<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for sRGB2HSV.c &amp; jxlsave.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for sRGB2HSV.c &amp; jxlsave.c
      </h3>
<h1 align="center">
        5.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>sRGB2HSV.c (10.256411%)<th>jxlsave.c (3.6253777%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(125-136)<td><a href="#" name="0">(541-552)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>sRGB2HSV.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;vips/vips.h&gt;
6 #include "pcolour.h"
7 typedef VipsColourCode VipssRGB2HSV;
8 typedef VipsColourCodeClass VipssRGB2HSVClass;
9 G_DEFINE_TYPE( VipssRGB2HSV, vips_sRGB2HSV, VIPS_TYPE_COLOUR_CODE );
10 static void
11 vips_sRGB2HSV_line( VipsColour *colour, VipsPel *out, VipsPel **in, int width )
12 {
13 	unsigned char *p = (unsigned char *) in[0];
14 	unsigned char *q = (unsigned char *) out;
15 	int i;
16 	for( i = 0; i &lt; width; i++ ) {
17 		unsigned char c_max;
18 		unsigned char c_min;
19 		float secondary_diff;
20 		float wrap_around_hue;
21 		if( p[1] &lt; p[2] ) {
22 			if( p[2] &lt; p[0] ) {
23 				c_max = p[0];
24 				c_min = p[1];
25 				secondary_diff = p[1] - p[2];
26 				wrap_around_hue = 255.0;
27 			} 
28 			else {
29 				c_max = p[2];
30 				c_min = VIPS_MIN( p[1], p[0] );
31 				secondary_diff = p[0] - p[1];
32 				wrap_around_hue = 170.0;
33 			}
34 		} 
35 		else {
36 			if( p[1] &lt; p[0] ) {
37 				c_max = p[0];
38 				c_min = p[2];
39 				secondary_diff = p[1] - p[2];
40 				wrap_around_hue = 0.0;
41 			} 
42 			else {
43 				c_max = p[1];
44 				c_min = VIPS_MIN( p[2], p[0] );
45 				secondary_diff = p[2] - p[0];
46 				wrap_around_hue = 85.0;
47 			}
48 		}
49 		if( c_max == 0 ) {
50 			q[0] = 0;
51 			q[1] = 0;
52 			q[2] = 0;
53 		} 
54 		else {
55 			unsigned char delta;
56 			q[2] = c_max;
57 			delta = c_max - c_min;
58 			if( delta == 0 ) 
59 				q[0] = 0;
60 			else 
61 				q[0] = 42.5 * (secondary_diff / (float) delta) +
62 				       	wrap_around_hue;
63 			q[1] = delta * 255.0 / (float) c_max;
64 		}
65 <a name="0"></a>		p += 3;
66 		q += 3;
67 	}
68 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
69 static void
70 vips_sRGB2HSV_class_init( VipssRGB2HSVClass *class )
71 {
72 	VipsObjectClass *object_class = (VipsObjectClass *) class;
73 	VipsColourClass *colour_class = VIPS_COLOUR_CLASS( class );
74 	object_class-&gt;nickname = "sRGB2HSV";
75 	object_class-&gt;description = _( "transform sRGB to HSV" );
76 	colour_class-&gt;process_line = vips_sRGB2HSV_line;</b></font>
77 }
78 static void
79 vips_sRGB2HSV_init( VipssRGB2HSV *sRGB2HSV )
80 {
81 	VipsColour *colour = VIPS_COLOUR( sRGB2HSV );
82 	VipsColourCode *code = VIPS_COLOUR_CODE( sRGB2HSV );
83 	colour-&gt;interpretation = VIPS_INTERPRETATION_HSV;
84 	colour-&gt;format = VIPS_FORMAT_UCHAR;
85 	colour-&gt;bands = 3;
86 	colour-&gt;input_bands = 3;
87 	code-&gt;input_coding = VIPS_CODING_NONE;
88 	code-&gt;input_format = VIPS_FORMAT_UCHAR;
89 	code-&gt;input_interpretation = VIPS_INTERPRETATION_sRGB;
90 }
91 int
92 vips_sRGB2HSV( VipsImage *in, VipsImage **out, ... )
93 {
94 	va_list ap;
95 	int result;
96 	va_start( ap, out );
97 	result = vips_call_split( "sRGB2HSV", ap, in, out );
98 	va_end( ap );
99 	return( result );
100 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>jxlsave.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #ifdef HAVE_LIBJXL
5 #include &lt;stdio.h&gt;
6 #include &lt;stdlib.h&gt;
7 #include &lt;string.h&gt;
8 #include &lt;vips/vips.h&gt;
9 #include &lt;vips/internal.h&gt;
10 #include &lt;jxl/encode.h&gt;
11 #include &lt;jxl/thread_parallel_runner.h&gt;
12 #include "pforeign.h"
13 #define OUTPUT_BUFFER_SIZE (4096)
14 typedef struct _VipsForeignSaveJxl {
15 	VipsForeignSave parent_object;
16 	VipsTarget *target;
17 	int tier;
18 	double distance;
19 	int effort;
20 	gboolean lossless;
21 	int Q;
22 	JxlBasicInfo info;
23 	JxlColorEncoding color_encoding;
24 	JxlPixelFormat format;
25 	void *runner;
26 	JxlEncoder *encoder;
27 	uint8_t output_buffer[OUTPUT_BUFFER_SIZE];
28 } VipsForeignSaveJxl;
29 typedef VipsForeignSaveClass VipsForeignSaveJxlClass;
30 G_DEFINE_ABSTRACT_TYPE( VipsForeignSaveJxl, vips_foreign_save_jxl, 
31 	VIPS_TYPE_FOREIGN_SAVE );
32 static void
33 vips_foreign_save_jxl_dispose( GObject *gobject )
34 {
35 	VipsForeignSaveJxl *jxl = (VipsForeignSaveJxl *) gobject;
36 	VIPS_FREEF( JxlThreadParallelRunnerDestroy, jxl-&gt;runner );
37 	VIPS_FREEF( JxlEncoderDestroy, jxl-&gt;encoder );
38 	G_OBJECT_CLASS( vips_foreign_save_jxl_parent_class )-&gt;
39 		dispose( gobject );
40 }
41 static void
42 vips_foreign_save_jxl_error( VipsForeignSaveJxl *jxl, const char *details )
43 {
44 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( jxl );
45 	vips_error( class-&gt;nickname, "error %s", details );
46 }
47 #ifdef DEBUG
48 static void
49 vips_foreign_save_jxl_print_info( JxlBasicInfo *info )
50 {
51 	printf( "JxlBasicInfo:\n" );
52 	printf( "    have_container = %d\n", info-&gt;have_container );
53 	printf( "    xsize = %d\n", info-&gt;xsize );
54 	printf( "    ysize = %d\n", info-&gt;ysize );
55 	printf( "    bits_per_sample = %d\n", info-&gt;bits_per_sample );
56 	printf( "    exponent_bits_per_sample = %d\n", 
57 		info-&gt;exponent_bits_per_sample );
58 	printf( "    intensity_target = %g\n", info-&gt;intensity_target );
59 	printf( "    min_nits = %g\n", info-&gt;min_nits );
60 	printf( "    relative_to_max_display = %d\n", 
61 		info-&gt;relative_to_max_display );
62 	printf( "    linear_below = %g\n", info-&gt;linear_below );
63 	printf( "    uses_original_profile = %d\n", 
64 		info-&gt;uses_original_profile );
65 	printf( "    have_preview = %d\n", info-&gt;have_preview );
66 	printf( "    have_animation = %d\n", info-&gt;have_animation );
67 	printf( "    orientation = %d\n", info-&gt;orientation );
68 	printf( "    num_color_channels = %d\n", info-&gt;num_color_channels );
69 	printf( "    num_extra_channels = %d\n", info-&gt;num_extra_channels );
70 	printf( "    alpha_bits = %d\n", info-&gt;alpha_bits );
71 	printf( "    alpha_exponent_bits = %d\n", info-&gt;alpha_exponent_bits );
72 	printf( "    alpha_premultiplied = %d\n", info-&gt;alpha_premultiplied );
73 	printf( "    preview.xsize = %d\n", info-&gt;preview.xsize );
74 	printf( "    preview.ysize = %d\n", info-&gt;preview.ysize );
75 	printf( "    animation.tps_numerator = %d\n", 
76 		info-&gt;animation.tps_numerator );
77 	printf( "    animation.tps_denominator = %d\n", 
78 		info-&gt;animation.tps_denominator );
79 	printf( "    animation.num_loops = %d\n", info-&gt;animation.num_loops );
80 	printf( "    animation.have_timecodes = %d\n", 
81 		info-&gt;animation.have_timecodes );
82 }
83 static void
84 vips_foreign_save_jxl_print_format( JxlPixelFormat *format )
85 {
86 	printf( "JxlPixelFormat:\n" );
87 	printf( "    data_type = " );
88 	switch( format-&gt;data_type ) {
89 	case JXL_TYPE_UINT8: 
90 		printf( "JXL_TYPE_UINT8" );
91 		break;
92 	case JXL_TYPE_UINT16: 
93 		printf( "JXL_TYPE_UINT16" );
94 		break;
95 	case JXL_TYPE_UINT32: 
96 		printf( "JXL_TYPE_UINT32" );
97 		break;
98 	case JXL_TYPE_FLOAT: 
99 		printf( "JXL_TYPE_FLOAT" );
100 		break;
101 	default:
102 		printf( "(unknown)" );
103 		break;
104 	}
105 	printf( "\n" );
106 	printf( "    num_channels = %d\n", format-&gt;num_channels );
107 	printf( "    endianness = %d\n", format-&gt;endianness );
108 	printf( "    align = %zd\n", format-&gt;align );
109 }
110 static void
111 vips_foreign_save_jxl_print_status( JxlEncoderStatus status )
112 {
113 	switch( status ) {
114 	case JXL_ENC_SUCCESS:
115 		printf( "JXL_ENC_SUCCESS\n" );
116 		break;
117 	case JXL_ENC_ERROR:
118 		printf( "JXL_ENC_ERROR\n" );
119 		break;
120 	case JXL_ENC_NEED_MORE_OUTPUT:
121 		printf( "JXL_ENC_NEED_MORE_OUTPUT\n" );
122 		break;
123 	case JXL_ENC_NOT_SUPPORTED:
124 		printf( "JXL_ENC_NOT_SUPPORTED\n" );
125 		break;
126 	default:
127 		printf( "JXL_ENC_&lt;unknown&gt;\n" );
128 		break;
129 	}
130 }
131 static int
132 vips_foreign_save_jxl_build( VipsObject *object )
133 {
134 	VipsForeignSave *save = (VipsForeignSave *) object;
135 	VipsForeignSaveJxl *jxl = (VipsForeignSaveJxl *) object;
136 	JxlEncoderOptions *options;
137 	JxlEncoderStatus status;
138 	if( VIPS_OBJECT_CLASS( vips_foreign_save_jxl_parent_class )-&gt;
139 		build( object ) )
140 		return( -1 );
141 	if( !vips_object_argument_isset( object, "distance" ) ) 
142 		jxl-&gt;distance = jxl-&gt;Q &gt;= 30 ?
143 			0.1 + (100 - jxl-&gt;Q) * 0.09 :
144 			6.4 + pow(2.5, (30 - jxl-&gt;Q) / 5.0f) / 6.25f;
145 	if( jxl-&gt;distance == 0 )
146 		jxl-&gt;lossless = TRUE;
147 	jxl-&gt;runner = JxlThreadParallelRunnerCreate( NULL, 
148 		vips_concurrency_get() );
149 	jxl-&gt;encoder = JxlEncoderCreate( NULL );
150 	if( JxlEncoderSetParallelRunner( jxl-&gt;encoder, 
151 		JxlThreadParallelRunner, jxl-&gt;runner ) ) {
152 		vips_foreign_save_jxl_error( jxl, 
153 			"JxlDecoderSetParallelRunner" );
154 		return( -1 );
155 	}
156 	switch( save-&gt;ready-&gt;BandFmt ) {
157 	case VIPS_FORMAT_UCHAR:
158 		jxl-&gt;info.bits_per_sample = 8;
159 		jxl-&gt;info.exponent_bits_per_sample = 0;
160 		jxl-&gt;format.data_type = JXL_TYPE_UINT8;
161 		break;
162 	case VIPS_FORMAT_USHORT:
163 		jxl-&gt;info.bits_per_sample = 16;
164 		jxl-&gt;info.exponent_bits_per_sample = 0;
165 		jxl-&gt;format.data_type = JXL_TYPE_UINT16;
166 		break;
167 	case VIPS_FORMAT_UINT:
168 		jxl-&gt;info.bits_per_sample = 32;
169 		jxl-&gt;info.exponent_bits_per_sample = 0;
170 		jxl-&gt;format.data_type = JXL_TYPE_UINT32;
171 		break;
172 	case VIPS_FORMAT_FLOAT:
173 		jxl-&gt;info.bits_per_sample = 32;
174 		jxl-&gt;info.exponent_bits_per_sample = 8;
175 		jxl-&gt;format.data_type = JXL_TYPE_FLOAT;
176 		break;
177 	default:
178 		g_assert_not_reached();
179 		break;
180 	}
181 	switch( save-&gt;ready-&gt;Type ) {
182 	case VIPS_INTERPRETATION_B_W:
183 	case VIPS_INTERPRETATION_GREY16:
184 		jxl-&gt;info.num_color_channels = 1;
185 		break;
186 	case VIPS_INTERPRETATION_sRGB:
187 	case VIPS_INTERPRETATION_scRGB:
188 	case VIPS_INTERPRETATION_RGB16:
189 		jxl-&gt;info.num_color_channels = 3;
190 		break;
191 	default:
192 		jxl-&gt;info.num_color_channels = save-&gt;ready-&gt;Bands;
193 	}
194 	jxl-&gt;info.num_extra_channels = VIPS_MAX( 0, 
195 		save-&gt;ready-&gt;Bands - jxl-&gt;info.num_color_channels );
196 	jxl-&gt;info.xsize = save-&gt;ready-&gt;Xsize;
197 	jxl-&gt;info.ysize = save-&gt;ready-&gt;Ysize;
198 	jxl-&gt;format.num_channels = save-&gt;ready-&gt;Bands;
199 	jxl-&gt;format.endianness = JXL_NATIVE_ENDIAN;
200 	jxl-&gt;format.align = 0;
201 	if( vips_image_hasalpha( save-&gt;ready ) ) {
202 		jxl-&gt;info.alpha_bits = jxl-&gt;info.bits_per_sample;
203 		jxl-&gt;info.alpha_exponent_bits = 
204 			jxl-&gt;info.exponent_bits_per_sample;
205 	}
206 	else {
207 		jxl-&gt;info.alpha_exponent_bits = 0;
208 		jxl-&gt;info.alpha_bits = 0;
209 	}
210 	if( vips_image_get_typeof( save-&gt;ready, "stonits" ) ) {
211 		double stonits;
212 		if( vips_image_get_double( save-&gt;ready, "stonits", &amp;stonits ) )
213 			return( -1 );
214 		jxl-&gt;info.intensity_target = stonits;
215 	}
216 	jxl-&gt;info.uses_original_profile = JXL_FALSE;
217 	if( JxlEncoderSetBasicInfo( jxl-&gt;encoder, &amp;jxl-&gt;info ) ) {
218 		vips_foreign_save_jxl_error( jxl, "JxlEncoderSetBasicInfo" );
219 		return( -1 );
220 	}
221 	JxlColorEncodingSetToSRGB( &amp;jxl-&gt;color_encoding, 
222 		jxl-&gt;format.num_channels &lt; 3 );
223 	if( JxlEncoderSetColorEncoding( jxl-&gt;encoder, &amp;jxl-&gt;color_encoding ) ) {
224 		vips_foreign_save_jxl_error( jxl, 
225 			"JxlEncoderSetColorEncoding" );
226 		return( -1 );
227 	}
228 	if( vips_image_wio_input( save-&gt;ready ) )
229 		return( -1 );
230 	options = JxlEncoderOptionsCreate( jxl-&gt;encoder, NULL );
231 	JxlEncoderOptionsSetDecodingSpeed( options, jxl-&gt;tier );
232 	JxlEncoderOptionsSetDistance( options, jxl-&gt;distance );
233 	JxlEncoderOptionsSetEffort( options, jxl-&gt;effort );
234 	JxlEncoderOptionsSetLossless( options, jxl-&gt;lossless );
235 #ifdef DEBUG
236 	vips_foreign_save_jxl_print_info( &amp;jxl-&gt;info );
237 	vips_foreign_save_jxl_print_format( &amp;jxl-&gt;format );
238 	printf( "JxlEncoderOptions:\n" );
239 	printf( "    tier = %d\n", jxl-&gt;tier );
240 	printf( "    distance = %g\n", jxl-&gt;distance );
241 	printf( "    effort = %d\n", jxl-&gt;effort );
242 	printf( "    lossless = %d\n", jxl-&gt;lossless );
243 	if( JxlEncoderAddImageFrame( options, &amp;jxl-&gt;format, 
244 		VIPS_IMAGE_ADDR( save-&gt;ready, 0, 0 ),
245 		VIPS_IMAGE_SIZEOF_IMAGE( save-&gt;ready ) ) ) { 
246 		vips_foreign_save_jxl_error( jxl, "JxlEncoderAddImageFrame" );
247 		return( -1 );
248 	}
249 	do {
250 		uint8_t *out;
251 		size_t avail_out;
252 		out = jxl-&gt;output_buffer;
253 		avail_out = OUTPUT_BUFFER_SIZE;
254 		status = JxlEncoderProcessOutput( jxl-&gt;encoder,
255 			&amp;out, &amp;avail_out );
256 		switch( status ) {
257 		case JXL_ENC_SUCCESS:
258 		case JXL_ENC_NEED_MORE_OUTPUT:
259 			if( vips_target_write( jxl-&gt;target,
260 				jxl-&gt;output_buffer, 
261 				OUTPUT_BUFFER_SIZE - avail_out ) )
262 				return( -1 );
263 			break;
264 		default:
265 			vips_foreign_save_jxl_error( jxl, 
266 				"JxlEncoderProcessOutput" );
267 #ifdef DEBUG
268 			vips_foreign_save_jxl_print_status( status );
269 			return( -1 );
270 		}
271 	} while( status != JXL_ENC_SUCCESS );
272 	vips_target_finish( jxl-&gt;target );
273 	return( 0 );
274 }
275 #define UC VIPS_FORMAT_UCHAR
276 #define US VIPS_FORMAT_USHORT
277 #define UI VIPS_FORMAT_UINT
278 #define F VIPS_FORMAT_FLOAT
279 static int bandfmt_jpeg[10] = {
280 	UC, UC, US, US, UI, UI, F, F, F, F
281 };
282 static void
283 vips_foreign_save_jxl_class_init( VipsForeignSaveJxlClass *class )
284 {
285 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
286 	VipsObjectClass *object_class = (VipsObjectClass *) class;
287 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
288 	VipsForeignSaveClass *save_class = (VipsForeignSaveClass *) class;
289 	gobject_class-&gt;dispose = vips_foreign_save_jxl_dispose;
290 	gobject_class-&gt;set_property = vips_object_set_property;
291 	gobject_class-&gt;get_property = vips_object_get_property;
292 	object_class-&gt;nickname = "jxlsave_base";
293 	object_class-&gt;description = _( "save image in JPEG-XL format" );
294 	object_class-&gt;build = vips_foreign_save_jxl_build;
295 	foreign_class-&gt;suffs = vips__jxl_suffs;
296 	save_class-&gt;saveable = VIPS_SAVEABLE_ANY;
297 	save_class-&gt;format_table = bandfmt_jpeg;
298 	VIPS_ARG_INT( class, "tier", 10, 
299 		_( "Tier" ), 
300 		_( "Decode speed tier" ),
301 		VIPS_ARGUMENT_OPTIONAL_INPUT,
302 		G_STRUCT_OFFSET( VipsForeignSaveJxl, tier ),
303 		0, 4, 0 );
304 	VIPS_ARG_DOUBLE( class, "distance", 11, 
305 		_( "Distance" ), 
306 		_( "Target butteraugli distance" ),
307 		VIPS_ARGUMENT_OPTIONAL_INPUT,
308 		G_STRUCT_OFFSET( VipsForeignSaveJxl, distance ),
309 		0, 15, 1.0 );
310 	VIPS_ARG_INT( class, "effort", 12, 
311 		_( "effort" ), 
312 		_( "Encoding effort" ),
313 		VIPS_ARGUMENT_OPTIONAL_INPUT,
314 		G_STRUCT_OFFSET( VipsForeignSaveJxl, effort ),
315 		3, 9, 7 );
316 	VIPS_ARG_BOOL( class, "lossless", 13, 
317 		_( "Lossless" ), 
318 		_( "Enable lossless compression" ),
319 		VIPS_ARGUMENT_OPTIONAL_INPUT,
320 		G_STRUCT_OFFSET( VipsForeignSaveJxl, lossless ),
321 		FALSE ); 
322 	VIPS_ARG_INT( class, "Q", 14, 
323 		_( "Q" ), 
324 		_( "Quality factor" ),
325 		VIPS_ARGUMENT_OPTIONAL_INPUT,
326 		G_STRUCT_OFFSET( VipsForeignSaveJxl, Q ),
327 		0, 100, 75 );
328 }
329 static void
330 vips_foreign_save_jxl_init( VipsForeignSaveJxl *jxl )
331 {
332 	jxl-&gt;tier = 0;
333 	jxl-&gt;distance = 1.0;
334 	jxl-&gt;effort = 7;
335 	jxl-&gt;lossless = FALSE;
336 	jxl-&gt;Q = 75;
337 }
338 typedef struct _VipsForeignSaveJxlFile {
339 	VipsForeignSaveJxl parent_object;
340 	char *filename; 
341 } VipsForeignSaveJxlFile;
342 typedef VipsForeignSaveJxlClass VipsForeignSaveJxlFileClass;
343 G_DEFINE_TYPE( VipsForeignSaveJxlFile, vips_foreign_save_jxl_file, 
344 	vips_foreign_save_jxl_get_type() );
345 static int
346 vips_foreign_save_jxl_file_build( VipsObject *object )
347 {
348 	VipsForeignSaveJxl *jxl = (VipsForeignSaveJxl *) object;
349 	VipsForeignSaveJxlFile *file = (VipsForeignSaveJxlFile *) object;
350 	if( !(jxl-&gt;target = vips_target_new_to_file( file-&gt;filename )) )
351 		return( -1 );
352 	if( VIPS_OBJECT_CLASS( vips_foreign_save_jxl_file_parent_class )-&gt;
353 		build( object ) )
354 <a name="0"></a>		return( -1 );
355 	return( 0 );
356 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
357 static void
358 vips_foreign_save_jxl_file_class_init( VipsForeignSaveJxlFileClass *class )
359 {
360 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
361 	VipsObjectClass *object_class = (VipsObjectClass *) class;
362 	gobject_class-&gt;set_property = vips_object_set_property;
363 	gobject_class-&gt;get_property = vips_object_get_property;
364 	object_class-&gt;nickname = "jxlsave";</b></font>
365 	object_class-&gt;build = vips_foreign_save_jxl_file_build;
366 	VIPS_ARG_STRING( class, "filename", 1, 
367 		_( "Filename" ),
368 		_( "Filename to load from" ),
369 		VIPS_ARGUMENT_REQUIRED_INPUT, 
370 		G_STRUCT_OFFSET( VipsForeignSaveJxlFile, filename ),
371 		NULL );
372 }
373 static void
374 vips_foreign_save_jxl_file_init( VipsForeignSaveJxlFile *file )
375 {
376 }
377 typedef struct _VipsForeignSaveJxlBuffer {
378 	VipsForeignSaveJxl parent_object;
379 	VipsArea *buf;
380 } VipsForeignSaveJxlBuffer;
381 typedef VipsForeignSaveJxlClass VipsForeignSaveJxlBufferClass;
382 G_DEFINE_TYPE( VipsForeignSaveJxlBuffer, vips_foreign_save_jxl_buffer, 
383 	vips_foreign_save_jxl_get_type() );
384 static int
385 vips_foreign_save_jxl_buffer_build( VipsObject *object )
386 {
387 	VipsForeignSaveJxl *jxl = (VipsForeignSaveJxl *) object;
388 	VipsForeignSaveJxlBuffer *buffer = 
389 		(VipsForeignSaveJxlBuffer *) object;
390 	VipsBlob *blob;
391 	if( !(jxl-&gt;target = vips_target_new_to_memory()) )
392 		return( -1 );
393 	if( VIPS_OBJECT_CLASS( vips_foreign_save_jxl_buffer_parent_class )-&gt;
394 		build( object ) )
395 		return( -1 );
396 	g_object_get( jxl-&gt;target, "blob", &amp;blob, NULL );
397 	g_object_set( buffer, "buffer", blob, NULL );
398 	vips_area_unref( VIPS_AREA( blob ) );
399 	return( 0 );
400 }
401 static void
402 vips_foreign_save_jxl_buffer_class_init( 
403 	VipsForeignSaveJxlBufferClass *class )
404 {
405 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
406 	VipsObjectClass *object_class = (VipsObjectClass *) class;
407 	gobject_class-&gt;set_property = vips_object_set_property;
408 	gobject_class-&gt;get_property = vips_object_get_property;
409 	object_class-&gt;nickname = "jxlsave_buffer";
410 	object_class-&gt;build = vips_foreign_save_jxl_buffer_build;
411 	VIPS_ARG_BOXED( class, "buffer", 1, 
412 		_( "Buffer" ),
413 		_( "Buffer to save to" ),
414 		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
415 		G_STRUCT_OFFSET( VipsForeignSaveJxlBuffer, buf ),
416 		VIPS_TYPE_BLOB );
417 }
418 static void
419 vips_foreign_save_jxl_buffer_init( VipsForeignSaveJxlBuffer *buffer )
420 {
421 }
422 typedef struct _VipsForeignSaveJxlTarget {
423 	VipsForeignSaveJxl parent_object;
424 	VipsTarget *target;
425 } VipsForeignSaveJxlTarget;
426 typedef VipsForeignSaveJxlClass VipsForeignSaveJxlTargetClass;
427 G_DEFINE_TYPE( VipsForeignSaveJxlTarget, vips_foreign_save_jxl_target, 
428 	vips_foreign_save_jxl_get_type() );
429 static int
430 vips_foreign_save_jxl_target_build( VipsObject *object )
431 {
432 	VipsForeignSaveJxl *jxl = (VipsForeignSaveJxl *) object;
433 	VipsForeignSaveJxlTarget *target = 
434 		(VipsForeignSaveJxlTarget *) object;
435 	if( target-&gt;target ) {
436 		jxl-&gt;target = target-&gt;target;
437 		g_object_ref( jxl-&gt;target );
438 	}
439 	if( VIPS_OBJECT_CLASS( vips_foreign_save_jxl_target_parent_class )-&gt;
440 		build( object ) )
441 		return( -1 );
442 	return( 0 );
443 }
444 static void
445 vips_foreign_save_jxl_target_class_init( 
446 	VipsForeignSaveJxlTargetClass *class )
447 {
448 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
449 	VipsObjectClass *object_class = (VipsObjectClass *) class;
450 	gobject_class-&gt;set_property = vips_object_set_property;
451 	gobject_class-&gt;get_property = vips_object_get_property;
452 	object_class-&gt;nickname = "jxlsave_target";
453 	object_class-&gt;build = vips_foreign_save_jxl_target_build;
454 	VIPS_ARG_OBJECT( class, "target", 1,
455 		_( "Target" ),
456 		_( "Target to save to" ),
457 		VIPS_ARGUMENT_REQUIRED_INPUT, 
458 		G_STRUCT_OFFSET( VipsForeignSaveJxlTarget, target ),
459 		VIPS_TYPE_TARGET );
460 }
461 static void
462 vips_foreign_save_jxl_target_init( VipsForeignSaveJxlTarget *target )
463 {
464 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
