
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.741573033707865%, Tokens: 9</h2>
        <div class="column">
            <h3>small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-obfs.c</h3>
            <pre><code>1  #include <string.h>
2  #include <stdlib.h>
3  #include "utils.h"
4  #include "obfs.h"
5  int rand_bytes(uint8_t *output, int len);
6  #define OBFS_HMAC_SHA1_LEN 10
7  #include "obfsutil.c"
8  #include "crc32.c"
9  #include "base64.c"
10  #include "http_simple.c"
11  #include "tls1.2_ticket.c"
12  #include "verify.c"
13  #include "auth.c"
14  void * init_data() {
15      return malloc(1);
16  }
17  obfs * new_obfs() {
18      obfs * self = (obfs*)malloc(sizeof(obfs));
19      self->l_data = NULL;
20      return self;
21  }
22  void set_server_info(obfs *self, server_info *server) {
23      memmove(&self->server, server, sizeof(server_info));
24  }
25  void get_server_info(obfs *self, server_info *server) {
26      memmove(server, &self->server, sizeof(server_info));
27  }
28  void dispose_obfs(obfs *self) {
29      free(self);
30  }
31  obfs_class * new_obfs_class(char *plugin_name)
32  {
33      if (plugin_name == NULL)
34          return NULL;
35      if (strcmp(plugin_name, "origin") == 0)
36          return NULL;
37      if (strcmp(plugin_name, "plain") == 0)
38          return NULL;
39      init_crc32_table();
40      init_shift128plus();
41      if (strcmp(plugin_name, "http_simple") == 0) {
42          obfs_class * plugin = (obfs_class*)malloc(sizeof(obfs));
43          plugin->init_data = init_data;
44          plugin->new_obfs = http_simple_new_obfs;
45          plugin->get_server_info = get_server_info;
46          plugin->set_server_info = set_server_info;
47          plugin->dispose = http_simple_dispose;
48          plugin->client_encode = http_simple_client_encode;
49          plugin->client_decode = http_simple_client_decode;
50          plugin->server_encode = http_simple_server_encode;
51          plugin->server_decode = http_simple_server_decode;
52          return plugin;
53      } else if (strcmp(plugin_name, "http_post") == 0) {
54          obfs_class * plugin = (obfs_class*)malloc(sizeof(obfs));
55          plugin->init_data = init_data;
56          plugin->new_obfs = http_simple_new_obfs;
57          plugin->get_server_info = get_server_info;
58          plugin->set_server_info = set_server_info;
59          plugin->dispose = http_simple_dispose;
60          plugin->client_encode = http_post_client_encode;
61          plugin->client_decode = http_simple_client_decode;
62          plugin->server_encode = http_simple_server_encode;
63          plugin->server_decode = http_simple_server_decode;
64          return plugin;
65      } else if (strcmp(plugin_name, "tls1.2_ticket_auth") == 0) {
66          obfs_class * plugin = (obfs_class*)malloc(sizeof(obfs));
67          plugin->init_data = tls12_ticket_auth_init_data;
68          plugin->new_obfs = tls12_ticket_auth_new_obfs;
69          plugin->get_server_info = get_server_info;
70          plugin->set_server_info = set_server_info;
71          plugin->dispose = tls12_ticket_auth_dispose;
72          plugin->client_encode = tls12_ticket_auth_client_encode;
73          plugin->client_decode = tls12_ticket_auth_client_decode;
74          plugin->server_encode = tls12_ticket_auth_server_encode;
75          plugin->server_decode = tls12_ticket_auth_server_decode;
76          return plugin;
77      } else if (strcmp(plugin_name, "verify_simple") == 0) {
78          obfs_class * plugin = (obfs_class*)malloc(sizeof(obfs));
79          plugin->init_data = init_data;
80          plugin->new_obfs = verify_simple_new_obfs;
81          plugin->get_server_info = get_server_info;
82          plugin->set_server_info = set_server_info;
83          plugin->dispose = verify_simple_dispose;
84          plugin->client_pre_encrypt = verify_simple_client_pre_encrypt;
85          plugin->client_post_decrypt = verify_simple_client_post_decrypt;
86          plugin->client_udp_pre_encrypt = NULL;
87          plugin->client_udp_post_decrypt = NULL;
88          plugin->server_pre_encrypt = verify_simple_server_pre_encrypt;
89          plugin->server_post_decrypt = verify_simple_server_post_decrypt;
90          plugin->server_udp_pre_encrypt = NULL;
91          plugin->server_udp_post_decrypt = NULL;
92          return plugin;
93      } else if (strcmp(plugin_name, "auth_simple") == 0) {
94          obfs_class * plugin = (obfs_class*)malloc(sizeof(obfs));
95          plugin->init_data = auth_simple_init_data;
96          plugin->new_obfs = auth_simple_new_obfs;
97          plugin->get_server_info = get_server_info;
98          plugin->set_server_info = set_server_info;
99          plugin->dispose = auth_simple_dispose;
100          plugin->client_pre_encrypt = auth_simple_client_pre_encrypt;
101          plugin->client_post_decrypt = auth_simple_client_post_decrypt;
102          plugin->client_udp_pre_encrypt = NULL;
103          plugin->client_udp_post_decrypt = NULL;
104          return plugin;
105      } else if (strcmp(plugin_name, "auth_sha1") == 0) {
106          obfs_class * plugin = (obfs_class*)malloc(sizeof(obfs));
107          plugin->init_data = auth_simple_init_data;
108          plugin->new_obfs = auth_simple_new_obfs;
109          plugin->get_server_info = get_server_info;
110          plugin->set_server_info = set_server_info;
111          plugin->dispose = auth_simple_dispose;
112          plugin->client_pre_encrypt = auth_sha1_client_pre_encrypt;
113          plugin->client_post_decrypt = auth_sha1_client_post_decrypt;
114          plugin->client_udp_pre_encrypt = NULL;
115          plugin->client_udp_post_decrypt = NULL;
116          return plugin;
117      } else if (strcmp(plugin_name, "auth_sha1_v2") == 0) {
118          obfs_class * plugin = (obfs_class*)malloc(sizeof(obfs));
119          plugin->init_data = auth_simple_init_data;
120          plugin->new_obfs = auth_simple_new_obfs;
121          plugin->get_server_info = get_server_info;
122          plugin->set_server_info = set_server_info;
123          plugin->dispose = auth_simple_dispose;
124          plugin->client_pre_encrypt = auth_sha1_v2_client_pre_encrypt;
125          plugin->client_post_decrypt = auth_sha1_v2_client_post_decrypt;
126          plugin->client_udp_pre_encrypt = NULL;
127          plugin->client_udp_post_decrypt = NULL;
128          return plugin;
129      } else if (strcmp(plugin_name, "auth_sha1_v4") == 0) {
130          obfs_class * plugin = (obfs_class*)malloc(sizeof(obfs));
131          plugin->init_data = auth_simple_init_data;
132          plugin->new_obfs = auth_simple_new_obfs;
133          plugin->get_server_info = get_server_info;
134          plugin->set_server_info = set_server_info;
135          plugin->dispose = auth_simple_dispose;
136          plugin->client_pre_encrypt = auth_sha1_v4_client_pre_encrypt;
137          plugin->client_post_decrypt = auth_sha1_v4_client_post_decrypt;
138          plugin->client_udp_pre_encrypt = NULL;
139          plugin->client_udp_post_decrypt = NULL;
140          return plugin;
141      } else if (strcmp(plugin_name, "auth_aes128_md5") == 0) {
142          obfs_class * plugin = (obfs_class*)malloc(sizeof(obfs));
<span onclick='openModal()' class='match'>143          plugin->init_data = auth_simple_init_data;
144          plugin->new_obfs = auth_aes128_md5_new_obfs;
145          plugin->get_server_info = get_server_info;
146          plugin->set_server_info = set_server_info;
147          plugin->dispose = auth_simple_dispose;
148          plugin->client_pre_encrypt = auth_aes128_sha1_client_pre_encrypt;
149          plugin->client_post_decrypt = auth_aes128_sha1_client_post_decrypt;
150          plugin->client_udp_pre_encrypt = auth_aes128_sha1_client_udp_pre_encrypt;
151          plugin->client_udp_post_decrypt = auth_aes128_sha1_client_udp_post_decrypt;
</span>152          return plugin;
153      } else if (strcmp(plugin_name, "auth_aes128_sha1") == 0) {
154          obfs_class * plugin = (obfs_class*)malloc(sizeof(obfs));
155          plugin->init_data = auth_simple_init_data;
156          plugin->new_obfs = auth_aes128_sha1_new_obfs;
157          plugin->get_server_info = get_server_info;
158          plugin->set_server_info = set_server_info;
159          plugin->dispose = auth_simple_dispose;
160          plugin->client_pre_encrypt = auth_aes128_sha1_client_pre_encrypt;
161          plugin->client_post_decrypt = auth_aes128_sha1_client_post_decrypt;
162          plugin->client_udp_pre_encrypt = auth_aes128_sha1_client_udp_pre_encrypt;
163          plugin->client_udp_post_decrypt = auth_aes128_sha1_client_udp_post_decrypt;
164          return plugin;
165      }
166      LOGE("Load obfs '%s' failed", plugin_name);
167      return NULL;
168  }
169  void free_obfs_class(obfs_class *plugin) {
170      free(plugin);
171  }
</code></pre>
        </div>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-subdir.c</h3>
            <pre><code>1  #include <fuse_config.h>
2  #include <fuse.h>
3  #include <stdio.h>
4  #include <stdlib.h>
5  #include <stddef.h>
6  #include <string.h>
7  #include <errno.h>
8  struct subdir {
9  	char *base;
10  	size_t baselen;
11  	int rellinks;
12  	struct fuse_fs *next;
13  };
14  static struct subdir *subdir_get(void)
15  {
16  	return fuse_get_context()->private_data;
17  }
18  static int subdir_addpath(struct subdir *d, const char *path, char **newpathp)
19  {
20  	char *newpath = NULL;
21  	if (path != NULL) {
22  		unsigned newlen = d->baselen + strlen(path);
23  		newpath = malloc(newlen + 2);
24  		if (!newpath)
25  			return -ENOMEM;
26  		if (path[0] == '/')
27  			path++;
28  		strcpy(newpath, d->base);
29  		strcpy(newpath + d->baselen, path);
30  		if (!newpath[0])
31  			strcpy(newpath, ".");
32  	}
33  	*newpathp = newpath;
34  	return 0;
35  }
36  static int subdir_getattr(const char *path, struct stat *stbuf,
37  			  struct fuse_file_info *fi)
38  {
39  	struct subdir *d = subdir_get();
40  	char *newpath;
41  	int err = subdir_addpath(d, path, &newpath);
42  	if (!err) {
43  		err = fuse_fs_getattr(d->next, newpath, stbuf, fi);
44  		free(newpath);
45  	}
46  	return err;
47  }
48  static int subdir_access(const char *path, int mask)
49  {
50  	struct subdir *d = subdir_get();
51  	char *newpath;
52  	int err = subdir_addpath(d, path, &newpath);
53  	if (!err) {
54  		err = fuse_fs_access(d->next, newpath, mask);
55  		free(newpath);
56  	}
57  	return err;
58  }
59  static int count_components(const char *p)
60  {
61  	int ctr;
62  	for (; *p == '/'; p++);
63  	for (ctr = 0; *p; ctr++) {
64  		for (; *p && *p != '/'; p++);
65  		for (; *p == '/'; p++);
66  	}
67  	return ctr;
68  }
69  static void strip_common(const char **sp, const char **tp)
70  {
71  	const char *s = *sp;
72  	const char *t = *tp;
73  	do {
74  		for (; *s == '/'; s++);
75  		for (; *t == '/'; t++);
76  		*tp = t;
77  		*sp = s;
78  		for (; *s == *t && *s && *s != '/'; s++, t++);
79  	} while ((*s == *t && *s) || (!*s && *t == '/') || (*s == '/' && !*t));
80  }
81  static void transform_symlink(struct subdir *d, const char *path,
82  			      char *buf, size_t size)
83  {
84  	const char *l = buf;
85  	size_t llen;
86  	char *s;
87  	int dotdots;
88  	int i;
89  	if (l[0] != '/' || d->base[0] != '/')
90  		return;
91  	strip_common(&l, &path);
92  	if (l - buf < (long) d->baselen)
93  		return;
94  	dotdots = count_components(path);
95  	if (!dotdots)
96  		return;
97  	dotdots--;
98  	llen = strlen(l);
99  	if (dotdots * 3 + llen + 2 > size)
100  		return;
101  	s = buf + dotdots * 3;
102  	if (llen)
103  		memmove(s, l, llen + 1);
104  	else if (!dotdots)
105  		strcpy(s, ".");
106  	else
107  		*s = '\0';
108  	for (s = buf, i = 0; i < dotdots; i++, s += 3)
109  		memcpy(s, "../", 3);
110  }
111  static int subdir_readlink(const char *path, char *buf, size_t size)
112  {
113  	struct subdir *d = subdir_get();
114  	char *newpath;
115  	int err = subdir_addpath(d, path, &newpath);
116  	if (!err) {
117  		err = fuse_fs_readlink(d->next, newpath, buf, size);
118  		if (!err && d->rellinks)
119  			transform_symlink(d, newpath, buf, size);
120  		free(newpath);
121  	}
122  	return err;
123  }
124  static int subdir_opendir(const char *path, struct fuse_file_info *fi)
125  {
126  	struct subdir *d = subdir_get();
127  	char *newpath;
128  	int err = subdir_addpath(d, path, &newpath);
129  	if (!err) {
130  		err = fuse_fs_opendir(d->next, newpath, fi);
131  		free(newpath);
132  	}
133  	return err;
134  }
135  static int subdir_readdir(const char *path, void *buf,
136  			  fuse_fill_dir_t filler, off_t offset,
137  			  struct fuse_file_info *fi,
138  			  enum fuse_readdir_flags flags)
139  {
140  	struct subdir *d = subdir_get();
141  	char *newpath;
142  	int err = subdir_addpath(d, path, &newpath);
143  	if (!err) {
144  		err = fuse_fs_readdir(d->next, newpath, buf, filler, offset,
145  				      fi, flags);
146  		free(newpath);
147  	}
148  	return err;
149  }
150  static int subdir_releasedir(const char *path, struct fuse_file_info *fi)
151  {
152  	struct subdir *d = subdir_get();
153  	char *newpath;
154  	int err = subdir_addpath(d, path, &newpath);
155  	if (!err) {
156  		err = fuse_fs_releasedir(d->next, newpath, fi);
157  		free(newpath);
158  	}
159  	return err;
160  }
161  static int subdir_mknod(const char *path, mode_t mode, dev_t rdev)
162  {
163  	struct subdir *d = subdir_get();
164  	char *newpath;
165  	int err = subdir_addpath(d, path, &newpath);
166  	if (!err) {
167  		err = fuse_fs_mknod(d->next, newpath, mode, rdev);
168  		free(newpath);
169  	}
170  	return err;
171  }
172  static int subdir_mkdir(const char *path, mode_t mode)
173  {
174  	struct subdir *d = subdir_get();
175  	char *newpath;
176  	int err = subdir_addpath(d, path, &newpath);
177  	if (!err) {
178  		err = fuse_fs_mkdir(d->next, newpath, mode);
179  		free(newpath);
180  	}
181  	return err;
182  }
183  static int subdir_unlink(const char *path)
184  {
185  	struct subdir *d = subdir_get();
186  	char *newpath;
187  	int err = subdir_addpath(d, path, &newpath);
188  	if (!err) {
189  		err = fuse_fs_unlink(d->next, newpath);
190  		free(newpath);
191  	}
192  	return err;
193  }
194  static int subdir_rmdir(const char *path)
195  {
196  	struct subdir *d = subdir_get();
197  	char *newpath;
198  	int err = subdir_addpath(d, path, &newpath);
199  	if (!err) {
200  		err = fuse_fs_rmdir(d->next, newpath);
201  		free(newpath);
202  	}
203  	return err;
204  }
205  static int subdir_symlink(const char *from, const char *path)
206  {
207  	struct subdir *d = subdir_get();
208  	char *newpath;
209  	int err = subdir_addpath(d, path, &newpath);
210  	if (!err) {
211  		err = fuse_fs_symlink(d->next, from, newpath);
212  		free(newpath);
213  	}
214  	return err;
215  }
216  static int subdir_rename(const char *from, const char *to, unsigned int flags)
217  {
218  	struct subdir *d = subdir_get();
219  	char *newfrom;
220  	char *newto;
221  	int err = subdir_addpath(d, from, &newfrom);
222  	if (!err) {
223  		err = subdir_addpath(d, to, &newto);
224  		if (!err) {
225  			err = fuse_fs_rename(d->next, newfrom, newto, flags);
226  			free(newto);
227  		}
228  		free(newfrom);
229  	}
230  	return err;
231  }
232  static int subdir_link(const char *from, const char *to)
233  {
234  	struct subdir *d = subdir_get();
235  	char *newfrom;
236  	char *newto;
237  	int err = subdir_addpath(d, from, &newfrom);
238  	if (!err) {
239  		err = subdir_addpath(d, to, &newto);
240  		if (!err) {
241  			err = fuse_fs_link(d->next, newfrom, newto);
242  			free(newto);
243  		}
244  		free(newfrom);
245  	}
246  	return err;
247  }
248  static int subdir_chmod(const char *path, mode_t mode,
249  			struct fuse_file_info *fi)
250  {
251  	struct subdir *d = subdir_get();
252  	char *newpath;
253  	int err = subdir_addpath(d, path, &newpath);
254  	if (!err) {
255  		err = fuse_fs_chmod(d->next, newpath, mode, fi);
256  		free(newpath);
257  	}
258  	return err;
259  }
260  static int subdir_chown(const char *path, uid_t uid, gid_t gid,
261  			struct fuse_file_info *fi)
262  {
263  	struct subdir *d = subdir_get();
264  	char *newpath;
265  	int err = subdir_addpath(d, path, &newpath);
266  	if (!err) {
267  		err = fuse_fs_chown(d->next, newpath, uid, gid, fi);
268  		free(newpath);
269  	}
270  	return err;
271  }
272  static int subdir_truncate(const char *path, off_t size,
273  			   struct fuse_file_info *fi)
274  {
275  	struct subdir *d = subdir_get();
276  	char *newpath;
277  	int err = subdir_addpath(d, path, &newpath);
278  	if (!err) {
279  		err = fuse_fs_truncate(d->next, newpath, size, fi);
280  		free(newpath);
281  	}
282  	return err;
283  }
284  static int subdir_utimens(const char *path, const struct timespec ts[2],
285  			  struct fuse_file_info *fi)
286  {
287  	struct subdir *d = subdir_get();
288  	char *newpath;
289  	int err = subdir_addpath(d, path, &newpath);
290  	if (!err) {
291  		err = fuse_fs_utimens(d->next, newpath, ts, fi);
292  		free(newpath);
293  	}
294  	return err;
295  }
296  static int subdir_create(const char *path, mode_t mode,
297  			 struct fuse_file_info *fi)
298  {
299  	struct subdir *d = subdir_get();
300  	char *newpath;
301  	int err = subdir_addpath(d, path, &newpath);
302  	if (!err) {
303  		err = fuse_fs_create(d->next, newpath, mode, fi);
304  		free(newpath);
305  	}
306  	return err;
307  }
308  static int subdir_open(const char *path, struct fuse_file_info *fi)
309  {
310  	struct subdir *d = subdir_get();
311  	char *newpath;
312  	int err = subdir_addpath(d, path, &newpath);
313  	if (!err) {
314  		err = fuse_fs_open(d->next, newpath, fi);
315  		free(newpath);
316  	}
317  	return err;
318  }
319  static int subdir_read_buf(const char *path, struct fuse_bufvec **bufp,
320  			   size_t size, off_t offset, struct fuse_file_info *fi)
321  {
322  	struct subdir *d = subdir_get();
323  	char *newpath;
324  	int err = subdir_addpath(d, path, &newpath);
325  	if (!err) {
326  		err = fuse_fs_read_buf(d->next, newpath, bufp, size, offset, fi);
327  		free(newpath);
328  	}
329  	return err;
330  }
331  static int subdir_write_buf(const char *path, struct fuse_bufvec *buf,
332  			off_t offset, struct fuse_file_info *fi)
333  {
334  	struct subdir *d = subdir_get();
335  	char *newpath;
336  	int err = subdir_addpath(d, path, &newpath);
337  	if (!err) {
338  		err = fuse_fs_write_buf(d->next, newpath, buf, offset, fi);
339  		free(newpath);
340  	}
341  	return err;
342  }
343  static int subdir_statfs(const char *path, struct statvfs *stbuf)
344  {
345  	struct subdir *d = subdir_get();
346  	char *newpath;
347  	int err = subdir_addpath(d, path, &newpath);
348  	if (!err) {
349  		err = fuse_fs_statfs(d->next, newpath, stbuf);
350  		free(newpath);
351  	}
352  	return err;
353  }
354  static int subdir_flush(const char *path, struct fuse_file_info *fi)
355  {
356  	struct subdir *d = subdir_get();
357  	char *newpath;
358  	int err = subdir_addpath(d, path, &newpath);
359  	if (!err) {
360  		err = fuse_fs_flush(d->next, newpath, fi);
361  		free(newpath);
362  	}
363  	return err;
364  }
365  static int subdir_release(const char *path, struct fuse_file_info *fi)
366  {
367  	struct subdir *d = subdir_get();
368  	char *newpath;
369  	int err = subdir_addpath(d, path, &newpath);
370  	if (!err) {
371  		err = fuse_fs_release(d->next, newpath, fi);
372  		free(newpath);
373  	}
374  	return err;
375  }
376  static int subdir_fsync(const char *path, int isdatasync,
377  			struct fuse_file_info *fi)
378  {
379  	struct subdir *d = subdir_get();
380  	char *newpath;
381  	int err = subdir_addpath(d, path, &newpath);
382  	if (!err) {
383  		err = fuse_fs_fsync(d->next, newpath, isdatasync, fi);
384  		free(newpath);
385  	}
386  	return err;
387  }
388  static int subdir_fsyncdir(const char *path, int isdatasync,
389  			   struct fuse_file_info *fi)
390  {
391  	struct subdir *d = subdir_get();
392  	char *newpath;
393  	int err = subdir_addpath(d, path, &newpath);
394  	if (!err) {
395  		err = fuse_fs_fsyncdir(d->next, newpath, isdatasync, fi);
396  		free(newpath);
397  	}
398  	return err;
399  }
400  static int subdir_setxattr(const char *path, const char *name,
401  			   const char *value, size_t size, int flags)
402  {
403  	struct subdir *d = subdir_get();
404  	char *newpath;
405  	int err = subdir_addpath(d, path, &newpath);
406  	if (!err) {
407  		err = fuse_fs_setxattr(d->next, newpath, name, value, size,
408  				       flags);
409  		free(newpath);
410  	}
411  	return err;
412  }
413  static int subdir_getxattr(const char *path, const char *name, char *value,
414  			   size_t size)
415  {
416  	struct subdir *d = subdir_get();
417  	char *newpath;
418  	int err = subdir_addpath(d, path, &newpath);
419  	if (!err) {
420  		err = fuse_fs_getxattr(d->next, newpath, name, value, size);
421  		free(newpath);
422  	}
423  	return err;
424  }
425  static int subdir_listxattr(const char *path, char *list, size_t size)
426  {
427  	struct subdir *d = subdir_get();
428  	char *newpath;
429  	int err = subdir_addpath(d, path, &newpath);
430  	if (!err) {
431  		err = fuse_fs_listxattr(d->next, newpath, list, size);
432  		free(newpath);
433  	}
434  	return err;
435  }
436  static int subdir_removexattr(const char *path, const char *name)
437  {
438  	struct subdir *d = subdir_get();
439  	char *newpath;
440  	int err = subdir_addpath(d, path, &newpath);
441  	if (!err) {
442  		err = fuse_fs_removexattr(d->next, newpath, name);
443  		free(newpath);
444  	}
445  	return err;
446  }
447  static int subdir_lock(const char *path, struct fuse_file_info *fi, int cmd,
448  		       struct flock *lock)
449  {
450  	struct subdir *d = subdir_get();
451  	char *newpath;
452  	int err = subdir_addpath(d, path, &newpath);
453  	if (!err) {
454  		err = fuse_fs_lock(d->next, newpath, fi, cmd, lock);
455  		free(newpath);
456  	}
457  	return err;
458  }
459  static int subdir_flock(const char *path, struct fuse_file_info *fi, int op)
460  {
461  	struct subdir *d = subdir_get();
462  	char *newpath;
463  	int err = subdir_addpath(d, path, &newpath);
464  	if (!err) {
465  		err = fuse_fs_flock(d->next, newpath, fi, op);
466  		free(newpath);
467  	}
468  	return err;
469  }
470  static int subdir_bmap(const char *path, size_t blocksize, uint64_t *idx)
471  {
472  	struct subdir *d = subdir_get();
473  	char *newpath;
474  	int err = subdir_addpath(d, path, &newpath);
475  	if (!err) {
476  		err = fuse_fs_bmap(d->next, newpath, blocksize, idx);
477  		free(newpath);
478  	}
479  	return err;
480  }
481  static off_t subdir_lseek(const char *path, off_t off, int whence,
482  			  struct fuse_file_info *fi)
483  {
484  	struct subdir *ic = subdir_get();
485  	char *newpath;
486  	int res = subdir_addpath(ic, path, &newpath);
487  	if (!res) {
488  		res = fuse_fs_lseek(ic->next, newpath, off, whence, fi);
489  		free(newpath);
490  	}
491  	return res;
492  }
493  static void *subdir_init(struct fuse_conn_info *conn,
494  			 struct fuse_config *cfg)
495  {
496  	struct subdir *d = subdir_get();
497  	fuse_fs_init(d->next, conn, cfg);
498  	return d;
499  }
500  static void subdir_destroy(void *data)
501  {
502  	struct subdir *d = data;
503  	fuse_fs_destroy(d->next);
504  	free(d->base);
505  	free(d);
506  }
507  static const struct fuse_operations subdir_oper = {
508  	.destroy	= subdir_destroy,
509  	.init		= subdir_init,
510  	.getattr	= subdir_getattr,
511  	.access		= subdir_access,
512  	.readlink	= subdir_readlink,
513  	.opendir	= subdir_opendir,
514  	.readdir	= subdir_readdir,
515  	.releasedir	= subdir_releasedir,
516  	.mknod		= subdir_mknod,
517  	.mkdir		= subdir_mkdir,
518  	.symlink	= subdir_symlink,
519  	.unlink		= subdir_unlink,
520  	.rmdir		= subdir_rmdir,
521  	.rename		= subdir_rename,
522  	.link		= subdir_link,
523  	.chmod		= subdir_chmod,
524  	.chown		= subdir_chown,
525  	.truncate	= subdir_truncate,
526  	.utimens	= subdir_utimens,
527  	.create		= subdir_create,
528  	.open		= subdir_open,
529  	.read_buf	= subdir_read_buf,
530  	.write_buf	= subdir_write_buf,
531  	.statfs		= subdir_statfs,
532  	.flush		= subdir_flush,
533  	.release	= subdir_release,
534  	.fsync		= subdir_fsync,
<span onclick='openModal()' class='match'>535  	.fsyncdir	= subdir_fsyncdir,
536  	.setxattr	= subdir_setxattr,
537  	.getxattr	= subdir_getxattr,
538  	.listxattr	= subdir_listxattr,
539  	.removexattr	= subdir_removexattr,
540  	.lock		= subdir_lock,
541  	.flock		= subdir_flock,
542  	.bmap		= subdir_bmap,
543  	.lseek		= subdir_lseek,
</span>544  };
545  static const struct fuse_opt subdir_opts[] = {
546  	FUSE_OPT_KEY("-h", 0),
547  	FUSE_OPT_KEY("--help", 0),
548  	{ "subdir=%s", offsetof(struct subdir, base), 0 },
549  	{ "rellinks", offsetof(struct subdir, rellinks), 1 },
550  	{ "norellinks", offsetof(struct subdir, rellinks), 0 },
551  	FUSE_OPT_END
552  };
553  static void subdir_help(void)
554  {
555  	printf(
556  "    -o subdir=DIR	    prepend this directory to all paths (mandatory)\n"
557  "    -o [no]rellinks	    transform absolute symlinks to relative\n");
558  }
559  static int subdir_opt_proc(void *data, const char *arg, int key,
560  			   struct fuse_args *outargs)
561  {
562  	(void) data; (void) arg; (void) outargs;
563  	if (!key) {
564  		subdir_help();
565  		return -1;
566  	}
567  	return 1;
568  }
569  static struct fuse_fs *subdir_new(struct fuse_args *args,
570  				  struct fuse_fs *next[])
571  {
572  	struct fuse_fs *fs;
573  	struct subdir *d;
574  	d = calloc(1, sizeof(struct subdir));
575  	if (d == NULL) {
576  		fuse_log(FUSE_LOG_ERR, "fuse-subdir: memory allocation failed\n");
577  		return NULL;
578  	}
579  	if (fuse_opt_parse(args, d, subdir_opts, subdir_opt_proc) == -1)
580  		goto out_free;
581  	if (!next[0] || next[1]) {
582  		fuse_log(FUSE_LOG_ERR, "fuse-subdir: exactly one next filesystem required\n");
583  		goto out_free;
584  	}
585  	if (!d->base) {
586  		fuse_log(FUSE_LOG_ERR, "fuse-subdir: missing 'subdir' option\n");
587  		goto out_free;
588  	}
589  	if (d->base[0] && d->base[strlen(d->base)-1] != '/') {
590  		char *tmp = realloc(d->base, strlen(d->base) + 2);
591  		if (!tmp) {
592  			fuse_log(FUSE_LOG_ERR, "fuse-subdir: memory allocation failed\n");
593  			goto out_free;
594  		}
595  		d->base = tmp;
596  		strcat(d->base, "/");
597  	}
598  	d->baselen = strlen(d->base);
599  	d->next = next[0];
600  	fs = fuse_fs_new(&subdir_oper, sizeof(subdir_oper), d);
601  	if (!fs)
602  		goto out_free;
603  	return fs;
604  out_free:
605  	free(d->base);
606  	free(d);
607  	return NULL;
608  }
609  FUSE_REGISTER_MODULE(subdir, subdir_new);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-obfs.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-subdir.c</div>
                </div>
                <div class="column column_space"><pre><code>143          plugin->init_data = auth_simple_init_data;
144          plugin->new_obfs = auth_aes128_md5_new_obfs;
145          plugin->get_server_info = get_server_info;
146          plugin->set_server_info = set_server_info;
147          plugin->dispose = auth_simple_dispose;
148          plugin->client_pre_encrypt = auth_aes128_sha1_client_pre_encrypt;
149          plugin->client_post_decrypt = auth_aes128_sha1_client_post_decrypt;
150          plugin->client_udp_pre_encrypt = auth_aes128_sha1_client_udp_pre_encrypt;
151          plugin->client_udp_post_decrypt = auth_aes128_sha1_client_udp_post_decrypt;
</pre></code></div>
                <div class="column column_space"><pre><code>535  	.fsyncdir	= subdir_fsyncdir,
536  	.setxattr	= subdir_setxattr,
537  	.getxattr	= subdir_getxattr,
538  	.listxattr	= subdir_listxattr,
539  	.removexattr	= subdir_removexattr,
540  	.lock		= subdir_lock,
541  	.flock		= subdir_flock,
542  	.bmap		= subdir_bmap,
543  	.lseek		= subdir_lseek,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    