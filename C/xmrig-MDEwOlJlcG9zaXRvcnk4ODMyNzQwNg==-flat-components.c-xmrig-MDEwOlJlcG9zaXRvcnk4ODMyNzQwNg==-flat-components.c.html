
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 26, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-components.c</h3>
            <pre><code>1  #include "private/autogen/config.h"
2  #include "hwloc.h"
3  #include "private/private.h"
4  #include "private/xml.h"
5  #include "private/misc.h"
6  #define HWLOC_COMPONENT_STOP_NAME "stop"
7  #define HWLOC_COMPONENT_EXCLUDE_CHAR '-'
8  #define HWLOC_COMPONENT_SEPS ","
9  #define HWLOC_COMPONENT_PHASESEP_CHAR ':'
10  static struct hwloc_disc_component * hwloc_disc_components = NULL;
11  static unsigned hwloc_components_users = 0; &bsol;* first one initializes, last ones destroys */
12  static int hwloc_components_verbose = 0;
13  #ifdef HWLOC_HAVE_PLUGINS
14  static int hwloc_plugins_verbose = 0;
15  static const char * hwloc_plugins_blacklist = NULL;
16  #endif
17  #ifdef HWLOC_WIN_SYS
18  #include <windows.h>
19  static LONG hwloc_components_mutex = 0;
20  #define HWLOC_COMPONENTS_LOCK() do {						\
21    while (InterlockedCompareExchange(&hwloc_components_mutex, 1, 0) != 0)	\
22      SwitchToThread();								\
23  } while (0)
24  #define HWLOC_COMPONENTS_UNLOCK() do {						\
25    assert(hwloc_components_mutex == 1);						\
26    hwloc_components_mutex = 0;							\
27  } while (0)
28  #elif defined HWLOC_HAVE_PTHREAD_MUTEX
29  #include <pthread.h>
30  static pthread_mutex_t hwloc_components_mutex = PTHREAD_MUTEX_INITIALIZER;
31  #define HWLOC_COMPONENTS_LOCK() pthread_mutex_lock(&hwloc_components_mutex)
32  #define HWLOC_COMPONENTS_UNLOCK() pthread_mutex_unlock(&hwloc_components_mutex)
33  #else &bsol;* HWLOC_WIN_SYS || HWLOC_HAVE_PTHREAD_MUTEX */
34  #error No mutex implementation available
35  #endif
36  #ifdef HWLOC_HAVE_PLUGINS
37  #ifdef HWLOC_HAVE_LTDL
38  #include <ltdl.h>
39  typedef lt_dlhandle hwloc_dlhandle;
40  #define hwloc_dlinit lt_dlinit
41  #define hwloc_dlexit lt_dlexit
42  #define hwloc_dlopenext lt_dlopenext
43  #define hwloc_dlclose lt_dlclose
44  #define hwloc_dlerror lt_dlerror
45  #define hwloc_dlsym lt_dlsym
46  #define hwloc_dlforeachfile lt_dlforeachfile
47  #else &bsol;* !HWLOC_HAVE_LTDL */
48  #include <dlfcn.h>
49  typedef void * hwloc_dlhandle;
50  static __hwloc_inline int hwloc_dlinit(void) { return 0; }
51  static __hwloc_inline int hwloc_dlexit(void) { return 0; }
52  #define hwloc_dlclose dlclose
53  #define hwloc_dlerror dlerror
54  #define hwloc_dlsym dlsym
55  #include <sys/stat.h>
56  #include <sys/types.h>
57  #include <dirent.h>
58  #include <unistd.h>
59  static hwloc_dlhandle hwloc_dlopenext(const char *_filename)
60  {
61    hwloc_dlhandle handle;
62    char *filename = NULL;
63    (void) asprintf(&filename, "%s.so", _filename);
64    if (!filename)
65      return NULL;
66    handle = dlopen(filename, RTLD_NOW|RTLD_LOCAL);
67    free(filename);
68    return handle;
69  }
70  static int
71  hwloc_dlforeachfile(const char *_paths,
72  		    int (*func)(const char *filename, void *data),
73  		    void *data)
74  {
75    char *paths = NULL, *path;
76    paths = strdup(_paths);
77    if (!paths)
78      return -1;
79    path = paths;
80    while (*path) {
81      char *colon;
82      DIR *dir;
83      struct dirent *dirent;
84      colon = strchr(path, ':');
85      if (colon)
86        *colon = '\0';
87      if (hwloc_plugins_verbose)
88        fprintf(stderr, "hwloc:  Looking under %s\n", path);
89      dir = opendir(path);
90      if (!dir)
91        goto next;
92      while ((dirent = readdir(dir)) != NULL) {
93        char *abs_name, *suffix;
94        struct stat stbuf;
95        int err;
96        err = asprintf(&abs_name, "%s/%s", path, dirent->d_name);
97        if (err < 0)
98  	continue;
99        err = stat(abs_name, &stbuf);
100        if (err < 0) {
101  	free(abs_name);
102          continue;
103        }
104        if (!S_ISREG(stbuf.st_mode)) {
105  	free(abs_name);
106  	continue;
107        }
108        suffix = strrchr(abs_name, '.');
109        if (!suffix || strcmp(suffix, ".so")) {
110  	free(abs_name);
111  	continue;
112        }
113        *suffix = '\0';
114        err = func(abs_name, data);
115        if (err) {
116  	free(abs_name);
117  	continue;
118        }
119        free(abs_name);
120      }
121      closedir(dir);
122    next:
123      if (!colon)
124        break;
125      path = colon+1;
126    }
127    free(paths);
128    return 0;
129  }
130  #endif &bsol;* !HWLOC_HAVE_LTDL */
131  static struct hwloc__plugin_desc {
132    char *name;
133    struct hwloc_component *component;
134    char *filename;
135    hwloc_dlhandle handle;
136    struct hwloc__plugin_desc *next;
137  } *hwloc_plugins = NULL;
138  static int
139  hwloc__dlforeach_cb(const char *filename, void *_data __hwloc_attribute_unused)
140  {
141    const char *basename;
142    hwloc_dlhandle handle;
143    struct hwloc_component *component;
144    struct hwloc__plugin_desc *desc, **prevdesc;
145    char *componentsymbolname;
146    if (hwloc_plugins_verbose)
147      fprintf(stderr, "hwloc: Plugin dlforeach found `%s'\n", filename);
148    basename = strrchr(filename, '/');
149    if (!basename)
150      basename = filename;
151    else
152      basename++;
153    if (hwloc_plugins_blacklist && strstr(hwloc_plugins_blacklist, basename)) {
154      if (hwloc_plugins_verbose)
155        fprintf(stderr, "hwloc: Plugin `%s' is blacklisted in the environment\n", basename);
156      goto out;
157    }
158    handle = hwloc_dlopenext(filename);
159    if (!handle) {
160      if (hwloc_plugins_verbose)
161        fprintf(stderr, "hwloc: Failed to load plugin: %s\n", hwloc_dlerror());
162      goto out;
163    }
164    componentsymbolname = malloc(strlen(basename)+10+1);
165    if (!componentsymbolname) {
166      if (hwloc_plugins_verbose)
167        fprintf(stderr, "hwloc: Failed to allocation component `%s' symbol\n",
168  	      basename);
169      goto out_with_handle;
170    }
171    sprintf(componentsymbolname, "%s_component", basename);
172    component = hwloc_dlsym(handle, componentsymbolname);
173    if (!component) {
174      if (hwloc_plugins_verbose)
175        fprintf(stderr, "hwloc: Failed to find component symbol `%s'\n",
176  	      componentsymbolname);
177      free(componentsymbolname);
178      goto out_with_handle;
179    }
180    if (component->abi != HWLOC_COMPONENT_ABI) {
181      if (hwloc_plugins_verbose)
182        fprintf(stderr, "hwloc: Plugin symbol ABI %u instead of %d\n",
183  	      component->abi, HWLOC_COMPONENT_ABI);
184      free(componentsymbolname);
185      goto out_with_handle;
186    }
187    if (hwloc_plugins_verbose)
188      fprintf(stderr, "hwloc: Plugin contains expected symbol `%s'\n",
189  	    componentsymbolname);
190    free(componentsymbolname);
191    if (HWLOC_COMPONENT_TYPE_DISC == component->type) {
192      if (strncmp(basename, "hwloc_", 6)) {
193        if (hwloc_plugins_verbose)
194  	fprintf(stderr, "hwloc: Plugin name `%s' doesn't match its type DISCOVERY\n", basename);
195        goto out_with_handle;
196      }
197    } else if (HWLOC_COMPONENT_TYPE_XML == component->type) {
198      if (strncmp(basename, "hwloc_xml_", 10)) {
199        if (hwloc_plugins_verbose)
200  	fprintf(stderr, "hwloc: Plugin name `%s' doesn't match its type XML\n", basename);
201        goto out_with_handle;
202      }
203    } else {
204      if (hwloc_plugins_verbose)
205        fprintf(stderr, "hwloc: Plugin name `%s' has invalid type %u\n",
206  	      basename, (unsigned) component->type);
207      goto out_with_handle;
208    }
209    desc = malloc(sizeof(*desc));
210    if (!desc)
211      goto out_with_handle;
212    desc->name = strdup(basename);
213    desc->filename = strdup(filename);
214    desc->component = component;
215    desc->handle = handle;
216    desc->next = NULL;
217    if (hwloc_plugins_verbose)
218      fprintf(stderr, "hwloc: Plugin descriptor `%s' ready\n", basename);
219    prevdesc = &hwloc_plugins;
220    while (*prevdesc)
221      prevdesc = &((*prevdesc)->next);
222    *prevdesc = desc;
223    if (hwloc_plugins_verbose)
224      fprintf(stderr, "hwloc: Plugin descriptor `%s' queued\n", basename);
225    return 0;
226   out_with_handle:
227    hwloc_dlclose(handle);
228   out:
229    return 0;
230  }
231  static void
232  hwloc_plugins_exit(void)
233  {
234    struct hwloc__plugin_desc *desc, *next;
235    if (hwloc_plugins_verbose)
236      fprintf(stderr, "hwloc: Closing all plugins\n");
237    desc = hwloc_plugins;
238    while (desc) {
239      next = desc->next;
240      hwloc_dlclose(desc->handle);
241      free(desc->name);
242      free(desc->filename);
243      free(desc);
244      desc = next;
245    }
246    hwloc_plugins = NULL;
247    hwloc_dlexit();
248  }
249  static int
250  hwloc_plugins_init(void)
251  {
252    const char *verboseenv;
253    const char *path = HWLOC_PLUGINS_PATH;
254    const char *env;
255    int err;
256    verboseenv = getenv("HWLOC_PLUGINS_VERBOSE");
257    hwloc_plugins_verbose = verboseenv ? atoi(verboseenv) : 0;
258    hwloc_plugins_blacklist = getenv("HWLOC_PLUGINS_BLACKLIST");
259    err = hwloc_dlinit();
260    if (err)
261      goto out;
262    env = getenv("HWLOC_PLUGINS_PATH");
263    if (env)
264      path = env;
265    hwloc_plugins = NULL;
266    if (hwloc_plugins_verbose)
267      fprintf(stderr, "hwloc: Starting plugin dlforeach in %s\n", path);
268    err = hwloc_dlforeachfile(path, hwloc__dlforeach_cb, NULL);
269    if (err)
270      goto out_with_init;
271    return 0;
272   out_with_init:
273    hwloc_plugins_exit();
274   out:
275    return -1;
276  }
277  #endif &bsol;* HWLOC_HAVE_PLUGINS */
278  static int
279  hwloc_disc_component_register(struct hwloc_disc_component *component,
280  			      const char *filename)
281  {
282    struct hwloc_disc_component **prev;
283    if (!strcmp(component->name, HWLOC_COMPONENT_STOP_NAME)) {
284      if (hwloc_components_verbose)
285        fprintf(stderr, "hwloc: Cannot register discovery component with reserved name `" HWLOC_COMPONENT_STOP_NAME "'\n");
286      return -1;
287    }
288    if (strchr(component->name, HWLOC_COMPONENT_EXCLUDE_CHAR)
289        || strchr(component->name, HWLOC_COMPONENT_PHASESEP_CHAR)
290        || strcspn(component->name, HWLOC_COMPONENT_SEPS) != strlen(component->name)) {
291      if (hwloc_components_verbose)
292        fprintf(stderr, "hwloc: Cannot register discovery component with name `%s' containing reserved characters `%c" HWLOC_COMPONENT_SEPS "'\n",
293  	      component->name, HWLOC_COMPONENT_EXCLUDE_CHAR);
294      return -1;
295    }
296    if (!component->phases
297        || (component->phases != HWLOC_DISC_PHASE_GLOBAL
298  	  && component->phases & ~(HWLOC_DISC_PHASE_CPU
299  				   |HWLOC_DISC_PHASE_MEMORY
300  				   |HWLOC_DISC_PHASE_PCI
301  				   |HWLOC_DISC_PHASE_IO
302  				   |HWLOC_DISC_PHASE_MISC
303  				   |HWLOC_DISC_PHASE_ANNOTATE
304  				   |HWLOC_DISC_PHASE_TWEAK))) {
305      if (HWLOC_SHOW_CRITICAL_ERRORS())
306        fprintf(stderr, "hwloc: Cannot register discovery component `%s' with invalid phases 0x%x\n",
307                component->name, component->phases);
308      return -1;
309    }
310    prev = &hwloc_disc_components;
311    while (NULL != *prev) {
312      if (!strcmp((*prev)->name, component->name)) {
313        if ((*prev)->priority < component->priority) {
314  	if (hwloc_components_verbose)
315  	  fprintf(stderr, "hwloc: Dropping previously registered discovery component `%s', priority %u lower than new one %u\n",
316  		  (*prev)->name, (*prev)->priority, component->priority);
317  	*prev = (*prev)->next;
318        } else {
319  	if (hwloc_components_verbose)
320  	  fprintf(stderr, "hwloc: Ignoring new discovery component `%s', priority %u lower than previously registered one %u\n",
321  		  component->name, component->priority, (*prev)->priority);
322  	return -1;
323        }
324      }
325      prev = &((*prev)->next);
326    }
327    if (hwloc_components_verbose)
328      fprintf(stderr, "hwloc: Registered discovery component `%s' phases 0x%x with priority %u (%s%s)\n",
329  	    component->name, component->phases, component->priority,
330  	    filename ? "from plugin " : "statically build", filename ? filename : "");
331    prev = &hwloc_disc_components;
332    while (NULL != *prev) {
333      if ((*prev)->priority < component->priority)
334        break;
335      prev = &((*prev)->next);
336    }
337    component->next = *prev;
338    *prev = component;
339    return 0;
340  }
341  #include "static-components.h"
342  static void (**hwloc_component_finalize_cbs)(unsigned long);
343  static unsigned hwloc_component_finalize_cb_count;
344  void
345  hwloc_components_init(void)
346  {
347  #ifdef HWLOC_HAVE_PLUGINS
348    struct hwloc__plugin_desc *desc;
349  #endif
350    const char *verboseenv;
351    unsigned i;
352    HWLOC_COMPONENTS_LOCK();
353    assert((unsigned) -1 != hwloc_components_users);
354    if (0 != hwloc_components_users++) {
355      HWLOC_COMPONENTS_UNLOCK();
356      return;
357    }
358    verboseenv = getenv("HWLOC_COMPONENTS_VERBOSE");
359    hwloc_components_verbose = verboseenv ? atoi(verboseenv) : 0;
360  #ifdef HWLOC_HAVE_PLUGINS
361    hwloc_plugins_init();
362  #endif
363    hwloc_component_finalize_cbs = NULL;
364    hwloc_component_finalize_cb_count = 0;
365    for(i=0; NULL != hwloc_static_components[i]; i++)
366      hwloc_component_finalize_cb_count++;
367  #ifdef HWLOC_HAVE_PLUGINS
368    for(desc = hwloc_plugins; NULL != desc; desc = desc->next)
369      hwloc_component_finalize_cb_count++;
370  #endif
371    if (hwloc_component_finalize_cb_count) {
372      hwloc_component_finalize_cbs = calloc(hwloc_component_finalize_cb_count,
373  					  sizeof(*hwloc_component_finalize_cbs));
374      assert(hwloc_component_finalize_cbs);
375      hwloc_component_finalize_cb_count = 0;
376    }
377    for(i=0; NULL != hwloc_static_components[i]; i++) {
378      if (hwloc_static_components[i]->flags) {
379        if (HWLOC_SHOW_CRITICAL_ERRORS())
380          fprintf(stderr, "hwloc: Ignoring static component with invalid flags %lx\n",
381                  hwloc_static_components[i]->flags);
382        continue;
383      }
384      if (hwloc_static_components[i]->init && hwloc_static_components[i]->init(0) < 0) {
385        if (hwloc_components_verbose)
386  	fprintf(stderr, "hwloc: Ignoring static component, failed to initialize\n");
387        continue;
388      }
389      if (hwloc_static_components[i]->finalize)
390        hwloc_component_finalize_cbs[hwloc_component_finalize_cb_count++] = hwloc_static_components[i]->finalize;
391      if (HWLOC_COMPONENT_TYPE_DISC == hwloc_static_components[i]->type)
392        hwloc_disc_component_register(hwloc_static_components[i]->data, NULL);
393      else if (HWLOC_COMPONENT_TYPE_XML == hwloc_static_components[i]->type)
394        hwloc_xml_callbacks_register(hwloc_static_components[i]->data);
395      else
396        assert(0);
397    }
398  #ifdef HWLOC_HAVE_PLUGINS
399    for(desc = hwloc_plugins; NULL != desc; desc = desc->next) {
400      if (desc->component->flags) {
401        if (HWLOC_SHOW_CRITICAL_ERRORS())
402          fprintf(stderr, "hwloc: Ignoring plugin `%s' component with invalid flags %lx\n",
403                  desc->name, desc->component->flags);
404        continue;
405      }
406      if (desc->component->init && desc->component->init(0) < 0) {
407        if (hwloc_components_verbose)
408  	fprintf(stderr, "hwloc: Ignoring plugin `%s', failed to initialize\n", desc->name);
409        continue;
410      }
411      if (desc->component->finalize)
412        hwloc_component_finalize_cbs[hwloc_component_finalize_cb_count++] = desc->component->finalize;
413      if (HWLOC_COMPONENT_TYPE_DISC == desc->component->type)
414        hwloc_disc_component_register(desc->component->data, desc->filename);
415      else if (HWLOC_COMPONENT_TYPE_XML == desc->component->type)
416        hwloc_xml_callbacks_register(desc->component->data);
417      else
418        assert(0);
419    }
420  #endif
421    HWLOC_COMPONENTS_UNLOCK();
422  }
423  void
424  hwloc_topology_components_init(struct hwloc_topology *topology)
425  {
426    topology->nr_blacklisted_components = 0;
427    topology->blacklisted_components = NULL;
428    topology->backends = NULL;
429    topology->backend_phases = 0;
430    topology->backend_excluded_phases = 0;
431  }
432  static struct hwloc_disc_component *
433  hwloc_disc_component_find(const char *name, const char **endp)
434  {
435    struct hwloc_disc_component *comp;
436    size_t length;
437    const char *end = strchr(name, HWLOC_COMPONENT_PHASESEP_CHAR);
438    if (end) {
439      length = end-name;
440      if (endp)
441        *endp = end+1;
442    } else {
443      length = strlen(name);
444      if (endp)
445        *endp = NULL;
446    }
447    comp = hwloc_disc_components;
448    while (NULL != comp) {
449      if (!strncmp(name, comp->name, length))
450        return comp;
451      comp = comp->next;
452    }
453    return NULL;
454  }
455  static unsigned
456  hwloc_phases_from_string(const char *s)
457  {
458    if (!s)
459      return ~0U;
460    if (s[0]<'0' || s[0]>'9') {
461      if (!strcasecmp(s, "global"))
462        return HWLOC_DISC_PHASE_GLOBAL;
463      else if (!strcasecmp(s, "cpu"))
464        return HWLOC_DISC_PHASE_CPU;
465      if (!strcasecmp(s, "memory"))
466        return HWLOC_DISC_PHASE_MEMORY;
467      if (!strcasecmp(s, "pci"))
468        return HWLOC_DISC_PHASE_PCI;
469      if (!strcasecmp(s, "io"))
470        return HWLOC_DISC_PHASE_IO;
471      if (!strcasecmp(s, "misc"))
472        return HWLOC_DISC_PHASE_MISC;
473      if (!strcasecmp(s, "annotate"))
474        return HWLOC_DISC_PHASE_ANNOTATE;
475      if (!strcasecmp(s, "tweak"))
476        return HWLOC_DISC_PHASE_TWEAK;
477      return 0;
478    }
479    return (unsigned) strtoul(s, NULL, 0);
480  }
481  static int
482  hwloc_disc_component_blacklist_one(struct hwloc_topology *topology,
483  				   const char *name)
484  {
485    struct hwloc_topology_forced_component_s *blacklisted;
486    struct hwloc_disc_component *comp;
487    unsigned phases;
488    unsigned i;
489    if (!strcmp(name, "linuxpci") || !strcmp(name, "linuxio")) {
490      if (hwloc_components_verbose)
491        fprintf(stderr, "hwloc: Replacing deprecated component `%s' with `linux' IO phases in blacklisting\n", name);
492      comp = hwloc_disc_component_find("linux", NULL);
493      phases = HWLOC_DISC_PHASE_PCI | HWLOC_DISC_PHASE_IO | HWLOC_DISC_PHASE_MISC | HWLOC_DISC_PHASE_ANNOTATE;
494    } else {
495      const char *end;
496      comp = hwloc_disc_component_find(name, &end);
497      phases = hwloc_phases_from_string(end);
498    }
499    if (!comp) {
500      errno = EINVAL;
501      return -1;
502    }
503    if (hwloc_components_verbose)
504      fprintf(stderr, "hwloc: Blacklisting component `%s` phases 0x%x\n", comp->name, phases);
505    for(i=0; i<topology->nr_blacklisted_components; i++) {
506      if (topology->blacklisted_components[i].component == comp) {
507        topology->blacklisted_components[i].phases |= phases;
508        return 0;
509      }
510    }
511    blacklisted = realloc(topology->blacklisted_components, (topology->nr_blacklisted_components+1)*sizeof(*blacklisted));
512    if (!blacklisted)
513      return -1;
514    blacklisted[topology->nr_blacklisted_components].component = comp;
515    blacklisted[topology->nr_blacklisted_components].phases = phases;
516    topology->blacklisted_components = blacklisted;
517    topology->nr_blacklisted_components++;
518    return 0;
519  }
520  int
521  hwloc_topology_set_components(struct hwloc_topology *topology,
522  			      unsigned long flags,
523  			      const char *name)
524  {
525    if (topology->is_loaded) {
526      errno = EBUSY;
527      return -1;
528    }
529    if (flags & ~HWLOC_TOPOLOGY_COMPONENTS_FLAG_BLACKLIST) {
530      errno = EINVAL;
531      return -1;
532    }
533    if (flags != HWLOC_TOPOLOGY_COMPONENTS_FLAG_BLACKLIST) {
534      errno = EINVAL;
535      return -1;
536    }
537    if (!strncmp(name, "all", 3) && name[3] == HWLOC_COMPONENT_PHASESEP_CHAR) {
538      topology->backend_excluded_phases = hwloc_phases_from_string(name+4);
539      return 0;
540    }
541    return hwloc_disc_component_blacklist_one(topology, name);
542  }
543  int
544  hwloc_disc_component_force_enable(struct hwloc_topology *topology,
545  				  int envvar_forced,
546  				  const char *name,
547  				  const void *data1, const void *data2, const void *data3)
548  {
549    struct hwloc_disc_component *comp;
550    struct hwloc_backend *backend;
551    if (topology->is_loaded) {
552      errno = EBUSY;
553      return -1;
554    }
555    comp = hwloc_disc_component_find(name, NULL);
556    if (!comp) {
557      errno = ENOSYS;
558      return -1;
559    }
560    backend = comp->instantiate(topology, comp, 0U &bsol;* force-enabled don't get any phase blacklisting */,
561  			      data1, data2, data3);
562    if (backend) {
563      int err;
564      backend->envvar_forced = envvar_forced;
565      if (topology->backends)
566        hwloc_backends_disable_all(topology);
567      err = hwloc_backend_enable(backend);
568      if (comp->phases == HWLOC_DISC_PHASE_GLOBAL) {
569        char *env = getenv("HWLOC_ANNOTATE_GLOBAL_COMPONENTS");
570        if (env && atoi(env))
571  	topology->backend_excluded_phases &= ~HWLOC_DISC_PHASE_ANNOTATE;
572      }
573      return err;
574    } else
575      return -1;
576  }
577  static int
578  hwloc_disc_component_try_enable(struct hwloc_topology *topology,
579  				struct hwloc_disc_component *comp,
580  				int envvar_forced,
581  				unsigned blacklisted_phases)
582  {
583    struct hwloc_backend *backend;
584    if (!(comp->phases & ~(topology->backend_excluded_phases | blacklisted_phases))) {
585      if (hwloc_components_verbose)
586        fprintf(stderr, "hwloc: Excluding discovery component `%s' phases 0x%x, conflicts with excludes 0x%x\n",
587  	      comp->name, comp->phases, topology->backend_excluded_phases);
588      return -1;
589    }
590    backend = comp->instantiate(topology, comp, topology->backend_excluded_phases | blacklisted_phases,
591  			      NULL, NULL, NULL);
592    if (!backend) {
593      if (hwloc_components_verbose || (envvar_forced && HWLOC_SHOW_CRITICAL_ERRORS()))
594        fprintf(stderr, "hwloc: Failed to instantiate discovery component `%s'\n", comp->name);
595      return -1;
596    }
597    backend->phases &= ~blacklisted_phases;
598    backend->envvar_forced = envvar_forced;
599    return hwloc_backend_enable(backend);
600  }
601  void
602  hwloc_disc_components_enable_others(struct hwloc_topology *topology)
603  {
604    struct hwloc_disc_component *comp;
605    struct hwloc_backend *backend;
606    int tryall = 1;
607    const char *_env;
608    char *env; &bsol;* we'll to modify the env value, so duplicate it */
609    unsigned i;
610    _env = getenv("HWLOC_COMPONENTS");
611    env = _env ? strdup(_env) : NULL;
612    if (env) {
613      char *curenv = env;
<span onclick='openModal()' class='match'>614      size_t s;
615      while (*curenv) {
616        s = strcspn(curenv, HWLOC_COMPONENT_SEPS);
617        if (s) {
618  	char c;
619  	if (curenv[0] != HWLOC_COMPONENT_EXCLUDE_CHAR)
</span>620  	  goto nextname;
621  	c = curenv[s];
622  	curenv[s] = '\0';
623  	hwloc_disc_component_blacklist_one(topology, curenv+1);
624  	for(i=0; i<s; i++)
625  	  curenv[i] = *HWLOC_COMPONENT_SEPS;
626  	curenv[s] = c;
627        }
628      nextname:
629        curenv += s;
630        if (*curenv)
631  	curenv++;
632      }
633    }
634    if (env) {
635      char *curenv = env;
636      size_t s;
637      while (*curenv) {
638        s = strcspn(curenv, HWLOC_COMPONENT_SEPS);
639        if (s) {
640  	char c;
641  	const char *name;
642  	if (!strncmp(curenv, HWLOC_COMPONENT_STOP_NAME, s)) {
643  	  tryall = 0;
644  	  break;
645  	}
646  	c = curenv[s];
647  	curenv[s] = '\0';
648  	name = curenv;
649  	if (!strcmp(name, "linuxpci") || !strcmp(name, "linuxio")) {
650  	  if (hwloc_components_verbose)
651  	    fprintf(stderr, "hwloc: Replacing deprecated component `%s' with `linux' in envvar forcing\n", name);
652  	  name = "linux";
653  	}
654  	comp = hwloc_disc_component_find(name, NULL &bsol;* we enable the entire component, phases must be blacklisted separately */);
655  	if (comp) {
656  	  unsigned blacklisted_phases = 0U;
657  	  for(i=0; i<topology->nr_blacklisted_components; i++)
658  	    if (comp == topology->blacklisted_components[i].component) {
659  	      blacklisted_phases = topology->blacklisted_components[i].phases;
660  	      break;
661  	    }
662  	  if (comp->phases & ~blacklisted_phases)
663  	    hwloc_disc_component_try_enable(topology, comp, 1 &bsol;* envvar forced */, blacklisted_phases);
664  	} else {
665            if (HWLOC_SHOW_CRITICAL_ERRORS())
666              fprintf(stderr, "hwloc: Cannot find discovery component `%s'\n", name);
667  	}
668  	curenv[s] = c;
669        }
670        curenv += s;
671        if (*curenv)
672  	curenv++;
673      }
674    }
675    if (tryall) {
676      comp = hwloc_disc_components;
677      while (NULL != comp) {
678        unsigned blacklisted_phases = 0U;
679        if (!comp->enabled_by_default)
680  	goto nextcomp;
681        for(i=0; i<topology->nr_blacklisted_components; i++)
682  	if (comp == topology->blacklisted_components[i].component) {
683  	  blacklisted_phases = topology->blacklisted_components[i].phases;
684  	  break;
685  	}
686        if (!(comp->phases & ~blacklisted_phases)) {
687  	if (hwloc_components_verbose)
688  	  fprintf(stderr, "hwloc: Excluding blacklisted discovery component `%s' phases 0x%x\n",
689  		  comp->name, comp->phases);
690  	goto nextcomp;
691        }
692        hwloc_disc_component_try_enable(topology, comp, 0 &bsol;* defaults, not envvar forced */, blacklisted_phases);
693  nextcomp:
694        comp = comp->next;
695      }
696    }
697    if (hwloc_components_verbose) {
698      int first = 1;
699      backend = topology->backends;
700      fprintf(stderr, "hwloc: Final list of enabled discovery components: ");
701      while (backend != NULL) {
702        fprintf(stderr, "%s%s(0x%x)", first ? "" : ",", backend->component->name, backend->phases);
703        backend = backend->next;
704        first = 0;
705      }
706      fprintf(stderr, "\n");
707    }
708    free(env);
709  }
710  void
711  hwloc_components_fini(void)
712  {
713    unsigned i;
714    HWLOC_COMPONENTS_LOCK();
715    assert(0 != hwloc_components_users);
716    if (0 != --hwloc_components_users) {
717      HWLOC_COMPONENTS_UNLOCK();
718      return;
719    }
720    for(i=0; i<hwloc_component_finalize_cb_count; i++)
721      hwloc_component_finalize_cbs[hwloc_component_finalize_cb_count-i-1](0);
722    free(hwloc_component_finalize_cbs);
723    hwloc_component_finalize_cbs = NULL;
724    hwloc_component_finalize_cb_count = 0;
725    hwloc_disc_components = NULL;
726    hwloc_xml_callbacks_reset();
727  #ifdef HWLOC_HAVE_PLUGINS
728    hwloc_plugins_exit();
729  #endif
730    HWLOC_COMPONENTS_UNLOCK();
731  }
732  struct hwloc_backend *
733  hwloc_backend_alloc(struct hwloc_topology *topology,
734  		    struct hwloc_disc_component *component)
735  {
736    struct hwloc_backend * backend = malloc(sizeof(*backend));
737    if (!backend) {
738      errno = ENOMEM;
739      return NULL;
740    }
741    backend->component = component;
742    backend->topology = topology;
743    backend->phases = component->phases & ~topology->backend_excluded_phases;
744    if (backend->phases != component->phases && hwloc_components_verbose)
745      fprintf(stderr, "hwloc: Trying discovery component `%s' with phases 0x%x instead of 0x%x\n",
746  	    component->name, backend->phases, component->phases);
747    backend->flags = 0;
748    backend->discover = NULL;
749    backend->get_pci_busid_cpuset = NULL;
750    backend->disable = NULL;
751    backend->is_thissystem = -1;
752    backend->next = NULL;
753    backend->envvar_forced = 0;
754    return backend;
755  }
756  static void
757  hwloc_backend_disable(struct hwloc_backend *backend)
758  {
759    if (backend->disable)
760      backend->disable(backend);
761    free(backend);
762  }
763  int
764  hwloc_backend_enable(struct hwloc_backend *backend)
765  {
766    struct hwloc_topology *topology = backend->topology;
767    struct hwloc_backend **pprev;
768    if (backend->flags) {
769      if (HWLOC_SHOW_CRITICAL_ERRORS())
770        fprintf(stderr, "hwloc: Cannot enable discovery component `%s' phases 0x%x with unknown flags %lx\n",
771                backend->component->name, backend->component->phases, backend->flags);
772      return -1;
773    }
774    pprev = &topology->backends;
775    while (NULL != *pprev) {
776      if ((*pprev)->component == backend->component) {
777        if (hwloc_components_verbose)
778  	fprintf(stderr, "hwloc: Cannot enable  discovery component `%s' phases 0x%x twice\n",
779  		backend->component->name, backend->component->phases);
780        hwloc_backend_disable(backend);
781        errno = EBUSY;
782        return -1;
783      }
784      pprev = &((*pprev)->next);
785    }
786    if (hwloc_components_verbose)
787      fprintf(stderr, "hwloc: Enabling discovery component `%s' with phases 0x%x (among 0x%x)\n",
788  	    backend->component->name, backend->phases, backend->component->phases);
789    pprev = &topology->backends;
790    while (NULL != *pprev)
791      pprev = &((*pprev)->next);
792    backend->next = *pprev;
793    *pprev = backend;
794    topology->backend_phases |= backend->component->phases;
795    topology->backend_excluded_phases |= backend->component->excluded_phases;
796    return 0;
797  }
798  void
799  hwloc_backends_is_thissystem(struct hwloc_topology *topology)
800  {
801    struct hwloc_backend *backend;
802    const char *local_env;
803    topology->is_thissystem = 1;
804    backend = topology->backends;
805    while (backend != NULL) {
806      if (backend->envvar_forced == 0 && backend->is_thissystem != -1) {
807        assert(backend->is_thissystem == 0);
808        topology->is_thissystem = 0;
809      }
810      backend = backend->next;
811    }
812    if (topology->flags & HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM)
813      topology->is_thissystem = 1;
814    backend = topology->backends;
815    while (backend != NULL) {
816      if (backend->envvar_forced == 1 && backend->is_thissystem != -1) {
817        assert(backend->is_thissystem == 0);
818        topology->is_thissystem = 0;
819      }
820      backend = backend->next;
821    }
822    local_env = getenv("HWLOC_THISSYSTEM");
823    if (local_env)
824      topology->is_thissystem = atoi(local_env);
825  }
826  void
827  hwloc_backends_find_callbacks(struct hwloc_topology *topology)
828  {
829    struct hwloc_backend *backend = topology->backends;
830    topology->get_pci_busid_cpuset_backend = NULL;
831    while (backend != NULL) {
832      if (backend->get_pci_busid_cpuset) {
833        topology->get_pci_busid_cpuset_backend = backend;
834        return;
835      }
836      backend = backend->next;
837    }
838    return;
839  }
840  void
841  hwloc_backends_disable_all(struct hwloc_topology *topology)
842  {
843    struct hwloc_backend *backend;
844    while (NULL != (backend = topology->backends)) {
845      struct hwloc_backend *next = backend->next;
846      if (hwloc_components_verbose)
847        fprintf(stderr, "hwloc: Disabling discovery component `%s'\n",
848  	      backend->component->name);
849      hwloc_backend_disable(backend);
850      topology->backends = next;
851    }
852    topology->backends = NULL;
853    topology->backend_excluded_phases = 0;
854  }
855  void
856  hwloc_topology_components_fini(struct hwloc_topology *topology)
857  {
858    assert(!topology->backends);
859    free(topology->blacklisted_components);
860  }
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-components.c</h3>
            <pre><code>1  #include "private/autogen/config.h"
2  #include "hwloc.h"
3  #include "private/private.h"
4  #include "private/xml.h"
5  #include "private/misc.h"
6  #define HWLOC_COMPONENT_STOP_NAME "stop"
7  #define HWLOC_COMPONENT_EXCLUDE_CHAR '-'
8  #define HWLOC_COMPONENT_SEPS ","
9  #define HWLOC_COMPONENT_PHASESEP_CHAR ':'
10  static struct hwloc_disc_component * hwloc_disc_components = NULL;
11  static unsigned hwloc_components_users = 0; &bsol;* first one initializes, last ones destroys */
12  static int hwloc_components_verbose = 0;
13  #ifdef HWLOC_HAVE_PLUGINS
14  static int hwloc_plugins_verbose = 0;
15  static const char * hwloc_plugins_blacklist = NULL;
16  #endif
17  #ifdef HWLOC_WIN_SYS
18  #include <windows.h>
19  static LONG hwloc_components_mutex = 0;
20  #define HWLOC_COMPONENTS_LOCK() do {						\
21    while (InterlockedCompareExchange(&hwloc_components_mutex, 1, 0) != 0)	\
22      SwitchToThread();								\
23  } while (0)
24  #define HWLOC_COMPONENTS_UNLOCK() do {						\
25    assert(hwloc_components_mutex == 1);						\
26    hwloc_components_mutex = 0;							\
27  } while (0)
28  #elif defined HWLOC_HAVE_PTHREAD_MUTEX
29  #include <pthread.h>
30  static pthread_mutex_t hwloc_components_mutex = PTHREAD_MUTEX_INITIALIZER;
31  #define HWLOC_COMPONENTS_LOCK() pthread_mutex_lock(&hwloc_components_mutex)
32  #define HWLOC_COMPONENTS_UNLOCK() pthread_mutex_unlock(&hwloc_components_mutex)
33  #else &bsol;* HWLOC_WIN_SYS || HWLOC_HAVE_PTHREAD_MUTEX */
34  #error No mutex implementation available
35  #endif
36  #ifdef HWLOC_HAVE_PLUGINS
37  #ifdef HWLOC_HAVE_LTDL
38  #include <ltdl.h>
39  typedef lt_dlhandle hwloc_dlhandle;
40  #define hwloc_dlinit lt_dlinit
41  #define hwloc_dlexit lt_dlexit
42  #define hwloc_dlopenext lt_dlopenext
43  #define hwloc_dlclose lt_dlclose
44  #define hwloc_dlerror lt_dlerror
45  #define hwloc_dlsym lt_dlsym
46  #define hwloc_dlforeachfile lt_dlforeachfile
47  #else &bsol;* !HWLOC_HAVE_LTDL */
48  #include <dlfcn.h>
49  typedef void * hwloc_dlhandle;
50  static __hwloc_inline int hwloc_dlinit(void) { return 0; }
51  static __hwloc_inline int hwloc_dlexit(void) { return 0; }
52  #define hwloc_dlclose dlclose
53  #define hwloc_dlerror dlerror
54  #define hwloc_dlsym dlsym
55  #include <sys/stat.h>
56  #include <sys/types.h>
57  #include <dirent.h>
58  #include <unistd.h>
59  static hwloc_dlhandle hwloc_dlopenext(const char *_filename)
60  {
61    hwloc_dlhandle handle;
62    char *filename = NULL;
63    (void) asprintf(&filename, "%s.so", _filename);
64    if (!filename)
65      return NULL;
66    handle = dlopen(filename, RTLD_NOW|RTLD_LOCAL);
67    free(filename);
68    return handle;
69  }
70  static int
71  hwloc_dlforeachfile(const char *_paths,
72  		    int (*func)(const char *filename, void *data),
73  		    void *data)
74  {
75    char *paths = NULL, *path;
76    paths = strdup(_paths);
77    if (!paths)
78      return -1;
79    path = paths;
80    while (*path) {
81      char *colon;
82      DIR *dir;
83      struct dirent *dirent;
84      colon = strchr(path, ':');
85      if (colon)
86        *colon = '\0';
87      if (hwloc_plugins_verbose)
88        fprintf(stderr, "hwloc:  Looking under %s\n", path);
89      dir = opendir(path);
90      if (!dir)
91        goto next;
92      while ((dirent = readdir(dir)) != NULL) {
93        char *abs_name, *suffix;
94        struct stat stbuf;
95        int err;
96        err = asprintf(&abs_name, "%s/%s", path, dirent->d_name);
97        if (err < 0)
98  	continue;
99        err = stat(abs_name, &stbuf);
100        if (err < 0) {
101  	free(abs_name);
102          continue;
103        }
104        if (!S_ISREG(stbuf.st_mode)) {
105  	free(abs_name);
106  	continue;
107        }
108        suffix = strrchr(abs_name, '.');
109        if (!suffix || strcmp(suffix, ".so")) {
110  	free(abs_name);
111  	continue;
112        }
113        *suffix = '\0';
114        err = func(abs_name, data);
115        if (err) {
116  	free(abs_name);
117  	continue;
118        }
119        free(abs_name);
120      }
121      closedir(dir);
122    next:
123      if (!colon)
124        break;
125      path = colon+1;
126    }
127    free(paths);
128    return 0;
129  }
130  #endif &bsol;* !HWLOC_HAVE_LTDL */
131  static struct hwloc__plugin_desc {
132    char *name;
133    struct hwloc_component *component;
134    char *filename;
135    hwloc_dlhandle handle;
136    struct hwloc__plugin_desc *next;
137  } *hwloc_plugins = NULL;
138  static int
139  hwloc__dlforeach_cb(const char *filename, void *_data __hwloc_attribute_unused)
140  {
141    const char *basename;
142    hwloc_dlhandle handle;
143    struct hwloc_component *component;
144    struct hwloc__plugin_desc *desc, **prevdesc;
145    char *componentsymbolname;
146    if (hwloc_plugins_verbose)
147      fprintf(stderr, "hwloc: Plugin dlforeach found `%s'\n", filename);
148    basename = strrchr(filename, '/');
149    if (!basename)
150      basename = filename;
151    else
152      basename++;
153    if (hwloc_plugins_blacklist && strstr(hwloc_plugins_blacklist, basename)) {
154      if (hwloc_plugins_verbose)
155        fprintf(stderr, "hwloc: Plugin `%s' is blacklisted in the environment\n", basename);
156      goto out;
157    }
158    handle = hwloc_dlopenext(filename);
159    if (!handle) {
160      if (hwloc_plugins_verbose)
161        fprintf(stderr, "hwloc: Failed to load plugin: %s\n", hwloc_dlerror());
162      goto out;
163    }
164    componentsymbolname = malloc(strlen(basename)+10+1);
165    if (!componentsymbolname) {
166      if (hwloc_plugins_verbose)
167        fprintf(stderr, "hwloc: Failed to allocation component `%s' symbol\n",
168  	      basename);
169      goto out_with_handle;
170    }
171    sprintf(componentsymbolname, "%s_component", basename);
172    component = hwloc_dlsym(handle, componentsymbolname);
173    if (!component) {
174      if (hwloc_plugins_verbose)
175        fprintf(stderr, "hwloc: Failed to find component symbol `%s'\n",
176  	      componentsymbolname);
177      free(componentsymbolname);
178      goto out_with_handle;
179    }
180    if (component->abi != HWLOC_COMPONENT_ABI) {
181      if (hwloc_plugins_verbose)
182        fprintf(stderr, "hwloc: Plugin symbol ABI %u instead of %d\n",
183  	      component->abi, HWLOC_COMPONENT_ABI);
184      free(componentsymbolname);
185      goto out_with_handle;
186    }
187    if (hwloc_plugins_verbose)
188      fprintf(stderr, "hwloc: Plugin contains expected symbol `%s'\n",
189  	    componentsymbolname);
190    free(componentsymbolname);
191    if (HWLOC_COMPONENT_TYPE_DISC == component->type) {
192      if (strncmp(basename, "hwloc_", 6)) {
193        if (hwloc_plugins_verbose)
194  	fprintf(stderr, "hwloc: Plugin name `%s' doesn't match its type DISCOVERY\n", basename);
195        goto out_with_handle;
196      }
197    } else if (HWLOC_COMPONENT_TYPE_XML == component->type) {
198      if (strncmp(basename, "hwloc_xml_", 10)) {
199        if (hwloc_plugins_verbose)
200  	fprintf(stderr, "hwloc: Plugin name `%s' doesn't match its type XML\n", basename);
201        goto out_with_handle;
202      }
203    } else {
204      if (hwloc_plugins_verbose)
205        fprintf(stderr, "hwloc: Plugin name `%s' has invalid type %u\n",
206  	      basename, (unsigned) component->type);
207      goto out_with_handle;
208    }
209    desc = malloc(sizeof(*desc));
210    if (!desc)
211      goto out_with_handle;
212    desc->name = strdup(basename);
213    desc->filename = strdup(filename);
214    desc->component = component;
215    desc->handle = handle;
216    desc->next = NULL;
217    if (hwloc_plugins_verbose)
218      fprintf(stderr, "hwloc: Plugin descriptor `%s' ready\n", basename);
219    prevdesc = &hwloc_plugins;
220    while (*prevdesc)
221      prevdesc = &((*prevdesc)->next);
222    *prevdesc = desc;
223    if (hwloc_plugins_verbose)
224      fprintf(stderr, "hwloc: Plugin descriptor `%s' queued\n", basename);
225    return 0;
226   out_with_handle:
227    hwloc_dlclose(handle);
228   out:
229    return 0;
230  }
231  static void
232  hwloc_plugins_exit(void)
233  {
234    struct hwloc__plugin_desc *desc, *next;
235    if (hwloc_plugins_verbose)
236      fprintf(stderr, "hwloc: Closing all plugins\n");
237    desc = hwloc_plugins;
238    while (desc) {
239      next = desc->next;
240      hwloc_dlclose(desc->handle);
241      free(desc->name);
242      free(desc->filename);
243      free(desc);
244      desc = next;
245    }
246    hwloc_plugins = NULL;
247    hwloc_dlexit();
248  }
249  static int
250  hwloc_plugins_init(void)
251  {
252    const char *verboseenv;
253    const char *path = HWLOC_PLUGINS_PATH;
254    const char *env;
255    int err;
256    verboseenv = getenv("HWLOC_PLUGINS_VERBOSE");
257    hwloc_plugins_verbose = verboseenv ? atoi(verboseenv) : 0;
258    hwloc_plugins_blacklist = getenv("HWLOC_PLUGINS_BLACKLIST");
259    err = hwloc_dlinit();
260    if (err)
261      goto out;
262    env = getenv("HWLOC_PLUGINS_PATH");
263    if (env)
264      path = env;
265    hwloc_plugins = NULL;
266    if (hwloc_plugins_verbose)
267      fprintf(stderr, "hwloc: Starting plugin dlforeach in %s\n", path);
268    err = hwloc_dlforeachfile(path, hwloc__dlforeach_cb, NULL);
269    if (err)
270      goto out_with_init;
271    return 0;
272   out_with_init:
273    hwloc_plugins_exit();
274   out:
275    return -1;
276  }
277  #endif &bsol;* HWLOC_HAVE_PLUGINS */
278  static int
279  hwloc_disc_component_register(struct hwloc_disc_component *component,
280  			      const char *filename)
281  {
282    struct hwloc_disc_component **prev;
283    if (!strcmp(component->name, HWLOC_COMPONENT_STOP_NAME)) {
284      if (hwloc_components_verbose)
285        fprintf(stderr, "hwloc: Cannot register discovery component with reserved name `" HWLOC_COMPONENT_STOP_NAME "'\n");
286      return -1;
287    }
288    if (strchr(component->name, HWLOC_COMPONENT_EXCLUDE_CHAR)
289        || strchr(component->name, HWLOC_COMPONENT_PHASESEP_CHAR)
290        || strcspn(component->name, HWLOC_COMPONENT_SEPS) != strlen(component->name)) {
291      if (hwloc_components_verbose)
292        fprintf(stderr, "hwloc: Cannot register discovery component with name `%s' containing reserved characters `%c" HWLOC_COMPONENT_SEPS "'\n",
293  	      component->name, HWLOC_COMPONENT_EXCLUDE_CHAR);
294      return -1;
295    }
296    if (!component->phases
297        || (component->phases != HWLOC_DISC_PHASE_GLOBAL
298  	  && component->phases & ~(HWLOC_DISC_PHASE_CPU
299  				   |HWLOC_DISC_PHASE_MEMORY
300  				   |HWLOC_DISC_PHASE_PCI
301  				   |HWLOC_DISC_PHASE_IO
302  				   |HWLOC_DISC_PHASE_MISC
303  				   |HWLOC_DISC_PHASE_ANNOTATE
304  				   |HWLOC_DISC_PHASE_TWEAK))) {
305      if (HWLOC_SHOW_CRITICAL_ERRORS())
306        fprintf(stderr, "hwloc: Cannot register discovery component `%s' with invalid phases 0x%x\n",
307                component->name, component->phases);
308      return -1;
309    }
310    prev = &hwloc_disc_components;
311    while (NULL != *prev) {
312      if (!strcmp((*prev)->name, component->name)) {
313        if ((*prev)->priority < component->priority) {
314  	if (hwloc_components_verbose)
315  	  fprintf(stderr, "hwloc: Dropping previously registered discovery component `%s', priority %u lower than new one %u\n",
316  		  (*prev)->name, (*prev)->priority, component->priority);
317  	*prev = (*prev)->next;
318        } else {
319  	if (hwloc_components_verbose)
320  	  fprintf(stderr, "hwloc: Ignoring new discovery component `%s', priority %u lower than previously registered one %u\n",
321  		  component->name, component->priority, (*prev)->priority);
322  	return -1;
323        }
324      }
325      prev = &((*prev)->next);
326    }
327    if (hwloc_components_verbose)
328      fprintf(stderr, "hwloc: Registered discovery component `%s' phases 0x%x with priority %u (%s%s)\n",
329  	    component->name, component->phases, component->priority,
330  	    filename ? "from plugin " : "statically build", filename ? filename : "");
331    prev = &hwloc_disc_components;
332    while (NULL != *prev) {
333      if ((*prev)->priority < component->priority)
334        break;
335      prev = &((*prev)->next);
336    }
337    component->next = *prev;
338    *prev = component;
339    return 0;
340  }
341  #include "static-components.h"
342  static void (**hwloc_component_finalize_cbs)(unsigned long);
343  static unsigned hwloc_component_finalize_cb_count;
344  void
345  hwloc_components_init(void)
346  {
347  #ifdef HWLOC_HAVE_PLUGINS
348    struct hwloc__plugin_desc *desc;
349  #endif
350    const char *verboseenv;
351    unsigned i;
352    HWLOC_COMPONENTS_LOCK();
353    assert((unsigned) -1 != hwloc_components_users);
354    if (0 != hwloc_components_users++) {
355      HWLOC_COMPONENTS_UNLOCK();
356      return;
357    }
358    verboseenv = getenv("HWLOC_COMPONENTS_VERBOSE");
359    hwloc_components_verbose = verboseenv ? atoi(verboseenv) : 0;
360  #ifdef HWLOC_HAVE_PLUGINS
361    hwloc_plugins_init();
362  #endif
363    hwloc_component_finalize_cbs = NULL;
364    hwloc_component_finalize_cb_count = 0;
365    for(i=0; NULL != hwloc_static_components[i]; i++)
366      hwloc_component_finalize_cb_count++;
367  #ifdef HWLOC_HAVE_PLUGINS
368    for(desc = hwloc_plugins; NULL != desc; desc = desc->next)
369      hwloc_component_finalize_cb_count++;
370  #endif
371    if (hwloc_component_finalize_cb_count) {
372      hwloc_component_finalize_cbs = calloc(hwloc_component_finalize_cb_count,
373  					  sizeof(*hwloc_component_finalize_cbs));
374      assert(hwloc_component_finalize_cbs);
375      hwloc_component_finalize_cb_count = 0;
376    }
377    for(i=0; NULL != hwloc_static_components[i]; i++) {
378      if (hwloc_static_components[i]->flags) {
379        if (HWLOC_SHOW_CRITICAL_ERRORS())
380          fprintf(stderr, "hwloc: Ignoring static component with invalid flags %lx\n",
381                  hwloc_static_components[i]->flags);
382        continue;
383      }
384      if (hwloc_static_components[i]->init && hwloc_static_components[i]->init(0) < 0) {
385        if (hwloc_components_verbose)
386  	fprintf(stderr, "hwloc: Ignoring static component, failed to initialize\n");
387        continue;
388      }
389      if (hwloc_static_components[i]->finalize)
390        hwloc_component_finalize_cbs[hwloc_component_finalize_cb_count++] = hwloc_static_components[i]->finalize;
391      if (HWLOC_COMPONENT_TYPE_DISC == hwloc_static_components[i]->type)
392        hwloc_disc_component_register(hwloc_static_components[i]->data, NULL);
393      else if (HWLOC_COMPONENT_TYPE_XML == hwloc_static_components[i]->type)
394        hwloc_xml_callbacks_register(hwloc_static_components[i]->data);
395      else
396        assert(0);
397    }
398  #ifdef HWLOC_HAVE_PLUGINS
399    for(desc = hwloc_plugins; NULL != desc; desc = desc->next) {
400      if (desc->component->flags) {
401        if (HWLOC_SHOW_CRITICAL_ERRORS())
402          fprintf(stderr, "hwloc: Ignoring plugin `%s' component with invalid flags %lx\n",
403                  desc->name, desc->component->flags);
404        continue;
405      }
406      if (desc->component->init && desc->component->init(0) < 0) {
407        if (hwloc_components_verbose)
408  	fprintf(stderr, "hwloc: Ignoring plugin `%s', failed to initialize\n", desc->name);
409        continue;
410      }
411      if (desc->component->finalize)
412        hwloc_component_finalize_cbs[hwloc_component_finalize_cb_count++] = desc->component->finalize;
413      if (HWLOC_COMPONENT_TYPE_DISC == desc->component->type)
414        hwloc_disc_component_register(desc->component->data, desc->filename);
415      else if (HWLOC_COMPONENT_TYPE_XML == desc->component->type)
416        hwloc_xml_callbacks_register(desc->component->data);
417      else
418        assert(0);
419    }
420  #endif
421    HWLOC_COMPONENTS_UNLOCK();
422  }
423  void
424  hwloc_topology_components_init(struct hwloc_topology *topology)
425  {
426    topology->nr_blacklisted_components = 0;
427    topology->blacklisted_components = NULL;
428    topology->backends = NULL;
429    topology->backend_phases = 0;
430    topology->backend_excluded_phases = 0;
431  }
432  static struct hwloc_disc_component *
433  hwloc_disc_component_find(const char *name, const char **endp)
434  {
435    struct hwloc_disc_component *comp;
436    size_t length;
437    const char *end = strchr(name, HWLOC_COMPONENT_PHASESEP_CHAR);
438    if (end) {
439      length = end-name;
440      if (endp)
441        *endp = end+1;
442    } else {
443      length = strlen(name);
444      if (endp)
445        *endp = NULL;
446    }
447    comp = hwloc_disc_components;
448    while (NULL != comp) {
449      if (!strncmp(name, comp->name, length))
450        return comp;
451      comp = comp->next;
452    }
453    return NULL;
454  }
455  static unsigned
456  hwloc_phases_from_string(const char *s)
457  {
458    if (!s)
459      return ~0U;
460    if (s[0]<'0' || s[0]>'9') {
461      if (!strcasecmp(s, "global"))
462        return HWLOC_DISC_PHASE_GLOBAL;
463      else if (!strcasecmp(s, "cpu"))
464        return HWLOC_DISC_PHASE_CPU;
465      if (!strcasecmp(s, "memory"))
466        return HWLOC_DISC_PHASE_MEMORY;
467      if (!strcasecmp(s, "pci"))
468        return HWLOC_DISC_PHASE_PCI;
469      if (!strcasecmp(s, "io"))
470        return HWLOC_DISC_PHASE_IO;
471      if (!strcasecmp(s, "misc"))
472        return HWLOC_DISC_PHASE_MISC;
473      if (!strcasecmp(s, "annotate"))
474        return HWLOC_DISC_PHASE_ANNOTATE;
475      if (!strcasecmp(s, "tweak"))
476        return HWLOC_DISC_PHASE_TWEAK;
477      return 0;
478    }
479    return (unsigned) strtoul(s, NULL, 0);
480  }
481  static int
482  hwloc_disc_component_blacklist_one(struct hwloc_topology *topology,
483  				   const char *name)
484  {
485    struct hwloc_topology_forced_component_s *blacklisted;
486    struct hwloc_disc_component *comp;
487    unsigned phases;
488    unsigned i;
489    if (!strcmp(name, "linuxpci") || !strcmp(name, "linuxio")) {
490      if (hwloc_components_verbose)
491        fprintf(stderr, "hwloc: Replacing deprecated component `%s' with `linux' IO phases in blacklisting\n", name);
492      comp = hwloc_disc_component_find("linux", NULL);
493      phases = HWLOC_DISC_PHASE_PCI | HWLOC_DISC_PHASE_IO | HWLOC_DISC_PHASE_MISC | HWLOC_DISC_PHASE_ANNOTATE;
494    } else {
495      const char *end;
496      comp = hwloc_disc_component_find(name, &end);
497      phases = hwloc_phases_from_string(end);
498    }
499    if (!comp) {
500      errno = EINVAL;
501      return -1;
502    }
503    if (hwloc_components_verbose)
504      fprintf(stderr, "hwloc: Blacklisting component `%s` phases 0x%x\n", comp->name, phases);
505    for(i=0; i<topology->nr_blacklisted_components; i++) {
506      if (topology->blacklisted_components[i].component == comp) {
507        topology->blacklisted_components[i].phases |= phases;
508        return 0;
509      }
510    }
511    blacklisted = realloc(topology->blacklisted_components, (topology->nr_blacklisted_components+1)*sizeof(*blacklisted));
512    if (!blacklisted)
513      return -1;
514    blacklisted[topology->nr_blacklisted_components].component = comp;
515    blacklisted[topology->nr_blacklisted_components].phases = phases;
516    topology->blacklisted_components = blacklisted;
517    topology->nr_blacklisted_components++;
518    return 0;
519  }
520  int
521  hwloc_topology_set_components(struct hwloc_topology *topology,
522  			      unsigned long flags,
523  			      const char *name)
524  {
525    if (topology->is_loaded) {
526      errno = EBUSY;
527      return -1;
528    }
529    if (flags & ~HWLOC_TOPOLOGY_COMPONENTS_FLAG_BLACKLIST) {
530      errno = EINVAL;
531      return -1;
532    }
533    if (flags != HWLOC_TOPOLOGY_COMPONENTS_FLAG_BLACKLIST) {
534      errno = EINVAL;
535      return -1;
536    }
537    if (!strncmp(name, "all", 3) && name[3] == HWLOC_COMPONENT_PHASESEP_CHAR) {
538      topology->backend_excluded_phases = hwloc_phases_from_string(name+4);
539      return 0;
540    }
541    return hwloc_disc_component_blacklist_one(topology, name);
542  }
543  int
544  hwloc_disc_component_force_enable(struct hwloc_topology *topology,
545  				  int envvar_forced,
546  				  const char *name,
547  				  const void *data1, const void *data2, const void *data3)
548  {
549    struct hwloc_disc_component *comp;
550    struct hwloc_backend *backend;
551    if (topology->is_loaded) {
552      errno = EBUSY;
553      return -1;
554    }
555    comp = hwloc_disc_component_find(name, NULL);
556    if (!comp) {
557      errno = ENOSYS;
558      return -1;
559    }
560    backend = comp->instantiate(topology, comp, 0U &bsol;* force-enabled don't get any phase blacklisting */,
561  			      data1, data2, data3);
562    if (backend) {
563      int err;
564      backend->envvar_forced = envvar_forced;
565      if (topology->backends)
566        hwloc_backends_disable_all(topology);
567      err = hwloc_backend_enable(backend);
568      if (comp->phases == HWLOC_DISC_PHASE_GLOBAL) {
569        char *env = getenv("HWLOC_ANNOTATE_GLOBAL_COMPONENTS");
570        if (env && atoi(env))
571  	topology->backend_excluded_phases &= ~HWLOC_DISC_PHASE_ANNOTATE;
572      }
573      return err;
574    } else
575      return -1;
576  }
577  static int
578  hwloc_disc_component_try_enable(struct hwloc_topology *topology,
579  				struct hwloc_disc_component *comp,
580  				int envvar_forced,
581  				unsigned blacklisted_phases)
582  {
583    struct hwloc_backend *backend;
584    if (!(comp->phases & ~(topology->backend_excluded_phases | blacklisted_phases))) {
585      if (hwloc_components_verbose)
586        fprintf(stderr, "hwloc: Excluding discovery component `%s' phases 0x%x, conflicts with excludes 0x%x\n",
587  	      comp->name, comp->phases, topology->backend_excluded_phases);
588      return -1;
589    }
590    backend = comp->instantiate(topology, comp, topology->backend_excluded_phases | blacklisted_phases,
591  			      NULL, NULL, NULL);
592    if (!backend) {
593      if (hwloc_components_verbose || (envvar_forced && HWLOC_SHOW_CRITICAL_ERRORS()))
594        fprintf(stderr, "hwloc: Failed to instantiate discovery component `%s'\n", comp->name);
595      return -1;
596    }
597    backend->phases &= ~blacklisted_phases;
598    backend->envvar_forced = envvar_forced;
599    return hwloc_backend_enable(backend);
600  }
601  void
602  hwloc_disc_components_enable_others(struct hwloc_topology *topology)
603  {
604    struct hwloc_disc_component *comp;
605    struct hwloc_backend *backend;
606    int tryall = 1;
607    const char *_env;
608    char *env; &bsol;* we'll to modify the env value, so duplicate it */
609    unsigned i;
610    _env = getenv("HWLOC_COMPONENTS");
611    env = _env ? strdup(_env) : NULL;
612    if (env) {
613      char *curenv = env;
614      size_t s;
615      while (*curenv) {
616        s = strcspn(curenv, HWLOC_COMPONENT_SEPS);
617        if (s) {
618  	char c;
619  	if (curenv[0] != HWLOC_COMPONENT_EXCLUDE_CHAR)
620  	  goto nextname;
621  	c = curenv[s];
622  	curenv[s] = '\0';
623  	hwloc_disc_component_blacklist_one(topology, curenv+1);
624  	for(i=0; i<s; i++)
625  	  curenv[i] = *HWLOC_COMPONENT_SEPS;
626  	curenv[s] = c;
627        }
628      nextname:
629        curenv += s;
630        if (*curenv)
631  	curenv++;
632      }
633    }
634    if (env) {
635      char *curenv = env;
<span onclick='openModal()' class='match'>636      size_t s;
637      while (*curenv) {
638        s = strcspn(curenv, HWLOC_COMPONENT_SEPS);
639        if (s) {
640  	char c;
641  	const char *name;
</span>642  	if (!strncmp(curenv, HWLOC_COMPONENT_STOP_NAME, s)) {
643  	  tryall = 0;
644  	  break;
645  	}
646  	c = curenv[s];
647  	curenv[s] = '\0';
648  	name = curenv;
649  	if (!strcmp(name, "linuxpci") || !strcmp(name, "linuxio")) {
650  	  if (hwloc_components_verbose)
651  	    fprintf(stderr, "hwloc: Replacing deprecated component `%s' with `linux' in envvar forcing\n", name);
652  	  name = "linux";
653  	}
654  	comp = hwloc_disc_component_find(name, NULL &bsol;* we enable the entire component, phases must be blacklisted separately */);
655  	if (comp) {
656  	  unsigned blacklisted_phases = 0U;
657  	  for(i=0; i<topology->nr_blacklisted_components; i++)
658  	    if (comp == topology->blacklisted_components[i].component) {
659  	      blacklisted_phases = topology->blacklisted_components[i].phases;
660  	      break;
661  	    }
662  	  if (comp->phases & ~blacklisted_phases)
663  	    hwloc_disc_component_try_enable(topology, comp, 1 &bsol;* envvar forced */, blacklisted_phases);
664  	} else {
665            if (HWLOC_SHOW_CRITICAL_ERRORS())
666              fprintf(stderr, "hwloc: Cannot find discovery component `%s'\n", name);
667  	}
668  	curenv[s] = c;
669        }
670        curenv += s;
671        if (*curenv)
672  	curenv++;
673      }
674    }
675    if (tryall) {
676      comp = hwloc_disc_components;
677      while (NULL != comp) {
678        unsigned blacklisted_phases = 0U;
679        if (!comp->enabled_by_default)
680  	goto nextcomp;
681        for(i=0; i<topology->nr_blacklisted_components; i++)
682  	if (comp == topology->blacklisted_components[i].component) {
683  	  blacklisted_phases = topology->blacklisted_components[i].phases;
684  	  break;
685  	}
686        if (!(comp->phases & ~blacklisted_phases)) {
687  	if (hwloc_components_verbose)
688  	  fprintf(stderr, "hwloc: Excluding blacklisted discovery component `%s' phases 0x%x\n",
689  		  comp->name, comp->phases);
690  	goto nextcomp;
691        }
692        hwloc_disc_component_try_enable(topology, comp, 0 &bsol;* defaults, not envvar forced */, blacklisted_phases);
693  nextcomp:
694        comp = comp->next;
695      }
696    }
697    if (hwloc_components_verbose) {
698      int first = 1;
699      backend = topology->backends;
700      fprintf(stderr, "hwloc: Final list of enabled discovery components: ");
701      while (backend != NULL) {
702        fprintf(stderr, "%s%s(0x%x)", first ? "" : ",", backend->component->name, backend->phases);
703        backend = backend->next;
704        first = 0;
705      }
706      fprintf(stderr, "\n");
707    }
708    free(env);
709  }
710  void
711  hwloc_components_fini(void)
712  {
713    unsigned i;
714    HWLOC_COMPONENTS_LOCK();
715    assert(0 != hwloc_components_users);
716    if (0 != --hwloc_components_users) {
717      HWLOC_COMPONENTS_UNLOCK();
718      return;
719    }
720    for(i=0; i<hwloc_component_finalize_cb_count; i++)
721      hwloc_component_finalize_cbs[hwloc_component_finalize_cb_count-i-1](0);
722    free(hwloc_component_finalize_cbs);
723    hwloc_component_finalize_cbs = NULL;
724    hwloc_component_finalize_cb_count = 0;
725    hwloc_disc_components = NULL;
726    hwloc_xml_callbacks_reset();
727  #ifdef HWLOC_HAVE_PLUGINS
728    hwloc_plugins_exit();
729  #endif
730    HWLOC_COMPONENTS_UNLOCK();
731  }
732  struct hwloc_backend *
733  hwloc_backend_alloc(struct hwloc_topology *topology,
734  		    struct hwloc_disc_component *component)
735  {
736    struct hwloc_backend * backend = malloc(sizeof(*backend));
737    if (!backend) {
738      errno = ENOMEM;
739      return NULL;
740    }
741    backend->component = component;
742    backend->topology = topology;
743    backend->phases = component->phases & ~topology->backend_excluded_phases;
744    if (backend->phases != component->phases && hwloc_components_verbose)
745      fprintf(stderr, "hwloc: Trying discovery component `%s' with phases 0x%x instead of 0x%x\n",
746  	    component->name, backend->phases, component->phases);
747    backend->flags = 0;
748    backend->discover = NULL;
749    backend->get_pci_busid_cpuset = NULL;
750    backend->disable = NULL;
751    backend->is_thissystem = -1;
752    backend->next = NULL;
753    backend->envvar_forced = 0;
754    return backend;
755  }
756  static void
757  hwloc_backend_disable(struct hwloc_backend *backend)
758  {
759    if (backend->disable)
760      backend->disable(backend);
761    free(backend);
762  }
763  int
764  hwloc_backend_enable(struct hwloc_backend *backend)
765  {
766    struct hwloc_topology *topology = backend->topology;
767    struct hwloc_backend **pprev;
768    if (backend->flags) {
769      if (HWLOC_SHOW_CRITICAL_ERRORS())
770        fprintf(stderr, "hwloc: Cannot enable discovery component `%s' phases 0x%x with unknown flags %lx\n",
771                backend->component->name, backend->component->phases, backend->flags);
772      return -1;
773    }
774    pprev = &topology->backends;
775    while (NULL != *pprev) {
776      if ((*pprev)->component == backend->component) {
777        if (hwloc_components_verbose)
778  	fprintf(stderr, "hwloc: Cannot enable  discovery component `%s' phases 0x%x twice\n",
779  		backend->component->name, backend->component->phases);
780        hwloc_backend_disable(backend);
781        errno = EBUSY;
782        return -1;
783      }
784      pprev = &((*pprev)->next);
785    }
786    if (hwloc_components_verbose)
787      fprintf(stderr, "hwloc: Enabling discovery component `%s' with phases 0x%x (among 0x%x)\n",
788  	    backend->component->name, backend->phases, backend->component->phases);
789    pprev = &topology->backends;
790    while (NULL != *pprev)
791      pprev = &((*pprev)->next);
792    backend->next = *pprev;
793    *pprev = backend;
794    topology->backend_phases |= backend->component->phases;
795    topology->backend_excluded_phases |= backend->component->excluded_phases;
796    return 0;
797  }
798  void
799  hwloc_backends_is_thissystem(struct hwloc_topology *topology)
800  {
801    struct hwloc_backend *backend;
802    const char *local_env;
803    topology->is_thissystem = 1;
804    backend = topology->backends;
805    while (backend != NULL) {
806      if (backend->envvar_forced == 0 && backend->is_thissystem != -1) {
807        assert(backend->is_thissystem == 0);
808        topology->is_thissystem = 0;
809      }
810      backend = backend->next;
811    }
812    if (topology->flags & HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM)
813      topology->is_thissystem = 1;
814    backend = topology->backends;
815    while (backend != NULL) {
816      if (backend->envvar_forced == 1 && backend->is_thissystem != -1) {
817        assert(backend->is_thissystem == 0);
818        topology->is_thissystem = 0;
819      }
820      backend = backend->next;
821    }
822    local_env = getenv("HWLOC_THISSYSTEM");
823    if (local_env)
824      topology->is_thissystem = atoi(local_env);
825  }
826  void
827  hwloc_backends_find_callbacks(struct hwloc_topology *topology)
828  {
829    struct hwloc_backend *backend = topology->backends;
830    topology->get_pci_busid_cpuset_backend = NULL;
831    while (backend != NULL) {
832      if (backend->get_pci_busid_cpuset) {
833        topology->get_pci_busid_cpuset_backend = backend;
834        return;
835      }
836      backend = backend->next;
837    }
838    return;
839  }
840  void
841  hwloc_backends_disable_all(struct hwloc_topology *topology)
842  {
843    struct hwloc_backend *backend;
844    while (NULL != (backend = topology->backends)) {
845      struct hwloc_backend *next = backend->next;
846      if (hwloc_components_verbose)
847        fprintf(stderr, "hwloc: Disabling discovery component `%s'\n",
848  	      backend->component->name);
849      hwloc_backend_disable(backend);
850      topology->backends = next;
851    }
852    topology->backends = NULL;
853    topology->backend_excluded_phases = 0;
854  }
855  void
856  hwloc_topology_components_fini(struct hwloc_topology *topology)
857  {
858    assert(!topology->backends);
859    free(topology->blacklisted_components);
860  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-components.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-components.c</div>
                </div>
                <div class="column column_space"><pre><code>614      size_t s;
615      while (*curenv) {
616        s = strcspn(curenv, HWLOC_COMPONENT_SEPS);
617        if (s) {
618  	char c;
619  	if (curenv[0] != HWLOC_COMPONENT_EXCLUDE_CHAR)
</pre></code></div>
                <div class="column column_space"><pre><code>636      size_t s;
637      while (*curenv) {
638        s = strcspn(curenv, HWLOC_COMPONENT_SEPS);
639        if (s) {
640  	char c;
641  	const char *name;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    