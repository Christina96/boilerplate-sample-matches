
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.5930572982015896%, Tokens: 10</h2>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-avcodec.h</h3>
            <pre><code>1  #ifndef AVCODEC_AVCODEC_H
2  #define AVCODEC_AVCODEC_H
3  #include <errno.h>
4  #include "libavutil/samplefmt.h"
5  #include "libavutil/attributes.h"
6  #include "libavutil/avutil.h"
7  #include "libavutil/buffer.h"
8  #include "libavutil/cpu.h"
9  #include "libavutil/channel_layout.h"
10  #include "libavutil/dict.h"
11  #include "libavutil/frame.h"
12  #include "libavutil/log.h"
13  #include "libavutil/pixfmt.h"
14  #include "libavutil/rational.h"
15  #include "version.h"
16  enum AVCodecID {
17      AV_CODEC_ID_NONE,
18      AV_CODEC_ID_MPEG1VIDEO,
19      AV_CODEC_ID_MPEG2VIDEO, 
20  #if FF_API_XVMC
21      AV_CODEC_ID_MPEG2VIDEO_XVMC,
22  #endif &bsol;* FF_API_XVMC */
23      AV_CODEC_ID_H261,
24      AV_CODEC_ID_H263,
25      AV_CODEC_ID_RV10,
26      AV_CODEC_ID_RV20,
27      AV_CODEC_ID_MJPEG,
28      AV_CODEC_ID_MJPEGB,
29      AV_CODEC_ID_LJPEG,
30      AV_CODEC_ID_SP5X,
31      AV_CODEC_ID_JPEGLS,
32      AV_CODEC_ID_MPEG4,
33      AV_CODEC_ID_RAWVIDEO,
34      AV_CODEC_ID_MSMPEG4V1,
35      AV_CODEC_ID_MSMPEG4V2,
36      AV_CODEC_ID_MSMPEG4V3,
37      AV_CODEC_ID_WMV1,
38      AV_CODEC_ID_WMV2,
39      AV_CODEC_ID_H263P,
40      AV_CODEC_ID_H263I,
41      AV_CODEC_ID_FLV1,
42      AV_CODEC_ID_SVQ1,
43      AV_CODEC_ID_SVQ3,
44      AV_CODEC_ID_DVVIDEO,
45      AV_CODEC_ID_HUFFYUV,
46      AV_CODEC_ID_CYUV,
47      AV_CODEC_ID_H264,
48      AV_CODEC_ID_INDEO3,
49      AV_CODEC_ID_VP3,
50      AV_CODEC_ID_THEORA,
51      AV_CODEC_ID_ASV1,
52      AV_CODEC_ID_ASV2,
53      AV_CODEC_ID_FFV1,
54      AV_CODEC_ID_4XM,
55      AV_CODEC_ID_VCR1,
56      AV_CODEC_ID_CLJR,
57      AV_CODEC_ID_MDEC,
58      AV_CODEC_ID_ROQ,
59      AV_CODEC_ID_INTERPLAY_VIDEO,
60      AV_CODEC_ID_XAN_WC3,
61      AV_CODEC_ID_XAN_WC4,
62      AV_CODEC_ID_RPZA,
63      AV_CODEC_ID_CINEPAK,
64      AV_CODEC_ID_WS_VQA,
65      AV_CODEC_ID_MSRLE,
66      AV_CODEC_ID_MSVIDEO1,
67      AV_CODEC_ID_IDCIN,
68      AV_CODEC_ID_8BPS,
69      AV_CODEC_ID_SMC,
70      AV_CODEC_ID_FLIC,
71      AV_CODEC_ID_TRUEMOTION1,
72      AV_CODEC_ID_VMDVIDEO,
73      AV_CODEC_ID_MSZH,
74      AV_CODEC_ID_ZLIB,
75      AV_CODEC_ID_QTRLE,
76      AV_CODEC_ID_TSCC,
77      AV_CODEC_ID_ULTI,
78      AV_CODEC_ID_QDRAW,
79      AV_CODEC_ID_VIXL,
80      AV_CODEC_ID_QPEG,
81      AV_CODEC_ID_PNG,
82      AV_CODEC_ID_PPM,
83      AV_CODEC_ID_PBM,
84      AV_CODEC_ID_PGM,
85      AV_CODEC_ID_PGMYUV,
86      AV_CODEC_ID_PAM,
87      AV_CODEC_ID_FFVHUFF,
88      AV_CODEC_ID_RV30,
89      AV_CODEC_ID_RV40,
90      AV_CODEC_ID_VC1,
91      AV_CODEC_ID_WMV3,
92      AV_CODEC_ID_LOCO,
93      AV_CODEC_ID_WNV1,
94      AV_CODEC_ID_AASC,
95      AV_CODEC_ID_INDEO2,
96      AV_CODEC_ID_FRAPS,
97      AV_CODEC_ID_TRUEMOTION2,
98      AV_CODEC_ID_BMP,
99      AV_CODEC_ID_CSCD,
100      AV_CODEC_ID_MMVIDEO,
101      AV_CODEC_ID_ZMBV,
102      AV_CODEC_ID_AVS,
103      AV_CODEC_ID_SMACKVIDEO,
104      AV_CODEC_ID_NUV,
105      AV_CODEC_ID_KMVC,
106      AV_CODEC_ID_FLASHSV,
107      AV_CODEC_ID_CAVS,
108      AV_CODEC_ID_JPEG2000,
109      AV_CODEC_ID_VMNC,
110      AV_CODEC_ID_VP5,
111      AV_CODEC_ID_VP6,
112      AV_CODEC_ID_VP6F,
113      AV_CODEC_ID_TARGA,
114      AV_CODEC_ID_DSICINVIDEO,
115      AV_CODEC_ID_TIERTEXSEQVIDEO,
116      AV_CODEC_ID_TIFF,
117      AV_CODEC_ID_GIF,
118      AV_CODEC_ID_DXA,
119      AV_CODEC_ID_DNXHD,
120      AV_CODEC_ID_THP,
121      AV_CODEC_ID_SGI,
122      AV_CODEC_ID_C93,
123      AV_CODEC_ID_BETHSOFTVID,
124      AV_CODEC_ID_PTX,
125      AV_CODEC_ID_TXD,
126      AV_CODEC_ID_VP6A,
127      AV_CODEC_ID_AMV,
128      AV_CODEC_ID_VB,
129      AV_CODEC_ID_PCX,
130      AV_CODEC_ID_SUNRAST,
131      AV_CODEC_ID_INDEO4,
132      AV_CODEC_ID_INDEO5,
133      AV_CODEC_ID_MIMIC,
134      AV_CODEC_ID_RL2,
135      AV_CODEC_ID_ESCAPE124,
136      AV_CODEC_ID_DIRAC,
137      AV_CODEC_ID_BFI,
138      AV_CODEC_ID_CMV,
139      AV_CODEC_ID_MOTIONPIXELS,
140      AV_CODEC_ID_TGV,
141      AV_CODEC_ID_TGQ,
142      AV_CODEC_ID_TQI,
143      AV_CODEC_ID_AURA,
144      AV_CODEC_ID_AURA2,
145      AV_CODEC_ID_V210X,
146      AV_CODEC_ID_TMV,
147      AV_CODEC_ID_V210,
148      AV_CODEC_ID_DPX,
149      AV_CODEC_ID_MAD,
150      AV_CODEC_ID_FRWU,
151      AV_CODEC_ID_FLASHSV2,
152      AV_CODEC_ID_CDGRAPHICS,
153      AV_CODEC_ID_R210,
154      AV_CODEC_ID_ANM,
155      AV_CODEC_ID_BINKVIDEO,
156      AV_CODEC_ID_IFF_ILBM,
157  #define AV_CODEC_ID_IFF_BYTERUN1 AV_CODEC_ID_IFF_ILBM
158      AV_CODEC_ID_KGV1,
159      AV_CODEC_ID_YOP,
160      AV_CODEC_ID_VP8,
161      AV_CODEC_ID_PICTOR,
162      AV_CODEC_ID_ANSI,
163      AV_CODEC_ID_A64_MULTI,
164      AV_CODEC_ID_A64_MULTI5,
165      AV_CODEC_ID_R10K,
166      AV_CODEC_ID_MXPEG,
167      AV_CODEC_ID_LAGARITH,
168      AV_CODEC_ID_PRORES,
169      AV_CODEC_ID_JV,
170      AV_CODEC_ID_DFA,
171      AV_CODEC_ID_WMV3IMAGE,
172      AV_CODEC_ID_VC1IMAGE,
173      AV_CODEC_ID_UTVIDEO,
174      AV_CODEC_ID_BMV_VIDEO,
175      AV_CODEC_ID_VBLE,
176      AV_CODEC_ID_DXTORY,
177      AV_CODEC_ID_V410,
178      AV_CODEC_ID_XWD,
179      AV_CODEC_ID_CDXL,
180      AV_CODEC_ID_XBM,
181      AV_CODEC_ID_ZEROCODEC,
182      AV_CODEC_ID_MSS1,
183      AV_CODEC_ID_MSA1,
184      AV_CODEC_ID_TSCC2,
185      AV_CODEC_ID_MTS2,
186      AV_CODEC_ID_CLLC,
187      AV_CODEC_ID_MSS2,
188      AV_CODEC_ID_VP9,
189      AV_CODEC_ID_AIC,
190      AV_CODEC_ID_ESCAPE130,
191      AV_CODEC_ID_G2M,
192      AV_CODEC_ID_WEBP,
193      AV_CODEC_ID_HNM4_VIDEO,
194      AV_CODEC_ID_HEVC,
195  #define AV_CODEC_ID_H265 AV_CODEC_ID_HEVC
196      AV_CODEC_ID_FIC,
197      AV_CODEC_ID_ALIAS_PIX,
198      AV_CODEC_ID_BRENDER_PIX,
199      AV_CODEC_ID_PAF_VIDEO,
200      AV_CODEC_ID_EXR,
201      AV_CODEC_ID_VP7,
202      AV_CODEC_ID_SANM,
203      AV_CODEC_ID_SGIRLE,
204      AV_CODEC_ID_MVC1,
205      AV_CODEC_ID_MVC2,
206      AV_CODEC_ID_HQX,
207      AV_CODEC_ID_TDSC,
208      AV_CODEC_ID_HQ_HQA,
209      AV_CODEC_ID_HAP,
210      AV_CODEC_ID_DDS,
211      AV_CODEC_ID_DXV,
212      AV_CODEC_ID_SCREENPRESSO,
213      AV_CODEC_ID_RSCC,
214      AV_CODEC_ID_Y41P = 0x8000,
215      AV_CODEC_ID_AVRP,
216      AV_CODEC_ID_012V,
217      AV_CODEC_ID_AVUI,
218      AV_CODEC_ID_AYUV,
219      AV_CODEC_ID_TARGA_Y216,
220      AV_CODEC_ID_V308,
221      AV_CODEC_ID_V408,
222      AV_CODEC_ID_YUV4,
223      AV_CODEC_ID_AVRN,
224      AV_CODEC_ID_CPIA,
225      AV_CODEC_ID_XFACE,
226      AV_CODEC_ID_SNOW,
227      AV_CODEC_ID_SMVJPEG,
228      AV_CODEC_ID_APNG,
229      AV_CODEC_ID_DAALA,
230      AV_CODEC_ID_CFHD,
231      AV_CODEC_ID_TRUEMOTION2RT,
232      AV_CODEC_ID_M101,
233      AV_CODEC_ID_MAGICYUV,
234      AV_CODEC_ID_SHEERVIDEO,
235      AV_CODEC_ID_YLC,
236      AV_CODEC_ID_PSD,
237      AV_CODEC_ID_PIXLET,
238      AV_CODEC_ID_SPEEDHQ,
239      AV_CODEC_ID_FMVC,
240      AV_CODEC_ID_SCPR,
241      AV_CODEC_ID_CLEARVIDEO,
242      AV_CODEC_ID_XPM,
243      AV_CODEC_ID_AV1,
244      AV_CODEC_ID_BITPACKED,
245      AV_CODEC_ID_MSCC,
246      AV_CODEC_ID_SRGC,
247      AV_CODEC_ID_SVG,
248      AV_CODEC_ID_GDV,
249      AV_CODEC_ID_FITS,
250      AV_CODEC_ID_FIRST_AUDIO = 0x10000,     
251      AV_CODEC_ID_PCM_S16LE = 0x10000,
252      AV_CODEC_ID_PCM_S16BE,
253      AV_CODEC_ID_PCM_U16LE,
254      AV_CODEC_ID_PCM_U16BE,
255      AV_CODEC_ID_PCM_S8,
256      AV_CODEC_ID_PCM_U8,
257      AV_CODEC_ID_PCM_MULAW,
258      AV_CODEC_ID_PCM_ALAW,
259      AV_CODEC_ID_PCM_S32LE,
260      AV_CODEC_ID_PCM_S32BE,
261      AV_CODEC_ID_PCM_U32LE,
262      AV_CODEC_ID_PCM_U32BE,
263      AV_CODEC_ID_PCM_S24LE,
264      AV_CODEC_ID_PCM_S24BE,
265      AV_CODEC_ID_PCM_U24LE,
266      AV_CODEC_ID_PCM_U24BE,
267      AV_CODEC_ID_PCM_S24DAUD,
268      AV_CODEC_ID_PCM_ZORK,
269      AV_CODEC_ID_PCM_S16LE_PLANAR,
270      AV_CODEC_ID_PCM_DVD,
271      AV_CODEC_ID_PCM_F32BE,
272      AV_CODEC_ID_PCM_F32LE,
273      AV_CODEC_ID_PCM_F64BE,
274      AV_CODEC_ID_PCM_F64LE,
275      AV_CODEC_ID_PCM_BLURAY,
276      AV_CODEC_ID_PCM_LXF,
277      AV_CODEC_ID_S302M,
278      AV_CODEC_ID_PCM_S8_PLANAR,
279      AV_CODEC_ID_PCM_S24LE_PLANAR,
280      AV_CODEC_ID_PCM_S32LE_PLANAR,
281      AV_CODEC_ID_PCM_S16BE_PLANAR,
282      AV_CODEC_ID_PCM_S64LE = 0x10800,
283      AV_CODEC_ID_PCM_S64BE,
284      AV_CODEC_ID_PCM_F16LE,
285      AV_CODEC_ID_PCM_F24LE,
286      AV_CODEC_ID_ADPCM_IMA_QT = 0x11000,
287      AV_CODEC_ID_ADPCM_IMA_WAV,
288      AV_CODEC_ID_ADPCM_IMA_DK3,
289      AV_CODEC_ID_ADPCM_IMA_DK4,
290      AV_CODEC_ID_ADPCM_IMA_WS,
291      AV_CODEC_ID_ADPCM_IMA_SMJPEG,
292      AV_CODEC_ID_ADPCM_MS,
293      AV_CODEC_ID_ADPCM_4XM,
294      AV_CODEC_ID_ADPCM_XA,
295      AV_CODEC_ID_ADPCM_ADX,
296      AV_CODEC_ID_ADPCM_EA,
297      AV_CODEC_ID_ADPCM_G726,
298      AV_CODEC_ID_ADPCM_CT,
299      AV_CODEC_ID_ADPCM_SWF,
300      AV_CODEC_ID_ADPCM_YAMAHA,
301      AV_CODEC_ID_ADPCM_SBPRO_4,
302      AV_CODEC_ID_ADPCM_SBPRO_3,
303      AV_CODEC_ID_ADPCM_SBPRO_2,
304      AV_CODEC_ID_ADPCM_THP,
305      AV_CODEC_ID_ADPCM_IMA_AMV,
306      AV_CODEC_ID_ADPCM_EA_R1,
307      AV_CODEC_ID_ADPCM_EA_R3,
308      AV_CODEC_ID_ADPCM_EA_R2,
309      AV_CODEC_ID_ADPCM_IMA_EA_SEAD,
310      AV_CODEC_ID_ADPCM_IMA_EA_EACS,
311      AV_CODEC_ID_ADPCM_EA_XAS,
312      AV_CODEC_ID_ADPCM_EA_MAXIS_XA,
313      AV_CODEC_ID_ADPCM_IMA_ISS,
314      AV_CODEC_ID_ADPCM_G722,
315      AV_CODEC_ID_ADPCM_IMA_APC,
316      AV_CODEC_ID_ADPCM_VIMA,
317  #if FF_API_VIMA_DECODER
318      AV_CODEC_ID_VIMA = AV_CODEC_ID_ADPCM_VIMA,
319  #endif
320      AV_CODEC_ID_ADPCM_AFC = 0x11800,
321      AV_CODEC_ID_ADPCM_IMA_OKI,
322      AV_CODEC_ID_ADPCM_DTK,
323      AV_CODEC_ID_ADPCM_IMA_RAD,
324      AV_CODEC_ID_ADPCM_G726LE,
325      AV_CODEC_ID_ADPCM_THP_LE,
326      AV_CODEC_ID_ADPCM_PSX,
327      AV_CODEC_ID_ADPCM_AICA,
328      AV_CODEC_ID_ADPCM_IMA_DAT4,
329      AV_CODEC_ID_ADPCM_MTAF,
330      AV_CODEC_ID_AMR_NB = 0x12000,
331      AV_CODEC_ID_AMR_WB,
332      AV_CODEC_ID_RA_144 = 0x13000,
333      AV_CODEC_ID_RA_288,
334      AV_CODEC_ID_ROQ_DPCM = 0x14000,
335      AV_CODEC_ID_INTERPLAY_DPCM,
336      AV_CODEC_ID_XAN_DPCM,
337      AV_CODEC_ID_SOL_DPCM,
338      AV_CODEC_ID_SDX2_DPCM = 0x14800,
339      AV_CODEC_ID_GREMLIN_DPCM,
340      AV_CODEC_ID_MP2 = 0x15000,
341      AV_CODEC_ID_MP3, 
342      AV_CODEC_ID_AAC,
343      AV_CODEC_ID_AC3,
344      AV_CODEC_ID_DTS,
345      AV_CODEC_ID_VORBIS,
346      AV_CODEC_ID_DVAUDIO,
347      AV_CODEC_ID_WMAV1,
348      AV_CODEC_ID_WMAV2,
349      AV_CODEC_ID_MACE3,
350      AV_CODEC_ID_MACE6,
351      AV_CODEC_ID_VMDAUDIO,
352      AV_CODEC_ID_FLAC,
353      AV_CODEC_ID_MP3ADU,
354      AV_CODEC_ID_MP3ON4,
355      AV_CODEC_ID_SHORTEN,
356      AV_CODEC_ID_ALAC,
357      AV_CODEC_ID_WESTWOOD_SND1,
358      AV_CODEC_ID_GSM, 
359      AV_CODEC_ID_QDM2,
360      AV_CODEC_ID_COOK,
361      AV_CODEC_ID_TRUESPEECH,
362      AV_CODEC_ID_TTA,
363      AV_CODEC_ID_SMACKAUDIO,
364      AV_CODEC_ID_QCELP,
365      AV_CODEC_ID_WAVPACK,
366      AV_CODEC_ID_DSICINAUDIO,
367      AV_CODEC_ID_IMC,
368      AV_CODEC_ID_MUSEPACK7,
369      AV_CODEC_ID_MLP,
370      AV_CODEC_ID_GSM_MS, &bsol;* as found in WAV */
371      AV_CODEC_ID_ATRAC3,
372  #if FF_API_VOXWARE
373      AV_CODEC_ID_VOXWARE,
374  #endif
375      AV_CODEC_ID_APE,
376      AV_CODEC_ID_NELLYMOSER,
377      AV_CODEC_ID_MUSEPACK8,
378      AV_CODEC_ID_SPEEX,
379      AV_CODEC_ID_WMAVOICE,
380      AV_CODEC_ID_WMAPRO,
381      AV_CODEC_ID_WMALOSSLESS,
382      AV_CODEC_ID_ATRAC3P,
383      AV_CODEC_ID_EAC3,
384      AV_CODEC_ID_SIPR,
385      AV_CODEC_ID_MP1,
386      AV_CODEC_ID_TWINVQ,
387      AV_CODEC_ID_TRUEHD,
388      AV_CODEC_ID_MP4ALS,
389      AV_CODEC_ID_ATRAC1,
390      AV_CODEC_ID_BINKAUDIO_RDFT,
391      AV_CODEC_ID_BINKAUDIO_DCT,
392      AV_CODEC_ID_AAC_LATM,
393      AV_CODEC_ID_QDMC,
394      AV_CODEC_ID_CELT,
395      AV_CODEC_ID_G723_1,
396      AV_CODEC_ID_G729,
397      AV_CODEC_ID_8SVX_EXP,
398      AV_CODEC_ID_8SVX_FIB,
399      AV_CODEC_ID_BMV_AUDIO,
400      AV_CODEC_ID_RALF,
401      AV_CODEC_ID_IAC,
402      AV_CODEC_ID_ILBC,
403      AV_CODEC_ID_OPUS,
404      AV_CODEC_ID_COMFORT_NOISE,
405      AV_CODEC_ID_TAK,
406      AV_CODEC_ID_METASOUND,
407      AV_CODEC_ID_PAF_AUDIO,
408      AV_CODEC_ID_ON2AVC,
409      AV_CODEC_ID_DSS_SP,
410      AV_CODEC_ID_FFWAVESYNTH = 0x15800,
411      AV_CODEC_ID_SONIC,
412      AV_CODEC_ID_SONIC_LS,
413      AV_CODEC_ID_EVRC,
414      AV_CODEC_ID_SMV,
415      AV_CODEC_ID_DSD_LSBF,
416      AV_CODEC_ID_DSD_MSBF,
417      AV_CODEC_ID_DSD_LSBF_PLANAR,
418      AV_CODEC_ID_DSD_MSBF_PLANAR,
419      AV_CODEC_ID_4GV,
420      AV_CODEC_ID_INTERPLAY_ACM,
421      AV_CODEC_ID_XMA1,
422      AV_CODEC_ID_XMA2,
423      AV_CODEC_ID_DST,
424      AV_CODEC_ID_ATRAC3AL,
425      AV_CODEC_ID_ATRAC3PAL,
426      AV_CODEC_ID_DOLBY_E,
427      AV_CODEC_ID_FIRST_SUBTITLE = 0x17000,          
428      AV_CODEC_ID_DVD_SUBTITLE = 0x17000,
429      AV_CODEC_ID_DVB_SUBTITLE,
430      AV_CODEC_ID_TEXT,  
431      AV_CODEC_ID_XSUB,
432      AV_CODEC_ID_SSA,
433      AV_CODEC_ID_MOV_TEXT,
434      AV_CODEC_ID_HDMV_PGS_SUBTITLE,
435      AV_CODEC_ID_DVB_TELETEXT,
436      AV_CODEC_ID_SRT,
437      AV_CODEC_ID_MICRODVD   = 0x17800,
438      AV_CODEC_ID_EIA_608,
439      AV_CODEC_ID_JACOSUB,
440      AV_CODEC_ID_SAMI,
441      AV_CODEC_ID_REALTEXT,
442      AV_CODEC_ID_STL,
443      AV_CODEC_ID_SUBVIEWER1,
444      AV_CODEC_ID_SUBVIEWER,
445      AV_CODEC_ID_SUBRIP,
446      AV_CODEC_ID_WEBVTT,
447      AV_CODEC_ID_MPL2,
448      AV_CODEC_ID_VPLAYER,
449      AV_CODEC_ID_PJS,
450      AV_CODEC_ID_ASS,
451      AV_CODEC_ID_HDMV_TEXT_SUBTITLE,
452      AV_CODEC_ID_FIRST_UNKNOWN = 0x18000,           
453      AV_CODEC_ID_TTF = 0x18000,
454      AV_CODEC_ID_SCTE_35, 
455      AV_CODEC_ID_BINTEXT    = 0x18800,
456      AV_CODEC_ID_XBIN,
457      AV_CODEC_ID_IDF,
458      AV_CODEC_ID_OTF,
459      AV_CODEC_ID_SMPTE_KLV,
460      AV_CODEC_ID_DVD_NAV,
461      AV_CODEC_ID_TIMED_ID3,
462      AV_CODEC_ID_BIN_DATA,
463      AV_CODEC_ID_PROBE = 0x19000, 
464      AV_CODEC_ID_MPEG2TS = 0x20000, &bsol;**< _FAKE_ codec to indicate a raw MPEG-2 TS
465                                  * stream (only used by libavformat) */
466      AV_CODEC_ID_MPEG4SYSTEMS = 0x20001, &bsol;**< _FAKE_ codec to indicate a MPEG-4 Systems
467                                  * stream (only used by libavformat) */
468      AV_CODEC_ID_FFMETADATA = 0x21000,   
469      AV_CODEC_ID_WRAPPED_AVFRAME = 0x21001, 
470  };
471  typedef struct AVCodecDescriptor {
472      enum AVCodecID     id;
473      enum AVMediaType type;
474      const char      *name;
475      const char *long_name;
476      int             props;
477      const char *const *mime_types;
478      const struct AVProfile *profiles;
479  } AVCodecDescriptor;
480  #define AV_CODEC_PROP_INTRA_ONLY    (1 << 0)
481  #define AV_CODEC_PROP_LOSSY         (1 << 1)
482  #define AV_CODEC_PROP_LOSSLESS      (1 << 2)
483  #define AV_CODEC_PROP_REORDER       (1 << 3)
484  #define AV_CODEC_PROP_BITMAP_SUB    (1 << 16)
485  #define AV_CODEC_PROP_TEXT_SUB      (1 << 17)
486  #define AV_INPUT_BUFFER_PADDING_SIZE 32
487  #define AV_INPUT_BUFFER_MIN_SIZE 16384
488  #if FF_API_WITHOUT_PREFIX
489  #define FF_INPUT_BUFFER_PADDING_SIZE 32
490  #define FF_MIN_BUFFER_SIZE 16384
491  #endif &bsol;* FF_API_WITHOUT_PREFIX */
492  #if FF_API_MOTION_EST
493  enum Motion_Est_ID {
494      ME_ZERO = 1,    
495      ME_FULL,
496      ME_LOG,
497      ME_PHODS,
498      ME_EPZS,        
499      ME_X1,          
500      ME_HEX,         
501      ME_UMH,         
502      ME_TESA,        
503      ME_ITER=50,     
504  };
505  #endif
506  enum AVDiscard{
507      AVDISCARD_NONE    =-16, 
508      AVDISCARD_DEFAULT =  0, 
509      AVDISCARD_NONREF  =  8, 
510      AVDISCARD_BIDIR   = 16, 
511      AVDISCARD_NONINTRA= 24, 
512      AVDISCARD_NONKEY  = 32, 
513      AVDISCARD_ALL     = 48, 
514  };
515  enum AVAudioServiceType {
<span onclick='openModal()' class='match'>516      AV_AUDIO_SERVICE_TYPE_MAIN              = 0,
517      AV_AUDIO_SERVICE_TYPE_EFFECTS           = 1,
518      AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2,
519      AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED  = 3,
520      AV_AUDIO_SERVICE_TYPE_DIALOGUE          = 4,
521      AV_AUDIO_SERVICE_TYPE_COMMENTARY        = 5,
522      AV_AUDIO_SERVICE_TYPE_EMERGENCY         = 6,
523      AV_AUDIO_SERVICE_TYPE_VOICE_OVER        = 7,
524      AV_AUDIO_SERVICE_TYPE_KARAOKE           = 8,
525      AV_AUDIO_SERVICE_TYPE_NB                   , 
526  };
</span>527  typedef struct RcOverride{
528      int start_frame;
529      int end_frame;
530      int qscale; 
531      float quality_factor;
532  } RcOverride;
533  #if FF_API_MAX_BFRAMES
534  #define FF_MAX_B_FRAMES 16
535  #endif
536  #define AV_CODEC_FLAG_UNALIGNED       (1 <<  0)
537  #define AV_CODEC_FLAG_QSCALE          (1 <<  1)
538  #define AV_CODEC_FLAG_4MV             (1 <<  2)
539  #define AV_CODEC_FLAG_OUTPUT_CORRUPT  (1 <<  3)
540  #define AV_CODEC_FLAG_QPEL            (1 <<  4)
541  #define AV_CODEC_FLAG_PASS1           (1 <<  9)
542  #define AV_CODEC_FLAG_PASS2           (1 << 10)
543  #define AV_CODEC_FLAG_LOOP_FILTER     (1 << 11)
544  #define AV_CODEC_FLAG_GRAY            (1 << 13)
545  #define AV_CODEC_FLAG_PSNR            (1 << 15)
546  #define AV_CODEC_FLAG_TRUNCATED       (1 << 16)
547  #define AV_CODEC_FLAG_INTERLACED_DCT  (1 << 18)
548  #define AV_CODEC_FLAG_LOW_DELAY       (1 << 19)
549  #define AV_CODEC_FLAG_GLOBAL_HEADER   (1 << 22)
550  #define AV_CODEC_FLAG_BITEXACT        (1 << 23)
551  #define AV_CODEC_FLAG_AC_PRED         (1 << 24)
552  #define AV_CODEC_FLAG_INTERLACED_ME   (1 << 29)
553  #define AV_CODEC_FLAG_CLOSED_GOP      (1U << 31)
554  #define AV_CODEC_FLAG2_FAST           (1 <<  0)
555  #define AV_CODEC_FLAG2_NO_OUTPUT      (1 <<  2)
556  #define AV_CODEC_FLAG2_LOCAL_HEADER   (1 <<  3)
557  #define AV_CODEC_FLAG2_DROP_FRAME_TIMECODE (1 << 13)
558  #define AV_CODEC_FLAG2_CHUNKS         (1 << 15)
559  #define AV_CODEC_FLAG2_IGNORE_CROP    (1 << 16)
560  #define AV_CODEC_FLAG2_SHOW_ALL       (1 << 22)
561  #define AV_CODEC_FLAG2_EXPORT_MVS     (1 << 28)
562  #define AV_CODEC_FLAG2_SKIP_MANUAL    (1 << 29)
563  #define AV_CODEC_FLAG2_RO_FLUSH_NOOP  (1 << 30)
564  #define AV_CODEC_CAP_DRAW_HORIZ_BAND     (1 <<  0)
565  #define AV_CODEC_CAP_DR1                 (1 <<  1)
566  #define AV_CODEC_CAP_TRUNCATED           (1 <<  3)
567  #define AV_CODEC_CAP_DELAY               (1 <<  5)
568  #define AV_CODEC_CAP_SMALL_LAST_FRAME    (1 <<  6)
569  #if FF_API_CAP_VDPAU
570  #define AV_CODEC_CAP_HWACCEL_VDPAU       (1 <<  7)
571  #endif
572  #define AV_CODEC_CAP_SUBFRAMES           (1 <<  8)
573  #define AV_CODEC_CAP_EXPERIMENTAL        (1 <<  9)
574  #define AV_CODEC_CAP_CHANNEL_CONF        (1 << 10)
575  #define AV_CODEC_CAP_FRAME_THREADS       (1 << 12)
576  #define AV_CODEC_CAP_SLICE_THREADS       (1 << 13)
577  #define AV_CODEC_CAP_PARAM_CHANGE        (1 << 14)
578  #define AV_CODEC_CAP_AUTO_THREADS        (1 << 15)
579  #define AV_CODEC_CAP_VARIABLE_FRAME_SIZE (1 << 16)
580  #define AV_CODEC_CAP_AVOID_PROBING       (1 << 17)
581  #define AV_CODEC_CAP_INTRA_ONLY       0x40000000
582  #define AV_CODEC_CAP_LOSSLESS         0x80000000
583  #if FF_API_WITHOUT_PREFIX
584  #define CODEC_FLAG_UNALIGNED AV_CODEC_FLAG_UNALIGNED
585  #define CODEC_FLAG_QSCALE AV_CODEC_FLAG_QSCALE
586  #define CODEC_FLAG_4MV    AV_CODEC_FLAG_4MV
587  #define CODEC_FLAG_OUTPUT_CORRUPT AV_CODEC_FLAG_OUTPUT_CORRUPT
588  #define CODEC_FLAG_QPEL   AV_CODEC_FLAG_QPEL
589  #if FF_API_GMC
590  #define CODEC_FLAG_GMC    0x0020  
591  #endif
592  #if FF_API_MV0
593  #define CODEC_FLAG_MV0    0x0040
594  #endif
595  #if FF_API_INPUT_PRESERVED
596  #define CODEC_FLAG_INPUT_PRESERVED 0x0100
597  #endif
598  #define CODEC_FLAG_PASS1           AV_CODEC_FLAG_PASS1
599  #define CODEC_FLAG_PASS2           AV_CODEC_FLAG_PASS2
600  #define CODEC_FLAG_GRAY            AV_CODEC_FLAG_GRAY
601  #if FF_API_EMU_EDGE
602  #define CODEC_FLAG_EMU_EDGE        0x4000
603  #endif
604  #define CODEC_FLAG_PSNR            AV_CODEC_FLAG_PSNR
605  #define CODEC_FLAG_TRUNCATED       AV_CODEC_FLAG_TRUNCATED
606  #if FF_API_NORMALIZE_AQP
607  #define CODEC_FLAG_NORMALIZE_AQP  0x00020000
608  #endif
609  #define CODEC_FLAG_INTERLACED_DCT AV_CODEC_FLAG_INTERLACED_DCT
610  #define CODEC_FLAG_LOW_DELAY      AV_CODEC_FLAG_LOW_DELAY
611  #define CODEC_FLAG_GLOBAL_HEADER  AV_CODEC_FLAG_GLOBAL_HEADER
612  #define CODEC_FLAG_BITEXACT       AV_CODEC_FLAG_BITEXACT
613  #define CODEC_FLAG_AC_PRED        AV_CODEC_FLAG_AC_PRED
614  #define CODEC_FLAG_LOOP_FILTER    AV_CODEC_FLAG_LOOP_FILTER
615  #define CODEC_FLAG_INTERLACED_ME  AV_CODEC_FLAG_INTERLACED_ME
616  #define CODEC_FLAG_CLOSED_GOP     AV_CODEC_FLAG_CLOSED_GOP
617  #define CODEC_FLAG2_FAST          AV_CODEC_FLAG2_FAST
618  #define CODEC_FLAG2_NO_OUTPUT     AV_CODEC_FLAG2_NO_OUTPUT
619  #define CODEC_FLAG2_LOCAL_HEADER  AV_CODEC_FLAG2_LOCAL_HEADER
620  #define CODEC_FLAG2_DROP_FRAME_TIMECODE AV_CODEC_FLAG2_DROP_FRAME_TIMECODE
621  #define CODEC_FLAG2_IGNORE_CROP   AV_CODEC_FLAG2_IGNORE_CROP
622  #define CODEC_FLAG2_CHUNKS        AV_CODEC_FLAG2_CHUNKS
623  #define CODEC_FLAG2_SHOW_ALL      AV_CODEC_FLAG2_SHOW_ALL
624  #define CODEC_FLAG2_EXPORT_MVS    AV_CODEC_FLAG2_EXPORT_MVS
625  #define CODEC_FLAG2_SKIP_MANUAL   AV_CODEC_FLAG2_SKIP_MANUAL
626  #define CODEC_CAP_DRAW_HORIZ_BAND AV_CODEC_CAP_DRAW_HORIZ_BAND 
627  #define CODEC_CAP_DR1             AV_CODEC_CAP_DR1
628  #define CODEC_CAP_TRUNCATED       AV_CODEC_CAP_TRUNCATED
629  #if FF_API_XVMC
630  #define CODEC_CAP_HWACCEL         0x0010
631  #endif &bsol;* FF_API_XVMC */
632  #define CODEC_CAP_DELAY           AV_CODEC_CAP_DELAY
633  #define CODEC_CAP_SMALL_LAST_FRAME AV_CODEC_CAP_SMALL_LAST_FRAME
634  #if FF_API_CAP_VDPAU
635  #define CODEC_CAP_HWACCEL_VDPAU    AV_CODEC_CAP_HWACCEL_VDPAU
636  #endif
637  #define CODEC_CAP_SUBFRAMES        AV_CODEC_CAP_SUBFRAMES
638  #define CODEC_CAP_EXPERIMENTAL     AV_CODEC_CAP_EXPERIMENTAL
639  #define CODEC_CAP_CHANNEL_CONF     AV_CODEC_CAP_CHANNEL_CONF
640  #if FF_API_NEG_LINESIZES
641  #define CODEC_CAP_NEG_LINESIZES    0x0800
642  #endif
643  #define CODEC_CAP_FRAME_THREADS    AV_CODEC_CAP_FRAME_THREADS
644  #define CODEC_CAP_SLICE_THREADS    AV_CODEC_CAP_SLICE_THREADS
645  #define CODEC_CAP_PARAM_CHANGE     AV_CODEC_CAP_PARAM_CHANGE
646  #define CODEC_CAP_AUTO_THREADS     AV_CODEC_CAP_AUTO_THREADS
647  #define CODEC_CAP_VARIABLE_FRAME_SIZE AV_CODEC_CAP_VARIABLE_FRAME_SIZE
648  #define CODEC_CAP_INTRA_ONLY       AV_CODEC_CAP_INTRA_ONLY
649  #define CODEC_CAP_LOSSLESS         AV_CODEC_CAP_LOSSLESS
650  #define HWACCEL_CODEC_CAP_EXPERIMENTAL     0x0200
651  #endif &bsol;* FF_API_WITHOUT_PREFIX */
652  #if FF_API_MB_TYPE
653  #define MB_TYPE_INTRA4x4   0x0001
654  #define MB_TYPE_INTRA16x16 0x0002 
655  #define MB_TYPE_INTRA_PCM  0x0004 
656  #define MB_TYPE_16x16      0x0008
657  #define MB_TYPE_16x8       0x0010
658  #define MB_TYPE_8x16       0x0020
659  #define MB_TYPE_8x8        0x0040
660  #define MB_TYPE_INTERLACED 0x0080
661  #define MB_TYPE_DIRECT2    0x0100 
662  #define MB_TYPE_ACPRED     0x0200
663  #define MB_TYPE_GMC        0x0400
664  #define MB_TYPE_SKIP       0x0800
665  #define MB_TYPE_P0L0       0x1000
666  #define MB_TYPE_P1L0       0x2000
667  #define MB_TYPE_P0L1       0x4000
668  #define MB_TYPE_P1L1       0x8000
669  #define MB_TYPE_L0         (MB_TYPE_P0L0 | MB_TYPE_P1L0)
670  #define MB_TYPE_L1         (MB_TYPE_P0L1 | MB_TYPE_P1L1)
671  #define MB_TYPE_L0L1       (MB_TYPE_L0   | MB_TYPE_L1)
672  #define MB_TYPE_QUANT      0x00010000
673  #define MB_TYPE_CBP        0x00020000
674  #endif
675  typedef struct AVPanScan{
676      int id;
677      int width;
678      int height;
679      int16_t position[3][2];
680  }AVPanScan;
681  typedef struct AVCPBProperties {
682      int max_bitrate;
683      int min_bitrate;
684      int avg_bitrate;
685      int buffer_size;
686      uint64_t vbv_delay;
687  } AVCPBProperties;
688  #if FF_API_QSCALE_TYPE
689  #define FF_QSCALE_TYPE_MPEG1 0
690  #define FF_QSCALE_TYPE_MPEG2 1
691  #define FF_QSCALE_TYPE_H264  2
692  #define FF_QSCALE_TYPE_VP56  3
693  #endif
694  #define AV_GET_BUFFER_FLAG_REF (1 << 0)
695  enum AVPacketSideDataType {
696      AV_PKT_DATA_PALETTE,
697      AV_PKT_DATA_NEW_EXTRADATA,
698      AV_PKT_DATA_PARAM_CHANGE,
699      AV_PKT_DATA_H263_MB_INFO,
700      AV_PKT_DATA_REPLAYGAIN,
701      AV_PKT_DATA_DISPLAYMATRIX,
702      AV_PKT_DATA_STEREO3D,
703      AV_PKT_DATA_AUDIO_SERVICE_TYPE,
704      AV_PKT_DATA_QUALITY_STATS,
705      AV_PKT_DATA_FALLBACK_TRACK,
706      AV_PKT_DATA_CPB_PROPERTIES,
707      AV_PKT_DATA_SKIP_SAMPLES=70,
708      AV_PKT_DATA_JP_DUALMONO,
709      AV_PKT_DATA_STRINGS_METADATA,
710      AV_PKT_DATA_SUBTITLE_POSITION,
711      AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL,
712      AV_PKT_DATA_WEBVTT_IDENTIFIER,
713      AV_PKT_DATA_WEBVTT_SETTINGS,
714      AV_PKT_DATA_METADATA_UPDATE,
715      AV_PKT_DATA_MPEGTS_STREAM_ID,
716      AV_PKT_DATA_MASTERING_DISPLAY_METADATA,
717      AV_PKT_DATA_SPHERICAL,
718      AV_PKT_DATA_CONTENT_LIGHT_LEVEL,
719      AV_PKT_DATA_A53_CC,
720      AV_PKT_DATA_NB
721  };
722  #define AV_PKT_DATA_QUALITY_FACTOR AV_PKT_DATA_QUALITY_STATS 
723  typedef struct AVPacketSideData {
724      uint8_t *data;
725      int      size;
726      enum AVPacketSideDataType type;
727  } AVPacketSideData;
728  typedef struct AVPacket {
729      AVBufferRef *buf;
730      int64_t pts;
731      int64_t dts;
732      uint8_t *data;
733      int   size;
734      int   stream_index;
735      int   flags;
736      AVPacketSideData *side_data;
737      int side_data_elems;
738      int64_t duration;
739      int64_t pos;                            
740  #if FF_API_CONVERGENCE_DURATION
741      attribute_deprecated
742      int64_t convergence_duration;
743  #endif
744  } AVPacket;
745  #define AV_PKT_FLAG_KEY     0x0001 
746  #define AV_PKT_FLAG_CORRUPT 0x0002 
747  #define AV_PKT_FLAG_DISCARD   0x0004
748  #define AV_PKT_FLAG_TRUSTED   0x0008
749  enum AVSideDataParamChangeFlags {
750      AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT  = 0x0001,
751      AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT = 0x0002,
752      AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE    = 0x0004,
753      AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS     = 0x0008,
754  };
755  struct AVCodecInternal;
756  enum AVFieldOrder {
757      AV_FIELD_UNKNOWN,
758      AV_FIELD_PROGRESSIVE,
759      AV_FIELD_TT,          
760      AV_FIELD_BB,          
761      AV_FIELD_TB,          
762      AV_FIELD_BT,          
763  };
764  typedef struct AVCodecContext {
765      const AVClass *av_class;
766      int log_level_offset;
767      enum AVMediaType codec_type; &bsol;* see AVMEDIA_TYPE_xxx */
768      const struct AVCodec  *codec;
769  #if FF_API_CODEC_NAME
770      attribute_deprecated
771      char             codec_name[32];
772  #endif
773      enum AVCodecID     codec_id; &bsol;* see AV_CODEC_ID_xxx */
774      unsigned int codec_tag;
775  #if FF_API_STREAM_CODEC_TAG
776      attribute_deprecated
777      unsigned int stream_codec_tag;
778  #endif
779      void *priv_data;
780      struct AVCodecInternal *internal;
781      void *opaque;
782      int64_t bit_rate;
783      int bit_rate_tolerance;
784      int global_quality;
785      int compression_level;
786  #define FF_COMPRESSION_DEFAULT -1
787      int flags;
788      int flags2;
789      uint8_t *extradata;
790      int extradata_size;
791      AVRational time_base;
792      int ticks_per_frame;
793      int delay;
794      int width, height;
795      int coded_width, coded_height;
796  #if FF_API_ASPECT_EXTENDED
797  #define FF_ASPECT_EXTENDED 15
798  #endif
799      int gop_size;
800      enum AVPixelFormat pix_fmt;
801  #if FF_API_MOTION_EST
802      attribute_deprecated int me_method;
803  #endif
804      void (*draw_horiz_band)(struct AVCodecContext *s,
805                              const AVFrame *src, int offset[AV_NUM_DATA_POINTERS],
806                              int y, int type, int height);
807      enum AVPixelFormat (*get_format)(struct AVCodecContext *s, const enum AVPixelFormat * fmt);
808      int max_b_frames;
809      float b_quant_factor;
810  #if FF_API_RC_STRATEGY
811      attribute_deprecated int rc_strategy;
812  #define FF_RC_STRATEGY_XVID 1
813  #endif
814  #if FF_API_PRIVATE_OPT
815      attribute_deprecated
816      int b_frame_strategy;
817  #endif
818      float b_quant_offset;
819      int has_b_frames;
820  #if FF_API_PRIVATE_OPT
821      attribute_deprecated
822      int mpeg_quant;
823  #endif
824      float i_quant_factor;
825      float i_quant_offset;
826      float lumi_masking;
827      float temporal_cplx_masking;
828      float spatial_cplx_masking;
829      float p_masking;
830      float dark_masking;
831      int slice_count;
832  #if FF_API_PRIVATE_OPT
833      attribute_deprecated
834       int prediction_method;
835  #define FF_PRED_LEFT   0
836  #define FF_PRED_PLANE  1
837  #define FF_PRED_MEDIAN 2
838  #endif
839      int *slice_offset;
840      AVRational sample_aspect_ratio;
841      int me_cmp;
842      int me_sub_cmp;
843      int mb_cmp;
844      int ildct_cmp;
845  #define FF_CMP_SAD          0
846  #define FF_CMP_SSE          1
847  #define FF_CMP_SATD         2
848  #define FF_CMP_DCT          3
849  #define FF_CMP_PSNR         4
850  #define FF_CMP_BIT          5
851  #define FF_CMP_RD           6
852  #define FF_CMP_ZERO         7
853  #define FF_CMP_VSAD         8
854  #define FF_CMP_VSSE         9
855  #define FF_CMP_NSSE         10
856  #define FF_CMP_W53          11
857  #define FF_CMP_W97          12
858  #define FF_CMP_DCTMAX       13
859  #define FF_CMP_DCT264       14
860  #define FF_CMP_MEDIAN_SAD   15
861  #define FF_CMP_CHROMA       256
862      int dia_size;
863      int last_predictor_count;
864  #if FF_API_PRIVATE_OPT
865      attribute_deprecated
866      int pre_me;
867  #endif
868      int me_pre_cmp;
869      int pre_dia_size;
870      int me_subpel_quality;
871  #if FF_API_AFD
872      attribute_deprecated int dtg_active_format;
873  #define FF_DTG_AFD_SAME         8
874  #define FF_DTG_AFD_4_3          9
875  #define FF_DTG_AFD_16_9         10
876  #define FF_DTG_AFD_14_9         11
877  #define FF_DTG_AFD_4_3_SP_14_9  13
878  #define FF_DTG_AFD_16_9_SP_14_9 14
879  #define FF_DTG_AFD_SP_4_3       15
880  #endif &bsol;* FF_API_AFD */
881      int me_range;
882  #if FF_API_QUANT_BIAS
883      attribute_deprecated int intra_quant_bias;
884  #define FF_DEFAULT_QUANT_BIAS 999999
885      attribute_deprecated int inter_quant_bias;
886  #endif
887      int slice_flags;
888  #define SLICE_FLAG_CODED_ORDER    0x0001 
889  #define SLICE_FLAG_ALLOW_FIELD    0x0002 
890  #define SLICE_FLAG_ALLOW_PLANE    0x0004 
891  #if FF_API_XVMC
892      attribute_deprecated int xvmc_acceleration;
893  #endif &bsol;* FF_API_XVMC */
894      int mb_decision;
895  #define FF_MB_DECISION_SIMPLE 0        
896  #define FF_MB_DECISION_BITS   1        
897  #define FF_MB_DECISION_RD     2        
898      uint16_t *intra_matrix;
899      uint16_t *inter_matrix;
900  #if FF_API_PRIVATE_OPT
901      attribute_deprecated
902      int scenechange_threshold;
903      attribute_deprecated
904      int noise_reduction;
905  #endif
906  #if FF_API_MPV_OPT
907      attribute_deprecated
908      int me_threshold;
909      attribute_deprecated
910      int mb_threshold;
911  #endif
912      int intra_dc_precision;
913      int skip_top;
914      int skip_bottom;
915  #if FF_API_MPV_OPT
916      attribute_deprecated
917      float border_masking;
918  #endif
919      int mb_lmin;
920      int mb_lmax;
921  #if FF_API_PRIVATE_OPT
922      attribute_deprecated
923      int me_penalty_compensation;
924  #endif
925      int bidir_refine;
926  #if FF_API_PRIVATE_OPT
927      attribute_deprecated
928      int brd_scale;
929  #endif
930      int keyint_min;
931      int refs;
932  #if FF_API_PRIVATE_OPT
933      attribute_deprecated
934      int chromaoffset;
935  #endif
936  #if FF_API_UNUSED_MEMBERS
937      attribute_deprecated int scenechange_factor;
938  #endif
939      int mv0_threshold;
940  #if FF_API_PRIVATE_OPT
941      attribute_deprecated
942      int b_sensitivity;
943  #endif
944      enum AVColorPrimaries color_primaries;
945      enum AVColorTransferCharacteristic color_trc;
946      enum AVColorSpace colorspace;
947      enum AVColorRange color_range;
948      enum AVChromaLocation chroma_sample_location;
949      int slices;
950      enum AVFieldOrder field_order;
951      int sample_rate; 
952      int channels;    
953      enum AVSampleFormat sample_fmt;  
954      int frame_size;
955      int frame_number;
956      int block_align;
957      int cutoff;
958      uint64_t channel_layout;
959      uint64_t request_channel_layout;
960      enum AVAudioServiceType audio_service_type;
961      enum AVSampleFormat request_sample_fmt;
962      int (*get_buffer2)(struct AVCodecContext *s, AVFrame *frame, int flags);
963      attribute_deprecated
964      int refcounted_frames;
965      float qcompress;  
966      float qblur;      
967      int qmin;
968      int qmax;
969      int max_qdiff;
970  #if FF_API_MPV_OPT
971      attribute_deprecated
972      float rc_qsquish;
973      attribute_deprecated
974      float rc_qmod_amp;
975      attribute_deprecated
976      int rc_qmod_freq;
977  #endif
978      int rc_buffer_size;
979      int rc_override_count;
980      RcOverride *rc_override;
981  #if FF_API_MPV_OPT
982      attribute_deprecated
983      const char *rc_eq;
984  #endif
985      int64_t rc_max_rate;
986      int64_t rc_min_rate;
987  #if FF_API_MPV_OPT
988      attribute_deprecated
989      float rc_buffer_aggressivity;
990      attribute_deprecated
991      float rc_initial_cplx;
992  #endif
993      float rc_max_available_vbv_use;
994      float rc_min_vbv_overflow_use;
995      int rc_initial_buffer_occupancy;
996  #if FF_API_CODER_TYPE
997  #define FF_CODER_TYPE_VLC       0
998  #define FF_CODER_TYPE_AC        1
999  #define FF_CODER_TYPE_RAW       2
1000  #define FF_CODER_TYPE_RLE       3
1001  #if FF_API_UNUSED_MEMBERS
1002  #define FF_CODER_TYPE_DEFLATE   4
1003  #endif &bsol;* FF_API_UNUSED_MEMBERS */
1004      attribute_deprecated
1005      int coder_type;
1006  #endif &bsol;* FF_API_CODER_TYPE */
1007  #if FF_API_PRIVATE_OPT
1008      attribute_deprecated
1009      int context_model;
1010  #endif
1011  #if FF_API_MPV_OPT
1012      attribute_deprecated
1013      int lmin;
1014      attribute_deprecated
1015      int lmax;
1016  #endif
1017  #if FF_API_PRIVATE_OPT
1018      attribute_deprecated
1019      int frame_skip_threshold;
1020      attribute_deprecated
1021      int frame_skip_factor;
1022      attribute_deprecated
1023      int frame_skip_exp;
1024      attribute_deprecated
1025      int frame_skip_cmp;
1026  #endif &bsol;* FF_API_PRIVATE_OPT */
1027      int trellis;
1028  #if FF_API_PRIVATE_OPT
1029      attribute_deprecated
1030      int min_prediction_order;
1031      attribute_deprecated
1032      int max_prediction_order;
1033      attribute_deprecated
1034      int64_t timecode_frame_start;
1035  #endif
1036  #if FF_API_RTP_CALLBACK
1037      attribute_deprecated
1038      void (*rtp_callback)(struct AVCodecContext *avctx, void *data, int size, int mb_nb);
1039  #endif
1040  #if FF_API_PRIVATE_OPT
1041      attribute_deprecated
1042      int rtp_payload_size;   &bsol;* The size of the RTP payload: the coder will  */
1043  #endif
1044  #if FF_API_STAT_BITS
1045      attribute_deprecated
1046      int mv_bits;
1047      attribute_deprecated
1048      int header_bits;
1049      attribute_deprecated
1050      int i_tex_bits;
1051      attribute_deprecated
1052      int p_tex_bits;
1053      attribute_deprecated
1054      int i_count;
1055      attribute_deprecated
1056      int p_count;
1057      attribute_deprecated
1058      int skip_count;
1059      attribute_deprecated
1060      int misc_bits;
1061      attribute_deprecated
1062      int frame_bits;
1063  #endif
1064      char *stats_out;
1065      char *stats_in;
1066      int workaround_bugs;
1067  #define FF_BUG_AUTODETECT       1  
1068  #if FF_API_OLD_MSMPEG4
1069  #define FF_BUG_OLD_MSMPEG4      2
1070  #endif
1071  #define FF_BUG_XVID_ILACE       4
1072  #define FF_BUG_UMP4             8
1073  #define FF_BUG_NO_PADDING       16
1074  #define FF_BUG_AMV              32
1075  #if FF_API_AC_VLC
1076  #define FF_BUG_AC_VLC           0  
1077  #endif
1078  #define FF_BUG_QPEL_CHROMA      64
1079  #define FF_BUG_STD_QPEL         128
1080  #define FF_BUG_QPEL_CHROMA2     256
1081  #define FF_BUG_DIRECT_BLOCKSIZE 512
1082  #define FF_BUG_EDGE             1024
1083  #define FF_BUG_HPEL_CHROMA      2048
1084  #define FF_BUG_DC_CLIP          4096
1085  #define FF_BUG_MS               8192 
1086  #define FF_BUG_TRUNCATED       16384
1087  #define FF_BUG_IEDGE           32768
1088      int strict_std_compliance;
1089  #define FF_COMPLIANCE_VERY_STRICT   2 
1090  #define FF_COMPLIANCE_STRICT        1 
1091  #define FF_COMPLIANCE_NORMAL        0
1092  #define FF_COMPLIANCE_UNOFFICIAL   -1 
1093  #define FF_COMPLIANCE_EXPERIMENTAL -2 
1094      int error_concealment;
1095  #define FF_EC_GUESS_MVS   1
1096  #define FF_EC_DEBLOCK     2
1097  #define FF_EC_FAVOR_INTER 256
1098      int debug;
1099  #define FF_DEBUG_PICT_INFO   1
1100  #define FF_DEBUG_RC          2
1101  #define FF_DEBUG_BITSTREAM   4
1102  #define FF_DEBUG_MB_TYPE     8
1103  #define FF_DEBUG_QP          16
1104  #if FF_API_DEBUG_MV
1105  #define FF_DEBUG_MV          32
1106  #endif
1107  #define FF_DEBUG_DCT_COEFF   0x00000040
1108  #define FF_DEBUG_SKIP        0x00000080
1109  #define FF_DEBUG_STARTCODE   0x00000100
1110  #if FF_API_UNUSED_MEMBERS
1111  #define FF_DEBUG_PTS         0x00000200
1112  #endif &bsol;* FF_API_UNUSED_MEMBERS */
1113  #define FF_DEBUG_ER          0x00000400
1114  #define FF_DEBUG_MMCO        0x00000800
1115  #define FF_DEBUG_BUGS        0x00001000
1116  #if FF_API_DEBUG_MV
1117  #define FF_DEBUG_VIS_QP      0x00002000
1118  #define FF_DEBUG_VIS_MB_TYPE 0x00004000
1119  #endif
1120  #define FF_DEBUG_BUFFERS     0x00008000
1121  #define FF_DEBUG_THREADS     0x00010000
1122  #define FF_DEBUG_GREEN_MD    0x00800000
1123  #define FF_DEBUG_NOMC        0x01000000
1124  #if FF_API_DEBUG_MV
1125      int debug_mv;
1126  #define FF_DEBUG_VIS_MV_P_FOR  0x00000001 
1127  #define FF_DEBUG_VIS_MV_B_FOR  0x00000002 
1128  #define FF_DEBUG_VIS_MV_B_BACK 0x00000004 
1129  #endif
1130      int err_recognition;
1131  #define AV_EF_CRCCHECK  (1<<0)
1132  #define AV_EF_BITSTREAM (1<<1)          
1133  #define AV_EF_BUFFER    (1<<2)          
1134  #define AV_EF_EXPLODE   (1<<3)          
1135  #define AV_EF_IGNORE_ERR (1<<15)        
1136  #define AV_EF_CAREFUL    (1<<16)        
1137  #define AV_EF_COMPLIANT  (1<<17)        
1138  #define AV_EF_AGGRESSIVE (1<<18)        
1139      int64_t reordered_opaque;
1140      struct AVHWAccel *hwaccel;
1141      void *hwaccel_context;
1142      uint64_t error[AV_NUM_DATA_POINTERS];
1143      int dct_algo;
1144  #define FF_DCT_AUTO    0
1145  #define FF_DCT_FASTINT 1
1146  #define FF_DCT_INT     2
1147  #define FF_DCT_MMX     3
1148  #define FF_DCT_ALTIVEC 5
1149  #define FF_DCT_FAAN    6
1150      int idct_algo;
1151  #define FF_IDCT_AUTO          0
1152  #define FF_IDCT_INT           1
1153  #define FF_IDCT_SIMPLE        2
1154  #define FF_IDCT_SIMPLEMMX     3
1155  #define FF_IDCT_ARM           7
1156  #define FF_IDCT_ALTIVEC       8
1157  #if FF_API_ARCH_SH4
1158  #define FF_IDCT_SH4           9
1159  #endif
1160  #define FF_IDCT_SIMPLEARM     10
1161  #if FF_API_UNUSED_MEMBERS
1162  #define FF_IDCT_IPP           13
1163  #endif &bsol;* FF_API_UNUSED_MEMBERS */
1164  #define FF_IDCT_XVID          14
1165  #if FF_API_IDCT_XVIDMMX
1166  #define FF_IDCT_XVIDMMX       14
1167  #endif &bsol;* FF_API_IDCT_XVIDMMX */
1168  #define FF_IDCT_SIMPLEARMV5TE 16
1169  #define FF_IDCT_SIMPLEARMV6   17
1170  #if FF_API_ARCH_SPARC
1171  #define FF_IDCT_SIMPLEVIS     18
1172  #endif
1173  #define FF_IDCT_FAAN          20
1174  #define FF_IDCT_SIMPLENEON    22
1175  #if FF_API_ARCH_ALPHA
1176  #define FF_IDCT_SIMPLEALPHA   23
1177  #endif
1178  #define FF_IDCT_NONE          24 &bsol;* Used by XvMC to extract IDCT coefficients with FF_IDCT_PERM_NONE */
1179  #define FF_IDCT_SIMPLEAUTO    128
1180       int bits_per_coded_sample;
1181      int bits_per_raw_sample;
1182  #if FF_API_LOWRES
1183       int lowres;
1184  #endif
1185  #if FF_API_CODED_FRAME
1186      attribute_deprecated AVFrame *coded_frame;
1187  #endif
1188      int thread_count;
1189      int thread_type;
1190  #define FF_THREAD_FRAME   1 
1191  #define FF_THREAD_SLICE   2 
1192      int active_thread_type;
1193      int thread_safe_callbacks;
1194      int (*execute)(struct AVCodecContext *c, int (*func)(struct AVCodecContext *c2, void *arg), void *arg2, int *ret, int count, int size);
1195      int (*execute2)(struct AVCodecContext *c, int (*func)(struct AVCodecContext *c2, void *arg, int jobnr, int threadnr), void *arg2, int *ret, int count);
1196       int nsse_weight;
1197       int profile;
1198  #define FF_PROFILE_UNKNOWN -99
1199  #define FF_PROFILE_RESERVED -100
1200  #define FF_PROFILE_AAC_MAIN 0
1201  #define FF_PROFILE_AAC_LOW  1
1202  #define FF_PROFILE_AAC_SSR  2
1203  #define FF_PROFILE_AAC_LTP  3
1204  #define FF_PROFILE_AAC_HE   4
1205  #define FF_PROFILE_AAC_HE_V2 28
1206  #define FF_PROFILE_AAC_LD   22
1207  #define FF_PROFILE_AAC_ELD  38
1208  #define FF_PROFILE_MPEG2_AAC_LOW 128
1209  #define FF_PROFILE_MPEG2_AAC_HE  131
1210  #define FF_PROFILE_DNXHD         0
1211  #define FF_PROFILE_DNXHR_LB      1
1212  #define FF_PROFILE_DNXHR_SQ      2
1213  #define FF_PROFILE_DNXHR_HQ      3
1214  #define FF_PROFILE_DNXHR_HQX     4
1215  #define FF_PROFILE_DNXHR_444     5
1216  #define FF_PROFILE_DTS         20
1217  #define FF_PROFILE_DTS_ES      30
1218  #define FF_PROFILE_DTS_96_24   40
1219  #define FF_PROFILE_DTS_HD_HRA  50
1220  #define FF_PROFILE_DTS_HD_MA   60
1221  #define FF_PROFILE_DTS_EXPRESS 70
1222  #define FF_PROFILE_MPEG2_422    0
1223  #define FF_PROFILE_MPEG2_HIGH   1
1224  #define FF_PROFILE_MPEG2_SS     2
1225  #define FF_PROFILE_MPEG2_SNR_SCALABLE  3
1226  #define FF_PROFILE_MPEG2_MAIN   4
1227  #define FF_PROFILE_MPEG2_SIMPLE 5
1228  #define FF_PROFILE_H264_CONSTRAINED  (1<<9)  
1229  #define FF_PROFILE_H264_INTRA        (1<<11) 
1230  #define FF_PROFILE_H264_BASELINE             66
1231  #define FF_PROFILE_H264_CONSTRAINED_BASELINE (66|FF_PROFILE_H264_CONSTRAINED)
1232  #define FF_PROFILE_H264_MAIN                 77
1233  #define FF_PROFILE_H264_EXTENDED             88
1234  #define FF_PROFILE_H264_HIGH                 100
1235  #define FF_PROFILE_H264_HIGH_10              110
1236  #define FF_PROFILE_H264_HIGH_10_INTRA        (110|FF_PROFILE_H264_INTRA)
1237  #define FF_PROFILE_H264_MULTIVIEW_HIGH       118
1238  #define FF_PROFILE_H264_HIGH_422             122
1239  #define FF_PROFILE_H264_HIGH_422_INTRA       (122|FF_PROFILE_H264_INTRA)
1240  #define FF_PROFILE_H264_STEREO_HIGH          128
1241  #define FF_PROFILE_H264_HIGH_444             144
1242  #define FF_PROFILE_H264_HIGH_444_PREDICTIVE  244
1243  #define FF_PROFILE_H264_HIGH_444_INTRA       (244|FF_PROFILE_H264_INTRA)
1244  #define FF_PROFILE_H264_CAVLC_444            44
1245  #define FF_PROFILE_VC1_SIMPLE   0
1246  #define FF_PROFILE_VC1_MAIN     1
1247  #define FF_PROFILE_VC1_COMPLEX  2
1248  #define FF_PROFILE_VC1_ADVANCED 3
1249  #define FF_PROFILE_MPEG4_SIMPLE                     0
1250  #define FF_PROFILE_MPEG4_SIMPLE_SCALABLE            1
1251  #define FF_PROFILE_MPEG4_CORE                       2
1252  #define FF_PROFILE_MPEG4_MAIN                       3
1253  #define FF_PROFILE_MPEG4_N_BIT                      4
1254  #define FF_PROFILE_MPEG4_SCALABLE_TEXTURE           5
1255  #define FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION      6
1256  #define FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE     7
1257  #define FF_PROFILE_MPEG4_HYBRID                     8
1258  #define FF_PROFILE_MPEG4_ADVANCED_REAL_TIME         9
1259  #define FF_PROFILE_MPEG4_CORE_SCALABLE             10
1260  #define FF_PROFILE_MPEG4_ADVANCED_CODING           11
1261  #define FF_PROFILE_MPEG4_ADVANCED_CORE             12
1262  #define FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE 13
1263  #define FF_PROFILE_MPEG4_SIMPLE_STUDIO             14
1264  #define FF_PROFILE_MPEG4_ADVANCED_SIMPLE           15
1265  #define FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0   1
1266  #define FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1   2
1267  #define FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION  32768
1268  #define FF_PROFILE_JPEG2000_DCINEMA_2K              3
1269  #define FF_PROFILE_JPEG2000_DCINEMA_4K              4
1270  #define FF_PROFILE_VP9_0                            0
1271  #define FF_PROFILE_VP9_1                            1
1272  #define FF_PROFILE_VP9_2                            2
1273  #define FF_PROFILE_VP9_3                            3
1274  #define FF_PROFILE_HEVC_MAIN                        1
1275  #define FF_PROFILE_HEVC_MAIN_10                     2
1276  #define FF_PROFILE_HEVC_MAIN_STILL_PICTURE          3
1277  #define FF_PROFILE_HEVC_REXT                        4
1278       int level;
1279  #define FF_LEVEL_UNKNOWN -99
1280      enum AVDiscard skip_loop_filter;
1281      enum AVDiscard skip_idct;
1282      enum AVDiscard skip_frame;
1283      uint8_t *subtitle_header;
1284      int subtitle_header_size;
1285  #if FF_API_ERROR_RATE
1286      attribute_deprecated
1287      int error_rate;
1288  #endif
1289  #if FF_API_VBV_DELAY
1290      attribute_deprecated
1291      uint64_t vbv_delay;
1292  #endif
1293  #if FF_API_SIDEDATA_ONLY_PKT
1294      attribute_deprecated
1295      int side_data_only_packets;
1296  #endif
1297      int initial_padding;
1298      AVRational framerate;
1299      enum AVPixelFormat sw_pix_fmt;
1300      AVRational pkt_timebase;
1301      const AVCodecDescriptor *codec_descriptor;
1302  #if !FF_API_LOWRES
1303       int lowres;
1304  #endif
1305      int64_t pts_correction_num_faulty_pts; 
1306      int64_t pts_correction_num_faulty_dts; 
1307      int64_t pts_correction_last_pts;       
1308      int64_t pts_correction_last_dts;       
1309      char *sub_charenc;
1310      int sub_charenc_mode;
1311  #define FF_SUB_CHARENC_MODE_DO_NOTHING  -1  
1312  #define FF_SUB_CHARENC_MODE_AUTOMATIC    0  
1313  #define FF_SUB_CHARENC_MODE_PRE_DECODER  1  
1314      int skip_alpha;
1315      int seek_preroll;
1316  #if !FF_API_DEBUG_MV
1317      int debug_mv;
1318  #define FF_DEBUG_VIS_MV_P_FOR  0x00000001 
1319  #define FF_DEBUG_VIS_MV_B_FOR  0x00000002 
1320  #define FF_DEBUG_VIS_MV_B_BACK 0x00000004 
1321  #endif
1322      uint16_t *chroma_intra_matrix;
1323      uint8_t *dump_separator;
1324      char *codec_whitelist;
1325      unsigned properties;
1326  #define FF_CODEC_PROPERTY_LOSSLESS        0x00000001
1327  #define FF_CODEC_PROPERTY_CLOSED_CAPTIONS 0x00000002
1328      AVPacketSideData *coded_side_data;
1329      int            nb_coded_side_data;
1330      AVBufferRef *hw_frames_ctx;
1331      int sub_text_format;
1332  #define FF_SUB_TEXT_FMT_ASS              0
1333  #if FF_API_ASS_TIMING
1334  #define FF_SUB_TEXT_FMT_ASS_WITH_TIMINGS 1
1335  #endif
1336      int trailing_padding;
1337      int64_t max_pixels;
1338      AVBufferRef *hw_device_ctx;
1339      int hwaccel_flags;
1340      int apply_cropping;
1341  } AVCodecContext;
1342  AVRational av_codec_get_pkt_timebase         (const AVCodecContext *avctx);
1343  void       av_codec_set_pkt_timebase         (AVCodecContext *avctx, AVRational val);
1344  const AVCodecDescriptor *av_codec_get_codec_descriptor(const AVCodecContext *avctx);
1345  void                     av_codec_set_codec_descriptor(AVCodecContext *avctx, const AVCodecDescriptor *desc);
1346  unsigned av_codec_get_codec_properties(const AVCodecContext *avctx);
1347  int  av_codec_get_lowres(const AVCodecContext *avctx);
1348  void av_codec_set_lowres(AVCodecContext *avctx, int val);
1349  int  av_codec_get_seek_preroll(const AVCodecContext *avctx);
1350  void av_codec_set_seek_preroll(AVCodecContext *avctx, int val);
1351  uint16_t *av_codec_get_chroma_intra_matrix(const AVCodecContext *avctx);
1352  void av_codec_set_chroma_intra_matrix(AVCodecContext *avctx, uint16_t *val);
1353  typedef struct AVProfile {
1354      int profile;
1355      const char *name; 
1356  } AVProfile;
1357  typedef struct AVCodecDefault AVCodecDefault;
1358  struct AVSubtitle;
1359  typedef struct AVCodec {
1360      const char *name;
1361      const char *long_name;
1362      enum AVMediaType type;
1363      enum AVCodecID id;
1364      int capabilities;
1365      const AVRational *supported_framerates; 
1366      const enum AVPixelFormat *pix_fmts;     
1367      const int *supported_samplerates;       
1368      const enum AVSampleFormat *sample_fmts; 
1369      const uint64_t *channel_layouts;         
1370      uint8_t max_lowres;                     
1371      const AVClass *priv_class;              
1372      const AVProfile *profiles;              
1373      int priv_data_size;
1374      struct AVCodec *next;
1375      int (*init_thread_copy)(AVCodecContext *);
1376      int (*update_thread_context)(AVCodecContext *dst, const AVCodecContext *src);
1377      const AVCodecDefault *defaults;
1378      void (*init_static_data)(struct AVCodec *codec);
1379      int (*init)(AVCodecContext *);
1380      int (*encode_sub)(AVCodecContext *, uint8_t *buf, int buf_size,
1381                        const struct AVSubtitle *sub);
1382      int (*encode2)(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame,
1383                     int *got_packet_ptr);
1384      int (*decode)(AVCodecContext *, void *outdata, int *outdata_size, AVPacket *avpkt);
1385      int (*close)(AVCodecContext *);
1386      int (*send_frame)(AVCodecContext *avctx, const AVFrame *frame);
1387      int (*receive_packet)(AVCodecContext *avctx, AVPacket *avpkt);
1388      int (*receive_frame)(AVCodecContext *avctx, AVFrame *frame);
1389      void (*flush)(AVCodecContext *);
1390      int caps_internal;
1391      const char *bsfs;
1392  } AVCodec;
1393  int av_codec_get_max_lowres(const AVCodec *codec);
1394  struct MpegEncContext;
1395  typedef struct AVHWAccel {
1396      const char *name;
1397      enum AVMediaType type;
1398      enum AVCodecID id;
1399      enum AVPixelFormat pix_fmt;
1400      int capabilities;
1401      struct AVHWAccel *next;
1402      int (*alloc_frame)(AVCodecContext *avctx, AVFrame *frame);
1403      int (*start_frame)(AVCodecContext *avctx, const uint8_t *buf, uint32_t buf_size);
1404      int (*decode_slice)(AVCodecContext *avctx, const uint8_t *buf, uint32_t buf_size);
1405      int (*end_frame)(AVCodecContext *avctx);
1406      int frame_priv_data_size;
1407      void (*decode_mb)(struct MpegEncContext *s);
1408      int (*init)(AVCodecContext *avctx);
1409      int (*uninit)(AVCodecContext *avctx);
1410      int priv_data_size;
1411      int caps_internal;
1412  } AVHWAccel;
1413  #define AV_HWACCEL_CODEC_CAP_EXPERIMENTAL 0x0200
1414  #define AV_HWACCEL_FLAG_IGNORE_LEVEL (1 << 0)
1415  #define AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH (1 << 1)
1416  #define AV_HWACCEL_FLAG_ALLOW_PROFILE_MISMATCH (1 << 2)
1417  #if FF_API_AVPICTURE
1418  typedef struct AVPicture {
1419      attribute_deprecated
1420      uint8_t *data[AV_NUM_DATA_POINTERS];    
1421      attribute_deprecated
1422      int linesize[AV_NUM_DATA_POINTERS];     
1423  } AVPicture;
1424  #endif
1425  enum AVSubtitleType {
1426      SUBTITLE_NONE,
1427      SUBTITLE_BITMAP,                
1428      SUBTITLE_TEXT,
1429      SUBTITLE_ASS,
1430  };
1431  #define AV_SUBTITLE_FLAG_FORCED 0x00000001
1432  typedef struct AVSubtitleRect {
1433      int x;         
1434      int y;         
1435      int w;         
1436      int h;         
1437      int nb_colors; 
1438  #if FF_API_AVPICTURE
1439      attribute_deprecated
1440      AVPicture pict;
1441  #endif
1442      uint8_t *data[4];
1443      int linesize[4];
1444      enum AVSubtitleType type;
1445      char *text;                     
1446      char *ass;
1447      int flags;
1448  } AVSubtitleRect;
1449  typedef struct AVSubtitle {
1450      uint16_t format; &bsol;* 0 = graphics */
1451      uint32_t start_display_time; &bsol;* relative to packet pts, in ms */
1452      uint32_t end_display_time; &bsol;* relative to packet pts, in ms */
1453      unsigned num_rects;
1454      AVSubtitleRect **rects;
1455      int64_t pts;    
1456  } AVSubtitle;
1457  typedef struct AVCodecParameters {
1458      enum AVMediaType codec_type;
1459      enum AVCodecID   codec_id;
1460      uint32_t         codec_tag;
1461      uint8_t *extradata;
1462      int      extradata_size;
1463      int format;
1464      int64_t bit_rate;
1465      int bits_per_coded_sample;
1466      int bits_per_raw_sample;
1467      int profile;
1468      int level;
1469      int width;
1470      int height;
1471      AVRational sample_aspect_ratio;
1472      enum AVFieldOrder                  field_order;
1473      enum AVColorRange                  color_range;
1474      enum AVColorPrimaries              color_primaries;
1475      enum AVColorTransferCharacteristic color_trc;
1476      enum AVColorSpace                  color_space;
1477      enum AVChromaLocation              chroma_location;
1478      int video_delay;
1479      uint64_t channel_layout;
1480      int      channels;
1481      int      sample_rate;
1482      int      block_align;
1483      int      frame_size;
1484      int initial_padding;
1485      int trailing_padding;
1486      int seek_preroll;
1487  } AVCodecParameters;
1488  AVCodec *av_codec_next(const AVCodec *c);
1489  unsigned avcodec_version(void);
1490  const char *avcodec_configuration(void);
1491  const char *avcodec_license(void);
1492  void avcodec_register(AVCodec *codec);
1493  void avcodec_register_all(void);
1494  AVCodecContext *avcodec_alloc_context3(const AVCodec *codec);
1495  void avcodec_free_context(AVCodecContext **avctx);
1496  #if FF_API_GET_CONTEXT_DEFAULTS
1497  int avcodec_get_context_defaults3(AVCodecContext *s, const AVCodec *codec);
1498  #endif
1499  const AVClass *avcodec_get_class(void);
1500  #if FF_API_COPY_CONTEXT
1501  const AVClass *avcodec_get_frame_class(void);
1502  const AVClass *avcodec_get_subtitle_rect_class(void);
1503  attribute_deprecated
1504  int avcodec_copy_context(AVCodecContext *dest, const AVCodecContext *src);
1505  #endif
1506  AVCodecParameters *avcodec_parameters_alloc(void);
1507  void avcodec_parameters_free(AVCodecParameters **par);
1508  int avcodec_parameters_copy(AVCodecParameters *dst, const AVCodecParameters *src);
1509  int avcodec_parameters_from_context(AVCodecParameters *par,
1510                                      const AVCodecContext *codec);
1511  int avcodec_parameters_to_context(AVCodecContext *codec,
1512                                    const AVCodecParameters *par);
1513  int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options);
1514  int avcodec_close(AVCodecContext *avctx);
1515  void avsubtitle_free(AVSubtitle *sub);
1516  AVPacket *av_packet_alloc(void);
1517  AVPacket *av_packet_clone(const AVPacket *src);
1518  void av_packet_free(AVPacket **pkt);
1519  void av_init_packet(AVPacket *pkt);
1520  int av_new_packet(AVPacket *pkt, int size);
1521  void av_shrink_packet(AVPacket *pkt, int size);
1522  int av_grow_packet(AVPacket *pkt, int grow_by);
1523  int av_packet_from_data(AVPacket *pkt, uint8_t *data, int size);
1524  #if FF_API_AVPACKET_OLD_API
1525  attribute_deprecated
1526  int av_dup_packet(AVPacket *pkt);
1527  attribute_deprecated
1528  int av_copy_packet(AVPacket *dst, const AVPacket *src);
1529  attribute_deprecated
1530  int av_copy_packet_side_data(AVPacket *dst, const AVPacket *src);
1531  attribute_deprecated
1532  void av_free_packet(AVPacket *pkt);
1533  #endif
1534  uint8_t* av_packet_new_side_data(AVPacket *pkt, enum AVPacketSideDataType type,
1535                                   int size);
1536  int av_packet_add_side_data(AVPacket *pkt, enum AVPacketSideDataType type,
1537                              uint8_t *data, size_t size);
1538  int av_packet_shrink_side_data(AVPacket *pkt, enum AVPacketSideDataType type,
1539                                 int size);
1540  uint8_t* av_packet_get_side_data(const AVPacket *pkt, enum AVPacketSideDataType type,
1541                                   int *size);
1542  #if FF_API_MERGE_SD_API
1543  attribute_deprecated
1544  int av_packet_merge_side_data(AVPacket *pkt);
1545  attribute_deprecated
1546  int av_packet_split_side_data(AVPacket *pkt);
1547  #endif
1548  const char *av_packet_side_data_name(enum AVPacketSideDataType type);
1549  uint8_t *av_packet_pack_dictionary(AVDictionary *dict, int *size);
1550  int av_packet_unpack_dictionary(const uint8_t *data, int size, AVDictionary **dict);
1551  void av_packet_free_side_data(AVPacket *pkt);
1552  int av_packet_ref(AVPacket *dst, const AVPacket *src);
1553  void av_packet_unref(AVPacket *pkt);
1554  void av_packet_move_ref(AVPacket *dst, AVPacket *src);
1555  int av_packet_copy_props(AVPacket *dst, const AVPacket *src);
1556  void av_packet_rescale_ts(AVPacket *pkt, AVRational tb_src, AVRational tb_dst);
1557  AVCodec *avcodec_find_decoder(enum AVCodecID id);
1558  AVCodec *avcodec_find_decoder_by_name(const char *name);
1559  int avcodec_default_get_buffer2(AVCodecContext *s, AVFrame *frame, int flags);
1560  #if FF_API_EMU_EDGE
1561  attribute_deprecated
1562  unsigned avcodec_get_edge_width(void);
1563  #endif
1564  void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height);
1565  void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,
1566                                 int linesize_align[AV_NUM_DATA_POINTERS]);
1567  int avcodec_enum_to_chroma_pos(int *xpos, int *ypos, enum AVChromaLocation pos);
1568  enum AVChromaLocation avcodec_chroma_pos_to_enum(int xpos, int ypos);
1569  attribute_deprecated
1570  int avcodec_decode_audio4(AVCodecContext *avctx, AVFrame *frame,
1571                            int *got_frame_ptr, const AVPacket *avpkt);
1572  attribute_deprecated
1573  int avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,
1574                           int *got_picture_ptr,
1575                           const AVPacket *avpkt);
1576  int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub,
1577                              int *got_sub_ptr,
1578                              AVPacket *avpkt);
1579  int avcodec_send_packet(AVCodecContext *avctx, const AVPacket *avpkt);
1580  int avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame);
1581  int avcodec_send_frame(AVCodecContext *avctx, const AVFrame *frame);
1582  int avcodec_receive_packet(AVCodecContext *avctx, AVPacket *avpkt);
1583  enum AVPictureStructure {
1584      AV_PICTURE_STRUCTURE_UNKNOWN,      
1585      AV_PICTURE_STRUCTURE_TOP_FIELD,    
1586      AV_PICTURE_STRUCTURE_BOTTOM_FIELD, 
1587      AV_PICTURE_STRUCTURE_FRAME,        
1588  };
1589  typedef struct AVCodecParserContext {
1590      void *priv_data;
1591      struct AVCodecParser *parser;
1592      int64_t frame_offset; &bsol;* offset of the current frame */
1593      int64_t cur_offset; &bsol;* current offset
1594                             (incremented by each av_parser_parse()) */
1595      int64_t next_frame_offset; &bsol;* offset of the next frame */
1596      int pict_type; &bsol;* XXX: Put it back in AVCodecContext. */
1597      int repeat_pict; &bsol;* XXX: Put it back in AVCodecContext. */
1598      int64_t pts;     &bsol;* pts of the current frame */
1599      int64_t dts;     &bsol;* dts of the current frame */
1600      int64_t last_pts;
1601      int64_t last_dts;
1602      int fetch_timestamp;
1603  #define AV_PARSER_PTS_NB 4
1604      int cur_frame_start_index;
1605      int64_t cur_frame_offset[AV_PARSER_PTS_NB];
1606      int64_t cur_frame_pts[AV_PARSER_PTS_NB];
1607      int64_t cur_frame_dts[AV_PARSER_PTS_NB];
1608      int flags;
1609  #define PARSER_FLAG_COMPLETE_FRAMES           0x0001
1610  #define PARSER_FLAG_ONCE                      0x0002
1611  #define PARSER_FLAG_FETCHED_OFFSET            0x0004
1612  #define PARSER_FLAG_USE_CODEC_TS              0x1000
1613      int64_t offset;      
1614      int64_t cur_frame_end[AV_PARSER_PTS_NB];
1615      int key_frame;
1616  #if FF_API_CONVERGENCE_DURATION
1617      attribute_deprecated
1618      int64_t convergence_duration;
1619  #endif
1620      int dts_sync_point;
1621      int dts_ref_dts_delta;
1622      int pts_dts_delta;
1623      int64_t cur_frame_pos[AV_PARSER_PTS_NB];
1624      int64_t pos;
1625      int64_t last_pos;
1626      int duration;
1627      enum AVFieldOrder field_order;
1628      enum AVPictureStructure picture_structure;
1629      int output_picture_number;
1630      int width;
1631      int height;
1632      int coded_width;
1633      int coded_height;
1634      int format;
1635  } AVCodecParserContext;
1636  typedef struct AVCodecParser {
1637      int codec_ids[5]; &bsol;* several codec IDs are permitted */
1638      int priv_data_size;
1639      int (*parser_init)(AVCodecParserContext *s);
1640      int (*parser_parse)(AVCodecParserContext *s,
1641                          AVCodecContext *avctx,
1642                          const uint8_t **poutbuf, int *poutbuf_size,
1643                          const uint8_t *buf, int buf_size);
1644      void (*parser_close)(AVCodecParserContext *s);
1645      int (*split)(AVCodecContext *avctx, const uint8_t *buf, int buf_size);
1646      struct AVCodecParser *next;
1647  } AVCodecParser;
1648  AVCodecParser *av_parser_next(const AVCodecParser *c);
1649  void av_register_codec_parser(AVCodecParser *parser);
1650  AVCodecParserContext *av_parser_init(int codec_id);
1651  int av_parser_parse2(AVCodecParserContext *s,
1652                       AVCodecContext *avctx,
1653                       uint8_t **poutbuf, int *poutbuf_size,
1654                       const uint8_t *buf, int buf_size,
1655                       int64_t pts, int64_t dts,
1656                       int64_t pos);
1657  int av_parser_change(AVCodecParserContext *s,
1658                       AVCodecContext *avctx,
1659                       uint8_t **poutbuf, int *poutbuf_size,
1660                       const uint8_t *buf, int buf_size, int keyframe);
1661  void av_parser_close(AVCodecParserContext *s);
1662  AVCodec *avcodec_find_encoder(enum AVCodecID id);
1663  AVCodec *avcodec_find_encoder_by_name(const char *name);
1664  attribute_deprecated
1665  int avcodec_encode_audio2(AVCodecContext *avctx, AVPacket *avpkt,
1666                            const AVFrame *frame, int *got_packet_ptr);
1667  attribute_deprecated
1668  int avcodec_encode_video2(AVCodecContext *avctx, AVPacket *avpkt,
1669                            const AVFrame *frame, int *got_packet_ptr);
1670  int avcodec_encode_subtitle(AVCodecContext *avctx, uint8_t *buf, int buf_size,
1671                              const AVSubtitle *sub);
1672  #if FF_API_AVCODEC_RESAMPLE
1673  struct ReSampleContext;
1674  struct AVResampleContext;
1675  typedef struct ReSampleContext ReSampleContext;
1676  attribute_deprecated
1677  ReSampleContext *av_audio_resample_init(int output_channels, int input_channels,
1678                                          int output_rate, int input_rate,
1679                                          enum AVSampleFormat sample_fmt_out,
1680                                          enum AVSampleFormat sample_fmt_in,
1681                                          int filter_length, int log2_phase_count,
1682                                          int linear, double cutoff);
1683  attribute_deprecated
1684  int audio_resample(ReSampleContext *s, short *output, short *input, int nb_samples);
1685  attribute_deprecated
1686  void audio_resample_close(ReSampleContext *s);
1687  attribute_deprecated
1688  struct AVResampleContext *av_resample_init(int out_rate, int in_rate, int filter_length, int log2_phase_count, int linear, double cutoff);
1689  attribute_deprecated
1690  int av_resample(struct AVResampleContext *c, short *dst, short *src, int *consumed, int src_size, int dst_size, int update_ctx);
1691  attribute_deprecated
1692  void av_resample_compensate(struct AVResampleContext *c, int sample_delta, int compensation_distance);
1693  attribute_deprecated
1694  void av_resample_close(struct AVResampleContext *c);
1695  #endif
1696  #if FF_API_AVPICTURE
1697  attribute_deprecated
1698  int avpicture_alloc(AVPicture *picture, enum AVPixelFormat pix_fmt, int width, int height);
1699  attribute_deprecated
1700  void avpicture_free(AVPicture *picture);
1701  attribute_deprecated
1702  int avpicture_fill(AVPicture *picture, const uint8_t *ptr,
1703                     enum AVPixelFormat pix_fmt, int width, int height);
1704  attribute_deprecated
1705  int avpicture_layout(const AVPicture *src, enum AVPixelFormat pix_fmt,
1706                       int width, int height,
1707                       unsigned char *dest, int dest_size);
1708  attribute_deprecated
1709  int avpicture_get_size(enum AVPixelFormat pix_fmt, int width, int height);
1710  attribute_deprecated
1711  void av_picture_copy(AVPicture *dst, const AVPicture *src,
1712                       enum AVPixelFormat pix_fmt, int width, int height);
1713  attribute_deprecated
1714  int av_picture_crop(AVPicture *dst, const AVPicture *src,
1715                      enum AVPixelFormat pix_fmt, int top_band, int left_band);
1716  attribute_deprecated
1717  int av_picture_pad(AVPicture *dst, const AVPicture *src, int height, int width, enum AVPixelFormat pix_fmt,
1718              int padtop, int padbottom, int padleft, int padright, int *color);
1719  #endif
1720  #if FF_API_GETCHROMA
1721  attribute_deprecated
1722  void avcodec_get_chroma_sub_sample(enum AVPixelFormat pix_fmt, int *h_shift, int *v_shift);
1723  #endif
1724  unsigned int avcodec_pix_fmt_to_codec_tag(enum AVPixelFormat pix_fmt);
1725  int avcodec_get_pix_fmt_loss(enum AVPixelFormat dst_pix_fmt, enum AVPixelFormat src_pix_fmt,
1726                               int has_alpha);
1727  enum AVPixelFormat avcodec_find_best_pix_fmt_of_list(const enum AVPixelFormat *pix_fmt_list,
1728                                              enum AVPixelFormat src_pix_fmt,
1729                                              int has_alpha, int *loss_ptr);
1730  enum AVPixelFormat avcodec_find_best_pix_fmt_of_2(enum AVPixelFormat dst_pix_fmt1, enum AVPixelFormat dst_pix_fmt2,
1731                                              enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr);
1732  attribute_deprecated
1733  enum AVPixelFormat avcodec_find_best_pix_fmt2(enum AVPixelFormat dst_pix_fmt1, enum AVPixelFormat dst_pix_fmt2,
1734                                              enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr);
1735  enum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum AVPixelFormat * fmt);
1736  #if FF_API_SET_DIMENSIONS
1737  attribute_deprecated
1738  void avcodec_set_dimensions(AVCodecContext *s, int width, int height);
1739  #endif
1740  #if FF_API_TAG_STRING
1741  attribute_deprecated
1742  size_t av_get_codec_tag_string(char *buf, size_t buf_size, unsigned int codec_tag);
1743  #endif
1744  void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode);
1745  const char *av_get_profile_name(const AVCodec *codec, int profile);
1746  const char *avcodec_profile_name(enum AVCodecID codec_id, int profile);
1747  int avcodec_default_execute(AVCodecContext *c, int (*func)(AVCodecContext *c2, void *arg2),void *arg, int *ret, int count, int size);
1748  int avcodec_default_execute2(AVCodecContext *c, int (*func)(AVCodecContext *c2, void *arg2, int, int),void *arg, int *ret, int count);
1749  int avcodec_fill_audio_frame(AVFrame *frame, int nb_channels,
1750                               enum AVSampleFormat sample_fmt, const uint8_t *buf,
1751                               int buf_size, int align);
1752  void avcodec_flush_buffers(AVCodecContext *avctx);
1753  int av_get_bits_per_sample(enum AVCodecID codec_id);
1754  enum AVCodecID av_get_pcm_codec(enum AVSampleFormat fmt, int be);
1755  int av_get_exact_bits_per_sample(enum AVCodecID codec_id);
1756  int av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes);
1757  int av_get_audio_frame_duration2(AVCodecParameters *par, int frame_bytes);
1758  #if FF_API_OLD_BSF
1759  typedef struct AVBitStreamFilterContext {
1760      void *priv_data;
1761      const struct AVBitStreamFilter *filter;
1762      AVCodecParserContext *parser;
1763      struct AVBitStreamFilterContext *next;
1764      char *args;
1765  } AVBitStreamFilterContext;
1766  #endif
1767  typedef struct AVBSFInternal AVBSFInternal;
1768  typedef struct AVBSFContext {
1769      const AVClass *av_class;
1770      const struct AVBitStreamFilter *filter;
1771      AVBSFInternal *internal;
1772      void *priv_data;
1773      AVCodecParameters *par_in;
1774      AVCodecParameters *par_out;
1775      AVRational time_base_in;
1776      AVRational time_base_out;
1777  } AVBSFContext;
1778  typedef struct AVBitStreamFilter {
1779      const char *name;
1780      const enum AVCodecID *codec_ids;
1781      const AVClass *priv_class;
1782      int priv_data_size;
1783      int (*init)(AVBSFContext *ctx);
1784      int (*filter)(AVBSFContext *ctx, AVPacket *pkt);
1785      void (*close)(AVBSFContext *ctx);
1786  } AVBitStreamFilter;
1787  #if FF_API_OLD_BSF
1788  attribute_deprecated
1789  void av_register_bitstream_filter(AVBitStreamFilter *bsf);
1790  attribute_deprecated
1791  AVBitStreamFilterContext *av_bitstream_filter_init(const char *name);
1792  attribute_deprecated
1793  int av_bitstream_filter_filter(AVBitStreamFilterContext *bsfc,
1794                                 AVCodecContext *avctx, const char *args,
1795                                 uint8_t **poutbuf, int *poutbuf_size,
1796                                 const uint8_t *buf, int buf_size, int keyframe);
1797  attribute_deprecated
1798  void av_bitstream_filter_close(AVBitStreamFilterContext *bsf);
1799  attribute_deprecated
1800  AVBitStreamFilter *av_bitstream_filter_next(const AVBitStreamFilter *f);
1801  #endif
1802  const AVBitStreamFilter *av_bsf_get_by_name(const char *name);
1803  const AVBitStreamFilter *av_bsf_next(void **opaque);
1804  int av_bsf_alloc(const AVBitStreamFilter *filter, AVBSFContext **ctx);
1805  int av_bsf_init(AVBSFContext *ctx);
1806  int av_bsf_send_packet(AVBSFContext *ctx, AVPacket *pkt);
1807  int av_bsf_receive_packet(AVBSFContext *ctx, AVPacket *pkt);
1808  void av_bsf_free(AVBSFContext **ctx);
1809  const AVClass *av_bsf_get_class(void);
1810  typedef struct AVBSFList AVBSFList;
1811  AVBSFList *av_bsf_list_alloc(void);
1812  void av_bsf_list_free(AVBSFList **lst);
1813  int av_bsf_list_append(AVBSFList *lst, AVBSFContext *bsf);
1814  int av_bsf_list_append2(AVBSFList *lst, const char * bsf_name, AVDictionary **options);
1815  int av_bsf_list_finalize(AVBSFList **lst, AVBSFContext **bsf);
1816  int av_bsf_list_parse_str(const char *str, AVBSFContext **bsf);
1817  int av_bsf_get_null_filter(AVBSFContext **bsf);
1818  void av_fast_padded_malloc(void *ptr, unsigned int *size, size_t min_size);
1819  void av_fast_padded_mallocz(void *ptr, unsigned int *size, size_t min_size);
1820  unsigned int av_xiphlacing(unsigned char *s, unsigned int v);
1821  #if FF_API_MISSING_SAMPLE
1822  attribute_deprecated
1823  void av_log_missing_feature(void *avc, const char *feature, int want_sample);
1824  attribute_deprecated
1825  void av_log_ask_for_sample(void *avc, const char *msg, ...) av_printf_format(2, 3);
1826  #endif &bsol;* FF_API_MISSING_SAMPLE */
1827  void av_register_hwaccel(AVHWAccel *hwaccel);
1828  AVHWAccel *av_hwaccel_next(const AVHWAccel *hwaccel);
1829  enum AVLockOp {
1830    AV_LOCK_CREATE,  
1831    AV_LOCK_OBTAIN,  
1832    AV_LOCK_RELEASE, 
1833    AV_LOCK_DESTROY, 
1834  };
1835  int av_lockmgr_register(int (*cb)(void **mutex, enum AVLockOp op));
1836  enum AVMediaType avcodec_get_type(enum AVCodecID codec_id);
1837  const char *avcodec_get_name(enum AVCodecID id);
1838  int avcodec_is_open(AVCodecContext *s);
1839  int av_codec_is_encoder(const AVCodec *codec);
1840  int av_codec_is_decoder(const AVCodec *codec);
1841  const AVCodecDescriptor *avcodec_descriptor_get(enum AVCodecID id);
1842  const AVCodecDescriptor *avcodec_descriptor_next(const AVCodecDescriptor *prev);
1843  const AVCodecDescriptor *avcodec_descriptor_get_by_name(const char *name);
1844  AVCPBProperties *av_cpb_properties_alloc(size_t *size);
1845  #endif &bsol;* AVCODEC_AVCODEC_H */
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-quant_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <math.h>
3  #include <stdlib.h>  
4  #include "src/dsp/quant.h"
5  #include "src/enc/vp8i_enc.h"
6  #include "src/enc/cost_enc.h"
7  #define DO_TRELLIS_I4  1
8  #define DO_TRELLIS_I16 1   
9  #define DO_TRELLIS_UV  0   
10  #define USE_TDISTO 1
11  #define MID_ALPHA 64      
12  #define MIN_ALPHA 30      
13  #define MAX_ALPHA 100     
14  #define SNS_TO_DQ 0.9     
15  #define FLATNESS_LIMIT_I16 0       
16  #define FLATNESS_LIMIT_I4  3       
17  #define FLATNESS_LIMIT_UV  2       
18  #define FLATNESS_PENALTY   140     
19  #define MULT_8B(a, b) (((a) * (b) + 128) >> 8)
20  #define RD_DISTO_MULT      256  
21  #if defined(DEBUG_BLOCK)
22  #include <stdio.h>
23  #include <stdlib.h>
24  static void PrintBlockInfo(const VP8EncIterator* const it,
25                             const VP8ModeScore* const rd) {
26    int i, j;
27    const int is_i16 = (it->mb_->type_ == 1);
28    const uint8_t* const y_in = it->yuv_in_ + Y_OFF_ENC;
29    const uint8_t* const y_out = it->yuv_out_ + Y_OFF_ENC;
30    const uint8_t* const uv_in = it->yuv_in_ + U_OFF_ENC;
31    const uint8_t* const uv_out = it->yuv_out_ + U_OFF_ENC;
32    printf("SOURCE / OUTPUT / ABS DELTA\n");
33    for (j = 0; j < 16; ++j) {
34      for (i = 0; i < 16; ++i) printf("%3d ", y_in[i + j * BPS]);
35      printf("     ");
36      for (i = 0; i < 16; ++i) printf("%3d ", y_out[i + j * BPS]);
37      printf("     ");
38      for (i = 0; i < 16; ++i) {
39        printf("%1d ", abs(y_in[i + j * BPS] - y_out[i + j * BPS]));
40      }
41      printf("\n");
42    }
43    printf("\n");   
44    for (j = 0; j < 8; ++j) {
45      for (i = 0; i < 8; ++i) printf("%3d ", uv_in[i + j * BPS]);
46      printf(" ");
47      for (i = 8; i < 16; ++i) printf("%3d ", uv_in[i + j * BPS]);
48      printf("    ");
49      for (i = 0; i < 8; ++i) printf("%3d ", uv_out[i + j * BPS]);
50      printf(" ");
51      for (i = 8; i < 16; ++i) printf("%3d ", uv_out[i + j * BPS]);
52      printf("   ");
53      for (i = 0; i < 8; ++i) {
54        printf("%1d ", abs(uv_out[i + j * BPS] - uv_in[i + j * BPS]));
55      }
56      printf(" ");
57      for (i = 8; i < 16; ++i) {
58        printf("%1d ", abs(uv_out[i + j * BPS] - uv_in[i + j * BPS]));
59      }
60      printf("\n");
61    }
62    printf("\nD:%d SD:%d R:%d H:%d nz:0x%x score:%d\n",
63      (int)rd->D, (int)rd->SD, (int)rd->R, (int)rd->H, (int)rd->nz,
64      (int)rd->score);
65    if (is_i16) {
66      printf("Mode: %d\n", rd->mode_i16);
67      printf("y_dc_levels:");
68      for (i = 0; i < 16; ++i) printf("%3d ", rd->y_dc_levels[i]);
69      printf("\n");
70    } else {
71      printf("Modes[16]: ");
72      for (i = 0; i < 16; ++i) printf("%d ", rd->modes_i4[i]);
73      printf("\n");
74    }
75    printf("y_ac_levels:\n");
76    for (j = 0; j < 16; ++j) {
77      for (i = is_i16 ? 1 : 0; i < 16; ++i) {
78        printf("%4d ", rd->y_ac_levels[j][i]);
79      }
80      printf("\n");
81    }
82    printf("\n");
83    printf("uv_levels (mode=%d):\n", rd->mode_uv);
84    for (j = 0; j < 8; ++j) {
85      for (i = 0; i < 16; ++i) {
86        printf("%4d ", rd->uv_levels[j][i]);
87      }
88      printf("\n");
89    }
90  }
91  #endif   
92  static WEBP_INLINE int clip(int v, int m, int M) {
93    return v < m ? m : v > M ? M : v;
94  }
95  static const uint8_t kZigzag[16] = {
96    0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15
97  };
98  static const uint8_t kDcTable[128] = {
99    4,     5,   6,   7,   8,   9,  10,  10,
100    11,   12,  13,  14,  15,  16,  17,  17,
101    18,   19,  20,  20,  21,  21,  22,  22,
102    23,   23,  24,  25,  25,  26,  27,  28,
103    29,   30,  31,  32,  33,  34,  35,  36,
104    37,   37,  38,  39,  40,  41,  42,  43,
105    44,   45,  46,  46,  47,  48,  49,  50,
106    51,   52,  53,  54,  55,  56,  57,  58,
107    59,   60,  61,  62,  63,  64,  65,  66,
108    67,   68,  69,  70,  71,  72,  73,  74,
109    75,   76,  76,  77,  78,  79,  80,  81,
110    82,   83,  84,  85,  86,  87,  88,  89,
111    91,   93,  95,  96,  98, 100, 101, 102,
112    104, 106, 108, 110, 112, 114, 116, 118,
113    122, 124, 126, 128, 130, 132, 134, 136,
114    138, 140, 143, 145, 148, 151, 154, 157
115  };
116  static const uint16_t kAcTable[128] = {
117    4,     5,   6,   7,   8,   9,  10,  11,
118    12,   13,  14,  15,  16,  17,  18,  19,
119    20,   21,  22,  23,  24,  25,  26,  27,
120    28,   29,  30,  31,  32,  33,  34,  35,
121    36,   37,  38,  39,  40,  41,  42,  43,
122    44,   45,  46,  47,  48,  49,  50,  51,
123    52,   53,  54,  55,  56,  57,  58,  60,
124    62,   64,  66,  68,  70,  72,  74,  76,
125    78,   80,  82,  84,  86,  88,  90,  92,
126    94,   96,  98, 100, 102, 104, 106, 108,
127    110, 112, 114, 116, 119, 122, 125, 128,
128    131, 134, 137, 140, 143, 146, 149, 152,
129    155, 158, 161, 164, 167, 170, 173, 177,
130    181, 185, 189, 193, 197, 201, 205, 209,
131    213, 217, 221, 225, 229, 234, 239, 245,
132    249, 254, 259, 264, 269, 274, 279, 284
133  };
134  static const uint16_t kAcTable2[128] = {
135    8,     8,   9,  10,  12,  13,  15,  17,
136    18,   20,  21,  23,  24,  26,  27,  29,
137    31,   32,  34,  35,  37,  38,  40,  41,
138    43,   44,  46,  48,  49,  51,  52,  54,
139    55,   57,  58,  60,  62,  63,  65,  66,
140    68,   69,  71,  72,  74,  75,  77,  79,
141    80,   82,  83,  85,  86,  88,  89,  93,
142    96,   99, 102, 105, 108, 111, 114, 117,
143    120, 124, 127, 130, 133, 136, 139, 142,
144    145, 148, 151, 155, 158, 161, 164, 167,
145    170, 173, 176, 179, 184, 189, 193, 198,
146    203, 207, 212, 217, 221, 226, 230, 235,
147    240, 244, 249, 254, 258, 263, 268, 274,
148    280, 286, 292, 299, 305, 311, 317, 323,
149    330, 336, 342, 348, 354, 362, 370, 379,
150    385, 393, 401, 409, 416, 424, 432, 440
151  };
152  static const uint8_t kBiasMatrices[3][2] = {  
153    { 96, 110 }, { 96, 108 }, { 110, 115 }
154  };
155  #define SHARPEN_BITS 11  
156  static const uint8_t kFreqSharpening[16] = {
157    0,  30, 60, 90,
158    30, 60, 90, 90,
159    60, 90, 90, 90,
160    90, 90, 90, 90
161  };
162  static int ExpandMatrix(VP8Matrix* const m, int type) {
163    int i, sum;
164    for (i = 0; i < 2; ++i) {
165      const int is_ac_coeff = (i > 0);
166      const int bias = kBiasMatrices[type][is_ac_coeff];
167      m->iq_[i] = (1 << QFIX) / m->q_[i];
168      m->bias_[i] = BIAS(bias);
169      m->zthresh_[i] = ((1 << QFIX) - 1 - m->bias_[i]) / m->iq_[i];
170    }
171    for (i = 2; i < 16; ++i) {
172      m->q_[i] = m->q_[1];
173      m->iq_[i] = m->iq_[1];
174      m->bias_[i] = m->bias_[1];
175      m->zthresh_[i] = m->zthresh_[1];
176    }
177    for (sum = 0, i = 0; i < 16; ++i) {
178      if (type == 0) {  
179        m->sharpen_[i] = (kFreqSharpening[i] * m->q_[i]) >> SHARPEN_BITS;
180      } else {
181        m->sharpen_[i] = 0;
182      }
183      sum += m->q_[i];
184    }
185    return (sum + 8) >> 4;
186  }
187  static void CheckLambdaValue(int* const v) { if (*v < 1) *v = 1; }
188  static void SetupMatrices(VP8Encoder* enc) {
189    int i;
190    const int tlambda_scale =
191      (enc->method_ >= 4) ? enc->config_->sns_strength
192                          : 0;
193    const int num_segments = enc->segment_hdr_.num_segments_;
194    for (i = 0; i < num_segments; ++i) {
195      VP8SegmentInfo* const m = &enc->dqm_[i];
196      const int q = m->quant_;
197      int q_i4, q_i16, q_uv;
198      m->y1_.q_[0] = kDcTable[clip(q + enc->dq_y1_dc_, 0, 127)];
199      m->y1_.q_[1] = kAcTable[clip(q,                  0, 127)];
200      m->y2_.q_[0] = kDcTable[ clip(q + enc->dq_y2_dc_, 0, 127)] * 2;
201      m->y2_.q_[1] = kAcTable2[clip(q + enc->dq_y2_ac_, 0, 127)];
202      m->uv_.q_[0] = kDcTable[clip(q + enc->dq_uv_dc_, 0, 117)];
203      m->uv_.q_[1] = kAcTable[clip(q + enc->dq_uv_ac_, 0, 127)];
204      q_i4  = ExpandMatrix(&m->y1_, 0);
205      q_i16 = ExpandMatrix(&m->y2_, 1);
206      q_uv  = ExpandMatrix(&m->uv_, 2);
207      m->lambda_i4_          = (3 * q_i4 * q_i4) >> 7;
208      m->lambda_i16_         = (3 * q_i16 * q_i16);
209      m->lambda_uv_          = (3 * q_uv * q_uv) >> 6;
210      m->lambda_mode_        = (1 * q_i4 * q_i4) >> 7;
211      m->lambda_trellis_i4_  = (7 * q_i4 * q_i4) >> 3;
212      m->lambda_trellis_i16_ = (q_i16 * q_i16) >> 2;
213      m->lambda_trellis_uv_  = (q_uv * q_uv) << 1;
214      m->tlambda_            = (tlambda_scale * q_i4) >> 5;
215      CheckLambdaValue(&m->lambda_i4_);
216      CheckLambdaValue(&m->lambda_i16_);
217      CheckLambdaValue(&m->lambda_uv_);
218      CheckLambdaValue(&m->lambda_mode_);
219      CheckLambdaValue(&m->lambda_trellis_i4_);
220      CheckLambdaValue(&m->lambda_trellis_i16_);
221      CheckLambdaValue(&m->lambda_trellis_uv_);
222      CheckLambdaValue(&m->tlambda_);
223      m->min_disto_ = 20 * m->y1_.q_[0];   
224      m->max_edge_  = 0;
225      m->i4_penalty_ = 1000 * q_i4 * q_i4;
226    }
227  }
228  #define FSTRENGTH_CUTOFF 2
229  static void SetupFilterStrength(VP8Encoder* const enc) {
230    int i;
231    const int level0 = 5 * enc->config_->filter_strength;
232    for (i = 0; i < NUM_MB_SEGMENTS; ++i) {
233      VP8SegmentInfo* const m = &enc->dqm_[i];
234      const int qstep = kAcTable[clip(m->quant_, 0, 127)] >> 2;
235      const int base_strength =
236          VP8FilterStrengthFromDelta(enc->filter_hdr_.sharpness_, qstep);
237      const int f = base_strength * level0 / (256 + m->beta_);
238      m->fstrength_ = (f < FSTRENGTH_CUTOFF) ? 0 : (f > 63) ? 63 : f;
239    }
240    enc->filter_hdr_.level_ = enc->dqm_[0].fstrength_;
241    enc->filter_hdr_.simple_ = (enc->config_->filter_type == 0);
242    enc->filter_hdr_.sharpness_ = enc->config_->filter_sharpness;
243  }
244  #define MAX_DQ_UV (6)
245  #define MIN_DQ_UV (-4)
246  static double QualityToCompression(double c) {
247    const double linear_c = (c < 0.75) ? c * (2. / 3.) : 2. * c - 1.;
248    const double v = pow(linear_c, 1 / 3.);
249    return v;
250  }
251  static double QualityToJPEGCompression(double c, double alpha) {
252    const double amin = 0.30;
253    const double amax = 0.85;
254    const double exp_min = 0.4;
255    const double exp_max = 0.9;
256    const double slope = (exp_min - exp_max) / (amax - amin);
257    const double expn = (alpha > amax) ? exp_min
258                      : (alpha < amin) ? exp_max
259                      : exp_max + slope * (alpha - amin);
260    const double v = pow(c, expn);
261    return v;
262  }
263  static int SegmentsAreEquivalent(const VP8SegmentInfo* const S1,
264                                   const VP8SegmentInfo* const S2) {
265    return (S1->quant_ == S2->quant_) && (S1->fstrength_ == S2->fstrength_);
266  }
267  static void SimplifySegments(VP8Encoder* const enc) {
268    int map[NUM_MB_SEGMENTS] = { 0, 1, 2, 3 };
269    const int num_segments = (enc->segment_hdr_.num_segments_ < NUM_MB_SEGMENTS)
270                                 ? enc->segment_hdr_.num_segments_
271                                 : NUM_MB_SEGMENTS;
272    int num_final_segments = 1;
273    int s1, s2;
274    for (s1 = 1; s1 < num_segments; ++s1) {    
275      const VP8SegmentInfo* const S1 = &enc->dqm_[s1];
276      int found = 0;
277      for (s2 = 0; s2 < num_final_segments; ++s2) {
278        const VP8SegmentInfo* const S2 = &enc->dqm_[s2];
279        if (SegmentsAreEquivalent(S1, S2)) {
280          found = 1;
281          break;
282        }
283      }
284      map[s1] = s2;
285      if (!found) {
286        if (num_final_segments != s1) {
287          enc->dqm_[num_final_segments] = enc->dqm_[s1];
288        }
289        ++num_final_segments;
290      }
291    }
292    if (num_final_segments < num_segments) {  
293      int i = enc->mb_w_ * enc->mb_h_;
294      while (i-- > 0) enc->mb_info_[i].segment_ = map[enc->mb_info_[i].segment_];
295      enc->segment_hdr_.num_segments_ = num_final_segments;
296      for (i = num_final_segments; i < num_segments; ++i) {
297        enc->dqm_[i] = enc->dqm_[num_final_segments - 1];
298      }
299    }
300  }
301  void VP8SetSegmentParams(VP8Encoder* const enc, float quality) {
302    int i;
303    int dq_uv_ac, dq_uv_dc;
304    const int num_segments = enc->segment_hdr_.num_segments_;
305    const double amp = SNS_TO_DQ * enc->config_->sns_strength / 100. / 128.;
306    const double Q = quality / 100.;
307    const double c_base = enc->config_->emulate_jpeg_size ?
308        QualityToJPEGCompression(Q, enc->alpha_ / 255.) :
309        QualityToCompression(Q);
310    for (i = 0; i < num_segments; ++i) {
311      const double expn = 1. - amp * enc->dqm_[i].alpha_;
312      const double c = pow(c_base, expn);
313      const int q = (int)(127. * (1. - c));
314      assert(expn > 0.);
315      enc->dqm_[i].quant_ = clip(q, 0, 127);
316    }
317    enc->base_quant_ = enc->dqm_[0].quant_;
318    for (i = num_segments; i < NUM_MB_SEGMENTS; ++i) {
319      enc->dqm_[i].quant_ = enc->base_quant_;
320    }
321    dq_uv_ac = (enc->uv_alpha_ - MID_ALPHA) * (MAX_DQ_UV - MIN_DQ_UV)
322                                            / (MAX_ALPHA - MIN_ALPHA);
323    dq_uv_ac = dq_uv_ac * enc->config_->sns_strength / 100;
324    dq_uv_ac = clip(dq_uv_ac, MIN_DQ_UV, MAX_DQ_UV);
325    dq_uv_dc = -4 * enc->config_->sns_strength / 100;
326    dq_uv_dc = clip(dq_uv_dc, -15, 15);   
327    enc->dq_y1_dc_ = 0;       
328    enc->dq_y2_dc_ = 0;
329    enc->dq_y2_ac_ = 0;
330    enc->dq_uv_dc_ = dq_uv_dc;
331    enc->dq_uv_ac_ = dq_uv_ac;
332    SetupFilterStrength(enc);   
333    if (num_segments > 1) SimplifySegments(enc);
334    SetupMatrices(enc);         
335  }
336  const uint16_t VP8I16ModeOffsets[4] = { I16DC16, I16TM16, I16VE16, I16HE16 };
337  const uint16_t VP8UVModeOffsets[4] = { C8DC8, C8TM8, C8VE8, C8HE8 };
338  const uint16_t VP8I4ModeOffsets[NUM_BMODES] = {
339    I4DC4, I4TM4, I4VE4, I4HE4, I4RD4, I4VR4, I4LD4, I4VL4, I4HD4, I4HU4
340  };
341  void VP8MakeLuma16Preds(const VP8EncIterator* const it) {
342    const uint8_t* const left = it->x_ ? it->y_left_ : NULL;
343    const uint8_t* const top = it->y_ ? it->y_top_ : NULL;
344    VP8EncPredLuma16(it->yuv_p_, left, top);
345  }
346  void VP8MakeChroma8Preds(const VP8EncIterator* const it) {
347    const uint8_t* const left = it->x_ ? it->u_left_ : NULL;
348    const uint8_t* const top = it->y_ ? it->uv_top_ : NULL;
349    VP8EncPredChroma8(it->yuv_p_, left, top);
350  }
351  void VP8MakeIntra4Preds(const VP8EncIterator* const it) {
352    VP8EncPredLuma4(it->yuv_p_, it->i4_top_);
353  }
354  const uint16_t VP8Scan[16] = {  
355    0 +  0 * BPS,  4 +  0 * BPS, 8 +  0 * BPS, 12 +  0 * BPS,
356    0 +  4 * BPS,  4 +  4 * BPS, 8 +  4 * BPS, 12 +  4 * BPS,
357    0 +  8 * BPS,  4 +  8 * BPS, 8 +  8 * BPS, 12 +  8 * BPS,
358    0 + 12 * BPS,  4 + 12 * BPS, 8 + 12 * BPS, 12 + 12 * BPS,
359  };
360  static const uint16_t VP8ScanUV[4 + 4] = {
361    0 + 0 * BPS,   4 + 0 * BPS, 0 + 4 * BPS,  4 + 4 * BPS,    
362    8 + 0 * BPS,  12 + 0 * BPS, 8 + 4 * BPS, 12 + 4 * BPS     
363  };
364  static const uint16_t kWeightY[16] = {
365    38, 32, 20, 9, 32, 28, 17, 7, 20, 17, 10, 4, 9, 7, 4, 2
366  };
367  static const uint16_t kWeightTrellis[16] = {
368  #if USE_TDISTO == 0
369    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
370  #else
371    30, 27, 19, 11,
372    27, 24, 17, 10,
373    19, 17, 12,  8,
374    11, 10,  8,  6
375  #endif
376  };
377  static void InitScore(VP8ModeScore* const rd) {
378    rd->D  = 0;
379    rd->SD = 0;
380    rd->R  = 0;
381    rd->H  = 0;
382    rd->nz = 0;
383    rd->score = MAX_COST;
384  }
385  static void CopyScore(VP8ModeScore* const dst, const VP8ModeScore* const src) {
386    dst->D  = src->D;
387    dst->SD = src->SD;
388    dst->R  = src->R;
389    dst->H  = src->H;
390    dst->nz = src->nz;      
391    dst->score = src->score;
392  }
393  static void AddScore(VP8ModeScore* const dst, const VP8ModeScore* const src) {
394    dst->D  += src->D;
395    dst->SD += src->SD;
396    dst->R  += src->R;
397    dst->H  += src->H;
398    dst->nz |= src->nz;     
399    dst->score += src->score;
400  }
401  typedef struct {
402    int8_t prev;            
403    int8_t sign;            
404    int16_t level;          
405  } Node;
406  typedef struct {
407    score_t score;          
408    const uint16_t* costs;  
409  } ScoreState;
410  #define MIN_DELTA 0   
411  #define MAX_DELTA 1   
412  #define NUM_NODES (MIN_DELTA + 1 + MAX_DELTA)
413  #define NODE(n, l) (nodes[(n)][(l) + MIN_DELTA])
414  #define SCORE_STATE(n, l) (score_states[n][(l) + MIN_DELTA])
415  static WEBP_INLINE void SetRDScore(int lambda, VP8ModeScore* const rd) {
416    rd->score = (rd->R + rd->H) * lambda + RD_DISTO_MULT * (rd->D + rd->SD);
417  }
418  static WEBP_INLINE score_t RDScoreTrellis(int lambda, score_t rate,
419                                            score_t distortion) {
420    return rate * lambda + RD_DISTO_MULT * distortion;
421  }
422  static int TrellisQuantizeBlock(const VP8Encoder* const enc,
423                                  int16_t in[16], int16_t out[16],
424                                  int ctx0, int coeff_type,
425                                  const VP8Matrix* const mtx,
426                                  int lambda) {
427    const ProbaArray* const probas = enc->proba_.coeffs_[coeff_type];
428    CostArrayPtr const costs =
429        (CostArrayPtr)enc->proba_.remapped_costs_[coeff_type];
430    const int first = (coeff_type == 0) ? 1 : 0;
431    Node nodes[16][NUM_NODES];
432    ScoreState score_states[2][NUM_NODES];
433    ScoreState* ss_cur = &SCORE_STATE(0, MIN_DELTA);
434    ScoreState* ss_prev = &SCORE_STATE(1, MIN_DELTA);
435    int best_path[3] = {-1, -1, -1};   
436    score_t best_score;
437    int n, m, p, last;
438    {
439      score_t cost;
440      const int thresh = mtx->q_[1] * mtx->q_[1] / 4;
441      const int last_proba = probas[VP8EncBands[first]][ctx0][0];
442      last = first - 1;
443      for (n = 15; n >= first; --n) {
444        const int j = kZigzag[n];
445        const int err = in[j] * in[j];
446        if (err > thresh) {
447          last = n;
448          break;
449        }
450      }
451      if (last < 15) ++last;
452      cost = VP8BitCost(0, last_proba);
453      best_score = RDScoreTrellis(lambda, cost, 0);
454      for (m = -MIN_DELTA; m <= MAX_DELTA; ++m) {
455        const score_t rate = (ctx0 == 0) ? VP8BitCost(1, last_proba) : 0;
456        ss_cur[m].score = RDScoreTrellis(lambda, rate, 0);
457        ss_cur[m].costs = costs[first][ctx0];
458      }
459    }
460    for (n = first; n <= last; ++n) {
461      const int j = kZigzag[n];
462      const uint32_t Q  = mtx->q_[j];
463      const uint32_t iQ = mtx->iq_[j];
464      const uint32_t B = BIAS(0x00);     
465      const int sign = (in[j] < 0);
466      const uint32_t coeff0 = (sign ? -in[j] : in[j]) + mtx->sharpen_[j];
467      int level0 = QUANTDIV(coeff0, iQ, B);
468      int thresh_level = QUANTDIV(coeff0, iQ, BIAS(0x80));
469      if (thresh_level > MAX_LEVEL) thresh_level = MAX_LEVEL;
470      if (level0 > MAX_LEVEL) level0 = MAX_LEVEL;
471      {   
472        ScoreState* const tmp = ss_cur;
473        ss_cur = ss_prev;
474        ss_prev = tmp;
475      }
476      for (m = -MIN_DELTA; m <= MAX_DELTA; ++m) {
477        Node* const cur = &NODE(n, m);
478        int level = level0 + m;
479        const int ctx = (level > 2) ? 2 : level;
480        const int band = VP8EncBands[n + 1];
481        score_t base_score;
482        score_t best_cur_score = MAX_COST;
483        int best_prev = 0;   
484        ss_cur[m].score = MAX_COST;
485        ss_cur[m].costs = costs[n + 1][ctx];
486        if (level < 0 || level > thresh_level) {
487          continue;
488        }
489        {
490          const int new_error = coeff0 - level * Q;
491          const int delta_error =
492              kWeightTrellis[j] * (new_error * new_error - coeff0 * coeff0);
493          base_score = RDScoreTrellis(lambda, 0, delta_error);
494        }
495        for (p = -MIN_DELTA; p <= MAX_DELTA; ++p) {
496          const score_t cost = VP8LevelCost(ss_prev[p].costs, level);
497          const score_t score =
498              base_score + ss_prev[p].score + RDScoreTrellis(lambda, cost, 0);
499          if (score < best_cur_score) {
500            best_cur_score = score;
501            best_prev = p;
502          }
503        }
504        cur->sign = sign;
505        cur->level = level;
506        cur->prev = best_prev;
507        ss_cur[m].score = best_cur_score;
508        if (level != 0) {
509          const score_t last_pos_cost =
510              (n < 15) ? VP8BitCost(0, probas[band][ctx][0]) : 0;
511          const score_t last_pos_score = RDScoreTrellis(lambda, last_pos_cost, 0);
512          const score_t score = best_cur_score + last_pos_score;
513          if (score < best_score) {
514            best_score = score;
515            best_path[0] = n;                     
516            best_path[1] = m;                     
517            best_path[2] = best_prev;             
518          }
519        }
520      }
521    }
522    memset(in + first, 0, (16 - first) * sizeof(*in));
523    memset(out + first, 0, (16 - first) * sizeof(*out));
524    if (best_path[0] == -1) {
525      return 0;   
526    }
527    {
528      int nz = 0;
529      int best_node = best_path[1];
530      n = best_path[0];
531      NODE(n, best_node).prev = best_path[2];   
532      for (; n >= first; --n) {
533        const Node* const node = &NODE(n, best_node);
534        const int j = kZigzag[n];
535        out[n] = node->sign ? -node->level : node->level;
536        nz |= node->level;
537        in[j] = out[n] * mtx->q_[j];
538        best_node = node->prev;
539      }
540      return (nz != 0);
541    }
542  }
543  #undef NODE
544  static int ReconstructIntra16(VP8EncIterator* const it,
545                                VP8ModeScore* const rd,
546                                uint8_t* const yuv_out,
547                                int mode) {
548    const VP8Encoder* const enc = it->enc_;
549    const uint8_t* const ref = it->yuv_p_ + VP8I16ModeOffsets[mode];
550    const uint8_t* const src = it->yuv_in_ + Y_OFF_ENC;
551    const VP8SegmentInfo* const dqm = &enc->dqm_[it->mb_->segment_];
552    int nz = 0;
553    int n;
554    int16_t tmp[16][16], dc_tmp[16];
555    for (n = 0; n < 16; n += 2) {
556      VP8FTransform2(src + VP8Scan[n], ref + VP8Scan[n], tmp[n]);
557    }
558    VP8FTransformWHT(tmp[0], dc_tmp);
559    nz |= VP8EncQuantizeBlockWHT(dc_tmp, rd->y_dc_levels, &dqm->y2_) << 24;
560    if (DO_TRELLIS_I16 && it->do_trellis_) {
561      int x, y;
562      VP8IteratorNzToBytes(it);
563      for (y = 0, n = 0; y < 4; ++y) {
564        for (x = 0; x < 4; ++x, ++n) {
565          const int ctx = it->top_nz_[x] + it->left_nz_[y];
566          const int non_zero =
567              TrellisQuantizeBlock(enc, tmp[n], rd->y_ac_levels[n], ctx, 0,
568                                   &dqm->y1_, dqm->lambda_trellis_i16_);
569          it->top_nz_[x] = it->left_nz_[y] = non_zero;
570          rd->y_ac_levels[n][0] = 0;
571          nz |= non_zero << n;
572        }
573      }
574    } else {
575      for (n = 0; n < 16; n += 2) {
576        tmp[n][0] = tmp[n + 1][0] = 0;
577        nz |= VP8EncQuantize2Blocks(tmp[n], rd->y_ac_levels[n], &dqm->y1_) << n;
578        assert(rd->y_ac_levels[n + 0][0] == 0);
579        assert(rd->y_ac_levels[n + 1][0] == 0);
580      }
581    }
582    VP8TransformWHT(dc_tmp, tmp[0]);
583    for (n = 0; n < 16; n += 2) {
584      VP8ITransform(ref + VP8Scan[n], tmp[n], yuv_out + VP8Scan[n], 1);
585    }
586    return nz;
587  }
588  static int ReconstructIntra4(VP8EncIterator* const it,
589                               int16_t levels[16],
590                               const uint8_t* const src,
591                               uint8_t* const yuv_out,
592                               int mode) {
593    const VP8Encoder* const enc = it->enc_;
594    const uint8_t* const ref = it->yuv_p_ + VP8I4ModeOffsets[mode];
595    const VP8SegmentInfo* const dqm = &enc->dqm_[it->mb_->segment_];
596    int nz = 0;
597    int16_t tmp[16];
598    VP8FTransform(src, ref, tmp);
599    if (DO_TRELLIS_I4 && it->do_trellis_) {
600      const int x = it->i4_ & 3, y = it->i4_ >> 2;
601      const int ctx = it->top_nz_[x] + it->left_nz_[y];
602      nz = TrellisQuantizeBlock(enc, tmp, levels, ctx, 3, &dqm->y1_,
603                                dqm->lambda_trellis_i4_);
604    } else {
605      nz = VP8EncQuantizeBlock(tmp, levels, &dqm->y1_);
606    }
607    VP8ITransform(ref, tmp, yuv_out, 0);
608    return nz;
609  }
610  #define C1 7    
611  #define C2 8    
612  #define DSHIFT 4
613  #define DSCALE 1   
614  static int QuantizeSingle(int16_t* const v, const VP8Matrix* const mtx) {
615    int V = *v;
616    const int sign = (V < 0);
617    if (sign) V = -V;
618    if (V > (int)mtx->zthresh_[0]) {
619      const int qV = QUANTDIV(V, mtx->iq_[0], mtx->bias_[0]) * mtx->q_[0];
620      const int err = (V - qV);
621      *v = sign ? -qV : qV;
622      return (sign ? -err : err) >> DSCALE;
623    }
624    *v = 0;
625    return (sign ? -V : V) >> DSCALE;
626  }
627  static void CorrectDCValues(const VP8EncIterator* const it,
628                              const VP8Matrix* const mtx,
629                              int16_t tmp[][16], VP8ModeScore* const rd) {
630    int ch;
631    for (ch = 0; ch <= 1; ++ch) {
632      const int8_t* const top = it->top_derr_[it->x_][ch];
633      const int8_t* const left = it->left_derr_[ch];
634      int16_t (* const c)[16] = &tmp[ch * 4];
635      int err0, err1, err2, err3;
636      c[0][0] += (C1 * top[0] + C2 * left[0]) >> (DSHIFT - DSCALE);
637      err0 = QuantizeSingle(&c[0][0], mtx);
<span onclick='openModal()' class='match'>638      c[1][0] += (C1 * top[1] + C2 * err0) >> (DSHIFT - DSCALE);
639      err1 = QuantizeSingle(&c[1][0], mtx);
640      c[2][0] += (C1 * err0 + C2 * left[1]) >> (DSHIFT - DSCALE);
641      err2 = QuantizeSingle(&c[2][0], mtx);
642      c[3][0] += (C1 * err1 + C2 * err2) >> (DSHIFT - DSCALE);
643      err3 = QuantizeSingle(&c[3][0], mtx);
644      assert(abs(err1) <= 127 && abs(err2) <= 127 && abs(err3) <= 127);
645      rd->derr[ch][0] = (int8_t)err1;
646      rd->derr[ch][1] = (int8_t)err2;
647      rd->derr[ch][2] = (int8_t)err3;
648    }
</span>649  }
650  static void StoreDiffusionErrors(VP8EncIterator* const it,
651                                   const VP8ModeScore* const rd) {
652    int ch;
653    for (ch = 0; ch <= 1; ++ch) {
654      int8_t* const top = it->top_derr_[it->x_][ch];
655      int8_t* const left = it->left_derr_[ch];
656      left[0] = rd->derr[ch][0];            
657      left[1] = 3 * rd->derr[ch][2] >> 2;   
658      top[0]  = rd->derr[ch][1];            
659      top[1]  = rd->derr[ch][2] - left[1];  
660    }
661  }
662  #undef C1
663  #undef C2
664  #undef DSHIFT
665  #undef DSCALE
666  static int ReconstructUV(VP8EncIterator* const it, VP8ModeScore* const rd,
667                           uint8_t* const yuv_out, int mode) {
668    const VP8Encoder* const enc = it->enc_;
669    const uint8_t* const ref = it->yuv_p_ + VP8UVModeOffsets[mode];
670    const uint8_t* const src = it->yuv_in_ + U_OFF_ENC;
671    const VP8SegmentInfo* const dqm = &enc->dqm_[it->mb_->segment_];
672    int nz = 0;
673    int n;
674    int16_t tmp[8][16];
675    for (n = 0; n < 8; n += 2) {
676      VP8FTransform2(src + VP8ScanUV[n], ref + VP8ScanUV[n], tmp[n]);
677    }
678    if (it->top_derr_ != NULL) CorrectDCValues(it, &dqm->uv_, tmp, rd);
679    if (DO_TRELLIS_UV && it->do_trellis_) {
680      int ch, x, y;
681      for (ch = 0, n = 0; ch <= 2; ch += 2) {
682        for (y = 0; y < 2; ++y) {
683          for (x = 0; x < 2; ++x, ++n) {
684            const int ctx = it->top_nz_[4 + ch + x] + it->left_nz_[4 + ch + y];
685            const int non_zero =
686                TrellisQuantizeBlock(enc, tmp[n], rd->uv_levels[n], ctx, 2,
687                                     &dqm->uv_, dqm->lambda_trellis_uv_);
688            it->top_nz_[4 + ch + x] = it->left_nz_[4 + ch + y] = non_zero;
689            nz |= non_zero << n;
690          }
691        }
692      }
693    } else {
694      for (n = 0; n < 8; n += 2) {
695        nz |= VP8EncQuantize2Blocks(tmp[n], rd->uv_levels[n], &dqm->uv_) << n;
696      }
697    }
698    for (n = 0; n < 8; n += 2) {
699      VP8ITransform(ref + VP8ScanUV[n], tmp[n], yuv_out + VP8ScanUV[n], 1);
700    }
701    return (nz << 16);
702  }
703  static void StoreMaxDelta(VP8SegmentInfo* const dqm, const int16_t DCs[16]) {
704    const int v0 = abs(DCs[1]);
705    const int v1 = abs(DCs[2]);
706    const int v2 = abs(DCs[4]);
707    int max_v = (v1 > v0) ? v1 : v0;
708    max_v = (v2 > max_v) ? v2 : max_v;
709    if (max_v > dqm->max_edge_) dqm->max_edge_ = max_v;
710  }
711  static void SwapModeScore(VP8ModeScore** a, VP8ModeScore** b) {
712    VP8ModeScore* const tmp = *a;
713    *a = *b;
714    *b = tmp;
715  }
716  static void SwapPtr(uint8_t** a, uint8_t** b) {
717    uint8_t* const tmp = *a;
718    *a = *b;
719    *b = tmp;
720  }
721  static void SwapOut(VP8EncIterator* const it) {
722    SwapPtr(&it->yuv_out_, &it->yuv_out2_);
723  }
724  static void PickBestIntra16(VP8EncIterator* const it, VP8ModeScore* rd) {
725    const int kNumBlocks = 16;
726    VP8SegmentInfo* const dqm = &it->enc_->dqm_[it->mb_->segment_];
727    const int lambda = dqm->lambda_i16_;
728    const int tlambda = dqm->tlambda_;
729    const uint8_t* const src = it->yuv_in_ + Y_OFF_ENC;
730    VP8ModeScore rd_tmp;
731    VP8ModeScore* rd_cur = &rd_tmp;
732    VP8ModeScore* rd_best = rd;
733    int mode;
734    int is_flat = IsFlatSource16(it->yuv_in_ + Y_OFF_ENC);
735    rd->mode_i16 = -1;
736    for (mode = 0; mode < NUM_PRED_MODES; ++mode) {
737      uint8_t* const tmp_dst = it->yuv_out2_ + Y_OFF_ENC;  
738      rd_cur->mode_i16 = mode;
739      rd_cur->nz = ReconstructIntra16(it, rd_cur, tmp_dst, mode);
740      rd_cur->D = VP8SSE16x16(src, tmp_dst);
741      rd_cur->SD =
742          tlambda ? MULT_8B(tlambda, VP8TDisto16x16(src, tmp_dst, kWeightY)) : 0;
743      rd_cur->H = VP8FixedCostsI16[mode];
744      rd_cur->R = VP8GetCostLuma16(it, rd_cur);
745      if (is_flat) {
746        is_flat = IsFlat(rd_cur->y_ac_levels[0], kNumBlocks, FLATNESS_LIMIT_I16);
747        if (is_flat) {
748          rd_cur->D *= 2;
749          rd_cur->SD *= 2;
750        }
751      }
752      SetRDScore(lambda, rd_cur);
753      if (mode == 0 || rd_cur->score < rd_best->score) {
754        SwapModeScore(&rd_cur, &rd_best);
755        SwapOut(it);
756      }
757    }
758    if (rd_best != rd) {
759      memcpy(rd, rd_best, sizeof(*rd));
760    }
761    SetRDScore(dqm->lambda_mode_, rd);   
762    VP8SetIntra16Mode(it, rd->mode_i16);
763    if ((rd->nz & 0x100ffff) == 0x1000000 && rd->D > dqm->min_disto_) {
764      StoreMaxDelta(dqm, rd->y_dc_levels);
765    }
766  }
767  static const uint16_t* GetCostModeI4(VP8EncIterator* const it,
768                                       const uint8_t modes[16]) {
769    const int preds_w = it->enc_->preds_w_;
770    const int x = (it->i4_ & 3), y = it->i4_ >> 2;
771    const int left = (x == 0) ? it->preds_[y * preds_w - 1] : modes[it->i4_ - 1];
772    const int top = (y == 0) ? it->preds_[-preds_w + x] : modes[it->i4_ - 4];
773    return VP8FixedCostsI4[top][left];
774  }
775  static int PickBestIntra4(VP8EncIterator* const it, VP8ModeScore* const rd) {
776    const VP8Encoder* const enc = it->enc_;
777    const VP8SegmentInfo* const dqm = &enc->dqm_[it->mb_->segment_];
778    const int lambda = dqm->lambda_i4_;
779    const int tlambda = dqm->tlambda_;
780    const uint8_t* const src0 = it->yuv_in_ + Y_OFF_ENC;
781    uint8_t* const best_blocks = it->yuv_out2_ + Y_OFF_ENC;
782    int total_header_bits = 0;
783    VP8ModeScore rd_best;
784    if (enc->max_i4_header_bits_ == 0) {
785      return 0;
786    }
787    InitScore(&rd_best);
788    rd_best.H = 211;  
789    SetRDScore(dqm->lambda_mode_, &rd_best);
790    VP8IteratorStartI4(it);
791    do {
792      const int kNumBlocks = 1;
793      VP8ModeScore rd_i4;
794      int mode;
795      int best_mode = -1;
796      const uint8_t* const src = src0 + VP8Scan[it->i4_];
797      const uint16_t* const mode_costs = GetCostModeI4(it, rd->modes_i4);
798      uint8_t* best_block = best_blocks + VP8Scan[it->i4_];
799      uint8_t* tmp_dst = it->yuv_p_ + I4TMP;    
800      InitScore(&rd_i4);
801      VP8MakeIntra4Preds(it);
802      for (mode = 0; mode < NUM_BMODES; ++mode) {
803        VP8ModeScore rd_tmp;
804        int16_t tmp_levels[16];
805        rd_tmp.nz =
806            ReconstructIntra4(it, tmp_levels, src, tmp_dst, mode) << it->i4_;
807        rd_tmp.D = VP8SSE4x4(src, tmp_dst);
808        rd_tmp.SD =
809            tlambda ? MULT_8B(tlambda, VP8TDisto4x4(src, tmp_dst, kWeightY))
810                    : 0;
811        rd_tmp.H = mode_costs[mode];
812        if (mode > 0 && IsFlat(tmp_levels, kNumBlocks, FLATNESS_LIMIT_I4)) {
813          rd_tmp.R = FLATNESS_PENALTY * kNumBlocks;
814        } else {
815          rd_tmp.R = 0;
816        }
817        SetRDScore(lambda, &rd_tmp);
818        if (best_mode >= 0 && rd_tmp.score >= rd_i4.score) continue;
819        rd_tmp.R += VP8GetCostLuma4(it, tmp_levels);
820        SetRDScore(lambda, &rd_tmp);
821        if (best_mode < 0 || rd_tmp.score < rd_i4.score) {
822          CopyScore(&rd_i4, &rd_tmp);
823          best_mode = mode;
824          SwapPtr(&tmp_dst, &best_block);
825          memcpy(rd_best.y_ac_levels[it->i4_], tmp_levels,
826                 sizeof(rd_best.y_ac_levels[it->i4_]));
827        }
828      }
829      SetRDScore(dqm->lambda_mode_, &rd_i4);
830      AddScore(&rd_best, &rd_i4);
831      if (rd_best.score >= rd->score) {
832        return 0;
833      }
834      total_header_bits += (int)rd_i4.H;   
835      if (total_header_bits > enc->max_i4_header_bits_) {
836        return 0;
837      }
838      if (best_block != best_blocks + VP8Scan[it->i4_]) {
839        VP8Copy4x4(best_block, best_blocks + VP8Scan[it->i4_]);
840      }
841      rd->modes_i4[it->i4_] = best_mode;
842      it->top_nz_[it->i4_ & 3] = it->left_nz_[it->i4_ >> 2] = (rd_i4.nz ? 1 : 0);
843    } while (VP8IteratorRotateI4(it, best_blocks));
844    CopyScore(rd, &rd_best);
845    VP8SetIntra4Mode(it, rd->modes_i4);
846    SwapOut(it);
847    memcpy(rd->y_ac_levels, rd_best.y_ac_levels, sizeof(rd->y_ac_levels));
848    return 1;   
849  }
850  static void PickBestUV(VP8EncIterator* const it, VP8ModeScore* const rd) {
851    const int kNumBlocks = 8;
852    const VP8SegmentInfo* const dqm = &it->enc_->dqm_[it->mb_->segment_];
853    const int lambda = dqm->lambda_uv_;
854    const uint8_t* const src = it->yuv_in_ + U_OFF_ENC;
855    uint8_t* tmp_dst = it->yuv_out2_ + U_OFF_ENC;  
856    uint8_t* dst0 = it->yuv_out_ + U_OFF_ENC;
857    uint8_t* dst = dst0;
858    VP8ModeScore rd_best;
859    int mode;
860    rd->mode_uv = -1;
861    InitScore(&rd_best);
862    for (mode = 0; mode < NUM_PRED_MODES; ++mode) {
863      VP8ModeScore rd_uv;
864      rd_uv.nz = ReconstructUV(it, &rd_uv, tmp_dst, mode);
865      rd_uv.D  = VP8SSE16x8(src, tmp_dst);
866      rd_uv.SD = 0;    
867      rd_uv.H  = VP8FixedCostsUV[mode];
868      rd_uv.R  = VP8GetCostUV(it, &rd_uv);
869      if (mode > 0 && IsFlat(rd_uv.uv_levels[0], kNumBlocks, FLATNESS_LIMIT_UV)) {
870        rd_uv.R += FLATNESS_PENALTY * kNumBlocks;
871      }
872      SetRDScore(lambda, &rd_uv);
873      if (mode == 0 || rd_uv.score < rd_best.score) {
874        CopyScore(&rd_best, &rd_uv);
875        rd->mode_uv = mode;
876        memcpy(rd->uv_levels, rd_uv.uv_levels, sizeof(rd->uv_levels));
877        if (it->top_derr_ != NULL) {
878          memcpy(rd->derr, rd_uv.derr, sizeof(rd_uv.derr));
879        }
880        SwapPtr(&dst, &tmp_dst);
881      }
882    }
883    VP8SetIntraUVMode(it, rd->mode_uv);
884    AddScore(rd, &rd_best);
885    if (dst != dst0) {   
886      VP8Copy16x8(dst, dst0);
887    }
888    if (it->top_derr_ != NULL) {  
889      StoreDiffusionErrors(it, rd);
890    }
891  }
892  static void SimpleQuantize(VP8EncIterator* const it, VP8ModeScore* const rd) {
893    const VP8Encoder* const enc = it->enc_;
894    const int is_i16 = (it->mb_->type_ == 1);
895    int nz = 0;
896    if (is_i16) {
897      nz = ReconstructIntra16(it, rd, it->yuv_out_ + Y_OFF_ENC, it->preds_[0]);
898    } else {
899      VP8IteratorStartI4(it);
900      do {
901        const int mode =
902            it->preds_[(it->i4_ & 3) + (it->i4_ >> 2) * enc->preds_w_];
903        const uint8_t* const src = it->yuv_in_ + Y_OFF_ENC + VP8Scan[it->i4_];
904        uint8_t* const dst = it->yuv_out_ + Y_OFF_ENC + VP8Scan[it->i4_];
905        VP8MakeIntra4Preds(it);
906        nz |= ReconstructIntra4(it, rd->y_ac_levels[it->i4_],
907                                src, dst, mode) << it->i4_;
908      } while (VP8IteratorRotateI4(it, it->yuv_out_ + Y_OFF_ENC));
909    }
910    nz |= ReconstructUV(it, rd, it->yuv_out_ + U_OFF_ENC, it->mb_->uv_mode_);
911    rd->nz = nz;
912  }
913  static void RefineUsingDistortion(VP8EncIterator* const it,
914                                    int try_both_modes, int refine_uv_mode,
915                                    VP8ModeScore* const rd) {
916    score_t best_score = MAX_COST;
917    int nz = 0;
918    int mode;
919    int is_i16 = try_both_modes || (it->mb_->type_ == 1);
920    const VP8SegmentInfo* const dqm = &it->enc_->dqm_[it->mb_->segment_];
921    const int lambda_d_i16 = 106;
922    const int lambda_d_i4 = 11;
923    const int lambda_d_uv = 120;
924    score_t score_i4 = dqm->i4_penalty_;
925    score_t i4_bit_sum = 0;
926    const score_t bit_limit = try_both_modes ? it->enc_->mb_header_limit_
927                                             : MAX_COST;  
928    if (is_i16) {   
929      int best_mode = -1;
930      const uint8_t* const src = it->yuv_in_ + Y_OFF_ENC;
931      for (mode = 0; mode < NUM_PRED_MODES; ++mode) {
932        const uint8_t* const ref = it->yuv_p_ + VP8I16ModeOffsets[mode];
933        const score_t score = (score_t)VP8SSE16x16(src, ref) * RD_DISTO_MULT
934                            + VP8FixedCostsI16[mode] * lambda_d_i16;
935        if (mode > 0 && VP8FixedCostsI16[mode] > bit_limit) {
936          continue;
937        }
938        if (score < best_score) {
939          best_mode = mode;
940          best_score = score;
941        }
942      }
943      if (it->x_ == 0 || it->y_ == 0) {
944        if (IsFlatSource16(src)) {
945          best_mode = (it->x_ == 0) ? 0 : 2;
946          try_both_modes = 0;  
947        }
948      }
949      VP8SetIntra16Mode(it, best_mode);
950    }
951    if (try_both_modes || !is_i16) {
952      is_i16 = 0;
953      VP8IteratorStartI4(it);
954      do {
955        int best_i4_mode = -1;
956        score_t best_i4_score = MAX_COST;
957        const uint8_t* const src = it->yuv_in_ + Y_OFF_ENC + VP8Scan[it->i4_];
958        const uint16_t* const mode_costs = GetCostModeI4(it, rd->modes_i4);
959        VP8MakeIntra4Preds(it);
960        for (mode = 0; mode < NUM_BMODES; ++mode) {
961          const uint8_t* const ref = it->yuv_p_ + VP8I4ModeOffsets[mode];
962          const score_t score = VP8SSE4x4(src, ref) * RD_DISTO_MULT
963                              + mode_costs[mode] * lambda_d_i4;
964          if (score < best_i4_score) {
965            best_i4_mode = mode;
966            best_i4_score = score;
967          }
968        }
969        i4_bit_sum += mode_costs[best_i4_mode];
970        rd->modes_i4[it->i4_] = best_i4_mode;
971        score_i4 += best_i4_score;
972        if (score_i4 >= best_score || i4_bit_sum > bit_limit) {
973          is_i16 = 1;
974          break;
975        } else {  
976          uint8_t* const tmp_dst = it->yuv_out2_ + Y_OFF_ENC + VP8Scan[it->i4_];
977          nz |= ReconstructIntra4(it, rd->y_ac_levels[it->i4_],
978                                  src, tmp_dst, best_i4_mode) << it->i4_;
979        }
980      } while (VP8IteratorRotateI4(it, it->yuv_out2_ + Y_OFF_ENC));
981    }
982    if (!is_i16) {
983      VP8SetIntra4Mode(it, rd->modes_i4);
984      SwapOut(it);
985      best_score = score_i4;
986    } else {
987      nz = ReconstructIntra16(it, rd, it->yuv_out_ + Y_OFF_ENC, it->preds_[0]);
988    }
989    if (refine_uv_mode) {
990      int best_mode = -1;
991      score_t best_uv_score = MAX_COST;
992      const uint8_t* const src = it->yuv_in_ + U_OFF_ENC;
993      for (mode = 0; mode < NUM_PRED_MODES; ++mode) {
994        const uint8_t* const ref = it->yuv_p_ + VP8UVModeOffsets[mode];
995        const score_t score = VP8SSE16x8(src, ref) * RD_DISTO_MULT
996                            + VP8FixedCostsUV[mode] * lambda_d_uv;
997        if (score < best_uv_score) {
998          best_mode = mode;
999          best_uv_score = score;
1000        }
1001      }
1002      VP8SetIntraUVMode(it, best_mode);
1003    }
1004    nz |= ReconstructUV(it, rd, it->yuv_out_ + U_OFF_ENC, it->mb_->uv_mode_);
1005    rd->nz = nz;
1006    rd->score = best_score;
1007  }
1008  int VP8Decimate(VP8EncIterator* const it, VP8ModeScore* const rd,
1009                  VP8RDLevel rd_opt) {
1010    int is_skipped;
1011    const int method = it->enc_->method_;
1012    InitScore(rd);
1013    VP8MakeLuma16Preds(it);
1014    VP8MakeChroma8Preds(it);
1015    if (rd_opt > RD_OPT_NONE) {
1016      it->do_trellis_ = (rd_opt >= RD_OPT_TRELLIS_ALL);
1017      PickBestIntra16(it, rd);
1018      if (method >= 2) {
1019        PickBestIntra4(it, rd);
1020      }
1021      PickBestUV(it, rd);
1022      if (rd_opt == RD_OPT_TRELLIS) {   
1023        it->do_trellis_ = 1;
1024        SimpleQuantize(it, rd);
1025      }
1026    } else {
1027      RefineUsingDistortion(it, (method >= 2), (method >= 1), rd);
1028    }
1029    is_skipped = (rd->nz == 0);
1030    VP8SetSkip(it, is_skipped);
1031    return is_skipped;
1032  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-avcodec.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-quant_enc.c</div>
                <div class="column column_space"><pre><code>516      AV_AUDIO_SERVICE_TYPE_MAIN              = 0,
517      AV_AUDIO_SERVICE_TYPE_EFFECTS           = 1,
518      AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2,
519      AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED  = 3,
520      AV_AUDIO_SERVICE_TYPE_DIALOGUE          = 4,
521      AV_AUDIO_SERVICE_TYPE_COMMENTARY        = 5,
522      AV_AUDIO_SERVICE_TYPE_EMERGENCY         = 6,
523      AV_AUDIO_SERVICE_TYPE_VOICE_OVER        = 7,
524      AV_AUDIO_SERVICE_TYPE_KARAOKE           = 8,
525      AV_AUDIO_SERVICE_TYPE_NB                   , 
526  };
</pre></code></div>
                <div class="column column_space"><pre><code>638      c[1][0] += (C1 * top[1] + C2 * err0) >> (DSHIFT - DSCALE);
639      err1 = QuantizeSingle(&c[1][0], mtx);
640      c[2][0] += (C1 * err0 + C2 * left[1]) >> (DSHIFT - DSCALE);
641      err2 = QuantizeSingle(&c[2][0], mtx);
642      c[3][0] += (C1 * err1 + C2 * err2) >> (DSHIFT - DSCALE);
643      err3 = QuantizeSingle(&c[3][0], mtx);
644      assert(abs(err1) <= 127 && abs(err2) <= 127 && abs(err3) <= 127);
645      rd->derr[ch][0] = (int8_t)err1;
646      rd->derr[ch][1] = (int8_t)err2;
647      rd->derr[ch][2] = (int8_t)err3;
648    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    