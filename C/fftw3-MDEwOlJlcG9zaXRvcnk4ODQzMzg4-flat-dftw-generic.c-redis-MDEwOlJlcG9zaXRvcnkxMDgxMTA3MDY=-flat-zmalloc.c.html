
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.830022075055188%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dftw-generic.c</h3>
            <pre><code>1  #include "dft/ct.h"
2  typedef ct_solver S;
3  typedef struct {
4       plan_dftw super;
5       INT r, rs, m, mb, me, ms, v, vs;
6       plan *cld;
7       twid *td;
8       const S *slv;
9       int dec;
10  } P;
11  static void mktwiddle(P *ego, enum wakefulness wakefulness)
12  {
13       static const tw_instr tw[] = { { TW_FULL, 0, 0 }, { TW_NEXT, 1, 0 } };
14       X(twiddle_awake)(wakefulness, &ego->td, tw,
15  		      ego->r * ego->m, ego->m, ego->r);
16  }
17  static void bytwiddle(const P *ego, R *rio, R *iio)
18  {
19       INT iv, ir, im;
20       INT r = ego->r, rs = ego->rs;
21       INT m = ego->m, mb = ego->mb, me = ego->me, ms = ego->ms;
22       INT v = ego->v, vs = ego->vs;
23       const R *W = ego->td->W;
24       mb += (mb == 0); &bsol;* skip m=0 iteration */
25       for (iv = 0; iv < v; ++iv) {
26  	  for (ir = 1; ir < r; ++ir) {
27  	       for (im = mb; im < me; ++im) {
<span onclick='openModal()' class='match'>28  		    R *pr = rio + ms * im + rs * ir;
29  		    R *pi = iio + ms * im + rs * ir;
30  		    E xr = *pr;
31  		    E xi = *pi;
32  		    E wr = W[2 * im + (2 * (m-1)) * ir - 2];
33  		    E wi = W[2 * im + (2 * (m-1)) * ir - 1];
34  		    *pr = xr * wr + xi * wi;
35  		    *pi = xi * wr - xr * wi;
</span>36  	       }
37  	  }
38  	  rio += vs;
39  	  iio += vs;
40       }
41  }
42  static int applicable(INT irs, INT ors, INT ivs, INT ovs,
43  		      const planner *plnr)
44  {
45       return (1
46  	     && irs == ors
47  	     && ivs == ovs
48  	     && !NO_SLOWP(plnr)
49  	  );
50  }
51  static void apply_dit(const plan *ego_, R *rio, R *iio)
52  {
53       const P *ego = (const P *) ego_;
54       plan_dft *cld;
55       INT dm = ego->ms * ego->mb;
56       bytwiddle(ego, rio, iio);
57       cld = (plan_dft *) ego->cld;
58       cld->apply(ego->cld, rio + dm, iio + dm, rio + dm, iio + dm);
59  }
60  static void apply_dif(const plan *ego_, R *rio, R *iio)
61  {
62       const P *ego = (const P *) ego_;
63       plan_dft *cld;
64       INT dm = ego->ms * ego->mb;
65       cld = (plan_dft *) ego->cld;
66       cld->apply(ego->cld, rio + dm, iio + dm, rio + dm, iio + dm);
67       bytwiddle(ego, rio, iio);
68  }
69  static void awake(plan *ego_, enum wakefulness wakefulness)
70  {
71       P *ego = (P *) ego_;
72       X(plan_awake)(ego->cld, wakefulness);
73       mktwiddle(ego, wakefulness);
74  }
75  static void destroy(plan *ego_)
76  {
77       P *ego = (P *) ego_;
78       X(plan_destroy_internal)(ego->cld);
79  }
80  static void print(const plan *ego_, printer *p)
81  {
82       const P *ego = (const P *) ego_;
83       p->print(p, "(dftw-generic-%s-%D-%D%v%(%p%))",
84  	      ego->dec == DECDIT ? "dit" : "dif",
85  	      ego->r, ego->m, ego->v, ego->cld);
86  }
87  static plan *mkcldw(const ct_solver *ego_,
88  		    INT r, INT irs, INT ors,
89  		    INT m, INT ms,
90  		    INT v, INT ivs, INT ovs,
91  		    INT mstart, INT mcount,
92  		    R *rio, R *iio,
93  		    planner *plnr)
94  {
95       const S *ego = (const S *)ego_;
96       P *pln;
97       plan *cld = 0;
98       INT dm = ms * mstart;
99       static const plan_adt padt = {
100  	  0, awake, print, destroy
101       };
102       A(mstart >= 0 && mstart + mcount <= m);
103       if (!applicable(irs, ors, ivs, ovs, plnr))
104            return (plan *)0;
105       cld = X(mkplan_d)(plnr,
106  			X(mkproblem_dft_d)(
107  			     X(mktensor_1d)(r, irs, irs),
108  			     X(mktensor_2d)(mcount, ms, ms, v, ivs, ivs),
109  			     rio + dm, iio + dm, rio + dm, iio + dm)
110  			);
111       if (!cld) goto nada;
112       pln = MKPLAN_DFTW(P, &padt, ego->dec == DECDIT ? apply_dit : apply_dif);
113       pln->slv = ego;
114       pln->cld = cld;
115       pln->r = r;
116       pln->rs = irs;
117       pln->m = m;
118       pln->ms = ms;
119       pln->v = v;
120       pln->vs = ivs;
121       pln->mb = mstart;
122       pln->me = mstart + mcount;
123       pln->dec = ego->dec;
124       pln->td = 0;
125       {
126  	  double n0 = (r - 1) * (mcount - 1) * v;
127  	  pln->super.super.ops = cld->ops;
128  	  pln->super.super.ops.mul += 8 * n0;
129  	  pln->super.super.ops.add += 4 * n0;
130  	  pln->super.super.ops.other += 8 * n0;
131       }
132       return &(pln->super.super);
133   nada:
134       X(plan_destroy_internal)(cld);
135       return (plan *) 0;
136  }
137  static void regsolver(planner *plnr, INT r, int dec)
138  {
139       S *slv = (S *)X(mksolver_ct)(sizeof(S), r, dec, mkcldw, 0);
140       REGISTER_SOLVER(plnr, &(slv->super));
141       if (X(mksolver_ct_hook)) {
142  	  slv = (S *)X(mksolver_ct_hook)(sizeof(S), r, dec, mkcldw, 0);
143  	  REGISTER_SOLVER(plnr, &(slv->super));
144       }
145  }
146  void X(ct_generic_register)(planner *p)
147  {
148       regsolver(p, 0, DECDIT);
149       regsolver(p, 0, DECDIF);
150  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-zmalloc.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/Win32_Portability.h"
3  #include "Win32_Interop/win32_types.h"
4  #include "Win32_Interop/win32fixes.h"
5  #include "Win32_Interop/Win32_QFork.h"
6  #include "Win32_Interop/Win32_PThread.h"
7  #endif
8  #include <stdio.h>
9  #include <stdlib.h>
10  #include <stdint.h>
11  void zlibc_free(void *ptr) {
12      free(ptr);
13  }
14  #include <string.h>
15  POSIX_ONLY(#include <pthread.h>)
16  #include "config.h"
17  #include "zmalloc.h"
18  #include "atomicvar.h"
19  #ifdef HAVE_MALLOC_SIZE
20  #define PREFIX_SIZE (0)
21  #else
22  #if defined(__sun) || defined(__sparc) || defined(__sparc__)
23  #define PREFIX_SIZE (sizeof(PORT_LONGLONG))
24  #else
25  #define PREFIX_SIZE (sizeof(size_t))
26  #endif
27  #endif
28  #if defined(USE_TCMALLOC)
29  #define malloc(size) tc_malloc(size)
30  #define calloc(count,size) tc_calloc(count,size)
31  #define realloc(ptr,size) tc_realloc(ptr,size)
32  #define free(ptr) tc_free(ptr)
33  #elif defined(USE_JEMALLOC)
34  #define malloc(size) je_malloc(size)
35  #define calloc(count,size) je_calloc(count,size)
36  #define realloc(ptr,size) je_realloc(ptr,size)
37  #define free(ptr) je_free(ptr)
38  #define mallocx(size,flags) je_mallocx(size,flags)
39  #define dallocx(ptr,flags) je_dallocx(ptr,flags)
40  #endif
41  #define update_zmalloc_stat_alloc(__n) do { \
42      size_t _n = (__n); \
43      if (_n&(sizeof(PORT_LONG)-1)) _n += sizeof(PORT_LONG)-(_n&(sizeof(PORT_LONG)-1)); \
44      atomicIncr(used_memory,__n); \
45  } while(0)
46  #define update_zmalloc_stat_free(__n) do { \
47      size_t _n = (__n); \
48      if (_n&(sizeof(PORT_LONG)-1)) _n += sizeof(PORT_LONG)-(_n&(sizeof(PORT_LONG)-1)); \
49      atomicDecr(used_memory,__n); \
50  } while(0)
51  static size_t used_memory = 0;
52  #ifdef _WIN32
53  pthread_mutex_t used_memory_mutex;
54  #else
55  pthread_mutex_t used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;
56  #endif
57  static void zmalloc_default_oom(size_t size) {
58      fprintf(stderr, "zmalloc: Out of memory trying to allocate %Iu bytes\n",    WIN_PORT_FIX &bsol;* %zu -> %Iu */
59          size);
60      fflush(stderr);
61      abort();
62  }
63  static void (*zmalloc_oom_handler)(size_t) = zmalloc_default_oom;
64  void *zmalloc(size_t size) {
65      void *ptr = malloc(size+PREFIX_SIZE);
66      if (!ptr) zmalloc_oom_handler(size);
67  #ifdef HAVE_MALLOC_SIZE
68      update_zmalloc_stat_alloc(zmalloc_size(ptr));
69      return ptr;
70  #else
71      *((size_t*)ptr) = size;
72      update_zmalloc_stat_alloc(size+PREFIX_SIZE);
73      return (char*)ptr+PREFIX_SIZE;
74  #endif
75  }
76  #ifdef HAVE_DEFRAG
77  void *zmalloc_no_tcache(size_t size) {
78      void *ptr = mallocx(size+PREFIX_SIZE, MALLOCX_TCACHE_NONE);
79      if (!ptr) zmalloc_oom_handler(size);
80      update_zmalloc_stat_alloc(zmalloc_size(ptr));
81      return ptr;
82  }
83  void zfree_no_tcache(void *ptr) {
84      if (ptr == NULL) return;
85      update_zmalloc_stat_free(zmalloc_size(ptr));
86      dallocx(ptr, MALLOCX_TCACHE_NONE);
87  }
88  #endif
89  void *zcalloc(size_t size) {
90      void *ptr = calloc(1, size+PREFIX_SIZE);
91      if (!ptr) zmalloc_oom_handler(size);
92  #ifdef HAVE_MALLOC_SIZE
93      update_zmalloc_stat_alloc(zmalloc_size(ptr));
94      return ptr;
95  #else
96      *((size_t*)ptr) = size;
97      update_zmalloc_stat_alloc(size+PREFIX_SIZE);
98      return (char*)ptr+PREFIX_SIZE;
99  #endif
100  }
101  void *zrealloc(void *ptr, size_t size) {
102  #ifndef HAVE_MALLOC_SIZE
103      void *realptr;
104  #endif
105      size_t oldsize;
106      void *newptr;
107      if (ptr == NULL) return zmalloc(size);
108  #ifdef HAVE_MALLOC_SIZE
109      oldsize = zmalloc_size(ptr);
110      newptr = realloc(ptr,size);
111      if (!newptr) zmalloc_oom_handler(size);
112      update_zmalloc_stat_free(oldsize);
113      update_zmalloc_stat_alloc(zmalloc_size(newptr));
114      return newptr;
115  #else
116      realptr = (char*)ptr-PREFIX_SIZE;
117      oldsize = *((size_t*)realptr);
118      newptr = realloc(realptr,size+PREFIX_SIZE);
119      if (!newptr) zmalloc_oom_handler(size);
120      *((size_t*)newptr) = size;
121      update_zmalloc_stat_free(oldsize+PREFIX_SIZE);
122      update_zmalloc_stat_alloc(size+PREFIX_SIZE);
123      return (char*)newptr+PREFIX_SIZE;
124  #endif
125  }
126  #ifndef HAVE_MALLOC_SIZE
127  size_t zmalloc_size(void *ptr) {
128      void *realptr = (char*)ptr-PREFIX_SIZE;
129      size_t size = *((size_t*)realptr);
130      return size+PREFIX_SIZE;
131  }
132  size_t zmalloc_usable(void *ptr) {
133      return zmalloc_size(ptr)-PREFIX_SIZE;
134  }
135  #endif
136  void zfree(void *ptr) {
137  #ifndef HAVE_MALLOC_SIZE
138      void *realptr;
139      size_t oldsize;
140  #endif
141      if (ptr == NULL) return;
142  #ifdef HAVE_MALLOC_SIZE
143      update_zmalloc_stat_free(zmalloc_size(ptr));
144      free(ptr);
145  #else
146      realptr = (char*)ptr-PREFIX_SIZE;
147      oldsize = *((size_t*)realptr);
148      update_zmalloc_stat_free(oldsize+PREFIX_SIZE);
149      free(realptr);
150  #endif
151  }
152  char *zstrdup(const char *s) {
153      size_t l = strlen(s)+1;
154      char *p = zmalloc(l);
155      memcpy(p,s,l);
156      return p;
157  }
158  size_t zmalloc_used_memory(void) {
159      size_t um;
160      atomicGet(used_memory,um);
161      return um;
162  }
163  void zmalloc_set_oom_handler(void (*oom_handler)(size_t)) {
164      zmalloc_oom_handler = oom_handler;
165  }
166  #if defined(HAVE_PROC_STAT)
167  #include <unistd.h>
168  #include <sys/types.h>
169  #include <sys/stat.h>
170  #include <fcntl.h>
171  size_t zmalloc_get_rss(void) {
172      int page = sysconf(_SC_PAGESIZE);
173      size_t rss;
174      char buf[4096];
175      char filename[256];
176      int fd, count;
177      char *p, *x;
178      snprintf(filename,256,"/proc/%d/stat",getpid());
179      if ((fd = open(filename,O_RDONLY)) == -1) return 0;
180      if (read(fd,buf,4096) <= 0) {
181          close(fd);
182          return 0;
183      }
184      close(fd);
185      p = buf;
186      count = 23; &bsol;* RSS is the 24th field in /proc/<pid>/stat */
187      while(p && count--) {
188          p = strchr(p,' ');
189          if (p) p++;
190      }
191      if (!p) return 0;
192      x = strchr(p,' ');
193      if (!x) return 0;
194      *x = '\0';
195      rss = strtoll(p,NULL,10);
196      rss *= page;
197      return rss;
198  }
199  #elif defined(HAVE_TASKINFO)
200  #include <unistd.h>
201  #include <stdio.h>
202  #include <stdlib.h>
203  #include <sys/types.h>
204  #include <sys/sysctl.h>
205  #include <mach/task.h>
206  #include <mach/mach_init.h>
207  size_t zmalloc_get_rss(void) {
208      task_t task = MACH_PORT_NULL;
209      struct task_basic_info t_info;
210      mach_msg_type_number_t t_info_count = TASK_BASIC_INFO_COUNT;
211      if (task_for_pid(current_task(), getpid(), &task) != KERN_SUCCESS)
212          return 0;
213      task_info(task, TASK_BASIC_INFO, (task_info_t)&t_info, &t_info_count);
214      return t_info.resident_size;
215  }
216  #else
217  size_t zmalloc_get_rss(void) {
218      return zmalloc_used_memory();
219  }
220  #endif
221  #if defined(USE_JEMALLOC)
222  int zmalloc_get_allocator_info(size_t *allocated,
223                                 size_t *active,
224                                 size_t *resident) {
225      uint64_t epoch = 1;
226      size_t sz;
227      *allocated = *resident = *active = 0;
228      sz = sizeof(epoch);
229      je_mallctl("epoch", &epoch, &sz, &epoch, sz);
230      sz = sizeof(size_t);
231      je_mallctl("stats.resident", resident, &sz, NULL, 0);
232      je_mallctl("stats.active", active, &sz, NULL, 0);
233      je_mallctl("stats.allocated", allocated, &sz, NULL, 0);
234      return 1;
235  }
236  void set_jemalloc_bg_thread(int enable) {
237      char val = !!enable;
238      je_mallctl("background_thread", NULL, 0, &val, 1);
239  }
240  #else
241  int zmalloc_get_allocator_info(size_t *allocated,
242                                 size_t *active,
243                                 size_t *resident) {
244      *allocated = *resident = *active = 0;
245      return 1;
246  }
247  #endif
248  #if defined(HAVE_PROC_SMAPS)
249  size_t zmalloc_get_smap_bytes_by_field(char *field, long pid) {
250      char line[1024];
251      size_t bytes = 0;
252      int flen = strlen(field);
253      FILE *fp;
254      if (pid == -1) {
255          fp = fopen("/proc/self/smaps","r");
256      } else {
257          char filename[128];
258          snprintf(filename,sizeof(filename),"/proc/%ld/smaps",pid);
259          fp = fopen(filename,"r");
260      }
261      if (!fp) return 0;
262      while(fgets(line,sizeof(line),fp) != NULL) {
263          if (strncmp(line,field,flen) == 0) {
264              char *p = strchr(line,'k');
265              if (p) {
266                  *p = '\0';
267                  bytes += strtol(line+flen,NULL,10) * 1024;
268              }
269          }
270      }
271      fclose(fp);
272      return bytes;
273  }
274  #else
275  size_t zmalloc_get_smap_bytes_by_field(char *field, PORT_LONG pid) {
276      ((void) field);
277      ((void) pid);
278      return 0;
279  }
280  #endif
281  size_t zmalloc_get_private_dirty(PORT_LONG pid) {
282      return zmalloc_get_smap_bytes_by_field("Private_Dirty:",pid);
283  }
284  size_t zmalloc_get_memory_size(void) {
285  #if defined(__unix__) || defined(__unix) || defined(unix) || \
286      (defined(__APPLE__) && defined(__MACH__))
287  #if defined(CTL_HW) && (defined(HW_MEMSIZE) || defined(HW_PHYSMEM64))
288      int mib[2];
289      mib[0] = CTL_HW;
290  #if defined(HW_MEMSIZE)
291      mib[1] = HW_MEMSIZE;            &bsol;* OSX. --------------------- */
292  #elif defined(HW_PHYSMEM64)
293      mib[1] = HW_PHYSMEM64;          &bsol;* NetBSD, OpenBSD. --------- */
294  #endif
295      int64_t size = 0;               &bsol;* 64-bit */
296      size_t len = sizeof(size);
297      if (sysctl( mib, 2, &size, &len, NULL, 0) == 0)
298          return (size_t)size;
299      return 0L;          &bsol;* Failed? */
300  #elif defined(_SC_PHYS_PAGES) && defined(_SC_PAGESIZE)
301      return (size_t)sysconf(_SC_PHYS_PAGES) * (size_t)sysconf(_SC_PAGESIZE);
302  #elif defined(CTL_HW) && (defined(HW_PHYSMEM) || defined(HW_REALMEM))
303      int mib[2];
<span onclick='openModal()' class='match'>304      mib[0] = CTL_HW;
305  #if defined(HW_REALMEM)
306      mib[1] = HW_REALMEM;        &bsol;* FreeBSD. ----------------- */
</span>307  #elif defined(HW_PHYSMEM)
308      mib[1] = HW_PHYSMEM;        &bsol;* Others. ------------------ */
309  #endif
310      unsigned int size = 0;      &bsol;* 32-bit */
311      size_t len = sizeof(size);
312      if (sysctl(mib, 2, &size, &len, NULL, 0) == 0)
313          return (size_t)size;
314      return 0L;          &bsol;* Failed? */
315  #else
316      return 0L;          &bsol;* Unknown method to get the data. */
317  #endif
318  #else
319      return 0L;          &bsol;* Unknown OS. */
320  #endif
321  }
322  #ifdef REDIS_TEST
323  #define UNUSED(x) ((void)(x))
324  int zmalloc_test(int argc, char **argv) {
325      void *ptr;
326      UNUSED(argc);
327      UNUSED(argv);
328      printf("Initial used memory: %zu\n", zmalloc_used_memory());
329      ptr = zmalloc(123);
330      printf("Allocated 123 bytes; used: %zu\n", zmalloc_used_memory());
331      ptr = zrealloc(ptr, 456);
332      printf("Reallocated to 456 bytes; used: %zu\n", zmalloc_used_memory());
333      zfree(ptr);
334      printf("Freed pointer; used: %zu\n", zmalloc_used_memory());
335      return 0;
336  }
337  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dftw-generic.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-zmalloc.c</div>
                </div>
                <div class="column column_space"><pre><code>28  		    R *pr = rio + ms * im + rs * ir;
29  		    R *pi = iio + ms * im + rs * ir;
30  		    E xr = *pr;
31  		    E xi = *pi;
32  		    E wr = W[2 * im + (2 * (m-1)) * ir - 2];
33  		    E wi = W[2 * im + (2 * (m-1)) * ir - 1];
34  		    *pr = xr * wr + xi * wi;
35  		    *pi = xi * wr - xr * wi;
</pre></code></div>
                <div class="column column_space"><pre><code>304      mib[0] = CTL_HW;
305  #if defined(HW_REALMEM)
306      mib[1] = HW_REALMEM;        &bsol;* FreeBSD. ----------------- */
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    