<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for avg.c &amp; heifload.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for avg.c &amp; heifload.c
      </h3>
<h1 align="center">
        4.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>avg.c (15.384615%)<th>heifload.c (2.9761906%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(192-211)<td><a href="#" name="0">(941-960)</a><td align="center"><font color="#ff0000">20</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>avg.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;math.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/internal.h&gt;
9 #include "statistic.h"
10 typedef struct _VipsAvg {
11 	VipsStatistic parent_instance;
12 	double sum;
13 	double out;
14 } VipsAvg;
15 typedef VipsStatisticClass VipsAvgClass;
16 G_DEFINE_TYPE( VipsAvg, vips_avg, VIPS_TYPE_STATISTIC );
17 static int
18 vips_avg_build( VipsObject *object )
19 {
20 	VipsStatistic *statistic = VIPS_STATISTIC( object ); 
21 	VipsAvg *avg = (VipsAvg *) object;
22 	gint64 vals;
23 	double average;
24 	if( VIPS_OBJECT_CLASS( vips_avg_parent_class )-&gt;build( object ) )
25 		return( -1 );
26 	vals = (gint64) 
27 		vips_image_get_width( statistic-&gt;in ) * 
28 		vips_image_get_height( statistic-&gt;in ) * 
29 		vips_image_get_bands( statistic-&gt;in );
30 	average = avg-&gt;sum / vals;
31 	g_object_set( object, "out", average, NULL );
32 	return( 0 );
33 }
34 static void *
35 vips_avg_start( VipsStatistic *statistic )
36 {
37 	return( (void *) g_new0( double, 1 ) );
38 }
39 static int
40 vips_avg_stop( VipsStatistic *statistic, void *seq )
41 {
42 	VipsAvg *avg = (VipsAvg *) statistic;
43 	double *sum = (double *) seq;
44 	avg-&gt;sum += *sum;
45 	g_free( seq );
46 	return( 0 );
47 }
48 #define LOOP( TYPE ) { \
49 	TYPE *p = (TYPE *) in; \
50 	\
51 	for( i = 0; i &lt; sz; i++ ) \
52 		m += p[i]; \
53 }
54 #define CLOOP( TYPE ) { \
55 	TYPE *p = (TYPE *) in; \
56 	\
57 	for( i = 0; i &lt; sz; i++ ) { \
58 		double mod = sqrt( p[0] * p[0] + p[1] * p[1] ); \
59 		\
60 		m += mod; \
61 		p += 2; \
62 	} \
63 } 
64 static int
65 vips_avg_scan( VipsStatistic *statistic, void *seq, 
66 	int x, int y, void *in, int n )
67 {
68 	const int sz = n * vips_image_get_bands( statistic-&gt;in );
69 	double *sum = (double *) seq;
70 	int i;
71 	double m;
72 	m = *sum;
73 	switch( vips_image_get_format( statistic-&gt;in ) ) {
74 	case VIPS_FORMAT_UCHAR:		LOOP( unsigned char ); break; 
75 	case VIPS_FORMAT_CHAR:		LOOP( signed char ); break; 
76 	case VIPS_FORMAT_USHORT:	LOOP( unsigned short ); break; 
77 	case VIPS_FORMAT_SHORT:		LOOP( signed short ); break; 
78 	case VIPS_FORMAT_UINT:		LOOP( unsigned int ); break;
79 	case VIPS_FORMAT_INT:		LOOP( signed int ); break; 
80 	case VIPS_FORMAT_FLOAT:		LOOP( float ); break; 
81 	case VIPS_FORMAT_DOUBLE:	LOOP( double ); break; 
82 	case VIPS_FORMAT_COMPLEX:	CLOOP( float ); break; 
83 	case VIPS_FORMAT_DPCOMPLEX:	CLOOP( double ); break; 
84 	default: 
85 		g_assert_not_reached();
86 	}
87 <a name="0"></a>
88 	*sum = m;
89 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( 0 );
90 }
91 static void
92 vips_avg_class_init( VipsAvgClass *class )
93 {
94 	GObjectClass *gobject_class = (GObjectClass *) class;
95 	VipsObjectClass *object_class = (VipsObjectClass *) class;
96 	VipsStatisticClass *sclass = VIPS_STATISTIC_CLASS( class );
97 	gobject_class-&gt;set_property = vips_object_set_property;
98 	gobject_class-&gt;get_property = vips_object_get_property;
99 	object_class-&gt;nickname = "avg";
100 	object_class-&gt;description = _( "find image average" );
101 	object_class-&gt;build = vips_avg_build;
102 	sclass-&gt;start = vips_avg_start;
103 	sclass-&gt;scan = vips_avg_scan;
104 	sclass-&gt;stop = vips_avg_stop;</b></font>
105 	VIPS_ARG_DOUBLE( class, "out", 2, 
106 		_( "Output" ), 
107 		_( "Output value" ),
108 		VIPS_ARGUMENT_REQUIRED_OUTPUT,
109 		G_STRUCT_OFFSET( VipsAvg, out ),
110 		-INFINITY, INFINITY, 0.0 );
111 }
112 static void
113 vips_avg_init( VipsAvg *avg )
114 {
115 }
116 int
117 vips_avg( VipsImage *in, double *out, ... )
118 {
119 	va_list ap;
120 	int result;
121 	va_start( ap, out );
122 	result = vips_call_split( "avg", ap, in, out );
123 	va_end( ap );
124 	return( result );
125 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>heifload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/debug.h&gt;
9 #include &lt;vips/internal.h&gt;
10 #if defined(HAVE_HEIF_DECODER) || defined(HAVE_HEIF_ENCODER)
11 #include "pforeign.h"
12 const char *vips__heif_suffs[] = { 
13 	".heic",
14 	".heif",
15 	".avif",
16 	NULL 
17 };
18 #ifdef HAVE_HEIF_DECODER
19 #include &lt;libheif/heif.h&gt;
20 #define VIPS_TYPE_FOREIGN_LOAD_HEIF (vips_foreign_load_heif_get_type())
21 #define VIPS_FOREIGN_LOAD_HEIF( obj ) \
22 	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
23 	VIPS_TYPE_FOREIGN_LOAD_HEIF, VipsForeignLoadHeif ))
24 #define VIPS_FOREIGN_LOAD_HEIF_CLASS( klass ) \
25 	(G_TYPE_CHECK_CLASS_CAST( (klass), \
26 	VIPS_TYPE_FOREIGN_LOAD_HEIF, VipsForeignLoadHeifClass))
27 #define VIPS_IS_FOREIGN_LOAD_HEIF( obj ) \
28 	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_FOREIGN_LOAD_HEIF ))
29 #define VIPS_IS_FOREIGN_LOAD_HEIF_CLASS( klass ) \
30 	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_FOREIGN_LOAD_HEIF ))
31 #define VIPS_FOREIGN_LOAD_HEIF_GET_CLASS( obj ) \
32 	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
33 	VIPS_TYPE_FOREIGN_LOAD_HEIF, VipsForeignLoadHeifClass ))
34 typedef struct _VipsForeignLoadHeif {
35 	VipsForeignLoad parent_object;
36 	int page;
37 	int n;
38 	gboolean thumbnail;
39 	gboolean autorotate;
40 	struct heif_context *ctx;
41 	int n_top;
42 	gboolean has_alpha;
43 	int width;
44 	int height;
45 	int page_width;
46 	int page_height;
47 	int page_no;
48 	gboolean thumbnail_set;
49 	int primary_page;
50 	heif_item_id *id;
51 	struct heif_image_handle *handle;
52 	struct heif_image *img;
53 	int stride;
54 	const uint8_t *data;
55 	VipsSource *source;
56 	struct heif_reader *reader;
57 } VipsForeignLoadHeif;
58 void
59 vips__heif_error( struct heif_error *error )
60 {
61 	if( error-&gt;code ) 
62 		vips_error( "heif", "%s (%d.%d)", error-&gt;message, error-&gt;code,
63 			error-&gt;subcode );
64 }
65 typedef struct _VipsForeignLoadHeifClass {
66 	VipsForeignLoadClass parent_class;
67 } VipsForeignLoadHeifClass;
68 G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadHeif, vips_foreign_load_heif, 
69 	VIPS_TYPE_FOREIGN_LOAD );
70 static void
71 vips_foreign_load_heif_dispose( GObject *gobject )
72 {
73 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) gobject;
74 	heif-&gt;data = NULL;
75 	VIPS_FREEF( heif_image_release, heif-&gt;img );
76 	VIPS_FREEF( heif_image_handle_release, heif-&gt;handle );
77 	VIPS_FREEF( heif_context_free, heif-&gt;ctx );
78 	VIPS_FREE( heif-&gt;id );
79 	VIPS_FREE( heif-&gt;reader );
80 	VIPS_UNREF( heif-&gt;source );
81 	G_OBJECT_CLASS( vips_foreign_load_heif_parent_class )-&gt;
82 		dispose( gobject );
83 }
84 static int
85 vips_foreign_load_heif_build( VipsObject *object )
86 {
87 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) object;
88 #ifdef DEBUG
89 	printf( "vips_foreign_load_heif_build:\n" );
90 	if( heif-&gt;source &amp;&amp;
91 		vips_source_rewind( heif-&gt;source ) )
92 		return( -1 );
93 	if( !heif-&gt;ctx ) {
94 		struct heif_error error;
95 		heif-&gt;ctx = heif_context_alloc();
96 		error = heif_context_read_from_reader( heif-&gt;ctx, 
97 			heif-&gt;reader, heif, NULL );
98 		if( error.code ) {
99 			vips__heif_error( &amp;error );
100 			return( -1 );
101 		}
102 	}
103 	if( VIPS_OBJECT_CLASS( vips_foreign_load_heif_parent_class )-&gt;
104 		build( object ) )
105 		return( -1 );
106 	return( 0 );
107 }
108 static const char *heif_magic[] = {
109 	"ftypheic",		"ftypheix",		"ftyphevc",		"ftypheim",		"ftypheis",		"ftyphevm",		"ftyphevs",		"ftypmif1",		"ftypmsf1",		"ftypavif"	};
110 static int
111 vips_foreign_load_heif_is_a( const char *buf, int len )
112 {
113 	if( len &gt;= 12 ) {
114 		const guint32 chunk_len = 
115 			(guint32) buf[0] &lt;&lt; 24 |
116 			(guint32) buf[1] &lt;&lt; 16 |
117 			(guint32) buf[2] &lt;&lt; 8 |
118 			(guint32) buf[3];
119 		int i;
120 		if( chunk_len &gt; 64 || 
121 			chunk_len % 4 != 0 )
122 			return( 0 );
123 		for( i = 0; i &lt; VIPS_NUMBER( heif_magic ); i++ )
124 			if( strncmp( buf + 4, heif_magic[i], 8 ) == 0 )
125 				return( 1 );
126 	}
127 	return( 0 );
128 }
129 static VipsForeignFlags
130 vips_foreign_load_heif_get_flags( VipsForeignLoad *load )
131 {
132 	return( VIPS_FOREIGN_SEQUENTIAL );
133 }
134 static int
135 vips_foreign_load_heif_set_thumbnail( VipsForeignLoadHeif *heif )
136 {
137 	heif_item_id thumb_ids[1];
138 	int n_thumbs;
139 	struct heif_image_handle *thumb_handle;
140 	struct heif_image *thumb_img;
141 	struct heif_error error;
142 	double main_aspect;
143 	double thumb_aspect;
144 #ifdef DEBUG
145 	printf( "vips_foreign_load_heif_set_thumbnail:\n" );
146 	n_thumbs = heif_image_handle_get_list_of_thumbnail_IDs( 
147 		heif-&gt;handle, thumb_ids, 1 );
148 	if( n_thumbs == 0 )
149 		return( 0 );
150 	error = heif_image_handle_get_thumbnail( heif-&gt;handle,
151 		thumb_ids[0], &amp;thumb_handle );
152 	if( error.code ) {
153 		vips__heif_error( &amp;error );
154 		return( -1 );
155 	}
156 	error = heif_decode_image( thumb_handle, &amp;thumb_img,
157 		heif_colorspace_RGB, 
158 		heif_chroma_interleaved_RGB,
159 		NULL );
160 	if( error.code ) {
161 		VIPS_FREEF( heif_image_handle_release, thumb_handle );
162 		vips__heif_error( &amp;error );
163 		return( -1 );
164 	}
165 	thumb_aspect = (double) 
166 		heif_image_get_width( thumb_img, heif_channel_interleaved ) /
167 		heif_image_get_height( thumb_img, heif_channel_interleaved );
168 	VIPS_FREEF( heif_image_release, thumb_img );
169 	main_aspect = (double) 
170 		heif_image_handle_get_width( heif-&gt;handle ) /
171 		heif_image_handle_get_height( heif-&gt;handle );
172 	if( fabs( main_aspect - thumb_aspect ) &gt; 0.1 ) {
173 		VIPS_FREEF( heif_image_handle_release, thumb_handle );
174 		return( 0 );
175 	}
176 	VIPS_FREEF( heif_image_handle_release, heif-&gt;handle );
177 	heif-&gt;handle = thumb_handle;
178 	return( 0 );
179 }
180 static int
181 vips_foreign_load_heif_set_page( VipsForeignLoadHeif *heif, 
182 	int page_no, gboolean thumbnail )
183 {
184 	if( !heif-&gt;handle ||
185 		page_no != heif-&gt;page_no ||
186 		thumbnail != heif-&gt;thumbnail_set ) {
187 		struct heif_error error;
188 #ifdef DEBUG
189 		printf( "vips_foreign_load_heif_set_page: %d, thumbnail = %d\n",
190 			page_no, thumbnail );
191 		VIPS_FREEF( heif_image_handle_release, heif-&gt;handle );
192 		VIPS_FREEF( heif_image_release, heif-&gt;img );
193 		heif-&gt;data = NULL;
194 		heif-&gt;thumbnail_set = FALSE;
195 		error = heif_context_get_image_handle( heif-&gt;ctx, 
196 			heif-&gt;id[page_no], &amp;heif-&gt;handle );
197 		if( error.code ) {
198 			vips__heif_error( &amp;error );
199 			return( -1 );
200 		}
201 		if( thumbnail ) {
202 			if( vips_foreign_load_heif_set_thumbnail( heif ) )
203 				return( -1 );
204 			heif-&gt;thumbnail_set = TRUE;
205 		}
206 		heif-&gt;page_no = page_no;
207 	}
208 	return( 0 );
209 }
210 static int
211 vips_foreign_load_heif_set_header( VipsForeignLoadHeif *heif, VipsImage *out )
212 {
213 	VipsForeignLoad *load = (VipsForeignLoad *) heif;
214 	int bands;
215 	int i;
216 	heif_item_id id[16];
217 	int n_metadata;
218 	struct heif_error error;
219 	VipsForeignHeifCompression compression;
220 	if( vips_foreign_load_heif_set_page( heif, heif-&gt;page, FALSE ) )
221 		return( -1 );
222 	if ( heif-&gt;page_width &lt; 1 || heif-&gt;page_height &lt; 1 ) {
223 		vips_error( "heifload", "%s", _( "bad dimensions" ) );
224 		return( -1 );
225 	}
226 	heif-&gt;has_alpha = heif_image_handle_has_alpha_channel( heif-&gt;handle );
227 #ifdef DEBUG
228 	printf( "heif_image_handle_has_alpha_channel() = %d\n", 
229 		heif-&gt;has_alpha );
230 	bands = heif-&gt;has_alpha ? 4 : 3;
231 	n_metadata = heif_image_handle_get_list_of_metadata_block_IDs( 
232 		heif-&gt;handle, NULL, id, VIPS_NUMBER( id ) );
233 	for( i = 0; i &lt; n_metadata; i++ ) {
234 		size_t length = heif_image_handle_get_metadata_size( 
235 			heif-&gt;handle, id[i] );
236 		const char *type = heif_image_handle_get_metadata_type( 
237 			heif-&gt;handle, id[i] );
238 		unsigned char *data;
239 		char name[256];
240 #ifdef DEBUG
241 		printf( "metadata type = %s, length = %zu\n", type, length ); 
242 		if( !length )
243 			continue;
244 		if( !(data = VIPS_ARRAY( out, length, unsigned char )) )
245 			return( -1 );
246 		error = heif_image_handle_get_metadata( 
247 			heif-&gt;handle, id[i], data );
248 		if( error.code ) {
249 			vips__heif_error( &amp;error );
250 			return( -1 );
251 		}
252 		if( length &gt; 4 &amp;&amp;
253 			g_ascii_strcasecmp( type, "exif" ) == 0 ) {
254 			data += 4;
255 			length -= 4;
256 		}
257 		if( g_ascii_strcasecmp( type, "exif" ) == 0 )
258 			vips_snprintf( name, 256, VIPS_META_EXIF_NAME );
259 		else if( g_ascii_strcasecmp( type, "mime" ) == 0 &amp;&amp;
260 			length &gt; 10 &amp;&amp;
261 			vips_isprefix( "&lt;x:xmpmeta", (const char *) data ) ) 
262 			vips_snprintf( name, 256, VIPS_META_XMP_NAME );
263 		else
264 			vips_snprintf( name, 256, "heif-%s-%d", type, i );
265 		vips_image_set_blob( out, name, 
266 			(VipsCallbackFn) NULL, data, length );
267 	}
268 	vips_autorot_remove_angle( out );
269 #ifdef HAVE_HEIF_COLOR_PROFILE
270 	enum heif_color_profile_type profile_type = 
271 		heif_image_handle_get_color_profile_type( heif-&gt;handle );
272 #ifdef DEBUG
273 {
274 	printf( "profile type = " ); 
275 	switch( profile_type ) {
276 	case heif_color_profile_type_not_present: 
277 		printf( "none" ); 
278 		break;
279 	case heif_color_profile_type_nclx: 
280 		printf( "nclx" ); 
281 		break;
282 	case heif_color_profile_type_rICC: 
283 		printf( "rICC" ); 
284 		break;
285 	case heif_color_profile_type_prof: 
286 		printf( "prof" ); 
287 		break;
288 	default:
289 		printf( "unknown" ); 
290 		break;
291 	}
292 	printf( "\n" ); 
293 }
294 	if( profile_type == heif_color_profile_type_prof ||
295 		profile_type == heif_color_profile_type_rICC ) {
296 		size_t length = heif_image_handle_get_raw_color_profile_size( 
297 			heif-&gt;handle );
298 		unsigned char *data;
299 		if( !(data = VIPS_ARRAY( out, length, unsigned char )) )
300 			return( -1 );
301 		error = heif_image_handle_get_raw_color_profile( 
302 			heif-&gt;handle, data );
303 		if( error.code ) {
304 			vips__heif_error( &amp;error );
305 			return( -1 );
306 		}
307 #ifdef DEBUG
308 		printf( "profile data, length = %zd\n", length ); 
309 		vips_image_set_blob( out, VIPS_META_ICC_NAME, 
310 			(VipsCallbackFn) NULL, data, length );
311 	}
312 	else if( profile_type == heif_color_profile_type_nclx ) {
313 		g_warning( "heifload: ignoring nclx profile" );
314 	}
315 	vips_image_set_int( out, "heif-primary", heif-&gt;primary_page );
316 	vips_image_set_int( out, "n-pages", heif-&gt;n_top );
317 	if( vips_object_argument_isset( VIPS_OBJECT( heif ), "n" ) )
318 		vips_image_set_int( out, 
319 			VIPS_META_PAGE_HEIGHT, heif-&gt;page_height );
320 	compression = VIPS_FOREIGN_HEIF_COMPRESSION_HEVC;
321 #ifdef HAVE_HEIF_AVIF
322 {
323 	const unsigned char *brand_data;
324 	if( (brand_data = vips_source_sniff( heif-&gt;source, 12 )) ) {
325 		enum heif_brand brand;
326 		brand = heif_main_brand( brand_data, 12 );
327 		if( brand == heif_avif || 
328 			brand == heif_avis )
329 			compression = VIPS_FOREIGN_HEIF_COMPRESSION_AV1;
330 	}
331 }
332 	vips_image_set_string( out, "heif-compression",
333 		vips_enum_nick( VIPS_TYPE_FOREIGN_HEIF_COMPRESSION,
334 			compression ) );
335 	if( vips_image_pipelinev( out, VIPS_DEMAND_STYLE_THINSTRIP, NULL ) )
336 		return( -1 );
337 	vips_image_init_fields( out,
338 		heif-&gt;page_width, heif-&gt;page_height * heif-&gt;n, bands, 
339 		VIPS_FORMAT_UCHAR, VIPS_CODING_NONE, VIPS_INTERPRETATION_sRGB, 
340 		1.0, 1.0 );
341 	VIPS_SETSTR( load-&gt;out-&gt;filename, 
342 		vips_connection_filename( VIPS_CONNECTION( heif-&gt;source ) ) );
343 	return( 0 );
344 }
345 static int
346 vips_foreign_load_heif_header( VipsForeignLoad *load )
347 {
348 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );
349 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) load;
350 	struct heif_error error;
351 	heif_item_id primary_id;
352 	int i;
353 #ifdef DEBUG
354 	printf( "vips_foreign_load_heif_header:\n" );
355 	heif-&gt;n_top = heif_context_get_number_of_top_level_images( heif-&gt;ctx );
356 	heif-&gt;id = VIPS_ARRAY( NULL, heif-&gt;n_top, heif_item_id );
357 	heif_context_get_list_of_top_level_image_IDs( heif-&gt;ctx, 
358 		heif-&gt;id, heif-&gt;n_top );
359 	error = heif_context_get_primary_image_ID( heif-&gt;ctx, &amp;primary_id );
360 	if( error.code ) {
361 		vips__heif_error( &amp;error );
362 		return( -1 );
363 	}
364 	for( i = 0; i &lt; heif-&gt;n_top; i++ )
365 		if( heif-&gt;id[i] == primary_id )
366 			heif-&gt;primary_page = i;
367 	if( !vips_object_argument_isset( VIPS_OBJECT( load ), "page" ) &amp;&amp;
368 		!vips_object_argument_isset( VIPS_OBJECT( load ), "n" ) )
369 		heif-&gt;page = heif-&gt;primary_page;
370 	if( heif-&gt;n == -1 )
371 		heif-&gt;n = heif-&gt;n_top - heif-&gt;page;
372 	if( heif-&gt;page &lt; 0 ||
373 		heif-&gt;n &lt;= 0 ||
374 		heif-&gt;page + heif-&gt;n &gt; heif-&gt;n_top ) {
375 		vips_error( class-&gt;nickname, "%s", _( "bad page number" ) ); 
376 		return( -1 ); 
377 	}
378 #ifdef DEBUG
379 	for( i = heif-&gt;page; i &lt; heif-&gt;page + heif-&gt;n; i++ ) {
380 		heif_item_id thumb_ids[1];
381 		int n_items;
382 		int n_thumbs;
383 		int j;
384 		if( vips_foreign_load_heif_set_page( heif, i, FALSE ) )
385 			return( -1 );
386 		n_thumbs = heif_image_handle_get_number_of_thumbnails( 
387 			heif-&gt;handle );
388 		n_items = heif_image_handle_get_list_of_thumbnail_IDs( 
389 			heif-&gt;handle, thumb_ids, 1 );
390 		printf( "page = %d\n", i );
391 		printf( "n_thumbs = %d\n", n_thumbs );
392 		printf( "n_items = %d\n", n_items );
393 		for( j = 0; j &lt; n_items; j++ ) {
394 			struct heif_image_handle *thumb_handle;
395 			error = heif_image_handle_get_thumbnail( heif-&gt;handle,
396 				thumb_ids[j], &amp;thumb_handle );
397 			if( error.code ) {
398 				vips__heif_error( &amp;error );
399 				return( -1 );
400 			}
401 			printf( "  thumb %d\n", j );
402 			printf( "    width = %d\n", 
403 				heif_image_handle_get_width( thumb_handle ) );
404 			printf( "    height = %d\n", 
405 				heif_image_handle_get_height( thumb_handle ) );
406 		}
407 	}
408 	if( vips_foreign_load_heif_set_page( heif, 
409 		heif-&gt;page, heif-&gt;thumbnail ) )
410 		return( -1 );
411 	heif-&gt;page_width = heif_image_handle_get_width( heif-&gt;handle );
412 	heif-&gt;page_height = heif_image_handle_get_height( heif-&gt;handle );
413 	for( i = heif-&gt;page + 1; i &lt; heif-&gt;page + heif-&gt;n; i++ ) {
414 		if( vips_foreign_load_heif_set_page( heif, 
415 			i, heif-&gt;thumbnail ) )
416 			return( -1 );
417 		if( heif_image_handle_get_width( heif-&gt;handle ) 
418 				!= heif-&gt;page_width ||
419 			heif_image_handle_get_height( heif-&gt;handle ) 
420 				!= heif-&gt;page_height ) {
421 			vips_error( class-&gt;nickname, "%s", 
422 				_( "not all pages are the same size" ) ); 
423 			return( -1 ); 
424 		}
425 	}
426 #ifdef DEBUG
427 	printf( "page_width = %d\n", heif-&gt;page_width );
428 	printf( "page_height = %d\n", heif-&gt;page_height );
429 	printf( "n_top = %d\n", heif-&gt;n_top );
430 	for( i = 0; i &lt; heif-&gt;n_top; i++ ) {
431 		printf( "  id[%d] = %d\n", i, heif-&gt;id[i] );
432 		if( vips_foreign_load_heif_set_page( heif, i, FALSE ) )
433 			return( -1 );
434 		printf( "    width = %d\n", 
435 			heif_image_handle_get_width( heif-&gt;handle ) );
436 		printf( "    height = %d\n", 
437 			heif_image_handle_get_height( heif-&gt;handle ) );
438 		printf( "    has_depth = %d\n", 
439 			heif_image_handle_has_depth_image( heif-&gt;handle ) );
440 		printf( "    has_alpha = %d\n", 
441 			heif_image_handle_has_alpha_channel( heif-&gt;handle ) );
442 		printf( "    n_metadata = %d\n", 
443 			heif_image_handle_get_number_of_metadata_blocks( 
444 				heif-&gt;handle, NULL ) );
445 #ifdef HAVE_HEIF_COLOR_PROFILE
446 		printf( "    colour profile type = 0x%xd\n", 
447 			heif_image_handle_get_color_profile_type( 
448 				heif-&gt;handle ) );
449 	}
450 	if( vips_foreign_load_heif_set_header( heif, load-&gt;out ) )
451 		return( -1 );
452 	vips_source_minimise( heif-&gt;source );
453 	return( 0 );
454 }
455 #ifdef DEBUG
456 void
457 vips__heif_image_print( struct heif_image *img )
458 {
459 	const static enum heif_channel channel[] = {
460 		heif_channel_Y,
461 		heif_channel_Cb,
462 		heif_channel_Cr,
463 		heif_channel_R,
464 		heif_channel_G,
465 		heif_channel_B,
466 		heif_channel_Alpha,
467 		heif_channel_interleaved
468 	};
469 	const static char *channel_name[] = {
470 		"heif_channel_Y",
471 		"heif_channel_Cb",
472 		"heif_channel_Cr",
473 		"heif_channel_R",
474 		"heif_channel_G",
475 		"heif_channel_B",
476 		"heif_channel_Alpha",
477 		"heif_channel_interleaved"
478 	};
479 	int i;
480 	printf( "vips__heif_image_print:\n" );
481 	for( i = 0; i &lt; VIPS_NUMBER( channel ); i++ ) {
482 		if( !heif_image_has_channel( img, channel[i] ) )
483 			continue;
484 		printf( "\t%s:\n", channel_name[i] ); 
485 		printf( "\t\twidth = %d\n", 
486 			heif_image_get_width( img, channel[i] ) );
487 		printf( "\t\theight = %d\n", 
488 			heif_image_get_height( img, channel[i] ) );
489 		printf( "\t\tbits = %d\n", 
490 			heif_image_get_bits_per_pixel( img, channel[i] ) );
491 	}
492 }
493 static int
494 vips_foreign_load_heif_generate( VipsRegion *or, 
495 	void *seq, void *a, void *b, gboolean *stop )
496 {
497 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) a;
498 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( heif );
499         VipsRect *r = &amp;or-&gt;valid;
500 	int page = r-&gt;top / heif-&gt;page_height + heif-&gt;page;
501 	int line = r-&gt;top % heif-&gt;page_height;
502 #ifdef DEBUG_VERBOSE
503 	printf( "vips_foreign_load_heif_generate: line %d\n", r-&gt;top );
504 	g_assert( r-&gt;height == 1 );
505 	if( vips_foreign_load_heif_set_page( heif, page, heif-&gt;thumbnail ) )
506 		return( -1 );
507 	if( !heif-&gt;img ) {
508 		struct heif_error error;
509 		struct heif_decoding_options *options;
510 		enum heif_chroma chroma = heif-&gt;has_alpha ? 
511 			heif_chroma_interleaved_RGBA :
512 			heif_chroma_interleaved_RGB;
513 		options = heif_decoding_options_alloc();
514 #ifdef HAVE_HEIF_DECODING_OPTIONS_CONVERT_HDR_TO_8BIT
515 		options-&gt;convert_hdr_to_8bit = TRUE;
516 		error = heif_decode_image( heif-&gt;handle, &amp;heif-&gt;img, 
517 			heif_colorspace_RGB, chroma, 
518 			options );
519 		heif_decoding_options_free( options );
520 		if( error.code ) {
521 			vips__heif_error( &amp;error );
522 			return( -1 );
523 		}
524 #ifdef DEBUG
525 		vips__heif_image_print( heif-&gt;img );
526 	}
527 	if( !heif-&gt;data ) {
528 		int image_width = heif_image_get_width( heif-&gt;img, 
529 			heif_channel_interleaved );
530 		int image_height = heif_image_get_height( heif-&gt;img, 
531 			heif_channel_interleaved );
532 		if( image_width != heif-&gt;page_width ||
533 			image_height != heif-&gt;page_height ) {
534 			vips_error( class-&gt;nickname, 
535 				"%s", _( "bad image dimensions on decode" ) );
536 			return( -1 );
537 		}
538 		if( !(heif-&gt;data = heif_image_get_plane_readonly( heif-&gt;img, 
539 			heif_channel_interleaved, &amp;heif-&gt;stride )) ) {
540 			vips_error( class-&gt;nickname, 
541 				"%s", _( "unable to get image data" ) );
542 			return( -1 );
543 		}
544 	}
545 	memcpy( VIPS_REGION_ADDR( or, 0, r-&gt;top ),
546 		heif-&gt;data + heif-&gt;stride * line, 
547 		VIPS_IMAGE_SIZEOF_LINE( or-&gt;im ) );
548 	return( 0 );
549 }
550 static void
551 vips_foreign_load_heif_minimise( VipsObject *object, VipsForeignLoadHeif *heif )
552 {
553 	vips_source_minimise( heif-&gt;source );
554 }
555 static int
556 vips_foreign_load_heif_load( VipsForeignLoad *load )
557 {
558 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) load;
559 	VipsImage **t = (VipsImage **) 
560 		vips_object_local_array( VIPS_OBJECT( load ), 3 );
561 #ifdef DEBUG
562 	printf( "vips_foreign_load_heif_load: loading image\n" );
563 	t[0] = vips_image_new();
564 	if( vips_foreign_load_heif_set_header( heif, t[0] ) )
565 		return( -1 );
566 	g_signal_connect( t[0], "minimise", 
567 		G_CALLBACK( vips_foreign_load_heif_minimise ), heif ); 
568 	if( vips_image_generate( t[0],
569 		NULL, vips_foreign_load_heif_generate, NULL, heif, NULL ) ||
570 		vips_sequential( t[0], &amp;t[1], NULL ) ||
571 		vips_image_write( t[1], load-&gt;real ) )
572 		return( -1 );
573 <a name="0"></a>	if( vips_source_decode( heif-&gt;source ) )
574 		return( -1 );
575 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
576 }
577 static void
578 vips_foreign_load_heif_class_init( VipsForeignLoadHeifClass *class )
579 {
580 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
581 	VipsObjectClass *object_class = (VipsObjectClass *) class;
582 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
583 	gobject_class-&gt;dispose = vips_foreign_load_heif_dispose;
584 	gobject_class-&gt;set_property = vips_object_set_property;
585 	gobject_class-&gt;get_property = vips_object_get_property;
586 	object_class-&gt;nickname = "heifload_base";
587 	object_class-&gt;description = _( "load a HEIF image" );
588 	object_class-&gt;build = vips_foreign_load_heif_build;
589 	load_class-&gt;get_flags = vips_foreign_load_heif_get_flags;
590 	load_class-&gt;header = vips_foreign_load_heif_header;</b></font>
591 	load_class-&gt;load = vips_foreign_load_heif_load;
592 	VIPS_ARG_INT( class, "page", 2,
593 		_( "Page" ),
594 		_( "Load this page from the file" ),
595 		VIPS_ARGUMENT_OPTIONAL_INPUT,
596 		G_STRUCT_OFFSET( VipsForeignLoadHeif, page ),
597 		0, 100000, 0 );
598 	VIPS_ARG_INT( class, "n", 3,
599 		_( "n" ),
600 		_( "Load this many pages" ),
601 		VIPS_ARGUMENT_OPTIONAL_INPUT,
602 		G_STRUCT_OFFSET( VipsForeignLoadHeif, n ),
603 		-1, 100000, 1 );
604 	VIPS_ARG_BOOL( class, "thumbnail", 4, 
605 		_( "Thumbnail" ), 
606 		_( "Fetch thumbnail image" ),
607 		VIPS_ARGUMENT_OPTIONAL_INPUT,
608 		G_STRUCT_OFFSET( VipsForeignLoadHeif, thumbnail ),
609 		FALSE );
610 	VIPS_ARG_BOOL( class, "autorotate", 21, 
611 		_( "Autorotate" ), 
612 		_( "Rotate image using exif orientation" ),
613 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
614 		G_STRUCT_OFFSET( VipsForeignLoadHeif, autorotate ),
615 		FALSE );
616 }
617 static gint64
618 vips_foreign_load_heif_get_position( void *userdata )
619 {
620 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) userdata;
621 	return( vips_source_seek( heif-&gt;source, 0L, SEEK_CUR ) );
622 }
623 static int
624 vips_foreign_load_heif_read( void *data, size_t size, void *userdata )
625 {
626 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) userdata;
627 	while( size &gt; 0 ) {
628 		gint64 bytes_read;
629 		bytes_read = vips_source_read( heif-&gt;source, data, size );
630 		if( bytes_read &lt;= 0 ) 
631 			return( -1 );
632 		size -= bytes_read;
633 		data += bytes_read;
634 	}
635 	return( 0 );
636 }
637 static int
638 vips_foreign_load_heif_seek( gint64 position, void *userdata )
639 {
640 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) userdata;
641 	return( vips_source_seek( heif-&gt;source, position, SEEK_SET ) == -1 );
642 }
643 static enum heif_reader_grow_status 
644 vips_foreign_load_heif_wait_for_file_size( gint64 target_size, void *userdata )
645 {
646 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) userdata;
647 	gint64 old_position;
648 	gint64 result;
649 	enum heif_reader_grow_status status;
650 	old_position = vips_source_seek( heif-&gt;source, 0L, SEEK_CUR );
651 	result = vips_source_seek( heif-&gt;source, target_size, SEEK_SET );
652 	vips_source_seek( heif-&gt;source, old_position, SEEK_SET );
653 	if( result &lt; 0 )
654 		status = heif_reader_grow_status_size_beyond_eof;
655 	else
656 		status = heif_reader_grow_status_size_reached;
657 	return( status );
658 }
659 static void
660 vips_foreign_load_heif_init( VipsForeignLoadHeif *heif )
661 {
662 	heif-&gt;n = 1;
663 	heif-&gt;reader = VIPS_ARRAY( NULL, 1, struct heif_reader );
664 	heif-&gt;reader-&gt;reader_api_version = 1;
665 	heif-&gt;reader-&gt;get_position = vips_foreign_load_heif_get_position;
666 	heif-&gt;reader-&gt;read = vips_foreign_load_heif_read;
667 	heif-&gt;reader-&gt;seek = vips_foreign_load_heif_seek;
668 	heif-&gt;reader-&gt;wait_for_file_size = 
669 		vips_foreign_load_heif_wait_for_file_size;
670 }
671 typedef struct _VipsForeignLoadHeifFile {
672 	VipsForeignLoadHeif parent_object;
673 	char *filename; 
674 } VipsForeignLoadHeifFile;
675 typedef VipsForeignLoadHeifClass VipsForeignLoadHeifFileClass;
676 G_DEFINE_TYPE( VipsForeignLoadHeifFile, vips_foreign_load_heif_file, 
677 	vips_foreign_load_heif_get_type() );
678 static int
679 vips_foreign_load_heif_file_build( VipsObject *object )
680 {
681 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) object;
682 	VipsForeignLoadHeifFile *file = (VipsForeignLoadHeifFile *) object;
683 	if( file-&gt;filename ) 
684 		if( !(heif-&gt;source = 
685 			vips_source_new_from_file( file-&gt;filename )) )
686 			return( -1 );
687 	if( VIPS_OBJECT_CLASS( vips_foreign_load_heif_file_parent_class )-&gt;
688 		build( object ) )
689 		return( -1 );
690 	return( 0 );
691 }
692 static int
693 vips_foreign_load_heif_file_is_a( const char *filename )
694 {
695 	char buf[12];
696 	if( vips__get_bytes( filename, (unsigned char *) buf, 12 ) != 12 )
697 		return( 0 );
698 	return( vips_foreign_load_heif_is_a( buf, 12 ) );
699 }
700 static void
701 vips_foreign_load_heif_file_class_init( VipsForeignLoadHeifFileClass *class )
702 {
703 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
704 	VipsObjectClass *object_class = (VipsObjectClass *) class;
705 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
706 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
707 	gobject_class-&gt;set_property = vips_object_set_property;
708 	gobject_class-&gt;get_property = vips_object_get_property;
709 	object_class-&gt;nickname = "heifload";
710 	object_class-&gt;build = vips_foreign_load_heif_file_build;
711 	foreign_class-&gt;suffs = vips__heif_suffs;
712 	load_class-&gt;is_a = vips_foreign_load_heif_file_is_a;
713 	VIPS_ARG_STRING( class, "filename", 1, 
714 		_( "Filename" ),
715 		_( "Filename to load from" ),
716 		VIPS_ARGUMENT_REQUIRED_INPUT, 
717 		G_STRUCT_OFFSET( VipsForeignLoadHeifFile, filename ),
718 		NULL );
719 }
720 static void
721 vips_foreign_load_heif_file_init( VipsForeignLoadHeifFile *file )
722 {
723 }
724 typedef struct _VipsForeignLoadHeifBuffer {
725 	VipsForeignLoadHeif parent_object;
726 	VipsArea *buf;
727 } VipsForeignLoadHeifBuffer;
728 typedef VipsForeignLoadHeifClass VipsForeignLoadHeifBufferClass;
729 G_DEFINE_TYPE( VipsForeignLoadHeifBuffer, vips_foreign_load_heif_buffer, 
730 	vips_foreign_load_heif_get_type() );
731 static int
732 vips_foreign_load_heif_buffer_build( VipsObject *object )
733 {
734 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) object;
735 	VipsForeignLoadHeifBuffer *buffer = 
736 		(VipsForeignLoadHeifBuffer *) object;
737 	if( buffer-&gt;buf )
738 		if( !(heif-&gt;source = vips_source_new_from_memory( 
739 			VIPS_AREA( buffer-&gt;buf )-&gt;data, 
740 			VIPS_AREA( buffer-&gt;buf )-&gt;length )) )
741 			return( -1 );
742 	if( VIPS_OBJECT_CLASS( vips_foreign_load_heif_file_parent_class )-&gt;
743 		build( object ) )
744 		return( -1 );
745 	return( 0 );
746 }
747 static gboolean
748 vips_foreign_load_heif_buffer_is_a( const void *buf, size_t len )
749 {
750 	return( vips_foreign_load_heif_is_a( buf, len ) );
751 }
752 static void
753 vips_foreign_load_heif_buffer_class_init( 
754 	VipsForeignLoadHeifBufferClass *class )
755 {
756 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
757 	VipsObjectClass *object_class = (VipsObjectClass *) class;
758 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
759 	gobject_class-&gt;set_property = vips_object_set_property;
760 	gobject_class-&gt;get_property = vips_object_get_property;
761 	object_class-&gt;nickname = "heifload_buffer";
762 	object_class-&gt;build = vips_foreign_load_heif_buffer_build;
763 	load_class-&gt;is_a_buffer = vips_foreign_load_heif_buffer_is_a;
764 	VIPS_ARG_BOXED( class, "buffer", 1, 
765 		_( "Buffer" ),
766 		_( "Buffer to load from" ),
767 		VIPS_ARGUMENT_REQUIRED_INPUT, 
768 		G_STRUCT_OFFSET( VipsForeignLoadHeifBuffer, buf ),
769 		VIPS_TYPE_BLOB );
770 }
771 static void
772 vips_foreign_load_heif_buffer_init( VipsForeignLoadHeifBuffer *buffer )
773 {
774 }
775 typedef struct _VipsForeignLoadHeifSource {
776 	VipsForeignLoadHeif parent_object;
777 	VipsSource *source;
778 } VipsForeignLoadHeifSource;
779 typedef VipsForeignLoadHeifClass VipsForeignLoadHeifSourceClass;
780 G_DEFINE_TYPE( VipsForeignLoadHeifSource, vips_foreign_load_heif_source, 
781 	vips_foreign_load_heif_get_type() );
782 static int
783 vips_foreign_load_heif_source_build( VipsObject *object )
784 {
785 	VipsForeignLoadHeif *heif = (VipsForeignLoadHeif *) object;
786 	VipsForeignLoadHeifSource *source = 
787 		(VipsForeignLoadHeifSource *) object;
788 	if( source-&gt;source ) {
789 		heif-&gt;source = source-&gt;source;
790 		g_object_ref( heif-&gt;source );
791 	}
792 	if( VIPS_OBJECT_CLASS( vips_foreign_load_heif_source_parent_class )-&gt;
793 		build( object ) )
794 		return( -1 );
795 	return( 0 );
796 }
797 static gboolean
798 vips_foreign_load_heif_source_is_a_source( VipsSource *source )
799 {
800 	const char *p;
801 	return( (p = (const char *) vips_source_sniff( source, 12 )) &amp;&amp;
802 		vips_foreign_load_heif_is_a( p, 12 ) );
803 }
804 static void
805 vips_foreign_load_heif_source_class_init( 
806 	VipsForeignLoadHeifSourceClass *class )
807 {
808 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
809 	VipsObjectClass *object_class = (VipsObjectClass *) class;
810 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
811 	gobject_class-&gt;set_property = vips_object_set_property;
812 	gobject_class-&gt;get_property = vips_object_get_property;
813 	object_class-&gt;nickname = "heifload_source";
814 	object_class-&gt;build = vips_foreign_load_heif_source_build;
815 	load_class-&gt;is_a_source = vips_foreign_load_heif_source_is_a_source;
816 	VIPS_ARG_OBJECT( class, "source", 1,
817 		_( "Source" ),
818 		_( "Source to load from" ),
819 		VIPS_ARGUMENT_REQUIRED_INPUT, 
820 		G_STRUCT_OFFSET( VipsForeignLoadHeifSource, source ),
821 		VIPS_TYPE_SOURCE );
822 }
823 static void
824 vips_foreign_load_heif_source_init( VipsForeignLoadHeifSource *source )
825 {
826 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
