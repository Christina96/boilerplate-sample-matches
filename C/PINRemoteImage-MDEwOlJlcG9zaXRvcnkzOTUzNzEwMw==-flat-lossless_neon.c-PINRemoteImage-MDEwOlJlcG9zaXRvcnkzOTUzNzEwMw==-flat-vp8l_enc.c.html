
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.418738049713193%, Tokens: 10</h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_neon.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_NEON)
3  #include <arm_neon.h>
4  #include "src/dsp/lossless.h"
5  #include "src/dsp/neon.h"
6  #if !defined(WORK_AROUND_GCC)
7  static void ConvertBGRAToRGBA_NEON(const uint32_t* src,
8                                     int num_pixels, uint8_t* dst) {
9    const uint32_t* const end = src + (num_pixels & ~15);
10    for (; src < end; src += 16) {
11      uint8x16x4_t pixel = vld4q_u8((uint8_t*)src);
12      const uint8x16_t tmp = pixel.val[0];
13      pixel.val[0] = pixel.val[2];
14      pixel.val[2] = tmp;
15      vst4q_u8(dst, pixel);
16      dst += 64;
17    }
18    VP8LConvertBGRAToRGBA_C(src, num_pixels & 15, dst);  
19  }
20  static void ConvertBGRAToBGR_NEON(const uint32_t* src,
21                                    int num_pixels, uint8_t* dst) {
22    const uint32_t* const end = src + (num_pixels & ~15);
23    for (; src < end; src += 16) {
24      const uint8x16x4_t pixel = vld4q_u8((uint8_t*)src);
25      const uint8x16x3_t tmp = { { pixel.val[0], pixel.val[1], pixel.val[2] } };
26      vst3q_u8(dst, tmp);
27      dst += 48;
28    }
29    VP8LConvertBGRAToBGR_C(src, num_pixels & 15, dst);  
30  }
31  static void ConvertBGRAToRGB_NEON(const uint32_t* src,
32                                    int num_pixels, uint8_t* dst) {
33    const uint32_t* const end = src + (num_pixels & ~15);
34    for (; src < end; src += 16) {
35      const uint8x16x4_t pixel = vld4q_u8((uint8_t*)src);
36      const uint8x16x3_t tmp = { { pixel.val[2], pixel.val[1], pixel.val[0] } };
37      vst3q_u8(dst, tmp);
38      dst += 48;
39    }
40    VP8LConvertBGRAToRGB_C(src, num_pixels & 15, dst);  
41  }
42  #else  
43  static const uint8_t kRGBAShuffle[8] = { 2, 1, 0, 3, 6, 5, 4, 7 };
44  static void ConvertBGRAToRGBA_NEON(const uint32_t* src,
45                                     int num_pixels, uint8_t* dst) {
46    const uint32_t* const end = src + (num_pixels & ~1);
47    const uint8x8_t shuffle = vld1_u8(kRGBAShuffle);
48    for (; src < end; src += 2) {
49      const uint8x8_t pixels = vld1_u8((uint8_t*)src);
50      vst1_u8(dst, vtbl1_u8(pixels, shuffle));
51      dst += 8;
52    }
53    VP8LConvertBGRAToRGBA_C(src, num_pixels & 1, dst);  
54  }
<span onclick='openModal()' class='match'>55  static const uint8_t kBGRShuffle[3][8] = {
56    {  0,  1,  2,  4,  5,  6,  8,  9 },
57    { 10, 12, 13, 14, 16, 17, 18, 20 },
58    { 21, 22, 24, 25, 26, 28, 29, 30 }
</span>59  };
60  static void ConvertBGRAToBGR_NEON(const uint32_t* src,
61                                    int num_pixels, uint8_t* dst) {
62    const uint32_t* const end = src + (num_pixels & ~7);
63    const uint8x8_t shuffle0 = vld1_u8(kBGRShuffle[0]);
64    const uint8x8_t shuffle1 = vld1_u8(kBGRShuffle[1]);
65    const uint8x8_t shuffle2 = vld1_u8(kBGRShuffle[2]);
66    for (; src < end; src += 8) {
67      uint8x8x4_t pixels;
68      INIT_VECTOR4(pixels,
69                   vld1_u8((const uint8_t*)(src + 0)),
70                   vld1_u8((const uint8_t*)(src + 2)),
71                   vld1_u8((const uint8_t*)(src + 4)),
72                   vld1_u8((const uint8_t*)(src + 6)));
73      vst1_u8(dst +  0, vtbl4_u8(pixels, shuffle0));
74      vst1_u8(dst +  8, vtbl4_u8(pixels, shuffle1));
75      vst1_u8(dst + 16, vtbl4_u8(pixels, shuffle2));
76      dst += 8 * 3;
77    }
78    VP8LConvertBGRAToBGR_C(src, num_pixels & 7, dst);  
79  }
80  static const uint8_t kRGBShuffle[3][8] = {
81    {  2,  1,  0,  6,  5,  4, 10,  9 },
82    {  8, 14, 13, 12, 18, 17, 16, 22 },
83    { 21, 20, 26, 25, 24, 30, 29, 28 }
84  };
85  static void ConvertBGRAToRGB_NEON(const uint32_t* src,
86                                    int num_pixels, uint8_t* dst) {
87    const uint32_t* const end = src + (num_pixels & ~7);
88    const uint8x8_t shuffle0 = vld1_u8(kRGBShuffle[0]);
89    const uint8x8_t shuffle1 = vld1_u8(kRGBShuffle[1]);
90    const uint8x8_t shuffle2 = vld1_u8(kRGBShuffle[2]);
91    for (; src < end; src += 8) {
92      uint8x8x4_t pixels;
93      INIT_VECTOR4(pixels,
94                   vld1_u8((const uint8_t*)(src + 0)),
95                   vld1_u8((const uint8_t*)(src + 2)),
96                   vld1_u8((const uint8_t*)(src + 4)),
97                   vld1_u8((const uint8_t*)(src + 6)));
98      vst1_u8(dst +  0, vtbl4_u8(pixels, shuffle0));
99      vst1_u8(dst +  8, vtbl4_u8(pixels, shuffle1));
100      vst1_u8(dst + 16, vtbl4_u8(pixels, shuffle2));
101      dst += 8 * 3;
102    }
103    VP8LConvertBGRAToRGB_C(src, num_pixels & 7, dst);  
104  }
105  #endif   
106  #define LOAD_U32_AS_U8(IN) vreinterpret_u8_u32(vdup_n_u32((IN)))
107  #define LOAD_U32P_AS_U8(IN) vreinterpret_u8_u32(vld1_u32((IN)))
108  #define LOADQ_U32_AS_U8(IN) vreinterpretq_u8_u32(vdupq_n_u32((IN)))
109  #define LOADQ_U32P_AS_U8(IN) vreinterpretq_u8_u32(vld1q_u32((IN)))
110  #define GET_U8_AS_U32(IN) vget_lane_u32(vreinterpret_u32_u8((IN)), 0);
111  #define GETQ_U8_AS_U32(IN) vgetq_lane_u32(vreinterpretq_u32_u8((IN)), 0);
112  #define STOREQ_U8_AS_U32P(OUT, IN) vst1q_u32((OUT), vreinterpretq_u32_u8((IN)));
113  #define ROTATE32_LEFT(L) vextq_u8((L), (L), 12)    
114  static WEBP_INLINE uint8x8_t Average2_u8_NEON(uint32_t a0, uint32_t a1) {
115    const uint8x8_t A0 = LOAD_U32_AS_U8(a0);
116    const uint8x8_t A1 = LOAD_U32_AS_U8(a1);
117    return vhadd_u8(A0, A1);
118  }
119  static WEBP_INLINE uint32_t ClampedAddSubtractHalf_NEON(uint32_t c0,
120                                                          uint32_t c1,
121                                                          uint32_t c2) {
122    const uint8x8_t avg = Average2_u8_NEON(c0, c1);
123    const uint8x8_t C2 = LOAD_U32_AS_U8(c2);
124    const uint8x8_t cmp = vcgt_u8(C2, avg);
125    const uint8x8_t C2_1 = vadd_u8(C2, cmp);
126    const int8x8_t diff_avg = vreinterpret_s8_u8(vhsub_u8(avg, C2_1));
127    const int16x8_t avg_16 = vreinterpretq_s16_u16(vmovl_u8(avg));
128    const uint8x8_t res = vqmovun_s16(vaddw_s8(avg_16, diff_avg));
129    const uint32_t output = GET_U8_AS_U32(res);
130    return output;
131  }
132  static WEBP_INLINE uint32_t Average2_NEON(uint32_t a0, uint32_t a1) {
133    const uint8x8_t avg_u8x8 = Average2_u8_NEON(a0, a1);
134    const uint32_t avg = GET_U8_AS_U32(avg_u8x8);
135    return avg;
136  }
137  static WEBP_INLINE uint32_t Average3_NEON(uint32_t a0, uint32_t a1,
138                                            uint32_t a2) {
139    const uint8x8_t avg0 = Average2_u8_NEON(a0, a2);
140    const uint8x8_t A1 = LOAD_U32_AS_U8(a1);
141    const uint32_t avg = GET_U8_AS_U32(vhadd_u8(avg0, A1));
142    return avg;
143  }
144  static uint32_t Predictor5_NEON(uint32_t left, const uint32_t* const top) {
145    return Average3_NEON(left, top[0], top[1]);
146  }
147  static uint32_t Predictor6_NEON(uint32_t left, const uint32_t* const top) {
148    return Average2_NEON(left, top[-1]);
149  }
150  static uint32_t Predictor7_NEON(uint32_t left, const uint32_t* const top) {
151    return Average2_NEON(left, top[0]);
152  }
153  static uint32_t Predictor13_NEON(uint32_t left, const uint32_t* const top) {
154    return ClampedAddSubtractHalf_NEON(left, top[0], top[-1]);
155  }
156  static void PredictorAdd0_NEON(const uint32_t* in, const uint32_t* upper,
157                                 int num_pixels, uint32_t* out) {
158    int i;
159    const uint8x16_t black = vreinterpretq_u8_u32(vdupq_n_u32(ARGB_BLACK));
160    for (i = 0; i + 4 <= num_pixels; i += 4) {
161      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
162      const uint8x16_t res = vaddq_u8(src, black);
163      STOREQ_U8_AS_U32P(&out[i], res);
164    }
165    VP8LPredictorsAdd_C[0](in + i, upper + i, num_pixels - i, out + i);
166  }
167  static void PredictorAdd1_NEON(const uint32_t* in, const uint32_t* upper,
168                                 int num_pixels, uint32_t* out) {
169    int i;
170    const uint8x16_t zero = LOADQ_U32_AS_U8(0);
171    for (i = 0; i + 4 <= num_pixels; i += 4) {
172      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
173      const uint8x16_t shift0 = vextq_u8(zero, src, 12);
174      const uint8x16_t sum0 = vaddq_u8(src, shift0);
175      const uint8x16_t shift1 = vextq_u8(zero, sum0, 8);
176      const uint8x16_t sum1 = vaddq_u8(sum0, shift1);
177      const uint8x16_t prev = LOADQ_U32_AS_U8(out[i - 1]);
178      const uint8x16_t res = vaddq_u8(sum1, prev);
179      STOREQ_U8_AS_U32P(&out[i], res);
180    }
181    VP8LPredictorsAdd_C[1](in + i, upper + i, num_pixels - i, out + i);
182  }
183  #define GENERATE_PREDICTOR_1(X, IN)                                       \
184  static void PredictorAdd##X##_NEON(const uint32_t* in,                    \
185                                     const uint32_t* upper, int num_pixels, \
186                                     uint32_t* out) {                       \
187    int i;                                                                  \
188    for (i = 0; i + 4 <= num_pixels; i += 4) {                              \
189      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);                      \
190      const uint8x16_t other = LOADQ_U32P_AS_U8(&(IN));                     \
191      const uint8x16_t res = vaddq_u8(src, other);                          \
192      STOREQ_U8_AS_U32P(&out[i], res);                                      \
193    }                                                                       \
194    VP8LPredictorsAdd_C[(X)](in + i, upper + i, num_pixels - i, out + i);   \
195  }
196  GENERATE_PREDICTOR_1(2, upper[i])
197  GENERATE_PREDICTOR_1(3, upper[i + 1])
198  GENERATE_PREDICTOR_1(4, upper[i - 1])
199  #undef GENERATE_PREDICTOR_1
200  #define DO_PRED5(LANE) do {                                              \
201    const uint8x16_t avgLTR = vhaddq_u8(L, TR);                            \
202    const uint8x16_t avg = vhaddq_u8(avgLTR, T);                           \
203    const uint8x16_t res = vaddq_u8(avg, src);                             \
204    vst1q_lane_u32(&out[i + (LANE)], vreinterpretq_u32_u8(res), (LANE));   \
205    L = ROTATE32_LEFT(res);                                                \
206  } while (0)
207  static void PredictorAdd5_NEON(const uint32_t* in, const uint32_t* upper,
208                                 int num_pixels, uint32_t* out) {
209    int i;
210    uint8x16_t L = LOADQ_U32_AS_U8(out[-1]);
211    for (i = 0; i + 4 <= num_pixels; i += 4) {
212      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
213      const uint8x16_t T = LOADQ_U32P_AS_U8(&upper[i + 0]);
214      const uint8x16_t TR = LOADQ_U32P_AS_U8(&upper[i + 1]);
215      DO_PRED5(0);
216      DO_PRED5(1);
217      DO_PRED5(2);
218      DO_PRED5(3);
219    }
220    VP8LPredictorsAdd_C[5](in + i, upper + i, num_pixels - i, out + i);
221  }
222  #undef DO_PRED5
223  #define DO_PRED67(LANE) do {                                             \
224    const uint8x16_t avg = vhaddq_u8(L, top);                              \
225    const uint8x16_t res = vaddq_u8(avg, src);                             \
226    vst1q_lane_u32(&out[i + (LANE)], vreinterpretq_u32_u8(res), (LANE));   \
227    L = ROTATE32_LEFT(res);                                                \
228  } while (0)
229  static void PredictorAdd6_NEON(const uint32_t* in, const uint32_t* upper,
230                                 int num_pixels, uint32_t* out) {
231    int i;
232    uint8x16_t L = LOADQ_U32_AS_U8(out[-1]);
233    for (i = 0; i + 4 <= num_pixels; i += 4) {
234      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
235      const uint8x16_t top = LOADQ_U32P_AS_U8(&upper[i - 1]);
236      DO_PRED67(0);
237      DO_PRED67(1);
238      DO_PRED67(2);
239      DO_PRED67(3);
240    }
241    VP8LPredictorsAdd_C[6](in + i, upper + i, num_pixels - i, out + i);
242  }
243  static void PredictorAdd7_NEON(const uint32_t* in, const uint32_t* upper,
244                                 int num_pixels, uint32_t* out) {
245    int i;
246    uint8x16_t L = LOADQ_U32_AS_U8(out[-1]);
247    for (i = 0; i + 4 <= num_pixels; i += 4) {
248      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
249      const uint8x16_t top = LOADQ_U32P_AS_U8(&upper[i]);
250      DO_PRED67(0);
251      DO_PRED67(1);
252      DO_PRED67(2);
253      DO_PRED67(3);
254    }
255    VP8LPredictorsAdd_C[7](in + i, upper + i, num_pixels - i, out + i);
256  }
257  #undef DO_PRED67
258  #define GENERATE_PREDICTOR_2(X, IN)                                       \
259  static void PredictorAdd##X##_NEON(const uint32_t* in,                    \
260                                     const uint32_t* upper, int num_pixels, \
261                                     uint32_t* out) {                       \
262    int i;                                                                  \
263    for (i = 0; i + 4 <= num_pixels; i += 4) {                              \
264      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);                      \
265      const uint8x16_t Tother = LOADQ_U32P_AS_U8(&(IN));                    \
266      const uint8x16_t T = LOADQ_U32P_AS_U8(&upper[i]);                     \
267      const uint8x16_t avg = vhaddq_u8(T, Tother);                          \
268      const uint8x16_t res = vaddq_u8(avg, src);                            \
269      STOREQ_U8_AS_U32P(&out[i], res);                                      \
270    }                                                                       \
271    VP8LPredictorsAdd_C[(X)](in + i, upper + i, num_pixels - i, out + i);   \
272  }
273  GENERATE_PREDICTOR_2(8, upper[i - 1])
274  GENERATE_PREDICTOR_2(9, upper[i + 1])
275  #undef GENERATE_PREDICTOR_2
276  #define DO_PRED10(LANE) do {                                             \
277    const uint8x16_t avgLTL = vhaddq_u8(L, TL);                            \
278    const uint8x16_t avg = vhaddq_u8(avgTTR, avgLTL);                      \
279    const uint8x16_t res = vaddq_u8(avg, src);                             \
280    vst1q_lane_u32(&out[i + (LANE)], vreinterpretq_u32_u8(res), (LANE));   \
281    L = ROTATE32_LEFT(res);                                                \
282  } while (0)
283  static void PredictorAdd10_NEON(const uint32_t* in, const uint32_t* upper,
284                                  int num_pixels, uint32_t* out) {
285    int i;
286    uint8x16_t L = LOADQ_U32_AS_U8(out[-1]);
287    for (i = 0; i + 4 <= num_pixels; i += 4) {
288      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
289      const uint8x16_t TL = LOADQ_U32P_AS_U8(&upper[i - 1]);
290      const uint8x16_t T = LOADQ_U32P_AS_U8(&upper[i]);
291      const uint8x16_t TR = LOADQ_U32P_AS_U8(&upper[i + 1]);
292      const uint8x16_t avgTTR = vhaddq_u8(T, TR);
293      DO_PRED10(0);
294      DO_PRED10(1);
295      DO_PRED10(2);
296      DO_PRED10(3);
297    }
298    VP8LPredictorsAdd_C[10](in + i, upper + i, num_pixels - i, out + i);
299  }
300  #undef DO_PRED10
301  #define DO_PRED11(LANE) do {                                                   \
302    const uint8x16_t sumLin = vaddq_u8(L, src);  &bsol;* in + L */                    \
303    const uint8x16_t pLTL = vabdq_u8(L, TL);  &bsol;* |L - TL| */                     \
304    const uint16x8_t sum_LTL = vpaddlq_u8(pLTL);                                 \
305    const uint32x4_t pa = vpaddlq_u16(sum_LTL);                                  \
306    const uint32x4_t mask = vcleq_u32(pa, pb);                                   \
307    const uint8x16_t res = vbslq_u8(vreinterpretq_u8_u32(mask), sumTin, sumLin); \
308    vst1q_lane_u32(&out[i + (LANE)], vreinterpretq_u32_u8(res), (LANE));         \
309    L = ROTATE32_LEFT(res);                                                      \
310  } while (0)
311  static void PredictorAdd11_NEON(const uint32_t* in, const uint32_t* upper,
312                                  int num_pixels, uint32_t* out) {
313    int i;
314    uint8x16_t L = LOADQ_U32_AS_U8(out[-1]);
315    for (i = 0; i + 4 <= num_pixels; i += 4) {
316      const uint8x16_t T = LOADQ_U32P_AS_U8(&upper[i]);
317      const uint8x16_t TL = LOADQ_U32P_AS_U8(&upper[i - 1]);
318      const uint8x16_t pTTL = vabdq_u8(T, TL);   
319      const uint16x8_t sum_TTL = vpaddlq_u8(pTTL);
320      const uint32x4_t pb = vpaddlq_u16(sum_TTL);
321      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
322      const uint8x16_t sumTin = vaddq_u8(T, src);   
323      DO_PRED11(0);
324      DO_PRED11(1);
325      DO_PRED11(2);
326      DO_PRED11(3);
327    }
328    VP8LPredictorsAdd_C[11](in + i, upper + i, num_pixels - i, out + i);
329  }
330  #undef DO_PRED11
331  #define DO_PRED12(DIFF, LANE) do {                                       \
332    const uint8x8_t pred =                                                 \
333        vqmovun_s16(vaddq_s16(vreinterpretq_s16_u16(L), (DIFF)));          \
334    const uint8x8_t res =                                                  \
335        vadd_u8(pred, (LANE <= 1) ? vget_low_u8(src) : vget_high_u8(src)); \
336    const uint16x8_t res16 = vmovl_u8(res);                                \
337    vst1_lane_u32(&out[i + (LANE)], vreinterpret_u32_u8(res), (LANE) & 1); \
338                      \
339    L = vextq_u16(res16, res16, 4);                                        \
340  } while (0)
341  static void PredictorAdd12_NEON(const uint32_t* in, const uint32_t* upper,
342                                  int num_pixels, uint32_t* out) {
343    int i;
344    uint16x8_t L = vmovl_u8(LOAD_U32_AS_U8(out[-1]));
345    for (i = 0; i + 4 <= num_pixels; i += 4) {
346      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
347      const uint8x16_t TL = LOADQ_U32P_AS_U8(&upper[i - 1]);
348      const uint8x16_t T = LOADQ_U32P_AS_U8(&upper[i]);
349      const int16x8_t diff_lo =
350          vreinterpretq_s16_u16(vsubl_u8(vget_low_u8(T), vget_low_u8(TL)));
351      const int16x8_t diff_hi =
352          vreinterpretq_s16_u16(vsubl_u8(vget_high_u8(T), vget_high_u8(TL)));
353      DO_PRED12(diff_lo, 0);
354      DO_PRED12(diff_lo, 1);
355      DO_PRED12(diff_hi, 2);
356      DO_PRED12(diff_hi, 3);
357    }
358    VP8LPredictorsAdd_C[12](in + i, upper + i, num_pixels - i, out + i);
359  }
360  #undef DO_PRED12
361  #define DO_PRED13(LANE, LOW_OR_HI) do {                                        \
362    const uint8x16_t avg = vhaddq_u8(L, T);                                      \
363    const uint8x16_t cmp = vcgtq_u8(TL, avg);                                    \
364    const uint8x16_t TL_1 = vaddq_u8(TL, cmp);                                   \
365                        \
366    const int8x8_t diff_avg =                                                    \
367        vreinterpret_s8_u8(LOW_OR_HI(vhsubq_u8(avg, TL_1)));                     \
368                                     \
369    const int16x8_t avg_16 = vreinterpretq_s16_u16(vmovl_u8(LOW_OR_HI(avg)));    \
370    const uint8x8_t delta = vqmovun_s16(vaddw_s8(avg_16, diff_avg));             \
371    const uint8x8_t res = vadd_u8(LOW_OR_HI(src), delta);                        \
372    const uint8x16_t res2 = vcombine_u8(res, res);                               \
373    vst1_lane_u32(&out[i + (LANE)], vreinterpret_u32_u8(res), (LANE) & 1);       \
374    L = ROTATE32_LEFT(res2);                                                     \
375  } while (0)
376  static void PredictorAdd13_NEON(const uint32_t* in, const uint32_t* upper,
377                                  int num_pixels, uint32_t* out) {
378    int i;
379    uint8x16_t L = LOADQ_U32_AS_U8(out[-1]);
380    for (i = 0; i + 4 <= num_pixels; i += 4) {
381      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
382      const uint8x16_t T = LOADQ_U32P_AS_U8(&upper[i]);
383      const uint8x16_t TL = LOADQ_U32P_AS_U8(&upper[i - 1]);
384      DO_PRED13(0, vget_low_u8);
385      DO_PRED13(1, vget_low_u8);
386      DO_PRED13(2, vget_high_u8);
387      DO_PRED13(3, vget_high_u8);
388    }
389    VP8LPredictorsAdd_C[13](in + i, upper + i, num_pixels - i, out + i);
390  }
391  #undef DO_PRED13
392  #undef LOAD_U32_AS_U8
393  #undef LOAD_U32P_AS_U8
394  #undef LOADQ_U32_AS_U8
395  #undef LOADQ_U32P_AS_U8
396  #undef GET_U8_AS_U32
397  #undef GETQ_U8_AS_U32
398  #undef STOREQ_U8_AS_U32P
399  #undef ROTATE32_LEFT
400  #if defined(__APPLE__) && defined(__aarch64__) && \
401      defined(__apple_build_version__) && (__apple_build_version__< 6020037)
402  #define USE_VTBLQ
403  #endif
404  #ifdef USE_VTBLQ
405  static const uint8_t kGreenShuffle[16] = {
406    1, 255, 1, 255, 5, 255, 5, 255, 9, 255, 9, 255, 13, 255, 13, 255
407  };
408  static WEBP_INLINE uint8x16_t DoGreenShuffle_NEON(const uint8x16_t argb,
409                                                    const uint8x16_t shuffle) {
410    return vcombine_u8(vtbl1q_u8(argb, vget_low_u8(shuffle)),
411                       vtbl1q_u8(argb, vget_high_u8(shuffle)));
412  }
413  #else  
414  static const uint8_t kGreenShuffle[8] = { 1, 255, 1, 255, 5, 255, 5, 255  };
415  static WEBP_INLINE uint8x16_t DoGreenShuffle_NEON(const uint8x16_t argb,
416                                                    const uint8x8_t shuffle) {
417    return vcombine_u8(vtbl1_u8(vget_low_u8(argb), shuffle),
418                       vtbl1_u8(vget_high_u8(argb), shuffle));
419  }
420  #endif  
421  static void AddGreenToBlueAndRed_NEON(const uint32_t* src, int num_pixels,
422                                        uint32_t* dst) {
423    const uint32_t* const end = src + (num_pixels & ~3);
424  #ifdef USE_VTBLQ
425    const uint8x16_t shuffle = vld1q_u8(kGreenShuffle);
426  #else
427    const uint8x8_t shuffle = vld1_u8(kGreenShuffle);
428  #endif
429    for (; src < end; src += 4, dst += 4) {
430      const uint8x16_t argb = vld1q_u8((const uint8_t*)src);
431      const uint8x16_t greens = DoGreenShuffle_NEON(argb, shuffle);
432      vst1q_u8((uint8_t*)dst, vaddq_u8(argb, greens));
433    }
434    VP8LAddGreenToBlueAndRed_C(src, num_pixels & 3, dst);
435  }
436  static void TransformColorInverse_NEON(const VP8LMultipliers* const m,
437                                         const uint32_t* const src,
438                                         int num_pixels, uint32_t* dst) {
439  #define CST(X)  (((int16_t)(m->X << 8)) >> 6)
440    const int16_t rb[8] = {
441      CST(green_to_blue_), CST(green_to_red_),
442      CST(green_to_blue_), CST(green_to_red_),
443      CST(green_to_blue_), CST(green_to_red_),
444      CST(green_to_blue_), CST(green_to_red_)
445    };
446    const int16x8_t mults_rb = vld1q_s16(rb);
447    const int16_t b2[8] = {
448      0, CST(red_to_blue_), 0, CST(red_to_blue_),
449      0, CST(red_to_blue_), 0, CST(red_to_blue_),
450    };
451    const int16x8_t mults_b2 = vld1q_s16(b2);
452  #undef CST
453  #ifdef USE_VTBLQ
454    static const uint8_t kg0g0[16] = {
455      255, 1, 255, 1, 255, 5, 255, 5, 255, 9, 255, 9, 255, 13, 255, 13
456    };
457    const uint8x16_t shuffle = vld1q_u8(kg0g0);
458  #else
459    static const uint8_t k0g0g[8] = { 255, 1, 255, 1, 255, 5, 255, 5 };
460    const uint8x8_t shuffle = vld1_u8(k0g0g);
461  #endif
462    const uint32x4_t mask_ag = vdupq_n_u32(0xff00ff00u);
463    int i;
464    for (i = 0; i + 4 <= num_pixels; i += 4) {
465      const uint8x16_t in = vld1q_u8((const uint8_t*)(src + i));
466      const uint32x4_t a0g0 = vandq_u32(vreinterpretq_u32_u8(in), mask_ag);
467      const uint8x16_t greens = DoGreenShuffle_NEON(in, shuffle);
468      const int16x8_t A = vqdmulhq_s16(vreinterpretq_s16_u8(greens), mults_rb);
469      const int8x16_t B = vaddq_s8(vreinterpretq_s8_u8(in),
470                                   vreinterpretq_s8_s16(A));
471      const int16x8_t C = vshlq_n_s16(vreinterpretq_s16_s8(B), 8);
472      const int16x8_t D = vqdmulhq_s16(C, mults_b2);
473      const uint32x4_t E = vshrq_n_u32(vreinterpretq_u32_s16(D), 8);
474      const int8x16_t F = vaddq_s8(vreinterpretq_s8_u32(E),
475                                   vreinterpretq_s8_s16(C));
476      const uint16x8_t G = vshrq_n_u16(vreinterpretq_u16_s8(F), 8);
477      const uint32x4_t out = vorrq_u32(vreinterpretq_u32_u16(G), a0g0);
478      vst1q_u32(dst + i, out);
479    }
480    VP8LTransformColorInverse_C(m, src + i, num_pixels - i, dst + i);
481  }
482  #undef USE_VTBLQ
483  extern void VP8LDspInitNEON(void);
484  WEBP_TSAN_IGNORE_FUNCTION void VP8LDspInitNEON(void) {
485    VP8LPredictors[5] = Predictor5_NEON;
486    VP8LPredictors[6] = Predictor6_NEON;
487    VP8LPredictors[7] = Predictor7_NEON;
488    VP8LPredictors[13] = Predictor13_NEON;
489    VP8LPredictorsAdd[0] = PredictorAdd0_NEON;
490    VP8LPredictorsAdd[1] = PredictorAdd1_NEON;
491    VP8LPredictorsAdd[2] = PredictorAdd2_NEON;
492    VP8LPredictorsAdd[3] = PredictorAdd3_NEON;
493    VP8LPredictorsAdd[4] = PredictorAdd4_NEON;
494    VP8LPredictorsAdd[5] = PredictorAdd5_NEON;
495    VP8LPredictorsAdd[6] = PredictorAdd6_NEON;
496    VP8LPredictorsAdd[7] = PredictorAdd7_NEON;
497    VP8LPredictorsAdd[8] = PredictorAdd8_NEON;
498    VP8LPredictorsAdd[9] = PredictorAdd9_NEON;
499    VP8LPredictorsAdd[10] = PredictorAdd10_NEON;
500    VP8LPredictorsAdd[11] = PredictorAdd11_NEON;
501    VP8LPredictorsAdd[12] = PredictorAdd12_NEON;
502    VP8LPredictorsAdd[13] = PredictorAdd13_NEON;
503    VP8LConvertBGRAToRGBA = ConvertBGRAToRGBA_NEON;
504    VP8LConvertBGRAToBGR = ConvertBGRAToBGR_NEON;
505    VP8LConvertBGRAToRGB = ConvertBGRAToRGB_NEON;
506    VP8LAddGreenToBlueAndRed = AddGreenToBlueAndRed_NEON;
507    VP8LTransformColorInverse = TransformColorInverse_NEON;
508  }
509  #else  
510  WEBP_DSP_INIT_STUB(VP8LDspInitNEON)
511  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vp8l_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdlib.h>
3  #include "src/enc/backward_references_enc.h"
4  #include "src/enc/histogram_enc.h"
5  #include "src/enc/vp8i_enc.h"
6  #include "src/enc/vp8li_enc.h"
7  #include "src/dsp/lossless.h"
8  #include "src/dsp/lossless_common.h"
9  #include "src/utils/bit_writer_utils.h"
10  #include "src/utils/huffman_encode_utils.h"
11  #include "src/utils/utils.h"
12  #include "src/webp/format_constants.h"
13  #define MAX_HUFF_IMAGE_SIZE       2600
14  static int PaletteCompareColorsForQsort(const void* p1, const void* p2) {
15    const uint32_t a = WebPMemToUint32((uint8_t*)p1);
16    const uint32_t b = WebPMemToUint32((uint8_t*)p2);
17    assert(a != b);
18    return (a < b) ? -1 : 1;
19  }
20  static WEBP_INLINE uint32_t PaletteComponentDistance(uint32_t v) {
21    return (v <= 128) ? v : (256 - v);
22  }
23  static WEBP_INLINE uint32_t PaletteColorDistance(uint32_t col1, uint32_t col2) {
24    const uint32_t diff = VP8LSubPixels(col1, col2);
25    const int kMoreWeightForRGBThanForAlpha = 9;
26    uint32_t score;
27    score =  PaletteComponentDistance((diff >>  0) & 0xff);
28    score += PaletteComponentDistance((diff >>  8) & 0xff);
29    score += PaletteComponentDistance((diff >> 16) & 0xff);
30    score *= kMoreWeightForRGBThanForAlpha;
31    score += PaletteComponentDistance((diff >> 24) & 0xff);
32    return score;
33  }
34  static WEBP_INLINE void SwapColor(uint32_t* const col1, uint32_t* const col2) {
35    const uint32_t tmp = *col1;
36    *col1 = *col2;
37    *col2 = tmp;
38  }
39  static void GreedyMinimizeDeltas(uint32_t palette[], int num_colors) {
40    uint32_t predict = 0x00000000;
41    int i, k;
42    for (i = 0; i < num_colors; ++i) {
43      int best_ix = i;
44      uint32_t best_score = ~0U;
45      for (k = i; k < num_colors; ++k) {
46        const uint32_t cur_score = PaletteColorDistance(palette[k], predict);
47        if (best_score > cur_score) {
48          best_score = cur_score;
49          best_ix = k;
50        }
51      }
52      SwapColor(&palette[best_ix], &palette[i]);
53      predict = palette[i];
54    }
55  }
56  static int PaletteHasNonMonotonousDeltas(uint32_t palette[], int num_colors) {
57    uint32_t predict = 0x000000;
58    int i;
59    uint8_t sign_found = 0x00;
60    for (i = 0; i < num_colors; ++i) {
61      const uint32_t diff = VP8LSubPixels(palette[i], predict);
62      const uint8_t rd = (diff >> 16) & 0xff;
63      const uint8_t gd = (diff >>  8) & 0xff;
64      const uint8_t bd = (diff >>  0) & 0xff;
65      if (rd != 0x00) {
66        sign_found |= (rd < 0x80) ? 1 : 2;
67      }
68      if (gd != 0x00) {
69        sign_found |= (gd < 0x80) ? 8 : 16;
70      }
71      if (bd != 0x00) {
72        sign_found |= (bd < 0x80) ? 64 : 128;
73      }
74      predict = palette[i];
75    }
76    return (sign_found & (sign_found << 1)) != 0;  
77  }
78  static int AnalyzeAndCreatePalette(const WebPPicture* const pic,
79                                     int low_effort,
80                                     uint32_t palette[MAX_PALETTE_SIZE],
81                                     int* const palette_size) {
82    const int num_colors = WebPGetColorPalette(pic, palette);
83    if (num_colors > MAX_PALETTE_SIZE) {
84      *palette_size = 0;
85      return 0;
86    }
87    *palette_size = num_colors;
88    qsort(palette, num_colors, sizeof(*palette), PaletteCompareColorsForQsort);
89    if (!low_effort && PaletteHasNonMonotonousDeltas(palette, num_colors)) {
90      GreedyMinimizeDeltas(palette, num_colors);
91    }
92    return 1;
93  }
94  typedef enum {
95    kDirect = 0,
96    kSpatial = 1,
97    kSubGreen = 2,
98    kSpatialSubGreen = 3,
99    kPalette = 4,
100    kNumEntropyIx = 5
101  } EntropyIx;
102  typedef enum {
103    kHistoAlpha = 0,
104    kHistoAlphaPred,
105    kHistoGreen,
106    kHistoGreenPred,
107    kHistoRed,
108    kHistoRedPred,
109    kHistoBlue,
110    kHistoBluePred,
111    kHistoRedSubGreen,
112    kHistoRedPredSubGreen,
113    kHistoBlueSubGreen,
114    kHistoBluePredSubGreen,
115    kHistoPalette,
116    kHistoTotal  
117  } HistoIx;
118  static void AddSingleSubGreen(int p, uint32_t* const r, uint32_t* const b) {
119    const int green = p >> 8;  
120    ++r[((p >> 16) - green) & 0xff];
121    ++b[((p >>  0) - green) & 0xff];
122  }
123  static void AddSingle(uint32_t p,
124                        uint32_t* const a, uint32_t* const r,
125                        uint32_t* const g, uint32_t* const b) {
126    ++a[(p >> 24) & 0xff];
127    ++r[(p >> 16) & 0xff];
128    ++g[(p >>  8) & 0xff];
129    ++b[(p >>  0) & 0xff];
130  }
131  static WEBP_INLINE uint32_t HashPix(uint32_t pix) {
132    return ((((uint64_t)pix + (pix >> 19)) * 0x39c5fba7ull) & 0xffffffffu) >> 24;
133  }
134  static int AnalyzeEntropy(const uint32_t* argb,
135                            int width, int height, int argb_stride,
136                            int use_palette,
137                            int palette_size, int transform_bits,
138                            EntropyIx* const min_entropy_ix,
139                            int* const red_and_blue_always_zero) {
140    uint32_t* histo;
141    if (use_palette && palette_size <= 16) {
142      *min_entropy_ix = kPalette;
143      *red_and_blue_always_zero = 1;
144      return 1;
145    }
146    histo = (uint32_t*)WebPSafeCalloc(kHistoTotal, sizeof(*histo) * 256);
147    if (histo != NULL) {
148      int i, x, y;
149      const uint32_t* prev_row = NULL;
150      const uint32_t* curr_row = argb;
151      uint32_t pix_prev = argb[0];  
152      for (y = 0; y < height; ++y) {
153        for (x = 0; x < width; ++x) {
154          const uint32_t pix = curr_row[x];
155          const uint32_t pix_diff = VP8LSubPixels(pix, pix_prev);
156          pix_prev = pix;
157          if ((pix_diff == 0) || (prev_row != NULL && pix == prev_row[x])) {
158            continue;
159          }
160          AddSingle(pix,
161                    &histo[kHistoAlpha * 256],
162                    &histo[kHistoRed * 256],
163                    &histo[kHistoGreen * 256],
164                    &histo[kHistoBlue * 256]);
165          AddSingle(pix_diff,
166                    &histo[kHistoAlphaPred * 256],
167                    &histo[kHistoRedPred * 256],
168                    &histo[kHistoGreenPred * 256],
169                    &histo[kHistoBluePred * 256]);
170          AddSingleSubGreen(pix,
171                            &histo[kHistoRedSubGreen * 256],
172                            &histo[kHistoBlueSubGreen * 256]);
173          AddSingleSubGreen(pix_diff,
174                            &histo[kHistoRedPredSubGreen * 256],
175                            &histo[kHistoBluePredSubGreen * 256]);
176          {
177            const uint32_t hash = HashPix(pix);
178            ++histo[kHistoPalette * 256 + hash];
179          }
180        }
181        prev_row = curr_row;
182        curr_row += argb_stride;
183      }
184      {
185        double entropy_comp[kHistoTotal];
186        double entropy[kNumEntropyIx];
187        int k;
188        int last_mode_to_analyze = use_palette ? kPalette : kSpatialSubGreen;
189        int j;
190        ++histo[kHistoRedPredSubGreen * 256];
191        ++histo[kHistoBluePredSubGreen * 256];
192        ++histo[kHistoRedPred * 256];
193        ++histo[kHistoGreenPred * 256];
194        ++histo[kHistoBluePred * 256];
195        ++histo[kHistoAlphaPred * 256];
196        for (j = 0; j < kHistoTotal; ++j) {
197          entropy_comp[j] = VP8LBitsEntropy(&histo[j * 256], 256);
198        }
199        entropy[kDirect] = entropy_comp[kHistoAlpha] +
200            entropy_comp[kHistoRed] +
201            entropy_comp[kHistoGreen] +
202            entropy_comp[kHistoBlue];
203        entropy[kSpatial] = entropy_comp[kHistoAlphaPred] +
204            entropy_comp[kHistoRedPred] +
205            entropy_comp[kHistoGreenPred] +
206            entropy_comp[kHistoBluePred];
207        entropy[kSubGreen] = entropy_comp[kHistoAlpha] +
208            entropy_comp[kHistoRedSubGreen] +
209            entropy_comp[kHistoGreen] +
210            entropy_comp[kHistoBlueSubGreen];
211        entropy[kSpatialSubGreen] = entropy_comp[kHistoAlphaPred] +
212            entropy_comp[kHistoRedPredSubGreen] +
213            entropy_comp[kHistoGreenPred] +
214            entropy_comp[kHistoBluePredSubGreen];
215        entropy[kPalette] = entropy_comp[kHistoPalette];
216        entropy[kSpatial] += VP8LSubSampleSize(width, transform_bits) *
217                             VP8LSubSampleSize(height, transform_bits) *
218                             VP8LFastLog2(14);
219        entropy[kSpatialSubGreen] += VP8LSubSampleSize(width, transform_bits) *
220                                     VP8LSubSampleSize(height, transform_bits) *
221                                     VP8LFastLog2(24);
222        entropy[kPalette] += palette_size * 8;
223        *min_entropy_ix = kDirect;
224        for (k = kDirect + 1; k <= last_mode_to_analyze; ++k) {
225          if (entropy[*min_entropy_ix] > entropy[k]) {
226            *min_entropy_ix = (EntropyIx)k;
227          }
228        }
229        assert((int)*min_entropy_ix <= last_mode_to_analyze);
230        *red_and_blue_always_zero = 1;
231        {
<span onclick='openModal()' class='match'>232          static const uint8_t kHistoPairs[5][2] = {
233            { kHistoRed, kHistoBlue },
234            { kHistoRedPred, kHistoBluePred },
235            { kHistoRedSubGreen, kHistoBlueSubGreen },
</span>236            { kHistoRedPredSubGreen, kHistoBluePredSubGreen },
237            { kHistoRed, kHistoBlue }
238          };
239          const uint32_t* const red_histo =
240              &histo[256 * kHistoPairs[*min_entropy_ix][0]];
241          const uint32_t* const blue_histo =
242              &histo[256 * kHistoPairs[*min_entropy_ix][1]];
243          for (i = 1; i < 256; ++i) {
244            if ((red_histo[i] | blue_histo[i]) != 0) {
245              *red_and_blue_always_zero = 0;
246              break;
247            }
248          }
249        }
250      }
251      WebPSafeFree(histo);
252      return 1;
253    } else {
254      return 0;
255    }
256  }
257  static int GetHistoBits(int method, int use_palette, int width, int height) {
258    int histo_bits = (use_palette ? 9 : 7) - method;
259    while (1) {
260      const int huff_image_size = VP8LSubSampleSize(width, histo_bits) *
261                                  VP8LSubSampleSize(height, histo_bits);
262      if (huff_image_size <= MAX_HUFF_IMAGE_SIZE) break;
263      ++histo_bits;
264    }
265    return (histo_bits < MIN_HUFFMAN_BITS) ? MIN_HUFFMAN_BITS :
266           (histo_bits > MAX_HUFFMAN_BITS) ? MAX_HUFFMAN_BITS : histo_bits;
267  }
268  static int GetTransformBits(int method, int histo_bits) {
269    const int max_transform_bits = (method < 4) ? 6 : (method > 4) ? 4 : 5;
270    const int res =
271        (histo_bits > max_transform_bits) ? max_transform_bits : histo_bits;
272    assert(res <= MAX_TRANSFORM_BITS);
273    return res;
274  }
275  #define CRUNCH_CONFIGS_LZ77_MAX 2
276  typedef struct {
277    int entropy_idx_;
278    int lz77s_types_to_try_[CRUNCH_CONFIGS_LZ77_MAX];
279    int lz77s_types_to_try_size_;
280  } CrunchConfig;
281  #define CRUNCH_CONFIGS_MAX kNumEntropyIx
282  static int EncoderAnalyze(VP8LEncoder* const enc,
283                            CrunchConfig crunch_configs[CRUNCH_CONFIGS_MAX],
284                            int* const crunch_configs_size,
285                            int* const red_and_blue_always_zero) {
286    const WebPPicture* const pic = enc->pic_;
287    const int width = pic->width;
288    const int height = pic->height;
289    const WebPConfig* const config = enc->config_;
290    const int method = config->method;
291    const int low_effort = (config->method == 0);
292    int i;
293    int use_palette;
294    int n_lz77s;
295    assert(pic != NULL && pic->argb != NULL);
296    use_palette =
297        AnalyzeAndCreatePalette(pic, low_effort,
298                                enc->palette_, &enc->palette_size_);
299    enc->histo_bits_ = GetHistoBits(method, use_palette,
300                                    pic->width, pic->height);
301    enc->transform_bits_ = GetTransformBits(method, enc->histo_bits_);
302    if (low_effort) {
303      crunch_configs[0].entropy_idx_ = use_palette ? kPalette : kSpatialSubGreen;
304      n_lz77s = 1;
305      *crunch_configs_size = 1;
306    } else {
307      EntropyIx min_entropy_ix;
308      n_lz77s = (enc->palette_size_ > 0 && enc->palette_size_ <= 16) ? 2 : 1;
309      if (!AnalyzeEntropy(pic->argb, width, height, pic->argb_stride, use_palette,
310                          enc->palette_size_, enc->transform_bits_,
311                          &min_entropy_ix, red_and_blue_always_zero)) {
312        return 0;
313      }
314      if (method == 6 && config->quality == 100) {
315        *crunch_configs_size = 0;
316        for (i = 0; i < kNumEntropyIx; ++i) {
317          if (i != kPalette || use_palette) {
318            assert(*crunch_configs_size < CRUNCH_CONFIGS_MAX);
319            crunch_configs[(*crunch_configs_size)++].entropy_idx_ = i;
320          }
321        }
322      } else {
323        *crunch_configs_size = 1;
324        crunch_configs[0].entropy_idx_ = min_entropy_ix;
325      }
326    }
327    assert(n_lz77s <= CRUNCH_CONFIGS_LZ77_MAX);
328    for (i = 0; i < *crunch_configs_size; ++i) {
329      int j;
330      for (j = 0; j < n_lz77s; ++j) {
331        crunch_configs[i].lz77s_types_to_try_[j] =
332            (j == 0) ? kLZ77Standard | kLZ77RLE : kLZ77Box;
333      }
334      crunch_configs[i].lz77s_types_to_try_size_ = n_lz77s;
335    }
336    return 1;
337  }
338  static int EncoderInit(VP8LEncoder* const enc) {
339    const WebPPicture* const pic = enc->pic_;
340    const int width = pic->width;
341    const int height = pic->height;
342    const int pix_cnt = width * height;
343    const int refs_block_size = (pix_cnt - 1) / MAX_REFS_BLOCK_PER_IMAGE + 1;
344    int i;
345    if (!VP8LHashChainInit(&enc->hash_chain_, pix_cnt)) return 0;
346    for (i = 0; i < 3; ++i) VP8LBackwardRefsInit(&enc->refs_[i], refs_block_size);
347    return 1;
348  }
349  static int GetHuffBitLengthsAndCodes(
350      const VP8LHistogramSet* const histogram_image,
351      HuffmanTreeCode* const huffman_codes) {
352    int i, k;
353    int ok = 0;
354    uint64_t total_length_size = 0;
355    uint8_t* mem_buf = NULL;
356    const int histogram_image_size = histogram_image->size;
357    int max_num_symbols = 0;
358    uint8_t* buf_rle = NULL;
359    HuffmanTree* huff_tree = NULL;
360    for (i = 0; i < histogram_image_size; ++i) {
361      const VP8LHistogram* const histo = histogram_image->histograms[i];
362      HuffmanTreeCode* const codes = &huffman_codes[5 * i];
363      assert(histo != NULL);
364      for (k = 0; k < 5; ++k) {
365        const int num_symbols =
366            (k == 0) ? VP8LHistogramNumCodes(histo->palette_code_bits_) :
367            (k == 4) ? NUM_DISTANCE_CODES : 256;
368        codes[k].num_symbols = num_symbols;
369        total_length_size += num_symbols;
370      }
371    }
372    {
373      uint16_t* codes;
374      uint8_t* lengths;
375      mem_buf = (uint8_t*)WebPSafeCalloc(total_length_size,
376                                         sizeof(*lengths) + sizeof(*codes));
377      if (mem_buf == NULL) goto End;
378      codes = (uint16_t*)mem_buf;
379      lengths = (uint8_t*)&codes[total_length_size];
380      for (i = 0; i < 5 * histogram_image_size; ++i) {
381        const int bit_length = huffman_codes[i].num_symbols;
382        huffman_codes[i].codes = codes;
383        huffman_codes[i].code_lengths = lengths;
384        codes += bit_length;
385        lengths += bit_length;
386        if (max_num_symbols < bit_length) {
387          max_num_symbols = bit_length;
388        }
389      }
390    }
391    buf_rle = (uint8_t*)WebPSafeMalloc(1ULL, max_num_symbols);
392    huff_tree = (HuffmanTree*)WebPSafeMalloc(3ULL * max_num_symbols,
393                                             sizeof(*huff_tree));
394    if (buf_rle == NULL || huff_tree == NULL) goto End;
395    for (i = 0; i < histogram_image_size; ++i) {
396      HuffmanTreeCode* const codes = &huffman_codes[5 * i];
397      VP8LHistogram* const histo = histogram_image->histograms[i];
398      VP8LCreateHuffmanTree(histo->literal_, 15, buf_rle, huff_tree, codes + 0);
399      VP8LCreateHuffmanTree(histo->red_, 15, buf_rle, huff_tree, codes + 1);
400      VP8LCreateHuffmanTree(histo->blue_, 15, buf_rle, huff_tree, codes + 2);
401      VP8LCreateHuffmanTree(histo->alpha_, 15, buf_rle, huff_tree, codes + 3);
402      VP8LCreateHuffmanTree(histo->distance_, 15, buf_rle, huff_tree, codes + 4);
403    }
404    ok = 1;
405   End:
406    WebPSafeFree(huff_tree);
407    WebPSafeFree(buf_rle);
408    if (!ok) {
409      WebPSafeFree(mem_buf);
410      memset(huffman_codes, 0, 5 * histogram_image_size * sizeof(*huffman_codes));
411    }
412    return ok;
413  }
414  static void StoreHuffmanTreeOfHuffmanTreeToBitMask(
415      VP8LBitWriter* const bw, const uint8_t* code_length_bitdepth) {
416    static const uint8_t kStorageOrder[CODE_LENGTH_CODES] = {
417      17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
418    };
419    int i;
420    int codes_to_store = CODE_LENGTH_CODES;
421    for (; codes_to_store > 4; --codes_to_store) {
422      if (code_length_bitdepth[kStorageOrder[codes_to_store - 1]] != 0) {
423        break;
424      }
425    }
426    VP8LPutBits(bw, codes_to_store - 4, 4);
427    for (i = 0; i < codes_to_store; ++i) {
428      VP8LPutBits(bw, code_length_bitdepth[kStorageOrder[i]], 3);
429    }
430  }
431  static void ClearHuffmanTreeIfOnlyOneSymbol(
432      HuffmanTreeCode* const huffman_code) {
433    int k;
434    int count = 0;
435    for (k = 0; k < huffman_code->num_symbols; ++k) {
436      if (huffman_code->code_lengths[k] != 0) {
437        ++count;
438        if (count > 1) return;
439      }
440    }
441    for (k = 0; k < huffman_code->num_symbols; ++k) {
442      huffman_code->code_lengths[k] = 0;
443      huffman_code->codes[k] = 0;
444    }
445  }
446  static void StoreHuffmanTreeToBitMask(
447      VP8LBitWriter* const bw,
448      const HuffmanTreeToken* const tokens, const int num_tokens,
449      const HuffmanTreeCode* const huffman_code) {
450    int i;
451    for (i = 0; i < num_tokens; ++i) {
452      const int ix = tokens[i].code;
453      const int extra_bits = tokens[i].extra_bits;
454      VP8LPutBits(bw, huffman_code->codes[ix], huffman_code->code_lengths[ix]);
455      switch (ix) {
456        case 16:
457          VP8LPutBits(bw, extra_bits, 2);
458          break;
459        case 17:
460          VP8LPutBits(bw, extra_bits, 3);
461          break;
462        case 18:
463          VP8LPutBits(bw, extra_bits, 7);
464          break;
465      }
466    }
467  }
468  static void StoreFullHuffmanCode(VP8LBitWriter* const bw,
469                                   HuffmanTree* const huff_tree,
470                                   HuffmanTreeToken* const tokens,
471                                   const HuffmanTreeCode* const tree) {
472    uint8_t code_length_bitdepth[CODE_LENGTH_CODES] = { 0 };
473    uint16_t code_length_bitdepth_symbols[CODE_LENGTH_CODES] = { 0 };
474    const int max_tokens = tree->num_symbols;
475    int num_tokens;
476    HuffmanTreeCode huffman_code;
477    huffman_code.num_symbols = CODE_LENGTH_CODES;
478    huffman_code.code_lengths = code_length_bitdepth;
479    huffman_code.codes = code_length_bitdepth_symbols;
480    VP8LPutBits(bw, 0, 1);
481    num_tokens = VP8LCreateCompressedHuffmanTree(tree, tokens, max_tokens);
482    {
483      uint32_t histogram[CODE_LENGTH_CODES] = { 0 };
484      uint8_t buf_rle[CODE_LENGTH_CODES] = { 0 };
485      int i;
486      for (i = 0; i < num_tokens; ++i) {
487        ++histogram[tokens[i].code];
488      }
489      VP8LCreateHuffmanTree(histogram, 7, buf_rle, huff_tree, &huffman_code);
490    }
491    StoreHuffmanTreeOfHuffmanTreeToBitMask(bw, code_length_bitdepth);
492    ClearHuffmanTreeIfOnlyOneSymbol(&huffman_code);
493    {
494      int trailing_zero_bits = 0;
495      int trimmed_length = num_tokens;
496      int write_trimmed_length;
497      int length;
498      int i = num_tokens;
499      while (i-- > 0) {
500        const int ix = tokens[i].code;
501        if (ix == 0 || ix == 17 || ix == 18) {
502          --trimmed_length;   
503          trailing_zero_bits += code_length_bitdepth[ix];
504          if (ix == 17) {
505            trailing_zero_bits += 3;
506          } else if (ix == 18) {
507            trailing_zero_bits += 7;
508          }
509        } else {
510          break;
511        }
512      }
513      write_trimmed_length = (trimmed_length > 1 && trailing_zero_bits > 12);
514      length = write_trimmed_length ? trimmed_length : num_tokens;
515      VP8LPutBits(bw, write_trimmed_length, 1);
516      if (write_trimmed_length) {
517        if (trimmed_length == 2) {
518          VP8LPutBits(bw, 0, 3 + 2);     
519        } else {
520          const int nbits = BitsLog2Floor(trimmed_length - 2);
521          const int nbitpairs = nbits / 2 + 1;
522          assert(trimmed_length > 2);
523          assert(nbitpairs - 1 < 8);
524          VP8LPutBits(bw, nbitpairs - 1, 3);
525          VP8LPutBits(bw, trimmed_length - 2, nbitpairs * 2);
526        }
527      }
528      StoreHuffmanTreeToBitMask(bw, tokens, length, &huffman_code);
529    }
530  }
531  static void StoreHuffmanCode(VP8LBitWriter* const bw,
532                               HuffmanTree* const huff_tree,
533                               HuffmanTreeToken* const tokens,
534                               const HuffmanTreeCode* const huffman_code) {
535    int i;
536    int count = 0;
537    int symbols[2] = { 0, 0 };
538    const int kMaxBits = 8;
539    const int kMaxSymbol = 1 << kMaxBits;
540    for (i = 0; i < huffman_code->num_symbols && count < 3; ++i) {
541      if (huffman_code->code_lengths[i] != 0) {
542        if (count < 2) symbols[count] = i;
543        ++count;
544      }
545    }
546    if (count == 0) {   
547      VP8LPutBits(bw, 0x01, 4);
548    } else if (count <= 2 && symbols[0] < kMaxSymbol && symbols[1] < kMaxSymbol) {
549      VP8LPutBits(bw, 1, 1);  
550      VP8LPutBits(bw, count - 1, 1);
551      if (symbols[0] <= 1) {
552        VP8LPutBits(bw, 0, 1);  
553        VP8LPutBits(bw, symbols[0], 1);
554      } else {
555        VP8LPutBits(bw, 1, 1);
556        VP8LPutBits(bw, symbols[0], 8);
557      }
558      if (count == 2) {
559        VP8LPutBits(bw, symbols[1], 8);
560      }
561    } else {
562      StoreFullHuffmanCode(bw, huff_tree, tokens, huffman_code);
563    }
564  }
565  static WEBP_INLINE void WriteHuffmanCode(VP8LBitWriter* const bw,
566                               const HuffmanTreeCode* const code,
567                               int code_index) {
568    const int depth = code->code_lengths[code_index];
569    const int symbol = code->codes[code_index];
570    VP8LPutBits(bw, symbol, depth);
571  }
572  static WEBP_INLINE void WriteHuffmanCodeWithExtraBits(
573      VP8LBitWriter* const bw,
574      const HuffmanTreeCode* const code,
575      int code_index,
576      int bits,
577      int n_bits) {
578    const int depth = code->code_lengths[code_index];
579    const int symbol = code->codes[code_index];
580    VP8LPutBits(bw, (bits << depth) | symbol, depth + n_bits);
581  }
582  static WebPEncodingError StoreImageToBitMask(
583      VP8LBitWriter* const bw, int width, int histo_bits,
584      const VP8LBackwardRefs* const refs,
585      const uint16_t* histogram_symbols,
586      const HuffmanTreeCode* const huffman_codes) {
587    const int histo_xsize = histo_bits ? VP8LSubSampleSize(width, histo_bits) : 1;
588    const int tile_mask = (histo_bits == 0) ? 0 : -(1 << histo_bits);
589    int x = 0;
590    int y = 0;
591    int tile_x = x & tile_mask;
592    int tile_y = y & tile_mask;
593    int histogram_ix = histogram_symbols[0];
594    const HuffmanTreeCode* codes = huffman_codes + 5 * histogram_ix;
595    VP8LRefsCursor c = VP8LRefsCursorInit(refs);
596    while (VP8LRefsCursorOk(&c)) {
597      const PixOrCopy* const v = c.cur_pos;
598      if ((tile_x != (x & tile_mask)) || (tile_y != (y & tile_mask))) {
599        tile_x = x & tile_mask;
600        tile_y = y & tile_mask;
601        histogram_ix = histogram_symbols[(y >> histo_bits) * histo_xsize +
602                                         (x >> histo_bits)];
603        codes = huffman_codes + 5 * histogram_ix;
604      }
605      if (PixOrCopyIsLiteral(v)) {
606        static const uint8_t order[] = { 1, 2, 0, 3 };
607        int k;
608        for (k = 0; k < 4; ++k) {
609          const int code = PixOrCopyLiteral(v, order[k]);
610          WriteHuffmanCode(bw, codes + k, code);
611        }
612      } else if (PixOrCopyIsCacheIdx(v)) {
613        const int code = PixOrCopyCacheIdx(v);
614        const int literal_ix = 256 + NUM_LENGTH_CODES + code;
615        WriteHuffmanCode(bw, codes, literal_ix);
616      } else {
617        int bits, n_bits;
618        int code;
619        const int distance = PixOrCopyDistance(v);
620        VP8LPrefixEncode(v->len, &code, &n_bits, &bits);
621        WriteHuffmanCodeWithExtraBits(bw, codes, 256 + code, bits, n_bits);
622        VP8LPrefixEncode(distance, &code, &n_bits, &bits);
623        WriteHuffmanCode(bw, codes + 4, code);
624        VP8LPutBits(bw, bits, n_bits);
625      }
626      x += PixOrCopyLength(v);
627      while (x >= width) {
628        x -= width;
629        ++y;
630      }
631      VP8LRefsCursorNext(&c);
632    }
633    return bw->error_ ? VP8_ENC_ERROR_OUT_OF_MEMORY : VP8_ENC_OK;
634  }
635  static WebPEncodingError EncodeImageNoHuffman(VP8LBitWriter* const bw,
636                                                const uint32_t* const argb,
637                                                VP8LHashChain* const hash_chain,
638                                                VP8LBackwardRefs* const refs_tmp1,
639                                                VP8LBackwardRefs* const refs_tmp2,
640                                                int width, int height,
641                                                int quality, int low_effort) {
642    int i;
643    int max_tokens = 0;
644    WebPEncodingError err = VP8_ENC_OK;
645    VP8LBackwardRefs* refs;
646    HuffmanTreeToken* tokens = NULL;
647    HuffmanTreeCode huffman_codes[5] = { { 0, NULL, NULL } };
648    const uint16_t histogram_symbols[1] = { 0 };    
649    int cache_bits = 0;
650    VP8LHistogramSet* histogram_image = NULL;
651    HuffmanTree* const huff_tree = (HuffmanTree*)WebPSafeMalloc(
652          3ULL * CODE_LENGTH_CODES, sizeof(*huff_tree));
653    if (huff_tree == NULL) {
654      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
655      goto Error;
656    }
657    if (!VP8LHashChainFill(hash_chain, quality, argb, width, height,
658                           low_effort)) {
659      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
660      goto Error;
661    }
662    refs = VP8LGetBackwardReferences(width, height, argb, quality, 0,
663                                     kLZ77Standard | kLZ77RLE, &cache_bits,
664                                     hash_chain, refs_tmp1, refs_tmp2);
665    if (refs == NULL) {
666      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
667      goto Error;
668    }
669    histogram_image = VP8LAllocateHistogramSet(1, cache_bits);
670    if (histogram_image == NULL) {
671      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
672      goto Error;
673    }
674    VP8LHistogramSetClear(histogram_image);
675    VP8LHistogramStoreRefs(refs, histogram_image->histograms[0]);
676    assert(histogram_image->size == 1);
677    if (!GetHuffBitLengthsAndCodes(histogram_image, huffman_codes)) {
678      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
679      goto Error;
680    }
681    VP8LPutBits(bw, 0, 1);
682    for (i = 0; i < 5; ++i) {
683      HuffmanTreeCode* const codes = &huffman_codes[i];
684      if (max_tokens < codes->num_symbols) {
685        max_tokens = codes->num_symbols;
686      }
687    }
688    tokens = (HuffmanTreeToken*)WebPSafeMalloc(max_tokens, sizeof(*tokens));
689    if (tokens == NULL) {
690      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
691      goto Error;
692    }
693    for (i = 0; i < 5; ++i) {
694      HuffmanTreeCode* const codes = &huffman_codes[i];
695      StoreHuffmanCode(bw, huff_tree, tokens, codes);
696      ClearHuffmanTreeIfOnlyOneSymbol(codes);
697    }
698    err = StoreImageToBitMask(bw, width, 0, refs, histogram_symbols,
699                              huffman_codes);
700   Error:
701    WebPSafeFree(tokens);
702    WebPSafeFree(huff_tree);
703    VP8LFreeHistogramSet(histogram_image);
704    WebPSafeFree(huffman_codes[0].codes);
705    return err;
706  }
707  static WebPEncodingError EncodeImageInternal(
708      VP8LBitWriter* const bw, const uint32_t* const argb,
709      VP8LHashChain* const hash_chain, VP8LBackwardRefs refs_array[3], int width,
710      int height, int quality, int low_effort, int use_cache,
711      const CrunchConfig* const config, int* cache_bits, int histogram_bits,
712      size_t init_byte_position, int* const hdr_size, int* const data_size) {
713    WebPEncodingError err = VP8_ENC_OK;
714    const uint32_t histogram_image_xysize =
715        VP8LSubSampleSize(width, histogram_bits) *
716        VP8LSubSampleSize(height, histogram_bits);
717    VP8LHistogramSet* histogram_image = NULL;
718    VP8LHistogram* tmp_histo = NULL;
719    int histogram_image_size = 0;
720    size_t bit_array_size = 0;
721    HuffmanTree* const huff_tree = (HuffmanTree*)WebPSafeMalloc(
722        3ULL * CODE_LENGTH_CODES, sizeof(*huff_tree));
723    HuffmanTreeToken* tokens = NULL;
724    HuffmanTreeCode* huffman_codes = NULL;
725    VP8LBackwardRefs* refs_best;
726    VP8LBackwardRefs* refs_tmp;
727    uint16_t* const histogram_symbols =
728        (uint16_t*)WebPSafeMalloc(histogram_image_xysize,
729                                  sizeof(*histogram_symbols));
730    int lz77s_idx;
731    VP8LBitWriter bw_init = *bw, bw_best;
732    int hdr_size_tmp;
733    assert(histogram_bits >= MIN_HUFFMAN_BITS);
734    assert(histogram_bits <= MAX_HUFFMAN_BITS);
735    assert(hdr_size != NULL);
736    assert(data_size != NULL);
737    if (histogram_symbols == NULL) {
738      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
739      goto Error;
740    }
741    if (use_cache) {
742      if (*cache_bits == 0) *cache_bits = MAX_COLOR_CACHE_BITS;
743    } else {
744      *cache_bits = 0;
745    }
746    if (huff_tree == NULL ||
747        !VP8LHashChainFill(hash_chain, quality, argb, width, height,
748                           low_effort) ||
749        !VP8LBitWriterInit(&bw_best, 0) ||
750        (config->lz77s_types_to_try_size_ > 1 &&
751         !VP8LBitWriterClone(bw, &bw_best))) {
752      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
753      goto Error;
754    }
755    for (lz77s_idx = 0; lz77s_idx < config->lz77s_types_to_try_size_;
756         ++lz77s_idx) {
757      refs_best = VP8LGetBackwardReferences(
758          width, height, argb, quality, low_effort,
759          config->lz77s_types_to_try_[lz77s_idx], cache_bits, hash_chain,
760          &refs_array[0], &refs_array[1]);
761      if (refs_best == NULL) {
762        err = VP8_ENC_ERROR_OUT_OF_MEMORY;
763        goto Error;
764      }
765      refs_tmp = &refs_array[refs_best == &refs_array[0] ? 1 : 0];
766      histogram_image =
767          VP8LAllocateHistogramSet(histogram_image_xysize, *cache_bits);
768      tmp_histo = VP8LAllocateHistogram(*cache_bits);
769      if (histogram_image == NULL || tmp_histo == NULL) {
770        err = VP8_ENC_ERROR_OUT_OF_MEMORY;
771        goto Error;
772      }
773      if (!VP8LGetHistoImageSymbols(width, height, refs_best, quality, low_effort,
774                                    histogram_bits, *cache_bits, histogram_image,
775                                    tmp_histo, histogram_symbols)) {
776        err = VP8_ENC_ERROR_OUT_OF_MEMORY;
777        goto Error;
778      }
779      histogram_image_size = histogram_image->size;
780      bit_array_size = 5 * histogram_image_size;
781      huffman_codes = (HuffmanTreeCode*)WebPSafeCalloc(bit_array_size,
782                                                       sizeof(*huffman_codes));
783      if (huffman_codes == NULL ||
784          !GetHuffBitLengthsAndCodes(histogram_image, huffman_codes)) {
785        err = VP8_ENC_ERROR_OUT_OF_MEMORY;
786        goto Error;
787      }
788      VP8LFreeHistogramSet(histogram_image);
789      histogram_image = NULL;
790      VP8LFreeHistogram(tmp_histo);
791      tmp_histo = NULL;
792      if (*cache_bits > 0) {
793        VP8LPutBits(bw, 1, 1);
794        VP8LPutBits(bw, *cache_bits, 4);
795      } else {
796        VP8LPutBits(bw, 0, 1);
797      }
798      {
799        const int write_histogram_image = (histogram_image_size > 1);
800        VP8LPutBits(bw, write_histogram_image, 1);
801        if (write_histogram_image) {
802          uint32_t* const histogram_argb =
803              (uint32_t*)WebPSafeMalloc(histogram_image_xysize,
804                                        sizeof(*histogram_argb));
805          int max_index = 0;
806          uint32_t i;
807          if (histogram_argb == NULL) {
808            err = VP8_ENC_ERROR_OUT_OF_MEMORY;
809            goto Error;
810          }
811          for (i = 0; i < histogram_image_xysize; ++i) {
812            const int symbol_index = histogram_symbols[i] & 0xffff;
813            histogram_argb[i] = (symbol_index << 8);
814            if (symbol_index >= max_index) {
815              max_index = symbol_index + 1;
816            }
817          }
818          histogram_image_size = max_index;
819          VP8LPutBits(bw, histogram_bits - 2, 3);
820          err = EncodeImageNoHuffman(
821              bw, histogram_argb, hash_chain, refs_tmp, &refs_array[2],
822              VP8LSubSampleSize(width, histogram_bits),
823              VP8LSubSampleSize(height, histogram_bits), quality, low_effort);
824          WebPSafeFree(histogram_argb);
825          if (err != VP8_ENC_OK) goto Error;
826        }
827      }
828      {
829        int i;
830        int max_tokens = 0;
831        for (i = 0; i < 5 * histogram_image_size; ++i) {
832          HuffmanTreeCode* const codes = &huffman_codes[i];
833          if (max_tokens < codes->num_symbols) {
834            max_tokens = codes->num_symbols;
835          }
836        }
837        tokens = (HuffmanTreeToken*)WebPSafeMalloc(max_tokens, sizeof(*tokens));
838        if (tokens == NULL) {
839          err = VP8_ENC_ERROR_OUT_OF_MEMORY;
840          goto Error;
841        }
842        for (i = 0; i < 5 * histogram_image_size; ++i) {
843          HuffmanTreeCode* const codes = &huffman_codes[i];
844          StoreHuffmanCode(bw, huff_tree, tokens, codes);
845          ClearHuffmanTreeIfOnlyOneSymbol(codes);
846        }
847      }
848      hdr_size_tmp = (int)(VP8LBitWriterNumBytes(bw) - init_byte_position);
849      err = StoreImageToBitMask(bw, width, histogram_bits, refs_best,
850                                histogram_symbols, huffman_codes);
851      if (lz77s_idx == 0 ||
852          VP8LBitWriterNumBytes(bw) < VP8LBitWriterNumBytes(&bw_best)) {
853        *hdr_size = hdr_size_tmp;
854        *data_size =
855            (int)(VP8LBitWriterNumBytes(bw) - init_byte_position - *hdr_size);
856        VP8LBitWriterSwap(bw, &bw_best);
857      }
858      if (config->lz77s_types_to_try_size_ > 1) VP8LBitWriterReset(&bw_init, bw);
859      WebPSafeFree(tokens);
860      tokens = NULL;
861      if (huffman_codes != NULL) {
862        WebPSafeFree(huffman_codes->codes);
863        WebPSafeFree(huffman_codes);
864        huffman_codes = NULL;
865      }
866    }
867    VP8LBitWriterSwap(bw, &bw_best);
868   Error:
869    WebPSafeFree(tokens);
870    WebPSafeFree(huff_tree);
871    VP8LFreeHistogramSet(histogram_image);
872    VP8LFreeHistogram(tmp_histo);
873    if (huffman_codes != NULL) {
874      WebPSafeFree(huffman_codes->codes);
875      WebPSafeFree(huffman_codes);
876    }
877    WebPSafeFree(histogram_symbols);
878    VP8LBitWriterWipeOut(&bw_best);
879    return err;
880  }
881  static void ApplySubtractGreen(VP8LEncoder* const enc, int width, int height,
882                                 VP8LBitWriter* const bw) {
883    VP8LPutBits(bw, TRANSFORM_PRESENT, 1);
884    VP8LPutBits(bw, SUBTRACT_GREEN, 2);
885    VP8LSubtractGreenFromBlueAndRed(enc->argb_, width * height);
886  }
887  static WebPEncodingError ApplyPredictFilter(const VP8LEncoder* const enc,
888                                              int width, int height,
889                                              int quality, int low_effort,
890                                              int used_subtract_green,
891                                              VP8LBitWriter* const bw) {
892    const int pred_bits = enc->transform_bits_;
893    const int transform_width = VP8LSubSampleSize(width, pred_bits);
894    const int transform_height = VP8LSubSampleSize(height, pred_bits);
895    const int near_lossless_strength = enc->use_palette_ ? 100
896                                     : enc->config_->near_lossless;
897    VP8LResidualImage(width, height, pred_bits, low_effort, enc->argb_,
898                      enc->argb_scratch_, enc->transform_data_,
899                      near_lossless_strength, enc->config_->exact,
900                      used_subtract_green);
901    VP8LPutBits(bw, TRANSFORM_PRESENT, 1);
902    VP8LPutBits(bw, PREDICTOR_TRANSFORM, 2);
903    assert(pred_bits >= 2);
904    VP8LPutBits(bw, pred_bits - 2, 3);
905    return EncodeImageNoHuffman(
906        bw, enc->transform_data_, (VP8LHashChain*)&enc->hash_chain_,
907        (VP8LBackwardRefs*)&enc->refs_[0],  
908        (VP8LBackwardRefs*)&enc->refs_[1], transform_width, transform_height,
909        quality, low_effort);
910  }
911  static WebPEncodingError ApplyCrossColorFilter(const VP8LEncoder* const enc,
912                                                 int width, int height,
913                                                 int quality, int low_effort,
914                                                 VP8LBitWriter* const bw) {
915    const int ccolor_transform_bits = enc->transform_bits_;
916    const int transform_width = VP8LSubSampleSize(width, ccolor_transform_bits);
917    const int transform_height = VP8LSubSampleSize(height, ccolor_transform_bits);
918    VP8LColorSpaceTransform(width, height, ccolor_transform_bits, quality,
919                            enc->argb_, enc->transform_data_);
920    VP8LPutBits(bw, TRANSFORM_PRESENT, 1);
921    VP8LPutBits(bw, CROSS_COLOR_TRANSFORM, 2);
922    assert(ccolor_transform_bits >= 2);
923    VP8LPutBits(bw, ccolor_transform_bits - 2, 3);
924    return EncodeImageNoHuffman(
925        bw, enc->transform_data_, (VP8LHashChain*)&enc->hash_chain_,
926        (VP8LBackwardRefs*)&enc->refs_[0],  
927        (VP8LBackwardRefs*)&enc->refs_[1], transform_width, transform_height,
928        quality, low_effort);
929  }
930  static WebPEncodingError WriteRiffHeader(const WebPPicture* const pic,
931                                           size_t riff_size, size_t vp8l_size) {
932    uint8_t riff[RIFF_HEADER_SIZE + CHUNK_HEADER_SIZE + VP8L_SIGNATURE_SIZE] = {
933      'R', 'I', 'F', 'F', 0, 0, 0, 0, 'W', 'E', 'B', 'P',
934      'V', 'P', '8', 'L', 0, 0, 0, 0, VP8L_MAGIC_BYTE,
935    };
936    PutLE32(riff + TAG_SIZE, (uint32_t)riff_size);
937    PutLE32(riff + RIFF_HEADER_SIZE + TAG_SIZE, (uint32_t)vp8l_size);
938    if (!pic->writer(riff, sizeof(riff), pic)) {
939      return VP8_ENC_ERROR_BAD_WRITE;
940    }
941    return VP8_ENC_OK;
942  }
943  static int WriteImageSize(const WebPPicture* const pic,
944                            VP8LBitWriter* const bw) {
945    const int width = pic->width - 1;
946    const int height = pic->height - 1;
947    assert(width < WEBP_MAX_DIMENSION && height < WEBP_MAX_DIMENSION);
948    VP8LPutBits(bw, width, VP8L_IMAGE_SIZE_BITS);
949    VP8LPutBits(bw, height, VP8L_IMAGE_SIZE_BITS);
950    return !bw->error_;
951  }
952  static int WriteRealAlphaAndVersion(VP8LBitWriter* const bw, int has_alpha) {
953    VP8LPutBits(bw, has_alpha, 1);
954    VP8LPutBits(bw, VP8L_VERSION, VP8L_VERSION_BITS);
955    return !bw->error_;
956  }
957  static WebPEncodingError WriteImage(const WebPPicture* const pic,
958                                      VP8LBitWriter* const bw,
959                                      size_t* const coded_size) {
960    WebPEncodingError err = VP8_ENC_OK;
961    const uint8_t* const webpll_data = VP8LBitWriterFinish(bw);
962    const size_t webpll_size = VP8LBitWriterNumBytes(bw);
963    const size_t vp8l_size = VP8L_SIGNATURE_SIZE + webpll_size;
964    const size_t pad = vp8l_size & 1;
965    const size_t riff_size = TAG_SIZE + CHUNK_HEADER_SIZE + vp8l_size + pad;
966    err = WriteRiffHeader(pic, riff_size, vp8l_size);
967    if (err != VP8_ENC_OK) goto Error;
968    if (!pic->writer(webpll_data, webpll_size, pic)) {
969      err = VP8_ENC_ERROR_BAD_WRITE;
970      goto Error;
971    }
972    if (pad) {
973      const uint8_t pad_byte[1] = { 0 };
974      if (!pic->writer(pad_byte, 1, pic)) {
975        err = VP8_ENC_ERROR_BAD_WRITE;
976        goto Error;
977      }
978    }
979    *coded_size = CHUNK_HEADER_SIZE + riff_size;
980    return VP8_ENC_OK;
981   Error:
982    return err;
983  }
984  static void ClearTransformBuffer(VP8LEncoder* const enc) {
985    WebPSafeFree(enc->transform_mem_);
986    enc->transform_mem_ = NULL;
987    enc->transform_mem_size_ = 0;
988  }
989  static WebPEncodingError AllocateTransformBuffer(VP8LEncoder* const enc,
990                                                   int width, int height) {
991    WebPEncodingError err = VP8_ENC_OK;
992    const uint64_t image_size = width * height;
993    const uint64_t argb_scratch_size =
994        enc->use_predict_
995            ? (width + 1) * 2 +
996              (width * 2 + sizeof(uint32_t) - 1) / sizeof(uint32_t)
997            : 0;
998    const uint64_t transform_data_size =
999        (enc->use_predict_ || enc->use_cross_color_)
1000            ? VP8LSubSampleSize(width, enc->transform_bits_) *
1001                  VP8LSubSampleSize(height, enc->transform_bits_)
1002            : 0;
1003    const uint64_t max_alignment_in_words =
1004        (WEBP_ALIGN_CST + sizeof(uint32_t) - 1) / sizeof(uint32_t);
1005    const uint64_t mem_size =
1006        image_size + max_alignment_in_words +
1007        argb_scratch_size + max_alignment_in_words +
1008        transform_data_size;
1009    uint32_t* mem = enc->transform_mem_;
1010    if (mem == NULL || mem_size > enc->transform_mem_size_) {
1011      ClearTransformBuffer(enc);
1012      mem = (uint32_t*)WebPSafeMalloc(mem_size, sizeof(*mem));
1013      if (mem == NULL) {
1014        err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1015        goto Error;
1016      }
1017      enc->transform_mem_ = mem;
1018      enc->transform_mem_size_ = (size_t)mem_size;
1019      enc->argb_content_ = kEncoderNone;
1020    }
1021    enc->argb_ = mem;
1022    mem = (uint32_t*)WEBP_ALIGN(mem + image_size);
1023    enc->argb_scratch_ = mem;
1024    mem = (uint32_t*)WEBP_ALIGN(mem + argb_scratch_size);
1025    enc->transform_data_ = mem;
1026    enc->current_width_ = width;
1027   Error:
1028    return err;
1029  }
1030  static WebPEncodingError MakeInputImageCopy(VP8LEncoder* const enc) {
1031    WebPEncodingError err = VP8_ENC_OK;
1032    const WebPPicture* const picture = enc->pic_;
1033    const int width = picture->width;
1034    const int height = picture->height;
1035    err = AllocateTransformBuffer(enc, width, height);
1036    if (err != VP8_ENC_OK) return err;
1037    if (enc->argb_content_ == kEncoderARGB) return VP8_ENC_OK;
1038    {
1039      uint32_t* dst = enc->argb_;
1040      const uint32_t* src = picture->argb;
1041      int y;
1042      for (y = 0; y < height; ++y) {
1043        memcpy(dst, src, width * sizeof(*dst));
1044        dst += width;
1045        src += picture->argb_stride;
1046      }
1047    }
1048    enc->argb_content_ = kEncoderARGB;
1049    assert(enc->current_width_ == width);
1050    return VP8_ENC_OK;
1051  }
1052  static WEBP_INLINE int SearchColorNoIdx(const uint32_t sorted[], uint32_t color,
1053                                          int hi) {
1054    int low = 0;
1055    if (sorted[low] == color) return low;  
1056    while (1) {
1057      const int mid = (low + hi) >> 1;
1058      if (sorted[mid] == color) {
1059        return mid;
1060      } else if (sorted[mid] < color) {
1061        low = mid;
1062      } else {
1063        hi = mid;
1064      }
1065    }
1066  }
1067  #define APPLY_PALETTE_GREEDY_MAX 4
1068  static WEBP_INLINE uint32_t SearchColorGreedy(const uint32_t palette[],
1069                                                int palette_size,
1070                                                uint32_t color) {
1071    (void)palette_size;
1072    assert(palette_size < APPLY_PALETTE_GREEDY_MAX);
1073    assert(3 == APPLY_PALETTE_GREEDY_MAX - 1);
1074    if (color == palette[0]) return 0;
1075    if (color == palette[1]) return 1;
1076    if (color == palette[2]) return 2;
1077    return 3;
1078  }
1079  static WEBP_INLINE uint32_t ApplyPaletteHash0(uint32_t color) {
1080    return (color >> 8) & 0xff;
1081  }
1082  #define PALETTE_INV_SIZE_BITS 11
1083  #define PALETTE_INV_SIZE (1 << PALETTE_INV_SIZE_BITS)
1084  static WEBP_INLINE uint32_t ApplyPaletteHash1(uint32_t color) {
1085    return ((uint32_t)((color & 0x00ffffffu) * 4222244071ull)) >>
1086           (32 - PALETTE_INV_SIZE_BITS);
1087  }
1088  static WEBP_INLINE uint32_t ApplyPaletteHash2(uint32_t color) {
1089    return ((uint32_t)((color & 0x00ffffffu) * ((1ull << 31) - 1))) >>
1090           (32 - PALETTE_INV_SIZE_BITS);
1091  }
1092  static void PrepareMapToPalette(const uint32_t palette[], int num_colors,
1093                                  uint32_t sorted[], uint32_t idx_map[]) {
1094    int i;
1095    memcpy(sorted, palette, num_colors * sizeof(*sorted));
1096    qsort(sorted, num_colors, sizeof(*sorted), PaletteCompareColorsForQsort);
1097    for (i = 0; i < num_colors; ++i) {
1098      idx_map[SearchColorNoIdx(sorted, palette[i], num_colors)] = i;
1099    }
1100  }
1101  #define APPLY_PALETTE_FOR(COLOR_INDEX) do {         \
1102    uint32_t prev_pix = palette[0];                   \
1103    uint32_t prev_idx = 0;                            \
1104    for (y = 0; y < height; ++y) {                    \
1105      for (x = 0; x < width; ++x) {                   \
1106        const uint32_t pix = src[x];                  \
1107        if (pix != prev_pix) {                        \
1108          prev_idx = COLOR_INDEX;                     \
1109          prev_pix = pix;                             \
1110        }                                             \
1111        tmp_row[x] = prev_idx;                        \
1112      }                                               \
1113      VP8LBundleColorMap(tmp_row, width, xbits, dst); \
1114      src += src_stride;                              \
1115      dst += dst_stride;                              \
1116    }                                                 \
1117  } while (0)
1118  static WebPEncodingError ApplyPalette(const uint32_t* src, uint32_t src_stride,
1119                                        uint32_t* dst, uint32_t dst_stride,
1120                                        const uint32_t* palette, int palette_size,
1121                                        int width, int height, int xbits) {
1122    uint8_t* const tmp_row = (uint8_t*)WebPSafeMalloc(width, sizeof(*tmp_row));
1123    int x, y;
1124    if (tmp_row == NULL) return VP8_ENC_ERROR_OUT_OF_MEMORY;
1125    if (palette_size < APPLY_PALETTE_GREEDY_MAX) {
1126      APPLY_PALETTE_FOR(SearchColorGreedy(palette, palette_size, pix));
1127    } else {
1128      int i, j;
1129      uint16_t buffer[PALETTE_INV_SIZE];
1130      uint32_t (*const hash_functions[])(uint32_t) = {
1131          ApplyPaletteHash0, ApplyPaletteHash1, ApplyPaletteHash2
1132      };
1133      for (i = 0; i < 3; ++i) {
1134        int use_LUT = 1;
1135        memset(buffer, 0xff, sizeof(buffer));
1136        for (j = 0; j < palette_size; ++j) {
1137          const uint32_t ind = hash_functions[i](palette[j]);
1138          if (buffer[ind] != 0xffffu) {
1139            use_LUT = 0;
1140            break;
1141          } else {
1142            buffer[ind] = j;
1143          }
1144        }
1145        if (use_LUT) break;
1146      }
1147      if (i == 0) {
1148        APPLY_PALETTE_FOR(buffer[ApplyPaletteHash0(pix)]);
1149      } else if (i == 1) {
1150        APPLY_PALETTE_FOR(buffer[ApplyPaletteHash1(pix)]);
1151      } else if (i == 2) {
1152        APPLY_PALETTE_FOR(buffer[ApplyPaletteHash2(pix)]);
1153      } else {
1154        uint32_t idx_map[MAX_PALETTE_SIZE];
1155        uint32_t palette_sorted[MAX_PALETTE_SIZE];
1156        PrepareMapToPalette(palette, palette_size, palette_sorted, idx_map);
1157        APPLY_PALETTE_FOR(
1158            idx_map[SearchColorNoIdx(palette_sorted, pix, palette_size)]);
1159      }
1160    }
1161    WebPSafeFree(tmp_row);
1162    return VP8_ENC_OK;
1163  }
1164  #undef APPLY_PALETTE_FOR
1165  #undef PALETTE_INV_SIZE_BITS
1166  #undef PALETTE_INV_SIZE
1167  #undef APPLY_PALETTE_GREEDY_MAX
1168  static WebPEncodingError MapImageFromPalette(VP8LEncoder* const enc,
1169                                               int in_place) {
1170    WebPEncodingError err = VP8_ENC_OK;
1171    const WebPPicture* const pic = enc->pic_;
1172    const int width = pic->width;
1173    const int height = pic->height;
1174    const uint32_t* const palette = enc->palette_;
1175    const uint32_t* src = in_place ? enc->argb_ : pic->argb;
1176    const int src_stride = in_place ? enc->current_width_ : pic->argb_stride;
1177    const int palette_size = enc->palette_size_;
1178    int xbits;
1179    if (palette_size <= 4) {
1180      xbits = (palette_size <= 2) ? 3 : 2;
1181    } else {
1182      xbits = (palette_size <= 16) ? 1 : 0;
1183    }
1184    err = AllocateTransformBuffer(enc, VP8LSubSampleSize(width, xbits), height);
1185    if (err != VP8_ENC_OK) return err;
1186    err = ApplyPalette(src, src_stride,
1187                       enc->argb_, enc->current_width_,
1188                       palette, palette_size, width, height, xbits);
1189    enc->argb_content_ = kEncoderPalette;
1190    return err;
1191  }
1192  static WebPEncodingError EncodePalette(VP8LBitWriter* const bw, int low_effort,
1193                                         VP8LEncoder* const enc) {
1194    int i;
1195    uint32_t tmp_palette[MAX_PALETTE_SIZE];
1196    const int palette_size = enc->palette_size_;
1197    const uint32_t* const palette = enc->palette_;
1198    VP8LPutBits(bw, TRANSFORM_PRESENT, 1);
1199    VP8LPutBits(bw, COLOR_INDEXING_TRANSFORM, 2);
1200    assert(palette_size >= 1 && palette_size <= MAX_PALETTE_SIZE);
1201    VP8LPutBits(bw, palette_size - 1, 8);
1202    for (i = palette_size - 1; i >= 1; --i) {
1203      tmp_palette[i] = VP8LSubPixels(palette[i], palette[i - 1]);
1204    }
1205    tmp_palette[0] = palette[0];
1206    return EncodeImageNoHuffman(bw, tmp_palette, &enc->hash_chain_,
1207                                &enc->refs_[0], &enc->refs_[1], palette_size, 1,
1208                                20 &bsol;* quality */, low_effort);
1209  }
1210  static VP8LEncoder* VP8LEncoderNew(const WebPConfig* const config,
1211                                     const WebPPicture* const picture) {
1212    VP8LEncoder* const enc = (VP8LEncoder*)WebPSafeCalloc(1ULL, sizeof(*enc));
1213    if (enc == NULL) {
1214      WebPEncodingSetError(picture, VP8_ENC_ERROR_OUT_OF_MEMORY);
1215      return NULL;
1216    }
1217    enc->config_ = config;
1218    enc->pic_ = picture;
1219    enc->argb_content_ = kEncoderNone;
1220    VP8LEncDspInit();
1221    return enc;
1222  }
1223  static void VP8LEncoderDelete(VP8LEncoder* enc) {
1224    if (enc != NULL) {
1225      int i;
1226      VP8LHashChainClear(&enc->hash_chain_);
1227      for (i = 0; i < 3; ++i) VP8LBackwardRefsClear(&enc->refs_[i]);
1228      ClearTransformBuffer(enc);
1229      WebPSafeFree(enc);
1230    }
1231  }
1232  typedef struct {
1233    const WebPConfig* config_;
1234    const WebPPicture* picture_;
1235    VP8LBitWriter* bw_;
1236    VP8LEncoder* enc_;
1237    int use_cache_;
1238    CrunchConfig crunch_configs_[CRUNCH_CONFIGS_MAX];
1239    int num_crunch_configs_;
1240    int red_and_blue_always_zero_;
1241    WebPEncodingError err_;
1242    WebPAuxStats* stats_;
1243  } StreamEncodeContext;
1244  static int EncodeStreamHook(void* input, void* data2) {
1245    StreamEncodeContext* const params = (StreamEncodeContext*)input;
1246    const WebPConfig* const config = params->config_;
1247    const WebPPicture* const picture = params->picture_;
1248    VP8LBitWriter* const bw = params->bw_;
1249    VP8LEncoder* const enc = params->enc_;
1250    const int use_cache = params->use_cache_;
1251    const CrunchConfig* const crunch_configs = params->crunch_configs_;
1252    const int num_crunch_configs = params->num_crunch_configs_;
1253    const int red_and_blue_always_zero = params->red_and_blue_always_zero_;
1254  #if !defined(WEBP_DISABLE_STATS)
1255    WebPAuxStats* const stats = params->stats_;
1256  #endif
1257    WebPEncodingError err = VP8_ENC_OK;
1258    const int quality = (int)config->quality;
1259    const int low_effort = (config->method == 0);
1260  #if (WEBP_NEAR_LOSSLESS == 1)
1261    const int width = picture->width;
1262  #endif
1263    const int height = picture->height;
1264    const size_t byte_position = VP8LBitWriterNumBytes(bw);
1265  #if (WEBP_NEAR_LOSSLESS == 1)
1266    int use_near_lossless = 0;
1267  #endif
1268    int hdr_size = 0;
1269    int data_size = 0;
1270    int use_delta_palette = 0;
1271    int idx;
1272    size_t best_size = 0;
1273    VP8LBitWriter bw_init = *bw, bw_best;
1274    (void)data2;
1275    if (!VP8LBitWriterInit(&bw_best, 0) ||
1276        (num_crunch_configs > 1 && !VP8LBitWriterClone(bw, &bw_best))) {
1277      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1278      goto Error;
1279    }
1280    for (idx = 0; idx < num_crunch_configs; ++idx) {
1281      const int entropy_idx = crunch_configs[idx].entropy_idx_;
1282      enc->use_palette_ = (entropy_idx == kPalette);
1283      enc->use_subtract_green_ =
1284          (entropy_idx == kSubGreen) || (entropy_idx == kSpatialSubGreen);
1285      enc->use_predict_ =
1286          (entropy_idx == kSpatial) || (entropy_idx == kSpatialSubGreen);
1287      if (low_effort) {
1288        enc->use_cross_color_ = 0;
1289      } else {
1290        enc->use_cross_color_ = red_and_blue_always_zero ? 0 : enc->use_predict_;
1291      }
1292      enc->cache_bits_ = 0;
1293      VP8LBackwardRefsClear(&enc->refs_[0]);
1294      VP8LBackwardRefsClear(&enc->refs_[1]);
1295  #if (WEBP_NEAR_LOSSLESS == 1)
1296      use_near_lossless = (config->near_lossless < 100) && !enc->use_palette_ &&
1297                          !enc->use_predict_;
1298      if (use_near_lossless) {
1299        err = AllocateTransformBuffer(enc, width, height);
1300        if (err != VP8_ENC_OK) goto Error;
1301        if ((enc->argb_content_ != kEncoderNearLossless) &&
1302            !VP8ApplyNearLossless(picture, config->near_lossless, enc->argb_)) {
1303          err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1304          goto Error;
1305        }
1306        enc->argb_content_ = kEncoderNearLossless;
1307      } else {
1308        enc->argb_content_ = kEncoderNone;
1309      }
1310  #else
1311      enc->argb_content_ = kEncoderNone;
1312  #endif
1313      if (enc->use_palette_) {
1314        err = EncodePalette(bw, low_effort, enc);
1315        if (err != VP8_ENC_OK) goto Error;
1316        err = MapImageFromPalette(enc, use_delta_palette);
1317        if (err != VP8_ENC_OK) goto Error;
1318        if (use_cache && enc->palette_size_ < (1 << MAX_COLOR_CACHE_BITS)) {
1319          enc->cache_bits_ = BitsLog2Floor(enc->palette_size_) + 1;
1320        }
1321      }
1322      if (!use_delta_palette) {
1323        if (enc->argb_content_ != kEncoderNearLossless &&
1324            enc->argb_content_ != kEncoderPalette) {
1325          err = MakeInputImageCopy(enc);
1326          if (err != VP8_ENC_OK) goto Error;
1327        }
1328        if (enc->use_subtract_green_) {
1329          ApplySubtractGreen(enc, enc->current_width_, height, bw);
1330        }
1331        if (enc->use_predict_) {
1332          err = ApplyPredictFilter(enc, enc->current_width_, height, quality,
1333                                   low_effort, enc->use_subtract_green_, bw);
1334          if (err != VP8_ENC_OK) goto Error;
1335        }
1336        if (enc->use_cross_color_) {
1337          err = ApplyCrossColorFilter(enc, enc->current_width_, height, quality,
1338                                      low_effort, bw);
1339          if (err != VP8_ENC_OK) goto Error;
1340        }
1341      }
1342      VP8LPutBits(bw, !TRANSFORM_PRESENT, 1);  
1343      err = EncodeImageInternal(bw, enc->argb_, &enc->hash_chain_, enc->refs_,
1344                                enc->current_width_, height, quality, low_effort,
1345                                use_cache, &crunch_configs[idx],
1346                                &enc->cache_bits_, enc->histo_bits_,
1347                                byte_position, &hdr_size, &data_size);
1348      if (err != VP8_ENC_OK) goto Error;
1349      if (idx == 0 || VP8LBitWriterNumBytes(bw) < best_size) {
1350        best_size = VP8LBitWriterNumBytes(bw);
1351        VP8LBitWriterSwap(bw, &bw_best);
1352  #if !defined(WEBP_DISABLE_STATS)
1353        if (stats != NULL) {
1354          stats->lossless_features = 0;
1355          if (enc->use_predict_) stats->lossless_features |= 1;
1356          if (enc->use_cross_color_) stats->lossless_features |= 2;
1357          if (enc->use_subtract_green_) stats->lossless_features |= 4;
1358          if (enc->use_palette_) stats->lossless_features |= 8;
1359          stats->histogram_bits = enc->histo_bits_;
1360          stats->transform_bits = enc->transform_bits_;
1361          stats->cache_bits = enc->cache_bits_;
1362          stats->palette_size = enc->palette_size_;
1363          stats->lossless_size = (int)(best_size - byte_position);
1364          stats->lossless_hdr_size = hdr_size;
1365          stats->lossless_data_size = data_size;
1366        }
1367  #endif
1368      }
1369      if (num_crunch_configs > 1) VP8LBitWriterReset(&bw_init, bw);
1370    }
1371    VP8LBitWriterSwap(&bw_best, bw);
1372  Error:
1373    VP8LBitWriterWipeOut(&bw_best);
1374    params->err_ = err;
1375    return (err == VP8_ENC_OK);
1376  }
1377  WebPEncodingError VP8LEncodeStream(const WebPConfig* const config,
1378                                     const WebPPicture* const picture,
1379                                     VP8LBitWriter* const bw_main,
1380                                     int use_cache) {
1381    WebPEncodingError err = VP8_ENC_OK;
1382    VP8LEncoder* const enc_main = VP8LEncoderNew(config, picture);
1383    VP8LEncoder* enc_side = NULL;
1384    CrunchConfig crunch_configs[CRUNCH_CONFIGS_MAX];
1385    int num_crunch_configs_main, num_crunch_configs_side = 0;
1386    int idx;
1387    int red_and_blue_always_zero = 0;
1388    WebPWorker worker_main, worker_side;
1389    StreamEncodeContext params_main, params_side;
1390    WebPAuxStats stats_side;
1391    VP8LBitWriter bw_side;
1392    const WebPWorkerInterface* const worker_interface = WebPGetWorkerInterface();
1393    int ok_main;
1394    if (enc_main == NULL ||
1395        !EncoderAnalyze(enc_main, crunch_configs, &num_crunch_configs_main,
1396                        &red_and_blue_always_zero) ||
1397        !EncoderInit(enc_main) || !VP8LBitWriterInit(&bw_side, 0)) {
1398      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1399      goto Error;
1400    }
1401    if (config->thread_level > 0) {
1402      num_crunch_configs_side = num_crunch_configs_main / 2;
1403      for (idx = 0; idx < num_crunch_configs_side; ++idx) {
1404        params_side.crunch_configs_[idx] =
1405            crunch_configs[num_crunch_configs_main - num_crunch_configs_side +
1406                           idx];
1407      }
1408      params_side.num_crunch_configs_ = num_crunch_configs_side;
1409    }
1410    num_crunch_configs_main -= num_crunch_configs_side;
1411    for (idx = 0; idx < num_crunch_configs_main; ++idx) {
1412      params_main.crunch_configs_[idx] = crunch_configs[idx];
1413    }
1414    params_main.num_crunch_configs_ = num_crunch_configs_main;
1415    {
1416      const int params_size = (num_crunch_configs_side > 0) ? 2 : 1;
1417      for (idx = 0; idx < params_size; ++idx) {
1418        WebPWorker* const worker = (idx == 0) ? &worker_main : &worker_side;
1419        StreamEncodeContext* const param =
1420            (idx == 0) ? &params_main : &params_side;
1421        param->config_ = config;
1422        param->picture_ = picture;
1423        param->use_cache_ = use_cache;
1424        param->red_and_blue_always_zero_ = red_and_blue_always_zero;
1425        if (idx == 0) {
1426          param->stats_ = picture->stats;
1427          param->bw_ = bw_main;
1428          param->enc_ = enc_main;
1429        } else {
1430          param->stats_ = (picture->stats == NULL) ? NULL : &stats_side;
1431          if (!VP8LBitWriterClone(bw_main, &bw_side)) {
1432            err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1433            goto Error;
1434          }
1435          param->bw_ = &bw_side;
1436          enc_side = VP8LEncoderNew(config, picture);
1437          if (enc_side == NULL || !EncoderInit(enc_side)) {
1438            err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1439            goto Error;
1440          }
1441          enc_side->histo_bits_ = enc_main->histo_bits_;
1442          enc_side->transform_bits_ = enc_main->transform_bits_;
1443          enc_side->palette_size_ = enc_main->palette_size_;
1444          memcpy(enc_side->palette_, enc_main->palette_,
1445                 sizeof(enc_main->palette_));
1446          param->enc_ = enc_side;
1447        }
1448        worker_interface->Init(worker);
1449        worker->data1 = param;
1450        worker->data2 = NULL;
1451        worker->hook = EncodeStreamHook;
1452      }
1453    }
1454    if (num_crunch_configs_side != 0) {
1455      if (!worker_interface->Reset(&worker_side)) {
1456        err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1457        goto Error;
1458      }
1459  #if !defined(WEBP_DISABLE_STATS)
1460      if (picture->stats != NULL) {
1461        memcpy(&stats_side, picture->stats, sizeof(stats_side));
1462      }
1463  #endif
1464      params_side.err_ = VP8_ENC_OK;
1465      worker_interface->Launch(&worker_side);
1466    }
1467    worker_interface->Execute(&worker_main);
1468    ok_main = worker_interface->Sync(&worker_main);
1469    worker_interface->End(&worker_main);
1470    if (num_crunch_configs_side != 0) {
1471      const int ok_side = worker_interface->Sync(&worker_side);
1472      worker_interface->End(&worker_side);
1473      if (!ok_main || !ok_side) {
1474        err = ok_main ? params_side.err_ : params_main.err_;
1475        goto Error;
1476      }
1477      if (VP8LBitWriterNumBytes(&bw_side) < VP8LBitWriterNumBytes(bw_main)) {
1478        VP8LBitWriterSwap(bw_main, &bw_side);
1479  #if !defined(WEBP_DISABLE_STATS)
1480        if (picture->stats != NULL) {
1481          memcpy(picture->stats, &stats_side, sizeof(*picture->stats));
1482        }
1483  #endif
1484      }
1485    } else {
1486      if (!ok_main) {
1487        err = params_main.err_;
1488        goto Error;
1489      }
1490    }
1491  Error:
1492    VP8LBitWriterWipeOut(&bw_side);
1493    VP8LEncoderDelete(enc_main);
1494    VP8LEncoderDelete(enc_side);
1495    return err;
1496  }
1497  #undef CRUNCH_CONFIGS_MAX
1498  #undef CRUNCH_CONFIGS_LZ77_MAX
1499  int VP8LEncodeImage(const WebPConfig* const config,
1500                      const WebPPicture* const picture) {
1501    int width, height;
1502    int has_alpha;
1503    size_t coded_size;
1504    int percent = 0;
1505    int initial_size;
1506    WebPEncodingError err = VP8_ENC_OK;
1507    VP8LBitWriter bw;
1508    if (picture == NULL) return 0;
1509    if (config == NULL || picture->argb == NULL) {
1510      err = VP8_ENC_ERROR_NULL_PARAMETER;
1511      WebPEncodingSetError(picture, err);
1512      return 0;
1513    }
1514    width = picture->width;
1515    height = picture->height;
1516    initial_size = (config->image_hint == WEBP_HINT_GRAPH) ?
1517        width * height : width * height * 2;
1518    if (!VP8LBitWriterInit(&bw, initial_size)) {
1519      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1520      goto Error;
1521    }
1522    if (!WebPReportProgress(picture, 1, &percent)) {
1523   UserAbort:
1524      err = VP8_ENC_ERROR_USER_ABORT;
1525      goto Error;
1526    }
1527    if (picture->stats != NULL) {
1528      WebPAuxStats* const stats = picture->stats;
1529      memset(stats, 0, sizeof(*stats));
1530      stats->PSNR[0] = 99.f;
1531      stats->PSNR[1] = 99.f;
1532      stats->PSNR[2] = 99.f;
1533      stats->PSNR[3] = 99.f;
1534      stats->PSNR[4] = 99.f;
1535    }
1536    if (!WriteImageSize(picture, &bw)) {
1537      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1538      goto Error;
1539    }
1540    has_alpha = WebPPictureHasTransparency(picture);
1541    if (!WriteRealAlphaAndVersion(&bw, has_alpha)) {
1542      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1543      goto Error;
1544    }
1545    if (!WebPReportProgress(picture, 5, &percent)) goto UserAbort;
1546    err = VP8LEncodeStream(config, picture, &bw, 1 &bsol;*use_cache*/);
1547    if (err != VP8_ENC_OK) goto Error;
1548    if (!WebPReportProgress(picture, 90, &percent)) goto UserAbort;
1549    err = WriteImage(picture, &bw, &coded_size);
1550    if (err != VP8_ENC_OK) goto Error;
1551    if (!WebPReportProgress(picture, 100, &percent)) goto UserAbort;
1552  #if !defined(WEBP_DISABLE_STATS)
1553    if (picture->stats != NULL) {
1554      picture->stats->coded_size += (int)coded_size;
1555      picture->stats->lossless_size = (int)coded_size;
1556    }
1557  #endif
1558    if (picture->extra_info != NULL) {
1559      const int mb_w = (width + 15) >> 4;
1560      const int mb_h = (height + 15) >> 4;
1561      memset(picture->extra_info, 0, mb_w * mb_h * sizeof(*picture->extra_info));
1562    }
1563   Error:
1564    if (bw.error_) err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1565    VP8LBitWriterWipeOut(&bw);
1566    if (err != VP8_ENC_OK) {
1567      WebPEncodingSetError(picture, err);
1568      return 0;
1569    }
1570    return 1;
1571  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_neon.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vp8l_enc.c</div>
                <div class="column column_space"><pre><code>55  static const uint8_t kBGRShuffle[3][8] = {
56    {  0,  1,  2,  4,  5,  6,  8,  9 },
57    { 10, 12, 13, 14, 16, 17, 18, 20 },
58    { 21, 22, 24, 25, 26, 28, 29, 30 }
</pre></code></div>
                <div class="column column_space"><pre><code>232          static const uint8_t kHistoPairs[5][2] = {
233            { kHistoRed, kHistoBlue },
234            { kHistoRedPred, kHistoBluePred },
235            { kHistoRedSubGreen, kHistoBlueSubGreen },
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    