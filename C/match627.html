<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for inf-text-default-insert-operation.c & inf-adopted-undo-grouping.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for inf-text-default-insert-operation.c & inf-adopted-undo-grouping.c
      </h3>
      <h1 align="center">
        15.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>inf-text-default-insert-operation.c (25.76687%)<TH>inf-adopted-undo-grouping.c (10.9375%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match627-0.html#0',2,'match627-1.html#0',3)" NAME="0">(97-143)<TD><A HREF="javascript:ZweiFrames('match627-0.html#0',2,'match627-1.html#0',3)" NAME="0">(509-550)</A><TD ALIGN=center><FONT COLOR="#ff0000">25</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match627-0.html#1',2,'match627-1.html#1',3)" NAME="1">(60-91)<TD><A HREF="javascript:ZweiFrames('match627-0.html#1',2,'match627-1.html#1',3)" NAME="1">(463-494)</A><TD ALIGN=center><FONT COLOR="#ad0000">17</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-default-insert-operation.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include &lt;libinftext/inf-text-default-insert-operation.h&gt;
#include &lt;libinftext/inf-text-default-delete-operation.h&gt;
#include &lt;libinftext/inf-text-insert-operation.h&gt;
#include &lt;libinftext/inf-text-delete-operation.h&gt;
#include &lt;libinftext/inf-text-buffer.h&gt;

#include &lt;libinfinity/adopted/inf-adopted-operation.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;

typedef struct _InfTextDefaultInsertOperationPrivate
  InfTextDefaultInsertOperationPrivate;
struct _InfTextDefaultInsertOperationPrivate {
  guint position;
  InfTextChunk* chunk;
};

enum {
  PROP_0,

  PROP_POSITION,
  PROP_CHUNK
};

#define INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_TYPE_DEFAULT_INSERT_OPERATION, InfTextDefaultInsertOperationPrivate))

static void inf_text_default_insert_operation_operation_iface_init(InfAdoptedOperationInterface* iface);
static void inf_text_default_insert_operation_insert_operation_iface_init(InfTextInsertOperationInterface* iface);
G_DEFINE_TYPE_WITH_CODE(InfTextDefaultInsertOperation, inf_text_default_insert_operation, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfTextDefaultInsertOperation)
  G_IMPLEMENT_INTERFACE(INF_ADOPTED_TYPE_OPERATION, inf_text_default_insert_operation_operation_iface_init)
  G_IMPLEMENT_INTERFACE(INF_TEXT_TYPE_INSERT_OPERATION, inf_text_default_insert_operation_insert_operation_iface_init))

static void
inf_text_default_insert_operation_init(
  InfTextDefaultInsertOperation* operation)
{
  InfTextDefaultInsertOperationPrivate* priv;
<A NAME="1"></A>  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);

  priv-&gt;position = 0;
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match627-1.html#1',3,'match627-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  priv-&gt;chunk = NULL;
}

static void
inf_text_default_insert_operation_finalize(GObject* object)
{
  InfTextDefaultInsertOperation* operation;
  InfTextDefaultInsertOperationPrivate* priv;

  operation = INF_TEXT_DEFAULT_INSERT_OPERATION(object);
  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);

  inf_text_chunk_free(priv-&gt;chunk);

  G_OBJECT_CLASS(inf_text_default_insert_operation_parent_class)-&gt;finalize(object);
}

static void
inf_text_default_insert_operation_set_property(GObject* object,
                                               guint prop_id,
                                               const GValue* value,
                                               GParamSpec* pspec)
{
  InfTextDefaultInsertOperation* operation;
  InfTextDefaultInsertOperationPrivate* priv;

  operation = INF_TEXT_DEFAULT_INSERT_OPERATION(object);
  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);

  switch(prop_id)
  {
  case PROP_POSITION:</B></FONT>
    priv-&gt;position = g_value_get_uint(value);
    break;
<A NAME="0"></A>  case PROP_CHUNK:
    g_assert(priv-&gt;chunk == NULL); /* construct only */
    priv-&gt;chunk = (InfTextChunk*)g_value_dup_boxed(value);
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match627-1.html#0',3,'match627-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_text_default_insert_operation_get_property(GObject* object,
                                               guint prop_id,
                                               GValue* value,
                                               GParamSpec* pspec)
{
  InfTextDefaultInsertOperation* operation;
  InfTextDefaultInsertOperationPrivate* priv;

  operation = INF_TEXT_DEFAULT_INSERT_OPERATION(object);
  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);

  switch(prop_id)
  {
  case PROP_POSITION:
    g_value_set_uint(value, priv-&gt;position);
    break;
  case PROP_CHUNK:
    g_value_set_boxed(value, priv-&gt;chunk);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static gboolean
inf_text_default_insert_operation_need_concurrency_id(
  InfAdoptedOperation* operation,
  InfAdoptedOperation* against)
{
  g_assert(INF_TEXT_IS_DEFAULT_INSERT_OPERATION(operation));

  return inf_text_insert_operation_need_concurrency_id(
    INF_TEXT_INSERT_OPERATION(operation),
    against
  );
}

static InfAdoptedOperation*</B></FONT>
inf_text_default_insert_operation_transform(InfAdoptedOperation* operation,
                                            InfAdoptedOperation* against,
                                            InfAdoptedOperation* op_lcs,
                                            InfAdoptedOperation* against_lcs,
                                            InfAdoptedConcurrencyId cid)
{
  g_assert(INF_TEXT_IS_DEFAULT_INSERT_OPERATION(operation));

  if(INF_TEXT_IS_INSERT_OPERATION(against))
  {
    g_assert(op_lcs == NULL ||
             INF_TEXT_IS_INSERT_OPERATION(op_lcs));
    g_assert(against_lcs == NULL ||
             INF_TEXT_IS_INSERT_OPERATION(against_lcs));

    return inf_text_insert_operation_transform_insert(
      INF_TEXT_INSERT_OPERATION(operation),
      INF_TEXT_INSERT_OPERATION(against),
      INF_TEXT_INSERT_OPERATION(op_lcs),
      INF_TEXT_INSERT_OPERATION(against_lcs),
      cid
    );
  }
  else if(INF_TEXT_IS_DELETE_OPERATION(against))
  {
    return inf_text_insert_operation_transform_delete(
      INF_TEXT_INSERT_OPERATION(operation),
      INF_TEXT_DELETE_OPERATION(against)
    );
  }
  else
  {
    g_assert_not_reached();
    return NULL;
  }
}

static InfAdoptedOperation*
inf_text_default_insert_operation_copy(InfAdoptedOperation* operation)
{
  InfTextDefaultInsertOperationPrivate* priv;
  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);

  return INF_ADOPTED_OPERATION(
    g_object_new(
      INF_TEXT_TYPE_DEFAULT_INSERT_OPERATION,
      &quot;position&quot;, priv-&gt;position,
      &quot;chunk&quot;, priv-&gt;chunk,
      NULL
    )
  );
}

static InfAdoptedOperationFlags
inf_text_default_insert_operation_get_flags(InfAdoptedOperation* operation)
{
  return INF_ADOPTED_OPERATION_AFFECTS_BUFFER |
         INF_ADOPTED_OPERATION_REVERSIBLE;
}

static gboolean
inf_text_default_insert_operation_apply(InfAdoptedOperation* operation,
                                        InfAdoptedUser* by,
                                        InfBuffer* buffer,
                                        GError** error)
{
  InfTextDefaultInsertOperationPrivate* priv;

  g_assert(INF_TEXT_IS_DEFAULT_INSERT_OPERATION(operation));
  g_assert(INF_TEXT_IS_BUFFER(buffer));

  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);

  if(priv-&gt;position &gt; inf_text_buffer_get_length(INF_TEXT_BUFFER(buffer)))
  {
    g_set_error_literal(
      error,
      g_quark_from_static_string(&quot;INF_TEXT_OPERATION_ERROR&quot;),
      INF_TEXT_OPERATION_ERROR_INVALID_INSERT,
      _(&quot;Attempt to insert text after the end of the document&quot;)
    );

    return FALSE;
  }
  else
  {
    inf_text_buffer_insert_chunk(
      INF_TEXT_BUFFER(buffer),
      priv-&gt;position,
      priv-&gt;chunk,
      INF_USER(by)
    );

    return TRUE;
  }
}

static InfAdoptedOperation*
inf_text_default_insert_operation_revert(InfAdoptedOperation* operation)
{
  InfTextDefaultInsertOperationPrivate* priv;
  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);

  return INF_ADOPTED_OPERATION(
    inf_text_default_delete_operation_new(priv-&gt;position, priv-&gt;chunk)
  );
}

static guint
inf_text_default_insert_operation_get_position(InfTextInsertOperation* op)
{
  return INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(op)-&gt;position;
}

static guint
inf_text_default_insert_operation_get_length(
  InfTextInsertOperation* operation)
{
  return inf_text_chunk_get_length(
    INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation)-&gt;chunk
  );
}

static InfTextInsertOperation*
inf_text_default_insert_operation_transform_position(
  InfTextInsertOperation* operation,
  guint position)
{
  InfTextDefaultInsertOperationPrivate* priv;
  GObject* result;

  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);

  result = g_object_new(
    INF_TEXT_TYPE_DEFAULT_INSERT_OPERATION,
    &quot;position&quot;, position,
    &quot;chunk&quot;, priv-&gt;chunk,
    NULL
  );

  return INF_TEXT_INSERT_OPERATION(result);
}

static void
inf_text_default_insert_operation_class_init(
  InfTextDefaultInsertOperationClass* default_insert_operation_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(default_insert_operation_class);

  object_class-&gt;finalize = inf_text_default_insert_operation_finalize;
  object_class-&gt;set_property =
    inf_text_default_insert_operation_set_property;
  object_class-&gt;get_property =
    inf_text_default_insert_operation_get_property;

  g_object_class_install_property(
    object_class,
    PROP_POSITION,
    g_param_spec_uint(
      &quot;position&quot;,
      &quot;Position&quot;,
      &quot;Insertion position&quot;,
      0,
      G_MAXUINT,
      0,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_CHUNK,
    g_param_spec_boxed(
      &quot;chunk&quot;,
      &quot;Chunk&quot;,
      &quot;The text to insert&quot;,
      INF_TEXT_TYPE_CHUNK,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
}

static void
inf_text_default_insert_operation_operation_iface_init(
  InfAdoptedOperationInterface* iface)
{
  iface-&gt;need_concurrency_id =
    inf_text_default_insert_operation_need_concurrency_id;
  iface-&gt;transform = inf_text_default_insert_operation_transform;
  iface-&gt;copy = inf_text_default_insert_operation_copy;
  iface-&gt;get_flags = inf_text_default_insert_operation_get_flags;
  iface-&gt;apply = inf_text_default_insert_operation_apply;
  iface-&gt;apply_transformed = NULL;
  iface-&gt;revert = inf_text_default_insert_operation_revert;
}

static void
inf_text_default_insert_operation_insert_operation_iface_init(
  InfTextInsertOperationInterface* iface)
{
  iface-&gt;get_position = inf_text_default_insert_operation_get_position;
  iface-&gt;get_length = inf_text_default_insert_operation_get_length;
  iface-&gt;transform_position =
    inf_text_default_insert_operation_transform_position;
}

/**
 * inf_text_default_insert_operation_new: (constructor)
 * @pos: The position at which to insert text.
 * @chunk: The text to insert.
 *
 * Creates a new insert operation that, when applied, inserts @chunk
 * at @pos.
 *
 * Returns: (transfer full): A new #InfTextDefaultInsertOperation.
 **/
InfTextDefaultInsertOperation*
inf_text_default_insert_operation_new(guint pos,
                                      InfTextChunk* chunk)
{
  GObject* object;

  g_return_val_if_fail(chunk != NULL, NULL);

  object = g_object_new(
    INF_TEXT_TYPE_DEFAULT_INSERT_OPERATION,
    &quot;position&quot;, pos,
    &quot;chunk&quot;, chunk,
    NULL
  );

  return INF_TEXT_DEFAULT_INSERT_OPERATION(object);
}

/**
 * inf_text_default_insert_operation_get_chunk:
 * @operation: A #InfTextDefaultInsertOperation.
 *
 * Returns the text inserted by @operation.
 *
 * Returns: (transfer none): A #InfTextChunk, owned by the operation.
 **/
InfTextChunk*
inf_text_default_insert_operation_get_chunk(InfTextDefaultInsertOperation* operation)
{
  g_return_val_if_fail(INF_TEXT_IS_DEFAULT_INSERT_OPERATION(operation), NULL);
  return INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation)-&gt;chunk;
}

/* vim:set et sw=2 ts=2: */
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-adopted-undo-grouping.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include &lt;libinfinity/adopted/inf-adopted-undo-grouping.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;

/**
 * SECTION:inf-adopted-undo-grouping
 * @title: InfAdoptedUndoGrouping
 * @short_description: Grouping of requests to be undone simultaneously
 * @include: libinfinity/adopted/inf-adopted-undo-grouping.h
 * @see_also: #InfAdoptedAlgorithm
 * @stability: Unstable
 *
 * #InfAdoptedUndoGrouping groups related requests together so that they can
 * be undone at the same time. For example, Undo in a text editor is normally
 * expected to operate on written words, not characters. Therefore, multiple
 * requests need to be undone at once.
 *
 * The undo grouping helps with this. Everytime it needs to decide whether two
 * requests should be grouped it emits
 * #InfAdoptedUndoGrouping::group-requests. If the signal handler returns
 * %TRUE then the two requests will be undone at the same time, otherwise not.
 *
 * It is also possible to explicitely group a bunch of requests that would
 * not be grouped otherwise, by calling inf_adopted_undo_grouping_start_group()
 * and inf_adopted_undo_grouping_end_group() before and after issuing the
 * requests, respectively.
 *
 * The default signal handler always returns %FALSE. However, this behaviour
 * can be changed in derived classes.
 */

typedef struct _InfAdoptedUndoGroupingItem InfAdoptedUndoGroupingItem;
struct _InfAdoptedUndoGroupingItem {
  InfAdoptedRequest* request;
  gboolean in_group;
};

typedef enum __InfAdoptedUndoGroupingFlags {
  /* allow grouping with items before explicit group */
  INF_ADOPTED_UNDO_GROUPING_ALLOW_WITH_PREV   = 1 &lt;&lt; 0,
  /* allow grouping with items after explicit group */
  INF_ADOPTED_UNDO_GROUPING_ALLOW_WITH_NEXT   = 1 &lt;&lt; 1,
  /* whether the next item is the first item inside an explicit group */
  INF_ADOPTED_UNDO_GROUPING_FIRST_IN_GROUP    = 1 &lt;&lt; 2,
  /* whether the next item is the first item after an explicit group */
  INF_ADOPTED_UNDO_GROUPING_FIRST_AFTER_GROUP = 1 &lt;&lt; 3
} InfAdoptedUndoGroupingFlags;

typedef struct _InfAdoptedUndoGroupingPrivate InfAdoptedUndoGroupingPrivate;
struct _InfAdoptedUndoGroupingPrivate {
  InfAdoptedAlgorithm* algorithm;
  InfAdoptedUser* user;

  InfAdoptedUndoGroupingItem* items;
  guint n_items;
  guint n_alloc;
  guint first_item;
  guint item_pos; /* relative to first_item */

  guint group_ref;
  guint group_flags;
};

enum {
  PROP_0,

  /* construct only */
  PROP_ALGORITHM,
  PROP_USER
};

enum {
  GROUP_REQUESTS,

  LAST_SIGNAL
};

#define INF_ADOPTED_UNDO_GROUPING_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_ADOPTED_TYPE_UNDO_GROUPING, InfAdoptedUndoGroupingPrivate))

static guint undo_grouping_signals[LAST_SIGNAL];

G_DEFINE_TYPE_WITH_CODE(InfAdoptedUndoGrouping, inf_adopted_undo_grouping, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfAdoptedUndoGrouping))

static void
inf_adopted_undo_grouping_add_request(InfAdoptedUndoGrouping* grouping,
                                      InfAdoptedRequest* request)
{
  InfAdoptedUndoGroupingPrivate* priv;
  guint max;
  InfAdoptedUndoGroupingItem* item;
  InfAdoptedUndoGroupingItem* prev_item;

  InfAdoptedUndoGroupingFlags flags;
  gboolean first_after_group;
  gboolean first_in_group;
  gboolean allow_with_next;
  gboolean allow_with_prev;

  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);

  switch(inf_adopted_request_get_request_type(request))
  {
  case INF_ADOPTED_REQUEST_DO:
    if(priv-&gt;first_item + priv-&gt;item_pos == priv-&gt;n_alloc)
    {
      /* The maximum number of requests that we ever need to hold is half of
       * the algorithm's max total log size, since undoing one of the requests
       * in the log takes another request. We add +1 because we add the new
       * request before removing the old one. */
      g_object_get(
        G_OBJECT(priv-&gt;algorithm),
        &quot;max-total-log-size&quot;, &amp;max,
        NULL
      );

      if(max != G_MAXUINT)
      {
        max = (max/2) + 1;

        /* Don't start to wrap around as long as we have not reached the max
         * buffer size. */
        if(priv-&gt;n_alloc &lt; max)
        {
          priv-&gt;n_alloc = MIN(priv-&gt;n_alloc * 2, max);
          priv-&gt;n_alloc = MAX(priv-&gt;n_alloc, MIN(16, max));

          priv-&gt;items = g_realloc(
            priv-&gt;items,
            priv-&gt;n_alloc * sizeof(InfAdoptedUndoGroupingItem)
          );
        }
      }
      else
      {
        priv-&gt;n_alloc = MAX(priv-&gt;n_alloc * 2, 16);

        priv-&gt;items = g_realloc(
          priv-&gt;items,
          priv-&gt;n_alloc * sizeof(InfAdoptedUndoGroupingItem)
        );
      }
    }

    /* Cut redo possibilities */
    priv-&gt;n_items = priv-&gt;item_pos;
    g_assert(priv-&gt;n_items &lt; priv-&gt;n_alloc);
    item = &amp;priv-&gt;items[(priv-&gt;first_item + priv-&gt;item_pos) % priv-&gt;n_alloc];

    item-&gt;request = request;
    g_object_ref(request);

    if(priv-&gt;item_pos &gt; 0)
    {
      flags = priv-&gt;group_flags;

      first_after_group =
        (flags &amp; INF_ADOPTED_UNDO_GROUPING_FIRST_AFTER_GROUP) != 0;
      first_in_group =
        (flags &amp; INF_ADOPTED_UNDO_GROUPING_FIRST_IN_GROUP) != 0;
      allow_with_next =
        (flags &amp; INF_ADOPTED_UNDO_GROUPING_ALLOW_WITH_NEXT) != 0;
      allow_with_prev =
        (flags &amp; INF_ADOPTED_UNDO_GROUPING_ALLOW_WITH_PREV) != 0;

      if(first_after_group &amp;&amp; !allow_with_next)
      {
        item-&gt;in_group = FALSE;
      }
      else if(priv-&gt;group_ref &gt; 0 &amp;&amp; first_in_group &amp;&amp; !allow_with_prev)
      {
        item-&gt;in_group = FALSE;
      }
      else if(priv-&gt;group_ref &gt; 0 &amp;&amp; !first_in_group)
      {
        item-&gt;in_group = TRUE;
      }
      else
      {
        prev_item = &amp;priv-&gt;items[
          (priv-&gt;first_item + priv-&gt;item_pos - 1) % priv-&gt;n_alloc
        ];

        g_signal_emit(
          G_OBJECT(grouping),
          undo_grouping_signals[GROUP_REQUESTS],
          0,
          prev_item-&gt;request,
          request,
          &amp;item-&gt;in_group
        );
      }
    }
    else
    {
      /* No previous request, so start group */
      item-&gt;in_group = FALSE;
    }

    priv-&gt;group_flags &amp;= ~(INF_ADOPTED_UNDO_GROUPING_FIRST_IN_GROUP |
                           INF_ADOPTED_UNDO_GROUPING_FIRST_AFTER_GROUP);

    ++priv-&gt;n_items;
    ++priv-&gt;item_pos;
    break;
  case INF_ADOPTED_REQUEST_UNDO:
    g_assert(priv-&gt;item_pos &gt; 0);
    --priv-&gt;item_pos;
    break;
  case INF_ADOPTED_REQUEST_REDO:
    g_assert(priv-&gt;item_pos &lt; priv-&gt;n_items);
    ++priv-&gt;item_pos;
    break;
  }
}

/* Remove requests that can no longer be undone from buffer */
static void
inf_adopted_undo_grouping_cleanup(InfAdoptedUndoGrouping* grouping)
{
  InfAdoptedUndoGroupingPrivate* priv;
  InfAdoptedUndoGroupingItem* item;
  guint max_total_log_size;
  guint vdiff;
  guint i;

  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
  g_assert(priv-&gt;user != NULL);

  g_object_get(
    priv-&gt;algorithm,
    &quot;max-total-log-size&quot;, &amp;max_total_log_size,
    NULL
  );

  if(max_total_log_size != G_MAXUINT)
  {
    while(priv-&gt;n_items &gt; 0)
    {
      item = &amp;priv-&gt;items[priv-&gt;first_item];

      vdiff = inf_adopted_state_vector_vdiff(
        inf_adopted_request_get_vector(item-&gt;request),
        inf_adopted_user_get_vector(priv-&gt;user)
      );

      if(vdiff + priv-&gt;item_pos &gt; max_total_log_size)
      {
        /* Request is too old to be undone, remove from buffer */
        if(priv-&gt;item_pos == 0)
        {
          /* Remove all items since we cannot redo the following anymore at
           * this point since the first one to redo is too old. */
          for(i = 0; i &lt; priv-&gt;n_items; ++i)
            g_object_unref(priv-&gt;items[(priv-&gt;first_item + i) % priv-&gt;n_alloc].request);
          priv-&gt;first_item = 0;
          priv-&gt;n_items = 0;
          break;
        }
        else
        {
          g_object_unref(item-&gt;request);

          /* Remove the request being too old */
          priv-&gt;first_item = (priv-&gt;first_item + 1) % priv-&gt;n_alloc;
          --priv-&gt;n_items;
          --priv-&gt;item_pos;

          /* Reuse buffer if we drop to zero */
          if(priv-&gt;n_items == 0)
            priv-&gt;first_item = 0;
          else
            priv-&gt;items[priv-&gt;first_item].in_group = FALSE;
        }
      }
      else
      {
        /* All OK */
        break;
      }
    }
  }
}

static void
inf_adopted_undo_grouping_add_request_cb(InfAdoptedRequestLog* log,
                                         InfAdoptedRequest* request,
                                         gpointer user_data)
{
  InfAdoptedUndoGrouping* grouping;
  grouping = INF_ADOPTED_UNDO_GROUPING(user_data);

  inf_adopted_undo_grouping_add_request(grouping, request);
}

static void
inf_adopted_undo_grouping_end_execute_request_cb(InfAdoptedAlgorithm* algo,
                                                 InfAdoptedUser* user,
                                                 InfAdoptedRequest* request,
                                                 InfAdoptedRequest* trans,
                                                 const GError* error,
                                                 gpointer user_data)
{
  InfAdoptedUndoGrouping* grouping;
  InfAdoptedUndoGroupingPrivate* priv;
  guint user_id;

  /* Note that this signal handler is called _after_ the request has been
   * executed and the buffer and local user vector times updated. If the
   * execution causes requests in the request log to be removed due to
   * algorithm cleanup, then this will still happen after the signal emission
   * though, so all requests in our buffers are still valid at this point. */

  grouping = INF_ADOPTED_UNDO_GROUPING(user_data);
  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);

  /* If the request does not affect the buffer then it did not increase the
   * state vector, in which case we don't need to check again here. */
  if(priv-&gt;user != NULL)
  {
    user_id = inf_user_get_id(INF_USER(priv-&gt;user));

    /* We need to do cleanup if our user issued this request, even if the
     * request does not affect the buffer, since it raises that user's
     * vector time, and thus might cause requests in its request log to be
     * dropped. */
    if(inf_adopted_request_affects_buffer(request) ||
       inf_adopted_request_get_user_id(request) == user_id)
    {
      inf_adopted_undo_grouping_cleanup(grouping);
    }
  }
}

static void
inf_adopted_undo_grouping_init_user(InfAdoptedUndoGrouping* grouping)
{
  InfAdoptedUndoGroupingPrivate* priv;
  InfAdoptedRequestLog* log;
  InfAdoptedRequest* request;
  guint max_total_log_size;
  guint end;
  guint i;

  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);

  g_assert(priv-&gt;user != NULL);

  g_signal_connect(
    G_OBJECT(inf_adopted_user_get_request_log(priv-&gt;user)),
    &quot;add-request&quot;,
    G_CALLBACK(inf_adopted_undo_grouping_add_request_cb),
    grouping
  );

  g_object_get(
    priv-&gt;algorithm,
    &quot;max-total-log-size&quot;, &amp;max_total_log_size,
    NULL
  );

  /* Add initial requests from request log */
  log = inf_adopted_user_get_request_log(priv-&gt;user);
  end = inf_adopted_request_log_get_end(log);

  for(i = inf_adopted_request_log_get_begin(log); i &lt; end; ++i)
  {
    request = inf_adopted_request_log_get_request(log, i);
    inf_adopted_undo_grouping_add_request(grouping, request);

    /* TODO: Instead of cleaning up requests that we have added just before,
     * we may find out which ones will not end up in the buffer anyway because
     * they cannot be undone anymore. This would require
     * inf_adopted_algorithm_can_undo_redo() to work for requests that are
     * anywhere in the log and to be public. */
    inf_adopted_undo_grouping_cleanup(grouping);
  }
}

static void
inf_adopted_undo_grouping_deinit_user(InfAdoptedUndoGrouping* grouping)
{
  InfAdoptedUndoGroupingPrivate* priv;
  InfAdoptedRequest* request;
  guint i;

  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);

  g_assert(priv-&gt;user != NULL);

  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(inf_adopted_user_get_request_log(priv-&gt;user)),
    G_CALLBACK(inf_adopted_undo_grouping_add_request_cb),
    grouping
  );

  g_object_unref(priv-&gt;user);
  priv-&gt;user = NULL;

  for(i = 0; i &lt; priv-&gt;n_items; ++i)
  {
    request =
      priv-&gt;items[(priv-&gt;first_item + i) % priv-&gt;n_alloc].request;
    g_object_unref(request);
  }

  g_free(priv-&gt;items);
  priv-&gt;items = NULL;
  priv-&gt;n_items = 0;
  priv-&gt;n_alloc = 0;
  priv-&gt;first_item = 0;
  priv-&gt;item_pos = 0;

  g_object_notify(G_OBJECT(grouping), &quot;user&quot;);
}

static void
inf_adopted_undo_grouping_init(InfAdoptedUndoGrouping* grouping)
{
  InfAdoptedUndoGroupingPrivate* priv;
  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);

  priv-&gt;algorithm = NULL;
  priv-&gt;user = NULL;

  priv-&gt;items = NULL;
  priv-&gt;n_items = 0;
  priv-&gt;n_alloc = 0;
  priv-&gt;first_item = 0;
  priv-&gt;item_pos = 0;

  priv-&gt;group_ref = 0;
  priv-&gt;group_flags = 0;
}

static void
inf_adopted_undo_grouping_dispose(GObject* object)
{
  InfAdoptedUndoGrouping* grouping;
  InfAdoptedUndoGroupingPrivate* priv;

<A NAME="1"></A>  grouping = INF_ADOPTED_UNDO_GROUPING(object);
  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);

<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match627-0.html#1',2,'match627-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  inf_adopted_undo_grouping_set_algorithm(grouping, NULL, NULL);

  G_OBJECT_CLASS(inf_adopted_undo_grouping_parent_class)-&gt;dispose(object);
}

static void
inf_adopted_undo_grouping_finalize(GObject* object)
{
  InfAdoptedUndoGrouping* grouping;
  InfAdoptedUndoGroupingPrivate* priv;

  grouping = INF_ADOPTED_UNDO_GROUPING(object);
  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);

  G_OBJECT_CLASS(inf_adopted_undo_grouping_parent_class)-&gt;finalize(object);
}

static void
inf_adopted_undo_grouping_set_property(GObject* object,
                                       guint prop_id,
                                       const GValue* value,
                                       GParamSpec* pspec)
{
  InfAdoptedUndoGrouping* grouping;
  InfAdoptedUndoGroupingPrivate* priv;

  grouping = INF_ADOPTED_UNDO_GROUPING(object);
  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);

  switch(prop_id)
  {
  case PROP_ALGORITHM:</B></FONT>
    inf_adopted_undo_grouping_set_algorithm(
      grouping,
      INF_ADOPTED_ALGORITHM(g_value_get_object(value)),
      NULL
    );

    break;
  case PROP_USER:
    inf_adopted_undo_grouping_set_algorithm(
      grouping,
      priv-&gt;algorithm,
<A NAME="0"></A>      INF_ADOPTED_USER(g_value_get_object(value))
    );

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match627-0.html#0',2,'match627-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_adopted_undo_grouping_get_property(GObject* object,
                                       guint prop_id,
                                       GValue* value,
                                       GParamSpec* pspec)
{
  InfAdoptedUndoGrouping* grouping;
  InfAdoptedUndoGroupingPrivate* priv;

  grouping = INF_ADOPTED_UNDO_GROUPING(object);
  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);

  switch(prop_id)
  {
  case PROP_ALGORITHM:
    g_value_set_object(value, priv-&gt;algorithm);
    break;
  case PROP_USER:
    g_value_set_object(value, priv-&gt;user);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static gboolean
inf_adopted_undo_grouping_group_requests(InfAdoptedUndoGrouping* grouping,
                                         InfAdoptedRequest* first,
                                         InfAdoptedRequest* second)
{
  return FALSE;
}

static void</B></FONT>
inf_adopted_undo_grouping_class_init(
  InfAdoptedUndoGroupingClass* undo_grouping_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(undo_grouping_class);

  object_class-&gt;dispose = inf_adopted_undo_grouping_dispose;
  object_class-&gt;finalize = inf_adopted_undo_grouping_finalize;
  object_class-&gt;set_property = inf_adopted_undo_grouping_set_property;
  object_class-&gt;get_property = inf_adopted_undo_grouping_get_property;
  undo_grouping_class-&gt;group_requests =
    inf_adopted_undo_grouping_group_requests;

  g_object_class_install_property(
    object_class,
    PROP_ALGORITHM,
    g_param_spec_object(
      &quot;algorithm&quot;,
      &quot;Algorithm&quot;,
      &quot;The algorithm for which to group requests&quot;,
      INF_ADOPTED_TYPE_ALGORITHM,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_USER,
    g_param_spec_object(
      &quot;user&quot;,
      &quot;User&quot;,
      &quot;The user for which to group requests&quot;,
      INF_ADOPTED_TYPE_USER,
      G_PARAM_READWRITE
    )
  );

  /**
   * InfAdoptedUndoGrouping::group-requests:
   * @grouping: The #InfAdoptedUndoGrouping which is about to group a request.
   * @first: The previous request.
   * @second: The current request.
   *
   * This signal is emitted whenever the #InfAdoptedUndoGrouping needs to
   * decide whether to put two requests into the same undo group or not.
   * A signal handler should return %TRUE if they belong into the same group
   * or %FALSE otherwise. Note however that the two requests may not
   * immediately follow each other because other users may have issued
   * requests inbetween. Check the vector times of the requests to find out,
   * using inf_adopted_request_get_vector().
   */
  undo_grouping_signals[GROUP_REQUESTS] = g_signal_new(
    &quot;group-requests&quot;,
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfAdoptedUndoGroupingClass, group_requests),
    g_signal_accumulator_true_handled, NULL,
    NULL,
    G_TYPE_BOOLEAN,
    2,
    INF_ADOPTED_TYPE_REQUEST,
    INF_ADOPTED_TYPE_REQUEST
  );
}

/**
 * inf_adopted_undo_grouping_new: (constructor)
 *
 * Creates a new #InfAdoptedUndoGrouping. To start grouping requests, set a
 * user whose requests to group via inf_adopted_undo_grouping_set_algorithm().
 * Before doing so you might want to connect to
 * #InfAdoptedUndoGrouping::group-requests, so the user's initial requests can
 * be grouped correctly.
 *
 * Returns: (transfer full): A new #InfAdoptedUndoGrouping, to be freed
 * via g_object_unref().
 */
InfAdoptedUndoGrouping*
inf_adopted_undo_grouping_new(void)
{
  GObject* object;
  object = g_object_new(INF_ADOPTED_TYPE_UNDO_GROUPING, NULL);
  return INF_ADOPTED_UNDO_GROUPING(object);
}

/**
 * inf_adopted_undo_grouping_get_algorithm:
 * @grouping: A #InfAdoptedUndoGrouping.
 *
 * Returns the #InfAdoptedAlgorithm for @grouping.
 *
 * Returns: (transfer none): @grouping's algorithm.
 */
InfAdoptedAlgorithm*
inf_adopted_undo_grouping_get_algorithm(InfAdoptedUndoGrouping* grouping)
{
  g_return_val_if_fail(INF_ADOPTED_IS_UNDO_GROUPING(grouping), NULL);
  return INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping)-&gt;algorithm;
}

/**
 * inf_adopted_undo_grouping_set_algorithm:
 * @grouping: A #InfAdoptedUndoGrouping.
 * @algorithm: The #InfAdoptedAlgorithm for the document to group requests,
 * or %NULL.
 * @user: The user for which to group requests, or %NULL. Ignored if
 * @algorithm is %NULL.
 *
 * Sets the algorithm and user to group requests for. This function will group
 * all requests in user's request log, and also each new request that is
 * added to it's log. Requests that cannot be undone anymore (because
 * they are too old), will be correctly taken care off.
 */
void
inf_adopted_undo_grouping_set_algorithm(InfAdoptedUndoGrouping* grouping,
                                       InfAdoptedAlgorithm* algorithm,
                                       InfAdoptedUser* user)
{
  InfAdoptedUndoGroupingPrivate* priv;

  g_return_if_fail(INF_ADOPTED_IS_UNDO_GROUPING(grouping));
  g_return_if_fail(algorithm == NULL || INF_ADOPTED_IS_ALGORITHM(algorithm));
  g_return_if_fail(user == NULL || INF_ADOPTED_IS_USER(user));

  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
  g_object_freeze_notify(G_OBJECT(grouping));

  if(priv-&gt;algorithm != algorithm)
  {
    if(priv-&gt;algorithm != NULL)
    {
      inf_signal_handlers_disconnect_by_func(
        G_OBJECT(priv-&gt;algorithm),
        G_CALLBACK(inf_adopted_undo_grouping_end_execute_request_cb),
        grouping
      );

      /* The user belonged to the old algorithm */
      if(priv-&gt;user != NULL)
        inf_adopted_undo_grouping_deinit_user(grouping);

      g_object_unref(priv-&gt;algorithm);
      priv-&gt;algorithm = NULL;
    }

    priv-&gt;algorithm = algorithm;

    if(algorithm != NULL)
    {
      g_object_ref(algorithm);

      g_signal_connect(
        G_OBJECT(priv-&gt;algorithm),
        &quot;end-execute-request&quot;,
        G_CALLBACK(inf_adopted_undo_grouping_end_execute_request_cb),
        grouping
      );
    }

    g_object_notify(G_OBJECT(grouping), &quot;algorithm&quot;);
  }

  if(priv-&gt;user != user)
  {
    if(priv-&gt;user != NULL)
        inf_adopted_undo_grouping_deinit_user(grouping);

    priv-&gt;user = user;

    if(user != NULL)
    {
      g_object_ref(user);

      inf_adopted_undo_grouping_init_user(grouping);
    }

    g_object_notify(G_OBJECT(grouping), &quot;user&quot;);
  }

  g_object_thaw_notify(G_OBJECT(grouping));
}

/**
 * inf_adopted_undo_grouping_start_group:
 * @grouping: A #InfAdoptedUndoGrouping.
 * @allow_group_with_prev: Whether the new group can be part of the previous
 * group if #InfAdoptedUndoGrouping::group-requests allows.
 *
 * Makes all requests issued after this call belong into the same group,
 * i.e. they will be undone at once. This can make sense for example when the
 * user copy+pastes something into the document which causes multiple requests
 * to be generated. A call to inf_adopted_undo_grouping_end_group() restores
 * the normal behavior.
 */
void
inf_adopted_undo_grouping_start_group(InfAdoptedUndoGrouping* grouping,
                                      gboolean allow_group_with_prev)
{
  InfAdoptedUndoGroupingPrivate* priv;

  g_return_if_fail(INF_ADOPTED_IS_UNDO_GROUPING(grouping));

  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
  g_return_if_fail(priv-&gt;algorithm != NULL);
  g_return_if_fail(priv-&gt;user != NULL);

  if(priv-&gt;group_ref++ == 0)
  {
    priv-&gt;group_flags = INF_ADOPTED_UNDO_GROUPING_FIRST_IN_GROUP;
    if(allow_group_with_prev)
      priv-&gt;group_flags |= INF_ADOPTED_UNDO_GROUPING_ALLOW_WITH_PREV;
  }
}

/**
 * inf_adopted_undo_grouping_end_group:
 * @grouping: A #InfAdoptedUndoGrouping.
 * @allow_group_with_next: Whether subsequent requests are allow to be part of
 * this group if #InfAdoptedUndoGrouping::group-requests allows.
 *
 * When inf_adopted_undo_grouping_start_group() was called before, then this
 * function restores the normal behaviour of grouping requests.
 */
void
inf_adopted_undo_grouping_end_group(InfAdoptedUndoGrouping* grouping,
                                    gboolean allow_group_with_next)
{
  InfAdoptedUndoGroupingPrivate* priv;

  g_return_if_fail(INF_ADOPTED_IS_UNDO_GROUPING(grouping));

  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
  g_return_if_fail(priv-&gt;algorithm != NULL);
  g_return_if_fail(priv-&gt;user != NULL);

  g_return_if_fail(priv-&gt;group_ref &gt; 0);
  if(--priv-&gt;group_ref == 0)
  {
    priv-&gt;group_flags = INF_ADOPTED_UNDO_GROUPING_FIRST_AFTER_GROUP;
    if(allow_group_with_next)
      priv-&gt;group_flags |= INF_ADOPTED_UNDO_GROUPING_ALLOW_WITH_NEXT;
  }
}

/**
 * inf_adopted_undo_grouping_get_undo_size:
 * @grouping: A #InfAdoptedUndoGrouping.
 *
 * Returns the number of requests to undo so that a whole group is being
 * undone. This takes into account that possibly not the whole group cannot
 * be undone due to the #InfAdoptedAlgorithm:max-total-log-size constraint.
 *
 * Returns: The number of requests in the current undo group.
 */
guint
inf_adopted_undo_grouping_get_undo_size(InfAdoptedUndoGrouping* grouping)
{
  InfAdoptedUndoGroupingPrivate* priv;
  guint max_total_log_size;
  InfAdoptedRequestLog* log;
  InfAdoptedStateVector* current;
  guint pos;
  guint index;
  InfAdoptedRequest* lower_related;
  InfAdoptedStateVector* vector;
  guint vdiff;

  g_return_val_if_fail(INF_ADOPTED_IS_UNDO_GROUPING(grouping), 0);

  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
  if(priv-&gt;item_pos == 0) return 0;

  g_object_get(
    G_OBJECT(priv-&gt;algorithm),
    &quot;max-total-log-size&quot;,
    &amp;max_total_log_size,
    NULL
  );

  log = inf_adopted_user_get_request_log(priv-&gt;user);
  current = inf_adopted_user_get_vector(priv-&gt;user);

  pos = priv-&gt;item_pos;
  do
  {
    g_assert(pos &gt; 0);

    index = inf_adopted_request_get_index(priv-&gt;items[pos-1].request);
    lower_related = inf_adopted_request_log_lower_related(log, index);
    vector = inf_adopted_request_get_vector(lower_related);
    vdiff = inf_adopted_state_vector_vdiff(vector, current);

    if(vdiff + priv-&gt;item_pos - pos &gt;= max_total_log_size)
      return priv-&gt;item_pos - pos;

    --pos;
  } while(priv-&gt;items[(priv-&gt;first_item + pos) % priv-&gt;n_alloc].in_group);

  return priv-&gt;item_pos - pos;
}

/**
 * inf_adopted_undo_grouping_get_redo_size:
 * @grouping: A #InfAdoptedUndoGrouping.
 *
 * Returns the number of requests to redo so that a whole group is being
 * redone. This takes into account that possibly not the whole group cannot
 * be undone due to the #InfAdoptedAlgorithm:max-total-log-size constraint.
 *
 * Returns: The number of requests in the current redo group.
 */
guint
inf_adopted_undo_grouping_get_redo_size(InfAdoptedUndoGrouping* grouping)
{
  InfAdoptedUndoGroupingPrivate* priv;
  guint max_total_log_size;
  InfAdoptedRequestLog* log;
  InfAdoptedStateVector* current;
  guint pos;
  guint index;
  InfAdoptedRequest* lower_related;
  InfAdoptedStateVector* vector;
  guint vdiff;

  g_return_val_if_fail(INF_ADOPTED_IS_UNDO_GROUPING(grouping), 0);

  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
  if(priv-&gt;item_pos == priv-&gt;n_items) return 0;

  g_object_get(
    G_OBJECT(priv-&gt;algorithm),
    &quot;max-total-log-size&quot;,
    &amp;max_total_log_size,
    NULL
  );

  log = inf_adopted_user_get_request_log(priv-&gt;user);
  current = inf_adopted_user_get_vector(priv-&gt;user);

  pos = priv-&gt;item_pos;
  do
  {
    g_assert(pos &lt; priv-&gt;n_items);

    index = inf_adopted_request_get_index(priv-&gt;items[pos].request);
    lower_related = inf_adopted_request_log_lower_related(log, index);
    vector = inf_adopted_request_get_vector(lower_related);
    vdiff = inf_adopted_state_vector_vdiff(vector, current);

    if(vdiff + pos - priv-&gt;item_pos &gt;= max_total_log_size)
      return pos - priv-&gt;item_pos;

    ++pos;
  } while(pos &lt; priv-&gt;n_items &amp;&amp;
          priv-&gt;items[(priv-&gt;first_item + pos) % priv-&gt;n_alloc].in_group);

  return pos - priv-&gt;item_pos;
}

/* vim:set et sw=2 ts=2: */
</PRE>
</div>
  </div>
</body>
</html>
