<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-text-default-insert-operation.c &amp; inf-adopted-undo-grouping.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-text-default-insert-operation.c &amp; inf-adopted-undo-grouping.c
      </h3>
<h1 align="center">
        15.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-text-default-insert-operation.c (25.76687%)<th>inf-adopted-undo-grouping.c (10.9375%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(97-143)<td><a href="#" name="0">(509-550)</a><td align="center"><font color="#ff0000">25</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(60-91)<td><a href="#" name="1">(463-494)</a><td align="center"><font color="#ad0000">17</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-default-insert-operation.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinftext/inf-text-default-insert-operation.h&gt;
2 #include &lt;libinftext/inf-text-default-delete-operation.h&gt;
3 #include &lt;libinftext/inf-text-insert-operation.h&gt;
4 #include &lt;libinftext/inf-text-delete-operation.h&gt;
5 #include &lt;libinftext/inf-text-buffer.h&gt;
6 #include &lt;libinfinity/adopted/inf-adopted-operation.h&gt;
7 #include &lt;libinfinity/inf-i18n.h&gt;
8 typedef struct _InfTextDefaultInsertOperationPrivate
9   InfTextDefaultInsertOperationPrivate;
10 struct _InfTextDefaultInsertOperationPrivate {
11   guint position;
12   InfTextChunk* chunk;
13 };
14 enum {
15   PROP_0,
16   PROP_POSITION,
17   PROP_CHUNK
18 };
19 #define INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_TYPE_DEFAULT_INSERT_OPERATION, InfTextDefaultInsertOperationPrivate))
20 static void inf_text_default_insert_operation_operation_iface_init(InfAdoptedOperationInterface* iface);
21 static void inf_text_default_insert_operation_insert_operation_iface_init(InfTextInsertOperationInterface* iface);
22 G_DEFINE_TYPE_WITH_CODE(InfTextDefaultInsertOperation, inf_text_default_insert_operation, G_TYPE_OBJECT,
23   G_ADD_PRIVATE(InfTextDefaultInsertOperation)
24   G_IMPLEMENT_INTERFACE(INF_ADOPTED_TYPE_OPERATION, inf_text_default_insert_operation_operation_iface_init)
25   G_IMPLEMENT_INTERFACE(INF_TEXT_TYPE_INSERT_OPERATION, inf_text_default_insert_operation_insert_operation_iface_init))
26 static void
27 inf_text_default_insert_operation_init(
28   InfTextDefaultInsertOperation* operation)
29 {
30   InfTextDefaultInsertOperationPrivate* priv;
31 <a name="1"></a>  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);
32   priv-&gt;position = 0;
33 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  priv-&gt;chunk = NULL;
34 }
35 static void
36 inf_text_default_insert_operation_finalize(GObject* object)
37 {
38   InfTextDefaultInsertOperation* operation;
39   InfTextDefaultInsertOperationPrivate* priv;
40   operation = INF_TEXT_DEFAULT_INSERT_OPERATION(object);
41   priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);
42   inf_text_chunk_free(priv-&gt;chunk);
43   G_OBJECT_CLASS(inf_text_default_insert_operation_parent_class)-&gt;finalize(object);
44 }
45 static void
46 inf_text_default_insert_operation_set_property(GObject* object,
47                                                guint prop_id,
48                                                const GValue* value,
49                                                GParamSpec* pspec)
50 {
51   InfTextDefaultInsertOperation* operation;
52   InfTextDefaultInsertOperationPrivate* priv;
53   operation = INF_TEXT_DEFAULT_INSERT_OPERATION(object);
54   priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);
55   switch(prop_id)
56   {
57   case PROP_POSITION:</b></font>
58     priv-&gt;position = g_value_get_uint(value);
59     break;
60 <a name="0"></a>  case PROP_CHUNK:
61     g_assert(priv-&gt;chunk == NULL);     priv-&gt;chunk = (InfTextChunk*)g_value_dup_boxed(value);
62 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
63   default:
64     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
65     break;
66   }
67 }
68 static void
69 inf_text_default_insert_operation_get_property(GObject* object,
70                                                guint prop_id,
71                                                GValue* value,
72                                                GParamSpec* pspec)
73 {
74   InfTextDefaultInsertOperation* operation;
75   InfTextDefaultInsertOperationPrivate* priv;
76   operation = INF_TEXT_DEFAULT_INSERT_OPERATION(object);
77   priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);
78   switch(prop_id)
79   {
80   case PROP_POSITION:
81     g_value_set_uint(value, priv-&gt;position);
82     break;
83   case PROP_CHUNK:
84     g_value_set_boxed(value, priv-&gt;chunk);
85     break;
86   default:
87     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
88     break;
89   }
90 }
91 static gboolean
92 inf_text_default_insert_operation_need_concurrency_id(
93   InfAdoptedOperation* operation,
94   InfAdoptedOperation* against)
95 {
96   g_assert(INF_TEXT_IS_DEFAULT_INSERT_OPERATION(operation));
97   return inf_text_insert_operation_need_concurrency_id(
98     INF_TEXT_INSERT_OPERATION(operation),
99     against
100   );
101 }
102 static InfAdoptedOperation*</b></font>
103 inf_text_default_insert_operation_transform(InfAdoptedOperation* operation,
104                                             InfAdoptedOperation* against,
105                                             InfAdoptedOperation* op_lcs,
106                                             InfAdoptedOperation* against_lcs,
107                                             InfAdoptedConcurrencyId cid)
108 {
109   g_assert(INF_TEXT_IS_DEFAULT_INSERT_OPERATION(operation));
110   if(INF_TEXT_IS_INSERT_OPERATION(against))
111   {
112     g_assert(op_lcs == NULL ||
113              INF_TEXT_IS_INSERT_OPERATION(op_lcs));
114     g_assert(against_lcs == NULL ||
115              INF_TEXT_IS_INSERT_OPERATION(against_lcs));
116     return inf_text_insert_operation_transform_insert(
117       INF_TEXT_INSERT_OPERATION(operation),
118       INF_TEXT_INSERT_OPERATION(against),
119       INF_TEXT_INSERT_OPERATION(op_lcs),
120       INF_TEXT_INSERT_OPERATION(against_lcs),
121       cid
122     );
123   }
124   else if(INF_TEXT_IS_DELETE_OPERATION(against))
125   {
126     return inf_text_insert_operation_transform_delete(
127       INF_TEXT_INSERT_OPERATION(operation),
128       INF_TEXT_DELETE_OPERATION(against)
129     );
130   }
131   else
132   {
133     g_assert_not_reached();
134     return NULL;
135   }
136 }
137 static InfAdoptedOperation*
138 inf_text_default_insert_operation_copy(InfAdoptedOperation* operation)
139 {
140   InfTextDefaultInsertOperationPrivate* priv;
141   priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);
142   return INF_ADOPTED_OPERATION(
143     g_object_new(
144       INF_TEXT_TYPE_DEFAULT_INSERT_OPERATION,
145       "position", priv-&gt;position,
146       "chunk", priv-&gt;chunk,
147       NULL
148     )
149   );
150 }
151 static InfAdoptedOperationFlags
152 inf_text_default_insert_operation_get_flags(InfAdoptedOperation* operation)
153 {
154   return INF_ADOPTED_OPERATION_AFFECTS_BUFFER |
155          INF_ADOPTED_OPERATION_REVERSIBLE;
156 }
157 static gboolean
158 inf_text_default_insert_operation_apply(InfAdoptedOperation* operation,
159                                         InfAdoptedUser* by,
160                                         InfBuffer* buffer,
161                                         GError** error)
162 {
163   InfTextDefaultInsertOperationPrivate* priv;
164   g_assert(INF_TEXT_IS_DEFAULT_INSERT_OPERATION(operation));
165   g_assert(INF_TEXT_IS_BUFFER(buffer));
166   priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);
167   if(priv-&gt;position &gt; inf_text_buffer_get_length(INF_TEXT_BUFFER(buffer)))
168   {
169     g_set_error_literal(
170       error,
171       g_quark_from_static_string("INF_TEXT_OPERATION_ERROR"),
172       INF_TEXT_OPERATION_ERROR_INVALID_INSERT,
173       _("Attempt to insert text after the end of the document")
174     );
175     return FALSE;
176   }
177   else
178   {
179     inf_text_buffer_insert_chunk(
180       INF_TEXT_BUFFER(buffer),
181       priv-&gt;position,
182       priv-&gt;chunk,
183       INF_USER(by)
184     );
185     return TRUE;
186   }
187 }
188 static InfAdoptedOperation*
189 inf_text_default_insert_operation_revert(InfAdoptedOperation* operation)
190 {
191   InfTextDefaultInsertOperationPrivate* priv;
192   priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);
193   return INF_ADOPTED_OPERATION(
194     inf_text_default_delete_operation_new(priv-&gt;position, priv-&gt;chunk)
195   );
196 }
197 static guint
198 inf_text_default_insert_operation_get_position(InfTextInsertOperation* op)
199 {
200   return INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(op)-&gt;position;
201 }
202 static guint
203 inf_text_default_insert_operation_get_length(
204   InfTextInsertOperation* operation)
205 {
206   return inf_text_chunk_get_length(
207     INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation)-&gt;chunk
208   );
209 }
210 static InfTextInsertOperation*
211 inf_text_default_insert_operation_transform_position(
212   InfTextInsertOperation* operation,
213   guint position)
214 {
215   InfTextDefaultInsertOperationPrivate* priv;
216   GObject* result;
217   priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);
218   result = g_object_new(
219     INF_TEXT_TYPE_DEFAULT_INSERT_OPERATION,
220     "position", position,
221     "chunk", priv-&gt;chunk,
222     NULL
223   );
224   return INF_TEXT_INSERT_OPERATION(result);
225 }
226 static void
227 inf_text_default_insert_operation_class_init(
228   InfTextDefaultInsertOperationClass* default_insert_operation_class)
229 {
230   GObjectClass* object_class;
231   object_class = G_OBJECT_CLASS(default_insert_operation_class);
232   object_class-&gt;finalize = inf_text_default_insert_operation_finalize;
233   object_class-&gt;set_property =
234     inf_text_default_insert_operation_set_property;
235   object_class-&gt;get_property =
236     inf_text_default_insert_operation_get_property;
237   g_object_class_install_property(
238     object_class,
239     PROP_POSITION,
240     g_param_spec_uint(
241       "position",
242       "Position",
243       "Insertion position",
244       0,
245       G_MAXUINT,
246       0,
247       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
248     )
249   );
250   g_object_class_install_property(
251     object_class,
252     PROP_CHUNK,
253     g_param_spec_boxed(
254       "chunk",
255       "Chunk",
256       "The text to insert",
257       INF_TEXT_TYPE_CHUNK,
258       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
259     )
260   );
261 }
262 static void
263 inf_text_default_insert_operation_operation_iface_init(
264   InfAdoptedOperationInterface* iface)
265 {
266   iface-&gt;need_concurrency_id =
267     inf_text_default_insert_operation_need_concurrency_id;
268   iface-&gt;transform = inf_text_default_insert_operation_transform;
269   iface-&gt;copy = inf_text_default_insert_operation_copy;
270   iface-&gt;get_flags = inf_text_default_insert_operation_get_flags;
271   iface-&gt;apply = inf_text_default_insert_operation_apply;
272   iface-&gt;apply_transformed = NULL;
273   iface-&gt;revert = inf_text_default_insert_operation_revert;
274 }
275 static void
276 inf_text_default_insert_operation_insert_operation_iface_init(
277   InfTextInsertOperationInterface* iface)
278 {
279   iface-&gt;get_position = inf_text_default_insert_operation_get_position;
280   iface-&gt;get_length = inf_text_default_insert_operation_get_length;
281   iface-&gt;transform_position =
282     inf_text_default_insert_operation_transform_position;
283 }
284 InfTextDefaultInsertOperation*
285 inf_text_default_insert_operation_new(guint pos,
286                                       InfTextChunk* chunk)
287 {
288   GObject* object;
289   g_return_val_if_fail(chunk != NULL, NULL);
290   object = g_object_new(
291     INF_TEXT_TYPE_DEFAULT_INSERT_OPERATION,
292     "position", pos,
293     "chunk", chunk,
294     NULL
295   );
296   return INF_TEXT_DEFAULT_INSERT_OPERATION(object);
297 }
298 InfTextChunk*
299 inf_text_default_insert_operation_get_chunk(InfTextDefaultInsertOperation* operation)
300 {
301   g_return_val_if_fail(INF_TEXT_IS_DEFAULT_INSERT_OPERATION(operation), NULL);
302   return INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation)-&gt;chunk;
303 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-adopted-undo-grouping.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/adopted/inf-adopted-undo-grouping.h&gt;
2 #include &lt;libinfinity/inf-signals.h&gt;
3 typedef struct _InfAdoptedUndoGroupingItem InfAdoptedUndoGroupingItem;
4 struct _InfAdoptedUndoGroupingItem {
5   InfAdoptedRequest* request;
6   gboolean in_group;
7 };
8 typedef enum __InfAdoptedUndoGroupingFlags {
9   INF_ADOPTED_UNDO_GROUPING_ALLOW_WITH_PREV   = 1 &lt;&lt; 0,
10   INF_ADOPTED_UNDO_GROUPING_ALLOW_WITH_NEXT   = 1 &lt;&lt; 1,
11   INF_ADOPTED_UNDO_GROUPING_FIRST_IN_GROUP    = 1 &lt;&lt; 2,
12   INF_ADOPTED_UNDO_GROUPING_FIRST_AFTER_GROUP = 1 &lt;&lt; 3
13 } InfAdoptedUndoGroupingFlags;
14 typedef struct _InfAdoptedUndoGroupingPrivate InfAdoptedUndoGroupingPrivate;
15 struct _InfAdoptedUndoGroupingPrivate {
16   InfAdoptedAlgorithm* algorithm;
17   InfAdoptedUser* user;
18   InfAdoptedUndoGroupingItem* items;
19   guint n_items;
20   guint n_alloc;
21   guint first_item;
22   guint item_pos; 
23   guint group_ref;
24   guint group_flags;
25 };
26 enum {
27   PROP_0,
28   PROP_ALGORITHM,
29   PROP_USER
30 };
31 enum {
32   GROUP_REQUESTS,
33   LAST_SIGNAL
34 };
35 #define INF_ADOPTED_UNDO_GROUPING_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_ADOPTED_TYPE_UNDO_GROUPING, InfAdoptedUndoGroupingPrivate))
36 static guint undo_grouping_signals[LAST_SIGNAL];
37 G_DEFINE_TYPE_WITH_CODE(InfAdoptedUndoGrouping, inf_adopted_undo_grouping, G_TYPE_OBJECT,
38   G_ADD_PRIVATE(InfAdoptedUndoGrouping))
39 static void
40 inf_adopted_undo_grouping_add_request(InfAdoptedUndoGrouping* grouping,
41                                       InfAdoptedRequest* request)
42 {
43   InfAdoptedUndoGroupingPrivate* priv;
44   guint max;
45   InfAdoptedUndoGroupingItem* item;
46   InfAdoptedUndoGroupingItem* prev_item;
47   InfAdoptedUndoGroupingFlags flags;
48   gboolean first_after_group;
49   gboolean first_in_group;
50   gboolean allow_with_next;
51   gboolean allow_with_prev;
52   priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
53   switch(inf_adopted_request_get_request_type(request))
54   {
55   case INF_ADOPTED_REQUEST_DO:
56     if(priv-&gt;first_item + priv-&gt;item_pos == priv-&gt;n_alloc)
57     {
58       g_object_get(
59         G_OBJECT(priv-&gt;algorithm),
60         "max-total-log-size", &amp;max,
61         NULL
62       );
63       if(max != G_MAXUINT)
64       {
65         max = (max/2) + 1;
66         if(priv-&gt;n_alloc &lt; max)
67         {
68           priv-&gt;n_alloc = MIN(priv-&gt;n_alloc * 2, max);
69           priv-&gt;n_alloc = MAX(priv-&gt;n_alloc, MIN(16, max));
70           priv-&gt;items = g_realloc(
71             priv-&gt;items,
72             priv-&gt;n_alloc * sizeof(InfAdoptedUndoGroupingItem)
73           );
74         }
75       }
76       else
77       {
78         priv-&gt;n_alloc = MAX(priv-&gt;n_alloc * 2, 16);
79         priv-&gt;items = g_realloc(
80           priv-&gt;items,
81           priv-&gt;n_alloc * sizeof(InfAdoptedUndoGroupingItem)
82         );
83       }
84     }
85     priv-&gt;n_items = priv-&gt;item_pos;
86     g_assert(priv-&gt;n_items &lt; priv-&gt;n_alloc);
87     item = &amp;priv-&gt;items[(priv-&gt;first_item + priv-&gt;item_pos) % priv-&gt;n_alloc];
88     item-&gt;request = request;
89     g_object_ref(request);
90     if(priv-&gt;item_pos &gt; 0)
91     {
92       flags = priv-&gt;group_flags;
93       first_after_group =
94         (flags &amp; INF_ADOPTED_UNDO_GROUPING_FIRST_AFTER_GROUP) != 0;
95       first_in_group =
96         (flags &amp; INF_ADOPTED_UNDO_GROUPING_FIRST_IN_GROUP) != 0;
97       allow_with_next =
98         (flags &amp; INF_ADOPTED_UNDO_GROUPING_ALLOW_WITH_NEXT) != 0;
99       allow_with_prev =
100         (flags &amp; INF_ADOPTED_UNDO_GROUPING_ALLOW_WITH_PREV) != 0;
101       if(first_after_group &amp;&amp; !allow_with_next)
102       {
103         item-&gt;in_group = FALSE;
104       }
105       else if(priv-&gt;group_ref &gt; 0 &amp;&amp; first_in_group &amp;&amp; !allow_with_prev)
106       {
107         item-&gt;in_group = FALSE;
108       }
109       else if(priv-&gt;group_ref &gt; 0 &amp;&amp; !first_in_group)
110       {
111         item-&gt;in_group = TRUE;
112       }
113       else
114       {
115         prev_item = &amp;priv-&gt;items[
116           (priv-&gt;first_item + priv-&gt;item_pos - 1) % priv-&gt;n_alloc
117         ];
118         g_signal_emit(
119           G_OBJECT(grouping),
120           undo_grouping_signals[GROUP_REQUESTS],
121           0,
122           prev_item-&gt;request,
123           request,
124           &amp;item-&gt;in_group
125         );
126       }
127     }
128     else
129     {
130       item-&gt;in_group = FALSE;
131     }
132     priv-&gt;group_flags &amp;= ~(INF_ADOPTED_UNDO_GROUPING_FIRST_IN_GROUP |
133                            INF_ADOPTED_UNDO_GROUPING_FIRST_AFTER_GROUP);
134     ++priv-&gt;n_items;
135     ++priv-&gt;item_pos;
136     break;
137   case INF_ADOPTED_REQUEST_UNDO:
138     g_assert(priv-&gt;item_pos &gt; 0);
139     --priv-&gt;item_pos;
140     break;
141   case INF_ADOPTED_REQUEST_REDO:
142     g_assert(priv-&gt;item_pos &lt; priv-&gt;n_items);
143     ++priv-&gt;item_pos;
144     break;
145   }
146 }
147 static void
148 inf_adopted_undo_grouping_cleanup(InfAdoptedUndoGrouping* grouping)
149 {
150   InfAdoptedUndoGroupingPrivate* priv;
151   InfAdoptedUndoGroupingItem* item;
152   guint max_total_log_size;
153   guint vdiff;
154   guint i;
155   priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
156   g_assert(priv-&gt;user != NULL);
157   g_object_get(
158     priv-&gt;algorithm,
159     "max-total-log-size", &amp;max_total_log_size,
160     NULL
161   );
162   if(max_total_log_size != G_MAXUINT)
163   {
164     while(priv-&gt;n_items &gt; 0)
165     {
166       item = &amp;priv-&gt;items[priv-&gt;first_item];
167       vdiff = inf_adopted_state_vector_vdiff(
168         inf_adopted_request_get_vector(item-&gt;request),
169         inf_adopted_user_get_vector(priv-&gt;user)
170       );
171       if(vdiff + priv-&gt;item_pos &gt; max_total_log_size)
172       {
173         if(priv-&gt;item_pos == 0)
174         {
175           for(i = 0; i &lt; priv-&gt;n_items; ++i)
176             g_object_unref(priv-&gt;items[(priv-&gt;first_item + i) % priv-&gt;n_alloc].request);
177           priv-&gt;first_item = 0;
178           priv-&gt;n_items = 0;
179           break;
180         }
181         else
182         {
183           g_object_unref(item-&gt;request);
184           priv-&gt;first_item = (priv-&gt;first_item + 1) % priv-&gt;n_alloc;
185           --priv-&gt;n_items;
186           --priv-&gt;item_pos;
187           if(priv-&gt;n_items == 0)
188             priv-&gt;first_item = 0;
189           else
190             priv-&gt;items[priv-&gt;first_item].in_group = FALSE;
191         }
192       }
193       else
194       {
195         break;
196       }
197     }
198   }
199 }
200 static void
201 inf_adopted_undo_grouping_add_request_cb(InfAdoptedRequestLog* log,
202                                          InfAdoptedRequest* request,
203                                          gpointer user_data)
204 {
205   InfAdoptedUndoGrouping* grouping;
206   grouping = INF_ADOPTED_UNDO_GROUPING(user_data);
207   inf_adopted_undo_grouping_add_request(grouping, request);
208 }
209 static void
210 inf_adopted_undo_grouping_end_execute_request_cb(InfAdoptedAlgorithm* algo,
211                                                  InfAdoptedUser* user,
212                                                  InfAdoptedRequest* request,
213                                                  InfAdoptedRequest* trans,
214                                                  const GError* error,
215                                                  gpointer user_data)
216 {
217   InfAdoptedUndoGrouping* grouping;
218   InfAdoptedUndoGroupingPrivate* priv;
219   guint user_id;
220   grouping = INF_ADOPTED_UNDO_GROUPING(user_data);
221   priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
222   if(priv-&gt;user != NULL)
223   {
224     user_id = inf_user_get_id(INF_USER(priv-&gt;user));
225     if(inf_adopted_request_affects_buffer(request) ||
226        inf_adopted_request_get_user_id(request) == user_id)
227     {
228       inf_adopted_undo_grouping_cleanup(grouping);
229     }
230   }
231 }
232 static void
233 inf_adopted_undo_grouping_init_user(InfAdoptedUndoGrouping* grouping)
234 {
235   InfAdoptedUndoGroupingPrivate* priv;
236   InfAdoptedRequestLog* log;
237   InfAdoptedRequest* request;
238   guint max_total_log_size;
239   guint end;
240   guint i;
241   priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
242   g_assert(priv-&gt;user != NULL);
243   g_signal_connect(
244     G_OBJECT(inf_adopted_user_get_request_log(priv-&gt;user)),
245     "add-request",
246     G_CALLBACK(inf_adopted_undo_grouping_add_request_cb),
247     grouping
248   );
249   g_object_get(
250     priv-&gt;algorithm,
251     "max-total-log-size", &amp;max_total_log_size,
252     NULL
253   );
254   log = inf_adopted_user_get_request_log(priv-&gt;user);
255   end = inf_adopted_request_log_get_end(log);
256   for(i = inf_adopted_request_log_get_begin(log); i &lt; end; ++i)
257   {
258     request = inf_adopted_request_log_get_request(log, i);
259     inf_adopted_undo_grouping_add_request(grouping, request);
260     inf_adopted_undo_grouping_cleanup(grouping);
261   }
262 }
263 static void
264 inf_adopted_undo_grouping_deinit_user(InfAdoptedUndoGrouping* grouping)
265 {
266   InfAdoptedUndoGroupingPrivate* priv;
267   InfAdoptedRequest* request;
268   guint i;
269   priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
270   g_assert(priv-&gt;user != NULL);
271   inf_signal_handlers_disconnect_by_func(
272     G_OBJECT(inf_adopted_user_get_request_log(priv-&gt;user)),
273     G_CALLBACK(inf_adopted_undo_grouping_add_request_cb),
274     grouping
275   );
276   g_object_unref(priv-&gt;user);
277   priv-&gt;user = NULL;
278   for(i = 0; i &lt; priv-&gt;n_items; ++i)
279   {
280     request =
281       priv-&gt;items[(priv-&gt;first_item + i) % priv-&gt;n_alloc].request;
282     g_object_unref(request);
283   }
284   g_free(priv-&gt;items);
285   priv-&gt;items = NULL;
286   priv-&gt;n_items = 0;
287   priv-&gt;n_alloc = 0;
288   priv-&gt;first_item = 0;
289   priv-&gt;item_pos = 0;
290   g_object_notify(G_OBJECT(grouping), "user");
291 }
292 static void
293 inf_adopted_undo_grouping_init(InfAdoptedUndoGrouping* grouping)
294 {
295   InfAdoptedUndoGroupingPrivate* priv;
296   priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
297   priv-&gt;algorithm = NULL;
298   priv-&gt;user = NULL;
299   priv-&gt;items = NULL;
300   priv-&gt;n_items = 0;
301   priv-&gt;n_alloc = 0;
302   priv-&gt;first_item = 0;
303   priv-&gt;item_pos = 0;
304   priv-&gt;group_ref = 0;
305   priv-&gt;group_flags = 0;
306 }
307 static void
308 inf_adopted_undo_grouping_dispose(GObject* object)
309 {
310   InfAdoptedUndoGrouping* grouping;
311   InfAdoptedUndoGroupingPrivate* priv;
312 <a name="1"></a>  grouping = INF_ADOPTED_UNDO_GROUPING(object);
313   priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
314 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  inf_adopted_undo_grouping_set_algorithm(grouping, NULL, NULL);
315   G_OBJECT_CLASS(inf_adopted_undo_grouping_parent_class)-&gt;dispose(object);
316 }
317 static void
318 inf_adopted_undo_grouping_finalize(GObject* object)
319 {
320   InfAdoptedUndoGrouping* grouping;
321   InfAdoptedUndoGroupingPrivate* priv;
322   grouping = INF_ADOPTED_UNDO_GROUPING(object);
323   priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
324   G_OBJECT_CLASS(inf_adopted_undo_grouping_parent_class)-&gt;finalize(object);
325 }
326 static void
327 inf_adopted_undo_grouping_set_property(GObject* object,
328                                        guint prop_id,
329                                        const GValue* value,
330                                        GParamSpec* pspec)
331 {
332   InfAdoptedUndoGrouping* grouping;
333   InfAdoptedUndoGroupingPrivate* priv;
334   grouping = INF_ADOPTED_UNDO_GROUPING(object);
335   priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
336   switch(prop_id)
337   {
338   case PROP_ALGORITHM:</b></font>
339     inf_adopted_undo_grouping_set_algorithm(
340       grouping,
341       INF_ADOPTED_ALGORITHM(g_value_get_object(value)),
342       NULL
343     );
344     break;
345   case PROP_USER:
346     inf_adopted_undo_grouping_set_algorithm(
347       grouping,
348       priv-&gt;algorithm,
349 <a name="0"></a>      INF_ADOPTED_USER(g_value_get_object(value))
350     );
351 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
352   default:
353     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
354     break;
355   }
356 }
357 static void
358 inf_adopted_undo_grouping_get_property(GObject* object,
359                                        guint prop_id,
360                                        GValue* value,
361                                        GParamSpec* pspec)
362 {
363   InfAdoptedUndoGrouping* grouping;
364   InfAdoptedUndoGroupingPrivate* priv;
365   grouping = INF_ADOPTED_UNDO_GROUPING(object);
366   priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
367   switch(prop_id)
368   {
369   case PROP_ALGORITHM:
370     g_value_set_object(value, priv-&gt;algorithm);
371     break;
372   case PROP_USER:
373     g_value_set_object(value, priv-&gt;user);
374     break;
375   default:
376     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
377     break;
378   }
379 }
380 static gboolean
381 inf_adopted_undo_grouping_group_requests(InfAdoptedUndoGrouping* grouping,
382                                          InfAdoptedRequest* first,
383                                          InfAdoptedRequest* second)
384 {
385   return FALSE;
386 }
387 static void</b></font>
388 inf_adopted_undo_grouping_class_init(
389   InfAdoptedUndoGroupingClass* undo_grouping_class)
390 {
391   GObjectClass* object_class;
392   object_class = G_OBJECT_CLASS(undo_grouping_class);
393   object_class-&gt;dispose = inf_adopted_undo_grouping_dispose;
394   object_class-&gt;finalize = inf_adopted_undo_grouping_finalize;
395   object_class-&gt;set_property = inf_adopted_undo_grouping_set_property;
396   object_class-&gt;get_property = inf_adopted_undo_grouping_get_property;
397   undo_grouping_class-&gt;group_requests =
398     inf_adopted_undo_grouping_group_requests;
399   g_object_class_install_property(
400     object_class,
401     PROP_ALGORITHM,
402     g_param_spec_object(
403       "algorithm",
404       "Algorithm",
405       "The algorithm for which to group requests",
406       INF_ADOPTED_TYPE_ALGORITHM,
407       G_PARAM_READWRITE
408     )
409   );
410   g_object_class_install_property(
411     object_class,
412     PROP_USER,
413     g_param_spec_object(
414       "user",
415       "User",
416       "The user for which to group requests",
417       INF_ADOPTED_TYPE_USER,
418       G_PARAM_READWRITE
419     )
420   );
421   undo_grouping_signals[GROUP_REQUESTS] = g_signal_new(
422     "group-requests",
423     G_OBJECT_CLASS_TYPE(object_class),
424     G_SIGNAL_RUN_LAST,
425     G_STRUCT_OFFSET(InfAdoptedUndoGroupingClass, group_requests),
426     g_signal_accumulator_true_handled, NULL,
427     NULL,
428     G_TYPE_BOOLEAN,
429     2,
430     INF_ADOPTED_TYPE_REQUEST,
431     INF_ADOPTED_TYPE_REQUEST
432   );
433 }
434 InfAdoptedUndoGrouping*
435 inf_adopted_undo_grouping_new(void)
436 {
437   GObject* object;
438   object = g_object_new(INF_ADOPTED_TYPE_UNDO_GROUPING, NULL);
439   return INF_ADOPTED_UNDO_GROUPING(object);
440 }
441 InfAdoptedAlgorithm*
442 inf_adopted_undo_grouping_get_algorithm(InfAdoptedUndoGrouping* grouping)
443 {
444   g_return_val_if_fail(INF_ADOPTED_IS_UNDO_GROUPING(grouping), NULL);
445   return INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping)-&gt;algorithm;
446 }
447 void
448 inf_adopted_undo_grouping_set_algorithm(InfAdoptedUndoGrouping* grouping,
449                                        InfAdoptedAlgorithm* algorithm,
450                                        InfAdoptedUser* user)
451 {
452   InfAdoptedUndoGroupingPrivate* priv;
453   g_return_if_fail(INF_ADOPTED_IS_UNDO_GROUPING(grouping));
454   g_return_if_fail(algorithm == NULL || INF_ADOPTED_IS_ALGORITHM(algorithm));
455   g_return_if_fail(user == NULL || INF_ADOPTED_IS_USER(user));
456   priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
457   g_object_freeze_notify(G_OBJECT(grouping));
458   if(priv-&gt;algorithm != algorithm)
459   {
460     if(priv-&gt;algorithm != NULL)
461     {
462       inf_signal_handlers_disconnect_by_func(
463         G_OBJECT(priv-&gt;algorithm),
464         G_CALLBACK(inf_adopted_undo_grouping_end_execute_request_cb),
465         grouping
466       );
467       if(priv-&gt;user != NULL)
468         inf_adopted_undo_grouping_deinit_user(grouping);
469       g_object_unref(priv-&gt;algorithm);
470       priv-&gt;algorithm = NULL;
471     }
472     priv-&gt;algorithm = algorithm;
473     if(algorithm != NULL)
474     {
475       g_object_ref(algorithm);
476       g_signal_connect(
477         G_OBJECT(priv-&gt;algorithm),
478         "end-execute-request",
479         G_CALLBACK(inf_adopted_undo_grouping_end_execute_request_cb),
480         grouping
481       );
482     }
483     g_object_notify(G_OBJECT(grouping), "algorithm");
484   }
485   if(priv-&gt;user != user)
486   {
487     if(priv-&gt;user != NULL)
488         inf_adopted_undo_grouping_deinit_user(grouping);
489     priv-&gt;user = user;
490     if(user != NULL)
491     {
492       g_object_ref(user);
493       inf_adopted_undo_grouping_init_user(grouping);
494     }
495     g_object_notify(G_OBJECT(grouping), "user");
496   }
497   g_object_thaw_notify(G_OBJECT(grouping));
498 }
499 void
500 inf_adopted_undo_grouping_start_group(InfAdoptedUndoGrouping* grouping,
501                                       gboolean allow_group_with_prev)
502 {
503   InfAdoptedUndoGroupingPrivate* priv;
504   g_return_if_fail(INF_ADOPTED_IS_UNDO_GROUPING(grouping));
505   priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
506   g_return_if_fail(priv-&gt;algorithm != NULL);
507   g_return_if_fail(priv-&gt;user != NULL);
508   if(priv-&gt;group_ref++ == 0)
509   {
510     priv-&gt;group_flags = INF_ADOPTED_UNDO_GROUPING_FIRST_IN_GROUP;
511     if(allow_group_with_prev)
512       priv-&gt;group_flags |= INF_ADOPTED_UNDO_GROUPING_ALLOW_WITH_PREV;
513   }
514 }
515 void
516 inf_adopted_undo_grouping_end_group(InfAdoptedUndoGrouping* grouping,
517                                     gboolean allow_group_with_next)
518 {
519   InfAdoptedUndoGroupingPrivate* priv;
520   g_return_if_fail(INF_ADOPTED_IS_UNDO_GROUPING(grouping));
521   priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
522   g_return_if_fail(priv-&gt;algorithm != NULL);
523   g_return_if_fail(priv-&gt;user != NULL);
524   g_return_if_fail(priv-&gt;group_ref &gt; 0);
525   if(--priv-&gt;group_ref == 0)
526   {
527     priv-&gt;group_flags = INF_ADOPTED_UNDO_GROUPING_FIRST_AFTER_GROUP;
528     if(allow_group_with_next)
529       priv-&gt;group_flags |= INF_ADOPTED_UNDO_GROUPING_ALLOW_WITH_NEXT;
530   }
531 }
532 guint
533 inf_adopted_undo_grouping_get_undo_size(InfAdoptedUndoGrouping* grouping)
534 {
535   InfAdoptedUndoGroupingPrivate* priv;
536   guint max_total_log_size;
537   InfAdoptedRequestLog* log;
538   InfAdoptedStateVector* current;
539   guint pos;
540   guint index;
541   InfAdoptedRequest* lower_related;
542   InfAdoptedStateVector* vector;
543   guint vdiff;
544   g_return_val_if_fail(INF_ADOPTED_IS_UNDO_GROUPING(grouping), 0);
545   priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
546   if(priv-&gt;item_pos == 0) return 0;
547   g_object_get(
548     G_OBJECT(priv-&gt;algorithm),
549     "max-total-log-size",
550     &amp;max_total_log_size,
551     NULL
552   );
553   log = inf_adopted_user_get_request_log(priv-&gt;user);
554   current = inf_adopted_user_get_vector(priv-&gt;user);
555   pos = priv-&gt;item_pos;
556   do
557   {
558     g_assert(pos &gt; 0);
559     index = inf_adopted_request_get_index(priv-&gt;items[pos-1].request);
560     lower_related = inf_adopted_request_log_lower_related(log, index);
561     vector = inf_adopted_request_get_vector(lower_related);
562     vdiff = inf_adopted_state_vector_vdiff(vector, current);
563     if(vdiff + priv-&gt;item_pos - pos &gt;= max_total_log_size)
564       return priv-&gt;item_pos - pos;
565     --pos;
566   } while(priv-&gt;items[(priv-&gt;first_item + pos) % priv-&gt;n_alloc].in_group);
567   return priv-&gt;item_pos - pos;
568 }
569 guint
570 inf_adopted_undo_grouping_get_redo_size(InfAdoptedUndoGrouping* grouping)
571 {
572   InfAdoptedUndoGroupingPrivate* priv;
573   guint max_total_log_size;
574   InfAdoptedRequestLog* log;
575   InfAdoptedStateVector* current;
576   guint pos;
577   guint index;
578   InfAdoptedRequest* lower_related;
579   InfAdoptedStateVector* vector;
580   guint vdiff;
581   g_return_val_if_fail(INF_ADOPTED_IS_UNDO_GROUPING(grouping), 0);
582   priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
583   if(priv-&gt;item_pos == priv-&gt;n_items) return 0;
584   g_object_get(
585     G_OBJECT(priv-&gt;algorithm),
586     "max-total-log-size",
587     &amp;max_total_log_size,
588     NULL
589   );
590   log = inf_adopted_user_get_request_log(priv-&gt;user);
591   current = inf_adopted_user_get_vector(priv-&gt;user);
592   pos = priv-&gt;item_pos;
593   do
594   {
595     g_assert(pos &lt; priv-&gt;n_items);
596     index = inf_adopted_request_get_index(priv-&gt;items[pos].request);
597     lower_related = inf_adopted_request_log_lower_related(log, index);
598     vector = inf_adopted_request_get_vector(lower_related);
599     vdiff = inf_adopted_state_vector_vdiff(vector, current);
600     if(vdiff + pos - priv-&gt;item_pos &gt;= max_total_log_size)
601       return pos - priv-&gt;item_pos;
602     ++pos;
603   } while(pos &lt; priv-&gt;n_items &amp;&amp;
604           priv-&gt;items[(priv-&gt;first_item + pos) % priv-&gt;n_alloc].in_group);
605   return pos - priv-&gt;item_pos;
606 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
