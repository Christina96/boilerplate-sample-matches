<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-text-default-insert-operation.c &amp; inf-adopted-undo-grouping.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-text-default-insert-operation.c &amp; inf-adopted-undo-grouping.c
      </h3>
<h1 align="center">
        15.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-text-default-insert-operation.c (25.76687%)<th>inf-adopted-undo-grouping.c (10.9375%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(97-143)<td><a href="#" name="0">(509-550)</a><td align="center"><font color="#ff0000">25</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(60-91)<td><a href="#" name="1">(463-494)</a><td align="center"><font color="#ad0000">17</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-default-insert-operation.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinftext/inf-text-default-insert-operation.h&gt;
#include &lt;libinftext/inf-text-default-delete-operation.h&gt;
#include &lt;libinftext/inf-text-insert-operation.h&gt;
#include &lt;libinftext/inf-text-delete-operation.h&gt;
#include &lt;libinftext/inf-text-buffer.h&gt;
#include &lt;libinfinity/adopted/inf-adopted-operation.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
typedef struct _InfTextDefaultInsertOperationPrivate
  InfTextDefaultInsertOperationPrivate;
struct _InfTextDefaultInsertOperationPrivate {
  guint position;
  InfTextChunk* chunk;
};
enum {
  PROP_0,
  PROP_POSITION,
  PROP_CHUNK
};
#define INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_TYPE_DEFAULT_INSERT_OPERATION, InfTextDefaultInsertOperationPrivate))
static void inf_text_default_insert_operation_operation_iface_init(InfAdoptedOperationInterface* iface);
static void inf_text_default_insert_operation_insert_operation_iface_init(InfTextInsertOperationInterface* iface);
G_DEFINE_TYPE_WITH_CODE(InfTextDefaultInsertOperation, inf_text_default_insert_operation, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfTextDefaultInsertOperation)
  G_IMPLEMENT_INTERFACE(INF_ADOPTED_TYPE_OPERATION, inf_text_default_insert_operation_operation_iface_init)
  G_IMPLEMENT_INTERFACE(INF_TEXT_TYPE_INSERT_OPERATION, inf_text_default_insert_operation_insert_operation_iface_init))
static void
inf_text_default_insert_operation_init(
  InfTextDefaultInsertOperation* operation)
{
  InfTextDefaultInsertOperationPrivate* priv;
<a name="1"></a>  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);
  priv-&gt;position = 0;
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  priv-&gt;chunk = NULL;
}
static void
inf_text_default_insert_operation_finalize(GObject* object)
{
  InfTextDefaultInsertOperation* operation;
  InfTextDefaultInsertOperationPrivate* priv;
  operation = INF_TEXT_DEFAULT_INSERT_OPERATION(object);
  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);
  inf_text_chunk_free(priv-&gt;chunk);
  G_OBJECT_CLASS(inf_text_default_insert_operation_parent_class)-&gt;finalize(object);
}
static void
inf_text_default_insert_operation_set_property(GObject* object,
                                               guint prop_id,
                                               const GValue* value,
                                               GParamSpec* pspec)
{
  InfTextDefaultInsertOperation* operation;
  InfTextDefaultInsertOperationPrivate* priv;
  operation = INF_TEXT_DEFAULT_INSERT_OPERATION(object);
  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);
  switch(prop_id)
  {
  case PROP_POSITION:</b></font>
    priv-&gt;position = g_value_get_uint(value);
    break;
<a name="0"></a>  case PROP_CHUNK:
    g_assert(priv-&gt;chunk == NULL);     priv-&gt;chunk = (InfTextChunk*)g_value_dup_boxed(value);
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_text_default_insert_operation_get_property(GObject* object,
                                               guint prop_id,
                                               GValue* value,
                                               GParamSpec* pspec)
{
  InfTextDefaultInsertOperation* operation;
  InfTextDefaultInsertOperationPrivate* priv;
  operation = INF_TEXT_DEFAULT_INSERT_OPERATION(object);
  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);
  switch(prop_id)
  {
  case PROP_POSITION:
    g_value_set_uint(value, priv-&gt;position);
    break;
  case PROP_CHUNK:
    g_value_set_boxed(value, priv-&gt;chunk);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static gboolean
inf_text_default_insert_operation_need_concurrency_id(
  InfAdoptedOperation* operation,
  InfAdoptedOperation* against)
{
  g_assert(INF_TEXT_IS_DEFAULT_INSERT_OPERATION(operation));
  return inf_text_insert_operation_need_concurrency_id(
    INF_TEXT_INSERT_OPERATION(operation),
    against
  );
}
static InfAdoptedOperation*</b></font>
inf_text_default_insert_operation_transform(InfAdoptedOperation* operation,
                                            InfAdoptedOperation* against,
                                            InfAdoptedOperation* op_lcs,
                                            InfAdoptedOperation* against_lcs,
                                            InfAdoptedConcurrencyId cid)
{
  g_assert(INF_TEXT_IS_DEFAULT_INSERT_OPERATION(operation));
  if(INF_TEXT_IS_INSERT_OPERATION(against))
  {
    g_assert(op_lcs == NULL ||
             INF_TEXT_IS_INSERT_OPERATION(op_lcs));
    g_assert(against_lcs == NULL ||
             INF_TEXT_IS_INSERT_OPERATION(against_lcs));
    return inf_text_insert_operation_transform_insert(
      INF_TEXT_INSERT_OPERATION(operation),
      INF_TEXT_INSERT_OPERATION(against),
      INF_TEXT_INSERT_OPERATION(op_lcs),
      INF_TEXT_INSERT_OPERATION(against_lcs),
      cid
    );
  }
  else if(INF_TEXT_IS_DELETE_OPERATION(against))
  {
    return inf_text_insert_operation_transform_delete(
      INF_TEXT_INSERT_OPERATION(operation),
      INF_TEXT_DELETE_OPERATION(against)
    );
  }
  else
  {
    g_assert_not_reached();
    return NULL;
  }
}
static InfAdoptedOperation*
inf_text_default_insert_operation_copy(InfAdoptedOperation* operation)
{
  InfTextDefaultInsertOperationPrivate* priv;
  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);
  return INF_ADOPTED_OPERATION(
    g_object_new(
      INF_TEXT_TYPE_DEFAULT_INSERT_OPERATION,
      "position", priv-&gt;position,
      "chunk", priv-&gt;chunk,
      NULL
    )
  );
}
static InfAdoptedOperationFlags
inf_text_default_insert_operation_get_flags(InfAdoptedOperation* operation)
{
  return INF_ADOPTED_OPERATION_AFFECTS_BUFFER |
         INF_ADOPTED_OPERATION_REVERSIBLE;
}
static gboolean
inf_text_default_insert_operation_apply(InfAdoptedOperation* operation,
                                        InfAdoptedUser* by,
                                        InfBuffer* buffer,
                                        GError** error)
{
  InfTextDefaultInsertOperationPrivate* priv;
  g_assert(INF_TEXT_IS_DEFAULT_INSERT_OPERATION(operation));
  g_assert(INF_TEXT_IS_BUFFER(buffer));
  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);
  if(priv-&gt;position &gt; inf_text_buffer_get_length(INF_TEXT_BUFFER(buffer)))
  {
    g_set_error_literal(
      error,
      g_quark_from_static_string("INF_TEXT_OPERATION_ERROR"),
      INF_TEXT_OPERATION_ERROR_INVALID_INSERT,
      _("Attempt to insert text after the end of the document")
    );
    return FALSE;
  }
  else
  {
    inf_text_buffer_insert_chunk(
      INF_TEXT_BUFFER(buffer),
      priv-&gt;position,
      priv-&gt;chunk,
      INF_USER(by)
    );
    return TRUE;
  }
}
static InfAdoptedOperation*
inf_text_default_insert_operation_revert(InfAdoptedOperation* operation)
{
  InfTextDefaultInsertOperationPrivate* priv;
  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);
  return INF_ADOPTED_OPERATION(
    inf_text_default_delete_operation_new(priv-&gt;position, priv-&gt;chunk)
  );
}
static guint
inf_text_default_insert_operation_get_position(InfTextInsertOperation* op)
{
  return INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(op)-&gt;position;
}
static guint
inf_text_default_insert_operation_get_length(
  InfTextInsertOperation* operation)
{
  return inf_text_chunk_get_length(
    INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation)-&gt;chunk
  );
}
static InfTextInsertOperation*
inf_text_default_insert_operation_transform_position(
  InfTextInsertOperation* operation,
  guint position)
{
  InfTextDefaultInsertOperationPrivate* priv;
  GObject* result;
  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);
  result = g_object_new(
    INF_TEXT_TYPE_DEFAULT_INSERT_OPERATION,
    "position", position,
    "chunk", priv-&gt;chunk,
    NULL
  );
  return INF_TEXT_INSERT_OPERATION(result);
}
static void
inf_text_default_insert_operation_class_init(
  InfTextDefaultInsertOperationClass* default_insert_operation_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(default_insert_operation_class);
  object_class-&gt;finalize = inf_text_default_insert_operation_finalize;
  object_class-&gt;set_property =
    inf_text_default_insert_operation_set_property;
  object_class-&gt;get_property =
    inf_text_default_insert_operation_get_property;
  g_object_class_install_property(
    object_class,
    PROP_POSITION,
    g_param_spec_uint(
      "position",
      "Position",
      "Insertion position",
      0,
      G_MAXUINT,
      0,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_CHUNK,
    g_param_spec_boxed(
      "chunk",
      "Chunk",
      "The text to insert",
      INF_TEXT_TYPE_CHUNK,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
}
static void
inf_text_default_insert_operation_operation_iface_init(
  InfAdoptedOperationInterface* iface)
{
  iface-&gt;need_concurrency_id =
    inf_text_default_insert_operation_need_concurrency_id;
  iface-&gt;transform = inf_text_default_insert_operation_transform;
  iface-&gt;copy = inf_text_default_insert_operation_copy;
  iface-&gt;get_flags = inf_text_default_insert_operation_get_flags;
  iface-&gt;apply = inf_text_default_insert_operation_apply;
  iface-&gt;apply_transformed = NULL;
  iface-&gt;revert = inf_text_default_insert_operation_revert;
}
static void
inf_text_default_insert_operation_insert_operation_iface_init(
  InfTextInsertOperationInterface* iface)
{
  iface-&gt;get_position = inf_text_default_insert_operation_get_position;
  iface-&gt;get_length = inf_text_default_insert_operation_get_length;
  iface-&gt;transform_position =
    inf_text_default_insert_operation_transform_position;
}
InfTextDefaultInsertOperation*
inf_text_default_insert_operation_new(guint pos,
                                      InfTextChunk* chunk)
{
  GObject* object;
  g_return_val_if_fail(chunk != NULL, NULL);
  object = g_object_new(
    INF_TEXT_TYPE_DEFAULT_INSERT_OPERATION,
    "position", pos,
    "chunk", chunk,
    NULL
  );
  return INF_TEXT_DEFAULT_INSERT_OPERATION(object);
}
InfTextChunk*
inf_text_default_insert_operation_get_chunk(InfTextDefaultInsertOperation* operation)
{
  g_return_val_if_fail(INF_TEXT_IS_DEFAULT_INSERT_OPERATION(operation), NULL);
  return INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation)-&gt;chunk;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-adopted-undo-grouping.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinfinity/adopted/inf-adopted-undo-grouping.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
typedef struct _InfAdoptedUndoGroupingItem InfAdoptedUndoGroupingItem;
struct _InfAdoptedUndoGroupingItem {
  InfAdoptedRequest* request;
  gboolean in_group;
};
typedef enum __InfAdoptedUndoGroupingFlags {
  INF_ADOPTED_UNDO_GROUPING_ALLOW_WITH_PREV   = 1 &lt;&lt; 0,
  INF_ADOPTED_UNDO_GROUPING_ALLOW_WITH_NEXT   = 1 &lt;&lt; 1,
  INF_ADOPTED_UNDO_GROUPING_FIRST_IN_GROUP    = 1 &lt;&lt; 2,
  INF_ADOPTED_UNDO_GROUPING_FIRST_AFTER_GROUP = 1 &lt;&lt; 3
} InfAdoptedUndoGroupingFlags;
typedef struct _InfAdoptedUndoGroupingPrivate InfAdoptedUndoGroupingPrivate;
struct _InfAdoptedUndoGroupingPrivate {
  InfAdoptedAlgorithm* algorithm;
  InfAdoptedUser* user;
  InfAdoptedUndoGroupingItem* items;
  guint n_items;
  guint n_alloc;
  guint first_item;
  guint item_pos; 
  guint group_ref;
  guint group_flags;
};
enum {
  PROP_0,
  PROP_ALGORITHM,
  PROP_USER
};
enum {
  GROUP_REQUESTS,
  LAST_SIGNAL
};
#define INF_ADOPTED_UNDO_GROUPING_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_ADOPTED_TYPE_UNDO_GROUPING, InfAdoptedUndoGroupingPrivate))
static guint undo_grouping_signals[LAST_SIGNAL];
G_DEFINE_TYPE_WITH_CODE(InfAdoptedUndoGrouping, inf_adopted_undo_grouping, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfAdoptedUndoGrouping))
static void
inf_adopted_undo_grouping_add_request(InfAdoptedUndoGrouping* grouping,
                                      InfAdoptedRequest* request)
{
  InfAdoptedUndoGroupingPrivate* priv;
  guint max;
  InfAdoptedUndoGroupingItem* item;
  InfAdoptedUndoGroupingItem* prev_item;
  InfAdoptedUndoGroupingFlags flags;
  gboolean first_after_group;
  gboolean first_in_group;
  gboolean allow_with_next;
  gboolean allow_with_prev;
  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
  switch(inf_adopted_request_get_request_type(request))
  {
  case INF_ADOPTED_REQUEST_DO:
    if(priv-&gt;first_item + priv-&gt;item_pos == priv-&gt;n_alloc)
    {
      g_object_get(
        G_OBJECT(priv-&gt;algorithm),
        "max-total-log-size", &amp;max,
        NULL
      );
      if(max != G_MAXUINT)
      {
        max = (max/2) + 1;
        if(priv-&gt;n_alloc &lt; max)
        {
          priv-&gt;n_alloc = MIN(priv-&gt;n_alloc * 2, max);
          priv-&gt;n_alloc = MAX(priv-&gt;n_alloc, MIN(16, max));
          priv-&gt;items = g_realloc(
            priv-&gt;items,
            priv-&gt;n_alloc * sizeof(InfAdoptedUndoGroupingItem)
          );
        }
      }
      else
      {
        priv-&gt;n_alloc = MAX(priv-&gt;n_alloc * 2, 16);
        priv-&gt;items = g_realloc(
          priv-&gt;items,
          priv-&gt;n_alloc * sizeof(InfAdoptedUndoGroupingItem)
        );
      }
    }
    priv-&gt;n_items = priv-&gt;item_pos;
    g_assert(priv-&gt;n_items &lt; priv-&gt;n_alloc);
    item = &amp;priv-&gt;items[(priv-&gt;first_item + priv-&gt;item_pos) % priv-&gt;n_alloc];
    item-&gt;request = request;
    g_object_ref(request);
    if(priv-&gt;item_pos &gt; 0)
    {
      flags = priv-&gt;group_flags;
      first_after_group =
        (flags &amp; INF_ADOPTED_UNDO_GROUPING_FIRST_AFTER_GROUP) != 0;
      first_in_group =
        (flags &amp; INF_ADOPTED_UNDO_GROUPING_FIRST_IN_GROUP) != 0;
      allow_with_next =
        (flags &amp; INF_ADOPTED_UNDO_GROUPING_ALLOW_WITH_NEXT) != 0;
      allow_with_prev =
        (flags &amp; INF_ADOPTED_UNDO_GROUPING_ALLOW_WITH_PREV) != 0;
      if(first_after_group &amp;&amp; !allow_with_next)
      {
        item-&gt;in_group = FALSE;
      }
      else if(priv-&gt;group_ref &gt; 0 &amp;&amp; first_in_group &amp;&amp; !allow_with_prev)
      {
        item-&gt;in_group = FALSE;
      }
      else if(priv-&gt;group_ref &gt; 0 &amp;&amp; !first_in_group)
      {
        item-&gt;in_group = TRUE;
      }
      else
      {
        prev_item = &amp;priv-&gt;items[
          (priv-&gt;first_item + priv-&gt;item_pos - 1) % priv-&gt;n_alloc
        ];
        g_signal_emit(
          G_OBJECT(grouping),
          undo_grouping_signals[GROUP_REQUESTS],
          0,
          prev_item-&gt;request,
          request,
          &amp;item-&gt;in_group
        );
      }
    }
    else
    {
      item-&gt;in_group = FALSE;
    }
    priv-&gt;group_flags &amp;= ~(INF_ADOPTED_UNDO_GROUPING_FIRST_IN_GROUP |
                           INF_ADOPTED_UNDO_GROUPING_FIRST_AFTER_GROUP);
    ++priv-&gt;n_items;
    ++priv-&gt;item_pos;
    break;
  case INF_ADOPTED_REQUEST_UNDO:
    g_assert(priv-&gt;item_pos &gt; 0);
    --priv-&gt;item_pos;
    break;
  case INF_ADOPTED_REQUEST_REDO:
    g_assert(priv-&gt;item_pos &lt; priv-&gt;n_items);
    ++priv-&gt;item_pos;
    break;
  }
}
static void
inf_adopted_undo_grouping_cleanup(InfAdoptedUndoGrouping* grouping)
{
  InfAdoptedUndoGroupingPrivate* priv;
  InfAdoptedUndoGroupingItem* item;
  guint max_total_log_size;
  guint vdiff;
  guint i;
  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
  g_assert(priv-&gt;user != NULL);
  g_object_get(
    priv-&gt;algorithm,
    "max-total-log-size", &amp;max_total_log_size,
    NULL
  );
  if(max_total_log_size != G_MAXUINT)
  {
    while(priv-&gt;n_items &gt; 0)
    {
      item = &amp;priv-&gt;items[priv-&gt;first_item];
      vdiff = inf_adopted_state_vector_vdiff(
        inf_adopted_request_get_vector(item-&gt;request),
        inf_adopted_user_get_vector(priv-&gt;user)
      );
      if(vdiff + priv-&gt;item_pos &gt; max_total_log_size)
      {
        if(priv-&gt;item_pos == 0)
        {
          for(i = 0; i &lt; priv-&gt;n_items; ++i)
            g_object_unref(priv-&gt;items[(priv-&gt;first_item + i) % priv-&gt;n_alloc].request);
          priv-&gt;first_item = 0;
          priv-&gt;n_items = 0;
          break;
        }
        else
        {
          g_object_unref(item-&gt;request);
          priv-&gt;first_item = (priv-&gt;first_item + 1) % priv-&gt;n_alloc;
          --priv-&gt;n_items;
          --priv-&gt;item_pos;
          if(priv-&gt;n_items == 0)
            priv-&gt;first_item = 0;
          else
            priv-&gt;items[priv-&gt;first_item].in_group = FALSE;
        }
      }
      else
      {
        break;
      }
    }
  }
}
static void
inf_adopted_undo_grouping_add_request_cb(InfAdoptedRequestLog* log,
                                         InfAdoptedRequest* request,
                                         gpointer user_data)
{
  InfAdoptedUndoGrouping* grouping;
  grouping = INF_ADOPTED_UNDO_GROUPING(user_data);
  inf_adopted_undo_grouping_add_request(grouping, request);
}
static void
inf_adopted_undo_grouping_end_execute_request_cb(InfAdoptedAlgorithm* algo,
                                                 InfAdoptedUser* user,
                                                 InfAdoptedRequest* request,
                                                 InfAdoptedRequest* trans,
                                                 const GError* error,
                                                 gpointer user_data)
{
  InfAdoptedUndoGrouping* grouping;
  InfAdoptedUndoGroupingPrivate* priv;
  guint user_id;
  grouping = INF_ADOPTED_UNDO_GROUPING(user_data);
  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
  if(priv-&gt;user != NULL)
  {
    user_id = inf_user_get_id(INF_USER(priv-&gt;user));
    if(inf_adopted_request_affects_buffer(request) ||
       inf_adopted_request_get_user_id(request) == user_id)
    {
      inf_adopted_undo_grouping_cleanup(grouping);
    }
  }
}
static void
inf_adopted_undo_grouping_init_user(InfAdoptedUndoGrouping* grouping)
{
  InfAdoptedUndoGroupingPrivate* priv;
  InfAdoptedRequestLog* log;
  InfAdoptedRequest* request;
  guint max_total_log_size;
  guint end;
  guint i;
  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
  g_assert(priv-&gt;user != NULL);
  g_signal_connect(
    G_OBJECT(inf_adopted_user_get_request_log(priv-&gt;user)),
    "add-request",
    G_CALLBACK(inf_adopted_undo_grouping_add_request_cb),
    grouping
  );
  g_object_get(
    priv-&gt;algorithm,
    "max-total-log-size", &amp;max_total_log_size,
    NULL
  );
  log = inf_adopted_user_get_request_log(priv-&gt;user);
  end = inf_adopted_request_log_get_end(log);
  for(i = inf_adopted_request_log_get_begin(log); i &lt; end; ++i)
  {
    request = inf_adopted_request_log_get_request(log, i);
    inf_adopted_undo_grouping_add_request(grouping, request);
    inf_adopted_undo_grouping_cleanup(grouping);
  }
}
static void
inf_adopted_undo_grouping_deinit_user(InfAdoptedUndoGrouping* grouping)
{
  InfAdoptedUndoGroupingPrivate* priv;
  InfAdoptedRequest* request;
  guint i;
  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
  g_assert(priv-&gt;user != NULL);
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(inf_adopted_user_get_request_log(priv-&gt;user)),
    G_CALLBACK(inf_adopted_undo_grouping_add_request_cb),
    grouping
  );
  g_object_unref(priv-&gt;user);
  priv-&gt;user = NULL;
  for(i = 0; i &lt; priv-&gt;n_items; ++i)
  {
    request =
      priv-&gt;items[(priv-&gt;first_item + i) % priv-&gt;n_alloc].request;
    g_object_unref(request);
  }
  g_free(priv-&gt;items);
  priv-&gt;items = NULL;
  priv-&gt;n_items = 0;
  priv-&gt;n_alloc = 0;
  priv-&gt;first_item = 0;
  priv-&gt;item_pos = 0;
  g_object_notify(G_OBJECT(grouping), "user");
}
static void
inf_adopted_undo_grouping_init(InfAdoptedUndoGrouping* grouping)
{
  InfAdoptedUndoGroupingPrivate* priv;
  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
  priv-&gt;algorithm = NULL;
  priv-&gt;user = NULL;
  priv-&gt;items = NULL;
  priv-&gt;n_items = 0;
  priv-&gt;n_alloc = 0;
  priv-&gt;first_item = 0;
  priv-&gt;item_pos = 0;
  priv-&gt;group_ref = 0;
  priv-&gt;group_flags = 0;
}
static void
inf_adopted_undo_grouping_dispose(GObject* object)
{
  InfAdoptedUndoGrouping* grouping;
  InfAdoptedUndoGroupingPrivate* priv;
<a name="1"></a>  grouping = INF_ADOPTED_UNDO_GROUPING(object);
  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  inf_adopted_undo_grouping_set_algorithm(grouping, NULL, NULL);
  G_OBJECT_CLASS(inf_adopted_undo_grouping_parent_class)-&gt;dispose(object);
}
static void
inf_adopted_undo_grouping_finalize(GObject* object)
{
  InfAdoptedUndoGrouping* grouping;
  InfAdoptedUndoGroupingPrivate* priv;
  grouping = INF_ADOPTED_UNDO_GROUPING(object);
  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
  G_OBJECT_CLASS(inf_adopted_undo_grouping_parent_class)-&gt;finalize(object);
}
static void
inf_adopted_undo_grouping_set_property(GObject* object,
                                       guint prop_id,
                                       const GValue* value,
                                       GParamSpec* pspec)
{
  InfAdoptedUndoGrouping* grouping;
  InfAdoptedUndoGroupingPrivate* priv;
  grouping = INF_ADOPTED_UNDO_GROUPING(object);
  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
  switch(prop_id)
  {
  case PROP_ALGORITHM:</b></font>
    inf_adopted_undo_grouping_set_algorithm(
      grouping,
      INF_ADOPTED_ALGORITHM(g_value_get_object(value)),
      NULL
    );
    break;
  case PROP_USER:
    inf_adopted_undo_grouping_set_algorithm(
      grouping,
      priv-&gt;algorithm,
<a name="0"></a>      INF_ADOPTED_USER(g_value_get_object(value))
    );
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_adopted_undo_grouping_get_property(GObject* object,
                                       guint prop_id,
                                       GValue* value,
                                       GParamSpec* pspec)
{
  InfAdoptedUndoGrouping* grouping;
  InfAdoptedUndoGroupingPrivate* priv;
  grouping = INF_ADOPTED_UNDO_GROUPING(object);
  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
  switch(prop_id)
  {
  case PROP_ALGORITHM:
    g_value_set_object(value, priv-&gt;algorithm);
    break;
  case PROP_USER:
    g_value_set_object(value, priv-&gt;user);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static gboolean
inf_adopted_undo_grouping_group_requests(InfAdoptedUndoGrouping* grouping,
                                         InfAdoptedRequest* first,
                                         InfAdoptedRequest* second)
{
  return FALSE;
}
static void</b></font>
inf_adopted_undo_grouping_class_init(
  InfAdoptedUndoGroupingClass* undo_grouping_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(undo_grouping_class);
  object_class-&gt;dispose = inf_adopted_undo_grouping_dispose;
  object_class-&gt;finalize = inf_adopted_undo_grouping_finalize;
  object_class-&gt;set_property = inf_adopted_undo_grouping_set_property;
  object_class-&gt;get_property = inf_adopted_undo_grouping_get_property;
  undo_grouping_class-&gt;group_requests =
    inf_adopted_undo_grouping_group_requests;
  g_object_class_install_property(
    object_class,
    PROP_ALGORITHM,
    g_param_spec_object(
      "algorithm",
      "Algorithm",
      "The algorithm for which to group requests",
      INF_ADOPTED_TYPE_ALGORITHM,
      G_PARAM_READWRITE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_USER,
    g_param_spec_object(
      "user",
      "User",
      "The user for which to group requests",
      INF_ADOPTED_TYPE_USER,
      G_PARAM_READWRITE
    )
  );
  undo_grouping_signals[GROUP_REQUESTS] = g_signal_new(
    "group-requests",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfAdoptedUndoGroupingClass, group_requests),
    g_signal_accumulator_true_handled, NULL,
    NULL,
    G_TYPE_BOOLEAN,
    2,
    INF_ADOPTED_TYPE_REQUEST,
    INF_ADOPTED_TYPE_REQUEST
  );
}
InfAdoptedUndoGrouping*
inf_adopted_undo_grouping_new(void)
{
  GObject* object;
  object = g_object_new(INF_ADOPTED_TYPE_UNDO_GROUPING, NULL);
  return INF_ADOPTED_UNDO_GROUPING(object);
}
InfAdoptedAlgorithm*
inf_adopted_undo_grouping_get_algorithm(InfAdoptedUndoGrouping* grouping)
{
  g_return_val_if_fail(INF_ADOPTED_IS_UNDO_GROUPING(grouping), NULL);
  return INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping)-&gt;algorithm;
}
void
inf_adopted_undo_grouping_set_algorithm(InfAdoptedUndoGrouping* grouping,
                                       InfAdoptedAlgorithm* algorithm,
                                       InfAdoptedUser* user)
{
  InfAdoptedUndoGroupingPrivate* priv;
  g_return_if_fail(INF_ADOPTED_IS_UNDO_GROUPING(grouping));
  g_return_if_fail(algorithm == NULL || INF_ADOPTED_IS_ALGORITHM(algorithm));
  g_return_if_fail(user == NULL || INF_ADOPTED_IS_USER(user));
  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
  g_object_freeze_notify(G_OBJECT(grouping));
  if(priv-&gt;algorithm != algorithm)
  {
    if(priv-&gt;algorithm != NULL)
    {
      inf_signal_handlers_disconnect_by_func(
        G_OBJECT(priv-&gt;algorithm),
        G_CALLBACK(inf_adopted_undo_grouping_end_execute_request_cb),
        grouping
      );
      if(priv-&gt;user != NULL)
        inf_adopted_undo_grouping_deinit_user(grouping);
      g_object_unref(priv-&gt;algorithm);
      priv-&gt;algorithm = NULL;
    }
    priv-&gt;algorithm = algorithm;
    if(algorithm != NULL)
    {
      g_object_ref(algorithm);
      g_signal_connect(
        G_OBJECT(priv-&gt;algorithm),
        "end-execute-request",
        G_CALLBACK(inf_adopted_undo_grouping_end_execute_request_cb),
        grouping
      );
    }
    g_object_notify(G_OBJECT(grouping), "algorithm");
  }
  if(priv-&gt;user != user)
  {
    if(priv-&gt;user != NULL)
        inf_adopted_undo_grouping_deinit_user(grouping);
    priv-&gt;user = user;
    if(user != NULL)
    {
      g_object_ref(user);
      inf_adopted_undo_grouping_init_user(grouping);
    }
    g_object_notify(G_OBJECT(grouping), "user");
  }
  g_object_thaw_notify(G_OBJECT(grouping));
}
void
inf_adopted_undo_grouping_start_group(InfAdoptedUndoGrouping* grouping,
                                      gboolean allow_group_with_prev)
{
  InfAdoptedUndoGroupingPrivate* priv;
  g_return_if_fail(INF_ADOPTED_IS_UNDO_GROUPING(grouping));
  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
  g_return_if_fail(priv-&gt;algorithm != NULL);
  g_return_if_fail(priv-&gt;user != NULL);
  if(priv-&gt;group_ref++ == 0)
  {
    priv-&gt;group_flags = INF_ADOPTED_UNDO_GROUPING_FIRST_IN_GROUP;
    if(allow_group_with_prev)
      priv-&gt;group_flags |= INF_ADOPTED_UNDO_GROUPING_ALLOW_WITH_PREV;
  }
}
void
inf_adopted_undo_grouping_end_group(InfAdoptedUndoGrouping* grouping,
                                    gboolean allow_group_with_next)
{
  InfAdoptedUndoGroupingPrivate* priv;
  g_return_if_fail(INF_ADOPTED_IS_UNDO_GROUPING(grouping));
  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
  g_return_if_fail(priv-&gt;algorithm != NULL);
  g_return_if_fail(priv-&gt;user != NULL);
  g_return_if_fail(priv-&gt;group_ref &gt; 0);
  if(--priv-&gt;group_ref == 0)
  {
    priv-&gt;group_flags = INF_ADOPTED_UNDO_GROUPING_FIRST_AFTER_GROUP;
    if(allow_group_with_next)
      priv-&gt;group_flags |= INF_ADOPTED_UNDO_GROUPING_ALLOW_WITH_NEXT;
  }
}
guint
inf_adopted_undo_grouping_get_undo_size(InfAdoptedUndoGrouping* grouping)
{
  InfAdoptedUndoGroupingPrivate* priv;
  guint max_total_log_size;
  InfAdoptedRequestLog* log;
  InfAdoptedStateVector* current;
  guint pos;
  guint index;
  InfAdoptedRequest* lower_related;
  InfAdoptedStateVector* vector;
  guint vdiff;
  g_return_val_if_fail(INF_ADOPTED_IS_UNDO_GROUPING(grouping), 0);
  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
  if(priv-&gt;item_pos == 0) return 0;
  g_object_get(
    G_OBJECT(priv-&gt;algorithm),
    "max-total-log-size",
    &amp;max_total_log_size,
    NULL
  );
  log = inf_adopted_user_get_request_log(priv-&gt;user);
  current = inf_adopted_user_get_vector(priv-&gt;user);
  pos = priv-&gt;item_pos;
  do
  {
    g_assert(pos &gt; 0);
    index = inf_adopted_request_get_index(priv-&gt;items[pos-1].request);
    lower_related = inf_adopted_request_log_lower_related(log, index);
    vector = inf_adopted_request_get_vector(lower_related);
    vdiff = inf_adopted_state_vector_vdiff(vector, current);
    if(vdiff + priv-&gt;item_pos - pos &gt;= max_total_log_size)
      return priv-&gt;item_pos - pos;
    --pos;
  } while(priv-&gt;items[(priv-&gt;first_item + pos) % priv-&gt;n_alloc].in_group);
  return priv-&gt;item_pos - pos;
}
guint
inf_adopted_undo_grouping_get_redo_size(InfAdoptedUndoGrouping* grouping)
{
  InfAdoptedUndoGroupingPrivate* priv;
  guint max_total_log_size;
  InfAdoptedRequestLog* log;
  InfAdoptedStateVector* current;
  guint pos;
  guint index;
  InfAdoptedRequest* lower_related;
  InfAdoptedStateVector* vector;
  guint vdiff;
  g_return_val_if_fail(INF_ADOPTED_IS_UNDO_GROUPING(grouping), 0);
  priv = INF_ADOPTED_UNDO_GROUPING_PRIVATE(grouping);
  if(priv-&gt;item_pos == priv-&gt;n_items) return 0;
  g_object_get(
    G_OBJECT(priv-&gt;algorithm),
    "max-total-log-size",
    &amp;max_total_log_size,
    NULL
  );
  log = inf_adopted_user_get_request_log(priv-&gt;user);
  current = inf_adopted_user_get_vector(priv-&gt;user);
  pos = priv-&gt;item_pos;
  do
  {
    g_assert(pos &lt; priv-&gt;n_items);
    index = inf_adopted_request_get_index(priv-&gt;items[pos].request);
    lower_related = inf_adopted_request_log_lower_related(log, index);
    vector = inf_adopted_request_get_vector(lower_related);
    vdiff = inf_adopted_state_vector_vdiff(vector, current);
    if(vdiff + pos - priv-&gt;item_pos &gt;= max_total_log_size)
      return pos - priv-&gt;item_pos;
    ++pos;
  } while(pos &lt; priv-&gt;n_items &amp;&amp;
          priv-&gt;items[(priv-&gt;first_item + pos) % priv-&gt;n_alloc].in_group);
  return pos - priv-&gt;item_pos;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
