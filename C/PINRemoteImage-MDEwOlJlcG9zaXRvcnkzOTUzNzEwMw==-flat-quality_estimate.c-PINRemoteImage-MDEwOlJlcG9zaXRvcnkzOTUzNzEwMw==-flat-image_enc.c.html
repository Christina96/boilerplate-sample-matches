
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.071246819338422%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-quality_estimate.c</h3>
            <pre><code>1  #include "extras/extras.h"
2  #include "webp/decode.h"
3  #include <math.h>
4  #define INVALID_BIT_POS (1ull << 63)
5  static WEBP_INLINE uint32_t GetBit(const uint8_t* const data, size_t nb,
6                                     uint64_t max_size, uint64_t* const bit_pos) {
7    uint32_t val = 0;
8    if (*bit_pos + nb <= 8 * max_size) {
9      while (nb-- > 0) {
10        const uint64_t p = (*bit_pos)++;
11        const int bit = !!(data[p >> 3] & (128 >> ((p & 7))));
12        val = (val << 1) | bit;
13      }
14    } else {
<span onclick='openModal()' class='match'>15      *bit_pos = INVALID_BIT_POS;
16    }
17    return val;
18  }
19  #define GET_BIT(n) GetBit(data, (n), size, &bit_pos)
20  #define CONDITIONAL_SKIP(n) (GET_BIT(1) ? GET_BIT((n)) : 0)
21  int VP8EstimateQuality(const uint8_t* const data, size_t size) {
</span>22    size_t pos = 0;
23    uint64_t bit_pos;
24    uint64_t sig = 0x00;
25    int ok = 0;
26    int Q = -1;
27    WebPBitstreamFeatures features;
28    if (data == NULL) return -1;
29    if (WebPGetFeatures(data, size, &features) != VP8_STATUS_OK) {
30      return -1;   
31    }
32    if (features.format == 2) return 101;  
33    if (features.format == 0 || features.has_animation) return -1;   
34    while (pos < size) {
35      sig = (sig >> 8) | ((uint64_t)data[pos++] << 40);
36      if ((sig >> 24) == 0x2a019dull) {
37        ok = 1;
38        break;
39      }
40    }
41    if (!ok) return -1;
42    if (pos + 4 > size) return -1;
43    pos += 4;
44    bit_pos = pos * 8;
45    GET_BIT(2);  
46    if (GET_BIT(1)) {       
47      int s;
48      const int update_map = GET_BIT(1);
49      if (GET_BIT(1)) {     
50        const int absolute_delta = GET_BIT(1);
51        int q[4]  = { 0, 0, 0, 0 };
52        for (s = 0; s < 4; ++s) {
53          if (GET_BIT(1)) {
54            q[s] = GET_BIT(7);
55            if (GET_BIT(1)) q[s] = -q[s];   
56          }
57        }
58        if (absolute_delta) Q = q[0];  
59        for (s = 0; s < 4; ++s) CONDITIONAL_SKIP(7);   
60      }
61      if (update_map) {
62        for (s = 0; s < 3; ++s) CONDITIONAL_SKIP(8);
63      }
64    }
65    GET_BIT(1 + 6 + 3);     
66    if (GET_BIT(1)) {       
67      if (GET_BIT(1)) {     
68        int n;
69        for (n = 0; n < 4 + 4; ++n) CONDITIONAL_SKIP(6);
70      }
71    }
72    GET_BIT(2);
73    {
74      const int base_q = GET_BIT(7);
75       CONDITIONAL_SKIP(5);
76       CONDITIONAL_SKIP(5);
77       CONDITIONAL_SKIP(5);
78       CONDITIONAL_SKIP(5);
79       CONDITIONAL_SKIP(5);
80      if (Q < 0) Q = base_q;
81    }
82    if (bit_pos == INVALID_BIT_POS) return -1;
83    Q = (127 - Q) * 100 / 127;
84    if (Q < 80) {
85      Q = (int)(pow(Q / 80., 1. / 0.38) * 80);
86    }
87    return Q;
88  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-image_enc.c</h3>
            <pre><code>1  #include "./image_enc.h"
2  #include <assert.h>
3  #include <string.h>
4  #ifdef WEBP_HAVE_PNG
5  #include <png.h>
6  #include <setjmp.h>   
7  #endif
8  #ifdef HAVE_WINCODEC_H
9  #ifdef __MINGW32__
10  #define INITGUID  
11  #endif
12  #define CINTERFACE
13  #define COBJMACROS
14  #define _WIN32_IE 0x500  
15  #include <ole2.h>  
16  #include <shlwapi.h>
17  #include <tchar.h>
18  #include <windows.h>
19  #include <wincodec.h>
20  #endif
21  #include "./imageio_util.h"
22  #include "../examples/unicode.h"
23  #ifdef HAVE_WINCODEC_H
24  #define IFS(fn)                                                     \
25    do {                                                              \
26      if (SUCCEEDED(hr)) {                                            \
27        hr = (fn);                                                    \
28        if (FAILED(hr)) fprintf(stderr, #fn " failed %08lx\n", hr);   \
29      }                                                               \
30    } while (0)
31  #ifdef __cplusplus
32  #define MAKE_REFGUID(x) (x)
33  #else
34  #define MAKE_REFGUID(x) &(x)
35  #endif
36  static HRESULT CreateOutputStream(const char* out_file_name,
37                                    int write_to_mem, IStream** stream) {
38    HRESULT hr = S_OK;
39    if (write_to_mem) {
40      IFS(CreateStreamOnHGlobal(NULL, TRUE, stream));
41    } else {
42      IFS(SHCreateStreamOnFile((const LPTSTR)out_file_name,
43                               STGM_WRITE | STGM_CREATE, stream));
44    }
45    if (FAILED(hr)) {
46      _ftprintf(stderr, _T("Error opening output file %s (%08lx)\n"),
47                (const LPTSTR)out_file_name, hr);
48    }
49    return hr;
50  }
51  static HRESULT WriteUsingWIC(const char* out_file_name, int use_stdout,
52                               REFGUID container_guid,
53                               uint8_t* rgb, int stride,
54                               uint32_t width, uint32_t height, int has_alpha) {
55    HRESULT hr = S_OK;
56    IWICImagingFactory* factory = NULL;
57    IWICBitmapFrameEncode* frame = NULL;
58    IWICBitmapEncoder* encoder = NULL;
59    IStream* stream = NULL;
60    WICPixelFormatGUID pixel_format = has_alpha ? GUID_WICPixelFormat32bppBGRA
61                                                : GUID_WICPixelFormat24bppBGR;
62    if (out_file_name == NULL || rgb == NULL) return E_INVALIDARG;
63    IFS(CoInitialize(NULL));
64    IFS(CoCreateInstance(MAKE_REFGUID(CLSID_WICImagingFactory), NULL,
65                         CLSCTX_INPROC_SERVER,
66                         MAKE_REFGUID(IID_IWICImagingFactory),
67                         (LPVOID*)&factory));
68    if (hr == REGDB_E_CLASSNOTREG) {
69      fprintf(stderr,
70              "Couldn't access Windows Imaging Component (are you running "
71              "Windows XP SP3 or newer?). PNG support not available. "
72              "Use -ppm or -pgm for available PPM and PGM formats.\n");
73    }
74    IFS(CreateOutputStream(out_file_name, use_stdout, &stream));
75    IFS(IWICImagingFactory_CreateEncoder(factory, container_guid, NULL,
76                                         &encoder));
77    IFS(IWICBitmapEncoder_Initialize(encoder, stream,
78                                     WICBitmapEncoderNoCache));
79    IFS(IWICBitmapEncoder_CreateNewFrame(encoder, &frame, NULL));
80    IFS(IWICBitmapFrameEncode_Initialize(frame, NULL));
81    IFS(IWICBitmapFrameEncode_SetSize(frame, width, height));
82    IFS(IWICBitmapFrameEncode_SetPixelFormat(frame, &pixel_format));
83    IFS(IWICBitmapFrameEncode_WritePixels(frame, height, stride,
84                                          height * stride, rgb));
85    IFS(IWICBitmapFrameEncode_Commit(frame));
86    IFS(IWICBitmapEncoder_Commit(encoder));
87    if (SUCCEEDED(hr) && use_stdout) {
88      HGLOBAL image;
89      IFS(GetHGlobalFromStream(stream, &image));
90      if (SUCCEEDED(hr)) {
91        HANDLE std_output = GetStdHandle(STD_OUTPUT_HANDLE);
92        DWORD mode;
93        const BOOL update_mode = GetConsoleMode(std_output, &mode);
94        const void* const image_mem = GlobalLock(image);
95        DWORD bytes_written = 0;
96        if (update_mode) SetConsoleMode(std_output, 0);
97        if (!WriteFile(std_output, image_mem, (DWORD)GlobalSize(image),
98                       &bytes_written, NULL) ||
99            bytes_written != GlobalSize(image)) {
100          hr = E_FAIL;
101        }
102        if (update_mode) SetConsoleMode(std_output, mode);
103        GlobalUnlock(image);
104      }
105    }
106    if (frame != NULL) IUnknown_Release(frame);
107    if (encoder != NULL) IUnknown_Release(encoder);
108    if (factory != NULL) IUnknown_Release(factory);
109    if (stream != NULL) IUnknown_Release(stream);
110    return hr;
111  }
112  int WebPWritePNG(const char* out_file_name, int use_stdout,
113                   const WebPDecBuffer* const buffer) {
114    const uint32_t width = buffer->width;
115    const uint32_t height = buffer->height;
116    uint8_t* const rgb = buffer->u.RGBA.rgba;
117    const int stride = buffer->u.RGBA.stride;
118    const int has_alpha = WebPIsAlphaMode(buffer->colorspace);
119    return SUCCEEDED(WriteUsingWIC(out_file_name, use_stdout,
120                                   MAKE_REFGUID(GUID_ContainerFormatPng),
121                                   rgb, stride, width, height, has_alpha));
122  }
123  #elif defined(WEBP_HAVE_PNG)    
124  static void PNGAPI PNGErrorFunction(png_structp png, png_const_charp dummy) {
125    (void)dummy;  
126    longjmp(png_jmpbuf(png), 1);
127  }
128  int WebPWritePNG(FILE* out_file, const WebPDecBuffer* const buffer) {
129    volatile png_structp png;
130    volatile png_infop info;
131    if (out_file == NULL || buffer == NULL) return 0;
132    png = png_create_write_struct(PNG_LIBPNG_VER_STRING,
133                                  NULL, PNGErrorFunction, NULL);
134    if (png == NULL) {
135      return 0;
136    }
137    info = png_create_info_struct(png);
138    if (info == NULL) {
139      png_destroy_write_struct((png_structpp)&png, NULL);
140      return 0;
141    }
142    if (setjmp(png_jmpbuf(png))) {
143      png_destroy_write_struct((png_structpp)&png, (png_infopp)&info);
144      return 0;
145    }
146    png_init_io(png, out_file);
147    {
148      const uint32_t width = buffer->width;
149      const uint32_t height = buffer->height;
150      png_bytep row = buffer->u.RGBA.rgba;
151      const int stride = buffer->u.RGBA.stride;
152      const int has_alpha = WebPIsAlphaMode(buffer->colorspace);
153      uint32_t y;
154      png_set_IHDR(png, info, width, height, 8,
155                   has_alpha ? PNG_COLOR_TYPE_RGBA : PNG_COLOR_TYPE_RGB,
156                   PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT,
157                   PNG_FILTER_TYPE_DEFAULT);
158      png_write_info(png, info);
159      for (y = 0; y < height; ++y) {
160        png_write_rows(png, &row, 1);
161        row += stride;
162      }
163    }
164    png_write_end(png, info);
165    png_destroy_write_struct((png_structpp)&png, (png_infopp)&info);
166    return 1;
167  }
168  #else    
169  int WebPWritePNG(FILE* fout, const WebPDecBuffer* const buffer) {
170    if (fout == NULL || buffer == NULL) return 0;
171    fprintf(stderr, "PNG support not compiled. Please install the libpng "
172            "development package before building.\n");
173    fprintf(stderr, "You can run with -ppm flag to decode in PPM format.\n");
174    return 0;
175  }
176  #endif
177  static int WritePPMPAM(FILE* fout, const WebPDecBuffer* const buffer,
178                         int alpha) {
179    if (fout == NULL || buffer == NULL) {
180      return 0;
181    } else {
182      const uint32_t width = buffer->width;
183      const uint32_t height = buffer->height;
184      const uint8_t* row = buffer->u.RGBA.rgba;
185      const int stride = buffer->u.RGBA.stride;
186      const size_t bytes_per_px = alpha ? 4 : 3;
187      uint32_t y;
188      if (row == NULL) return 0;
189      if (alpha) {
190        fprintf(fout, "P7\nWIDTH %u\nHEIGHT %u\nDEPTH 4\nMAXVAL 255\n"
191                      "TUPLTYPE RGB_ALPHA\nENDHDR\n", width, height);
192      } else {
193        fprintf(fout, "P6\n%u %u\n255\n", width, height);
194      }
195      for (y = 0; y < height; ++y) {
196        if (fwrite(row, width, bytes_per_px, fout) != bytes_per_px) {
197          return 0;
198        }
199        row += stride;
200      }
201    }
202    return 1;
203  }
204  int WebPWritePPM(FILE* fout, const WebPDecBuffer* const buffer) {
205    return WritePPMPAM(fout, buffer, 0);
206  }
207  int WebPWritePAM(FILE* fout, const WebPDecBuffer* const buffer) {
208    return WritePPMPAM(fout, buffer, 1);
209  }
210  int WebPWrite16bAsPGM(FILE* fout, const WebPDecBuffer* const buffer) {
211    const uint32_t width = buffer->width;
212    const uint32_t height = buffer->height;
213    const uint8_t* rgba = buffer->u.RGBA.rgba;
214    const int stride = buffer->u.RGBA.stride;
215    const uint32_t bytes_per_px = 2;
216    uint32_t y;
217    if (fout == NULL || buffer == NULL || rgba == NULL) return 0;
218    fprintf(fout, "P5\n%u %u\n255\n", width * bytes_per_px, height);
219    for (y = 0; y < height; ++y) {
220      if (fwrite(rgba, width, bytes_per_px, fout) != bytes_per_px) {
221        return 0;
222      }
223      rgba += stride;
224    }
225    return 1;
226  }
227  static void PutLE16(uint8_t* const dst, uint32_t value) {
228    dst[0] = (value >> 0) & 0xff;
229    dst[1] = (value >> 8) & 0xff;
230  }
231  static void PutLE32(uint8_t* const dst, uint32_t value) {
232    PutLE16(dst + 0, (value >>  0) & 0xffff);
233    PutLE16(dst + 2, (value >> 16) & 0xffff);
234  }
235  #define BMP_HEADER_SIZE 54
236  int WebPWriteBMP(FILE* fout, const WebPDecBuffer* const buffer) {
237    const int has_alpha = WebPIsAlphaMode(buffer->colorspace);
238    const uint32_t width = buffer->width;
239    const uint32_t height = buffer->height;
240    const uint8_t* rgba = buffer->u.RGBA.rgba;
241    const int stride = buffer->u.RGBA.stride;
242    const uint32_t bytes_per_px = has_alpha ? 4 : 3;
243    uint32_t y;
244    const uint32_t line_size = bytes_per_px * width;
245    const uint32_t bmp_stride = (line_size + 3) & ~3;   
246    const uint32_t total_size = bmp_stride * height + BMP_HEADER_SIZE;
247    uint8_t bmp_header[BMP_HEADER_SIZE] = { 0 };
248    if (fout == NULL || buffer == NULL || rgba == NULL) return 0;
249    PutLE16(bmp_header + 0, 0x4d42);                
250    PutLE32(bmp_header + 2, total_size);            
251    PutLE32(bmp_header + 6, 0);                     
252    PutLE32(bmp_header + 10, BMP_HEADER_SIZE);      
253    PutLE32(bmp_header + 14, 40);                   
254    PutLE32(bmp_header + 18, width);                
255    PutLE32(bmp_header + 22, -(int)height);         
256    PutLE16(bmp_header + 26, 1);                    
257    PutLE16(bmp_header + 28, bytes_per_px * 8);     
258    PutLE32(bmp_header + 30, 0);                    
259    PutLE32(bmp_header + 34, 0);                    
260    PutLE32(bmp_header + 38, 2400);                 
261    PutLE32(bmp_header + 42, 2400);                 
262    PutLE32(bmp_header + 46, 0);                    
263    PutLE32(bmp_header + 50, 0);                    
264    if (fwrite(bmp_header, sizeof(bmp_header), 1, fout) != 1) {
265      return 0;
266    }
267    for (y = 0; y < height; ++y) {
268      if (fwrite(rgba, line_size, 1, fout) != 1) {
269        return 0;
270      }
271      if (bmp_stride != line_size) {
272        const uint8_t zeroes[3] = { 0 };
273        if (fwrite(zeroes, bmp_stride - line_size, 1, fout) != 1) {
274          return 0;
275        }
276      }
<span onclick='openModal()' class='match'>277      rgba += stride;
278    }
279    return 1;
280  }
281  #undef BMP_HEADER_SIZE
282  #define NUM_IFD_ENTRIES 15
283  #define EXTRA_DATA_SIZE 16
284  #define EXTRA_DATA_OFFSET (10 + 12 * NUM_IFD_ENTRIES + 4)
285  #define TIFF_HEADER_SIZE (EXTRA_DATA_OFFSET + EXTRA_DATA_SIZE)
286  int WebPWriteTIFF(FILE* fout, const WebPDecBuffer* const buffer) {
</span>287    const int has_alpha = WebPIsAlphaMode(buffer->colorspace);
288    const uint32_t width = buffer->width;
289    const uint32_t height = buffer->height;
290    const uint8_t* rgba = buffer->u.RGBA.rgba;
291    const int stride = buffer->u.RGBA.stride;
292    const uint8_t bytes_per_px = has_alpha ? 4 : 3;
293    const uint8_t assoc_alpha =
294        WebPIsPremultipliedMode(buffer->colorspace) ? 1 : 2;
295    const uint8_t num_ifd_entries = has_alpha ? NUM_IFD_ENTRIES
296                                              : NUM_IFD_ENTRIES - 1;
297    uint8_t tiff_header[TIFF_HEADER_SIZE] = {
298      0x49, 0x49, 0x2a, 0x00,   
299      8, 0, 0, 0,               
300      num_ifd_entries, 0,       
301      0x00, 0x01, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0,    
302      0x01, 0x01, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0,    
303      0x02, 0x01, 3, 0, bytes_per_px, 0, 0, 0,     
304          EXTRA_DATA_OFFSET + 0, 0, 0, 0,
305      0x03, 0x01, 3, 0, 1, 0, 0, 0, 1, 0, 0, 0,    
306      0x06, 0x01, 3, 0, 1, 0, 0, 0, 2, 0, 0, 0,    
307      0x11, 0x01, 4, 0, 1, 0, 0, 0,                
308          TIFF_HEADER_SIZE, 0, 0, 0,               
309      0x12, 0x01, 3, 0, 1, 0, 0, 0, 1, 0, 0, 0,    
310      0x15, 0x01, 3, 0, 1, 0, 0, 0,                
311          bytes_per_px, 0, 0, 0,
312      0x16, 0x01, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0,    
313      0x17, 0x01, 4, 0, 1, 0, 0, 0, 0, 0, 0, 0,    
314      0x1a, 0x01, 5, 0, 1, 0, 0, 0,                
315          EXTRA_DATA_OFFSET + 8, 0, 0, 0,
316      0x1b, 0x01, 5, 0, 1, 0, 0, 0,                
317          EXTRA_DATA_OFFSET + 8, 0, 0, 0,
318      0x1c, 0x01, 3, 0, 1, 0, 0, 0, 1, 0, 0, 0,    
319      0x28, 0x01, 3, 0, 1, 0, 0, 0, 2, 0, 0, 0,    
320      0x52, 0x01, 3, 0, 1, 0, 0, 0,
321          assoc_alpha, 0, 0, 0,                    
322      0, 0, 0, 0,                                  
323      8, 0, 8, 0, 8, 0, 8, 0,      
324      72, 0, 0, 0, 1, 0, 0, 0      
325    };
326    uint32_t y;
327    if (fout == NULL || buffer == NULL || rgba == NULL) return 0;
328    PutLE32(tiff_header + 10 + 8, width);
329    PutLE32(tiff_header + 22 + 8, height);
330    PutLE32(tiff_header + 106 + 8, height);
331    PutLE32(tiff_header + 118 + 8, width * bytes_per_px * height);
332    if (!has_alpha) PutLE32(tiff_header + 178, 0);  
333    if (fwrite(tiff_header, sizeof(tiff_header), 1, fout) != 1) {
334      return 0;
335    }
336    for (y = 0; y < height; ++y) {
337      if (fwrite(rgba, bytes_per_px, width, fout) != width) {
338        return 0;
339      }
340      rgba += stride;
341    }
342    return 1;
343  }
344  #undef TIFF_HEADER_SIZE
345  #undef EXTRA_DATA_OFFSET
346  #undef EXTRA_DATA_SIZE
347  #undef NUM_IFD_ENTRIES
348  int WebPWriteAlphaPlane(FILE* fout, const WebPDecBuffer* const buffer) {
349    if (fout == NULL || buffer == NULL) {
350      return 0;
351    } else {
352      const uint32_t width = buffer->width;
353      const uint32_t height = buffer->height;
354      const uint8_t* a = buffer->u.YUVA.a;
355      const int a_stride = buffer->u.YUVA.a_stride;
356      uint32_t y;
357      if (a == NULL) return 0;
358      fprintf(fout, "P5\n%u %u\n255\n", width, height);
359      for (y = 0; y < height; ++y) {
360        if (fwrite(a, width, 1, fout) != 1) return 0;
361        a += a_stride;
362      }
363      return 1;
364    }
365  }
366  int WebPWritePGM(FILE* fout, const WebPDecBuffer* const buffer) {
367    if (fout == NULL || buffer == NULL) {
368      return 0;
369    } else {
370      const int width = buffer->width;
371      const int height = buffer->height;
372      const WebPYUVABuffer* const yuv = &buffer->u.YUVA;
373      const uint8_t* src_y = yuv->y;
374      const uint8_t* src_u = yuv->u;
375      const uint8_t* src_v = yuv->v;
376      const uint8_t* src_a = yuv->a;
377      const int uv_width = (width + 1) / 2;
378      const int uv_height = (height + 1) / 2;
379      const int a_height = (src_a != NULL) ? height : 0;
380      int ok = 1;
381      int y;
382      if (src_y == NULL || src_u == NULL || src_v == NULL) return 0;
383      fprintf(fout, "P5\n%d %d\n255\n",
384              (width + 1) & ~1, height + uv_height + a_height);
385      for (y = 0; ok && y < height; ++y) {
386        ok &= (fwrite(src_y, width, 1, fout) == 1);
387        if (width & 1) fputc(0, fout);    
388        src_y += yuv->y_stride;
389      }
390      for (y = 0; ok && y < uv_height; ++y) {
391        ok &= (fwrite(src_u, uv_width, 1, fout) == 1);
392        ok &= (fwrite(src_v, uv_width, 1, fout) == 1);
393        src_u += yuv->u_stride;
394        src_v += yuv->v_stride;
395      }
396      for (y = 0; ok && y < a_height; ++y) {
397        ok &= (fwrite(src_a, width, 1, fout) == 1);
398        if (width & 1) fputc(0, fout);    
399        src_a += yuv->a_stride;
400      }
401      return ok;
402    }
403  }
404  int WebPWriteYUV(FILE* fout, const WebPDecBuffer* const buffer) {
405    if (fout == NULL || buffer == NULL) {
406      return 0;
407    } else {
408      const int width = buffer->width;
409      const int height = buffer->height;
410      const WebPYUVABuffer* const yuv = &buffer->u.YUVA;
411      const uint8_t* src_y = yuv->y;
412      const uint8_t* src_u = yuv->u;
413      const uint8_t* src_v = yuv->v;
414      const uint8_t* src_a = yuv->a;
415      const int uv_width = (width + 1) / 2;
416      const int uv_height = (height + 1) / 2;
417      const int a_height = (src_a != NULL) ? height : 0;
418      int ok = 1;
419      int y;
420      if (src_y == NULL || src_u == NULL || src_v == NULL) return 0;
421      for (y = 0; ok && y < height; ++y) {
422        ok &= (fwrite(src_y, width, 1, fout) == 1);
423        src_y += yuv->y_stride;
424      }
425      for (y = 0; ok && y < uv_height; ++y) {
426        ok &= (fwrite(src_u, uv_width, 1, fout) == 1);
427        src_u += yuv->u_stride;
428      }
429      for (y = 0; ok && y < uv_height; ++y) {
430        ok &= (fwrite(src_v, uv_width, 1, fout) == 1);
431        src_v += yuv->v_stride;
432      }
433      for (y = 0; ok && y < a_height; ++y) {
434        ok &= (fwrite(src_a, width, 1, fout) == 1);
435        src_a += yuv->a_stride;
436      }
437      return ok;
438    }
439  }
440  int WebPSaveImage(const WebPDecBuffer* const buffer,
441                    WebPOutputFileFormat format,
442                    const char* const out_file_name) {
443    FILE* fout = NULL;
444    int needs_open_file = 1;
445    const int use_stdout =
446        (out_file_name != NULL) && !WSTRCMP(out_file_name, "-");
447    int ok = 1;
448    if (buffer == NULL || out_file_name == NULL) return 0;
449  #ifdef HAVE_WINCODEC_H
450    needs_open_file = (format != PNG);
451  #endif
452    if (needs_open_file) {
453      fout = use_stdout ? ImgIoUtilSetBinaryMode(stdout)
454                        : WFOPEN(out_file_name, "wb");
455      if (fout == NULL) {
456        WFPRINTF(stderr, "Error opening output file %s\n",
457                 (const W_CHAR*)out_file_name);
458        return 0;
459      }
460    }
461    if (format == PNG ||
462        format == RGBA || format == BGRA || format == ARGB ||
463        format == rgbA || format == bgrA || format == Argb) {
464  #ifdef HAVE_WINCODEC_H
465      ok &= WebPWritePNG(out_file_name, use_stdout, buffer);
466  #else
467      ok &= WebPWritePNG(fout, buffer);
468  #endif
469    } else if (format == PAM) {
470      ok &= WebPWritePAM(fout, buffer);
471    } else if (format == PPM || format == RGB || format == BGR) {
472      ok &= WebPWritePPM(fout, buffer);
473    } else if (format == RGBA_4444 || format == RGB_565 || format == rgbA_4444) {
474      ok &= WebPWrite16bAsPGM(fout, buffer);
475    } else if (format == BMP) {
476      ok &= WebPWriteBMP(fout, buffer);
477    } else if (format == TIFF) {
478      ok &= WebPWriteTIFF(fout, buffer);
479    } else if (format == RAW_YUV) {
480      ok &= WebPWriteYUV(fout, buffer);
481    } else if (format == PGM || format == YUV || format == YUVA) {
482      ok &= WebPWritePGM(fout, buffer);
483    } else if (format == ALPHA_PLANE_ONLY) {
484      ok &= WebPWriteAlphaPlane(fout, buffer);
485    }
486    if (fout != NULL && fout != stdout) {
487      fclose(fout);
488    }
489    return ok;
490  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-quality_estimate.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-image_enc.c</div>
                </div>
                <div class="column column_space"><pre><code>15      *bit_pos = INVALID_BIT_POS;
16    }
17    return val;
18  }
19  #define GET_BIT(n) GetBit(data, (n), size, &bit_pos)
20  #define CONDITIONAL_SKIP(n) (GET_BIT(1) ? GET_BIT((n)) : 0)
21  int VP8EstimateQuality(const uint8_t* const data, size_t size) {
</pre></code></div>
                <div class="column column_space"><pre><code>277      rgba += stride;
278    }
279    return 1;
280  }
281  #undef BMP_HEADER_SIZE
282  #define NUM_IFD_ENTRIES 15
283  #define EXTRA_DATA_SIZE 16
284  #define EXTRA_DATA_OFFSET (10 + 12 * NUM_IFD_ENTRIES + 4)
285  #define TIFF_HEADER_SIZE (EXTRA_DATA_OFFSET + EXTRA_DATA_SIZE)
286  int WebPWriteTIFF(FILE* fout, const WebPDecBuffer* const buffer) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    