<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-xmpp-manager.c &amp; inf-gtk-permissions-dialog.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-xmpp-manager.c &amp; inf-gtk-permissions-dialog.c
      </h3>
<h1 align="center">
        3.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-xmpp-manager.c (5.8315334%)<th>inf-gtk-permissions-dialog.c (2.057927%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(77-103)<td><a href="#" name="0">(55-119)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(145-165)<td><a href="#" name="1">(2795-2815)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-xmpp-manager.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/common/inf-xmpp-manager.h&gt;
2 #include &lt;libinfinity/common/inf-xml-connection.h&gt;
3 #include &lt;libinfinity/common/inf-tcp-connection.h&gt;
4 #include &lt;libinfinity/inf-signals.h&gt;
5 #include &lt;string.h&gt;
6 typedef enum _InfXmppManagerKeyKind {
7   INF_XMPP_MANAGER_KEY_HOSTNAME,
8   INF_XMPP_MANAGER_KEY_ADDRESS
9 } InfXmppManagerKeyKind;
10 typedef struct _InfXmppManagerKey InfXmppManagerKey;
11 struct _InfXmppManagerKey {
12   InfXmppManagerKeyKind kind;
13   union {
14     struct {
15       InfIpAddress* address;
16       guint port;
17     } address;
18     struct {
19       gchar* hostname;
20       gchar* service;
21 <a name="0"></a>      gchar* srv;
22     } hostname;
23   } shared;
24 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
25 typedef struct _InfXmppManagerConnectionInfo InfXmppManagerConnectionInfo;
26 struct _InfXmppManagerConnectionInfo {
27   InfXmppManager* manager;
28   InfXmppConnection* xmpp;
29   InfNameResolver* resolver; 
30   InfXmppManagerKey** keys;
31   guint n_keys;
32 };
33 typedef struct _InfXmppManagerPrivate InfXmppManagerPrivate;
34 struct _InfXmppManagerPrivate {
35   GTree* connections;
36 };
37 enum {
38   CONNECTION_ADDED,
39   CONNECTION_REMOVED,
40   LAST_SIGNAL
41 };
42 #define INF_XMPP_MANAGER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_XMPP_MANAGER, InfXmppManagerPrivate))
43 static guint xmpp_manager_signals[LAST_SIGNAL];</b></font>
44 G_DEFINE_TYPE_WITH_CODE(InfXmppManager, inf_xmpp_manager, G_TYPE_OBJECT,
45   G_ADD_PRIVATE(InfXmppManager))
46 static InfXmppManagerKey*
47 inf_xmpp_manager_key_copy(const InfXmppManagerKey* orig_key)
48 {
49   InfXmppManagerKey* key;
50   key = g_slice_new(InfXmppManagerKey);
51   key-&gt;kind = orig_key-&gt;kind;
52   switch(key-&gt;kind)
53   {
54   case INF_XMPP_MANAGER_KEY_ADDRESS:
55     key-&gt;shared.address.address =
56       inf_ip_address_copy(orig_key-&gt;shared.address.address);
57     key-&gt;shared.address.port = orig_key-&gt;shared.address.port;
58     break;
59   case INF_XMPP_MANAGER_KEY_HOSTNAME:
60     key-&gt;shared.hostname.hostname =
61       g_strdup(orig_key-&gt;shared.hostname.hostname);
62     key-&gt;shared.hostname.service =
63       g_strdup(orig_key-&gt;shared.hostname.service);
64     key-&gt;shared.hostname.srv =
65       g_strdup(orig_key-&gt;shared.hostname.srv);
66     break;
67   default:
68     g_assert_not_reached();
69     break;
70   }
71   return key;
72 }
73 static void
74 <a name="1"></a>inf_xmpp_manager_key_free(gpointer key_ptr)
75 {
76   InfXmppManagerKey* key;
77 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  key = (InfXmppManagerKey*)key_ptr;
78   switch(key-&gt;kind)
79   {
80   case INF_XMPP_MANAGER_KEY_ADDRESS:
81     inf_ip_address_free(key-&gt;shared.address.address);
82     break;
83   case INF_XMPP_MANAGER_KEY_HOSTNAME:
84     g_free(key-&gt;shared.hostname.hostname);
85     g_free(key-&gt;shared.hostname.service);
86     g_free(key-&gt;shared.hostname.srv);
87     break;
88   default:
89     g_assert_not_reached();
90     break;
91   }
92   g_slice_free(InfXmppManagerKey, key);
93 }
94 static int</b></font>
95 inf_xmpp_manager_strcmp_nul(const gchar* str1,
96                             const gchar* str2)
97 {
98   if(str1 == NULL &amp;&amp; str2 == NULL)
99     return 0;
100   else if(str1 == NULL &amp;&amp; str2 != NULL)
101     return +1;
102   else if(str1 != NULL &amp;&amp; str2 == NULL)
103     return -1;
104   else
105     return strcmp(str1, str2);
106 }
107 static int
108 inf_xmpp_manager_key_cmp(gconstpointer first,
109                          gconstpointer second,
110                          G_GNUC_UNUSED gpointer data)
111 {
112   const InfXmppManagerKey* first_key;
113   const InfXmppManagerKey* second_key;
114   int cmp;
115   first_key = (const InfXmppManagerKey*)first;
116   second_key = (const InfXmppManagerKey*)second;
117   if(first_key-&gt;kind &lt; second_key-&gt;kind)
118     return -1;
119   else if(first_key-&gt;kind &gt; second_key-&gt;kind)
120     return 1;
121   switch(first_key-&gt;kind)
122   {
123   case INF_XMPP_MANAGER_KEY_ADDRESS:
124     if(first_key-&gt;shared.address.port &lt; second_key-&gt;shared.address.port)
125     {
126       return -1;
127     }
128     else if(first_key-&gt;shared.address.port &gt; second_key-&gt;shared.address.port)
129     {
130       return 1;
131     }
132     else
133     {
134       return inf_ip_address_collate(
135         first_key-&gt;shared.address.address,
136         second_key-&gt;shared.address.address
137       );
138     }
139   case INF_XMPP_MANAGER_KEY_HOSTNAME:
140     cmp = strcmp(
141       first_key-&gt;shared.hostname.hostname,
142       second_key-&gt;shared.hostname.hostname
143     );
144     if(cmp != 0) return cmp;
145     cmp = inf_xmpp_manager_strcmp_nul(
146       first_key-&gt;shared.hostname.service,
147       second_key-&gt;shared.hostname.service
148     );
149     if(cmp != 0) return cmp;
150     cmp = inf_xmpp_manager_strcmp_nul(
151       first_key-&gt;shared.hostname.srv,
152       second_key-&gt;shared.hostname.srv
153     );
154     return cmp;
155   default:
156     g_assert_not_reached();
157     return 0;
158   }
159 }
160 InfXmppManagerConnectionInfo*
161 inf_xmpp_manager_lookup_connection(InfXmppManager* manager,
162                                    InfXmppConnection* connection)
163 {
164   InfXmppManagerPrivate* priv;
165   InfXmppManagerKey key;
166   InfTcpConnection* tcp;
167   InfNameResolver* resolver;
168   InfXmppManagerConnectionInfo* info;
169   priv = INF_XMPP_MANAGER_PRIVATE(manager);
170   g_object_get(G_OBJECT(connection), "tcp-connection", &amp;tcp, NULL);
171   key.shared.address.address = inf_tcp_connection_get_remote_address(tcp);
172   key.shared.address.port = inf_tcp_connection_get_remote_port(tcp);
173   if(key.shared.address.address == NULL || key.shared.address.port == 0)
174   {
175     g_object_get(G_OBJECT(tcp), "resolver", &amp;resolver, NULL);
176     if(resolver == NULL) return NULL; 
177     key.kind = INF_XMPP_MANAGER_KEY_HOSTNAME;
178     key.shared.hostname.hostname =
179       (gchar*)inf_name_resolver_get_hostname(resolver);
180     key.shared.hostname.service =
181       (gchar*)inf_name_resolver_get_service(resolver);
182     key.shared.hostname.srv =
183       (gchar*)inf_name_resolver_get_srv(resolver);
184     g_object_unref(resolver);
185   }
186   else
187   {
188     key.kind = INF_XMPP_MANAGER_KEY_ADDRESS;
189   }
190   g_object_unref(tcp);
191   info = g_tree_lookup(priv-&gt;connections, &amp;key);
192   return info;
193 }
194 static InfXmppManagerConnectionInfo*
195 inf_xmpp_manager_check_key(InfXmppManager* manager,
196                            InfXmppManagerConnectionInfo* info,
197                            const InfXmppManagerKey* key,
198                            gboolean* has_keys)
199 {
200   InfXmppManagerPrivate* priv;
201   InfXmppManagerKey* permanent_key;
202   InfXmppManagerConnectionInfo* lookup;
203   guint i;
204   priv = INF_XMPP_MANAGER_PRIVATE(manager);
205   lookup = g_tree_lookup(priv-&gt;connections, key);
206   if(lookup != NULL &amp;&amp; lookup != info)
207     return lookup;
208   if(lookup == NULL)
209   {
210     permanent_key = inf_xmpp_manager_key_copy(key);
211     g_tree_insert(priv-&gt;connections, permanent_key, info);
212     info-&gt;keys = g_realloc(
213       info-&gt;keys,
214       sizeof(InfXmppManagerKey*) * (info-&gt;n_keys + 1)
215     );
216     info-&gt;keys[info-&gt;n_keys] = permanent_key;
217     ++info-&gt;n_keys;
218   }
219   else
220   {
221     for(i = 0; i &lt; info-&gt;n_keys; ++i)
222     {
223       if(inf_xmpp_manager_key_cmp(info-&gt;keys[i], key, NULL) == 0)
224       {
225         has_keys[i] = TRUE;
226         break;
227       }
228     }
229   }
230   return NULL;
231 }
232 static void
233 inf_xmpp_manager_connection_info_free(InfXmppManagerConnectionInfo* info);
234 static gboolean
235 inf_xmpp_manager_update_keys(InfXmppManager* manager,
236                              InfXmppManagerConnectionInfo* info,
237                              gboolean is_added)
238 {
239   InfXmppManagerPrivate* priv;
240   guint n_keys;
241   gboolean* has_keys;
242   guint i;
243   InfTcpConnection* tcp;
244   InfNameResolver* resolver;
245   InfXmppManagerKey key;
246   InfXmppManagerConnectionInfo* duplicate_info;
247   InfXmppConnection* xmpp;
248   gboolean result;
249   priv = INF_XMPP_MANAGER_PRIVATE(manager);
250   n_keys = info-&gt;n_keys;
251   if(n_keys &gt; 0)
252     has_keys = g_malloc(n_keys * sizeof(gboolean));
253   else
254     has_keys = NULL;
255   for(i = 0; i &lt; n_keys; ++i)
256     has_keys[i] = FALSE;
257   duplicate_info = NULL;
258   g_object_get(G_OBJECT(info-&gt;xmpp), "tcp-connection", &amp;tcp, NULL);
259   key.kind = INF_XMPP_MANAGER_KEY_ADDRESS;
260   key.shared.address.address = inf_tcp_connection_get_remote_address(tcp);
261   key.shared.address.port = inf_tcp_connection_get_remote_port(tcp);
262   if(key.shared.address.address != NULL &amp;&amp; key.shared.address.port != 0)
263   {
264     duplicate_info =
265       inf_xmpp_manager_check_key(manager, info, &amp;key, has_keys);
266   }
267   if(duplicate_info == NULL)
268   {
269     g_object_get(G_OBJECT(tcp), "resolver", &amp;resolver, NULL);
270     if(resolver != NULL)
271     {
272       key.kind = INF_XMPP_MANAGER_KEY_HOSTNAME;
273       key.shared.hostname.hostname =
274         (gchar*)inf_name_resolver_get_hostname(resolver);
275       key.shared.hostname.service =
276         (gchar*)inf_name_resolver_get_service(resolver);
277       key.shared.hostname.srv =
278         (gchar*)inf_name_resolver_get_srv(resolver);
279       duplicate_info =
280         inf_xmpp_manager_check_key(manager, info, &amp;key, has_keys);
281       if(duplicate_info == NULL &amp;&amp;
282          inf_name_resolver_finished(resolver) == TRUE)
283       {
284         for(i = 0; i &lt; inf_name_resolver_get_n_addresses(resolver); ++i)
285         {
286           key.kind = INF_XMPP_MANAGER_KEY_ADDRESS;
287           key.shared.address.address =
288             (InfIpAddress*)inf_name_resolver_get_address(resolver, i);
289           key.shared.address.port =
290             inf_name_resolver_get_port(resolver, i);
291           duplicate_info =
292             inf_xmpp_manager_check_key(manager, info, &amp;key, has_keys);
293           if(duplicate_info != NULL)
294             break;
295         }
296       }
297       g_object_unref(resolver);
298     }
299   }
300   g_object_unref(tcp);
301   result = TRUE;
302   if(duplicate_info == NULL)
303   {
304     for(i = 0; i &lt; n_keys; )
305     {
306       if(has_keys[i] == FALSE)
307       {
308         g_tree_remove(priv-&gt;connections, info-&gt;keys[i]);
309         g_assert(n_keys &gt; 0);
310         g_assert(info-&gt;n_keys &gt; 0);
311         g_assert(info-&gt;n_keys &gt;= n_keys);
312         info-&gt;keys[i] = info-&gt;keys[n_keys - 1];
313         has_keys[i] = has_keys[n_keys - 1];
314         info-&gt;keys[n_keys - 1] = info-&gt;keys[info-&gt;n_keys - 1];
315         --n_keys;
316         if(info-&gt;n_keys &gt; 1)
317         {
318           info-&gt;keys = g_realloc(
319             info-&gt;keys,
320             sizeof(InfXmppManagerKey*) * (info-&gt;n_keys - 1)
321           );
322           --info-&gt;n_keys;
323         }
324         else
325         {
326           g_free(info-&gt;keys);
327           info-&gt;keys = NULL;
328           info-&gt;n_keys = 0;
329         }
330       }
331       else
332       {
333         ++i;
334       }
335     }
336     if(info-&gt;n_keys == 0)
337     {
338       xmpp = info-&gt;xmpp;
339       g_object_ref(xmpp);
340       g_warning("Connection has no keys anymore!");
341       inf_xmpp_manager_connection_info_free(info);
342       if(is_added == TRUE)
343       {
344         g_signal_emit(
345           G_OBJECT(manager),
346           xmpp_manager_signals[CONNECTION_REMOVED],
347           0,
348           xmpp,
349           NULL
350         );
351       }
352       g_object_unref(xmpp);
353       result = FALSE;
354     }
355   }
356   else
357   {
358     for(i = 0; i &lt; info-&gt;n_keys; ++i)
359       g_tree_remove(priv-&gt;connections, info-&gt;keys[i]);
360     xmpp = info-&gt;xmpp;
361     g_object_ref(xmpp);
362     inf_xmpp_manager_connection_info_free(info);
363     if(is_added == TRUE)
364     {
365       g_signal_emit(
366         G_OBJECT(manager),
367         xmpp_manager_signals[CONNECTION_REMOVED],
368         0,
369         xmpp,
370         duplicate_info-&gt;xmpp
371       );
372     }
373     g_object_unref(xmpp);
374     result = FALSE;
375   }
376   g_free(has_keys);
377   return result;
378 }
379 static void
380 inf_xmpp_manager_notify_cb(GObject* object,
381                            GParamSpec* pspec,
382                            gpointer user_data)
383 {
384   InfXmppManagerConnectionInfo* info;
385   info = (InfXmppManagerConnectionInfo*)user_data;
386   inf_xmpp_manager_update_keys(info-&gt;manager, info, TRUE);
387 }
388 static void
389 inf_xmpp_manager_resolved_cb(InfNameResolver* resolver,
390                              const GError* error,
391                              gpointer user_data)
392 {
393   InfXmppManagerConnectionInfo* info;
394   info = (InfXmppManagerConnectionInfo*)user_data;
395   inf_xmpp_manager_update_keys(info-&gt;manager, info, TRUE);
396 }
397 static void
398 inf_xmpp_manager_connection_info_set_resolver(InfXmppManagerConnectionInfo* info,
399                                               InfNameResolver* resolver)
400 {
401   if(info-&gt;resolver != NULL)
402   {
403     inf_signal_handlers_disconnect_by_func(
404       info-&gt;resolver,
405       G_CALLBACK(inf_xmpp_manager_notify_cb),
406       info
407     );
408     inf_signal_handlers_disconnect_by_func(
409       info-&gt;resolver,
410       G_CALLBACK(inf_xmpp_manager_resolved_cb),
411       info
412     );
413     g_object_unref(info-&gt;resolver);
414   }
415   info-&gt;resolver = resolver;
416   if(resolver != NULL)
417   {
418     g_object_ref(resolver);
419     g_signal_connect(
420       G_OBJECT(resolver),
421       "notify::hostname",
422       G_CALLBACK(inf_xmpp_manager_notify_cb),
423       info
424     );
425     g_signal_connect(
426       G_OBJECT(resolver),
427       "notify::service",
428       G_CALLBACK(inf_xmpp_manager_notify_cb),
429       info
430     );
431     g_signal_connect(
432       G_OBJECT(resolver),
433       "notify::srv",
434       G_CALLBACK(inf_xmpp_manager_notify_cb),
435       info
436     );
437     g_signal_connect(
438       G_OBJECT(resolver),
439       "resolved",
440       G_CALLBACK(inf_xmpp_manager_resolved_cb),
441       info
442     );
443   }
444 }
445 static void
446 inf_xmpp_manager_notify_resolver_cb(GObject* object,
447                                     GParamSpec* pspec,
448                                     gpointer user_data)
449 {
450   InfXmppManagerConnectionInfo* info;
451   InfNameResolver* resolver;
452   g_object_get(object, "resolver", &amp;resolver, NULL);
453   info = (InfXmppManagerConnectionInfo*)user_data;
454   inf_xmpp_manager_connection_info_set_resolver(info, resolver);
455   g_object_unref(resolver);
456   inf_xmpp_manager_update_keys(info-&gt;manager, info, TRUE);
457 }
458 static InfXmppManagerConnectionInfo*
459 inf_xmpp_manager_connection_info_new(InfXmppManager* manager,
460                                      InfXmppConnection* xmpp)
461 {
462   InfXmppManagerConnectionInfo* info;
463   InfTcpConnection* tcp;
464   InfNameResolver* resolver;
465   g_object_get(G_OBJECT(xmpp), "tcp-connection", &amp;tcp, NULL);
466   g_assert(tcp != NULL);
467   info = g_slice_new(InfXmppManagerConnectionInfo);
468   info-&gt;manager = manager;
469   info-&gt;xmpp = xmpp;
470   info-&gt;resolver = NULL;
471   info-&gt;keys = NULL;
472   info-&gt;n_keys = 0;
473   g_object_ref(xmpp);
474   g_signal_connect(
475     G_OBJECT(tcp),
476     "notify::remote-address",
477     G_CALLBACK(inf_xmpp_manager_notify_cb),
478     info
479   );
480   g_signal_connect(
481     G_OBJECT(tcp),
482     "notify::remote-port",
483     G_CALLBACK(inf_xmpp_manager_notify_cb),
484     info
485   );
486   g_signal_connect(
487     G_OBJECT(tcp),
488     "notify::resolver",
489     G_CALLBACK(inf_xmpp_manager_notify_resolver_cb),
490     info
491   );
492   g_object_get(G_OBJECT(tcp), "resolver", &amp;resolver, NULL);
493   if(resolver != NULL)
494   {
495     inf_xmpp_manager_connection_info_set_resolver(info, resolver);
496     g_object_unref(resolver);
497   }
498   g_object_unref(tcp);
499   return info;
500 }
501 static void
502 inf_xmpp_manager_connection_info_free(InfXmppManagerConnectionInfo* info)
503 {
504   InfTcpConnection* tcp;
505   g_object_get(G_OBJECT(info-&gt;xmpp), "tcp-connection", &amp;tcp, NULL);
506   g_assert(tcp != NULL);
507   inf_xmpp_manager_connection_info_set_resolver(info, NULL);
508   inf_signal_handlers_disconnect_by_func(
509     tcp,
510     G_CALLBACK(inf_xmpp_manager_notify_cb),
511     info
512   );
513   inf_signal_handlers_disconnect_by_func(
514     tcp,
515     G_CALLBACK(inf_xmpp_manager_notify_resolver_cb),
516     info
517   );
518   g_object_unref(tcp);
519   g_object_unref(info-&gt;xmpp);
520   g_free(info-&gt;keys);
521   g_slice_free(InfXmppManagerConnectionInfo, info);
522 }
523 static gboolean
524 inf_xmpp_manager_dispose_destroy_func(gpointer key,
525                                       gpointer value,
526                                       gpointer data)
527 {
528   InfXmppManagerConnectionInfo* info;
529   info = (InfXmppManagerConnectionInfo*)value;
530   if(--info-&gt;n_keys == 0)
531     inf_xmpp_manager_connection_info_free(value);
532   return FALSE;
533 }
534 static void
535 inf_xmpp_manager_init(InfXmppManager* manager)
536 {
537   InfXmppManagerPrivate* priv;
538   priv = INF_XMPP_MANAGER_PRIVATE(manager);
539   priv-&gt;connections = g_tree_new_full(
540     inf_xmpp_manager_key_cmp,
541     NULL,
542     inf_xmpp_manager_key_free,
543     NULL
544   );
545 }
546 static void
547 inf_xmpp_manager_dispose(GObject* object)
548 {
549   InfXmppManager* manager;
550   InfXmppManagerPrivate* priv;
551   manager = INF_XMPP_MANAGER(object);
552   priv = INF_XMPP_MANAGER_PRIVATE(object);
553   g_tree_foreach(
554     priv-&gt;connections,
555     inf_xmpp_manager_dispose_destroy_func,
556     manager
557   );
558   g_tree_destroy(priv-&gt;connections);
559   priv-&gt;connections = NULL;
560   G_OBJECT_CLASS(inf_xmpp_manager_parent_class)-&gt;dispose(object);
561 }
562 static void
563 inf_xmpp_manager_class_init(InfXmppManagerClass* xmpp_manager_class)
564 {
565   GObjectClass* object_class;
566   object_class = G_OBJECT_CLASS(xmpp_manager_class);
567   object_class-&gt;dispose = inf_xmpp_manager_dispose;
568   xmpp_manager_class-&gt;connection_added = NULL;
569   xmpp_manager_class-&gt;connection_removed = NULL;
570   xmpp_manager_signals[CONNECTION_ADDED] = g_signal_new(
571     "connection-added",
572     G_OBJECT_CLASS_TYPE(object_class),
573     G_SIGNAL_RUN_LAST,
574     G_STRUCT_OFFSET(InfXmppManagerClass, connection_added),
575     NULL, NULL,
576     g_cclosure_marshal_VOID__OBJECT,
577     G_TYPE_NONE,
578     1,
579     INF_TYPE_XMPP_CONNECTION
580   );
581   xmpp_manager_signals[CONNECTION_REMOVED] = g_signal_new(
582     "connection-removed",
583     G_OBJECT_CLASS_TYPE(object_class),
584     G_SIGNAL_RUN_LAST,
585     G_STRUCT_OFFSET(InfXmppManagerClass, connection_removed),
586     NULL, NULL,
587     NULL,
588     G_TYPE_NONE,
589     2,
590     INF_TYPE_XMPP_CONNECTION,
591     INF_TYPE_XMPP_CONNECTION
592   );
593 }
594 InfXmppManager*
595 inf_xmpp_manager_new(void)
596 {
597   GObject* object;
598   object = g_object_new(INF_TYPE_XMPP_MANAGER, NULL);
599   return INF_XMPP_MANAGER(object);
600 }
601 InfXmppConnection*
602 inf_xmpp_manager_lookup_connection_by_address(InfXmppManager* manager,
603                                               const InfIpAddress* address,
604                                               guint port)
605 {
606   InfXmppManagerPrivate* priv;
607   InfXmppManagerKey key;
608   InfXmppManagerConnectionInfo* info;
609   g_return_val_if_fail(INF_IS_XMPP_MANAGER(manager), NULL);
610   g_return_val_if_fail(address != NULL, NULL);
611   priv = INF_XMPP_MANAGER_PRIVATE(manager);
612   key.kind = INF_XMPP_MANAGER_KEY_ADDRESS;
613   key.shared.address.address = (InfIpAddress*)address;
614   key.shared.address.port = port;
615   info = g_tree_lookup(priv-&gt;connections, &amp;key);
616   if(info == NULL) return NULL;
617   return info-&gt;xmpp;
618 }
619 InfXmppConnection*
620 inf_xmpp_manager_lookup_connection_by_hostname(InfXmppManager* manager,
621                                                const gchar* hostname,
622                                                const gchar* service,
623                                                const gchar* srv)
624 {
625   InfXmppManagerPrivate* priv;
626   InfXmppManagerKey key;
627   InfXmppManagerConnectionInfo* info;
628   g_return_val_if_fail(INF_IS_XMPP_MANAGER(manager), NULL);
629   g_return_val_if_fail(hostname != NULL, NULL);
630   priv = INF_XMPP_MANAGER_PRIVATE(manager);
631   key.kind = INF_XMPP_MANAGER_KEY_HOSTNAME;
632   key.shared.hostname.hostname = (gchar*)hostname;
633   key.shared.hostname.service = (gchar*)service;
634   key.shared.hostname.srv = (gchar*)srv;
635   info = g_tree_lookup(priv-&gt;connections, &amp;key);
636   if(info == NULL) return NULL;
637   return info-&gt;xmpp;
638 }
639 gboolean
640 inf_xmpp_manager_contains_connection(InfXmppManager* manager,
641                                      InfXmppConnection* connection)
642 {
643   InfXmppManagerConnectionInfo* info;
644   g_return_val_if_fail(INF_IS_XMPP_MANAGER(manager), FALSE);
645   g_return_val_if_fail(INF_IS_XMPP_CONNECTION(connection), FALSE);
646   info = inf_xmpp_manager_lookup_connection(manager, connection);
647   if(info == NULL) return FALSE;
648   return TRUE;
649 }
650 void
651 inf_xmpp_manager_add_connection(InfXmppManager* manager,
652                                 InfXmppConnection* connection)
653 {
654   InfXmppManagerConnectionInfo* info;
655   gboolean was_added;
656   g_return_if_fail(INF_IS_XMPP_MANAGER(manager));
657   g_return_if_fail(INF_IS_XMPP_CONNECTION(connection));
658   info = inf_xmpp_manager_connection_info_new(manager, connection);
659   was_added = inf_xmpp_manager_update_keys(manager, info, FALSE);
660   if(was_added == FALSE)
661     inf_xmpp_manager_connection_info_free(info);
662   g_return_if_fail(was_added == TRUE);
663   g_signal_emit(
664     G_OBJECT(manager),
665     xmpp_manager_signals[CONNECTION_ADDED],
666     0,
667     connection
668   );
669 }
670 void
671 inf_xmpp_manager_remove_connection(InfXmppManager* manager,
672                                    InfXmppConnection* connection)
673 {
674   InfXmppManagerPrivate* priv;
675   InfXmppManagerConnectionInfo* info;
676   guint i;
677   g_return_if_fail(INF_IS_XMPP_MANAGER(manager));
678   g_return_if_fail(INF_IS_XMPP_CONNECTION(connection));
679   priv = INF_XMPP_MANAGER_PRIVATE(manager);
680   info = inf_xmpp_manager_lookup_connection(manager, connection);
681   g_return_if_fail(info != NULL);
682   for(i = 0; i &lt; info-&gt;n_keys; ++i)
683     g_tree_remove(priv-&gt;connections, info-&gt;keys[i]);
684   g_object_ref(connection);
685   inf_xmpp_manager_connection_info_free(info);
686   g_signal_emit(
687     G_OBJECT(manager),
688     xmpp_manager_signals[CONNECTION_REMOVED],
689     0,
690     connection,
691     NULL
692   );
693   g_object_unref(connection);
694 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-gtk-permissions-dialog.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfgtk/inf-gtk-permissions-dialog.h&gt;
2 #include &lt;libinfgtk/inf-gtk-acl-sheet-view.h&gt;
3 #include &lt;libinfinity/common/inf-request-result.h&gt;
4 #include &lt;libinfinity/common/inf-error.h&gt;
5 #include &lt;libinfinity/inf-i18n.h&gt;
6 #include &lt;libinfinity/inf-signals.h&gt;
7 #include &lt;gdk/gdkkeysyms.h&gt;
8 #include &lt;string.h&gt;
9 <a name="0"></a>enum {
10   INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID = 0,
11   INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME = 1
12 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>};
13 typedef struct _InfGtkPermissionsDialogPendingSheet
14   InfGtkPermissionsDialogPendingSheet;
15 struct _InfGtkPermissionsDialogPendingSheet {
16   InfGtkPermissionsDialog* dialog;
17   GtkTreeRowReference* row;
18   InfAclSheet sheet;
19   InfAclAccountId last_combo_changed_id;
20   InfRequest* lookup_request;
21 };
22 typedef struct _InfGtkPermissionsDialogPrivate InfGtkPermissionsDialogPrivate;
23 struct _InfGtkPermissionsDialogPrivate {
24   InfBrowser* browser;
25   InfBrowserIter browser_iter;
26   GtkListStore* account_store;
27   InfRequest* query_acl_account_list_request;
28   gboolean account_list_queried;
29   InfAclAccount* accounts;
30   guint n_accounts;
31   InfRequest* query_acl_request;
32   GSList* set_acl_requests;
33   GSList* remove_acl_account_requests;
34   GSList* lookup_acl_account_requests;
35   GSList* pending_sheets;
36   GtkMenu* popup_menu;
37   InfAclAccountId popup_account;
38   GtkWidget* status_text;
39   GtkWidget* tree_view;
40   GtkWidget* sheet_view;
41   GtkWidget* add_button;
42   GtkWidget* remove_button;
43   GtkCellRenderer* renderer;
44 };
45 enum {
46   PROP_0,
47   PROP_BROWSER,
48   PROP_BROWSER_ITER
49 };
50 #define INF_GTK_PERMISSIONS_DIALOG_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_GTK_TYPE_PERMISSIONS_DIALOG, InfGtkPermissionsDialogPrivate))
51 G_DEFINE_TYPE_WITH_CODE(InfGtkPermissionsDialog, inf_gtk_permissions_dialog, GTK_TYPE_DIALOG,
52   G_ADD_PRIVATE(InfGtkPermissionsDialog))
53 static void</b></font>
54 inf_gtk_permissions_dialog_update(InfGtkPermissionsDialog* dialog,
55                                   const GError* error);
56 static void
57 inf_gtk_permissions_dialog_update_sheet(InfGtkPermissionsDialog* dialog);
58 static gboolean
59 inf_gtk_permissions_dialog_find_account(InfGtkPermissionsDialog* dialog,
60                                         InfAclAccountId account,
61                                         GtkTreeIter* out_iter)
62 {
63   InfGtkPermissionsDialogPrivate* priv;
64   gpointer row_account_id;
65   GtkTreeModel* model;
66   GtkTreeIter iter;
67   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
68   model = GTK_TREE_MODEL(priv-&gt;account_store);
69   if(gtk_tree_model_get_iter_first(model, &amp;iter))
70   {
71     do
72     {
73       gtk_tree_model_get(
74         model,
75         &amp;iter,
76         INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
77         &amp;row_account_id,
78         -1
79       );
80       if(row_account_id == INF_ACL_ACCOUNT_ID_TO_POINTER(account))
81       {
82         if(out_iter != NULL)
83           *out_iter = iter;
84         return TRUE;
85       }
86     } while(gtk_tree_model_iter_next(model, &amp;iter));
87   }
88   return FALSE;
89 }
90 static InfGtkPermissionsDialogPendingSheet*
91 inf_gtk_permissions_dialog_find_pending_sheet(InfGtkPermissionsDialog* dialog,
92                                               GtkTreeIter* iter)
93 {
94   InfGtkPermissionsDialogPrivate* priv;
95   GtkTreeModel* model;
96   GtkTreePath* path;
97   GSList* item;
98   InfGtkPermissionsDialogPendingSheet* pending;
99   GtkTreePath* pending_path;
100   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
101   model = GTK_TREE_MODEL(priv-&gt;account_store);
102   path = gtk_tree_model_get_path(model, iter);
103   for(item = priv-&gt;pending_sheets; item != NULL; item = item-&gt;next)
104   {
105     pending = (InfGtkPermissionsDialogPendingSheet*)item-&gt;data;
106     pending_path = gtk_tree_row_reference_get_path(pending-&gt;row);
107     g_assert(pending_path != NULL);
108     if(gtk_tree_path_compare(path, pending_path) == 0)
109     {
110       gtk_tree_path_free(path);
111       gtk_tree_path_free(pending_path);
112       return pending;
113     }
114     gtk_tree_path_free(pending_path);
115   }
116   gtk_tree_path_free(path);
117   return NULL;
118 }
119 static void
120 inf_gtk_permissions_dialog_set_acl_finished_cb(InfRequest* request,
121                                                const InfRequestResult* result,
122                                                const GError* error,
123                                                gpointer user_data)
124 {
125   InfGtkPermissionsDialog* dialog;
126   InfGtkPermissionsDialogPrivate* priv;
127   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
128   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
129   if(error != NULL)
130   {
131     inf_gtk_permissions_dialog_update(dialog, error);
132     inf_gtk_permissions_dialog_update_sheet(dialog);
133   }
134   if(g_slist_find(priv-&gt;set_acl_requests, request) != NULL)
135   {
136     priv-&gt;set_acl_requests = g_slist_remove(priv-&gt;set_acl_requests, request);
137     g_object_unref(request);
138   }
139 }
140 static void
141 inf_gtk_permissions_dialog_selection_changed_cb(GtkTreeSelection* selection,
142                                                 gpointer user_data)
143 {
144   InfGtkPermissionsDialog* dialog;
145   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
146   inf_gtk_permissions_dialog_update_sheet(dialog);
147   inf_gtk_permissions_dialog_update(dialog, NULL);
148 }
149 static void
150 inf_gtk_permissions_dialog_sheet_changed_cb(InfGtkAclSheetView* sheet_view,
151                                             gpointer user_data)
152 {
153   InfGtkPermissionsDialog* dialog;
154   InfGtkPermissionsDialogPrivate* priv;
155   const InfAclSheet* sheet;
156   InfAclSheetSet sheet_set;
157   InfRequest* request;
158   GtkTreeSelection* selection;
159   gboolean has_selection;
160   GtkTreeIter iter;
161   InfGtkPermissionsDialogPendingSheet* pending;
162   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
163   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
164   sheet = inf_gtk_acl_sheet_view_get_sheet(
165     INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view)
166   );
167   if(sheet != NULL)
168   {
169     if(sheet-&gt;account != 0)
170     {
171       sheet_set.own_sheets = NULL;
172       sheet_set.sheets = sheet;
173       sheet_set.n_sheets = 1;
174       request = inf_browser_set_acl(
175         priv-&gt;browser,
176         &amp;priv-&gt;browser_iter,
177         &amp;sheet_set,
178         inf_gtk_permissions_dialog_set_acl_finished_cb,
179         dialog
180       );
181       if(request != NULL)
182       {
183         priv-&gt;set_acl_requests =
184           g_slist_prepend(priv-&gt;set_acl_requests, request);
185         g_object_ref(request);
186       }
187     }
188     else
189     {
190       selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view));
191       has_selection = gtk_tree_selection_get_selected(selection, NULL, &amp;iter);
192       g_assert(has_selection);
193       pending = inf_gtk_permissions_dialog_find_pending_sheet(dialog, &amp;iter);
194       g_assert(pending != NULL);
195       pending-&gt;sheet = *sheet;
196     }
197   }
198 }
199 static int
200 inf_gtk_permissions_dialog_account_sort_func(GtkTreeModel* model,
201                                              GtkTreeIter* a,
202                                              GtkTreeIter* b,
203                                              gpointer user_data)
204 {
205   InfGtkPermissionsDialog* dialog;
206   InfGtkPermissionsDialogPrivate* priv;
207   InfAclAccountId default_id;
208   gpointer account_a_id_ptr;
209   gpointer account_b_id_ptr;
210   InfAclAccountId account_a_id;
211   InfAclAccountId account_b_id;
212   const gchar* account_a_id_str;
213   const gchar* account_b_id_str;
214   gchar* account_a_name;
215   gchar* account_b_name;
216   int result;
217   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
218   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
219   gtk_tree_model_get(
220     model,
221     a,
222     INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID, &amp;account_a_id_ptr,
223     INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME, &amp;account_a_name,
224     -1
225   );
226   gtk_tree_model_get(
227     model,
228     b,
229     INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID, &amp;account_b_id_ptr,
230     INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME, &amp;account_b_name,
231     -1
232   );
233   account_a_id = INF_ACL_ACCOUNT_POINTER_TO_ID(account_a_id_ptr);
234   account_b_id = INF_ACL_ACCOUNT_POINTER_TO_ID(account_b_id_ptr);
235   account_a_id_str = inf_acl_account_id_to_string(account_a_id);
236   account_b_id_str = inf_acl_account_id_to_string(account_b_id);
237   default_id = inf_acl_account_id_from_string("default");
238   if(account_a_id == default_id)
239   {
240     if(account_b_id == default_id)
241       result = 0;
242     else
243       result = -1;
244   }
245   else if(account_b_id == default_id)
246   {
247     result = 1;
248   }
249   else if(account_a_name != NULL &amp;&amp; account_a_id != 0)
250   {
251     if(account_b_name != NULL &amp;&amp; account_b_id != 0)
252       result = g_utf8_collate(account_a_name, account_b_name);
253     else
254       result = -1;
255   }
256   else if(account_b_name != NULL &amp;&amp; account_b_id != 0)
257   {
258     result = 1;
259   }
260   else if(account_a_name == NULL &amp;&amp; account_a_id != 0)
261   {
262     if(account_b_name == NULL &amp;&amp; account_b_id != 0)
263       result = g_utf8_collate(account_a_id_str, account_b_id_str);
264     else
265       result = -1;
266   }
267   else if(account_b_name == NULL &amp;&amp; account_b_id != 0)
268   {
269     result = 1;
270   }
271   else if(account_a_name != NULL &amp;&amp; account_a_id == 0)
272   {
273     if(account_b_name != NULL &amp;&amp; account_b_id == 0)
274       result = g_utf8_collate(account_a_name, account_b_name);
275     else
276       result = -1;
277   }
278   else if(account_b_name != NULL &amp;&amp; account_b_id == 0)
279   {
280     result = 1;
281   }
282   else
283   {
284     g_assert_not_reached();
285     result = 0;
286   }
287   g_free(account_a_name);
288   g_free(account_b_name);
289   return result;
290 }
291 static void
292 inf_gtk_permissions_dialog_lookup_by_name_finished_cb(
293   InfRequest* request,
294   const InfRequestResult* result,
295   const GError* error,
296   gpointer user_data);
297 static void
298 inf_gtk_permissions_dialog_remove_pending_sheet(
299   InfGtkPermissionsDialog* dialog,
300   InfGtkPermissionsDialogPendingSheet* pending)
301 {
302   InfGtkPermissionsDialogPrivate* priv;
303   GtkTreePath* path;
304   GtkTreeIter iter;
305   gboolean has_iter;
306   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
307   if(pending-&gt;lookup_request != NULL)
308   {
309     inf_signal_handlers_disconnect_by_func(
310       G_OBJECT(pending-&gt;lookup_request),
311       G_CALLBACK(inf_gtk_permissions_dialog_lookup_by_name_finished_cb),
312       pending
313     );
314     g_object_unref(pending-&gt;lookup_request);
315   }
316   priv-&gt;pending_sheets = g_slist_remove(priv-&gt;pending_sheets, pending);
317   if(pending-&gt;row != NULL)
318   {
319     path = gtk_tree_row_reference_get_path(pending-&gt;row);
320     g_assert(path != NULL);
321     has_iter = gtk_tree_model_get_iter(
322       GTK_TREE_MODEL(priv-&gt;account_store),
323       &amp;iter,
324       path
325     );
326     g_assert(has_iter == TRUE);
327     gtk_list_store_remove(priv-&gt;account_store, &amp;iter);
328     gtk_tree_path_free(path);
329     gtk_tree_row_reference_free(pending-&gt;row);
330   }
331   g_slice_free(InfGtkPermissionsDialogPendingSheet, pending);
332 }
333 static void
334 inf_gtk_permissions_dialog_realize_pending_sheet(
335   InfGtkPermissionsDialog* dialog,
336   InfGtkPermissionsDialogPendingSheet* pending,
337   InfAclAccountId id,
338   const gchar* name)
339 {
340   InfGtkPermissionsDialogPrivate* priv;
341   GtkTreeIter iter;
342   GtkTreePath* path;
343   gboolean has_iter;
344   InfAclSheet pending_sheet;
345   InfAclSheetSet sheet_set;
346   InfRequest* request;
347   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
348   pending_sheet = pending-&gt;sheet;
349   pending_sheet.account = id;
350   if(inf_gtk_permissions_dialog_find_account(dialog, id, &amp;iter))
351   {
352     path = gtk_tree_model_get_path(
353       GTK_TREE_MODEL(priv-&gt;account_store),
354       &amp;iter
355     );
356     inf_signal_handlers_block_by_func(
357       G_OBJECT(gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view))),
358       G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
359       dialog
360     );
361     gtk_tree_view_set_cursor(
362       GTK_TREE_VIEW(priv-&gt;tree_view),
363       path,
364       gtk_tree_view_get_column(GTK_TREE_VIEW(priv-&gt;tree_view), 0),
365       FALSE
366     );
367     inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
368     inf_signal_handlers_unblock_by_func(
369       G_OBJECT(gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view))),
370       G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
371       dialog
372     );
373     gtk_tree_path_free(path);
374     inf_gtk_permissions_dialog_update_sheet(dialog);
375   }
376   else
377   {
378     path = gtk_tree_row_reference_get_path(pending-&gt;row);
379     g_assert(path != NULL);
380     has_iter  = gtk_tree_model_get_iter(
381       GTK_TREE_MODEL(priv-&gt;account_store),
382       &amp;iter,
383       path
384     );
385     g_assert(has_iter == TRUE);
386     gtk_list_store_set(
387       priv-&gt;account_store,
388       &amp;iter,
389       INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID, INF_ACL_ACCOUNT_ID_TO_POINTER(id),
390       INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME, name,
391       -1
392     );
393     gtk_tree_row_reference_free(pending-&gt;row);
394     pending-&gt;row = NULL;
395     inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
396     inf_signal_handlers_block_by_func(
397       G_OBJECT(priv-&gt;sheet_view),
398       G_CALLBACK(inf_gtk_permissions_dialog_sheet_changed_cb),
399       dialog
400     );
401     inf_gtk_acl_sheet_view_set_sheet(
402       INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
403       &amp;pending_sheet
404     );
405     inf_signal_handlers_unblock_by_func(
406       G_OBJECT(priv-&gt;sheet_view),
407       G_CALLBACK(inf_gtk_permissions_dialog_sheet_changed_cb),
408       dialog
409     );
410     if(!inf_acl_mask_empty(&amp;pending_sheet.mask))
411     {
412       sheet_set.own_sheets = NULL;
413       sheet_set.sheets = &amp;pending_sheet;
414       sheet_set.n_sheets = 1;
415       request = inf_browser_set_acl(
416         priv-&gt;browser,
417         &amp;priv-&gt;browser_iter,
418         &amp;sheet_set,
419         inf_gtk_permissions_dialog_set_acl_finished_cb,
420         dialog
421       );
422       if(request != NULL)
423       {
424         priv-&gt;set_acl_requests =
425           g_slist_prepend(priv-&gt;set_acl_requests, request);
426         g_object_ref(request);
427       }
428     }
429     inf_gtk_permissions_dialog_update(dialog, NULL);
430   }
431 }
432 static void
433 inf_gtk_permissions_dialog_lookup_by_name_finished_cb(
434   InfRequest* request,
435   const InfRequestResult* result,
436   const GError* error,
437   gpointer user_data)
438 {
439   InfGtkPermissionsDialogPendingSheet* pending;
440   InfGtkPermissionsDialog* dialog;
441   InfGtkPermissionsDialogPrivate* priv;
442   const InfAclAccount* accounts;
443   guint n_accounts;
444   pending = (InfGtkPermissionsDialogPendingSheet*)user_data;
445   dialog = pending-&gt;dialog;
446   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
447   if(pending-&gt;lookup_request != NULL)
448   {
449     g_object_unref(pending-&gt;lookup_request);
450     pending-&gt;lookup_request = NULL;
451   }
452   if(error != NULL)
453   {
454     g_warning("Failed to reverse lookup: %s", error-&gt;message);
455     inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
456   }
457   else
458   {
459     inf_request_result_get_lookup_acl_accounts(
460       result,
461       NULL,
462       &amp;accounts,
463       &amp;n_accounts
464     );
465     if(n_accounts &gt; 0)
466     {
467       if(n_accounts &gt; 1)
468       {
469         g_warning(
470           "Multiple accounts with the same name \"%s\"",
471           accounts[0].name
472         );
473       }
474       inf_gtk_permissions_dialog_realize_pending_sheet(
475         dialog,
476         pending,
477         accounts[0].id,
478         accounts[0].name
479       );
480     }
481     else
482     {
483       inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
484     }
485   }
486 }
487 static void
488 inf_gtk_permissions_dialog_lookup_acl_accounts_finished_cb(
489   InfRequest* request,
490   const InfRequestResult* result,
491   const GError* error,
492   gpointer user_data);
493 static void
494 inf_gtk_permissions_dialog_remove_lookup_acl_accounts_request(
495   InfGtkPermissionsDialog* dialog,
496   InfRequest* request)
497 {
498   InfGtkPermissionsDialogPrivate* priv;
499   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
500   inf_signal_handlers_disconnect_by_func(
501     request,
502     G_CALLBACK(inf_gtk_permissions_dialog_lookup_acl_accounts_finished_cb),
503     dialog
504   );
505   if(g_slist_find(priv-&gt;lookup_acl_account_requests, request) != NULL)
506   {
507     priv-&gt;lookup_acl_account_requests =
508       g_slist_remove(priv-&gt;lookup_acl_account_requests, request);
509     g_object_unref(request);
510   }
511 }
512 static void
513 inf_gtk_permissions_dialog_lookup_acl_accounts_finished_cb(
514   InfRequest* request,
515   const InfRequestResult* result,
516   const GError* error,
517   gpointer user_data)
518 {
519   InfGtkPermissionsDialog* dialog;
520   InfGtkPermissionsDialogPrivate* priv;
521   const InfAclAccount* accounts;
522   guint n_accounts;
523   guint i;
524   GtkTreeIter iter;
525   InfAclAccountId account_id;
526   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
527   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
528   if(error != NULL)
529   {
530     g_warning("Failed to look up accounts: %s\n", error-&gt;message);
531   }
532   else
533   {
534     inf_request_result_get_lookup_acl_accounts(
535       result,
536       NULL,
537       &amp;accounts,
538       &amp;n_accounts
539     );
540     for(i = 0; i &lt; n_accounts; ++i)
541     {
542       if(accounts[i].name != NULL)
543       {
544         account_id = accounts[i].id;
545         if(inf_gtk_permissions_dialog_find_account(dialog, account_id, &amp;iter))
546         {
547           gtk_list_store_set(
548             GTK_LIST_STORE(priv-&gt;account_store),
549             &amp;iter,
550             INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
551             accounts[i].name,
552             -1
553           );
554         }
555       }
556     }
557   }
558   inf_gtk_permissions_dialog_remove_lookup_acl_accounts_request(
559     dialog,
560     request
561   );
562 }
563 static void
564 inf_gtk_permissions_dialog_fill_account_list(InfGtkPermissionsDialog* dialog,
565                                              const InfAclAccountId* ids,
566                                              guint n_ids)
567 {
568   InfGtkPermissionsDialogPrivate* priv;
569   GtkTreeModel* model;
570   gboolean* have_accounts;
571   GtkTreeIter iter;
572   gpointer account_id_ptr;
573   InfAclAccountId account_id;
574   gboolean has_row;
575   guint i, j;
576   InfAclAccountId* lookup_ids;
577   guint n_lookup_ids;
578   guint lookup_index;
579   const gchar* new_account_name;
580   InfAclMask perms;
581   const InfAclAccount* default_account;
582   const InfAclAccount* local_account;
583   InfRequest* request;
584   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
585   model = GTK_TREE_MODEL(priv-&gt;account_store);
586   have_accounts = g_malloc(n_ids * sizeof(gboolean));
587   for(i = 0; i &lt; n_ids; ++i)
588     have_accounts[i] = FALSE;
589   n_lookup_ids = n_ids;
590   has_row = gtk_tree_model_get_iter_first(model, &amp;iter);
591   while(has_row)
592   {
593     gtk_tree_model_get(
594       model,
595       &amp;iter,
596       INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
597       &amp;account_id_ptr,
598       -1
599     );
600     account_id = INF_ACL_ACCOUNT_POINTER_TO_ID(account_id_ptr);
601     if(account_id == 0)
602     {
603       has_row = gtk_tree_model_iter_next(model, &amp;iter);
604     }
605     else
606     {
607       for(i = 0; i &lt; n_ids; ++i)
608         if(account_id == ids[i])
609           break;
610       if(i &lt; n_ids)
611       {
612         have_accounts[i] = TRUE;
613         has_row = gtk_tree_model_iter_next(model, &amp;iter);
614         g_assert(n_lookup_ids &gt; 0);
615         --n_lookup_ids;
616       }
617       else
618       {
619         inf_signal_handlers_block_by_func(
620           gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
621           G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
622           dialog
623         );
624         has_row = gtk_list_store_remove(priv-&gt;account_store, &amp;iter);
625         inf_signal_handlers_unblock_by_func(
626           gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
627           G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
628           dialog
629         );
630       }
631     }
632   }
633   if(n_lookup_ids &gt; 0)
634     lookup_ids = g_malloc(sizeof(InfAclAccountId) * n_lookup_ids);
635   lookup_index = 0;
636   default_account = inf_browser_get_acl_default_account(priv-&gt;browser);
637   local_account = inf_browser_get_acl_local_account(priv-&gt;browser);
638   for(i = 0; i &lt; n_ids; ++i)
639   {
640     if(!have_accounts[i])
641     {
642       if(ids[i] == default_account-&gt;id)
643       {
644         new_account_name = default_account-&gt;name;
645       }
646       else if(local_account != NULL &amp;&amp; ids[i] == local_account-&gt;id)
647       {
648         new_account_name = local_account-&gt;name;
649       }
650       else
651       {
652         new_account_name = NULL;
653         for(j = 0; j &lt; priv-&gt;n_accounts; ++j)
654         {
655           if(priv-&gt;accounts[j].id == ids[i])
656           {
657             new_account_name = priv-&gt;accounts[j].name;
658             break;
659           }
660         }
661       }
662       gtk_list_store_insert_with_values(
663         priv-&gt;account_store,
664         NULL,
665         -1,
666         INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
667         INF_ACL_ACCOUNT_ID_TO_POINTER(ids[i]),
668         INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
669         new_account_name,
670         -1
671       );
672       if(new_account_name == NULL &amp;&amp; ids[i] != default_account-&gt;id)
673         lookup_ids[lookup_index++] = ids[i];
674     }
675   }
676   if(lookup_index &gt; 0)
677   {
678     g_assert(lookup_index &lt;= n_lookup_ids);
679     inf_acl_mask_set1(&amp;perms, INF_ACL_CAN_QUERY_ACCOUNT_LIST);
680     inf_browser_check_acl(
681       priv-&gt;browser,
682       &amp;priv-&gt;browser_iter,
683       local_account ? local_account-&gt;id : 0,
684       &amp;perms,
685       &amp;perms
686     );
687     if(inf_acl_mask_has(&amp;perms, INF_ACL_CAN_QUERY_ACCOUNT_LIST))
688     {
689       request = inf_browser_lookup_acl_accounts(
690         priv-&gt;browser,
691         lookup_ids,
692         lookup_index,
693         inf_gtk_permissions_dialog_lookup_acl_accounts_finished_cb,
694         dialog
695       );
696       if(request != NULL)
697       {
698         g_object_ref(request);
699         priv-&gt;lookup_acl_account_requests = g_slist_prepend(
700           priv-&gt;lookup_acl_account_requests,
701           request
702         );
703       }
704     }
705   }
706   if(n_lookup_ids &gt; 0)
707     g_free(lookup_ids);
708   g_free(have_accounts);
709 }
710 static void
711 inf_gtk_permissions_dialog_update_sheet(InfGtkPermissionsDialog* dialog)
712 {
713   InfGtkPermissionsDialogPrivate* priv;
714   GtkTreeSelection* selection;
715   GtkTreeModel* model;
716   GtkTreeIter iter;
717   gpointer account_id_ptr;
718   InfAclAccountId account_id;
719   InfAclAccountId default_id;
720   const InfAclSheetSet* sheet_set;
721   const InfAclSheet* sheet;
722   InfAclSheet default_sheet;
723   InfAclMask show_mask;
724   InfAclMask neg_mask;
725   InfGtkPermissionsDialogPendingSheet* pending;
726   InfBrowserIter test_iter;
727   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
728   selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view));
729   inf_signal_handlers_block_by_func(
730     G_OBJECT(priv-&gt;sheet_view),
731     G_CALLBACK(inf_gtk_permissions_dialog_sheet_changed_cb),
732     dialog
733   );
734   if(!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter))
735   {
736     inf_gtk_acl_sheet_view_set_sheet(
737       INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
738       NULL
739     );
740     account_id = 0;
741   }
742   else
743   {
744     gtk_tree_model_get(
745       model,
746       &amp;iter,
747       INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
748       &amp;account_id_ptr,
749       -1
750     );
751     account_id = INF_ACL_ACCOUNT_POINTER_TO_ID(account_id_ptr);
752     if(account_id != 0)
753     {
754       sheet = NULL;
755       sheet_set = inf_browser_get_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter);
756       if(sheet_set != NULL)
757       {
758         sheet = inf_acl_sheet_set_find_const_sheet(sheet_set, account_id);
759       }
760     }
761     else
762     {
763       pending = inf_gtk_permissions_dialog_find_pending_sheet(dialog, &amp;iter);
764       g_assert(pending != NULL);
765       sheet = &amp;pending-&gt;sheet;
766     }
767     if(sheet != NULL)
768     {
769       inf_gtk_acl_sheet_view_set_sheet(
770         INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
771         sheet
772       );
773     }
774     else
775     {
776       default_sheet.account = account_id;
777       inf_acl_mask_clear(&amp;default_sheet.mask);
778       inf_acl_mask_clear(&amp;default_sheet.perms);
779       inf_gtk_acl_sheet_view_set_sheet(
780         INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
781         &amp;default_sheet
782       );
783     }
784   }
785   test_iter = priv-&gt;browser_iter;
786   show_mask = INF_ACL_MASK_ALL;
787   if(!inf_browser_get_parent(priv-&gt;browser, &amp;test_iter))
788   {
789     default_id = inf_acl_account_id_from_string("default");
790     if(account_id == default_id)
791     {
792       inf_gtk_acl_sheet_view_set_show_default(
793         INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
794         FALSE
795       );
796     }
797     else
798     {
799       inf_gtk_acl_sheet_view_set_show_default(
800         INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
801         TRUE
802       );
803     }
804   }
805   else
806   {
807     inf_gtk_acl_sheet_view_set_show_default(
808       INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
809       TRUE
810     );
811     inf_acl_mask_neg(&amp;INF_ACL_MASK_ROOT, &amp;neg_mask);
812     inf_acl_mask_and(&amp;show_mask, &amp;neg_mask, &amp;show_mask);
813   }
814   if(!inf_browser_is_subdirectory(priv-&gt;browser, &amp;priv-&gt;browser_iter))
815   {
816     inf_acl_mask_neg(&amp;INF_ACL_MASK_SUBDIRECTORY, &amp;neg_mask);
817     inf_acl_mask_and(&amp;show_mask, &amp;neg_mask, &amp;show_mask);
818   }
819   inf_gtk_acl_sheet_view_set_permission_mask(
820     INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
821     &amp;show_mask
822   );
823   inf_signal_handlers_unblock_by_func(
824     G_OBJECT(priv-&gt;sheet_view),
825     G_CALLBACK(inf_gtk_permissions_dialog_sheet_changed_cb),
826     dialog
827   );
828 }
829 static void
830 inf_gtk_permissions_dialog_node_removed_cb(InfBrowser* browser,
831                                            const InfBrowserIter* iter,
832                                            InfRequest* request,
833                                            gpointer user_data)
834 {
835   InfGtkPermissionsDialog* dialog;
836   InfGtkPermissionsDialogPrivate* priv;
837   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
838   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
839   if(inf_browser_is_ancestor(browser, iter, &amp;priv-&gt;browser_iter))
840     inf_gtk_permissions_dialog_set_node(dialog, NULL, NULL);
841 }
842 static void
843 inf_gtk_permissions_dialog_acl_account_added_cb(InfBrowser* browser,
844                                                 const InfAclAccount* account,
845                                                 InfRequest* request,
846                                                 gpointer user_data)
847 {
848   InfGtkPermissionsDialog* dialog;
849   InfGtkPermissionsDialogPrivate* priv;
850   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
851   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
852   if(account-&gt;id != 0 &amp;&amp; account-&gt;name != NULL &amp;&amp; priv-&gt;accounts != NULL)
853   {
854     priv-&gt;accounts = g_realloc(
855       priv-&gt;accounts,
856       (priv-&gt;n_accounts + 1) * sizeof(InfAclAccount)
857     );
858     priv-&gt;accounts[priv-&gt;n_accounts].id = account-&gt;id;
859     priv-&gt;accounts[priv-&gt;n_accounts].name = g_strdup(account-&gt;name);
860     ++priv-&gt;n_accounts;
861     inf_gtk_permissions_dialog_update(dialog, NULL);
862   }
863 }
864 static void
865 inf_gtk_permissions_dialog_acl_account_removed_cb(InfBrowser* browser,
866                                                   const InfAclAccount* account,
867                                                   InfRequest* request,
868                                                   gpointer user_data)
869 {
870   InfGtkPermissionsDialog* dialog;
871   InfGtkPermissionsDialogPrivate* priv;
872   gboolean have_account;
873   GtkTreeIter iter;
874   guint i;
875   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
876   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
877   g_assert(account-&gt;id != 0);
878   if(priv-&gt;popup_menu != NULL &amp;&amp; account-&gt;id == priv-&gt;popup_account)
879     gtk_menu_popdown(priv-&gt;popup_menu);
880   g_assert(priv-&gt;popup_menu == NULL);
881   g_assert(priv-&gt;popup_account == 0);
882   have_account =
883     inf_gtk_permissions_dialog_find_account(dialog, account-&gt;id, &amp;iter);
884   if(have_account == TRUE)
885   {
886     inf_signal_handlers_block_by_func(
887       gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
888       G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
889       dialog
890     );
891     gtk_list_store_remove(priv-&gt;account_store, &amp;iter);
892     inf_signal_handlers_unblock_by_func(
893       gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
894       G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
895       dialog
896     );
897     inf_gtk_permissions_dialog_update_sheet(dialog);
898   }
899   if(priv-&gt;accounts != NULL)
900   {
901     for(i = 0; i &lt; priv-&gt;n_accounts; ++i)
902     {
903       if(priv-&gt;accounts[i].id == account-&gt;id)
904       {
905         priv-&gt;accounts[i] = priv-&gt;accounts[priv-&gt;n_accounts - 1];
906         --priv-&gt;n_accounts;
907         priv-&gt;accounts = g_realloc(
908           priv-&gt;accounts,
909           sizeof(InfAclAccount) * priv-&gt;n_accounts
910         );
911         break;
912       }
913     }
914   }
915   inf_gtk_permissions_dialog_update(dialog, NULL);
916 }
917 static void
918 inf_gtk_permissions_dialog_acl_changed_cb(InfBrowser* browser,
919                                           const InfBrowserIter* iter,
920                                           const InfAclSheetSet* sheet_set,
921                                           InfRequest* request,
922                                           gpointer user_data)
923 {
924   InfGtkPermissionsDialog* dialog;
925   InfGtkPermissionsDialogPrivate* priv;
926   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
927   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
928   if(iter-&gt;node == priv-&gt;browser_iter.node)
929     inf_gtk_permissions_dialog_update_sheet(dialog);
930   if(inf_browser_is_ancestor(browser, iter, &amp;priv-&gt;browser_iter))
931     inf_gtk_permissions_dialog_update(dialog, NULL);
932 }
933 static void
934 inf_gtk_permissions_dialog_renderer_editing_started_cb(GtkCellRenderer* r,
935                                                        GtkCellEditable* edit,
936                                                        const gchar* path,
937                                                        gpointer user_data)
938 {
939   g_object_set_data_full(
940     G_OBJECT(r),
941     "inf-gtk-permissions-dialog-path",
942     g_strdup(path),
943     g_free
944   );
945 }
946 static void
947 inf_gtk_permissions_dialog_renderer_editing_canceled_cb(GtkCellRenderer* r,
948                                                         gpointer user_data)
949 {
950   InfGtkPermissionsDialog* dialog;
951   InfGtkPermissionsDialogPrivate* priv;
952   gchar* path_str;
953   GtkTreePath* path;
954   GtkTreeIter iter;
955   gboolean has_selected;
956   InfGtkPermissionsDialogPendingSheet* pending;
957   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
958   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
959   g_object_set(
960     G_OBJECT(priv-&gt;renderer),
961     "model", NULL,
962     "editable", FALSE,
963     NULL
964   );
965   path_str = g_object_steal_data(
966     G_OBJECT(r),
967     "inf-gtk-permissions-dialog-path"
968   );
969   path = gtk_tree_path_new_from_string(path_str);
970   g_free(path_str);
971   has_selected = gtk_tree_model_get_iter(
972     GTK_TREE_MODEL(priv-&gt;account_store),
973     &amp;iter,
974     path
975   );
976   g_assert(has_selected == TRUE);
977   pending = inf_gtk_permissions_dialog_find_pending_sheet(dialog, &amp;iter);
978   g_assert(pending != NULL);
979   inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
980 }
981 static void
982 inf_gtk_permissions_dialog_renderer_changed_cb(GtkCellRendererCombo* combo,
983                                                const gchar* path_str,
984                                                GtkTreeIter* combo_iter,
985                                                gpointer user_data)
986 {
987   InfGtkPermissionsDialog* dialog;
988   InfGtkPermissionsDialogPrivate* priv;
989   GtkTreePath* path;
990   GtkTreeIter view_iter;
991   gboolean has_path;
992   InfGtkPermissionsDialogPendingSheet* pending;
993   GtkTreeModel* model;
994   gpointer id_ptr;
995   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
996   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
997   path = gtk_tree_path_new_from_string(path_str);
998   has_path = gtk_tree_model_get_iter(
999     GTK_TREE_MODEL(priv-&gt;account_store),
1000     &amp;view_iter,
1001     path
1002   );
1003   g_assert(has_path);
1004   gtk_tree_path_free(path);
1005   pending = inf_gtk_permissions_dialog_find_pending_sheet(dialog, &amp;view_iter);
1006   g_assert(pending != NULL);
1007   g_object_get(G_OBJECT(combo), "model", &amp;model, NULL);
1008   g_assert(model != NULL);
1009   gtk_tree_model_get(
1010     model,
1011     combo_iter,
1012     INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
1013     &amp;id_ptr,
1014     -1
1015   );
1016   pending-&gt;last_combo_changed_id = INF_ACL_ACCOUNT_POINTER_TO_ID(id_ptr);
1017   g_object_unref(model);
1018 }
1019 static void
1020 inf_gtk_permissions_dialog_renderer_edited_cb(GtkCellRendererCombo* renderer,
1021                                               const gchar* path_str,
1022                                               const gchar* text,
1023                                               gpointer user_data)
1024 {
1025   InfGtkPermissionsDialog* dialog;
1026   InfGtkPermissionsDialogPrivate* priv;
1027   gchar* path_str_obj;
1028   GtkTreePath* path;
1029   gboolean has_path;
1030   GtkTreeIter view_iter;
1031   InfGtkPermissionsDialogPendingSheet* pending;
1032   GtkTreeModel* model;
1033   InfRequest* request;
1034   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1035   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1036   path_str_obj = g_object_steal_data(
1037     G_OBJECT(renderer),
1038     "inf-gtk-permissions-dialog-path"
1039   );
1040   g_assert(strcmp(path_str_obj, path_str) == 0);
1041   g_free(path_str_obj);
1042   path = gtk_tree_path_new_from_string(path_str);
1043   has_path = gtk_tree_model_get_iter(
1044     GTK_TREE_MODEL(priv-&gt;account_store),
1045     &amp;view_iter,
1046     path
1047   );
1048   g_assert(has_path);
1049   gtk_tree_path_free(path);
1050   pending = inf_gtk_permissions_dialog_find_pending_sheet(dialog, &amp;view_iter);
1051   g_assert(pending != NULL);
1052   g_object_get(G_OBJECT(renderer), "model", &amp;model, NULL);
1053   g_object_set(
1054     G_OBJECT(priv-&gt;renderer),
1055     "model", NULL,
1056     "editable", FALSE,
1057     NULL
1058   );
1059   g_assert(model != NULL);
1060   if(gtk_tree_model_iter_n_children(model, NULL) &gt; 0)
1061   {
1062     g_assert(pending-&gt;last_combo_changed_id != 0);
1063     inf_gtk_permissions_dialog_realize_pending_sheet(
1064       dialog,
1065       pending,
1066       pending-&gt;last_combo_changed_id,
1067       text
1068     );
1069   }
1070   else
1071   {
1072     gtk_list_store_set(
1073       priv-&gt;account_store,
1074       &amp;view_iter,
1075       INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
1076       text,
1077       -1
1078     );
1079     request = inf_browser_lookup_acl_account_by_name(
1080       priv-&gt;browser,
1081       text,
1082       inf_gtk_permissions_dialog_lookup_by_name_finished_cb,
1083       pending
1084     );
1085     if(request != NULL)
1086     {
1087       pending-&gt;lookup_request = request;
1088       g_object_ref(request);
1089     }
1090   }
1091   g_object_unref(model);
1092 }
1093 static void
1094 inf_gtk_permissions_dialog_add_clicked_cb(GtkButton* button,
1095                                           gpointer user_data)
1096 {
1097   InfGtkPermissionsDialog* dialog;
1098   InfGtkPermissionsDialogPrivate* priv;
1099   GtkTreeIter new_iter;
1100   GtkTreePath* new_path;
1101   InfGtkPermissionsDialogPendingSheet* pending;
1102   GtkListStore* store;
1103   const InfAclSheetSet* sheet_set;
1104   const InfAclSheet* sheet;
1105   guint i;
1106   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1107   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1108   gtk_cell_renderer_stop_editing(priv-&gt;renderer, TRUE);
1109   gtk_list_store_insert_with_values(
1110     priv-&gt;account_store,
1111     &amp;new_iter,
1112     -1,
1113     INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
1114     0,
1115     INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
1116     NULL,
1117     -1
1118   );
1119   new_path = gtk_tree_model_get_path(
1120     GTK_TREE_MODEL(priv-&gt;account_store),
1121     &amp;new_iter
1122   );
1123   pending = g_slice_new(InfGtkPermissionsDialogPendingSheet);
1124   pending-&gt;dialog = dialog;
1125   pending-&gt;row = gtk_tree_row_reference_new(
1126     GTK_TREE_MODEL(priv-&gt;account_store),
1127     new_path
1128   );
1129   pending-&gt;sheet.account = 0;
1130   inf_acl_mask_clear(&amp;pending-&gt;sheet.mask);
1131   inf_acl_mask_clear(&amp;pending-&gt;sheet.perms);
1132   pending-&gt;last_combo_changed_id = 0;
1133   pending-&gt;lookup_request = NULL;
1134   priv-&gt;pending_sheets = g_slist_prepend(priv-&gt;pending_sheets, pending);
1135   store = gtk_list_store_new(2, G_TYPE_POINTER, G_TYPE_STRING);
1136   g_object_set(
1137     G_OBJECT(priv-&gt;renderer),
1138     "model", store,
1139     "editable", TRUE,
1140     "text-column", INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
1141     NULL
1142   );
1143   if(priv-&gt;accounts != NULL)
1144   {
1145     g_object_set(G_OBJECT(priv-&gt;renderer), "has-entry", FALSE, NULL);
1146     sheet_set = inf_browser_get_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter);
1147     for(i = 0; i &lt; priv-&gt;n_accounts; ++i)
1148     {
1149       if(priv-&gt;accounts[i].name != NULL)
1150       {
1151         sheet = NULL;
1152         if(sheet_set != NULL)
1153         {
1154           sheet = inf_acl_sheet_set_find_const_sheet(
1155             sheet_set,
1156             priv-&gt;accounts[i].id
1157           );
1158         }
1159         if(sheet == NULL)
1160         {
1161           gtk_list_store_insert_with_values(
1162             store,
1163             NULL,
1164             -1,
1165             INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
1166             priv-&gt;accounts[i].id,
1167             INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
1168             priv-&gt;accounts[i].name,
1169             -1
1170           );
1171         }
1172       }
1173     }
1174     g_assert(gtk_tree_model_iter_n_children(GTK_TREE_MODEL(store), NULL) &gt; 0);
1175   }
1176   else
1177   {
1178     g_object_set(G_OBJECT(priv-&gt;renderer), "has-entry", TRUE, NULL);
1179   }
1180   gtk_tree_sortable_set_sort_column_id(
1181     GTK_TREE_SORTABLE(store),
1182     INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
1183     GTK_SORT_ASCENDING
1184   );
1185   gtk_tree_sortable_set_sort_func(
1186     GTK_TREE_SORTABLE(store),
1187     INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
1188     inf_gtk_permissions_dialog_account_sort_func,
1189     dialog,
1190     NULL
1191   );
1192   g_object_unref(store);
1193   gtk_tree_selection_select_path(
1194     gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
1195     new_path
1196   );
1197   gtk_tree_path_free(new_path);
1198   new_path = gtk_tree_row_reference_get_path(pending-&gt;row);
1199   gtk_tree_view_set_cursor(
1200     GTK_TREE_VIEW(priv-&gt;tree_view),
1201     new_path,
1202     gtk_tree_view_get_column(GTK_TREE_VIEW(priv-&gt;tree_view), 0),
1203     TRUE
1204   );
1205   gtk_tree_path_free(new_path);
1206 }
1207 static void
1208 inf_gtk_permissions_dialog_remove_clicked_cb(GtkButton* button,
1209                                              gpointer user_data)
1210 {
1211   InfGtkPermissionsDialog* dialog;
1212   InfGtkPermissionsDialogPrivate* priv;
1213   GtkTreeSelection* selection;
1214   GtkTreeIter selected_iter;
1215   gpointer selected_id_ptr;
1216   InfAclAccountId selected_id;
1217   InfGtkPermissionsDialogPendingSheet* pending;
1218   const InfAclSheetSet* sheet_set;
1219   InfAclSheet set_sheet;
1220   InfAclSheetSet set_sheet_set;
1221   guint i;
1222   InfRequest* request;
1223   GtkTreeIter move_iter;
1224   gboolean could_move;
1225   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1226   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1227   selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view));
1228   if(!gtk_tree_selection_get_selected(selection, NULL, &amp;selected_iter))
1229     return;
1230   gtk_tree_model_get(
1231     GTK_TREE_MODEL(priv-&gt;account_store),
1232     &amp;selected_iter,
1233     INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
1234     &amp;selected_id_ptr,
1235     -1
1236   );
1237   selected_id = INF_ACL_ACCOUNT_POINTER_TO_ID(selected_id_ptr);
1238   sheet_set = inf_browser_get_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter);
1239   if(selected_id == 0)
1240   {
1241     pending = inf_gtk_permissions_dialog_find_pending_sheet(
1242       dialog,
1243       &amp;selected_iter
1244     );
1245     g_assert(pending != NULL);
1246     inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
1247   }
1248   else if(sheet_set == NULL || sheet_set-&gt;n_sheets == 0)
1249   {
1250     gtk_list_store_remove(priv-&gt;account_store, &amp;selected_iter);
1251   }
1252   else
1253   {
1254     set_sheet.account = selected_id;
1255     inf_acl_mask_clear(&amp;set_sheet.mask);
1256     inf_acl_mask_clear(&amp;set_sheet.perms);
1257     set_sheet_set.n_sheets = 1;
1258     set_sheet_set.own_sheets = NULL;
1259     set_sheet_set.sheets = &amp;set_sheet;
1260     request = inf_browser_set_acl(
1261       priv-&gt;browser,
1262       &amp;priv-&gt;browser_iter,
1263       &amp;set_sheet_set,
1264       inf_gtk_permissions_dialog_set_acl_finished_cb,
1265       dialog
1266     );
1267     if(request != NULL)
1268     {
1269       priv-&gt;set_acl_requests =
1270         g_slist_prepend(priv-&gt;set_acl_requests, request);
1271       g_object_ref(request);
1272     }
1273     move_iter = selected_iter;
1274     could_move = gtk_tree_model_iter_next(
1275       GTK_TREE_MODEL(priv-&gt;account_store),
1276       &amp;move_iter
1277     );
1278     if(!could_move)
1279     {
1280       move_iter = selected_iter;
1281       could_move = gtk_tree_model_iter_previous(
1282         GTK_TREE_MODEL(priv-&gt;account_store),
1283         &amp;move_iter
1284       );
1285     }
1286     g_assert(could_move);
1287     gtk_tree_selection_select_iter(
1288       GTK_TREE_SELECTION(selection),
1289       &amp;move_iter
1290     );
1291   }
1292 }
1293 static void
1294 inf_gtk_permissions_dialog_remove_acl_account_finished_cb(
1295   InfRequest* request,
1296   const InfRequestResult* result,
1297   const GError* error,
1298   gpointer user_data);
1299 static void
1300 inf_gtk_permissions_dialog_remove_remove_acl_account_request(
1301   InfGtkPermissionsDialog* dialog,
1302   InfRequest* request)
1303 {
1304   InfGtkPermissionsDialogPrivate* priv;
1305   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1306   g_assert(g_slist_find(priv-&gt;remove_acl_account_requests, request) != NULL);
1307   g_signal_handlers_disconnect_by_func(
1308     request,
1309     G_CALLBACK(inf_gtk_permissions_dialog_remove_acl_account_finished_cb),
1310     dialog
1311   );
1312   priv-&gt;remove_acl_account_requests =
1313     g_slist_remove(priv-&gt;remove_acl_account_requests, request);
1314   g_object_unref(request);
1315 }
1316 static void
1317 inf_gtk_permissions_dialog_remove_acl_account_finished_cb(
1318   InfRequest* request,
1319   const InfRequestResult* result,
1320   const GError* error,
1321   gpointer user_data)
1322 {
1323   InfGtkPermissionsDialog* dialog;
1324   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1325   if(error != NULL)
1326   {
1327     g_warning("Failed to remove account: %s\n", error-&gt;message);
1328   }
1329   inf_gtk_permissions_dialog_remove_remove_acl_account_request(
1330     dialog,
1331     request
1332   );
1333 }
1334 static void
1335 inf_gtk_permissions_dialog_popup_delete_account_cb(GtkMenuItem* item,
1336                                                    gpointer user_data)
1337 {
1338   InfGtkPermissionsDialog* dialog;
1339   InfGtkPermissionsDialogPrivate* priv;
1340   InfRequest* request;
1341   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1342   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1343   g_assert(priv-&gt;popup_menu != NULL);
1344   g_assert(priv-&gt;popup_account != 0);
1345   request = inf_browser_remove_acl_account(
1346     priv-&gt;browser,
1347     priv-&gt;popup_account,
1348     inf_gtk_permissions_dialog_remove_acl_account_finished_cb,
1349     dialog
1350   );
1351   if(request != NULL)
1352   {
1353     g_object_ref(request);
1354     priv-&gt;remove_acl_account_requests = g_slist_prepend(
1355       priv-&gt;remove_acl_account_requests,
1356       request
1357     );
1358   }
1359 }
1360 static gboolean
1361 inf_gtk_permissions_dialog_populate_popup(InfGtkPermissionsDialog* dialog,
1362                                           GtkMenu* menu)
1363 {
1364   InfGtkPermissionsDialogPrivate* priv;
1365   GtkWidget* item;
1366   InfBrowserIter root;
1367   InfAclMask perms;
1368   guint n_accounts;
1369   InfAclAccountId default_id;
1370   const InfAclAccount* local_account;
1371   const InfAclAccount** accounts;
1372   gpointer account_id_ptr;
1373   InfAclAccountId account_id;
1374   GtkTreeSelection* selection;
1375   GtkTreeIter iter;
1376   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1377   g_assert(priv-&gt;popup_menu == NULL);
1378   inf_browser_get_root(priv-&gt;browser, &amp;root);
1379   inf_acl_mask_set1(&amp;perms, INF_ACL_CAN_REMOVE_ACCOUNT);
1380   local_account = inf_browser_get_acl_local_account(priv-&gt;browser);
1381   inf_browser_check_acl(
1382     priv-&gt;browser,
1383     &amp;root,
1384     local_account ? local_account-&gt;id : 0,
1385     &amp;perms,
1386     &amp;perms
1387   );
1388   if(!inf_acl_mask_has(&amp;perms, INF_ACL_CAN_REMOVE_ACCOUNT))
1389     return FALSE;
1390   selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view));
1391   if(!gtk_tree_selection_get_selected(selection, NULL, &amp;iter))
1392     return FALSE;
1393   gtk_tree_model_get(
1394     GTK_TREE_MODEL(priv-&gt;account_store),
1395     &amp;iter,
1396     INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
1397     &amp;account_id_ptr,
1398     -1
1399   );
1400   account_id = INF_ACL_ACCOUNT_POINTER_TO_ID(account_id_ptr);
1401   default_id = inf_acl_account_id_from_string("default");
1402   if(account_id == 0 || account_id == default_id)
1403     return FALSE;
1404   item = gtk_menu_item_new_with_mnemonic(_("_Delete Account"));
1405   g_signal_connect(
1406     G_OBJECT(item),
1407     "activate",
1408     G_CALLBACK(inf_gtk_permissions_dialog_popup_delete_account_cb),
1409     dialog
1410   );
1411   gtk_widget_show(item);
1412   gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);
1413   priv-&gt;popup_menu = menu;
1414   priv-&gt;popup_account = INF_ACL_ACCOUNT_POINTER_TO_ID(account_id);
1415   return TRUE;
1416 }
1417 static void
1418 inf_gtk_permissions_dialog_popup_menu_detach_func(GtkWidget* attach_widget,
1419                                                   GtkMenu* menu)
1420 {
1421 }
1422 static void
1423 inf_gtk_permissions_dialog_popup_menu_position_func(GtkMenu* menu,
1424                                                     gint* x,
1425                                                     gint* y,
1426                                                     gboolean* push_in,
1427                                                     gpointer user_data)
1428 {
1429   InfGtkPermissionsDialog* dialog;
1430   InfGtkPermissionsDialogPrivate* priv;
1431   GdkWindow* bin_window;
1432   GdkScreen* screen;
1433   GtkRequisition menu_req;
1434   GdkRectangle monitor;
1435   gint monitor_num;
1436   gint orig_x;
1437   gint orig_y;
1438   gint height;
1439   GtkTreeSelection* selection;
1440   GtkTreeModel* model;
1441   GtkTreeIter selected_iter;
1442   GtkTreePath* selected_path;
1443   GdkRectangle cell_area;
1444   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1445   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1446   bin_window = gtk_tree_view_get_bin_window(GTK_TREE_VIEW(priv-&gt;tree_view));
1447   gdk_window_get_origin(bin_window, &amp;orig_x, &amp;orig_y);
1448   screen = gtk_widget_get_screen(GTK_WIDGET(priv-&gt;tree_view));
1449   monitor_num = gdk_screen_get_monitor_at_window(screen, bin_window);
1450   if(monitor_num &lt; 0) monitor_num = 0;
1451   gtk_menu_set_monitor(menu, monitor_num);
1452   gdk_screen_get_monitor_geometry(screen, monitor_num, &amp;monitor);
1453   gtk_widget_get_preferred_size(GTK_WIDGET(menu), NULL, &amp;menu_req);
1454   height = gdk_window_get_height(bin_window);
1455   selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view));
1456   gtk_tree_selection_get_selected(selection, &amp;model, &amp;selected_iter);
1457   selected_path = gtk_tree_model_get_path(model, &amp;selected_iter);
1458   gtk_tree_view_get_cell_area(
1459     GTK_TREE_VIEW(priv-&gt;tree_view),
1460     selected_path,
1461     gtk_tree_view_get_column(GTK_TREE_VIEW(priv-&gt;tree_view), 0),
1462     &amp;cell_area
1463   );
1464   gtk_tree_path_free(selected_path);
1465   g_assert(cell_area.height &gt; 0);
1466   if(gtk_widget_get_direction(GTK_WIDGET(priv-&gt;tree_view)) ==
1467      GTK_TEXT_DIR_LTR)
1468   {
1469     *x = orig_x + cell_area.x + cell_area.width - menu_req.width;
1470   }
1471   else
1472   {
1473     *x = orig_x + cell_area.x;
1474   }
1475   *y = orig_y + cell_area.y + cell_area.height;
1476   if(*y &lt; orig_y)
1477     *y = orig_y;
1478   if(*y &gt; orig_y + height)
1479     *y = orig_y + height;
1480   if(*y + menu_req.height &gt; monitor.y + monitor.height)
1481     *y = monitor.y + monitor.height - menu_req.height;
1482   if(*y &lt; monitor.y)
1483     *y = monitor.y;
1484   *push_in = FALSE;
1485 }
1486 static void
1487 inf_gtk_permissions_dialog_popup_selection_done_cb(GtkMenu* menu,
1488                                                    gpointer user_data)
1489 {
1490   InfGtkPermissionsDialog* dialog;
1491   InfGtkPermissionsDialogPrivate* priv;
1492   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1493   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1494   g_assert(priv-&gt;popup_menu != NULL);
1495   priv-&gt;popup_menu = NULL;
1496   priv-&gt;popup_account = 0;
1497 }
1498 static gboolean
1499 inf_gtk_permissions_dialog_show_popup(InfGtkPermissionsDialog* dialog,
1500                                       guint button,                                       guint32 time)
1501 {
1502   InfGtkPermissionsDialogPrivate* priv;
1503   GtkWidget* menu;
1504   gboolean result;
1505   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1506   menu = gtk_menu_new();
1507   g_signal_connect(
1508     G_OBJECT(menu),
1509     "selection-done",
1510     G_CALLBACK(inf_gtk_permissions_dialog_popup_selection_done_cb),
1511     dialog
1512   );
1513   gtk_menu_attach_to_widget(
1514     GTK_MENU(menu),
1515     GTK_WIDGET(priv-&gt;tree_view),
1516     inf_gtk_permissions_dialog_popup_menu_detach_func
1517   );
1518   if(inf_gtk_permissions_dialog_populate_popup(dialog, GTK_MENU(menu)))
1519   {
1520     result = TRUE;
1521     if(button)
1522     {
1523       gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, button, time);
1524     }
1525     else
1526     {
1527       gtk_menu_popup(
1528         GTK_MENU(menu),
1529         NULL,
1530         NULL,
1531         inf_gtk_permissions_dialog_popup_menu_position_func,
1532         priv-&gt;tree_view,
1533         button,
1534         time
1535       );
1536       gtk_menu_shell_select_first(GTK_MENU_SHELL(menu), FALSE);
1537     }
1538   }
1539   else
1540   {
1541     result = FALSE;
1542     gtk_widget_destroy(menu);
1543   }
1544   return result;
1545 }
1546 static gboolean
1547 inf_gtk_permissions_dialog_button_press_event_cb(GtkWidget* treeview,
1548                                                  GdkEventButton* event,
1549                                                  gpointer user_data)
1550 {
1551   InfGtkPermissionsDialog* dialog;
1552   GtkTreePath* path;
1553   gboolean has_path;
1554   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1555   if(event-&gt;button == 3 &amp;&amp;
1556      event-&gt;window == gtk_tree_view_get_bin_window(GTK_TREE_VIEW(treeview)))
1557   {
1558     has_path = gtk_tree_view_get_path_at_pos(
1559       GTK_TREE_VIEW(treeview),
1560       event-&gt;x,
1561       event-&gt;y,
1562       &amp;path,
1563       NULL,
1564       NULL,
1565       NULL
1566     );
1567     if(has_path)
1568     {
1569       gtk_tree_selection_select_path(
1570         gtk_tree_view_get_selection(GTK_TREE_VIEW(treeview)),
1571         path
1572       );
1573       gtk_tree_path_free(path);
1574       return inf_gtk_permissions_dialog_show_popup(
1575         dialog,
1576         event-&gt;button,
1577         event-&gt;time
1578       );
1579     }
1580   }
1581   return FALSE;
1582 }
1583 static gboolean
1584 inf_gtk_permissions_dialog_key_press_event_cb(GtkWidget* treeview,
1585                                               GdkEventKey* event,
1586                                               gpointer user_data)
1587 {
1588   InfGtkPermissionsDialog* dialog;
1589   GtkTreeSelection* selection;
1590   GtkTreeIter iter;
1591   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1592   if(event-&gt;keyval == GDK_KEY_Menu)
1593   {
1594     selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(treeview));
1595     if(gtk_tree_selection_get_selected(selection, NULL, &amp;iter))
1596     {
1597       return inf_gtk_permissions_dialog_show_popup(dialog, 0, event-&gt;time);
1598     }
1599   }
1600   return FALSE;
1601 }
1602 static void
1603 inf_gtk_permissions_dialog_name_data_func(GtkTreeViewColumn* column,
1604                                           GtkCellRenderer* cell,
1605                                           GtkTreeModel* model,
1606                                           GtkTreeIter* iter,
1607                                           gpointer user_data)
1608 {
1609   gpointer account_id_ptr;
1610   InfAclAccountId account_id;
1611   const gchar* account_id_str;
1612   InfAclAccountId default_id;
1613   gchar* account_name;
1614   gchar* str;
1615   gtk_tree_model_get(
1616     model,
1617     iter,
1618     INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID, &amp;account_id_ptr,
1619     INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME, &amp;account_name,
1620     -1
1621   );
1622   account_id = INF_ACL_ACCOUNT_POINTER_TO_ID(account_id_ptr);
1623   account_id_str = inf_acl_account_id_to_string(account_id);
1624   if(account_name != NULL)
1625   {
1626     g_object_set(G_OBJECT(cell), "text", account_name, NULL);
1627   }
1628   else if(account_id_str != NULL)
1629   {
1630     str = g_strdup_printf("&lt;%s&gt;", account_id_str);
1631     g_object_set(G_OBJECT(cell), "text", str, NULL);
1632     g_free(str);
1633   }
1634   else
1635   {
1636     g_object_set(G_OBJECT(cell), "text", "", NULL);
1637   }
1638   default_id = inf_acl_account_id_from_string("default");
1639   if( (account_id == 0 || account_name == NULL) &amp;&amp; account_id != default_id)
1640     g_object_set(G_OBJECT(cell), "foreground", "red", NULL);
1641   else
1642     g_object_set(G_OBJECT(cell), "foreground-set", FALSE, NULL);
1643   g_free(account_name);
1644 }
1645 static void
1646 inf_gtk_permissions_dialog_query_acl_account_list_finished_cb(
1647   InfRequest* request,
1648   const InfRequestResult* res,
1649   const GError* error,
1650   gpointer user_data)
1651 {
1652   InfGtkPermissionsDialog* dialog;
1653   InfGtkPermissionsDialogPrivate* priv;
1654   const InfAclAccount* accounts;
1655   guint n_accounts;
1656   guint i;
1657   InfAclAccountId account_id;
1658   GtkTreeIter iter;
1659   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1660   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1661   priv-&gt;query_acl_account_list_request = NULL;
1662   priv-&gt;account_list_queried = TRUE;
1663   if(error != NULL)
1664   {
1665     if(error-&gt;domain != inf_directory_error_quark() ||
1666        error-&gt;code != INF_DIRECTORY_ERROR_OPERATION_UNSUPPORTED)
1667     {
1668       g_warning("Error while querying account list: %s\n", error-&gt;message);
1669     }
1670   }
1671   else
1672   {
1673     inf_request_result_get_query_acl_account_list(
1674       res,
1675       NULL,
1676       &amp;accounts,
1677       &amp;n_accounts,
1678       NULL
1679     );
1680     for(i = 0; i &lt; n_accounts; ++i)
1681     {
1682       if(accounts[i].name != NULL)
1683       {
1684         account_id = accounts[i].id;
1685         if(inf_gtk_permissions_dialog_find_account(dialog, account_id, &amp;iter))
1686         {
1687           gtk_list_store_set(
1688             GTK_LIST_STORE(priv-&gt;account_store),
1689             &amp;iter,
1690             INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
1691             accounts[i].name,
1692             -1
1693           );
1694         }
1695       }
1696     }
1697     for(i = 0; i &lt; priv-&gt;n_accounts; ++i)
1698       g_free(priv-&gt;accounts[i].name);
1699     priv-&gt;accounts = g_realloc(
1700       priv-&gt;accounts,
1701       n_accounts * sizeof(InfAclAccount)
1702     );
1703     for(i = 0; i &lt; n_accounts; ++i)
1704     {
1705       priv-&gt;accounts[i].id = accounts[i].id;
1706       priv-&gt;accounts[i].name = g_strdup(accounts[i].name);
1707     }
1708     priv-&gt;n_accounts = n_accounts;
1709   }
1710 }
1711 static void
1712 inf_gtk_permissions_dialog_query_acl_finished_cb(InfRequest* request,
1713                                                  const InfRequestResult* res,
1714                                                  const GError* error,
1715                                                  gpointer user_data)
1716 {
1717   InfGtkPermissionsDialog* dialog;
1718   InfGtkPermissionsDialogPrivate* priv;
1719   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1720   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1721   priv-&gt;query_acl_request = NULL;
1722   inf_gtk_permissions_dialog_update(dialog, error);
1723 }
1724 static void
1725 inf_gtk_permissions_dialog_update(InfGtkPermissionsDialog* dialog,
1726                                   const GError* error)
1727 {
1728   InfGtkPermissionsDialogPrivate* priv;
1729   gchar* path;
1730   gchar* title;
1731   InfAclMask perms;
1732   GArray* accounts;
1733   const InfAclAccount* local_account;
1734   const InfAclSheetSet* sheet_set;
1735   gboolean has_default;
1736   InfAclAccountId default_id;
1737   guint i;
1738   GtkTreeSelection* selection;
1739   GtkTreeIter selected_iter;
1740   gpointer selected_id_ptr;
1741   GtkTreePath* selected_path;
1742   InfAclAccountId selected_id;
1743   gboolean has_selected;
1744   GSList* item;
1745   InfGtkPermissionsDialogPendingSheet* pending;
1746   GtkTreePath* pending_path;
1747   const gchar* query_acl_str;
1748   const gchar* set_acl_str;
1749   gchar* error_str;
1750   gchar* str;
1751   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1752   if(priv-&gt;browser == NULL)
1753   {
1754     gtk_list_store_clear(priv-&gt;account_store);
1755     gtk_label_set_text(GTK_LABEL(priv-&gt;status_text), _("No node selected"));
1756     return;
1757   }
1758   path = inf_browser_get_path(priv-&gt;browser, &amp;priv-&gt;browser_iter);
1759   title = g_strdup_printf(_("Permissions for %s"), path);
1760   gtk_window_set_title(GTK_WINDOW(dialog), title);
1761   g_free(path);
1762   g_free(title);
1763   inf_acl_mask_set1(&amp;perms, INF_ACL_CAN_QUERY_ACCOUNT_LIST);
1764   inf_acl_mask_or1(&amp;perms, INF_ACL_CAN_QUERY_ACL);
1765   inf_acl_mask_or1(&amp;perms, INF_ACL_CAN_SET_ACL);
1766   local_account = inf_browser_get_acl_local_account(priv-&gt;browser);
1767   inf_browser_check_acl(
1768     priv-&gt;browser,
1769     &amp;priv-&gt;browser_iter,
1770     local_account ? local_account-&gt;id : 0,
1771     &amp;perms,
1772     &amp;perms
1773   );
1774   if(priv-&gt;query_acl_account_list_request == NULL &amp;&amp;
1775      priv-&gt;account_list_queried == FALSE)
1776   {
1777     if(inf_acl_mask_has(&amp;perms, INF_ACL_CAN_QUERY_ACCOUNT_LIST) &amp;&amp;
1778        inf_acl_mask_has(&amp;perms, INF_ACL_CAN_SET_ACL))
1779     {
1780       priv-&gt;query_acl_account_list_request = inf_browser_get_pending_request(
1781         priv-&gt;browser,
1782         NULL,
1783         "query-acl-account-list"
1784       );
1785       if(priv-&gt;query_acl_account_list_request == NULL)
1786       {
1787         priv-&gt;query_acl_account_list_request =
1788           inf_browser_query_acl_account_list(
1789             priv-&gt;browser,
1790             inf_gtk_permissions_dialog_query_acl_account_list_finished_cb,
1791             dialog
1792           );
1793       }
1794       else
1795       {
1796         g_signal_connect(
1797           G_OBJECT(priv-&gt;query_acl_account_list_request),
1798           "finished",
1799           G_CALLBACK(
1800             inf_gtk_permissions_dialog_query_acl_account_list_finished_cb
1801           ),
1802           dialog
1803         );
1804       }
1805     }
1806   }
1807   if(!inf_browser_has_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter, 0))
1808   {
1809     if(inf_acl_mask_has(&amp;perms, INF_ACL_CAN_QUERY_ACL) &amp;&amp;
1810        priv-&gt;query_acl_request == NULL &amp;&amp; error == NULL)
1811     {
1812       priv-&gt;query_acl_request = inf_browser_get_pending_request(
1813         priv-&gt;browser,
1814         &amp;priv-&gt;browser_iter,
1815         "query-acl"
1816       );
1817       if(priv-&gt;query_acl_request == NULL)
1818       {
1819         priv-&gt;query_acl_request = inf_browser_query_acl(
1820           priv-&gt;browser,
1821           &amp;priv-&gt;browser_iter,
1822           inf_gtk_permissions_dialog_query_acl_finished_cb,
1823           dialog
1824         );
1825       }
1826       else
1827       {
1828         g_signal_connect(
1829           G_OBJECT(priv-&gt;query_acl_request),
1830           "finished",
1831           G_CALLBACK(inf_gtk_permissions_dialog_query_acl_finished_cb),
1832           dialog
1833         );
1834       }
1835     }
1836   }
1837   accounts = g_array_new(FALSE, FALSE, sizeof(InfAclAccountId));
1838   sheet_set = inf_browser_get_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter);
1839   default_id = inf_acl_account_id_from_string("default");
1840   selected_id = 0;
1841   selected_path = NULL;
1842   selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view));
1843   if(gtk_tree_selection_get_selected(selection, NULL, &amp;selected_iter))
1844   {
1845     gtk_tree_model_get(
1846       GTK_TREE_MODEL(priv-&gt;account_store),
1847       &amp;selected_iter,
1848       INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
1849       &amp;selected_id_ptr,
1850       -1
1851     );
1852     selected_id = INF_ACL_ACCOUNT_POINTER_TO_ID(selected_id_ptr);
1853     selected_path = gtk_tree_model_get_path(
1854       GTK_TREE_MODEL(priv-&gt;account_store),
1855       &amp;selected_iter
1856     );
1857   }
1858   has_default = FALSE;
1859   has_selected = FALSE;
1860   if(sheet_set != NULL)
1861   {
1862     for(i = 0; i &lt; sheet_set-&gt;n_sheets; ++i)
1863     {
1864       g_array_append_val(accounts, sheet_set-&gt;sheets[i].account);
1865       if(sheet_set-&gt;sheets[i].account == default_id)
1866         has_default = TRUE;
1867       if(sheet_set-&gt;sheets[i].account == selected_id)
1868         has_selected = TRUE;
1869     }
1870   }
1871   if(has_default == FALSE)
1872     g_array_append_val(accounts, default_id);
1873   if(selected_id != 0 &amp;&amp; selected_id != default_id &amp;&amp; has_selected == FALSE)
1874     g_array_append_val(accounts, selected_id);
1875   for(item = priv-&gt;pending_sheets; item != NULL; item = item-&gt;next)
1876   {
1877     pending = (InfGtkPermissionsDialogPendingSheet*)item-&gt;data;
1878     if(inf_acl_mask_empty(&amp;pending-&gt;sheet.mask))
1879     {
1880       pending_path = gtk_tree_row_reference_get_path(pending-&gt;row);
1881       g_assert(pending_path != NULL);
1882       if(selected_path == NULL ||
1883          gtk_tree_path_compare(pending_path, selected_path) != 0)
1884       {
1885         gtk_tree_path_free(pending_path);
1886         inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
1887         break;
1888       }
1889       gtk_tree_path_free(pending_path);
1890     }
1891   }
1892   if(selected_path != NULL)
1893     gtk_tree_path_free(selected_path);
1894   inf_gtk_permissions_dialog_fill_account_list(
1895     dialog,
1896     (InfAclAccountId*)accounts-&gt;data,
1897     accounts-&gt;len
1898   );
1899   if(!inf_acl_mask_has(&amp;perms, INF_ACL_CAN_SET_ACL) ||
1900      !inf_browser_has_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter, 0))
1901   {
1902     inf_gtk_acl_sheet_view_set_editable(
1903       INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
1904       FALSE
1905     );
1906     gtk_widget_set_sensitive(priv-&gt;add_button, FALSE);
1907     gtk_widget_set_sensitive(priv-&gt;remove_button, FALSE);
1908     set_acl_str = _("Permission is &lt;b&gt;not granted&lt;/b&gt; to modify the permission list. It is read-only.");
1909   }
1910   else
1911   {
1912     inf_gtk_acl_sheet_view_set_editable(
1913       INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
1914       TRUE
1915     );
1916     if(priv-&gt;accounts == NULL || accounts-&gt;len &lt; priv-&gt;n_accounts)
1917       gtk_widget_set_sensitive(priv-&gt;add_button, TRUE);
1918     else
1919       gtk_widget_set_sensitive(priv-&gt;add_button, FALSE);
1920     if(selected_id != default_id)
1921       gtk_widget_set_sensitive(priv-&gt;remove_button, TRUE);
1922     else
1923       gtk_widget_set_sensitive(priv-&gt;remove_button, FALSE);
1924     set_acl_str = _("Permission is &lt;b&gt;granted&lt;/b&gt; to modify the permission list.");
1925   }
1926   g_array_free(accounts, TRUE);
1927   error_str = NULL;
1928   if(error != NULL)
1929   {
1930     error_str = g_markup_printf_escaped(
1931       _("&lt;b&gt;Server Error:&lt;/b&gt; %s"),
1932       error-&gt;message
1933     );
1934     query_acl_str = error_str;
1935   }
1936   else if(priv-&gt;query_acl_request != NULL)
1937   {
1938     query_acl_str = _("Querying current permissions for "
1939                       "this node from the server...");
1940   }
1941   else if(!inf_acl_mask_has(&amp;perms, INF_ACL_CAN_QUERY_ACL) &amp;&amp;
1942           !inf_browser_has_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter, 0))
1943   {
1944     query_acl_str = _("Permission is &lt;b&gt;not granted&lt;/b&gt; to query the "
1945                       "permission list for this node from the server. "
1946                       "Showing only default permissions and permissions "
1947                       "for the own account.");
1948   }
1949   else
1950   {
1951     query_acl_str = _("Permissions are &lt;b&gt;granted&lt;/b&gt; to query the full "
1952                       "permission list from the server. "
1953                       "Showing all permissions.");
1954   }
1955   str = g_strdup_printf("%s\n\n%s", query_acl_str, set_acl_str);
1956   g_free(error_str);
1957   gtk_label_set_markup(GTK_LABEL(priv-&gt;status_text), str);
1958   g_free(str);
1959 }
1960 static void
1961 inf_gtk_permissions_dialog_register(InfGtkPermissionsDialog* dialog)
1962 {
1963   InfGtkPermissionsDialogPrivate* priv;
1964   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1965   g_assert(priv-&gt;browser != NULL);
1966   g_signal_connect(
1967     priv-&gt;browser,
1968     "node-removed",
1969     G_CALLBACK(inf_gtk_permissions_dialog_node_removed_cb),
1970     dialog
1971   );
1972   g_signal_connect(
1973     priv-&gt;browser,
1974     "acl-account-added",
1975     G_CALLBACK(inf_gtk_permissions_dialog_acl_account_added_cb),
1976     dialog
1977   );
1978   g_signal_connect(
1979     priv-&gt;browser,
1980     "acl-account-removed",
1981     G_CALLBACK(inf_gtk_permissions_dialog_acl_account_removed_cb),
1982     dialog
1983   );
1984   g_signal_connect(
1985     priv-&gt;browser,
1986     "acl-changed",
1987     G_CALLBACK(inf_gtk_permissions_dialog_acl_changed_cb),
1988     dialog
1989   );
1990 }
1991 static void
1992 inf_gtk_permissions_dialog_unregister(InfGtkPermissionsDialog* dialog)
1993 {
1994   InfGtkPermissionsDialogPrivate* priv;
1995   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1996   g_assert(priv-&gt;browser != NULL);
1997   inf_signal_handlers_disconnect_by_func(
1998     priv-&gt;browser,
1999     G_CALLBACK(inf_gtk_permissions_dialog_node_removed_cb),
2000     dialog
2001   );
2002   inf_signal_handlers_disconnect_by_func(
2003     priv-&gt;browser,
2004     G_CALLBACK(inf_gtk_permissions_dialog_acl_account_added_cb),
2005     dialog
2006   );
2007   inf_signal_handlers_disconnect_by_func(
2008     priv-&gt;browser,
2009     G_CALLBACK(inf_gtk_permissions_dialog_acl_account_removed_cb),
2010     dialog
2011   );
2012   inf_signal_handlers_disconnect_by_func(
2013     priv-&gt;browser,
2014     G_CALLBACK(inf_gtk_permissions_dialog_acl_changed_cb),
2015     dialog
2016   );
2017 }
2018 static void
2019 inf_gtk_permissions_dialog_init(InfGtkPermissionsDialog* dialog)
2020 {
2021   InfGtkPermissionsDialogPrivate* priv;
2022   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
2023   priv-&gt;query_acl_account_list_request = NULL;
2024   priv-&gt;account_list_queried = FALSE;
2025   priv-&gt;accounts = NULL;
2026   priv-&gt;n_accounts = 0;
2027   priv-&gt;query_acl_request = NULL;
2028   priv-&gt;set_acl_requests = NULL;
2029   priv-&gt;remove_acl_account_requests = NULL;
2030   priv-&gt;lookup_acl_account_requests = NULL;
2031   priv-&gt;pending_sheets = NULL;
2032   priv-&gt;popup_menu = NULL;
2033   priv-&gt;popup_account = 0;
2034   gtk_widget_init_template(GTK_WIDGET(dialog));
2035   gtk_tree_sortable_set_sort_column_id(
2036     GTK_TREE_SORTABLE(priv-&gt;account_store),
2037     INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
2038     GTK_SORT_ASCENDING
2039   );
2040   gtk_tree_sortable_set_sort_func(
2041     GTK_TREE_SORTABLE(priv-&gt;account_store),
2042     INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
2043     inf_gtk_permissions_dialog_account_sort_func,
2044     dialog,
2045     NULL
2046   );
2047   gtk_tree_view_column_set_cell_data_func(
2048     gtk_tree_view_get_column(GTK_TREE_VIEW(priv-&gt;tree_view), 0),
2049     priv-&gt;renderer,
2050     inf_gtk_permissions_dialog_name_data_func,
2051     NULL,
2052     NULL
2053   );
2054 }
2055 static void
2056 inf_gtk_permissions_dialog_constructed(GObject* object)
2057 {
2058   InfGtkPermissionsDialogPrivate* priv;
2059   G_OBJECT_CLASS(inf_gtk_permissions_dialog_parent_class)-&gt;constructed(
2060     object
2061   );
2062   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(object);
2063   inf_gtk_permissions_dialog_update(
2064     INF_GTK_PERMISSIONS_DIALOG(object),
2065     NULL
2066   );
2067 }
2068 static void
2069 inf_gtk_permissions_dialog_dispose(GObject* object)
2070 {
2071   InfGtkPermissionsDialog* dialog;
2072   InfGtkPermissionsDialogPrivate* priv;
2073   dialog = INF_GTK_PERMISSIONS_DIALOG(object);
2074   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
2075   while(priv-&gt;remove_acl_account_requests != NULL)
2076   {
2077     inf_gtk_permissions_dialog_remove_remove_acl_account_request(
2078       dialog,
2079       priv-&gt;remove_acl_account_requests-&gt;data
2080     );
2081   }
2082   while(priv-&gt;lookup_acl_account_requests != NULL)
2083   {
2084     inf_gtk_permissions_dialog_remove_lookup_acl_accounts_request(
2085       dialog,
2086       priv-&gt;lookup_acl_account_requests-&gt;data
2087     );
2088   }
2089   if(priv-&gt;browser != NULL)
2090   {
2091     inf_gtk_permissions_dialog_set_node(dialog, NULL, NULL);
2092   }
2093   g_assert(priv-&gt;set_acl_requests == NULL);
2094   g_assert(priv-&gt;pending_sheets == NULL);
2095   G_OBJECT_CLASS(inf_gtk_permissions_dialog_parent_class)-&gt;dispose(object);
2096 }
2097 static void
2098 inf_gtk_permissions_dialog_finalize(GObject* object)
2099 {
2100   InfGtkPermissionsDialog* dialog;
2101   InfGtkPermissionsDialogPrivate* priv;
2102   guint i;
2103   dialog = INF_GTK_PERMISSIONS_DIALOG(object);
2104   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
2105   for(i = 0; i &lt; priv-&gt;n_accounts; ++i)
2106     g_free(priv-&gt;accounts[i].name);
2107   g_free(priv-&gt;accounts);
2108   G_OBJECT_CLASS(inf_gtk_permissions_dialog_parent_class)-&gt;finalize(object);
2109 }
2110 static void
2111 inf_gtk_permissions_dialog_set_property(GObject* object,
2112                                         guint prop_id,
2113                                         const GValue* value,
2114                                         GParamSpec* pspec)
2115 {
2116   InfGtkPermissionsDialog* dialog;
2117   InfGtkPermissionsDialogPrivate* priv;
2118   dialog = INF_GTK_PERMISSIONS_DIALOG(object);
2119   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
2120   switch(prop_id)
2121   {
2122   case PROP_BROWSER:
2123     g_assert(priv-&gt;browser == NULL);     priv-&gt;browser = INF_BROWSER(g_value_dup_object(value));
2124     if(priv-&gt;browser != NULL)
2125       inf_gtk_permissions_dialog_register(dialog);
2126     break;
2127   case PROP_BROWSER_ITER:
2128     priv-&gt;browser_iter = *(InfBrowserIter*)g_value_get_boxed(value);
2129     break;
2130   default:
2131     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
2132     break;
2133   }
2134 }
2135 static void
2136 inf_gtk_permissions_dialog_get_property(GObject* object,
2137                                         guint prop_id,
2138                                         GValue* value,
2139                                         GParamSpec* pspec)
2140 {
2141   InfGtkPermissionsDialog* dialog;
2142 <a name="1"></a>  InfGtkPermissionsDialogPrivate* priv;
2143   dialog = INF_GTK_PERMISSIONS_DIALOG(object);
2144 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
2145   switch(prop_id)
2146   {
2147   case PROP_BROWSER:
2148     g_value_set_object(value, priv-&gt;browser);
2149     break;
2150   case PROP_BROWSER_ITER:
2151     g_value_set_boxed(value, &amp;priv-&gt;browser_iter);
2152     break;
2153   default:
2154     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
2155     break;
2156   }
2157 }
2158 static void</b></font>
2159 inf_gtk_permissions_dialog_class_init(
2160   InfGtkPermissionsDialogClass* permissions_dialog_class)
2161 {
2162   GObjectClass* object_class;
2163   object_class = G_OBJECT_CLASS(permissions_dialog_class);
2164   object_class-&gt;constructed = inf_gtk_permissions_dialog_constructed;
2165   object_class-&gt;dispose = inf_gtk_permissions_dialog_dispose;
2166   object_class-&gt;finalize = inf_gtk_permissions_dialog_finalize;
2167   object_class-&gt;set_property = inf_gtk_permissions_dialog_set_property;
2168   object_class-&gt;get_property = inf_gtk_permissions_dialog_get_property;
2169   gtk_widget_class_set_template_from_resource(
2170     GTK_WIDGET_CLASS(object_class),
2171     "/de/0x539/libinfgtk/ui/infgtkpermissionsdialog.ui"
2172   );
2173   gtk_widget_class_bind_template_child_private(
2174     GTK_WIDGET_CLASS(object_class),
2175     InfGtkPermissionsDialog,
2176     account_store
2177   );
2178   gtk_widget_class_bind_template_child_private(
2179     GTK_WIDGET_CLASS(object_class),
2180     InfGtkPermissionsDialog,
2181     status_text
2182   );
2183   gtk_widget_class_bind_template_child_private(
2184     GTK_WIDGET_CLASS(object_class),
2185     InfGtkPermissionsDialog,
2186     tree_view
2187   );
2188   gtk_widget_class_bind_template_child_private(
2189     GTK_WIDGET_CLASS(object_class),
2190     InfGtkPermissionsDialog,
2191     sheet_view
2192   );
2193   gtk_widget_class_bind_template_child_private(
2194     GTK_WIDGET_CLASS(object_class),
2195     InfGtkPermissionsDialog,
2196     add_button
2197   );
2198   gtk_widget_class_bind_template_child_private(
2199     GTK_WIDGET_CLASS(object_class),
2200     InfGtkPermissionsDialog,
2201     remove_button
2202   );
2203   gtk_widget_class_bind_template_child_private(
2204     GTK_WIDGET_CLASS(object_class),
2205     InfGtkPermissionsDialog,
2206     renderer
2207   );
2208   gtk_widget_class_bind_template_callback(
2209     GTK_WIDGET_CLASS(object_class),
2210     inf_gtk_permissions_dialog_key_press_event_cb
2211   );
2212   gtk_widget_class_bind_template_callback(
2213     GTK_WIDGET_CLASS(object_class),
2214     inf_gtk_permissions_dialog_button_press_event_cb
2215   );
2216   gtk_widget_class_bind_template_callback(
2217     GTK_WIDGET_CLASS(object_class),
2218     inf_gtk_permissions_dialog_selection_changed_cb
2219   );
2220   gtk_widget_class_bind_template_callback(
2221     GTK_WIDGET_CLASS(object_class),
2222     inf_gtk_permissions_dialog_renderer_editing_started_cb
2223   );
2224   gtk_widget_class_bind_template_callback(
2225     GTK_WIDGET_CLASS(object_class),
2226     inf_gtk_permissions_dialog_renderer_editing_canceled_cb
2227   );
2228   gtk_widget_class_bind_template_callback(
2229     GTK_WIDGET_CLASS(object_class),
2230     inf_gtk_permissions_dialog_renderer_edited_cb
2231   );
2232   gtk_widget_class_bind_template_callback(
2233     GTK_WIDGET_CLASS(object_class),
2234     inf_gtk_permissions_dialog_renderer_changed_cb
2235   );
2236   gtk_widget_class_bind_template_callback(
2237     GTK_WIDGET_CLASS(object_class),
2238     inf_gtk_permissions_dialog_add_clicked_cb
2239   );
2240   gtk_widget_class_bind_template_callback(
2241     GTK_WIDGET_CLASS(object_class),
2242     inf_gtk_permissions_dialog_remove_clicked_cb
2243   );
2244   gtk_widget_class_bind_template_callback(
2245     GTK_WIDGET_CLASS(object_class),
2246     inf_gtk_permissions_dialog_sheet_changed_cb
2247   );
2248   g_object_class_install_property(
2249     object_class,
2250     PROP_BROWSER,
2251     g_param_spec_object(
2252       "browser",
2253       "Browser",
2254       "The browser with the node for which to show the permissions",
2255       INF_TYPE_BROWSER,
2256       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
2257     )
2258   );
2259   g_object_class_install_property(
2260     object_class,
2261     PROP_BROWSER_ITER,
2262     g_param_spec_boxed(
2263       "browser-iter",
2264       "Browser Iter",
2265       "An iterator pointing to the node inside the browser for which to show "
2266       "the permissions",
2267       INF_TYPE_BROWSER_ITER,
2268       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
2269     )
2270   );
2271 }
2272 InfGtkPermissionsDialog*
2273 inf_gtk_permissions_dialog_new(GtkWindow* parent,
2274                                GtkDialogFlags dialog_flags,
2275                                InfBrowser* browser,
2276                                const InfBrowserIter* iter)
2277 {
2278   GObject* object;
2279   g_return_val_if_fail(parent == NULL || GTK_IS_WINDOW(parent), NULL);
2280   g_return_val_if_fail(browser == NULL || INF_IS_BROWSER(browser), NULL);
2281   g_return_val_if_fail(browser == NULL || iter != NULL, NULL);
2282   object = g_object_new(
2283     INF_GTK_TYPE_PERMISSIONS_DIALOG,
2284     "browser", browser,
2285     "browser-iter", iter,
2286     NULL
2287   );
2288   if(dialog_flags &amp; GTK_DIALOG_MODAL)
2289     gtk_window_set_modal(GTK_WINDOW(object), TRUE);
2290   if(dialog_flags &amp; GTK_DIALOG_DESTROY_WITH_PARENT)
2291     gtk_window_set_destroy_with_parent(GTK_WINDOW(object), TRUE);
2292   gtk_window_set_transient_for(GTK_WINDOW(object), parent);
2293   return INF_GTK_PERMISSIONS_DIALOG(object);
2294 }
2295 void
2296 inf_gtk_permissions_dialog_set_node(InfGtkPermissionsDialog* dialog,
2297                                     InfBrowser* browser,
2298                                     const InfBrowserIter* iter)
2299 {
2300   InfGtkPermissionsDialogPrivate* priv;
2301   GSList* item;
2302   guint i;
2303   g_return_if_fail(INF_GTK_IS_PERMISSIONS_DIALOG(dialog));
2304   g_return_if_fail(browser == NULL || INF_IS_BROWSER(browser));
2305   g_return_if_fail((browser == NULL) == (iter == NULL));
2306   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
2307   if(priv-&gt;popup_menu != NULL)
2308     gtk_menu_popdown(priv-&gt;popup_menu);
2309   if(priv-&gt;browser != NULL)
2310   {
2311     if(priv-&gt;query_acl_account_list_request != NULL)
2312     {
2313       inf_signal_handlers_disconnect_by_func(
2314         priv-&gt;query_acl_account_list_request,
2315         G_CALLBACK(
2316           inf_gtk_permissions_dialog_query_acl_account_list_finished_cb
2317         ),
2318         dialog
2319       );
2320       priv-&gt;query_acl_account_list_request = NULL;
2321     }
2322     if(priv-&gt;query_acl_request != NULL)
2323     {
2324       inf_signal_handlers_disconnect_by_func(
2325         priv-&gt;query_acl_request,
2326         G_CALLBACK(inf_gtk_permissions_dialog_query_acl_finished_cb),
2327         dialog
2328       );
2329       priv-&gt;query_acl_request = NULL;
2330     }
2331     for(item = priv-&gt;set_acl_requests; item != NULL; item = item-&gt;next)
2332     {
2333       inf_signal_handlers_disconnect_by_func(
2334         G_OBJECT(item-&gt;data),
2335         G_CALLBACK(inf_gtk_permissions_dialog_set_acl_finished_cb),
2336         dialog
2337       );
2338       g_object_unref(item-&gt;data);
2339     }
2340     g_slist_free(priv-&gt;set_acl_requests);
2341     priv-&gt;set_acl_requests = NULL;
2342     while(priv-&gt;pending_sheets != NULL)
2343     {
2344       inf_gtk_permissions_dialog_remove_pending_sheet(
2345         dialog,
2346         priv-&gt;pending_sheets-&gt;data
2347       );
2348     }
2349   }
2350   for(i = 0; i &lt; priv-&gt;n_accounts; ++i)
2351     g_free(priv-&gt;accounts[i].name);
2352   g_free(priv-&gt;accounts);
2353   priv-&gt;accounts = NULL;
2354   priv-&gt;n_accounts = 0;
2355   inf_signal_handlers_block_by_func(
2356     gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
2357     G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
2358     dialog
2359   );
2360   gtk_list_store_clear(priv-&gt;account_store);
2361   inf_signal_handlers_unblock_by_func(
2362     gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
2363     G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
2364     dialog
2365   );
2366   if(priv-&gt;browser != browser)
2367   {
2368     if(priv-&gt;browser != NULL)
2369     {
2370       inf_gtk_permissions_dialog_unregister(dialog);
2371       g_object_unref(priv-&gt;browser);
2372     }
2373     priv-&gt;browser = browser;
2374     if(iter != NULL)
2375       priv-&gt;browser_iter = *iter;
2376     if(priv-&gt;browser != NULL)
2377     {
2378       g_object_ref(priv-&gt;browser);
2379       inf_gtk_permissions_dialog_register(dialog);
2380     }
2381     g_object_notify(G_OBJECT(dialog), "browser");
2382     g_object_notify(G_OBJECT(dialog), "browser-iter");
2383   }
2384   inf_gtk_permissions_dialog_update(dialog, NULL);
2385 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
