<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for infc-request.c &amp; inf-user.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for infc-request.c &amp; inf-user.c
      </h3>
<h1 align="center">
        23.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>infc-request.c (34.343433%)<th>inf-user.c (18.27957%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(113-142)<td><a href="#" name="0">(204-233)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(69-99)<td><a href="#" name="1">(138-181)</a><td align="center"><font color="#e20000">16</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>infc-request.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/client/infc-request.h&gt;
2 #include &lt;libinfinity/common/inf-request.h&gt;
3 typedef struct _InfcRequestPrivate InfcRequestPrivate;
4 struct _InfcRequestPrivate {
5   gchar* type;
6   guint seq;
7   guint node_id;
8   gboolean finished;
9 };
10 enum {
11   PROP_0,
12   PROP_TYPE,
13   PROP_SEQ,
14   PROP_PROGRESS,
15   PROP_NODE_ID
16 };
17 #define INFC_REQUEST_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFC_TYPE_REQUEST, InfcRequestPrivate))
18 static void infc_request_request_iface_init(InfRequestInterface* iface);
19 G_DEFINE_TYPE_WITH_CODE(InfcRequest, infc_request, G_TYPE_OBJECT,
20   G_ADD_PRIVATE(InfcRequest)
21   G_IMPLEMENT_INTERFACE(INF_TYPE_REQUEST, infc_request_request_iface_init))
22 static void
23 infc_request_init(InfcRequest* request)
24 {
25   InfcRequestPrivate* priv;
26   priv = INFC_REQUEST_PRIVATE(request);
27   priv-&gt;type = NULL;
28 <a name="1"></a>  priv-&gt;seq = G_MAXUINT;
29   priv-&gt;node_id = G_MAXUINT;
30   priv-&gt;finished = FALSE;
31 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
32 static void
33 infc_request_finalize(GObject* object)
34 {
35   InfcRequest* request;
36   InfcRequestPrivate* priv;
37   request = INFC_REQUEST(object);
38   priv = INFC_REQUEST_PRIVATE(request);
39   g_free(priv-&gt;type);
40   G_OBJECT_CLASS(infc_request_parent_class)-&gt;finalize(object);
41 }
42 static void
43 infc_request_set_property(GObject* object,
44                           guint prop_id,
45                           const GValue* value,
46                           GParamSpec* pspec)
47 {
48   InfcRequest* request;
49   InfcRequestPrivate* priv;
50   request = INFC_REQUEST(object);
51   priv = INFC_REQUEST_PRIVATE(request);
52   switch(prop_id)
53   {
54   case PROP_TYPE:</b></font>
55     g_assert(priv-&gt;type == NULL);     priv-&gt;type = g_value_dup_string(value);
56     break;
57   case PROP_SEQ:
58     g_assert(priv-&gt;seq == G_MAXUINT);     priv-&gt;seq = g_value_get_uint(value);
59     break;
60   case PROP_NODE_ID:
61     g_assert(priv-&gt;node_id == G_MAXUINT);     priv-&gt;node_id = g_value_get_uint(value);
62 <a name="0"></a>    break;
63   case PROP_PROGRESS:
64 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  default:
65     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
66     break;
67   }
68 }
69 static void
70 infc_request_get_property(GObject* object,
71                           guint prop_id,
72                           GValue* value,
73                           GParamSpec* pspec)
74 {
75   InfcRequest* request;
76   InfcRequestPrivate* priv;
77   request = INFC_REQUEST(object);
78   priv = INFC_REQUEST_PRIVATE(request);
79   switch(prop_id)
80   {
81   case PROP_TYPE:
82     g_value_set_string(value, priv-&gt;type);
83     break;
84   case PROP_SEQ:
85     g_value_set_uint(value, priv-&gt;seq);
86     break;
87   case PROP_NODE_ID:
88     g_value_set_uint(value, priv-&gt;node_id);
89     break;
90   case PROP_PROGRESS:</b></font>
91     if(priv-&gt;finished)
92       g_value_set_double(value, 1.0);
93     else
94       g_value_set_double(value, 0.0);
95     break;
96   default:
97     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
98     break;
99   }
100 }
101 static gboolean
102 infc_request_is_local(InfRequest* request)
103 {
104   InfcRequestPrivate* priv;
105   priv = INFC_REQUEST_PRIVATE(request);
106   if(priv-&gt;seq == G_MAXUINT)
107     return FALSE;
108   return TRUE;
109 }
110 static void
111 infc_request_finished(InfRequest* request,
112                       const InfRequestResult* result,
113                       const GError* error)
114 {
115   InfcRequestPrivate* priv;
116   priv = INFC_REQUEST_PRIVATE(request);
117   priv-&gt;finished = TRUE;
118   g_object_notify(G_OBJECT(request), "progress");
119 }
120 static void
121 infc_request_class_init(InfcRequestClass* request_class)
122 {
123   GObjectClass* object_class;
124   object_class = G_OBJECT_CLASS(request_class);
125   object_class-&gt;finalize = infc_request_finalize;
126   object_class-&gt;set_property = infc_request_set_property;
127   object_class-&gt;get_property = infc_request_get_property;
128   g_object_class_install_property(
129     object_class,
130     PROP_SEQ,
131     g_param_spec_uint(
132       "seq",
133       "Seq",
134       "The sequence number of the request",
135       0,
136       G_MAXUINT,
137       0,
138       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
139     )
140   );
141   g_object_class_install_property(
142     object_class,
143     PROP_NODE_ID,
144     g_param_spec_uint(
145       "node-id",
146       "Node ID",
147       "The ID of the node affected by this request",
148       0,
149       G_MAXUINT,
150       G_MAXUINT,
151       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
152     )
153   );
154   g_object_class_override_property(object_class, PROP_TYPE, "type");
155   g_object_class_override_property(object_class, PROP_PROGRESS, "progress");
156 }
157 static void
158 infc_request_request_iface_init(InfRequestInterface* iface)
159 {
160   iface-&gt;finished = infc_request_finished;
161   iface-&gt;is_local = infc_request_is_local;
162 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-user.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/common/inf-user.h&gt;
2 #include &lt;libinfinity/common/inf-error.h&gt;
3 #include &lt;libinfinity/inf-i18n.h&gt;
4 #include &lt;libinfinity/inf-define-enum.h&gt;
5 #include &lt;string.h&gt;
6 static const GFlagsValue inf_user_flags_values[] = {
7   {
8     INF_USER_LOCAL,
9     "INF_USER_LOCAL",
10     "local"
11   }, {
12     0,
13     NULL,
14     NULL
15   }
16 };
17 static const GEnumValue inf_user_status_values[] = {
18   {
19     INF_USER_ACTIVE,
20     "INF_USER_ACTIVE",
21     "active"
22   }, {
23     INF_USER_INACTIVE,
24     "INF_USER_INACTIVE",
25     "inactive"
26   }, {
27     INF_USER_UNAVAILABLE,
28     "INF_USER_UNAVAILABLE",
29     "unavailable"
30   }, {
31     0,
32     NULL,
33     NULL
34   }
35 };
36 typedef struct _InfUserPrivate InfUserPrivate;
37 struct _InfUserPrivate {
38   guint id;
39   gchar* name;
40   InfUserStatus status;
41   InfUserFlags flags;
42   InfXmlConnection* connection;
43 };
44 enum {
45   PROP_0,
46   PROP_ID,
47   PROP_NAME,
48   PROP_STATUS,
49   PROP_FLAGS,
50   PROP_CONNECTION
51 };
52 enum {
53   SET_STATUS,
54   LAST_SIGNAL
55 };
56 #define INF_USER_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_USER, InfUserPrivate))
57 #define INF_USER_PRIVATE(obj)     ((InfUserPrivate*)(obj)-&gt;priv)
58 static guint user_signals[LAST_SIGNAL];
59 INF_DEFINE_FLAGS_TYPE(InfUserFlags, inf_user_flags, inf_user_flags_values)
60 INF_DEFINE_ENUM_TYPE(InfUserStatus, inf_user_status, inf_user_status_values)
61 G_DEFINE_TYPE_WITH_CODE(InfUser, inf_user, G_TYPE_OBJECT,
62   G_ADD_PRIVATE(InfUser))
63 static void
64 inf_user_init(InfUser* user)
65 {
66   InfUserPrivate* priv;
67   user-&gt;priv = INF_USER_GET_PRIVATE(user);
68   priv = INF_USER_PRIVATE(user);
69   priv-&gt;id = 0;
70   priv-&gt;name = NULL;
71   priv-&gt;status = INF_USER_UNAVAILABLE;
72   priv-&gt;flags = 0;
73   priv-&gt;connection = NULL;
74 }
75 static void
76 inf_user_dispose(GObject* object)
77 {
78   InfUser* user;
79   InfUserPrivate* priv;
80   user = INF_USER(object);
81   priv = INF_USER_PRIVATE(user);
82   if(priv-&gt;connection != NULL)
83   {
84     g_object_unref(priv-&gt;connection);
85     priv-&gt;connection = NULL;
86 <a name="1"></a>  }
87   G_OBJECT_CLASS(inf_user_parent_class)-&gt;dispose(object);
88 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
89 static void
90 inf_user_finalize(GObject* object)
91 {
92   InfUser* user;
93   InfUserPrivate* priv;
94   user = INF_USER(object);
95   priv = INF_USER_PRIVATE(user);
96   g_free(priv-&gt;name);
97   G_OBJECT_CLASS(inf_user_parent_class)-&gt;finalize(object);
98 }
99 static void
100 inf_user_set_property(GObject* object,
101                       guint prop_id,
102                       const GValue* value,
103                       GParamSpec* pspec)
104 {
105   InfUser* user;
106   InfUserPrivate* priv;
107   user = INF_USER(object);
108   priv = INF_USER_PRIVATE(user);
109   switch(prop_id)
110   {
111   case PROP_ID:</b></font>
112     priv-&gt;id = g_value_get_uint(value);
113     break;
114   case PROP_NAME:
115     g_free(priv-&gt;name);
116     priv-&gt;name = g_value_dup_string(value);
117     break;
118   case PROP_STATUS:
119     g_signal_emit(
120       object,
121       user_signals[SET_STATUS],
122       0,
123       g_value_get_enum(value)
124     );
125     break;
126   case PROP_FLAGS:
127     priv-&gt;flags = g_value_get_flags(value);
128     break;
129   case PROP_CONNECTION:
130 <a name="0"></a>    if(priv-&gt;connection != NULL) g_object_unref(priv-&gt;connection);
131     priv-&gt;connection = INF_XML_CONNECTION(g_value_dup_object(value));
132     break;
133 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  default:
134     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
135     break;
136   }
137 }
138 static void
139 inf_user_get_property(GObject* object,
140                       guint prop_id,
141                       GValue* value,
142                       GParamSpec* pspec)
143 {
144   InfUser* user;
145   InfUserPrivate* priv;
146   user = INF_USER(object);
147   priv = INF_USER_PRIVATE(user);
148   switch(prop_id)
149   {
150   case PROP_ID:
151     g_value_set_uint(value, priv-&gt;id);
152     break;
153   case PROP_NAME:
154     g_value_set_string(value, priv-&gt;name);
155     break;
156   case PROP_STATUS:
157     g_value_set_enum(value, priv-&gt;status);
158     break;
159   case PROP_FLAGS:</b></font>
160     g_value_set_flags(value, priv-&gt;flags);
161     break;
162   case PROP_CONNECTION:
163     g_value_set_object(value, G_OBJECT(priv-&gt;connection));
164     break;
165   default:
166     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
167     break;
168   }
169 }
170 static void
171 inf_user_set_status_handler(InfUser* user,
172                             InfUserStatus status)
173 {
174   InfUserPrivate* priv;
175   priv = INF_USER_PRIVATE(user);
176   priv-&gt;status = status;
177 }
178 static void
179 inf_user_class_init(InfUserClass* user_class)
180 {
181   GObjectClass* object_class;
182   object_class = G_OBJECT_CLASS(user_class);
183   object_class-&gt;dispose = inf_user_dispose;
184   object_class-&gt;finalize = inf_user_finalize;
185   object_class-&gt;set_property = inf_user_set_property;
186   object_class-&gt;get_property = inf_user_get_property;
187   user_class-&gt;set_status = inf_user_set_status_handler;
188   g_object_class_install_property(
189     object_class,
190     PROP_ID,
191     g_param_spec_uint(
192       "id",
193       "User ID",
194       "A Unique User ID",
195       0,
196       G_MAXUINT,
197       0,
198       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
199     )
200   );
201   g_object_class_install_property(
202     object_class,
203     PROP_NAME,
204     g_param_spec_string(
205       "name",
206       "User Name",
207       "The Name with which a user joined a session. Most servers "
208       "ensure that it is unique.",
209       "",
210       G_PARAM_READWRITE
211     )
212   );
213   g_object_class_install_property(
214     object_class,
215     PROP_STATUS,
216     g_param_spec_enum(
217       "status",
218       "User Status",
219       "Whether the user is currently available or not.",
220       INF_TYPE_USER_STATUS,
221       INF_USER_UNAVAILABLE,
222       G_PARAM_READWRITE
223     )
224   );
225   g_object_class_install_property(
226     object_class,
227     PROP_FLAGS,
228     g_param_spec_flags(
229       "flags",
230       "Flags",
231       "Flags the user currently has",
232       INF_TYPE_USER_FLAGS,
233       0,
234       G_PARAM_READWRITE
235     )
236   );
237   g_object_class_install_property(
238     object_class,
239     PROP_CONNECTION,
240     g_param_spec_object(
241       "connection",
242       "Connection",
243       "Connection to the user",
244       INF_TYPE_XML_CONNECTION,
245       G_PARAM_READWRITE
246     )
247   );
248   user_signals[SET_STATUS] = g_signal_new(
249     "set-status",
250     G_OBJECT_CLASS_TYPE(object_class),
251     G_SIGNAL_RUN_LAST,
252     G_STRUCT_OFFSET(InfUserClass, set_status),
253     NULL, NULL,
254     g_cclosure_marshal_VOID__ENUM,
255     G_TYPE_NONE,
256     1,
257     INF_TYPE_USER_STATUS
258   );
259 }
260 guint
261 inf_user_get_id(InfUser* user)
262 {
263   g_return_val_if_fail(INF_IS_USER(user), 0);
264   return INF_USER_PRIVATE(user)-&gt;id;
265 }
266 const gchar*
267 inf_user_get_name(InfUser* user)
268 {
269   g_return_val_if_fail(INF_IS_USER(user), NULL);
270   return INF_USER_PRIVATE(user)-&gt;name;
271 }
272 InfUserStatus
273 inf_user_get_status(InfUser* user)
274 {
275   g_return_val_if_fail(INF_IS_USER(user), INF_USER_UNAVAILABLE);
276   return INF_USER_PRIVATE(user)-&gt;status;
277 }
278 InfUserFlags
279 inf_user_get_flags(InfUser* user)
280 {
281   g_return_val_if_fail(INF_IS_USER(user), 0);
282   return INF_USER_PRIVATE(user)-&gt;flags;
283 }
284 InfXmlConnection*
285 inf_user_get_connection(InfUser* user)
286 {
287   g_return_val_if_fail(INF_IS_USER(user), NULL);
288   return INF_USER_PRIVATE(user)-&gt;connection;
289 }
290 const gchar*
291 inf_user_status_to_string(InfUserStatus status)
292 {
293   switch(status)
294   {
295   case INF_USER_ACTIVE: return "active";
296   case INF_USER_INACTIVE: return "inactive";
297   case INF_USER_UNAVAILABLE: return "unavailable";
298   default: g_assert_not_reached();
299   }
300 }
301 gboolean
302 inf_user_status_from_string(const gchar* string,
303                             InfUserStatus* status,
304                             GError** error)
305 {
306   InfUserStatus tmp_status;
307   if(strcmp(string, "active") == 0)
308     tmp_status = INF_USER_ACTIVE;
309   else if(strcmp(string, "inactive") == 0)
310     tmp_status = INF_USER_INACTIVE;
311   else if(strcmp(string, "unavailable") == 0)
312     tmp_status = INF_USER_UNAVAILABLE;
313   else
314   {
315     g_set_error(
316       error,
317       inf_user_error_quark(),
318       INF_USER_ERROR_INVALID_STATUS,
319       _("Invalid user status: '%s'"),
320       string
321     );
322     return FALSE;
323   }
324   if(status) *status = tmp_status;
325   return TRUE;
326 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
