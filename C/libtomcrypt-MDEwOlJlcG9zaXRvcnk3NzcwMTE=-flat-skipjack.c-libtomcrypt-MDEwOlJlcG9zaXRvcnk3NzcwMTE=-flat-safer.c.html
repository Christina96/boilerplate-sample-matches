
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 34.357005758157385%, Tokens: 21, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-skipjack.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_SKIPJACK
3  const struct ltc_cipher_descriptor skipjack_desc =
4  {
5      "skipjack",
6      17,
7      10, 10, 8, 32,
8      &skipjack_setup,
9      &skipjack_ecb_encrypt,
10      &skipjack_ecb_decrypt,
11      &skipjack_test,
12      &skipjack_done,
13      &skipjack_keysize,
14      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
15  };
16  static const unsigned char sbox[256] = {
17     0xa3,0xd7,0x09,0x83,0xf8,0x48,0xf6,0xf4,0xb3,0x21,0x15,0x78,0x99,0xb1,0xaf,0xf9,
18     0xe7,0x2d,0x4d,0x8a,0xce,0x4c,0xca,0x2e,0x52,0x95,0xd9,0x1e,0x4e,0x38,0x44,0x28,
19     0x0a,0xdf,0x02,0xa0,0x17,0xf1,0x60,0x68,0x12,0xb7,0x7a,0xc3,0xe9,0xfa,0x3d,0x53,
20     0x96,0x84,0x6b,0xba,0xf2,0x63,0x9a,0x19,0x7c,0xae,0xe5,0xf5,0xf7,0x16,0x6a,0xa2,
21     0x39,0xb6,0x7b,0x0f,0xc1,0x93,0x81,0x1b,0xee,0xb4,0x1a,0xea,0xd0,0x91,0x2f,0xb8,
22     0x55,0xb9,0xda,0x85,0x3f,0x41,0xbf,0xe0,0x5a,0x58,0x80,0x5f,0x66,0x0b,0xd8,0x90,
23     0x35,0xd5,0xc0,0xa7,0x33,0x06,0x65,0x69,0x45,0x00,0x94,0x56,0x6d,0x98,0x9b,0x76,
24     0x97,0xfc,0xb2,0xc2,0xb0,0xfe,0xdb,0x20,0xe1,0xeb,0xd6,0xe4,0xdd,0x47,0x4a,0x1d,
25     0x42,0xed,0x9e,0x6e,0x49,0x3c,0xcd,0x43,0x27,0xd2,0x07,0xd4,0xde,0xc7,0x67,0x18,
26     0x89,0xcb,0x30,0x1f,0x8d,0xc6,0x8f,0xaa,0xc8,0x74,0xdc,0xc9,0x5d,0x5c,0x31,0xa4,
27     0x70,0x88,0x61,0x2c,0x9f,0x0d,0x2b,0x87,0x50,0x82,0x54,0x64,0x26,0x7d,0x03,0x40,
28     0x34,0x4b,0x1c,0x73,0xd1,0xc4,0xfd,0x3b,0xcc,0xfb,0x7f,0xab,0xe6,0x3e,0x5b,0xa5,
29     0xad,0x04,0x23,0x9c,0x14,0x51,0x22,0xf0,0x29,0x79,0x71,0x7e,0xff,0x8c,0x0e,0xe2,
30     0x0c,0xef,0xbc,0x72,0x75,0x6f,0x37,0xa1,0xec,0xd3,0x8e,0x62,0x8b,0x86,0x10,0xe8,
31     0x08,0x77,0x11,0xbe,0x92,0x4f,0x24,0xc5,0x32,0x36,0x9d,0xcf,0xf3,0xa6,0xbb,0xac,
32     0x5e,0x6c,0xa9,0x13,0x57,0x25,0xb5,0xe3,0xbd,0xa8,0x3a,0x01,0x05,0x59,0x2a,0x46
33  };
34  static const int keystep[] =  { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };
35  static const int ikeystep[] = { 9, 0, 1, 2, 3, 4, 5, 6, 7, 8 };
36  int skipjack_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
37  {
38     int x;
39     LTC_ARGCHK(key  != NULL);
40     LTC_ARGCHK(skey != NULL);
41     if (keylen != 10) {
42        return CRYPT_INVALID_KEYSIZE;
43     }
44     if (num_rounds != 32 && num_rounds != 0) {
45        return CRYPT_INVALID_ROUNDS;
46     }
47     for (x = 0; x < 10; x++) {
48         skey->skipjack.key[x] = key[x] & 255;
49     }
50     return CRYPT_OK;
51  }
52  #define RULE_A \
53     tmp = g_func(w1, &kp, skey->skipjack.key);      \
54     w1  = tmp ^ w4 ^ x;                            \
55     w4  = w3; w3 = w2;                             \
56     w2  = tmp;
57  #define RULE_B \
58     tmp  = g_func(w1, &kp, skey->skipjack.key);     \
59     tmp1 = w4; w4  = w3;                           \
60     w3   = w1 ^ w2 ^ x;                            \
61     w1   = tmp1; w2 = tmp;
62  #define RULE_A1 \
63     tmp = w1 ^ w2 ^ x;                             \
64     w1  = ig_func(w2, &kp, skey->skipjack.key);     \
65     w2  = w3; w3 = w4; w4 = tmp;
66  #define RULE_B1 \
67     tmp = ig_func(w2, &kp, skey->skipjack.key);     \
68     w2  = tmp ^ w3 ^ x;                            \
69     w3  = w4; w4 = w1; w1 = tmp;
70  static unsigned g_func(unsigned w, int *kp, const unsigned char *key)
71  {
72     unsigned char g1,g2;
73     g1 = (w >> 8) & 255; g2 = w & 255;
74     g1 ^= sbox[g2^key[*kp]]; *kp = keystep[*kp];
75     g2 ^= sbox[g1^key[*kp]]; *kp = keystep[*kp];
76     g1 ^= sbox[g2^key[*kp]]; *kp = keystep[*kp];
77     g2 ^= sbox[g1^key[*kp]]; *kp = keystep[*kp];
78     return ((unsigned)g1<<8)|(unsigned)g2;
79  }
80  static unsigned ig_func(unsigned w, int *kp, const unsigned char *key)
81  {
82     unsigned char g1,g2;
83     g1 = (w >> 8) & 255; g2 = w & 255;
84     *kp = ikeystep[*kp]; g2 ^= sbox[g1^key[*kp]];
85     *kp = ikeystep[*kp]; g1 ^= sbox[g2^key[*kp]];
86     *kp = ikeystep[*kp]; g2 ^= sbox[g1^key[*kp]];
87     *kp = ikeystep[*kp]; g1 ^= sbox[g2^key[*kp]];
88     return ((unsigned)g1<<8)|(unsigned)g2;
89  }
90  #ifdef LTC_CLEAN_STACK
91  static int s_skipjack_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
92  #else
93  int skipjack_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
94  #endif
95  {
96     unsigned w1,w2,w3,w4,tmp,tmp1;
97     int x, kp;
98     LTC_ARGCHK(pt   != NULL);
99     LTC_ARGCHK(ct   != NULL);
100     LTC_ARGCHK(skey != NULL);
101     w1 = ((unsigned)pt[0]<<8)|pt[1];
102     w2 = ((unsigned)pt[2]<<8)|pt[3];
103     w3 = ((unsigned)pt[4]<<8)|pt[5];
104     w4 = ((unsigned)pt[6]<<8)|pt[7];
105     for (x = 1, kp = 0; x < 9; x++) {
106         RULE_A;
107     }
108     for (; x < 17; x++) {
109         RULE_B;
110     }
111     for (; x < 25; x++) {
112         RULE_A;
113     }
114     for (; x < 33; x++) {
115         RULE_B;
116     }
117     ct[0] = (w1>>8)&255; ct[1] = w1&255;
118     ct[2] = (w2>>8)&255; ct[3] = w2&255;
119     ct[4] = (w3>>8)&255; ct[5] = w3&255;
120     ct[6] = (w4>>8)&255; ct[7] = w4&255;
121     return CRYPT_OK;
122  }
123  #ifdef LTC_CLEAN_STACK
124  int skipjack_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
125  {
126     int err = s_skipjack_ecb_encrypt(pt, ct, skey);
<span onclick='openModal()' class='match'>127     burn_stack(sizeof(unsigned) * 8 + sizeof(int) * 2);
128     return err;
129  }
130  #endif
131  #ifdef LTC_CLEAN_STACK
132  static int s_skipjack_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
133  #else
134  int skipjack_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
135  #endif
136  {
137     unsigned w1,w2,w3,w4,tmp;
138     int x, kp;
</span>139     LTC_ARGCHK(pt   != NULL);
140     LTC_ARGCHK(ct   != NULL);
141     LTC_ARGCHK(skey != NULL);
142     w1 = ((unsigned)ct[0]<<8)|ct[1];
143     w2 = ((unsigned)ct[2]<<8)|ct[3];
144     w3 = ((unsigned)ct[4]<<8)|ct[5];
145     w4 = ((unsigned)ct[6]<<8)|ct[7];
146     for (x = 32, kp = 8; x > 24; x--) {
147         RULE_B1;
148     }
149     for (; x > 16; x--) {
150         RULE_A1;
151     }
152     for (; x > 8; x--) {
153         RULE_B1;
154     }
155     for (; x > 0; x--) {
156         RULE_A1;
157     }
158     pt[0] = (w1>>8)&255; pt[1] = w1&255;
159     pt[2] = (w2>>8)&255; pt[3] = w2&255;
160     pt[4] = (w3>>8)&255; pt[5] = w3&255;
161     pt[6] = (w4>>8)&255; pt[7] = w4&255;
162     return CRYPT_OK;
163  }
164  #ifdef LTC_CLEAN_STACK
165  int skipjack_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
166  {
167     int err = s_skipjack_ecb_decrypt(ct, pt, skey);
168     burn_stack(sizeof(unsigned) * 7 + sizeof(int) * 2);
169     return err;
170  }
171  #endif
172  int skipjack_test(void)
173  {
174   #ifndef LTC_TEST
175      return CRYPT_NOP;
176   #else
177     static const struct {
178         unsigned char key[10], pt[8], ct[8];
179     } tests[] = {
180     {
181         { 0x00, 0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11 },
182         { 0x33, 0x22, 0x11, 0x00, 0xdd, 0xcc, 0xbb, 0xaa },
183         { 0x25, 0x87, 0xca, 0xe2, 0x7a, 0x12, 0xd3, 0x00 }
184     }
185     };
186     unsigned char buf[2][8];
187     int x, y, err;
188     symmetric_key key;
189     for (x = 0; x < (int)(sizeof(tests) / sizeof(tests[0])); x++) {
190        if ((err = skipjack_setup(tests[x].key, 10, 0, &key)) != CRYPT_OK) {
191           return err;
192        }
193        skipjack_ecb_encrypt(tests[x].pt, buf[0], &key);
194        skipjack_ecb_decrypt(buf[0], buf[1], &key);
195        if (compare_testvector(buf[0], 8, tests[x].ct, 8, "Skipjack Encrypt", x) != 0 ||
196              compare_testvector(buf[1], 8, tests[x].pt, 8, "Skipjack Decrypt", x) != 0) {
197           return CRYPT_FAIL_TESTVECTOR;
198        }
199        for (y = 0; y < 8; y++) buf[0][y] = 0;
200        for (y = 0; y < 1000; y++) skipjack_ecb_encrypt(buf[0], buf[0], &key);
201        for (y = 0; y < 1000; y++) skipjack_ecb_decrypt(buf[0], buf[0], &key);
202        for (y = 0; y < 8; y++) if (buf[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;
203     }
204     return CRYPT_OK;
205    #endif
206  }
207  void skipjack_done(symmetric_key *skey)
208  {
209    LTC_UNUSED_PARAM(skey);
210  }
211  int skipjack_keysize(int *keysize)
212  {
213     LTC_ARGCHK(keysize != NULL);
214     if (*keysize < 10) {
215        return CRYPT_INVALID_KEYSIZE;
216     }
217     if (*keysize > 10) {
218        *keysize = 10;
219     }
220     return CRYPT_OK;
221  }
222  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-safer.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_SAFER
3  #define LTC_SAFER_TAB_C
4  #include "safer_tab.c"
5  const struct ltc_cipher_descriptor safer_k64_desc = {
6     "safer-k64",
7     8, 8, 8, 8, LTC_SAFER_K64_DEFAULT_NOF_ROUNDS,
8     &safer_k64_setup,
9     &safer_ecb_encrypt,
10     &safer_ecb_decrypt,
11     &safer_k64_test,
12     &safer_done,
13     &safer_64_keysize,
14     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
15     },
16     safer_sk64_desc = {
17     "safer-sk64",
18     9, 8, 8, 8, LTC_SAFER_SK64_DEFAULT_NOF_ROUNDS,
19     &safer_sk64_setup,
20     &safer_ecb_encrypt,
21     &safer_ecb_decrypt,
22     &safer_sk64_test,
23     &safer_done,
24     &safer_64_keysize,
25     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
26     },
27     safer_k128_desc = {
28     "safer-k128",
29     10, 16, 16, 8, LTC_SAFER_K128_DEFAULT_NOF_ROUNDS,
30     &safer_k128_setup,
31     &safer_ecb_encrypt,
32     &safer_ecb_decrypt,
33     &safer_sk128_test,
34     &safer_done,
35     &safer_128_keysize,
36     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
37     },
38     safer_sk128_desc = {
39     "safer-sk128",
40     11, 16, 16, 8, LTC_SAFER_SK128_DEFAULT_NOF_ROUNDS,
41     &safer_sk128_setup,
42     &safer_ecb_encrypt,
43     &safer_ecb_decrypt,
44     &safer_sk128_test,
45     &safer_done,
46     &safer_128_keysize,
47     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
48     };
49  #define ROL8(x, n)   ((unsigned char)((unsigned int)(x) << (n)\
50                                       |(unsigned int)((x) & 0xFF) >> (8 - (n))))
51  #define EXP(x)       safer_ebox[(x) & 0xFF]
52  #define LOG(x)       safer_lbox[(x) & 0xFF]
53  #define PHT(x, y)    { y += x; x += y; }
54  #define IPHT(x, y)   { x -= y; y -= x; }
55  #ifdef LTC_CLEAN_STACK
56  static void s_safer_expand_userkey(const unsigned char *userkey_1,
57                                   const unsigned char *userkey_2,
58                                   unsigned int nof_rounds,
59                                   int strengthened,
60                                   safer_key_t key)
61  #else
62  static void safer_expand_userkey(const unsigned char *userkey_1,
63                                   const unsigned char *userkey_2,
64                                   unsigned int nof_rounds,
65                                   int strengthened,
66                                   safer_key_t key)
67  #endif
68  {   unsigned int i, j, k;
69      unsigned char ka[LTC_SAFER_BLOCK_LEN + 1];
70      unsigned char kb[LTC_SAFER_BLOCK_LEN + 1];
71      if (LTC_SAFER_MAX_NOF_ROUNDS < nof_rounds) {
72          nof_rounds = LTC_SAFER_MAX_NOF_ROUNDS;
73      }
74      *key++ = (unsigned char)nof_rounds;
75      ka[LTC_SAFER_BLOCK_LEN] = (unsigned char)0;
76      kb[LTC_SAFER_BLOCK_LEN] = (unsigned char)0;
77      k = 0;
78      for (j = 0; j < LTC_SAFER_BLOCK_LEN; j++) {
79          ka[j] = ROL8(userkey_1[j], 5);
80          ka[LTC_SAFER_BLOCK_LEN] ^= ka[j];
81          kb[j] = *key++ = userkey_2[j];
82          kb[LTC_SAFER_BLOCK_LEN] ^= kb[j];
83      }
84      for (i = 1; i <= nof_rounds; i++) {
85          for (j = 0; j < LTC_SAFER_BLOCK_LEN + 1; j++) {
86              ka[j] = ROL8(ka[j], 6);
87              kb[j] = ROL8(kb[j], 6);
88          }
89          if (strengthened) {
90             k = 2 * i - 1;
91             while (k >= (LTC_SAFER_BLOCK_LEN + 1)) { k -= LTC_SAFER_BLOCK_LEN + 1; }
92          }
93          for (j = 0; j < LTC_SAFER_BLOCK_LEN; j++) {
94              if (strengthened) {
95                  *key++ = (ka[k]
96                                  + safer_ebox[(int)safer_ebox[(int)((18 * i + j + 1)&0xFF)]]) & 0xFF;
97                  if (++k == (LTC_SAFER_BLOCK_LEN + 1)) { k = 0; }
98              } else {
99                  *key++ = (ka[j] + safer_ebox[(int)safer_ebox[(int)((18 * i + j + 1)&0xFF)]]) & 0xFF;
100              }
101          }
102          if (strengthened) {
103             k = 2 * i;
104             while (k >= (LTC_SAFER_BLOCK_LEN + 1)) { k -= LTC_SAFER_BLOCK_LEN + 1; }
105          }
106          for (j = 0; j < LTC_SAFER_BLOCK_LEN; j++) {
107              if (strengthened) {
108                  *key++ = (kb[k]
109                                  + safer_ebox[(int)safer_ebox[(int)((18 * i + j + 10)&0xFF)]]) & 0xFF;
110                  if (++k == (LTC_SAFER_BLOCK_LEN + 1)) { k = 0; }
111              } else {
112                  *key++ = (kb[j] + safer_ebox[(int)safer_ebox[(int)((18 * i + j + 10)&0xFF)]]) & 0xFF;
113              }
114          }
115      }
116  #ifdef LTC_CLEAN_STACK
117      zeromem(ka, sizeof(ka));
118      zeromem(kb, sizeof(kb));
119  #endif
120  }
121  #ifdef LTC_CLEAN_STACK
122  static void safer_expand_userkey(const unsigned char *userkey_1,
123                                   const unsigned char *userkey_2,
124                                   unsigned int nof_rounds,
125                                   int strengthened,
126                                   safer_key_t key)
127  {
128     s_safer_expand_userkey(userkey_1, userkey_2, nof_rounds, strengthened, key);
129     burn_stack(sizeof(unsigned char) * (2 * (LTC_SAFER_BLOCK_LEN + 1)) + sizeof(unsigned int)*2);
130  }
131  #endif
132  int safer_k64_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
133  {
134     LTC_ARGCHK(key != NULL);
135     LTC_ARGCHK(skey != NULL);
136     if (num_rounds != 0 && (num_rounds < 6 || num_rounds > LTC_SAFER_MAX_NOF_ROUNDS)) {
137        return CRYPT_INVALID_ROUNDS;
138     }
139     if (keylen != 8) {
140        return CRYPT_INVALID_KEYSIZE;
141     }
142     safer_expand_userkey(key, key, (unsigned int)(num_rounds != 0 ?num_rounds:LTC_SAFER_K64_DEFAULT_NOF_ROUNDS), 0, skey->safer.key);
143     return CRYPT_OK;
144  }
145  int safer_sk64_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
146  {
147     LTC_ARGCHK(key != NULL);
148     LTC_ARGCHK(skey != NULL);
149     if (num_rounds != 0 && (num_rounds < 6 || num_rounds > LTC_SAFER_MAX_NOF_ROUNDS)) {
150        return CRYPT_INVALID_ROUNDS;
151     }
152     if (keylen != 8) {
153        return CRYPT_INVALID_KEYSIZE;
154     }
155     safer_expand_userkey(key, key, (unsigned int)(num_rounds != 0 ?num_rounds:LTC_SAFER_SK64_DEFAULT_NOF_ROUNDS), 1, skey->safer.key);
156     return CRYPT_OK;
157  }
158  int safer_k128_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
159  {
160     LTC_ARGCHK(key != NULL);
161     LTC_ARGCHK(skey != NULL);
162     if (num_rounds != 0 && (num_rounds < 6 || num_rounds > LTC_SAFER_MAX_NOF_ROUNDS)) {
163        return CRYPT_INVALID_ROUNDS;
164     }
165     if (keylen != 16) {
166        return CRYPT_INVALID_KEYSIZE;
167     }
168     safer_expand_userkey(key, key+8, (unsigned int)(num_rounds != 0 ?num_rounds:LTC_SAFER_K128_DEFAULT_NOF_ROUNDS), 0, skey->safer.key);
169     return CRYPT_OK;
170  }
171  int safer_sk128_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
172  {
173     LTC_ARGCHK(key != NULL);
174     LTC_ARGCHK(skey != NULL);
175     if (num_rounds != 0 && (num_rounds < 6 || num_rounds > LTC_SAFER_MAX_NOF_ROUNDS)) {
176        return CRYPT_INVALID_ROUNDS;
177     }
178     if (keylen != 16) {
179        return CRYPT_INVALID_KEYSIZE;
180     }
181     safer_expand_userkey(key, key+8, (unsigned int)(num_rounds != 0?num_rounds:LTC_SAFER_SK128_DEFAULT_NOF_ROUNDS), 1, skey->safer.key);
182     return CRYPT_OK;
183  }
184  #ifdef LTC_CLEAN_STACK
185  static int s_safer_ecb_encrypt(const unsigned char *pt,
186                               unsigned char *ct,
187                               const symmetric_key *skey)
188  #else
189  int safer_ecb_encrypt(const unsigned char *pt,
190                               unsigned char *ct,
191                               const symmetric_key *skey)
192  #endif
193  {   unsigned char a, b, c, d, e, f, g, h, t;
194      unsigned int round;
195      const unsigned char *key;
196      LTC_ARGCHK(pt != NULL);
197      LTC_ARGCHK(ct != NULL);
198      LTC_ARGCHK(skey != NULL);
199      key = skey->safer.key;
200      a = pt[0]; b = pt[1]; c = pt[2]; d = pt[3];
201      e = pt[4]; f = pt[5]; g = pt[6]; h = pt[7];
202      if (LTC_SAFER_MAX_NOF_ROUNDS < (round = *key)) round = LTC_SAFER_MAX_NOF_ROUNDS;
203      while(round-- > 0)
204      {
205          a ^= *++key; b += *++key; c += *++key; d ^= *++key;
206          e ^= *++key; f += *++key; g += *++key; h ^= *++key;
207          a = EXP(a) + *++key; b = LOG(b) ^ *++key;
208          c = LOG(c) ^ *++key; d = EXP(d) + *++key;
209          e = EXP(e) + *++key; f = LOG(f) ^ *++key;
210          g = LOG(g) ^ *++key; h = EXP(h) + *++key;
211          PHT(a, b); PHT(c, d); PHT(e, f); PHT(g, h);
212          PHT(a, c); PHT(e, g); PHT(b, d); PHT(f, h);
213          PHT(a, e); PHT(b, f); PHT(c, g); PHT(d, h);
214          t = b; b = e; e = c; c = t; t = d; d = f; f = g; g = t;
215      }
216      a ^= *++key; b += *++key; c += *++key; d ^= *++key;
217      e ^= *++key; f += *++key; g += *++key; h ^= *++key;
218      ct[0] = a & 0xFF; ct[1] = b & 0xFF;
219      ct[2] = c & 0xFF; ct[3] = d & 0xFF;
220      ct[4] = e & 0xFF; ct[5] = f & 0xFF;
221      ct[6] = g & 0xFF; ct[7] = h & 0xFF;
222      return CRYPT_OK;
223  }
224  #ifdef LTC_CLEAN_STACK
225  int safer_ecb_encrypt(const unsigned char *pt,
226                               unsigned char *ct,
227                               const symmetric_key *skey)
228  {
229      int err = s_safer_ecb_encrypt(pt, ct, skey);
<span onclick='openModal()' class='match'>230      burn_stack(sizeof(unsigned char) * 9 + sizeof(unsigned int) + sizeof(unsigned char *));
231      return err;
232  }
233  #endif
234  #ifdef LTC_CLEAN_STACK
235  static int s_safer_ecb_decrypt(const unsigned char *ct,
236                               unsigned char *pt,
237                               const symmetric_key *skey)
238  #else
239  int safer_ecb_decrypt(const unsigned char *ct,
240                               unsigned char *pt,
241                               const symmetric_key *skey)
242  #endif
243  {   unsigned char a, b, c, d, e, f, g, h, t;
</span>244      unsigned int round;
245      const unsigned char *key;
246      LTC_ARGCHK(ct != NULL);
247      LTC_ARGCHK(pt != NULL);
248      LTC_ARGCHK(skey != NULL);
249      key = skey->safer.key;
250      a = ct[0]; b = ct[1]; c = ct[2]; d = ct[3];
251      e = ct[4]; f = ct[5]; g = ct[6]; h = ct[7];
252      if (LTC_SAFER_MAX_NOF_ROUNDS < (round = *key)) round = LTC_SAFER_MAX_NOF_ROUNDS;
253      key += LTC_SAFER_BLOCK_LEN * (1 + 2 * round);
254      h ^= *key; g -= *--key; f -= *--key; e ^= *--key;
255      d ^= *--key; c -= *--key; b -= *--key; a ^= *--key;
256      while (round--)
257      {
258          t = e; e = b; b = c; c = t; t = f; f = d; d = g; g = t;
259          IPHT(a, e); IPHT(b, f); IPHT(c, g); IPHT(d, h);
260          IPHT(a, c); IPHT(e, g); IPHT(b, d); IPHT(f, h);
261          IPHT(a, b); IPHT(c, d); IPHT(e, f); IPHT(g, h);
262          h -= *--key; g ^= *--key; f ^= *--key; e -= *--key;
263          d -= *--key; c ^= *--key; b ^= *--key; a -= *--key;
264          h = LOG(h) ^ *--key; g = EXP(g) - *--key;
265          f = EXP(f) - *--key; e = LOG(e) ^ *--key;
266          d = LOG(d) ^ *--key; c = EXP(c) - *--key;
267          b = EXP(b) - *--key; a = LOG(a) ^ *--key;
268      }
269      pt[0] = a & 0xFF; pt[1] = b & 0xFF;
270      pt[2] = c & 0xFF; pt[3] = d & 0xFF;
271      pt[4] = e & 0xFF; pt[5] = f & 0xFF;
272      pt[6] = g & 0xFF; pt[7] = h & 0xFF;
273      return CRYPT_OK;
274  }
275  #ifdef LTC_CLEAN_STACK
276  int safer_ecb_decrypt(const unsigned char *ct,
277                               unsigned char *pt,
278                               const symmetric_key *skey)
279  {
280      int err = s_safer_ecb_decrypt(ct, pt, skey);
281      burn_stack(sizeof(unsigned char) * 9 + sizeof(unsigned int) + sizeof(unsigned char *));
282      return err;
283  }
284  #endif
285  int safer_64_keysize(int *keysize)
286  {
287     LTC_ARGCHK(keysize != NULL);
288     if (*keysize < 8) {
289        return CRYPT_INVALID_KEYSIZE;
290     }
291     *keysize = 8;
292     return CRYPT_OK;
293  }
294  int safer_128_keysize(int *keysize)
295  {
296     LTC_ARGCHK(keysize != NULL);
297     if (*keysize < 16) {
298        return CRYPT_INVALID_KEYSIZE;
299     }
300     *keysize = 16;
301     return CRYPT_OK;
302  }
303  int safer_k64_test(void)
304  {
305   #ifndef LTC_TEST
306      return CRYPT_NOP;
307   #else
308     static const unsigned char k64_pt[]  = { 1, 2, 3, 4, 5, 6, 7, 8 },
309                                k64_key[] = { 8, 7, 6, 5, 4, 3, 2, 1 },
310                                k64_ct[]  = { 200, 242, 156, 221, 135, 120, 62, 217 };
311     symmetric_key skey;
312     unsigned char buf[2][8];
313     int err;
314     if ((err = safer_k64_setup(k64_key, 8, 6, &skey)) != CRYPT_OK) {
315        return err;
316     }
317     safer_ecb_encrypt(k64_pt, buf[0], &skey);
318     safer_ecb_decrypt(buf[0], buf[1], &skey);
319     if (compare_testvector(buf[0], 8, k64_ct, 8, "Safer K64 Encrypt", 0) != 0 ||
320           compare_testvector(buf[1], 8, k64_pt, 8, "Safer K64 Decrypt", 0) != 0) {
321        return CRYPT_FAIL_TESTVECTOR;
322     }
323     return CRYPT_OK;
324   #endif
325  }
326  int safer_sk64_test(void)
327  {
328   #ifndef LTC_TEST
329      return CRYPT_NOP;
330   #else
331     static const unsigned char sk64_pt[]  = { 1, 2, 3, 4, 5, 6, 7, 8 },
332                                sk64_key[] = { 1, 2, 3, 4, 5, 6, 7, 8 },
333                                sk64_ct[]  = { 95, 206, 155, 162, 5, 132, 56, 199 };
334     symmetric_key skey;
335     unsigned char buf[2][8];
336     int err, y;
337     if ((err = safer_sk64_setup(sk64_key, 8, 6, &skey)) != CRYPT_OK) {
338        return err;
339     }
340     safer_ecb_encrypt(sk64_pt, buf[0], &skey);
341     safer_ecb_decrypt(buf[0], buf[1], &skey);
342     if (compare_testvector(buf[0], 8, sk64_ct, 8, "Safer SK64 Encrypt", 0) != 0 ||
343           compare_testvector(buf[1], 8, sk64_pt, 8, "Safer SK64 Decrypt", 0) != 0) {
344        return CRYPT_FAIL_TESTVECTOR;
345     }
346     for (y = 0; y < 8; y++) buf[0][y] = 0;
347     for (y = 0; y < 1000; y++) safer_ecb_encrypt(buf[0], buf[0], &skey);
348     for (y = 0; y < 1000; y++) safer_ecb_decrypt(buf[0], buf[0], &skey);
349     for (y = 0; y < 8; y++) if (buf[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;
350     return CRYPT_OK;
351    #endif
352  }
353  void safer_done(symmetric_key *skey)
354  {
355    LTC_UNUSED_PARAM(skey);
356  }
357  int safer_sk128_test(void)
358  {
359   #ifndef LTC_TEST
360      return CRYPT_NOP;
361   #else
362     static const unsigned char sk128_pt[]  = { 1, 2, 3, 4, 5, 6, 7, 8 },
363                                sk128_key[] = { 1, 2, 3, 4, 5, 6, 7, 8,
364                                                0, 0, 0, 0, 0, 0, 0, 0 },
365                                sk128_ct[]  = { 255, 120, 17, 228, 179, 167, 46, 113 };
366     symmetric_key skey;
367     unsigned char buf[2][8];
368     int err, y;
369     if ((err = safer_sk128_setup(sk128_key, 16, 0, &skey)) != CRYPT_OK) {
370        return err;
371     }
372     safer_ecb_encrypt(sk128_pt, buf[0], &skey);
373     safer_ecb_decrypt(buf[0], buf[1], &skey);
374     if (compare_testvector(buf[0], 8, sk128_ct, 8, "Safer SK128 Encrypt", 0) != 0 ||
375           compare_testvector(buf[1], 8, sk128_pt, 8, "Safer SK128 Decrypt", 0) != 0) {
376        return CRYPT_FAIL_TESTVECTOR;
377     }
378     for (y = 0; y < 8; y++) buf[0][y] = 0;
379     for (y = 0; y < 1000; y++) safer_ecb_encrypt(buf[0], buf[0], &skey);
380     for (y = 0; y < 1000; y++) safer_ecb_decrypt(buf[0], buf[0], &skey);
381     for (y = 0; y < 8; y++) if (buf[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;
382     return CRYPT_OK;
383   #endif
384  }
385  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-skipjack.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-safer.c</div>
                </div>
                <div class="column column_space"><pre><code>127     burn_stack(sizeof(unsigned) * 8 + sizeof(int) * 2);
128     return err;
129  }
130  #endif
131  #ifdef LTC_CLEAN_STACK
132  static int s_skipjack_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
133  #else
134  int skipjack_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
135  #endif
136  {
137     unsigned w1,w2,w3,w4,tmp;
138     int x, kp;
</pre></code></div>
                <div class="column column_space"><pre><code>230      burn_stack(sizeof(unsigned char) * 9 + sizeof(unsigned int) + sizeof(unsigned char *));
231      return err;
232  }
233  #endif
234  #ifdef LTC_CLEAN_STACK
235  static int s_safer_ecb_decrypt(const unsigned char *ct,
236                               unsigned char *pt,
237                               const symmetric_key *skey)
238  #else
239  int safer_ecb_decrypt(const unsigned char *ct,
240                               unsigned char *pt,
241                               const symmetric_key *skey)
242  #endif
243  {   unsigned char a, b, c, d, e, f, g, h, t;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    