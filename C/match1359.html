<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-chat-buffer.c &amp; inf-session.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-chat-buffer.c &amp; inf-session.c
      </h3>
<h1 align="center">
        8.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-chat-buffer.c (19.551283%)<th>inf-session.c (5.058043%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(361-388)<td><a href="#" name="0">(657-686)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(36-58)<td><a href="#" name="1">(74-96)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(69-105)<td><a href="#" name="2">(139-180)</a><td align="center"><font color="#e10000">15</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(335-356)<td><a href="#" name="3">(544-564)</a><td align="center"><font color="#b40000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-chat-buffer.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/common/inf-chat-buffer.h&gt;
2 #include &lt;libinfinity/inf-i18n.h&gt;
3 #include &lt;libinfinity/inf-define-enum.h&gt;
4 <a name="1"></a>
5 #include &lt;string.h&gt;
6 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static const GEnumValue inf_chat_buffer_message_type_values[] = {
7   {
8     INF_CHAT_BUFFER_MESSAGE_NORMAL,
9     "INF_CHAT_BUFFER_MESSAGE_NORMAL",
10     "normal"
11   }, {
12     INF_CHAT_BUFFER_MESSAGE_EMOTE,
13     "INF_CHAT_BUFFER_MESSAGE_EMOTE",
14     "emote"
15   }, {
16     INF_CHAT_BUFFER_MESSAGE_USERJOIN,
17     "INF_CHAT_BUFFER_MESSAGE_USERJOIN",
18     "userjoin"
19   }, {
20     INF_CHAT_BUFFER_MESSAGE_USERPART,
21     "INF_CHAT_BUFFER_MESSAGE_USERPART",
22     "userpart"
23   }, {
24     0,
25     NULL,
26     NULL
27   }
28 };</b></font>
29 static const GFlagsValue inf_chat_buffer_message_flags_values[] = {
30   {
31     INF_CHAT_BUFFER_MESSAGE_BACKLOG,
32     "INF_CHAT_BUFFER_MESSAGE_BACKLOG",
33     "backlog"
34   }, {
35 <a name="2"></a>    0,
36     NULL,
37     NULL
38 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  }
39 };
40 typedef struct _InfChatBufferPrivate InfChatBufferPrivate;
41 struct _InfChatBufferPrivate {
42   InfChatBufferMessage* messages;
43   guint alloc_messages;
44   guint num_messages;
45   guint first_message;
46   guint size;
47   gboolean modified;
48 };
49 enum {
50   PROP_0,
51   PROP_SIZE,
52   PROP_MODIFIED
53 };
54 enum {
55   ADD_MESSAGE,
56   LAST_SIGNAL
57 };
58 #define INF_CHAT_BUFFER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_CHAT_BUFFER, InfChatBufferPrivate))
59 static guint chat_buffer_signals[LAST_SIGNAL];
60 static void inf_chat_buffer_buffer_iface_init(InfBufferInterface* iface);</b></font>
61 INF_DEFINE_ENUM_TYPE(InfChatBufferMessageType, inf_chat_buffer_message_type, inf_chat_buffer_message_type_values)
62 INF_DEFINE_FLAGS_TYPE(InfChatBufferMessageFlags, inf_chat_buffer_message_flags, inf_chat_buffer_message_flags_values)
63 G_DEFINE_BOXED_TYPE(InfChatBufferMessage, inf_chat_buffer_message, inf_chat_buffer_message_copy, inf_chat_buffer_message_free)
64 G_DEFINE_TYPE_WITH_CODE(InfChatBuffer, inf_chat_buffer, G_TYPE_OBJECT,
65   G_ADD_PRIVATE(InfChatBuffer)
66   G_IMPLEMENT_INTERFACE(INF_TYPE_BUFFER, inf_chat_buffer_buffer_iface_init))
67 static InfChatBufferMessage*
68 inf_chat_buffer_reserve_message(InfChatBuffer* buffer,
69                                 time_t time)
70 {
71   InfChatBufferPrivate* priv;
72   InfChatBufferMessage* message;
73   guint begin;
74   guint end;
75   guint n;
76   priv = INF_CHAT_BUFFER_PRIVATE(buffer);
77   begin = 0;
78   end = priv-&gt;num_messages;
79   while(begin != end)
80   {
81     n = (begin + end) / 2;
82     message = &amp;priv-&gt;messages[(priv-&gt;first_message + n) % priv-&gt;size];
83     if(message-&gt;time &lt;= time)
84       begin = (begin + end + 1)/2;
85     else
86       end = (begin + end)/2;
87   } while(begin != end);
88   n = begin;
89   if(n == 0 &amp;&amp; priv-&gt;num_messages == priv-&gt;size)
90     return NULL;
91   if(priv-&gt;num_messages &lt; priv-&gt;size)
92   {
93     g_assert(priv-&gt;first_message + priv-&gt;num_messages &lt;= priv-&gt;alloc_messages);
94     if(priv-&gt;num_messages == priv-&gt;alloc_messages)
95     {
96       priv-&gt;alloc_messages = MAX(priv-&gt;alloc_messages * 2, 16);
97       priv-&gt;alloc_messages = MIN(priv-&gt;alloc_messages, priv-&gt;size);
98       g_assert(priv-&gt;alloc_messages &gt; priv-&gt;num_messages);
99       priv-&gt;messages = g_realloc(
100         priv-&gt;messages,
101         priv-&gt;alloc_messages * sizeof(InfChatBufferMessage)
102       );
103     }
104     if(n == 0 &amp;&amp; priv-&gt;first_message == 0)
105     {
106       end = (priv-&gt;alloc_messages - priv-&gt;num_messages + 1) / 2;
107       g_assert(end &gt; 0);
108       memmove(
109         priv-&gt;messages + end,
110         priv-&gt;messages         priv-&gt;num_messages * sizeof(InfChatBufferMessage)
111       );
112       priv-&gt;first_message = end - 1;
113     }
114     else if(n == priv-&gt;num_messages &amp;&amp;
115             priv-&gt;first_message + priv-&gt;num_messages == priv-&gt;alloc_messages)
116     {
117       end = (priv-&gt;alloc_messages - priv-&gt;num_messages) / 2;
118       g_assert(end + priv-&gt;num_messages &lt; priv-&gt;alloc_messages);
119       memmove(
120         priv-&gt;messages + end,
121         priv-&gt;messages + priv-&gt;first_message,
122         priv-&gt;num_messages * sizeof(InfChatBufferMessage)
123       );
124       priv-&gt;first_message = end;
125     }
126     else if(n &gt; 0 &amp;&amp; n &lt; priv-&gt;num_messages)
127     {
128       if((n &lt; priv-&gt;num_messages / 2 &amp;&amp;
129           priv-&gt;first_message &gt; 0) ||
130          (n &gt; priv-&gt;num_messages / 2 &amp;&amp;
131           priv-&gt;first_message + priv-&gt;num_messages == priv-&gt;alloc_messages))
132       {
133         begin = priv-&gt;first_message;
134         memmove(
135           priv-&gt;messages + begin - 1,
136           priv-&gt;messages + begin,
137           (n + 1) * sizeof(InfChatBufferMessage)
138         );
139         --priv-&gt;first_message;
140       }
141       else
142       {
143         memmove(
144           priv-&gt;messages + n + 1,
145           priv-&gt;messages + n,
146           (priv-&gt;num_messages - n) * sizeof(InfChatBufferMessage)
147         );
148       }
149     }
150     else
151     {
152       g_assert(n == 0 || n == priv-&gt;num_messages);
153       if(n == 0)
154       {
155         g_assert(priv-&gt;first_message &gt; 0);
156         --priv-&gt;first_message;
157       }
158       else
159       {
160         g_assert(priv-&gt;first_message + priv-&gt;num_messages &lt;
161                  priv-&gt;alloc_messages);
162       }
163     }
164     ++ priv-&gt;num_messages;
165   }
166   else
167   {
168     g_assert(n &gt; 0); 
169     begin = priv-&gt;first_message;
170     end = (priv-&gt;first_message + n) % priv-&gt;size;
171     if(n == priv-&gt;num_messages)
172     {
173       g_free(priv-&gt;messages[priv-&gt;first_message].text);
174       priv-&gt;first_message = (priv-&gt;first_message + 1) % priv-&gt;size;
175     }
176     else
177     {
178       g_free(priv-&gt;messages[end].text);
179       if(begin &lt; end)
180       {
181         memmove(
182           priv-&gt;messages + begin + 1,
183           priv-&gt;messages + begin,
184           (end - begin) * sizeof(InfChatBufferMessage)
185         );
186       }
187       else
188       {
189         memmove(
190           priv-&gt;messages + end + 1,
191           priv-&gt;messages + end,
192           (begin - end) * sizeof(InfChatBufferMessage)
193         );
194         priv-&gt;first_message = (priv-&gt;first_message + 1) % priv-&gt;size;
195       }
196     }
197     --n;
198   }
199   return &amp;priv-&gt;messages[(priv-&gt;first_message + n) % priv-&gt;size];
200 }
201 static void
202 inf_chat_buffer_init(InfChatBuffer* buffer)
203 {
204   InfChatBufferPrivate* priv;
205   priv = INF_CHAT_BUFFER_PRIVATE(buffer);
206   priv-&gt;messages = NULL;
207   priv-&gt;alloc_messages = 0;
208   priv-&gt;num_messages = 0;
209   priv-&gt;first_message = 0;
210   priv-&gt;size = 256;
211   priv-&gt;modified = FALSE;
212 }
213 static void
214 inf_chat_buffer_finalize(GObject* object)
215 {
216   InfChatBuffer* buffer;
217   InfChatBufferPrivate* priv;
218   guint i;
219   buffer = INF_CHAT_BUFFER(object);
220   priv = INF_CHAT_BUFFER_PRIVATE(buffer);
221 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  for(i = 0; i &lt; priv-&gt;num_messages; ++i)
222     g_free(priv-&gt;messages[(priv-&gt;first_message + i) % priv-&gt;size].text);
223   g_free(priv-&gt;messages);
224   G_OBJECT_CLASS(inf_chat_buffer_parent_class)-&gt;finalize(object);
225 }
226 static void
227 inf_chat_buffer_set_property(GObject* object,
228                              guint prop_id,
229                              const GValue* value,
230                              GParamSpec* pspec)
231 {
232   InfChatBuffer* session;
233   InfChatBufferPrivate* priv;
234   session = INF_CHAT_BUFFER(object);
235   priv = INF_CHAT_BUFFER_PRIVATE(session);
236   switch(prop_id)
237   {
238   case PROP_SIZE:</b></font>
239     g_assert(priv-&gt;num_messages == 0); <a name="0"></a>    priv-&gt;size = g_value_get_uint(value);
240     break;
241   case PROP_MODIFIED:
242 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    priv-&gt;modified = g_value_get_boolean(value);
243     break;
244   default:
245     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
246     break;
247   }
248 }
249 static void
250 inf_chat_buffer_get_property(GObject* object,
251                              guint prop_id,
252                              GValue* value,
253                              GParamSpec* pspec)
254 {
255   InfChatBuffer* session;
256   InfChatBufferPrivate* priv;
257   session = INF_CHAT_BUFFER(object);
258   priv = INF_CHAT_BUFFER_PRIVATE(session);
259   switch(prop_id)
260   {
261   case PROP_SIZE:
262     g_value_set_uint(value, priv-&gt;size);
263     break;
264   case PROP_MODIFIED:
265     g_value_set_boolean(value, priv-&gt;modified);
266     break;</b></font>
267   default:
268     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
269     break;
270   }
271 }
272 static void
273 inf_chat_buffer_add_message_handler(InfChatBuffer* buffer,
274                                     const InfChatBufferMessage* message)
275 {
276   InfChatBufferPrivate* priv;
277   InfChatBufferMessage* new_message;
278   priv = INF_CHAT_BUFFER_PRIVATE(buffer);
279   new_message = inf_chat_buffer_reserve_message(buffer, message-&gt;time);
280   if(new_message != NULL)
281   {
282     new_message-&gt;type = message-&gt;type;
283     new_message-&gt;user = message-&gt;user;
284     new_message-&gt;text = g_strndup(message-&gt;text, message-&gt;length);
285     new_message-&gt;length = message-&gt;length;
286     new_message-&gt;time = message-&gt;time;
287     new_message-&gt;flags = message-&gt;flags;
288   }
289 }
290 static gboolean
291 inf_chat_buffer_buffer_get_modified(InfBuffer* buffer)
292 {
293   return INF_CHAT_BUFFER_PRIVATE(buffer)-&gt;modified;
294 }
295 static void
296 inf_chat_buffer_buffer_set_modified(InfBuffer* buffer,
297                                     gboolean modified)
298 {
299   InfChatBuffer* chat_buffer;
300   InfChatBufferPrivate* priv;
301   chat_buffer = INF_CHAT_BUFFER(buffer);
302   priv = INF_CHAT_BUFFER_PRIVATE(chat_buffer);
303   if(priv-&gt;modified != modified)
304   {
305     priv-&gt;modified = modified;
306     g_object_notify(G_OBJECT(buffer), "modified");
307   }
308 }
309 static void
310 inf_chat_buffer_class_init(InfChatBufferClass* buffer_class)
311 {
312   GObjectClass* object_class;
313   object_class = G_OBJECT_CLASS(buffer_class);
314   object_class-&gt;finalize = inf_chat_buffer_finalize;
315   object_class-&gt;set_property = inf_chat_buffer_set_property;
316   object_class-&gt;get_property = inf_chat_buffer_get_property;
317   buffer_class-&gt;add_message = inf_chat_buffer_add_message_handler;
318   g_object_class_install_property(
319     object_class,
320     PROP_SIZE,
321     g_param_spec_uint(
322       "size",
323       "size",
324       "The maxmimum number of messages saved",
325       0,
326       G_MAXUINT,
327       256,
328       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
329     )
330   );
331   g_object_class_override_property(object_class, PROP_MODIFIED, "modified");
332   chat_buffer_signals[ADD_MESSAGE] = g_signal_new(
333     "add-message",
334     G_OBJECT_CLASS_TYPE(object_class),
335     G_SIGNAL_RUN_LAST,
336     G_STRUCT_OFFSET(InfChatBufferClass, add_message),
337     NULL, NULL,
338     g_cclosure_marshal_VOID__BOXED,
339     G_TYPE_NONE,
340     1,
341     INF_TYPE_CHAT_BUFFER_MESSAGE | G_SIGNAL_TYPE_STATIC_SCOPE
342   );
343 }
344 static void
345 inf_chat_buffer_buffer_iface_init(InfBufferInterface* iface)
346 {
347   iface-&gt;get_modified = inf_chat_buffer_buffer_get_modified;
348   iface-&gt;set_modified = inf_chat_buffer_buffer_set_modified;
349 }
350 InfChatBufferMessage*
351 inf_chat_buffer_message_copy(const InfChatBufferMessage* message)
352 {
353   InfChatBufferMessage* new_message;
354   g_return_val_if_fail(message != NULL, NULL);
355   new_message = g_slice_new(InfChatBufferMessage);
356   new_message-&gt;type = message-&gt;type;
357   new_message-&gt;user = message-&gt;user;
358   new_message-&gt;text = g_strndup(message-&gt;text, message-&gt;length);
359   new_message-&gt;length = message-&gt;length;
360   new_message-&gt;time = message-&gt;time;
361   new_message-&gt;flags = message-&gt;flags;
362   return new_message;
363 }
364 void
365 inf_chat_buffer_message_free(InfChatBufferMessage* message)
366 {
367   g_return_if_fail(message != NULL);
368   g_free(message-&gt;text);
369   g_slice_free(InfChatBufferMessage, message);
370 }
371 InfChatBuffer*
372 inf_chat_buffer_new(guint size)
373 {
374   return g_object_new(
375     INF_TYPE_CHAT_BUFFER,
376     "size", size,
377     NULL
378   );
379 }
380 void
381 inf_chat_buffer_add_message(InfChatBuffer* buffer,
382                             InfUser* by,
383                             const gchar* message,
384                             gsize length,
385                             time_t time,
386                             InfChatBufferMessageFlags flags)
387 {
388   InfChatBufferMessage msg;
389   g_return_if_fail(INF_IS_CHAT_BUFFER(buffer));
390   g_return_if_fail(INF_IS_USER(by));
391   g_return_if_fail(message != NULL);
392   msg.type = INF_CHAT_BUFFER_MESSAGE_NORMAL;
393   msg.user = by;
394   msg.text = *(gchar**) (gpointer) &amp;message;
395   msg.length = length;
396   msg.time = time;
397   msg.flags = flags;
398   g_signal_emit(buffer, chat_buffer_signals[ADD_MESSAGE], 0, &amp;msg);
399 }
400 void
401 inf_chat_buffer_add_emote_message(InfChatBuffer* buffer,
402                                   InfUser* by,
403                                   const gchar* message,
404                                   gsize length,
405                                   time_t time,
406                                   InfChatBufferMessageFlags flags)
407 {
408   InfChatBufferMessage msg;
409   g_return_if_fail(INF_IS_CHAT_BUFFER(buffer));
410   g_return_if_fail(INF_IS_USER(by));
411   g_return_if_fail(message != NULL);
412   msg.type = INF_CHAT_BUFFER_MESSAGE_EMOTE;
413   msg.user = by;
414   msg.text = *(gchar**) (gpointer) &amp;message;
415   msg.length = length;
416   msg.time = time;
417   msg.flags = flags;
418   g_signal_emit(buffer, chat_buffer_signals[ADD_MESSAGE], 0, &amp;msg);
419 }
420 void
421 inf_chat_buffer_add_userjoin_message(InfChatBuffer* buffer,
422                                      InfUser* user,
423                                      time_t time,
424                                      InfChatBufferMessageFlags flags)
425 {
426   InfChatBufferMessage msg;
427   g_return_if_fail(INF_IS_CHAT_BUFFER(buffer));
428   g_return_if_fail(INF_IS_USER(user));
429   msg.type = INF_CHAT_BUFFER_MESSAGE_USERJOIN;
430   msg.user = user;
431   msg.text = NULL;
432   msg.length = 0;
433   msg.time = time;
434   msg.flags = flags;
435   g_signal_emit(buffer, chat_buffer_signals[ADD_MESSAGE], 0, &amp;msg);
436 }
437 void
438 inf_chat_buffer_add_userpart_message(InfChatBuffer* buffer,
439                                      InfUser* user,
440                                      time_t time,
441                                      InfChatBufferMessageFlags flags)
442 {
443   InfChatBufferMessage msg;
444   g_return_if_fail(INF_IS_CHAT_BUFFER(buffer));
445   g_return_if_fail(INF_IS_USER(user));
446   msg.type = INF_CHAT_BUFFER_MESSAGE_USERPART;
447   msg.user = user;
448   msg.text = NULL;
449   msg.length = 0;
450   msg.time = time;
451   msg.flags = flags;
452   g_signal_emit(buffer, chat_buffer_signals[ADD_MESSAGE], 0, &amp;msg);
453 }
454 const InfChatBufferMessage*
455 inf_chat_buffer_get_message(InfChatBuffer* buffer,
456                             guint n)
457 {
458   InfChatBufferPrivate* priv;
459   g_return_val_if_fail(INF_IS_CHAT_BUFFER(buffer), NULL);
460   g_return_val_if_fail(n &lt; inf_chat_buffer_get_n_messages(buffer), NULL);
461   priv = INF_CHAT_BUFFER_PRIVATE(buffer);
462   return &amp;priv-&gt;messages[
463     (priv-&gt;first_message + n) % priv-&gt;size
464   ];
465 }
466 guint
467 inf_chat_buffer_get_n_messages(InfChatBuffer* buffer)
468 {
469   g_return_val_if_fail(INF_IS_CHAT_BUFFER(buffer), 0);
470   return INF_CHAT_BUFFER_PRIVATE(buffer)-&gt;num_messages;
471 }
472 guint
473 inf_chat_buffer_get_size(InfChatBuffer* buffer)
474 {
475   g_return_val_if_fail(INF_IS_CHAT_BUFFER(buffer), 0);
476   return INF_CHAT_BUFFER_PRIVATE(buffer)-&gt;size;
477 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-session.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/common/inf-session.h&gt;
2 #include &lt;libinfinity/common/inf-buffer.h&gt;
3 #include &lt;libinfinity/common/inf-xml-util.h&gt;
4 #include &lt;libinfinity/common/inf-error.h&gt;
5 #include &lt;libinfinity/communication/inf-communication-object.h&gt;
6 #include &lt;libinfinity/inf-i18n.h&gt;
7 #include &lt;libinfinity/inf-signals.h&gt;
8 #include &lt;libinfinity/inf-define-enum.h&gt;
9 #include &lt;string.h&gt;
10 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static const GEnumValue inf_session_status_values[] = {
11   {
12     INF_SESSION_PRESYNC,
13     "INF_SESSION_PRESYNC",
14     "presync"
15   }, {
16     INF_SESSION_SYNCHRONIZING,
17     "INF_SESSION_SYNCHRONIZING",
18     "synchronizing"
19   }, {
20     INF_SESSION_RUNNING,
21     "INF_SESSION_RUNNING",
22     "running"
23   }, {
24     INF_SESSION_CLOSED,
25     "INF_SESSION_CLOSED",
26     "closed"
27   }, {
28     0,
29     NULL,
30     NULL
31   }
32 };</b></font>
33 typedef struct _InfSessionSync InfSessionSync;
34 struct _InfSessionSync {
35   InfCommunicationGroup* group;
36   InfXmlConnection* conn;
37   guint messages_total;
38   guint messages_sent;
39   InfSessionSyncStatus status;
40 };
41 typedef struct _InfSessionPrivate InfSessionPrivate;
42 struct _InfSessionPrivate {
43   InfCommunicationManager* manager;
44   InfBuffer* buffer;
45   InfUserTable* user_table;
46   InfSessionStatus status;
47   InfCommunicationGroup* subscription_group;
48   union {
49     struct {
50       InfCommunicationGroup* group;
51       InfXmlConnection* conn;
52       gboolean closing;
53     } presync;
54     struct {
55       InfCommunicationGroup* group;
56       InfXmlConnection* conn;
57       guint messages_total;
58       guint messages_received;
59       gboolean closing;
60     } sync;
61 <a name="2"></a>    struct {
62       GSList* syncs;
63     } run;
64 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  } shared;
65 };
66 typedef struct _InfSessionXmlData InfSessionXmlData;
67 struct _InfSessionXmlData {
68   InfSession* session;
69   xmlNodePtr xml;
70 };
71 enum {
72   PROP_0,
73   PROP_COMMUNICATION_MANAGER,
74   PROP_BUFFER,
75   PROP_USER_TABLE,
76   PROP_STATUS,
77   PROP_SYNC_CONNECTION,
78   PROP_SYNC_GROUP,
79   PROP_SUBSCRIPTION_GROUP
80 };
81 enum {
82   CLOSE,
83   ERROR,
84   SYNCHRONIZATION_BEGIN,
85   SYNCHRONIZATION_PROGRESS,
86   SYNCHRONIZATION_COMPLETE,
87   SYNCHRONIZATION_FAILED,
88   LAST_SIGNAL
89 };
90 #define INF_SESSION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_SESSION, InfSessionPrivate))
91 static guint session_signals[LAST_SIGNAL];
92 static GQuark inf_session_sync_error_quark;</b></font>
93 static void inf_session_communication_object_iface_init(InfCommunicationObjectInterface* iface);
94 INF_DEFINE_ENUM_TYPE(InfSessionStatus, inf_session_status, inf_session_status_values)
95 G_DEFINE_TYPE_WITH_CODE(InfSession, inf_session, G_TYPE_OBJECT,
96   G_ADD_PRIVATE(InfSession)
97   G_IMPLEMENT_INTERFACE(INF_COMMUNICATION_TYPE_OBJECT, inf_session_communication_object_iface_init))
98 static const gchar*
99 inf_session_sync_strerror(InfSessionSyncError errcode)
100 {
101   switch(errcode)
102   {
103   case INF_SESSION_SYNC_ERROR_GOT_MESSAGE_IN_PRESYNC:
104     return _("Unexpectedly got an XML message in presync");
105   case INF_SESSION_SYNC_ERROR_UNEXPECTED_NODE:
106     return _("Got unexpected XML node during synchronization");
107   case INF_SESSION_SYNC_ERROR_ID_NOT_PRESENT:
108     return _("'id' attribute in user message is missing");
109   case INF_SESSION_SYNC_ERROR_ID_IN_USE:
110     return _("User ID is already in use");
111   case INF_SESSION_SYNC_ERROR_NAME_NOT_PRESENT:
112     return _("'name' attribute in user message is missing");
113   case INF_SESSION_SYNC_ERROR_NAME_IN_USE:
114     return _("User Name is already in use");
115   case INF_SESSION_SYNC_ERROR_CONNECTION_CLOSED:
116     return _("The connection was closed unexpectedly");
117   case INF_SESSION_SYNC_ERROR_SENDER_CANCELLED:
118     return _("The sender cancelled the synchronization");
119   case INF_SESSION_SYNC_ERROR_RECEIVER_CANCELLED:
120     return _("The receiver cancelled the synchronization");
121   case INF_SESSION_SYNC_ERROR_UNEXPECTED_BEGIN_OF_SYNC:
122     return _("Got begin-of-sync message, but synchronization is already "
123              "in progress");
124   case INF_SESSION_SYNC_ERROR_NUM_MESSAGES_MISSING:
125     return _("begin-of-sync message does not contain the number of messages "
126              "to expect");
127   case INF_SESSION_SYNC_ERROR_UNEXPECTED_END_OF_SYNC:
128     return _("Got end-of-sync message, but synchronization is still in "
129              "progress");
130   case INF_SESSION_SYNC_ERROR_EXPECTED_BEGIN_OF_SYNC:
131     return _("Expected begin-of-sync message as first message during "
132              "synchronization");
133   case INF_SESSION_SYNC_ERROR_EXPECTED_END_OF_SYNC:
134     return _("Expected end-of-sync message as last message during "
135              "synchronization");
136   case INF_SESSION_SYNC_ERROR_FAILED:
137     return _("An unknown synchronization error has occurred");
138   default:
139     return _("An error with unknown error code occurred");
140   }
141 }
142 static const gchar*
143 inf_session_get_sync_error_message(GQuark domain,
144                                    guint code)
145 {
146   if(domain == inf_session_sync_error_quark)
147     return inf_session_sync_strerror(code);
148   return _("An error with unknown error domain occurred");
149 }
150 static GSList*
151 inf_session_find_sync_item_by_connection(InfSession* session,
152                                          InfXmlConnection* conn)
153 {
154   InfSessionPrivate* priv;
155   GSList* item;
156   priv = INF_SESSION_PRIVATE(session);
157   g_return_val_if_fail(priv-&gt;status == INF_SESSION_RUNNING, NULL);
158   for(item = priv-&gt;shared.run.syncs; item != NULL; item = g_slist_next(item))
159   {
160     if( ((InfSessionSync*)item-&gt;data)-&gt;conn == conn)
161       return item;
162   }
163   return NULL;
164 }
165 static InfSessionSync*
166 inf_session_find_sync_by_connection(InfSession* session,
167                                     InfXmlConnection* conn)
168 {
169   GSList* item;
170   item = inf_session_find_sync_item_by_connection(session, conn);
171   if(item == NULL) return NULL;
172   return (InfSessionSync*)item-&gt;data;
173 }
174 static void
175 inf_session_connection_notify_status_cb(InfXmlConnection* connection,
176                                         GParamSpec* pspec,
177                                         gpointer user_data);
178 static void
179 inf_session_release_connection(InfSession* session,
180                                InfXmlConnection* connection)
181 {
182   InfSessionPrivate* priv;
183   InfSessionSync* sync;
184   GSList* item;
185   priv = INF_SESSION_PRIVATE(session);
186   switch(priv-&gt;status)
187   {
188   case INF_SESSION_PRESYNC:
189     g_assert(priv-&gt;shared.presync.conn == connection);
190     g_assert(priv-&gt;shared.presync.group != NULL);
191     g_object_unref(priv-&gt;shared.presync.group);
192     priv-&gt;shared.presync.conn = NULL;
193     priv-&gt;shared.presync.group = NULL;
194     break;
195   case INF_SESSION_SYNCHRONIZING:
196     g_assert(priv-&gt;shared.sync.conn == connection);
197     g_assert(priv-&gt;shared.sync.group != NULL);
198     g_object_unref(priv-&gt;shared.sync.group);
199     priv-&gt;shared.sync.conn = NULL;
200     priv-&gt;shared.sync.group = NULL;
201     break;
202   case INF_SESSION_RUNNING:
203     item = inf_session_find_sync_item_by_connection(session, connection);
204     g_assert(item != NULL);
205     sync = item-&gt;data;
206     g_object_unref(sync-&gt;group);
207     g_slice_free(InfSessionSync, sync);
208     priv-&gt;shared.run.syncs = g_slist_delete_link(
209       priv-&gt;shared.run.syncs,
210       item
211     );
212     break;
213   case INF_SESSION_CLOSED:
214   default:
215     g_assert_not_reached();
216     break;
217   }
218   inf_signal_handlers_disconnect_by_func(
219     G_OBJECT(connection),
220     G_CALLBACK(inf_session_connection_notify_status_cb),
221     session
222   );
223   g_object_unref(connection);
224 }
225 static void
226 inf_session_send_sync_error(InfSession* session,
227                             GError* error)
228 {
229   InfSessionPrivate* priv;
230   xmlNodePtr node;
231   priv = INF_SESSION_PRIVATE(session);
232   g_return_if_fail(priv-&gt;status == INF_SESSION_SYNCHRONIZING);
233   g_return_if_fail(priv-&gt;shared.sync.conn != NULL);
234   node = inf_xml_util_new_node_from_error(error, NULL, "sync-error");
235   inf_communication_group_send_message(
236     priv-&gt;shared.sync.group,
237     priv-&gt;shared.sync.conn,
238     node
239   );
240 }
241 static void
242 inf_session_connection_notify_status_cb(InfXmlConnection* connection,
243                                         GParamSpec* pspec,
244                                         gpointer user_data)
245 {
246   InfSession* session;
247   InfSessionPrivate* priv;
248   InfXmlConnectionStatus status;
249   GError* error;
250   session = INF_SESSION(user_data);
251   priv = INF_SESSION_PRIVATE(session);
252   error = NULL;
253   g_object_get(G_OBJECT(connection), "status", &amp;status, NULL);
254   if(status == INF_XML_CONNECTION_CLOSED ||
255      status == INF_XML_CONNECTION_CLOSING)
256   {
257     g_set_error_literal(
258       &amp;error,
259       inf_session_sync_error_quark,
260       INF_SESSION_SYNC_ERROR_CONNECTION_CLOSED,
261       inf_session_sync_strerror(INF_SESSION_SYNC_ERROR_CONNECTION_CLOSED)
262     );
263     switch(priv-&gt;status)
264     {
265     case INF_SESSION_PRESYNC:
266       g_assert(connection == priv-&gt;shared.presync.conn);
267       g_signal_emit(
268         G_OBJECT(session),
269         session_signals[SYNCHRONIZATION_FAILED],
270         0,
271         connection,
272         error
273       );
274       break;
275     case INF_SESSION_SYNCHRONIZING:
276       g_assert(connection == priv-&gt;shared.sync.conn);
277       g_signal_emit(
278         G_OBJECT(session),
279         session_signals[SYNCHRONIZATION_FAILED],
280         0,
281         connection,
282         error
283       );
284       break;
285     case INF_SESSION_RUNNING:
286       g_assert(
287         inf_session_find_sync_by_connection(session, connection) != NULL
288       );
289       g_signal_emit(
290         G_OBJECT(session),
291         session_signals[SYNCHRONIZATION_FAILED],
292         0,
293         connection,
294         error
295       );
296       break;
297     case INF_SESSION_CLOSED:
298     default:
299       g_assert_not_reached();
300       break;
301     }
302     g_error_free(error);
303   }
304 }
305 static void
306 inf_session_init(InfSession* session)
307 {
308   InfSessionPrivate* priv;
309   priv = INF_SESSION_PRIVATE(session);
310   priv-&gt;manager = NULL;
311   priv-&gt;buffer = NULL;
312   priv-&gt;user_table = NULL;
313   priv-&gt;status = INF_SESSION_RUNNING;
314   priv-&gt;shared.run.syncs = NULL;
315 }
316 static void
317 inf_session_constructed(GObject* object)
318 {
319   InfSessionPrivate* priv;
320   InfXmlConnection* sync_conn;
321   G_OBJECT_CLASS(inf_session_parent_class)-&gt;constructed(object);
322   priv = INF_SESSION_PRIVATE(object);
323   if(priv-&gt;user_table == NULL)
324     priv-&gt;user_table = inf_user_table_new();
325   switch(priv-&gt;status)
326   {
327   case INF_SESSION_PRESYNC:
328     g_assert(priv-&gt;shared.presync.conn != NULL &amp;&amp;
329              priv-&gt;shared.presync.group != NULL);
330     sync_conn = priv-&gt;shared.presync.conn;
331     break;
332   case INF_SESSION_SYNCHRONIZING:
333     g_assert(priv-&gt;shared.sync.conn != NULL &amp;&amp;
334              priv-&gt;shared.sync.group != NULL);
335     sync_conn = priv-&gt;shared.sync.conn;
336     break;
337   case INF_SESSION_RUNNING:
338   case INF_SESSION_CLOSED:
339     sync_conn = NULL;
340     break;
341   default:
342     g_assert_not_reached();
343     break;
344   }
345   if(sync_conn != NULL)
346   {
347     g_signal_connect(
348       G_OBJECT(sync_conn),
349       "notify::status",
350       G_CALLBACK(inf_session_connection_notify_status_cb),
351       object
352     );
353   }
354 }
355 static void
356 inf_session_dispose(GObject* object)
357 {
358   InfSession* session;
359   InfSessionPrivate* priv;
360   session = INF_SESSION(object);
361   priv = INF_SESSION_PRIVATE(session);
362   if(priv-&gt;status != INF_SESSION_CLOSED)
363   {
364     inf_session_close(session);
365   }
366   g_object_unref(G_OBJECT(priv-&gt;user_table));
367   priv-&gt;user_table = NULL;
368   g_object_unref(G_OBJECT(priv-&gt;buffer));
369   priv-&gt;buffer = NULL;
370   g_object_unref(G_OBJECT(priv-&gt;manager));
371   priv-&gt;manager = NULL;
372   G_OBJECT_CLASS(inf_session_parent_class)-&gt;dispose(object);
373 }
374 static void
375 inf_session_finalize(GObject* object)
376 {
377 <a name="3"></a>  InfSession* session;
378   InfSessionPrivate* priv;
379 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  session = INF_SESSION(object);
380   priv = INF_SESSION_PRIVATE(session);
381   G_OBJECT_CLASS(inf_session_parent_class)-&gt;finalize(object);
382 }
383 static void
384 inf_session_set_property(GObject* object,
385                          guint prop_id,
386                          const GValue* value,
387                          GParamSpec* pspec)
388 {
389   InfSession* session;
390   InfSessionPrivate* priv;
391   session = INF_SESSION(object);
392   priv = INF_SESSION_PRIVATE(session);
393   switch(prop_id)
394   {
395   case PROP_COMMUNICATION_MANAGER:</b></font>
396     g_assert(priv-&gt;manager == NULL);     priv-&gt;manager = INF_COMMUNICATION_MANAGER(g_value_dup_object(value));
397     break;
398   case PROP_BUFFER:
399     g_assert(priv-&gt;buffer == NULL);     priv-&gt;buffer = INF_BUFFER(g_value_dup_object(value));
400     break;
401   case PROP_USER_TABLE:
402     g_assert(priv-&gt;user_table == NULL);     priv-&gt;user_table = INF_USER_TABLE(g_value_dup_object(value));
403     break;
404   case PROP_STATUS:
405     g_assert(priv-&gt;status == INF_SESSION_RUNNING);
406     priv-&gt;status = g_value_get_enum(value);
407     switch(priv-&gt;status)
408     {
409     case INF_SESSION_PRESYNC:
410       priv-&gt;shared.presync.conn = NULL;
411       priv-&gt;shared.presync.group = NULL;
412       priv-&gt;shared.presync.closing = FALSE;
413       break;
414     case INF_SESSION_SYNCHRONIZING:
415       priv-&gt;shared.sync.conn = NULL;
416       priv-&gt;shared.sync.group = NULL;
417       priv-&gt;shared.sync.messages_total = 0;
418       priv-&gt;shared.sync.messages_received = 0;
419       priv-&gt;shared.sync.closing = FALSE;
420       break;
421     case INF_SESSION_RUNNING:
422       g_assert(priv-&gt;shared.run.syncs == NULL);
423       break;
424     case INF_SESSION_CLOSED:
425       break;
426     default:
427       g_assert_not_reached();
428       break;
429     }
430     break;
431   case PROP_SYNC_CONNECTION:
432     switch(priv-&gt;status)
433     {
434     case INF_SESSION_PRESYNC:
435       g_assert(priv-&gt;shared.presync.conn == NULL);       priv-&gt;shared.presync.conn =
436         INF_XML_CONNECTION(g_value_dup_object(value));
437       break;
438     case INF_SESSION_SYNCHRONIZING:
439       g_assert(priv-&gt;shared.sync.conn == NULL);       priv-&gt;shared.sync.conn =
440         INF_XML_CONNECTION(g_value_dup_object(value));
441       break;
442     case INF_SESSION_RUNNING:
443       g_assert(g_value_get_object(value) == NULL);
444       break;
445     case INF_SESSION_CLOSED:
446     default:
447       g_assert_not_reached();
448       break;
449     }
450     break;
451   case PROP_SYNC_GROUP:
452     switch(priv-&gt;status)
453     {
454     case INF_SESSION_PRESYNC:
455       g_assert(priv-&gt;shared.presync.group == NULL);       priv-&gt;shared.presync.group =
456         INF_COMMUNICATION_GROUP(g_value_dup_object(value));
457       break;
458     case INF_SESSION_SYNCHRONIZING:
459       g_assert(priv-&gt;shared.sync.group == NULL);       priv-&gt;shared.sync.group =
460         INF_COMMUNICATION_GROUP(g_value_dup_object(value));
461       break;
462     case INF_SESSION_RUNNING:
463       g_assert(g_value_get_object(value) == NULL);
464       break;
465     case INF_SESSION_CLOSED:
466     default:
467       g_assert_not_reached();
468       break;
469     }
470     break;
471   case PROP_SUBSCRIPTION_GROUP:
472 <a name="0"></a>    if(priv-&gt;subscription_group != NULL)
473       g_object_unref(priv-&gt;subscription_group);
474 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    priv-&gt;subscription_group =
475       INF_COMMUNICATION_GROUP(g_value_dup_object(value));
476     break;
477   default:
478     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
479     break;
480   }
481 }
482 static void
483 inf_session_get_property(GObject* object,
484                          guint prop_id,
485                          GValue* value,
486                          GParamSpec* pspec)
487 {
488   InfSession* session;
489   InfSessionPrivate* priv;
490   session = INF_SESSION(object);
491   priv = INF_SESSION_PRIVATE(session);
492   switch(prop_id)
493   {
494   case PROP_COMMUNICATION_MANAGER:
495     g_value_set_object(value, G_OBJECT(priv-&gt;manager));
496     break;
497   case PROP_BUFFER:
498     g_value_set_object(value, G_OBJECT(priv-&gt;buffer));
499     break;</b></font>
500   case PROP_USER_TABLE:
501     g_value_set_object(value, G_OBJECT(priv-&gt;user_table));
502     break;
503   case PROP_STATUS:
504     g_value_set_enum(value, priv-&gt;status);
505     break;
506   case PROP_SYNC_CONNECTION:
507     switch(priv-&gt;status)
508     {
509     case INF_SESSION_PRESYNC:
510       g_value_set_object(value, G_OBJECT(priv-&gt;shared.presync.conn));
511       break;
512     case INF_SESSION_SYNCHRONIZING:
513       g_value_set_object(value, G_OBJECT(priv-&gt;shared.sync.conn));
514       break;
515     case INF_SESSION_RUNNING:
516     case INF_SESSION_CLOSED:
517       g_value_set_object(value, NULL);
518       break;
519     default:
520       g_assert_not_reached();
521       break;
522     }
523     break;
524   case PROP_SYNC_GROUP:
525     switch(priv-&gt;status)
526     {
527     case INF_SESSION_PRESYNC:
528       g_value_set_object(value, G_OBJECT(priv-&gt;shared.presync.group));
529       break;
530     case INF_SESSION_SYNCHRONIZING:
531       g_value_set_object(value, G_OBJECT(priv-&gt;shared.sync.group));
532       break;
533     case INF_SESSION_RUNNING:
534     case INF_SESSION_CLOSED:
535       g_value_set_object(value, NULL);
536       break;
537     default:
538       g_assert_not_reached();
539       break;
540     }
541     break;
542   case PROP_SUBSCRIPTION_GROUP:
543     g_value_set_object(value, G_OBJECT(priv-&gt;subscription_group));
544     break;
545   default:
546     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
547     break;
548   }
549 }
550 static InfCommunicationScope
551 inf_session_handle_user_status_change(InfSession* session,
552                                       InfXmlConnection* connection,
553                                       xmlNodePtr xml,
554                                       GError** error)
555 {
556   InfSessionPrivate* priv;
557   InfUser* user;
558   guint id;
559   xmlChar* status_attr;
560   gboolean has_status;
561   InfUserStatus status;
562   priv = INF_SESSION_PRIVATE(session);
563   if(!inf_xml_util_get_attribute_uint_required(xml, "id", &amp;id, error))
564     return INF_COMMUNICATION_SCOPE_PTP;
565   user = inf_user_table_lookup_user_by_id(priv-&gt;user_table, id);
566   if(user == NULL)
567   {
568     g_set_error(
569       error,
570       inf_user_error_quark(),
571       INF_USER_ERROR_NO_SUCH_USER,
572       _("No such user with ID %u"),
573       id
574     );
575     return INF_COMMUNICATION_SCOPE_PTP;
576   }
577   if(inf_user_get_status(user) == INF_USER_UNAVAILABLE ||
578      inf_user_get_connection(user) != connection)
579   {
580     g_set_error_literal(
581       error,
582       inf_user_error_quark(),
583       INF_USER_ERROR_NOT_JOINED,
584       _("User did not join from this connection")
585     );
586     return INF_COMMUNICATION_SCOPE_PTP;
587   }
588   status_attr = xmlGetProp(xml, (const xmlChar*)"status");
589   has_status =
590     inf_user_status_from_string((const char*)status_attr, &amp;status, error);
591   xmlFree(status_attr);
592   if(!has_status) return FALSE;
593   if(inf_user_get_status(user) != status)
594     g_object_set(G_OBJECT(user), "status", status, NULL);
595   return INF_COMMUNICATION_SCOPE_GROUP;
596 }
597 static void
598 inf_session_to_xml_sync_impl_foreach_func(InfUser* user,
599                                           gpointer user_data)
600 {
601   InfSessionXmlData* data;
602   xmlNodePtr usernode;
603   data = (InfSessionXmlData*)user_data;
604   usernode = xmlNewNode(NULL, (const xmlChar*)"sync-user");
605   inf_session_user_to_xml(data-&gt;session, user, usernode);
606   xmlAddChild(data-&gt;xml, usernode);
607 }
608 static void
609 inf_session_to_xml_sync_impl(InfSession* session,
610                              xmlNodePtr parent)
611 {
612   InfSessionPrivate* priv;
613   InfSessionXmlData data;
614   priv = INF_SESSION_PRIVATE(session);
615   data.session = session;
616   data.xml = parent;
617   inf_user_table_foreach_user(
618     priv-&gt;user_table,
619     inf_session_to_xml_sync_impl_foreach_func,
620     &amp;data
621   );
622 }
623 static gboolean
624 inf_session_process_xml_sync_impl(InfSession* session,
625                                   InfXmlConnection* connection,
626                                   const xmlNodePtr xml,
627                                   GError** error)
628 {
629   InfSessionPrivate* priv;
630   InfSessionClass* session_class;
631   GArray* user_props;
632   InfUser* user;
633   guint i;
634   const GParameter* param;
635   GParameter* connparam;
636   priv = INF_SESSION_PRIVATE(session);
637   session_class = INF_SESSION_GET_CLASS(session);
638   g_return_val_if_fail(session_class-&gt;get_xml_user_props != NULL, FALSE);
639   g_return_val_if_fail(priv-&gt;status == INF_SESSION_SYNCHRONIZING, FALSE);
640   g_return_val_if_fail(connection == priv-&gt;shared.sync.conn, FALSE);
641   if(strcmp((const char*)xml-&gt;name, "sync-user") == 0)
642   {
643     user_props = session_class-&gt;get_xml_user_props(
644       session,
645       connection,
646       xml
647     );
648     param = inf_session_lookup_user_property(
649       (const GParameter*)user_props-&gt;data,
650       user_props-&gt;len,
651       "status"
652     );
653     if(param != NULL &amp;&amp;
654        g_value_get_enum(&amp;param-&gt;value) != INF_USER_UNAVAILABLE)
655     {
656       connparam = inf_session_get_user_property(user_props, "connection");
657       if(!G_IS_VALUE(&amp;connparam-&gt;value))
658       {
659         g_value_init(&amp;connparam-&gt;value, INF_TYPE_XML_CONNECTION);
660         g_value_set_object(&amp;connparam-&gt;value, G_OBJECT(connection));
661       }
662     }
663     user = inf_session_add_user(
664       session,
665       (GParameter*)user_props-&gt;data,
666       user_props-&gt;len
667     );
668     for(i = 0; i &lt; user_props-&gt;len; ++ i)
669       g_value_unset(&amp;g_array_index(user_props, GParameter, i).value);
670     g_array_free(user_props, TRUE);
671     if(user == NULL) return FALSE;
672     return TRUE;
673   }
674   else
675   {
676     g_set_error(
677       error,
678       inf_session_sync_error_quark,
679       INF_SESSION_SYNC_ERROR_UNEXPECTED_NODE,
680       "Received unexpected XML message \"%s\" during synchronization",
681       (const gchar*)xml-&gt;name
682     );
683     return FALSE;
684   }
685 }
686 static InfCommunicationScope
687 inf_session_process_xml_run_impl(InfSession* session,
688                                  InfXmlConnection* connection,
689                                  const xmlNodePtr xml,
690                                  GError** error)
691 {
692   if(strcmp((const char*)xml-&gt;name, "user-status-change") == 0)
693   {
694     return inf_session_handle_user_status_change(
695       session,
696       connection,
697       xml,
698       error
699     );
700   }
701   else
702   {
703     g_set_error(
704       error,
705       g_quark_from_static_string("INF_SESSION_ERROR"),
706       0,
707       _("Received unhandled XML message '%s'"),
708       (const gchar*)xml-&gt;name
709     );
710     return INF_COMMUNICATION_SCOPE_PTP;
711   }
712 }
713 static GArray*
714 inf_session_get_xml_user_props_impl(InfSession* session,
715                                     InfXmlConnection* conn,
716                                     const xmlNodePtr xml)
717 {
718   InfSessionPrivate* priv;
719   GArray* array;
720   GParameter* parameter;
721   xmlChar* name;
722   xmlChar* id;
723   xmlChar* status;
724 #if 0
725   xmlChar* connection;
726   InfXmlConnection* real_conn;
727 #endif
728   priv = INF_SESSION_PRIVATE(session);
729   array = g_array_sized_new(FALSE, FALSE, sizeof(GParameter), 16);
730   name = xmlGetProp(xml, (const xmlChar*)"name");
731   id = xmlGetProp(xml, (const xmlChar*)"id");
732   status = xmlGetProp(xml, (const xmlChar*)"status");
733 #if 0
734   connection = xmlGetProp(xml, (const xmlChar*)"connection");
735 #endif
736   if(id != NULL)
737   {
738     parameter = inf_session_get_user_property(array, "id");
739     g_value_init(&amp;parameter-&gt;value, G_TYPE_UINT);
740     g_value_set_uint(&amp;parameter-&gt;value, strtoul((const gchar*)id, NULL, 10));
741     xmlFree(id);
742   }
743   if(name != NULL)
744   {
745     parameter = inf_session_get_user_property(array, "name");
746     g_value_init(&amp;parameter-&gt;value, G_TYPE_STRING);
747     g_value_set_string(&amp;parameter-&gt;value, (const gchar*)name);
748     xmlFree(name);
749   }
750   if(status != NULL)
751   {
752     parameter = inf_session_get_user_property(array, "status");
753     g_value_init(&amp;parameter-&gt;value, INF_TYPE_USER_STATUS);
754     if(strcmp((const char*)status, "active") == 0)
755       g_value_set_enum(&amp;parameter-&gt;value, INF_USER_ACTIVE);
756     else if(strcmp((const char*)status, "inactive") == 0)
757       g_value_set_enum(&amp;parameter-&gt;value, INF_USER_INACTIVE);
758     else
759       g_value_set_enum(&amp;parameter-&gt;value, INF_USER_UNAVAILABLE);
760     xmlFree(status);
761   }
762 #if 0
763   if(connection != NULL)
764   {
765     real_conn = inf_connection_manager_group_lookup_connection(
766       priv-&gt;subscription_group,
767       connection
768     );
769     if(real_conn != NULL)
770     {
771       parameter = inf_session_get_user_property(array, "connection");
772       g_value_init(&amp;parameter-&gt;value, INF_TYPE_XML_CONNECTION);
773       g_value_set_object(&amp;parameter-&gt;value, G_OBJECT(real_conn));
774     }
775     else
776     {
777     }
778   }
779 #endif
780   return array;
781 }
782 static void
783 inf_session_set_xml_user_props_impl(InfSession* session,
784                                     const GParameter* params,
785                                     guint n_params,
786                                     xmlNodePtr xml)
787 {
788   guint i;
789   gchar id_buf[16];
790   const gchar* name;
791   InfUserStatus status;
792 #if 0
793   InfXmlConnection* conn;
794   gchar* remote_address;
795 #endif
796   for(i = 0; i &lt; n_params; ++ i)
797   {
798     if(strcmp(params[i].name, "id") == 0)
799     {
800       sprintf(id_buf, "%u", g_value_get_uint(&amp;params[i].value));
801       xmlNewProp(xml, (const xmlChar*)"id", (const xmlChar*)id_buf);
802     }
803     else if(strcmp(params[i].name, "name") == 0)
804     {
805       name = g_value_get_string(&amp;params[i].value);
806       xmlNewProp(xml, (const xmlChar*)"name", (const xmlChar*)name);
807     }
808     else if(strcmp(params[i].name, "status") == 0)
809     {
810       status = g_value_get_enum(&amp;params[i].value);
811       inf_xml_util_set_attribute(
812         xml,
813         "status",
814         inf_user_status_to_string(status)
815       );
816     }
817   }
818 }
819 static gboolean
820 inf_session_validate_user_props_impl(InfSession* session,
821                                      const GParameter* params,
822                                      guint n_params,
823                                      InfUser* exclude,
824                                      GError** error)
825 {
826   InfSessionPrivate* priv;
827   const GParameter* parameter;
828   const gchar* name;
829   InfUser* user;
830   guint id;
831   priv = INF_SESSION_PRIVATE(session);
832   parameter = inf_session_lookup_user_property(params, n_params, "id");
833   if(parameter == NULL)
834   {
835     g_set_error_literal(
836       error,
837       inf_session_sync_error_quark,
838       INF_SESSION_SYNC_ERROR_ID_NOT_PRESENT,
839       inf_session_sync_strerror(INF_SESSION_SYNC_ERROR_ID_NOT_PRESENT)
840     );
841     return FALSE;
842   }
843   id = g_value_get_uint(&amp;parameter-&gt;value);
844   user = inf_user_table_lookup_user_by_id(priv-&gt;user_table, id);
845   if(user != NULL &amp;&amp; user != exclude)
846   {
847     g_set_error_literal(
848       error,
849       inf_session_sync_error_quark,
850       INF_SESSION_SYNC_ERROR_ID_IN_USE,
851       inf_session_sync_strerror(INF_SESSION_SYNC_ERROR_ID_IN_USE)
852     );
853     return FALSE;
854   }
855   parameter = inf_session_lookup_user_property(params, n_params, "name");
856   if(parameter == NULL)
857   {
858     g_set_error_literal(
859       error,
860       inf_session_sync_error_quark,
861       INF_SESSION_SYNC_ERROR_NAME_NOT_PRESENT,
862       inf_session_sync_strerror(INF_SESSION_SYNC_ERROR_NAME_NOT_PRESENT)
863     );
864     return FALSE;
865   }
866   name = g_value_get_string(&amp;parameter-&gt;value);
867   user = inf_user_table_lookup_user_by_name(priv-&gt;user_table, name);
868   if(user != NULL &amp;&amp; user != exclude)
869   {
870     g_set_error_literal(
871       error,
872       inf_session_sync_error_quark,
873       INF_SESSION_SYNC_ERROR_NAME_IN_USE,
874       inf_session_sync_strerror(INF_SESSION_SYNC_ERROR_NAME_IN_USE)
875     );
876     return FALSE;
877   }
878   return TRUE;
879 }
880 static gboolean
881 inf_session_handle_received_sync_message(InfSession* session,
882                                          InfXmlConnection* connection,
883                                          const xmlNodePtr node,
884                                          GError** error)
885 {
886   InfSessionClass* session_class;
887   InfSessionPrivate* priv;
888   xmlChar* num_messages;
889   gboolean result;
890   xmlNodePtr xml_reply;
891   GError* local_error;
892   session_class = INF_SESSION_GET_CLASS(session);
893   priv = INF_SESSION_PRIVATE(session);
894   g_assert(session_class-&gt;process_xml_sync != NULL);
895   g_assert(priv-&gt;status == INF_SESSION_SYNCHRONIZING);
896   if(strcmp((const gchar*)node-&gt;name, "sync-cancel") == 0)
897   {
898     local_error = NULL;
899     g_set_error_literal(
900       &amp;local_error,
901       inf_session_sync_error_quark,
902       INF_SESSION_SYNC_ERROR_SENDER_CANCELLED,
903       inf_session_sync_strerror(INF_SESSION_SYNC_ERROR_SENDER_CANCELLED)
904     );
905     g_signal_emit(
906       G_OBJECT(session),
907       session_signals[SYNCHRONIZATION_FAILED],
908       0,
909       connection,
910       local_error
911     );
912 #if 0
913     inf_session_close(session);
914 #endif
915     g_error_free(local_error);
916     return FALSE;
917   }
918   else if(strcmp((const gchar*)node-&gt;name, "sync-begin") == 0)
919   {
920     if(priv-&gt;shared.sync.messages_total &gt; 0)
921     {
922       g_set_error_literal(
923         error,
924         inf_session_sync_error_quark,
925         INF_SESSION_SYNC_ERROR_UNEXPECTED_BEGIN_OF_SYNC,
926         inf_session_sync_strerror(
927           INF_SESSION_SYNC_ERROR_UNEXPECTED_BEGIN_OF_SYNC
928         )
929       );
930       return FALSE;
931     }
932     else
933     {
934       num_messages = xmlGetProp(node, (const xmlChar*)"num-messages");
935       if(num_messages == NULL)
936       {
937         g_set_error_literal(
938           error,
939           inf_session_sync_error_quark,
940           INF_SESSION_SYNC_ERROR_NUM_MESSAGES_MISSING,
941           inf_session_sync_strerror(
942             INF_SESSION_SYNC_ERROR_NUM_MESSAGES_MISSING
943           )
944         );
945         return FALSE;
946       }
947       else
948       {
949         priv-&gt;shared.sync.messages_total = 2 + strtoul(
950           (const gchar*)num_messages,
951           NULL,
952           0
953         );
954         priv-&gt;shared.sync.messages_received = 1;
955         xmlFree(num_messages);
956         g_signal_emit(
957           G_OBJECT(session),
958           session_signals[SYNCHRONIZATION_PROGRESS],
959           0,
960           connection,
961           1.0 / (double)priv-&gt;shared.sync.messages_total
962         );
963         return TRUE;
964       }
965     }
966   }
967   else if(strcmp((const gchar*)node-&gt;name, "sync-end") == 0)
968   {
969     ++ priv-&gt;shared.sync.messages_received;
970     if(priv-&gt;shared.sync.messages_received !=
971        priv-&gt;shared.sync.messages_total)
972     {
973       g_set_error_literal(
974         error,
975         inf_session_sync_error_quark,
976         INF_SESSION_SYNC_ERROR_UNEXPECTED_END_OF_SYNC,
977         inf_session_sync_strerror(
978           INF_SESSION_SYNC_ERROR_UNEXPECTED_END_OF_SYNC
979         )
980       );
981       return FALSE;
982     }
983     else
984     {
985       xml_reply = xmlNewNode(NULL, (const xmlChar*)"sync-ack");
986       inf_communication_group_send_message(
987         priv-&gt;shared.sync.group,
988         connection,
989         xml_reply
990       );
991       g_signal_emit(
992         G_OBJECT(session),
993         session_signals[SYNCHRONIZATION_COMPLETE],
994         0,
995         connection
996       );
997       return TRUE;
998     }
999   }
1000   else
1001   {
1002     if(priv-&gt;shared.sync.messages_received == 0)
1003     {
1004       g_set_error_literal(
1005         error,
1006         inf_session_sync_error_quark,
1007         INF_SESSION_SYNC_ERROR_EXPECTED_BEGIN_OF_SYNC,
1008         inf_session_sync_strerror(
1009           INF_SESSION_SYNC_ERROR_EXPECTED_BEGIN_OF_SYNC
1010         )
1011       );
1012       return FALSE;
1013     }
1014     else if(priv-&gt;shared.sync.messages_received ==
1015             priv-&gt;shared.sync.messages_total - 1)
1016     {
1017       g_set_error_literal(
1018         error,
1019         inf_session_sync_error_quark,
1020         INF_SESSION_SYNC_ERROR_EXPECTED_END_OF_SYNC,
1021         inf_session_sync_strerror(INF_SESSION_SYNC_ERROR_EXPECTED_END_OF_SYNC)
1022       );
1023       return FALSE;
1024     }
1025     else
1026     {
1027       result = session_class-&gt;process_xml_sync(
1028         session,
1029         connection,
1030         node,
1031         error
1032       );
1033       if(result == FALSE) return FALSE;
1034       if(priv-&gt;status == INF_SESSION_CLOSED)
1035         return TRUE;
1036       ++ priv-&gt;shared.sync.messages_received;
1037       g_signal_emit(
1038         G_OBJECT(session),
1039         session_signals[SYNCHRONIZATION_PROGRESS],
1040         0,
1041         connection,
1042         (double)priv-&gt;shared.sync.messages_received /
1043           (double)priv-&gt;shared.sync.messages_total
1044       );
1045       return TRUE;
1046     }
1047   }
1048 }
1049 static void
1050 inf_session_communication_object_sent(InfCommunicationObject* comm_object,
1051                                       InfXmlConnection* connection,
1052                                       const xmlNodePtr node)
1053 {
1054   InfSession* session;
1055   InfSessionPrivate* priv;
1056   InfSessionSync* sync;
1057   session = INF_SESSION(comm_object);
1058   priv = INF_SESSION_PRIVATE(session);
1059   if(priv-&gt;status == INF_SESSION_RUNNING)
1060   {
1061     sync = inf_session_find_sync_by_connection(session, connection);
1062     if(sync != NULL &amp;&amp; sync-&gt;messages_sent &lt; sync-&gt;messages_total)
1063     {
1064       ++ sync-&gt;messages_sent;
1065       g_signal_emit(
1066         G_OBJECT(comm_object),
1067         session_signals[SYNCHRONIZATION_PROGRESS],
1068         0,
1069         connection,
1070         (gdouble)sync-&gt;messages_sent / (gdouble)sync-&gt;messages_total
1071       );
1072     }
1073   }
1074 }
1075 static void
1076 inf_session_communication_object_enqueued(InfCommunicationObject* comm_object,
1077                                           InfXmlConnection* connection,
1078                                           const xmlNodePtr node)
1079 {
1080   InfSessionSync* sync;
1081   if(strcmp((const gchar*)node-&gt;name, "sync-end") == 0)
1082   {
1083     sync = inf_session_find_sync_by_connection(
1084       INF_SESSION(comm_object),
1085       connection
1086     );
1087     g_assert(sync != NULL);
1088     g_assert(sync-&gt;status == INF_SESSION_SYNC_IN_PROGRESS);
1089     sync-&gt;status = INF_SESSION_SYNC_AWAITING_ACK;
1090   }
1091 }
1092 static InfCommunicationScope
1093 inf_session_communication_object_received(InfCommunicationObject* comm_object,
1094                                           InfXmlConnection* connection,
1095                                           const xmlNodePtr node)
1096 {
1097   InfSessionClass* session_class;
1098   InfSession* session;
1099   InfSessionPrivate* priv;
1100   InfSessionSync* sync;
1101   gboolean result;
1102   InfCommunicationScope scope;
1103   GError* local_error;
1104   const gchar* local_message;
1105   session = INF_SESSION(comm_object);
1106   priv = INF_SESSION_PRIVATE(session);
1107   switch(priv-&gt;status)
1108   {
1109   case INF_SESSION_PRESYNC:
1110     g_assert(connection == priv-&gt;shared.presync.conn);
1111     local_error = NULL;
1112     g_set_error(
1113       &amp;local_error,
1114       inf_session_sync_error_quark,
1115       INF_SESSION_SYNC_ERROR_GOT_MESSAGE_IN_PRESYNC,
1116       _("Unexpectedly received XML message \"%s\" in presync"),
1117       (const gchar*)node-&gt;name
1118     );
1119      g_signal_emit(
1120       G_OBJECT(session),
1121       session_signals[ERROR],
1122       0,
1123       connection,
1124       node,
1125       local_error
1126     );
1127     return INF_COMMUNICATION_SCOPE_PTP;
1128   case INF_SESSION_SYNCHRONIZING:
1129     g_assert(connection == priv-&gt;shared.sync.conn);
1130     local_error = NULL;
1131     result = inf_session_handle_received_sync_message(
1132       session,
1133       connection,
1134       node,
1135       &amp;local_error
1136     );
1137     if(result == FALSE &amp;&amp; local_error != NULL)
1138     {
1139       inf_session_send_sync_error(session, local_error);
1140       g_signal_emit(
1141         G_OBJECT(session),
1142         session_signals[SYNCHRONIZATION_FAILED],
1143         0,
1144         connection,
1145         local_error
1146       );
1147       g_error_free(local_error);
1148     }
1149     return INF_COMMUNICATION_SCOPE_PTP;
1150   case INF_SESSION_RUNNING:
1151     sync = inf_session_find_sync_by_connection(session, connection);
1152     if(sync != NULL)
1153     {
1154       if(strcmp((const gchar*)node-&gt;name, "sync-error") == 0)
1155       {
1156         inf_communication_group_cancel_messages(sync-&gt;group, connection);
1157         local_error = inf_xml_util_new_error_from_node(node);
1158         if(local_error != NULL)
1159         {
1160           local_message =
1161             inf_session_get_sync_error_message(local_error-&gt;domain,
1162                                                local_error-&gt;code);
1163           if(local_message != NULL)
1164           {
1165             if(local_error-&gt;message != NULL)
1166               g_free(local_error-&gt;message);
1167             local_error-&gt;message = g_strdup(local_message);
1168           }
1169         }
1170         else
1171         {
1172           g_set_error_literal(
1173             &amp;local_error,
1174             inf_session_sync_error_quark,
1175             INF_SESSION_SYNC_ERROR_FAILED,
1176             inf_session_sync_strerror(INF_SESSION_SYNC_ERROR_FAILED)
1177           );
1178         }
1179         g_signal_emit(
1180           G_OBJECT(session),
1181           session_signals[SYNCHRONIZATION_FAILED],
1182           0,
1183           connection,
1184           local_error
1185         );
1186         g_error_free(local_error);
1187       }
1188       else if(strcmp((const gchar*)node-&gt;name, "sync-ack") == 0 &amp;&amp;
1189               sync-&gt;status == INF_SESSION_SYNC_AWAITING_ACK)
1190       {
1191         g_signal_emit(
1192           G_OBJECT(comm_object),
1193           session_signals[SYNCHRONIZATION_COMPLETE],
1194           0,
1195           connection
1196         );
1197       }
1198       else
1199       {
1200         local_error = NULL;
1201         g_set_error(
1202           &amp;local_error,
1203           inf_session_sync_error_quark,
1204           INF_SESSION_SYNC_ERROR_UNEXPECTED_NODE,
1205           _("Received unexpected XML message \"%s\" while synchronizing"),
1206           (const gchar*)node-&gt;name
1207         );
1208         g_error_free(local_error);
1209       }
1210       return INF_COMMUNICATION_SCOPE_PTP;
1211     }
1212     else
1213     {
1214       session_class = INF_SESSION_GET_CLASS(session);
1215       g_assert(session_class-&gt;process_xml_run != NULL);
1216       local_error = NULL;
1217       scope = session_class-&gt;process_xml_run(
1218         session,
1219         connection,
1220         node,
1221         &amp;local_error
1222       );
1223       if(local_error != NULL)
1224       {
1225         g_signal_emit(
1226           G_OBJECT(session),
1227           session_signals[ERROR],
1228           0,
1229           connection,
1230           node,
1231           local_error
1232         );
1233         g_error_free(local_error);
1234       }
1235       return scope;
1236     }
1237   case INF_SESSION_CLOSED:
1238   default:
1239     g_assert_not_reached();
1240     return INF_COMMUNICATION_SCOPE_PTP;
1241   }
1242 }
1243 static void
1244 inf_session_close_handler(InfSession* session)
1245 {
1246   InfSessionPrivate* priv;
1247   InfSessionSync* sync;
1248   priv = INF_SESSION_PRIVATE(session);
1249   g_object_freeze_notify(G_OBJECT(session));
1250   switch(priv-&gt;status)
1251   {
1252   case INF_SESSION_PRESYNC:
1253     if(priv-&gt;shared.presync.closing == FALSE)
1254     {
1255       priv-&gt;shared.presync.closing = TRUE;
1256       inf_session_cancel_synchronization(session, priv-&gt;shared.presync.conn);
1257     }
1258     inf_session_release_connection(session, priv-&gt;shared.presync.conn);
1259     break;
1260   case INF_SESSION_SYNCHRONIZING:
1261     if(priv-&gt;shared.sync.closing == FALSE)
1262     {
1263       priv-&gt;shared.sync.closing = TRUE;
1264       inf_session_cancel_synchronization(session, priv-&gt;shared.sync.conn);
1265     }
1266     inf_session_release_connection(session, priv-&gt;shared.sync.conn);
1267     break;
1268   case INF_SESSION_RUNNING:
1269     while(priv-&gt;shared.run.syncs != NULL)
1270     {
1271       sync = (InfSessionSync*)priv-&gt;shared.run.syncs-&gt;data;
1272       inf_session_cancel_synchronization(session, sync-&gt;conn);
1273     }
1274     break;
1275   case INF_SESSION_CLOSED:
1276   default:
1277     g_assert_not_reached();
1278     break;
1279   }
1280   if(priv-&gt;subscription_group != NULL)
1281   {
1282     g_object_unref(priv-&gt;subscription_group);
1283     priv-&gt;subscription_group = NULL;
1284     g_object_notify(G_OBJECT(session), "subscription-group");
1285   }
1286   priv-&gt;status = INF_SESSION_CLOSED;
1287   g_object_notify(G_OBJECT(session), "status");
1288   g_object_thaw_notify(G_OBJECT(session));
1289 }
1290 static void
1291 inf_session_synchronization_begin_handler(InfSession* session,
1292                                           InfCommunicationGroup* group,
1293                                           InfXmlConnection* connection)
1294 {
1295   InfSessionPrivate* priv;
1296   InfSessionClass* session_class;
1297   InfSessionSync* sync;
1298   xmlNodePtr messages;
1299   xmlNodePtr next;
1300   xmlNodePtr xml;
1301   gchar num_messages_buf[16];
1302   priv = INF_SESSION_PRIVATE(session);
1303   g_assert(priv-&gt;status == INF_SESSION_RUNNING);
1304   g_assert(inf_session_find_sync_by_connection(session, connection) == NULL);
1305   session_class = INF_SESSION_GET_CLASS(session);
1306   g_return_if_fail(session_class-&gt;to_xml_sync != NULL);
1307   sync = g_slice_new(InfSessionSync);
1308   sync-&gt;conn = connection;
1309   sync-&gt;messages_sent = 0;
1310   sync-&gt;messages_total = 2;   sync-&gt;status = INF_SESSION_SYNC_IN_PROGRESS;
1311   g_object_ref(G_OBJECT(connection));
1312   priv-&gt;shared.run.syncs = g_slist_prepend(priv-&gt;shared.run.syncs, sync);
1313   g_signal_connect_after(
1314     G_OBJECT(connection),
1315     "notify::status",
1316     G_CALLBACK(inf_session_connection_notify_status_cb),
1317     session
1318   );
1319   sync-&gt;group = group;
1320   g_object_ref(sync-&gt;group);
1321   g_assert(inf_communication_group_is_member(sync-&gt;group, connection));
1322   messages = xmlNewNode(NULL, (const xmlChar*)"sync-container");
1323   session_class-&gt;to_xml_sync(session, messages);
1324   for(xml = messages-&gt;children; xml != NULL; xml = xml-&gt;next)
1325     ++ sync-&gt;messages_total;
1326   sprintf(num_messages_buf, "%u", sync-&gt;messages_total - 2);
1327   xml = xmlNewNode(NULL, (const xmlChar*)"sync-begin");
1328   xmlNewProp(
1329     xml,
1330     (const xmlChar*)"num-messages",
1331     (const xmlChar*)num_messages_buf
1332   );
1333   inf_communication_group_send_message(sync-&gt;group, connection, xml);
1334   for(xml = messages-&gt;children; xml != NULL; xml = next)
1335   {
1336     next = xml-&gt;next;
1337     xmlUnlinkNode(xml);
1338     inf_communication_group_send_message(sync-&gt;group, connection, xml);
1339   }
1340   xmlFreeNode(messages);
1341   xml = xmlNewNode(NULL, (const xmlChar*)"sync-end");
1342   inf_communication_group_send_message(sync-&gt;group, connection, xml);
1343 }
1344 static void
1345 inf_session_synchronization_complete_handler(InfSession* session,
1346                                              InfXmlConnection* connection)
1347 {
1348   InfSessionPrivate* priv;
1349   priv = INF_SESSION_PRIVATE(session);
1350   switch(priv-&gt;status)
1351   {
1352   case INF_SESSION_PRESYNC:
1353     g_assert_not_reached();
1354     break;
1355   case INF_SESSION_SYNCHRONIZING:
1356     g_assert(connection == priv-&gt;shared.sync.conn);
1357     inf_session_release_connection(session, connection);
1358     priv-&gt;status = INF_SESSION_RUNNING;
1359     priv-&gt;shared.run.syncs = NULL;
1360     g_object_notify(G_OBJECT(session), "status");
1361     break;
1362   case INF_SESSION_RUNNING:
1363     g_assert(
1364       inf_session_find_sync_by_connection(session, connection) != NULL
1365     );
1366     inf_session_release_connection(session, connection);
1367     break;
1368   case INF_SESSION_CLOSED:
1369   default:
1370     g_assert_not_reached();
1371     break;
1372   }
1373 }
1374 static void
1375 inf_session_synchronization_failed_handler(InfSession* session,
1376                                            InfXmlConnection* connection,
1377                                            const GError* error)
1378 {
1379   InfSessionPrivate* priv;
1380   priv = INF_SESSION_PRIVATE(session);
1381   switch(priv-&gt;status)
1382   {
1383   case INF_SESSION_PRESYNC:
1384     g_assert(connection == priv-&gt;shared.presync.conn);
1385     if(priv-&gt;shared.presync.closing == FALSE)
1386     {
1387       priv-&gt;shared.presync.closing = TRUE;
1388       inf_session_close(session);
1389     }
1390     break;
1391   case INF_SESSION_SYNCHRONIZING:
1392     g_assert(connection == priv-&gt;shared.sync.conn);
1393     if(priv-&gt;shared.sync.closing == FALSE)
1394     {
1395       priv-&gt;shared.sync.closing = TRUE;
1396       inf_session_close(session);
1397     }
1398     break;
1399   case INF_SESSION_RUNNING:
1400     g_assert(
1401       inf_session_find_sync_by_connection(session, connection) != NULL
1402     );
1403     inf_session_release_connection(session, connection);
1404     break;
1405   case INF_SESSION_CLOSED:
1406     break;
1407   default:
1408     g_assert_not_reached();
1409     break;
1410   }
1411 }
1412 static void
1413 inf_session_class_init(InfSessionClass* session_class)
1414 {
1415   GObjectClass* object_class;
1416   object_class = G_OBJECT_CLASS(session_class);
1417   object_class-&gt;constructed = inf_session_constructed;
1418   object_class-&gt;dispose = inf_session_dispose;
1419   object_class-&gt;finalize = inf_session_finalize;
1420   object_class-&gt;set_property = inf_session_set_property;
1421   object_class-&gt;get_property = inf_session_get_property;
1422   session_class-&gt;to_xml_sync = inf_session_to_xml_sync_impl;
1423   session_class-&gt;process_xml_sync = inf_session_process_xml_sync_impl;
1424   session_class-&gt;process_xml_run = inf_session_process_xml_run_impl;
1425   session_class-&gt;get_xml_user_props = inf_session_get_xml_user_props_impl;
1426   session_class-&gt;set_xml_user_props = inf_session_set_xml_user_props_impl;
1427   session_class-&gt;validate_user_props = inf_session_validate_user_props_impl;
1428   session_class-&gt;user_new = NULL;
1429   session_class-&gt;close = inf_session_close_handler;
1430   session_class-&gt;error = NULL;
1431   session_class-&gt;synchronization_begin =
1432     inf_session_synchronization_begin_handler;
1433   session_class-&gt;synchronization_progress = NULL;
1434   session_class-&gt;synchronization_complete =
1435     inf_session_synchronization_complete_handler;
1436   session_class-&gt;synchronization_failed =
1437     inf_session_synchronization_failed_handler;
1438   inf_session_sync_error_quark = g_quark_from_static_string(
1439     "INF_SESSION_SYNC_ERROR"
1440   );
1441   g_object_class_install_property(
1442     object_class,
1443     PROP_COMMUNICATION_MANAGER,
1444     g_param_spec_object(
1445       "communication-manager",
1446       "Communication manager",
1447       "The communication manager used for sending requests",
1448       INF_COMMUNICATION_TYPE_MANAGER,
1449       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1450     )
1451   );
1452   g_object_class_install_property(
1453     object_class,
1454     PROP_BUFFER,
1455     g_param_spec_object(
1456       "buffer",
1457       "Buffer",
1458       "The buffer in which the document content is stored",
1459       INF_TYPE_BUFFER,
1460       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1461     )
1462   );
1463   g_object_class_install_property(
1464     object_class,
1465     PROP_USER_TABLE,
1466     g_param_spec_object(
1467       "user-table",
1468       "User table",
1469       "User table containing the users of the session",
1470       INF_TYPE_USER_TABLE,
1471       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1472     )
1473   );
1474   g_object_class_install_property(
1475     object_class,
1476     PROP_STATUS,
1477     g_param_spec_enum(
1478       "status",
1479       "Session Status",
1480       "Current status of the session",
1481       INF_TYPE_SESSION_STATUS,
1482       INF_SESSION_RUNNING,
1483       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1484     )
1485   );
1486   g_object_class_install_property(
1487     object_class,
1488     PROP_SYNC_CONNECTION,
1489     g_param_spec_object(
1490       "sync-connection",
1491       "Synchronizing connection",
1492       "Connection which synchronizes the initial session state",
1493       INF_TYPE_XML_CONNECTION,
1494       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1495     )
1496   );
1497   g_object_class_install_property(
1498     object_class,
1499     PROP_SYNC_GROUP,
1500     g_param_spec_object(
1501       "sync-group",
1502       "Synchronization group",
1503       "Communication group in which to perform synchronization",
1504       INF_COMMUNICATION_TYPE_GROUP,
1505       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1506     )
1507   );
1508   g_object_class_install_property(
1509     object_class,
1510     PROP_SUBSCRIPTION_GROUP,
1511     g_param_spec_object(
1512       "subscription-group",
1513       "Subscription group",
1514       "Communication group of subscribed connections",
1515       INF_COMMUNICATION_TYPE_GROUP,
1516       G_PARAM_READWRITE
1517     )
1518   );
1519   session_signals[CLOSE] = g_signal_new(
1520     "close",
1521     G_OBJECT_CLASS_TYPE(object_class),
1522     G_SIGNAL_RUN_LAST,
1523     G_STRUCT_OFFSET(InfSessionClass, close),
1524     NULL, NULL,
1525     g_cclosure_marshal_VOID__VOID,
1526     G_TYPE_NONE,
1527     0
1528   );
1529   session_signals[ERROR] = g_signal_new(
1530     "error",
1531     G_OBJECT_CLASS_TYPE(object_class),
1532     G_SIGNAL_RUN_LAST,
1533     G_STRUCT_OFFSET(InfSessionClass, error),
1534     NULL, NULL,
1535     NULL,
1536     G_TYPE_NONE,
1537     3,
1538     INF_TYPE_XML_CONNECTION,
1539     G_TYPE_POINTER,     G_TYPE_ERROR
1540   );
1541   session_signals[SYNCHRONIZATION_BEGIN] = g_signal_new(
1542     "synchronization-begin",
1543     G_OBJECT_CLASS_TYPE(object_class),
1544     G_SIGNAL_RUN_LAST,
1545     G_STRUCT_OFFSET(InfSessionClass, synchronization_begin),
1546     NULL, NULL,
1547     NULL,
1548     G_TYPE_NONE,
1549     2,
1550     INF_COMMUNICATION_TYPE_GROUP,
1551     INF_TYPE_XML_CONNECTION
1552   );
1553   session_signals[SYNCHRONIZATION_PROGRESS] = g_signal_new(
1554     "synchronization-progress",
1555     G_OBJECT_CLASS_TYPE(object_class),
1556     G_SIGNAL_RUN_LAST,
1557     G_STRUCT_OFFSET(InfSessionClass, synchronization_progress),
1558     NULL, NULL,
1559     NULL,
1560     G_TYPE_NONE,
1561     2,
1562     INF_TYPE_XML_CONNECTION,
1563     G_TYPE_DOUBLE
1564   );
1565   session_signals[SYNCHRONIZATION_COMPLETE] = g_signal_new(
1566     "synchronization-complete",
1567     G_OBJECT_CLASS_TYPE(object_class),
1568     G_SIGNAL_RUN_LAST,
1569     G_STRUCT_OFFSET(InfSessionClass, synchronization_complete),
1570     NULL, NULL,
1571     g_cclosure_marshal_VOID__OBJECT,
1572     G_TYPE_NONE,
1573     1,
1574     INF_TYPE_XML_CONNECTION
1575   );
1576   session_signals[SYNCHRONIZATION_FAILED] = g_signal_new(
1577     "synchronization-failed",
1578     G_OBJECT_CLASS_TYPE(object_class),
1579     G_SIGNAL_RUN_LAST,
1580     G_STRUCT_OFFSET(InfSessionClass, synchronization_failed),
1581     NULL, NULL,
1582     NULL,
1583     G_TYPE_NONE,
1584     2,
1585     INF_TYPE_XML_CONNECTION,
1586     G_TYPE_ERROR
1587   );
1588 }
1589 static void
1590 inf_session_communication_object_iface_init(
1591   InfCommunicationObjectInterface* iface)
1592 {
1593   iface-&gt;sent = inf_session_communication_object_sent;
1594   iface-&gt;enqueued = inf_session_communication_object_enqueued;
1595   iface-&gt;received = inf_session_communication_object_received;
1596 }
1597 const GParameter*
1598 inf_session_lookup_user_property(const GParameter* params,
1599                                  guint n_params,
1600                                  const gchar* name)
1601 {
1602   guint i;
1603   g_return_val_if_fail(params != NULL || n_params == 0, NULL);
1604   g_return_val_if_fail(name != NULL, NULL);
1605   for(i = 0; i &lt; n_params; ++ i)
1606     if(strcmp(params[i].name, name) == 0)
1607       return &amp;params[i];
1608   return NULL;
1609 }
1610 GParameter*
1611 inf_session_get_user_property(GArray* array,
1612                               const gchar* name)
1613 {
1614   GParameter* parameter;
1615   guint i;
1616   g_return_val_if_fail(array != NULL, NULL);
1617   g_return_val_if_fail(name != NULL, NULL);
1618   for(i = 0; i &lt; array-&gt;len; ++ i)
1619     if(strcmp(g_array_index(array, GParameter, i).name, name) == 0)
1620       return &amp;g_array_index(array, GParameter, i);
1621   g_array_set_size(array, array-&gt;len + 1);
1622   parameter = &amp;g_array_index(array, GParameter, array-&gt;len - 1);
1623   parameter-&gt;name = name;
1624   memset(&amp;parameter-&gt;value, 0, sizeof(GValue));
1625   return parameter;
1626 }
1627 void
1628 inf_session_user_to_xml(InfSession* session,
1629                         InfUser* user,
1630                         xmlNodePtr xml)
1631 {
1632   InfSessionClass* session_class;
1633   GParamSpec** pspecs;
1634   GParameter* params;
1635   guint n_params;
1636   guint i;
1637   g_return_if_fail(INF_IS_SESSION(session));
1638   g_return_if_fail(INF_IS_USER(user));
1639   g_return_if_fail(xml != NULL);
1640   session_class = INF_SESSION_GET_CLASS(session);
1641   g_return_if_fail(session_class-&gt;set_xml_user_props != NULL);
1642   pspecs = g_object_class_list_properties(
1643     G_OBJECT_CLASS(INF_USER_GET_CLASS(user)),
1644     &amp;n_params
1645   );
1646   params = g_malloc(n_params * sizeof(GParameter));
1647   for(i = 0; i &lt; n_params; ++ i)
1648   {
1649     params[i].name = pspecs[i]-&gt;name;
1650     memset(&amp;params[i].value, 0, sizeof(GValue));
1651     g_value_init(&amp;params[i].value, pspecs[i]-&gt;value_type);
1652     g_object_get_property(G_OBJECT(user), params[i].name, &amp;params[i].value);
1653   }
1654   session_class-&gt;set_xml_user_props(session, params, n_params, xml);
1655   for(i = 0; i &lt; n_params; ++ i)
1656     g_value_unset(&amp;params[i].value);
1657   g_free(params);
1658   g_free(pspecs);
1659 }
1660 void
1661 inf_session_close(InfSession* session)
1662 {
1663   g_return_if_fail(INF_IS_SESSION(session));
1664   g_return_if_fail(inf_session_get_status(session) != INF_SESSION_CLOSED);
1665   g_signal_emit(G_OBJECT(session), session_signals[CLOSE], 0);
1666 }
1667 InfCommunicationManager*
1668 inf_session_get_communication_manager(InfSession* session)
1669 {
1670   g_return_val_if_fail(INF_IS_SESSION(session), NULL);
1671   return INF_SESSION_PRIVATE(session)-&gt;manager;
1672 }
1673 InfBuffer*
1674 inf_session_get_buffer(InfSession* session)
1675 {
1676   g_return_val_if_fail(INF_IS_SESSION(session), NULL);
1677   return INF_SESSION_PRIVATE(session)-&gt;buffer;
1678 }
1679 InfUserTable*
1680 inf_session_get_user_table(InfSession* session)
1681 {
1682   g_return_val_if_fail(INF_IS_SESSION(session), NULL);
1683   return INF_SESSION_PRIVATE(session)-&gt;user_table;
1684 }
1685 InfSessionStatus
1686 inf_session_get_status(InfSession* session)
1687 {
1688   g_return_val_if_fail(INF_IS_SESSION(session), INF_SESSION_CLOSED);
1689   return INF_SESSION_PRIVATE(session)-&gt;status;
1690 }
1691 InfUser*
1692 inf_session_add_user(InfSession* session,
1693                      const GParameter* params,
1694                      guint n_params)
1695 {
1696   InfSessionPrivate* priv;
1697   InfSessionClass* session_class;
1698   InfUser* user;
1699   gboolean result;
1700   g_return_val_if_fail(INF_IS_SESSION(session), NULL);
1701   session_class = INF_SESSION_GET_CLASS(session);
1702   g_return_val_if_fail(session_class-&gt;validate_user_props != NULL, NULL);
1703   g_return_val_if_fail(session_class-&gt;user_new != NULL, NULL);
1704   priv = INF_SESSION_PRIVATE(session);
1705   g_return_val_if_fail(
1706     session_class-&gt;validate_user_props(session, params, n_params, NULL, NULL),
1707     NULL
1708   );
1709   user = session_class-&gt;user_new(
1710     session,
1711     *(GParameter**)(gpointer)&amp;params,
1712     n_params
1713   );
1714   inf_user_table_add_user(priv-&gt;user_table, user);
1715   g_object_unref(user); 
1716   return user;
1717 }
1718 void
1719 inf_session_set_user_status(InfSession* session,
1720                             InfUser* user,
1721                             InfUserStatus status)
1722 {
1723   InfSessionPrivate* priv;
1724   xmlNodePtr xml;
1725   g_return_if_fail(INF_IS_SESSION(session));
1726   g_return_if_fail(INF_IS_USER(user));
1727   g_return_if_fail(inf_session_get_status(session) == INF_SESSION_RUNNING);
1728   g_return_if_fail(inf_user_get_status(user) != INF_USER_UNAVAILABLE);
1729   g_return_if_fail( (inf_user_get_flags(user) &amp; INF_USER_LOCAL) != 0);
1730   priv = INF_SESSION_PRIVATE(session);
1731   if(inf_user_get_status(user) != status)
1732   {
1733     xml = xmlNewNode(NULL, (const xmlChar*)"user-status-change");
1734     inf_xml_util_set_attribute_uint(xml, "id", inf_user_get_id(user));
1735     inf_xml_util_set_attribute(
1736       xml,
1737       "status",
1738       inf_user_status_to_string(status)
1739     );
1740     if(priv-&gt;subscription_group != NULL)
1741       inf_session_send_to_subscriptions(session, xml);
1742     g_object_set(G_OBJECT(user), "status", status, NULL);
1743   }
1744 }
1745 void
1746 inf_session_synchronize_from(InfSession* session)
1747 {
1748   InfSessionPrivate* priv;
1749   InfCommunicationGroup* group;
1750   InfXmlConnection* connection;
1751   g_return_if_fail(inf_session_get_status(session) == INF_SESSION_PRESYNC);
1752   priv = INF_SESSION_PRIVATE(session);
1753   g_return_if_fail(priv-&gt;shared.presync.closing == FALSE);
1754   group = priv-&gt;shared.presync.group;
1755   connection = priv-&gt;shared.presync.conn;
1756   priv-&gt;status = INF_SESSION_SYNCHRONIZING;
1757   priv-&gt;shared.sync.group = group;
1758   priv-&gt;shared.sync.conn = connection;
1759   priv-&gt;shared.sync.messages_total = 0;
1760   priv-&gt;shared.sync.messages_received = 0;
1761   priv-&gt;shared.sync.closing = FALSE;
1762   g_object_notify(G_OBJECT(session), "status");
1763 }
1764 void
1765 inf_session_synchronize_to(InfSession* session,
1766                            InfCommunicationGroup* group,
1767                            InfXmlConnection* connection)
1768 {
1769   g_return_if_fail(INF_IS_SESSION(session));
1770   g_return_if_fail(group != NULL);
1771   g_return_if_fail(INF_IS_XML_CONNECTION(connection));
1772   g_return_if_fail(inf_session_get_status(session) == INF_SESSION_RUNNING);
1773   g_return_if_fail(
1774     inf_session_find_sync_by_connection(session, connection) == NULL
1775   );
1776   g_signal_emit(
1777     G_OBJECT(session),
1778     session_signals[SYNCHRONIZATION_BEGIN],
1779     0,
1780     group,
1781     connection
1782   );
1783 }
1784 void
1785 inf_session_cancel_synchronization(InfSession* session,
1786                                    InfXmlConnection* connection)
1787 {
1788   InfSessionPrivate* priv;
1789   InfXmlConnectionStatus status;
1790   InfSessionSync* sync;
1791   xmlNodePtr xml;
1792   GError* error;
1793   g_return_if_fail(INF_IS_SESSION(session));
1794   g_return_if_fail(INF_IS_XML_CONNECTION(connection));
1795   priv = INF_SESSION_PRIVATE(session);
1796   error = NULL;
1797   switch(priv-&gt;status)
1798   {
1799   case INF_SESSION_PRESYNC:
1800     g_return_if_fail(connection == priv-&gt;shared.presync.conn);
1801     g_set_error_literal(
1802       &amp;error,
1803       inf_session_sync_error_quark,
1804       INF_SESSION_SYNC_ERROR_RECEIVER_CANCELLED,
1805       inf_session_sync_strerror(INF_SESSION_SYNC_ERROR_RECEIVER_CANCELLED)
1806     );
1807     break;
1808   case INF_SESSION_SYNCHRONIZING:
1809     g_return_if_fail(connection == priv-&gt;shared.sync.conn);
1810     g_set_error_literal(
1811       &amp;error,
1812       inf_session_sync_error_quark,
1813       INF_SESSION_SYNC_ERROR_RECEIVER_CANCELLED,
1814       inf_session_sync_strerror(INF_SESSION_SYNC_ERROR_RECEIVER_CANCELLED)
1815     );
1816     g_object_get(G_OBJECT(connection), "status", &amp;status, NULL);
1817     if(status == INF_XML_CONNECTION_OPEN)
1818       inf_session_send_sync_error(session, error);
1819     break;
1820   case INF_SESSION_RUNNING:
1821     sync = inf_session_find_sync_by_connection(session, connection);
1822     g_return_if_fail(sync != NULL);
1823     if(sync-&gt;status == INF_SESSION_SYNC_IN_PROGRESS)
1824     {
1825       inf_communication_group_cancel_messages(sync-&gt;group, sync-&gt;conn);
1826       xml = xmlNewNode(NULL, (const xmlChar*)"sync-cancel");
1827       inf_communication_group_send_message(sync-&gt;group, sync-&gt;conn, xml);
1828     }
1829     g_set_error_literal(
1830       &amp;error,
1831       inf_session_sync_error_quark,
1832       INF_SESSION_SYNC_ERROR_SENDER_CANCELLED,
1833       inf_session_sync_strerror(INF_SESSION_SYNC_ERROR_SENDER_CANCELLED)
1834     );
1835     break;
1836   case INF_SESSION_CLOSED:
1837     g_return_if_reached();
1838     break;
1839   default:
1840     g_assert_not_reached();
1841     break;
1842   }
1843   g_signal_emit(
1844     G_OBJECT(session),
1845     session_signals[SYNCHRONIZATION_FAILED],
1846     0,
1847     connection,
1848     error
1849   );
1850   g_error_free(error);
1851 }
1852 InfSessionSyncStatus
1853 inf_session_get_synchronization_status(InfSession* session,
1854                                        InfXmlConnection* connection)
1855 {
1856   InfSessionPrivate* priv;
1857   InfSessionSync* sync;
1858   g_return_val_if_fail(INF_IS_SESSION(session), INF_SESSION_SYNC_NONE);
1859   g_return_val_if_fail(
1860     INF_IS_XML_CONNECTION(connection),
1861     INF_SESSION_SYNC_NONE
1862   );
1863   priv = INF_SESSION_PRIVATE(session);
1864   switch(priv-&gt;status)
1865   {
1866   case INF_SESSION_SYNCHRONIZING:
1867     if(connection == priv-&gt;shared.sync.conn)
1868       return INF_SESSION_SYNC_IN_PROGRESS;
1869     return INF_SESSION_SYNC_NONE;
1870   case INF_SESSION_RUNNING:
1871     sync = inf_session_find_sync_by_connection(session, connection);
1872     if(sync == NULL) return INF_SESSION_SYNC_NONE;
1873     return sync-&gt;status;
1874   case INF_SESSION_CLOSED:
1875     return INF_SESSION_SYNC_NONE;
1876   default:
1877     g_assert_not_reached();
1878     break;
1879   }
1880 }
1881 gdouble
1882 inf_session_get_synchronization_progress(InfSession* session,
1883                                          InfXmlConnection* connection)
1884 {
1885   InfSessionPrivate* priv;
1886   InfSessionSync* sync;
1887   g_return_val_if_fail(INF_IS_SESSION(session), 0.0);
1888   g_return_val_if_fail(INF_IS_XML_CONNECTION(connection), 0.0);
1889   g_return_val_if_fail(
1890     inf_session_get_synchronization_status(
1891       session,
1892       connection
1893     ) != INF_SESSION_SYNC_NONE,
1894     0.0
1895   );
1896   priv = INF_SESSION_PRIVATE(session);
1897   switch(priv-&gt;status)
1898   {
1899   case INF_SESSION_PRESYNC:
1900     g_assert(connection == priv-&gt;shared.presync.conn);
1901     return 0.0;
1902   case INF_SESSION_SYNCHRONIZING:
1903     g_assert(connection == priv-&gt;shared.sync.conn);
1904     if(priv-&gt;shared.sync.messages_total == 0)
1905       return 0.0;
1906     return (gdouble)priv-&gt;shared.sync.messages_received /
1907            (gdouble)priv-&gt;shared.sync.messages_total;
1908   case INF_SESSION_RUNNING:
1909     sync = inf_session_find_sync_by_connection(session, connection);
1910     g_assert(sync != NULL);
1911     return (gdouble)sync-&gt;messages_sent / (gdouble)sync-&gt;messages_total;
1912   case INF_SESSION_CLOSED:
1913   default:
1914     g_assert_not_reached();
1915     return 0.0;
1916   }
1917 }
1918 gboolean
1919 inf_session_has_synchronizations(InfSession* session)
1920 {
1921   InfSessionPrivate* priv;
1922   g_return_val_if_fail(INF_IS_SESSION(session), FALSE);
1923   priv = INF_SESSION_PRIVATE(session);
1924   switch(priv-&gt;status)
1925   {
1926   case INF_SESSION_PRESYNC:
1927   case INF_SESSION_SYNCHRONIZING:
1928     return TRUE;
1929   case INF_SESSION_RUNNING:
1930     if(priv-&gt;shared.run.syncs == NULL)
1931       return FALSE;
1932     else
1933       return TRUE;
1934   case INF_SESSION_CLOSED:
1935     return FALSE;
1936   default:
1937     g_assert_not_reached();
1938     return FALSE;
1939   }
1940 }
1941 InfCommunicationGroup*
1942 inf_session_get_subscription_group(InfSession* session)
1943 {
1944   g_return_val_if_fail(INF_IS_SESSION(session), NULL);
1945   return INF_SESSION_PRIVATE(session)-&gt;subscription_group;
1946 }
1947 void
1948 inf_session_set_subscription_group(InfSession* session,
1949                                    InfCommunicationGroup* group)
1950 {
1951   InfSessionPrivate* priv;
1952   g_return_if_fail(INF_IS_SESSION(session));
1953   priv = INF_SESSION_PRIVATE(session);
1954   if(priv-&gt;subscription_group != group)
1955   {
1956     if(priv-&gt;subscription_group != NULL)
1957       g_object_unref(priv-&gt;subscription_group);
1958     priv-&gt;subscription_group = group;
1959     if(group != NULL)
1960       g_object_ref(group);
1961     g_object_notify(G_OBJECT(session), "subscription-group");
1962   }
1963 }
1964 void
1965 inf_session_send_to_subscriptions(InfSession* session,
1966                                   xmlNodePtr xml)
1967 {
1968   InfSessionPrivate* priv;
1969   g_return_if_fail(INF_IS_SESSION(session));
1970   g_return_if_fail(xml != NULL);
1971   priv = INF_SESSION_PRIVATE(session);
1972   g_return_if_fail(priv-&gt;subscription_group != NULL);
1973   inf_communication_group_send_group_message(priv-&gt;subscription_group, xml);
1974 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
