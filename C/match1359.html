<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-chat-buffer.c &amp; inf-session.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-chat-buffer.c &amp; inf-session.c
      </h3>
<h1 align="center">
        8.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-chat-buffer.c (19.551283%)<th>inf-session.c (5.058043%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(361-388)<td><a href="#" name="0">(657-686)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(36-58)<td><a href="#" name="1">(74-96)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(69-105)<td><a href="#" name="2">(139-180)</a><td align="center"><font color="#e10000">15</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(335-356)<td><a href="#" name="3">(544-564)</a><td align="center"><font color="#b40000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-chat-buffer.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinfinity/common/inf-chat-buffer.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-define-enum.h&gt;
<a name="1"></a>
#include &lt;string.h&gt;
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static const GEnumValue inf_chat_buffer_message_type_values[] = {
  {
    INF_CHAT_BUFFER_MESSAGE_NORMAL,
    "INF_CHAT_BUFFER_MESSAGE_NORMAL",
    "normal"
  }, {
    INF_CHAT_BUFFER_MESSAGE_EMOTE,
    "INF_CHAT_BUFFER_MESSAGE_EMOTE",
    "emote"
  }, {
    INF_CHAT_BUFFER_MESSAGE_USERJOIN,
    "INF_CHAT_BUFFER_MESSAGE_USERJOIN",
    "userjoin"
  }, {
    INF_CHAT_BUFFER_MESSAGE_USERPART,
    "INF_CHAT_BUFFER_MESSAGE_USERPART",
    "userpart"
  }, {
    0,
    NULL,
    NULL
  }
};</b></font>
static const GFlagsValue inf_chat_buffer_message_flags_values[] = {
  {
    INF_CHAT_BUFFER_MESSAGE_BACKLOG,
    "INF_CHAT_BUFFER_MESSAGE_BACKLOG",
    "backlog"
  }, {
<a name="2"></a>    0,
    NULL,
    NULL
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  }
};
typedef struct _InfChatBufferPrivate InfChatBufferPrivate;
struct _InfChatBufferPrivate {
  InfChatBufferMessage* messages;
  guint alloc_messages;
  guint num_messages;
  guint first_message;
  guint size;
  gboolean modified;
};
enum {
  PROP_0,
  PROP_SIZE,
  PROP_MODIFIED
};
enum {
  ADD_MESSAGE,
  LAST_SIGNAL
};
#define INF_CHAT_BUFFER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_CHAT_BUFFER, InfChatBufferPrivate))
static guint chat_buffer_signals[LAST_SIGNAL];
static void inf_chat_buffer_buffer_iface_init(InfBufferInterface* iface);</b></font>
INF_DEFINE_ENUM_TYPE(InfChatBufferMessageType, inf_chat_buffer_message_type, inf_chat_buffer_message_type_values)
INF_DEFINE_FLAGS_TYPE(InfChatBufferMessageFlags, inf_chat_buffer_message_flags, inf_chat_buffer_message_flags_values)
G_DEFINE_BOXED_TYPE(InfChatBufferMessage, inf_chat_buffer_message, inf_chat_buffer_message_copy, inf_chat_buffer_message_free)
G_DEFINE_TYPE_WITH_CODE(InfChatBuffer, inf_chat_buffer, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfChatBuffer)
  G_IMPLEMENT_INTERFACE(INF_TYPE_BUFFER, inf_chat_buffer_buffer_iface_init))
static InfChatBufferMessage*
inf_chat_buffer_reserve_message(InfChatBuffer* buffer,
                                time_t time)
{
  InfChatBufferPrivate* priv;
  InfChatBufferMessage* message;
  guint begin;
  guint end;
  guint n;
  priv = INF_CHAT_BUFFER_PRIVATE(buffer);
  begin = 0;
  end = priv-&gt;num_messages;
  while(begin != end)
  {
    n = (begin + end) / 2;
    message = &amp;priv-&gt;messages[(priv-&gt;first_message + n) % priv-&gt;size];
    if(message-&gt;time &lt;= time)
      begin = (begin + end + 1)/2;
    else
      end = (begin + end)/2;
  } while(begin != end);
  n = begin;
  if(n == 0 &amp;&amp; priv-&gt;num_messages == priv-&gt;size)
    return NULL;
  if(priv-&gt;num_messages &lt; priv-&gt;size)
  {
    g_assert(priv-&gt;first_message + priv-&gt;num_messages &lt;= priv-&gt;alloc_messages);
    if(priv-&gt;num_messages == priv-&gt;alloc_messages)
    {
      priv-&gt;alloc_messages = MAX(priv-&gt;alloc_messages * 2, 16);
      priv-&gt;alloc_messages = MIN(priv-&gt;alloc_messages, priv-&gt;size);
      g_assert(priv-&gt;alloc_messages &gt; priv-&gt;num_messages);
      priv-&gt;messages = g_realloc(
        priv-&gt;messages,
        priv-&gt;alloc_messages * sizeof(InfChatBufferMessage)
      );
    }
    if(n == 0 &amp;&amp; priv-&gt;first_message == 0)
    {
      end = (priv-&gt;alloc_messages - priv-&gt;num_messages + 1) / 2;
      g_assert(end &gt; 0);
      memmove(
        priv-&gt;messages + end,
        priv-&gt;messages         priv-&gt;num_messages * sizeof(InfChatBufferMessage)
      );
      priv-&gt;first_message = end - 1;
    }
    else if(n == priv-&gt;num_messages &amp;&amp;
            priv-&gt;first_message + priv-&gt;num_messages == priv-&gt;alloc_messages)
    {
      end = (priv-&gt;alloc_messages - priv-&gt;num_messages) / 2;
      g_assert(end + priv-&gt;num_messages &lt; priv-&gt;alloc_messages);
      memmove(
        priv-&gt;messages + end,
        priv-&gt;messages + priv-&gt;first_message,
        priv-&gt;num_messages * sizeof(InfChatBufferMessage)
      );
      priv-&gt;first_message = end;
    }
    else if(n &gt; 0 &amp;&amp; n &lt; priv-&gt;num_messages)
    {
      if((n &lt; priv-&gt;num_messages / 2 &amp;&amp;
          priv-&gt;first_message &gt; 0) ||
         (n &gt; priv-&gt;num_messages / 2 &amp;&amp;
          priv-&gt;first_message + priv-&gt;num_messages == priv-&gt;alloc_messages))
      {
        begin = priv-&gt;first_message;
        memmove(
          priv-&gt;messages + begin - 1,
          priv-&gt;messages + begin,
          (n + 1) * sizeof(InfChatBufferMessage)
        );
        --priv-&gt;first_message;
      }
      else
      {
        memmove(
          priv-&gt;messages + n + 1,
          priv-&gt;messages + n,
          (priv-&gt;num_messages - n) * sizeof(InfChatBufferMessage)
        );
      }
    }
    else
    {
      g_assert(n == 0 || n == priv-&gt;num_messages);
      if(n == 0)
      {
        g_assert(priv-&gt;first_message &gt; 0);
        --priv-&gt;first_message;
      }
      else
      {
        g_assert(priv-&gt;first_message + priv-&gt;num_messages &lt;
                 priv-&gt;alloc_messages);
      }
    }
    ++ priv-&gt;num_messages;
  }
  else
  {
    g_assert(n &gt; 0); 
    begin = priv-&gt;first_message;
    end = (priv-&gt;first_message + n) % priv-&gt;size;
    if(n == priv-&gt;num_messages)
    {
      g_free(priv-&gt;messages[priv-&gt;first_message].text);
      priv-&gt;first_message = (priv-&gt;first_message + 1) % priv-&gt;size;
    }
    else
    {
      g_free(priv-&gt;messages[end].text);
      if(begin &lt; end)
      {
        memmove(
          priv-&gt;messages + begin + 1,
          priv-&gt;messages + begin,
          (end - begin) * sizeof(InfChatBufferMessage)
        );
      }
      else
      {
        memmove(
          priv-&gt;messages + end + 1,
          priv-&gt;messages + end,
          (begin - end) * sizeof(InfChatBufferMessage)
        );
        priv-&gt;first_message = (priv-&gt;first_message + 1) % priv-&gt;size;
      }
    }
    --n;
  }
  return &amp;priv-&gt;messages[(priv-&gt;first_message + n) % priv-&gt;size];
}
static void
inf_chat_buffer_init(InfChatBuffer* buffer)
{
  InfChatBufferPrivate* priv;
  priv = INF_CHAT_BUFFER_PRIVATE(buffer);
  priv-&gt;messages = NULL;
  priv-&gt;alloc_messages = 0;
  priv-&gt;num_messages = 0;
  priv-&gt;first_message = 0;
  priv-&gt;size = 256;
  priv-&gt;modified = FALSE;
}
static void
inf_chat_buffer_finalize(GObject* object)
{
  InfChatBuffer* buffer;
  InfChatBufferPrivate* priv;
  guint i;
  buffer = INF_CHAT_BUFFER(object);
  priv = INF_CHAT_BUFFER_PRIVATE(buffer);
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  for(i = 0; i &lt; priv-&gt;num_messages; ++i)
    g_free(priv-&gt;messages[(priv-&gt;first_message + i) % priv-&gt;size].text);
  g_free(priv-&gt;messages);
  G_OBJECT_CLASS(inf_chat_buffer_parent_class)-&gt;finalize(object);
}
static void
inf_chat_buffer_set_property(GObject* object,
                             guint prop_id,
                             const GValue* value,
                             GParamSpec* pspec)
{
  InfChatBuffer* session;
  InfChatBufferPrivate* priv;
  session = INF_CHAT_BUFFER(object);
  priv = INF_CHAT_BUFFER_PRIVATE(session);
  switch(prop_id)
  {
  case PROP_SIZE:</b></font>
    g_assert(priv-&gt;num_messages == 0); <a name="0"></a>    priv-&gt;size = g_value_get_uint(value);
    break;
  case PROP_MODIFIED:
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    priv-&gt;modified = g_value_get_boolean(value);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_chat_buffer_get_property(GObject* object,
                             guint prop_id,
                             GValue* value,
                             GParamSpec* pspec)
{
  InfChatBuffer* session;
  InfChatBufferPrivate* priv;
  session = INF_CHAT_BUFFER(object);
  priv = INF_CHAT_BUFFER_PRIVATE(session);
  switch(prop_id)
  {
  case PROP_SIZE:
    g_value_set_uint(value, priv-&gt;size);
    break;
  case PROP_MODIFIED:
    g_value_set_boolean(value, priv-&gt;modified);
    break;</b></font>
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_chat_buffer_add_message_handler(InfChatBuffer* buffer,
                                    const InfChatBufferMessage* message)
{
  InfChatBufferPrivate* priv;
  InfChatBufferMessage* new_message;
  priv = INF_CHAT_BUFFER_PRIVATE(buffer);
  new_message = inf_chat_buffer_reserve_message(buffer, message-&gt;time);
  if(new_message != NULL)
  {
    new_message-&gt;type = message-&gt;type;
    new_message-&gt;user = message-&gt;user;
    new_message-&gt;text = g_strndup(message-&gt;text, message-&gt;length);
    new_message-&gt;length = message-&gt;length;
    new_message-&gt;time = message-&gt;time;
    new_message-&gt;flags = message-&gt;flags;
  }
}
static gboolean
inf_chat_buffer_buffer_get_modified(InfBuffer* buffer)
{
  return INF_CHAT_BUFFER_PRIVATE(buffer)-&gt;modified;
}
static void
inf_chat_buffer_buffer_set_modified(InfBuffer* buffer,
                                    gboolean modified)
{
  InfChatBuffer* chat_buffer;
  InfChatBufferPrivate* priv;
  chat_buffer = INF_CHAT_BUFFER(buffer);
  priv = INF_CHAT_BUFFER_PRIVATE(chat_buffer);
  if(priv-&gt;modified != modified)
  {
    priv-&gt;modified = modified;
    g_object_notify(G_OBJECT(buffer), "modified");
  }
}
static void
inf_chat_buffer_class_init(InfChatBufferClass* buffer_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(buffer_class);
  object_class-&gt;finalize = inf_chat_buffer_finalize;
  object_class-&gt;set_property = inf_chat_buffer_set_property;
  object_class-&gt;get_property = inf_chat_buffer_get_property;
  buffer_class-&gt;add_message = inf_chat_buffer_add_message_handler;
  g_object_class_install_property(
    object_class,
    PROP_SIZE,
    g_param_spec_uint(
      "size",
      "size",
      "The maxmimum number of messages saved",
      0,
      G_MAXUINT,
      256,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_override_property(object_class, PROP_MODIFIED, "modified");
  chat_buffer_signals[ADD_MESSAGE] = g_signal_new(
    "add-message",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfChatBufferClass, add_message),
    NULL, NULL,
    g_cclosure_marshal_VOID__BOXED,
    G_TYPE_NONE,
    1,
    INF_TYPE_CHAT_BUFFER_MESSAGE | G_SIGNAL_TYPE_STATIC_SCOPE
  );
}
static void
inf_chat_buffer_buffer_iface_init(InfBufferInterface* iface)
{
  iface-&gt;get_modified = inf_chat_buffer_buffer_get_modified;
  iface-&gt;set_modified = inf_chat_buffer_buffer_set_modified;
}
InfChatBufferMessage*
inf_chat_buffer_message_copy(const InfChatBufferMessage* message)
{
  InfChatBufferMessage* new_message;
  g_return_val_if_fail(message != NULL, NULL);
  new_message = g_slice_new(InfChatBufferMessage);
  new_message-&gt;type = message-&gt;type;
  new_message-&gt;user = message-&gt;user;
  new_message-&gt;text = g_strndup(message-&gt;text, message-&gt;length);
  new_message-&gt;length = message-&gt;length;
  new_message-&gt;time = message-&gt;time;
  new_message-&gt;flags = message-&gt;flags;
  return new_message;
}
void
inf_chat_buffer_message_free(InfChatBufferMessage* message)
{
  g_return_if_fail(message != NULL);
  g_free(message-&gt;text);
  g_slice_free(InfChatBufferMessage, message);
}
InfChatBuffer*
inf_chat_buffer_new(guint size)
{
  return g_object_new(
    INF_TYPE_CHAT_BUFFER,
    "size", size,
    NULL
  );
}
void
inf_chat_buffer_add_message(InfChatBuffer* buffer,
                            InfUser* by,
                            const gchar* message,
                            gsize length,
                            time_t time,
                            InfChatBufferMessageFlags flags)
{
  InfChatBufferMessage msg;
  g_return_if_fail(INF_IS_CHAT_BUFFER(buffer));
  g_return_if_fail(INF_IS_USER(by));
  g_return_if_fail(message != NULL);
  msg.type = INF_CHAT_BUFFER_MESSAGE_NORMAL;
  msg.user = by;
  msg.text = *(gchar**) (gpointer) &amp;message;
  msg.length = length;
  msg.time = time;
  msg.flags = flags;
  g_signal_emit(buffer, chat_buffer_signals[ADD_MESSAGE], 0, &amp;msg);
}
void
inf_chat_buffer_add_emote_message(InfChatBuffer* buffer,
                                  InfUser* by,
                                  const gchar* message,
                                  gsize length,
                                  time_t time,
                                  InfChatBufferMessageFlags flags)
{
  InfChatBufferMessage msg;
  g_return_if_fail(INF_IS_CHAT_BUFFER(buffer));
  g_return_if_fail(INF_IS_USER(by));
  g_return_if_fail(message != NULL);
  msg.type = INF_CHAT_BUFFER_MESSAGE_EMOTE;
  msg.user = by;
  msg.text = *(gchar**) (gpointer) &amp;message;
  msg.length = length;
  msg.time = time;
  msg.flags = flags;
  g_signal_emit(buffer, chat_buffer_signals[ADD_MESSAGE], 0, &amp;msg);
}
void
inf_chat_buffer_add_userjoin_message(InfChatBuffer* buffer,
                                     InfUser* user,
                                     time_t time,
                                     InfChatBufferMessageFlags flags)
{
  InfChatBufferMessage msg;
  g_return_if_fail(INF_IS_CHAT_BUFFER(buffer));
  g_return_if_fail(INF_IS_USER(user));
  msg.type = INF_CHAT_BUFFER_MESSAGE_USERJOIN;
  msg.user = user;
  msg.text = NULL;
  msg.length = 0;
  msg.time = time;
  msg.flags = flags;
  g_signal_emit(buffer, chat_buffer_signals[ADD_MESSAGE], 0, &amp;msg);
}
void
inf_chat_buffer_add_userpart_message(InfChatBuffer* buffer,
                                     InfUser* user,
                                     time_t time,
                                     InfChatBufferMessageFlags flags)
{
  InfChatBufferMessage msg;
  g_return_if_fail(INF_IS_CHAT_BUFFER(buffer));
  g_return_if_fail(INF_IS_USER(user));
  msg.type = INF_CHAT_BUFFER_MESSAGE_USERPART;
  msg.user = user;
  msg.text = NULL;
  msg.length = 0;
  msg.time = time;
  msg.flags = flags;
  g_signal_emit(buffer, chat_buffer_signals[ADD_MESSAGE], 0, &amp;msg);
}
const InfChatBufferMessage*
inf_chat_buffer_get_message(InfChatBuffer* buffer,
                            guint n)
{
  InfChatBufferPrivate* priv;
  g_return_val_if_fail(INF_IS_CHAT_BUFFER(buffer), NULL);
  g_return_val_if_fail(n &lt; inf_chat_buffer_get_n_messages(buffer), NULL);
  priv = INF_CHAT_BUFFER_PRIVATE(buffer);
  return &amp;priv-&gt;messages[
    (priv-&gt;first_message + n) % priv-&gt;size
  ];
}
guint
inf_chat_buffer_get_n_messages(InfChatBuffer* buffer)
{
  g_return_val_if_fail(INF_IS_CHAT_BUFFER(buffer), 0);
  return INF_CHAT_BUFFER_PRIVATE(buffer)-&gt;num_messages;
}
guint
inf_chat_buffer_get_size(InfChatBuffer* buffer)
{
  g_return_val_if_fail(INF_IS_CHAT_BUFFER(buffer), 0);
  return INF_CHAT_BUFFER_PRIVATE(buffer)-&gt;size;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-session.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinfinity/common/inf-session.h&gt;
#include &lt;libinfinity/common/inf-buffer.h&gt;
#include &lt;libinfinity/common/inf-xml-util.h&gt;
#include &lt;libinfinity/common/inf-error.h&gt;
#include &lt;libinfinity/communication/inf-communication-object.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
#include &lt;libinfinity/inf-define-enum.h&gt;
#include &lt;string.h&gt;
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static const GEnumValue inf_session_status_values[] = {
  {
    INF_SESSION_PRESYNC,
    "INF_SESSION_PRESYNC",
    "presync"
  }, {
    INF_SESSION_SYNCHRONIZING,
    "INF_SESSION_SYNCHRONIZING",
    "synchronizing"
  }, {
    INF_SESSION_RUNNING,
    "INF_SESSION_RUNNING",
    "running"
  }, {
    INF_SESSION_CLOSED,
    "INF_SESSION_CLOSED",
    "closed"
  }, {
    0,
    NULL,
    NULL
  }
};</b></font>
typedef struct _InfSessionSync InfSessionSync;
struct _InfSessionSync {
  InfCommunicationGroup* group;
  InfXmlConnection* conn;
  guint messages_total;
  guint messages_sent;
  InfSessionSyncStatus status;
};
typedef struct _InfSessionPrivate InfSessionPrivate;
struct _InfSessionPrivate {
  InfCommunicationManager* manager;
  InfBuffer* buffer;
  InfUserTable* user_table;
  InfSessionStatus status;
  InfCommunicationGroup* subscription_group;
  union {
    struct {
      InfCommunicationGroup* group;
      InfXmlConnection* conn;
      gboolean closing;
    } presync;
    struct {
      InfCommunicationGroup* group;
      InfXmlConnection* conn;
      guint messages_total;
      guint messages_received;
      gboolean closing;
    } sync;
<a name="2"></a>    struct {
      GSList* syncs;
    } run;
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  } shared;
};
typedef struct _InfSessionXmlData InfSessionXmlData;
struct _InfSessionXmlData {
  InfSession* session;
  xmlNodePtr xml;
};
enum {
  PROP_0,
  PROP_COMMUNICATION_MANAGER,
  PROP_BUFFER,
  PROP_USER_TABLE,
  PROP_STATUS,
  PROP_SYNC_CONNECTION,
  PROP_SYNC_GROUP,
  PROP_SUBSCRIPTION_GROUP
};
enum {
  CLOSE,
  ERROR,
  SYNCHRONIZATION_BEGIN,
  SYNCHRONIZATION_PROGRESS,
  SYNCHRONIZATION_COMPLETE,
  SYNCHRONIZATION_FAILED,
  LAST_SIGNAL
};
#define INF_SESSION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_SESSION, InfSessionPrivate))
static guint session_signals[LAST_SIGNAL];
static GQuark inf_session_sync_error_quark;</b></font>
static void inf_session_communication_object_iface_init(InfCommunicationObjectInterface* iface);
INF_DEFINE_ENUM_TYPE(InfSessionStatus, inf_session_status, inf_session_status_values)
G_DEFINE_TYPE_WITH_CODE(InfSession, inf_session, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfSession)
  G_IMPLEMENT_INTERFACE(INF_COMMUNICATION_TYPE_OBJECT, inf_session_communication_object_iface_init))
static const gchar*
inf_session_sync_strerror(InfSessionSyncError errcode)
{
  switch(errcode)
  {
  case INF_SESSION_SYNC_ERROR_GOT_MESSAGE_IN_PRESYNC:
    return _("Unexpectedly got an XML message in presync");
  case INF_SESSION_SYNC_ERROR_UNEXPECTED_NODE:
    return _("Got unexpected XML node during synchronization");
  case INF_SESSION_SYNC_ERROR_ID_NOT_PRESENT:
    return _("'id' attribute in user message is missing");
  case INF_SESSION_SYNC_ERROR_ID_IN_USE:
    return _("User ID is already in use");
  case INF_SESSION_SYNC_ERROR_NAME_NOT_PRESENT:
    return _("'name' attribute in user message is missing");
  case INF_SESSION_SYNC_ERROR_NAME_IN_USE:
    return _("User Name is already in use");
  case INF_SESSION_SYNC_ERROR_CONNECTION_CLOSED:
    return _("The connection was closed unexpectedly");
  case INF_SESSION_SYNC_ERROR_SENDER_CANCELLED:
    return _("The sender cancelled the synchronization");
  case INF_SESSION_SYNC_ERROR_RECEIVER_CANCELLED:
    return _("The receiver cancelled the synchronization");
  case INF_SESSION_SYNC_ERROR_UNEXPECTED_BEGIN_OF_SYNC:
    return _("Got begin-of-sync message, but synchronization is already "
             "in progress");
  case INF_SESSION_SYNC_ERROR_NUM_MESSAGES_MISSING:
    return _("begin-of-sync message does not contain the number of messages "
             "to expect");
  case INF_SESSION_SYNC_ERROR_UNEXPECTED_END_OF_SYNC:
    return _("Got end-of-sync message, but synchronization is still in "
             "progress");
  case INF_SESSION_SYNC_ERROR_EXPECTED_BEGIN_OF_SYNC:
    return _("Expected begin-of-sync message as first message during "
             "synchronization");
  case INF_SESSION_SYNC_ERROR_EXPECTED_END_OF_SYNC:
    return _("Expected end-of-sync message as last message during "
             "synchronization");
  case INF_SESSION_SYNC_ERROR_FAILED:
    return _("An unknown synchronization error has occurred");
  default:
    return _("An error with unknown error code occurred");
  }
}
static const gchar*
inf_session_get_sync_error_message(GQuark domain,
                                   guint code)
{
  if(domain == inf_session_sync_error_quark)
    return inf_session_sync_strerror(code);
  return _("An error with unknown error domain occurred");
}
static GSList*
inf_session_find_sync_item_by_connection(InfSession* session,
                                         InfXmlConnection* conn)
{
  InfSessionPrivate* priv;
  GSList* item;
  priv = INF_SESSION_PRIVATE(session);
  g_return_val_if_fail(priv-&gt;status == INF_SESSION_RUNNING, NULL);
  for(item = priv-&gt;shared.run.syncs; item != NULL; item = g_slist_next(item))
  {
    if( ((InfSessionSync*)item-&gt;data)-&gt;conn == conn)
      return item;
  }
  return NULL;
}
static InfSessionSync*
inf_session_find_sync_by_connection(InfSession* session,
                                    InfXmlConnection* conn)
{
  GSList* item;
  item = inf_session_find_sync_item_by_connection(session, conn);
  if(item == NULL) return NULL;
  return (InfSessionSync*)item-&gt;data;
}
static void
inf_session_connection_notify_status_cb(InfXmlConnection* connection,
                                        GParamSpec* pspec,
                                        gpointer user_data);
static void
inf_session_release_connection(InfSession* session,
                               InfXmlConnection* connection)
{
  InfSessionPrivate* priv;
  InfSessionSync* sync;
  GSList* item;
  priv = INF_SESSION_PRIVATE(session);
  switch(priv-&gt;status)
  {
  case INF_SESSION_PRESYNC:
    g_assert(priv-&gt;shared.presync.conn == connection);
    g_assert(priv-&gt;shared.presync.group != NULL);
    g_object_unref(priv-&gt;shared.presync.group);
    priv-&gt;shared.presync.conn = NULL;
    priv-&gt;shared.presync.group = NULL;
    break;
  case INF_SESSION_SYNCHRONIZING:
    g_assert(priv-&gt;shared.sync.conn == connection);
    g_assert(priv-&gt;shared.sync.group != NULL);
    g_object_unref(priv-&gt;shared.sync.group);
    priv-&gt;shared.sync.conn = NULL;
    priv-&gt;shared.sync.group = NULL;
    break;
  case INF_SESSION_RUNNING:
    item = inf_session_find_sync_item_by_connection(session, connection);
    g_assert(item != NULL);
    sync = item-&gt;data;
    g_object_unref(sync-&gt;group);
    g_slice_free(InfSessionSync, sync);
    priv-&gt;shared.run.syncs = g_slist_delete_link(
      priv-&gt;shared.run.syncs,
      item
    );
    break;
  case INF_SESSION_CLOSED:
  default:
    g_assert_not_reached();
    break;
  }
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(connection),
    G_CALLBACK(inf_session_connection_notify_status_cb),
    session
  );
  g_object_unref(connection);
}
static void
inf_session_send_sync_error(InfSession* session,
                            GError* error)
{
  InfSessionPrivate* priv;
  xmlNodePtr node;
  priv = INF_SESSION_PRIVATE(session);
  g_return_if_fail(priv-&gt;status == INF_SESSION_SYNCHRONIZING);
  g_return_if_fail(priv-&gt;shared.sync.conn != NULL);
  node = inf_xml_util_new_node_from_error(error, NULL, "sync-error");
  inf_communication_group_send_message(
    priv-&gt;shared.sync.group,
    priv-&gt;shared.sync.conn,
    node
  );
}
static void
inf_session_connection_notify_status_cb(InfXmlConnection* connection,
                                        GParamSpec* pspec,
                                        gpointer user_data)
{
  InfSession* session;
  InfSessionPrivate* priv;
  InfXmlConnectionStatus status;
  GError* error;
  session = INF_SESSION(user_data);
  priv = INF_SESSION_PRIVATE(session);
  error = NULL;
  g_object_get(G_OBJECT(connection), "status", &amp;status, NULL);
  if(status == INF_XML_CONNECTION_CLOSED ||
     status == INF_XML_CONNECTION_CLOSING)
  {
    g_set_error_literal(
      &amp;error,
      inf_session_sync_error_quark,
      INF_SESSION_SYNC_ERROR_CONNECTION_CLOSED,
      inf_session_sync_strerror(INF_SESSION_SYNC_ERROR_CONNECTION_CLOSED)
    );
    switch(priv-&gt;status)
    {
    case INF_SESSION_PRESYNC:
      g_assert(connection == priv-&gt;shared.presync.conn);
      g_signal_emit(
        G_OBJECT(session),
        session_signals[SYNCHRONIZATION_FAILED],
        0,
        connection,
        error
      );
      break;
    case INF_SESSION_SYNCHRONIZING:
      g_assert(connection == priv-&gt;shared.sync.conn);
      g_signal_emit(
        G_OBJECT(session),
        session_signals[SYNCHRONIZATION_FAILED],
        0,
        connection,
        error
      );
      break;
    case INF_SESSION_RUNNING:
      g_assert(
        inf_session_find_sync_by_connection(session, connection) != NULL
      );
      g_signal_emit(
        G_OBJECT(session),
        session_signals[SYNCHRONIZATION_FAILED],
        0,
        connection,
        error
      );
      break;
    case INF_SESSION_CLOSED:
    default:
      g_assert_not_reached();
      break;
    }
    g_error_free(error);
  }
}
static void
inf_session_init(InfSession* session)
{
  InfSessionPrivate* priv;
  priv = INF_SESSION_PRIVATE(session);
  priv-&gt;manager = NULL;
  priv-&gt;buffer = NULL;
  priv-&gt;user_table = NULL;
  priv-&gt;status = INF_SESSION_RUNNING;
  priv-&gt;shared.run.syncs = NULL;
}
static void
inf_session_constructed(GObject* object)
{
  InfSessionPrivate* priv;
  InfXmlConnection* sync_conn;
  G_OBJECT_CLASS(inf_session_parent_class)-&gt;constructed(object);
  priv = INF_SESSION_PRIVATE(object);
  if(priv-&gt;user_table == NULL)
    priv-&gt;user_table = inf_user_table_new();
  switch(priv-&gt;status)
  {
  case INF_SESSION_PRESYNC:
    g_assert(priv-&gt;shared.presync.conn != NULL &amp;&amp;
             priv-&gt;shared.presync.group != NULL);
    sync_conn = priv-&gt;shared.presync.conn;
    break;
  case INF_SESSION_SYNCHRONIZING:
    g_assert(priv-&gt;shared.sync.conn != NULL &amp;&amp;
             priv-&gt;shared.sync.group != NULL);
    sync_conn = priv-&gt;shared.sync.conn;
    break;
  case INF_SESSION_RUNNING:
  case INF_SESSION_CLOSED:
    sync_conn = NULL;
    break;
  default:
    g_assert_not_reached();
    break;
  }
  if(sync_conn != NULL)
  {
    g_signal_connect(
      G_OBJECT(sync_conn),
      "notify::status",
      G_CALLBACK(inf_session_connection_notify_status_cb),
      object
    );
  }
}
static void
inf_session_dispose(GObject* object)
{
  InfSession* session;
  InfSessionPrivate* priv;
  session = INF_SESSION(object);
  priv = INF_SESSION_PRIVATE(session);
  if(priv-&gt;status != INF_SESSION_CLOSED)
  {
    inf_session_close(session);
  }
  g_object_unref(G_OBJECT(priv-&gt;user_table));
  priv-&gt;user_table = NULL;
  g_object_unref(G_OBJECT(priv-&gt;buffer));
  priv-&gt;buffer = NULL;
  g_object_unref(G_OBJECT(priv-&gt;manager));
  priv-&gt;manager = NULL;
  G_OBJECT_CLASS(inf_session_parent_class)-&gt;dispose(object);
}
static void
inf_session_finalize(GObject* object)
{
<a name="3"></a>  InfSession* session;
  InfSessionPrivate* priv;
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  session = INF_SESSION(object);
  priv = INF_SESSION_PRIVATE(session);
  G_OBJECT_CLASS(inf_session_parent_class)-&gt;finalize(object);
}
static void
inf_session_set_property(GObject* object,
                         guint prop_id,
                         const GValue* value,
                         GParamSpec* pspec)
{
  InfSession* session;
  InfSessionPrivate* priv;
  session = INF_SESSION(object);
  priv = INF_SESSION_PRIVATE(session);
  switch(prop_id)
  {
  case PROP_COMMUNICATION_MANAGER:</b></font>
    g_assert(priv-&gt;manager == NULL);     priv-&gt;manager = INF_COMMUNICATION_MANAGER(g_value_dup_object(value));
    break;
  case PROP_BUFFER:
    g_assert(priv-&gt;buffer == NULL);     priv-&gt;buffer = INF_BUFFER(g_value_dup_object(value));
    break;
  case PROP_USER_TABLE:
    g_assert(priv-&gt;user_table == NULL);     priv-&gt;user_table = INF_USER_TABLE(g_value_dup_object(value));
    break;
  case PROP_STATUS:
    g_assert(priv-&gt;status == INF_SESSION_RUNNING);
    priv-&gt;status = g_value_get_enum(value);
    switch(priv-&gt;status)
    {
    case INF_SESSION_PRESYNC:
      priv-&gt;shared.presync.conn = NULL;
      priv-&gt;shared.presync.group = NULL;
      priv-&gt;shared.presync.closing = FALSE;
      break;
    case INF_SESSION_SYNCHRONIZING:
      priv-&gt;shared.sync.conn = NULL;
      priv-&gt;shared.sync.group = NULL;
      priv-&gt;shared.sync.messages_total = 0;
      priv-&gt;shared.sync.messages_received = 0;
      priv-&gt;shared.sync.closing = FALSE;
      break;
    case INF_SESSION_RUNNING:
      g_assert(priv-&gt;shared.run.syncs == NULL);
      break;
    case INF_SESSION_CLOSED:
      break;
    default:
      g_assert_not_reached();
      break;
    }
    break;
  case PROP_SYNC_CONNECTION:
    switch(priv-&gt;status)
    {
    case INF_SESSION_PRESYNC:
      g_assert(priv-&gt;shared.presync.conn == NULL);       priv-&gt;shared.presync.conn =
        INF_XML_CONNECTION(g_value_dup_object(value));
      break;
    case INF_SESSION_SYNCHRONIZING:
      g_assert(priv-&gt;shared.sync.conn == NULL);       priv-&gt;shared.sync.conn =
        INF_XML_CONNECTION(g_value_dup_object(value));
      break;
    case INF_SESSION_RUNNING:
      g_assert(g_value_get_object(value) == NULL);
      break;
    case INF_SESSION_CLOSED:
    default:
      g_assert_not_reached();
      break;
    }
    break;
  case PROP_SYNC_GROUP:
    switch(priv-&gt;status)
    {
    case INF_SESSION_PRESYNC:
      g_assert(priv-&gt;shared.presync.group == NULL);       priv-&gt;shared.presync.group =
        INF_COMMUNICATION_GROUP(g_value_dup_object(value));
      break;
    case INF_SESSION_SYNCHRONIZING:
      g_assert(priv-&gt;shared.sync.group == NULL);       priv-&gt;shared.sync.group =
        INF_COMMUNICATION_GROUP(g_value_dup_object(value));
      break;
    case INF_SESSION_RUNNING:
      g_assert(g_value_get_object(value) == NULL);
      break;
    case INF_SESSION_CLOSED:
    default:
      g_assert_not_reached();
      break;
    }
    break;
  case PROP_SUBSCRIPTION_GROUP:
<a name="0"></a>    if(priv-&gt;subscription_group != NULL)
      g_object_unref(priv-&gt;subscription_group);
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    priv-&gt;subscription_group =
      INF_COMMUNICATION_GROUP(g_value_dup_object(value));
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_session_get_property(GObject* object,
                         guint prop_id,
                         GValue* value,
                         GParamSpec* pspec)
{
  InfSession* session;
  InfSessionPrivate* priv;
  session = INF_SESSION(object);
  priv = INF_SESSION_PRIVATE(session);
  switch(prop_id)
  {
  case PROP_COMMUNICATION_MANAGER:
    g_value_set_object(value, G_OBJECT(priv-&gt;manager));
    break;
  case PROP_BUFFER:
    g_value_set_object(value, G_OBJECT(priv-&gt;buffer));
    break;</b></font>
  case PROP_USER_TABLE:
    g_value_set_object(value, G_OBJECT(priv-&gt;user_table));
    break;
  case PROP_STATUS:
    g_value_set_enum(value, priv-&gt;status);
    break;
  case PROP_SYNC_CONNECTION:
    switch(priv-&gt;status)
    {
    case INF_SESSION_PRESYNC:
      g_value_set_object(value, G_OBJECT(priv-&gt;shared.presync.conn));
      break;
    case INF_SESSION_SYNCHRONIZING:
      g_value_set_object(value, G_OBJECT(priv-&gt;shared.sync.conn));
      break;
    case INF_SESSION_RUNNING:
    case INF_SESSION_CLOSED:
      g_value_set_object(value, NULL);
      break;
    default:
      g_assert_not_reached();
      break;
    }
    break;
  case PROP_SYNC_GROUP:
    switch(priv-&gt;status)
    {
    case INF_SESSION_PRESYNC:
      g_value_set_object(value, G_OBJECT(priv-&gt;shared.presync.group));
      break;
    case INF_SESSION_SYNCHRONIZING:
      g_value_set_object(value, G_OBJECT(priv-&gt;shared.sync.group));
      break;
    case INF_SESSION_RUNNING:
    case INF_SESSION_CLOSED:
      g_value_set_object(value, NULL);
      break;
    default:
      g_assert_not_reached();
      break;
    }
    break;
  case PROP_SUBSCRIPTION_GROUP:
    g_value_set_object(value, G_OBJECT(priv-&gt;subscription_group));
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static InfCommunicationScope
inf_session_handle_user_status_change(InfSession* session,
                                      InfXmlConnection* connection,
                                      xmlNodePtr xml,
                                      GError** error)
{
  InfSessionPrivate* priv;
  InfUser* user;
  guint id;
  xmlChar* status_attr;
  gboolean has_status;
  InfUserStatus status;
  priv = INF_SESSION_PRIVATE(session);
  if(!inf_xml_util_get_attribute_uint_required(xml, "id", &amp;id, error))
    return INF_COMMUNICATION_SCOPE_PTP;
  user = inf_user_table_lookup_user_by_id(priv-&gt;user_table, id);
  if(user == NULL)
  {
    g_set_error(
      error,
      inf_user_error_quark(),
      INF_USER_ERROR_NO_SUCH_USER,
      _("No such user with ID %u"),
      id
    );
    return INF_COMMUNICATION_SCOPE_PTP;
  }
  if(inf_user_get_status(user) == INF_USER_UNAVAILABLE ||
     inf_user_get_connection(user) != connection)
  {
    g_set_error_literal(
      error,
      inf_user_error_quark(),
      INF_USER_ERROR_NOT_JOINED,
      _("User did not join from this connection")
    );
    return INF_COMMUNICATION_SCOPE_PTP;
  }
  status_attr = xmlGetProp(xml, (const xmlChar*)"status");
  has_status =
    inf_user_status_from_string((const char*)status_attr, &amp;status, error);
  xmlFree(status_attr);
  if(!has_status) return FALSE;
  if(inf_user_get_status(user) != status)
    g_object_set(G_OBJECT(user), "status", status, NULL);
  return INF_COMMUNICATION_SCOPE_GROUP;
}
static void
inf_session_to_xml_sync_impl_foreach_func(InfUser* user,
                                          gpointer user_data)
{
  InfSessionXmlData* data;
  xmlNodePtr usernode;
  data = (InfSessionXmlData*)user_data;
  usernode = xmlNewNode(NULL, (const xmlChar*)"sync-user");
  inf_session_user_to_xml(data-&gt;session, user, usernode);
  xmlAddChild(data-&gt;xml, usernode);
}
static void
inf_session_to_xml_sync_impl(InfSession* session,
                             xmlNodePtr parent)
{
  InfSessionPrivate* priv;
  InfSessionXmlData data;
  priv = INF_SESSION_PRIVATE(session);
  data.session = session;
  data.xml = parent;
  inf_user_table_foreach_user(
    priv-&gt;user_table,
    inf_session_to_xml_sync_impl_foreach_func,
    &amp;data
  );
}
static gboolean
inf_session_process_xml_sync_impl(InfSession* session,
                                  InfXmlConnection* connection,
                                  const xmlNodePtr xml,
                                  GError** error)
{
  InfSessionPrivate* priv;
  InfSessionClass* session_class;
  GArray* user_props;
  InfUser* user;
  guint i;
  const GParameter* param;
  GParameter* connparam;
  priv = INF_SESSION_PRIVATE(session);
  session_class = INF_SESSION_GET_CLASS(session);
  g_return_val_if_fail(session_class-&gt;get_xml_user_props != NULL, FALSE);
  g_return_val_if_fail(priv-&gt;status == INF_SESSION_SYNCHRONIZING, FALSE);
  g_return_val_if_fail(connection == priv-&gt;shared.sync.conn, FALSE);
  if(strcmp((const char*)xml-&gt;name, "sync-user") == 0)
  {
    user_props = session_class-&gt;get_xml_user_props(
      session,
      connection,
      xml
    );
    param = inf_session_lookup_user_property(
      (const GParameter*)user_props-&gt;data,
      user_props-&gt;len,
      "status"
    );
    if(param != NULL &amp;&amp;
       g_value_get_enum(&amp;param-&gt;value) != INF_USER_UNAVAILABLE)
    {
      connparam = inf_session_get_user_property(user_props, "connection");
      if(!G_IS_VALUE(&amp;connparam-&gt;value))
      {
        g_value_init(&amp;connparam-&gt;value, INF_TYPE_XML_CONNECTION);
        g_value_set_object(&amp;connparam-&gt;value, G_OBJECT(connection));
      }
    }
    user = inf_session_add_user(
      session,
      (GParameter*)user_props-&gt;data,
      user_props-&gt;len
    );
    for(i = 0; i &lt; user_props-&gt;len; ++ i)
      g_value_unset(&amp;g_array_index(user_props, GParameter, i).value);
    g_array_free(user_props, TRUE);
    if(user == NULL) return FALSE;
    return TRUE;
  }
  else
  {
    g_set_error(
      error,
      inf_session_sync_error_quark,
      INF_SESSION_SYNC_ERROR_UNEXPECTED_NODE,
      "Received unexpected XML message \"%s\" during synchronization",
      (const gchar*)xml-&gt;name
    );
    return FALSE;
  }
}
static InfCommunicationScope
inf_session_process_xml_run_impl(InfSession* session,
                                 InfXmlConnection* connection,
                                 const xmlNodePtr xml,
                                 GError** error)
{
  if(strcmp((const char*)xml-&gt;name, "user-status-change") == 0)
  {
    return inf_session_handle_user_status_change(
      session,
      connection,
      xml,
      error
    );
  }
  else
  {
    g_set_error(
      error,
      g_quark_from_static_string("INF_SESSION_ERROR"),
      0,
      _("Received unhandled XML message '%s'"),
      (const gchar*)xml-&gt;name
    );
    return INF_COMMUNICATION_SCOPE_PTP;
  }
}
static GArray*
inf_session_get_xml_user_props_impl(InfSession* session,
                                    InfXmlConnection* conn,
                                    const xmlNodePtr xml)
{
  InfSessionPrivate* priv;
  GArray* array;
  GParameter* parameter;
  xmlChar* name;
  xmlChar* id;
  xmlChar* status;
#if 0
  xmlChar* connection;
  InfXmlConnection* real_conn;
#endif
  priv = INF_SESSION_PRIVATE(session);
  array = g_array_sized_new(FALSE, FALSE, sizeof(GParameter), 16);
  name = xmlGetProp(xml, (const xmlChar*)"name");
  id = xmlGetProp(xml, (const xmlChar*)"id");
  status = xmlGetProp(xml, (const xmlChar*)"status");
#if 0
  connection = xmlGetProp(xml, (const xmlChar*)"connection");
#endif
  if(id != NULL)
  {
    parameter = inf_session_get_user_property(array, "id");
    g_value_init(&amp;parameter-&gt;value, G_TYPE_UINT);
    g_value_set_uint(&amp;parameter-&gt;value, strtoul((const gchar*)id, NULL, 10));
    xmlFree(id);
  }
  if(name != NULL)
  {
    parameter = inf_session_get_user_property(array, "name");
    g_value_init(&amp;parameter-&gt;value, G_TYPE_STRING);
    g_value_set_string(&amp;parameter-&gt;value, (const gchar*)name);
    xmlFree(name);
  }
  if(status != NULL)
  {
    parameter = inf_session_get_user_property(array, "status");
    g_value_init(&amp;parameter-&gt;value, INF_TYPE_USER_STATUS);
    if(strcmp((const char*)status, "active") == 0)
      g_value_set_enum(&amp;parameter-&gt;value, INF_USER_ACTIVE);
    else if(strcmp((const char*)status, "inactive") == 0)
      g_value_set_enum(&amp;parameter-&gt;value, INF_USER_INACTIVE);
    else
      g_value_set_enum(&amp;parameter-&gt;value, INF_USER_UNAVAILABLE);
    xmlFree(status);
  }
#if 0
  if(connection != NULL)
  {
    real_conn = inf_connection_manager_group_lookup_connection(
      priv-&gt;subscription_group,
      connection
    );
    if(real_conn != NULL)
    {
      parameter = inf_session_get_user_property(array, "connection");
      g_value_init(&amp;parameter-&gt;value, INF_TYPE_XML_CONNECTION);
      g_value_set_object(&amp;parameter-&gt;value, G_OBJECT(real_conn));
    }
    else
    {
    }
  }
#endif
  return array;
}
static void
inf_session_set_xml_user_props_impl(InfSession* session,
                                    const GParameter* params,
                                    guint n_params,
                                    xmlNodePtr xml)
{
  guint i;
  gchar id_buf[16];
  const gchar* name;
  InfUserStatus status;
#if 0
  InfXmlConnection* conn;
  gchar* remote_address;
#endif
  for(i = 0; i &lt; n_params; ++ i)
  {
    if(strcmp(params[i].name, "id") == 0)
    {
      sprintf(id_buf, "%u", g_value_get_uint(&amp;params[i].value));
      xmlNewProp(xml, (const xmlChar*)"id", (const xmlChar*)id_buf);
    }
    else if(strcmp(params[i].name, "name") == 0)
    {
      name = g_value_get_string(&amp;params[i].value);
      xmlNewProp(xml, (const xmlChar*)"name", (const xmlChar*)name);
    }
    else if(strcmp(params[i].name, "status") == 0)
    {
      status = g_value_get_enum(&amp;params[i].value);
      inf_xml_util_set_attribute(
        xml,
        "status",
        inf_user_status_to_string(status)
      );
    }
  }
}
static gboolean
inf_session_validate_user_props_impl(InfSession* session,
                                     const GParameter* params,
                                     guint n_params,
                                     InfUser* exclude,
                                     GError** error)
{
  InfSessionPrivate* priv;
  const GParameter* parameter;
  const gchar* name;
  InfUser* user;
  guint id;
  priv = INF_SESSION_PRIVATE(session);
  parameter = inf_session_lookup_user_property(params, n_params, "id");
  if(parameter == NULL)
  {
    g_set_error_literal(
      error,
      inf_session_sync_error_quark,
      INF_SESSION_SYNC_ERROR_ID_NOT_PRESENT,
      inf_session_sync_strerror(INF_SESSION_SYNC_ERROR_ID_NOT_PRESENT)
    );
    return FALSE;
  }
  id = g_value_get_uint(&amp;parameter-&gt;value);
  user = inf_user_table_lookup_user_by_id(priv-&gt;user_table, id);
  if(user != NULL &amp;&amp; user != exclude)
  {
    g_set_error_literal(
      error,
      inf_session_sync_error_quark,
      INF_SESSION_SYNC_ERROR_ID_IN_USE,
      inf_session_sync_strerror(INF_SESSION_SYNC_ERROR_ID_IN_USE)
    );
    return FALSE;
  }
  parameter = inf_session_lookup_user_property(params, n_params, "name");
  if(parameter == NULL)
  {
    g_set_error_literal(
      error,
      inf_session_sync_error_quark,
      INF_SESSION_SYNC_ERROR_NAME_NOT_PRESENT,
      inf_session_sync_strerror(INF_SESSION_SYNC_ERROR_NAME_NOT_PRESENT)
    );
    return FALSE;
  }
  name = g_value_get_string(&amp;parameter-&gt;value);
  user = inf_user_table_lookup_user_by_name(priv-&gt;user_table, name);
  if(user != NULL &amp;&amp; user != exclude)
  {
    g_set_error_literal(
      error,
      inf_session_sync_error_quark,
      INF_SESSION_SYNC_ERROR_NAME_IN_USE,
      inf_session_sync_strerror(INF_SESSION_SYNC_ERROR_NAME_IN_USE)
    );
    return FALSE;
  }
  return TRUE;
}
static gboolean
inf_session_handle_received_sync_message(InfSession* session,
                                         InfXmlConnection* connection,
                                         const xmlNodePtr node,
                                         GError** error)
{
  InfSessionClass* session_class;
  InfSessionPrivate* priv;
  xmlChar* num_messages;
  gboolean result;
  xmlNodePtr xml_reply;
  GError* local_error;
  session_class = INF_SESSION_GET_CLASS(session);
  priv = INF_SESSION_PRIVATE(session);
  g_assert(session_class-&gt;process_xml_sync != NULL);
  g_assert(priv-&gt;status == INF_SESSION_SYNCHRONIZING);
  if(strcmp((const gchar*)node-&gt;name, "sync-cancel") == 0)
  {
    local_error = NULL;
    g_set_error_literal(
      &amp;local_error,
      inf_session_sync_error_quark,
      INF_SESSION_SYNC_ERROR_SENDER_CANCELLED,
      inf_session_sync_strerror(INF_SESSION_SYNC_ERROR_SENDER_CANCELLED)
    );
    g_signal_emit(
      G_OBJECT(session),
      session_signals[SYNCHRONIZATION_FAILED],
      0,
      connection,
      local_error
    );
#if 0
    inf_session_close(session);
#endif
    g_error_free(local_error);
    return FALSE;
  }
  else if(strcmp((const gchar*)node-&gt;name, "sync-begin") == 0)
  {
    if(priv-&gt;shared.sync.messages_total &gt; 0)
    {
      g_set_error_literal(
        error,
        inf_session_sync_error_quark,
        INF_SESSION_SYNC_ERROR_UNEXPECTED_BEGIN_OF_SYNC,
        inf_session_sync_strerror(
          INF_SESSION_SYNC_ERROR_UNEXPECTED_BEGIN_OF_SYNC
        )
      );
      return FALSE;
    }
    else
    {
      num_messages = xmlGetProp(node, (const xmlChar*)"num-messages");
      if(num_messages == NULL)
      {
        g_set_error_literal(
          error,
          inf_session_sync_error_quark,
          INF_SESSION_SYNC_ERROR_NUM_MESSAGES_MISSING,
          inf_session_sync_strerror(
            INF_SESSION_SYNC_ERROR_NUM_MESSAGES_MISSING
          )
        );
        return FALSE;
      }
      else
      {
        priv-&gt;shared.sync.messages_total = 2 + strtoul(
          (const gchar*)num_messages,
          NULL,
          0
        );
        priv-&gt;shared.sync.messages_received = 1;
        xmlFree(num_messages);
        g_signal_emit(
          G_OBJECT(session),
          session_signals[SYNCHRONIZATION_PROGRESS],
          0,
          connection,
          1.0 / (double)priv-&gt;shared.sync.messages_total
        );
        return TRUE;
      }
    }
  }
  else if(strcmp((const gchar*)node-&gt;name, "sync-end") == 0)
  {
    ++ priv-&gt;shared.sync.messages_received;
    if(priv-&gt;shared.sync.messages_received !=
       priv-&gt;shared.sync.messages_total)
    {
      g_set_error_literal(
        error,
        inf_session_sync_error_quark,
        INF_SESSION_SYNC_ERROR_UNEXPECTED_END_OF_SYNC,
        inf_session_sync_strerror(
          INF_SESSION_SYNC_ERROR_UNEXPECTED_END_OF_SYNC
        )
      );
      return FALSE;
    }
    else
    {
      xml_reply = xmlNewNode(NULL, (const xmlChar*)"sync-ack");
      inf_communication_group_send_message(
        priv-&gt;shared.sync.group,
        connection,
        xml_reply
      );
      g_signal_emit(
        G_OBJECT(session),
        session_signals[SYNCHRONIZATION_COMPLETE],
        0,
        connection
      );
      return TRUE;
    }
  }
  else
  {
    if(priv-&gt;shared.sync.messages_received == 0)
    {
      g_set_error_literal(
        error,
        inf_session_sync_error_quark,
        INF_SESSION_SYNC_ERROR_EXPECTED_BEGIN_OF_SYNC,
        inf_session_sync_strerror(
          INF_SESSION_SYNC_ERROR_EXPECTED_BEGIN_OF_SYNC
        )
      );
      return FALSE;
    }
    else if(priv-&gt;shared.sync.messages_received ==
            priv-&gt;shared.sync.messages_total - 1)
    {
      g_set_error_literal(
        error,
        inf_session_sync_error_quark,
        INF_SESSION_SYNC_ERROR_EXPECTED_END_OF_SYNC,
        inf_session_sync_strerror(INF_SESSION_SYNC_ERROR_EXPECTED_END_OF_SYNC)
      );
      return FALSE;
    }
    else
    {
      result = session_class-&gt;process_xml_sync(
        session,
        connection,
        node,
        error
      );
      if(result == FALSE) return FALSE;
      if(priv-&gt;status == INF_SESSION_CLOSED)
        return TRUE;
      ++ priv-&gt;shared.sync.messages_received;
      g_signal_emit(
        G_OBJECT(session),
        session_signals[SYNCHRONIZATION_PROGRESS],
        0,
        connection,
        (double)priv-&gt;shared.sync.messages_received /
          (double)priv-&gt;shared.sync.messages_total
      );
      return TRUE;
    }
  }
}
static void
inf_session_communication_object_sent(InfCommunicationObject* comm_object,
                                      InfXmlConnection* connection,
                                      const xmlNodePtr node)
{
  InfSession* session;
  InfSessionPrivate* priv;
  InfSessionSync* sync;
  session = INF_SESSION(comm_object);
  priv = INF_SESSION_PRIVATE(session);
  if(priv-&gt;status == INF_SESSION_RUNNING)
  {
    sync = inf_session_find_sync_by_connection(session, connection);
    if(sync != NULL &amp;&amp; sync-&gt;messages_sent &lt; sync-&gt;messages_total)
    {
      ++ sync-&gt;messages_sent;
      g_signal_emit(
        G_OBJECT(comm_object),
        session_signals[SYNCHRONIZATION_PROGRESS],
        0,
        connection,
        (gdouble)sync-&gt;messages_sent / (gdouble)sync-&gt;messages_total
      );
    }
  }
}
static void
inf_session_communication_object_enqueued(InfCommunicationObject* comm_object,
                                          InfXmlConnection* connection,
                                          const xmlNodePtr node)
{
  InfSessionSync* sync;
  if(strcmp((const gchar*)node-&gt;name, "sync-end") == 0)
  {
    sync = inf_session_find_sync_by_connection(
      INF_SESSION(comm_object),
      connection
    );
    g_assert(sync != NULL);
    g_assert(sync-&gt;status == INF_SESSION_SYNC_IN_PROGRESS);
    sync-&gt;status = INF_SESSION_SYNC_AWAITING_ACK;
  }
}
static InfCommunicationScope
inf_session_communication_object_received(InfCommunicationObject* comm_object,
                                          InfXmlConnection* connection,
                                          const xmlNodePtr node)
{
  InfSessionClass* session_class;
  InfSession* session;
  InfSessionPrivate* priv;
  InfSessionSync* sync;
  gboolean result;
  InfCommunicationScope scope;
  GError* local_error;
  const gchar* local_message;
  session = INF_SESSION(comm_object);
  priv = INF_SESSION_PRIVATE(session);
  switch(priv-&gt;status)
  {
  case INF_SESSION_PRESYNC:
    g_assert(connection == priv-&gt;shared.presync.conn);
    local_error = NULL;
    g_set_error(
      &amp;local_error,
      inf_session_sync_error_quark,
      INF_SESSION_SYNC_ERROR_GOT_MESSAGE_IN_PRESYNC,
      _("Unexpectedly received XML message \"%s\" in presync"),
      (const gchar*)node-&gt;name
    );
     g_signal_emit(
      G_OBJECT(session),
      session_signals[ERROR],
      0,
      connection,
      node,
      local_error
    );
    return INF_COMMUNICATION_SCOPE_PTP;
  case INF_SESSION_SYNCHRONIZING:
    g_assert(connection == priv-&gt;shared.sync.conn);
    local_error = NULL;
    result = inf_session_handle_received_sync_message(
      session,
      connection,
      node,
      &amp;local_error
    );
    if(result == FALSE &amp;&amp; local_error != NULL)
    {
      inf_session_send_sync_error(session, local_error);
      g_signal_emit(
        G_OBJECT(session),
        session_signals[SYNCHRONIZATION_FAILED],
        0,
        connection,
        local_error
      );
      g_error_free(local_error);
    }
    return INF_COMMUNICATION_SCOPE_PTP;
  case INF_SESSION_RUNNING:
    sync = inf_session_find_sync_by_connection(session, connection);
    if(sync != NULL)
    {
      if(strcmp((const gchar*)node-&gt;name, "sync-error") == 0)
      {
        inf_communication_group_cancel_messages(sync-&gt;group, connection);
        local_error = inf_xml_util_new_error_from_node(node);
        if(local_error != NULL)
        {
          local_message =
            inf_session_get_sync_error_message(local_error-&gt;domain,
                                               local_error-&gt;code);
          if(local_message != NULL)
          {
            if(local_error-&gt;message != NULL)
              g_free(local_error-&gt;message);
            local_error-&gt;message = g_strdup(local_message);
          }
        }
        else
        {
          g_set_error_literal(
            &amp;local_error,
            inf_session_sync_error_quark,
            INF_SESSION_SYNC_ERROR_FAILED,
            inf_session_sync_strerror(INF_SESSION_SYNC_ERROR_FAILED)
          );
        }
        g_signal_emit(
          G_OBJECT(session),
          session_signals[SYNCHRONIZATION_FAILED],
          0,
          connection,
          local_error
        );
        g_error_free(local_error);
      }
      else if(strcmp((const gchar*)node-&gt;name, "sync-ack") == 0 &amp;&amp;
              sync-&gt;status == INF_SESSION_SYNC_AWAITING_ACK)
      {
        g_signal_emit(
          G_OBJECT(comm_object),
          session_signals[SYNCHRONIZATION_COMPLETE],
          0,
          connection
        );
      }
      else
      {
        local_error = NULL;
        g_set_error(
          &amp;local_error,
          inf_session_sync_error_quark,
          INF_SESSION_SYNC_ERROR_UNEXPECTED_NODE,
          _("Received unexpected XML message \"%s\" while synchronizing"),
          (const gchar*)node-&gt;name
        );
        g_error_free(local_error);
      }
      return INF_COMMUNICATION_SCOPE_PTP;
    }
    else
    {
      session_class = INF_SESSION_GET_CLASS(session);
      g_assert(session_class-&gt;process_xml_run != NULL);
      local_error = NULL;
      scope = session_class-&gt;process_xml_run(
        session,
        connection,
        node,
        &amp;local_error
      );
      if(local_error != NULL)
      {
        g_signal_emit(
          G_OBJECT(session),
          session_signals[ERROR],
          0,
          connection,
          node,
          local_error
        );
        g_error_free(local_error);
      }
      return scope;
    }
  case INF_SESSION_CLOSED:
  default:
    g_assert_not_reached();
    return INF_COMMUNICATION_SCOPE_PTP;
  }
}
static void
inf_session_close_handler(InfSession* session)
{
  InfSessionPrivate* priv;
  InfSessionSync* sync;
  priv = INF_SESSION_PRIVATE(session);
  g_object_freeze_notify(G_OBJECT(session));
  switch(priv-&gt;status)
  {
  case INF_SESSION_PRESYNC:
    if(priv-&gt;shared.presync.closing == FALSE)
    {
      priv-&gt;shared.presync.closing = TRUE;
      inf_session_cancel_synchronization(session, priv-&gt;shared.presync.conn);
    }
    inf_session_release_connection(session, priv-&gt;shared.presync.conn);
    break;
  case INF_SESSION_SYNCHRONIZING:
    if(priv-&gt;shared.sync.closing == FALSE)
    {
      priv-&gt;shared.sync.closing = TRUE;
      inf_session_cancel_synchronization(session, priv-&gt;shared.sync.conn);
    }
    inf_session_release_connection(session, priv-&gt;shared.sync.conn);
    break;
  case INF_SESSION_RUNNING:
    while(priv-&gt;shared.run.syncs != NULL)
    {
      sync = (InfSessionSync*)priv-&gt;shared.run.syncs-&gt;data;
      inf_session_cancel_synchronization(session, sync-&gt;conn);
    }
    break;
  case INF_SESSION_CLOSED:
  default:
    g_assert_not_reached();
    break;
  }
  if(priv-&gt;subscription_group != NULL)
  {
    g_object_unref(priv-&gt;subscription_group);
    priv-&gt;subscription_group = NULL;
    g_object_notify(G_OBJECT(session), "subscription-group");
  }
  priv-&gt;status = INF_SESSION_CLOSED;
  g_object_notify(G_OBJECT(session), "status");
  g_object_thaw_notify(G_OBJECT(session));
}
static void
inf_session_synchronization_begin_handler(InfSession* session,
                                          InfCommunicationGroup* group,
                                          InfXmlConnection* connection)
{
  InfSessionPrivate* priv;
  InfSessionClass* session_class;
  InfSessionSync* sync;
  xmlNodePtr messages;
  xmlNodePtr next;
  xmlNodePtr xml;
  gchar num_messages_buf[16];
  priv = INF_SESSION_PRIVATE(session);
  g_assert(priv-&gt;status == INF_SESSION_RUNNING);
  g_assert(inf_session_find_sync_by_connection(session, connection) == NULL);
  session_class = INF_SESSION_GET_CLASS(session);
  g_return_if_fail(session_class-&gt;to_xml_sync != NULL);
  sync = g_slice_new(InfSessionSync);
  sync-&gt;conn = connection;
  sync-&gt;messages_sent = 0;
  sync-&gt;messages_total = 2;   sync-&gt;status = INF_SESSION_SYNC_IN_PROGRESS;
  g_object_ref(G_OBJECT(connection));
  priv-&gt;shared.run.syncs = g_slist_prepend(priv-&gt;shared.run.syncs, sync);
  g_signal_connect_after(
    G_OBJECT(connection),
    "notify::status",
    G_CALLBACK(inf_session_connection_notify_status_cb),
    session
  );
  sync-&gt;group = group;
  g_object_ref(sync-&gt;group);
  g_assert(inf_communication_group_is_member(sync-&gt;group, connection));
  messages = xmlNewNode(NULL, (const xmlChar*)"sync-container");
  session_class-&gt;to_xml_sync(session, messages);
  for(xml = messages-&gt;children; xml != NULL; xml = xml-&gt;next)
    ++ sync-&gt;messages_total;
  sprintf(num_messages_buf, "%u", sync-&gt;messages_total - 2);
  xml = xmlNewNode(NULL, (const xmlChar*)"sync-begin");
  xmlNewProp(
    xml,
    (const xmlChar*)"num-messages",
    (const xmlChar*)num_messages_buf
  );
  inf_communication_group_send_message(sync-&gt;group, connection, xml);
  for(xml = messages-&gt;children; xml != NULL; xml = next)
  {
    next = xml-&gt;next;
    xmlUnlinkNode(xml);
    inf_communication_group_send_message(sync-&gt;group, connection, xml);
  }
  xmlFreeNode(messages);
  xml = xmlNewNode(NULL, (const xmlChar*)"sync-end");
  inf_communication_group_send_message(sync-&gt;group, connection, xml);
}
static void
inf_session_synchronization_complete_handler(InfSession* session,
                                             InfXmlConnection* connection)
{
  InfSessionPrivate* priv;
  priv = INF_SESSION_PRIVATE(session);
  switch(priv-&gt;status)
  {
  case INF_SESSION_PRESYNC:
    g_assert_not_reached();
    break;
  case INF_SESSION_SYNCHRONIZING:
    g_assert(connection == priv-&gt;shared.sync.conn);
    inf_session_release_connection(session, connection);
    priv-&gt;status = INF_SESSION_RUNNING;
    priv-&gt;shared.run.syncs = NULL;
    g_object_notify(G_OBJECT(session), "status");
    break;
  case INF_SESSION_RUNNING:
    g_assert(
      inf_session_find_sync_by_connection(session, connection) != NULL
    );
    inf_session_release_connection(session, connection);
    break;
  case INF_SESSION_CLOSED:
  default:
    g_assert_not_reached();
    break;
  }
}
static void
inf_session_synchronization_failed_handler(InfSession* session,
                                           InfXmlConnection* connection,
                                           const GError* error)
{
  InfSessionPrivate* priv;
  priv = INF_SESSION_PRIVATE(session);
  switch(priv-&gt;status)
  {
  case INF_SESSION_PRESYNC:
    g_assert(connection == priv-&gt;shared.presync.conn);
    if(priv-&gt;shared.presync.closing == FALSE)
    {
      priv-&gt;shared.presync.closing = TRUE;
      inf_session_close(session);
    }
    break;
  case INF_SESSION_SYNCHRONIZING:
    g_assert(connection == priv-&gt;shared.sync.conn);
    if(priv-&gt;shared.sync.closing == FALSE)
    {
      priv-&gt;shared.sync.closing = TRUE;
      inf_session_close(session);
    }
    break;
  case INF_SESSION_RUNNING:
    g_assert(
      inf_session_find_sync_by_connection(session, connection) != NULL
    );
    inf_session_release_connection(session, connection);
    break;
  case INF_SESSION_CLOSED:
    break;
  default:
    g_assert_not_reached();
    break;
  }
}
static void
inf_session_class_init(InfSessionClass* session_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(session_class);
  object_class-&gt;constructed = inf_session_constructed;
  object_class-&gt;dispose = inf_session_dispose;
  object_class-&gt;finalize = inf_session_finalize;
  object_class-&gt;set_property = inf_session_set_property;
  object_class-&gt;get_property = inf_session_get_property;
  session_class-&gt;to_xml_sync = inf_session_to_xml_sync_impl;
  session_class-&gt;process_xml_sync = inf_session_process_xml_sync_impl;
  session_class-&gt;process_xml_run = inf_session_process_xml_run_impl;
  session_class-&gt;get_xml_user_props = inf_session_get_xml_user_props_impl;
  session_class-&gt;set_xml_user_props = inf_session_set_xml_user_props_impl;
  session_class-&gt;validate_user_props = inf_session_validate_user_props_impl;
  session_class-&gt;user_new = NULL;
  session_class-&gt;close = inf_session_close_handler;
  session_class-&gt;error = NULL;
  session_class-&gt;synchronization_begin =
    inf_session_synchronization_begin_handler;
  session_class-&gt;synchronization_progress = NULL;
  session_class-&gt;synchronization_complete =
    inf_session_synchronization_complete_handler;
  session_class-&gt;synchronization_failed =
    inf_session_synchronization_failed_handler;
  inf_session_sync_error_quark = g_quark_from_static_string(
    "INF_SESSION_SYNC_ERROR"
  );
  g_object_class_install_property(
    object_class,
    PROP_COMMUNICATION_MANAGER,
    g_param_spec_object(
      "communication-manager",
      "Communication manager",
      "The communication manager used for sending requests",
      INF_COMMUNICATION_TYPE_MANAGER,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_BUFFER,
    g_param_spec_object(
      "buffer",
      "Buffer",
      "The buffer in which the document content is stored",
      INF_TYPE_BUFFER,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_USER_TABLE,
    g_param_spec_object(
      "user-table",
      "User table",
      "User table containing the users of the session",
      INF_TYPE_USER_TABLE,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_STATUS,
    g_param_spec_enum(
      "status",
      "Session Status",
      "Current status of the session",
      INF_TYPE_SESSION_STATUS,
      INF_SESSION_RUNNING,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SYNC_CONNECTION,
    g_param_spec_object(
      "sync-connection",
      "Synchronizing connection",
      "Connection which synchronizes the initial session state",
      INF_TYPE_XML_CONNECTION,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SYNC_GROUP,
    g_param_spec_object(
      "sync-group",
      "Synchronization group",
      "Communication group in which to perform synchronization",
      INF_COMMUNICATION_TYPE_GROUP,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SUBSCRIPTION_GROUP,
    g_param_spec_object(
      "subscription-group",
      "Subscription group",
      "Communication group of subscribed connections",
      INF_COMMUNICATION_TYPE_GROUP,
      G_PARAM_READWRITE
    )
  );
  session_signals[CLOSE] = g_signal_new(
    "close",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfSessionClass, close),
    NULL, NULL,
    g_cclosure_marshal_VOID__VOID,
    G_TYPE_NONE,
    0
  );
  session_signals[ERROR] = g_signal_new(
    "error",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfSessionClass, error),
    NULL, NULL,
    NULL,
    G_TYPE_NONE,
    3,
    INF_TYPE_XML_CONNECTION,
    G_TYPE_POINTER,     G_TYPE_ERROR
  );
  session_signals[SYNCHRONIZATION_BEGIN] = g_signal_new(
    "synchronization-begin",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfSessionClass, synchronization_begin),
    NULL, NULL,
    NULL,
    G_TYPE_NONE,
    2,
    INF_COMMUNICATION_TYPE_GROUP,
    INF_TYPE_XML_CONNECTION
  );
  session_signals[SYNCHRONIZATION_PROGRESS] = g_signal_new(
    "synchronization-progress",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfSessionClass, synchronization_progress),
    NULL, NULL,
    NULL,
    G_TYPE_NONE,
    2,
    INF_TYPE_XML_CONNECTION,
    G_TYPE_DOUBLE
  );
  session_signals[SYNCHRONIZATION_COMPLETE] = g_signal_new(
    "synchronization-complete",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfSessionClass, synchronization_complete),
    NULL, NULL,
    g_cclosure_marshal_VOID__OBJECT,
    G_TYPE_NONE,
    1,
    INF_TYPE_XML_CONNECTION
  );
  session_signals[SYNCHRONIZATION_FAILED] = g_signal_new(
    "synchronization-failed",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfSessionClass, synchronization_failed),
    NULL, NULL,
    NULL,
    G_TYPE_NONE,
    2,
    INF_TYPE_XML_CONNECTION,
    G_TYPE_ERROR
  );
}
static void
inf_session_communication_object_iface_init(
  InfCommunicationObjectInterface* iface)
{
  iface-&gt;sent = inf_session_communication_object_sent;
  iface-&gt;enqueued = inf_session_communication_object_enqueued;
  iface-&gt;received = inf_session_communication_object_received;
}
const GParameter*
inf_session_lookup_user_property(const GParameter* params,
                                 guint n_params,
                                 const gchar* name)
{
  guint i;
  g_return_val_if_fail(params != NULL || n_params == 0, NULL);
  g_return_val_if_fail(name != NULL, NULL);
  for(i = 0; i &lt; n_params; ++ i)
    if(strcmp(params[i].name, name) == 0)
      return &amp;params[i];
  return NULL;
}
GParameter*
inf_session_get_user_property(GArray* array,
                              const gchar* name)
{
  GParameter* parameter;
  guint i;
  g_return_val_if_fail(array != NULL, NULL);
  g_return_val_if_fail(name != NULL, NULL);
  for(i = 0; i &lt; array-&gt;len; ++ i)
    if(strcmp(g_array_index(array, GParameter, i).name, name) == 0)
      return &amp;g_array_index(array, GParameter, i);
  g_array_set_size(array, array-&gt;len + 1);
  parameter = &amp;g_array_index(array, GParameter, array-&gt;len - 1);
  parameter-&gt;name = name;
  memset(&amp;parameter-&gt;value, 0, sizeof(GValue));
  return parameter;
}
void
inf_session_user_to_xml(InfSession* session,
                        InfUser* user,
                        xmlNodePtr xml)
{
  InfSessionClass* session_class;
  GParamSpec** pspecs;
  GParameter* params;
  guint n_params;
  guint i;
  g_return_if_fail(INF_IS_SESSION(session));
  g_return_if_fail(INF_IS_USER(user));
  g_return_if_fail(xml != NULL);
  session_class = INF_SESSION_GET_CLASS(session);
  g_return_if_fail(session_class-&gt;set_xml_user_props != NULL);
  pspecs = g_object_class_list_properties(
    G_OBJECT_CLASS(INF_USER_GET_CLASS(user)),
    &amp;n_params
  );
  params = g_malloc(n_params * sizeof(GParameter));
  for(i = 0; i &lt; n_params; ++ i)
  {
    params[i].name = pspecs[i]-&gt;name;
    memset(&amp;params[i].value, 0, sizeof(GValue));
    g_value_init(&amp;params[i].value, pspecs[i]-&gt;value_type);
    g_object_get_property(G_OBJECT(user), params[i].name, &amp;params[i].value);
  }
  session_class-&gt;set_xml_user_props(session, params, n_params, xml);
  for(i = 0; i &lt; n_params; ++ i)
    g_value_unset(&amp;params[i].value);
  g_free(params);
  g_free(pspecs);
}
void
inf_session_close(InfSession* session)
{
  g_return_if_fail(INF_IS_SESSION(session));
  g_return_if_fail(inf_session_get_status(session) != INF_SESSION_CLOSED);
  g_signal_emit(G_OBJECT(session), session_signals[CLOSE], 0);
}
InfCommunicationManager*
inf_session_get_communication_manager(InfSession* session)
{
  g_return_val_if_fail(INF_IS_SESSION(session), NULL);
  return INF_SESSION_PRIVATE(session)-&gt;manager;
}
InfBuffer*
inf_session_get_buffer(InfSession* session)
{
  g_return_val_if_fail(INF_IS_SESSION(session), NULL);
  return INF_SESSION_PRIVATE(session)-&gt;buffer;
}
InfUserTable*
inf_session_get_user_table(InfSession* session)
{
  g_return_val_if_fail(INF_IS_SESSION(session), NULL);
  return INF_SESSION_PRIVATE(session)-&gt;user_table;
}
InfSessionStatus
inf_session_get_status(InfSession* session)
{
  g_return_val_if_fail(INF_IS_SESSION(session), INF_SESSION_CLOSED);
  return INF_SESSION_PRIVATE(session)-&gt;status;
}
InfUser*
inf_session_add_user(InfSession* session,
                     const GParameter* params,
                     guint n_params)
{
  InfSessionPrivate* priv;
  InfSessionClass* session_class;
  InfUser* user;
  gboolean result;
  g_return_val_if_fail(INF_IS_SESSION(session), NULL);
  session_class = INF_SESSION_GET_CLASS(session);
  g_return_val_if_fail(session_class-&gt;validate_user_props != NULL, NULL);
  g_return_val_if_fail(session_class-&gt;user_new != NULL, NULL);
  priv = INF_SESSION_PRIVATE(session);
  g_return_val_if_fail(
    session_class-&gt;validate_user_props(session, params, n_params, NULL, NULL),
    NULL
  );
  user = session_class-&gt;user_new(
    session,
    *(GParameter**)(gpointer)&amp;params,
    n_params
  );
  inf_user_table_add_user(priv-&gt;user_table, user);
  g_object_unref(user); 
  return user;
}
void
inf_session_set_user_status(InfSession* session,
                            InfUser* user,
                            InfUserStatus status)
{
  InfSessionPrivate* priv;
  xmlNodePtr xml;
  g_return_if_fail(INF_IS_SESSION(session));
  g_return_if_fail(INF_IS_USER(user));
  g_return_if_fail(inf_session_get_status(session) == INF_SESSION_RUNNING);
  g_return_if_fail(inf_user_get_status(user) != INF_USER_UNAVAILABLE);
  g_return_if_fail( (inf_user_get_flags(user) &amp; INF_USER_LOCAL) != 0);
  priv = INF_SESSION_PRIVATE(session);
  if(inf_user_get_status(user) != status)
  {
    xml = xmlNewNode(NULL, (const xmlChar*)"user-status-change");
    inf_xml_util_set_attribute_uint(xml, "id", inf_user_get_id(user));
    inf_xml_util_set_attribute(
      xml,
      "status",
      inf_user_status_to_string(status)
    );
    if(priv-&gt;subscription_group != NULL)
      inf_session_send_to_subscriptions(session, xml);
    g_object_set(G_OBJECT(user), "status", status, NULL);
  }
}
void
inf_session_synchronize_from(InfSession* session)
{
  InfSessionPrivate* priv;
  InfCommunicationGroup* group;
  InfXmlConnection* connection;
  g_return_if_fail(inf_session_get_status(session) == INF_SESSION_PRESYNC);
  priv = INF_SESSION_PRIVATE(session);
  g_return_if_fail(priv-&gt;shared.presync.closing == FALSE);
  group = priv-&gt;shared.presync.group;
  connection = priv-&gt;shared.presync.conn;
  priv-&gt;status = INF_SESSION_SYNCHRONIZING;
  priv-&gt;shared.sync.group = group;
  priv-&gt;shared.sync.conn = connection;
  priv-&gt;shared.sync.messages_total = 0;
  priv-&gt;shared.sync.messages_received = 0;
  priv-&gt;shared.sync.closing = FALSE;
  g_object_notify(G_OBJECT(session), "status");
}
void
inf_session_synchronize_to(InfSession* session,
                           InfCommunicationGroup* group,
                           InfXmlConnection* connection)
{
  g_return_if_fail(INF_IS_SESSION(session));
  g_return_if_fail(group != NULL);
  g_return_if_fail(INF_IS_XML_CONNECTION(connection));
  g_return_if_fail(inf_session_get_status(session) == INF_SESSION_RUNNING);
  g_return_if_fail(
    inf_session_find_sync_by_connection(session, connection) == NULL
  );
  g_signal_emit(
    G_OBJECT(session),
    session_signals[SYNCHRONIZATION_BEGIN],
    0,
    group,
    connection
  );
}
void
inf_session_cancel_synchronization(InfSession* session,
                                   InfXmlConnection* connection)
{
  InfSessionPrivate* priv;
  InfXmlConnectionStatus status;
  InfSessionSync* sync;
  xmlNodePtr xml;
  GError* error;
  g_return_if_fail(INF_IS_SESSION(session));
  g_return_if_fail(INF_IS_XML_CONNECTION(connection));
  priv = INF_SESSION_PRIVATE(session);
  error = NULL;
  switch(priv-&gt;status)
  {
  case INF_SESSION_PRESYNC:
    g_return_if_fail(connection == priv-&gt;shared.presync.conn);
    g_set_error_literal(
      &amp;error,
      inf_session_sync_error_quark,
      INF_SESSION_SYNC_ERROR_RECEIVER_CANCELLED,
      inf_session_sync_strerror(INF_SESSION_SYNC_ERROR_RECEIVER_CANCELLED)
    );
    break;
  case INF_SESSION_SYNCHRONIZING:
    g_return_if_fail(connection == priv-&gt;shared.sync.conn);
    g_set_error_literal(
      &amp;error,
      inf_session_sync_error_quark,
      INF_SESSION_SYNC_ERROR_RECEIVER_CANCELLED,
      inf_session_sync_strerror(INF_SESSION_SYNC_ERROR_RECEIVER_CANCELLED)
    );
    g_object_get(G_OBJECT(connection), "status", &amp;status, NULL);
    if(status == INF_XML_CONNECTION_OPEN)
      inf_session_send_sync_error(session, error);
    break;
  case INF_SESSION_RUNNING:
    sync = inf_session_find_sync_by_connection(session, connection);
    g_return_if_fail(sync != NULL);
    if(sync-&gt;status == INF_SESSION_SYNC_IN_PROGRESS)
    {
      inf_communication_group_cancel_messages(sync-&gt;group, sync-&gt;conn);
      xml = xmlNewNode(NULL, (const xmlChar*)"sync-cancel");
      inf_communication_group_send_message(sync-&gt;group, sync-&gt;conn, xml);
    }
    g_set_error_literal(
      &amp;error,
      inf_session_sync_error_quark,
      INF_SESSION_SYNC_ERROR_SENDER_CANCELLED,
      inf_session_sync_strerror(INF_SESSION_SYNC_ERROR_SENDER_CANCELLED)
    );
    break;
  case INF_SESSION_CLOSED:
    g_return_if_reached();
    break;
  default:
    g_assert_not_reached();
    break;
  }
  g_signal_emit(
    G_OBJECT(session),
    session_signals[SYNCHRONIZATION_FAILED],
    0,
    connection,
    error
  );
  g_error_free(error);
}
InfSessionSyncStatus
inf_session_get_synchronization_status(InfSession* session,
                                       InfXmlConnection* connection)
{
  InfSessionPrivate* priv;
  InfSessionSync* sync;
  g_return_val_if_fail(INF_IS_SESSION(session), INF_SESSION_SYNC_NONE);
  g_return_val_if_fail(
    INF_IS_XML_CONNECTION(connection),
    INF_SESSION_SYNC_NONE
  );
  priv = INF_SESSION_PRIVATE(session);
  switch(priv-&gt;status)
  {
  case INF_SESSION_SYNCHRONIZING:
    if(connection == priv-&gt;shared.sync.conn)
      return INF_SESSION_SYNC_IN_PROGRESS;
    return INF_SESSION_SYNC_NONE;
  case INF_SESSION_RUNNING:
    sync = inf_session_find_sync_by_connection(session, connection);
    if(sync == NULL) return INF_SESSION_SYNC_NONE;
    return sync-&gt;status;
  case INF_SESSION_CLOSED:
    return INF_SESSION_SYNC_NONE;
  default:
    g_assert_not_reached();
    break;
  }
}
gdouble
inf_session_get_synchronization_progress(InfSession* session,
                                         InfXmlConnection* connection)
{
  InfSessionPrivate* priv;
  InfSessionSync* sync;
  g_return_val_if_fail(INF_IS_SESSION(session), 0.0);
  g_return_val_if_fail(INF_IS_XML_CONNECTION(connection), 0.0);
  g_return_val_if_fail(
    inf_session_get_synchronization_status(
      session,
      connection
    ) != INF_SESSION_SYNC_NONE,
    0.0
  );
  priv = INF_SESSION_PRIVATE(session);
  switch(priv-&gt;status)
  {
  case INF_SESSION_PRESYNC:
    g_assert(connection == priv-&gt;shared.presync.conn);
    return 0.0;
  case INF_SESSION_SYNCHRONIZING:
    g_assert(connection == priv-&gt;shared.sync.conn);
    if(priv-&gt;shared.sync.messages_total == 0)
      return 0.0;
    return (gdouble)priv-&gt;shared.sync.messages_received /
           (gdouble)priv-&gt;shared.sync.messages_total;
  case INF_SESSION_RUNNING:
    sync = inf_session_find_sync_by_connection(session, connection);
    g_assert(sync != NULL);
    return (gdouble)sync-&gt;messages_sent / (gdouble)sync-&gt;messages_total;
  case INF_SESSION_CLOSED:
  default:
    g_assert_not_reached();
    return 0.0;
  }
}
gboolean
inf_session_has_synchronizations(InfSession* session)
{
  InfSessionPrivate* priv;
  g_return_val_if_fail(INF_IS_SESSION(session), FALSE);
  priv = INF_SESSION_PRIVATE(session);
  switch(priv-&gt;status)
  {
  case INF_SESSION_PRESYNC:
  case INF_SESSION_SYNCHRONIZING:
    return TRUE;
  case INF_SESSION_RUNNING:
    if(priv-&gt;shared.run.syncs == NULL)
      return FALSE;
    else
      return TRUE;
  case INF_SESSION_CLOSED:
    return FALSE;
  default:
    g_assert_not_reached();
    return FALSE;
  }
}
InfCommunicationGroup*
inf_session_get_subscription_group(InfSession* session)
{
  g_return_val_if_fail(INF_IS_SESSION(session), NULL);
  return INF_SESSION_PRIVATE(session)-&gt;subscription_group;
}
void
inf_session_set_subscription_group(InfSession* session,
                                   InfCommunicationGroup* group)
{
  InfSessionPrivate* priv;
  g_return_if_fail(INF_IS_SESSION(session));
  priv = INF_SESSION_PRIVATE(session);
  if(priv-&gt;subscription_group != group)
  {
    if(priv-&gt;subscription_group != NULL)
      g_object_unref(priv-&gt;subscription_group);
    priv-&gt;subscription_group = group;
    if(group != NULL)
      g_object_ref(group);
    g_object_notify(G_OBJECT(session), "subscription-group");
  }
}
void
inf_session_send_to_subscriptions(InfSession* session,
                                  xmlNodePtr xml)
{
  InfSessionPrivate* priv;
  g_return_if_fail(INF_IS_SESSION(session));
  g_return_if_fail(xml != NULL);
  priv = INF_SESSION_PRIVATE(session);
  g_return_if_fail(priv-&gt;subscription_group != NULL);
  inf_communication_group_send_group_message(priv-&gt;subscription_group, xml);
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
