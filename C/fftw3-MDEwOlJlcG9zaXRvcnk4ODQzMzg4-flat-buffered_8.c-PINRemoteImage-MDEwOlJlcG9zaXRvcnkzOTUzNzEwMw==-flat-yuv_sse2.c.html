
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.208754208754209%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-buffered_8.c</h3>
            <pre><code>1  #include "rdft/rdft.h"
2  typedef struct {
3       solver super;
4       size_t maxnbuf_ndx;
5  } S;
6  static const INT maxnbufs[] = { 8, 256 };
7  typedef struct {
8       plan_rdft super;
9       plan *cld, *cldcpy, *cldrest;
10       INT n, vl, nbuf, bufdist;
11       INT ivs_by_nbuf, ovs_by_nbuf;
12  } P;
13  static void apply(const plan *ego_, R *I, R *O)
14  {
15       const P *ego = (const P *) ego_;
16       plan_rdft *cld = (plan_rdft *) ego->cld;
17       plan_rdft *cldcpy = (plan_rdft *) ego->cldcpy;
18       plan_rdft *cldrest;
19       INT i, vl = ego->vl, nbuf = ego->nbuf;
20       INT ivs_by_nbuf = ego->ivs_by_nbuf, ovs_by_nbuf = ego->ovs_by_nbuf;
21       R *bufs;
22       bufs = (R *)MALLOC(sizeof(R) * nbuf * ego->bufdist, BUFFERS);
23       for (i = nbuf; i <= vl; i += nbuf) {
24            cld->apply((plan *) cld, I, bufs);
25  	  I += ivs_by_nbuf;
26            cldcpy->apply((plan *) cldcpy, bufs, O);
27  	  O += ovs_by_nbuf;
28       }
29       X(ifree)(bufs);
30       cldrest = (plan_rdft *) ego->cldrest;
31       cldrest->apply((plan *) cldrest, I, O);
32  }
33  static void apply_hc2r(const plan *ego_, R *I, R *O)
34  {
35       const P *ego = (const P *) ego_;
36       plan_rdft *cld = (plan_rdft *) ego->cld;
37       plan_rdft *cldcpy = (plan_rdft *) ego->cldcpy;
38       plan_rdft *cldrest;
39       INT i, vl = ego->vl, nbuf = ego->nbuf;
40       INT ivs_by_nbuf = ego->ivs_by_nbuf, ovs_by_nbuf = ego->ovs_by_nbuf;
41       R *bufs;
42       bufs = (R *)MALLOC(sizeof(R) * nbuf * ego->bufdist, BUFFERS);
43       for (i = nbuf; i <= vl; i += nbuf) {
44            cldcpy->apply((plan *) cldcpy, I, bufs);
45  	  I += ivs_by_nbuf;
46            cld->apply((plan *) cld, bufs, O);
47  	  O += ovs_by_nbuf;
48       }
49       X(ifree)(bufs);
50       cldrest = (plan_rdft *) ego->cldrest;
51       cldrest->apply((plan *) cldrest, I, O);
52  }
53  static void awake(plan *ego_, enum wakefulness wakefulness)
54  {
55       P *ego = (P *) ego_;
56       X(plan_awake)(ego->cld, wakefulness);
57       X(plan_awake)(ego->cldcpy, wakefulness);
58       X(plan_awake)(ego->cldrest, wakefulness);
59  }
60  static void destroy(plan *ego_)
61  {
62       P *ego = (P *) ego_;
63       X(plan_destroy_internal)(ego->cldrest);
64       X(plan_destroy_internal)(ego->cldcpy);
65       X(plan_destroy_internal)(ego->cld);
66  }
67  static void print(const plan *ego_, printer *p)
68  {
69       const P *ego = (const P *) ego_;
70       p->print(p, "(rdft-buffered-%D%v/%D-%D%(%p%)%(%p%)%(%p%))",
71                ego->n, ego->nbuf,
72                ego->vl, ego->bufdist % ego->n,
73                ego->cld, ego->cldcpy, ego->cldrest);
74  }
<span onclick='openModal()' class='match'>75  static int applicable0(const S *ego, const problem *p_, const planner *plnr)
76  {
77       const problem_rdft *p = (const problem_rdft *) p_;
78       iodim *d = p->sz->dims;
</span>79       if (1
80  	 && p->vecsz->rnk <= 1
81  	 && p->sz->rnk == 1
82  	  ) {
83  	  INT vl, ivs, ovs;
84  	  X(tensor_tornk1)(p->vecsz, &vl, &ivs, &ovs);
85  	  if (X(toobig)(d[0].n) && CONSERVE_MEMORYP(plnr))
86  	       return 0;
87  	  if (X(nbuf_redundant)(d[0].n, vl,
88  				ego->maxnbuf_ndx,
89  				maxnbufs, NELEM(maxnbufs)))
90  	       return 0;
91  	  if (p->I != p->O) {
92  	       if (p->kind[0] == HC2R) {
93  		    return (NO_DESTROY_INPUTP(plnr));
94  	       } else {
95  		    return (d[0].os > 1);
96  	       }
97  	  }
98  	  if (X(tensor_inplace_strides2)(p->sz, p->vecsz))
99  	       return 1;
100  	  if (&bsol;* fits into buffer: */
101  	       ((p->vecsz->rnk == 0)
102  		||
103  		(X(nbuf)(d[0].n, p->vecsz->dims[0].n, 
104  			 maxnbufs[ego->maxnbuf_ndx]) 
105  		 == p->vecsz->dims[0].n)))
106  	       return 1;
107       }
108       return 0;
109  }
110  static int applicable(const S *ego, const problem *p_, const planner *plnr)
111  {
112       const problem_rdft *p;
113       if (NO_BUFFERINGP(plnr)) return 0;
114       if (!applicable0(ego, p_, plnr)) return 0;
115       p = (const problem_rdft *) p_;
116       if (p->kind[0] == HC2R) {
117  	  if (NO_UGLYP(plnr)) {
118  	       if (p->I == p->O && X(toobig)(p->sz->dims[0].n)) 
119  		    return 0;
120  	  }
121       } else {
122  	  if (NO_UGLYP(plnr)) {
123  	       if (p->I != p->O) return 0;
124  	       if (X(toobig)(p->sz->dims[0].n)) return 0;
125  	  }
126       }
127       return 1;
128  }
129  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
130  {
131       P *pln;
132       const S *ego = (const S *)ego_;
133       plan *cld = (plan *) 0;
134       plan *cldcpy = (plan *) 0;
135       plan *cldrest = (plan *) 0;
136       const problem_rdft *p = (const problem_rdft *) p_;
137       R *bufs = (R *) 0;
138       INT nbuf = 0, bufdist, n, vl;
139       INT ivs, ovs;
140       int hc2rp;
141       static const plan_adt padt = {
142  	  X(rdft_solve), awake, print, destroy
143       };
144       if (!applicable(ego, p_, plnr))
145            goto nada;
146       n = X(tensor_sz)(p->sz);
147       X(tensor_tornk1)(p->vecsz, &vl, &ivs, &ovs);
148       hc2rp = (p->kind[0] == HC2R);
149       nbuf = X(nbuf)(n, vl, maxnbufs[ego->maxnbuf_ndx]);
150       bufdist = X(bufdist)(n, vl);
151       A(nbuf > 0);
152       bufs = (R *) MALLOC(sizeof(R) * nbuf * bufdist, BUFFERS);
153       if (hc2rp) {
154  	  cld = X(mkplan_f_d)(plnr, 
155  			      X(mkproblem_rdft_d)(
156  				   X(mktensor_1d)(n, 1, p->sz->dims[0].os),
157  				   X(mktensor_1d)(nbuf, bufdist, ovs),
158  				   bufs, TAINT(p->O, ovs * nbuf), p->kind),
159  			      0, 0, NO_DESTROY_INPUT);
160  	  if (!cld) goto nada;
161  	  cldcpy = X(mkplan_d)(plnr, 
162  			       X(mkproblem_rdft_0_d)(
163  				    X(mktensor_2d)(nbuf, ivs, bufdist,
164  						   n, p->sz->dims[0].is, 1),
165  				    TAINT(p->I, ivs * nbuf), bufs));
166  	  if (!cldcpy) goto nada;
167       } else {
168  	  cld = X(mkplan_f_d)(plnr, 
169  			      X(mkproblem_rdft_d)(
170  				   X(mktensor_1d)(n, p->sz->dims[0].is, 1),
171  				   X(mktensor_1d)(nbuf, ivs, bufdist),
172  				   TAINT(p->I, ivs * nbuf), bufs, p->kind),
173  			      0, 0, (p->I == p->O) ? NO_DESTROY_INPUT : 0);
174  	  if (!cld) goto nada;
175  	  cldcpy = X(mkplan_d)(plnr, 
176  			       X(mkproblem_rdft_0_d)(
177  				    X(mktensor_2d)(nbuf, bufdist, ovs,
178  						   n, 1, p->sz->dims[0].os),
179  				    bufs, TAINT(p->O, ovs * nbuf)));
180  	  if (!cldcpy) goto nada;
181       }
182       X(ifree)(bufs);
183       bufs = 0;
184       {
185  	  INT id = ivs * (nbuf * (vl / nbuf));
186  	  INT od = ovs * (nbuf * (vl / nbuf));
187  	  cldrest = X(mkplan_d)(plnr, 
188  				X(mkproblem_rdft_d)(
189  				     X(tensor_copy)(p->sz),
190  				     X(mktensor_1d)(vl % nbuf, ivs, ovs),
191  				     p->I + id, p->O + od, p->kind));
192       }
193       if (!cldrest) goto nada;
194       pln = MKPLAN_RDFT(P, &padt, hc2rp ? apply_hc2r : apply);
195       pln->cld = cld;
196       pln->cldcpy = cldcpy;
197       pln->cldrest = cldrest;
198       pln->n = n;
199       pln->vl = vl;
200       pln->ivs_by_nbuf = ivs * nbuf;
201       pln->ovs_by_nbuf = ovs * nbuf;
202       pln->nbuf = nbuf;
203       pln->bufdist = bufdist;
204       {
205  	  opcnt t;
206  	  X(ops_add)(&cld->ops, &cldcpy->ops, &t);
207  	  X(ops_madd)(vl / nbuf, &t, &cldrest->ops, &pln->super.super.ops);
208       }
209       return &(pln->super.super);
210   nada:
211       X(ifree0)(bufs);
212       X(plan_destroy_internal)(cldrest);
213       X(plan_destroy_internal)(cldcpy);
214       X(plan_destroy_internal)(cld);
215       return (plan *) 0;
216  }
217  static solver *mksolver(size_t maxnbuf_ndx)
218  {
219       static const solver_adt sadt = { PROBLEM_RDFT, mkplan, 0 };
220       S *slv = MKSOLVER(S, &sadt);
221       slv->maxnbuf_ndx = maxnbuf_ndx;
222       return &(slv->super);
223  }
224  void X(rdft_buffered_register)(planner *p)
225  {
226       size_t i;
227       for (i = 0; i < NELEM(maxnbufs); ++i)
228  	  REGISTER_SOLVER(p, mksolver(i));
229  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-yuv_sse2.c</h3>
            <pre><code>1  #include "src/dsp/yuv.h"
2  #if defined(WEBP_USE_SSE2)
3  #include "src/dsp/common_sse2.h"
4  #include <stdlib.h>
5  #include <emmintrin.h>
6  static void ConvertYUV444ToRGB_SSE2(const __m128i* const Y0,
7                                      const __m128i* const U0,
8                                      const __m128i* const V0,
<span onclick='openModal()' class='match'>9                                      __m128i* const R,
10                                      __m128i* const G,
11                                      __m128i* const B) {
12    const __m128i k19077 = _mm_set1_epi16(19077);
13    const __m128i k26149 = _mm_set1_epi16(26149);
</span>14    const __m128i k14234 = _mm_set1_epi16(14234);
15    const __m128i k33050 = _mm_set1_epi16((short)33050);
16    const __m128i k17685 = _mm_set1_epi16(17685);
17    const __m128i k6419  = _mm_set1_epi16(6419);
18    const __m128i k13320 = _mm_set1_epi16(13320);
19    const __m128i k8708  = _mm_set1_epi16(8708);
20    const __m128i Y1 = _mm_mulhi_epu16(*Y0, k19077);
21    const __m128i R0 = _mm_mulhi_epu16(*V0, k26149);
22    const __m128i R1 = _mm_sub_epi16(Y1, k14234);
23    const __m128i R2 = _mm_add_epi16(R1, R0);
24    const __m128i G0 = _mm_mulhi_epu16(*U0, k6419);
25    const __m128i G1 = _mm_mulhi_epu16(*V0, k13320);
26    const __m128i G2 = _mm_add_epi16(Y1, k8708);
27    const __m128i G3 = _mm_add_epi16(G0, G1);
28    const __m128i G4 = _mm_sub_epi16(G2, G3);
29    const __m128i B0 = _mm_mulhi_epu16(*U0, k33050);
30    const __m128i B1 = _mm_adds_epu16(B0, Y1);
31    const __m128i B2 = _mm_subs_epu16(B1, k17685);
32    *R = _mm_srai_epi16(R2, 6);   
33    *G = _mm_srai_epi16(G4, 6);   
34    *B = _mm_srli_epi16(B2, 6);   
35  }
36  static WEBP_INLINE __m128i Load_HI_16_SSE2(const uint8_t* src) {
37    const __m128i zero = _mm_setzero_si128();
38    return _mm_unpacklo_epi8(zero, _mm_loadl_epi64((const __m128i*)src));
39  }
40  static WEBP_INLINE __m128i Load_UV_HI_8_SSE2(const uint8_t* src) {
41    const __m128i zero = _mm_setzero_si128();
42    const __m128i tmp0 = _mm_cvtsi32_si128(*(const uint32_t*)src);
43    const __m128i tmp1 = _mm_unpacklo_epi8(zero, tmp0);
44    return _mm_unpacklo_epi16(tmp1, tmp1);   
45  }
46  static void YUV444ToRGB_SSE2(const uint8_t* const y,
47                               const uint8_t* const u,
48                               const uint8_t* const v,
49                               __m128i* const R, __m128i* const G,
50                               __m128i* const B) {
51    const __m128i Y0 = Load_HI_16_SSE2(y), U0 = Load_HI_16_SSE2(u),
52                  V0 = Load_HI_16_SSE2(v);
53    ConvertYUV444ToRGB_SSE2(&Y0, &U0, &V0, R, G, B);
54  }
55  static void YUV420ToRGB_SSE2(const uint8_t* const y,
56                               const uint8_t* const u,
57                               const uint8_t* const v,
58                               __m128i* const R, __m128i* const G,
59                               __m128i* const B) {
60    const __m128i Y0 = Load_HI_16_SSE2(y), U0 = Load_UV_HI_8_SSE2(u),
61                  V0 = Load_UV_HI_8_SSE2(v);
62    ConvertYUV444ToRGB_SSE2(&Y0, &U0, &V0, R, G, B);
63  }
64  static WEBP_INLINE void PackAndStore4_SSE2(const __m128i* const R,
65                                             const __m128i* const G,
66                                             const __m128i* const B,
67                                             const __m128i* const A,
68                                             uint8_t* const dst) {
69    const __m128i rb = _mm_packus_epi16(*R, *B);
70    const __m128i ga = _mm_packus_epi16(*G, *A);
71    const __m128i rg = _mm_unpacklo_epi8(rb, ga);
72    const __m128i ba = _mm_unpackhi_epi8(rb, ga);
73    const __m128i RGBA_lo = _mm_unpacklo_epi16(rg, ba);
74    const __m128i RGBA_hi = _mm_unpackhi_epi16(rg, ba);
75    _mm_storeu_si128((__m128i*)(dst +  0), RGBA_lo);
76    _mm_storeu_si128((__m128i*)(dst + 16), RGBA_hi);
77  }
78  static WEBP_INLINE void PackAndStore4444_SSE2(const __m128i* const R,
79                                                const __m128i* const G,
80                                                const __m128i* const B,
81                                                const __m128i* const A,
82                                                uint8_t* const dst) {
83  #if (WEBP_SWAP_16BIT_CSP == 0)
84    const __m128i rg0 = _mm_packus_epi16(*R, *G);
85    const __m128i ba0 = _mm_packus_epi16(*B, *A);
86  #else
87    const __m128i rg0 = _mm_packus_epi16(*B, *A);
88    const __m128i ba0 = _mm_packus_epi16(*R, *G);
89  #endif
90    const __m128i mask_0xf0 = _mm_set1_epi8(0xf0);
91    const __m128i rb1 = _mm_unpacklo_epi8(rg0, ba0);  
92    const __m128i ga1 = _mm_unpackhi_epi8(rg0, ba0);  
93    const __m128i rb2 = _mm_and_si128(rb1, mask_0xf0);
94    const __m128i ga2 = _mm_srli_epi16(_mm_and_si128(ga1, mask_0xf0), 4);
95    const __m128i rgba4444 = _mm_or_si128(rb2, ga2);
96    _mm_storeu_si128((__m128i*)dst, rgba4444);
97  }
98  static WEBP_INLINE void PackAndStore565_SSE2(const __m128i* const R,
99                                               const __m128i* const G,
100                                               const __m128i* const B,
101                                               uint8_t* const dst) {
102    const __m128i r0 = _mm_packus_epi16(*R, *R);
103    const __m128i g0 = _mm_packus_epi16(*G, *G);
104    const __m128i b0 = _mm_packus_epi16(*B, *B);
105    const __m128i r1 = _mm_and_si128(r0, _mm_set1_epi8(0xf8));
106    const __m128i b1 = _mm_and_si128(_mm_srli_epi16(b0, 3), _mm_set1_epi8(0x1f));
107    const __m128i g1 = _mm_srli_epi16(_mm_and_si128(g0, _mm_set1_epi8(0xe0)), 5);
108    const __m128i g2 = _mm_slli_epi16(_mm_and_si128(g0, _mm_set1_epi8(0x1c)), 3);
109    const __m128i rg = _mm_or_si128(r1, g1);
110    const __m128i gb = _mm_or_si128(g2, b1);
111  #if (WEBP_SWAP_16BIT_CSP == 0)
112    const __m128i rgb565 = _mm_unpacklo_epi8(rg, gb);
113  #else
114    const __m128i rgb565 = _mm_unpacklo_epi8(gb, rg);
115  #endif
116    _mm_storeu_si128((__m128i*)dst, rgb565);
117  }
118  static WEBP_INLINE void PlanarTo24b_SSE2(__m128i* const in0, __m128i* const in1,
119                                           __m128i* const in2, __m128i* const in3,
120                                           __m128i* const in4, __m128i* const in5,
121                                           uint8_t* const rgb) {
122    VP8PlanarTo24b_SSE2(in0, in1, in2, in3, in4, in5);
123    _mm_storeu_si128((__m128i*)(rgb +  0), *in0);
124    _mm_storeu_si128((__m128i*)(rgb + 16), *in1);
125    _mm_storeu_si128((__m128i*)(rgb + 32), *in2);
126    _mm_storeu_si128((__m128i*)(rgb + 48), *in3);
127    _mm_storeu_si128((__m128i*)(rgb + 64), *in4);
128    _mm_storeu_si128((__m128i*)(rgb + 80), *in5);
129  }
130  void VP8YuvToRgba32_SSE2(const uint8_t* y, const uint8_t* u, const uint8_t* v,
131                           uint8_t* dst) {
132    const __m128i kAlpha = _mm_set1_epi16(255);
133    int n;
134    for (n = 0; n < 32; n += 8, dst += 32) {
135      __m128i R, G, B;
136      YUV444ToRGB_SSE2(y + n, u + n, v + n, &R, &G, &B);
137      PackAndStore4_SSE2(&R, &G, &B, &kAlpha, dst);
138    }
139  }
140  void VP8YuvToBgra32_SSE2(const uint8_t* y, const uint8_t* u, const uint8_t* v,
141                           uint8_t* dst) {
142    const __m128i kAlpha = _mm_set1_epi16(255);
143    int n;
144    for (n = 0; n < 32; n += 8, dst += 32) {
145      __m128i R, G, B;
146      YUV444ToRGB_SSE2(y + n, u + n, v + n, &R, &G, &B);
147      PackAndStore4_SSE2(&B, &G, &R, &kAlpha, dst);
148    }
149  }
150  void VP8YuvToArgb32_SSE2(const uint8_t* y, const uint8_t* u, const uint8_t* v,
151                           uint8_t* dst) {
152    const __m128i kAlpha = _mm_set1_epi16(255);
153    int n;
154    for (n = 0; n < 32; n += 8, dst += 32) {
155      __m128i R, G, B;
156      YUV444ToRGB_SSE2(y + n, u + n, v + n, &R, &G, &B);
157      PackAndStore4_SSE2(&kAlpha, &R, &G, &B, dst);
158    }
159  }
160  void VP8YuvToRgba444432_SSE2(const uint8_t* y, const uint8_t* u,
161                               const uint8_t* v, uint8_t* dst) {
162    const __m128i kAlpha = _mm_set1_epi16(255);
163    int n;
164    for (n = 0; n < 32; n += 8, dst += 16) {
165      __m128i R, G, B;
166      YUV444ToRGB_SSE2(y + n, u + n, v + n, &R, &G, &B);
167      PackAndStore4444_SSE2(&R, &G, &B, &kAlpha, dst);
168    }
169  }
170  void VP8YuvToRgb56532_SSE2(const uint8_t* y, const uint8_t* u, const uint8_t* v,
171                             uint8_t* dst) {
172    int n;
173    for (n = 0; n < 32; n += 8, dst += 16) {
174      __m128i R, G, B;
175      YUV444ToRGB_SSE2(y + n, u + n, v + n, &R, &G, &B);
176      PackAndStore565_SSE2(&R, &G, &B, dst);
177    }
178  }
179  void VP8YuvToRgb32_SSE2(const uint8_t* y, const uint8_t* u, const uint8_t* v,
180                          uint8_t* dst) {
181    __m128i R0, R1, R2, R3, G0, G1, G2, G3, B0, B1, B2, B3;
182    __m128i rgb0, rgb1, rgb2, rgb3, rgb4, rgb5;
183    YUV444ToRGB_SSE2(y + 0, u + 0, v + 0, &R0, &G0, &B0);
184    YUV444ToRGB_SSE2(y + 8, u + 8, v + 8, &R1, &G1, &B1);
185    YUV444ToRGB_SSE2(y + 16, u + 16, v + 16, &R2, &G2, &B2);
186    YUV444ToRGB_SSE2(y + 24, u + 24, v + 24, &R3, &G3, &B3);
187    rgb0 = _mm_packus_epi16(R0, R1);
188    rgb1 = _mm_packus_epi16(R2, R3);
189    rgb2 = _mm_packus_epi16(G0, G1);
190    rgb3 = _mm_packus_epi16(G2, G3);
191    rgb4 = _mm_packus_epi16(B0, B1);
192    rgb5 = _mm_packus_epi16(B2, B3);
193    PlanarTo24b_SSE2(&rgb0, &rgb1, &rgb2, &rgb3, &rgb4, &rgb5, dst);
194  }
195  void VP8YuvToBgr32_SSE2(const uint8_t* y, const uint8_t* u, const uint8_t* v,
196                          uint8_t* dst) {
197    __m128i R0, R1, R2, R3, G0, G1, G2, G3, B0, B1, B2, B3;
198    __m128i bgr0, bgr1, bgr2, bgr3, bgr4, bgr5;
199    YUV444ToRGB_SSE2(y +  0, u +  0, v +  0, &R0, &G0, &B0);
200    YUV444ToRGB_SSE2(y +  8, u +  8, v +  8, &R1, &G1, &B1);
201    YUV444ToRGB_SSE2(y + 16, u + 16, v + 16, &R2, &G2, &B2);
202    YUV444ToRGB_SSE2(y + 24, u + 24, v + 24, &R3, &G3, &B3);
203    bgr0 = _mm_packus_epi16(B0, B1);
204    bgr1 = _mm_packus_epi16(B2, B3);
205    bgr2 = _mm_packus_epi16(G0, G1);
206    bgr3 = _mm_packus_epi16(G2, G3);
207    bgr4 = _mm_packus_epi16(R0, R1);
208    bgr5= _mm_packus_epi16(R2, R3);
209    PlanarTo24b_SSE2(&bgr0, &bgr1, &bgr2, &bgr3, &bgr4, &bgr5, dst);
210  }
211  static void YuvToRgbaRow_SSE2(const uint8_t* y,
212                                const uint8_t* u, const uint8_t* v,
213                                uint8_t* dst, int len) {
214    const __m128i kAlpha = _mm_set1_epi16(255);
215    int n;
216    for (n = 0; n + 8 <= len; n += 8, dst += 32) {
217      __m128i R, G, B;
218      YUV420ToRGB_SSE2(y, u, v, &R, &G, &B);
219      PackAndStore4_SSE2(&R, &G, &B, &kAlpha, dst);
220      y += 8;
221      u += 4;
222      v += 4;
223    }
224    for (; n < len; ++n) {   
225      VP8YuvToRgba(y[0], u[0], v[0], dst);
226      dst += 4;
227      y += 1;
228      u += (n & 1);
229      v += (n & 1);
230    }
231  }
232  static void YuvToBgraRow_SSE2(const uint8_t* y,
233                                const uint8_t* u, const uint8_t* v,
234                                uint8_t* dst, int len) {
235    const __m128i kAlpha = _mm_set1_epi16(255);
236    int n;
237    for (n = 0; n + 8 <= len; n += 8, dst += 32) {
238      __m128i R, G, B;
239      YUV420ToRGB_SSE2(y, u, v, &R, &G, &B);
240      PackAndStore4_SSE2(&B, &G, &R, &kAlpha, dst);
241      y += 8;
242      u += 4;
243      v += 4;
244    }
245    for (; n < len; ++n) {   
246      VP8YuvToBgra(y[0], u[0], v[0], dst);
247      dst += 4;
248      y += 1;
249      u += (n & 1);
250      v += (n & 1);
251    }
252  }
253  static void YuvToArgbRow_SSE2(const uint8_t* y,
254                                const uint8_t* u, const uint8_t* v,
255                                uint8_t* dst, int len) {
256    const __m128i kAlpha = _mm_set1_epi16(255);
257    int n;
258    for (n = 0; n + 8 <= len; n += 8, dst += 32) {
259      __m128i R, G, B;
260      YUV420ToRGB_SSE2(y, u, v, &R, &G, &B);
261      PackAndStore4_SSE2(&kAlpha, &R, &G, &B, dst);
262      y += 8;
263      u += 4;
264      v += 4;
265    }
266    for (; n < len; ++n) {   
267      VP8YuvToArgb(y[0], u[0], v[0], dst);
268      dst += 4;
269      y += 1;
270      u += (n & 1);
271      v += (n & 1);
272    }
273  }
274  static void YuvToRgbRow_SSE2(const uint8_t* y,
275                               const uint8_t* u, const uint8_t* v,
276                               uint8_t* dst, int len) {
277    int n;
278    for (n = 0; n + 32 <= len; n += 32, dst += 32 * 3) {
279      __m128i R0, R1, R2, R3, G0, G1, G2, G3, B0, B1, B2, B3;
280      __m128i rgb0, rgb1, rgb2, rgb3, rgb4, rgb5;
281      YUV420ToRGB_SSE2(y +  0, u +  0, v +  0, &R0, &G0, &B0);
282      YUV420ToRGB_SSE2(y +  8, u +  4, v +  4, &R1, &G1, &B1);
283      YUV420ToRGB_SSE2(y + 16, u +  8, v +  8, &R2, &G2, &B2);
284      YUV420ToRGB_SSE2(y + 24, u + 12, v + 12, &R3, &G3, &B3);
285      rgb0 = _mm_packus_epi16(R0, R1);
286      rgb1 = _mm_packus_epi16(R2, R3);
287      rgb2 = _mm_packus_epi16(G0, G1);
288      rgb3 = _mm_packus_epi16(G2, G3);
289      rgb4 = _mm_packus_epi16(B0, B1);
290      rgb5 = _mm_packus_epi16(B2, B3);
291      PlanarTo24b_SSE2(&rgb0, &rgb1, &rgb2, &rgb3, &rgb4, &rgb5, dst);
292      y += 32;
293      u += 16;
294      v += 16;
295    }
296    for (; n < len; ++n) {   
297      VP8YuvToRgb(y[0], u[0], v[0], dst);
298      dst += 3;
299      y += 1;
300      u += (n & 1);
301      v += (n & 1);
302    }
303  }
304  static void YuvToBgrRow_SSE2(const uint8_t* y,
305                               const uint8_t* u, const uint8_t* v,
306                               uint8_t* dst, int len) {
307    int n;
308    for (n = 0; n + 32 <= len; n += 32, dst += 32 * 3) {
309      __m128i R0, R1, R2, R3, G0, G1, G2, G3, B0, B1, B2, B3;
310      __m128i bgr0, bgr1, bgr2, bgr3, bgr4, bgr5;
311      YUV420ToRGB_SSE2(y +  0, u +  0, v +  0, &R0, &G0, &B0);
312      YUV420ToRGB_SSE2(y +  8, u +  4, v +  4, &R1, &G1, &B1);
313      YUV420ToRGB_SSE2(y + 16, u +  8, v +  8, &R2, &G2, &B2);
314      YUV420ToRGB_SSE2(y + 24, u + 12, v + 12, &R3, &G3, &B3);
315      bgr0 = _mm_packus_epi16(B0, B1);
316      bgr1 = _mm_packus_epi16(B2, B3);
317      bgr2 = _mm_packus_epi16(G0, G1);
318      bgr3 = _mm_packus_epi16(G2, G3);
319      bgr4 = _mm_packus_epi16(R0, R1);
320      bgr5 = _mm_packus_epi16(R2, R3);
321      PlanarTo24b_SSE2(&bgr0, &bgr1, &bgr2, &bgr3, &bgr4, &bgr5, dst);
322      y += 32;
323      u += 16;
324      v += 16;
325    }
326    for (; n < len; ++n) {   
327      VP8YuvToBgr(y[0], u[0], v[0], dst);
328      dst += 3;
329      y += 1;
330      u += (n & 1);
331      v += (n & 1);
332    }
333  }
334  extern void WebPInitSamplersSSE2(void);
335  WEBP_TSAN_IGNORE_FUNCTION void WebPInitSamplersSSE2(void) {
336    WebPSamplers[MODE_RGB]  = YuvToRgbRow_SSE2;
337    WebPSamplers[MODE_RGBA] = YuvToRgbaRow_SSE2;
338    WebPSamplers[MODE_BGR]  = YuvToBgrRow_SSE2;
339    WebPSamplers[MODE_BGRA] = YuvToBgraRow_SSE2;
340    WebPSamplers[MODE_ARGB] = YuvToArgbRow_SSE2;
341  }
342  #define LOAD_16(src) _mm_loadu_si128((const __m128i*)(src))
343  #define STORE_16(V, dst) _mm_storeu_si128((__m128i*)(dst), (V))
344  static WEBP_INLINE void RGB24PackedToPlanarHelper_SSE2(
345      const __m128i* const in &bsol;*in[6]*/, __m128i* const out &bsol;*out[6]*/) {
346    out[0] = _mm_unpacklo_epi8(in[0], in[3]);
347    out[1] = _mm_unpackhi_epi8(in[0], in[3]);
348    out[2] = _mm_unpacklo_epi8(in[1], in[4]);
349    out[3] = _mm_unpackhi_epi8(in[1], in[4]);
350    out[4] = _mm_unpacklo_epi8(in[2], in[5]);
351    out[5] = _mm_unpackhi_epi8(in[2], in[5]);
352  }
353  static WEBP_INLINE void RGB24PackedToPlanar_SSE2(
354      const uint8_t* const rgb, __m128i* const out &bsol;*out[6]*/) {
355    __m128i tmp[6];
356    tmp[0] = _mm_loadu_si128((const __m128i*)(rgb +  0));
357    tmp[1] = _mm_loadu_si128((const __m128i*)(rgb + 16));
358    tmp[2] = _mm_loadu_si128((const __m128i*)(rgb + 32));
359    tmp[3] = _mm_loadu_si128((const __m128i*)(rgb + 48));
360    tmp[4] = _mm_loadu_si128((const __m128i*)(rgb + 64));
361    tmp[5] = _mm_loadu_si128((const __m128i*)(rgb + 80));
362    RGB24PackedToPlanarHelper_SSE2(tmp, out);
363    RGB24PackedToPlanarHelper_SSE2(out, tmp);
364    RGB24PackedToPlanarHelper_SSE2(tmp, out);
365    RGB24PackedToPlanarHelper_SSE2(out, tmp);
366    RGB24PackedToPlanarHelper_SSE2(tmp, out);
367  }
368  static WEBP_INLINE void RGB32PackedToPlanar_SSE2(const uint32_t* const argb,
369                                                   __m128i* const rgb &bsol;*in[6]*/) {
370    const __m128i zero = _mm_setzero_si128();
371    __m128i a0 = LOAD_16(argb + 0);
372    __m128i a1 = LOAD_16(argb + 4);
373    __m128i a2 = LOAD_16(argb + 8);
374    __m128i a3 = LOAD_16(argb + 12);
375    VP8L32bToPlanar_SSE2(&a0, &a1, &a2, &a3);
376    rgb[0] = _mm_unpacklo_epi8(a1, zero);
377    rgb[1] = _mm_unpackhi_epi8(a1, zero);
378    rgb[2] = _mm_unpacklo_epi8(a2, zero);
379    rgb[3] = _mm_unpackhi_epi8(a2, zero);
380    rgb[4] = _mm_unpacklo_epi8(a3, zero);
381    rgb[5] = _mm_unpackhi_epi8(a3, zero);
382  }
383  #define TRANSFORM(RG_LO, RG_HI, GB_LO, GB_HI, MULT_RG, MULT_GB, \
384                    ROUNDER, DESCALE_FIX, OUT) do {               \
385    const __m128i V0_lo = _mm_madd_epi16(RG_LO, MULT_RG);         \
386    const __m128i V0_hi = _mm_madd_epi16(RG_HI, MULT_RG);         \
387    const __m128i V1_lo = _mm_madd_epi16(GB_LO, MULT_GB);         \
388    const __m128i V1_hi = _mm_madd_epi16(GB_HI, MULT_GB);         \
389    const __m128i V2_lo = _mm_add_epi32(V0_lo, V1_lo);            \
390    const __m128i V2_hi = _mm_add_epi32(V0_hi, V1_hi);            \
391    const __m128i V3_lo = _mm_add_epi32(V2_lo, ROUNDER);          \
392    const __m128i V3_hi = _mm_add_epi32(V2_hi, ROUNDER);          \
393    const __m128i V5_lo = _mm_srai_epi32(V3_lo, DESCALE_FIX);     \
394    const __m128i V5_hi = _mm_srai_epi32(V3_hi, DESCALE_FIX);     \
395    (OUT) = _mm_packs_epi32(V5_lo, V5_hi);                        \
396  } while (0)
397  #define MK_CST_16(A, B) _mm_set_epi16((B), (A), (B), (A), (B), (A), (B), (A))
398  static WEBP_INLINE void ConvertRGBToY_SSE2(const __m128i* const R,
399                                             const __m128i* const G,
400                                             const __m128i* const B,
401                                             __m128i* const Y) {
402    const __m128i kRG_y = MK_CST_16(16839, 33059 - 16384);
403    const __m128i kGB_y = MK_CST_16(16384, 6420);
404    const __m128i kHALF_Y = _mm_set1_epi32((16 << YUV_FIX) + YUV_HALF);
405    const __m128i RG_lo = _mm_unpacklo_epi16(*R, *G);
406    const __m128i RG_hi = _mm_unpackhi_epi16(*R, *G);
407    const __m128i GB_lo = _mm_unpacklo_epi16(*G, *B);
408    const __m128i GB_hi = _mm_unpackhi_epi16(*G, *B);
409    TRANSFORM(RG_lo, RG_hi, GB_lo, GB_hi, kRG_y, kGB_y, kHALF_Y, YUV_FIX, *Y);
410  }
411  static WEBP_INLINE void ConvertRGBToUV_SSE2(const __m128i* const R,
412                                              const __m128i* const G,
413                                              const __m128i* const B,
414                                              __m128i* const U,
415                                              __m128i* const V) {
416    const __m128i kRG_u = MK_CST_16(-9719, -19081);
417    const __m128i kGB_u = MK_CST_16(0, 28800);
418    const __m128i kRG_v = MK_CST_16(28800, 0);
419    const __m128i kGB_v = MK_CST_16(-24116, -4684);
420    const __m128i kHALF_UV = _mm_set1_epi32(((128 << YUV_FIX) + YUV_HALF) << 2);
421    const __m128i RG_lo = _mm_unpacklo_epi16(*R, *G);
422    const __m128i RG_hi = _mm_unpackhi_epi16(*R, *G);
423    const __m128i GB_lo = _mm_unpacklo_epi16(*G, *B);
424    const __m128i GB_hi = _mm_unpackhi_epi16(*G, *B);
425    TRANSFORM(RG_lo, RG_hi, GB_lo, GB_hi, kRG_u, kGB_u,
426              kHALF_UV, YUV_FIX + 2, *U);
427    TRANSFORM(RG_lo, RG_hi, GB_lo, GB_hi, kRG_v, kGB_v,
428              kHALF_UV, YUV_FIX + 2, *V);
429  }
430  #undef MK_CST_16
431  #undef TRANSFORM
432  static void ConvertRGB24ToY_SSE2(const uint8_t* rgb, uint8_t* y, int width) {
433    const int max_width = width & ~31;
434    int i;
435    for (i = 0; i < max_width; rgb += 3 * 16 * 2) {
436      __m128i rgb_plane[6];
437      int j;
438      RGB24PackedToPlanar_SSE2(rgb, rgb_plane);
439      for (j = 0; j < 2; ++j, i += 16) {
440        const __m128i zero = _mm_setzero_si128();
441        __m128i r, g, b, Y0, Y1;
442        r = _mm_unpacklo_epi8(rgb_plane[0 + j], zero);
443        g = _mm_unpacklo_epi8(rgb_plane[2 + j], zero);
444        b = _mm_unpacklo_epi8(rgb_plane[4 + j], zero);
445        ConvertRGBToY_SSE2(&r, &g, &b, &Y0);
446        r = _mm_unpackhi_epi8(rgb_plane[0 + j], zero);
447        g = _mm_unpackhi_epi8(rgb_plane[2 + j], zero);
448        b = _mm_unpackhi_epi8(rgb_plane[4 + j], zero);
449        ConvertRGBToY_SSE2(&r, &g, &b, &Y1);
450        STORE_16(_mm_packus_epi16(Y0, Y1), y + i);
451      }
452    }
453    for (; i < width; ++i, rgb += 3) {   
454      y[i] = VP8RGBToY(rgb[0], rgb[1], rgb[2], YUV_HALF);
455    }
456  }
457  static void ConvertBGR24ToY_SSE2(const uint8_t* bgr, uint8_t* y, int width) {
458    const int max_width = width & ~31;
459    int i;
460    for (i = 0; i < max_width; bgr += 3 * 16 * 2) {
461      __m128i bgr_plane[6];
462      int j;
463      RGB24PackedToPlanar_SSE2(bgr, bgr_plane);
464      for (j = 0; j < 2; ++j, i += 16) {
465        const __m128i zero = _mm_setzero_si128();
466        __m128i r, g, b, Y0, Y1;
467        b = _mm_unpacklo_epi8(bgr_plane[0 + j], zero);
468        g = _mm_unpacklo_epi8(bgr_plane[2 + j], zero);
469        r = _mm_unpacklo_epi8(bgr_plane[4 + j], zero);
470        ConvertRGBToY_SSE2(&r, &g, &b, &Y0);
471        b = _mm_unpackhi_epi8(bgr_plane[0 + j], zero);
472        g = _mm_unpackhi_epi8(bgr_plane[2 + j], zero);
473        r = _mm_unpackhi_epi8(bgr_plane[4 + j], zero);
474        ConvertRGBToY_SSE2(&r, &g, &b, &Y1);
475        STORE_16(_mm_packus_epi16(Y0, Y1), y + i);
476      }
477    }
478    for (; i < width; ++i, bgr += 3) {  
479      y[i] = VP8RGBToY(bgr[2], bgr[1], bgr[0], YUV_HALF);
480    }
481  }
482  static void ConvertARGBToY_SSE2(const uint32_t* argb, uint8_t* y, int width) {
483    const int max_width = width & ~15;
484    int i;
485    for (i = 0; i < max_width; i += 16) {
486      __m128i Y0, Y1, rgb[6];
487      RGB32PackedToPlanar_SSE2(&argb[i], rgb);
488      ConvertRGBToY_SSE2(&rgb[0], &rgb[2], &rgb[4], &Y0);
489      ConvertRGBToY_SSE2(&rgb[1], &rgb[3], &rgb[5], &Y1);
490      STORE_16(_mm_packus_epi16(Y0, Y1), y + i);
491    }
492    for (; i < width; ++i) {   
493      const uint32_t p = argb[i];
494      y[i] = VP8RGBToY((p >> 16) & 0xff, (p >> 8) & 0xff, (p >>  0) & 0xff,
495                       YUV_HALF);
496    }
497  }
498  static void HorizontalAddPack_SSE2(const __m128i* const A,
499                                     const __m128i* const B,
500                                     __m128i* const out) {
501    const __m128i k2 = _mm_set1_epi16(2);
502    const __m128i C = _mm_madd_epi16(*A, k2);
503    const __m128i D = _mm_madd_epi16(*B, k2);
504    *out = _mm_packs_epi32(C, D);
505  }
506  static void ConvertARGBToUV_SSE2(const uint32_t* argb,
507                                   uint8_t* u, uint8_t* v,
508                                   int src_width, int do_store) {
509    const int max_width = src_width & ~31;
510    int i;
511    for (i = 0; i < max_width; i += 32, u += 16, v += 16) {
512      __m128i rgb[6], U0, V0, U1, V1;
513      RGB32PackedToPlanar_SSE2(&argb[i], rgb);
514      HorizontalAddPack_SSE2(&rgb[0], &rgb[1], &rgb[0]);
515      HorizontalAddPack_SSE2(&rgb[2], &rgb[3], &rgb[2]);
516      HorizontalAddPack_SSE2(&rgb[4], &rgb[5], &rgb[4]);
517      ConvertRGBToUV_SSE2(&rgb[0], &rgb[2], &rgb[4], &U0, &V0);
518      RGB32PackedToPlanar_SSE2(&argb[i + 16], rgb);
519      HorizontalAddPack_SSE2(&rgb[0], &rgb[1], &rgb[0]);
520      HorizontalAddPack_SSE2(&rgb[2], &rgb[3], &rgb[2]);
521      HorizontalAddPack_SSE2(&rgb[4], &rgb[5], &rgb[4]);
522      ConvertRGBToUV_SSE2(&rgb[0], &rgb[2], &rgb[4], &U1, &V1);
523      U0 = _mm_packus_epi16(U0, U1);
524      V0 = _mm_packus_epi16(V0, V1);
525      if (!do_store) {
526        const __m128i prev_u = LOAD_16(u);
527        const __m128i prev_v = LOAD_16(v);
528        U0 = _mm_avg_epu8(U0, prev_u);
529        V0 = _mm_avg_epu8(V0, prev_v);
530      }
531      STORE_16(U0, u);
532      STORE_16(V0, v);
533    }
534    if (i < src_width) {  
535      WebPConvertARGBToUV_C(argb + i, u, v, src_width - i, do_store);
536    }
537  }
538  static WEBP_INLINE void RGBA32PackedToPlanar_16b_SSE2(
539      const uint16_t* const rgbx,
540      __m128i* const r, __m128i* const g, __m128i* const b) {
541    const __m128i in0 = LOAD_16(rgbx +  0);  
542    const __m128i in1 = LOAD_16(rgbx +  8);  
543    const __m128i in2 = LOAD_16(rgbx + 16);  
544    const __m128i in3 = LOAD_16(rgbx + 24);  
545    const __m128i A0 = _mm_unpacklo_epi16(in0, in1);
546    const __m128i A1 = _mm_unpackhi_epi16(in0, in1);
547    const __m128i A2 = _mm_unpacklo_epi16(in2, in3);
548    const __m128i A3 = _mm_unpackhi_epi16(in2, in3);
549    const __m128i B0 = _mm_unpacklo_epi16(A0, A1);  
550    const __m128i B1 = _mm_unpackhi_epi16(A0, A1);  
551    const __m128i B2 = _mm_unpacklo_epi16(A2, A3);  
552    const __m128i B3 = _mm_unpackhi_epi16(A2, A3);  
553    *r = _mm_unpacklo_epi64(B0, B2);
554    *g = _mm_unpackhi_epi64(B0, B2);
555    *b = _mm_unpacklo_epi64(B1, B3);
556  }
557  static void ConvertRGBA32ToUV_SSE2(const uint16_t* rgb,
558                                     uint8_t* u, uint8_t* v, int width) {
559    const int max_width = width & ~15;
560    const uint16_t* const last_rgb = rgb + 4 * max_width;
561    while (rgb < last_rgb) {
562      __m128i r, g, b, U0, V0, U1, V1;
563      RGBA32PackedToPlanar_16b_SSE2(rgb +  0, &r, &g, &b);
564      ConvertRGBToUV_SSE2(&r, &g, &b, &U0, &V0);
565      RGBA32PackedToPlanar_16b_SSE2(rgb + 32, &r, &g, &b);
566      ConvertRGBToUV_SSE2(&r, &g, &b, &U1, &V1);
567      STORE_16(_mm_packus_epi16(U0, U1), u);
568      STORE_16(_mm_packus_epi16(V0, V1), v);
569      u += 16;
570      v += 16;
571      rgb += 2 * 32;
572    }
573    if (max_width < width) {  
574      WebPConvertRGBA32ToUV_C(rgb, u, v, width - max_width);
575    }
576  }
577  extern void WebPInitConvertARGBToYUVSSE2(void);
578  WEBP_TSAN_IGNORE_FUNCTION void WebPInitConvertARGBToYUVSSE2(void) {
579    WebPConvertARGBToY = ConvertARGBToY_SSE2;
580    WebPConvertARGBToUV = ConvertARGBToUV_SSE2;
581    WebPConvertRGB24ToY = ConvertRGB24ToY_SSE2;
582    WebPConvertBGR24ToY = ConvertBGR24ToY_SSE2;
583    WebPConvertRGBA32ToUV = ConvertRGBA32ToUV_SSE2;
584  }
585  #define MAX_Y ((1 << 10) - 1)    
586  static uint16_t clip_y(int v) {
587    return (v < 0) ? 0 : (v > MAX_Y) ? MAX_Y : (uint16_t)v;
588  }
589  static uint64_t SharpYUVUpdateY_SSE2(const uint16_t* ref, const uint16_t* src,
590                                       uint16_t* dst, int len) {
591    uint64_t diff = 0;
592    uint32_t tmp[4];
593    int i;
594    const __m128i zero = _mm_setzero_si128();
595    const __m128i max = _mm_set1_epi16(MAX_Y);
596    const __m128i one = _mm_set1_epi16(1);
597    __m128i sum = zero;
598    for (i = 0; i + 8 <= len; i += 8) {
599      const __m128i A = _mm_loadu_si128((const __m128i*)(ref + i));
600      const __m128i B = _mm_loadu_si128((const __m128i*)(src + i));
601      const __m128i C = _mm_loadu_si128((const __m128i*)(dst + i));
602      const __m128i D = _mm_sub_epi16(A, B);       
603      const __m128i E = _mm_cmpgt_epi16(zero, D);  
604      const __m128i F = _mm_add_epi16(C, D);       
605      const __m128i G = _mm_or_si128(E, one);      
606      const __m128i H = _mm_max_epi16(_mm_min_epi16(F, max), zero);
607      const __m128i I = _mm_madd_epi16(D, G);      
608      _mm_storeu_si128((__m128i*)(dst + i), H);
609      sum = _mm_add_epi32(sum, I);
610    }
611    _mm_storeu_si128((__m128i*)tmp, sum);
612    diff = tmp[3] + tmp[2] + tmp[1] + tmp[0];
613    for (; i < len; ++i) {
614      const int diff_y = ref[i] - src[i];
615      const int new_y = (int)dst[i] + diff_y;
616      dst[i] = clip_y(new_y);
617      diff += (uint64_t)abs(diff_y);
618    }
619    return diff;
620  }
621  static void SharpYUVUpdateRGB_SSE2(const int16_t* ref, const int16_t* src,
622                                     int16_t* dst, int len) {
623    int i = 0;
624    for (i = 0; i + 8 <= len; i += 8) {
625      const __m128i A = _mm_loadu_si128((const __m128i*)(ref + i));
626      const __m128i B = _mm_loadu_si128((const __m128i*)(src + i));
627      const __m128i C = _mm_loadu_si128((const __m128i*)(dst + i));
628      const __m128i D = _mm_sub_epi16(A, B);   
629      const __m128i E = _mm_add_epi16(C, D);   
630      _mm_storeu_si128((__m128i*)(dst + i), E);
631    }
632    for (; i < len; ++i) {
633      const int diff_uv = ref[i] - src[i];
634      dst[i] += diff_uv;
635    }
636  }
637  static void SharpYUVFilterRow_SSE2(const int16_t* A, const int16_t* B, int len,
638                                     const uint16_t* best_y, uint16_t* out) {
639    int i;
640    const __m128i kCst8 = _mm_set1_epi16(8);
641    const __m128i max = _mm_set1_epi16(MAX_Y);
642    const __m128i zero = _mm_setzero_si128();
643    for (i = 0; i + 8 <= len; i += 8) {
644      const __m128i a0 = _mm_loadu_si128((const __m128i*)(A + i + 0));
645      const __m128i a1 = _mm_loadu_si128((const __m128i*)(A + i + 1));
646      const __m128i b0 = _mm_loadu_si128((const __m128i*)(B + i + 0));
647      const __m128i b1 = _mm_loadu_si128((const __m128i*)(B + i + 1));
648      const __m128i a0b1 = _mm_add_epi16(a0, b1);
649      const __m128i a1b0 = _mm_add_epi16(a1, b0);
650      const __m128i a0a1b0b1 = _mm_add_epi16(a0b1, a1b0);  
651      const __m128i a0a1b0b1_8 = _mm_add_epi16(a0a1b0b1, kCst8);
652      const __m128i a0b1_2 = _mm_add_epi16(a0b1, a0b1);    
653      const __m128i a1b0_2 = _mm_add_epi16(a1b0, a1b0);    
654      const __m128i c0 = _mm_srai_epi16(_mm_add_epi16(a0b1_2, a0a1b0b1_8), 3);
655      const __m128i c1 = _mm_srai_epi16(_mm_add_epi16(a1b0_2, a0a1b0b1_8), 3);
656      const __m128i d0 = _mm_add_epi16(c1, a0);
657      const __m128i d1 = _mm_add_epi16(c0, a1);
658      const __m128i e0 = _mm_srai_epi16(d0, 1);
659      const __m128i e1 = _mm_srai_epi16(d1, 1);
660      const __m128i f0 = _mm_unpacklo_epi16(e0, e1);
661      const __m128i f1 = _mm_unpackhi_epi16(e0, e1);
662      const __m128i g0 = _mm_loadu_si128((const __m128i*)(best_y + 2 * i + 0));
663      const __m128i g1 = _mm_loadu_si128((const __m128i*)(best_y + 2 * i + 8));
664      const __m128i h0 = _mm_add_epi16(g0, f0);
665      const __m128i h1 = _mm_add_epi16(g1, f1);
666      const __m128i i0 = _mm_max_epi16(_mm_min_epi16(h0, max), zero);
667      const __m128i i1 = _mm_max_epi16(_mm_min_epi16(h1, max), zero);
668      _mm_storeu_si128((__m128i*)(out + 2 * i + 0), i0);
669      _mm_storeu_si128((__m128i*)(out + 2 * i + 8), i1);
670    }
671    for (; i < len; ++i) {
672      const int a0b1 = A[i + 0] + B[i + 1];
673      const int a1b0 = A[i + 1] + B[i + 0];
674      const int a0a1b0b1 = a0b1 + a1b0 + 8;
675      const int v0 = (8 * A[i + 0] + 2 * a1b0 + a0a1b0b1) >> 4;
676      const int v1 = (8 * A[i + 1] + 2 * a0b1 + a0a1b0b1) >> 4;
677      out[2 * i + 0] = clip_y(best_y[2 * i + 0] + v0);
678      out[2 * i + 1] = clip_y(best_y[2 * i + 1] + v1);
679    }
680  }
681  #undef MAX_Y
682  extern void WebPInitSharpYUVSSE2(void);
683  WEBP_TSAN_IGNORE_FUNCTION void WebPInitSharpYUVSSE2(void) {
684    WebPSharpYUVUpdateY = SharpYUVUpdateY_SSE2;
685    WebPSharpYUVUpdateRGB = SharpYUVUpdateRGB_SSE2;
686    WebPSharpYUVFilterRow = SharpYUVFilterRow_SSE2;
687  }
688  #else  
689  WEBP_DSP_INIT_STUB(WebPInitSamplersSSE2)
690  WEBP_DSP_INIT_STUB(WebPInitConvertARGBToYUVSSE2)
691  WEBP_DSP_INIT_STUB(WebPInitSharpYUVSSE2)
692  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-buffered_8.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-yuv_sse2.c</div>
                </div>
                <div class="column column_space"><pre><code>75  static int applicable0(const S *ego, const problem *p_, const planner *plnr)
76  {
77       const problem_rdft *p = (const problem_rdft *) p_;
78       iodim *d = p->sz->dims;
</pre></code></div>
                <div class="column column_space"><pre><code>9                                      __m128i* const R,
10                                      __m128i* const G,
11                                      __m128i* const B) {
12    const __m128i k19077 = _mm_set1_epi16(19077);
13    const __m128i k26149 = _mm_set1_epi16(26149);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    