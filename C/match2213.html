<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for mmpstrucdata.c &amp; lmcry_gcry.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mmpstrucdata.c &amp; lmcry_gcry.c
      </h3>
<h1 align="center">
        5.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mmpstrucdata.c (5.019305%)<th>lmcry_gcry.c (5.4166665%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(71-78)<td><a href="#" name="0">(51-58)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmpstrucdata.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* mmpstrucdata.c
 * Parse all fields of the message into structured data inside the
 * JSON tree.
 *
 * Copyright 2013-2018 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "config.h"
#include "rsyslog.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;ctype.h&gt;
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "parserif.h"

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("mmpstrucdata")


DEF_OMOD_STATIC_DATA

/* config variables */

typedef struct _instanceData {
	uchar *jsonRoot;	/**&lt; container where to store fields */
	int lowercase_SD_ID;
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
} wrkrInstanceData_t;

struct modConfData_s {
	rsconf_t *pConf;	/* our overall config object */
};
static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current exec process */


<a name="0"></a>/* tables for interfacing with the v6 config system */
/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "jsonroot", eCmdHdlrString, 0 },
	{ "sd_name.lowercase", eCmdHdlrBinary, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};</b></font>

BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
ENDbeginCnfLoad

BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf

BEGINfreeCnf
CODESTARTfreeCnf
ENDfreeCnf


BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
ENDcreateWrkrInstance


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
ENDisCompatibleWithFeature


BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;jsonRoot);
ENDfreeInstance

BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
ENDfreeWrkrInstance


static inline void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;jsonRoot = NULL;
	pData-&gt;lowercase_SD_ID = 1;
}

BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
CODESTARTnewActInst
	DBGPRINTF("newActInst (mmpstrucdata)\n");
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CODE_STD_STRING_REQUESTnewActInst(1)
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, "jsonroot")) {
			size_t lenvar = es_strlen(pvals[i].val.d.estr);
			pData-&gt;jsonRoot = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			if(pData-&gt;jsonRoot[0] == '$') {
				/* pre 8.35, the jsonRoot name needed to be specified without
				 * the leading $. This was confusing, so we now require a full
				 * variable name. Nevertheless, we still need to support the
				 * version without $. -- rgerhards, 2018-05-16
				 */
				/* copy lenvar size because of \0 string terminator */
				memmove(pData-&gt;jsonRoot, pData-&gt;jsonRoot+1,  lenvar);
				--lenvar;
			}
			if(   (lenvar == 0)
			   || (  !(   pData-&gt;jsonRoot[0] == '!'
			           || pData-&gt;jsonRoot[0] == '.'
			           || pData-&gt;jsonRoot[0] == '/' ) )
			   ) {
				parser_errmsg("mmpstrucdata: invalid jsonRoot name '%s', name must "
					"start with either '$!', '$.', or '$/'", pData-&gt;jsonRoot);
				ABORT_FINALIZE(RS_RET_INVALID_VAR);
			}
		} else if(!strcmp(actpblk.descr[i].name, "sd_name.lowercase")) {
			pData-&gt;lowercase_SD_ID = pvals[i].val.d.n;
		} else {
			LogError(0, RS_RET_INTERNAL_ERROR,
				"mmpstrucdata: internal program error, non-handled "
				"param '%s'\n", actpblk.descr[i].name);
		}
	}
	if(pData-&gt;jsonRoot == NULL) {
		CHKmalloc(pData-&gt;jsonRoot = (uchar*) strdup("!"));
	}

CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
ENDdbgPrintInstInfo


BEGINtryResume
CODESTARTtryResume
ENDtryResume


static rsRetVal
parsePARAM_VALUE(uchar *sdbuf, int lenbuf, int *curridx, uchar *fieldbuf)
{
	int i, j;
	DEFiRet;
	i = *curridx;
	j = 0;
	while(i &lt; lenbuf &amp;&amp; sdbuf[i] != '"') {
		if(sdbuf[i] == '\\') {
			if(++i == lenbuf) {
				fieldbuf[j++] = '\\';
			} else {
				if(sdbuf[i] == '"') {
					fieldbuf[j++] = '"';
				} else if(sdbuf[i] == '\\') {
					fieldbuf[j++] = '\\';
				} else if(sdbuf[i] == ']') {
					fieldbuf[j++] = ']';
				} else {
					fieldbuf[j++] = '\\';
					fieldbuf[j++] = sdbuf[i];
				}
				++i;
			}
		} else {
			fieldbuf[j++] = sdbuf[i++];
		}
	}
	fieldbuf[j] = '\0';
	*curridx = i;
	RETiRet;
}


static rsRetVal ATTR_NONNULL()
parseSD_NAME(instanceData *const pData, uchar *sdbuf, int lenbuf, int *curridx, uchar *namebuf)
{
	int i, j;
	DEFiRet;
	i = *curridx;
	for(j = 0 ; i &lt; lenbuf &amp;&amp; j &lt; 32; ++j) {
		if(   sdbuf[i] == '=' || sdbuf[i] == '"'
		   || sdbuf[i] == ']' || sdbuf[i] == ' ')
			break;
		namebuf[j] = pData-&gt;lowercase_SD_ID ? tolower(sdbuf[i]) : sdbuf[i];
		++i;
	}
	namebuf[j] = '\0';
	*curridx = i;
	RETiRet;
}


static rsRetVal ATTR_NONNULL()
parseSD_PARAM(instanceData *const pData, uchar *sdbuf, int lenbuf, int *curridx, struct json_object *jroot)
{
	int i;
	uchar pName[33];
	uchar pVal[32*1024];
	struct json_object *jval;
	DEFiRet;
	
	i = *curridx;
	CHKiRet(parseSD_NAME(pData, sdbuf, lenbuf, &amp;i, pName));
	if(sdbuf[i] != '=') {
		ABORT_FINALIZE(RS_RET_STRUC_DATA_INVLD);
	}
	++i;
	if(sdbuf[i] != '"') {
		ABORT_FINALIZE(RS_RET_STRUC_DATA_INVLD);
	}
	++i;
	CHKiRet(parsePARAM_VALUE(sdbuf, lenbuf, &amp;i, pVal));
	if(sdbuf[i] != '"') {
		ABORT_FINALIZE(RS_RET_STRUC_DATA_INVLD);
	}
	++i;

	jval = json_object_new_string((char*)pVal);
	json_object_object_add(jroot, (char*)pName, jval);

	*curridx = i;
finalize_it:
	RETiRet;
}


static rsRetVal ATTR_NONNULL()
parseSD_ELEMENT(instanceData *const pData, uchar *sdbuf, int lenbuf, int *curridx, struct json_object *jroot)
{
	int i;
	uchar sd_id[33];
	struct json_object *json = NULL;
	DEFiRet;
	
	i = *curridx;
	if(sdbuf[i] != '[') {
		ABORT_FINALIZE(RS_RET_STRUC_DATA_INVLD);
	}
	++i; /* eat '[' */

	CHKiRet(parseSD_NAME(pData, sdbuf, lenbuf, &amp;i, sd_id));
	json =  json_object_new_object();

	while(i &lt; lenbuf) {
		if(sdbuf[i] == ']') {
			break;
		} else if(sdbuf[i] != ' ') {
			ABORT_FINALIZE(RS_RET_STRUC_DATA_INVLD);
		}
		++i;
		while(i &lt; lenbuf &amp;&amp; sdbuf[i] == ' ')
			++i;
		CHKiRet(parseSD_PARAM(pData, sdbuf, lenbuf, &amp;i, json));
	}

	if(sdbuf[i] != ']') {
		DBGPRINTF("mmpstrucdata: SD-ELEMENT does not terminate with "
		          "']': '%s'\n", sdbuf+i);
		ABORT_FINALIZE(RS_RET_STRUC_DATA_INVLD);
	}
	++i; /* eat ']' */
	*curridx = i;
	json_object_object_add(jroot, (char*)sd_id, json);
finalize_it:
	if(iRet != RS_RET_OK &amp;&amp; json != NULL)
		json_object_put(json);
	RETiRet;
}

static rsRetVal ATTR_NONNULL()
parse_sd(instanceData *const pData, smsg_t *const pMsg)
{
	struct json_object *json, *jroot;
	uchar *sdbuf;
	int lenbuf;
	int i = 0;
	DEFiRet;

	json =  json_object_new_object();
	if(json == NULL) {
		ABORT_FINALIZE(RS_RET_ERR);
	}
	MsgGetStructuredData(pMsg, &amp;sdbuf,&amp;lenbuf);
	while(i &lt; lenbuf) {
		CHKiRet(parseSD_ELEMENT(pData, sdbuf, lenbuf, &amp;i, json));
	}

	jroot =  json_object_new_object();
	if(jroot == NULL) {
		ABORT_FINALIZE(RS_RET_ERR);
	}
	json_object_object_add(jroot, "rfc5424-sd", json);
	msgAddJSON(pMsg, pData-&gt;jsonRoot, jroot, 0, 0);
finalize_it:
	if(iRet != RS_RET_OK &amp;&amp; json != NULL)
		json_object_put(json);
	RETiRet;
}


BEGINdoAction_NoStrings
	smsg_t **ppMsg = (smsg_t **) pMsgData;
	smsg_t *pMsg = ppMsg[0];
CODESTARTdoAction
	DBGPRINTF("mmpstrucdata: enter\n");
	if(!MsgHasStructuredData(pMsg)) {
		DBGPRINTF("mmpstrucdata: message does not have structured data\n");
		FINALIZE;
	}
	/* don't check return code - we never want rsyslog to retry
	 * or suspend this action!
	 */
	parse_sd(pWrkrData-&gt;pData, pMsg);
finalize_it:
ENDdoAction


BEGINmodExit
CODESTARTmodExit
ENDmodExit


NO_LEGACY_CONF_parseSelectorAct
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	DBGPRINTF("mmpstrucdata: module compiled with rsyslog version %s.\n", VERSION);
ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lmcry_gcry.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* lmcry_gcry.c
 *
 * An implementation of the cryprov interface for libgcrypt.
 *
 * Copyright 2013-2017 Rainer Gerhards and Adiscon GmbH.
 *
 * This file is part of the rsyslog runtime library.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "config.h"

#include "rsyslog.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;

#include "module-template.h"
#include "glbl.h"
#include "errmsg.h"
#include "cryprov.h"
#include "parserif.h"
#include "libgcry.h"
#include "lmcry_gcry.h"

MODULE_TYPE_LIB
MODULE_TYPE_NOKEEP

/* static data */
DEFobjStaticHelpers
DEFobjCurrIf(glbl)

/* tables for interfacing with the v6 config system */
static struct cnfparamdescr cnfpdescrRegular[] = {
<a name="0"></a>	{ "cry.key", eCmdHdlrGetWord, 0 },
	{ "cry.keyfile", eCmdHdlrGetWord, 0 },
	{ "cry.keyprogram", eCmdHdlrGetWord, 0 },
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "cry.mode", eCmdHdlrGetWord, 0 }, /* CBC, ECB, etc */
	{ "cry.algo", eCmdHdlrGetWord, 0 }
};
static struct cnfparamblk pblkRegular =
	{ CNFPARAMBLK_VERSION,
	  sizeof(cnfpdescrRegular)/sizeof(struct cnfparamdescr),
	  cnfpdescrRegular
	};</b></font>

static struct cnfparamdescr cnfpdescrQueue[] = {
	{ "queue.cry.key", eCmdHdlrGetWord, 0 },
	{ "queue.cry.keyfile", eCmdHdlrGetWord, 0 },
	{ "queue.cry.keyprogram", eCmdHdlrGetWord, 0 },
	{ "queue.cry.mode", eCmdHdlrGetWord, 0 }, /* CBC, ECB, etc */
	{ "queue.cry.algo", eCmdHdlrGetWord, 0 }
};
static struct cnfparamblk pblkQueue =
	{ CNFPARAMBLK_VERSION,
	  sizeof(cnfpdescrQueue)/sizeof(struct cnfparamdescr),
	  cnfpdescrQueue
	};


#if 0
static void
errfunc(__attribute__((unused)) void *usrptr, uchar *emsg)
{
	LogError(0, RS_RET_CRYPROV_ERR, "Crypto Provider"
		"Error: %s - disabling encryption", emsg);
}
#endif

/* Standard-Constructor
 */
BEGINobjConstruct(lmcry_gcry)
	CHKmalloc(pThis-&gt;ctx = gcryCtxNew());
finalize_it:
ENDobjConstruct(lmcry_gcry)


/* destructor for the lmcry_gcry object */
BEGINobjDestruct(lmcry_gcry) /* be sure to specify the object type also in END and CODESTART macros! */
CODESTARTobjDestruct(lmcry_gcry)
	rsgcryCtxDel(pThis-&gt;ctx);
ENDobjDestruct(lmcry_gcry)


/* apply all params from param block to us. This must be called
 * after construction, but before the OnFileOpen() entry point.
 * Defaults are expected to have been set during construction.
 */
static rsRetVal
SetCnfParam(void *pT, struct nvlst *lst, int paramType)
{
	lmcry_gcry_t *pThis = (lmcry_gcry_t*) pT;
	int i, r;
	unsigned keylen = 0;
	uchar *key = NULL;
	uchar *keyfile = NULL;
	uchar *keyprogram = NULL;
	uchar *algo = NULL;
	uchar *mode = NULL;
	int nKeys; /* number of keys (actually methods) specified */
	struct cnfparamvals *pvals;
	struct cnfparamblk *pblk;
	DEFiRet;

	pblk = (paramType == CRYPROV_PARAMTYPE_REGULAR ) ?  &amp;pblkRegular : &amp;pblkQueue;
	nKeys = 0;
	pvals = nvlstGetParams(lst, pblk, NULL);
	if(pvals == NULL) {
		parser_errmsg("error crypto provider gcryconfig parameters]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if(Debug) {
		dbgprintf("param blk in lmcry_gcry:\n");
		cnfparamsPrint(pblk, pvals);
	}

	for(i = 0 ; i &lt; pblk-&gt;nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(pblk-&gt;descr[i].name, "cry.key") ||
		   !strcmp(pblk-&gt;descr[i].name, "queue.cry.key")) {
			key = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
			++nKeys;
		} else if(!strcmp(pblk-&gt;descr[i].name, "cry.keyfile") ||
		          !strcmp(pblk-&gt;descr[i].name, "queue.cry.keyfile")) {
			keyfile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			++nKeys;
		} else if(!strcmp(pblk-&gt;descr[i].name, "cry.keyprogram") ||
		          !strcmp(pblk-&gt;descr[i].name, "queue.cry.keyprogram")) {
			keyprogram = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			++nKeys;
		} else if(!strcmp(pblk-&gt;descr[i].name, "cry.mode") ||
		          !strcmp(pblk-&gt;descr[i].name, "queue.cry.mode")) {
			mode = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(pblk-&gt;descr[i].name, "cry.algo") ||
		          !strcmp(pblk-&gt;descr[i].name, "queue.cry.algo")) {
			algo = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {
			DBGPRINTF("lmcry_gcry: program error, non-handled "
			  "param '%s'\n", pblk-&gt;descr[i].name);
		}
	}
	if(algo != NULL) {
		iRet = rsgcrySetAlgo(pThis-&gt;ctx, algo);
		if(iRet != RS_RET_OK) {
			LogError(0, iRet, "cry.algo '%s' is not know/supported", algo);
			FINALIZE;
		}
	}
	if(mode != NULL) {
		iRet = rsgcrySetMode(pThis-&gt;ctx, mode);
		if(iRet != RS_RET_OK) {
			LogError(0, iRet, "cry.mode '%s' is not know/supported", mode);
			FINALIZE;
		}
	}
	/* note: key must be set AFTER algo/mode is set (as it depends on them) */
	if(nKeys != 1) {
		LogError(0, RS_RET_INVALID_PARAMS, "excactly one of the following "
			"parameters can be specified: cry.key, cry.keyfile, cry.keyprogram\n");
		ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
	}
	if(key != NULL) {
		LogError(0, RS_RET_ERR, "Note: specifying an actual key directly from the "
			"config file is highly insecure - DO NOT USE FOR PRODUCTION");
		keylen = strlen((char*)key);
	}
	if(keyfile != NULL) {
		r = gcryGetKeyFromFile((char*)keyfile, (char**)&amp;key, &amp;keylen);
		if(r != 0) {
			LogError(errno, RS_RET_ERR, "error reading keyfile %s",
				keyfile);
			ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
		}
	}
	if(keyprogram != NULL) {
		r = gcryGetKeyFromProg((char*)keyprogram, (char**)&amp;key, &amp;keylen);
		if(r != 0) {
			LogError(0, RS_RET_ERR, "error %d obtaining key from program %s\n",
				r, keyprogram);
			ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
		}
	}

	/* if we reach this point, we have a valid key */
	r = rsgcrySetKey(pThis-&gt;ctx, key, keylen);
	if(r &gt; 0) {
		LogError(0, RS_RET_INVALID_PARAMS, "Key length %d expected, but "
			"key of length %d given", r, keylen);
		ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
	}

finalize_it:
	free(key);
	free(keyfile);
	free(algo);
	free(keyprogram);
	free(mode);
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, pblk);
	RETiRet;
}

static void
SetDeleteOnClose(void *pF, int val)
{
	gcryfileSetDeleteOnClose(pF, val);
}

static rsRetVal
GetBytesLeftInBlock(void *pF, ssize_t *left)
{
	return gcryfileGetBytesLeftInBlock((gcryfile) pF, left);
}

static rsRetVal
DeleteStateFiles(uchar *logfn)
{
	return gcryfileDeleteState(logfn);
}

static rsRetVal
OnFileOpen(void *pT, uchar *fn, void *pGF, char openMode)
{
	lmcry_gcry_t *pThis = (lmcry_gcry_t*) pT;
	gcryfile *pgf = (gcryfile*) pGF;
	DEFiRet;
	DBGPRINTF("lmcry_gcry: open file '%s', mode '%c'\n", fn, openMode);

	iRet = rsgcryInitCrypt(pThis-&gt;ctx, pgf, fn, openMode);
	if(iRet != RS_RET_OK) {
		LogError(0, iRet, "Encryption Provider"
			"Error: cannot open .encinfo file - disabling log file");
	}
	RETiRet;
}

static rsRetVal
Decrypt(void *pF, uchar *rec, size_t *lenRec)
{
	DEFiRet;
	iRet = rsgcryDecrypt(pF, rec, lenRec);

	RETiRet;
}


static rsRetVal
Encrypt(void *pF, uchar *rec, size_t *lenRec)
{
	DEFiRet;
	iRet = rsgcryEncrypt(pF, rec, lenRec);

	RETiRet;
}

static rsRetVal
OnFileClose(void *pF, off64_t offsLogfile)
{
	DEFiRet;
	gcryfileDestruct(pF, offsLogfile);

	RETiRet;
}

BEGINobjQueryInterface(lmcry_gcry)
CODESTARTobjQueryInterface(lmcry_gcry)
	 if(pIf-&gt;ifVersion != cryprovCURR_IF_VERSION) {/* check for current version, increment on each change */
		ABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);
	}
	pIf-&gt;Construct = (rsRetVal(*)(void*)) lmcry_gcryConstruct;
	pIf-&gt;SetCnfParam = SetCnfParam;
	pIf-&gt;SetDeleteOnClose = SetDeleteOnClose;
	pIf-&gt;Destruct = (rsRetVal(*)(void*)) lmcry_gcryDestruct;
	pIf-&gt;OnFileOpen = OnFileOpen;
	pIf-&gt;Encrypt = Encrypt;
	pIf-&gt;Decrypt = Decrypt;
	pIf-&gt;OnFileClose = OnFileClose;
	pIf-&gt;DeleteStateFiles = DeleteStateFiles;
	pIf-&gt;GetBytesLeftInBlock = GetBytesLeftInBlock;
finalize_it:
ENDobjQueryInterface(lmcry_gcry)


BEGINObjClassExit(lmcry_gcry, OBJ_IS_LOADABLE_MODULE) /* CHANGE class also in END MACRO! */
CODESTARTObjClassExit(lmcry_gcry)
	/* release objects we no longer need */
	objRelease(glbl, CORE_COMPONENT);

	rsgcryExit();
ENDObjClassExit(lmcry_gcry)


BEGINObjClassInit(lmcry_gcry, 1, OBJ_IS_LOADABLE_MODULE) /* class, version */
	/* request objects we use */
	CHKiRet(objUse(glbl, CORE_COMPONENT));

	if(rsgcryInit() != 0) {
		LogError(0, RS_RET_CRYPROV_ERR, "error initializing "
			"crypto provider - cannot encrypt");
		ABORT_FINALIZE(RS_RET_CRYPROV_ERR);
	}
ENDObjClassInit(lmcry_gcry)


/* --------------- here now comes the plumbing that makes as a library module --------------- */


BEGINmodExit
CODESTARTmodExit
	lmcry_gcryClassExit();
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_LIB_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
	/* Initialize all classes that are in our module - this includes ourselfs */
	CHKiRet(lmcry_gcryClassInit(pModInfo)); /* must be done after tcps_sess, as we use it */
ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
