<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mmpstrucdata.c &amp; lmcry_gcry.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mmpstrucdata.c &amp; lmcry_gcry.c
      </h3>
<h1 align="center">
        5.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mmpstrucdata.c (5.019305%)<th>lmcry_gcry.c (5.4166665%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(71-78)<td><a href="#" name="0">(51-58)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmpstrucdata.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;unistd.h&gt;
11 #include &lt;stdint.h&gt;
12 #include &lt;ctype.h&gt;
13 #include "conf.h"
14 #include "syslogd-types.h"
15 #include "srUtils.h"
16 #include "template.h"
17 #include "module-template.h"
18 #include "errmsg.h"
19 #include "parserif.h"
20 MODULE_TYPE_OUTPUT
21 MODULE_TYPE_NOKEEP
22 MODULE_CNFNAME("mmpstrucdata")
23 DEF_OMOD_STATIC_DATA
24 typedef struct _instanceData {
25 	int lowercase_SD_ID;
26 } instanceData;
27 typedef struct wrkrInstanceData {
28 	instanceData *pData;
29 } wrkrInstanceData_t;
30 struct modConfData_s {
31 	rsconf_t *pConf;	};
32 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
33 <a name="0"></a>static struct cnfparamdescr actpdescr[] = {
34 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "jsonroot", eCmdHdlrString, 0 },
35 	{ "sd_name.lowercase", eCmdHdlrBinary, 0 }
36 };
37 static struct cnfparamblk actpblk =
38 	{ CNFPARAMBLK_VERSION,
39 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
40 	  actpdescr
41 	};</b></font>
42 BEGINbeginCnfLoad
43 CODESTARTbeginCnfLoad
44 	loadModConf = pModConf;
45 	pModConf-&gt;pConf = pConf;
46 ENDbeginCnfLoad
47 BEGINendCnfLoad
48 CODESTARTendCnfLoad
49 ENDendCnfLoad
50 BEGINcheckCnf
51 CODESTARTcheckCnf
52 ENDcheckCnf
53 BEGINactivateCnf
54 CODESTARTactivateCnf
55 	runModConf = pModConf;
56 ENDactivateCnf
57 BEGINfreeCnf
58 CODESTARTfreeCnf
59 ENDfreeCnf
60 BEGINcreateInstance
61 CODESTARTcreateInstance
62 ENDcreateInstance
63 BEGINcreateWrkrInstance
64 CODESTARTcreateWrkrInstance
65 ENDcreateWrkrInstance
66 BEGINisCompatibleWithFeature
67 CODESTARTisCompatibleWithFeature
68 ENDisCompatibleWithFeature
69 BEGINfreeInstance
70 CODESTARTfreeInstance
71 	free(pData-&gt;jsonRoot);
72 ENDfreeInstance
73 BEGINfreeWrkrInstance
74 CODESTARTfreeWrkrInstance
75 ENDfreeWrkrInstance
76 static inline void
77 setInstParamDefaults(instanceData *pData)
78 {
79 	pData-&gt;jsonRoot = NULL;
80 	pData-&gt;lowercase_SD_ID = 1;
81 }
82 BEGINnewActInst
83 	struct cnfparamvals *pvals;
84 	int i;
85 CODESTARTnewActInst
86 	DBGPRINTF("newActInst (mmpstrucdata)\n");
87 	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
88 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
89 	}
90 	CODE_STD_STRING_REQUESTnewActInst(1)
91 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
92 	CHKiRet(createInstance(&amp;pData));
93 	setInstParamDefaults(pData);
94 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
95 		if(!pvals[i].bUsed)
96 			continue;
97 		if(!strcmp(actpblk.descr[i].name, "jsonroot")) {
98 			size_t lenvar = es_strlen(pvals[i].val.d.estr);
99 			pData-&gt;jsonRoot = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
100 			if(pData-&gt;jsonRoot[0] == '$') {
101 				memmove(pData-&gt;jsonRoot, pData-&gt;jsonRoot+1,  lenvar);
102 				--lenvar;
103 			}
104 			if(   (lenvar == 0)
105 			   || (  !(   pData-&gt;jsonRoot[0] == '!'
106 			           || pData-&gt;jsonRoot[0] == '.'
107 			           || pData-&gt;jsonRoot[0] == '/' ) )
108 			   ) {
109 				parser_errmsg("mmpstrucdata: invalid jsonRoot name '%s', name must "
110 					"start with either '$!', '$.', or '$/'", pData-&gt;jsonRoot);
111 				ABORT_FINALIZE(RS_RET_INVALID_VAR);
112 			}
113 		} else if(!strcmp(actpblk.descr[i].name, "sd_name.lowercase")) {
114 			pData-&gt;lowercase_SD_ID = pvals[i].val.d.n;
115 		} else {
116 			LogError(0, RS_RET_INTERNAL_ERROR,
117 				"mmpstrucdata: internal program error, non-handled "
118 				"param '%s'\n", actpblk.descr[i].name);
119 		}
120 	}
121 	if(pData-&gt;jsonRoot == NULL) {
122 		CHKmalloc(pData-&gt;jsonRoot = (uchar*) strdup("!"));
123 	}
124 CODE_STD_FINALIZERnewActInst
125 	cnfparamvalsDestruct(pvals, &amp;actpblk);
126 ENDnewActInst
127 BEGINdbgPrintInstInfo
128 CODESTARTdbgPrintInstInfo
129 ENDdbgPrintInstInfo
130 BEGINtryResume
131 CODESTARTtryResume
132 ENDtryResume
133 static rsRetVal
134 parsePARAM_VALUE(uchar *sdbuf, int lenbuf, int *curridx, uchar *fieldbuf)
135 {
136 	int i, j;
137 	DEFiRet;
138 	i = *curridx;
139 	j = 0;
140 	while(i &lt; lenbuf &amp;&amp; sdbuf[i] != '"') {
141 		if(sdbuf[i] == '\\') {
142 			if(++i == lenbuf) {
143 				fieldbuf[j++] = '\\';
144 			} else {
145 				if(sdbuf[i] == '"') {
146 					fieldbuf[j++] = '"';
147 				} else if(sdbuf[i] == '\\') {
148 					fieldbuf[j++] = '\\';
149 				} else if(sdbuf[i] == ']') {
150 					fieldbuf[j++] = ']';
151 				} else {
152 					fieldbuf[j++] = '\\';
153 					fieldbuf[j++] = sdbuf[i];
154 				}
155 				++i;
156 			}
157 		} else {
158 			fieldbuf[j++] = sdbuf[i++];
159 		}
160 	}
161 	fieldbuf[j] = '\0';
162 	*curridx = i;
163 	RETiRet;
164 }
165 static rsRetVal ATTR_NONNULL()
166 parseSD_NAME(instanceData *const pData, uchar *sdbuf, int lenbuf, int *curridx, uchar *namebuf)
167 {
168 	int i, j;
169 	DEFiRet;
170 	i = *curridx;
171 	for(j = 0 ; i &lt; lenbuf &amp;&amp; j &lt; 32; ++j) {
172 		if(   sdbuf[i] == '=' || sdbuf[i] == '"'
173 		   || sdbuf[i] == ']' || sdbuf[i] == ' ')
174 			break;
175 		namebuf[j] = pData-&gt;lowercase_SD_ID ? tolower(sdbuf[i]) : sdbuf[i];
176 		++i;
177 	}
178 	namebuf[j] = '\0';
179 	*curridx = i;
180 	RETiRet;
181 }
182 static rsRetVal ATTR_NONNULL()
183 parseSD_PARAM(instanceData *const pData, uchar *sdbuf, int lenbuf, int *curridx, struct json_object *jroot)
184 {
185 	int i;
186 	uchar pName[33];
187 	uchar pVal[32*1024];
188 	struct json_object *jval;
189 	DEFiRet;
190 	i = *curridx;
191 	CHKiRet(parseSD_NAME(pData, sdbuf, lenbuf, &amp;i, pName));
192 	if(sdbuf[i] != '=') {
193 		ABORT_FINALIZE(RS_RET_STRUC_DATA_INVLD);
194 	}
195 	++i;
196 	if(sdbuf[i] != '"') {
197 		ABORT_FINALIZE(RS_RET_STRUC_DATA_INVLD);
198 	}
199 	++i;
200 	CHKiRet(parsePARAM_VALUE(sdbuf, lenbuf, &amp;i, pVal));
201 	if(sdbuf[i] != '"') {
202 		ABORT_FINALIZE(RS_RET_STRUC_DATA_INVLD);
203 	}
204 	++i;
205 	jval = json_object_new_string((char*)pVal);
206 	json_object_object_add(jroot, (char*)pName, jval);
207 	*curridx = i;
208 finalize_it:
209 	RETiRet;
210 }
211 static rsRetVal ATTR_NONNULL()
212 parseSD_ELEMENT(instanceData *const pData, uchar *sdbuf, int lenbuf, int *curridx, struct json_object *jroot)
213 {
214 	int i;
215 	uchar sd_id[33];
216 	struct json_object *json = NULL;
217 	DEFiRet;
218 	i = *curridx;
219 	if(sdbuf[i] != '[') {
220 		ABORT_FINALIZE(RS_RET_STRUC_DATA_INVLD);
221 	}
222 	++i; 
223 	CHKiRet(parseSD_NAME(pData, sdbuf, lenbuf, &amp;i, sd_id));
224 	json =  json_object_new_object();
225 	while(i &lt; lenbuf) {
226 		if(sdbuf[i] == ']') {
227 			break;
228 		} else if(sdbuf[i] != ' ') {
229 			ABORT_FINALIZE(RS_RET_STRUC_DATA_INVLD);
230 		}
231 		++i;
232 		while(i &lt; lenbuf &amp;&amp; sdbuf[i] == ' ')
233 			++i;
234 		CHKiRet(parseSD_PARAM(pData, sdbuf, lenbuf, &amp;i, json));
235 	}
236 	if(sdbuf[i] != ']') {
237 		DBGPRINTF("mmpstrucdata: SD-ELEMENT does not terminate with "
238 		          "']': '%s'\n", sdbuf+i);
239 		ABORT_FINALIZE(RS_RET_STRUC_DATA_INVLD);
240 	}
241 	++i; 	*curridx = i;
242 	json_object_object_add(jroot, (char*)sd_id, json);
243 finalize_it:
244 	if(iRet != RS_RET_OK &amp;&amp; json != NULL)
245 		json_object_put(json);
246 	RETiRet;
247 }
248 static rsRetVal ATTR_NONNULL()
249 parse_sd(instanceData *const pData, smsg_t *const pMsg)
250 {
251 	struct json_object *json, *jroot;
252 	uchar *sdbuf;
253 	int lenbuf;
254 	int i = 0;
255 	DEFiRet;
256 	json =  json_object_new_object();
257 	if(json == NULL) {
258 		ABORT_FINALIZE(RS_RET_ERR);
259 	}
260 	MsgGetStructuredData(pMsg, &amp;sdbuf,&amp;lenbuf);
261 	while(i &lt; lenbuf) {
262 		CHKiRet(parseSD_ELEMENT(pData, sdbuf, lenbuf, &amp;i, json));
263 	}
264 	jroot =  json_object_new_object();
265 	if(jroot == NULL) {
266 		ABORT_FINALIZE(RS_RET_ERR);
267 	}
268 	json_object_object_add(jroot, "rfc5424-sd", json);
269 	msgAddJSON(pMsg, pData-&gt;jsonRoot, jroot, 0, 0);
270 finalize_it:
271 	if(iRet != RS_RET_OK &amp;&amp; json != NULL)
272 		json_object_put(json);
273 	RETiRet;
274 }
275 BEGINdoAction_NoStrings
276 	smsg_t **ppMsg = (smsg_t **) pMsgData;
277 	smsg_t *pMsg = ppMsg[0];
278 CODESTARTdoAction
279 	DBGPRINTF("mmpstrucdata: enter\n");
280 	if(!MsgHasStructuredData(pMsg)) {
281 		DBGPRINTF("mmpstrucdata: message does not have structured data\n");
282 		FINALIZE;
283 	}
284 	parse_sd(pWrkrData-&gt;pData, pMsg);
285 finalize_it:
286 ENDdoAction
287 BEGINmodExit
288 CODESTARTmodExit
289 ENDmodExit
290 NO_LEGACY_CONF_parseSelectorAct
291 BEGINqueryEtryPt
292 CODESTARTqueryEtryPt
293 CODEqueryEtryPt_STD_OMOD_QUERIES
294 CODEqueryEtryPt_STD_OMOD8_QUERIES
295 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
296 CODEqueryEtryPt_STD_CONF2_QUERIES
297 ENDqueryEtryPt
298 BEGINmodInit()
299 CODESTARTmodInit
300 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
301 	DBGPRINTF("mmpstrucdata: module compiled with rsyslog version %s.\n", VERSION);
302 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lmcry_gcry.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdlib.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;errno.h&gt;
7 #include "module-template.h"
8 #include "glbl.h"
9 #include "errmsg.h"
10 #include "cryprov.h"
11 #include "parserif.h"
12 #include "libgcry.h"
13 #include "lmcry_gcry.h"
14 MODULE_TYPE_LIB
15 MODULE_TYPE_NOKEEP
16 DEFobjStaticHelpers
17 DEFobjCurrIf(glbl)
18 static struct cnfparamdescr cnfpdescrRegular[] = {
19 <a name="0"></a>	{ "cry.key", eCmdHdlrGetWord, 0 },
20 	{ "cry.keyfile", eCmdHdlrGetWord, 0 },
21 	{ "cry.keyprogram", eCmdHdlrGetWord, 0 },
22 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "cry.mode", eCmdHdlrGetWord, 0 }, 	{ "cry.algo", eCmdHdlrGetWord, 0 }
23 };
24 static struct cnfparamblk pblkRegular =
25 	{ CNFPARAMBLK_VERSION,
26 	  sizeof(cnfpdescrRegular)/sizeof(struct cnfparamdescr),
27 	  cnfpdescrRegular
28 	};</b></font>
29 static struct cnfparamdescr cnfpdescrQueue[] = {
30 	{ "queue.cry.key", eCmdHdlrGetWord, 0 },
31 	{ "queue.cry.keyfile", eCmdHdlrGetWord, 0 },
32 	{ "queue.cry.keyprogram", eCmdHdlrGetWord, 0 },
33 	{ "queue.cry.mode", eCmdHdlrGetWord, 0 }, 	{ "queue.cry.algo", eCmdHdlrGetWord, 0 }
34 };
35 static struct cnfparamblk pblkQueue =
36 	{ CNFPARAMBLK_VERSION,
37 	  sizeof(cnfpdescrQueue)/sizeof(struct cnfparamdescr),
38 	  cnfpdescrQueue
39 	};
40 #if 0
41 static void
42 errfunc(__attribute__((unused)) void *usrptr, uchar *emsg)
43 {
44 	LogError(0, RS_RET_CRYPROV_ERR, "Crypto Provider"
45 		"Error: %s - disabling encryption", emsg);
46 }
47 #endif
48 BEGINobjConstruct(lmcry_gcry)
49 	CHKmalloc(pThis-&gt;ctx = gcryCtxNew());
50 finalize_it:
51 ENDobjConstruct(lmcry_gcry)
52 BEGINobjDestruct(lmcry_gcry) CODESTARTobjDestruct(lmcry_gcry)
53 	rsgcryCtxDel(pThis-&gt;ctx);
54 ENDobjDestruct(lmcry_gcry)
55 static rsRetVal
56 SetCnfParam(void *pT, struct nvlst *lst, int paramType)
57 {
58 	lmcry_gcry_t *pThis = (lmcry_gcry_t*) pT;
59 	int i, r;
60 	unsigned keylen = 0;
61 	uchar *key = NULL;
62 	uchar *keyfile = NULL;
63 	uchar *keyprogram = NULL;
64 	uchar *algo = NULL;
65 	uchar *mode = NULL;
66 	int nKeys; 	struct cnfparamvals *pvals;
67 	struct cnfparamblk *pblk;
68 	DEFiRet;
69 	pblk = (paramType == CRYPROV_PARAMTYPE_REGULAR ) ?  &amp;pblkRegular : &amp;pblkQueue;
70 	nKeys = 0;
71 	pvals = nvlstGetParams(lst, pblk, NULL);
72 	if(pvals == NULL) {
73 		parser_errmsg("error crypto provider gcryconfig parameters]");
74 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
75 	}
76 	if(Debug) {
77 		dbgprintf("param blk in lmcry_gcry:\n");
78 		cnfparamsPrint(pblk, pvals);
79 	}
80 	for(i = 0 ; i &lt; pblk-&gt;nParams ; ++i) {
81 		if(!pvals[i].bUsed)
82 			continue;
83 		if(!strcmp(pblk-&gt;descr[i].name, "cry.key") ||
84 		   !strcmp(pblk-&gt;descr[i].name, "queue.cry.key")) {
85 			key = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
86 			++nKeys;
87 		} else if(!strcmp(pblk-&gt;descr[i].name, "cry.keyfile") ||
88 		          !strcmp(pblk-&gt;descr[i].name, "queue.cry.keyfile")) {
89 			keyfile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
90 			++nKeys;
91 		} else if(!strcmp(pblk-&gt;descr[i].name, "cry.keyprogram") ||
92 		          !strcmp(pblk-&gt;descr[i].name, "queue.cry.keyprogram")) {
93 			keyprogram = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
94 			++nKeys;
95 		} else if(!strcmp(pblk-&gt;descr[i].name, "cry.mode") ||
96 		          !strcmp(pblk-&gt;descr[i].name, "queue.cry.mode")) {
97 			mode = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
98 		} else if(!strcmp(pblk-&gt;descr[i].name, "cry.algo") ||
99 		          !strcmp(pblk-&gt;descr[i].name, "queue.cry.algo")) {
100 			algo = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
101 		} else {
102 			DBGPRINTF("lmcry_gcry: program error, non-handled "
103 			  "param '%s'\n", pblk-&gt;descr[i].name);
104 		}
105 	}
106 	if(algo != NULL) {
107 		iRet = rsgcrySetAlgo(pThis-&gt;ctx, algo);
108 		if(iRet != RS_RET_OK) {
109 			LogError(0, iRet, "cry.algo '%s' is not know/supported", algo);
110 			FINALIZE;
111 		}
112 	}
113 	if(mode != NULL) {
114 		iRet = rsgcrySetMode(pThis-&gt;ctx, mode);
115 		if(iRet != RS_RET_OK) {
116 			LogError(0, iRet, "cry.mode '%s' is not know/supported", mode);
117 			FINALIZE;
118 		}
119 	}
120 	if(nKeys != 1) {
121 		LogError(0, RS_RET_INVALID_PARAMS, "excactly one of the following "
122 			"parameters can be specified: cry.key, cry.keyfile, cry.keyprogram\n");
123 		ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
124 	}
125 	if(key != NULL) {
126 		LogError(0, RS_RET_ERR, "Note: specifying an actual key directly from the "
127 			"config file is highly insecure - DO NOT USE FOR PRODUCTION");
128 		keylen = strlen((char*)key);
129 	}
130 	if(keyfile != NULL) {
131 		r = gcryGetKeyFromFile((char*)keyfile, (char**)&amp;key, &amp;keylen);
132 		if(r != 0) {
133 			LogError(errno, RS_RET_ERR, "error reading keyfile %s",
134 				keyfile);
135 			ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
136 		}
137 	}
138 	if(keyprogram != NULL) {
139 		r = gcryGetKeyFromProg((char*)keyprogram, (char**)&amp;key, &amp;keylen);
140 		if(r != 0) {
141 			LogError(0, RS_RET_ERR, "error %d obtaining key from program %s\n",
142 				r, keyprogram);
143 			ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
144 		}
145 	}
146 	r = rsgcrySetKey(pThis-&gt;ctx, key, keylen);
147 	if(r &gt; 0) {
148 		LogError(0, RS_RET_INVALID_PARAMS, "Key length %d expected, but "
149 			"key of length %d given", r, keylen);
150 		ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
151 	}
152 finalize_it:
153 	free(key);
154 	free(keyfile);
155 	free(algo);
156 	free(keyprogram);
157 	free(mode);
158 	if(pvals != NULL)
159 		cnfparamvalsDestruct(pvals, pblk);
160 	RETiRet;
161 }
162 static void
163 SetDeleteOnClose(void *pF, int val)
164 {
165 	gcryfileSetDeleteOnClose(pF, val);
166 }
167 static rsRetVal
168 GetBytesLeftInBlock(void *pF, ssize_t *left)
169 {
170 	return gcryfileGetBytesLeftInBlock((gcryfile) pF, left);
171 }
172 static rsRetVal
173 DeleteStateFiles(uchar *logfn)
174 {
175 	return gcryfileDeleteState(logfn);
176 }
177 static rsRetVal
178 OnFileOpen(void *pT, uchar *fn, void *pGF, char openMode)
179 {
180 	lmcry_gcry_t *pThis = (lmcry_gcry_t*) pT;
181 	gcryfile *pgf = (gcryfile*) pGF;
182 	DEFiRet;
183 	DBGPRINTF("lmcry_gcry: open file '%s', mode '%c'\n", fn, openMode);
184 	iRet = rsgcryInitCrypt(pThis-&gt;ctx, pgf, fn, openMode);
185 	if(iRet != RS_RET_OK) {
186 		LogError(0, iRet, "Encryption Provider"
187 			"Error: cannot open .encinfo file - disabling log file");
188 	}
189 	RETiRet;
190 }
191 static rsRetVal
192 Decrypt(void *pF, uchar *rec, size_t *lenRec)
193 {
194 	DEFiRet;
195 	iRet = rsgcryDecrypt(pF, rec, lenRec);
196 	RETiRet;
197 }
198 static rsRetVal
199 Encrypt(void *pF, uchar *rec, size_t *lenRec)
200 {
201 	DEFiRet;
202 	iRet = rsgcryEncrypt(pF, rec, lenRec);
203 	RETiRet;
204 }
205 static rsRetVal
206 OnFileClose(void *pF, off64_t offsLogfile)
207 {
208 	DEFiRet;
209 	gcryfileDestruct(pF, offsLogfile);
210 	RETiRet;
211 }
212 BEGINobjQueryInterface(lmcry_gcry)
213 CODESTARTobjQueryInterface(lmcry_gcry)
214 	 if(pIf-&gt;ifVersion != cryprovCURR_IF_VERSION) {		ABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);
215 	}
216 	pIf-&gt;Construct = (rsRetVal(*)(void*)) lmcry_gcryConstruct;
217 	pIf-&gt;SetCnfParam = SetCnfParam;
218 	pIf-&gt;SetDeleteOnClose = SetDeleteOnClose;
219 	pIf-&gt;Destruct = (rsRetVal(*)(void*)) lmcry_gcryDestruct;
220 	pIf-&gt;OnFileOpen = OnFileOpen;
221 	pIf-&gt;Encrypt = Encrypt;
222 	pIf-&gt;Decrypt = Decrypt;
223 	pIf-&gt;OnFileClose = OnFileClose;
224 	pIf-&gt;DeleteStateFiles = DeleteStateFiles;
225 	pIf-&gt;GetBytesLeftInBlock = GetBytesLeftInBlock;
226 finalize_it:
227 ENDobjQueryInterface(lmcry_gcry)
228 BEGINObjClassExit(lmcry_gcry, OBJ_IS_LOADABLE_MODULE) CODESTARTObjClassExit(lmcry_gcry)
229 	objRelease(glbl, CORE_COMPONENT);
230 	rsgcryExit();
231 ENDObjClassExit(lmcry_gcry)
232 BEGINObjClassInit(lmcry_gcry, 1, OBJ_IS_LOADABLE_MODULE) 	CHKiRet(objUse(glbl, CORE_COMPONENT));
233 	if(rsgcryInit() != 0) {
234 		LogError(0, RS_RET_CRYPROV_ERR, "error initializing "
235 			"crypto provider - cannot encrypt");
236 		ABORT_FINALIZE(RS_RET_CRYPROV_ERR);
237 	}
238 ENDObjClassInit(lmcry_gcry)
239 BEGINmodExit
240 CODESTARTmodExit
241 	lmcry_gcryClassExit();
242 ENDmodExit
243 BEGINqueryEtryPt
244 CODESTARTqueryEtryPt
245 CODEqueryEtryPt_STD_LIB_QUERIES
246 ENDqueryEtryPt
247 BEGINmodInit()
248 CODESTARTmodInit
249 	*ipIFVersProvided = CURR_MOD_IF_VERSION; 	CHKiRet(lmcry_gcryClassInit(pModInfo)); ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
