<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for mmpstrucdata.c & lmcry_gcry.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for mmpstrucdata.c & lmcry_gcry.c
      </h3>
      <h1 align="center">
        5.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>mmpstrucdata.c (5.019305%)<TH>lmcry_gcry.c (5.4166665%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match2213-0.html#0',2,'match2213-1.html#0',3)" NAME="0">(71-78)<TD><A HREF="javascript:ZweiFrames('match2213-0.html#0',2,'match2213-1.html#0',3)" NAME="0">(51-58)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmpstrucdata.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* mmpstrucdata.c
 * Parse all fields of the message into structured data inside the
 * JSON tree.
 *
 * Copyright 2013-2018 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;ctype.h&gt;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;template.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;parserif.h&quot;

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;mmpstrucdata&quot;)


DEF_OMOD_STATIC_DATA

/* config variables */

typedef struct _instanceData {
	uchar *jsonRoot;	/**&lt; container where to store fields */
	int lowercase_SD_ID;
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
} wrkrInstanceData_t;

struct modConfData_s {
	rsconf_t *pConf;	/* our overall config object */
};
static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current exec process */


<A NAME="0"></A>/* tables for interfacing with the v6 config system */
/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match2213-1.html#0',3,'match2213-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	{ &quot;jsonroot&quot;, eCmdHdlrString, 0 },
	{ &quot;sd_name.lowercase&quot;, eCmdHdlrBinary, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};</B></FONT>

BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
ENDbeginCnfLoad

BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf

BEGINfreeCnf
CODESTARTfreeCnf
ENDfreeCnf


BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
ENDcreateWrkrInstance


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
ENDisCompatibleWithFeature


BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;jsonRoot);
ENDfreeInstance

BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
ENDfreeWrkrInstance


static inline void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;jsonRoot = NULL;
	pData-&gt;lowercase_SD_ID = 1;
}

BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
CODESTARTnewActInst
	DBGPRINTF(&quot;newActInst (mmpstrucdata)\n&quot;);
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CODE_STD_STRING_REQUESTnewActInst(1)
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, &quot;jsonroot&quot;)) {
			size_t lenvar = es_strlen(pvals[i].val.d.estr);
			pData-&gt;jsonRoot = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			if(pData-&gt;jsonRoot[0] == '$') {
				/* pre 8.35, the jsonRoot name needed to be specified without
				 * the leading $. This was confusing, so we now require a full
				 * variable name. Nevertheless, we still need to support the
				 * version without $. -- rgerhards, 2018-05-16
				 */
				/* copy lenvar size because of \0 string terminator */
				memmove(pData-&gt;jsonRoot, pData-&gt;jsonRoot+1,  lenvar);
				--lenvar;
			}
			if(   (lenvar == 0)
			   || (  !(   pData-&gt;jsonRoot[0] == '!'
			           || pData-&gt;jsonRoot[0] == '.'
			           || pData-&gt;jsonRoot[0] == '/' ) )
			   ) {
				parser_errmsg(&quot;mmpstrucdata: invalid jsonRoot name '%s', name must &quot;
					&quot;start with either '$!', '$.', or '$/'&quot;, pData-&gt;jsonRoot);
				ABORT_FINALIZE(RS_RET_INVALID_VAR);
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;sd_name.lowercase&quot;)) {
			pData-&gt;lowercase_SD_ID = pvals[i].val.d.n;
		} else {
			LogError(0, RS_RET_INTERNAL_ERROR,
				&quot;mmpstrucdata: internal program error, non-handled &quot;
				&quot;param '%s'\n&quot;, actpblk.descr[i].name);
		}
	}
	if(pData-&gt;jsonRoot == NULL) {
		CHKmalloc(pData-&gt;jsonRoot = (uchar*) strdup(&quot;!&quot;));
	}

CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
ENDdbgPrintInstInfo


BEGINtryResume
CODESTARTtryResume
ENDtryResume


static rsRetVal
parsePARAM_VALUE(uchar *sdbuf, int lenbuf, int *curridx, uchar *fieldbuf)
{
	int i, j;
	DEFiRet;
	i = *curridx;
	j = 0;
	while(i &lt; lenbuf &amp;&amp; sdbuf[i] != '&quot;') {
		if(sdbuf[i] == '\\') {
			if(++i == lenbuf) {
				fieldbuf[j++] = '\\';
			} else {
				if(sdbuf[i] == '&quot;') {
					fieldbuf[j++] = '&quot;';
				} else if(sdbuf[i] == '\\') {
					fieldbuf[j++] = '\\';
				} else if(sdbuf[i] == ']') {
					fieldbuf[j++] = ']';
				} else {
					fieldbuf[j++] = '\\';
					fieldbuf[j++] = sdbuf[i];
				}
				++i;
			}
		} else {
			fieldbuf[j++] = sdbuf[i++];
		}
	}
	fieldbuf[j] = '\0';
	*curridx = i;
	RETiRet;
}


static rsRetVal ATTR_NONNULL()
parseSD_NAME(instanceData *const pData, uchar *sdbuf, int lenbuf, int *curridx, uchar *namebuf)
{
	int i, j;
	DEFiRet;
	i = *curridx;
	for(j = 0 ; i &lt; lenbuf &amp;&amp; j &lt; 32; ++j) {
		if(   sdbuf[i] == '=' || sdbuf[i] == '&quot;'
		   || sdbuf[i] == ']' || sdbuf[i] == ' ')
			break;
		namebuf[j] = pData-&gt;lowercase_SD_ID ? tolower(sdbuf[i]) : sdbuf[i];
		++i;
	}
	namebuf[j] = '\0';
	*curridx = i;
	RETiRet;
}


static rsRetVal ATTR_NONNULL()
parseSD_PARAM(instanceData *const pData, uchar *sdbuf, int lenbuf, int *curridx, struct json_object *jroot)
{
	int i;
	uchar pName[33];
	uchar pVal[32*1024];
	struct json_object *jval;
	DEFiRet;
	
	i = *curridx;
	CHKiRet(parseSD_NAME(pData, sdbuf, lenbuf, &amp;i, pName));
	if(sdbuf[i] != '=') {
		ABORT_FINALIZE(RS_RET_STRUC_DATA_INVLD);
	}
	++i;
	if(sdbuf[i] != '&quot;') {
		ABORT_FINALIZE(RS_RET_STRUC_DATA_INVLD);
	}
	++i;
	CHKiRet(parsePARAM_VALUE(sdbuf, lenbuf, &amp;i, pVal));
	if(sdbuf[i] != '&quot;') {
		ABORT_FINALIZE(RS_RET_STRUC_DATA_INVLD);
	}
	++i;

	jval = json_object_new_string((char*)pVal);
	json_object_object_add(jroot, (char*)pName, jval);

	*curridx = i;
finalize_it:
	RETiRet;
}


static rsRetVal ATTR_NONNULL()
parseSD_ELEMENT(instanceData *const pData, uchar *sdbuf, int lenbuf, int *curridx, struct json_object *jroot)
{
	int i;
	uchar sd_id[33];
	struct json_object *json = NULL;
	DEFiRet;
	
	i = *curridx;
	if(sdbuf[i] != '[') {
		ABORT_FINALIZE(RS_RET_STRUC_DATA_INVLD);
	}
	++i; /* eat '[' */

	CHKiRet(parseSD_NAME(pData, sdbuf, lenbuf, &amp;i, sd_id));
	json =  json_object_new_object();

	while(i &lt; lenbuf) {
		if(sdbuf[i] == ']') {
			break;
		} else if(sdbuf[i] != ' ') {
			ABORT_FINALIZE(RS_RET_STRUC_DATA_INVLD);
		}
		++i;
		while(i &lt; lenbuf &amp;&amp; sdbuf[i] == ' ')
			++i;
		CHKiRet(parseSD_PARAM(pData, sdbuf, lenbuf, &amp;i, json));
	}

	if(sdbuf[i] != ']') {
		DBGPRINTF(&quot;mmpstrucdata: SD-ELEMENT does not terminate with &quot;
		          &quot;']': '%s'\n&quot;, sdbuf+i);
		ABORT_FINALIZE(RS_RET_STRUC_DATA_INVLD);
	}
	++i; /* eat ']' */
	*curridx = i;
	json_object_object_add(jroot, (char*)sd_id, json);
finalize_it:
	if(iRet != RS_RET_OK &amp;&amp; json != NULL)
		json_object_put(json);
	RETiRet;
}

static rsRetVal ATTR_NONNULL()
parse_sd(instanceData *const pData, smsg_t *const pMsg)
{
	struct json_object *json, *jroot;
	uchar *sdbuf;
	int lenbuf;
	int i = 0;
	DEFiRet;

	json =  json_object_new_object();
	if(json == NULL) {
		ABORT_FINALIZE(RS_RET_ERR);
	}
	MsgGetStructuredData(pMsg, &amp;sdbuf,&amp;lenbuf);
	while(i &lt; lenbuf) {
		CHKiRet(parseSD_ELEMENT(pData, sdbuf, lenbuf, &amp;i, json));
	}

	jroot =  json_object_new_object();
	if(jroot == NULL) {
		ABORT_FINALIZE(RS_RET_ERR);
	}
	json_object_object_add(jroot, &quot;rfc5424-sd&quot;, json);
	msgAddJSON(pMsg, pData-&gt;jsonRoot, jroot, 0, 0);
finalize_it:
	if(iRet != RS_RET_OK &amp;&amp; json != NULL)
		json_object_put(json);
	RETiRet;
}


BEGINdoAction_NoStrings
	smsg_t **ppMsg = (smsg_t **) pMsgData;
	smsg_t *pMsg = ppMsg[0];
CODESTARTdoAction
	DBGPRINTF(&quot;mmpstrucdata: enter\n&quot;);
	if(!MsgHasStructuredData(pMsg)) {
		DBGPRINTF(&quot;mmpstrucdata: message does not have structured data\n&quot;);
		FINALIZE;
	}
	/* don't check return code - we never want rsyslog to retry
	 * or suspend this action!
	 */
	parse_sd(pWrkrData-&gt;pData, pMsg);
finalize_it:
ENDdoAction


BEGINmodExit
CODESTARTmodExit
ENDmodExit


NO_LEGACY_CONF_parseSelectorAct
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	DBGPRINTF(&quot;mmpstrucdata: module compiled with rsyslog version %s.\n&quot;, VERSION);
ENDmodInit
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lmcry_gcry.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* lmcry_gcry.c
 *
 * An implementation of the cryprov interface for libgcrypt.
 *
 * Copyright 2013-2017 Rainer Gerhards and Adiscon GmbH.
 *
 * This file is part of the rsyslog runtime library.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;

#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;

#include &quot;module-template.h&quot;
#include &quot;glbl.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;cryprov.h&quot;
#include &quot;parserif.h&quot;
#include &quot;libgcry.h&quot;
#include &quot;lmcry_gcry.h&quot;

MODULE_TYPE_LIB
MODULE_TYPE_NOKEEP

/* static data */
DEFobjStaticHelpers
DEFobjCurrIf(glbl)

/* tables for interfacing with the v6 config system */
static struct cnfparamdescr cnfpdescrRegular[] = {
<A NAME="0"></A>	{ &quot;cry.key&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;cry.keyfile&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;cry.keyprogram&quot;, eCmdHdlrGetWord, 0 },
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2213-0.html#0',2,'match2213-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	{ &quot;cry.mode&quot;, eCmdHdlrGetWord, 0 }, /* CBC, ECB, etc */
	{ &quot;cry.algo&quot;, eCmdHdlrGetWord, 0 }
};
static struct cnfparamblk pblkRegular =
	{ CNFPARAMBLK_VERSION,
	  sizeof(cnfpdescrRegular)/sizeof(struct cnfparamdescr),
	  cnfpdescrRegular
	};</B></FONT>

static struct cnfparamdescr cnfpdescrQueue[] = {
	{ &quot;queue.cry.key&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;queue.cry.keyfile&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;queue.cry.keyprogram&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;queue.cry.mode&quot;, eCmdHdlrGetWord, 0 }, /* CBC, ECB, etc */
	{ &quot;queue.cry.algo&quot;, eCmdHdlrGetWord, 0 }
};
static struct cnfparamblk pblkQueue =
	{ CNFPARAMBLK_VERSION,
	  sizeof(cnfpdescrQueue)/sizeof(struct cnfparamdescr),
	  cnfpdescrQueue
	};


#if 0
static void
errfunc(__attribute__((unused)) void *usrptr, uchar *emsg)
{
	LogError(0, RS_RET_CRYPROV_ERR, &quot;Crypto Provider&quot;
		&quot;Error: %s - disabling encryption&quot;, emsg);
}
#endif

/* Standard-Constructor
 */
BEGINobjConstruct(lmcry_gcry)
	CHKmalloc(pThis-&gt;ctx = gcryCtxNew());
finalize_it:
ENDobjConstruct(lmcry_gcry)


/* destructor for the lmcry_gcry object */
BEGINobjDestruct(lmcry_gcry) /* be sure to specify the object type also in END and CODESTART macros! */
CODESTARTobjDestruct(lmcry_gcry)
	rsgcryCtxDel(pThis-&gt;ctx);
ENDobjDestruct(lmcry_gcry)


/* apply all params from param block to us. This must be called
 * after construction, but before the OnFileOpen() entry point.
 * Defaults are expected to have been set during construction.
 */
static rsRetVal
SetCnfParam(void *pT, struct nvlst *lst, int paramType)
{
	lmcry_gcry_t *pThis = (lmcry_gcry_t*) pT;
	int i, r;
	unsigned keylen = 0;
	uchar *key = NULL;
	uchar *keyfile = NULL;
	uchar *keyprogram = NULL;
	uchar *algo = NULL;
	uchar *mode = NULL;
	int nKeys; /* number of keys (actually methods) specified */
	struct cnfparamvals *pvals;
	struct cnfparamblk *pblk;
	DEFiRet;

	pblk = (paramType == CRYPROV_PARAMTYPE_REGULAR ) ?  &amp;pblkRegular : &amp;pblkQueue;
	nKeys = 0;
	pvals = nvlstGetParams(lst, pblk, NULL);
	if(pvals == NULL) {
		parser_errmsg(&quot;error crypto provider gcryconfig parameters]&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if(Debug) {
		dbgprintf(&quot;param blk in lmcry_gcry:\n&quot;);
		cnfparamsPrint(pblk, pvals);
	}

	for(i = 0 ; i &lt; pblk-&gt;nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(pblk-&gt;descr[i].name, &quot;cry.key&quot;) ||
		   !strcmp(pblk-&gt;descr[i].name, &quot;queue.cry.key&quot;)) {
			key = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
			++nKeys;
		} else if(!strcmp(pblk-&gt;descr[i].name, &quot;cry.keyfile&quot;) ||
		          !strcmp(pblk-&gt;descr[i].name, &quot;queue.cry.keyfile&quot;)) {
			keyfile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			++nKeys;
		} else if(!strcmp(pblk-&gt;descr[i].name, &quot;cry.keyprogram&quot;) ||
		          !strcmp(pblk-&gt;descr[i].name, &quot;queue.cry.keyprogram&quot;)) {
			keyprogram = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			++nKeys;
		} else if(!strcmp(pblk-&gt;descr[i].name, &quot;cry.mode&quot;) ||
		          !strcmp(pblk-&gt;descr[i].name, &quot;queue.cry.mode&quot;)) {
			mode = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(pblk-&gt;descr[i].name, &quot;cry.algo&quot;) ||
		          !strcmp(pblk-&gt;descr[i].name, &quot;queue.cry.algo&quot;)) {
			algo = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {
			DBGPRINTF(&quot;lmcry_gcry: program error, non-handled &quot;
			  &quot;param '%s'\n&quot;, pblk-&gt;descr[i].name);
		}
	}
	if(algo != NULL) {
		iRet = rsgcrySetAlgo(pThis-&gt;ctx, algo);
		if(iRet != RS_RET_OK) {
			LogError(0, iRet, &quot;cry.algo '%s' is not know/supported&quot;, algo);
			FINALIZE;
		}
	}
	if(mode != NULL) {
		iRet = rsgcrySetMode(pThis-&gt;ctx, mode);
		if(iRet != RS_RET_OK) {
			LogError(0, iRet, &quot;cry.mode '%s' is not know/supported&quot;, mode);
			FINALIZE;
		}
	}
	/* note: key must be set AFTER algo/mode is set (as it depends on them) */
	if(nKeys != 1) {
		LogError(0, RS_RET_INVALID_PARAMS, &quot;excactly one of the following &quot;
			&quot;parameters can be specified: cry.key, cry.keyfile, cry.keyprogram\n&quot;);
		ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
	}
	if(key != NULL) {
		LogError(0, RS_RET_ERR, &quot;Note: specifying an actual key directly from the &quot;
			&quot;config file is highly insecure - DO NOT USE FOR PRODUCTION&quot;);
		keylen = strlen((char*)key);
	}
	if(keyfile != NULL) {
		r = gcryGetKeyFromFile((char*)keyfile, (char**)&amp;key, &amp;keylen);
		if(r != 0) {
			LogError(errno, RS_RET_ERR, &quot;error reading keyfile %s&quot;,
				keyfile);
			ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
		}
	}
	if(keyprogram != NULL) {
		r = gcryGetKeyFromProg((char*)keyprogram, (char**)&amp;key, &amp;keylen);
		if(r != 0) {
			LogError(0, RS_RET_ERR, &quot;error %d obtaining key from program %s\n&quot;,
				r, keyprogram);
			ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
		}
	}

	/* if we reach this point, we have a valid key */
	r = rsgcrySetKey(pThis-&gt;ctx, key, keylen);
	if(r &gt; 0) {
		LogError(0, RS_RET_INVALID_PARAMS, &quot;Key length %d expected, but &quot;
			&quot;key of length %d given&quot;, r, keylen);
		ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
	}

finalize_it:
	free(key);
	free(keyfile);
	free(algo);
	free(keyprogram);
	free(mode);
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, pblk);
	RETiRet;
}

static void
SetDeleteOnClose(void *pF, int val)
{
	gcryfileSetDeleteOnClose(pF, val);
}

static rsRetVal
GetBytesLeftInBlock(void *pF, ssize_t *left)
{
	return gcryfileGetBytesLeftInBlock((gcryfile) pF, left);
}

static rsRetVal
DeleteStateFiles(uchar *logfn)
{
	return gcryfileDeleteState(logfn);
}

static rsRetVal
OnFileOpen(void *pT, uchar *fn, void *pGF, char openMode)
{
	lmcry_gcry_t *pThis = (lmcry_gcry_t*) pT;
	gcryfile *pgf = (gcryfile*) pGF;
	DEFiRet;
	DBGPRINTF(&quot;lmcry_gcry: open file '%s', mode '%c'\n&quot;, fn, openMode);

	iRet = rsgcryInitCrypt(pThis-&gt;ctx, pgf, fn, openMode);
	if(iRet != RS_RET_OK) {
		LogError(0, iRet, &quot;Encryption Provider&quot;
			&quot;Error: cannot open .encinfo file - disabling log file&quot;);
	}
	RETiRet;
}

static rsRetVal
Decrypt(void *pF, uchar *rec, size_t *lenRec)
{
	DEFiRet;
	iRet = rsgcryDecrypt(pF, rec, lenRec);

	RETiRet;
}


static rsRetVal
Encrypt(void *pF, uchar *rec, size_t *lenRec)
{
	DEFiRet;
	iRet = rsgcryEncrypt(pF, rec, lenRec);

	RETiRet;
}

static rsRetVal
OnFileClose(void *pF, off64_t offsLogfile)
{
	DEFiRet;
	gcryfileDestruct(pF, offsLogfile);

	RETiRet;
}

BEGINobjQueryInterface(lmcry_gcry)
CODESTARTobjQueryInterface(lmcry_gcry)
	 if(pIf-&gt;ifVersion != cryprovCURR_IF_VERSION) {/* check for current version, increment on each change */
		ABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);
	}
	pIf-&gt;Construct = (rsRetVal(*)(void*)) lmcry_gcryConstruct;
	pIf-&gt;SetCnfParam = SetCnfParam;
	pIf-&gt;SetDeleteOnClose = SetDeleteOnClose;
	pIf-&gt;Destruct = (rsRetVal(*)(void*)) lmcry_gcryDestruct;
	pIf-&gt;OnFileOpen = OnFileOpen;
	pIf-&gt;Encrypt = Encrypt;
	pIf-&gt;Decrypt = Decrypt;
	pIf-&gt;OnFileClose = OnFileClose;
	pIf-&gt;DeleteStateFiles = DeleteStateFiles;
	pIf-&gt;GetBytesLeftInBlock = GetBytesLeftInBlock;
finalize_it:
ENDobjQueryInterface(lmcry_gcry)


BEGINObjClassExit(lmcry_gcry, OBJ_IS_LOADABLE_MODULE) /* CHANGE class also in END MACRO! */
CODESTARTObjClassExit(lmcry_gcry)
	/* release objects we no longer need */
	objRelease(glbl, CORE_COMPONENT);

	rsgcryExit();
ENDObjClassExit(lmcry_gcry)


BEGINObjClassInit(lmcry_gcry, 1, OBJ_IS_LOADABLE_MODULE) /* class, version */
	/* request objects we use */
	CHKiRet(objUse(glbl, CORE_COMPONENT));

	if(rsgcryInit() != 0) {
		LogError(0, RS_RET_CRYPROV_ERR, &quot;error initializing &quot;
			&quot;crypto provider - cannot encrypt&quot;);
		ABORT_FINALIZE(RS_RET_CRYPROV_ERR);
	}
ENDObjClassInit(lmcry_gcry)


/* --------------- here now comes the plumbing that makes as a library module --------------- */


BEGINmodExit
CODESTARTmodExit
	lmcry_gcryClassExit();
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_LIB_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
	/* Initialize all classes that are in our module - this includes ourselfs */
	CHKiRet(lmcry_gcryClassInit(pModInfo)); /* must be done after tcps_sess, as we use it */
ENDmodInit
</PRE>
</div>
  </div>
</body>
</html>
