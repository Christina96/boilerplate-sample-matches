
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-Win32_ANSI.c</h3>
            <pre><code>1  #include &lt;windows.h&gt;
2  #include &lt;stdio.h&gt;
3  #include &lt;stdlib.h&gt;
4  #include &quot;Win32_ANSI.h&quot;
5  #define lenof(array) (sizeof(array)/sizeof(*(array)))
6  typedef struct {
7      BYTE foreground;	
8      BYTE background;	
9      BYTE bold;	
10      BYTE underline;	
11      BYTE rvideo;	
12      BYTE concealed;	
13      BYTE reverse; 
14  } GRM, *PGRM;	
15  #define is_digit(c) (&#x27;0&#x27; &lt;= (c) &amp;&amp; (c) &lt;= &#x27;9&#x27;)
16  HANDLE	  hConOut;		
17  #define ESC	&#x27;\x1B&#x27;          
18  #define BEL	&#x27;\x07&#x27;
19  #define SO	&#x27;\x0E&#x27;          
20  #define SI	&#x27;\x0F&#x27;          
21  #define MAX_ARG 16		
22  int   state;			
23  TCHAR prefix;			
24  TCHAR prefix2;			
25  TCHAR suffix;			
26  int   es_argc;			
27  int   es_argv[MAX_ARG]; 	
28  TCHAR Pt_arg[MAX_PATH * 2];	
29  int   Pt_len;
30  BOOL  shifted;
31  const WCHAR G1[] =
32  {
33      &#x27; &#x27;,          
34      L&#x27;\x2666&#x27;,    
35      L&#x27;\x2592&#x27;,    
36      L&#x27;\x2409&#x27;,    
37      L&#x27;\x240c&#x27;,    
38      L&#x27;\x240d&#x27;,    
39      L&#x27;\x240a&#x27;,    
40      L&#x27;\x00b0&#x27;,    
41      L&#x27;\x00b1&#x27;,    
42      L&#x27;\x2424&#x27;,    
43      L&#x27;\x240b&#x27;,    
44      L&#x27;\x2518&#x27;,    
45      L&#x27;\x2510&#x27;,    
46      L&#x27;\x250c&#x27;,    
47      L&#x27;\x2514&#x27;,    
48      L&#x27;\x253c&#x27;,    
49      L&#x27;\x00af&#x27;,    
50      L&#x27;\x25ac&#x27;,    
51      L&#x27;\x2500&#x27;,    
52      L&#x27;_&#x27;,         
53      L&#x27;_&#x27;,         
54      L&#x27;\x251c&#x27;,    
55      L&#x27;\x2524&#x27;,    
56      L&#x27;\x2534&#x27;,    
57      L&#x27;\x252c&#x27;,    
58      L&#x27;\x2502&#x27;,    
59      L&#x27;\x2264&#x27;,    
60      L&#x27;\x2265&#x27;,    
61      L&#x27;\x03c0&#x27;,    
62      L&#x27;\x2260&#x27;,    
63      L&#x27;\x00a3&#x27;,    
64      L&#x27;\x00b7&#x27;,    
65  };
66  #define FIRST_G1 &#x27;_&#x27;
67  #define LAST_G1  &#x27;~&#x27;
68  #define FOREGROUND_BLACK 0
69  #define FOREGROUND_WHITE FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE
70  #define BACKGROUND_BLACK 0
71  #define BACKGROUND_WHITE BACKGROUND_RED|BACKGROUND_GREEN|BACKGROUND_BLUE
72  const BYTE foregroundcolor[8] =
73  {
74      FOREGROUND_BLACK,			
75      FOREGROUND_RED,			
76      FOREGROUND_GREEN,			
77      FOREGROUND_RED | FOREGROUND_GREEN,	
78      FOREGROUND_BLUE,			
79      FOREGROUND_BLUE | FOREGROUND_RED,	
80      FOREGROUND_BLUE | FOREGROUND_GREEN,	
81      FOREGROUND_WHITE			
82  };
83  const BYTE backgroundcolor[8] =
84  {
85      BACKGROUND_BLACK,			
86      BACKGROUND_RED,			
87      BACKGROUND_GREEN,			
88      BACKGROUND_RED | BACKGROUND_GREEN,	
89      BACKGROUND_BLUE,			
90      BACKGROUND_BLUE | BACKGROUND_RED,	
91      BACKGROUND_BLUE | BACKGROUND_GREEN,	
92      BACKGROUND_WHITE,			
93  };
94  const BYTE attr2ansi[8] =		
95  {
96      0,					
97      4,					
98      2,					
99      6,					
100      1,					
101      5,					
102      3,					
103      7					
104  };
105  GRM grm;
106  COORD SavePos;
107  #define BUFFER_SIZE 2048
108  int   nCharInBuffer;
109  WCHAR ChBuffer[BUFFER_SIZE];
110  void FlushBuffer(void) {
111      DWORD nWritten;
112      if (nCharInBuffer &lt;= 0) return;
113      WriteConsole(hConOut, ChBuffer, nCharInBuffer, &amp;nWritten, NULL);
114      nCharInBuffer = 0;
115  }
116  void PushBuffer(WCHAR c) {
117      if (shifted &amp;&amp; c &gt;= FIRST_G1 &amp;&amp; c &lt;= LAST_G1)
118          c = G1[c - FIRST_G1];
119      ChBuffer[nCharInBuffer] = c;
120      if (++nCharInBuffer == BUFFER_SIZE)
121          FlushBuffer();
122  }
123  void SendSequence(LPTSTR seq) {
124      DWORD out;
125      INPUT_RECORD in;
126      HANDLE hStdIn = GetStdHandle(STD_INPUT_HANDLE);
127      in.EventType = KEY_EVENT;
128      in.Event.KeyEvent.bKeyDown = TRUE;
129      in.Event.KeyEvent.wRepeatCount = 1;
130      in.Event.KeyEvent.wVirtualKeyCode = 0;
131      in.Event.KeyEvent.wVirtualScanCode = 0;
132      in.Event.KeyEvent.dwControlKeyState = 0;
133      for (; *seq; ++seq) {
134          in.Event.KeyEvent.uChar.UnicodeChar = *seq;
135          WriteConsoleInput(hStdIn, &amp;in, 1, &amp;out);
136      }
137  }
138  void InterpretEscSeq(void) {
139      int  i;
140      WORD attribut;
141      CONSOLE_SCREEN_BUFFER_INFO Info;
142      CONSOLE_CURSOR_INFO CursInfo;
143      DWORD len, NumberOfCharsWritten;
144      COORD Pos;
145      SMALL_RECT Rect;
146      CHAR_INFO  CharInfo;
147      if (prefix == &#x27;[&#x27;) {
148          if (prefix2 == &#x27;?&#x27; &amp;&amp; (suffix == &#x27;h&#x27; || suffix == &#x27;l&#x27;)) {
149              if (es_argc == 1 &amp;&amp; es_argv[0] == 25) {
150                  GetConsoleCursorInfo(hConOut, &amp;CursInfo);
151                  CursInfo.bVisible = (suffix == &#x27;h&#x27;);
152                  SetConsoleCursorInfo(hConOut, &amp;CursInfo);
153                  return;
154              }
155          }
156          if (prefix2 != 0)
157              return;
158          GetConsoleScreenBufferInfo(hConOut, &amp;Info);
159          switch (suffix) {
160              case &#x27;m&#x27;:
161                  if (es_argc == 0) es_argv[es_argc++] = 0;
162                  for (i = 0; i &lt; es_argc; i++) {
163                      if (30 &lt;= es_argv[i] &amp;&amp; es_argv[i] &lt;= 37)
164                          grm.foreground = es_argv[i] - 30;
165                      else if (40 &lt;= es_argv[i] &amp;&amp; es_argv[i] &lt;= 47)
166                          grm.background = es_argv[i] - 40;
167                      else switch (es_argv[i]) {
168                          case 0:
169                          case 39:
170                          case 49:
171                          {
172                                     TCHAR def[4];
173                                     int   a;
174                                     *def = &#x27;7&#x27;; def[1] = &#x27;\0&#x27;;
175                                     GetEnvironmentVariable(L&quot;ANSICON_DEF&quot;, def, lenof(def));
176                                     a = wcstol(def, NULL, 16);
177                                     grm.reverse = FALSE;
178                                     if (a &lt; 0) {
179                                         grm.reverse = TRUE;
180                                         a = -a;
181                                     }
182                                     if (es_argv[i] != 49)
183                                         grm.foreground = attr2ansi[a &amp; 7];
184                                     if (es_argv[i] != 39)
185                                         grm.background = attr2ansi[(a &gt;&gt; 4) &amp; 7];
186                                     if (es_argv[i] == 0) {
187                                         if (es_argc == 1) {
188                                             grm.bold = a &amp; FOREGROUND_INTENSITY;
189                                             grm.underline = a &amp; BACKGROUND_INTENSITY;
190                                         } else {
191                                             grm.bold = 0;
192                                             grm.underline = 0;
193                                         }
194                                         grm.rvideo = 0;
195                                         grm.concealed = 0;
196                                     }
197                          }
198                              break;
199                          case  1: grm.bold = FOREGROUND_INTENSITY; break;
200                          case  5: 
201                          case  4: grm.underline = BACKGROUND_INTENSITY; break;
202                          case  7: grm.rvideo = 1; break;
203                          case  8: grm.concealed = 1; break;
204                          case 21: 
205                          case 22: grm.bold = 0; break;
206                          case 25:
207                          case 24: grm.underline = 0; break;
208                          case 27: grm.rvideo = 0; break;
209                          case 28: grm.concealed = 0; break;
210                      }
211                  }
212                  if (grm.concealed) {
213                      if (grm.rvideo) {
<span onclick='openModal()' class='match'>214                          attribut = foregroundcolor[grm.foreground]
215                              | backgroundcolor[grm.foreground];
216                          if (grm.bold)
217                              attribut |= FOREGROUND_INTENSITY | BACKGROUND_INTENSITY;
</span>218                      } else {
219                          attribut = foregroundcolor[grm.background]
220                              | backgroundcolor[grm.background];
221                          if (grm.underline)
222                              attribut |= FOREGROUND_INTENSITY | BACKGROUND_INTENSITY;
223                      }
224                  } else if (grm.rvideo) {
225                      attribut = foregroundcolor[grm.background]
226                          | backgroundcolor[grm.foreground];
227                      if (grm.bold)
228                          attribut |= BACKGROUND_INTENSITY;
229                      if (grm.underline)
230                          attribut |= FOREGROUND_INTENSITY;
231                  } else
232                      attribut = foregroundcolor[grm.foreground] | grm.bold
233                      | backgroundcolor[grm.background] | grm.underline;
234                  if (grm.reverse)
235                      attribut = ((attribut &gt;&gt; 4) &amp; 15) | ((attribut &amp; 15) &lt;&lt; 4);
236                  SetConsoleTextAttribute(hConOut, attribut);
237                  return;
238              case &#x27;J&#x27;:
239                  if (es_argc == 0) es_argv[es_argc++] = 0; 
240                  if (es_argc != 1) return;
241                  switch (es_argv[0]) {
242                      case 0:		
243                          len = (Info.dwSize.Y - Info.dwCursorPosition.Y - 1) * Info.dwSize.X
244                              + Info.dwSize.X - Info.dwCursorPosition.X - 1;
245                          FillConsoleOutputCharacter(hConOut, &#x27; &#x27;, len,
246                              Info.dwCursorPosition,
247                              &amp;NumberOfCharsWritten);
248                          FillConsoleOutputAttribute(hConOut, Info.wAttributes, len,
249                              Info.dwCursorPosition,
250                              &amp;NumberOfCharsWritten);
251                          return;
252                      case 1:		
253                          Pos.X = 0;
254                          Pos.Y = 0;
255                          len = Info.dwCursorPosition.Y * Info.dwSize.X
256                              + Info.dwCursorPosition.X + 1;
257                          FillConsoleOutputCharacter(hConOut, &#x27; &#x27;, len, Pos,
258                              &amp;NumberOfCharsWritten);
259                          FillConsoleOutputAttribute(hConOut, Info.wAttributes, len, Pos,
260                              &amp;NumberOfCharsWritten);
261                          return;
262                      case 2:		
263                          Pos.X = 0;
264                          Pos.Y = 0;
265                          len = Info.dwSize.X * Info.dwSize.Y;
266                          FillConsoleOutputCharacter(hConOut, &#x27; &#x27;, len, Pos,
267                              &amp;NumberOfCharsWritten);
268                          FillConsoleOutputAttribute(hConOut, Info.wAttributes, len, Pos,
269                              &amp;NumberOfCharsWritten);
270                          SetConsoleCursorPosition(hConOut, Pos);
271                          return;
272                      default:
273                          return;
274                  }
275              case &#x27;K&#x27;:
276                  if (es_argc == 0) es_argv[es_argc++] = 0; 
277                  if (es_argc != 1) return;
278                  switch (es_argv[0]) {
279                      case 0:		
280                          len = Info.dwSize.X - Info.dwCursorPosition.X + 1;
281                          FillConsoleOutputCharacter(hConOut, &#x27; &#x27;, len,
282                              Info.dwCursorPosition,
283                              &amp;NumberOfCharsWritten);
284                          FillConsoleOutputAttribute(hConOut, Info.wAttributes, len,
285                              Info.dwCursorPosition,
286                              &amp;NumberOfCharsWritten);
287                          return;
288                      case 1:		
289                          Pos.X = 0;
290                          Pos.Y = Info.dwCursorPosition.Y;
291                          FillConsoleOutputCharacter(hConOut, &#x27; &#x27;,
292                              Info.dwCursorPosition.X + 1, Pos,
293                              &amp;NumberOfCharsWritten);
294                          FillConsoleOutputAttribute(hConOut, Info.wAttributes,
295                              Info.dwCursorPosition.X + 1, Pos,
296                              &amp;NumberOfCharsWritten);
297                          return;
298                      case 2:		
299                          Pos.X = 0;
300                          Pos.Y = Info.dwCursorPosition.Y;
301                          FillConsoleOutputCharacter(hConOut, &#x27; &#x27;, Info.dwSize.X, Pos,
302                              &amp;NumberOfCharsWritten);
303                          FillConsoleOutputAttribute(hConOut, Info.wAttributes,
304                              Info.dwSize.X, Pos,
305                              &amp;NumberOfCharsWritten);
306                          return;
307                      default:
308                          return;
309                  }
310              case &#x27;X&#x27;:                 
311                  if (es_argc == 0) es_argv[es_argc++] = 1; 
312                  if (es_argc != 1) return;
313                  FillConsoleOutputCharacter(hConOut, &#x27; &#x27;, es_argv[0],
314                      Info.dwCursorPosition,
315                      &amp;NumberOfCharsWritten);
316                  FillConsoleOutputAttribute(hConOut, Info.wAttributes, es_argv[0],
317                      Info.dwCursorPosition,
318                      &amp;NumberOfCharsWritten);
319                  return;
320              case &#x27;L&#x27;:                 
321                  if (es_argc == 0) es_argv[es_argc++] = 1; 
322                  if (es_argc != 1) return;
323                  Rect.Left = 0;
324                  Rect.Top = Info.dwCursorPosition.Y;
325                  Rect.Right = Info.dwSize.X - 1;
326                  Rect.Bottom = Info.dwSize.Y - 1;
327                  Pos.X = 0;
328                  Pos.Y = Info.dwCursorPosition.Y + es_argv[0];
329                  CharInfo.Char.UnicodeChar = &#x27; &#x27;;
330                  CharInfo.Attributes = Info.wAttributes;
331                  ScrollConsoleScreenBuffer(hConOut, &amp;Rect, NULL, Pos, &amp;CharInfo);
332                  return;
333              case &#x27;M&#x27;:                 
334                  if (es_argc == 0) es_argv[es_argc++] = 1; 
335                  if (es_argc != 1) return;
336                  if (es_argv[0] &gt; Info.dwSize.Y - Info.dwCursorPosition.Y)
337                      es_argv[0] = Info.dwSize.Y - Info.dwCursorPosition.Y;
338                  Rect.Left = 0;
339                  Rect.Top = Info.dwCursorPosition.Y + es_argv[0];
340                  Rect.Right = Info.dwSize.X - 1;
341                  Rect.Bottom = Info.dwSize.Y - 1;
342                  Pos.X = 0;
343                  Pos.Y = Info.dwCursorPosition.Y;
344                  CharInfo.Char.UnicodeChar = &#x27; &#x27;;
345                  CharInfo.Attributes = Info.wAttributes;
346                  ScrollConsoleScreenBuffer(hConOut, &amp;Rect, NULL, Pos, &amp;CharInfo);
347                  return;
348              case &#x27;P&#x27;:                 
349                  if (es_argc == 0) es_argv[es_argc++] = 1; 
350                  if (es_argc != 1) return;
351                  if (Info.dwCursorPosition.X + es_argv[0] &gt; Info.dwSize.X - 1)
352                      es_argv[0] = Info.dwSize.X - Info.dwCursorPosition.X;
353                  Rect.Left = Info.dwCursorPosition.X + es_argv[0];
354                  Rect.Top = Info.dwCursorPosition.Y;
355                  Rect.Right = Info.dwSize.X - 1;
356                  Rect.Bottom = Info.dwCursorPosition.Y;
357                  CharInfo.Char.UnicodeChar = &#x27; &#x27;;
358                  CharInfo.Attributes = Info.wAttributes;
359                  ScrollConsoleScreenBuffer(hConOut, &amp;Rect, NULL, Info.dwCursorPosition,
360                      &amp;CharInfo);
361                  return;
362              case &#x27;@&#x27;:                 
363                  if (es_argc == 0) es_argv[es_argc++] = 1; 
364                  if (es_argc != 1) return;
365                  if (Info.dwCursorPosition.X + es_argv[0] &gt; Info.dwSize.X - 1)
366                      es_argv[0] = Info.dwSize.X - Info.dwCursorPosition.X;
367                  Rect.Left = Info.dwCursorPosition.X;
368                  Rect.Top = Info.dwCursorPosition.Y;
369                  Rect.Right = Info.dwSize.X - 1 - es_argv[0];
370                  Rect.Bottom = Info.dwCursorPosition.Y;
371                  Pos.X = Info.dwCursorPosition.X + es_argv[0];
372                  Pos.Y = Info.dwCursorPosition.Y;
373                  CharInfo.Char.UnicodeChar = &#x27; &#x27;;
374                  CharInfo.Attributes = Info.wAttributes;
375                  ScrollConsoleScreenBuffer(hConOut, &amp;Rect, NULL, Pos, &amp;CharInfo);
376                  return;
377              case &#x27;k&#x27;:                 
378              case &#x27;A&#x27;:                 
379                  if (es_argc == 0) es_argv[es_argc++] = 1; 
380                  if (es_argc != 1) return;
381                  Pos.Y = Info.dwCursorPosition.Y - es_argv[0];
382                  if (Pos.Y &lt; 0) Pos.Y = 0;
383                  Pos.X = Info.dwCursorPosition.X;
384                  SetConsoleCursorPosition(hConOut, Pos);
385                  return;
386              case &#x27;e&#x27;:                 
387              case &#x27;B&#x27;:                 
388                  if (es_argc == 0) es_argv[es_argc++] = 1; 
389                  if (es_argc != 1) return;
390                  Pos.Y = Info.dwCursorPosition.Y + es_argv[0];
391                  if (Pos.Y &gt;= Info.dwSize.Y) Pos.Y = Info.dwSize.Y - 1;
392                  Pos.X = Info.dwCursorPosition.X;
393                  SetConsoleCursorPosition(hConOut, Pos);
394                  return;
395              case &#x27;a&#x27;:                 
396              case &#x27;C&#x27;:                 
397                  if (es_argc == 0) es_argv[es_argc++] = 1; 
398                  if (es_argc != 1) return;
399                  Pos.X = Info.dwCursorPosition.X + es_argv[0];
400                  if (Pos.X &gt;= Info.dwSize.X) Pos.X = Info.dwSize.X - 1;
401                  Pos.Y = Info.dwCursorPosition.Y;
402                  SetConsoleCursorPosition(hConOut, Pos);
403                  return;
404              case &#x27;j&#x27;:                 
405              case &#x27;D&#x27;:                 
406                  if (es_argc == 0) es_argv[es_argc++] = 1; 
407                  if (es_argc != 1) return;
408                  Pos.X = Info.dwCursorPosition.X - es_argv[0];
409                  if (Pos.X &lt; 0) Pos.X = 0;
410                  Pos.Y = Info.dwCursorPosition.Y;
411                  SetConsoleCursorPosition(hConOut, Pos);
412                  return;
413              case &#x27;E&#x27;:                 
414                  if (es_argc == 0) es_argv[es_argc++] = 1; 
415                  if (es_argc != 1) return;
416                  Pos.Y = Info.dwCursorPosition.Y + es_argv[0];
417                  if (Pos.Y &gt;= Info.dwSize.Y) Pos.Y = Info.dwSize.Y - 1;
418                  Pos.X = 0;
419                  SetConsoleCursorPosition(hConOut, Pos);
420                  return;
421              case &#x27;F&#x27;:                 
422                  if (es_argc == 0) es_argv[es_argc++] = 1; 
423                  if (es_argc != 1) return;
424                  Pos.Y = Info.dwCursorPosition.Y - es_argv[0];
425                  if (Pos.Y &lt; 0) Pos.Y = 0;
426                  Pos.X = 0;
427                  SetConsoleCursorPosition(hConOut, Pos);
428                  return;
429              case &#x27;`&#x27;:                 
430              case &#x27;G&#x27;:                 
431                  if (es_argc == 0) es_argv[es_argc++] = 1; 
432                  if (es_argc != 1) return;
433                  Pos.X = es_argv[0] - 1;
434                  if (Pos.X &gt;= Info.dwSize.X) Pos.X = Info.dwSize.X - 1;
435                  if (Pos.X &lt; 0) Pos.X = 0;
436                  Pos.Y = Info.dwCursorPosition.Y;
437                  SetConsoleCursorPosition(hConOut, Pos);
438                  return;
439              case &#x27;d&#x27;:                 
440                  if (es_argc == 0) es_argv[es_argc++] = 1; 
441                  if (es_argc != 1) return;
442                  Pos.Y = es_argv[0] - 1;
443                  if (Pos.Y &lt; 0) Pos.Y = 0;
444                  if (Pos.Y &gt;= Info.dwSize.Y) Pos.Y = Info.dwSize.Y - 1;
445                  SetConsoleCursorPosition(hConOut, Pos);
446                  return;
447              case &#x27;f&#x27;:                 
448              case &#x27;H&#x27;:                 
449                  if (es_argc == 0)
450                      es_argv[es_argc++] = 1; 
451                  if (es_argc == 1)
452                      es_argv[es_argc++] = 1; 
453                  if (es_argc &gt; 2) return;
454                  Pos.X = es_argv[1] - 1;
455                  if (Pos.X &lt; 0) Pos.X = 0;
456                  if (Pos.X &gt;= Info.dwSize.X) Pos.X = Info.dwSize.X - 1;
457                  Pos.Y = es_argv[0] - 1;
458                  if (Pos.Y &lt; 0) Pos.Y = 0;
459                  if (Pos.Y &gt;= Info.dwSize.Y) Pos.Y = Info.dwSize.Y - 1;
460                  SetConsoleCursorPosition(hConOut, Pos);
461                  return;
462              case &#x27;s&#x27;:                 
463                  if (es_argc != 0) return;
464                  SavePos = Info.dwCursorPosition;
465                  return;
466              case &#x27;u&#x27;:                 
467                  if (es_argc != 0) return;
468                  SetConsoleCursorPosition(hConOut, SavePos);
469                  return;
470              case &#x27;n&#x27;:                 
471                  if (es_argc != 1) return; 
472                  switch (es_argv[0]) {
473                      case 5:		
474                          SendSequence(L&quot;\33[0n&quot;); 
475                          return;
476                      case 6:		
477                      {
478                                      TCHAR buf[32];
479                                      wsprintf(buf, L&quot;\33[%d;%dR&quot;, Info.dwCursorPosition.Y + 1,
480                                          Info.dwCursorPosition.X + 1);
481                                      SendSequence(buf);
482                      }
483                          return;
484                      default:
485                          return;
486                  }
487              case &#x27;t&#x27;:                 
488                  if (es_argc != 1) return;
489                  if (es_argv[0] == 21)	
490                  {
491                      TCHAR buf[MAX_PATH * 2];
492                      DWORD len = GetConsoleTitle(buf + 3, lenof(buf) - 3 - 2);
493                      buf[0] = ESC;
494                      buf[1] = &#x27;]&#x27;;
495                      buf[2] = &#x27;l&#x27;;
496                      buf[3 + len] = ESC;
497                      buf[3 + len + 1] = &#x27;\\&#x27;;
498                      buf[3 + len + 2] = &#x27;\0&#x27;;
499                      SendSequence(buf);
500                  }
501                  return;
502              default:
503                  return;
504          }
505      } else 
506      {
507          if (prefix2 != 0)
508              return;
509          if (es_argc == 1 &amp;&amp; es_argv[0] == 0) 
510          {
511              SetConsoleTitle(Pt_arg);
512          }
513      }
514  }
515  BOOL ParseAndPrintANSIString(HANDLE hDev, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten) {
516      DWORD   i;
517      LPCSTR s;
518      if (hDev != hConOut)	
519      {
520          hConOut = hDev;
521          state = 1;
522          shifted = FALSE;
523      }
524      for (i = nNumberOfBytesToWrite, s = (LPCSTR)lpBuffer; i &gt; 0; i--, s++) {
525          if (state == 1) {
526              if (*s == ESC) state = 2;
527              else if (*s == SO) shifted = TRUE;
528              else if (*s == SI) shifted = FALSE;
529              else PushBuffer(*s);
530          } else if (state == 2) {
531              if (*s == ESC);	
532              else if ((*s == &#x27;[&#x27;) || (*s == &#x27;]&#x27;)) {
533                  FlushBuffer();
534                  prefix = *s;
535                  prefix2 = 0;
536                  state = 3;
537                  Pt_len = 0;
538                  *Pt_arg = &#x27;\0&#x27;;
539              } else if (*s == &#x27;)&#x27; || *s == &#x27;(&#x27;) state = 6;
540              else state = 1;
541          } else if (state == 3) {
542              if (is_digit(*s)) {
543                  es_argc = 0;
544                  es_argv[0] = *s - &#x27;0&#x27;;
545                  state = 4;
546              } else if (*s == &#x27;;&#x27;) {
547                  es_argc = 1;
548                  es_argv[0] = 0;
549                  es_argv[1] = 0;
550                  state = 4;
551              } else if (*s == &#x27;?&#x27; || *s == &#x27;&gt;&#x27;) {
552                  prefix2 = *s;
553              } else {
554                  es_argc = 0;
555                  suffix = *s;
556                  InterpretEscSeq();
557                  state = 1;
558              }
559          } else if (state == 4) {
560              if (is_digit(*s)) {
561                  es_argv[es_argc] = 10 * es_argv[es_argc] + (*s - &#x27;0&#x27;);
562              } else if (*s == &#x27;;&#x27;) {
563                  if (es_argc &lt; MAX_ARG - 1) es_argc++;
564                  es_argv[es_argc] = 0;
565                  if (prefix == &#x27;]&#x27;)
566                      state = 5;
567              } else {
568                  es_argc++;
569                  suffix = *s;
570                  InterpretEscSeq();
571                  state = 1;
572              }
573          } else if (state == 5) {
574              if (*s == BEL) {
575                  Pt_arg[Pt_len] = &#x27;\0&#x27;;
576                  InterpretEscSeq();
577                  state = 1;
578              } else if (*s == &#x27;\\&#x27; &amp;&amp; Pt_len &gt; 0 &amp;&amp; Pt_arg[Pt_len - 1] == ESC) {
579                  Pt_arg[--Pt_len] = &#x27;\0&#x27;;
580                  InterpretEscSeq();
581                  state = 1;
582              } else if (Pt_len &lt; lenof(Pt_arg) - 1)
583                  Pt_arg[Pt_len++] = *s;
584          } else if (state == 6) {
585              state = 1;
586          }
587      }
588      FlushBuffer();
589      if (lpNumberOfBytesWritten != NULL)
590          *lpNumberOfBytesWritten = nNumberOfBytesToWrite - i;
591      return (i == 0);
592  }
593  void ANSI_printf(char *format, ...) {
594      va_list args;
595      int retVal;
596  #define cBufLen 2000
597      char buffer[cBufLen];
598      memset(buffer, 0, cBufLen);
599      va_start(args, format);
600      retVal = vsprintf_s(buffer, cBufLen, format, args);
601      va_end(args);
602      if (retVal &gt; 0) {
603          DWORD bytesWritten = 0;
604          ParseAndPrintANSIString(GetStdHandle(STD_OUTPUT_HANDLE), buffer, (DWORD)strlen(buffer), &amp;bytesWritten);
605      }
606  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-Win32_ANSI.c</h3>
            <pre><code>1  #include &lt;windows.h&gt;
2  #include &lt;stdio.h&gt;
3  #include &lt;stdlib.h&gt;
4  #include &quot;Win32_ANSI.h&quot;
5  #define lenof(array) (sizeof(array)/sizeof(*(array)))
6  typedef struct {
7      BYTE foreground;	
8      BYTE background;	
9      BYTE bold;	
10      BYTE underline;	
11      BYTE rvideo;	
12      BYTE concealed;	
13      BYTE reverse; 
14  } GRM, *PGRM;	
15  #define is_digit(c) (&#x27;0&#x27; &lt;= (c) &amp;&amp; (c) &lt;= &#x27;9&#x27;)
16  HANDLE	  hConOut;		
17  #define ESC	&#x27;\x1B&#x27;          
18  #define BEL	&#x27;\x07&#x27;
19  #define SO	&#x27;\x0E&#x27;          
20  #define SI	&#x27;\x0F&#x27;          
21  #define MAX_ARG 16		
22  int   state;			
23  TCHAR prefix;			
24  TCHAR prefix2;			
25  TCHAR suffix;			
26  int   es_argc;			
27  int   es_argv[MAX_ARG]; 	
28  TCHAR Pt_arg[MAX_PATH * 2];	
29  int   Pt_len;
30  BOOL  shifted;
31  const WCHAR G1[] =
32  {
33      &#x27; &#x27;,          
34      L&#x27;\x2666&#x27;,    
35      L&#x27;\x2592&#x27;,    
36      L&#x27;\x2409&#x27;,    
37      L&#x27;\x240c&#x27;,    
38      L&#x27;\x240d&#x27;,    
39      L&#x27;\x240a&#x27;,    
40      L&#x27;\x00b0&#x27;,    
41      L&#x27;\x00b1&#x27;,    
42      L&#x27;\x2424&#x27;,    
43      L&#x27;\x240b&#x27;,    
44      L&#x27;\x2518&#x27;,    
45      L&#x27;\x2510&#x27;,    
46      L&#x27;\x250c&#x27;,    
47      L&#x27;\x2514&#x27;,    
48      L&#x27;\x253c&#x27;,    
49      L&#x27;\x00af&#x27;,    
50      L&#x27;\x25ac&#x27;,    
51      L&#x27;\x2500&#x27;,    
52      L&#x27;_&#x27;,         
53      L&#x27;_&#x27;,         
54      L&#x27;\x251c&#x27;,    
55      L&#x27;\x2524&#x27;,    
56      L&#x27;\x2534&#x27;,    
57      L&#x27;\x252c&#x27;,    
58      L&#x27;\x2502&#x27;,    
59      L&#x27;\x2264&#x27;,    
60      L&#x27;\x2265&#x27;,    
61      L&#x27;\x03c0&#x27;,    
62      L&#x27;\x2260&#x27;,    
63      L&#x27;\x00a3&#x27;,    
64      L&#x27;\x00b7&#x27;,    
65  };
66  #define FIRST_G1 &#x27;_&#x27;
67  #define LAST_G1  &#x27;~&#x27;
68  #define FOREGROUND_BLACK 0
69  #define FOREGROUND_WHITE FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE
70  #define BACKGROUND_BLACK 0
71  #define BACKGROUND_WHITE BACKGROUND_RED|BACKGROUND_GREEN|BACKGROUND_BLUE
72  const BYTE foregroundcolor[8] =
73  {
74      FOREGROUND_BLACK,			
75      FOREGROUND_RED,			
76      FOREGROUND_GREEN,			
77      FOREGROUND_RED | FOREGROUND_GREEN,	
78      FOREGROUND_BLUE,			
79      FOREGROUND_BLUE | FOREGROUND_RED,	
80      FOREGROUND_BLUE | FOREGROUND_GREEN,	
81      FOREGROUND_WHITE			
82  };
83  const BYTE backgroundcolor[8] =
84  {
85      BACKGROUND_BLACK,			
86      BACKGROUND_RED,			
87      BACKGROUND_GREEN,			
88      BACKGROUND_RED | BACKGROUND_GREEN,	
89      BACKGROUND_BLUE,			
90      BACKGROUND_BLUE | BACKGROUND_RED,	
91      BACKGROUND_BLUE | BACKGROUND_GREEN,	
92      BACKGROUND_WHITE,			
93  };
94  const BYTE attr2ansi[8] =		
95  {
96      0,					
97      4,					
98      2,					
99      6,					
100      1,					
101      5,					
102      3,					
103      7					
104  };
105  GRM grm;
106  COORD SavePos;
107  #define BUFFER_SIZE 2048
108  int   nCharInBuffer;
109  WCHAR ChBuffer[BUFFER_SIZE];
110  void FlushBuffer(void) {
111      DWORD nWritten;
112      if (nCharInBuffer &lt;= 0) return;
113      WriteConsole(hConOut, ChBuffer, nCharInBuffer, &amp;nWritten, NULL);
114      nCharInBuffer = 0;
115  }
116  void PushBuffer(WCHAR c) {
117      if (shifted &amp;&amp; c &gt;= FIRST_G1 &amp;&amp; c &lt;= LAST_G1)
118          c = G1[c - FIRST_G1];
119      ChBuffer[nCharInBuffer] = c;
120      if (++nCharInBuffer == BUFFER_SIZE)
121          FlushBuffer();
122  }
123  void SendSequence(LPTSTR seq) {
124      DWORD out;
125      INPUT_RECORD in;
126      HANDLE hStdIn = GetStdHandle(STD_INPUT_HANDLE);
127      in.EventType = KEY_EVENT;
128      in.Event.KeyEvent.bKeyDown = TRUE;
129      in.Event.KeyEvent.wRepeatCount = 1;
130      in.Event.KeyEvent.wVirtualKeyCode = 0;
131      in.Event.KeyEvent.wVirtualScanCode = 0;
132      in.Event.KeyEvent.dwControlKeyState = 0;
133      for (; *seq; ++seq) {
134          in.Event.KeyEvent.uChar.UnicodeChar = *seq;
135          WriteConsoleInput(hStdIn, &amp;in, 1, &amp;out);
136      }
137  }
138  void InterpretEscSeq(void) {
139      int  i;
140      WORD attribut;
141      CONSOLE_SCREEN_BUFFER_INFO Info;
142      CONSOLE_CURSOR_INFO CursInfo;
143      DWORD len, NumberOfCharsWritten;
144      COORD Pos;
145      SMALL_RECT Rect;
146      CHAR_INFO  CharInfo;
147      if (prefix == &#x27;[&#x27;) {
148          if (prefix2 == &#x27;?&#x27; &amp;&amp; (suffix == &#x27;h&#x27; || suffix == &#x27;l&#x27;)) {
149              if (es_argc == 1 &amp;&amp; es_argv[0] == 25) {
150                  GetConsoleCursorInfo(hConOut, &amp;CursInfo);
151                  CursInfo.bVisible = (suffix == &#x27;h&#x27;);
152                  SetConsoleCursorInfo(hConOut, &amp;CursInfo);
153                  return;
154              }
155          }
156          if (prefix2 != 0)
157              return;
158          GetConsoleScreenBufferInfo(hConOut, &amp;Info);
159          switch (suffix) {
160              case &#x27;m&#x27;:
161                  if (es_argc == 0) es_argv[es_argc++] = 0;
162                  for (i = 0; i &lt; es_argc; i++) {
163                      if (30 &lt;= es_argv[i] &amp;&amp; es_argv[i] &lt;= 37)
164                          grm.foreground = es_argv[i] - 30;
165                      else if (40 &lt;= es_argv[i] &amp;&amp; es_argv[i] &lt;= 47)
166                          grm.background = es_argv[i] - 40;
167                      else switch (es_argv[i]) {
168                          case 0:
169                          case 39:
170                          case 49:
171                          {
172                                     TCHAR def[4];
173                                     int   a;
174                                     *def = &#x27;7&#x27;; def[1] = &#x27;\0&#x27;;
175                                     GetEnvironmentVariable(L&quot;ANSICON_DEF&quot;, def, lenof(def));
176                                     a = wcstol(def, NULL, 16);
177                                     grm.reverse = FALSE;
178                                     if (a &lt; 0) {
179                                         grm.reverse = TRUE;
180                                         a = -a;
181                                     }
182                                     if (es_argv[i] != 49)
183                                         grm.foreground = attr2ansi[a &amp; 7];
184                                     if (es_argv[i] != 39)
185                                         grm.background = attr2ansi[(a &gt;&gt; 4) &amp; 7];
186                                     if (es_argv[i] == 0) {
187                                         if (es_argc == 1) {
188                                             grm.bold = a &amp; FOREGROUND_INTENSITY;
189                                             grm.underline = a &amp; BACKGROUND_INTENSITY;
190                                         } else {
191                                             grm.bold = 0;
192                                             grm.underline = 0;
193                                         }
194                                         grm.rvideo = 0;
195                                         grm.concealed = 0;
196                                     }
197                          }
198                              break;
199                          case  1: grm.bold = FOREGROUND_INTENSITY; break;
200                          case  5: 
201                          case  4: grm.underline = BACKGROUND_INTENSITY; break;
202                          case  7: grm.rvideo = 1; break;
203                          case  8: grm.concealed = 1; break;
204                          case 21: 
205                          case 22: grm.bold = 0; break;
206                          case 25:
207                          case 24: grm.underline = 0; break;
208                          case 27: grm.rvideo = 0; break;
209                          case 28: grm.concealed = 0; break;
210                      }
211                  }
212                  if (grm.concealed) {
213                      if (grm.rvideo) {
214                          attribut = foregroundcolor[grm.foreground]
215                              | backgroundcolor[grm.foreground];
216                          if (grm.bold)
217                              attribut |= FOREGROUND_INTENSITY | BACKGROUND_INTENSITY;
218                      } else {
<span onclick='openModal()' class='match'>219                          attribut = foregroundcolor[grm.background]
220                              | backgroundcolor[grm.background];
221                          if (grm.underline)
222                              attribut |= FOREGROUND_INTENSITY | BACKGROUND_INTENSITY;
</span>223                      }
224                  } else if (grm.rvideo) {
225                      attribut = foregroundcolor[grm.background]
226                          | backgroundcolor[grm.foreground];
227                      if (grm.bold)
228                          attribut |= BACKGROUND_INTENSITY;
229                      if (grm.underline)
230                          attribut |= FOREGROUND_INTENSITY;
231                  } else
232                      attribut = foregroundcolor[grm.foreground] | grm.bold
233                      | backgroundcolor[grm.background] | grm.underline;
234                  if (grm.reverse)
235                      attribut = ((attribut &gt;&gt; 4) &amp; 15) | ((attribut &amp; 15) &lt;&lt; 4);
236                  SetConsoleTextAttribute(hConOut, attribut);
237                  return;
238              case &#x27;J&#x27;:
239                  if (es_argc == 0) es_argv[es_argc++] = 0; 
240                  if (es_argc != 1) return;
241                  switch (es_argv[0]) {
242                      case 0:		
243                          len = (Info.dwSize.Y - Info.dwCursorPosition.Y - 1) * Info.dwSize.X
244                              + Info.dwSize.X - Info.dwCursorPosition.X - 1;
245                          FillConsoleOutputCharacter(hConOut, &#x27; &#x27;, len,
246                              Info.dwCursorPosition,
247                              &amp;NumberOfCharsWritten);
248                          FillConsoleOutputAttribute(hConOut, Info.wAttributes, len,
249                              Info.dwCursorPosition,
250                              &amp;NumberOfCharsWritten);
251                          return;
252                      case 1:		
253                          Pos.X = 0;
254                          Pos.Y = 0;
255                          len = Info.dwCursorPosition.Y * Info.dwSize.X
256                              + Info.dwCursorPosition.X + 1;
257                          FillConsoleOutputCharacter(hConOut, &#x27; &#x27;, len, Pos,
258                              &amp;NumberOfCharsWritten);
259                          FillConsoleOutputAttribute(hConOut, Info.wAttributes, len, Pos,
260                              &amp;NumberOfCharsWritten);
261                          return;
262                      case 2:		
263                          Pos.X = 0;
264                          Pos.Y = 0;
265                          len = Info.dwSize.X * Info.dwSize.Y;
266                          FillConsoleOutputCharacter(hConOut, &#x27; &#x27;, len, Pos,
267                              &amp;NumberOfCharsWritten);
268                          FillConsoleOutputAttribute(hConOut, Info.wAttributes, len, Pos,
269                              &amp;NumberOfCharsWritten);
270                          SetConsoleCursorPosition(hConOut, Pos);
271                          return;
272                      default:
273                          return;
274                  }
275              case &#x27;K&#x27;:
276                  if (es_argc == 0) es_argv[es_argc++] = 0; 
277                  if (es_argc != 1) return;
278                  switch (es_argv[0]) {
279                      case 0:		
280                          len = Info.dwSize.X - Info.dwCursorPosition.X + 1;
281                          FillConsoleOutputCharacter(hConOut, &#x27; &#x27;, len,
282                              Info.dwCursorPosition,
283                              &amp;NumberOfCharsWritten);
284                          FillConsoleOutputAttribute(hConOut, Info.wAttributes, len,
285                              Info.dwCursorPosition,
286                              &amp;NumberOfCharsWritten);
287                          return;
288                      case 1:		
289                          Pos.X = 0;
290                          Pos.Y = Info.dwCursorPosition.Y;
291                          FillConsoleOutputCharacter(hConOut, &#x27; &#x27;,
292                              Info.dwCursorPosition.X + 1, Pos,
293                              &amp;NumberOfCharsWritten);
294                          FillConsoleOutputAttribute(hConOut, Info.wAttributes,
295                              Info.dwCursorPosition.X + 1, Pos,
296                              &amp;NumberOfCharsWritten);
297                          return;
298                      case 2:		
299                          Pos.X = 0;
300                          Pos.Y = Info.dwCursorPosition.Y;
301                          FillConsoleOutputCharacter(hConOut, &#x27; &#x27;, Info.dwSize.X, Pos,
302                              &amp;NumberOfCharsWritten);
303                          FillConsoleOutputAttribute(hConOut, Info.wAttributes,
304                              Info.dwSize.X, Pos,
305                              &amp;NumberOfCharsWritten);
306                          return;
307                      default:
308                          return;
309                  }
310              case &#x27;X&#x27;:                 
311                  if (es_argc == 0) es_argv[es_argc++] = 1; 
312                  if (es_argc != 1) return;
313                  FillConsoleOutputCharacter(hConOut, &#x27; &#x27;, es_argv[0],
314                      Info.dwCursorPosition,
315                      &amp;NumberOfCharsWritten);
316                  FillConsoleOutputAttribute(hConOut, Info.wAttributes, es_argv[0],
317                      Info.dwCursorPosition,
318                      &amp;NumberOfCharsWritten);
319                  return;
320              case &#x27;L&#x27;:                 
321                  if (es_argc == 0) es_argv[es_argc++] = 1; 
322                  if (es_argc != 1) return;
323                  Rect.Left = 0;
324                  Rect.Top = Info.dwCursorPosition.Y;
325                  Rect.Right = Info.dwSize.X - 1;
326                  Rect.Bottom = Info.dwSize.Y - 1;
327                  Pos.X = 0;
328                  Pos.Y = Info.dwCursorPosition.Y + es_argv[0];
329                  CharInfo.Char.UnicodeChar = &#x27; &#x27;;
330                  CharInfo.Attributes = Info.wAttributes;
331                  ScrollConsoleScreenBuffer(hConOut, &amp;Rect, NULL, Pos, &amp;CharInfo);
332                  return;
333              case &#x27;M&#x27;:                 
334                  if (es_argc == 0) es_argv[es_argc++] = 1; 
335                  if (es_argc != 1) return;
336                  if (es_argv[0] &gt; Info.dwSize.Y - Info.dwCursorPosition.Y)
337                      es_argv[0] = Info.dwSize.Y - Info.dwCursorPosition.Y;
338                  Rect.Left = 0;
339                  Rect.Top = Info.dwCursorPosition.Y + es_argv[0];
340                  Rect.Right = Info.dwSize.X - 1;
341                  Rect.Bottom = Info.dwSize.Y - 1;
342                  Pos.X = 0;
343                  Pos.Y = Info.dwCursorPosition.Y;
344                  CharInfo.Char.UnicodeChar = &#x27; &#x27;;
345                  CharInfo.Attributes = Info.wAttributes;
346                  ScrollConsoleScreenBuffer(hConOut, &amp;Rect, NULL, Pos, &amp;CharInfo);
347                  return;
348              case &#x27;P&#x27;:                 
349                  if (es_argc == 0) es_argv[es_argc++] = 1; 
350                  if (es_argc != 1) return;
351                  if (Info.dwCursorPosition.X + es_argv[0] &gt; Info.dwSize.X - 1)
352                      es_argv[0] = Info.dwSize.X - Info.dwCursorPosition.X;
353                  Rect.Left = Info.dwCursorPosition.X + es_argv[0];
354                  Rect.Top = Info.dwCursorPosition.Y;
355                  Rect.Right = Info.dwSize.X - 1;
356                  Rect.Bottom = Info.dwCursorPosition.Y;
357                  CharInfo.Char.UnicodeChar = &#x27; &#x27;;
358                  CharInfo.Attributes = Info.wAttributes;
359                  ScrollConsoleScreenBuffer(hConOut, &amp;Rect, NULL, Info.dwCursorPosition,
360                      &amp;CharInfo);
361                  return;
362              case &#x27;@&#x27;:                 
363                  if (es_argc == 0) es_argv[es_argc++] = 1; 
364                  if (es_argc != 1) return;
365                  if (Info.dwCursorPosition.X + es_argv[0] &gt; Info.dwSize.X - 1)
366                      es_argv[0] = Info.dwSize.X - Info.dwCursorPosition.X;
367                  Rect.Left = Info.dwCursorPosition.X;
368                  Rect.Top = Info.dwCursorPosition.Y;
369                  Rect.Right = Info.dwSize.X - 1 - es_argv[0];
370                  Rect.Bottom = Info.dwCursorPosition.Y;
371                  Pos.X = Info.dwCursorPosition.X + es_argv[0];
372                  Pos.Y = Info.dwCursorPosition.Y;
373                  CharInfo.Char.UnicodeChar = &#x27; &#x27;;
374                  CharInfo.Attributes = Info.wAttributes;
375                  ScrollConsoleScreenBuffer(hConOut, &amp;Rect, NULL, Pos, &amp;CharInfo);
376                  return;
377              case &#x27;k&#x27;:                 
378              case &#x27;A&#x27;:                 
379                  if (es_argc == 0) es_argv[es_argc++] = 1; 
380                  if (es_argc != 1) return;
381                  Pos.Y = Info.dwCursorPosition.Y - es_argv[0];
382                  if (Pos.Y &lt; 0) Pos.Y = 0;
383                  Pos.X = Info.dwCursorPosition.X;
384                  SetConsoleCursorPosition(hConOut, Pos);
385                  return;
386              case &#x27;e&#x27;:                 
387              case &#x27;B&#x27;:                 
388                  if (es_argc == 0) es_argv[es_argc++] = 1; 
389                  if (es_argc != 1) return;
390                  Pos.Y = Info.dwCursorPosition.Y + es_argv[0];
391                  if (Pos.Y &gt;= Info.dwSize.Y) Pos.Y = Info.dwSize.Y - 1;
392                  Pos.X = Info.dwCursorPosition.X;
393                  SetConsoleCursorPosition(hConOut, Pos);
394                  return;
395              case &#x27;a&#x27;:                 
396              case &#x27;C&#x27;:                 
397                  if (es_argc == 0) es_argv[es_argc++] = 1; 
398                  if (es_argc != 1) return;
399                  Pos.X = Info.dwCursorPosition.X + es_argv[0];
400                  if (Pos.X &gt;= Info.dwSize.X) Pos.X = Info.dwSize.X - 1;
401                  Pos.Y = Info.dwCursorPosition.Y;
402                  SetConsoleCursorPosition(hConOut, Pos);
403                  return;
404              case &#x27;j&#x27;:                 
405              case &#x27;D&#x27;:                 
406                  if (es_argc == 0) es_argv[es_argc++] = 1; 
407                  if (es_argc != 1) return;
408                  Pos.X = Info.dwCursorPosition.X - es_argv[0];
409                  if (Pos.X &lt; 0) Pos.X = 0;
410                  Pos.Y = Info.dwCursorPosition.Y;
411                  SetConsoleCursorPosition(hConOut, Pos);
412                  return;
413              case &#x27;E&#x27;:                 
414                  if (es_argc == 0) es_argv[es_argc++] = 1; 
415                  if (es_argc != 1) return;
416                  Pos.Y = Info.dwCursorPosition.Y + es_argv[0];
417                  if (Pos.Y &gt;= Info.dwSize.Y) Pos.Y = Info.dwSize.Y - 1;
418                  Pos.X = 0;
419                  SetConsoleCursorPosition(hConOut, Pos);
420                  return;
421              case &#x27;F&#x27;:                 
422                  if (es_argc == 0) es_argv[es_argc++] = 1; 
423                  if (es_argc != 1) return;
424                  Pos.Y = Info.dwCursorPosition.Y - es_argv[0];
425                  if (Pos.Y &lt; 0) Pos.Y = 0;
426                  Pos.X = 0;
427                  SetConsoleCursorPosition(hConOut, Pos);
428                  return;
429              case &#x27;`&#x27;:                 
430              case &#x27;G&#x27;:                 
431                  if (es_argc == 0) es_argv[es_argc++] = 1; 
432                  if (es_argc != 1) return;
433                  Pos.X = es_argv[0] - 1;
434                  if (Pos.X &gt;= Info.dwSize.X) Pos.X = Info.dwSize.X - 1;
435                  if (Pos.X &lt; 0) Pos.X = 0;
436                  Pos.Y = Info.dwCursorPosition.Y;
437                  SetConsoleCursorPosition(hConOut, Pos);
438                  return;
439              case &#x27;d&#x27;:                 
440                  if (es_argc == 0) es_argv[es_argc++] = 1; 
441                  if (es_argc != 1) return;
442                  Pos.Y = es_argv[0] - 1;
443                  if (Pos.Y &lt; 0) Pos.Y = 0;
444                  if (Pos.Y &gt;= Info.dwSize.Y) Pos.Y = Info.dwSize.Y - 1;
445                  SetConsoleCursorPosition(hConOut, Pos);
446                  return;
447              case &#x27;f&#x27;:                 
448              case &#x27;H&#x27;:                 
449                  if (es_argc == 0)
450                      es_argv[es_argc++] = 1; 
451                  if (es_argc == 1)
452                      es_argv[es_argc++] = 1; 
453                  if (es_argc &gt; 2) return;
454                  Pos.X = es_argv[1] - 1;
455                  if (Pos.X &lt; 0) Pos.X = 0;
456                  if (Pos.X &gt;= Info.dwSize.X) Pos.X = Info.dwSize.X - 1;
457                  Pos.Y = es_argv[0] - 1;
458                  if (Pos.Y &lt; 0) Pos.Y = 0;
459                  if (Pos.Y &gt;= Info.dwSize.Y) Pos.Y = Info.dwSize.Y - 1;
460                  SetConsoleCursorPosition(hConOut, Pos);
461                  return;
462              case &#x27;s&#x27;:                 
463                  if (es_argc != 0) return;
464                  SavePos = Info.dwCursorPosition;
465                  return;
466              case &#x27;u&#x27;:                 
467                  if (es_argc != 0) return;
468                  SetConsoleCursorPosition(hConOut, SavePos);
469                  return;
470              case &#x27;n&#x27;:                 
471                  if (es_argc != 1) return; 
472                  switch (es_argv[0]) {
473                      case 5:		
474                          SendSequence(L&quot;\33[0n&quot;); 
475                          return;
476                      case 6:		
477                      {
478                                      TCHAR buf[32];
479                                      wsprintf(buf, L&quot;\33[%d;%dR&quot;, Info.dwCursorPosition.Y + 1,
480                                          Info.dwCursorPosition.X + 1);
481                                      SendSequence(buf);
482                      }
483                          return;
484                      default:
485                          return;
486                  }
487              case &#x27;t&#x27;:                 
488                  if (es_argc != 1) return;
489                  if (es_argv[0] == 21)	
490                  {
491                      TCHAR buf[MAX_PATH * 2];
492                      DWORD len = GetConsoleTitle(buf + 3, lenof(buf) - 3 - 2);
493                      buf[0] = ESC;
494                      buf[1] = &#x27;]&#x27;;
495                      buf[2] = &#x27;l&#x27;;
496                      buf[3 + len] = ESC;
497                      buf[3 + len + 1] = &#x27;\\&#x27;;
498                      buf[3 + len + 2] = &#x27;\0&#x27;;
499                      SendSequence(buf);
500                  }
501                  return;
502              default:
503                  return;
504          }
505      } else 
506      {
507          if (prefix2 != 0)
508              return;
509          if (es_argc == 1 &amp;&amp; es_argv[0] == 0) 
510          {
511              SetConsoleTitle(Pt_arg);
512          }
513      }
514  }
515  BOOL ParseAndPrintANSIString(HANDLE hDev, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten) {
516      DWORD   i;
517      LPCSTR s;
518      if (hDev != hConOut)	
519      {
520          hConOut = hDev;
521          state = 1;
522          shifted = FALSE;
523      }
524      for (i = nNumberOfBytesToWrite, s = (LPCSTR)lpBuffer; i &gt; 0; i--, s++) {
525          if (state == 1) {
526              if (*s == ESC) state = 2;
527              else if (*s == SO) shifted = TRUE;
528              else if (*s == SI) shifted = FALSE;
529              else PushBuffer(*s);
530          } else if (state == 2) {
531              if (*s == ESC);	
532              else if ((*s == &#x27;[&#x27;) || (*s == &#x27;]&#x27;)) {
533                  FlushBuffer();
534                  prefix = *s;
535                  prefix2 = 0;
536                  state = 3;
537                  Pt_len = 0;
538                  *Pt_arg = &#x27;\0&#x27;;
539              } else if (*s == &#x27;)&#x27; || *s == &#x27;(&#x27;) state = 6;
540              else state = 1;
541          } else if (state == 3) {
542              if (is_digit(*s)) {
543                  es_argc = 0;
544                  es_argv[0] = *s - &#x27;0&#x27;;
545                  state = 4;
546              } else if (*s == &#x27;;&#x27;) {
547                  es_argc = 1;
548                  es_argv[0] = 0;
549                  es_argv[1] = 0;
550                  state = 4;
551              } else if (*s == &#x27;?&#x27; || *s == &#x27;&gt;&#x27;) {
552                  prefix2 = *s;
553              } else {
554                  es_argc = 0;
555                  suffix = *s;
556                  InterpretEscSeq();
557                  state = 1;
558              }
559          } else if (state == 4) {
560              if (is_digit(*s)) {
561                  es_argv[es_argc] = 10 * es_argv[es_argc] + (*s - &#x27;0&#x27;);
562              } else if (*s == &#x27;;&#x27;) {
563                  if (es_argc &lt; MAX_ARG - 1) es_argc++;
564                  es_argv[es_argc] = 0;
565                  if (prefix == &#x27;]&#x27;)
566                      state = 5;
567              } else {
568                  es_argc++;
569                  suffix = *s;
570                  InterpretEscSeq();
571                  state = 1;
572              }
573          } else if (state == 5) {
574              if (*s == BEL) {
575                  Pt_arg[Pt_len] = &#x27;\0&#x27;;
576                  InterpretEscSeq();
577                  state = 1;
578              } else if (*s == &#x27;\\&#x27; &amp;&amp; Pt_len &gt; 0 &amp;&amp; Pt_arg[Pt_len - 1] == ESC) {
579                  Pt_arg[--Pt_len] = &#x27;\0&#x27;;
580                  InterpretEscSeq();
581                  state = 1;
582              } else if (Pt_len &lt; lenof(Pt_arg) - 1)
583                  Pt_arg[Pt_len++] = *s;
584          } else if (state == 6) {
585              state = 1;
586          }
587      }
588      FlushBuffer();
589      if (lpNumberOfBytesWritten != NULL)
590          *lpNumberOfBytesWritten = nNumberOfBytesToWrite - i;
591      return (i == 0);
592  }
593  void ANSI_printf(char *format, ...) {
594      va_list args;
595      int retVal;
596  #define cBufLen 2000
597      char buffer[cBufLen];
598      memset(buffer, 0, cBufLen);
599      va_start(args, format);
600      retVal = vsprintf_s(buffer, cBufLen, format, args);
601      va_end(args);
602      if (retVal &gt; 0) {
603          DWORD bytesWritten = 0;
604          ParseAndPrintANSIString(GetStdHandle(STD_OUTPUT_HANDLE), buffer, (DWORD)strlen(buffer), &amp;bytesWritten);
605      }
606  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-Win32_ANSI.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-Win32_ANSI.c</div>
                </div>
                <div class="column column_space"><pre><code>214                          attribut = foregroundcolor[grm.foreground]
215                              | backgroundcolor[grm.foreground];
216                          if (grm.bold)
217                              attribut |= FOREGROUND_INTENSITY | BACKGROUND_INTENSITY;
</pre></code></div>
                <div class="column column_space"><pre><code>219                          attribut = foregroundcolor[grm.background]
220                              | backgroundcolor[grm.background];
221                          if (grm.underline)
222                              attribut |= FOREGROUND_INTENSITY | BACKGROUND_INTENSITY;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    