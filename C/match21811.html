<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for scRGB2XYZ.c &amp; conva.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for scRGB2XYZ.c &amp; conva.c
      </h3>
<h1 align="center">
        5.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>scRGB2XYZ.c (47.272728%)<th>conva.c (3.1746032%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(93-124)<td><a href="#" name="0">(1305-1359)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(81-92)<td><a href="#" name="1">(1276-1287)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>scRGB2XYZ.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;math.h&gt;
6 #include &lt;vips/vips.h&gt;
7 #include "pcolour.h"
8 typedef VipsColourTransform VipsscRGB2XYZ;
9 typedef VipsColourTransformClass VipsscRGB2XYZClass;
10 G_DEFINE_TYPE( VipsscRGB2XYZ, vips_scRGB2XYZ, VIPS_TYPE_COLOUR_TRANSFORM );
11 void
12 vips_scRGB2XYZ_line( VipsColour *colour, VipsPel *out, VipsPel **in, int width )
13 {
14 	float * restrict p = (float *) in[0];
15 	float * restrict q = (float *) out;
16 	int i;
17 	for( i = 0; i &lt; width; i++ ) {
18 		float R = p[0];
19 		float G = p[1];
20 		float B = p[2];
21 		float X, Y, Z;
22 		p += 3;
23 		vips_col_scRGB2XYZ( R, G, B, &amp;X, &amp;Y, &amp;Z );
24 		q[0] = X;
25 		q[1] = Y;
26 <a name="1"></a>		q[2] = Z;
27 		q += 3;
28 	}
29 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
30 static void
31 vips_scRGB2XYZ_class_init( VipsscRGB2XYZClass *class )
32 {
33 	VipsObjectClass *object_class = (VipsObjectClass *) class;
34 	VipsColourClass *colour_class = VIPS_COLOUR_CLASS( class );
35 	object_class-&gt;nickname = "scRGB2XYZ";
36 <a name="0"></a>	object_class-&gt;description = _( "transform scRGB to XYZ" );
37 	colour_class-&gt;process_line = vips_scRGB2XYZ_line;</b></font>
38 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
39 static void
40 vips_scRGB2XYZ_init( VipsscRGB2XYZ *scRGB2XYZ )
41 {
42 	VipsColour *colour = VIPS_COLOUR( scRGB2XYZ );
43 	colour-&gt;interpretation = VIPS_INTERPRETATION_XYZ;
44 }
45 int
46 vips_scRGB2XYZ( VipsImage *in, VipsImage **out, ... )
47 {
48 	va_list ap;
49 	int result;
50 	va_start( ap, out );
51 	result = vips_call_split( "scRGB2XYZ", ap, in, out );
52 	va_end( ap );
53 	return( result );
54 }</b></font>
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>conva.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;stdlib.h&gt;
7 #include &lt;limits.h&gt;
8 #include &lt;math.h&gt;
9 #include &lt;vips/vips.h&gt;
10 #include &lt;vips/vector.h&gt;
11 #include &lt;vips/debug.h&gt;
12 #include &lt;vips/internal.h&gt;
13 #include "pconvolution.h"
14 #define MAX_LINES (1000)
15 #define MAX_EDGES (1000)
16 typedef struct _HLine {
17 	int start;
18 	int end;
19 	int weight;
20 } HLine;
21 typedef struct _Edge {
22 	int a;
23 	int b;
24 	int d;
25 } Edge;
26 typedef struct _VElement {
27 	int band;
28 	int row;
29 	int factor;
30 } VElement;
31 typedef struct _VLine {
32 	int band;
33 	int factor;
34 	int start;
35 	int end;
36 } VLine;
37 typedef struct {
38 	VipsConvolution parent_instance;
39 	VipsImage *iM;
40 	int layers;
41 	int cluster;
42 	int divisor;
43 	int rounding;
44 	int offset;
45 	int n_hline;
46 	HLine hline[MAX_LINES];
47 	int max_line;
48 	Edge edge[MAX_EDGES];
49 	int n_velement;
50 	VElement velement[MAX_LINES];
51 	int n_vline;
52 	VLine vline[MAX_LINES];
53 } VipsConva;
54 typedef VipsConvolutionClass VipsConvaClass;
55 G_DEFINE_TYPE( VipsConva, vips_conva, VIPS_TYPE_CONVOLUTION );
56 static int
57 gcd( int a, int b )
58 {
59 	if( b == 0 )
60 		return( abs( a ) );
61 	else
62 		return( gcd( b, a % b ) );
63 }
64 static void
65 vips_conva_hline_start( VipsConva *conva, int x )
66 {
67 	conva-&gt;hline[conva-&gt;n_hline].start = x;
68 	conva-&gt;hline[conva-&gt;n_hline].weight = 1;
69 }
70 static int
71 vips_conva_hline_end( VipsConva *conva, int x, int y, int factor )
72 {
73 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( conva );
74 	conva-&gt;hline[conva-&gt;n_hline].end = x;
75 	conva-&gt;velement[conva-&gt;n_velement].row = y;
76 	conva-&gt;velement[conva-&gt;n_velement].band = conva-&gt;n_hline;
77 	conva-&gt;velement[conva-&gt;n_velement].factor = factor;
78 	if( conva-&gt;n_hline &gt;= MAX_LINES - 1 ) {
79 		vips_error( class-&gt;nickname, "%s", _( "mask too complex" ) );
80 		return( -1 );
81 	}
82 	conva-&gt;n_hline += 1;
83 	if( conva-&gt;n_velement &gt;= MAX_LINES - 1 ) {
84 		vips_error( class-&gt;nickname, "%s", _( "mask too complex" ) );
85 		return( -1 );
86 	}
87 	conva-&gt;n_velement += 1;
88 	return( 0 );
89 }
90 #ifdef DEBUG
91 static void
92 vips_conva_hprint( VipsConva *conva )
93 {
94 	int x, y;
95 	printf( "hlines:\n" );
96 	printf( "   n   b   r  f   w\n" );
97 	for( y = 0; y &lt; conva-&gt;n_velement; y++ ) {
98 		int b = conva-&gt;velement[y].band;
99 		printf( "%4d %3d %3d %2d %3d ", 
100 			y, b, 
101 			conva-&gt;velement[y].row, 
102 			conva-&gt;velement[y].factor,
103 			conva-&gt;hline[b].weight );
104 		for( x = 0; x &lt; 45; x++ ) {
105 			int rx = x * (conva-&gt;iM-&gt;Xsize + 1) / 45;
106 			if( rx &gt;= conva-&gt;hline[b].start &amp;&amp; 
107 				rx &lt; conva-&gt;hline[b].end )
108 				printf( "#" );
109 			else
110 				printf( " " );
111 		}
112 		printf( " %3d .. %3d\n", 
113 			conva-&gt;hline[b].start, conva-&gt;hline[b].end );
114 	}
115 }
116 static void
117 vips_conva_vprint( VipsConva *conva )
118 {
119 	int y;
120 	printf( "%d vlines:\n", conva-&gt;n_vline );
121 	printf( "   n  b  f      s      e\n" );
122 	for( y = 0; y &lt; conva-&gt;n_vline; y++ ) 
123 		printf( "%4d %2d %2d == %3d .. %3d\n", y,
124 			conva-&gt;vline[y].band, 
125 			conva-&gt;vline[y].factor, 
126 			conva-&gt;vline[y].start, 
127 			conva-&gt;vline[y].end );
128 	printf( "divisor = %d\n", conva-&gt;divisor );
129 	printf( "rounding = %d\n", conva-&gt;rounding );
130 	printf( "offset = %d\n", conva-&gt;offset );
131 	printf( "max_line = %d\n", conva-&gt;max_line );
132 }
133 static int
134 vips_conva_decompose_hlines( VipsConva *conva )
135 {
136 	VipsImage *iM = conva-&gt;iM;
137 	const int size = iM-&gt;Xsize * iM-&gt;Ysize;
138 	double *coeff = VIPS_MATRIX( iM, 0, 0 ); 
139 	double max;
140 	double min;
141 	double depth;
142 	int layers_above;
143 	int layers_below;
144 	int z, n, x, y;
145 	max = 0;
146 	min = 0;
147 	for( n = 0; n &lt; size; n++ ) {
148 		max = VIPS_MAX( max, coeff[n] );
149 		min = VIPS_MIN( min, coeff[n] );
150 	}
151 	VIPS_DEBUG_MSG( "vips_conva_decompose_hlines: min = %g, max = %g\n", 
152 		min, max );
153 	depth = (max - min) / conva-&gt;layers;
154 	layers_above = VIPS_CEIL( max / depth );
155 	depth = max / layers_above;
156 	layers_below = VIPS_FLOOR( min / depth );
157 	conva-&gt;layers = layers_above - layers_below;
158 	VIPS_DEBUG_MSG( "vips_conva_decompose_hlines: depth = %g, layers = %d\n",
159 		depth, conva-&gt;layers );
160 	for( z = 0; z &lt; conva-&gt;layers; z++ ) {
161 		double z_ph = max - (1 + z) * depth + depth / 2;
162 		int z_positive = z &lt; layers_above;
163 		for( y = 0; y &lt; iM-&gt;Ysize; y++ ) {
164 			int inside;
165 			inside = 0;
166 			for( x = 0; x &lt; iM-&gt;Xsize; x++ ) {
167 				double c = coeff[x + y * iM-&gt;Xsize];
168 				if( (z_positive &amp;&amp; c &gt;= z_ph) ||
169 					(!z_positive &amp;&amp; c &lt;= z_ph) ) {
170 					if( !inside ) {
171 						vips_conva_hline_start( conva,
172 							x );
173 						inside = 1;
174 					}
175 				}
176 				else {
177 					if( inside ) {
178 						if( vips_conva_hline_end( conva,
179 							x, y, 
180 							z_positive ? 1 : -1 ) )
181 							return( -1 );
182 						inside = 0;
183 					}
184 				}
185 			}
186 			if( inside &amp;&amp; 
187 				vips_conva_hline_end( conva, 
188 					iM-&gt;Xsize, y, z_positive ? 1 : -1 ) )
189 				return( -1 );
190 		}
191 	}
192 #ifdef DEBUG
193 	VIPS_DEBUG_MSG( "vips_conva_decompose_hlines: generated %d hlines\n", 
194 		conva-&gt;n_hline );
195 	vips_conva_hprint( conva );
196 	return( 0 );
197 }
198 static int
199 vips_conva_distance( VipsConva *conva, int a, int b )
200 {
201 	g_assert( conva-&gt;hline[a].weight &gt; 0 &amp;&amp; conva-&gt;hline[b].weight &gt; 0 );
202 	return( abs( conva-&gt;hline[a].start - conva-&gt;hline[b].start ) + 
203 		abs( conva-&gt;hline[a].end - conva-&gt;hline[b].end ) ); 
204 }
205 static void
206 vips_conva_merge( VipsConva *conva, int a, int b )
207 {
208 	int i;
209 	int fa = conva-&gt;hline[a].weight;
210 	int fb = conva-&gt;hline[b].weight;
211 	double w = (double) fb / (fa + fb);
212 	conva-&gt;hline[a].start += w * 
213 		(conva-&gt;hline[b].start - conva-&gt;hline[a].start);
214 	conva-&gt;hline[a].end += w * 
215 		(conva-&gt;hline[b].end - conva-&gt;hline[a].end);
216 	conva-&gt;hline[a].weight += conva-&gt;hline[b].weight;
217 	for( i = 0; i &lt; conva-&gt;n_velement; i++ )
218 		if( conva-&gt;velement[i].band == b )
219 			conva-&gt;velement[i].band = a;
220 	conva-&gt;hline[b].weight = 0;
221 }
222 static int
223 edge_sortfn( const void *p1, const void *p2 )
224 {
225 	Edge *a = (Edge *) p1;
226 	Edge *b = (Edge *) p2;
227 	return( a-&gt;d - b-&gt;d );
228 }
229 static int
230 vips_conva_cluster2( VipsConva *conva )
231 {
232 	int i, j, k;
233 	int worst;
234 	int worst_i;
235 	int merged;
236 	for( i = 0; i &lt; MAX_EDGES; i++ ) {
237 		conva-&gt;edge[i].a = -1;
238 		conva-&gt;edge[i].b = -1;
239 		conva-&gt;edge[i].d = 99999;
240 	}
241 	worst_i = 0;
242 	worst = conva-&gt;edge[worst_i].d;
243 	for( i = 0; i &lt; conva-&gt;n_hline; i++ ) {
244 		if( conva-&gt;hline[i].weight == 0 )
245 			continue;
246 		for( j = i + 1; j &lt; conva-&gt;n_hline; j++ ) {
247 			int distance;
248 			if( conva-&gt;hline[j].weight == 0 )
249 				continue;
250 			distance = vips_conva_distance( conva, i, j ); 
251 			if( distance &lt; worst ) {
252 				conva-&gt;edge[worst_i].a = i;
253 				conva-&gt;edge[worst_i].b = j;
254 				conva-&gt;edge[worst_i].d = distance;
255 				worst_i = 0;
256 				worst = conva-&gt;edge[worst_i].d;
257 				for( k = 0; k &lt; MAX_EDGES; k++ )
258 					if( conva-&gt;edge[k].d &gt; worst ) {
259 						worst = conva-&gt;edge[k].d;
260 						worst_i = k;
261 					}
262 			}
263 		}
264 	}
265 	qsort( conva-&gt;edge, MAX_EDGES, sizeof( Edge ), edge_sortfn );
266 	merged = 0;
267 	for( k = 0; k &lt; MAX_EDGES; k++ ) {
268 		Edge *edge = &amp;conva-&gt;edge[k];
269 		if( edge-&gt;d &gt; conva-&gt;cluster )
270 			break;
271 		if( edge-&gt;a == -1 )
272 			continue;
273 		vips_conva_merge( conva, edge-&gt;a, edge-&gt;b );
274 		merged = 1;
275 		for( i = k; i &lt; MAX_EDGES; i++ ) {
276 			Edge *edgei = &amp;conva-&gt;edge[i];
277 			if( edgei-&gt;a == edge-&gt;a ||
278 				edgei-&gt;b == edge-&gt;a ||
279 				edgei-&gt;a == edge-&gt;b ||
280 				edgei-&gt;b == edge-&gt;b )
281 				edgei-&gt;a = -1;
282 		}
283 	}
284 	return( merged );
285 }
286 static void
287 vips_conva_renumber( VipsConva *conva )
288 {
289 	int i, j;
290 	VIPS_DEBUG_MSG( "vips_conva_renumber: renumbering ...\n" );
291 	for( i = 0; i &lt; conva-&gt;n_hline; ) {
292 		if( conva-&gt;hline[i].weight &gt; 0 ) {
293 			i++;
294 			continue;
295 		}
296 		for( j = 0; j &lt; conva-&gt;n_velement; j++ )
297 			if( conva-&gt;velement[j].band &gt; i ) 
298 				conva-&gt;velement[j].band -= 1;
299 		memmove( conva-&gt;hline + i, conva-&gt;hline + i + 1, 
300 			sizeof( HLine ) * (conva-&gt;n_hline - i - 1) );
301 		conva-&gt;n_hline -= 1;
302 	}
303 	VIPS_DEBUG_MSG( "vips_conva_renumber: ... %d hlines remain\n", 
304 		conva-&gt;n_hline );
305 }
306 static int
307 velement_sortfn( const void *p1, const void *p2 )
308 {
309 	VElement *a = (VElement *) p1;
310 	VElement *b = (VElement *) p2;
311 	if( a-&gt;band != b-&gt;band )
312 		return( a-&gt;band - b-&gt;band );
313 	if( a-&gt;factor != b-&gt;factor )
314 		return( a-&gt;factor - b-&gt;factor );
315 	return( a-&gt;row - b-&gt;row );
316 }
317 static void
318 vips_conva_vline( VipsConva *conva )
319 {
320 	int y, z;
321 	VIPS_DEBUG_MSG( "vips_conva_vline: forming vlines ...\n" );
322 	qsort( conva-&gt;velement, conva-&gt;n_velement, sizeof( VElement ), 
323 		velement_sortfn );
324 #ifdef DEBUG
325 	vips_conva_hprint( conva );
326 	for( y = 0; y &lt; conva-&gt;n_velement; y++ ) {
327 		for( z = y + 1; z &lt; conva-&gt;n_velement; z++ )
328 			if( conva-&gt;velement[z].band != 
329 				conva-&gt;velement[y].band ||
330 				conva-&gt;velement[z].row != 
331 					conva-&gt;velement[y].row )
332 				break;
333 		if( conva-&gt;velement[y].factor &gt; 0 )
334 			conva-&gt;velement[y].factor = z - y;
335 		else
336 			conva-&gt;velement[y].factor = y - z;
337 		memmove( conva-&gt;velement + y + 1, conva-&gt;velement + z,
338 			sizeof( VElement ) * (conva-&gt;n_velement - z) );
339 		conva-&gt;n_velement -= z - y - 1;
340 	}
341 #ifdef DEBUG
342 	printf( "after commoning up, %d velement remain\n", conva-&gt;n_velement );
343 	vips_conva_hprint( conva );
344 	conva-&gt;n_vline = 0;
345 	for( y = 0; y &lt; conva-&gt;n_velement; ) {
346 		int n = conva-&gt;n_vline;
347 		conva-&gt;vline[n].band = conva-&gt;velement[y].band;
348 		conva-&gt;vline[n].factor = conva-&gt;velement[y].factor;
349 		conva-&gt;vline[n].start = conva-&gt;velement[y].row;
350 		for( z = y + 1; z &lt; conva-&gt;n_velement; z++ ) 
351 			if( conva-&gt;velement[z].band != 
352 					conva-&gt;vline[n].band ||
353 				conva-&gt;velement[z].factor != 
354 					conva-&gt;vline[n].factor ||
355 				conva-&gt;velement[z].row != 
356 					conva-&gt;vline[n].start + z - y )
357 				break;
358 		conva-&gt;vline[n].end = conva-&gt;velement[z - 1].row + 1;
359 		conva-&gt;n_vline += 1;
360 		y = z;
361 	}
362 	VIPS_DEBUG_MSG( "vips_conva_vline: found %d vlines\n", conva-&gt;n_vline );
363 }
364 static int
365 vips_conva_decompose_boxes( VipsConva *conva )
366 {
367 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( conva );
368 	VipsImage *iM = conva-&gt;iM;
369 	double *coeff = VIPS_MATRIX( iM, 0, 0 ); 
370 	const int size = iM-&gt;Xsize * iM-&gt;Ysize;
371 	double scale = vips_image_get_scale( iM ); 
372 	double offset = vips_image_get_offset( iM ); 
373 	double sum;
374 	double area;
375 	int x, y, z;
376 	if( vips_conva_decompose_hlines( conva ) )
377 		return( -1 );
378 	VIPS_DEBUG_MSG( "vips_conva_decompose_boxes: "
379 		"clustering hlines with thresh %d ...\n", conva-&gt;cluster );
380 	while( vips_conva_cluster2( conva ) )
381 		;
382 	vips_conva_renumber( conva );
383 	vips_conva_vline( conva );
384 	area = 0;
385 	conva-&gt;max_line = 0;
386 	for( y = 0; y &lt; conva-&gt;n_velement; y++ ) {
387 		x = conva-&gt;velement[y].band;
388 		z = conva-&gt;hline[x].end - conva-&gt;hline[x].start;
389 		area += abs( conva-&gt;velement[y].factor * z );
390 		if( z &gt; conva-&gt;max_line )
391 			conva-&gt;max_line = z;
392 	}
393 	x = conva-&gt;velement[0].factor;
394 	for( y = 1; y &lt; conva-&gt;n_velement; y++ ) 
395 		x = gcd( x, conva-&gt;velement[y].factor );
396 	for( y = 0; y &lt; conva-&gt;n_velement; y++ ) 
397 		conva-&gt;velement[y].factor /= x;
398 	area *= x;
399 	sum = 0;
400 	for( z = 0; z &lt; size; z++ ) 
401 		sum += fabs( coeff[z] );
402 	conva-&gt;divisor = VIPS_RINT( area * scale / sum );
403 	conva-&gt;rounding = (conva-&gt;divisor + 1) / 2;
404 	conva-&gt;offset = offset;
405 #ifdef DEBUG
406 	vips_conva_hprint( conva );
407 	vips_conva_vprint( conva );
408 	if( conva-&gt;n_hline &gt; 150 ) {
409 		vips_error( class-&gt;nickname, "%s", _( "mask too complex" ) );
410 		return( -1 );
411 	}
412 	return( 0 );
413 }
414 typedef struct {
415 	VipsConva *conva;
416 	VipsRegion *ir;		
417 	int *start;		
418 	int *end;
419 	int last_stride;	
420 	void *sum;		
421 } VipsConvaSeq;
422 static int
423 vips_conva_stop( void *vseq, void *a, void *b )
424 {
425 	VipsConvaSeq *seq = (VipsConvaSeq *) vseq;
426 	VIPS_UNREF( seq-&gt;ir );
427 	return( 0 );
428 }
429 static void *
430 vips_conva_start( VipsImage *out, void *a, void *b )
431 {
432 	VipsImage *in = (VipsImage *) a;
433 	VipsConva *conva = (VipsConva *) b;
434 	VipsConvaSeq *seq;
435 	seq = VIPS_NEW( out, VipsConvaSeq );
436 	seq-&gt;conva = conva;
437 	seq-&gt;ir = vips_region_new( in );
438 	g_assert( conva-&gt;n_velement &gt;= conva-&gt;n_hline );
439 	g_assert( conva-&gt;n_velement &gt;= conva-&gt;n_vline );
440 	seq-&gt;start = VIPS_ARRAY( out, conva-&gt;n_velement, int );
441 	seq-&gt;end = VIPS_ARRAY( out, conva-&gt;n_velement, int );
442 	if( vips_band_format_isint( out-&gt;BandFmt ) )
443 		seq-&gt;sum = VIPS_ARRAY( out, conva-&gt;n_velement, int );
444 	else
445 		seq-&gt;sum = VIPS_ARRAY( out, conva-&gt;n_velement, double );
446 	seq-&gt;last_stride = -1;
447 	return( seq );
448 }
449 #define HCONV( IN, OUT ) \
450 G_STMT_START { \
451 	for( i = 0; i &lt; bands; i++ ) { \
452 		OUT *seq_sum = (OUT *) seq-&gt;sum; \
453 		\
454 		IN *p; \
455 		OUT *q; \
456 		\
457 		p = i + (IN *) VIPS_REGION_ADDR( ir, r-&gt;left, r-&gt;top + y ); \
458 		q = i * n_hline + \
459 			(OUT *) VIPS_REGION_ADDR( or, r-&gt;left, r-&gt;top + y ); \
460 		\
461 		for( z = 0; z &lt; n_hline; z++ ) { \
462 			seq_sum[z] = 0; \
463 			for( x = conva-&gt;hline[z].start; \
464 				x &lt; conva-&gt;hline[z].end; x++ ) \
465 				seq_sum[z] += p[x * istride]; \
466 			q[z] = seq_sum[z]; \
467 		} \
468 		q += ostride; \
469 		\
470 		for( x = 1; x &lt; r-&gt;width; x++ ) {  \
471 			for( z = 0; z &lt; n_hline; z++ ) { \
472 				seq_sum[z] += p[seq-&gt;end[z]]; \
473 				seq_sum[z] -= p[seq-&gt;start[z]]; \
474 				q[z] = seq_sum[z]; \
475 			} \
476 			p += istride; \
477 			q += ostride; \
478 		} \
479 	} \
480 } G_STMT_END
481 static int
482 vips_conva_hgenerate( VipsRegion *or, void *vseq, 
483 	void *a, void *b, gboolean *stop )
484 {
485 	VipsConvaSeq *seq = (VipsConvaSeq *) vseq;
486 	VipsImage *in = (VipsImage *) a;
487 	VipsConva *conva = (VipsConva *) b;
488 	VipsRegion *ir = seq-&gt;ir;
489 	const int n_hline = conva-&gt;n_hline;
490 	VipsImage *iM = conva-&gt;iM;
491 	VipsRect *r = &amp;or-&gt;valid;
492 	int bands = vips_band_format_iscomplex( in-&gt;BandFmt ) ? 
493 		2 * in-&gt;Bands : in-&gt;Bands;
494 	VipsRect s;
495 	int x, y, z, i;
496 	int istride;
497 	int ostride;
498 	s = *r;
499 	s.width += iM-&gt;Xsize - 1;
500 	if( vips_region_prepare( ir, &amp;s ) )
501 		return( -1 );
502 	istride = VIPS_IMAGE_SIZEOF_PEL( in ) / 
503 		VIPS_IMAGE_SIZEOF_ELEMENT( in );
504 	ostride = VIPS_IMAGE_SIZEOF_PEL( or-&gt;im ) / 
505 		VIPS_IMAGE_SIZEOF_ELEMENT( or-&gt;im );
506 	if( seq-&gt;last_stride != istride ) {
507 		seq-&gt;last_stride = istride;
508 		for( z = 0; z &lt; n_hline; z++ ) {
509 			seq-&gt;start[z] = conva-&gt;hline[z].start * istride;
510 			seq-&gt;end[z] = conva-&gt;hline[z].end * istride;
511 		}
512 	}
513 	for( y = 0; y &lt; r-&gt;height; y++ ) { 
514 		switch( in-&gt;BandFmt ) {
515 		case VIPS_FORMAT_UCHAR: 	
516 			if( conva-&gt;max_line &lt; 256 )
517 				HCONV( unsigned char, unsigned short );
518 			else
519 				HCONV( unsigned char, unsigned int );
520 			break;
521 		case VIPS_FORMAT_CHAR: 	
522 			if( conva-&gt;max_line &lt; 256 )
523 				HCONV( signed char, signed short );
524 			else
525 				HCONV( signed char, signed int );
526 			break;
527 		case VIPS_FORMAT_USHORT: 	
528 			HCONV( unsigned short, unsigned int );
529 			break;
530 		case VIPS_FORMAT_SHORT: 	
531 			HCONV( signed short, signed int );
532 			break;
533 		case VIPS_FORMAT_UINT: 	
534 			HCONV( unsigned int, unsigned int );
535 			break;
536 		case VIPS_FORMAT_INT: 	
537 			HCONV( signed int, signed int );
538 			break;
539 		case VIPS_FORMAT_FLOAT: 	
540 			HCONV( float, float );
541 			break;
542 		case VIPS_FORMAT_DOUBLE: 	
543 			HCONV( double, double );
544 			break;
545 		case VIPS_FORMAT_COMPLEX: 	
546 			HCONV( float, float );
547 			break;
548 		case VIPS_FORMAT_DPCOMPLEX: 	
549 			HCONV( double, double );
550 			break;
551 		default:
552 			g_assert_not_reached();
553 		}
554 	}
555 	return( 0 );
556 }
557 static int
558 vips_conva_horizontal( VipsConva *conva, VipsImage *in, VipsImage **out )
559 {
560 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( conva );
561 	*out = vips_image_new(); 
562 	if( vips_image_pipelinev( *out, 
563 		VIPS_DEMAND_STYLE_SMALLTILE, in, NULL ) )
564 		return( -1 );
565 	(*out)-&gt;Xsize -= conva-&gt;iM-&gt;Xsize - 1;
566 	if( (*out)-&gt;Xsize &lt;= 0 ) { 
567 		vips_error( class-&gt;nickname, 
568 			"%s", _( "image too small for mask" ) );
569 		return( -1 );
570 	}
571 	(*out)-&gt;Bands *= conva-&gt;n_hline;
572 	if( vips_band_format_isuint( in-&gt;BandFmt ) )
573 		(*out)-&gt;BandFmt = conva-&gt;max_line &lt; 256 ? 
574 			VIPS_FORMAT_USHORT : VIPS_FORMAT_UINT;
575 	else if( vips_band_format_isint( in-&gt;BandFmt ) )
576 		(*out)-&gt;BandFmt = conva-&gt;max_line &lt; 256 ? 
577 			VIPS_FORMAT_SHORT : VIPS_FORMAT_INT;
578 	if( vips_image_generate( *out, 
579 		vips_conva_start, vips_conva_hgenerate, vips_conva_stop, 
580 		in, conva ) )
581 		return( -1 );
582 	return( 0 );
583 }
584 #define CLIP_UCHAR( V ) \
585 G_STMT_START { \
586 	if( (V) &lt; 0 ) \
587 		(V) = 0; \
588 	else if( (V) &gt; UCHAR_MAX ) \
589 		(V) = UCHAR_MAX; \
590 } G_STMT_END
591 #define CLIP_CHAR( V ) \
592 G_STMT_START { \
593 	if( (V) &lt; SCHAR_MIN ) \
594 		(V) = SCHAR_MIN; \
595 	else if( (V) &gt; SCHAR_MAX ) \
596 		(V) = SCHAR_MAX; \
597 } G_STMT_END
598 #define CLIP_USHORT( V ) \
599 G_STMT_START { \
600 	if( (V) &lt; 0 ) \
601 		(V) = 0; \
602 	else if( (V) &gt; USHRT_MAX ) \
603 		(V) = USHRT_MAX; \
604 } G_STMT_END
605 #define CLIP_SHORT( V ) \
606 G_STMT_START { \
607 	if( (V) &lt; SHRT_MIN ) \
608 		(V) = SHRT_MIN; \
609 	else if( (V) &gt; SHRT_MAX ) \
610 		(V) = SHRT_MAX; \
611 } G_STMT_END
612 #define CLIP_NONE( V ) {}
613 #define VCONV( ACC, IN, OUT, CLIP ) \
614 G_STMT_START { \
615 	for( x = 0; x &lt; sz; x++ ) { \
616 		ACC *seq_sum = (ACC *) seq-&gt;sum; \
617 		\
618 		IN *p; \
619 		OUT *q; \
620 		ACC sum; \
621 		\
622 		p = x * conva-&gt;n_hline + \
623 			(IN *) VIPS_REGION_ADDR( ir, r-&gt;left, r-&gt;top ); \
624 		q = x + (OUT *) VIPS_REGION_ADDR( or, r-&gt;left, r-&gt;top ); \
625 		\
626 		sum = 0; \
627 		for( z = 0; z &lt; n_vline; z++ ) { \
628 			seq_sum[z] = 0; \
629 			for( k = conva-&gt;vline[z].start; \
630 				k &lt; conva-&gt;vline[z].end; k++ ) \
631 				seq_sum[z] += p[k * istride + \
632 					conva-&gt;vline[z].band]; \
633 			sum += conva-&gt;vline[z].factor * seq_sum[z]; \
634 		} \
635 		sum = (sum + conva-&gt;rounding) / conva-&gt;divisor + conva-&gt;offset; \
636 		CLIP( sum ); \
637 		*q = sum; \
638 		q += ostride; \
639 		\
640 		for( y = 1; y &lt; r-&gt;height; y++ ) { \
641 			sum = 0;\
642 			for( z = 0; z &lt; n_vline; z++ ) { \
643 				seq_sum[z] += p[seq-&gt;end[z]]; \
644 				seq_sum[z] -= p[seq-&gt;start[z]]; \
645 				sum += conva-&gt;vline[z].factor * seq_sum[z]; \
646 			} \
647 			p += istride; \
648 			sum = (sum + conva-&gt;rounding) / conva-&gt;divisor + \
649 				conva-&gt;offset; \
650 			CLIP( sum ); \
651 			*q = sum; \
652 			q += ostride; \
653 		} \
654 	} \
655 } G_STMT_END
656 static int
657 vips_conva_vgenerate( VipsRegion *or, void *vseq, 
658 	void *a, void *b, gboolean *stop )
659 {
660 	VipsConvaSeq *seq = (VipsConvaSeq *) vseq;
661 	VipsImage *in = (VipsImage *) a;
662 	VipsConva *conva = (VipsConva *) b;
663 	VipsConvolution *convolution = (VipsConvolution *) conva;
664 	VipsRegion *ir = seq-&gt;ir;
665 	const int n_vline = conva-&gt;n_vline;
666 	VipsImage *iM = conva-&gt;iM;
667 	VipsRect *r = &amp;or-&gt;valid;
668 	int sz = vips_band_format_iscomplex( in-&gt;BandFmt ) ? 
669 		2 * VIPS_REGION_N_ELEMENTS( or ) : VIPS_REGION_N_ELEMENTS( or );
670 	VipsRect s;
671 	int x, y, z, k;
672 	int istride;
673 	int ostride;
674 	s = *r;
675 	s.height += iM-&gt;Ysize - 1;
676 	if( vips_region_prepare( ir, &amp;s ) )
677 		return( -1 );
678 	istride = VIPS_REGION_LSKIP( ir ) / 
679 		VIPS_IMAGE_SIZEOF_ELEMENT( in );
680 	ostride = VIPS_REGION_LSKIP( or ) / 
681 		VIPS_IMAGE_SIZEOF_ELEMENT( convolution-&gt;out );
682 	if( seq-&gt;last_stride != istride ) {
683 		seq-&gt;last_stride = istride;
684 		for( z = 0; z &lt; n_vline; z++ ) {
685 			seq-&gt;start[z] = conva-&gt;vline[z].band + 
686 				conva-&gt;vline[z].start * istride;
687 			seq-&gt;end[z] = conva-&gt;vline[z].band + 
688 				conva-&gt;vline[z].end * istride;
689 		}
690 	}
691 	switch( convolution-&gt;in-&gt;BandFmt ) {
692 	case VIPS_FORMAT_UCHAR: 	
693 		if( conva-&gt;max_line &lt; 256 )
694 			VCONV( unsigned int, \
695 				unsigned short, unsigned char, CLIP_UCHAR );
696 		else
697 			VCONV( unsigned int, \
698 				unsigned int, unsigned char, CLIP_UCHAR );
699 		break;
700 	case VIPS_FORMAT_CHAR: 	
701 		if( conva-&gt;max_line &lt; 256 )
702 			VCONV( signed int, \
703 				signed short, signed char, CLIP_CHAR );
704 		else
705 			VCONV( signed int, \
706 				signed int, signed char, CLIP_CHAR );
707 		break;
708 	case VIPS_FORMAT_USHORT: 	
709 		VCONV( unsigned int, \
710 			unsigned int, unsigned short, CLIP_USHORT );
711 		break;
712 	case VIPS_FORMAT_SHORT: 	
713 		VCONV( signed int, signed int, signed short, CLIP_SHORT );
714 		break;
715 	case VIPS_FORMAT_UINT: 	
716 		VCONV( unsigned int, unsigned int, unsigned int, CLIP_NONE );
717 		break;
718 	case VIPS_FORMAT_INT: 	
719 		VCONV( signed int, signed int, signed int, CLIP_NONE );
720 		break;
721 	case VIPS_FORMAT_FLOAT: 	
722 		VCONV( float, float, float, CLIP_NONE );
723 		break;
724 	case VIPS_FORMAT_DOUBLE: 	
725 		VCONV( double, double, double, CLIP_NONE );
726 		break;
727 	case VIPS_FORMAT_COMPLEX: 	
728 		VCONV( float, float, float, CLIP_NONE );
729 		break;
730 	case VIPS_FORMAT_DPCOMPLEX: 	
731 		VCONV( double, double, double, CLIP_NONE );
732 		break;
733 	default:
734 		g_assert_not_reached();
735 	}
736 	return( 0 );
737 }
738 static int
739 vips_conva_vertical( VipsConva *conva, VipsImage *in, VipsImage **out )
740 {
741 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( conva );
742 	VipsConvolution *convolution = (VipsConvolution *) conva;
743 	*out = vips_image_new(); 
744 	if( vips_image_pipelinev( *out, 
745 		VIPS_DEMAND_STYLE_SMALLTILE, in, NULL ) )
746 		return( -1 );
747 	(*out)-&gt;Ysize -= conva-&gt;iM-&gt;Ysize - 1;
748 	if( (*out)-&gt;Ysize &lt;= 0 ) { 
749 		vips_error( class-&gt;nickname, 
750 			"%s", _( "image too small for mask" ) );
751 		return( -1 );
752 	}
753 	(*out)-&gt;Bands = convolution-&gt;in-&gt;Bands;
754 	(*out)-&gt;BandFmt = convolution-&gt;in-&gt;BandFmt;
755 	if( vips_image_generate( *out, 
756 		vips_conva_start, vips_conva_vgenerate, vips_conva_stop, 
757 		in, conva ) )
758 		return( -1 );
759 	return( 0 );
760 }
761 static int
762 vips_conva_build( VipsObject *object )
763 {
764 	VipsConvolution *convolution = (VipsConvolution *) object;
765 	VipsConva *conva = (VipsConva *) object;
766 	VipsImage **t = (VipsImage **) vips_object_local_array( object, 4 );
767 	VipsImage *in;
768 	if( VIPS_OBJECT_CLASS( vips_conva_parent_class )-&gt;build( object ) )
769 		return( -1 );
770 	if( vips__image_intize( convolution-&gt;M, &amp;t[0] ) )
771 		return( -1 );
772 	conva-&gt;iM = t[0]; 
773 #ifdef DEBUG
774 	printf( "vips_conva_build: iM =\n" );
775 	vips_matrixprint( conva-&gt;iM, NULL );
776 	in = convolution-&gt;in;
777 	if( vips_conva_decompose_boxes( conva ) )
778 	       return( -1 ); 	
779 	g_object_set( conva, "out", vips_image_new(), NULL ); 
780 	if( 
781 		vips_embed( in, &amp;t[1], 
782 			t[0]-&gt;Xsize / 2, 
783 			t[0]-&gt;Ysize / 2, 
784 			in-&gt;Xsize + t[0]-&gt;Xsize - 1, 
785 			in-&gt;Ysize + t[0]-&gt;Ysize - 1,
786 			"extend", VIPS_EXTEND_COPY,
787 			NULL ) ||
788 		vips_conva_horizontal( conva, t[1], &amp;t[2] ) ||
789 		vips_conva_vertical( conva, t[2], &amp;t[3] ) ||
790 		vips_image_write( t[3], convolution-&gt;out ) )
791 		return( -1 );
792 	convolution-&gt;out-&gt;Xoffset = 0;
793 <a name="1"></a>	convolution-&gt;out-&gt;Yoffset = 0;
794 	return( 0 );
795 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
796 static void
797 vips_conva_class_init( VipsConvaClass *class )
798 {
799 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
800 	VipsObjectClass *object_class = (VipsObjectClass *) class;
801 	gobject_class-&gt;set_property = vips_object_set_property;
802 	gobject_class-&gt;get_property = vips_object_get_property;
803 	object_class-&gt;nickname = "conva";</b></font>
804 	object_class-&gt;description = _( "approximate integer convolution" );
805 	object_class-&gt;build = vips_conva_build;
806 	VIPS_ARG_INT( class, "layers", 104, 
807 		_( "Layers" ), 
808 		_( "Use this many layers in approximation" ),
809 		VIPS_ARGUMENT_OPTIONAL_INPUT, 
810 		G_STRUCT_OFFSET( VipsConva, layers ), 
811 		1, 1000, 5 ); 
812 	VIPS_ARG_INT( class, "cluster", 105, 
813 		_( "Cluster" ), 
814 		_( "Cluster lines closer than this in approximation" ),
815 		VIPS_ARGUMENT_OPTIONAL_INPUT, 
816 <a name="0"></a>		G_STRUCT_OFFSET( VipsConva, cluster ), 
817 		1, 100, 1 ); 
818 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
819 static void
820 vips_conva_init( VipsConva *conva )
821 {
822         conva-&gt;layers = 5;
823         conva-&gt;cluster = 1;
824 }
825 int 
826 vips_conva( VipsImage *in, VipsImage **out, VipsImage *mask, ... )
827 {
828 	va_list ap;
829 	int result;
830 	va_start( ap, mask );
831 	result = vips_call_split( "conva", ap, in, out, mask );
832 	va_end( ap );
833 	return( result );
834 }</b></font>
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
