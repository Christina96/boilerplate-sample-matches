<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for infd-xmpp-server.c &amp; inf-tcp-connection.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for infd-xmpp-server.c &amp; inf-tcp-connection.c
      </h3>
<h1 align="center">
        6.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>infd-xmpp-server.c (12.418301%)<th>inf-tcp-connection.c (4.634146%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(361-381)<td><a href="#" name="0">(917-937)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(542-556)<td><a href="#" name="1">(1189-1203)</a><td align="center"><font color="#da0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(499-515)<td><a href="#" name="2">(1076-1092)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>infd-xmpp-server.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinfinity/server/infd-xmpp-server.h&gt;
#include &lt;libinfinity/server/infd-tcp-server.h&gt;
#include &lt;libinfinity/server/infd-xml-server.h&gt;
#include &lt;libinfinity/common/inf-xmpp-connection.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
#ifdef G_OS_WIN32
# ifdef ERROR
#  undef ERROR
# endif
#endif
typedef enum InfdXmppServerStatus_ {
  INFD_XMPP_SERVER_CLOSED,
  INFD_XMPP_SERVER_OPEN
} InfdXmppServerStatus;
typedef struct _InfdXmppServerPrivate InfdXmppServerPrivate;
struct _InfdXmppServerPrivate {
  InfdTcpServer* tcp;
  InfdXmppServerStatus status;
  gchar* local_hostname;
  InfXmppConnectionSecurityPolicy security_policy;
  InfCertificateCredentials* tls_creds;
  InfSaslContext* sasl_context;
  InfSaslContext* sasl_own_context;
  gchar* sasl_mechanisms;
};
enum {
  PROP_0,
  PROP_TCP,
  PROP_LOCAL_HOSTNAME,
  PROP_CREDENTIALS,
  PROP_SASL_CONTEXT,
  PROP_SASL_MECHANISMS,
  PROP_SECURITY_POLICY,
  PROP_STATUS
};
enum {
  ERROR,
  LAST_SIGNAL
};
#define INFD_XMPP_SERVER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFD_TYPE_XMPP_SERVER, InfdXmppServerPrivate))
static guint xmpp_server_signals[LAST_SIGNAL];
static void infd_xmpp_server_xml_server_iface_init(InfdXmlServerInterface* iface);
G_DEFINE_TYPE_WITH_CODE(InfdXmppServer, infd_xmpp_server, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfdXmppServer)
  G_IMPLEMENT_INTERFACE(INFD_TYPE_XML_SERVER, infd_xmpp_server_xml_server_iface_init))
static void
infd_xmpp_server_new_connection_cb(InfdTcpServer* tcp_server,
                                   InfTcpConnection* tcp_connection,
                                   gpointer user_data)
{
  InfdXmppServer* xmpp_server;
  InfdXmppServerPrivate* priv;
  InfXmppConnection* xmpp_connection;
  InfIpAddress* addr;
  gchar* addr_str;
  xmpp_server = INFD_XMPP_SERVER(user_data);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp_server);
  g_object_get(G_OBJECT(tcp_connection), "remote-address", &amp;addr, NULL);
  addr_str = inf_ip_address_to_string(addr);
  inf_ip_address_free(addr);
  xmpp_connection = inf_xmpp_connection_new(
    tcp_connection,
    INF_XMPP_CONNECTION_SERVER,
    priv-&gt;local_hostname,
    addr_str,
    priv-&gt;security_policy,
    priv-&gt;tls_creds,
    priv-&gt;sasl_context,
    priv-&gt;sasl_own_context != NULL ? "ANONYMOUS" : priv-&gt;sasl_mechanisms
  );
  g_free(addr_str);
  infd_xml_server_new_connection(
    INFD_XML_SERVER(xmpp_server),
    INF_XML_CONNECTION(xmpp_connection)
  );
  g_object_unref(G_OBJECT(xmpp_connection));
}
static void
infd_xmpp_server_error_cb(InfdTcpServer* tcp_server,
                          GError* error,
                          gpointer user_data)
{
  g_signal_emit(
    G_OBJECT(user_data),
    xmpp_server_signals[ERROR],
    0,
    error
  );
}
static void
infd_xmpp_server_notify_status_cb(InfdTcpServer* tcp_server,
                                  GParamSpec* pspec,
                                  gpointer user_data)
{
  InfdXmppServer* xmpp;
  InfdXmppServerPrivate* priv;
  InfdTcpServerStatus status;
  xmpp = INFD_XMPP_SERVER(user_data);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  g_object_get(G_OBJECT(tcp_server), "status", &amp;status, NULL);
  switch(status)
  {
  case INFD_TCP_SERVER_CLOSED:
  case INFD_TCP_SERVER_BOUND:
    if(priv-&gt;status != INFD_XMPP_SERVER_CLOSED)
    {
      priv-&gt;status = INFD_XMPP_SERVER_CLOSED;
      g_object_notify(G_OBJECT(xmpp), "status");
    }
    break;
  case INFD_TCP_SERVER_OPEN:
    if(priv-&gt;status != INFD_XMPP_SERVER_OPEN)
    {
      priv-&gt;status = INFD_XMPP_SERVER_OPEN;
      g_object_notify(G_OBJECT(xmpp), "status");
    }
    break;
  default:
    g_assert_not_reached();
    break;
  }
}
static void
infd_xmpp_server_sasl_cb(InfSaslContextSession* session,
                         Gsasl_property property,
                         gpointer session_data,
                         gpointer user_data)
{
  InfdXmppServer* xmpp;
  InfdXmppServerPrivate* priv;
  xmpp = INFD_XMPP_SERVER(user_data);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  switch(property)
  {
  case GSASL_ANONYMOUS_TOKEN:
    inf_sasl_context_session_set_property(
      session,
      GSASL_ANONYMOUS_TOKEN,
      priv-&gt;local_hostname
    );
    inf_sasl_context_session_continue(session, GSASL_OK);
    break;
  case GSASL_VALIDATE_ANONYMOUS:
    inf_sasl_context_session_continue(session, GSASL_OK);
    break;
  default:
    g_assert_not_reached();
    inf_sasl_context_session_continue(session, GSASL_NO_CALLBACK);
    break;
  }
}
static void
infd_xmpp_server_setup_own_sasl_context(InfdXmppServer* xmpp)
{
  InfdXmppServerPrivate* priv;
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  g_assert(priv-&gt;sasl_own_context == NULL);
  if(priv-&gt;sasl_context == NULL &amp;&amp; priv-&gt;tcp != NULL)
  {
    priv-&gt;sasl_own_context = inf_sasl_context_new(NULL);
    if(priv-&gt;sasl_own_context != NULL)
    {
      priv-&gt;sasl_context = priv-&gt;sasl_own_context;
      inf_sasl_context_ref(priv-&gt;sasl_context);
      inf_sasl_context_set_callback(
        priv-&gt;sasl_context,
        infd_xmpp_server_sasl_cb,
        xmpp,
        NULL
      );
      g_object_notify(G_OBJECT(xmpp), "sasl-context");
    }
  }
}
static void
infd_xmpp_server_set_tcp(InfdXmppServer* xmpp,
                         InfdTcpServer* tcp)
{
  InfdXmppServerPrivate* priv;
  InfdTcpServerStatus tcp_status;
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  g_object_freeze_notify(G_OBJECT(xmpp));
  if(priv-&gt;tcp != NULL)
  {
    g_object_get(G_OBJECT(priv-&gt;tcp), "status", &amp;tcp_status, NULL);
    if(tcp_status != INFD_TCP_SERVER_CLOSED)
      infd_tcp_server_close(priv-&gt;tcp);
    if(priv-&gt;sasl_own_context != NULL)
    {
      inf_sasl_context_unref(priv-&gt;sasl_own_context);
      priv-&gt;sasl_own_context = NULL;
    }
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;tcp),
      G_CALLBACK(infd_xmpp_server_new_connection_cb),
      xmpp
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;tcp),
      G_CALLBACK(infd_xmpp_server_error_cb),
      xmpp
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;tcp),
      G_CALLBACK(infd_xmpp_server_notify_status_cb),
      xmpp
    );
    g_object_unref(G_OBJECT(priv-&gt;tcp));
  }
  priv-&gt;tcp = tcp;
  if(tcp != NULL)
  {
    g_object_ref(G_OBJECT(tcp));
    g_signal_connect(
      G_OBJECT(tcp),
      "new-connection",
      G_CALLBACK(infd_xmpp_server_new_connection_cb),
      xmpp
    );
    g_signal_connect(
      G_OBJECT(tcp),
      "error",
      G_CALLBACK(infd_xmpp_server_error_cb),
      xmpp
    );
    g_signal_connect(
      G_OBJECT(tcp),
      "notify::status",
      G_CALLBACK(infd_xmpp_server_notify_status_cb),
      xmpp
    );
    g_object_get(G_OBJECT(tcp), "status", &amp;tcp_status, NULL);
    switch(tcp_status)
    {
    case INFD_TCP_SERVER_CLOSED:
    case INFD_TCP_SERVER_BOUND:
      g_assert(priv-&gt;status == INFD_XMPP_SERVER_CLOSED);
      break;
    case INFD_TCP_SERVER_OPEN:
      priv-&gt;status = INFD_XMPP_SERVER_OPEN;
      g_object_notify(G_OBJECT(xmpp), "status");
      break;
    default:
      g_assert_not_reached();
      break;
    }
  }
  infd_xmpp_server_setup_own_sasl_context(xmpp);
  g_object_thaw_notify(G_OBJECT(xmpp));
}
static void
infd_xmpp_server_init(InfdXmppServer* xmpp)
{
  InfdXmppServerPrivate* priv;
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  priv-&gt;tcp = NULL;
  priv-&gt;status = INFD_XMPP_SERVER_CLOSED;
  priv-&gt;local_hostname = g_strdup(g_get_host_name());
  priv-&gt;security_policy = INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED;
  priv-&gt;tls_creds = NULL;
<a name="0"></a>  priv-&gt;sasl_context = NULL;
  priv-&gt;sasl_own_context = NULL;
  priv-&gt;sasl_mechanisms = NULL;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
static void
infd_xmpp_server_dispose(GObject* object)
{
  InfdXmppServer* xmpp;
  InfdXmppServerPrivate* priv;
  xmpp = INFD_XMPP_SERVER(object);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  if(priv-&gt;status != INFD_XMPP_SERVER_CLOSED)
    infd_xml_server_close(INFD_XML_SERVER(xmpp));
  infd_xmpp_server_set_tcp(xmpp, NULL);
  if(priv-&gt;sasl_own_context != NULL)
  {
    inf_sasl_context_unref(priv-&gt;sasl_own_context);
    priv-&gt;sasl_own_context = NULL;
  }</b></font>
  if(priv-&gt;sasl_context != NULL)
  {
    inf_sasl_context_unref(priv-&gt;sasl_context);
    priv-&gt;sasl_context = NULL;
  }
  if(priv-&gt;tls_creds != NULL)
  {
    inf_certificate_credentials_unref(priv-&gt;tls_creds);
    priv-&gt;tls_creds = NULL;
  }
  G_OBJECT_CLASS(infd_xmpp_server_parent_class)-&gt;dispose(object);
}
static void
infd_xmpp_server_finalize(GObject* object)
{
  InfdXmppServer* xmpp;
  InfdXmppServerPrivate* priv;
  xmpp = INFD_XMPP_SERVER(object);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  g_free(priv-&gt;local_hostname);
  g_free(priv-&gt;sasl_mechanisms);
  G_OBJECT_CLASS(infd_xmpp_server_parent_class)-&gt;finalize(object);
}
static void
infd_xmpp_server_set_property(GObject* object,
                              guint prop_id,
                              const GValue* value,
                              GParamSpec* pspec)
{
  InfdXmppServer* xmpp;
  InfdXmppServerPrivate* priv;
  xmpp = INFD_XMPP_SERVER(object);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  switch(prop_id)
  {
  case PROP_TCP:
    infd_xmpp_server_set_tcp(
      xmpp,
      INFD_TCP_SERVER(g_value_get_object(value))
    );
    break;
  case PROP_LOCAL_HOSTNAME:
    g_free(priv-&gt;local_hostname);
    priv-&gt;local_hostname = g_value_dup_string(value);
    if(priv-&gt;local_hostname == NULL)
      priv-&gt;local_hostname = g_strdup(g_get_host_name());
    break;
  case PROP_CREDENTIALS:
    if(priv-&gt;tls_creds != NULL)
      inf_certificate_credentials_unref(priv-&gt;tls_creds);
    priv-&gt;tls_creds = g_value_dup_boxed(value);
    break;
  case PROP_SASL_CONTEXT:
    if(priv-&gt;sasl_own_context != NULL)
    {
      inf_sasl_context_unref(priv-&gt;sasl_own_context);
      priv-&gt;sasl_own_context = NULL;
    }
    if(priv-&gt;sasl_context != NULL)
      inf_sasl_context_unref(priv-&gt;sasl_context);
    priv-&gt;sasl_context = g_value_dup_boxed(value);
    infd_xmpp_server_setup_own_sasl_context(xmpp);
    break;
  case PROP_SASL_MECHANISMS:
    g_free(priv-&gt;sasl_mechanisms);
    priv-&gt;sasl_mechanisms = g_value_dup_string(value);
    break;
  case PROP_SECURITY_POLICY:
    infd_xmpp_server_set_security_policy(xmpp, g_value_get_enum(value));
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
infd_xmpp_server_get_property(GObject* object,
                              guint prop_id,
                              GValue* value,
                              GParamSpec* pspec)
{
  InfdXmppServer* xmpp;
  InfdXmppServerPrivate* priv;
  xmpp = INFD_XMPP_SERVER(object);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  switch(prop_id)
  {
  case PROP_STATUS:
    switch(priv-&gt;status)
    {
    case INFD_XMPP_SERVER_CLOSED:
      g_value_set_enum(value, INFD_XML_SERVER_CLOSED);
      break;
    case INFD_XMPP_SERVER_OPEN:
      g_value_set_enum(value, INFD_XML_SERVER_OPEN);
      break;
    default:
      g_assert_not_reached();
<a name="2"></a>      break;
    }
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
  case PROP_TCP:
    g_value_set_object(value, priv-&gt;tcp);
    break;
  case PROP_LOCAL_HOSTNAME:
    g_value_set_string(value, priv-&gt;local_hostname);
    break;
  case PROP_CREDENTIALS:
    g_value_set_boxed(value, priv-&gt;tls_creds);
    break;
  case PROP_SASL_CONTEXT:
    g_value_set_boxed(value, priv-&gt;sasl_context);
    break;
  case PROP_SASL_MECHANISMS:
    g_value_set_string(value, priv-&gt;sasl_mechanisms);
    break;
  case PROP_SECURITY_POLICY:</b></font>
    g_value_set_enum(value, priv-&gt;security_policy);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
infd_xmpp_server_xml_server_close(InfdXmlServer* xml)
{
  InfdXmppServerPrivate* priv;
  priv = INFD_XMPP_SERVER_PRIVATE(xml);
  g_return_if_fail(priv-&gt;status != INFD_XMPP_SERVER_CLOSED);
  switch(priv-&gt;status)
  {
  case INFD_XMPP_SERVER_OPEN:
    infd_tcp_server_close(priv-&gt;tcp);
    break;
  case INFD_XMPP_SERVER_CLOSED:
<a name="1"></a>  default:
    g_assert_not_reached();
    break;
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  }
}
static void
infd_xmpp_server_class_init(InfdXmppServerClass* xmpp_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(xmpp_class);
  object_class-&gt;dispose = infd_xmpp_server_dispose;
  object_class-&gt;finalize = infd_xmpp_server_finalize;
  object_class-&gt;set_property = infd_xmpp_server_set_property;
  object_class-&gt;get_property = infd_xmpp_server_get_property;
  xmpp_class-&gt;error = NULL;</b></font>
  g_object_class_install_property(
    object_class,
    PROP_TCP,
    g_param_spec_object(
      "tcp-server",
      "TCP server",
      "Underlaying TCP server",
      INFD_TYPE_TCP_SERVER,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_LOCAL_HOSTNAME,
    g_param_spec_string(
      "local-hostname",
      "Local hostname",
      "Hostname of the server",
      NULL,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_CREDENTIALS,
    g_param_spec_boxed(
      "credentials",
      "Credentials",
      "The certificate credentials for GnuTLS",
      INF_TYPE_CERTIFICATE_CREDENTIALS,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SASL_CONTEXT,
    g_param_spec_boxed(
      "sasl-context",
      "SASL context",
      "The SASL context used for authentaction",
      INF_TYPE_SASL_CONTEXT,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SASL_MECHANISMS,
    g_param_spec_string(
      "sasl-mechanisms",
      "SASL mechanisms",
      "The SASL mechanisms offered to the client for authentication",
      NULL,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SECURITY_POLICY,
    g_param_spec_enum(
      "security-policy",
      "Security policy",
      "Whether to offer or require TLS",
      INF_TYPE_XMPP_CONNECTION_SECURITY_POLICY,
      INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );
  g_object_class_override_property(object_class, PROP_STATUS, "status");
  xmpp_server_signals[ERROR] = g_signal_new(
    "error",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfdXmppServerClass, error),
    NULL, NULL,
    g_cclosure_marshal_VOID__BOXED,
    G_TYPE_NONE,
    1,
    G_TYPE_ERROR
  );
}
static void
infd_xmpp_server_xml_server_iface_init(InfdXmlServerInterface* iface)
{
  iface-&gt;close = infd_xmpp_server_xml_server_close;
}
InfdXmppServer*
infd_xmpp_server_new(InfdTcpServer* tcp,
                     InfXmppConnectionSecurityPolicy policy,
                     InfCertificateCredentials* creds,
                     InfSaslContext* sasl_context,
                     const gchar* sasl_mechanisms)
{
  GObject* object;
  g_return_val_if_fail(INFD_IS_TCP_SERVER(tcp), NULL);
  g_return_val_if_fail(
    policy == INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED || creds != NULL,
    NULL
  );
  object = g_object_new(
    INFD_TYPE_XMPP_SERVER,
    "tcp-server", tcp,
    "credentials", creds,
    "security-policy", policy,
    "sasl-context", sasl_context,
    "sasl-mechanisms", sasl_mechanisms,
    NULL
  );
  return INFD_XMPP_SERVER(object);
}
void
infd_xmpp_server_set_security_policy(InfdXmppServer* server,
                                     InfXmppConnectionSecurityPolicy policy)
{
  InfdXmppServerPrivate* priv;
  g_return_if_fail(INFD_IS_XMPP_SERVER(server));
  priv = INFD_XMPP_SERVER_PRIVATE(server);
  if(policy != priv-&gt;security_policy)
  {
    g_return_if_fail(
      policy == INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED ||
      priv-&gt;tls_creds != NULL
    );
    priv-&gt;security_policy = policy;
    g_object_notify(G_OBJECT(server), "security-policy");
  }
}
InfXmppConnectionSecurityPolicy
infd_xmpp_server_get_security_policy(InfdXmppServer* server)
{
  g_return_val_if_fail(
    INFD_IS_XMPP_SERVER(server),
    INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS
  );
  return INFD_XMPP_SERVER_PRIVATE(server)-&gt;security_policy;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-tcp-connection.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinfinity/common/inf-tcp-connection.h&gt;
#include &lt;libinfinity/common/inf-tcp-connection-private.h&gt;
#include &lt;libinfinity/common/inf-name-resolver.h&gt;
#include &lt;libinfinity/common/inf-ip-address.h&gt;
#include &lt;libinfinity/common/inf-io.h&gt;
#include &lt;libinfinity/common/inf-native-socket.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-define-enum.h&gt;
#include &lt;unistd.h&gt; 
#include "config.h"
#ifndef G_OS_WIN32
# include &lt;sys/types.h&gt;
# include &lt;sys/socket.h&gt;
# include &lt;netinet/in.h&gt;
# include &lt;net/if.h&gt;
# include &lt;arpa/inet.h&gt;
# include &lt;unistd.h&gt;
# include &lt;fcntl.h&gt;
# include &lt;errno.h&gt;
# include &lt;string.h&gt;
#else
# include &lt;ws2tcpip.h&gt;
#endif
static const GEnumValue inf_tcp_connection_status_values[] = {
  {
    INF_TCP_CONNECTION_CONNECTING,
    "INF_TCP_CONNECTION_CONNECTING",
    "connecting"
  }, {
    INF_TCP_CONNECTION_CONNECTED,
    "INF_TCP_CONNECTION_CONNECTED",
    "connected"
  }, {
    INF_TCP_CONNECTION_CLOSED,
    "INF_TCP_CONNECTION_CLOSED",
    "closed"
  }, {
    0,
    NULL,
    NULL
  }
};
typedef struct _InfTcpConnectionPrivate InfTcpConnectionPrivate;
struct _InfTcpConnectionPrivate {
  InfIo* io;
  InfIoEvent events;
  InfIoWatch* watch;
  InfNameResolver* resolver;
  guint resolver_index;
  InfTcpConnectionStatus status;
  InfNativeSocket socket;
  InfKeepalive keepalive;
  InfIpAddress* remote_address;
  guint remote_port;
  unsigned int device_index;
  guint8* queue;
  gsize front_pos;
  gsize back_pos;
  gsize alloc;
};
enum {
  PROP_0,
  PROP_IO,
  PROP_RESOLVER,
  PROP_STATUS,
  PROP_KEEPALIVE,
  PROP_REMOTE_ADDRESS,
  PROP_REMOTE_PORT,
  PROP_LOCAL_ADDRESS,
  PROP_LOCAL_PORT,
  PROP_DEVICE_INDEX,
  PROP_DEVICE_NAME
};
enum {
  SENT,
  RECEIVED,
  ERROR_, 
  LAST_SIGNAL
};
#define INF_TCP_CONNECTION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_TCP_CONNECTION, InfTcpConnectionPrivate))
static guint tcp_connection_signals[LAST_SIGNAL];
INF_DEFINE_ENUM_TYPE(InfTcpConnectionStatus, inf_tcp_connection_status, inf_tcp_connection_status_values)
G_DEFINE_TYPE_WITH_CODE(InfTcpConnection, inf_tcp_connection, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfTcpConnection))
static gboolean
inf_tcp_connection_addr_info(InfNativeSocket socket,
                             gboolean local,
                             InfIpAddress** address,
                             guint* port,
                             GError** error)
{
  union {
    struct sockaddr in_generic;
    struct sockaddr_in in;
    struct sockaddr_in6 in6;
  } native_addr;
  socklen_t len;
  int res;
  int code;
  len = sizeof(native_addr);
  if(local == TRUE)
    res = getsockname(socket, &amp;native_addr.in_generic, &amp;len);
  else
    res = getpeername(socket, &amp;native_addr.in_generic, &amp;len);
  if(res == -1)
  {
    code = INF_NATIVE_SOCKET_LAST_ERROR;
    inf_native_socket_make_error(code, error);
    return FALSE;
  }
  switch(native_addr.in_generic.sa_family)
  {
  case AF_INET:
    if(address != NULL)
      *address = inf_ip_address_new_raw4(native_addr.in.sin_addr.s_addr);
    if(port != NULL)
      *port = ntohs(native_addr.in.sin_port);
    break;
  case AF_INET6:
    if(address != NULL)
      *address = inf_ip_address_new_raw6(native_addr.in6.sin6_addr.s6_addr);
    if(port != NULL)
      *port = ntohs(native_addr.in6.sin6_port);
    break;
  default:
    g_assert_not_reached();
    break;
  }
  return TRUE;
}
static gboolean
inf_tcp_connection_configure_socket(InfNativeSocket socket,
                                    const InfKeepalive* keepalive,
                                    GError** error)
{
#ifdef G_OS_WIN32
  u_long argp;
#else
  int result;
#endif
  int errcode;
  GError* local_error;
#ifndef G_OS_WIN32
  result = fcntl(socket, F_GETFL);
  if(result == INVALID_SOCKET)
  {
    errcode = INF_NATIVE_SOCKET_LAST_ERROR;
    inf_native_socket_make_error(errcode, error);
    return FALSE;
  }
  if(fcntl(socket, F_SETFL, result | O_NONBLOCK) == -1)
  {
    errcode = INF_NATIVE_SOCKET_LAST_ERROR;
    inf_native_socket_make_error(errcode, error);
    return FALSE;
  }
#else
  argp = 1;
  if(ioctlsocket(socket, FIONBIO, &amp;argp) != 0)
  {
    errcode = INF_NATIVE_SOCKET_LAST_ERROR;
    inf_native_socket_make_error(errcode, error);
    return FALSE;
  }
#endif
  local_error = NULL;
  if(inf_keepalive_apply(keepalive, &amp;socket, 0, &amp;local_error) == FALSE)
  {
    g_warning("Failed to set keepalive on socket: %s", local_error-&gt;message);
    g_error_free(local_error);
  }
  return TRUE;
}
static void
inf_tcp_connection_system_error(InfTcpConnection* connection,
                                int code)
{
  GError* error;
  error = NULL;
  inf_native_socket_make_error(code, &amp;error);
  g_signal_emit(
    G_OBJECT(connection),
    tcp_connection_signals[ERROR_],
    0,
    error
  );
  g_error_free(error);
}
static void
inf_tcp_connection_io(InfNativeSocket* socket,
                      InfIoEvent events,
                      gpointer user_data);
static void
inf_tcp_connection_connected(InfTcpConnection* connection)
{
  InfTcpConnectionPrivate* priv;
  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  priv-&gt;status = INF_TCP_CONNECTION_CONNECTED;
  priv-&gt;front_pos = 0;
  priv-&gt;back_pos = 0;
  priv-&gt;events = INF_IO_INCOMING | INF_IO_ERROR;
  if(priv-&gt;watch == NULL)
  {
    priv-&gt;watch = inf_io_add_watch(
      priv-&gt;io,
      &amp;priv-&gt;socket,
      priv-&gt;events,
      inf_tcp_connection_io,
      connection,
      NULL
    );
  }
  else
  {
    inf_io_update_watch(priv-&gt;io, priv-&gt;watch, priv-&gt;events);
  }
  g_object_freeze_notify(G_OBJECT(connection));
  if(priv-&gt;resolver != NULL)
  {
    if(priv-&gt;remote_address != NULL)
      inf_ip_address_free(priv-&gt;remote_address);
    priv-&gt;remote_address = inf_ip_address_copy(
      inf_name_resolver_get_address(priv-&gt;resolver, priv-&gt;resolver_index)
    );
    priv-&gt;remote_port =
      inf_name_resolver_get_port(priv-&gt;resolver, priv-&gt;resolver_index);
    g_object_notify(G_OBJECT(connection), "remote-address");
    g_object_notify(G_OBJECT(connection), "remote-port");
    priv-&gt;resolver_index = 0;
  }
  g_object_notify(G_OBJECT(connection), "status");
  g_object_notify(G_OBJECT(connection), "local-address");
  g_object_notify(G_OBJECT(connection), "local-port");
  g_object_thaw_notify(G_OBJECT(connection));
}
static gboolean
inf_tcp_connection_open_with_resolver(InfTcpConnection* connection,
                                      GError** error);
static gboolean
inf_tcp_connection_connection_error(InfTcpConnection* connection,
                                    const GError* error)
{
  InfTcpConnectionPrivate* priv;
  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  if(priv-&gt;socket != INVALID_SOCKET)
  {
    closesocket(priv-&gt;socket);
    priv-&gt;socket = INVALID_SOCKET;
  }
  if(priv-&gt;watch != NULL)
  {
    priv-&gt;events = 0;
    inf_io_remove_watch(priv-&gt;io, priv-&gt;watch);
    priv-&gt;watch = NULL;
  }
  if(priv-&gt;resolver != NULL)
  {
    if(priv-&gt;resolver_index &lt;
       inf_name_resolver_get_n_addresses(priv-&gt;resolver))
    {
      ++priv-&gt;resolver_index;
      if(inf_tcp_connection_open_with_resolver(connection, NULL) == TRUE)
        return TRUE;
    }
    priv-&gt;resolver_index = 0;
  }
  g_signal_emit(
    G_OBJECT(connection),
    tcp_connection_signals[ERROR_],
    0,
    error
  );
  return FALSE;
}
static gboolean
inf_tcp_connection_open_real(InfTcpConnection* connection,
                             const InfIpAddress* address,
                             guint port,
                             GError** error)
{
  InfTcpConnectionPrivate* priv;
  union {
    struct sockaddr_in in;
    struct sockaddr_in6 in6;
  } native_address;
  struct sockaddr* addr;
  socklen_t addrlen;
  int result;
  int errcode;
  const InfKeepalive* keepalive;
  GError* local_error;
  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED ||
           priv-&gt;status == INF_TCP_CONNECTION_CONNECTING);
  if(priv-&gt;socket != INVALID_SOCKET)
    closesocket(priv-&gt;socket);
  switch(inf_ip_address_get_family(address))
  {
  case INF_IP_ADDRESS_IPV4:
    priv-&gt;socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
    addr = (struct sockaddr*)&amp;native_address.in;
    addrlen = sizeof(struct sockaddr_in);
    memcpy(
      &amp;native_address.in.sin_addr,
      inf_ip_address_get_raw(address),
      sizeof(struct in_addr)
    );
    native_address.in.sin_family = AF_INET;
    native_address.in.sin_port = htons(port);
    break;
  case INF_IP_ADDRESS_IPV6:
    priv-&gt;socket = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP);
    addr = (struct sockaddr*)&amp;native_address.in6;
    addrlen = sizeof(struct sockaddr_in6);
    memcpy(
      &amp;native_address.in6.sin6_addr,
      inf_ip_address_get_raw(address),
      sizeof(struct in6_addr)
    );
    native_address.in6.sin6_family = AF_INET6;
    native_address.in6.sin6_port = htons(port);
    native_address.in6.sin6_flowinfo = 0;
    native_address.in6.sin6_scope_id = priv-&gt;device_index;
    break;
  default:
    g_assert_not_reached();
    break;
  }
  if(priv-&gt;socket == INVALID_SOCKET)
  {
    inf_native_socket_make_error(INF_NATIVE_SOCKET_LAST_ERROR, error);
    return FALSE;
  }
  keepalive = &amp;priv-&gt;keepalive;
  if(!inf_tcp_connection_configure_socket(priv-&gt;socket, keepalive, error))
  {
    closesocket(priv-&gt;socket);
    priv-&gt;socket = INVALID_SOCKET;
    return FALSE;
  }
  do
  {
    result = connect(priv-&gt;socket, addr, addrlen);
    errcode = INF_NATIVE_SOCKET_LAST_ERROR;
    if(result == -1 &amp;&amp;
       errcode != INF_NATIVE_SOCKET_EINTR &amp;&amp;
       errcode != INF_NATIVE_SOCKET_EINPROGRESS)
    {
      local_error = NULL;
      inf_native_socket_make_error(errcode, &amp;local_error);
      if(inf_tcp_connection_connection_error(connection, local_error) == TRUE)
      {
        g_error_free(local_error);
        return TRUE;
      }
      g_propagate_error(error, local_error);
      return FALSE;
    }
  } while(result == -1 &amp;&amp; errcode != INF_NATIVE_SOCKET_EINPROGRESS);
  if(result == 0)
  {
    inf_tcp_connection_connected(connection);
  }
  else
  {
    g_assert(priv-&gt;watch == NULL);
    priv-&gt;events = INF_IO_OUTGOING | INF_IO_ERROR;
    priv-&gt;watch = inf_io_add_watch(
      priv-&gt;io,
      &amp;priv-&gt;socket,
      priv-&gt;events,
      inf_tcp_connection_io,
      connection,
      NULL
    );
    if(priv-&gt;status != INF_TCP_CONNECTION_CONNECTING)
    {
      priv-&gt;status = INF_TCP_CONNECTION_CONNECTING;
      g_object_notify(G_OBJECT(connection), "status");
    }
  }
  return TRUE;
}
static gboolean
inf_tcp_connection_open_with_resolver(InfTcpConnection* connection,
                                      GError** error)
{
  InfTcpConnectionPrivate* priv;
  GError* local_error;
  gboolean success;
  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED ||
           priv-&gt;status == INF_TCP_CONNECTION_CONNECTING);
  if(inf_name_resolver_finished(priv-&gt;resolver))
  {
    if(priv-&gt;resolver_index &lt; 
       inf_name_resolver_get_n_addresses(priv-&gt;resolver))
    {
      return inf_tcp_connection_open_real(
        connection,
        inf_name_resolver_get_address(priv-&gt;resolver, priv-&gt;resolver_index),
        inf_name_resolver_get_port(priv-&gt;resolver, priv-&gt;resolver_index),
        error
      );
    }
    g_object_freeze_notify(G_OBJECT(connection));
    if(priv-&gt;status != INF_TCP_CONNECTION_CONNECTING)
    {
      priv-&gt;status = INF_TCP_CONNECTION_CONNECTING;
      g_object_notify(G_OBJECT(connection), "status");
    }
    local_error = NULL;
    if(priv-&gt;resolver_index == 0)
      success = inf_name_resolver_start(priv-&gt;resolver, &amp;local_error);
    else
      success = inf_name_resolver_lookup_backup(priv-&gt;resolver, &amp;local_error);
    if(local_error != NULL)
    {
      inf_tcp_connection_connection_error(connection, local_error);
      g_propagate_error(error, local_error);
    }
    g_object_thaw_notify(G_OBJECT(connection));
    return success;
  }
  return TRUE;
}
static gboolean
inf_tcp_connection_send_real(InfTcpConnection* connection,
                             gconstpointer data,
                             guint* len)
{
  InfTcpConnectionPrivate* priv;
  gconstpointer send_data;
  guint send_len;
  int errcode;
  ssize_t result;
  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  g_assert(priv-&gt;status == INF_TCP_CONNECTION_CONNECTED);
  g_assert(data != NULL);
  g_assert(len != NULL);
  send_data = data;
  send_len = *len;
  do
  {
    result = send(
      priv-&gt;socket,
      send_data,
      send_len,
      INF_NATIVE_SOCKET_SENDRECV_FLAGS
    );
    errcode = INF_NATIVE_SOCKET_LAST_ERROR;
    if(result &lt; 0 &amp;&amp;
       errcode != INF_NATIVE_SOCKET_EINTR &amp;&amp;
       errcode != INF_NATIVE_SOCKET_EAGAIN)
    {
      inf_tcp_connection_system_error(connection, errcode);
      return FALSE;
    }
    else if(result == 0)
    {
      inf_tcp_connection_close(connection);
      return FALSE;
    }
    else if(result &gt; 0)
    {
      send_data = (const char*)send_data + result;
      send_len -= result;
    }
  } while( (send_len &gt; 0) &amp;&amp;
           (result &gt; 0 || errcode == INF_NATIVE_SOCKET_EINTR) &amp;&amp;
           (priv-&gt;socket != INVALID_SOCKET) );
  *len -= send_len;
  return TRUE;
}
static void
inf_tcp_connection_io_incoming(InfTcpConnection* connection)
{
  InfTcpConnectionPrivate* priv;
  gchar buf[2048];
  int errcode;
  ssize_t result;
  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  g_assert(priv-&gt;status == INF_TCP_CONNECTION_CONNECTED);
  do
  {
    result = recv(priv-&gt;socket, buf, 2048, INF_NATIVE_SOCKET_SENDRECV_FLAGS);
    errcode = INF_NATIVE_SOCKET_LAST_ERROR;
    if(result &lt; 0 &amp;&amp;
       errcode != INF_NATIVE_SOCKET_EINTR &amp;&amp;
       errcode != INF_NATIVE_SOCKET_EAGAIN)
    {
      inf_tcp_connection_system_error(connection, errcode);
    }
    else if(result == 0)
    {
      inf_tcp_connection_close(connection);
    }
    else if(result &gt; 0)
    {
      g_signal_emit(
        G_OBJECT(connection),
        tcp_connection_signals[RECEIVED],
        0,
        buf,
        (guint)result
      );
    }
  } while( ((result &gt; 0) ||
            (result &lt; 0 &amp;&amp; errcode == INF_NATIVE_SOCKET_EINTR)) &amp;&amp;
           (priv-&gt;status != INF_TCP_CONNECTION_CLOSED));
}
static void
inf_tcp_connection_io_outgoing(InfTcpConnection* connection)
{
  InfTcpConnectionPrivate* priv;
  socklen_t len;
  int errcode;
  gconstpointer data;
  guint data_len;
  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  switch(priv-&gt;status)
  {
  case INF_TCP_CONNECTION_CONNECTING:
    len = sizeof(int);
#ifdef G_OS_WIN32
    getsockopt(priv-&gt;socket, SOL_SOCKET, SO_ERROR, (char*)&amp;errcode, &amp;len);
#else
    getsockopt(priv-&gt;socket, SOL_SOCKET, SO_ERROR, &amp;errcode, &amp;len);
#endif
    if(errcode == 0)
    {
      inf_tcp_connection_connected(connection);
    }
    else
    {
      inf_tcp_connection_system_error(connection, errcode);
    }
    break;
  case INF_TCP_CONNECTION_CONNECTED:
    g_assert(priv-&gt;back_pos &lt; priv-&gt;front_pos);
    g_assert(priv-&gt;events &amp; INF_IO_OUTGOING);
    data = priv-&gt;queue + priv-&gt;back_pos;
    data_len = priv-&gt;front_pos - priv-&gt;back_pos;
    if(inf_tcp_connection_send_real(connection, data, &amp;data_len) == TRUE)
    {
      priv-&gt;back_pos += data_len;
      if(priv-&gt;front_pos == priv-&gt;back_pos)
      {
        priv-&gt;front_pos = 0;
        priv-&gt;back_pos = 0;
        priv-&gt;events &amp;= ~INF_IO_OUTGOING;
        inf_io_update_watch(priv-&gt;io, priv-&gt;watch, priv-&gt;events);
      }
      g_signal_emit(
        G_OBJECT(connection),
        tcp_connection_signals[SENT],
        0,
        data,
        data_len
      );
    }
    break;
  case INF_TCP_CONNECTION_CLOSED:
  default:
    g_assert_not_reached();
    break;
  }
}
static void
inf_tcp_connection_io(InfNativeSocket* socket,
                      InfIoEvent events,
                      gpointer user_data)
{
  InfTcpConnection* connection;
  InfTcpConnectionPrivate* priv;
  socklen_t len;
  int errcode;
  GError* error;
  connection = INF_TCP_CONNECTION(user_data);
  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  g_object_ref(G_OBJECT(connection));
  g_assert(priv-&gt;status != INF_TCP_CONNECTION_CLOSED);
  if(events &amp; INF_IO_ERROR)
  {
    len = sizeof(int);
#ifdef G_OS_WIN32
    getsockopt(priv-&gt;socket, SOL_SOCKET, SO_ERROR, (char*)&amp;errcode, &amp;len);
#else
    getsockopt(priv-&gt;socket, SOL_SOCKET, SO_ERROR, &amp;errcode, &amp;len);
#endif
    if(errcode != 0)
    {
      error = NULL;
      inf_native_socket_make_error(errcode, &amp;error);
      if(priv-&gt;status == INF_TCP_CONNECTION_CONNECTING)
      {
        inf_tcp_connection_connection_error(connection, error);
      }
      else
      {
        g_signal_emit(
          G_OBJECT(connection),
          tcp_connection_signals[ERROR_],
          0,
          error
        );
      }
      g_error_free(error);
    }
    else
    {
      inf_tcp_connection_close(connection);
    }
  }
  else
  {
    if(events &amp; INF_IO_INCOMING)
    {
      inf_tcp_connection_io_incoming(connection);
    }
    if((priv-&gt;status != INF_TCP_CONNECTION_CLOSED) &amp;&amp;
       (events &amp; INF_IO_OUTGOING))
    {
      inf_tcp_connection_io_outgoing(connection);
    }
  }
  g_object_unref(G_OBJECT(connection));
}
static void
inf_tcp_connection_resolved_cb(InfNameResolver* resolver,
                               const GError* error,
                               gpointer user_data)
{
  InfTcpConnection* connection;
  InfTcpConnectionPrivate* priv;
  connection = INF_TCP_CONNECTION(user_data);
  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  if(priv-&gt;status == INF_TCP_CONNECTION_CONNECTING)
  {
    if(error != NULL)
    {
      g_assert(
        priv-&gt;resolver_index == inf_name_resolver_get_n_addresses(resolver)
      );
      inf_tcp_connection_connection_error(connection, error);
    }
    else
    {
      inf_tcp_connection_open_with_resolver(connection, NULL);
    }
  }
}
static void
inf_tcp_connection_set_resolver(InfTcpConnection* connection,
                                InfNameResolver* resolver)
{
  InfTcpConnectionPrivate* priv;
  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  if(priv-&gt;resolver != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;resolver),
      G_CALLBACK(inf_tcp_connection_resolved_cb),
      connection
    );
    g_object_unref(priv-&gt;resolver);
  }
  priv-&gt;resolver = resolver;
  if(resolver != NULL)
  {
    g_object_ref(resolver);
    g_signal_connect(
      G_OBJECT(resolver),
      "resolved",
      G_CALLBACK(inf_tcp_connection_resolved_cb),
      connection
    );
  }
}
static void
inf_tcp_connection_init(InfTcpConnection* connection)
{
  InfTcpConnectionPrivate* priv;
  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  priv-&gt;io = NULL;
  priv-&gt;events = 0;
  priv-&gt;watch = NULL;
  priv-&gt;resolver = NULL;
  priv-&gt;resolver_index = 0;
  priv-&gt;status = INF_TCP_CONNECTION_CLOSED;
  priv-&gt;socket = INVALID_SOCKET;
  priv-&gt;keepalive.mask = 0;
  priv-&gt;remote_address = NULL;
  priv-&gt;remote_port = 0;
  priv-&gt;device_index = 0;
  priv-&gt;queue = g_malloc(1024);
<a name="0"></a>  priv-&gt;front_pos = 0;
  priv-&gt;back_pos = 0;
  priv-&gt;alloc = 1024;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
static void
inf_tcp_connection_dispose(GObject* object)
{
  InfTcpConnection* connection;
  InfTcpConnectionPrivate* priv;
  connection = INF_TCP_CONNECTION(object);
  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  if(priv-&gt;status != INF_TCP_CONNECTION_CLOSED)
    inf_tcp_connection_close(connection);
  inf_tcp_connection_set_resolver(connection, NULL);
  if(priv-&gt;io != NULL)
  {
    g_object_unref(priv-&gt;io);
    priv-&gt;io = NULL;
  }</b></font>
  G_OBJECT_CLASS(inf_tcp_connection_parent_class)-&gt;dispose(object);
}
static void
inf_tcp_connection_finalize(GObject* object)
{
  InfTcpConnection* connection;
  InfTcpConnectionPrivate* priv;
  connection = INF_TCP_CONNECTION(object);
  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  if(priv-&gt;remote_address != NULL)
    inf_ip_address_free(priv-&gt;remote_address);
  if(priv-&gt;socket != INVALID_SOCKET)
    closesocket(priv-&gt;socket);
  g_free(priv-&gt;queue);
  G_OBJECT_CLASS(inf_tcp_connection_parent_class)-&gt;finalize(object);
}
static void
inf_tcp_connection_set_property(GObject* object,
                                guint prop_id,
                                const GValue* value,
                                GParamSpec* pspec)
{
  InfTcpConnection* connection;
  InfTcpConnectionPrivate* priv;
#ifndef G_OS_WIN32
  const gchar* device_string;
  unsigned int new_index;
#endif
  GError* error;
  connection = INF_TCP_CONNECTION(object);
  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  switch(prop_id)
  {
  case PROP_IO:
    g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED);
    if(priv-&gt;io != NULL) g_object_unref(G_OBJECT(priv-&gt;io));
    priv-&gt;io = INF_IO(g_value_dup_object(value));
    break;
  case PROP_RESOLVER:
    g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED);
    inf_tcp_connection_set_resolver(
      connection,
      INF_NAME_RESOLVER(g_value_get_object(value))
    );
    break;
  case PROP_KEEPALIVE:
    error = NULL;
    inf_tcp_connection_set_keepalive(
      connection,
      (InfKeepalive*)g_value_get_boxed(value),
      &amp;error
    );
    if(error != NULL)
    {
      g_warning("Failed to set keepalive settings: %s\n", error-&gt;message);
      g_error_free(error);
    }
    break;
  case PROP_REMOTE_ADDRESS:
    g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED);
    if(priv-&gt;remote_address != NULL)
      inf_ip_address_free(priv-&gt;remote_address);
    priv-&gt;remote_address = (InfIpAddress*)g_value_dup_boxed(value);
    break;
  case PROP_REMOTE_PORT:
    g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED);
    priv-&gt;remote_port = g_value_get_uint(value);
    break;
  case PROP_DEVICE_INDEX:
    g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED);
    priv-&gt;device_index = g_value_get_uint(value);
    g_object_notify(G_OBJECT(object), "device-name");
    break;
  case PROP_DEVICE_NAME:
#ifdef G_OS_WIN32
    g_warning("The device-name property is not implemented on Win32");
#else
    g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED);
    device_string = g_value_get_string(value);
    if(device_string == NULL) priv-&gt;device_index = 0;
    new_index = if_nametoindex(device_string);
    if(new_index == 0)
    {
      g_warning(_("Interface `%s' does not exist"), device_string);
    }
    else
    {
      priv-&gt;device_index = new_index;
      g_object_notify(G_OBJECT(object), "device-index");
    }
#endif
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_tcp_connection_get_property(GObject* object,
                                guint prop_id,
                                GValue* value,
                                GParamSpec* pspec)
{
  InfTcpConnection* connection;
  InfTcpConnectionPrivate* priv;
  InfIpAddress* address;
  guint port;
  GError* error;
#ifndef G_OS_WIN32
  char device_name[IF_NAMESIZE];
#endif
  connection = INF_TCP_CONNECTION(object);
  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  switch(prop_id)
<a name="2"></a>  {
  case PROP_IO:
    g_value_set_object(value, G_OBJECT(priv-&gt;io));
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
  case PROP_RESOLVER:
    g_value_set_object(value, G_OBJECT(priv-&gt;resolver));
    break;
  case PROP_KEEPALIVE:
    g_value_set_boxed(value, &amp;priv-&gt;keepalive);
    break;
  case PROP_STATUS:
    g_value_set_enum(value, priv-&gt;status);
    break;
  case PROP_REMOTE_ADDRESS:
    g_value_set_static_boxed(value, priv-&gt;remote_address);
    break;
  case PROP_REMOTE_PORT:
    g_value_set_uint(value, priv-&gt;remote_port);
    break;
  case PROP_LOCAL_ADDRESS:</b></font>
    g_assert(priv-&gt;socket != INVALID_SOCKET);
    error = NULL;
    inf_tcp_connection_addr_info(priv-&gt;socket, TRUE, &amp;address, NULL, &amp;error);
    if(error != NULL)
    {
      g_warning(_("Failed to retrieve local address: %s"), error-&gt;message);
      g_error_free(error);
      g_value_set_boxed(value, NULL);
    }
    else
    {
      g_value_take_boxed(value, address);
    }
    break;
  case PROP_LOCAL_PORT:
    g_assert(priv-&gt;socket != INVALID_SOCKET);
    error = NULL;
    inf_tcp_connection_addr_info(priv-&gt;socket, TRUE, NULL, &amp;port, &amp;error);
    if(error != NULL)
    {
      g_warning(_("Failed to retrieve local port: %s"), error-&gt;message);
      g_error_free(error);
      g_value_set_uint(value, 0);
    }
    else
    {
      g_value_set_uint(value, port);
    }
    break;
  case PROP_DEVICE_INDEX:
    g_value_set_uint(value, priv-&gt;device_index);
    break;
  case PROP_DEVICE_NAME:
#ifdef G_OS_WIN32
    g_warning(_("The device-name property is not implemented on Win32"));
    g_value_set_string(value, NULL);
#else
    if(priv-&gt;device_index == 0)
    {
      g_value_set_string(value, NULL);
    }
    else
    {
      if(if_indextoname(priv-&gt;device_index, device_name) == NULL)
      {
        g_warning(
          _("Failed to get name for device %u: %s"),
          priv-&gt;device_index,
          strerror(errno)
        );
        g_value_set_string(value, NULL);
      }
      else
      {
        g_value_set_string(value, device_name);
      }
    }
#endif
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_tcp_connection_error(InfTcpConnection* connection,
                         GError* error)
{
  InfTcpConnectionPrivate* priv;
  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  if(priv-&gt;watch != NULL)
  {
    priv-&gt;events = 0;
    inf_io_remove_watch(priv-&gt;io, priv-&gt;watch);
    priv-&gt;watch = NULL;
  }
  if(priv-&gt;status != INF_TCP_CONNECTION_CLOSED)
<a name="1"></a>  {
    priv-&gt;status = INF_TCP_CONNECTION_CLOSED;
    g_object_notify(G_OBJECT(connection), "status");
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  }
}
static void
inf_tcp_connection_class_init(InfTcpConnectionClass* tcp_connection_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(tcp_connection_class);
  object_class-&gt;dispose = inf_tcp_connection_dispose;
  object_class-&gt;finalize = inf_tcp_connection_finalize;
  object_class-&gt;set_property = inf_tcp_connection_set_property;
  object_class-&gt;get_property = inf_tcp_connection_get_property;
  tcp_connection_class-&gt;sent = NULL;</b></font>
  tcp_connection_class-&gt;received = NULL;
  tcp_connection_class-&gt;error = inf_tcp_connection_error;
  g_object_class_install_property(
    object_class,
    PROP_IO,
    g_param_spec_object(
      "io",
      "IO",
      "I/O handler",
      INF_TYPE_IO,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_RESOLVER,
    g_param_spec_object(
      "resolver",
      "Resolver",
      "The hostname resolver",
      INF_TYPE_NAME_RESOLVER,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_STATUS,
    g_param_spec_enum(
      "status",
      "Status",
      "Status of the TCP connection",
      INF_TYPE_TCP_CONNECTION_STATUS,
      INF_TCP_CONNECTION_CLOSED,
      G_PARAM_READABLE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_KEEPALIVE,
    g_param_spec_boxed(
      "keepalive",
      "Keepalive",
      "The keepalive settings for the connection",
      INF_TYPE_KEEPALIVE,
      G_PARAM_READWRITE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_REMOTE_ADDRESS,
    g_param_spec_boxed(
      "remote-address",
      "Remote address",
      "Address to connect to",
      INF_TYPE_IP_ADDRESS,
      G_PARAM_READWRITE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_REMOTE_PORT,
    g_param_spec_uint(
      "remote-port",
      "Remote port",
      "Port to connect to",
      0,
      65535,
      0,
      G_PARAM_READWRITE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_LOCAL_ADDRESS,
    g_param_spec_boxed(
      "local-address",
      "Local address",
      "The local address of the connection",
      INF_TYPE_IP_ADDRESS,
      G_PARAM_READABLE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_LOCAL_PORT,
    g_param_spec_uint(
      "local-port",
      "Local port",
      "The local port of the connection",
      0,
      65535,
      0,
      G_PARAM_READABLE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_DEVICE_INDEX,
    g_param_spec_uint(
      "device-index",
      "Device index",
      "The index of the device to use for the connection",
      0,
      G_MAXUINT,
      0,
      G_PARAM_READWRITE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_DEVICE_NAME,
    g_param_spec_string(
      "device-name",
      "Device name",
      "The name of the device to use for the connection, such as `eth0'",
      NULL,
      G_PARAM_READWRITE
    )
  );
  tcp_connection_signals[SENT] = g_signal_new(
    "sent",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfTcpConnectionClass, sent),
    NULL, NULL,
    NULL,
    G_TYPE_NONE,
    2,
    G_TYPE_POINTER,
    G_TYPE_UINT
  );
  tcp_connection_signals[RECEIVED] = g_signal_new(
    "received",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfTcpConnectionClass, received),
    NULL, NULL,
    NULL,
    G_TYPE_NONE,
    2,
    G_TYPE_POINTER,
    G_TYPE_UINT
  );
  tcp_connection_signals[ERROR_] = g_signal_new(
    "error",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfTcpConnectionClass, error),
    NULL, NULL,
    g_cclosure_marshal_VOID__POINTER,
    G_TYPE_NONE,
    1,
    G_TYPE_ERROR
  );
}
InfTcpConnection*
inf_tcp_connection_new(InfIo* io,
                       const InfIpAddress* remote_addr,
                       guint remote_port)
{
  InfTcpConnection* tcp;
  g_return_val_if_fail(INF_IS_IO(io), NULL);
  g_return_val_if_fail(remote_addr != NULL, NULL);
  g_return_val_if_fail(remote_port &lt;= 65535, NULL);
  tcp = INF_TCP_CONNECTION(
    g_object_new(
      INF_TYPE_TCP_CONNECTION,
      "io", io,
      "remote-address", remote_addr,
      "remote-port", remote_port,
      NULL
    )
  );
  return tcp;
}
InfTcpConnection*
inf_tcp_connection_new_and_open(InfIo* io,
                                const InfIpAddress* remote_addr,
                                guint remote_port,
                                GError** error)
{
  InfTcpConnection* tcp;
  g_return_val_if_fail(INF_IS_IO(io), NULL);
  g_return_val_if_fail(remote_addr != NULL, NULL);
  g_return_val_if_fail(remote_port &lt;= 65535, NULL);
  g_return_val_if_fail(error == NULL || *error == NULL, NULL);
  tcp = inf_tcp_connection_new(io, remote_addr, remote_port);
  if(inf_tcp_connection_open(tcp, error) == FALSE)
  {
    g_object_unref(tcp);
    return NULL;
  }
  return tcp;
}
InfTcpConnection*
inf_tcp_connection_new_resolve(InfIo* io,
                               InfNameResolver* resolver)
{
  InfTcpConnection* tcp;
  g_return_val_if_fail(INF_IS_IO(io), NULL);
  g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), NULL);
  tcp = INF_TCP_CONNECTION(
    g_object_new(
      INF_TYPE_TCP_CONNECTION,
      "io", io,
      "resolver", resolver,
      NULL
    )
  );
  return tcp;
}
gboolean
inf_tcp_connection_open(InfTcpConnection* connection,
                        GError** error)
{
  InfTcpConnectionPrivate* priv;
  g_return_val_if_fail(INF_IS_TCP_CONNECTION(connection), FALSE);
  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  g_return_val_if_fail(priv-&gt;io != NULL, FALSE);
  g_return_val_if_fail(priv-&gt;status == INF_TCP_CONNECTION_CLOSED, FALSE);
  g_return_val_if_fail(
    priv-&gt;remote_address != NULL || priv-&gt;resolver != NULL,
    FALSE
  );
  g_return_val_if_fail(
    priv-&gt;remote_port != 0 ||
    priv-&gt;resolver != NULL,
    FALSE
  );
  if(priv-&gt;resolver != NULL)
  {
    g_assert(priv-&gt;resolver_index == 0);
    return inf_tcp_connection_open_with_resolver(connection, error);
  }
  else
  {
    return inf_tcp_connection_open_real(
      connection,
      priv-&gt;remote_address,
      priv-&gt;remote_port,
      error
    );
  }
}
void
inf_tcp_connection_close(InfTcpConnection* connection)
{
  InfTcpConnectionPrivate* priv;
  g_return_if_fail(INF_IS_TCP_CONNECTION(connection));
  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  g_return_if_fail(priv-&gt;status != INF_TCP_CONNECTION_CLOSED);
  priv-&gt;events = 0;
  if(priv-&gt;watch != NULL)
  {
    inf_io_remove_watch(priv-&gt;io, priv-&gt;watch);
    priv-&gt;watch = NULL;
  }
  priv-&gt;front_pos = 0;
  priv-&gt;back_pos = 0;
  priv-&gt;status = INF_TCP_CONNECTION_CLOSED;
  g_object_notify(G_OBJECT(connection), "status");
}
void
inf_tcp_connection_send(InfTcpConnection* connection,
                        gconstpointer data,
                        guint len)
{
  InfTcpConnectionPrivate* priv;
  gconstpointer sent_data;
  guint sent_len;
  g_return_if_fail(INF_IS_TCP_CONNECTION(connection));
  g_return_if_fail(len == 0 || data != NULL);
  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  g_return_if_fail(priv-&gt;status == INF_TCP_CONNECTION_CONNECTED);
  g_object_ref(connection);
  if(priv-&gt;front_pos == priv-&gt;back_pos)
  {
    g_assert(~priv-&gt;events &amp; INF_IO_OUTGOING);
    sent_len = len;
    sent_data = data;
    if(inf_tcp_connection_send_real(connection, data, &amp;sent_len) == TRUE)
    {
      data = (const char*)data + sent_len;
      len -= sent_len;
    }
    else
    {
      len = 0;
      sent_len = 0;
    }
  }
  else
  {
    sent_len = 0;
  }
  if(len &gt; 0)
  {
    if(priv-&gt;alloc - priv-&gt;front_pos &lt; len &amp;&amp; priv-&gt;back_pos &gt; 0)
    {
      memmove(
        priv-&gt;queue,
        priv-&gt;queue + priv-&gt;back_pos,
        priv-&gt;front_pos - priv-&gt;back_pos
      );
      priv-&gt;front_pos -= priv-&gt;back_pos;
      priv-&gt;back_pos = 0;
    }
    if(priv-&gt;alloc - priv-&gt;front_pos &lt; len)
    {
      priv-&gt;alloc = priv-&gt;front_pos + len;
      if(priv-&gt;alloc % 1024 != 0)
        priv-&gt;alloc = priv-&gt;alloc + (1024 - priv-&gt;alloc % 1024);
      priv-&gt;queue = g_realloc(priv-&gt;queue, priv-&gt;alloc);
    }
    memcpy(priv-&gt;queue + priv-&gt;front_pos, data, len);
    priv-&gt;front_pos += len;
    if(~priv-&gt;events &amp; INF_IO_OUTGOING)
    {
      priv-&gt;events |= INF_IO_OUTGOING;
      inf_io_update_watch(priv-&gt;io, priv-&gt;watch, priv-&gt;events);
    }
  }
  if(sent_len &gt; 0)
  {
    g_signal_emit(
      G_OBJECT(connection),
      tcp_connection_signals[SENT],
      0,
      sent_data,
      sent_len
    );
  }
  g_object_unref(connection);
}
InfIpAddress*
inf_tcp_connection_get_remote_address(InfTcpConnection* connection)
{
  g_return_val_if_fail(INF_IS_TCP_CONNECTION(connection), NULL);
  return INF_TCP_CONNECTION_PRIVATE(connection)-&gt;remote_address;
}
guint
inf_tcp_connection_get_remote_port(InfTcpConnection* connection)
{
  g_return_val_if_fail(INF_IS_TCP_CONNECTION(connection), 0);
  return INF_TCP_CONNECTION_PRIVATE(connection)-&gt;remote_port;
}
gboolean
inf_tcp_connection_set_keepalive(InfTcpConnection* connection,
                                 const InfKeepalive* keepalive,
                                 GError** error)
{
  InfTcpConnectionPrivate* priv;
  InfKeepaliveMask mask;
  g_return_val_if_fail(INF_IS_TCP_CONNECTION(connection), FALSE);
  g_return_val_if_fail(keepalive != NULL, FALSE);
  g_return_val_if_fail(error == NULL || *error == NULL, FALSE);
  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  if(priv-&gt;socket != INVALID_SOCKET)
  {
    mask = priv-&gt;keepalive.mask;
    if(inf_keepalive_apply(keepalive, &amp;priv-&gt;socket, mask, error) != TRUE)
      return FALSE;
  }
  priv-&gt;keepalive = *keepalive;
  return TRUE;
}
const InfKeepalive*
inf_tcp_connection_get_keepalive(InfTcpConnection* connection)
{
  g_return_val_if_fail(INF_IS_TCP_CONNECTION(connection), NULL);
  return &amp;INF_TCP_CONNECTION_PRIVATE(connection)-&gt;keepalive;
}
InfTcpConnection*
_inf_tcp_connection_accepted(InfIo* io,
                             InfNativeSocket socket,
                             InfIpAddress* address,
                             guint port,
                             const InfKeepalive* keepalive,
                             GError** error)
{
  InfTcpConnection* connection;
  InfTcpConnectionPrivate* priv;
  int errcode;
  g_return_val_if_fail(INF_IS_IO(io), NULL);
  g_return_val_if_fail(socket != INVALID_SOCKET, NULL);
  g_return_val_if_fail(address != NULL, NULL);
  g_return_val_if_fail(keepalive != NULL, NULL);
  if(inf_tcp_connection_configure_socket(socket, keepalive, error) != TRUE)
    return NULL;
  g_return_val_if_fail(address != NULL, NULL);
  g_return_val_if_fail(port != 0, NULL);
  connection = inf_tcp_connection_new(io, address, port);
  inf_ip_address_free(address);
  priv = INF_TCP_CONNECTION_PRIVATE(connection);
  priv-&gt;socket = socket;
  priv-&gt;keepalive = *keepalive;
  inf_tcp_connection_connected(connection);
  return connection;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
