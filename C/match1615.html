<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for infd-xmpp-server.c &amp; inf-tcp-connection.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for infd-xmpp-server.c &amp; inf-tcp-connection.c
      </h3>
<h1 align="center">
        6.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>infd-xmpp-server.c (12.418301%)<th>inf-tcp-connection.c (4.634146%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(361-381)<td><a href="#" name="0">(917-937)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(542-556)<td><a href="#" name="1">(1189-1203)</a><td align="center"><font color="#da0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(499-515)<td><a href="#" name="2">(1076-1092)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>infd-xmpp-server.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/server/infd-xmpp-server.h&gt;
2 #include &lt;libinfinity/server/infd-tcp-server.h&gt;
3 #include &lt;libinfinity/server/infd-xml-server.h&gt;
4 #include &lt;libinfinity/common/inf-xmpp-connection.h&gt;
5 #include &lt;libinfinity/inf-signals.h&gt;
6 #ifdef G_OS_WIN32
7 # ifdef ERROR
8 #  undef ERROR
9 # endif
10 #endif
11 typedef enum InfdXmppServerStatus_ {
12   INFD_XMPP_SERVER_CLOSED,
13   INFD_XMPP_SERVER_OPEN
14 } InfdXmppServerStatus;
15 typedef struct _InfdXmppServerPrivate InfdXmppServerPrivate;
16 struct _InfdXmppServerPrivate {
17   InfdTcpServer* tcp;
18   InfdXmppServerStatus status;
19   gchar* local_hostname;
20   InfXmppConnectionSecurityPolicy security_policy;
21   InfCertificateCredentials* tls_creds;
22   InfSaslContext* sasl_context;
23   InfSaslContext* sasl_own_context;
24   gchar* sasl_mechanisms;
25 };
26 enum {
27   PROP_0,
28   PROP_TCP,
29   PROP_LOCAL_HOSTNAME,
30   PROP_CREDENTIALS,
31   PROP_SASL_CONTEXT,
32   PROP_SASL_MECHANISMS,
33   PROP_SECURITY_POLICY,
34   PROP_STATUS
35 };
36 enum {
37   ERROR,
38   LAST_SIGNAL
39 };
40 #define INFD_XMPP_SERVER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFD_TYPE_XMPP_SERVER, InfdXmppServerPrivate))
41 static guint xmpp_server_signals[LAST_SIGNAL];
42 static void infd_xmpp_server_xml_server_iface_init(InfdXmlServerInterface* iface);
43 G_DEFINE_TYPE_WITH_CODE(InfdXmppServer, infd_xmpp_server, G_TYPE_OBJECT,
44   G_ADD_PRIVATE(InfdXmppServer)
45   G_IMPLEMENT_INTERFACE(INFD_TYPE_XML_SERVER, infd_xmpp_server_xml_server_iface_init))
46 static void
47 infd_xmpp_server_new_connection_cb(InfdTcpServer* tcp_server,
48                                    InfTcpConnection* tcp_connection,
49                                    gpointer user_data)
50 {
51   InfdXmppServer* xmpp_server;
52   InfdXmppServerPrivate* priv;
53   InfXmppConnection* xmpp_connection;
54   InfIpAddress* addr;
55   gchar* addr_str;
56   xmpp_server = INFD_XMPP_SERVER(user_data);
57   priv = INFD_XMPP_SERVER_PRIVATE(xmpp_server);
58   g_object_get(G_OBJECT(tcp_connection), "remote-address", &amp;addr, NULL);
59   addr_str = inf_ip_address_to_string(addr);
60   inf_ip_address_free(addr);
61   xmpp_connection = inf_xmpp_connection_new(
62     tcp_connection,
63     INF_XMPP_CONNECTION_SERVER,
64     priv-&gt;local_hostname,
65     addr_str,
66     priv-&gt;security_policy,
67     priv-&gt;tls_creds,
68     priv-&gt;sasl_context,
69     priv-&gt;sasl_own_context != NULL ? "ANONYMOUS" : priv-&gt;sasl_mechanisms
70   );
71   g_free(addr_str);
72   infd_xml_server_new_connection(
73     INFD_XML_SERVER(xmpp_server),
74     INF_XML_CONNECTION(xmpp_connection)
75   );
76   g_object_unref(G_OBJECT(xmpp_connection));
77 }
78 static void
79 infd_xmpp_server_error_cb(InfdTcpServer* tcp_server,
80                           GError* error,
81                           gpointer user_data)
82 {
83   g_signal_emit(
84     G_OBJECT(user_data),
85     xmpp_server_signals[ERROR],
86     0,
87     error
88   );
89 }
90 static void
91 infd_xmpp_server_notify_status_cb(InfdTcpServer* tcp_server,
92                                   GParamSpec* pspec,
93                                   gpointer user_data)
94 {
95   InfdXmppServer* xmpp;
96   InfdXmppServerPrivate* priv;
97   InfdTcpServerStatus status;
98   xmpp = INFD_XMPP_SERVER(user_data);
99   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
100   g_object_get(G_OBJECT(tcp_server), "status", &amp;status, NULL);
101   switch(status)
102   {
103   case INFD_TCP_SERVER_CLOSED:
104   case INFD_TCP_SERVER_BOUND:
105     if(priv-&gt;status != INFD_XMPP_SERVER_CLOSED)
106     {
107       priv-&gt;status = INFD_XMPP_SERVER_CLOSED;
108       g_object_notify(G_OBJECT(xmpp), "status");
109     }
110     break;
111   case INFD_TCP_SERVER_OPEN:
112     if(priv-&gt;status != INFD_XMPP_SERVER_OPEN)
113     {
114       priv-&gt;status = INFD_XMPP_SERVER_OPEN;
115       g_object_notify(G_OBJECT(xmpp), "status");
116     }
117     break;
118   default:
119     g_assert_not_reached();
120     break;
121   }
122 }
123 static void
124 infd_xmpp_server_sasl_cb(InfSaslContextSession* session,
125                          Gsasl_property property,
126                          gpointer session_data,
127                          gpointer user_data)
128 {
129   InfdXmppServer* xmpp;
130   InfdXmppServerPrivate* priv;
131   xmpp = INFD_XMPP_SERVER(user_data);
132   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
133   switch(property)
134   {
135   case GSASL_ANONYMOUS_TOKEN:
136     inf_sasl_context_session_set_property(
137       session,
138       GSASL_ANONYMOUS_TOKEN,
139       priv-&gt;local_hostname
140     );
141     inf_sasl_context_session_continue(session, GSASL_OK);
142     break;
143   case GSASL_VALIDATE_ANONYMOUS:
144     inf_sasl_context_session_continue(session, GSASL_OK);
145     break;
146   default:
147     g_assert_not_reached();
148     inf_sasl_context_session_continue(session, GSASL_NO_CALLBACK);
149     break;
150   }
151 }
152 static void
153 infd_xmpp_server_setup_own_sasl_context(InfdXmppServer* xmpp)
154 {
155   InfdXmppServerPrivate* priv;
156   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
157   g_assert(priv-&gt;sasl_own_context == NULL);
158   if(priv-&gt;sasl_context == NULL &amp;&amp; priv-&gt;tcp != NULL)
159   {
160     priv-&gt;sasl_own_context = inf_sasl_context_new(NULL);
161     if(priv-&gt;sasl_own_context != NULL)
162     {
163       priv-&gt;sasl_context = priv-&gt;sasl_own_context;
164       inf_sasl_context_ref(priv-&gt;sasl_context);
165       inf_sasl_context_set_callback(
166         priv-&gt;sasl_context,
167         infd_xmpp_server_sasl_cb,
168         xmpp,
169         NULL
170       );
171       g_object_notify(G_OBJECT(xmpp), "sasl-context");
172     }
173   }
174 }
175 static void
176 infd_xmpp_server_set_tcp(InfdXmppServer* xmpp,
177                          InfdTcpServer* tcp)
178 {
179   InfdXmppServerPrivate* priv;
180   InfdTcpServerStatus tcp_status;
181   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
182   g_object_freeze_notify(G_OBJECT(xmpp));
183   if(priv-&gt;tcp != NULL)
184   {
185     g_object_get(G_OBJECT(priv-&gt;tcp), "status", &amp;tcp_status, NULL);
186     if(tcp_status != INFD_TCP_SERVER_CLOSED)
187       infd_tcp_server_close(priv-&gt;tcp);
188     if(priv-&gt;sasl_own_context != NULL)
189     {
190       inf_sasl_context_unref(priv-&gt;sasl_own_context);
191       priv-&gt;sasl_own_context = NULL;
192     }
193     inf_signal_handlers_disconnect_by_func(
194       G_OBJECT(priv-&gt;tcp),
195       G_CALLBACK(infd_xmpp_server_new_connection_cb),
196       xmpp
197     );
198     inf_signal_handlers_disconnect_by_func(
199       G_OBJECT(priv-&gt;tcp),
200       G_CALLBACK(infd_xmpp_server_error_cb),
201       xmpp
202     );
203     inf_signal_handlers_disconnect_by_func(
204       G_OBJECT(priv-&gt;tcp),
205       G_CALLBACK(infd_xmpp_server_notify_status_cb),
206       xmpp
207     );
208     g_object_unref(G_OBJECT(priv-&gt;tcp));
209   }
210   priv-&gt;tcp = tcp;
211   if(tcp != NULL)
212   {
213     g_object_ref(G_OBJECT(tcp));
214     g_signal_connect(
215       G_OBJECT(tcp),
216       "new-connection",
217       G_CALLBACK(infd_xmpp_server_new_connection_cb),
218       xmpp
219     );
220     g_signal_connect(
221       G_OBJECT(tcp),
222       "error",
223       G_CALLBACK(infd_xmpp_server_error_cb),
224       xmpp
225     );
226     g_signal_connect(
227       G_OBJECT(tcp),
228       "notify::status",
229       G_CALLBACK(infd_xmpp_server_notify_status_cb),
230       xmpp
231     );
232     g_object_get(G_OBJECT(tcp), "status", &amp;tcp_status, NULL);
233     switch(tcp_status)
234     {
235     case INFD_TCP_SERVER_CLOSED:
236     case INFD_TCP_SERVER_BOUND:
237       g_assert(priv-&gt;status == INFD_XMPP_SERVER_CLOSED);
238       break;
239     case INFD_TCP_SERVER_OPEN:
240       priv-&gt;status = INFD_XMPP_SERVER_OPEN;
241       g_object_notify(G_OBJECT(xmpp), "status");
242       break;
243     default:
244       g_assert_not_reached();
245       break;
246     }
247   }
248   infd_xmpp_server_setup_own_sasl_context(xmpp);
249   g_object_thaw_notify(G_OBJECT(xmpp));
250 }
251 static void
252 infd_xmpp_server_init(InfdXmppServer* xmpp)
253 {
254   InfdXmppServerPrivate* priv;
255   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
256   priv-&gt;tcp = NULL;
257   priv-&gt;status = INFD_XMPP_SERVER_CLOSED;
258   priv-&gt;local_hostname = g_strdup(g_get_host_name());
259   priv-&gt;security_policy = INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED;
260   priv-&gt;tls_creds = NULL;
261 <a name="0"></a>  priv-&gt;sasl_context = NULL;
262   priv-&gt;sasl_own_context = NULL;
263   priv-&gt;sasl_mechanisms = NULL;
264 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
265 static void
266 infd_xmpp_server_dispose(GObject* object)
267 {
268   InfdXmppServer* xmpp;
269   InfdXmppServerPrivate* priv;
270   xmpp = INFD_XMPP_SERVER(object);
271   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
272   if(priv-&gt;status != INFD_XMPP_SERVER_CLOSED)
273     infd_xml_server_close(INFD_XML_SERVER(xmpp));
274   infd_xmpp_server_set_tcp(xmpp, NULL);
275   if(priv-&gt;sasl_own_context != NULL)
276   {
277     inf_sasl_context_unref(priv-&gt;sasl_own_context);
278     priv-&gt;sasl_own_context = NULL;
279   }</b></font>
280   if(priv-&gt;sasl_context != NULL)
281   {
282     inf_sasl_context_unref(priv-&gt;sasl_context);
283     priv-&gt;sasl_context = NULL;
284   }
285   if(priv-&gt;tls_creds != NULL)
286   {
287     inf_certificate_credentials_unref(priv-&gt;tls_creds);
288     priv-&gt;tls_creds = NULL;
289   }
290   G_OBJECT_CLASS(infd_xmpp_server_parent_class)-&gt;dispose(object);
291 }
292 static void
293 infd_xmpp_server_finalize(GObject* object)
294 {
295   InfdXmppServer* xmpp;
296   InfdXmppServerPrivate* priv;
297   xmpp = INFD_XMPP_SERVER(object);
298   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
299   g_free(priv-&gt;local_hostname);
300   g_free(priv-&gt;sasl_mechanisms);
301   G_OBJECT_CLASS(infd_xmpp_server_parent_class)-&gt;finalize(object);
302 }
303 static void
304 infd_xmpp_server_set_property(GObject* object,
305                               guint prop_id,
306                               const GValue* value,
307                               GParamSpec* pspec)
308 {
309   InfdXmppServer* xmpp;
310   InfdXmppServerPrivate* priv;
311   xmpp = INFD_XMPP_SERVER(object);
312   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
313   switch(prop_id)
314   {
315   case PROP_TCP:
316     infd_xmpp_server_set_tcp(
317       xmpp,
318       INFD_TCP_SERVER(g_value_get_object(value))
319     );
320     break;
321   case PROP_LOCAL_HOSTNAME:
322     g_free(priv-&gt;local_hostname);
323     priv-&gt;local_hostname = g_value_dup_string(value);
324     if(priv-&gt;local_hostname == NULL)
325       priv-&gt;local_hostname = g_strdup(g_get_host_name());
326     break;
327   case PROP_CREDENTIALS:
328     if(priv-&gt;tls_creds != NULL)
329       inf_certificate_credentials_unref(priv-&gt;tls_creds);
330     priv-&gt;tls_creds = g_value_dup_boxed(value);
331     break;
332   case PROP_SASL_CONTEXT:
333     if(priv-&gt;sasl_own_context != NULL)
334     {
335       inf_sasl_context_unref(priv-&gt;sasl_own_context);
336       priv-&gt;sasl_own_context = NULL;
337     }
338     if(priv-&gt;sasl_context != NULL)
339       inf_sasl_context_unref(priv-&gt;sasl_context);
340     priv-&gt;sasl_context = g_value_dup_boxed(value);
341     infd_xmpp_server_setup_own_sasl_context(xmpp);
342     break;
343   case PROP_SASL_MECHANISMS:
344     g_free(priv-&gt;sasl_mechanisms);
345     priv-&gt;sasl_mechanisms = g_value_dup_string(value);
346     break;
347   case PROP_SECURITY_POLICY:
348     infd_xmpp_server_set_security_policy(xmpp, g_value_get_enum(value));
349     break;
350   default:
351     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
352     break;
353   }
354 }
355 static void
356 infd_xmpp_server_get_property(GObject* object,
357                               guint prop_id,
358                               GValue* value,
359                               GParamSpec* pspec)
360 {
361   InfdXmppServer* xmpp;
362   InfdXmppServerPrivate* priv;
363   xmpp = INFD_XMPP_SERVER(object);
364   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
365   switch(prop_id)
366   {
367   case PROP_STATUS:
368     switch(priv-&gt;status)
369     {
370     case INFD_XMPP_SERVER_CLOSED:
371       g_value_set_enum(value, INFD_XML_SERVER_CLOSED);
372       break;
373     case INFD_XMPP_SERVER_OPEN:
374       g_value_set_enum(value, INFD_XML_SERVER_OPEN);
375       break;
376     default:
377       g_assert_not_reached();
378 <a name="2"></a>      break;
379     }
380 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
381   case PROP_TCP:
382     g_value_set_object(value, priv-&gt;tcp);
383     break;
384   case PROP_LOCAL_HOSTNAME:
385     g_value_set_string(value, priv-&gt;local_hostname);
386     break;
387   case PROP_CREDENTIALS:
388     g_value_set_boxed(value, priv-&gt;tls_creds);
389     break;
390   case PROP_SASL_CONTEXT:
391     g_value_set_boxed(value, priv-&gt;sasl_context);
392     break;
393   case PROP_SASL_MECHANISMS:
394     g_value_set_string(value, priv-&gt;sasl_mechanisms);
395     break;
396   case PROP_SECURITY_POLICY:</b></font>
397     g_value_set_enum(value, priv-&gt;security_policy);
398     break;
399   default:
400     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
401     break;
402   }
403 }
404 static void
405 infd_xmpp_server_xml_server_close(InfdXmlServer* xml)
406 {
407   InfdXmppServerPrivate* priv;
408   priv = INFD_XMPP_SERVER_PRIVATE(xml);
409   g_return_if_fail(priv-&gt;status != INFD_XMPP_SERVER_CLOSED);
410   switch(priv-&gt;status)
411   {
412   case INFD_XMPP_SERVER_OPEN:
413     infd_tcp_server_close(priv-&gt;tcp);
414     break;
415   case INFD_XMPP_SERVER_CLOSED:
416 <a name="1"></a>  default:
417     g_assert_not_reached();
418     break;
419 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  }
420 }
421 static void
422 infd_xmpp_server_class_init(InfdXmppServerClass* xmpp_class)
423 {
424   GObjectClass* object_class;
425   object_class = G_OBJECT_CLASS(xmpp_class);
426   object_class-&gt;dispose = infd_xmpp_server_dispose;
427   object_class-&gt;finalize = infd_xmpp_server_finalize;
428   object_class-&gt;set_property = infd_xmpp_server_set_property;
429   object_class-&gt;get_property = infd_xmpp_server_get_property;
430   xmpp_class-&gt;error = NULL;</b></font>
431   g_object_class_install_property(
432     object_class,
433     PROP_TCP,
434     g_param_spec_object(
435       "tcp-server",
436       "TCP server",
437       "Underlaying TCP server",
438       INFD_TYPE_TCP_SERVER,
439       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
440     )
441   );
442   g_object_class_install_property(
443     object_class,
444     PROP_LOCAL_HOSTNAME,
445     g_param_spec_string(
446       "local-hostname",
447       "Local hostname",
448       "Hostname of the server",
449       NULL,
450       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
451     )
452   );
453   g_object_class_install_property(
454     object_class,
455     PROP_CREDENTIALS,
456     g_param_spec_boxed(
457       "credentials",
458       "Credentials",
459       "The certificate credentials for GnuTLS",
460       INF_TYPE_CERTIFICATE_CREDENTIALS,
461       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
462     )
463   );
464   g_object_class_install_property(
465     object_class,
466     PROP_SASL_CONTEXT,
467     g_param_spec_boxed(
468       "sasl-context",
469       "SASL context",
470       "The SASL context used for authentaction",
471       INF_TYPE_SASL_CONTEXT,
472       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
473     )
474   );
475   g_object_class_install_property(
476     object_class,
477     PROP_SASL_MECHANISMS,
478     g_param_spec_string(
479       "sasl-mechanisms",
480       "SASL mechanisms",
481       "The SASL mechanisms offered to the client for authentication",
482       NULL,
483       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
484     )
485   );
486   g_object_class_install_property(
487     object_class,
488     PROP_SECURITY_POLICY,
489     g_param_spec_enum(
490       "security-policy",
491       "Security policy",
492       "Whether to offer or require TLS",
493       INF_TYPE_XMPP_CONNECTION_SECURITY_POLICY,
494       INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED,
495       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
496     )
497   );
498   g_object_class_override_property(object_class, PROP_STATUS, "status");
499   xmpp_server_signals[ERROR] = g_signal_new(
500     "error",
501     G_OBJECT_CLASS_TYPE(object_class),
502     G_SIGNAL_RUN_LAST,
503     G_STRUCT_OFFSET(InfdXmppServerClass, error),
504     NULL, NULL,
505     g_cclosure_marshal_VOID__BOXED,
506     G_TYPE_NONE,
507     1,
508     G_TYPE_ERROR
509   );
510 }
511 static void
512 infd_xmpp_server_xml_server_iface_init(InfdXmlServerInterface* iface)
513 {
514   iface-&gt;close = infd_xmpp_server_xml_server_close;
515 }
516 InfdXmppServer*
517 infd_xmpp_server_new(InfdTcpServer* tcp,
518                      InfXmppConnectionSecurityPolicy policy,
519                      InfCertificateCredentials* creds,
520                      InfSaslContext* sasl_context,
521                      const gchar* sasl_mechanisms)
522 {
523   GObject* object;
524   g_return_val_if_fail(INFD_IS_TCP_SERVER(tcp), NULL);
525   g_return_val_if_fail(
526     policy == INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED || creds != NULL,
527     NULL
528   );
529   object = g_object_new(
530     INFD_TYPE_XMPP_SERVER,
531     "tcp-server", tcp,
532     "credentials", creds,
533     "security-policy", policy,
534     "sasl-context", sasl_context,
535     "sasl-mechanisms", sasl_mechanisms,
536     NULL
537   );
538   return INFD_XMPP_SERVER(object);
539 }
540 void
541 infd_xmpp_server_set_security_policy(InfdXmppServer* server,
542                                      InfXmppConnectionSecurityPolicy policy)
543 {
544   InfdXmppServerPrivate* priv;
545   g_return_if_fail(INFD_IS_XMPP_SERVER(server));
546   priv = INFD_XMPP_SERVER_PRIVATE(server);
547   if(policy != priv-&gt;security_policy)
548   {
549     g_return_if_fail(
550       policy == INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED ||
551       priv-&gt;tls_creds != NULL
552     );
553     priv-&gt;security_policy = policy;
554     g_object_notify(G_OBJECT(server), "security-policy");
555   }
556 }
557 InfXmppConnectionSecurityPolicy
558 infd_xmpp_server_get_security_policy(InfdXmppServer* server)
559 {
560   g_return_val_if_fail(
561     INFD_IS_XMPP_SERVER(server),
562     INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS
563   );
564   return INFD_XMPP_SERVER_PRIVATE(server)-&gt;security_policy;
565 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-tcp-connection.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/common/inf-tcp-connection.h&gt;
2 #include &lt;libinfinity/common/inf-tcp-connection-private.h&gt;
3 #include &lt;libinfinity/common/inf-name-resolver.h&gt;
4 #include &lt;libinfinity/common/inf-ip-address.h&gt;
5 #include &lt;libinfinity/common/inf-io.h&gt;
6 #include &lt;libinfinity/common/inf-native-socket.h&gt;
7 #include &lt;libinfinity/inf-signals.h&gt;
8 #include &lt;libinfinity/inf-i18n.h&gt;
9 #include &lt;libinfinity/inf-define-enum.h&gt;
10 #include &lt;unistd.h&gt; 
11 #include "config.h"
12 #ifndef G_OS_WIN32
13 # include &lt;sys/types.h&gt;
14 # include &lt;sys/socket.h&gt;
15 # include &lt;netinet/in.h&gt;
16 # include &lt;net/if.h&gt;
17 # include &lt;arpa/inet.h&gt;
18 # include &lt;unistd.h&gt;
19 # include &lt;fcntl.h&gt;
20 # include &lt;errno.h&gt;
21 # include &lt;string.h&gt;
22 #else
23 # include &lt;ws2tcpip.h&gt;
24 #endif
25 static const GEnumValue inf_tcp_connection_status_values[] = {
26   {
27     INF_TCP_CONNECTION_CONNECTING,
28     "INF_TCP_CONNECTION_CONNECTING",
29     "connecting"
30   }, {
31     INF_TCP_CONNECTION_CONNECTED,
32     "INF_TCP_CONNECTION_CONNECTED",
33     "connected"
34   }, {
35     INF_TCP_CONNECTION_CLOSED,
36     "INF_TCP_CONNECTION_CLOSED",
37     "closed"
38   }, {
39     0,
40     NULL,
41     NULL
42   }
43 };
44 typedef struct _InfTcpConnectionPrivate InfTcpConnectionPrivate;
45 struct _InfTcpConnectionPrivate {
46   InfIo* io;
47   InfIoEvent events;
48   InfIoWatch* watch;
49   InfNameResolver* resolver;
50   guint resolver_index;
51   InfTcpConnectionStatus status;
52   InfNativeSocket socket;
53   InfKeepalive keepalive;
54   InfIpAddress* remote_address;
55   guint remote_port;
56   unsigned int device_index;
57   guint8* queue;
58   gsize front_pos;
59   gsize back_pos;
60   gsize alloc;
61 };
62 enum {
63   PROP_0,
64   PROP_IO,
65   PROP_RESOLVER,
66   PROP_STATUS,
67   PROP_KEEPALIVE,
68   PROP_REMOTE_ADDRESS,
69   PROP_REMOTE_PORT,
70   PROP_LOCAL_ADDRESS,
71   PROP_LOCAL_PORT,
72   PROP_DEVICE_INDEX,
73   PROP_DEVICE_NAME
74 };
75 enum {
76   SENT,
77   RECEIVED,
78   ERROR_, 
79   LAST_SIGNAL
80 };
81 #define INF_TCP_CONNECTION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_TCP_CONNECTION, InfTcpConnectionPrivate))
82 static guint tcp_connection_signals[LAST_SIGNAL];
83 INF_DEFINE_ENUM_TYPE(InfTcpConnectionStatus, inf_tcp_connection_status, inf_tcp_connection_status_values)
84 G_DEFINE_TYPE_WITH_CODE(InfTcpConnection, inf_tcp_connection, G_TYPE_OBJECT,
85   G_ADD_PRIVATE(InfTcpConnection))
86 static gboolean
87 inf_tcp_connection_addr_info(InfNativeSocket socket,
88                              gboolean local,
89                              InfIpAddress** address,
90                              guint* port,
91                              GError** error)
92 {
93   union {
94     struct sockaddr in_generic;
95     struct sockaddr_in in;
96     struct sockaddr_in6 in6;
97   } native_addr;
98   socklen_t len;
99   int res;
100   int code;
101   len = sizeof(native_addr);
102   if(local == TRUE)
103     res = getsockname(socket, &amp;native_addr.in_generic, &amp;len);
104   else
105     res = getpeername(socket, &amp;native_addr.in_generic, &amp;len);
106   if(res == -1)
107   {
108     code = INF_NATIVE_SOCKET_LAST_ERROR;
109     inf_native_socket_make_error(code, error);
110     return FALSE;
111   }
112   switch(native_addr.in_generic.sa_family)
113   {
114   case AF_INET:
115     if(address != NULL)
116       *address = inf_ip_address_new_raw4(native_addr.in.sin_addr.s_addr);
117     if(port != NULL)
118       *port = ntohs(native_addr.in.sin_port);
119     break;
120   case AF_INET6:
121     if(address != NULL)
122       *address = inf_ip_address_new_raw6(native_addr.in6.sin6_addr.s6_addr);
123     if(port != NULL)
124       *port = ntohs(native_addr.in6.sin6_port);
125     break;
126   default:
127     g_assert_not_reached();
128     break;
129   }
130   return TRUE;
131 }
132 static gboolean
133 inf_tcp_connection_configure_socket(InfNativeSocket socket,
134                                     const InfKeepalive* keepalive,
135                                     GError** error)
136 {
137 #ifdef G_OS_WIN32
138   u_long argp;
139 #else
140   int result;
141 #endif
142   int errcode;
143   GError* local_error;
144 #ifndef G_OS_WIN32
145   result = fcntl(socket, F_GETFL);
146   if(result == INVALID_SOCKET)
147   {
148     errcode = INF_NATIVE_SOCKET_LAST_ERROR;
149     inf_native_socket_make_error(errcode, error);
150     return FALSE;
151   }
152   if(fcntl(socket, F_SETFL, result | O_NONBLOCK) == -1)
153   {
154     errcode = INF_NATIVE_SOCKET_LAST_ERROR;
155     inf_native_socket_make_error(errcode, error);
156     return FALSE;
157   }
158 #else
159   argp = 1;
160   if(ioctlsocket(socket, FIONBIO, &amp;argp) != 0)
161   {
162     errcode = INF_NATIVE_SOCKET_LAST_ERROR;
163     inf_native_socket_make_error(errcode, error);
164     return FALSE;
165   }
166 #endif
167   local_error = NULL;
168   if(inf_keepalive_apply(keepalive, &amp;socket, 0, &amp;local_error) == FALSE)
169   {
170     g_warning("Failed to set keepalive on socket: %s", local_error-&gt;message);
171     g_error_free(local_error);
172   }
173   return TRUE;
174 }
175 static void
176 inf_tcp_connection_system_error(InfTcpConnection* connection,
177                                 int code)
178 {
179   GError* error;
180   error = NULL;
181   inf_native_socket_make_error(code, &amp;error);
182   g_signal_emit(
183     G_OBJECT(connection),
184     tcp_connection_signals[ERROR_],
185     0,
186     error
187   );
188   g_error_free(error);
189 }
190 static void
191 inf_tcp_connection_io(InfNativeSocket* socket,
192                       InfIoEvent events,
193                       gpointer user_data);
194 static void
195 inf_tcp_connection_connected(InfTcpConnection* connection)
196 {
197   InfTcpConnectionPrivate* priv;
198   priv = INF_TCP_CONNECTION_PRIVATE(connection);
199   priv-&gt;status = INF_TCP_CONNECTION_CONNECTED;
200   priv-&gt;front_pos = 0;
201   priv-&gt;back_pos = 0;
202   priv-&gt;events = INF_IO_INCOMING | INF_IO_ERROR;
203   if(priv-&gt;watch == NULL)
204   {
205     priv-&gt;watch = inf_io_add_watch(
206       priv-&gt;io,
207       &amp;priv-&gt;socket,
208       priv-&gt;events,
209       inf_tcp_connection_io,
210       connection,
211       NULL
212     );
213   }
214   else
215   {
216     inf_io_update_watch(priv-&gt;io, priv-&gt;watch, priv-&gt;events);
217   }
218   g_object_freeze_notify(G_OBJECT(connection));
219   if(priv-&gt;resolver != NULL)
220   {
221     if(priv-&gt;remote_address != NULL)
222       inf_ip_address_free(priv-&gt;remote_address);
223     priv-&gt;remote_address = inf_ip_address_copy(
224       inf_name_resolver_get_address(priv-&gt;resolver, priv-&gt;resolver_index)
225     );
226     priv-&gt;remote_port =
227       inf_name_resolver_get_port(priv-&gt;resolver, priv-&gt;resolver_index);
228     g_object_notify(G_OBJECT(connection), "remote-address");
229     g_object_notify(G_OBJECT(connection), "remote-port");
230     priv-&gt;resolver_index = 0;
231   }
232   g_object_notify(G_OBJECT(connection), "status");
233   g_object_notify(G_OBJECT(connection), "local-address");
234   g_object_notify(G_OBJECT(connection), "local-port");
235   g_object_thaw_notify(G_OBJECT(connection));
236 }
237 static gboolean
238 inf_tcp_connection_open_with_resolver(InfTcpConnection* connection,
239                                       GError** error);
240 static gboolean
241 inf_tcp_connection_connection_error(InfTcpConnection* connection,
242                                     const GError* error)
243 {
244   InfTcpConnectionPrivate* priv;
245   priv = INF_TCP_CONNECTION_PRIVATE(connection);
246   if(priv-&gt;socket != INVALID_SOCKET)
247   {
248     closesocket(priv-&gt;socket);
249     priv-&gt;socket = INVALID_SOCKET;
250   }
251   if(priv-&gt;watch != NULL)
252   {
253     priv-&gt;events = 0;
254     inf_io_remove_watch(priv-&gt;io, priv-&gt;watch);
255     priv-&gt;watch = NULL;
256   }
257   if(priv-&gt;resolver != NULL)
258   {
259     if(priv-&gt;resolver_index &lt;
260        inf_name_resolver_get_n_addresses(priv-&gt;resolver))
261     {
262       ++priv-&gt;resolver_index;
263       if(inf_tcp_connection_open_with_resolver(connection, NULL) == TRUE)
264         return TRUE;
265     }
266     priv-&gt;resolver_index = 0;
267   }
268   g_signal_emit(
269     G_OBJECT(connection),
270     tcp_connection_signals[ERROR_],
271     0,
272     error
273   );
274   return FALSE;
275 }
276 static gboolean
277 inf_tcp_connection_open_real(InfTcpConnection* connection,
278                              const InfIpAddress* address,
279                              guint port,
280                              GError** error)
281 {
282   InfTcpConnectionPrivate* priv;
283   union {
284     struct sockaddr_in in;
285     struct sockaddr_in6 in6;
286   } native_address;
287   struct sockaddr* addr;
288   socklen_t addrlen;
289   int result;
290   int errcode;
291   const InfKeepalive* keepalive;
292   GError* local_error;
293   priv = INF_TCP_CONNECTION_PRIVATE(connection);
294   g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED ||
295            priv-&gt;status == INF_TCP_CONNECTION_CONNECTING);
296   if(priv-&gt;socket != INVALID_SOCKET)
297     closesocket(priv-&gt;socket);
298   switch(inf_ip_address_get_family(address))
299   {
300   case INF_IP_ADDRESS_IPV4:
301     priv-&gt;socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
302     addr = (struct sockaddr*)&amp;native_address.in;
303     addrlen = sizeof(struct sockaddr_in);
304     memcpy(
305       &amp;native_address.in.sin_addr,
306       inf_ip_address_get_raw(address),
307       sizeof(struct in_addr)
308     );
309     native_address.in.sin_family = AF_INET;
310     native_address.in.sin_port = htons(port);
311     break;
312   case INF_IP_ADDRESS_IPV6:
313     priv-&gt;socket = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP);
314     addr = (struct sockaddr*)&amp;native_address.in6;
315     addrlen = sizeof(struct sockaddr_in6);
316     memcpy(
317       &amp;native_address.in6.sin6_addr,
318       inf_ip_address_get_raw(address),
319       sizeof(struct in6_addr)
320     );
321     native_address.in6.sin6_family = AF_INET6;
322     native_address.in6.sin6_port = htons(port);
323     native_address.in6.sin6_flowinfo = 0;
324     native_address.in6.sin6_scope_id = priv-&gt;device_index;
325     break;
326   default:
327     g_assert_not_reached();
328     break;
329   }
330   if(priv-&gt;socket == INVALID_SOCKET)
331   {
332     inf_native_socket_make_error(INF_NATIVE_SOCKET_LAST_ERROR, error);
333     return FALSE;
334   }
335   keepalive = &amp;priv-&gt;keepalive;
336   if(!inf_tcp_connection_configure_socket(priv-&gt;socket, keepalive, error))
337   {
338     closesocket(priv-&gt;socket);
339     priv-&gt;socket = INVALID_SOCKET;
340     return FALSE;
341   }
342   do
343   {
344     result = connect(priv-&gt;socket, addr, addrlen);
345     errcode = INF_NATIVE_SOCKET_LAST_ERROR;
346     if(result == -1 &amp;&amp;
347        errcode != INF_NATIVE_SOCKET_EINTR &amp;&amp;
348        errcode != INF_NATIVE_SOCKET_EINPROGRESS)
349     {
350       local_error = NULL;
351       inf_native_socket_make_error(errcode, &amp;local_error);
352       if(inf_tcp_connection_connection_error(connection, local_error) == TRUE)
353       {
354         g_error_free(local_error);
355         return TRUE;
356       }
357       g_propagate_error(error, local_error);
358       return FALSE;
359     }
360   } while(result == -1 &amp;&amp; errcode != INF_NATIVE_SOCKET_EINPROGRESS);
361   if(result == 0)
362   {
363     inf_tcp_connection_connected(connection);
364   }
365   else
366   {
367     g_assert(priv-&gt;watch == NULL);
368     priv-&gt;events = INF_IO_OUTGOING | INF_IO_ERROR;
369     priv-&gt;watch = inf_io_add_watch(
370       priv-&gt;io,
371       &amp;priv-&gt;socket,
372       priv-&gt;events,
373       inf_tcp_connection_io,
374       connection,
375       NULL
376     );
377     if(priv-&gt;status != INF_TCP_CONNECTION_CONNECTING)
378     {
379       priv-&gt;status = INF_TCP_CONNECTION_CONNECTING;
380       g_object_notify(G_OBJECT(connection), "status");
381     }
382   }
383   return TRUE;
384 }
385 static gboolean
386 inf_tcp_connection_open_with_resolver(InfTcpConnection* connection,
387                                       GError** error)
388 {
389   InfTcpConnectionPrivate* priv;
390   GError* local_error;
391   gboolean success;
392   priv = INF_TCP_CONNECTION_PRIVATE(connection);
393   g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED ||
394            priv-&gt;status == INF_TCP_CONNECTION_CONNECTING);
395   if(inf_name_resolver_finished(priv-&gt;resolver))
396   {
397     if(priv-&gt;resolver_index &lt; 
398        inf_name_resolver_get_n_addresses(priv-&gt;resolver))
399     {
400       return inf_tcp_connection_open_real(
401         connection,
402         inf_name_resolver_get_address(priv-&gt;resolver, priv-&gt;resolver_index),
403         inf_name_resolver_get_port(priv-&gt;resolver, priv-&gt;resolver_index),
404         error
405       );
406     }
407     g_object_freeze_notify(G_OBJECT(connection));
408     if(priv-&gt;status != INF_TCP_CONNECTION_CONNECTING)
409     {
410       priv-&gt;status = INF_TCP_CONNECTION_CONNECTING;
411       g_object_notify(G_OBJECT(connection), "status");
412     }
413     local_error = NULL;
414     if(priv-&gt;resolver_index == 0)
415       success = inf_name_resolver_start(priv-&gt;resolver, &amp;local_error);
416     else
417       success = inf_name_resolver_lookup_backup(priv-&gt;resolver, &amp;local_error);
418     if(local_error != NULL)
419     {
420       inf_tcp_connection_connection_error(connection, local_error);
421       g_propagate_error(error, local_error);
422     }
423     g_object_thaw_notify(G_OBJECT(connection));
424     return success;
425   }
426   return TRUE;
427 }
428 static gboolean
429 inf_tcp_connection_send_real(InfTcpConnection* connection,
430                              gconstpointer data,
431                              guint* len)
432 {
433   InfTcpConnectionPrivate* priv;
434   gconstpointer send_data;
435   guint send_len;
436   int errcode;
437   ssize_t result;
438   priv = INF_TCP_CONNECTION_PRIVATE(connection);
439   g_assert(priv-&gt;status == INF_TCP_CONNECTION_CONNECTED);
440   g_assert(data != NULL);
441   g_assert(len != NULL);
442   send_data = data;
443   send_len = *len;
444   do
445   {
446     result = send(
447       priv-&gt;socket,
448       send_data,
449       send_len,
450       INF_NATIVE_SOCKET_SENDRECV_FLAGS
451     );
452     errcode = INF_NATIVE_SOCKET_LAST_ERROR;
453     if(result &lt; 0 &amp;&amp;
454        errcode != INF_NATIVE_SOCKET_EINTR &amp;&amp;
455        errcode != INF_NATIVE_SOCKET_EAGAIN)
456     {
457       inf_tcp_connection_system_error(connection, errcode);
458       return FALSE;
459     }
460     else if(result == 0)
461     {
462       inf_tcp_connection_close(connection);
463       return FALSE;
464     }
465     else if(result &gt; 0)
466     {
467       send_data = (const char*)send_data + result;
468       send_len -= result;
469     }
470   } while( (send_len &gt; 0) &amp;&amp;
471            (result &gt; 0 || errcode == INF_NATIVE_SOCKET_EINTR) &amp;&amp;
472            (priv-&gt;socket != INVALID_SOCKET) );
473   *len -= send_len;
474   return TRUE;
475 }
476 static void
477 inf_tcp_connection_io_incoming(InfTcpConnection* connection)
478 {
479   InfTcpConnectionPrivate* priv;
480   gchar buf[2048];
481   int errcode;
482   ssize_t result;
483   priv = INF_TCP_CONNECTION_PRIVATE(connection);
484   g_assert(priv-&gt;status == INF_TCP_CONNECTION_CONNECTED);
485   do
486   {
487     result = recv(priv-&gt;socket, buf, 2048, INF_NATIVE_SOCKET_SENDRECV_FLAGS);
488     errcode = INF_NATIVE_SOCKET_LAST_ERROR;
489     if(result &lt; 0 &amp;&amp;
490        errcode != INF_NATIVE_SOCKET_EINTR &amp;&amp;
491        errcode != INF_NATIVE_SOCKET_EAGAIN)
492     {
493       inf_tcp_connection_system_error(connection, errcode);
494     }
495     else if(result == 0)
496     {
497       inf_tcp_connection_close(connection);
498     }
499     else if(result &gt; 0)
500     {
501       g_signal_emit(
502         G_OBJECT(connection),
503         tcp_connection_signals[RECEIVED],
504         0,
505         buf,
506         (guint)result
507       );
508     }
509   } while( ((result &gt; 0) ||
510             (result &lt; 0 &amp;&amp; errcode == INF_NATIVE_SOCKET_EINTR)) &amp;&amp;
511            (priv-&gt;status != INF_TCP_CONNECTION_CLOSED));
512 }
513 static void
514 inf_tcp_connection_io_outgoing(InfTcpConnection* connection)
515 {
516   InfTcpConnectionPrivate* priv;
517   socklen_t len;
518   int errcode;
519   gconstpointer data;
520   guint data_len;
521   priv = INF_TCP_CONNECTION_PRIVATE(connection);
522   switch(priv-&gt;status)
523   {
524   case INF_TCP_CONNECTION_CONNECTING:
525     len = sizeof(int);
526 #ifdef G_OS_WIN32
527     getsockopt(priv-&gt;socket, SOL_SOCKET, SO_ERROR, (char*)&amp;errcode, &amp;len);
528 #else
529     getsockopt(priv-&gt;socket, SOL_SOCKET, SO_ERROR, &amp;errcode, &amp;len);
530 #endif
531     if(errcode == 0)
532     {
533       inf_tcp_connection_connected(connection);
534     }
535     else
536     {
537       inf_tcp_connection_system_error(connection, errcode);
538     }
539     break;
540   case INF_TCP_CONNECTION_CONNECTED:
541     g_assert(priv-&gt;back_pos &lt; priv-&gt;front_pos);
542     g_assert(priv-&gt;events &amp; INF_IO_OUTGOING);
543     data = priv-&gt;queue + priv-&gt;back_pos;
544     data_len = priv-&gt;front_pos - priv-&gt;back_pos;
545     if(inf_tcp_connection_send_real(connection, data, &amp;data_len) == TRUE)
546     {
547       priv-&gt;back_pos += data_len;
548       if(priv-&gt;front_pos == priv-&gt;back_pos)
549       {
550         priv-&gt;front_pos = 0;
551         priv-&gt;back_pos = 0;
552         priv-&gt;events &amp;= ~INF_IO_OUTGOING;
553         inf_io_update_watch(priv-&gt;io, priv-&gt;watch, priv-&gt;events);
554       }
555       g_signal_emit(
556         G_OBJECT(connection),
557         tcp_connection_signals[SENT],
558         0,
559         data,
560         data_len
561       );
562     }
563     break;
564   case INF_TCP_CONNECTION_CLOSED:
565   default:
566     g_assert_not_reached();
567     break;
568   }
569 }
570 static void
571 inf_tcp_connection_io(InfNativeSocket* socket,
572                       InfIoEvent events,
573                       gpointer user_data)
574 {
575   InfTcpConnection* connection;
576   InfTcpConnectionPrivate* priv;
577   socklen_t len;
578   int errcode;
579   GError* error;
580   connection = INF_TCP_CONNECTION(user_data);
581   priv = INF_TCP_CONNECTION_PRIVATE(connection);
582   g_object_ref(G_OBJECT(connection));
583   g_assert(priv-&gt;status != INF_TCP_CONNECTION_CLOSED);
584   if(events &amp; INF_IO_ERROR)
585   {
586     len = sizeof(int);
587 #ifdef G_OS_WIN32
588     getsockopt(priv-&gt;socket, SOL_SOCKET, SO_ERROR, (char*)&amp;errcode, &amp;len);
589 #else
590     getsockopt(priv-&gt;socket, SOL_SOCKET, SO_ERROR, &amp;errcode, &amp;len);
591 #endif
592     if(errcode != 0)
593     {
594       error = NULL;
595       inf_native_socket_make_error(errcode, &amp;error);
596       if(priv-&gt;status == INF_TCP_CONNECTION_CONNECTING)
597       {
598         inf_tcp_connection_connection_error(connection, error);
599       }
600       else
601       {
602         g_signal_emit(
603           G_OBJECT(connection),
604           tcp_connection_signals[ERROR_],
605           0,
606           error
607         );
608       }
609       g_error_free(error);
610     }
611     else
612     {
613       inf_tcp_connection_close(connection);
614     }
615   }
616   else
617   {
618     if(events &amp; INF_IO_INCOMING)
619     {
620       inf_tcp_connection_io_incoming(connection);
621     }
622     if((priv-&gt;status != INF_TCP_CONNECTION_CLOSED) &amp;&amp;
623        (events &amp; INF_IO_OUTGOING))
624     {
625       inf_tcp_connection_io_outgoing(connection);
626     }
627   }
628   g_object_unref(G_OBJECT(connection));
629 }
630 static void
631 inf_tcp_connection_resolved_cb(InfNameResolver* resolver,
632                                const GError* error,
633                                gpointer user_data)
634 {
635   InfTcpConnection* connection;
636   InfTcpConnectionPrivate* priv;
637   connection = INF_TCP_CONNECTION(user_data);
638   priv = INF_TCP_CONNECTION_PRIVATE(connection);
639   if(priv-&gt;status == INF_TCP_CONNECTION_CONNECTING)
640   {
641     if(error != NULL)
642     {
643       g_assert(
644         priv-&gt;resolver_index == inf_name_resolver_get_n_addresses(resolver)
645       );
646       inf_tcp_connection_connection_error(connection, error);
647     }
648     else
649     {
650       inf_tcp_connection_open_with_resolver(connection, NULL);
651     }
652   }
653 }
654 static void
655 inf_tcp_connection_set_resolver(InfTcpConnection* connection,
656                                 InfNameResolver* resolver)
657 {
658   InfTcpConnectionPrivate* priv;
659   priv = INF_TCP_CONNECTION_PRIVATE(connection);
660   if(priv-&gt;resolver != NULL)
661   {
662     inf_signal_handlers_disconnect_by_func(
663       G_OBJECT(priv-&gt;resolver),
664       G_CALLBACK(inf_tcp_connection_resolved_cb),
665       connection
666     );
667     g_object_unref(priv-&gt;resolver);
668   }
669   priv-&gt;resolver = resolver;
670   if(resolver != NULL)
671   {
672     g_object_ref(resolver);
673     g_signal_connect(
674       G_OBJECT(resolver),
675       "resolved",
676       G_CALLBACK(inf_tcp_connection_resolved_cb),
677       connection
678     );
679   }
680 }
681 static void
682 inf_tcp_connection_init(InfTcpConnection* connection)
683 {
684   InfTcpConnectionPrivate* priv;
685   priv = INF_TCP_CONNECTION_PRIVATE(connection);
686   priv-&gt;io = NULL;
687   priv-&gt;events = 0;
688   priv-&gt;watch = NULL;
689   priv-&gt;resolver = NULL;
690   priv-&gt;resolver_index = 0;
691   priv-&gt;status = INF_TCP_CONNECTION_CLOSED;
692   priv-&gt;socket = INVALID_SOCKET;
693   priv-&gt;keepalive.mask = 0;
694   priv-&gt;remote_address = NULL;
695   priv-&gt;remote_port = 0;
696   priv-&gt;device_index = 0;
697   priv-&gt;queue = g_malloc(1024);
698 <a name="0"></a>  priv-&gt;front_pos = 0;
699   priv-&gt;back_pos = 0;
700   priv-&gt;alloc = 1024;
701 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
702 static void
703 inf_tcp_connection_dispose(GObject* object)
704 {
705   InfTcpConnection* connection;
706   InfTcpConnectionPrivate* priv;
707   connection = INF_TCP_CONNECTION(object);
708   priv = INF_TCP_CONNECTION_PRIVATE(connection);
709   if(priv-&gt;status != INF_TCP_CONNECTION_CLOSED)
710     inf_tcp_connection_close(connection);
711   inf_tcp_connection_set_resolver(connection, NULL);
712   if(priv-&gt;io != NULL)
713   {
714     g_object_unref(priv-&gt;io);
715     priv-&gt;io = NULL;
716   }</b></font>
717   G_OBJECT_CLASS(inf_tcp_connection_parent_class)-&gt;dispose(object);
718 }
719 static void
720 inf_tcp_connection_finalize(GObject* object)
721 {
722   InfTcpConnection* connection;
723   InfTcpConnectionPrivate* priv;
724   connection = INF_TCP_CONNECTION(object);
725   priv = INF_TCP_CONNECTION_PRIVATE(connection);
726   if(priv-&gt;remote_address != NULL)
727     inf_ip_address_free(priv-&gt;remote_address);
728   if(priv-&gt;socket != INVALID_SOCKET)
729     closesocket(priv-&gt;socket);
730   g_free(priv-&gt;queue);
731   G_OBJECT_CLASS(inf_tcp_connection_parent_class)-&gt;finalize(object);
732 }
733 static void
734 inf_tcp_connection_set_property(GObject* object,
735                                 guint prop_id,
736                                 const GValue* value,
737                                 GParamSpec* pspec)
738 {
739   InfTcpConnection* connection;
740   InfTcpConnectionPrivate* priv;
741 #ifndef G_OS_WIN32
742   const gchar* device_string;
743   unsigned int new_index;
744 #endif
745   GError* error;
746   connection = INF_TCP_CONNECTION(object);
747   priv = INF_TCP_CONNECTION_PRIVATE(connection);
748   switch(prop_id)
749   {
750   case PROP_IO:
751     g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED);
752     if(priv-&gt;io != NULL) g_object_unref(G_OBJECT(priv-&gt;io));
753     priv-&gt;io = INF_IO(g_value_dup_object(value));
754     break;
755   case PROP_RESOLVER:
756     g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED);
757     inf_tcp_connection_set_resolver(
758       connection,
759       INF_NAME_RESOLVER(g_value_get_object(value))
760     );
761     break;
762   case PROP_KEEPALIVE:
763     error = NULL;
764     inf_tcp_connection_set_keepalive(
765       connection,
766       (InfKeepalive*)g_value_get_boxed(value),
767       &amp;error
768     );
769     if(error != NULL)
770     {
771       g_warning("Failed to set keepalive settings: %s\n", error-&gt;message);
772       g_error_free(error);
773     }
774     break;
775   case PROP_REMOTE_ADDRESS:
776     g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED);
777     if(priv-&gt;remote_address != NULL)
778       inf_ip_address_free(priv-&gt;remote_address);
779     priv-&gt;remote_address = (InfIpAddress*)g_value_dup_boxed(value);
780     break;
781   case PROP_REMOTE_PORT:
782     g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED);
783     priv-&gt;remote_port = g_value_get_uint(value);
784     break;
785   case PROP_DEVICE_INDEX:
786     g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED);
787     priv-&gt;device_index = g_value_get_uint(value);
788     g_object_notify(G_OBJECT(object), "device-name");
789     break;
790   case PROP_DEVICE_NAME:
791 #ifdef G_OS_WIN32
792     g_warning("The device-name property is not implemented on Win32");
793 #else
794     g_assert(priv-&gt;status == INF_TCP_CONNECTION_CLOSED);
795     device_string = g_value_get_string(value);
796     if(device_string == NULL) priv-&gt;device_index = 0;
797     new_index = if_nametoindex(device_string);
798     if(new_index == 0)
799     {
800       g_warning(_("Interface `%s' does not exist"), device_string);
801     }
802     else
803     {
804       priv-&gt;device_index = new_index;
805       g_object_notify(G_OBJECT(object), "device-index");
806     }
807 #endif
808     break;
809   default:
810     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
811     break;
812   }
813 }
814 static void
815 inf_tcp_connection_get_property(GObject* object,
816                                 guint prop_id,
817                                 GValue* value,
818                                 GParamSpec* pspec)
819 {
820   InfTcpConnection* connection;
821   InfTcpConnectionPrivate* priv;
822   InfIpAddress* address;
823   guint port;
824   GError* error;
825 #ifndef G_OS_WIN32
826   char device_name[IF_NAMESIZE];
827 #endif
828   connection = INF_TCP_CONNECTION(object);
829   priv = INF_TCP_CONNECTION_PRIVATE(connection);
830   switch(prop_id)
831 <a name="2"></a>  {
832   case PROP_IO:
833     g_value_set_object(value, G_OBJECT(priv-&gt;io));
834 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
835   case PROP_RESOLVER:
836     g_value_set_object(value, G_OBJECT(priv-&gt;resolver));
837     break;
838   case PROP_KEEPALIVE:
839     g_value_set_boxed(value, &amp;priv-&gt;keepalive);
840     break;
841   case PROP_STATUS:
842     g_value_set_enum(value, priv-&gt;status);
843     break;
844   case PROP_REMOTE_ADDRESS:
845     g_value_set_static_boxed(value, priv-&gt;remote_address);
846     break;
847   case PROP_REMOTE_PORT:
848     g_value_set_uint(value, priv-&gt;remote_port);
849     break;
850   case PROP_LOCAL_ADDRESS:</b></font>
851     g_assert(priv-&gt;socket != INVALID_SOCKET);
852     error = NULL;
853     inf_tcp_connection_addr_info(priv-&gt;socket, TRUE, &amp;address, NULL, &amp;error);
854     if(error != NULL)
855     {
856       g_warning(_("Failed to retrieve local address: %s"), error-&gt;message);
857       g_error_free(error);
858       g_value_set_boxed(value, NULL);
859     }
860     else
861     {
862       g_value_take_boxed(value, address);
863     }
864     break;
865   case PROP_LOCAL_PORT:
866     g_assert(priv-&gt;socket != INVALID_SOCKET);
867     error = NULL;
868     inf_tcp_connection_addr_info(priv-&gt;socket, TRUE, NULL, &amp;port, &amp;error);
869     if(error != NULL)
870     {
871       g_warning(_("Failed to retrieve local port: %s"), error-&gt;message);
872       g_error_free(error);
873       g_value_set_uint(value, 0);
874     }
875     else
876     {
877       g_value_set_uint(value, port);
878     }
879     break;
880   case PROP_DEVICE_INDEX:
881     g_value_set_uint(value, priv-&gt;device_index);
882     break;
883   case PROP_DEVICE_NAME:
884 #ifdef G_OS_WIN32
885     g_warning(_("The device-name property is not implemented on Win32"));
886     g_value_set_string(value, NULL);
887 #else
888     if(priv-&gt;device_index == 0)
889     {
890       g_value_set_string(value, NULL);
891     }
892     else
893     {
894       if(if_indextoname(priv-&gt;device_index, device_name) == NULL)
895       {
896         g_warning(
897           _("Failed to get name for device %u: %s"),
898           priv-&gt;device_index,
899           strerror(errno)
900         );
901         g_value_set_string(value, NULL);
902       }
903       else
904       {
905         g_value_set_string(value, device_name);
906       }
907     }
908 #endif
909     break;
910   default:
911     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
912     break;
913   }
914 }
915 static void
916 inf_tcp_connection_error(InfTcpConnection* connection,
917                          GError* error)
918 {
919   InfTcpConnectionPrivate* priv;
920   priv = INF_TCP_CONNECTION_PRIVATE(connection);
921   if(priv-&gt;watch != NULL)
922   {
923     priv-&gt;events = 0;
924     inf_io_remove_watch(priv-&gt;io, priv-&gt;watch);
925     priv-&gt;watch = NULL;
926   }
927   if(priv-&gt;status != INF_TCP_CONNECTION_CLOSED)
928 <a name="1"></a>  {
929     priv-&gt;status = INF_TCP_CONNECTION_CLOSED;
930     g_object_notify(G_OBJECT(connection), "status");
931 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  }
932 }
933 static void
934 inf_tcp_connection_class_init(InfTcpConnectionClass* tcp_connection_class)
935 {
936   GObjectClass* object_class;
937   object_class = G_OBJECT_CLASS(tcp_connection_class);
938   object_class-&gt;dispose = inf_tcp_connection_dispose;
939   object_class-&gt;finalize = inf_tcp_connection_finalize;
940   object_class-&gt;set_property = inf_tcp_connection_set_property;
941   object_class-&gt;get_property = inf_tcp_connection_get_property;
942   tcp_connection_class-&gt;sent = NULL;</b></font>
943   tcp_connection_class-&gt;received = NULL;
944   tcp_connection_class-&gt;error = inf_tcp_connection_error;
945   g_object_class_install_property(
946     object_class,
947     PROP_IO,
948     g_param_spec_object(
949       "io",
950       "IO",
951       "I/O handler",
952       INF_TYPE_IO,
953       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
954     )
955   );
956   g_object_class_install_property(
957     object_class,
958     PROP_RESOLVER,
959     g_param_spec_object(
960       "resolver",
961       "Resolver",
962       "The hostname resolver",
963       INF_TYPE_NAME_RESOLVER,
964       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
965     )
966   );
967   g_object_class_install_property(
968     object_class,
969     PROP_STATUS,
970     g_param_spec_enum(
971       "status",
972       "Status",
973       "Status of the TCP connection",
974       INF_TYPE_TCP_CONNECTION_STATUS,
975       INF_TCP_CONNECTION_CLOSED,
976       G_PARAM_READABLE
977     )
978   );
979   g_object_class_install_property(
980     object_class,
981     PROP_KEEPALIVE,
982     g_param_spec_boxed(
983       "keepalive",
984       "Keepalive",
985       "The keepalive settings for the connection",
986       INF_TYPE_KEEPALIVE,
987       G_PARAM_READWRITE
988     )
989   );
990   g_object_class_install_property(
991     object_class,
992     PROP_REMOTE_ADDRESS,
993     g_param_spec_boxed(
994       "remote-address",
995       "Remote address",
996       "Address to connect to",
997       INF_TYPE_IP_ADDRESS,
998       G_PARAM_READWRITE
999     )
1000   );
1001   g_object_class_install_property(
1002     object_class,
1003     PROP_REMOTE_PORT,
1004     g_param_spec_uint(
1005       "remote-port",
1006       "Remote port",
1007       "Port to connect to",
1008       0,
1009       65535,
1010       0,
1011       G_PARAM_READWRITE
1012     )
1013   );
1014   g_object_class_install_property(
1015     object_class,
1016     PROP_LOCAL_ADDRESS,
1017     g_param_spec_boxed(
1018       "local-address",
1019       "Local address",
1020       "The local address of the connection",
1021       INF_TYPE_IP_ADDRESS,
1022       G_PARAM_READABLE
1023     )
1024   );
1025   g_object_class_install_property(
1026     object_class,
1027     PROP_LOCAL_PORT,
1028     g_param_spec_uint(
1029       "local-port",
1030       "Local port",
1031       "The local port of the connection",
1032       0,
1033       65535,
1034       0,
1035       G_PARAM_READABLE
1036     )
1037   );
1038   g_object_class_install_property(
1039     object_class,
1040     PROP_DEVICE_INDEX,
1041     g_param_spec_uint(
1042       "device-index",
1043       "Device index",
1044       "The index of the device to use for the connection",
1045       0,
1046       G_MAXUINT,
1047       0,
1048       G_PARAM_READWRITE
1049     )
1050   );
1051   g_object_class_install_property(
1052     object_class,
1053     PROP_DEVICE_NAME,
1054     g_param_spec_string(
1055       "device-name",
1056       "Device name",
1057       "The name of the device to use for the connection, such as `eth0'",
1058       NULL,
1059       G_PARAM_READWRITE
1060     )
1061   );
1062   tcp_connection_signals[SENT] = g_signal_new(
1063     "sent",
1064     G_OBJECT_CLASS_TYPE(object_class),
1065     G_SIGNAL_RUN_LAST,
1066     G_STRUCT_OFFSET(InfTcpConnectionClass, sent),
1067     NULL, NULL,
1068     NULL,
1069     G_TYPE_NONE,
1070     2,
1071     G_TYPE_POINTER,
1072     G_TYPE_UINT
1073   );
1074   tcp_connection_signals[RECEIVED] = g_signal_new(
1075     "received",
1076     G_OBJECT_CLASS_TYPE(object_class),
1077     G_SIGNAL_RUN_LAST,
1078     G_STRUCT_OFFSET(InfTcpConnectionClass, received),
1079     NULL, NULL,
1080     NULL,
1081     G_TYPE_NONE,
1082     2,
1083     G_TYPE_POINTER,
1084     G_TYPE_UINT
1085   );
1086   tcp_connection_signals[ERROR_] = g_signal_new(
1087     "error",
1088     G_OBJECT_CLASS_TYPE(object_class),
1089     G_SIGNAL_RUN_LAST,
1090     G_STRUCT_OFFSET(InfTcpConnectionClass, error),
1091     NULL, NULL,
1092     g_cclosure_marshal_VOID__POINTER,
1093     G_TYPE_NONE,
1094     1,
1095     G_TYPE_ERROR
1096   );
1097 }
1098 InfTcpConnection*
1099 inf_tcp_connection_new(InfIo* io,
1100                        const InfIpAddress* remote_addr,
1101                        guint remote_port)
1102 {
1103   InfTcpConnection* tcp;
1104   g_return_val_if_fail(INF_IS_IO(io), NULL);
1105   g_return_val_if_fail(remote_addr != NULL, NULL);
1106   g_return_val_if_fail(remote_port &lt;= 65535, NULL);
1107   tcp = INF_TCP_CONNECTION(
1108     g_object_new(
1109       INF_TYPE_TCP_CONNECTION,
1110       "io", io,
1111       "remote-address", remote_addr,
1112       "remote-port", remote_port,
1113       NULL
1114     )
1115   );
1116   return tcp;
1117 }
1118 InfTcpConnection*
1119 inf_tcp_connection_new_and_open(InfIo* io,
1120                                 const InfIpAddress* remote_addr,
1121                                 guint remote_port,
1122                                 GError** error)
1123 {
1124   InfTcpConnection* tcp;
1125   g_return_val_if_fail(INF_IS_IO(io), NULL);
1126   g_return_val_if_fail(remote_addr != NULL, NULL);
1127   g_return_val_if_fail(remote_port &lt;= 65535, NULL);
1128   g_return_val_if_fail(error == NULL || *error == NULL, NULL);
1129   tcp = inf_tcp_connection_new(io, remote_addr, remote_port);
1130   if(inf_tcp_connection_open(tcp, error) == FALSE)
1131   {
1132     g_object_unref(tcp);
1133     return NULL;
1134   }
1135   return tcp;
1136 }
1137 InfTcpConnection*
1138 inf_tcp_connection_new_resolve(InfIo* io,
1139                                InfNameResolver* resolver)
1140 {
1141   InfTcpConnection* tcp;
1142   g_return_val_if_fail(INF_IS_IO(io), NULL);
1143   g_return_val_if_fail(INF_IS_NAME_RESOLVER(resolver), NULL);
1144   tcp = INF_TCP_CONNECTION(
1145     g_object_new(
1146       INF_TYPE_TCP_CONNECTION,
1147       "io", io,
1148       "resolver", resolver,
1149       NULL
1150     )
1151   );
1152   return tcp;
1153 }
1154 gboolean
1155 inf_tcp_connection_open(InfTcpConnection* connection,
1156                         GError** error)
1157 {
1158   InfTcpConnectionPrivate* priv;
1159   g_return_val_if_fail(INF_IS_TCP_CONNECTION(connection), FALSE);
1160   priv = INF_TCP_CONNECTION_PRIVATE(connection);
1161   g_return_val_if_fail(priv-&gt;io != NULL, FALSE);
1162   g_return_val_if_fail(priv-&gt;status == INF_TCP_CONNECTION_CLOSED, FALSE);
1163   g_return_val_if_fail(
1164     priv-&gt;remote_address != NULL || priv-&gt;resolver != NULL,
1165     FALSE
1166   );
1167   g_return_val_if_fail(
1168     priv-&gt;remote_port != 0 ||
1169     priv-&gt;resolver != NULL,
1170     FALSE
1171   );
1172   if(priv-&gt;resolver != NULL)
1173   {
1174     g_assert(priv-&gt;resolver_index == 0);
1175     return inf_tcp_connection_open_with_resolver(connection, error);
1176   }
1177   else
1178   {
1179     return inf_tcp_connection_open_real(
1180       connection,
1181       priv-&gt;remote_address,
1182       priv-&gt;remote_port,
1183       error
1184     );
1185   }
1186 }
1187 void
1188 inf_tcp_connection_close(InfTcpConnection* connection)
1189 {
1190   InfTcpConnectionPrivate* priv;
1191   g_return_if_fail(INF_IS_TCP_CONNECTION(connection));
1192   priv = INF_TCP_CONNECTION_PRIVATE(connection);
1193   g_return_if_fail(priv-&gt;status != INF_TCP_CONNECTION_CLOSED);
1194   priv-&gt;events = 0;
1195   if(priv-&gt;watch != NULL)
1196   {
1197     inf_io_remove_watch(priv-&gt;io, priv-&gt;watch);
1198     priv-&gt;watch = NULL;
1199   }
1200   priv-&gt;front_pos = 0;
1201   priv-&gt;back_pos = 0;
1202   priv-&gt;status = INF_TCP_CONNECTION_CLOSED;
1203   g_object_notify(G_OBJECT(connection), "status");
1204 }
1205 void
1206 inf_tcp_connection_send(InfTcpConnection* connection,
1207                         gconstpointer data,
1208                         guint len)
1209 {
1210   InfTcpConnectionPrivate* priv;
1211   gconstpointer sent_data;
1212   guint sent_len;
1213   g_return_if_fail(INF_IS_TCP_CONNECTION(connection));
1214   g_return_if_fail(len == 0 || data != NULL);
1215   priv = INF_TCP_CONNECTION_PRIVATE(connection);
1216   g_return_if_fail(priv-&gt;status == INF_TCP_CONNECTION_CONNECTED);
1217   g_object_ref(connection);
1218   if(priv-&gt;front_pos == priv-&gt;back_pos)
1219   {
1220     g_assert(~priv-&gt;events &amp; INF_IO_OUTGOING);
1221     sent_len = len;
1222     sent_data = data;
1223     if(inf_tcp_connection_send_real(connection, data, &amp;sent_len) == TRUE)
1224     {
1225       data = (const char*)data + sent_len;
1226       len -= sent_len;
1227     }
1228     else
1229     {
1230       len = 0;
1231       sent_len = 0;
1232     }
1233   }
1234   else
1235   {
1236     sent_len = 0;
1237   }
1238   if(len &gt; 0)
1239   {
1240     if(priv-&gt;alloc - priv-&gt;front_pos &lt; len &amp;&amp; priv-&gt;back_pos &gt; 0)
1241     {
1242       memmove(
1243         priv-&gt;queue,
1244         priv-&gt;queue + priv-&gt;back_pos,
1245         priv-&gt;front_pos - priv-&gt;back_pos
1246       );
1247       priv-&gt;front_pos -= priv-&gt;back_pos;
1248       priv-&gt;back_pos = 0;
1249     }
1250     if(priv-&gt;alloc - priv-&gt;front_pos &lt; len)
1251     {
1252       priv-&gt;alloc = priv-&gt;front_pos + len;
1253       if(priv-&gt;alloc % 1024 != 0)
1254         priv-&gt;alloc = priv-&gt;alloc + (1024 - priv-&gt;alloc % 1024);
1255       priv-&gt;queue = g_realloc(priv-&gt;queue, priv-&gt;alloc);
1256     }
1257     memcpy(priv-&gt;queue + priv-&gt;front_pos, data, len);
1258     priv-&gt;front_pos += len;
1259     if(~priv-&gt;events &amp; INF_IO_OUTGOING)
1260     {
1261       priv-&gt;events |= INF_IO_OUTGOING;
1262       inf_io_update_watch(priv-&gt;io, priv-&gt;watch, priv-&gt;events);
1263     }
1264   }
1265   if(sent_len &gt; 0)
1266   {
1267     g_signal_emit(
1268       G_OBJECT(connection),
1269       tcp_connection_signals[SENT],
1270       0,
1271       sent_data,
1272       sent_len
1273     );
1274   }
1275   g_object_unref(connection);
1276 }
1277 InfIpAddress*
1278 inf_tcp_connection_get_remote_address(InfTcpConnection* connection)
1279 {
1280   g_return_val_if_fail(INF_IS_TCP_CONNECTION(connection), NULL);
1281   return INF_TCP_CONNECTION_PRIVATE(connection)-&gt;remote_address;
1282 }
1283 guint
1284 inf_tcp_connection_get_remote_port(InfTcpConnection* connection)
1285 {
1286   g_return_val_if_fail(INF_IS_TCP_CONNECTION(connection), 0);
1287   return INF_TCP_CONNECTION_PRIVATE(connection)-&gt;remote_port;
1288 }
1289 gboolean
1290 inf_tcp_connection_set_keepalive(InfTcpConnection* connection,
1291                                  const InfKeepalive* keepalive,
1292                                  GError** error)
1293 {
1294   InfTcpConnectionPrivate* priv;
1295   InfKeepaliveMask mask;
1296   g_return_val_if_fail(INF_IS_TCP_CONNECTION(connection), FALSE);
1297   g_return_val_if_fail(keepalive != NULL, FALSE);
1298   g_return_val_if_fail(error == NULL || *error == NULL, FALSE);
1299   priv = INF_TCP_CONNECTION_PRIVATE(connection);
1300   if(priv-&gt;socket != INVALID_SOCKET)
1301   {
1302     mask = priv-&gt;keepalive.mask;
1303     if(inf_keepalive_apply(keepalive, &amp;priv-&gt;socket, mask, error) != TRUE)
1304       return FALSE;
1305   }
1306   priv-&gt;keepalive = *keepalive;
1307   return TRUE;
1308 }
1309 const InfKeepalive*
1310 inf_tcp_connection_get_keepalive(InfTcpConnection* connection)
1311 {
1312   g_return_val_if_fail(INF_IS_TCP_CONNECTION(connection), NULL);
1313   return &amp;INF_TCP_CONNECTION_PRIVATE(connection)-&gt;keepalive;
1314 }
1315 InfTcpConnection*
1316 _inf_tcp_connection_accepted(InfIo* io,
1317                              InfNativeSocket socket,
1318                              InfIpAddress* address,
1319                              guint port,
1320                              const InfKeepalive* keepalive,
1321                              GError** error)
1322 {
1323   InfTcpConnection* connection;
1324   InfTcpConnectionPrivate* priv;
1325   int errcode;
1326   g_return_val_if_fail(INF_IS_IO(io), NULL);
1327   g_return_val_if_fail(socket != INVALID_SOCKET, NULL);
1328   g_return_val_if_fail(address != NULL, NULL);
1329   g_return_val_if_fail(keepalive != NULL, NULL);
1330   if(inf_tcp_connection_configure_socket(socket, keepalive, error) != TRUE)
1331     return NULL;
1332   g_return_val_if_fail(address != NULL, NULL);
1333   g_return_val_if_fail(port != 0, NULL);
1334   connection = inf_tcp_connection_new(io, address, port);
1335   inf_ip_address_free(address);
1336   priv = INF_TCP_CONNECTION_PRIVATE(connection);
1337   priv-&gt;socket = socket;
1338   priv-&gt;keepalive = *keepalive;
1339   inf_tcp_connection_connected(connection);
1340   return connection;
1341 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
