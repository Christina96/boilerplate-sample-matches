<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-user-table.c &amp; inf-text-session.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-user-table.c &amp; inf-text-session.c
      </h3>
<h1 align="center">
        7.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-user-table.c (16.52174%)<th>inf-text-session.c (4.6625767%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(368-399)<td><a href="#" name="0">(1748-1772)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(223-247)<td><a href="#" name="1">(731-757)</a><td align="center"><font color="#da0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(78-100)<td><a href="#" name="2">(522-552)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-user-table.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/common/inf-user-table.h&gt;
2 #include &lt;libinfinity/inf-signals.h&gt;
3 #include &lt;string.h&gt;
4 typedef struct _InfUserTablePrivate InfUserTablePrivate;
5 struct _InfUserTablePrivate {
6   GHashTable* table;
7   GSList* user_ids;
8   GSList* availables;
9   GSList* locals;
10 };
11 enum {
12   ADD_USER,
13   REMOVE_USER,
14   ADD_AVAILABLE_USER,
15   REMOVE_AVAILABLE_USER,
16   ADD_LOCAL_USER,
17   REMOVE_LOCAL_USER,
18   LAST_SIGNAL
19 };
20 #define INF_USER_TABLE_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_USER_TABLE, InfUserTablePrivate))
21 static guint user_table_signals[LAST_SIGNAL];
22 G_DEFINE_TYPE_WITH_CODE(InfUserTable, inf_user_table, G_TYPE_OBJECT,
23   G_ADD_PRIVATE(InfUserTable))
24 static gboolean
25 inf_user_table_is_local(InfUser* user)
26 {
27   if( (inf_user_get_flags(user) &amp; INF_USER_LOCAL) == 0)
28     return FALSE;
29   if(inf_user_get_status(user) == INF_USER_UNAVAILABLE)
30 <a name="2"></a>    return FALSE;
31   return TRUE;
32 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
33 static void
34 inf_user_table_check_local_cb(GObject* object,
35                               GParamSpec* pspec,
36                               gpointer user_data)
37 {
38   InfUserTable* user_table;
39   InfUserTablePrivate* priv;
40   InfUser* user;
41   GSList* available_item;
42   GSList* local_item;
43   user_table = INF_USER_TABLE(user_data);
44   priv = INF_USER_TABLE_PRIVATE(user_table);
45   user = INF_USER(object);
46   available_item = g_slist_find(priv-&gt;availables, user);
47   local_item = g_slist_find(priv-&gt;locals, user);
48   if(inf_user_get_status(user) != INF_USER_UNAVAILABLE &amp;&amp;
49      available_item == NULL)
50   {</b></font>
51     g_signal_emit(
52       G_OBJECT(user_table),
53       user_table_signals[ADD_AVAILABLE_USER],
54       0,
55       user
56     );
57   }
58   if(inf_user_table_is_local(INF_USER(object)) &amp;&amp; local_item == NULL)
59   {
60     g_signal_emit(
61       G_OBJECT(user_table),
62       user_table_signals[ADD_LOCAL_USER],
63       0,
64       user
65     );
66   }
67   if(!inf_user_table_is_local(INF_USER(object)) &amp;&amp; local_item != NULL)
68   {
69     g_signal_emit(
70       G_OBJECT(user_table),
71       user_table_signals[REMOVE_LOCAL_USER],
72       0,
73       user
74     );
75   }
76   if(inf_user_get_status(user) == INF_USER_UNAVAILABLE &amp;&amp;
77      available_item != NULL)
78   {
79     g_signal_emit(
80       G_OBJECT(user_table),
81       user_table_signals[REMOVE_AVAILABLE_USER],
82       0,
83       user
84     );
85   }
86 }
87 static void
88 inf_user_table_unref_user(InfUserTable* user_table,
89                           InfUser* user)
90 {
91   inf_signal_handlers_disconnect_by_func(
92     G_OBJECT(user),
93     G_CALLBACK(inf_user_table_check_local_cb),
94     user_table
95   );
96   g_object_unref(user);
97 }
98 static void
99 inf_user_table_dispose_foreach_func(gpointer key,
100                                     gpointer value,
101                                     gpointer user_data)
102 {
103   inf_user_table_unref_user(INF_USER_TABLE(user_data), INF_USER(value));
104 }
105 static gboolean
106 inf_user_table_lookup_user_by_name_func(gpointer key,
107                                         gpointer value,
108                                         gpointer data)
109 {
110   const gchar* user_name;
111   user_name = inf_user_get_name(INF_USER(value));
112   if(strcmp(user_name, (const gchar*)data) == 0) return TRUE;
113   return FALSE;
114 }
115 static gint
116 inf_user_ids_list_sort_compare_func(gconstpointer a,
117                                     gconstpointer b)
118 {
119   return GPOINTER_TO_UINT(a) - GPOINTER_TO_UINT(b);
120 }
121 static void
122 inf_user_table_init(InfUserTable* user_table)
123 {
124   InfUserTablePrivate* priv;
125   priv = INF_USER_TABLE_PRIVATE(user_table);
126   priv-&gt;table = g_hash_table_new_full(NULL, NULL, NULL, NULL);
127   priv-&gt;user_ids = NULL;
128   priv-&gt;availables = NULL;
129   priv-&gt;locals = NULL;
130 }
131 static void
132 inf_user_table_dispose(GObject* object)
133 {
134   InfUserTable* user_table;
135   InfUserTablePrivate* priv;
136   user_table = INF_USER_TABLE(object);
137   priv = INF_USER_TABLE_PRIVATE(user_table);
138   g_slist_free(priv-&gt;locals);
139   priv-&gt;locals = NULL;
140   g_slist_free(priv-&gt;availables);
141   priv-&gt;availables = NULL;
142   g_slist_free(priv-&gt;user_ids);
143   priv-&gt;user_ids = NULL;
144   g_hash_table_foreach(
145     priv-&gt;table,
146     inf_user_table_dispose_foreach_func,
147     user_table
148   );
149 <a name="1"></a>
150   g_hash_table_remove_all(priv-&gt;table);
151   G_OBJECT_CLASS(inf_user_table_parent_class)-&gt;dispose(object);
152 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
153 static void
154 inf_user_table_finalize(GObject* object)
155 {
156   InfUserTable* user_table;
157   InfUserTablePrivate* priv;
158   user_table = INF_USER_TABLE(object);
159   priv = INF_USER_TABLE_PRIVATE(user_table);
160   g_hash_table_destroy(priv-&gt;table);
161   G_OBJECT_CLASS(inf_user_table_parent_class)-&gt;finalize(object);
162 }
163 static void
164 inf_user_table_add_user_handler(InfUserTable* user_table,
165                                 InfUser* user)
166 {
167   InfUserTablePrivate* priv;
168   guint id;
169   priv = INF_USER_TABLE_PRIVATE(user_table);
170   id = inf_user_get_id(user);</b></font>
171   g_assert(id &gt; 0);
172   g_assert(g_hash_table_lookup(priv-&gt;table, GUINT_TO_POINTER(id)) == NULL);
173   g_hash_table_insert(priv-&gt;table, GUINT_TO_POINTER(id), user);
174   g_object_ref(user);
175   priv-&gt;user_ids = g_slist_insert_sorted(
176     priv-&gt;user_ids,
177     GUINT_TO_POINTER(id),
178     inf_user_ids_list_sort_compare_func
179   );
180   g_signal_connect(
181     G_OBJECT(user),
182     "notify::status",
183     G_CALLBACK(inf_user_table_check_local_cb),
184     user_table
185   );
186   if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
187   {
188     g_signal_emit(
189       G_OBJECT(user_table),
190       user_table_signals[ADD_AVAILABLE_USER],
191       0,
192       user
193     );
194   }
195   if(inf_user_table_is_local(user))
196   {
197     g_signal_emit(
198       G_OBJECT(user_table),
199       user_table_signals[ADD_LOCAL_USER],
200       0,
201       user
202     );
203   }
204 }
205 static void
206 inf_user_table_remove_user_handler(InfUserTable* user_table,
207                                    InfUser* user)
208 {
209   InfUserTablePrivate* priv;
210   guint id;
211   priv = INF_USER_TABLE_PRIVATE(user_table);
212   id = inf_user_get_id(user);
213   if(inf_user_table_is_local(user))
214   {
215     g_signal_emit(
216       G_OBJECT(user_table),
217       user_table_signals[REMOVE_LOCAL_USER],
218       0,
219       user
220     );
221   }
222   if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
223   {
224     g_signal_emit(
225       G_OBJECT(user_table),
226       user_table_signals[REMOVE_AVAILABLE_USER],
227       0,
228       user
229     );
230   }
231   priv-&gt;user_ids = g_slist_remove(priv-&gt;user_ids, GUINT_TO_POINTER(id));
232   inf_user_table_unref_user(user_table, user);
233   g_assert(g_hash_table_lookup(priv-&gt;table, GUINT_TO_POINTER(id)) == user);
234   g_hash_table_remove(priv-&gt;table, GUINT_TO_POINTER(id));
235 }
236 static void
237 inf_user_table_add_available_user(InfUserTable* user_table,
238                                   InfUser* user)
239 {
240   InfUserTablePrivate* priv;
241   priv = INF_USER_TABLE_PRIVATE(user_table);
242   g_assert(g_slist_find(priv-&gt;availables, user) == NULL);
243   priv-&gt;availables = g_slist_prepend(priv-&gt;availables, user);
244 }
245 static void
246 inf_user_table_remove_available_user(InfUserTable* user_table,
247                                      InfUser* user)
248 {
249   InfUserTablePrivate* priv;
250   priv = INF_USER_TABLE_PRIVATE(user_table);
251   g_assert(g_slist_find(priv-&gt;availables, user) != NULL);
252   priv-&gt;availables = g_slist_remove(priv-&gt;availables, user);
253 }
254 static void
255 inf_user_table_add_local_user(InfUserTable* user_table,
256                               InfUser* user)
257 {
258   InfUserTablePrivate* priv;
259   priv = INF_USER_TABLE_PRIVATE(user_table);
260   g_assert(g_slist_find(priv-&gt;locals, user) == NULL);
261   priv-&gt;locals = g_slist_prepend(priv-&gt;locals, user);
262 }
263 static void
264 inf_user_table_remove_local_user(InfUserTable* user_table,
265                                  InfUser* user)
266 {
267   InfUserTablePrivate* priv;
268   priv = INF_USER_TABLE_PRIVATE(user_table);
269 <a name="0"></a>
270   g_assert(g_slist_find(priv-&gt;locals, user) != NULL);
271   priv-&gt;locals = g_slist_remove(priv-&gt;locals, user);
272 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
273 static void
274 inf_user_table_class_init(InfUserTableClass* user_table_class)
275 {
276   GObjectClass* object_class;
277   object_class = G_OBJECT_CLASS(user_table_class);
278   object_class-&gt;dispose = inf_user_table_dispose;
279   object_class-&gt;finalize = inf_user_table_finalize;
280   user_table_class-&gt;add_user = inf_user_table_add_user_handler;
281   user_table_class-&gt;remove_user = inf_user_table_remove_user_handler;
282   user_table_class-&gt;add_available_user = inf_user_table_add_available_user;
283   user_table_class-&gt;remove_available_user =
284     inf_user_table_remove_available_user;
285   user_table_class-&gt;add_local_user = inf_user_table_add_local_user;
286   user_table_class-&gt;remove_local_user = inf_user_table_remove_local_user;
287   user_table_signals[ADD_USER] = g_signal_new(</b></font>
288     "add-user",
289     G_OBJECT_CLASS_TYPE(object_class),
290     G_SIGNAL_RUN_LAST,
291     G_STRUCT_OFFSET(InfUserTableClass, add_user),
292     NULL, NULL,
293     g_cclosure_marshal_VOID__OBJECT,
294     G_TYPE_NONE,
295     1,
296     INF_TYPE_USER
297   );
298   user_table_signals[REMOVE_USER] = g_signal_new(
299     "remove-user",
300     G_OBJECT_CLASS_TYPE(object_class),
301     G_SIGNAL_RUN_LAST,
302     G_STRUCT_OFFSET(InfUserTableClass, remove_user),
303     NULL, NULL,
304     g_cclosure_marshal_VOID__OBJECT,
305     G_TYPE_NONE,
306     1,
307     INF_TYPE_USER
308   );
309   user_table_signals[ADD_AVAILABLE_USER] = g_signal_new(
310     "add-available-user",
311     G_OBJECT_CLASS_TYPE(object_class),
312     G_SIGNAL_RUN_LAST,
313     G_STRUCT_OFFSET(InfUserTableClass, add_available_user),
314     NULL, NULL,
315     g_cclosure_marshal_VOID__OBJECT,
316     G_TYPE_NONE,
317     1,
318     INF_TYPE_USER
319   );
320   user_table_signals[REMOVE_AVAILABLE_USER] = g_signal_new(
321     "remove-available-user",
322     G_OBJECT_CLASS_TYPE(object_class),
323     G_SIGNAL_RUN_LAST,
324     G_STRUCT_OFFSET(InfUserTableClass, remove_available_user),
325     NULL, NULL,
326     g_cclosure_marshal_VOID__OBJECT,
327     G_TYPE_NONE,
328     1,
329     INF_TYPE_USER
330   );
331   user_table_signals[ADD_LOCAL_USER] = g_signal_new(
332     "add-local-user",
333     G_OBJECT_CLASS_TYPE(object_class),
334     G_SIGNAL_RUN_LAST,
335     G_STRUCT_OFFSET(InfUserTableClass, add_local_user),
336     NULL, NULL,
337     g_cclosure_marshal_VOID__OBJECT,
338     G_TYPE_NONE,
339     1,
340     INF_TYPE_USER
341   );
342   user_table_signals[REMOVE_LOCAL_USER] = g_signal_new(
343     "remove-local-user",
344     G_OBJECT_CLASS_TYPE(object_class),
345     G_SIGNAL_RUN_LAST,
346     G_STRUCT_OFFSET(InfUserTableClass, remove_local_user),
347     NULL, NULL,
348     g_cclosure_marshal_VOID__OBJECT,
349     G_TYPE_NONE,
350     1,
351     INF_TYPE_USER
352   );
353 }
354 InfUserTable*
355 inf_user_table_new(void)
356 {
357   return INF_USER_TABLE(g_object_new(INF_TYPE_USER_TABLE, NULL));
358 }
359 void
360 inf_user_table_add_user(InfUserTable* user_table,
361                         InfUser* user)
362 {
363   g_return_if_fail(INF_IS_USER_TABLE(user_table));
364   g_return_if_fail(INF_IS_USER(user));
365   g_signal_emit(G_OBJECT(user_table), user_table_signals[ADD_USER], 0, user);
366 }
367 void
368 inf_user_table_remove_user(InfUserTable* user_table,
369                            InfUser* user)
370 {
371   g_return_if_fail(INF_IS_USER_TABLE(user_table));
372   g_return_if_fail(INF_IS_USER(user));
373   g_signal_emit(
374     G_OBJECT(user_table),
375     user_table_signals[REMOVE_USER],
376     0,
377     user
378   );
379 }
380 InfUser*
381 inf_user_table_lookup_user_by_id(InfUserTable* user_table,
382                                  guint id)
383 {
384   InfUserTablePrivate* priv;
385   g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);
386   priv = INF_USER_TABLE_PRIVATE(user_table);
387   return INF_USER(g_hash_table_lookup(priv-&gt;table, GUINT_TO_POINTER(id)));
388 }
389 InfUser*
390 inf_user_table_lookup_user_by_name(InfUserTable* user_table,
391                                    const gchar* name)
392 {
393   InfUserTablePrivate* priv;
394   InfUser* user;
395   g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);
396   g_return_val_if_fail(name != NULL, NULL);
397   priv = INF_USER_TABLE_PRIVATE(user_table);
398   user = g_hash_table_find(
399     priv-&gt;table,
400     inf_user_table_lookup_user_by_name_func,
401     *(gpointer*) (gpointer) &amp;name   );
402   return user;
403 }
404 void
405 inf_user_table_foreach_user(InfUserTable* user_table,
406                             InfUserTableForeachUserFunc func,
407                             gpointer user_data)
408 {
409   InfUserTablePrivate* priv;
410   InfUser* user;
411   GSList* item;
412   guint user_id;
413   g_return_if_fail(INF_IS_USER_TABLE(user_table));
414   g_return_if_fail(func != NULL);
415   priv = INF_USER_TABLE_PRIVATE(user_table);
416   for(item = priv-&gt;user_ids; item != NULL; item = g_slist_next(item))
417   {
418     user_id = GPOINTER_TO_UINT(item-&gt;data);
419     user = inf_user_table_lookup_user_by_id(user_table, user_id);
420     func(user, user_data);
421   }
422 }
423 void
424 inf_user_table_foreach_local_user(InfUserTable* user_table,
425                                   InfUserTableForeachUserFunc func,
426                                   gpointer user_data)
427 {
428   InfUserTablePrivate* priv;
429   GSList* item;
430   g_return_if_fail(INF_IS_USER_TABLE(user_table));
431   g_return_if_fail(func != NULL);
432   priv = INF_USER_TABLE_PRIVATE(user_table);
433   for(item = priv-&gt;locals; item != NULL; item = g_slist_next(item))
434     func(INF_USER(item-&gt;data), user_data);
435 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-session.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinftext/inf-text-session.h&gt;
2 #include &lt;libinftext/inf-text-default-insert-operation.h&gt;
3 #include &lt;libinftext/inf-text-default-delete-operation.h&gt;
4 #include &lt;libinftext/inf-text-remote-delete-operation.h&gt;
5 #include &lt;libinftext/inf-text-insert-operation.h&gt;
6 #include &lt;libinftext/inf-text-delete-operation.h&gt;
7 #include &lt;libinftext/inf-text-move-operation.h&gt;
8 #include &lt;libinftext/inf-text-chunk.h&gt;
9 #include &lt;libinftext/inf-text-user.h&gt;
10 #include &lt;libinfinity/adopted/inf-adopted-no-operation.h&gt;
11 #include &lt;libinfinity/common/inf-xml-util.h&gt;
12 #include &lt;libinfinity/common/inf-error.h&gt;
13 #include &lt;libinfinity/inf-i18n.h&gt;
14 #include &lt;libinfinity/inf-signals.h&gt;
15 #include &lt;libxml/tree.h&gt;
16 #include &lt;string.h&gt;
17 #include &lt;errno.h&gt;
18 typedef struct _InfTextSessionLocalUser InfTextSessionLocalUser;
19 struct _InfTextSessionLocalUser {
20   InfTextSession* session;
21   InfTextUser* user;
22   GTimeVal last_caret_update;
23   InfIoTimeout* caret_timeout;
24 };
25 typedef struct _InfTextSessionPrivate InfTextSessionPrivate;
26 struct _InfTextSessionPrivate {
27   guint caret_update_interval;
28   GSList* local_users;
29 };
30 enum {
31   PROP_0,
32   PROP_CARET_UPDATE_INTERVAL
33 };
34 typedef struct _InfTextSessionInsertForeachData
35   InfTextSessionInsertForeachData;
36 typedef struct _InfTextSessionEraseForeachData
37   InfTextSessionEraseForeachData;
38 struct _InfTextSessionInsertForeachData {
39   guint position;
40   InfTextChunk* chunk;
41   InfUser* user;
42 };
43 struct _InfTextSessionEraseForeachData {
44   guint position;
45   guint length;
46   InfUser* user;
47 };
48 #define INF_TEXT_SESSION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_TYPE_SESSION, InfTextSessionPrivate))
49 static GQuark inf_text_session_error_quark;
50 G_DEFINE_TYPE_WITH_CODE(InfTextSession, inf_text_session, INF_ADOPTED_TYPE_SESSION,
51   G_ADD_PRIVATE(InfTextSession))
52 static guint
53 inf_text_session_timeval_diff(GTimeVal* first,
54                               GTimeVal* second)
55 {
56   g_assert(first-&gt;tv_sec &gt; second-&gt;tv_sec ||
57            (first-&gt;tv_sec == second-&gt;tv_sec &amp;&amp;
58             first-&gt;tv_usec &gt;= second-&gt;tv_usec));
59   return (first-&gt;tv_sec - second-&gt;tv_sec) * 1000 +
60          (first-&gt;tv_usec+500)/1000 - (second-&gt;tv_usec+500)/1000;
61 }
62 static void
63 inf_text_session_segment_to_xml(GIConv* cd,
64                                 xmlNodePtr xml,
65                                 gconstpointer text,
66                                 gsize* bytes,                                 guint author)
67 {
68   gchar utf8_text[1024];
69   gsize result;
70   gsize bytes_left;
71   gchar* inbuf;
72   gchar* outbuf;
73   bytes_left = 1024;
74   inbuf = *(gchar**)(gpointer)&amp;text;   outbuf = utf8_text;
75   result = g_iconv(
76     *cd,
77     &amp;inbuf,
78     bytes,
79     &amp;outbuf,
80     &amp;bytes_left
81   );
82   g_assert(result == 0 || errno == E2BIG);
83   inf_xml_util_add_child_text(xml, utf8_text, 1024 - bytes_left);
84   inf_xml_util_set_attribute_uint(xml, "author", author);
85 }
86 static gpointer
87 inf_text_session_segment_from_xml(GIConv* cd,
88                                   xmlNodePtr xml,
89                                   guint* length,
90                                   gsize* bytes,
91                                   guint* author,
92                                   GError** error)
93 {
94   gsize bytes_read;
95   gchar* utf8_text;
96   gpointer text;
97   if(!inf_xml_util_get_attribute_uint_required(xml, "author", author, error))
98     return NULL;
99   utf8_text = inf_xml_util_get_child_text(xml, &amp;bytes_read, length, error);
100   if(!utf8_text)
101     return NULL;
102   text = g_convert_with_iconv(
103     utf8_text,
104     bytes_read,
105     *cd,
106     NULL,
107     bytes,
108     error
109   );
110   g_free(utf8_text);
111   return text;
112 }
113 static InfTextSessionLocalUser*
114 inf_text_session_find_local_user(InfTextSession* session,
115                                  InfTextUser* user)
116 {
117   InfTextSessionPrivate* priv;
118   GSList* item;
119   InfTextSessionLocalUser* local;
120   priv = INF_TEXT_SESSION_PRIVATE(session);
121   for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
122   {
123     local = (InfTextSessionLocalUser*)item-&gt;data;
124     if(local-&gt;user == user)
125       return local;
126   }
127   return NULL;
128 }
129 static void
130 inf_text_session_broadcast_caret_selection(InfTextSession* session,
131                                            InfTextSessionLocalUser* local)
132 {
133   InfAdoptedOperation* operation;
134   InfAdoptedAlgorithm* algorithm;
135   InfAdoptedRequest* request;
136   guint buf_len;
137   guint position;
138   int sel;
139   guint end;
140   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
141   position = inf_text_user_get_caret_position(local-&gt;user);
142   sel = inf_text_user_get_selection_length(local-&gt;user);
143   end = position + sel;
144   buf_len = inf_text_buffer_get_length(
145     INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)))
146   );
147   if(position &gt; buf_len)
148     position = buf_len;
149   if(end &gt; buf_len)
150     end = buf_len;
151   if(end &gt;= position)
152     sel = (int)(end - position);
153   else
154     sel = -(int)(position - end);
155   operation = INF_ADOPTED_OPERATION(
156     inf_text_move_operation_new(position, sel)
157   );
158   request = inf_adopted_algorithm_generate_request(
159     algorithm,
160     INF_ADOPTED_REQUEST_DO,
161     INF_ADOPTED_USER(local-&gt;user),
162     operation
163   );
164   inf_adopted_algorithm_execute_request(algorithm, request, FALSE, NULL);
165   g_object_unref(operation);
166   inf_adopted_session_broadcast_request(
167     INF_ADOPTED_SESSION(session),
168     request
169   );
170   g_object_unref(request);
171   g_get_current_time(&amp;local-&gt;last_caret_update);
172   if(local-&gt;caret_timeout != NULL)
173   {
174     inf_io_remove_timeout(
175       inf_adopted_session_get_io(INF_ADOPTED_SESSION(session)),
176       local-&gt;caret_timeout
177     );
178     local-&gt;caret_timeout = NULL;
179   }
180 }
181 static void
182 inf_text_session_caret_update_timeout_func(gpointer user_data)
183 {
184   InfTextSessionLocalUser* local;
185   local = (InfTextSessionLocalUser*)user_data;
186   local-&gt;caret_timeout = NULL;
187   inf_text_session_broadcast_caret_selection(local-&gt;session, local);
188 }
189 static void
190 inf_text_session_selection_changed_cb(InfTextUser* user,
191                                       guint position,
192                                       gint sel,
193                                       gboolean by_request,
194                                       gpointer user_data)
195 {
196   InfTextSession* session;
197   InfTextSessionPrivate* priv;
198   InfAdoptedAlgorithm* algorithm;
199   InfAdoptedRequest* execute_request;
200   InfTextSessionLocalUser* local;
201   GTimeVal current;
202   guint diff;
203   session = INF_TEXT_SESSION(user_data);
204   priv = INF_TEXT_SESSION_PRIVATE(session);
205   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
206   execute_request = inf_adopted_algorithm_get_execute_request(algorithm);
207   g_assert( (execute_request != NULL &amp;&amp; by_request == FALSE) ||
208             (execute_request == NULL &amp;&amp; by_request == TRUE));
209   if(execute_request == NULL)
210   {
211     local = inf_text_session_find_local_user(session, user);
212     g_assert(local != NULL);
213     g_get_current_time(&amp;current);
214     diff = inf_text_session_timeval_diff(&amp;current, &amp;local-&gt;last_caret_update);
215     if(diff &lt; priv-&gt;caret_update_interval)
216     {
217       if(local-&gt;caret_timeout == NULL)
218       {
219         local-&gt;caret_timeout = inf_io_add_timeout(
220           inf_adopted_session_get_io(INF_ADOPTED_SESSION(local-&gt;session)),
221           priv-&gt;caret_update_interval - diff,
222           inf_text_session_caret_update_timeout_func,
223           local,
224           NULL
225         );
226       }
227     }
228     else
229     {
230       inf_text_session_broadcast_caret_selection(session, local);
231     }
232   }
233 }
234 static void
235 inf_text_session_add_local_user(InfTextSession* session,
236                                 InfTextUser* user)
237 {
238   InfTextSessionPrivate* priv;
239   InfTextSessionLocalUser* local;
240   priv = INF_TEXT_SESSION_PRIVATE(session);
241   local = g_slice_new(InfTextSessionLocalUser);
242   local-&gt;session = session;
243   local-&gt;user = user;
244   g_get_current_time(&amp;local-&gt;last_caret_update);
245   local-&gt;caret_timeout = NULL;
246   priv-&gt;local_users = g_slist_prepend(priv-&gt;local_users, local);
247   g_signal_connect_after(
248     G_OBJECT(user),
249     "selection-changed",
250     G_CALLBACK(inf_text_session_selection_changed_cb),
251     session
252   );
253 }
254 static void
255 inf_text_session_remove_local_user(InfTextSession* session,
256                                    InfTextSessionLocalUser* local)
257 {
258   InfTextSessionPrivate* priv;
259   priv = INF_TEXT_SESSION_PRIVATE(session);
260   if(local-&gt;caret_timeout != NULL)
261   {
262     inf_io_remove_timeout(
263       inf_adopted_session_get_io(INF_ADOPTED_SESSION(session)),
264       local-&gt;caret_timeout
265     );
266   }
267   inf_signal_handlers_disconnect_by_func(
268     G_OBJECT(local-&gt;user),
269     G_CALLBACK(inf_text_session_selection_changed_cb),
270     session
271   );
272   g_slice_free(InfTextSessionLocalUser, local);
273   priv-&gt;local_users = g_slist_remove(priv-&gt;local_users, local);
274 }
275 static void
276 inf_text_session_local_user_added_cb(InfUserTable* user_table,
277                                      InfUser* user,
278                                      gpointer user_data)
279 {
280   g_assert(INF_TEXT_IS_USER(user));
281   inf_text_session_add_local_user(
282     INF_TEXT_SESSION(user_data),
283     INF_TEXT_USER(user)
284   );
285 }
286 static void
287 inf_text_session_local_user_removed_cb(InfUserTable* user_table,
288                                        InfUser* user,
289                                        gpointer user_data)
290 {
291   InfTextSession* session;
292   InfTextSessionLocalUser* local;
293   g_assert(INF_TEXT_IS_USER(user));
294   session = INF_TEXT_SESSION(user_data);
295   local = inf_text_session_find_local_user(session, INF_TEXT_USER(user));
296   g_assert(local != NULL);
297   inf_text_session_remove_local_user(session, local);
298 }
299 static void
300 inf_text_session_block_local_users_selection_changed(InfTextSession* session)
301 {
302   InfTextSessionPrivate* priv;
303   GSList* item;
304   InfTextSessionLocalUser* local;
305   priv = INF_TEXT_SESSION_PRIVATE(session);
306   for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
307   {
308     local = (InfTextSessionLocalUser*)item-&gt;data;
309     inf_signal_handlers_block_by_func(
310       G_OBJECT(local-&gt;user),
311       G_CALLBACK(inf_text_session_selection_changed_cb),
312       session
313     );
314   }
315 }
316 static void
317 inf_text_session_unblock_local_users_selection_changed(InfTextSession* sess)
318 {
319   InfTextSessionPrivate* priv;
320   GSList* item;
321   InfTextSessionLocalUser* local;
322   priv = INF_TEXT_SESSION_PRIVATE(sess);
323   for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
324   {
325     local = (InfTextSessionLocalUser*)item-&gt;data;
326     inf_signal_handlers_unblock_by_func(
327       G_OBJECT(local-&gt;user),
328       G_CALLBACK(inf_text_session_selection_changed_cb),
329       sess
330     );
331   }
332 }
333 static void
334 inf_text_session_buffer_text_inserted_cb_foreach_func(InfUser* user,
335                                                       gpointer user_data)
336 {
337   InfTextSessionInsertForeachData* data;
338   guint position;
339   gint length;
340   data = (InfTextSessionInsertForeachData*)user_data;
341   if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
342   {
343     position = inf_text_user_get_caret_position(INF_TEXT_USER(user));
344     length = inf_text_user_get_selection_length(INF_TEXT_USER(user));
345     inf_text_move_operation_transform_insert(
346       data-&gt;position,
347       inf_text_chunk_get_length(data-&gt;chunk),
348       &amp;position,
349       &amp;length,
350       user == data-&gt;user ? FALSE : TRUE
351     );
352     inf_text_user_set_selection(
353       INF_TEXT_USER(user),
354       position,
355       length,
356       user == data-&gt;user ? TRUE : FALSE
357     );
358   }
359 }
360 static void
361 inf_text_session_buffer_text_erased_cb_foreach_func(InfUser* user,
362                                                     gpointer user_data)
363 {
364   InfTextSessionEraseForeachData* data;
365   guint position;
366   gint length;
367   data = (InfTextSessionEraseForeachData*)user_data;
368   if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
369   {
370     position = inf_text_user_get_caret_position(INF_TEXT_USER(user));
371     length = inf_text_user_get_selection_length(INF_TEXT_USER(user));
372     inf_text_move_operation_transform_delete(
373       data-&gt;position,
374       data-&gt;length,
375       &amp;position,
376       &amp;length
377     );
378     inf_text_user_set_selection(
379       INF_TEXT_USER(user),
380       position,
381       length,
382 <a name="2"></a>      user == data-&gt;user ? TRUE : FALSE
383     );
384   }
385 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
386 static void
387 inf_text_session_buffer_text_inserted_cb(InfTextBuffer* buffer,
388                                          guint pos,
389                                          InfTextChunk* chunk,
390                                          InfUser* user,
391                                          gpointer user_data)
392 {
393   InfTextSession* session;
394   InfTextSessionPrivate* priv;
395   InfUserTable* user_table;
396   InfAdoptedAlgorithm* algorithm;
397   InfAdoptedRequest* execute_request;
398   InfAdoptedOperation* operation;
399   InfAdoptedRequest* request;
400   InfTextSessionInsertForeachData data;
401   g_assert(INF_TEXT_IS_USER(user));
402   session = INF_TEXT_SESSION(user_data);
403   priv = INF_TEXT_SESSION_PRIVATE(session);
404   user_table = inf_session_get_user_table(INF_SESSION(session));
405   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
406   execute_request = inf_adopted_algorithm_get_execute_request(algorithm);
407   if(execute_request == NULL)
408   {</b></font>
409     operation = INF_ADOPTED_OPERATION(
410       inf_text_default_insert_operation_new(pos, chunk)
411     );
412     request = inf_adopted_algorithm_generate_request(
413       algorithm,
414       INF_ADOPTED_REQUEST_DO,
415       INF_ADOPTED_USER(user),
416       operation
417     );
418     inf_adopted_algorithm_execute_request(algorithm, request, FALSE, NULL);
419     inf_adopted_session_broadcast_request(
420       INF_ADOPTED_SESSION(session),
421       request
422     );
423     g_object_unref(request);
424     g_object_unref(operation);
425   }
426   data.position = pos;
427   data.chunk = chunk;
428   data.user = user;
429   inf_text_session_block_local_users_selection_changed(session);
430   inf_user_table_foreach_user(
431     user_table,
432     inf_text_session_buffer_text_inserted_cb_foreach_func,
433     &amp;data
434   );
435 #if 0
436   if(user != NULL)
437   {
438     inf_text_user_set_selection(
439       INF_TEXT_USER(user),
440       pos + inf_text_chunk_get_length(chunk),
441       0,
442       TRUE
443     );
444   }
445 #endif
446   inf_text_session_unblock_local_users_selection_changed(session);
447 }
448 static void
449 inf_text_session_buffer_text_erased_cb(InfTextBuffer* buffer,
450                                        guint pos,
451                                        InfTextChunk* chunk,
452                                        InfUser* user,
453                                        gpointer user_data)
454 {
455   InfTextSession* session;
456   InfTextSessionPrivate* priv;
457   InfUserTable* user_table;
458   InfAdoptedAlgorithm* algorithm;
459   InfAdoptedRequest* execute_request;
460   InfAdoptedOperation* operation;
461   InfAdoptedRequest* request;
462   InfTextSessionEraseForeachData data;
463   g_assert(INF_TEXT_IS_USER(user));
464   session = INF_TEXT_SESSION(user_data);
465   priv = INF_TEXT_SESSION_PRIVATE(session);
466   user_table = inf_session_get_user_table(INF_SESSION(session));
467   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
468   execute_request = inf_adopted_algorithm_get_execute_request(algorithm);
469   if(execute_request == NULL)
470   {
471     operation = INF_ADOPTED_OPERATION(
472       inf_text_default_delete_operation_new(pos, chunk)
473     );
474     request = inf_adopted_algorithm_generate_request(
475       algorithm,
476       INF_ADOPTED_REQUEST_DO,
477       INF_ADOPTED_USER(user),
478       operation
479     );
480     inf_adopted_algorithm_execute_request(algorithm, request, FALSE, NULL);
481     inf_adopted_session_broadcast_request(
482       INF_ADOPTED_SESSION(session),
483       request
484     );
485     g_object_unref(request);
486     g_object_unref(operation);
487   }
488   data.position = pos;
489   data.length = inf_text_chunk_get_length(chunk);
490   data.user = user;
491   inf_text_session_block_local_users_selection_changed(session);
492   inf_user_table_foreach_user(
493     user_table,
494     inf_text_session_buffer_text_erased_cb_foreach_func,
495     &amp;data
496   );
497 #if 0
498   if(user != NULL)
499     inf_text_user_set_selection(INF_TEXT_USER(user), pos, 0, TRUE);
500 #endif
501   inf_text_session_unblock_local_users_selection_changed(session);
502 }
503 static void
504 inf_text_session_init_text_handlers_user_foreach_func(InfUser* user,
505                                                       gpointer user_data)
506 {
507   g_assert(INF_TEXT_IS_USER(user));
508   inf_text_session_add_local_user(
509     INF_TEXT_SESSION(user_data),
510     INF_TEXT_USER(user)
511   );
512 }
513 static void
514 inf_text_session_init_text_handlers(InfTextSession* session)
515 {
516   InfTextBuffer* buffer;
517   InfAdoptedAlgorithm* algorithm;
518   InfUserTable* user_table;
519   buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
520   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
521   user_table = inf_session_get_user_table(INF_SESSION(session));
522   g_signal_connect(
523     G_OBJECT(buffer),
524     "text-inserted",
525     G_CALLBACK(inf_text_session_buffer_text_inserted_cb),
526     session
527   );
528   g_signal_connect(
529     G_OBJECT(buffer),
530     "text-erased",
531     G_CALLBACK(inf_text_session_buffer_text_erased_cb),
532     session
533   );
534   g_signal_connect(
535     G_OBJECT(user_table),
536     "add-local-user",
537     G_CALLBACK(inf_text_session_local_user_added_cb),
538     session
539   );
540   g_signal_connect(
541     G_OBJECT(user_table),
542     "remove-local-user",
543     G_CALLBACK(inf_text_session_local_user_removed_cb),
544     session
545   );
546   inf_user_table_foreach_local_user(
547     user_table,
548 <a name="1"></a>    inf_text_session_init_text_handlers_user_foreach_func,
549     session
550   );
551 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
552 static void
553 inf_text_session_init(InfTextSession* session)
554 {
555   InfTextSessionPrivate* priv;
556   priv = INF_TEXT_SESSION_PRIVATE(session);
557   priv-&gt;caret_update_interval = 500;
558 }
559 static void
560 inf_text_session_constructed(GObject* object)
561 {
562   InfTextSession* session;
563   InfTextSessionPrivate* priv;
564   InfTextBuffer* buffer;
565   InfSessionStatus status;
566   G_OBJECT_CLASS(inf_text_session_parent_class)-&gt;constructed(object);
567   session = INF_TEXT_SESSION(object);
568   priv = INF_TEXT_SESSION_PRIVATE(session);</b></font>
569   buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
570   g_object_get(G_OBJECT(session), "status", &amp;status, NULL);
571   g_assert(
572     status == INF_SESSION_RUNNING ||
573     inf_text_buffer_get_length(buffer) == 0
574   );
575   if(status == INF_SESSION_RUNNING)
576     inf_text_session_init_text_handlers(session);
577 }
578 static void
579 inf_text_session_dispose(GObject* object)
580 {
581   InfTextSession* session;
582   InfTextSessionPrivate* priv;
583   InfTextBuffer* buffer;
584   InfUserTable* user_table;
585   InfAdoptedAlgorithm* algorithm;
586   session = INF_TEXT_SESSION(object);
587   priv = INF_TEXT_SESSION_PRIVATE(session);
588   buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
589   user_table = inf_session_get_user_table(INF_SESSION(session));
590   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
591   while(priv-&gt;local_users != NULL)
592   {
593     inf_text_session_remove_local_user(
594       session,
595       (InfTextSessionLocalUser*)priv-&gt;local_users-&gt;data
596     );
597   }
598   inf_signal_handlers_disconnect_by_func(
599     G_OBJECT(buffer),
600     G_CALLBACK(inf_text_session_buffer_text_inserted_cb),
601     session
602   );
603   inf_signal_handlers_disconnect_by_func(
604     G_OBJECT(buffer),
605     G_CALLBACK(inf_text_session_buffer_text_erased_cb),
606     session
607   );
608   inf_signal_handlers_disconnect_by_func(
609     G_OBJECT(user_table),
610     G_CALLBACK(inf_text_session_local_user_added_cb),
611     session
612   );
613   inf_signal_handlers_disconnect_by_func(
614     G_OBJECT(user_table),
615     G_CALLBACK(inf_text_session_local_user_removed_cb),
616     session
617   );
618   G_OBJECT_CLASS(inf_text_session_parent_class)-&gt;dispose(object);
619 }
620 static void
621 inf_text_session_finalize(GObject* object)
622 {
623   InfTextSession* session;
624   InfTextSessionPrivate* priv;
625   session = INF_TEXT_SESSION(object);
626   priv = INF_TEXT_SESSION_PRIVATE(session);
627   G_OBJECT_CLASS(inf_text_session_parent_class)-&gt;finalize(object);
628 }
629 static void
630 inf_text_session_set_property(GObject* object,
631                               guint prop_id,
632                               const GValue* value,
633                               GParamSpec* pspec)
634 {
635   InfTextSession* session;
636   InfTextSessionPrivate* priv;
637   session = INF_TEXT_SESSION(object);
638   priv = INF_TEXT_SESSION_PRIVATE(session);
639   switch(prop_id)
640   {
641   case PROP_CARET_UPDATE_INTERVAL:
642     priv-&gt;caret_update_interval = g_value_get_uint(value);
643     break;
644   default:
645     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
646     break;
647   }
648 }
649 static void
650 inf_text_session_get_property(GObject* object,
651                               guint prop_id,
652                               GValue* value,
653                               GParamSpec* pspec)
654 {
655   InfTextSession* session;
656   InfTextSessionPrivate* priv;
657   session = INF_TEXT_SESSION(object);
658   priv = INF_TEXT_SESSION_PRIVATE(session);
659   switch(prop_id)
660   {
661   case PROP_CARET_UPDATE_INTERVAL:
662     g_value_set_uint(value, priv-&gt;caret_update_interval);
663     break;
664   default:
665     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
666     break;
667   }
668 }
669 static InfCommunicationScope
670 inf_text_session_handle_user_color_change(InfTextSession* session,
671                                           InfXmlConnection* connection,
672                                           xmlNodePtr xml,
673                                           GError** error)
674 {
675   InfUserTable* user_table;
676   guint user_id;
677   InfUser* user;
678   gdouble hue;
679   user_table = inf_session_get_user_table(INF_SESSION(session));
680   if(!inf_xml_util_get_attribute_uint_required(xml, "id", &amp;user_id, error))
681     return INF_COMMUNICATION_SCOPE_PTP;
682   if(!inf_xml_util_get_attribute_double_required(xml, "hue", &amp;hue, error))
683     return INF_COMMUNICATION_SCOPE_PTP;
684   user = inf_user_table_lookup_user_by_id(user_table, user_id);
685   if(user == NULL)
686   {
687     g_set_error(
688       error,
689       inf_user_error_quark(),
690       INF_USER_ERROR_NO_SUCH_USER,
691       _("No such user with ID '%u'"),
692       user_id
693     );
694     return INF_COMMUNICATION_SCOPE_PTP;
695   }
696   if(inf_user_get_status(user) == INF_USER_UNAVAILABLE ||
697      inf_user_get_connection(user) != connection)
698   {
699     g_set_error_literal(
700       error,
701       inf_user_error_quark(),
702       INF_USER_ERROR_NOT_JOINED,
703       _("User did not join from this connection")
704     );
705     return INF_COMMUNICATION_SCOPE_PTP;
706   }
707   g_assert(INF_TEXT_IS_USER(user));
708   if(hue &lt; 0.0 || hue &gt; 1.0)
709   {
710     g_set_error(
711       error,
712       inf_text_session_error_quark,
713       INF_TEXT_SESSION_ERROR_INVALID_HUE,
714       _("Invalid hue value: '%g'"),
715       hue
716     );
717     return INF_COMMUNICATION_SCOPE_PTP;
718   }
719   g_object_set(G_OBJECT(user), "hue", hue, NULL);
720   return INF_COMMUNICATION_SCOPE_GROUP;
721 }
722 static void
723 inf_text_session_to_xml_sync(InfSession* session,
724                              xmlNodePtr parent)
725 {
726   InfTextBuffer* buffer;
727   InfTextBufferIter* iter;
728   xmlNodePtr xml;
729   gboolean result;
730   gchar* text;
731   gsize total_bytes;
732   gsize bytes_left;
733   GIConv cd;
734   INF_SESSION_CLASS(inf_text_session_parent_class)-&gt;to_xml_sync(
735     session,
736     parent
737   );
738   buffer = INF_TEXT_BUFFER(inf_session_get_buffer(session));
739   cd = g_iconv_open("UTF-8", inf_text_buffer_get_encoding(buffer));
740   iter = inf_text_buffer_create_begin_iter(buffer);
741   if(iter != NULL)
742   {
743     result = TRUE;
744     while(result == TRUE)
745     {
746       text = inf_text_buffer_iter_get_text(buffer, iter);
747       total_bytes = inf_text_buffer_iter_get_bytes(buffer, iter);
748       bytes_left = total_bytes;
749       while(bytes_left &gt; 0)
750       {
751         xml = xmlNewChild(parent, NULL, (const xmlChar*)"sync-segment", NULL);
752         inf_text_session_segment_to_xml(
753           &amp;cd,
754           xml,
755           text + total_bytes - bytes_left,
756           &amp;bytes_left,
757           inf_text_buffer_iter_get_author(buffer, iter)
758         );
759       }
760       g_free(text);
761       result = inf_text_buffer_iter_next(buffer, iter);
762     }
763     inf_text_buffer_destroy_iter(buffer, iter);
764   }
765   g_iconv_close(cd);
766 }
767 static gboolean
768 inf_text_session_process_xml_sync(InfSession* session,
769                                   InfXmlConnection* connection,
770                                   const xmlNodePtr xml,
771                                   GError** error)
772 {
773   InfTextBuffer* buffer;
774   GIConv cd;
775   gpointer text;
776   gsize bytes;
777   guint length;
778   guint author;
779   InfUser* user;
780   if(strcmp((const char*)xml-&gt;name, "sync-segment") == 0)
781   {
782     buffer = INF_TEXT_BUFFER(inf_session_get_buffer(session));
783     cd = g_iconv_open(inf_text_buffer_get_encoding(buffer), "UTF-8");
784     text = inf_text_session_segment_from_xml(
785       &amp;cd,
786       xml,
787       &amp;length,
788       &amp;bytes,
789       &amp;author,
790       error
791     );
792     g_iconv_close(cd);
793     if(text == NULL) return FALSE;
794     if(author != 0)
795     {
796       user = inf_user_table_lookup_user_by_id(
797         inf_session_get_user_table(session),
798         author
799       );
800       if(user == NULL)
801       {
802         g_free(text);
803         g_set_error(
804           error,
805           inf_user_error_quark(),
806           INF_USER_ERROR_NO_SUCH_USER,
807           _("No such user with ID '%u'"),
808           author
809         );
810         return FALSE;
811       }
812     }
813     else
814     {
815       user = NULL;
816     }
817     inf_text_buffer_insert_text(
818       buffer,
819       inf_text_buffer_get_length(buffer),
820       text,
821       bytes,
822       length,
823       user
824     );
825     g_free(text);
826     return TRUE;
827   }
828   else
829   {
830     return INF_SESSION_CLASS(inf_text_session_parent_class)-&gt;process_xml_sync(
831       session,
832       connection,
833       xml,
834       error
835     );
836   }
837 }
838 static InfCommunicationScope
839 inf_text_session_process_xml_run(InfSession* session,
840                                  InfXmlConnection* connection,
841                                  const xmlNodePtr xml,
842                                  GError** error)
843 {
844   if(strcmp((const char*)xml-&gt;name, "user-color-change") == 0)
845   {
846     return inf_text_session_handle_user_color_change(
847       INF_TEXT_SESSION(session),
848       connection,
849       xml,
850       error
851     );
852   }
853   else
854   {
855     return INF_SESSION_CLASS(inf_text_session_parent_class)-&gt;process_xml_run(
856       session,
857       connection,
858       xml,
859       error
860     );
861   }
862 }
863 static GArray*
864 inf_text_session_get_xml_user_props(InfSession* session,
865                                     InfXmlConnection* connection,
866                                     const xmlNodePtr xml)
867 {
868   InfSessionClass* parent_class;
869   GArray* array;
870   GParameter* parameter;
871   guint caret;
872   gint selection;
873   gdouble hue;
874   parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
875   array = parent_class-&gt;get_xml_user_props(session, connection, xml);
876   if(inf_xml_util_get_attribute_uint(xml, "caret", &amp;caret, NULL))
877   {
878     parameter = inf_session_get_user_property(array, "caret-position");
879     g_value_init(&amp;parameter-&gt;value, G_TYPE_UINT);
880     g_value_set_uint(&amp;parameter-&gt;value, caret);
881   }
882   parameter = inf_session_get_user_property(array, "selection-length");
883   g_value_init(&amp;parameter-&gt;value, G_TYPE_INT);
884   if(inf_xml_util_get_attribute_int(xml, "selection", &amp;selection, NULL))
885     g_value_set_int(&amp;parameter-&gt;value, selection);
886   else
887     g_value_set_int(&amp;parameter-&gt;value, 0);
888   parameter = inf_session_get_user_property(array, "hue");
889   g_value_init(&amp;parameter-&gt;value, G_TYPE_DOUBLE);
890   if(inf_xml_util_get_attribute_double(xml, "hue", &amp;hue, NULL))
891     g_value_set_double(&amp;parameter-&gt;value, hue);
892   else
893     g_value_set_double(&amp;parameter-&gt;value, g_random_double());
894   return array;
895 }
896 static void
897 inf_text_session_set_xml_user_props(InfSession* session,
898                                     const GParameter* params,
899                                     guint n_params,
900                                     xmlNodePtr xml)
901 {
902   InfSessionClass* parent_class;
903   const GParameter* param;
904   parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
905   parent_class-&gt;set_xml_user_props(session, params, n_params, xml);
906   param = inf_session_lookup_user_property(
907     params,
908     n_params,
909     "caret-position"
910   );
911   if(param != NULL)
912   {
913     inf_xml_util_set_attribute_uint(
914       xml,
915       "caret",
916       g_value_get_uint(&amp;param-&gt;value)
917     );
918   }
919   param = inf_session_lookup_user_property(
920     params,
921     n_params,
922     "selection-length"
923   );
924   if(param != NULL)
925   {
926     inf_xml_util_set_attribute_int(
927       xml,
928       "selection",
929       g_value_get_int(&amp;param-&gt;value)
930     );
931   }
932   param = inf_session_lookup_user_property(
933     params,
934     n_params,
935     "hue"
936   );
937   if(param != NULL)
938   {
939     inf_xml_util_set_attribute_double(
940       xml,
941       "hue",
942       g_value_get_double(&amp;param-&gt;value)
943     );
944   }
945 }
946 static gboolean
947 inf_text_session_validate_user_props(InfSession* session,
948                                      const GParameter* params,
949                                      guint n_params,
950                                      InfUser* exclude,
951                                      GError** error)
952 {
953   InfSessionClass* parent_class;
954   const GParameter* caret;
955   gboolean result;
956   parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
957   result = parent_class-&gt;validate_user_props(
958     session,
959     params,
960     n_params,
961     exclude,
962     error
963   );
964   if(result == FALSE) return FALSE;
965   caret = inf_session_lookup_user_property(
966     params,
967     n_params,
968     "caret-position"
969   );
970   if(caret == NULL)
971   {
972     g_set_error_literal(
973       error,
974       inf_request_error_quark(),
975       INF_REQUEST_ERROR_NO_SUCH_ATTRIBUTE,
976       _("\"caret\" attribute in user message is missing")
977     );
978     return FALSE;
979   }
980   return result;
981 }
982 static InfUser*
983 inf_text_session_user_new(InfSession* session,
984                           GParameter* params,
985                           guint n_params)
986 {
987   GObject* object;
988   object = g_object_newv(INF_TEXT_TYPE_USER, n_params, params);
989   return INF_USER(object);
990 }
991 static void
992 inf_text_session_synchronization_complete(InfSession* session,
993                                           InfXmlConnection* connection)
994 {
995   InfSessionClass* parent_class;
996   InfSessionStatus status;
997   parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
998   status = inf_session_get_status(session);
999   parent_class-&gt;synchronization_complete(session, connection);
1000   if(status == INF_SESSION_SYNCHRONIZING)
1001     inf_text_session_init_text_handlers(INF_TEXT_SESSION(session));
1002 }
1003 static void
1004 inf_text_session_request_to_xml(InfAdoptedSession* session,
1005                                 xmlNodePtr xml,
1006                                 InfAdoptedRequest* request,
1007                                 InfAdoptedStateVector* diff_vec,
1008                                 gboolean for_sync)
1009 {
1010   InfTextChunk* chunk;
1011   InfTextChunkIter iter;
1012   gboolean result;
1013   xmlNodePtr op_xml;
1014   gchar* utf8_text;
1015   gsize bytes_read;
1016   gsize bytes_written;
1017   GIConv cd;
1018   xmlNodePtr child;
1019   const gchar* text;
1020   gsize total_bytes;
1021   gsize bytes_left;
1022   InfAdoptedOperation* operation;
1023   switch(inf_adopted_request_get_request_type(request))
1024   {
1025   case INF_ADOPTED_REQUEST_DO:
1026     operation = inf_adopted_request_get_operation(request);
1027     if(INF_TEXT_IS_INSERT_OPERATION(operation))
1028     {
1029       op_xml = xmlNewNode(NULL, (const xmlChar*)"insert-caret");
1030       inf_xml_util_set_attribute_uint(
1031         op_xml,
1032         "pos",
1033         inf_text_insert_operation_get_position(
1034           INF_TEXT_INSERT_OPERATION(operation)
1035         )
1036       );
1037       g_assert(INF_TEXT_IS_DEFAULT_INSERT_OPERATION(operation));
1038       chunk = inf_text_default_insert_operation_get_chunk(
1039         INF_TEXT_DEFAULT_INSERT_OPERATION(operation)
1040       );
1041       result = inf_text_chunk_iter_init_begin(chunk, &amp;iter);
1042       g_assert(result == TRUE);
1043       utf8_text = g_convert(
1044         inf_text_chunk_iter_get_text(&amp;iter),
1045         inf_text_chunk_iter_get_bytes(&amp;iter),
1046         "UTF-8",
1047         inf_text_chunk_get_encoding(chunk),
1048         &amp;bytes_read,
1049         &amp;bytes_written,
1050         NULL
1051       );
1052       g_assert(utf8_text != NULL);
1053       g_assert(bytes_read == inf_text_chunk_iter_get_bytes(&amp;iter));
1054       inf_xml_util_add_child_text(op_xml, utf8_text, bytes_written);
1055       g_free(utf8_text);
1056       g_assert(inf_text_chunk_iter_next(&amp;iter) == FALSE);
1057     }
1058     else if(INF_TEXT_IS_DELETE_OPERATION(operation))
1059     {
1060       op_xml = xmlNewNode(NULL, (const xmlChar*)"delete-caret");
1061       inf_xml_util_set_attribute_uint(
1062         op_xml,
1063         "pos",
1064         inf_text_delete_operation_get_position(
1065           INF_TEXT_DELETE_OPERATION(operation)
1066         )
1067       );
1068       if(for_sync == TRUE)
1069       {
1070         g_assert(INF_TEXT_IS_DEFAULT_DELETE_OPERATION(operation));
1071         chunk = inf_text_default_delete_operation_get_chunk(
1072           INF_TEXT_DEFAULT_DELETE_OPERATION(operation)
1073         );
1074         cd = g_iconv_open("UTF-8", inf_text_chunk_get_encoding(chunk));
1075         result = inf_text_chunk_iter_init_begin(chunk, &amp;iter);
1076         while(result == TRUE)
1077         {
1078           text = inf_text_chunk_iter_get_text(&amp;iter);
1079           total_bytes = inf_text_chunk_iter_get_bytes(&amp;iter);
1080           bytes_left = total_bytes;
1081           child = xmlNewChild(op_xml, NULL, (const xmlChar*)"segment", NULL);
1082           while(bytes_left &gt; 0)
1083           {
1084             inf_text_session_segment_to_xml(
1085               &amp;cd,
1086               child,
1087               text + total_bytes - bytes_left,
1088               &amp;bytes_left,
1089               inf_text_chunk_iter_get_author(&amp;iter)
1090             );
1091           }
1092           result = inf_text_chunk_iter_next(&amp;iter);
1093         }
1094         g_iconv_close(cd);
1095       }
1096       else
1097       {
1098         inf_xml_util_set_attribute_uint(
1099           op_xml,
1100           "len",
1101           inf_text_delete_operation_get_length(
1102             INF_TEXT_DELETE_OPERATION(operation)
1103           )
1104         );
1105       }
1106     }
1107     else if(for_sync == FALSE &amp;&amp; INF_TEXT_IS_MOVE_OPERATION(operation))
1108     {
1109       op_xml = xmlNewNode(NULL, (const xmlChar*)"move");
1110       inf_xml_util_set_attribute_uint(
1111         op_xml,
1112         "caret",
1113         inf_text_move_operation_get_position(
1114           INF_TEXT_MOVE_OPERATION(operation)
1115         )
1116       );
1117       inf_xml_util_set_attribute_int(
1118         op_xml,
1119         "selection",
1120         inf_text_move_operation_get_length(INF_TEXT_MOVE_OPERATION(operation))
1121       );
1122     }
1123     else if(for_sync == FALSE &amp;&amp; INF_ADOPTED_IS_NO_OPERATION(operation))
1124     {
1125       op_xml = xmlNewNode(NULL, (const xmlChar*)"no-op");
1126     }
1127     else
1128     {
1129       g_assert_not_reached();
1130     }
1131     break;
1132   case INF_ADOPTED_REQUEST_UNDO:
1133     op_xml = xmlNewNode(NULL, (const xmlChar*)"undo-caret");
1134     break;
1135   case INF_ADOPTED_REQUEST_REDO:
1136     op_xml = xmlNewNode(NULL, (const xmlChar*)"redo-caret");
1137     break;
1138   default:
1139     g_assert_not_reached();
1140     break;
1141   }
1142   g_assert(op_xml != NULL);
1143   inf_adopted_session_write_request_info(
1144     session,
1145     request,
1146     diff_vec,
1147     xml,
1148     op_xml
1149   );
1150 }
1151 static InfAdoptedRequest*
1152 inf_text_session_xml_to_request(InfAdoptedSession* session,
1153                                 xmlNodePtr xml,
1154                                 InfAdoptedStateVector* diff_vec,
1155                                 gboolean for_sync,
1156                                 GError** error)
1157 {
1158   InfTextBuffer* buffer;
1159   InfAdoptedUser* user;
1160   guint user_id;
1161   InfAdoptedStateVector* vector;
1162   xmlNodePtr op_xml;
1163   InfAdoptedOperation* operation;
1164   InfAdoptedRequestType type;
1165   InfAdoptedRequest* request;
1166   guint pos;
1167   gchar* text;
1168   gsize bytes;
1169   InfTextChunk* chunk;
1170   gchar* utf8_text;
1171   gsize in_bytes;
1172   guint length;
1173   xmlNodePtr child;
1174   GIConv cd;
1175   guint author;
1176   gboolean cmp;
1177   gint selection;
1178   buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
1179   cmp = inf_adopted_session_read_request_info(
1180     session,
1181     xml,
1182     diff_vec,
1183     &amp;user,
1184     &amp;vector,
1185     &amp;op_xml,
1186     error
1187   );
1188   if(cmp == FALSE) return FALSE;
1189   user_id = (user == NULL) ? 0 : inf_user_get_id(INF_USER(user));
1190   if(strcmp((const char*)op_xml-&gt;name, "insert") == 0 ||
1191      strcmp((const char*)op_xml-&gt;name, "insert-caret") == 0)
1192   {
1193     type = INF_ADOPTED_REQUEST_DO;
1194     if(!inf_xml_util_get_attribute_uint_required(op_xml, "pos", &amp;pos, error))
1195       goto fail;
1196     utf8_text = inf_xml_util_get_child_text(op_xml, &amp;in_bytes, &amp;length, error);
1197     if(!utf8_text)
1198       goto fail;
1199     text = g_convert(
1200       utf8_text,
1201       in_bytes,
1202       inf_text_buffer_get_encoding(buffer),
1203       "UTF-8",
1204       NULL,
1205       &amp;bytes,
1206       error
1207     );
1208     g_free(utf8_text);
1209     if(text == NULL) goto fail;
1210     chunk = inf_text_chunk_new(inf_text_buffer_get_encoding(buffer));
1211     inf_text_chunk_insert_text(chunk, 0, text, bytes, length, user_id);
1212     g_free(text);
1213     operation = INF_ADOPTED_OPERATION(
1214       inf_text_default_insert_operation_new(pos, chunk)
1215     );
1216     inf_text_chunk_free(chunk);
1217   }
1218   else if(strcmp((const char*)op_xml-&gt;name, "delete") == 0 ||
1219           strcmp((const char*)op_xml-&gt;name, "delete-caret") == 0)
1220   {
1221     type = INF_ADOPTED_REQUEST_DO;
1222     if(!inf_xml_util_get_attribute_uint_required(op_xml, "pos", &amp;pos, error))
1223       goto fail;
1224     if(for_sync == TRUE)
1225     {
1226       chunk = inf_text_chunk_new(inf_text_buffer_get_encoding(buffer));
1227       cd = g_iconv_open(inf_text_buffer_get_encoding(buffer), "UTF-8");
1228       g_assert(cd != (GIConv)(-1));
1229       for(child = op_xml-&gt;children; child != NULL; child = child-&gt;next)
1230       {
1231         if(strcmp((const char*)child-&gt;name, "segment") == 0)
1232         {
1233           text = inf_text_session_segment_from_xml(
1234             &amp;cd,
1235             child,
1236             &amp;length,
1237             &amp;bytes,
1238             &amp;author,
1239             error
1240           );
1241           if(text == NULL)
1242           {
1243             inf_text_chunk_free(chunk);
1244             g_iconv_close(cd);
1245             goto fail;
1246           }
1247           else
1248           {
1249             inf_text_chunk_insert_text(
1250               chunk,
1251               inf_text_chunk_get_length(chunk),
1252               text,
1253               bytes,
1254               length,
1255               author
1256             );
1257             g_free(text);
1258           }
1259         }
1260         else
1261         {
1262         }
1263       }
1264       g_iconv_close(cd);
1265       operation = INF_ADOPTED_OPERATION(
1266         inf_text_default_delete_operation_new(pos, chunk)
1267       );
1268       inf_text_chunk_free(chunk);
1269     }
1270     else
1271     {
1272       cmp = inf_xml_util_get_attribute_uint_required(
1273         op_xml,
1274         "len",
1275         &amp;length,
1276         error
1277       );
1278       if(cmp == FALSE) goto fail;
1279       operation = INF_ADOPTED_OPERATION(
1280         inf_text_remote_delete_operation_new(pos, length)
1281       );
1282     }
1283   }
1284   else if(strcmp((const char*)op_xml-&gt;name, "move") == 0)
1285   {
1286     type = INF_ADOPTED_REQUEST_DO;
1287     cmp = inf_xml_util_get_attribute_uint_required(
1288       op_xml,
1289       "caret",
1290       &amp;pos,
1291       error
1292     );
1293     if(cmp == FALSE) goto fail;
1294     cmp = inf_xml_util_get_attribute_int_required(
1295       op_xml,
1296       "selection",
1297       &amp;selection,
1298       error
1299     );
1300     if(cmp == FALSE) goto fail;
1301     operation = INF_ADOPTED_OPERATION(
1302       inf_text_move_operation_new(pos, selection)
1303     );
1304   }
1305   else if(strcmp((const char*)op_xml-&gt;name, "no-op") == 0)
1306   {
1307     type = INF_ADOPTED_REQUEST_DO;
1308     operation = INF_ADOPTED_OPERATION(inf_adopted_no_operation_new());
1309   }
1310   else if(strcmp((const char*)op_xml-&gt;name, "undo") == 0 ||
1311           strcmp((const char*)op_xml-&gt;name, "undo-caret") == 0)
1312   {
1313     type = INF_ADOPTED_REQUEST_UNDO;
1314   }
1315   else if(strcmp((const char*)op_xml-&gt;name, "redo") == 0 ||
1316           strcmp((const char*)op_xml-&gt;name, "redo-caret") == 0)
1317   {
1318     type = INF_ADOPTED_REQUEST_REDO;
1319   }
1320   else
1321   {
1322     goto fail;
1323   }
1324   switch(type)
1325   {
1326   case INF_ADOPTED_REQUEST_DO:
1327     g_assert(operation != NULL);
1328     request = inf_adopted_request_new_do(
1329       vector,
1330       user_id,
1331       operation,
1332       g_get_real_time()
1333     );
1334     g_object_unref(operation);
1335     break;
1336   case INF_ADOPTED_REQUEST_UNDO:
1337     request = inf_adopted_request_new_undo(
1338       vector,
1339       user_id,
1340       g_get_real_time()
1341     );
1342     break;
1343   case INF_ADOPTED_REQUEST_REDO:
1344     request = inf_adopted_request_new_redo(
1345       vector,
1346       user_id,
1347       g_get_real_time()
1348     );
1349     break;
1350   default:
1351     g_assert_not_reached();
1352     break;
1353   }
1354   inf_adopted_state_vector_free(vector);
1355   return request;
1356 <a name="0"></a>fail:
1357   inf_adopted_state_vector_free(vector);
1358   return NULL;
1359 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
1360 static void
1361 inf_text_session_class_init(InfTextSessionClass* text_session_class)
1362 {
1363   GObjectClass* object_class;
1364   InfSessionClass* session_class;
1365   InfAdoptedSessionClass* adopted_session_class;
1366   object_class = G_OBJECT_CLASS(text_session_class);
1367   session_class = INF_SESSION_CLASS(text_session_class);
1368   adopted_session_class = INF_ADOPTED_SESSION_CLASS(text_session_class);
1369   object_class-&gt;constructed = inf_text_session_constructed;
1370   object_class-&gt;dispose = inf_text_session_dispose;
1371   object_class-&gt;finalize = inf_text_session_finalize;
1372   object_class-&gt;set_property = inf_text_session_set_property;
1373   object_class-&gt;get_property = inf_text_session_get_property;
1374   session_class-&gt;to_xml_sync = inf_text_session_to_xml_sync;
1375   session_class-&gt;process_xml_sync = inf_text_session_process_xml_sync;</b></font>
1376   session_class-&gt;process_xml_run = inf_text_session_process_xml_run;
1377   session_class-&gt;get_xml_user_props = inf_text_session_get_xml_user_props;
1378   session_class-&gt;set_xml_user_props = inf_text_session_set_xml_user_props;
1379   session_class-&gt;validate_user_props = inf_text_session_validate_user_props;
1380   session_class-&gt;user_new = inf_text_session_user_new;
1381   session_class-&gt;synchronization_complete =
1382     inf_text_session_synchronization_complete;
1383   adopted_session_class-&gt;xml_to_request = inf_text_session_xml_to_request;
1384   adopted_session_class-&gt;request_to_xml = inf_text_session_request_to_xml;
1385   inf_text_session_error_quark = g_quark_from_static_string(
1386     "INF_TEXT_SESSION_ERROR"
1387   );
1388   g_object_class_install_property(
1389     object_class,
1390     PROP_CARET_UPDATE_INTERVAL,
1391     g_param_spec_uint(
1392       "caret-update-interval",
1393       "Caret update interval",
1394       "Minimum number of milliseconds between caret update broadcasts",
1395       0,
1396       G_MAXUINT,
1397       500,
1398       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
1399     )
1400   );
1401 }
1402 InfTextSession*
1403 inf_text_session_new(InfCommunicationManager* manager,
1404                      InfTextBuffer* buffer,
1405                      InfIo* io,
1406                      InfSessionStatus status,
1407                      InfCommunicationGroup* sync_group,
1408                      InfXmlConnection* sync_connection)
1409 {
1410   GObject* object;
1411   g_return_val_if_fail(INF_COMMUNICATION_IS_MANAGER(manager), NULL);
1412   g_return_val_if_fail(INF_TEXT_IS_BUFFER(buffer), NULL);
1413   g_return_val_if_fail(INF_IS_IO(io), NULL);
1414   g_return_val_if_fail(
1415     (status == INF_SESSION_RUNNING &amp;&amp;
1416      sync_group == NULL &amp;&amp; sync_connection == NULL) ||
1417     (status != INF_SESSION_RUNNING &amp;&amp;
1418      INF_COMMUNICATION_IS_GROUP(sync_group) &amp;&amp;
1419      INF_IS_XML_CONNECTION(sync_connection)),
1420     NULL
1421   );
1422   object = g_object_new(
1423     INF_TEXT_TYPE_SESSION,
1424     "communication-manager", manager,
1425     "buffer", buffer,
1426     "status", status,
1427     "sync-group", sync_group,
1428     "sync-connection", sync_connection,
1429     "io", io,
1430     NULL
1431   );
1432   return INF_TEXT_SESSION(object);
1433 }
1434 InfTextSession*
1435 inf_text_session_new_with_user_table(InfCommunicationManager* manager,
1436                                      InfTextBuffer* buffer,
1437                                      InfIo* io,
1438                                      InfUserTable* user_table,
1439                                      InfSessionStatus status,
1440                                      InfCommunicationGroup* sync_group,
1441                                      InfXmlConnection* sync_connection)
1442 {
1443   GObject* object;
1444   g_return_val_if_fail(INF_COMMUNICATION_IS_MANAGER(manager), NULL);
1445   g_return_val_if_fail(INF_TEXT_IS_BUFFER(buffer), NULL);
1446   g_return_val_if_fail(INF_IS_IO(io), NULL);
1447   g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);
1448   g_return_val_if_fail(
1449     (status == INF_SESSION_RUNNING &amp;&amp;
1450      sync_group == NULL &amp;&amp; sync_connection == NULL) ||
1451     (status != INF_SESSION_RUNNING &amp;&amp;
1452      INF_COMMUNICATION_IS_GROUP(sync_group) &amp;&amp;
1453      INF_IS_XML_CONNECTION(sync_connection)),
1454     NULL
1455   );
1456   object = g_object_new(
1457     INF_TEXT_TYPE_SESSION,
1458     "communication-manager", manager,
1459     "buffer", buffer,
1460     "user-table", user_table,
1461     "status", status,
1462     "sync-group", sync_group,
1463     "sync-connection", sync_connection,
1464     "io", io,
1465     NULL
1466   );
1467   return INF_TEXT_SESSION(object);
1468 }
1469 void
1470 inf_text_session_set_user_color(InfTextSession* session,
1471                                 InfTextUser* user,
1472                                 gdouble hue)
1473 {
1474   xmlNodePtr xml;
1475   g_return_if_fail(INF_TEXT_IS_SESSION(session));
1476   g_return_if_fail(INF_TEXT_IS_USER(user));
1477   g_return_if_fail(hue &gt;= 0.0 &amp;&amp; hue &lt;= 1.0);
1478   g_return_if_fail(
1479     inf_user_get_status(INF_USER(user)) != INF_USER_UNAVAILABLE
1480   );
1481   g_return_if_fail(
1482     (inf_user_get_flags(INF_USER(user)) &amp; INF_USER_LOCAL) != 0
1483   );
1484   xml = xmlNewNode(NULL, (const xmlChar*)"user-color-change");
1485   inf_xml_util_set_attribute_uint(xml, "id", inf_user_get_id(INF_USER(user)));
1486   inf_xml_util_set_attribute_double(xml, "hue", hue);
1487   inf_session_send_to_subscriptions(INF_SESSION(session), xml);
1488   g_object_set(G_OBJECT(user), "hue", hue, NULL);
1489 }
1490 void
1491 inf_text_session_flush_requests_for_user(InfTextSession* session,
1492                                          InfTextUser* user)
1493 {
1494   InfTextSessionLocalUser* local;
1495   g_return_if_fail(INF_TEXT_IS_SESSION(session));
1496   g_return_if_fail(INF_TEXT_IS_USER(user));
1497   local = inf_text_session_find_local_user(session, user);
1498   g_assert(local != NULL);
1499   if(local-&gt;caret_timeout != NULL)
1500   {
1501     inf_text_session_broadcast_caret_selection(session, local);
1502   }
1503 }
1504 InfRequest*
1505 inf_text_session_join_user(InfSessionProxy* proxy,
1506                            const gchar* name,
1507                            InfUserStatus status,
1508                            gdouble hue,
1509                            guint caret_position,
1510                            int selection_length,
1511                            InfRequestFunc func,
1512                            gpointer user_data)
1513 {
1514 #define N_PARAMS 6u
1515   GParameter params[N_PARAMS] = {
1516     { "hue", { 0 } },
1517     { "vector", { 0 } },
1518     { "caret-position", { 0 } },
1519     { "selection-length", { 0 } },
1520     { "name", { 0 } },
1521     { "status", { 0 } }
1522   };
1523   InfSession* session;
1524   InfRequest* request;
1525   guint i;
1526   g_return_val_if_fail(INF_IS_SESSION_PROXY(proxy), NULL);
1527   g_object_get(G_OBJECT(proxy), "session", &amp;session, NULL);
1528   g_return_val_if_fail(INF_TEXT_IS_SESSION(session), NULL);
1529   g_value_init(&amp;params[0].value, G_TYPE_DOUBLE);
1530   g_value_set_double(&amp;params[0].value, hue);
1531   g_value_init(&amp;params[1].value, INF_ADOPTED_TYPE_STATE_VECTOR);
1532   g_value_set_boxed(
1533     &amp;params[1].value,
1534     inf_adopted_algorithm_get_current(
1535       inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session))
1536     )
1537   );
1538   g_value_init(&amp;params[2].value, G_TYPE_UINT);
1539   g_value_set_uint(&amp;params[2].value, caret_position);
1540   g_value_init(&amp;params[3].value, G_TYPE_INT);
1541   g_value_set_int(&amp;params[3].value, selection_length);
1542   g_value_init(&amp;params[4].value, G_TYPE_STRING);
1543   g_value_set_string(&amp;params[4].value, name); 
1544   g_value_init(&amp;params[5].value, INF_TYPE_USER_STATUS);
1545   g_value_set_enum(&amp;params[5].value, status);
1546   request = inf_session_proxy_join_user(
1547     proxy,
1548     N_PARAMS,
1549     params,
1550     func,
1551     user_data
1552   );
1553   for(i = 0; i &lt; N_PARAMS; ++i)
1554     g_value_unset(&amp;params[i].value);
1555 #undef N_PARAMS
1556   g_object_unref(session);
1557   return request;
1558 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
