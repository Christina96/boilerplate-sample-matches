<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for inf-user-table.c & inf-text-session.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for inf-user-table.c & inf-text-session.c
      </h3>
      <h1 align="center">
        7.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>inf-user-table.c (16.52174%)<TH>inf-text-session.c (4.6625767%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1507-0.html#0',2,'match1507-1.html#0',3)" NAME="0">(368-399)<TD><A HREF="javascript:ZweiFrames('match1507-0.html#0',2,'match1507-1.html#0',3)" NAME="0">(1748-1772)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1507-0.html#1',2,'match1507-1.html#1',3)" NAME="1">(223-247)<TD><A HREF="javascript:ZweiFrames('match1507-0.html#1',2,'match1507-1.html#1',3)" NAME="1">(731-757)</A><TD ALIGN=center><FONT COLOR="#da0000">12</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match1507-0.html#2',2,'match1507-1.html#2',3)" NAME="2">(78-100)<TD><A HREF="javascript:ZweiFrames('match1507-0.html#2',2,'match1507-1.html#2',3)" NAME="2">(522-552)</A><TD ALIGN=center><FONT COLOR="#da0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-user-table.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include &lt;libinfinity/common/inf-user-table.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;

#include &lt;string.h&gt;

/**
 * SECTION:inf-user-table
 * @title: InfUserTable
 * @short_description: User information storage
 * @include: libinfinity/common/inf-user-table.h
 * @see_also: #InfUser, #InfSession
 * @stability: Unstable
 *
 * #InfUserTable manages multiple #InfUser objects and provides an easy way to
 * look up users by their ID and name. All users within a user table must have
 * a unique ID and name. The user table is used by #InfSession to store the
 * users within the session.
 */

typedef struct _InfUserTablePrivate InfUserTablePrivate;
struct _InfUserTablePrivate {
  GHashTable* table;
  /* To be able to iterate users in sorted order */
  GSList* user_ids;
  /* TODO: It would be smarter to map the hash table to a helper struct
   * which stores the user availability, locality and the InfUser object */
  GSList* availables;
  GSList* locals;
};

enum {
  ADD_USER,
  REMOVE_USER,
  ADD_AVAILABLE_USER,
  REMOVE_AVAILABLE_USER,
  ADD_LOCAL_USER,
  REMOVE_LOCAL_USER,

  LAST_SIGNAL
};

#define INF_USER_TABLE_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_USER_TABLE, InfUserTablePrivate))

static guint user_table_signals[LAST_SIGNAL];

G_DEFINE_TYPE_WITH_CODE(InfUserTable, inf_user_table, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfUserTable))

static gboolean
inf_user_table_is_local(InfUser* user)
{
  /* User counts as local when it has the local flag set and is available */
  if( (inf_user_get_flags(user) &amp; INF_USER_LOCAL) == 0)
    return FALSE;
  if(inf_user_get_status(user) == INF_USER_UNAVAILABLE)
<A NAME="2"></A>    return FALSE;

  return TRUE;
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match1507-1.html#2',3,'match1507-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

static void
inf_user_table_check_local_cb(GObject* object,
                              GParamSpec* pspec,
                              gpointer user_data)
{
  InfUserTable* user_table;
  InfUserTablePrivate* priv;
  InfUser* user;
  GSList* available_item;
  GSList* local_item;

  user_table = INF_USER_TABLE(user_data);
  priv = INF_USER_TABLE_PRIVATE(user_table);
  user = INF_USER(object);

  available_item = g_slist_find(priv-&gt;availables, user);
  local_item = g_slist_find(priv-&gt;locals, user);

  if(inf_user_get_status(user) != INF_USER_UNAVAILABLE &amp;&amp;
     available_item == NULL)
  {</B></FONT>
    g_signal_emit(
      G_OBJECT(user_table),
      user_table_signals[ADD_AVAILABLE_USER],
      0,
      user
    );
  }

  if(inf_user_table_is_local(INF_USER(object)) &amp;&amp; local_item == NULL)
  {
    g_signal_emit(
      G_OBJECT(user_table),
      user_table_signals[ADD_LOCAL_USER],
      0,
      user
    );
  }
  
  if(!inf_user_table_is_local(INF_USER(object)) &amp;&amp; local_item != NULL)
  {
    g_signal_emit(
      G_OBJECT(user_table),
      user_table_signals[REMOVE_LOCAL_USER],
      0,
      user
    );
  }

  if(inf_user_get_status(user) == INF_USER_UNAVAILABLE &amp;&amp;
     available_item != NULL)
  {
    g_signal_emit(
      G_OBJECT(user_table),
      user_table_signals[REMOVE_AVAILABLE_USER],
      0,
      user
    );
  }
}

static void
inf_user_table_unref_user(InfUserTable* user_table,
                          InfUser* user)
{
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(user),
    G_CALLBACK(inf_user_table_check_local_cb),
    user_table
  );

  g_object_unref(user);
}

static void
inf_user_table_dispose_foreach_func(gpointer key,
                                    gpointer value,
                                    gpointer user_data)
{
  inf_user_table_unref_user(INF_USER_TABLE(user_data), INF_USER(value));
}

/*
 * User table callbacks.
 */

static gboolean
inf_user_table_lookup_user_by_name_func(gpointer key,
                                        gpointer value,
                                        gpointer data)
{
  const gchar* user_name;
  user_name = inf_user_get_name(INF_USER(value));

  if(strcmp(user_name, (const gchar*)data) == 0) return TRUE;
  return FALSE;
}

static gint
inf_user_ids_list_sort_compare_func(gconstpointer a,
                                    gconstpointer b)
{
  return GPOINTER_TO_UINT(a) - GPOINTER_TO_UINT(b);
}

static void
inf_user_table_init(InfUserTable* user_table)
{
  InfUserTablePrivate* priv;
  priv = INF_USER_TABLE_PRIVATE(user_table);

  priv-&gt;table = g_hash_table_new_full(NULL, NULL, NULL, NULL);
  priv-&gt;user_ids = NULL;
  priv-&gt;availables = NULL;
  priv-&gt;locals = NULL;
}

static void
inf_user_table_dispose(GObject* object)
{
  InfUserTable* user_table;
  InfUserTablePrivate* priv;

  user_table = INF_USER_TABLE(object);
  priv = INF_USER_TABLE_PRIVATE(user_table);

  g_slist_free(priv-&gt;locals);
  priv-&gt;locals = NULL;

  g_slist_free(priv-&gt;availables);
  priv-&gt;availables = NULL;

  g_slist_free(priv-&gt;user_ids);
  priv-&gt;user_ids = NULL;

  g_hash_table_foreach(
    priv-&gt;table,
    inf_user_table_dispose_foreach_func,
    user_table
  );
<A NAME="1"></A>
  g_hash_table_remove_all(priv-&gt;table);
  G_OBJECT_CLASS(inf_user_table_parent_class)-&gt;dispose(object);
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1507-1.html#1',3,'match1507-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

static void
inf_user_table_finalize(GObject* object)
{
  InfUserTable* user_table;
  InfUserTablePrivate* priv;

  user_table = INF_USER_TABLE(object);
  priv = INF_USER_TABLE_PRIVATE(user_table);

  g_hash_table_destroy(priv-&gt;table);

  G_OBJECT_CLASS(inf_user_table_parent_class)-&gt;finalize(object);
}

static void
inf_user_table_add_user_handler(InfUserTable* user_table,
                                InfUser* user)
{
  InfUserTablePrivate* priv;
  guint id;

  priv = INF_USER_TABLE_PRIVATE(user_table);
  id = inf_user_get_id(user);</B></FONT>

  g_assert(id &gt; 0);
  g_assert(g_hash_table_lookup(priv-&gt;table, GUINT_TO_POINTER(id)) == NULL);

  g_hash_table_insert(priv-&gt;table, GUINT_TO_POINTER(id), user);
  g_object_ref(user);

  priv-&gt;user_ids = g_slist_insert_sorted(
    priv-&gt;user_ids,
    GUINT_TO_POINTER(id),
    inf_user_ids_list_sort_compare_func
  );

  g_signal_connect(
    G_OBJECT(user),
    &quot;notify::status&quot;,
    G_CALLBACK(inf_user_table_check_local_cb),
    user_table
  );

  if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
  {
    g_signal_emit(
      G_OBJECT(user_table),
      user_table_signals[ADD_AVAILABLE_USER],
      0,
      user
    );
  }

  if(inf_user_table_is_local(user))
  {
    g_signal_emit(
      G_OBJECT(user_table),
      user_table_signals[ADD_LOCAL_USER],
      0,
      user
    );
  }
}

static void
inf_user_table_remove_user_handler(InfUserTable* user_table,
                                   InfUser* user)
{
  InfUserTablePrivate* priv;
  guint id;

  priv = INF_USER_TABLE_PRIVATE(user_table);
  id = inf_user_get_id(user);

  if(inf_user_table_is_local(user))
  {
    g_signal_emit(
      G_OBJECT(user_table),
      user_table_signals[REMOVE_LOCAL_USER],
      0,
      user
    );
  }

  if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
  {
    g_signal_emit(
      G_OBJECT(user_table),
      user_table_signals[REMOVE_AVAILABLE_USER],
      0,
      user
    );
  }

  priv-&gt;user_ids = g_slist_remove(priv-&gt;user_ids, GUINT_TO_POINTER(id));

  inf_user_table_unref_user(user_table, user);
  g_assert(g_hash_table_lookup(priv-&gt;table, GUINT_TO_POINTER(id)) == user);
  g_hash_table_remove(priv-&gt;table, GUINT_TO_POINTER(id));
}

static void
inf_user_table_add_available_user(InfUserTable* user_table,
                                  InfUser* user)
{
  InfUserTablePrivate* priv;
  priv = INF_USER_TABLE_PRIVATE(user_table);

  g_assert(g_slist_find(priv-&gt;availables, user) == NULL);
  priv-&gt;availables = g_slist_prepend(priv-&gt;availables, user);
}

static void
inf_user_table_remove_available_user(InfUserTable* user_table,
                                     InfUser* user)
{
  InfUserTablePrivate* priv;
  priv = INF_USER_TABLE_PRIVATE(user_table);

  g_assert(g_slist_find(priv-&gt;availables, user) != NULL);
  priv-&gt;availables = g_slist_remove(priv-&gt;availables, user);
}

static void
inf_user_table_add_local_user(InfUserTable* user_table,
                              InfUser* user)
{
  InfUserTablePrivate* priv;
  priv = INF_USER_TABLE_PRIVATE(user_table);

  g_assert(g_slist_find(priv-&gt;locals, user) == NULL);
  priv-&gt;locals = g_slist_prepend(priv-&gt;locals, user);
}

static void
inf_user_table_remove_local_user(InfUserTable* user_table,
                                 InfUser* user)
{
  InfUserTablePrivate* priv;
  priv = INF_USER_TABLE_PRIVATE(user_table);
<A NAME="0"></A>
  g_assert(g_slist_find(priv-&gt;locals, user) != NULL);
  priv-&gt;locals = g_slist_remove(priv-&gt;locals, user);
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1507-1.html#0',3,'match1507-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

static void
inf_user_table_class_init(InfUserTableClass* user_table_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(user_table_class);

  object_class-&gt;dispose = inf_user_table_dispose;
  object_class-&gt;finalize = inf_user_table_finalize;

  user_table_class-&gt;add_user = inf_user_table_add_user_handler;
  user_table_class-&gt;remove_user = inf_user_table_remove_user_handler;
  user_table_class-&gt;add_available_user = inf_user_table_add_available_user;
  user_table_class-&gt;remove_available_user =
    inf_user_table_remove_available_user;
  user_table_class-&gt;add_local_user = inf_user_table_add_local_user;
  user_table_class-&gt;remove_local_user = inf_user_table_remove_local_user;

  /**
   * InfUserTable::add-user:
   * @user_table: The #InfUserTable into which @user has been added
   * @user: The #InfUser that has been added into @user_table
   *
   * This signal is emitted when inf_user_table_add_user() is called. Note
   * that this does not happen if @user rejoins the session and has already
   * been added to @user_table previously.
   *
   * #InfUserTable::add-local-user may also be emitted at this point if
   * @user has the %INF_USER_LOCAL flag set.
   */
  user_table_signals[ADD_USER] = g_signal_new(</B></FONT>
    &quot;add-user&quot;,
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfUserTableClass, add_user),
    NULL, NULL,
    g_cclosure_marshal_VOID__OBJECT,
    G_TYPE_NONE,
    1,
    INF_TYPE_USER
  );

  /**
   * InfUserTable::remove-user:
   * @user_table: The #InfUserTable from which @user has been remove
   * @user: The #InfUser that has been removed from @user_table
   *
   * This signal is emitted when inf_user_table_remove_user() is called. This
   * does not usually happen, as users leaving a session do not get removed
   * from the table.
   *
   * #InfUserTable::remove-local-user may also be emitted at this point if
   * @user has the %INF_USER_LOCAL flag set.
   */
  user_table_signals[REMOVE_USER] = g_signal_new(
    &quot;remove-user&quot;,
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfUserTableClass, remove_user),
    NULL, NULL,
    g_cclosure_marshal_VOID__OBJECT,
    G_TYPE_NONE,
    1,
    INF_TYPE_USER
  );

  /**
   * InfUserTable::add-available-user:
   * @user_table: The #InfUserTable in which @user became available.
   * @user: The #InfUser that became available.
   *
   * This signal is emitted when a user in the user table becomes available,
   * i.e. its status is not %INF_USER_UNAVAILABLE. The signal is also emitted
   * when a new user is added to the user table who is available, in addition
   * to #InfUserTable::add-user and possibly #InfUserTable::add-local-user.
   */
  user_table_signals[ADD_AVAILABLE_USER] = g_signal_new(
    &quot;add-available-user&quot;,
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfUserTableClass, add_available_user),
    NULL, NULL,
    g_cclosure_marshal_VOID__OBJECT,
    G_TYPE_NONE,
    1,
    INF_TYPE_USER
  );

  /**
   * InfUserTable::remove-available-user:
   * @user_table: The #InfUserTable in which @user became unavailable.
   * @user: The #InfUser that became unavailable.
   *
   * This signal is emitted when a user in the user table became unavailable,
   * i.e. its status has changed to %INF_USER_UNAVAILABLE. The signal is also
   * emitted when a user who was available has been removed from the user
   * table, in addition to #InfUserTable::remove-user and possibly
   * #InfUserTable::remove-local-user.
   */
  user_table_signals[REMOVE_AVAILABLE_USER] = g_signal_new(
    &quot;remove-available-user&quot;,
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfUserTableClass, remove_available_user),
    NULL, NULL,
    g_cclosure_marshal_VOID__OBJECT,
    G_TYPE_NONE,
    1,
    INF_TYPE_USER
  );

  /**
   * InfUserTable::add-local-user:
   * @user_table: The #InfUserTable in which @user has been set as local
   * @user: The #InfUser that has set as local
   *
   * This signal is emitted when a user is added to the user table and has the
   * %INF_USER_LOCAL flag set. In this case, #InfUserTable::add-user is
   * emitted as well.
   *
   * This signal is also emitted when an existing user receives the
   * %INF_USER_LOCAL flag. This occurs when a user rejoins locally after
   * leaving the session (possibly having the %INF_USER_LOCAL flag removed
   * during their absence). #InfUserTable::add-user is not emitted in this
   * case.
   */
  user_table_signals[ADD_LOCAL_USER] = g_signal_new(
    &quot;add-local-user&quot;,
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfUserTableClass, add_local_user),
    NULL, NULL,
    g_cclosure_marshal_VOID__OBJECT,
    G_TYPE_NONE,
    1,
    INF_TYPE_USER
  );

  /**
   * InfUserTable::remove-local-user:
   * @user_table: The #InfUserTable in which @user is no longer local
   * @user: The #InfUser that is no longer local
   *
   * This signal is emitted when a user is removed from the user table and
   * had the %INF_USER_LOCAL flag set. In this case,
   * #InfUserTable::remove-user is emitted as well.
   *
   * This signal is also emitted when @user loses the %INF_USER_LOCAL flag.
   * This occurs when the local @user leaves the session.
   * #InfUserTable::remove-user is not emitted and the status of @user is set
   * to %INF_USER_UNAVAILABLE.
   */
  user_table_signals[REMOVE_LOCAL_USER] = g_signal_new(
    &quot;remove-local-user&quot;,
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfUserTableClass, remove_local_user),
    NULL, NULL,
    g_cclosure_marshal_VOID__OBJECT,
    G_TYPE_NONE,
    1,
    INF_TYPE_USER
  );
}

/**
 * inf_user_table_new: (constructor)
 *
 * Creates a new, empty user table.
 *
 * Returns: (transfer full): A #InfUserTable.
 **/
InfUserTable*
inf_user_table_new(void)
{
  return INF_USER_TABLE(g_object_new(INF_TYPE_USER_TABLE, NULL));
}

/**
 * inf_user_table_add_user:
 * @user_table: A #InfUserTable.
 * @user: A #InfUser not already contained in @user_table.
 *
 * Inserts @user into @user_table.
 */
void
inf_user_table_add_user(InfUserTable* user_table,
                        InfUser* user)
{
  g_return_if_fail(INF_IS_USER_TABLE(user_table));
  g_return_if_fail(INF_IS_USER(user));

  g_signal_emit(G_OBJECT(user_table), user_table_signals[ADD_USER], 0, user);
}

/**
 * inf_user_table_remove_user:
 * @user_table: A #InfUserTable.
 * @user: A #InfUser contained in @table.
 *
 * Removes @user from @uesr_table.
 **/
void
inf_user_table_remove_user(InfUserTable* user_table,
                           InfUser* user)
{
  g_return_if_fail(INF_IS_USER_TABLE(user_table));
  g_return_if_fail(INF_IS_USER(user));

  g_signal_emit(
    G_OBJECT(user_table),
    user_table_signals[REMOVE_USER],
    0,
    user
  );
}

/**
 * inf_user_table_lookup_user_by_id:
 * @user_table: A #InfUserTable.
 * @id: User ID to lookup.
 *
 * Returns the #InfUser with the given User ID in @user_table.
 *
 * Returns: (transfer none) (allow-none): A #InfUser, or %NULL.
 **/
InfUser*
inf_user_table_lookup_user_by_id(InfUserTable* user_table,
                                 guint id)
{
  InfUserTablePrivate* priv;

  g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);

  priv = INF_USER_TABLE_PRIVATE(user_table);

  return INF_USER(g_hash_table_lookup(priv-&gt;table, GUINT_TO_POINTER(id)));
}

/**
 * inf_user_table_lookup_user_by_name:
 * @user_table: A #InfUserTable.
 * @name: User name to lookup.
 *
 * Returns an #InfUser with the given name if there is one.
 *
 * Returns: (transfer none) (allow-none): A #InfUser, or %NULL.
 **/
InfUser*
inf_user_table_lookup_user_by_name(InfUserTable* user_table,
                                   const gchar* name)
{
  InfUserTablePrivate* priv;
  InfUser* user;

  g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);
  g_return_val_if_fail(name != NULL, NULL);

  priv = INF_USER_TABLE_PRIVATE(user_table);

  user = g_hash_table_find(
    priv-&gt;table,
    inf_user_table_lookup_user_by_name_func,
    *(gpointer*) (gpointer) &amp;name /* cast const away without warning */
  );

  return user;
}

/**
 * inf_user_table_foreach_user:
 * @user_table: A #InfUserTable.
 * @func: (scope call): The function to call for each user.
 * @user_data: User data to pass to the function.
 *
 * Calls the given function for each user in the user_table. You should not
 * add or remove users while this function is being executed.
 **/
void
inf_user_table_foreach_user(InfUserTable* user_table,
                            InfUserTableForeachUserFunc func,
                            gpointer user_data)
{
  InfUserTablePrivate* priv;
  InfUser* user;
  GSList* item;

  guint user_id;

  g_return_if_fail(INF_IS_USER_TABLE(user_table));
  g_return_if_fail(func != NULL);

  priv = INF_USER_TABLE_PRIVATE(user_table);

  for(item = priv-&gt;user_ids; item != NULL; item = g_slist_next(item))
  {
    user_id = GPOINTER_TO_UINT(item-&gt;data);
    user = inf_user_table_lookup_user_by_id(user_table, user_id);
    func(user, user_data);
  }
}

/**
 * inf_user_table_foreach_local_user:
 * @user_table: A #InfUserTable.
 * @func: (scope call): The function to call for each user.
 * @user_data: User data to pass to the function.
 *
 * Calls the given function for each local user in the user_table. A local
 * user is a user that has the %INF_USER_LOCAL flag set and that has not
 * status %INF_USER_UNAVAILABLE. You should not add or remove users while this
 * function is being executed.
 **/
void
inf_user_table_foreach_local_user(InfUserTable* user_table,
                                  InfUserTableForeachUserFunc func,
                                  gpointer user_data)
{
  InfUserTablePrivate* priv;
  GSList* item;

  g_return_if_fail(INF_IS_USER_TABLE(user_table));
  g_return_if_fail(func != NULL);

  priv = INF_USER_TABLE_PRIVATE(user_table);
  
  for(item = priv-&gt;locals; item != NULL; item = g_slist_next(item))
    func(INF_USER(item-&gt;data), user_data);
}

/* vim:set et sw=2 ts=2: */
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-session.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include &lt;libinftext/inf-text-session.h&gt;
#include &lt;libinftext/inf-text-default-insert-operation.h&gt;
#include &lt;libinftext/inf-text-default-delete-operation.h&gt;
#include &lt;libinftext/inf-text-remote-delete-operation.h&gt;
#include &lt;libinftext/inf-text-insert-operation.h&gt;
#include &lt;libinftext/inf-text-delete-operation.h&gt;
#include &lt;libinftext/inf-text-move-operation.h&gt;
#include &lt;libinftext/inf-text-chunk.h&gt;
#include &lt;libinftext/inf-text-user.h&gt;
#include &lt;libinfinity/adopted/inf-adopted-no-operation.h&gt;
#include &lt;libinfinity/common/inf-xml-util.h&gt;
#include &lt;libinfinity/common/inf-error.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;

#include &lt;libxml/tree.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;

/* TODO: Optionally broadcast operations delayed to merge adjacent operations
 * and send as a single request. */

typedef struct _InfTextSessionLocalUser InfTextSessionLocalUser;
struct _InfTextSessionLocalUser {
  InfTextSession* session;
  InfTextUser* user;
  GTimeVal last_caret_update;
  InfIoTimeout* caret_timeout;
};

typedef struct _InfTextSessionPrivate InfTextSessionPrivate;
struct _InfTextSessionPrivate {
  guint caret_update_interval;
  GSList* local_users;
};

enum {
  PROP_0,

  PROP_CARET_UPDATE_INTERVAL
};

typedef struct _InfTextSessionInsertForeachData
  InfTextSessionInsertForeachData;
typedef struct _InfTextSessionEraseForeachData
  InfTextSessionEraseForeachData;

struct _InfTextSessionInsertForeachData {
  guint position;
  InfTextChunk* chunk;
  InfUser* user;
};

struct _InfTextSessionEraseForeachData {
  guint position;
  guint length;
  InfUser* user;
};

#define INF_TEXT_SESSION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_TYPE_SESSION, InfTextSessionPrivate))

static GQuark inf_text_session_error_quark;

G_DEFINE_TYPE_WITH_CODE(InfTextSession, inf_text_session, INF_ADOPTED_TYPE_SESSION,
  G_ADD_PRIVATE(InfTextSession))

/*
 * Utility functions
 */

/* Returns the difference between two GTimeVal, in milliseconds */
static guint
inf_text_session_timeval_diff(GTimeVal* first,
                              GTimeVal* second)
{
  g_assert(first-&gt;tv_sec &gt; second-&gt;tv_sec ||
           (first-&gt;tv_sec == second-&gt;tv_sec &amp;&amp;
            first-&gt;tv_usec &gt;= second-&gt;tv_usec));

  /* Don't risk overflow, don't need to convert to signed int */
  return (first-&gt;tv_sec - second-&gt;tv_sec) * 1000 +
         (first-&gt;tv_usec+500)/1000 - (second-&gt;tv_usec+500)/1000;
}

/* Converts at most *bytes bytes with cd and writes the result, which are
 * at most 1024 bytes, into xml, setting the given author. *bytes will be
 * set to the number of bytes not yet processed. */
static void
inf_text_session_segment_to_xml(GIConv* cd,
                                xmlNodePtr xml,
                                gconstpointer text,
                                gsize* bytes, /* in/out */
                                guint author)
{
  gchar utf8_text[1024];
  gsize result;

  gsize bytes_left;

  gchar* inbuf;
  gchar* outbuf;

  bytes_left = 1024;

  inbuf = *(gchar**)(gpointer)&amp;text; /* cast const away without warning */
  outbuf = utf8_text;

  result = g_iconv(
    *cd,
    &amp;inbuf,
    bytes,
    &amp;outbuf,
    &amp;bytes_left
  );

  /* Conversion into UTF-8 should always succeed */
  g_assert(result == 0 || errno == E2BIG);

  inf_xml_util_add_child_text(xml, utf8_text, 1024 - bytes_left);
  inf_xml_util_set_attribute_uint(xml, &quot;author&quot;, author);
}

static gpointer
inf_text_session_segment_from_xml(GIConv* cd,
                                  xmlNodePtr xml,
                                  guint* length,
                                  gsize* bytes,
                                  guint* author,
                                  GError** error)
{
  gsize bytes_read;
  gchar* utf8_text;
  gpointer text;

  if(!inf_xml_util_get_attribute_uint_required(xml, &quot;author&quot;, author, error))
    return NULL;

  utf8_text = inf_xml_util_get_child_text(xml, &amp;bytes_read, length, error);
  if(!utf8_text)
    return NULL;

  text = g_convert_with_iconv(
    utf8_text,
    bytes_read,
    *cd,
    NULL,
    bytes,
    error
  );

  g_free(utf8_text);
  return text;
}

/*
 * Caret/Selection handling
 */

static InfTextSessionLocalUser*
inf_text_session_find_local_user(InfTextSession* session,
                                 InfTextUser* user)
{
  InfTextSessionPrivate* priv;
  GSList* item;
  InfTextSessionLocalUser* local;

  priv = INF_TEXT_SESSION_PRIVATE(session);

  for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
  {
    local = (InfTextSessionLocalUser*)item-&gt;data;
    if(local-&gt;user == user)
      return local;
  }

  return NULL;
}

static void
inf_text_session_broadcast_caret_selection(InfTextSession* session,
                                           InfTextSessionLocalUser* local)
{
  InfAdoptedOperation* operation;
  InfAdoptedAlgorithm* algorithm;
  InfAdoptedRequest* request;
  guint buf_len;
  guint position;
  int sel;
  guint end;

  algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
  position = inf_text_user_get_caret_position(local-&gt;user);
  sel = inf_text_user_get_selection_length(local-&gt;user);
  end = position + sel;

  /* Clamp position and selection to buffer length. The only case when this is
   * needed is when a local user's position is beyond the end of the document
   * since there are some local document modifications. This can happen with
   * for example InfTextFixlineBuffer. */
  /* TODO: This should be handled more cleverly, by propagating the user
   * position and selection through the buffer, to make sure that at this
   * point it is always consistent with the infinote view of the buffer. */
  buf_len = inf_text_buffer_get_length(
    INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)))
  );

  if(position &gt; buf_len)
    position = buf_len;
  if(end &gt; buf_len)
    end = buf_len;

  if(end &gt;= position)
    sel = (int)(end - position);
  else
    sel = -(int)(position - end);

  operation = INF_ADOPTED_OPERATION(
    inf_text_move_operation_new(position, sel)
  );

  request = inf_adopted_algorithm_generate_request(
    algorithm,
    INF_ADOPTED_REQUEST_DO,
    INF_ADOPTED_USER(local-&gt;user),
    operation
  );

  /* This cannot fail since operation is not applied */
  inf_adopted_algorithm_execute_request(algorithm, request, FALSE, NULL);

  g_object_unref(operation);

  inf_adopted_session_broadcast_request(
    INF_ADOPTED_SESSION(session),
    request
  );

  g_object_unref(request);

  g_get_current_time(&amp;local-&gt;last_caret_update);

  if(local-&gt;caret_timeout != NULL)
  {
    inf_io_remove_timeout(
      inf_adopted_session_get_io(INF_ADOPTED_SESSION(session)),
      local-&gt;caret_timeout
    );

    local-&gt;caret_timeout = NULL;
  }
}

static void
inf_text_session_caret_update_timeout_func(gpointer user_data)
{
  InfTextSessionLocalUser* local;
  local = (InfTextSessionLocalUser*)user_data;

  local-&gt;caret_timeout = NULL;
  inf_text_session_broadcast_caret_selection(local-&gt;session, local);
}

static void
inf_text_session_selection_changed_cb(InfTextUser* user,
                                      guint position,
                                      gint sel,
                                      gboolean by_request,
                                      gpointer user_data)
{
  InfTextSession* session;
  InfTextSessionPrivate* priv;
  InfAdoptedAlgorithm* algorithm;
  InfAdoptedRequest* execute_request;
  InfTextSessionLocalUser* local;
  GTimeVal current;
  guint diff;

  session = INF_TEXT_SESSION(user_data);
  priv = INF_TEXT_SESSION_PRIVATE(session);
  algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
  execute_request = inf_adopted_algorithm_get_execute_request(algorithm);

  /* We should block all changes that have by_request set to FALSE... breaks
   * if someone else does that... should maybe emit a warning instead. */
  g_assert( (execute_request != NULL &amp;&amp; by_request == FALSE) ||
            (execute_request == NULL &amp;&amp; by_request == TRUE));

  if(execute_request == NULL)
  {
    local = inf_text_session_find_local_user(session, user);
    g_assert(local != NULL);

    g_get_current_time(&amp;current);
    diff = inf_text_session_timeval_diff(&amp;current, &amp;local-&gt;last_caret_update);

    if(diff &lt; priv-&gt;caret_update_interval)
    {
      if(local-&gt;caret_timeout == NULL)
      {
        /* TODO: Interrupt timeout if a -caret request is sent from that
         * local user. */
        local-&gt;caret_timeout = inf_io_add_timeout(
          inf_adopted_session_get_io(INF_ADOPTED_SESSION(local-&gt;session)),
          priv-&gt;caret_update_interval - diff,
          inf_text_session_caret_update_timeout_func,
          local,
          NULL
        );
      }
    }
    else
    {
      inf_text_session_broadcast_caret_selection(session, local);
    }
  }
}

static void
inf_text_session_add_local_user(InfTextSession* session,
                                InfTextUser* user)
{
  InfTextSessionPrivate* priv;
  InfTextSessionLocalUser* local;

  priv = INF_TEXT_SESSION_PRIVATE(session);

  local = g_slice_new(InfTextSessionLocalUser);
  local-&gt;session = session;
  local-&gt;user = user;
  g_get_current_time(&amp;local-&gt;last_caret_update);
  local-&gt;caret_timeout = NULL;

  priv-&gt;local_users = g_slist_prepend(priv-&gt;local_users, local);

  g_signal_connect_after(
    G_OBJECT(user),
    &quot;selection-changed&quot;,
    G_CALLBACK(inf_text_session_selection_changed_cb),
    session
  );
}

static void
inf_text_session_remove_local_user(InfTextSession* session,
                                   InfTextSessionLocalUser* local)
{
  InfTextSessionPrivate* priv;

  priv = INF_TEXT_SESSION_PRIVATE(session);

  if(local-&gt;caret_timeout != NULL)
  {
    inf_io_remove_timeout(
      inf_adopted_session_get_io(INF_ADOPTED_SESSION(session)),
      local-&gt;caret_timeout
    );
  }

  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(local-&gt;user),
    G_CALLBACK(inf_text_session_selection_changed_cb),
    session
  );

  g_slice_free(InfTextSessionLocalUser, local);
  priv-&gt;local_users = g_slist_remove(priv-&gt;local_users, local);
}

static void
inf_text_session_local_user_added_cb(InfUserTable* user_table,
                                     InfUser* user,
                                     gpointer user_data)
{
  g_assert(INF_TEXT_IS_USER(user));

  inf_text_session_add_local_user(
    INF_TEXT_SESSION(user_data),
    INF_TEXT_USER(user)
  );
}

static void
inf_text_session_local_user_removed_cb(InfUserTable* user_table,
                                       InfUser* user,
                                       gpointer user_data)
{
  InfTextSession* session;
  InfTextSessionLocalUser* local;

  g_assert(INF_TEXT_IS_USER(user));

  session = INF_TEXT_SESSION(user_data);
  local = inf_text_session_find_local_user(session, INF_TEXT_USER(user));
  g_assert(local != NULL);

  inf_text_session_remove_local_user(session, local);
}

static void
inf_text_session_block_local_users_selection_changed(InfTextSession* session)
{
  InfTextSessionPrivate* priv;
  GSList* item;
  InfTextSessionLocalUser* local;

  priv = INF_TEXT_SESSION_PRIVATE(session);

  for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
  {
    local = (InfTextSessionLocalUser*)item-&gt;data;

    inf_signal_handlers_block_by_func(
      G_OBJECT(local-&gt;user),
      G_CALLBACK(inf_text_session_selection_changed_cb),
      session
    );
  }
}

static void
inf_text_session_unblock_local_users_selection_changed(InfTextSession* sess)
{
  InfTextSessionPrivate* priv;
  GSList* item;
  InfTextSessionLocalUser* local;

  priv = INF_TEXT_SESSION_PRIVATE(sess);

  for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
  {
    local = (InfTextSessionLocalUser*)item-&gt;data;

    inf_signal_handlers_unblock_by_func(
      G_OBJECT(local-&gt;user),
      G_CALLBACK(inf_text_session_selection_changed_cb),
      sess
    );
  }
}

static void
inf_text_session_buffer_text_inserted_cb_foreach_func(InfUser* user,
                                                      gpointer user_data)
{
  InfTextSessionInsertForeachData* data;
  guint position;
  gint length;

  data = (InfTextSessionInsertForeachData*)user_data;
  if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
  {
    /* TODO: Handle separately if insert-caret */
    position = inf_text_user_get_caret_position(INF_TEXT_USER(user));
    length = inf_text_user_get_selection_length(INF_TEXT_USER(user));

    inf_text_move_operation_transform_insert(
      data-&gt;position,
      inf_text_chunk_get_length(data-&gt;chunk),
      &amp;position,
      &amp;length,
      /* Right gravity for local insertions, left gravity for remote ones */
      user == data-&gt;user ? FALSE : TRUE
    );

    inf_text_user_set_selection(
      INF_TEXT_USER(user),
      position,
      length,
      user == data-&gt;user ? TRUE : FALSE
    );
  }
}

static void
inf_text_session_buffer_text_erased_cb_foreach_func(InfUser* user,
                                                    gpointer user_data)
{
  InfTextSessionEraseForeachData* data;
  guint position;
  gint length;

  data = (InfTextSessionEraseForeachData*)user_data;
  if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
  {
    /* TODO: Handle separately if erase-caret */
    position = inf_text_user_get_caret_position(INF_TEXT_USER(user));
    length = inf_text_user_get_selection_length(INF_TEXT_USER(user));

    inf_text_move_operation_transform_delete(
      data-&gt;position,
      data-&gt;length,
      &amp;position,
      &amp;length
    );

    inf_text_user_set_selection(
      INF_TEXT_USER(user),
      position,
      length,
<A NAME="2"></A>      user == data-&gt;user ? TRUE : FALSE
    );
  }
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1507-0.html#2',2,'match1507-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

/* The after handlers readjust the caret and selection properties of the
 * users. Block handlers so we don't broadcast this. */
static void
inf_text_session_buffer_text_inserted_cb(InfTextBuffer* buffer,
                                         guint pos,
                                         InfTextChunk* chunk,
                                         InfUser* user,
                                         gpointer user_data)
{
  InfTextSession* session;
  InfTextSessionPrivate* priv;
  InfUserTable* user_table;
  InfAdoptedAlgorithm* algorithm;
  InfAdoptedRequest* execute_request;

  InfAdoptedOperation* operation;
  InfAdoptedRequest* request;
  InfTextSessionInsertForeachData data;

  g_assert(INF_TEXT_IS_USER(user));

  session = INF_TEXT_SESSION(user_data);
  priv = INF_TEXT_SESSION_PRIVATE(session);
  user_table = inf_session_get_user_table(INF_SESSION(session));
  algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
  execute_request = inf_adopted_algorithm_get_execute_request(algorithm);

  if(execute_request == NULL)
  {</B></FONT>
    operation = INF_ADOPTED_OPERATION(
      inf_text_default_insert_operation_new(pos, chunk)
    );

    request = inf_adopted_algorithm_generate_request(
      algorithm,
      INF_ADOPTED_REQUEST_DO,
      INF_ADOPTED_USER(user),
      operation
    );

    /* This cannot fail since operation is not applied */
    inf_adopted_algorithm_execute_request(algorithm, request, FALSE, NULL);

    inf_adopted_session_broadcast_request(
      INF_ADOPTED_SESSION(session),
      request
    );

    g_object_unref(request);
    g_object_unref(operation);
  }

  data.position = pos;
  data.chunk = chunk;
  data.user = user;

  inf_text_session_block_local_users_selection_changed(session);

  inf_user_table_foreach_user(
    user_table,
    inf_text_session_buffer_text_inserted_cb_foreach_func,
    &amp;data
  );

#if 0
  /* TODO: If that was an insert-caret request, then do this: */
  if(user != NULL)
  {
    inf_text_user_set_selection(
      INF_TEXT_USER(user),
      pos + inf_text_chunk_get_length(chunk),
      0,
      TRUE
    );
  }
#endif

  inf_text_session_unblock_local_users_selection_changed(session);
}

static void
inf_text_session_buffer_text_erased_cb(InfTextBuffer* buffer,
                                       guint pos,
                                       InfTextChunk* chunk,
                                       InfUser* user,
                                       gpointer user_data)
{
  InfTextSession* session;
  InfTextSessionPrivate* priv;
  InfUserTable* user_table;
  InfAdoptedAlgorithm* algorithm;
  InfAdoptedRequest* execute_request;

  InfAdoptedOperation* operation;
  InfAdoptedRequest* request;
  InfTextSessionEraseForeachData data;

  g_assert(INF_TEXT_IS_USER(user));

  session = INF_TEXT_SESSION(user_data);
  priv = INF_TEXT_SESSION_PRIVATE(session);
  user_table = inf_session_get_user_table(INF_SESSION(session));
  algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
  execute_request = inf_adopted_algorithm_get_execute_request(algorithm);

  if(execute_request == NULL)
  {
    operation = INF_ADOPTED_OPERATION(
      inf_text_default_delete_operation_new(pos, chunk)
    );

    request = inf_adopted_algorithm_generate_request(
      algorithm,
      INF_ADOPTED_REQUEST_DO,
      INF_ADOPTED_USER(user),
      operation
    );

    /* This cannot fail since operation is not applied */
    inf_adopted_algorithm_execute_request(algorithm, request, FALSE, NULL);

    inf_adopted_session_broadcast_request(
      INF_ADOPTED_SESSION(session),
      request
    );

    g_object_unref(request);
    g_object_unref(operation);
  }

  data.position = pos;
  data.length = inf_text_chunk_get_length(chunk);
  data.user = user;

  inf_text_session_block_local_users_selection_changed(session);

  inf_user_table_foreach_user(
    user_table,
    inf_text_session_buffer_text_erased_cb_foreach_func,
    &amp;data
  );

  /* TODO: If that was an erase-caret request, then do this: */
#if 0
  if(user != NULL)
    inf_text_user_set_selection(INF_TEXT_USER(user), pos, 0, TRUE);
#endif

  inf_text_session_unblock_local_users_selection_changed(session);
}

static void
inf_text_session_init_text_handlers_user_foreach_func(InfUser* user,
                                                      gpointer user_data)
{
  g_assert(INF_TEXT_IS_USER(user));

  inf_text_session_add_local_user(
    INF_TEXT_SESSION(user_data),
    INF_TEXT_USER(user)
  );
}

static void
inf_text_session_init_text_handlers(InfTextSession* session)
{
  InfTextBuffer* buffer;
  InfAdoptedAlgorithm* algorithm;
  InfUserTable* user_table;

  buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
  algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
  user_table = inf_session_get_user_table(INF_SESSION(session));

  g_signal_connect(
    G_OBJECT(buffer),
    &quot;text-inserted&quot;,
    G_CALLBACK(inf_text_session_buffer_text_inserted_cb),
    session
  );

  g_signal_connect(
    G_OBJECT(buffer),
    &quot;text-erased&quot;,
    G_CALLBACK(inf_text_session_buffer_text_erased_cb),
    session
  );

  g_signal_connect(
    G_OBJECT(user_table),
    &quot;add-local-user&quot;,
    G_CALLBACK(inf_text_session_local_user_added_cb),
    session
  );

  g_signal_connect(
    G_OBJECT(user_table),
    &quot;remove-local-user&quot;,
    G_CALLBACK(inf_text_session_local_user_removed_cb),
    session
  );

  inf_user_table_foreach_local_user(
    user_table,
<A NAME="1"></A>    inf_text_session_init_text_handlers_user_foreach_func,
    session
  );
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1507-0.html#1',2,'match1507-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

/*
 * GObject overrides.
 */

static void
inf_text_session_init(InfTextSession* session)
{
  InfTextSessionPrivate* priv;
  priv = INF_TEXT_SESSION_PRIVATE(session);

  priv-&gt;caret_update_interval = 500;
}

static void
inf_text_session_constructed(GObject* object)
{
  InfTextSession* session;
  InfTextSessionPrivate* priv;
  InfTextBuffer* buffer;
  InfSessionStatus status;

  G_OBJECT_CLASS(inf_text_session_parent_class)-&gt;constructed(object);

  session = INF_TEXT_SESSION(object);
  priv = INF_TEXT_SESSION_PRIVATE(session);</B></FONT>

  buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
  g_object_get(G_OBJECT(session), &quot;status&quot;, &amp;status, NULL);

  /* We can either be already synchronized in which case we use the given
   * buffer as initial buffer. This is used to initiate a new session with
   * predefined content. In that case, we can directly start through. In the
   * other case we are getting synchronized in which case the buffer must be
   * empty (we will fill it during synchronization). Text handlers are
   * connected when synchronization is complete. */
  g_assert(
    status == INF_SESSION_RUNNING ||
    inf_text_buffer_get_length(buffer) == 0
  );

  if(status == INF_SESSION_RUNNING)
    inf_text_session_init_text_handlers(session);
}

/*static void
inf_text_session_dispose_foreach_local_user_func(InfUser* user,
                                                 gpointer user_data)
{
  g_assert(INF_TEXT_IS_USER(user));

  g_signal_handlers_disconnect_matched(
    G_OBJECT(user),
    G_SIGNAL_MATCH_FUNC,
    0,
    0,
    NULL,
    G_CALLBACK(inf_text_session_selection_changed_cb),
    NULL
  );
}*/

static void
inf_text_session_dispose(GObject* object)
{
  InfTextSession* session;
  InfTextSessionPrivate* priv;
  InfTextBuffer* buffer;
  InfUserTable* user_table;
  InfAdoptedAlgorithm* algorithm;

  session = INF_TEXT_SESSION(object);
  priv = INF_TEXT_SESSION_PRIVATE(session);

  buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
  user_table = inf_session_get_user_table(INF_SESSION(session));
  algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));

  while(priv-&gt;local_users != NULL)
  {
    inf_text_session_remove_local_user(
      session,
      (InfTextSessionLocalUser*)priv-&gt;local_users-&gt;data
    );
  }

  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(buffer),
    G_CALLBACK(inf_text_session_buffer_text_inserted_cb),
    session
  );

  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(buffer),
    G_CALLBACK(inf_text_session_buffer_text_erased_cb),
    session
  );

  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(user_table),
    G_CALLBACK(inf_text_session_local_user_added_cb),
    session
  );

  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(user_table),
    G_CALLBACK(inf_text_session_local_user_removed_cb),
    session
  );

  G_OBJECT_CLASS(inf_text_session_parent_class)-&gt;dispose(object);
}

static void
inf_text_session_finalize(GObject* object)
{
  InfTextSession* session;
  InfTextSessionPrivate* priv;

  session = INF_TEXT_SESSION(object);
  priv = INF_TEXT_SESSION_PRIVATE(session);

  G_OBJECT_CLASS(inf_text_session_parent_class)-&gt;finalize(object);
}

static void
inf_text_session_set_property(GObject* object,
                              guint prop_id,
                              const GValue* value,
                              GParamSpec* pspec)
{
  InfTextSession* session;
  InfTextSessionPrivate* priv;

  session = INF_TEXT_SESSION(object);
  priv = INF_TEXT_SESSION_PRIVATE(session);

  switch(prop_id)
  {
  case PROP_CARET_UPDATE_INTERVAL:
    priv-&gt;caret_update_interval = g_value_get_uint(value);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_text_session_get_property(GObject* object,
                              guint prop_id,
                              GValue* value,
                              GParamSpec* pspec)
{
  InfTextSession* session;
  InfTextSessionPrivate* priv;

  session = INF_TEXT_SESSION(object);
  priv = INF_TEXT_SESSION_PRIVATE(session);

  switch(prop_id)
  {
  case PROP_CARET_UPDATE_INTERVAL:
    g_value_set_uint(value, priv-&gt;caret_update_interval);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

/*
 * Network command handlers
 */

static InfCommunicationScope
inf_text_session_handle_user_color_change(InfTextSession* session,
                                          InfXmlConnection* connection,
                                          xmlNodePtr xml,
                                          GError** error)
{
  InfUserTable* user_table;
  guint user_id;
  InfUser* user;
  gdouble hue;

  user_table = inf_session_get_user_table(INF_SESSION(session));

  if(!inf_xml_util_get_attribute_uint_required(xml, &quot;id&quot;, &amp;user_id, error))
    return INF_COMMUNICATION_SCOPE_PTP;
  if(!inf_xml_util_get_attribute_double_required(xml, &quot;hue&quot;, &amp;hue, error))
    return INF_COMMUNICATION_SCOPE_PTP;

  /* TODO: A public function in InfSession that does the following two checks
   * (and returns the user). This can also be used in
   * inf_session_handle_user_status_change */
  user = inf_user_table_lookup_user_by_id(user_table, user_id);
  if(user == NULL)
  {
    g_set_error(
      error,
      inf_user_error_quark(),
      INF_USER_ERROR_NO_SUCH_USER,
      _(&quot;No such user with ID '%u'&quot;),
      user_id
    );

    return INF_COMMUNICATION_SCOPE_PTP;
  }

  if(inf_user_get_status(user) == INF_USER_UNAVAILABLE ||
     inf_user_get_connection(user) != connection)
  {
    g_set_error_literal(
      error,
      inf_user_error_quark(),
      INF_USER_ERROR_NOT_JOINED,
      _(&quot;User did not join from this connection&quot;)
    );

    return INF_COMMUNICATION_SCOPE_PTP;
  }

  g_assert(INF_TEXT_IS_USER(user));

  if(hue &lt; 0.0 || hue &gt; 1.0)
  {
    g_set_error(
      error,
      inf_text_session_error_quark,
      INF_TEXT_SESSION_ERROR_INVALID_HUE,
      _(&quot;Invalid hue value: '%g'&quot;),
      hue
    );

    return INF_COMMUNICATION_SCOPE_PTP;
  }

  g_object_set(G_OBJECT(user), &quot;hue&quot;, hue, NULL);
  return INF_COMMUNICATION_SCOPE_GROUP;
}

/*
 * InfSession overrides
 */

static void
inf_text_session_to_xml_sync(InfSession* session,
                             xmlNodePtr parent)
{
  InfTextBuffer* buffer;
  InfTextBufferIter* iter;
  xmlNodePtr xml;
  gboolean result;

  gchar* text;
  gsize total_bytes;
  gsize bytes_left;
  GIConv cd;

  INF_SESSION_CLASS(inf_text_session_parent_class)-&gt;to_xml_sync(
    session,
    parent
  );

  buffer = INF_TEXT_BUFFER(inf_session_get_buffer(session));
  cd = g_iconv_open(&quot;UTF-8&quot;, inf_text_buffer_get_encoding(buffer));

  iter = inf_text_buffer_create_begin_iter(buffer);
  if(iter != NULL)
  {
    result = TRUE;
    while(result == TRUE)
    {
      /* Write segment in 1024 byte chunks */
      text = inf_text_buffer_iter_get_text(buffer, iter);
      total_bytes = inf_text_buffer_iter_get_bytes(buffer, iter);
      bytes_left = total_bytes;

      while(bytes_left &gt; 0)
      {
        xml = xmlNewChild(parent, NULL, (const xmlChar*)&quot;sync-segment&quot;, NULL);
        inf_text_session_segment_to_xml(
          &amp;cd,
          xml,
          text + total_bytes - bytes_left,
          &amp;bytes_left,
          inf_text_buffer_iter_get_author(buffer, iter)
        );
      }

      g_free(text);
      result = inf_text_buffer_iter_next(buffer, iter);
    }

    inf_text_buffer_destroy_iter(buffer, iter);
  }

  g_iconv_close(cd);
}

static gboolean
inf_text_session_process_xml_sync(InfSession* session,
                                  InfXmlConnection* connection,
                                  const xmlNodePtr xml,
                                  GError** error)
{
  InfTextBuffer* buffer;
  GIConv cd;

  gpointer text;
  gsize bytes;
  guint length;
  guint author;
  InfUser* user;

  if(strcmp((const char*)xml-&gt;name, &quot;sync-segment&quot;) == 0)
  {
    buffer = INF_TEXT_BUFFER(inf_session_get_buffer(session));
    cd = g_iconv_open(inf_text_buffer_get_encoding(buffer), &quot;UTF-8&quot;);

    text = inf_text_session_segment_from_xml(
      &amp;cd,
      xml,
      &amp;length,
      &amp;bytes,
      &amp;author,
      error
    );

    g_iconv_close(cd);
    if(text == NULL) return FALSE;

    if(author != 0)
    {
      /* TODO: inf_user_table_lookup_user_by_id_required, with error. */
      user = inf_user_table_lookup_user_by_id(
        inf_session_get_user_table(session),
        author
      );

      if(user == NULL)
      {
        g_free(text);

        g_set_error(
          error,
          inf_user_error_quark(),
          INF_USER_ERROR_NO_SUCH_USER,
          _(&quot;No such user with ID '%u'&quot;),
          author
        );

        return FALSE;
      }
    }
    else
    {
      user = NULL;
    }

    inf_text_buffer_insert_text(
      buffer,
      inf_text_buffer_get_length(buffer),
      text,
      bytes,
      length,
      user
    );

    g_free(text);
    return TRUE;
  }
  else
  {
    return INF_SESSION_CLASS(inf_text_session_parent_class)-&gt;process_xml_sync(
      session,
      connection,
      xml,
      error
    );
  }
}

static InfCommunicationScope
inf_text_session_process_xml_run(InfSession* session,
                                 InfXmlConnection* connection,
                                 const xmlNodePtr xml,
                                 GError** error)
{
  if(strcmp((const char*)xml-&gt;name, &quot;user-color-change&quot;) == 0)
  {
    return inf_text_session_handle_user_color_change(
      INF_TEXT_SESSION(session),
      connection,
      xml,
      error
    );
  }
  else
  {
    return INF_SESSION_CLASS(inf_text_session_parent_class)-&gt;process_xml_run(
      session,
      connection,
      xml,
      error
    );
  }
}

static GArray*
inf_text_session_get_xml_user_props(InfSession* session,
                                    InfXmlConnection* connection,
                                    const xmlNodePtr xml)
{
  InfSessionClass* parent_class;
  GArray* array;
  GParameter* parameter;
  guint caret;
  gint selection;
  gdouble hue;

  parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
  array = parent_class-&gt;get_xml_user_props(session, connection, xml);

  /* TODO: Error reporting for get_xml_user_props */
  if(inf_xml_util_get_attribute_uint(xml, &quot;caret&quot;, &amp;caret, NULL))
  {
    parameter = inf_session_get_user_property(array, &quot;caret-position&quot;);
    g_value_init(&amp;parameter-&gt;value, G_TYPE_UINT);
    g_value_set_uint(&amp;parameter-&gt;value, caret);
  }

  parameter = inf_session_get_user_property(array, &quot;selection-length&quot;);
  g_value_init(&amp;parameter-&gt;value, G_TYPE_INT);
  if(inf_xml_util_get_attribute_int(xml, &quot;selection&quot;, &amp;selection, NULL))
    g_value_set_int(&amp;parameter-&gt;value, selection);
  else
    g_value_set_int(&amp;parameter-&gt;value, 0);

  parameter = inf_session_get_user_property(array, &quot;hue&quot;);
  g_value_init(&amp;parameter-&gt;value, G_TYPE_DOUBLE);

  /* Use a random hue if none set */
  if(inf_xml_util_get_attribute_double(xml, &quot;hue&quot;, &amp;hue, NULL))
    g_value_set_double(&amp;parameter-&gt;value, hue);
  else
    g_value_set_double(&amp;parameter-&gt;value, g_random_double());

  return array;
}

static void
inf_text_session_set_xml_user_props(InfSession* session,
                                    const GParameter* params,
                                    guint n_params,
                                    xmlNodePtr xml)
{
  InfSessionClass* parent_class;
  const GParameter* param;

  parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
  parent_class-&gt;set_xml_user_props(session, params, n_params, xml);

  param = inf_session_lookup_user_property(
    params,
    n_params,
    &quot;caret-position&quot;
  );

  if(param != NULL)
  {
    inf_xml_util_set_attribute_uint(
      xml,
      &quot;caret&quot;,
      g_value_get_uint(&amp;param-&gt;value)
    );
  }

  param = inf_session_lookup_user_property(
    params,
    n_params,
    &quot;selection-length&quot;
  );

  if(param != NULL)
  {
    inf_xml_util_set_attribute_int(
      xml,
      &quot;selection&quot;,
      g_value_get_int(&amp;param-&gt;value)
    );
  }

  param = inf_session_lookup_user_property(
    params,
    n_params,
    &quot;hue&quot;
  );

  if(param != NULL)
  {
    inf_xml_util_set_attribute_double(
      xml,
      &quot;hue&quot;,
      g_value_get_double(&amp;param-&gt;value)
    );
  }
}

static gboolean
inf_text_session_validate_user_props(InfSession* session,
                                     const GParameter* params,
                                     guint n_params,
                                     InfUser* exclude,
                                     GError** error)
{
  InfSessionClass* parent_class;
  const GParameter* caret;
  gboolean result;

  parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
  result = parent_class-&gt;validate_user_props(
    session,
    params,
    n_params,
    exclude,
    error
  );

  if(result == FALSE) return FALSE;

  caret = inf_session_lookup_user_property(
    params,
    n_params,
    &quot;caret-position&quot;
  );

  if(caret == NULL)
  {
    g_set_error_literal(
      error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_NO_SUCH_ATTRIBUTE,
      _(&quot;\&quot;caret\&quot; attribute in user message is missing&quot;)
    );

    return FALSE;
  }

  /* Selection is optional and 0 if not given */

  return result;
}

static InfUser*
inf_text_session_user_new(InfSession* session,
                          GParameter* params,
                          guint n_params)
{
  GObject* object;
  object = g_object_newv(INF_TEXT_TYPE_USER, n_params, params);
  return INF_USER(object);
}

static void
inf_text_session_synchronization_complete(InfSession* session,
                                          InfXmlConnection* connection)
{
  InfSessionClass* parent_class;
  InfSessionStatus status;

  parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
  status = inf_session_get_status(session);

  parent_class-&gt;synchronization_complete(session, connection);

  /* init_text_handlers needs to access the algorithm which is created in the
   * parent class default signal handler which is why we call this afterwards.
   * Note that we need to query status before, so we know whether the session
   * itself was synchronized (status == SYNCHRONIZING) or whether we just
   * synchronized the session to someone else (status == RUNNING). */
  if(status == INF_SESSION_SYNCHRONIZING)
    inf_text_session_init_text_handlers(INF_TEXT_SESSION(session));
}

/*
 * InfAdoptedSession overrides
 */

static void
inf_text_session_request_to_xml(InfAdoptedSession* session,
                                xmlNodePtr xml,
                                InfAdoptedRequest* request,
                                InfAdoptedStateVector* diff_vec,
                                gboolean for_sync)
{
  InfTextChunk* chunk;
  InfTextChunkIter iter;
  gboolean result;
  xmlNodePtr op_xml;

  gchar* utf8_text;
  gsize bytes_read;
  gsize bytes_written;

  GIConv cd;
  xmlNodePtr child;
  const gchar* text;
  gsize total_bytes;
  gsize bytes_left;

  InfAdoptedOperation* operation;

  switch(inf_adopted_request_get_request_type(request))
  {
  case INF_ADOPTED_REQUEST_DO:
    operation = inf_adopted_request_get_operation(request);
    if(INF_TEXT_IS_INSERT_OPERATION(operation))
    {
      op_xml = xmlNewNode(NULL, (const xmlChar*)&quot;insert-caret&quot;);

      inf_xml_util_set_attribute_uint(
        op_xml,
        &quot;pos&quot;,
        inf_text_insert_operation_get_position(
          INF_TEXT_INSERT_OPERATION(operation)
        )
      );

      /* Must be default insert operation so we get the inserted text */
      g_assert(INF_TEXT_IS_DEFAULT_INSERT_OPERATION(operation));

      chunk = inf_text_default_insert_operation_get_chunk(
        INF_TEXT_DEFAULT_INSERT_OPERATION(operation)
      );

      result = inf_text_chunk_iter_init_begin(chunk, &amp;iter);
      g_assert(result == TRUE);

      utf8_text = g_convert(
        inf_text_chunk_iter_get_text(&amp;iter),
        inf_text_chunk_iter_get_bytes(&amp;iter),
        &quot;UTF-8&quot;,
        inf_text_chunk_get_encoding(chunk),
        &amp;bytes_read,
        &amp;bytes_written,
        NULL
      );

      /* Conversion to UTF-8 should always succeed */
      g_assert(utf8_text != NULL);
      g_assert(bytes_read == inf_text_chunk_iter_get_bytes(&amp;iter));

      inf_xml_util_add_child_text(op_xml, utf8_text, bytes_written);
      g_free(utf8_text);

      /* We only allow a single segment because the whole inserted text must
       * be written by a single user. */
      g_assert(inf_text_chunk_iter_next(&amp;iter) == FALSE);
    }
    else if(INF_TEXT_IS_DELETE_OPERATION(operation))
    {
      op_xml = xmlNewNode(NULL, (const xmlChar*)&quot;delete-caret&quot;);

      inf_xml_util_set_attribute_uint(
        op_xml,
        &quot;pos&quot;,
        inf_text_delete_operation_get_position(
          INF_TEXT_DELETE_OPERATION(operation)
        )
      );

      if(for_sync == TRUE)
      {
        /* Must be default delete operation so we get chunk */
        g_assert(INF_TEXT_IS_DEFAULT_DELETE_OPERATION(operation));

        chunk = inf_text_default_delete_operation_get_chunk(
          INF_TEXT_DEFAULT_DELETE_OPERATION(operation)
        );

        /* Need to transmit all deleted data */
        cd = g_iconv_open(&quot;UTF-8&quot;, inf_text_chunk_get_encoding(chunk));
        result = inf_text_chunk_iter_init_begin(chunk, &amp;iter);

        while(result == TRUE)
        {
          text = inf_text_chunk_iter_get_text(&amp;iter);
          total_bytes = inf_text_chunk_iter_get_bytes(&amp;iter);
          bytes_left = total_bytes;
          child = xmlNewChild(op_xml, NULL, (const xmlChar*)&quot;segment&quot;, NULL);

          while(bytes_left &gt; 0)
          {
            inf_text_session_segment_to_xml(
              &amp;cd,
              child,
              text + total_bytes - bytes_left,
              &amp;bytes_left,
              inf_text_chunk_iter_get_author(&amp;iter)
            );
          }

          result = inf_text_chunk_iter_next(&amp;iter);
        }

        g_iconv_close(cd);
      }
      else
      {
        /* Just transmit position and length, the other site generates a
         * InfTextRemoteDeleteOperation from that and is able to restore the
         * deleted text for potential Undo. */
        inf_xml_util_set_attribute_uint(
          op_xml,
          &quot;len&quot;,
          inf_text_delete_operation_get_length(
            INF_TEXT_DELETE_OPERATION(operation)
          )
        );
      }
    }
    else if(for_sync == FALSE &amp;&amp; INF_TEXT_IS_MOVE_OPERATION(operation))
    {
      op_xml = xmlNewNode(NULL, (const xmlChar*)&quot;move&quot;);

      inf_xml_util_set_attribute_uint(
        op_xml,
        &quot;caret&quot;,
        inf_text_move_operation_get_position(
          INF_TEXT_MOVE_OPERATION(operation)
        )
      );

      inf_xml_util_set_attribute_int(
        op_xml,
        &quot;selection&quot;,
        inf_text_move_operation_get_length(INF_TEXT_MOVE_OPERATION(operation))
      );
    }
    else if(for_sync == FALSE &amp;&amp; INF_ADOPTED_IS_NO_OPERATION(operation))
    {
      op_xml = xmlNewNode(NULL, (const xmlChar*)&quot;no-op&quot;);
    }
    else
    {
      g_assert_not_reached();
    }

    break;
  case INF_ADOPTED_REQUEST_UNDO:
    op_xml = xmlNewNode(NULL, (const xmlChar*)&quot;undo-caret&quot;);
    break;
  case INF_ADOPTED_REQUEST_REDO:
    op_xml = xmlNewNode(NULL, (const xmlChar*)&quot;redo-caret&quot;);
    break;
  default:
    g_assert_not_reached();
    break;
  }

  g_assert(op_xml != NULL);

  inf_adopted_session_write_request_info(
    session,
    request,
    diff_vec,
    xml,
    op_xml
  );
}

static InfAdoptedRequest*
inf_text_session_xml_to_request(InfAdoptedSession* session,
                                xmlNodePtr xml,
                                InfAdoptedStateVector* diff_vec,
                                gboolean for_sync,
                                GError** error)
{
  InfTextBuffer* buffer;
  InfAdoptedUser* user;
  guint user_id;
  InfAdoptedStateVector* vector;
  xmlNodePtr op_xml;
  InfAdoptedOperation* operation;
  InfAdoptedRequestType type;
  InfAdoptedRequest* request;

  guint pos;
  gchar* text;
  gsize bytes;
  InfTextChunk* chunk;

  gchar* utf8_text;
  gsize in_bytes;
  guint length;

  xmlNodePtr child;
  GIConv cd;
  guint author;
  gboolean cmp;

  gint selection;

  buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));

  cmp = inf_adopted_session_read_request_info(
    session,
    xml,
    diff_vec,
    &amp;user,
    &amp;vector,
    &amp;op_xml,
    error
  );

  if(cmp == FALSE) return FALSE;
  user_id = (user == NULL) ? 0 : inf_user_get_id(INF_USER(user));

  if(strcmp((const char*)op_xml-&gt;name, &quot;insert&quot;) == 0 ||
     strcmp((const char*)op_xml-&gt;name, &quot;insert-caret&quot;) == 0)
  {
    type = INF_ADOPTED_REQUEST_DO;

    if(!inf_xml_util_get_attribute_uint_required(op_xml, &quot;pos&quot;, &amp;pos, error))
      goto fail;

    utf8_text = inf_xml_util_get_child_text(op_xml, &amp;in_bytes, &amp;length, error);
    if(!utf8_text)
      goto fail;

    text = g_convert(
      utf8_text,
      in_bytes,
      inf_text_buffer_get_encoding(buffer),
      &quot;UTF-8&quot;,
      NULL,
      &amp;bytes,
      error
    );

    g_free(utf8_text);
    if(text == NULL) goto fail;

    chunk = inf_text_chunk_new(inf_text_buffer_get_encoding(buffer));
    inf_text_chunk_insert_text(chunk, 0, text, bytes, length, user_id);
    g_free(text);

    operation = INF_ADOPTED_OPERATION(
      inf_text_default_insert_operation_new(pos, chunk)
    );

    inf_text_chunk_free(chunk);
  }
  else if(strcmp((const char*)op_xml-&gt;name, &quot;delete&quot;) == 0 ||
          strcmp((const char*)op_xml-&gt;name, &quot;delete-caret&quot;) == 0)
  {
    type = INF_ADOPTED_REQUEST_DO;

    if(!inf_xml_util_get_attribute_uint_required(op_xml, &quot;pos&quot;, &amp;pos, error))
      goto fail;

    if(for_sync == TRUE)
    {
      chunk = inf_text_chunk_new(inf_text_buffer_get_encoding(buffer));
      cd = g_iconv_open(inf_text_buffer_get_encoding(buffer), &quot;UTF-8&quot;);
      g_assert(cd != (GIConv)(-1));

      for(child = op_xml-&gt;children; child != NULL; child = child-&gt;next)
      {
        if(strcmp((const char*)child-&gt;name, &quot;segment&quot;) == 0)
        {
          text = inf_text_session_segment_from_xml(
            &amp;cd,
            child,
            &amp;length,
            &amp;bytes,
            &amp;author,
            error
          );

          if(text == NULL)
          {
            inf_text_chunk_free(chunk);
            g_iconv_close(cd);
            goto fail;
          }
          else
          {
            inf_text_chunk_insert_text(
              chunk,
              inf_text_chunk_get_length(chunk),
              text,
              bytes,
              length,
              author
            );

            g_free(text);
          }
        }
        else
        {
          /* TODO: Error */
        }
      }

      g_iconv_close(cd);

      operation = INF_ADOPTED_OPERATION(
        inf_text_default_delete_operation_new(pos, chunk)
      );

      inf_text_chunk_free(chunk);
    }
    else
    {
      cmp = inf_xml_util_get_attribute_uint_required(
        op_xml,
        &quot;len&quot;,
        &amp;length,
        error
      );

      if(cmp == FALSE) goto fail;

      operation = INF_ADOPTED_OPERATION(
        inf_text_remote_delete_operation_new(pos, length)
      );
    }
  }
  else if(strcmp((const char*)op_xml-&gt;name, &quot;move&quot;) == 0)
  {
    type = INF_ADOPTED_REQUEST_DO;

    cmp = inf_xml_util_get_attribute_uint_required(
      op_xml,
      &quot;caret&quot;,
      &amp;pos,
      error
    );

    if(cmp == FALSE) goto fail;

    cmp = inf_xml_util_get_attribute_int_required(
      op_xml,
      &quot;selection&quot;,
      &amp;selection,
      error
    );

    if(cmp == FALSE) goto fail;

    operation = INF_ADOPTED_OPERATION(
      inf_text_move_operation_new(pos, selection)
    );
  }
  else if(strcmp((const char*)op_xml-&gt;name, &quot;no-op&quot;) == 0)
  {
    type = INF_ADOPTED_REQUEST_DO;
    operation = INF_ADOPTED_OPERATION(inf_adopted_no_operation_new());
  }
  else if(strcmp((const char*)op_xml-&gt;name, &quot;undo&quot;) == 0 ||
          strcmp((const char*)op_xml-&gt;name, &quot;undo-caret&quot;) == 0)
  {
    type = INF_ADOPTED_REQUEST_UNDO;
  }
  else if(strcmp((const char*)op_xml-&gt;name, &quot;redo&quot;) == 0 ||
          strcmp((const char*)op_xml-&gt;name, &quot;redo-caret&quot;) == 0)
  {
    type = INF_ADOPTED_REQUEST_REDO;
  }
  else
  {
    /* TODO: Error */
    goto fail;
  }

  switch(type)
  {
  case INF_ADOPTED_REQUEST_DO:
    g_assert(operation != NULL);
    request = inf_adopted_request_new_do(
      vector,
      user_id,
      operation,
      g_get_real_time()
    );
    g_object_unref(operation);
    break;
  case INF_ADOPTED_REQUEST_UNDO:
    request = inf_adopted_request_new_undo(
      vector,
      user_id,
      g_get_real_time()
    );
    break;
  case INF_ADOPTED_REQUEST_REDO:
    request = inf_adopted_request_new_redo(
      vector,
      user_id,
      g_get_real_time()
    );
    break;
  default:
    g_assert_not_reached();
    break;
  }

  inf_adopted_state_vector_free(vector);
  return request;

<A NAME="0"></A>fail:
  inf_adopted_state_vector_free(vector);
  return NULL;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1507-0.html#0',2,'match1507-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

/*
 * Gype registration.
 */

static void
inf_text_session_class_init(InfTextSessionClass* text_session_class)
{
  GObjectClass* object_class;
  InfSessionClass* session_class;
  InfAdoptedSessionClass* adopted_session_class;

  object_class = G_OBJECT_CLASS(text_session_class);
  session_class = INF_SESSION_CLASS(text_session_class);
  adopted_session_class = INF_ADOPTED_SESSION_CLASS(text_session_class);

  object_class-&gt;constructed = inf_text_session_constructed;
  object_class-&gt;dispose = inf_text_session_dispose;
  object_class-&gt;finalize = inf_text_session_finalize;
  object_class-&gt;set_property = inf_text_session_set_property;
  object_class-&gt;get_property = inf_text_session_get_property;

  session_class-&gt;to_xml_sync = inf_text_session_to_xml_sync;
  session_class-&gt;process_xml_sync = inf_text_session_process_xml_sync;</B></FONT>
  session_class-&gt;process_xml_run = inf_text_session_process_xml_run;
  session_class-&gt;get_xml_user_props = inf_text_session_get_xml_user_props;
  session_class-&gt;set_xml_user_props = inf_text_session_set_xml_user_props;
  session_class-&gt;validate_user_props = inf_text_session_validate_user_props;
  session_class-&gt;user_new = inf_text_session_user_new;
  session_class-&gt;synchronization_complete =
    inf_text_session_synchronization_complete;

  adopted_session_class-&gt;xml_to_request = inf_text_session_xml_to_request;
  adopted_session_class-&gt;request_to_xml = inf_text_session_request_to_xml;

  inf_text_session_error_quark = g_quark_from_static_string(
    &quot;INF_TEXT_SESSION_ERROR&quot;
  );

  g_object_class_install_property(
    object_class,
    PROP_CARET_UPDATE_INTERVAL,
    g_param_spec_uint(
      &quot;caret-update-interval&quot;,
      &quot;Caret update interval&quot;,
      &quot;Minimum number of milliseconds between caret update broadcasts&quot;,
      0,
      G_MAXUINT,
      500,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );
}

/*
 * Public API.
 */

/**
 * inf_text_session_new: (constructor)
 * @manager: A #InfCommunicationManager.
 * @buffer: An initial #InfTextBuffer.
 * @io: A #InfIo object.
 * @status: The initial status of the session.
 * @sync_group: (allow-none): A group in which the session is synchronized.
 * Ignored if @status is %INF_SESSION_RUNNING.
 * @sync_connection: (allow-none): A connection to synchronize the session
 * from. Ignored if @status is %INF_SESSION_RUNNING.
 *
 * Creates a new #InfTextSession. The communication manager is used to send
 * and receive requests from subscription and synchronization. @buffer will be
 * set to be initially empty if the session is initially synchronized
 * (see below). @io is required to trigger timeouts.
 *
 * If @status is %INF_SESSION_PRESYNC or %INF_SESSION_SYNCHRONIZING, then the
 * session will initially be sychronized, meaning the initial content is
 * retrieved from @sync_connection. If you are subscribed to the session, set
 * the subscription group via inf_session_set_subscription_group().
 *
 * Returns: (transfer full): A new #InfTextSession.
 **/
InfTextSession*
inf_text_session_new(InfCommunicationManager* manager,
                     InfTextBuffer* buffer,
                     InfIo* io,
                     InfSessionStatus status,
                     InfCommunicationGroup* sync_group,
                     InfXmlConnection* sync_connection)
{
  GObject* object;

  g_return_val_if_fail(INF_COMMUNICATION_IS_MANAGER(manager), NULL);
  g_return_val_if_fail(INF_TEXT_IS_BUFFER(buffer), NULL);
  g_return_val_if_fail(INF_IS_IO(io), NULL);

  g_return_val_if_fail(
    (status == INF_SESSION_RUNNING &amp;&amp;
     sync_group == NULL &amp;&amp; sync_connection == NULL) ||
    (status != INF_SESSION_RUNNING &amp;&amp;
     INF_COMMUNICATION_IS_GROUP(sync_group) &amp;&amp;
     INF_IS_XML_CONNECTION(sync_connection)),
    NULL
  );

  object = g_object_new(
    INF_TEXT_TYPE_SESSION,
    &quot;communication-manager&quot;, manager,
    &quot;buffer&quot;, buffer,
    &quot;status&quot;, status,
    &quot;sync-group&quot;, sync_group,
    &quot;sync-connection&quot;, sync_connection,
    &quot;io&quot;, io,
    NULL
  );

  return INF_TEXT_SESSION(object);
}

/**
 * inf_text_session_new_with_user_table: (constructor)
 * @manager: A #InfCommunicationManager.
 * @buffer: An initial #InfTextBuffer.
 * @io: A #InfIo object.
 * @user_table: A #InfUserTable.
 * @status: The initial status for the session.
 * @sync_group: (allow-none): A group in which the session is synchronized.
 * Ignored if @status is %INF_SESSION_RUNNING.
 * @sync_connection: (allow-none): A connection to synchronize the session
 * from. Ignored if @status is %INF_SESSION_RUNNING.
 *
 * Creates a new #InfTextSession. The connection manager is used to send and
 * receive requests from subscription and synchronization. @buffer will be
 * set to be initially empty if the session is initially synchronized
 * (see below). @io is required to trigger timeouts.
 *
 * If @status is %INF_SESSION_PRESYNC or %INF_SESSION_SYNCHRONIZING, then the
 * session will initially be sychronized, meaning the initial content is
 * retrieved from @sync_connection. If you are subscribed to the session, set
 * the subscription group via inf_session_set_subscription_group().
 *
 * @user_table is used as an initial user table. The user table should only
 * contain unavailable users, if any, that may rejoin during the session. If
 * there was an available user in the user table, it would probably belong
 * to another session, but different sessions cannot share the same user
 * object.
 *
 * Returns: (transfer full): A new #InfTextSession.
 **/
InfTextSession*
inf_text_session_new_with_user_table(InfCommunicationManager* manager,
                                     InfTextBuffer* buffer,
                                     InfIo* io,
                                     InfUserTable* user_table,
                                     InfSessionStatus status,
                                     InfCommunicationGroup* sync_group,
                                     InfXmlConnection* sync_connection)
{
  /* TODO: Can it happen that the user_table is set explicitely PLUS the
   * session is synchronized? If not then this function can be simplified */

  GObject* object;

  g_return_val_if_fail(INF_COMMUNICATION_IS_MANAGER(manager), NULL);
  g_return_val_if_fail(INF_TEXT_IS_BUFFER(buffer), NULL);
  g_return_val_if_fail(INF_IS_IO(io), NULL);
  g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);

  g_return_val_if_fail(
    (status == INF_SESSION_RUNNING &amp;&amp;
     sync_group == NULL &amp;&amp; sync_connection == NULL) ||
    (status != INF_SESSION_RUNNING &amp;&amp;
     INF_COMMUNICATION_IS_GROUP(sync_group) &amp;&amp;
     INF_IS_XML_CONNECTION(sync_connection)),
    NULL
  );

  object = g_object_new(
    INF_TEXT_TYPE_SESSION,
    &quot;communication-manager&quot;, manager,
    &quot;buffer&quot;, buffer,
    &quot;user-table&quot;, user_table,
    &quot;status&quot;, status,
    &quot;sync-group&quot;, sync_group,
    &quot;sync-connection&quot;, sync_connection,
    &quot;io&quot;, io,
    NULL
  );

  return INF_TEXT_SESSION(object);
}

/**
 * inf_text_session_set_user_color:
 * @session: A #InfTextSession.
 * @user: A local #InfTextUser from @session's user table.
 * @hue: New hue value for @user's color. Ranges from 0.0 (red) to 1.0 (red).
 *
 * Changes the user color of @user. @user must have the %INF_USER_LOCAL flag
 * set.
 */
void
inf_text_session_set_user_color(InfTextSession* session,
                                InfTextUser* user,
                                gdouble hue)
{
  xmlNodePtr xml;

  g_return_if_fail(INF_TEXT_IS_SESSION(session));
  g_return_if_fail(INF_TEXT_IS_USER(user));
  g_return_if_fail(hue &gt;= 0.0 &amp;&amp; hue &lt;= 1.0);

  g_return_if_fail(
    inf_user_get_status(INF_USER(user)) != INF_USER_UNAVAILABLE
  );
  g_return_if_fail(
    (inf_user_get_flags(INF_USER(user)) &amp; INF_USER_LOCAL) != 0
  );

  xml = xmlNewNode(NULL, (const xmlChar*)&quot;user-color-change&quot;);
  inf_xml_util_set_attribute_uint(xml, &quot;id&quot;, inf_user_get_id(INF_USER(user)));
  inf_xml_util_set_attribute_double(xml, &quot;hue&quot;, hue);

  inf_session_send_to_subscriptions(INF_SESSION(session), xml);
  g_object_set(G_OBJECT(user), &quot;hue&quot;, hue, NULL);
}

/**
 * inf_text_session_flush_requests_for_user:
 * @session: A #InfTextSession.
 * @user: The #InfTextUser for which to flush messages.
 *
 * This function sends all pending requests for @user immediately. Requests
 * that modify the buffer are not queued normally, but cursor movement
 * requests are delayed in case are issued frequently, to save bandwidth.
 *
 * The main purpose of this function is to send all pending requests before
 * changing a user's status to inactive or unavailable since inactive users
 * are automatically activated as soon as they issue a request.
 *
 * TODO: We should probably detect this automatically, without requiring
 * people to call this function, i.e. flush requests for local users just
 * before they become inactive.
 *
 * @user must have the %INF_USER_LOCAL flag set.
 */
void
inf_text_session_flush_requests_for_user(InfTextSession* session,
                                         InfTextUser* user)
{
  InfTextSessionLocalUser* local;

  g_return_if_fail(INF_TEXT_IS_SESSION(session));
  g_return_if_fail(INF_TEXT_IS_USER(user));

  local = inf_text_session_find_local_user(session, user);
  g_assert(local != NULL);

  if(local-&gt;caret_timeout != NULL)
  {
    inf_text_session_broadcast_caret_selection(session, local);
  }
}

/**
 * inf_text_session_join_user:
 * @proxy: A #InfSessionProxy with a #InfTextSession session.
 * @name: The name of the user to join.
 * @status: The initial status of the user to join. Must not be
 * @INF_USER_UNAVAILABLE.
 * @hue: The user color of the user to join.
 * @caret_position: The initial position of the new user's cursor.
 * @selection_length: The initial length of the new user's selection.
 * @func: (scope async): Function to call after completion of the request,
 * or %NULL.
 * @user_data: Additional data to pass to @func.
 *
 * This functions creates a user join request for an #InfTextSession. This is
 * a shortcut for inf_session_proxy_join_user().
 *
 * Returns: (transfer full): A #InfRequest, or %NULL.
 */
InfRequest*
inf_text_session_join_user(InfSessionProxy* proxy,
                           const gchar* name,
                           InfUserStatus status,
                           gdouble hue,
                           guint caret_position,
                           int selection_length,
                           InfRequestFunc func,
                           gpointer user_data)
{
#define N_PARAMS 6u
  GParameter params[N_PARAMS] = {
    { &quot;hue&quot;, { 0 } },
    { &quot;vector&quot;, { 0 } },
    { &quot;caret-position&quot;, { 0 } },
    { &quot;selection-length&quot;, { 0 } },
    { &quot;name&quot;, { 0 } },
    { &quot;status&quot;, { 0 } }
  };

  InfSession* session;
  InfRequest* request;
  guint i;

  g_return_val_if_fail(INF_IS_SESSION_PROXY(proxy), NULL);
  
  g_object_get(G_OBJECT(proxy), &quot;session&quot;, &amp;session, NULL);
  g_return_val_if_fail(INF_TEXT_IS_SESSION(session), NULL);

  g_value_init(&amp;params[0].value, G_TYPE_DOUBLE);
  g_value_set_double(&amp;params[0].value, hue);

  g_value_init(&amp;params[1].value, INF_ADOPTED_TYPE_STATE_VECTOR);
  g_value_set_boxed(
    &amp;params[1].value,
    inf_adopted_algorithm_get_current(
      inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session))
    )
  );

  g_value_init(&amp;params[2].value, G_TYPE_UINT);
  g_value_set_uint(&amp;params[2].value, caret_position);

  g_value_init(&amp;params[3].value, G_TYPE_INT);
  g_value_set_int(&amp;params[3].value, selection_length);

  g_value_init(&amp;params[4].value, G_TYPE_STRING);
  g_value_set_string(&amp;params[4].value, name); /* TODO: set_static_string? */

  g_value_init(&amp;params[5].value, INF_TYPE_USER_STATUS);
  g_value_set_enum(&amp;params[5].value, status);

  request = inf_session_proxy_join_user(
    proxy,
    N_PARAMS,
    params,
    func,
    user_data
  );

  for(i = 0; i &lt; N_PARAMS; ++i)
    g_value_unset(&amp;params[i].value);
#undef N_PARAMS

  g_object_unref(session);
  return request;
}

/* vim:set et sw=2 ts=2: */
</PRE>
</div>
  </div>
</body>
</html>
