
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.099150141643059%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-pelican_memory.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_PELICAN
3  int pelican_memory(const unsigned char *key, unsigned long keylen,
4                     const unsigned char *in,  unsigned long inlen,
5                           unsigned char *out)
6  {
7     pelican_state *pel;
8     int err;
9     pel = XMALLOC(sizeof(*pel));
10     if (pel == NULL) {
11        return CRYPT_MEM;
12     }
<span onclick='openModal()' class='match'>13     if ((err = pelican_init(pel, key, keylen)) != CRYPT_OK) {
14        XFREE(pel);
15        return err;
16     }
17     if ((err = pelican_process(pel, in ,inlen)) != CRYPT_OK) {
18        XFREE(pel);
19        return err;
20     }
21     err = pelican_done(pel, out);
</span>22     XFREE(pel);
23     return err;
24  }
25  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-dsa_generate_pqg.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_MDSA
3  static int s_dsa_make_params(prng_state *prng, int wprng, int group_size, int modulus_size, void *p, void *q, void *g)
4  {
5    unsigned long L, N, n, outbytes, seedbytes, counter, j, i;
6    int err, res, mr_tests_q, mr_tests_p, found_p, found_q, hash;
7    unsigned char *wbuf, *sbuf, digest[MAXBLOCKSIZE];
8    void *t2L1, *t2N1, *t2q, *t2seedlen, *U, *W, *X, *c, *h, *e, *seedinc;
9    const char *accepted_hashes[] = { "sha3-512", "sha512", "sha3-384", "sha384", "sha3-256", "sha256" };
10    if (group_size > LTC_MDSA_MAX_GROUP || group_size < 1 || group_size >= modulus_size || modulus_size > LTC_MDSA_MAX_MODULUS) {
11      return CRYPT_INVALID_ARG;
12    }
13    seedbytes = group_size;
14    L = (unsigned long)modulus_size * 8;
15    N = (unsigned long)group_size * 8;
16  #ifdef LTC_MPI_HAS_LUCAS_TEST
17    mr_tests_p = (L <= 2048) ? 3 : 2;
18    if      (N <= 160)  { mr_tests_q = 19; }
19    else if (N <= 224)  { mr_tests_q = 24; }
20    else                { mr_tests_q = 27; }
21  #else
22    if      (L <= 1024) { mr_tests_p = 40; }
23    else if (L <= 2048) { mr_tests_p = 56; }
24    else                { mr_tests_p = 64; }
25    if      (N <= 160)  { mr_tests_q = 40; }
26    else if (N <= 224)  { mr_tests_q = 56; }
27    else                { mr_tests_q = 64; }
28  #endif
29    hash = -1;
30    for (i = 0; i < sizeof(accepted_hashes)/sizeof(accepted_hashes[0]); ++i) {
31      hash = find_hash(accepted_hashes[i]);
32      if (hash != -1) break;
33    }
34    if (hash == -1) {
35      return CRYPT_INVALID_ARG; &bsol;* no appropriate hash function found */
36    }
<span onclick='openModal()' class='match'>37    if (N > hash_descriptor[hash].hashsize * 8) {
38      return CRYPT_INVALID_ARG; &bsol;* group_size too big */
39    }
40    if ((err = hash_is_valid(hash)) != CRYPT_OK)                                   { return err; }
41    outbytes = hash_descriptor[hash].hashsize;
</span>42    n = ((L + outbytes*8 - 1) / (outbytes*8)) - 1;
43    if ((wbuf = XMALLOC((n+1)*outbytes)) == NULL)                                  { err = CRYPT_MEM; goto cleanup3; }
44    if ((sbuf = XMALLOC(seedbytes)) == NULL)                                       { err = CRYPT_MEM; goto cleanup2; }
45    err = mp_init_multi(&t2L1, &t2N1, &t2q, &t2seedlen, &U, &W, &X, &c, &h, &e, &seedinc, LTC_NULL);
46    if (err != CRYPT_OK)                                                           { goto cleanup1; }
47    if ((err = mp_2expt(t2L1, L-1)) != CRYPT_OK)                                   { goto cleanup; }
48    if ((err = mp_2expt(t2N1, N-1)) != CRYPT_OK)                                   { goto cleanup; }
49    if ((err = mp_2expt(t2seedlen, seedbytes*8)) != CRYPT_OK)                      { goto cleanup; }
50    for(found_p=0; !found_p;) {
51      for(found_q=0; !found_q;) {
52        if (prng_descriptor[wprng].read(sbuf, seedbytes, prng) != seedbytes)       { err = CRYPT_ERROR_READPRNG; goto cleanup; }
53        i = outbytes;
54        if ((err = hash_memory(hash, sbuf, seedbytes, digest, &i)) != CRYPT_OK)    { goto cleanup; }
55        if ((err = mp_read_unsigned_bin(U, digest, outbytes)) != CRYPT_OK)         { goto cleanup; }
56        if ((err = mp_mod(U, t2N1, U)) != CRYPT_OK)                                { goto cleanup; }
57        if ((err = mp_add(t2N1, U, q)) != CRYPT_OK)                                { goto cleanup; }
58        if (!mp_isodd(q)) mp_add_d(q, 1, q);
59        if ((err = mp_prime_is_prime(q, mr_tests_q, &res)) != CRYPT_OK)            { goto cleanup; }
60        if (res == LTC_MP_YES) found_q = 1;
61      }
62      if ((err = mp_read_unsigned_bin(seedinc, sbuf, seedbytes)) != CRYPT_OK)      { goto cleanup; }
63      if ((err = mp_add(q, q, t2q)) != CRYPT_OK)                                   { goto cleanup; }
64      for(counter=0; counter < 4*L && !found_p; counter++) {
65        for(j=0; j<=n; j++) {
66          if ((err = mp_add_d(seedinc, 1, seedinc)) != CRYPT_OK)                   { goto cleanup; }
67          if ((err = mp_mod(seedinc, t2seedlen, seedinc)) != CRYPT_OK)             { goto cleanup; }
68          if ((i = mp_unsigned_bin_size(seedinc)) > seedbytes)                     { err = CRYPT_INVALID_ARG; goto cleanup; }
69          zeromem(sbuf, seedbytes);
70          if ((err = mp_to_unsigned_bin(seedinc, sbuf + seedbytes-i)) != CRYPT_OK) { goto cleanup; }
71          i = outbytes;
72          err = hash_memory(hash, sbuf, seedbytes, wbuf+(n-j)*outbytes, &i);
73          if (err != CRYPT_OK)                                                     { goto cleanup; }
74        }
75        if ((err = mp_read_unsigned_bin(W, wbuf, (n+1)*outbytes)) != CRYPT_OK)     { goto cleanup; }
76        if ((err = mp_mod(W, t2L1, W)) != CRYPT_OK)                                { goto cleanup; }
77        if ((err = mp_add(W, t2L1, X)) != CRYPT_OK)                                { goto cleanup; }
78        if ((err = mp_mod(X, t2q, c))  != CRYPT_OK)                                { goto cleanup; }
79        if ((err = mp_sub_d(c, 1, p))  != CRYPT_OK)                                { goto cleanup; }
80        if ((err = mp_sub(X, p, p))    != CRYPT_OK)                                { goto cleanup; }
81        if (mp_cmp(p, t2L1) != LTC_MP_LT) {
82          if ((err = mp_prime_is_prime(p, mr_tests_p, &res)) != CRYPT_OK)          { goto cleanup; }
83          if (res == LTC_MP_YES) {
84            found_p = 1;
85          }
86        }
87      }
88    }
89    if ((err = mp_sub_d(p, 1, e)) != CRYPT_OK)                                     { goto cleanup; }
90    if ((err = mp_div(e, q, e, c)) != CRYPT_OK)                                    { goto cleanup; }
91    i = mp_count_bits(p);
92    do {
93      do {
94        if ((err = rand_bn_bits(h, i, prng, wprng)) != CRYPT_OK)                   { goto cleanup; }
95      } while (mp_cmp(h, p) != LTC_MP_LT || mp_cmp_d(h, 2) != LTC_MP_GT);
96      if ((err = mp_sub_d(h, 1, h)) != CRYPT_OK)                                   { goto cleanup; }
97      if ((err = mp_exptmod(h, e, p, g)) != CRYPT_OK)                              { goto cleanup; }
98    } while (mp_cmp_d(g, 1) == LTC_MP_EQ);
99    err = CRYPT_OK;
100  cleanup:
101    mp_clear_multi(t2L1, t2N1, t2q, t2seedlen, U, W, X, c, h, e, seedinc, LTC_NULL);
102  cleanup1:
103    XFREE(sbuf);
104  cleanup2:
105    XFREE(wbuf);
106  cleanup3:
107    return err;
108  }
109  int dsa_generate_pqg(prng_state *prng, int wprng, int group_size, int modulus_size, dsa_key *key)
110  {
111     int err;
112     LTC_ARGCHK(key         != NULL);
113     LTC_ARGCHK(ltc_mp.name != NULL);
114     if ((err = mp_init_multi(&key->p, &key->g, &key->q, &key->x, &key->y, LTC_NULL)) != CRYPT_OK) {
115        return err;
116     }
117     err = s_dsa_make_params(prng, wprng, group_size, modulus_size, key->p, key->q, key->g);
118     if (err != CRYPT_OK) {
119        goto cleanup;
120     }
121     key->qord = group_size;
122     return CRYPT_OK;
123  cleanup:
124     dsa_free(key);
125     return err;
126  }
127  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-pelican_memory.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-dsa_generate_pqg.c</div>
                </div>
                <div class="column column_space"><pre><code>13     if ((err = pelican_init(pel, key, keylen)) != CRYPT_OK) {
14        XFREE(pel);
15        return err;
16     }
17     if ((err = pelican_process(pel, in ,inlen)) != CRYPT_OK) {
18        XFREE(pel);
19        return err;
20     }
21     err = pelican_done(pel, out);
</pre></code></div>
                <div class="column column_space"><pre><code>37    if (N > hash_descriptor[hash].hashsize * 8) {
38      return CRYPT_INVALID_ARG; &bsol;* group_size too big */
39    }
40    if ((err = hash_is_valid(hash)) != CRYPT_OK)                                   { return err; }
41    outbytes = hash_descriptor[hash].hashsize;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    