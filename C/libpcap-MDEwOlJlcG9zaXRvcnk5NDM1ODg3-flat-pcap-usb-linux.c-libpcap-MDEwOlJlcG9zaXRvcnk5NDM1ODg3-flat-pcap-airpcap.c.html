
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-usb-linux.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include "pcap-int.h"
5  #include "pcap-usb-linux.h"
6  #include "pcap-usb-linux-common.h"
7  #include "pcap/usb.h"
8  #include "extract.h"
9  #ifdef NEED_STRERROR_H
10  #include "strerror.h"
11  #endif
12  #include <errno.h>
13  #include <stdlib.h>
14  #include <unistd.h>
15  #include <fcntl.h>
16  #include <limits.h>
17  #include <string.h>
18  #include <dirent.h>
19  #include <byteswap.h>
20  #include <netinet/in.h>
21  #include <sys/ioctl.h>
22  #include <sys/mman.h>
23  #include <sys/utsname.h>
24  #ifdef HAVE_LINUX_USBDEVICE_FS_H
25  #ifdef HAVE_LINUX_COMPILER_H
26  #include <linux/compiler.h>
27  #endif &bsol;* HAVE_LINUX_COMPILER_H */
28  #include <linux/usbdevice_fs.h>
29  #endif &bsol;* HAVE_LINUX_USBDEVICE_FS_H */
30  #include "diag-control.h"
31  #define USB_IFACE "usbmon"
32  #define USBMON_DEV_PREFIX "usbmon"
33  #define USBMON_DEV_PREFIX_LEN	(sizeof USBMON_DEV_PREFIX - 1)
34  #define USB_LINE_LEN 4096
35  #if __BYTE_ORDER == __LITTLE_ENDIAN
36  #define htols(s) s
37  #define htoll(l) l
38  #define htol64(ll) ll
39  #else
40  #define htols(s) bswap_16(s)
41  #define htoll(l) bswap_32(l)
42  #define htol64(ll) bswap_64(ll)
43  #endif
44  struct mon_bin_stats {
45  	uint32_t queued;
46  	uint32_t dropped;
47  };
48  struct mon_bin_get {
49  	pcap_usb_header *hdr;
50  	void *data;
51  	size_t data_len;   &bsol;* Length of data (can be zero) */
52  };
53  struct mon_bin_mfetch {
54  	int32_t *offvec;   &bsol;* Vector of events fetched */
55  	int32_t nfetch;    &bsol;* Number of events to fetch (out: fetched) */
56  	int32_t nflush;    &bsol;* Number of events to flush */
57  };
58  #define MON_IOC_MAGIC 0x92
59  #define MON_IOCQ_URB_LEN _IO(MON_IOC_MAGIC, 1)
60  #define MON_IOCX_URB  _IOWR(MON_IOC_MAGIC, 2, struct mon_bin_hdr)
61  #define MON_IOCG_STATS _IOR(MON_IOC_MAGIC, 3, struct mon_bin_stats)
62  #define MON_IOCT_RING_SIZE _IO(MON_IOC_MAGIC, 4)
63  #define MON_IOCQ_RING_SIZE _IO(MON_IOC_MAGIC, 5)
64  #define MON_IOCX_GET   _IOW(MON_IOC_MAGIC, 6, struct mon_bin_get)
65  #define MON_IOCX_MFETCH _IOWR(MON_IOC_MAGIC, 7, struct mon_bin_mfetch)
66  #define MON_IOCH_MFLUSH _IO(MON_IOC_MAGIC, 8)
67  #define MON_BIN_SETUP	0x1 &bsol;* setup hdr is present*/
68  #define MON_BIN_SETUP_ZERO	0x2 &bsol;* setup buffer is not available */
69  #define MON_BIN_DATA_ZERO	0x4 &bsol;* data buffer is not available */
70  #define MON_BIN_ERROR	0x8
71  struct pcap_usb_linux {
72  	u_char *mmapbuf;	&bsol;* memory-mapped region pointer */
73  	size_t mmapbuflen;	&bsol;* size of region */
74  	int bus_index;
75  	u_int packets_read;
76  };
77  static int usb_activate(pcap_t *);
78  static int usb_stats_linux_bin(pcap_t *, struct pcap_stat *);
79  static int usb_read_linux_bin(pcap_t *, int , pcap_handler , u_char *);
80  static int usb_read_linux_mmap(pcap_t *, int , pcap_handler , u_char *);
81  static int usb_inject_linux(pcap_t *, const void *, int);
82  static int usb_setdirection_linux(pcap_t *, pcap_direction_t);
83  static void usb_cleanup_linux_mmap(pcap_t *);
84  static int
85  usb_dev_add(pcap_if_list_t *devlistp, int n, char *err_str)
86  {
87  	char dev_name[10];
88  	char dev_descr[30];
89  	snprintf(dev_name, 10, USB_IFACE"%d", n);
90  	if (n == 0) {
91  		if (pcap_add_dev(devlistp, dev_name,
92  		    PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE,
93  		    "Raw USB traffic, all USB buses", err_str) == NULL)
94  			return -1;
95  	} else {
96  		snprintf(dev_descr, 30, "Raw USB traffic, bus number %d", n);
97  		if (pcap_add_dev(devlistp, dev_name, 0, dev_descr, err_str) == NULL)
98  			return -1;
99  	}
100  	return 0;
101  }
102  int
103  usb_findalldevs(pcap_if_list_t *devlistp, char *err_str)
104  {
105  	struct dirent* data;
106  	int ret = 0;
107  	DIR* dir;
108  	int n;
109  	char* name;
110  	dir = opendir("/dev");
111  	if (dir != NULL) {
112  		while ((ret == 0) && ((data = readdir(dir)) != 0)) {
113  			name = data->d_name;
114  			if (strncmp(name, USBMON_DEV_PREFIX,
115  			    USBMON_DEV_PREFIX_LEN) != 0)
116  				continue;	&bsol;* no */
117  			if (sscanf(&name[USBMON_DEV_PREFIX_LEN], "%d", &n) == 0)
118  				continue;	&bsol;* failed */
119  			ret = usb_dev_add(devlistp, n, err_str);
120  		}
121  		closedir(dir);
122  	}
123  	return 0;
124  }
125  #define MIN_RING_SIZE	(8*1024)
126  #define MAX_RING_SIZE	(1200*1024)
127  static int
128  usb_set_ring_size(pcap_t* handle, int header_size)
129  {
130  	int ring_size;
131  	if (handle->snapshot < header_size)
132  		handle->snapshot = header_size;
133  	ring_size = (handle->snapshot - header_size) * 5;
134  	if (ring_size > MAX_RING_SIZE) {
135  		ring_size = MAX_RING_SIZE;
136  		handle->snapshot = header_size + (MAX_RING_SIZE/5);
137  	} else if (ring_size < MIN_RING_SIZE) {
138  		ring_size = MIN_RING_SIZE;
139  	}
140  	if (ioctl(handle->fd, MON_IOCT_RING_SIZE, ring_size) == -1) {
141  		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
142  		    errno, "Can't set ring size from fd %d", handle->fd);
143  		return -1;
144  	}
145  	return ring_size;
146  }
147  static
148  int usb_mmap(pcap_t* handle)
149  {
150  	struct pcap_usb_linux *handlep = handle->priv;
151  	int len;
152  	len = usb_set_ring_size(handle, (int)sizeof(pcap_usb_header_mmapped));
153  	if (len == -1) {
154  		return 0;
155  	}
156  	handlep->mmapbuflen = len;
157  	handlep->mmapbuf = mmap(0, handlep->mmapbuflen, PROT_READ,
158  	    MAP_SHARED, handle->fd, 0);
159  	if (handlep->mmapbuf == MAP_FAILED) {
160  		return 0;
161  	}
162  	return 1;
163  }
164  #ifdef HAVE_LINUX_USBDEVICE_FS_H
165  #define CTRL_TIMEOUT    (5*1000)        &bsol;* milliseconds */
166  #define USB_DIR_IN		0x80
167  #define USB_TYPE_STANDARD	0x00
168  #define USB_RECIP_DEVICE	0x00
169  #define USB_REQ_GET_DESCRIPTOR	6
170  #define USB_DT_DEVICE		1
171  #define USB_DT_CONFIG		2
172  #define USB_DEVICE_DESCRIPTOR_SIZE	18
173  #define USB_CONFIG_DESCRIPTOR_SIZE	9
174  static void
175  probe_devices(int bus)
176  {
177  	struct usbdevfs_ctrltransfer ctrl;
178  	struct dirent* data;
179  	int ret = 0;
180  	char busdevpath[sizeof("/dev/bus/usb/000/") + NAME_MAX];
181  	DIR* dir;
182  	uint8_t descriptor[USB_DEVICE_DESCRIPTOR_SIZE];
183  	uint8_t configdesc[USB_CONFIG_DESCRIPTOR_SIZE];
184  	snprintf(busdevpath, sizeof(busdevpath), "/dev/bus/usb/%03d", bus);
185  	dir = opendir(busdevpath);
186  	if (!dir)
187  		return;
188  	while ((ret >= 0) && ((data = readdir(dir)) != 0)) {
189  		int fd;
190  		char* name = data->d_name;
191  		if (name[0] == '.')
192  			continue;
193  		snprintf(busdevpath, sizeof(busdevpath), "/dev/bus/usb/%03d/%s", bus, data->d_name);
194  		fd = open(busdevpath, O_RDWR);
195  		if (fd == -1)
196  			continue;
197  #ifdef HAVE_STRUCT_USBDEVFS_CTRLTRANSFER_BREQUESTTYPE
198  		ctrl.bRequestType = USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE;
199  		ctrl.bRequest = USB_REQ_GET_DESCRIPTOR;
200  		ctrl.wValue = USB_DT_DEVICE << 8;
201  		ctrl.wIndex = 0;
202  		ctrl.wLength = sizeof(descriptor);
203  #else
204  		ctrl.requesttype = USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE;
205  		ctrl.request = USB_REQ_GET_DESCRIPTOR;
206  		ctrl.value = USB_DT_DEVICE << 8;
207  		ctrl.index = 0;
208  		ctrl.length = sizeof(descriptor);
209  #endif
210  		ctrl.data = descriptor;
211  		ctrl.timeout = CTRL_TIMEOUT;
212  		ret = ioctl(fd, USBDEVFS_CONTROL, &ctrl);
213  #ifdef HAVE_STRUCT_USBDEVFS_CTRLTRANSFER_BREQUESTTYPE
214  		ctrl.wValue = USB_DT_CONFIG << 8;
215  		ctrl.wLength = sizeof(configdesc);
216  #else
217  		ctrl.value = USB_DT_CONFIG << 8;
218  		ctrl.length = sizeof(configdesc);
219  #endif
220  		ctrl.data = configdesc;
221  		ret = ioctl(fd, USBDEVFS_CONTROL, &ctrl);
222  		if (ret >= 0) {
223  			uint16_t wtotallength;
224  			wtotallength = EXTRACT_LE_U_2(&configdesc[2]);
225  #ifdef HAVE_STRUCT_USBDEVFS_CTRLTRANSFER_BREQUESTTYPE
226  			ctrl.wLength = wtotallength;
227  #else
228  			ctrl.length = wtotallength;
229  #endif
230  			ctrl.data = malloc(wtotallength);
231  			if (ctrl.data) {
232  				ret = ioctl(fd, USBDEVFS_CONTROL, &ctrl);
233  				free(ctrl.data);
234  			}
235  		}
236  		close(fd);
237  	}
238  	closedir(dir);
239  }
240  #endif &bsol;* HAVE_LINUX_USBDEVICE_FS_H */
241  pcap_t *
242  usb_create(const char *device, char *ebuf, int *is_ours)
243  {
244  	const char *cp;
245  	char *cpend;
246  	long devnum;
247  	pcap_t *p;
248  	cp = strrchr(device, '/');
249  	if (cp == NULL)
250  		cp = device;
251  	if (strncmp(cp, USB_IFACE, sizeof USB_IFACE - 1) != 0) {
252  		*is_ours = 0;
253  		return NULL;
254  	}
255  	cp += sizeof USB_IFACE - 1;
256  	devnum = strtol(cp, &cpend, 10);
257  	if (cpend == cp || *cpend != '\0') {
258  		*is_ours = 0;
259  		return NULL;
260  	}
261  	if (devnum < 0) {
262  		*is_ours = 0;
263  		return NULL;
264  	}
265  	*is_ours = 1;
266  	p = PCAP_CREATE_COMMON(ebuf, struct pcap_usb_linux);
267  	if (p == NULL)
268  		return (NULL);
269  	p->activate_op = usb_activate;
270  	return (p);
271  }
272  static int
273  usb_activate(pcap_t* handle)
274  {
275  	struct pcap_usb_linux *handlep = handle->priv;
276  	char		full_path[USB_LINE_LEN];
277  	if (handle->snapshot <= 0 || handle->snapshot > MAXIMUM_SNAPLEN)
278  		handle->snapshot = MAXIMUM_SNAPLEN;
279  	handle->bufsize = handle->snapshot;
280  	handle->offset = 0;
281  	handle->linktype = DLT_USB_LINUX;
282  	handle->inject_op = usb_inject_linux;
283  	handle->setfilter_op = pcap_install_bpf_program; &bsol;* no kernel filtering */
284  	handle->setdirection_op = usb_setdirection_linux;
285  	handle->set_datalink_op = NULL;	&bsol;* can't change data link type */
286  	handle->getnonblock_op = pcap_getnonblock_fd;
287  	handle->setnonblock_op = pcap_setnonblock_fd;
288  	if (sscanf(handle->opt.device, USB_IFACE"%d", &handlep->bus_index) != 1)
289  	{
290  		snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
291  			"Can't get USB bus index from %s", handle->opt.device);
292  		return PCAP_ERROR;
293  	}
294  	snprintf(full_path, USB_LINE_LEN, "/dev/"USBMON_DEV_PREFIX"%d",
295  	    handlep->bus_index);
296  	handle->fd = open(full_path, O_RDONLY, 0);
297  	if (handle->fd < 0)
298  	{
299  		switch (errno) {
300  		case ENOENT:
301  			handle->errbuf[0] = '\0';
302  			return PCAP_ERROR_NO_SUCH_DEVICE;
303  		case EACCES:
304  DIAG_OFF_FORMAT_TRUNCATION
305  			snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
306  			    "Attempt to open %s failed with EACCES - root privileges may be required",
307  			    full_path);
308  DIAG_ON_FORMAT_TRUNCATION
309  			return PCAP_ERROR_PERM_DENIED;
310  		default:
311  			pcap_fmt_errmsg_for_errno(handle->errbuf,
312  			    PCAP_ERRBUF_SIZE, errno,
313  			    "Can't open USB bus file %s", full_path);
314  			return PCAP_ERROR;
315  		}
316  	}
317  	if (handle->opt.rfmon)
318  	{
319  		close(handle->fd);
320  		return PCAP_ERROR_RFMON_NOTSUP;
321  	}
322  	if (usb_mmap(handle))
323  	{
324  		handle->linktype = DLT_USB_LINUX_MMAPPED;
325  		handle->stats_op = usb_stats_linux_bin;
326  		handle->read_op = usb_read_linux_mmap;
327  		handle->cleanup_op = usb_cleanup_linux_mmap;
328  #ifdef HAVE_LINUX_USBDEVICE_FS_H
329  		probe_devices(handlep->bus_index);
330  #endif
331  		handle->selectable_fd = handle->fd;
332  		return 0;
333  	}
334  	if (usb_set_ring_size(handle, (int)sizeof(pcap_usb_header)) == -1) {
335  		close(handle->fd);
336  		return PCAP_ERROR;
337  	}
338  	handle->stats_op = usb_stats_linux_bin;
339  	handle->read_op = usb_read_linux_bin;
340  #ifdef HAVE_LINUX_USBDEVICE_FS_H
341  	probe_devices(handlep->bus_index);
342  #endif
343  	handle->selectable_fd = handle->fd;
344  	handle->buffer = malloc(handle->bufsize);
345  	if (!handle->buffer) {
346  		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
347  		    errno, "malloc");
348  		close(handle->fd);
349  		return PCAP_ERROR;
350  	}
351  	return 0;
352  }
353  static int
354  usb_inject_linux(pcap_t *handle, const void *buf _U_, int size _U_)
355  {
356  	snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
357  	    "Packet injection is not supported on USB devices");
358  	return (-1);
359  }
360  static int
361  usb_setdirection_linux(pcap_t *p, pcap_direction_t d)
362  {
363  	p->direction = d;
364  	return 0;
365  }
366  static int
367  usb_stats_linux_bin(pcap_t *handle, struct pcap_stat *stats)
368  {
369  	struct pcap_usb_linux *handlep = handle->priv;
370  	int ret;
371  	struct mon_bin_stats st;
372  	ret = ioctl(handle->fd, MON_IOCG_STATS, &st);
373  	if (ret < 0)
374  	{
375  		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
376  		    errno, "Can't read stats from fd %d", handle->fd);
377  		return -1;
378  	}
379  	stats->ps_recv = handlep->packets_read + st.queued;
380  	stats->ps_drop = st.dropped;
381  	stats->ps_ifdrop = 0;
382  	return 0;
383  }
384  static int
385  usb_read_linux_bin(pcap_t *handle, int max_packets _U_, pcap_handler callback, u_char *user)
386  {
387  	struct pcap_usb_linux *handlep = handle->priv;
388  	struct mon_bin_get info;
389  	int ret;
390  	struct pcap_pkthdr pkth;
391  	u_int clen = handle->snapshot - sizeof(pcap_usb_header);
392  	info.hdr = (pcap_usb_header*) handle->buffer;
393  	info.data = handle->buffer + sizeof(pcap_usb_header);
394  	info.data_len = clen;
395  	do {
396  		ret = ioctl(handle->fd, MON_IOCX_GET, &info);
397  		if (handle->break_loop)
398  		{
399  			handle->break_loop = 0;
400  			return -2;
401  		}
402  	} while ((ret == -1) && (errno == EINTR));
403  	if (ret < 0)
404  	{
405  		if (errno == EAGAIN)
406  			return 0;	&bsol;* no data there */
407  		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
408  		    errno, "Can't read from fd %d", handle->fd);
409  		return -1;
410  	}
411  	if (info.hdr->data_len < clen)
412  		clen = info.hdr->data_len;
413  	info.hdr->data_len = clen;
414  	pkth.caplen = sizeof(pcap_usb_header) + clen;
415  	if (info.hdr->data_flag) {
416  		pkth.len = sizeof(pcap_usb_header) + info.hdr->data_len;
417  	} else {
418  		pkth.len = sizeof(pcap_usb_header) + info.hdr->urb_len;
419  	}
420  	pkth.ts.tv_sec = (time_t)info.hdr->ts_sec;
421  	pkth.ts.tv_usec = info.hdr->ts_usec;
422  	if (handle->fcode.bf_insns == NULL ||
423  	    pcap_filter(handle->fcode.bf_insns, handle->buffer,
424  	      pkth.len, pkth.caplen)) {
425  		handlep->packets_read++;
426  		callback(user, &pkth, handle->buffer);
427  		return 1;
428  	}
429  	return 0;	&bsol;* didn't pass filter */
430  }
431  #define VEC_SIZE 32
432  static int
433  usb_read_linux_mmap(pcap_t *handle, int max_packets, pcap_handler callback, u_char *user)
434  {
435  	struct pcap_usb_linux *handlep = handle->priv;
436  	struct mon_bin_mfetch fetch;
437  	int32_t vec[VEC_SIZE];
438  	struct pcap_pkthdr pkth;
439  	u_char *bp;
440  	pcap_usb_header_mmapped* hdr;
441  	int nflush = 0;
442  	int packets = 0;
443  	u_int clen, max_clen;
444  	max_clen = handle->snapshot - sizeof(pcap_usb_header_mmapped);
445  	for (;;) {
446  		int i, ret;
447  		int limit;
448  		if (PACKET_COUNT_IS_UNLIMITED(max_packets)) {
449  			limit = VEC_SIZE;
450  		} else {
451  			limit = max_packets - packets;
452  			if (limit > VEC_SIZE)
453  				limit = VEC_SIZE;
454  		}
455  		fetch.offvec = vec;
456  		fetch.nfetch = limit;
457  		fetch.nflush = nflush;
458  		do {
459  			ret = ioctl(handle->fd, MON_IOCX_MFETCH, &fetch);
460  			if (handle->break_loop)
461  			{
462  				handle->break_loop = 0;
463  				return -2;
464  			}
465  		} while ((ret == -1) && (errno == EINTR));
466  		if (ret < 0)
467  		{
468  			if (errno == EAGAIN)
469  				return 0;	&bsol;* no data there */
470  			pcap_fmt_errmsg_for_errno(handle->errbuf,
471  			    PCAP_ERRBUF_SIZE, errno, "Can't mfetch fd %d",
472  			    handle->fd);
473  			return -1;
474  		}
475  		nflush = fetch.nfetch;
476  		for (i=0; i<fetch.nfetch; ++i) {
477  			bp = &handlep->mmapbuf[vec[i]];
478  			hdr = (pcap_usb_header_mmapped*) bp;
479  			if (hdr->event_type == '@')
480  				continue;
481  			clen = max_clen;
482  			if (hdr->data_len < clen)
483  				clen = hdr->data_len;
484  			pkth.caplen = sizeof(pcap_usb_header_mmapped) + clen;
485  			if (hdr->data_flag) {
486  				pkth.len = sizeof(pcap_usb_header_mmapped) +
487  				    hdr->data_len;
488  			} else {
489  				pkth.len = sizeof(pcap_usb_header_mmapped) +
490  				    (hdr->ndesc * sizeof (usb_isodesc)) + hdr->urb_len;
491  				fix_linux_usb_mmapped_length(&pkth, bp);
492  			}
493  			pkth.ts.tv_sec = (time_t)hdr->ts_sec;
494  			pkth.ts.tv_usec = hdr->ts_usec;
495  			if (handle->fcode.bf_insns == NULL ||
496  			    pcap_filter(handle->fcode.bf_insns, (u_char*) hdr,
497  			      pkth.len, pkth.caplen)) {
498  				handlep->packets_read++;
499  				callback(user, &pkth, (u_char*) hdr);
500  				packets++;
501  			}
502  		}
503  		if (PACKET_COUNT_IS_UNLIMITED(max_packets) ||
504  		    (packets >= max_packets))
505  			break;
506  	}
507  	if (ioctl(handle->fd, MON_IOCH_MFLUSH, nflush) == -1) {
508  		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
509  		    errno, "Can't mflush fd %d", handle->fd);
510  		return -1;
511  	}
512  	return packets;
513  }
514  static void
515  usb_cleanup_linux_mmap(pcap_t* handle)
516  {
<span onclick='openModal()' class='match'>517  	struct pcap_usb_linux *handlep = handle->priv;
518  	if (handlep->mmapbuf != NULL) {
519  		munmap(handlep->mmapbuf, handlep->mmapbuflen);
</span>520  		handlep->mmapbuf = NULL;
521  	}
522  	pcap_cleanup_live_common(handle);
523  }
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-airpcap.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include "pcap-int.h"
5  #include <airpcap.h>
6  #include "pcap-airpcap.h"
7  #define	AIRPCAP_DEFAULT_USER_BUFFER_SIZE 256000
8  #define	AIRPCAP_DEFAULT_KERNEL_BUFFER_SIZE 1000000
9  static pcap_code_handle_t airpcap_lib;
10  typedef PCHAR (*AirpcapGetLastErrorHandler)(PAirpcapHandle);
11  typedef BOOL (*AirpcapGetDeviceListHandler)(PAirpcapDeviceDescription *, PCHAR);
12  typedef VOID (*AirpcapFreeDeviceListHandler)(PAirpcapDeviceDescription);
13  typedef PAirpcapHandle (*AirpcapOpenHandler)(PCHAR, PCHAR);
14  typedef VOID (*AirpcapCloseHandler)(PAirpcapHandle);
15  typedef BOOL (*AirpcapSetDeviceMacFlagsHandler)(PAirpcapHandle, UINT);
16  typedef BOOL (*AirpcapSetLinkTypeHandler)(PAirpcapHandle, AirpcapLinkType);
17  typedef BOOL (*AirpcapGetLinkTypeHandler)(PAirpcapHandle, PAirpcapLinkType);
18  typedef BOOL (*AirpcapSetKernelBufferHandler)(PAirpcapHandle, UINT);
19  typedef BOOL (*AirpcapSetFilterHandler)(PAirpcapHandle, PVOID, UINT);
20  typedef BOOL (*AirpcapSetMinToCopyHandler)(PAirpcapHandle, UINT);
21  typedef BOOL (*AirpcapGetReadEventHandler)(PAirpcapHandle, HANDLE *);
22  typedef BOOL (*AirpcapReadHandler)(PAirpcapHandle, PBYTE, UINT, PUINT);
23  typedef BOOL (*AirpcapWriteHandler)(PAirpcapHandle, PCHAR, ULONG);
24  typedef BOOL (*AirpcapGetStatsHandler)(PAirpcapHandle, PAirpcapStats);
25  static AirpcapGetLastErrorHandler p_AirpcapGetLastError;
26  static AirpcapGetDeviceListHandler p_AirpcapGetDeviceList;
27  static AirpcapFreeDeviceListHandler p_AirpcapFreeDeviceList;
28  static AirpcapOpenHandler p_AirpcapOpen;
29  static AirpcapCloseHandler p_AirpcapClose;
30  static AirpcapSetDeviceMacFlagsHandler p_AirpcapSetDeviceMacFlags;
31  static AirpcapSetLinkTypeHandler p_AirpcapSetLinkType;
32  static AirpcapGetLinkTypeHandler p_AirpcapGetLinkType;
33  static AirpcapSetKernelBufferHandler p_AirpcapSetKernelBuffer;
34  static AirpcapSetFilterHandler p_AirpcapSetFilter;
35  static AirpcapSetMinToCopyHandler p_AirpcapSetMinToCopy;
36  static AirpcapGetReadEventHandler p_AirpcapGetReadEvent;
37  static AirpcapReadHandler p_AirpcapRead;
38  static AirpcapWriteHandler p_AirpcapWrite;
39  static AirpcapGetStatsHandler p_AirpcapGetStats;
40  typedef enum LONG
41  {
42  	AIRPCAP_API_UNLOADED = 0,
43  	AIRPCAP_API_LOADED,
44  	AIRPCAP_API_CANNOT_LOAD,
45  	AIRPCAP_API_LOADING
46  } AIRPCAP_API_LOAD_STATUS;
47  static AIRPCAP_API_LOAD_STATUS	airpcap_load_status;
48  static AIRPCAP_API_LOAD_STATUS
49  load_airpcap_functions(void)
50  {
51  	AIRPCAP_API_LOAD_STATUS current_status;
52  	current_status = InterlockedCompareExchange((LONG *)&airpcap_load_status,
53  	    AIRPCAP_API_LOADING, AIRPCAP_API_UNLOADED);
54  	while (current_status == AIRPCAP_API_LOADING) {
55  		current_status = InterlockedCompareExchange((LONG*)&airpcap_load_status,
56  		    AIRPCAP_API_LOADING, AIRPCAP_API_LOADING);
57  		Sleep(10);
58  	}
59  	if (current_status == AIRPCAP_API_LOADED)
60  		return AIRPCAP_API_LOADED;
61  	if (current_status == AIRPCAP_API_CANNOT_LOAD)
62  		return AIRPCAP_API_CANNOT_LOAD;
63  	current_status = AIRPCAP_API_CANNOT_LOAD;
64  	airpcap_lib = pcap_load_code("airpcap.dll");
65  	if (airpcap_lib != NULL) {
66  		p_AirpcapGetLastError = (AirpcapGetLastErrorHandler) pcap_find_function(airpcap_lib, "AirpcapGetLastError");
67  		p_AirpcapGetDeviceList = (AirpcapGetDeviceListHandler) pcap_find_function(airpcap_lib, "AirpcapGetDeviceList");
68  		p_AirpcapFreeDeviceList = (AirpcapFreeDeviceListHandler) pcap_find_function(airpcap_lib, "AirpcapFreeDeviceList");
69  		p_AirpcapOpen = (AirpcapOpenHandler) pcap_find_function(airpcap_lib, "AirpcapOpen");
70  		p_AirpcapClose = (AirpcapCloseHandler) pcap_find_function(airpcap_lib, "AirpcapClose");
71  		p_AirpcapSetDeviceMacFlags = (AirpcapSetDeviceMacFlagsHandler) pcap_find_function(airpcap_lib, "AirpcapSetDeviceMacFlags");
72  		p_AirpcapSetLinkType = (AirpcapSetLinkTypeHandler) pcap_find_function(airpcap_lib, "AirpcapSetLinkType");
73  		p_AirpcapGetLinkType = (AirpcapGetLinkTypeHandler) pcap_find_function(airpcap_lib, "AirpcapGetLinkType");
74  		p_AirpcapSetKernelBuffer = (AirpcapSetKernelBufferHandler) pcap_find_function(airpcap_lib, "AirpcapSetKernelBuffer");
75  		p_AirpcapSetFilter = (AirpcapSetFilterHandler) pcap_find_function(airpcap_lib, "AirpcapSetFilter");
76  		p_AirpcapSetMinToCopy = (AirpcapSetMinToCopyHandler) pcap_find_function(airpcap_lib, "AirpcapSetMinToCopy");
77  		p_AirpcapGetReadEvent = (AirpcapGetReadEventHandler) pcap_find_function(airpcap_lib, "AirpcapGetReadEvent");
78  		p_AirpcapRead = (AirpcapReadHandler) pcap_find_function(airpcap_lib, "AirpcapRead");
79  		p_AirpcapWrite = (AirpcapWriteHandler) pcap_find_function(airpcap_lib, "AirpcapWrite");
80  		p_AirpcapGetStats = (AirpcapGetStatsHandler) pcap_find_function(airpcap_lib, "AirpcapGetStats");
81  		if (p_AirpcapGetLastError != NULL &&
82  		    p_AirpcapGetDeviceList != NULL &&
83  		    p_AirpcapFreeDeviceList != NULL &&
84  		    p_AirpcapOpen != NULL &&
85  		    p_AirpcapClose != NULL &&
86  		    p_AirpcapSetDeviceMacFlags != NULL &&
87  		    p_AirpcapSetLinkType != NULL &&
88  		    p_AirpcapGetLinkType != NULL &&
89  		    p_AirpcapSetKernelBuffer != NULL &&
90  		    p_AirpcapSetFilter != NULL &&
91  		    p_AirpcapSetMinToCopy != NULL &&
92  		    p_AirpcapGetReadEvent != NULL &&
93  		    p_AirpcapRead != NULL &&
94  		    p_AirpcapWrite != NULL &&
95  		    p_AirpcapGetStats != NULL) {
96  			current_status = AIRPCAP_API_LOADED;
97  		}
98  	}
99  	if (current_status != AIRPCAP_API_LOADED) {
100  		if (airpcap_lib != NULL) {
101  			FreeLibrary(airpcap_lib);
102  			airpcap_lib = NULL;
103  		}
104  	}
105  	InterlockedExchange((LONG *)&airpcap_load_status, current_status);
106  	return current_status;
107  }
108  struct pcap_airpcap {
109  	PAirpcapHandle adapter;
110  	int filtering_in_kernel;
111  	int nonblock;
112  	int read_timeout;
113  	HANDLE read_event;
114  	struct pcap_stat stat;
115  };
116  static int
117  airpcap_setfilter(pcap_t *p, struct bpf_program *fp)
118  {
119  	struct pcap_airpcap *pa = p->priv;
120  	if (!p_AirpcapSetFilter(pa->adapter, fp->bf_insns,
121  	    fp->bf_len * sizeof(struct bpf_insn))) {
122  		if (pcap_install_bpf_program(p, fp) < 0)
123  			return (-1);
124  		pa->filtering_in_kernel = 0;	&bsol;* filtering in userland */
125  		return (0);
126  	}
127  	pa->filtering_in_kernel = 1;	&bsol;* filtering in the kernel */
128  	p->cc = 0;
129  	return (0);
130  }
131  static int
132  airpcap_set_datalink(pcap_t *p, int dlt)
133  {
134  	struct pcap_airpcap *pa = p->priv;
135  	AirpcapLinkType type;
136  	switch (dlt) {
137  	case DLT_IEEE802_11_RADIO:
138  		type = AIRPCAP_LT_802_11_PLUS_RADIO;
139  		break;
140  	case DLT_PPI:
141  		type = AIRPCAP_LT_802_11_PLUS_PPI;
142  		break;
143  	case DLT_IEEE802_11:
144  		type = AIRPCAP_LT_802_11;
145  		break;
146  	default:
147  		return (0);
148  	}
149  	if (!p_AirpcapSetLinkType(pa->adapter, type)) {
150  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
151  		    "AirpcapSetLinkType() failed: %s",
152  		    p_AirpcapGetLastError(pa->adapter));
153  		return (-1);
154  	}
155  	p->linktype = dlt;
156  	return (0);
157  }
158  static int
159  airpcap_getnonblock(pcap_t *p)
160  {
161  	struct pcap_airpcap *pa = p->priv;
162  	return (pa->nonblock);
163  }
164  static int
165  airpcap_setnonblock(pcap_t *p, int nonblock)
166  {
167  	struct pcap_airpcap *pa = p->priv;
168  	int newtimeout;
169  	if (nonblock) {
170  		newtimeout = -1;
171  	} else {
172  		newtimeout = p->opt.timeout;
173  	}
174  	pa->read_timeout = newtimeout;
175  	pa->nonblock = (newtimeout == -1);
176  	return (0);
177  }
178  static int
179  airpcap_stats(pcap_t *p, struct pcap_stat *ps)
180  {
181  	struct pcap_airpcap *pa = p->priv;
182  	AirpcapStats tas;
183  	if (!p_AirpcapGetStats(pa->adapter, &tas)) {
184  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
185  		    "AirpcapGetStats() failed: %s",
186  		    p_AirpcapGetLastError(pa->adapter));
187  		return (-1);
188  	}
189  	ps->ps_drop = tas.Drops;
190  	ps->ps_recv = tas.Recvs;
191  	ps->ps_ifdrop = tas.IfDrops;
192  	return (0);
193  }
194  static struct pcap_stat *
195  airpcap_stats_ex(pcap_t *p, int *pcap_stat_size)
196  {
197  	struct pcap_airpcap *pa = p->priv;
198  	AirpcapStats tas;
199  	*pcap_stat_size = sizeof (p->stat);
200  	if (!p_AirpcapGetStats(pa->adapter, &tas)) {
201  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
202  		    "AirpcapGetStats() failed: %s",
203  		    p_AirpcapGetLastError(pa->adapter));
204  		return (NULL);
205  	}
206  	p->stat.ps_recv = tas.Recvs;
207  	p->stat.ps_drop = tas.Drops;
208  	p->stat.ps_ifdrop = tas.IfDrops;
209  #ifdef _WIN32
210  	p->stat.ps_capt = tas.Capt;
211  #endif
212  	return (&p->stat);
213  }
214  static int
215  airpcap_setbuff(pcap_t *p, int dim)
216  {
217  	struct pcap_airpcap *pa = p->priv;
218  	if (!p_AirpcapSetKernelBuffer(pa->adapter, dim)) {
219  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
220  		    "AirpcapSetKernelBuffer() failed: %s",
221  		    p_AirpcapGetLastError(pa->adapter));
222  		return (-1);
223  	}
224  	return (0);
225  }
226  static int
227  airpcap_setmode(pcap_t *p, int mode)
228  {
229  	 if (mode != MODE_CAPT) {
230  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
231  		    "Only MODE_CAPT is supported on an AirPcap adapter");
232  		return (-1);
233  	 }
234  	 return (0);
235  }
236  static int
237  airpcap_setmintocopy(pcap_t *p, int size)
238  {
239  	struct pcap_airpcap *pa = p->priv;
240  	if (!p_AirpcapSetMinToCopy(pa->adapter, size)) {
241  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
242  		    "AirpcapSetMinToCopy() failed: %s",
243  		    p_AirpcapGetLastError(pa->adapter));
244  		return (-1);
245  	}
246  	return (0);
247  }
248  static HANDLE
249  airpcap_getevent(pcap_t *p)
250  {
251  	struct pcap_airpcap *pa = p->priv;
252  	return (pa->read_event);
253  }
254  static int
255  airpcap_oid_get_request(pcap_t *p, bpf_u_int32 oid _U_, void *data _U_,
256      size_t *lenp _U_)
257  {
258  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
259  	    "Getting OID values is not supported on an AirPcap adapter");
260  	return (PCAP_ERROR);
261  }
262  static int
263  airpcap_oid_set_request(pcap_t *p, bpf_u_int32 oid _U_, const void *data _U_,
264      size_t *lenp _U_)
265  {
266  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
267  	    "Setting OID values is not supported on an AirPcap adapter");
268  	return (PCAP_ERROR);
269  }
270  static u_int
271  airpcap_sendqueue_transmit(pcap_t *p, pcap_send_queue *queue _U_, int sync _U_)
272  {
273  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
274  	    "Cannot queue packets for transmission on an AirPcap adapter");
275  	return (0);
276  }
277  static int
278  airpcap_setuserbuffer(pcap_t *p, int size)
279  {
280  	unsigned char *new_buff;
281  	if (size <= 0) {
282  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
283  		    "Error: invalid size %d",size);
284  		return (-1);
285  	}
286  	new_buff = (unsigned char *)malloc(sizeof(char)*size);
287  	if (!new_buff) {
288  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
289  		    "Error: not enough memory");
290  		return (-1);
291  	}
292  	free(p->buffer);
293  	p->buffer = new_buff;
294  	p->bufsize = size;
295  	return (0);
296  }
297  static int
298  airpcap_live_dump(pcap_t *p, char *filename _U_, int maxsize _U_,
299      int maxpacks _U_)
300  {
301  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
302  	    "AirPcap adapters don't support live dump");
303  	return (-1);
304  }
305  static int
306  airpcap_live_dump_ended(pcap_t *p, int sync _U_)
307  {
308  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
309  	    "AirPcap adapters don't support live dump");
310  	return (-1);
311  }
312  static PAirpcapHandle
313  airpcap_get_airpcap_handle(pcap_t *p)
314  {
315  	struct pcap_airpcap *pa = p->priv;
316  	return (pa->adapter);
317  }
318  static int
319  airpcap_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
320  {
321  	struct pcap_airpcap *pa = p->priv;
322  	int cc;
323  	int n;
324  	register u_char *bp, *ep;
325  	UINT bytes_read;
326  	u_char *datap;
327  	cc = p->cc;
328  	if (cc == 0) {
329  		if (p->break_loop) {
330  			p->break_loop = 0;
331  			return (PCAP_ERROR_BREAK);
332  		}
333  		if (pa->read_timeout != -1) {
334  			WaitForSingleObject(pa->read_event,
335  			    (pa->read_timeout ==0 )? INFINITE: pa->read_timeout);
336  		}
337  		if (!p_AirpcapRead(pa->adapter, (PBYTE)p->buffer,
338  		    p->bufsize, &bytes_read)) {
339  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
340  			    "AirpcapRead() failed: %s",
341  			    p_AirpcapGetLastError(pa->adapter));
342  			return (-1);
343  		}
344  		cc = bytes_read;
345  		bp = p->buffer;
346  	} else
347  		bp = p->bp;
348  #define bhp ((AirpcapBpfHeader *)bp)
349  	n = 0;
350  	ep = bp + cc;
351  	for (;;) {
352  		register u_int caplen, hdrlen;
353  		if (p->break_loop) {
354  			if (n == 0) {
355  				p->break_loop = 0;
356  				return (PCAP_ERROR_BREAK);
357  			} else {
358  				p->bp = bp;
359  				p->cc = (int) (ep - bp);
360  				return (n);
361  			}
362  		}
363  		if (bp >= ep)
364  			break;
365  		caplen = bhp->Caplen;
366  		hdrlen = bhp->Hdrlen;
367  		datap = bp + hdrlen;
368  		if (pa->filtering_in_kernel ||
369  		    p->fcode.bf_insns == NULL ||
370  		    pcap_filter(p->fcode.bf_insns, datap, bhp->Originallen, caplen)) {
371  			struct pcap_pkthdr pkthdr;
372  			pkthdr.ts.tv_sec = bhp->TsSec;
373  			pkthdr.ts.tv_usec = bhp->TsUsec;
374  			pkthdr.caplen = caplen;
375  			pkthdr.len = bhp->Originallen;
376  			(*callback)(user, &pkthdr, datap);
377  			bp += AIRPCAP_WORDALIGN(caplen + hdrlen);
378  			if (++n >= cnt && !PACKET_COUNT_IS_UNLIMITED(cnt)) {
379  				p->bp = bp;
380  				p->cc = (int)(ep - bp);
381  				return (n);
382  			}
383  		} else {
384  			bp += AIRPCAP_WORDALIGN(caplen + hdrlen);
385  		}
386  	}
387  #undef bhp
388  	p->cc = 0;
389  	return (n);
390  }
391  static int
392  airpcap_inject(pcap_t *p, const void *buf, int size)
393  {
394  	struct pcap_airpcap *pa = p->priv;
395  	if (!p_AirpcapWrite(pa->adapter, (void *)buf, size)) {
396  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
397  		    "AirpcapWrite() failed: %s",
398  		    p_AirpcapGetLastError(pa->adapter));
399  		return (-1);
400  	}
401  	return (size);
402  }
403  static void
404  airpcap_cleanup(pcap_t *p)
405  {
<span onclick='openModal()' class='match'>406  	struct pcap_airpcap *pa = p->priv;
407  	if (pa->adapter != NULL) {
408  		p_AirpcapClose(pa->adapter);
</span>409  		pa->adapter = NULL;
410  	}
411  	pcap_cleanup_live_common(p);
412  }
413  static void
414  airpcap_breakloop(pcap_t *p)
415  {
416  	HANDLE read_event;
417  	pcap_breakloop_common(p);
418  	struct pcap_airpcap *pa = p->priv;
419  	if (!p_AirpcapGetReadEvent(pa->adapter, &read_event))
420  		return;
421  	SetEvent(read_event);
422  }
423  static int
424  airpcap_activate(pcap_t *p)
425  {
426  	struct pcap_airpcap *pa = p->priv;
427  	char *device = p->opt.device;
428  	char airpcap_errbuf[AIRPCAP_ERRBUF_SIZE];
429  	BOOL status;
430  	AirpcapLinkType link_type;
431  	pa->adapter = p_AirpcapOpen(device, airpcap_errbuf);
432  	if (pa->adapter == NULL) {
433  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "%s", airpcap_errbuf);
434  		return (PCAP_ERROR);
435  	}
436  	if (p->opt.rfmon) {
437  		status = p_AirpcapSetDeviceMacFlags(pa->adapter,
438  		    AIRPCAP_MF_MONITOR_MODE_ON);
439  	} else
440  		status = p_AirpcapSetDeviceMacFlags(pa->adapter,
441  		    AIRPCAP_MF_ACK_FRAMES_ON);
442  	if (!status) {
443  		p_AirpcapClose(pa->adapter);
444  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
445  		    "AirpcapSetDeviceMacFlags() failed: %s",
446  		    p_AirpcapGetLastError(pa->adapter));
447  		return (PCAP_ERROR);
448  	}
449  	if (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)
450  		p->snapshot = MAXIMUM_SNAPLEN;
451  	if (p->opt.buffer_size == 0)
452  		p->opt.buffer_size = AIRPCAP_DEFAULT_KERNEL_BUFFER_SIZE;
453  	if (!p_AirpcapSetKernelBuffer(pa->adapter, p->opt.buffer_size)) {
454  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
455  		    "AirpcapSetKernelBuffer() failed: %s",
456  		    p_AirpcapGetLastError(pa->adapter));
457  		goto bad;
458  	}
459  	if(!p_AirpcapGetReadEvent(pa->adapter, &pa->read_event)) {
460  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
461  		    "AirpcapGetReadEvent() failed: %s",
462  		    p_AirpcapGetLastError(pa->adapter));
463  		goto bad;
464  	}
465  	p->bufsize = AIRPCAP_DEFAULT_USER_BUFFER_SIZE;
466  	p->buffer = malloc(p->bufsize);
467  	if (p->buffer == NULL) {
468  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
469  		    errno, "malloc");
470  		goto bad;
471  	}
472  	if (p->opt.immediate) {
473  		if (!p_AirpcapSetMinToCopy(pa->adapter, 0)) {
474  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
475  			    "AirpcapSetMinToCopy() failed: %s",
476  			    p_AirpcapGetLastError(pa->adapter));
477  			goto bad;
478  		}
479  	} else {
480  		if (!p_AirpcapSetMinToCopy(pa->adapter, 16000)) {
481  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
482  			    "AirpcapSetMinToCopy() failed: %s",
483  			    p_AirpcapGetLastError(pa->adapter));
484  			goto bad;
485  		}
486  	}
487  	if (!p_AirpcapGetLinkType(pa->adapter, &link_type)) {
488  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
489  		    "AirpcapGetLinkType() failed: %s",
490  		    p_AirpcapGetLastError(pa->adapter));
491  		goto bad;
492  	}
493  	switch (link_type) {
494  	case AIRPCAP_LT_802_11_PLUS_RADIO:
495  		p->linktype = DLT_IEEE802_11_RADIO;
496  		break;
497  	case AIRPCAP_LT_802_11_PLUS_PPI:
498  		p->linktype = DLT_PPI;
499  		break;
500  	case AIRPCAP_LT_802_11:
501  		p->linktype = DLT_IEEE802_11;
502  		break;
503  	case AIRPCAP_LT_UNKNOWN:
504  	default:
505  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
506  		    "AirpcapGetLinkType() returned unknown link type %u",
507  		    link_type);
508  		goto bad;
509  	}
510  	p->dlt_list = (u_int *) malloc(sizeof(u_int) * 3);
511  	if (p->dlt_list == NULL) {
512  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
513  		    errno, "malloc");
514  		goto bad;
515  	}
516  	p->dlt_list[0] = DLT_IEEE802_11_RADIO;
517  	p->dlt_list[1] = DLT_PPI;
518  	p->dlt_list[2] = DLT_IEEE802_11;
519  	p->dlt_count = 3;
520  	p->read_op = airpcap_read;
521  	p->inject_op = airpcap_inject;
522  	p->setfilter_op = airpcap_setfilter;
523  	p->setdirection_op = NULL;	&bsol;* Not implemented. */
524  	p->set_datalink_op = airpcap_set_datalink;
525  	p->getnonblock_op = airpcap_getnonblock;
526  	p->setnonblock_op = airpcap_setnonblock;
527  	p->breakloop_op = airpcap_breakloop;
528  	p->stats_op = airpcap_stats;
529  	p->stats_ex_op = airpcap_stats_ex;
530  	p->setbuff_op = airpcap_setbuff;
531  	p->setmode_op = airpcap_setmode;
532  	p->setmintocopy_op = airpcap_setmintocopy;
533  	p->getevent_op = airpcap_getevent;
534  	p->oid_get_request_op = airpcap_oid_get_request;
535  	p->oid_set_request_op = airpcap_oid_set_request;
536  	p->sendqueue_transmit_op = airpcap_sendqueue_transmit;
537  	p->setuserbuffer_op = airpcap_setuserbuffer;
538  	p->live_dump_op = airpcap_live_dump;
539  	p->live_dump_ended_op = airpcap_live_dump_ended;
540  	p->get_airpcap_handle_op = airpcap_get_airpcap_handle;
541  	p->cleanup_op = airpcap_cleanup;
542  	return (0);
543   bad:
544  	airpcap_cleanup(p);
545  	return (PCAP_ERROR);
546  }
547  static int
548  airpcap_can_set_rfmon(pcap_t *p)
549  {
550  	return (1);
551  }
552  int
553  device_is_airpcap(const char *device, char *ebuf)
554  {
555  	static const char airpcap_prefix[] = "\\\\.\\airpcap";
556  	if (strncmp(device, airpcap_prefix, sizeof airpcap_prefix - 1) == 0) {
557  		return (1);
558  	}
559  	return (0);
560  }
561  pcap_t *
562  airpcap_create(const char *device, char *ebuf, int *is_ours)
563  {
564  	int ret;
565  	pcap_t *p;
566  	if (load_airpcap_functions() != AIRPCAP_API_LOADED) {
567  		*is_ours = 0;
568  		return (NULL);
569  	}
570  	ret = device_is_airpcap(device, ebuf);
571  	if (ret == 0) {
572  		*is_ours = 0;
573  		return (NULL);
574  	}
575  	*is_ours = 1;
576  	p = PCAP_CREATE_COMMON(ebuf, struct pcap_airpcap);
577  	if (p == NULL)
578  		return (NULL);
579  	p->activate_op = airpcap_activate;
580  	p->can_set_rfmon_op = airpcap_can_set_rfmon;
581  	return (p);
582  }
583  int
584  airpcap_findalldevs(pcap_if_list_t *devlistp, char *errbuf)
585  {
586  	AirpcapDeviceDescription *airpcap_devices, *airpcap_device;
587  	char airpcap_errbuf[AIRPCAP_ERRBUF_SIZE];
588  	if (load_airpcap_functions() != AIRPCAP_API_LOADED) {
589  		return (0);
590  	}
591  	if (!p_AirpcapGetDeviceList(&airpcap_devices, airpcap_errbuf)) {
592  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
593  		    "AirpcapGetDeviceList() failed: %s", airpcap_errbuf);
594  		return (-1);
595  	}
596  	for (airpcap_device = airpcap_devices; airpcap_device != NULL;
597  	    airpcap_device = airpcap_device->next) {
598  		if (pcap_add_dev(devlistp, airpcap_device->Name, 0,
599  		    airpcap_device->Description, errbuf) == NULL) {
600  			p_AirpcapFreeDeviceList(airpcap_devices);
601  			return (-1);
602  		}
603  	}
604  	p_AirpcapFreeDeviceList(airpcap_devices);
605  	return (0);
606  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-usb-linux.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-airpcap.c</div>
                </div>
                <div class="column column_space"><pre><code>517  	struct pcap_usb_linux *handlep = handle->priv;
518  	if (handlep->mmapbuf != NULL) {
519  		munmap(handlep->mmapbuf, handlep->mmapbuflen);
</pre></code></div>
                <div class="column column_space"><pre><code>406  	struct pcap_airpcap *pa = p->priv;
407  	if (pa->adapter != NULL) {
408  		p_AirpcapClose(pa->adapter);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    