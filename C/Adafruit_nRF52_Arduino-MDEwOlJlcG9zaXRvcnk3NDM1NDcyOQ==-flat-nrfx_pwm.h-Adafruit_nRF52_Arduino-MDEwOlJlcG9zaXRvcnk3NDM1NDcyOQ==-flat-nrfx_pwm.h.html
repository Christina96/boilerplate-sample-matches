
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_pwm.h</h3>
            <pre><code>1  #ifndef NRFX_PWM_H__
2  #define NRFX_PWM_H__
3  #include <nrfx.h>
4  #include <hal/nrf_pwm.h>
5  #ifdef __cplusplus
6  extern "C" {
7  #endif
8  typedef struct
9  {
10      NRF_PWM_Type * p_registers;  
11      uint8_t        drv_inst_idx; 
12  } nrfx_pwm_t;
13  #define NRFX_PWM_INSTANCE(id)                               \
14  {                                                           \
15      .p_registers  = NRFX_CONCAT_2(NRF_PWM, id),             \
16      .drv_inst_idx = NRFX_CONCAT_3(NRFX_PWM, id, _INST_IDX), \
17  }
18  #ifndef __NRFX_DOXYGEN__
19  enum {
20  #if NRFX_CHECK(NRFX_PWM0_ENABLED)
21      NRFX_PWM0_INST_IDX,
22  #endif
23  #if NRFX_CHECK(NRFX_PWM1_ENABLED)
24      NRFX_PWM1_INST_IDX,
25  #endif
26  #if NRFX_CHECK(NRFX_PWM2_ENABLED)
27      NRFX_PWM2_INST_IDX,
28  #endif
29  #if NRFX_CHECK(NRFX_PWM3_ENABLED)
30      NRFX_PWM3_INST_IDX,
31  #endif
32      NRFX_PWM_ENABLED_COUNT
33  };
34  #endif
35  #define NRFX_PWM_PIN_NOT_USED    0xFF
36  #define NRFX_PWM_PIN_INVERTED    0x80
37  typedef struct
38  {
39      uint8_t output_pins[NRF_PWM_CHANNEL_COUNT]; 
40      uint8_t            irq_priority; 
41      nrf_pwm_clk_t      base_clock;   
42      nrf_pwm_mode_t     count_mode;   
43      uint16_t           top_value;    
44      nrf_pwm_dec_load_t load_mode;    
45      nrf_pwm_dec_step_t step_mode;    
46      bool               skip_gpio_cfg; 
47  } nrfx_pwm_config_t;
48  #define NRFX_PWM_DEFAULT_CONFIG(_out_0, _out_1, _out_2, _out_3) \
49  {                                                               \
50      .output_pins   = { _out_0,                                  \
51                         _out_1,                                  \
52                         _out_2,                                  \
53                         _out_3                                   \
54                       },                                         \
55      .irq_priority  = NRFX_PWM_DEFAULT_CONFIG_IRQ_PRIORITY,      \
56      .base_clock    = NRF_PWM_CLK_1MHz,                          \
57      .count_mode    = NRF_PWM_MODE_UP,                           \
58      .top_value     = 1000,                                      \
59      .load_mode     = NRF_PWM_LOAD_COMMON,                       \
60      .step_mode     = NRF_PWM_STEP_AUTO,                         \
61      .skip_gpio_cfg = false                                      \
62  }
63  typedef enum
64  {
65      NRFX_PWM_FLAG_STOP = 0x01, &bsol;**< When the requested playback is finished,
66                                      the peripheral will be stopped.
67                                      @note The STOP task is triggered when
68                                      the last value of the final sequence is
69                                      loaded from RAM, and the peripheral stops
70                                      at the end of the current PWM period.
71                                      For sequences with configured repeating
72                                      of duty cycle values, this might result in
73                                      less than the requested number of repeats
74                                      of the last value. */
75      NRFX_PWM_FLAG_LOOP = 0x02, &bsol;**< When the requested playback is finished,
76                                      it will be started from the beginning.
77                                      This flag is ignored if used together
78                                      with @ref NRFX_PWM_FLAG_STOP.
79                                      @note The playback restart is done via a
80                                      shortcut configured in the PWM peripheral.
81                                      This shortcut triggers the proper starting
82                                      task when the final value of previous
83                                      playback is read from RAM and applied to
84                                      the pulse generator counter.
85                                      When this mechanism is used together with
86                                      the @ref NRF_PWM_STEP_TRIGGERED mode,
87                                      the playback restart will occur right
88                                      after switching to the final value (this
89                                      final value will be played only once). */
90      NRFX_PWM_FLAG_SIGNAL_END_SEQ0 = 0x04, &bsol;**< The event handler is to be
91                                                 called when the last value
92                                                 from sequence 0 is loaded. */
93      NRFX_PWM_FLAG_SIGNAL_END_SEQ1 = 0x08, &bsol;**< The event handler is to be
94                                                 called when the last value
95                                                 from sequence 1 is loaded. */
96      NRFX_PWM_FLAG_NO_EVT_FINISHED = 0x10, &bsol;**< The playback finished event
97                                                 (enabled by default) is to be
98                                                 suppressed. */
99      NRFX_PWM_FLAG_START_VIA_TASK = 0x80, &bsol;**< The playback must not be
100                                                started directly by the called
101                                                function. Instead, the function
102                                                must only prepare it and
103                                                return the address of the task
104                                                to be triggered to start the
105                                                playback. */
106  } nrfx_pwm_flag_t;
107  typedef enum
108  {
109      NRFX_PWM_EVT_FINISHED, 
110      NRFX_PWM_EVT_END_SEQ0, &bsol;**< End of sequence 0 reached. Its data can be
111                                  safely modified now. */
112      NRFX_PWM_EVT_END_SEQ1, &bsol;**< End of sequence 1 reached. Its data can be
113                                  safely modified now. */
114      NRFX_PWM_EVT_STOPPED,  
115  } nrfx_pwm_evt_type_t;
116  typedef void (* nrfx_pwm_handler_t)(nrfx_pwm_evt_type_t event_type, void * p_context);
117  nrfx_err_t nrfx_pwm_init(nrfx_pwm_t const *        p_instance,
118                           nrfx_pwm_config_t const * p_config,
119                           nrfx_pwm_handler_t        handler,
120                           void *                    p_context);
121  void nrfx_pwm_uninit(nrfx_pwm_t const * p_instance);
122  uint32_t nrfx_pwm_simple_playback(nrfx_pwm_t const *         p_instance,
123                                    nrf_pwm_sequence_t const * p_sequence,
124                                    uint16_t                   playback_count,
125                                    uint32_t                   flags);
126  uint32_t nrfx_pwm_complex_playback(nrfx_pwm_t const *         p_instance,
127                                     nrf_pwm_sequence_t const * p_sequence_0,
128                                     nrf_pwm_sequence_t const * p_sequence_1,
129                                     uint16_t                   playback_count,
130                                     uint32_t                   flags);
131  NRFX_STATIC_INLINE void nrfx_pwm_step(nrfx_pwm_t const * p_instance);
132  bool nrfx_pwm_stop(nrfx_pwm_t const * p_instance, bool wait_until_stopped);
133  bool nrfx_pwm_is_stopped(nrfx_pwm_t const * p_instance);
134  NRFX_STATIC_INLINE void nrfx_pwm_sequence_update(nrfx_pwm_t const *         p_instance,
135                                                   uint8_t                    seq_id,
136                                                   nrf_pwm_sequence_t const * p_sequence);
137  NRFX_STATIC_INLINE void nrfx_pwm_sequence_values_update(nrfx_pwm_t const * p_instance,
138                                                          uint8_t            seq_id,
<span onclick='openModal()' class='match'>139                                                          nrf_pwm_values_t   values);
140  NRFX_STATIC_INLINE void nrfx_pwm_sequence_length_update(nrfx_pwm_t const * p_instance,
141                                                          uint8_t            seq_id,
142                                                          uint16_t           length);
143  NRFX_STATIC_INLINE void nrfx_pwm_sequence_repeats_update(nrfx_pwm_t const * p_instance,
</span>144                                                           uint8_t            seq_id,
145                                                           uint32_t           repeats);
146  NRFX_STATIC_INLINE void nrfx_pwm_sequence_end_delay_update(nrfx_pwm_t const * p_instance,
147                                                             uint8_t            seq_id,
148                                                             uint32_t           end_delay);
149  NRFX_STATIC_INLINE uint32_t nrfx_pwm_task_address_get(nrfx_pwm_t const * p_instance,
150                                                        nrf_pwm_task_t     task);
151  NRFX_STATIC_INLINE uint32_t nrfx_pwm_event_address_get(nrfx_pwm_t const * p_instance,
152                                                         nrf_pwm_event_t    event);
153  #ifndef NRFX_DECLARE_ONLY
154  NRFX_STATIC_INLINE void nrfx_pwm_step(nrfx_pwm_t const * p_instance)
155  {
156      nrf_pwm_task_trigger(p_instance->p_registers, NRF_PWM_TASK_NEXTSTEP);
157  }
158  NRFX_STATIC_INLINE void nrfx_pwm_sequence_update(nrfx_pwm_t const *         p_instance,
159                                                   uint8_t                    seq_id,
160                                                   nrf_pwm_sequence_t const * p_sequence)
161  {
162      nrf_pwm_sequence_set(p_instance->p_registers, seq_id, p_sequence);
163  }
164  NRFX_STATIC_INLINE void nrfx_pwm_sequence_values_update(nrfx_pwm_t const * p_instance,
165                                                          uint8_t            seq_id,
166                                                          nrf_pwm_values_t   values)
167  {
168      nrf_pwm_seq_ptr_set(p_instance->p_registers, seq_id, values.p_raw);
169  }
170  NRFX_STATIC_INLINE void nrfx_pwm_sequence_length_update(nrfx_pwm_t const * p_instance,
171                                                          uint8_t            seq_id,
172                                                          uint16_t           length)
173  {
174      nrf_pwm_seq_cnt_set(p_instance->p_registers, seq_id, length);
175  }
176  NRFX_STATIC_INLINE void nrfx_pwm_sequence_repeats_update(nrfx_pwm_t const * p_instance,
177                                                           uint8_t            seq_id,
178                                                           uint32_t           repeats)
179  {
180      nrf_pwm_seq_refresh_set(p_instance->p_registers, seq_id, repeats);
181  }
182  NRFX_STATIC_INLINE void nrfx_pwm_sequence_end_delay_update(nrfx_pwm_t const * p_instance,
183                                                             uint8_t            seq_id,
184                                                             uint32_t           end_delay)
185  {
186      nrf_pwm_seq_end_delay_set(p_instance->p_registers, seq_id, end_delay);
187  }
188  NRFX_STATIC_INLINE uint32_t nrfx_pwm_task_address_get(nrfx_pwm_t const * p_instance,
189                                                        nrf_pwm_task_t     task)
190  {
191      return nrf_pwm_task_address_get(p_instance->p_registers, task);
192  }
193  NRFX_STATIC_INLINE uint32_t nrfx_pwm_event_address_get(nrfx_pwm_t const * p_instance,
194                                                         nrf_pwm_event_t    event)
195  {
196      return nrf_pwm_event_address_get(p_instance->p_registers, event);
197  }
198  #endif 
199  void nrfx_pwm_0_irq_handler(void);
200  void nrfx_pwm_1_irq_handler(void);
201  void nrfx_pwm_2_irq_handler(void);
202  void nrfx_pwm_3_irq_handler(void);
203  #ifdef __cplusplus
204  }
205  #endif
206  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_pwm.h</h3>
            <pre><code>1  #ifndef NRFX_PWM_H__
2  #define NRFX_PWM_H__
3  #include <nrfx.h>
4  #include <hal/nrf_pwm.h>
5  #ifdef __cplusplus
6  extern "C" {
7  #endif
8  typedef struct
9  {
10      NRF_PWM_Type * p_registers;  
11      uint8_t        drv_inst_idx; 
12  } nrfx_pwm_t;
13  #define NRFX_PWM_INSTANCE(id)                               \
14  {                                                           \
15      .p_registers  = NRFX_CONCAT_2(NRF_PWM, id),             \
16      .drv_inst_idx = NRFX_CONCAT_3(NRFX_PWM, id, _INST_IDX), \
17  }
18  #ifndef __NRFX_DOXYGEN__
19  enum {
20  #if NRFX_CHECK(NRFX_PWM0_ENABLED)
21      NRFX_PWM0_INST_IDX,
22  #endif
23  #if NRFX_CHECK(NRFX_PWM1_ENABLED)
24      NRFX_PWM1_INST_IDX,
25  #endif
26  #if NRFX_CHECK(NRFX_PWM2_ENABLED)
27      NRFX_PWM2_INST_IDX,
28  #endif
29  #if NRFX_CHECK(NRFX_PWM3_ENABLED)
30      NRFX_PWM3_INST_IDX,
31  #endif
32      NRFX_PWM_ENABLED_COUNT
33  };
34  #endif
35  #define NRFX_PWM_PIN_NOT_USED    0xFF
36  #define NRFX_PWM_PIN_INVERTED    0x80
37  typedef struct
38  {
39      uint8_t output_pins[NRF_PWM_CHANNEL_COUNT]; 
40      uint8_t            irq_priority; 
41      nrf_pwm_clk_t      base_clock;   
42      nrf_pwm_mode_t     count_mode;   
43      uint16_t           top_value;    
44      nrf_pwm_dec_load_t load_mode;    
45      nrf_pwm_dec_step_t step_mode;    
46      bool               skip_gpio_cfg; 
47  } nrfx_pwm_config_t;
48  #define NRFX_PWM_DEFAULT_CONFIG(_out_0, _out_1, _out_2, _out_3) \
49  {                                                               \
50      .output_pins   = { _out_0,                                  \
51                         _out_1,                                  \
52                         _out_2,                                  \
53                         _out_3                                   \
54                       },                                         \
55      .irq_priority  = NRFX_PWM_DEFAULT_CONFIG_IRQ_PRIORITY,      \
56      .base_clock    = NRF_PWM_CLK_1MHz,                          \
57      .count_mode    = NRF_PWM_MODE_UP,                           \
58      .top_value     = 1000,                                      \
59      .load_mode     = NRF_PWM_LOAD_COMMON,                       \
60      .step_mode     = NRF_PWM_STEP_AUTO,                         \
61      .skip_gpio_cfg = false                                      \
62  }
63  typedef enum
64  {
65      NRFX_PWM_FLAG_STOP = 0x01, &bsol;**< When the requested playback is finished,
66                                      the peripheral will be stopped.
67                                      @note The STOP task is triggered when
68                                      the last value of the final sequence is
69                                      loaded from RAM, and the peripheral stops
70                                      at the end of the current PWM period.
71                                      For sequences with configured repeating
72                                      of duty cycle values, this might result in
73                                      less than the requested number of repeats
74                                      of the last value. */
75      NRFX_PWM_FLAG_LOOP = 0x02, &bsol;**< When the requested playback is finished,
76                                      it will be started from the beginning.
77                                      This flag is ignored if used together
78                                      with @ref NRFX_PWM_FLAG_STOP.
79                                      @note The playback restart is done via a
80                                      shortcut configured in the PWM peripheral.
81                                      This shortcut triggers the proper starting
82                                      task when the final value of previous
83                                      playback is read from RAM and applied to
84                                      the pulse generator counter.
85                                      When this mechanism is used together with
86                                      the @ref NRF_PWM_STEP_TRIGGERED mode,
87                                      the playback restart will occur right
88                                      after switching to the final value (this
89                                      final value will be played only once). */
90      NRFX_PWM_FLAG_SIGNAL_END_SEQ0 = 0x04, &bsol;**< The event handler is to be
91                                                 called when the last value
92                                                 from sequence 0 is loaded. */
93      NRFX_PWM_FLAG_SIGNAL_END_SEQ1 = 0x08, &bsol;**< The event handler is to be
94                                                 called when the last value
95                                                 from sequence 1 is loaded. */
96      NRFX_PWM_FLAG_NO_EVT_FINISHED = 0x10, &bsol;**< The playback finished event
97                                                 (enabled by default) is to be
98                                                 suppressed. */
99      NRFX_PWM_FLAG_START_VIA_TASK = 0x80, &bsol;**< The playback must not be
100                                                started directly by the called
101                                                function. Instead, the function
102                                                must only prepare it and
103                                                return the address of the task
104                                                to be triggered to start the
105                                                playback. */
106  } nrfx_pwm_flag_t;
107  typedef enum
108  {
109      NRFX_PWM_EVT_FINISHED, 
110      NRFX_PWM_EVT_END_SEQ0, &bsol;**< End of sequence 0 reached. Its data can be
111                                  safely modified now. */
112      NRFX_PWM_EVT_END_SEQ1, &bsol;**< End of sequence 1 reached. Its data can be
113                                  safely modified now. */
114      NRFX_PWM_EVT_STOPPED,  
115  } nrfx_pwm_evt_type_t;
116  typedef void (* nrfx_pwm_handler_t)(nrfx_pwm_evt_type_t event_type, void * p_context);
117  nrfx_err_t nrfx_pwm_init(nrfx_pwm_t const *        p_instance,
118                           nrfx_pwm_config_t const * p_config,
119                           nrfx_pwm_handler_t        handler,
120                           void *                    p_context);
121  void nrfx_pwm_uninit(nrfx_pwm_t const * p_instance);
122  uint32_t nrfx_pwm_simple_playback(nrfx_pwm_t const *         p_instance,
123                                    nrf_pwm_sequence_t const * p_sequence,
124                                    uint16_t                   playback_count,
125                                    uint32_t                   flags);
126  uint32_t nrfx_pwm_complex_playback(nrfx_pwm_t const *         p_instance,
127                                     nrf_pwm_sequence_t const * p_sequence_0,
128                                     nrf_pwm_sequence_t const * p_sequence_1,
129                                     uint16_t                   playback_count,
130                                     uint32_t                   flags);
131  NRFX_STATIC_INLINE void nrfx_pwm_step(nrfx_pwm_t const * p_instance);
132  bool nrfx_pwm_stop(nrfx_pwm_t const * p_instance, bool wait_until_stopped);
133  bool nrfx_pwm_is_stopped(nrfx_pwm_t const * p_instance);
134  NRFX_STATIC_INLINE void nrfx_pwm_sequence_update(nrfx_pwm_t const *         p_instance,
135                                                   uint8_t                    seq_id,
136                                                   nrf_pwm_sequence_t const * p_sequence);
137  NRFX_STATIC_INLINE void nrfx_pwm_sequence_values_update(nrfx_pwm_t const * p_instance,
138                                                          uint8_t            seq_id,
139                                                          nrf_pwm_values_t   values);
140  NRFX_STATIC_INLINE void nrfx_pwm_sequence_length_update(nrfx_pwm_t const * p_instance,
141                                                          uint8_t            seq_id,
142                                                          uint16_t           length);
143  NRFX_STATIC_INLINE void nrfx_pwm_sequence_repeats_update(nrfx_pwm_t const * p_instance,
144                                                           uint8_t            seq_id,
<span onclick='openModal()' class='match'>145                                                           uint32_t           repeats);
146  NRFX_STATIC_INLINE void nrfx_pwm_sequence_end_delay_update(nrfx_pwm_t const * p_instance,
147                                                             uint8_t            seq_id,
148                                                             uint32_t           end_delay);
149  NRFX_STATIC_INLINE uint32_t nrfx_pwm_task_address_get(nrfx_pwm_t const * p_instance,
</span>150                                                        nrf_pwm_task_t     task);
151  NRFX_STATIC_INLINE uint32_t nrfx_pwm_event_address_get(nrfx_pwm_t const * p_instance,
152                                                         nrf_pwm_event_t    event);
153  #ifndef NRFX_DECLARE_ONLY
154  NRFX_STATIC_INLINE void nrfx_pwm_step(nrfx_pwm_t const * p_instance)
155  {
156      nrf_pwm_task_trigger(p_instance->p_registers, NRF_PWM_TASK_NEXTSTEP);
157  }
158  NRFX_STATIC_INLINE void nrfx_pwm_sequence_update(nrfx_pwm_t const *         p_instance,
159                                                   uint8_t                    seq_id,
160                                                   nrf_pwm_sequence_t const * p_sequence)
161  {
162      nrf_pwm_sequence_set(p_instance->p_registers, seq_id, p_sequence);
163  }
164  NRFX_STATIC_INLINE void nrfx_pwm_sequence_values_update(nrfx_pwm_t const * p_instance,
165                                                          uint8_t            seq_id,
166                                                          nrf_pwm_values_t   values)
167  {
168      nrf_pwm_seq_ptr_set(p_instance->p_registers, seq_id, values.p_raw);
169  }
170  NRFX_STATIC_INLINE void nrfx_pwm_sequence_length_update(nrfx_pwm_t const * p_instance,
171                                                          uint8_t            seq_id,
172                                                          uint16_t           length)
173  {
174      nrf_pwm_seq_cnt_set(p_instance->p_registers, seq_id, length);
175  }
176  NRFX_STATIC_INLINE void nrfx_pwm_sequence_repeats_update(nrfx_pwm_t const * p_instance,
177                                                           uint8_t            seq_id,
178                                                           uint32_t           repeats)
179  {
180      nrf_pwm_seq_refresh_set(p_instance->p_registers, seq_id, repeats);
181  }
182  NRFX_STATIC_INLINE void nrfx_pwm_sequence_end_delay_update(nrfx_pwm_t const * p_instance,
183                                                             uint8_t            seq_id,
184                                                             uint32_t           end_delay)
185  {
186      nrf_pwm_seq_end_delay_set(p_instance->p_registers, seq_id, end_delay);
187  }
188  NRFX_STATIC_INLINE uint32_t nrfx_pwm_task_address_get(nrfx_pwm_t const * p_instance,
189                                                        nrf_pwm_task_t     task)
190  {
191      return nrf_pwm_task_address_get(p_instance->p_registers, task);
192  }
193  NRFX_STATIC_INLINE uint32_t nrfx_pwm_event_address_get(nrfx_pwm_t const * p_instance,
194                                                         nrf_pwm_event_t    event)
195  {
196      return nrf_pwm_event_address_get(p_instance->p_registers, event);
197  }
198  #endif 
199  void nrfx_pwm_0_irq_handler(void);
200  void nrfx_pwm_1_irq_handler(void);
201  void nrfx_pwm_2_irq_handler(void);
202  void nrfx_pwm_3_irq_handler(void);
203  #ifdef __cplusplus
204  }
205  #endif
206  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_pwm.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_pwm.h</div>
                </div>
                <div class="column column_space"><pre><code>139                                                          nrf_pwm_values_t   values);
140  NRFX_STATIC_INLINE void nrfx_pwm_sequence_length_update(nrfx_pwm_t const * p_instance,
141                                                          uint8_t            seq_id,
142                                                          uint16_t           length);
143  NRFX_STATIC_INLINE void nrfx_pwm_sequence_repeats_update(nrfx_pwm_t const * p_instance,
</pre></code></div>
                <div class="column column_space"><pre><code>145                                                           uint32_t           repeats);
146  NRFX_STATIC_INLINE void nrfx_pwm_sequence_end_delay_update(nrfx_pwm_t const * p_instance,
147                                                             uint8_t            seq_id,
148                                                             uint32_t           end_delay);
149  NRFX_STATIC_INLINE uint32_t nrfx_pwm_task_address_get(nrfx_pwm_t const * p_instance,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    