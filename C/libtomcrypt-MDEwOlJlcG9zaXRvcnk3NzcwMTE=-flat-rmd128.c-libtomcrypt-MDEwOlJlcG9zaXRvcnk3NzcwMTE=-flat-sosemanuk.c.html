
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 10.982658959537572%, Tokens: 9</h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rmd128.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_RIPEMD128
3  const struct ltc_hash_descriptor rmd128_desc =
4  {
5      "rmd128",
6      8,
7      16,
8      64,
9     { 1, 0, 10118, 3, 0, 50 },
10     6,
11      &rmd128_init,
12      &rmd128_process,
13      &rmd128_done,
14      &rmd128_test,
15      NULL
16  };
17  #define F(x, y, z)        ((x) ^ (y) ^ (z))
18  #define G(x, y, z)        (((x) & (y)) | (~(x) & (z)))
19  #define H(x, y, z)        (((x) | ~(y)) ^ (z))
20  #define I(x, y, z)        (((x) & (z)) | ((y) & ~(z)))
21  #define FF(a, b, c, d, x, s)        \
22        (a) += F((b), (c), (d)) + (x);\
23        (a) = ROLc((a), (s));
24  #define GG(a, b, c, d, x, s)        \
25        (a) += G((b), (c), (d)) + (x) + 0x5a827999UL;\
26        (a) = ROLc((a), (s));
27  #define HH(a, b, c, d, x, s)        \
28        (a) += H((b), (c), (d)) + (x) + 0x6ed9eba1UL;\
29        (a) = ROLc((a), (s));
30  #define II(a, b, c, d, x, s)        \
31        (a) += I((b), (c), (d)) + (x) + 0x8f1bbcdcUL;\
32        (a) = ROLc((a), (s));
33  #define FFF(a, b, c, d, x, s)        \
34        (a) += F((b), (c), (d)) + (x);\
35        (a) = ROLc((a), (s));
36  #define GGG(a, b, c, d, x, s)        \
37        (a) += G((b), (c), (d)) + (x) + 0x6d703ef3UL;\
38        (a) = ROLc((a), (s));
39  #define HHH(a, b, c, d, x, s)        \
40        (a) += H((b), (c), (d)) + (x) + 0x5c4dd124UL;\
41        (a) = ROLc((a), (s));
42  #define III(a, b, c, d, x, s)        \
43        (a) += I((b), (c), (d)) + (x) + 0x50a28be6UL;\
44        (a) = ROLc((a), (s));
45  #ifdef LTC_CLEAN_STACK
46  static int ss_rmd128_compress(hash_state *md, const unsigned char *buf)
47  #else
48  static int  s_rmd128_compress(hash_state *md, const unsigned char *buf)
49  #endif
50  {
51     ulong32 aa,bb,cc,dd,aaa,bbb,ccc,ddd,X[16];
52     int i;
53     for (i = 0; i < 16; i++){
54        LOAD32L(X[i], buf + (4 * i));
55     }
<span onclick='openModal()' class='match'>56     aa = aaa = md->rmd128.state[0];
57     bb = bbb = md->rmd128.state[1];
58     cc = ccc = md->rmd128.state[2];
59     dd = ddd = md->rmd128.state[3];
60     FF(aa, bb, cc, dd, X[ 0], 11);
61     FF(dd, aa, bb, cc, X[ 1], 14);
62     FF(cc, dd, aa, bb, X[ 2], 15);
63     FF(bb, cc, dd, aa, X[ 3], 12);
64     FF(aa, bb, cc, dd, X[ 4],  5);
65     FF(dd, aa, bb, cc, X[ 5],  8);
66     FF(cc, dd, aa, bb, X[ 6],  7);
67     FF(bb, cc, dd, aa, X[ 7],  9);
68     FF(aa, bb, cc, dd, X[ 8], 11);
69     FF(dd, aa, bb, cc, X[ 9], 13);
70     FF(cc, dd, aa, bb, X[10], 14);
71     FF(bb, cc, dd, aa, X[11], 15);
72     FF(aa, bb, cc, dd, X[12],  6);
73     FF(dd, aa, bb, cc, X[13],  7);
74     FF(cc, dd, aa, bb, X[14],  9);
75     FF(bb, cc, dd, aa, X[15],  8);
76     GG(aa, bb, cc, dd, X[ 7],  7);
77     GG(dd, aa, bb, cc, X[ 4],  6);
78     GG(cc, dd, aa, bb, X[13],  8);
79     GG(bb, cc, dd, aa, X[ 1], 13);
80     GG(aa, bb, cc, dd, X[10], 11);
81     GG(dd, aa, bb, cc, X[ 6],  9);
82     GG(cc, dd, aa, bb, X[15],  7);
83     GG(bb, cc, dd, aa, X[ 3], 15);
84     GG(aa, bb, cc, dd, X[12],  7);
85     GG(dd, aa, bb, cc, X[ 0], 12);
86     GG(cc, dd, aa, bb, X[ 9], 15);
87     GG(bb, cc, dd, aa, X[ 5],  9);
88     GG(aa, bb, cc, dd, X[ 2], 11);
89     GG(dd, aa, bb, cc, X[14],  7);
90     GG(cc, dd, aa, bb, X[11], 13);
91     GG(bb, cc, dd, aa, X[ 8], 12);
92     HH(aa, bb, cc, dd, X[ 3], 11);
93     HH(dd, aa, bb, cc, X[10], 13);
94     HH(cc, dd, aa, bb, X[14],  6);
95     HH(bb, cc, dd, aa, X[ 4],  7);
96     HH(aa, bb, cc, dd, X[ 9], 14);
97     HH(dd, aa, bb, cc, X[15],  9);
98     HH(cc, dd, aa, bb, X[ 8], 13);
99     HH(bb, cc, dd, aa, X[ 1], 15);
100     HH(aa, bb, cc, dd, X[ 2], 14);
101     HH(dd, aa, bb, cc, X[ 7],  8);
102     HH(cc, dd, aa, bb, X[ 0], 13);
103     HH(bb, cc, dd, aa, X[ 6],  6);
104     HH(aa, bb, cc, dd, X[13],  5);
105     HH(dd, aa, bb, cc, X[11], 12);
106     HH(cc, dd, aa, bb, X[ 5],  7);
107     HH(bb, cc, dd, aa, X[12],  5);
108     II(aa, bb, cc, dd, X[ 1], 11);
109     II(dd, aa, bb, cc, X[ 9], 12);
110     II(cc, dd, aa, bb, X[11], 14);
111     II(bb, cc, dd, aa, X[10], 15);
112     II(aa, bb, cc, dd, X[ 0], 14);
113     II(dd, aa, bb, cc, X[ 8], 15);
114     II(cc, dd, aa, bb, X[12],  9);
115     II(bb, cc, dd, aa, X[ 4],  8);
116     II(aa, bb, cc, dd, X[13],  9);
117     II(dd, aa, bb, cc, X[ 3], 14);
118     II(cc, dd, aa, bb, X[ 7],  5);
119     II(bb, cc, dd, aa, X[15],  6);
120     II(aa, bb, cc, dd, X[14],  8);
121     II(dd, aa, bb, cc, X[ 5],  6);
122     II(cc, dd, aa, bb, X[ 6],  5);
123     II(bb, cc, dd, aa, X[ 2], 12);
124     III(aaa, bbb, ccc, ddd, X[ 5],  8);
125     III(ddd, aaa, bbb, ccc, X[14],  9);
126     III(ccc, ddd, aaa, bbb, X[ 7],  9);
127     III(bbb, ccc, ddd, aaa, X[ 0], 11);
128     III(aaa, bbb, ccc, ddd, X[ 9], 13);
129     III(ddd, aaa, bbb, ccc, X[ 2], 15);
130     III(ccc, ddd, aaa, bbb, X[11], 15);
131     III(bbb, ccc, ddd, aaa, X[ 4],  5);
132     III(aaa, bbb, ccc, ddd, X[13],  7);
133     III(ddd, aaa, bbb, ccc, X[ 6],  7);
134     III(ccc, ddd, aaa, bbb, X[15],  8);
135     III(bbb, ccc, ddd, aaa, X[ 8], 11);
136     III(aaa, bbb, ccc, ddd, X[ 1], 14);
137     III(ddd, aaa, bbb, ccc, X[10], 14);
138     III(ccc, ddd, aaa, bbb, X[ 3], 12);
139     III(bbb, ccc, ddd, aaa, X[12],  6);
140     HHH(aaa, bbb, ccc, ddd, X[ 6],  9);
141     HHH(ddd, aaa, bbb, ccc, X[11], 13);
142     HHH(ccc, ddd, aaa, bbb, X[ 3], 15);
143     HHH(bbb, ccc, ddd, aaa, X[ 7],  7);
144     HHH(aaa, bbb, ccc, ddd, X[ 0], 12);
145     HHH(ddd, aaa, bbb, ccc, X[13],  8);
146     HHH(ccc, ddd, aaa, bbb, X[ 5],  9);
147     HHH(bbb, ccc, ddd, aaa, X[10], 11);
148     HHH(aaa, bbb, ccc, ddd, X[14],  7);
149     HHH(ddd, aaa, bbb, ccc, X[15],  7);
150     HHH(ccc, ddd, aaa, bbb, X[ 8], 12);
151     HHH(bbb, ccc, ddd, aaa, X[12],  7);
152     HHH(aaa, bbb, ccc, ddd, X[ 4],  6);
153     HHH(ddd, aaa, bbb, ccc, X[ 9], 15);
154     HHH(ccc, ddd, aaa, bbb, X[ 1], 13);
155     HHH(bbb, ccc, ddd, aaa, X[ 2], 11);
156     GGG(aaa, bbb, ccc, ddd, X[15],  9);
157     GGG(ddd, aaa, bbb, ccc, X[ 5],  7);
158     GGG(ccc, ddd, aaa, bbb, X[ 1], 15);
159     GGG(bbb, ccc, ddd, aaa, X[ 3], 11);
160     GGG(aaa, bbb, ccc, ddd, X[ 7],  8);
161     GGG(ddd, aaa, bbb, ccc, X[14],  6);
162     GGG(ccc, ddd, aaa, bbb, X[ 6],  6);
163     GGG(bbb, ccc, ddd, aaa, X[ 9], 14);
164     GGG(aaa, bbb, ccc, ddd, X[11], 12);
165     GGG(ddd, aaa, bbb, ccc, X[ 8], 13);
166     GGG(ccc, ddd, aaa, bbb, X[12],  5);
167     GGG(bbb, ccc, ddd, aaa, X[ 2], 14);
168     GGG(aaa, bbb, ccc, ddd, X[10], 13);
169     GGG(ddd, aaa, bbb, ccc, X[ 0], 13);
170     GGG(ccc, ddd, aaa, bbb, X[ 4],  7);
171     GGG(bbb, ccc, ddd, aaa, X[13],  5);
172     FFF(aaa, bbb, ccc, ddd, X[ 8], 15);
173     FFF(ddd, aaa, bbb, ccc, X[ 6],  5);
174     FFF(ccc, ddd, aaa, bbb, X[ 4],  8);
175     FFF(bbb, ccc, ddd, aaa, X[ 1], 11);
176     FFF(aaa, bbb, ccc, ddd, X[ 3], 14);
177     FFF(ddd, aaa, bbb, ccc, X[11], 14);
178     FFF(ccc, ddd, aaa, bbb, X[15],  6);
179     FFF(bbb, ccc, ddd, aaa, X[ 0], 14);
180     FFF(aaa, bbb, ccc, ddd, X[ 5],  6);
181     FFF(ddd, aaa, bbb, ccc, X[12],  9);
182     FFF(ccc, ddd, aaa, bbb, X[ 2], 12);
183     FFF(bbb, ccc, ddd, aaa, X[13],  9);
184     FFF(aaa, bbb, ccc, ddd, X[ 9], 12);
185     FFF(ddd, aaa, bbb, ccc, X[ 7],  5);
186     FFF(ccc, ddd, aaa, bbb, X[10], 15);
187     FFF(bbb, ccc, ddd, aaa, X[14],  8);
188     ddd += cc + md->rmd128.state[1];               &bsol;* final result for MDbuf[0] */
</span>189     md->rmd128.state[1] = md->rmd128.state[2] + dd + aaa;
190     md->rmd128.state[2] = md->rmd128.state[3] + aa + bbb;
191     md->rmd128.state[3] = md->rmd128.state[0] + bb + ccc;
192     md->rmd128.state[0] = ddd;
193     return CRYPT_OK;
194  }
195  #ifdef LTC_CLEAN_STACK
196  static int s_rmd128_compress(hash_state *md, const unsigned char *buf)
197  {
198     int err;
199     err = ss_rmd128_compress(md, buf);
200     burn_stack(sizeof(ulong32) * 24 + sizeof(int));
201     return err;
202  }
203  #endif
204  int rmd128_init(hash_state * md)
205  {
206     LTC_ARGCHK(md != NULL);
207     md->rmd128.state[0] = 0x67452301UL;
208     md->rmd128.state[1] = 0xefcdab89UL;
209     md->rmd128.state[2] = 0x98badcfeUL;
210     md->rmd128.state[3] = 0x10325476UL;
211     md->rmd128.curlen   = 0;
212     md->rmd128.length   = 0;
213     return CRYPT_OK;
214  }
215  HASH_PROCESS(rmd128_process, s_rmd128_compress, rmd128, 64)
216  int rmd128_done(hash_state * md, unsigned char *out)
217  {
218      int i;
219      LTC_ARGCHK(md  != NULL);
220      LTC_ARGCHK(out != NULL);
221      if (md->rmd128.curlen >= sizeof(md->rmd128.buf)) {
222         return CRYPT_INVALID_ARG;
223      }
224      md->rmd128.length += md->rmd128.curlen * 8;
225      md->rmd128.buf[md->rmd128.curlen++] = (unsigned char)0x80;
226      if (md->rmd128.curlen > 56) {
227          while (md->rmd128.curlen < 64) {
228              md->rmd128.buf[md->rmd128.curlen++] = (unsigned char)0;
229          }
230          s_rmd128_compress(md, md->rmd128.buf);
231          md->rmd128.curlen = 0;
232      }
233      while (md->rmd128.curlen < 56) {
234          md->rmd128.buf[md->rmd128.curlen++] = (unsigned char)0;
235      }
236      STORE64L(md->rmd128.length, md->rmd128.buf+56);
237      s_rmd128_compress(md, md->rmd128.buf);
238      for (i = 0; i < 4; i++) {
239          STORE32L(md->rmd128.state[i], out+(4*i));
240      }
241  #ifdef LTC_CLEAN_STACK
242      zeromem(md, sizeof(hash_state));
243  #endif
244     return CRYPT_OK;
245  }
246  int rmd128_test(void)
247  {
248  #ifndef LTC_TEST
249     return CRYPT_NOP;
250  #else
251     static const struct {
252          const char *msg;
253          unsigned char hash[16];
254     } tests[] = {
255     { "",
256       { 0xcd, 0xf2, 0x62, 0x13, 0xa1, 0x50, 0xdc, 0x3e,
257         0xcb, 0x61, 0x0f, 0x18, 0xf6, 0xb3, 0x8b, 0x46 }
258     },
259     { "a",
260       { 0x86, 0xbe, 0x7a, 0xfa, 0x33, 0x9d, 0x0f, 0xc7,
261         0xcf, 0xc7, 0x85, 0xe7, 0x2f, 0x57, 0x8d, 0x33 }
262     },
263     { "abc",
264       { 0xc1, 0x4a, 0x12, 0x19, 0x9c, 0x66, 0xe4, 0xba,
265         0x84, 0x63, 0x6b, 0x0f, 0x69, 0x14, 0x4c, 0x77 }
266     },
267     { "message digest",
268       { 0x9e, 0x32, 0x7b, 0x3d, 0x6e, 0x52, 0x30, 0x62,
269         0xaf, 0xc1, 0x13, 0x2d, 0x7d, 0xf9, 0xd1, 0xb8 }
270     },
271     { "abcdefghijklmnopqrstuvwxyz",
272       { 0xfd, 0x2a, 0xa6, 0x07, 0xf7, 0x1d, 0xc8, 0xf5,
273         0x10, 0x71, 0x49, 0x22, 0xb3, 0x71, 0x83, 0x4e }
274     },
275     { "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
276       { 0xd1, 0xe9, 0x59, 0xeb, 0x17, 0x9c, 0x91, 0x1f,
277         0xae, 0xa4, 0x62, 0x4c, 0x60, 0xc5, 0xc7, 0x02 }
278     }
279     };
280     int i;
281     unsigned char tmp[16];
282     hash_state md;
283     for (i = 0; i < (int)(sizeof(tests)/sizeof(tests[0])); i++) {
284         rmd128_init(&md);
285         rmd128_process(&md, (unsigned char *)tests[i].msg, XSTRLEN(tests[i].msg));
286         rmd128_done(&md, tmp);
287         if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "RIPEMD128", i)) {
288            return CRYPT_FAIL_TESTVECTOR;
289         }
290     }
291     return CRYPT_OK;
292  #endif
293  }
294  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-sosemanuk.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_SOSEMANUK
3  #define T32(x)   ((x) & (ulong32)0xFFFFFFFF)
4  #define S0(r0, r1, r2, r3, r4)   do { \
5          r3 ^= r0;  r4  = r1; \
6          r1 &= r3;  r4 ^= r2; \
7          r1 ^= r0;  r0 |= r3; \
8          r0 ^= r4;  r4 ^= r3; \
9          r3 ^= r2;  r2 |= r1; \
10          r2 ^= r4;  r4 = ~r4; \
11          r4 |= r1;  r1 ^= r3; \
12          r1 ^= r4;  r3 |= r0; \
13          r1 ^= r3;  r4 ^= r3; \
14      } while (0)
15  #define S1(r0, r1, r2, r3, r4)   do { \
16          r0 = ~r0;  r2 = ~r2; \
17          r4  = r0;  r0 &= r1; \
18          r2 ^= r0;  r0 |= r3; \
19          r3 ^= r2;  r1 ^= r0; \
20          r0 ^= r4;  r4 |= r1; \
21          r1 ^= r3;  r2 |= r0; \
22          r2 &= r4;  r0 ^= r1; \
23          r1 &= r2; \
24          r1 ^= r0;  r0 &= r2; \
25          r0 ^= r4; \
26      } while (0)
27  #define S2(r0, r1, r2, r3, r4)   do { \
28          r4  = r0;  r0 &= r2; \
29          r0 ^= r3;  r2 ^= r1; \
30          r2 ^= r0;  r3 |= r4; \
31          r3 ^= r1;  r4 ^= r2; \
32          r1  = r3;  r3 |= r4; \
33          r3 ^= r0;  r0 &= r1; \
34          r4 ^= r0;  r1 ^= r3; \
35          r1 ^= r4;  r4 = ~r4; \
36      } while (0)
37  #define S3(r0, r1, r2, r3, r4)   do { \
38          r4  = r0;  r0 |= r3; \
39          r3 ^= r1;  r1 &= r4; \
40          r4 ^= r2;  r2 ^= r3; \
41          r3 &= r0;  r4 |= r1; \
42          r3 ^= r4;  r0 ^= r1; \
43          r4 &= r0;  r1 ^= r3; \
44          r4 ^= r2;  r1 |= r0; \
45          r1 ^= r2;  r0 ^= r3; \
46          r2  = r1;  r1 |= r3; \
47          r1 ^= r0; \
48      } while (0)
49  #define S4(r0, r1, r2, r3, r4)   do { \
50          r1 ^= r3;  r3 = ~r3; \
51          r2 ^= r3;  r3 ^= r0; \
52          r4  = r1;  r1 &= r3; \
53          r1 ^= r2;  r4 ^= r3; \
54          r0 ^= r4;  r2 &= r4; \
55          r2 ^= r0;  r0 &= r1; \
56          r3 ^= r0;  r4 |= r1; \
57          r4 ^= r0;  r0 |= r3; \
58          r0 ^= r2;  r2 &= r3; \
59          r0 = ~r0;  r4 ^= r2; \
60      } while (0)
61  #define S5(r0, r1, r2, r3, r4)   do { \
62          r0 ^= r1;  r1 ^= r3; \
63          r3 = ~r3;  r4  = r1; \
64          r1 &= r0;  r2 ^= r3; \
65          r1 ^= r2;  r2 |= r4; \
66          r4 ^= r3;  r3 &= r1; \
67          r3 ^= r0;  r4 ^= r1; \
68          r4 ^= r2;  r2 ^= r0; \
69          r0 &= r3;  r2 = ~r2; \
70          r0 ^= r4;  r4 |= r3; \
71          r2 ^= r4; \
72      } while (0)
73  #define S6(r0, r1, r2, r3, r4)   do { \
74          r2 = ~r2;  r4  = r3; \
75          r3 &= r0;  r0 ^= r4; \
76          r3 ^= r2;  r2 |= r4; \
77          r1 ^= r3;  r2 ^= r0; \
78          r0 |= r1;  r2 ^= r1; \
79          r4 ^= r0;  r0 |= r3; \
80          r0 ^= r2;  r4 ^= r3; \
81          r4 ^= r0;  r3 = ~r3; \
82          r2 &= r4; \
83          r2 ^= r3; \
84      } while (0)
85  #define S7(r0, r1, r2, r3, r4)   do { \
86          r4  = r1;  r1 |= r2; \
87          r1 ^= r3;  r4 ^= r2; \
88          r2 ^= r1;  r3 |= r4; \
89          r3 &= r0;  r4 ^= r2; \
90          r3 ^= r1;  r1 |= r4; \
91          r1 ^= r0;  r0 |= r4; \
92          r0 ^= r2;  r1 ^= r4; \
93          r2 ^= r1;  r1 &= r0; \
94          r1 ^= r4;  r2 = ~r2; \
95          r2 |= r0; \
96          r4 ^= r2; \
97      } while (0)
98  #define SERPENT_LT(x0, x1, x2, x3)  do { \
99          x0 = ROLc(x0, 13); \
100          x2 = ROLc(x2, 3); \
101          x1 = x1 ^ x0 ^ x2; \
102          x3 = x3 ^ x2 ^ T32(x0 << 3); \
103          x1 = ROLc(x1, 1); \
104          x3 = ROLc(x3, 7); \
105          x0 = x0 ^ x1 ^ x3; \
106          x2 = x2 ^ x3 ^ T32(x1 << 7); \
107          x0 = ROLc(x0, 5); \
108          x2 = ROLc(x2, 22); \
109      } while (0)
110  int sosemanuk_setup(sosemanuk_state *st, const unsigned char *key, unsigned long keylen)
111  {
112  #define SKS(S, o0, o1, o2, o3, d0, d1, d2, d3)   do { \
113          ulong32 r0, r1, r2, r3, r4; \
114          r0 = w ## o0; \
115          r1 = w ## o1; \
116          r2 = w ## o2; \
117          r3 = w ## o3; \
118          S(r0, r1, r2, r3, r4); \
119          st->kc[i ++] = r ## d0; \
120          st->kc[i ++] = r ## d1; \
121          st->kc[i ++] = r ## d2; \
122          st->kc[i ++] = r ## d3; \
123      } while (0)
124  #define SKS0    SKS(S0, 4, 5, 6, 7, 1, 4, 2, 0)
125  #define SKS1    SKS(S1, 0, 1, 2, 3, 2, 0, 3, 1)
126  #define SKS2    SKS(S2, 4, 5, 6, 7, 2, 3, 1, 4)
127  #define SKS3    SKS(S3, 0, 1, 2, 3, 1, 2, 3, 4)
128  #define SKS4    SKS(S4, 4, 5, 6, 7, 1, 4, 0, 3)
129  #define SKS5    SKS(S5, 0, 1, 2, 3, 1, 3, 0, 2)
130  #define SKS6    SKS(S6, 4, 5, 6, 7, 0, 1, 4, 2)
131  #define SKS7    SKS(S7, 0, 1, 2, 3, 4, 3, 1, 0)
132  #define WUP(wi, wi5, wi3, wi1, cc)   do { \
133          ulong32 tt = (wi) ^ (wi5) ^ (wi3) \
134              ^ (wi1) ^ (0x9E3779B9 ^ (ulong32)(cc)); \
135          (wi) = ROLc(tt, 11); \
136      } while (0)
137  #define WUP0(cc)   do { \
138          WUP(w0, w3, w5, w7, cc); \
139          WUP(w1, w4, w6, w0, cc + 1); \
140          WUP(w2, w5, w7, w1, cc + 2); \
141          WUP(w3, w6, w0, w2, cc + 3); \
142      } while (0)
143  #define WUP1(cc)   do { \
144          WUP(w4, w7, w1, w3, cc); \
145          WUP(w5, w0, w2, w4, cc + 1); \
146          WUP(w6, w1, w3, w5, cc + 2); \
147          WUP(w7, w2, w4, w6, cc + 3); \
148      } while (0)
149      unsigned char wbuf[32];
150      ulong32 w0, w1, w2, w3, w4, w5, w6, w7;
151      int i = 0;
152     LTC_ARGCHK(st  != NULL);
153     LTC_ARGCHK(key != NULL);
154     LTC_ARGCHK(keylen > 0 && keylen <= 32);
155      XMEMCPY(wbuf, key, keylen);
156      if (keylen < 32) {
157          wbuf[keylen] = 0x01;
158          if (keylen < 31) {
159              XMEMSET(wbuf + keylen + 1, 0, 31 - keylen);
160          }
161      }
162      LOAD32L(w0, wbuf);
163      LOAD32L(w1, wbuf + 4);
164      LOAD32L(w2, wbuf + 8);
165      LOAD32L(w3, wbuf + 12);
166      LOAD32L(w4, wbuf + 16);
167      LOAD32L(w5, wbuf + 20);
168      LOAD32L(w6, wbuf + 24);
169      LOAD32L(w7, wbuf + 28);
170      WUP0(0);   SKS3;
171      WUP1(4);   SKS2;
172      WUP0(8);   SKS1;
173      WUP1(12);  SKS0;
174      WUP0(16);  SKS7;
175      WUP1(20);  SKS6;
176      WUP0(24);  SKS5;
177      WUP1(28);  SKS4;
178      WUP0(32);  SKS3;
179      WUP1(36);  SKS2;
180      WUP0(40);  SKS1;
181      WUP1(44);  SKS0;
182      WUP0(48);  SKS7;
183      WUP1(52);  SKS6;
184      WUP0(56);  SKS5;
185      WUP1(60);  SKS4;
186      WUP0(64);  SKS3;
187      WUP1(68);  SKS2;
188      WUP0(72);  SKS1;
189      WUP1(76);  SKS0;
190      WUP0(80);  SKS7;
191      WUP1(84);  SKS6;
192      WUP0(88);  SKS5;
193      WUP1(92);  SKS4;
194      WUP0(96);  SKS3;
195  #undef SKS
196  #undef SKS0
197  #undef SKS1
198  #undef SKS2
199  #undef SKS3
200  #undef SKS4
201  #undef SKS5
202  #undef SKS6
203  #undef SKS7
204  #undef WUP
205  #undef WUP0
206  #undef WUP1
207      return CRYPT_OK;
208  }
209  int sosemanuk_setiv(sosemanuk_state *st, const unsigned char *iv, unsigned long ivlen)
210  {
211  #define KA(zc, x0, x1, x2, x3)  do { \
212          x0 ^= st->kc[(zc)]; \
213          x1 ^= st->kc[(zc) + 1]; \
214          x2 ^= st->kc[(zc) + 2]; \
215          x3 ^= st->kc[(zc) + 3]; \
216      } while (0)
217  #define FSS(zc, S, i0, i1, i2, i3, i4, o0, o1, o2, o3)  do { \
218          KA(zc, r ## i0, r ## i1, r ## i2, r ## i3); \
219          S(r ## i0, r ## i1, r ## i2, r ## i3, r ## i4); \
220          SERPENT_LT(r ## o0, r ## o1, r ## o2, r ## o3); \
221      } while (0)
222  #define FSF(zc, S, i0, i1, i2, i3, i4, o0, o1, o2, o3)  do { \
223          KA(zc, r ## i0, r ## i1, r ## i2, r ## i3); \
224          S(r ## i0, r ## i1, r ## i2, r ## i3, r ## i4); \
225          SERPENT_LT(r ## o0, r ## o1, r ## o2, r ## o3); \
226          KA(zc + 4, r ## o0, r ## o1, r ## o2, r ## o3); \
227      } while (0)
228      ulong32 r0, r1, r2, r3, r4;
229      unsigned char ivtmp[16] = {0};
230      LTC_ARGCHK(st != NULL);
231      LTC_ARGCHK(ivlen <= 16);
232      LTC_ARGCHK(iv != NULL || ivlen == 0);
233      if (ivlen > 0) XMEMCPY(ivtmp, iv, ivlen);
234      LOAD32L(r0, ivtmp);
235      LOAD32L(r1, ivtmp + 4);
236      LOAD32L(r2, ivtmp + 8);
237      LOAD32L(r3, ivtmp + 12);
238      FSS(0, S0, 0, 1, 2, 3, 4, 1, 4, 2, 0);
239      FSS(4, S1, 1, 4, 2, 0, 3, 2, 1, 0, 4);
240      FSS(8, S2, 2, 1, 0, 4, 3, 0, 4, 1, 3);
241      FSS(12, S3, 0, 4, 1, 3, 2, 4, 1, 3, 2);
242      FSS(16, S4, 4, 1, 3, 2, 0, 1, 0, 4, 2);
243      FSS(20, S5, 1, 0, 4, 2, 3, 0, 2, 1, 4);
244      FSS(24, S6, 0, 2, 1, 4, 3, 0, 2, 3, 1);
245      FSS(28, S7, 0, 2, 3, 1, 4, 4, 1, 2, 0);
246      FSS(32, S0, 4, 1, 2, 0, 3, 1, 3, 2, 4);
247      FSS(36, S1, 1, 3, 2, 4, 0, 2, 1, 4, 3);
248      FSS(40, S2, 2, 1, 4, 3, 0, 4, 3, 1, 0);
249      FSS(44, S3, 4, 3, 1, 0, 2, 3, 1, 0, 2);
<span onclick='openModal()' class='match'>250      st->s09 = r3;
251      st->s08 = r1;
252      st->s07 = r0;
253      st->s06 = r2;
254      FSS(48, S4, 3, 1, 0, 2, 4, 1, 4, 3, 2);
255      FSS(52, S5, 1, 4, 3, 2, 0, 4, 2, 1, 3);
256      FSS(56, S6, 4, 2, 1, 3, 0, 4, 2, 0, 1);
257      FSS(60, S7, 4, 2, 0, 1, 3, 3, 1, 2, 4);
258      FSS(64, S0, 3, 1, 2, 4, 0, 1, 0, 2, 3);
259      FSS(68, S1, 1, 0, 2, 3, 4, 2, 1, 3, 0);
260      st->r1  = r2;
261      st->s04 = r1;
262      st->r2  = r3;
263      st->s05 = r0;
264      FSS(72, S2, 2, 1, 3, 0, 4, 3, 0, 1, 4);
265      FSS(76, S3, 3, 0, 1, 4, 2, 0, 1, 4, 2);
266      FSS(80, S4, 0, 1, 4, 2, 3, 1, 3, 0, 2);
267      FSS(84, S5, 1, 3, 0, 2, 4, 3, 2, 1, 0);
268      FSS(88, S6, 3, 2, 1, 0, 4, 3, 2, 4, 1);
269      FSF(92, S7, 3, 2, 4, 1, 0, 0, 1, 2, 3);
270      st->s03 = r0;
</span>271      st->s02 = r1;
272      st->s01 = r2;
273      st->s00 = r3;
274      st->ptr = sizeof(st->buf);
275  #undef KA
276  #undef FSS
277  #undef FSF
278      return CRYPT_OK;
279  }
280  static const ulong32 mul_a[] = {
281      0x00000000, 0xE19FCF13, 0x6B973726, 0x8A08F835,
282      0xD6876E4C, 0x3718A15F, 0xBD10596A, 0x5C8F9679,
283      0x05A7DC98, 0xE438138B, 0x6E30EBBE, 0x8FAF24AD,
284      0xD320B2D4, 0x32BF7DC7, 0xB8B785F2, 0x59284AE1,
285      0x0AE71199, 0xEB78DE8A, 0x617026BF, 0x80EFE9AC,
286      0xDC607FD5, 0x3DFFB0C6, 0xB7F748F3, 0x566887E0,
287      0x0F40CD01, 0xEEDF0212, 0x64D7FA27, 0x85483534,
288      0xD9C7A34D, 0x38586C5E, 0xB250946B, 0x53CF5B78,
289      0x1467229B, 0xF5F8ED88, 0x7FF015BD, 0x9E6FDAAE,
290      0xC2E04CD7, 0x237F83C4, 0xA9777BF1, 0x48E8B4E2,
291      0x11C0FE03, 0xF05F3110, 0x7A57C925, 0x9BC80636,
292      0xC747904F, 0x26D85F5C, 0xACD0A769, 0x4D4F687A,
293      0x1E803302, 0xFF1FFC11, 0x75170424, 0x9488CB37,
294      0xC8075D4E, 0x2998925D, 0xA3906A68, 0x420FA57B,
295      0x1B27EF9A, 0xFAB82089, 0x70B0D8BC, 0x912F17AF,
296      0xCDA081D6, 0x2C3F4EC5, 0xA637B6F0, 0x47A879E3,
297      0x28CE449F, 0xC9518B8C, 0x435973B9, 0xA2C6BCAA,
298      0xFE492AD3, 0x1FD6E5C0, 0x95DE1DF5, 0x7441D2E6,
299      0x2D699807, 0xCCF65714, 0x46FEAF21, 0xA7616032,
300      0xFBEEF64B, 0x1A713958, 0x9079C16D, 0x71E60E7E,
301      0x22295506, 0xC3B69A15, 0x49BE6220, 0xA821AD33,
302      0xF4AE3B4A, 0x1531F459, 0x9F390C6C, 0x7EA6C37F,
303      0x278E899E, 0xC611468D, 0x4C19BEB8, 0xAD8671AB,
304      0xF109E7D2, 0x109628C1, 0x9A9ED0F4, 0x7B011FE7,
305      0x3CA96604, 0xDD36A917, 0x573E5122, 0xB6A19E31,
306      0xEA2E0848, 0x0BB1C75B, 0x81B93F6E, 0x6026F07D,
307      0x390EBA9C, 0xD891758F, 0x52998DBA, 0xB30642A9,
308      0xEF89D4D0, 0x0E161BC3, 0x841EE3F6, 0x65812CE5,
309      0x364E779D, 0xD7D1B88E, 0x5DD940BB, 0xBC468FA8,
310      0xE0C919D1, 0x0156D6C2, 0x8B5E2EF7, 0x6AC1E1E4,
311      0x33E9AB05, 0xD2766416, 0x587E9C23, 0xB9E15330,
312      0xE56EC549, 0x04F10A5A, 0x8EF9F26F, 0x6F663D7C,
313      0x50358897, 0xB1AA4784, 0x3BA2BFB1, 0xDA3D70A2,
314      0x86B2E6DB, 0x672D29C8, 0xED25D1FD, 0x0CBA1EEE,
315      0x5592540F, 0xB40D9B1C, 0x3E056329, 0xDF9AAC3A,
316      0x83153A43, 0x628AF550, 0xE8820D65, 0x091DC276,
317      0x5AD2990E, 0xBB4D561D, 0x3145AE28, 0xD0DA613B,
318      0x8C55F742, 0x6DCA3851, 0xE7C2C064, 0x065D0F77,
319      0x5F754596, 0xBEEA8A85, 0x34E272B0, 0xD57DBDA3,
320      0x89F22BDA, 0x686DE4C9, 0xE2651CFC, 0x03FAD3EF,
321      0x4452AA0C, 0xA5CD651F, 0x2FC59D2A, 0xCE5A5239,
322      0x92D5C440, 0x734A0B53, 0xF942F366, 0x18DD3C75,
323      0x41F57694, 0xA06AB987, 0x2A6241B2, 0xCBFD8EA1,
324      0x977218D8, 0x76EDD7CB, 0xFCE52FFE, 0x1D7AE0ED,
325      0x4EB5BB95, 0xAF2A7486, 0x25228CB3, 0xC4BD43A0,
326      0x9832D5D9, 0x79AD1ACA, 0xF3A5E2FF, 0x123A2DEC,
327      0x4B12670D, 0xAA8DA81E, 0x2085502B, 0xC11A9F38,
328      0x9D950941, 0x7C0AC652, 0xF6023E67, 0x179DF174,
329      0x78FBCC08, 0x9964031B, 0x136CFB2E, 0xF2F3343D,
330      0xAE7CA244, 0x4FE36D57, 0xC5EB9562, 0x24745A71,
331      0x7D5C1090, 0x9CC3DF83, 0x16CB27B6, 0xF754E8A5,
332      0xABDB7EDC, 0x4A44B1CF, 0xC04C49FA, 0x21D386E9,
333      0x721CDD91, 0x93831282, 0x198BEAB7, 0xF81425A4,
334      0xA49BB3DD, 0x45047CCE, 0xCF0C84FB, 0x2E934BE8,
335      0x77BB0109, 0x9624CE1A, 0x1C2C362F, 0xFDB3F93C,
336      0xA13C6F45, 0x40A3A056, 0xCAAB5863, 0x2B349770,
337      0x6C9CEE93, 0x8D032180, 0x070BD9B5, 0xE69416A6,
338      0xBA1B80DF, 0x5B844FCC, 0xD18CB7F9, 0x301378EA,
339      0x693B320B, 0x88A4FD18, 0x02AC052D, 0xE333CA3E,
340      0xBFBC5C47, 0x5E239354, 0xD42B6B61, 0x35B4A472,
341      0x667BFF0A, 0x87E43019, 0x0DECC82C, 0xEC73073F,
342      0xB0FC9146, 0x51635E55, 0xDB6BA660, 0x3AF46973,
343      0x63DC2392, 0x8243EC81, 0x084B14B4, 0xE9D4DBA7,
344      0xB55B4DDE, 0x54C482CD, 0xDECC7AF8, 0x3F53B5EB
345  };
346  static const ulong32 mul_ia[] = {
347      0x00000000, 0x180F40CD, 0x301E8033, 0x2811C0FE,
348      0x603CA966, 0x7833E9AB, 0x50222955, 0x482D6998,
349      0xC078FBCC, 0xD877BB01, 0xF0667BFF, 0xE8693B32,
350      0xA04452AA, 0xB84B1267, 0x905AD299, 0x88559254,
351      0x29F05F31, 0x31FF1FFC, 0x19EEDF02, 0x01E19FCF,
352      0x49CCF657, 0x51C3B69A, 0x79D27664, 0x61DD36A9,
353      0xE988A4FD, 0xF187E430, 0xD99624CE, 0xC1996403,
354      0x89B40D9B, 0x91BB4D56, 0xB9AA8DA8, 0xA1A5CD65,
355      0x5249BE62, 0x4A46FEAF, 0x62573E51, 0x7A587E9C,
356      0x32751704, 0x2A7A57C9, 0x026B9737, 0x1A64D7FA,
357      0x923145AE, 0x8A3E0563, 0xA22FC59D, 0xBA208550,
358      0xF20DECC8, 0xEA02AC05, 0xC2136CFB, 0xDA1C2C36,
359      0x7BB9E153, 0x63B6A19E, 0x4BA76160, 0x53A821AD,
360      0x1B854835, 0x038A08F8, 0x2B9BC806, 0x339488CB,
361      0xBBC11A9F, 0xA3CE5A52, 0x8BDF9AAC, 0x93D0DA61,
362      0xDBFDB3F9, 0xC3F2F334, 0xEBE333CA, 0xF3EC7307,
363      0xA492D5C4, 0xBC9D9509, 0x948C55F7, 0x8C83153A,
364      0xC4AE7CA2, 0xDCA13C6F, 0xF4B0FC91, 0xECBFBC5C,
365      0x64EA2E08, 0x7CE56EC5, 0x54F4AE3B, 0x4CFBEEF6,
366      0x04D6876E, 0x1CD9C7A3, 0x34C8075D, 0x2CC74790,
367      0x8D628AF5, 0x956DCA38, 0xBD7C0AC6, 0xA5734A0B,
368      0xED5E2393, 0xF551635E, 0xDD40A3A0, 0xC54FE36D,
369      0x4D1A7139, 0x551531F4, 0x7D04F10A, 0x650BB1C7,
370      0x2D26D85F, 0x35299892, 0x1D38586C, 0x053718A1,
371      0xF6DB6BA6, 0xEED42B6B, 0xC6C5EB95, 0xDECAAB58,
372      0x96E7C2C0, 0x8EE8820D, 0xA6F942F3, 0xBEF6023E,
373      0x36A3906A, 0x2EACD0A7, 0x06BD1059, 0x1EB25094,
374      0x569F390C, 0x4E9079C1, 0x6681B93F, 0x7E8EF9F2,
375      0xDF2B3497, 0xC724745A, 0xEF35B4A4, 0xF73AF469,
376      0xBF179DF1, 0xA718DD3C, 0x8F091DC2, 0x97065D0F,
377      0x1F53CF5B, 0x075C8F96, 0x2F4D4F68, 0x37420FA5,
378      0x7F6F663D, 0x676026F0, 0x4F71E60E, 0x577EA6C3,
379      0xE18D0321, 0xF98243EC, 0xD1938312, 0xC99CC3DF,
380      0x81B1AA47, 0x99BEEA8A, 0xB1AF2A74, 0xA9A06AB9,
381      0x21F5F8ED, 0x39FAB820, 0x11EB78DE, 0x09E43813,
382      0x41C9518B, 0x59C61146, 0x71D7D1B8, 0x69D89175,
383      0xC87D5C10, 0xD0721CDD, 0xF863DC23, 0xE06C9CEE,
384      0xA841F576, 0xB04EB5BB, 0x985F7545, 0x80503588,
385      0x0805A7DC, 0x100AE711, 0x381B27EF, 0x20146722,
386      0x68390EBA, 0x70364E77, 0x58278E89, 0x4028CE44,
387      0xB3C4BD43, 0xABCBFD8E, 0x83DA3D70, 0x9BD57DBD,
388      0xD3F81425, 0xCBF754E8, 0xE3E69416, 0xFBE9D4DB,
389      0x73BC468F, 0x6BB30642, 0x43A2C6BC, 0x5BAD8671,
390      0x1380EFE9, 0x0B8FAF24, 0x239E6FDA, 0x3B912F17,
391      0x9A34E272, 0x823BA2BF, 0xAA2A6241, 0xB225228C,
392      0xFA084B14, 0xE2070BD9, 0xCA16CB27, 0xD2198BEA,
393      0x5A4C19BE, 0x42435973, 0x6A52998D, 0x725DD940,
394      0x3A70B0D8, 0x227FF015, 0x0A6E30EB, 0x12617026,
395      0x451FD6E5, 0x5D109628, 0x750156D6, 0x6D0E161B,
396      0x25237F83, 0x3D2C3F4E, 0x153DFFB0, 0x0D32BF7D,
397      0x85672D29, 0x9D686DE4, 0xB579AD1A, 0xAD76EDD7,
398      0xE55B844F, 0xFD54C482, 0xD545047C, 0xCD4A44B1,
399      0x6CEF89D4, 0x74E0C919, 0x5CF109E7, 0x44FE492A,
400      0x0CD320B2, 0x14DC607F, 0x3CCDA081, 0x24C2E04C,
401      0xAC977218, 0xB49832D5, 0x9C89F22B, 0x8486B2E6,
402      0xCCABDB7E, 0xD4A49BB3, 0xFCB55B4D, 0xE4BA1B80,
403      0x17566887, 0x0F59284A, 0x2748E8B4, 0x3F47A879,
404      0x776AC1E1, 0x6F65812C, 0x477441D2, 0x5F7B011F,
405      0xD72E934B, 0xCF21D386, 0xE7301378, 0xFF3F53B5,
406      0xB7123A2D, 0xAF1D7AE0, 0x870CBA1E, 0x9F03FAD3,
407      0x3EA637B6, 0x26A9777B, 0x0EB8B785, 0x16B7F748,
408      0x5E9A9ED0, 0x4695DE1D, 0x6E841EE3, 0x768B5E2E,
409      0xFEDECC7A, 0xE6D18CB7, 0xCEC04C49, 0xD6CF0C84,
410      0x9EE2651C, 0x86ED25D1, 0xAEFCE52F, 0xB6F3A5E2
411  };
412  static LTC_INLINE void s_sosemanuk_internal(sosemanuk_state *st)
413  {
414  #define MUL_A(x)    (T32((x) << 8) ^ mul_a[(x) >> 24])
415  #define MUL_G(x)    (((x) >> 8) ^ mul_ia[(x) & 0xFF])
416  #ifdef __alpha
417  #define XMUX(c, x, y)   ((((signed int)((c) << 31) >> 31) & (y)) ^ (x))
418  #else
419  #define XMUX(c, x, y)   (((c) & 0x1) ? ((x) ^ (y)) : (x))
420  #endif
421  #define FSM(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)   do { \
422          ulong32 tt, or1; \
423          tt = XMUX(r1, s ## x1, s ## x8); \
424          or1 = r1; \
425          r1 = T32(r2 + tt); \
426          tt = T32(or1 * 0x54655307); \
427          r2 = ROLc(tt, 7); \
428      } while (0)
429  #define LRU(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, dd)   do { \
430          dd = s ## x0; \
431          s ## x0 = MUL_A(s ## x0) ^ MUL_G(s ## x3) ^ s ## x9; \
432      } while (0)
433  #define CC1(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, ee)   do { \
434          ee = T32(s ## x9 + r1) ^ r2; \
435      } while (0)
436  #define STEP(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, dd, ee)   do { \
437          FSM(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9); \
438          LRU(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, dd); \
439          CC1(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, ee); \
440      } while (0)
441  #define SRD(S, x0, x1, x2, x3, ooff)   do { \
442          S(u0, u1, u2, u3, u4); \
443          STORE32L(u ## x0 ^ v0, st->buf + ooff); \
444          STORE32L(u ## x1 ^ v1, st->buf + ooff +  4); \
445          STORE32L(u ## x2 ^ v2, st->buf + ooff +  8); \
446          STORE32L(u ## x3 ^ v3, st->buf + ooff + 12); \
447      } while (0)
448      ulong32 s00 = st->s00;
449      ulong32 s01 = st->s01;
450      ulong32 s02 = st->s02;
451      ulong32 s03 = st->s03;
452      ulong32 s04 = st->s04;
453      ulong32 s05 = st->s05;
454      ulong32 s06 = st->s06;
455      ulong32 s07 = st->s07;
456      ulong32 s08 = st->s08;
457      ulong32 s09 = st->s09;
458      ulong32 r1 = st->r1;
459      ulong32 r2 = st->r2;
460      ulong32 u0, u1, u2, u3, u4;
461      ulong32 v0, v1, v2, v3;
462      STEP(00, 01, 02, 03, 04, 05, 06, 07, 08, 09, v0, u0);
463      STEP(01, 02, 03, 04, 05, 06, 07, 08, 09, 00, v1, u1);
464      STEP(02, 03, 04, 05, 06, 07, 08, 09, 00, 01, v2, u2);
465      STEP(03, 04, 05, 06, 07, 08, 09, 00, 01, 02, v3, u3);
466      SRD(S2, 2, 3, 1, 4, 0);
467      STEP(04, 05, 06, 07, 08, 09, 00, 01, 02, 03, v0, u0);
468      STEP(05, 06, 07, 08, 09, 00, 01, 02, 03, 04, v1, u1);
469      STEP(06, 07, 08, 09, 00, 01, 02, 03, 04, 05, v2, u2);
470      STEP(07, 08, 09, 00, 01, 02, 03, 04, 05, 06, v3, u3);
471      SRD(S2, 2, 3, 1, 4, 16);
472      STEP(08, 09, 00, 01, 02, 03, 04, 05, 06, 07, v0, u0);
473      STEP(09, 00, 01, 02, 03, 04, 05, 06, 07, 08, v1, u1);
474      STEP(00, 01, 02, 03, 04, 05, 06, 07, 08, 09, v2, u2);
475      STEP(01, 02, 03, 04, 05, 06, 07, 08, 09, 00, v3, u3);
476      SRD(S2, 2, 3, 1, 4, 32);
477      STEP(02, 03, 04, 05, 06, 07, 08, 09, 00, 01, v0, u0);
478      STEP(03, 04, 05, 06, 07, 08, 09, 00, 01, 02, v1, u1);
479      STEP(04, 05, 06, 07, 08, 09, 00, 01, 02, 03, v2, u2);
480      STEP(05, 06, 07, 08, 09, 00, 01, 02, 03, 04, v3, u3);
481      SRD(S2, 2, 3, 1, 4, 48);
482      STEP(06, 07, 08, 09, 00, 01, 02, 03, 04, 05, v0, u0);
483      STEP(07, 08, 09, 00, 01, 02, 03, 04, 05, 06, v1, u1);
484      STEP(08, 09, 00, 01, 02, 03, 04, 05, 06, 07, v2, u2);
485      STEP(09, 00, 01, 02, 03, 04, 05, 06, 07, 08, v3, u3);
486      SRD(S2, 2, 3, 1, 4, 64);
487      st->s00 = s00;
488      st->s01 = s01;
489      st->s02 = s02;
490      st->s03 = s03;
491      st->s04 = s04;
492      st->s05 = s05;
493      st->s06 = s06;
494      st->s07 = s07;
495      st->s08 = s08;
496      st->s09 = s09;
497      st->r1 = r1;
498      st->r2 = r2;
499  }
500  static LTC_INLINE void s_xorbuf(const unsigned char *in1, const unsigned char *in2,
501      unsigned char *out, unsigned long datalen)
502  {
503      while (datalen -- > 0) {
504          *out ++ = *in1 ++ ^ *in2 ++;
505      }
506  }
507  int sosemanuk_crypt(sosemanuk_state *st,
508                          const unsigned char *in, unsigned long inlen, unsigned char *out)
509  {
510      LTC_ARGCHK(st  != NULL);
511      LTC_ARGCHK(in  != NULL);
512      LTC_ARGCHK(out != NULL);
513      if (st->ptr < (sizeof(st->buf))) {
514          unsigned long rlen = (sizeof(st->buf)) - st->ptr;
515          if (rlen > inlen) {
516              rlen = inlen;
517          }
518          s_xorbuf(st->buf + st->ptr, in, out, rlen);
519          in += rlen;
520          out += rlen;
521          inlen -= rlen;
522          st->ptr += rlen;
523      }
524      while (inlen > 0) {
525          s_sosemanuk_internal(st);
526          if (inlen >= sizeof(st->buf)) {
527              s_xorbuf(st->buf, in, out, sizeof(st->buf));
528              in += sizeof(st->buf);
529              out += sizeof(st->buf);
530              inlen -= sizeof(st->buf);
531          } else {
532              s_xorbuf(st->buf, in, out, inlen);
533              st->ptr = inlen;
534              inlen = 0;
535          }
536      }
537      return CRYPT_OK;
538  }
539  int sosemanuk_keystream(sosemanuk_state *st, unsigned char *out, unsigned long outlen)
540  {
541     if (outlen == 0) return CRYPT_OK; &bsol;* nothing to do */
542     LTC_ARGCHK(out != NULL);
543     XMEMSET(out, 0, outlen);
544     return sosemanuk_crypt(st, out, outlen, out);
545  }
546  int sosemanuk_done(sosemanuk_state *st)
547  {
548     LTC_ARGCHK(st != NULL);
549     zeromem(st, sizeof(sosemanuk_state));
550     return CRYPT_OK;
551  }
552  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rmd128.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-sosemanuk.c</div>
                </div>
                <div class="column column_space"><pre><code>56     aa = aaa = md->rmd128.state[0];
57     bb = bbb = md->rmd128.state[1];
58     cc = ccc = md->rmd128.state[2];
59     dd = ddd = md->rmd128.state[3];
60     FF(aa, bb, cc, dd, X[ 0], 11);
61     FF(dd, aa, bb, cc, X[ 1], 14);
62     FF(cc, dd, aa, bb, X[ 2], 15);
63     FF(bb, cc, dd, aa, X[ 3], 12);
64     FF(aa, bb, cc, dd, X[ 4],  5);
65     FF(dd, aa, bb, cc, X[ 5],  8);
66     FF(cc, dd, aa, bb, X[ 6],  7);
67     FF(bb, cc, dd, aa, X[ 7],  9);
68     FF(aa, bb, cc, dd, X[ 8], 11);
69     FF(dd, aa, bb, cc, X[ 9], 13);
70     FF(cc, dd, aa, bb, X[10], 14);
71     FF(bb, cc, dd, aa, X[11], 15);
72     FF(aa, bb, cc, dd, X[12],  6);
73     FF(dd, aa, bb, cc, X[13],  7);
74     FF(cc, dd, aa, bb, X[14],  9);
75     FF(bb, cc, dd, aa, X[15],  8);
76     GG(aa, bb, cc, dd, X[ 7],  7);
77     GG(dd, aa, bb, cc, X[ 4],  6);
78     GG(cc, dd, aa, bb, X[13],  8);
79     GG(bb, cc, dd, aa, X[ 1], 13);
80     GG(aa, bb, cc, dd, X[10], 11);
81     GG(dd, aa, bb, cc, X[ 6],  9);
82     GG(cc, dd, aa, bb, X[15],  7);
83     GG(bb, cc, dd, aa, X[ 3], 15);
84     GG(aa, bb, cc, dd, X[12],  7);
85     GG(dd, aa, bb, cc, X[ 0], 12);
86     GG(cc, dd, aa, bb, X[ 9], 15);
87     GG(bb, cc, dd, aa, X[ 5],  9);
88     GG(aa, bb, cc, dd, X[ 2], 11);
89     GG(dd, aa, bb, cc, X[14],  7);
90     GG(cc, dd, aa, bb, X[11], 13);
91     GG(bb, cc, dd, aa, X[ 8], 12);
92     HH(aa, bb, cc, dd, X[ 3], 11);
93     HH(dd, aa, bb, cc, X[10], 13);
94     HH(cc, dd, aa, bb, X[14],  6);
95     HH(bb, cc, dd, aa, X[ 4],  7);
96     HH(aa, bb, cc, dd, X[ 9], 14);
97     HH(dd, aa, bb, cc, X[15],  9);
98     HH(cc, dd, aa, bb, X[ 8], 13);
99     HH(bb, cc, dd, aa, X[ 1], 15);
100     HH(aa, bb, cc, dd, X[ 2], 14);
101     HH(dd, aa, bb, cc, X[ 7],  8);
102     HH(cc, dd, aa, bb, X[ 0], 13);
103     HH(bb, cc, dd, aa, X[ 6],  6);
104     HH(aa, bb, cc, dd, X[13],  5);
105     HH(dd, aa, bb, cc, X[11], 12);
106     HH(cc, dd, aa, bb, X[ 5],  7);
107     HH(bb, cc, dd, aa, X[12],  5);
108     II(aa, bb, cc, dd, X[ 1], 11);
109     II(dd, aa, bb, cc, X[ 9], 12);
110     II(cc, dd, aa, bb, X[11], 14);
111     II(bb, cc, dd, aa, X[10], 15);
112     II(aa, bb, cc, dd, X[ 0], 14);
113     II(dd, aa, bb, cc, X[ 8], 15);
114     II(cc, dd, aa, bb, X[12],  9);
115     II(bb, cc, dd, aa, X[ 4],  8);
116     II(aa, bb, cc, dd, X[13],  9);
117     II(dd, aa, bb, cc, X[ 3], 14);
118     II(cc, dd, aa, bb, X[ 7],  5);
119     II(bb, cc, dd, aa, X[15],  6);
120     II(aa, bb, cc, dd, X[14],  8);
121     II(dd, aa, bb, cc, X[ 5],  6);
122     II(cc, dd, aa, bb, X[ 6],  5);
123     II(bb, cc, dd, aa, X[ 2], 12);
124     III(aaa, bbb, ccc, ddd, X[ 5],  8);
125     III(ddd, aaa, bbb, ccc, X[14],  9);
126     III(ccc, ddd, aaa, bbb, X[ 7],  9);
127     III(bbb, ccc, ddd, aaa, X[ 0], 11);
128     III(aaa, bbb, ccc, ddd, X[ 9], 13);
129     III(ddd, aaa, bbb, ccc, X[ 2], 15);
130     III(ccc, ddd, aaa, bbb, X[11], 15);
131     III(bbb, ccc, ddd, aaa, X[ 4],  5);
132     III(aaa, bbb, ccc, ddd, X[13],  7);
133     III(ddd, aaa, bbb, ccc, X[ 6],  7);
134     III(ccc, ddd, aaa, bbb, X[15],  8);
135     III(bbb, ccc, ddd, aaa, X[ 8], 11);
136     III(aaa, bbb, ccc, ddd, X[ 1], 14);
137     III(ddd, aaa, bbb, ccc, X[10], 14);
138     III(ccc, ddd, aaa, bbb, X[ 3], 12);
139     III(bbb, ccc, ddd, aaa, X[12],  6);
140     HHH(aaa, bbb, ccc, ddd, X[ 6],  9);
141     HHH(ddd, aaa, bbb, ccc, X[11], 13);
142     HHH(ccc, ddd, aaa, bbb, X[ 3], 15);
143     HHH(bbb, ccc, ddd, aaa, X[ 7],  7);
144     HHH(aaa, bbb, ccc, ddd, X[ 0], 12);
145     HHH(ddd, aaa, bbb, ccc, X[13],  8);
146     HHH(ccc, ddd, aaa, bbb, X[ 5],  9);
147     HHH(bbb, ccc, ddd, aaa, X[10], 11);
148     HHH(aaa, bbb, ccc, ddd, X[14],  7);
149     HHH(ddd, aaa, bbb, ccc, X[15],  7);
150     HHH(ccc, ddd, aaa, bbb, X[ 8], 12);
151     HHH(bbb, ccc, ddd, aaa, X[12],  7);
152     HHH(aaa, bbb, ccc, ddd, X[ 4],  6);
153     HHH(ddd, aaa, bbb, ccc, X[ 9], 15);
154     HHH(ccc, ddd, aaa, bbb, X[ 1], 13);
155     HHH(bbb, ccc, ddd, aaa, X[ 2], 11);
156     GGG(aaa, bbb, ccc, ddd, X[15],  9);
157     GGG(ddd, aaa, bbb, ccc, X[ 5],  7);
158     GGG(ccc, ddd, aaa, bbb, X[ 1], 15);
159     GGG(bbb, ccc, ddd, aaa, X[ 3], 11);
160     GGG(aaa, bbb, ccc, ddd, X[ 7],  8);
161     GGG(ddd, aaa, bbb, ccc, X[14],  6);
162     GGG(ccc, ddd, aaa, bbb, X[ 6],  6);
163     GGG(bbb, ccc, ddd, aaa, X[ 9], 14);
164     GGG(aaa, bbb, ccc, ddd, X[11], 12);
165     GGG(ddd, aaa, bbb, ccc, X[ 8], 13);
166     GGG(ccc, ddd, aaa, bbb, X[12],  5);
167     GGG(bbb, ccc, ddd, aaa, X[ 2], 14);
168     GGG(aaa, bbb, ccc, ddd, X[10], 13);
169     GGG(ddd, aaa, bbb, ccc, X[ 0], 13);
170     GGG(ccc, ddd, aaa, bbb, X[ 4],  7);
171     GGG(bbb, ccc, ddd, aaa, X[13],  5);
172     FFF(aaa, bbb, ccc, ddd, X[ 8], 15);
173     FFF(ddd, aaa, bbb, ccc, X[ 6],  5);
174     FFF(ccc, ddd, aaa, bbb, X[ 4],  8);
175     FFF(bbb, ccc, ddd, aaa, X[ 1], 11);
176     FFF(aaa, bbb, ccc, ddd, X[ 3], 14);
177     FFF(ddd, aaa, bbb, ccc, X[11], 14);
178     FFF(ccc, ddd, aaa, bbb, X[15],  6);
179     FFF(bbb, ccc, ddd, aaa, X[ 0], 14);
180     FFF(aaa, bbb, ccc, ddd, X[ 5],  6);
181     FFF(ddd, aaa, bbb, ccc, X[12],  9);
182     FFF(ccc, ddd, aaa, bbb, X[ 2], 12);
183     FFF(bbb, ccc, ddd, aaa, X[13],  9);
184     FFF(aaa, bbb, ccc, ddd, X[ 9], 12);
185     FFF(ddd, aaa, bbb, ccc, X[ 7],  5);
186     FFF(ccc, ddd, aaa, bbb, X[10], 15);
187     FFF(bbb, ccc, ddd, aaa, X[14],  8);
188     ddd += cc + md->rmd128.state[1];               &bsol;* final result for MDbuf[0] */
</pre></code></div>
                <div class="column column_space"><pre><code>250      st->s09 = r3;
251      st->s08 = r1;
252      st->s07 = r0;
253      st->s06 = r2;
254      FSS(48, S4, 3, 1, 0, 2, 4, 1, 4, 3, 2);
255      FSS(52, S5, 1, 4, 3, 2, 0, 4, 2, 1, 3);
256      FSS(56, S6, 4, 2, 1, 3, 0, 4, 2, 0, 1);
257      FSS(60, S7, 4, 2, 0, 1, 3, 3, 1, 2, 4);
258      FSS(64, S0, 3, 1, 2, 4, 0, 1, 0, 2, 3);
259      FSS(68, S1, 1, 0, 2, 3, 4, 2, 1, 3, 0);
260      st->r1  = r2;
261      st->s04 = r1;
262      st->r2  = r3;
263      st->s05 = r0;
264      FSS(72, S2, 2, 1, 3, 0, 4, 3, 0, 1, 4);
265      FSS(76, S3, 3, 0, 1, 4, 2, 0, 1, 4, 2);
266      FSS(80, S4, 0, 1, 4, 2, 3, 1, 3, 0, 2);
267      FSS(84, S5, 1, 3, 0, 2, 4, 3, 2, 1, 0);
268      FSS(88, S6, 3, 2, 1, 0, 4, 3, 2, 4, 1);
269      FSF(92, S7, 3, 2, 4, 1, 0, 0, 1, 2, 3);
270      st->s03 = r0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    