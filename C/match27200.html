<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for unary.c &amp; global_balance.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for unary.c &amp; global_balance.c
      </h3>
<h1 align="center">
        2.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>unary.c (47.36842%)<th>global_balance.c (1.4742014%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(65-87)<td><a href="#" name="0">(1896-1916)</a><td align="center"><font color="#ff0000">18</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>unary.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;math.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include "unary.h"
9 G_DEFINE_ABSTRACT_TYPE( VipsUnary, vips_unary, VIPS_TYPE_ARITHMETIC );
10 static int
11 vips_unary_build( VipsObject *object )
12 {
13 	VipsArithmetic *arithmetic = VIPS_ARITHMETIC( object );
14 	VipsUnary *unary = VIPS_UNARY( object );
15 	arithmetic-&gt;n = 1;
16 	arithmetic-&gt;in = (VipsImage **) vips_object_local_array( object, 1 );
17 	arithmetic-&gt;in[0] = unary-&gt;in;
18 <a name="0"></a>	if( arithmetic-&gt;in[0] )
19 		g_object_ref( arithmetic-&gt;in[0] );
20 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if( VIPS_OBJECT_CLASS( vips_unary_parent_class )-&gt;build( object ) )
21 		return( -1 );
22 	return( 0 );
23 }
24 static void
25 vips_unary_class_init( VipsUnaryClass *class )
26 {
27 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
28 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
29 	gobject_class-&gt;set_property = vips_object_set_property;
30 	gobject_class-&gt;get_property = vips_object_get_property;
31 	vobject_class-&gt;nickname = "unary";
32 	vobject_class-&gt;description = _( "unary operations" );
33 	vobject_class-&gt;build = vips_unary_build;
34 	VIPS_ARG_IMAGE( class, "in", 1, </b></font>
35 		_( "Input" ), 
36 		_( "Input image" ),
37 		VIPS_ARGUMENT_REQUIRED_INPUT,
38 		G_STRUCT_OFFSET( VipsUnary, in ) );
39 }
40 static void
41 vips_unary_init( VipsUnary *unary )
42 {
43 }
44 int
45 vips_unary_copy( VipsUnary *unary )
46 {
47 	VipsArithmetic *arithmetic = VIPS_ARITHMETIC( unary );
48 	g_object_set( unary, "out", vips_image_new(), NULL ); 
49 	return( vips_image_write( unary-&gt;in, arithmetic-&gt;out ) );
50 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>global_balance.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;stdarg.h&gt;
8 #include &lt;math.h&gt;
9 #include &lt;vips/vips.h&gt;
10 #include &lt;vips/transform.h&gt;
11 #include &lt;vips/internal.h&gt;
12 #include "pmosaicing.h"
13 #include "global_balance.h"
14 #define MAX_ITEMS (50)
15 #define TRIVIAL (20 * 20)
16 static int
17 break_items( char *line, char **out )
18 {
19 	int i;
20 	char *p;
21 	for( i = 0; i &lt; MAX_ITEMS; i++ ) {
22 		if( !(p = strchr( line, '&lt;' )) )
23 			break;
24 		out[i] = line = p + 1;
25 		if( !(p = strchr( line, '&gt;' )) ) {
26 			vips_error( "break_files", "%s", _( "no matching '&gt;'" ) );
27 			return( -1 );
28 		}
29 		*p = '\0';
30 		line = p + 1;
31 	}
32 	if( i == MAX_ITEMS ) {
33 		vips_error( "break_files", "%s", _( "too many items" ) );
34 		return( -1 );
35 	}
36 	return( i );
37 }
38 VipsImage *
39 vips__global_open_image( SymbolTable *st, char *name )
40 {
41 	char *basename;
42 	VipsImage *image;
43 	if( !(image = vips_image_new_from_file( name, NULL ))) {
44 		basename = g_path_get_basename( name );
45 		if( !(image = vips_image_new_from_file( basename, NULL ))) {
46 			g_free( basename );
47 			return( NULL );
48 		}
49 		g_free( basename );
50 	}
51 	vips_object_local( st-&gt;im, image );
52 	return( image );
53 }
54 static void
55 junk_node( VipsImage *image, JoinNode *node )
56 {
57 	VIPS_FREEF( g_slist_free, node-&gt;overlaps );
58 }
59 static int
60 hash( char *n )
61 {
62 	int i;
63 	int r = 0;
64 	int l = strlen( n );
65 	for( i = 0; i &lt; l; i++ )
66 		r = ((r + n[i]) * 43) &amp; 0xffffff;
67 	return( r % SYM_TAB_SIZE );
68 }
69 static JoinNode *
70 build_node( SymbolTable *st, char *name )
71 {
72 	JoinNode *node = VIPS_NEW( st-&gt;im, JoinNode );
73 	int n = hash( name );
74 	if( !node || !(node-&gt;name = 
75 		vips_strdup( VIPS_OBJECT( st-&gt;im ), name )) )
76 		return( NULL );
77 	node-&gt;type = JOIN_LEAF;
78 	node-&gt;dirty = 0;
79 	node-&gt;mwidth = -2;
80 	node-&gt;st = st;
81 	vips__transform_init( &amp;node-&gt;cumtrn );
82 	node-&gt;trnim = NULL;
83 	node-&gt;arg1 = NULL;
84 	node-&gt;arg2 = NULL;
85 	node-&gt;overlaps = NULL;
86 	node-&gt;im = NULL;
87 	node-&gt;index = 0;
88 	g_signal_connect( st-&gt;im, "close",
89 		G_CALLBACK( junk_node ), node );
90 	if( (node-&gt;im = vips__global_open_image( st, name )) ) {
91 		node-&gt;cumtrn.oarea.width = node-&gt;im-&gt;Xsize;
92 		node-&gt;cumtrn.oarea.height = node-&gt;im-&gt;Ysize;
93 	}
94 	else {
95 		vips_error_clear();
96 	}
97 	st-&gt;table[n] = g_slist_prepend( st-&gt;table[n], node );
98 	return( node );
99 }
100 static OverlapInfo *
101 build_overlap( JoinNode *node, JoinNode *other, VipsRect *overlap )
102 {
103 	OverlapInfo *lap = VIPS_NEW( node-&gt;st-&gt;im, OverlapInfo );
104 	if( !lap )
105 		return( NULL );
106 	lap-&gt;node = node;
107 	lap-&gt;other = other;
108 	lap-&gt;overlap = *overlap;
109 	lap-&gt;nstats = NULL;
110 	lap-&gt;ostats = NULL;
111 	node-&gt;overlaps = g_slist_prepend( node-&gt;overlaps, lap );
112 	node-&gt;st-&gt;novl++;
113 	return( lap );
114 }
115 static void
116 overlap_destroy( OverlapInfo *lap )
117 {
118 	JoinNode *node = lap-&gt;node;
119 	node-&gt;overlaps = g_slist_remove( node-&gt;overlaps, lap );
120 	g_assert( node-&gt;st-&gt;novl &gt; 0 );
121 	node-&gt;st-&gt;novl--;
122 }
123 static void
124 junk_table( VipsImage *image, SymbolTable *st ) {
125 	int i;
126 	for( i = 0; i &lt; st-&gt;sz; i++ )
127 		VIPS_FREEF( g_slist_free, st-&gt;table[i] );
128 }
129 SymbolTable *
130 vips__build_symtab( VipsImage *out, int sz )
131 {
132 	SymbolTable *st = VIPS_NEW( out, SymbolTable );
133 	int i;
134 	if( !st ||
135 		!(st-&gt;table = VIPS_ARRAY( out, sz, GSList * )) )
136 		return( NULL );
137 	st-&gt;sz = sz;
138 	st-&gt;im = out;
139 	st-&gt;novl = 0;
140 	st-&gt;nim = 0;
141 	st-&gt;njoin = 0;
142 	st-&gt;root = NULL;
143 	st-&gt;leaf = NULL;
144 	st-&gt;fac = NULL;
145 	g_signal_connect( out, "close", 
146 		G_CALLBACK( junk_table ), st );
147 	for( i = 0; i &lt; sz; i++ )
148 		st-&gt;table[i] = NULL;
149 	return( st );
150 }
151 static JoinNode *
152 test_name( JoinNode *node, char *name, void *b )
153 {
154 	if( strcmp( node-&gt;name, name ) == 0 )
155 		return( node );
156 	else
157 		return( NULL );
158 }
159 static JoinNode *
160 find_node( SymbolTable *st, char *name ) 
161 {
162 	return( vips_slist_map2( st-&gt;table[hash( name )],
163 		(VipsSListMap2Fn) test_name, name, NULL ) );
164 }
165 static JoinNode *
166 add_node( SymbolTable *st, char *name )
167 {
168 	JoinNode *node;
169 	if( !(node = find_node( st, name )) &amp;&amp; 
170 		!(node = build_node( st, name )) )
171 		return( NULL );
172 	return( node );
173 }
174 void *
175 vips__map_table( SymbolTable *st, VipsSListMap2Fn fn, void *a, void *b )
176 {
177 	int i;
178 	void *r;
179 	for( i = 0; i &lt; st-&gt;sz; i++ )
180 		if( (r = vips_slist_map2( st-&gt;table[i], fn, a, b )) )
181 			return( r );
182 	return( NULL );
183 }
184 static void *
185 set_dirty( JoinNode *node, int state, void *b )
186 {	
187 	node-&gt;dirty = state;
188 	return( NULL );
189 }
190 static void
191 clean_table( SymbolTable *st )
192 {
193 	(void) vips__map_table( st, 
194 		(VipsSListMap2Fn) set_dirty, (void *) 0, NULL );
195 }
196 static void
197 calc_geometry( JoinNode *node )
198 {
199 	VipsRect um;
200 	switch( node-&gt;type ) {
201 	case JOIN_LR:
202 	case JOIN_TB:
203 	case JOIN_LRROTSCALE:
204 	case JOIN_TBROTSCALE:
205 		vips_rect_unionrect( &amp;node-&gt;arg1-&gt;cumtrn.oarea,
206 			&amp;node-&gt;arg2-&gt;cumtrn.oarea, &amp;um );
207 		node-&gt;cumtrn.iarea.left = 0;
208 		node-&gt;cumtrn.iarea.top = 0;
209 		node-&gt;cumtrn.iarea.width = um.width;
210 		node-&gt;cumtrn.iarea.height = um.height;
211 		vips__transform_set_area( &amp;node-&gt;cumtrn );
212 		break;
213 	case JOIN_CP:
214 		node-&gt;cumtrn = node-&gt;arg1-&gt;cumtrn;
215 		break;
216 	case JOIN_LEAF:
217 		if( node-&gt;im ) {
218 			node-&gt;cumtrn.iarea.left = 0;
219 			node-&gt;cumtrn.iarea.top = 0;
220 			node-&gt;cumtrn.iarea.width = node-&gt;im-&gt;Xsize;
221 			node-&gt;cumtrn.iarea.height = node-&gt;im-&gt;Ysize;
222 			vips__transform_set_area( &amp;node-&gt;cumtrn );
223 		}
224 		break;
225 	default:
226 		vips_error_exit( "internal error #98356" );
227 	}
228 }
229 static int
230 propagate_transform( JoinNode *node, VipsTransformation *trn )
231 {
232 	if( !node )
233 		return( 0 );
234 	if( node-&gt;dirty &amp;&amp; node-&gt;arg1 &amp;&amp; node-&gt;arg2 ) {
235 		vips_error( "vips_global_balance", 
236 			"%s", _( "circularity detected" ) );
237 		return( -1 );
238 	}
239 	node-&gt;dirty = 1;
240 	if( propagate_transform( node-&gt;arg1, trn ) ||
241 		propagate_transform( node-&gt;arg2, trn ) )
242 		return( -1 );
243 	vips__transform_add( &amp;node-&gt;cumtrn, trn, &amp;node-&gt;cumtrn );
244 	calc_geometry( node );
245 	return( 0 );
246 }
247 static int
248 make_join( SymbolTable *st, JoinType type, 
249 	JoinNode *arg1, JoinNode *arg2, JoinNode *out, 
250 	double a, double b, double dx, double dy, int mwidth )
251 {
252 	VipsTransformation trn;
253 	if( out-&gt;type != JOIN_LEAF ) {
254 		vips_error( "vips_global_balance", 
255 			_( "image \"%s\" used twice as output" ), out-&gt;name );
256 		return( -1 );
257 	}
258 	out-&gt;type = type;
259 	out-&gt;mwidth = mwidth;
260 	out-&gt;a = a;
261 	out-&gt;b = b;
262 	out-&gt;dx = dx;
263 	out-&gt;dy = dy;
264 	out-&gt;arg1 = arg1;
265 	out-&gt;arg2 = arg2;
266 	out-&gt;thistrn.a = a;
267 	out-&gt;thistrn.b = -b;
268 	out-&gt;thistrn.c = b;
269 	out-&gt;thistrn.d = a;
270 	out-&gt;thistrn.idx = 0;
271 	out-&gt;thistrn.idy = 0;
272 	out-&gt;thistrn.odx = dx;
273 	out-&gt;thistrn.ody = dy;
274 	clean_table( st );
275 	if( propagate_transform( arg2, &amp;out-&gt;thistrn ) )
276 		return( -1 );
277 	calc_geometry( out );
278 	trn.a = 1.0;
279 	trn.b = 0.0;
280 	trn.c = 0.0;
281 	trn.d = 1.0;
282 	trn.idx = 0;
283 	trn.idy = 0;
284 	trn.odx = -out-&gt;cumtrn.oarea.left;
285 	trn.ody = -out-&gt;cumtrn.oarea.top;
286 	clean_table( st );
287 	if( propagate_transform( out, &amp;trn ) )
288 		return( -1 );
289 	return( 0 );
290 }
291 static int
292 make_copy( SymbolTable *st, JoinNode *before, JoinNode *after )
293 {
294 	if( after-&gt;type != JOIN_LEAF ) {
295 		vips_error( "vips_global_balance", 
296 			_( "image \"%s\" used twice as output" ), after-&gt;name );
297 		return( -1 );
298 	}
299 	after-&gt;type = JOIN_CP;
300 	after-&gt;arg1 = before;
301 	after-&gt;arg2 = NULL;
302 	calc_geometry( after ); 
303 	return( 0 );
304 }
305 static int
306 process_line( SymbolTable *st, const char *text )
307 {
308 	char line[1024];
309 #ifdef DEBUG
310 	printf( "read: %s\n", text );
311 	vips_strncpy( line, text, 1024 );
312 	if( vips_isprefix( "#LRJOIN ", line ) ||
313 		vips_isprefix( "#TBJOIN ", line ) ) {
314 		char *item[MAX_ITEMS];
315 		int nitems;
316 		JoinType type;
317 		JoinNode *arg1, *arg2, *join;
318 		int dx, dy, mwidth;
319 		if( (nitems = break_items( line, item )) &lt; 0 )
320 			return( -1 );
321 		if( nitems != 5 &amp;&amp; nitems != 6 ) {
322 			vips_error( "global_balance", 
323 				"%s", _( "bad number of args in join line" ) );
324 			return( -1 );
325 		}
326 		if( !(arg1 = add_node( st, item[0] )) ||
327 			!(arg2 = add_node( st, item[1] )) ||
328 			!(join = add_node( st, item[2] )) )
329 			return( -1 );
330 		dx = atoi( item[3] );
331 		dy = atoi( item[4] );
332 		if( nitems == 6 ) 
333 			mwidth = atoi( item[5] );
334 		else
335 			mwidth = -1;
336 		if( vips_isprefix( "#LRJOIN ", line ) )
337 			type = JOIN_LR;
338 		else
339 			type = JOIN_TB;
340 		if( make_join( st, type, arg1, arg2, 
341 			join, 1.0, 0.0, dx, dy, mwidth ) )
342 			return( -1 );
343 	}
344 	else if( vips_isprefix( "#LRROTSCALE ", line ) ||
345 		vips_isprefix( "#TBROTSCALE ", line ) ) {
346 		char *item[MAX_ITEMS];
347 		int nitems;
348 		JoinType type;
349 		JoinNode *arg1, *arg2, *join;
350 		double a, b, dx, dy;
351 		int mwidth;
352 		if( (nitems = break_items( line, item )) &lt; 0 )
353 			return( -1 );
354 		if( nitems != 7 &amp;&amp; nitems != 8 ) {
355 			vips_error( "global_balance", 
356 				"%s", _( "bad number of args in join1 line" ) );
357 			return( -1 );
358 		}
359 		if( !(arg1 = add_node( st, item[0] )) ||
360 			!(arg2 = add_node( st, item[1] )) ||
361 			!(join = add_node( st, item[2] )) )
362 			return( -1 );
363 		a = g_ascii_strtod( item[3], NULL );
364 		b = g_ascii_strtod( item[4], NULL );
365 		dx = g_ascii_strtod( item[5], NULL );
366 		dy = g_ascii_strtod( item[6], NULL );
367 		if( nitems == 8 )
368 			mwidth = atoi( item[7] );
369 		else
370 			mwidth = -1;
371 		if( vips_isprefix( "#LRROTSCALE ", line ) )
372 			type = JOIN_LRROTSCALE;
373 		else
374 			type = JOIN_TBROTSCALE;
375 		if( make_join( st, type, arg1, arg2, 
376 			join, a, b, dx, dy, mwidth ) )
377 			return( -1 );
378 	}
379 	else if( vips_isprefix( "copy ", line ) ) {
380 		char *item[MAX_ITEMS];
381 		int nitems;
382 		JoinNode *before, *after;
383 		if( (nitems = break_items( line, item )) &lt; 0 )
384 			return( -1 );
385 		if( nitems != 2 ) {
386 			vips_error( "global_balance", 
387 				"%s", _( "bad number of args in copy line" ) );
388 			return( -1 );
389 		}
390 		if( !(before = add_node( st, item[0] )) ||
391 			!(after = add_node( st, item[1] )) ||
392 			make_copy( st, before, after ) )
393 			return( -1 );
394 	}
395 	return( 0 );
396 }
397 static void *
398 set_referenced( JoinNode *node, void *a, void *b )
399 {
400 	if( node-&gt;arg1 )
401 		node-&gt;arg1-&gt;dirty = 1;
402 	if( node-&gt;arg2 )
403 		node-&gt;arg2-&gt;dirty = 1;
404 	return( NULL );
405 }
406 static void *
407 is_root( JoinNode *node, void *a, void *b )
408 {
409 	if( !node-&gt;dirty )
410 		return( (void *) node );
411 	else
412 		return( NULL );
413 }
414 static JoinNode *
415 find_root( SymbolTable *st )
416 {
417 	JoinNode *root;
418 	clean_table( st );
419 	vips__map_table( st, (VipsSListMap2Fn) set_referenced, NULL, NULL );
420 	root = (JoinNode *) vips__map_table( st, 
421 		(VipsSListMap2Fn) is_root, NULL, NULL );
422 	if( !root ) {
423 		vips_error( "vips_global_balance", 
424 			"%s", _( "mosaic root not found in desc file\n"
425 			"is this really a mosaiced image?" ) );
426 		return( NULL );
427 	}
428 	root-&gt;dirty = 1;
429 	if( vips__map_table( st, (VipsSListMap2Fn) is_root, NULL, NULL ) ) {
430 		vips_error( "vips_global_balance", 
431 			"%s", _( "more than one root" ) );
432 		return( NULL );
433 	}
434 	return( root );
435 }
436 int
437 vips__parse_desc( SymbolTable *st, VipsImage *in )
438 {
439 	GSList *p;
440 	for( p = in-&gt;history_list; p; p = p-&gt;next ) {
441 		GValue *value = (GValue *) p-&gt;data;
442 		g_assert( G_VALUE_TYPE( value ) == VIPS_TYPE_REF_STRING );
443 		if( process_line( st, vips_value_get_ref_string( value, NULL ) ) )
444 			return( -1 );
445 	}
446 	if( !(st-&gt;root = find_root( st )) )
447 		return( -1 );
448 	return( 0 );
449 }
450 static void *
451 count_leaves( JoinNode *node, void *a, void *b )
452 {
453 	if( node-&gt;type == JOIN_LEAF ) {
454 		node-&gt;index = node-&gt;st-&gt;nim;
455 		node-&gt;st-&gt;nim++;
456 	}
457 	return( NULL );
458 }
459 #ifdef DEBUG
460 static void
461 print_node( JoinNode *node )
462 {
463 	char *basename = g_path_get_basename( node-&gt;name );
464 	printf( "%s, position %dx%d, size %dx%d, index %d\n",
465 		basename,
466 		node-&gt;cumtrn.oarea.left, node-&gt;cumtrn.oarea.top,
467 		node-&gt;cumtrn.oarea.width, node-&gt;cumtrn.oarea.height,
468 		node-&gt;index );
469 	g_free( basename );
470 }
471 #ifdef DEBUG
472 static void *
473 print_leaf( JoinNode *node, void *a, void *b )
474 {
475 	if( node-&gt;type == JOIN_LEAF ) 
476 		print_node( node );
477 	return( NULL );
478 }
479 static void *
480 count_joins( JoinNode *node, void *a, void *b )
481 {
482 	if( node-&gt;type == JOIN_TB ||
483 		node-&gt;type == JOIN_LR ||
484 		node-&gt;type == JOIN_LRROTSCALE ||
485 		node-&gt;type == JOIN_TBROTSCALE )
486 		node-&gt;st-&gt;njoin++;
487 	return( NULL );
488 }
489 #ifdef DEBUG
490 static void
491 spc( int n )
492 {
493 	int i;
494 	for( i = 0; i &lt; n; i++ )
495 		printf( " " );
496 }
497 #ifdef DEBUG
498 static char *
499 JoinType2char( JoinType type )
500 {
501 	switch( type ) {
502 	case JOIN_LR: 		return( "JOIN_LR" );
503 	case JOIN_TB: 		return( "JOIN_TB" );
504 	case JOIN_LRROTSCALE: 	return( "JOIN_LRROTSCALE" );
505 	case JOIN_TBROTSCALE: 	return( "JOIN_TBROTSCALE" );
506 	case JOIN_CP: 		return( "JOIN_CP" );
507 	case JOIN_LEAF: 	return( "JOIN_LEAF" );
508 	default:
509 		vips_error_exit( "internal error #9275" );
510 		return( NULL );
511 	}
512 }
513 #ifdef DEBUG
514 static void *
515 print_joins( JoinNode *node, int indent )
516 {
517 	char *basename = g_path_get_basename( node-&gt;name );
518 	switch( node-&gt;type ) {
519 	case JOIN_TB:
520 	case JOIN_LR:
521 	case JOIN_TBROTSCALE:
522 	case JOIN_LRROTSCALE:
523 		spc( indent );
524 		printf( "%s to make %s, size %dx%d, pos. %dx%d, of:\n", 
525 			JoinType2char( node-&gt;type ), 
526 			basename,
527 			node-&gt;cumtrn.oarea.width, node-&gt;cumtrn.oarea.height,
528 			node-&gt;cumtrn.oarea.left, node-&gt;cumtrn.oarea.top );
529 		spc( indent );
530 		printf( "reference:\n" );
531 		print_joins( node-&gt;arg1, indent + 2 );
532 		spc( indent );
533 		printf( "secondary:\n" );
534 		print_joins( node-&gt;arg2, indent + 2 );
535 		break;
536 	case JOIN_CP:
537 		spc( indent );
538 		printf( "copy to make %s of:\n", basename );
539 		print_joins( node-&gt;arg1, indent + 2 );
540 		break;
541 	case JOIN_LEAF:
542 		spc( indent );
543 		printf( "input image %s\n", basename );
544 		break;
545 	}
546 	g_free( basename );
547 	return( NULL );
548 }
549 #ifdef DEBUG
550 static void *
551 print_overlap( OverlapInfo *lap, void *a, void *b )
552 {
553 	char *basename_node = g_path_get_basename( lap-&gt;node-&gt;name );
554 	char *basename_other = g_path_get_basename( lap-&gt;other-&gt;name );
555 	printf( "-&gt; %s overlaps with %s; (this, other) = (%.4G, %.4G)\n",
556 		basename_node,
557 		basename_other,
558 		*VIPS_MATRIX( lap-&gt;nstats, 4, 0 ),
559 		*VIPS_MATRIX( lap-&gt;ostats, 4, 0 ) );
560 	g_free( basename_node );
561 	g_free( basename_other );
562 	return( NULL );
563 }
564 #ifdef DEBUG
565 static void *
566 print_overlaps( JoinNode *node, void *a, void *b )
567 {
568 	char *basename;
569 	if( node-&gt;type == JOIN_LEAF &amp;&amp; g_slist_length( node-&gt;overlaps ) &gt; 0 ) {
570 		basename = g_path_get_basename( node-&gt;name );
571 		printf( "overlap of %s with:\n", basename );
572 		g_free( basename );
573 		vips_slist_map2( node-&gt;overlaps, 
574 			(VipsSListMap2Fn) print_overlap, NULL, NULL );
575 	}
576 	return( NULL );
577 }
578 #ifdef DEBUG
579 static void *
580 print_overlap_error( OverlapInfo *lap, double *fac, double *total )
581 {
582 	char *basename_other = g_path_get_basename( lap-&gt;other-&gt;name );
583 	double na = *VIPS_MATRIX( lap-&gt;nstats, 4, 0 );
584 	double oa = *VIPS_MATRIX( lap-&gt;ostats, 4, 0 );
585 	double err;
586 	if( fac ) {
587 		na *= fac[lap-&gt;node-&gt;index];
588 		oa *= fac[lap-&gt;other-&gt;index];
589 	}
590 	err = na - oa;
591 	printf( "-&gt; file %s, error = %g\n",
592 		basename_other, err );
593 	*total += err * err;
594 	g_free( basename_other );
595 	return( NULL );
596 }
597 #ifdef DEBUG
598 static void *
599 print_overlap_errors( JoinNode *node, double *fac, double *total )
600 {
601 	char *basename;
602 	if( node-&gt;type == JOIN_LEAF &amp;&amp; g_slist_length( node-&gt;overlaps ) &gt; 0 ) {
603 		basename = g_path_get_basename( node-&gt;name );
604 		printf( "overlap of %s (index %d) with:\n", basename, 
605 			node-&gt;index );
606 		g_free( basename );
607 		vips_slist_map2( node-&gt;overlaps, 
608 			(VipsSListMap2Fn) print_overlap_error, fac, total );
609 	}
610 	return( NULL );
611 }
612 static int
613 extract_rect( VipsImage *in, VipsImage **out, VipsRect *r )
614 {
615 	return( vips_extract_area( in, out, 
616 		r-&gt;left, r-&gt;top, r-&gt;width, r-&gt;height, NULL ) );
617 }
618 static int
619 make_overlap_mask( VipsImage *mem, 
620 	VipsImage *ref, VipsImage *sec, VipsImage **mask, 
621 	VipsRect *rarea, VipsRect *sarea )
622 {
623 	VipsImage **t = (VipsImage **) 
624 		vips_object_local_array( VIPS_OBJECT( mem ), 6 );
625 	if( extract_rect( ref, &amp;t[0], rarea ) ||
626 		extract_rect( sec, &amp;t[1], sarea ) ||
627 		vips_extract_band( t[0], &amp;t[2], 0, NULL ) ||
628 		vips_extract_band( t[1], &amp;t[3], 0, NULL ) ||
629 		vips_notequal_const1( t[2], &amp;t[4], 0.0, NULL ) ||
630 		vips_notequal_const1( t[3], &amp;t[5], 0.0, NULL ) ||
631 		vips_andimage( t[4], t[5], mask, NULL ) ) 
632 		return( -1 );
633 	return( 0 );
634 }
635 static int
636 count_nonzero( VipsImage *in, gint64 *count )
637 {
638 	double avg;
639 	if( vips_avg( in, &amp;avg, NULL ) )
640 		return( -1 );
641 	*count = (avg * VIPS_IMAGE_N_PELS( in )) / 255.0;
642 	return( 0 );
643 }
644 static VipsImage *
645 find_image_stats( VipsImage *mem, 
646 	VipsImage *in, VipsImage *mask, VipsRect *area )
647 {
648 	VipsImage **t = (VipsImage **) 
649 		vips_object_local_array( VIPS_OBJECT( mem ), 5 );
650 	gint64 count;
651 	if( extract_rect( in, &amp;t[0], area ) ||
652 		vips_black( &amp;t[1], t[0]-&gt;Xsize, t[0]-&gt;Ysize, 
653 			"bands", t[0]-&gt;Bands, 
654 			NULL ) ||
655 		vips_cast( t[1], &amp;t[2], t[0]-&gt;BandFmt, NULL ) ||
656 		vips_ifthenelse( mask, t[0], t[2], &amp;t[3], NULL ) )
657 		return( NULL );
658 	if( vips_stats( t[3], &amp;t[4], NULL ) )
659 		return( NULL );
660 	if( count_nonzero( mask, &amp;count ) )
661 		return( NULL );
662 	*VIPS_MATRIX( t[4], 4, 0 ) *= 
663 		(double) count / VIPS_IMAGE_N_PELS( mask );
664 	*VIPS_MATRIX( t[4], 5, 0 )  = count;
665 #ifdef DEBUG
666 	if( count == 0 )
667 		g_warning( "global_balance %s", _( "empty overlap!" ) );
668 	return( t[4] );
669 }
670 static int
671 find_overlap_stats( OverlapInfo *lap )
672 {
673 	VipsImage *mem = lap-&gt;node-&gt;st-&gt;im;
674 	VipsImage **t = (VipsImage **) 
675 		vips_object_local_array( VIPS_OBJECT( mem ), 1 );
676 	VipsRect rarea, sarea;
677 	rarea = lap-&gt;overlap;
678 	rarea.left -= lap-&gt;node-&gt;cumtrn.oarea.left;
679 	rarea.top -= lap-&gt;node-&gt;cumtrn.oarea.top;
680 	sarea = lap-&gt;overlap;
681 	sarea.left -= lap-&gt;other-&gt;cumtrn.oarea.left;
682 	sarea.top -= lap-&gt;other-&gt;cumtrn.oarea.top;
683 	if( make_overlap_mask( mem, 
684 		lap-&gt;node-&gt;trnim, lap-&gt;other-&gt;trnim, &amp;t[0], &amp;rarea, &amp;sarea ) )
685 		return( -1 );
686 	if( !(lap-&gt;nstats = find_image_stats( mem, 
687 		lap-&gt;node-&gt;trnim, t[0], &amp;rarea )) )
688 		return( -1 );
689 	if( !(lap-&gt;ostats = find_image_stats( mem, 
690 		lap-&gt;other-&gt;trnim, t[0], &amp;sarea )) )
691 		return( -1 );
692 	return( 0 );
693 }
694 static void *
695 overlap_eq( OverlapInfo *this, JoinNode *node, void *b )
696 {
697 	if( this-&gt;other == node )
698 		return( this );
699 	else
700 		return( NULL );
701 }
702 static void *
703 test_overlap( JoinNode *other, JoinNode *node, void *b )
704 {
705 	VipsRect overlap;
706 	OverlapInfo *lap;
707 	if( other-&gt;type != JOIN_LEAF || node == other ) 
708 		return( NULL );
709 	vips_rect_intersectrect( &amp;node-&gt;cumtrn.oarea, &amp;other-&gt;cumtrn.oarea, 
710 		&amp;overlap );
711 	if( vips_rect_isempty( &amp;overlap ) ) 
712 		return( NULL );
713 	if( overlap.width * overlap.height &lt; TRIVIAL )
714 		return( NULL );
715 	if( vips_slist_map2( other-&gt;overlaps, 
716 		(VipsSListMap2Fn) overlap_eq, node, NULL ) )
717 		return( NULL );
718 	if( !(lap = build_overlap( node, other, &amp;overlap )) )
719 		return( node );
720 	if( find_overlap_stats( lap ) ) 
721 		return( node );
722 	if( *VIPS_MATRIX( lap-&gt;nstats, 5, 0 ) &lt; TRIVIAL ||
723 		*VIPS_MATRIX( lap-&gt;ostats, 5, 0 ) &lt; TRIVIAL ) {
724 #ifdef DEBUG
725 		printf( "trivial overlap ... junking\n" );
726 		printf( "nstats count = %g, ostats count = %g\n",
727 			*VIPS_MATRIX( lap-&gt;nstats, 5, 0 ), *VIPS_MATRIX( lap-&gt;ostats, 5, 0 ) );
728 		print_overlap( lap, NULL, NULL );
729 		overlap_destroy( lap );
730 	}
731 	return( NULL );
732 }
733 static void *
734 find_overlaps( JoinNode *node, SymbolTable *st, void *b )
735 {
736 	if( node-&gt;type == JOIN_LEAF ) {
737 		if( !node-&gt;im ) {
738 			vips_error( "vips_global_balance", 
739 				_( "unable to open \"%s\"" ), node-&gt;name );
740 			return( node );
741 		}
742 		if( !node-&gt;trnim ) 
743 			vips_error_exit( "global_balance: sanity failure #9834" );
744 		return( vips__map_table( st, 
745 			(VipsSListMap2Fn) test_overlap, node, NULL ) );
746 	}
747 	return( NULL );
748 }
749 typedef struct {
750 	SymbolTable *st;			JoinNode *leaf;				VipsImage *K;				VipsImage *M;				int row;			} MatrixBundle;
751 static void *
752 add_nominated( OverlapInfo *ovl, MatrixBundle *bun, double *gamma )
753 {
754 	double ns = pow( *VIPS_MATRIX( ovl-&gt;nstats, 4, 0 ), 1.0 / (*gamma) );
755 	double os = pow( *VIPS_MATRIX( ovl-&gt;ostats, 4, 0 ), 1.0 / (*gamma) );
756 	*VIPS_MATRIX( bun-&gt;K, 0, bun-&gt;row ) = ns;
757 	*VIPS_MATRIX( bun-&gt;M, ovl-&gt;other-&gt;index - 1, bun-&gt;row ) = os;
758 	bun-&gt;row++;
759 	return( NULL );
760 }
761 static void *
762 add_other( OverlapInfo *ovl, MatrixBundle *bun, double *gamma )
763 {
764 	double ns = -pow( *VIPS_MATRIX( ovl-&gt;nstats, 4, 0 ), 1.0 / (*gamma) );
765 	double os = pow( *VIPS_MATRIX( ovl-&gt;ostats, 4, 0 ), 1.0 / (*gamma) );
766 	*VIPS_MATRIX( bun-&gt;M, ovl-&gt;node-&gt;index - 1, bun-&gt;row ) = ns;
767 	*VIPS_MATRIX( bun-&gt;M, ovl-&gt;other-&gt;index - 1, bun-&gt;row ) = os;
768 	bun-&gt;row++;
769 	return( NULL );
770 }
771 static void *
772 add_row( JoinNode *node, MatrixBundle *bun, double *gamma )
773 {
774 	if( node == bun-&gt;leaf )
775 		vips_slist_map2( node-&gt;overlaps, 
776 			(VipsSListMap2Fn) add_nominated, bun, gamma );
777 	else
778 		vips_slist_map2( node-&gt;overlaps, 
779 			(VipsSListMap2Fn) add_other, bun, gamma );
780 	return( NULL );
781 }
782 static void
783 fill_matrices( SymbolTable *st, double gamma, VipsImage *K, VipsImage *M )
784 {
785 	MatrixBundle bun;
786 	bun.st = st;
787 	bun.leaf = st-&gt;leaf;
788 	bun.K = K;
789 	bun.M = M;
790 	bun.row = 0;
791 	vips__map_table( st, (VipsSListMap2Fn) add_row, &amp;bun, &amp;gamma );
792 }
793 static void *
794 choose_leaf( JoinNode *node, void *a, void *b )
795 {
796 	if( node-&gt;type == JOIN_LEAF )
797 		return( node );
798 	return( NULL );
799 }
800 static VipsImage *
801 make_mos_image( SymbolTable *st, JoinNode *node, transform_fn tfn, void *a )
802 {
803 	VipsImage *im1, *im2, *out;
804 	switch( node-&gt;type ) {
805 	case JOIN_LR:
806 	case JOIN_TB:
807 		if( !(im1 = make_mos_image( st, node-&gt;arg1, tfn, a )) ||
808 			!(im2 = make_mos_image( st, node-&gt;arg2, tfn, a )) )
809 			return( NULL );
810 		if( vips_merge( im1, im2, &amp;out, 
811 			node-&gt;type == JOIN_LR ? 
812 				VIPS_DIRECTION_HORIZONTAL : 
813 				VIPS_DIRECTION_VERTICAL,
814 			-node-&gt;dx, -node-&gt;dy, 
815 			"mblend", node-&gt;mwidth,
816 			NULL ) )
817 			return( NULL );
818 		vips_object_local( st-&gt;im, out );
819 		vips_image_set_string( out, "mosaic-name", node-&gt;name );
820 		break;
821 	case JOIN_LRROTSCALE:
822 	case JOIN_TBROTSCALE:
823 		if( !(im1 = make_mos_image( st, node-&gt;arg1, tfn, a )) ||
824 			!(im2 = make_mos_image( st, node-&gt;arg2, tfn, a )) )
825 			return( NULL );
826 		out = vips_image_new();
827 		vips_object_local( st-&gt;im, out );
828 		vips_image_set_string( out, "mosaic-name", node-&gt;name );
829 		if( node-&gt;type == JOIN_LRROTSCALE ) {
830 			if( vips__lrmerge1( im1, im2, out, 
831 				node-&gt;a, node-&gt;b, node-&gt;dx, node-&gt;dy,
832 				node-&gt;mwidth ) )
833 				return( NULL );
834 		}
835 		else {
836 			if( vips__tbmerge1( im1, im2, out, 
837 				node-&gt;a, node-&gt;b, node-&gt;dx, node-&gt;dy,
838 				node-&gt;mwidth ) )
839 				return( NULL );
840 		}
841 		break;
842 	case JOIN_LEAF:
843 		if( !(out = tfn( node, a )) )
844 			return( NULL );
845 		break;
846 	case JOIN_CP:
847 		out = make_mos_image( st, node-&gt;arg1, tfn, a );
848 		break;
849 	default:
850 		vips_error_exit( "internal error #982369824375987" );
851 		return( NULL );
852 	}
853 	return( out );
854 }
855 int
856 vips__build_mosaic( SymbolTable *st, VipsImage *out, transform_fn tfn, void *a )
857 {
858 	JoinNode *root = st-&gt;root;
859 	VipsImage *im1, *im2;
860 	VipsImage *x;
861 	switch( root-&gt;type ) {
862 	case JOIN_LR:
863 	case JOIN_TB:
864 		if( !(im1 = make_mos_image( st, root-&gt;arg1, tfn, a )) ||
865 			!(im2 = make_mos_image( st, root-&gt;arg2, tfn, a )) )
866 			return( -1 );
867 		if( vips_merge( im1, im2, &amp;x, 
868 			root-&gt;type == JOIN_LR ? 
869 				VIPS_DIRECTION_HORIZONTAL : 
870 				VIPS_DIRECTION_VERTICAL,
871 			-root-&gt;dx, -root-&gt;dy, 
872 			"mblend", root-&gt;mwidth,
873 			NULL ) )
874 			return( -1 );
875 		if( vips_image_write( x, out ) ) {
876 			g_object_unref( x );
877 			return( -1 );
878 		}
879 		g_object_unref( x );
880 		break;
881 	case JOIN_LRROTSCALE:
882 	case JOIN_TBROTSCALE:
883 		if( !(im1 = make_mos_image( st, root-&gt;arg1, tfn, a )) ||
884 			!(im2 = make_mos_image( st, root-&gt;arg2, tfn, a )) )
885 			return( -1 );
886 		if( root-&gt;type == JOIN_LRROTSCALE ) {
887 			if( vips__lrmerge1( im1, im2, out, 
888 				root-&gt;a, root-&gt;b, root-&gt;dx, root-&gt;dy,
889 				root-&gt;mwidth ) )
890 				return( -1 );
891 		}
892 		else {
893 			if( vips__tbmerge1( im1, im2, out, 
894 				root-&gt;a, root-&gt;b, root-&gt;dx, root-&gt;dy,
895 				root-&gt;mwidth ) )
896 				return( -1 );
897 		}
898 		break;
899 	case JOIN_LEAF:
900 		if( !(im1 = tfn( root, a )) || 
901 			vips_image_write( im1, out ) )
902 			return( -1 );
903 		break;
904 	case JOIN_CP:
905 		if( !(im1 = make_mos_image( st, root-&gt;arg1, tfn, a )) ||
906 			vips_image_write( im1, out ) )
907 			return( -1 );
908 		break;
909 	default:
910 		vips_error_exit( "internal error #982369824375987" );
911 	}
912 	return( 0 );
913 }
914 static int
915 vips__matrixtranspose( VipsImage *in, VipsImage **out )
916 {
917 	int yc, xc;
918 	if( !(*out = vips_image_new_matrix( in-&gt;Ysize, in-&gt;Xsize )) )
919 		return( -1 );
920 	for( yc = 0; yc &lt; (*out)-&gt;Ysize; ++yc )
921 		for( xc = 0; xc &lt; (*out)-&gt;Xsize; ++xc )
922 			*VIPS_MATRIX( *out, xc, yc ) = *VIPS_MATRIX( in, yc, xc );
923 	return( 0 );
924 }
925 static int
926 vips__matrixmultiply( VipsImage *in1, VipsImage *in2, VipsImage **out )
927 {
928 	int xc, yc, col;
929 	double sum;
930 	double *mat, *a, *b;
931 	double *s1, *s2;
932 	if( in1-&gt;Xsize != in2-&gt;Ysize ) {
933 		vips_error( "vips__matrixmultiply", "%s", _( "bad sizes" ) );
934 		return( -1 );
935 	}
936 	if( !(*out = vips_image_new_matrix( in2-&gt;Xsize, in1-&gt;Ysize  )) )
937 		return( -1 );
938 	mat = VIPS_MATRIX( *out, 0, 0 );
939 	s1 = VIPS_MATRIX( in1, 0, 0 );
940 	for( yc = 0; yc &lt; in1-&gt;Ysize; yc++ ) {
941 		s2 = VIPS_MATRIX( in2, 0, 0 );
942 		for( col = 0; col &lt; in2-&gt;Xsize; col++ ) {
943 			a = s1;
944 			b = s2;
945 			for( sum = 0.0, xc = 0; xc &lt; in1-&gt;Xsize; xc++ ) {
946 				sum += *a++ * *b;
947 				b += in2-&gt;Xsize;
948 			}
949 			*mat++ = sum;
950 			s2++;
951 		}
952 		s1 += in1-&gt;Xsize;
953 	}
954 	return( 0 );
955 }
956 static int
957 find_factors( SymbolTable *st, double gamma )
958 {
959 	VipsImage **t = (VipsImage **) 
960 		vips_object_local_array( VIPS_OBJECT( st-&gt;im ), 7 );
961 	double total;
962 	double avg;
963 	int i;
964 	if( !(t[0] = vips_image_new_matrix( 1, st-&gt;novl )) ||
965 		!(t[1] = vips_image_new_matrix( st-&gt;nim - 1, st-&gt;novl )) )
966 		return( -1 );
967 	fill_matrices( st, gamma, t[0], t[1] );
968 #ifdef DEBUG
969 	vips_image_write_to_file( t[0], "K.mat", NULL ); 
970 	vips_image_write_to_file( t[1], "M.mat", NULL );
971 	if( vips__matrixtranspose( t[1], &amp;t[2] ) ||
972 		vips__matrixmultiply( t[2], t[1], &amp;t[3] ) ||
973 		vips_matrixinvert( t[3], &amp;t[4], NULL ) ||
974 		vips__matrixmultiply( t[4], t[2], &amp;t[5] ) ||
975 		vips__matrixmultiply( t[5], t[0], &amp;t[6] ) )
976 		return( -1 );
977 	if( !(st-&gt;fac = VIPS_ARRAY( st-&gt;im, st-&gt;nim, double )) )
978 		return( -1 );
979 	for( i = 0; i &lt; t[6]-&gt;Ysize; i++ )
980 		st-&gt;fac[i + 1] = *VIPS_MATRIX( t[6], 0, i );
981 	st-&gt;fac[0] = 1.0;
982 	total = 0.0;
983 	for( i = 0; i &lt; st-&gt;nim; i++ )
984 		total += st-&gt;fac[i];
985 	avg = total / st-&gt;nim;
986 	for( i = 0; i &lt; st-&gt;nim; i++ )
987 		st-&gt;fac[i] /= avg;
988 #ifdef DEBUG
989 	printf( "debugging output for vips_global_balance():\n" );
990 	for( i = 0; i &lt; st-&gt;nim; i++ )
991 		printf( "balance factor %d = %g\n", i, st-&gt;fac[i] );
992 	total = 0.0;
993 	printf( "Overlap errors:\n" );
994 	vips__map_table( st, 
995 		(VipsSListMap2Fn) print_overlap_errors, NULL, &amp;total );
996 	printf( "RMS error = %g\n", sqrt( total / st-&gt;novl ) );
997 	total = 0.0;
998 	printf( "Overlap errors after adjustment:\n" );
999 	vips__map_table( st, 
1000 		(VipsSListMap2Fn) print_overlap_errors, st-&gt;fac, &amp;total );
1001 	printf( "RMS error = %g\n", sqrt( total / st-&gt;novl ) );
1002 	return( 0 );
1003 }
1004 int
1005 vips__affinei( VipsImage *in, VipsImage *out, VipsTransformation *trn )
1006 {
1007 	VipsImage **t = (VipsImage **)
1008 		vips_object_local_array( VIPS_OBJECT( out ), 2 );
1009 	VipsArea *oarea;
1010 	gboolean repack;
1011 	oarea = VIPS_AREA( vips_array_int_newv( 4,
1012 		trn-&gt;oarea.left, trn-&gt;oarea.top,
1013 		trn-&gt;oarea.width, trn-&gt;oarea.height ) );
1014 	repack = in-&gt;Coding == VIPS_CODING_LABQ;
1015 	if( vips_affine( in, &amp;t[0],
1016 		trn-&gt;a, trn-&gt;b, trn-&gt;c, trn-&gt;d,
1017 		"oarea", oarea,
1018 		"odx", trn-&gt;odx,
1019 		"ody", trn-&gt;ody,
1020 		NULL ) ) {
1021 		vips_area_unref( oarea );
1022 		return( -1 );
1023 	}
1024 	vips_area_unref( oarea );
1025 	in = t[0];
1026 	if( repack ) {
1027 		if (vips_colourspace( in, &amp;t[1],
1028 			VIPS_INTERPRETATION_LABQ, NULL ) )
1029 			return ( -1 );
1030 		in = t[1];
1031 	}
1032 	if( vips_image_write( in, out ) )
1033 		return( -1 );
1034 	return( 0 );
1035 }
1036 static void *
1037 generate_trn_leaves( JoinNode *node, SymbolTable *st, void *b )
1038 {
1039 	if( node-&gt;type == JOIN_LEAF ) {
1040 		if( !node-&gt;im ) {
1041 			vips_error( "vips_global_balance", 
1042 				_( "unable to open \"%s\"" ), node-&gt;name );
1043 			return( node );
1044 		}
1045 		if( node-&gt;trnim ) 
1046 			vips_error_exit( "global_balance: sanity failure #765" );
1047 		if( vips__transform_isidentity( &amp;node-&gt;cumtrn ) )
1048 			node-&gt;trnim = node-&gt;im;
1049 		else {
1050 			node-&gt;trnim = vips_image_new();
1051 			vips_object_local( node-&gt;st-&gt;im, node-&gt;trnim );
1052 			if ( vips__affinei( node-&gt;im, node-&gt;trnim, &amp;node-&gt;cumtrn ) )
1053 				return( node );
1054 		}
1055 	}
1056 	return( NULL );
1057 }
1058 static int
1059 analyse_mosaic( SymbolTable *st, VipsImage *in )
1060 {
1061 	if( vips__parse_desc( st, in ) )
1062 		return( -1 );
1063 #ifdef DEBUG
1064 	printf( "Input files:\n" );
1065 	vips__map_table( st, (VipsSListMap2Fn) print_leaf, NULL, NULL );
1066 	printf( "\nOutput file:\n" );
1067 	print_node( st-&gt;root );
1068 	printf( "\nJoin commands:\n" );
1069 	print_joins( st-&gt;root, 0 );
1070 	if( vips__map_table( st, 
1071 		(VipsSListMap2Fn) generate_trn_leaves, st, NULL ) )
1072 		return( -1 );
1073 	if( vips__map_table( st, (VipsSListMap2Fn) find_overlaps, st, NULL ) )
1074 		return( -1 );
1075 	vips__map_table( st, (VipsSListMap2Fn) count_leaves, NULL, NULL );
1076 	vips__map_table( st, (VipsSListMap2Fn) count_joins, NULL, NULL );
1077 	st-&gt;leaf = vips__map_table( st, 
1078 		(VipsSListMap2Fn) choose_leaf, NULL, NULL );
1079 #ifdef DEBUG
1080 	printf( "\nLeaf to be 1.000:\n" );
1081 	print_node( st-&gt;leaf );
1082 	printf( "\nOverlaps:\n" );
1083 	vips__map_table( st, (VipsSListMap2Fn) print_overlaps, NULL, NULL );
1084 	printf( "\n%d input files, %d unique overlaps, %d joins\n", 
1085 		st-&gt;nim, st-&gt;novl, st-&gt;njoin );
1086 	return( 0 );
1087 }
1088 static VipsImage *
1089 transform( JoinNode *node, double *gamma )
1090 {
1091 	SymbolTable *st = node-&gt;st;
1092 	VipsImage *in = node-&gt;im;
1093 	double fac = st-&gt;fac[node-&gt;index];
1094 	VipsImage **t = (VipsImage **)
1095 		vips_object_local_array( VIPS_OBJECT( st-&gt;im ), 8 );
1096 	VipsImage *out;
1097 	if( fac == 1.0 ) {
1098 		out = in;
1099 	}
1100 	else if( in-&gt;BandFmt == VIPS_FORMAT_UCHAR || 
1101 		in-&gt;BandFmt == VIPS_FORMAT_USHORT ) {
1102 		if( vips_identity( &amp;t[0],
1103 				"bands", 1,
1104 				"ushort", in-&gt;BandFmt == VIPS_FORMAT_USHORT,
1105 				NULL ) ||
1106 			vips_pow_const1( t[0], &amp;t[1],
1107 				1.0 / (*gamma), NULL ) ||
1108 			vips_linear1( t[1], &amp;t[2], fac, 0.0, NULL ) ||
1109 			vips_pow_const1( t[2], &amp;t[3], *gamma, NULL ) ||
1110 			vips_cast( t[3], &amp;t[4], in-&gt;BandFmt, NULL ) ||
1111 			vips_maplut( in, &amp;t[5], t[4], NULL ) )
1112 			return( NULL );
1113 		out = t[5];
1114 	}
1115 	else {
1116 		if( vips_linear1( in, &amp;t[6], fac, 0.0, NULL ) ||
1117 			vips_cast( t[6], &amp;t[7], in-&gt;BandFmt, NULL ) )
1118 			return( NULL );
1119 		out = t[7];
1120 	}
1121 	vips_image_set_string( out, "mosaic-name", node-&gt;name );
1122 	return( out );
1123 }
1124 static VipsImage *
1125 transformf( JoinNode *node, double *gamma )
1126 {
1127 	SymbolTable *st = node-&gt;st;
1128 	VipsImage *in = node-&gt;im;
1129 	double fac = node-&gt;st-&gt;fac[node-&gt;index];
1130 	VipsImage **t = (VipsImage **) 
1131 		vips_object_local_array( VIPS_OBJECT( st-&gt;im ), 6 );
1132 	VipsImage *out;
1133 	if( fac == 1.0 ) {
1134 		out = in;
1135 	}
1136 	else if( in-&gt;BandFmt == VIPS_FORMAT_UCHAR || 
1137 		in-&gt;BandFmt == VIPS_FORMAT_USHORT ) {
1138 		if( vips_identity( &amp;t[0],
1139 				"bands", 1,
1140 				"ushort", in-&gt;BandFmt == VIPS_FORMAT_USHORT,
1141 				NULL ) ||
1142 			vips_pow_const1( t[0], &amp;t[1],
1143 				1.0 / (*gamma), NULL ) ||
1144 			vips_linear1( t[1], &amp;t[2], fac, 0.0, NULL ) ||
1145 			vips_pow_const1( t[2], &amp;t[3], *gamma, NULL ) ||
1146 			vips_maplut( in, &amp;t[4], t[3], NULL ) )
1147 			return( NULL );
1148 		out = t[4];
1149 	}
1150 	else {
1151 		if( vips_linear1( in, &amp;t[5], fac, 0.0, NULL ) )
1152 			return( NULL );
1153 		out = t[5];
1154 	}
1155 	vips_image_set_string( out, "mosaic-name", node-&gt;name );
1156 	return( out );
1157 }
1158 typedef struct {
1159 	VipsOperation parent_instance;
1160 	VipsImage *in;
1161 	VipsImage *out;
1162 	gboolean int_output;
1163 	double gamma;
1164 } VipsGlobalbalance;
1165 typedef VipsOperationClass VipsGlobalbalanceClass;
1166 G_DEFINE_TYPE( VipsGlobalbalance, vips_globalbalance, VIPS_TYPE_OPERATION );
1167 static int
1168 vips_globalbalance_build( VipsObject *object )
1169 {
1170 	VipsGlobalbalance *globalbalance = (VipsGlobalbalance *) object;
1171 	SymbolTable *st;
1172 	transform_fn trn;
1173 	g_object_set( globalbalance, "out", vips_image_new(), NULL ); 
1174 	if( VIPS_OBJECT_CLASS( vips_globalbalance_parent_class )-&gt;
1175 		build( object ) )
1176 		return( -1 );
1177 	if( !(st = vips__build_symtab( globalbalance-&gt;out, SYM_TAB_SIZE )) ||
1178 		analyse_mosaic( st, globalbalance-&gt;in ) ||
1179 		find_factors( st, globalbalance-&gt;gamma ) )
1180 		return( -1 );
1181 <a name="0"></a>
1182 	trn = globalbalance-&gt;int_output ? 
1183 		(transform_fn) transform : (transform_fn) transformf; 
1184 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if( vips__build_mosaic( st, globalbalance-&gt;out, 
1185 		trn, &amp;globalbalance-&gt;gamma ) )
1186 		return( -1 );
1187 	return( 0 );
1188 }
1189 static void
1190 vips_globalbalance_class_init( VipsGlobalbalanceClass *class )
1191 {
1192 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
1193 	VipsObjectClass *object_class = (VipsObjectClass *) class;
1194 	gobject_class-&gt;set_property = vips_object_set_property;
1195 	gobject_class-&gt;get_property = vips_object_get_property;
1196 	object_class-&gt;nickname = "globalbalance";
1197 	object_class-&gt;description = _( "global balance an image mosaic" );
1198 	object_class-&gt;build = vips_globalbalance_build;
1199 	VIPS_ARG_IMAGE( class, "in", 1, </b></font>
1200 		_( "Input" ), 
1201 		_( "Input image" ),
1202 		VIPS_ARGUMENT_REQUIRED_INPUT, 
1203 		G_STRUCT_OFFSET( VipsGlobalbalance, in ) );
1204 	VIPS_ARG_IMAGE( class, "out", 2, 
1205 		_( "Output" ), 
1206 		_( "Output image" ),
1207 		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
1208 		G_STRUCT_OFFSET( VipsGlobalbalance, out ) );
1209 	VIPS_ARG_DOUBLE( class, "gamma", 5, 
1210 		_( "gamma" ), 
1211 		_( "Image gamma" ),
1212 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1213 		G_STRUCT_OFFSET( VipsGlobalbalance, gamma ),
1214 		0.00001, 10, 1.6 );
1215 	VIPS_ARG_BOOL( class, "int_output", 7, 
1216 		_( "Int output" ), 
1217 		_( "Integer output" ),
1218 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1219 		G_STRUCT_OFFSET( VipsGlobalbalance, int_output ),
1220 		FALSE ); 
1221 }
1222 static void
1223 vips_globalbalance_init( VipsGlobalbalance *globalbalance )
1224 {
1225 	globalbalance-&gt;gamma = 1.6;
1226 }
1227 int 
1228 vips_globalbalance( VipsImage *in, VipsImage **out, ... )
1229 {
1230 	va_list ap;
1231 	int result;
1232 	va_start( ap, out );
1233 	result = vips_call_split( "globalbalance", ap, in, out );
1234 	va_end( ap );
1235 	return( result );
1236 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
