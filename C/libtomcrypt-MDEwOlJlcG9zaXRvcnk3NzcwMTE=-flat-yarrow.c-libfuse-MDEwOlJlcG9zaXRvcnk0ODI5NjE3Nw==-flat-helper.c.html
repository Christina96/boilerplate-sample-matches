
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.143418467583497%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-yarrow.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_YARROW
3  const struct ltc_prng_descriptor yarrow_desc =
4  {
5      "yarrow", 64,
6      &yarrow_start,
7      &yarrow_add_entropy,
8      &yarrow_ready,
9      &yarrow_read,
10      &yarrow_done,
11      &yarrow_export,
12      &yarrow_import,
13      &yarrow_test
14  };
15  int yarrow_start(prng_state *prng)
16  {
17     int err;
18     LTC_ARGCHK(prng != NULL);
19     prng->ready = 0;
20  #ifdef LTC_RIJNDAEL
21  #if    LTC_YARROW_AES==0
22     prng->u.yarrow.cipher = register_cipher(&rijndael_enc_desc);
23  #elif  LTC_YARROW_AES==1
24     prng->u.yarrow.cipher = register_cipher(&aes_enc_desc);
25  #elif  LTC_YARROW_AES==2
26     prng->u.yarrow.cipher = register_cipher(&rijndael_desc);
27  #elif  LTC_YARROW_AES==3
28     prng->u.yarrow.cipher = register_cipher(&aes_desc);
29  #endif
30  #elif defined(LTC_BLOWFISH)
31     prng->u.yarrow.cipher = register_cipher(&blowfish_desc);
32  #elif defined(LTC_TWOFISH)
33     prng->u.yarrow.cipher = register_cipher(&twofish_desc);
34  #elif defined(LTC_RC6)
35     prng->u.yarrow.cipher = register_cipher(&rc6_desc);
36  #elif defined(LTC_RC5)
37     prng->u.yarrow.cipher = register_cipher(&rc5_desc);
38  #elif defined(LTC_SAFERP)
39     prng->u.yarrow.cipher = register_cipher(&saferp_desc);
40  #elif defined(LTC_RC2)
41     prng->u.yarrow.cipher = register_cipher(&rc2_desc);
42  #elif defined(LTC_NOEKEON)
43     prng->u.yarrow.cipher = register_cipher(&noekeon_desc);
44  #elif defined(LTC_ANUBIS)
45     prng->u.yarrow.cipher = register_cipher(&anubis_desc);
46  #elif defined(LTC_KSEED)
47     prng->u.yarrow.cipher = register_cipher(&kseed_desc);
48  #elif defined(LTC_KHAZAD)
49     prng->u.yarrow.cipher = register_cipher(&khazad_desc);
50  #elif defined(LTC_CAST5)
51     prng->u.yarrow.cipher = register_cipher(&cast5_desc);
52  #elif defined(LTC_XTEA)
53     prng->u.yarrow.cipher = register_cipher(&xtea_desc);
54  #elif defined(LTC_SAFER)
55     prng->u.yarrow.cipher = register_cipher(&safer_sk128_desc);
56  #elif defined(LTC_DES)
57     prng->u.yarrow.cipher = register_cipher(&des3_desc);
58  #else
59     #error LTC_YARROW needs at least one CIPHER
60  #endif
61     if ((err = cipher_is_valid(prng->u.yarrow.cipher)) != CRYPT_OK) {
62        return err;
63     }
64  #ifdef LTC_SHA256
65     prng->u.yarrow.hash   = register_hash(&sha256_desc);
66  #elif defined(LTC_SHA512)
67     prng->u.yarrow.hash   = register_hash(&sha512_desc);
68  #elif defined(LTC_TIGER)
69     prng->u.yarrow.hash   = register_hash(&tiger_desc);
70  #elif defined(LTC_SHA1)
71     prng->u.yarrow.hash   = register_hash(&sha1_desc);
72  #elif defined(LTC_RIPEMD320)
73     prng->u.yarrow.hash   = register_hash(&rmd320_desc);
74  #elif defined(LTC_RIPEMD256)
75     prng->u.yarrow.hash   = register_hash(&rmd256_desc);
76  #elif defined(LTC_RIPEMD160)
77     prng->u.yarrow.hash   = register_hash(&rmd160_desc);
78  #elif defined(LTC_RIPEMD128)
79     prng->u.yarrow.hash   = register_hash(&rmd128_desc);
80  #elif defined(LTC_MD5)
81     prng->u.yarrow.hash   = register_hash(&md5_desc);
82  #elif defined(LTC_MD4)
83     prng->u.yarrow.hash   = register_hash(&md4_desc);
84  #elif defined(LTC_MD2)
85     prng->u.yarrow.hash   = register_hash(&md2_desc);
86  #elif defined(LTC_WHIRLPOOL)
87     prng->u.yarrow.hash   = register_hash(&whirlpool_desc);
88  #else
89     #error LTC_YARROW needs at least one HASH
90  #endif
91     if ((err = hash_is_valid(prng->u.yarrow.hash)) != CRYPT_OK) {
92        return err;
93     }
94     zeromem(prng->u.yarrow.pool, sizeof(prng->u.yarrow.pool));
95     LTC_MUTEX_INIT(&prng->lock)
96     return CRYPT_OK;
97  }
98  int yarrow_add_entropy(const unsigned char *in, unsigned long inlen, prng_state *prng)
99  {
100     hash_state md;
101     int err;
102     LTC_ARGCHK(prng != NULL);
103     LTC_ARGCHK(in != NULL);
104     LTC_ARGCHK(inlen > 0);
105     LTC_MUTEX_LOCK(&prng->lock);
106     if ((err = hash_is_valid(prng->u.yarrow.hash)) != CRYPT_OK) {
107        goto LBL_UNLOCK;
108     }
109     if ((err = hash_descriptor[prng->u.yarrow.hash].init(&md)) != CRYPT_OK) {
110        goto LBL_UNLOCK;
111     }
112     if ((err = hash_descriptor[prng->u.yarrow.hash].process(&md, prng->u.yarrow.pool,
113                                                          hash_descriptor[prng->u.yarrow.hash].hashsize)) != CRYPT_OK) {
114        goto LBL_UNLOCK;
115     }
116     if ((err = hash_descriptor[prng->u.yarrow.hash].process(&md, in, inlen)) != CRYPT_OK) {
117        goto LBL_UNLOCK;
118     }
119     err = hash_descriptor[prng->u.yarrow.hash].done(&md, prng->u.yarrow.pool);
120  LBL_UNLOCK:
121     LTC_MUTEX_UNLOCK(&prng->lock);
122     return err;
123  }
124  int yarrow_ready(prng_state *prng)
125  {
126     int ks, err;
127     LTC_ARGCHK(prng != NULL);
128     LTC_MUTEX_LOCK(&prng->lock);
129     if ((err = hash_is_valid(prng->u.yarrow.hash)) != CRYPT_OK) {
130        goto LBL_UNLOCK;
131     }
132     if ((err = cipher_is_valid(prng->u.yarrow.cipher)) != CRYPT_OK) {
133        goto LBL_UNLOCK;
134     }
135     ks = (int)hash_descriptor[prng->u.yarrow.hash].hashsize;
136     if ((err = cipher_descriptor[prng->u.yarrow.cipher].keysize(&ks)) != CRYPT_OK) {
137        goto LBL_UNLOCK;
138     }
139     if ((err = ctr_start(prng->u.yarrow.cipher,     &bsol;* what cipher to use */
140                          prng->u.yarrow.pool,       &bsol;* IV */
141                          prng->u.yarrow.pool, ks,   &bsol;* KEY and key size */
142                          0,                       &bsol;* number of rounds */
143                          CTR_COUNTER_LITTLE_ENDIAN, &bsol;* little endian counter */
144                          &prng->u.yarrow.ctr)) != CRYPT_OK) {
145        goto LBL_UNLOCK;
146     }
147     prng->ready = 1;
148  LBL_UNLOCK:
149     LTC_MUTEX_UNLOCK(&prng->lock);
150     return err;
151  }
152  unsigned long yarrow_read(unsigned char *out, unsigned long outlen, prng_state *prng)
153  {
<span onclick='openModal()' class='match'>154     if (outlen == 0 || prng == NULL || out == NULL) return 0;
155     LTC_MUTEX_LOCK(&prng->lock);
156     if (!prng->ready) {
157        outlen = 0;
158        goto LBL_UNLOCK;
159     }
160     zeromem(out, outlen);
161     if (ctr_encrypt(out, out, outlen, &prng->u.yarrow.ctr) != CRYPT_OK) {
</span>162        outlen = 0;
163     }
164  LBL_UNLOCK:
165     LTC_MUTEX_UNLOCK(&prng->lock);
166     return outlen;
167  }
168  int yarrow_done(prng_state *prng)
169  {
170     int err;
171     LTC_ARGCHK(prng != NULL);
172     LTC_MUTEX_LOCK(&prng->lock);
173     prng->ready = 0;
174     err = ctr_done(&prng->u.yarrow.ctr);
175     LTC_MUTEX_UNLOCK(&prng->lock);
176     LTC_MUTEX_DESTROY(&prng->lock);
177     return err;
178  }
179  LTC_PRNG_EXPORT(yarrow)
180  int yarrow_import(const unsigned char *in, unsigned long inlen, prng_state *prng)
181  {
182     int err;
183     LTC_ARGCHK(in   != NULL);
184     LTC_ARGCHK(prng != NULL);
185     if (inlen < (unsigned long)yarrow_desc.export_size) return CRYPT_INVALID_ARG;
186     if ((err = yarrow_start(prng)) != CRYPT_OK)                  return err;
187     if ((err = yarrow_add_entropy(in, inlen, prng)) != CRYPT_OK) return err;
188     return CRYPT_OK;
189  }
190  int yarrow_test(void)
191  {
192  #ifndef LTC_TEST
193     return CRYPT_NOP;
194  #else
195     int err;
196     prng_state prng;
197     if ((err = yarrow_start(&prng)) != CRYPT_OK) {
198        return err;
199     }
200     if (cipher_descriptor[prng.u.yarrow.cipher].test &&
201         ((err = cipher_descriptor[prng.u.yarrow.cipher].test()) != CRYPT_OK)) {
202        return err;
203     }
204     if (hash_descriptor[prng.u.yarrow.hash].test &&
205         ((err = hash_descriptor[prng.u.yarrow.hash].test()) != CRYPT_OK)) {
206        return err;
207     }
208     return CRYPT_OK;
209  #endif
210  }
211  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-helper.c</h3>
            <pre><code>1  #include "fuse_config.h"
2  #include "fuse_i.h"
3  #include "fuse_misc.h"
4  #include "fuse_opt.h"
5  #include "fuse_lowlevel.h"
6  #include "mount_util.h"
7  #include <stdio.h>
8  #include <stdlib.h>
9  #include <stddef.h>
10  #include <unistd.h>
11  #include <string.h>
12  #include <limits.h>
13  #include <errno.h>
14  #include <sys/param.h>
15  #define FUSE_HELPER_OPT(t, p) \
16  	{ t, offsetof(struct fuse_cmdline_opts, p), 1 }
17  static const struct fuse_opt fuse_helper_opts[] = {
18  	FUSE_HELPER_OPT("-h",		show_help),
19  	FUSE_HELPER_OPT("--help",	show_help),
20  	FUSE_HELPER_OPT("-V",		show_version),
21  	FUSE_HELPER_OPT("--version",	show_version),
22  	FUSE_HELPER_OPT("-d",		debug),
23  	FUSE_HELPER_OPT("debug",	debug),
24  	FUSE_HELPER_OPT("-d",		foreground),
25  	FUSE_HELPER_OPT("debug",	foreground),
26  	FUSE_OPT_KEY("-d",		FUSE_OPT_KEY_KEEP),
27  	FUSE_OPT_KEY("debug",		FUSE_OPT_KEY_KEEP),
28  	FUSE_HELPER_OPT("-f",		foreground),
29  	FUSE_HELPER_OPT("-s",		singlethread),
30  	FUSE_HELPER_OPT("fsname=",	nodefault_subtype),
31  	FUSE_OPT_KEY("fsname=",		FUSE_OPT_KEY_KEEP),
32  #ifndef __FreeBSD__
33  	FUSE_HELPER_OPT("subtype=",	nodefault_subtype),
34  	FUSE_OPT_KEY("subtype=",	FUSE_OPT_KEY_KEEP),
35  #endif
36  	FUSE_HELPER_OPT("clone_fd",	clone_fd),
37  	FUSE_HELPER_OPT("max_idle_threads=%u", max_idle_threads),
38  	FUSE_HELPER_OPT("max_threads=%u", max_threads),
39  	FUSE_OPT_END
40  };
41  struct fuse_conn_info_opts {
42  	int atomic_o_trunc;
43  	int no_remote_posix_lock;
44  	int no_remote_flock;
45  	int splice_write;
46  	int splice_move;
47  	int splice_read;
48  	int no_splice_write;
49  	int no_splice_move;
50  	int no_splice_read;
51  	int auto_inval_data;
52  	int no_auto_inval_data;
53  	int no_readdirplus;
54  	int no_readdirplus_auto;
55  	int async_dio;
56  	int no_async_dio;
57  	int writeback_cache;
58  	int no_writeback_cache;
59  	int async_read;
60  	int sync_read;
61  	unsigned max_write;
62  	unsigned max_readahead;
63  	unsigned max_background;
64  	unsigned congestion_threshold;
65  	unsigned time_gran;
66  	int set_max_write;
67  	int set_max_readahead;
68  	int set_max_background;
69  	int set_congestion_threshold;
70  	int set_time_gran;
71  };
72  #define CONN_OPTION(t, p, v)					\
73  	{ t, offsetof(struct fuse_conn_info_opts, p), v }
74  static const struct fuse_opt conn_info_opt_spec[] = {
75  	CONN_OPTION("max_write=%u", max_write, 0),
76  	CONN_OPTION("max_write=", set_max_write, 1),
77  	CONN_OPTION("max_readahead=%u", max_readahead, 0),
78  	CONN_OPTION("max_readahead=", set_max_readahead, 1),
79  	CONN_OPTION("max_background=%u", max_background, 0),
80  	CONN_OPTION("max_background=", set_max_background, 1),
81  	CONN_OPTION("congestion_threshold=%u", congestion_threshold, 0),
82  	CONN_OPTION("congestion_threshold=", set_congestion_threshold, 1),
83  	CONN_OPTION("sync_read", sync_read, 1),
84  	CONN_OPTION("async_read", async_read, 1),
85  	CONN_OPTION("atomic_o_trunc", atomic_o_trunc, 1),
86  	CONN_OPTION("no_remote_lock", no_remote_posix_lock, 1),
87  	CONN_OPTION("no_remote_lock", no_remote_flock, 1),
88  	CONN_OPTION("no_remote_flock", no_remote_flock, 1),
89  	CONN_OPTION("no_remote_posix_lock", no_remote_posix_lock, 1),
90  	CONN_OPTION("splice_write", splice_write, 1),
91  	CONN_OPTION("no_splice_write", no_splice_write, 1),
92  	CONN_OPTION("splice_move", splice_move, 1),
93  	CONN_OPTION("no_splice_move", no_splice_move, 1),
94  	CONN_OPTION("splice_read", splice_read, 1),
95  	CONN_OPTION("no_splice_read", no_splice_read, 1),
96  	CONN_OPTION("auto_inval_data", auto_inval_data, 1),
97  	CONN_OPTION("no_auto_inval_data", no_auto_inval_data, 1),
98  	CONN_OPTION("readdirplus=no", no_readdirplus, 1),
99  	CONN_OPTION("readdirplus=yes", no_readdirplus, 0),
100  	CONN_OPTION("readdirplus=yes", no_readdirplus_auto, 1),
101  	CONN_OPTION("readdirplus=auto", no_readdirplus, 0),
102  	CONN_OPTION("readdirplus=auto", no_readdirplus_auto, 0),
103  	CONN_OPTION("async_dio", async_dio, 1),
104  	CONN_OPTION("no_async_dio", no_async_dio, 1),
105  	CONN_OPTION("writeback_cache", writeback_cache, 1),
106  	CONN_OPTION("no_writeback_cache", no_writeback_cache, 1),
107  	CONN_OPTION("time_gran=%u", time_gran, 0),
108  	CONN_OPTION("time_gran=", set_time_gran, 1),
109  	FUSE_OPT_END
110  };
111  void fuse_cmdline_help(void)
112  {
113  	printf("    -h   --help            print help\n"
114  	       "    -V   --version         print version\n"
115  	       "    -d   -o debug          enable debug output (implies -f)\n"
116  	       "    -f                     foreground operation\n"
117  	       "    -s                     disable multi-threaded operation\n"
118  	       "    -o clone_fd            use separate fuse device fd for each thread\n"
119  	       "                           (may improve performance)\n"
120  	       "    -o max_idle_threads    the maximum number of idle worker threads\n"
121  	       "                           allowed (default: -1)\n"
122  	       "    -o max_threads         the maximum number of worker threads\n"
123  	       "                           allowed (default: 10)\n");
124  }
125  static int fuse_helper_opt_proc(void *data, const char *arg, int key,
126  				struct fuse_args *outargs)
127  {
128  	(void) outargs;
129  	struct fuse_cmdline_opts *opts = data;
130  	switch (key) {
131  	case FUSE_OPT_KEY_NONOPT:
132  		if (!opts->mountpoint) {
133  			if (fuse_mnt_parse_fuse_fd(arg) != -1) {
134  				return fuse_opt_add_opt(&opts->mountpoint, arg);
135  			}
136  			char mountpoint[PATH_MAX] = "";
137  			if (realpath(arg, mountpoint) == NULL) {
138  				fuse_log(FUSE_LOG_ERR,
139  					"fuse: bad mount point `%s': %s\n",
140  					arg, strerror(errno));
141  				return -1;
142  			}
143  			return fuse_opt_add_opt(&opts->mountpoint, mountpoint);
144  		} else {
145  			fuse_log(FUSE_LOG_ERR, "fuse: invalid argument `%s'\n", arg);
146  			return -1;
147  		}
148  	default:
149  		return 1;
150  	}
151  }
152  static int add_default_subtype(const char *progname, struct fuse_args *args)
153  {
154  	int res;
155  	char *subtype_opt;
156  	const char *basename = strrchr(progname, '/');
157  	if (basename == NULL)
158  		basename = progname;
159  	else if (basename[1] != '\0')
160  		basename++;
161  	subtype_opt = (char *) malloc(strlen(basename) + 64);
162  	if (subtype_opt == NULL) {
163  		fuse_log(FUSE_LOG_ERR, "fuse: memory allocation failed\n");
164  		return -1;
165  	}
166  #ifdef __FreeBSD__
167  	sprintf(subtype_opt, "-ofsname=%s", basename);
168  #else
169  	sprintf(subtype_opt, "-osubtype=%s", basename);
170  #endif
171  	res = fuse_opt_add_arg(args, subtype_opt);
172  	free(subtype_opt);
173  	return res;
174  }
175  int fuse_parse_cmdline_312(struct fuse_args *args,
176  			   struct fuse_cmdline_opts *opts);
177  FUSE_SYMVER("fuse_parse_cmdline_312", "fuse_parse_cmdline@@FUSE_3.12")
178  int fuse_parse_cmdline_312(struct fuse_args *args,
179  			   struct fuse_cmdline_opts *opts)
180  {
181  	memset(opts, 0, sizeof(struct fuse_cmdline_opts));
182  	opts->max_idle_threads = UINT_MAX; &bsol;* new default in fuse version 3.12 */
183  	opts->max_threads = 10;
184  	if (fuse_opt_parse(args, opts, fuse_helper_opts,
185  			   fuse_helper_opt_proc) == -1)
186  		return -1;
187  	if (!opts->nodefault_subtype)
188  		if (add_default_subtype(args->argv[0], args) == -1)
189  			return -1;
190  	return 0;
191  }
192  int fuse_parse_cmdline_30(struct fuse_args *args,
193  		       struct fuse_cmdline_opts *opts);
194  FUSE_SYMVER("fuse_parse_cmdline_30", "fuse_parse_cmdline@FUSE_3.0")
195  int fuse_parse_cmdline_30(struct fuse_args *args,
196  			  struct fuse_cmdline_opts *out_opts)
197  {
198  	struct fuse_cmdline_opts opts;
199  	int rc = fuse_parse_cmdline_312(args, &opts);
200  	if (rc == 0) {
201  		memcpy(out_opts, &opts,
202  		       offsetof(struct fuse_cmdline_opts, max_idle_threads) +
203  		       sizeof(opts.max_idle_threads));
204  	}
205  	return rc;
206  }
207  int fuse_daemonize(int foreground)
208  {
209  	if (!foreground) {
210  		int nullfd;
211  		int waiter[2];
212  		char completed;
213  		if (pipe(waiter)) {
214  			perror("fuse_daemonize: pipe");
215  			return -1;
216  		}
217  		switch(fork()) {
218  		case -1:
219  			perror("fuse_daemonize: fork");
220  			return -1;
221  		case 0:
222  			break;
223  		default:
224  			(void) read(waiter[0], &completed, sizeof(completed));
225  			_exit(0);
226  		}
227  		if (setsid() == -1) {
228  			perror("fuse_daemonize: setsid");
229  			return -1;
230  		}
231  		(void) chdir("/");
232  		nullfd = open("/dev/null", O_RDWR, 0);
233  		if (nullfd != -1) {
234  			(void) dup2(nullfd, 0);
235  			(void) dup2(nullfd, 1);
236  			(void) dup2(nullfd, 2);
237  			if (nullfd > 2)
238  				close(nullfd);
239  		}
240  		completed = 1;
241  		(void) write(waiter[1], &completed, sizeof(completed));
242  		close(waiter[0]);
243  		close(waiter[1]);
244  	} else {
245  		(void) chdir("/");
246  	}
247  	return 0;
248  }
249  int fuse_main_real(int argc, char *argv[], const struct fuse_operations *op,
250  		   size_t op_size, void *user_data)
251  {
252  	struct fuse_args args = FUSE_ARGS_INIT(argc, argv);
253  	struct fuse *fuse;
254  	struct fuse_cmdline_opts opts;
255  	int res;
256  	struct fuse_loop_config *loop_config = NULL;
257  	if (fuse_parse_cmdline(&args, &opts) != 0)
<span onclick='openModal()' class='match'>258  		return 1;
259  	if (opts.show_version) {
260  		printf("FUSE library version %s\n", PACKAGE_VERSION);
261  		fuse_lowlevel_version();
262  		res = 0;
263  		goto out1;
264  	}
265  	if (opts.show_help) {
</span>266  		if(args.argv[0][0] != '\0')
267  			printf("usage: %s [options] <mountpoint>\n\n",
268  			       args.argv[0]);
269  		printf("FUSE options:\n");
270  		fuse_cmdline_help();
271  		fuse_lib_help(&args);
272  		res = 0;
273  		goto out1;
274  	}
275  	if (!opts.show_help &&
276  	    !opts.mountpoint) {
277  		fuse_log(FUSE_LOG_ERR, "error: no mountpoint specified\n");
278  		res = 2;
279  		goto out1;
280  	}
281  	fuse = fuse_new_31(&args, op, op_size, user_data);
282  	if (fuse == NULL) {
283  		res = 3;
284  		goto out1;
285  	}
286  	if (fuse_mount(fuse,opts.mountpoint) != 0) {
287  		res = 4;
288  		goto out2;
289  	}
290  	if (fuse_daemonize(opts.foreground) != 0) {
291  		res = 5;
292  		goto out3;
293  	}
294  	struct fuse_session *se = fuse_get_session(fuse);
295  	if (fuse_set_signal_handlers(se) != 0) {
296  		res = 6;
297  		goto out3;
298  	}
299  	if (opts.singlethread)
300  		res = fuse_loop(fuse);
301  	else {
302  		loop_config = fuse_loop_cfg_create();
303  		if (loop_config == NULL) {
304  			res = 7;
305  			goto out3;
306  		}
307  		fuse_loop_cfg_set_clone_fd(loop_config, opts.clone_fd);
308  		fuse_loop_cfg_set_idle_threads(loop_config, opts.max_idle_threads);
309  		fuse_loop_cfg_set_max_threads(loop_config, opts.max_threads);
310  		res = fuse_loop_mt(fuse, loop_config);
311  	}
312  	if (res)
313  		res = 8;
314  	fuse_remove_signal_handlers(se);
315  out3:
316  	fuse_unmount(fuse);
317  out2:
318  	fuse_destroy(fuse);
319  out1:
320  	fuse_loop_cfg_destroy(loop_config);
321  	free(opts.mountpoint);
322  	fuse_opt_free_args(&args);
323  	return res;
324  }
325  void fuse_apply_conn_info_opts(struct fuse_conn_info_opts *opts,
326  			       struct fuse_conn_info *conn)
327  {
328  	if(opts->set_max_write)
329  		conn->max_write = opts->max_write;
330  	if(opts->set_max_background)
331  		conn->max_background = opts->max_background;
332  	if(opts->set_congestion_threshold)
333  		conn->congestion_threshold = opts->congestion_threshold;
334  	if(opts->set_time_gran)
335  		conn->time_gran = opts->time_gran;
336  	if(opts->set_max_readahead)
337  		conn->max_readahead = opts->max_readahead;
338  #define LL_ENABLE(cond,cap) \
339  	if (cond) conn->want |= (cap)
340  #define LL_DISABLE(cond,cap) \
341  	if (cond) conn->want &= ~(cap)
342  	LL_ENABLE(opts->splice_read, FUSE_CAP_SPLICE_READ);
343  	LL_DISABLE(opts->no_splice_read, FUSE_CAP_SPLICE_READ);
344  	LL_ENABLE(opts->splice_write, FUSE_CAP_SPLICE_WRITE);
345  	LL_DISABLE(opts->no_splice_write, FUSE_CAP_SPLICE_WRITE);
346  	LL_ENABLE(opts->splice_move, FUSE_CAP_SPLICE_MOVE);
347  	LL_DISABLE(opts->no_splice_move, FUSE_CAP_SPLICE_MOVE);
348  	LL_ENABLE(opts->auto_inval_data, FUSE_CAP_AUTO_INVAL_DATA);
349  	LL_DISABLE(opts->no_auto_inval_data, FUSE_CAP_AUTO_INVAL_DATA);
350  	LL_DISABLE(opts->no_readdirplus, FUSE_CAP_READDIRPLUS);
351  	LL_DISABLE(opts->no_readdirplus_auto, FUSE_CAP_READDIRPLUS_AUTO);
352  	LL_ENABLE(opts->async_dio, FUSE_CAP_ASYNC_DIO);
353  	LL_DISABLE(opts->no_async_dio, FUSE_CAP_ASYNC_DIO);
354  	LL_ENABLE(opts->writeback_cache, FUSE_CAP_WRITEBACK_CACHE);
355  	LL_DISABLE(opts->no_writeback_cache, FUSE_CAP_WRITEBACK_CACHE);
356  	LL_ENABLE(opts->async_read, FUSE_CAP_ASYNC_READ);
357  	LL_DISABLE(opts->sync_read, FUSE_CAP_ASYNC_READ);
358  	LL_DISABLE(opts->no_remote_posix_lock, FUSE_CAP_POSIX_LOCKS);
359  	LL_DISABLE(opts->no_remote_flock, FUSE_CAP_FLOCK_LOCKS);
360  }
361  struct fuse_conn_info_opts* fuse_parse_conn_info_opts(struct fuse_args *args)
362  {
363  	struct fuse_conn_info_opts *opts;
364  	opts = calloc(1, sizeof(struct fuse_conn_info_opts));
365  	if(opts == NULL) {
366  		fuse_log(FUSE_LOG_ERR, "calloc failed\n");
367  		return NULL;
368  	}
369  	if(fuse_opt_parse(args, opts, conn_info_opt_spec, NULL) == -1) {
370  		free(opts);
371  		return NULL;
372  	}
373  	return opts;
374  }
375  int fuse_open_channel(const char *mountpoint, const char* options)
376  {
377  	struct mount_opts *opts = NULL;
378  	int fd = -1;
379  	const char *argv[] = { "", "-o", options };
380  	int argc = sizeof(argv) / sizeof(argv[0]);
381  	struct fuse_args args = FUSE_ARGS_INIT(argc, (char**) argv);
382  	opts = parse_mount_opts(&args);
383  	if (opts == NULL)
384  		return -1;
385  	fd = fuse_kern_mount(mountpoint, opts);
386  	destroy_mount_opts(opts);
387  	return fd;
388  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-yarrow.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-helper.c</div>
                </div>
                <div class="column column_space"><pre><code>154     if (outlen == 0 || prng == NULL || out == NULL) return 0;
155     LTC_MUTEX_LOCK(&prng->lock);
156     if (!prng->ready) {
157        outlen = 0;
158        goto LBL_UNLOCK;
159     }
160     zeromem(out, outlen);
161     if (ctr_encrypt(out, out, outlen, &prng->u.yarrow.ctr) != CRYPT_OK) {
</pre></code></div>
                <div class="column column_space"><pre><code>258  		return 1;
259  	if (opts.show_version) {
260  		printf("FUSE library version %s\n", PACKAGE_VERSION);
261  		fuse_lowlevel_version();
262  		res = 0;
263  		goto out1;
264  	}
265  	if (opts.show_help) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    