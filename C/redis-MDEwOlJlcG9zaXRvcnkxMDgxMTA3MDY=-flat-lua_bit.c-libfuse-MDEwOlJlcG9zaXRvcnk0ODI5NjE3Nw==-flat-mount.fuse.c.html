
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.1936127744510974%, Tokens: 8</h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lua_bit.c</h3>
            <pre><code>1  #define LUA_BITOP_VERSION	"1.0.2"
2  #define LUA_LIB
3  #include "lua.h"
4  #include "lauxlib.h"
5  #ifdef _MSC_VER
6  typedef __int32 int32_t;
7  typedef unsigned __int32 uint32_t;
8  typedef unsigned __int64 uint64_t;
9  #else
10  #include <stdint.h>
11  #endif
12  typedef int32_t SBits;
13  typedef uint32_t UBits;
14  typedef union {
15    lua_Number n;
16  #ifdef LUA_NUMBER_DOUBLE
17    uint64_t b;
18  #else
19    UBits b;
20  #endif
21  } BitNum;
22  static UBits barg(lua_State *L, int idx)
23  {
24    BitNum bn;
25    UBits b;
26  #if LUA_VERSION_NUM < 502
27    bn.n = lua_tonumber(L, idx);
28  #else
29    bn.n = luaL_checknumber(L, idx);
30  #endif
31  #if defined(LUA_NUMBER_DOUBLE)
32    bn.n += 6755399441055744.0;  &bsol;* 2^52+2^51 */
33  #ifdef SWAPPED_DOUBLE
34    b = (UBits)(bn.b >> 32);
35  #else
36    b = (UBits)bn.b;
37  #endif
38  #elif defined(LUA_NUMBER_INT) || defined(LUA_NUMBER_LONG) || \
39        defined(LUA_NUMBER_LONGLONG) || defined(LUA_NUMBER_LONG_LONG) || \
40        defined(LUA_NUMBER_LLONG)
41    if (sizeof(UBits) == sizeof(lua_Number))
42      b = bn.b;
43    else
<span onclick='openModal()' class='match'>44      b = (UBits)(SBits)bn.n;
45  #elif defined(LUA_NUMBER_FLOAT)
46  #error "A 'float' lua_Number type is incompatible with this library"
47  #else
48  #error "Unknown number type, check LUA_NUMBER_* in luaconf.h"
49  #endif
50  #if LUA_VERSION_NUM < 502
51    if (b == 0 && !lua_isnumber(L, idx)) {
52      luaL_typerror(L, idx, "number");
53    }
54  #endif
55    return b;
56  }
57  #define BRET(b)  lua_pushnumber(L, (lua_Number)(SBits)(b)); return 1;
58  static int bit_tobit(lua_State *L) { BRET(barg(L, 1)) }
</span>59  static int bit_bnot(lua_State *L) { BRET(~barg(L, 1)) }
60  #define BIT_OP(func, opr) \
61    static int func(lua_State *L) { int i; UBits b = barg(L, 1); \
62      for (i = lua_gettop(L); i > 1; i--) b opr barg(L, i); BRET(b) }
63  BIT_OP(bit_band, &=)
64  BIT_OP(bit_bor, |=)
65  BIT_OP(bit_bxor, ^=)
66  #define bshl(b, n)  (b << n)
67  #define bshr(b, n)  (b >> n)
68  #define bsar(b, n)  ((SBits)b >> n)
69  #define brol(b, n)  ((b << n) | (b >> (32-n)))
70  #define bror(b, n)  ((b << (32-n)) | (b >> n))
71  #define BIT_SH(func, fn) \
72    static int func(lua_State *L) { \
73      UBits b = barg(L, 1); UBits n = barg(L, 2) & 31; BRET(fn(b, n)) }
74  BIT_SH(bit_lshift, bshl)
75  BIT_SH(bit_rshift, bshr)
76  BIT_SH(bit_arshift, bsar)
77  BIT_SH(bit_rol, brol)
78  BIT_SH(bit_ror, bror)
79  static int bit_bswap(lua_State *L)
80  {
81    UBits b = barg(L, 1);
82    b = (b >> 24) | ((b >> 8) & 0xff00) | ((b & 0xff00) << 8) | (b << 24);
83    BRET(b)
84  }
85  static int bit_tohex(lua_State *L)
86  {
87    UBits b = barg(L, 1);
88    SBits n = lua_isnone(L, 2) ? 8 : (SBits)barg(L, 2);
89    const char *hexdigits = "0123456789abcdef";
90    char buf[8];
91    int i;
92    if (n < 0) { n = -n; hexdigits = "0123456789ABCDEF"; }
93    if (n > 8) n = 8;
94    for (i = (int)n; --i >= 0; ) { buf[i] = hexdigits[b & 15]; b >>= 4; }
95    lua_pushlstring(L, buf, (size_t)n);
96    return 1;
97  }
98  static const struct luaL_Reg bit_funcs[] = {
99    { "tobit",	bit_tobit },
100    { "bnot",	bit_bnot },
101    { "band",	bit_band },
102    { "bor",	bit_bor },
103    { "bxor",	bit_bxor },
104    { "lshift",	bit_lshift },
105    { "rshift",	bit_rshift },
106    { "arshift",	bit_arshift },
107    { "rol",	bit_rol },
108    { "ror",	bit_ror },
109    { "bswap",	bit_bswap },
110    { "tohex",	bit_tohex },
111    { NULL, NULL }
112  };
113  #define BAD_SAR		(bsar(-8, 2) != (SBits)-2)
114  LUALIB_API int luaopen_bit(lua_State *L)
115  {
116    UBits b;
117    lua_pushnumber(L, (lua_Number)1437217655L);
118    b = barg(L, -1);
119    if (b != (UBits)1437217655L || BAD_SAR) {  &bsol;* Perform a simple self-test. */
120      const char *msg = "compiled with incompatible luaconf.h";
121  #ifdef LUA_NUMBER_DOUBLE
122  #ifdef _WIN32
123      if (b == (UBits)1610612736L)
124        msg = "use D3DCREATE_FPU_PRESERVE with DirectX";
125  #endif
126      if (b == (UBits)1127743488L)
127        msg = "not compiled with SWAPPED_DOUBLE";
128  #endif
129      if (BAD_SAR)
130        msg = "arithmetic right-shift broken";
131      luaL_error(L, "bit library self-test failed (%s)", msg);
132    }
133  #if LUA_VERSION_NUM < 502
134    luaL_register(L, "bit", bit_funcs);
135  #else
136    luaL_newlib(L, bit_funcs);
137  #endif
138    return 1;
139  }
</code></pre>
        </div>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-mount.fuse.c</h3>
            <pre><code>1  #include "fuse_config.h"
2  #include <stdio.h>
3  #include <stdlib.h>
4  #include <string.h>
5  #include <unistd.h>
6  #include <errno.h>
7  #include <stdint.h>
8  #include <fcntl.h>
9  #include <pwd.h>
10  #include <sys/wait.h>
11  #ifdef linux
12  #include <sys/prctl.h>
13  #include <sys/syscall.h>
14  #include <linux/capability.h>
15  #include <linux/securebits.h>
16  #if !defined(SECBIT_KEEP_CAPS) && defined(SECURE_KEEP_CAPS)
17  #define SECBIT_KEEP_CAPS (issecure_mask(SECURE_KEEP_CAPS))
18  #endif
19  #if !defined(SECBIT_KEEP_CAPS_LOCKED) && defined(SECURE_KEEP_CAPS_LOCKED)
20  #define SECBIT_KEEP_CAPS_LOCKED (issecure_mask(SECURE_KEEP_CAPS_LOCKED))
21  #endif
22  #if !defined(SECBIT_NO_SETUID_FIXUP) && defined(SECURE_NO_SETUID_FIXUP)
23  #define SECBIT_NO_SETUID_FIXUP (issecure_mask(SECURE_NO_SETUID_FIXUP))
24  #endif
25  #if !defined(SECBIT_NO_SETUID_FIXUP_LOCKED) && defined(SECURE_NO_SETUID_FIXUP_LOCKED)
26  #define SECBIT_NO_SETUID_FIXUP_LOCKED (issecure_mask(SECURE_NO_SETUID_FIXUP_LOCKED))
27  #endif
28  #if !defined(SECBIT_NOROOT) && defined(SECURE_NOROOT)
29  #define SECBIT_NOROOT (issecure_mask(SECURE_NOROOT))
30  #endif
31  #if !defined(SECBIT_NOROOT_LOCKED) && defined(SECURE_NOROOT_LOCKED)
32  #define SECBIT_NOROOT_LOCKED (issecure_mask(SECURE_NOROOT_LOCKED))
33  #endif
34  #endif
35  #include "fuse.h"
36  static char *progname;
37  static char *xstrdup(const char *s)
38  {
39  	char *t = strdup(s);
40  	if (!t) {
41  		fprintf(stderr, "%s: failed to allocate memory\n", progname);
42  		exit(1);
43  	}
44  	return t;
45  }
46  static void *xrealloc(void *oldptr, size_t size)
47  {
<span onclick='openModal()' class='match'>48  	void *ptr = realloc(oldptr, size);
49  	if (!ptr) {
50  		fprintf(stderr, "%s: failed to allocate memory\n", progname);
51  		exit(1);
52  	}
53  	return ptr;
54  }
55  static void add_arg(char **cmdp, const char *opt)
</span>56  {
57  	size_t optlen = strlen(opt);
58  	size_t cmdlen = *cmdp ? strlen(*cmdp) : 0;
59  	if (optlen >= (SIZE_MAX - cmdlen - 4)/4) {
60  		fprintf(stderr, "%s: argument too long\n", progname);
61  		exit(1);
62  	}
63  	char *cmd = xrealloc(*cmdp, cmdlen + optlen * 4 + 4);
64  	char *s;
65  	s = cmd + cmdlen;
66  	if (*cmdp)
67  		*s++ = ' ';
68  	*s++ = '\'';
69  	for (; *opt; opt++) {
70  		if (*opt == '\'') {
71  			*s++ = '\'';
72  			*s++ = '\\';
73  			*s++ = '\'';
74  			*s++ = '\'';
75  		} else
76  			*s++ = *opt;
77  	}
78  	*s++ = '\'';
79  	*s = '\0';
80  	*cmdp = cmd;
81  }
82  static char *add_option(const char *opt, char *options)
83  {
84  	int oldlen = options ? strlen(options) : 0;
85  	options = xrealloc(options, oldlen + 1 + strlen(opt) + 1);
86  	if (!oldlen)
87  		strcpy(options, opt);
88  	else {
89  		strcat(options, ",");
90  		strcat(options, opt);
91  	}
92  	return options;
93  }
94  static int prepare_fuse_fd(const char *mountpoint, const char* subtype,
95  			   const char *options)
96  {
97  	int fuse_fd = -1;
98  	int flags = -1;
99  	int subtype_len = strlen(subtype) + 9;
100  	char* options_copy = xrealloc(NULL, subtype_len);
101  	snprintf(options_copy, subtype_len, "subtype=%s", subtype);
102  	options_copy = add_option(options, options_copy);
103  	fuse_fd = fuse_open_channel(mountpoint, options_copy);
104  	if (fuse_fd == -1) {
105  		exit(1);
106  	}
107  	flags = fcntl(fuse_fd, F_GETFD);
108  	if (flags == -1 || fcntl(fuse_fd, F_SETFD, flags & ~FD_CLOEXEC) == 1) {
109  		fprintf(stderr, "%s: Failed to clear CLOEXEC: %s\n",
110  			progname, strerror(errno));
111  		exit(1);
112  	}
113  	return fuse_fd;
114  }
115  #ifdef linux
116  static uint64_t get_capabilities(void)
117  {
118  	struct __user_cap_header_struct header = {
119  		.version = _LINUX_CAPABILITY_VERSION_3,
120  		.pid = 0,
121  	};
122  	struct __user_cap_data_struct data[2];
123  	memset(data, 0, sizeof(data));
124  	if (syscall(SYS_capget, &header, data) == -1) {
125  		fprintf(stderr, "%s: Failed to get capabilities: %s\n",
126  			progname, strerror(errno));
127  		exit(1);
128  	}
129  	return data[0].effective | ((uint64_t) data[1].effective << 32);
130  }
131  static void set_capabilities(uint64_t caps)
132  {
133  	struct __user_cap_header_struct header = {
134  		.version = _LINUX_CAPABILITY_VERSION_3,
135  		.pid = 0,
136  	};
137  	struct __user_cap_data_struct data[2];
138  	memset(data, 0, sizeof(data));
139  	data[0].effective = data[0].permitted = caps;
140  	data[1].effective = data[1].permitted = caps >> 32;
141  	if (syscall(SYS_capset, &header, data) == -1) {
142  		fprintf(stderr, "%s: Failed to set capabilities: %s\n",
143  			progname, strerror(errno));
144  		exit(1);
145  	}
146  }
147  static void drop_and_lock_capabilities(void)
148  {
149  	if (prctl(PR_SET_SECUREBITS,
150  		  SECBIT_KEEP_CAPS_LOCKED |
151  		  SECBIT_NO_SETUID_FIXUP |
152  		  SECBIT_NO_SETUID_FIXUP_LOCKED |
153  		  SECBIT_NOROOT |
154  		  SECBIT_NOROOT_LOCKED) == -1) {
155  		fprintf(stderr, "%s: Failed to set securebits %s\n",
156  			progname, strerror(errno));
157  		exit(1);
158  	}
159  	int cap;
160  	for (cap = 0; ; cap++) {
161  		int cap_status = prctl(PR_CAPBSET_READ, cap);
162  		if (cap_status == 0) {
163  			continue;
164  		}
165  		if (cap_status == -1 && errno == EINVAL) {
166  			break;
167  		}
168  		if (cap_status != 1) {
169  			fprintf(stderr,
170  				"%s: Failed to get capability %u: %s\n",
171  				progname, cap, strerror(errno));
172  			exit(1);
173  		}
174  		if (prctl(PR_CAPBSET_DROP, cap) == -1) {
175  			fprintf(stderr,
176  				"%s: Failed to drop capability %u: %s\n",
177  				progname, cap, strerror(errno));
178  		}
179  	}
180  	set_capabilities(0);
181  	if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) == -1) {
182  		fprintf(stderr, "%s: Failed to set no_new_privs: %s\n",
183  			progname, strerror(errno));
184  		exit(1);
185  	}
186  }
187  #endif
188  int main(int argc, char *argv[])
189  {
190  	char *type = NULL;
191  	char *source;
192  	char *dup_source = NULL;
193  	const char *mountpoint;
194  	char *basename;
195  	char *options = NULL;
196  	char *command = NULL;
197  	char *setuid_name = NULL;
198  	int i;
199  	int dev = 1;
200  	int suid = 1;
201  	int pass_fuse_fd = 0;
202  	int fuse_fd = 0;
203  	int drop_privileges = 0;
204  	char *dev_fd_mountpoint = NULL;
205  	progname = argv[0];
206  	basename = strrchr(argv[0], '/');
207  	if (basename)
208  		basename++;
209  	else
210  		basename = argv[0];
211  	if (strncmp(basename, "mount.fuse.", 11) == 0)
212  		type = basename + 11;
213  	if (strncmp(basename, "mount.fuseblk.", 14) == 0)
214  		type = basename + 14;
215  	if (type && !type[0])
216  		type = NULL;
217  	if (argc < 3) {
218  		fprintf(stderr,
219  			"usage: %s %s destination [-t type] [-o opt[,opts...]]\n",
220  			progname, type ? "source" : "type#[source]");
221  		exit(1);
222  	}
223  	source = argv[1];
224  	if (!source[0])
225  		source = NULL;
226  	mountpoint = argv[2];
227  	for (i = 3; i < argc; i++) {
228  		if (strcmp(argv[i], "-v") == 0) {
229  			continue;
230  		} else if (strcmp(argv[i], "-t") == 0) {
231  			i++;
232  			if (i == argc) {
233  				fprintf(stderr,
234  					"%s: missing argument to option '-t'\n",
235  					progname);
236  				exit(1);
237  			}
238  			type = argv[i];
239  			if (strncmp(type, "fuse.", 5) == 0)
240  				type += 5;
241  			else if (strncmp(type, "fuseblk.", 8) == 0)
242  				type += 8;
243  			if (!type[0]) {
244  				fprintf(stderr,
245  					"%s: empty type given as argument to option '-t'\n",
246  					progname);
247  				exit(1);
248  			}
249  		} else	if (strcmp(argv[i], "-o") == 0) {
250  			char *opts;
251  			char *opt;
252  			i++;
253  			if (i == argc)
254  				break;
255  			opts = xstrdup(argv[i]);
256  			opt = strtok(opts, ",");
257  			while (opt) {
258  				int j;
259  				int ignore = 0;
260  				const char *ignore_opts[] = { "",
261  							      "user",
262  							      "nofail",
263  							      "nouser",
264  							      "users",
265  							      "auto",
266  							      "noauto",
267  							      "_netdev",
268  							      NULL};
269  				if (strncmp(opt, "setuid=", 7) == 0) {
270  					setuid_name = xstrdup(opt + 7);
271  					ignore = 1;
272  				} else if (strcmp(opt,
273  						  "drop_privileges") == 0) {
274  					pass_fuse_fd = 1;
275  					drop_privileges = 1;
276  					ignore = 1;
277  				}
278  				for (j = 0; ignore_opts[j]; j++)
279  					if (strcmp(opt, ignore_opts[j]) == 0)
280  						ignore = 1;
281  				if (!ignore) {
282  					if (strcmp(opt, "nodev") == 0)
283  						dev = 0;
284  					else if (strcmp(opt, "nosuid") == 0)
285  						suid = 0;
286  					options = add_option(opt, options);
287  				}
288  				opt = strtok(NULL, ",");
289  			}
290  			free(opts);
291  		}
292  	}
293  	if (drop_privileges) {
294  		uint64_t required_caps = CAP_TO_MASK(CAP_SETPCAP) |
295  				CAP_TO_MASK(CAP_SYS_ADMIN);
296  		if ((get_capabilities() & required_caps) != required_caps) {
297  			fprintf(stderr, "%s: drop_privileges was requested, which launches the FUSE file system fully unprivileged. In order to do so %s must be run with privileges, please invoke with CAP_SYS_ADMIN and CAP_SETPCAP (e.g. as root).\n",
298  			progname, progname);
299  			exit(1);
300  		}
301  	}
302  	if (dev)
303  		options = add_option("dev", options);
304  	if (suid)
305  		options = add_option("suid", options);
306  	if (!type) {
307  		if (source) {
308  			dup_source = xstrdup(source);
309  			type = dup_source;
310  			source = strchr(type, '#');
311  			if (source)
312  				*source++ = '\0';
313  			if (!type[0]) {
314  				fprintf(stderr, "%s: empty filesystem type\n",
315  					progname);
316  				exit(1);
317  			}
318  		} else {
319  			fprintf(stderr, "%s: empty source\n", progname);
320  			exit(1);
321  		}
322  	}
323  	if (setuid_name && setuid_name[0]) {
324  #ifdef linux
325  		if (drop_privileges) {
326  			if (prctl(PR_SET_SECUREBITS,
327  				  SECBIT_KEEP_CAPS |
328  				  SECBIT_NO_SETUID_FIXUP) == -1) {
329  				fprintf(stderr,
330  					"%s: Failed to set securebits %s\n",
331  					progname, strerror(errno));
332  				exit(1);
333  			}
334  		}
335  #endif
336  		struct passwd *pwd = getpwnam(setuid_name);
337  		if (!pwd || setgid(pwd->pw_gid) == -1 || setuid(pwd->pw_uid) == -1) {
338  			fprintf(stderr, "%s: Failed to setuid to %s: %s\n",
339  				progname, setuid_name, strerror(errno));
340  			exit(1);
341  		}
342  	} else if (!getenv("HOME")) {
343  		setenv("HOME", "/root", 0);
344  	}
345  	if (pass_fuse_fd)  {
346  		fuse_fd = prepare_fuse_fd(mountpoint, type, options);
347  		dev_fd_mountpoint = xrealloc(NULL, 20);
348  		snprintf(dev_fd_mountpoint, 20, "/dev/fd/%u", fuse_fd);
349  		mountpoint = dev_fd_mountpoint;
350  	}
351  #ifdef linux
352  	if (drop_privileges) {
353  		drop_and_lock_capabilities();
354  	}
355  #endif
356  	add_arg(&command, type);
357  	if (source)
358  		add_arg(&command, source);
359  	add_arg(&command, mountpoint);
360  	if (options) {
361  		add_arg(&command, "-o");
362  		add_arg(&command, options);
363  	}
364  	free(options);
365  	free(dev_fd_mountpoint);
366  	free(dup_source);
367  	free(setuid_name);
368  	execl("/bin/sh", "/bin/sh", "-c", command, NULL);
369  	fprintf(stderr, "%s: failed to execute /bin/sh: %s\n", progname,
370  		strerror(errno));
371  	if (pass_fuse_fd)
372  		close(fuse_fd);
373  	free(command);
374  	return 1;
375  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lua_bit.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-mount.fuse.c</div>
                <div class="column column_space"><pre><code>44      b = (UBits)(SBits)bn.n;
45  #elif defined(LUA_NUMBER_FLOAT)
46  #error "A 'float' lua_Number type is incompatible with this library"
47  #else
48  #error "Unknown number type, check LUA_NUMBER_* in luaconf.h"
49  #endif
50  #if LUA_VERSION_NUM < 502
51    if (b == 0 && !lua_isnumber(L, idx)) {
52      luaL_typerror(L, idx, "number");
53    }
54  #endif
55    return b;
56  }
57  #define BRET(b)  lua_pushnumber(L, (lua_Number)(SBits)(b)); return 1;
58  static int bit_tobit(lua_State *L) { BRET(barg(L, 1)) }
</pre></code></div>
                <div class="column column_space"><pre><code>48  	void *ptr = realloc(oldptr, size);
49  	if (!ptr) {
50  		fprintf(stderr, "%s: failed to allocate memory\n", progname);
51  		exit(1);
52  	}
53  	return ptr;
54  }
55  static void add_arg(char **cmdp, const char *opt)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    