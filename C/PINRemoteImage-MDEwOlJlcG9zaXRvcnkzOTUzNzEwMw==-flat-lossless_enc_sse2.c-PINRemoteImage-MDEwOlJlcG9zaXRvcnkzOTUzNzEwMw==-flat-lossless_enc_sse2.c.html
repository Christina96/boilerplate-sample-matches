
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 51, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_enc_sse2.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_SSE2)
3  #include <assert.h>
4  #include <emmintrin.h>
5  #include "src/dsp/lossless.h"
6  #include "src/dsp/common_sse2.h"
7  #include "src/dsp/lossless_common.h"
8  #define CST_5b(X)  (((int16_t)((uint16_t)(X) << 8)) >> 5)
9  static void SubtractGreenFromBlueAndRed_SSE2(uint32_t* argb_data,
10                                               int num_pixels) {
11    int i;
12    for (i = 0; i + 4 <= num_pixels; i += 4) {
13      const __m128i in = _mm_loadu_si128((__m128i*)&argb_data[i]); 
14      const __m128i A = _mm_srli_epi16(in, 8);     
15      const __m128i B = _mm_shufflelo_epi16(A, _MM_SHUFFLE(2, 2, 0, 0));
16      const __m128i C = _mm_shufflehi_epi16(B, _MM_SHUFFLE(2, 2, 0, 0));  
17      const __m128i out = _mm_sub_epi8(in, C);
18      _mm_storeu_si128((__m128i*)&argb_data[i], out);
19    }
20    if (i != num_pixels) {
21      VP8LSubtractGreenFromBlueAndRed_C(argb_data + i, num_pixels - i);
22    }
23  }
24  #define MK_CST_16(HI, LO) \
25    _mm_set1_epi32((int)(((uint32_t)(HI) << 16) | ((LO) & 0xffff)))
26  static void TransformColor_SSE2(const VP8LMultipliers* const m,
27                                  uint32_t* argb_data, int num_pixels) {
28    const __m128i mults_rb = MK_CST_16(CST_5b(m->green_to_red_),
29                                       CST_5b(m->green_to_blue_));
30    const __m128i mults_b2 = MK_CST_16(CST_5b(m->red_to_blue_), 0);
31    const __m128i mask_ag = _mm_set1_epi32(0xff00ff00);  
32    const __m128i mask_rb = _mm_set1_epi32(0x00ff00ff);  
33    int i;
34    for (i = 0; i + 4 <= num_pixels; i += 4) {
35      const __m128i in = _mm_loadu_si128((__m128i*)&argb_data[i]); 
36      const __m128i A = _mm_and_si128(in, mask_ag);     
37      const __m128i B = _mm_shufflelo_epi16(A, _MM_SHUFFLE(2, 2, 0, 0));
38      const __m128i C = _mm_shufflehi_epi16(B, _MM_SHUFFLE(2, 2, 0, 0));  
39      const __m128i D = _mm_mulhi_epi16(C, mults_rb);    
40      const __m128i E = _mm_slli_epi16(in, 8);           
41      const __m128i F = _mm_mulhi_epi16(E, mults_b2);    
42      const __m128i G = _mm_srli_epi32(F, 16);           
43      const __m128i H = _mm_add_epi8(G, D);              
44      const __m128i I = _mm_and_si128(H, mask_rb);       
45      const __m128i out = _mm_sub_epi8(in, I);
46      _mm_storeu_si128((__m128i*)&argb_data[i], out);
47    }
48    if (i != num_pixels) {
49      VP8LTransformColor_C(m, argb_data + i, num_pixels - i);
50    }
51  }
52  #define SPAN 8
53  static void CollectColorBlueTransforms_SSE2(const uint32_t* argb, int stride,
54                                              int tile_width, int tile_height,
55                                              int green_to_blue, int red_to_blue,
56                                              int histo[]) {
57    const __m128i mults_r = MK_CST_16(CST_5b(red_to_blue), 0);
58    const __m128i mults_g = MK_CST_16(0, CST_5b(green_to_blue));
59    const __m128i mask_g = _mm_set1_epi32(0x00ff00);  
60    const __m128i mask_b = _mm_set1_epi32(0x0000ff);  
61    int y;
62    for (y = 0; y < tile_height; ++y) {
63      const uint32_t* const src = argb + y * stride;
64      int i, x;
65      for (x = 0; x + SPAN <= tile_width; x += SPAN) {
66        uint16_t values[SPAN];
67        const __m128i in0 = _mm_loadu_si128((__m128i*)&src[x +        0]);
68        const __m128i in1 = _mm_loadu_si128((__m128i*)&src[x + SPAN / 2]);
69        const __m128i A0 = _mm_slli_epi16(in0, 8);        
70        const __m128i A1 = _mm_slli_epi16(in1, 8);
71        const __m128i B0 = _mm_and_si128(in0, mask_g);    
72        const __m128i B1 = _mm_and_si128(in1, mask_g);
73        const __m128i C0 = _mm_mulhi_epi16(A0, mults_r);  
74        const __m128i C1 = _mm_mulhi_epi16(A1, mults_r);
75        const __m128i D0 = _mm_mulhi_epi16(B0, mults_g);  
76        const __m128i D1 = _mm_mulhi_epi16(B1, mults_g);
77        const __m128i E0 = _mm_sub_epi8(in0, D0);         
78        const __m128i E1 = _mm_sub_epi8(in1, D1);
79        const __m128i F0 = _mm_srli_epi32(C0, 16);        
80        const __m128i F1 = _mm_srli_epi32(C1, 16);
81        const __m128i G0 = _mm_sub_epi8(E0, F0);          
82        const __m128i G1 = _mm_sub_epi8(E1, F1);
83        const __m128i H0 = _mm_and_si128(G0, mask_b);     
84        const __m128i H1 = _mm_and_si128(G1, mask_b);
85        const __m128i I = _mm_packs_epi32(H0, H1);        
86        _mm_storeu_si128((__m128i*)values, I);
87        for (i = 0; i < SPAN; ++i) ++histo[values[i]];
88      }
89    }
90    {
91      const int left_over = tile_width & (SPAN - 1);
92      if (left_over > 0) {
93        VP8LCollectColorBlueTransforms_C(argb + tile_width - left_over, stride,
94                                         left_over, tile_height,
95                                         green_to_blue, red_to_blue, histo);
96      }
97    }
98  }
99  static void CollectColorRedTransforms_SSE2(const uint32_t* argb, int stride,
100                                             int tile_width, int tile_height,
101                                             int green_to_red, int histo[]) {
102    const __m128i mults_g = MK_CST_16(0, CST_5b(green_to_red));
103    const __m128i mask_g = _mm_set1_epi32(0x00ff00);  
104    const __m128i mask = _mm_set1_epi32(0xff);
105    int y;
106    for (y = 0; y < tile_height; ++y) {
107      const uint32_t* const src = argb + y * stride;
108      int i, x;
109      for (x = 0; x + SPAN <= tile_width; x += SPAN) {
110        uint16_t values[SPAN];
111        const __m128i in0 = _mm_loadu_si128((__m128i*)&src[x +        0]);
112        const __m128i in1 = _mm_loadu_si128((__m128i*)&src[x + SPAN / 2]);
113        const __m128i A0 = _mm_and_si128(in0, mask_g);    
114        const __m128i A1 = _mm_and_si128(in1, mask_g);
115        const __m128i B0 = _mm_srli_epi32(in0, 16);       
116        const __m128i B1 = _mm_srli_epi32(in1, 16);
117        const __m128i C0 = _mm_mulhi_epi16(A0, mults_g);  
118        const __m128i C1 = _mm_mulhi_epi16(A1, mults_g);
119        const __m128i E0 = _mm_sub_epi8(B0, C0);          
120        const __m128i E1 = _mm_sub_epi8(B1, C1);
121        const __m128i F0 = _mm_and_si128(E0, mask);       
122        const __m128i F1 = _mm_and_si128(E1, mask);
123        const __m128i I = _mm_packs_epi32(F0, F1);
124        _mm_storeu_si128((__m128i*)values, I);
125        for (i = 0; i < SPAN; ++i) ++histo[values[i]];
126      }
127    }
128    {
129      const int left_over = tile_width & (SPAN - 1);
130      if (left_over > 0) {
131        VP8LCollectColorRedTransforms_C(argb + tile_width - left_over, stride,
132                                        left_over, tile_height,
133                                        green_to_red, histo);
134      }
135    }
136  }
137  #undef SPAN
138  #undef MK_CST_16
139  #define LINE_SIZE 16    
140  static void AddVector_SSE2(const uint32_t* a, const uint32_t* b, uint32_t* out,
141                             int size) {
142    int i;
143    for (i = 0; i + LINE_SIZE <= size; i += LINE_SIZE) {
144      const __m128i a0 = _mm_loadu_si128((const __m128i*)&a[i +  0]);
145      const __m128i a1 = _mm_loadu_si128((const __m128i*)&a[i +  4]);
146  #if (LINE_SIZE == 16)
147      const __m128i a2 = _mm_loadu_si128((const __m128i*)&a[i +  8]);
148      const __m128i a3 = _mm_loadu_si128((const __m128i*)&a[i + 12]);
149  #endif
150      const __m128i b0 = _mm_loadu_si128((const __m128i*)&b[i +  0]);
151      const __m128i b1 = _mm_loadu_si128((const __m128i*)&b[i +  4]);
152  #if (LINE_SIZE == 16)
153      const __m128i b2 = _mm_loadu_si128((const __m128i*)&b[i +  8]);
154      const __m128i b3 = _mm_loadu_si128((const __m128i*)&b[i + 12]);
155  #endif
156      _mm_storeu_si128((__m128i*)&out[i +  0], _mm_add_epi32(a0, b0));
157      _mm_storeu_si128((__m128i*)&out[i +  4], _mm_add_epi32(a1, b1));
158  #if (LINE_SIZE == 16)
159      _mm_storeu_si128((__m128i*)&out[i +  8], _mm_add_epi32(a2, b2));
160      _mm_storeu_si128((__m128i*)&out[i + 12], _mm_add_epi32(a3, b3));
161  #endif
162    }
163    for (; i < size; ++i) {
164      out[i] = a[i] + b[i];
165    }
166  }
167  static void AddVectorEq_SSE2(const uint32_t* a, uint32_t* out, int size) {
168    int i;
169    for (i = 0; i + LINE_SIZE <= size; i += LINE_SIZE) {
170      const __m128i a0 = _mm_loadu_si128((const __m128i*)&a[i +  0]);
171      const __m128i a1 = _mm_loadu_si128((const __m128i*)&a[i +  4]);
172  #if (LINE_SIZE == 16)
173      const __m128i a2 = _mm_loadu_si128((const __m128i*)&a[i +  8]);
174      const __m128i a3 = _mm_loadu_si128((const __m128i*)&a[i + 12]);
175  #endif
176      const __m128i b0 = _mm_loadu_si128((const __m128i*)&out[i +  0]);
177      const __m128i b1 = _mm_loadu_si128((const __m128i*)&out[i +  4]);
178  #if (LINE_SIZE == 16)
179      const __m128i b2 = _mm_loadu_si128((const __m128i*)&out[i +  8]);
180      const __m128i b3 = _mm_loadu_si128((const __m128i*)&out[i + 12]);
181  #endif
182      _mm_storeu_si128((__m128i*)&out[i +  0], _mm_add_epi32(a0, b0));
183      _mm_storeu_si128((__m128i*)&out[i +  4], _mm_add_epi32(a1, b1));
184  #if (LINE_SIZE == 16)
185      _mm_storeu_si128((__m128i*)&out[i +  8], _mm_add_epi32(a2, b2));
186      _mm_storeu_si128((__m128i*)&out[i + 12], _mm_add_epi32(a3, b3));
187  #endif
188    }
189    for (; i < size; ++i) {
190      out[i] += a[i];
191    }
192  }
193  #undef LINE_SIZE
194  #define ANALYZE_X_OR_Y(x_or_y, j)                                           \
195    do {                                                                      \
196      if ((x_or_y)[i + (j)] != 0) retval -= VP8LFastSLog2((x_or_y)[i + (j)]); \
197    } while (0)
198  #define ANALYZE_XY(j)                  \
199    do {                                 \
200      if (tmp[j] != 0) {                 \
201        retval -= VP8LFastSLog2(tmp[j]); \
202        ANALYZE_X_OR_Y(X, j);            \
203      }                                  \
204    } while (0)
205  static float CombinedShannonEntropy_SSE2(const int X[256], const int Y[256]) {
206    int i;
207    double retval = 0.;
208    int sumX, sumXY;
209    int32_t tmp[4];
210    __m128i zero = _mm_setzero_si128();
211    __m128i sumXY_128 = zero;
212    __m128i sumX_128 = zero;
213    for (i = 0; i < 256; i += 4) {
214      const __m128i x = _mm_loadu_si128((const __m128i*)(X + i));
215      const __m128i y = _mm_loadu_si128((const __m128i*)(Y + i));
216      if (_mm_movemask_epi8(_mm_cmpeq_epi32(x, zero)) != 0xFFFF) {
217        const __m128i xy_128 = _mm_add_epi32(x, y);
218        sumXY_128 = _mm_add_epi32(sumXY_128, xy_128);
219        sumX_128 = _mm_add_epi32(sumX_128, x);
220        _mm_storeu_si128((__m128i*)tmp, xy_128);
221        ANALYZE_XY(0);
222        ANALYZE_XY(1);
223        ANALYZE_XY(2);
224        ANALYZE_XY(3);
225      } else {
226        sumXY_128 = _mm_add_epi32(sumXY_128, y);
227        ANALYZE_X_OR_Y(Y, 0);
228        ANALYZE_X_OR_Y(Y, 1);
229        ANALYZE_X_OR_Y(Y, 2);
230        ANALYZE_X_OR_Y(Y, 3);
231      }
232    }
233    _mm_storeu_si128((__m128i*)tmp, sumX_128);
234    sumX = tmp[3] + tmp[2] + tmp[1] + tmp[0];
235    _mm_storeu_si128((__m128i*)tmp, sumXY_128);
236    sumXY = tmp[3] + tmp[2] + tmp[1] + tmp[0];
237    retval += VP8LFastSLog2(sumX) + VP8LFastSLog2(sumXY);
238    return (float)retval;
239  }
240  #undef ANALYZE_X_OR_Y
241  #undef ANALYZE_XY
242  static int VectorMismatch_SSE2(const uint32_t* const array1,
243                                 const uint32_t* const array2, int length) {
244    int match_len;
245    if (length >= 12) {
246      __m128i A0 = _mm_loadu_si128((const __m128i*)&array1[0]);
247      __m128i A1 = _mm_loadu_si128((const __m128i*)&array2[0]);
248      match_len = 0;
249      do {
250        const __m128i cmpA = _mm_cmpeq_epi32(A0, A1);
251        const __m128i B0 =
252            _mm_loadu_si128((const __m128i*)&array1[match_len + 4]);
253        const __m128i B1 =
254            _mm_loadu_si128((const __m128i*)&array2[match_len + 4]);
255        if (_mm_movemask_epi8(cmpA) != 0xffff) break;
256        match_len += 4;
257        {
258          const __m128i cmpB = _mm_cmpeq_epi32(B0, B1);
259          A0 = _mm_loadu_si128((const __m128i*)&array1[match_len + 4]);
260          A1 = _mm_loadu_si128((const __m128i*)&array2[match_len + 4]);
261          if (_mm_movemask_epi8(cmpB) != 0xffff) break;
262          match_len += 4;
263        }
264      } while (match_len + 12 < length);
265    } else {
<span onclick='openModal()' class='match'>266      match_len = 0;
267      if (length >= 4 &&
268          _mm_movemask_epi8(_mm_cmpeq_epi32(
269              _mm_loadu_si128((const __m128i*)&array1[0]),
270              _mm_loadu_si128((const __m128i*)&array2[0]))) == 0xffff) {
271        match_len = 4;
272        if (length >= 8 &&
</span>273            _mm_movemask_epi8(_mm_cmpeq_epi32(
274                _mm_loadu_si128((const __m128i*)&array1[4]),
275                _mm_loadu_si128((const __m128i*)&array2[4]))) == 0xffff) {
276          match_len = 8;
277        }
278      }
279    }
280    while (match_len < length && array1[match_len] == array2[match_len]) {
281      ++match_len;
282    }
283    return match_len;
284  }
285  static void BundleColorMap_SSE2(const uint8_t* const row, int width, int xbits,
286                                  uint32_t* dst) {
287    int x;
288    assert(xbits >= 0);
289    assert(xbits <= 3);
290    switch (xbits) {
291      case 0: {
292        const __m128i ff = _mm_set1_epi16((short)0xff00);
293        const __m128i zero = _mm_setzero_si128();
294        for (x = 0; x + 16 <= width; x += 16, dst += 16) {
295          const __m128i in = _mm_loadu_si128((const __m128i*)&row[x]);
296          const __m128i in_lo = _mm_unpacklo_epi8(zero, in);
297          const __m128i dst0 = _mm_unpacklo_epi16(in_lo, ff);
298          const __m128i dst1 = _mm_unpackhi_epi16(in_lo, ff);
299          const __m128i in_hi = _mm_unpackhi_epi8(zero, in);
300          const __m128i dst2 = _mm_unpacklo_epi16(in_hi, ff);
301          const __m128i dst3 = _mm_unpackhi_epi16(in_hi, ff);
302          _mm_storeu_si128((__m128i*)&dst[0], dst0);
303          _mm_storeu_si128((__m128i*)&dst[4], dst1);
304          _mm_storeu_si128((__m128i*)&dst[8], dst2);
305          _mm_storeu_si128((__m128i*)&dst[12], dst3);
306        }
307        break;
308      }
309      case 1: {
310        const __m128i ff = _mm_set1_epi16((short)0xff00);
311        const __m128i mul = _mm_set1_epi16(0x110);
312        for (x = 0; x + 16 <= width; x += 16, dst += 8) {
313          const __m128i in = _mm_loadu_si128((const __m128i*)&row[x]);
314          const __m128i tmp = _mm_mullo_epi16(in, mul);  
315          const __m128i pack = _mm_and_si128(tmp, ff);   
316          const __m128i dst0 = _mm_unpacklo_epi16(pack, ff);
317          const __m128i dst1 = _mm_unpackhi_epi16(pack, ff);
318          _mm_storeu_si128((__m128i*)&dst[0], dst0);
319          _mm_storeu_si128((__m128i*)&dst[4], dst1);
320        }
321        break;
322      }
323      case 2: {
324        const __m128i mask_or = _mm_set1_epi32(0xff000000);
325        const __m128i mul_cst = _mm_set1_epi16(0x0104);
326        const __m128i mask_mul = _mm_set1_epi16(0x0f00);
327        for (x = 0; x + 16 <= width; x += 16, dst += 4) {
328          const __m128i in = _mm_loadu_si128((const __m128i*)&row[x]);
329          const __m128i mul = _mm_mullo_epi16(in, mul_cst);  
330          const __m128i tmp = _mm_and_si128(mul, mask_mul);  
331          const __m128i shift = _mm_srli_epi32(tmp, 12);     
332          const __m128i pack = _mm_or_si128(shift, tmp);     
333          const __m128i res = _mm_or_si128(pack, mask_or);
334          _mm_storeu_si128((__m128i*)dst, res);
335        }
336        break;
337      }
338      default: {
339        assert(xbits == 3);
340        for (x = 0; x + 16 <= width; x += 16, dst += 2) {
341          const __m128i in = _mm_loadu_si128((const __m128i*)&row[x]);
342          const __m128i shift = _mm_slli_epi64(in, 7);
343          const uint32_t move = _mm_movemask_epi8(shift);
344          dst[0] = 0xff000000 | ((move & 0xff) << 8);
345          dst[1] = 0xff000000 | (move & 0xff00);
346        }
347        break;
348      }
349    }
350    if (x != width) {
351      VP8LBundleColorMap_C(row + x, width - x, xbits, dst);
352    }
353  }
354  static WEBP_INLINE void Average2_m128i(const __m128i* const a0,
355                                         const __m128i* const a1,
356                                         __m128i* const avg) {
357    const __m128i ones = _mm_set1_epi8(1);
358    const __m128i avg1 = _mm_avg_epu8(*a0, *a1);
359    const __m128i one = _mm_and_si128(_mm_xor_si128(*a0, *a1), ones);
360    *avg = _mm_sub_epi8(avg1, one);
361  }
362  static void PredictorSub0_SSE2(const uint32_t* in, const uint32_t* upper,
363                                 int num_pixels, uint32_t* out) {
364    int i;
365    const __m128i black = _mm_set1_epi32(ARGB_BLACK);
366    for (i = 0; i + 4 <= num_pixels; i += 4) {
367      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
368      const __m128i res = _mm_sub_epi8(src, black);
369      _mm_storeu_si128((__m128i*)&out[i], res);
370    }
371    if (i != num_pixels) {
372      VP8LPredictorsSub_C[0](in + i, NULL, num_pixels - i, out + i);
373    }
374    (void)upper;
375  }
376  #define GENERATE_PREDICTOR_1(X, IN)                                           \
377  static void PredictorSub##X##_SSE2(const uint32_t* in, const uint32_t* upper, \
378                                     int num_pixels, uint32_t* out) {           \
379    int i;                                                                      \
380    for (i = 0; i + 4 <= num_pixels; i += 4) {                                  \
381      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);              \
382      const __m128i pred = _mm_loadu_si128((const __m128i*)&(IN));              \
383      const __m128i res = _mm_sub_epi8(src, pred);                              \
384      _mm_storeu_si128((__m128i*)&out[i], res);                                 \
385    }                                                                           \
386    if (i != num_pixels) {                                                      \
387      VP8LPredictorsSub_C[(X)](in + i, upper + i, num_pixels - i, out + i);     \
388    }                                                                           \
389  }
390  GENERATE_PREDICTOR_1(1, in[i - 1])       
391  GENERATE_PREDICTOR_1(2, upper[i])        
392  GENERATE_PREDICTOR_1(3, upper[i + 1])    
393  GENERATE_PREDICTOR_1(4, upper[i - 1])    
394  #undef GENERATE_PREDICTOR_1
395  static void PredictorSub5_SSE2(const uint32_t* in, const uint32_t* upper,
396                                 int num_pixels, uint32_t* out) {
397    int i;
398    for (i = 0; i + 4 <= num_pixels; i += 4) {
399      const __m128i L = _mm_loadu_si128((const __m128i*)&in[i - 1]);
400      const __m128i T = _mm_loadu_si128((const __m128i*)&upper[i]);
401      const __m128i TR = _mm_loadu_si128((const __m128i*)&upper[i + 1]);
402      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
403      __m128i avg, pred, res;
404      Average2_m128i(&L, &TR, &avg);
405      Average2_m128i(&avg, &T, &pred);
406      res = _mm_sub_epi8(src, pred);
407      _mm_storeu_si128((__m128i*)&out[i], res);
408    }
409    if (i != num_pixels) {
410      VP8LPredictorsSub_C[5](in + i, upper + i, num_pixels - i, out + i);
411    }
412  }
413  #define GENERATE_PREDICTOR_2(X, A, B)                                         \
414  static void PredictorSub##X##_SSE2(const uint32_t* in, const uint32_t* upper, \
415                                     int num_pixels, uint32_t* out) {           \
416    int i;                                                                      \
417    for (i = 0; i + 4 <= num_pixels; i += 4) {                                  \
418      const __m128i tA = _mm_loadu_si128((const __m128i*)&(A));                 \
419      const __m128i tB = _mm_loadu_si128((const __m128i*)&(B));                 \
420      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);              \
421      __m128i pred, res;                                                        \
422      Average2_m128i(&tA, &tB, &pred);                                          \
423      res = _mm_sub_epi8(src, pred);                                            \
424      _mm_storeu_si128((__m128i*)&out[i], res);                                 \
425    }                                                                           \
426    if (i != num_pixels) {                                                      \
427      VP8LPredictorsSub_C[(X)](in + i, upper + i, num_pixels - i, out + i);     \
428    }                                                                           \
429  }
430  GENERATE_PREDICTOR_2(6, in[i - 1], upper[i - 1])   
431  GENERATE_PREDICTOR_2(7, in[i - 1], upper[i])       
432  GENERATE_PREDICTOR_2(8, upper[i - 1], upper[i])    
433  GENERATE_PREDICTOR_2(9, upper[i], upper[i + 1])    
434  #undef GENERATE_PREDICTOR_2
435  static void PredictorSub10_SSE2(const uint32_t* in, const uint32_t* upper,
436                                  int num_pixels, uint32_t* out) {
437    int i;
438    for (i = 0; i + 4 <= num_pixels; i += 4) {
439      const __m128i L = _mm_loadu_si128((const __m128i*)&in[i - 1]);
440      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
441      const __m128i TL = _mm_loadu_si128((const __m128i*)&upper[i - 1]);
442      const __m128i T = _mm_loadu_si128((const __m128i*)&upper[i]);
443      const __m128i TR = _mm_loadu_si128((const __m128i*)&upper[i + 1]);
444      __m128i avgTTR, avgLTL, avg, res;
445      Average2_m128i(&T, &TR, &avgTTR);
446      Average2_m128i(&L, &TL, &avgLTL);
447      Average2_m128i(&avgTTR, &avgLTL, &avg);
448      res = _mm_sub_epi8(src, avg);
449      _mm_storeu_si128((__m128i*)&out[i], res);
450    }
451    if (i != num_pixels) {
452      VP8LPredictorsSub_C[10](in + i, upper + i, num_pixels - i, out + i);
453    }
454  }
455  static void GetSumAbsDiff32_SSE2(const __m128i* const A, const __m128i* const B,
456                                   __m128i* const out) {
457    const __m128i A_lo = _mm_unpacklo_epi32(*A, *A);
458    const __m128i B_lo = _mm_unpacklo_epi32(*B, *A);
459    const __m128i A_hi = _mm_unpackhi_epi32(*A, *A);
460    const __m128i B_hi = _mm_unpackhi_epi32(*B, *A);
461    const __m128i s_lo = _mm_sad_epu8(A_lo, B_lo);
462    const __m128i s_hi = _mm_sad_epu8(A_hi, B_hi);
463    *out = _mm_packs_epi32(s_lo, s_hi);
464  }
465  static void PredictorSub11_SSE2(const uint32_t* in, const uint32_t* upper,
466                                  int num_pixels, uint32_t* out) {
467    int i;
468    for (i = 0; i + 4 <= num_pixels; i += 4) {
469      const __m128i L = _mm_loadu_si128((const __m128i*)&in[i - 1]);
470      const __m128i T = _mm_loadu_si128((const __m128i*)&upper[i]);
471      const __m128i TL = _mm_loadu_si128((const __m128i*)&upper[i - 1]);
472      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
473      __m128i pa, pb;
474      GetSumAbsDiff32_SSE2(&T, &TL, &pa);   
475      GetSumAbsDiff32_SSE2(&L, &TL, &pb);   
476      {
477        const __m128i mask = _mm_cmpgt_epi32(pb, pa);
478        const __m128i A = _mm_and_si128(mask, L);
479        const __m128i B = _mm_andnot_si128(mask, T);
480        const __m128i pred = _mm_or_si128(A, B);    
481        const __m128i res = _mm_sub_epi8(src, pred);
482        _mm_storeu_si128((__m128i*)&out[i], res);
483      }
484    }
485    if (i != num_pixels) {
486      VP8LPredictorsSub_C[11](in + i, upper + i, num_pixels - i, out + i);
487    }
488  }
489  static void PredictorSub12_SSE2(const uint32_t* in, const uint32_t* upper,
490                                  int num_pixels, uint32_t* out) {
491    int i;
492    const __m128i zero = _mm_setzero_si128();
493    for (i = 0; i + 4 <= num_pixels; i += 4) {
494      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
495      const __m128i L = _mm_loadu_si128((const __m128i*)&in[i - 1]);
496      const __m128i L_lo = _mm_unpacklo_epi8(L, zero);
497      const __m128i L_hi = _mm_unpackhi_epi8(L, zero);
498      const __m128i T = _mm_loadu_si128((const __m128i*)&upper[i]);
499      const __m128i T_lo = _mm_unpacklo_epi8(T, zero);
500      const __m128i T_hi = _mm_unpackhi_epi8(T, zero);
501      const __m128i TL = _mm_loadu_si128((const __m128i*)&upper[i - 1]);
502      const __m128i TL_lo = _mm_unpacklo_epi8(TL, zero);
503      const __m128i TL_hi = _mm_unpackhi_epi8(TL, zero);
504      const __m128i diff_lo = _mm_sub_epi16(T_lo, TL_lo);
505      const __m128i diff_hi = _mm_sub_epi16(T_hi, TL_hi);
506      const __m128i pred_lo = _mm_add_epi16(L_lo, diff_lo);
507      const __m128i pred_hi = _mm_add_epi16(L_hi, diff_hi);
508      const __m128i pred = _mm_packus_epi16(pred_lo, pred_hi);
509      const __m128i res = _mm_sub_epi8(src, pred);
510      _mm_storeu_si128((__m128i*)&out[i], res);
511    }
512    if (i != num_pixels) {
513      VP8LPredictorsSub_C[12](in + i, upper + i, num_pixels - i, out + i);
514    }
515  }
516  static void PredictorSub13_SSE2(const uint32_t* in, const uint32_t* upper,
517                                  int num_pixels, uint32_t* out) {
518    int i;
519    const __m128i zero = _mm_setzero_si128();
520    for (i = 0; i + 2 <= num_pixels; i += 2) {
521      const __m128i L = _mm_loadl_epi64((const __m128i*)&in[i - 1]);
522      const __m128i src = _mm_loadl_epi64((const __m128i*)&in[i]);
523      const __m128i T = _mm_loadl_epi64((const __m128i*)&upper[i]);
524      const __m128i TL = _mm_loadl_epi64((const __m128i*)&upper[i - 1]);
525      const __m128i L_lo = _mm_unpacklo_epi8(L, zero);
526      const __m128i T_lo = _mm_unpacklo_epi8(T, zero);
527      const __m128i TL_lo = _mm_unpacklo_epi8(TL, zero);
528      const __m128i sum = _mm_add_epi16(T_lo, L_lo);
529      const __m128i avg = _mm_srli_epi16(sum, 1);
530      const __m128i A1 = _mm_sub_epi16(avg, TL_lo);
531      const __m128i bit_fix = _mm_cmpgt_epi16(TL_lo, avg);
532      const __m128i A2 = _mm_sub_epi16(A1, bit_fix);
533      const __m128i A3 = _mm_srai_epi16(A2, 1);
534      const __m128i A4 = _mm_add_epi16(avg, A3);
535      const __m128i pred = _mm_packus_epi16(A4, A4);
536      const __m128i res = _mm_sub_epi8(src, pred);
537      _mm_storel_epi64((__m128i*)&out[i], res);
538    }
539    if (i != num_pixels) {
540      VP8LPredictorsSub_C[13](in + i, upper + i, num_pixels - i, out + i);
541    }
542  }
543  extern void VP8LEncDspInitSSE2(void);
544  WEBP_TSAN_IGNORE_FUNCTION void VP8LEncDspInitSSE2(void) {
545    VP8LSubtractGreenFromBlueAndRed = SubtractGreenFromBlueAndRed_SSE2;
546    VP8LTransformColor = TransformColor_SSE2;
547    VP8LCollectColorBlueTransforms = CollectColorBlueTransforms_SSE2;
548    VP8LCollectColorRedTransforms = CollectColorRedTransforms_SSE2;
549    VP8LAddVector = AddVector_SSE2;
550    VP8LAddVectorEq = AddVectorEq_SSE2;
551    VP8LCombinedShannonEntropy = CombinedShannonEntropy_SSE2;
552    VP8LVectorMismatch = VectorMismatch_SSE2;
553    VP8LBundleColorMap = BundleColorMap_SSE2;
554    VP8LPredictorsSub[0] = PredictorSub0_SSE2;
555    VP8LPredictorsSub[1] = PredictorSub1_SSE2;
556    VP8LPredictorsSub[2] = PredictorSub2_SSE2;
557    VP8LPredictorsSub[3] = PredictorSub3_SSE2;
558    VP8LPredictorsSub[4] = PredictorSub4_SSE2;
559    VP8LPredictorsSub[5] = PredictorSub5_SSE2;
560    VP8LPredictorsSub[6] = PredictorSub6_SSE2;
561    VP8LPredictorsSub[7] = PredictorSub7_SSE2;
562    VP8LPredictorsSub[8] = PredictorSub8_SSE2;
563    VP8LPredictorsSub[9] = PredictorSub9_SSE2;
564    VP8LPredictorsSub[10] = PredictorSub10_SSE2;
565    VP8LPredictorsSub[11] = PredictorSub11_SSE2;
566    VP8LPredictorsSub[12] = PredictorSub12_SSE2;
567    VP8LPredictorsSub[13] = PredictorSub13_SSE2;
568    VP8LPredictorsSub[14] = PredictorSub0_SSE2;  
569    VP8LPredictorsSub[15] = PredictorSub0_SSE2;
570  }
571  #else  
572  WEBP_DSP_INIT_STUB(VP8LEncDspInitSSE2)
573  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_enc_sse2.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_SSE2)
3  #include <assert.h>
4  #include <emmintrin.h>
5  #include "src/dsp/lossless.h"
6  #include "src/dsp/common_sse2.h"
7  #include "src/dsp/lossless_common.h"
8  #define CST_5b(X)  (((int16_t)((uint16_t)(X) << 8)) >> 5)
9  static void SubtractGreenFromBlueAndRed_SSE2(uint32_t* argb_data,
10                                               int num_pixels) {
11    int i;
12    for (i = 0; i + 4 <= num_pixels; i += 4) {
13      const __m128i in = _mm_loadu_si128((__m128i*)&argb_data[i]); 
14      const __m128i A = _mm_srli_epi16(in, 8);     
15      const __m128i B = _mm_shufflelo_epi16(A, _MM_SHUFFLE(2, 2, 0, 0));
16      const __m128i C = _mm_shufflehi_epi16(B, _MM_SHUFFLE(2, 2, 0, 0));  
17      const __m128i out = _mm_sub_epi8(in, C);
18      _mm_storeu_si128((__m128i*)&argb_data[i], out);
19    }
20    if (i != num_pixels) {
21      VP8LSubtractGreenFromBlueAndRed_C(argb_data + i, num_pixels - i);
22    }
23  }
24  #define MK_CST_16(HI, LO) \
25    _mm_set1_epi32((int)(((uint32_t)(HI) << 16) | ((LO) & 0xffff)))
26  static void TransformColor_SSE2(const VP8LMultipliers* const m,
27                                  uint32_t* argb_data, int num_pixels) {
28    const __m128i mults_rb = MK_CST_16(CST_5b(m->green_to_red_),
29                                       CST_5b(m->green_to_blue_));
30    const __m128i mults_b2 = MK_CST_16(CST_5b(m->red_to_blue_), 0);
31    const __m128i mask_ag = _mm_set1_epi32(0xff00ff00);  
32    const __m128i mask_rb = _mm_set1_epi32(0x00ff00ff);  
33    int i;
34    for (i = 0; i + 4 <= num_pixels; i += 4) {
35      const __m128i in = _mm_loadu_si128((__m128i*)&argb_data[i]); 
36      const __m128i A = _mm_and_si128(in, mask_ag);     
37      const __m128i B = _mm_shufflelo_epi16(A, _MM_SHUFFLE(2, 2, 0, 0));
38      const __m128i C = _mm_shufflehi_epi16(B, _MM_SHUFFLE(2, 2, 0, 0));  
39      const __m128i D = _mm_mulhi_epi16(C, mults_rb);    
40      const __m128i E = _mm_slli_epi16(in, 8);           
41      const __m128i F = _mm_mulhi_epi16(E, mults_b2);    
42      const __m128i G = _mm_srli_epi32(F, 16);           
43      const __m128i H = _mm_add_epi8(G, D);              
44      const __m128i I = _mm_and_si128(H, mask_rb);       
45      const __m128i out = _mm_sub_epi8(in, I);
46      _mm_storeu_si128((__m128i*)&argb_data[i], out);
47    }
48    if (i != num_pixels) {
49      VP8LTransformColor_C(m, argb_data + i, num_pixels - i);
50    }
51  }
52  #define SPAN 8
53  static void CollectColorBlueTransforms_SSE2(const uint32_t* argb, int stride,
54                                              int tile_width, int tile_height,
55                                              int green_to_blue, int red_to_blue,
56                                              int histo[]) {
57    const __m128i mults_r = MK_CST_16(CST_5b(red_to_blue), 0);
58    const __m128i mults_g = MK_CST_16(0, CST_5b(green_to_blue));
59    const __m128i mask_g = _mm_set1_epi32(0x00ff00);  
60    const __m128i mask_b = _mm_set1_epi32(0x0000ff);  
61    int y;
62    for (y = 0; y < tile_height; ++y) {
63      const uint32_t* const src = argb + y * stride;
64      int i, x;
65      for (x = 0; x + SPAN <= tile_width; x += SPAN) {
66        uint16_t values[SPAN];
67        const __m128i in0 = _mm_loadu_si128((__m128i*)&src[x +        0]);
68        const __m128i in1 = _mm_loadu_si128((__m128i*)&src[x + SPAN / 2]);
69        const __m128i A0 = _mm_slli_epi16(in0, 8);        
70        const __m128i A1 = _mm_slli_epi16(in1, 8);
71        const __m128i B0 = _mm_and_si128(in0, mask_g);    
72        const __m128i B1 = _mm_and_si128(in1, mask_g);
73        const __m128i C0 = _mm_mulhi_epi16(A0, mults_r);  
74        const __m128i C1 = _mm_mulhi_epi16(A1, mults_r);
75        const __m128i D0 = _mm_mulhi_epi16(B0, mults_g);  
76        const __m128i D1 = _mm_mulhi_epi16(B1, mults_g);
77        const __m128i E0 = _mm_sub_epi8(in0, D0);         
78        const __m128i E1 = _mm_sub_epi8(in1, D1);
79        const __m128i F0 = _mm_srli_epi32(C0, 16);        
80        const __m128i F1 = _mm_srli_epi32(C1, 16);
81        const __m128i G0 = _mm_sub_epi8(E0, F0);          
82        const __m128i G1 = _mm_sub_epi8(E1, F1);
83        const __m128i H0 = _mm_and_si128(G0, mask_b);     
84        const __m128i H1 = _mm_and_si128(G1, mask_b);
85        const __m128i I = _mm_packs_epi32(H0, H1);        
86        _mm_storeu_si128((__m128i*)values, I);
87        for (i = 0; i < SPAN; ++i) ++histo[values[i]];
88      }
89    }
90    {
91      const int left_over = tile_width & (SPAN - 1);
92      if (left_over > 0) {
93        VP8LCollectColorBlueTransforms_C(argb + tile_width - left_over, stride,
94                                         left_over, tile_height,
95                                         green_to_blue, red_to_blue, histo);
96      }
97    }
98  }
99  static void CollectColorRedTransforms_SSE2(const uint32_t* argb, int stride,
100                                             int tile_width, int tile_height,
101                                             int green_to_red, int histo[]) {
102    const __m128i mults_g = MK_CST_16(0, CST_5b(green_to_red));
103    const __m128i mask_g = _mm_set1_epi32(0x00ff00);  
104    const __m128i mask = _mm_set1_epi32(0xff);
105    int y;
106    for (y = 0; y < tile_height; ++y) {
107      const uint32_t* const src = argb + y * stride;
108      int i, x;
109      for (x = 0; x + SPAN <= tile_width; x += SPAN) {
110        uint16_t values[SPAN];
111        const __m128i in0 = _mm_loadu_si128((__m128i*)&src[x +        0]);
112        const __m128i in1 = _mm_loadu_si128((__m128i*)&src[x + SPAN / 2]);
113        const __m128i A0 = _mm_and_si128(in0, mask_g);    
114        const __m128i A1 = _mm_and_si128(in1, mask_g);
115        const __m128i B0 = _mm_srli_epi32(in0, 16);       
116        const __m128i B1 = _mm_srli_epi32(in1, 16);
117        const __m128i C0 = _mm_mulhi_epi16(A0, mults_g);  
118        const __m128i C1 = _mm_mulhi_epi16(A1, mults_g);
119        const __m128i E0 = _mm_sub_epi8(B0, C0);          
120        const __m128i E1 = _mm_sub_epi8(B1, C1);
121        const __m128i F0 = _mm_and_si128(E0, mask);       
122        const __m128i F1 = _mm_and_si128(E1, mask);
123        const __m128i I = _mm_packs_epi32(F0, F1);
124        _mm_storeu_si128((__m128i*)values, I);
125        for (i = 0; i < SPAN; ++i) ++histo[values[i]];
126      }
127    }
128    {
129      const int left_over = tile_width & (SPAN - 1);
130      if (left_over > 0) {
131        VP8LCollectColorRedTransforms_C(argb + tile_width - left_over, stride,
132                                        left_over, tile_height,
133                                        green_to_red, histo);
134      }
135    }
136  }
137  #undef SPAN
138  #undef MK_CST_16
139  #define LINE_SIZE 16    
140  static void AddVector_SSE2(const uint32_t* a, const uint32_t* b, uint32_t* out,
141                             int size) {
142    int i;
143    for (i = 0; i + LINE_SIZE <= size; i += LINE_SIZE) {
144      const __m128i a0 = _mm_loadu_si128((const __m128i*)&a[i +  0]);
145      const __m128i a1 = _mm_loadu_si128((const __m128i*)&a[i +  4]);
146  #if (LINE_SIZE == 16)
147      const __m128i a2 = _mm_loadu_si128((const __m128i*)&a[i +  8]);
148      const __m128i a3 = _mm_loadu_si128((const __m128i*)&a[i + 12]);
149  #endif
150      const __m128i b0 = _mm_loadu_si128((const __m128i*)&b[i +  0]);
151      const __m128i b1 = _mm_loadu_si128((const __m128i*)&b[i +  4]);
152  #if (LINE_SIZE == 16)
153      const __m128i b2 = _mm_loadu_si128((const __m128i*)&b[i +  8]);
154      const __m128i b3 = _mm_loadu_si128((const __m128i*)&b[i + 12]);
155  #endif
156      _mm_storeu_si128((__m128i*)&out[i +  0], _mm_add_epi32(a0, b0));
157      _mm_storeu_si128((__m128i*)&out[i +  4], _mm_add_epi32(a1, b1));
158  #if (LINE_SIZE == 16)
159      _mm_storeu_si128((__m128i*)&out[i +  8], _mm_add_epi32(a2, b2));
160      _mm_storeu_si128((__m128i*)&out[i + 12], _mm_add_epi32(a3, b3));
161  #endif
162    }
163    for (; i < size; ++i) {
164      out[i] = a[i] + b[i];
165    }
166  }
167  static void AddVectorEq_SSE2(const uint32_t* a, uint32_t* out, int size) {
168    int i;
169    for (i = 0; i + LINE_SIZE <= size; i += LINE_SIZE) {
170      const __m128i a0 = _mm_loadu_si128((const __m128i*)&a[i +  0]);
171      const __m128i a1 = _mm_loadu_si128((const __m128i*)&a[i +  4]);
172  #if (LINE_SIZE == 16)
173      const __m128i a2 = _mm_loadu_si128((const __m128i*)&a[i +  8]);
174      const __m128i a3 = _mm_loadu_si128((const __m128i*)&a[i + 12]);
175  #endif
176      const __m128i b0 = _mm_loadu_si128((const __m128i*)&out[i +  0]);
177      const __m128i b1 = _mm_loadu_si128((const __m128i*)&out[i +  4]);
178  #if (LINE_SIZE == 16)
179      const __m128i b2 = _mm_loadu_si128((const __m128i*)&out[i +  8]);
180      const __m128i b3 = _mm_loadu_si128((const __m128i*)&out[i + 12]);
181  #endif
182      _mm_storeu_si128((__m128i*)&out[i +  0], _mm_add_epi32(a0, b0));
183      _mm_storeu_si128((__m128i*)&out[i +  4], _mm_add_epi32(a1, b1));
184  #if (LINE_SIZE == 16)
185      _mm_storeu_si128((__m128i*)&out[i +  8], _mm_add_epi32(a2, b2));
186      _mm_storeu_si128((__m128i*)&out[i + 12], _mm_add_epi32(a3, b3));
187  #endif
188    }
189    for (; i < size; ++i) {
190      out[i] += a[i];
191    }
192  }
193  #undef LINE_SIZE
194  #define ANALYZE_X_OR_Y(x_or_y, j)                                           \
195    do {                                                                      \
196      if ((x_or_y)[i + (j)] != 0) retval -= VP8LFastSLog2((x_or_y)[i + (j)]); \
197    } while (0)
198  #define ANALYZE_XY(j)                  \
199    do {                                 \
200      if (tmp[j] != 0) {                 \
201        retval -= VP8LFastSLog2(tmp[j]); \
202        ANALYZE_X_OR_Y(X, j);            \
203      }                                  \
204    } while (0)
205  static float CombinedShannonEntropy_SSE2(const int X[256], const int Y[256]) {
206    int i;
207    double retval = 0.;
208    int sumX, sumXY;
209    int32_t tmp[4];
210    __m128i zero = _mm_setzero_si128();
211    __m128i sumXY_128 = zero;
212    __m128i sumX_128 = zero;
213    for (i = 0; i < 256; i += 4) {
214      const __m128i x = _mm_loadu_si128((const __m128i*)(X + i));
215      const __m128i y = _mm_loadu_si128((const __m128i*)(Y + i));
216      if (_mm_movemask_epi8(_mm_cmpeq_epi32(x, zero)) != 0xFFFF) {
217        const __m128i xy_128 = _mm_add_epi32(x, y);
218        sumXY_128 = _mm_add_epi32(sumXY_128, xy_128);
219        sumX_128 = _mm_add_epi32(sumX_128, x);
220        _mm_storeu_si128((__m128i*)tmp, xy_128);
221        ANALYZE_XY(0);
222        ANALYZE_XY(1);
223        ANALYZE_XY(2);
224        ANALYZE_XY(3);
225      } else {
226        sumXY_128 = _mm_add_epi32(sumXY_128, y);
227        ANALYZE_X_OR_Y(Y, 0);
228        ANALYZE_X_OR_Y(Y, 1);
229        ANALYZE_X_OR_Y(Y, 2);
230        ANALYZE_X_OR_Y(Y, 3);
231      }
232    }
233    _mm_storeu_si128((__m128i*)tmp, sumX_128);
234    sumX = tmp[3] + tmp[2] + tmp[1] + tmp[0];
235    _mm_storeu_si128((__m128i*)tmp, sumXY_128);
236    sumXY = tmp[3] + tmp[2] + tmp[1] + tmp[0];
237    retval += VP8LFastSLog2(sumX) + VP8LFastSLog2(sumXY);
238    return (float)retval;
239  }
240  #undef ANALYZE_X_OR_Y
241  #undef ANALYZE_XY
242  static int VectorMismatch_SSE2(const uint32_t* const array1,
243                                 const uint32_t* const array2, int length) {
244    int match_len;
245    if (length >= 12) {
246      __m128i A0 = _mm_loadu_si128((const __m128i*)&array1[0]);
247      __m128i A1 = _mm_loadu_si128((const __m128i*)&array2[0]);
248      match_len = 0;
249      do {
250        const __m128i cmpA = _mm_cmpeq_epi32(A0, A1);
251        const __m128i B0 =
252            _mm_loadu_si128((const __m128i*)&array1[match_len + 4]);
253        const __m128i B1 =
254            _mm_loadu_si128((const __m128i*)&array2[match_len + 4]);
255        if (_mm_movemask_epi8(cmpA) != 0xffff) break;
256        match_len += 4;
257        {
258          const __m128i cmpB = _mm_cmpeq_epi32(B0, B1);
259          A0 = _mm_loadu_si128((const __m128i*)&array1[match_len + 4]);
260          A1 = _mm_loadu_si128((const __m128i*)&array2[match_len + 4]);
261          if (_mm_movemask_epi8(cmpB) != 0xffff) break;
262          match_len += 4;
263        }
264      } while (match_len + 12 < length);
265    } else {
266      match_len = 0;
267      if (length >= 4 &&
268          _mm_movemask_epi8(_mm_cmpeq_epi32(
269              _mm_loadu_si128((const __m128i*)&array1[0]),
270              _mm_loadu_si128((const __m128i*)&array2[0]))) == 0xffff) {
<span onclick='openModal()' class='match'>271        match_len = 4;
272        if (length >= 8 &&
273            _mm_movemask_epi8(_mm_cmpeq_epi32(
274                _mm_loadu_si128((const __m128i*)&array1[4]),
275                _mm_loadu_si128((const __m128i*)&array2[4]))) == 0xffff) {
276          match_len = 8;
277        }
</span>278      }
279    }
280    while (match_len < length && array1[match_len] == array2[match_len]) {
281      ++match_len;
282    }
283    return match_len;
284  }
285  static void BundleColorMap_SSE2(const uint8_t* const row, int width, int xbits,
286                                  uint32_t* dst) {
287    int x;
288    assert(xbits >= 0);
289    assert(xbits <= 3);
290    switch (xbits) {
291      case 0: {
292        const __m128i ff = _mm_set1_epi16((short)0xff00);
293        const __m128i zero = _mm_setzero_si128();
294        for (x = 0; x + 16 <= width; x += 16, dst += 16) {
295          const __m128i in = _mm_loadu_si128((const __m128i*)&row[x]);
296          const __m128i in_lo = _mm_unpacklo_epi8(zero, in);
297          const __m128i dst0 = _mm_unpacklo_epi16(in_lo, ff);
298          const __m128i dst1 = _mm_unpackhi_epi16(in_lo, ff);
299          const __m128i in_hi = _mm_unpackhi_epi8(zero, in);
300          const __m128i dst2 = _mm_unpacklo_epi16(in_hi, ff);
301          const __m128i dst3 = _mm_unpackhi_epi16(in_hi, ff);
302          _mm_storeu_si128((__m128i*)&dst[0], dst0);
303          _mm_storeu_si128((__m128i*)&dst[4], dst1);
304          _mm_storeu_si128((__m128i*)&dst[8], dst2);
305          _mm_storeu_si128((__m128i*)&dst[12], dst3);
306        }
307        break;
308      }
309      case 1: {
310        const __m128i ff = _mm_set1_epi16((short)0xff00);
311        const __m128i mul = _mm_set1_epi16(0x110);
312        for (x = 0; x + 16 <= width; x += 16, dst += 8) {
313          const __m128i in = _mm_loadu_si128((const __m128i*)&row[x]);
314          const __m128i tmp = _mm_mullo_epi16(in, mul);  
315          const __m128i pack = _mm_and_si128(tmp, ff);   
316          const __m128i dst0 = _mm_unpacklo_epi16(pack, ff);
317          const __m128i dst1 = _mm_unpackhi_epi16(pack, ff);
318          _mm_storeu_si128((__m128i*)&dst[0], dst0);
319          _mm_storeu_si128((__m128i*)&dst[4], dst1);
320        }
321        break;
322      }
323      case 2: {
324        const __m128i mask_or = _mm_set1_epi32(0xff000000);
325        const __m128i mul_cst = _mm_set1_epi16(0x0104);
326        const __m128i mask_mul = _mm_set1_epi16(0x0f00);
327        for (x = 0; x + 16 <= width; x += 16, dst += 4) {
328          const __m128i in = _mm_loadu_si128((const __m128i*)&row[x]);
329          const __m128i mul = _mm_mullo_epi16(in, mul_cst);  
330          const __m128i tmp = _mm_and_si128(mul, mask_mul);  
331          const __m128i shift = _mm_srli_epi32(tmp, 12);     
332          const __m128i pack = _mm_or_si128(shift, tmp);     
333          const __m128i res = _mm_or_si128(pack, mask_or);
334          _mm_storeu_si128((__m128i*)dst, res);
335        }
336        break;
337      }
338      default: {
339        assert(xbits == 3);
340        for (x = 0; x + 16 <= width; x += 16, dst += 2) {
341          const __m128i in = _mm_loadu_si128((const __m128i*)&row[x]);
342          const __m128i shift = _mm_slli_epi64(in, 7);
343          const uint32_t move = _mm_movemask_epi8(shift);
344          dst[0] = 0xff000000 | ((move & 0xff) << 8);
345          dst[1] = 0xff000000 | (move & 0xff00);
346        }
347        break;
348      }
349    }
350    if (x != width) {
351      VP8LBundleColorMap_C(row + x, width - x, xbits, dst);
352    }
353  }
354  static WEBP_INLINE void Average2_m128i(const __m128i* const a0,
355                                         const __m128i* const a1,
356                                         __m128i* const avg) {
357    const __m128i ones = _mm_set1_epi8(1);
358    const __m128i avg1 = _mm_avg_epu8(*a0, *a1);
359    const __m128i one = _mm_and_si128(_mm_xor_si128(*a0, *a1), ones);
360    *avg = _mm_sub_epi8(avg1, one);
361  }
362  static void PredictorSub0_SSE2(const uint32_t* in, const uint32_t* upper,
363                                 int num_pixels, uint32_t* out) {
364    int i;
365    const __m128i black = _mm_set1_epi32(ARGB_BLACK);
366    for (i = 0; i + 4 <= num_pixels; i += 4) {
367      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
368      const __m128i res = _mm_sub_epi8(src, black);
369      _mm_storeu_si128((__m128i*)&out[i], res);
370    }
371    if (i != num_pixels) {
372      VP8LPredictorsSub_C[0](in + i, NULL, num_pixels - i, out + i);
373    }
374    (void)upper;
375  }
376  #define GENERATE_PREDICTOR_1(X, IN)                                           \
377  static void PredictorSub##X##_SSE2(const uint32_t* in, const uint32_t* upper, \
378                                     int num_pixels, uint32_t* out) {           \
379    int i;                                                                      \
380    for (i = 0; i + 4 <= num_pixels; i += 4) {                                  \
381      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);              \
382      const __m128i pred = _mm_loadu_si128((const __m128i*)&(IN));              \
383      const __m128i res = _mm_sub_epi8(src, pred);                              \
384      _mm_storeu_si128((__m128i*)&out[i], res);                                 \
385    }                                                                           \
386    if (i != num_pixels) {                                                      \
387      VP8LPredictorsSub_C[(X)](in + i, upper + i, num_pixels - i, out + i);     \
388    }                                                                           \
389  }
390  GENERATE_PREDICTOR_1(1, in[i - 1])       
391  GENERATE_PREDICTOR_1(2, upper[i])        
392  GENERATE_PREDICTOR_1(3, upper[i + 1])    
393  GENERATE_PREDICTOR_1(4, upper[i - 1])    
394  #undef GENERATE_PREDICTOR_1
395  static void PredictorSub5_SSE2(const uint32_t* in, const uint32_t* upper,
396                                 int num_pixels, uint32_t* out) {
397    int i;
398    for (i = 0; i + 4 <= num_pixels; i += 4) {
399      const __m128i L = _mm_loadu_si128((const __m128i*)&in[i - 1]);
400      const __m128i T = _mm_loadu_si128((const __m128i*)&upper[i]);
401      const __m128i TR = _mm_loadu_si128((const __m128i*)&upper[i + 1]);
402      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
403      __m128i avg, pred, res;
404      Average2_m128i(&L, &TR, &avg);
405      Average2_m128i(&avg, &T, &pred);
406      res = _mm_sub_epi8(src, pred);
407      _mm_storeu_si128((__m128i*)&out[i], res);
408    }
409    if (i != num_pixels) {
410      VP8LPredictorsSub_C[5](in + i, upper + i, num_pixels - i, out + i);
411    }
412  }
413  #define GENERATE_PREDICTOR_2(X, A, B)                                         \
414  static void PredictorSub##X##_SSE2(const uint32_t* in, const uint32_t* upper, \
415                                     int num_pixels, uint32_t* out) {           \
416    int i;                                                                      \
417    for (i = 0; i + 4 <= num_pixels; i += 4) {                                  \
418      const __m128i tA = _mm_loadu_si128((const __m128i*)&(A));                 \
419      const __m128i tB = _mm_loadu_si128((const __m128i*)&(B));                 \
420      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);              \
421      __m128i pred, res;                                                        \
422      Average2_m128i(&tA, &tB, &pred);                                          \
423      res = _mm_sub_epi8(src, pred);                                            \
424      _mm_storeu_si128((__m128i*)&out[i], res);                                 \
425    }                                                                           \
426    if (i != num_pixels) {                                                      \
427      VP8LPredictorsSub_C[(X)](in + i, upper + i, num_pixels - i, out + i);     \
428    }                                                                           \
429  }
430  GENERATE_PREDICTOR_2(6, in[i - 1], upper[i - 1])   
431  GENERATE_PREDICTOR_2(7, in[i - 1], upper[i])       
432  GENERATE_PREDICTOR_2(8, upper[i - 1], upper[i])    
433  GENERATE_PREDICTOR_2(9, upper[i], upper[i + 1])    
434  #undef GENERATE_PREDICTOR_2
435  static void PredictorSub10_SSE2(const uint32_t* in, const uint32_t* upper,
436                                  int num_pixels, uint32_t* out) {
437    int i;
438    for (i = 0; i + 4 <= num_pixels; i += 4) {
439      const __m128i L = _mm_loadu_si128((const __m128i*)&in[i - 1]);
440      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
441      const __m128i TL = _mm_loadu_si128((const __m128i*)&upper[i - 1]);
442      const __m128i T = _mm_loadu_si128((const __m128i*)&upper[i]);
443      const __m128i TR = _mm_loadu_si128((const __m128i*)&upper[i + 1]);
444      __m128i avgTTR, avgLTL, avg, res;
445      Average2_m128i(&T, &TR, &avgTTR);
446      Average2_m128i(&L, &TL, &avgLTL);
447      Average2_m128i(&avgTTR, &avgLTL, &avg);
448      res = _mm_sub_epi8(src, avg);
449      _mm_storeu_si128((__m128i*)&out[i], res);
450    }
451    if (i != num_pixels) {
452      VP8LPredictorsSub_C[10](in + i, upper + i, num_pixels - i, out + i);
453    }
454  }
455  static void GetSumAbsDiff32_SSE2(const __m128i* const A, const __m128i* const B,
456                                   __m128i* const out) {
457    const __m128i A_lo = _mm_unpacklo_epi32(*A, *A);
458    const __m128i B_lo = _mm_unpacklo_epi32(*B, *A);
459    const __m128i A_hi = _mm_unpackhi_epi32(*A, *A);
460    const __m128i B_hi = _mm_unpackhi_epi32(*B, *A);
461    const __m128i s_lo = _mm_sad_epu8(A_lo, B_lo);
462    const __m128i s_hi = _mm_sad_epu8(A_hi, B_hi);
463    *out = _mm_packs_epi32(s_lo, s_hi);
464  }
465  static void PredictorSub11_SSE2(const uint32_t* in, const uint32_t* upper,
466                                  int num_pixels, uint32_t* out) {
467    int i;
468    for (i = 0; i + 4 <= num_pixels; i += 4) {
469      const __m128i L = _mm_loadu_si128((const __m128i*)&in[i - 1]);
470      const __m128i T = _mm_loadu_si128((const __m128i*)&upper[i]);
471      const __m128i TL = _mm_loadu_si128((const __m128i*)&upper[i - 1]);
472      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
473      __m128i pa, pb;
474      GetSumAbsDiff32_SSE2(&T, &TL, &pa);   
475      GetSumAbsDiff32_SSE2(&L, &TL, &pb);   
476      {
477        const __m128i mask = _mm_cmpgt_epi32(pb, pa);
478        const __m128i A = _mm_and_si128(mask, L);
479        const __m128i B = _mm_andnot_si128(mask, T);
480        const __m128i pred = _mm_or_si128(A, B);    
481        const __m128i res = _mm_sub_epi8(src, pred);
482        _mm_storeu_si128((__m128i*)&out[i], res);
483      }
484    }
485    if (i != num_pixels) {
486      VP8LPredictorsSub_C[11](in + i, upper + i, num_pixels - i, out + i);
487    }
488  }
489  static void PredictorSub12_SSE2(const uint32_t* in, const uint32_t* upper,
490                                  int num_pixels, uint32_t* out) {
491    int i;
492    const __m128i zero = _mm_setzero_si128();
493    for (i = 0; i + 4 <= num_pixels; i += 4) {
494      const __m128i src = _mm_loadu_si128((const __m128i*)&in[i]);
495      const __m128i L = _mm_loadu_si128((const __m128i*)&in[i - 1]);
496      const __m128i L_lo = _mm_unpacklo_epi8(L, zero);
497      const __m128i L_hi = _mm_unpackhi_epi8(L, zero);
498      const __m128i T = _mm_loadu_si128((const __m128i*)&upper[i]);
499      const __m128i T_lo = _mm_unpacklo_epi8(T, zero);
500      const __m128i T_hi = _mm_unpackhi_epi8(T, zero);
501      const __m128i TL = _mm_loadu_si128((const __m128i*)&upper[i - 1]);
502      const __m128i TL_lo = _mm_unpacklo_epi8(TL, zero);
503      const __m128i TL_hi = _mm_unpackhi_epi8(TL, zero);
504      const __m128i diff_lo = _mm_sub_epi16(T_lo, TL_lo);
505      const __m128i diff_hi = _mm_sub_epi16(T_hi, TL_hi);
506      const __m128i pred_lo = _mm_add_epi16(L_lo, diff_lo);
507      const __m128i pred_hi = _mm_add_epi16(L_hi, diff_hi);
508      const __m128i pred = _mm_packus_epi16(pred_lo, pred_hi);
509      const __m128i res = _mm_sub_epi8(src, pred);
510      _mm_storeu_si128((__m128i*)&out[i], res);
511    }
512    if (i != num_pixels) {
513      VP8LPredictorsSub_C[12](in + i, upper + i, num_pixels - i, out + i);
514    }
515  }
516  static void PredictorSub13_SSE2(const uint32_t* in, const uint32_t* upper,
517                                  int num_pixels, uint32_t* out) {
518    int i;
519    const __m128i zero = _mm_setzero_si128();
520    for (i = 0; i + 2 <= num_pixels; i += 2) {
521      const __m128i L = _mm_loadl_epi64((const __m128i*)&in[i - 1]);
522      const __m128i src = _mm_loadl_epi64((const __m128i*)&in[i]);
523      const __m128i T = _mm_loadl_epi64((const __m128i*)&upper[i]);
524      const __m128i TL = _mm_loadl_epi64((const __m128i*)&upper[i - 1]);
525      const __m128i L_lo = _mm_unpacklo_epi8(L, zero);
526      const __m128i T_lo = _mm_unpacklo_epi8(T, zero);
527      const __m128i TL_lo = _mm_unpacklo_epi8(TL, zero);
528      const __m128i sum = _mm_add_epi16(T_lo, L_lo);
529      const __m128i avg = _mm_srli_epi16(sum, 1);
530      const __m128i A1 = _mm_sub_epi16(avg, TL_lo);
531      const __m128i bit_fix = _mm_cmpgt_epi16(TL_lo, avg);
532      const __m128i A2 = _mm_sub_epi16(A1, bit_fix);
533      const __m128i A3 = _mm_srai_epi16(A2, 1);
534      const __m128i A4 = _mm_add_epi16(avg, A3);
535      const __m128i pred = _mm_packus_epi16(A4, A4);
536      const __m128i res = _mm_sub_epi8(src, pred);
537      _mm_storel_epi64((__m128i*)&out[i], res);
538    }
539    if (i != num_pixels) {
540      VP8LPredictorsSub_C[13](in + i, upper + i, num_pixels - i, out + i);
541    }
542  }
543  extern void VP8LEncDspInitSSE2(void);
544  WEBP_TSAN_IGNORE_FUNCTION void VP8LEncDspInitSSE2(void) {
545    VP8LSubtractGreenFromBlueAndRed = SubtractGreenFromBlueAndRed_SSE2;
546    VP8LTransformColor = TransformColor_SSE2;
547    VP8LCollectColorBlueTransforms = CollectColorBlueTransforms_SSE2;
548    VP8LCollectColorRedTransforms = CollectColorRedTransforms_SSE2;
549    VP8LAddVector = AddVector_SSE2;
550    VP8LAddVectorEq = AddVectorEq_SSE2;
551    VP8LCombinedShannonEntropy = CombinedShannonEntropy_SSE2;
552    VP8LVectorMismatch = VectorMismatch_SSE2;
553    VP8LBundleColorMap = BundleColorMap_SSE2;
554    VP8LPredictorsSub[0] = PredictorSub0_SSE2;
555    VP8LPredictorsSub[1] = PredictorSub1_SSE2;
556    VP8LPredictorsSub[2] = PredictorSub2_SSE2;
557    VP8LPredictorsSub[3] = PredictorSub3_SSE2;
558    VP8LPredictorsSub[4] = PredictorSub4_SSE2;
559    VP8LPredictorsSub[5] = PredictorSub5_SSE2;
560    VP8LPredictorsSub[6] = PredictorSub6_SSE2;
561    VP8LPredictorsSub[7] = PredictorSub7_SSE2;
562    VP8LPredictorsSub[8] = PredictorSub8_SSE2;
563    VP8LPredictorsSub[9] = PredictorSub9_SSE2;
564    VP8LPredictorsSub[10] = PredictorSub10_SSE2;
565    VP8LPredictorsSub[11] = PredictorSub11_SSE2;
566    VP8LPredictorsSub[12] = PredictorSub12_SSE2;
567    VP8LPredictorsSub[13] = PredictorSub13_SSE2;
568    VP8LPredictorsSub[14] = PredictorSub0_SSE2;  
569    VP8LPredictorsSub[15] = PredictorSub0_SSE2;
570  }
571  #else  
572  WEBP_DSP_INIT_STUB(VP8LEncDspInitSSE2)
573  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_enc_sse2.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_enc_sse2.c</div>
                </div>
                <div class="column column_space"><pre><code>266      match_len = 0;
267      if (length >= 4 &&
268          _mm_movemask_epi8(_mm_cmpeq_epi32(
269              _mm_loadu_si128((const __m128i*)&array1[0]),
270              _mm_loadu_si128((const __m128i*)&array2[0]))) == 0xffff) {
271        match_len = 4;
272        if (length >= 8 &&
</pre></code></div>
                <div class="column column_space"><pre><code>271        match_len = 4;
272        if (length >= 8 &&
273            _mm_movemask_epi8(_mm_cmpeq_epi32(
274                _mm_loadu_si128((const __m128i*)&array1[4]),
275                _mm_loadu_si128((const __m128i*)&array2[4]))) == 0xffff) {
276          match_len = 8;
277        }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    