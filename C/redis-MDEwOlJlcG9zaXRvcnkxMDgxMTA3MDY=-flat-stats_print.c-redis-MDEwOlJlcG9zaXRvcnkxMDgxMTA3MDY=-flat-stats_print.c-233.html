
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-stats_print.c</h3>
            <pre><code>1  #include &quot;test/jemalloc_test.h&quot;
2  #include &quot;jemalloc/internal/util.h&quot;
3  typedef enum {
4  	TOKEN_TYPE_NONE,
5  	TOKEN_TYPE_ERROR,
6  	TOKEN_TYPE_EOI,
7  	TOKEN_TYPE_NULL,
8  	TOKEN_TYPE_FALSE,
9  	TOKEN_TYPE_TRUE,
10  	TOKEN_TYPE_LBRACKET,
11  	TOKEN_TYPE_RBRACKET,
12  	TOKEN_TYPE_LBRACE,
13  	TOKEN_TYPE_RBRACE,
14  	TOKEN_TYPE_COLON,
15  	TOKEN_TYPE_COMMA,
16  	TOKEN_TYPE_STRING,
17  	TOKEN_TYPE_NUMBER
18  } token_type_t;
19  typedef struct parser_s parser_t;
20  typedef struct {
21  	parser_t	*parser;
22  	token_type_t	token_type;
23  	size_t		pos;
24  	size_t		len;
25  	size_t		line;
26  	size_t		col;
27  } token_t;
28  struct parser_s {
29  	bool verbose;
30  	char	*buf; &amp;bsol;* &#x27;\0&#x27;-terminated. */
31  	size_t	len; &amp;bsol;* Number of characters preceding &#x27;\0&#x27; in buf. */
32  	size_t	pos;
33  	size_t	line;
34  	size_t	col;
35  	token_t	token;
36  };
37  static void
38  token_init(token_t *token, parser_t *parser, token_type_t token_type,
39      size_t pos, size_t len, size_t line, size_t col) {
40  	token-&gt;parser = parser;
41  	token-&gt;token_type = token_type;
42  	token-&gt;pos = pos;
43  	token-&gt;len = len;
44  	token-&gt;line = line;
45  	token-&gt;col = col;
46  }
47  static void
48  token_error(token_t *token) {
49  	if (!token-&gt;parser-&gt;verbose) {
50  		return;
51  	}
52  	switch (token-&gt;token_type) {
53  	case TOKEN_TYPE_NONE:
54  		not_reached();
55  	case TOKEN_TYPE_ERROR:
56  		malloc_printf(&quot;%zu:%zu: Unexpected character in token: &quot;,
57  		    token-&gt;line, token-&gt;col);
58  		break;
59  	default:
60  		malloc_printf(&quot;%zu:%zu: Unexpected token: &quot;, token-&gt;line,
61  		    token-&gt;col);
62  		break;
63  	}
64  	UNUSED ssize_t err = malloc_write_fd(STDERR_FILENO,
65  	    &amp;token-&gt;parser-&gt;buf[token-&gt;pos], token-&gt;len);
66  	malloc_printf(&quot;\n&quot;);
67  }
68  static void
69  parser_init(parser_t *parser, bool verbose) {
70  	parser-&gt;verbose = verbose;
71  	parser-&gt;buf = NULL;
72  	parser-&gt;len = 0;
73  	parser-&gt;pos = 0;
74  	parser-&gt;line = 1;
75  	parser-&gt;col = 0;
76  }
77  static void
78  parser_fini(parser_t *parser) {
79  	if (parser-&gt;buf != NULL) {
80  		dallocx(parser-&gt;buf, MALLOCX_TCACHE_NONE);
81  	}
82  }
83  static bool
84  parser_append(parser_t *parser, const char *str) {
85  	size_t len = strlen(str);
86  	char *buf = (parser-&gt;buf == NULL) ? mallocx(len + 1,
87  	    MALLOCX_TCACHE_NONE) : rallocx(parser-&gt;buf, parser-&gt;len + len + 1,
88  	    MALLOCX_TCACHE_NONE);
89  	if (buf == NULL) {
90  		return true;
91  	}
92  	memcpy(&amp;buf[parser-&gt;len], str, len + 1);
93  	parser-&gt;buf = buf;
94  	parser-&gt;len += len;
95  	return false;
96  }
97  static bool
98  parser_tokenize(parser_t *parser) {
99  	enum {
100  		STATE_START,
101  		STATE_EOI,
102  		STATE_N, STATE_NU, STATE_NUL, STATE_NULL,
103  		STATE_F, STATE_FA, STATE_FAL, STATE_FALS, STATE_FALSE,
104  		STATE_T, STATE_TR, STATE_TRU, STATE_TRUE,
105  		STATE_LBRACKET,
106  		STATE_RBRACKET,
107  		STATE_LBRACE,
108  		STATE_RBRACE,
109  		STATE_COLON,
110  		STATE_COMMA,
111  		STATE_CHARS,
112  		STATE_CHAR_ESCAPE,
113  		STATE_CHAR_U, STATE_CHAR_UD, STATE_CHAR_UDD, STATE_CHAR_UDDD,
114  		STATE_STRING,
115  		STATE_MINUS,
116  		STATE_LEADING_ZERO,
117  		STATE_DIGITS,
118  		STATE_DECIMAL,
119  		STATE_FRAC_DIGITS,
120  		STATE_EXP,
121  		STATE_EXP_SIGN,
122  		STATE_EXP_DIGITS,
123  		STATE_ACCEPT
124  	} state = STATE_START;
125  	size_t token_pos JEMALLOC_CC_SILENCE_INIT(0);
126  	size_t token_line JEMALLOC_CC_SILENCE_INIT(1);
127  	size_t token_col JEMALLOC_CC_SILENCE_INIT(0);
128  	assert_zu_le(parser-&gt;pos, parser-&gt;len,
129  	    &quot;Position is past end of buffer&quot;);
130  	while (state != STATE_ACCEPT) {
131  		char c = parser-&gt;buf[parser-&gt;pos];
132  		switch (state) {
133  		case STATE_START:
134  			token_pos = parser-&gt;pos;
135  			token_line = parser-&gt;line;
136  			token_col = parser-&gt;col;
137  			switch (c) {
138  			case &#x27; &#x27;: case &#x27;\b&#x27;: case &#x27;\n&#x27;: case &#x27;\r&#x27;: case &#x27;\t&#x27;:
139  				break;
140  			case &#x27;\0&#x27;:
141  				state = STATE_EOI;
142  				break;
143  			case &#x27;n&#x27;:
144  				state = STATE_N;
145  				break;
146  			case &#x27;f&#x27;:
147  				state = STATE_F;
148  				break;
149  			case &#x27;t&#x27;:
150  				state = STATE_T;
151  				break;
152  			case &#x27;[&#x27;:
153  				state = STATE_LBRACKET;
154  				break;
155  			case &#x27;]&#x27;:
156  				state = STATE_RBRACKET;
157  				break;
158  			case &#x27;{&#x27;:
159  				state = STATE_LBRACE;
160  				break;
161  			case &#x27;}&#x27;:
162  				state = STATE_RBRACE;
163  				break;
164  			case &#x27;:&#x27;:
165  				state = STATE_COLON;
166  				break;
167  			case &#x27;,&#x27;:
168  				state = STATE_COMMA;
169  				break;
170  			case &#x27;&quot;&#x27;:
171  				state = STATE_CHARS;
172  				break;
173  			case &#x27;-&#x27;:
174  				state = STATE_MINUS;
175  				break;
176  			case &#x27;0&#x27;:
177  				state = STATE_LEADING_ZERO;
178  				break;
179  			case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;:
180  			case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
181  				state = STATE_DIGITS;
182  				break;
183  			default:
184  				token_init(&amp;parser-&gt;token, parser,
185  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
186  				    - token_pos, token_line, token_col);
187  				return true;
188  			}
189  			break;
190  		case STATE_EOI:
191  			token_init(&amp;parser-&gt;token, parser,
192  			    TOKEN_TYPE_EOI, token_pos, parser-&gt;pos -
193  			    token_pos, token_line, token_col);
194  			state = STATE_ACCEPT;
195  			break;
196  		case STATE_N:
197  			switch (c) {
198  			case &#x27;u&#x27;:
199  				state = STATE_NU;
200  				break;
201  			default:
202  				token_init(&amp;parser-&gt;token, parser,
203  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
204  				    - token_pos, token_line, token_col);
205  				return true;
206  			}
207  			break;
208  		case STATE_NU:
209  			switch (c) {
210  			case &#x27;l&#x27;:
211  				state = STATE_NUL;
212  				break;
213  			default:
214  				token_init(&amp;parser-&gt;token, parser,
215  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
216  				    - token_pos, token_line, token_col);
217  				return true;
218  			}
219  			break;
220  		case STATE_NUL:
221  			switch (c) {
222  			case &#x27;l&#x27;:
223  				state = STATE_NULL;
224  				break;
225  			default:
226  				token_init(&amp;parser-&gt;token, parser,
227  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
228  				    - token_pos, token_line, token_col);
229  				return true;
230  			}
231  			break;
232  		case STATE_NULL:
233  			switch (c) {
234  			case &#x27; &#x27;: case &#x27;\b&#x27;: case &#x27;\n&#x27;: case &#x27;\r&#x27;: case &#x27;\t&#x27;:
235  			case &#x27;\0&#x27;:
236  			case &#x27;[&#x27;: case &#x27;]&#x27;: case &#x27;{&#x27;: case &#x27;}&#x27;: case &#x27;:&#x27;:
237  			case &#x27;,&#x27;:
238  				break;
239  			default:
240  				token_init(&amp;parser-&gt;token, parser,
241  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
242  				    - token_pos, token_line, token_col);
243  				return true;
244  			}
245  			token_init(&amp;parser-&gt;token, parser, TOKEN_TYPE_NULL,
246  			    token_pos, parser-&gt;pos - token_pos, token_line,
247  			    token_col);
248  			state = STATE_ACCEPT;
249  			break;
250  		case STATE_F:
251  			switch (c) {
252  			case &#x27;a&#x27;:
253  				state = STATE_FA;
254  				break;
255  			default:
256  				token_init(&amp;parser-&gt;token, parser,
257  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
258  				    - token_pos, token_line, token_col);
259  				return true;
260  			}
261  			break;
262  		case STATE_FA:
263  			switch (c) {
264  			case &#x27;l&#x27;:
265  				state = STATE_FAL;
266  				break;
267  			default:
268  				token_init(&amp;parser-&gt;token, parser,
269  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
270  				    - token_pos, token_line, token_col);
271  				return true;
272  			}
273  			break;
274  		case STATE_FAL:
<span onclick='openModal()' class='match'>275  			switch (c) {
276  			case &#x27;s&#x27;:
277  				state = STATE_FALS;
278  				break;
279  			default:
280  				token_init(&amp;parser-&gt;token, parser,
</span>281  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
282  				    - token_pos, token_line, token_col);
283  				return true;
284  			}
285  			break;
286  		case STATE_FALS:
287  			switch (c) {
288  			case &#x27;e&#x27;:
289  				state = STATE_FALSE;
290  				break;
291  			default:
292  				token_init(&amp;parser-&gt;token, parser,
293  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
294  				    - token_pos, token_line, token_col);
295  				return true;
296  			}
297  			break;
298  		case STATE_FALSE:
299  			switch (c) {
300  			case &#x27; &#x27;: case &#x27;\b&#x27;: case &#x27;\n&#x27;: case &#x27;\r&#x27;: case &#x27;\t&#x27;:
301  			case &#x27;\0&#x27;:
302  			case &#x27;[&#x27;: case &#x27;]&#x27;: case &#x27;{&#x27;: case &#x27;}&#x27;: case &#x27;:&#x27;:
303  			case &#x27;,&#x27;:
304  				break;
305  			default:
306  				token_init(&amp;parser-&gt;token, parser,
307  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
308  				    - token_pos, token_line, token_col);
309  				return true;
310  			}
311  			token_init(&amp;parser-&gt;token, parser,
312  			    TOKEN_TYPE_FALSE, token_pos, parser-&gt;pos -
313  			    token_pos, token_line, token_col);
314  			state = STATE_ACCEPT;
315  			break;
316  		case STATE_T:
317  			switch (c) {
318  			case &#x27;r&#x27;:
319  				state = STATE_TR;
320  				break;
321  			default:
322  				token_init(&amp;parser-&gt;token, parser,
323  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
324  				    - token_pos, token_line, token_col);
325  				return true;
326  			}
327  			break;
328  		case STATE_TR:
329  			switch (c) {
330  			case &#x27;u&#x27;:
331  				state = STATE_TRU;
332  				break;
333  			default:
334  				token_init(&amp;parser-&gt;token, parser,
335  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
336  				    - token_pos, token_line, token_col);
337  				return true;
338  			}
339  			break;
340  		case STATE_TRU:
341  			switch (c) {
342  			case &#x27;e&#x27;:
343  				state = STATE_TRUE;
344  				break;
345  			default:
346  				token_init(&amp;parser-&gt;token, parser,
347  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
348  				    - token_pos, token_line, token_col);
349  				return true;
350  			}
351  			break;
352  		case STATE_TRUE:
353  			switch (c) {
354  			case &#x27; &#x27;: case &#x27;\b&#x27;: case &#x27;\n&#x27;: case &#x27;\r&#x27;: case &#x27;\t&#x27;:
355  			case &#x27;\0&#x27;:
356  			case &#x27;[&#x27;: case &#x27;]&#x27;: case &#x27;{&#x27;: case &#x27;}&#x27;: case &#x27;:&#x27;:
357  			case &#x27;,&#x27;:
358  				break;
359  			default:
360  				token_init(&amp;parser-&gt;token, parser,
361  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
362  				    - token_pos, token_line, token_col);
363  				return true;
364  			}
365  			token_init(&amp;parser-&gt;token, parser, TOKEN_TYPE_TRUE,
366  			    token_pos, parser-&gt;pos - token_pos, token_line,
367  			    token_col);
368  			state = STATE_ACCEPT;
369  			break;
370  		case STATE_LBRACKET:
371  			token_init(&amp;parser-&gt;token, parser, TOKEN_TYPE_LBRACKET,
372  			    token_pos, parser-&gt;pos - token_pos, token_line,
373  			    token_col);
374  			state = STATE_ACCEPT;
375  			break;
376  		case STATE_RBRACKET:
377  			token_init(&amp;parser-&gt;token, parser, TOKEN_TYPE_RBRACKET,
378  			    token_pos, parser-&gt;pos - token_pos, token_line,
379  			    token_col);
380  			state = STATE_ACCEPT;
381  			break;
382  		case STATE_LBRACE:
383  			token_init(&amp;parser-&gt;token, parser, TOKEN_TYPE_LBRACE,
384  			    token_pos, parser-&gt;pos - token_pos, token_line,
385  			    token_col);
386  			state = STATE_ACCEPT;
387  			break;
388  		case STATE_RBRACE:
389  			token_init(&amp;parser-&gt;token, parser, TOKEN_TYPE_RBRACE,
390  			    token_pos, parser-&gt;pos - token_pos, token_line,
391  			    token_col);
392  			state = STATE_ACCEPT;
393  			break;
394  		case STATE_COLON:
395  			token_init(&amp;parser-&gt;token, parser, TOKEN_TYPE_COLON,
396  			    token_pos, parser-&gt;pos - token_pos, token_line,
397  			    token_col);
398  			state = STATE_ACCEPT;
399  			break;
400  		case STATE_COMMA:
401  			token_init(&amp;parser-&gt;token, parser, TOKEN_TYPE_COMMA,
402  			    token_pos, parser-&gt;pos - token_pos, token_line,
403  			    token_col);
404  			state = STATE_ACCEPT;
405  			break;
406  		case STATE_CHARS:
407  			switch (c) {
408  			case &#x27;\\&#x27;:
409  				state = STATE_CHAR_ESCAPE;
410  				break;
411  			case &#x27;&quot;&#x27;:
412  				state = STATE_STRING;
413  				break;
414  			case 0x00: case 0x01: case 0x02: case 0x03: case 0x04:
415  			case 0x05: case 0x06: case 0x07: case 0x08: case 0x09:
416  			case 0x0a: case 0x0b: case 0x0c: case 0x0d: case 0x0e:
417  			case 0x0f: case 0x10: case 0x11: case 0x12: case 0x13:
418  			case 0x14: case 0x15: case 0x16: case 0x17: case 0x18:
419  			case 0x19: case 0x1a: case 0x1b: case 0x1c: case 0x1d:
420  			case 0x1e: case 0x1f:
421  				token_init(&amp;parser-&gt;token, parser,
422  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
423  				    - token_pos, token_line, token_col);
424  				return true;
425  			default:
426  				break;
427  			}
428  			break;
429  		case STATE_CHAR_ESCAPE:
430  			switch (c) {
431  			case &#x27;&quot;&#x27;: case &#x27;\\&#x27;: case &#x27;/&#x27;: case &#x27;b&#x27;: case &#x27;n&#x27;:
432  			case &#x27;r&#x27;: case &#x27;t&#x27;:
433  				state = STATE_CHARS;
434  				break;
435  			case &#x27;u&#x27;:
436  				state = STATE_CHAR_U;
437  				break;
438  			default:
439  				token_init(&amp;parser-&gt;token, parser,
440  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
441  				    - token_pos, token_line, token_col);
442  				return true;
443  			}
444  			break;
445  		case STATE_CHAR_U:
446  			switch (c) {
447  			case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;:
448  			case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
449  			case &#x27;a&#x27;: case &#x27;b&#x27;: case &#x27;c&#x27;: case &#x27;d&#x27;: case &#x27;e&#x27;:
450  			case &#x27;f&#x27;:
451  			case &#x27;A&#x27;: case &#x27;B&#x27;: case &#x27;C&#x27;: case &#x27;D&#x27;: case &#x27;E&#x27;:
452  			case &#x27;F&#x27;:
453  				state = STATE_CHAR_UD;
454  				break;
455  			default:
456  				token_init(&amp;parser-&gt;token, parser,
457  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
458  				    - token_pos, token_line, token_col);
459  				return true;
460  			}
461  			break;
462  		case STATE_CHAR_UD:
463  			switch (c) {
464  			case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;:
465  			case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
466  			case &#x27;a&#x27;: case &#x27;b&#x27;: case &#x27;c&#x27;: case &#x27;d&#x27;: case &#x27;e&#x27;:
467  			case &#x27;f&#x27;:
468  			case &#x27;A&#x27;: case &#x27;B&#x27;: case &#x27;C&#x27;: case &#x27;D&#x27;: case &#x27;E&#x27;:
469  			case &#x27;F&#x27;:
470  				state = STATE_CHAR_UDD;
471  				break;
472  			default:
473  				token_init(&amp;parser-&gt;token, parser,
474  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
475  				    - token_pos, token_line, token_col);
476  				return true;
477  			}
478  			break;
479  		case STATE_CHAR_UDD:
480  			switch (c) {
481  			case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;:
482  			case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
483  			case &#x27;a&#x27;: case &#x27;b&#x27;: case &#x27;c&#x27;: case &#x27;d&#x27;: case &#x27;e&#x27;:
484  			case &#x27;f&#x27;:
485  			case &#x27;A&#x27;: case &#x27;B&#x27;: case &#x27;C&#x27;: case &#x27;D&#x27;: case &#x27;E&#x27;:
486  			case &#x27;F&#x27;:
487  				state = STATE_CHAR_UDDD;
488  				break;
489  			default:
490  				token_init(&amp;parser-&gt;token, parser,
491  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
492  				    - token_pos, token_line, token_col);
493  				return true;
494  			}
495  			break;
496  		case STATE_CHAR_UDDD:
497  			switch (c) {
498  			case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;:
499  			case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
500  			case &#x27;a&#x27;: case &#x27;b&#x27;: case &#x27;c&#x27;: case &#x27;d&#x27;: case &#x27;e&#x27;:
501  			case &#x27;f&#x27;:
502  			case &#x27;A&#x27;: case &#x27;B&#x27;: case &#x27;C&#x27;: case &#x27;D&#x27;: case &#x27;E&#x27;:
503  			case &#x27;F&#x27;:
504  				state = STATE_CHARS;
505  				break;
506  			default:
507  				token_init(&amp;parser-&gt;token, parser,
508  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
509  				    - token_pos, token_line, token_col);
510  				return true;
511  			}
512  			break;
513  		case STATE_STRING:
514  			token_init(&amp;parser-&gt;token, parser, TOKEN_TYPE_STRING,
515  			    token_pos, parser-&gt;pos - token_pos, token_line,
516  			    token_col);
517  			state = STATE_ACCEPT;
518  			break;
519  		case STATE_MINUS:
520  			switch (c) {
521  			case &#x27;0&#x27;:
522  				state = STATE_LEADING_ZERO;
523  				break;
524  			case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;:
525  			case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
526  				state = STATE_DIGITS;
527  				break;
528  			default:
529  				token_init(&amp;parser-&gt;token, parser,
530  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
531  				    - token_pos, token_line, token_col);
532  				return true;
533  			}
534  			break;
535  		case STATE_LEADING_ZERO:
536  			switch (c) {
537  			case &#x27;.&#x27;:
538  				state = STATE_DECIMAL;
539  				break;
540  			default:
541  				token_init(&amp;parser-&gt;token, parser,
542  				    TOKEN_TYPE_NUMBER, token_pos, parser-&gt;pos -
543  				    token_pos, token_line, token_col);
544  				state = STATE_ACCEPT;
545  				break;
546  			}
547  			break;
548  		case STATE_DIGITS:
549  			switch (c) {
550  			case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;:
551  			case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
552  				break;
553  			case &#x27;.&#x27;:
554  				state = STATE_DECIMAL;
555  				break;
556  			default:
557  				token_init(&amp;parser-&gt;token, parser,
558  				    TOKEN_TYPE_NUMBER, token_pos, parser-&gt;pos -
559  				    token_pos, token_line, token_col);
560  				state = STATE_ACCEPT;
561  				break;
562  			}
563  			break;
564  		case STATE_DECIMAL:
565  			switch (c) {
566  			case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;:
567  			case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
568  				state = STATE_FRAC_DIGITS;
569  				break;
570  			default:
571  				token_init(&amp;parser-&gt;token, parser,
572  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
573  				    - token_pos, token_line, token_col);
574  				return true;
575  			}
576  			break;
577  		case STATE_FRAC_DIGITS:
578  			switch (c) {
579  			case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;:
580  			case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
581  				break;
582  			case &#x27;e&#x27;: case &#x27;E&#x27;:
583  				state = STATE_EXP;
584  				break;
585  			default:
586  				token_init(&amp;parser-&gt;token, parser,
587  				    TOKEN_TYPE_NUMBER, token_pos, parser-&gt;pos -
588  				    token_pos, token_line, token_col);
589  				state = STATE_ACCEPT;
590  				break;
591  			}
592  			break;
593  		case STATE_EXP:
594  			switch (c) {
595  			case &#x27;-&#x27;: case &#x27;+&#x27;:
596  				state = STATE_EXP_SIGN;
597  				break;
598  			case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;:
599  			case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
600  				state = STATE_EXP_DIGITS;
601  				break;
602  			default:
603  				token_init(&amp;parser-&gt;token, parser,
604  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
605  				    - token_pos, token_line, token_col);
606  				return true;
607  			}
608  			break;
609  		case STATE_EXP_SIGN:
610  			switch (c) {
611  			case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;:
612  			case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
613  				state = STATE_EXP_DIGITS;
614  				break;
615  			default:
616  				token_init(&amp;parser-&gt;token, parser,
617  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
618  				    - token_pos, token_line, token_col);
619  				return true;
620  			}
621  			break;
622  		case STATE_EXP_DIGITS:
623  			switch (c) {
624  			case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;:
625  			case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
626  				break;
627  			default:
628  				token_init(&amp;parser-&gt;token, parser,
629  				    TOKEN_TYPE_NUMBER, token_pos, parser-&gt;pos -
630  				    token_pos, token_line, token_col);
631  				state = STATE_ACCEPT;
632  				break;
633  			}
634  			break;
635  		default:
636  			not_reached();
637  		}
638  		if (state != STATE_ACCEPT) {
639  			if (c == &#x27;\n&#x27;) {
640  				parser-&gt;line++;
641  				parser-&gt;col = 0;
642  			} else {
643  				parser-&gt;col++;
644  			}
645  			parser-&gt;pos++;
646  		}
647  	}
648  	return false;
649  }
650  static bool	parser_parse_array(parser_t *parser);
651  static bool	parser_parse_object(parser_t *parser);
652  static bool
653  parser_parse_value(parser_t *parser) {
654  	switch (parser-&gt;token.token_type) {
655  	case TOKEN_TYPE_NULL:
656  	case TOKEN_TYPE_FALSE:
657  	case TOKEN_TYPE_TRUE:
658  	case TOKEN_TYPE_STRING:
659  	case TOKEN_TYPE_NUMBER:
660  		return false;
661  	case TOKEN_TYPE_LBRACE:
662  		return parser_parse_object(parser);
663  	case TOKEN_TYPE_LBRACKET:
664  		return parser_parse_array(parser);
665  	default:
666  		return true;
667  	}
668  	not_reached();
669  }
670  static bool
671  parser_parse_pair(parser_t *parser) {
672  	assert_d_eq(parser-&gt;token.token_type, TOKEN_TYPE_STRING,
673  	    &quot;Pair should start with string&quot;);
674  	if (parser_tokenize(parser)) {
675  		return true;
676  	}
677  	switch (parser-&gt;token.token_type) {
678  	case TOKEN_TYPE_COLON:
679  		if (parser_tokenize(parser)) {
680  			return true;
681  		}
682  		return parser_parse_value(parser);
683  	default:
684  		return true;
685  	}
686  }
687  static bool
688  parser_parse_values(parser_t *parser) {
689  	if (parser_parse_value(parser)) {
690  		return true;
691  	}
692  	while (true) {
693  		if (parser_tokenize(parser)) {
694  			return true;
695  		}
696  		switch (parser-&gt;token.token_type) {
697  		case TOKEN_TYPE_COMMA:
698  			if (parser_tokenize(parser)) {
699  				return true;
700  			}
701  			if (parser_parse_value(parser)) {
702  				return true;
703  			}
704  			break;
705  		case TOKEN_TYPE_RBRACKET:
706  			return false;
707  		default:
708  			return true;
709  		}
710  	}
711  }
712  static bool
713  parser_parse_array(parser_t *parser) {
714  	assert_d_eq(parser-&gt;token.token_type, TOKEN_TYPE_LBRACKET,
715  	    &quot;Array should start with [&quot;);
716  	if (parser_tokenize(parser)) {
717  		return true;
718  	}
719  	switch (parser-&gt;token.token_type) {
720  	case TOKEN_TYPE_RBRACKET:
721  		return false;
722  	default:
723  		return parser_parse_values(parser);
724  	}
725  	not_reached();
726  }
727  static bool
728  parser_parse_pairs(parser_t *parser) {
729  	assert_d_eq(parser-&gt;token.token_type, TOKEN_TYPE_STRING,
730  	    &quot;Object should start with string&quot;);
731  	if (parser_parse_pair(parser)) {
732  		return true;
733  	}
734  	while (true) {
735  		if (parser_tokenize(parser)) {
736  			return true;
737  		}
738  		switch (parser-&gt;token.token_type) {
739  		case TOKEN_TYPE_COMMA:
740  			if (parser_tokenize(parser)) {
741  				return true;
742  			}
743  			switch (parser-&gt;token.token_type) {
744  			case TOKEN_TYPE_STRING:
745  				if (parser_parse_pair(parser)) {
746  					return true;
747  				}
748  				break;
749  			default:
750  				return true;
751  			}
752  			break;
753  		case TOKEN_TYPE_RBRACE:
754  			return false;
755  		default:
756  			return true;
757  		}
758  	}
759  }
760  static bool
761  parser_parse_object(parser_t *parser) {
762  	assert_d_eq(parser-&gt;token.token_type, TOKEN_TYPE_LBRACE,
763  	    &quot;Object should start with {&quot;);
764  	if (parser_tokenize(parser)) {
765  		return true;
766  	}
767  	switch (parser-&gt;token.token_type) {
768  	case TOKEN_TYPE_STRING:
769  		return parser_parse_pairs(parser);
770  	case TOKEN_TYPE_RBRACE:
771  		return false;
772  	default:
773  		return true;
774  	}
775  	not_reached();
776  }
777  static bool
778  parser_parse(parser_t *parser) {
779  	if (parser_tokenize(parser)) {
780  		goto label_error;
781  	}
782  	if (parser_parse_value(parser)) {
783  		goto label_error;
784  	}
785  	if (parser_tokenize(parser)) {
786  		goto label_error;
787  	}
788  	switch (parser-&gt;token.token_type) {
789  	case TOKEN_TYPE_EOI:
790  		return false;
791  	default:
792  		goto label_error;
793  	}
794  	not_reached();
795  label_error:
796  	token_error(&amp;parser-&gt;token);
797  	return true;
798  }
799  TEST_BEGIN(test_json_parser) {
800  	size_t i;
801  	const char *invalid_inputs[] = {
802  		&quot;{ \&quot;string\&quot;: X }&quot;,
803  		&quot;{ \&quot;string\&quot;: nXll }&quot;,
804  		&quot;{ \&quot;string\&quot;: nuXl }&quot;,
805  		&quot;{ \&quot;string\&quot;: nulX }&quot;,
806  		&quot;{ \&quot;string\&quot;: nullX }&quot;,
807  		&quot;{ \&quot;string\&quot;: fXlse }&quot;,
808  		&quot;{ \&quot;string\&quot;: faXse }&quot;,
809  		&quot;{ \&quot;string\&quot;: falXe }&quot;,
810  		&quot;{ \&quot;string\&quot;: falsX }&quot;,
811  		&quot;{ \&quot;string\&quot;: falseX }&quot;,
812  		&quot;{ \&quot;string\&quot;: tXue }&quot;,
813  		&quot;{ \&quot;string\&quot;: trXe }&quot;,
814  		&quot;{ \&quot;string\&quot;: truX }&quot;,
815  		&quot;{ \&quot;string\&quot;: trueX }&quot;,
816  		&quot;{ \&quot;string\&quot;: \&quot;\n\&quot; }&quot;,
817  		&quot;{ \&quot;string\&quot;: \&quot;\\z\&quot; }&quot;,
818  		&quot;{ \&quot;string\&quot;: \&quot;\\uX000\&quot; }&quot;,
819  		&quot;{ \&quot;string\&quot;: \&quot;\\u0X00\&quot; }&quot;,
820  		&quot;{ \&quot;string\&quot;: \&quot;\\u00X0\&quot; }&quot;,
821  		&quot;{ \&quot;string\&quot;: \&quot;\\u000X\&quot; }&quot;,
822  		&quot;{ \&quot;string\&quot;: -X }&quot;,
823  		&quot;{ \&quot;string\&quot;: 0.X }&quot;,
824  		&quot;{ \&quot;string\&quot;: 0.0eX }&quot;,
825  		&quot;{ \&quot;string\&quot;: 0.0e+X }&quot;,
826  		&quot;{\&quot;string\&quot;: }&quot;,
827  		&quot;{\&quot;string\&quot; }&quot;,
828  		&quot;{\&quot;string\&quot;: [ 0 }&quot;,
829  		&quot;{\&quot;string\&quot;: {\&quot;a\&quot;:0, 1 } }&quot;,
830  		&quot;{\&quot;string\&quot;: {\&quot;a\&quot;:0: } }&quot;,
831  		&quot;{&quot;,
832  		&quot;{}{&quot;,
833  	};
834  	const char *valid_inputs[] = {
835  		&quot;null&quot;,
836  		&quot;false&quot;,
837  		&quot;true&quot;,
838  		&quot;{}&quot;,
839  		&quot;{\&quot;a\&quot;: 0}&quot;,
840  		&quot;[]&quot;,
841  		&quot;[0, 1]&quot;,
842  		&quot;0&quot;,
843  		&quot;1&quot;,
844  		&quot;10&quot;,
845  		&quot;-10&quot;,
846  		&quot;10.23&quot;,
847  		&quot;10.23e4&quot;,
848  		&quot;10.23e-4&quot;,
849  		&quot;10.23e+4&quot;,
850  		&quot;10.23E4&quot;,
851  		&quot;10.23E-4&quot;,
852  		&quot;10.23E+4&quot;,
853  		&quot;-10.23&quot;,
854  		&quot;-10.23e4&quot;,
855  		&quot;-10.23e-4&quot;,
856  		&quot;-10.23e+4&quot;,
857  		&quot;-10.23E4&quot;,
858  		&quot;-10.23E-4&quot;,
859  		&quot;-10.23E+4&quot;,
860  		&quot;\&quot;value\&quot;&quot;,
861  		&quot;\&quot; \\\&quot; \\/ \\b \\n \\r \\t \\u0abc \\u1DEF \&quot;&quot;,
862  		&quot;{\&quot;a\&quot;:null, \&quot;b\&quot;:[1,[{\&quot;c\&quot;:2},3]], \&quot;d\&quot;:{\&quot;e\&quot;:true}}&quot;,
863  	};
864  	for (i = 0; i &lt; sizeof(invalid_inputs)/sizeof(const char *); i++) {
865  		const char *input = invalid_inputs[i];
866  		parser_t parser;
867  		parser_init(&amp;parser, false);
868  		assert_false(parser_append(&amp;parser, input),
869  		    &quot;Unexpected input appending failure&quot;);
870  		assert_true(parser_parse(&amp;parser),
871  		    &quot;Unexpected parse success for input: %s&quot;, input);
872  		parser_fini(&amp;parser);
873  	}
874  	for (i = 0; i &lt; sizeof(valid_inputs)/sizeof(const char *); i++) {
875  		const char *input = valid_inputs[i];
876  		parser_t parser;
877  		parser_init(&amp;parser, true);
878  		assert_false(parser_append(&amp;parser, input),
879  		    &quot;Unexpected input appending failure&quot;);
880  		assert_false(parser_parse(&amp;parser),
881  		    &quot;Unexpected parse error for input: %s&quot;, input);
882  		parser_fini(&amp;parser);
883  	}
884  }
885  TEST_END
886  void
887  write_cb(void *opaque, const char *str) {
888  	parser_t *parser = (parser_t *)opaque;
889  	if (parser_append(parser, str)) {
890  		test_fail(&quot;Unexpected input appending failure&quot;);
891  	}
892  }
893  TEST_BEGIN(test_stats_print_json) {
894  	const char *opts[] = {
895  		&quot;J&quot;,
896  		&quot;Jg&quot;,
897  		&quot;Jm&quot;,
898  		&quot;Jd&quot;,
899  		&quot;Jmd&quot;,
900  		&quot;Jgd&quot;,
901  		&quot;Jgm&quot;,
902  		&quot;Jgmd&quot;,
903  		&quot;Ja&quot;,
904  		&quot;Jb&quot;,
905  		&quot;Jl&quot;,
906  		&quot;Jx&quot;,
907  		&quot;Jbl&quot;,
908  		&quot;Jal&quot;,
909  		&quot;Jab&quot;,
910  		&quot;Jabl&quot;,
911  		&quot;Jax&quot;,
912  		&quot;Jbx&quot;,
913  		&quot;Jlx&quot;,
914  		&quot;Jablx&quot;,
915  		&quot;Jgmdablx&quot;,
916  	};
917  	unsigned arena_ind, i;
918  	for (i = 0; i &lt; 3; i++) {
919  		unsigned j;
920  		switch (i) {
921  		case 0:
922  			break;
923  		case 1: {
924  			size_t sz = sizeof(arena_ind);
925  			assert_d_eq(mallctl(&quot;arenas.create&quot;, (void *)&amp;arena_ind,
926  			    &amp;sz, NULL, 0), 0, &quot;Unexpected mallctl failure&quot;);
927  			break;
928  		} case 2: {
929  			size_t mib[3];
930  			size_t miblen = sizeof(mib)/sizeof(size_t);
931  			assert_d_eq(mallctlnametomib(&quot;arena.0.destroy&quot;,
932  			    mib, &amp;miblen), 0,
933  			    &quot;Unexpected mallctlnametomib failure&quot;);
934  			mib[1] = arena_ind;
935  			assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL,
936  			    0), 0, &quot;Unexpected mallctlbymib failure&quot;);
937  			break;
938  		} default:
939  			not_reached();
940  		}
941  		for (j = 0; j &lt; sizeof(opts)/sizeof(const char *); j++) {
942  			parser_t parser;
943  			parser_init(&amp;parser, true);
944  			malloc_stats_print(write_cb, (void *)&amp;parser, opts[j]);
945  			assert_false(parser_parse(&amp;parser),
946  			    &quot;Unexpected parse error, opts=\&quot;%s\&quot;&quot;, opts[j]);
947  			parser_fini(&amp;parser);
948  		}
949  	}
950  }
951  TEST_END
952  int
953  main(void) {
954  	return test(
955  	    test_json_parser,
956  	    test_stats_print_json);
957  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-stats_print.c</h3>
            <pre><code>1  #include &quot;test/jemalloc_test.h&quot;
2  #include &quot;jemalloc/internal/util.h&quot;
3  typedef enum {
4  	TOKEN_TYPE_NONE,
5  	TOKEN_TYPE_ERROR,
6  	TOKEN_TYPE_EOI,
7  	TOKEN_TYPE_NULL,
8  	TOKEN_TYPE_FALSE,
9  	TOKEN_TYPE_TRUE,
10  	TOKEN_TYPE_LBRACKET,
11  	TOKEN_TYPE_RBRACKET,
12  	TOKEN_TYPE_LBRACE,
13  	TOKEN_TYPE_RBRACE,
14  	TOKEN_TYPE_COLON,
15  	TOKEN_TYPE_COMMA,
16  	TOKEN_TYPE_STRING,
17  	TOKEN_TYPE_NUMBER
18  } token_type_t;
19  typedef struct parser_s parser_t;
20  typedef struct {
21  	parser_t	*parser;
22  	token_type_t	token_type;
23  	size_t		pos;
24  	size_t		len;
25  	size_t		line;
26  	size_t		col;
27  } token_t;
28  struct parser_s {
29  	bool verbose;
30  	char	*buf; &amp;bsol;* &#x27;\0&#x27;-terminated. */
31  	size_t	len; &amp;bsol;* Number of characters preceding &#x27;\0&#x27; in buf. */
32  	size_t	pos;
33  	size_t	line;
34  	size_t	col;
35  	token_t	token;
36  };
37  static void
38  token_init(token_t *token, parser_t *parser, token_type_t token_type,
39      size_t pos, size_t len, size_t line, size_t col) {
40  	token-&gt;parser = parser;
41  	token-&gt;token_type = token_type;
42  	token-&gt;pos = pos;
43  	token-&gt;len = len;
44  	token-&gt;line = line;
45  	token-&gt;col = col;
46  }
47  static void
48  token_error(token_t *token) {
49  	if (!token-&gt;parser-&gt;verbose) {
50  		return;
51  	}
52  	switch (token-&gt;token_type) {
53  	case TOKEN_TYPE_NONE:
54  		not_reached();
55  	case TOKEN_TYPE_ERROR:
56  		malloc_printf(&quot;%zu:%zu: Unexpected character in token: &quot;,
57  		    token-&gt;line, token-&gt;col);
58  		break;
59  	default:
60  		malloc_printf(&quot;%zu:%zu: Unexpected token: &quot;, token-&gt;line,
61  		    token-&gt;col);
62  		break;
63  	}
64  	UNUSED ssize_t err = malloc_write_fd(STDERR_FILENO,
65  	    &amp;token-&gt;parser-&gt;buf[token-&gt;pos], token-&gt;len);
66  	malloc_printf(&quot;\n&quot;);
67  }
68  static void
69  parser_init(parser_t *parser, bool verbose) {
70  	parser-&gt;verbose = verbose;
71  	parser-&gt;buf = NULL;
72  	parser-&gt;len = 0;
73  	parser-&gt;pos = 0;
74  	parser-&gt;line = 1;
75  	parser-&gt;col = 0;
76  }
77  static void
78  parser_fini(parser_t *parser) {
79  	if (parser-&gt;buf != NULL) {
80  		dallocx(parser-&gt;buf, MALLOCX_TCACHE_NONE);
81  	}
82  }
83  static bool
84  parser_append(parser_t *parser, const char *str) {
85  	size_t len = strlen(str);
86  	char *buf = (parser-&gt;buf == NULL) ? mallocx(len + 1,
87  	    MALLOCX_TCACHE_NONE) : rallocx(parser-&gt;buf, parser-&gt;len + len + 1,
88  	    MALLOCX_TCACHE_NONE);
89  	if (buf == NULL) {
90  		return true;
91  	}
92  	memcpy(&amp;buf[parser-&gt;len], str, len + 1);
93  	parser-&gt;buf = buf;
94  	parser-&gt;len += len;
95  	return false;
96  }
97  static bool
98  parser_tokenize(parser_t *parser) {
99  	enum {
100  		STATE_START,
101  		STATE_EOI,
102  		STATE_N, STATE_NU, STATE_NUL, STATE_NULL,
103  		STATE_F, STATE_FA, STATE_FAL, STATE_FALS, STATE_FALSE,
104  		STATE_T, STATE_TR, STATE_TRU, STATE_TRUE,
105  		STATE_LBRACKET,
106  		STATE_RBRACKET,
107  		STATE_LBRACE,
108  		STATE_RBRACE,
109  		STATE_COLON,
110  		STATE_COMMA,
111  		STATE_CHARS,
112  		STATE_CHAR_ESCAPE,
113  		STATE_CHAR_U, STATE_CHAR_UD, STATE_CHAR_UDD, STATE_CHAR_UDDD,
114  		STATE_STRING,
115  		STATE_MINUS,
116  		STATE_LEADING_ZERO,
117  		STATE_DIGITS,
118  		STATE_DECIMAL,
119  		STATE_FRAC_DIGITS,
120  		STATE_EXP,
121  		STATE_EXP_SIGN,
122  		STATE_EXP_DIGITS,
123  		STATE_ACCEPT
124  	} state = STATE_START;
125  	size_t token_pos JEMALLOC_CC_SILENCE_INIT(0);
126  	size_t token_line JEMALLOC_CC_SILENCE_INIT(1);
127  	size_t token_col JEMALLOC_CC_SILENCE_INIT(0);
128  	assert_zu_le(parser-&gt;pos, parser-&gt;len,
129  	    &quot;Position is past end of buffer&quot;);
130  	while (state != STATE_ACCEPT) {
131  		char c = parser-&gt;buf[parser-&gt;pos];
132  		switch (state) {
133  		case STATE_START:
134  			token_pos = parser-&gt;pos;
135  			token_line = parser-&gt;line;
136  			token_col = parser-&gt;col;
137  			switch (c) {
138  			case &#x27; &#x27;: case &#x27;\b&#x27;: case &#x27;\n&#x27;: case &#x27;\r&#x27;: case &#x27;\t&#x27;:
139  				break;
140  			case &#x27;\0&#x27;:
141  				state = STATE_EOI;
142  				break;
143  			case &#x27;n&#x27;:
144  				state = STATE_N;
145  				break;
146  			case &#x27;f&#x27;:
147  				state = STATE_F;
148  				break;
149  			case &#x27;t&#x27;:
150  				state = STATE_T;
151  				break;
152  			case &#x27;[&#x27;:
153  				state = STATE_LBRACKET;
154  				break;
155  			case &#x27;]&#x27;:
156  				state = STATE_RBRACKET;
157  				break;
158  			case &#x27;{&#x27;:
159  				state = STATE_LBRACE;
160  				break;
161  			case &#x27;}&#x27;:
162  				state = STATE_RBRACE;
163  				break;
164  			case &#x27;:&#x27;:
165  				state = STATE_COLON;
166  				break;
167  			case &#x27;,&#x27;:
168  				state = STATE_COMMA;
169  				break;
170  			case &#x27;&quot;&#x27;:
171  				state = STATE_CHARS;
172  				break;
173  			case &#x27;-&#x27;:
174  				state = STATE_MINUS;
175  				break;
176  			case &#x27;0&#x27;:
177  				state = STATE_LEADING_ZERO;
178  				break;
179  			case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;:
180  			case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
181  				state = STATE_DIGITS;
182  				break;
183  			default:
184  				token_init(&amp;parser-&gt;token, parser,
185  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
186  				    - token_pos, token_line, token_col);
187  				return true;
188  			}
189  			break;
190  		case STATE_EOI:
191  			token_init(&amp;parser-&gt;token, parser,
192  			    TOKEN_TYPE_EOI, token_pos, parser-&gt;pos -
193  			    token_pos, token_line, token_col);
194  			state = STATE_ACCEPT;
195  			break;
196  		case STATE_N:
197  			switch (c) {
198  			case &#x27;u&#x27;:
199  				state = STATE_NU;
200  				break;
201  			default:
202  				token_init(&amp;parser-&gt;token, parser,
203  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
204  				    - token_pos, token_line, token_col);
205  				return true;
206  			}
207  			break;
208  		case STATE_NU:
<span onclick='openModal()' class='match'>209  			switch (c) {
210  			case &#x27;l&#x27;:
211  				state = STATE_NUL;
212  				break;
213  			default:
214  				token_init(&amp;parser-&gt;token, parser,
</span>215  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
216  				    - token_pos, token_line, token_col);
217  				return true;
218  			}
219  			break;
220  		case STATE_NUL:
221  			switch (c) {
222  			case &#x27;l&#x27;:
223  				state = STATE_NULL;
224  				break;
225  			default:
226  				token_init(&amp;parser-&gt;token, parser,
227  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
228  				    - token_pos, token_line, token_col);
229  				return true;
230  			}
231  			break;
232  		case STATE_NULL:
233  			switch (c) {
234  			case &#x27; &#x27;: case &#x27;\b&#x27;: case &#x27;\n&#x27;: case &#x27;\r&#x27;: case &#x27;\t&#x27;:
235  			case &#x27;\0&#x27;:
236  			case &#x27;[&#x27;: case &#x27;]&#x27;: case &#x27;{&#x27;: case &#x27;}&#x27;: case &#x27;:&#x27;:
237  			case &#x27;,&#x27;:
238  				break;
239  			default:
240  				token_init(&amp;parser-&gt;token, parser,
241  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
242  				    - token_pos, token_line, token_col);
243  				return true;
244  			}
245  			token_init(&amp;parser-&gt;token, parser, TOKEN_TYPE_NULL,
246  			    token_pos, parser-&gt;pos - token_pos, token_line,
247  			    token_col);
248  			state = STATE_ACCEPT;
249  			break;
250  		case STATE_F:
251  			switch (c) {
252  			case &#x27;a&#x27;:
253  				state = STATE_FA;
254  				break;
255  			default:
256  				token_init(&amp;parser-&gt;token, parser,
257  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
258  				    - token_pos, token_line, token_col);
259  				return true;
260  			}
261  			break;
262  		case STATE_FA:
263  			switch (c) {
264  			case &#x27;l&#x27;:
265  				state = STATE_FAL;
266  				break;
267  			default:
268  				token_init(&amp;parser-&gt;token, parser,
269  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
270  				    - token_pos, token_line, token_col);
271  				return true;
272  			}
273  			break;
274  		case STATE_FAL:
275  			switch (c) {
276  			case &#x27;s&#x27;:
277  				state = STATE_FALS;
278  				break;
279  			default:
280  				token_init(&amp;parser-&gt;token, parser,
281  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
282  				    - token_pos, token_line, token_col);
283  				return true;
284  			}
285  			break;
286  		case STATE_FALS:
287  			switch (c) {
288  			case &#x27;e&#x27;:
289  				state = STATE_FALSE;
290  				break;
291  			default:
292  				token_init(&amp;parser-&gt;token, parser,
293  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
294  				    - token_pos, token_line, token_col);
295  				return true;
296  			}
297  			break;
298  		case STATE_FALSE:
299  			switch (c) {
300  			case &#x27; &#x27;: case &#x27;\b&#x27;: case &#x27;\n&#x27;: case &#x27;\r&#x27;: case &#x27;\t&#x27;:
301  			case &#x27;\0&#x27;:
302  			case &#x27;[&#x27;: case &#x27;]&#x27;: case &#x27;{&#x27;: case &#x27;}&#x27;: case &#x27;:&#x27;:
303  			case &#x27;,&#x27;:
304  				break;
305  			default:
306  				token_init(&amp;parser-&gt;token, parser,
307  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
308  				    - token_pos, token_line, token_col);
309  				return true;
310  			}
311  			token_init(&amp;parser-&gt;token, parser,
312  			    TOKEN_TYPE_FALSE, token_pos, parser-&gt;pos -
313  			    token_pos, token_line, token_col);
314  			state = STATE_ACCEPT;
315  			break;
316  		case STATE_T:
317  			switch (c) {
318  			case &#x27;r&#x27;:
319  				state = STATE_TR;
320  				break;
321  			default:
322  				token_init(&amp;parser-&gt;token, parser,
323  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
324  				    - token_pos, token_line, token_col);
325  				return true;
326  			}
327  			break;
328  		case STATE_TR:
329  			switch (c) {
330  			case &#x27;u&#x27;:
331  				state = STATE_TRU;
332  				break;
333  			default:
334  				token_init(&amp;parser-&gt;token, parser,
335  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
336  				    - token_pos, token_line, token_col);
337  				return true;
338  			}
339  			break;
340  		case STATE_TRU:
341  			switch (c) {
342  			case &#x27;e&#x27;:
343  				state = STATE_TRUE;
344  				break;
345  			default:
346  				token_init(&amp;parser-&gt;token, parser,
347  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
348  				    - token_pos, token_line, token_col);
349  				return true;
350  			}
351  			break;
352  		case STATE_TRUE:
353  			switch (c) {
354  			case &#x27; &#x27;: case &#x27;\b&#x27;: case &#x27;\n&#x27;: case &#x27;\r&#x27;: case &#x27;\t&#x27;:
355  			case &#x27;\0&#x27;:
356  			case &#x27;[&#x27;: case &#x27;]&#x27;: case &#x27;{&#x27;: case &#x27;}&#x27;: case &#x27;:&#x27;:
357  			case &#x27;,&#x27;:
358  				break;
359  			default:
360  				token_init(&amp;parser-&gt;token, parser,
361  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
362  				    - token_pos, token_line, token_col);
363  				return true;
364  			}
365  			token_init(&amp;parser-&gt;token, parser, TOKEN_TYPE_TRUE,
366  			    token_pos, parser-&gt;pos - token_pos, token_line,
367  			    token_col);
368  			state = STATE_ACCEPT;
369  			break;
370  		case STATE_LBRACKET:
371  			token_init(&amp;parser-&gt;token, parser, TOKEN_TYPE_LBRACKET,
372  			    token_pos, parser-&gt;pos - token_pos, token_line,
373  			    token_col);
374  			state = STATE_ACCEPT;
375  			break;
376  		case STATE_RBRACKET:
377  			token_init(&amp;parser-&gt;token, parser, TOKEN_TYPE_RBRACKET,
378  			    token_pos, parser-&gt;pos - token_pos, token_line,
379  			    token_col);
380  			state = STATE_ACCEPT;
381  			break;
382  		case STATE_LBRACE:
383  			token_init(&amp;parser-&gt;token, parser, TOKEN_TYPE_LBRACE,
384  			    token_pos, parser-&gt;pos - token_pos, token_line,
385  			    token_col);
386  			state = STATE_ACCEPT;
387  			break;
388  		case STATE_RBRACE:
389  			token_init(&amp;parser-&gt;token, parser, TOKEN_TYPE_RBRACE,
390  			    token_pos, parser-&gt;pos - token_pos, token_line,
391  			    token_col);
392  			state = STATE_ACCEPT;
393  			break;
394  		case STATE_COLON:
395  			token_init(&amp;parser-&gt;token, parser, TOKEN_TYPE_COLON,
396  			    token_pos, parser-&gt;pos - token_pos, token_line,
397  			    token_col);
398  			state = STATE_ACCEPT;
399  			break;
400  		case STATE_COMMA:
401  			token_init(&amp;parser-&gt;token, parser, TOKEN_TYPE_COMMA,
402  			    token_pos, parser-&gt;pos - token_pos, token_line,
403  			    token_col);
404  			state = STATE_ACCEPT;
405  			break;
406  		case STATE_CHARS:
407  			switch (c) {
408  			case &#x27;\\&#x27;:
409  				state = STATE_CHAR_ESCAPE;
410  				break;
411  			case &#x27;&quot;&#x27;:
412  				state = STATE_STRING;
413  				break;
414  			case 0x00: case 0x01: case 0x02: case 0x03: case 0x04:
415  			case 0x05: case 0x06: case 0x07: case 0x08: case 0x09:
416  			case 0x0a: case 0x0b: case 0x0c: case 0x0d: case 0x0e:
417  			case 0x0f: case 0x10: case 0x11: case 0x12: case 0x13:
418  			case 0x14: case 0x15: case 0x16: case 0x17: case 0x18:
419  			case 0x19: case 0x1a: case 0x1b: case 0x1c: case 0x1d:
420  			case 0x1e: case 0x1f:
421  				token_init(&amp;parser-&gt;token, parser,
422  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
423  				    - token_pos, token_line, token_col);
424  				return true;
425  			default:
426  				break;
427  			}
428  			break;
429  		case STATE_CHAR_ESCAPE:
430  			switch (c) {
431  			case &#x27;&quot;&#x27;: case &#x27;\\&#x27;: case &#x27;/&#x27;: case &#x27;b&#x27;: case &#x27;n&#x27;:
432  			case &#x27;r&#x27;: case &#x27;t&#x27;:
433  				state = STATE_CHARS;
434  				break;
435  			case &#x27;u&#x27;:
436  				state = STATE_CHAR_U;
437  				break;
438  			default:
439  				token_init(&amp;parser-&gt;token, parser,
440  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
441  				    - token_pos, token_line, token_col);
442  				return true;
443  			}
444  			break;
445  		case STATE_CHAR_U:
446  			switch (c) {
447  			case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;:
448  			case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
449  			case &#x27;a&#x27;: case &#x27;b&#x27;: case &#x27;c&#x27;: case &#x27;d&#x27;: case &#x27;e&#x27;:
450  			case &#x27;f&#x27;:
451  			case &#x27;A&#x27;: case &#x27;B&#x27;: case &#x27;C&#x27;: case &#x27;D&#x27;: case &#x27;E&#x27;:
452  			case &#x27;F&#x27;:
453  				state = STATE_CHAR_UD;
454  				break;
455  			default:
456  				token_init(&amp;parser-&gt;token, parser,
457  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
458  				    - token_pos, token_line, token_col);
459  				return true;
460  			}
461  			break;
462  		case STATE_CHAR_UD:
463  			switch (c) {
464  			case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;:
465  			case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
466  			case &#x27;a&#x27;: case &#x27;b&#x27;: case &#x27;c&#x27;: case &#x27;d&#x27;: case &#x27;e&#x27;:
467  			case &#x27;f&#x27;:
468  			case &#x27;A&#x27;: case &#x27;B&#x27;: case &#x27;C&#x27;: case &#x27;D&#x27;: case &#x27;E&#x27;:
469  			case &#x27;F&#x27;:
470  				state = STATE_CHAR_UDD;
471  				break;
472  			default:
473  				token_init(&amp;parser-&gt;token, parser,
474  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
475  				    - token_pos, token_line, token_col);
476  				return true;
477  			}
478  			break;
479  		case STATE_CHAR_UDD:
480  			switch (c) {
481  			case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;:
482  			case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
483  			case &#x27;a&#x27;: case &#x27;b&#x27;: case &#x27;c&#x27;: case &#x27;d&#x27;: case &#x27;e&#x27;:
484  			case &#x27;f&#x27;:
485  			case &#x27;A&#x27;: case &#x27;B&#x27;: case &#x27;C&#x27;: case &#x27;D&#x27;: case &#x27;E&#x27;:
486  			case &#x27;F&#x27;:
487  				state = STATE_CHAR_UDDD;
488  				break;
489  			default:
490  				token_init(&amp;parser-&gt;token, parser,
491  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
492  				    - token_pos, token_line, token_col);
493  				return true;
494  			}
495  			break;
496  		case STATE_CHAR_UDDD:
497  			switch (c) {
498  			case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;:
499  			case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
500  			case &#x27;a&#x27;: case &#x27;b&#x27;: case &#x27;c&#x27;: case &#x27;d&#x27;: case &#x27;e&#x27;:
501  			case &#x27;f&#x27;:
502  			case &#x27;A&#x27;: case &#x27;B&#x27;: case &#x27;C&#x27;: case &#x27;D&#x27;: case &#x27;E&#x27;:
503  			case &#x27;F&#x27;:
504  				state = STATE_CHARS;
505  				break;
506  			default:
507  				token_init(&amp;parser-&gt;token, parser,
508  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
509  				    - token_pos, token_line, token_col);
510  				return true;
511  			}
512  			break;
513  		case STATE_STRING:
514  			token_init(&amp;parser-&gt;token, parser, TOKEN_TYPE_STRING,
515  			    token_pos, parser-&gt;pos - token_pos, token_line,
516  			    token_col);
517  			state = STATE_ACCEPT;
518  			break;
519  		case STATE_MINUS:
520  			switch (c) {
521  			case &#x27;0&#x27;:
522  				state = STATE_LEADING_ZERO;
523  				break;
524  			case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;:
525  			case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
526  				state = STATE_DIGITS;
527  				break;
528  			default:
529  				token_init(&amp;parser-&gt;token, parser,
530  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
531  				    - token_pos, token_line, token_col);
532  				return true;
533  			}
534  			break;
535  		case STATE_LEADING_ZERO:
536  			switch (c) {
537  			case &#x27;.&#x27;:
538  				state = STATE_DECIMAL;
539  				break;
540  			default:
541  				token_init(&amp;parser-&gt;token, parser,
542  				    TOKEN_TYPE_NUMBER, token_pos, parser-&gt;pos -
543  				    token_pos, token_line, token_col);
544  				state = STATE_ACCEPT;
545  				break;
546  			}
547  			break;
548  		case STATE_DIGITS:
549  			switch (c) {
550  			case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;:
551  			case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
552  				break;
553  			case &#x27;.&#x27;:
554  				state = STATE_DECIMAL;
555  				break;
556  			default:
557  				token_init(&amp;parser-&gt;token, parser,
558  				    TOKEN_TYPE_NUMBER, token_pos, parser-&gt;pos -
559  				    token_pos, token_line, token_col);
560  				state = STATE_ACCEPT;
561  				break;
562  			}
563  			break;
564  		case STATE_DECIMAL:
565  			switch (c) {
566  			case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;:
567  			case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
568  				state = STATE_FRAC_DIGITS;
569  				break;
570  			default:
571  				token_init(&amp;parser-&gt;token, parser,
572  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
573  				    - token_pos, token_line, token_col);
574  				return true;
575  			}
576  			break;
577  		case STATE_FRAC_DIGITS:
578  			switch (c) {
579  			case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;:
580  			case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
581  				break;
582  			case &#x27;e&#x27;: case &#x27;E&#x27;:
583  				state = STATE_EXP;
584  				break;
585  			default:
586  				token_init(&amp;parser-&gt;token, parser,
587  				    TOKEN_TYPE_NUMBER, token_pos, parser-&gt;pos -
588  				    token_pos, token_line, token_col);
589  				state = STATE_ACCEPT;
590  				break;
591  			}
592  			break;
593  		case STATE_EXP:
594  			switch (c) {
595  			case &#x27;-&#x27;: case &#x27;+&#x27;:
596  				state = STATE_EXP_SIGN;
597  				break;
598  			case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;:
599  			case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
600  				state = STATE_EXP_DIGITS;
601  				break;
602  			default:
603  				token_init(&amp;parser-&gt;token, parser,
604  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
605  				    - token_pos, token_line, token_col);
606  				return true;
607  			}
608  			break;
609  		case STATE_EXP_SIGN:
610  			switch (c) {
611  			case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;:
612  			case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
613  				state = STATE_EXP_DIGITS;
614  				break;
615  			default:
616  				token_init(&amp;parser-&gt;token, parser,
617  				    TOKEN_TYPE_ERROR, token_pos, parser-&gt;pos + 1
618  				    - token_pos, token_line, token_col);
619  				return true;
620  			}
621  			break;
622  		case STATE_EXP_DIGITS:
623  			switch (c) {
624  			case &#x27;0&#x27;: case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;:
625  			case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;:
626  				break;
627  			default:
628  				token_init(&amp;parser-&gt;token, parser,
629  				    TOKEN_TYPE_NUMBER, token_pos, parser-&gt;pos -
630  				    token_pos, token_line, token_col);
631  				state = STATE_ACCEPT;
632  				break;
633  			}
634  			break;
635  		default:
636  			not_reached();
637  		}
638  		if (state != STATE_ACCEPT) {
639  			if (c == &#x27;\n&#x27;) {
640  				parser-&gt;line++;
641  				parser-&gt;col = 0;
642  			} else {
643  				parser-&gt;col++;
644  			}
645  			parser-&gt;pos++;
646  		}
647  	}
648  	return false;
649  }
650  static bool	parser_parse_array(parser_t *parser);
651  static bool	parser_parse_object(parser_t *parser);
652  static bool
653  parser_parse_value(parser_t *parser) {
654  	switch (parser-&gt;token.token_type) {
655  	case TOKEN_TYPE_NULL:
656  	case TOKEN_TYPE_FALSE:
657  	case TOKEN_TYPE_TRUE:
658  	case TOKEN_TYPE_STRING:
659  	case TOKEN_TYPE_NUMBER:
660  		return false;
661  	case TOKEN_TYPE_LBRACE:
662  		return parser_parse_object(parser);
663  	case TOKEN_TYPE_LBRACKET:
664  		return parser_parse_array(parser);
665  	default:
666  		return true;
667  	}
668  	not_reached();
669  }
670  static bool
671  parser_parse_pair(parser_t *parser) {
672  	assert_d_eq(parser-&gt;token.token_type, TOKEN_TYPE_STRING,
673  	    &quot;Pair should start with string&quot;);
674  	if (parser_tokenize(parser)) {
675  		return true;
676  	}
677  	switch (parser-&gt;token.token_type) {
678  	case TOKEN_TYPE_COLON:
679  		if (parser_tokenize(parser)) {
680  			return true;
681  		}
682  		return parser_parse_value(parser);
683  	default:
684  		return true;
685  	}
686  }
687  static bool
688  parser_parse_values(parser_t *parser) {
689  	if (parser_parse_value(parser)) {
690  		return true;
691  	}
692  	while (true) {
693  		if (parser_tokenize(parser)) {
694  			return true;
695  		}
696  		switch (parser-&gt;token.token_type) {
697  		case TOKEN_TYPE_COMMA:
698  			if (parser_tokenize(parser)) {
699  				return true;
700  			}
701  			if (parser_parse_value(parser)) {
702  				return true;
703  			}
704  			break;
705  		case TOKEN_TYPE_RBRACKET:
706  			return false;
707  		default:
708  			return true;
709  		}
710  	}
711  }
712  static bool
713  parser_parse_array(parser_t *parser) {
714  	assert_d_eq(parser-&gt;token.token_type, TOKEN_TYPE_LBRACKET,
715  	    &quot;Array should start with [&quot;);
716  	if (parser_tokenize(parser)) {
717  		return true;
718  	}
719  	switch (parser-&gt;token.token_type) {
720  	case TOKEN_TYPE_RBRACKET:
721  		return false;
722  	default:
723  		return parser_parse_values(parser);
724  	}
725  	not_reached();
726  }
727  static bool
728  parser_parse_pairs(parser_t *parser) {
729  	assert_d_eq(parser-&gt;token.token_type, TOKEN_TYPE_STRING,
730  	    &quot;Object should start with string&quot;);
731  	if (parser_parse_pair(parser)) {
732  		return true;
733  	}
734  	while (true) {
735  		if (parser_tokenize(parser)) {
736  			return true;
737  		}
738  		switch (parser-&gt;token.token_type) {
739  		case TOKEN_TYPE_COMMA:
740  			if (parser_tokenize(parser)) {
741  				return true;
742  			}
743  			switch (parser-&gt;token.token_type) {
744  			case TOKEN_TYPE_STRING:
745  				if (parser_parse_pair(parser)) {
746  					return true;
747  				}
748  				break;
749  			default:
750  				return true;
751  			}
752  			break;
753  		case TOKEN_TYPE_RBRACE:
754  			return false;
755  		default:
756  			return true;
757  		}
758  	}
759  }
760  static bool
761  parser_parse_object(parser_t *parser) {
762  	assert_d_eq(parser-&gt;token.token_type, TOKEN_TYPE_LBRACE,
763  	    &quot;Object should start with {&quot;);
764  	if (parser_tokenize(parser)) {
765  		return true;
766  	}
767  	switch (parser-&gt;token.token_type) {
768  	case TOKEN_TYPE_STRING:
769  		return parser_parse_pairs(parser);
770  	case TOKEN_TYPE_RBRACE:
771  		return false;
772  	default:
773  		return true;
774  	}
775  	not_reached();
776  }
777  static bool
778  parser_parse(parser_t *parser) {
779  	if (parser_tokenize(parser)) {
780  		goto label_error;
781  	}
782  	if (parser_parse_value(parser)) {
783  		goto label_error;
784  	}
785  	if (parser_tokenize(parser)) {
786  		goto label_error;
787  	}
788  	switch (parser-&gt;token.token_type) {
789  	case TOKEN_TYPE_EOI:
790  		return false;
791  	default:
792  		goto label_error;
793  	}
794  	not_reached();
795  label_error:
796  	token_error(&amp;parser-&gt;token);
797  	return true;
798  }
799  TEST_BEGIN(test_json_parser) {
800  	size_t i;
801  	const char *invalid_inputs[] = {
802  		&quot;{ \&quot;string\&quot;: X }&quot;,
803  		&quot;{ \&quot;string\&quot;: nXll }&quot;,
804  		&quot;{ \&quot;string\&quot;: nuXl }&quot;,
805  		&quot;{ \&quot;string\&quot;: nulX }&quot;,
806  		&quot;{ \&quot;string\&quot;: nullX }&quot;,
807  		&quot;{ \&quot;string\&quot;: fXlse }&quot;,
808  		&quot;{ \&quot;string\&quot;: faXse }&quot;,
809  		&quot;{ \&quot;string\&quot;: falXe }&quot;,
810  		&quot;{ \&quot;string\&quot;: falsX }&quot;,
811  		&quot;{ \&quot;string\&quot;: falseX }&quot;,
812  		&quot;{ \&quot;string\&quot;: tXue }&quot;,
813  		&quot;{ \&quot;string\&quot;: trXe }&quot;,
814  		&quot;{ \&quot;string\&quot;: truX }&quot;,
815  		&quot;{ \&quot;string\&quot;: trueX }&quot;,
816  		&quot;{ \&quot;string\&quot;: \&quot;\n\&quot; }&quot;,
817  		&quot;{ \&quot;string\&quot;: \&quot;\\z\&quot; }&quot;,
818  		&quot;{ \&quot;string\&quot;: \&quot;\\uX000\&quot; }&quot;,
819  		&quot;{ \&quot;string\&quot;: \&quot;\\u0X00\&quot; }&quot;,
820  		&quot;{ \&quot;string\&quot;: \&quot;\\u00X0\&quot; }&quot;,
821  		&quot;{ \&quot;string\&quot;: \&quot;\\u000X\&quot; }&quot;,
822  		&quot;{ \&quot;string\&quot;: -X }&quot;,
823  		&quot;{ \&quot;string\&quot;: 0.X }&quot;,
824  		&quot;{ \&quot;string\&quot;: 0.0eX }&quot;,
825  		&quot;{ \&quot;string\&quot;: 0.0e+X }&quot;,
826  		&quot;{\&quot;string\&quot;: }&quot;,
827  		&quot;{\&quot;string\&quot; }&quot;,
828  		&quot;{\&quot;string\&quot;: [ 0 }&quot;,
829  		&quot;{\&quot;string\&quot;: {\&quot;a\&quot;:0, 1 } }&quot;,
830  		&quot;{\&quot;string\&quot;: {\&quot;a\&quot;:0: } }&quot;,
831  		&quot;{&quot;,
832  		&quot;{}{&quot;,
833  	};
834  	const char *valid_inputs[] = {
835  		&quot;null&quot;,
836  		&quot;false&quot;,
837  		&quot;true&quot;,
838  		&quot;{}&quot;,
839  		&quot;{\&quot;a\&quot;: 0}&quot;,
840  		&quot;[]&quot;,
841  		&quot;[0, 1]&quot;,
842  		&quot;0&quot;,
843  		&quot;1&quot;,
844  		&quot;10&quot;,
845  		&quot;-10&quot;,
846  		&quot;10.23&quot;,
847  		&quot;10.23e4&quot;,
848  		&quot;10.23e-4&quot;,
849  		&quot;10.23e+4&quot;,
850  		&quot;10.23E4&quot;,
851  		&quot;10.23E-4&quot;,
852  		&quot;10.23E+4&quot;,
853  		&quot;-10.23&quot;,
854  		&quot;-10.23e4&quot;,
855  		&quot;-10.23e-4&quot;,
856  		&quot;-10.23e+4&quot;,
857  		&quot;-10.23E4&quot;,
858  		&quot;-10.23E-4&quot;,
859  		&quot;-10.23E+4&quot;,
860  		&quot;\&quot;value\&quot;&quot;,
861  		&quot;\&quot; \\\&quot; \\/ \\b \\n \\r \\t \\u0abc \\u1DEF \&quot;&quot;,
862  		&quot;{\&quot;a\&quot;:null, \&quot;b\&quot;:[1,[{\&quot;c\&quot;:2},3]], \&quot;d\&quot;:{\&quot;e\&quot;:true}}&quot;,
863  	};
864  	for (i = 0; i &lt; sizeof(invalid_inputs)/sizeof(const char *); i++) {
865  		const char *input = invalid_inputs[i];
866  		parser_t parser;
867  		parser_init(&amp;parser, false);
868  		assert_false(parser_append(&amp;parser, input),
869  		    &quot;Unexpected input appending failure&quot;);
870  		assert_true(parser_parse(&amp;parser),
871  		    &quot;Unexpected parse success for input: %s&quot;, input);
872  		parser_fini(&amp;parser);
873  	}
874  	for (i = 0; i &lt; sizeof(valid_inputs)/sizeof(const char *); i++) {
875  		const char *input = valid_inputs[i];
876  		parser_t parser;
877  		parser_init(&amp;parser, true);
878  		assert_false(parser_append(&amp;parser, input),
879  		    &quot;Unexpected input appending failure&quot;);
880  		assert_false(parser_parse(&amp;parser),
881  		    &quot;Unexpected parse error for input: %s&quot;, input);
882  		parser_fini(&amp;parser);
883  	}
884  }
885  TEST_END
886  void
887  write_cb(void *opaque, const char *str) {
888  	parser_t *parser = (parser_t *)opaque;
889  	if (parser_append(parser, str)) {
890  		test_fail(&quot;Unexpected input appending failure&quot;);
891  	}
892  }
893  TEST_BEGIN(test_stats_print_json) {
894  	const char *opts[] = {
895  		&quot;J&quot;,
896  		&quot;Jg&quot;,
897  		&quot;Jm&quot;,
898  		&quot;Jd&quot;,
899  		&quot;Jmd&quot;,
900  		&quot;Jgd&quot;,
901  		&quot;Jgm&quot;,
902  		&quot;Jgmd&quot;,
903  		&quot;Ja&quot;,
904  		&quot;Jb&quot;,
905  		&quot;Jl&quot;,
906  		&quot;Jx&quot;,
907  		&quot;Jbl&quot;,
908  		&quot;Jal&quot;,
909  		&quot;Jab&quot;,
910  		&quot;Jabl&quot;,
911  		&quot;Jax&quot;,
912  		&quot;Jbx&quot;,
913  		&quot;Jlx&quot;,
914  		&quot;Jablx&quot;,
915  		&quot;Jgmdablx&quot;,
916  	};
917  	unsigned arena_ind, i;
918  	for (i = 0; i &lt; 3; i++) {
919  		unsigned j;
920  		switch (i) {
921  		case 0:
922  			break;
923  		case 1: {
924  			size_t sz = sizeof(arena_ind);
925  			assert_d_eq(mallctl(&quot;arenas.create&quot;, (void *)&amp;arena_ind,
926  			    &amp;sz, NULL, 0), 0, &quot;Unexpected mallctl failure&quot;);
927  			break;
928  		} case 2: {
929  			size_t mib[3];
930  			size_t miblen = sizeof(mib)/sizeof(size_t);
931  			assert_d_eq(mallctlnametomib(&quot;arena.0.destroy&quot;,
932  			    mib, &amp;miblen), 0,
933  			    &quot;Unexpected mallctlnametomib failure&quot;);
934  			mib[1] = arena_ind;
935  			assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL,
936  			    0), 0, &quot;Unexpected mallctlbymib failure&quot;);
937  			break;
938  		} default:
939  			not_reached();
940  		}
941  		for (j = 0; j &lt; sizeof(opts)/sizeof(const char *); j++) {
942  			parser_t parser;
943  			parser_init(&amp;parser, true);
944  			malloc_stats_print(write_cb, (void *)&amp;parser, opts[j]);
945  			assert_false(parser_parse(&amp;parser),
946  			    &quot;Unexpected parse error, opts=\&quot;%s\&quot;&quot;, opts[j]);
947  			parser_fini(&amp;parser);
948  		}
949  	}
950  }
951  TEST_END
952  int
953  main(void) {
954  	return test(
955  	    test_json_parser,
956  	    test_stats_print_json);
957  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-stats_print.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-stats_print.c</div>
                </div>
                <div class="column column_space"><pre><code>275  			switch (c) {
276  			case &#x27;s&#x27;:
277  				state = STATE_FALS;
278  				break;
279  			default:
280  				token_init(&amp;parser-&gt;token, parser,
</pre></code></div>
                <div class="column column_space"><pre><code>209  			switch (c) {
210  			case &#x27;l&#x27;:
211  				state = STATE_NUL;
212  				break;
213  			default:
214  				token_init(&amp;parser-&gt;token, parser,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    