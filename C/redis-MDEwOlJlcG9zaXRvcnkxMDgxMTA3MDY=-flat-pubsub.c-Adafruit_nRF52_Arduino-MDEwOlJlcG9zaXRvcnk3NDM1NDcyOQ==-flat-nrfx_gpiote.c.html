
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.5760430686406455%, Tokens: 9</h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-pubsub.c</h3>
            <pre><code>1  #include "server.h"
2  void freePubsubPattern(void *p) {
3      pubsubPattern *pat = p;
4      decrRefCount(pat->pattern);
5      zfree(pat);
6  }
7  int listMatchPubsubPattern(void *a, void *b) {
8      pubsubPattern *pa = a, *pb = b;
9      return (pa->client == pb->client) &&
10             (equalStringObjects(pa->pattern,pb->pattern));
11  }
12  int clientSubscriptionsCount(client *c) {
13      return (int)(dictSize(c->pubsub_channels)+                                  WIN_PORT_FIX &bsol;* cast (int) */
14             listLength(c->pubsub_patterns));
15  }
16  int pubsubSubscribeChannel(client *c, robj *channel) {
17      dictEntry *de;
18      list *clients = NULL;
19      int retval = 0;
20      if (dictAdd(c->pubsub_channels,channel,NULL) == DICT_OK) {
21          retval = 1;
22          incrRefCount(channel);
23          de = dictFind(server.pubsub_channels,channel);
24          if (de == NULL) {
<span onclick='openModal()' class='match'>25              clients = listCreate();
26              dictAdd(server.pubsub_channels,channel,clients);
27              incrRefCount(channel);
28          } else {
29              clients = dictGetVal(de);
30          }
31          listAddNodeTail(clients,c);
32      }
33      addReply(c,shared.mbulkhdr[3]);
34      addReply(c,shared.subscribebulk);
35      addReplyBulk(c,channel);
36      addReplyLongLong(c,clientSubscriptionsCount(c));
37      return retval;
38  }
</span>39  int pubsubUnsubscribeChannel(client *c, robj *channel, int notify) {
40      dictEntry *de;
41      list *clients;
42      listNode *ln;
43      int retval = 0;
44      incrRefCount(channel); &bsol;* channel may be just a pointer to the same object
45                              we have in the hash tables. Protect it... */
46      if (dictDelete(c->pubsub_channels,channel) == DICT_OK) {
47          retval = 1;
48          de = dictFind(server.pubsub_channels,channel);
49          serverAssertWithInfo(c,NULL,de != NULL);
50          clients = dictGetVal(de);
51          ln = listSearchKey(clients,c);
52          serverAssertWithInfo(c,NULL,ln != NULL);
53          listDelNode(clients,ln);
54          if (listLength(clients) == 0) {
55              dictDelete(server.pubsub_channels,channel);
56          }
57      }
58      if (notify) {
59          addReply(c,shared.mbulkhdr[3]);
60          addReply(c,shared.unsubscribebulk);
61          addReplyBulk(c,channel);
62          addReplyLongLong(c,dictSize(c->pubsub_channels)+
63                         listLength(c->pubsub_patterns));
64      }
65      decrRefCount(channel); &bsol;* it is finally safe to release it */
66      return retval;
67  }
68  int pubsubSubscribePattern(client *c, robj *pattern) {
69      int retval = 0;
70      if (listSearchKey(c->pubsub_patterns,pattern) == NULL) {
71          retval = 1;
72          pubsubPattern *pat;
73          listAddNodeTail(c->pubsub_patterns,pattern);
74          incrRefCount(pattern);
75          pat = zmalloc(sizeof(*pat));
76          pat->pattern = getDecodedObject(pattern);
77          pat->client = c;
78          listAddNodeTail(server.pubsub_patterns,pat);
79      }
80      addReply(c,shared.mbulkhdr[3]);
81      addReply(c,shared.psubscribebulk);
82      addReplyBulk(c,pattern);
83      addReplyLongLong(c,clientSubscriptionsCount(c));
84      return retval;
85  }
86  int pubsubUnsubscribePattern(client *c, robj *pattern, int notify) {
87      listNode *ln;
88      pubsubPattern pat;
89      int retval = 0;
90      incrRefCount(pattern); &bsol;* Protect the object. May be the same we remove */
91      if ((ln = listSearchKey(c->pubsub_patterns,pattern)) != NULL) {
92          retval = 1;
93          listDelNode(c->pubsub_patterns,ln);
94          pat.client = c;
95          pat.pattern = pattern;
96          ln = listSearchKey(server.pubsub_patterns,&pat);
97          listDelNode(server.pubsub_patterns,ln);
98      }
99      if (notify) {
100          addReply(c,shared.mbulkhdr[3]);
101          addReply(c,shared.punsubscribebulk);
102          addReplyBulk(c,pattern);
103          addReplyLongLong(c,dictSize(c->pubsub_channels)+
104                         listLength(c->pubsub_patterns));
105      }
106      decrRefCount(pattern);
107      return retval;
108  }
109  int pubsubUnsubscribeAllChannels(client *c, int notify) {
110      dictIterator *di = dictGetSafeIterator(c->pubsub_channels);
111      dictEntry *de;
112      int count = 0;
113      while((de = dictNext(di)) != NULL) {
114          robj *channel = dictGetKey(de);
115          count += pubsubUnsubscribeChannel(c,channel,notify);
116      }
117      if (notify && count == 0) {
118          addReply(c,shared.mbulkhdr[3]);
119          addReply(c,shared.unsubscribebulk);
120          addReply(c,shared.nullbulk);
121          addReplyLongLong(c,dictSize(c->pubsub_channels)+
122                         listLength(c->pubsub_patterns));
123      }
124      dictReleaseIterator(di);
125      return count;
126  }
127  int pubsubUnsubscribeAllPatterns(client *c, int notify) {
128      listNode *ln;
129      listIter li;
130      int count = 0;
131      listRewind(c->pubsub_patterns,&li);
132      while ((ln = listNext(&li)) != NULL) {
133          robj *pattern = ln->value;
134          count += pubsubUnsubscribePattern(c,pattern,notify);
135      }
136      if (notify && count == 0) {
137          addReply(c,shared.mbulkhdr[3]);
138          addReply(c,shared.punsubscribebulk);
139          addReply(c,shared.nullbulk);
140          addReplyLongLong(c,dictSize(c->pubsub_channels)+
141                         listLength(c->pubsub_patterns));
142      }
143      return count;
144  }
145  int pubsubPublishMessage(robj *channel, robj *message) {
146      int receivers = 0;
147      dictEntry *de;
148      listNode *ln;
149      listIter li;
150      de = dictFind(server.pubsub_channels,channel);
151      if (de) {
152          list *list = dictGetVal(de);
153          listNode *ln;
154          listIter li;
155          listRewind(list,&li);
156          while ((ln = listNext(&li)) != NULL) {
157              client *c = ln->value;
158              addReply(c,shared.mbulkhdr[3]);
159              addReply(c,shared.messagebulk);
160              addReplyBulk(c,channel);
161              addReplyBulk(c,message);
162              receivers++;
163          }
164      }
165      if (listLength(server.pubsub_patterns)) {
166          listRewind(server.pubsub_patterns,&li);
167          channel = getDecodedObject(channel);
168          while ((ln = listNext(&li)) != NULL) {
169              pubsubPattern *pat = ln->value;
170              if (stringmatchlen((char*)pat->pattern->ptr,
171                                  (int)sdslen(pat->pattern->ptr),                 WIN_PORT_FIX &bsol;* cast (int) */
172                                  (char*)channel->ptr,
173                                  (int)sdslen(channel->ptr),0)) {                 WIN_PORT_FIX &bsol;* cast (int) */
174                  addReply(pat->client,shared.mbulkhdr[4]);
175                  addReply(pat->client,shared.pmessagebulk);
176                  addReplyBulk(pat->client,pat->pattern);
177                  addReplyBulk(pat->client,channel);
178                  addReplyBulk(pat->client,message);
179                  receivers++;
180              }
181          }
182          decrRefCount(channel);
183      }
184      return receivers;
185  }
186  void subscribeCommand(client *c) {
187      int j;
188      for (j = 1; j < c->argc; j++)
189          pubsubSubscribeChannel(c,c->argv[j]);
190      c->flags |= CLIENT_PUBSUB;
191  }
192  void unsubscribeCommand(client *c) {
193      if (c->argc == 1) {
194          pubsubUnsubscribeAllChannels(c,1);
195      } else {
196          int j;
197          for (j = 1; j < c->argc; j++)
198              pubsubUnsubscribeChannel(c,c->argv[j],1);
199      }
200      if (clientSubscriptionsCount(c) == 0) c->flags &= ~CLIENT_PUBSUB;
201  }
202  void psubscribeCommand(client *c) {
203      int j;
204      for (j = 1; j < c->argc; j++)
205          pubsubSubscribePattern(c,c->argv[j]);
206      c->flags |= CLIENT_PUBSUB;
207  }
208  void punsubscribeCommand(client *c) {
209      if (c->argc == 1) {
210          pubsubUnsubscribeAllPatterns(c,1);
211      } else {
212          int j;
213          for (j = 1; j < c->argc; j++)
214              pubsubUnsubscribePattern(c,c->argv[j],1);
215      }
216      if (clientSubscriptionsCount(c) == 0) c->flags &= ~CLIENT_PUBSUB;
217  }
218  void publishCommand(client *c) {
219      int receivers = pubsubPublishMessage(c->argv[1],c->argv[2]);
220      if (server.cluster_enabled)
221          clusterPropagatePublish(c->argv[1],c->argv[2]);
222      else
223          forceCommandPropagation(c,PROPAGATE_REPL);
224      addReplyLongLong(c,receivers);
225  }
226  void pubsubCommand(client *c) {
227      if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
228          const char *help[] = {
229  "CHANNELS [<pattern>] -- Return the currently active channels matching a pattern (default: all).",
230  "NUMPAT -- Return number of subscriptions to patterns.",
231  "NUMSUB [channel-1 .. channel-N] -- Returns the number of subscribers for the specified channels (excluding patterns, default: none).",
232  NULL
233          };
234          addReplyHelp(c, help);
235      } else if (!strcasecmp(c->argv[1]->ptr,"channels") &&
236          (c->argc == 2 || c->argc == 3))
237      {
238          sds pat = (c->argc == 2) ? NULL : c->argv[2]->ptr;
239          dictIterator *di = dictGetIterator(server.pubsub_channels);
240          dictEntry *de;
241          PORT_LONG mblen = 0;
242          void *replylen;
243          replylen = addDeferredMultiBulkLength(c);
244          while((de = dictNext(di)) != NULL) {
245              robj *cobj = dictGetKey(de);
246              sds channel = cobj->ptr;
247              if (!pat || stringmatchlen(pat, (int)sdslen(pat),                   WIN_PORT_FIX &bsol;* cast (int) */
248                                         channel, (int)sdslen(channel),0))        WIN_PORT_FIX &bsol;* cast (int) */
249              {
250                  addReplyBulk(c,cobj);
251                  mblen++;
252              }
253          }
254          dictReleaseIterator(di);
255          setDeferredMultiBulkLength(c,replylen,mblen);
256      } else if (!strcasecmp(c->argv[1]->ptr,"numsub") && c->argc >= 2) {
257          int j;
258          addReplyMultiBulkLen(c,(c->argc-2)*2);
259          for (j = 2; j < c->argc; j++) {
260              list *l = dictFetchValue(server.pubsub_channels,c->argv[j]);
261              addReplyBulk(c,c->argv[j]);
262              addReplyLongLong(c,l ? listLength(l) : 0);
263          }
264      } else if (!strcasecmp(c->argv[1]->ptr,"numpat") && c->argc == 2) {
265          addReplyLongLong(c,listLength(server.pubsub_patterns));
266      } else {
267          addReplySubcommandSyntaxError(c);
268      }
269  }
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_gpiote.c</h3>
            <pre><code>1  #include <nrfx.h>
2  #if NRFX_CHECK(NRFX_GPIOTE_ENABLED)
3  #include <nrfx_gpiote.h>
4  #include "nrf_bitmask.h"
5  #include <string.h>
6  #define NRFX_LOG_MODULE GPIOTE
7  #include <nrfx_log.h>
8  #define FORBIDDEN_HANDLER_ADDRESS ((nrfx_gpiote_evt_handler_t)UINT32_MAX)
9  #define PIN_NOT_USED              (-1)
10  #define PIN_USED                  (-2)
11  #define NO_CHANNELS               (-1)
12  #define POLARITY_FIELD_POS        (6)
13  #define POLARITY_FIELD_MASK       (0xC0)
14  NRFX_STATIC_ASSERT(NUMBER_OF_PINS <= (1 << POLARITY_FIELD_POS));
15  typedef struct
16  {
17      nrfx_gpiote_evt_handler_t handlers[GPIOTE_CH_NUM + NRFX_GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS];
18      int8_t                    pin_assignments[NUMBER_OF_PINS];
19      int8_t                    port_handlers_pins[NRFX_GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS];
20      uint8_t                   configured_pins[((NUMBER_OF_PINS)+7) / 8];
21      nrfx_drv_state_t          state;
22  } gpiote_control_block_t;
23  static gpiote_control_block_t m_cb;
24  static bool pin_in_use(uint32_t pin)
25  {
26      return (m_cb.pin_assignments[pin] != PIN_NOT_USED);
27  }
28  static bool pin_in_use_as_non_task_out(uint32_t pin)
29  {
30      return (m_cb.pin_assignments[pin] == PIN_USED);
31  }
32  static bool pin_in_use_by_te(uint32_t pin)
33  {
34      return (m_cb.pin_assignments[pin] >= 0 && m_cb.pin_assignments[pin] < GPIOTE_CH_NUM) ?
35              true : false;
36  }
37  static bool pin_in_use_by_port(uint32_t pin)
38  {
39      return (m_cb.pin_assignments[pin] >= GPIOTE_CH_NUM);
40  }
41  static bool pin_in_use_by_gpiote(uint32_t pin)
42  {
43      return (m_cb.pin_assignments[pin] >= 0);
44  }
45  static void pin_in_use_by_te_set(uint32_t                  pin,
46                                   uint32_t                  channel_id,
47                                   nrfx_gpiote_evt_handler_t handler,
48                                   bool                      is_channel)
49  {
50      m_cb.pin_assignments[pin] = channel_id;
51      m_cb.handlers[channel_id] = handler;
52      if (!is_channel)
53      {
54          m_cb.port_handlers_pins[channel_id - GPIOTE_CH_NUM] = (int8_t)pin;
55      }
56  }
57  static void pin_in_use_set(uint32_t pin)
58  {
59      m_cb.pin_assignments[pin] = PIN_USED;
60  }
61  static void pin_in_use_clear(uint32_t pin)
62  {
63      m_cb.pin_assignments[pin] = PIN_NOT_USED;
64  }
65  static void pin_configured_set(uint32_t pin)
66  {
67      nrf_bitmask_bit_set(pin, m_cb.configured_pins);
68  }
69  static void pin_configured_clear(uint32_t pin)
70  {
71      nrf_bitmask_bit_clear(pin, m_cb.configured_pins);
72  }
73  static bool pin_configured_check(uint32_t pin)
74  {
75      return 0 != nrf_bitmask_bit_is_set(pin, m_cb.configured_pins);
76  }
77  static int8_t channel_port_get(uint32_t pin)
78  {
79      return m_cb.pin_assignments[pin];
80  }
81  static nrfx_gpiote_evt_handler_t channel_handler_get(uint32_t channel)
82  {
83      return m_cb.handlers[channel];
84  }
85  static nrfx_gpiote_pin_t port_handler_pin_get(uint32_t handler_idx)
86  {
87      uint8_t pin_and_polarity = (uint8_t)m_cb.port_handlers_pins[handler_idx];
88      return (nrfx_gpiote_pin_t)(pin_and_polarity & ~POLARITY_FIELD_MASK);
89  }
90  static nrf_gpiote_polarity_t port_handler_polarity_get(uint32_t handler_idx)
91  {
92      uint8_t pin_and_polarity = (uint8_t)m_cb.port_handlers_pins[handler_idx];
93      return (nrf_gpiote_polarity_t)((pin_and_polarity & POLARITY_FIELD_MASK) >> POLARITY_FIELD_POS);
94  }
95  static int8_t channel_port_alloc(uint32_t pin, nrfx_gpiote_evt_handler_t handler, bool channel)
96  {
97      int8_t   channel_id = NO_CHANNELS;
98      uint32_t i;
99      uint32_t start_idx = channel ? 0 : GPIOTE_CH_NUM;
100      uint32_t end_idx   =
101          channel ? GPIOTE_CH_NUM : (GPIOTE_CH_NUM + NRFX_GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS);
102      for (i = start_idx; i < end_idx; i++)
103      {
104          if (m_cb.handlers[i] == FORBIDDEN_HANDLER_ADDRESS)
105          {
106              pin_in_use_by_te_set(pin, i, handler, channel);
107              channel_id = i;
108              break;
109          }
110      }
111      return channel_id;
112  }
113  static void channel_free(uint8_t channel_id)
114  {
115      m_cb.handlers[channel_id] = FORBIDDEN_HANDLER_ADDRESS;
116      if (channel_id >= GPIOTE_CH_NUM)
117      {
118          m_cb.port_handlers_pins[channel_id - GPIOTE_CH_NUM] = (int8_t)PIN_NOT_USED;
119      }
120  }
121  nrfx_err_t nrfx_gpiote_init(uint8_t interrupt_priority)
122  {
123      nrfx_err_t err_code;
124      if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
125      {
126          err_code = NRFX_ERROR_INVALID_STATE;
127          NRFX_LOG_WARNING("Function: %s, error code: %s.",
128                           __func__,
129                           NRFX_LOG_ERROR_STRING_GET(err_code));
130          return err_code;
131      }
132      uint8_t i;
133      for (i = 0; i < NUMBER_OF_PINS; i++)
134      {
135          pin_in_use_clear(i);
136      }
137      for (i = 0; i < (GPIOTE_CH_NUM + NRFX_GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS); i++)
138      {
139          channel_free(i);
140      }
141      memset(m_cb.configured_pins, 0, sizeof(m_cb.configured_pins));
142      NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_GPIOTE), interrupt_priority);
143      NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_GPIOTE));
144      nrf_gpiote_event_clear(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT);
145      nrf_gpiote_int_enable(NRF_GPIOTE, GPIOTE_INTENSET_PORT_Msk);
146      m_cb.state = NRFX_DRV_STATE_INITIALIZED;
147      err_code = NRFX_SUCCESS;
148      NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
149      return err_code;
150  }
151  bool nrfx_gpiote_is_init(void)
152  {
153      return (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED) ? true : false;
154  }
155  void nrfx_gpiote_uninit(void)
156  {
157      NRFX_ASSERT(m_cb.state != NRFX_DRV_STATE_UNINITIALIZED);
158      uint32_t i;
159      for (i = 0; i < NUMBER_OF_PINS; i++)
160      {
161          if (pin_in_use_as_non_task_out(i))
162          {
163              nrfx_gpiote_out_uninit(i);
164          }
165          else if ( pin_in_use_by_gpiote(i))
166          {
167              nrfx_gpiote_in_uninit(i);
168          }
169      }
170      m_cb.state = NRFX_DRV_STATE_UNINITIALIZED;
171      NRFX_LOG_INFO("Uninitialized.");
172  }
173  nrfx_err_t nrfx_gpiote_out_init(nrfx_gpiote_pin_t                pin,
174                                  nrfx_gpiote_out_config_t const * p_config)
175  {
176      NRFX_ASSERT(pin < NUMBER_OF_PINS);
177      NRFX_ASSERT(m_cb.state == NRFX_DRV_STATE_INITIALIZED);
178      NRFX_ASSERT(p_config);
179      nrfx_err_t err_code = NRFX_SUCCESS;
180      if (pin_in_use(pin))
181      {
182          err_code = NRFX_ERROR_BUSY;
183      }
184      else
185      {
186          if (p_config->task_pin)
187          {
188              int8_t channel = channel_port_alloc(pin, NULL, true);
189              if (channel != NO_CHANNELS)
190              {
191                  nrf_gpiote_task_configure(NRF_GPIOTE,
192                                            (uint32_t)channel,
193                                            pin,
194                                            p_config->action,
195                                            p_config->init_state);
196              }
197              else
198              {
199                  err_code = NRFX_ERROR_NO_MEM;
200              }
201          }
202          else
203          {
204              pin_in_use_set(pin);
205          }
206          if (err_code == NRFX_SUCCESS)
207          {
208              if (p_config->init_state == NRF_GPIOTE_INITIAL_VALUE_HIGH)
209              {
210                  nrf_gpio_pin_set(pin);
211              }
212              else
213              {
214                  nrf_gpio_pin_clear(pin);
215              }
216              nrf_gpio_cfg_output(pin);
217              pin_configured_set(pin);
218          }
219      }
220      NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
221      return err_code;
222  }
223  void nrfx_gpiote_out_uninit(nrfx_gpiote_pin_t pin)
224  {
225      NRFX_ASSERT(pin < NUMBER_OF_PINS);
226      NRFX_ASSERT(pin_in_use(pin));
227      if (pin_in_use_by_te(pin))
228      {
229          channel_free((uint8_t)channel_port_get(pin));
230          nrf_gpiote_te_default(NRF_GPIOTE, (uint32_t)channel_port_get(pin));
231      }
232      pin_in_use_clear(pin);
233      if (pin_configured_check(pin))
234      {
235          nrf_gpio_cfg_default(pin);
236          pin_configured_clear(pin);
237      }
238  }
239  void nrfx_gpiote_out_set(nrfx_gpiote_pin_t pin)
240  {
241      NRFX_ASSERT(pin < NUMBER_OF_PINS);
242      NRFX_ASSERT(pin_in_use(pin));
243      NRFX_ASSERT(!pin_in_use_by_te(pin));
244      nrf_gpio_pin_set(pin);
245  }
246  void nrfx_gpiote_out_clear(nrfx_gpiote_pin_t pin)
247  {
248      NRFX_ASSERT(pin < NUMBER_OF_PINS);
249      NRFX_ASSERT(pin_in_use(pin));
250      NRFX_ASSERT(!pin_in_use_by_te(pin));
251      nrf_gpio_pin_clear(pin);
252  }
253  void nrfx_gpiote_out_toggle(nrfx_gpiote_pin_t pin)
254  {
255      NRFX_ASSERT(pin < NUMBER_OF_PINS);
256      NRFX_ASSERT(pin_in_use(pin));
257      NRFX_ASSERT(!pin_in_use_by_te(pin));
258      nrf_gpio_pin_toggle(pin);
259  }
260  void nrfx_gpiote_out_task_enable(nrfx_gpiote_pin_t pin)
261  {
262      NRFX_ASSERT(pin < NUMBER_OF_PINS);
263      NRFX_ASSERT(pin_in_use(pin));
264      NRFX_ASSERT(pin_in_use_by_te(pin));
265      nrf_gpiote_task_enable(NRF_GPIOTE, (uint32_t)m_cb.pin_assignments[pin]);
266  }
267  void nrfx_gpiote_out_task_disable(nrfx_gpiote_pin_t pin)
268  {
269      NRFX_ASSERT(pin < NUMBER_OF_PINS);
270      NRFX_ASSERT(pin_in_use(pin));
271      NRFX_ASSERT(pin_in_use_by_te(pin));
272      nrf_gpiote_task_disable(NRF_GPIOTE, (uint32_t)m_cb.pin_assignments[pin]);
273  }
274  nrf_gpiote_task_t nrfx_gpiote_out_task_get(nrfx_gpiote_pin_t pin)
275  {
276      NRFX_ASSERT(pin < NUMBER_OF_PINS);
277      NRFX_ASSERT(pin_in_use_by_te(pin));
278      return  nrf_gpiote_out_task_get((uint8_t)channel_port_get(pin));
279  }
280  uint32_t nrfx_gpiote_out_task_addr_get(nrfx_gpiote_pin_t pin)
281  {
282      nrf_gpiote_task_t task = nrfx_gpiote_out_task_get(pin);
283      return nrf_gpiote_task_address_get(NRF_GPIOTE, task);
284  }
285  #if defined(GPIOTE_FEATURE_SET_PRESENT)
286  nrf_gpiote_task_t nrfx_gpiote_set_task_get(nrfx_gpiote_pin_t pin)
287  {
288      NRFX_ASSERT(pin < NUMBER_OF_PINS);
289      NRFX_ASSERT(pin_in_use_by_te(pin));
290      return nrf_gpiote_set_task_get((uint8_t)channel_port_get(pin));
291  }
292  uint32_t nrfx_gpiote_set_task_addr_get(nrfx_gpiote_pin_t pin)
293  {
294      nrf_gpiote_task_t task = nrfx_gpiote_set_task_get(pin);
295      return nrf_gpiote_task_address_get(NRF_GPIOTE, task);
296  }
297  #endif 
298  #if defined(GPIOTE_FEATURE_CLR_PRESENT)
299  nrf_gpiote_task_t nrfx_gpiote_clr_task_get(nrfx_gpiote_pin_t pin)
300  {
301      NRFX_ASSERT(pin < NUMBER_OF_PINS);
302      NRFX_ASSERT(pin_in_use_by_te(pin));
303      return nrf_gpiote_clr_task_get((uint8_t)channel_port_get(pin));
304  }
305  uint32_t nrfx_gpiote_clr_task_addr_get(nrfx_gpiote_pin_t pin)
306  {
307      nrf_gpiote_task_t task = nrfx_gpiote_clr_task_get(pin);
308      return nrf_gpiote_task_address_get(NRF_GPIOTE, task);
309  }
310  #endif 
311  void nrfx_gpiote_out_task_force(nrfx_gpiote_pin_t pin, uint8_t state)
312  {
313      NRFX_ASSERT(pin < NUMBER_OF_PINS);
314      NRFX_ASSERT(pin_in_use(pin));
315      NRFX_ASSERT(pin_in_use_by_te(pin));
316      nrf_gpiote_outinit_t init_val =
317          state ? NRF_GPIOTE_INITIAL_VALUE_HIGH : NRF_GPIOTE_INITIAL_VALUE_LOW;
318      nrf_gpiote_task_force(NRF_GPIOTE, (uint32_t)m_cb.pin_assignments[pin], init_val);
319  }
320  void nrfx_gpiote_out_task_trigger(nrfx_gpiote_pin_t pin)
321  {
322      NRFX_ASSERT(pin < NUMBER_OF_PINS);
323      NRFX_ASSERT(pin_in_use(pin));
324      NRFX_ASSERT(pin_in_use_by_te(pin));
325      nrf_gpiote_task_t task = nrf_gpiote_out_task_get((uint8_t)channel_port_get(pin));
326      nrf_gpiote_task_trigger(NRF_GPIOTE, task);
327  }
328  #if defined(GPIOTE_FEATURE_SET_PRESENT)
329  void nrfx_gpiote_set_task_trigger(nrfx_gpiote_pin_t pin)
330  {
331      NRFX_ASSERT(pin < NUMBER_OF_PINS);
332      NRFX_ASSERT(pin_in_use(pin));
333      NRFX_ASSERT(pin_in_use_by_te(pin));
334      nrf_gpiote_task_t task = nrf_gpiote_set_task_get((uint8_t)channel_port_get(pin));
335      nrf_gpiote_task_trigger(NRF_GPIOTE, task);
336  }
337  #endif 
338  #if  defined(GPIOTE_FEATURE_CLR_PRESENT)
339  void nrfx_gpiote_clr_task_trigger(nrfx_gpiote_pin_t pin)
340  {
341      NRFX_ASSERT(pin < NUMBER_OF_PINS);
342      NRFX_ASSERT(pin_in_use(pin));
343      NRFX_ASSERT(pin_in_use_by_te(pin));
344      nrf_gpiote_task_t task = nrf_gpiote_clr_task_get((uint8_t)channel_port_get(pin));
345      nrf_gpiote_task_trigger(NRF_GPIOTE, task);
346  }
347  #endif 
348  nrfx_err_t nrfx_gpiote_in_init(nrfx_gpiote_pin_t               pin,
349                                 nrfx_gpiote_in_config_t const * p_config,
350                                 nrfx_gpiote_evt_handler_t       evt_handler)
351  {
352      NRFX_ASSERT(pin < NUMBER_OF_PINS);
353      NRFX_ASSERT(m_cb.state == NRFX_DRV_STATE_INITIALIZED);
354      NRFX_ASSERT(p_config);
355      nrfx_err_t err_code = NRFX_SUCCESS;
356      if (pin_in_use_by_gpiote(pin))
357      {
358          err_code = NRFX_ERROR_BUSY;
359      }
360      else
361      {
362          int8_t channel = channel_port_alloc(pin, evt_handler, p_config->hi_accuracy);
363          if (channel != NO_CHANNELS)
364          {
365              if (!p_config->skip_gpio_setup)
366              {
367                  if (p_config->is_watcher)
368                  {
369                      nrf_gpio_cfg_watcher(pin);
370                  }
371                  else
372                  {
373                      nrf_gpio_cfg_input(pin, p_config->pull);
374                  }
375                  pin_configured_set(pin);
376              }
377              if (p_config->hi_accuracy)
378              {
379                  nrf_gpiote_event_configure(NRF_GPIOTE, (uint32_t)channel, pin, p_config->sense);
380              }
381              else
382              {
383                  m_cb.port_handlers_pins[channel - GPIOTE_CH_NUM] |= (p_config->sense) <<
384                                                                      POLARITY_FIELD_POS;
385              }
386          }
387          else
388          {
389              err_code = NRFX_ERROR_NO_MEM;
390          }
391      }
392      NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
393      return err_code;
394  }
395  void nrfx_gpiote_in_event_enable(nrfx_gpiote_pin_t pin, bool int_enable)
396  {
397      NRFX_ASSERT(pin < NUMBER_OF_PINS);
398      NRFX_ASSERT(pin_in_use_by_gpiote(pin));
399      if (pin_in_use_by_port(pin))
400      {
401          nrf_gpiote_polarity_t polarity =
402              port_handler_polarity_get(channel_port_get(pin) - GPIOTE_CH_NUM);
403          nrf_gpio_pin_sense_t sense;
404          if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
405          {
406              sense = (nrf_gpio_pin_read(pin)) ?
407                      NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
408          }
409          else
410          {
411              sense = (polarity == NRF_GPIOTE_POLARITY_LOTOHI) ?
412                      NRF_GPIO_PIN_SENSE_HIGH : NRF_GPIO_PIN_SENSE_LOW;
413          }
414          nrf_gpio_cfg_sense_set(pin, sense);
415      }
416      else if (pin_in_use_by_te(pin))
417      {
418          int32_t            channel = (int32_t)channel_port_get(pin);
419          nrf_gpiote_event_t event   = nrf_gpiote_in_event_get((uint8_t)channel);
420          nrf_gpiote_event_enable(NRF_GPIOTE, (uint32_t)channel);
421          nrf_gpiote_event_clear(NRF_GPIOTE, event);
422          if (int_enable)
423          {
424              nrfx_gpiote_evt_handler_t handler = channel_handler_get((uint32_t)channel_port_get(pin));
425              if (handler)
426              {
427                  nrf_gpiote_int_enable(NRF_GPIOTE, 1 << channel);
428              }
429          }
430      }
431  }
432  void nrfx_gpiote_in_event_disable(nrfx_gpiote_pin_t pin)
433  {
434      NRFX_ASSERT(pin < NUMBER_OF_PINS);
435      NRFX_ASSERT(pin_in_use_by_gpiote(pin));
436      if (pin_in_use_by_port(pin))
437      {
438          nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
439      }
440      else if (pin_in_use_by_te(pin))
441      {
442          int32_t channel = (int32_t)channel_port_get(pin);
443          nrf_gpiote_event_disable(NRF_GPIOTE, (uint32_t)channel);
444          nrf_gpiote_int_disable(NRF_GPIOTE, 1 << channel);
445      }
446  }
447  void nrfx_gpiote_in_uninit(nrfx_gpiote_pin_t pin)
448  {
449      NRFX_ASSERT(pin < NUMBER_OF_PINS);
450      NRFX_ASSERT(pin_in_use_by_gpiote(pin));
451      nrfx_gpiote_in_event_disable(pin);
452      if (pin_in_use_by_te(pin))
453      {
454          nrf_gpiote_te_default(NRF_GPIOTE, (uint32_t)channel_port_get(pin));
455      }
456      if (pin_configured_check(pin))
457      {
458          nrf_gpio_cfg_default(pin);
459          pin_configured_clear(pin);
460      }
461      channel_free((uint8_t)channel_port_get(pin));
462      pin_in_use_clear(pin);
463  }
464  bool nrfx_gpiote_in_is_set(nrfx_gpiote_pin_t pin)
465  {
466      NRFX_ASSERT(pin < NUMBER_OF_PINS);
467      return nrf_gpio_pin_read(pin) ? true : false;
468  }
469  nrf_gpiote_event_t nrfx_gpiote_in_event_get(nrfx_gpiote_pin_t pin)
470  {
471      NRFX_ASSERT(pin < NUMBER_OF_PINS);
472      NRFX_ASSERT(pin_in_use_by_port(pin) || pin_in_use_by_te(pin));
473      if (pin_in_use_by_te(pin))
474      {
475          return nrf_gpiote_in_event_get((uint8_t)channel_port_get(pin));
476      }
477      return NRF_GPIOTE_EVENT_PORT;
478  }
479  uint32_t nrfx_gpiote_in_event_addr_get(nrfx_gpiote_pin_t pin)
480  {
481      nrf_gpiote_event_t event = nrfx_gpiote_in_event_get(pin);
482      return nrf_gpiote_event_address_get(NRF_GPIOTE, event);
483  }
484  #if defined(NRF_GPIO_LATCH_PRESENT)
485  static bool latch_pending_read_and_check(uint32_t * latch)
486  {
487      nrf_gpio_latches_read_and_clear(0, GPIO_COUNT, latch);
488      for (uint32_t port_idx = 0; port_idx < GPIO_COUNT; port_idx++)
489      {
490          if (latch[port_idx])
491          {
492              return true;
493          }
494      }
495      return false;
496  }
497  static void port_event_handle(uint32_t * latch)
498  {
499      do {
500          for (uint32_t i = 0; i < NRFX_GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS; i++)
501          {
502              if (m_cb.port_handlers_pins[i] == PIN_NOT_USED)
503              {
504                  continue;
505              }
506              nrfx_gpiote_pin_t pin = port_handler_pin_get(i);
507              if (nrf_bitmask_bit_is_set(pin, latch))
508              {
509                  nrf_gpiote_polarity_t polarity = port_handler_polarity_get(i);
510                  nrf_gpio_pin_sense_t sense     = nrf_gpio_pin_sense_get(pin);
511                  NRFX_LOG_DEBUG("PORT event for pin: %d, polarity: %d.", pin, polarity);
512                  nrf_gpio_pin_sense_t next_sense =
513                      (sense == NRF_GPIO_PIN_SENSE_HIGH) ? NRF_GPIO_PIN_SENSE_LOW :
514                                                           NRF_GPIO_PIN_SENSE_HIGH;
515                  nrf_gpio_cfg_sense_set(pin, next_sense);
516                  nrf_gpio_pin_latch_clear(pin);
517                  nrfx_gpiote_evt_handler_t handler =
518                      channel_handler_get((uint32_t)channel_port_get(pin));
519                  if (handler &&
520                      ((polarity == NRF_GPIOTE_POLARITY_TOGGLE) ||
521                       (sense == NRF_GPIO_PIN_SENSE_HIGH && polarity == NRF_GPIOTE_POLARITY_LOTOHI) ||
522                       (sense == NRF_GPIO_PIN_SENSE_LOW && polarity == NRF_GPIOTE_POLARITY_HITOLO)))
523                  {
524                      handler(pin, polarity);
525                  }
526              }
527          }
528      } while (latch_pending_read_and_check(latch));
529  }
530  #else
531  static bool input_read_and_check(uint32_t * input, uint32_t * pins_to_check)
532  {
533      bool process_inputs_again;
534      uint32_t new_input[GPIO_COUNT];
535      nrf_gpio_ports_read(0, GPIO_COUNT, new_input);
536      process_inputs_again = false;
537      for (uint32_t port_idx = 0; port_idx < GPIO_COUNT; port_idx++)
538      {
539          uint32_t input_diff = input[port_idx] ^ new_input[port_idx];
540          input[port_idx] = new_input[port_idx];
541          if (input_diff)
542          {
543              pins_to_check[port_idx] = input_diff;
<span onclick='openModal()' class='match'>544              process_inputs_again = true;
545          }
546          else
547          {
548              pins_to_check[port_idx] = 0;
549          }
550      }
551      return process_inputs_again;
552  }
</span>553  static void port_event_handle(uint32_t * input)
554  {
555      uint32_t pins_to_check[GPIO_COUNT];
556      for (uint32_t port_idx = 0; port_idx < GPIO_COUNT; port_idx++)
557      {
558          pins_to_check[port_idx] = 0xFFFFFFFF;
559      }
560      do {
561          for (uint32_t i = 0; i < NRFX_GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS; i++)
562          {
563              if (m_cb.port_handlers_pins[i] == PIN_NOT_USED)
564              {
565                  continue;
566              }
567              nrfx_gpiote_pin_t pin = port_handler_pin_get(i);
568              if (nrf_bitmask_bit_is_set(pin, pins_to_check))
569              {
570                  nrf_gpiote_polarity_t polarity = port_handler_polarity_get(i);
571                  nrf_gpio_pin_sense_t sense     = nrf_gpio_pin_sense_get(pin);
572                  bool pin_state                 = nrf_bitmask_bit_is_set(pin, input);
573                  if ((pin_state && (sense == NRF_GPIO_PIN_SENSE_HIGH)) ||
574                      (!pin_state && (sense == NRF_GPIO_PIN_SENSE_LOW)) )
575                  {
576                      NRFX_LOG_DEBUG("PORT event for pin: %d, polarity: %d.", pin, polarity);
577                      nrf_gpio_pin_sense_t next_sense =
578                          (sense == NRF_GPIO_PIN_SENSE_HIGH) ? NRF_GPIO_PIN_SENSE_LOW :
579                                                               NRF_GPIO_PIN_SENSE_HIGH;
580                      nrf_gpio_cfg_sense_set(pin, next_sense);
581                      nrfx_gpiote_evt_handler_t handler =
582                          channel_handler_get((uint32_t)channel_port_get(pin));
583                      if (handler &&
584                          ((polarity == NRF_GPIOTE_POLARITY_TOGGLE) ||
585                           (sense == NRF_GPIO_PIN_SENSE_HIGH &&
586                            polarity == NRF_GPIOTE_POLARITY_LOTOHI) ||
587                           (sense == NRF_GPIO_PIN_SENSE_LOW &&
588                            polarity == NRF_GPIOTE_POLARITY_HITOLO)))
589                      {
590                          handler(pin, polarity);
591                      }
592                  }
593              }
594          }
595      } while (input_read_and_check(input, pins_to_check));
596  }
597  #endif 
598  void nrfx_gpiote_irq_handler(void)
599  {
600      uint32_t status            = 0;
601      uint32_t input[GPIO_COUNT] = {0};
602      uint32_t            i;
603      nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
604      uint32_t            mask  = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
605      for (i = 0; i < GPIOTE_CH_NUM; i++)
606      {
607          if (nrf_gpiote_event_check(NRF_GPIOTE, event) &&
608              nrf_gpiote_int_enable_check(NRF_GPIOTE, mask))
609          {
610              nrf_gpiote_event_clear(NRF_GPIOTE, event);
611              status |= mask;
612          }
613          mask <<= 1;
614          event = (nrf_gpiote_event_t)((uint32_t)event + sizeof(uint32_t));
615      }
616      if (nrf_gpiote_event_check(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT))
617      {
618          nrf_gpiote_event_clear(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT);
619          status |= (uint32_t)NRF_GPIOTE_INT_PORT_MASK;
620  #if defined(NRF_GPIO_LATCH_PRESENT)
621          nrf_gpio_latches_read_and_clear(0, GPIO_COUNT, input);
622  #else
623          nrf_gpio_ports_read(0, GPIO_COUNT, input);
624  #endif
625      }
626      if (status & NRF_GPIOTE_INT_IN_MASK)
627      {
628          mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
629          for (i = 0; i < GPIOTE_CH_NUM; i++)
630          {
631              if (mask & status)
632              {
633                  nrfx_gpiote_pin_t pin = nrf_gpiote_event_pin_get(NRF_GPIOTE, i);
634                  NRFX_LOG_DEBUG("Event in number: %d.", i);
635                  nrf_gpiote_polarity_t polarity = nrf_gpiote_event_polarity_get(NRF_GPIOTE, i);
636                  nrfx_gpiote_evt_handler_t handler  = channel_handler_get(i);
637                  NRFX_LOG_DEBUG("Pin: %d, polarity: %d.", pin, polarity);
638                  if (handler)
639                  {
640                      handler(pin, polarity);
641                  }
642              }
643              mask <<= 1;
644          }
645      }
646      if (status & (uint32_t)NRF_GPIOTE_INT_PORT_MASK)
647      {
648          port_event_handle(input);
649      }
650  }
651  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-pubsub.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_gpiote.c</div>
                <div class="column column_space"><pre><code>25              clients = listCreate();
26              dictAdd(server.pubsub_channels,channel,clients);
27              incrRefCount(channel);
28          } else {
29              clients = dictGetVal(de);
30          }
31          listAddNodeTail(clients,c);
32      }
33      addReply(c,shared.mbulkhdr[3]);
34      addReply(c,shared.subscribebulk);
35      addReplyBulk(c,channel);
36      addReplyLongLong(c,clientSubscriptionsCount(c));
37      return retval;
38  }
</pre></code></div>
                <div class="column column_space"><pre><code>544              process_inputs_again = true;
545          }
546          else
547          {
548              pins_to_check[port_idx] = 0;
549          }
550      }
551      return process_inputs_again;
552  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    