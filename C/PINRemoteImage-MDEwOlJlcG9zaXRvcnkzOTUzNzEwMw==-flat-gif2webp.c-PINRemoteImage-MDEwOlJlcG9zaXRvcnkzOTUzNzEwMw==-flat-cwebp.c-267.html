
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-gif2webp.c</h3>
            <pre><code>1  #include &lt;assert.h&gt;
2  #include &lt;stdio.h&gt;
3  #include &lt;stdlib.h&gt;
4  #include &lt;string.h&gt;
5  #ifdef HAVE_CONFIG_H
6  #include &quot;webp/config.h&quot;
7  #endif
8  #ifdef WEBP_HAVE_GIF
9  #if defined(HAVE_UNISTD_H) &amp;&amp; HAVE_UNISTD_H
10  #include &lt;unistd.h&gt;
11  #endif
12  #include &lt;gif_lib.h&gt;
13  #include &quot;webp/encode.h&quot;
14  #include &quot;webp/mux.h&quot;
15  #include &quot;../examples/example_util.h&quot;
16  #include &quot;../imageio/imageio_util.h&quot;
17  #include &quot;./gifdec.h&quot;
18  #include &quot;./unicode.h&quot;
19  #include &quot;./unicode_gif.h&quot;
20  #if !defined(STDIN_FILENO)
21  #define STDIN_FILENO 0
22  #endif
23  static int transparent_index = GIF_INDEX_INVALID;  
24  static const char* const kErrorMessages[-WEBP_MUX_NOT_ENOUGH_DATA + 1] = {
25    &quot;WEBP_MUX_NOT_FOUND&quot;, &quot;WEBP_MUX_INVALID_ARGUMENT&quot;, &quot;WEBP_MUX_BAD_DATA&quot;,
26    &quot;WEBP_MUX_MEMORY_ERROR&quot;, &quot;WEBP_MUX_NOT_ENOUGH_DATA&quot;
27  };
28  static const char* ErrorString(WebPMuxError err) {
29    assert(err &lt;= WEBP_MUX_NOT_FOUND &amp;&amp; err &gt;= WEBP_MUX_NOT_ENOUGH_DATA);
30    return kErrorMessages[-err];
31  }
32  enum {
33    METADATA_ICC  = (1 &lt;&lt; 0),
34    METADATA_XMP  = (1 &lt;&lt; 1),
35    METADATA_ALL  = METADATA_ICC | METADATA_XMP
36  };
37  static void Help(void) {
38    printf(&quot;Usage:\n&quot;);
39    printf(&quot; gif2webp [options] gif_file -o webp_file\n&quot;);
40    printf(&quot;Options:\n&quot;);
41    printf(&quot;  -h / -help ............. this help\n&quot;);
42    printf(&quot;  -lossy ................. encode image using lossy compression\n&quot;);
43    printf(&quot;  -mixed ................. for each frame in the image, pick lossy\n&quot;
44           &quot;                           or lossless compression heuristically\n&quot;);
45    printf(&quot;  -q &lt;float&gt; ............. quality factor (0:small..100:big)\n&quot;);
46    printf(&quot;  -m &lt;int&gt; ............... compression method (0=fast, 6=slowest)\n&quot;);
47    printf(&quot;  -min_size .............. minimize output size (default:off)\n&quot;
48           &quot;                           lossless compression by default; can be\n&quot;
49           &quot;                           combined with -q, -m, -lossy or -mixed\n&quot;
50           &quot;                           options\n&quot;);
51    printf(&quot;  -kmin &lt;int&gt; ............ min distance between key frames\n&quot;);
52    printf(&quot;  -kmax &lt;int&gt; ............ max distance between key frames\n&quot;);
53    printf(&quot;  -f &lt;int&gt; ............... filter strength (0=off..100)\n&quot;);
54    printf(&quot;  -metadata &lt;string&gt; ..... comma separated list of metadata to\n&quot;);
55    printf(&quot;                           &quot;);
56    printf(&quot;copy from the input to the output if present\n&quot;);
57    printf(&quot;                           &quot;);
58    printf(&quot;Valid values: all, none, icc, xmp (default)\n&quot;);
59    printf(&quot;  -loop_compatibility .... use compatibility mode for Chrome\n&quot;);
60    printf(&quot;                           version prior to M62 (inclusive)\n&quot;);
61    printf(&quot;  -mt .................... use multi-threading if available\n&quot;);
62    printf(&quot;\n&quot;);
63    printf(&quot;  -version ............... print version number and exit\n&quot;);
64    printf(&quot;  -v ..................... verbose\n&quot;);
65    printf(&quot;  -quiet ................. don&#x27;t print anything\n&quot;);
66    printf(&quot;\n&quot;);
67  }
68  int main(int argc, const char* argv[]) {
69    int verbose = 0;
70    int gif_error = GIF_ERROR;
71    WebPMuxError err = WEBP_MUX_OK;
72    int ok = 0;
73    const W_CHAR* in_file = NULL, *out_file = NULL;
74    GifFileType* gif = NULL;
75    int frame_duration = 0;
76    int frame_timestamp = 0;
77    GIFDisposeMethod orig_dispose = GIF_DISPOSE_NONE;
78    WebPPicture frame;                
79    WebPPicture curr_canvas;          
80    WebPPicture prev_canvas;          
81    WebPAnimEncoder* enc = NULL;
82    WebPAnimEncoderOptions enc_options;
83    WebPConfig config;
84    int frame_number = 0;     
85    int done;
86    int c;
87    int quiet = 0;
88    WebPData webp_data;
89    int keep_metadata = METADATA_XMP;  
90    WebPData icc_data;
91    int stored_icc = 0;         
92    WebPData xmp_data;
93    int stored_xmp = 0;         
94    int loop_count = 0;         
95    int stored_loop_count = 0;  
96    int loop_compatibility = 0;
97    WebPMux* mux = NULL;
98    int default_kmin = 1;  
99    int default_kmax = 1;
100    INIT_WARGV(argc, argv);
101    if (!WebPConfigInit(&amp;config) || !WebPAnimEncoderOptionsInit(&amp;enc_options) ||
102        !WebPPictureInit(&amp;frame) || !WebPPictureInit(&amp;curr_canvas) ||
103        !WebPPictureInit(&amp;prev_canvas)) {
104      fprintf(stderr, &quot;Error! Version mismatch!\n&quot;);
105      FREE_WARGV_AND_RETURN(-1);
106    }
107    config.lossless = 1;  
108    WebPDataInit(&amp;webp_data);
109    WebPDataInit(&amp;icc_data);
110    WebPDataInit(&amp;xmp_data);
111    if (argc == 1) {
112      Help();
113      FREE_WARGV_AND_RETURN(0);
114    }
115    for (c = 1; c &lt; argc; ++c) {
116      int parse_error = 0;
117      if (!strcmp(argv[c], &quot;-h&quot;) || !strcmp(argv[c], &quot;-help&quot;)) {
118        Help();
119        FREE_WARGV_AND_RETURN(0);
120      } else if (!strcmp(argv[c], &quot;-o&quot;) &amp;&amp; c &lt; argc - 1) {
121        out_file = GET_WARGV(argv, ++c);
122      } else if (!strcmp(argv[c], &quot;-lossy&quot;)) {
123        config.lossless = 0;
124      } else if (!strcmp(argv[c], &quot;-mixed&quot;)) {
125        enc_options.allow_mixed = 1;
126        config.lossless = 0;
127      } else if (!strcmp(argv[c], &quot;-loop_compatibility&quot;)) {
128        loop_compatibility = 1;
129      } else if (!strcmp(argv[c], &quot;-q&quot;) &amp;&amp; c &lt; argc - 1) {
130        config.quality = ExUtilGetFloat(argv[++c], &amp;parse_error);
131      } else if (!strcmp(argv[c], &quot;-m&quot;) &amp;&amp; c &lt; argc - 1) {
132        config.method = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
133      } else if (!strcmp(argv[c], &quot;-min_size&quot;)) {
134        enc_options.minimize_size = 1;
135      } else if (!strcmp(argv[c], &quot;-kmax&quot;) &amp;&amp; c &lt; argc - 1) {
136        enc_options.kmax = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
137        default_kmax = 0;
138      } else if (!strcmp(argv[c], &quot;-kmin&quot;) &amp;&amp; c &lt; argc - 1) {
139        enc_options.kmin = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
140        default_kmin = 0;
141      } else if (!strcmp(argv[c], &quot;-f&quot;) &amp;&amp; c &lt; argc - 1) {
142        config.filter_strength = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
143      } else if (!strcmp(argv[c], &quot;-metadata&quot;) &amp;&amp; c &lt; argc - 1) {
144        static const struct {
145          const char* option;
146          int flag;
147        } kTokens[] = {
148          { &quot;all&quot;,  METADATA_ALL },
149          { &quot;none&quot;, 0 },
150          { &quot;icc&quot;,  METADATA_ICC },
151          { &quot;xmp&quot;,  METADATA_XMP },
152        };
153        const size_t kNumTokens = sizeof(kTokens) / sizeof(*kTokens);
154        const char* start = argv[++c];
155        const char* const end = start + strlen(start);
156        keep_metadata = 0;
157        while (start &lt; end) {
158          size_t i;
159          const char* token = strchr(start, &#x27;,&#x27;);
160          if (token == NULL) token = end;
161          for (i = 0; i &lt; kNumTokens; ++i) {
162            if ((size_t)(token - start) == strlen(kTokens[i].option) &amp;&amp;
163                !strncmp(start, kTokens[i].option, strlen(kTokens[i].option))) {
164              if (kTokens[i].flag != 0) {
165                keep_metadata |= kTokens[i].flag;
166              } else {
167                keep_metadata = 0;
168              }
169              break;
170            }
171          }
172          if (i == kNumTokens) {
173            fprintf(stderr, &quot;Error! Unknown metadata type &#x27;%.*s&#x27;\n&quot;,
174                    (int)(token - start), start);
175            Help();
176            FREE_WARGV_AND_RETURN(-1);
177          }
178          start = token + 1;
179        }
180      } else if (!strcmp(argv[c], &quot;-mt&quot;)) {
181        ++config.thread_level;
182      } else if (!strcmp(argv[c], &quot;-version&quot;)) {
183        const int enc_version = WebPGetEncoderVersion();
184        const int mux_version = WebPGetMuxVersion();
185        printf(&quot;WebP Encoder version: %d.%d.%d\nWebP Mux version: %d.%d.%d\n&quot;,
186               (enc_version &gt;&gt; 16) &amp; 0xff, (enc_version &gt;&gt; 8) &amp; 0xff,
187               enc_version &amp; 0xff, (mux_version &gt;&gt; 16) &amp; 0xff,
188               (mux_version &gt;&gt; 8) &amp; 0xff, mux_version &amp; 0xff);
189        FREE_WARGV_AND_RETURN(0);
190      } else if (!strcmp(argv[c], &quot;-quiet&quot;)) {
191        quiet = 1;
192        enc_options.verbose = 0;
193      } else if (!strcmp(argv[c], &quot;-v&quot;)) {
194        verbose = 1;
195        enc_options.verbose = 1;
196      } else if (!strcmp(argv[c], &quot;--&quot;)) {
197        if (c &lt; argc - 1) in_file = GET_WARGV(argv, ++c);
198        break;
199      } else if (argv[c][0] == &#x27;-&#x27;) {
200        fprintf(stderr, &quot;Error! Unknown option &#x27;%s&#x27;\n&quot;, argv[c]);
201        Help();
202        FREE_WARGV_AND_RETURN(-1);
203      } else {
204        in_file = GET_WARGV(argv, c);
205      }
206      if (parse_error) {
207        Help();
208        FREE_WARGV_AND_RETURN(-1);
209      }
210    }
211    if (default_kmin) {
212      enc_options.kmin = config.lossless ? 9 : 3;
213    }
214    if (default_kmax) {
215      enc_options.kmax = config.lossless ? 17 : 5;
216    }
217    if (!WebPValidateConfig(&amp;config)) {
218      fprintf(stderr, &quot;Error! Invalid configuration.\n&quot;);
219      goto End;
220    }
221    if (in_file == NULL) {
<span onclick='openModal()' class='match'>222      fprintf(stderr, &quot;No input file specified!\n&quot;);
223      Help();
224      goto End;
225    }
226    gif = DGifOpenFileUnicode(in_file, &amp;gif_error);
</span>227    if (gif == NULL) goto End;
228    done = 0;
229    do {
230      GifRecordType type;
231      if (DGifGetRecordType(gif, &amp;type) == GIF_ERROR) goto End;
232      switch (type) {
233        case IMAGE_DESC_RECORD_TYPE: {
234          GIFFrameRect gif_rect;
235          GifImageDesc* const image_desc = &amp;gif-&gt;Image;
236          if (!DGifGetImageDesc(gif)) goto End;
237          if (frame_number == 0) {
238            if (verbose) {
239              printf(&quot;Canvas screen: %d x %d\n&quot;, gif-&gt;SWidth, gif-&gt;SHeight);
240            }
241            if (gif-&gt;SWidth == 0 || gif-&gt;SHeight == 0) {
242              image_desc-&gt;Left = 0;
243              image_desc-&gt;Top = 0;
244              gif-&gt;SWidth = image_desc-&gt;Width;
245              gif-&gt;SHeight = image_desc-&gt;Height;
246              if (gif-&gt;SWidth &lt;= 0 || gif-&gt;SHeight &lt;= 0) {
247                goto End;
248              }
249              if (verbose) {
250                printf(&quot;Fixed canvas screen dimension to: %d x %d\n&quot;,
251                       gif-&gt;SWidth, gif-&gt;SHeight);
252              }
253            }
254            frame.width = gif-&gt;SWidth;
255            frame.height = gif-&gt;SHeight;
256            frame.use_argb = 1;
257            if (!WebPPictureAlloc(&amp;frame)) goto End;
258            GIFClearPic(&amp;frame, NULL);
259            WebPPictureCopy(&amp;frame, &amp;curr_canvas);
260            WebPPictureCopy(&amp;frame, &amp;prev_canvas);
261            GIFGetBackgroundColor(gif-&gt;SColorMap, gif-&gt;SBackGroundColor,
262                                  transparent_index,
263                                  &amp;enc_options.anim_params.bgcolor);
264            enc = WebPAnimEncoderNew(curr_canvas.width, curr_canvas.height,
265                                     &amp;enc_options);
266            if (enc == NULL) {
267              fprintf(stderr,
268                      &quot;Error! Could not create encoder object. Possibly due to &quot;
269                      &quot;a memory error.\n&quot;);
270              goto End;
271            }
272          }
273          if (image_desc-&gt;Width == 0 || image_desc-&gt;Height == 0) {
274            image_desc-&gt;Width = gif-&gt;SWidth;
275            image_desc-&gt;Height = gif-&gt;SHeight;
276          }
277          if (!GIFReadFrame(gif, transparent_index, &amp;gif_rect, &amp;frame)) {
278            goto End;
279          }
280          GIFBlendFrames(&amp;frame, &amp;gif_rect, &amp;curr_canvas);
281          if (!WebPAnimEncoderAdd(enc, &amp;curr_canvas, frame_timestamp, &amp;config)) {
282            fprintf(stderr, &quot;Error while adding frame #%d: %s\n&quot;, frame_number,
283                    WebPAnimEncoderGetError(enc));
284            goto End;
285          } else {
286            ++frame_number;
287          }
288          GIFDisposeFrame(orig_dispose, &amp;gif_rect, &amp;prev_canvas, &amp;curr_canvas);
289          GIFCopyPixels(&amp;curr_canvas, &amp;prev_canvas);
290          if (frame_duration &lt;= 10) {
291            frame_duration = 100;
292          }
293          frame_timestamp += frame_duration;
294          orig_dispose = GIF_DISPOSE_NONE;
295          frame_duration = 0;
296          transparent_index = GIF_INDEX_INVALID;
297          break;
298        }
299        case EXTENSION_RECORD_TYPE: {
300          int extension;
301          GifByteType* data = NULL;
302          if (DGifGetExtension(gif, &amp;extension, &amp;data) == GIF_ERROR) {
303            goto End;
304          }
305          if (data == NULL) continue;
306          switch (extension) {
307            case COMMENT_EXT_FUNC_CODE: {
308              break;  
309            }
310            case GRAPHICS_EXT_FUNC_CODE: {
311              if (!GIFReadGraphicsExtension(data, &amp;frame_duration, &amp;orig_dispose,
312                                            &amp;transparent_index)) {
313                goto End;
314              }
315              break;
316            }
317            case PLAINTEXT_EXT_FUNC_CODE: {
318              break;
319            }
320            case APPLICATION_EXT_FUNC_CODE: {
321              if (data[0] != 11) break;    
322              if (!memcmp(data + 1, &quot;NETSCAPE2.0&quot;, 11) ||
323                  !memcmp(data + 1, &quot;ANIMEXTS1.0&quot;, 11)) {
324                if (!GIFReadLoopCount(gif, &amp;data, &amp;loop_count)) {
325                  goto End;
326                }
327                if (verbose) {
328                  fprintf(stderr, &quot;Loop count: %d\n&quot;, loop_count);
329                }
330                stored_loop_count = loop_compatibility ? (loop_count != 0) : 1;
331              } else {  
332                const int is_xmp = (keep_metadata &amp; METADATA_XMP) &amp;&amp;
333                                   !stored_xmp &amp;&amp;
334                                   !memcmp(data + 1, &quot;XMP DataXMP&quot;, 11);
335                const int is_icc = (keep_metadata &amp; METADATA_ICC) &amp;&amp;
336                                   !stored_icc &amp;&amp;
337                                   !memcmp(data + 1, &quot;ICCRGBG1012&quot;, 11);
338                if (is_xmp || is_icc) {
339                  if (!GIFReadMetadata(gif, &amp;data,
340                                       is_xmp ? &amp;xmp_data : &amp;icc_data)) {
341                    goto End;
342                  }
343                  if (is_icc) {
344                    stored_icc = 1;
345                  } else if (is_xmp) {
346                    stored_xmp = 1;
347                  }
348                }
349              }
350              break;
351            }
352            default: {
353              break;  
354            }
355          }
356          while (data != NULL) {
357            if (DGifGetExtensionNext(gif, &amp;data) == GIF_ERROR) goto End;
358          }
359          break;
360        }
361        case TERMINATE_RECORD_TYPE: {
362          done = 1;
363          break;
364        }
365        default: {
366          if (verbose) {
367            fprintf(stderr, &quot;Skipping over unknown record type %d\n&quot;, type);
368          }
369          break;
370        }
371      }
372    } while (!done);
373    if (!WebPAnimEncoderAdd(enc, NULL, frame_timestamp, NULL)) {
374      fprintf(stderr, &quot;Error flushing WebP muxer.\n&quot;);
375      fprintf(stderr, &quot;%s\n&quot;, WebPAnimEncoderGetError(enc));
376    }
377    if (!WebPAnimEncoderAssemble(enc, &amp;webp_data)) {
378      fprintf(stderr, &quot;%s\n&quot;, WebPAnimEncoderGetError(enc));
379      goto End;
380    }
381    if (!loop_compatibility) {
382      if (!stored_loop_count) {
383        if (frame_number &gt; 1) {
384          stored_loop_count = 1;
385          loop_count = 1;
386        }
387      } else if (loop_count &gt; 0 &amp;&amp; loop_count &lt; 65535) {
388        loop_count += 1;
389      }
390    }
391    if (loop_count == 0) stored_loop_count = 0;
392    if (stored_loop_count || stored_icc || stored_xmp) {
393      mux = WebPMuxCreate(&amp;webp_data, 1);
394      if (mux == NULL) {
395        fprintf(stderr, &quot;ERROR: Could not re-mux to add loop count/metadata.\n&quot;);
396        goto End;
397      }
398      WebPDataClear(&amp;webp_data);
399      if (stored_loop_count) {  
400        WebPMuxAnimParams new_params;
401        err = WebPMuxGetAnimationParams(mux, &amp;new_params);
402        if (err != WEBP_MUX_OK) {
403          fprintf(stderr, &quot;ERROR (%s): Could not fetch loop count.\n&quot;,
404                  ErrorString(err));
405          goto End;
406        }
407        new_params.loop_count = loop_count;
408        err = WebPMuxSetAnimationParams(mux, &amp;new_params);
409        if (err != WEBP_MUX_OK) {
410          fprintf(stderr, &quot;ERROR (%s): Could not update loop count.\n&quot;,
411                  ErrorString(err));
412          goto End;
413        }
414      }
415      if (stored_icc) {   
416        err = WebPMuxSetChunk(mux, &quot;ICCP&quot;, &amp;icc_data, 1);
417        if (verbose) {
418          fprintf(stderr, &quot;ICC size: %d\n&quot;, (int)icc_data.size);
419        }
420        if (err != WEBP_MUX_OK) {
421          fprintf(stderr, &quot;ERROR (%s): Could not set ICC chunk.\n&quot;,
422                  ErrorString(err));
423          goto End;
424        }
425      }
426      if (stored_xmp) {   
427        err = WebPMuxSetChunk(mux, &quot;XMP &quot;, &amp;xmp_data, 1);
428        if (verbose) {
429          fprintf(stderr, &quot;XMP size: %d\n&quot;, (int)xmp_data.size);
430        }
431        if (err != WEBP_MUX_OK) {
432          fprintf(stderr, &quot;ERROR (%s): Could not set XMP chunk.\n&quot;,
433                  ErrorString(err));
434          goto End;
435        }
436      }
437      err = WebPMuxAssemble(mux, &amp;webp_data);
438      if (err != WEBP_MUX_OK) {
439        fprintf(stderr, &quot;ERROR (%s): Could not assemble when re-muxing to add &quot;
440                &quot;loop count/metadata.\n&quot;, ErrorString(err));
441        goto End;
442      }
443    }
444    if (out_file != NULL) {
445      if (!ImgIoUtilWriteFile((const char*)out_file, webp_data.bytes,
446                              webp_data.size)) {
447        WFPRINTF(stderr, &quot;Error writing output file: %s\n&quot;, out_file);
448        goto End;
449      }
450      if (!quiet) {
451        if (!WSTRCMP(out_file, &quot;-&quot;)) {
452          fprintf(stderr, &quot;Saved %d bytes to STDIO\n&quot;,
453                  (int)webp_data.size);
454        } else {
455          WFPRINTF(stderr, &quot;Saved output file (%d bytes): %s\n&quot;,
456                   (int)webp_data.size, out_file);
457        }
458      }
459    } else {
460      if (!quiet) {
461        fprintf(stderr, &quot;Nothing written; use -o flag to save the result &quot;
462                        &quot;(%d bytes).\n&quot;, (int)webp_data.size);
463      }
464    }
465    ok = 1;
466    gif_error = GIF_OK;
467   End:
468    WebPDataClear(&amp;icc_data);
469    WebPDataClear(&amp;xmp_data);
470    WebPMuxDelete(mux);
471    WebPDataClear(&amp;webp_data);
472    WebPPictureFree(&amp;frame);
473    WebPPictureFree(&amp;curr_canvas);
474    WebPPictureFree(&amp;prev_canvas);
475    WebPAnimEncoderDelete(enc);
476    if (gif_error != GIF_OK) {
477      GIFDisplayError(gif, gif_error);
478    }
479    if (gif != NULL) {
480  #if LOCAL_GIF_PREREQ(5,1)
481      DGifCloseFile(gif, &amp;gif_error);
482  #else
483      DGifCloseFile(gif);
484  #endif
485    }
486    FREE_WARGV_AND_RETURN(!ok);
487  }
488  #else  
489  int main(int argc, const char* argv[]) {
490    fprintf(stderr, &quot;GIF support not enabled in %s.\n&quot;, argv[0]);
491    (void)argc;
492    return 0;
493  }
494  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-cwebp.c</h3>
            <pre><code>1  #include &lt;stdio.h&gt;
2  #include &lt;stdlib.h&gt;
3  #include &lt;string.h&gt;
4  #ifdef HAVE_CONFIG_H
5  #include &quot;webp/config.h&quot;
6  #endif
7  #include &quot;../examples/example_util.h&quot;
8  #include &quot;../imageio/image_dec.h&quot;
9  #include &quot;../imageio/imageio_util.h&quot;
10  #include &quot;./stopwatch.h&quot;
11  #include &quot;./unicode.h&quot;
12  #include &quot;webp/encode.h&quot;
13  #ifndef WEBP_DLL
14  #ifdef __cplusplus
15  extern &quot;C&quot; {
16  #endif
17  extern void* VP8GetCPUInfo;   
18  #ifdef __cplusplus
19  }    
20  #endif
21  #endif  
22  static int verbose = 0;
23  static int ReadYUV(const uint8_t* const data, size_t data_size,
24                     WebPPicture* const pic) {
25    const int use_argb = pic-&gt;use_argb;
26    const int uv_width = (pic-&gt;width + 1) / 2;
27    const int uv_height = (pic-&gt;height + 1) / 2;
28    const int y_plane_size = pic-&gt;width * pic-&gt;height;
29    const int uv_plane_size = uv_width * uv_height;
30    const size_t expected_data_size = y_plane_size + 2 * uv_plane_size;
31    if (data_size != expected_data_size) {
32      fprintf(stderr,
33              &quot;input data doesn&#x27;t have the expected size (%d instead of %d)\n&quot;,
34              (int)data_size, (int)expected_data_size);
35      return 0;
36    }
37    pic-&gt;use_argb = 0;
38    if (!WebPPictureAlloc(pic)) return 0;
39    ImgIoUtilCopyPlane(data, pic-&gt;width, pic-&gt;y, pic-&gt;y_stride,
40                       pic-&gt;width, pic-&gt;height);
41    ImgIoUtilCopyPlane(data + y_plane_size, uv_width,
42                       pic-&gt;u, pic-&gt;uv_stride, uv_width, uv_height);
43    ImgIoUtilCopyPlane(data + y_plane_size + uv_plane_size, uv_width,
44                       pic-&gt;v, pic-&gt;uv_stride, uv_width, uv_height);
45    return use_argb ? WebPPictureYUVAToARGB(pic) : 1;
46  }
47  #ifdef HAVE_WINCODEC_H
48  static int ReadPicture(const char* const filename, WebPPicture* const pic,
49                         int keep_alpha, Metadata* const metadata) {
50    int ok = 0;
51    const uint8_t* data = NULL;
52    size_t data_size = 0;
53    if (pic-&gt;width != 0 &amp;&amp; pic-&gt;height != 0) {
54      ok = ImgIoUtilReadFile(filename, &amp;data, &amp;data_size);
55      ok = ok &amp;&amp; ReadYUV(data, data_size, pic);
56    } else {
57      ok = ReadPictureWithWIC(filename, pic, keep_alpha, metadata);
58      if (!ok) {
59        ok = ImgIoUtilReadFile(filename, &amp;data, &amp;data_size);
60        ok = ok &amp;&amp; ReadWebP(data, data_size, pic, keep_alpha, metadata);
61      }
62    }
63    if (!ok) {
64      WFPRINTF(stderr, &quot;Error! Could not process file %s\n&quot;,
65               (const W_CHAR*)filename);
66    }
67    free((void*)data);
68    return ok;
69  }
70  #else  
71  static int ReadPicture(const char* const filename, WebPPicture* const pic,
72                         int keep_alpha, Metadata* const metadata) {
73    const uint8_t* data = NULL;
74    size_t data_size = 0;
75    int ok = 0;
76    ok = ImgIoUtilReadFile(filename, &amp;data, &amp;data_size);
77    if (!ok) goto End;
78    if (pic-&gt;width == 0 || pic-&gt;height == 0) {
79      WebPImageReader reader = WebPGuessImageReader(data, data_size);
80      ok = reader(data, data_size, pic, keep_alpha, metadata);
81    } else {
82      ok = ReadYUV(data, data_size, pic);
83    }
84   End:
85    if (!ok) {
86      WFPRINTF(stderr, &quot;Error! Could not process file %s\n&quot;,
87               (const W_CHAR*)filename);
88    }
89    free((void*)data);
90    return ok;
91  }
92  #endif  
93  static void AllocExtraInfo(WebPPicture* const pic) {
94    const int mb_w = (pic-&gt;width + 15) / 16;
95    const int mb_h = (pic-&gt;height + 15) / 16;
96    pic-&gt;extra_info =
97        (uint8_t*)WebPMalloc(mb_w * mb_h * sizeof(*pic-&gt;extra_info));
98  }
99  static void PrintByteCount(const int bytes[4], int total_size,
100                             int* const totals) {
101    int s;
102    int total = 0;
103    for (s = 0; s &lt; 4; ++s) {
104      fprintf(stderr, &quot;| %7d &quot;, bytes[s]);
105      total += bytes[s];
106      if (totals) totals[s] += bytes[s];
107    }
108    fprintf(stderr, &quot;| %7d  (%.1f%%)\n&quot;, total, 100.f * total / total_size);
109  }
110  static void PrintPercents(const int counts[4]) {
111    int s;
112    const int total = counts[0] + counts[1] + counts[2] + counts[3];
113    for (s = 0; s &lt; 4; ++s) {
114      fprintf(stderr, &quot;|      %2d%%&quot;, (int)(100. * counts[s] / total + .5));
115    }
116    fprintf(stderr, &quot;| %7d\n&quot;, total);
117  }
118  static void PrintValues(const int values[4]) {
119    int s;
120    for (s = 0; s &lt; 4; ++s) {
121      fprintf(stderr, &quot;| %7d &quot;, values[s]);
122    }
123    fprintf(stderr, &quot;|\n&quot;);
124  }
125  static void PrintFullLosslessInfo(const WebPAuxStats* const stats,
126                                    const char* const description) {
127    fprintf(stderr, &quot;Lossless-%s compressed size: %d bytes\n&quot;,
128            description, stats-&gt;lossless_size);
129    fprintf(stderr, &quot;  * Header size: %d bytes, image data size: %d\n&quot;,
130            stats-&gt;lossless_hdr_size, stats-&gt;lossless_data_size);
131    if (stats-&gt;lossless_features) {
132      fprintf(stderr, &quot;  * Lossless features used:&quot;);
133      if (stats-&gt;lossless_features &amp; 1) fprintf(stderr, &quot; PREDICTION&quot;);
134      if (stats-&gt;lossless_features &amp; 2) fprintf(stderr, &quot; CROSS-COLOR-TRANSFORM&quot;);
135      if (stats-&gt;lossless_features &amp; 4) fprintf(stderr, &quot; SUBTRACT-GREEN&quot;);
136      if (stats-&gt;lossless_features &amp; 8) fprintf(stderr, &quot; PALETTE&quot;);
137      fprintf(stderr, &quot;\n&quot;);
138    }
139    fprintf(stderr, &quot;  * Precision Bits: histogram=%d transform=%d cache=%d\n&quot;,
140            stats-&gt;histogram_bits, stats-&gt;transform_bits, stats-&gt;cache_bits);
141    if (stats-&gt;palette_size &gt; 0) {
142      fprintf(stderr, &quot;  * Palette size:   %d\n&quot;, stats-&gt;palette_size);
143    }
144  }
145  static void PrintExtraInfoLossless(const WebPPicture* const pic,
146                                     int short_output,
147                                     const char* const file_name) {
148    const WebPAuxStats* const stats = pic-&gt;stats;
149    if (short_output) {
150      fprintf(stderr, &quot;%7d %2.2f\n&quot;, stats-&gt;coded_size, stats-&gt;PSNR[3]);
151    } else {
152      WFPRINTF(stderr, &quot;File:      %s\n&quot;, (const W_CHAR*)file_name);
153      fprintf(stderr, &quot;Dimension: %d x %d\n&quot;, pic-&gt;width, pic-&gt;height);
154      fprintf(stderr, &quot;Output:    %d bytes (%.2f bpp)\n&quot;, stats-&gt;coded_size,
155              8.f * stats-&gt;coded_size / pic-&gt;width / pic-&gt;height);
156      PrintFullLosslessInfo(stats, &quot;ARGB&quot;);
157    }
158  }
159  static void PrintExtraInfoLossy(const WebPPicture* const pic, int short_output,
160                                  int full_details,
161                                  const char* const file_name) {
162    const WebPAuxStats* const stats = pic-&gt;stats;
163    if (short_output) {
164      fprintf(stderr, &quot;%7d %2.2f\n&quot;, stats-&gt;coded_size, stats-&gt;PSNR[3]);
165    } else {
166      const int num_i4 = stats-&gt;block_count[0];
167      const int num_i16 = stats-&gt;block_count[1];
168      const int num_skip = stats-&gt;block_count[2];
169      const int total = num_i4 + num_i16;
170      WFPRINTF(stderr, &quot;File:      %s\n&quot;, (const W_CHAR*)file_name);
171      fprintf(stderr, &quot;Dimension: %d x %d%s\n&quot;,
172              pic-&gt;width, pic-&gt;height,
173              stats-&gt;alpha_data_size ? &quot; (with alpha)&quot; : &quot;&quot;);
174      fprintf(stderr, &quot;Output:    &quot;
175              &quot;%d bytes Y-U-V-All-PSNR %2.2f %2.2f %2.2f   %2.2f dB\n&quot;
176              &quot;           (%.2f bpp)\n&quot;,
177              stats-&gt;coded_size,
178              stats-&gt;PSNR[0], stats-&gt;PSNR[1], stats-&gt;PSNR[2], stats-&gt;PSNR[3],
179              8.f * stats-&gt;coded_size / pic-&gt;width / pic-&gt;height);
180      if (total &gt; 0) {
181        int totals[4] = { 0, 0, 0, 0 };
182        fprintf(stderr, &quot;block count:  intra4:     %6d  (%.2f%%)\n&quot;
183                        &quot;              intra16:    %6d  (%.2f%%)\n&quot;
184                        &quot;              skipped:    %6d  (%.2f%%)\n&quot;,
185                num_i4, 100.f * num_i4 / total,
186                num_i16, 100.f * num_i16 / total,
187                num_skip, 100.f * num_skip / total);
188        fprintf(stderr, &quot;bytes used:  header:         %6d  (%.1f%%)\n&quot;
189                        &quot;             mode-partition: %6d  (%.1f%%)\n&quot;,
190                stats-&gt;header_bytes[0],
191                100.f * stats-&gt;header_bytes[0] / stats-&gt;coded_size,
192                stats-&gt;header_bytes[1],
193                100.f * stats-&gt;header_bytes[1] / stats-&gt;coded_size);
194        if (stats-&gt;alpha_data_size &gt; 0) {
195          fprintf(stderr, &quot;             transparency:   %6d (%.1f dB)\n&quot;,
196                  stats-&gt;alpha_data_size, stats-&gt;PSNR[4]);
197        }
198        fprintf(stderr, &quot; Residuals bytes  &quot;
199                        &quot;|segment 1|segment 2|segment 3&quot;
200                        &quot;|segment 4|  total\n&quot;);
201        if (full_details) {
202          fprintf(stderr, &quot;  intra4-coeffs:  &quot;);
203          PrintByteCount(stats-&gt;residual_bytes[0], stats-&gt;coded_size, totals);
204          fprintf(stderr, &quot; intra16-coeffs:  &quot;);
205          PrintByteCount(stats-&gt;residual_bytes[1], stats-&gt;coded_size, totals);
206          fprintf(stderr, &quot;  chroma coeffs:  &quot;);
207          PrintByteCount(stats-&gt;residual_bytes[2], stats-&gt;coded_size, totals);
208        }
209        fprintf(stderr, &quot;    macroblocks:  &quot;);
210        PrintPercents(stats-&gt;segment_size);
211        fprintf(stderr, &quot;      quantizer:  &quot;);
212        PrintValues(stats-&gt;segment_quant);
213        fprintf(stderr, &quot;   filter level:  &quot;);
214        PrintValues(stats-&gt;segment_level);
215        if (full_details) {
216          fprintf(stderr, &quot;------------------+---------&quot;);
217          fprintf(stderr, &quot;+---------+---------+---------+-----------------\n&quot;);
218          fprintf(stderr, &quot; segments total:  &quot;);
219          PrintByteCount(totals, stats-&gt;coded_size, NULL);
220        }
221      }
222      if (stats-&gt;lossless_size &gt; 0) {
223        PrintFullLosslessInfo(stats, &quot;alpha&quot;);
224      }
225    }
226  }
227  static void PrintMapInfo(const WebPPicture* const pic) {
228    if (pic-&gt;extra_info != NULL) {
229      const int mb_w = (pic-&gt;width + 15) / 16;
230      const int mb_h = (pic-&gt;height + 15) / 16;
231      const int type = pic-&gt;extra_info_type;
232      int x, y;
233      for (y = 0; y &lt; mb_h; ++y) {
234        for (x = 0; x &lt; mb_w; ++x) {
235          const int c = pic-&gt;extra_info[x + y * mb_w];
236          if (type == 1) {   
237            fprintf(stderr, &quot;%c&quot;, &quot;+.&quot;[c]);
238          } else if (type == 2) {    
239            fprintf(stderr, &quot;%c&quot;, &quot;.-*X&quot;[c]);
240          } else if (type == 3) {    
241            fprintf(stderr, &quot;%.2d &quot;, c);
242          } else if (type == 6 || type == 7) {
243            fprintf(stderr, &quot;%3d &quot;, c);
244          } else {
245            fprintf(stderr, &quot;0x%.2x &quot;, c);
246          }
247        }
248        fprintf(stderr, &quot;\n&quot;);
249      }
250    }
251  }
252  static int MyWriter(const uint8_t* data, size_t data_size,
253                      const WebPPicture* const pic) {
254    FILE* const out = (FILE*)pic-&gt;custom_ptr;
255    return data_size ? (fwrite(data, data_size, 1, out) == 1) : 1;
256  }
257  static int DumpPicture(const WebPPicture* const picture, const char* PGM_name) {
258    int y;
259    const int uv_width = (picture-&gt;width + 1) / 2;
260    const int uv_height = (picture-&gt;height + 1) / 2;
261    const int stride = (picture-&gt;width + 1) &amp; ~1;
262    const uint8_t* src_y = picture-&gt;y;
263    const uint8_t* src_u = picture-&gt;u;
264    const uint8_t* src_v = picture-&gt;v;
265    const uint8_t* src_a = picture-&gt;a;
266    const int alpha_height =
267        WebPPictureHasTransparency(picture) ? picture-&gt;height : 0;
268    const int height = picture-&gt;height + uv_height + alpha_height;
269    FILE* const f = WFOPEN(PGM_name, &quot;wb&quot;);
270    if (f == NULL) return 0;
271    fprintf(f, &quot;P5\n%d %d\n255\n&quot;, stride, height);
272    for (y = 0; y &lt; picture-&gt;height; ++y) {
273      if (fwrite(src_y, picture-&gt;width, 1, f) != 1) return 0;
274      if (picture-&gt;width &amp; 1) fputc(0, f);  
275      src_y += picture-&gt;y_stride;
276    }
277    for (y = 0; y &lt; uv_height; ++y) {
278      if (fwrite(src_u, uv_width, 1, f) != 1) return 0;
279      if (fwrite(src_v, uv_width, 1, f) != 1) return 0;
280      src_u += picture-&gt;uv_stride;
281      src_v += picture-&gt;uv_stride;
282    }
283    for (y = 0; y &lt; alpha_height; ++y) {
284      if (fwrite(src_a, picture-&gt;width, 1, f) != 1) return 0;
285      if (picture-&gt;width &amp; 1) fputc(0, f);  
286      src_a += picture-&gt;a_stride;
287    }
288    fclose(f);
289    return 1;
290  }
291  enum {
292    METADATA_EXIF = (1 &lt;&lt; 0),
293    METADATA_ICC  = (1 &lt;&lt; 1),
294    METADATA_XMP  = (1 &lt;&lt; 2),
295    METADATA_ALL  = METADATA_EXIF | METADATA_ICC | METADATA_XMP
296  };
297  static const int kChunkHeaderSize = 8;
298  static const int kTagSize = 4;
299  static void PrintMetadataInfo(const Metadata* const metadata,
300                                int metadata_written) {
301    if (metadata == NULL || metadata_written == 0) return;
302    fprintf(stderr, &quot;Metadata:\n&quot;);
303    if (metadata_written &amp; METADATA_ICC) {
304      fprintf(stderr, &quot;  * ICC profile:  %6d bytes\n&quot;, (int)metadata-&gt;iccp.size);
305    }
306    if (metadata_written &amp; METADATA_EXIF) {
307      fprintf(stderr, &quot;  * EXIF data:    %6d bytes\n&quot;, (int)metadata-&gt;exif.size);
308    }
309    if (metadata_written &amp; METADATA_XMP) {
310      fprintf(stderr, &quot;  * XMP data:     %6d bytes\n&quot;, (int)metadata-&gt;xmp.size);
311    }
312  }
313  static int WriteLE(FILE* const out, uint32_t val, int num) {
314    uint8_t buf[4];
315    int i;
316    for (i = 0; i &lt; num; ++i) {
317      buf[i] = (uint8_t)(val &amp; 0xff);
318      val &gt;&gt;= 8;
319    }
320    return (fwrite(buf, num, 1, out) == 1);
321  }
322  static int WriteLE24(FILE* const out, uint32_t val) {
323    return WriteLE(out, val, 3);
324  }
325  static int WriteLE32(FILE* const out, uint32_t val) {
326    return WriteLE(out, val, 4);
327  }
328  static int WriteMetadataChunk(FILE* const out, const char fourcc[4],
329                                const MetadataPayload* const payload) {
330    const uint8_t zero = 0;
331    const size_t need_padding = payload-&gt;size &amp; 1;
332    int ok = (fwrite(fourcc, kTagSize, 1, out) == 1);
333    ok = ok &amp;&amp; WriteLE32(out, (uint32_t)payload-&gt;size);
334    ok = ok &amp;&amp; (fwrite(payload-&gt;bytes, payload-&gt;size, 1, out) == 1);
335    return ok &amp;&amp; (fwrite(&amp;zero, need_padding, need_padding, out) == need_padding);
336  }
337  static int UpdateFlagsAndSize(const MetadataPayload* const payload,
338                                int keep, int flag,
339                                uint32_t* vp8x_flags, uint64_t* metadata_size) {
340    if (keep &amp;&amp; payload-&gt;bytes != NULL &amp;&amp; payload-&gt;size &gt; 0) {
341      *vp8x_flags |= flag;
342      *metadata_size += kChunkHeaderSize + payload-&gt;size + (payload-&gt;size &amp; 1);
343      return 1;
344    }
345    return 0;
346  }
347  static int WriteWebPWithMetadata(FILE* const out,
348                                   const WebPPicture* const picture,
349                                   const WebPMemoryWriter* const memory_writer,
350                                   const Metadata* const metadata,
351                                   int keep_metadata,
352                                   int* const metadata_written) {
353    const char kVP8XHeader[] = &quot;VP8X\x0a\x00\x00\x00&quot;;
354    const int kAlphaFlag = 0x10;
355    const int kEXIFFlag  = 0x08;
356    const int kICCPFlag  = 0x20;
357    const int kXMPFlag   = 0x04;
358    const size_t kRiffHeaderSize = 12;
359    const size_t kMaxChunkPayload = ~0 - kChunkHeaderSize - 1;
360    const size_t kMinSize = kRiffHeaderSize + kChunkHeaderSize;
361    uint32_t flags = 0;
362    uint64_t metadata_size = 0;
363    const int write_exif = UpdateFlagsAndSize(&amp;metadata-&gt;exif,
364                                              !!(keep_metadata &amp; METADATA_EXIF),
365                                              kEXIFFlag, &amp;flags, &amp;metadata_size);
366    const int write_iccp = UpdateFlagsAndSize(&amp;metadata-&gt;iccp,
367                                              !!(keep_metadata &amp; METADATA_ICC),
368                                              kICCPFlag, &amp;flags, &amp;metadata_size);
369    const int write_xmp  = UpdateFlagsAndSize(&amp;metadata-&gt;xmp,
370                                              !!(keep_metadata &amp; METADATA_XMP),
371                                              kXMPFlag, &amp;flags, &amp;metadata_size);
372    uint8_t* webp = memory_writer-&gt;mem;
373    size_t webp_size = memory_writer-&gt;size;
374    *metadata_written = 0;
375    if (webp_size &lt; kMinSize) return 0;
376    if (webp_size - kChunkHeaderSize + metadata_size &gt; kMaxChunkPayload) {
377      fprintf(stderr, &quot;Error! Addition of metadata would exceed &quot;
378                      &quot;container size limit.\n&quot;);
379      return 0;
380    }
381    if (metadata_size &gt; 0) {
382      const int kVP8XChunkSize = 18;
383      const int has_vp8x = !memcmp(webp + kRiffHeaderSize, &quot;VP8X&quot;, kTagSize);
384      const uint32_t riff_size = (uint32_t)(webp_size - kChunkHeaderSize +
385                                            (has_vp8x ? 0 : kVP8XChunkSize) +
386                                            metadata_size);
387      int ok = (fwrite(webp, kTagSize, 1, out) == 1);
388      ok = ok &amp;&amp; WriteLE32(out, riff_size);
389      webp += kChunkHeaderSize;
390      webp_size -= kChunkHeaderSize;
391      ok = ok &amp;&amp; (fwrite(webp, kTagSize, 1, out) == 1);
392      webp += kTagSize;
393      webp_size -= kTagSize;
394      if (has_vp8x) {  
395        webp[kChunkHeaderSize] |= (uint8_t)(flags &amp; 0xff);
396        ok = ok &amp;&amp; (fwrite(webp, kVP8XChunkSize, 1, out) == 1);
397        webp += kVP8XChunkSize;
398        webp_size -= kVP8XChunkSize;
399      } else {
400        const int is_lossless = !memcmp(webp, &quot;VP8L&quot;, kTagSize);
401        if (is_lossless) {
402          if (webp[kChunkHeaderSize + 4] &amp; (1 &lt;&lt; 4)) flags |= kAlphaFlag;
403        }
404        ok = ok &amp;&amp; (fwrite(kVP8XHeader, kChunkHeaderSize, 1, out) == 1);
405        ok = ok &amp;&amp; WriteLE32(out, flags);
406        ok = ok &amp;&amp; WriteLE24(out, picture-&gt;width - 1);
407        ok = ok &amp;&amp; WriteLE24(out, picture-&gt;height - 1);
408      }
409      if (write_iccp) {
410        ok = ok &amp;&amp; WriteMetadataChunk(out, &quot;ICCP&quot;, &amp;metadata-&gt;iccp);
411        *metadata_written |= METADATA_ICC;
412      }
413      ok = ok &amp;&amp; (fwrite(webp, webp_size, 1, out) == 1);
414      if (write_exif) {
415        ok = ok &amp;&amp; WriteMetadataChunk(out, &quot;EXIF&quot;, &amp;metadata-&gt;exif);
416        *metadata_written |= METADATA_EXIF;
417      }
418      if (write_xmp) {
419        ok = ok &amp;&amp; WriteMetadataChunk(out, &quot;XMP &quot;, &amp;metadata-&gt;xmp);
420        *metadata_written |= METADATA_XMP;
421      }
422      return ok;
423    }
424    return (fwrite(webp, webp_size, 1, out) == 1);
425  }
426  static int ProgressReport(int percent, const WebPPicture* const picture) {
427    fprintf(stderr, &quot;[%s]: %3d %%      \r&quot;,
428            (char*)picture-&gt;user_data, percent);
429    return 1;  
430  }
431  static void HelpShort(void) {
432    printf(&quot;Usage:\n\n&quot;);
433    printf(&quot;   cwebp [options] -q quality input.png -o output.webp\n\n&quot;);
434    printf(&quot;where quality is between 0 (poor) to 100 (very good).\n&quot;);
435    printf(&quot;Typical value is around 80.\n\n&quot;);
436    printf(&quot;Try -longhelp for an exhaustive list of advanced options.\n&quot;);
437  }
438  static void HelpLong(void) {
439    printf(&quot;Usage:\n&quot;);
440    printf(&quot; cwebp [-preset &lt;...&gt;] [options] in_file [-o out_file]\n\n&quot;);
441    printf(&quot;If input size (-s) for an image is not specified, it is\n&quot;
442           &quot;assumed to be a PNG, JPEG, TIFF or WebP file.\n&quot;);
443  #ifdef HAVE_WINCODEC_H
444    printf(&quot;Windows builds can take as input any of the files handled by WIC.\n&quot;);
445  #endif
446    printf(&quot;\nOptions:\n&quot;);
447    printf(&quot;  -h / -help ............. short help\n&quot;);
448    printf(&quot;  -H / -longhelp ......... long help\n&quot;);
449    printf(&quot;  -q &lt;float&gt; ............. quality factor (0:small..100:big), &quot;
450           &quot;default=75\n&quot;);
451    printf(&quot;  -alpha_q &lt;int&gt; ......... transparency-compression quality (0..100),&quot;
452           &quot;\n                           default=100\n&quot;);
453    printf(&quot;  -preset &lt;string&gt; ....... preset setting, one of:\n&quot;);
454    printf(&quot;                            default, photo, picture,\n&quot;);
455    printf(&quot;                            drawing, icon, text\n&quot;);
456    printf(&quot;     -preset must come first, as it overwrites other parameters\n&quot;);
457    printf(&quot;  -z &lt;int&gt; ............... activates lossless preset with given\n&quot;
458           &quot;                           level in [0:fast, ..., 9:slowest]\n&quot;);
459    printf(&quot;\n&quot;);
460    printf(&quot;  -m &lt;int&gt; ............... compression method (0=fast, 6=slowest), &quot;
461           &quot;default=4\n&quot;);
462    printf(&quot;  -segments &lt;int&gt; ........ number of segments to use (1..4), &quot;
463           &quot;default=4\n&quot;);
464    printf(&quot;  -size &lt;int&gt; ............ target size (in bytes)\n&quot;);
465    printf(&quot;  -psnr &lt;float&gt; .......... target PSNR (in dB. typically: 42)\n&quot;);
466    printf(&quot;\n&quot;);
467    printf(&quot;  -s &lt;int&gt; &lt;int&gt; ......... input size (width x height) for YUV\n&quot;);
468    printf(&quot;  -sns &lt;int&gt; ............. spatial noise shaping (0:off, 100:max), &quot;
469           &quot;default=50\n&quot;);
470    printf(&quot;  -f &lt;int&gt; ............... filter strength (0=off..100), &quot;
471           &quot;default=60\n&quot;);
472    printf(&quot;  -sharpness &lt;int&gt; ....... &quot;
473           &quot;filter sharpness (0:most .. 7:least sharp), default=0\n&quot;);
474    printf(&quot;  -strong ................ use strong filter instead &quot;
475                                       &quot;of simple (default)\n&quot;);
476    printf(&quot;  -nostrong .............. use simple filter instead of strong\n&quot;);
477    printf(&quot;  -sharp_yuv ............. use sharper (and slower) RGB-&gt;YUV &quot;
478                                       &quot;conversion\n&quot;);
479    printf(&quot;  -partition_limit &lt;int&gt; . limit quality to fit the 512k limit on\n&quot;);
480    printf(&quot;                           &quot;
481           &quot;the first partition (0=no degradation ... 100=full)\n&quot;);
482    printf(&quot;  -pass &lt;int&gt; ............ analysis pass number (1..10)\n&quot;);
483    printf(&quot;  -crop &lt;x&gt; &lt;y&gt; &lt;w&gt; &lt;h&gt; .. crop picture with the given rectangle\n&quot;);
484    printf(&quot;  -resize &lt;w&gt; &lt;h&gt; ........ resize picture (after any cropping)\n&quot;);
485    printf(&quot;  -mt .................... use multi-threading if available\n&quot;);
486    printf(&quot;  -low_memory ............ reduce memory usage (slower encoding)\n&quot;);
487    printf(&quot;  -map &lt;int&gt; ............. print map of extra info\n&quot;);
488    printf(&quot;  -print_psnr ............ prints averaged PSNR distortion\n&quot;);
489    printf(&quot;  -print_ssim ............ prints averaged SSIM distortion\n&quot;);
490    printf(&quot;  -print_lsim ............ prints local-similarity distortion\n&quot;);
491    printf(&quot;  -d &lt;file.pgm&gt; .......... dump the compressed output (PGM file)\n&quot;);
492    printf(&quot;  -alpha_method &lt;int&gt; .... transparency-compression method (0..1), &quot;
493           &quot;default=1\n&quot;);
494    printf(&quot;  -alpha_filter &lt;string&gt; . predictive filtering for alpha plane,\n&quot;);
495    printf(&quot;                           one of: none, fast (default) or best\n&quot;);
496    printf(&quot;  -exact ................. preserve RGB values in transparent area, &quot;
497           &quot;default=off\n&quot;);
498    printf(&quot;  -blend_alpha &lt;hex&gt; ..... blend colors against background color\n&quot;
499           &quot;                           expressed as RGB values written in\n&quot;
500           &quot;                           hexadecimal, e.g. 0xc0e0d0 for red=0xc0\n&quot;
501           &quot;                           green=0xe0 and blue=0xd0\n&quot;);
502    printf(&quot;  -noalpha ............... discard any transparency information\n&quot;);
503    printf(&quot;  -lossless .............. encode image losslessly, default=off\n&quot;);
504    printf(&quot;  -near_lossless &lt;int&gt; ... use near-lossless image\n&quot;
505           &quot;                           preprocessing (0..100=off), &quot;
506           &quot;default=100\n&quot;);
507    printf(&quot;  -hint &lt;string&gt; ......... specify image characteristics hint,\n&quot;);
508    printf(&quot;                           one of: photo, picture or graph\n&quot;);
509    printf(&quot;\n&quot;);
510    printf(&quot;  -metadata &lt;string&gt; ..... comma separated list of metadata to\n&quot;);
511    printf(&quot;                           &quot;);
512    printf(&quot;copy from the input to the output if present.\n&quot;);
513    printf(&quot;                           &quot;
514           &quot;Valid values: all, none (default), exif, icc, xmp\n&quot;);
515    printf(&quot;\n&quot;);
516    printf(&quot;  -short ................. condense printed message\n&quot;);
517    printf(&quot;  -quiet ................. don&#x27;t print anything\n&quot;);
518    printf(&quot;  -version ............... print version number and exit\n&quot;);
519  #ifndef WEBP_DLL
520    printf(&quot;  -noasm ................. disable all assembly optimizations\n&quot;);
521  #endif
522    printf(&quot;  -v ..................... verbose, e.g. print encoding/decoding &quot;
523           &quot;times\n&quot;);
524    printf(&quot;  -progress .............. report encoding progress\n&quot;);
525    printf(&quot;\n&quot;);
526    printf(&quot;Experimental Options:\n&quot;);
527    printf(&quot;  -jpeg_like ............. roughly match expected JPEG size\n&quot;);
528    printf(&quot;  -af .................... auto-adjust filter strength\n&quot;);
529    printf(&quot;  -pre &lt;int&gt; ............. pre-processing filter\n&quot;);
530    printf(&quot;\n&quot;);
531  }
532  static const char* const kErrorMessages[VP8_ENC_ERROR_LAST] = {
533    &quot;OK&quot;,
534    &quot;OUT_OF_MEMORY: Out of memory allocating objects&quot;,
535    &quot;BITSTREAM_OUT_OF_MEMORY: Out of memory re-allocating byte buffer&quot;,
536    &quot;NULL_PARAMETER: NULL parameter passed to function&quot;,
537    &quot;INVALID_CONFIGURATION: configuration is invalid&quot;,
538    &quot;BAD_DIMENSION: Bad picture dimension. Maximum width and height &quot;
539    &quot;allowed is 16383 pixels.&quot;,
540    &quot;PARTITION0_OVERFLOW: Partition #0 is too big to fit 512k.\n&quot;
541    &quot;To reduce the size of this partition, try using less segments &quot;
542    &quot;with the -segments option, and eventually reduce the number of &quot;
543    &quot;header bits using -partition_limit. More details are available &quot;
544    &quot;in the manual (`man cwebp`)&quot;,
545    &quot;PARTITION_OVERFLOW: Partition is too big to fit 16M&quot;,
546    &quot;BAD_WRITE: Picture writer returned an I/O error&quot;,
547    &quot;FILE_TOO_BIG: File would be too big to fit in 4G&quot;,
548    &quot;USER_ABORT: encoding abort requested by user&quot;
549  };
550  int main(int argc, const char* argv[]) {
551    int return_value = -1;
552    const char* in_file = NULL, *out_file = NULL, *dump_file = NULL;
553    FILE* out = NULL;
554    int c;
555    int short_output = 0;
556    int quiet = 0;
557    int keep_alpha = 1;
558    int blend_alpha = 0;
559    uint32_t background_color = 0xffffffu;
560    int crop = 0, crop_x = 0, crop_y = 0, crop_w = 0, crop_h = 0;
561    int resize_w = 0, resize_h = 0;
562    int lossless_preset = 6;
563    int use_lossless_preset = -1;  
564    int show_progress = 0;
565    int keep_metadata = 0;
566    int metadata_written = 0;
567    WebPPicture picture;
568    int print_distortion = -1;        
569    WebPPicture original_picture;    
570    WebPConfig config;
571    WebPAuxStats stats;
572    WebPMemoryWriter memory_writer;
573    Metadata metadata;
574    Stopwatch stop_watch;
575    INIT_WARGV(argc, argv);
576    MetadataInit(&amp;metadata);
577    WebPMemoryWriterInit(&amp;memory_writer);
578    if (!WebPPictureInit(&amp;picture) ||
579        !WebPPictureInit(&amp;original_picture) ||
580        !WebPConfigInit(&amp;config)) {
581      fprintf(stderr, &quot;Error! Version mismatch!\n&quot;);
582      FREE_WARGV_AND_RETURN(-1);
583    }
584    if (argc == 1) {
585      HelpShort();
586      FREE_WARGV_AND_RETURN(0);
587    }
588    for (c = 1; c &lt; argc; ++c) {
589      int parse_error = 0;
590      if (!strcmp(argv[c], &quot;-h&quot;) || !strcmp(argv[c], &quot;-help&quot;)) {
591        HelpShort();
592        FREE_WARGV_AND_RETURN(0);
593      } else if (!strcmp(argv[c], &quot;-H&quot;) || !strcmp(argv[c], &quot;-longhelp&quot;)) {
594        HelpLong();
595        FREE_WARGV_AND_RETURN(0);
596      } else if (!strcmp(argv[c], &quot;-o&quot;) &amp;&amp; c &lt; argc - 1) {
597        out_file = (const char*)GET_WARGV(argv, ++c);
598      } else if (!strcmp(argv[c], &quot;-d&quot;) &amp;&amp; c &lt; argc - 1) {
599        dump_file = (const char*)GET_WARGV(argv, ++c);
600        config.show_compressed = 1;
601      } else if (!strcmp(argv[c], &quot;-print_psnr&quot;)) {
602        config.show_compressed = 1;
603        print_distortion = 0;
604      } else if (!strcmp(argv[c], &quot;-print_ssim&quot;)) {
605        config.show_compressed = 1;
606        print_distortion = 1;
607      } else if (!strcmp(argv[c], &quot;-print_lsim&quot;)) {
608        config.show_compressed = 1;
609        print_distortion = 2;
610      } else if (!strcmp(argv[c], &quot;-short&quot;)) {
611        ++short_output;
612      } else if (!strcmp(argv[c], &quot;-s&quot;) &amp;&amp; c &lt; argc - 2) {
613        picture.width = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
614        picture.height = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
615        if (picture.width &gt; WEBP_MAX_DIMENSION || picture.width &lt; 0 ||
616            picture.height &gt; WEBP_MAX_DIMENSION ||  picture.height &lt; 0) {
617          fprintf(stderr,
618                  &quot;Specified dimension (%d x %d) is out of range.\n&quot;,
619                  picture.width, picture.height);
620          goto Error;
621        }
622      } else if (!strcmp(argv[c], &quot;-m&quot;) &amp;&amp; c &lt; argc - 1) {
623        config.method = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
624        use_lossless_preset = 0;   
625      } else if (!strcmp(argv[c], &quot;-q&quot;) &amp;&amp; c &lt; argc - 1) {
626        config.quality = ExUtilGetFloat(argv[++c], &amp;parse_error);
627        use_lossless_preset = 0;   
628      } else if (!strcmp(argv[c], &quot;-z&quot;) &amp;&amp; c &lt; argc - 1) {
629        lossless_preset = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
630        if (use_lossless_preset != 0) use_lossless_preset = 1;
631      } else if (!strcmp(argv[c], &quot;-alpha_q&quot;) &amp;&amp; c &lt; argc - 1) {
632        config.alpha_quality = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
633      } else if (!strcmp(argv[c], &quot;-alpha_method&quot;) &amp;&amp; c &lt; argc - 1) {
634        config.alpha_compression = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
635      } else if (!strcmp(argv[c], &quot;-alpha_cleanup&quot;)) {
636        config.exact = 0;
637      } else if (!strcmp(argv[c], &quot;-exact&quot;)) {
638        config.exact = 1;
639      } else if (!strcmp(argv[c], &quot;-blend_alpha&quot;) &amp;&amp; c &lt; argc - 1) {
640        blend_alpha = 1;
641        background_color = ExUtilGetInt(argv[++c], 16, &amp;parse_error);
642        background_color = background_color &amp; 0x00ffffffu;
643      } else if (!strcmp(argv[c], &quot;-alpha_filter&quot;) &amp;&amp; c &lt; argc - 1) {
644        ++c;
645        if (!strcmp(argv[c], &quot;none&quot;)) {
646          config.alpha_filtering = 0;
647        } else if (!strcmp(argv[c], &quot;fast&quot;)) {
648          config.alpha_filtering = 1;
649        } else if (!strcmp(argv[c], &quot;best&quot;)) {
650          config.alpha_filtering = 2;
651        } else {
652          fprintf(stderr, &quot;Error! Unrecognized alpha filter: %s\n&quot;, argv[c]);
653          goto Error;
654        }
655      } else if (!strcmp(argv[c], &quot;-noalpha&quot;)) {
656        keep_alpha = 0;
657      } else if (!strcmp(argv[c], &quot;-lossless&quot;)) {
658        config.lossless = 1;
659      } else if (!strcmp(argv[c], &quot;-near_lossless&quot;) &amp;&amp; c &lt; argc - 1) {
660        config.near_lossless = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
661        config.lossless = 1;  
662      } else if (!strcmp(argv[c], &quot;-hint&quot;) &amp;&amp; c &lt; argc - 1) {
663        ++c;
664        if (!strcmp(argv[c], &quot;photo&quot;)) {
665          config.image_hint = WEBP_HINT_PHOTO;
666        } else if (!strcmp(argv[c], &quot;picture&quot;)) {
667          config.image_hint = WEBP_HINT_PICTURE;
668        } else if (!strcmp(argv[c], &quot;graph&quot;)) {
669          config.image_hint = WEBP_HINT_GRAPH;
670        } else {
671          fprintf(stderr, &quot;Error! Unrecognized image hint: %s\n&quot;, argv[c]);
672          goto Error;
673        }
674      } else if (!strcmp(argv[c], &quot;-size&quot;) &amp;&amp; c &lt; argc - 1) {
675        config.target_size = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
676      } else if (!strcmp(argv[c], &quot;-psnr&quot;) &amp;&amp; c &lt; argc - 1) {
677        config.target_PSNR = ExUtilGetFloat(argv[++c], &amp;parse_error);
678      } else if (!strcmp(argv[c], &quot;-sns&quot;) &amp;&amp; c &lt; argc - 1) {
679        config.sns_strength = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
680      } else if (!strcmp(argv[c], &quot;-f&quot;) &amp;&amp; c &lt; argc - 1) {
681        config.filter_strength = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
682      } else if (!strcmp(argv[c], &quot;-af&quot;)) {
683        config.autofilter = 1;
684      } else if (!strcmp(argv[c], &quot;-jpeg_like&quot;)) {
685        config.emulate_jpeg_size = 1;
686      } else if (!strcmp(argv[c], &quot;-mt&quot;)) {
687        ++config.thread_level;  
688      } else if (!strcmp(argv[c], &quot;-low_memory&quot;)) {
689        config.low_memory = 1;
690      } else if (!strcmp(argv[c], &quot;-strong&quot;)) {
691        config.filter_type = 1;
692      } else if (!strcmp(argv[c], &quot;-nostrong&quot;)) {
693        config.filter_type = 0;
694      } else if (!strcmp(argv[c], &quot;-sharpness&quot;) &amp;&amp; c &lt; argc - 1) {
695        config.filter_sharpness = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
696      } else if (!strcmp(argv[c], &quot;-sharp_yuv&quot;)) {
697        config.use_sharp_yuv = 1;
698      } else if (!strcmp(argv[c], &quot;-pass&quot;) &amp;&amp; c &lt; argc - 1) {
699        config.pass = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
700      } else if (!strcmp(argv[c], &quot;-pre&quot;) &amp;&amp; c &lt; argc - 1) {
701        config.preprocessing = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
702      } else if (!strcmp(argv[c], &quot;-segments&quot;) &amp;&amp; c &lt; argc - 1) {
703        config.segments = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
704      } else if (!strcmp(argv[c], &quot;-partition_limit&quot;) &amp;&amp; c &lt; argc - 1) {
705        config.partition_limit = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
706      } else if (!strcmp(argv[c], &quot;-map&quot;) &amp;&amp; c &lt; argc - 1) {
707        picture.extra_info_type = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
708      } else if (!strcmp(argv[c], &quot;-crop&quot;) &amp;&amp; c &lt; argc - 4) {
709        crop = 1;
710        crop_x = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
711        crop_y = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
712        crop_w = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
713        crop_h = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
714      } else if (!strcmp(argv[c], &quot;-resize&quot;) &amp;&amp; c &lt; argc - 2) {
715        resize_w = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
716        resize_h = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
717  #ifndef WEBP_DLL
718      } else if (!strcmp(argv[c], &quot;-noasm&quot;)) {
719        VP8GetCPUInfo = NULL;
720  #endif
721      } else if (!strcmp(argv[c], &quot;-version&quot;)) {
722        const int version = WebPGetEncoderVersion();
723        printf(&quot;%d.%d.%d\n&quot;,
724               (version &gt;&gt; 16) &amp; 0xff, (version &gt;&gt; 8) &amp; 0xff, version &amp; 0xff);
725        FREE_WARGV_AND_RETURN(0);
726      } else if (!strcmp(argv[c], &quot;-progress&quot;)) {
727        show_progress = 1;
728      } else if (!strcmp(argv[c], &quot;-quiet&quot;)) {
729        quiet = 1;
730      } else if (!strcmp(argv[c], &quot;-preset&quot;) &amp;&amp; c &lt; argc - 1) {
731        WebPPreset preset;
732        ++c;
733        if (!strcmp(argv[c], &quot;default&quot;)) {
734          preset = WEBP_PRESET_DEFAULT;
735        } else if (!strcmp(argv[c], &quot;photo&quot;)) {
736          preset = WEBP_PRESET_PHOTO;
737        } else if (!strcmp(argv[c], &quot;picture&quot;)) {
738          preset = WEBP_PRESET_PICTURE;
739        } else if (!strcmp(argv[c], &quot;drawing&quot;)) {
740          preset = WEBP_PRESET_DRAWING;
741        } else if (!strcmp(argv[c], &quot;icon&quot;)) {
742          preset = WEBP_PRESET_ICON;
743        } else if (!strcmp(argv[c], &quot;text&quot;)) {
744          preset = WEBP_PRESET_TEXT;
745        } else {
746          fprintf(stderr, &quot;Error! Unrecognized preset: %s\n&quot;, argv[c]);
747          goto Error;
748        }
749        if (!WebPConfigPreset(&amp;config, preset, config.quality)) {
750          fprintf(stderr, &quot;Error! Could initialize configuration with preset.\n&quot;);
751          goto Error;
752        }
753      } else if (!strcmp(argv[c], &quot;-metadata&quot;) &amp;&amp; c &lt; argc - 1) {
754        static const struct {
755          const char* option;
756          int flag;
757        } kTokens[] = {
758          { &quot;all&quot;,  METADATA_ALL },
759          { &quot;none&quot;, 0 },
760          { &quot;exif&quot;, METADATA_EXIF },
761          { &quot;icc&quot;,  METADATA_ICC },
762          { &quot;xmp&quot;,  METADATA_XMP },
763        };
764        const size_t kNumTokens = sizeof(kTokens) / sizeof(kTokens[0]);
765        const char* start = argv[++c];
766        const char* const end = start + strlen(start);
767        while (start &lt; end) {
768          size_t i;
769          const char* token = strchr(start, &#x27;,&#x27;);
770          if (token == NULL) token = end;
771          for (i = 0; i &lt; kNumTokens; ++i) {
772            if ((size_t)(token - start) == strlen(kTokens[i].option) &amp;&amp;
773                !strncmp(start, kTokens[i].option, strlen(kTokens[i].option))) {
774              if (kTokens[i].flag != 0) {
775                keep_metadata |= kTokens[i].flag;
776              } else {
777                keep_metadata = 0;
778              }
779              break;
780            }
781          }
782          if (i == kNumTokens) {
783            fprintf(stderr, &quot;Error! Unknown metadata type &#x27;%.*s&#x27;\n&quot;,
784                    (int)(token - start), start);
785            FREE_WARGV_AND_RETURN(-1);
786          }
787          start = token + 1;
788        }
789  #ifdef HAVE_WINCODEC_H
790        if (keep_metadata != 0 &amp;&amp; keep_metadata != METADATA_ICC) {
791          fprintf(stderr, &quot;Warning: only ICC profile extraction is currently&quot;
792                          &quot; supported on this platform!\n&quot;);
793        }
794  #endif
795      } else if (!strcmp(argv[c], &quot;-v&quot;)) {
796        verbose = 1;
797      } else if (!strcmp(argv[c], &quot;--&quot;)) {
798        if (c &lt; argc - 1) in_file = (const char*)GET_WARGV(argv, ++c);
799        break;
800      } else if (argv[c][0] == &#x27;-&#x27;) {
801        fprintf(stderr, &quot;Error! Unknown option &#x27;%s&#x27;\n&quot;, argv[c]);
802        HelpLong();
803        FREE_WARGV_AND_RETURN(-1);
804      } else {
805        in_file = (const char*)GET_WARGV(argv, c);
806      }
807      if (parse_error) {
808        HelpLong();
809        FREE_WARGV_AND_RETURN(-1);
810      }
811    }
812    if (in_file == NULL) {
<span onclick='openModal()' class='match'>813      fprintf(stderr, &quot;No input file specified!\n&quot;);
814      HelpShort();
815      goto Error;
816    }
817    if (use_lossless_preset == 1) {
</span>818      if (!WebPConfigLosslessPreset(&amp;config, lossless_preset)) {
819        fprintf(stderr, &quot;Invalid lossless preset (-z %d)\n&quot;, lossless_preset);
820        goto Error;
821      }
822    }
823    if (!quiet &amp;&amp; config.lossless == 1) {
824      if (config.target_size &gt; 0 || config.target_PSNR &gt; 0) {
825        fprintf(stderr, &quot;Encoding for specified size or PSNR is not supported&quot;
826                        &quot; for lossless encoding. Ignoring such option(s)!\n&quot;);
827      }
828      if (config.partition_limit &gt; 0) {
829        fprintf(stderr, &quot;Partition limit option is not required for lossless&quot;
830                        &quot; encoding. Ignoring this option!\n&quot;);
831      }
832    }
833    if (config.target_size &gt; 0 || config.target_PSNR &gt; 0) {
834      if (config.pass == 1) config.pass = 6;
835    }
836    if (!WebPValidateConfig(&amp;config)) {
837      fprintf(stderr, &quot;Error! Invalid configuration.\n&quot;);
838      goto Error;
839    }
840    picture.use_argb = (config.lossless || config.use_sharp_yuv ||
841                        config.preprocessing &gt; 0 ||
842                        crop || (resize_w | resize_h) &gt; 0);
843    if (verbose) {
844      StopwatchReset(&amp;stop_watch);
845    }
846    if (!ReadPicture(in_file, &amp;picture, keep_alpha,
847                     (keep_metadata == 0) ? NULL : &amp;metadata)) {
848      WFPRINTF(stderr, &quot;Error! Cannot read input picture file &#x27;%s&#x27;\n&quot;,
849               (const W_CHAR*)in_file);
850      goto Error;
851    }
852    picture.progress_hook = (show_progress &amp;&amp; !quiet) ? ProgressReport : NULL;
853    if (blend_alpha) {
854      WebPBlendAlpha(&amp;picture, background_color);
855    }
856    if (verbose) {
857      const double read_time = StopwatchReadAndReset(&amp;stop_watch);
858      fprintf(stderr, &quot;Time to read input: %.3fs\n&quot;, read_time);
859    }
860    if (out_file != NULL) {
861      const int use_stdout = !WSTRCMP(out_file, &quot;-&quot;);
862      out = use_stdout ? ImgIoUtilSetBinaryMode(stdout) : WFOPEN(out_file, &quot;wb&quot;);
863      if (out == NULL) {
864        WFPRINTF(stderr, &quot;Error! Cannot open output file &#x27;%s&#x27;\n&quot;,
865                 (const W_CHAR*)out_file);
866        goto Error;
867      } else {
868        if (!short_output &amp;&amp; !quiet) {
869          WFPRINTF(stderr, &quot;Saving file &#x27;%s&#x27;\n&quot;, (const W_CHAR*)out_file);
870        }
871      }
872      if (keep_metadata == 0) {
873        picture.writer = MyWriter;
874        picture.custom_ptr = (void*)out;
875      } else {
876        picture.writer = WebPMemoryWrite;
877        picture.custom_ptr = (void*)&amp;memory_writer;
878      }
879    } else {
880      out = NULL;
881      if (!quiet &amp;&amp; !short_output) {
882        fprintf(stderr, &quot;No output file specified (no -o flag). Encoding will\n&quot;);
883        fprintf(stderr, &quot;be performed, but its results discarded.\n\n&quot;);
884      }
885    }
886    if (!quiet) {
887      picture.stats = &amp;stats;
888      picture.user_data = (void*)in_file;
889    }
890    if (verbose) {
891      StopwatchReset(&amp;stop_watch);
892    }
893    if (crop != 0) {
894      if (!WebPPictureView(&amp;picture, crop_x, crop_y, crop_w, crop_h, &amp;picture)) {
895        fprintf(stderr, &quot;Error! Cannot crop picture\n&quot;);
896        goto Error;
897      }
898    }
899    if ((resize_w | resize_h) &gt; 0) {
900      WebPPicture picture_no_alpha;
901      if (config.exact) {
902        if (!WebPPictureCopy(&amp;picture, &amp;picture_no_alpha)) {
903          fprintf(stderr, &quot;Error! Cannot copy temporary picture\n&quot;);
904          goto Error;
905        }
906        {
907          int x, y;
908          uint32_t* argb_no_alpha = picture_no_alpha.argb;
909          for (y = 0; y &lt; picture_no_alpha.height; ++y) {
910            for (x = 0; x &lt; picture_no_alpha.width; ++x) {
911              argb_no_alpha[x] |= 0xff000000;  
912            }
913            argb_no_alpha += picture_no_alpha.argb_stride;
914          }
915        }
916        if (!WebPPictureRescale(&amp;picture_no_alpha, resize_w, resize_h)) {
917          fprintf(stderr, &quot;Error! Cannot resize temporary picture\n&quot;);
918          goto Error;
919        }
920      }
921      if (!WebPPictureRescale(&amp;picture, resize_w, resize_h)) {
922        fprintf(stderr, &quot;Error! Cannot resize picture\n&quot;);
923        goto Error;
924      }
925      if (config.exact) {  
926        int x, y;
927        uint32_t* argb_no_alpha = picture_no_alpha.argb;
928        uint32_t* argb = picture.argb;
929        for (y = 0; y &lt; picture_no_alpha.height; ++y) {
930          for (x = 0; x &lt; picture_no_alpha.width; ++x) {
931            argb[x] = (argb[x] &amp; 0xff000000) | (argb_no_alpha[x] &amp; 0x00ffffff);
932          }
933          argb_no_alpha += picture_no_alpha.argb_stride;
934          argb += picture.argb_stride;
935        }
936        WebPPictureFree(&amp;picture_no_alpha);
937      }
938    }
939    if (verbose &amp;&amp; (crop != 0 || (resize_w | resize_h) &gt; 0)) {
940      const double preproc_time = StopwatchReadAndReset(&amp;stop_watch);
941      fprintf(stderr, &quot;Time to crop/resize picture: %.3fs\n&quot;, preproc_time);
942    }
943    if (picture.extra_info_type &gt; 0) {
944      AllocExtraInfo(&amp;picture);
945    }
946    if (print_distortion &gt;= 0) {  
947      WebPPictureCopy(&amp;picture, &amp;original_picture);
948    }
949    if (verbose) {
950      StopwatchReset(&amp;stop_watch);
951    }
952    if (!WebPEncode(&amp;config, &amp;picture)) {
953      fprintf(stderr, &quot;Error! Cannot encode picture as WebP\n&quot;);
954      fprintf(stderr, &quot;Error code: %d (%s)\n&quot;,
955              picture.error_code, kErrorMessages[picture.error_code]);
956      goto Error;
957    }
958    if (verbose) {
959      const double encode_time = StopwatchReadAndReset(&amp;stop_watch);
960      fprintf(stderr, &quot;Time to encode picture: %.3fs\n&quot;, encode_time);
961    }
962    if (dump_file) {
963      if (picture.use_argb) {
964        fprintf(stderr, &quot;Warning: can&#x27;t dump file (-d option) &quot;
965                        &quot;in lossless mode.\n&quot;);
966      } else if (!DumpPicture(&amp;picture, dump_file)) {
967        WFPRINTF(stderr, &quot;Warning, couldn&#x27;t dump picture %s\n&quot;,
968                 (const W_CHAR*)dump_file);
969      }
970    }
971    if (keep_metadata != 0) {
972      if (out != NULL) {
973        if (!WriteWebPWithMetadata(out, &amp;picture, &amp;memory_writer,
974                                   &amp;metadata, keep_metadata, &amp;metadata_written)) {
975          fprintf(stderr, &quot;Error writing WebP file with metadata!\n&quot;);
976          goto Error;
977        }
978      } else {  
979        const struct {
980          const MetadataPayload* const payload;
981          int flag;
982        } *iter, info[] = {
983          { &amp;metadata.exif, METADATA_EXIF },
984          { &amp;metadata.iccp, METADATA_ICC },
985          { &amp;metadata.xmp, METADATA_XMP },
986          { NULL, 0 }
987        };
988        uint32_t unused1 = 0;
989        uint64_t unused2 = 0;
990        for (iter = info; iter-&gt;payload != NULL; ++iter) {
991          if (UpdateFlagsAndSize(iter-&gt;payload, !!(keep_metadata &amp; iter-&gt;flag),
992                                 0, &amp;unused1, &amp;unused2)) {
993            metadata_written |= iter-&gt;flag;
994          }
995        }
996      }
997    }
998    if (!quiet) {
999      if (!short_output || print_distortion &lt; 0) {
1000        if (config.lossless) {
1001          PrintExtraInfoLossless(&amp;picture, short_output, in_file);
1002        } else {
1003          PrintExtraInfoLossy(&amp;picture, short_output, config.low_memory, in_file);
1004        }
1005      }
1006      if (!short_output &amp;&amp; picture.extra_info_type &gt; 0) {
1007        PrintMapInfo(&amp;picture);
1008      }
1009      if (print_distortion &gt;= 0) {    
1010        static const char* distortion_names[] = { &quot;PSNR&quot;, &quot;SSIM&quot;, &quot;LSIM&quot; };
1011        float values[5];
1012        if (!WebPPictureDistortion(&amp;picture, &amp;original_picture,
1013                                   print_distortion, values)) {
1014          fprintf(stderr, &quot;Error while computing the distortion.\n&quot;);
1015          goto Error;
1016        }
1017        if (!short_output) {
1018          fprintf(stderr, &quot;%s: &quot;, distortion_names[print_distortion]);
1019          fprintf(stderr, &quot;B:%.2f G:%.2f R:%.2f A:%.2f  Total:%.2f\n&quot;,
1020                  values[0], values[1], values[2], values[3], values[4]);
1021        } else {
1022          fprintf(stderr, &quot;%7d %.4f\n&quot;, picture.stats-&gt;coded_size, values[4]);
1023        }
1024      }
1025      if (!short_output) {
1026        PrintMetadataInfo(&amp;metadata, metadata_written);
1027      }
1028    }
1029    return_value = 0;
1030   Error:
1031    WebPMemoryWriterClear(&amp;memory_writer);
1032    WebPFree(picture.extra_info);
1033    MetadataFree(&amp;metadata);
1034    WebPPictureFree(&amp;picture);
1035    WebPPictureFree(&amp;original_picture);
1036    if (out != NULL &amp;&amp; out != stdout) {
1037      fclose(out);
1038    }
1039    FREE_WARGV_AND_RETURN(return_value);
1040  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-gif2webp.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-cwebp.c</div>
                </div>
                <div class="column column_space"><pre><code>222      fprintf(stderr, &quot;No input file specified!\n&quot;);
223      Help();
224      goto End;
225    }
226    gif = DGifOpenFileUnicode(in_file, &amp;gif_error);
</pre></code></div>
                <div class="column column_space"><pre><code>813      fprintf(stderr, &quot;No input file specified!\n&quot;);
814      HelpShort();
815      goto Error;
816    }
817    if (use_lossless_preset == 1) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    