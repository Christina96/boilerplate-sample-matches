<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for round.c &amp; math.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for round.c &amp; math.c
      </h3>
<h1 align="center">
        63.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>round.c (86.0%)<th>math.c (50.0%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(123-290)<td><a href="#" name="0">(168-330)</a><td align="center"><font color="#ff0000">72</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(79-117)<td><a href="#" name="1">(93-156)</a><td align="center"><font color="#310000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>round.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#include &lt;vips/intl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;vips/vips.h&gt;
#include "unary.h"
typedef struct _VipsRound {
	VipsUnary parent_instance;
	VipsOperationRound round;
} VipsRound;
typedef VipsUnaryClass VipsRoundClass;
G_DEFINE_TYPE( VipsRound, vips_round, VIPS_TYPE_UNARY );
static int
vips_round_build( VipsObject *object )
{
	VipsUnary *unary = (VipsUnary *) object;
	if( unary-&gt;in &amp;&amp;
		vips_band_format_isint( unary-&gt;in-&gt;BandFmt ) ) 
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		return( vips_unary_copy( unary ) ); 
	if( VIPS_OBJECT_CLASS( vips_round_parent_class )-&gt;build( object ) )
		return( -1 );
	return( 0 );
}
#define LOOP( TYPE, OP ) { \
	TYPE * restrict p = (TYPE *) in[0]; \
	TYPE * restrict q = (TYPE *) out; \
	\
	for( x = 0; x &lt; sz; x++ ) \
		q[x] = OP( p[x] ); \
}
#define SWITCH( OP ) { \
	switch( vips_image_get_format( im ) ) { \
        case VIPS_FORMAT_COMPLEX: \
	case VIPS_FORMAT_FLOAT: LOOP( float, OP ); break; \
	\
        case VIPS_FORMAT_DPCOMPLEX: \
	case VIPS_FORMAT_DOUBLE:LOOP( double, OP ); break;\
 	\
	default: \
		g_assert_not_reached(); \
	} \
}
static void
vips_round_buffer( VipsArithmetic *arithmetic, 
	VipsPel *out, VipsPel **in, int width )
{
	VipsRound *round = (VipsRound *) arithmetic;
	VipsImage *im = arithmetic-&gt;ready[0];
	const int sz = width * im-&gt;Bands * </b></font>
		(vips_band_format_iscomplex( im-&gt;BandFmt ) ? 2 : 1);
<a name="0"></a>	int x;
	switch( round-&gt;round ) {
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	case VIPS_OPERATION_ROUND_RINT:		SWITCH( VIPS_RINT ); break;
	case VIPS_OPERATION_ROUND_CEIL:		SWITCH( VIPS_CEIL ); break;
	case VIPS_OPERATION_ROUND_FLOOR:	SWITCH( VIPS_FLOOR ); break;
	default: 
		g_assert_not_reached(); 
	} 
}
#define UC VIPS_FORMAT_UCHAR
#define C VIPS_FORMAT_CHAR
#define US VIPS_FORMAT_USHORT
#define S VIPS_FORMAT_SHORT
#define UI VIPS_FORMAT_UINT
#define I VIPS_FORMAT_INT
#define F VIPS_FORMAT_FLOAT
#define X VIPS_FORMAT_COMPLEX
#define D VIPS_FORMAT_DOUBLE
#define DX VIPS_FORMAT_DPCOMPLEX
static const VipsBandFormat vips_round_format_table[10] = {
   UC, C,  US, S,  UI, I,  F,  X,  D,  DX 
};
static void
vips_round_class_init( VipsRoundClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsArithmeticClass *aclass = VIPS_ARITHMETIC_CLASS( class );
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "round";
	object_class-&gt;description = _( "perform a round function on an image" );
	object_class-&gt;build = vips_round_build;
	aclass-&gt;process_line = vips_round_buffer;
	vips_arithmetic_set_format_table( aclass, vips_round_format_table ); 
	VIPS_ARG_ENUM( class, "round", 200, 
		_( "Round operation" ), 
		_( "rounding operation to perform" ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsRound, round ),
		VIPS_TYPE_OPERATION_ROUND, VIPS_OPERATION_ROUND_RINT ); 
}
static void
vips_round_init( VipsRound *round )
{
}
static int
vips_roundv( VipsImage *in, VipsImage **out, 
	VipsOperationRound round, va_list ap )
{
	return( vips_call_split( "round", ap, in, out, round ) );
}
int
vips_round( VipsImage *in, VipsImage **out, VipsOperationRound round, ... )
{
	va_list ap;
	int result;
	va_start( ap, round );
	result = vips_roundv( in, out, round, ap );
	va_end( ap );
	return( result );
}
int
vips_floor( VipsImage *in, VipsImage **out, ... )
{
	va_list ap;
	int result;
	va_start( ap, out );
	result = vips_roundv( in, out, VIPS_OPERATION_ROUND_FLOOR, ap );
	va_end( ap );
	return( result );
}
int
vips_ceil( VipsImage *in, VipsImage **out, ... )
{
	va_list ap;
	int result;
	va_start( ap, out );
	result = vips_roundv( in, out, VIPS_OPERATION_ROUND_CEIL, ap );
	va_end( ap );
	return( result );
}
int
vips_rint( VipsImage *in, VipsImage **out, ... )
{
	va_list ap;
	int result;
	va_start( ap, out );
	result = vips_roundv( in, out, VIPS_OPERATION_ROUND_RINT, ap );
	va_end( ap );
	return( result );
}</b></font>
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>math.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#include &lt;vips/intl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;vips/vips.h&gt;
#include "unary.h"
typedef struct _VipsMath {
	VipsUnary parent_instance;
	VipsOperationMath math;
} VipsMath;
typedef VipsUnaryClass VipsMathClass;
G_DEFINE_TYPE( VipsMath, vips_math, VIPS_TYPE_UNARY );
static int
vips_math_build( VipsObject *object )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
	VipsUnary *unary = (VipsUnary *) object;
<a name="1"></a>
	if( unary-&gt;in &amp;&amp;
		vips_check_noncomplex( class-&gt;nickname, unary-&gt;in ) )
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		return( -1 );
	if( VIPS_OBJECT_CLASS( vips_math_parent_class )-&gt;build( object ) )
		return( -1 );
	return( 0 );
}
#define LOOP( IN, OUT, OP ) { \
	IN * restrict p = (IN *) in[0]; \
	OUT * restrict q = (OUT *) out; \
	\
	for( x = 0; x &lt; sz; x++ ) \
		q[x] = OP( p[x] ); \
}
#define SWITCH( OP ) \
	switch( vips_image_get_format( im ) ) { \
	case VIPS_FORMAT_UCHAR: \
		LOOP( unsigned char, float, OP ); break; \
	case VIPS_FORMAT_CHAR: \
		LOOP( signed char, float, OP ); break; \
	case VIPS_FORMAT_USHORT: \
		LOOP( unsigned short, float, OP ); break; \
	case VIPS_FORMAT_SHORT: \
		LOOP( signed short, float, OP ); break; \
	case VIPS_FORMAT_UINT: \
		LOOP( unsigned int, float, OP ); break; \
	case VIPS_FORMAT_INT: \
		LOOP( signed int, float, OP ); break; \
	case VIPS_FORMAT_FLOAT: \
		LOOP( float, float, OP ); break; \
	case VIPS_FORMAT_DOUBLE: \
		LOOP( double, double, OP ); break;\
 	\
	default: \
		g_assert_not_reached(); \
	} 
#define DSIN( X ) (sin( VIPS_RAD( X ) ))
#define DCOS( X ) (cos( VIPS_RAD( X ) ))
#define DTAN( X ) (tan( VIPS_RAD( X ) ))
#define ADSIN( X ) (VIPS_DEG( asin( X ) ))
#define ADCOS( X ) (VIPS_DEG( acos( X ) ))
#define ADTAN( X ) (VIPS_DEG( atan( X ) ))
#define EXP10( X ) (pow( 10.0, (X) ))
#define LOGZ( X ) ((X) == 0.0 ? 0.0 : log( X ))
#define LOGZ10( X ) ((X) == 0.0 ? 0.0 : log10( X ))
static void
vips_math_buffer( VipsArithmetic *arithmetic, 
	VipsPel *out, VipsPel **in, int width )
{
	VipsMath *math = (VipsMath *) arithmetic;
	VipsImage *im = arithmetic-&gt;ready[0];
	const int sz = width * vips_image_get_bands( im );</b></font>
	int x;
	switch( math-&gt;math ) {
	case VIPS_OPERATION_MATH_SIN: 	SWITCH( DSIN ); break;
	case VIPS_OPERATION_MATH_COS: 	SWITCH( DCOS ); break;
	case VIPS_OPERATION_MATH_TAN: 	SWITCH( DTAN ); break;
	case VIPS_OPERATION_MATH_ASIN: 	SWITCH( ADSIN ); break;
<a name="0"></a>	case VIPS_OPERATION_MATH_ACOS: 	SWITCH( ADCOS ); break;
	case VIPS_OPERATION_MATH_ATAN: 	SWITCH( ADTAN ); break;
	case VIPS_OPERATION_MATH_LOG: 	SWITCH( LOGZ ); break;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	case VIPS_OPERATION_MATH_LOG10:	SWITCH( LOGZ10 ); break;
	case VIPS_OPERATION_MATH_EXP: 	SWITCH( exp ); break;
	case VIPS_OPERATION_MATH_EXP10:	SWITCH( EXP10 ); break;
	default:
		g_assert_not_reached();
	}
}
#define UC VIPS_FORMAT_UCHAR
#define C VIPS_FORMAT_CHAR
#define US VIPS_FORMAT_USHORT
#define S VIPS_FORMAT_SHORT
#define UI VIPS_FORMAT_UINT
#define I VIPS_FORMAT_INT
#define F VIPS_FORMAT_FLOAT
#define X VIPS_FORMAT_COMPLEX
#define D VIPS_FORMAT_DOUBLE
#define DX VIPS_FORMAT_DPCOMPLEX
static const VipsBandFormat vips_math_format_table[10] = {
   F,  F,  F,  F,  F,  F,  F,  X,  D,  DX 
};
static void
vips_math_class_init( VipsMathClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsArithmeticClass *aclass = VIPS_ARITHMETIC_CLASS( class );
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "math";
	object_class-&gt;description = _( "apply a math operation to an image" );
	object_class-&gt;build = vips_math_build;
	aclass-&gt;process_line = vips_math_buffer;
	vips_arithmetic_set_format_table( aclass, vips_math_format_table ); 
	VIPS_ARG_ENUM( class, "math", 200, 
		_( "Operation" ), 
		_( "math to perform" ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsMath, math ),
		VIPS_TYPE_OPERATION_MATH, VIPS_OPERATION_MATH_SIN ); 
}
static void
vips_math_init( VipsMath *math )
{
}
static int
vips_mathv( VipsImage *in, VipsImage **out, VipsOperationMath math, va_list ap )
{
	return( vips_call_split( "math", ap, in, out, math ) );
}
int
vips_math( VipsImage *in, VipsImage **out, VipsOperationMath math, ... )
{
	va_list ap;
	int result;
	va_start( ap, math );
	result = vips_mathv( in, out, math, ap );
	va_end( ap );
	return( result );
}
int
vips_sin( VipsImage *in, VipsImage **out, ... )
{
	va_list ap;
	int result;
	va_start( ap, out );
	result = vips_mathv( in, out, VIPS_OPERATION_MATH_SIN, ap );
	va_end( ap );
	return( result );
}
int
vips_cos( VipsImage *in, VipsImage **out, ... )
{
	va_list ap;
	int result;
	va_start( ap, out );
	result = vips_mathv( in, out, VIPS_OPERATION_MATH_COS, ap );
	va_end( ap );
	return( result );
}
int
vips_tan( VipsImage *in, VipsImage **out, ... )
{
	va_list ap;
	int result;
	va_start( ap, out );
	result = vips_mathv( in, out, VIPS_OPERATION_MATH_TAN, ap );
	va_end( ap );
	return( result );
}</b></font>
int
vips_asin( VipsImage *in, VipsImage **out, ... )
{
	va_list ap;
	int result;
	va_start( ap, out );
	result = vips_mathv( in, out, VIPS_OPERATION_MATH_ASIN, ap );
	va_end( ap );
	return( result );
}
int
vips_acos( VipsImage *in, VipsImage **out, ... )
{
	va_list ap;
	int result;
	va_start( ap, out );
	result = vips_mathv( in, out, VIPS_OPERATION_MATH_ACOS, ap );
	va_end( ap );
	return( result );
}
int
vips_atan( VipsImage *in, VipsImage **out, ... )
{
	va_list ap;
	int result;
	va_start( ap, out );
	result = vips_mathv( in, out, VIPS_OPERATION_MATH_ATAN, ap );
	va_end( ap );
	return( result );
}
int
vips_log( VipsImage *in, VipsImage **out, ... )
{
	va_list ap;
	int result;
	va_start( ap, out );
	result = vips_mathv( in, out, VIPS_OPERATION_MATH_LOG, ap );
	va_end( ap );
	return( result );
}
int
vips_log10( VipsImage *in, VipsImage **out, ... )
{
	va_list ap;
	int result;
	va_start( ap, out );
	result = vips_mathv( in, out, VIPS_OPERATION_MATH_LOG10, ap );
	va_end( ap );
	return( result );
}
int
vips_exp( VipsImage *in, VipsImage **out, ... )
{
	va_list ap;
	int result;
	va_start( ap, out );
	result = vips_mathv( in, out, VIPS_OPERATION_MATH_EXP, ap );
	va_end( ap );
	return( result );
}
int
vips_exp10( VipsImage *in, VipsImage **out, ... )
{
	va_list ap;
	int result;
	va_start( ap, out );
	result = vips_mathv( in, out, VIPS_OPERATION_MATH_EXP10, ap );
	va_end( ap );
	return( result );
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
