<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for round.c &amp; math.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for round.c &amp; math.c
      </h3>
<h1 align="center">
        63.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>round.c (86.0%)<th>math.c (50.0%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(123-290)<td><a href="#" name="0">(168-330)</a><td align="center"><font color="#ff0000">72</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(79-117)<td><a href="#" name="1">(93-156)</a><td align="center"><font color="#310000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>round.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;math.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include "unary.h"
9 typedef struct _VipsRound {
10 	VipsUnary parent_instance;
11 	VipsOperationRound round;
12 } VipsRound;
13 typedef VipsUnaryClass VipsRoundClass;
14 G_DEFINE_TYPE( VipsRound, vips_round, VIPS_TYPE_UNARY );
15 static int
16 vips_round_build( VipsObject *object )
17 {
18 	VipsUnary *unary = (VipsUnary *) object;
19 	if( unary-&gt;in &amp;&amp;
20 		vips_band_format_isint( unary-&gt;in-&gt;BandFmt ) ) 
21 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		return( vips_unary_copy( unary ) ); 
22 	if( VIPS_OBJECT_CLASS( vips_round_parent_class )-&gt;build( object ) )
23 		return( -1 );
24 	return( 0 );
25 }
26 #define LOOP( TYPE, OP ) { \
27 	TYPE * restrict p = (TYPE *) in[0]; \
28 	TYPE * restrict q = (TYPE *) out; \
29 	\
30 	for( x = 0; x &lt; sz; x++ ) \
31 		q[x] = OP( p[x] ); \
32 }
33 #define SWITCH( OP ) { \
34 	switch( vips_image_get_format( im ) ) { \
35         case VIPS_FORMAT_COMPLEX: \
36 	case VIPS_FORMAT_FLOAT: LOOP( float, OP ); break; \
37 	\
38         case VIPS_FORMAT_DPCOMPLEX: \
39 	case VIPS_FORMAT_DOUBLE:LOOP( double, OP ); break;\
40  	\
41 	default: \
42 		g_assert_not_reached(); \
43 	} \
44 }
45 static void
46 vips_round_buffer( VipsArithmetic *arithmetic, 
47 	VipsPel *out, VipsPel **in, int width )
48 {
49 	VipsRound *round = (VipsRound *) arithmetic;
50 	VipsImage *im = arithmetic-&gt;ready[0];
51 	const int sz = width * im-&gt;Bands * </b></font>
52 		(vips_band_format_iscomplex( im-&gt;BandFmt ) ? 2 : 1);
53 <a name="0"></a>	int x;
54 	switch( round-&gt;round ) {
55 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	case VIPS_OPERATION_ROUND_RINT:		SWITCH( VIPS_RINT ); break;
56 	case VIPS_OPERATION_ROUND_CEIL:		SWITCH( VIPS_CEIL ); break;
57 	case VIPS_OPERATION_ROUND_FLOOR:	SWITCH( VIPS_FLOOR ); break;
58 	default: 
59 		g_assert_not_reached(); 
60 	} 
61 }
62 #define UC VIPS_FORMAT_UCHAR
63 #define C VIPS_FORMAT_CHAR
64 #define US VIPS_FORMAT_USHORT
65 #define S VIPS_FORMAT_SHORT
66 #define UI VIPS_FORMAT_UINT
67 #define I VIPS_FORMAT_INT
68 #define F VIPS_FORMAT_FLOAT
69 #define X VIPS_FORMAT_COMPLEX
70 #define D VIPS_FORMAT_DOUBLE
71 #define DX VIPS_FORMAT_DPCOMPLEX
72 static const VipsBandFormat vips_round_format_table[10] = {
73    UC, C,  US, S,  UI, I,  F,  X,  D,  DX 
74 };
75 static void
76 vips_round_class_init( VipsRoundClass *class )
77 {
78 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
79 	VipsObjectClass *object_class = (VipsObjectClass *) class;
80 	VipsArithmeticClass *aclass = VIPS_ARITHMETIC_CLASS( class );
81 	gobject_class-&gt;set_property = vips_object_set_property;
82 	gobject_class-&gt;get_property = vips_object_get_property;
83 	object_class-&gt;nickname = "round";
84 	object_class-&gt;description = _( "perform a round function on an image" );
85 	object_class-&gt;build = vips_round_build;
86 	aclass-&gt;process_line = vips_round_buffer;
87 	vips_arithmetic_set_format_table( aclass, vips_round_format_table ); 
88 	VIPS_ARG_ENUM( class, "round", 200, 
89 		_( "Round operation" ), 
90 		_( "rounding operation to perform" ),
91 		VIPS_ARGUMENT_REQUIRED_INPUT,
92 		G_STRUCT_OFFSET( VipsRound, round ),
93 		VIPS_TYPE_OPERATION_ROUND, VIPS_OPERATION_ROUND_RINT ); 
94 }
95 static void
96 vips_round_init( VipsRound *round )
97 {
98 }
99 static int
100 vips_roundv( VipsImage *in, VipsImage **out, 
101 	VipsOperationRound round, va_list ap )
102 {
103 	return( vips_call_split( "round", ap, in, out, round ) );
104 }
105 int
106 vips_round( VipsImage *in, VipsImage **out, VipsOperationRound round, ... )
107 {
108 	va_list ap;
109 	int result;
110 	va_start( ap, round );
111 	result = vips_roundv( in, out, round, ap );
112 	va_end( ap );
113 	return( result );
114 }
115 int
116 vips_floor( VipsImage *in, VipsImage **out, ... )
117 {
118 	va_list ap;
119 	int result;
120 	va_start( ap, out );
121 	result = vips_roundv( in, out, VIPS_OPERATION_ROUND_FLOOR, ap );
122 	va_end( ap );
123 	return( result );
124 }
125 int
126 vips_ceil( VipsImage *in, VipsImage **out, ... )
127 {
128 	va_list ap;
129 	int result;
130 	va_start( ap, out );
131 	result = vips_roundv( in, out, VIPS_OPERATION_ROUND_CEIL, ap );
132 	va_end( ap );
133 	return( result );
134 }
135 int
136 vips_rint( VipsImage *in, VipsImage **out, ... )
137 {
138 	va_list ap;
139 	int result;
140 	va_start( ap, out );
141 	result = vips_roundv( in, out, VIPS_OPERATION_ROUND_RINT, ap );
142 	va_end( ap );
143 	return( result );
144 }</b></font>
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>math.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;math.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include "unary.h"
9 typedef struct _VipsMath {
10 	VipsUnary parent_instance;
11 	VipsOperationMath math;
12 } VipsMath;
13 typedef VipsUnaryClass VipsMathClass;
14 G_DEFINE_TYPE( VipsMath, vips_math, VIPS_TYPE_UNARY );
15 static int
16 vips_math_build( VipsObject *object )
17 {
18 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
19 	VipsUnary *unary = (VipsUnary *) object;
20 <a name="1"></a>
21 	if( unary-&gt;in &amp;&amp;
22 		vips_check_noncomplex( class-&gt;nickname, unary-&gt;in ) )
23 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		return( -1 );
24 	if( VIPS_OBJECT_CLASS( vips_math_parent_class )-&gt;build( object ) )
25 		return( -1 );
26 	return( 0 );
27 }
28 #define LOOP( IN, OUT, OP ) { \
29 	IN * restrict p = (IN *) in[0]; \
30 	OUT * restrict q = (OUT *) out; \
31 	\
32 	for( x = 0; x &lt; sz; x++ ) \
33 		q[x] = OP( p[x] ); \
34 }
35 #define SWITCH( OP ) \
36 	switch( vips_image_get_format( im ) ) { \
37 	case VIPS_FORMAT_UCHAR: \
38 		LOOP( unsigned char, float, OP ); break; \
39 	case VIPS_FORMAT_CHAR: \
40 		LOOP( signed char, float, OP ); break; \
41 	case VIPS_FORMAT_USHORT: \
42 		LOOP( unsigned short, float, OP ); break; \
43 	case VIPS_FORMAT_SHORT: \
44 		LOOP( signed short, float, OP ); break; \
45 	case VIPS_FORMAT_UINT: \
46 		LOOP( unsigned int, float, OP ); break; \
47 	case VIPS_FORMAT_INT: \
48 		LOOP( signed int, float, OP ); break; \
49 	case VIPS_FORMAT_FLOAT: \
50 		LOOP( float, float, OP ); break; \
51 	case VIPS_FORMAT_DOUBLE: \
52 		LOOP( double, double, OP ); break;\
53  	\
54 	default: \
55 		g_assert_not_reached(); \
56 	} 
57 #define DSIN( X ) (sin( VIPS_RAD( X ) ))
58 #define DCOS( X ) (cos( VIPS_RAD( X ) ))
59 #define DTAN( X ) (tan( VIPS_RAD( X ) ))
60 #define ADSIN( X ) (VIPS_DEG( asin( X ) ))
61 #define ADCOS( X ) (VIPS_DEG( acos( X ) ))
62 #define ADTAN( X ) (VIPS_DEG( atan( X ) ))
63 #define EXP10( X ) (pow( 10.0, (X) ))
64 #define LOGZ( X ) ((X) == 0.0 ? 0.0 : log( X ))
65 #define LOGZ10( X ) ((X) == 0.0 ? 0.0 : log10( X ))
66 static void
67 vips_math_buffer( VipsArithmetic *arithmetic, 
68 	VipsPel *out, VipsPel **in, int width )
69 {
70 	VipsMath *math = (VipsMath *) arithmetic;
71 	VipsImage *im = arithmetic-&gt;ready[0];
72 	const int sz = width * vips_image_get_bands( im );</b></font>
73 	int x;
74 	switch( math-&gt;math ) {
75 	case VIPS_OPERATION_MATH_SIN: 	SWITCH( DSIN ); break;
76 	case VIPS_OPERATION_MATH_COS: 	SWITCH( DCOS ); break;
77 	case VIPS_OPERATION_MATH_TAN: 	SWITCH( DTAN ); break;
78 	case VIPS_OPERATION_MATH_ASIN: 	SWITCH( ADSIN ); break;
79 <a name="0"></a>	case VIPS_OPERATION_MATH_ACOS: 	SWITCH( ADCOS ); break;
80 	case VIPS_OPERATION_MATH_ATAN: 	SWITCH( ADTAN ); break;
81 	case VIPS_OPERATION_MATH_LOG: 	SWITCH( LOGZ ); break;
82 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	case VIPS_OPERATION_MATH_LOG10:	SWITCH( LOGZ10 ); break;
83 	case VIPS_OPERATION_MATH_EXP: 	SWITCH( exp ); break;
84 	case VIPS_OPERATION_MATH_EXP10:	SWITCH( EXP10 ); break;
85 	default:
86 		g_assert_not_reached();
87 	}
88 }
89 #define UC VIPS_FORMAT_UCHAR
90 #define C VIPS_FORMAT_CHAR
91 #define US VIPS_FORMAT_USHORT
92 #define S VIPS_FORMAT_SHORT
93 #define UI VIPS_FORMAT_UINT
94 #define I VIPS_FORMAT_INT
95 #define F VIPS_FORMAT_FLOAT
96 #define X VIPS_FORMAT_COMPLEX
97 #define D VIPS_FORMAT_DOUBLE
98 #define DX VIPS_FORMAT_DPCOMPLEX
99 static const VipsBandFormat vips_math_format_table[10] = {
100    F,  F,  F,  F,  F,  F,  F,  X,  D,  DX 
101 };
102 static void
103 vips_math_class_init( VipsMathClass *class )
104 {
105 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
106 	VipsObjectClass *object_class = (VipsObjectClass *) class;
107 	VipsArithmeticClass *aclass = VIPS_ARITHMETIC_CLASS( class );
108 	gobject_class-&gt;set_property = vips_object_set_property;
109 	gobject_class-&gt;get_property = vips_object_get_property;
110 	object_class-&gt;nickname = "math";
111 	object_class-&gt;description = _( "apply a math operation to an image" );
112 	object_class-&gt;build = vips_math_build;
113 	aclass-&gt;process_line = vips_math_buffer;
114 	vips_arithmetic_set_format_table( aclass, vips_math_format_table ); 
115 	VIPS_ARG_ENUM( class, "math", 200, 
116 		_( "Operation" ), 
117 		_( "math to perform" ),
118 		VIPS_ARGUMENT_REQUIRED_INPUT,
119 		G_STRUCT_OFFSET( VipsMath, math ),
120 		VIPS_TYPE_OPERATION_MATH, VIPS_OPERATION_MATH_SIN ); 
121 }
122 static void
123 vips_math_init( VipsMath *math )
124 {
125 }
126 static int
127 vips_mathv( VipsImage *in, VipsImage **out, VipsOperationMath math, va_list ap )
128 {
129 	return( vips_call_split( "math", ap, in, out, math ) );
130 }
131 int
132 vips_math( VipsImage *in, VipsImage **out, VipsOperationMath math, ... )
133 {
134 	va_list ap;
135 	int result;
136 	va_start( ap, math );
137 	result = vips_mathv( in, out, math, ap );
138 	va_end( ap );
139 	return( result );
140 }
141 int
142 vips_sin( VipsImage *in, VipsImage **out, ... )
143 {
144 	va_list ap;
145 	int result;
146 	va_start( ap, out );
147 	result = vips_mathv( in, out, VIPS_OPERATION_MATH_SIN, ap );
148 	va_end( ap );
149 	return( result );
150 }
151 int
152 vips_cos( VipsImage *in, VipsImage **out, ... )
153 {
154 	va_list ap;
155 	int result;
156 	va_start( ap, out );
157 	result = vips_mathv( in, out, VIPS_OPERATION_MATH_COS, ap );
158 	va_end( ap );
159 	return( result );
160 }
161 int
162 vips_tan( VipsImage *in, VipsImage **out, ... )
163 {
164 	va_list ap;
165 	int result;
166 	va_start( ap, out );
167 	result = vips_mathv( in, out, VIPS_OPERATION_MATH_TAN, ap );
168 	va_end( ap );
169 	return( result );
170 }</b></font>
171 int
172 vips_asin( VipsImage *in, VipsImage **out, ... )
173 {
174 	va_list ap;
175 	int result;
176 	va_start( ap, out );
177 	result = vips_mathv( in, out, VIPS_OPERATION_MATH_ASIN, ap );
178 	va_end( ap );
179 	return( result );
180 }
181 int
182 vips_acos( VipsImage *in, VipsImage **out, ... )
183 {
184 	va_list ap;
185 	int result;
186 	va_start( ap, out );
187 	result = vips_mathv( in, out, VIPS_OPERATION_MATH_ACOS, ap );
188 	va_end( ap );
189 	return( result );
190 }
191 int
192 vips_atan( VipsImage *in, VipsImage **out, ... )
193 {
194 	va_list ap;
195 	int result;
196 	va_start( ap, out );
197 	result = vips_mathv( in, out, VIPS_OPERATION_MATH_ATAN, ap );
198 	va_end( ap );
199 	return( result );
200 }
201 int
202 vips_log( VipsImage *in, VipsImage **out, ... )
203 {
204 	va_list ap;
205 	int result;
206 	va_start( ap, out );
207 	result = vips_mathv( in, out, VIPS_OPERATION_MATH_LOG, ap );
208 	va_end( ap );
209 	return( result );
210 }
211 int
212 vips_log10( VipsImage *in, VipsImage **out, ... )
213 {
214 	va_list ap;
215 	int result;
216 	va_start( ap, out );
217 	result = vips_mathv( in, out, VIPS_OPERATION_MATH_LOG10, ap );
218 	va_end( ap );
219 	return( result );
220 }
221 int
222 vips_exp( VipsImage *in, VipsImage **out, ... )
223 {
224 	va_list ap;
225 	int result;
226 	va_start( ap, out );
227 	result = vips_mathv( in, out, VIPS_OPERATION_MATH_EXP, ap );
228 	va_end( ap );
229 	return( result );
230 }
231 int
232 vips_exp10( VipsImage *in, VipsImage **out, ... )
233 {
234 	va_list ap;
235 	int result;
236 	va_start( ap, out );
237 	result = vips_mathv( in, out, VIPS_OPERATION_MATH_EXP10, ap );
238 	va_end( ap );
239 	return( result );
240 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
