
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 28, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-config.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include &quot;Win32_Interop/win32_types.h&quot;
3  #include &quot;Win32_Interop/Win32_EventLog.h&quot;
4  #include &quot;Win32_Interop/Win32_Error.h&quot;
5  #include &lt;direct.h&gt;
6  #endif
7  #include &quot;server.h&quot;
8  #include &quot;cluster.h&quot;
9  #include &lt;fcntl.h&gt;
10  #include &lt;sys/stat.h&gt;
11  typedef struct configEnum {
12      const char *name;
13      const int val;
14  } configEnum;
15  configEnum maxmemory_policy_enum[] = {
16      {&quot;volatile-lru&quot;, MAXMEMORY_VOLATILE_LRU},
17      {&quot;volatile-lfu&quot;, MAXMEMORY_VOLATILE_LFU},
18      {&quot;volatile-random&quot;,MAXMEMORY_VOLATILE_RANDOM},
19      {&quot;volatile-ttl&quot;,MAXMEMORY_VOLATILE_TTL},
20      {&quot;allkeys-lru&quot;,MAXMEMORY_ALLKEYS_LRU},
21      {&quot;allkeys-lfu&quot;,MAXMEMORY_ALLKEYS_LFU},
22      {&quot;allkeys-random&quot;,MAXMEMORY_ALLKEYS_RANDOM},
23      {&quot;noeviction&quot;,MAXMEMORY_NO_EVICTION},
24      {NULL, 0}
25  };
26  #ifndef _WIN32
27  configEnum syslog_facility_enum[] = {
28      {&quot;user&quot;,    LOG_USER},
29      {&quot;local0&quot;,  LOG_LOCAL0},
30      {&quot;local1&quot;,  LOG_LOCAL1},
31      {&quot;local2&quot;,  LOG_LOCAL2},
32      {&quot;local3&quot;,  LOG_LOCAL3},
33      {&quot;local4&quot;,  LOG_LOCAL4},
34      {&quot;local5&quot;,  LOG_LOCAL5},
35      {&quot;local6&quot;,  LOG_LOCAL6},
36      {&quot;local7&quot;,  LOG_LOCAL7},
37      {NULL, 0}
38  };
39  #endif
40  configEnum loglevel_enum[] = {
41      {&quot;debug&quot;, LL_DEBUG},
42      {&quot;verbose&quot;, LL_VERBOSE},
43      {&quot;notice&quot;, LL_NOTICE},
44      {&quot;warning&quot;, LL_WARNING},
45      {NULL,0}
46  };
47  configEnum supervised_mode_enum[] = {
48      {&quot;upstart&quot;, SUPERVISED_UPSTART},
49      {&quot;systemd&quot;, SUPERVISED_SYSTEMD},
50      {&quot;auto&quot;, SUPERVISED_AUTODETECT},
51      {&quot;no&quot;, SUPERVISED_NONE},
52      {NULL, 0}
53  };
54  configEnum aof_fsync_enum[] = {
55      {&quot;everysec&quot;, AOF_FSYNC_EVERYSEC},
56      {&quot;always&quot;, AOF_FSYNC_ALWAYS},
57      {&quot;no&quot;, AOF_FSYNC_NO},
58      {NULL, 0}
59  };
60  clientBufferLimitsConfig clientBufferLimitsDefaults[CLIENT_TYPE_OBUF_COUNT] = {
61      {0, 0, 0}, &amp;bsol;* normal */
62      {1024*1024*256, 1024*1024*64, 60}, &amp;bsol;* slave */
63      {1024*1024*32, 1024*1024*8, 60}  &amp;bsol;* pubsub */
64  };
65  int configEnumGetValue(configEnum *ce, char *name) {
66      while(ce-&gt;name != NULL) {
67          if (!strcasecmp(ce-&gt;name,name)) return ce-&gt;val;
68          ce++;
69      }
70      return INT_MIN;
71  }
72  const char *configEnumGetName(configEnum *ce, int val) {
73      while(ce-&gt;name != NULL) {
74          if (ce-&gt;val == val) return ce-&gt;name;
75          ce++;
76      }
77      return NULL;
78  }
79  const char *configEnumGetNameOrUnknown(configEnum *ce, int val) {
80      const char *name = configEnumGetName(ce,val);
81      return name ? name : &quot;unknown&quot;;
82  }
83  const char *evictPolicyToString(void) {
84      return configEnumGetNameOrUnknown(maxmemory_policy_enum,server.maxmemory_policy);
85  }
86  int yesnotoi(char *s) {
87      if (!strcasecmp(s,&quot;yes&quot;)) return 1;
88      else if (!strcasecmp(s,&quot;no&quot;)) return 0;
89      else return -1;
90  }
91  void appendServerSaveParams(time_t seconds, int changes) {
92      server.saveparams = zrealloc(server.saveparams,sizeof(struct saveparam)*((PORT_ULONG)server.saveparamslen+1));  WIN_PORT_FIX &amp;bsol;* cat (PORT_ULONG) */
93      server.saveparams[server.saveparamslen].seconds = seconds;
94      server.saveparams[server.saveparamslen].changes = changes;
95      server.saveparamslen++;
96  }
97  void resetServerSaveParams(void) {
98      zfree(server.saveparams);
99      server.saveparams = NULL;
100      server.saveparamslen = 0;
101  }
102  void queueLoadModule(sds path, sds *argv, int argc) {
103      int i;
104      struct moduleLoadQueueEntry *loadmod;
105      loadmod = zmalloc(sizeof(struct moduleLoadQueueEntry));
106      loadmod-&gt;argv = zmalloc(sizeof(robj*)*argc);
107      loadmod-&gt;path = sdsnew(path);
108      loadmod-&gt;argc = argc;
109      for (i = 0; i &lt; argc; i++) {
110          loadmod-&gt;argv[i] = createRawStringObject(argv[i],sdslen(argv[i]));
111      }
112      listAddNodeTail(server.loadmodule_queue,loadmod);
113  }
114  void loadServerConfigFromString(char *config) {
115      char *err = NULL;
116      int linenum = 0, totlines, i;
117      int slaveof_linenum = 0;
118      sds *lines;
119      lines = sdssplitlen(config,(int)strlen(config),&quot;\n&quot;,1,&amp;totlines);           WIN_PORT_FIX &amp;bsol;* cast (int) */
120      for (i = 0; i &lt; totlines; i++) {
121          sds *argv;
122          int argc;
123          linenum = i+1;
124          lines[i] = sdstrim(lines[i],&quot; \t\r\n&quot;);
125          if (lines[i][0] == &#x27;#&#x27; || lines[i][0] == &#x27;\0&#x27;) continue;
126          argv = sdssplitargs(lines[i],&amp;argc);
127          if (argv == NULL) {
128              err = &quot;Unbalanced quotes in configuration line&quot;;
129              goto loaderr;
130          }
131          if (argc == 0) {
132              sdsfreesplitres(argv,argc);
133              continue;
134          }
135          sdstolower(argv[0]);
136          if (!strcasecmp(argv[0],&quot;timeout&quot;) &amp;&amp; argc == 2) {
137              server.maxidletime = atoi(argv[1]);
138              if (server.maxidletime &lt; 0) {
139                  err = &quot;Invalid timeout value&quot;; goto loaderr;
140              }
141          } else if (!strcasecmp(argv[0],&quot;tcp-keepalive&quot;) &amp;&amp; argc == 2) {
142              server.tcpkeepalive = atoi(argv[1]);
143              if (server.tcpkeepalive &lt; 0) {
144                  err = &quot;Invalid tcp-keepalive value&quot;; goto loaderr;
145              }
146          } else if (!strcasecmp(argv[0],&quot;protected-mode&quot;) &amp;&amp; argc == 2) {
147              if ((server.protected_mode = yesnotoi(argv[1])) == -1) {
148                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
149              }
150          } else if (!strcasecmp(argv[0],&quot;port&quot;) &amp;&amp; argc == 2) {
151              server.port = atoi(argv[1]);
152              if (server.port &lt; 0 || server.port &gt; 65535) {
153                  err = &quot;Invalid port&quot;; goto loaderr;
154              }
155          } else if (!strcasecmp(argv[0],&quot;tcp-backlog&quot;) &amp;&amp; argc == 2) {
156              server.tcp_backlog = atoi(argv[1]);
157              if (server.tcp_backlog &lt; 0) {
158                  err = &quot;Invalid backlog value&quot;; goto loaderr;
159              }
160          } else if (!strcasecmp(argv[0],&quot;bind&quot;) &amp;&amp; argc &gt;= 2) {
161              int j, addresses = argc-1;
162              if (addresses &gt; CONFIG_BINDADDR_MAX) {
163                  err = &quot;Too many bind addresses specified&quot;; goto loaderr;
164              }
165              for (j = 0; j &lt; addresses; j++)
166                  server.bindaddr[j] = zstrdup(argv[j+1]);
167              server.bindaddr_count = addresses;
168          } else if (!strcasecmp(argv[0],&quot;unixsocket&quot;) &amp;&amp; argc == 2) {
169              server.unixsocket = zstrdup(argv[1]);
170          } else if (!strcasecmp(argv[0],&quot;unixsocketperm&quot;) &amp;&amp; argc == 2) {
171              errno = 0;
172              server.unixsocketperm = (mode_t)strtol(argv[1], NULL, 8);
173              if (errno || server.unixsocketperm &gt; 0777) {
174                  err = &quot;Invalid socket file permissions&quot;; goto loaderr;
175              }
176          } else if (!strcasecmp(argv[0],&quot;save&quot;)) {
177              if (argc == 3) {
178                  int seconds = atoi(argv[1]);
179                  int changes = atoi(argv[2]);
180                  if (seconds &lt; 1 || changes &lt; 0) {
181                      err = &quot;Invalid save parameters&quot;; goto loaderr;
182                  }
183                  appendServerSaveParams(seconds,changes);
184              } else if (argc == 2 &amp;&amp; !strcasecmp(argv[1],&quot;&quot;)) {
185                  resetServerSaveParams();
186              }
187          } else if (!strcasecmp(argv[0],&quot;dir&quot;) &amp;&amp; argc == 2) {
188              if (chdir(argv[1]) == -1) {
189                  serverLog(LL_WARNING,&quot;Can&#x27;t chdir to &#x27;%s&#x27;: %s&quot;,
190                      argv[1], IF_WIN32(wsa_strerror(errno), strerror(errno)));
191                  exit(1);
192              }
193          } else if (!strcasecmp(argv[0],&quot;loglevel&quot;) &amp;&amp; argc == 2) {
194              server.verbosity = configEnumGetValue(loglevel_enum,argv[1]);
195              if (server.verbosity == INT_MIN) {
196                  err = &quot;Invalid log level. &quot;
197                        &quot;Must be one of debug, verbose, notice, warning&quot;;
198                  goto loaderr;
199              }
200  #ifdef _WIN32
201              setLogVerbosityLevel(server.verbosity);
202  #endif
203          } else if (!strcasecmp(argv[0],&quot;logfile&quot;) &amp;&amp; argc == 2) {
204              FILE *logfp;
205              zfree(server.logfile);
206  #ifdef _WIN32
207              int length = (int)sdslen(argv[1]);
208              if ((argv[1][0] == &#x27;\&#x27;&#x27;  &amp;&amp;  argv[1][length-1] == &#x27;\&#x27;&#x27;)  ||
209                  (argv[1][0] == &#x27;\&quot;&#x27;  &amp;&amp;  argv[1][length-1] == &#x27;\&quot;&#x27;)) {
210                  if (length == 2) {
211                      server.logfile = zstrdup(&quot;\0&quot;);
212                  } else {
213                      size_t l = (size_t) length - 2 + 1;
214                      char *p = zmalloc(l);
215                      memcpy(p, argv[1]+1, l);
216                      server.logfile = p;
217                  }
218              } else {
219                  server.logfile = zstrdup(argv[1]);
220              }
221  #else
222              server.logfile = zstrdup(argv[1]);
223  #endif
224              if (server.logfile[0] != &#x27;\0&#x27;) {
225                  logfp = fopen(server.logfile,&quot;a&quot;);
226                  if (logfp == NULL) {
227                      err = sdscatprintf(sdsempty(),
228                          &quot;Can&#x27;t open the log file: %s&quot;, IF_WIN32(wsa_strerror(errno), strerror(errno)));
229                      goto loaderr;
230  #ifdef _WIN32
231                  } else {
232                      setLogFile(server.logfile);
233  #endif
234                  }
235                  fclose(logfp);
236              }
237          } else if (!strcasecmp(argv[0],&quot;always-show-logo&quot;) &amp;&amp; argc == 2) {
238              if ((server.always_show_logo = yesnotoi(argv[1])) == -1) {
239                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
240              }
241          } else if (!strcasecmp(argv[0],&quot;syslog-enabled&quot;) &amp;&amp; argc == 2) {
242              if ((server.syslog_enabled = yesnotoi(argv[1])) == -1) {
243                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
244              }
245  #ifdef _WIN32
246              setSyslogEnabled(server.syslog_enabled);
247  #endif
248          } else if (!strcasecmp(argv[0],&quot;syslog-ident&quot;) &amp;&amp; argc == 2) {
249              if (server.syslog_ident) zfree(server.syslog_ident);
250              server.syslog_ident = zstrdup(argv[1]);
251  #ifdef _WIN32
252              setSyslogIdent(server.syslog_ident);
253  #endif
254          } else if (!strcasecmp(argv[0],&quot;syslog-facility&quot;) &amp;&amp; argc == 2) {
255  #ifdef _WIN32
256  #else
257              server.syslog_facility =
258                  configEnumGetValue(syslog_facility_enum,argv[1]);
259              if (server.syslog_facility == INT_MIN) {
260                  err = &quot;Invalid log facility. Must be one of USER or between LOCAL0-LOCAL7&quot;;
261                  goto loaderr;
262              }
263  #endif
264          } else if (!strcasecmp(argv[0],&quot;databases&quot;) &amp;&amp; argc == 2) {
265              server.dbnum = atoi(argv[1]);
266              if (server.dbnum &lt; 1) {
267                  err = &quot;Invalid number of databases&quot;; goto loaderr;
268              }
269          } else if (!strcasecmp(argv[0],&quot;include&quot;) &amp;&amp; argc == 2) {
270              loadServerConfig(argv[1],NULL);
271          } else if (!strcasecmp(argv[0],&quot;maxclients&quot;) &amp;&amp; argc == 2) {
272              server.maxclients = atoi(argv[1]);
273              if (server.maxclients &lt; 1) {
274                  err = &quot;Invalid max clients limit&quot;; goto loaderr;
275              }
276          } else if (!strcasecmp(argv[0],&quot;maxmemory&quot;) &amp;&amp; argc == 2) {
277              server.maxmemory = memtoll(argv[1],NULL);
278          } else if (!strcasecmp(argv[0],&quot;maxmemory-policy&quot;) &amp;&amp; argc == 2) {
279              server.maxmemory_policy =
280                  configEnumGetValue(maxmemory_policy_enum,argv[1]);
281              if (server.maxmemory_policy == INT_MIN) {
282                  err = &quot;Invalid maxmemory policy&quot;;
283                  goto loaderr;
284              }
285          } else if (!strcasecmp(argv[0],&quot;maxmemory-samples&quot;) &amp;&amp; argc == 2) {
286              server.maxmemory_samples = atoi(argv[1]);
287              if (server.maxmemory_samples &lt;= 0) {
288                  err = &quot;maxmemory-samples must be 1 or greater&quot;;
289                  goto loaderr;
290              }
291          } else if ((!strcasecmp(argv[0],&quot;proto-max-bulk-len&quot;)) &amp;&amp; argc == 2) {
292              server.proto_max_bulk_len = memtoll(argv[1],NULL);
293          } else if ((!strcasecmp(argv[0],&quot;client-query-buffer-limit&quot;)) &amp;&amp; argc == 2) {
294              server.client_max_querybuf_len = memtoll(argv[1],NULL);
295          } else if (!strcasecmp(argv[0],&quot;lfu-log-factor&quot;) &amp;&amp; argc == 2) {
296              server.lfu_log_factor = atoi(argv[1]);
297              if (server.lfu_log_factor &lt; 0) {
298                  err = &quot;lfu-log-factor must be 0 or greater&quot;;
299                  goto loaderr;
300              }
301          } else if (!strcasecmp(argv[0],&quot;lfu-decay-time&quot;) &amp;&amp; argc == 2) {
302              server.lfu_decay_time = atoi(argv[1]);
303              if (server.lfu_decay_time &lt; 0) {
304                  err = &quot;lfu-decay-time must be 0 or greater&quot;;
305                  goto loaderr;
306              }
307          } else if ((!strcasecmp(argv[0],&quot;slaveof&quot;) ||
308                      !strcasecmp(argv[0],&quot;replicaof&quot;)) &amp;&amp; argc == 3) {
309              slaveof_linenum = linenum;
310              server.masterhost = sdsnew(argv[1]);
311              server.masterport = atoi(argv[2]);
312              server.repl_state = REPL_STATE_CONNECT;
313          } else if ((!strcasecmp(argv[0],&quot;repl-ping-slave-period&quot;) ||
314                      !strcasecmp(argv[0],&quot;repl-ping-replica-period&quot;)) &amp;&amp;
315                      argc == 2)
316          {
317              server.repl_ping_slave_period = atoi(argv[1]);
318              if (server.repl_ping_slave_period &lt;= 0) {
319                  err = &quot;repl-ping-replica-period must be 1 or greater&quot;;
320                  goto loaderr;
321              }
322          } else if (!strcasecmp(argv[0],&quot;repl-timeout&quot;) &amp;&amp; argc == 2) {
323              server.repl_timeout = atoi(argv[1]);
324              if (server.repl_timeout &lt;= 0) {
325                  err = &quot;repl-timeout must be 1 or greater&quot;;
326                  goto loaderr;
327              }
328          } else if (!strcasecmp(argv[0],&quot;repl-disable-tcp-nodelay&quot;) &amp;&amp; argc==2) {
329              if ((server.repl_disable_tcp_nodelay = yesnotoi(argv[1])) == -1) {
330                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
331              }
332          } else if (!strcasecmp(argv[0],&quot;repl-diskless-sync&quot;) &amp;&amp; argc==2) {
333              if ((server.repl_diskless_sync = yesnotoi(argv[1])) == -1) {
334                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
335              }
336          } else if (!strcasecmp(argv[0],&quot;repl-diskless-sync-delay&quot;) &amp;&amp; argc==2) {
337              server.repl_diskless_sync_delay = atoi(argv[1]);
338              if (server.repl_diskless_sync_delay &lt; 0) {
339                  err = &quot;repl-diskless-sync-delay can&#x27;t be negative&quot;;
340                  goto loaderr;
341              }
342          } else if (!strcasecmp(argv[0],&quot;repl-backlog-size&quot;) &amp;&amp; argc == 2) {
343              PORT_LONGLONG size = memtoll(argv[1],NULL);
344              if (size &lt;= 0) {
345                  err = &quot;repl-backlog-size must be 1 or greater.&quot;;
346                  goto loaderr;
347              }
348              resizeReplicationBacklog(size);
349          } else if (!strcasecmp(argv[0],&quot;repl-backlog-ttl&quot;) &amp;&amp; argc == 2) {
350              server.repl_backlog_time_limit = atoi(argv[1]);
351              if (server.repl_backlog_time_limit &lt; 0) {
352                  err = &quot;repl-backlog-ttl can&#x27;t be negative &quot;;
353                  goto loaderr;
354              }
355          } else if (!strcasecmp(argv[0],&quot;masterauth&quot;) &amp;&amp; argc == 2) {
356              zfree(server.masterauth);
357              server.masterauth = argv[1][0] ? zstrdup(argv[1]) : NULL;
358          } else if ((!strcasecmp(argv[0],&quot;slave-serve-stale-data&quot;) ||
359                      !strcasecmp(argv[0],&quot;replica-serve-stale-data&quot;))
360                      &amp;&amp; argc == 2)
361          {
362              if ((server.repl_serve_stale_data = yesnotoi(argv[1])) == -1) {
363                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
364              }
365          } else if ((!strcasecmp(argv[0],&quot;slave-read-only&quot;) ||
366                      !strcasecmp(argv[0],&quot;replica-read-only&quot;))
367                      &amp;&amp; argc == 2)
368          {
369              if ((server.repl_slave_ro = yesnotoi(argv[1])) == -1) {
370                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
371              }
372          } else if ((!strcasecmp(argv[0],&quot;slave-ignore-maxmemory&quot;) ||
373                      !strcasecmp(argv[0],&quot;replica-ignore-maxmemory&quot;))
374                      &amp;&amp; argc == 2)
375          {
376              if ((server.repl_slave_ignore_maxmemory = yesnotoi(argv[1])) == -1) {
377                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
378              }
379          } else if (!strcasecmp(argv[0],&quot;rdbcompression&quot;) &amp;&amp; argc == 2) {
380              if ((server.rdb_compression = yesnotoi(argv[1])) == -1) {
381                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
382              }
383          } else if (!strcasecmp(argv[0],&quot;rdbchecksum&quot;) &amp;&amp; argc == 2) {
384              if ((server.rdb_checksum = yesnotoi(argv[1])) == -1) {
385                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
386              }
387          } else if (!strcasecmp(argv[0],&quot;activerehashing&quot;) &amp;&amp; argc == 2) {
388              if ((server.activerehashing = yesnotoi(argv[1])) == -1) {
389                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
390              }
391          } else if (!strcasecmp(argv[0],&quot;lazyfree-lazy-eviction&quot;) &amp;&amp; argc == 2) {
392              if ((server.lazyfree_lazy_eviction = yesnotoi(argv[1])) == -1) {
393                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
394              }
395          } else if (!strcasecmp(argv[0],&quot;lazyfree-lazy-expire&quot;) &amp;&amp; argc == 2) {
396              if ((server.lazyfree_lazy_expire = yesnotoi(argv[1])) == -1) {
397                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
398              }
399          } else if (!strcasecmp(argv[0],&quot;lazyfree-lazy-server-del&quot;) &amp;&amp; argc == 2){
400              if ((server.lazyfree_lazy_server_del = yesnotoi(argv[1])) == -1) {
401                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
402              }
403          } else if ((!strcasecmp(argv[0],&quot;slave-lazy-flush&quot;) ||
404                      !strcasecmp(argv[0],&quot;replica-lazy-flush&quot;)) &amp;&amp; argc == 2)
405          {
406              if ((server.repl_slave_lazy_flush = yesnotoi(argv[1])) == -1) {
407                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
408              }
409          } else if (!strcasecmp(argv[0],&quot;activedefrag&quot;) &amp;&amp; argc == 2) {
410              if ((server.active_defrag_enabled = yesnotoi(argv[1])) == -1) {
411                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
412              }
413              if (server.active_defrag_enabled) {
414  #ifndef HAVE_DEFRAG
415                  err = &quot;active defrag can&#x27;t be enabled without proper jemalloc support&quot;; goto loaderr;
416  #endif
417              }
418          } else if (!strcasecmp(argv[0],&quot;daemonize&quot;) &amp;&amp; argc == 2) {
419              if ((server.daemonize = yesnotoi(argv[1])) == -1) {
420                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
421              }
422          } else if (!strcasecmp(argv[0],&quot;dynamic-hz&quot;) &amp;&amp; argc == 2) {
423              if ((server.dynamic_hz = yesnotoi(argv[1])) == -1) {
424                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
425              }
426          } else if (!strcasecmp(argv[0],&quot;hz&quot;) &amp;&amp; argc == 2) {
427              server.config_hz = atoi(argv[1]);
428              if (server.config_hz &lt; CONFIG_MIN_HZ) server.config_hz = CONFIG_MIN_HZ;
429              if (server.config_hz &gt; CONFIG_MAX_HZ) server.config_hz = CONFIG_MAX_HZ;
430          } else if (!strcasecmp(argv[0],&quot;appendonly&quot;) &amp;&amp; argc == 2) {
431              int yes;
432              if ((yes = yesnotoi(argv[1])) == -1) {
433                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
434              }
435              server.aof_state = yes ? AOF_ON : AOF_OFF;
436          } else if (!strcasecmp(argv[0],&quot;appendfilename&quot;) &amp;&amp; argc == 2) {
437              if (!pathIsBaseName(argv[1])) {
438                  err = &quot;appendfilename can&#x27;t be a path, just a filename&quot;;
439                  goto loaderr;
440              }
441              zfree(server.aof_filename);
442              server.aof_filename = zstrdup(argv[1]);
443          } else if (!strcasecmp(argv[0],&quot;no-appendfsync-on-rewrite&quot;)
444                     &amp;&amp; argc == 2) {
445              if ((server.aof_no_fsync_on_rewrite= yesnotoi(argv[1])) == -1) {
446                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
447              }
448          } else if (!strcasecmp(argv[0],&quot;appendfsync&quot;) &amp;&amp; argc == 2) {
449              server.aof_fsync = configEnumGetValue(aof_fsync_enum,argv[1]);
450              if (server.aof_fsync == INT_MIN) {
451                  err = &quot;argument must be &#x27;no&#x27;, &#x27;always&#x27; or &#x27;everysec&#x27;&quot;;
452                  goto loaderr;
453              }
454          } else if (!strcasecmp(argv[0],&quot;auto-aof-rewrite-percentage&quot;) &amp;&amp;
455                     argc == 2)
456          {
457              server.aof_rewrite_perc = atoi(argv[1]);
458              if (server.aof_rewrite_perc &lt; 0) {
459                  err = &quot;Invalid negative percentage for AOF auto rewrite&quot;;
460                  goto loaderr;
461              }
462          } else if (!strcasecmp(argv[0],&quot;auto-aof-rewrite-min-size&quot;) &amp;&amp;
463                     argc == 2)
464          {
465              server.aof_rewrite_min_size = memtoll(argv[1],NULL);
466          } else if (!strcasecmp(argv[0],&quot;aof-rewrite-incremental-fsync&quot;) &amp;&amp;
467                     argc == 2)
468          {
469              if ((server.aof_rewrite_incremental_fsync =
470                   yesnotoi(argv[1])) == -1) {
471                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
472              }
473          } else if (!strcasecmp(argv[0],&quot;rdb-save-incremental-fsync&quot;) &amp;&amp;
474                     argc == 2)
475          {
476              if ((server.rdb_save_incremental_fsync =
477                   yesnotoi(argv[1])) == -1) {
478                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
479              }
480          } else if (!strcasecmp(argv[0],&quot;aof-load-truncated&quot;) &amp;&amp; argc == 2) {
481              if ((server.aof_load_truncated = yesnotoi(argv[1])) == -1) {
482                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
483              }
484          } else if (!strcasecmp(argv[0],&quot;aof-use-rdb-preamble&quot;) &amp;&amp; argc == 2) {
485              if ((server.aof_use_rdb_preamble = yesnotoi(argv[1])) == -1) {
486                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
487              }
488          } else if (!strcasecmp(argv[0],&quot;requirepass&quot;) &amp;&amp; argc == 2) {
489              if (strlen(argv[1]) &gt; CONFIG_AUTHPASS_MAX_LEN) {
490                  err = &quot;Password is longer than CONFIG_AUTHPASS_MAX_LEN&quot;;
491                  goto loaderr;
492              }
493              server.requirepass = argv[1][0] ? zstrdup(argv[1]) : NULL;
494          } else if (!strcasecmp(argv[0],&quot;pidfile&quot;) &amp;&amp; argc == 2) {
495              zfree(server.pidfile);
496              server.pidfile = zstrdup(argv[1]);
497          } else if (!strcasecmp(argv[0],&quot;dbfilename&quot;) &amp;&amp; argc == 2) {
498              if (!pathIsBaseName(argv[1])) {
499                  err = &quot;dbfilename can&#x27;t be a path, just a filename&quot;;
500                  goto loaderr;
501              }
502              zfree(server.rdb_filename);
503              server.rdb_filename = zstrdup(argv[1]);
504          } else if (!strcasecmp(argv[0],&quot;active-defrag-threshold-lower&quot;) &amp;&amp; argc == 2) {
505              server.active_defrag_threshold_lower = atoi(argv[1]);
506              if (server.active_defrag_threshold_lower &lt; 0 ||
507                  server.active_defrag_threshold_lower &gt; 1000) {
508                  err = &quot;active-defrag-threshold-lower must be between 0 and 1000&quot;;
509                  goto loaderr;
510              }
511          } else if (!strcasecmp(argv[0],&quot;active-defrag-threshold-upper&quot;) &amp;&amp; argc == 2) {
512              server.active_defrag_threshold_upper = atoi(argv[1]);
513              if (server.active_defrag_threshold_upper &lt; 0 ||
514                  server.active_defrag_threshold_upper &gt; 1000) {
515                  err = &quot;active-defrag-threshold-upper must be between 0 and 1000&quot;;
516                  goto loaderr;
517              }
518          } else if (!strcasecmp(argv[0],&quot;active-defrag-ignore-bytes&quot;) &amp;&amp; argc == 2) {
519              server.active_defrag_ignore_bytes = memtoll(argv[1], NULL);
520              if (server.active_defrag_ignore_bytes &lt;= 0) {
521                  err = &quot;active-defrag-ignore-bytes must above 0&quot;;
522                  goto loaderr;
523              }
524          } else if (!strcasecmp(argv[0],&quot;active-defrag-cycle-min&quot;) &amp;&amp; argc == 2) {
525              server.active_defrag_cycle_min = atoi(argv[1]);
526              if (server.active_defrag_cycle_min &lt; 1 || server.active_defrag_cycle_min &gt; 99) {
527                  err = &quot;active-defrag-cycle-min must be between 1 and 99&quot;;
528                  goto loaderr;
529              }
530          } else if (!strcasecmp(argv[0],&quot;active-defrag-cycle-max&quot;) &amp;&amp; argc == 2) {
531              server.active_defrag_cycle_max = atoi(argv[1]);
532              if (server.active_defrag_cycle_max &lt; 1 || server.active_defrag_cycle_max &gt; 99) {
<span onclick='openModal()' class='match'>533                  err = &quot;active-defrag-cycle-max must be between 1 and 99&quot;;
534                  goto loaderr;
535              }
536          } else if (!strcasecmp(argv[0],&quot;active-defrag-max-scan-fields&quot;) &amp;&amp; argc == 2) {
537              server.active_defrag_max_scan_fields = strtoll(argv[1],NULL,10);
</span>538              if (server.active_defrag_max_scan_fields &lt; 1) {
539                  err = &quot;active-defrag-max-scan-fields must be positive&quot;;
540                  goto loaderr;
541              }
542          } else if (!strcasecmp(argv[0],&quot;hash-max-ziplist-entries&quot;) &amp;&amp; argc == 2) {
543              server.hash_max_ziplist_entries = memtoll(argv[1], NULL);
544          } else if (!strcasecmp(argv[0],&quot;hash-max-ziplist-value&quot;) &amp;&amp; argc == 2) {
545              server.hash_max_ziplist_value = memtoll(argv[1], NULL);
546          } else if (!strcasecmp(argv[0],&quot;stream-node-max-bytes&quot;) &amp;&amp; argc == 2) {
547              server.stream_node_max_bytes = memtoll(argv[1], NULL);
548          } else if (!strcasecmp(argv[0],&quot;stream-node-max-entries&quot;) &amp;&amp; argc == 2) {
549              server.stream_node_max_entries = atoi(argv[1]);
550          } else if (!strcasecmp(argv[0],&quot;list-max-ziplist-entries&quot;) &amp;&amp; argc == 2){
551          } else if (!strcasecmp(argv[0],&quot;list-max-ziplist-value&quot;) &amp;&amp; argc == 2) {
552          } else if (!strcasecmp(argv[0],&quot;list-max-ziplist-size&quot;) &amp;&amp; argc == 2) {
553              server.list_max_ziplist_size = atoi(argv[1]);
554          } else if (!strcasecmp(argv[0],&quot;list-compress-depth&quot;) &amp;&amp; argc == 2) {
555              server.list_compress_depth = atoi(argv[1]);
556          } else if (!strcasecmp(argv[0],&quot;set-max-intset-entries&quot;) &amp;&amp; argc == 2) {
557              server.set_max_intset_entries = memtoll(argv[1], NULL);
558          } else if (!strcasecmp(argv[0],&quot;zset-max-ziplist-entries&quot;) &amp;&amp; argc == 2) {
559              server.zset_max_ziplist_entries = memtoll(argv[1], NULL);
560          } else if (!strcasecmp(argv[0],&quot;zset-max-ziplist-value&quot;) &amp;&amp; argc == 2) {
561              server.zset_max_ziplist_value = memtoll(argv[1], NULL);
562          } else if (!strcasecmp(argv[0],&quot;hll-sparse-max-bytes&quot;) &amp;&amp; argc == 2) {
563              server.hll_sparse_max_bytes = memtoll(argv[1], NULL);
564          } else if (!strcasecmp(argv[0],&quot;rename-command&quot;) &amp;&amp; argc == 3) {
565              struct redisCommand *cmd = lookupCommand(argv[1]);
566              int retval;
567              if (!cmd) {
568                  err = &quot;No such command in rename-command&quot;;
569                  goto loaderr;
570              }
571              retval = dictDelete(server.commands, argv[1]);
572              serverAssert(retval == DICT_OK);
573              if (sdslen(argv[2]) != 0) {
574                  sds copy = sdsdup(argv[2]);
575                  retval = dictAdd(server.commands, copy, cmd);
576                  if (retval != DICT_OK) {
577                      sdsfree(copy);
578                      err = &quot;Target command name already exists&quot;; goto loaderr;
579                  }
580              }
581          } else if (!strcasecmp(argv[0],&quot;cluster-enabled&quot;) &amp;&amp; argc == 2) {
582              if ((server.cluster_enabled = yesnotoi(argv[1])) == -1) {
583                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
584              }
585          } else if (!strcasecmp(argv[0],&quot;cluster-config-file&quot;) &amp;&amp; argc == 2) {
586              zfree(server.cluster_configfile);
587              server.cluster_configfile = zstrdup(argv[1]);
588          } else if (!strcasecmp(argv[0],&quot;cluster-announce-ip&quot;) &amp;&amp; argc == 2) {
589              zfree(server.cluster_announce_ip);
590              server.cluster_announce_ip = zstrdup(argv[1]);
591          } else if (!strcasecmp(argv[0],&quot;cluster-announce-port&quot;) &amp;&amp; argc == 2) {
592              server.cluster_announce_port = atoi(argv[1]);
593              if (server.cluster_announce_port &lt; 0 ||
594                  server.cluster_announce_port &gt; 65535)
595              {
596                  err = &quot;Invalid port&quot;; goto loaderr;
597              }
598          } else if (!strcasecmp(argv[0],&quot;cluster-announce-bus-port&quot;) &amp;&amp;
599                     argc == 2)
600          {
601              server.cluster_announce_bus_port = atoi(argv[1]);
602              if (server.cluster_announce_bus_port &lt; 0 ||
603                  server.cluster_announce_bus_port &gt; 65535)
604              {
605                  err = &quot;Invalid port&quot;; goto loaderr;
606              }
607          } else if (!strcasecmp(argv[0],&quot;cluster-require-full-coverage&quot;) &amp;&amp;
608                      argc == 2)
609          {
610              if ((server.cluster_require_full_coverage = yesnotoi(argv[1])) == -1)
611              {
612                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
613              }
614          } else if (!strcasecmp(argv[0],&quot;cluster-node-timeout&quot;) &amp;&amp; argc == 2) {
615              server.cluster_node_timeout = strtoll(argv[1],NULL,10);
616              if (server.cluster_node_timeout &lt;= 0) {
617                  err = &quot;cluster node timeout must be 1 or greater&quot;; goto loaderr;
618              }
619          } else if (!strcasecmp(argv[0],&quot;cluster-migration-barrier&quot;)
620                     &amp;&amp; argc == 2)
621          {
622              server.cluster_migration_barrier = atoi(argv[1]);
623              if (server.cluster_migration_barrier &lt; 0) {
624                  err = &quot;cluster migration barrier must zero or positive&quot;;
625                  goto loaderr;
626              }
627          } else if ((!strcasecmp(argv[0],&quot;cluster-slave-validity-factor&quot;) ||
628                      !strcasecmp(argv[0],&quot;cluster-replica-validity-factor&quot;))
629                     &amp;&amp; argc == 2)
630          {
631              server.cluster_slave_validity_factor = atoi(argv[1]);
632              if (server.cluster_slave_validity_factor &lt; 0) {
633                  err = &quot;cluster replica validity factor must be zero or positive&quot;;
634                  goto loaderr;
635              }
636          } else if ((!strcasecmp(argv[0],&quot;cluster-slave-no-failover&quot;) ||
637                      !strcasecmp(argv[0],&quot;cluster-replica-no-failover&quot;)) &amp;&amp;
638                     argc == 2)
639          {
640              server.cluster_slave_no_failover = yesnotoi(argv[1]);
641              if (server.cluster_slave_no_failover == -1) {
642                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;;
643                  goto loaderr;
644              }
645          } else if (!strcasecmp(argv[0],&quot;lua-time-limit&quot;) &amp;&amp; argc == 2) {
646              server.lua_time_limit = strtoll(argv[1],NULL,10);
647          } else if (!strcasecmp(argv[0],&quot;lua-replicate-commands&quot;) &amp;&amp; argc == 2) {
648              server.lua_always_replicate_commands = yesnotoi(argv[1]);
649          } else if (!strcasecmp(argv[0],&quot;slowlog-log-slower-than&quot;) &amp;&amp;
650                     argc == 2)
651          {
652              server.slowlog_log_slower_than = strtoll(argv[1],NULL,10);
653          } else if (!strcasecmp(argv[0],&quot;latency-monitor-threshold&quot;) &amp;&amp;
654                     argc == 2)
655          {
656              server.latency_monitor_threshold = strtoll(argv[1],NULL,10);
657              if (server.latency_monitor_threshold &lt; 0) {
658                  err = &quot;The latency threshold can&#x27;t be negative&quot;;
659                  goto loaderr;
660              }
661          } else if (!strcasecmp(argv[0],&quot;slowlog-max-len&quot;) &amp;&amp; argc == 2) {
662              server.slowlog_max_len = (PORT_ULONG)(strtoll(argv[1],NULL,10));    WIN_PORT_FIX &amp;bsol;* cast (PORT_ULONG) */
663          } else if (!strcasecmp(argv[0],&quot;client-output-buffer-limit&quot;) &amp;&amp;
664                     argc == 5)
665          {
666              int class = getClientTypeByName(argv[1]);
667              PORT_ULONGLONG hard, soft;
668              int soft_seconds;
669              if (class == -1 || class == CLIENT_TYPE_MASTER) {
670                  err = &quot;Unrecognized client limit class: the user specified &quot;
671                  &quot;an invalid one, or &#x27;master&#x27; which has no buffer limits.&quot;;
672                  goto loaderr;
673              }
674              hard = memtoll(argv[2],NULL);
675              soft = memtoll(argv[3],NULL);
676              soft_seconds = atoi(argv[4]);
677              if (soft_seconds &lt; 0) {
678                  err = &quot;Negative number of seconds in soft limit is invalid&quot;;
679                  goto loaderr;
680              }
681              server.client_obuf_limits[class].hard_limit_bytes = hard;
682              server.client_obuf_limits[class].soft_limit_bytes = soft;
683              server.client_obuf_limits[class].soft_limit_seconds = soft_seconds;
684          } else if (!strcasecmp(argv[0],&quot;stop-writes-on-bgsave-error&quot;) &amp;&amp;
685                     argc == 2) {
686              if ((server.stop_writes_on_bgsave_err = yesnotoi(argv[1])) == -1) {
687                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
688              }
689          } else if ((!strcasecmp(argv[0],&quot;slave-priority&quot;) ||
690                      !strcasecmp(argv[0],&quot;replica-priority&quot;)) &amp;&amp; argc == 2)
691          {
692              server.slave_priority = atoi(argv[1]);
693          } else if ((!strcasecmp(argv[0],&quot;slave-announce-ip&quot;) ||
694                      !strcasecmp(argv[0],&quot;replica-announce-ip&quot;)) &amp;&amp; argc == 2)
695          {
696              zfree(server.slave_announce_ip);
697              server.slave_announce_ip = zstrdup(argv[1]);
698          } else if ((!strcasecmp(argv[0],&quot;slave-announce-port&quot;) ||
699                      !strcasecmp(argv[0],&quot;replica-announce-port&quot;)) &amp;&amp; argc == 2)
700          {
701              server.slave_announce_port = atoi(argv[1]);
702              if (server.slave_announce_port &lt; 0 ||
703                  server.slave_announce_port &gt; 65535)
704              {
705                  err = &quot;Invalid port&quot;; goto loaderr;
706              }
707          } else if ((!strcasecmp(argv[0],&quot;min-slaves-to-write&quot;) ||
708                      !strcasecmp(argv[0],&quot;min-replicas-to-write&quot;)) &amp;&amp; argc == 2)
709          {
710              server.repl_min_slaves_to_write = atoi(argv[1]);
711              if (server.repl_min_slaves_to_write &lt; 0) {
712                  err = &quot;Invalid value for min-replicas-to-write.&quot;; goto loaderr;
713              }
714          } else if ((!strcasecmp(argv[0],&quot;min-slaves-max-lag&quot;) ||
715                      !strcasecmp(argv[0],&quot;min-replicas-max-lag&quot;)) &amp;&amp; argc == 2)
716          {
717              server.repl_min_slaves_max_lag = atoi(argv[1]);
718              if (server.repl_min_slaves_max_lag &lt; 0) {
719                  err = &quot;Invalid value for min-replicas-max-lag.&quot;; goto loaderr;
720              }
721          } else if (!strcasecmp(argv[0],&quot;notify-keyspace-events&quot;) &amp;&amp; argc == 2) {
722              int flags = keyspaceEventsStringToFlags(argv[1]);
723              if (flags == -1) {
724                  err = &quot;Invalid event class character. Use &#x27;g$lshzxeA&#x27;.&quot;;
725                  goto loaderr;
726              }
727              server.notify_keyspace_events = flags;
728          } else if (!strcasecmp(argv[0],&quot;supervised&quot;) &amp;&amp; argc == 2) {
729              server.supervised_mode =
730                  configEnumGetValue(supervised_mode_enum,argv[1]);
731              if (server.supervised_mode == INT_MIN) {
732                  err = &quot;Invalid option for &#x27;supervised&#x27;. &quot;
733                      &quot;Allowed values: &#x27;upstart&#x27;, &#x27;systemd&#x27;, &#x27;auto&#x27;, or &#x27;no&#x27;&quot;;
734                  goto loaderr;
735              }
736          } else if (!strcasecmp(argv[0],&quot;loadmodule&quot;) &amp;&amp; argc &gt;= 2) {
737              queueLoadModule(argv[1],&amp;argv[2],argc-2);
738          } else if (!strcasecmp(argv[0],&quot;sentinel&quot;)) {
739              if (argc != 1) {
740                  if (!server.sentinel_mode) {
741                      err = &quot;sentinel directive while not in sentinel mode&quot;;
742                      goto loaderr;
743                  }
744                  err = sentinelHandleConfiguration(argv+1,argc-1);
745                  if (err) goto loaderr;
746              }
747  #ifdef _WIN32
748          } else if (!strcasecmp(argv[0], &quot;service-name&quot;)) {
749          } else if (!strcasecmp(argv[0], &quot;persistence-available&quot;)) {
750              if (strcasecmp(argv[1], &quot;no&quot;) == 0) {
751                  int retval;
752                  sds bgsave;
753                  sds bgrewriteaof;
754                  sds replconf;
755                  sds psync;
756                  sds sync;
757                  bgsave = sdsnew(&quot;bgsave&quot;);
758                  bgrewriteaof = sdsnew(&quot;bgrewriteaof&quot;);
759                  replconf = sdsnew(&quot;replconf&quot;);
760                  psync = sdsnew(&quot;psync&quot;);
761                  sync = sdsnew(&quot;sync&quot;);
762                  retval = dictDelete(server.commands, bgsave);
763                  serverAssert(retval == DICT_OK);
764                  retval = dictDelete(server.commands, bgrewriteaof);
765                  serverAssert(retval == DICT_OK);
766                  retval = dictDelete(server.commands, replconf);
767                  serverAssert(retval == DICT_OK);
768                  retval = dictDelete(server.commands, psync);
769                  serverAssert(retval == DICT_OK);
770                  retval = dictDelete(server.commands, sync);
771                  serverAssert(retval == DICT_OK);
772                  sdsfree(bgsave);
773                  sdsfree(bgrewriteaof);
774                  sdsfree(replconf);
775                  sdsfree(psync);
776                  sdsfree(sync);
777              }
778  #endif
779          } else {
780              err = &quot;Bad directive or wrong number of arguments&quot;; goto loaderr;
781          }
782          sdsfreesplitres(argv,argc);
783      }
784      if (server.cluster_enabled &amp;&amp; server.masterhost) {
785          linenum = slaveof_linenum;
786          i = linenum-1;
787          err = &quot;replicaof directive not allowed in cluster mode&quot;;
788          goto loaderr;
789      }
790      sdsfreesplitres(lines,totlines);
791      return;
792  loaderr:
793  #ifdef _WIN32
794      serverLog(LL_WARNING, &quot;\n*** FATAL CONFIG FILE ERROR ***\n&quot;);
795      serverLog(LL_WARNING, &quot;Reading the configuration file, at line %d\n&quot;, linenum);
796      serverLog(LL_WARNING, &quot;&gt;&gt;&gt; &#x27;%s&#x27;\n&quot;, lines[i]);
797      serverLog(LL_WARNING, &quot;%s\n&quot;, err);
798  #else
799      fprintf(stderr, &quot;\n*** FATAL CONFIG FILE ERROR ***\n&quot;);
800      fprintf(stderr, &quot;Reading the configuration file, at line %d\n&quot;, linenum);
801      fprintf(stderr, &quot;&gt;&gt;&gt; &#x27;%s&#x27;\n&quot;, lines[i]);
802      fprintf(stderr, &quot;%s\n&quot;, err);
803  #endif
804      exit(1);
805  }
806  void loadServerConfig(char *filename, char *options) {
807      sds config = sdsempty();
808      char buf[CONFIG_MAX_LINE+1];
809      if (filename) {
810          FILE *fp;
811          if (filename[0] == &#x27;-&#x27; &amp;&amp; filename[1] == &#x27;\0&#x27;) {
812              fp = stdin;
813          } else {
814              if ((fp = fopen(filename,IF_WIN32(&quot;rb&quot;,&quot;r&quot;))) == NULL) {
815                  serverLog(LL_WARNING,
816                      &quot;Fatal error, can&#x27;t open config file &#x27;%s&#x27;&quot;, filename);
817                  exit(1);
818              }
819          }
820          while(fgets(buf,CONFIG_MAX_LINE+1,fp) != NULL)
821              config = sdscat(config,buf);
822          if (fp != stdin) fclose(fp);
823      }
824      if (options) {
825          config = sdscat(config,&quot;\n&quot;);
826          config = sdscat(config,options);
827      }
828      loadServerConfigFromString(config);
829      sdsfree(config);
830  }
831  #define config_set_bool_field(_name,_var) \
832      } else if (!strcasecmp(c-&gt;argv[2]-&gt;ptr,_name)) { \
833          int yn = yesnotoi(o-&gt;ptr); \
834          if (yn == -1) goto badfmt; \
835          _var = yn;
836  #define config_set_numerical_field(_name,_var,min,max) \
837      } else if (!strcasecmp(c-&gt;argv[2]-&gt;ptr,_name)) { \
838          if (getLongLongFromObject(o,&amp;ll) == C_ERR) goto badfmt; \
839          if (min != LLONG_MIN &amp;&amp; ll &lt; min) goto badfmt; \
840          if (max != LLONG_MAX &amp;&amp; ll &gt; max) goto badfmt; \
841          _var = ll;
842  #define config_set_memory_field(_name,_var) \
843      } else if (!strcasecmp(c-&gt;argv[2]-&gt;ptr,_name)) { \
844          ll = memtoll(o-&gt;ptr,&amp;err); \
845          if (err || ll &lt; 0) goto badfmt; \
846          _var = ll;
847  #define config_set_enum_field(_name,_var,_enumvar) \
848      } else if (!strcasecmp(c-&gt;argv[2]-&gt;ptr,_name)) { \
849          int enumval = configEnumGetValue(_enumvar,o-&gt;ptr); \
850          if (enumval == INT_MIN) goto badfmt; \
851          _var = enumval;
852  #define config_set_special_field(_name) \
853      } else if (!strcasecmp(c-&gt;argv[2]-&gt;ptr,_name)) {
854  #define config_set_special_field_with_alias(_name1,_name2) \
855      } else if (!strcasecmp(c-&gt;argv[2]-&gt;ptr,_name1) || \
856                 !strcasecmp(c-&gt;argv[2]-&gt;ptr,_name2)) {
857  #define config_set_else } else
858  void configSetCommand(client *c) {
859      robj *o;
860      PORT_LONGLONG ll;
861      int err;
862      serverAssertWithInfo(c,c-&gt;argv[2],sdsEncodedObject(c-&gt;argv[2]));
863      serverAssertWithInfo(c,c-&gt;argv[3],sdsEncodedObject(c-&gt;argv[3]));
864      o = c-&gt;argv[3];
865      if (0) { &amp;bsol;* this starts the config_set macros else-if chain. */
866      config_set_special_field(&quot;dbfilename&quot;) {
867          if (!pathIsBaseName(o-&gt;ptr)) {
868              addReplyError(c, &quot;dbfilename can&#x27;t be a path, just a filename&quot;);
869              return;
870          }
871          zfree(server.rdb_filename);
872          server.rdb_filename = zstrdup(o-&gt;ptr);
873      } config_set_special_field(&quot;requirepass&quot;) {
874          if (sdslen(o-&gt;ptr) &gt; CONFIG_AUTHPASS_MAX_LEN) goto badfmt;
875          zfree(server.requirepass);
876          server.requirepass = ((char*)o-&gt;ptr)[0] ? zstrdup(o-&gt;ptr) : NULL;
877      } config_set_special_field(&quot;masterauth&quot;) {
878          zfree(server.masterauth);
879          server.masterauth = ((char*)o-&gt;ptr)[0] ? zstrdup(o-&gt;ptr) : NULL;
880      } config_set_special_field(&quot;cluster-announce-ip&quot;) {
881          zfree(server.cluster_announce_ip);
882          server.cluster_announce_ip = ((char*)o-&gt;ptr)[0] ? zstrdup(o-&gt;ptr) : NULL;
883      } config_set_special_field(&quot;maxclients&quot;) {
884          int orig_value = server.maxclients;
885          if (getLongLongFromObject(o,&amp;ll) == C_ERR || ll &lt; 1) goto badfmt;
886          server.maxclients = (PORT_ULONGLONG)ll;                                            WIN_PORT_FIX &amp;bsol;* cast (PORT_ULONGLONG) */
887          if (ll &gt; orig_value) {
888              adjustOpenFilesLimit();
889              if (server.maxclients != ll) {
890                  addReplyErrorFormat(c,&quot;The operating system is not able to handle the specified number of clients, try with %lld&quot;, server.maxclients);
891                  server.maxclients = orig_value;
892                  return;
893              }
894              if ((unsigned int) aeGetSetSize(server.el) &lt;
895                  server.maxclients + CONFIG_FDSET_INCR)
896              {
897                  if (aeResizeSetSize(server.el,
898                      server.maxclients + CONFIG_FDSET_INCR) == AE_ERR)
899                  {
900                      addReplyError(c,&quot;The event loop API used by Redis is not able to handle the specified number of clients&quot;);
901                      server.maxclients = orig_value;
902                      return;
903                  }
904              }
905          }
906      } config_set_special_field(&quot;appendonly&quot;) {
907          int enable = yesnotoi(o-&gt;ptr);
908          if (enable == -1) goto badfmt;
909          if (enable == 0 &amp;&amp; server.aof_state != AOF_OFF) {
910              stopAppendOnly();
911          } else if (enable &amp;&amp; server.aof_state == AOF_OFF) {
912              if (startAppendOnly() == C_ERR) {
913                  addReplyError(c,
914                      &quot;Unable to turn on AOF. Check server logs.&quot;);
915                  return;
916              }
917          }
918      } config_set_special_field(&quot;save&quot;) {
919          int vlen, j;
920          sds *v = sdssplitlen(o-&gt;ptr,sdslen(o-&gt;ptr),&quot; &quot;,1,&amp;vlen);
921          if (vlen &amp; 1) {
922              sdsfreesplitres(v,vlen);
923              goto badfmt;
924          }
925          for (j = 0; j &lt; vlen; j++) {
926              char *eptr;
927              PORT_LONG val;
928              val = strtoll(v[j], &amp;eptr, 10);
929              if (eptr[0] != &#x27;\0&#x27; ||
930                  ((j &amp; 1) == 0 &amp;&amp; val &lt; 1) ||
931                  ((j &amp; 1) == 1 &amp;&amp; val &lt; 0)) {
932                  sdsfreesplitres(v,vlen);
933                  goto badfmt;
934              }
935          }
936          resetServerSaveParams();
937          for (j = 0; j &lt; vlen; j += 2) {
938              time_t seconds;
939              int changes;
940              seconds = strtoll(v[j],NULL,10);
941              changes = strtoll(v[j+1],NULL,10);
942              appendServerSaveParams(seconds, changes);
943          }
944          sdsfreesplitres(v,vlen);
945      } config_set_special_field(&quot;dir&quot;) {
946          if (chdir((char*)o-&gt;ptr) == -1) {
947              addReplyErrorFormat(c,&quot;Changing directory: %s&quot;, IF_WIN32(wsa_strerror(errno), strerror(errno)));
948              return;
949          }
950      } config_set_special_field(&quot;client-output-buffer-limit&quot;) {
951          int vlen, j;
952          sds *v = sdssplitlen(o-&gt;ptr,sdslen(o-&gt;ptr),&quot; &quot;,1,&amp;vlen);
953          if (vlen % 4) {
954              sdsfreesplitres(v,vlen);
955              goto badfmt;
956          }
957          for (j = 0; j &lt; vlen; j++) {
958              PORT_LONG val;
959              if ((j % 4) == 0) {
960                  int class = getClientTypeByName(v[j]);
961                  if (class == -1 || class == CLIENT_TYPE_MASTER) {
962                      sdsfreesplitres(v,vlen);
963                      goto badfmt;
964                  }
965              } else {
966                  val = memtoll(v[j], &amp;err);
967                  if (err || val &lt; 0) {
968                      sdsfreesplitres(v,vlen);
969                      goto badfmt;
970                  }
971              }
972          }
973          for (j = 0; j &lt; vlen; j += 4) {
974              int class;
975              PORT_ULONGLONG hard, soft;
976              int soft_seconds;
977              class = getClientTypeByName(v[j]);
978              hard = memtoll(v[j+1],NULL);
979              soft = memtoll(v[j+2],NULL);
980              soft_seconds = strtoll(v[j+3],NULL,10);
981              server.client_obuf_limits[class].hard_limit_bytes = hard;
982              server.client_obuf_limits[class].soft_limit_bytes = soft;
983              server.client_obuf_limits[class].soft_limit_seconds = soft_seconds;
984          }
985          sdsfreesplitres(v,vlen);
986      } config_set_special_field(&quot;notify-keyspace-events&quot;) {
987          int flags = keyspaceEventsStringToFlags(o-&gt;ptr);
988          if (flags == -1) goto badfmt;
989          server.notify_keyspace_events = flags;
990      } config_set_special_field_with_alias(&quot;slave-announce-ip&quot;,
991                                            &quot;replica-announce-ip&quot;)
992      {
993          zfree(server.slave_announce_ip);
994          server.slave_announce_ip = ((char*)o-&gt;ptr)[0] ? zstrdup(o-&gt;ptr) : NULL;
995      } config_set_bool_field(
996        &quot;rdbcompression&quot;, server.rdb_compression) {
997      } config_set_bool_field(
998        &quot;repl-disable-tcp-nodelay&quot;,server.repl_disable_tcp_nodelay) {
999      } config_set_bool_field(
1000        &quot;repl-diskless-sync&quot;,server.repl_diskless_sync) {
1001      } config_set_bool_field(
1002        &quot;cluster-require-full-coverage&quot;,server.cluster_require_full_coverage) {
1003      } config_set_bool_field(
1004        &quot;cluster-slave-no-failover&quot;,server.cluster_slave_no_failover) {
1005      } config_set_bool_field(
1006        &quot;cluster-replica-no-failover&quot;,server.cluster_slave_no_failover) {
1007      } config_set_bool_field(
1008        &quot;aof-rewrite-incremental-fsync&quot;,server.aof_rewrite_incremental_fsync) {
1009      } config_set_bool_field(
1010        &quot;rdb-save-incremental-fsync&quot;,server.rdb_save_incremental_fsync) {
1011      } config_set_bool_field(
1012        &quot;aof-load-truncated&quot;,server.aof_load_truncated) {
1013      } config_set_bool_field(
1014        &quot;aof-use-rdb-preamble&quot;,server.aof_use_rdb_preamble) {
1015      } config_set_bool_field(
1016        &quot;slave-serve-stale-data&quot;,server.repl_serve_stale_data) {
1017      } config_set_bool_field(
1018        &quot;replica-serve-stale-data&quot;,server.repl_serve_stale_data) {
1019      } config_set_bool_field(
1020        &quot;slave-read-only&quot;,server.repl_slave_ro) {
1021      } config_set_bool_field(
1022        &quot;replica-read-only&quot;,server.repl_slave_ro) {
1023      } config_set_bool_field(
1024        &quot;slave-ignore-maxmemory&quot;,server.repl_slave_ignore_maxmemory) {
1025      } config_set_bool_field(
1026        &quot;replica-ignore-maxmemory&quot;,server.repl_slave_ignore_maxmemory) {
1027      } config_set_bool_field(
1028        &quot;activerehashing&quot;,server.activerehashing) {
1029      } config_set_bool_field(
1030        &quot;activedefrag&quot;,server.active_defrag_enabled) {
1031  #ifndef HAVE_DEFRAG
1032          if (server.active_defrag_enabled) {
1033              server.active_defrag_enabled = 0;
1034              addReplyError(c,
1035                  &quot;-DISABLED Active defragmentation cannot be enabled: it &quot;
1036                  &quot;requires a Redis server compiled with a modified Jemalloc &quot;
1037                  &quot;like the one shipped by default with the Redis source &quot;
1038                  &quot;distribution&quot;);
1039              return;
1040          }
1041  #endif
1042      } config_set_bool_field(
1043        &quot;protected-mode&quot;,server.protected_mode) {
1044      } config_set_bool_field(
1045        &quot;stop-writes-on-bgsave-error&quot;,server.stop_writes_on_bgsave_err) {
1046      } config_set_bool_field(
1047        &quot;lazyfree-lazy-eviction&quot;,server.lazyfree_lazy_eviction) {
1048      } config_set_bool_field(
1049        &quot;lazyfree-lazy-expire&quot;,server.lazyfree_lazy_expire) {
1050      } config_set_bool_field(
1051        &quot;lazyfree-lazy-server-del&quot;,server.lazyfree_lazy_server_del) {
1052      } config_set_bool_field(
1053        &quot;slave-lazy-flush&quot;,server.repl_slave_lazy_flush) {
1054      } config_set_bool_field(
1055        &quot;replica-lazy-flush&quot;,server.repl_slave_lazy_flush) {
1056      } config_set_bool_field(
1057        &quot;no-appendfsync-on-rewrite&quot;,server.aof_no_fsync_on_rewrite) {
1058      } config_set_bool_field(
1059        &quot;dynamic-hz&quot;,server.dynamic_hz) {
1060      } config_set_numerical_field(
1061        &quot;tcp-keepalive&quot;,server.tcpkeepalive,0,INT_MAX) {
1062      } config_set_numerical_field(
1063        &quot;maxmemory-samples&quot;,server.maxmemory_samples,1,INT_MAX) {
1064      } config_set_numerical_field(
1065        &quot;lfu-log-factor&quot;,server.lfu_log_factor,0,INT_MAX) {
1066      } config_set_numerical_field(
1067        &quot;lfu-decay-time&quot;,server.lfu_decay_time,0,INT_MAX) {
1068      } config_set_numerical_field(
1069        &quot;timeout&quot;,server.maxidletime,0,INT_MAX) {
1070      } config_set_numerical_field(
1071        &quot;active-defrag-threshold-lower&quot;,server.active_defrag_threshold_lower,0,1000) {
1072      } config_set_numerical_field(
1073        &quot;active-defrag-threshold-upper&quot;,server.active_defrag_threshold_upper,0,1000) {
1074      } config_set_memory_field(
1075        &quot;active-defrag-ignore-bytes&quot;,server.active_defrag_ignore_bytes) {
1076      } config_set_numerical_field(
1077        &quot;active-defrag-cycle-min&quot;,server.active_defrag_cycle_min,1,99) {
1078      } config_set_numerical_field(
1079        &quot;active-defrag-cycle-max&quot;,server.active_defrag_cycle_max,1,99) {
1080      } config_set_numerical_field(
1081        &quot;active-defrag-max-scan-fields&quot;,server.active_defrag_max_scan_fields,1,LONG_MAX) {
1082      } config_set_numerical_field(
1083        &quot;auto-aof-rewrite-percentage&quot;,server.aof_rewrite_perc,0,INT_MAX){
1084      } config_set_numerical_field(
1085        &quot;hash-max-ziplist-entries&quot;,server.hash_max_ziplist_entries,0,LONG_MAX) {
1086      } config_set_numerical_field(
1087        &quot;hash-max-ziplist-value&quot;,server.hash_max_ziplist_value,0,LONG_MAX) {
1088      } config_set_numerical_field(
1089        &quot;stream-node-max-bytes&quot;,server.stream_node_max_bytes,0,LONG_MAX) {
1090      } config_set_numerical_field(
1091        &quot;stream-node-max-entries&quot;,server.stream_node_max_entries,0,LLONG_MAX) {
1092      } config_set_numerical_field(
1093        &quot;list-max-ziplist-size&quot;,server.list_max_ziplist_size,INT_MIN,INT_MAX) {
1094      } config_set_numerical_field(
1095        &quot;list-compress-depth&quot;,server.list_compress_depth,0,INT_MAX) {
1096      } config_set_numerical_field(
1097        &quot;set-max-intset-entries&quot;,server.set_max_intset_entries,0,LONG_MAX) {
1098      } config_set_numerical_field(
1099        &quot;zset-max-ziplist-entries&quot;,server.zset_max_ziplist_entries,0,LONG_MAX) {
1100      } config_set_numerical_field(
1101        &quot;zset-max-ziplist-value&quot;,server.zset_max_ziplist_value,0,LONG_MAX) {
1102      } config_set_numerical_field(
1103        &quot;hll-sparse-max-bytes&quot;,server.hll_sparse_max_bytes,0,LONG_MAX) {
1104      } config_set_numerical_field(
1105        &quot;lua-time-limit&quot;,server.lua_time_limit,0,LONG_MAX) {
1106      } config_set_numerical_field(
1107        &quot;slowlog-log-slower-than&quot;,server.slowlog_log_slower_than,-1,LLONG_MAX) {
1108      } config_set_numerical_field(
1109        &quot;slowlog-max-len&quot;,ll,0,LONG_MAX) {
1110          server.slowlog_max_len = (PORT_ULONG)ll;
1111      } config_set_numerical_field(
1112        &quot;latency-monitor-threshold&quot;,server.latency_monitor_threshold,0,LLONG_MAX){
1113      } config_set_numerical_field(
1114        &quot;repl-ping-slave-period&quot;,server.repl_ping_slave_period,1,INT_MAX) {
1115      } config_set_numerical_field(
1116        &quot;repl-ping-replica-period&quot;,server.repl_ping_slave_period,1,INT_MAX) {
1117      } config_set_numerical_field(
1118        &quot;repl-timeout&quot;,server.repl_timeout,1,INT_MAX) {
1119      } config_set_numerical_field(
1120        &quot;repl-backlog-ttl&quot;,server.repl_backlog_time_limit,0,LONG_MAX) {
1121      } config_set_numerical_field(
1122        &quot;repl-diskless-sync-delay&quot;,server.repl_diskless_sync_delay,0,INT_MAX) {
1123      } config_set_numerical_field(
1124        &quot;slave-priority&quot;,server.slave_priority,0,INT_MAX) {
1125      } config_set_numerical_field(
1126        &quot;replica-priority&quot;,server.slave_priority,0,INT_MAX) {
1127      } config_set_numerical_field(
1128        &quot;slave-announce-port&quot;,server.slave_announce_port,0,65535) {
1129      } config_set_numerical_field(
1130        &quot;replica-announce-port&quot;,server.slave_announce_port,0,65535) {
1131      } config_set_numerical_field(
1132        &quot;min-slaves-to-write&quot;,server.repl_min_slaves_to_write,0,INT_MAX) {
1133          refreshGoodSlavesCount();
1134      } config_set_numerical_field(
1135        &quot;min-replicas-to-write&quot;,server.repl_min_slaves_to_write,0,INT_MAX) {
1136          refreshGoodSlavesCount();
1137      } config_set_numerical_field(
1138        &quot;min-slaves-max-lag&quot;,server.repl_min_slaves_max_lag,0,INT_MAX) {
1139          refreshGoodSlavesCount();
1140      } config_set_numerical_field(
1141        &quot;min-replicas-max-lag&quot;,server.repl_min_slaves_max_lag,0,INT_MAX) {
1142          refreshGoodSlavesCount();
1143      } config_set_numerical_field(
1144        &quot;cluster-node-timeout&quot;,server.cluster_node_timeout,0,LLONG_MAX) {
1145      } config_set_numerical_field(
1146        &quot;cluster-announce-port&quot;,server.cluster_announce_port,0,65535) {
1147      } config_set_numerical_field(
1148        &quot;cluster-announce-bus-port&quot;,server.cluster_announce_bus_port,0,65535) {
1149      } config_set_numerical_field(
1150        &quot;cluster-migration-barrier&quot;,server.cluster_migration_barrier,0,INT_MAX){
1151      } config_set_numerical_field(
1152        &quot;cluster-slave-validity-factor&quot;,server.cluster_slave_validity_factor,0,INT_MAX) {
1153      } config_set_numerical_field(
1154        &quot;cluster-replica-validity-factor&quot;,server.cluster_slave_validity_factor,0,INT_MAX) {
1155      } config_set_numerical_field(
1156        &quot;hz&quot;,server.config_hz,0,INT_MAX) {
1157          if (server.config_hz &lt; CONFIG_MIN_HZ) server.config_hz = CONFIG_MIN_HZ;
1158          if (server.config_hz &gt; CONFIG_MAX_HZ) server.config_hz = CONFIG_MAX_HZ;
1159      } config_set_numerical_field(
1160        &quot;watchdog-period&quot;,ll,0,INT_MAX) {
1161          if (ll)
1162              enableWatchdog(ll);
1163          else
1164              disableWatchdog();
1165      } config_set_memory_field(&quot;maxmemory&quot;,server.maxmemory) {
1166          if (server.maxmemory) {
1167              if (server.maxmemory &lt; zmalloc_used_memory()) {
1168                  serverLog(LL_WARNING,&quot;WARNING: the new maxmemory value set via CONFIG SET is smaller than the current memory usage. This will result in key eviction and/or the inability to accept new write commands depending on the maxmemory-policy.&quot;);
1169              }
1170              freeMemoryIfNeededAndSafe();
1171          }
1172      } config_set_memory_field(
1173        &quot;proto-max-bulk-len&quot;,server.proto_max_bulk_len) {
1174      } config_set_memory_field(
1175        &quot;client-query-buffer-limit&quot;,server.client_max_querybuf_len) {
1176      } config_set_memory_field(&quot;repl-backlog-size&quot;,ll) {
1177          resizeReplicationBacklog(ll);
1178      } config_set_memory_field(&quot;auto-aof-rewrite-min-size&quot;,ll) {
1179          server.aof_rewrite_min_size = ll;
1180      } config_set_enum_field(
1181        &quot;loglevel&quot;,server.verbosity,loglevel_enum) {
1182  #ifdef _WIN32
1183          setLogVerbosityLevel(server.verbosity);
1184  #endif
1185      } config_set_enum_field(
1186        &quot;maxmemory-policy&quot;,server.maxmemory_policy,maxmemory_policy_enum) {
1187      } config_set_enum_field(
1188        &quot;appendfsync&quot;,server.aof_fsync,aof_fsync_enum) {
1189      } config_set_else {
1190          addReplyErrorFormat(c,&quot;Unsupported CONFIG parameter: %s&quot;,
1191              (char*)c-&gt;argv[2]-&gt;ptr);
1192          return;
1193      }
1194      addReply(c,shared.ok);
1195      return;
1196  badfmt: &amp;bsol;* Bad format errors */
1197      addReplyErrorFormat(c,&quot;Invalid argument &#x27;%s&#x27; for CONFIG SET &#x27;%s&#x27;&quot;,
1198              (char*)o-&gt;ptr,
1199              (char*)c-&gt;argv[2]-&gt;ptr);
1200  }
1201  #define config_get_string_field(_name,_var) do { \
1202      if (stringmatch(pattern,_name,1)) { \
1203          addReplyBulkCString(c,_name); \
1204          addReplyBulkCString(c,_var ? _var : &quot;&quot;); \
1205          matches++; \
1206      } \
1207  } while(0);
1208  #define config_get_bool_field(_name,_var) do { \
1209      if (stringmatch(pattern,_name,1)) { \
1210          addReplyBulkCString(c,_name); \
1211          addReplyBulkCString(c,_var ? &quot;yes&quot; : &quot;no&quot;); \
1212          matches++; \
1213      } \
1214  } while(0);
1215  #define config_get_numerical_field(_name,_var) do { \
1216      if (stringmatch(pattern,_name,1)) { \
1217          ll2string(buf,sizeof(buf),_var); \
1218          addReplyBulkCString(c,_name); \
1219          addReplyBulkCString(c,buf); \
1220          matches++; \
1221      } \
1222  } while(0);
1223  #define config_get_enum_field(_name,_var,_enumvar) do { \
1224      if (stringmatch(pattern,_name,1)) { \
1225          addReplyBulkCString(c,_name); \
1226          addReplyBulkCString(c,configEnumGetNameOrUnknown(_enumvar,_var)); \
1227          matches++; \
1228      } \
1229  } while(0);
1230  void configGetCommand(client *c) {
1231      robj *o = c-&gt;argv[2];
1232      void *replylen = addDeferredMultiBulkLength(c);
1233      char *pattern = o-&gt;ptr;
1234      char buf[128];
1235      int matches = 0;
1236      serverAssertWithInfo(c,o,sdsEncodedObject(o));
1237      config_get_string_field(&quot;dbfilename&quot;,server.rdb_filename);
1238      config_get_string_field(&quot;requirepass&quot;,server.requirepass);
1239      config_get_string_field(&quot;masterauth&quot;,server.masterauth);
1240      config_get_string_field(&quot;cluster-announce-ip&quot;,server.cluster_announce_ip);
1241      config_get_string_field(&quot;unixsocket&quot;,server.unixsocket);
1242      config_get_string_field(&quot;logfile&quot;,server.logfile);
1243      config_get_string_field(&quot;pidfile&quot;,server.pidfile);
1244      config_get_string_field(&quot;slave-announce-ip&quot;,server.slave_announce_ip);
1245      config_get_string_field(&quot;replica-announce-ip&quot;,server.slave_announce_ip);
1246      config_get_numerical_field(&quot;maxmemory&quot;,server.maxmemory);
1247      config_get_numerical_field(&quot;proto-max-bulk-len&quot;,server.proto_max_bulk_len);
1248      config_get_numerical_field(&quot;client-query-buffer-limit&quot;,server.client_max_querybuf_len);
1249      config_get_numerical_field(&quot;maxmemory-samples&quot;,server.maxmemory_samples);
1250      config_get_numerical_field(&quot;lfu-log-factor&quot;,server.lfu_log_factor);
1251      config_get_numerical_field(&quot;lfu-decay-time&quot;,server.lfu_decay_time);
1252      config_get_numerical_field(&quot;timeout&quot;,server.maxidletime);
1253      config_get_numerical_field(&quot;active-defrag-threshold-lower&quot;,server.active_defrag_threshold_lower);
1254      config_get_numerical_field(&quot;active-defrag-threshold-upper&quot;,server.active_defrag_threshold_upper);
1255      config_get_numerical_field(&quot;active-defrag-ignore-bytes&quot;,server.active_defrag_ignore_bytes);
1256      config_get_numerical_field(&quot;active-defrag-cycle-min&quot;,server.active_defrag_cycle_min);
1257      config_get_numerical_field(&quot;active-defrag-cycle-max&quot;,server.active_defrag_cycle_max);
1258      config_get_numerical_field(&quot;active-defrag-max-scan-fields&quot;,server.active_defrag_max_scan_fields);
1259      config_get_numerical_field(&quot;auto-aof-rewrite-percentage&quot;,
1260              server.aof_rewrite_perc);
1261      config_get_numerical_field(&quot;auto-aof-rewrite-min-size&quot;,
1262              server.aof_rewrite_min_size);
1263      config_get_numerical_field(&quot;hash-max-ziplist-entries&quot;,
1264              server.hash_max_ziplist_entries);
1265      config_get_numerical_field(&quot;hash-max-ziplist-value&quot;,
1266              server.hash_max_ziplist_value);
1267      config_get_numerical_field(&quot;stream-node-max-bytes&quot;,
1268              server.stream_node_max_bytes);
1269      config_get_numerical_field(&quot;stream-node-max-entries&quot;,
1270              server.stream_node_max_entries);
1271      config_get_numerical_field(&quot;list-max-ziplist-size&quot;,
1272              server.list_max_ziplist_size);
1273      config_get_numerical_field(&quot;list-compress-depth&quot;,
1274              server.list_compress_depth);
1275      config_get_numerical_field(&quot;set-max-intset-entries&quot;,
1276              server.set_max_intset_entries);
1277      config_get_numerical_field(&quot;zset-max-ziplist-entries&quot;,
1278              server.zset_max_ziplist_entries);
1279      config_get_numerical_field(&quot;zset-max-ziplist-value&quot;,
1280              server.zset_max_ziplist_value);
1281      config_get_numerical_field(&quot;hll-sparse-max-bytes&quot;,
1282              server.hll_sparse_max_bytes);
1283      config_get_numerical_field(&quot;lua-time-limit&quot;,server.lua_time_limit);
1284      config_get_numerical_field(&quot;slowlog-log-slower-than&quot;,
1285              server.slowlog_log_slower_than);
1286      config_get_numerical_field(&quot;latency-monitor-threshold&quot;,
1287              server.latency_monitor_threshold);
1288      config_get_numerical_field(&quot;slowlog-max-len&quot;,
1289              server.slowlog_max_len);
1290      config_get_numerical_field(&quot;port&quot;,server.port);
1291      config_get_numerical_field(&quot;cluster-announce-port&quot;,server.cluster_announce_port);
1292      config_get_numerical_field(&quot;cluster-announce-bus-port&quot;,server.cluster_announce_bus_port);
1293      config_get_numerical_field(&quot;tcp-backlog&quot;,server.tcp_backlog);
1294      config_get_numerical_field(&quot;databases&quot;,server.dbnum);
1295      config_get_numerical_field(&quot;repl-ping-slave-period&quot;,server.repl_ping_slave_period);
1296      config_get_numerical_field(&quot;repl-ping-replica-period&quot;,server.repl_ping_slave_period);
1297      config_get_numerical_field(&quot;repl-timeout&quot;,server.repl_timeout);
1298      config_get_numerical_field(&quot;repl-backlog-size&quot;,server.repl_backlog_size);
1299      config_get_numerical_field(&quot;repl-backlog-ttl&quot;,server.repl_backlog_time_limit);
1300      config_get_numerical_field(&quot;maxclients&quot;,server.maxclients);
1301      config_get_numerical_field(&quot;watchdog-period&quot;,server.watchdog_period);
1302      config_get_numerical_field(&quot;slave-priority&quot;,server.slave_priority);
1303      config_get_numerical_field(&quot;replica-priority&quot;,server.slave_priority);
1304      config_get_numerical_field(&quot;slave-announce-port&quot;,server.slave_announce_port);
1305      config_get_numerical_field(&quot;replica-announce-port&quot;,server.slave_announce_port);
1306      config_get_numerical_field(&quot;min-slaves-to-write&quot;,server.repl_min_slaves_to_write);
1307      config_get_numerical_field(&quot;min-replicas-to-write&quot;,server.repl_min_slaves_to_write);
1308      config_get_numerical_field(&quot;min-slaves-max-lag&quot;,server.repl_min_slaves_max_lag);
1309      config_get_numerical_field(&quot;min-replicas-max-lag&quot;,server.repl_min_slaves_max_lag);
1310      config_get_numerical_field(&quot;hz&quot;,server.config_hz);
1311      config_get_numerical_field(&quot;cluster-node-timeout&quot;,server.cluster_node_timeout);
1312      config_get_numerical_field(&quot;cluster-migration-barrier&quot;,server.cluster_migration_barrier);
1313      config_get_numerical_field(&quot;cluster-slave-validity-factor&quot;,server.cluster_slave_validity_factor);
1314      config_get_numerical_field(&quot;cluster-replica-validity-factor&quot;,server.cluster_slave_validity_factor);
1315      config_get_numerical_field(&quot;repl-diskless-sync-delay&quot;,server.repl_diskless_sync_delay);
1316      config_get_numerical_field(&quot;tcp-keepalive&quot;,server.tcpkeepalive);
1317      config_get_bool_field(&quot;cluster-require-full-coverage&quot;,
1318              server.cluster_require_full_coverage);
1319      config_get_bool_field(&quot;cluster-slave-no-failover&quot;,
1320              server.cluster_slave_no_failover);
1321      config_get_bool_field(&quot;cluster-replica-no-failover&quot;,
1322              server.cluster_slave_no_failover);
1323      config_get_bool_field(&quot;no-appendfsync-on-rewrite&quot;,
1324              server.aof_no_fsync_on_rewrite);
1325      config_get_bool_field(&quot;slave-serve-stale-data&quot;,
1326              server.repl_serve_stale_data);
1327      config_get_bool_field(&quot;replica-serve-stale-data&quot;,
1328              server.repl_serve_stale_data);
1329      config_get_bool_field(&quot;slave-read-only&quot;,
1330              server.repl_slave_ro);
1331      config_get_bool_field(&quot;replica-read-only&quot;,
1332              server.repl_slave_ro);
1333      config_get_bool_field(&quot;slave-ignore-maxmemory&quot;,
1334              server.repl_slave_ignore_maxmemory);
1335      config_get_bool_field(&quot;replica-ignore-maxmemory&quot;,
1336              server.repl_slave_ignore_maxmemory);
1337      config_get_bool_field(&quot;stop-writes-on-bgsave-error&quot;,
1338              server.stop_writes_on_bgsave_err);
1339      config_get_bool_field(&quot;daemonize&quot;, server.daemonize);
1340      config_get_bool_field(&quot;rdbcompression&quot;, server.rdb_compression);
1341      config_get_bool_field(&quot;rdbchecksum&quot;, server.rdb_checksum);
1342      config_get_bool_field(&quot;activerehashing&quot;, server.activerehashing);
1343      config_get_bool_field(&quot;activedefrag&quot;, server.active_defrag_enabled);
1344      config_get_bool_field(&quot;protected-mode&quot;, server.protected_mode);
1345      config_get_bool_field(&quot;repl-disable-tcp-nodelay&quot;,
1346              server.repl_disable_tcp_nodelay);
1347      config_get_bool_field(&quot;repl-diskless-sync&quot;,
1348              server.repl_diskless_sync);
1349      config_get_bool_field(&quot;aof-rewrite-incremental-fsync&quot;,
1350              server.aof_rewrite_incremental_fsync);
1351      config_get_bool_field(&quot;rdb-save-incremental-fsync&quot;,
1352              server.rdb_save_incremental_fsync);
1353      config_get_bool_field(&quot;aof-load-truncated&quot;,
1354              server.aof_load_truncated);
1355      config_get_bool_field(&quot;aof-use-rdb-preamble&quot;,
1356              server.aof_use_rdb_preamble);
1357      config_get_bool_field(&quot;lazyfree-lazy-eviction&quot;,
1358              server.lazyfree_lazy_eviction);
1359      config_get_bool_field(&quot;lazyfree-lazy-expire&quot;,
1360              server.lazyfree_lazy_expire);
1361      config_get_bool_field(&quot;lazyfree-lazy-server-del&quot;,
1362              server.lazyfree_lazy_server_del);
1363      config_get_bool_field(&quot;slave-lazy-flush&quot;,
1364              server.repl_slave_lazy_flush);
1365      config_get_bool_field(&quot;replica-lazy-flush&quot;,
1366              server.repl_slave_lazy_flush);
1367      config_get_bool_field(&quot;dynamic-hz&quot;,
1368              server.dynamic_hz);
1369      config_get_enum_field(&quot;maxmemory-policy&quot;,
1370              server.maxmemory_policy,maxmemory_policy_enum);
1371      config_get_enum_field(&quot;loglevel&quot;,
1372              server.verbosity,loglevel_enum);
1373      config_get_enum_field(&quot;supervised&quot;,
1374              server.supervised_mode,supervised_mode_enum);
1375      config_get_enum_field(&quot;appendfsync&quot;,
1376              server.aof_fsync,aof_fsync_enum);
1377  #ifndef _WIN32
1378      config_get_enum_field(&quot;syslog-facility&quot;,
1379              server.syslog_facility,syslog_facility_enum);
1380  #endif
1381      if (stringmatch(pattern,&quot;appendonly&quot;,1)) {
1382          addReplyBulkCString(c,&quot;appendonly&quot;);
1383          addReplyBulkCString(c,server.aof_state == AOF_OFF ? &quot;no&quot; : &quot;yes&quot;);
1384          matches++;
1385      }
1386      if (stringmatch(pattern,&quot;dir&quot;,1)) {
1387          char buf[1024];
1388          if (getcwd(buf,sizeof(buf)) == NULL)
1389              buf[0] = &#x27;\0&#x27;;
1390          addReplyBulkCString(c,&quot;dir&quot;);
1391          addReplyBulkCString(c,buf);
1392          matches++;
1393      }
1394      if (stringmatch(pattern,&quot;save&quot;,1)) {
1395          sds buf = sdsempty();
1396          int j;
1397          for (j = 0; j &lt; server.saveparamslen; j++) {
1398              buf = sdscatprintf(buf,&quot;%jd %d&quot;,
1399                      (intmax_t)server.saveparams[j].seconds,
1400                      server.saveparams[j].changes);
1401              if (j != server.saveparamslen-1)
1402                  buf = sdscatlen(buf,&quot; &quot;,1);
1403          }
1404          addReplyBulkCString(c,&quot;save&quot;);
1405          addReplyBulkCString(c,buf);
1406          sdsfree(buf);
1407          matches++;
1408      }
1409      if (stringmatch(pattern,&quot;client-output-buffer-limit&quot;,1)) {
1410          sds buf = sdsempty();
1411          int j;
1412          for (j = 0; j &lt; CLIENT_TYPE_OBUF_COUNT; j++) {
1413              buf = sdscatprintf(buf,&quot;%s %llu %llu %Id&quot;,                                WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
1414                      getClientTypeName(j),
1415                      server.client_obuf_limits[j].hard_limit_bytes,
1416                      server.client_obuf_limits[j].soft_limit_bytes,
1417                      (PORT_LONG) server.client_obuf_limits[j].soft_limit_seconds);
1418              if (j != CLIENT_TYPE_OBUF_COUNT-1)
1419                  buf = sdscatlen(buf,&quot; &quot;,1);
1420          }
1421          addReplyBulkCString(c,&quot;client-output-buffer-limit&quot;);
1422          addReplyBulkCString(c,buf);
1423          sdsfree(buf);
1424          matches++;
1425      }
1426      if (stringmatch(pattern,&quot;unixsocketperm&quot;,1)) {
1427          char buf[32];
1428          snprintf(buf,sizeof(buf),&quot;%o&quot;,server.unixsocketperm);
1429          addReplyBulkCString(c,&quot;unixsocketperm&quot;);
1430          addReplyBulkCString(c,buf);
1431          matches++;
1432      }
1433      if (stringmatch(pattern,&quot;slaveof&quot;,1) ||
1434          stringmatch(pattern,&quot;replicaof&quot;,1))
1435      {
1436          char *optname = stringmatch(pattern,&quot;slaveof&quot;,1) ?
1437                          &quot;slaveof&quot; : &quot;replicaof&quot;;
1438          char buf[256];
1439          addReplyBulkCString(c,optname);
1440          if (server.masterhost)
1441              snprintf(buf,sizeof(buf),&quot;%s %d&quot;,
1442                  server.masterhost, server.masterport);
1443          else
1444              buf[0] = &#x27;\0&#x27;;
1445          addReplyBulkCString(c,buf);
1446          matches++;
1447      }
1448      if (stringmatch(pattern,&quot;notify-keyspace-events&quot;,1)) {
1449          robj *flagsobj = createObject(OBJ_STRING,
1450              keyspaceEventsFlagsToString(server.notify_keyspace_events));
1451          addReplyBulkCString(c,&quot;notify-keyspace-events&quot;);
1452          addReplyBulk(c,flagsobj);
1453          decrRefCount(flagsobj);
1454          matches++;
1455      }
1456      if (stringmatch(pattern,&quot;bind&quot;,1)) {
1457          sds aux = sdsjoin(server.bindaddr,server.bindaddr_count,&quot; &quot;);
1458          addReplyBulkCString(c,&quot;bind&quot;);
1459          addReplyBulkCString(c,aux);
1460          sdsfree(aux);
1461          matches++;
1462      }
1463      setDeferredMultiBulkLength(c,replylen,(PORT_LONG)matches*2);  WIN_PORT_FIX &amp;bsol;* cat (PORT_LONG) */
1464  }
1465  #define REDIS_CONFIG_REWRITE_SIGNATURE &quot;# Generated by CONFIG REWRITE&quot;
1466  uint64_t dictSdsCaseHash(const void *key);
1467  int dictSdsKeyCaseCompare(void *privdata, const void *key1, const void *key2);
1468  void dictSdsDestructor(void *privdata, void *val);
1469  void dictListDestructor(void *privdata, void *val);
1470  void rewriteConfigSentinelOption(struct rewriteConfigState *state);
1471  dictType optionToLineDictType = {
1472      dictSdsCaseHash,            &amp;bsol;* hash function */
1473      NULL,                       &amp;bsol;* key dup */
1474      NULL,                       &amp;bsol;* val dup */
1475      dictSdsKeyCaseCompare,      &amp;bsol;* key compare */
1476      dictSdsDestructor,          &amp;bsol;* key destructor */
1477      dictListDestructor          &amp;bsol;* val destructor */
1478  };
1479  dictType optionSetDictType = {
1480      dictSdsCaseHash,            &amp;bsol;* hash function */
1481      NULL,                       &amp;bsol;* key dup */
1482      NULL,                       &amp;bsol;* val dup */
1483      dictSdsKeyCaseCompare,      &amp;bsol;* key compare */
1484      dictSdsDestructor,          &amp;bsol;* key destructor */
1485      NULL                        &amp;bsol;* val destructor */
1486  };
1487  struct rewriteConfigState {
1488      dict *option_to_line; &amp;bsol;* Option -&gt; list of config file lines map */
1489      dict *rewritten;      &amp;bsol;* Dictionary of already processed options */
1490      int numlines;         &amp;bsol;* Number of lines in current config */
1491      sds *lines;           &amp;bsol;* Current lines as an array of sds strings */
1492      int has_tail;         &amp;bsol;* True if we already added directives that were
1493                               not present in the original config file. */
1494  };
1495  void rewriteConfigAppendLine(struct rewriteConfigState *state, sds line) {
1496      state-&gt;lines = zrealloc(state-&gt;lines, sizeof(char*) * ((PORT_ULONG)state-&gt;numlines+1));  WIN_PORT_FIX &amp;bsol;* cat (PORT_ULONG) */
1497      state-&gt;lines[state-&gt;numlines++] = line;
1498  }
1499  void rewriteConfigAddLineNumberToOption(struct rewriteConfigState *state, sds option, int linenum) {
1500      list *l = dictFetchValue(state-&gt;option_to_line,option);
1501      if (l == NULL) {
1502          l = listCreate();
1503          dictAdd(state-&gt;option_to_line,sdsdup(option),l);
1504      }
1505      listAddNodeTail(l,(void*)(PORT_LONG)linenum);
1506  }
1507  void rewriteConfigMarkAsProcessed(struct rewriteConfigState *state, const char *option) {
1508      sds opt = sdsnew(option);
1509      if (dictAdd(state-&gt;rewritten,opt,NULL) != DICT_OK) sdsfree(opt);
1510  }
1511  struct rewriteConfigState *rewriteConfigReadOldFile(char *path) {
1512      FILE *fp = fopen(path,&quot;r&quot;);
1513      if (fp == NULL &amp;&amp; errno != ENOENT) return NULL;
1514      char buf[CONFIG_MAX_LINE+1];
1515      int linenum = -1;
1516      struct rewriteConfigState *state = zmalloc(sizeof(*state));
1517      state-&gt;option_to_line = dictCreate(&amp;optionToLineDictType,NULL);
1518      state-&gt;rewritten = dictCreate(&amp;optionSetDictType,NULL);
1519      state-&gt;numlines = 0;
1520      state-&gt;lines = NULL;
1521      state-&gt;has_tail = 0;
1522      if (fp == NULL) return state;
1523      while(fgets(buf,CONFIG_MAX_LINE+1,fp) != NULL) {
1524          int argc;
1525          sds *argv;
1526          sds line = sdstrim(sdsnew(buf),&quot;\r\n\t &quot;);
1527          linenum++; &amp;bsol;* Zero based, so we init at -1 */
1528          if (line[0] == &#x27;#&#x27; || line[0] == &#x27;\0&#x27;) {
1529              if (!state-&gt;has_tail &amp;&amp; !strcmp(line,REDIS_CONFIG_REWRITE_SIGNATURE))
1530                  state-&gt;has_tail = 1;
1531              rewriteConfigAppendLine(state,line);
1532              continue;
1533          }
1534          argv = sdssplitargs(line,&amp;argc);
1535          if (argv == NULL) {
1536              sds aux = sdsnew(&quot;# ??? &quot;);
1537              aux = sdscatsds(aux,line);
1538              sdsfree(line);
1539              rewriteConfigAppendLine(state,aux);
1540              continue;
1541          }
1542          sdstolower(argv[0]); &amp;bsol;* We only want lowercase config directives. */
1543          rewriteConfigAppendLine(state,line);
1544          char *p = strstr(argv[0],&quot;slave&quot;);
1545          if (p) {
1546              sds alt = sdsempty();
1547              alt = sdscatlen(alt,argv[0],p-argv[0]);;
1548              alt = sdscatlen(alt,&quot;replica&quot;,7);
1549              alt = sdscatlen(alt,p+5,strlen(p+5));
1550              sdsfree(argv[0]);
1551              argv[0] = alt;
1552          }
1553          rewriteConfigAddLineNumberToOption(state,argv[0],linenum);
1554          sdsfreesplitres(argv,argc);
1555      }
1556      fclose(fp);
1557      return state;
1558  }
1559  void rewriteConfigRewriteLine(struct rewriteConfigState *state, const char *option, sds line, int force) {
1560      sds o = sdsnew(option);
1561      list *l = dictFetchValue(state-&gt;option_to_line,o);
1562      rewriteConfigMarkAsProcessed(state,option);
1563      if (!l &amp;&amp; !force) {
1564          sdsfree(line);
1565          sdsfree(o);
1566          return;
1567      }
1568      if (l) {
1569          listNode *ln = listFirst(l);
1570          int linenum = (int)((PORT_LONG) ln-&gt;value);                             WIN_PORT_FIX &amp;bsol;* cast (int) */
1571          listDelNode(l,ln);
1572          if (listLength(l) == 0) dictDelete(state-&gt;option_to_line,o);
1573          sdsfree(state-&gt;lines[linenum]);
1574          state-&gt;lines[linenum] = line;
1575      } else {
1576          if (!state-&gt;has_tail) {
1577              rewriteConfigAppendLine(state,
1578                  sdsnew(REDIS_CONFIG_REWRITE_SIGNATURE));
1579              state-&gt;has_tail = 1;
1580          }
1581          rewriteConfigAppendLine(state,line);
1582      }
1583      sdsfree(o);
1584  }
1585  int rewriteConfigFormatMemory(char *buf, size_t len, PORT_LONGLONG bytes) {
1586      int gb = 1024*1024*1024;
1587      int mb = 1024*1024;
1588      int kb = 1024;
1589      if (bytes &amp;&amp; (bytes % gb) == 0) {
1590          return snprintf(buf,len,&quot;%lldgb&quot;,bytes/gb);
1591      } else if (bytes &amp;&amp; (bytes % mb) == 0) {
1592          return snprintf(buf,len,&quot;%lldmb&quot;,bytes/mb);
1593      } else if (bytes &amp;&amp; (bytes % kb) == 0) {
1594          return snprintf(buf,len,&quot;%lldkb&quot;,bytes/kb);
1595      } else {
1596          return snprintf(buf,len,&quot;%lld&quot;,bytes);
1597      }
1598  }
1599  void rewriteConfigBytesOption(struct rewriteConfigState *state, char *option, PORT_LONGLONG value, PORT_LONGLONG defvalue) {
1600      char buf[64];
1601      int force = value != defvalue;
1602      sds line;
1603      rewriteConfigFormatMemory(buf,sizeof(buf),value);
1604      line = sdscatprintf(sdsempty(),&quot;%s %s&quot;,option,buf);
1605      rewriteConfigRewriteLine(state,option,line,force);
1606  }
1607  void rewriteConfigYesNoOption(struct rewriteConfigState *state, char *option, int value, int defvalue) {
1608      int force = value != defvalue;
1609      sds line = sdscatprintf(sdsempty(),&quot;%s %s&quot;,option,
1610          value ? &quot;yes&quot; : &quot;no&quot;);
1611      rewriteConfigRewriteLine(state,option,line,force);
1612  }
1613  void rewriteConfigStringOption(struct rewriteConfigState *state, char *option, char *value, char *defvalue) {
1614      int force = 1;
1615      sds line;
1616      if (value == NULL) {
1617          rewriteConfigMarkAsProcessed(state,option);
1618          return;
1619      }
1620      if (defvalue &amp;&amp; strcmp(value,defvalue) == 0) force = 0;
1621      line = sdsnew(option);
1622      line = sdscatlen(line, &quot; &quot;, 1);
1623      line = sdscatrepr(line, value, strlen(value));
1624      rewriteConfigRewriteLine(state,option,line,force);
1625  }
1626  void rewriteConfigNumericalOption(struct rewriteConfigState *state, char *option, PORT_LONGLONG value, PORT_LONGLONG defvalue) {
1627      int force = value != defvalue;
1628      sds line = sdscatprintf(sdsempty(),&quot;%s %lld&quot;,option,value);
1629      rewriteConfigRewriteLine(state,option,line,force);
1630  }
1631  void rewriteConfigOctalOption(struct rewriteConfigState *state, char *option, int value, int defvalue) {
1632      int force = value != defvalue;
1633      sds line = sdscatprintf(sdsempty(),&quot;%s %o&quot;,option,value);
1634      rewriteConfigRewriteLine(state,option,line,force);
1635  }
1636  void rewriteConfigEnumOption(struct rewriteConfigState *state, char *option, int value, configEnum *ce, int defval) {
1637      sds line;
1638      const char *name = configEnumGetNameOrUnknown(ce,value);
1639      int force = value != defval;
1640      line = sdscatprintf(sdsempty(),&quot;%s %s&quot;,option,name);
1641      rewriteConfigRewriteLine(state,option,line,force);
1642  }
1643  #ifndef _WIN32
1644  void rewriteConfigSyslogfacilityOption(struct rewriteConfigState *state) {
1645      int value = server.syslog_facility;
1646      int force = value != LOG_LOCAL0;
1647      const char *name = NULL, *option = &quot;syslog-facility&quot;;
1648      sds line;
1649      name = configEnumGetNameOrUnknown(syslog_facility_enum,value);
1650      line = sdscatprintf(sdsempty(),&quot;%s %s&quot;,option,name);
1651      rewriteConfigRewriteLine(state,option,line,force);
1652  }
1653  #endif
1654  void rewriteConfigSaveOption(struct rewriteConfigState *state) {
1655      int j;
1656      sds line;
1657      for (j = 0; j &lt; server.saveparamslen; j++) {
1658          line = sdscatprintf(sdsempty(),&quot;save %Id %d&quot;,                                      WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
1659              (PORT_LONG) server.saveparams[j].seconds, server.saveparams[j].changes);
1660          rewriteConfigRewriteLine(state,&quot;save&quot;,line,1);
1661      }
1662      rewriteConfigMarkAsProcessed(state,&quot;save&quot;);
1663  }
1664  void rewriteConfigDirOption(struct rewriteConfigState *state) {
1665      char cwd[1024];
1666      if (getcwd(cwd,sizeof(cwd)) == NULL) {
1667          rewriteConfigMarkAsProcessed(state,&quot;dir&quot;);
1668          return; &amp;bsol;* no rewrite on error. */
1669      }
1670      rewriteConfigStringOption(state,&quot;dir&quot;,cwd,NULL);
1671  }
1672  void rewriteConfigSlaveofOption(struct rewriteConfigState *state, char *option) {
1673      sds line;
1674      if (server.cluster_enabled || server.masterhost == NULL) {
1675          rewriteConfigMarkAsProcessed(state,option);
1676          return;
1677      }
1678      line = sdscatprintf(sdsempty(),&quot;%s %s %d&quot;, option,
1679          server.masterhost, server.masterport);
1680      rewriteConfigRewriteLine(state,option,line,1);
1681  }
1682  void rewriteConfigNotifykeyspaceeventsOption(struct rewriteConfigState *state) {
1683      int force = server.notify_keyspace_events != 0;
1684      char *option = &quot;notify-keyspace-events&quot;;
1685      sds line, flags;
1686      flags = keyspaceEventsFlagsToString(server.notify_keyspace_events);
1687      line = sdsnew(option);
1688      line = sdscatlen(line, &quot; &quot;, 1);
1689      line = sdscatrepr(line, flags, sdslen(flags));
1690      sdsfree(flags);
1691      rewriteConfigRewriteLine(state,option,line,force);
1692  }
1693  void rewriteConfigClientoutputbufferlimitOption(struct rewriteConfigState *state) {
1694      int j;
1695      char *option = &quot;client-output-buffer-limit&quot;;
1696      for (j = 0; j &lt; CLIENT_TYPE_OBUF_COUNT; j++) {
1697          int force = (server.client_obuf_limits[j].hard_limit_bytes !=
1698                      clientBufferLimitsDefaults[j].hard_limit_bytes) ||
1699                      (server.client_obuf_limits[j].soft_limit_bytes !=
1700                      clientBufferLimitsDefaults[j].soft_limit_bytes) ||
1701                      (server.client_obuf_limits[j].soft_limit_seconds !=
1702                      clientBufferLimitsDefaults[j].soft_limit_seconds);
1703          sds line;
1704          char hard[64], soft[64];
1705          rewriteConfigFormatMemory(hard,sizeof(hard),
1706                  server.client_obuf_limits[j].hard_limit_bytes);
1707          rewriteConfigFormatMemory(soft,sizeof(soft),
1708                  server.client_obuf_limits[j].soft_limit_bytes);
1709          char *typename = getClientTypeName(j);
1710          if (!strcmp(typename,&quot;slave&quot;)) typename = &quot;replica&quot;;
1711          line = sdscatprintf(sdsempty(),&quot;%s %s %s %s %Id&quot;, WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
1712                  option, typename, hard, soft,
1713                  (PORT_LONG) server.client_obuf_limits[j].soft_limit_seconds);
1714          rewriteConfigRewriteLine(state,option,line,force);
1715      }
1716  }
1717  void rewriteConfigBindOption(struct rewriteConfigState *state) {
1718      int force = 1;
1719      sds line, addresses;
1720      char *option = &quot;bind&quot;;
1721      if (server.bindaddr_count == 0) {
1722          rewriteConfigMarkAsProcessed(state,option);
1723          return;
1724      }
1725      addresses = sdsjoin(server.bindaddr,server.bindaddr_count,&quot; &quot;);
1726      line = sdsnew(option);
1727      line = sdscatlen(line, &quot; &quot;, 1);
1728      line = sdscatsds(line, addresses);
1729      sdsfree(addresses);
1730      rewriteConfigRewriteLine(state,option,line,force);
1731  }
1732  sds rewriteConfigGetContentFromState(struct rewriteConfigState *state) {
1733      sds content = sdsempty();
1734      int j, was_empty = 0;
1735      for (j = 0; j &lt; state-&gt;numlines; j++) {
1736          if (sdslen(state-&gt;lines[j]) == 0) {
1737              if (was_empty) continue;
1738              was_empty = 1;
1739          } else {
1740              was_empty = 0;
1741          }
1742          content = sdscatsds(content,state-&gt;lines[j]);
1743          content = sdscatlen(content,&quot;\n&quot;,1);
1744      }
1745      return content;
1746  }
1747  void rewriteConfigReleaseState(struct rewriteConfigState *state) {
1748      sdsfreesplitres(state-&gt;lines,state-&gt;numlines);
1749      dictRelease(state-&gt;option_to_line);
1750      dictRelease(state-&gt;rewritten);
1751      zfree(state);
1752  }
1753  void rewriteConfigRemoveOrphaned(struct rewriteConfigState *state) {
1754      dictIterator *di = dictGetIterator(state-&gt;option_to_line);
1755      dictEntry *de;
1756      while((de = dictNext(di)) != NULL) {
1757          list *l = dictGetVal(de);
1758          sds option = dictGetKey(de);
1759          if (dictFind(state-&gt;rewritten,option) == NULL) {
1760              serverLog(LL_DEBUG,&quot;Not rewritten option: %s&quot;, option);
1761              continue;
1762          }
1763          while(listLength(l)) {
1764              listNode *ln = listFirst(l);
1765              int linenum = (int)((PORT_LONG) ln-&gt;value);                         WIN_PORT_FIX &amp;bsol;* cast (int) */
1766              sdsfree(state-&gt;lines[linenum]);
1767              state-&gt;lines[linenum] = sdsempty();
1768              listDelNode(l,ln);
1769          }
1770      }
1771      dictReleaseIterator(di);
1772  }
1773  int rewriteConfigOverwriteFile(char *configfile, sds content) {
1774      int retval = 0;
1775      int fd = open(configfile,O_RDWR|O_CREAT,0644);
1776      int content_size = (int)sdslen(content), padding = 0;                       WIN_PORT_FIX &amp;bsol;* cast (int) */
1777      struct IF_WIN32(_stat64,stat) sb;                                           
1778      sds content_padded;
1779      if (fd == -1) return -1; &amp;bsol;* errno set by open(). */
1780      if (fstat(fd,&amp;sb) == -1) {
1781          close(fd);
1782          return -1; &amp;bsol;* errno set by fstat(). */
1783      }
1784      content_padded = sdsdup(content);
1785      if (content_size &lt; sb.st_size) {
1786          padding = (int)(sb.st_size - content_size);                             WIN_PORT_FIX &amp;bsol;* cast (int) */
1787          content_padded = sdsgrowzero(content_padded,sb.st_size);
1788          content_padded[content_size] = &#x27;\n&#x27;;
1789          memset(content_padded+content_size+1,&#x27;#&#x27;,(size_t)padding-1);            WIN_PORT_FIX &amp;bsol;* cat (size_t) */
1790      }
1791      if (write(fd,content_padded,strlen(content_padded)) == -1) {
1792          retval = -1;
1793          goto cleanup;
1794      }
1795      if (padding) {
1796          if (ftruncate(fd,content_size) == -1) {
1797          }
1798      }
1799  cleanup:
1800      sdsfree(content_padded);
1801      close(fd);
1802      return retval;
1803  }
1804  int rewriteConfig(char *path) {
1805      struct rewriteConfigState *state;
1806      sds newcontent;
1807      int retval;
1808      if ((state = rewriteConfigReadOldFile(path)) == NULL) return -1;
1809      rewriteConfigYesNoOption(state,&quot;daemonize&quot;,server.daemonize,0);
1810      rewriteConfigStringOption(state,&quot;pidfile&quot;,server.pidfile,CONFIG_DEFAULT_PID_FILE);
1811      rewriteConfigNumericalOption(state,&quot;port&quot;,server.port,CONFIG_DEFAULT_SERVER_PORT);
1812      rewriteConfigNumericalOption(state,&quot;cluster-announce-port&quot;,server.cluster_announce_port,CONFIG_DEFAULT_CLUSTER_ANNOUNCE_PORT);
1813      rewriteConfigNumericalOption(state,&quot;cluster-announce-bus-port&quot;,server.cluster_announce_bus_port,CONFIG_DEFAULT_CLUSTER_ANNOUNCE_BUS_PORT);
1814      rewriteConfigNumericalOption(state,&quot;tcp-backlog&quot;,server.tcp_backlog,CONFIG_DEFAULT_TCP_BACKLOG);
1815      rewriteConfigBindOption(state);
1816      rewriteConfigStringOption(state,&quot;unixsocket&quot;,server.unixsocket,NULL);
1817      rewriteConfigOctalOption(state,&quot;unixsocketperm&quot;,server.unixsocketperm,CONFIG_DEFAULT_UNIX_SOCKET_PERM);
1818      rewriteConfigNumericalOption(state,&quot;timeout&quot;,server.maxidletime,CONFIG_DEFAULT_CLIENT_TIMEOUT);
1819      rewriteConfigNumericalOption(state,&quot;tcp-keepalive&quot;,server.tcpkeepalive,CONFIG_DEFAULT_TCP_KEEPALIVE);
1820      rewriteConfigNumericalOption(state,&quot;replica-announce-port&quot;,server.slave_announce_port,CONFIG_DEFAULT_SLAVE_ANNOUNCE_PORT);
1821      rewriteConfigEnumOption(state,&quot;loglevel&quot;,server.verbosity,loglevel_enum,CONFIG_DEFAULT_VERBOSITY);
1822      rewriteConfigStringOption(state,&quot;logfile&quot;,server.logfile,CONFIG_DEFAULT_LOGFILE);
1823      rewriteConfigYesNoOption(state,&quot;syslog-enabled&quot;,server.syslog_enabled,CONFIG_DEFAULT_SYSLOG_ENABLED);
1824      rewriteConfigStringOption(state,&quot;syslog-ident&quot;,server.syslog_ident,CONFIG_DEFAULT_SYSLOG_IDENT);
1825  #ifndef _WIN32
1826      rewriteConfigSyslogfacilityOption(state);
1827  #endif
1828      rewriteConfigSaveOption(state);
1829      rewriteConfigNumericalOption(state,&quot;databases&quot;,server.dbnum,CONFIG_DEFAULT_DBNUM);
1830      rewriteConfigYesNoOption(state,&quot;stop-writes-on-bgsave-error&quot;,server.stop_writes_on_bgsave_err,CONFIG_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR);
1831      rewriteConfigYesNoOption(state,&quot;rdbcompression&quot;,server.rdb_compression,CONFIG_DEFAULT_RDB_COMPRESSION);
1832      rewriteConfigYesNoOption(state,&quot;rdbchecksum&quot;,server.rdb_checksum,CONFIG_DEFAULT_RDB_CHECKSUM);
1833      rewriteConfigStringOption(state,&quot;dbfilename&quot;,server.rdb_filename,CONFIG_DEFAULT_RDB_FILENAME);
1834      rewriteConfigDirOption(state);
1835      rewriteConfigSlaveofOption(state,&quot;replicaof&quot;);
1836      rewriteConfigStringOption(state,&quot;replica-announce-ip&quot;,server.slave_announce_ip,CONFIG_DEFAULT_SLAVE_ANNOUNCE_IP);
1837      rewriteConfigStringOption(state,&quot;masterauth&quot;,server.masterauth,NULL);
1838      rewriteConfigStringOption(state,&quot;cluster-announce-ip&quot;,server.cluster_announce_ip,NULL);
1839      rewriteConfigYesNoOption(state,&quot;replica-serve-stale-data&quot;,server.repl_serve_stale_data,CONFIG_DEFAULT_SLAVE_SERVE_STALE_DATA);
1840      rewriteConfigYesNoOption(state,&quot;replica-read-only&quot;,server.repl_slave_ro,CONFIG_DEFAULT_SLAVE_READ_ONLY);
1841      rewriteConfigYesNoOption(state,&quot;replica-ignore-maxmemory&quot;,server.repl_slave_ignore_maxmemory,CONFIG_DEFAULT_SLAVE_IGNORE_MAXMEMORY);
1842      rewriteConfigNumericalOption(state,&quot;repl-ping-replica-period&quot;,server.repl_ping_slave_period,CONFIG_DEFAULT_REPL_PING_SLAVE_PERIOD);
1843      rewriteConfigNumericalOption(state,&quot;repl-timeout&quot;,server.repl_timeout,CONFIG_DEFAULT_REPL_TIMEOUT);
1844      rewriteConfigBytesOption(state,&quot;repl-backlog-size&quot;,server.repl_backlog_size,CONFIG_DEFAULT_REPL_BACKLOG_SIZE);
1845      rewriteConfigBytesOption(state,&quot;repl-backlog-ttl&quot;,server.repl_backlog_time_limit,CONFIG_DEFAULT_REPL_BACKLOG_TIME_LIMIT);
1846      rewriteConfigYesNoOption(state,&quot;repl-disable-tcp-nodelay&quot;,server.repl_disable_tcp_nodelay,CONFIG_DEFAULT_REPL_DISABLE_TCP_NODELAY);
1847      rewriteConfigYesNoOption(state,&quot;repl-diskless-sync&quot;,server.repl_diskless_sync,CONFIG_DEFAULT_REPL_DISKLESS_SYNC);
1848      rewriteConfigNumericalOption(state,&quot;repl-diskless-sync-delay&quot;,server.repl_diskless_sync_delay,CONFIG_DEFAULT_REPL_DISKLESS_SYNC_DELAY);
1849      rewriteConfigNumericalOption(state,&quot;replica-priority&quot;,server.slave_priority,CONFIG_DEFAULT_SLAVE_PRIORITY);
1850      rewriteConfigNumericalOption(state,&quot;min-replicas-to-write&quot;,server.repl_min_slaves_to_write,CONFIG_DEFAULT_MIN_SLAVES_TO_WRITE);
1851      rewriteConfigNumericalOption(state,&quot;min-replicas-max-lag&quot;,server.repl_min_slaves_max_lag,CONFIG_DEFAULT_MIN_SLAVES_MAX_LAG);
1852      rewriteConfigStringOption(state,&quot;requirepass&quot;,server.requirepass,NULL);
1853      rewriteConfigNumericalOption(state,&quot;maxclients&quot;,server.maxclients,CONFIG_DEFAULT_MAX_CLIENTS);
1854      rewriteConfigBytesOption(state,&quot;maxmemory&quot;,server.maxmemory,CONFIG_DEFAULT_MAXMEMORY);
1855      rewriteConfigBytesOption(state,&quot;proto-max-bulk-len&quot;,server.proto_max_bulk_len,CONFIG_DEFAULT_PROTO_MAX_BULK_LEN);
1856      rewriteConfigBytesOption(state,&quot;client-query-buffer-limit&quot;,server.client_max_querybuf_len,PROTO_MAX_QUERYBUF_LEN);
1857      rewriteConfigEnumOption(state,&quot;maxmemory-policy&quot;,server.maxmemory_policy,maxmemory_policy_enum,CONFIG_DEFAULT_MAXMEMORY_POLICY);
1858      rewriteConfigNumericalOption(state,&quot;maxmemory-samples&quot;,server.maxmemory_samples,CONFIG_DEFAULT_MAXMEMORY_SAMPLES);
1859      rewriteConfigNumericalOption(state,&quot;lfu-log-factor&quot;,server.lfu_log_factor,CONFIG_DEFAULT_LFU_LOG_FACTOR);
1860      rewriteConfigNumericalOption(state,&quot;lfu-decay-time&quot;,server.lfu_decay_time,CONFIG_DEFAULT_LFU_DECAY_TIME);
1861      rewriteConfigNumericalOption(state,&quot;active-defrag-threshold-lower&quot;,server.active_defrag_threshold_lower,CONFIG_DEFAULT_DEFRAG_THRESHOLD_LOWER);
1862      rewriteConfigNumericalOption(state,&quot;active-defrag-threshold-upper&quot;,server.active_defrag_threshold_upper,CONFIG_DEFAULT_DEFRAG_THRESHOLD_UPPER);
1863      rewriteConfigBytesOption(state,&quot;active-defrag-ignore-bytes&quot;,server.active_defrag_ignore_bytes,CONFIG_DEFAULT_DEFRAG_IGNORE_BYTES);
1864      rewriteConfigNumericalOption(state,&quot;active-defrag-cycle-min&quot;,server.active_defrag_cycle_min,CONFIG_DEFAULT_DEFRAG_CYCLE_MIN);
1865      rewriteConfigNumericalOption(state,&quot;active-defrag-cycle-max&quot;,server.active_defrag_cycle_max,CONFIG_DEFAULT_DEFRAG_CYCLE_MAX);
1866      rewriteConfigNumericalOption(state,&quot;active-defrag-max-scan-fields&quot;,server.active_defrag_max_scan_fields,CONFIG_DEFAULT_DEFRAG_MAX_SCAN_FIELDS);
1867      rewriteConfigYesNoOption(state,&quot;appendonly&quot;,server.aof_state != AOF_OFF,0);
1868      rewriteConfigStringOption(state,&quot;appendfilename&quot;,server.aof_filename,CONFIG_DEFAULT_AOF_FILENAME);
1869      rewriteConfigEnumOption(state,&quot;appendfsync&quot;,server.aof_fsync,aof_fsync_enum,CONFIG_DEFAULT_AOF_FSYNC);
1870      rewriteConfigYesNoOption(state,&quot;no-appendfsync-on-rewrite&quot;,server.aof_no_fsync_on_rewrite,CONFIG_DEFAULT_AOF_NO_FSYNC_ON_REWRITE);
1871      rewriteConfigNumericalOption(state,&quot;auto-aof-rewrite-percentage&quot;,server.aof_rewrite_perc,AOF_REWRITE_PERC);
1872      rewriteConfigBytesOption(state,&quot;auto-aof-rewrite-min-size&quot;,server.aof_rewrite_min_size,AOF_REWRITE_MIN_SIZE);
1873      rewriteConfigNumericalOption(state,&quot;lua-time-limit&quot;,server.lua_time_limit,LUA_SCRIPT_TIME_LIMIT);
1874      rewriteConfigYesNoOption(state,&quot;cluster-enabled&quot;,server.cluster_enabled,0);
1875      rewriteConfigStringOption(state,&quot;cluster-config-file&quot;,server.cluster_configfile,CONFIG_DEFAULT_CLUSTER_CONFIG_FILE);
1876      rewriteConfigYesNoOption(state,&quot;cluster-require-full-coverage&quot;,server.cluster_require_full_coverage,CLUSTER_DEFAULT_REQUIRE_FULL_COVERAGE);
1877      rewriteConfigYesNoOption(state,&quot;cluster-replica-no-failover&quot;,server.cluster_slave_no_failover,CLUSTER_DEFAULT_SLAVE_NO_FAILOVER);
1878      rewriteConfigNumericalOption(state,&quot;cluster-node-timeout&quot;,server.cluster_node_timeout,CLUSTER_DEFAULT_NODE_TIMEOUT);
1879      rewriteConfigNumericalOption(state,&quot;cluster-migration-barrier&quot;,server.cluster_migration_barrier,CLUSTER_DEFAULT_MIGRATION_BARRIER);
1880      rewriteConfigNumericalOption(state,&quot;cluster-replica-validity-factor&quot;,server.cluster_slave_validity_factor,CLUSTER_DEFAULT_SLAVE_VALIDITY);
1881      rewriteConfigNumericalOption(state,&quot;slowlog-log-slower-than&quot;,server.slowlog_log_slower_than,CONFIG_DEFAULT_SLOWLOG_LOG_SLOWER_THAN);
1882      rewriteConfigNumericalOption(state,&quot;latency-monitor-threshold&quot;,server.latency_monitor_threshold,CONFIG_DEFAULT_LATENCY_MONITOR_THRESHOLD);
1883      rewriteConfigNumericalOption(state,&quot;slowlog-max-len&quot;,server.slowlog_max_len,CONFIG_DEFAULT_SLOWLOG_MAX_LEN);
1884      rewriteConfigNotifykeyspaceeventsOption(state);
1885      rewriteConfigNumericalOption(state,&quot;hash-max-ziplist-entries&quot;,server.hash_max_ziplist_entries,OBJ_HASH_MAX_ZIPLIST_ENTRIES);
1886      rewriteConfigNumericalOption(state,&quot;hash-max-ziplist-value&quot;,server.hash_max_ziplist_value,OBJ_HASH_MAX_ZIPLIST_VALUE);
1887      rewriteConfigNumericalOption(state,&quot;stream-node-max-bytes&quot;,server.stream_node_max_bytes,OBJ_STREAM_NODE_MAX_BYTES);
1888      rewriteConfigNumericalOption(state,&quot;stream-node-max-entries&quot;,server.stream_node_max_entries,OBJ_STREAM_NODE_MAX_ENTRIES);
1889      rewriteConfigNumericalOption(state,&quot;list-max-ziplist-size&quot;,server.list_max_ziplist_size,OBJ_LIST_MAX_ZIPLIST_SIZE);
1890      rewriteConfigNumericalOption(state,&quot;list-compress-depth&quot;,server.list_compress_depth,OBJ_LIST_COMPRESS_DEPTH);
1891      rewriteConfigNumericalOption(state,&quot;set-max-intset-entries&quot;,server.set_max_intset_entries,OBJ_SET_MAX_INTSET_ENTRIES);
1892      rewriteConfigNumericalOption(state,&quot;zset-max-ziplist-entries&quot;,server.zset_max_ziplist_entries,OBJ_ZSET_MAX_ZIPLIST_ENTRIES);
1893      rewriteConfigNumericalOption(state,&quot;zset-max-ziplist-value&quot;,server.zset_max_ziplist_value,OBJ_ZSET_MAX_ZIPLIST_VALUE);
1894      rewriteConfigNumericalOption(state,&quot;hll-sparse-max-bytes&quot;,server.hll_sparse_max_bytes,CONFIG_DEFAULT_HLL_SPARSE_MAX_BYTES);
1895      rewriteConfigYesNoOption(state,&quot;activerehashing&quot;,server.activerehashing,CONFIG_DEFAULT_ACTIVE_REHASHING);
1896      rewriteConfigYesNoOption(state,&quot;activedefrag&quot;,server.active_defrag_enabled,CONFIG_DEFAULT_ACTIVE_DEFRAG);
1897      rewriteConfigYesNoOption(state,&quot;protected-mode&quot;,server.protected_mode,CONFIG_DEFAULT_PROTECTED_MODE);
1898      rewriteConfigClientoutputbufferlimitOption(state);
1899      rewriteConfigNumericalOption(state,&quot;hz&quot;,server.config_hz,CONFIG_DEFAULT_HZ);
1900      rewriteConfigYesNoOption(state,&quot;aof-rewrite-incremental-fsync&quot;,server.aof_rewrite_incremental_fsync,CONFIG_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC);
1901      rewriteConfigYesNoOption(state,&quot;rdb-save-incremental-fsync&quot;,server.rdb_save_incremental_fsync,CONFIG_DEFAULT_RDB_SAVE_INCREMENTAL_FSYNC);
1902      rewriteConfigYesNoOption(state,&quot;aof-load-truncated&quot;,server.aof_load_truncated,CONFIG_DEFAULT_AOF_LOAD_TRUNCATED);
1903      rewriteConfigYesNoOption(state,&quot;aof-use-rdb-preamble&quot;,server.aof_use_rdb_preamble,CONFIG_DEFAULT_AOF_USE_RDB_PREAMBLE);
1904      rewriteConfigEnumOption(state,&quot;supervised&quot;,server.supervised_mode,supervised_mode_enum,SUPERVISED_NONE);
1905      rewriteConfigYesNoOption(state,&quot;lazyfree-lazy-eviction&quot;,server.lazyfree_lazy_eviction,CONFIG_DEFAULT_LAZYFREE_LAZY_EVICTION);
1906      rewriteConfigYesNoOption(state,&quot;lazyfree-lazy-expire&quot;,server.lazyfree_lazy_expire,CONFIG_DEFAULT_LAZYFREE_LAZY_EXPIRE);
1907      rewriteConfigYesNoOption(state,&quot;lazyfree-lazy-server-del&quot;,server.lazyfree_lazy_server_del,CONFIG_DEFAULT_LAZYFREE_LAZY_SERVER_DEL);
1908      rewriteConfigYesNoOption(state,&quot;replica-lazy-flush&quot;,server.repl_slave_lazy_flush,CONFIG_DEFAULT_SLAVE_LAZY_FLUSH);
1909      rewriteConfigYesNoOption(state,&quot;dynamic-hz&quot;,server.dynamic_hz,CONFIG_DEFAULT_DYNAMIC_HZ);
1910      if (server.sentinel_mode) rewriteConfigSentinelOption(state);
1911      rewriteConfigRemoveOrphaned(state);
1912      newcontent = rewriteConfigGetContentFromState(state);
1913      retval = rewriteConfigOverwriteFile(server.configfile,newcontent);
1914      sdsfree(newcontent);
1915      rewriteConfigReleaseState(state);
1916      return retval;
1917  }
1918  void configCommand(client *c) {
1919      if (server.loading &amp;&amp; strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;get&quot;)) {
1920          addReplyError(c,&quot;Only CONFIG GET is allowed during loading&quot;);
1921          return;
1922      }
1923      if (c-&gt;argc == 2 &amp;&amp; !strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;help&quot;)) {
1924          const char *help[] = {
1925  &quot;GET &lt;pattern&gt; -- Return parameters matching the glob-like &lt;pattern&gt; and their values.&quot;,
1926  &quot;SET &lt;parameter&gt; &lt;value&gt; -- Set parameter to value.&quot;,
1927  &quot;RESETSTAT -- Reset statistics reported by INFO.&quot;,
1928  &quot;REWRITE -- Rewrite the configuration file.&quot;,
1929  NULL
1930          };
1931          addReplyHelp(c, help);
1932      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;set&quot;) &amp;&amp; c-&gt;argc == 4) {
1933          configSetCommand(c);
1934      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;get&quot;) &amp;&amp; c-&gt;argc == 3) {
1935          configGetCommand(c);
1936      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;resetstat&quot;) &amp;&amp; c-&gt;argc == 2) {
1937          resetServerStats();
1938          resetCommandTableStats();
1939          addReply(c,shared.ok);
1940      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;rewrite&quot;) &amp;&amp; c-&gt;argc == 2) {
1941          if (server.configfile == NULL) {
1942              addReplyError(c,&quot;The server is running without a config file&quot;);
1943              return;
1944          }
1945          if (rewriteConfig(server.configfile) == -1) {
1946              serverLog(LL_WARNING,&quot;CONFIG REWRITE failed: %s&quot;, IF_WIN32(wsa_strerror(errno), strerror(errno)));
1947              addReplyErrorFormat(c,&quot;Rewriting config file: %s&quot;, IF_WIN32(wsa_strerror(errno), strerror(errno)));
1948          } else {
1949              serverLog(LL_WARNING,&quot;CONFIG REWRITE executed with success.&quot;);
1950              addReply(c,shared.ok);
1951          }
1952      } else {
1953          addReplySubcommandSyntaxError(c);
1954          return;
1955      }
1956  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-config.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include &quot;Win32_Interop/win32_types.h&quot;
3  #include &quot;Win32_Interop/Win32_EventLog.h&quot;
4  #include &quot;Win32_Interop/Win32_Error.h&quot;
5  #include &lt;direct.h&gt;
6  #endif
7  #include &quot;server.h&quot;
8  #include &quot;cluster.h&quot;
9  #include &lt;fcntl.h&gt;
10  #include &lt;sys/stat.h&gt;
11  typedef struct configEnum {
12      const char *name;
13      const int val;
14  } configEnum;
15  configEnum maxmemory_policy_enum[] = {
16      {&quot;volatile-lru&quot;, MAXMEMORY_VOLATILE_LRU},
17      {&quot;volatile-lfu&quot;, MAXMEMORY_VOLATILE_LFU},
18      {&quot;volatile-random&quot;,MAXMEMORY_VOLATILE_RANDOM},
19      {&quot;volatile-ttl&quot;,MAXMEMORY_VOLATILE_TTL},
20      {&quot;allkeys-lru&quot;,MAXMEMORY_ALLKEYS_LRU},
21      {&quot;allkeys-lfu&quot;,MAXMEMORY_ALLKEYS_LFU},
22      {&quot;allkeys-random&quot;,MAXMEMORY_ALLKEYS_RANDOM},
23      {&quot;noeviction&quot;,MAXMEMORY_NO_EVICTION},
24      {NULL, 0}
25  };
26  #ifndef _WIN32
27  configEnum syslog_facility_enum[] = {
28      {&quot;user&quot;,    LOG_USER},
29      {&quot;local0&quot;,  LOG_LOCAL0},
30      {&quot;local1&quot;,  LOG_LOCAL1},
31      {&quot;local2&quot;,  LOG_LOCAL2},
32      {&quot;local3&quot;,  LOG_LOCAL3},
33      {&quot;local4&quot;,  LOG_LOCAL4},
34      {&quot;local5&quot;,  LOG_LOCAL5},
35      {&quot;local6&quot;,  LOG_LOCAL6},
36      {&quot;local7&quot;,  LOG_LOCAL7},
37      {NULL, 0}
38  };
39  #endif
40  configEnum loglevel_enum[] = {
41      {&quot;debug&quot;, LL_DEBUG},
42      {&quot;verbose&quot;, LL_VERBOSE},
43      {&quot;notice&quot;, LL_NOTICE},
44      {&quot;warning&quot;, LL_WARNING},
45      {NULL,0}
46  };
47  configEnum supervised_mode_enum[] = {
48      {&quot;upstart&quot;, SUPERVISED_UPSTART},
49      {&quot;systemd&quot;, SUPERVISED_SYSTEMD},
50      {&quot;auto&quot;, SUPERVISED_AUTODETECT},
51      {&quot;no&quot;, SUPERVISED_NONE},
52      {NULL, 0}
53  };
54  configEnum aof_fsync_enum[] = {
55      {&quot;everysec&quot;, AOF_FSYNC_EVERYSEC},
56      {&quot;always&quot;, AOF_FSYNC_ALWAYS},
57      {&quot;no&quot;, AOF_FSYNC_NO},
58      {NULL, 0}
59  };
60  clientBufferLimitsConfig clientBufferLimitsDefaults[CLIENT_TYPE_OBUF_COUNT] = {
61      {0, 0, 0}, &amp;bsol;* normal */
62      {1024*1024*256, 1024*1024*64, 60}, &amp;bsol;* slave */
63      {1024*1024*32, 1024*1024*8, 60}  &amp;bsol;* pubsub */
64  };
65  int configEnumGetValue(configEnum *ce, char *name) {
66      while(ce-&gt;name != NULL) {
67          if (!strcasecmp(ce-&gt;name,name)) return ce-&gt;val;
68          ce++;
69      }
70      return INT_MIN;
71  }
72  const char *configEnumGetName(configEnum *ce, int val) {
73      while(ce-&gt;name != NULL) {
74          if (ce-&gt;val == val) return ce-&gt;name;
75          ce++;
76      }
77      return NULL;
78  }
79  const char *configEnumGetNameOrUnknown(configEnum *ce, int val) {
80      const char *name = configEnumGetName(ce,val);
81      return name ? name : &quot;unknown&quot;;
82  }
83  const char *evictPolicyToString(void) {
84      return configEnumGetNameOrUnknown(maxmemory_policy_enum,server.maxmemory_policy);
85  }
86  int yesnotoi(char *s) {
87      if (!strcasecmp(s,&quot;yes&quot;)) return 1;
88      else if (!strcasecmp(s,&quot;no&quot;)) return 0;
89      else return -1;
90  }
91  void appendServerSaveParams(time_t seconds, int changes) {
92      server.saveparams = zrealloc(server.saveparams,sizeof(struct saveparam)*((PORT_ULONG)server.saveparamslen+1));  WIN_PORT_FIX &amp;bsol;* cat (PORT_ULONG) */
93      server.saveparams[server.saveparamslen].seconds = seconds;
94      server.saveparams[server.saveparamslen].changes = changes;
95      server.saveparamslen++;
96  }
97  void resetServerSaveParams(void) {
98      zfree(server.saveparams);
99      server.saveparams = NULL;
100      server.saveparamslen = 0;
101  }
102  void queueLoadModule(sds path, sds *argv, int argc) {
103      int i;
104      struct moduleLoadQueueEntry *loadmod;
105      loadmod = zmalloc(sizeof(struct moduleLoadQueueEntry));
106      loadmod-&gt;argv = zmalloc(sizeof(robj*)*argc);
107      loadmod-&gt;path = sdsnew(path);
108      loadmod-&gt;argc = argc;
109      for (i = 0; i &lt; argc; i++) {
110          loadmod-&gt;argv[i] = createRawStringObject(argv[i],sdslen(argv[i]));
111      }
112      listAddNodeTail(server.loadmodule_queue,loadmod);
113  }
114  void loadServerConfigFromString(char *config) {
115      char *err = NULL;
116      int linenum = 0, totlines, i;
117      int slaveof_linenum = 0;
118      sds *lines;
119      lines = sdssplitlen(config,(int)strlen(config),&quot;\n&quot;,1,&amp;totlines);           WIN_PORT_FIX &amp;bsol;* cast (int) */
120      for (i = 0; i &lt; totlines; i++) {
121          sds *argv;
122          int argc;
123          linenum = i+1;
124          lines[i] = sdstrim(lines[i],&quot; \t\r\n&quot;);
125          if (lines[i][0] == &#x27;#&#x27; || lines[i][0] == &#x27;\0&#x27;) continue;
126          argv = sdssplitargs(lines[i],&amp;argc);
127          if (argv == NULL) {
128              err = &quot;Unbalanced quotes in configuration line&quot;;
129              goto loaderr;
130          }
131          if (argc == 0) {
132              sdsfreesplitres(argv,argc);
133              continue;
134          }
135          sdstolower(argv[0]);
136          if (!strcasecmp(argv[0],&quot;timeout&quot;) &amp;&amp; argc == 2) {
137              server.maxidletime = atoi(argv[1]);
138              if (server.maxidletime &lt; 0) {
139                  err = &quot;Invalid timeout value&quot;; goto loaderr;
140              }
141          } else if (!strcasecmp(argv[0],&quot;tcp-keepalive&quot;) &amp;&amp; argc == 2) {
142              server.tcpkeepalive = atoi(argv[1]);
143              if (server.tcpkeepalive &lt; 0) {
144                  err = &quot;Invalid tcp-keepalive value&quot;; goto loaderr;
145              }
146          } else if (!strcasecmp(argv[0],&quot;protected-mode&quot;) &amp;&amp; argc == 2) {
147              if ((server.protected_mode = yesnotoi(argv[1])) == -1) {
148                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
149              }
150          } else if (!strcasecmp(argv[0],&quot;port&quot;) &amp;&amp; argc == 2) {
151              server.port = atoi(argv[1]);
152              if (server.port &lt; 0 || server.port &gt; 65535) {
153                  err = &quot;Invalid port&quot;; goto loaderr;
154              }
155          } else if (!strcasecmp(argv[0],&quot;tcp-backlog&quot;) &amp;&amp; argc == 2) {
156              server.tcp_backlog = atoi(argv[1]);
157              if (server.tcp_backlog &lt; 0) {
158                  err = &quot;Invalid backlog value&quot;; goto loaderr;
159              }
160          } else if (!strcasecmp(argv[0],&quot;bind&quot;) &amp;&amp; argc &gt;= 2) {
161              int j, addresses = argc-1;
162              if (addresses &gt; CONFIG_BINDADDR_MAX) {
163                  err = &quot;Too many bind addresses specified&quot;; goto loaderr;
164              }
165              for (j = 0; j &lt; addresses; j++)
166                  server.bindaddr[j] = zstrdup(argv[j+1]);
167              server.bindaddr_count = addresses;
168          } else if (!strcasecmp(argv[0],&quot;unixsocket&quot;) &amp;&amp; argc == 2) {
169              server.unixsocket = zstrdup(argv[1]);
170          } else if (!strcasecmp(argv[0],&quot;unixsocketperm&quot;) &amp;&amp; argc == 2) {
171              errno = 0;
172              server.unixsocketperm = (mode_t)strtol(argv[1], NULL, 8);
173              if (errno || server.unixsocketperm &gt; 0777) {
174                  err = &quot;Invalid socket file permissions&quot;; goto loaderr;
175              }
176          } else if (!strcasecmp(argv[0],&quot;save&quot;)) {
177              if (argc == 3) {
178                  int seconds = atoi(argv[1]);
179                  int changes = atoi(argv[2]);
180                  if (seconds &lt; 1 || changes &lt; 0) {
181                      err = &quot;Invalid save parameters&quot;; goto loaderr;
182                  }
183                  appendServerSaveParams(seconds,changes);
184              } else if (argc == 2 &amp;&amp; !strcasecmp(argv[1],&quot;&quot;)) {
185                  resetServerSaveParams();
186              }
187          } else if (!strcasecmp(argv[0],&quot;dir&quot;) &amp;&amp; argc == 2) {
188              if (chdir(argv[1]) == -1) {
189                  serverLog(LL_WARNING,&quot;Can&#x27;t chdir to &#x27;%s&#x27;: %s&quot;,
190                      argv[1], IF_WIN32(wsa_strerror(errno), strerror(errno)));
191                  exit(1);
192              }
193          } else if (!strcasecmp(argv[0],&quot;loglevel&quot;) &amp;&amp; argc == 2) {
194              server.verbosity = configEnumGetValue(loglevel_enum,argv[1]);
195              if (server.verbosity == INT_MIN) {
196                  err = &quot;Invalid log level. &quot;
197                        &quot;Must be one of debug, verbose, notice, warning&quot;;
198                  goto loaderr;
199              }
200  #ifdef _WIN32
201              setLogVerbosityLevel(server.verbosity);
202  #endif
203          } else if (!strcasecmp(argv[0],&quot;logfile&quot;) &amp;&amp; argc == 2) {
204              FILE *logfp;
205              zfree(server.logfile);
206  #ifdef _WIN32
207              int length = (int)sdslen(argv[1]);
208              if ((argv[1][0] == &#x27;\&#x27;&#x27;  &amp;&amp;  argv[1][length-1] == &#x27;\&#x27;&#x27;)  ||
209                  (argv[1][0] == &#x27;\&quot;&#x27;  &amp;&amp;  argv[1][length-1] == &#x27;\&quot;&#x27;)) {
210                  if (length == 2) {
211                      server.logfile = zstrdup(&quot;\0&quot;);
212                  } else {
213                      size_t l = (size_t) length - 2 + 1;
214                      char *p = zmalloc(l);
215                      memcpy(p, argv[1]+1, l);
216                      server.logfile = p;
217                  }
218              } else {
219                  server.logfile = zstrdup(argv[1]);
220              }
221  #else
222              server.logfile = zstrdup(argv[1]);
223  #endif
224              if (server.logfile[0] != &#x27;\0&#x27;) {
225                  logfp = fopen(server.logfile,&quot;a&quot;);
226                  if (logfp == NULL) {
227                      err = sdscatprintf(sdsempty(),
228                          &quot;Can&#x27;t open the log file: %s&quot;, IF_WIN32(wsa_strerror(errno), strerror(errno)));
229                      goto loaderr;
230  #ifdef _WIN32
231                  } else {
232                      setLogFile(server.logfile);
233  #endif
234                  }
235                  fclose(logfp);
236              }
237          } else if (!strcasecmp(argv[0],&quot;always-show-logo&quot;) &amp;&amp; argc == 2) {
238              if ((server.always_show_logo = yesnotoi(argv[1])) == -1) {
239                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
240              }
241          } else if (!strcasecmp(argv[0],&quot;syslog-enabled&quot;) &amp;&amp; argc == 2) {
242              if ((server.syslog_enabled = yesnotoi(argv[1])) == -1) {
243                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
244              }
245  #ifdef _WIN32
246              setSyslogEnabled(server.syslog_enabled);
247  #endif
248          } else if (!strcasecmp(argv[0],&quot;syslog-ident&quot;) &amp;&amp; argc == 2) {
249              if (server.syslog_ident) zfree(server.syslog_ident);
250              server.syslog_ident = zstrdup(argv[1]);
251  #ifdef _WIN32
252              setSyslogIdent(server.syslog_ident);
253  #endif
254          } else if (!strcasecmp(argv[0],&quot;syslog-facility&quot;) &amp;&amp; argc == 2) {
255  #ifdef _WIN32
256  #else
257              server.syslog_facility =
258                  configEnumGetValue(syslog_facility_enum,argv[1]);
259              if (server.syslog_facility == INT_MIN) {
260                  err = &quot;Invalid log facility. Must be one of USER or between LOCAL0-LOCAL7&quot;;
261                  goto loaderr;
262              }
263  #endif
264          } else if (!strcasecmp(argv[0],&quot;databases&quot;) &amp;&amp; argc == 2) {
265              server.dbnum = atoi(argv[1]);
266              if (server.dbnum &lt; 1) {
267                  err = &quot;Invalid number of databases&quot;; goto loaderr;
268              }
269          } else if (!strcasecmp(argv[0],&quot;include&quot;) &amp;&amp; argc == 2) {
270              loadServerConfig(argv[1],NULL);
271          } else if (!strcasecmp(argv[0],&quot;maxclients&quot;) &amp;&amp; argc == 2) {
272              server.maxclients = atoi(argv[1]);
273              if (server.maxclients &lt; 1) {
274                  err = &quot;Invalid max clients limit&quot;; goto loaderr;
275              }
276          } else if (!strcasecmp(argv[0],&quot;maxmemory&quot;) &amp;&amp; argc == 2) {
277              server.maxmemory = memtoll(argv[1],NULL);
278          } else if (!strcasecmp(argv[0],&quot;maxmemory-policy&quot;) &amp;&amp; argc == 2) {
279              server.maxmemory_policy =
280                  configEnumGetValue(maxmemory_policy_enum,argv[1]);
281              if (server.maxmemory_policy == INT_MIN) {
282                  err = &quot;Invalid maxmemory policy&quot;;
283                  goto loaderr;
284              }
285          } else if (!strcasecmp(argv[0],&quot;maxmemory-samples&quot;) &amp;&amp; argc == 2) {
286              server.maxmemory_samples = atoi(argv[1]);
287              if (server.maxmemory_samples &lt;= 0) {
288                  err = &quot;maxmemory-samples must be 1 or greater&quot;;
289                  goto loaderr;
290              }
291          } else if ((!strcasecmp(argv[0],&quot;proto-max-bulk-len&quot;)) &amp;&amp; argc == 2) {
292              server.proto_max_bulk_len = memtoll(argv[1],NULL);
293          } else if ((!strcasecmp(argv[0],&quot;client-query-buffer-limit&quot;)) &amp;&amp; argc == 2) {
294              server.client_max_querybuf_len = memtoll(argv[1],NULL);
295          } else if (!strcasecmp(argv[0],&quot;lfu-log-factor&quot;) &amp;&amp; argc == 2) {
296              server.lfu_log_factor = atoi(argv[1]);
297              if (server.lfu_log_factor &lt; 0) {
298                  err = &quot;lfu-log-factor must be 0 or greater&quot;;
299                  goto loaderr;
300              }
301          } else if (!strcasecmp(argv[0],&quot;lfu-decay-time&quot;) &amp;&amp; argc == 2) {
302              server.lfu_decay_time = atoi(argv[1]);
303              if (server.lfu_decay_time &lt; 0) {
304                  err = &quot;lfu-decay-time must be 0 or greater&quot;;
305                  goto loaderr;
306              }
307          } else if ((!strcasecmp(argv[0],&quot;slaveof&quot;) ||
308                      !strcasecmp(argv[0],&quot;replicaof&quot;)) &amp;&amp; argc == 3) {
309              slaveof_linenum = linenum;
310              server.masterhost = sdsnew(argv[1]);
311              server.masterport = atoi(argv[2]);
312              server.repl_state = REPL_STATE_CONNECT;
313          } else if ((!strcasecmp(argv[0],&quot;repl-ping-slave-period&quot;) ||
314                      !strcasecmp(argv[0],&quot;repl-ping-replica-period&quot;)) &amp;&amp;
315                      argc == 2)
316          {
317              server.repl_ping_slave_period = atoi(argv[1]);
318              if (server.repl_ping_slave_period &lt;= 0) {
319                  err = &quot;repl-ping-replica-period must be 1 or greater&quot;;
320                  goto loaderr;
321              }
322          } else if (!strcasecmp(argv[0],&quot;repl-timeout&quot;) &amp;&amp; argc == 2) {
323              server.repl_timeout = atoi(argv[1]);
324              if (server.repl_timeout &lt;= 0) {
325                  err = &quot;repl-timeout must be 1 or greater&quot;;
326                  goto loaderr;
327              }
328          } else if (!strcasecmp(argv[0],&quot;repl-disable-tcp-nodelay&quot;) &amp;&amp; argc==2) {
329              if ((server.repl_disable_tcp_nodelay = yesnotoi(argv[1])) == -1) {
330                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
331              }
332          } else if (!strcasecmp(argv[0],&quot;repl-diskless-sync&quot;) &amp;&amp; argc==2) {
333              if ((server.repl_diskless_sync = yesnotoi(argv[1])) == -1) {
334                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
335              }
336          } else if (!strcasecmp(argv[0],&quot;repl-diskless-sync-delay&quot;) &amp;&amp; argc==2) {
337              server.repl_diskless_sync_delay = atoi(argv[1]);
338              if (server.repl_diskless_sync_delay &lt; 0) {
339                  err = &quot;repl-diskless-sync-delay can&#x27;t be negative&quot;;
340                  goto loaderr;
341              }
342          } else if (!strcasecmp(argv[0],&quot;repl-backlog-size&quot;) &amp;&amp; argc == 2) {
343              PORT_LONGLONG size = memtoll(argv[1],NULL);
344              if (size &lt;= 0) {
345                  err = &quot;repl-backlog-size must be 1 or greater.&quot;;
346                  goto loaderr;
347              }
348              resizeReplicationBacklog(size);
349          } else if (!strcasecmp(argv[0],&quot;repl-backlog-ttl&quot;) &amp;&amp; argc == 2) {
350              server.repl_backlog_time_limit = atoi(argv[1]);
351              if (server.repl_backlog_time_limit &lt; 0) {
352                  err = &quot;repl-backlog-ttl can&#x27;t be negative &quot;;
353                  goto loaderr;
354              }
355          } else if (!strcasecmp(argv[0],&quot;masterauth&quot;) &amp;&amp; argc == 2) {
356              zfree(server.masterauth);
357              server.masterauth = argv[1][0] ? zstrdup(argv[1]) : NULL;
358          } else if ((!strcasecmp(argv[0],&quot;slave-serve-stale-data&quot;) ||
359                      !strcasecmp(argv[0],&quot;replica-serve-stale-data&quot;))
360                      &amp;&amp; argc == 2)
361          {
362              if ((server.repl_serve_stale_data = yesnotoi(argv[1])) == -1) {
363                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
364              }
365          } else if ((!strcasecmp(argv[0],&quot;slave-read-only&quot;) ||
366                      !strcasecmp(argv[0],&quot;replica-read-only&quot;))
367                      &amp;&amp; argc == 2)
368          {
369              if ((server.repl_slave_ro = yesnotoi(argv[1])) == -1) {
370                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
371              }
372          } else if ((!strcasecmp(argv[0],&quot;slave-ignore-maxmemory&quot;) ||
373                      !strcasecmp(argv[0],&quot;replica-ignore-maxmemory&quot;))
374                      &amp;&amp; argc == 2)
375          {
376              if ((server.repl_slave_ignore_maxmemory = yesnotoi(argv[1])) == -1) {
377                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
378              }
379          } else if (!strcasecmp(argv[0],&quot;rdbcompression&quot;) &amp;&amp; argc == 2) {
380              if ((server.rdb_compression = yesnotoi(argv[1])) == -1) {
381                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
382              }
383          } else if (!strcasecmp(argv[0],&quot;rdbchecksum&quot;) &amp;&amp; argc == 2) {
384              if ((server.rdb_checksum = yesnotoi(argv[1])) == -1) {
385                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
386              }
387          } else if (!strcasecmp(argv[0],&quot;activerehashing&quot;) &amp;&amp; argc == 2) {
388              if ((server.activerehashing = yesnotoi(argv[1])) == -1) {
389                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
390              }
391          } else if (!strcasecmp(argv[0],&quot;lazyfree-lazy-eviction&quot;) &amp;&amp; argc == 2) {
392              if ((server.lazyfree_lazy_eviction = yesnotoi(argv[1])) == -1) {
393                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
394              }
395          } else if (!strcasecmp(argv[0],&quot;lazyfree-lazy-expire&quot;) &amp;&amp; argc == 2) {
396              if ((server.lazyfree_lazy_expire = yesnotoi(argv[1])) == -1) {
397                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
398              }
399          } else if (!strcasecmp(argv[0],&quot;lazyfree-lazy-server-del&quot;) &amp;&amp; argc == 2){
400              if ((server.lazyfree_lazy_server_del = yesnotoi(argv[1])) == -1) {
401                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
402              }
403          } else if ((!strcasecmp(argv[0],&quot;slave-lazy-flush&quot;) ||
404                      !strcasecmp(argv[0],&quot;replica-lazy-flush&quot;)) &amp;&amp; argc == 2)
405          {
406              if ((server.repl_slave_lazy_flush = yesnotoi(argv[1])) == -1) {
407                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
408              }
409          } else if (!strcasecmp(argv[0],&quot;activedefrag&quot;) &amp;&amp; argc == 2) {
410              if ((server.active_defrag_enabled = yesnotoi(argv[1])) == -1) {
411                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
412              }
413              if (server.active_defrag_enabled) {
414  #ifndef HAVE_DEFRAG
415                  err = &quot;active defrag can&#x27;t be enabled without proper jemalloc support&quot;; goto loaderr;
416  #endif
417              }
418          } else if (!strcasecmp(argv[0],&quot;daemonize&quot;) &amp;&amp; argc == 2) {
419              if ((server.daemonize = yesnotoi(argv[1])) == -1) {
420                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
421              }
422          } else if (!strcasecmp(argv[0],&quot;dynamic-hz&quot;) &amp;&amp; argc == 2) {
423              if ((server.dynamic_hz = yesnotoi(argv[1])) == -1) {
424                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
425              }
426          } else if (!strcasecmp(argv[0],&quot;hz&quot;) &amp;&amp; argc == 2) {
427              server.config_hz = atoi(argv[1]);
428              if (server.config_hz &lt; CONFIG_MIN_HZ) server.config_hz = CONFIG_MIN_HZ;
429              if (server.config_hz &gt; CONFIG_MAX_HZ) server.config_hz = CONFIG_MAX_HZ;
430          } else if (!strcasecmp(argv[0],&quot;appendonly&quot;) &amp;&amp; argc == 2) {
431              int yes;
432              if ((yes = yesnotoi(argv[1])) == -1) {
433                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
434              }
435              server.aof_state = yes ? AOF_ON : AOF_OFF;
436          } else if (!strcasecmp(argv[0],&quot;appendfilename&quot;) &amp;&amp; argc == 2) {
437              if (!pathIsBaseName(argv[1])) {
438                  err = &quot;appendfilename can&#x27;t be a path, just a filename&quot;;
439                  goto loaderr;
440              }
441              zfree(server.aof_filename);
442              server.aof_filename = zstrdup(argv[1]);
443          } else if (!strcasecmp(argv[0],&quot;no-appendfsync-on-rewrite&quot;)
444                     &amp;&amp; argc == 2) {
445              if ((server.aof_no_fsync_on_rewrite= yesnotoi(argv[1])) == -1) {
446                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
447              }
448          } else if (!strcasecmp(argv[0],&quot;appendfsync&quot;) &amp;&amp; argc == 2) {
449              server.aof_fsync = configEnumGetValue(aof_fsync_enum,argv[1]);
450              if (server.aof_fsync == INT_MIN) {
451                  err = &quot;argument must be &#x27;no&#x27;, &#x27;always&#x27; or &#x27;everysec&#x27;&quot;;
452                  goto loaderr;
453              }
454          } else if (!strcasecmp(argv[0],&quot;auto-aof-rewrite-percentage&quot;) &amp;&amp;
455                     argc == 2)
456          {
457              server.aof_rewrite_perc = atoi(argv[1]);
458              if (server.aof_rewrite_perc &lt; 0) {
459                  err = &quot;Invalid negative percentage for AOF auto rewrite&quot;;
460                  goto loaderr;
461              }
462          } else if (!strcasecmp(argv[0],&quot;auto-aof-rewrite-min-size&quot;) &amp;&amp;
463                     argc == 2)
464          {
465              server.aof_rewrite_min_size = memtoll(argv[1],NULL);
466          } else if (!strcasecmp(argv[0],&quot;aof-rewrite-incremental-fsync&quot;) &amp;&amp;
467                     argc == 2)
468          {
469              if ((server.aof_rewrite_incremental_fsync =
470                   yesnotoi(argv[1])) == -1) {
471                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
472              }
473          } else if (!strcasecmp(argv[0],&quot;rdb-save-incremental-fsync&quot;) &amp;&amp;
474                     argc == 2)
475          {
476              if ((server.rdb_save_incremental_fsync =
477                   yesnotoi(argv[1])) == -1) {
478                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
479              }
480          } else if (!strcasecmp(argv[0],&quot;aof-load-truncated&quot;) &amp;&amp; argc == 2) {
481              if ((server.aof_load_truncated = yesnotoi(argv[1])) == -1) {
482                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
483              }
484          } else if (!strcasecmp(argv[0],&quot;aof-use-rdb-preamble&quot;) &amp;&amp; argc == 2) {
485              if ((server.aof_use_rdb_preamble = yesnotoi(argv[1])) == -1) {
486                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
487              }
488          } else if (!strcasecmp(argv[0],&quot;requirepass&quot;) &amp;&amp; argc == 2) {
489              if (strlen(argv[1]) &gt; CONFIG_AUTHPASS_MAX_LEN) {
490                  err = &quot;Password is longer than CONFIG_AUTHPASS_MAX_LEN&quot;;
491                  goto loaderr;
492              }
493              server.requirepass = argv[1][0] ? zstrdup(argv[1]) : NULL;
494          } else if (!strcasecmp(argv[0],&quot;pidfile&quot;) &amp;&amp; argc == 2) {
495              zfree(server.pidfile);
496              server.pidfile = zstrdup(argv[1]);
497          } else if (!strcasecmp(argv[0],&quot;dbfilename&quot;) &amp;&amp; argc == 2) {
498              if (!pathIsBaseName(argv[1])) {
499                  err = &quot;dbfilename can&#x27;t be a path, just a filename&quot;;
500                  goto loaderr;
501              }
502              zfree(server.rdb_filename);
503              server.rdb_filename = zstrdup(argv[1]);
504          } else if (!strcasecmp(argv[0],&quot;active-defrag-threshold-lower&quot;) &amp;&amp; argc == 2) {
505              server.active_defrag_threshold_lower = atoi(argv[1]);
506              if (server.active_defrag_threshold_lower &lt; 0 ||
507                  server.active_defrag_threshold_lower &gt; 1000) {
<span onclick='openModal()' class='match'>508                  err = &quot;active-defrag-threshold-lower must be between 0 and 1000&quot;;
509                  goto loaderr;
510              }
511          } else if (!strcasecmp(argv[0],&quot;active-defrag-threshold-upper&quot;) &amp;&amp; argc == 2) {
512              server.active_defrag_threshold_upper = atoi(argv[1]);
</span>513              if (server.active_defrag_threshold_upper &lt; 0 ||
514                  server.active_defrag_threshold_upper &gt; 1000) {
515                  err = &quot;active-defrag-threshold-upper must be between 0 and 1000&quot;;
516                  goto loaderr;
517              }
518          } else if (!strcasecmp(argv[0],&quot;active-defrag-ignore-bytes&quot;) &amp;&amp; argc == 2) {
519              server.active_defrag_ignore_bytes = memtoll(argv[1], NULL);
520              if (server.active_defrag_ignore_bytes &lt;= 0) {
521                  err = &quot;active-defrag-ignore-bytes must above 0&quot;;
522                  goto loaderr;
523              }
524          } else if (!strcasecmp(argv[0],&quot;active-defrag-cycle-min&quot;) &amp;&amp; argc == 2) {
525              server.active_defrag_cycle_min = atoi(argv[1]);
526              if (server.active_defrag_cycle_min &lt; 1 || server.active_defrag_cycle_min &gt; 99) {
527                  err = &quot;active-defrag-cycle-min must be between 1 and 99&quot;;
528                  goto loaderr;
529              }
530          } else if (!strcasecmp(argv[0],&quot;active-defrag-cycle-max&quot;) &amp;&amp; argc == 2) {
531              server.active_defrag_cycle_max = atoi(argv[1]);
532              if (server.active_defrag_cycle_max &lt; 1 || server.active_defrag_cycle_max &gt; 99) {
533                  err = &quot;active-defrag-cycle-max must be between 1 and 99&quot;;
534                  goto loaderr;
535              }
536          } else if (!strcasecmp(argv[0],&quot;active-defrag-max-scan-fields&quot;) &amp;&amp; argc == 2) {
537              server.active_defrag_max_scan_fields = strtoll(argv[1],NULL,10);
538              if (server.active_defrag_max_scan_fields &lt; 1) {
539                  err = &quot;active-defrag-max-scan-fields must be positive&quot;;
540                  goto loaderr;
541              }
542          } else if (!strcasecmp(argv[0],&quot;hash-max-ziplist-entries&quot;) &amp;&amp; argc == 2) {
543              server.hash_max_ziplist_entries = memtoll(argv[1], NULL);
544          } else if (!strcasecmp(argv[0],&quot;hash-max-ziplist-value&quot;) &amp;&amp; argc == 2) {
545              server.hash_max_ziplist_value = memtoll(argv[1], NULL);
546          } else if (!strcasecmp(argv[0],&quot;stream-node-max-bytes&quot;) &amp;&amp; argc == 2) {
547              server.stream_node_max_bytes = memtoll(argv[1], NULL);
548          } else if (!strcasecmp(argv[0],&quot;stream-node-max-entries&quot;) &amp;&amp; argc == 2) {
549              server.stream_node_max_entries = atoi(argv[1]);
550          } else if (!strcasecmp(argv[0],&quot;list-max-ziplist-entries&quot;) &amp;&amp; argc == 2){
551          } else if (!strcasecmp(argv[0],&quot;list-max-ziplist-value&quot;) &amp;&amp; argc == 2) {
552          } else if (!strcasecmp(argv[0],&quot;list-max-ziplist-size&quot;) &amp;&amp; argc == 2) {
553              server.list_max_ziplist_size = atoi(argv[1]);
554          } else if (!strcasecmp(argv[0],&quot;list-compress-depth&quot;) &amp;&amp; argc == 2) {
555              server.list_compress_depth = atoi(argv[1]);
556          } else if (!strcasecmp(argv[0],&quot;set-max-intset-entries&quot;) &amp;&amp; argc == 2) {
557              server.set_max_intset_entries = memtoll(argv[1], NULL);
558          } else if (!strcasecmp(argv[0],&quot;zset-max-ziplist-entries&quot;) &amp;&amp; argc == 2) {
559              server.zset_max_ziplist_entries = memtoll(argv[1], NULL);
560          } else if (!strcasecmp(argv[0],&quot;zset-max-ziplist-value&quot;) &amp;&amp; argc == 2) {
561              server.zset_max_ziplist_value = memtoll(argv[1], NULL);
562          } else if (!strcasecmp(argv[0],&quot;hll-sparse-max-bytes&quot;) &amp;&amp; argc == 2) {
563              server.hll_sparse_max_bytes = memtoll(argv[1], NULL);
564          } else if (!strcasecmp(argv[0],&quot;rename-command&quot;) &amp;&amp; argc == 3) {
565              struct redisCommand *cmd = lookupCommand(argv[1]);
566              int retval;
567              if (!cmd) {
568                  err = &quot;No such command in rename-command&quot;;
569                  goto loaderr;
570              }
571              retval = dictDelete(server.commands, argv[1]);
572              serverAssert(retval == DICT_OK);
573              if (sdslen(argv[2]) != 0) {
574                  sds copy = sdsdup(argv[2]);
575                  retval = dictAdd(server.commands, copy, cmd);
576                  if (retval != DICT_OK) {
577                      sdsfree(copy);
578                      err = &quot;Target command name already exists&quot;; goto loaderr;
579                  }
580              }
581          } else if (!strcasecmp(argv[0],&quot;cluster-enabled&quot;) &amp;&amp; argc == 2) {
582              if ((server.cluster_enabled = yesnotoi(argv[1])) == -1) {
583                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
584              }
585          } else if (!strcasecmp(argv[0],&quot;cluster-config-file&quot;) &amp;&amp; argc == 2) {
586              zfree(server.cluster_configfile);
587              server.cluster_configfile = zstrdup(argv[1]);
588          } else if (!strcasecmp(argv[0],&quot;cluster-announce-ip&quot;) &amp;&amp; argc == 2) {
589              zfree(server.cluster_announce_ip);
590              server.cluster_announce_ip = zstrdup(argv[1]);
591          } else if (!strcasecmp(argv[0],&quot;cluster-announce-port&quot;) &amp;&amp; argc == 2) {
592              server.cluster_announce_port = atoi(argv[1]);
593              if (server.cluster_announce_port &lt; 0 ||
594                  server.cluster_announce_port &gt; 65535)
595              {
596                  err = &quot;Invalid port&quot;; goto loaderr;
597              }
598          } else if (!strcasecmp(argv[0],&quot;cluster-announce-bus-port&quot;) &amp;&amp;
599                     argc == 2)
600          {
601              server.cluster_announce_bus_port = atoi(argv[1]);
602              if (server.cluster_announce_bus_port &lt; 0 ||
603                  server.cluster_announce_bus_port &gt; 65535)
604              {
605                  err = &quot;Invalid port&quot;; goto loaderr;
606              }
607          } else if (!strcasecmp(argv[0],&quot;cluster-require-full-coverage&quot;) &amp;&amp;
608                      argc == 2)
609          {
610              if ((server.cluster_require_full_coverage = yesnotoi(argv[1])) == -1)
611              {
612                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
613              }
614          } else if (!strcasecmp(argv[0],&quot;cluster-node-timeout&quot;) &amp;&amp; argc == 2) {
615              server.cluster_node_timeout = strtoll(argv[1],NULL,10);
616              if (server.cluster_node_timeout &lt;= 0) {
617                  err = &quot;cluster node timeout must be 1 or greater&quot;; goto loaderr;
618              }
619          } else if (!strcasecmp(argv[0],&quot;cluster-migration-barrier&quot;)
620                     &amp;&amp; argc == 2)
621          {
622              server.cluster_migration_barrier = atoi(argv[1]);
623              if (server.cluster_migration_barrier &lt; 0) {
624                  err = &quot;cluster migration barrier must zero or positive&quot;;
625                  goto loaderr;
626              }
627          } else if ((!strcasecmp(argv[0],&quot;cluster-slave-validity-factor&quot;) ||
628                      !strcasecmp(argv[0],&quot;cluster-replica-validity-factor&quot;))
629                     &amp;&amp; argc == 2)
630          {
631              server.cluster_slave_validity_factor = atoi(argv[1]);
632              if (server.cluster_slave_validity_factor &lt; 0) {
633                  err = &quot;cluster replica validity factor must be zero or positive&quot;;
634                  goto loaderr;
635              }
636          } else if ((!strcasecmp(argv[0],&quot;cluster-slave-no-failover&quot;) ||
637                      !strcasecmp(argv[0],&quot;cluster-replica-no-failover&quot;)) &amp;&amp;
638                     argc == 2)
639          {
640              server.cluster_slave_no_failover = yesnotoi(argv[1]);
641              if (server.cluster_slave_no_failover == -1) {
642                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;;
643                  goto loaderr;
644              }
645          } else if (!strcasecmp(argv[0],&quot;lua-time-limit&quot;) &amp;&amp; argc == 2) {
646              server.lua_time_limit = strtoll(argv[1],NULL,10);
647          } else if (!strcasecmp(argv[0],&quot;lua-replicate-commands&quot;) &amp;&amp; argc == 2) {
648              server.lua_always_replicate_commands = yesnotoi(argv[1]);
649          } else if (!strcasecmp(argv[0],&quot;slowlog-log-slower-than&quot;) &amp;&amp;
650                     argc == 2)
651          {
652              server.slowlog_log_slower_than = strtoll(argv[1],NULL,10);
653          } else if (!strcasecmp(argv[0],&quot;latency-monitor-threshold&quot;) &amp;&amp;
654                     argc == 2)
655          {
656              server.latency_monitor_threshold = strtoll(argv[1],NULL,10);
657              if (server.latency_monitor_threshold &lt; 0) {
658                  err = &quot;The latency threshold can&#x27;t be negative&quot;;
659                  goto loaderr;
660              }
661          } else if (!strcasecmp(argv[0],&quot;slowlog-max-len&quot;) &amp;&amp; argc == 2) {
662              server.slowlog_max_len = (PORT_ULONG)(strtoll(argv[1],NULL,10));    WIN_PORT_FIX &amp;bsol;* cast (PORT_ULONG) */
663          } else if (!strcasecmp(argv[0],&quot;client-output-buffer-limit&quot;) &amp;&amp;
664                     argc == 5)
665          {
666              int class = getClientTypeByName(argv[1]);
667              PORT_ULONGLONG hard, soft;
668              int soft_seconds;
669              if (class == -1 || class == CLIENT_TYPE_MASTER) {
670                  err = &quot;Unrecognized client limit class: the user specified &quot;
671                  &quot;an invalid one, or &#x27;master&#x27; which has no buffer limits.&quot;;
672                  goto loaderr;
673              }
674              hard = memtoll(argv[2],NULL);
675              soft = memtoll(argv[3],NULL);
676              soft_seconds = atoi(argv[4]);
677              if (soft_seconds &lt; 0) {
678                  err = &quot;Negative number of seconds in soft limit is invalid&quot;;
679                  goto loaderr;
680              }
681              server.client_obuf_limits[class].hard_limit_bytes = hard;
682              server.client_obuf_limits[class].soft_limit_bytes = soft;
683              server.client_obuf_limits[class].soft_limit_seconds = soft_seconds;
684          } else if (!strcasecmp(argv[0],&quot;stop-writes-on-bgsave-error&quot;) &amp;&amp;
685                     argc == 2) {
686              if ((server.stop_writes_on_bgsave_err = yesnotoi(argv[1])) == -1) {
687                  err = &quot;argument must be &#x27;yes&#x27; or &#x27;no&#x27;&quot;; goto loaderr;
688              }
689          } else if ((!strcasecmp(argv[0],&quot;slave-priority&quot;) ||
690                      !strcasecmp(argv[0],&quot;replica-priority&quot;)) &amp;&amp; argc == 2)
691          {
692              server.slave_priority = atoi(argv[1]);
693          } else if ((!strcasecmp(argv[0],&quot;slave-announce-ip&quot;) ||
694                      !strcasecmp(argv[0],&quot;replica-announce-ip&quot;)) &amp;&amp; argc == 2)
695          {
696              zfree(server.slave_announce_ip);
697              server.slave_announce_ip = zstrdup(argv[1]);
698          } else if ((!strcasecmp(argv[0],&quot;slave-announce-port&quot;) ||
699                      !strcasecmp(argv[0],&quot;replica-announce-port&quot;)) &amp;&amp; argc == 2)
700          {
701              server.slave_announce_port = atoi(argv[1]);
702              if (server.slave_announce_port &lt; 0 ||
703                  server.slave_announce_port &gt; 65535)
704              {
705                  err = &quot;Invalid port&quot;; goto loaderr;
706              }
707          } else if ((!strcasecmp(argv[0],&quot;min-slaves-to-write&quot;) ||
708                      !strcasecmp(argv[0],&quot;min-replicas-to-write&quot;)) &amp;&amp; argc == 2)
709          {
710              server.repl_min_slaves_to_write = atoi(argv[1]);
711              if (server.repl_min_slaves_to_write &lt; 0) {
712                  err = &quot;Invalid value for min-replicas-to-write.&quot;; goto loaderr;
713              }
714          } else if ((!strcasecmp(argv[0],&quot;min-slaves-max-lag&quot;) ||
715                      !strcasecmp(argv[0],&quot;min-replicas-max-lag&quot;)) &amp;&amp; argc == 2)
716          {
717              server.repl_min_slaves_max_lag = atoi(argv[1]);
718              if (server.repl_min_slaves_max_lag &lt; 0) {
719                  err = &quot;Invalid value for min-replicas-max-lag.&quot;; goto loaderr;
720              }
721          } else if (!strcasecmp(argv[0],&quot;notify-keyspace-events&quot;) &amp;&amp; argc == 2) {
722              int flags = keyspaceEventsStringToFlags(argv[1]);
723              if (flags == -1) {
724                  err = &quot;Invalid event class character. Use &#x27;g$lshzxeA&#x27;.&quot;;
725                  goto loaderr;
726              }
727              server.notify_keyspace_events = flags;
728          } else if (!strcasecmp(argv[0],&quot;supervised&quot;) &amp;&amp; argc == 2) {
729              server.supervised_mode =
730                  configEnumGetValue(supervised_mode_enum,argv[1]);
731              if (server.supervised_mode == INT_MIN) {
732                  err = &quot;Invalid option for &#x27;supervised&#x27;. &quot;
733                      &quot;Allowed values: &#x27;upstart&#x27;, &#x27;systemd&#x27;, &#x27;auto&#x27;, or &#x27;no&#x27;&quot;;
734                  goto loaderr;
735              }
736          } else if (!strcasecmp(argv[0],&quot;loadmodule&quot;) &amp;&amp; argc &gt;= 2) {
737              queueLoadModule(argv[1],&amp;argv[2],argc-2);
738          } else if (!strcasecmp(argv[0],&quot;sentinel&quot;)) {
739              if (argc != 1) {
740                  if (!server.sentinel_mode) {
741                      err = &quot;sentinel directive while not in sentinel mode&quot;;
742                      goto loaderr;
743                  }
744                  err = sentinelHandleConfiguration(argv+1,argc-1);
745                  if (err) goto loaderr;
746              }
747  #ifdef _WIN32
748          } else if (!strcasecmp(argv[0], &quot;service-name&quot;)) {
749          } else if (!strcasecmp(argv[0], &quot;persistence-available&quot;)) {
750              if (strcasecmp(argv[1], &quot;no&quot;) == 0) {
751                  int retval;
752                  sds bgsave;
753                  sds bgrewriteaof;
754                  sds replconf;
755                  sds psync;
756                  sds sync;
757                  bgsave = sdsnew(&quot;bgsave&quot;);
758                  bgrewriteaof = sdsnew(&quot;bgrewriteaof&quot;);
759                  replconf = sdsnew(&quot;replconf&quot;);
760                  psync = sdsnew(&quot;psync&quot;);
761                  sync = sdsnew(&quot;sync&quot;);
762                  retval = dictDelete(server.commands, bgsave);
763                  serverAssert(retval == DICT_OK);
764                  retval = dictDelete(server.commands, bgrewriteaof);
765                  serverAssert(retval == DICT_OK);
766                  retval = dictDelete(server.commands, replconf);
767                  serverAssert(retval == DICT_OK);
768                  retval = dictDelete(server.commands, psync);
769                  serverAssert(retval == DICT_OK);
770                  retval = dictDelete(server.commands, sync);
771                  serverAssert(retval == DICT_OK);
772                  sdsfree(bgsave);
773                  sdsfree(bgrewriteaof);
774                  sdsfree(replconf);
775                  sdsfree(psync);
776                  sdsfree(sync);
777              }
778  #endif
779          } else {
780              err = &quot;Bad directive or wrong number of arguments&quot;; goto loaderr;
781          }
782          sdsfreesplitres(argv,argc);
783      }
784      if (server.cluster_enabled &amp;&amp; server.masterhost) {
785          linenum = slaveof_linenum;
786          i = linenum-1;
787          err = &quot;replicaof directive not allowed in cluster mode&quot;;
788          goto loaderr;
789      }
790      sdsfreesplitres(lines,totlines);
791      return;
792  loaderr:
793  #ifdef _WIN32
794      serverLog(LL_WARNING, &quot;\n*** FATAL CONFIG FILE ERROR ***\n&quot;);
795      serverLog(LL_WARNING, &quot;Reading the configuration file, at line %d\n&quot;, linenum);
796      serverLog(LL_WARNING, &quot;&gt;&gt;&gt; &#x27;%s&#x27;\n&quot;, lines[i]);
797      serverLog(LL_WARNING, &quot;%s\n&quot;, err);
798  #else
799      fprintf(stderr, &quot;\n*** FATAL CONFIG FILE ERROR ***\n&quot;);
800      fprintf(stderr, &quot;Reading the configuration file, at line %d\n&quot;, linenum);
801      fprintf(stderr, &quot;&gt;&gt;&gt; &#x27;%s&#x27;\n&quot;, lines[i]);
802      fprintf(stderr, &quot;%s\n&quot;, err);
803  #endif
804      exit(1);
805  }
806  void loadServerConfig(char *filename, char *options) {
807      sds config = sdsempty();
808      char buf[CONFIG_MAX_LINE+1];
809      if (filename) {
810          FILE *fp;
811          if (filename[0] == &#x27;-&#x27; &amp;&amp; filename[1] == &#x27;\0&#x27;) {
812              fp = stdin;
813          } else {
814              if ((fp = fopen(filename,IF_WIN32(&quot;rb&quot;,&quot;r&quot;))) == NULL) {
815                  serverLog(LL_WARNING,
816                      &quot;Fatal error, can&#x27;t open config file &#x27;%s&#x27;&quot;, filename);
817                  exit(1);
818              }
819          }
820          while(fgets(buf,CONFIG_MAX_LINE+1,fp) != NULL)
821              config = sdscat(config,buf);
822          if (fp != stdin) fclose(fp);
823      }
824      if (options) {
825          config = sdscat(config,&quot;\n&quot;);
826          config = sdscat(config,options);
827      }
828      loadServerConfigFromString(config);
829      sdsfree(config);
830  }
831  #define config_set_bool_field(_name,_var) \
832      } else if (!strcasecmp(c-&gt;argv[2]-&gt;ptr,_name)) { \
833          int yn = yesnotoi(o-&gt;ptr); \
834          if (yn == -1) goto badfmt; \
835          _var = yn;
836  #define config_set_numerical_field(_name,_var,min,max) \
837      } else if (!strcasecmp(c-&gt;argv[2]-&gt;ptr,_name)) { \
838          if (getLongLongFromObject(o,&amp;ll) == C_ERR) goto badfmt; \
839          if (min != LLONG_MIN &amp;&amp; ll &lt; min) goto badfmt; \
840          if (max != LLONG_MAX &amp;&amp; ll &gt; max) goto badfmt; \
841          _var = ll;
842  #define config_set_memory_field(_name,_var) \
843      } else if (!strcasecmp(c-&gt;argv[2]-&gt;ptr,_name)) { \
844          ll = memtoll(o-&gt;ptr,&amp;err); \
845          if (err || ll &lt; 0) goto badfmt; \
846          _var = ll;
847  #define config_set_enum_field(_name,_var,_enumvar) \
848      } else if (!strcasecmp(c-&gt;argv[2]-&gt;ptr,_name)) { \
849          int enumval = configEnumGetValue(_enumvar,o-&gt;ptr); \
850          if (enumval == INT_MIN) goto badfmt; \
851          _var = enumval;
852  #define config_set_special_field(_name) \
853      } else if (!strcasecmp(c-&gt;argv[2]-&gt;ptr,_name)) {
854  #define config_set_special_field_with_alias(_name1,_name2) \
855      } else if (!strcasecmp(c-&gt;argv[2]-&gt;ptr,_name1) || \
856                 !strcasecmp(c-&gt;argv[2]-&gt;ptr,_name2)) {
857  #define config_set_else } else
858  void configSetCommand(client *c) {
859      robj *o;
860      PORT_LONGLONG ll;
861      int err;
862      serverAssertWithInfo(c,c-&gt;argv[2],sdsEncodedObject(c-&gt;argv[2]));
863      serverAssertWithInfo(c,c-&gt;argv[3],sdsEncodedObject(c-&gt;argv[3]));
864      o = c-&gt;argv[3];
865      if (0) { &amp;bsol;* this starts the config_set macros else-if chain. */
866      config_set_special_field(&quot;dbfilename&quot;) {
867          if (!pathIsBaseName(o-&gt;ptr)) {
868              addReplyError(c, &quot;dbfilename can&#x27;t be a path, just a filename&quot;);
869              return;
870          }
871          zfree(server.rdb_filename);
872          server.rdb_filename = zstrdup(o-&gt;ptr);
873      } config_set_special_field(&quot;requirepass&quot;) {
874          if (sdslen(o-&gt;ptr) &gt; CONFIG_AUTHPASS_MAX_LEN) goto badfmt;
875          zfree(server.requirepass);
876          server.requirepass = ((char*)o-&gt;ptr)[0] ? zstrdup(o-&gt;ptr) : NULL;
877      } config_set_special_field(&quot;masterauth&quot;) {
878          zfree(server.masterauth);
879          server.masterauth = ((char*)o-&gt;ptr)[0] ? zstrdup(o-&gt;ptr) : NULL;
880      } config_set_special_field(&quot;cluster-announce-ip&quot;) {
881          zfree(server.cluster_announce_ip);
882          server.cluster_announce_ip = ((char*)o-&gt;ptr)[0] ? zstrdup(o-&gt;ptr) : NULL;
883      } config_set_special_field(&quot;maxclients&quot;) {
884          int orig_value = server.maxclients;
885          if (getLongLongFromObject(o,&amp;ll) == C_ERR || ll &lt; 1) goto badfmt;
886          server.maxclients = (PORT_ULONGLONG)ll;                                            WIN_PORT_FIX &amp;bsol;* cast (PORT_ULONGLONG) */
887          if (ll &gt; orig_value) {
888              adjustOpenFilesLimit();
889              if (server.maxclients != ll) {
890                  addReplyErrorFormat(c,&quot;The operating system is not able to handle the specified number of clients, try with %lld&quot;, server.maxclients);
891                  server.maxclients = orig_value;
892                  return;
893              }
894              if ((unsigned int) aeGetSetSize(server.el) &lt;
895                  server.maxclients + CONFIG_FDSET_INCR)
896              {
897                  if (aeResizeSetSize(server.el,
898                      server.maxclients + CONFIG_FDSET_INCR) == AE_ERR)
899                  {
900                      addReplyError(c,&quot;The event loop API used by Redis is not able to handle the specified number of clients&quot;);
901                      server.maxclients = orig_value;
902                      return;
903                  }
904              }
905          }
906      } config_set_special_field(&quot;appendonly&quot;) {
907          int enable = yesnotoi(o-&gt;ptr);
908          if (enable == -1) goto badfmt;
909          if (enable == 0 &amp;&amp; server.aof_state != AOF_OFF) {
910              stopAppendOnly();
911          } else if (enable &amp;&amp; server.aof_state == AOF_OFF) {
912              if (startAppendOnly() == C_ERR) {
913                  addReplyError(c,
914                      &quot;Unable to turn on AOF. Check server logs.&quot;);
915                  return;
916              }
917          }
918      } config_set_special_field(&quot;save&quot;) {
919          int vlen, j;
920          sds *v = sdssplitlen(o-&gt;ptr,sdslen(o-&gt;ptr),&quot; &quot;,1,&amp;vlen);
921          if (vlen &amp; 1) {
922              sdsfreesplitres(v,vlen);
923              goto badfmt;
924          }
925          for (j = 0; j &lt; vlen; j++) {
926              char *eptr;
927              PORT_LONG val;
928              val = strtoll(v[j], &amp;eptr, 10);
929              if (eptr[0] != &#x27;\0&#x27; ||
930                  ((j &amp; 1) == 0 &amp;&amp; val &lt; 1) ||
931                  ((j &amp; 1) == 1 &amp;&amp; val &lt; 0)) {
932                  sdsfreesplitres(v,vlen);
933                  goto badfmt;
934              }
935          }
936          resetServerSaveParams();
937          for (j = 0; j &lt; vlen; j += 2) {
938              time_t seconds;
939              int changes;
940              seconds = strtoll(v[j],NULL,10);
941              changes = strtoll(v[j+1],NULL,10);
942              appendServerSaveParams(seconds, changes);
943          }
944          sdsfreesplitres(v,vlen);
945      } config_set_special_field(&quot;dir&quot;) {
946          if (chdir((char*)o-&gt;ptr) == -1) {
947              addReplyErrorFormat(c,&quot;Changing directory: %s&quot;, IF_WIN32(wsa_strerror(errno), strerror(errno)));
948              return;
949          }
950      } config_set_special_field(&quot;client-output-buffer-limit&quot;) {
951          int vlen, j;
952          sds *v = sdssplitlen(o-&gt;ptr,sdslen(o-&gt;ptr),&quot; &quot;,1,&amp;vlen);
953          if (vlen % 4) {
954              sdsfreesplitres(v,vlen);
955              goto badfmt;
956          }
957          for (j = 0; j &lt; vlen; j++) {
958              PORT_LONG val;
959              if ((j % 4) == 0) {
960                  int class = getClientTypeByName(v[j]);
961                  if (class == -1 || class == CLIENT_TYPE_MASTER) {
962                      sdsfreesplitres(v,vlen);
963                      goto badfmt;
964                  }
965              } else {
966                  val = memtoll(v[j], &amp;err);
967                  if (err || val &lt; 0) {
968                      sdsfreesplitres(v,vlen);
969                      goto badfmt;
970                  }
971              }
972          }
973          for (j = 0; j &lt; vlen; j += 4) {
974              int class;
975              PORT_ULONGLONG hard, soft;
976              int soft_seconds;
977              class = getClientTypeByName(v[j]);
978              hard = memtoll(v[j+1],NULL);
979              soft = memtoll(v[j+2],NULL);
980              soft_seconds = strtoll(v[j+3],NULL,10);
981              server.client_obuf_limits[class].hard_limit_bytes = hard;
982              server.client_obuf_limits[class].soft_limit_bytes = soft;
983              server.client_obuf_limits[class].soft_limit_seconds = soft_seconds;
984          }
985          sdsfreesplitres(v,vlen);
986      } config_set_special_field(&quot;notify-keyspace-events&quot;) {
987          int flags = keyspaceEventsStringToFlags(o-&gt;ptr);
988          if (flags == -1) goto badfmt;
989          server.notify_keyspace_events = flags;
990      } config_set_special_field_with_alias(&quot;slave-announce-ip&quot;,
991                                            &quot;replica-announce-ip&quot;)
992      {
993          zfree(server.slave_announce_ip);
994          server.slave_announce_ip = ((char*)o-&gt;ptr)[0] ? zstrdup(o-&gt;ptr) : NULL;
995      } config_set_bool_field(
996        &quot;rdbcompression&quot;, server.rdb_compression) {
997      } config_set_bool_field(
998        &quot;repl-disable-tcp-nodelay&quot;,server.repl_disable_tcp_nodelay) {
999      } config_set_bool_field(
1000        &quot;repl-diskless-sync&quot;,server.repl_diskless_sync) {
1001      } config_set_bool_field(
1002        &quot;cluster-require-full-coverage&quot;,server.cluster_require_full_coverage) {
1003      } config_set_bool_field(
1004        &quot;cluster-slave-no-failover&quot;,server.cluster_slave_no_failover) {
1005      } config_set_bool_field(
1006        &quot;cluster-replica-no-failover&quot;,server.cluster_slave_no_failover) {
1007      } config_set_bool_field(
1008        &quot;aof-rewrite-incremental-fsync&quot;,server.aof_rewrite_incremental_fsync) {
1009      } config_set_bool_field(
1010        &quot;rdb-save-incremental-fsync&quot;,server.rdb_save_incremental_fsync) {
1011      } config_set_bool_field(
1012        &quot;aof-load-truncated&quot;,server.aof_load_truncated) {
1013      } config_set_bool_field(
1014        &quot;aof-use-rdb-preamble&quot;,server.aof_use_rdb_preamble) {
1015      } config_set_bool_field(
1016        &quot;slave-serve-stale-data&quot;,server.repl_serve_stale_data) {
1017      } config_set_bool_field(
1018        &quot;replica-serve-stale-data&quot;,server.repl_serve_stale_data) {
1019      } config_set_bool_field(
1020        &quot;slave-read-only&quot;,server.repl_slave_ro) {
1021      } config_set_bool_field(
1022        &quot;replica-read-only&quot;,server.repl_slave_ro) {
1023      } config_set_bool_field(
1024        &quot;slave-ignore-maxmemory&quot;,server.repl_slave_ignore_maxmemory) {
1025      } config_set_bool_field(
1026        &quot;replica-ignore-maxmemory&quot;,server.repl_slave_ignore_maxmemory) {
1027      } config_set_bool_field(
1028        &quot;activerehashing&quot;,server.activerehashing) {
1029      } config_set_bool_field(
1030        &quot;activedefrag&quot;,server.active_defrag_enabled) {
1031  #ifndef HAVE_DEFRAG
1032          if (server.active_defrag_enabled) {
1033              server.active_defrag_enabled = 0;
1034              addReplyError(c,
1035                  &quot;-DISABLED Active defragmentation cannot be enabled: it &quot;
1036                  &quot;requires a Redis server compiled with a modified Jemalloc &quot;
1037                  &quot;like the one shipped by default with the Redis source &quot;
1038                  &quot;distribution&quot;);
1039              return;
1040          }
1041  #endif
1042      } config_set_bool_field(
1043        &quot;protected-mode&quot;,server.protected_mode) {
1044      } config_set_bool_field(
1045        &quot;stop-writes-on-bgsave-error&quot;,server.stop_writes_on_bgsave_err) {
1046      } config_set_bool_field(
1047        &quot;lazyfree-lazy-eviction&quot;,server.lazyfree_lazy_eviction) {
1048      } config_set_bool_field(
1049        &quot;lazyfree-lazy-expire&quot;,server.lazyfree_lazy_expire) {
1050      } config_set_bool_field(
1051        &quot;lazyfree-lazy-server-del&quot;,server.lazyfree_lazy_server_del) {
1052      } config_set_bool_field(
1053        &quot;slave-lazy-flush&quot;,server.repl_slave_lazy_flush) {
1054      } config_set_bool_field(
1055        &quot;replica-lazy-flush&quot;,server.repl_slave_lazy_flush) {
1056      } config_set_bool_field(
1057        &quot;no-appendfsync-on-rewrite&quot;,server.aof_no_fsync_on_rewrite) {
1058      } config_set_bool_field(
1059        &quot;dynamic-hz&quot;,server.dynamic_hz) {
1060      } config_set_numerical_field(
1061        &quot;tcp-keepalive&quot;,server.tcpkeepalive,0,INT_MAX) {
1062      } config_set_numerical_field(
1063        &quot;maxmemory-samples&quot;,server.maxmemory_samples,1,INT_MAX) {
1064      } config_set_numerical_field(
1065        &quot;lfu-log-factor&quot;,server.lfu_log_factor,0,INT_MAX) {
1066      } config_set_numerical_field(
1067        &quot;lfu-decay-time&quot;,server.lfu_decay_time,0,INT_MAX) {
1068      } config_set_numerical_field(
1069        &quot;timeout&quot;,server.maxidletime,0,INT_MAX) {
1070      } config_set_numerical_field(
1071        &quot;active-defrag-threshold-lower&quot;,server.active_defrag_threshold_lower,0,1000) {
1072      } config_set_numerical_field(
1073        &quot;active-defrag-threshold-upper&quot;,server.active_defrag_threshold_upper,0,1000) {
1074      } config_set_memory_field(
1075        &quot;active-defrag-ignore-bytes&quot;,server.active_defrag_ignore_bytes) {
1076      } config_set_numerical_field(
1077        &quot;active-defrag-cycle-min&quot;,server.active_defrag_cycle_min,1,99) {
1078      } config_set_numerical_field(
1079        &quot;active-defrag-cycle-max&quot;,server.active_defrag_cycle_max,1,99) {
1080      } config_set_numerical_field(
1081        &quot;active-defrag-max-scan-fields&quot;,server.active_defrag_max_scan_fields,1,LONG_MAX) {
1082      } config_set_numerical_field(
1083        &quot;auto-aof-rewrite-percentage&quot;,server.aof_rewrite_perc,0,INT_MAX){
1084      } config_set_numerical_field(
1085        &quot;hash-max-ziplist-entries&quot;,server.hash_max_ziplist_entries,0,LONG_MAX) {
1086      } config_set_numerical_field(
1087        &quot;hash-max-ziplist-value&quot;,server.hash_max_ziplist_value,0,LONG_MAX) {
1088      } config_set_numerical_field(
1089        &quot;stream-node-max-bytes&quot;,server.stream_node_max_bytes,0,LONG_MAX) {
1090      } config_set_numerical_field(
1091        &quot;stream-node-max-entries&quot;,server.stream_node_max_entries,0,LLONG_MAX) {
1092      } config_set_numerical_field(
1093        &quot;list-max-ziplist-size&quot;,server.list_max_ziplist_size,INT_MIN,INT_MAX) {
1094      } config_set_numerical_field(
1095        &quot;list-compress-depth&quot;,server.list_compress_depth,0,INT_MAX) {
1096      } config_set_numerical_field(
1097        &quot;set-max-intset-entries&quot;,server.set_max_intset_entries,0,LONG_MAX) {
1098      } config_set_numerical_field(
1099        &quot;zset-max-ziplist-entries&quot;,server.zset_max_ziplist_entries,0,LONG_MAX) {
1100      } config_set_numerical_field(
1101        &quot;zset-max-ziplist-value&quot;,server.zset_max_ziplist_value,0,LONG_MAX) {
1102      } config_set_numerical_field(
1103        &quot;hll-sparse-max-bytes&quot;,server.hll_sparse_max_bytes,0,LONG_MAX) {
1104      } config_set_numerical_field(
1105        &quot;lua-time-limit&quot;,server.lua_time_limit,0,LONG_MAX) {
1106      } config_set_numerical_field(
1107        &quot;slowlog-log-slower-than&quot;,server.slowlog_log_slower_than,-1,LLONG_MAX) {
1108      } config_set_numerical_field(
1109        &quot;slowlog-max-len&quot;,ll,0,LONG_MAX) {
1110          server.slowlog_max_len = (PORT_ULONG)ll;
1111      } config_set_numerical_field(
1112        &quot;latency-monitor-threshold&quot;,server.latency_monitor_threshold,0,LLONG_MAX){
1113      } config_set_numerical_field(
1114        &quot;repl-ping-slave-period&quot;,server.repl_ping_slave_period,1,INT_MAX) {
1115      } config_set_numerical_field(
1116        &quot;repl-ping-replica-period&quot;,server.repl_ping_slave_period,1,INT_MAX) {
1117      } config_set_numerical_field(
1118        &quot;repl-timeout&quot;,server.repl_timeout,1,INT_MAX) {
1119      } config_set_numerical_field(
1120        &quot;repl-backlog-ttl&quot;,server.repl_backlog_time_limit,0,LONG_MAX) {
1121      } config_set_numerical_field(
1122        &quot;repl-diskless-sync-delay&quot;,server.repl_diskless_sync_delay,0,INT_MAX) {
1123      } config_set_numerical_field(
1124        &quot;slave-priority&quot;,server.slave_priority,0,INT_MAX) {
1125      } config_set_numerical_field(
1126        &quot;replica-priority&quot;,server.slave_priority,0,INT_MAX) {
1127      } config_set_numerical_field(
1128        &quot;slave-announce-port&quot;,server.slave_announce_port,0,65535) {
1129      } config_set_numerical_field(
1130        &quot;replica-announce-port&quot;,server.slave_announce_port,0,65535) {
1131      } config_set_numerical_field(
1132        &quot;min-slaves-to-write&quot;,server.repl_min_slaves_to_write,0,INT_MAX) {
1133          refreshGoodSlavesCount();
1134      } config_set_numerical_field(
1135        &quot;min-replicas-to-write&quot;,server.repl_min_slaves_to_write,0,INT_MAX) {
1136          refreshGoodSlavesCount();
1137      } config_set_numerical_field(
1138        &quot;min-slaves-max-lag&quot;,server.repl_min_slaves_max_lag,0,INT_MAX) {
1139          refreshGoodSlavesCount();
1140      } config_set_numerical_field(
1141        &quot;min-replicas-max-lag&quot;,server.repl_min_slaves_max_lag,0,INT_MAX) {
1142          refreshGoodSlavesCount();
1143      } config_set_numerical_field(
1144        &quot;cluster-node-timeout&quot;,server.cluster_node_timeout,0,LLONG_MAX) {
1145      } config_set_numerical_field(
1146        &quot;cluster-announce-port&quot;,server.cluster_announce_port,0,65535) {
1147      } config_set_numerical_field(
1148        &quot;cluster-announce-bus-port&quot;,server.cluster_announce_bus_port,0,65535) {
1149      } config_set_numerical_field(
1150        &quot;cluster-migration-barrier&quot;,server.cluster_migration_barrier,0,INT_MAX){
1151      } config_set_numerical_field(
1152        &quot;cluster-slave-validity-factor&quot;,server.cluster_slave_validity_factor,0,INT_MAX) {
1153      } config_set_numerical_field(
1154        &quot;cluster-replica-validity-factor&quot;,server.cluster_slave_validity_factor,0,INT_MAX) {
1155      } config_set_numerical_field(
1156        &quot;hz&quot;,server.config_hz,0,INT_MAX) {
1157          if (server.config_hz &lt; CONFIG_MIN_HZ) server.config_hz = CONFIG_MIN_HZ;
1158          if (server.config_hz &gt; CONFIG_MAX_HZ) server.config_hz = CONFIG_MAX_HZ;
1159      } config_set_numerical_field(
1160        &quot;watchdog-period&quot;,ll,0,INT_MAX) {
1161          if (ll)
1162              enableWatchdog(ll);
1163          else
1164              disableWatchdog();
1165      } config_set_memory_field(&quot;maxmemory&quot;,server.maxmemory) {
1166          if (server.maxmemory) {
1167              if (server.maxmemory &lt; zmalloc_used_memory()) {
1168                  serverLog(LL_WARNING,&quot;WARNING: the new maxmemory value set via CONFIG SET is smaller than the current memory usage. This will result in key eviction and/or the inability to accept new write commands depending on the maxmemory-policy.&quot;);
1169              }
1170              freeMemoryIfNeededAndSafe();
1171          }
1172      } config_set_memory_field(
1173        &quot;proto-max-bulk-len&quot;,server.proto_max_bulk_len) {
1174      } config_set_memory_field(
1175        &quot;client-query-buffer-limit&quot;,server.client_max_querybuf_len) {
1176      } config_set_memory_field(&quot;repl-backlog-size&quot;,ll) {
1177          resizeReplicationBacklog(ll);
1178      } config_set_memory_field(&quot;auto-aof-rewrite-min-size&quot;,ll) {
1179          server.aof_rewrite_min_size = ll;
1180      } config_set_enum_field(
1181        &quot;loglevel&quot;,server.verbosity,loglevel_enum) {
1182  #ifdef _WIN32
1183          setLogVerbosityLevel(server.verbosity);
1184  #endif
1185      } config_set_enum_field(
1186        &quot;maxmemory-policy&quot;,server.maxmemory_policy,maxmemory_policy_enum) {
1187      } config_set_enum_field(
1188        &quot;appendfsync&quot;,server.aof_fsync,aof_fsync_enum) {
1189      } config_set_else {
1190          addReplyErrorFormat(c,&quot;Unsupported CONFIG parameter: %s&quot;,
1191              (char*)c-&gt;argv[2]-&gt;ptr);
1192          return;
1193      }
1194      addReply(c,shared.ok);
1195      return;
1196  badfmt: &amp;bsol;* Bad format errors */
1197      addReplyErrorFormat(c,&quot;Invalid argument &#x27;%s&#x27; for CONFIG SET &#x27;%s&#x27;&quot;,
1198              (char*)o-&gt;ptr,
1199              (char*)c-&gt;argv[2]-&gt;ptr);
1200  }
1201  #define config_get_string_field(_name,_var) do { \
1202      if (stringmatch(pattern,_name,1)) { \
1203          addReplyBulkCString(c,_name); \
1204          addReplyBulkCString(c,_var ? _var : &quot;&quot;); \
1205          matches++; \
1206      } \
1207  } while(0);
1208  #define config_get_bool_field(_name,_var) do { \
1209      if (stringmatch(pattern,_name,1)) { \
1210          addReplyBulkCString(c,_name); \
1211          addReplyBulkCString(c,_var ? &quot;yes&quot; : &quot;no&quot;); \
1212          matches++; \
1213      } \
1214  } while(0);
1215  #define config_get_numerical_field(_name,_var) do { \
1216      if (stringmatch(pattern,_name,1)) { \
1217          ll2string(buf,sizeof(buf),_var); \
1218          addReplyBulkCString(c,_name); \
1219          addReplyBulkCString(c,buf); \
1220          matches++; \
1221      } \
1222  } while(0);
1223  #define config_get_enum_field(_name,_var,_enumvar) do { \
1224      if (stringmatch(pattern,_name,1)) { \
1225          addReplyBulkCString(c,_name); \
1226          addReplyBulkCString(c,configEnumGetNameOrUnknown(_enumvar,_var)); \
1227          matches++; \
1228      } \
1229  } while(0);
1230  void configGetCommand(client *c) {
1231      robj *o = c-&gt;argv[2];
1232      void *replylen = addDeferredMultiBulkLength(c);
1233      char *pattern = o-&gt;ptr;
1234      char buf[128];
1235      int matches = 0;
1236      serverAssertWithInfo(c,o,sdsEncodedObject(o));
1237      config_get_string_field(&quot;dbfilename&quot;,server.rdb_filename);
1238      config_get_string_field(&quot;requirepass&quot;,server.requirepass);
1239      config_get_string_field(&quot;masterauth&quot;,server.masterauth);
1240      config_get_string_field(&quot;cluster-announce-ip&quot;,server.cluster_announce_ip);
1241      config_get_string_field(&quot;unixsocket&quot;,server.unixsocket);
1242      config_get_string_field(&quot;logfile&quot;,server.logfile);
1243      config_get_string_field(&quot;pidfile&quot;,server.pidfile);
1244      config_get_string_field(&quot;slave-announce-ip&quot;,server.slave_announce_ip);
1245      config_get_string_field(&quot;replica-announce-ip&quot;,server.slave_announce_ip);
1246      config_get_numerical_field(&quot;maxmemory&quot;,server.maxmemory);
1247      config_get_numerical_field(&quot;proto-max-bulk-len&quot;,server.proto_max_bulk_len);
1248      config_get_numerical_field(&quot;client-query-buffer-limit&quot;,server.client_max_querybuf_len);
1249      config_get_numerical_field(&quot;maxmemory-samples&quot;,server.maxmemory_samples);
1250      config_get_numerical_field(&quot;lfu-log-factor&quot;,server.lfu_log_factor);
1251      config_get_numerical_field(&quot;lfu-decay-time&quot;,server.lfu_decay_time);
1252      config_get_numerical_field(&quot;timeout&quot;,server.maxidletime);
1253      config_get_numerical_field(&quot;active-defrag-threshold-lower&quot;,server.active_defrag_threshold_lower);
1254      config_get_numerical_field(&quot;active-defrag-threshold-upper&quot;,server.active_defrag_threshold_upper);
1255      config_get_numerical_field(&quot;active-defrag-ignore-bytes&quot;,server.active_defrag_ignore_bytes);
1256      config_get_numerical_field(&quot;active-defrag-cycle-min&quot;,server.active_defrag_cycle_min);
1257      config_get_numerical_field(&quot;active-defrag-cycle-max&quot;,server.active_defrag_cycle_max);
1258      config_get_numerical_field(&quot;active-defrag-max-scan-fields&quot;,server.active_defrag_max_scan_fields);
1259      config_get_numerical_field(&quot;auto-aof-rewrite-percentage&quot;,
1260              server.aof_rewrite_perc);
1261      config_get_numerical_field(&quot;auto-aof-rewrite-min-size&quot;,
1262              server.aof_rewrite_min_size);
1263      config_get_numerical_field(&quot;hash-max-ziplist-entries&quot;,
1264              server.hash_max_ziplist_entries);
1265      config_get_numerical_field(&quot;hash-max-ziplist-value&quot;,
1266              server.hash_max_ziplist_value);
1267      config_get_numerical_field(&quot;stream-node-max-bytes&quot;,
1268              server.stream_node_max_bytes);
1269      config_get_numerical_field(&quot;stream-node-max-entries&quot;,
1270              server.stream_node_max_entries);
1271      config_get_numerical_field(&quot;list-max-ziplist-size&quot;,
1272              server.list_max_ziplist_size);
1273      config_get_numerical_field(&quot;list-compress-depth&quot;,
1274              server.list_compress_depth);
1275      config_get_numerical_field(&quot;set-max-intset-entries&quot;,
1276              server.set_max_intset_entries);
1277      config_get_numerical_field(&quot;zset-max-ziplist-entries&quot;,
1278              server.zset_max_ziplist_entries);
1279      config_get_numerical_field(&quot;zset-max-ziplist-value&quot;,
1280              server.zset_max_ziplist_value);
1281      config_get_numerical_field(&quot;hll-sparse-max-bytes&quot;,
1282              server.hll_sparse_max_bytes);
1283      config_get_numerical_field(&quot;lua-time-limit&quot;,server.lua_time_limit);
1284      config_get_numerical_field(&quot;slowlog-log-slower-than&quot;,
1285              server.slowlog_log_slower_than);
1286      config_get_numerical_field(&quot;latency-monitor-threshold&quot;,
1287              server.latency_monitor_threshold);
1288      config_get_numerical_field(&quot;slowlog-max-len&quot;,
1289              server.slowlog_max_len);
1290      config_get_numerical_field(&quot;port&quot;,server.port);
1291      config_get_numerical_field(&quot;cluster-announce-port&quot;,server.cluster_announce_port);
1292      config_get_numerical_field(&quot;cluster-announce-bus-port&quot;,server.cluster_announce_bus_port);
1293      config_get_numerical_field(&quot;tcp-backlog&quot;,server.tcp_backlog);
1294      config_get_numerical_field(&quot;databases&quot;,server.dbnum);
1295      config_get_numerical_field(&quot;repl-ping-slave-period&quot;,server.repl_ping_slave_period);
1296      config_get_numerical_field(&quot;repl-ping-replica-period&quot;,server.repl_ping_slave_period);
1297      config_get_numerical_field(&quot;repl-timeout&quot;,server.repl_timeout);
1298      config_get_numerical_field(&quot;repl-backlog-size&quot;,server.repl_backlog_size);
1299      config_get_numerical_field(&quot;repl-backlog-ttl&quot;,server.repl_backlog_time_limit);
1300      config_get_numerical_field(&quot;maxclients&quot;,server.maxclients);
1301      config_get_numerical_field(&quot;watchdog-period&quot;,server.watchdog_period);
1302      config_get_numerical_field(&quot;slave-priority&quot;,server.slave_priority);
1303      config_get_numerical_field(&quot;replica-priority&quot;,server.slave_priority);
1304      config_get_numerical_field(&quot;slave-announce-port&quot;,server.slave_announce_port);
1305      config_get_numerical_field(&quot;replica-announce-port&quot;,server.slave_announce_port);
1306      config_get_numerical_field(&quot;min-slaves-to-write&quot;,server.repl_min_slaves_to_write);
1307      config_get_numerical_field(&quot;min-replicas-to-write&quot;,server.repl_min_slaves_to_write);
1308      config_get_numerical_field(&quot;min-slaves-max-lag&quot;,server.repl_min_slaves_max_lag);
1309      config_get_numerical_field(&quot;min-replicas-max-lag&quot;,server.repl_min_slaves_max_lag);
1310      config_get_numerical_field(&quot;hz&quot;,server.config_hz);
1311      config_get_numerical_field(&quot;cluster-node-timeout&quot;,server.cluster_node_timeout);
1312      config_get_numerical_field(&quot;cluster-migration-barrier&quot;,server.cluster_migration_barrier);
1313      config_get_numerical_field(&quot;cluster-slave-validity-factor&quot;,server.cluster_slave_validity_factor);
1314      config_get_numerical_field(&quot;cluster-replica-validity-factor&quot;,server.cluster_slave_validity_factor);
1315      config_get_numerical_field(&quot;repl-diskless-sync-delay&quot;,server.repl_diskless_sync_delay);
1316      config_get_numerical_field(&quot;tcp-keepalive&quot;,server.tcpkeepalive);
1317      config_get_bool_field(&quot;cluster-require-full-coverage&quot;,
1318              server.cluster_require_full_coverage);
1319      config_get_bool_field(&quot;cluster-slave-no-failover&quot;,
1320              server.cluster_slave_no_failover);
1321      config_get_bool_field(&quot;cluster-replica-no-failover&quot;,
1322              server.cluster_slave_no_failover);
1323      config_get_bool_field(&quot;no-appendfsync-on-rewrite&quot;,
1324              server.aof_no_fsync_on_rewrite);
1325      config_get_bool_field(&quot;slave-serve-stale-data&quot;,
1326              server.repl_serve_stale_data);
1327      config_get_bool_field(&quot;replica-serve-stale-data&quot;,
1328              server.repl_serve_stale_data);
1329      config_get_bool_field(&quot;slave-read-only&quot;,
1330              server.repl_slave_ro);
1331      config_get_bool_field(&quot;replica-read-only&quot;,
1332              server.repl_slave_ro);
1333      config_get_bool_field(&quot;slave-ignore-maxmemory&quot;,
1334              server.repl_slave_ignore_maxmemory);
1335      config_get_bool_field(&quot;replica-ignore-maxmemory&quot;,
1336              server.repl_slave_ignore_maxmemory);
1337      config_get_bool_field(&quot;stop-writes-on-bgsave-error&quot;,
1338              server.stop_writes_on_bgsave_err);
1339      config_get_bool_field(&quot;daemonize&quot;, server.daemonize);
1340      config_get_bool_field(&quot;rdbcompression&quot;, server.rdb_compression);
1341      config_get_bool_field(&quot;rdbchecksum&quot;, server.rdb_checksum);
1342      config_get_bool_field(&quot;activerehashing&quot;, server.activerehashing);
1343      config_get_bool_field(&quot;activedefrag&quot;, server.active_defrag_enabled);
1344      config_get_bool_field(&quot;protected-mode&quot;, server.protected_mode);
1345      config_get_bool_field(&quot;repl-disable-tcp-nodelay&quot;,
1346              server.repl_disable_tcp_nodelay);
1347      config_get_bool_field(&quot;repl-diskless-sync&quot;,
1348              server.repl_diskless_sync);
1349      config_get_bool_field(&quot;aof-rewrite-incremental-fsync&quot;,
1350              server.aof_rewrite_incremental_fsync);
1351      config_get_bool_field(&quot;rdb-save-incremental-fsync&quot;,
1352              server.rdb_save_incremental_fsync);
1353      config_get_bool_field(&quot;aof-load-truncated&quot;,
1354              server.aof_load_truncated);
1355      config_get_bool_field(&quot;aof-use-rdb-preamble&quot;,
1356              server.aof_use_rdb_preamble);
1357      config_get_bool_field(&quot;lazyfree-lazy-eviction&quot;,
1358              server.lazyfree_lazy_eviction);
1359      config_get_bool_field(&quot;lazyfree-lazy-expire&quot;,
1360              server.lazyfree_lazy_expire);
1361      config_get_bool_field(&quot;lazyfree-lazy-server-del&quot;,
1362              server.lazyfree_lazy_server_del);
1363      config_get_bool_field(&quot;slave-lazy-flush&quot;,
1364              server.repl_slave_lazy_flush);
1365      config_get_bool_field(&quot;replica-lazy-flush&quot;,
1366              server.repl_slave_lazy_flush);
1367      config_get_bool_field(&quot;dynamic-hz&quot;,
1368              server.dynamic_hz);
1369      config_get_enum_field(&quot;maxmemory-policy&quot;,
1370              server.maxmemory_policy,maxmemory_policy_enum);
1371      config_get_enum_field(&quot;loglevel&quot;,
1372              server.verbosity,loglevel_enum);
1373      config_get_enum_field(&quot;supervised&quot;,
1374              server.supervised_mode,supervised_mode_enum);
1375      config_get_enum_field(&quot;appendfsync&quot;,
1376              server.aof_fsync,aof_fsync_enum);
1377  #ifndef _WIN32
1378      config_get_enum_field(&quot;syslog-facility&quot;,
1379              server.syslog_facility,syslog_facility_enum);
1380  #endif
1381      if (stringmatch(pattern,&quot;appendonly&quot;,1)) {
1382          addReplyBulkCString(c,&quot;appendonly&quot;);
1383          addReplyBulkCString(c,server.aof_state == AOF_OFF ? &quot;no&quot; : &quot;yes&quot;);
1384          matches++;
1385      }
1386      if (stringmatch(pattern,&quot;dir&quot;,1)) {
1387          char buf[1024];
1388          if (getcwd(buf,sizeof(buf)) == NULL)
1389              buf[0] = &#x27;\0&#x27;;
1390          addReplyBulkCString(c,&quot;dir&quot;);
1391          addReplyBulkCString(c,buf);
1392          matches++;
1393      }
1394      if (stringmatch(pattern,&quot;save&quot;,1)) {
1395          sds buf = sdsempty();
1396          int j;
1397          for (j = 0; j &lt; server.saveparamslen; j++) {
1398              buf = sdscatprintf(buf,&quot;%jd %d&quot;,
1399                      (intmax_t)server.saveparams[j].seconds,
1400                      server.saveparams[j].changes);
1401              if (j != server.saveparamslen-1)
1402                  buf = sdscatlen(buf,&quot; &quot;,1);
1403          }
1404          addReplyBulkCString(c,&quot;save&quot;);
1405          addReplyBulkCString(c,buf);
1406          sdsfree(buf);
1407          matches++;
1408      }
1409      if (stringmatch(pattern,&quot;client-output-buffer-limit&quot;,1)) {
1410          sds buf = sdsempty();
1411          int j;
1412          for (j = 0; j &lt; CLIENT_TYPE_OBUF_COUNT; j++) {
1413              buf = sdscatprintf(buf,&quot;%s %llu %llu %Id&quot;,                                WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
1414                      getClientTypeName(j),
1415                      server.client_obuf_limits[j].hard_limit_bytes,
1416                      server.client_obuf_limits[j].soft_limit_bytes,
1417                      (PORT_LONG) server.client_obuf_limits[j].soft_limit_seconds);
1418              if (j != CLIENT_TYPE_OBUF_COUNT-1)
1419                  buf = sdscatlen(buf,&quot; &quot;,1);
1420          }
1421          addReplyBulkCString(c,&quot;client-output-buffer-limit&quot;);
1422          addReplyBulkCString(c,buf);
1423          sdsfree(buf);
1424          matches++;
1425      }
1426      if (stringmatch(pattern,&quot;unixsocketperm&quot;,1)) {
1427          char buf[32];
1428          snprintf(buf,sizeof(buf),&quot;%o&quot;,server.unixsocketperm);
1429          addReplyBulkCString(c,&quot;unixsocketperm&quot;);
1430          addReplyBulkCString(c,buf);
1431          matches++;
1432      }
1433      if (stringmatch(pattern,&quot;slaveof&quot;,1) ||
1434          stringmatch(pattern,&quot;replicaof&quot;,1))
1435      {
1436          char *optname = stringmatch(pattern,&quot;slaveof&quot;,1) ?
1437                          &quot;slaveof&quot; : &quot;replicaof&quot;;
1438          char buf[256];
1439          addReplyBulkCString(c,optname);
1440          if (server.masterhost)
1441              snprintf(buf,sizeof(buf),&quot;%s %d&quot;,
1442                  server.masterhost, server.masterport);
1443          else
1444              buf[0] = &#x27;\0&#x27;;
1445          addReplyBulkCString(c,buf);
1446          matches++;
1447      }
1448      if (stringmatch(pattern,&quot;notify-keyspace-events&quot;,1)) {
1449          robj *flagsobj = createObject(OBJ_STRING,
1450              keyspaceEventsFlagsToString(server.notify_keyspace_events));
1451          addReplyBulkCString(c,&quot;notify-keyspace-events&quot;);
1452          addReplyBulk(c,flagsobj);
1453          decrRefCount(flagsobj);
1454          matches++;
1455      }
1456      if (stringmatch(pattern,&quot;bind&quot;,1)) {
1457          sds aux = sdsjoin(server.bindaddr,server.bindaddr_count,&quot; &quot;);
1458          addReplyBulkCString(c,&quot;bind&quot;);
1459          addReplyBulkCString(c,aux);
1460          sdsfree(aux);
1461          matches++;
1462      }
1463      setDeferredMultiBulkLength(c,replylen,(PORT_LONG)matches*2);  WIN_PORT_FIX &amp;bsol;* cat (PORT_LONG) */
1464  }
1465  #define REDIS_CONFIG_REWRITE_SIGNATURE &quot;# Generated by CONFIG REWRITE&quot;
1466  uint64_t dictSdsCaseHash(const void *key);
1467  int dictSdsKeyCaseCompare(void *privdata, const void *key1, const void *key2);
1468  void dictSdsDestructor(void *privdata, void *val);
1469  void dictListDestructor(void *privdata, void *val);
1470  void rewriteConfigSentinelOption(struct rewriteConfigState *state);
1471  dictType optionToLineDictType = {
1472      dictSdsCaseHash,            &amp;bsol;* hash function */
1473      NULL,                       &amp;bsol;* key dup */
1474      NULL,                       &amp;bsol;* val dup */
1475      dictSdsKeyCaseCompare,      &amp;bsol;* key compare */
1476      dictSdsDestructor,          &amp;bsol;* key destructor */
1477      dictListDestructor          &amp;bsol;* val destructor */
1478  };
1479  dictType optionSetDictType = {
1480      dictSdsCaseHash,            &amp;bsol;* hash function */
1481      NULL,                       &amp;bsol;* key dup */
1482      NULL,                       &amp;bsol;* val dup */
1483      dictSdsKeyCaseCompare,      &amp;bsol;* key compare */
1484      dictSdsDestructor,          &amp;bsol;* key destructor */
1485      NULL                        &amp;bsol;* val destructor */
1486  };
1487  struct rewriteConfigState {
1488      dict *option_to_line; &amp;bsol;* Option -&gt; list of config file lines map */
1489      dict *rewritten;      &amp;bsol;* Dictionary of already processed options */
1490      int numlines;         &amp;bsol;* Number of lines in current config */
1491      sds *lines;           &amp;bsol;* Current lines as an array of sds strings */
1492      int has_tail;         &amp;bsol;* True if we already added directives that were
1493                               not present in the original config file. */
1494  };
1495  void rewriteConfigAppendLine(struct rewriteConfigState *state, sds line) {
1496      state-&gt;lines = zrealloc(state-&gt;lines, sizeof(char*) * ((PORT_ULONG)state-&gt;numlines+1));  WIN_PORT_FIX &amp;bsol;* cat (PORT_ULONG) */
1497      state-&gt;lines[state-&gt;numlines++] = line;
1498  }
1499  void rewriteConfigAddLineNumberToOption(struct rewriteConfigState *state, sds option, int linenum) {
1500      list *l = dictFetchValue(state-&gt;option_to_line,option);
1501      if (l == NULL) {
1502          l = listCreate();
1503          dictAdd(state-&gt;option_to_line,sdsdup(option),l);
1504      }
1505      listAddNodeTail(l,(void*)(PORT_LONG)linenum);
1506  }
1507  void rewriteConfigMarkAsProcessed(struct rewriteConfigState *state, const char *option) {
1508      sds opt = sdsnew(option);
1509      if (dictAdd(state-&gt;rewritten,opt,NULL) != DICT_OK) sdsfree(opt);
1510  }
1511  struct rewriteConfigState *rewriteConfigReadOldFile(char *path) {
1512      FILE *fp = fopen(path,&quot;r&quot;);
1513      if (fp == NULL &amp;&amp; errno != ENOENT) return NULL;
1514      char buf[CONFIG_MAX_LINE+1];
1515      int linenum = -1;
1516      struct rewriteConfigState *state = zmalloc(sizeof(*state));
1517      state-&gt;option_to_line = dictCreate(&amp;optionToLineDictType,NULL);
1518      state-&gt;rewritten = dictCreate(&amp;optionSetDictType,NULL);
1519      state-&gt;numlines = 0;
1520      state-&gt;lines = NULL;
1521      state-&gt;has_tail = 0;
1522      if (fp == NULL) return state;
1523      while(fgets(buf,CONFIG_MAX_LINE+1,fp) != NULL) {
1524          int argc;
1525          sds *argv;
1526          sds line = sdstrim(sdsnew(buf),&quot;\r\n\t &quot;);
1527          linenum++; &amp;bsol;* Zero based, so we init at -1 */
1528          if (line[0] == &#x27;#&#x27; || line[0] == &#x27;\0&#x27;) {
1529              if (!state-&gt;has_tail &amp;&amp; !strcmp(line,REDIS_CONFIG_REWRITE_SIGNATURE))
1530                  state-&gt;has_tail = 1;
1531              rewriteConfigAppendLine(state,line);
1532              continue;
1533          }
1534          argv = sdssplitargs(line,&amp;argc);
1535          if (argv == NULL) {
1536              sds aux = sdsnew(&quot;# ??? &quot;);
1537              aux = sdscatsds(aux,line);
1538              sdsfree(line);
1539              rewriteConfigAppendLine(state,aux);
1540              continue;
1541          }
1542          sdstolower(argv[0]); &amp;bsol;* We only want lowercase config directives. */
1543          rewriteConfigAppendLine(state,line);
1544          char *p = strstr(argv[0],&quot;slave&quot;);
1545          if (p) {
1546              sds alt = sdsempty();
1547              alt = sdscatlen(alt,argv[0],p-argv[0]);;
1548              alt = sdscatlen(alt,&quot;replica&quot;,7);
1549              alt = sdscatlen(alt,p+5,strlen(p+5));
1550              sdsfree(argv[0]);
1551              argv[0] = alt;
1552          }
1553          rewriteConfigAddLineNumberToOption(state,argv[0],linenum);
1554          sdsfreesplitres(argv,argc);
1555      }
1556      fclose(fp);
1557      return state;
1558  }
1559  void rewriteConfigRewriteLine(struct rewriteConfigState *state, const char *option, sds line, int force) {
1560      sds o = sdsnew(option);
1561      list *l = dictFetchValue(state-&gt;option_to_line,o);
1562      rewriteConfigMarkAsProcessed(state,option);
1563      if (!l &amp;&amp; !force) {
1564          sdsfree(line);
1565          sdsfree(o);
1566          return;
1567      }
1568      if (l) {
1569          listNode *ln = listFirst(l);
1570          int linenum = (int)((PORT_LONG) ln-&gt;value);                             WIN_PORT_FIX &amp;bsol;* cast (int) */
1571          listDelNode(l,ln);
1572          if (listLength(l) == 0) dictDelete(state-&gt;option_to_line,o);
1573          sdsfree(state-&gt;lines[linenum]);
1574          state-&gt;lines[linenum] = line;
1575      } else {
1576          if (!state-&gt;has_tail) {
1577              rewriteConfigAppendLine(state,
1578                  sdsnew(REDIS_CONFIG_REWRITE_SIGNATURE));
1579              state-&gt;has_tail = 1;
1580          }
1581          rewriteConfigAppendLine(state,line);
1582      }
1583      sdsfree(o);
1584  }
1585  int rewriteConfigFormatMemory(char *buf, size_t len, PORT_LONGLONG bytes) {
1586      int gb = 1024*1024*1024;
1587      int mb = 1024*1024;
1588      int kb = 1024;
1589      if (bytes &amp;&amp; (bytes % gb) == 0) {
1590          return snprintf(buf,len,&quot;%lldgb&quot;,bytes/gb);
1591      } else if (bytes &amp;&amp; (bytes % mb) == 0) {
1592          return snprintf(buf,len,&quot;%lldmb&quot;,bytes/mb);
1593      } else if (bytes &amp;&amp; (bytes % kb) == 0) {
1594          return snprintf(buf,len,&quot;%lldkb&quot;,bytes/kb);
1595      } else {
1596          return snprintf(buf,len,&quot;%lld&quot;,bytes);
1597      }
1598  }
1599  void rewriteConfigBytesOption(struct rewriteConfigState *state, char *option, PORT_LONGLONG value, PORT_LONGLONG defvalue) {
1600      char buf[64];
1601      int force = value != defvalue;
1602      sds line;
1603      rewriteConfigFormatMemory(buf,sizeof(buf),value);
1604      line = sdscatprintf(sdsempty(),&quot;%s %s&quot;,option,buf);
1605      rewriteConfigRewriteLine(state,option,line,force);
1606  }
1607  void rewriteConfigYesNoOption(struct rewriteConfigState *state, char *option, int value, int defvalue) {
1608      int force = value != defvalue;
1609      sds line = sdscatprintf(sdsempty(),&quot;%s %s&quot;,option,
1610          value ? &quot;yes&quot; : &quot;no&quot;);
1611      rewriteConfigRewriteLine(state,option,line,force);
1612  }
1613  void rewriteConfigStringOption(struct rewriteConfigState *state, char *option, char *value, char *defvalue) {
1614      int force = 1;
1615      sds line;
1616      if (value == NULL) {
1617          rewriteConfigMarkAsProcessed(state,option);
1618          return;
1619      }
1620      if (defvalue &amp;&amp; strcmp(value,defvalue) == 0) force = 0;
1621      line = sdsnew(option);
1622      line = sdscatlen(line, &quot; &quot;, 1);
1623      line = sdscatrepr(line, value, strlen(value));
1624      rewriteConfigRewriteLine(state,option,line,force);
1625  }
1626  void rewriteConfigNumericalOption(struct rewriteConfigState *state, char *option, PORT_LONGLONG value, PORT_LONGLONG defvalue) {
1627      int force = value != defvalue;
1628      sds line = sdscatprintf(sdsempty(),&quot;%s %lld&quot;,option,value);
1629      rewriteConfigRewriteLine(state,option,line,force);
1630  }
1631  void rewriteConfigOctalOption(struct rewriteConfigState *state, char *option, int value, int defvalue) {
1632      int force = value != defvalue;
1633      sds line = sdscatprintf(sdsempty(),&quot;%s %o&quot;,option,value);
1634      rewriteConfigRewriteLine(state,option,line,force);
1635  }
1636  void rewriteConfigEnumOption(struct rewriteConfigState *state, char *option, int value, configEnum *ce, int defval) {
1637      sds line;
1638      const char *name = configEnumGetNameOrUnknown(ce,value);
1639      int force = value != defval;
1640      line = sdscatprintf(sdsempty(),&quot;%s %s&quot;,option,name);
1641      rewriteConfigRewriteLine(state,option,line,force);
1642  }
1643  #ifndef _WIN32
1644  void rewriteConfigSyslogfacilityOption(struct rewriteConfigState *state) {
1645      int value = server.syslog_facility;
1646      int force = value != LOG_LOCAL0;
1647      const char *name = NULL, *option = &quot;syslog-facility&quot;;
1648      sds line;
1649      name = configEnumGetNameOrUnknown(syslog_facility_enum,value);
1650      line = sdscatprintf(sdsempty(),&quot;%s %s&quot;,option,name);
1651      rewriteConfigRewriteLine(state,option,line,force);
1652  }
1653  #endif
1654  void rewriteConfigSaveOption(struct rewriteConfigState *state) {
1655      int j;
1656      sds line;
1657      for (j = 0; j &lt; server.saveparamslen; j++) {
1658          line = sdscatprintf(sdsempty(),&quot;save %Id %d&quot;,                                      WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
1659              (PORT_LONG) server.saveparams[j].seconds, server.saveparams[j].changes);
1660          rewriteConfigRewriteLine(state,&quot;save&quot;,line,1);
1661      }
1662      rewriteConfigMarkAsProcessed(state,&quot;save&quot;);
1663  }
1664  void rewriteConfigDirOption(struct rewriteConfigState *state) {
1665      char cwd[1024];
1666      if (getcwd(cwd,sizeof(cwd)) == NULL) {
1667          rewriteConfigMarkAsProcessed(state,&quot;dir&quot;);
1668          return; &amp;bsol;* no rewrite on error. */
1669      }
1670      rewriteConfigStringOption(state,&quot;dir&quot;,cwd,NULL);
1671  }
1672  void rewriteConfigSlaveofOption(struct rewriteConfigState *state, char *option) {
1673      sds line;
1674      if (server.cluster_enabled || server.masterhost == NULL) {
1675          rewriteConfigMarkAsProcessed(state,option);
1676          return;
1677      }
1678      line = sdscatprintf(sdsempty(),&quot;%s %s %d&quot;, option,
1679          server.masterhost, server.masterport);
1680      rewriteConfigRewriteLine(state,option,line,1);
1681  }
1682  void rewriteConfigNotifykeyspaceeventsOption(struct rewriteConfigState *state) {
1683      int force = server.notify_keyspace_events != 0;
1684      char *option = &quot;notify-keyspace-events&quot;;
1685      sds line, flags;
1686      flags = keyspaceEventsFlagsToString(server.notify_keyspace_events);
1687      line = sdsnew(option);
1688      line = sdscatlen(line, &quot; &quot;, 1);
1689      line = sdscatrepr(line, flags, sdslen(flags));
1690      sdsfree(flags);
1691      rewriteConfigRewriteLine(state,option,line,force);
1692  }
1693  void rewriteConfigClientoutputbufferlimitOption(struct rewriteConfigState *state) {
1694      int j;
1695      char *option = &quot;client-output-buffer-limit&quot;;
1696      for (j = 0; j &lt; CLIENT_TYPE_OBUF_COUNT; j++) {
1697          int force = (server.client_obuf_limits[j].hard_limit_bytes !=
1698                      clientBufferLimitsDefaults[j].hard_limit_bytes) ||
1699                      (server.client_obuf_limits[j].soft_limit_bytes !=
1700                      clientBufferLimitsDefaults[j].soft_limit_bytes) ||
1701                      (server.client_obuf_limits[j].soft_limit_seconds !=
1702                      clientBufferLimitsDefaults[j].soft_limit_seconds);
1703          sds line;
1704          char hard[64], soft[64];
1705          rewriteConfigFormatMemory(hard,sizeof(hard),
1706                  server.client_obuf_limits[j].hard_limit_bytes);
1707          rewriteConfigFormatMemory(soft,sizeof(soft),
1708                  server.client_obuf_limits[j].soft_limit_bytes);
1709          char *typename = getClientTypeName(j);
1710          if (!strcmp(typename,&quot;slave&quot;)) typename = &quot;replica&quot;;
1711          line = sdscatprintf(sdsempty(),&quot;%s %s %s %s %Id&quot;, WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
1712                  option, typename, hard, soft,
1713                  (PORT_LONG) server.client_obuf_limits[j].soft_limit_seconds);
1714          rewriteConfigRewriteLine(state,option,line,force);
1715      }
1716  }
1717  void rewriteConfigBindOption(struct rewriteConfigState *state) {
1718      int force = 1;
1719      sds line, addresses;
1720      char *option = &quot;bind&quot;;
1721      if (server.bindaddr_count == 0) {
1722          rewriteConfigMarkAsProcessed(state,option);
1723          return;
1724      }
1725      addresses = sdsjoin(server.bindaddr,server.bindaddr_count,&quot; &quot;);
1726      line = sdsnew(option);
1727      line = sdscatlen(line, &quot; &quot;, 1);
1728      line = sdscatsds(line, addresses);
1729      sdsfree(addresses);
1730      rewriteConfigRewriteLine(state,option,line,force);
1731  }
1732  sds rewriteConfigGetContentFromState(struct rewriteConfigState *state) {
1733      sds content = sdsempty();
1734      int j, was_empty = 0;
1735      for (j = 0; j &lt; state-&gt;numlines; j++) {
1736          if (sdslen(state-&gt;lines[j]) == 0) {
1737              if (was_empty) continue;
1738              was_empty = 1;
1739          } else {
1740              was_empty = 0;
1741          }
1742          content = sdscatsds(content,state-&gt;lines[j]);
1743          content = sdscatlen(content,&quot;\n&quot;,1);
1744      }
1745      return content;
1746  }
1747  void rewriteConfigReleaseState(struct rewriteConfigState *state) {
1748      sdsfreesplitres(state-&gt;lines,state-&gt;numlines);
1749      dictRelease(state-&gt;option_to_line);
1750      dictRelease(state-&gt;rewritten);
1751      zfree(state);
1752  }
1753  void rewriteConfigRemoveOrphaned(struct rewriteConfigState *state) {
1754      dictIterator *di = dictGetIterator(state-&gt;option_to_line);
1755      dictEntry *de;
1756      while((de = dictNext(di)) != NULL) {
1757          list *l = dictGetVal(de);
1758          sds option = dictGetKey(de);
1759          if (dictFind(state-&gt;rewritten,option) == NULL) {
1760              serverLog(LL_DEBUG,&quot;Not rewritten option: %s&quot;, option);
1761              continue;
1762          }
1763          while(listLength(l)) {
1764              listNode *ln = listFirst(l);
1765              int linenum = (int)((PORT_LONG) ln-&gt;value);                         WIN_PORT_FIX &amp;bsol;* cast (int) */
1766              sdsfree(state-&gt;lines[linenum]);
1767              state-&gt;lines[linenum] = sdsempty();
1768              listDelNode(l,ln);
1769          }
1770      }
1771      dictReleaseIterator(di);
1772  }
1773  int rewriteConfigOverwriteFile(char *configfile, sds content) {
1774      int retval = 0;
1775      int fd = open(configfile,O_RDWR|O_CREAT,0644);
1776      int content_size = (int)sdslen(content), padding = 0;                       WIN_PORT_FIX &amp;bsol;* cast (int) */
1777      struct IF_WIN32(_stat64,stat) sb;                                           
1778      sds content_padded;
1779      if (fd == -1) return -1; &amp;bsol;* errno set by open(). */
1780      if (fstat(fd,&amp;sb) == -1) {
1781          close(fd);
1782          return -1; &amp;bsol;* errno set by fstat(). */
1783      }
1784      content_padded = sdsdup(content);
1785      if (content_size &lt; sb.st_size) {
1786          padding = (int)(sb.st_size - content_size);                             WIN_PORT_FIX &amp;bsol;* cast (int) */
1787          content_padded = sdsgrowzero(content_padded,sb.st_size);
1788          content_padded[content_size] = &#x27;\n&#x27;;
1789          memset(content_padded+content_size+1,&#x27;#&#x27;,(size_t)padding-1);            WIN_PORT_FIX &amp;bsol;* cat (size_t) */
1790      }
1791      if (write(fd,content_padded,strlen(content_padded)) == -1) {
1792          retval = -1;
1793          goto cleanup;
1794      }
1795      if (padding) {
1796          if (ftruncate(fd,content_size) == -1) {
1797          }
1798      }
1799  cleanup:
1800      sdsfree(content_padded);
1801      close(fd);
1802      return retval;
1803  }
1804  int rewriteConfig(char *path) {
1805      struct rewriteConfigState *state;
1806      sds newcontent;
1807      int retval;
1808      if ((state = rewriteConfigReadOldFile(path)) == NULL) return -1;
1809      rewriteConfigYesNoOption(state,&quot;daemonize&quot;,server.daemonize,0);
1810      rewriteConfigStringOption(state,&quot;pidfile&quot;,server.pidfile,CONFIG_DEFAULT_PID_FILE);
1811      rewriteConfigNumericalOption(state,&quot;port&quot;,server.port,CONFIG_DEFAULT_SERVER_PORT);
1812      rewriteConfigNumericalOption(state,&quot;cluster-announce-port&quot;,server.cluster_announce_port,CONFIG_DEFAULT_CLUSTER_ANNOUNCE_PORT);
1813      rewriteConfigNumericalOption(state,&quot;cluster-announce-bus-port&quot;,server.cluster_announce_bus_port,CONFIG_DEFAULT_CLUSTER_ANNOUNCE_BUS_PORT);
1814      rewriteConfigNumericalOption(state,&quot;tcp-backlog&quot;,server.tcp_backlog,CONFIG_DEFAULT_TCP_BACKLOG);
1815      rewriteConfigBindOption(state);
1816      rewriteConfigStringOption(state,&quot;unixsocket&quot;,server.unixsocket,NULL);
1817      rewriteConfigOctalOption(state,&quot;unixsocketperm&quot;,server.unixsocketperm,CONFIG_DEFAULT_UNIX_SOCKET_PERM);
1818      rewriteConfigNumericalOption(state,&quot;timeout&quot;,server.maxidletime,CONFIG_DEFAULT_CLIENT_TIMEOUT);
1819      rewriteConfigNumericalOption(state,&quot;tcp-keepalive&quot;,server.tcpkeepalive,CONFIG_DEFAULT_TCP_KEEPALIVE);
1820      rewriteConfigNumericalOption(state,&quot;replica-announce-port&quot;,server.slave_announce_port,CONFIG_DEFAULT_SLAVE_ANNOUNCE_PORT);
1821      rewriteConfigEnumOption(state,&quot;loglevel&quot;,server.verbosity,loglevel_enum,CONFIG_DEFAULT_VERBOSITY);
1822      rewriteConfigStringOption(state,&quot;logfile&quot;,server.logfile,CONFIG_DEFAULT_LOGFILE);
1823      rewriteConfigYesNoOption(state,&quot;syslog-enabled&quot;,server.syslog_enabled,CONFIG_DEFAULT_SYSLOG_ENABLED);
1824      rewriteConfigStringOption(state,&quot;syslog-ident&quot;,server.syslog_ident,CONFIG_DEFAULT_SYSLOG_IDENT);
1825  #ifndef _WIN32
1826      rewriteConfigSyslogfacilityOption(state);
1827  #endif
1828      rewriteConfigSaveOption(state);
1829      rewriteConfigNumericalOption(state,&quot;databases&quot;,server.dbnum,CONFIG_DEFAULT_DBNUM);
1830      rewriteConfigYesNoOption(state,&quot;stop-writes-on-bgsave-error&quot;,server.stop_writes_on_bgsave_err,CONFIG_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR);
1831      rewriteConfigYesNoOption(state,&quot;rdbcompression&quot;,server.rdb_compression,CONFIG_DEFAULT_RDB_COMPRESSION);
1832      rewriteConfigYesNoOption(state,&quot;rdbchecksum&quot;,server.rdb_checksum,CONFIG_DEFAULT_RDB_CHECKSUM);
1833      rewriteConfigStringOption(state,&quot;dbfilename&quot;,server.rdb_filename,CONFIG_DEFAULT_RDB_FILENAME);
1834      rewriteConfigDirOption(state);
1835      rewriteConfigSlaveofOption(state,&quot;replicaof&quot;);
1836      rewriteConfigStringOption(state,&quot;replica-announce-ip&quot;,server.slave_announce_ip,CONFIG_DEFAULT_SLAVE_ANNOUNCE_IP);
1837      rewriteConfigStringOption(state,&quot;masterauth&quot;,server.masterauth,NULL);
1838      rewriteConfigStringOption(state,&quot;cluster-announce-ip&quot;,server.cluster_announce_ip,NULL);
1839      rewriteConfigYesNoOption(state,&quot;replica-serve-stale-data&quot;,server.repl_serve_stale_data,CONFIG_DEFAULT_SLAVE_SERVE_STALE_DATA);
1840      rewriteConfigYesNoOption(state,&quot;replica-read-only&quot;,server.repl_slave_ro,CONFIG_DEFAULT_SLAVE_READ_ONLY);
1841      rewriteConfigYesNoOption(state,&quot;replica-ignore-maxmemory&quot;,server.repl_slave_ignore_maxmemory,CONFIG_DEFAULT_SLAVE_IGNORE_MAXMEMORY);
1842      rewriteConfigNumericalOption(state,&quot;repl-ping-replica-period&quot;,server.repl_ping_slave_period,CONFIG_DEFAULT_REPL_PING_SLAVE_PERIOD);
1843      rewriteConfigNumericalOption(state,&quot;repl-timeout&quot;,server.repl_timeout,CONFIG_DEFAULT_REPL_TIMEOUT);
1844      rewriteConfigBytesOption(state,&quot;repl-backlog-size&quot;,server.repl_backlog_size,CONFIG_DEFAULT_REPL_BACKLOG_SIZE);
1845      rewriteConfigBytesOption(state,&quot;repl-backlog-ttl&quot;,server.repl_backlog_time_limit,CONFIG_DEFAULT_REPL_BACKLOG_TIME_LIMIT);
1846      rewriteConfigYesNoOption(state,&quot;repl-disable-tcp-nodelay&quot;,server.repl_disable_tcp_nodelay,CONFIG_DEFAULT_REPL_DISABLE_TCP_NODELAY);
1847      rewriteConfigYesNoOption(state,&quot;repl-diskless-sync&quot;,server.repl_diskless_sync,CONFIG_DEFAULT_REPL_DISKLESS_SYNC);
1848      rewriteConfigNumericalOption(state,&quot;repl-diskless-sync-delay&quot;,server.repl_diskless_sync_delay,CONFIG_DEFAULT_REPL_DISKLESS_SYNC_DELAY);
1849      rewriteConfigNumericalOption(state,&quot;replica-priority&quot;,server.slave_priority,CONFIG_DEFAULT_SLAVE_PRIORITY);
1850      rewriteConfigNumericalOption(state,&quot;min-replicas-to-write&quot;,server.repl_min_slaves_to_write,CONFIG_DEFAULT_MIN_SLAVES_TO_WRITE);
1851      rewriteConfigNumericalOption(state,&quot;min-replicas-max-lag&quot;,server.repl_min_slaves_max_lag,CONFIG_DEFAULT_MIN_SLAVES_MAX_LAG);
1852      rewriteConfigStringOption(state,&quot;requirepass&quot;,server.requirepass,NULL);
1853      rewriteConfigNumericalOption(state,&quot;maxclients&quot;,server.maxclients,CONFIG_DEFAULT_MAX_CLIENTS);
1854      rewriteConfigBytesOption(state,&quot;maxmemory&quot;,server.maxmemory,CONFIG_DEFAULT_MAXMEMORY);
1855      rewriteConfigBytesOption(state,&quot;proto-max-bulk-len&quot;,server.proto_max_bulk_len,CONFIG_DEFAULT_PROTO_MAX_BULK_LEN);
1856      rewriteConfigBytesOption(state,&quot;client-query-buffer-limit&quot;,server.client_max_querybuf_len,PROTO_MAX_QUERYBUF_LEN);
1857      rewriteConfigEnumOption(state,&quot;maxmemory-policy&quot;,server.maxmemory_policy,maxmemory_policy_enum,CONFIG_DEFAULT_MAXMEMORY_POLICY);
1858      rewriteConfigNumericalOption(state,&quot;maxmemory-samples&quot;,server.maxmemory_samples,CONFIG_DEFAULT_MAXMEMORY_SAMPLES);
1859      rewriteConfigNumericalOption(state,&quot;lfu-log-factor&quot;,server.lfu_log_factor,CONFIG_DEFAULT_LFU_LOG_FACTOR);
1860      rewriteConfigNumericalOption(state,&quot;lfu-decay-time&quot;,server.lfu_decay_time,CONFIG_DEFAULT_LFU_DECAY_TIME);
1861      rewriteConfigNumericalOption(state,&quot;active-defrag-threshold-lower&quot;,server.active_defrag_threshold_lower,CONFIG_DEFAULT_DEFRAG_THRESHOLD_LOWER);
1862      rewriteConfigNumericalOption(state,&quot;active-defrag-threshold-upper&quot;,server.active_defrag_threshold_upper,CONFIG_DEFAULT_DEFRAG_THRESHOLD_UPPER);
1863      rewriteConfigBytesOption(state,&quot;active-defrag-ignore-bytes&quot;,server.active_defrag_ignore_bytes,CONFIG_DEFAULT_DEFRAG_IGNORE_BYTES);
1864      rewriteConfigNumericalOption(state,&quot;active-defrag-cycle-min&quot;,server.active_defrag_cycle_min,CONFIG_DEFAULT_DEFRAG_CYCLE_MIN);
1865      rewriteConfigNumericalOption(state,&quot;active-defrag-cycle-max&quot;,server.active_defrag_cycle_max,CONFIG_DEFAULT_DEFRAG_CYCLE_MAX);
1866      rewriteConfigNumericalOption(state,&quot;active-defrag-max-scan-fields&quot;,server.active_defrag_max_scan_fields,CONFIG_DEFAULT_DEFRAG_MAX_SCAN_FIELDS);
1867      rewriteConfigYesNoOption(state,&quot;appendonly&quot;,server.aof_state != AOF_OFF,0);
1868      rewriteConfigStringOption(state,&quot;appendfilename&quot;,server.aof_filename,CONFIG_DEFAULT_AOF_FILENAME);
1869      rewriteConfigEnumOption(state,&quot;appendfsync&quot;,server.aof_fsync,aof_fsync_enum,CONFIG_DEFAULT_AOF_FSYNC);
1870      rewriteConfigYesNoOption(state,&quot;no-appendfsync-on-rewrite&quot;,server.aof_no_fsync_on_rewrite,CONFIG_DEFAULT_AOF_NO_FSYNC_ON_REWRITE);
1871      rewriteConfigNumericalOption(state,&quot;auto-aof-rewrite-percentage&quot;,server.aof_rewrite_perc,AOF_REWRITE_PERC);
1872      rewriteConfigBytesOption(state,&quot;auto-aof-rewrite-min-size&quot;,server.aof_rewrite_min_size,AOF_REWRITE_MIN_SIZE);
1873      rewriteConfigNumericalOption(state,&quot;lua-time-limit&quot;,server.lua_time_limit,LUA_SCRIPT_TIME_LIMIT);
1874      rewriteConfigYesNoOption(state,&quot;cluster-enabled&quot;,server.cluster_enabled,0);
1875      rewriteConfigStringOption(state,&quot;cluster-config-file&quot;,server.cluster_configfile,CONFIG_DEFAULT_CLUSTER_CONFIG_FILE);
1876      rewriteConfigYesNoOption(state,&quot;cluster-require-full-coverage&quot;,server.cluster_require_full_coverage,CLUSTER_DEFAULT_REQUIRE_FULL_COVERAGE);
1877      rewriteConfigYesNoOption(state,&quot;cluster-replica-no-failover&quot;,server.cluster_slave_no_failover,CLUSTER_DEFAULT_SLAVE_NO_FAILOVER);
1878      rewriteConfigNumericalOption(state,&quot;cluster-node-timeout&quot;,server.cluster_node_timeout,CLUSTER_DEFAULT_NODE_TIMEOUT);
1879      rewriteConfigNumericalOption(state,&quot;cluster-migration-barrier&quot;,server.cluster_migration_barrier,CLUSTER_DEFAULT_MIGRATION_BARRIER);
1880      rewriteConfigNumericalOption(state,&quot;cluster-replica-validity-factor&quot;,server.cluster_slave_validity_factor,CLUSTER_DEFAULT_SLAVE_VALIDITY);
1881      rewriteConfigNumericalOption(state,&quot;slowlog-log-slower-than&quot;,server.slowlog_log_slower_than,CONFIG_DEFAULT_SLOWLOG_LOG_SLOWER_THAN);
1882      rewriteConfigNumericalOption(state,&quot;latency-monitor-threshold&quot;,server.latency_monitor_threshold,CONFIG_DEFAULT_LATENCY_MONITOR_THRESHOLD);
1883      rewriteConfigNumericalOption(state,&quot;slowlog-max-len&quot;,server.slowlog_max_len,CONFIG_DEFAULT_SLOWLOG_MAX_LEN);
1884      rewriteConfigNotifykeyspaceeventsOption(state);
1885      rewriteConfigNumericalOption(state,&quot;hash-max-ziplist-entries&quot;,server.hash_max_ziplist_entries,OBJ_HASH_MAX_ZIPLIST_ENTRIES);
1886      rewriteConfigNumericalOption(state,&quot;hash-max-ziplist-value&quot;,server.hash_max_ziplist_value,OBJ_HASH_MAX_ZIPLIST_VALUE);
1887      rewriteConfigNumericalOption(state,&quot;stream-node-max-bytes&quot;,server.stream_node_max_bytes,OBJ_STREAM_NODE_MAX_BYTES);
1888      rewriteConfigNumericalOption(state,&quot;stream-node-max-entries&quot;,server.stream_node_max_entries,OBJ_STREAM_NODE_MAX_ENTRIES);
1889      rewriteConfigNumericalOption(state,&quot;list-max-ziplist-size&quot;,server.list_max_ziplist_size,OBJ_LIST_MAX_ZIPLIST_SIZE);
1890      rewriteConfigNumericalOption(state,&quot;list-compress-depth&quot;,server.list_compress_depth,OBJ_LIST_COMPRESS_DEPTH);
1891      rewriteConfigNumericalOption(state,&quot;set-max-intset-entries&quot;,server.set_max_intset_entries,OBJ_SET_MAX_INTSET_ENTRIES);
1892      rewriteConfigNumericalOption(state,&quot;zset-max-ziplist-entries&quot;,server.zset_max_ziplist_entries,OBJ_ZSET_MAX_ZIPLIST_ENTRIES);
1893      rewriteConfigNumericalOption(state,&quot;zset-max-ziplist-value&quot;,server.zset_max_ziplist_value,OBJ_ZSET_MAX_ZIPLIST_VALUE);
1894      rewriteConfigNumericalOption(state,&quot;hll-sparse-max-bytes&quot;,server.hll_sparse_max_bytes,CONFIG_DEFAULT_HLL_SPARSE_MAX_BYTES);
1895      rewriteConfigYesNoOption(state,&quot;activerehashing&quot;,server.activerehashing,CONFIG_DEFAULT_ACTIVE_REHASHING);
1896      rewriteConfigYesNoOption(state,&quot;activedefrag&quot;,server.active_defrag_enabled,CONFIG_DEFAULT_ACTIVE_DEFRAG);
1897      rewriteConfigYesNoOption(state,&quot;protected-mode&quot;,server.protected_mode,CONFIG_DEFAULT_PROTECTED_MODE);
1898      rewriteConfigClientoutputbufferlimitOption(state);
1899      rewriteConfigNumericalOption(state,&quot;hz&quot;,server.config_hz,CONFIG_DEFAULT_HZ);
1900      rewriteConfigYesNoOption(state,&quot;aof-rewrite-incremental-fsync&quot;,server.aof_rewrite_incremental_fsync,CONFIG_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC);
1901      rewriteConfigYesNoOption(state,&quot;rdb-save-incremental-fsync&quot;,server.rdb_save_incremental_fsync,CONFIG_DEFAULT_RDB_SAVE_INCREMENTAL_FSYNC);
1902      rewriteConfigYesNoOption(state,&quot;aof-load-truncated&quot;,server.aof_load_truncated,CONFIG_DEFAULT_AOF_LOAD_TRUNCATED);
1903      rewriteConfigYesNoOption(state,&quot;aof-use-rdb-preamble&quot;,server.aof_use_rdb_preamble,CONFIG_DEFAULT_AOF_USE_RDB_PREAMBLE);
1904      rewriteConfigEnumOption(state,&quot;supervised&quot;,server.supervised_mode,supervised_mode_enum,SUPERVISED_NONE);
1905      rewriteConfigYesNoOption(state,&quot;lazyfree-lazy-eviction&quot;,server.lazyfree_lazy_eviction,CONFIG_DEFAULT_LAZYFREE_LAZY_EVICTION);
1906      rewriteConfigYesNoOption(state,&quot;lazyfree-lazy-expire&quot;,server.lazyfree_lazy_expire,CONFIG_DEFAULT_LAZYFREE_LAZY_EXPIRE);
1907      rewriteConfigYesNoOption(state,&quot;lazyfree-lazy-server-del&quot;,server.lazyfree_lazy_server_del,CONFIG_DEFAULT_LAZYFREE_LAZY_SERVER_DEL);
1908      rewriteConfigYesNoOption(state,&quot;replica-lazy-flush&quot;,server.repl_slave_lazy_flush,CONFIG_DEFAULT_SLAVE_LAZY_FLUSH);
1909      rewriteConfigYesNoOption(state,&quot;dynamic-hz&quot;,server.dynamic_hz,CONFIG_DEFAULT_DYNAMIC_HZ);
1910      if (server.sentinel_mode) rewriteConfigSentinelOption(state);
1911      rewriteConfigRemoveOrphaned(state);
1912      newcontent = rewriteConfigGetContentFromState(state);
1913      retval = rewriteConfigOverwriteFile(server.configfile,newcontent);
1914      sdsfree(newcontent);
1915      rewriteConfigReleaseState(state);
1916      return retval;
1917  }
1918  void configCommand(client *c) {
1919      if (server.loading &amp;&amp; strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;get&quot;)) {
1920          addReplyError(c,&quot;Only CONFIG GET is allowed during loading&quot;);
1921          return;
1922      }
1923      if (c-&gt;argc == 2 &amp;&amp; !strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;help&quot;)) {
1924          const char *help[] = {
1925  &quot;GET &lt;pattern&gt; -- Return parameters matching the glob-like &lt;pattern&gt; and their values.&quot;,
1926  &quot;SET &lt;parameter&gt; &lt;value&gt; -- Set parameter to value.&quot;,
1927  &quot;RESETSTAT -- Reset statistics reported by INFO.&quot;,
1928  &quot;REWRITE -- Rewrite the configuration file.&quot;,
1929  NULL
1930          };
1931          addReplyHelp(c, help);
1932      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;set&quot;) &amp;&amp; c-&gt;argc == 4) {
1933          configSetCommand(c);
1934      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;get&quot;) &amp;&amp; c-&gt;argc == 3) {
1935          configGetCommand(c);
1936      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;resetstat&quot;) &amp;&amp; c-&gt;argc == 2) {
1937          resetServerStats();
1938          resetCommandTableStats();
1939          addReply(c,shared.ok);
1940      } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;rewrite&quot;) &amp;&amp; c-&gt;argc == 2) {
1941          if (server.configfile == NULL) {
1942              addReplyError(c,&quot;The server is running without a config file&quot;);
1943              return;
1944          }
1945          if (rewriteConfig(server.configfile) == -1) {
1946              serverLog(LL_WARNING,&quot;CONFIG REWRITE failed: %s&quot;, IF_WIN32(wsa_strerror(errno), strerror(errno)));
1947              addReplyErrorFormat(c,&quot;Rewriting config file: %s&quot;, IF_WIN32(wsa_strerror(errno), strerror(errno)));
1948          } else {
1949              serverLog(LL_WARNING,&quot;CONFIG REWRITE executed with success.&quot;);
1950              addReply(c,shared.ok);
1951          }
1952      } else {
1953          addReplySubcommandSyntaxError(c);
1954          return;
1955      }
1956  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-config.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-config.c</div>
                </div>
                <div class="column column_space"><pre><code>533                  err = &quot;active-defrag-cycle-max must be between 1 and 99&quot;;
534                  goto loaderr;
535              }
536          } else if (!strcasecmp(argv[0],&quot;active-defrag-max-scan-fields&quot;) &amp;&amp; argc == 2) {
537              server.active_defrag_max_scan_fields = strtoll(argv[1],NULL,10);
</pre></code></div>
                <div class="column column_space"><pre><code>508                  err = &quot;active-defrag-threshold-lower must be between 0 and 1000&quot;;
509                  goto loaderr;
510              }
511          } else if (!strcasecmp(argv[0],&quot;active-defrag-threshold-upper&quot;) &amp;&amp; argc == 2) {
512              server.active_defrag_threshold_upper = atoi(argv[1]);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    