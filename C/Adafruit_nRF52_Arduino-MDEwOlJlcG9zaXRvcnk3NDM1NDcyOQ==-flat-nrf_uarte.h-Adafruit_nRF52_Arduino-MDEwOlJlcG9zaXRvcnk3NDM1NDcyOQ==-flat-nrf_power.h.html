
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 57.41626794258373%, Tokens: 24</h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_uarte.h</h3>
            <pre><code>1  #ifndef NRF_UARTE_H__
2  #define NRF_UARTE_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #define NRF_UARTE_PSEL_DISCONNECTED 0xFFFFFFFF
8  typedef enum
9  {
10      NRF_UARTE_TASK_STARTRX   = offsetof(NRF_UARTE_Type, TASKS_STARTRX), 
11      NRF_UARTE_TASK_STOPRX    = offsetof(NRF_UARTE_Type, TASKS_STOPRX),  
12      NRF_UARTE_TASK_STARTTX   = offsetof(NRF_UARTE_Type, TASKS_STARTTX), 
13      NRF_UARTE_TASK_STOPTX    = offsetof(NRF_UARTE_Type, TASKS_STOPTX),  
14      NRF_UARTE_TASK_FLUSHRX   = offsetof(NRF_UARTE_Type, TASKS_FLUSHRX)  
15  } nrf_uarte_task_t;
16  typedef enum
17  {
18      NRF_UARTE_EVENT_CTS       = offsetof(NRF_UARTE_Type, EVENTS_CTS),       
19      NRF_UARTE_EVENT_NCTS      = offsetof(NRF_UARTE_Type, EVENTS_NCTS),      
20      NRF_UARTE_EVENT_RXDRDY    = offsetof(NRF_UARTE_Type, EVENTS_RXDRDY),    
21      NRF_UARTE_EVENT_ENDRX     = offsetof(NRF_UARTE_Type, EVENTS_ENDRX),     
22      NRF_UARTE_EVENT_TXDRDY    = offsetof(NRF_UARTE_Type, EVENTS_TXDRDY),    
23      NRF_UARTE_EVENT_ENDTX     = offsetof(NRF_UARTE_Type, EVENTS_ENDTX),     
24      NRF_UARTE_EVENT_ERROR     = offsetof(NRF_UARTE_Type, EVENTS_ERROR),     
25      NRF_UARTE_EVENT_RXTO      = offsetof(NRF_UARTE_Type, EVENTS_RXTO),      
26      NRF_UARTE_EVENT_RXSTARTED = offsetof(NRF_UARTE_Type, EVENTS_RXSTARTED), 
27      NRF_UARTE_EVENT_TXSTARTED = offsetof(NRF_UARTE_Type, EVENTS_TXSTARTED), 
28      NRF_UARTE_EVENT_TXSTOPPED = offsetof(NRF_UARTE_Type, EVENTS_TXSTOPPED)  
29  } nrf_uarte_event_t;
30  typedef enum
31  {
32      NRF_UARTE_SHORT_ENDRX_STARTRX = UARTE_SHORTS_ENDRX_STARTRX_Msk, 
33      NRF_UARTE_SHORT_ENDRX_STOPRX  = UARTE_SHORTS_ENDRX_STOPRX_Msk   
34  } nrf_uarte_short_t;
35  typedef enum
36  {
37      NRF_UARTE_INT_CTS_MASK       = UARTE_INTENSET_CTS_Msk,       
38      NRF_UARTE_INT_NCTS_MASK      = UARTE_INTENSET_NCTS_Msk,      
39      NRF_UARTE_INT_RXDRDY_MASK    = UARTE_INTENSET_RXDRDY_Msk,    
40      NRF_UARTE_INT_ENDRX_MASK     = UARTE_INTENSET_ENDRX_Msk,     
41      NRF_UARTE_INT_TXDRDY_MASK    = UARTE_INTENSET_TXDRDY_Msk,    
42      NRF_UARTE_INT_ENDTX_MASK     = UARTE_INTENSET_ENDTX_Msk,     
43      NRF_UARTE_INT_ERROR_MASK     = UARTE_INTENSET_ERROR_Msk,     
44      NRF_UARTE_INT_RXTO_MASK      = UARTE_INTENSET_RXTO_Msk,      
45      NRF_UARTE_INT_RXSTARTED_MASK = UARTE_INTENSET_RXSTARTED_Msk, 
46      NRF_UARTE_INT_TXSTARTED_MASK = UARTE_INTENSET_TXSTARTED_Msk, 
47      NRF_UARTE_INT_TXSTOPPED_MASK = UARTE_INTENSET_TXSTOPPED_Msk  
48  } nrf_uarte_int_mask_t;
49  typedef enum
50  {
51      NRF_UARTE_BAUDRATE_1200    = UARTE_BAUDRATE_BAUDRATE_Baud1200,   
52      NRF_UARTE_BAUDRATE_2400    = UARTE_BAUDRATE_BAUDRATE_Baud2400,   
53      NRF_UARTE_BAUDRATE_4800    = UARTE_BAUDRATE_BAUDRATE_Baud4800,   
54      NRF_UARTE_BAUDRATE_9600    = UARTE_BAUDRATE_BAUDRATE_Baud9600,   
55      NRF_UARTE_BAUDRATE_14400   = UARTE_BAUDRATE_BAUDRATE_Baud14400,  
56      NRF_UARTE_BAUDRATE_19200   = UARTE_BAUDRATE_BAUDRATE_Baud19200,  
57      NRF_UARTE_BAUDRATE_28800   = UARTE_BAUDRATE_BAUDRATE_Baud28800,  
58      NRF_UARTE_BAUDRATE_31250   = UARTE_BAUDRATE_BAUDRATE_Baud31250,  
59      NRF_UARTE_BAUDRATE_38400   = UARTE_BAUDRATE_BAUDRATE_Baud38400,  
60      NRF_UARTE_BAUDRATE_56000   = UARTE_BAUDRATE_BAUDRATE_Baud56000,  
61      NRF_UARTE_BAUDRATE_57600   = UARTE_BAUDRATE_BAUDRATE_Baud57600,  
62      NRF_UARTE_BAUDRATE_76800   = UARTE_BAUDRATE_BAUDRATE_Baud76800,  
63      NRF_UARTE_BAUDRATE_115200  = UARTE_BAUDRATE_BAUDRATE_Baud115200, 
64      NRF_UARTE_BAUDRATE_230400  = UARTE_BAUDRATE_BAUDRATE_Baud230400, 
65      NRF_UARTE_BAUDRATE_250000  = UARTE_BAUDRATE_BAUDRATE_Baud250000, 
66      NRF_UARTE_BAUDRATE_460800  = UARTE_BAUDRATE_BAUDRATE_Baud460800, 
67      NRF_UARTE_BAUDRATE_921600  = UARTE_BAUDRATE_BAUDRATE_Baud921600, 
68      NRF_UARTE_BAUDRATE_1000000 = UARTE_BAUDRATE_BAUDRATE_Baud1M      
69  } nrf_uarte_baudrate_t;
70  typedef enum
71  {
72      NRF_UARTE_ERROR_OVERRUN_MASK = UARTE_ERRORSRC_OVERRUN_Msk, 
73      NRF_UARTE_ERROR_PARITY_MASK  = UARTE_ERRORSRC_PARITY_Msk,  
74      NRF_UARTE_ERROR_FRAMING_MASK = UARTE_ERRORSRC_FRAMING_Msk, 
75      NRF_UARTE_ERROR_BREAK_MASK   = UARTE_ERRORSRC_BREAK_Msk    
76  } nrf_uarte_error_mask_t;
77  typedef enum
78  {
79      NRF_UARTE_PARITY_EXCLUDED = UARTE_CONFIG_PARITY_Excluded << UARTE_CONFIG_PARITY_Pos, 
80      NRF_UARTE_PARITY_INCLUDED = UARTE_CONFIG_PARITY_Included << UARTE_CONFIG_PARITY_Pos  
81  } nrf_uarte_parity_t;
82  typedef enum
83  {
84      NRF_UARTE_HWFC_DISABLED = UARTE_CONFIG_HWFC_Disabled << UARTE_CONFIG_HWFC_Pos, 
85      NRF_UARTE_HWFC_ENABLED  = UARTE_CONFIG_HWFC_Enabled  << UARTE_CONFIG_HWFC_Pos  
86  } nrf_uarte_hwfc_t;
87  #if defined(UARTE_CONFIG_STOP_Msk) || defined(__NRFX_DOXYGEN__)
88  typedef enum
89  {
90      NRF_UARTE_STOP_ONE = UARTE_CONFIG_STOP_One << UARTE_CONFIG_STOP_Pos, 
91      NRF_UARTE_STOP_TWO = UARTE_CONFIG_STOP_Two << UARTE_CONFIG_STOP_Pos  
92  } nrf_uarte_stop_t;
93  #endif
94  #if defined(UARTE_CONFIG_PARITYTYPE_Msk) || defined(__NRFX_DOXYGEN__)
95  typedef enum
96  {
97      NRF_UARTE_PARITYTYPE_EVEN = UARTE_CONFIG_PARITYTYPE_Even << UARTE_CONFIG_PARITYTYPE_Pos, 
98      NRF_UARTE_PARITYTYPE_ODD  = UARTE_CONFIG_PARITYTYPE_Odd << UARTE_CONFIG_PARITYTYPE_Pos,  
99  } nrf_uarte_paritytype_t;
100  #endif
101  typedef struct
102  {
103      nrf_uarte_hwfc_t       hwfc;       
104      nrf_uarte_parity_t     parity;     
105  #if defined(UARTE_CONFIG_STOP_Msk) || defined(__NRFX_DOXYGEN__)
106      nrf_uarte_stop_t       stop;       
107  #endif
108  #if defined(UARTE_CONFIG_PARITYTYPE_Msk) || defined(__NRFX_DOXYGEN__)
109      nrf_uarte_paritytype_t paritytype; 
110  #endif
111  } nrf_uarte_config_t;
112  NRF_STATIC_INLINE void nrf_uarte_event_clear(NRF_UARTE_Type * p_reg, nrf_uarte_event_t event);
113  NRF_STATIC_INLINE bool nrf_uarte_event_check(NRF_UARTE_Type const * p_reg,
114                                               nrf_uarte_event_t      event);
115  NRF_STATIC_INLINE uint32_t nrf_uarte_event_address_get(NRF_UARTE_Type const * p_reg,
116                                                         nrf_uarte_event_t      event);
117  NRF_STATIC_INLINE void nrf_uarte_shorts_enable(NRF_UARTE_Type * p_reg, uint32_t mask);
118  NRF_STATIC_INLINE void nrf_uarte_shorts_disable(NRF_UARTE_Type * p_reg, uint32_t mask);
119  NRF_STATIC_INLINE void nrf_uarte_int_enable(NRF_UARTE_Type * p_reg, uint32_t mask);
120  NRF_STATIC_INLINE uint32_t nrf_uarte_int_enable_check(NRF_UARTE_Type const * p_reg, uint32_t mask);
121  NRF_STATIC_INLINE void nrf_uarte_int_disable(NRF_UARTE_Type * p_reg, uint32_t mask);
122  #if defined(DPPI_PRESENT) || defined(__NRFX_DOXYGEN__)
123  NRF_STATIC_INLINE void nrf_uarte_subscribe_set(NRF_UARTE_Type * p_reg,
124                                                 nrf_uarte_task_t task,
125                                                 uint8_t          channel);
126  NRF_STATIC_INLINE void nrf_uarte_subscribe_clear(NRF_UARTE_Type * p_reg,
127                                                   nrf_uarte_task_t task);
128  NRF_STATIC_INLINE void nrf_uarte_publish_set(NRF_UARTE_Type *  p_reg,
129                                               nrf_uarte_event_t event,
130                                               uint8_t           channel);
131  NRF_STATIC_INLINE void nrf_uarte_publish_clear(NRF_UARTE_Type *  p_reg,
132                                                 nrf_uarte_event_t event);
133  #endif 
134  NRF_STATIC_INLINE uint32_t nrf_uarte_errorsrc_get_and_clear(NRF_UARTE_Type * p_reg);
135  NRF_STATIC_INLINE void nrf_uarte_enable(NRF_UARTE_Type * p_reg);
136  NRF_STATIC_INLINE void nrf_uarte_disable(NRF_UARTE_Type * p_reg);
137  NRF_STATIC_INLINE void nrf_uarte_txrx_pins_set(NRF_UARTE_Type * p_reg,
138                                                 uint32_t         pseltxd,
139                                                 uint32_t         pselrxd);
140  NRF_STATIC_INLINE void nrf_uarte_txrx_pins_disconnect(NRF_UARTE_Type * p_reg);
141  NRF_STATIC_INLINE uint32_t nrf_uarte_tx_pin_get(NRF_UARTE_Type const * p_reg);
142  NRF_STATIC_INLINE uint32_t nrf_uarte_rx_pin_get(NRF_UARTE_Type const * p_reg);
143  NRF_STATIC_INLINE uint32_t nrf_uarte_rts_pin_get(NRF_UARTE_Type const * p_reg);
144  NRF_STATIC_INLINE uint32_t nrf_uarte_cts_pin_get(NRF_UARTE_Type const * p_reg);
145  NRF_STATIC_INLINE void nrf_uarte_hwfc_pins_set(NRF_UARTE_Type * p_reg,
146                                                 uint32_t         pselrts,
147                                                 uint32_t         pselcts);
148  NRF_STATIC_INLINE void nrf_uarte_hwfc_pins_disconnect(NRF_UARTE_Type * p_reg);
149  NRF_STATIC_INLINE void nrf_uarte_task_trigger(NRF_UARTE_Type * p_reg, nrf_uarte_task_t task);
150  NRF_STATIC_INLINE uint32_t nrf_uarte_task_address_get(NRF_UARTE_Type const * p_reg,
151                                                        nrf_uarte_task_t       task);
152  NRF_STATIC_INLINE void nrf_uarte_configure(NRF_UARTE_Type           * p_reg,
153                                             nrf_uarte_config_t const * p_cfg);
154  NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type *     p_reg,
155                                                nrf_uarte_baudrate_t baudrate);
156  NRF_STATIC_INLINE void nrf_uarte_tx_buffer_set(NRF_UARTE_Type * p_reg,
157                                                 uint8_t  const * p_buffer,
158                                                 size_t           length);
159  NRF_STATIC_INLINE uint32_t nrf_uarte_tx_amount_get(NRF_UARTE_Type const * p_reg);
160  NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
161                                                 uint8_t *        p_buffer,
162                                                 size_t           length);
163  NRF_STATIC_INLINE uint32_t nrf_uarte_rx_amount_get(NRF_UARTE_Type const * p_reg);
164  #ifndef NRF_DECLARE_ONLY
165  NRF_STATIC_INLINE void nrf_uarte_event_clear(NRF_UARTE_Type * p_reg, nrf_uarte_event_t event)
166  {
167      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
168  #if __CORTEX_M == 0x04
169      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
170      (void)dummy;
171  #endif
172  }
173  NRF_STATIC_INLINE bool nrf_uarte_event_check(NRF_UARTE_Type const * p_reg,
174                                               nrf_uarte_event_t      event)
175  {
176      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
177  }
178  NRF_STATIC_INLINE uint32_t nrf_uarte_event_address_get(NRF_UARTE_Type const * p_reg,
179                                                         nrf_uarte_event_t      event)
180  {
181      return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
182  }
183  NRF_STATIC_INLINE void nrf_uarte_shorts_enable(NRF_UARTE_Type * p_reg, uint32_t mask)
184  {
185      p_reg->SHORTS |= mask;
186  }
187  NRF_STATIC_INLINE void nrf_uarte_shorts_disable(NRF_UARTE_Type * p_reg, uint32_t mask)
188  {
189      p_reg->SHORTS &= ~(mask);
190  }
191  NRF_STATIC_INLINE void nrf_uarte_int_enable(NRF_UARTE_Type * p_reg, uint32_t mask)
192  {
193      p_reg->INTENSET = mask;
<span onclick='openModal()' class='match'>194  }
195  NRF_STATIC_INLINE uint32_t nrf_uarte_int_enable_check(NRF_UARTE_Type const * p_reg, uint32_t mask)
196  {
197      return p_reg->INTENSET & mask;
198  }
199  NRF_STATIC_INLINE void nrf_uarte_int_disable(NRF_UARTE_Type * p_reg, uint32_t mask)
200  {
201      p_reg->INTENCLR = mask;
202  }
203  #if defined(DPPI_PRESENT)
204  NRF_STATIC_INLINE void nrf_uarte_subscribe_set(NRF_UARTE_Type * p_reg,
205                                                 nrf_uarte_task_t task,
206                                                 uint8_t          channel)
207  {
208      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
209              ((uint32_t)channel | UARTE_SUBSCRIBE_STARTRX_EN_Msk);
210  }
211  NRF_STATIC_INLINE void nrf_uarte_subscribe_clear(NRF_UARTE_Type * p_reg,
212                                                   nrf_uarte_task_t task)
213  {
214      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
215  }
216  NRF_STATIC_INLINE void nrf_uarte_publish_set(NRF_UARTE_Type *  p_reg,
217                                               nrf_uarte_event_t event,
218                                               uint8_t           channel)
219  {
220      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
221              ((uint32_t)channel | UARTE_PUBLISH_CTS_EN_Msk);
222  }
223  NRF_STATIC_INLINE void nrf_uarte_publish_clear(NRF_UARTE_Type *  p_reg,
224                                                 nrf_uarte_event_t event)
225  {
226      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
227  }
</span>228  #endif 
229  NRF_STATIC_INLINE uint32_t nrf_uarte_errorsrc_get_and_clear(NRF_UARTE_Type * p_reg)
230  {
231      uint32_t errsrc_mask = p_reg->ERRORSRC;
232      p_reg->ERRORSRC = errsrc_mask;
233      return errsrc_mask;
234  }
235  NRF_STATIC_INLINE void nrf_uarte_enable(NRF_UARTE_Type * p_reg)
236  {
237      p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
238  }
239  NRF_STATIC_INLINE void nrf_uarte_disable(NRF_UARTE_Type * p_reg)
240  {
241      p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
242  }
243  NRF_STATIC_INLINE void nrf_uarte_txrx_pins_set(NRF_UARTE_Type * p_reg,
244                                                 uint32_t         pseltxd,
245                                                 uint32_t         pselrxd)
246  {
247      p_reg->PSEL.TXD = pseltxd;
248      p_reg->PSEL.RXD = pselrxd;
249  }
250  NRF_STATIC_INLINE void nrf_uarte_txrx_pins_disconnect(NRF_UARTE_Type * p_reg)
251  {
252      nrf_uarte_txrx_pins_set(p_reg, NRF_UARTE_PSEL_DISCONNECTED, NRF_UARTE_PSEL_DISCONNECTED);
253  }
254  NRF_STATIC_INLINE uint32_t nrf_uarte_tx_pin_get(NRF_UARTE_Type const * p_reg)
255  {
256      return p_reg->PSEL.TXD;
257  }
258  NRF_STATIC_INLINE uint32_t nrf_uarte_rx_pin_get(NRF_UARTE_Type const * p_reg)
259  {
260      return p_reg->PSEL.RXD;
261  }
262  NRF_STATIC_INLINE uint32_t nrf_uarte_rts_pin_get(NRF_UARTE_Type const * p_reg)
263  {
264      return p_reg->PSEL.RTS;
265  }
266  NRF_STATIC_INLINE uint32_t nrf_uarte_cts_pin_get(NRF_UARTE_Type const * p_reg)
267  {
268      return p_reg->PSEL.CTS;
269  }
270  NRF_STATIC_INLINE void nrf_uarte_hwfc_pins_set(NRF_UARTE_Type * p_reg,
271                                                 uint32_t         pselrts,
272                                                 uint32_t         pselcts)
273  {
274      p_reg->PSEL.RTS = pselrts;
275      p_reg->PSEL.CTS = pselcts;
276  }
277  NRF_STATIC_INLINE void nrf_uarte_hwfc_pins_disconnect(NRF_UARTE_Type * p_reg)
278  {
279      nrf_uarte_hwfc_pins_set(p_reg, NRF_UARTE_PSEL_DISCONNECTED, NRF_UARTE_PSEL_DISCONNECTED);
280  }
281  NRF_STATIC_INLINE void nrf_uarte_task_trigger(NRF_UARTE_Type * p_reg, nrf_uarte_task_t task)
282  {
283      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
284  }
285  NRF_STATIC_INLINE uint32_t nrf_uarte_task_address_get(NRF_UARTE_Type const * p_reg,
286                                                        nrf_uarte_task_t       task)
287  {
288      return (uint32_t)p_reg + (uint32_t)task;
289  }
290  NRF_STATIC_INLINE void nrf_uarte_configure(NRF_UARTE_Type           * p_reg,
291                                             nrf_uarte_config_t const * p_cfg)
292  {
293      p_reg->CONFIG = (uint32_t)p_cfg->parity
294  #if defined(UARTE_CONFIG_STOP_Msk)
295                      | (uint32_t)p_cfg->stop
296  #endif
297  #if defined(UARTE_CONFIG_PARITYTYPE_Msk)
298                      | (uint32_t)p_cfg->paritytype
299  #endif
300                      | (uint32_t)p_cfg->hwfc;
301  }
302  NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
303  {
304      p_reg->BAUDRATE = baudrate;
305  }
306  NRF_STATIC_INLINE void nrf_uarte_tx_buffer_set(NRF_UARTE_Type * p_reg,
307                                                 uint8_t  const * p_buffer,
308                                                 size_t           length)
309  {
310      p_reg->TXD.PTR    = (uint32_t)p_buffer;
311      p_reg->TXD.MAXCNT = length;
312  }
313  NRF_STATIC_INLINE uint32_t nrf_uarte_tx_amount_get(NRF_UARTE_Type const * p_reg)
314  {
315      return p_reg->TXD.AMOUNT;
316  }
317  NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
318                                                 uint8_t *        p_buffer,
319                                                 size_t           length)
320  {
321      p_reg->RXD.PTR    = (uint32_t)p_buffer;
322      p_reg->RXD.MAXCNT = length;
323  }
324  NRF_STATIC_INLINE uint32_t nrf_uarte_rx_amount_get(NRF_UARTE_Type const * p_reg)
325  {
326      return p_reg->RXD.AMOUNT;
327  }
328  #endif 
329  #ifdef __cplusplus
330  }
331  #endif
332  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_power.h</h3>
            <pre><code>1  #ifndef NRF_POWER_H__
2  #define NRF_POWER_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #if defined(POWER_INTENSET_SLEEPENTER_Msk) || defined(__NRFX_DOXYGEN__)
8  #define NRF_POWER_HAS_SLEEPEVT 1
9  #else
10  #define NRF_POWER_HAS_SLEEPEVT 0
11  #endif
12  #if defined(POWER_USBREGSTATUS_VBUSDETECT_Msk) || defined(__NRFX_DOXYGEN__)
13  #define NRF_POWER_HAS_USBREG 1
14  #else
15  #define NRF_POWER_HAS_USBREG 0
16  #endif
17  #if defined(POWER_DCDCEN0_DCDCEN_Msk) || defined(__NRFX_DOXYGEN__)
18  #define NRF_POWER_HAS_DCDCEN_VDDH 1
19  #else
20  #define NRF_POWER_HAS_DCDCEN_VDDH 0
21  #endif
22  #if defined(POWER_DCDCEN_DCDCEN_Msk) || defined(__NRFX_DOXYGEN__)
23  #define NRF_POWER_HAS_DCDCEN 1
24  #else
25  #define NRF_POWER_HAS_DCDCEN 0
26  #endif
27  #if defined(POWER_INTENSET_POFWARN_Msk) || defined(__NRFX_DOXYGEN__)
28  #define NRF_POWER_HAS_POFWARN 1
29  #else
30  #define NRF_POWER_HAS_POFWARN 0
31  #endif
32  #if defined(POWER_POFCON_THRESHOLD_Msk) || defined(__NRFX_DOXYGEN__)
33  #define NRF_POWER_HAS_POFCON 1
34  #else
35  #define NRF_POWER_HAS_POFCON 0
36  #endif
37  #if defined(POWER_POFCON_THRESHOLDVDDH_Msk) || defined(__NRFX_DOXYGEN__)
38  #define NRF_POWER_HAS_POFCON_VDDH 1
39  #else
40  #define NRF_POWER_HAS_POFCON_VDDH 0
41  #endif
42  #if defined(POWER_RESETREAS_RESETPIN_Msk) || defined(__NRFX_DOXYGEN__)
43  #define NRF_POWER_HAS_RESETREAS 1
44  #else
45  #define NRF_POWER_HAS_RESETREAS 0
46  #endif
47  #if defined(POWER_MAINREGSTATUS_MAINREGSTATUS_Msk) || defined(__NRFX_DOXYGEN__)
48  #define NRF_POWER_HAS_MAINREGSTATUS 1
49  #else
50  #define NRF_POWER_HAS_MAINREGSTATUS 0
51  #endif
52  typedef enum
53  {
54      NRF_POWER_TASK_CONSTLAT  = offsetof(NRF_POWER_Type, TASKS_CONSTLAT), &bsol;**< Enable constant latency mode. */
55      NRF_POWER_TASK_LOWPWR    = offsetof(NRF_POWER_Type, TASKS_LOWPWR  ), &bsol;**< Enable low-power mode (variable latency). */
56  } nrf_power_task_t;
57  typedef enum
58  {
59  #if NRF_POWER_HAS_POFWARN
60      NRF_POWER_EVENT_POFWARN      = offsetof(NRF_POWER_Type, EVENTS_POFWARN    ), &bsol;**< Power failure warning. */
61  #endif
62  #if NRF_POWER_HAS_SLEEPEVT
63      NRF_POWER_EVENT_SLEEPENTER   = offsetof(NRF_POWER_Type, EVENTS_SLEEPENTER ), &bsol;**< CPU entered WFI/WFE sleep. */
64      NRF_POWER_EVENT_SLEEPEXIT    = offsetof(NRF_POWER_Type, EVENTS_SLEEPEXIT  ), &bsol;**< CPU exited WFI/WFE sleep. */
65  #endif
66  #if NRF_POWER_HAS_USBREG
67      NRF_POWER_EVENT_USBDETECTED  = offsetof(NRF_POWER_Type, EVENTS_USBDETECTED), &bsol;**< Voltage supply detected on VBUS. */
68      NRF_POWER_EVENT_USBREMOVED   = offsetof(NRF_POWER_Type, EVENTS_USBREMOVED ), &bsol;**< Voltage supply removed from VBUS. */
69      NRF_POWER_EVENT_USBPWRRDY    = offsetof(NRF_POWER_Type, EVENTS_USBPWRRDY  ), &bsol;**< USB 3.3&nbsp;V supply ready. */
70  #endif
71  } nrf_power_event_t;
72  typedef enum
73  {
74  #if NRF_POWER_HAS_POFWARN
75      NRF_POWER_INT_POFWARN_MASK     = POWER_INTENSET_POFWARN_Msk    , &bsol;**< Write '1' to Enable interrupt for POFWARN event. */
76  #endif
77  #if NRF_POWER_HAS_SLEEPEVT
78      NRF_POWER_INT_SLEEPENTER_MASK  = POWER_INTENSET_SLEEPENTER_Msk , &bsol;**< Write '1' to Enable interrupt for SLEEPENTER event. */
79      NRF_POWER_INT_SLEEPEXIT_MASK   = POWER_INTENSET_SLEEPEXIT_Msk  , &bsol;**< Write '1' to Enable interrupt for SLEEPEXIT event. */
80  #endif
81  #if NRF_POWER_HAS_USBREG
82      NRF_POWER_INT_USBDETECTED_MASK = POWER_INTENSET_USBDETECTED_Msk, &bsol;**< Write '1' to Enable interrupt for USBDETECTED event. */
83      NRF_POWER_INT_USBREMOVED_MASK  = POWER_INTENSET_USBREMOVED_Msk , &bsol;**< Write '1' to Enable interrupt for USBREMOVED event. */
84      NRF_POWER_INT_USBPWRRDY_MASK   = POWER_INTENSET_USBPWRRDY_Msk  , &bsol;**< Write '1' to Enable interrupt for USBPWRRDY event. */
85  #endif
86  } nrf_power_int_mask_t;
87  #if NRF_POWER_HAS_RESETREAS
88  typedef enum
89  {
90      NRF_POWER_RESETREAS_RESETPIN_MASK = POWER_RESETREAS_RESETPIN_Msk, &bsol;**< Bit mask of RESETPIN field. */
91      NRF_POWER_RESETREAS_DOG_MASK      = POWER_RESETREAS_DOG_Msk     , &bsol;**< Bit mask of DOG field. */
92      NRF_POWER_RESETREAS_SREQ_MASK     = POWER_RESETREAS_SREQ_Msk    , &bsol;**< Bit mask of SREQ field. */
93      NRF_POWER_RESETREAS_LOCKUP_MASK   = POWER_RESETREAS_LOCKUP_Msk  , &bsol;**< Bit mask of LOCKUP field. */
94      NRF_POWER_RESETREAS_OFF_MASK      = POWER_RESETREAS_OFF_Msk     , &bsol;**< Bit mask of OFF field. */
95  #if defined(POWER_RESETREAS_LPCOMP_Msk) || defined(__NRFX_DOXYGEN__)
96      NRF_POWER_RESETREAS_LPCOMP_MASK   = POWER_RESETREAS_LPCOMP_Msk  , &bsol;**< Bit mask of LPCOMP field. */
97  #endif
98      NRF_POWER_RESETREAS_DIF_MASK      = POWER_RESETREAS_DIF_Msk     , &bsol;**< Bit mask of DIF field. */
99  #if defined(POWER_RESETREAS_NFC_Msk) || defined(__NRFX_DOXYGEN__)
100      NRF_POWER_RESETREAS_NFC_MASK      = POWER_RESETREAS_NFC_Msk     , &bsol;**< Bit mask of NFC field. */
101  #endif
102  #if defined(POWER_RESETREAS_VBUS_Msk) || defined(__NRFX_DOXYGEN__)
103      NRF_POWER_RESETREAS_VBUS_MASK     = POWER_RESETREAS_VBUS_Msk    , &bsol;**< Bit mask of VBUS field. */
104  #endif
105  } nrf_power_resetreas_mask_t;
106  #endif 
107  #if NRF_POWER_HAS_USBREG
108  typedef enum
109  {
110      NRF_POWER_USBREGSTATUS_VBUSDETECT_MASK = POWER_USBREGSTATUS_VBUSDETECT_Msk, &bsol;**< USB detected or removed.     */
111      NRF_POWER_USBREGSTATUS_OUTPUTRDY_MASK  = POWER_USBREGSTATUS_OUTPUTRDY_Msk   &bsol;**< USB 3.3&nbsp;V supply ready. */
112  } nrf_power_usbregstatus_mask_t;
113  #endif 
114  #if defined(POWER_RAMSTATUS_RAMBLOCK0_Msk) || defined(__NRFX_DOXYGEN__)
115  typedef enum
116  {
117      NRF_POWER_RAMBLOCK0 = POWER_RAMSTATUS_RAMBLOCK0_Pos,
118      NRF_POWER_RAMBLOCK1 = POWER_RAMSTATUS_RAMBLOCK1_Pos,
119      NRF_POWER_RAMBLOCK2 = POWER_RAMSTATUS_RAMBLOCK2_Pos,
120      NRF_POWER_RAMBLOCK3 = POWER_RAMSTATUS_RAMBLOCK3_Pos
121  } nrf_power_ramblock_t;
122  typedef enum
123  {
124      NRF_POWER_RAMBLOCK0_MASK = POWER_RAMSTATUS_RAMBLOCK0_Msk,
125      NRF_POWER_RAMBLOCK1_MASK = POWER_RAMSTATUS_RAMBLOCK1_Msk,
126      NRF_POWER_RAMBLOCK2_MASK = POWER_RAMSTATUS_RAMBLOCK2_Msk,
127      NRF_POWER_RAMBLOCK3_MASK = POWER_RAMSTATUS_RAMBLOCK3_Msk
128  } nrf_power_ramblock_mask_t;
129  #endif 
130  typedef enum
131  {
132      NRF_POWER_ONRAM0,  &bsol;**< Keep RAM block 0 ON or OFF in System ON mode.                 */
133      NRF_POWER_OFFRAM0, &bsol;**< Keep retention on RAM block 0 when RAM block is switched OFF. */
134      NRF_POWER_ONRAM1,  &bsol;**< Keep RAM block 1 ON or OFF in System ON mode.                 */
135      NRF_POWER_OFFRAM1, &bsol;**< Keep retention on RAM block 1 when RAM block is switched OFF. */
136      NRF_POWER_ONRAM2,  &bsol;**< Keep RAM block 2 ON or OFF in System ON mode.                 */
137      NRF_POWER_OFFRAM2, &bsol;**< Keep retention on RAM block 2 when RAM block is switched OFF. */
138      NRF_POWER_ONRAM3,  &bsol;**< Keep RAM block 3 ON or OFF in System ON mode.                 */
139      NRF_POWER_OFFRAM3, &bsol;**< Keep retention on RAM block 3 when RAM block is switched OFF. */
140  }nrf_power_onoffram_t;
141  typedef enum
142  {
143      NRF_POWER_ONRAM0_MASK  = 1U << NRF_POWER_ONRAM0,  &bsol;**< Keep RAM block 0 ON or OFF in System ON mode.                 */
144      NRF_POWER_OFFRAM0_MASK = 1U << NRF_POWER_OFFRAM0, &bsol;**< Keep retention on RAM block 0 when RAM block is switched OFF. */
145      NRF_POWER_ONRAM1_MASK  = 1U << NRF_POWER_ONRAM1,  &bsol;**< Keep RAM block 1 ON or OFF in System ON mode.                 */
146      NRF_POWER_OFFRAM1_MASK = 1U << NRF_POWER_OFFRAM1, &bsol;**< Keep retention on RAM block 1 when RAM block is switched OFF. */
147      NRF_POWER_ONRAM2_MASK  = 1U << NRF_POWER_ONRAM2,  &bsol;**< Keep RAM block 2 ON or OFF in System ON mode.                 */
148      NRF_POWER_OFFRAM2_MASK = 1U << NRF_POWER_OFFRAM2, &bsol;**< Keep retention on RAM block 2 when RAM block is switched OFF. */
149      NRF_POWER_ONRAM3_MASK  = 1U << NRF_POWER_ONRAM3,  &bsol;**< Keep RAM block 3 ON or OFF in System ON mode.                 */
150      NRF_POWER_OFFRAM3_MASK = 1U << NRF_POWER_OFFRAM3, &bsol;**< Keep retention on RAM block 3 when RAM block is switched OFF. */
151  }nrf_power_onoffram_mask_t;
152  #if NRF_POWER_HAS_POFCON
153  typedef enum
154  {
155      NRF_POWER_POFTHR_V21 = POWER_POFCON_THRESHOLD_V21, &bsol;**< Set threshold to 2.1&nbsp;V. */
156      NRF_POWER_POFTHR_V23 = POWER_POFCON_THRESHOLD_V23, &bsol;**< Set threshold to 2.3&nbsp;V. */
157      NRF_POWER_POFTHR_V25 = POWER_POFCON_THRESHOLD_V25, &bsol;**< Set threshold to 2.5&nbsp;V. */
158      NRF_POWER_POFTHR_V27 = POWER_POFCON_THRESHOLD_V27, &bsol;**< Set threshold to 2.7&nbsp;V. */
159  #if defined(POWER_POFCON_THRESHOLD_V17) || defined(__NRFX_DOXYGEN__)
160      NRF_POWER_POFTHR_V17 = POWER_POFCON_THRESHOLD_V17, &bsol;**< Set threshold to 1.7&nbsp;V. */
161      NRF_POWER_POFTHR_V18 = POWER_POFCON_THRESHOLD_V18, &bsol;**< Set threshold to 1.8&nbsp;V. */
162      NRF_POWER_POFTHR_V19 = POWER_POFCON_THRESHOLD_V19, &bsol;**< Set threshold to 1.9&nbsp;V. */
163      NRF_POWER_POFTHR_V20 = POWER_POFCON_THRESHOLD_V20, &bsol;**< Set threshold to 2.0&nbsp;V. */
164      NRF_POWER_POFTHR_V22 = POWER_POFCON_THRESHOLD_V22, &bsol;**< Set threshold to 2.2&nbsp;V. */
165      NRF_POWER_POFTHR_V24 = POWER_POFCON_THRESHOLD_V24, &bsol;**< Set threshold to 2.4&nbsp;V. */
166      NRF_POWER_POFTHR_V26 = POWER_POFCON_THRESHOLD_V26, &bsol;**< Set threshold to 2.6&nbsp;V. */
167      NRF_POWER_POFTHR_V28 = POWER_POFCON_THRESHOLD_V28, &bsol;**< Set threshold to 2.8&nbsp;V. */
168  #endif 
169  } nrf_power_pof_thr_t;
170  #endif 
171  #if NRF_POWER_HAS_POFCON_VDDH
172  typedef enum
173  {
174      NRF_POWER_POFTHRVDDH_V27 = POWER_POFCON_THRESHOLDVDDH_V27, &bsol;**< Set threshold to 2.7&nbsp;V. */
175      NRF_POWER_POFTHRVDDH_V28 = POWER_POFCON_THRESHOLDVDDH_V28, &bsol;**< Set threshold to 2.8&nbsp;V. */
176      NRF_POWER_POFTHRVDDH_V29 = POWER_POFCON_THRESHOLDVDDH_V29, &bsol;**< Set threshold to 2.9&nbsp;V. */
177      NRF_POWER_POFTHRVDDH_V30 = POWER_POFCON_THRESHOLDVDDH_V30, &bsol;**< Set threshold to 3.0&nbsp;V. */
178      NRF_POWER_POFTHRVDDH_V31 = POWER_POFCON_THRESHOLDVDDH_V31, &bsol;**< Set threshold to 3.1&nbsp;V. */
179      NRF_POWER_POFTHRVDDH_V32 = POWER_POFCON_THRESHOLDVDDH_V32, &bsol;**< Set threshold to 3.2&nbsp;V. */
180      NRF_POWER_POFTHRVDDH_V33 = POWER_POFCON_THRESHOLDVDDH_V33, &bsol;**< Set threshold to 3.3&nbsp;V. */
181      NRF_POWER_POFTHRVDDH_V34 = POWER_POFCON_THRESHOLDVDDH_V34, &bsol;**< Set threshold to 3.4&nbsp;V. */
182      NRF_POWER_POFTHRVDDH_V35 = POWER_POFCON_THRESHOLDVDDH_V35, &bsol;**< Set threshold to 3.5&nbsp;V. */
183      NRF_POWER_POFTHRVDDH_V36 = POWER_POFCON_THRESHOLDVDDH_V36, &bsol;**< Set threshold to 3.6&nbsp;V. */
184      NRF_POWER_POFTHRVDDH_V37 = POWER_POFCON_THRESHOLDVDDH_V37, &bsol;**< Set threshold to 3.7&nbsp;V. */
185      NRF_POWER_POFTHRVDDH_V38 = POWER_POFCON_THRESHOLDVDDH_V38, &bsol;**< Set threshold to 3.8&nbsp;V. */
186      NRF_POWER_POFTHRVDDH_V39 = POWER_POFCON_THRESHOLDVDDH_V39, &bsol;**< Set threshold to 3.9&nbsp;V. */
187      NRF_POWER_POFTHRVDDH_V40 = POWER_POFCON_THRESHOLDVDDH_V40, &bsol;**< Set threshold to 4.0&nbsp;V. */
188      NRF_POWER_POFTHRVDDH_V41 = POWER_POFCON_THRESHOLDVDDH_V41, &bsol;**< Set threshold to 4.1&nbsp;V. */
189      NRF_POWER_POFTHRVDDH_V42 = POWER_POFCON_THRESHOLDVDDH_V42, &bsol;**< Set threshold to 4.2&nbsp;V. */
190  } nrf_power_pof_thrvddh_t;
191  #endif 
192  #if NRF_POWER_HAS_MAINREGSTATUS
193  typedef enum
194  {
195      NRF_POWER_MAINREGSTATUS_NORMAL = POWER_MAINREGSTATUS_MAINREGSTATUS_Normal, &bsol;**< Normal voltage mode. Voltage supplied on VDD. */
196      NRF_POWER_MAINREGSTATUS_HIGH   = POWER_MAINREGSTATUS_MAINREGSTATUS_High    &bsol;**< High voltage mode. Voltage supplied on VDDH.  */
197  } nrf_power_mainregstatus_t;
198  #endif
199  #if defined(POWER_RAM_POWER_S0POWER_Msk) || defined(__NRFX_DOXYGEN__)
200  typedef enum
201  {
202      NRF_POWER_RAMPOWER_S0POWER = POWER_RAM_POWER_S0POWER_Pos,
203      NRF_POWER_RAMPOWER_S1POWER,  &bsol;**< Keep RAM section S1 ON in System ON mode. */
204      NRF_POWER_RAMPOWER_S2POWER,  &bsol;**< Keep RAM section S2 ON in System ON mode. */
205      NRF_POWER_RAMPOWER_S3POWER,  &bsol;**< Keep RAM section S3 ON in System ON mode. */
206      NRF_POWER_RAMPOWER_S4POWER,  &bsol;**< Keep RAM section S4 ON in System ON mode. */
207      NRF_POWER_RAMPOWER_S5POWER,  &bsol;**< Keep RAM section S5 ON in System ON mode. */
208      NRF_POWER_RAMPOWER_S6POWER,  &bsol;**< Keep RAM section S6 ON in System ON mode. */
209      NRF_POWER_RAMPOWER_S7POWER,  &bsol;**< Keep RAM section S7 ON in System ON mode. */
210      NRF_POWER_RAMPOWER_S8POWER,  &bsol;**< Keep RAM section S8 ON in System ON mode. */
211      NRF_POWER_RAMPOWER_S9POWER,  &bsol;**< Keep RAM section S9 ON in System ON mode. */
212      NRF_POWER_RAMPOWER_S10POWER, &bsol;**< Keep RAM section S10 ON in System ON mode. */
213      NRF_POWER_RAMPOWER_S11POWER, &bsol;**< Keep RAM section S11 ON in System ON mode. */
214      NRF_POWER_RAMPOWER_S12POWER, &bsol;**< Keep RAM section S12 ON in System ON mode. */
215      NRF_POWER_RAMPOWER_S13POWER, &bsol;**< Keep RAM section S13 ON in System ON mode. */
216      NRF_POWER_RAMPOWER_S14POWER, &bsol;**< Keep RAM section S14 ON in System ON mode. */
217      NRF_POWER_RAMPOWER_S15POWER, &bsol;**< Keep RAM section S15 ON in System ON mode. */
218      NRF_POWER_RAMPOWER_S0RETENTION = POWER_RAM_POWER_S0RETENTION_Pos,
219      NRF_POWER_RAMPOWER_S1RETENTION,  &bsol;**< Keep section retention in OFF mode when section is OFF. */
220      NRF_POWER_RAMPOWER_S2RETENTION,  &bsol;**< Keep section retention in OFF mode when section is OFF. */
221      NRF_POWER_RAMPOWER_S3RETENTION,  &bsol;**< Keep section retention in OFF mode when section is OFF. */
222      NRF_POWER_RAMPOWER_S4RETENTION,  &bsol;**< Keep section retention in OFF mode when section is OFF. */
223      NRF_POWER_RAMPOWER_S5RETENTION,  &bsol;**< Keep section retention in OFF mode when section is OFF. */
224      NRF_POWER_RAMPOWER_S6RETENTION,  &bsol;**< Keep section retention in OFF mode when section is OFF. */
225      NRF_POWER_RAMPOWER_S7RETENTION,  &bsol;**< Keep section retention in OFF mode when section is OFF. */
226      NRF_POWER_RAMPOWER_S8RETENTION,  &bsol;**< Keep section retention in OFF mode when section is OFF. */
227      NRF_POWER_RAMPOWER_S9RETENTION,  &bsol;**< Keep section retention in OFF mode when section is OFF. */
228      NRF_POWER_RAMPOWER_S10RETENTION, &bsol;**< Keep section retention in OFF mode when section is OFF. */
229      NRF_POWER_RAMPOWER_S11RETENTION, &bsol;**< Keep section retention in OFF mode when section is OFF. */
230      NRF_POWER_RAMPOWER_S12RETENTION, &bsol;**< Keep section retention in OFF mode when section is OFF. */
231      NRF_POWER_RAMPOWER_S13RETENTION, &bsol;**< Keep section retention in OFF mode when section is OFF. */
232      NRF_POWER_RAMPOWER_S14RETENTION, &bsol;**< Keep section retention in OFF mode when section is OFF. */
233      NRF_POWER_RAMPOWER_S15RETENTION, &bsol;**< Keep section retention in OFF mode when section is OFF. */
234  } nrf_power_rampower_t;
235  typedef enum
236  {
237      NRF_POWER_RAMPOWER_S0POWER_MASK  = 1UL << NRF_POWER_RAMPOWER_S0POWER ,
238      NRF_POWER_RAMPOWER_S1POWER_MASK  = 1UL << NRF_POWER_RAMPOWER_S1POWER ,
239      NRF_POWER_RAMPOWER_S2POWER_MASK  = 1UL << NRF_POWER_RAMPOWER_S2POWER ,
240      NRF_POWER_RAMPOWER_S3POWER_MASK  = 1UL << NRF_POWER_RAMPOWER_S3POWER ,
241      NRF_POWER_RAMPOWER_S4POWER_MASK  = 1UL << NRF_POWER_RAMPOWER_S4POWER ,
242      NRF_POWER_RAMPOWER_S5POWER_MASK  = 1UL << NRF_POWER_RAMPOWER_S5POWER ,
243      NRF_POWER_RAMPOWER_S7POWER_MASK  = 1UL << NRF_POWER_RAMPOWER_S7POWER ,
244      NRF_POWER_RAMPOWER_S8POWER_MASK  = 1UL << NRF_POWER_RAMPOWER_S8POWER ,
245      NRF_POWER_RAMPOWER_S9POWER_MASK  = 1UL << NRF_POWER_RAMPOWER_S9POWER ,
246      NRF_POWER_RAMPOWER_S10POWER_MASK = 1UL << NRF_POWER_RAMPOWER_S10POWER,
247      NRF_POWER_RAMPOWER_S11POWER_MASK = 1UL << NRF_POWER_RAMPOWER_S11POWER,
248      NRF_POWER_RAMPOWER_S12POWER_MASK = 1UL << NRF_POWER_RAMPOWER_S12POWER,
249      NRF_POWER_RAMPOWER_S13POWER_MASK = 1UL << NRF_POWER_RAMPOWER_S13POWER,
250      NRF_POWER_RAMPOWER_S14POWER_MASK = 1UL << NRF_POWER_RAMPOWER_S14POWER,
251      NRF_POWER_RAMPOWER_S15POWER_MASK = 1UL << NRF_POWER_RAMPOWER_S15POWER,
252      NRF_POWER_RAMPOWER_S0RETENTION_MASK  = 1UL << NRF_POWER_RAMPOWER_S0RETENTION ,
253      NRF_POWER_RAMPOWER_S1RETENTION_MASK  = 1UL << NRF_POWER_RAMPOWER_S1RETENTION ,
254      NRF_POWER_RAMPOWER_S2RETENTION_MASK  = 1UL << NRF_POWER_RAMPOWER_S2RETENTION ,
255      NRF_POWER_RAMPOWER_S3RETENTION_MASK  = 1UL << NRF_POWER_RAMPOWER_S3RETENTION ,
256      NRF_POWER_RAMPOWER_S4RETENTION_MASK  = 1UL << NRF_POWER_RAMPOWER_S4RETENTION ,
257      NRF_POWER_RAMPOWER_S5RETENTION_MASK  = 1UL << NRF_POWER_RAMPOWER_S5RETENTION ,
258      NRF_POWER_RAMPOWER_S7RETENTION_MASK  = 1UL << NRF_POWER_RAMPOWER_S7RETENTION ,
259      NRF_POWER_RAMPOWER_S8RETENTION_MASK  = 1UL << NRF_POWER_RAMPOWER_S8RETENTION ,
260      NRF_POWER_RAMPOWER_S9RETENTION_MASK  = 1UL << NRF_POWER_RAMPOWER_S9RETENTION ,
261      NRF_POWER_RAMPOWER_S10RETENTION_MASK = 1UL << NRF_POWER_RAMPOWER_S10RETENTION,
262      NRF_POWER_RAMPOWER_S11RETENTION_MASK = 1UL << NRF_POWER_RAMPOWER_S11RETENTION,
263      NRF_POWER_RAMPOWER_S12RETENTION_MASK = 1UL << NRF_POWER_RAMPOWER_S12RETENTION,
264      NRF_POWER_RAMPOWER_S13RETENTION_MASK = 1UL << NRF_POWER_RAMPOWER_S13RETENTION,
265      NRF_POWER_RAMPOWER_S14RETENTION_MASK = 1UL << NRF_POWER_RAMPOWER_S14RETENTION,
266      NRF_POWER_RAMPOWER_S15RETENTION_MASK = (int)(1UL << NRF_POWER_RAMPOWER_S15RETENTION),
267  } nrf_power_rampower_mask_t;
268  #endif 
269  NRF_STATIC_INLINE void nrf_power_task_trigger(NRF_POWER_Type * p_reg, nrf_power_task_t task);
270  NRF_STATIC_INLINE uint32_t nrf_power_task_address_get(NRF_POWER_Type const * p_reg,
271                                                        nrf_power_task_t       task);
272  NRF_STATIC_INLINE void nrf_power_event_clear(NRF_POWER_Type * p_reg, nrf_power_event_t event);
273  NRF_STATIC_INLINE bool nrf_power_event_check(NRF_POWER_Type const * p_reg, nrf_power_event_t event);
274  NRF_STATIC_INLINE bool nrf_power_event_get_and_clear(NRF_POWER_Type *  p_reg,
275                                                       nrf_power_event_t event);
276  NRF_STATIC_INLINE uint32_t nrf_power_event_address_get(NRF_POWER_Type const * p_reg,
277                                                         nrf_power_event_t      event);
278  NRF_STATIC_INLINE void nrf_power_int_enable(NRF_POWER_Type * p_reg, uint32_t mask);
279  NRF_STATIC_INLINE uint32_t nrf_power_int_enable_check(NRF_POWER_Type const * p_reg, uint32_t mask);
280  NRF_STATIC_INLINE uint32_t nrf_power_int_enable_get(NRF_POWER_Type const * p_reg);
281  NRF_STATIC_INLINE void nrf_power_int_disable(NRF_POWER_Type * p_reg, uint32_t mask);
282  #if defined(DPPI_PRESENT) || defined(__NRFX_DOXYGEN__)
283  NRF_STATIC_INLINE void nrf_power_subscribe_set(NRF_POWER_Type * p_reg,
284                                                 nrf_power_task_t task,
285                                                 uint8_t          channel);
286  NRF_STATIC_INLINE void nrf_power_subscribe_clear(NRF_POWER_Type * p_reg, nrf_power_task_t task);
287  NRF_STATIC_INLINE void nrf_power_publish_set(NRF_POWER_Type *  p_reg,
288                                               nrf_power_event_t event,
289                                               uint8_t           channel);
290  NRF_STATIC_INLINE void nrf_power_publish_clear(NRF_POWER_Type * p_reg, nrf_power_event_t event);
291  #endif 
292  #if NRF_POWER_HAS_RESETREAS
293  NRF_STATIC_INLINE uint32_t nrf_power_resetreas_get(NRF_POWER_Type const * p_reg);
294  NRF_STATIC_INLINE void nrf_power_resetreas_clear(NRF_POWER_Type * p_reg, uint32_t mask);
295  #endif 
296  #if defined(POWER_POWERSTATUS_LTEMODEM_Msk) || defined(__NRFX_DOXYGEN__)
297  NRF_STATIC_INLINE bool nrf_power_powerstatus_get(NRF_POWER_Type const * p_reg);
298  #endif
299  #if defined(POWER_RAMSTATUS_RAMBLOCK0_Msk) || defined(__NRFX_DOXYGEN__)
300  NRF_STATIC_INLINE uint32_t nrf_power_ramstatus_get(NRF_POWER_Type const * p_reg);
301  #endif 
302  #if defined(POWER_SYSTEMOFF_SYSTEMOFF_Enter)
303  NRF_STATIC_INLINE void nrf_power_system_off(NRF_POWER_Type * p_reg);
304  #endif 
305  #if NRF_POWER_HAS_POFCON
306  NRF_STATIC_INLINE void nrf_power_pofcon_set(NRF_POWER_Type *    p_reg,
307                                              bool                enable,
308                                              nrf_power_pof_thr_t thr);
309  NRF_STATIC_INLINE nrf_power_pof_thr_t nrf_power_pofcon_get(NRF_POWER_Type const * p_reg,
310                                                             bool *                 p_enabled);
311  #endif 
312  #if NRF_POWER_HAS_POFCON_VDDH
313  NRF_STATIC_INLINE void nrf_power_pofcon_vddh_set(NRF_POWER_Type *        p_reg,
314                                                   nrf_power_pof_thrvddh_t thr);
315  NRF_STATIC_INLINE nrf_power_pof_thrvddh_t nrf_power_pofcon_vddh_get(NRF_POWER_Type const * p_reg);
316  #endif 
317  NRF_STATIC_INLINE void nrf_power_gpregret_set(NRF_POWER_Type * p_reg, uint8_t val);
318  NRF_STATIC_INLINE uint8_t nrf_power_gpregret_get(NRF_POWER_Type const * p_reg);
319  #if defined(POWER_GPREGRET2_GPREGRET_Msk) || defined(__NRFX_DOXYGEN__)
320  NRF_STATIC_INLINE void nrf_power_gpregret2_set(NRF_POWER_Type * p_reg, uint8_t val);
321  NRF_STATIC_INLINE uint8_t nrf_power_gpregret2_get(NRF_POWER_Type const * p_reg);
322  #endif 
323  NRF_STATIC_INLINE uint8_t nrf_power_gpregret_ext_get(NRF_POWER_Type const * p_reg, uint8_t reg_num);
324  NRF_STATIC_INLINE void nrf_power_gpregret_ext_set(NRF_POWER_Type * p_reg,
325                                                    uint8_t          reg_num,
326                                                    uint8_t          val);
327  #if NRF_POWER_HAS_DCDCEN
328  NRF_STATIC_INLINE void nrf_power_dcdcen_set(NRF_POWER_Type * p_reg, bool enable);
329  NRF_STATIC_INLINE bool nrf_power_dcdcen_get(NRF_POWER_Type const * p_reg);
330  #endif 
331  #if defined(POWER_RAM_POWER_S0POWER_Msk) || defined(__NRFX_DOXYGEN__)
332  NRF_STATIC_INLINE void nrf_power_rampower_mask_on(NRF_POWER_Type * p_reg,
333                                                    uint8_t          block,
334                                                    uint32_t         section_mask);
335  NRF_STATIC_INLINE void nrf_power_rampower_mask_off(NRF_POWER_Type * p_reg,
336                                                     uint8_t          block,
337                                                     uint32_t         section_mask);
338  NRF_STATIC_INLINE uint32_t nrf_power_rampower_mask_get(NRF_POWER_Type const * p_reg, uint8_t block);
339  #endif &bsol;* defined(POWER_RAM_POWER_S0POWER_Msk) || defined(__NRFX_DOXYGEN__) */
340  #if NRF_POWER_HAS_DCDCEN_VDDH
341  NRF_STATIC_INLINE void nrf_power_dcdcen_vddh_set(NRF_POWER_Type * p_reg, bool enable);
342  NRF_STATIC_INLINE bool nrf_power_dcdcen_vddh_get(NRF_POWER_Type const * p_reg);
343  #endif 
344  #if NRF_POWER_HAS_MAINREGSTATUS
345  NRF_STATIC_INLINE
346  nrf_power_mainregstatus_t nrf_power_mainregstatus_get(NRF_POWER_Type const * p_reg);
347  #endif 
348  #if NRF_POWER_HAS_USBREG
349  NRF_STATIC_INLINE uint32_t nrf_power_usbregstatus_get(NRF_POWER_Type const * p_reg);
350  NRF_STATIC_INLINE bool nrf_power_usbregstatus_vbusdet_get(NRF_POWER_Type const * p_reg);
351  NRF_STATIC_INLINE bool nrf_power_usbregstatus_outrdy_get(NRF_POWER_Type const * p_reg);
352  #endif 
353  #ifndef NRF_DECLARE_ONLY
354  NRF_STATIC_INLINE void nrf_power_task_trigger(NRF_POWER_Type * p_reg, nrf_power_task_t task)
355  {
356      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
357  }
358  NRF_STATIC_INLINE uint32_t nrf_power_task_address_get(NRF_POWER_Type const * p_reg,
359                                                        nrf_power_task_t       task)
360  {
361      return ((uint32_t)p_reg + (uint32_t)task);
362  }
363  NRF_STATIC_INLINE void nrf_power_event_clear(NRF_POWER_Type * p_reg, nrf_power_event_t event)
364  {
365      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
366  #if __CORTEX_M == 0x04
367      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
368      (void)dummy;
369  #endif
370  }
371  NRF_STATIC_INLINE bool nrf_power_event_check(NRF_POWER_Type const * p_reg, nrf_power_event_t event)
372  {
373      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
374  }
375  NRF_STATIC_INLINE bool nrf_power_event_get_and_clear(NRF_POWER_Type *  p_reg,
376                                                       nrf_power_event_t event)
377  {
378      bool ret = nrf_power_event_check(p_reg, event);
379      if (ret)
380      {
381          nrf_power_event_clear(p_reg, event);
382      }
383      return ret;
384  }
385  NRF_STATIC_INLINE uint32_t nrf_power_event_address_get(NRF_POWER_Type const * p_reg,
386                                                         nrf_power_event_t      event)
387  {
388      return ((uint32_t)p_reg + (uint32_t)event);
389  }
390  NRF_STATIC_INLINE void nrf_power_int_enable(NRF_POWER_Type * p_reg, uint32_t mask)
391  {
392      p_reg->INTENSET = mask;
393  }
394  NRF_STATIC_INLINE uint32_t nrf_power_int_enable_check(NRF_POWER_Type const * p_reg, uint32_t mask)
395  {
396      return p_reg->INTENSET & mask;
<span onclick='openModal()' class='match'>397  }
398  NRF_STATIC_INLINE uint32_t nrf_power_int_enable_get(NRF_POWER_Type const * p_reg)
399  {
400      return p_reg->INTENSET;
401  }
402  NRF_STATIC_INLINE void nrf_power_int_disable(NRF_POWER_Type * p_reg, uint32_t mask)
403  {
404      p_reg->INTENCLR = mask;
405  }
406  #if defined(DPPI_PRESENT)
407  NRF_STATIC_INLINE void nrf_power_subscribe_set(NRF_POWER_Type * p_reg,
408                                                 nrf_power_task_t task,
409                                                 uint8_t          channel)
410  {
411      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
412              ((uint32_t)channel | POWER_SUBSCRIBE_CONSTLAT_EN_Msk);
413  }
414  NRF_STATIC_INLINE void nrf_power_subscribe_clear(NRF_POWER_Type * p_reg, nrf_power_task_t task)
415  {
416      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
417  }
418  NRF_STATIC_INLINE void nrf_power_publish_set(NRF_POWER_Type *  p_reg,
419                                               nrf_power_event_t event,
420                                               uint8_t           channel)
421  {
422      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
423              ((uint32_t)channel | POWER_PUBLISH_SLEEPENTER_EN_Msk);
424  }
425  NRF_STATIC_INLINE void nrf_power_publish_clear(NRF_POWER_Type * p_reg, nrf_power_event_t event)
426  {
427      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
428  }
</span>429  #endif 
430  #if NRF_POWER_HAS_RESETREAS
431  NRF_STATIC_INLINE uint32_t nrf_power_resetreas_get(NRF_POWER_Type const * p_reg)
432  {
433      return p_reg->RESETREAS;
434  }
435  NRF_STATIC_INLINE void nrf_power_resetreas_clear(NRF_POWER_Type * p_reg, uint32_t mask)
436  {
437      p_reg->RESETREAS = mask;
438  }
439  #endif 
440  #if defined(POWER_POWERSTATUS_LTEMODEM_Msk)
441  NRF_STATIC_INLINE bool nrf_power_powerstatus_get(NRF_POWER_Type const * p_reg)
442  {
443      return (p_reg->POWERSTATUS & POWER_POWERSTATUS_LTEMODEM_Msk) ==
444             (POWER_POWERSTATUS_LTEMODEM_ON << POWER_POWERSTATUS_LTEMODEM_Pos);
445  }
446  #endif 
447  #if defined(POWER_RAMSTATUS_RAMBLOCK0_Msk)
448  NRF_STATIC_INLINE uint32_t nrf_power_ramstatus_get(NRF_POWER_Type const * p_reg)
449  {
450      return p_reg->RAMSTATUS;
451  }
452  #endif 
453  #if defined(POWER_SYSTEMOFF_SYSTEMOFF_Enter)
454  NRF_STATIC_INLINE void nrf_power_system_off(NRF_POWER_Type * p_reg)
455  {
456      p_reg->SYSTEMOFF = POWER_SYSTEMOFF_SYSTEMOFF_Enter;
457      __DSB();
458      while (true)
459      {
460          __WFE();
461      }
462  }
463  #endif 
464  #if NRF_POWER_HAS_POFCON
465  NRF_STATIC_INLINE void nrf_power_pofcon_set(NRF_POWER_Type *    p_reg,
466                                              bool                enable,
467                                              nrf_power_pof_thr_t thr)
468  {
469      NRFX_ASSERT(thr == (thr & (POWER_POFCON_THRESHOLD_Msk >> POWER_POFCON_THRESHOLD_Pos)));
470  #if NRF_POWER_HAS_POFCON_VDDH
471      uint32_t pofcon = p_reg->POFCON;
472      pofcon &= ~(POWER_POFCON_THRESHOLD_Msk | POWER_POFCON_POF_Msk);
473      pofcon |=
474  #else 
475      p_reg->POFCON =
476  #endif
477          (((uint32_t)thr) << POWER_POFCON_THRESHOLD_Pos) |
478          (enable ?
479          (POWER_POFCON_POF_Enabled << POWER_POFCON_POF_Pos)
480          :
481          (POWER_POFCON_POF_Disabled << POWER_POFCON_POF_Pos));
482  #if NRF_POWER_HAS_POFCON_VDDH
483      p_reg->POFCON = pofcon;
484  #endif
485  }
486  NRF_STATIC_INLINE nrf_power_pof_thr_t nrf_power_pofcon_get(NRF_POWER_Type const * p_reg,
487                                                             bool *                 p_enabled)
488  {
489      uint32_t pofcon = p_reg->POFCON;
490      if (NULL != p_enabled)
491      {
492          (*p_enabled) = ((pofcon & POWER_POFCON_POF_Msk) >> POWER_POFCON_POF_Pos)
493              == POWER_POFCON_POF_Enabled;
494      }
495      return (nrf_power_pof_thr_t)((pofcon & POWER_POFCON_THRESHOLD_Msk) >>
496          POWER_POFCON_THRESHOLD_Pos);
497  }
498  #endif 
499  #if NRF_POWER_HAS_POFCON_VDDH
500  NRF_STATIC_INLINE void nrf_power_pofcon_vddh_set(NRF_POWER_Type *        p_reg,
501                                                   nrf_power_pof_thrvddh_t thr)
502  {
503      NRFX_ASSERT(thr == (thr & (POWER_POFCON_THRESHOLDVDDH_Msk >> POWER_POFCON_THRESHOLDVDDH_Pos)));
504      uint32_t pofcon = p_reg->POFCON;
505      pofcon &= ~POWER_POFCON_THRESHOLDVDDH_Msk;
506      pofcon |= (((uint32_t)thr) << POWER_POFCON_THRESHOLDVDDH_Pos);
507      p_reg->POFCON = pofcon;
508  }
509  NRF_STATIC_INLINE nrf_power_pof_thrvddh_t nrf_power_pofcon_vddh_get(NRF_POWER_Type const * p_reg)
510  {
511      return (nrf_power_pof_thrvddh_t)((p_reg->POFCON & POWER_POFCON_THRESHOLDVDDH_Msk) >>
512                                       POWER_POFCON_THRESHOLDVDDH_Pos);
513  }
514  #endif 
515  NRF_STATIC_INLINE void nrf_power_gpregret_set(NRF_POWER_Type * p_reg, uint8_t val)
516  {
517      volatile uint32_t * p_gpregret;
518      if (sizeof(p_reg->GPREGRET) > sizeof(uint32_t))
519      {
520          p_gpregret = &((volatile uint32_t *)p_reg->GPREGRET)[0];
521      }
522      else
523      {
524          p_gpregret = &((volatile uint32_t *)&p_reg->GPREGRET)[0];
525      }
526      *p_gpregret = val;
527  }
528  NRF_STATIC_INLINE uint8_t nrf_power_gpregret_get(NRF_POWER_Type const * p_reg)
529  {
530      volatile uint32_t * p_gpregret;
531      if (sizeof(p_reg->GPREGRET) > sizeof(uint32_t))
532      {
533          p_gpregret = &((volatile uint32_t *)p_reg->GPREGRET)[0];
534      }
535      else
536      {
537          p_gpregret = &((volatile uint32_t *)&p_reg->GPREGRET)[0];
538      }
539      return *p_gpregret;
540  }
541  NRF_STATIC_INLINE void nrf_power_gpregret_ext_set(NRF_POWER_Type * p_reg,
542                                                    uint8_t          reg_num,
543                                                    uint8_t          val)
544  {
545  #if defined(NRF91_SERIES) || defined(NRF5340_XXAA_APPLICATION) || defined(NRF5340_XXAA_NETWORK)
546      p_reg->GPREGRET[reg_num] = val;
547  #else
548      NRFX_ASSERT(reg_num < 1);
549      p_reg->GPREGRET = val;
550  #endif
551  }
552  NRF_STATIC_INLINE uint8_t nrf_power_gpregret_ext_get(NRF_POWER_Type const * p_reg, uint8_t reg_num)
553  {
554  #if defined(NRF91_SERIES) || defined(NRF5340_XXAA_APPLICATION) || defined(NRF5340_XXAA_NETWORK)
555      return p_reg->GPREGRET[reg_num];
556  #else
557      NRFX_ASSERT(reg_num < 1);
558      return p_reg->GPREGRET;
559  #endif
560  }
561  #if defined(POWER_GPREGRET2_GPREGRET_Msk)
562  NRF_STATIC_INLINE void nrf_power_gpregret2_set(NRF_POWER_Type * p_reg, uint8_t val)
563  {
564      p_reg->GPREGRET2 = val;
565  }
566  NRF_STATIC_INLINE uint8_t nrf_power_gpregret2_get(NRF_POWER_Type const * p_reg)
567  {
568      return p_reg->GPREGRET2;
569  }
570  #endif
571  #if NRF_POWER_HAS_DCDCEN
572  NRF_STATIC_INLINE void nrf_power_dcdcen_set(NRF_POWER_Type * p_reg, bool enable)
573  {
574      p_reg->DCDCEN = (enable ? POWER_DCDCEN_DCDCEN_Enabled : POWER_DCDCEN_DCDCEN_Disabled) <<
575                      POWER_DCDCEN_DCDCEN_Pos;
576  }
577  NRF_STATIC_INLINE bool nrf_power_dcdcen_get(NRF_POWER_Type const * p_reg)
578  {
579      return (p_reg->DCDCEN & POWER_DCDCEN_DCDCEN_Msk)
580              ==
581             (POWER_DCDCEN_DCDCEN_Enabled << POWER_DCDCEN_DCDCEN_Pos);
582  }
583  #endif 
584  #if defined(POWER_RAM_POWER_S0POWER_Msk)
585  NRF_STATIC_INLINE void nrf_power_rampower_mask_on(NRF_POWER_Type * p_reg,
586                                                    uint8_t          block,
587                                                    uint32_t         section_mask)
588  {
589      p_reg->RAM[block].POWERSET = section_mask;
590  }
591  NRF_STATIC_INLINE void nrf_power_rampower_mask_off(NRF_POWER_Type * p_reg,
592                                                     uint8_t          block,
593                                                     uint32_t         section_mask)
594  {
595      p_reg->RAM[block].POWERCLR = section_mask;
596  }
597  NRF_STATIC_INLINE uint32_t nrf_power_rampower_mask_get(NRF_POWER_Type const * p_reg, uint8_t block)
598  {
599      return p_reg->RAM[block].POWER;
600  }
601  #endif 
602  #if NRF_POWER_HAS_DCDCEN_VDDH
603  NRF_STATIC_INLINE void nrf_power_dcdcen_vddh_set(NRF_POWER_Type * p_reg, bool enable)
604  {
605      p_reg->DCDCEN0 = (enable ? POWER_DCDCEN0_DCDCEN_Enabled : POWER_DCDCEN0_DCDCEN_Disabled) <<
606                       POWER_DCDCEN0_DCDCEN_Pos;
607  }
608  NRF_STATIC_INLINE bool nrf_power_dcdcen_vddh_get(NRF_POWER_Type const * p_reg)
609  {
610      return (p_reg->DCDCEN0 & POWER_DCDCEN0_DCDCEN_Msk)
611              ==
612             (POWER_DCDCEN0_DCDCEN_Enabled << POWER_DCDCEN0_DCDCEN_Pos);
613  }
614  #endif 
615  #if NRF_POWER_HAS_MAINREGSTATUS
616  NRF_STATIC_INLINE
617  nrf_power_mainregstatus_t nrf_power_mainregstatus_get(NRF_POWER_Type const * p_reg)
618  {
619      return (nrf_power_mainregstatus_t)(((p_reg->MAINREGSTATUS) &
620          POWER_MAINREGSTATUS_MAINREGSTATUS_Msk) >>
621          POWER_MAINREGSTATUS_MAINREGSTATUS_Pos);
622  }
623  #endif 
624  #if NRF_POWER_HAS_USBREG
625  NRF_STATIC_INLINE uint32_t nrf_power_usbregstatus_get(NRF_POWER_Type const * p_reg)
626  {
627      return p_reg->USBREGSTATUS;
628  }
629  NRF_STATIC_INLINE bool nrf_power_usbregstatus_vbusdet_get(NRF_POWER_Type const * p_reg)
630  {
631      return (nrf_power_usbregstatus_get(p_reg) & NRF_POWER_USBREGSTATUS_VBUSDETECT_MASK) != 0;
632  }
633  NRF_STATIC_INLINE bool nrf_power_usbregstatus_outrdy_get(NRF_POWER_Type const * p_reg)
634  {
635      return (nrf_power_usbregstatus_get(p_reg) & NRF_POWER_USBREGSTATUS_OUTPUTRDY_MASK) != 0;
636  }
637  #endif 
638  #endif 
639  #ifdef __cplusplus
640  }
641  #endif
642  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_uarte.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_power.h</div>
                <div class="column column_space"><pre><code>194  }
195  NRF_STATIC_INLINE uint32_t nrf_uarte_int_enable_check(NRF_UARTE_Type const * p_reg, uint32_t mask)
196  {
197      return p_reg->INTENSET & mask;
198  }
199  NRF_STATIC_INLINE void nrf_uarte_int_disable(NRF_UARTE_Type * p_reg, uint32_t mask)
200  {
201      p_reg->INTENCLR = mask;
202  }
203  #if defined(DPPI_PRESENT)
204  NRF_STATIC_INLINE void nrf_uarte_subscribe_set(NRF_UARTE_Type * p_reg,
205                                                 nrf_uarte_task_t task,
206                                                 uint8_t          channel)
207  {
208      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
209              ((uint32_t)channel | UARTE_SUBSCRIBE_STARTRX_EN_Msk);
210  }
211  NRF_STATIC_INLINE void nrf_uarte_subscribe_clear(NRF_UARTE_Type * p_reg,
212                                                   nrf_uarte_task_t task)
213  {
214      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
215  }
216  NRF_STATIC_INLINE void nrf_uarte_publish_set(NRF_UARTE_Type *  p_reg,
217                                               nrf_uarte_event_t event,
218                                               uint8_t           channel)
219  {
220      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
221              ((uint32_t)channel | UARTE_PUBLISH_CTS_EN_Msk);
222  }
223  NRF_STATIC_INLINE void nrf_uarte_publish_clear(NRF_UARTE_Type *  p_reg,
224                                                 nrf_uarte_event_t event)
225  {
226      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
227  }
</pre></code></div>
                <div class="column column_space"><pre><code>397  }
398  NRF_STATIC_INLINE uint32_t nrf_power_int_enable_get(NRF_POWER_Type const * p_reg)
399  {
400      return p_reg->INTENSET;
401  }
402  NRF_STATIC_INLINE void nrf_power_int_disable(NRF_POWER_Type * p_reg, uint32_t mask)
403  {
404      p_reg->INTENCLR = mask;
405  }
406  #if defined(DPPI_PRESENT)
407  NRF_STATIC_INLINE void nrf_power_subscribe_set(NRF_POWER_Type * p_reg,
408                                                 nrf_power_task_t task,
409                                                 uint8_t          channel)
410  {
411      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
412              ((uint32_t)channel | POWER_SUBSCRIBE_CONSTLAT_EN_Msk);
413  }
414  NRF_STATIC_INLINE void nrf_power_subscribe_clear(NRF_POWER_Type * p_reg, nrf_power_task_t task)
415  {
416      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
417  }
418  NRF_STATIC_INLINE void nrf_power_publish_set(NRF_POWER_Type *  p_reg,
419                                               nrf_power_event_t event,
420                                               uint8_t           channel)
421  {
422      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
423              ((uint32_t)channel | POWER_PUBLISH_SLEEPENTER_EN_Msk);
424  }
425  NRF_STATIC_INLINE void nrf_power_publish_clear(NRF_POWER_Type * p_reg, nrf_power_event_t event)
426  {
427      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
428  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    