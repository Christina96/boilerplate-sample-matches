
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.787330316742081%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-stats_13.c</h3>
            <pre><code>1  #define JEMALLOC_STATS_C_
2  #include "jemalloc/internal/jemalloc_preamble.h"
3  #include "jemalloc/internal/jemalloc_internal_includes.h"
4  #include "jemalloc/internal/assert.h"
5  #include "jemalloc/internal/ctl.h"
6  #include "jemalloc/internal/emitter.h"
7  #include "jemalloc/internal/mutex.h"
8  #include "jemalloc/internal/mutex_prof.h"
9  const char *global_mutex_names[mutex_prof_num_global_mutexes] = {
10  #define OP(mtx) #mtx,
11  	MUTEX_PROF_GLOBAL_MUTEXES
12  #undef OP
13  };
14  const char *arena_mutex_names[mutex_prof_num_arena_mutexes] = {
15  #define OP(mtx) #mtx,
16  	MUTEX_PROF_ARENA_MUTEXES
17  #undef OP
18  };
19  #define CTL_GET(n, v, t) do {						\
20  	size_t sz = sizeof(t);						\
21  	xmallctl(n, (void *)v, &sz, NULL, 0);				\
22  } while (0)
23  #define CTL_M2_GET(n, i, v, t) do {					\
24  	size_t mib[CTL_MAX_DEPTH];					\
25  	size_t miblen = sizeof(mib) / sizeof(size_t);			\
26  	size_t sz = sizeof(t);						\
27  	xmallctlnametomib(n, mib, &miblen);				\
28  	mib[2] = (i);							\
29  	xmallctlbymib(mib, miblen, (void *)v, &sz, NULL, 0);		\
30  } while (0)
31  #define CTL_M2_M4_GET(n, i, j, v, t) do {				\
32  	size_t mib[CTL_MAX_DEPTH];					\
33  	size_t miblen = sizeof(mib) / sizeof(size_t);			\
34  	size_t sz = sizeof(t);						\
35  	xmallctlnametomib(n, mib, &miblen);				\
36  	mib[2] = (i);							\
37  	mib[4] = (j);							\
38  	xmallctlbymib(mib, miblen, (void *)v, &sz, NULL, 0);		\
39  } while (0)
40  bool opt_stats_print = false;
41  char opt_stats_print_opts[stats_print_tot_num_options+1] = "";
42  static uint64_t
43  rate_per_second(uint64_t value, uint64_t uptime_ns) {
44  	uint64_t billion = 1000000000;
45  	if (uptime_ns == 0 || value == 0) {
46  		return 0;
47  	}
48  	if (uptime_ns < billion) {
49  		return value;
50  	} else {
51  		uint64_t uptime_s = uptime_ns / billion;
52  		return value / uptime_s;
53  	}
54  }
55  static bool
56  get_rate_str(uint64_t dividend, uint64_t divisor, char str[6]) {
57  	if (divisor == 0 || dividend > divisor) {
58  		return true;
59  	}
60  	if (dividend > 0) {
61  		assert(UINT64_MAX / dividend >= 1000);
62  	}
63  	unsigned n = (unsigned)((dividend * 1000) / divisor);
64  	if (n < 10) {
65  		malloc_snprintf(str, 6, "0.00%u", n);
66  	} else if (n < 100) {
67  		malloc_snprintf(str, 6, "0.0%u", n);
68  	} else if (n < 1000) {
69  		malloc_snprintf(str, 6, "0.%u", n);
70  	} else {
71  		malloc_snprintf(str, 6, "1");
72  	}
73  	return false;
74  }
75  #define MUTEX_CTL_STR_MAX_LENGTH 128
76  static void
77  gen_mutex_ctl_str(char *str, size_t buf_len, const char *prefix,
78      const char *mutex, const char *counter) {
79  	malloc_snprintf(str, buf_len, "stats.%s.%s.%s", prefix, mutex, counter);
80  }
81  static void
82  mutex_stats_init_cols(emitter_row_t *row, const char *table_name,
83      emitter_col_t *name,
84      emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
85      emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters]) {
86  	mutex_prof_uint64_t_counter_ind_t k_uint64_t = 0;
87  	mutex_prof_uint32_t_counter_ind_t k_uint32_t = 0;
88  	emitter_col_t *col;
89  	if (name != NULL) {
90  		emitter_col_init(name, row);
91  		name->justify = emitter_justify_left;
92  		name->width = 21;
93  		name->type = emitter_type_title;
94  		name->str_val = table_name;
95  	}
96  #define WIDTH_uint32_t 12
97  #define WIDTH_uint64_t 16
98  #define OP(counter, counter_type, human, derived, base_counter)	\
99  	col = &col_##counter_type[k_##counter_type];			\
100  	++k_##counter_type;						\
101  	emitter_col_init(col, row);					\
102  	col->justify = emitter_justify_right;				\
103  	col->width = derived ? 8 : WIDTH_##counter_type;		\
104  	col->type = emitter_type_title;					\
105  	col->str_val = human;
106  	MUTEX_PROF_COUNTERS
107  #undef OP
108  #undef WIDTH_uint32_t
109  #undef WIDTH_uint64_t
110  	col_uint64_t[mutex_counter_total_wait_time_ps].width = 10;
111  }
112  static void
113  mutex_stats_read_global(const char *name, emitter_col_t *col_name,
114      emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
115      emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters],
116      uint64_t uptime) {
117  	char cmd[MUTEX_CTL_STR_MAX_LENGTH];
118  	col_name->str_val = name;
119  	emitter_col_t *dst;
120  #define EMITTER_TYPE_uint32_t emitter_type_uint32
121  #define EMITTER_TYPE_uint64_t emitter_type_uint64
122  #define OP(counter, counter_type, human, derived, base_counter)	\
123  	dst = &col_##counter_type[mutex_counter_##counter];		\
124  	dst->type = EMITTER_TYPE_##counter_type;			\
125  	if (!derived) {							\
126  		gen_mutex_ctl_str(cmd, MUTEX_CTL_STR_MAX_LENGTH,	\
127  		    "mutexes", name, #counter);				\
128  		CTL_GET(cmd, (counter_type *)&dst->bool_val, counter_type);	\
129  	} else { \
130  	    emitter_col_t *base = &col_##counter_type[mutex_counter_##base_counter];	\
131  	    dst->counter_type##_val = rate_per_second(base->counter_type##_val, uptime); \
132  	}
133  	MUTEX_PROF_COUNTERS
134  #undef OP
135  #undef EMITTER_TYPE_uint32_t
136  #undef EMITTER_TYPE_uint64_t
137  }
138  static void
139  mutex_stats_read_arena(unsigned arena_ind, mutex_prof_arena_ind_t mutex_ind,
140      const char *name, emitter_col_t *col_name,
141      emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
142      emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters],
143      uint64_t uptime) {
144  	char cmd[MUTEX_CTL_STR_MAX_LENGTH];
145  	col_name->str_val = name;
146  	emitter_col_t *dst;
147  #define EMITTER_TYPE_uint32_t emitter_type_uint32
148  #define EMITTER_TYPE_uint64_t emitter_type_uint64
149  #define OP(counter, counter_type, human, derived, base_counter)	\
150  	dst = &col_##counter_type[mutex_counter_##counter];		\
151  	dst->type = EMITTER_TYPE_##counter_type;			\
152  	if (!derived) {                                   \
153  		gen_mutex_ctl_str(cmd, MUTEX_CTL_STR_MAX_LENGTH,        \
154  		    "arenas.0.mutexes", arena_mutex_names[mutex_ind], #counter);\
155  		CTL_M2_GET(cmd, arena_ind, (counter_type *)&dst->bool_val, counter_type); \
156  	} else {                      \
157  		emitter_col_t *base = &col_##counter_type[mutex_counter_##base_counter];	\
158  		dst->counter_type##_val = rate_per_second(base->counter_type##_val, uptime); \
159  	}
160  	MUTEX_PROF_COUNTERS
161  #undef OP
162  #undef EMITTER_TYPE_uint32_t
163  #undef EMITTER_TYPE_uint64_t
164  }
165  static void
166  mutex_stats_read_arena_bin(unsigned arena_ind, unsigned bin_ind,
167      emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
168      emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters],
169      uint64_t uptime) {
170  	char cmd[MUTEX_CTL_STR_MAX_LENGTH];
171  	emitter_col_t *dst;
172  #define EMITTER_TYPE_uint32_t emitter_type_uint32
173  #define EMITTER_TYPE_uint64_t emitter_type_uint64
174  #define OP(counter, counter_type, human, derived, base_counter)	\
175  	dst = &col_##counter_type[mutex_counter_##counter];		\
176  	dst->type = EMITTER_TYPE_##counter_type;			\
177  	if (!derived) {                                   \
178  		gen_mutex_ctl_str(cmd, MUTEX_CTL_STR_MAX_LENGTH,        \
179  		    "arenas.0.bins.0","mutex", #counter);            \
180  		CTL_M2_M4_GET(cmd, arena_ind, bin_ind,                \
181  		    (counter_type *)&dst->bool_val, counter_type);  \
182  	} else {                      \
183  		emitter_col_t *base = &col_##counter_type[mutex_counter_##base_counter]; \
184  		dst->counter_type##_val = rate_per_second(base->counter_type##_val, uptime); \
185  	}
186  	MUTEX_PROF_COUNTERS
187  #undef OP
188  #undef EMITTER_TYPE_uint32_t
189  #undef EMITTER_TYPE_uint64_t
190  }
191  static void
192  mutex_stats_emit(emitter_t *emitter, emitter_row_t *row,
193      emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
194      emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters]) {
195  	if (row != NULL) {
196  		emitter_table_row(emitter, row);
197  	}
198  	mutex_prof_uint64_t_counter_ind_t k_uint64_t = 0;
199  	mutex_prof_uint32_t_counter_ind_t k_uint32_t = 0;
200  	emitter_col_t *col;
201  #define EMITTER_TYPE_uint32_t emitter_type_uint32
202  #define EMITTER_TYPE_uint64_t emitter_type_uint64
203  #define OP(counter, type, human, derived, base_counter)		\
204  	if (!derived) {                    \
205  		col = &col_##type[k_##type];                        \
206  		++k_##type;                            \
207  		emitter_json_kv(emitter, #counter, EMITTER_TYPE_##type,        \
208  		    (const void *)&col->bool_val); \
209  	}
210  	MUTEX_PROF_COUNTERS;
211  #undef OP
212  #undef EMITTER_TYPE_uint32_t
213  #undef EMITTER_TYPE_uint64_t
214  }
215  #define COL(row_name, column_name, left_or_right, col_width, etype)      \
216  	emitter_col_t col_##column_name;                                     \
217  	emitter_col_init(&col_##column_name, &row_name);                     \
218  	col_##column_name.justify = emitter_justify_##left_or_right;         \
219  	col_##column_name.width = col_width;                                 \
220  	col_##column_name.type = emitter_type_##etype;
221  #define COL_HDR(row_name, column_name, human, left_or_right, col_width, etype)  \
222  	COL(row_name, column_name, left_or_right, col_width, etype)	         \
223  	emitter_col_t header_##column_name;                                  \
224  	emitter_col_init(&header_##column_name, &header_##row_name);         \
225  	header_##column_name.justify = emitter_justify_##left_or_right;      \
226  	header_##column_name.width = col_width;                              \
227  	header_##column_name.type = emitter_type_title;                      \
228  	header_##column_name.str_val = human ? human : #column_name;
229  static void
230  stats_arena_bins_print(emitter_t *emitter, bool mutex, unsigned i, uint64_t uptime) {
231  	size_t page;
232  	bool in_gap, in_gap_prev;
233  	unsigned nbins, j;
234  	CTL_GET("arenas.page", &page, size_t);
235  	CTL_GET("arenas.nbins", &nbins, unsigned);
236  	emitter_row_t header_row;
237  	emitter_row_init(&header_row);
238  	emitter_row_t row;
239  	emitter_row_init(&row);
240  	COL_HDR(row, size, NULL, right, 20, size)
241  	COL_HDR(row, ind, NULL, right, 4, unsigned)
242  	COL_HDR(row, allocated, NULL, right, 13, uint64)
243  	COL_HDR(row, nmalloc, NULL, right, 13, uint64)
244  	COL_HDR(row, nmalloc_ps, "(#/sec)", right, 8, uint64)
245  	COL_HDR(row, ndalloc, NULL, right, 13, uint64)
246  	COL_HDR(row, ndalloc_ps, "(#/sec)", right, 8, uint64)
247  	COL_HDR(row, nrequests, NULL, right, 13, uint64)
248  	COL_HDR(row, nrequests_ps, "(#/sec)", right, 10, uint64)
249  	COL_HDR(row, nshards, NULL, right, 9, unsigned)
250  	COL_HDR(row, curregs, NULL, right, 13, size)
251  	COL_HDR(row, curslabs, NULL, right, 13, size)
252  	COL_HDR(row, nonfull_slabs, NULL, right, 15, size)
253  	COL_HDR(row, regs, NULL, right, 5, unsigned)
254  	COL_HDR(row, pgs, NULL, right, 4, size)
255  	COL_HDR(row, justify_spacer, NULL, right, 1, title)
256  	COL_HDR(row, util, NULL, right, 6, title)
257  	COL_HDR(row, nfills, NULL, right, 13, uint64)
258  	COL_HDR(row, nfills_ps, "(#/sec)", right, 8, uint64)
259  	COL_HDR(row, nflushes, NULL, right, 13, uint64)
260  	COL_HDR(row, nflushes_ps, "(#/sec)", right, 8, uint64)
261  	COL_HDR(row, nslabs, NULL, right, 13, uint64)
262  	COL_HDR(row, nreslabs, NULL, right, 13, uint64)
263  	COL_HDR(row, nreslabs_ps, "(#/sec)", right, 8, uint64)
264  	header_justify_spacer.str_val = " ";
265  	col_justify_spacer.str_val = " ";
266  	emitter_col_t col_mutex64[mutex_prof_num_uint64_t_counters];
267  	emitter_col_t col_mutex32[mutex_prof_num_uint32_t_counters];
268  	emitter_col_t header_mutex64[mutex_prof_num_uint64_t_counters];
269  	emitter_col_t header_mutex32[mutex_prof_num_uint32_t_counters];
270  	if (mutex) {
271  		mutex_stats_init_cols(&row, NULL, NULL, col_mutex64,
272  		    col_mutex32);
273  		mutex_stats_init_cols(&header_row, NULL, NULL, header_mutex64,
274  		    header_mutex32);
275  	}
276  	header_size.width -=5;
277  	emitter_table_printf(emitter, "bins:");
278  	emitter_table_row(emitter, &header_row);
279  	emitter_json_array_kv_begin(emitter, "bins");
280  	for (j = 0, in_gap = false; j < nbins; j++) {
281  		uint64_t nslabs;
282  		size_t reg_size, slab_size, curregs;
283  		size_t curslabs;
284  		size_t nonfull_slabs;
285  		uint32_t nregs, nshards;
286  		uint64_t nmalloc, ndalloc, nrequests, nfills, nflushes;
287  		uint64_t nreslabs;
288  		CTL_M2_M4_GET("stats.arenas.0.bins.0.nslabs", i, j, &nslabs,
289  		    uint64_t);
290  		in_gap_prev = in_gap;
291  		in_gap = (nslabs == 0);
292  		if (in_gap_prev && !in_gap) {
293  			emitter_table_printf(emitter,
294  			    "                     ---\n");
295  		}
296  		CTL_M2_GET("arenas.bin.0.size", j, &reg_size, size_t);
297  		CTL_M2_GET("arenas.bin.0.nregs", j, &nregs, uint32_t);
298  		CTL_M2_GET("arenas.bin.0.slab_size", j, &slab_size, size_t);
299  		CTL_M2_GET("arenas.bin.0.nshards", j, &nshards, uint32_t);
300  		CTL_M2_M4_GET("stats.arenas.0.bins.0.nmalloc", i, j, &nmalloc,
301  		    uint64_t);
302  		CTL_M2_M4_GET("stats.arenas.0.bins.0.ndalloc", i, j, &ndalloc,
303  		    uint64_t);
304  		CTL_M2_M4_GET("stats.arenas.0.bins.0.curregs", i, j, &curregs,
305  		    size_t);
306  		CTL_M2_M4_GET("stats.arenas.0.bins.0.nrequests", i, j,
307  		    &nrequests, uint64_t);
308  		CTL_M2_M4_GET("stats.arenas.0.bins.0.nfills", i, j, &nfills,
309  		    uint64_t);
310  		CTL_M2_M4_GET("stats.arenas.0.bins.0.nflushes", i, j, &nflushes,
311  		    uint64_t);
312  		CTL_M2_M4_GET("stats.arenas.0.bins.0.nreslabs", i, j, &nreslabs,
313  		    uint64_t);
314  		CTL_M2_M4_GET("stats.arenas.0.bins.0.curslabs", i, j, &curslabs,
315  		    size_t);
316  		CTL_M2_M4_GET("stats.arenas.0.bins.0.nonfull_slabs", i, j, &nonfull_slabs,
317  		    size_t);
318  		if (mutex) {
319  			mutex_stats_read_arena_bin(i, j, col_mutex64,
320  			    col_mutex32, uptime);
321  		}
322  		emitter_json_object_begin(emitter);
323  		emitter_json_kv(emitter, "nmalloc", emitter_type_uint64,
324  		    &nmalloc);
325  		emitter_json_kv(emitter, "ndalloc", emitter_type_uint64,
326  		    &ndalloc);
327  		emitter_json_kv(emitter, "curregs", emitter_type_size,
328  		    &curregs);
329  		emitter_json_kv(emitter, "nrequests", emitter_type_uint64,
330  		    &nrequests);
331  		emitter_json_kv(emitter, "nfills", emitter_type_uint64,
332  		    &nfills);
333  		emitter_json_kv(emitter, "nflushes", emitter_type_uint64,
334  		    &nflushes);
335  		emitter_json_kv(emitter, "nreslabs", emitter_type_uint64,
336  		    &nreslabs);
337  		emitter_json_kv(emitter, "curslabs", emitter_type_size,
338  		    &curslabs);
339  		emitter_json_kv(emitter, "nonfull_slabs", emitter_type_size,
340  		    &nonfull_slabs);
341  		if (mutex) {
342  			emitter_json_object_kv_begin(emitter, "mutex");
343  			mutex_stats_emit(emitter, NULL, col_mutex64,
344  			    col_mutex32);
345  			emitter_json_object_end(emitter);
346  		}
347  		emitter_json_object_end(emitter);
348  		size_t availregs = nregs * curslabs;
349  		char util[6];
350  		if (get_rate_str((uint64_t)curregs, (uint64_t)availregs, util))
351  		{
352  			if (availregs == 0) {
353  				malloc_snprintf(util, sizeof(util), "1");
354  			} else if (curregs > availregs) {
355  				malloc_snprintf(util, sizeof(util), " race");
356  			} else {
357  				not_reached();
358  			}
359  		}
360  		col_size.size_val = reg_size;
361  		col_ind.unsigned_val = j;
362  		col_allocated.size_val = curregs * reg_size;
363  		col_nmalloc.uint64_val = nmalloc;
364  		col_nmalloc_ps.uint64_val = rate_per_second(nmalloc, uptime);
365  		col_ndalloc.uint64_val = ndalloc;
366  		col_ndalloc_ps.uint64_val = rate_per_second(ndalloc, uptime);
367  		col_nrequests.uint64_val = nrequests;
368  		col_nrequests_ps.uint64_val = rate_per_second(nrequests, uptime);
369  		col_nshards.unsigned_val = nshards;
370  		col_curregs.size_val = curregs;
371  		col_curslabs.size_val = curslabs;
372  		col_nonfull_slabs.size_val = nonfull_slabs;
373  		col_regs.unsigned_val = nregs;
374  		col_pgs.size_val = slab_size / page;
375  		col_util.str_val = util;
376  		col_nfills.uint64_val = nfills;
377  		col_nfills_ps.uint64_val = rate_per_second(nfills, uptime);
378  		col_nflushes.uint64_val = nflushes;
379  		col_nflushes_ps.uint64_val = rate_per_second(nflushes, uptime);
380  		col_nslabs.uint64_val = nslabs;
381  		col_nreslabs.uint64_val = nreslabs;
382  		col_nreslabs_ps.uint64_val = rate_per_second(nreslabs, uptime);
383  		emitter_table_row(emitter, &row);
384  	}
385  	emitter_json_array_end(emitter); &bsol;* Close "bins". */
386  	if (in_gap) {
387  		emitter_table_printf(emitter, "                     ---\n");
388  	}
389  }
390  static void
391  stats_arena_lextents_print(emitter_t *emitter, unsigned i, uint64_t uptime) {
392  	unsigned nbins, nlextents, j;
393  	bool in_gap, in_gap_prev;
394  	CTL_GET("arenas.nbins", &nbins, unsigned);
395  	CTL_GET("arenas.nlextents", &nlextents, unsigned);
396  	emitter_row_t header_row;
397  	emitter_row_init(&header_row);
398  	emitter_row_t row;
399  	emitter_row_init(&row);
400  	COL_HDR(row, size, NULL, right, 20, size)
401  	COL_HDR(row, ind, NULL, right, 4, unsigned)
402  	COL_HDR(row, allocated, NULL, right, 13, size)
403  	COL_HDR(row, nmalloc, NULL, right, 13, uint64)
404  	COL_HDR(row, nmalloc_ps, "(#/sec)", right, 8, uint64)
405  	COL_HDR(row, ndalloc, NULL, right, 13, uint64)
406  	COL_HDR(row, ndalloc_ps, "(#/sec)", right, 8, uint64)
407  	COL_HDR(row, nrequests, NULL, right, 13, uint64)
408  	COL_HDR(row, nrequests_ps, "(#/sec)", right, 8, uint64)
409  	COL_HDR(row, curlextents, NULL, right, 13, size)
410  	header_size.width -= 6;
411  	emitter_table_printf(emitter, "large:");
412  	emitter_table_row(emitter, &header_row);
413  	emitter_json_array_kv_begin(emitter, "lextents");
414  	for (j = 0, in_gap = false; j < nlextents; j++) {
415  		uint64_t nmalloc, ndalloc, nrequests;
416  		size_t lextent_size, curlextents;
417  		CTL_M2_M4_GET("stats.arenas.0.lextents.0.nmalloc", i, j,
418  		    &nmalloc, uint64_t);
419  		CTL_M2_M4_GET("stats.arenas.0.lextents.0.ndalloc", i, j,
420  		    &ndalloc, uint64_t);
421  		CTL_M2_M4_GET("stats.arenas.0.lextents.0.nrequests", i, j,
422  		    &nrequests, uint64_t);
423  		in_gap_prev = in_gap;
424  		in_gap = (nrequests == 0);
425  		if (in_gap_prev && !in_gap) {
426  			emitter_table_printf(emitter,
427  			    "                     ---\n");
428  		}
429  		CTL_M2_GET("arenas.lextent.0.size", j, &lextent_size, size_t);
430  		CTL_M2_M4_GET("stats.arenas.0.lextents.0.curlextents", i, j,
431  		    &curlextents, size_t);
432  		emitter_json_object_begin(emitter);
433  		emitter_json_kv(emitter, "curlextents", emitter_type_size,
434  		    &curlextents);
435  		emitter_json_object_end(emitter);
436  		col_size.size_val = lextent_size;
437  		col_ind.unsigned_val = nbins + j;
<span onclick='openModal()' class='match'>438  		col_allocated.size_val = curlextents * lextent_size;
439  		col_nmalloc.uint64_val = nmalloc;
440  		col_nmalloc_ps.uint64_val = rate_per_second(nmalloc, uptime);
441  		col_ndalloc.uint64_val = ndalloc;
442  		col_ndalloc_ps.uint64_val = rate_per_second(ndalloc, uptime);
443  		col_nrequests.uint64_val = nrequests;
444  		col_nrequests_ps.uint64_val = rate_per_second(nrequests, uptime);
445  		col_curlextents.size_val = curlextents;
446  		if (!in_gap) {
</span>447  			emitter_table_row(emitter, &row);
448  		}
449  	}
450  	emitter_json_array_end(emitter); &bsol;* Close "lextents". */
451  	if (in_gap) {
452  		emitter_table_printf(emitter, "                     ---\n");
453  	}
454  }
455  static void
456  stats_arena_extents_print(emitter_t *emitter, unsigned i) {
457  	unsigned j;
458  	bool in_gap, in_gap_prev;
459  	emitter_row_t header_row;
460  	emitter_row_init(&header_row);
461  	emitter_row_t row;
462  	emitter_row_init(&row);
463  	COL_HDR(row, size, NULL, right, 20, size)
464  	COL_HDR(row, ind, NULL, right, 4, unsigned)
465  	COL_HDR(row, ndirty, NULL, right, 13, size)
466  	COL_HDR(row, dirty, NULL, right, 13, size)
467  	COL_HDR(row, nmuzzy, NULL, right, 13, size)
468  	COL_HDR(row, muzzy, NULL, right, 13, size)
469  	COL_HDR(row, nretained, NULL, right, 13, size)
470  	COL_HDR(row, retained, NULL, right, 13, size)
471  	COL_HDR(row, ntotal, NULL, right, 13, size)
472  	COL_HDR(row, total, NULL, right, 13, size)
473  	header_size.width -= 8;
474  	emitter_table_printf(emitter, "extents:");
475  	emitter_table_row(emitter, &header_row);
476  	emitter_json_array_kv_begin(emitter, "extents");
477  	in_gap = false;
478  	for (j = 0; j < SC_NPSIZES; j++) {
479  		size_t ndirty, nmuzzy, nretained, total, dirty_bytes,
480  		    muzzy_bytes, retained_bytes, total_bytes;
481  		CTL_M2_M4_GET("stats.arenas.0.extents.0.ndirty", i, j,
482  		    &ndirty, size_t);
483  		CTL_M2_M4_GET("stats.arenas.0.extents.0.nmuzzy", i, j,
484  		    &nmuzzy, size_t);
485  		CTL_M2_M4_GET("stats.arenas.0.extents.0.nretained", i, j,
486  		    &nretained, size_t);
487  		CTL_M2_M4_GET("stats.arenas.0.extents.0.dirty_bytes", i, j,
488  		    &dirty_bytes, size_t);
489  		CTL_M2_M4_GET("stats.arenas.0.extents.0.muzzy_bytes", i, j,
490  		    &muzzy_bytes, size_t);
491  		CTL_M2_M4_GET("stats.arenas.0.extents.0.retained_bytes", i, j,
492  		    &retained_bytes, size_t);
493  		total = ndirty + nmuzzy + nretained;
494  		total_bytes = dirty_bytes + muzzy_bytes + retained_bytes;
495  		in_gap_prev = in_gap;
496  		in_gap = (total == 0);
497  		if (in_gap_prev && !in_gap) {
498  			emitter_table_printf(emitter,
499  			    "                     ---\n");
500  		}
501  		emitter_json_object_begin(emitter);
502  		emitter_json_kv(emitter, "ndirty", emitter_type_size, &ndirty);
503  		emitter_json_kv(emitter, "nmuzzy", emitter_type_size, &nmuzzy);
504  		emitter_json_kv(emitter, "nretained", emitter_type_size,
505  		    &nretained);
506  		emitter_json_kv(emitter, "dirty_bytes", emitter_type_size,
507  		    &dirty_bytes);
508  		emitter_json_kv(emitter, "muzzy_bytes", emitter_type_size,
509  		    &muzzy_bytes);
510  		emitter_json_kv(emitter, "retained_bytes", emitter_type_size,
511  		    &retained_bytes);
512  		emitter_json_object_end(emitter);
513  		col_size.size_val = sz_pind2sz(j);
514  		col_ind.size_val = j;
515  		col_ndirty.size_val = ndirty;
516  		col_dirty.size_val = dirty_bytes;
517  		col_nmuzzy.size_val = nmuzzy;
518  		col_muzzy.size_val = muzzy_bytes;
519  		col_nretained.size_val = nretained;
520  		col_retained.size_val = retained_bytes;
521  		col_ntotal.size_val = total;
522  		col_total.size_val = total_bytes;
523  		if (!in_gap) {
524  			emitter_table_row(emitter, &row);
525  		}
526  	}
527  	emitter_json_array_end(emitter); &bsol;* Close "extents". */
528  	if (in_gap) {
529  		emitter_table_printf(emitter, "                     ---\n");
530  	}
531  }
532  static void
533  stats_arena_mutexes_print(emitter_t *emitter, unsigned arena_ind, uint64_t uptime) {
534  	emitter_row_t row;
535  	emitter_col_t col_name;
536  	emitter_col_t col64[mutex_prof_num_uint64_t_counters];
537  	emitter_col_t col32[mutex_prof_num_uint32_t_counters];
538  	emitter_row_init(&row);
539  	mutex_stats_init_cols(&row, "", &col_name, col64, col32);
540  	emitter_json_object_kv_begin(emitter, "mutexes");
541  	emitter_table_row(emitter, &row);
542  	for (mutex_prof_arena_ind_t i = 0; i < mutex_prof_num_arena_mutexes;
543  	    i++) {
544  		const char *name = arena_mutex_names[i];
545  		emitter_json_object_kv_begin(emitter, name);
546  		mutex_stats_read_arena(arena_ind, i, name, &col_name, col64,
547  		    col32, uptime);
548  		mutex_stats_emit(emitter, &row, col64, col32);
549  		emitter_json_object_end(emitter); &bsol;* Close the mutex dict. */
550  	}
551  	emitter_json_object_end(emitter); &bsol;* End "mutexes". */
552  }
553  static void
554  stats_arena_print(emitter_t *emitter, unsigned i, bool bins, bool large,
555      bool mutex, bool extents) {
556  	unsigned nthreads;
557  	const char *dss;
558  	ssize_t dirty_decay_ms, muzzy_decay_ms;
559  	size_t page, pactive, pdirty, pmuzzy, mapped, retained;
560  	size_t base, internal, resident, metadata_thp, extent_avail;
561  	uint64_t dirty_npurge, dirty_nmadvise, dirty_purged;
562  	uint64_t muzzy_npurge, muzzy_nmadvise, muzzy_purged;
563  	size_t small_allocated;
564  	uint64_t small_nmalloc, small_ndalloc, small_nrequests, small_nfills,
565  	    small_nflushes;
566  	size_t large_allocated;
567  	uint64_t large_nmalloc, large_ndalloc, large_nrequests, large_nfills,
568  	    large_nflushes;
569  	size_t tcache_bytes, abandoned_vm;
570  	uint64_t uptime;
571  	CTL_GET("arenas.page", &page, size_t);
572  	CTL_M2_GET("stats.arenas.0.nthreads", i, &nthreads, unsigned);
573  	emitter_kv(emitter, "nthreads", "assigned threads",
574  	    emitter_type_unsigned, &nthreads);
575  	CTL_M2_GET("stats.arenas.0.uptime", i, &uptime, uint64_t);
576  	emitter_kv(emitter, "uptime_ns", "uptime", emitter_type_uint64,
577  	    &uptime);
578  	CTL_M2_GET("stats.arenas.0.dss", i, &dss, const char *);
579  	emitter_kv(emitter, "dss", "dss allocation precedence",
580  	    emitter_type_string, &dss);
581  	CTL_M2_GET("stats.arenas.0.dirty_decay_ms", i, &dirty_decay_ms,
582  	    ssize_t);
583  	CTL_M2_GET("stats.arenas.0.muzzy_decay_ms", i, &muzzy_decay_ms,
584  	    ssize_t);
585  	CTL_M2_GET("stats.arenas.0.pactive", i, &pactive, size_t);
586  	CTL_M2_GET("stats.arenas.0.pdirty", i, &pdirty, size_t);
587  	CTL_M2_GET("stats.arenas.0.pmuzzy", i, &pmuzzy, size_t);
588  	CTL_M2_GET("stats.arenas.0.dirty_npurge", i, &dirty_npurge, uint64_t);
589  	CTL_M2_GET("stats.arenas.0.dirty_nmadvise", i, &dirty_nmadvise,
590  	    uint64_t);
591  	CTL_M2_GET("stats.arenas.0.dirty_purged", i, &dirty_purged, uint64_t);
592  	CTL_M2_GET("stats.arenas.0.muzzy_npurge", i, &muzzy_npurge, uint64_t);
593  	CTL_M2_GET("stats.arenas.0.muzzy_nmadvise", i, &muzzy_nmadvise,
594  	    uint64_t);
595  	CTL_M2_GET("stats.arenas.0.muzzy_purged", i, &muzzy_purged, uint64_t);
596  	emitter_row_t decay_row;
597  	emitter_row_init(&decay_row);
598  	emitter_json_kv(emitter, "dirty_decay_ms", emitter_type_ssize,
599  	    &dirty_decay_ms);
600  	emitter_json_kv(emitter, "muzzy_decay_ms", emitter_type_ssize,
601  	    &muzzy_decay_ms);
602  	emitter_json_kv(emitter, "pactive", emitter_type_size, &pactive);
603  	emitter_json_kv(emitter, "pdirty", emitter_type_size, &pdirty);
604  	emitter_json_kv(emitter, "pmuzzy", emitter_type_size, &pmuzzy);
605  	emitter_json_kv(emitter, "dirty_npurge", emitter_type_uint64,
606  	    &dirty_npurge);
607  	emitter_json_kv(emitter, "dirty_nmadvise", emitter_type_uint64,
608  	    &dirty_nmadvise);
609  	emitter_json_kv(emitter, "dirty_purged", emitter_type_uint64,
610  	    &dirty_purged);
611  	emitter_json_kv(emitter, "muzzy_npurge", emitter_type_uint64,
612  	    &muzzy_npurge);
613  	emitter_json_kv(emitter, "muzzy_nmadvise", emitter_type_uint64,
614  	    &muzzy_nmadvise);
615  	emitter_json_kv(emitter, "muzzy_purged", emitter_type_uint64,
616  	    &muzzy_purged);
617  	COL(decay_row, decay_type, right, 9, title);
618  	col_decay_type.str_val = "decaying:";
619  	COL(decay_row, decay_time, right, 6, title);
620  	col_decay_time.str_val = "time";
621  	COL(decay_row, decay_npages, right, 13, title);
622  	col_decay_npages.str_val = "npages";
623  	COL(decay_row, decay_sweeps, right, 13, title);
624  	col_decay_sweeps.str_val = "sweeps";
625  	COL(decay_row, decay_madvises, right, 13, title);
626  	col_decay_madvises.str_val = "madvises";
627  	COL(decay_row, decay_purged, right, 13, title);
628  	col_decay_purged.str_val = "purged";
629  	emitter_table_row(emitter, &decay_row);
630  	col_decay_type.str_val = "dirty:";
631  	if (dirty_decay_ms >= 0) {
632  		col_decay_time.type = emitter_type_ssize;
633  		col_decay_time.ssize_val = dirty_decay_ms;
634  	} else {
635  		col_decay_time.type = emitter_type_title;
636  		col_decay_time.str_val = "N/A";
637  	}
638  	col_decay_npages.type = emitter_type_size;
639  	col_decay_npages.size_val = pdirty;
640  	col_decay_sweeps.type = emitter_type_uint64;
641  	col_decay_sweeps.uint64_val = dirty_npurge;
642  	col_decay_madvises.type = emitter_type_uint64;
643  	col_decay_madvises.uint64_val = dirty_nmadvise;
644  	col_decay_purged.type = emitter_type_uint64;
645  	col_decay_purged.uint64_val = dirty_purged;
646  	emitter_table_row(emitter, &decay_row);
647  	col_decay_type.str_val = "muzzy:";
648  	if (muzzy_decay_ms >= 0) {
649  		col_decay_time.type = emitter_type_ssize;
650  		col_decay_time.ssize_val = muzzy_decay_ms;
651  	} else {
652  		col_decay_time.type = emitter_type_title;
653  		col_decay_time.str_val = "N/A";
654  	}
655  	col_decay_npages.type = emitter_type_size;
656  	col_decay_npages.size_val = pmuzzy;
657  	col_decay_sweeps.type = emitter_type_uint64;
658  	col_decay_sweeps.uint64_val = muzzy_npurge;
659  	col_decay_madvises.type = emitter_type_uint64;
660  	col_decay_madvises.uint64_val = muzzy_nmadvise;
661  	col_decay_purged.type = emitter_type_uint64;
662  	col_decay_purged.uint64_val = muzzy_purged;
663  	emitter_table_row(emitter, &decay_row);
664  	emitter_row_t alloc_count_row;
665  	emitter_row_init(&alloc_count_row);
666  	COL(alloc_count_row, count_title, left, 21, title);
667  	col_count_title.str_val = "";
668  	COL(alloc_count_row, count_allocated, right, 16, title);
669  	col_count_allocated.str_val = "allocated";
670  	COL(alloc_count_row, count_nmalloc, right, 16, title);
671  	col_count_nmalloc.str_val = "nmalloc";
672  	COL(alloc_count_row, count_nmalloc_ps, right, 8, title);
673  	col_count_nmalloc_ps.str_val = "(#/sec)";
674  	COL(alloc_count_row, count_ndalloc, right, 16, title);
675  	col_count_ndalloc.str_val = "ndalloc";
676  	COL(alloc_count_row, count_ndalloc_ps, right, 8, title);
677  	col_count_ndalloc_ps.str_val = "(#/sec)";
678  	COL(alloc_count_row, count_nrequests, right, 16, title);
679  	col_count_nrequests.str_val = "nrequests";
680  	COL(alloc_count_row, count_nrequests_ps, right, 10, title);
681  	col_count_nrequests_ps.str_val = "(#/sec)";
682  	COL(alloc_count_row, count_nfills, right, 16, title);
683  	col_count_nfills.str_val = "nfill";
684  	COL(alloc_count_row, count_nfills_ps, right, 10, title);
685  	col_count_nfills_ps.str_val = "(#/sec)";
686  	COL(alloc_count_row, count_nflushes, right, 16, title);
687  	col_count_nflushes.str_val = "nflush";
688  	COL(alloc_count_row, count_nflushes_ps, right, 10, title);
689  	col_count_nflushes_ps.str_val = "(#/sec)";
690  	emitter_table_row(emitter, &alloc_count_row);
691  	col_count_nmalloc_ps.type = emitter_type_uint64;
692  	col_count_ndalloc_ps.type = emitter_type_uint64;
693  	col_count_nrequests_ps.type = emitter_type_uint64;
694  	col_count_nfills_ps.type = emitter_type_uint64;
695  	col_count_nflushes_ps.type = emitter_type_uint64;
696  #define GET_AND_EMIT_ALLOC_STAT(small_or_large, name, valtype)		\
697  	CTL_M2_GET("stats.arenas.0." #small_or_large "." #name, i,	\
698  	    &small_or_large##_##name, valtype##_t);			\
699  	emitter_json_kv(emitter, #name, emitter_type_##valtype,		\
700  	    &small_or_large##_##name);					\
701  	col_count_##name.type = emitter_type_##valtype;		\
702  	col_count_##name.valtype##_val = small_or_large##_##name;
703  	emitter_json_object_kv_begin(emitter, "small");
704  	col_count_title.str_val = "small:";
705  	GET_AND_EMIT_ALLOC_STAT(small, allocated, size)
706  	GET_AND_EMIT_ALLOC_STAT(small, nmalloc, uint64)
707  	col_count_nmalloc_ps.uint64_val =
708  	    rate_per_second(col_count_nmalloc.uint64_val, uptime);
709  	GET_AND_EMIT_ALLOC_STAT(small, ndalloc, uint64)
710  	col_count_ndalloc_ps.uint64_val =
711  	    rate_per_second(col_count_ndalloc.uint64_val, uptime);
712  	GET_AND_EMIT_ALLOC_STAT(small, nrequests, uint64)
713  	col_count_nrequests_ps.uint64_val =
714  	    rate_per_second(col_count_nrequests.uint64_val, uptime);
715  	GET_AND_EMIT_ALLOC_STAT(small, nfills, uint64)
716  	col_count_nfills_ps.uint64_val =
717  	    rate_per_second(col_count_nfills.uint64_val, uptime);
718  	GET_AND_EMIT_ALLOC_STAT(small, nflushes, uint64)
719  	col_count_nflushes_ps.uint64_val =
720  	    rate_per_second(col_count_nflushes.uint64_val, uptime);
721  	emitter_table_row(emitter, &alloc_count_row);
722  	emitter_json_object_end(emitter); &bsol;* Close "small". */
723  	emitter_json_object_kv_begin(emitter, "large");
724  	col_count_title.str_val = "large:";
725  	GET_AND_EMIT_ALLOC_STAT(large, allocated, size)
726  	GET_AND_EMIT_ALLOC_STAT(large, nmalloc, uint64)
727  	col_count_nmalloc_ps.uint64_val =
728  	    rate_per_second(col_count_nmalloc.uint64_val, uptime);
729  	GET_AND_EMIT_ALLOC_STAT(large, ndalloc, uint64)
730  	col_count_ndalloc_ps.uint64_val =
731  	    rate_per_second(col_count_ndalloc.uint64_val, uptime);
732  	GET_AND_EMIT_ALLOC_STAT(large, nrequests, uint64)
733  	col_count_nrequests_ps.uint64_val =
734  	    rate_per_second(col_count_nrequests.uint64_val, uptime);
735  	GET_AND_EMIT_ALLOC_STAT(large, nfills, uint64)
736  	col_count_nfills_ps.uint64_val =
737  	    rate_per_second(col_count_nfills.uint64_val, uptime);
738  	GET_AND_EMIT_ALLOC_STAT(large, nflushes, uint64)
739  	col_count_nflushes_ps.uint64_val =
740  	    rate_per_second(col_count_nflushes.uint64_val, uptime);
741  	emitter_table_row(emitter, &alloc_count_row);
742  	emitter_json_object_end(emitter); &bsol;* Close "large". */
743  #undef GET_AND_EMIT_ALLOC_STAT
744  	col_count_title.str_val = "total:";
745  	col_count_allocated.size_val = small_allocated + large_allocated;
746  	col_count_nmalloc.uint64_val = small_nmalloc + large_nmalloc;
747  	col_count_ndalloc.uint64_val = small_ndalloc + large_ndalloc;
748  	col_count_nrequests.uint64_val = small_nrequests + large_nrequests;
749  	col_count_nfills.uint64_val = small_nfills + large_nfills;
750  	col_count_nflushes.uint64_val = small_nflushes + large_nflushes;
751  	col_count_nmalloc_ps.uint64_val =
752  	    rate_per_second(col_count_nmalloc.uint64_val, uptime);
753  	col_count_ndalloc_ps.uint64_val =
754  	    rate_per_second(col_count_ndalloc.uint64_val, uptime);
755  	col_count_nrequests_ps.uint64_val =
756  	    rate_per_second(col_count_nrequests.uint64_val, uptime);
757  	col_count_nfills_ps.uint64_val =
758  	    rate_per_second(col_count_nfills.uint64_val, uptime);
759  	col_count_nflushes_ps.uint64_val =
760  	    rate_per_second(col_count_nflushes.uint64_val, uptime);
761  	emitter_table_row(emitter, &alloc_count_row);
762  	emitter_row_t mem_count_row;
763  	emitter_row_init(&mem_count_row);
764  	emitter_col_t mem_count_title;
765  	emitter_col_init(&mem_count_title, &mem_count_row);
766  	mem_count_title.justify = emitter_justify_left;
767  	mem_count_title.width = 21;
768  	mem_count_title.type = emitter_type_title;
769  	mem_count_title.str_val = "";
770  	emitter_col_t mem_count_val;
771  	emitter_col_init(&mem_count_val, &mem_count_row);
772  	mem_count_val.justify = emitter_justify_right;
773  	mem_count_val.width = 16;
774  	mem_count_val.type = emitter_type_title;
775  	mem_count_val.str_val = "";
776  	emitter_table_row(emitter, &mem_count_row);
777  	mem_count_val.type = emitter_type_size;
778  	mem_count_title.str_val = "active:";
779  	mem_count_val.size_val = pactive * page;
780  	emitter_table_row(emitter, &mem_count_row);
781  #define GET_AND_EMIT_MEM_STAT(stat)					\
782  	CTL_M2_GET("stats.arenas.0."#stat, i, &stat, size_t);		\
783  	emitter_json_kv(emitter, #stat, emitter_type_size, &stat);	\
784  	mem_count_title.str_val = #stat":";				\
785  	mem_count_val.size_val = stat;					\
786  	emitter_table_row(emitter, &mem_count_row);
787  	GET_AND_EMIT_MEM_STAT(mapped)
788  	GET_AND_EMIT_MEM_STAT(retained)
789  	GET_AND_EMIT_MEM_STAT(base)
790  	GET_AND_EMIT_MEM_STAT(internal)
791  	GET_AND_EMIT_MEM_STAT(metadata_thp)
792  	GET_AND_EMIT_MEM_STAT(tcache_bytes)
793  	GET_AND_EMIT_MEM_STAT(resident)
794  	GET_AND_EMIT_MEM_STAT(abandoned_vm)
795  	GET_AND_EMIT_MEM_STAT(extent_avail)
796  #undef GET_AND_EMIT_MEM_STAT
797  	if (mutex) {
798  		stats_arena_mutexes_print(emitter, i, uptime);
799  	}
800  	if (bins) {
801  		stats_arena_bins_print(emitter, mutex, i, uptime);
802  	}
803  	if (large) {
804  		stats_arena_lextents_print(emitter, i, uptime);
805  	}
806  	if (extents) {
807  		stats_arena_extents_print(emitter, i);
808  	}
809  }
810  static void
811  stats_general_print(emitter_t *emitter) {
812  	const char *cpv;
813  	bool bv, bv2;
814  	unsigned uv;
815  	uint32_t u32v;
816  	uint64_t u64v;
817  	ssize_t ssv, ssv2;
818  	size_t sv, bsz, usz, ssz, sssz, cpsz;
819  	bsz = sizeof(bool);
820  	usz = sizeof(unsigned);
821  	ssz = sizeof(size_t);
822  	sssz = sizeof(ssize_t);
823  	cpsz = sizeof(const char *);
824  	CTL_GET("version", &cpv, const char *);
825  	emitter_kv(emitter, "version", "Version", emitter_type_string, &cpv);
826  	emitter_dict_begin(emitter, "config", "Build-time option settings");
827  #define CONFIG_WRITE_BOOL(name)						\
828  	do {								\
829  		CTL_GET("config."#name, &bv, bool);			\
830  		emitter_kv(emitter, #name, "config."#name,		\
831  		    emitter_type_bool, &bv);				\
832  	} while (0)
833  	CONFIG_WRITE_BOOL(cache_oblivious);
834  	CONFIG_WRITE_BOOL(debug);
835  	CONFIG_WRITE_BOOL(fill);
836  	CONFIG_WRITE_BOOL(lazy_lock);
837  	emitter_kv(emitter, "malloc_conf", "config.malloc_conf",
838  	    emitter_type_string, &config_malloc_conf);
839  	CONFIG_WRITE_BOOL(opt_safety_checks);
840  	CONFIG_WRITE_BOOL(prof);
841  	CONFIG_WRITE_BOOL(prof_libgcc);
842  	CONFIG_WRITE_BOOL(prof_libunwind);
843  	CONFIG_WRITE_BOOL(stats);
844  	CONFIG_WRITE_BOOL(utrace);
845  	CONFIG_WRITE_BOOL(xmalloc);
846  #undef CONFIG_WRITE_BOOL
847  	emitter_dict_end(emitter); &bsol;* Close "config" dict. */
848  #define OPT_WRITE(name, var, size, emitter_type)			\
849  	if (je_mallctl("opt."name, (void *)&var, &size, NULL, 0) ==	\
850  	    0) {							\
851  		emitter_kv(emitter, name, "opt."name, emitter_type,	\
852  		    &var);						\
853  	}
854  #define OPT_WRITE_MUTABLE(name, var1, var2, size, emitter_type,		\
855      altname)								\
856  	if (je_mallctl("opt."name, (void *)&var1, &size, NULL, 0) ==	\
857  	    0 && je_mallctl(altname, (void *)&var2, &size, NULL, 0)	\
858  	    == 0) {							\
859  		emitter_kv_note(emitter, name, "opt."name,		\
860  		    emitter_type, &var1, altname, emitter_type,		\
861  		    &var2);						\
862  	}
863  #define OPT_WRITE_BOOL(name) OPT_WRITE(name, bv, bsz, emitter_type_bool)
864  #define OPT_WRITE_BOOL_MUTABLE(name, altname)				\
865  	OPT_WRITE_MUTABLE(name, bv, bv2, bsz, emitter_type_bool, altname)
866  #define OPT_WRITE_UNSIGNED(name)					\
867  	OPT_WRITE(name, uv, usz, emitter_type_unsigned)
868  #define OPT_WRITE_SIZE_T(name)						\
869  	OPT_WRITE(name, sv, ssz, emitter_type_size)
870  #define OPT_WRITE_SSIZE_T(name)						\
871  	OPT_WRITE(name, ssv, sssz, emitter_type_ssize)
872  #define OPT_WRITE_SSIZE_T_MUTABLE(name, altname)			\
873  	OPT_WRITE_MUTABLE(name, ssv, ssv2, sssz, emitter_type_ssize,	\
874  	    altname)
875  #define OPT_WRITE_CHAR_P(name)						\
876  	OPT_WRITE(name, cpv, cpsz, emitter_type_string)
877  	emitter_dict_begin(emitter, "opt", "Run-time option settings");
878  	OPT_WRITE_BOOL("abort")
879  	OPT_WRITE_BOOL("abort_conf")
880  	OPT_WRITE_BOOL("confirm_conf")
881  	OPT_WRITE_BOOL("retain")
882  	OPT_WRITE_CHAR_P("dss")
883  	OPT_WRITE_UNSIGNED("narenas")
884  	OPT_WRITE_CHAR_P("percpu_arena")
885  	OPT_WRITE_SIZE_T("oversize_threshold")
886  	OPT_WRITE_CHAR_P("metadata_thp")
887  	OPT_WRITE_BOOL_MUTABLE("background_thread", "background_thread")
888  	OPT_WRITE_SSIZE_T_MUTABLE("dirty_decay_ms", "arenas.dirty_decay_ms")
889  	OPT_WRITE_SSIZE_T_MUTABLE("muzzy_decay_ms", "arenas.muzzy_decay_ms")
890  	OPT_WRITE_SIZE_T("lg_extent_max_active_fit")
891  	OPT_WRITE_CHAR_P("junk")
892  	OPT_WRITE_BOOL("zero")
893  	OPT_WRITE_BOOL("utrace")
894  	OPT_WRITE_BOOL("xmalloc")
895  	OPT_WRITE_BOOL("tcache")
896  	OPT_WRITE_SSIZE_T("lg_tcache_max")
897  	OPT_WRITE_CHAR_P("thp")
898  	OPT_WRITE_BOOL("prof")
899  	OPT_WRITE_CHAR_P("prof_prefix")
900  	OPT_WRITE_BOOL_MUTABLE("prof_active", "prof.active")
901  	OPT_WRITE_BOOL_MUTABLE("prof_thread_active_init",
902  	    "prof.thread_active_init")
903  	OPT_WRITE_SSIZE_T_MUTABLE("lg_prof_sample", "prof.lg_sample")
904  	OPT_WRITE_BOOL("prof_accum")
905  	OPT_WRITE_SSIZE_T("lg_prof_interval")
906  	OPT_WRITE_BOOL("prof_gdump")
907  	OPT_WRITE_BOOL("prof_final")
908  	OPT_WRITE_BOOL("prof_leak")
909  	OPT_WRITE_BOOL("stats_print")
910  	OPT_WRITE_CHAR_P("stats_print_opts")
911  	emitter_dict_end(emitter);
912  #undef OPT_WRITE
913  #undef OPT_WRITE_MUTABLE
914  #undef OPT_WRITE_BOOL
915  #undef OPT_WRITE_BOOL_MUTABLE
916  #undef OPT_WRITE_UNSIGNED
917  #undef OPT_WRITE_SSIZE_T
918  #undef OPT_WRITE_SSIZE_T_MUTABLE
919  #undef OPT_WRITE_CHAR_P
920  	if (config_prof) {
921  		emitter_dict_begin(emitter, "prof", "Profiling settings");
922  		CTL_GET("prof.thread_active_init", &bv, bool);
923  		emitter_kv(emitter, "thread_active_init",
924  		    "prof.thread_active_init", emitter_type_bool, &bv);
925  		CTL_GET("prof.active", &bv, bool);
926  		emitter_kv(emitter, "active", "prof.active", emitter_type_bool,
927  		    &bv);
928  		CTL_GET("prof.gdump", &bv, bool);
929  		emitter_kv(emitter, "gdump", "prof.gdump", emitter_type_bool,
930  		    &bv);
931  		CTL_GET("prof.interval", &u64v, uint64_t);
932  		emitter_kv(emitter, "interval", "prof.interval",
933  		    emitter_type_uint64, &u64v);
934  		CTL_GET("prof.lg_sample", &ssv, ssize_t);
935  		emitter_kv(emitter, "lg_sample", "prof.lg_sample",
936  		    emitter_type_ssize, &ssv);
937  		emitter_dict_end(emitter); &bsol;* Close "prof". */
938  	}
939  	emitter_json_object_kv_begin(emitter, "arenas");
940  	CTL_GET("arenas.narenas", &uv, unsigned);
941  	emitter_kv(emitter, "narenas", "Arenas", emitter_type_unsigned, &uv);
942  	CTL_GET("arenas.dirty_decay_ms", &ssv, ssize_t);
943  	emitter_json_kv(emitter, "dirty_decay_ms", emitter_type_ssize, &ssv);
944  	CTL_GET("arenas.muzzy_decay_ms", &ssv, ssize_t);
945  	emitter_json_kv(emitter, "muzzy_decay_ms", emitter_type_ssize, &ssv);
946  	CTL_GET("arenas.quantum", &sv, size_t);
947  	emitter_kv(emitter, "quantum", "Quantum size", emitter_type_size, &sv);
948  	CTL_GET("arenas.page", &sv, size_t);
949  	emitter_kv(emitter, "page", "Page size", emitter_type_size, &sv);
950  	if (je_mallctl("arenas.tcache_max", (void *)&sv, &ssz, NULL, 0) == 0) {
951  		emitter_kv(emitter, "tcache_max",
952  		    "Maximum thread-cached size class", emitter_type_size, &sv);
953  	}
954  	unsigned nbins;
955  	CTL_GET("arenas.nbins", &nbins, unsigned);
956  	emitter_kv(emitter, "nbins", "Number of bin size classes",
957  	    emitter_type_unsigned, &nbins);
958  	unsigned nhbins;
959  	CTL_GET("arenas.nhbins", &nhbins, unsigned);
960  	emitter_kv(emitter, "nhbins", "Number of thread-cache bin size classes",
961  	    emitter_type_unsigned, &nhbins);
962  	if (emitter->output == emitter_output_json) {
963  		emitter_json_array_kv_begin(emitter, "bin");
964  		for (unsigned i = 0; i < nbins; i++) {
965  			emitter_json_object_begin(emitter);
966  			CTL_M2_GET("arenas.bin.0.size", i, &sv, size_t);
967  			emitter_json_kv(emitter, "size", emitter_type_size,
968  			    &sv);
969  			CTL_M2_GET("arenas.bin.0.nregs", i, &u32v, uint32_t);
970  			emitter_json_kv(emitter, "nregs", emitter_type_uint32,
971  			    &u32v);
972  			CTL_M2_GET("arenas.bin.0.slab_size", i, &sv, size_t);
973  			emitter_json_kv(emitter, "slab_size", emitter_type_size,
974  			    &sv);
975  			CTL_M2_GET("arenas.bin.0.nshards", i, &u32v, uint32_t);
976  			emitter_json_kv(emitter, "nshards", emitter_type_uint32,
977  			    &u32v);
978  			emitter_json_object_end(emitter);
979  		}
980  		emitter_json_array_end(emitter); &bsol;* Close "bin". */
981  	}
982  	unsigned nlextents;
983  	CTL_GET("arenas.nlextents", &nlextents, unsigned);
984  	emitter_kv(emitter, "nlextents", "Number of large size classes",
985  	    emitter_type_unsigned, &nlextents);
986  	if (emitter->output == emitter_output_json) {
987  		emitter_json_array_kv_begin(emitter, "lextent");
988  		for (unsigned i = 0; i < nlextents; i++) {
989  			emitter_json_object_begin(emitter);
990  			CTL_M2_GET("arenas.lextent.0.size", i, &sv, size_t);
991  			emitter_json_kv(emitter, "size", emitter_type_size,
992  			    &sv);
993  			emitter_json_object_end(emitter);
994  		}
995  		emitter_json_array_end(emitter); &bsol;* Close "lextent". */
996  	}
997  	emitter_json_object_end(emitter); &bsol;* Close "arenas" */
998  }
999  static void
1000  stats_print_helper(emitter_t *emitter, bool merged, bool destroyed,
1001      bool unmerged, bool bins, bool large, bool mutex, bool extents) {
1002  	size_t allocated, active, metadata, metadata_thp, resident, mapped,
1003  	    retained;
1004  	size_t num_background_threads;
1005  	uint64_t background_thread_num_runs, background_thread_run_interval;
1006  	CTL_GET("stats.allocated", &allocated, size_t);
1007  	CTL_GET("stats.active", &active, size_t);
1008  	CTL_GET("stats.metadata", &metadata, size_t);
1009  	CTL_GET("stats.metadata_thp", &metadata_thp, size_t);
1010  	CTL_GET("stats.resident", &resident, size_t);
1011  	CTL_GET("stats.mapped", &mapped, size_t);
1012  	CTL_GET("stats.retained", &retained, size_t);
1013  	if (have_background_thread) {
1014  		CTL_GET("stats.background_thread.num_threads",
1015  		    &num_background_threads, size_t);
1016  		CTL_GET("stats.background_thread.num_runs",
1017  		    &background_thread_num_runs, uint64_t);
1018  		CTL_GET("stats.background_thread.run_interval",
1019  		    &background_thread_run_interval, uint64_t);
1020  	} else {
1021  		num_background_threads = 0;
1022  		background_thread_num_runs = 0;
1023  		background_thread_run_interval = 0;
1024  	}
1025  	emitter_json_object_kv_begin(emitter, "stats");
1026  	emitter_json_kv(emitter, "allocated", emitter_type_size, &allocated);
1027  	emitter_json_kv(emitter, "active", emitter_type_size, &active);
1028  	emitter_json_kv(emitter, "metadata", emitter_type_size, &metadata);
1029  	emitter_json_kv(emitter, "metadata_thp", emitter_type_size,
1030  	    &metadata_thp);
1031  	emitter_json_kv(emitter, "resident", emitter_type_size, &resident);
1032  	emitter_json_kv(emitter, "mapped", emitter_type_size, &mapped);
1033  	emitter_json_kv(emitter, "retained", emitter_type_size, &retained);
1034  	emitter_table_printf(emitter, "Allocated: %zu, active: %zu, "
1035  	    "metadata: %zu (n_thp %zu), resident: %zu, mapped: %zu, "
1036  	    "retained: %zu\n", allocated, active, metadata, metadata_thp,
1037  	    resident, mapped, retained);
1038  	emitter_json_object_kv_begin(emitter, "background_thread");
1039  	emitter_json_kv(emitter, "num_threads", emitter_type_size,
1040  	    &num_background_threads);
1041  	emitter_json_kv(emitter, "num_runs", emitter_type_uint64,
1042  	    &background_thread_num_runs);
1043  	emitter_json_kv(emitter, "run_interval", emitter_type_uint64,
1044  	    &background_thread_run_interval);
1045  	emitter_json_object_end(emitter); &bsol;* Close "background_thread". */
1046  	emitter_table_printf(emitter, "Background threads: %zu, "
1047  	    "num_runs: %"FMTu64", run_interval: %"FMTu64" ns\n",
1048  	    num_background_threads, background_thread_num_runs,
1049  	    background_thread_run_interval);
1050  	if (mutex) {
1051  		emitter_row_t row;
1052  		emitter_col_t name;
1053  		emitter_col_t col64[mutex_prof_num_uint64_t_counters];
1054  		emitter_col_t col32[mutex_prof_num_uint32_t_counters];
1055  		uint64_t uptime;
1056  		emitter_row_init(&row);
1057  		mutex_stats_init_cols(&row, "", &name, col64, col32);
1058  		emitter_table_row(emitter, &row);
1059  		emitter_json_object_kv_begin(emitter, "mutexes");
1060  		CTL_M2_GET("stats.arenas.0.uptime", 0, &uptime, uint64_t);
1061  		for (int i = 0; i < mutex_prof_num_global_mutexes; i++) {
1062  			mutex_stats_read_global(global_mutex_names[i], &name,
1063  			    col64, col32, uptime);
1064  			emitter_json_object_kv_begin(emitter, global_mutex_names[i]);
1065  			mutex_stats_emit(emitter, &row, col64, col32);
1066  			emitter_json_object_end(emitter);
1067  		}
1068  		emitter_json_object_end(emitter); &bsol;* Close "mutexes". */
1069  	}
1070  	emitter_json_object_end(emitter); &bsol;* Close "stats". */
1071  	if (merged || destroyed || unmerged) {
1072  		unsigned narenas;
1073  		emitter_json_object_kv_begin(emitter, "stats.arenas");
1074  		CTL_GET("arenas.narenas", &narenas, unsigned);
1075  		size_t mib[3];
1076  		size_t miblen = sizeof(mib) / sizeof(size_t);
1077  		size_t sz;
1078  		VARIABLE_ARRAY(bool, initialized, narenas);
1079  		bool destroyed_initialized;
1080  		unsigned i, j, ninitialized;
1081  		xmallctlnametomib("arena.0.initialized", mib, &miblen);
1082  		for (i = ninitialized = 0; i < narenas; i++) {
1083  			mib[1] = i;
1084  			sz = sizeof(bool);
1085  			xmallctlbymib(mib, miblen, &initialized[i], &sz,
1086  			    NULL, 0);
1087  			if (initialized[i]) {
1088  				ninitialized++;
1089  			}
1090  		}
1091  		mib[1] = MALLCTL_ARENAS_DESTROYED;
1092  		sz = sizeof(bool);
1093  		xmallctlbymib(mib, miblen, &destroyed_initialized, &sz,
1094  		    NULL, 0);
1095  		if (merged && (ninitialized > 1 || !unmerged)) {
1096  			emitter_table_printf(emitter, "Merged arenas stats:\n");
1097  			emitter_json_object_kv_begin(emitter, "merged");
1098  			stats_arena_print(emitter, MALLCTL_ARENAS_ALL, bins,
1099  			    large, mutex, extents);
1100  			emitter_json_object_end(emitter); &bsol;* Close "merged". */
1101  		}
1102  		if (destroyed_initialized && destroyed) {
1103  			emitter_table_printf(emitter,
1104  			    "Destroyed arenas stats:\n");
1105  			emitter_json_object_kv_begin(emitter, "destroyed");
1106  			stats_arena_print(emitter, MALLCTL_ARENAS_DESTROYED,
1107  			    bins, large, mutex, extents);
1108  			emitter_json_object_end(emitter); &bsol;* Close "destroyed". */
1109  		}
1110  		if (unmerged) {
1111  			for (i = j = 0; i < narenas; i++) {
1112  				if (initialized[i]) {
1113  					char arena_ind_str[20];
1114  					malloc_snprintf(arena_ind_str,
1115  					    sizeof(arena_ind_str), "%u", i);
1116  					emitter_json_object_kv_begin(emitter,
1117  					    arena_ind_str);
1118  					emitter_table_printf(emitter,
1119  					    "arenas[%s]:\n", arena_ind_str);
1120  					stats_arena_print(emitter, i, bins,
1121  					    large, mutex, extents);
1122  					emitter_json_object_end(emitter);
1123  				}
1124  			}
1125  		}
1126  		emitter_json_object_end(emitter); &bsol;* Close "stats.arenas". */
1127  	}
1128  }
1129  void
1130  stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
1131      const char *opts) {
1132  	int err;
1133  	uint64_t epoch;
1134  	size_t u64sz;
1135  #define OPTION(o, v, d, s) bool v = d;
1136  	STATS_PRINT_OPTIONS
1137  #undef OPTION
1138  	epoch = 1;
1139  	u64sz = sizeof(uint64_t);
1140  	err = je_mallctl("epoch", (void *)&epoch, &u64sz, (void *)&epoch,
1141  	    sizeof(uint64_t));
1142  	if (err != 0) {
1143  		if (err == EAGAIN) {
1144  			malloc_write("<jemalloc>: Memory allocation failure in "
1145  			    "mallctl(\"epoch\", ...)\n");
1146  			return;
1147  		}
1148  		malloc_write("<jemalloc>: Failure in mallctl(\"epoch\", "
1149  		    "...)\n");
1150  		abort();
1151  	}
1152  	if (opts != NULL) {
1153  		for (unsigned i = 0; opts[i] != '\0'; i++) {
1154  			switch (opts[i]) {
1155  #define OPTION(o, v, d, s) case o: v = s; break;
1156  				STATS_PRINT_OPTIONS
1157  #undef OPTION
1158  			default:;
1159  			}
1160  		}
1161  	}
1162  	emitter_t emitter;
1163  	emitter_init(&emitter,
1164  	    json ? emitter_output_json : emitter_output_table, write_cb,
1165  	    cbopaque);
1166  	emitter_begin(&emitter);
1167  	emitter_table_printf(&emitter, "___ Begin jemalloc statistics ___\n");
1168  	emitter_json_object_kv_begin(&emitter, "jemalloc");
1169  	if (general) {
1170  		stats_general_print(&emitter);
1171  	}
1172  	if (config_stats) {
1173  		stats_print_helper(&emitter, merged, destroyed, unmerged,
1174  		    bins, large, mutex, extents);
1175  	}
1176  	emitter_json_object_end(&emitter); &bsol;* Closes the "jemalloc" dict. */
1177  	emitter_table_printf(&emitter, "--- End jemalloc statistics ---\n");
1178  	emitter_end(&emitter);
1179  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-anim_encode.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <limits.h>
3  #include <math.h>    
4  #include <stdio.h>
5  #include <stdlib.h>  
6  #include "src/mux/animi.h"
7  #include "src/utils/utils.h"
8  #include "src/webp/decode.h"
9  #include "src/webp/encode.h"
10  #include "src/webp/format_constants.h"
11  #include "src/webp/mux.h"
12  #if defined(_MSC_VER) && _MSC_VER < 1900
13  #define snprintf _snprintf
14  #endif
15  #define ERROR_STR_MAX_LENGTH 100
16  typedef struct {
17    int x_offset_, y_offset_, width_, height_;
18  } FrameRectangle;
19  typedef struct {
20    WebPMuxFrameInfo sub_frame_;  
21    WebPMuxFrameInfo key_frame_;  
22    int is_key_frame_;            
23  } EncodedFrame;
24  struct WebPAnimEncoder {
25    const int canvas_width_;                  
26    const int canvas_height_;                 
27    const WebPAnimEncoderOptions options_;    
28    FrameRectangle prev_rect_;          
29    WebPConfig last_config_;            
30    WebPConfig last_config_reversed_;   
31    WebPPicture* curr_canvas_;          
32    WebPPicture curr_canvas_copy_;      
33    int curr_canvas_copy_modified_;     
34    WebPPicture prev_canvas_;           
35    WebPPicture prev_canvas_disposed_;  
36    EncodedFrame* encoded_frames_;      
37    size_t size_;             
38    size_t start_;            
39    size_t count_;            
40    size_t flush_count_;      
41    int64_t best_delta_;      
42    int keyframe_;            
43    int count_since_key_frame_;     
44    int first_timestamp_;           
45    int prev_timestamp_;            
46    int prev_candidate_undecided_;  
47    int is_first_frame_;  
48    int got_null_frame_;  
49    size_t in_frame_count_;   
50    size_t out_frame_count_;  
51    WebPMux* mux_;        
52    char error_str_[ERROR_STR_MAX_LENGTH];  
53  };
54  #define DELTA_INFINITY      (1ULL << 32)
55  #define KEYFRAME_NONE       (-1)
56  static void ResetCounters(WebPAnimEncoder* const enc) {
57    enc->start_ = 0;
58    enc->count_ = 0;
59    enc->flush_count_ = 0;
60    enc->best_delta_ = DELTA_INFINITY;
61    enc->keyframe_ = KEYFRAME_NONE;
62  }
63  static void DisableKeyframes(WebPAnimEncoderOptions* const enc_options) {
64    enc_options->kmax = INT_MAX;
65    enc_options->kmin = enc_options->kmax - 1;
66  }
67  #define MAX_CACHED_FRAMES 30
68  static void SanitizeEncoderOptions(WebPAnimEncoderOptions* const enc_options) {
69    int print_warning = enc_options->verbose;
70    if (enc_options->minimize_size) {
71      DisableKeyframes(enc_options);
72    }
73    if (enc_options->kmax == 1) {  
74      enc_options->kmin = 0;
75      enc_options->kmax = 0;
76      return;
77    } else if (enc_options->kmax <= 0) {
78      DisableKeyframes(enc_options);
79      print_warning = 0;
80    }
81    if (enc_options->kmin >= enc_options->kmax) {
82      enc_options->kmin = enc_options->kmax - 1;
83      if (print_warning) {
84        fprintf(stderr, "WARNING: Setting kmin = %d, so that kmin < kmax.\n",
85                enc_options->kmin);
86      }
87    } else {
88      const int kmin_limit = enc_options->kmax / 2 + 1;
89      if (enc_options->kmin < kmin_limit && kmin_limit < enc_options->kmax) {
90        enc_options->kmin = kmin_limit;
91        if (print_warning) {
92          fprintf(stderr,
93                  "WARNING: Setting kmin = %d, so that kmin >= kmax / 2 + 1.\n",
94                  enc_options->kmin);
95        }
96      }
97    }
98    if (enc_options->kmax - enc_options->kmin > MAX_CACHED_FRAMES) {
99      enc_options->kmin = enc_options->kmax - MAX_CACHED_FRAMES;
100      if (print_warning) {
101        fprintf(stderr,
102                "WARNING: Setting kmin = %d, so that kmax - kmin <= %d.\n",
103                enc_options->kmin, MAX_CACHED_FRAMES);
104      }
105    }
106    assert(enc_options->kmin < enc_options->kmax);
107  }
108  #undef MAX_CACHED_FRAMES
109  static void DefaultEncoderOptions(WebPAnimEncoderOptions* const enc_options) {
110    enc_options->anim_params.loop_count = 0;
111    enc_options->anim_params.bgcolor = 0xffffffff;  
112    enc_options->minimize_size = 0;
113    DisableKeyframes(enc_options);
114    enc_options->allow_mixed = 0;
115    enc_options->verbose = 0;
116  }
117  int WebPAnimEncoderOptionsInitInternal(WebPAnimEncoderOptions* enc_options,
118                                         int abi_version) {
119    if (enc_options == NULL ||
120        WEBP_ABI_IS_INCOMPATIBLE(abi_version, WEBP_MUX_ABI_VERSION)) {
121      return 0;
122    }
123    DefaultEncoderOptions(enc_options);
124    return 1;
125  }
126  #define TRANSPARENT_COLOR   0x00000000
127  static void ClearRectangle(WebPPicture* const picture,
128                             int left, int top, int width, int height) {
129    int j;
130    for (j = top; j < top + height; ++j) {
131      uint32_t* const dst = picture->argb + j * picture->argb_stride;
132      int i;
133      for (i = left; i < left + width; ++i) {
134        dst[i] = TRANSPARENT_COLOR;
135      }
136    }
137  }
138  static void WebPUtilClearPic(WebPPicture* const picture,
139                               const FrameRectangle* const rect) {
140    if (rect != NULL) {
141      ClearRectangle(picture, rect->x_offset_, rect->y_offset_,
142                     rect->width_, rect->height_);
143    } else {
144      ClearRectangle(picture, 0, 0, picture->width, picture->height);
145    }
146  }
147  static void MarkNoError(WebPAnimEncoder* const enc) {
148    enc->error_str_[0] = '\0';  
149  }
150  static void MarkError(WebPAnimEncoder* const enc, const char* str) {
151    if (snprintf(enc->error_str_, ERROR_STR_MAX_LENGTH, "%s.", str) < 0) {
152      assert(0);  
153    }
154  }
155  static void MarkError2(WebPAnimEncoder* const enc,
156                         const char* str, int error_code) {
157    if (snprintf(enc->error_str_, ERROR_STR_MAX_LENGTH, "%s: %d.", str,
158                 error_code) < 0) {
159      assert(0);  
160    }
161  }
162  WebPAnimEncoder* WebPAnimEncoderNewInternal(
163      int width, int height, const WebPAnimEncoderOptions* enc_options,
164      int abi_version) {
165    WebPAnimEncoder* enc;
166    if (WEBP_ABI_IS_INCOMPATIBLE(abi_version, WEBP_MUX_ABI_VERSION)) {
167      return NULL;
168    }
169    if (width <= 0 || height <= 0 ||
170        (width * (uint64_t)height) >= MAX_IMAGE_AREA) {
171      return NULL;
172    }
173    enc = (WebPAnimEncoder*)WebPSafeCalloc(1, sizeof(*enc));
174    if (enc == NULL) return NULL;
175    enc->encoded_frames_ = NULL;
176    enc->mux_ = NULL;
177    MarkNoError(enc);
178    *(int*)&enc->canvas_width_ = width;
179    *(int*)&enc->canvas_height_ = height;
180    if (enc_options != NULL) {
181      *(WebPAnimEncoderOptions*)&enc->options_ = *enc_options;
182      SanitizeEncoderOptions((WebPAnimEncoderOptions*)&enc->options_);
183    } else {
184      DefaultEncoderOptions((WebPAnimEncoderOptions*)&enc->options_);
185    }
186    if (!WebPPictureInit(&enc->curr_canvas_copy_) ||
187        !WebPPictureInit(&enc->prev_canvas_) ||
188        !WebPPictureInit(&enc->prev_canvas_disposed_)) {
189      goto Err;
190    }
191    enc->curr_canvas_copy_.width = width;
192    enc->curr_canvas_copy_.height = height;
193    enc->curr_canvas_copy_.use_argb = 1;
194    if (!WebPPictureAlloc(&enc->curr_canvas_copy_) ||
195        !WebPPictureCopy(&enc->curr_canvas_copy_, &enc->prev_canvas_) ||
196        !WebPPictureCopy(&enc->curr_canvas_copy_, &enc->prev_canvas_disposed_)) {
197      goto Err;
198    }
199    WebPUtilClearPic(&enc->prev_canvas_, NULL);
200    enc->curr_canvas_copy_modified_ = 1;
201    ResetCounters(enc);
202    enc->size_ = enc->options_.kmax - enc->options_.kmin + 1;
203    if (enc->size_ < 2) enc->size_ = 2;
204    enc->encoded_frames_ =
205        (EncodedFrame*)WebPSafeCalloc(enc->size_, sizeof(*enc->encoded_frames_));
206    if (enc->encoded_frames_ == NULL) goto Err;
207    enc->mux_ = WebPMuxNew();
208    if (enc->mux_ == NULL) goto Err;
209    enc->count_since_key_frame_ = 0;
210    enc->first_timestamp_ = 0;
211    enc->prev_timestamp_ = 0;
212    enc->prev_candidate_undecided_ = 0;
213    enc->is_first_frame_ = 1;
214    enc->got_null_frame_ = 0;
215    return enc;  
216   Err:
217    WebPAnimEncoderDelete(enc);
218    return NULL;
219  }
220  static void FrameRelease(EncodedFrame* const encoded_frame) {
221    if (encoded_frame != NULL) {
222      WebPDataClear(&encoded_frame->sub_frame_.bitstream);
223      WebPDataClear(&encoded_frame->key_frame_.bitstream);
224      memset(encoded_frame, 0, sizeof(*encoded_frame));
225    }
226  }
227  void WebPAnimEncoderDelete(WebPAnimEncoder* enc) {
228    if (enc != NULL) {
229      WebPPictureFree(&enc->curr_canvas_copy_);
230      WebPPictureFree(&enc->prev_canvas_);
231      WebPPictureFree(&enc->prev_canvas_disposed_);
232      if (enc->encoded_frames_ != NULL) {
233        size_t i;
234        for (i = 0; i < enc->size_; ++i) {
235          FrameRelease(&enc->encoded_frames_[i]);
236        }
237        WebPSafeFree(enc->encoded_frames_);
238      }
239      WebPMuxDelete(enc->mux_);
240      WebPSafeFree(enc);
241    }
242  }
243  static EncodedFrame* GetFrame(const WebPAnimEncoder* const enc,
244                                size_t position) {
245    assert(enc->start_ + position < enc->size_);
246    return &enc->encoded_frames_[enc->start_ + position];
247  }
248  typedef int (*ComparePixelsFunc)(const uint32_t*, int, const uint32_t*, int,
249                                   int, int);
250  static WEBP_INLINE int ComparePixelsLossless(const uint32_t* src, int src_step,
251                                               const uint32_t* dst, int dst_step,
252                                               int length, int max_allowed_diff) {
253    (void)max_allowed_diff;
254    assert(length > 0);
255    while (length-- > 0) {
256      if (*src != *dst) {
257        return 0;
258      }
259      src += src_step;
260      dst += dst_step;
261    }
262    return 1;
263  }
264  static WEBP_INLINE int PixelsAreSimilar(uint32_t src, uint32_t dst,
265                                          int max_allowed_diff) {
266    const int src_a = (src >> 24) & 0xff;
267    const int src_r = (src >> 16) & 0xff;
268    const int src_g = (src >> 8) & 0xff;
269    const int src_b = (src >> 0) & 0xff;
270    const int dst_a = (dst >> 24) & 0xff;
271    const int dst_r = (dst >> 16) & 0xff;
272    const int dst_g = (dst >> 8) & 0xff;
273    const int dst_b = (dst >> 0) & 0xff;
274    return (src_a == dst_a) &&
275           (abs(src_r - dst_r) * dst_a <= (max_allowed_diff * 255)) &&
276           (abs(src_g - dst_g) * dst_a <= (max_allowed_diff * 255)) &&
277           (abs(src_b - dst_b) * dst_a <= (max_allowed_diff * 255));
278  }
279  static WEBP_INLINE int ComparePixelsLossy(const uint32_t* src, int src_step,
280                                            const uint32_t* dst, int dst_step,
281                                            int length, int max_allowed_diff) {
282    assert(length > 0);
283    while (length-- > 0) {
284      if (!PixelsAreSimilar(*src, *dst, max_allowed_diff)) {
285        return 0;
286      }
287      src += src_step;
288      dst += dst_step;
289    }
290    return 1;
291  }
292  static int IsEmptyRect(const FrameRectangle* const rect) {
293    return (rect->width_ == 0) || (rect->height_ == 0);
294  }
295  static int QualityToMaxDiff(float quality) {
296    const double val = pow(quality / 100., 0.5);
297    const double max_diff = 31 * (1 - val) + 1 * val;
298    return (int)(max_diff + 0.5);
299  }
300  static void MinimizeChangeRectangle(const WebPPicture* const src,
301                                      const WebPPicture* const dst,
302                                      FrameRectangle* const rect,
303                                      int is_lossless, float quality) {
304    int i, j;
305    const ComparePixelsFunc compare_pixels =
306        is_lossless ? ComparePixelsLossless : ComparePixelsLossy;
307    const int max_allowed_diff_lossy = QualityToMaxDiff(quality);
308    const int max_allowed_diff = is_lossless ? 0 : max_allowed_diff_lossy;
309    assert(src->width == dst->width && src->height == dst->height);
310    assert(rect->x_offset_ + rect->width_ <= dst->width);
311    assert(rect->y_offset_ + rect->height_ <= dst->height);
312    for (i = rect->x_offset_; i < rect->x_offset_ + rect->width_; ++i) {
313      const uint32_t* const src_argb =
314          &src->argb[rect->y_offset_ * src->argb_stride + i];
315      const uint32_t* const dst_argb =
316          &dst->argb[rect->y_offset_ * dst->argb_stride + i];
317      if (compare_pixels(src_argb, src->argb_stride, dst_argb, dst->argb_stride,
318                         rect->height_, max_allowed_diff)) {
319        --rect->width_;  
320        ++rect->x_offset_;
321      } else {
322        break;
323      }
324    }
325    if (rect->width_ == 0) goto NoChange;
326    for (i = rect->x_offset_ + rect->width_ - 1; i >= rect->x_offset_; --i) {
327      const uint32_t* const src_argb =
328          &src->argb[rect->y_offset_ * src->argb_stride + i];
329      const uint32_t* const dst_argb =
330          &dst->argb[rect->y_offset_ * dst->argb_stride + i];
331      if (compare_pixels(src_argb, src->argb_stride, dst_argb, dst->argb_stride,
332                         rect->height_, max_allowed_diff)) {
333        --rect->width_;  
334      } else {
335        break;
336      }
337    }
338    if (rect->width_ == 0) goto NoChange;
339    for (j = rect->y_offset_; j < rect->y_offset_ + rect->height_; ++j) {
340      const uint32_t* const src_argb =
341          &src->argb[j * src->argb_stride + rect->x_offset_];
342      const uint32_t* const dst_argb =
343          &dst->argb[j * dst->argb_stride + rect->x_offset_];
344      if (compare_pixels(src_argb, 1, dst_argb, 1, rect->width_,
345                         max_allowed_diff)) {
346        --rect->height_;  
347        ++rect->y_offset_;
348      } else {
349        break;
350      }
351    }
352    if (rect->height_ == 0) goto NoChange;
353    for (j = rect->y_offset_ + rect->height_ - 1; j >= rect->y_offset_; --j) {
354      const uint32_t* const src_argb =
355          &src->argb[j * src->argb_stride + rect->x_offset_];
356      const uint32_t* const dst_argb =
357          &dst->argb[j * dst->argb_stride + rect->x_offset_];
358      if (compare_pixels(src_argb, 1, dst_argb, 1, rect->width_,
359                         max_allowed_diff)) {
360        --rect->height_;  
361      } else {
362        break;
363      }
364    }
365    if (rect->height_ == 0) goto NoChange;
366    if (IsEmptyRect(rect)) {
367   NoChange:
368      rect->x_offset_ = 0;
369      rect->y_offset_ = 0;
370      rect->width_ = 0;
371      rect->height_ = 0;
372    }
373  }
374  static WEBP_INLINE void SnapToEvenOffsets(FrameRectangle* const rect) {
375    rect->width_ += (rect->x_offset_ & 1);
376    rect->height_ += (rect->y_offset_ & 1);
377    rect->x_offset_ &= ~1;
378    rect->y_offset_ &= ~1;
379  }
380  typedef struct {
381    int should_try_;               
382    int empty_rect_allowed_;       
383    FrameRectangle rect_ll_;       
384    WebPPicture sub_frame_ll_;     
385    FrameRectangle rect_lossy_;    
386    WebPPicture sub_frame_lossy_;  
387  } SubFrameParams;
388  static int SubFrameParamsInit(SubFrameParams* const params,
389                                int should_try, int empty_rect_allowed) {
390    params->should_try_ = should_try;
391    params->empty_rect_allowed_ = empty_rect_allowed;
392    if (!WebPPictureInit(&params->sub_frame_ll_) ||
393        !WebPPictureInit(&params->sub_frame_lossy_)) {
394      return 0;
395    }
396    return 1;
397  }
398  static void SubFrameParamsFree(SubFrameParams* const params) {
399    WebPPictureFree(&params->sub_frame_ll_);
400    WebPPictureFree(&params->sub_frame_lossy_);
401  }
402  static int GetSubRect(const WebPPicture* const prev_canvas,
403                        const WebPPicture* const curr_canvas, int is_key_frame,
404                        int is_first_frame, int empty_rect_allowed,
405                        int is_lossless, float quality,
406                        FrameRectangle* const rect,
407                        WebPPicture* const sub_frame) {
408    if (!is_key_frame || is_first_frame) {  
409      MinimizeChangeRectangle(prev_canvas, curr_canvas, rect,
410                              is_lossless, quality);
411    }
412    if (IsEmptyRect(rect)) {
413      if (empty_rect_allowed) {  
414        return 1;
415      } else {                   
416        rect->width_ = 1;
417        rect->height_ = 1;
418        assert(rect->x_offset_ == 0);
419        assert(rect->y_offset_ == 0);
420      }
421    }
422    SnapToEvenOffsets(rect);
423    return WebPPictureView(curr_canvas, rect->x_offset_, rect->y_offset_,
424                           rect->width_, rect->height_, sub_frame);
425  }
426  static int GetSubRects(const WebPPicture* const prev_canvas,
427                         const WebPPicture* const curr_canvas, int is_key_frame,
428                         int is_first_frame, float quality,
429                         SubFrameParams* const params) {
430    params->rect_ll_.x_offset_ = 0;
431    params->rect_ll_.y_offset_ = 0;
432    params->rect_ll_.width_ = curr_canvas->width;
433    params->rect_ll_.height_ = curr_canvas->height;
434    if (!GetSubRect(prev_canvas, curr_canvas, is_key_frame, is_first_frame,
435                    params->empty_rect_allowed_, 1, quality,
436                    &params->rect_ll_, &params->sub_frame_ll_)) {
437      return 0;
438    }
439    params->rect_lossy_ = params->rect_ll_;  
440    return GetSubRect(prev_canvas, curr_canvas, is_key_frame, is_first_frame,
441                      params->empty_rect_allowed_, 0, quality,
442                      &params->rect_lossy_, &params->sub_frame_lossy_);
443  }
444  static WEBP_INLINE int clip(int v, int min_v, int max_v) {
445    return (v < min_v) ? min_v : (v > max_v) ? max_v : v;
446  }
447  int WebPAnimEncoderRefineRect(
448      const WebPPicture* const prev_canvas, const WebPPicture* const curr_canvas,
449      int is_lossless, float quality, int* const x_offset, int* const y_offset,
450      int* const width, int* const height) {
451    FrameRectangle rect;
452    const int right = clip(*x_offset + *width, 0, curr_canvas->width);
453    const int left = clip(*x_offset, 0, curr_canvas->width - 1);
454    const int bottom = clip(*y_offset + *height, 0, curr_canvas->height);
455    const int top = clip(*y_offset, 0, curr_canvas->height - 1);
456    if (prev_canvas == NULL || curr_canvas == NULL ||
457        prev_canvas->width != curr_canvas->width ||
458        prev_canvas->height != curr_canvas->height ||
459        !prev_canvas->use_argb || !curr_canvas->use_argb) {
460      return 0;
461    }
462    rect.x_offset_ = left;
463    rect.y_offset_ = top;
464    rect.width_ = clip(right - left, 0, curr_canvas->width - rect.x_offset_);
465    rect.height_ = clip(bottom - top, 0, curr_canvas->height - rect.y_offset_);
466    MinimizeChangeRectangle(prev_canvas, curr_canvas, &rect, is_lossless,
467                            quality);
468    SnapToEvenOffsets(&rect);
469    *x_offset = rect.x_offset_;
470    *y_offset = rect.y_offset_;
471    *width = rect.width_;
472    *height = rect.height_;
473    return 1;
474  }
475  static void DisposeFrameRectangle(int dispose_method,
476                                    const FrameRectangle* const rect,
477                                    WebPPicture* const curr_canvas) {
478    assert(rect != NULL);
479    if (dispose_method == WEBP_MUX_DISPOSE_BACKGROUND) {
480      WebPUtilClearPic(curr_canvas, rect);
481    }
482  }
483  static uint32_t RectArea(const FrameRectangle* const rect) {
484    return (uint32_t)rect->width_ * rect->height_;
485  }
486  static int IsLosslessBlendingPossible(const WebPPicture* const src,
487                                        const WebPPicture* const dst,
488                                        const FrameRectangle* const rect) {
489    int i, j;
490    assert(src->width == dst->width && src->height == dst->height);
491    assert(rect->x_offset_ + rect->width_ <= dst->width);
492    assert(rect->y_offset_ + rect->height_ <= dst->height);
493    for (j = rect->y_offset_; j < rect->y_offset_ + rect->height_; ++j) {
494      for (i = rect->x_offset_; i < rect->x_offset_ + rect->width_; ++i) {
495        const uint32_t src_pixel = src->argb[j * src->argb_stride + i];
496        const uint32_t dst_pixel = dst->argb[j * dst->argb_stride + i];
497        const uint32_t dst_alpha = dst_pixel >> 24;
498        if (dst_alpha != 0xff && src_pixel != dst_pixel) {
499          return 0;
500        }
501      }
502    }
503    return 1;
504  }
505  static int IsLossyBlendingPossible(const WebPPicture* const src,
506                                     const WebPPicture* const dst,
507                                     const FrameRectangle* const rect,
508                                     float quality) {
509    const int max_allowed_diff_lossy = QualityToMaxDiff(quality);
510    int i, j;
511    assert(src->width == dst->width && src->height == dst->height);
512    assert(rect->x_offset_ + rect->width_ <= dst->width);
513    assert(rect->y_offset_ + rect->height_ <= dst->height);
514    for (j = rect->y_offset_; j < rect->y_offset_ + rect->height_; ++j) {
515      for (i = rect->x_offset_; i < rect->x_offset_ + rect->width_; ++i) {
516        const uint32_t src_pixel = src->argb[j * src->argb_stride + i];
517        const uint32_t dst_pixel = dst->argb[j * dst->argb_stride + i];
518        const uint32_t dst_alpha = dst_pixel >> 24;
519        if (dst_alpha != 0xff &&
520            !PixelsAreSimilar(src_pixel, dst_pixel, max_allowed_diff_lossy)) {
521          return 0;
522        }
523      }
524    }
525    return 1;
526  }
527  static int IncreaseTransparency(const WebPPicture* const src,
528                                  const FrameRectangle* const rect,
529                                  WebPPicture* const dst) {
530    int i, j;
531    int modified = 0;
532    assert(src != NULL && dst != NULL && rect != NULL);
533    assert(src->width == dst->width && src->height == dst->height);
534    for (j = rect->y_offset_; j < rect->y_offset_ + rect->height_; ++j) {
535      const uint32_t* const psrc = src->argb + j * src->argb_stride;
536      uint32_t* const pdst = dst->argb + j * dst->argb_stride;
537      for (i = rect->x_offset_; i < rect->x_offset_ + rect->width_; ++i) {
538        if (psrc[i] == pdst[i] && pdst[i] != TRANSPARENT_COLOR) {
539          pdst[i] = TRANSPARENT_COLOR;
540          modified = 1;
541        }
542      }
543    }
544    return modified;
545  }
546  #undef TRANSPARENT_COLOR
547  static int FlattenSimilarBlocks(const WebPPicture* const src,
548                                  const FrameRectangle* const rect,
549                                  WebPPicture* const dst, float quality) {
550    const int max_allowed_diff_lossy = QualityToMaxDiff(quality);
551    int i, j;
552    int modified = 0;
553    const int block_size = 8;
554    const int y_start = (rect->y_offset_ + block_size) & ~(block_size - 1);
555    const int y_end = (rect->y_offset_ + rect->height_) & ~(block_size - 1);
556    const int x_start = (rect->x_offset_ + block_size) & ~(block_size - 1);
557    const int x_end = (rect->x_offset_ + rect->width_) & ~(block_size - 1);
558    assert(src != NULL && dst != NULL && rect != NULL);
559    assert(src->width == dst->width && src->height == dst->height);
560    assert((block_size & (block_size - 1)) == 0);  
561    for (j = y_start; j < y_end; j += block_size) {
562      for (i = x_start; i < x_end; i += block_size) {
563        int cnt = 0;
564        int avg_r = 0, avg_g = 0, avg_b = 0;
565        int x, y;
566        const uint32_t* const psrc = src->argb + j * src->argb_stride + i;
567        uint32_t* const pdst = dst->argb + j * dst->argb_stride + i;
568        for (y = 0; y < block_size; ++y) {
569          for (x = 0; x < block_size; ++x) {
570            const uint32_t src_pixel = psrc[x + y * src->argb_stride];
571            const int alpha = src_pixel >> 24;
572            if (alpha == 0xff &&
573                PixelsAreSimilar(src_pixel, pdst[x + y * dst->argb_stride],
574                                 max_allowed_diff_lossy)) {
575              ++cnt;
576              avg_r += (src_pixel >> 16) & 0xff;
577              avg_g += (src_pixel >> 8) & 0xff;
578              avg_b += (src_pixel >> 0) & 0xff;
579            }
580          }
581        }
582        if (cnt == block_size * block_size) {
583          const uint32_t color = (0x00          << 24) |
584                                 ((avg_r / cnt) << 16) |
585                                 ((avg_g / cnt) <<  8) |
586                                 ((avg_b / cnt) <<  0);
587          for (y = 0; y < block_size; ++y) {
588            for (x = 0; x < block_size; ++x) {
589              pdst[x + y * dst->argb_stride] = color;
590            }
591          }
592          modified = 1;
593        }
594      }
595    }
596    return modified;
597  }
598  static int EncodeFrame(const WebPConfig* const config, WebPPicture* const pic,
599                         WebPMemoryWriter* const memory) {
600    pic->use_argb = 1;
601    pic->writer = WebPMemoryWrite;
602    pic->custom_ptr = memory;
603    if (!WebPEncode(config, pic)) {
604      return 0;
605    }
606    return 1;
607  }
608  typedef struct {
609    WebPMemoryWriter  mem_;
610    WebPMuxFrameInfo  info_;
611    FrameRectangle    rect_;
612    int               evaluate_;  
613  } Candidate;
614  static WebPEncodingError EncodeCandidate(WebPPicture* const sub_frame,
615                                           const FrameRectangle* const rect,
616                                           const WebPConfig* const encoder_config,
617                                           int use_blending,
618                                           Candidate* const candidate) {
619    WebPConfig config = *encoder_config;
620    WebPEncodingError error_code = VP8_ENC_OK;
621    assert(candidate != NULL);
622    memset(candidate, 0, sizeof(*candidate));
623    candidate->rect_ = *rect;
624    candidate->info_.id = WEBP_CHUNK_ANMF;
625    candidate->info_.x_offset = rect->x_offset_;
626    candidate->info_.y_offset = rect->y_offset_;
627    candidate->info_.dispose_method = WEBP_MUX_DISPOSE_NONE;  
628    candidate->info_.blend_method =
629        use_blending ? WEBP_MUX_BLEND : WEBP_MUX_NO_BLEND;
630    candidate->info_.duration = 0;  
631    WebPMemoryWriterInit(&candidate->mem_);
632    if (!config.lossless && use_blending) {
633      config.autofilter = 0;
634      config.filter_strength = 0;
635    }
636    if (!EncodeFrame(&config, sub_frame, &candidate->mem_)) {
637      error_code = sub_frame->error_code;
638      goto Err;
639    }
640    candidate->evaluate_ = 1;
641    return error_code;
642   Err:
643    WebPMemoryWriterClear(&candidate->mem_);
644    return error_code;
645  }
646  static void CopyCurrentCanvas(WebPAnimEncoder* const enc) {
647    if (enc->curr_canvas_copy_modified_) {
648      WebPCopyPixels(enc->curr_canvas_, &enc->curr_canvas_copy_);
649      enc->curr_canvas_copy_.progress_hook = enc->curr_canvas_->progress_hook;
650      enc->curr_canvas_copy_.user_data = enc->curr_canvas_->user_data;
651      enc->curr_canvas_copy_modified_ = 0;
652    }
653  }
654  enum {
655    LL_DISP_NONE = 0,
656    LL_DISP_BG,
657    LOSSY_DISP_NONE,
658    LOSSY_DISP_BG,
659    CANDIDATE_COUNT
660  };
661  #define MIN_COLORS_LOSSY     31  
662  #define MAX_COLORS_LOSSLESS 194  
663  static WebPEncodingError GenerateCandidates(
664      WebPAnimEncoder* const enc, Candidate candidates[CANDIDATE_COUNT],
665      WebPMuxAnimDispose dispose_method, int is_lossless, int is_key_frame,
666      SubFrameParams* const params,
667      const WebPConfig* const config_ll, const WebPConfig* const config_lossy) {
668    WebPEncodingError error_code = VP8_ENC_OK;
669    const int is_dispose_none = (dispose_method == WEBP_MUX_DISPOSE_NONE);
670    Candidate* const candidate_ll =
671        is_dispose_none ? &candidates[LL_DISP_NONE] : &candidates[LL_DISP_BG];
672    Candidate* const candidate_lossy = is_dispose_none
673                                       ? &candidates[LOSSY_DISP_NONE]
674                                       : &candidates[LOSSY_DISP_BG];
675    WebPPicture* const curr_canvas = &enc->curr_canvas_copy_;
676    const WebPPicture* const prev_canvas =
677        is_dispose_none ? &enc->prev_canvas_ : &enc->prev_canvas_disposed_;
678    int use_blending_ll, use_blending_lossy;
679    int evaluate_ll, evaluate_lossy;
680    CopyCurrentCanvas(enc);
681    use_blending_ll =
682        !is_key_frame &&
683        IsLosslessBlendingPossible(prev_canvas, curr_canvas, &params->rect_ll_);
684    use_blending_lossy =
685        !is_key_frame &&
686        IsLossyBlendingPossible(prev_canvas, curr_canvas, &params->rect_lossy_,
687                                config_lossy->quality);
688    if (!enc->options_.allow_mixed) {
689      evaluate_ll = is_lossless;
690      evaluate_lossy = !is_lossless;
691    } else if (enc->options_.minimize_size) {
692      evaluate_ll = 1;
693      evaluate_lossy = 1;
694    } else {  
695      const int num_colors = WebPGetColorPalette(&params->sub_frame_ll_, NULL);
696      evaluate_ll = (num_colors < MAX_COLORS_LOSSLESS);
697      evaluate_lossy = (num_colors >= MIN_COLORS_LOSSY);
698    }
699    if (evaluate_ll) {
700      CopyCurrentCanvas(enc);
701      if (use_blending_ll) {
702        enc->curr_canvas_copy_modified_ =
703            IncreaseTransparency(prev_canvas, &params->rect_ll_, curr_canvas);
704      }
705      error_code = EncodeCandidate(&params->sub_frame_ll_, &params->rect_ll_,
706                                   config_ll, use_blending_ll, candidate_ll);
707      if (error_code != VP8_ENC_OK) return error_code;
708    }
709    if (evaluate_lossy) {
710      CopyCurrentCanvas(enc);
711      if (use_blending_lossy) {
712        enc->curr_canvas_copy_modified_ =
713            FlattenSimilarBlocks(prev_canvas, &params->rect_lossy_, curr_canvas,
714                                 config_lossy->quality);
715      }
716      error_code =
717          EncodeCandidate(&params->sub_frame_lossy_, &params->rect_lossy_,
718                          config_lossy, use_blending_lossy, candidate_lossy);
719      if (error_code != VP8_ENC_OK) return error_code;
720      enc->curr_canvas_copy_modified_ = 1;
721    }
722    return error_code;
723  }
724  #undef MIN_COLORS_LOSSY
725  #undef MAX_COLORS_LOSSLESS
726  static void GetEncodedData(const WebPMemoryWriter* const memory,
727                             WebPData* const encoded_data) {
728    encoded_data->bytes = memory->mem;
729    encoded_data->size  = memory->size;
730  }
731  static void SetPreviousDisposeMethod(WebPAnimEncoder* const enc,
732                                       WebPMuxAnimDispose dispose_method) {
733    const size_t position = enc->count_ - 2;
734    EncodedFrame* const prev_enc_frame = GetFrame(enc, position);
735    assert(enc->count_ >= 2);  
736    if (enc->prev_candidate_undecided_) {
737      assert(dispose_method == WEBP_MUX_DISPOSE_NONE);
738      prev_enc_frame->sub_frame_.dispose_method = dispose_method;
739      prev_enc_frame->key_frame_.dispose_method = dispose_method;
740    } else {
741      WebPMuxFrameInfo* const prev_info = prev_enc_frame->is_key_frame_
742                                          ? &prev_enc_frame->key_frame_
743                                          : &prev_enc_frame->sub_frame_;
744      prev_info->dispose_method = dispose_method;
745    }
746  }
747  static int IncreasePreviousDuration(WebPAnimEncoder* const enc, int duration) {
748    const size_t position = enc->count_ - 1;
749    EncodedFrame* const prev_enc_frame = GetFrame(enc, position);
750    int new_duration;
751    assert(enc->count_ >= 1);
752    assert(prev_enc_frame->sub_frame_.duration ==
753           prev_enc_frame->key_frame_.duration);
754    assert(prev_enc_frame->sub_frame_.duration ==
755           (prev_enc_frame->sub_frame_.duration & (MAX_DURATION - 1)));
756    assert(duration == (duration & (MAX_DURATION - 1)));
757    new_duration = prev_enc_frame->sub_frame_.duration + duration;
758    if (new_duration >= MAX_DURATION) {  
759      const FrameRectangle rect = { 0, 0, 1, 1 };
760      const uint8_t lossless_1x1_bytes[] = {
761        0x52, 0x49, 0x46, 0x46, 0x14, 0x00, 0x00, 0x00, 0x57, 0x45, 0x42, 0x50,
762        0x56, 0x50, 0x38, 0x4c, 0x08, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00,
763        0x10, 0x88, 0x88, 0x08
764      };
765      const WebPData lossless_1x1 = {
766          lossless_1x1_bytes, sizeof(lossless_1x1_bytes)
767      };
768      const uint8_t lossy_1x1_bytes[] = {
769        0x52, 0x49, 0x46, 0x46, 0x40, 0x00, 0x00, 0x00, 0x57, 0x45, 0x42, 0x50,
770        0x56, 0x50, 0x38, 0x58, 0x0a, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
771        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x4c, 0x50, 0x48, 0x02, 0x00,
772        0x00, 0x00, 0x00, 0x00, 0x56, 0x50, 0x38, 0x20, 0x18, 0x00, 0x00, 0x00,
773        0x30, 0x01, 0x00, 0x9d, 0x01, 0x2a, 0x01, 0x00, 0x01, 0x00, 0x02, 0x00,
774        0x34, 0x25, 0xa4, 0x00, 0x03, 0x70, 0x00, 0xfe, 0xfb, 0xfd, 0x50, 0x00
775      };
776      const WebPData lossy_1x1 = { lossy_1x1_bytes, sizeof(lossy_1x1_bytes) };
777      const int can_use_lossless =
778          (enc->last_config_.lossless || enc->options_.allow_mixed);
<span onclick='openModal()' class='match'>779      EncodedFrame* const curr_enc_frame = GetFrame(enc, enc->count_);
780      curr_enc_frame->is_key_frame_ = 0;
781      curr_enc_frame->sub_frame_.id = WEBP_CHUNK_ANMF;
782      curr_enc_frame->sub_frame_.x_offset = 0;
783      curr_enc_frame->sub_frame_.y_offset = 0;
784      curr_enc_frame->sub_frame_.dispose_method = WEBP_MUX_DISPOSE_NONE;
785      curr_enc_frame->sub_frame_.blend_method = WEBP_MUX_BLEND;
786      curr_enc_frame->sub_frame_.duration = duration;
787      if (!WebPDataCopy(can_use_lossless ? &lossless_1x1 : &lossy_1x1,
</span>788                        &curr_enc_frame->sub_frame_.bitstream)) {
789        return 0;
790      }
791      ++enc->count_;
792      ++enc->count_since_key_frame_;
793      enc->flush_count_ = enc->count_ - 1;
794      enc->prev_candidate_undecided_ = 0;
795      enc->prev_rect_ = rect;
796    } else {                           
797      prev_enc_frame->sub_frame_.duration = new_duration;
798      prev_enc_frame->key_frame_.duration = new_duration;
799    }
800    return 1;
801  }
802  static void PickBestCandidate(WebPAnimEncoder* const enc,
803                                Candidate* const candidates, int is_key_frame,
804                                EncodedFrame* const encoded_frame) {
805    int i;
806    int best_idx = -1;
807    size_t best_size = ~0;
808    for (i = 0; i < CANDIDATE_COUNT; ++i) {
809      if (candidates[i].evaluate_) {
810        const size_t candidate_size = candidates[i].mem_.size;
811        if (candidate_size < best_size) {
812          best_idx = i;
813          best_size = candidate_size;
814        }
815      }
816    }
817    assert(best_idx != -1);
818    for (i = 0; i < CANDIDATE_COUNT; ++i) {
819      if (candidates[i].evaluate_) {
820        if (i == best_idx) {
821          WebPMuxFrameInfo* const dst = is_key_frame
822                                        ? &encoded_frame->key_frame_
823                                        : &encoded_frame->sub_frame_;
824          *dst = candidates[i].info_;
825          GetEncodedData(&candidates[i].mem_, &dst->bitstream);
826          if (!is_key_frame) {
827            const WebPMuxAnimDispose prev_dispose_method =
828                (best_idx == LL_DISP_NONE || best_idx == LOSSY_DISP_NONE)
829                    ? WEBP_MUX_DISPOSE_NONE
830                    : WEBP_MUX_DISPOSE_BACKGROUND;
831            SetPreviousDisposeMethod(enc, prev_dispose_method);
832          }
833          enc->prev_rect_ = candidates[i].rect_;  
834        } else {
835          WebPMemoryWriterClear(&candidates[i].mem_);
836          candidates[i].evaluate_ = 0;
837        }
838      }
839    }
840  }
841  static WebPEncodingError SetFrame(WebPAnimEncoder* const enc,
842                                    const WebPConfig* const config,
843                                    int is_key_frame,
844                                    EncodedFrame* const encoded_frame,
845                                    int* const frame_skipped) {
846    int i;
847    WebPEncodingError error_code = VP8_ENC_OK;
848    const WebPPicture* const curr_canvas = &enc->curr_canvas_copy_;
849    const WebPPicture* const prev_canvas = &enc->prev_canvas_;
850    Candidate candidates[CANDIDATE_COUNT];
851    const int is_lossless = config->lossless;
852    const int consider_lossless = is_lossless || enc->options_.allow_mixed;
853    const int consider_lossy = !is_lossless || enc->options_.allow_mixed;
854    const int is_first_frame = enc->is_first_frame_;
855    const int empty_rect_allowed_none = !is_first_frame;
856    const int empty_rect_allowed_bg = 0;
857    const int dispose_bg_possible =
858        !is_key_frame && !enc->prev_candidate_undecided_;
859    SubFrameParams dispose_none_params;
860    SubFrameParams dispose_bg_params;
861    WebPConfig config_ll = *config;
862    WebPConfig config_lossy = *config;
863    config_ll.lossless = 1;
864    config_lossy.lossless = 0;
865    enc->last_config_ = *config;
866    enc->last_config_reversed_ = config->lossless ? config_lossy : config_ll;
867    *frame_skipped = 0;
868    if (!SubFrameParamsInit(&dispose_none_params, 1, empty_rect_allowed_none) ||
869        !SubFrameParamsInit(&dispose_bg_params, 0, empty_rect_allowed_bg)) {
870      return VP8_ENC_ERROR_INVALID_CONFIGURATION;
871    }
872    memset(candidates, 0, sizeof(candidates));
873    if (!GetSubRects(prev_canvas, curr_canvas, is_key_frame, is_first_frame,
874                     config_lossy.quality, &dispose_none_params)) {
875      error_code = VP8_ENC_ERROR_INVALID_CONFIGURATION;
876      goto Err;
877    }
878    if ((consider_lossless && IsEmptyRect(&dispose_none_params.rect_ll_)) ||
879        (consider_lossy && IsEmptyRect(&dispose_none_params.rect_lossy_))) {
880      assert(empty_rect_allowed_none);
881      *frame_skipped = 1;
882      goto End;
883    }
884    if (dispose_bg_possible) {
885      WebPPicture* const prev_canvas_disposed = &enc->prev_canvas_disposed_;
886      WebPCopyPixels(prev_canvas, prev_canvas_disposed);
887      DisposeFrameRectangle(WEBP_MUX_DISPOSE_BACKGROUND, &enc->prev_rect_,
888                            prev_canvas_disposed);
889      if (!GetSubRects(prev_canvas_disposed, curr_canvas, is_key_frame,
890                       is_first_frame, config_lossy.quality,
891                       &dispose_bg_params)) {
892        error_code = VP8_ENC_ERROR_INVALID_CONFIGURATION;
893        goto Err;
894      }
895      assert(!IsEmptyRect(&dispose_bg_params.rect_ll_));
896      assert(!IsEmptyRect(&dispose_bg_params.rect_lossy_));
897      if (enc->options_.minimize_size) {  
898        dispose_bg_params.should_try_ = 1;
899        dispose_none_params.should_try_ = 1;
900      } else if ((is_lossless &&
901                  RectArea(&dispose_bg_params.rect_ll_) <
902                      RectArea(&dispose_none_params.rect_ll_)) ||
903                 (!is_lossless &&
904                  RectArea(&dispose_bg_params.rect_lossy_) <
905                      RectArea(&dispose_none_params.rect_lossy_))) {
906        dispose_bg_params.should_try_ = 1;  
907        dispose_none_params.should_try_ = 0;
908      }
909    }
910    if (dispose_none_params.should_try_) {
911      error_code = GenerateCandidates(
912          enc, candidates, WEBP_MUX_DISPOSE_NONE, is_lossless, is_key_frame,
913          &dispose_none_params, &config_ll, &config_lossy);
914      if (error_code != VP8_ENC_OK) goto Err;
915    }
916    if (dispose_bg_params.should_try_) {
917      assert(!enc->is_first_frame_);
918      assert(dispose_bg_possible);
919      error_code = GenerateCandidates(
920          enc, candidates, WEBP_MUX_DISPOSE_BACKGROUND, is_lossless, is_key_frame,
921          &dispose_bg_params, &config_ll, &config_lossy);
922      if (error_code != VP8_ENC_OK) goto Err;
923    }
924    PickBestCandidate(enc, candidates, is_key_frame, encoded_frame);
925    goto End;
926   Err:
927    for (i = 0; i < CANDIDATE_COUNT; ++i) {
928      if (candidates[i].evaluate_) {
929        WebPMemoryWriterClear(&candidates[i].mem_);
930      }
931    }
932   End:
933    SubFrameParamsFree(&dispose_none_params);
934    SubFrameParamsFree(&dispose_bg_params);
935    return error_code;
936  }
937  static int64_t KeyFramePenalty(const EncodedFrame* const encoded_frame) {
938    return ((int64_t)encoded_frame->key_frame_.bitstream.size -
939            encoded_frame->sub_frame_.bitstream.size);
940  }
941  static int CacheFrame(WebPAnimEncoder* const enc,
942                        const WebPConfig* const config) {
943    int ok = 0;
944    int frame_skipped = 0;
945    WebPEncodingError error_code = VP8_ENC_OK;
946    const size_t position = enc->count_;
947    EncodedFrame* const encoded_frame = GetFrame(enc, position);
948    ++enc->count_;
949    if (enc->is_first_frame_) {  
950      error_code = SetFrame(enc, config, 1, encoded_frame, &frame_skipped);
951      if (error_code != VP8_ENC_OK) goto End;
952      assert(frame_skipped == 0);  
953      assert(position == 0 && enc->count_ == 1);
954      encoded_frame->is_key_frame_ = 1;
955      enc->flush_count_ = 0;
956      enc->count_since_key_frame_ = 0;
957      enc->prev_candidate_undecided_ = 0;
958    } else {
959      ++enc->count_since_key_frame_;
960      if (enc->count_since_key_frame_ <= enc->options_.kmin) {
961        error_code = SetFrame(enc, config, 0, encoded_frame, &frame_skipped);
962        if (error_code != VP8_ENC_OK) goto End;
963        if (frame_skipped) goto Skip;
964        encoded_frame->is_key_frame_ = 0;
965        enc->flush_count_ = enc->count_ - 1;
966        enc->prev_candidate_undecided_ = 0;
967      } else {
968        int64_t curr_delta;
969        FrameRectangle prev_rect_key, prev_rect_sub;
970        error_code = SetFrame(enc, config, 0, encoded_frame, &frame_skipped);
971        if (error_code != VP8_ENC_OK) goto End;
972        if (frame_skipped) goto Skip;
973        prev_rect_sub = enc->prev_rect_;
974        error_code = SetFrame(enc, config, 1, encoded_frame, &frame_skipped);
975        if (error_code != VP8_ENC_OK) goto End;
976        assert(frame_skipped == 0);  
977        prev_rect_key = enc->prev_rect_;
978        curr_delta = KeyFramePenalty(encoded_frame);
979        if (curr_delta <= enc->best_delta_) {  
980          if (enc->keyframe_ != KEYFRAME_NONE) {
981            EncodedFrame* const old_keyframe = GetFrame(enc, enc->keyframe_);
982            assert(old_keyframe->is_key_frame_);
983            old_keyframe->is_key_frame_ = 0;
984          }
985          encoded_frame->is_key_frame_ = 1;
986          enc->prev_candidate_undecided_ = 1;
987          enc->keyframe_ = (int)position;
988          enc->best_delta_ = curr_delta;
989          enc->flush_count_ = enc->count_ - 1;  
990        } else {
991          encoded_frame->is_key_frame_ = 0;
992          enc->prev_candidate_undecided_ = 0;
993        }
994        if (enc->count_since_key_frame_ >= enc->options_.kmax) {
995          enc->flush_count_ = enc->count_ - 1;
996          enc->count_since_key_frame_ = 0;
997          enc->keyframe_ = KEYFRAME_NONE;
998          enc->best_delta_ = DELTA_INFINITY;
999        }
1000        if (!enc->prev_candidate_undecided_) {
1001          enc->prev_rect_ =
1002              encoded_frame->is_key_frame_ ? prev_rect_key : prev_rect_sub;
1003        }
1004      }
1005    }
1006    WebPCopyPixels(enc->curr_canvas_, &enc->prev_canvas_);
1007    enc->is_first_frame_ = 0;
1008   Skip:
1009    ok = 1;
1010    ++enc->in_frame_count_;
1011   End:
1012    if (!ok || frame_skipped) {
1013      FrameRelease(encoded_frame);
1014      --enc->count_;
1015      if (!enc->is_first_frame_) --enc->count_since_key_frame_;
1016      if (!ok) {
1017        MarkError2(enc, "ERROR adding frame. WebPEncodingError", error_code);
1018      }
1019    }
1020    enc->curr_canvas_->error_code = error_code;   
1021    assert(ok || error_code != VP8_ENC_OK);
1022    return ok;
1023  }
1024  static int FlushFrames(WebPAnimEncoder* const enc) {
1025    while (enc->flush_count_ > 0) {
1026      WebPMuxError err;
1027      EncodedFrame* const curr = GetFrame(enc, 0);
1028      const WebPMuxFrameInfo* const info =
1029          curr->is_key_frame_ ? &curr->key_frame_ : &curr->sub_frame_;
1030      assert(enc->mux_ != NULL);
1031      err = WebPMuxPushFrame(enc->mux_, info, 1);
1032      if (err != WEBP_MUX_OK) {
1033        MarkError2(enc, "ERROR adding frame. WebPMuxError", err);
1034        return 0;
1035      }
1036      if (enc->options_.verbose) {
1037        fprintf(stderr, "INFO: Added frame. offset:%d,%d dispose:%d blend:%d\n",
1038                info->x_offset, info->y_offset, info->dispose_method,
1039                info->blend_method);
1040      }
1041      ++enc->out_frame_count_;
1042      FrameRelease(curr);
1043      ++enc->start_;
1044      --enc->flush_count_;
1045      --enc->count_;
1046      if (enc->keyframe_ != KEYFRAME_NONE) --enc->keyframe_;
1047    }
1048    if (enc->count_ == 1 && enc->start_ != 0) {
1049      const int enc_start_tmp = (int)enc->start_;
1050      EncodedFrame temp = enc->encoded_frames_[0];
1051      enc->encoded_frames_[0] = enc->encoded_frames_[enc_start_tmp];
1052      enc->encoded_frames_[enc_start_tmp] = temp;
1053      FrameRelease(&enc->encoded_frames_[enc_start_tmp]);
1054      enc->start_ = 0;
1055    }
1056    return 1;
1057  }
1058  #undef DELTA_INFINITY
1059  #undef KEYFRAME_NONE
1060  int WebPAnimEncoderAdd(WebPAnimEncoder* enc, WebPPicture* frame, int timestamp,
1061                         const WebPConfig* encoder_config) {
1062    WebPConfig config;
1063    int ok;
1064    if (enc == NULL) {
1065      return 0;
1066    }
1067    MarkNoError(enc);
1068    if (!enc->is_first_frame_) {
1069      const uint32_t prev_frame_duration =
1070          (uint32_t)timestamp - enc->prev_timestamp_;
1071      if (prev_frame_duration >= MAX_DURATION) {
1072        if (frame != NULL) {
1073          frame->error_code = VP8_ENC_ERROR_INVALID_CONFIGURATION;
1074        }
1075        MarkError(enc, "ERROR adding frame: timestamps must be non-decreasing");
1076        return 0;
1077      }
1078      if (!IncreasePreviousDuration(enc, (int)prev_frame_duration)) {
1079        return 0;
1080      }
1081    } else {
1082      enc->first_timestamp_ = timestamp;
1083    }
1084    if (frame == NULL) {  
1085      enc->got_null_frame_ = 1;
1086      enc->prev_timestamp_ = timestamp;
1087      return 1;
1088    }
1089    if (frame->width != enc->canvas_width_ ||
1090        frame->height != enc->canvas_height_) {
1091      frame->error_code = VP8_ENC_ERROR_INVALID_CONFIGURATION;
1092      MarkError(enc, "ERROR adding frame: Invalid frame dimensions");
1093      return 0;
1094    }
1095    if (!frame->use_argb) {  
1096      if (enc->options_.verbose) {
1097        fprintf(stderr, "WARNING: Converting frame from YUV(A) to ARGB format; "
1098                "this incurs a small loss.\n");
1099      }
1100      if (!WebPPictureYUVAToARGB(frame)) {
1101        MarkError(enc, "ERROR converting frame from YUV(A) to ARGB");
1102        return 0;
1103      }
1104    }
1105    if (encoder_config != NULL) {
1106      if (!WebPValidateConfig(encoder_config)) {
1107        MarkError(enc, "ERROR adding frame: Invalid WebPConfig");
1108        return 0;
1109      }
1110      config = *encoder_config;
1111    } else {
1112      WebPConfigInit(&config);
1113      config.lossless = 1;
1114    }
1115    assert(enc->curr_canvas_ == NULL);
1116    enc->curr_canvas_ = frame;  
1117    assert(enc->curr_canvas_copy_modified_ == 1);
1118    CopyCurrentCanvas(enc);
1119    ok = CacheFrame(enc, &config) && FlushFrames(enc);
1120    enc->curr_canvas_ = NULL;
1121    enc->curr_canvas_copy_modified_ = 1;
1122    if (ok) {
1123      enc->prev_timestamp_ = timestamp;
1124    }
1125    return ok;
1126  }
1127  static int DecodeFrameOntoCanvas(const WebPMuxFrameInfo* const frame,
1128                                   WebPPicture* const canvas) {
1129    const WebPData* const image = &frame->bitstream;
1130    WebPPicture sub_image;
1131    WebPDecoderConfig config;
1132    WebPInitDecoderConfig(&config);
1133    WebPUtilClearPic(canvas, NULL);
1134    if (WebPGetFeatures(image->bytes, image->size, &config.input) !=
1135        VP8_STATUS_OK) {
1136      return 0;
1137    }
1138    if (!WebPPictureView(canvas, frame->x_offset, frame->y_offset,
1139                         config.input.width, config.input.height, &sub_image)) {
1140      return 0;
1141    }
1142    config.output.is_external_memory = 1;
1143    config.output.colorspace = MODE_BGRA;
1144    config.output.u.RGBA.rgba = (uint8_t*)sub_image.argb;
1145    config.output.u.RGBA.stride = sub_image.argb_stride * 4;
1146    config.output.u.RGBA.size = config.output.u.RGBA.stride * sub_image.height;
1147    if (WebPDecode(image->bytes, image->size, &config) != VP8_STATUS_OK) {
1148      return 0;
1149    }
1150    return 1;
1151  }
1152  static int FrameToFullCanvas(WebPAnimEncoder* const enc,
1153                               const WebPMuxFrameInfo* const frame,
1154                               WebPData* const full_image) {
1155    WebPPicture* const canvas_buf = &enc->curr_canvas_copy_;
1156    WebPMemoryWriter mem1, mem2;
1157    WebPMemoryWriterInit(&mem1);
1158    WebPMemoryWriterInit(&mem2);
1159    if (!DecodeFrameOntoCanvas(frame, canvas_buf)) goto Err;
1160    if (!EncodeFrame(&enc->last_config_, canvas_buf, &mem1)) goto Err;
1161    GetEncodedData(&mem1, full_image);
1162    if (enc->options_.allow_mixed) {
1163      if (!EncodeFrame(&enc->last_config_reversed_, canvas_buf, &mem2)) goto Err;
1164      if (mem2.size < mem1.size) {
1165        GetEncodedData(&mem2, full_image);
1166        WebPMemoryWriterClear(&mem1);
1167      } else {
1168        WebPMemoryWriterClear(&mem2);
1169      }
1170    }
1171    return 1;
1172   Err:
1173    WebPMemoryWriterClear(&mem1);
1174    WebPMemoryWriterClear(&mem2);
1175    return 0;
1176  }
1177  static WebPMuxError OptimizeSingleFrame(WebPAnimEncoder* const enc,
1178                                          WebPData* const webp_data) {
1179    WebPMuxError err = WEBP_MUX_OK;
1180    int canvas_width, canvas_height;
1181    WebPMuxFrameInfo frame;
1182    WebPData full_image;
1183    WebPData webp_data2;
1184    WebPMux* const mux = WebPMuxCreate(webp_data, 0);
1185    if (mux == NULL) return WEBP_MUX_BAD_DATA;
1186    assert(enc->out_frame_count_ == 1);
1187    WebPDataInit(&frame.bitstream);
1188    WebPDataInit(&full_image);
1189    WebPDataInit(&webp_data2);
1190    err = WebPMuxGetFrame(mux, 1, &frame);
1191    if (err != WEBP_MUX_OK) goto End;
1192    if (frame.id != WEBP_CHUNK_ANMF) goto End;  
1193    err = WebPMuxGetCanvasSize(mux, &canvas_width, &canvas_height);
1194    if (err != WEBP_MUX_OK) goto End;
1195    if (!FrameToFullCanvas(enc, &frame, &full_image)) {
1196      err = WEBP_MUX_BAD_DATA;
1197      goto End;
1198    }
1199    err = WebPMuxSetImage(mux, &full_image, 1);
1200    if (err != WEBP_MUX_OK) goto End;
1201    err = WebPMuxAssemble(mux, &webp_data2);
1202    if (err != WEBP_MUX_OK) goto End;
1203    if (webp_data2.size < webp_data->size) {  
1204      WebPDataClear(webp_data);
1205      *webp_data = webp_data2;
1206      WebPDataInit(&webp_data2);
1207    }
1208   End:
1209    WebPDataClear(&frame.bitstream);
1210    WebPDataClear(&full_image);
1211    WebPMuxDelete(mux);
1212    WebPDataClear(&webp_data2);
1213    return err;
1214  }
1215  int WebPAnimEncoderAssemble(WebPAnimEncoder* enc, WebPData* webp_data) {
1216    WebPMux* mux;
1217    WebPMuxError err;
1218    if (enc == NULL) {
1219      return 0;
1220    }
1221    MarkNoError(enc);
1222    if (webp_data == NULL) {
1223      MarkError(enc, "ERROR assembling: NULL input");
1224      return 0;
1225    }
1226    if (enc->in_frame_count_ == 0) {
1227      MarkError(enc, "ERROR: No frames to assemble");
1228      return 0;
1229    }
1230    if (!enc->got_null_frame_ && enc->in_frame_count_ > 1 && enc->count_ > 0) {
1231      const double delta_time =
1232          (uint32_t)enc->prev_timestamp_ - enc->first_timestamp_;
1233      const int average_duration = (int)(delta_time / (enc->in_frame_count_ - 1));
1234      if (!IncreasePreviousDuration(enc, average_duration)) {
1235        return 0;
1236      }
1237    }
1238    enc->flush_count_ = enc->count_;
1239    if (!FlushFrames(enc)) {
1240      return 0;
1241    }
1242    mux = enc->mux_;
1243    err = WebPMuxSetCanvasSize(mux, enc->canvas_width_, enc->canvas_height_);
1244    if (err != WEBP_MUX_OK) goto Err;
1245    err = WebPMuxSetAnimationParams(mux, &enc->options_.anim_params);
1246    if (err != WEBP_MUX_OK) goto Err;
1247    err = WebPMuxAssemble(mux, webp_data);
1248    if (err != WEBP_MUX_OK) goto Err;
1249    if (enc->out_frame_count_ == 1) {
1250      err = OptimizeSingleFrame(enc, webp_data);
1251      if (err != WEBP_MUX_OK) goto Err;
1252    }
1253    return 1;
1254   Err:
1255    MarkError2(enc, "ERROR assembling WebP", err);
1256    return 0;
1257  }
1258  const char* WebPAnimEncoderGetError(WebPAnimEncoder* enc) {
1259    if (enc == NULL) return NULL;
1260    return enc->error_str_;
1261  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-stats_13.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-anim_encode.c</div>
                </div>
                <div class="column column_space"><pre><code>438  		col_allocated.size_val = curlextents * lextent_size;
439  		col_nmalloc.uint64_val = nmalloc;
440  		col_nmalloc_ps.uint64_val = rate_per_second(nmalloc, uptime);
441  		col_ndalloc.uint64_val = ndalloc;
442  		col_ndalloc_ps.uint64_val = rate_per_second(ndalloc, uptime);
443  		col_nrequests.uint64_val = nrequests;
444  		col_nrequests_ps.uint64_val = rate_per_second(nrequests, uptime);
445  		col_curlextents.size_val = curlextents;
446  		if (!in_gap) {
</pre></code></div>
                <div class="column column_space"><pre><code>779      EncodedFrame* const curr_enc_frame = GetFrame(enc, enc->count_);
780      curr_enc_frame->is_key_frame_ = 0;
781      curr_enc_frame->sub_frame_.id = WEBP_CHUNK_ANMF;
782      curr_enc_frame->sub_frame_.x_offset = 0;
783      curr_enc_frame->sub_frame_.y_offset = 0;
784      curr_enc_frame->sub_frame_.dispose_method = WEBP_MUX_DISPOSE_NONE;
785      curr_enc_frame->sub_frame_.blend_method = WEBP_MUX_BLEND;
786      curr_enc_frame->sub_frame_.duration = duration;
787      if (!WebPDataCopy(can_use_lossless ? &lossless_1x1 : &lossy_1x1,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    