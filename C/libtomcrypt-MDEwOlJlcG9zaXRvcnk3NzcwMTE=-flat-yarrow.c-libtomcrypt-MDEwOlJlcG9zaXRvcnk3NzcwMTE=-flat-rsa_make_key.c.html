
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 31.876606683804624%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-yarrow.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_YARROW
3  const struct ltc_prng_descriptor yarrow_desc =
4  {
5      "yarrow", 64,
6      &yarrow_start,
7      &yarrow_add_entropy,
8      &yarrow_ready,
9      &yarrow_read,
10      &yarrow_done,
11      &yarrow_export,
12      &yarrow_import,
13      &yarrow_test
14  };
15  int yarrow_start(prng_state *prng)
16  {
17     int err;
18     LTC_ARGCHK(prng != NULL);
19     prng->ready = 0;
20  #ifdef LTC_RIJNDAEL
21  #if    LTC_YARROW_AES==0
22     prng->u.yarrow.cipher = register_cipher(&rijndael_enc_desc);
23  #elif  LTC_YARROW_AES==1
24     prng->u.yarrow.cipher = register_cipher(&aes_enc_desc);
25  #elif  LTC_YARROW_AES==2
26     prng->u.yarrow.cipher = register_cipher(&rijndael_desc);
27  #elif  LTC_YARROW_AES==3
28     prng->u.yarrow.cipher = register_cipher(&aes_desc);
29  #endif
30  #elif defined(LTC_BLOWFISH)
31     prng->u.yarrow.cipher = register_cipher(&blowfish_desc);
32  #elif defined(LTC_TWOFISH)
33     prng->u.yarrow.cipher = register_cipher(&twofish_desc);
34  #elif defined(LTC_RC6)
35     prng->u.yarrow.cipher = register_cipher(&rc6_desc);
36  #elif defined(LTC_RC5)
37     prng->u.yarrow.cipher = register_cipher(&rc5_desc);
38  #elif defined(LTC_SAFERP)
39     prng->u.yarrow.cipher = register_cipher(&saferp_desc);
40  #elif defined(LTC_RC2)
41     prng->u.yarrow.cipher = register_cipher(&rc2_desc);
42  #elif defined(LTC_NOEKEON)
43     prng->u.yarrow.cipher = register_cipher(&noekeon_desc);
44  #elif defined(LTC_ANUBIS)
45     prng->u.yarrow.cipher = register_cipher(&anubis_desc);
46  #elif defined(LTC_KSEED)
47     prng->u.yarrow.cipher = register_cipher(&kseed_desc);
48  #elif defined(LTC_KHAZAD)
49     prng->u.yarrow.cipher = register_cipher(&khazad_desc);
50  #elif defined(LTC_CAST5)
51     prng->u.yarrow.cipher = register_cipher(&cast5_desc);
52  #elif defined(LTC_XTEA)
53     prng->u.yarrow.cipher = register_cipher(&xtea_desc);
54  #elif defined(LTC_SAFER)
55     prng->u.yarrow.cipher = register_cipher(&safer_sk128_desc);
56  #elif defined(LTC_DES)
57     prng->u.yarrow.cipher = register_cipher(&des3_desc);
58  #else
59     #error LTC_YARROW needs at least one CIPHER
60  #endif
61     if ((err = cipher_is_valid(prng->u.yarrow.cipher)) != CRYPT_OK) {
62        return err;
63     }
64  #ifdef LTC_SHA256
65     prng->u.yarrow.hash   = register_hash(&sha256_desc);
66  #elif defined(LTC_SHA512)
67     prng->u.yarrow.hash   = register_hash(&sha512_desc);
68  #elif defined(LTC_TIGER)
69     prng->u.yarrow.hash   = register_hash(&tiger_desc);
70  #elif defined(LTC_SHA1)
71     prng->u.yarrow.hash   = register_hash(&sha1_desc);
72  #elif defined(LTC_RIPEMD320)
73     prng->u.yarrow.hash   = register_hash(&rmd320_desc);
74  #elif defined(LTC_RIPEMD256)
75     prng->u.yarrow.hash   = register_hash(&rmd256_desc);
76  #elif defined(LTC_RIPEMD160)
77     prng->u.yarrow.hash   = register_hash(&rmd160_desc);
78  #elif defined(LTC_RIPEMD128)
79     prng->u.yarrow.hash   = register_hash(&rmd128_desc);
80  #elif defined(LTC_MD5)
81     prng->u.yarrow.hash   = register_hash(&md5_desc);
82  #elif defined(LTC_MD4)
83     prng->u.yarrow.hash   = register_hash(&md4_desc);
84  #elif defined(LTC_MD2)
85     prng->u.yarrow.hash   = register_hash(&md2_desc);
86  #elif defined(LTC_WHIRLPOOL)
87     prng->u.yarrow.hash   = register_hash(&whirlpool_desc);
88  #else
89     #error LTC_YARROW needs at least one HASH
90  #endif
91     if ((err = hash_is_valid(prng->u.yarrow.hash)) != CRYPT_OK) {
92        return err;
93     }
94     zeromem(prng->u.yarrow.pool, sizeof(prng->u.yarrow.pool));
95     LTC_MUTEX_INIT(&prng->lock)
96     return CRYPT_OK;
97  }
98  int yarrow_add_entropy(const unsigned char *in, unsigned long inlen, prng_state *prng)
99  {
100     hash_state md;
101     int err;
102     LTC_ARGCHK(prng != NULL);
103     LTC_ARGCHK(in != NULL);
104     LTC_ARGCHK(inlen > 0);
105     LTC_MUTEX_LOCK(&prng->lock);
106     if ((err = hash_is_valid(prng->u.yarrow.hash)) != CRYPT_OK) {
107        goto LBL_UNLOCK;
108     }
109     if ((err = hash_descriptor[prng->u.yarrow.hash].init(&md)) != CRYPT_OK) {
110        goto LBL_UNLOCK;
111     }
112     if ((err = hash_descriptor[prng->u.yarrow.hash].process(&md, prng->u.yarrow.pool,
113                                                          hash_descriptor[prng->u.yarrow.hash].hashsize)) != CRYPT_OK) {
114        goto LBL_UNLOCK;
115     }
116     if ((err = hash_descriptor[prng->u.yarrow.hash].process(&md, in, inlen)) != CRYPT_OK) {
117        goto LBL_UNLOCK;
118     }
119     err = hash_descriptor[prng->u.yarrow.hash].done(&md, prng->u.yarrow.pool);
120  LBL_UNLOCK:
121     LTC_MUTEX_UNLOCK(&prng->lock);
122     return err;
123  }
124  int yarrow_ready(prng_state *prng)
125  {
126     int ks, err;
127     LTC_ARGCHK(prng != NULL);
128     LTC_MUTEX_LOCK(&prng->lock);
<span onclick='openModal()' class='match'>129     if ((err = hash_is_valid(prng->u.yarrow.hash)) != CRYPT_OK) {
130        goto LBL_UNLOCK;
131     }
132     if ((err = cipher_is_valid(prng->u.yarrow.cipher)) != CRYPT_OK) {
133        goto LBL_UNLOCK;
134     }
135     ks = (int)hash_descriptor[prng->u.yarrow.hash].hashsize;
</span>136     if ((err = cipher_descriptor[prng->u.yarrow.cipher].keysize(&ks)) != CRYPT_OK) {
137        goto LBL_UNLOCK;
138     }
139     if ((err = ctr_start(prng->u.yarrow.cipher,     &bsol;* what cipher to use */
140                          prng->u.yarrow.pool,       &bsol;* IV */
141                          prng->u.yarrow.pool, ks,   &bsol;* KEY and key size */
142                          0,                       &bsol;* number of rounds */
143                          CTR_COUNTER_LITTLE_ENDIAN, &bsol;* little endian counter */
144                          &prng->u.yarrow.ctr)) != CRYPT_OK) {
145        goto LBL_UNLOCK;
146     }
147     prng->ready = 1;
148  LBL_UNLOCK:
149     LTC_MUTEX_UNLOCK(&prng->lock);
150     return err;
151  }
152  unsigned long yarrow_read(unsigned char *out, unsigned long outlen, prng_state *prng)
153  {
154     if (outlen == 0 || prng == NULL || out == NULL) return 0;
155     LTC_MUTEX_LOCK(&prng->lock);
156     if (!prng->ready) {
157        outlen = 0;
158        goto LBL_UNLOCK;
159     }
160     zeromem(out, outlen);
161     if (ctr_encrypt(out, out, outlen, &prng->u.yarrow.ctr) != CRYPT_OK) {
162        outlen = 0;
163     }
164  LBL_UNLOCK:
165     LTC_MUTEX_UNLOCK(&prng->lock);
166     return outlen;
167  }
168  int yarrow_done(prng_state *prng)
169  {
170     int err;
171     LTC_ARGCHK(prng != NULL);
172     LTC_MUTEX_LOCK(&prng->lock);
173     prng->ready = 0;
174     err = ctr_done(&prng->u.yarrow.ctr);
175     LTC_MUTEX_UNLOCK(&prng->lock);
176     LTC_MUTEX_DESTROY(&prng->lock);
177     return err;
178  }
179  LTC_PRNG_EXPORT(yarrow)
180  int yarrow_import(const unsigned char *in, unsigned long inlen, prng_state *prng)
181  {
182     int err;
183     LTC_ARGCHK(in   != NULL);
184     LTC_ARGCHK(prng != NULL);
185     if (inlen < (unsigned long)yarrow_desc.export_size) return CRYPT_INVALID_ARG;
186     if ((err = yarrow_start(prng)) != CRYPT_OK)                  return err;
187     if ((err = yarrow_add_entropy(in, inlen, prng)) != CRYPT_OK) return err;
188     return CRYPT_OK;
189  }
190  int yarrow_test(void)
191  {
192  #ifndef LTC_TEST
193     return CRYPT_NOP;
194  #else
195     int err;
196     prng_state prng;
197     if ((err = yarrow_start(&prng)) != CRYPT_OK) {
198        return err;
199     }
200     if (cipher_descriptor[prng.u.yarrow.cipher].test &&
201         ((err = cipher_descriptor[prng.u.yarrow.cipher].test()) != CRYPT_OK)) {
202        return err;
203     }
204     if (hash_descriptor[prng.u.yarrow.hash].test &&
205         ((err = hash_descriptor[prng.u.yarrow.hash].test()) != CRYPT_OK)) {
206        return err;
207     }
208     return CRYPT_OK;
209  #endif
210  }
211  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rsa_make_key.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_MRSA
3  static int s_rsa_make_key(prng_state *prng, int wprng, int size, void *e, rsa_key *key)
4  {
5     void *p, *q, *tmp1, *tmp2;
6     int    err;
7     LTC_ARGCHK(ltc_mp.name != NULL);
8     LTC_ARGCHK(key         != NULL);
9     LTC_ARGCHK(size        > 0);
10     if ((err = prng_is_valid(wprng)) != CRYPT_OK) {
11        return err;
12     }
13     if ((err = mp_init_multi(&p, &q, &tmp1, &tmp2, LTC_NULL)) != CRYPT_OK) {
14        return err;
15     }
16     do {
17         if ((err = rand_prime( p, size/2, prng, wprng)) != CRYPT_OK)  { goto cleanup; }
18         if ((err = mp_sub_d( p, 1,  tmp1)) != CRYPT_OK)               { goto cleanup; }  &bsol;* tmp1 = p-1 */
19         if ((err = mp_gcd( tmp1,  e,  tmp2)) != CRYPT_OK)             { goto cleanup; }  &bsol;* tmp2 = gcd(p-1, e) */
20     } while (mp_cmp_d( tmp2, 1) != 0);                                                  &bsol;* while e divides p-1 */
21     do {
<span onclick='openModal()' class='match'>22         if ((err = rand_prime( q, size/2, prng, wprng)) != CRYPT_OK)  { goto cleanup; }
23         if ((err = mp_sub_d( q, 1,  tmp1)) != CRYPT_OK)               { goto cleanup; } &bsol;* tmp1 = q-1 */
</span>24         if ((err = mp_gcd( tmp1,  e,  tmp2)) != CRYPT_OK)          { goto cleanup; } &bsol;* tmp2 = gcd(q-1, e) */
25     } while (mp_cmp_d( tmp2, 1) != 0);                                                 &bsol;* while e divides q-1 */
26     if ((err = mp_sub_d( p, 1,  tmp2)) != CRYPT_OK)                   { goto cleanup; } &bsol;* tmp2 = p-1 */
27     if ((err = mp_lcm( tmp1,  tmp2,  tmp1)) != CRYPT_OK)              { goto cleanup; } &bsol;* tmp1 = lcm(p-1, q-1) */
28     if ((err = rsa_init(key)) != CRYPT_OK) {
29        goto errkey;
30     }
31     if ((err = mp_copy( e,  key->e)) != CRYPT_OK)                       { goto errkey; } &bsol;* key->e =  e */
32     if ((err = mp_invmod( key->e,  tmp1,  key->d)) != CRYPT_OK)         { goto errkey; } &bsol;* key->d = 1/e mod lcm(p-1,q-1) */
33     if ((err = mp_mul( p,  q,  key->N)) != CRYPT_OK)                    { goto errkey; } &bsol;* key->N = pq */
34     if ((err = mp_sub_d( p, 1,  tmp1)) != CRYPT_OK)                     { goto errkey; } &bsol;* tmp1 = p-1 */
35     if ((err = mp_sub_d( q, 1,  tmp2)) != CRYPT_OK)                     { goto errkey; } &bsol;* tmp2 = q-1 */
36     if ((err = mp_mod( key->d,  tmp1,  key->dP)) != CRYPT_OK)           { goto errkey; } &bsol;* dP = d mod p-1 */
37     if ((err = mp_mod( key->d,  tmp2,  key->dQ)) != CRYPT_OK)           { goto errkey; } &bsol;* dQ = d mod q-1 */
38     if ((err = mp_invmod( q,  p,  key->qP)) != CRYPT_OK)                { goto errkey; } &bsol;* qP = 1/q mod p */
39     if ((err = mp_copy( p,  key->p)) != CRYPT_OK)                       { goto errkey; }
40     if ((err = mp_copy( q,  key->q)) != CRYPT_OK)                       { goto errkey; }
41     key->type = PK_PRIVATE;
42     err       = CRYPT_OK;
43     goto cleanup;
44  errkey:
45     rsa_free(key);
46  cleanup:
47     mp_clear_multi(tmp2, tmp1, q, p, LTC_NULL);
48     return err;
49  }
50  int rsa_make_key(prng_state *prng, int wprng, int size, long e, rsa_key *key)
51  {
52     void *tmp_e;
53     int err;
54     if ((e < 3) || ((e & 1) == 0)) {
55       return CRYPT_INVALID_ARG;
56     }
57     if ((err = mp_init(&tmp_e)) != CRYPT_OK) {
58       return err;
59     }
60     if ((err = mp_set_int(tmp_e, e)) == CRYPT_OK)
61       err = s_rsa_make_key(prng, wprng, size, tmp_e, key);
62     mp_clear(tmp_e);
63     return err;
64  }
65  int rsa_make_key_ubin_e(prng_state *prng, int wprng, int size,
66                          const unsigned char *e, unsigned long elen, rsa_key *key)
67  {
68     int err;
69     void *tmp_e;
70     if ((err = mp_init(&tmp_e)) != CRYPT_OK) {
71        return err;
72     }
73     if ((err = mp_read_unsigned_bin(tmp_e, (unsigned char *)e, elen)) == CRYPT_OK)
74       err = rsa_make_key_bn_e(prng, wprng, size, tmp_e, key);
75     mp_clear(tmp_e);
76     return err;
77  }
78  int rsa_make_key_bn_e(prng_state *prng, int wprng, int size, void *e, rsa_key *key)
79  {
80     int err;
81     int e_bits;
82     e_bits = mp_count_bits(e);
83     if ((e_bits > 1 && e_bits < 256) && (mp_get_digit(e, 0) & 1)) {
84       err = s_rsa_make_key(prng, wprng, size, e, key);
85     } else {
86       err = CRYPT_INVALID_ARG;
87     }
88     return err;
89  }
90  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-yarrow.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rsa_make_key.c</div>
                </div>
                <div class="column column_space"><pre><code>129     if ((err = hash_is_valid(prng->u.yarrow.hash)) != CRYPT_OK) {
130        goto LBL_UNLOCK;
131     }
132     if ((err = cipher_is_valid(prng->u.yarrow.cipher)) != CRYPT_OK) {
133        goto LBL_UNLOCK;
134     }
135     ks = (int)hash_descriptor[prng->u.yarrow.hash].hashsize;
</pre></code></div>
                <div class="column column_space"><pre><code>22         if ((err = rand_prime( q, size/2, prng, wprng)) != CRYPT_OK)  { goto cleanup; }
23         if ((err = mp_sub_d( q, 1,  tmp1)) != CRYPT_OK)               { goto cleanup; } &bsol;* tmp1 = q-1 */
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    