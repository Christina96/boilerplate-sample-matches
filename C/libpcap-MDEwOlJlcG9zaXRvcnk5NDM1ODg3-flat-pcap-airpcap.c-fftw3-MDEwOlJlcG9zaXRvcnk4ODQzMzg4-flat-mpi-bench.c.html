
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.642074506939371%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-airpcap.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include "pcap-int.h"
5  #include <airpcap.h>
6  #include "pcap-airpcap.h"
7  #define	AIRPCAP_DEFAULT_USER_BUFFER_SIZE 256000
8  #define	AIRPCAP_DEFAULT_KERNEL_BUFFER_SIZE 1000000
9  static pcap_code_handle_t airpcap_lib;
10  typedef PCHAR (*AirpcapGetLastErrorHandler)(PAirpcapHandle);
11  typedef BOOL (*AirpcapGetDeviceListHandler)(PAirpcapDeviceDescription *, PCHAR);
12  typedef VOID (*AirpcapFreeDeviceListHandler)(PAirpcapDeviceDescription);
13  typedef PAirpcapHandle (*AirpcapOpenHandler)(PCHAR, PCHAR);
14  typedef VOID (*AirpcapCloseHandler)(PAirpcapHandle);
15  typedef BOOL (*AirpcapSetDeviceMacFlagsHandler)(PAirpcapHandle, UINT);
16  typedef BOOL (*AirpcapSetLinkTypeHandler)(PAirpcapHandle, AirpcapLinkType);
17  typedef BOOL (*AirpcapGetLinkTypeHandler)(PAirpcapHandle, PAirpcapLinkType);
18  typedef BOOL (*AirpcapSetKernelBufferHandler)(PAirpcapHandle, UINT);
19  typedef BOOL (*AirpcapSetFilterHandler)(PAirpcapHandle, PVOID, UINT);
20  typedef BOOL (*AirpcapSetMinToCopyHandler)(PAirpcapHandle, UINT);
21  typedef BOOL (*AirpcapGetReadEventHandler)(PAirpcapHandle, HANDLE *);
22  typedef BOOL (*AirpcapReadHandler)(PAirpcapHandle, PBYTE, UINT, PUINT);
23  typedef BOOL (*AirpcapWriteHandler)(PAirpcapHandle, PCHAR, ULONG);
24  typedef BOOL (*AirpcapGetStatsHandler)(PAirpcapHandle, PAirpcapStats);
25  static AirpcapGetLastErrorHandler p_AirpcapGetLastError;
26  static AirpcapGetDeviceListHandler p_AirpcapGetDeviceList;
27  static AirpcapFreeDeviceListHandler p_AirpcapFreeDeviceList;
28  static AirpcapOpenHandler p_AirpcapOpen;
29  static AirpcapCloseHandler p_AirpcapClose;
30  static AirpcapSetDeviceMacFlagsHandler p_AirpcapSetDeviceMacFlags;
31  static AirpcapSetLinkTypeHandler p_AirpcapSetLinkType;
32  static AirpcapGetLinkTypeHandler p_AirpcapGetLinkType;
33  static AirpcapSetKernelBufferHandler p_AirpcapSetKernelBuffer;
34  static AirpcapSetFilterHandler p_AirpcapSetFilter;
35  static AirpcapSetMinToCopyHandler p_AirpcapSetMinToCopy;
36  static AirpcapGetReadEventHandler p_AirpcapGetReadEvent;
37  static AirpcapReadHandler p_AirpcapRead;
38  static AirpcapWriteHandler p_AirpcapWrite;
39  static AirpcapGetStatsHandler p_AirpcapGetStats;
40  typedef enum LONG
41  {
42  	AIRPCAP_API_UNLOADED = 0,
43  	AIRPCAP_API_LOADED,
44  	AIRPCAP_API_CANNOT_LOAD,
45  	AIRPCAP_API_LOADING
46  } AIRPCAP_API_LOAD_STATUS;
47  static AIRPCAP_API_LOAD_STATUS	airpcap_load_status;
48  static AIRPCAP_API_LOAD_STATUS
49  load_airpcap_functions(void)
50  {
51  	AIRPCAP_API_LOAD_STATUS current_status;
52  	current_status = InterlockedCompareExchange((LONG *)&airpcap_load_status,
53  	    AIRPCAP_API_LOADING, AIRPCAP_API_UNLOADED);
54  	while (current_status == AIRPCAP_API_LOADING) {
55  		current_status = InterlockedCompareExchange((LONG*)&airpcap_load_status,
56  		    AIRPCAP_API_LOADING, AIRPCAP_API_LOADING);
57  		Sleep(10);
58  	}
59  	if (current_status == AIRPCAP_API_LOADED)
60  		return AIRPCAP_API_LOADED;
61  	if (current_status == AIRPCAP_API_CANNOT_LOAD)
62  		return AIRPCAP_API_CANNOT_LOAD;
63  	current_status = AIRPCAP_API_CANNOT_LOAD;
64  	airpcap_lib = pcap_load_code("airpcap.dll");
65  	if (airpcap_lib != NULL) {
66  		p_AirpcapGetLastError = (AirpcapGetLastErrorHandler) pcap_find_function(airpcap_lib, "AirpcapGetLastError");
67  		p_AirpcapGetDeviceList = (AirpcapGetDeviceListHandler) pcap_find_function(airpcap_lib, "AirpcapGetDeviceList");
68  		p_AirpcapFreeDeviceList = (AirpcapFreeDeviceListHandler) pcap_find_function(airpcap_lib, "AirpcapFreeDeviceList");
69  		p_AirpcapOpen = (AirpcapOpenHandler) pcap_find_function(airpcap_lib, "AirpcapOpen");
70  		p_AirpcapClose = (AirpcapCloseHandler) pcap_find_function(airpcap_lib, "AirpcapClose");
71  		p_AirpcapSetDeviceMacFlags = (AirpcapSetDeviceMacFlagsHandler) pcap_find_function(airpcap_lib, "AirpcapSetDeviceMacFlags");
72  		p_AirpcapSetLinkType = (AirpcapSetLinkTypeHandler) pcap_find_function(airpcap_lib, "AirpcapSetLinkType");
73  		p_AirpcapGetLinkType = (AirpcapGetLinkTypeHandler) pcap_find_function(airpcap_lib, "AirpcapGetLinkType");
74  		p_AirpcapSetKernelBuffer = (AirpcapSetKernelBufferHandler) pcap_find_function(airpcap_lib, "AirpcapSetKernelBuffer");
75  		p_AirpcapSetFilter = (AirpcapSetFilterHandler) pcap_find_function(airpcap_lib, "AirpcapSetFilter");
76  		p_AirpcapSetMinToCopy = (AirpcapSetMinToCopyHandler) pcap_find_function(airpcap_lib, "AirpcapSetMinToCopy");
77  		p_AirpcapGetReadEvent = (AirpcapGetReadEventHandler) pcap_find_function(airpcap_lib, "AirpcapGetReadEvent");
78  		p_AirpcapRead = (AirpcapReadHandler) pcap_find_function(airpcap_lib, "AirpcapRead");
79  		p_AirpcapWrite = (AirpcapWriteHandler) pcap_find_function(airpcap_lib, "AirpcapWrite");
80  		p_AirpcapGetStats = (AirpcapGetStatsHandler) pcap_find_function(airpcap_lib, "AirpcapGetStats");
81  		if (p_AirpcapGetLastError != NULL &&
82  		    p_AirpcapGetDeviceList != NULL &&
83  		    p_AirpcapFreeDeviceList != NULL &&
84  		    p_AirpcapOpen != NULL &&
85  		    p_AirpcapClose != NULL &&
86  		    p_AirpcapSetDeviceMacFlags != NULL &&
87  		    p_AirpcapSetLinkType != NULL &&
88  		    p_AirpcapGetLinkType != NULL &&
89  		    p_AirpcapSetKernelBuffer != NULL &&
90  		    p_AirpcapSetFilter != NULL &&
91  		    p_AirpcapSetMinToCopy != NULL &&
92  		    p_AirpcapGetReadEvent != NULL &&
93  		    p_AirpcapRead != NULL &&
94  		    p_AirpcapWrite != NULL &&
95  		    p_AirpcapGetStats != NULL) {
96  			current_status = AIRPCAP_API_LOADED;
97  		}
98  	}
99  	if (current_status != AIRPCAP_API_LOADED) {
100  		if (airpcap_lib != NULL) {
101  			FreeLibrary(airpcap_lib);
102  			airpcap_lib = NULL;
103  		}
104  	}
105  	InterlockedExchange((LONG *)&airpcap_load_status, current_status);
106  	return current_status;
107  }
108  struct pcap_airpcap {
109  	PAirpcapHandle adapter;
110  	int filtering_in_kernel;
111  	int nonblock;
112  	int read_timeout;
113  	HANDLE read_event;
114  	struct pcap_stat stat;
115  };
116  static int
117  airpcap_setfilter(pcap_t *p, struct bpf_program *fp)
118  {
119  	struct pcap_airpcap *pa = p->priv;
120  	if (!p_AirpcapSetFilter(pa->adapter, fp->bf_insns,
121  	    fp->bf_len * sizeof(struct bpf_insn))) {
122  		if (pcap_install_bpf_program(p, fp) < 0)
123  			return (-1);
124  		pa->filtering_in_kernel = 0;	&bsol;* filtering in userland */
125  		return (0);
126  	}
127  	pa->filtering_in_kernel = 1;	&bsol;* filtering in the kernel */
128  	p->cc = 0;
129  	return (0);
130  }
131  static int
132  airpcap_set_datalink(pcap_t *p, int dlt)
133  {
134  	struct pcap_airpcap *pa = p->priv;
135  	AirpcapLinkType type;
136  	switch (dlt) {
137  	case DLT_IEEE802_11_RADIO:
138  		type = AIRPCAP_LT_802_11_PLUS_RADIO;
139  		break;
140  	case DLT_PPI:
141  		type = AIRPCAP_LT_802_11_PLUS_PPI;
142  		break;
143  	case DLT_IEEE802_11:
144  		type = AIRPCAP_LT_802_11;
145  		break;
146  	default:
147  		return (0);
148  	}
149  	if (!p_AirpcapSetLinkType(pa->adapter, type)) {
150  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
151  		    "AirpcapSetLinkType() failed: %s",
152  		    p_AirpcapGetLastError(pa->adapter));
153  		return (-1);
154  	}
155  	p->linktype = dlt;
156  	return (0);
157  }
158  static int
159  airpcap_getnonblock(pcap_t *p)
160  {
161  	struct pcap_airpcap *pa = p->priv;
162  	return (pa->nonblock);
163  }
164  static int
165  airpcap_setnonblock(pcap_t *p, int nonblock)
166  {
167  	struct pcap_airpcap *pa = p->priv;
168  	int newtimeout;
169  	if (nonblock) {
170  		newtimeout = -1;
171  	} else {
172  		newtimeout = p->opt.timeout;
173  	}
174  	pa->read_timeout = newtimeout;
175  	pa->nonblock = (newtimeout == -1);
176  	return (0);
177  }
178  static int
179  airpcap_stats(pcap_t *p, struct pcap_stat *ps)
180  {
181  	struct pcap_airpcap *pa = p->priv;
182  	AirpcapStats tas;
183  	if (!p_AirpcapGetStats(pa->adapter, &tas)) {
184  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
185  		    "AirpcapGetStats() failed: %s",
186  		    p_AirpcapGetLastError(pa->adapter));
187  		return (-1);
188  	}
189  	ps->ps_drop = tas.Drops;
190  	ps->ps_recv = tas.Recvs;
191  	ps->ps_ifdrop = tas.IfDrops;
192  	return (0);
193  }
194  static struct pcap_stat *
195  airpcap_stats_ex(pcap_t *p, int *pcap_stat_size)
196  {
197  	struct pcap_airpcap *pa = p->priv;
198  	AirpcapStats tas;
199  	*pcap_stat_size = sizeof (p->stat);
200  	if (!p_AirpcapGetStats(pa->adapter, &tas)) {
201  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
202  		    "AirpcapGetStats() failed: %s",
203  		    p_AirpcapGetLastError(pa->adapter));
204  		return (NULL);
205  	}
206  	p->stat.ps_recv = tas.Recvs;
207  	p->stat.ps_drop = tas.Drops;
208  	p->stat.ps_ifdrop = tas.IfDrops;
209  #ifdef _WIN32
210  	p->stat.ps_capt = tas.Capt;
211  #endif
212  	return (&p->stat);
213  }
214  static int
215  airpcap_setbuff(pcap_t *p, int dim)
216  {
217  	struct pcap_airpcap *pa = p->priv;
218  	if (!p_AirpcapSetKernelBuffer(pa->adapter, dim)) {
219  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
220  		    "AirpcapSetKernelBuffer() failed: %s",
221  		    p_AirpcapGetLastError(pa->adapter));
222  		return (-1);
223  	}
224  	return (0);
225  }
226  static int
227  airpcap_setmode(pcap_t *p, int mode)
228  {
229  	 if (mode != MODE_CAPT) {
230  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
231  		    "Only MODE_CAPT is supported on an AirPcap adapter");
232  		return (-1);
233  	 }
234  	 return (0);
235  }
236  static int
237  airpcap_setmintocopy(pcap_t *p, int size)
238  {
239  	struct pcap_airpcap *pa = p->priv;
240  	if (!p_AirpcapSetMinToCopy(pa->adapter, size)) {
241  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
242  		    "AirpcapSetMinToCopy() failed: %s",
243  		    p_AirpcapGetLastError(pa->adapter));
244  		return (-1);
245  	}
246  	return (0);
247  }
248  static HANDLE
249  airpcap_getevent(pcap_t *p)
250  {
251  	struct pcap_airpcap *pa = p->priv;
252  	return (pa->read_event);
253  }
254  static int
255  airpcap_oid_get_request(pcap_t *p, bpf_u_int32 oid _U_, void *data _U_,
256      size_t *lenp _U_)
257  {
258  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
259  	    "Getting OID values is not supported on an AirPcap adapter");
260  	return (PCAP_ERROR);
261  }
262  static int
263  airpcap_oid_set_request(pcap_t *p, bpf_u_int32 oid _U_, const void *data _U_,
264      size_t *lenp _U_)
265  {
266  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
267  	    "Setting OID values is not supported on an AirPcap adapter");
268  	return (PCAP_ERROR);
269  }
270  static u_int
271  airpcap_sendqueue_transmit(pcap_t *p, pcap_send_queue *queue _U_, int sync _U_)
272  {
273  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
274  	    "Cannot queue packets for transmission on an AirPcap adapter");
275  	return (0);
276  }
277  static int
278  airpcap_setuserbuffer(pcap_t *p, int size)
279  {
280  	unsigned char *new_buff;
281  	if (size <= 0) {
282  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
283  		    "Error: invalid size %d",size);
284  		return (-1);
285  	}
286  	new_buff = (unsigned char *)malloc(sizeof(char)*size);
287  	if (!new_buff) {
288  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
289  		    "Error: not enough memory");
290  		return (-1);
291  	}
292  	free(p->buffer);
293  	p->buffer = new_buff;
294  	p->bufsize = size;
295  	return (0);
296  }
297  static int
298  airpcap_live_dump(pcap_t *p, char *filename _U_, int maxsize _U_,
299      int maxpacks _U_)
300  {
301  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
302  	    "AirPcap adapters don't support live dump");
303  	return (-1);
304  }
305  static int
306  airpcap_live_dump_ended(pcap_t *p, int sync _U_)
307  {
308  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
309  	    "AirPcap adapters don't support live dump");
310  	return (-1);
311  }
312  static PAirpcapHandle
313  airpcap_get_airpcap_handle(pcap_t *p)
314  {
315  	struct pcap_airpcap *pa = p->priv;
316  	return (pa->adapter);
317  }
318  static int
319  airpcap_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
320  {
321  	struct pcap_airpcap *pa = p->priv;
322  	int cc;
323  	int n;
324  	register u_char *bp, *ep;
325  	UINT bytes_read;
326  	u_char *datap;
327  	cc = p->cc;
328  	if (cc == 0) {
329  		if (p->break_loop) {
330  			p->break_loop = 0;
331  			return (PCAP_ERROR_BREAK);
332  		}
333  		if (pa->read_timeout != -1) {
334  			WaitForSingleObject(pa->read_event,
335  			    (pa->read_timeout ==0 )? INFINITE: pa->read_timeout);
336  		}
337  		if (!p_AirpcapRead(pa->adapter, (PBYTE)p->buffer,
338  		    p->bufsize, &bytes_read)) {
339  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
340  			    "AirpcapRead() failed: %s",
341  			    p_AirpcapGetLastError(pa->adapter));
342  			return (-1);
343  		}
344  		cc = bytes_read;
345  		bp = p->buffer;
346  	} else
347  		bp = p->bp;
348  #define bhp ((AirpcapBpfHeader *)bp)
349  	n = 0;
350  	ep = bp + cc;
351  	for (;;) {
352  		register u_int caplen, hdrlen;
353  		if (p->break_loop) {
354  			if (n == 0) {
355  				p->break_loop = 0;
356  				return (PCAP_ERROR_BREAK);
357  			} else {
358  				p->bp = bp;
359  				p->cc = (int) (ep - bp);
360  				return (n);
361  			}
362  		}
363  		if (bp >= ep)
364  			break;
365  		caplen = bhp->Caplen;
366  		hdrlen = bhp->Hdrlen;
367  		datap = bp + hdrlen;
368  		if (pa->filtering_in_kernel ||
369  		    p->fcode.bf_insns == NULL ||
370  		    pcap_filter(p->fcode.bf_insns, datap, bhp->Originallen, caplen)) {
371  			struct pcap_pkthdr pkthdr;
372  			pkthdr.ts.tv_sec = bhp->TsSec;
373  			pkthdr.ts.tv_usec = bhp->TsUsec;
374  			pkthdr.caplen = caplen;
375  			pkthdr.len = bhp->Originallen;
376  			(*callback)(user, &pkthdr, datap);
377  			bp += AIRPCAP_WORDALIGN(caplen + hdrlen);
378  			if (++n >= cnt && !PACKET_COUNT_IS_UNLIMITED(cnt)) {
379  				p->bp = bp;
380  				p->cc = (int)(ep - bp);
381  				return (n);
382  			}
383  		} else {
384  			bp += AIRPCAP_WORDALIGN(caplen + hdrlen);
385  		}
386  	}
387  #undef bhp
388  	p->cc = 0;
389  	return (n);
390  }
391  static int
392  airpcap_inject(pcap_t *p, const void *buf, int size)
393  {
394  	struct pcap_airpcap *pa = p->priv;
395  	if (!p_AirpcapWrite(pa->adapter, (void *)buf, size)) {
396  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
397  		    "AirpcapWrite() failed: %s",
398  		    p_AirpcapGetLastError(pa->adapter));
399  		return (-1);
400  	}
401  	return (size);
402  }
403  static void
404  airpcap_cleanup(pcap_t *p)
405  {
406  	struct pcap_airpcap *pa = p->priv;
407  	if (pa->adapter != NULL) {
408  		p_AirpcapClose(pa->adapter);
409  		pa->adapter = NULL;
410  	}
411  	pcap_cleanup_live_common(p);
412  }
413  static void
414  airpcap_breakloop(pcap_t *p)
415  {
416  	HANDLE read_event;
417  	pcap_breakloop_common(p);
418  	struct pcap_airpcap *pa = p->priv;
419  	if (!p_AirpcapGetReadEvent(pa->adapter, &read_event))
420  		return;
421  	SetEvent(read_event);
422  }
423  static int
424  airpcap_activate(pcap_t *p)
425  {
426  	struct pcap_airpcap *pa = p->priv;
427  	char *device = p->opt.device;
428  	char airpcap_errbuf[AIRPCAP_ERRBUF_SIZE];
429  	BOOL status;
430  	AirpcapLinkType link_type;
431  	pa->adapter = p_AirpcapOpen(device, airpcap_errbuf);
432  	if (pa->adapter == NULL) {
433  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "%s", airpcap_errbuf);
434  		return (PCAP_ERROR);
435  	}
436  	if (p->opt.rfmon) {
437  		status = p_AirpcapSetDeviceMacFlags(pa->adapter,
438  		    AIRPCAP_MF_MONITOR_MODE_ON);
439  	} else
440  		status = p_AirpcapSetDeviceMacFlags(pa->adapter,
441  		    AIRPCAP_MF_ACK_FRAMES_ON);
442  	if (!status) {
443  		p_AirpcapClose(pa->adapter);
444  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
445  		    "AirpcapSetDeviceMacFlags() failed: %s",
446  		    p_AirpcapGetLastError(pa->adapter));
447  		return (PCAP_ERROR);
448  	}
449  	if (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)
450  		p->snapshot = MAXIMUM_SNAPLEN;
451  	if (p->opt.buffer_size == 0)
452  		p->opt.buffer_size = AIRPCAP_DEFAULT_KERNEL_BUFFER_SIZE;
453  	if (!p_AirpcapSetKernelBuffer(pa->adapter, p->opt.buffer_size)) {
454  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
455  		    "AirpcapSetKernelBuffer() failed: %s",
456  		    p_AirpcapGetLastError(pa->adapter));
457  		goto bad;
458  	}
459  	if(!p_AirpcapGetReadEvent(pa->adapter, &pa->read_event)) {
460  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
461  		    "AirpcapGetReadEvent() failed: %s",
462  		    p_AirpcapGetLastError(pa->adapter));
463  		goto bad;
464  	}
465  	p->bufsize = AIRPCAP_DEFAULT_USER_BUFFER_SIZE;
466  	p->buffer = malloc(p->bufsize);
467  	if (p->buffer == NULL) {
468  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
469  		    errno, "malloc");
470  		goto bad;
471  	}
472  	if (p->opt.immediate) {
473  		if (!p_AirpcapSetMinToCopy(pa->adapter, 0)) {
474  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
475  			    "AirpcapSetMinToCopy() failed: %s",
476  			    p_AirpcapGetLastError(pa->adapter));
477  			goto bad;
478  		}
479  	} else {
480  		if (!p_AirpcapSetMinToCopy(pa->adapter, 16000)) {
481  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
482  			    "AirpcapSetMinToCopy() failed: %s",
483  			    p_AirpcapGetLastError(pa->adapter));
484  			goto bad;
485  		}
486  	}
487  	if (!p_AirpcapGetLinkType(pa->adapter, &link_type)) {
488  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
489  		    "AirpcapGetLinkType() failed: %s",
490  		    p_AirpcapGetLastError(pa->adapter));
491  		goto bad;
492  	}
493  	switch (link_type) {
494  	case AIRPCAP_LT_802_11_PLUS_RADIO:
495  		p->linktype = DLT_IEEE802_11_RADIO;
496  		break;
497  	case AIRPCAP_LT_802_11_PLUS_PPI:
498  		p->linktype = DLT_PPI;
499  		break;
500  	case AIRPCAP_LT_802_11:
501  		p->linktype = DLT_IEEE802_11;
502  		break;
503  	case AIRPCAP_LT_UNKNOWN:
504  	default:
505  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
506  		    "AirpcapGetLinkType() returned unknown link type %u",
507  		    link_type);
508  		goto bad;
509  	}
510  	p->dlt_list = (u_int *) malloc(sizeof(u_int) * 3);
511  	if (p->dlt_list == NULL)
512  		goto bad;
<span onclick='openModal()' class='match'>513  	p->dlt_list[0] = DLT_IEEE802_11_RADIO;
514  	p->dlt_list[1] = DLT_PPI;
515  	p->dlt_list[2] = DLT_IEEE802_11;
516  	p->dlt_count = 3;
517  	p->read_op = airpcap_read;
518  	p->inject_op = airpcap_inject;
519  	p->setfilter_op = airpcap_setfilter;
520  	p->setdirection_op = NULL;	&bsol;* Not implemented. */
</span>521  	p->set_datalink_op = airpcap_set_datalink;
522  	p->getnonblock_op = airpcap_getnonblock;
523  	p->setnonblock_op = airpcap_setnonblock;
524  	p->breakloop_op = airpcap_breakloop;
525  	p->stats_op = airpcap_stats;
526  	p->stats_ex_op = airpcap_stats_ex;
527  	p->setbuff_op = airpcap_setbuff;
528  	p->setmode_op = airpcap_setmode;
529  	p->setmintocopy_op = airpcap_setmintocopy;
530  	p->getevent_op = airpcap_getevent;
531  	p->oid_get_request_op = airpcap_oid_get_request;
532  	p->oid_set_request_op = airpcap_oid_set_request;
533  	p->sendqueue_transmit_op = airpcap_sendqueue_transmit;
534  	p->setuserbuffer_op = airpcap_setuserbuffer;
535  	p->live_dump_op = airpcap_live_dump;
536  	p->live_dump_ended_op = airpcap_live_dump_ended;
537  	p->get_airpcap_handle_op = airpcap_get_airpcap_handle;
538  	p->cleanup_op = airpcap_cleanup;
539  	return (0);
540   bad:
541  	airpcap_cleanup(p);
542  	return (PCAP_ERROR);
543  }
544  static int
545  airpcap_can_set_rfmon(pcap_t *p)
546  {
547  	return (1);
548  }
549  int
550  device_is_airpcap(const char *device, char *ebuf)
551  {
552  	static const char airpcap_prefix[] = "\\\\.\\airpcap";
553  	if (strncmp(device, airpcap_prefix, sizeof airpcap_prefix - 1) == 0) {
554  		return (1);
555  	}
556  	return (0);
557  }
558  pcap_t *
559  airpcap_create(const char *device, char *ebuf, int *is_ours)
560  {
561  	int ret;
562  	pcap_t *p;
563  	if (load_airpcap_functions() != AIRPCAP_API_LOADED) {
564  		*is_ours = 0;
565  		return (NULL);
566  	}
567  	ret = device_is_airpcap(device, ebuf);
568  	if (ret == 0) {
569  		*is_ours = 0;
570  		return (NULL);
571  	}
572  	*is_ours = 1;
573  	p = PCAP_CREATE_COMMON(ebuf, struct pcap_airpcap);
574  	if (p == NULL)
575  		return (NULL);
576  	p->activate_op = airpcap_activate;
577  	p->can_set_rfmon_op = airpcap_can_set_rfmon;
578  	return (p);
579  }
580  int
581  airpcap_findalldevs(pcap_if_list_t *devlistp, char *errbuf)
582  {
583  	AirpcapDeviceDescription *airpcap_devices, *airpcap_device;
584  	char airpcap_errbuf[AIRPCAP_ERRBUF_SIZE];
585  	if (load_airpcap_functions() != AIRPCAP_API_LOADED) {
586  		return (0);
587  	}
588  	if (!p_AirpcapGetDeviceList(&airpcap_devices, airpcap_errbuf)) {
589  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
590  		    "AirpcapGetDeviceList() failed: %s", airpcap_errbuf);
591  		return (-1);
592  	}
593  	for (airpcap_device = airpcap_devices; airpcap_device != NULL;
594  	    airpcap_device = airpcap_device->next) {
595  		if (pcap_add_dev(devlistp, airpcap_device->Name, 0,
596  		    airpcap_device->Description, errbuf) == NULL) {
597  			p_AirpcapFreeDeviceList(airpcap_devices);
598  			return (-1);
599  		}
600  	}
601  	p_AirpcapFreeDeviceList(airpcap_devices);
602  	return (0);
603  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-mpi-bench.c</h3>
            <pre><code>1  #include <math.h>
2  #include <stdio.h>
3  #include <string.h>
4  #include "fftw3-mpi.h"
5  #include "tests/fftw-bench.h"
6  #if defined(BENCHFFT_SINGLE)
7  #  define BENCH_MPI_TYPE MPI_FLOAT
8  #elif defined(BENCHFFT_LDOUBLE)
9  #  define BENCH_MPI_TYPE MPI_LONG_DOUBLE
10  #elif defined(BENCHFFT_QUAD)
11  #  error MPI quad-precision type is unknown
12  #else
13  #  define BENCH_MPI_TYPE MPI_DOUBLE
14  #endif
15  #if SIZEOF_PTRDIFF_T == SIZEOF_INT
16  #  define FFTW_MPI_PTRDIFF_T MPI_INT
17  #elif SIZEOF_PTRDIFF_T == SIZEOF_LONG
18  #  define FFTW_MPI_PTRDIFF_T MPI_LONG
19  #elif SIZEOF_PTRDIFF_T == SIZEOF_LONG_LONG
20  #  define FFTW_MPI_PTRDIFF_T MPI_LONG_LONG
21  #else
22  #  error MPI type for ptrdiff_t is unknown
23  #  define FFTW_MPI_PTRDIFF_T MPI_LONG
24  #endif
25  static const char *mkversion(void) { return FFTW(version); }
26  static const char *mkcc(void) { return FFTW(cc); }
27  static const char *mkcodelet_optim(void) { return FFTW(codelet_optim); }
28  static const char *mknproc(void) {
29       static char buf[32];
30       int ncpus;
31       MPI_Comm_size(MPI_COMM_WORLD, &ncpus);
32  #ifdef HAVE_SNPRINTF
33       snprintf(buf, 32, "%d", ncpus);
34  #else
35       sprintf(buf, "%d", ncpus);
36  #endif
37       return buf;
38  }
39  BEGIN_BENCH_DOC
40  BENCH_DOC("name", "fftw3_mpi")
41  BENCH_DOCF("version", mkversion)
42  BENCH_DOCF("cc", mkcc)
43  BENCH_DOCF("codelet-optim", mkcodelet_optim)
44  BENCH_DOCF("nproc", mknproc)
45  END_BENCH_DOC 
46  static int n_pes = 1, my_pe = 0;
47  static int rnk;
48  static ptrdiff_t vn, iNtot, oNtot;
49  static ptrdiff_t *local_ni=0, *local_starti=0;
50  static ptrdiff_t *local_no=0, *local_starto=0;
51  static ptrdiff_t *all_local_ni=0, *all_local_starti=0; &bsol;* n_pes x rnk arrays */
52  static ptrdiff_t *all_local_no=0, *all_local_starto=0; &bsol;* n_pes x rnk arrays */
53  static ptrdiff_t *istrides = 0, *ostrides = 0;
54  static ptrdiff_t *total_ni=0, *total_no=0;
55  static int *isend_cnt = 0, *isend_off = 0; &bsol;* for MPI_Scatterv */
56  static int *orecv_cnt = 0, *orecv_off = 0; &bsol;* for MPI_Gatherv */
57  static bench_real *local_in = 0, *local_out = 0;
58  static bench_real *all_local_in = 0, *all_local_out = 0;
59  static int all_local_in_alloc = 0, all_local_out_alloc = 0;
60  static FFTW(plan) plan_scramble_in = 0, plan_unscramble_out = 0;
61  static void alloc_rnk(int rnk_) {
62       rnk = rnk_;
63       bench_free(local_ni);
64       if (rnk == 0)
65  	  local_ni = 0;
66       else
67  	  local_ni = (ptrdiff_t *) bench_malloc(sizeof(ptrdiff_t) * rnk
68  						* (8 + n_pes * 4));
69       local_starti = local_ni + rnk;
70       local_no = local_ni + 2 * rnk;
71       local_starto = local_ni + 3 * rnk;
72       istrides = local_ni + 4 * rnk;
73       ostrides = local_ni + 5 * rnk;
74       total_ni = local_ni + 6 * rnk;
75       total_no = local_ni + 7 * rnk;
76       all_local_ni = local_ni + 8 * rnk;
77       all_local_starti = local_ni + (8 + n_pes) * rnk;
78       all_local_no = local_ni + (8 + 2 * n_pes) * rnk;
79       all_local_starto = local_ni + (8 + 3 * n_pes) * rnk;
80  }
81  static void setup_gather_scatter(void)
82  {
83       int i, j;
84       ptrdiff_t off;
85       MPI_Gather(local_ni, rnk, FFTW_MPI_PTRDIFF_T,
86  		all_local_ni, rnk, FFTW_MPI_PTRDIFF_T,
87  		0, MPI_COMM_WORLD);
88       MPI_Bcast(all_local_ni, rnk*n_pes, FFTW_MPI_PTRDIFF_T, 0, MPI_COMM_WORLD);
89       MPI_Gather(local_starti, rnk, FFTW_MPI_PTRDIFF_T,
90  		all_local_starti, rnk, FFTW_MPI_PTRDIFF_T,
91  		0, MPI_COMM_WORLD);
92       MPI_Bcast(all_local_starti, rnk*n_pes, FFTW_MPI_PTRDIFF_T, 0, MPI_COMM_WORLD);
93       MPI_Gather(local_no, rnk, FFTW_MPI_PTRDIFF_T,
94  		all_local_no, rnk, FFTW_MPI_PTRDIFF_T,
95  		0, MPI_COMM_WORLD);
96       MPI_Bcast(all_local_no, rnk*n_pes, FFTW_MPI_PTRDIFF_T, 0, MPI_COMM_WORLD);
97       MPI_Gather(local_starto, rnk, FFTW_MPI_PTRDIFF_T,
98  		all_local_starto, rnk, FFTW_MPI_PTRDIFF_T,
99  		0, MPI_COMM_WORLD);
100       MPI_Bcast(all_local_starto, rnk*n_pes, FFTW_MPI_PTRDIFF_T, 0, MPI_COMM_WORLD);
101       off = 0;
102       for (i = 0; i < n_pes; ++i) {
103  	  ptrdiff_t N = vn;
104  	  for (j = 0; j < rnk; ++j)
105  	       N *= all_local_ni[i * rnk + j];
106  	  isend_cnt[i] = N;
107  	  isend_off[i] = off;
108  	  off += N;
109       }
110       iNtot = off;
111       all_local_in_alloc = 1;
112       istrides[rnk - 1] = vn;
113       for (j = rnk - 2; j >= 0; --j)
114  	  istrides[j] = total_ni[j + 1] * istrides[j + 1];
115       off = 0;
116       for (i = 0; i < n_pes; ++i) {
117  	  ptrdiff_t N = vn;
118  	  for (j = 0; j < rnk; ++j)
119  	       N *= all_local_no[i * rnk + j];
120  	  orecv_cnt[i] = N;
121  	  orecv_off[i] = off;
122  	  off += N;
123       }
124       oNtot = off;
125       all_local_out_alloc = 1;
126       ostrides[rnk - 1] = vn;
127       for (j = rnk - 2; j >= 0; --j)
128  	  ostrides[j] = total_no[j + 1] * ostrides[j + 1];
129  }
130  static void copy_block_out(const bench_real *in,
131  			   int rnk, ptrdiff_t *n, ptrdiff_t *start, 
132  			   ptrdiff_t is, ptrdiff_t *os, ptrdiff_t vn,
133  			   bench_real *out)
134  {
135       ptrdiff_t i;
136       if (rnk == 0) { 
137  	  for (i = 0; i < vn; ++i)
138  	       out[i] = in[i];
139       }
140       else if (rnk == 1) { &bsol;* this case is just an optimization */
141  	  ptrdiff_t j;
142  	  out += start[0] * os[0];
143  	  for (j = 0; j < n[0]; ++j) {
144  	       for (i = 0; i < vn; ++i)
145  		    out[i] = in[i];
146  	       in += is;
147  	       out += os[0];
148  	  }
149       }
150       else {
151  	  for (i = 0; i < n[rnk - 1]; ++i) 
152  	       copy_block_out(in + i * is,
153  			      rnk - 1, n, start, is * n[rnk - 1], os, vn,
154  			      out + (start[rnk - 1] + i) * os[rnk - 1]);
155       }
156  }
157  static void copy_block_in(bench_real *in,
158  			  int rnk, ptrdiff_t *n, ptrdiff_t *start, 
159  			  ptrdiff_t is, ptrdiff_t *os, ptrdiff_t vn,
160  			  const bench_real *out)
161  {
162       ptrdiff_t i;
163       if (rnk == 0) { 
164  	  for (i = 0; i < vn; ++i)
165  	       in[i] = out[i];
166       }
167       else if (rnk == 1) { &bsol;* this case is just an optimization */
168  	  ptrdiff_t j;
169  	  out += start[0] * os[0];
170  	  for (j = 0; j < n[0]; ++j) {
171  	       for (i = 0; i < vn; ++i)
172  		    in[i] = out[i];
173  	       in += is;
174  	       out += os[0];
175  	  }
176       }
177       else {
178  	  for (i = 0; i < n[rnk - 1]; ++i) 
179  	       copy_block_in(in + i * is,
180  			     rnk - 1, n, start, is * n[rnk - 1], os, vn,
181  			     out + (start[rnk - 1] + i) * os[rnk - 1]);
182       }
183  }
184  static void do_scatter_in(bench_real *in)
185  {
186       bench_real *ali;
187       int i;
188       if (all_local_in_alloc) {
189            bench_free(all_local_in);
190  	  all_local_in = (bench_real*) bench_malloc(iNtot*sizeof(bench_real));
191  	  all_local_in_alloc = 0;
192       }
193       ali = all_local_in;
194       for (i = 0; i < n_pes; ++i) {
195  	  copy_block_in(ali,
196  			rnk, all_local_ni + i * rnk, 
197  			all_local_starti + i * rnk,
198  			vn, istrides, vn,
199  			in);
200  	  ali += isend_cnt[i];
201       }
202       MPI_Scatterv(all_local_in, isend_cnt, isend_off, BENCH_MPI_TYPE,
203  		  local_in, isend_cnt[my_pe], BENCH_MPI_TYPE,
204  		  0, MPI_COMM_WORLD);
205  }
206  static void do_gather_out(bench_real *out)
207  {
208       bench_real *alo;
209       int i;
210       if (all_local_out_alloc) {
211            bench_free(all_local_out);
212  	  all_local_out = (bench_real*) bench_malloc(oNtot*sizeof(bench_real));
213  	  all_local_out_alloc = 0;
214       }
215       MPI_Gatherv(local_out, orecv_cnt[my_pe], BENCH_MPI_TYPE,
216  		 all_local_out, orecv_cnt, orecv_off, BENCH_MPI_TYPE,
217  		 0, MPI_COMM_WORLD);
218       MPI_Bcast(all_local_out, oNtot, BENCH_MPI_TYPE, 0, MPI_COMM_WORLD);
219       alo = all_local_out;
220       for (i = 0; i < n_pes; ++i) {
221  	  copy_block_out(alo,
222  			 rnk, all_local_no + i * rnk, 
223  			 all_local_starto + i * rnk,
224  			 vn, ostrides, vn,
225  			 out);
226  	  alo += orecv_cnt[i];
227       }
228  }
229  static void alloc_local(ptrdiff_t nreal, int inplace)
230  {
231       bench_free(local_in);
232       if (local_out != local_in) bench_free(local_out);
233       local_in = local_out = 0;
234       if (nreal > 0) {
235  	  ptrdiff_t i;
236  	  local_in = (bench_real*) bench_malloc(nreal * sizeof(bench_real));
237  	  if (inplace)
238  	       local_out = local_in;
239  	  else
240  	       local_out = (bench_real*) bench_malloc(nreal * sizeof(bench_real));
241  	  for (i = 0; i < nreal; ++i) local_in[i] = local_out[i] = 0.0;
242       }
243  }
244  void after_problem_rcopy_from(bench_problem *p, bench_real *ri)
245  {
246       UNUSED(p);
247       do_scatter_in(ri);
248       if (plan_scramble_in) FFTW(execute)(plan_scramble_in);
249  }
250  void after_problem_rcopy_to(bench_problem *p, bench_real *ro)
251  {
252       UNUSED(p);
253       if (plan_unscramble_out) FFTW(execute)(plan_unscramble_out);
254       do_gather_out(ro);
255  }
256  void after_problem_ccopy_from(bench_problem *p, bench_real *ri, bench_real *ii)
257  {
258       UNUSED(ii);
259       after_problem_rcopy_from(p, ri);
260  }
261  void after_problem_ccopy_to(bench_problem *p, bench_real *ro, bench_real *io)
262  {
263       UNUSED(io);
264       after_problem_rcopy_to(p, ro);
265  }
266  void after_problem_hccopy_from(bench_problem *p, bench_real *ri, bench_real *ii)
267  {
268       UNUSED(ii);
269       after_problem_rcopy_from(p, ri);
270  }
271  void after_problem_hccopy_to(bench_problem *p, bench_real *ro, bench_real *io)
272  {
273       UNUSED(io);
274       after_problem_rcopy_to(p, ro);
275  }
276  static FFTW(plan) mkplan_transpose_local(ptrdiff_t nx, ptrdiff_t ny, 
277  					 ptrdiff_t vn, 
278  					 bench_real *in, bench_real *out)
279  {
280       FFTW(iodim64) hdims[3];
281       FFTW(r2r_kind) k[3];
282       FFTW(plan) pln;
283       hdims[0].n = nx;
284       hdims[0].is = ny * vn;
285       hdims[0].os = vn;
286       hdims[1].n = ny;
287       hdims[1].is = vn;
288       hdims[1].os = nx * vn;
289       hdims[2].n = vn;
290       hdims[2].is = 1;
291       hdims[2].os = 1;
292       k[0] = k[1] = k[2] = FFTW_R2HC;
293       pln = FFTW(plan_guru64_r2r)(0, 0, 3, hdims, in, out, k, FFTW_ESTIMATE);
294       BENCH_ASSERT(pln != 0);
295       return pln;
296  }
297  static int tensor_rowmajor_transposedp(bench_tensor *t)
298  {
299       bench_iodim *d;
300       int i;
301       BENCH_ASSERT(BENCH_FINITE_RNK(t->rnk));
302       if (t->rnk < 2)
303  	  return 0;
304       d = t->dims;
305       if (d[0].is != d[1].is * d[1].n
306  	 || d[0].os != d[1].is
307  	 || d[1].os != d[0].os * d[0].n)
308  	  return 0;
309       if (t->rnk > 2 && d[1].is != d[2].is * d[2].n)
310  	  return 0;
311       for (i = 2; i + 1 < t->rnk; ++i) {
312            d = t->dims + i;
313            if (d[0].is != d[1].is * d[1].n
314  	      || d[0].os != d[1].os * d[1].n)
315                 return 0;
316       }
317       if (t->rnk > 2 && t->dims[t->rnk-1].is != t->dims[t->rnk-1].os)
318  	  return 0;
319       return 1;
320  }
321  static int tensor_contiguousp(bench_tensor *t, int s)
322  {
323       return (t->dims[t->rnk-1].is == s
324  	     && ((tensor_rowmajorp(t) && 
325  		  t->dims[t->rnk-1].is == t->dims[t->rnk-1].os)
326  		 || tensor_rowmajor_transposedp(t)));
327  }
328  static FFTW(plan) mkplan_complex(bench_problem *p, unsigned flags)
329  {
330       FFTW(plan) pln = 0;
331       int i; 
332       ptrdiff_t ntot;
333       vn = p->vecsz->rnk == 1 ? p->vecsz->dims[0].n : 1;
334       if (p->sz->rnk < 1
335  	 || p->split
336  	 || !tensor_contiguousp(p->sz, vn)
337  	 || tensor_rowmajor_transposedp(p->sz)
338  	 || p->vecsz->rnk > 1
339  	 || (p->vecsz->rnk == 1 && (p->vecsz->dims[0].is != 1
340  				    || p->vecsz->dims[0].os != 1)))
341  	  return 0;
342       alloc_rnk(p->sz->rnk);
343       for (i = 0; i < rnk; ++i) {
344  	  total_ni[i] = total_no[i] = p->sz->dims[i].n;
345  	  local_ni[i] = local_no[i] = total_ni[i];
346  	  local_starti[i] = local_starto[i] = 0;
347       }
348       if (rnk > 1) {
349  	  ptrdiff_t n, start, nT, startT;
350  	  ntot = FFTW(mpi_local_size_many_transposed)
351  	       (p->sz->rnk, total_ni, vn,
352  		FFTW_MPI_DEFAULT_BLOCK, FFTW_MPI_DEFAULT_BLOCK,
353  		MPI_COMM_WORLD,
354  		&n, &start, &nT, &startT);
355  	  if  (flags & FFTW_MPI_TRANSPOSED_IN) {
356  	       local_ni[1] = nT;
357  	       local_starti[1] = startT;
358  	  }
359  	  else {
360  	       local_ni[0] = n;
361  	       local_starti[0] = start;
362  	  }
363  	  if  (flags & FFTW_MPI_TRANSPOSED_OUT) {
364  	       local_no[1] = nT;
365  	       local_starto[1] = startT;
366  	  }
367  	  else {
368  	       local_no[0] = n;
369  	       local_starto[0] = start;
370  	  }
371       }
372       else if (rnk == 1) {
373  	  ntot = FFTW(mpi_local_size_many_1d)
374  	       (total_ni[0], vn, MPI_COMM_WORLD, p->sign, flags,
375  		local_ni, local_starti, local_no, local_starto);
376       }
377       alloc_local(ntot * 2, p->in == p->out);
378       pln = FFTW(mpi_plan_many_dft)(p->sz->rnk, total_ni, vn, 
379  				   FFTW_MPI_DEFAULT_BLOCK,
380  				   FFTW_MPI_DEFAULT_BLOCK,
381  				   (FFTW(complex) *) local_in, 
382  				   (FFTW(complex) *) local_out,
383  				   MPI_COMM_WORLD, p->sign, flags);
384       vn *= 2;
385       if (rnk > 1) {
386  	  ptrdiff_t nrest = 1;
387  	  for (i = 2; i < rnk; ++i) nrest *= p->sz->dims[i].n;
388  	  if (flags & FFTW_MPI_TRANSPOSED_IN)
389  	       plan_scramble_in = mkplan_transpose_local(
390  		    p->sz->dims[0].n, local_ni[1], vn * nrest,
391  		    local_in, local_in);
392  	  if (flags & FFTW_MPI_TRANSPOSED_OUT)
393  	       plan_unscramble_out = mkplan_transpose_local(
394  		    local_no[1], p->sz->dims[0].n, vn * nrest,
395  		    local_out, local_out);
396       }
397       return pln;
398  }
399  static int tensor_real_contiguousp(bench_tensor *t, int sign, int s)
400  {
401       return (t->dims[t->rnk-1].is == s
402  	     && ((tensor_real_rowmajorp(t, sign, 1) && 
403  		  t->dims[t->rnk-1].is == t->dims[t->rnk-1].os)));
404  }
405  static FFTW(plan) mkplan_real(bench_problem *p, unsigned flags)
406  {
407       FFTW(plan) pln = 0;
408       int i; 
409       ptrdiff_t ntot;
410       vn = p->vecsz->rnk == 1 ? p->vecsz->dims[0].n : 1;
411       if (p->sz->rnk < 2
412  	 || p->split
413  	 || !tensor_real_contiguousp(p->sz, p->sign, vn)
414  	 || tensor_rowmajor_transposedp(p->sz)
415  	 || p->vecsz->rnk > 1
416  	 || (p->vecsz->rnk == 1 && (p->vecsz->dims[0].is != 1
417  				    || p->vecsz->dims[0].os != 1)))
418  	  return 0;
419       alloc_rnk(p->sz->rnk);
420       for (i = 0; i < rnk; ++i) {
421  	  total_ni[i] = total_no[i] = p->sz->dims[i].n;
422  	  local_ni[i] = local_no[i] = total_ni[i];
423  	  local_starti[i] = local_starto[i] = 0;
424       }
425       local_ni[rnk-1] = local_no[rnk-1] = total_ni[rnk-1] = total_no[rnk-1] 
426  	  = p->sz->dims[rnk-1].n / 2 + 1;
427       {
428  	  ptrdiff_t n, start, nT, startT;
429  	  ntot = FFTW(mpi_local_size_many_transposed)
430  	       (p->sz->rnk, total_ni, vn,
431  		FFTW_MPI_DEFAULT_BLOCK, FFTW_MPI_DEFAULT_BLOCK,
432  		MPI_COMM_WORLD,
433  		&n, &start, &nT, &startT);
434  	  if  (flags & FFTW_MPI_TRANSPOSED_IN) {
435  	       local_ni[1] = nT;
436  	       local_starti[1] = startT;
437  	  }
438  	  else {
439  	       local_ni[0] = n;
440  	       local_starti[0] = start;
441  	  }
442  	  if  (flags & FFTW_MPI_TRANSPOSED_OUT) {
443  	       local_no[1] = nT;
444  	       local_starto[1] = startT;
445  	  }
446  	  else {
447  	       local_no[0] = n;
448  	       local_starto[0] = start;
449  	  }
450       }
451       alloc_local(ntot * 2, p->in == p->out);
452       total_ni[rnk - 1] = p->sz->dims[rnk - 1].n;
453       if (p->sign < 0)
454  	  pln = FFTW(mpi_plan_many_dft_r2c)(p->sz->rnk, total_ni, vn, 
455  					    FFTW_MPI_DEFAULT_BLOCK,
456  					    FFTW_MPI_DEFAULT_BLOCK,
457  					    local_in, 
458  					    (FFTW(complex) *) local_out,
459  					    MPI_COMM_WORLD, flags);
460       else
461  	  pln = FFTW(mpi_plan_many_dft_c2r)(p->sz->rnk, total_ni, vn, 
462  					    FFTW_MPI_DEFAULT_BLOCK,
463  					    FFTW_MPI_DEFAULT_BLOCK,
464  					    (FFTW(complex) *) local_in, 
465  					    local_out,
466  					    MPI_COMM_WORLD, flags);
467       total_ni[rnk - 1] = p->sz->dims[rnk - 1].n / 2 + 1;
468       vn *= 2;
469       {
470  	  ptrdiff_t nrest = 1;
471  	  for (i = 2; i < rnk; ++i) nrest *= total_ni[i];
472  	  if (flags & FFTW_MPI_TRANSPOSED_IN)
473  	       plan_scramble_in = mkplan_transpose_local(
474  		    total_ni[0], local_ni[1], vn * nrest,
475  		    local_in, local_in);
476  	  if (flags & FFTW_MPI_TRANSPOSED_OUT)
477  	       plan_unscramble_out = mkplan_transpose_local(
478  		    local_no[1], total_ni[0], vn * nrest,
479  		    local_out, local_out);
480       }
481       return pln;
482  }
483  static FFTW(plan) mkplan_transpose(bench_problem *p, unsigned flags)
484  {
485       ptrdiff_t ntot, nx, ny;
486       int ix=0, iy=1, i;
487       const bench_iodim *d = p->vecsz->dims;
488       FFTW(plan) pln;
489       if (p->vecsz->rnk == 3) {
490  	  for (i = 0; i < 3; ++i)
491  	       if (d[i].is == 1 && d[i].os == 1) {
492  		    vn = d[i].n;
493  		    ix = (i + 1) % 3;
494  		    iy = (i + 2) % 3;
495  		    break;
496  	       }
497  	  if (i == 3) return 0;
498       }
499       else {
500  	  vn = 1;
501  	  ix = 0;
502  	  iy = 1;
503       }
504       if (d[ix].is == d[iy].n * vn && d[ix].os == vn
505  	 && d[iy].os == d[ix].n * vn && d[iy].is == vn) {
506  	  nx = d[ix].n;
507  	  ny = d[iy].n;
508       }
509       else if (d[iy].is == d[ix].n * vn && d[iy].os == vn
510  	      && d[ix].os == d[iy].n * vn && d[ix].is == vn) {
511  	  nx = d[iy].n;
512  	  ny = d[ix].n;
513       }
514       else
515  	  return 0;
516       alloc_rnk(2);
<span onclick='openModal()' class='match'>517       ntot = vn * FFTW(mpi_local_size_2d_transposed)(nx, ny, MPI_COMM_WORLD,
518  						    &local_ni[0], 
519  						    &local_starti[0],
520  						    &local_no[0], 
521  						    &local_starto[0]);
522       local_ni[1] = ny;
523       local_starti[1] = 0;
524       local_no[1] = nx;
525       local_starto[1] = 0;
526       total_ni[0] = nx; total_ni[1] = ny;
527       total_no[1] = nx; total_no[0] = ny;
</span>528       alloc_local(ntot, p->in == p->out);
529       pln = FFTW(mpi_plan_many_transpose)(nx, ny, vn,
530  					 FFTW_MPI_DEFAULT_BLOCK,
531  					 FFTW_MPI_DEFAULT_BLOCK,
532  					 local_in, local_out,
533  					 MPI_COMM_WORLD, flags);
534       if (flags & FFTW_MPI_TRANSPOSED_IN)
535  	  plan_scramble_in = mkplan_transpose_local(local_ni[0], ny, vn,
536  						    local_in, local_in);
537       if (flags & FFTW_MPI_TRANSPOSED_OUT)
538  	  plan_unscramble_out = mkplan_transpose_local
539  	       (nx, local_no[0], vn, local_out, local_out);
540  #if 0
541       if (pln && vn == 1) {
542  	  int i, j;
543  	  bench_real *ri = (bench_real *) p->in;
544  	  bench_real *ro = (bench_real *) p->out;
545  	  if (!ri || !ro) return pln;
546  	  setup_gather_scatter();
547  	  for (i = 0; i < nx * ny; ++i)
548  	       ri[i] = i;
549  	  after_problem_rcopy_from(p, ri);
550  	  FFTW(execute)(pln);
551  	  after_problem_rcopy_to(p, ro);
552  	  if (my_pe == 0) {
553  	       for (i = 0; i < nx; ++i) {
554  		    for (j = 0; j < ny; ++j)
555  			 printf("  %3g", ro[j * nx + i]);
556  		    printf("\n");
557  	       }
558  	  }
559       }
560  #endif
561       return pln;
562  }
563  static FFTW(plan) mkplan_r2r(bench_problem *p, unsigned flags)
564  {
565       FFTW(plan) pln = 0;
566       int i; 
567       ptrdiff_t ntot;
568       FFTW(r2r_kind) *k;
569       if ((p->sz->rnk == 0 || (p->sz->rnk == 1 && p->sz->dims[0].n == 1))
570  	 && p->vecsz->rnk >= 2 && p->vecsz->rnk <= 3)
571  	  return mkplan_transpose(p, flags);
572       vn = p->vecsz->rnk == 1 ? p->vecsz->dims[0].n : 1;
573       if (p->sz->rnk < 1
574  	 || p->split
575  	 || !tensor_contiguousp(p->sz, vn)
576  	 || tensor_rowmajor_transposedp(p->sz)
577  	 || p->vecsz->rnk > 1
578  	 || (p->vecsz->rnk == 1 && (p->vecsz->dims[0].is != 1
579  				    || p->vecsz->dims[0].os != 1)))
580  	  return 0;
581       alloc_rnk(p->sz->rnk);
582       for (i = 0; i < rnk; ++i) {
583  	  total_ni[i] = total_no[i] = p->sz->dims[i].n;
584  	  local_ni[i] = local_no[i] = total_ni[i];
585  	  local_starti[i] = local_starto[i] = 0;
586       }
587       if (rnk > 1) {
588  	  ptrdiff_t n, start, nT, startT;
589  	  ntot = FFTW(mpi_local_size_many_transposed)
590  	       (p->sz->rnk, total_ni, vn,
591  		FFTW_MPI_DEFAULT_BLOCK, FFTW_MPI_DEFAULT_BLOCK,
592  		MPI_COMM_WORLD,
593  		&n, &start, &nT, &startT);
594  	  if  (flags & FFTW_MPI_TRANSPOSED_IN) {
595  	       local_ni[1] = nT;
596  	       local_starti[1] = startT;
597  	  }
598  	  else {
599  	       local_ni[0] = n;
600  	       local_starti[0] = start;
601  	  }
602  	  if  (flags & FFTW_MPI_TRANSPOSED_OUT) {
603  	       local_no[1] = nT;
604  	       local_starto[1] = startT;
605  	  }
606  	  else {
607  	       local_no[0] = n;
608  	       local_starto[0] = start;
609  	  }
610       }
611       else if (rnk == 1) {
612  	  ntot = FFTW(mpi_local_size_many_1d)
613  	       (total_ni[0], vn, MPI_COMM_WORLD, p->sign, flags,
614  		local_ni, local_starti, local_no, local_starto);
615       }
616       alloc_local(ntot, p->in == p->out);
617       k = (FFTW(r2r_kind) *) bench_malloc(sizeof(FFTW(r2r_kind)) * p->sz->rnk);
618       for (i = 0; i < p->sz->rnk; ++i)
619  	  switch (p->k[i]) {
620  	      case R2R_R2HC: k[i] = FFTW_R2HC; break;
621  	      case R2R_HC2R: k[i] = FFTW_HC2R; break;
622  	      case R2R_DHT: k[i] = FFTW_DHT; break;
623  	      case R2R_REDFT00: k[i] = FFTW_REDFT00; break;
624  	      case R2R_REDFT01: k[i] = FFTW_REDFT01; break;
625  	      case R2R_REDFT10: k[i] = FFTW_REDFT10; break;
626  	      case R2R_REDFT11: k[i] = FFTW_REDFT11; break;
627  	      case R2R_RODFT00: k[i] = FFTW_RODFT00; break;
628  	      case R2R_RODFT01: k[i] = FFTW_RODFT01; break;
629  	      case R2R_RODFT10: k[i] = FFTW_RODFT10; break;
630  	      case R2R_RODFT11: k[i] = FFTW_RODFT11; break;
631  	      default: BENCH_ASSERT(0);
632  	  }
633       pln = FFTW(mpi_plan_many_r2r)(p->sz->rnk, total_ni, vn, 
634  				   FFTW_MPI_DEFAULT_BLOCK,
635  				   FFTW_MPI_DEFAULT_BLOCK,
636  				   local_in, local_out,
637  				   MPI_COMM_WORLD, k, flags);
638       bench_free(k);
639       if (rnk > 1) {
640  	  ptrdiff_t nrest = 1;
641  	  for (i = 2; i < rnk; ++i) nrest *= p->sz->dims[i].n;
642  	  if (flags & FFTW_MPI_TRANSPOSED_IN)
643  	       plan_scramble_in = mkplan_transpose_local(
644  		    p->sz->dims[0].n, local_ni[1], vn * nrest,
645  		    local_in, local_in);
646  	  if (flags & FFTW_MPI_TRANSPOSED_OUT)
647  	       plan_unscramble_out = mkplan_transpose_local(
648  		    local_no[1], p->sz->dims[0].n, vn * nrest,
649  		    local_out, local_out);
650       }
651       return pln;
652  }
653  FFTW(plan) mkplan(bench_problem *p, unsigned flags)
654  {
655       FFTW(plan) pln = 0;
656       FFTW(destroy_plan)(plan_scramble_in); plan_scramble_in = 0;
657       FFTW(destroy_plan)(plan_unscramble_out); plan_unscramble_out = 0;
658       if (p->scrambled_in) {
659  	  if (p->sz->rnk == 1 && p->sz->dims[0].n != 1) 
660  	       flags |= FFTW_MPI_SCRAMBLED_IN;
661  	  else
662  	       flags |= FFTW_MPI_TRANSPOSED_IN;
663       }
664       if (p->scrambled_out) {
665  	  if (p->sz->rnk == 1 && p->sz->dims[0].n != 1) 
666  	       flags |= FFTW_MPI_SCRAMBLED_OUT;
667  	  else
668  	       flags |= FFTW_MPI_TRANSPOSED_OUT;
669       }
670       switch (p->kind) {
671           case PROBLEM_COMPLEX: 
672  	      pln =mkplan_complex(p, flags);
673  	      break;
674           case PROBLEM_REAL: 
675  	      pln = mkplan_real(p, flags);
676  	      break;
677           case PROBLEM_R2R:
678  	      pln = mkplan_r2r(p, flags);
679  	      break;
680           default: BENCH_ASSERT(0);
681       }
682       if (pln) setup_gather_scatter();
683       return pln;
684  }
685  void main_init(int *argc, char ***argv)
686  {
687  #ifdef HAVE_SMP
688  # if MPI_VERSION >= 2 &bsol;* for MPI_Init_thread */
689       int provided;
690       MPI_Init_thread(argc, argv, MPI_THREAD_FUNNELED, &provided);
691       threads_ok = provided >= MPI_THREAD_FUNNELED;
692  # else
693       MPI_Init(argc, argv);
694       threads_ok = 0;
695  # endif
696  #else
697       MPI_Init(argc, argv);
698  #endif
699       MPI_Comm_rank(MPI_COMM_WORLD, &my_pe);
700       MPI_Comm_size(MPI_COMM_WORLD, &n_pes);
701       if (my_pe != 0) verbose = -999;
702       no_speed_allocation = 1; &bsol;* so we can benchmark transforms > memory */
703       always_pad_real = 1; &bsol;* out-of-place real transforms are padded */
704       isend_cnt = (int *) bench_malloc(sizeof(int) * n_pes);
705       isend_off = (int *) bench_malloc(sizeof(int) * n_pes);
706       orecv_cnt = (int *) bench_malloc(sizeof(int) * n_pes);
707       orecv_off = (int *) bench_malloc(sizeof(int) * n_pes);
708  #ifdef HAVE_SMP
709       if (threads_ok) { BENCH_ASSERT(FFTW(init_threads)()); }
710  #endif
711       FFTW(mpi_init)();
712  }
713  void initial_cleanup(void)
714  {
715       alloc_rnk(0);
716       alloc_local(0, 0);
717       bench_free(all_local_in); all_local_in = 0;
718       bench_free(all_local_out); all_local_out = 0;
719       bench_free(isend_off); isend_off = 0;
720       bench_free(isend_cnt); isend_cnt = 0;
721       bench_free(orecv_off); orecv_off = 0;
722       bench_free(orecv_cnt); orecv_cnt = 0;
723       FFTW(destroy_plan)(plan_scramble_in); plan_scramble_in = 0;
724       FFTW(destroy_plan)(plan_unscramble_out); plan_unscramble_out = 0;
725  }
726  void final_cleanup(void)
727  {
728       MPI_Finalize();
729  }
730  void bench_exit(int status)
731  {
732       MPI_Abort(MPI_COMM_WORLD, status);
733  }
734  double bench_cost_postprocess(double cost)
735  {
736       double cost_max;
737       MPI_Allreduce(&cost, &cost_max, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
738       return cost_max;
739  }
740  int import_wisdom(FILE *f)
741  {
742       int success = 1, sall;
743       if (my_pe == 0) success = FFTW(import_wisdom_from_file)(f);
744       FFTW(mpi_broadcast_wisdom)(MPI_COMM_WORLD);
745       MPI_Allreduce(&success, &sall, 1, MPI_INT, MPI_LAND, MPI_COMM_WORLD);
746       return sall;
747  }
748  void export_wisdom(FILE *f)
749  {
750       FFTW(mpi_gather_wisdom)(MPI_COMM_WORLD);
751       if (my_pe == 0) FFTW(export_wisdom_to_file)(f);
752  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-airpcap.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-mpi-bench.c</div>
                </div>
                <div class="column column_space"><pre><code>513  	p->dlt_list[0] = DLT_IEEE802_11_RADIO;
514  	p->dlt_list[1] = DLT_PPI;
515  	p->dlt_list[2] = DLT_IEEE802_11;
516  	p->dlt_count = 3;
517  	p->read_op = airpcap_read;
518  	p->inject_op = airpcap_inject;
519  	p->setfilter_op = airpcap_setfilter;
520  	p->setdirection_op = NULL;	&bsol;* Not implemented. */
</pre></code></div>
                <div class="column column_space"><pre><code>517       ntot = vn * FFTW(mpi_local_size_2d_transposed)(nx, ny, MPI_COMM_WORLD,
518  						    &local_ni[0], 
519  						    &local_starti[0],
520  						    &local_no[0], 
521  						    &local_starto[0]);
522       local_ni[1] = ny;
523       local_starti[1] = 0;
524       local_no[1] = nx;
525       local_starto[1] = 0;
526       total_ni[0] = nx; total_ni[1] = ny;
527       total_no[1] = nx; total_no[0] = ny;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    