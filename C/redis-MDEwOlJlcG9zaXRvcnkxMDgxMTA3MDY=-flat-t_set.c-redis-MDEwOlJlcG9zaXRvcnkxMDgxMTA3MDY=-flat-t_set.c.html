
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-t_set.c</h3>
            <pre><code>1  #include "server.h"
2  void sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,
3                                robj *dstkey, int op);
4  robj *setTypeCreate(sds value) {
5      if (isSdsRepresentableAsLongLong(value,NULL) == C_OK)
6          return createIntsetObject();
7      return createSetObject();
8  }
9  int setTypeAdd(robj *subject, sds value) {
10      PORT_LONGLONG llval;
11      if (subject->encoding == OBJ_ENCODING_HT) {
12          dict *ht = subject->ptr;
13          dictEntry *de = dictAddRaw(ht,value,NULL);
14          if (de) {
15              dictSetKey(ht,de,sdsdup(value));
16              dictSetVal(ht,de,NULL);
17              return 1;
18          }
19      } else if (subject->encoding == OBJ_ENCODING_INTSET) {
20          if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {
21              uint8_t success = 0;
<span onclick='openModal()' class='match'>22              subject->ptr = intsetAdd(subject->ptr,llval,&success);
23              if (success) {
</span>24                  if (intsetLen(subject->ptr) > server.set_max_intset_entries)
25                      setTypeConvert(subject,OBJ_ENCODING_HT);
26                  return 1;
27              }
28          } else {
29              setTypeConvert(subject,OBJ_ENCODING_HT);
30              serverAssert(dictAdd(subject->ptr,sdsdup(value),NULL) == DICT_OK);
31              return 1;
32          }
33      } else {
34          serverPanic("Unknown set encoding");
35      }
36      return 0;
37  }
38  int setTypeRemove(robj *setobj, sds value) {
39      PORT_LONGLONG llval;
40      if (setobj->encoding == OBJ_ENCODING_HT) {
41          if (dictDelete(setobj->ptr,value) == DICT_OK) {
42              if (htNeedsResize(setobj->ptr)) dictResize(setobj->ptr);
43              return 1;
44          }
45      } else if (setobj->encoding == OBJ_ENCODING_INTSET) {
46          if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {
47              int success;
48              setobj->ptr = intsetRemove(setobj->ptr,llval,&success);
49              if (success) return 1;
50          }
51      } else {
52          serverPanic("Unknown set encoding");
53      }
54      return 0;
55  }
56  int setTypeIsMember(robj *subject, sds value) {
57      PORT_LONGLONG llval;
58      if (subject->encoding == OBJ_ENCODING_HT) {
59          return dictFind((dict*)subject->ptr,value) != NULL;
60      } else if (subject->encoding == OBJ_ENCODING_INTSET) {
61          if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {
62              return intsetFind((intset*)subject->ptr,llval);
63          }
64      } else {
65          serverPanic("Unknown set encoding");
66      }
67      return 0;
68  }
69  setTypeIterator *setTypeInitIterator(robj *subject) {
70      setTypeIterator *si = zmalloc(sizeof(setTypeIterator));
71      si->subject = subject;
72      si->encoding = subject->encoding;
73      if (si->encoding == OBJ_ENCODING_HT) {
74          si->di = dictGetIterator(subject->ptr);
75      } else if (si->encoding == OBJ_ENCODING_INTSET) {
76          si->ii = 0;
77      } else {
78          serverPanic("Unknown set encoding");
79      }
80      return si;
81  }
82  void setTypeReleaseIterator(setTypeIterator *si) {
83      if (si->encoding == OBJ_ENCODING_HT)
84          dictReleaseIterator(si->di);
85      zfree(si);
86  }
87  int setTypeNext(setTypeIterator *si, sds *sdsele, int64_t *llele) {
88      if (si->encoding == OBJ_ENCODING_HT) {
89          dictEntry *de = dictNext(si->di);
90          if (de == NULL) return -1;
91          *sdsele = dictGetKey(de);
92          *llele = -123456789; &bsol;* Not needed. Defensive. */
93      } else if (si->encoding == OBJ_ENCODING_INTSET) {
94          if (!intsetGet(si->subject->ptr,si->ii++,llele))
95              return -1;
96          *sdsele = NULL; &bsol;* Not needed. Defensive. */
97      } else {
98          serverPanic("Wrong set encoding in setTypeNext");
99      }
100      return si->encoding;
101  }
102  sds setTypeNextObject(setTypeIterator *si) {
103      int64_t intele;
104      sds sdsele;
105      int encoding;
106      encoding = setTypeNext(si,&sdsele,&intele);
107      switch(encoding) {
108          case -1:    return NULL;
109          case OBJ_ENCODING_INTSET:
110              return sdsfromlonglong(intele);
111          case OBJ_ENCODING_HT:
112              return sdsdup(sdsele);
113          default:
114              serverPanic("Unsupported encoding");
115      }
116      return NULL; &bsol;* just to suppress warnings */
117  }
118  int setTypeRandomElement(robj *setobj, sds *sdsele, int64_t *llele) {
119      if (setobj->encoding == OBJ_ENCODING_HT) {
120          dictEntry *de = dictGetRandomKey(setobj->ptr);
121          *sdsele = dictGetKey(de);
122          *llele = -123456789; &bsol;* Not needed. Defensive. */
123      } else if (setobj->encoding == OBJ_ENCODING_INTSET) {
124          *llele = intsetRandom(setobj->ptr);
125          *sdsele = NULL; &bsol;* Not needed. Defensive. */
126      } else {
127          serverPanic("Unknown set encoding");
128      }
129      return setobj->encoding;
130  }
131  PORT_ULONG setTypeSize(const robj *subject) {
132      if (subject->encoding == OBJ_ENCODING_HT) {
133          return (PORT_ULONG) dictSize((const dict*)subject->ptr);                     WIN_PORT_FIX &bsol;* cast (PORT_ULONG) */
134      } else if (subject->encoding == OBJ_ENCODING_INTSET) {
135          return intsetLen((const intset*)subject->ptr);
136      } else {
137          serverPanic("Unknown set encoding");
138      }
139  }
140  void setTypeConvert(robj *setobj, int enc) {
141      setTypeIterator *si;
142      serverAssertWithInfo(NULL,setobj,setobj->type == OBJ_SET &&
143                               setobj->encoding == OBJ_ENCODING_INTSET);
144      if (enc == OBJ_ENCODING_HT) {
145          int64_t intele;
146          dict *d = dictCreate(&setDictType,NULL);
147          sds element;
148          dictExpand(d,intsetLen(setobj->ptr));
149          si = setTypeInitIterator(setobj);
150          while (setTypeNext(si,&element,&intele) != -1) {
151              element = sdsfromlonglong(intele);
152              serverAssert(dictAdd(d,element,NULL) == DICT_OK);
153          }
154          setTypeReleaseIterator(si);
155          setobj->encoding = OBJ_ENCODING_HT;
156          zfree(setobj->ptr);
157          setobj->ptr = d;
158      } else {
159          serverPanic("Unsupported set conversion");
160      }
161  }
162  void saddCommand(client *c) {
163      robj *set;
164      int j, added = 0;
165      set = lookupKeyWrite(c->db,c->argv[1]);
166      if (set == NULL) {
167          set = setTypeCreate(c->argv[2]->ptr);
168          dbAdd(c->db,c->argv[1],set);
169      } else {
170          if (set->type != OBJ_SET) {
171              addReply(c,shared.wrongtypeerr);
172              return;
173          }
174      }
175      for (j = 2; j < c->argc; j++) {
176          if (setTypeAdd(set,c->argv[j]->ptr)) added++;
177      }
178      if (added) {
179          signalModifiedKey(c->db,c->argv[1]);
180          notifyKeyspaceEvent(NOTIFY_SET,"sadd",c->argv[1],c->db->id);
181      }
182      server.dirty += added;
183      addReplyLongLong(c,added);
184  }
185  void sremCommand(client *c) {
186      robj *set;
187      int j, deleted = 0, keyremoved = 0;
188      if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
189          checkType(c,set,OBJ_SET)) return;
190      for (j = 2; j < c->argc; j++) {
191          if (setTypeRemove(set,c->argv[j]->ptr)) {
192              deleted++;
193              if (setTypeSize(set) == 0) {
194                  dbDelete(c->db,c->argv[1]);
195                  keyremoved = 1;
196                  break;
197              }
198          }
199      }
200      if (deleted) {
201          signalModifiedKey(c->db,c->argv[1]);
202          notifyKeyspaceEvent(NOTIFY_SET,"srem",c->argv[1],c->db->id);
203          if (keyremoved)
204              notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],
205                                  c->db->id);
206          server.dirty += deleted;
207      }
208      addReplyLongLong(c,deleted);
209  }
210  void smoveCommand(client *c) {
211      robj *srcset, *dstset, *ele;
212      srcset = lookupKeyWrite(c->db,c->argv[1]);
213      dstset = lookupKeyWrite(c->db,c->argv[2]);
214      ele = c->argv[3];
215      if (srcset == NULL) {
216          addReply(c,shared.czero);
217          return;
218      }
219      if (checkType(c,srcset,OBJ_SET) ||
220          (dstset && checkType(c,dstset,OBJ_SET))) return;
221      if (srcset == dstset) {
222          addReply(c,setTypeIsMember(srcset,ele->ptr) ?
223              shared.cone : shared.czero);
224          return;
225      }
226      if (!setTypeRemove(srcset,ele->ptr)) {
227          addReply(c,shared.czero);
228          return;
229      }
230      notifyKeyspaceEvent(NOTIFY_SET,"srem",c->argv[1],c->db->id);
231      if (setTypeSize(srcset) == 0) {
232          dbDelete(c->db,c->argv[1]);
233          notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
234      }
235      if (!dstset) {
236          dstset = setTypeCreate(ele->ptr);
237          dbAdd(c->db,c->argv[2],dstset);
238      }
239      signalModifiedKey(c->db,c->argv[1]);
240      signalModifiedKey(c->db,c->argv[2]);
241      server.dirty++;
242      if (setTypeAdd(dstset,ele->ptr)) {
243          server.dirty++;
244          notifyKeyspaceEvent(NOTIFY_SET,"sadd",c->argv[2],c->db->id);
245      }
246      addReply(c,shared.cone);
247  }
248  void sismemberCommand(client *c) {
249      robj *set;
250      if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
251          checkType(c,set,OBJ_SET)) return;
252      if (setTypeIsMember(set,c->argv[2]->ptr))
253          addReply(c,shared.cone);
254      else
255          addReply(c,shared.czero);
256  }
257  void scardCommand(client *c) {
258      robj *o;
259      if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
260          checkType(c,o,OBJ_SET)) return;
261      addReplyLongLong(c,setTypeSize(o));
262  }
263  #define SPOP_MOVE_STRATEGY_MUL 5
264  void spopWithCountCommand(client *c) {
265      PORT_LONG l;
266      PORT_ULONG count, size;
267      robj *set;
268      if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;
269      if (l >= 0) {
270          count = (PORT_ULONG) l;
271      } else {
272          addReply(c,shared.outofrangeerr);
273          return;
274      }
275      if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk))
276          == NULL || checkType(c,set,OBJ_SET)) return;
277      if (count == 0) {
278          addReply(c,shared.emptymultibulk);
279          return;
280      }
281      size = setTypeSize(set);
282      notifyKeyspaceEvent(NOTIFY_SET,"spop",c->argv[1],c->db->id);
283      server.dirty += count;
284      if (count >= size) {
285          sunionDiffGenericCommand(c,c->argv+1,1,NULL,SET_OP_UNION);
286          dbDelete(c->db,c->argv[1]);
287          notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
288          rewriteClientCommandVector(c,2,shared.del,c->argv[1]);
289          signalModifiedKey(c->db,c->argv[1]);
290          server.dirty++;
291          return;
292      }
293      robj *propargv[3];
294      propargv[0] = createStringObject("SREM",4);
295      propargv[1] = c->argv[1];
296      addReplyMultiBulkLen(c,count);
297      sds sdsele;
298      robj *objele;
299      int encoding;
300      int64_t llele;
301      PORT_ULONG remaining = size-count; &bsol;* Elements left after SPOP. */
302      if (remaining*SPOP_MOVE_STRATEGY_MUL > count) {
303          while(count--) {
304              encoding = setTypeRandomElement(set,&sdsele,&llele);
305              if (encoding == OBJ_ENCODING_INTSET) {
306                  addReplyBulkLongLong(c,llele);
307                  objele = createStringObjectFromLongLong(llele);
308                  set->ptr = intsetRemove(set->ptr,llele,NULL);
309              } else {
310                  addReplyBulkCBuffer(c,sdsele,sdslen(sdsele));
311                  objele = createStringObject(sdsele,sdslen(sdsele));
312                  setTypeRemove(set,sdsele);
313              }
314              propargv[2] = objele;
315              alsoPropagate(server.sremCommand,c->db->id,propargv,3,
316                  PROPAGATE_AOF|PROPAGATE_REPL);
317              decrRefCount(objele);
318          }
319      } else {
320          robj *newset = NULL;
321          while(remaining--) {
322              encoding = setTypeRandomElement(set,&sdsele,&llele);
323              if (encoding == OBJ_ENCODING_INTSET) {
324                  sdsele = sdsfromlonglong(llele);
325              } else {
326                  sdsele = sdsdup(sdsele);
327              }
328              if (!newset) newset = setTypeCreate(sdsele);
329              setTypeAdd(newset,sdsele);
330              setTypeRemove(set,sdsele);
331              sdsfree(sdsele);
332          }
333          setTypeIterator *si;
334          si = setTypeInitIterator(set);
335          while((encoding = setTypeNext(si,&sdsele,&llele)) != -1) {
336              if (encoding == OBJ_ENCODING_INTSET) {
337                  addReplyBulkLongLong(c,llele);
338                  objele = createStringObjectFromLongLong(llele);
339              } else {
340                  addReplyBulkCBuffer(c,sdsele,sdslen(sdsele));
341                  objele = createStringObject(sdsele,sdslen(sdsele));
342              }
343              propargv[2] = objele;
344              alsoPropagate(server.sremCommand,c->db->id,propargv,3,
345                  PROPAGATE_AOF|PROPAGATE_REPL);
346              decrRefCount(objele);
347          }
348          setTypeReleaseIterator(si);
349          dbOverwrite(c->db,c->argv[1],newset);
350      }
351      decrRefCount(propargv[0]);
352      preventCommandPropagation(c);
353      signalModifiedKey(c->db,c->argv[1]);
354      server.dirty++;
355  }
356  void spopCommand(client *c) {
357      robj *set, *ele, *aux;
358      sds sdsele;
359      int64_t llele;
360      int encoding;
361      if (c->argc == 3) {
362          spopWithCountCommand(c);
363          return;
364      } else if (c->argc > 3) {
365          addReply(c,shared.syntaxerr);
366          return;
367      }
368      if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
369          checkType(c,set,OBJ_SET)) return;
370      encoding = setTypeRandomElement(set,&sdsele,&llele);
371      if (encoding == OBJ_ENCODING_INTSET) {
372          ele = createStringObjectFromLongLong(llele);
373          set->ptr = intsetRemove(set->ptr,llele,NULL);
374      } else {
375          ele = createStringObject(sdsele,sdslen(sdsele));
376          setTypeRemove(set,ele->ptr);
377      }
378      notifyKeyspaceEvent(NOTIFY_SET,"spop",c->argv[1],c->db->id);
379      aux = createStringObject("SREM",4);
380      rewriteClientCommandVector(c,3,aux,c->argv[1],ele);
381      decrRefCount(aux);
382      addReplyBulk(c,ele);
383      decrRefCount(ele);
384      if (setTypeSize(set) == 0) {
385          dbDelete(c->db,c->argv[1]);
386          notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
387      }
388      signalModifiedKey(c->db,c->argv[1]);
389      server.dirty++;
390  }
391  #define SRANDMEMBER_SUB_STRATEGY_MUL 3
392  void srandmemberWithCountCommand(client *c) {
393      PORT_LONG l;
394      PORT_ULONG count, size;
395      int uniq = 1;
396      robj *set;
397      sds ele;
398      int64_t llele;
399      int encoding;
400      dict *d;
401      if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;
402      if (l >= 0) {
403          count = (PORT_ULONG) l;
404      } else {
405          count = -l;
406          uniq = 0;
407      }
408      if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk))
409          == NULL || checkType(c,set,OBJ_SET)) return;
410      size = setTypeSize(set);
411      if (count == 0) {
412          addReply(c,shared.emptymultibulk);
413          return;
414      }
415      if (!uniq) {
416          addReplyMultiBulkLen(c,count);
417          while(count--) {
418              encoding = setTypeRandomElement(set,&ele,&llele);
419              if (encoding == OBJ_ENCODING_INTSET) {
420                  addReplyBulkLongLong(c,llele);
421              } else {
422                  addReplyBulkCBuffer(c,ele,sdslen(ele));
423              }
424          }
425          return;
426      }
427      if (count >= size) {
428          sunionDiffGenericCommand(c,c->argv+1,1,NULL,SET_OP_UNION);
429          return;
430      }
431      d = dictCreate(&objectKeyPointerValueDictType,NULL);
432      if (count*SRANDMEMBER_SUB_STRATEGY_MUL > size) {
433          setTypeIterator *si;
434          si = setTypeInitIterator(set);
435          while((encoding = setTypeNext(si,&ele,&llele)) != -1) {
436              int retval = DICT_ERR;
437              if (encoding == OBJ_ENCODING_INTSET) {
438                  retval = dictAdd(d,createStringObjectFromLongLong(llele),NULL);
439              } else {
440                  retval = dictAdd(d,createStringObject(ele,sdslen(ele)),NULL);
441              }
442              serverAssert(retval == DICT_OK);
443          }
444          setTypeReleaseIterator(si);
445          serverAssert(dictSize(d) == size);
446          while(size > count) {
447              dictEntry *de;
448              de = dictGetRandomKey(d);
449              dictDelete(d,dictGetKey(de));
450              size--;
451          }
452      }
453      else {
454          PORT_ULONG added = 0;
455          robj *objele;
456          while(added < count) {
457              encoding = setTypeRandomElement(set,&ele,&llele);
458              if (encoding == OBJ_ENCODING_INTSET) {
459                  objele = createStringObjectFromLongLong(llele);
460              } else {
461                  objele = createStringObject(ele,sdslen(ele));
462              }
463              if (dictAdd(d,objele,NULL) == DICT_OK)
464                  added++;
465              else
466                  decrRefCount(objele);
467          }
468      }
469      {
470          dictIterator *di;
471          dictEntry *de;
472          addReplyMultiBulkLen(c,count);
473          di = dictGetIterator(d);
474          while((de = dictNext(di)) != NULL)
475              addReplyBulk(c,dictGetKey(de));
476          dictReleaseIterator(di);
477          dictRelease(d);
478      }
479  }
480  void srandmemberCommand(client *c) {
481      robj *set;
482      sds ele;
483      int64_t llele;
484      int encoding;
485      if (c->argc == 3) {
486          srandmemberWithCountCommand(c);
487          return;
488      } else if (c->argc > 3) {
489          addReply(c,shared.syntaxerr);
490          return;
491      }
492      if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
493          checkType(c,set,OBJ_SET)) return;
494      encoding = setTypeRandomElement(set,&ele,&llele);
495      if (encoding == OBJ_ENCODING_INTSET) {
496          addReplyBulkLongLong(c,llele);
497      } else {
498          addReplyBulkCBuffer(c,ele,sdslen(ele));
499      }
500  }
501  int qsortCompareSetsByCardinality(const void *s1, const void *s2) {
502      if (setTypeSize(*(robj**)s1) > setTypeSize(*(robj**)s2)) return 1;
503      if (setTypeSize(*(robj**)s1) < setTypeSize(*(robj**)s2)) return -1;
504      return 0;
505  }
506  int qsortCompareSetsByRevCardinality(const void *s1, const void *s2) {
507      robj *o1 = *(robj**)s1, *o2 = *(robj**)s2;
508      PORT_ULONG first = o1 ? setTypeSize(o1) : 0;
509      PORT_ULONG second = o2 ? setTypeSize(o2) : 0;
510      if (first < second) return 1;
511      if (first > second) return -1;
512      return 0;
513  }
514  void sinterGenericCommand(client *c, robj **setkeys,
515                            PORT_ULONG setnum, robj *dstkey) {
516      robj **sets = zmalloc(sizeof(robj*)*setnum);
517      setTypeIterator *si;
518      robj *dstset = NULL;
519      sds elesds;
520      int64_t intobj;
521      void *replylen = NULL;
522      PORT_ULONG j, cardinality = 0;
523      int encoding;
524      for (j = 0; j < setnum; j++) {
525          robj *setobj = dstkey ?
526              lookupKeyWrite(c->db,setkeys[j]) :
527              lookupKeyRead(c->db,setkeys[j]);
528          if (!setobj) {
529              zfree(sets);
530              if (dstkey) {
531                  if (dbDelete(c->db,dstkey)) {
532                      signalModifiedKey(c->db,dstkey);
533                      server.dirty++;
534                  }
535                  addReply(c,shared.czero);
536              } else {
537                  addReply(c,shared.emptymultibulk);
538              }
539              return;
540          }
541          if (checkType(c,setobj,OBJ_SET)) {
542              zfree(sets);
543              return;
544          }
545          sets[j] = setobj;
546      }
547      qsort(sets,setnum,sizeof(robj*),qsortCompareSetsByCardinality);
548      if (!dstkey) {
549          replylen = addDeferredMultiBulkLength(c);
550      } else {
551          dstset = createIntsetObject();
552      }
553      si = setTypeInitIterator(sets[0]);
554      while((encoding = setTypeNext(si,&elesds,&intobj)) != -1) {
555          for (j = 1; j < setnum; j++) {
556              if (sets[j] == sets[0]) continue;
557              if (encoding == OBJ_ENCODING_INTSET) {
558                  if (sets[j]->encoding == OBJ_ENCODING_INTSET &&
559                      !intsetFind((intset*)sets[j]->ptr,intobj))
560                  {
561                      break;
562                  } else if (sets[j]->encoding == OBJ_ENCODING_HT) {
563                      elesds = sdsfromlonglong(intobj);
564                      if (!setTypeIsMember(sets[j],elesds)) {
565                          sdsfree(elesds);
566                          break;
567                      }
568                      sdsfree(elesds);
569                  }
570              } else if (encoding == OBJ_ENCODING_HT) {
571                  if (!setTypeIsMember(sets[j],elesds)) {
572                      break;
573                  }
574              }
575          }
576          if (j == setnum) {
577              if (!dstkey) {
578                  if (encoding == OBJ_ENCODING_HT)
579                      addReplyBulkCBuffer(c,elesds,sdslen(elesds));
580                  else
581                      addReplyBulkLongLong(c,intobj);
582                  cardinality++;
583              } else {
584                  if (encoding == OBJ_ENCODING_INTSET) {
585                      elesds = sdsfromlonglong(intobj);
586                      setTypeAdd(dstset,elesds);
587                      sdsfree(elesds);
588                  } else {
589                      setTypeAdd(dstset,elesds);
590                  }
591              }
592          }
593      }
594      setTypeReleaseIterator(si);
595      if (dstkey) {
596          int deleted = dbDelete(c->db,dstkey);
597          if (setTypeSize(dstset) > 0) {
598              dbAdd(c->db,dstkey,dstset);
599              addReplyLongLong(c,setTypeSize(dstset));
600              notifyKeyspaceEvent(NOTIFY_SET,"sinterstore",
601                  dstkey,c->db->id);
602          } else {
603              decrRefCount(dstset);
604              addReply(c,shared.czero);
605              if (deleted)
606                  notifyKeyspaceEvent(NOTIFY_GENERIC,"del",
607                      dstkey,c->db->id);
608          }
609          signalModifiedKey(c->db,dstkey);
610          server.dirty++;
611      } else {
612          setDeferredMultiBulkLength(c,replylen,cardinality);
613      }
614      zfree(sets);
615  }
616  void sinterCommand(client *c) {
617      sinterGenericCommand(c,c->argv+1,c->argc-1,NULL);
618  }
619  void sinterstoreCommand(client *c) {
620      sinterGenericCommand(c,c->argv+2,c->argc-2,c->argv[1]);
621  }
622  #define SET_OP_UNION 0
623  #define SET_OP_DIFF 1
624  #define SET_OP_INTER 2
625  void sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,
626                                robj *dstkey, int op) {
627      robj **sets = zmalloc(sizeof(robj*)*setnum);
628      setTypeIterator *si;
629      robj *dstset = NULL;
630      sds ele;
631      int j, cardinality = 0;
632      int diff_algo = 1;
633      for (j = 0; j < setnum; j++) {
634          robj *setobj = dstkey ?
635              lookupKeyWrite(c->db,setkeys[j]) :
636              lookupKeyRead(c->db,setkeys[j]);
637          if (!setobj) {
638              sets[j] = NULL;
639              continue;
640          }
641          if (checkType(c,setobj,OBJ_SET)) {
642              zfree(sets);
643              return;
644          }
645          sets[j] = setobj;
646      }
647      if (op == SET_OP_DIFF && sets[0]) {
648          PORT_LONGLONG algo_one_work = 0, algo_two_work = 0;
649          for (j = 0; j < setnum; j++) {
650              if (sets[j] == NULL) continue;
651              algo_one_work += setTypeSize(sets[0]);
652              algo_two_work += setTypeSize(sets[j]);
653          }
654          algo_one_work /= 2;
655          diff_algo = (algo_one_work <= algo_two_work) ? 1 : 2;
656          if (diff_algo == 1 && setnum > 1) {
657              qsort(sets+1,setnum-1,sizeof(robj*),
658                  qsortCompareSetsByRevCardinality);
659          }
660      }
661      dstset = createIntsetObject();
662      if (op == SET_OP_UNION) {
663          for (j = 0; j < setnum; j++) {
664              if (!sets[j]) continue; &bsol;* non existing keys are like empty sets */
665              si = setTypeInitIterator(sets[j]);
666              while((ele = setTypeNextObject(si)) != NULL) {
667                  if (setTypeAdd(dstset,ele)) cardinality++;
668                  sdsfree(ele);
669              }
670              setTypeReleaseIterator(si);
671          }
672      } else if (op == SET_OP_DIFF && sets[0] && diff_algo == 1) {
673          si = setTypeInitIterator(sets[0]);
674          while((ele = setTypeNextObject(si)) != NULL) {
675              for (j = 1; j < setnum; j++) {
676                  if (!sets[j]) continue; &bsol;* no key is an empty set. */
677                  if (sets[j] == sets[0]) break; &bsol;* same set! */
678                  if (setTypeIsMember(sets[j],ele)) break;
679              }
680              if (j == setnum) {
681                  setTypeAdd(dstset,ele);
682                  cardinality++;
683              }
684              sdsfree(ele);
685          }
686          setTypeReleaseIterator(si);
687      } else if (op == SET_OP_DIFF && sets[0] && diff_algo == 2) {
688          for (j = 0; j < setnum; j++) {
689              if (!sets[j]) continue; &bsol;* non existing keys are like empty sets */
690              si = setTypeInitIterator(sets[j]);
691              while((ele = setTypeNextObject(si)) != NULL) {
692                  if (j == 0) {
693                      if (setTypeAdd(dstset,ele)) cardinality++;
694                  } else {
695                      if (setTypeRemove(dstset,ele)) cardinality--;
696                  }
697                  sdsfree(ele);
698              }
699              setTypeReleaseIterator(si);
700              if (cardinality == 0) break;
701          }
702      }
703      if (!dstkey) {
704          addReplyMultiBulkLen(c,cardinality);
705          si = setTypeInitIterator(dstset);
706          while((ele = setTypeNextObject(si)) != NULL) {
707              addReplyBulkCBuffer(c,ele,sdslen(ele));
708              sdsfree(ele);
709          }
710          setTypeReleaseIterator(si);
711          decrRefCount(dstset);
712      } else {
713          int deleted = dbDelete(c->db,dstkey);
714          if (setTypeSize(dstset) > 0) {
715              dbAdd(c->db,dstkey,dstset);
716              addReplyLongLong(c,setTypeSize(dstset));
717              notifyKeyspaceEvent(NOTIFY_SET,
718                  op == SET_OP_UNION ? "sunionstore" : "sdiffstore",
719                  dstkey,c->db->id);
720          } else {
721              decrRefCount(dstset);
722              addReply(c,shared.czero);
723              if (deleted)
724                  notifyKeyspaceEvent(NOTIFY_GENERIC,"del",
725                      dstkey,c->db->id);
726          }
727          signalModifiedKey(c->db,dstkey);
728          server.dirty++;
729      }
730      zfree(sets);
731  }
732  void sunionCommand(client *c) {
733      sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,SET_OP_UNION);
734  }
735  void sunionstoreCommand(client *c) {
736      sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],SET_OP_UNION);
737  }
738  void sdiffCommand(client *c) {
739      sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,SET_OP_DIFF);
740  }
741  void sdiffstoreCommand(client *c) {
742      sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],SET_OP_DIFF);
743  }
744  void sscanCommand(client *c) {
745      robj *set;
746      PORT_ULONG cursor;
747      if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;
748      if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
749          checkType(c,set,OBJ_SET)) return;
750      scanGenericCommand(c,set,cursor);
751  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-t_set.c</h3>
            <pre><code>1  #include "server.h"
2  void sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,
3                                robj *dstkey, int op);
4  robj *setTypeCreate(sds value) {
5      if (isSdsRepresentableAsLongLong(value,NULL) == C_OK)
6          return createIntsetObject();
7      return createSetObject();
8  }
9  int setTypeAdd(robj *subject, sds value) {
10      PORT_LONGLONG llval;
11      if (subject->encoding == OBJ_ENCODING_HT) {
12          dict *ht = subject->ptr;
13          dictEntry *de = dictAddRaw(ht,value,NULL);
14          if (de) {
15              dictSetKey(ht,de,sdsdup(value));
16              dictSetVal(ht,de,NULL);
17              return 1;
18          }
19      } else if (subject->encoding == OBJ_ENCODING_INTSET) {
20          if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {
21              uint8_t success = 0;
<span onclick='openModal()' class='match'>22              subject->ptr = intsetAdd(subject->ptr,llval,&success);
23              if (success) {
</span>24                  if (intsetLen(subject->ptr) > server.set_max_intset_entries)
25                      setTypeConvert(subject,OBJ_ENCODING_HT);
26                  return 1;
27              }
28          } else {
29              setTypeConvert(subject,OBJ_ENCODING_HT);
30              serverAssert(dictAdd(subject->ptr,sdsdup(value),NULL) == DICT_OK);
31              return 1;
32          }
33      } else {
34          serverPanic("Unknown set encoding");
35      }
36      return 0;
37  }
38  int setTypeRemove(robj *setobj, sds value) {
39      PORT_LONGLONG llval;
40      if (setobj->encoding == OBJ_ENCODING_HT) {
41          if (dictDelete(setobj->ptr,value) == DICT_OK) {
42              if (htNeedsResize(setobj->ptr)) dictResize(setobj->ptr);
43              return 1;
44          }
45      } else if (setobj->encoding == OBJ_ENCODING_INTSET) {
46          if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {
47              int success;
48              setobj->ptr = intsetRemove(setobj->ptr,llval,&success);
49              if (success) return 1;
50          }
51      } else {
52          serverPanic("Unknown set encoding");
53      }
54      return 0;
55  }
56  int setTypeIsMember(robj *subject, sds value) {
57      PORT_LONGLONG llval;
58      if (subject->encoding == OBJ_ENCODING_HT) {
59          return dictFind((dict*)subject->ptr,value) != NULL;
60      } else if (subject->encoding == OBJ_ENCODING_INTSET) {
61          if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {
62              return intsetFind((intset*)subject->ptr,llval);
63          }
64      } else {
65          serverPanic("Unknown set encoding");
66      }
67      return 0;
68  }
69  setTypeIterator *setTypeInitIterator(robj *subject) {
70      setTypeIterator *si = zmalloc(sizeof(setTypeIterator));
71      si->subject = subject;
72      si->encoding = subject->encoding;
73      if (si->encoding == OBJ_ENCODING_HT) {
74          si->di = dictGetIterator(subject->ptr);
75      } else if (si->encoding == OBJ_ENCODING_INTSET) {
76          si->ii = 0;
77      } else {
78          serverPanic("Unknown set encoding");
79      }
80      return si;
81  }
82  void setTypeReleaseIterator(setTypeIterator *si) {
83      if (si->encoding == OBJ_ENCODING_HT)
84          dictReleaseIterator(si->di);
85      zfree(si);
86  }
87  int setTypeNext(setTypeIterator *si, sds *sdsele, int64_t *llele) {
88      if (si->encoding == OBJ_ENCODING_HT) {
89          dictEntry *de = dictNext(si->di);
90          if (de == NULL) return -1;
91          *sdsele = dictGetKey(de);
92          *llele = -123456789; &bsol;* Not needed. Defensive. */
93      } else if (si->encoding == OBJ_ENCODING_INTSET) {
94          if (!intsetGet(si->subject->ptr,si->ii++,llele))
95              return -1;
96          *sdsele = NULL; &bsol;* Not needed. Defensive. */
97      } else {
98          serverPanic("Wrong set encoding in setTypeNext");
99      }
100      return si->encoding;
101  }
102  sds setTypeNextObject(setTypeIterator *si) {
103      int64_t intele;
104      sds sdsele;
105      int encoding;
106      encoding = setTypeNext(si,&sdsele,&intele);
107      switch(encoding) {
108          case -1:    return NULL;
109          case OBJ_ENCODING_INTSET:
110              return sdsfromlonglong(intele);
111          case OBJ_ENCODING_HT:
112              return sdsdup(sdsele);
113          default:
114              serverPanic("Unsupported encoding");
115      }
116      return NULL; &bsol;* just to suppress warnings */
117  }
118  int setTypeRandomElement(robj *setobj, sds *sdsele, int64_t *llele) {
119      if (setobj->encoding == OBJ_ENCODING_HT) {
120          dictEntry *de = dictGetRandomKey(setobj->ptr);
121          *sdsele = dictGetKey(de);
122          *llele = -123456789; &bsol;* Not needed. Defensive. */
123      } else if (setobj->encoding == OBJ_ENCODING_INTSET) {
124          *llele = intsetRandom(setobj->ptr);
125          *sdsele = NULL; &bsol;* Not needed. Defensive. */
126      } else {
127          serverPanic("Unknown set encoding");
128      }
129      return setobj->encoding;
130  }
131  PORT_ULONG setTypeSize(const robj *subject) {
132      if (subject->encoding == OBJ_ENCODING_HT) {
133          return (PORT_ULONG) dictSize((const dict*)subject->ptr);                     WIN_PORT_FIX &bsol;* cast (PORT_ULONG) */
134      } else if (subject->encoding == OBJ_ENCODING_INTSET) {
135          return intsetLen((const intset*)subject->ptr);
136      } else {
137          serverPanic("Unknown set encoding");
138      }
139  }
140  void setTypeConvert(robj *setobj, int enc) {
141      setTypeIterator *si;
142      serverAssertWithInfo(NULL,setobj,setobj->type == OBJ_SET &&
143                               setobj->encoding == OBJ_ENCODING_INTSET);
144      if (enc == OBJ_ENCODING_HT) {
145          int64_t intele;
146          dict *d = dictCreate(&setDictType,NULL);
147          sds element;
148          dictExpand(d,intsetLen(setobj->ptr));
149          si = setTypeInitIterator(setobj);
150          while (setTypeNext(si,&element,&intele) != -1) {
151              element = sdsfromlonglong(intele);
152              serverAssert(dictAdd(d,element,NULL) == DICT_OK);
153          }
154          setTypeReleaseIterator(si);
155          setobj->encoding = OBJ_ENCODING_HT;
156          zfree(setobj->ptr);
157          setobj->ptr = d;
158      } else {
159          serverPanic("Unsupported set conversion");
160      }
161  }
162  void saddCommand(client *c) {
163      robj *set;
164      int j, added = 0;
165      set = lookupKeyWrite(c->db,c->argv[1]);
166      if (set == NULL) {
167          set = setTypeCreate(c->argv[2]->ptr);
168          dbAdd(c->db,c->argv[1],set);
169      } else {
170          if (set->type != OBJ_SET) {
171              addReply(c,shared.wrongtypeerr);
172              return;
173          }
174      }
175      for (j = 2; j < c->argc; j++) {
176          if (setTypeAdd(set,c->argv[j]->ptr)) added++;
177      }
178      if (added) {
179          signalModifiedKey(c->db,c->argv[1]);
180          notifyKeyspaceEvent(NOTIFY_SET,"sadd",c->argv[1],c->db->id);
181      }
182      server.dirty += added;
183      addReplyLongLong(c,added);
184  }
185  void sremCommand(client *c) {
186      robj *set;
187      int j, deleted = 0, keyremoved = 0;
188      if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
189          checkType(c,set,OBJ_SET)) return;
190      for (j = 2; j < c->argc; j++) {
191          if (setTypeRemove(set,c->argv[j]->ptr)) {
192              deleted++;
193              if (setTypeSize(set) == 0) {
194                  dbDelete(c->db,c->argv[1]);
195                  keyremoved = 1;
196                  break;
197              }
198          }
199      }
200      if (deleted) {
201          signalModifiedKey(c->db,c->argv[1]);
202          notifyKeyspaceEvent(NOTIFY_SET,"srem",c->argv[1],c->db->id);
203          if (keyremoved)
204              notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],
205                                  c->db->id);
206          server.dirty += deleted;
207      }
208      addReplyLongLong(c,deleted);
209  }
210  void smoveCommand(client *c) {
211      robj *srcset, *dstset, *ele;
212      srcset = lookupKeyWrite(c->db,c->argv[1]);
213      dstset = lookupKeyWrite(c->db,c->argv[2]);
214      ele = c->argv[3];
215      if (srcset == NULL) {
216          addReply(c,shared.czero);
217          return;
218      }
219      if (checkType(c,srcset,OBJ_SET) ||
220          (dstset && checkType(c,dstset,OBJ_SET))) return;
221      if (srcset == dstset) {
222          addReply(c,setTypeIsMember(srcset,ele->ptr) ?
223              shared.cone : shared.czero);
224          return;
225      }
226      if (!setTypeRemove(srcset,ele->ptr)) {
227          addReply(c,shared.czero);
228          return;
229      }
230      notifyKeyspaceEvent(NOTIFY_SET,"srem",c->argv[1],c->db->id);
231      if (setTypeSize(srcset) == 0) {
232          dbDelete(c->db,c->argv[1]);
233          notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
234      }
235      if (!dstset) {
236          dstset = setTypeCreate(ele->ptr);
237          dbAdd(c->db,c->argv[2],dstset);
238      }
239      signalModifiedKey(c->db,c->argv[1]);
240      signalModifiedKey(c->db,c->argv[2]);
241      server.dirty++;
242      if (setTypeAdd(dstset,ele->ptr)) {
243          server.dirty++;
244          notifyKeyspaceEvent(NOTIFY_SET,"sadd",c->argv[2],c->db->id);
245      }
246      addReply(c,shared.cone);
247  }
248  void sismemberCommand(client *c) {
249      robj *set;
250      if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
251          checkType(c,set,OBJ_SET)) return;
252      if (setTypeIsMember(set,c->argv[2]->ptr))
253          addReply(c,shared.cone);
254      else
255          addReply(c,shared.czero);
256  }
257  void scardCommand(client *c) {
258      robj *o;
259      if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
260          checkType(c,o,OBJ_SET)) return;
261      addReplyLongLong(c,setTypeSize(o));
262  }
263  #define SPOP_MOVE_STRATEGY_MUL 5
264  void spopWithCountCommand(client *c) {
265      PORT_LONG l;
266      PORT_ULONG count, size;
267      robj *set;
268      if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;
269      if (l >= 0) {
270          count = (PORT_ULONG) l;
271      } else {
272          addReply(c,shared.outofrangeerr);
273          return;
274      }
275      if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk))
276          == NULL || checkType(c,set,OBJ_SET)) return;
277      if (count == 0) {
278          addReply(c,shared.emptymultibulk);
279          return;
280      }
281      size = setTypeSize(set);
282      notifyKeyspaceEvent(NOTIFY_SET,"spop",c->argv[1],c->db->id);
283      server.dirty += count;
284      if (count >= size) {
285          sunionDiffGenericCommand(c,c->argv+1,1,NULL,SET_OP_UNION);
286          dbDelete(c->db,c->argv[1]);
287          notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
288          rewriteClientCommandVector(c,2,shared.del,c->argv[1]);
289          signalModifiedKey(c->db,c->argv[1]);
290          server.dirty++;
291          return;
292      }
293      robj *propargv[3];
294      propargv[0] = createStringObject("SREM",4);
295      propargv[1] = c->argv[1];
296      addReplyMultiBulkLen(c,count);
297      sds sdsele;
298      robj *objele;
299      int encoding;
300      int64_t llele;
301      PORT_ULONG remaining = size-count; &bsol;* Elements left after SPOP. */
302      if (remaining*SPOP_MOVE_STRATEGY_MUL > count) {
303          while(count--) {
304              encoding = setTypeRandomElement(set,&sdsele,&llele);
305              if (encoding == OBJ_ENCODING_INTSET) {
306                  addReplyBulkLongLong(c,llele);
307                  objele = createStringObjectFromLongLong(llele);
308                  set->ptr = intsetRemove(set->ptr,llele,NULL);
309              } else {
310                  addReplyBulkCBuffer(c,sdsele,sdslen(sdsele));
311                  objele = createStringObject(sdsele,sdslen(sdsele));
312                  setTypeRemove(set,sdsele);
313              }
314              propargv[2] = objele;
315              alsoPropagate(server.sremCommand,c->db->id,propargv,3,
316                  PROPAGATE_AOF|PROPAGATE_REPL);
317              decrRefCount(objele);
318          }
319      } else {
320          robj *newset = NULL;
321          while(remaining--) {
322              encoding = setTypeRandomElement(set,&sdsele,&llele);
323              if (encoding == OBJ_ENCODING_INTSET) {
324                  sdsele = sdsfromlonglong(llele);
325              } else {
326                  sdsele = sdsdup(sdsele);
327              }
328              if (!newset) newset = setTypeCreate(sdsele);
329              setTypeAdd(newset,sdsele);
330              setTypeRemove(set,sdsele);
331              sdsfree(sdsele);
332          }
333          setTypeIterator *si;
334          si = setTypeInitIterator(set);
335          while((encoding = setTypeNext(si,&sdsele,&llele)) != -1) {
336              if (encoding == OBJ_ENCODING_INTSET) {
337                  addReplyBulkLongLong(c,llele);
338                  objele = createStringObjectFromLongLong(llele);
339              } else {
340                  addReplyBulkCBuffer(c,sdsele,sdslen(sdsele));
341                  objele = createStringObject(sdsele,sdslen(sdsele));
342              }
343              propargv[2] = objele;
344              alsoPropagate(server.sremCommand,c->db->id,propargv,3,
345                  PROPAGATE_AOF|PROPAGATE_REPL);
346              decrRefCount(objele);
347          }
348          setTypeReleaseIterator(si);
349          dbOverwrite(c->db,c->argv[1],newset);
350      }
351      decrRefCount(propargv[0]);
352      preventCommandPropagation(c);
353      signalModifiedKey(c->db,c->argv[1]);
354      server.dirty++;
355  }
356  void spopCommand(client *c) {
357      robj *set, *ele, *aux;
358      sds sdsele;
359      int64_t llele;
360      int encoding;
361      if (c->argc == 3) {
362          spopWithCountCommand(c);
363          return;
364      } else if (c->argc > 3) {
365          addReply(c,shared.syntaxerr);
366          return;
367      }
368      if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
369          checkType(c,set,OBJ_SET)) return;
370      encoding = setTypeRandomElement(set,&sdsele,&llele);
371      if (encoding == OBJ_ENCODING_INTSET) {
372          ele = createStringObjectFromLongLong(llele);
373          set->ptr = intsetRemove(set->ptr,llele,NULL);
374      } else {
375          ele = createStringObject(sdsele,sdslen(sdsele));
376          setTypeRemove(set,ele->ptr);
377      }
378      notifyKeyspaceEvent(NOTIFY_SET,"spop",c->argv[1],c->db->id);
379      aux = createStringObject("SREM",4);
380      rewriteClientCommandVector(c,3,aux,c->argv[1],ele);
381      decrRefCount(aux);
382      addReplyBulk(c,ele);
383      decrRefCount(ele);
384      if (setTypeSize(set) == 0) {
385          dbDelete(c->db,c->argv[1]);
386          notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
387      }
388      signalModifiedKey(c->db,c->argv[1]);
389      server.dirty++;
390  }
391  #define SRANDMEMBER_SUB_STRATEGY_MUL 3
392  void srandmemberWithCountCommand(client *c) {
393      PORT_LONG l;
394      PORT_ULONG count, size;
395      int uniq = 1;
396      robj *set;
397      sds ele;
398      int64_t llele;
399      int encoding;
400      dict *d;
401      if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;
402      if (l >= 0) {
403          count = (PORT_ULONG) l;
404      } else {
405          count = -l;
406          uniq = 0;
407      }
408      if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk))
409          == NULL || checkType(c,set,OBJ_SET)) return;
410      size = setTypeSize(set);
411      if (count == 0) {
412          addReply(c,shared.emptymultibulk);
413          return;
414      }
415      if (!uniq) {
416          addReplyMultiBulkLen(c,count);
417          while(count--) {
418              encoding = setTypeRandomElement(set,&ele,&llele);
419              if (encoding == OBJ_ENCODING_INTSET) {
420                  addReplyBulkLongLong(c,llele);
421              } else {
422                  addReplyBulkCBuffer(c,ele,sdslen(ele));
423              }
424          }
425          return;
426      }
427      if (count >= size) {
428          sunionDiffGenericCommand(c,c->argv+1,1,NULL,SET_OP_UNION);
429          return;
430      }
431      d = dictCreate(&objectKeyPointerValueDictType,NULL);
432      if (count*SRANDMEMBER_SUB_STRATEGY_MUL > size) {
433          setTypeIterator *si;
434          si = setTypeInitIterator(set);
435          while((encoding = setTypeNext(si,&ele,&llele)) != -1) {
436              int retval = DICT_ERR;
437              if (encoding == OBJ_ENCODING_INTSET) {
438                  retval = dictAdd(d,createStringObjectFromLongLong(llele),NULL);
439              } else {
440                  retval = dictAdd(d,createStringObject(ele,sdslen(ele)),NULL);
441              }
442              serverAssert(retval == DICT_OK);
443          }
444          setTypeReleaseIterator(si);
445          serverAssert(dictSize(d) == size);
446          while(size > count) {
447              dictEntry *de;
448              de = dictGetRandomKey(d);
449              dictDelete(d,dictGetKey(de));
450              size--;
451          }
452      }
453      else {
454          PORT_ULONG added = 0;
455          robj *objele;
456          while(added < count) {
457              encoding = setTypeRandomElement(set,&ele,&llele);
458              if (encoding == OBJ_ENCODING_INTSET) {
459                  objele = createStringObjectFromLongLong(llele);
460              } else {
461                  objele = createStringObject(ele,sdslen(ele));
462              }
463              if (dictAdd(d,objele,NULL) == DICT_OK)
464                  added++;
465              else
466                  decrRefCount(objele);
467          }
468      }
469      {
470          dictIterator *di;
471          dictEntry *de;
472          addReplyMultiBulkLen(c,count);
473          di = dictGetIterator(d);
474          while((de = dictNext(di)) != NULL)
475              addReplyBulk(c,dictGetKey(de));
476          dictReleaseIterator(di);
477          dictRelease(d);
478      }
479  }
480  void srandmemberCommand(client *c) {
481      robj *set;
482      sds ele;
483      int64_t llele;
484      int encoding;
485      if (c->argc == 3) {
486          srandmemberWithCountCommand(c);
487          return;
488      } else if (c->argc > 3) {
489          addReply(c,shared.syntaxerr);
490          return;
491      }
492      if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
493          checkType(c,set,OBJ_SET)) return;
494      encoding = setTypeRandomElement(set,&ele,&llele);
495      if (encoding == OBJ_ENCODING_INTSET) {
496          addReplyBulkLongLong(c,llele);
497      } else {
498          addReplyBulkCBuffer(c,ele,sdslen(ele));
499      }
500  }
501  int qsortCompareSetsByCardinality(const void *s1, const void *s2) {
502      if (setTypeSize(*(robj**)s1) > setTypeSize(*(robj**)s2)) return 1;
503      if (setTypeSize(*(robj**)s1) < setTypeSize(*(robj**)s2)) return -1;
504      return 0;
505  }
506  int qsortCompareSetsByRevCardinality(const void *s1, const void *s2) {
507      robj *o1 = *(robj**)s1, *o2 = *(robj**)s2;
508      PORT_ULONG first = o1 ? setTypeSize(o1) : 0;
509      PORT_ULONG second = o2 ? setTypeSize(o2) : 0;
510      if (first < second) return 1;
511      if (first > second) return -1;
512      return 0;
513  }
514  void sinterGenericCommand(client *c, robj **setkeys,
515                            PORT_ULONG setnum, robj *dstkey) {
516      robj **sets = zmalloc(sizeof(robj*)*setnum);
517      setTypeIterator *si;
518      robj *dstset = NULL;
519      sds elesds;
520      int64_t intobj;
521      void *replylen = NULL;
522      PORT_ULONG j, cardinality = 0;
523      int encoding;
524      for (j = 0; j < setnum; j++) {
525          robj *setobj = dstkey ?
526              lookupKeyWrite(c->db,setkeys[j]) :
527              lookupKeyRead(c->db,setkeys[j]);
528          if (!setobj) {
529              zfree(sets);
530              if (dstkey) {
531                  if (dbDelete(c->db,dstkey)) {
532                      signalModifiedKey(c->db,dstkey);
533                      server.dirty++;
534                  }
535                  addReply(c,shared.czero);
536              } else {
537                  addReply(c,shared.emptymultibulk);
538              }
539              return;
540          }
541          if (checkType(c,setobj,OBJ_SET)) {
542              zfree(sets);
543              return;
544          }
545          sets[j] = setobj;
546      }
547      qsort(sets,setnum,sizeof(robj*),qsortCompareSetsByCardinality);
548      if (!dstkey) {
549          replylen = addDeferredMultiBulkLength(c);
550      } else {
551          dstset = createIntsetObject();
552      }
553      si = setTypeInitIterator(sets[0]);
554      while((encoding = setTypeNext(si,&elesds,&intobj)) != -1) {
555          for (j = 1; j < setnum; j++) {
556              if (sets[j] == sets[0]) continue;
557              if (encoding == OBJ_ENCODING_INTSET) {
558                  if (sets[j]->encoding == OBJ_ENCODING_INTSET &&
559                      !intsetFind((intset*)sets[j]->ptr,intobj))
560                  {
561                      break;
562                  } else if (sets[j]->encoding == OBJ_ENCODING_HT) {
563                      elesds = sdsfromlonglong(intobj);
564                      if (!setTypeIsMember(sets[j],elesds)) {
565                          sdsfree(elesds);
566                          break;
567                      }
568                      sdsfree(elesds);
569                  }
570              } else if (encoding == OBJ_ENCODING_HT) {
571                  if (!setTypeIsMember(sets[j],elesds)) {
572                      break;
573                  }
574              }
575          }
576          if (j == setnum) {
577              if (!dstkey) {
578                  if (encoding == OBJ_ENCODING_HT)
579                      addReplyBulkCBuffer(c,elesds,sdslen(elesds));
580                  else
581                      addReplyBulkLongLong(c,intobj);
582                  cardinality++;
583              } else {
584                  if (encoding == OBJ_ENCODING_INTSET) {
585                      elesds = sdsfromlonglong(intobj);
586                      setTypeAdd(dstset,elesds);
587                      sdsfree(elesds);
588                  } else {
589                      setTypeAdd(dstset,elesds);
590                  }
591              }
592          }
593      }
594      setTypeReleaseIterator(si);
595      if (dstkey) {
596          int deleted = dbDelete(c->db,dstkey);
597          if (setTypeSize(dstset) > 0) {
598              dbAdd(c->db,dstkey,dstset);
599              addReplyLongLong(c,setTypeSize(dstset));
600              notifyKeyspaceEvent(NOTIFY_SET,"sinterstore",
601                  dstkey,c->db->id);
602          } else {
603              decrRefCount(dstset);
604              addReply(c,shared.czero);
605              if (deleted)
606                  notifyKeyspaceEvent(NOTIFY_GENERIC,"del",
607                      dstkey,c->db->id);
608          }
609          signalModifiedKey(c->db,dstkey);
610          server.dirty++;
611      } else {
612          setDeferredMultiBulkLength(c,replylen,cardinality);
613      }
614      zfree(sets);
615  }
616  void sinterCommand(client *c) {
617      sinterGenericCommand(c,c->argv+1,c->argc-1,NULL);
618  }
619  void sinterstoreCommand(client *c) {
620      sinterGenericCommand(c,c->argv+2,c->argc-2,c->argv[1]);
621  }
622  #define SET_OP_UNION 0
623  #define SET_OP_DIFF 1
624  #define SET_OP_INTER 2
625  void sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,
626                                robj *dstkey, int op) {
627      robj **sets = zmalloc(sizeof(robj*)*setnum);
628      setTypeIterator *si;
629      robj *dstset = NULL;
630      sds ele;
631      int j, cardinality = 0;
632      int diff_algo = 1;
633      for (j = 0; j < setnum; j++) {
634          robj *setobj = dstkey ?
635              lookupKeyWrite(c->db,setkeys[j]) :
636              lookupKeyRead(c->db,setkeys[j]);
637          if (!setobj) {
638              sets[j] = NULL;
639              continue;
640          }
641          if (checkType(c,setobj,OBJ_SET)) {
642              zfree(sets);
643              return;
644          }
645          sets[j] = setobj;
646      }
647      if (op == SET_OP_DIFF && sets[0]) {
648          PORT_LONGLONG algo_one_work = 0, algo_two_work = 0;
649          for (j = 0; j < setnum; j++) {
650              if (sets[j] == NULL) continue;
651              algo_one_work += setTypeSize(sets[0]);
652              algo_two_work += setTypeSize(sets[j]);
653          }
654          algo_one_work /= 2;
655          diff_algo = (algo_one_work <= algo_two_work) ? 1 : 2;
656          if (diff_algo == 1 && setnum > 1) {
657              qsort(sets+1,setnum-1,sizeof(robj*),
658                  qsortCompareSetsByRevCardinality);
659          }
660      }
661      dstset = createIntsetObject();
662      if (op == SET_OP_UNION) {
663          for (j = 0; j < setnum; j++) {
664              if (!sets[j]) continue; &bsol;* non existing keys are like empty sets */
665              si = setTypeInitIterator(sets[j]);
666              while((ele = setTypeNextObject(si)) != NULL) {
667                  if (setTypeAdd(dstset,ele)) cardinality++;
668                  sdsfree(ele);
669              }
670              setTypeReleaseIterator(si);
671          }
672      } else if (op == SET_OP_DIFF && sets[0] && diff_algo == 1) {
673          si = setTypeInitIterator(sets[0]);
674          while((ele = setTypeNextObject(si)) != NULL) {
675              for (j = 1; j < setnum; j++) {
676                  if (!sets[j]) continue; &bsol;* no key is an empty set. */
677                  if (sets[j] == sets[0]) break; &bsol;* same set! */
678                  if (setTypeIsMember(sets[j],ele)) break;
679              }
680              if (j == setnum) {
681                  setTypeAdd(dstset,ele);
682                  cardinality++;
683              }
684              sdsfree(ele);
685          }
686          setTypeReleaseIterator(si);
687      } else if (op == SET_OP_DIFF && sets[0] && diff_algo == 2) {
688          for (j = 0; j < setnum; j++) {
689              if (!sets[j]) continue; &bsol;* non existing keys are like empty sets */
690              si = setTypeInitIterator(sets[j]);
691              while((ele = setTypeNextObject(si)) != NULL) {
692                  if (j == 0) {
693                      if (setTypeAdd(dstset,ele)) cardinality++;
694                  } else {
695                      if (setTypeRemove(dstset,ele)) cardinality--;
696                  }
697                  sdsfree(ele);
698              }
699              setTypeReleaseIterator(si);
700              if (cardinality == 0) break;
701          }
702      }
703      if (!dstkey) {
704          addReplyMultiBulkLen(c,cardinality);
705          si = setTypeInitIterator(dstset);
706          while((ele = setTypeNextObject(si)) != NULL) {
707              addReplyBulkCBuffer(c,ele,sdslen(ele));
708              sdsfree(ele);
709          }
710          setTypeReleaseIterator(si);
711          decrRefCount(dstset);
712      } else {
713          int deleted = dbDelete(c->db,dstkey);
714          if (setTypeSize(dstset) > 0) {
715              dbAdd(c->db,dstkey,dstset);
716              addReplyLongLong(c,setTypeSize(dstset));
717              notifyKeyspaceEvent(NOTIFY_SET,
718                  op == SET_OP_UNION ? "sunionstore" : "sdiffstore",
719                  dstkey,c->db->id);
720          } else {
721              decrRefCount(dstset);
722              addReply(c,shared.czero);
723              if (deleted)
724                  notifyKeyspaceEvent(NOTIFY_GENERIC,"del",
725                      dstkey,c->db->id);
726          }
727          signalModifiedKey(c->db,dstkey);
728          server.dirty++;
729      }
730      zfree(sets);
731  }
732  void sunionCommand(client *c) {
733      sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,SET_OP_UNION);
734  }
735  void sunionstoreCommand(client *c) {
736      sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],SET_OP_UNION);
737  }
738  void sdiffCommand(client *c) {
739      sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,SET_OP_DIFF);
740  }
741  void sdiffstoreCommand(client *c) {
742      sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],SET_OP_DIFF);
743  }
744  void sscanCommand(client *c) {
745      robj *set;
746      PORT_ULONG cursor;
747      if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;
748      if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
749          checkType(c,set,OBJ_SET)) return;
750      scanGenericCommand(c,set,cursor);
751  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-t_set.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-t_set.c</div>
                </div>
                <div class="column column_space"><pre><code>22              subject->ptr = intsetAdd(subject->ptr,llval,&success);
23              if (success) {
</pre></code></div>
                <div class="column column_space"><pre><code>22              subject->ptr = intsetAdd(subject->ptr,llval,&success);
23              if (success) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    