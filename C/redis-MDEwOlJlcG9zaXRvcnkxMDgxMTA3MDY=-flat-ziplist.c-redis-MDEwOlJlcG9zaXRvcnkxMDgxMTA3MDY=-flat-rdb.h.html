
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-ziplist.c</h3>
            <pre><code>1  #include <stdio.h>
2  #include <stdlib.h>
3  #include <string.h>
4  #include <stdint.h>
5  #include <limits.h>
6  #include "zmalloc.h"
7  #include "util.h"
8  #include "ziplist.h"
9  #include "endianconv.h"
10  #include "redisassert.h"
11  #ifdef _WIN32
12  #include "Win32_Interop/Win32_FDAPI.h"
13  #endif
14  #define ZIP_END 255         &bsol;* Special "end of ziplist" entry. */
15  #define ZIP_BIG_PREVLEN 254 &bsol;* Max number of bytes of the previous entry, for
16                                 the "prevlen" field prefixing each entry, to be
17                                 represented with just a single byte. Otherwise
18                                 it is represented as FF AA BB CC DD, where
19                                 AA BB CC DD are a 4 bytes unsigned integer
<span onclick='openModal()' class='match'>20                                 representing the previous entry len. */
21  #define ZIP_STR_MASK 0xc0
22  #define ZIP_INT_MASK 0x30
23  #define ZIP_STR_06B (0 << 6)
</span>24  #define ZIP_STR_14B (1 << 6)
25  #define ZIP_STR_32B (2 << 6)
26  #define ZIP_INT_16B (0xc0 | 0<<4)
27  #define ZIP_INT_32B (0xc0 | 1<<4)
28  #define ZIP_INT_64B (0xc0 | 2<<4)
29  #define ZIP_INT_24B (0xc0 | 3<<4)
30  #define ZIP_INT_8B 0xfe
31  #define ZIP_INT_IMM_MASK 0x0f   &bsol;* Mask to extract the 4 bits value. To add
32                                     one is needed to reconstruct the value. */
33  #define ZIP_INT_IMM_MIN 0xf1    &bsol;* 11110001 */
34  #define ZIP_INT_IMM_MAX 0xfd    &bsol;* 11111101 */
35  #define INT24_MAX 0x7fffff
36  #define INT24_MIN (-INT24_MAX - 1)
37  #define ZIP_IS_STR(enc) (((enc) & ZIP_STR_MASK) < ZIP_STR_MASK)
38  #define ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))
39  #define ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))
40  #define ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))
41  #define ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))
42  #define ZIPLIST_END_SIZE        (sizeof(uint8_t))
43  #define ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)
44  #define ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))
45  #define ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)
46  #define ZIPLIST_INCR_LENGTH(zl,incr) { \
47      if (ZIPLIST_LENGTH(zl) < UINT16_MAX) \
48          ZIPLIST_LENGTH(zl) = intrev16ifbe(intrev16ifbe(ZIPLIST_LENGTH(zl))+incr); \
49  }
50  typedef struct zlentry {
51      unsigned int prevrawlensize; &bsol;* Bytes used to encode the previous entry len*/
52      unsigned int prevrawlen;     &bsol;* Previous entry len. */
53      unsigned int lensize;        &bsol;* Bytes used to encode this entry type/len.
54                                      For example strings have a 1, 2 or 5 bytes
55                                      header. Integers always use a single byte.*/
56      unsigned int len;            &bsol;* Bytes used to represent the actual entry.
57                                      For strings this is just the string length
58                                      while for integers it is 1, 2, 3, 4, 8 or
59                                      0 (for 4 bit immediate) depending on the
60                                      number range. */
61      unsigned int headersize;     &bsol;* prevrawlensize + lensize. */
62      unsigned char encoding;      &bsol;* Set to ZIP_STR_* or ZIP_INT_* depending on
63                                      the entry encoding. However for 4 bits
64                                      immediate integers this can assume a range
65                                      of values and must be range-checked. */
66      unsigned char *p;            &bsol;* Pointer to the very start of the entry, that
67                                      is, this points to prev-entry-len field. */
68  } zlentry;
69  #define ZIPLIST_ENTRY_ZERO(zle) { \
70      (zle)->prevrawlensize = (zle)->prevrawlen = 0; \
71      (zle)->lensize = (zle)->len = (zle)->headersize = 0; \
72      (zle)->encoding = 0; \
73      (zle)->p = NULL; \
74  }
75  #define ZIP_ENTRY_ENCODING(ptr, encoding) do {  \
76      (encoding) = (ptr[0]); \
77      if ((encoding) < ZIP_STR_MASK) (encoding) &= ZIP_STR_MASK; \
78  } while(0)
79  unsigned int zipIntSize(unsigned char encoding) {
80      switch(encoding) {
81      case ZIP_INT_8B:  return 1;
82      case ZIP_INT_16B: return 2;
83      case ZIP_INT_24B: return 3;
84      case ZIP_INT_32B: return 4;
85      case ZIP_INT_64B: return 8;
86      }
87      if (encoding >= ZIP_INT_IMM_MIN && encoding <= ZIP_INT_IMM_MAX)
88          return 0; &bsol;* 4 bit immediate */
89      panic("Invalid integer encoding 0x%02X", encoding);
90      return 0;
91  }
92  unsigned int zipStoreEntryEncoding(unsigned char *p, unsigned char encoding, unsigned int rawlen) {
93      unsigned char len = 1, buf[5];
94      if (ZIP_IS_STR(encoding)) {
95          if (rawlen <= 0x3f) {
96              if (!p) return len;
97              buf[0] = ZIP_STR_06B | rawlen;
98          } else if (rawlen <= 0x3fff) {
99              len += 1;
100              if (!p) return len;
101              buf[0] = ZIP_STR_14B | ((rawlen >> 8) & 0x3f);
102              buf[1] = rawlen & 0xff;
103          } else {
104              len += 4;
105              if (!p) return len;
106              buf[0] = ZIP_STR_32B;
107              buf[1] = (rawlen >> 24) & 0xff;
108              buf[2] = (rawlen >> 16) & 0xff;
109              buf[3] = (rawlen >> 8) & 0xff;
110              buf[4] = rawlen & 0xff;
111          }
112      } else {
113          if (!p) return len;
114          buf[0] = encoding;
115      }
116      memcpy(p,buf,len);
117      return len;
118  }
119  #define ZIP_DECODE_LENGTH(ptr, encoding, lensize, len) do {                    \
120      ZIP_ENTRY_ENCODING((ptr), (encoding));                                     \
121      if ((encoding) < ZIP_STR_MASK) {                                           \
122          if ((encoding) == ZIP_STR_06B) {                                       \
123              (lensize) = 1;                                                     \
124              (len) = (ptr)[0] & 0x3f;                                           \
125          } else if ((encoding) == ZIP_STR_14B) {                                \
126              (lensize) = 2;                                                     \
127              (len) = (((ptr)[0] & 0x3f) << 8) | (ptr)[1];                       \
128          } else if ((encoding) == ZIP_STR_32B) {                                \
129              (lensize) = 5;                                                     \
130              (len) = ((ptr)[1] << 24) |                                         \
131                      ((ptr)[2] << 16) |                                         \
132                      ((ptr)[3] <<  8) |                                         \
133                      ((ptr)[4]);                                                \
134          } else {                                                               \
135              panic("Invalid string encoding 0x%02X", (encoding));               \
136          }                                                                      \
137      } else {                                                                   \
138          (lensize) = 1;                                                         \
139          (len) = zipIntSize(encoding);                                          \
140      }                                                                          \
141  } while(0);
142  int zipStorePrevEntryLengthLarge(unsigned char *p, unsigned int len) {
143      if (p != NULL) {
144          p[0] = ZIP_BIG_PREVLEN;
145          memcpy(p+1,&len,sizeof(len));
146          memrev32ifbe(p+1);
147      }
148      return 1+sizeof(len);
149  }
150  unsigned int zipStorePrevEntryLength(unsigned char *p, unsigned int len) {
151      if (p == NULL) {
152          return (len < ZIP_BIG_PREVLEN) ? 1 : sizeof(len)+1;
153      } else {
154          if (len < ZIP_BIG_PREVLEN) {
155              p[0] = len;
156              return 1;
157          } else {
158              return zipStorePrevEntryLengthLarge(p,len);
159          }
160      }
161  }
162  #define ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do {                          \
163      if ((ptr)[0] < ZIP_BIG_PREVLEN) {                                          \
164          (prevlensize) = 1;                                                     \
165      } else {                                                                   \
166          (prevlensize) = 5;                                                     \
167      }                                                                          \
168  } while(0);
169  #define ZIP_DECODE_PREVLEN(ptr, prevlensize, prevlen) do {                     \
170      ZIP_DECODE_PREVLENSIZE(ptr, prevlensize);                                  \
171      if ((prevlensize) == 1) {                                                  \
172          (prevlen) = (ptr)[0];                                                  \
173      } else if ((prevlensize) == 5) {                                           \
174          assert(sizeof((prevlen)) == 4);                                    \
175          memcpy(&(prevlen), ((char*)(ptr)) + 1, 4);                             \
176          memrev32ifbe(&prevlen);                                                \
177      }                                                                          \
178  } while(0);
179  int zipPrevLenByteDiff(unsigned char *p, unsigned int len) {
180      unsigned int prevlensize;
181      ZIP_DECODE_PREVLENSIZE(p, prevlensize);
182      return zipStorePrevEntryLength(NULL, len) - prevlensize;
183  }
184  unsigned int zipRawEntryLength(unsigned char *p) {
185      unsigned int prevlensize, encoding, lensize, len;
186      ZIP_DECODE_PREVLENSIZE(p, prevlensize);
187      ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len);
188      return prevlensize + lensize + len;
189  }
190  int zipTryEncoding(unsigned char *entry, unsigned int entrylen, PORT_LONGLONG *v, unsigned char *encoding) {
191      PORT_LONGLONG value;
192      if (entrylen >= 32 || entrylen == 0) return 0;
193      if (string2ll((char*)entry,entrylen,&value)) {
194          if (value >= 0 && value <= 12) {
195              *encoding = (unsigned char)(ZIP_INT_IMM_MIN+value);                 WIN_PORT_FIX &bsol;* cast (unsigned char) */
196          } else if (value >= INT8_MIN && value <= INT8_MAX) {
197              *encoding = ZIP_INT_8B;
198          } else if (value >= INT16_MIN && value <= INT16_MAX) {
199              *encoding = ZIP_INT_16B;
200          } else if (value >= INT24_MIN && value <= INT24_MAX) {
201              *encoding = ZIP_INT_24B;
202          } else if (value >= INT32_MIN && value <= INT32_MAX) {
203              *encoding = ZIP_INT_32B;
204          } else {
205              *encoding = ZIP_INT_64B;
206          }
207          *v = value;
208          return 1;
209      }
210      return 0;
211  }
212  void zipSaveInteger(unsigned char *p, int64_t value, unsigned char encoding) {
213      int16_t i16;
214      int32_t i32;
215      int64_t i64;
216      if (encoding == ZIP_INT_8B) {
217          ((int8_t*)p)[0] = (int8_t)value;
218      } else if (encoding == ZIP_INT_16B) {
219          i16 = (int16_t)value;                                                   WIN_PORT_FIX &bsol;* cast (int16_t) */
220          memcpy(p,&i16,sizeof(i16));
221          memrev16ifbe(p);
222      } else if (encoding == ZIP_INT_24B) {
223          i32 = (int32_t)(value<<8);                                              WIN_PORT_FIX &bsol;* cast (int32_t) */
224          memrev32ifbe(&i32);
225          memcpy(p,((uint8_t*)&i32)+1,sizeof(i32)-sizeof(uint8_t));
226      } else if (encoding == ZIP_INT_32B) {
227          i32 = (int32_t)value;                                                   WIN_PORT_FIX &bsol;* cast (int32_t) */
228          memcpy(p,&i32,sizeof(i32));
229          memrev32ifbe(p);
230      } else if (encoding == ZIP_INT_64B) {
231          i64 = value;
232          memcpy(p,&i64,sizeof(i64));
233          memrev64ifbe(p);
234      } else if (encoding >= ZIP_INT_IMM_MIN && encoding <= ZIP_INT_IMM_MAX) {
235      } else {
236          assert(NULL);
237      }
238  }
239  int64_t zipLoadInteger(unsigned char *p, unsigned char encoding) {
240      int16_t i16;
241      int32_t i32;
242      int64_t i64, ret = 0;
243      if (encoding == ZIP_INT_8B) {
244          ret = ((int8_t*)p)[0];
245      } else if (encoding == ZIP_INT_16B) {
246          memcpy(&i16,p,sizeof(i16));
247          memrev16ifbe(&i16);
248          ret = i16;
249      } else if (encoding == ZIP_INT_32B) {
250          memcpy(&i32,p,sizeof(i32));
251          memrev32ifbe(&i32);
252          ret = i32;
253      } else if (encoding == ZIP_INT_24B) {
254          i32 = 0;
255          memcpy(((uint8_t*)&i32)+1,p,sizeof(i32)-sizeof(uint8_t));
256          memrev32ifbe(&i32);
257          ret = i32>>8;
258      } else if (encoding == ZIP_INT_64B) {
259          memcpy(&i64,p,sizeof(i64));
260          memrev64ifbe(&i64);
261          ret = i64;
262      } else if (encoding >= ZIP_INT_IMM_MIN && encoding <= ZIP_INT_IMM_MAX) {
263          ret = (encoding & ZIP_INT_IMM_MASK)-1;
264      } else {
265          assert(NULL);
266      }
267      return ret;
268  }
269  void zipEntry(unsigned char *p, zlentry *e) {
270      ZIP_DECODE_PREVLEN(p, e->prevrawlensize, e->prevrawlen);
271      ZIP_DECODE_LENGTH(p + e->prevrawlensize, e->encoding, e->lensize, e->len);
272      e->headersize = e->prevrawlensize + e->lensize;
273      e->p = p;
274  }
275  unsigned char *ziplistNew(void) {
276      unsigned int bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;
277      unsigned char *zl = zmalloc(bytes);
278      ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);
279      ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);
280      ZIPLIST_LENGTH(zl) = 0;
281      zl[bytes-1] = ZIP_END;
282      return zl;
283  }
284  unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {
285      zl = zrealloc(zl,len);
286      ZIPLIST_BYTES(zl) = intrev32ifbe(len);
287      zl[len-1] = ZIP_END;
288      return zl;
289  }
290  unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p) {
291      size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;
292      size_t offset, noffset, extra;
293      unsigned char *np;
294      zlentry cur, next;
295      while (p[0] != ZIP_END) {
296          zipEntry(p, &cur);
297          rawlen = cur.headersize + cur.len;
298          rawlensize = zipStorePrevEntryLength(NULL,(unsigned int)rawlen);            WIN_PORT_FIX &bsol;* cast (unsigned int) */
299          if (p[rawlen] == ZIP_END) break;
300          zipEntry(p+rawlen, &next);
301          if (next.prevrawlen == rawlen) break;
302          if (next.prevrawlensize < rawlensize) {
303              offset = p-zl;
304              extra = rawlensize-next.prevrawlensize;
305              zl = ziplistResize(zl,(unsigned int)(curlen+extra));                WIN_PORT_FIX &bsol;* cast (unsigned int) */
306              p = zl+offset;
307              np = p+rawlen;
308              noffset = np-zl;
309              if ((zl+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np) {
310                  ZIPLIST_TAIL_OFFSET(zl) =
311                      (uint32_t)intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+extra); WIN_PORT_FIX &bsol;* cast (uint32_t) */
312              }
313              memmove(np+rawlensize,
314                  np+next.prevrawlensize,
315                  curlen-noffset-next.prevrawlensize-1);
316              zipStorePrevEntryLength(np,(unsigned int)rawlen);                       WIN_PORT_FIX &bsol;* cast (unsigned int) */
317              p += rawlen;
318              curlen += extra;
319          } else {
320              if (next.prevrawlensize > rawlensize) {
321                  zipStorePrevEntryLengthLarge(p+rawlen,(unsigned int)rawlen);
322              } else {
323                  zipStorePrevEntryLength(p+rawlen,(unsigned int)rawlen);
324              }
325              break;
326          }
327      }
328      return zl;
329  }
330  unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num) {
331      unsigned int i, totlen, deleted = 0;
332      size_t offset;
333      int nextdiff = 0;
334      zlentry first, tail;
335      zipEntry(p, &first);
336      for (i = 0; p[0] != ZIP_END && i < num; i++) {
337          p += zipRawEntryLength(p);
338          deleted++;
339      }
340      totlen = (unsigned int)(p-first.p); &bsol;* Bytes taken by the element(s) to delete. */ WIN_PORT_FIX &bsol;* cast (unsigned int) */
341      if (totlen > 0) {
342          if (p[0] != ZIP_END) {
343              nextdiff = zipPrevLenByteDiff(p,first.prevrawlen);
344              p -= nextdiff;
345              zipStorePrevEntryLength(p,first.prevrawlen);
346              ZIPLIST_TAIL_OFFSET(zl) =
347                  intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))-totlen);
348              zipEntry(p, &tail);
349              if (p[tail.headersize+tail.len] != ZIP_END) {
350                  ZIPLIST_TAIL_OFFSET(zl) =
351                     intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);
352              }
353              memmove(first.p,p,
354                  intrev32ifbe(ZIPLIST_BYTES(zl))-(p-zl)-1);
355          } else {
356              ZIPLIST_TAIL_OFFSET(zl) =
357                  (unsigned int)intrev32ifbe((first.p-zl)-first.prevrawlen);      WIN_PORT_FIX &bsol;* cast (unsigned int) */
358          }
359          offset = first.p-zl;
360          zl = ziplistResize(zl, intrev32ifbe(ZIPLIST_BYTES(zl))-totlen+nextdiff);
361          ZIPLIST_INCR_LENGTH(zl,-deleted);
362          p = zl+offset;
363          if (nextdiff != 0)
364              zl = __ziplistCascadeUpdate(zl,p);
365      }
366      return zl;
367  }
368  unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {
369      size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;
370      unsigned int prevlensize, prevlen = 0;
371      size_t offset;
372      int nextdiff = 0;
373      unsigned char encoding = 0;
374      PORT_LONGLONG value = 123456789; &bsol;* initialized to avoid warning. Using a value
375                                      that is easy to see if for some reason
376                                      we use it uninitialized. */
377      zlentry tail;
378      if (p[0] != ZIP_END) {
379          ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
380      } else {
381          unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);
382          if (ptail[0] != ZIP_END) {
383              prevlen = zipRawEntryLength(ptail);
384          }
385      }
386      if (zipTryEncoding(s,slen,&value,&encoding)) {
387          reqlen = zipIntSize(encoding);
388      } else {
389          reqlen = slen;
390      }
391      reqlen += zipStorePrevEntryLength(NULL,(unsigned int)prevlen); WIN_PORT_FIX &bsol;* cast (unsigned int) */
392      reqlen += zipStoreEntryEncoding(NULL,encoding,slen);
393      int forcelarge = 0;
394      nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,(unsigned int)reqlen) : 0;  WIN_PORT_FIX &bsol;* cast (unsigned int) */
395      if (nextdiff == -4 && reqlen < 4) {
396          nextdiff = 0;
397          forcelarge = 1;
398      }
399      offset = p-zl;
400      zl = ziplistResize(zl,(unsigned int)(curlen+reqlen+nextdiff));              WIN_PORT_FIX &bsol;* cast (unsigned int) */
401      p = zl+offset;
402      if (p[0] != ZIP_END) {
403          memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);
404          if (forcelarge)
405              zipStorePrevEntryLengthLarge(p+reqlen,reqlen);
406          else
407              zipStorePrevEntryLength(p+reqlen,reqlen);
408          ZIPLIST_TAIL_OFFSET(zl) =
409              (uint32_t)intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen); WIN_PORT_FIX &bsol;* cast (uint32_t) */
410          zipEntry(p+reqlen, &tail);
411          if (p[reqlen+tail.headersize+tail.len] != ZIP_END) {
412              ZIPLIST_TAIL_OFFSET(zl) =
413                  intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);
414          }
415      } else {
416          ZIPLIST_TAIL_OFFSET(zl) = (uint32_t)intrev32ifbe(p-zl);                 WIN_PORT_FIX &bsol;* cast (uint32_) */
417      }
418      if (nextdiff != 0) {
419          offset = p-zl;
420          zl = __ziplistCascadeUpdate(zl,p+reqlen);
421          p = zl+offset;
422      }
423      p += zipStorePrevEntryLength(p,prevlen);
424      p += zipStoreEntryEncoding(p,encoding,slen);
425      if (ZIP_IS_STR(encoding)) {
426          memcpy(p,s,slen);
427      } else {
428          zipSaveInteger(p,value,encoding);
429      }
430      ZIPLIST_INCR_LENGTH(zl,1);
431      return zl;
432  }
433  unsigned char *ziplistMerge(unsigned char **first, unsigned char **second) {
434      if (first == NULL || *first == NULL || second == NULL || *second == NULL)
435          return NULL;
436      if (*first == *second)
437          return NULL;
438      size_t first_bytes = intrev32ifbe(ZIPLIST_BYTES(*first));
439      size_t first_len = intrev16ifbe(ZIPLIST_LENGTH(*first));
440      size_t second_bytes = intrev32ifbe(ZIPLIST_BYTES(*second));
441      size_t second_len = intrev16ifbe(ZIPLIST_LENGTH(*second));
442      int append;
443      unsigned char *source, *target;
444      size_t target_bytes, source_bytes;
445      if (first_len >= second_len) {
446          target = *first;
447          target_bytes = first_bytes;
448          source = *second;
449          source_bytes = second_bytes;
450          append = 1;
451      } else {
452          target = *second;
453          target_bytes = second_bytes;
454          source = *first;
455          source_bytes = first_bytes;
456          append = 0;
457      }
458      size_t zlbytes = first_bytes + second_bytes -
459                       ZIPLIST_HEADER_SIZE - ZIPLIST_END_SIZE;
460      size_t zllength = first_len + second_len;
461      zllength = zllength < UINT16_MAX ? zllength : UINT16_MAX;
462      size_t first_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*first));
463      size_t second_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*second));
464      target = zrealloc(target, zlbytes);
465      if (append) {
466          memcpy(target + target_bytes - ZIPLIST_END_SIZE,
467                 source + ZIPLIST_HEADER_SIZE,
468                 source_bytes - ZIPLIST_HEADER_SIZE);
469      } else {
470          memmove(target + source_bytes - ZIPLIST_END_SIZE,
471                  target + ZIPLIST_HEADER_SIZE,
472                  target_bytes - ZIPLIST_HEADER_SIZE);
473          memcpy(target, source, source_bytes - ZIPLIST_END_SIZE);
474      }
475      ZIPLIST_BYTES(target) = intrev32ifbe(zlbytes);
476      ZIPLIST_LENGTH(target) = intrev16ifbe(zllength);
477      ZIPLIST_TAIL_OFFSET(target) = intrev32ifbe(
478                                     (first_bytes - ZIPLIST_END_SIZE) +
479                                     (second_offset - ZIPLIST_HEADER_SIZE));
480      target = __ziplistCascadeUpdate(target, target+first_offset);
481      if (append) {
482          zfree(*second);
483          *second = NULL;
484          *first = target;
485      } else {
486          zfree(*first);
487          *first = NULL;
488          *second = target;
489      }
490      return target;
491  }
492  unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where) {
493      unsigned char *p;
494      p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);
495      return __ziplistInsert(zl,p,s,slen);
496  }
497  unsigned char *ziplistIndex(unsigned char *zl, int index) {
498      unsigned char *p;
499      unsigned int prevlensize, prevlen = 0;
500      if (index < 0) {
501          index = (-index)-1;
502          p = ZIPLIST_ENTRY_TAIL(zl);
503          if (p[0] != ZIP_END) {
504              ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
505              while (prevlen > 0 && index--) {
506                  p -= prevlen;
507                  ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
508              }
509          }
510      } else {
511          p = ZIPLIST_ENTRY_HEAD(zl);
512          while (p[0] != ZIP_END && index--) {
513              p += zipRawEntryLength(p);
514          }
515      }
516      return (p[0] == ZIP_END || index > 0) ? NULL : p;
517  }
518  unsigned char *ziplistNext(unsigned char *zl, unsigned char *p) {
519      ((void) zl);
520      if (p[0] == ZIP_END) {
521          return NULL;
522      }
523      p += zipRawEntryLength(p);
524      if (p[0] == ZIP_END) {
525          return NULL;
526      }
527      return p;
528  }
529  unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p) {
530      unsigned int prevlensize, prevlen = 0;
531      if (p[0] == ZIP_END) {
532          p = ZIPLIST_ENTRY_TAIL(zl);
533          return (p[0] == ZIP_END) ? NULL : p;
534      } else if (p == ZIPLIST_ENTRY_HEAD(zl)) {
535          return NULL;
536      } else {
537          ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
538          assert(prevlen > 0);
539          return p-prevlen;
540      }
541  }
542  unsigned int ziplistGet(unsigned char *p, unsigned char **sstr, unsigned int *slen, PORT_LONGLONG *sval) {
543      zlentry entry;
544      if (p == NULL || p[0] == ZIP_END) return 0;
545      if (sstr) *sstr = NULL;
546      zipEntry(p, &entry);
547      if (ZIP_IS_STR(entry.encoding)) {
548          if (sstr) {
549              *slen = entry.len;
550              *sstr = p+entry.headersize;
551          }
552      } else {
553          if (sval) {
554              *sval = zipLoadInteger(p+entry.headersize,entry.encoding);
555          }
556      }
557      return 1;
558  }
559  unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {
560      return __ziplistInsert(zl,p,s,slen);
561  }
562  unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p) {
563      size_t offset = *p-zl;
564      zl = __ziplistDelete(zl,*p,1);
565      *p = zl+offset;
566      return zl;
567  }
568  unsigned char *ziplistDeleteRange(unsigned char *zl, int index, unsigned int num) {
569      unsigned char *p = ziplistIndex(zl,index);
570      return (p == NULL) ? zl : __ziplistDelete(zl,p,num);
571  }
572  unsigned int ziplistCompare(unsigned char *p, unsigned char *sstr, unsigned int slen) {
573      zlentry entry;
574      unsigned char sencoding;
575      PORT_LONGLONG zval, sval;
576      if (p[0] == ZIP_END) return 0;
577      zipEntry(p, &entry);
578      if (ZIP_IS_STR(entry.encoding)) {
579          if (entry.len == slen) {
580              return memcmp(p+entry.headersize,sstr,slen) == 0;
581          } else {
582              return 0;
583          }
584      } else {
585          if (zipTryEncoding(sstr,slen,&sval,&sencoding)) {
586            zval = zipLoadInteger(p+entry.headersize,entry.encoding);
587            return zval == sval;
588          }
589      }
590      return 0;
591  }
592  unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip) {
593      int skipcnt = 0;
594      unsigned char vencoding = 0;
595      PORT_LONGLONG vll = 0;
596      while (p[0] != ZIP_END) {
597          unsigned int prevlensize, encoding, lensize, len;
598          unsigned char *q;
599          ZIP_DECODE_PREVLENSIZE(p, prevlensize);
600          ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len);
601          q = p + prevlensize + lensize;
602          if (skipcnt == 0) {
603              if (ZIP_IS_STR(encoding)) {
604                  if (len == vlen && memcmp(q, vstr, vlen) == 0) {
605                      return p;
606                  }
607              } else {
608                  if (vencoding == 0) {
609                      if (!zipTryEncoding(vstr, vlen, &vll, &vencoding)) {
610                          vencoding = UCHAR_MAX;
611                      }
612                      assert(vencoding);
613                  }
614                  if (vencoding != UCHAR_MAX) {
615                      PORT_LONGLONG ll = zipLoadInteger(q, encoding);
616                      if (ll == vll) {
617                          return p;
618                      }
619                  }
620              }
621              skipcnt = skip;
622          } else {
623              skipcnt--;
624          }
625          p = q + len;
626      }
627      return NULL;
628  }
629  unsigned int ziplistLen(unsigned char *zl) {
630      unsigned int len = 0;
631      if (intrev16ifbe(ZIPLIST_LENGTH(zl)) < UINT16_MAX) {
632          len = intrev16ifbe(ZIPLIST_LENGTH(zl));
633      } else {
634          unsigned char *p = zl+ZIPLIST_HEADER_SIZE;
635          while (*p != ZIP_END) {
636              p += zipRawEntryLength(p);
637              len++;
638          }
639          if (len < UINT16_MAX) ZIPLIST_LENGTH(zl) = intrev16ifbe(len);
640      }
641      return len;
642  }
643  size_t ziplistBlobLen(unsigned char *zl) {
644      return intrev32ifbe(ZIPLIST_BYTES(zl));
645  }
646  void ziplistRepr(unsigned char *zl) {
647      unsigned char *p;
648      int index = 0;
649      zlentry entry;
650      printf(
651          "{total bytes %d} "
652          "{num entries %u}\n"
653          "{tail offset %u}\n",
654          intrev32ifbe(ZIPLIST_BYTES(zl)),
655          intrev16ifbe(ZIPLIST_LENGTH(zl)),
656          intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)));
657      p = ZIPLIST_ENTRY_HEAD(zl);
658      while(*p != ZIP_END) {
659          zipEntry(p, &entry);
660          printf(
661              "{\n"
662                  "\taddr 0x%08lx,\n"
663                  "\tindex %2d,\n"
664                  "\toffset %5ld,\n"
665                  "\thdr+entry len: %5u,\n"
666                  "\thdr len%2u,\n"
667                  "\tprevrawlen: %5u,\n"
668                  "\tprevrawlensize: %2u,\n"
669                  "\tpayload %5u\n",
670              (PORT_ULONG)p,
671              index,
672              (PORT_ULONG) (p-zl),
673              entry.headersize+entry.len,
674              entry.headersize,
675              entry.prevrawlen,
676              entry.prevrawlensize,
677              entry.len);
678          printf("\tbytes: ");
679          for (unsigned int i = 0; i < entry.headersize+entry.len; i++) {
680              printf("%02x|",p[i]);
681          }
682          printf("\n");
683          p += entry.headersize;
684          if (ZIP_IS_STR(entry.encoding)) {
685              printf("\t[str]");
686              if (entry.len > 40) {
687                  if (fwrite(p,40,1,stdout) == 0) perror("fwrite");
688                  printf("...");
689              } else {
690                  if (entry.len &&
691                      fwrite(p,entry.len,1,stdout) == 0) perror("fwrite");
692              }
693          } else {
694              printf("\t[int]%lld", (PORT_LONGLONG) zipLoadInteger(p,entry.encoding));
695          }
696          printf("\n}\n");
697          p += entry.len;
698          index++;
699      }
700      printf("{end}\n\n");
701  }
702  #ifdef REDIS_TEST
703  #include <sys/time.h>
704  #include "adlist.h"
705  #include "sds.h"
706  #define debug(f, ...) { if (DEBUG) printf(f, __VA_ARGS__); }
707  static unsigned char *createList() {
708      unsigned char *zl = ziplistNew();
709      zl = ziplistPush(zl, (unsigned char*)"foo", 3, ZIPLIST_TAIL);
710      zl = ziplistPush(zl, (unsigned char*)"quux", 4, ZIPLIST_TAIL);
711      zl = ziplistPush(zl, (unsigned char*)"hello", 5, ZIPLIST_HEAD);
712      zl = ziplistPush(zl, (unsigned char*)"1024", 4, ZIPLIST_TAIL);
713      return zl;
714  }
715  static unsigned char *createIntList() {
716      unsigned char *zl = ziplistNew();
717      char buf[32];
718      sprintf(buf, "100");
719      zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
720      sprintf(buf, "128000");
721      zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
722      sprintf(buf, "-100");
723      zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_HEAD);
724      sprintf(buf, "4294967296");
725      zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_HEAD);
726      sprintf(buf, "non integer");
727      zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
728      sprintf(buf, "much much longer non integer");
729      zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
730      return zl;
731  }
732  static PORT_LONGLONG usec(void) {
733  #ifdef _WIN32
734      return GetHighResRelativeTime(1000000);
735  #else
736      struct timeval tv;
737      gettimeofday(&tv,NULL);
738      return (((long long)tv.tv_sec)*1000000)+tv.tv_usec;
739  #endif
740  }
741  static void stress(int pos, int num, int maxsize, int dnum) {
742      int i,j,k;
743      unsigned char *zl;
744      char posstr[2][5] = { "HEAD", "TAIL" };
745      PORT_LONGLONG start;
746      for (i = 0; i < maxsize; i+=dnum) {
747          zl = ziplistNew();
748          for (j = 0; j < i; j++) {
749              zl = ziplistPush(zl,(unsigned char*)"quux",4,ZIPLIST_TAIL);
750          }
751          start = usec();
752          for (k = 0; k < num; k++) {
753              zl = ziplistPush(zl,(unsigned char*)"quux",4,pos);
754              zl = ziplistDeleteRange(zl,0,1);
755          }
756          printf("List size: %8d, bytes: %8d, %dx push+pop (%s): %6lld usec\n",
757              i,intrev32ifbe(ZIPLIST_BYTES(zl)),num,posstr[pos],usec()-start);
758          zfree(zl);
759      }
760  }
761  static unsigned char *pop(unsigned char *zl, int where) {
762      unsigned char *p, *vstr;
763      unsigned int vlen;
764      PORT_LONGLONG vlong;
765      p = ziplistIndex(zl,where == ZIPLIST_HEAD ? 0 : -1);
766      if (ziplistGet(p,&vstr,&vlen,&vlong)) {
767          if (where == ZIPLIST_HEAD)
768              printf("Pop head: ");
769          else
770              printf("Pop tail: ");
771          if (vstr) {
772              if (vlen && fwrite(vstr,vlen,1,stdout) == 0) perror("fwrite");
773          }
774          else {
775              printf("%lld", vlong);
776          }
777          printf("\n");
778          return ziplistDelete(zl,&p);
779      } else {
780          printf("ERROR: Could not pop\n");
781          exit(1);
782      }
783  }
784  static int randstring(char *target, unsigned int min, unsigned int max) {
785      int p = 0;
786      int len = min+rand()%(max-min+1);
787      int minval, maxval;
788      switch(rand() % 3) {
789      case 0:
790          minval = 0;
791          maxval = 255;
792      break;
793      case 1:
794          minval = 48;
795          maxval = 122;
796      break;
797      case 2:
798          minval = 48;
799          maxval = 52;
800      break;
801      default:
802          assert(NULL);
803      }
804      while(p < len)
805          target[p++] = minval+rand()%(maxval-minval+1);
806      return len;
807  }
808  static void verify(unsigned char *zl, zlentry *e) {
809      int len = ziplistLen(zl);
810      zlentry _e;
811      ZIPLIST_ENTRY_ZERO(&_e);
812      for (int i = 0; i < len; i++) {
813          memset(&e[i], 0, sizeof(zlentry));
814          zipEntry(ziplistIndex(zl, i), &e[i]);
815          memset(&_e, 0, sizeof(zlentry));
816          zipEntry(ziplistIndex(zl, -len+i), &_e);
817          assert(memcmp(&e[i], &_e, sizeof(zlentry)) == 0);
818      }
819  }
820  int ziplistTest(int argc, char **argv) {
821      unsigned char *zl, *p;
822      unsigned char *entry;
823      unsigned int elen;
824      PORT_LONGLONG value;
825      if (argc == 2)
826          srand(atoi(argv[1]));
827      zl = createIntList();
828      ziplistRepr(zl);
829      zfree(zl);
830      zl = createList();
831      ziplistRepr(zl);
832      zl = pop(zl,ZIPLIST_TAIL);
833      ziplistRepr(zl);
834      zl = pop(zl,ZIPLIST_HEAD);
835      ziplistRepr(zl);
836      zl = pop(zl,ZIPLIST_TAIL);
837      ziplistRepr(zl);
838      zl = pop(zl,ZIPLIST_TAIL);
839      ziplistRepr(zl);
840      zfree(zl);
841      printf("Get element at index 3:\n");
842      {
843          zl = createList();
844          p = ziplistIndex(zl, 3);
845          if (!ziplistGet(p, &entry, &elen, &value)) {
846              printf("ERROR: Could not access index 3\n");
847              return 1;
848          }
849          if (entry) {
850              if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
851              printf("\n");
852          } else {
853              printf("%lld\n", value);
854          }
855          printf("\n");
856          zfree(zl);
857      }
858      printf("Get element at index 4 (out of range):\n");
859      {
860          zl = createList();
861          p = ziplistIndex(zl, 4);
862          if (p == NULL) {
863              printf("No entry\n");
864          } else {
865              printf("ERROR: Out of range index should return NULL, returned offset: %ld\n", p-zl);
866              return 1;
867          }
868          printf("\n");
869          zfree(zl);
870      }
871      printf("Get element at index -1 (last element):\n");
872      {
873          zl = createList();
874          p = ziplistIndex(zl, -1);
875          if (!ziplistGet(p, &entry, &elen, &value)) {
876              printf("ERROR: Could not access index -1\n");
877              return 1;
878          }
879          if (entry) {
880              if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
881              printf("\n");
882          } else {
883              printf("%lld\n", value);
884          }
885          printf("\n");
886          zfree(zl);
887      }
888      printf("Get element at index -4 (first element):\n");
889      {
890          zl = createList();
891          p = ziplistIndex(zl, -4);
892          if (!ziplistGet(p, &entry, &elen, &value)) {
893              printf("ERROR: Could not access index -4\n");
894              return 1;
895          }
896          if (entry) {
897              if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
898              printf("\n");
899          } else {
900              printf("%lld\n", value);
901          }
902          printf("\n");
903          zfree(zl);
904      }
905      printf("Get element at index -5 (reverse out of range):\n");
906      {
907          zl = createList();
908          p = ziplistIndex(zl, -5);
909          if (p == NULL) {
910              printf("No entry\n");
911          } else {
912              printf("ERROR: Out of range index should return NULL, returned offset: %ld\n", p-zl);
913              return 1;
914          }
915          printf("\n");
916          zfree(zl);
917      }
918      printf("Iterate list from 0 to end:\n");
919      {
920          zl = createList();
921          p = ziplistIndex(zl, 0);
922          while (ziplistGet(p, &entry, &elen, &value)) {
923              printf("Entry: ");
924              if (entry) {
925                  if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
926              } else {
927                  printf("%lld", value);
928              }
929              p = ziplistNext(zl,p);
930              printf("\n");
931          }
932          printf("\n");
933          zfree(zl);
934      }
935      printf("Iterate list from 1 to end:\n");
936      {
937          zl = createList();
938          p = ziplistIndex(zl, 1);
939          while (ziplistGet(p, &entry, &elen, &value)) {
940              printf("Entry: ");
941              if (entry) {
942                  if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
943              } else {
944                  printf("%lld", value);
945              }
946              p = ziplistNext(zl,p);
947              printf("\n");
948          }
949          printf("\n");
950          zfree(zl);
951      }
952      printf("Iterate list from 2 to end:\n");
953      {
954          zl = createList();
955          p = ziplistIndex(zl, 2);
956          while (ziplistGet(p, &entry, &elen, &value)) {
957              printf("Entry: ");
958              if (entry) {
959                  if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
960              } else {
961                  printf("%lld", value);
962              }
963              p = ziplistNext(zl,p);
964              printf("\n");
965          }
966          printf("\n");
967          zfree(zl);
968      }
969      printf("Iterate starting out of range:\n");
970      {
971          zl = createList();
972          p = ziplistIndex(zl, 4);
973          if (!ziplistGet(p, &entry, &elen, &value)) {
974              printf("No entry\n");
975          } else {
976              printf("ERROR\n");
977          }
978          printf("\n");
979          zfree(zl);
980      }
981      printf("Iterate from back to front:\n");
982      {
983          zl = createList();
984          p = ziplistIndex(zl, -1);
985          while (ziplistGet(p, &entry, &elen, &value)) {
986              printf("Entry: ");
987              if (entry) {
988                  if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
989              } else {
990                  printf("%lld", value);
991              }
992              p = ziplistPrev(zl,p);
993              printf("\n");
994          }
995          printf("\n");
996          zfree(zl);
997      }
998      printf("Iterate from back to front, deleting all items:\n");
999      {
1000          zl = createList();
1001          p = ziplistIndex(zl, -1);
1002          while (ziplistGet(p, &entry, &elen, &value)) {
1003              printf("Entry: ");
1004              if (entry) {
1005                  if (elen && fwrite(entry,elen,1,stdout) == 0) perror("fwrite");
1006              } else {
1007                  printf("%lld", value);
1008              }
1009              zl = ziplistDelete(zl,&p);
1010              p = ziplistPrev(zl,p);
1011              printf("\n");
1012          }
1013          printf("\n");
1014          zfree(zl);
1015      }
1016      printf("Delete inclusive range 0,0:\n");
1017      {
1018          zl = createList();
1019          zl = ziplistDeleteRange(zl, 0, 1);
1020          ziplistRepr(zl);
1021          zfree(zl);
1022      }
1023      printf("Delete inclusive range 0,1:\n");
1024      {
1025          zl = createList();
1026          zl = ziplistDeleteRange(zl, 0, 2);
1027          ziplistRepr(zl);
1028          zfree(zl);
1029      }
1030      printf("Delete inclusive range 1,2:\n");
1031      {
1032          zl = createList();
1033          zl = ziplistDeleteRange(zl, 1, 2);
1034          ziplistRepr(zl);
1035          zfree(zl);
1036      }
1037      printf("Delete with start index out of range:\n");
1038      {
1039          zl = createList();
1040          zl = ziplistDeleteRange(zl, 5, 1);
1041          ziplistRepr(zl);
1042          zfree(zl);
1043      }
1044      printf("Delete with num overflow:\n");
1045      {
1046          zl = createList();
1047          zl = ziplistDeleteRange(zl, 1, 5);
1048          ziplistRepr(zl);
1049          zfree(zl);
1050      }
1051      printf("Delete foo while iterating:\n");
1052      {
1053          zl = createList();
1054          p = ziplistIndex(zl,0);
1055          while (ziplistGet(p,&entry,&elen,&value)) {
1056              if (entry && strncmp("foo",(char*)entry,elen) == 0) {
1057                  printf("Delete foo\n");
1058                  zl = ziplistDelete(zl,&p);
1059              } else {
1060                  printf("Entry: ");
1061                  if (entry) {
1062                      if (elen && fwrite(entry,elen,1,stdout) == 0)
1063                          perror("fwrite");
1064                  } else {
1065                      printf("%lld",value);
1066                  }
1067                  p = ziplistNext(zl,p);
1068                  printf("\n");
1069              }
1070          }
1071          printf("\n");
1072          ziplistRepr(zl);
1073          zfree(zl);
1074      }
1075      printf("Regression test for >255 byte strings:\n");
1076      {
1077          char v1[257] = {0}, v2[257] = {0};
1078          memset(v1,'x',256);
1079          memset(v2,'y',256);
1080          zl = ziplistNew();
1081          zl = ziplistPush(zl,(unsigned char*)v1,strlen(v1),ZIPLIST_TAIL);
1082          zl = ziplistPush(zl,(unsigned char*)v2,strlen(v2),ZIPLIST_TAIL);
1083          p = ziplistIndex(zl,0);
1084          assert(ziplistGet(p,&entry,&elen,&value));
1085          assert(strncmp(v1,(char*)entry,elen) == 0);
1086          p = ziplistIndex(zl,1);
1087          assert(ziplistGet(p,&entry,&elen,&value));
1088          assert(strncmp(v2,(char*)entry,elen) == 0);
1089          printf("SUCCESS\n\n");
1090          zfree(zl);
1091      }
1092      printf("Regression test deleting next to last entries:\n");
1093      {
1094          char v[3][257] = {{0}};
1095          zlentry e[3] = {{.prevrawlensize = 0, .prevrawlen = 0, .lensize = 0,
1096                           .len = 0, .headersize = 0, .encoding = 0, .p = NULL}};
1097          size_t i;
1098          for (i = 0; i < (sizeof(v)/sizeof(v[0])); i++) {
1099              memset(v[i], 'a' + i, sizeof(v[0]));
1100          }
1101          v[0][256] = '\0';
1102          v[1][  1] = '\0';
1103          v[2][256] = '\0';
1104          zl = ziplistNew();
1105          for (i = 0; i < (sizeof(v)/sizeof(v[0])); i++) {
1106              zl = ziplistPush(zl, (unsigned char *) v[i], strlen(v[i]), ZIPLIST_TAIL);
1107          }
1108          verify(zl, e);
1109          assert(e[0].prevrawlensize == 1);
1110          assert(e[1].prevrawlensize == 5);
1111          assert(e[2].prevrawlensize == 1);
1112          unsigned char *p = e[1].p;
1113          zl = ziplistDelete(zl, &p);
1114          verify(zl, e);
1115          assert(e[0].prevrawlensize == 1);
1116          assert(e[1].prevrawlensize == 5);
1117          printf("SUCCESS\n\n");
1118          zfree(zl);
1119      }
1120      printf("Create long list and check indices:\n");
1121      {
1122          zl = ziplistNew();
1123          char buf[32];
1124          int i,len;
1125          for (i = 0; i < 1000; i++) {
1126              len = sprintf(buf,"%d",i);
1127              zl = ziplistPush(zl,(unsigned char*)buf,len,ZIPLIST_TAIL);
1128          }
1129          for (i = 0; i < 1000; i++) {
1130              p = ziplistIndex(zl,i);
1131              assert(ziplistGet(p,NULL,NULL,&value));
1132              assert(i == value);
1133              p = ziplistIndex(zl,-i-1);
1134              assert(ziplistGet(p,NULL,NULL,&value));
1135              assert(999-i == value);
1136          }
1137          printf("SUCCESS\n\n");
1138          zfree(zl);
1139      }
1140      printf("Compare strings with ziplist entries:\n");
1141      {
1142          zl = createList();
1143          p = ziplistIndex(zl,0);
1144          if (!ziplistCompare(p,(unsigned char*)"hello",5)) {
1145              printf("ERROR: not \"hello\"\n");
1146              return 1;
1147          }
1148          if (ziplistCompare(p,(unsigned char*)"hella",5)) {
1149              printf("ERROR: \"hella\"\n");
1150              return 1;
1151          }
1152          p = ziplistIndex(zl,3);
1153          if (!ziplistCompare(p,(unsigned char*)"1024",4)) {
1154              printf("ERROR: not \"1024\"\n");
1155              return 1;
1156          }
1157          if (ziplistCompare(p,(unsigned char*)"1025",4)) {
1158              printf("ERROR: \"1025\"\n");
1159              return 1;
1160          }
1161          printf("SUCCESS\n\n");
1162          zfree(zl);
1163      }
1164      printf("Merge test:\n");
1165      {
1166          zl = createList();
1167          unsigned char *zl2 = createList();
1168          unsigned char *zl3 = ziplistNew();
1169          unsigned char *zl4 = ziplistNew();
1170          if (ziplistMerge(&zl4, &zl4)) {
1171              printf("ERROR: Allowed merging of one ziplist into itself.\n");
1172              return 1;
1173          }
1174          zl4 = ziplistMerge(&zl3, &zl4);
1175          ziplistRepr(zl4);
1176          if (ziplistLen(zl4)) {
1177              printf("ERROR: Merging two empty ziplists created entries.\n");
1178              return 1;
1179          }
1180          zfree(zl4);
1181          zl2 = ziplistMerge(&zl, &zl2);
1182          ziplistRepr(zl2);
1183          if (ziplistLen(zl2) != 8) {
1184              printf("ERROR: Merged length not 8, but: %u\n", ziplistLen(zl2));
1185              return 1;
1186          }
1187          p = ziplistIndex(zl2,0);
1188          if (!ziplistCompare(p,(unsigned char*)"hello",5)) {
1189              printf("ERROR: not \"hello\"\n");
1190              return 1;
1191          }
1192          if (ziplistCompare(p,(unsigned char*)"hella",5)) {
1193              printf("ERROR: \"hella\"\n");
1194              return 1;
1195          }
1196          p = ziplistIndex(zl2,3);
1197          if (!ziplistCompare(p,(unsigned char*)"1024",4)) {
1198              printf("ERROR: not \"1024\"\n");
1199              return 1;
1200          }
1201          if (ziplistCompare(p,(unsigned char*)"1025",4)) {
1202              printf("ERROR: \"1025\"\n");
1203              return 1;
1204          }
1205          p = ziplistIndex(zl2,4);
1206          if (!ziplistCompare(p,(unsigned char*)"hello",5)) {
1207              printf("ERROR: not \"hello\"\n");
1208              return 1;
1209          }
1210          if (ziplistCompare(p,(unsigned char*)"hella",5)) {
1211              printf("ERROR: \"hella\"\n");
1212              return 1;
1213          }
1214          p = ziplistIndex(zl2,7);
1215          if (!ziplistCompare(p,(unsigned char*)"1024",4)) {
1216              printf("ERROR: not \"1024\"\n");
1217              return 1;
1218          }
1219          if (ziplistCompare(p,(unsigned char*)"1025",4)) {
1220              printf("ERROR: \"1025\"\n");
1221              return 1;
1222          }
1223          printf("SUCCESS\n\n");
1224          zfree(zl);
1225      }
1226      printf("Stress with random payloads of different encoding:\n");
1227      {
1228          int i,j,len,where;
1229          unsigned char *p;
1230          char buf[1024];
1231          int buflen;
1232          list *ref;
1233          listNode *refnode;
1234          unsigned char *sstr;
1235          unsigned int slen;
1236          PORT_LONGLONG sval;
1237          for (i = 0; i < 20000; i++) {
1238              zl = ziplistNew();
1239              ref = listCreate();
1240              listSetFreeMethod(ref,(void (*)(void*))sdsfree);
1241              len = rand() % 256;
1242              for (j = 0; j < len; j++) {
1243                  where = (rand() & 1) ? ZIPLIST_HEAD : ZIPLIST_TAIL;
1244                  if (rand() % 2) {
1245                      buflen = randstring(buf,1,sizeof(buf)-1);
1246                  } else {
1247                      switch(rand() % 3) {
1248                      case 0:
1249                          buflen = sprintf(buf,"%lld",(0LL + rand()) >> 20);
1250                          break;
1251                      case 1:
1252                          buflen = sprintf(buf,"%lld",(0LL + rand()));
1253                          break;
1254                      case 2:
1255                          buflen = sprintf(buf,"%lld",(0LL + rand()) << 20);
1256                          break;
1257                      default:
1258                          assert(NULL);
1259                      }
1260                  }
1261                  zl = ziplistPush(zl, (unsigned char*)buf, buflen, where);
1262                  if (where == ZIPLIST_HEAD) {
1263                      listAddNodeHead(ref,sdsnewlen(buf, buflen));
1264                  } else if (where == ZIPLIST_TAIL) {
1265                      listAddNodeTail(ref,sdsnewlen(buf, buflen));
1266                  } else {
1267                      assert(NULL);
1268                  }
1269              }
1270              assert(listLength(ref) == ziplistLen(zl));
1271              for (j = 0; j < len; j++) {
1272                  p = ziplistIndex(zl,j);
1273                  refnode = listIndex(ref,j);
1274                  assert(ziplistGet(p,&sstr,&slen,&sval));
1275                  if (sstr == NULL) {
1276                      buflen = sprintf(buf,"%lld",sval);
1277                  } else {
1278                      buflen = slen;
1279                      memcpy(buf,sstr,buflen);
1280                      buf[buflen] = '\0';
1281                  }
1282                  assert(memcmp(buf,listNodeValue(refnode),buflen) == 0);
1283              }
1284              zfree(zl);
1285              listRelease(ref);
1286          }
1287          printf("SUCCESS\n\n");
1288      }
1289      printf("Stress with variable ziplist size:\n");
1290      {
1291          stress(ZIPLIST_HEAD,100000,16384,256);
1292          stress(ZIPLIST_TAIL,100000,16384,256);
1293      }
1294      return 0;
1295  }
1296  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-rdb.h</h3>
            <pre><code>1  #ifndef __RDB_H
2  #define __RDB_H
3  #include <stdio.h>
4  #include "rio.h"
5  #include "server.h"
6  #define RDB_VERSION 9
7  #define RDB_6BITLEN 0
8  #define RDB_14BITLEN 1
9  #define RDB_32BITLEN 0x80
10  #define RDB_64BITLEN 0x81
11  #define RDB_ENCVAL 3
12  #define RDB_LENERR UINT64_MAX
13  #define RDB_ENC_INT8 0        &bsol;* 8 bit signed integer */
14  #define RDB_ENC_INT16 1       &bsol;* 16 bit signed integer */
15  #define RDB_ENC_INT32 2       &bsol;* 32 bit signed integer */
16  #define RDB_ENC_LZF 3         &bsol;* string compressed with FASTLZ */
17  #define RDB_TYPE_STRING 0
18  #define RDB_TYPE_LIST   1
19  #define RDB_TYPE_SET    2
20  #define RDB_TYPE_ZSET   3
21  #define RDB_TYPE_HASH   4
22  #define RDB_TYPE_ZSET_2 5 &bsol;* ZSET version 2 with doubles stored in binary. */
23  #define RDB_TYPE_MODULE 6
24  #define RDB_TYPE_MODULE_2 7 &bsol;* Module value with annotations for parsing without
<span onclick='openModal()' class='match'>25                                 the generating module being loaded. */
26  #define RDB_TYPE_HASH_ZIPMAP    9
27  #define RDB_TYPE_LIST_ZIPLIST  10
28  #define RDB_TYPE_SET_INTSET    11
</span>29  #define RDB_TYPE_ZSET_ZIPLIST  12
30  #define RDB_TYPE_HASH_ZIPLIST  13
31  #define RDB_TYPE_LIST_QUICKLIST 14
32  #define RDB_TYPE_STREAM_LISTPACKS 15
33  #define rdbIsObjectType(t) ((t >= 0 && t <= 7) || (t >= 9 && t <= 15))
34  #define RDB_OPCODE_MODULE_AUX 247   &bsol;* Module auxiliary data. */
35  #define RDB_OPCODE_IDLE       248   &bsol;* LRU idle time. */
36  #define RDB_OPCODE_FREQ       249   &bsol;* LFU frequency. */
37  #define RDB_OPCODE_AUX        250   &bsol;* RDB aux field. */
38  #define RDB_OPCODE_RESIZEDB   251   &bsol;* Hash table resize hint. */
39  #define RDB_OPCODE_EXPIRETIME_MS 252    &bsol;* Expire time in milliseconds. */
40  #define RDB_OPCODE_EXPIRETIME 253       &bsol;* Old expire time in seconds. */
41  #define RDB_OPCODE_SELECTDB   254   &bsol;* DB number of the following keys. */
42  #define RDB_OPCODE_EOF        255   &bsol;* End of the RDB file. */
43  #define RDB_MODULE_OPCODE_EOF   0   &bsol;* End of module value. */
44  #define RDB_MODULE_OPCODE_SINT  1   &bsol;* Signed integer. */
45  #define RDB_MODULE_OPCODE_UINT  2   &bsol;* Unsigned integer. */
46  #define RDB_MODULE_OPCODE_FLOAT 3   &bsol;* Float. */
47  #define RDB_MODULE_OPCODE_DOUBLE 4  &bsol;* Double. */
48  #define RDB_MODULE_OPCODE_STRING 5  &bsol;* String. */
49  #define RDB_LOAD_NONE   0
50  #define RDB_LOAD_ENC    (1<<0)
51  #define RDB_LOAD_PLAIN  (1<<1)
52  #define RDB_LOAD_SDS    (1<<2)
53  #define RDB_SAVE_NONE 0
54  #define RDB_SAVE_AOF_PREAMBLE (1<<0)
55  int rdbSaveType(rio *rdb, unsigned char type);
56  int rdbLoadType(rio *rdb);
57  int rdbSaveTime(rio *rdb, time_t t);
58  time_t rdbLoadTime(rio *rdb);
59  int rdbSaveLen(rio *rdb, uint64_t len);
60  int rdbSaveMillisecondTime(rio *rdb, PORT_LONGLONG t);
61  PORT_LONGLONG rdbLoadMillisecondTime(rio *rdb, int rdbver);
62  uint64_t rdbLoadLen(rio *rdb, int *isencoded);
63  int rdbLoadLenByRef(rio *rdb, int *isencoded, uint64_t *lenptr);
64  int rdbSaveObjectType(rio *rdb, robj *o);
65  int rdbLoadObjectType(rio *rdb);
66  int rdbLoad(char *filename, rdbSaveInfo *rsi);
67  int rdbSaveBackground(char *filename, rdbSaveInfo *rsi);
68  int rdbSaveToSlavesSockets(rdbSaveInfo *rsi);
69  void rdbRemoveTempFile(pid_t childpid);
70  int rdbSave(char *filename, rdbSaveInfo *rsi);
71  ssize_t rdbSaveObject(rio *rdb, robj *o, robj *key);
72  size_t rdbSavedObjectLen(robj *o);
73  robj *rdbLoadObject(int type, rio *rdb, robj *key);
74  void backgroundSaveDoneHandler(int exitcode, int bysignal);
75  int rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val, PORT_LONGLONG expiretime);
76  ssize_t rdbSaveSingleModuleAux(rio *rdb, int when, moduleType *mt);
77  robj *rdbLoadCheckModuleValue(rio *rdb, char *modulename);
78  robj *rdbLoadStringObject(rio *rdb);
79  ssize_t rdbSaveStringObject(rio *rdb, robj *obj);
80  ssize_t rdbSaveRawString(rio *rdb, unsigned char *s, size_t len);
81  void *rdbGenericLoadStringObject(rio *rdb, int flags, size_t *lenptr);
82  int rdbSaveBinaryDoubleValue(rio *rdb, double val);
83  int rdbLoadBinaryDoubleValue(rio *rdb, double *val);
84  int rdbSaveBinaryFloatValue(rio *rdb, float val);
85  int rdbLoadBinaryFloatValue(rio *rdb, float *val);
86  int rdbLoadRio(rio *rdb, rdbSaveInfo *rsi, int loading_aof);
87  rdbSaveInfo *rdbPopulateSaveInfo(rdbSaveInfo *rsi);
88  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-ziplist.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-rdb.h</div>
                </div>
                <div class="column column_space"><pre><code>20                                 representing the previous entry len. */
21  #define ZIP_STR_MASK 0xc0
22  #define ZIP_INT_MASK 0x30
23  #define ZIP_STR_06B (0 << 6)
</pre></code></div>
                <div class="column column_space"><pre><code>25                                 the generating module being loaded. */
26  #define RDB_TYPE_HASH_ZIPMAP    9
27  #define RDB_TYPE_LIST_ZIPLIST  10
28  #define RDB_TYPE_SET_INTSET    11
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    