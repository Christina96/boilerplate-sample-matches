<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for match.c &amp; mosaic1.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for match.c &amp; mosaic1.c
      </h3>
<h1 align="center">
        33.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>match.c (49.65035%)<th>mosaic1.c (25.724638%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(195-352)<td><a href="#" name="0">(505-689)</a><td align="center"><font color="#ff0000">38</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(175-193)<td><a href="#" name="1">(468-485)</a><td align="center"><font color="#720000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(91-113)<td><a href="#" name="2">(414-436)</a><td align="center"><font color="#6b0000">16</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>match.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;math.h&gt;
6 #include &lt;vips/vips.h&gt;
7 #include &lt;vips/internal.h&gt;
8 #include "pmosaicing.h"
9 int 
10 vips__coeff( int xr1, int yr1, int xs1, int ys1, 
11 	int xr2, int yr2, int xs2, int ys2, 
12 	double *a, double *b, double *dx, double *dy )
13 {
14 	VipsImage **t = VIPS_ARRAY( NULL, 2, VipsImage * );
15 	if( !(t[0] = vips_image_new_matrixv( 4, 4,
16 		(double)xs1, (double)-ys1, 1.0, 0.0,
17 		(double)ys1, (double)xs1, 0.0, 1.0,
18 		(double)xs2, (double)-ys2, 1.0, 0.0,
19 		(double)ys2, (double)xs2, 0.0, 1.0 )) ) {
20 		g_free( t );
21 		return( -1 );
22 	}
23 	if( vips_matrixinvert( t[0], &amp;t[1], NULL ) ) {
24 		g_object_unref( t[0] );
25 		g_free( t );
26 		return( -1 );
27 	}
28 	*a = *VIPS_MATRIX( t[1], 0, 0 ) * xr1 + *VIPS_MATRIX( t[1], 0, 1 ) * yr1 +
29 		*VIPS_MATRIX( t[1], 0, 2 ) * xr2 + *VIPS_MATRIX( t[1], 0, 3 ) * yr2;
30 	*b = *VIPS_MATRIX( t[1], 1, 0 ) * xr1 + *VIPS_MATRIX( t[1], 1, 1 ) * yr1 +
31 		*VIPS_MATRIX( t[1], 1, 2 ) * xr2 + *VIPS_MATRIX( t[1], 1, 3 ) * yr2;
32 	*dx= *VIPS_MATRIX( t[1], 2, 0 ) * xr1 + *VIPS_MATRIX( t[1], 2, 1 ) * yr1 +
33 		*VIPS_MATRIX( t[1], 2, 2 ) * xr2 + *VIPS_MATRIX( t[1], 2, 3 ) * yr2;
34 	*dy= *VIPS_MATRIX( t[1], 3, 0 ) * xr1 + *VIPS_MATRIX( t[1], 3, 1 ) * yr1 +
35 		*VIPS_MATRIX( t[1], 3, 2 ) * xr2 + *VIPS_MATRIX( t[1], 3, 3 ) * yr2;
36 	g_object_unref( t[0] );
37 	g_object_unref( t[1] );
38 	g_free( t );
39 	return( 0 );
40 }
41 typedef struct {
42 	VipsOperation parent_instance;
43 <a name="2"></a>	VipsImage *ref;
44 	VipsImage *sec;
45 	VipsImage *out;
46 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	int xr1;
47 	int yr1;
48 	int xs1;
49 	int ys1;
50 	int xr2;
51 	int yr2;
52 	int xs2;
53 	int ys2;
54 	int hwindow;
55 	int harea;
56 	gboolean search;
57 	VipsInterpolate *interpolate;
58 } VipsMatch;
59 typedef VipsOperationClass VipsMatchClass;
60 G_DEFINE_TYPE( VipsMatch, vips_match, VIPS_TYPE_OPERATION );
61 static int
62 vips_match_build( VipsObject *object )
63 {
64 	VipsMatch *match = (VipsMatch *) object;</b></font>
65 	double a, b, dx, dy;
66 	VipsArrayInt *oarea;
67 	VipsImage *x;
68 	g_object_set( match, "out", vips_image_new(), NULL ); 
69 	if( VIPS_OBJECT_CLASS( vips_match_parent_class )-&gt;build( object ) )
70 		return( -1 );
71 	if( !match-&gt;interpolate )
72 		match-&gt;interpolate = vips_interpolate_new( "bilinear" );
73 	if( match-&gt;search ) {
74 		int xs, ys;
75 		double cor;
76 		if( vips__correl( match-&gt;ref, match-&gt;sec, 
77 			match-&gt;xr1, match-&gt;yr1, match-&gt;xs1, match-&gt;ys1,
78 			match-&gt;hwindow, match-&gt;harea, 
79 			&amp;cor, &amp;xs, &amp;ys ) )
80 			return( -1 ); 
81 		match-&gt;xs1 = xs;
82 		match-&gt;ys1 = ys;
83 		if( vips__correl( match-&gt;ref, match-&gt;sec, 
84 			match-&gt;xr2, match-&gt;yr2, match-&gt;xs2, match-&gt;ys2,
85 			match-&gt;hwindow, match-&gt;harea, 
86 			&amp;cor, &amp;xs, &amp;ys ) )
87 			return( -1 ); 
88 		match-&gt;xs2 = xs;
89 		match-&gt;ys2 = ys;
90 	}
91 	if( vips__coeff( match-&gt;xr1, match-&gt;yr1, match-&gt;xs1, match-&gt;ys1, 
92 		match-&gt;xr2, match-&gt;yr2, match-&gt;xs2, match-&gt;ys2, 
93 		&amp;a, &amp;b, &amp;dx, &amp;dy ) )
94 		return( -1 );
95 	oarea = vips_array_int_newv( 4, 
96 		0, 0, match-&gt;ref-&gt;Xsize, match-&gt;ref-&gt;Ysize ); 
97 	if( vips_affine( match-&gt;sec, &amp;x,
98 		a, -b, b, a, 
99 		"interpolate", match-&gt;interpolate, 
100 		"odx", dx, 
101 		"ody", dy, 
102 		"oarea", oarea, 
103 		NULL ) ) {
104 		vips_area_unref( VIPS_AREA( oarea ) );
105 		return( -1 );
106 	}
107 	vips_area_unref( VIPS_AREA( oarea ) );
108 <a name="1"></a>
109 	if( vips_image_write( x, match-&gt;out ) ) {
110 		g_object_unref( x ); 
111 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		return( -1 ); 
112 	}
113 	g_object_unref( x ); 
114 	return( 0 );
115 }
116 static void
117 vips_match_class_init( VipsMatchClass *class )
118 {
119 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
120 	VipsObjectClass *object_class = (VipsObjectClass *) class;
121 	gobject_class-&gt;set_property = vips_object_set_property;
122 	gobject_class-&gt;get_property = vips_object_get_property;
123 	object_class-&gt;nickname = "match";
124 <a name="0"></a>	object_class-&gt;description = _( "first-order match of two images" );
125 	object_class-&gt;build = vips_match_build;</b></font>
126 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	VIPS_ARG_IMAGE( class, "ref", 1, 
127 		_( "Reference" ), 
128 		_( "Reference image" ),
129 		VIPS_ARGUMENT_REQUIRED_INPUT, 
130 		G_STRUCT_OFFSET( VipsMatch, ref ) );
131 	VIPS_ARG_IMAGE( class, "sec", 2, 
132 		_( "Secondary" ), 
133 		_( "Secondary image" ),
134 		VIPS_ARGUMENT_REQUIRED_INPUT, 
135 		G_STRUCT_OFFSET( VipsMatch, sec ) );
136 	VIPS_ARG_IMAGE( class, "out", 3, 
137 		_( "Output" ), 
138 		_( "Output image" ),
139 		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
140 		G_STRUCT_OFFSET( VipsMatch, out ) );
141 	VIPS_ARG_INT( class, "xr1", 5, 
142 		_( "xr1" ), 
143 		_( "Position of first reference tie-point" ),
144 		VIPS_ARGUMENT_REQUIRED_INPUT,
145 		G_STRUCT_OFFSET( VipsMatch, xr1 ),
146 		-1000000000, 1000000000, 1 );
147 	VIPS_ARG_INT( class, "yr1", 6, 
148 		_( "yr1" ), 
149 		_( "Position of first reference tie-point" ),
150 		VIPS_ARGUMENT_REQUIRED_INPUT,
151 		G_STRUCT_OFFSET( VipsMatch, yr1 ),
152 		-1000000000, 1000000000, 1 );
153 	VIPS_ARG_INT( class, "xs1", 7, 
154 		_( "xs1" ), 
155 		_( "Position of first secondary tie-point" ),
156 		VIPS_ARGUMENT_REQUIRED_INPUT,
157 		G_STRUCT_OFFSET( VipsMatch, xs1 ),
158 		-1000000000, 1000000000, 1 );
159 	VIPS_ARG_INT( class, "ys1", 8, 
160 		_( "ys1" ), 
161 		_( "Position of first secondary tie-point" ),
162 		VIPS_ARGUMENT_REQUIRED_INPUT,
163 		G_STRUCT_OFFSET( VipsMatch, ys1 ),
164 		-1000000000, 1000000000, 1 );
165 	VIPS_ARG_INT( class, "xr2", 9, 
166 		_( "xr2" ), 
167 		_( "Position of second reference tie-point" ),
168 		VIPS_ARGUMENT_REQUIRED_INPUT,
169 		G_STRUCT_OFFSET( VipsMatch, xr2 ),
170 		-1000000000, 1000000000, 1 );
171 	VIPS_ARG_INT( class, "yr2", 10, 
172 		_( "yr2" ), 
173 		_( "Position of second reference tie-point" ),
174 		VIPS_ARGUMENT_REQUIRED_INPUT,
175 		G_STRUCT_OFFSET( VipsMatch, yr2 ),
176 		-1000000000, 1000000000, 1 );
177 	VIPS_ARG_INT( class, "xs2", 11, 
178 		_( "xs2" ), 
179 		_( "Position of second secondary tie-point" ),
180 		VIPS_ARGUMENT_REQUIRED_INPUT,
181 		G_STRUCT_OFFSET( VipsMatch, xs2 ),
182 		-1000000000, 1000000000, 1 );
183 	VIPS_ARG_INT( class, "ys2", 12, 
184 		_( "ys2" ), 
185 		_( "Position of second secondary tie-point" ),
186 		VIPS_ARGUMENT_REQUIRED_INPUT,
187 		G_STRUCT_OFFSET( VipsMatch, ys2 ),
188 		-1000000000, 1000000000, 1 );
189 	VIPS_ARG_INT( class, "hwindow", 13, 
190 		_( "hwindow" ), 
191 		_( "Half window size" ),
192 		VIPS_ARGUMENT_OPTIONAL_INPUT,
193 		G_STRUCT_OFFSET( VipsMatch, hwindow ),
194 		0, 1000000000, 1 );
195 	VIPS_ARG_INT( class, "harea", 14, 
196 		_( "harea" ), 
197 		_( "Half area size" ),
198 		VIPS_ARGUMENT_OPTIONAL_INPUT,
199 		G_STRUCT_OFFSET( VipsMatch, harea ),
200 		0, 1000000000, 1 );
201 	VIPS_ARG_BOOL( class, "search", 15, 
202 		_( "search" ), 
203 		_( "Search to improve tie-points" ),
204 		VIPS_ARGUMENT_OPTIONAL_INPUT,
205 		G_STRUCT_OFFSET( VipsMatch, search ),
206 		FALSE ); 
207 	VIPS_ARG_INTERPOLATE( class, "interpolate", 16, 
208 		_( "Interpolate" ), 
209 		_( "Interpolate pixels with this" ),
210 		VIPS_ARGUMENT_OPTIONAL_INPUT, 
211 		G_STRUCT_OFFSET( VipsMatch, interpolate ) );
212 }
213 static void
214 vips_match_init( VipsMatch *match )
215 {
216 	match-&gt;hwindow = 5;
217 	match-&gt;harea = 15;
218 	match-&gt;search = FALSE;
219 }
220 int
221 vips_match( VipsImage *ref, VipsImage *sec, VipsImage **out, 
222 	int xr1, int yr1, int xs1, int ys1, 
223 	int xr2, int yr2, int xs2, int ys2, ... )
224 {
225 	va_list ap;
226 	int result;
227 	va_start( ap, ys2 );
228 	result = vips_call_split( "match", ap, ref, sec, out, 
229 		xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2 );
230 	va_end( ap );
231 	return( result );
232 }</b></font>
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mosaic1.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;math.h&gt;
6 #include &lt;vips/vips.h&gt;
7 #include &lt;vips/buf.h&gt;
8 #include &lt;vips/transform.h&gt;
9 #include &lt;vips/internal.h&gt;
10 #include "pmosaicing.h"
11 static int 
12 apply_similarity( VipsTransformation *trn, VipsImage *in, VipsImage *out, 
13 	double a, double b, double dx, double dy )
14 {
15 	trn-&gt;iarea.left = 0;
16 	trn-&gt;iarea.top = 0;
17 	trn-&gt;iarea.width = in-&gt;Xsize;
18 	trn-&gt;iarea.height = in-&gt;Ysize;
19 	trn-&gt;a = a;
20 	trn-&gt;b = -b;
21 	trn-&gt;c = b;
22 	trn-&gt;d = a;
23 	trn-&gt;idx = 0;
24 	trn-&gt;idy = 0;
25 	trn-&gt;odx = dx;
26 	trn-&gt;ody = dy;
27 	vips__transform_set_area( trn );
28 	if( vips__transform_calc_inverse( trn ) )
29 		return( -1 );
30 	if( vips__affinei( in, out, trn ) )
31 		return( -1 );
32 	return( 0 );
33 }
34 typedef int (*joinfn)( VipsImage *, VipsImage *, VipsImage *, 
35 	double, double, double, double, int );
36 int
37 vips__lrmerge1( VipsImage *ref, VipsImage *sec, VipsImage *out,
38 	double a, double b, double dx, double dy, int mwidth )
39 {
40 	VipsTransformation trn;
41 	VipsImage **t = (VipsImage **) 
42 		vips_object_local_array( VIPS_OBJECT( out ), 1 );
43 	VipsBuf buf;
44 	char text[1024];
45 	if( apply_similarity( &amp;trn, sec, t[0], a, b, dx, dy ) )
46 		return( -1 );
47 	if( vips__lrmerge( ref, t[0], out, 
48 		-trn.oarea.left, -trn.oarea.top, mwidth ) )
49 		return( -1 );
50 	vips__add_mosaic_name( out );
51 	vips_buf_init_static( &amp;buf, text, 1024 );
52 	vips_buf_appendf( &amp;buf, "#LRROTSCALE &lt;%s&gt; &lt;%s&gt; &lt;%s&gt; &lt;",
53 		vips__get_mosaic_name( ref ), 
54 		vips__get_mosaic_name( sec ), 
55 		vips__get_mosaic_name( out ) );  
56 	vips_buf_appendg( &amp;buf, a );
57 	vips_buf_appendf( &amp;buf, "&gt; &lt;" );
58 	vips_buf_appendg( &amp;buf, b );
59 	vips_buf_appendf( &amp;buf, "&gt; &lt;" );
60 	vips_buf_appendg( &amp;buf, dx );
61 	vips_buf_appendf( &amp;buf, "&gt; &lt;" );
62 	vips_buf_appendg( &amp;buf, dy );
63 	vips_buf_appendf( &amp;buf, "&gt; &lt;%d&gt;", mwidth );
64 	if( vips_image_history_printf( out, "%s", vips_buf_all( &amp;buf ) ) )
65 		return( -1 );
66 	return( 0 );
67 }
68 int
69 vips__tbmerge1( VipsImage *ref, VipsImage *sec, VipsImage *out,
70 	double a, double b, double dx, double dy, int mwidth )
71 {
72 	VipsTransformation trn;
73 	VipsImage **t = (VipsImage **)
74 		vips_object_local_array( VIPS_OBJECT( out ), 1 );
75 	VipsBuf buf;
76 	char text[1024];
77 	if( apply_similarity( &amp;trn, sec, t[0], a, b, dx, dy ) )
78 		return( -1 );
79 	if( vips__tbmerge( ref, t[0], out, 
80 		-trn.oarea.left, -trn.oarea.top, mwidth ) )
81 		return( -1 );
82 	vips__add_mosaic_name( out );
83 	vips_buf_init_static( &amp;buf, text, 1024 );
84 	vips_buf_appendf( &amp;buf, "#TBROTSCALE &lt;%s&gt; &lt;%s&gt; &lt;%s&gt; &lt;",
85 		vips__get_mosaic_name( ref ),
86 		vips__get_mosaic_name( sec ),
87 		vips__get_mosaic_name( out ) );  
88 	vips_buf_appendg( &amp;buf, a );
89 	vips_buf_appendf( &amp;buf, "&gt; &lt;" );
90 	vips_buf_appendg( &amp;buf, b );
91 	vips_buf_appendf( &amp;buf, "&gt; &lt;" );
92 	vips_buf_appendg( &amp;buf, dx );
93 	vips_buf_appendf( &amp;buf, "&gt; &lt;" );
94 	vips_buf_appendg( &amp;buf, dy );
95 	vips_buf_appendf( &amp;buf, "&gt; &lt;%d&gt;", mwidth );
96 	if( vips_image_history_printf( out, "%s", vips_buf_all( &amp;buf ) ) )
97 		return( -1 );
98 	return( 0 );
99 }
100 static int
101 rotjoin( VipsImage *ref, VipsImage *sec, VipsImage *out, joinfn jfn,
102 	int xr1, int yr1, int xs1, int ys1, 
103 	int xr2, int yr2, int xs2, int ys2,
104 	int mwidth )
105 { 
106 	double a, b, dx, dy;
107 	if( vips__coeff( xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2, 
108 		&amp;a, &amp;b, &amp;dx, &amp;dy ) )
109 		return( -1 );
110 	if( jfn( ref, sec, out, a, b, dx, dy, mwidth ) )
111 		return( -1 );
112 	return( 0 );
113 }
114 static int
115 rotjoin_search( VipsImage *ref, VipsImage *sec, VipsImage *out, joinfn jfn,
116 	int bandno,
117 	int xr1, int yr1, int xs1, int ys1, 
118 	int xr2, int yr2, int xs2, int ys2,
119 	int halfcorrelation, int halfarea,
120 	int balancetype,
121 	int mwidth )
122 { 
123 	VipsTransformation trn;
124 	double cor1, cor2;
125 	double a, b, dx, dy;
126 	double xs3, ys3;
127 	double xs4, ys4;
128 	int xs5, ys5;
129 	int xs6, ys6;
130 	double xs7, ys7;
131 	double xs8, ys8;
132 	VipsImage **t = (VipsImage **)
133 		vips_object_local_array( VIPS_OBJECT( out ), 3 );
134 	if( ref-&gt;Coding == VIPS_CODING_LABQ ) {
135 		if( vips_LabQ2LabS( ref, &amp;t[0], NULL ) )
136 			return( -1 );
137 	}
138 	else
139 		t[0] = ref;
140 	if( sec-&gt;Coding == VIPS_CODING_LABQ ) {
141 		if( vips_LabQ2LabS( sec, &amp;t[1], NULL ) )
142 			return( -1 );
143 	}
144 	else
145 		t[1] = sec;
146 	if( vips__coeff( xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2, 
147 		&amp;a, &amp;b, &amp;dx, &amp;dy ) ||
148 		apply_similarity( &amp;trn, t[1], t[2], a, b, dx, dy ) ) 
149 		return( -1 );
150 	vips__transform_forward_point( &amp;trn, xs1, ys1, &amp;xs3, &amp;ys3 );
151 	vips__transform_forward_point( &amp;trn, xs2, ys2, &amp;xs4, &amp;ys4 );
152 	if( vips__correl( t[0], t[2], xr1, yr1, 
153 		xs3 - trn.oarea.left, ys3 - trn.oarea.top,
154 		halfcorrelation, halfarea, &amp;cor1, &amp;xs5, &amp;ys5 ) )
155 		return( -1 );
156 	if( vips__correl( t[0], t[2], xr2, yr2, 
157 		xs4 - trn.oarea.left, ys4 - trn.oarea.top,
158 		halfcorrelation, halfarea, &amp;cor2, &amp;xs6, &amp;ys6 ) )
159 		return( -1 );
160 #ifdef DEBUG
161 	printf( "rotjoin_search: nudged pair 1 from %d, %d to %d, %d\n",
162 		xs3 - trn.oarea.left, ys3 - trn.oarea.top,
163 		xs5, ys5 );
164 	printf( "rotjoin_search: nudged pair 2 from %d, %d to %d, %d\n",
165 		xs4 - trn.oarea.left, ys4 - trn.oarea.top,
166 		xs6, ys6 );
167 	xs5 += trn.oarea.left;
168 	ys5 += trn.oarea.top;
169 	xs6 += trn.oarea.left;
170 	ys6 += trn.oarea.top;
171 	vips__transform_invert_point( &amp;trn, xs5, ys5, &amp;xs7, &amp;ys7 );
172 	vips__transform_invert_point( &amp;trn, xs6, ys6, &amp;xs8, &amp;ys8 );
173 	if( vips__coeff( xr1, yr1, xs7, ys7, xr2, yr2, xs8, ys8, 
174 		&amp;a, &amp;b, &amp;dx, &amp;dy ) )
175 		return( -1 );
176 	if( jfn( ref, sec, out, a, b, dx, dy, mwidth ) )
177 		return( -1 );
178 	return( 0 );
179 }
180 #ifdef OLD
181 static int
182 old_lrmosaic1( VipsImage *ref, VipsImage *sec, VipsImage *out,
183 	int bandno,
184 	int xr1, int yr1, int xs1, int ys1, 
185 	int xr2, int yr2, int xs2, int ys2,
186 	int halfcorrelation, int halfarea,
187 	int balancetype,
188 	int mwidth )
189 { 
190 	VipsTransformation trn1, trn2;
191 	int dx0, dy0;
192 	double a, b, dx, dy;
193 	double a1, b1, dx1, dy1;
194 	double af, bf, dxf, dyf;
195 	int xpos, ypos;
196 	int xpos1, ypos1;
197 	VipsImage **t = (VipsImage **)
198 		vips_object_local_array( VIPS_OBJECT( out ), 2 );
199 	VipsImage *dummy;
200 	if( vips__coeff( xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2, 
201 		&amp;a, &amp;b, &amp;dx, &amp;dy ) ||
202 		apply_similarity( &amp;trn1, sec, t[0], a, b, dx, dy ) )
203 		return( -1 );
204 	dummy = vips_image_new();
205 	if( vips__find_lroverlap( ref, t[0], dummy,
206 		bandno, 
207 		-trn1.area.left, -trn1.area.top, 0, 0,
208 		halfcorrelation, halfarea,
209 		&amp;dx0, &amp;dy0,
210 		&amp;a1, &amp;b1, &amp;dx1, &amp;dy1 ) ) {
211 		g_object_unref( dummy );
212 		return( -1 );
213 	}
214 	g_object_unref( dummy );
215 	af = a1 * a - b1 * b;
216 	bf = a1 * b + b1 * a;
217 	dxf = a1 * dx - b1 * dy + dx1;
218 	dyf = b1 * dx + a1 * dy + dy1;
219 	printf( "transform was: a = %g, b = %g, dx = %g, dy = %g\n",
220 		a, b, dx, dy );
221 	printf( "correction: a = %g, b = %g, dx = %g, dy = %g\n",
222 		a1, b1, dx1, dy1 );
223 	printf( "final: a = %g, b = %g, dx = %g, dy = %g\n",
224 		af, bf, dxf, dyf );
225 	if( apply_similarity( &amp;trn2, sec, t[1], af, bf, dxf, dyf ) )
226 		return( -1 );
227 	printf( "disp: trn1 left = %d, top = %d\n", 
228 		trn1.area.left, trn1.area.top );
229 	printf( "disp: trn2 left = %d, top = %d\n", 
230 		trn2.area.left, trn2.area.top );
231 	if( vips_merge( ref, t[1], out, VIPS_DIRECtION_HORIZONTAL,
232 		-trn2.area.left, -trn2.area.top, mwidth ) )
233 		return( -1 );
234 	return( 0 );
235 }
236 typedef struct {
237 	VipsOperation parent_instance;
238 	VipsImage *ref;
239 	VipsImage *sec;
240 	VipsImage *out;
241 <a name="2"></a>	VipsDirection direction;
242 	int xr1;
243 	int yr1;
244 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	int xs1;
245 	int ys1;
246 	int xr2;
247 	int yr2;
248 	int xs2;
249 	int ys2;
250 	int hwindow;
251 	int harea;
252 	gboolean search;
253 	VipsInterpolate *interpolate;
254 	int mblend;
255 	int bandno;
256 } VipsMosaic1;
257 typedef VipsOperationClass VipsMosaic1Class;
258 G_DEFINE_TYPE( VipsMosaic1, vips_mosaic1, VIPS_TYPE_OPERATION );
259 static int
260 vips_mosaic1_build( VipsObject *object )
261 {
262 	VipsMosaic1 *mosaic1 = (VipsMosaic1 *) object;</b></font>
263 	joinfn jfn;
264 	g_object_set( mosaic1, "out", vips_image_new(), NULL ); 
265 	if( VIPS_OBJECT_CLASS( vips_mosaic1_parent_class )-&gt;build( object ) )
266 		return( -1 );
267 	if( !mosaic1-&gt;interpolate )
268 		mosaic1-&gt;interpolate = vips_interpolate_new( "bilinear" );
269 	jfn = mosaic1-&gt;direction == VIPS_DIRECTION_HORIZONTAL ?
270 		vips__lrmerge1 : vips__tbmerge1;
271 	if( mosaic1-&gt;search ) {
272 		if( rotjoin_search( mosaic1-&gt;ref, mosaic1-&gt;sec, mosaic1-&gt;out, 
273 			jfn,
274 			mosaic1-&gt;bandno,
275 			mosaic1-&gt;xr1, mosaic1-&gt;yr1, mosaic1-&gt;xs1, mosaic1-&gt;ys1, 
276 			mosaic1-&gt;xr2, mosaic1-&gt;yr2, mosaic1-&gt;xs2, mosaic1-&gt;ys2,
277 			mosaic1-&gt;hwindow, mosaic1-&gt;harea, 
278 			0,
279 			mosaic1-&gt;mblend ) )
280 			return( -1 );
281 	}
282 	else {
283 		if( rotjoin( mosaic1-&gt;ref, mosaic1-&gt;sec, mosaic1-&gt;out, 
284 			jfn,
285 <a name="1"></a>			mosaic1-&gt;xr1, mosaic1-&gt;yr1, mosaic1-&gt;xs1, mosaic1-&gt;ys1, 
286 			mosaic1-&gt;xr2, mosaic1-&gt;yr2, mosaic1-&gt;xs2, mosaic1-&gt;ys2,
287 			mosaic1-&gt;mblend ) )
288 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>			return( -1 );
289 	}
290 	return( 0 );
291 }
292 static void
293 vips_mosaic1_class_init( VipsMosaic1Class *class )
294 {
295 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
296 	VipsObjectClass *object_class = (VipsObjectClass *) class;
297 	gobject_class-&gt;set_property = vips_object_set_property;
298 	gobject_class-&gt;get_property = vips_object_get_property;
299 	object_class-&gt;nickname = "mosaic1";
300 	object_class-&gt;description = _( "first-order mosaic of two images" );
301 	object_class-&gt;build = vips_mosaic1_build;</b></font>
302 	VIPS_ARG_IMAGE( class, "ref", 1, 
303 		_( "Reference" ), 
304 		_( "Reference image" ),
305 		VIPS_ARGUMENT_REQUIRED_INPUT, 
306 		G_STRUCT_OFFSET( VipsMosaic1, ref ) );
307 	VIPS_ARG_IMAGE( class, "sec", 2, 
308 		_( "Secondary" ), 
309 		_( "Secondary image" ),
310 		VIPS_ARGUMENT_REQUIRED_INPUT, 
311 		G_STRUCT_OFFSET( VipsMosaic1, sec ) );
312 	VIPS_ARG_IMAGE( class, "out", 3, 
313 		_( "Output" ), 
314 		_( "Output image" ),
315 <a name="0"></a>		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
316 		G_STRUCT_OFFSET( VipsMosaic1, out ) );
317 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	VIPS_ARG_ENUM( class, "direction", 4, 
318 		_( "Direction" ), 
319 		_( "Horizontal or vertical mosaic" ),
320 		VIPS_ARGUMENT_REQUIRED_INPUT, 
321 		G_STRUCT_OFFSET( VipsMosaic1, direction ), 
322 		VIPS_TYPE_DIRECTION, VIPS_DIRECTION_HORIZONTAL ); 
323 	VIPS_ARG_INT( class, "xr1", 5, 
324 		_( "xr1" ), 
325 		_( "Position of first reference tie-point" ),
326 		VIPS_ARGUMENT_REQUIRED_INPUT,
327 		G_STRUCT_OFFSET( VipsMosaic1, xr1 ),
328 		-1000000000, 1000000000, 1 );
329 	VIPS_ARG_INT( class, "yr1", 6, 
330 		_( "yr1" ), 
331 		_( "Position of first reference tie-point" ),
332 		VIPS_ARGUMENT_REQUIRED_INPUT,
333 		G_STRUCT_OFFSET( VipsMosaic1, yr1 ),
334 		-1000000000, 1000000000, 1 );
335 	VIPS_ARG_INT( class, "xs1", 7, 
336 		_( "xs1" ), 
337 		_( "Position of first secondary tie-point" ),
338 		VIPS_ARGUMENT_REQUIRED_INPUT,
339 		G_STRUCT_OFFSET( VipsMosaic1, xs1 ),
340 		-1000000000, 1000000000, 1 );
341 	VIPS_ARG_INT( class, "ys1", 8, 
342 		_( "ys1" ), 
343 		_( "Position of first secondary tie-point" ),
344 		VIPS_ARGUMENT_REQUIRED_INPUT,
345 		G_STRUCT_OFFSET( VipsMosaic1, ys1 ),
346 		-1000000000, 1000000000, 1 );
347 	VIPS_ARG_INT( class, "xr2", 9, 
348 		_( "xr2" ), 
349 		_( "Position of second reference tie-point" ),
350 		VIPS_ARGUMENT_REQUIRED_INPUT,
351 		G_STRUCT_OFFSET( VipsMosaic1, xr2 ),
352 		-1000000000, 1000000000, 1 );
353 	VIPS_ARG_INT( class, "yr2", 10, 
354 		_( "yr2" ), 
355 		_( "Position of second reference tie-point" ),
356 		VIPS_ARGUMENT_REQUIRED_INPUT,
357 		G_STRUCT_OFFSET( VipsMosaic1, yr2 ),
358 		-1000000000, 1000000000, 1 );
359 	VIPS_ARG_INT( class, "xs2", 11, 
360 		_( "xs2" ), 
361 		_( "Position of second secondary tie-point" ),
362 		VIPS_ARGUMENT_REQUIRED_INPUT,
363 		G_STRUCT_OFFSET( VipsMosaic1, xs2 ),
364 		-1000000000, 1000000000, 1 );
365 	VIPS_ARG_INT( class, "ys2", 12, 
366 		_( "ys2" ), 
367 		_( "Position of second secondary tie-point" ),
368 		VIPS_ARGUMENT_REQUIRED_INPUT,
369 		G_STRUCT_OFFSET( VipsMosaic1, ys2 ),
370 		-1000000000, 1000000000, 1 );
371 	VIPS_ARG_INT( class, "hwindow", 13, 
372 		_( "hwindow" ), 
373 		_( "Half window size" ),
374 		VIPS_ARGUMENT_OPTIONAL_INPUT,
375 		G_STRUCT_OFFSET( VipsMosaic1, hwindow ),
376 		0, 1000000000, 5 );
377 	VIPS_ARG_INT( class, "harea", 14, 
378 		_( "harea" ), 
379 		_( "Half area size" ),
380 		VIPS_ARGUMENT_OPTIONAL_INPUT,
381 		G_STRUCT_OFFSET( VipsMosaic1, harea ),
382 		0, 1000000000, 15 );
383 	VIPS_ARG_BOOL( class, "search", 15, 
384 		_( "search" ), 
385 		_( "Search to improve tie-points" ),
386 		VIPS_ARGUMENT_OPTIONAL_INPUT,
387 		G_STRUCT_OFFSET( VipsMosaic1, search ),
388 		FALSE ); 
389 	VIPS_ARG_INTERPOLATE( class, "interpolate", 16, 
390 		_( "Interpolate" ), 
391 		_( "Interpolate pixels with this" ),
392 		VIPS_ARGUMENT_OPTIONAL_INPUT, 
393 		G_STRUCT_OFFSET( VipsMosaic1, interpolate ) );
394 	VIPS_ARG_INT( class, "mblend", 17, 
395 		_( "Max blend" ), 
396 		_( "Maximum blend size" ),
397 		VIPS_ARGUMENT_OPTIONAL_INPUT,
398 		G_STRUCT_OFFSET( VipsMosaic1, mblend ),
399 		0, 10000, 10 );
400 	VIPS_ARG_INT( class, "bandno", 18, 
401 		_( "Search band" ), 
402 		_( "Band to search for features on" ),
403 		VIPS_ARGUMENT_OPTIONAL_INPUT,
404 		G_STRUCT_OFFSET( VipsMosaic1, bandno ),
405 		0, 10000, 0 );
406 }
407 static void
408 vips_mosaic1_init( VipsMosaic1 *mosaic1 )
409 {
410 	mosaic1-&gt;hwindow = 5;
411 	mosaic1-&gt;harea = 15;
412 	mosaic1-&gt;mblend = 10;
413 }
414 int
415 vips_mosaic1( VipsImage *ref, VipsImage *sec, VipsImage **out, 
416 	VipsDirection direction, 
417 	int xr1, int yr1, int xs1, int ys1, 
418 	int xr2, int yr2, int xs2, int ys2, ... )
419 {
420 	va_list ap;
421 	int result;
422 	va_start( ap, ys2 );
423 	result = vips_call_split( "mosaic1", ap, ref, sec, out, direction,
424 		xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2 );
425 	va_end( ap );
426 	return( result );
427 }</b></font>
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
