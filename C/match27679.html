<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for LabQ2LabS.c &amp; jp2ksave.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for LabQ2LabS.c &amp; jp2ksave.c
      </h3>
<h1 align="center">
        2.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>LabQ2LabS.c (16.90141%)<th>jp2ksave.c (1.369863%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(95-106)<td><a href="#" name="0">(1009-1020)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>LabQ2LabS.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;vips/vips.h&gt;
6 #include "pcolour.h"
7 typedef VipsColourCode VipsLabQ2LabS;
8 typedef VipsColourCodeClass VipsLabQ2LabSClass;
9 G_DEFINE_TYPE( VipsLabQ2LabS, vips_LabQ2LabS, VIPS_TYPE_COLOUR_CODE );
10 static void
11 vips_LabQ2LabS_line( VipsColour *colour, VipsPel *out, VipsPel **in, int width )
12 {
13 	unsigned char * restrict p = (unsigned char *) in[0];
14 	signed short * restrict q = (signed short *) out;
15 	int i;
16 	unsigned char ext;
17 	signed short l, a, b;
18 	for( i = 0; i &lt; width; i++ ) {
19 		l = p[0] &lt;&lt; 7;
20 		a = p[1] &lt;&lt; 8;
21 		b = p[2] &lt;&lt; 8;
22 		ext = p[3];
23 		p += 4;
24 		l |= (unsigned char) (ext &amp; 0xc0) &gt;&gt; 1;
25 		a |= (ext &amp; 0x38) &lt;&lt; 2;
26 		b |= (ext &amp; 0x7) &lt;&lt; 5;
27 		q[0] = l;
28 		q[1] = a;
29 <a name="0"></a>		q[2] = b;
30 		q += 3;
31 	}
32 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
33 static void
34 vips_LabQ2LabS_class_init( VipsLabQ2LabSClass *class )
35 {
36 	VipsObjectClass *object_class = (VipsObjectClass *) class;
37 	VipsColourClass *colour_class = VIPS_COLOUR_CLASS( class );
38 	object_class-&gt;nickname = "LabQ2LabS";
39 	object_class-&gt;description = _( "unpack a LabQ image to short Lab" );
40 	colour_class-&gt;process_line = vips_LabQ2LabS_line;</b></font>
41 }
42 static void
43 vips_LabQ2LabS_init( VipsLabQ2LabS *LabQ2LabS )
44 {
45 	VipsColour *colour = VIPS_COLOUR( LabQ2LabS );
46 	VipsColourCode *code = VIPS_COLOUR_CODE( LabQ2LabS );
47 	colour-&gt;coding = VIPS_CODING_NONE;
48 	colour-&gt;interpretation = VIPS_INTERPRETATION_LABS;
49 	colour-&gt;format = VIPS_FORMAT_SHORT;
50 	colour-&gt;bands = 3;
51 	code-&gt;input_coding = VIPS_CODING_LABQ;
52 }
53 int
54 vips_LabQ2LabS( VipsImage *in, VipsImage **out, ... )
55 {
56 	va_list ap;
57 	int result;
58 	va_start( ap, out );
59 	result = vips_call_split( "LabQ2LabS", ap, in, out );
60 	va_end( ap );
61 	return( result );
62 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>jp2ksave.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/internal.h&gt;
9 #ifdef HAVE_LIBOPENJP2
10 #include &lt;openjpeg.h&gt;
11 #include "pforeign.h"
12 #define MAX_BANDS (100)
13 typedef struct _VipsForeignSaveJp2k {
14 	VipsForeignSave parent_object;
15 	VipsTarget *target;
16 	int tile_width;
17 	int tile_height;
18 	gboolean lossless;
19 	int Q;
20 	VipsForeignSubsample subsample_mode;
21 	opj_stream_t *stream;
22 	opj_codec_t *codec;
23 	opj_cparameters_t parameters;
24 	opj_image_t *image;
25 	VipsRegion *strip;
26 	VipsPel *tile_buffer;
27 	gboolean subsample;
28 	gboolean save_as_ycc;
29 	VipsPel *accumulate;
30 } VipsForeignSaveJp2k;
31 typedef VipsForeignSaveClass VipsForeignSaveJp2kClass;
32 G_DEFINE_ABSTRACT_TYPE( VipsForeignSaveJp2k, vips_foreign_save_jp2k, 
33 	VIPS_TYPE_FOREIGN_SAVE );
34 static void
35 vips_foreign_save_jp2k_dispose( GObject *gobject )
36 {
37 	VipsForeignSaveJp2k *jp2k = (VipsForeignSaveJp2k *) gobject;
38 	VIPS_FREEF( opj_destroy_codec, jp2k-&gt;codec );
39 	VIPS_FREEF( opj_stream_destroy, jp2k-&gt;stream );
40 	VIPS_FREEF( opj_image_destroy, jp2k-&gt;image );
41 	VIPS_UNREF( jp2k-&gt;target );
42 	VIPS_UNREF( jp2k-&gt;strip );
43 	VIPS_FREE( jp2k-&gt;tile_buffer );
44 	VIPS_FREE( jp2k-&gt;accumulate );
45 	G_OBJECT_CLASS( vips_foreign_save_jp2k_parent_class )-&gt;
46 		dispose( gobject );
47 }
48 static OPJ_SIZE_T
49 vips_foreign_save_jp2k_write_target( void *buffer, size_t length, void *client )
50 {
51 	VipsTarget *target = VIPS_TARGET( client );
52 	if( vips_target_write( target, buffer, length ) )
53 		return( 0 );
54 	return( length );
55 }
56 static opj_stream_t *
57 vips_foreign_save_jp2k_target( VipsTarget *target )
58 {
59 	opj_stream_t *stream;
60 	if( !(stream = opj_stream_create( OPJ_J2K_STREAM_CHUNK_SIZE, FALSE )) ) 
61 		return( NULL );
62 	opj_stream_set_user_data( stream, target, NULL );
63 	opj_stream_set_write_function( stream, 
64 		vips_foreign_save_jp2k_write_target );
65 	return( stream );
66 }
67 static void 
68 vips_foreign_save_jp2k_error_callback( const char *msg, void *client )
69 {
70 	vips_error( "jp2ksave", "%s", msg ); 
71 }
72 static void 
73 vips_foreign_save_jp2k_warning_callback( const char *msg, void *client )
74 {
75 #ifdef DEBUG
76 	g_warning( "jp2ksave: %s", msg );
77 }
78 static void 
79 vips_foreign_save_jp2k_info_callback( const char *msg, void *client )
80 {
81 #ifdef DEBUG
82 	g_info( "jp2ksave: %s", msg );
83 }
84 static void
85 vips_foreign_save_jp2k_attach_handlers( opj_codec_t *codec )
86 {
87 	opj_set_info_handler( codec,
88 		vips_foreign_save_jp2k_info_callback, NULL );
89 	opj_set_warning_handler( codec, 
90 		vips_foreign_save_jp2k_warning_callback, NULL );
91 	opj_set_error_handler( codec, 
92 		vips_foreign_save_jp2k_error_callback, NULL );
93 }
94 #define RGB_TO_YCC( TYPE ) { \
95 	TYPE *tq = (TYPE *) q; \
96 	\
97 	for( x = 0; x &lt; tile-&gt;width; x++ ) { \
98 		int r = tq[0]; \
99 		int g = tq[1]; \
100 		int b = tq[2]; \
101 		\
102 		int y, cb, cr; \
103 		\
104 		y = 0.299 * r + 0.587 * g + 0.114 * b; \
105 		tq[0] = VIPS_CLIP( 0, y, upb ); \
106 		\
107 		cb = offset - (int)(0.168736 * r + 0.331264 * g - 0.5 * b); \
108 		tq[1] = VIPS_CLIP( 0, cb, upb ); \
109 		\
110 		cr = offset - (int)(-0.5 * r + 0.418688 * g + 0.081312 * b); \
111 		tq[2] = VIPS_CLIP( 0, cr, upb ); \
112 		\
113 		tq += 3; \
114 	} \
115 }
116 static void
117 vips_foreign_save_jp2k_rgb_to_ycc( VipsRegion *region, 
118 	VipsRect *tile, int prec ) 
119 {
120 	VipsImage *im = region-&gt;im;
121 	int offset = 1 &lt;&lt; (prec - 1);
122 	int upb = (1 &lt;&lt; prec) - 1;
123 	int x, y;
124 	g_assert( im-&gt;Bands == 3 );
125 	for( y = 0; y &lt; tile-&gt;height; y++ ) {
126 		VipsPel *q = VIPS_REGION_ADDR( region, 
127 			tile-&gt;left, tile-&gt;top + y );
128 		switch( im-&gt;BandFmt ) {
129 		case VIPS_FORMAT_CHAR:
130 		case VIPS_FORMAT_UCHAR:
131 			RGB_TO_YCC( unsigned char );
132 			break;
133 		case VIPS_FORMAT_SHORT:
134 		case VIPS_FORMAT_USHORT:
135 			RGB_TO_YCC( unsigned short );
136 			break;
137 		case VIPS_FORMAT_INT:
138 		case VIPS_FORMAT_UINT:
139 			RGB_TO_YCC( unsigned int );
140 			break;
141 		default:
142 			g_assert_not_reached();
143 			break;
144 		}
145 	}
146 }
147 #define SHRINK( OUTPUT_TYPE, ACC_TYPE, PIXEL_TYPE ) { \
148 	ACC_TYPE *acc = (ACC_TYPE *) accumulate; \
149 	OUTPUT_TYPE *tq = (OUTPUT_TYPE *) q; \
150 	const int n_pels = comp-&gt;dx * comp-&gt;dy; \
151 	\
152 	PIXEL_TYPE *tp; \
153 	ACC_TYPE *ap; \
154 	\
155 	tp = (PIXEL_TYPE *) p; \
156 	for( x = 0; x &lt; tile-&gt;width; x++ ) { \
157 		acc[x] = *tp; \
158 		tp += n_bands; \
159 	} \
160 	\
161 	for( z = 1; z &lt; comp-&gt;dy; z++ ) { \
162 		tp = (PIXEL_TYPE *) (p + z * lskip); \
163 		for( x = 0; x &lt; tile-&gt;width; x++ ) { \
164 			acc[x] += *tp; \
165 			tp += n_bands; \
166 		} \
167 	} \
168 	\
169 	ap = acc; \
170 	for( x = 0; x &lt; output_width; x++ ) { \
171 		ACC_TYPE sum; \
172 		\
173 		sum = 0; \
174 		for( z = 0; z &lt; comp-&gt;dx; z++ ) \
175 			sum += ap[z]; \
176 		\
177 		tq[x] = (sum + n_pels / 2) / n_pels; \
178 		ap += comp-&gt;dx; \
179 	} \
180 }
181 static void
182 vips_foreign_save_jp2k_unpack_subsample( VipsRegion *region, VipsRect *tile,
183 	opj_image_t *image, VipsPel *tile_buffer, VipsPel *accumulate )
184 {
185 	VipsImage *im = region-&gt;im;
186 	size_t sizeof_element = VIPS_REGION_SIZEOF_ELEMENT( region );
187 	size_t lskip = VIPS_REGION_LSKIP( region );
188 	int n_bands = im-&gt;Bands;
189 	VipsPel *q;
190 	int x, y, z, i;
191 	q = tile_buffer;
192 	for( i = 0; i &lt; n_bands; i++ ) {
193 		opj_image_comp_t *comp = &amp;image-&gt;comps[i];
194 		int output_width = VIPS_ROUND_UINT( 
195 			(double) tile-&gt;width / comp-&gt;dx );
196 		int output_height = VIPS_ROUND_UINT( 
197 			(double) tile-&gt;height / comp-&gt;dy );;
198 		for( y = 0; y &lt; output_height; y++ ) {
199 			VipsPel *p = i * sizeof_element + 
200 				VIPS_REGION_ADDR( region, 
201 					tile-&gt;left, tile-&gt;top + y * comp-&gt;dy );
202 			switch( im-&gt;BandFmt ) {
203 			case VIPS_FORMAT_CHAR:
204 				SHRINK( signed char, int, signed char );
205 				break;
206 			case VIPS_FORMAT_UCHAR:
207 				SHRINK( unsigned char, int, unsigned char );
208 				break;
209 			case VIPS_FORMAT_SHORT:
210 				SHRINK( signed short, int, signed short );
211 				break;
212 			case VIPS_FORMAT_USHORT:
213 				SHRINK( unsigned short, int, unsigned short );
214 				break;
215 			case VIPS_FORMAT_INT:
216 				SHRINK( signed int, gint64, signed int );
217 				break;
218 			case VIPS_FORMAT_UINT:
219 				SHRINK( unsigned int, gint64, unsigned int );
220 				break;
221 			default:
222 				g_assert_not_reached();
223 				break;
224 			}
225 			q += sizeof_element * output_width;
226 		}
227 	}
228 }
229 #define UNPACK( OUT, IN ) { \
230 	OUT *tq = (OUT *) q; \
231 	IN *tp = (IN *) p + i; \
232 	\
233 	for( x = 0; x &lt; tile-&gt;width; x++ ) { \
234 		tq[x] = *tp; \
235 		tp += b; \
236 	} \
237 }
238 static void
239 vips_foreign_save_jp2k_unpack( VipsRegion *region, VipsRect *tile,
240 	opj_image_t *image, VipsPel *tile_buffer )
241 {
242 	VipsImage *im = region-&gt;im;
243 	size_t sizeof_element = VIPS_REGION_SIZEOF_ELEMENT( region );
244 	size_t sizeof_line = sizeof_element * tile-&gt;width;
245 	size_t sizeof_tile = sizeof_line * tile-&gt;height;
246 	int b = im-&gt;Bands;
247 	int x, y, i;
248 	for( y = 0; y &lt; tile-&gt;height; y++ ) {
249 		VipsPel *p = VIPS_REGION_ADDR( region, 
250 			tile-&gt;left, tile-&gt;top + y );
251 		for( i = 0; i &lt; b; i++ ) {
252 			VipsPel *q = tile_buffer + 
253 				i * sizeof_tile + y * sizeof_line;
254 			switch( im-&gt;BandFmt ) {
255 			case VIPS_FORMAT_CHAR:
256 			case VIPS_FORMAT_UCHAR:
257 				UNPACK( unsigned char, unsigned char );
258 				break;
259 			case VIPS_FORMAT_SHORT:
260 			case VIPS_FORMAT_USHORT:
261 				UNPACK( unsigned short, unsigned short );
262 				break;
263 			case VIPS_FORMAT_INT:
264 			case VIPS_FORMAT_UINT:
265 				UNPACK( unsigned int, unsigned int );
266 				break;
267 			default:
268 				g_assert_not_reached();
269 				break;
270 			}
271 		}
272 	}
273 }
274 static size_t
275 vips_foreign_save_jp2k_sizeof_tile( VipsForeignSaveJp2k *jp2k, VipsRect *tile )
276 {
277 	VipsForeignSave *save = (VipsForeignSave *) jp2k;
278 	size_t sizeof_element = VIPS_IMAGE_SIZEOF_ELEMENT( save-&gt;ready );
279 	size_t size;
280 	int i;
281 	size = 0;
282 	for( i = 0; i &lt; jp2k-&gt;image-&gt;numcomps; i++ ) {
283 		opj_image_comp_t *comp = &amp;jp2k-&gt;image-&gt;comps[i];
284 		int output_width = VIPS_ROUND_UINT( 
285 			(double) tile-&gt;width / comp-&gt;dx );
286 		int output_height = VIPS_ROUND_UINT( 
287 			(double) tile-&gt;height / comp-&gt;dy );;
288 		size += output_width * output_height * sizeof_element;
289 	}
290 	return( size );
291 }
292 static int
293 vips_foreign_save_jp2k_write_tiles( VipsForeignSaveJp2k *jp2k )
294 {
295 	VipsForeignSave *save = (VipsForeignSave *) jp2k;
296 	VipsImage *im = save-&gt;ready;
297 	int tiles_across = VIPS_ROUND_UP( im-&gt;Xsize, jp2k-&gt;tile_width ) /
298 		jp2k-&gt;tile_width;
299 	int x;
300 	for( x = 0; x &lt; im-&gt;Xsize; x += jp2k-&gt;tile_width ) {
301 		VipsRect tile;
302 		size_t sizeof_tile;
303 		int tile_index;
304 		tile.left = x;
305 		tile.top = jp2k-&gt;strip-&gt;valid.top;
306 		tile.width = jp2k-&gt;tile_width;
307 		tile.height = jp2k-&gt;tile_height;
308 		vips_rect_intersectrect( &amp;tile, &amp;jp2k-&gt;strip-&gt;valid, &amp;tile );
309 		if( jp2k-&gt;save_as_ycc ) 
310 			vips_foreign_save_jp2k_rgb_to_ycc( jp2k-&gt;strip, 
311 				&amp;tile, jp2k-&gt;image-&gt;comps[0].prec ); 
312 		if( jp2k-&gt;subsample )
313 			vips_foreign_save_jp2k_unpack_subsample( jp2k-&gt;strip, 
314 				&amp;tile, jp2k-&gt;image, 
315 				jp2k-&gt;tile_buffer, jp2k-&gt;accumulate ); 
316 		else
317 			vips_foreign_save_jp2k_unpack( jp2k-&gt;strip, 
318 				&amp;tile, jp2k-&gt;image, 
319 				jp2k-&gt;tile_buffer );
320 		sizeof_tile = 
321 			vips_foreign_save_jp2k_sizeof_tile( jp2k, &amp;tile );
322 		tile_index = tiles_across * tile.top / jp2k-&gt;tile_height +
323 			x / jp2k-&gt;tile_width;
324 		if( !opj_write_tile( jp2k-&gt;codec, tile_index, 
325 			(VipsPel *) jp2k-&gt;tile_buffer, sizeof_tile, 
326 			jp2k-&gt;stream ) )
327 			return( -1 );
328 	}
329 	return( 0 );
330 }
331 static int
332 vips_foreign_save_jp2k_write_block( VipsRegion *region, VipsRect *area, 
333 	void *a )
334 {
335 	VipsForeignSaveJp2k *jp2k = (VipsForeignSaveJp2k *) a;
336 	VipsForeignSave *save = (VipsForeignSave *) jp2k;
337 #ifdef DEBUG_VERBOSE
338 	printf( "vips_foreign_save_jp2k_write_block: y = %d, nlines = %d\n", 
339 		area-&gt;top, area-&gt;height );
340 	for(;;) {
341 		VipsRect hit;
342 		int y;
343 		VipsRect strip_position;
344 		vips_rect_intersectrect( area, &amp;(jp2k-&gt;strip-&gt;valid), &amp;hit );
345 		for( y = 0; y &lt; hit.height; y++ ) {
346 			VipsPel *p = VIPS_REGION_ADDR( region, 
347 				0, hit.top + y );
348 			VipsPel *q = VIPS_REGION_ADDR( jp2k-&gt;strip, 
349 				0, hit.top + y );
350 			memcpy( q, p, VIPS_IMAGE_SIZEOF_LINE( region-&gt;im ) );
351 		}
352 		if( VIPS_RECT_BOTTOM( &amp;hit ) != 
353 			VIPS_RECT_BOTTOM( &amp;jp2k-&gt;strip-&gt;valid ) ) 
354 			break;
355 		if( vips_foreign_save_jp2k_write_tiles( jp2k ) )
356 			return( -1 );
357 		strip_position.left = 0;
358 		strip_position.top = jp2k-&gt;strip-&gt;valid.top + jp2k-&gt;tile_height;
359 		strip_position.width = save-&gt;ready-&gt;Xsize;
360 		strip_position.height = jp2k-&gt;tile_height;
361 		if( vips_region_buffer( jp2k-&gt;strip, &amp;strip_position ) )
362 			return( -1 );
363 	}
364 	return( 0 );
365 }
366 #define VIPS_OPJ_CALLOC( N, TYPE ) \
367 	((TYPE *) calloc( (N), sizeof( TYPE ) ))
368 static opj_image_t * 
369 vips_opj_image_create( OPJ_UINT32 numcmpts,
370 	opj_image_cmptparm_t *cmptparms, OPJ_COLOR_SPACE clrspc,
371 	gboolean allocate )
372 {
373 	OPJ_UINT32 compno;
374 	opj_image_t *image = NULL;
375 	if( !(image = VIPS_OPJ_CALLOC( 1, opj_image_t )) )
376 		return( NULL );
377         image-&gt;color_space = clrspc;
378         image-&gt;numcomps = numcmpts;
379         image-&gt;comps = VIPS_OPJ_CALLOC( image-&gt;numcomps, opj_image_comp_t );
380         if( !image-&gt;comps ) {
381             opj_image_destroy( image );
382             return( NULL );
383         }
384         for( compno = 0; compno &lt; numcmpts; compno++ ) {
385 		opj_image_comp_t *comp = &amp;image-&gt;comps[compno];
386 		comp-&gt;dx = cmptparms[compno].dx;
387 		comp-&gt;dy = cmptparms[compno].dy;
388 		comp-&gt;w = cmptparms[compno].w;
389 		comp-&gt;h = cmptparms[compno].h;
390 		comp-&gt;x0 = cmptparms[compno].x0;
391 		comp-&gt;y0 = cmptparms[compno].y0;
392 		comp-&gt;prec = cmptparms[compno].prec;
393 		comp-&gt;bpp = cmptparms[compno].bpp;
394 		comp-&gt;sgnd = cmptparms[compno].sgnd;
395 		if( comp-&gt;h != 0 &amp;&amp;
396 			(OPJ_SIZE_T) comp-&gt;w &gt; SIZE_MAX / comp-&gt;h / 
397 				sizeof( OPJ_INT32 ) ) {
398 			opj_image_destroy( image );
399 			return( NULL );
400 		}
401 		if( allocate ) {
402 			size_t bytes = (size_t) comp-&gt;w * comp-&gt;h * 
403                                 sizeof( OPJ_INT32 );
404 			comp-&gt;data = (OPJ_INT32*) opj_image_data_alloc( bytes );
405 			if( !comp-&gt;data ) {
406 				opj_image_destroy( image );
407 				return NULL;
408 			}
409 			memset( comp-&gt;data, 0, bytes );
410 		}
411 	}
412 	return( image );
413 }
414 static opj_image_t *
415 vips_foreign_save_jp2k_new_image( VipsImage *im, 
416 	int width, int height, 
417 	gboolean subsample, gboolean save_as_ycc, gboolean allocate )
418 {
419 	OPJ_COLOR_SPACE color_space;
420 	int expected_bands;
421 	int bits_per_pixel;
422 	opj_image_cmptparm_t comps[MAX_BANDS];
423 	opj_image_t *image;
424 	int i;
425 	if( im-&gt;Bands &gt; MAX_BANDS )
426 		return( NULL );
427 	switch( im-&gt;Type ) {
428 	case VIPS_INTERPRETATION_B_W:
429 	case VIPS_INTERPRETATION_GREY16:
430 		color_space = OPJ_CLRSPC_GRAY;
431 		expected_bands = 1;
432 		break;
433 	case VIPS_INTERPRETATION_sRGB:
434 	case VIPS_INTERPRETATION_RGB16:
435 		color_space = save_as_ycc ? OPJ_CLRSPC_SYCC : OPJ_CLRSPC_SRGB;
436 		expected_bands = 3;
437 		break;
438 	case VIPS_INTERPRETATION_CMYK:
439 		color_space = OPJ_CLRSPC_CMYK;
440 		expected_bands = 4;
441 		break;
442 	default:
443 		color_space = OPJ_CLRSPC_UNSPECIFIED;
444 		expected_bands = im-&gt;Bands;
445 		break;
446 	}
447 	switch( im-&gt;BandFmt ) {
448 	case VIPS_FORMAT_CHAR:
449 	case VIPS_FORMAT_UCHAR:
450 		bits_per_pixel = 8;
451 		break;
452 	case VIPS_FORMAT_SHORT:
453 	case VIPS_FORMAT_USHORT:
454 		bits_per_pixel = 16;
455 		break;
456 	case VIPS_FORMAT_INT:
457 	case VIPS_FORMAT_UINT:
458 		bits_per_pixel = 31;
459 		break;
460 	default:
461 		g_assert_not_reached();
462 		break;
463 	}
464 	for( i = 0; i &lt; im-&gt;Bands; i++ ) {
465 		comps[i].dx = (subsample &amp;&amp; i &gt; 0) ? 2 : 1;
466 		comps[i].dy = (subsample &amp;&amp; i &gt; 0) ? 2 : 1;
467 		comps[i].w = width;
468 		comps[i].h = height;
469 		comps[i].x0 = 0;
470 		comps[i].y0 = 0;
471 		comps[i].prec = bits_per_pixel;
472 		comps[i].bpp = bits_per_pixel;
473 		comps[i].sgnd = !vips_band_format_isuint( im-&gt;BandFmt );
474 	}
475 	image = vips_opj_image_create( im-&gt;Bands, comps, color_space, 
476 		allocate );
477 	image-&gt;x1 = width;
478 	image-&gt;y1 = height;
479 	for( i = 0; i &lt; im-&gt;Bands; i++ )
480 		image-&gt;comps[i].alpha = i &gt;= expected_bands;
481 	return( image );
482 }
483 static void
484 vips_foreign_save_jp2k_set_profile( opj_cparameters_t *parameters, 
485 	gboolean lossless, int Q )
486 {
487 	if( lossless )
488 		parameters-&gt;irreversible = FALSE;
489 	else {
490 		int i;
491 		parameters-&gt;irreversible = TRUE;
492 		parameters-&gt;prog_order = OPJ_RPCL;
493 		parameters-&gt;cblockw_init = 64;
494 		parameters-&gt;cblockh_init = 64;
495 		parameters-&gt;cp_disto_alloc = 1;
496 		parameters-&gt;cp_fixed_quality = TRUE;
497 		parameters-&gt;tcp_numlayers = 1;
498 		parameters-&gt;numresolution = 7;
499 		parameters-&gt;csty = 1;
500 		parameters-&gt;res_spec = 7;
501 		for( i = 0; i &lt; parameters-&gt;res_spec; i++ ) { 
502 			parameters-&gt;prch_init[i] = 256;
503 			parameters-&gt;prcw_init[i] = 256;
504 			parameters-&gt;tcp_distoratio[i] = Q + 10 * i;
505 		}
506 	}
507 }
508 static int
509 vips_foreign_save_jp2k_build( VipsObject *object )
510 {
511 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
512 	VipsForeignSave *save = (VipsForeignSave *) object;
513 	VipsForeignSaveJp2k *jp2k = (VipsForeignSaveJp2k *) object;
514 	size_t sizeof_tile;
515 	size_t sizeof_line;
516 	VipsRect strip_position;
517 	if( VIPS_OBJECT_CLASS( vips_foreign_save_jp2k_parent_class )-&gt;
518 		build( object ) )
519 		return( -1 );
520 	if( !vips_band_format_isint( save-&gt;ready-&gt;BandFmt ) ) {
521 		vips_error( class-&gt;nickname,
522 			"%s", _( "not an integer format" ) );
523 		return( -1 );
524 	}
525 	switch( jp2k-&gt;subsample_mode ) {
526 	case VIPS_FOREIGN_SUBSAMPLE_AUTO:
527 		jp2k-&gt;subsample =
528 			!jp2k-&gt;lossless &amp;&amp;
529 			jp2k-&gt;Q &lt; 90 &amp;&amp;
530 			save-&gt;ready-&gt;Xsize % 2 == 0 &amp;&amp;
531 			save-&gt;ready-&gt;Ysize % 2 == 0 &amp;&amp;
532 			(save-&gt;ready-&gt;Type == VIPS_INTERPRETATION_sRGB ||
533 			 save-&gt;ready-&gt;Type == VIPS_INTERPRETATION_RGB16) &amp;&amp;
534 			save-&gt;ready-&gt;Bands == 3;
535 		break;
536 	case VIPS_FOREIGN_SUBSAMPLE_ON:
537 		jp2k-&gt;subsample = TRUE;
538 		break;
539 	case VIPS_FOREIGN_SUBSAMPLE_OFF:
540 		jp2k-&gt;subsample = FALSE;
541 		break;
542 	default:
543 		g_assert_not_reached();
544 		break;
545 	}
546 	if( jp2k-&gt;subsample ) 
547 		jp2k-&gt;save_as_ycc = TRUE;
548 	opj_set_default_encoder_parameters( &amp;jp2k-&gt;parameters );
549 	vips_foreign_save_jp2k_set_profile( &amp;jp2k-&gt;parameters, 
550 		jp2k-&gt;lossless, jp2k-&gt;Q ); 
551 	jp2k-&gt;parameters.tile_size_on = OPJ_TRUE;
552 	jp2k-&gt;parameters.cp_tdx = jp2k-&gt;tile_width;
553 	jp2k-&gt;parameters.cp_tdy = jp2k-&gt;tile_height;
554 	jp2k-&gt;parameters.tcp_mct = save-&gt;ready-&gt;Bands &gt;= 3 &amp;&amp; !jp2k-&gt;subsample;
555 	jp2k-&gt;parameters.numresolution = VIPS_MAX( 1, 
556 		log( VIPS_MIN( save-&gt;ready-&gt;Xsize, save-&gt;ready-&gt;Ysize ) ) / 
557 		log( 2 ) - 5 );
558 #ifdef DEBUG
559 	printf( "vips_foreign_save_jp2k_build: numresolutions = %d\n", 
560 		jp2k-&gt;parameters.numresolution );
561 	jp2k-&gt;codec = opj_create_compress( OPJ_CODEC_J2K );
562 	vips_foreign_save_jp2k_attach_handlers( jp2k-&gt;codec );
563 	if( !(jp2k-&gt;image = vips_foreign_save_jp2k_new_image( save-&gt;ready,
564 		save-&gt;ready-&gt;Xsize, save-&gt;ready-&gt;Ysize, 
565 		jp2k-&gt;subsample, jp2k-&gt;save_as_ycc, FALSE )) )
566 		return( -1 );
567         if( !opj_setup_encoder( jp2k-&gt;codec, &amp;jp2k-&gt;parameters, jp2k-&gt;image ) ) 
568 		return( -1 );
569 	opj_codec_set_threads( jp2k-&gt;codec, vips_concurrency_get() );
570 	if( !(jp2k-&gt;stream = vips_foreign_save_jp2k_target( jp2k-&gt;target )) )
571 		return( -1 );
572 	if( !opj_start_compress( jp2k-&gt;codec, jp2k-&gt;image, jp2k-&gt;stream ) )
573 		return( -1 );
574 	sizeof_tile = VIPS_IMAGE_SIZEOF_PEL( save-&gt;ready ) *
575 		jp2k-&gt;tile_width * jp2k-&gt;tile_height;
576 	if( !(jp2k-&gt;tile_buffer = VIPS_ARRAY( NULL, sizeof_tile, VipsPel )) )
577 		return( -1 );
578 	sizeof_line = sizeof( gint64 ) * jp2k-&gt;tile_width;
579 	if( !(jp2k-&gt;accumulate = VIPS_ARRAY( NULL, sizeof_line, VipsPel )) )
580 		return( -1 );
581 	jp2k-&gt;strip = vips_region_new( save-&gt;ready );
582 	strip_position.left = 0;
583 	strip_position.top = 0;
584 	strip_position.width = save-&gt;ready-&gt;Xsize;
585 	strip_position.height = jp2k-&gt;tile_height;
586 	if( vips_region_buffer( jp2k-&gt;strip, &amp;strip_position ) ) 
587 		return( -1 );
588 	if( vips_sink_disc( save-&gt;ready,
589 		vips_foreign_save_jp2k_write_block, jp2k ) )
590 		return( -1 );
591 	opj_end_compress( jp2k-&gt;codec, jp2k-&gt;stream );
592 	vips_target_finish( jp2k-&gt;target );
593 	return( 0 );
594 }
595 static void
596 vips_foreign_save_jp2k_class_init( VipsForeignSaveJp2kClass *class )
597 {
598 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
599 	VipsObjectClass *object_class = (VipsObjectClass *) class;
600 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
601 	VipsForeignSaveClass *save_class = (VipsForeignSaveClass *) class;
602 	gobject_class-&gt;dispose = vips_foreign_save_jp2k_dispose;
603 	gobject_class-&gt;set_property = vips_object_set_property;
604 	gobject_class-&gt;get_property = vips_object_get_property;
605 	object_class-&gt;nickname = "jp2ksave_base";
606 	object_class-&gt;description = _( "save image in JPEG2000 format" );
607 	object_class-&gt;build = vips_foreign_save_jp2k_build;
608 	foreign_class-&gt;suffs = vips__jp2k_suffs;
609 	save_class-&gt;saveable = VIPS_SAVEABLE_ANY;
610 	VIPS_ARG_INT( class, "tile_width", 11, 
611 		_( "Tile width" ), 
612 		_( "Tile width in pixels" ),
613 		VIPS_ARGUMENT_OPTIONAL_INPUT,
614 		G_STRUCT_OFFSET( VipsForeignSaveJp2k, tile_width ),
615 		1, 32768, 512 );
616 	VIPS_ARG_INT( class, "tile_height", 12, 
617 		_( "Tile height" ), 
618 		_( "Tile height in pixels" ),
619 		VIPS_ARGUMENT_OPTIONAL_INPUT,
620 		G_STRUCT_OFFSET( VipsForeignSaveJp2k, tile_height ),
621 		1, 32768, 512 );
622 	VIPS_ARG_BOOL( class, "lossless", 13, 
623 		_( "Lossless" ), 
624 		_( "Enable lossless compression" ),
625 		VIPS_ARGUMENT_OPTIONAL_INPUT,
626 		G_STRUCT_OFFSET( VipsForeignSaveJp2k, lossless ),
627 		FALSE ); 
628 	VIPS_ARG_ENUM( class, "subsample_mode", 19,
629 		_( "Subsample mode" ),
630 		_( "Select chroma subsample operation mode" ),
631 		VIPS_ARGUMENT_OPTIONAL_INPUT,
632 		G_STRUCT_OFFSET( VipsForeignSaveJp2k, subsample_mode ),
633 		VIPS_TYPE_FOREIGN_SUBSAMPLE,
634 		VIPS_FOREIGN_SUBSAMPLE_AUTO );
635 	VIPS_ARG_INT( class, "Q", 14, 
636 		_( "Q" ), 
637 		_( "Q factor" ),
638 		VIPS_ARGUMENT_OPTIONAL_INPUT,
639 		G_STRUCT_OFFSET( VipsForeignSaveJp2k, Q ),
640 		1, 100, 48 );
641 }
642 static void
643 vips_foreign_save_jp2k_init( VipsForeignSaveJp2k *jp2k )
644 {
645 	jp2k-&gt;tile_width = 512;
646 	jp2k-&gt;tile_height = 512;
647 	jp2k-&gt;Q = 48;
648 	jp2k-&gt;subsample_mode = VIPS_FOREIGN_SUBSAMPLE_AUTO;
649 }
650 typedef struct _VipsForeignSaveJp2kFile {
651 	VipsForeignSaveJp2k parent_object;
652 	char *filename; 
653 } VipsForeignSaveJp2kFile;
654 typedef VipsForeignSaveJp2kClass VipsForeignSaveJp2kFileClass;
655 G_DEFINE_TYPE( VipsForeignSaveJp2kFile, vips_foreign_save_jp2k_file, 
656 	vips_foreign_save_jp2k_get_type() );
657 static int
658 vips_foreign_save_jp2k_file_build( VipsObject *object )
659 {
660 	VipsForeignSaveJp2k *jp2k = (VipsForeignSaveJp2k *) object;
661 	VipsForeignSaveJp2kFile *file = (VipsForeignSaveJp2kFile *) object;
662 	if( !(jp2k-&gt;target = vips_target_new_to_file( file-&gt;filename )) )
663 		return( -1 );
664 	if( VIPS_OBJECT_CLASS( vips_foreign_save_jp2k_file_parent_class )-&gt;
665 		build( object ) )
666 <a name="0"></a>		return( -1 );
667 	return( 0 );
668 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
669 static void
670 vips_foreign_save_jp2k_file_class_init( VipsForeignSaveJp2kFileClass *class )
671 {
672 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
673 	VipsObjectClass *object_class = (VipsObjectClass *) class;
674 	gobject_class-&gt;set_property = vips_object_set_property;
675 	gobject_class-&gt;get_property = vips_object_get_property;
676 	object_class-&gt;nickname = "jp2ksave";</b></font>
677 	object_class-&gt;build = vips_foreign_save_jp2k_file_build;
678 	VIPS_ARG_STRING( class, "filename", 1, 
679 		_( "Filename" ),
680 		_( "Filename to load from" ),
681 		VIPS_ARGUMENT_REQUIRED_INPUT, 
682 		G_STRUCT_OFFSET( VipsForeignSaveJp2kFile, filename ),
683 		NULL );
684 }
685 static void
686 vips_foreign_save_jp2k_file_init( VipsForeignSaveJp2kFile *file )
687 {
688 }
689 typedef struct _VipsForeignSaveJp2kBuffer {
690 	VipsForeignSaveJp2k parent_object;
691 	VipsArea *buf;
692 } VipsForeignSaveJp2kBuffer;
693 typedef VipsForeignSaveJp2kClass VipsForeignSaveJp2kBufferClass;
694 G_DEFINE_TYPE( VipsForeignSaveJp2kBuffer, vips_foreign_save_jp2k_buffer, 
695 	vips_foreign_save_jp2k_get_type() );
696 static int
697 vips_foreign_save_jp2k_buffer_build( VipsObject *object )
698 {
699 	VipsForeignSaveJp2k *jp2k = (VipsForeignSaveJp2k *) object;
700 	VipsForeignSaveJp2kBuffer *buffer = 
701 		(VipsForeignSaveJp2kBuffer *) object;
702 	VipsBlob *blob;
703 	if( !(jp2k-&gt;target = vips_target_new_to_memory()) )
704 		return( -1 );
705 	if( VIPS_OBJECT_CLASS( vips_foreign_save_jp2k_buffer_parent_class )-&gt;
706 		build( object ) )
707 		return( -1 );
708 	g_object_get( jp2k-&gt;target, "blob", &amp;blob, NULL );
709 	g_object_set( buffer, "buffer", blob, NULL );
710 	vips_area_unref( VIPS_AREA( blob ) );
711 	return( 0 );
712 }
713 static void
714 vips_foreign_save_jp2k_buffer_class_init( 
715 	VipsForeignSaveJp2kBufferClass *class )
716 {
717 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
718 	VipsObjectClass *object_class = (VipsObjectClass *) class;
719 	gobject_class-&gt;set_property = vips_object_set_property;
720 	gobject_class-&gt;get_property = vips_object_get_property;
721 	object_class-&gt;nickname = "jp2ksave_buffer";
722 	object_class-&gt;build = vips_foreign_save_jp2k_buffer_build;
723 	VIPS_ARG_BOXED( class, "buffer", 1, 
724 		_( "Buffer" ),
725 		_( "Buffer to save to" ),
726 		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
727 		G_STRUCT_OFFSET( VipsForeignSaveJp2kBuffer, buf ),
728 		VIPS_TYPE_BLOB );
729 }
730 static void
731 vips_foreign_save_jp2k_buffer_init( VipsForeignSaveJp2kBuffer *buffer )
732 {
733 }
734 typedef struct _VipsForeignSaveJp2kTarget {
735 	VipsForeignSaveJp2k parent_object;
736 	VipsTarget *target;
737 } VipsForeignSaveJp2kTarget;
738 typedef VipsForeignSaveJp2kClass VipsForeignSaveJp2kTargetClass;
739 G_DEFINE_TYPE( VipsForeignSaveJp2kTarget, vips_foreign_save_jp2k_target, 
740 	vips_foreign_save_jp2k_get_type() );
741 static int
742 vips_foreign_save_jp2k_target_build( VipsObject *object )
743 {
744 	VipsForeignSaveJp2k *jp2k = (VipsForeignSaveJp2k *) object;
745 	VipsForeignSaveJp2kTarget *target = 
746 		(VipsForeignSaveJp2kTarget *) object;
747 	if( target-&gt;target ) {
748 		jp2k-&gt;target = target-&gt;target;
749 		g_object_ref( jp2k-&gt;target );
750 	}
751 	if( VIPS_OBJECT_CLASS( vips_foreign_save_jp2k_target_parent_class )-&gt;
752 		build( object ) )
753 		return( -1 );
754 	return( 0 );
755 }
756 static void
757 vips_foreign_save_jp2k_target_class_init( 
758 	VipsForeignSaveJp2kTargetClass *class )
759 {
760 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
761 	VipsObjectClass *object_class = (VipsObjectClass *) class;
762 	gobject_class-&gt;set_property = vips_object_set_property;
763 	gobject_class-&gt;get_property = vips_object_get_property;
764 	object_class-&gt;nickname = "jp2ksave_target";
765 	object_class-&gt;build = vips_foreign_save_jp2k_target_build;
766 	VIPS_ARG_OBJECT( class, "target", 1,
767 		_( "Target" ),
768 		_( "Target to save to" ),
769 		VIPS_ARGUMENT_REQUIRED_INPUT, 
770 		G_STRUCT_OFFSET( VipsForeignSaveJp2kTarget, target ),
771 		VIPS_TYPE_TARGET );
772 }
773 static void
774 vips_foreign_save_jp2k_target_init( VipsForeignSaveJp2kTarget *target )
775 {
776 }
777 typedef struct _TileCompress {
778         opj_codec_t *codec;
779 	opj_image_t *image;
780 	opj_stream_t *stream;
781 	VipsPel *accumulate;
782 } TileCompress;
783 static void
784 vips_foreign_save_jp2k_unpack_subsample_image( VipsRegion *region, 
785 	VipsRect *tile, opj_image_t *image, VipsPel *accumulate )
786 {
787 	VipsImage *im = region-&gt;im;
788 	size_t sizeof_element = VIPS_REGION_SIZEOF_ELEMENT( region );
789 	size_t lskip = VIPS_REGION_LSKIP( region );
790 	int n_bands = im-&gt;Bands;
791 	int x, y, z, i;
792 	for( i = 0; i &lt; n_bands; i++ ) {
793 		opj_image_comp_t *comp = &amp;image-&gt;comps[i];
794 		int *q = comp-&gt;data;
795 		int output_width = VIPS_ROUND_UINT( 
796 			(double) comp-&gt;w / comp-&gt;dx );
797 		int output_height = VIPS_ROUND_UINT( 
798 			(double) comp-&gt;h / comp-&gt;dy );
799 		for( y = 0; y &lt; output_height; y++ ) {
800 			VipsPel *p = i * sizeof_element + 
801 				VIPS_REGION_ADDR( region, 
802 					tile-&gt;left, tile-&gt;top + y * comp-&gt;dy );
803 			switch( im-&gt;BandFmt ) {
804 			case VIPS_FORMAT_CHAR:
805 				SHRINK( int, int, signed char );
806 				break;
807 			case VIPS_FORMAT_UCHAR:
808 				SHRINK( int, int, unsigned char );
809 				break;
810 			case VIPS_FORMAT_SHORT:
811 				SHRINK( int, int, signed short );
812 				break;
813 			case VIPS_FORMAT_USHORT:
814 				SHRINK( int, int, unsigned short );
815 				break;
816 			case VIPS_FORMAT_INT:
817 				SHRINK( int, gint64, signed int );
818 				break;
819 			case VIPS_FORMAT_UINT:
820 				SHRINK( int, gint64, unsigned int );
821 				break;
822 			default:
823 				g_assert_not_reached();
824 				break;
825 			}
826 			q += output_width;
827 		}
828 	}
829 }
830 static void
831 vips_foreign_save_jp2k_unpack_image( VipsRegion *region, VipsRect *tile,
832 	opj_image_t *image )
833 {
834 	VipsImage *im = region-&gt;im;
835 	int b = im-&gt;Bands;
836 	int x, y, i;
837 	for( y = 0; y &lt; tile-&gt;height; y++ ) {
838 		VipsPel *p = VIPS_REGION_ADDR( region, 
839 			tile-&gt;left, tile-&gt;top + y );
840 		for( i = 0; i &lt; b; i++ ) {
841 			opj_image_comp_t *comp = &amp;image-&gt;comps[i];
842                         int *q = comp-&gt;data + y * comp-&gt;w; 
843 			switch( im-&gt;BandFmt ) {
844 			case VIPS_FORMAT_CHAR:
845 			case VIPS_FORMAT_UCHAR:
846 				UNPACK( int, unsigned char );
847 				break;
848 			case VIPS_FORMAT_SHORT:
849 			case VIPS_FORMAT_USHORT:
850 				UNPACK( int, unsigned short );
851 				break;
852 			case VIPS_FORMAT_INT:
853 			case VIPS_FORMAT_UINT:
854 				UNPACK( int, unsigned int );
855 				break;
856 			default:
857 				g_assert_not_reached();
858 				break;
859 			}
860 		}
861 	}
862 }
863 void
864 vips__foreign_load_jp2k_compress_free( TileCompress *compress )
865 {
866 	VIPS_FREEF( opj_destroy_codec, compress-&gt;codec );
867 	VIPS_FREEF( opj_image_destroy, compress-&gt;image );
868 	VIPS_FREEF( opj_stream_destroy, compress-&gt;stream );
869 	VIPS_FREE( compress-&gt;accumulate );
870 }
871 int
872 vips__foreign_load_jp2k_compress( VipsRegion *region, 
873 	VipsRect *tile, VipsTarget *target,
874 	int tile_width, int tile_height,
875         gboolean save_as_ycc, gboolean subsample, gboolean lossless, int Q )
876 {
877 	TileCompress compress = { 0 };
878 	opj_cparameters_t parameters;
879 	size_t sizeof_line;
880 	save_as_ycc = save_as_ycc &amp;&amp; region-&gt;im-&gt;Bands == 3;
881 	subsample = subsample &amp;&amp; save_as_ycc;
882 	opj_set_default_encoder_parameters( &amp;parameters );
883 	vips_foreign_save_jp2k_set_profile( &amp;parameters, lossless, Q ); 
884 	parameters.tcp_mct = region-&gt;im-&gt;Bands &gt;= 3 ? 1 : 0;
885 	if( !(compress.image = vips_foreign_save_jp2k_new_image( region-&gt;im,
886 		tile_width, tile_height, subsample, save_as_ycc, TRUE )) ) {
887 		vips__foreign_load_jp2k_compress_free( &amp;compress );
888 		return( -1 );
889 	}
890 	sizeof_line = sizeof( gint64 ) * tile-&gt;width;
891 	if( !(compress.accumulate = 
892 		VIPS_ARRAY( NULL, sizeof_line, VipsPel )) ) {
893 		vips__foreign_load_jp2k_compress_free( &amp;compress );
894 		return( -1 );
895 	}
896 	compress.codec = opj_create_compress( OPJ_CODEC_J2K );
897 	vips_foreign_save_jp2k_attach_handlers( compress.codec );
898         if( !opj_setup_encoder( compress.codec, 
899 		&amp;parameters, compress.image ) ) {
900 		vips__foreign_load_jp2k_compress_free( &amp;compress );
901 		return( -1 );
902 	}
903 	opj_codec_set_threads( compress.codec, vips_concurrency_get() );
904 	if( save_as_ycc ) 
905 		vips_foreign_save_jp2k_rgb_to_ycc( region, 
906 			tile, compress.image-&gt;comps[0].prec );
907 	if( subsample )
908 		vips_foreign_save_jp2k_unpack_subsample_image( region,
909 			tile, compress.image, 
910 			compress.accumulate ); 
911 	else
912 		vips_foreign_save_jp2k_unpack_image( region,
913 			tile, compress.image ); 
914 	if( !(compress.stream = vips_foreign_save_jp2k_target( target )) ) {
915 		vips__foreign_load_jp2k_compress_free( &amp;compress );
916 		return( -1 );
917 	}
918 	if( !opj_start_compress( compress.codec, 
919 		compress.image, compress.stream ) ) {
920 		vips__foreign_load_jp2k_compress_free( &amp;compress );
921 		return( -1 );
922 	}
923 	if( !opj_encode( compress.codec, compress.stream ) ) {
924 		vips__foreign_load_jp2k_compress_free( &amp;compress );
925 		return( -1 );
926 	}
927 	opj_end_compress( compress.codec, compress.stream );
928 	vips__foreign_load_jp2k_compress_free( &amp;compress );
929 	return( 0 );
930 }
931 int
932 vips__foreign_load_jp2k_compress( VipsRegion *region, 
933 	VipsRect *tile, VipsTarget *target,
934 	int tile_width, int tile_height,
935         gboolean save_as_ycc, gboolean subsample, gboolean lossless, int Q )
936 {
937 	vips_error( "jp2k", 
938 		"%s", _( "libvips built without JPEG2000 support" ) );
939 	return( -1 );
940 }
941 int
942 vips_jp2ksave( VipsImage *in, const char *filename, ... )
943 {
944 	va_list ap;
945 	int result;
946 	va_start( ap, filename );
947 	result = vips_call_split( "jp2ksave", ap, in, filename );
948 	va_end( ap );
949 	return( result );
950 }
951 int
952 vips_jp2ksave_buffer( VipsImage *in, void **buf, size_t *len, ... )
953 {
954 	va_list ap;
955 	VipsArea *area;
956 	int result;
957 	area = NULL; 
958 	va_start( ap, len );
959 	result = vips_call_split( "jp2ksave_buffer", ap, in, &amp;area );
960 	va_end( ap );
961 	if( !result &amp;&amp;
962 		area ) { 
963 		if( buf ) {
964 			*buf = area-&gt;data;
965 			area-&gt;free_fn = NULL;
966 		}
967 		if( len ) 
968 			*len = area-&gt;length;
969 		vips_area_unref( area );
970 	}
971 	return( result );
972 }
973 int
974 vips_jp2ksave_target( VipsImage *in, VipsTarget *target, ... )
975 {
976 	va_list ap;
977 	int result;
978 	va_start( ap, target );
979 	result = vips_call_split( "jp2ksave_target", ap, in, target );
980 	va_end( ap );
981 	return( result );
982 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
