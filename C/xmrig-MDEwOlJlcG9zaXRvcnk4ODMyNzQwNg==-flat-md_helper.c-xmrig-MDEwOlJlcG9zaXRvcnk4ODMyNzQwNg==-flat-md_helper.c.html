
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-md_helper.c</h3>
            <pre><code>1  #ifdef _MSC_VER
2  #pragma warning (disable: 4146)
3  #endif
4  #undef SPH_XCAT
5  #define SPH_XCAT(a, b)     SPH_XCAT_(a, b)
6  #undef SPH_XCAT_
7  #define SPH_XCAT_(a, b)    a ## b
8  #undef SPH_BLEN
9  #undef SPH_WLEN
10  #if defined BE64 || defined LE64
11  #define SPH_BLEN    128U
12  #define SPH_WLEN      8U
13  #else
14  #define SPH_BLEN     64U
15  #define SPH_WLEN      4U
16  #endif
17  #ifdef BLEN
18  #undef SPH_BLEN
19  #define SPH_BLEN    BLEN
20  #endif
21  #undef SPH_MAXPAD
22  #if defined PLW1
23  #define SPH_MAXPAD   (SPH_BLEN - SPH_WLEN)
24  #elif defined PLW4
25  #define SPH_MAXPAD   (SPH_BLEN - (SPH_WLEN << 2))
26  #else
27  #define SPH_MAXPAD   (SPH_BLEN - (SPH_WLEN << 1))
28  #endif
29  #undef SPH_VAL
30  #undef SPH_NO_OUTPUT
31  #ifdef SVAL
32  #define SPH_VAL         SVAL
33  #define SPH_NO_OUTPUT   1
34  #else
35  #define SPH_VAL   sc->val
36  #endif
37  #ifndef CLOSE_ONLY
38  #ifdef SPH_UPTR
39  static void
40  SPH_XCAT(HASH, _short)(void *cc, const void *data, size_t len)
41  #else
42  void
43  SPH_XCAT(sph_, HASH)(void *cc, const void *data, size_t len)
44  #endif
45  {
46  	SPH_XCAT(sph_, SPH_XCAT(HASH, _context)) *sc;
47  	size_t current;
48  	sc = cc;
49  #if SPH_64
50  	current = (unsigned)sc->count & (SPH_BLEN - 1U);
51  #else
52  	current = (unsigned)sc->count_low & (SPH_BLEN - 1U);
53  #endif
54  	while (len > 0) {
55  		size_t clen;
56  #if !SPH_64
57  		sph_u32 clow, clow2;
58  #endif
<span onclick='openModal()' class='match'>59  		clen = SPH_BLEN - current;
60  		if (clen > len)
61  			clen = len;
62  		memcpy(sc->buf + current, data, clen);
</span>63  		data = (const unsigned char *)data + clen;
64  		current += clen;
65  		len -= clen;
66  		if (current == SPH_BLEN) {
67  			RFUN(sc->buf, SPH_VAL);
68  			current = 0;
69  		}
70  #if SPH_64
71  		sc->count += clen;
72  #else
73  		clow = sc->count_low;
74  		clow2 = SPH_T32(clow + clen);
75  		sc->count_low = clow2;
76  		if (clow2 < clow)
77  			sc->count_high ++;
78  #endif
79  	}
80  }
81  #ifdef SPH_UPTR
82  void
83  SPH_XCAT(sph_, HASH)(void *cc, const void *data, size_t len)
84  {
85  	SPH_XCAT(sph_, SPH_XCAT(HASH, _context)) *sc;
86  	unsigned current;
87  	size_t orig_len;
88  #if !SPH_64
89  	sph_u32 clow, clow2;
90  #endif
91  	if (len < (2 * SPH_BLEN)) {
92  		SPH_XCAT(HASH, _short)(cc, data, len);
93  		return;
94  	}
95  	sc = cc;
96  #if SPH_64
97  	current = (unsigned)sc->count & (SPH_BLEN - 1U);
98  #else
99  	current = (unsigned)sc->count_low & (SPH_BLEN - 1U);
100  #endif
101  	if (current > 0) {
102  		unsigned t;
103  		t = SPH_BLEN - current;
104  		SPH_XCAT(HASH, _short)(cc, data, t);
105  		data = (const unsigned char *)data + t;
106  		len -= t;
107  	}
108  #if !SPH_UNALIGNED
109  	if (((SPH_UPTR)data & (SPH_WLEN - 1U)) != 0) {
110  		SPH_XCAT(HASH, _short)(cc, data, len);
111  		return;
112  	}
113  #endif
114  	orig_len = len;
115  	while (len >= SPH_BLEN) {
116  		RFUN(data, SPH_VAL);
117  		len -= SPH_BLEN;
118  		data = (const unsigned char *)data + SPH_BLEN;
119  	}
120  	if (len > 0)
121  		memcpy(sc->buf, data, len);
122  #if SPH_64
123  	sc->count += (sph_u64)orig_len;
124  #else
125  	clow = sc->count_low;
126  	clow2 = SPH_T32(clow + orig_len);
127  	sc->count_low = clow2;
128  	if (clow2 < clow)
129  		sc->count_high ++;
130  	orig_len >>= 12;
131  	orig_len >>= 10;
132  	orig_len >>= 10;
133  	sc->count_high += orig_len;
134  #endif
135  }
136  #endif
137  #endif
138  static void
139  SPH_XCAT(HASH, _addbits_and_close)(void *cc,
140  	unsigned ub, unsigned n, void *dst, unsigned rnum)
141  {
142  	SPH_XCAT(sph_, SPH_XCAT(HASH, _context)) *sc;
143  	unsigned current, u;
144  #if !SPH_64
145  	sph_u32 low, high;
146  #endif
147  	sc = cc;
148  #if SPH_64
149  	current = (unsigned)sc->count & (SPH_BLEN - 1U);
150  #else
151  	current = (unsigned)sc->count_low & (SPH_BLEN - 1U);
152  #endif
153  #ifdef PW01
154  	sc->buf[current ++] = (0x100 | (ub & 0xFF)) >> (8 - n);
155  #else
156  	{
157  		unsigned z;
158  		z = 0x80 >> n;
159  		sc->buf[current ++] = ((ub & -z) | z) & 0xFF;
160  	}
161  #endif
162  	if (current > SPH_MAXPAD) {
163  		memset(sc->buf + current, 0, SPH_BLEN - current);
164  		RFUN(sc->buf, SPH_VAL);
165  		memset(sc->buf, 0, SPH_MAXPAD);
166  	} else {
167  		memset(sc->buf + current, 0, SPH_MAXPAD - current);
168  	}
169  #if defined BE64
170  #if defined PLW1
171  	sph_enc64be_aligned(sc->buf + SPH_MAXPAD,
172  		SPH_T64(sc->count << 3) + (sph_u64)n);
173  #elif defined PLW4
174  	memset(sc->buf + SPH_MAXPAD, 0, 2 * SPH_WLEN);
175  	sph_enc64be_aligned(sc->buf + SPH_MAXPAD + 2 * SPH_WLEN,
176  		sc->count >> 61);
177  	sph_enc64be_aligned(sc->buf + SPH_MAXPAD + 3 * SPH_WLEN,
178  		SPH_T64(sc->count << 3) + (sph_u64)n);
179  #else
180  	sph_enc64be_aligned(sc->buf + SPH_MAXPAD, sc->count >> 61);
181  	sph_enc64be_aligned(sc->buf + SPH_MAXPAD + SPH_WLEN,
182  		SPH_T64(sc->count << 3) + (sph_u64)n);
183  #endif
184  #elif defined LE64
185  #if defined PLW1
186  	sph_enc64le_aligned(sc->buf + SPH_MAXPAD,
187  		SPH_T64(sc->count << 3) + (sph_u64)n);
188  #elif defined PLW1
189  	sph_enc64le_aligned(sc->buf + SPH_MAXPAD,
190  		SPH_T64(sc->count << 3) + (sph_u64)n);
191  	sph_enc64le_aligned(sc->buf + SPH_MAXPAD + SPH_WLEN, sc->count >> 61);
192  	memset(sc->buf + SPH_MAXPAD + 2 * SPH_WLEN, 0, 2 * SPH_WLEN);
193  #else
194  	sph_enc64le_aligned(sc->buf + SPH_MAXPAD,
195  		SPH_T64(sc->count << 3) + (sph_u64)n);
196  	sph_enc64le_aligned(sc->buf + SPH_MAXPAD + SPH_WLEN, sc->count >> 61);
197  #endif
198  #else
199  #if SPH_64
200  #ifdef BE32
201  	sph_enc64be_aligned(sc->buf + SPH_MAXPAD,
202  		SPH_T64(sc->count << 3) + (sph_u64)n);
203  #else
204  	sph_enc64le_aligned(sc->buf + SPH_MAXPAD,
205  		SPH_T64(sc->count << 3) + (sph_u64)n);
206  #endif
207  #else
208  	low = sc->count_low;
209  	high = SPH_T32((sc->count_high << 3) | (low >> 29));
210  	low = SPH_T32(low << 3) + (sph_u32)n;
211  #ifdef BE32
212  	sph_enc32be(sc->buf + SPH_MAXPAD, high);
213  	sph_enc32be(sc->buf + SPH_MAXPAD + SPH_WLEN, low);
214  #else
215  	sph_enc32le(sc->buf + SPH_MAXPAD, low);
216  	sph_enc32le(sc->buf + SPH_MAXPAD + SPH_WLEN, high);
217  #endif
218  #endif
219  #endif
220  	RFUN(sc->buf, SPH_VAL);
221  #ifdef SPH_NO_OUTPUT
222  	(void)dst;
223  	(void)rnum;
224  	(void)u;
225  #else
226  	for (u = 0; u < rnum; u ++) {
227  #if defined BE64
228  		sph_enc64be((unsigned char *)dst + 8 * u, sc->val[u]);
229  #elif defined LE64
230  		sph_enc64le((unsigned char *)dst + 8 * u, sc->val[u]);
231  #elif defined BE32
232  		sph_enc32be((unsigned char *)dst + 4 * u, sc->val[u]);
233  #else
234  		sph_enc32le((unsigned char *)dst + 4 * u, sc->val[u]);
235  #endif
236  	}
237  #endif
238  }
239  static void
240  SPH_XCAT(HASH, _close)(void *cc, void *dst, unsigned rnum)
241  {
242  	SPH_XCAT(HASH, _addbits_and_close)(cc, 0, 0, dst, rnum);
243  }
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-md_helper.c</h3>
            <pre><code>1  #ifdef _MSC_VER
2  #pragma warning (disable: 4146)
3  #endif
4  #undef SPH_XCAT
5  #define SPH_XCAT(a, b)     SPH_XCAT_(a, b)
6  #undef SPH_XCAT_
7  #define SPH_XCAT_(a, b)    a ## b
8  #undef SPH_BLEN
9  #undef SPH_WLEN
10  #if defined BE64 || defined LE64
11  #define SPH_BLEN    128U
12  #define SPH_WLEN      8U
13  #else
14  #define SPH_BLEN     64U
15  #define SPH_WLEN      4U
16  #endif
17  #ifdef BLEN
18  #undef SPH_BLEN
19  #define SPH_BLEN    BLEN
20  #endif
21  #undef SPH_MAXPAD
22  #if defined PLW1
23  #define SPH_MAXPAD   (SPH_BLEN - SPH_WLEN)
24  #elif defined PLW4
25  #define SPH_MAXPAD   (SPH_BLEN - (SPH_WLEN << 2))
26  #else
27  #define SPH_MAXPAD   (SPH_BLEN - (SPH_WLEN << 1))
28  #endif
29  #undef SPH_VAL
30  #undef SPH_NO_OUTPUT
31  #ifdef SVAL
32  #define SPH_VAL         SVAL
33  #define SPH_NO_OUTPUT   1
34  #else
35  #define SPH_VAL   sc->val
36  #endif
37  #ifndef CLOSE_ONLY
38  #ifdef SPH_UPTR
39  static void
40  SPH_XCAT(HASH, _short)(void *cc, const void *data, size_t len)
41  #else
42  void
43  SPH_XCAT(sph_, HASH)(void *cc, const void *data, size_t len)
44  #endif
45  {
46  	SPH_XCAT(sph_, SPH_XCAT(HASH, _context)) *sc;
47  	size_t current;
48  	sc = cc;
49  #if SPH_64
50  	current = (unsigned)sc->count & (SPH_BLEN - 1U);
51  #else
52  	current = (unsigned)sc->count_low & (SPH_BLEN - 1U);
53  #endif
54  	while (len > 0) {
55  		size_t clen;
56  #if !SPH_64
57  		sph_u32 clow, clow2;
58  #endif
<span onclick='openModal()' class='match'>59  		clen = SPH_BLEN - current;
60  		if (clen > len)
61  			clen = len;
62  		memcpy(sc->buf + current, data, clen);
</span>63  		data = (const unsigned char *)data + clen;
64  		current += clen;
65  		len -= clen;
66  		if (current == SPH_BLEN) {
67  			RFUN(sc->buf, SPH_VAL);
68  			current = 0;
69  		}
70  #if SPH_64
71  		sc->count += clen;
72  #else
73  		clow = sc->count_low;
74  		clow2 = SPH_T32(clow + clen);
75  		sc->count_low = clow2;
76  		if (clow2 < clow)
77  			sc->count_high ++;
78  #endif
79  	}
80  }
81  #ifdef SPH_UPTR
82  void
83  SPH_XCAT(sph_, HASH)(void *cc, const void *data, size_t len)
84  {
85  	SPH_XCAT(sph_, SPH_XCAT(HASH, _context)) *sc;
86  	unsigned current;
87  	size_t orig_len;
88  #if !SPH_64
89  	sph_u32 clow, clow2;
90  #endif
91  	if (len < (2 * SPH_BLEN)) {
92  		SPH_XCAT(HASH, _short)(cc, data, len);
93  		return;
94  	}
95  	sc = cc;
96  #if SPH_64
97  	current = (unsigned)sc->count & (SPH_BLEN - 1U);
98  #else
99  	current = (unsigned)sc->count_low & (SPH_BLEN - 1U);
100  #endif
101  	if (current > 0) {
102  		unsigned t;
103  		t = SPH_BLEN - current;
104  		SPH_XCAT(HASH, _short)(cc, data, t);
105  		data = (const unsigned char *)data + t;
106  		len -= t;
107  	}
108  #if !SPH_UNALIGNED
109  	if (((SPH_UPTR)data & (SPH_WLEN - 1U)) != 0) {
110  		SPH_XCAT(HASH, _short)(cc, data, len);
111  		return;
112  	}
113  #endif
114  	orig_len = len;
115  	while (len >= SPH_BLEN) {
116  		RFUN(data, SPH_VAL);
117  		len -= SPH_BLEN;
118  		data = (const unsigned char *)data + SPH_BLEN;
119  	}
120  	if (len > 0)
121  		memcpy(sc->buf, data, len);
122  #if SPH_64
123  	sc->count += (sph_u64)orig_len;
124  #else
125  	clow = sc->count_low;
126  	clow2 = SPH_T32(clow + orig_len);
127  	sc->count_low = clow2;
128  	if (clow2 < clow)
129  		sc->count_high ++;
130  	orig_len >>= 12;
131  	orig_len >>= 10;
132  	orig_len >>= 10;
133  	sc->count_high += orig_len;
134  #endif
135  }
136  #endif
137  #endif
138  static void
139  SPH_XCAT(HASH, _addbits_and_close)(void *cc,
140  	unsigned ub, unsigned n, void *dst, unsigned rnum)
141  {
142  	SPH_XCAT(sph_, SPH_XCAT(HASH, _context)) *sc;
143  	unsigned current, u;
144  #if !SPH_64
145  	sph_u32 low, high;
146  #endif
147  	sc = cc;
148  #if SPH_64
149  	current = (unsigned)sc->count & (SPH_BLEN - 1U);
150  #else
151  	current = (unsigned)sc->count_low & (SPH_BLEN - 1U);
152  #endif
153  #ifdef PW01
154  	sc->buf[current ++] = (0x100 | (ub & 0xFF)) >> (8 - n);
155  #else
156  	{
157  		unsigned z;
158  		z = 0x80 >> n;
159  		sc->buf[current ++] = ((ub & -z) | z) & 0xFF;
160  	}
161  #endif
162  	if (current > SPH_MAXPAD) {
163  		memset(sc->buf + current, 0, SPH_BLEN - current);
164  		RFUN(sc->buf, SPH_VAL);
165  		memset(sc->buf, 0, SPH_MAXPAD);
166  	} else {
167  		memset(sc->buf + current, 0, SPH_MAXPAD - current);
168  	}
169  #if defined BE64
170  #if defined PLW1
171  	sph_enc64be_aligned(sc->buf + SPH_MAXPAD,
172  		SPH_T64(sc->count << 3) + (sph_u64)n);
173  #elif defined PLW4
174  	memset(sc->buf + SPH_MAXPAD, 0, 2 * SPH_WLEN);
175  	sph_enc64be_aligned(sc->buf + SPH_MAXPAD + 2 * SPH_WLEN,
176  		sc->count >> 61);
177  	sph_enc64be_aligned(sc->buf + SPH_MAXPAD + 3 * SPH_WLEN,
178  		SPH_T64(sc->count << 3) + (sph_u64)n);
179  #else
180  	sph_enc64be_aligned(sc->buf + SPH_MAXPAD, sc->count >> 61);
181  	sph_enc64be_aligned(sc->buf + SPH_MAXPAD + SPH_WLEN,
182  		SPH_T64(sc->count << 3) + (sph_u64)n);
183  #endif
184  #elif defined LE64
185  #if defined PLW1
186  	sph_enc64le_aligned(sc->buf + SPH_MAXPAD,
187  		SPH_T64(sc->count << 3) + (sph_u64)n);
188  #elif defined PLW1
189  	sph_enc64le_aligned(sc->buf + SPH_MAXPAD,
190  		SPH_T64(sc->count << 3) + (sph_u64)n);
191  	sph_enc64le_aligned(sc->buf + SPH_MAXPAD + SPH_WLEN, sc->count >> 61);
192  	memset(sc->buf + SPH_MAXPAD + 2 * SPH_WLEN, 0, 2 * SPH_WLEN);
193  #else
194  	sph_enc64le_aligned(sc->buf + SPH_MAXPAD,
195  		SPH_T64(sc->count << 3) + (sph_u64)n);
196  	sph_enc64le_aligned(sc->buf + SPH_MAXPAD + SPH_WLEN, sc->count >> 61);
197  #endif
198  #else
199  #if SPH_64
200  #ifdef BE32
201  	sph_enc64be_aligned(sc->buf + SPH_MAXPAD,
202  		SPH_T64(sc->count << 3) + (sph_u64)n);
203  #else
204  	sph_enc64le_aligned(sc->buf + SPH_MAXPAD,
205  		SPH_T64(sc->count << 3) + (sph_u64)n);
206  #endif
207  #else
208  	low = sc->count_low;
209  	high = SPH_T32((sc->count_high << 3) | (low >> 29));
210  	low = SPH_T32(low << 3) + (sph_u32)n;
211  #ifdef BE32
212  	sph_enc32be(sc->buf + SPH_MAXPAD, high);
213  	sph_enc32be(sc->buf + SPH_MAXPAD + SPH_WLEN, low);
214  #else
215  	sph_enc32le(sc->buf + SPH_MAXPAD, low);
216  	sph_enc32le(sc->buf + SPH_MAXPAD + SPH_WLEN, high);
217  #endif
218  #endif
219  #endif
220  	RFUN(sc->buf, SPH_VAL);
221  #ifdef SPH_NO_OUTPUT
222  	(void)dst;
223  	(void)rnum;
224  	(void)u;
225  #else
226  	for (u = 0; u < rnum; u ++) {
227  #if defined BE64
228  		sph_enc64be((unsigned char *)dst + 8 * u, sc->val[u]);
229  #elif defined LE64
230  		sph_enc64le((unsigned char *)dst + 8 * u, sc->val[u]);
231  #elif defined BE32
232  		sph_enc32be((unsigned char *)dst + 4 * u, sc->val[u]);
233  #else
234  		sph_enc32le((unsigned char *)dst + 4 * u, sc->val[u]);
235  #endif
236  	}
237  #endif
238  }
239  static void
240  SPH_XCAT(HASH, _close)(void *cc, void *dst, unsigned rnum)
241  {
242  	SPH_XCAT(HASH, _addbits_and_close)(cc, 0, 0, dst, rnum);
243  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-md_helper.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-md_helper.c</div>
                </div>
                <div class="column column_space"><pre><code>59  		clen = SPH_BLEN - current;
60  		if (clen > len)
61  			clen = len;
62  		memcpy(sc->buf + current, data, clen);
</pre></code></div>
                <div class="column column_space"><pre><code>59  		clen = SPH_BLEN - current;
60  		if (clen > len)
61  			clen = len;
62  		memcpy(sc->buf + current, data, clen);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    