<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for lluv_prepare.c &amp; lluv_signal.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for lluv_prepare.c &amp; lluv_signal.c
      </h3>
<h1 align="center">
        56.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>lluv_prepare.c (82.41758%)<th>lluv_signal.c (42.613636%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(19-43)<td><a href="#" name="0">(25-49)</a><td align="center"><font color="#ff0000">28</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(78-104)<td><a href="#" name="1">(212-245)</a><td align="center"><font color="#f50000">27</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(48-72)<td><a href="#" name="2">(84-110)</a><td align="center"><font color="#b60000">20</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>lluv_prepare.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/******************************************************************************
* Author: Alexey Melnichuk &lt;alexeymelnichuck@gmail.com&gt;
*
* Copyright (C) 2014-2016 Alexey Melnichuk &lt;alexeymelnichuck@gmail.com&gt;
*
* Licensed according to the included 'LICENSE' document
*
* This file is part of lua-lluv library.
******************************************************************************/

#include "lluv.h"
#include "lluv_handle.h"
#include "lluv_prepare.h"
#include "lluv_loop.h"
#include "lluv_error.h"
<a name="0"></a>#include &lt;assert.h&gt;

#define LLUV_PREPARE_NAME LLUV_PREFIX" Prepare"
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static const char *LLUV_PREPARE = LLUV_PREPARE_NAME;

LLUV_INTERNAL int lluv_prepare_index(lua_State *L){
  return lluv__index(L, LLUV_PREPARE, lluv_handle_index);
}

LLUV_IMPL_SAFE(lluv_prepare_create){
  lluv_loop_t   *loop   = lluv_opt_loop_ex(L, 1, LLUV_FLAG_OPEN);
  lluv_handle_t *handle = lluv_handle_create(L, UV_PREPARE, safe_flag | INHERITE_FLAGS(loop));
  int err = uv_prepare_init(loop-&gt;handle, LLUV_H(handle, uv_prepare_t));
  if(err &lt; 0){
    lluv_handle_cleanup(L, handle, -1);
    return lluv_fail(L, safe_flag | loop-&gt;flags, LLUV_ERR_UV, (uv_errno_t)err, NULL);
  }
  return 1;
}

static lluv_handle_t* lluv_check_prepare(lua_State *L, int idx, lluv_flags_t flags){
  lluv_handle_t *handle = lluv_check_handle(L, idx, flags);
  luaL_argcheck (L, LLUV_H(handle, uv_handle_t)-&gt;type == UV_PREPARE, idx, LLUV_PREPARE_NAME" expected");

  return handle;
}

static void lluv_on_prepare_start(uv_prepare_t *arg){</b></font>
  lluv_on_handle_start((uv_handle_t*)arg);
<a name="2"></a>}

static int lluv_prepare_start(lua_State *L){
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  lluv_handle_t *handle = lluv_check_prepare(L, 1, LLUV_FLAG_OPEN);
  int err;

  lluv_check_args_with_cb(L, 2);
  LLUV_START_CB(handle) = luaL_ref(L, LLUV_LUA_REGISTRY);

  err = uv_prepare_start(LLUV_H(handle, uv_prepare_t), lluv_on_prepare_start);

  if(err &gt;= 0) lluv_handle_lock(L, handle, LLUV_LOCK_START);

  return lluv_return(L, handle, LLUV_START_CB(handle), err);
}

static int lluv_prepare_stop(lua_State *L){
  lluv_handle_t *handle = lluv_check_prepare(L, 1, LLUV_FLAG_OPEN);
  int err = uv_prepare_stop(LLUV_H(handle, uv_prepare_t));
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }

  lluv_handle_unlock(L, handle, LLUV_LOCK_START);

  lua_settop(L, 1);
  return 1;
}</b></font>

static const struct luaL_Reg lluv_prepare_methods[] = {
<a name="1"></a>  { "start",      lluv_prepare_start      },
  { "stop",       lluv_prepare_stop       },

<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  {NULL,NULL}
};

#define LLUV_FUNCTIONS(F)               \
  {"prepare", lluv_prepare_create_##F}, \

static const struct luaL_Reg lluv_functions[][2] = {
  {
    LLUV_FUNCTIONS(unsafe)

    {NULL,NULL}
  },
  {
    LLUV_FUNCTIONS(safe)

    {NULL,NULL}
  },
};

LLUV_INTERNAL void lluv_prepare_initlib(lua_State *L, int nup, int safe){
  lutil_pushnvalues(L, nup);
  if(!lutil_createmetap(L, LLUV_PREPARE, lluv_prepare_methods, nup))
    lua_pop(L, nup);
  lua_pop(L, 1);

  luaL_setfuncs(L, lluv_functions[safe], nup);
}</b></font>
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lluv_signal.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/******************************************************************************
* Author: Alexey Melnichuk &lt;alexeymelnichuck@gmail.com&gt;
*
* Copyright (C) 2014-2017 Alexey Melnichuk &lt;alexeymelnichuck@gmail.com&gt;
*
* Licensed according to the included 'LICENSE' document
*
* This file is part of lua-lluv library.
******************************************************************************/

#include "lluv.h"
#include "lluv_handle.h"
#include "lluv_signal.h"
#include "lluv_loop.h"
#include "lluv_error.h"
#include &lt;assert.h&gt;

#ifndef _WIN32

#include &lt;signal.h&gt;

<a name="0"></a>#endif

#define LLUV_SIGNAL_NAME LLUV_PREFIX" Signal"
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static const char *LLUV_SIGNAL = LLUV_SIGNAL_NAME;

LLUV_INTERNAL int lluv_signal_index(lua_State *L){
  return lluv__index(L, LLUV_SIGNAL, lluv_handle_index);
}

LLUV_IMPL_SAFE(lluv_signal_create){
  lluv_loop_t   *loop   = lluv_opt_loop_ex(L, 1, LLUV_FLAG_OPEN);
  lluv_handle_t *handle = lluv_handle_create(L, UV_SIGNAL, INHERITE_FLAGS(loop));
  int err = uv_signal_init(loop-&gt;handle, LLUV_H(handle, uv_signal_t));
  if(err &lt; 0){
    lluv_handle_cleanup(L, handle, -1);
    return lluv_fail(L, safe_flag | loop-&gt;flags, LLUV_ERR_UV, (uv_errno_t)err, NULL);
  }
  return 1;
}

static lluv_handle_t* lluv_check_signal(lua_State *L, int idx, lluv_flags_t flags){
  lluv_handle_t *handle = lluv_check_handle(L, idx, flags);
  luaL_argcheck (L, LLUV_H(handle, uv_handle_t)-&gt;type == UV_SIGNAL, idx, LLUV_SIGNAL_NAME" expected");

  return handle;
}

static void lluv_on_signal_start(uv_signal_t *arg, int signum){</b></font>
  lluv_handle_t *handle = lluv_handle_byptr((uv_handle_t*)arg);
  lua_State *L = LLUV_HCALLBACK_L(handle);

  LLUV_CHECK_LOOP_CB_INVARIANT(L);

  lua_rawgeti(L, LLUV_LUA_REGISTRY, LLUV_START_CB(handle));
  assert(!lua_isnil(L, -1)); /* is callble */

  lluv_handle_pushself(L, handle);
  lua_pushinteger(L, signum);
  LLUV_HANDLE_CALL_CB(L, handle, 2);

  LLUV_CHECK_LOOP_CB_INVARIANT(L);
}

static int lluv_signal_start(lua_State *L){
  lluv_handle_t *handle = lluv_check_signal(L, 1, LLUV_FLAG_OPEN);
  int signum = luaL_checkint(L, 2);
  int err;

  lluv_check_args_with_cb(L, 3);
  LLUV_START_CB(handle) = luaL_ref(L, LLUV_LUA_REGISTRY);

  err = uv_signal_start(LLUV_H(handle, uv_signal_t), lluv_on_signal_start, signum);

  if(err &gt;= 0) lluv_handle_lock(L, handle, LLUV_LOCK_START);

  return lluv_return(L, handle, LLUV_START_CB(handle), err);
}

#if LLUV_UV_VER_GE(1,12,0)
<a name="2"></a>
static int lluv_signal_start_oneshot(lua_State *L){
  lluv_handle_t *handle = lluv_check_signal(L, 1, LLUV_FLAG_OPEN);
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  int signum = luaL_checkint(L, 2);
  int err;

  lluv_check_args_with_cb(L, 3);
  LLUV_START_CB(handle) = luaL_ref(L, LLUV_LUA_REGISTRY);

  err = uv_signal_start_oneshot(LLUV_H(handle, uv_signal_t), lluv_on_signal_start, signum);

  if(err &gt;= 0) lluv_handle_lock(L, handle, LLUV_LOCK_START);

  return lluv_return(L, handle, LLUV_START_CB(handle), err);
}

#endif

static int lluv_signal_stop(lua_State *L){
  lluv_handle_t *handle = lluv_check_signal(L, 1, LLUV_FLAG_OPEN);
  int err = uv_signal_stop(LLUV_H(handle, uv_signal_t));
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }

  lluv_handle_unlock(L, handle, LLUV_LOCK_START);

  lua_settop(L, 1);
  return 1;
}</b></font>

LLUV_IMPL_SAFE(lluv_signal_ignore){
#ifndef _WIN32
  int s = luaL_checkint(L, 1);
  signal(s, SIG_IGN);
#endif
  lua_pushboolean(L, 1);
  return 1;
}

LLUV_IMPL_SAFE(lluv_signal_default){
#ifndef _WIN32
  int s = luaL_checkint(L, 1);
  signal(s, SIG_DFL);
#endif
  lua_pushboolean(L, 1);
  return 1;
}

static const struct luaL_Reg lluv_signal_methods[] = {
#if LLUV_UV_VER_GE(1,12,0)
  { "start_oneshot",  lluv_signal_start_oneshot  },
#endif
  { "start",          lluv_signal_start          },
  { "stop",           lluv_signal_stop           },

  {NULL,NULL}
};

static const lluv_uv_const_t lluv_signal_constants[] = {
#ifdef SIGINT
  { SIGINT,   "SIGINT"   },
#endif
#ifdef SIGBREAK
  { SIGBREAK, "SIGBREAK" },
#endif
#ifdef SIGHUP
  { SIGHUP,   "SIGHUP"   },
#endif
#ifdef SIGWINCH
  { SIGWINCH, "SIGWINCH" },
#endif
#ifdef SIGPIPE
  { SIGPIPE, "SIGPIPE" },
#endif
#ifdef SIGQUIT
  { SIGQUIT, "SIGQUIT" },
#endif
#ifdef SIGILL
  { SIGILL, "SIGILL" },
#endif
#ifdef SIGABRT
  { SIGABRT, "SIGABRT" },
#endif
#ifdef SIGTRAP
  { SIGTRAP, "SIGTRAP" },
#endif
#ifdef SIGIOT
  { SIGIOT, "SIGIOT" },
#endif
#ifdef SIGEMT
  { SIGEMT, "SIGEMT" },
#endif
#ifdef SIGFPE
  { SIGFPE, "SIGFPE" },
#endif
#ifdef SIGKILL
  { SIGKILL, "SIGKILL" },
#endif
#ifdef SIGBUS
  { SIGBUS, "SIGBUS" },
#endif
#ifdef SIGSEGV
  { SIGSEGV, "SIGSEGV" },
#endif
#ifdef SIGSYS
  { SIGSYS, "SIGSYS" },
#endif
#ifdef SIGALRM
  { SIGALRM, "SIGALRM" },
#endif
#ifdef SIGUSR1
  { SIGUSR1, "SIGUSR1" },
#endif
#ifdef SIGUSR2
  { SIGUSR2, "SIGUSR2" },
#endif
#ifdef SIGCHLD
  { SIGCHLD, "SIGCHLD" },
#endif
#ifdef SIGCLD
  { SIGCLD, "SIGCLD" },
#endif
#ifdef SIGPWR
  { SIGPWR, "SIGPWR" },
#endif
#ifdef SIGXCPU
  { SIGXCPU, "SIGXCPU" },
<a name="1"></a>#endif
  { SIGTERM,  "SIGTERM"  },

<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  { 0, NULL }
};

#define LLUV_FUNCTIONS(F)                      \
  {"signal",         lluv_signal_create_##F }, \
  {"signal_ignore",  lluv_signal_ignore_##F }, \
  {"signal_default", lluv_signal_default_##F}, \

static const struct luaL_Reg lluv_functions[][4] = {
  {
    LLUV_FUNCTIONS(unsafe)

    {NULL,NULL}
  },
  {
    LLUV_FUNCTIONS(safe)

    {NULL,NULL}
  },
};

LLUV_INTERNAL void lluv_signal_initlib(lua_State *L, int nup, int safe){
  lutil_pushnvalues(L, nup);
  if(!lutil_createmetap(L, LLUV_SIGNAL, lluv_signal_methods, nup))
    lua_pop(L, nup);
  lua_pop(L, 1);

  luaL_setfuncs(L, lluv_functions[safe], nup);
  lluv_register_constants(L, lluv_signal_constants);

#ifndef _WIN32
  signal(SIGPIPE, SIG_IGN);
#endif
}</b></font>
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
