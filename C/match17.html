<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for lluv_prepare.c & lluv_signal.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for lluv_prepare.c & lluv_signal.c
      </h3>
      <h1 align="center">
        56.1%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>lluv_prepare.c (82.41758%)<TH>lluv_signal.c (42.613636%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match17-0.html#0',2,'match17-1.html#0',3)" NAME="0">(19-43)<TD><A HREF="javascript:ZweiFrames('match17-0.html#0',2,'match17-1.html#0',3)" NAME="0">(25-49)</A><TD ALIGN=center><FONT COLOR="#ff0000">28</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match17-0.html#1',2,'match17-1.html#1',3)" NAME="1">(78-104)<TD><A HREF="javascript:ZweiFrames('match17-0.html#1',2,'match17-1.html#1',3)" NAME="1">(212-245)</A><TD ALIGN=center><FONT COLOR="#f50000">27</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match17-0.html#2',2,'match17-1.html#2',3)" NAME="2">(48-72)<TD><A HREF="javascript:ZweiFrames('match17-0.html#2',2,'match17-1.html#2',3)" NAME="2">(84-110)</A><TD ALIGN=center><FONT COLOR="#b60000">20</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>lluv_prepare.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/******************************************************************************
* Author: Alexey Melnichuk &lt;alexeymelnichuck@gmail.com&gt;
*
* Copyright (C) 2014-2016 Alexey Melnichuk &lt;alexeymelnichuck@gmail.com&gt;
*
* Licensed according to the included 'LICENSE' document
*
* This file is part of lua-lluv library.
******************************************************************************/

#include &quot;lluv.h&quot;
#include &quot;lluv_handle.h&quot;
#include &quot;lluv_prepare.h&quot;
#include &quot;lluv_loop.h&quot;
#include &quot;lluv_error.h&quot;
<A NAME="0"></A>#include &lt;assert.h&gt;

#define LLUV_PREPARE_NAME LLUV_PREFIX&quot; Prepare&quot;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match17-1.html#0',3,'match17-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>static const char *LLUV_PREPARE = LLUV_PREPARE_NAME;

LLUV_INTERNAL int lluv_prepare_index(lua_State *L){
  return lluv__index(L, LLUV_PREPARE, lluv_handle_index);
}

LLUV_IMPL_SAFE(lluv_prepare_create){
  lluv_loop_t   *loop   = lluv_opt_loop_ex(L, 1, LLUV_FLAG_OPEN);
  lluv_handle_t *handle = lluv_handle_create(L, UV_PREPARE, safe_flag | INHERITE_FLAGS(loop));
  int err = uv_prepare_init(loop-&gt;handle, LLUV_H(handle, uv_prepare_t));
  if(err &lt; 0){
    lluv_handle_cleanup(L, handle, -1);
    return lluv_fail(L, safe_flag | loop-&gt;flags, LLUV_ERR_UV, (uv_errno_t)err, NULL);
  }
  return 1;
}

static lluv_handle_t* lluv_check_prepare(lua_State *L, int idx, lluv_flags_t flags){
  lluv_handle_t *handle = lluv_check_handle(L, idx, flags);
  luaL_argcheck (L, LLUV_H(handle, uv_handle_t)-&gt;type == UV_PREPARE, idx, LLUV_PREPARE_NAME&quot; expected&quot;);

  return handle;
}

static void lluv_on_prepare_start(uv_prepare_t *arg){</B></FONT>
  lluv_on_handle_start((uv_handle_t*)arg);
<A NAME="2"></A>}

static int lluv_prepare_start(lua_State *L){
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match17-1.html#2',3,'match17-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  lluv_handle_t *handle = lluv_check_prepare(L, 1, LLUV_FLAG_OPEN);
  int err;

  lluv_check_args_with_cb(L, 2);
  LLUV_START_CB(handle) = luaL_ref(L, LLUV_LUA_REGISTRY);

  err = uv_prepare_start(LLUV_H(handle, uv_prepare_t), lluv_on_prepare_start);

  if(err &gt;= 0) lluv_handle_lock(L, handle, LLUV_LOCK_START);

  return lluv_return(L, handle, LLUV_START_CB(handle), err);
}

static int lluv_prepare_stop(lua_State *L){
  lluv_handle_t *handle = lluv_check_prepare(L, 1, LLUV_FLAG_OPEN);
  int err = uv_prepare_stop(LLUV_H(handle, uv_prepare_t));
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }

  lluv_handle_unlock(L, handle, LLUV_LOCK_START);

  lua_settop(L, 1);
  return 1;
}</B></FONT>

static const struct luaL_Reg lluv_prepare_methods[] = {
<A NAME="1"></A>  { &quot;start&quot;,      lluv_prepare_start      },
  { &quot;stop&quot;,       lluv_prepare_stop       },

<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match17-1.html#1',3,'match17-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  {NULL,NULL}
};

#define LLUV_FUNCTIONS(F)               \
  {&quot;prepare&quot;, lluv_prepare_create_##F}, \

static const struct luaL_Reg lluv_functions[][2] = {
  {
    LLUV_FUNCTIONS(unsafe)

    {NULL,NULL}
  },
  {
    LLUV_FUNCTIONS(safe)

    {NULL,NULL}
  },
};

LLUV_INTERNAL void lluv_prepare_initlib(lua_State *L, int nup, int safe){
  lutil_pushnvalues(L, nup);
  if(!lutil_createmetap(L, LLUV_PREPARE, lluv_prepare_methods, nup))
    lua_pop(L, nup);
  lua_pop(L, 1);

  luaL_setfuncs(L, lluv_functions[safe], nup);
}</B></FONT>
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lluv_signal.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/******************************************************************************
* Author: Alexey Melnichuk &lt;alexeymelnichuck@gmail.com&gt;
*
* Copyright (C) 2014-2017 Alexey Melnichuk &lt;alexeymelnichuck@gmail.com&gt;
*
* Licensed according to the included 'LICENSE' document
*
* This file is part of lua-lluv library.
******************************************************************************/

#include &quot;lluv.h&quot;
#include &quot;lluv_handle.h&quot;
#include &quot;lluv_signal.h&quot;
#include &quot;lluv_loop.h&quot;
#include &quot;lluv_error.h&quot;
#include &lt;assert.h&gt;

#ifndef _WIN32

#include &lt;signal.h&gt;

<A NAME="0"></A>#endif

#define LLUV_SIGNAL_NAME LLUV_PREFIX&quot; Signal&quot;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match17-0.html#0',2,'match17-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>static const char *LLUV_SIGNAL = LLUV_SIGNAL_NAME;

LLUV_INTERNAL int lluv_signal_index(lua_State *L){
  return lluv__index(L, LLUV_SIGNAL, lluv_handle_index);
}

LLUV_IMPL_SAFE(lluv_signal_create){
  lluv_loop_t   *loop   = lluv_opt_loop_ex(L, 1, LLUV_FLAG_OPEN);
  lluv_handle_t *handle = lluv_handle_create(L, UV_SIGNAL, INHERITE_FLAGS(loop));
  int err = uv_signal_init(loop-&gt;handle, LLUV_H(handle, uv_signal_t));
  if(err &lt; 0){
    lluv_handle_cleanup(L, handle, -1);
    return lluv_fail(L, safe_flag | loop-&gt;flags, LLUV_ERR_UV, (uv_errno_t)err, NULL);
  }
  return 1;
}

static lluv_handle_t* lluv_check_signal(lua_State *L, int idx, lluv_flags_t flags){
  lluv_handle_t *handle = lluv_check_handle(L, idx, flags);
  luaL_argcheck (L, LLUV_H(handle, uv_handle_t)-&gt;type == UV_SIGNAL, idx, LLUV_SIGNAL_NAME&quot; expected&quot;);

  return handle;
}

static void lluv_on_signal_start(uv_signal_t *arg, int signum){</B></FONT>
  lluv_handle_t *handle = lluv_handle_byptr((uv_handle_t*)arg);
  lua_State *L = LLUV_HCALLBACK_L(handle);

  LLUV_CHECK_LOOP_CB_INVARIANT(L);

  lua_rawgeti(L, LLUV_LUA_REGISTRY, LLUV_START_CB(handle));
  assert(!lua_isnil(L, -1)); /* is callble */

  lluv_handle_pushself(L, handle);
  lua_pushinteger(L, signum);
  LLUV_HANDLE_CALL_CB(L, handle, 2);

  LLUV_CHECK_LOOP_CB_INVARIANT(L);
}

static int lluv_signal_start(lua_State *L){
  lluv_handle_t *handle = lluv_check_signal(L, 1, LLUV_FLAG_OPEN);
  int signum = luaL_checkint(L, 2);
  int err;

  lluv_check_args_with_cb(L, 3);
  LLUV_START_CB(handle) = luaL_ref(L, LLUV_LUA_REGISTRY);

  err = uv_signal_start(LLUV_H(handle, uv_signal_t), lluv_on_signal_start, signum);

  if(err &gt;= 0) lluv_handle_lock(L, handle, LLUV_LOCK_START);

  return lluv_return(L, handle, LLUV_START_CB(handle), err);
}

#if LLUV_UV_VER_GE(1,12,0)
<A NAME="2"></A>
static int lluv_signal_start_oneshot(lua_State *L){
  lluv_handle_t *handle = lluv_check_signal(L, 1, LLUV_FLAG_OPEN);
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match17-0.html#2',2,'match17-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  int signum = luaL_checkint(L, 2);
  int err;

  lluv_check_args_with_cb(L, 3);
  LLUV_START_CB(handle) = luaL_ref(L, LLUV_LUA_REGISTRY);

  err = uv_signal_start_oneshot(LLUV_H(handle, uv_signal_t), lluv_on_signal_start, signum);

  if(err &gt;= 0) lluv_handle_lock(L, handle, LLUV_LOCK_START);

  return lluv_return(L, handle, LLUV_START_CB(handle), err);
}

#endif

static int lluv_signal_stop(lua_State *L){
  lluv_handle_t *handle = lluv_check_signal(L, 1, LLUV_FLAG_OPEN);
  int err = uv_signal_stop(LLUV_H(handle, uv_signal_t));
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }

  lluv_handle_unlock(L, handle, LLUV_LOCK_START);

  lua_settop(L, 1);
  return 1;
}</B></FONT>

LLUV_IMPL_SAFE(lluv_signal_ignore){
#ifndef _WIN32
  int s = luaL_checkint(L, 1);
  signal(s, SIG_IGN);
#endif
  lua_pushboolean(L, 1);
  return 1;
}

LLUV_IMPL_SAFE(lluv_signal_default){
#ifndef _WIN32
  int s = luaL_checkint(L, 1);
  signal(s, SIG_DFL);
#endif
  lua_pushboolean(L, 1);
  return 1;
}

static const struct luaL_Reg lluv_signal_methods[] = {
#if LLUV_UV_VER_GE(1,12,0)
  { &quot;start_oneshot&quot;,  lluv_signal_start_oneshot  },
#endif
  { &quot;start&quot;,          lluv_signal_start          },
  { &quot;stop&quot;,           lluv_signal_stop           },

  {NULL,NULL}
};

static const lluv_uv_const_t lluv_signal_constants[] = {
#ifdef SIGINT
  { SIGINT,   &quot;SIGINT&quot;   },
#endif
#ifdef SIGBREAK
  { SIGBREAK, &quot;SIGBREAK&quot; },
#endif
#ifdef SIGHUP
  { SIGHUP,   &quot;SIGHUP&quot;   },
#endif
#ifdef SIGWINCH
  { SIGWINCH, &quot;SIGWINCH&quot; },
#endif
#ifdef SIGPIPE
  { SIGPIPE, &quot;SIGPIPE&quot; },
#endif
#ifdef SIGQUIT
  { SIGQUIT, &quot;SIGQUIT&quot; },
#endif
#ifdef SIGILL
  { SIGILL, &quot;SIGILL&quot; },
#endif
#ifdef SIGABRT
  { SIGABRT, &quot;SIGABRT&quot; },
#endif
#ifdef SIGTRAP
  { SIGTRAP, &quot;SIGTRAP&quot; },
#endif
#ifdef SIGIOT
  { SIGIOT, &quot;SIGIOT&quot; },
#endif
#ifdef SIGEMT
  { SIGEMT, &quot;SIGEMT&quot; },
#endif
#ifdef SIGFPE
  { SIGFPE, &quot;SIGFPE&quot; },
#endif
#ifdef SIGKILL
  { SIGKILL, &quot;SIGKILL&quot; },
#endif
#ifdef SIGBUS
  { SIGBUS, &quot;SIGBUS&quot; },
#endif
#ifdef SIGSEGV
  { SIGSEGV, &quot;SIGSEGV&quot; },
#endif
#ifdef SIGSYS
  { SIGSYS, &quot;SIGSYS&quot; },
#endif
#ifdef SIGALRM
  { SIGALRM, &quot;SIGALRM&quot; },
#endif
#ifdef SIGUSR1
  { SIGUSR1, &quot;SIGUSR1&quot; },
#endif
#ifdef SIGUSR2
  { SIGUSR2, &quot;SIGUSR2&quot; },
#endif
#ifdef SIGCHLD
  { SIGCHLD, &quot;SIGCHLD&quot; },
#endif
#ifdef SIGCLD
  { SIGCLD, &quot;SIGCLD&quot; },
#endif
#ifdef SIGPWR
  { SIGPWR, &quot;SIGPWR&quot; },
#endif
#ifdef SIGXCPU
  { SIGXCPU, &quot;SIGXCPU&quot; },
<A NAME="1"></A>#endif
  { SIGTERM,  &quot;SIGTERM&quot;  },

<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match17-0.html#1',2,'match17-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  { 0, NULL }
};

#define LLUV_FUNCTIONS(F)                      \
  {&quot;signal&quot;,         lluv_signal_create_##F }, \
  {&quot;signal_ignore&quot;,  lluv_signal_ignore_##F }, \
  {&quot;signal_default&quot;, lluv_signal_default_##F}, \

static const struct luaL_Reg lluv_functions[][4] = {
  {
    LLUV_FUNCTIONS(unsafe)

    {NULL,NULL}
  },
  {
    LLUV_FUNCTIONS(safe)

    {NULL,NULL}
  },
};

LLUV_INTERNAL void lluv_signal_initlib(lua_State *L, int nup, int safe){
  lutil_pushnvalues(L, nup);
  if(!lutil_createmetap(L, LLUV_SIGNAL, lluv_signal_methods, nup))
    lua_pop(L, nup);
  lua_pop(L, 1);

  luaL_setfuncs(L, lluv_functions[safe], nup);
  lluv_register_constants(L, lluv_signal_constants);

#ifndef _WIN32
  signal(SIGPIPE, SIG_IGN);
#endif
}</B></FONT>
</PRE>
</div>
  </div>
</body>
</html>
