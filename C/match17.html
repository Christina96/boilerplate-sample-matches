<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for lluv_prepare.c &amp; lluv_signal.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for lluv_prepare.c &amp; lluv_signal.c
      </h3>
<h1 align="center">
        56.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>lluv_prepare.c (82.41758%)<th>lluv_signal.c (42.613636%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(19-43)<td><a href="#" name="0">(25-49)</a><td align="center"><font color="#ff0000">28</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(78-104)<td><a href="#" name="1">(212-245)</a><td align="center"><font color="#f50000">27</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(48-72)<td><a href="#" name="2">(84-110)</a><td align="center"><font color="#b60000">20</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>lluv_prepare.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "lluv.h"
2 #include "lluv_handle.h"
3 #include "lluv_prepare.h"
4 #include "lluv_loop.h"
5 #include "lluv_error.h"
6 <a name="0"></a>#include &lt;assert.h&gt;
7 #define LLUV_PREPARE_NAME LLUV_PREFIX" Prepare"
8 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static const char *LLUV_PREPARE = LLUV_PREPARE_NAME;
9 LLUV_INTERNAL int lluv_prepare_index(lua_State *L){
10   return lluv__index(L, LLUV_PREPARE, lluv_handle_index);
11 }
12 LLUV_IMPL_SAFE(lluv_prepare_create){
13   lluv_loop_t   *loop   = lluv_opt_loop_ex(L, 1, LLUV_FLAG_OPEN);
14   lluv_handle_t *handle = lluv_handle_create(L, UV_PREPARE, safe_flag | INHERITE_FLAGS(loop));
15   int err = uv_prepare_init(loop-&gt;handle, LLUV_H(handle, uv_prepare_t));
16   if(err &lt; 0){
17     lluv_handle_cleanup(L, handle, -1);
18     return lluv_fail(L, safe_flag | loop-&gt;flags, LLUV_ERR_UV, (uv_errno_t)err, NULL);
19   }
20   return 1;
21 }
22 static lluv_handle_t* lluv_check_prepare(lua_State *L, int idx, lluv_flags_t flags){
23   lluv_handle_t *handle = lluv_check_handle(L, idx, flags);
24   luaL_argcheck (L, LLUV_H(handle, uv_handle_t)-&gt;type == UV_PREPARE, idx, LLUV_PREPARE_NAME" expected");
25   return handle;
26 }
27 static void lluv_on_prepare_start(uv_prepare_t *arg){</b></font>
28   lluv_on_handle_start((uv_handle_t*)arg);
29 <a name="2"></a>}
30 static int lluv_prepare_start(lua_State *L){
31 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  lluv_handle_t *handle = lluv_check_prepare(L, 1, LLUV_FLAG_OPEN);
32   int err;
33   lluv_check_args_with_cb(L, 2);
34   LLUV_START_CB(handle) = luaL_ref(L, LLUV_LUA_REGISTRY);
35   err = uv_prepare_start(LLUV_H(handle, uv_prepare_t), lluv_on_prepare_start);
36   if(err &gt;= 0) lluv_handle_lock(L, handle, LLUV_LOCK_START);
37   return lluv_return(L, handle, LLUV_START_CB(handle), err);
38 }
39 static int lluv_prepare_stop(lua_State *L){
40   lluv_handle_t *handle = lluv_check_prepare(L, 1, LLUV_FLAG_OPEN);
41   int err = uv_prepare_stop(LLUV_H(handle, uv_prepare_t));
42   if(err &lt; 0){
43     return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
44   }
45   lluv_handle_unlock(L, handle, LLUV_LOCK_START);
46   lua_settop(L, 1);
47   return 1;
48 }</b></font>
49 static const struct luaL_Reg lluv_prepare_methods[] = {
50 <a name="1"></a>  { "start",      lluv_prepare_start      },
51   { "stop",       lluv_prepare_stop       },
52 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  {NULL,NULL}
53 };
54 #define LLUV_FUNCTIONS(F)               \
55   {"prepare", lluv_prepare_create_##F}, \
56 static const struct luaL_Reg lluv_functions[][2] = {
57   {
58     LLUV_FUNCTIONS(unsafe)
59     {NULL,NULL}
60   },
61   {
62     LLUV_FUNCTIONS(safe)
63     {NULL,NULL}
64   },
65 };
66 LLUV_INTERNAL void lluv_prepare_initlib(lua_State *L, int nup, int safe){
67   lutil_pushnvalues(L, nup);
68   if(!lutil_createmetap(L, LLUV_PREPARE, lluv_prepare_methods, nup))
69     lua_pop(L, nup);
70   lua_pop(L, 1);
71   luaL_setfuncs(L, lluv_functions[safe], nup);
72 }</b></font>
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lluv_signal.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "lluv.h"
2 #include "lluv_handle.h"
3 #include "lluv_signal.h"
4 #include "lluv_loop.h"
5 #include "lluv_error.h"
6 #include &lt;assert.h&gt;
7 #ifndef _WIN32
8 #include &lt;signal.h&gt;
9 <a name="0"></a>#endif
10 #define LLUV_SIGNAL_NAME LLUV_PREFIX" Signal"
11 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static const char *LLUV_SIGNAL = LLUV_SIGNAL_NAME;
12 LLUV_INTERNAL int lluv_signal_index(lua_State *L){
13   return lluv__index(L, LLUV_SIGNAL, lluv_handle_index);
14 }
15 LLUV_IMPL_SAFE(lluv_signal_create){
16   lluv_loop_t   *loop   = lluv_opt_loop_ex(L, 1, LLUV_FLAG_OPEN);
17   lluv_handle_t *handle = lluv_handle_create(L, UV_SIGNAL, INHERITE_FLAGS(loop));
18   int err = uv_signal_init(loop-&gt;handle, LLUV_H(handle, uv_signal_t));
19   if(err &lt; 0){
20     lluv_handle_cleanup(L, handle, -1);
21     return lluv_fail(L, safe_flag | loop-&gt;flags, LLUV_ERR_UV, (uv_errno_t)err, NULL);
22   }
23   return 1;
24 }
25 static lluv_handle_t* lluv_check_signal(lua_State *L, int idx, lluv_flags_t flags){
26   lluv_handle_t *handle = lluv_check_handle(L, idx, flags);
27   luaL_argcheck (L, LLUV_H(handle, uv_handle_t)-&gt;type == UV_SIGNAL, idx, LLUV_SIGNAL_NAME" expected");
28   return handle;
29 }
30 static void lluv_on_signal_start(uv_signal_t *arg, int signum){</b></font>
31   lluv_handle_t *handle = lluv_handle_byptr((uv_handle_t*)arg);
32   lua_State *L = LLUV_HCALLBACK_L(handle);
33   LLUV_CHECK_LOOP_CB_INVARIANT(L);
34   lua_rawgeti(L, LLUV_LUA_REGISTRY, LLUV_START_CB(handle));
35   assert(!lua_isnil(L, -1)); 
36   lluv_handle_pushself(L, handle);
37   lua_pushinteger(L, signum);
38   LLUV_HANDLE_CALL_CB(L, handle, 2);
39   LLUV_CHECK_LOOP_CB_INVARIANT(L);
40 }
41 static int lluv_signal_start(lua_State *L){
42   lluv_handle_t *handle = lluv_check_signal(L, 1, LLUV_FLAG_OPEN);
43   int signum = luaL_checkint(L, 2);
44   int err;
45   lluv_check_args_with_cb(L, 3);
46   LLUV_START_CB(handle) = luaL_ref(L, LLUV_LUA_REGISTRY);
47   err = uv_signal_start(LLUV_H(handle, uv_signal_t), lluv_on_signal_start, signum);
48   if(err &gt;= 0) lluv_handle_lock(L, handle, LLUV_LOCK_START);
49   return lluv_return(L, handle, LLUV_START_CB(handle), err);
50 }
51 #if LLUV_UV_VER_GE(1,12,0)
52 <a name="2"></a>
53 static int lluv_signal_start_oneshot(lua_State *L){
54   lluv_handle_t *handle = lluv_check_signal(L, 1, LLUV_FLAG_OPEN);
55 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  int signum = luaL_checkint(L, 2);
56   int err;
57   lluv_check_args_with_cb(L, 3);
58   LLUV_START_CB(handle) = luaL_ref(L, LLUV_LUA_REGISTRY);
59   err = uv_signal_start_oneshot(LLUV_H(handle, uv_signal_t), lluv_on_signal_start, signum);
60   if(err &gt;= 0) lluv_handle_lock(L, handle, LLUV_LOCK_START);
61   return lluv_return(L, handle, LLUV_START_CB(handle), err);
62 }
63 #endif
64 static int lluv_signal_stop(lua_State *L){
65   lluv_handle_t *handle = lluv_check_signal(L, 1, LLUV_FLAG_OPEN);
66   int err = uv_signal_stop(LLUV_H(handle, uv_signal_t));
67   if(err &lt; 0){
68     return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
69   }
70   lluv_handle_unlock(L, handle, LLUV_LOCK_START);
71   lua_settop(L, 1);
72   return 1;
73 }</b></font>
74 LLUV_IMPL_SAFE(lluv_signal_ignore){
75 #ifndef _WIN32
76   int s = luaL_checkint(L, 1);
77   signal(s, SIG_IGN);
78 #endif
79   lua_pushboolean(L, 1);
80   return 1;
81 }
82 LLUV_IMPL_SAFE(lluv_signal_default){
83 #ifndef _WIN32
84   int s = luaL_checkint(L, 1);
85   signal(s, SIG_DFL);
86 #endif
87   lua_pushboolean(L, 1);
88   return 1;
89 }
90 static const struct luaL_Reg lluv_signal_methods[] = {
91 #if LLUV_UV_VER_GE(1,12,0)
92   { "start_oneshot",  lluv_signal_start_oneshot  },
93 #endif
94   { "start",          lluv_signal_start          },
95   { "stop",           lluv_signal_stop           },
96   {NULL,NULL}
97 };
98 static const lluv_uv_const_t lluv_signal_constants[] = {
99 #ifdef SIGINT
100   { SIGINT,   "SIGINT"   },
101 #endif
102 #ifdef SIGBREAK
103   { SIGBREAK, "SIGBREAK" },
104 #endif
105 #ifdef SIGHUP
106   { SIGHUP,   "SIGHUP"   },
107 #endif
108 #ifdef SIGWINCH
109   { SIGWINCH, "SIGWINCH" },
110 #endif
111 #ifdef SIGPIPE
112   { SIGPIPE, "SIGPIPE" },
113 #endif
114 #ifdef SIGQUIT
115   { SIGQUIT, "SIGQUIT" },
116 #endif
117 #ifdef SIGILL
118   { SIGILL, "SIGILL" },
119 #endif
120 #ifdef SIGABRT
121   { SIGABRT, "SIGABRT" },
122 #endif
123 #ifdef SIGTRAP
124   { SIGTRAP, "SIGTRAP" },
125 #endif
126 #ifdef SIGIOT
127   { SIGIOT, "SIGIOT" },
128 #endif
129 #ifdef SIGEMT
130   { SIGEMT, "SIGEMT" },
131 #endif
132 #ifdef SIGFPE
133   { SIGFPE, "SIGFPE" },
134 #endif
135 #ifdef SIGKILL
136   { SIGKILL, "SIGKILL" },
137 #endif
138 #ifdef SIGBUS
139   { SIGBUS, "SIGBUS" },
140 #endif
141 #ifdef SIGSEGV
142   { SIGSEGV, "SIGSEGV" },
143 #endif
144 #ifdef SIGSYS
145   { SIGSYS, "SIGSYS" },
146 #endif
147 #ifdef SIGALRM
148   { SIGALRM, "SIGALRM" },
149 #endif
150 #ifdef SIGUSR1
151   { SIGUSR1, "SIGUSR1" },
152 #endif
153 #ifdef SIGUSR2
154   { SIGUSR2, "SIGUSR2" },
155 #endif
156 #ifdef SIGCHLD
157   { SIGCHLD, "SIGCHLD" },
158 #endif
159 #ifdef SIGCLD
160   { SIGCLD, "SIGCLD" },
161 #endif
162 #ifdef SIGPWR
163   { SIGPWR, "SIGPWR" },
164 #endif
165 #ifdef SIGXCPU
166   { SIGXCPU, "SIGXCPU" },
167 <a name="1"></a>#endif
168   { SIGTERM,  "SIGTERM"  },
169 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  { 0, NULL }
170 };
171 #define LLUV_FUNCTIONS(F)                      \
172   {"signal",         lluv_signal_create_##F }, \
173   {"signal_ignore",  lluv_signal_ignore_##F }, \
174   {"signal_default", lluv_signal_default_##F}, \
175 static const struct luaL_Reg lluv_functions[][4] = {
176   {
177     LLUV_FUNCTIONS(unsafe)
178     {NULL,NULL}
179   },
180   {
181     LLUV_FUNCTIONS(safe)
182     {NULL,NULL}
183   },
184 };
185 LLUV_INTERNAL void lluv_signal_initlib(lua_State *L, int nup, int safe){
186   lutil_pushnvalues(L, nup);
187   if(!lutil_createmetap(L, LLUV_SIGNAL, lluv_signal_methods, nup))
188     lua_pop(L, nup);
189   lua_pop(L, 1);
190   luaL_setfuncs(L, lluv_functions[safe], nup);
191   lluv_register_constants(L, lluv_signal_constants);
192 #ifndef _WIN32
193   signal(SIGPIPE, SIG_IGN);
194 #endif
195 }</b></font>
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
