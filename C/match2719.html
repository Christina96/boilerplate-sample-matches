<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-adopted-session-record.c &amp; infc-browser.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-adopted-session-record.c &amp; infc-browser.c
      </h3>
<h1 align="center">
        2.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-adopted-session-record.c (14.420063%)<th>infc-browser.c (1.3909888%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(405-431)<td><a href="#" name="0">(1761-1788)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(433-458)<td><a href="#" name="1">(1873-1898)</a><td align="center"><font color="#e10000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(342-358)<td><a href="#" name="2">(1643-1659)</a><td align="center"><font color="#d20000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-adopted-session-record.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinfinity/adopted/inf-adopted-session-record.h&gt;
#include &lt;libinfinity/common/inf-xml-util.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
#include &lt;libxml/xmlwriter.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
typedef struct _InfAdoptedSessionRecordPrivate InfAdoptedSessionRecordPrivate;
struct _InfAdoptedSessionRecordPrivate {
  InfAdoptedSession* session;
  xmlTextWriterPtr writer;
  FILE* file;
  gchar* filename;
  GHashTable* last_send_table;
};
enum {
  PROP_0,
  PROP_SESSION,
  PROP_FILENAME
};
#define INF_ADOPTED_SESSION_RECORD_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_ADOPTED_TYPE_SESSION_RECORD, InfAdoptedSessionRecordPrivate))
static GQuark libxml2_writer_error_quark;
G_DEFINE_TYPE_WITH_CODE(InfAdoptedSessionRecord, inf_adopted_session_record, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfAdoptedSessionRecord))
static void
inf_adopted_session_record_handle_xml_error(InfAdoptedSessionRecord* record)
{
  InfAdoptedSessionRecordPrivate* priv;
  xmlErrorPtr xmlerror;
  priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
  xmlerror = xmlGetLastError();
  g_warning(
    _("Error writing record \"%s\": %s"),
    priv-&gt;filename,
    xmlerror-&gt;message
  );
}
static void
inf_adopted_session_record_write_node(InfAdoptedSessionRecord* record,
                                      xmlNodePtr xml)
{
  InfAdoptedSessionRecordPrivate* priv;
  xmlAttrPtr attr;
  xmlChar* value;
  xmlNodePtr child;
  int result;
  priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
  result = xmlTextWriterStartElement(priv-&gt;writer, xml-&gt;name);
  if(result &lt; 0) inf_adopted_session_record_handle_xml_error(record);
  for(attr = xml-&gt;properties; attr != NULL; attr = attr-&gt;next)
  {
    value = xmlGetProp(xml, attr-&gt;name);
    result = xmlTextWriterWriteAttribute(priv-&gt;writer, attr-&gt;name, value);
    if(result &lt; 0) inf_adopted_session_record_handle_xml_error(record);
    xmlFree(value);
  }
  for(child = xml-&gt;children; child != NULL; child = child-&gt;next)
  {
    if(child-&gt;type == XML_ELEMENT_NODE)
    {
      inf_adopted_session_record_write_node(record, child);
    }
    else if(child-&gt;type == XML_TEXT_NODE)
    {
      value = xmlNodeGetContent(child);
      result = xmlTextWriterWriteString(priv-&gt;writer, value);
      if(result &lt; 0) inf_adopted_session_record_handle_xml_error(record);
      xmlFree(value);
    }
  }
  result = xmlTextWriterEndElement(priv-&gt;writer);
  if(result &lt; 0) inf_adopted_session_record_handle_xml_error(record);
}
static void
inf_adopted_session_record_user_joined(InfAdoptedSessionRecord* record,
                                       InfAdoptedUser* user)
{
  InfAdoptedSessionRecordPrivate* priv;
  priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
  g_hash_table_insert(
    priv-&gt;last_send_table,
    user,
    inf_adopted_state_vector_copy(inf_adopted_user_get_vector(user))
  );
}
static void
inf_adopted_session_record_begin_execute_request_cb(InfAdoptedAlgorithm* algo,
                                                    InfAdoptedUser* user,
                                                    InfAdoptedRequest* req,
                                                    gpointer user_data)
{
  InfAdoptedSessionRecord* record;
  InfAdoptedSessionRecordPrivate* priv;
  InfAdoptedSessionClass* session_class;
  InfAdoptedStateVector* previous;
  xmlNodePtr xml;
  int result;
  record = INF_ADOPTED_SESSION_RECORD(user_data);
  priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
  session_class = INF_ADOPTED_SESSION_GET_CLASS(priv-&gt;session);
  xml = xmlNewNode(NULL, (const xmlChar*)"request");
  previous = g_hash_table_lookup(priv-&gt;last_send_table, user);
  g_assert(previous != NULL);
  session_class-&gt;request_to_xml(priv-&gt;session, xml, req, previous, FALSE);
  inf_xml_util_set_attribute_double(
    xml,
    "received",
    inf_adopted_request_get_receive_time(req) / 1000000.
  );
  inf_xml_util_set_attribute_double(
    xml,
    "executed",
    inf_adopted_request_get_execute_time(req) / 1000000.
  );
  inf_adopted_session_record_write_node(record, xml);
  xmlFreeNode(xml);
  result = xmlTextWriterFlush(priv-&gt;writer);
  if(result &lt; 0) inf_adopted_session_record_handle_xml_error(record);
  fflush(priv-&gt;file);
  previous =
    inf_adopted_state_vector_copy(inf_adopted_request_get_vector(req));
  if(inf_adopted_request_affects_buffer(req))
    inf_adopted_state_vector_add(previous, inf_user_get_id(INF_USER(user)), 1);
  g_hash_table_insert(priv-&gt;last_send_table, user, previous);
}
static void
inf_adopted_session_record_add_user_cb(InfUserTable* user_table,
                                       InfUser* user,
                                       gpointer user_data)
{
  InfAdoptedSessionRecord* record;
  InfAdoptedSessionRecordPrivate* priv;
  xmlNodePtr xml;
  int result;
  record = INF_ADOPTED_SESSION_RECORD(user_data);
  priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
  inf_adopted_session_record_user_joined(record, INF_ADOPTED_USER(user));
  result = xmlTextWriterWriteString(priv-&gt;writer, (const xmlChar*)"\n  ");
  if(result &lt; 0) inf_adopted_session_record_handle_xml_error(record);
  xml = xmlNewNode(NULL, (const xmlChar*)"user");
  inf_session_user_to_xml(INF_SESSION(priv-&gt;session), user, xml);
  inf_xml_util_set_attribute_double(
    xml,
    "executed",
    g_get_real_time() / 1000000.
  );
  inf_adopted_session_record_write_node(record, xml);
  xmlFreeNode(xml);
  result = xmlTextWriterFlush(priv-&gt;writer);
  if(result &lt; 0) inf_adopted_session_record_handle_xml_error(record);
  fflush(priv-&gt;file);
}
static void
inf_adopted_session_record_start_foreach_user_func(InfUser* user,
                                                   gpointer user_data)
{
  inf_adopted_session_record_user_joined(
    INF_ADOPTED_SESSION_RECORD(user_data),
    INF_ADOPTED_USER(user)
  );
}
static void
inf_adopted_session_record_real_start(InfAdoptedSessionRecord* record)
{
  InfAdoptedSessionRecordPrivate* priv;
  InfAdoptedAlgorithm* algorithm;
  InfUserTable* user_table;
  xmlNodePtr xml;
  xmlNodePtr child;
  xmlNodePtr cur;
  int result;
  guint total;
  InfSessionClass* session_class;
  priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
  algorithm = inf_adopted_session_get_algorithm(priv-&gt;session);
  user_table = inf_session_get_user_table(INF_SESSION(priv-&gt;session));
  session_class = INF_SESSION_GET_CLASS(priv-&gt;session);
  g_signal_connect(
    G_OBJECT(algorithm),
    "begin-execute-request",
    G_CALLBACK(inf_adopted_session_record_begin_execute_request_cb),
    record
  );
  g_signal_connect(
    G_OBJECT(user_table),
    "add-user",
    G_CALLBACK(inf_adopted_session_record_add_user_cb),
    record
  );
  priv-&gt;last_send_table = g_hash_table_new_full(
    NULL,
    NULL,
    NULL,
    (GDestroyNotify)inf_adopted_state_vector_free
  );
  inf_user_table_foreach_user(
    inf_session_get_user_table(INF_SESSION(priv-&gt;session)),
    inf_adopted_session_record_start_foreach_user_func,
    record
  );
  result = xmlTextWriterStartDocument(priv-&gt;writer, NULL, "UTF-8", NULL);
  if(result &lt; 0) inf_adopted_session_record_handle_xml_error(record);
  result = xmlTextWriterStartElement(
    priv-&gt;writer,
    (const xmlChar*)"infinote-adopted-session-record"
  );
  if(result &lt; 0) inf_adopted_session_record_handle_xml_error(record);
  xml = xmlNewNode(NULL, (const xmlChar*)"initial");
  child = xmlNewChild(xml, NULL, (const xmlChar*)"sync-begin", NULL);
  session_class-&gt;to_xml_sync(INF_SESSION(priv-&gt;session), xml);
  xmlNewChild(xml, NULL, (const xmlChar*)"sync-end", NULL);
  total = 0;
  for(cur = child; cur != NULL; cur = cur-&gt;next)
    ++ total;
  inf_xml_util_set_attribute_uint(child, "num-messages", total - 2);
  inf_adopted_session_record_write_node(record, xml);
  xmlFreeNode(xml);
  result = xmlTextWriterFlush(priv-&gt;writer);
  if(result &lt; 0) inf_adopted_session_record_handle_xml_error(record);
  fflush(priv-&gt;file);
}
static void
inf_adopted_session_record_synchronization_complete_cb(InfSession* session,
                                                       InfXmlConnection* conn,
                                                       gpointer user_data)
{
  InfAdoptedSessionRecord* record;
  record = INF_ADOPTED_SESSION_RECORD(user_data);
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(session),
    G_CALLBACK(inf_adopted_session_record_synchronization_complete_cb),
    record
<a name="2"></a>  );
  inf_adopted_session_record_real_start(record);
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
static void
inf_adopted_session_record_init(InfAdoptedSessionRecord* record)
{
  InfAdoptedSessionRecordPrivate* priv;
  priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
  priv-&gt;session = NULL;
  priv-&gt;writer = NULL;
  priv-&gt;file = NULL;
  priv-&gt;filename = NULL;
  priv-&gt;last_send_table = NULL;</b></font>
}
static void
inf_adopted_session_record_dispose(GObject* object)
{
  InfAdoptedSessionRecord* record;
  InfAdoptedSessionRecordPrivate* priv;
  GError* error;
  record = INF_ADOPTED_SESSION_RECORD(object);
  priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
  if(priv-&gt;writer != NULL)
  {
    error = NULL;
    inf_adopted_session_record_stop_recording(record, &amp;error);
    if(error != NULL)
    {
      g_assert(priv-&gt;filename != NULL);
      g_warning(
        "Error while finishing record `%s': %s",
        priv-&gt;filename,
        error-&gt;message
      );
      g_error_free(error);
    }
  }
  if(priv-&gt;session != NULL)
  {
    g_object_unref(priv-&gt;session);
    priv-&gt;session = NULL;
  }
  G_OBJECT_CLASS(inf_adopted_session_record_parent_class)-&gt;dispose(object);
}
static void
inf_adopted_session_record_finalize(GObject* object)
{
<a name="0"></a>  InfAdoptedSessionRecord* record;
  InfAdoptedSessionRecordPrivate* priv;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  record = INF_ADOPTED_SESSION_RECORD(object);
  priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
  g_assert(priv-&gt;filename == NULL);
  G_OBJECT_CLASS(inf_adopted_session_record_parent_class)-&gt;finalize(object);
}
static void
inf_adopted_session_record_set_property(GObject* object,
                                        guint prop_id,
                                        const GValue* value,
                                        GParamSpec* pspec)
{
  InfAdoptedSessionRecord* record;
  InfAdoptedSessionRecordPrivate* priv;
  record = INF_ADOPTED_SESSION_RECORD(object);
  priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
  switch(prop_id)
  {
  case PROP_SESSION:
    g_assert(priv-&gt;session == NULL);     priv-&gt;session = INF_ADOPTED_SESSION(g_value_dup_object(value));
<a name="1"></a>    break;
  case PROP_FILENAME:</b></font>
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_adopted_session_record_get_property(GObject* object,
                                        guint prop_id,
                                        GValue* value,
                                        GParamSpec* pspec)
{
  InfAdoptedSessionRecord* record;
  InfAdoptedSessionRecordPrivate* priv;
  record = INF_ADOPTED_SESSION_RECORD(object);
  priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
  switch(prop_id)
  {
  case PROP_SESSION:
    g_value_set_object(value, G_OBJECT(priv-&gt;session));
    break;
  case PROP_FILENAME:
    g_value_set_string(value, priv-&gt;filename);
    break;</b></font>
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_adopted_session_record_class_init(
  InfAdoptedSessionRecordClass* record_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(record_class);
  object_class-&gt;dispose = inf_adopted_session_record_dispose;
  object_class-&gt;finalize = inf_adopted_session_record_finalize;
  object_class-&gt;set_property = inf_adopted_session_record_set_property;
  object_class-&gt;get_property = inf_adopted_session_record_get_property;
  libxml2_writer_error_quark =
    g_quark_from_static_string("LIBXML2_WRITER_ERROR");
  g_object_class_install_property(
    object_class,
    PROP_SESSION,
    g_param_spec_object(
      "session",
      "Session",
      "The session to record",
      INF_ADOPTED_TYPE_SESSION,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_FILENAME,
    g_param_spec_string(
      "filename",
      "Filename",
      "The filename of the record file",
      NULL,
      G_PARAM_READABLE
    )
  );
}
InfAdoptedSessionRecord*
inf_adopted_session_record_new(InfAdoptedSession* session)
{
  GObject* object;
  g_return_val_if_fail(INF_ADOPTED_IS_SESSION(session), NULL);
  object = g_object_new(
    INF_ADOPTED_TYPE_SESSION_RECORD,
    "session", session,
    NULL
  );
  return INF_ADOPTED_SESSION_RECORD(object);
}
gboolean
inf_adopted_session_record_start_recording(InfAdoptedSessionRecord* record,
                                           const gchar* filename,
                                           GError** error)
{
  InfAdoptedSessionRecordPrivate* priv;
  InfSessionStatus status;
  xmlOutputBufferPtr buffer;
  xmlErrorPtr xmlerror;
  int errcode;
  g_return_val_if_fail(INF_ADOPTED_IS_SESSION_RECORD(record), FALSE);
  g_return_val_if_fail(filename != NULL, FALSE);
  g_return_val_if_fail(error == NULL || *error == NULL, FALSE);
  priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
  status = inf_session_get_status(INF_SESSION(priv-&gt;session));
  g_return_val_if_fail(priv-&gt;writer == NULL, FALSE);
  g_return_val_if_fail(status != INF_SESSION_CLOSED, FALSE);
  priv-&gt;file = fopen(filename, "w");
  if(priv-&gt;file == NULL)
  {
    errcode = errno;
    g_set_error_literal(
      error,
      g_quark_from_static_string("ERRNO_ERROR"),
      errcode,
      strerror(errcode)
    );
    return FALSE;
  }
  buffer = xmlOutputBufferCreateFile(priv-&gt;file, NULL);
  if(buffer == NULL)
  {
    fclose(priv-&gt;file);
    priv-&gt;file = NULL;
    xmlerror = xmlGetLastError();
    g_set_error_literal(
      error,
      libxml2_writer_error_quark,
      xmlerror-&gt;code,
      xmlerror-&gt;message
    );
    return FALSE;
  }
  priv-&gt;writer = xmlNewTextWriter(buffer);
  if(priv-&gt;writer == NULL)
  {
    xmlOutputBufferClose(buffer);
    priv-&gt;file = NULL;
    xmlerror = xmlGetLastError();
    g_set_error_literal(
      error,
      libxml2_writer_error_quark,
      xmlerror-&gt;code,
      xmlerror-&gt;message
    );
    return FALSE;
  }
  xmlTextWriterSetIndent(priv-&gt;writer, 1);
  switch(status)
  {
  case INF_SESSION_SYNCHRONIZING:
    g_signal_connect_after(
      G_OBJECT(priv-&gt;session),
      "synchronization-complete",
      G_CALLBACK(inf_adopted_session_record_synchronization_complete_cb),
      record
    );
    break;
  case INF_SESSION_RUNNING:
    inf_adopted_session_record_real_start(record);
    break;
  default:
    g_assert_not_reached();
    break;
  }
  g_assert(priv-&gt;filename == NULL);
  priv-&gt;filename = g_strdup(filename);
  g_object_notify(G_OBJECT(record), "filename");
  return TRUE;
}
gboolean
inf_adopted_session_record_stop_recording(InfAdoptedSessionRecord* record,
                                          GError** error)
{
  InfAdoptedSessionRecordPrivate* priv;
  InfSessionStatus status;
  InfAdoptedAlgorithm* algorithm;
  InfUserTable* user_table;
  xmlErrorPtr xmlerror;
  int result;
  g_return_val_if_fail(INF_ADOPTED_IS_SESSION_RECORD(record), FALSE);
  g_return_val_if_fail(error == NULL || *error == NULL, FALSE);
  priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
  g_return_val_if_fail(priv-&gt;writer != NULL, FALSE);
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(priv-&gt;session),
    G_CALLBACK(inf_adopted_session_record_synchronization_complete_cb),
    record
  );
  status = inf_session_get_status(INF_SESSION(priv-&gt;session));
  if(status != INF_SESSION_SYNCHRONIZING)
  {
    user_table = inf_session_get_user_table(INF_SESSION(priv-&gt;session));
    if(status != INF_SESSION_CLOSED)
    {
      algorithm = inf_adopted_session_get_algorithm(priv-&gt;session);
      g_assert(algorithm != NULL);
      inf_signal_handlers_disconnect_by_func(
        G_OBJECT(algorithm),
        G_CALLBACK(inf_adopted_session_record_begin_execute_request_cb),
        record
      );
    }
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(user_table),
      G_CALLBACK(inf_adopted_session_record_add_user_cb),
      record
    );
  }
  result = xmlTextWriterWriteString(priv-&gt;writer, (const xmlChar*)"\n");
  if(result &lt; 0) inf_adopted_session_record_handle_xml_error(record);
  result = xmlTextWriterEndDocument(priv-&gt;writer);
  if(result &lt; 0)
  {
    xmlerror = xmlGetLastError();
    g_set_error_literal(
      error,
      libxml2_writer_error_quark,
      xmlerror-&gt;code,
      xmlerror-&gt;message
    );
    return FALSE;
  }
  xmlFreeTextWriter(priv-&gt;writer);
  priv-&gt;writer = NULL;
  priv-&gt;file = NULL;
  g_free(priv-&gt;filename);
  priv-&gt;filename = NULL;
  if(priv-&gt;last_send_table != NULL)
  {
    g_hash_table_unref(priv-&gt;last_send_table);
    priv-&gt;last_send_table = NULL;
  }
  g_object_notify(G_OBJECT(record), "filename");
  return result &gt;= 0;
}
gboolean
inf_adopted_session_record_is_recording(InfAdoptedSessionRecord* record)
{
  g_return_val_if_fail(INF_ADOPTED_IS_SESSION_RECORD(record), FALSE);
  return INF_ADOPTED_SESSION_RECORD_PRIVATE(record)-&gt;writer != NULL;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>infc-browser.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinfinity/client/infc-browser.h&gt;
#include &lt;libinfinity/client/infc-progress-request.h&gt;
#include &lt;libinfinity/client/infc-request-manager.h&gt;
#include &lt;libinfinity/common/inf-request-result.h&gt;
#include &lt;libinfinity/common/inf-chat-session.h&gt;
#include &lt;libinfinity/common/inf-cert-util.h&gt;
#include &lt;libinfinity/common/inf-xml-util.h&gt;
#include &lt;libinfinity/common/inf-protocol.h&gt;
#include &lt;libinfinity/common/inf-error.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
#include &lt;string.h&gt;
#ifdef G_OS_WIN32
# ifdef ERROR
#  undef ERROR
# endif
#endif
typedef enum _InfcBrowserNodeType {
  INFC_BROWSER_NODE_SUBDIRECTORY = 1 &lt;&lt; 0,
  INFC_BROWSER_NODE_NOTE_KNOWN   = 1 &lt;&lt; 1,
  INFC_BROWSER_NODE_NOTE_UNKNOWN = 1 &lt;&lt; 2
} InfcBrowserNodeType;
typedef struct _InfcBrowserMakeAclAccountListData
  InfcBrowserMakeAclAccountListData;
struct _InfcBrowserMakeAclAccountListData {
  InfAclAccount* accounts;
  guint index;
};
typedef struct _InfcBrowserLookupAclAccountByByNameData
  InfcBrowserLookupAclAccountByByNameData;
struct _InfcBrowserLookupAclAccountByByNameData {
  const gchar* name;
  GArray* accounts;
};
typedef struct _InfcBrowserListPendingRequestsForeachData
  InfcBrowserListPendingRequestsForeachData;
struct _InfcBrowserListPendingRequestsForeachData {
  const InfBrowserIter* iter;
  GSList* result;
};
typedef struct _InfcBrowserIterGetChatRequestForeachData
  InfcBrowserIterGetChatRequestForeachData;
struct _InfcBrowserIterGetChatRequestForeachData {
  const InfBrowserIter* iter;
  InfcRequest* result;
};
typedef struct _InfcBrowserIterGetSyncInRequestsForeachData
  InfcBrowserIterGetSyncInRequestsForeachData;
struct _InfcBrowserIterGetSyncInRequestsForeachData {
  const InfBrowserIter* iter;
  GSList* result;
};
typedef struct _InfcBrowserNode InfcBrowserNode;
struct _InfcBrowserNode {
  InfcBrowserNode* parent;
  InfcBrowserNode* prev;
  InfcBrowserNode* next;
  guint id;
  gchar* name;
  InfcBrowserNodeType type;
  InfAclSheetSet* acl;
  gboolean acl_queried;
  union {
    struct {
      InfcSessionProxy* session;
      const InfcNotePlugin* plugin;
    } known;
    struct {
      gchar* type;
    } unknown;
    struct {
      InfcBrowserNode* child;
      gboolean explored;
    } subdir;
  } shared;
};
typedef struct _InfcBrowserSyncIn InfcBrowserSyncIn;
struct _InfcBrowserSyncIn {
  InfcBrowser* browser;
  InfcBrowserNode* node;
  InfcSessionProxy* proxy;
};
typedef enum _InfcBrowserSubreqType {
  INFC_BROWSER_SUBREQ_CHAT,
  INFC_BROWSER_SUBREQ_SESSION,
  INFC_BROWSER_SUBREQ_ADD_NODE,
  INFC_BROWSER_SUBREQ_SYNC_IN
} InfcBrowserSubreqType;
typedef struct _InfcBrowserSubreq InfcBrowserSubreq;
struct _InfcBrowserSubreq {
  InfcBrowserSubreqType type;
  guint node_id;
  union {
    struct {
      InfcRequest* request;
      InfCommunicationJoinedGroup* subscription_group;
    } chat;
    struct {
      InfcBrowserNode* node;
      InfcRequest* request;
      InfCommunicationJoinedGroup* subscription_group;
    } session;
    struct {
      InfcBrowserNode* parent;
      const InfcNotePlugin* plugin;
      gchar* name;
      InfAclSheetSet* sheet_set;
      InfcRequest* request;
      InfCommunicationJoinedGroup* subscription_group;
    } add_node;
    struct {
      InfcBrowserNode* parent;
      const InfcNotePlugin* plugin;
      gchar* name;
      InfAclSheetSet* sheet_set;
      InfcRequest* request;
      InfCommunicationJoinedGroup* synchronization_group;
      InfCommunicationJoinedGroup* subscription_group;       InfSession* session;
    } sync_in;
  } shared;
};
typedef enum _InfcBrowserAccountListStatus {
  INFC_BROWSER_ACCOUNT_LIST_NOT_QUERIED,
  INFC_BROWSER_ACCOUNT_LIST_NO_NOTIFICATIONS,
  INFC_BROWSER_ACCOUNT_LIST_NOTIFICATIONS
} InfcBrowserAccountListStatus;
typedef struct _InfcBrowserPrivate InfcBrowserPrivate;
struct _InfcBrowserPrivate {
  InfIo* io;
  InfCommunicationManager* communication_manager;
  InfCommunicationJoinedGroup* group;
  InfXmlConnection* connection;
  guint seq_id;
  InfIoTimeout* welcome_timeout;
  InfcRequestManager* request_manager;
  GHashTable* plugins; 
  InfBrowserStatus status;
  GHashTable* nodes;   InfcBrowserNode* root;
  GHashTable* accounts;   const InfAclAccount* local_account;
  InfcBrowserAccountListStatus account_list_status;
  GSList* sync_ins;
  GSList* subscription_requests;
  InfcSessionProxy* chat_session;
};
#define INFC_BROWSER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFC_TYPE_BROWSER, InfcBrowserPrivate))
enum {
  PROP_0,
  PROP_IO,
  PROP_COMMUNICATION_MANAGER,
  PROP_CONNECTION,
  PROP_STATUS,
  PROP_CHAT_SESSION
};
#define infc_browser_return_if_iter_fail(browser, iter) \
  g_return_if_fail( \
    iter != NULL &amp;&amp; \
    g_hash_table_lookup( \
      INFC_BROWSER_PRIVATE(INFC_BROWSER(browser))-&gt;nodes, \
      GUINT_TO_POINTER((iter)-&gt;node_id) \
    ) == (iter)-&gt;node \
  )
#define infc_browser_return_val_if_iter_fail(browser, iter, val) \
  g_return_val_if_fail( \
    iter != NULL &amp;&amp; \
    g_hash_table_lookup( \
      INFC_BROWSER_PRIVATE(INFC_BROWSER(browser))-&gt;nodes, \
      GUINT_TO_POINTER((iter)-&gt;node_id) \
    ) == (iter)-&gt;node, \
    val \
  )
#define infc_browser_return_if_subdir_fail(node) \
  g_return_if_fail( \
    ((InfcBrowserNode*)node)-&gt;type == INFC_BROWSER_NODE_SUBDIRECTORY \
  )
#define infc_browser_return_val_if_subdir_fail(node, val) \
  g_return_val_if_fail( \
    ((InfcBrowserNode*)node)-&gt;type == INFC_BROWSER_NODE_SUBDIRECTORY, \
    val \
  )
static GQuark infc_browser_session_proxy_quark;
static GQuark infc_browser_sync_in_session_quark;
static GQuark infc_browser_sync_in_plugin_quark;
static GQuark infc_browser_lookup_acl_accounts_ids_quark;
static GQuark infc_browser_lookup_acl_accounts_n_ids_quark;
static GQuark infc_browser_lookup_acl_accounts_name_quark;
static GQuark infc_browser_query_acl_account_list_accounts_quark;
static void infc_browser_communication_object_iface_init(InfCommunicationObjectInterface* iface);
static void infc_browser_browser_iface_init(InfBrowserInterface* iface);
G_DEFINE_TYPE_WITH_CODE(InfcBrowser, infc_browser, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfcBrowser)
  G_IMPLEMENT_INTERFACE(INF_COMMUNICATION_TYPE_OBJECT, infc_browser_communication_object_iface_init)
  G_IMPLEMENT_INTERFACE(INF_TYPE_BROWSER, infc_browser_browser_iface_init))
static void
infc_browser_make_acl_account_list_foreach_func(gpointer key,
                                                gpointer value,
                                                gpointer user_data)
{
  InfcBrowserMakeAclAccountListData* data;
  data = (InfcBrowserMakeAclAccountListData*)user_data;
  data-&gt;accounts[data-&gt;index++] = *(const InfAclAccount*)value;
}
static void
infc_browser_browser_lookup_acl_account_by_name_find_func(gpointer key,
                                                          gpointer value,
                                                          gpointer user_data)
{
  const InfcBrowserLookupAclAccountByByNameData* data;
  const InfAclAccount* acc;
  data = (InfcBrowserLookupAclAccountByByNameData*)user_data;
  acc = (const InfAclAccount*)value;
  if(acc-&gt;name != NULL)
   if(strcmp(acc-&gt;name, data-&gt;name) == 0)
     g_array_append_val(data-&gt;accounts, *acc);
}
InfAclAccount*
infc_browser_make_acl_account_list(InfcBrowser* browser,
                                   guint* n_accounts)
{
  InfcBrowserPrivate* priv;
  InfcBrowserMakeAclAccountListData data;
  guint n;
  priv = INFC_BROWSER_PRIVATE(browser);
  n = g_hash_table_size(priv-&gt;accounts);
  data.index = 0;
  data.accounts = g_malloc(sizeof(InfAclAccount) * n);
  g_hash_table_foreach(
    priv-&gt;accounts,
    infc_browser_make_acl_account_list_foreach_func,
    &amp;data
  );
  g_assert(data.index == n);
  if(n_accounts != NULL) *n_accounts = n;
  return data.accounts;
}
static void
infc_browser_browser_list_pending_requests_foreach_func(InfcRequest* request,
                                                        gpointer user_data)
{
  InfcBrowserListPendingRequestsForeachData* data;
  guint node_id;
  data = (InfcBrowserListPendingRequestsForeachData*)user_data;
  g_object_get(G_OBJECT(request), "node-id", &amp;node_id, NULL);
  if(node_id == G_MAXUINT)
  {
    if(data-&gt;iter == NULL)
      data-&gt;result = g_slist_prepend(data-&gt;result, request);
  }
  else
  {
    if(data-&gt;iter != NULL &amp;&amp; node_id == data-&gt;iter-&gt;node_id)
      data-&gt;result = g_slist_prepend(data-&gt;result, request);
  }
}
static void
infc_browser_iter_get_sync_in_requests_foreach_func(InfcRequest* request,
                                                    gpointer user_data)
{
  InfcBrowserIterGetSyncInRequestsForeachData* data;
  InfSession* session;
  guint node_id;
  data = (InfcBrowserIterGetSyncInRequestsForeachData*)user_data;
  session = g_object_get_qdata(
    G_OBJECT(request),
    infc_browser_sync_in_session_quark
  );
  if(session != NULL)
  {
    g_object_get(G_OBJECT(request), "node-id", &amp;node_id, NULL);
    if(node_id != G_MAXUINT &amp;&amp; node_id == data-&gt;iter-&gt;node_id)
      data-&gt;result = g_slist_prepend(data-&gt;result, request);
  }
}
static void
infc_browser_get_chat_request_foreach_func(InfcRequest* request,
                                           gpointer user_data)
{
  InfcBrowserIterGetChatRequestForeachData* data;
  data = (InfcBrowserIterGetChatRequestForeachData*)user_data;
  g_assert(data-&gt;result == NULL);
  data-&gt;result = request;
}
static void
infc_browser_node_get_path_string(InfcBrowserNode* node,
                                   GString* string)
{
  g_return_if_fail(node != NULL);
  g_return_if_fail(string != NULL);
  if(node-&gt;parent != NULL)
  {
    g_assert(node-&gt;name != NULL);
    if(node-&gt;parent-&gt;parent != NULL)
      infc_browser_node_get_path_string(node-&gt;parent, string);
    g_string_append_c(string, '/');
    g_string_append(string, node-&gt;name);
  }
  else
  {
    g_assert(node-&gt;name == NULL);
    g_string_append_c(string, '/');
  }
}
static void
infc_browser_node_get_path(InfcBrowserNode* node,
                           gchar** path,
                           gsize* len)
{
  GString* str;
  g_return_if_fail(node != NULL);
  g_return_if_fail(path != NULL);
  str = g_string_sized_new(128);
  infc_browser_node_get_path_string(node, str);
  *path = str-&gt;str;
  if(len != NULL)
    *len = str-&gt;len;
  g_string_free(str, FALSE);
}
static void
infc_browser_node_link(InfcBrowserNode* node,
                       InfcBrowserNode* parent)
{
  g_assert(parent != NULL);
  g_assert(parent-&gt;type == INFC_BROWSER_NODE_SUBDIRECTORY);
  node-&gt;prev = NULL;
  if(parent-&gt;shared.subdir.child != NULL)
  {
    parent-&gt;shared.subdir.child-&gt;prev = node;
    node-&gt;next = parent-&gt;shared.subdir.child;
  }
  else
  {
    node-&gt;next = NULL;
  }
  parent-&gt;shared.subdir.child = node;
}
static void
infc_browser_node_unlink(InfcBrowserNode* node)
{
  g_assert(node-&gt;parent != NULL);
  g_assert(node-&gt;parent-&gt;type == INFC_BROWSER_NODE_SUBDIRECTORY);
  if(node-&gt;prev != NULL)
    node-&gt;prev-&gt;next = node-&gt;next;
  else
    node-&gt;parent-&gt;shared.subdir.child = node-&gt;next;
  if(node-&gt;next != NULL)
    node-&gt;next-&gt;prev = node-&gt;prev;
}
static InfcBrowserNode*
infc_browser_node_new_common(InfcBrowser* browser,
                             InfcBrowserNode* parent,
                             guint id,
                             InfcBrowserNodeType type,
                             const gchar* name,
                             const InfAclSheetSet* sheet_set)
{
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  InfBrowserIter iter;
  priv = INFC_BROWSER_PRIVATE(browser);
  node = g_slice_new(InfcBrowserNode);
  node-&gt;parent = parent;
  node-&gt;id = id;
  node-&gt;name = g_strdup(name);
  node-&gt;type = type;
  if(sheet_set != NULL)
    node-&gt;acl = inf_acl_sheet_set_copy(sheet_set);
  else
    node-&gt;acl = NULL;
  node-&gt;acl_queried = FALSE;
  if(parent != NULL)
  {
    infc_browser_node_link(node, parent);
  }
  else
  {
    node-&gt;prev = NULL;
    node-&gt;next = NULL;
  }
  g_assert(
    g_hash_table_lookup(priv-&gt;nodes, GUINT_TO_POINTER(node-&gt;id)) == NULL
  );
  g_hash_table_insert(priv-&gt;nodes, GUINT_TO_POINTER(node-&gt;id), node);
  return node;
}
static InfcBrowserNode*
infc_browser_node_new_subdirectory(InfcBrowser* browser,
                                   InfcBrowserNode* parent,
                                   guint id,
                                   const gchar* name,
                                   const InfAclSheetSet* sheet_set)
{
  InfcBrowserNode* node;
  node = infc_browser_node_new_common(
    browser,
    parent,
    id,
    INFC_BROWSER_NODE_SUBDIRECTORY,
    name,
    sheet_set
  );
  node-&gt;shared.subdir.explored = FALSE;
  node-&gt;shared.subdir.child = NULL;
  return node;
}
static InfcBrowserNode*
infc_browser_node_new_note(InfcBrowser* browser,
                           InfcBrowserNode* parent,
                           guint id,
                           const gchar* name,
                           const gchar* type,
                           const InfAclSheetSet* sheet_set)
{
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  InfcNotePlugin* plugin;
  priv = INFC_BROWSER_PRIVATE(browser);
  plugin = g_hash_table_lookup(priv-&gt;plugins, type);
  node = infc_browser_node_new_common(
    browser,
    parent,
    id,
    (plugin != NULL) ? INFC_BROWSER_NODE_NOTE_KNOWN :
      INFC_BROWSER_NODE_NOTE_UNKNOWN,
    name,
    sheet_set
  );
  if(plugin != NULL)
  {
    node-&gt;shared.known.plugin = plugin;
    node-&gt;shared.known.session = NULL;
  }
  else
  {
    node-&gt;shared.unknown.type = g_strdup(type);
  }
  return node;
}
static void
infc_browser_session_notify_subscription_group_cb(InfSession* session,
                                                  const GParamSpec* pspec,
                                                  gpointer user_data);
static void
infc_browser_session_remove_session(InfcBrowser* browser,
                                    InfcBrowserNode* node,
                                    InfcRequest* request)
{
  InfSession* session;
  InfcSessionProxy* proxy;
  InfBrowserIter iter;
  g_assert(node-&gt;type == INFC_BROWSER_NODE_NOTE_KNOWN);
  g_assert(node-&gt;shared.known.session != NULL);
  proxy = node-&gt;shared.known.session;
  g_object_get(G_OBJECT(proxy), "session", &amp;session, NULL);
  inf_signal_handlers_disconnect_by_func(
    session,
    G_CALLBACK(infc_browser_session_notify_subscription_group_cb),
    browser
  );
  g_object_set_qdata(
    G_OBJECT(session),
    infc_browser_session_proxy_quark,
    NULL
  );
  node-&gt;shared.known.session = NULL;
  inf_browser_unsubscribe_session(
    INF_BROWSER(browser),
    &amp;iter,
    INF_SESSION_PROXY(proxy),
    INF_REQUEST(request)
  );
  g_object_unref(session);
  g_object_unref(proxy);
}
static void
infc_browser_session_remove_child_sessions(InfcBrowser* browser,
                                           InfcBrowserNode* node,
                                           InfcRequest* request)
{
  InfcBrowserNode* child;
  switch(node-&gt;type)
  {
  case INFC_BROWSER_NODE_SUBDIRECTORY:
    if(node-&gt;shared.subdir.explored == TRUE)
    {
      for(child = node-&gt;shared.subdir.child;
          child != NULL;
          child = child-&gt;next)
      {
        infc_browser_session_remove_child_sessions(browser, child, request);
      }
    }
    break;
  case INFC_BROWSER_NODE_NOTE_KNOWN:
    if(node-&gt;shared.known.session != NULL)
      infc_browser_session_remove_session(browser, node, request);
    break;
  case INFC_BROWSER_NODE_NOTE_UNKNOWN:
    break;
  }
}
static void
infc_browser_node_register(InfcBrowser* browser,
                           InfcBrowserNode* node,
                           InfcRequest* request)
{
  InfBrowserIter iter;
  iter.node_id = node-&gt;id;
  iter.node = node;
  inf_browser_node_added(INF_BROWSER(browser), &amp;iter, INF_REQUEST(request));
}
static void
infc_browser_node_unregister(InfcBrowser* browser,
                             InfcBrowserNode* node,
                             InfcRequest* request)
{
  InfBrowserIter iter;
  iter.node_id = node-&gt;id;
  iter.node = node;
  inf_browser_node_removed(INF_BROWSER(browser), &amp;iter, INF_REQUEST(request));
}
static void
infc_browser_remove_sync_in(InfcBrowser* browser,
                            InfcBrowserSyncIn* sync_in);
static void
infc_browser_remove_subreq(InfcBrowser* browser,
                           InfcBrowserSubreq* request);
static void
infc_browser_node_free(InfcBrowser* browser,
                       InfcBrowserNode* node)
{
  InfcBrowserPrivate* priv;
  gboolean removed;
  GSList* item;
  InfcBrowserSyncIn* sync_in;
  InfcBrowserSubreq* request;
  InfBrowserIter iter;
  GError* error;
  priv = INFC_BROWSER_PRIVATE(browser);
  switch(node-&gt;type)
  {
  case INFC_BROWSER_NODE_SUBDIRECTORY:
    while(node-&gt;shared.subdir.child != NULL)
      infc_browser_node_free(browser, node-&gt;shared.subdir.child);
    break;
  case INFC_BROWSER_NODE_NOTE_KNOWN:
    g_assert(node-&gt;shared.known.session == NULL);
    break;
  case INFC_BROWSER_NODE_NOTE_UNKNOWN:
    g_free(node-&gt;shared.unknown.type);
    break;
  default:
    g_assert_not_reached();
    break;
  }
  for(item = priv-&gt;sync_ins; item != NULL; )
  {
    sync_in = (InfcBrowserSyncIn*)item-&gt;data;
    item = item-&gt;next;
    if(sync_in-&gt;node == node)
      infc_browser_remove_sync_in(browser, sync_in);
  }
  for(item = priv-&gt;subscription_requests; item != NULL; )
  {
    request = (InfcBrowserSubreq*)item-&gt;data;
    item = item-&gt;next;
    switch(request-&gt;type)
    {
    case INFC_BROWSER_SUBREQ_SESSION:
      if(request-&gt;shared.session.node == node)
      {
        request-&gt;shared.session.node = NULL;
        if(request-&gt;shared.session.request != NULL)
        {
          error = g_error_new_literal(
            inf_directory_error_quark(),
            INF_DIRECTORY_ERROR_NO_SUCH_NODE,
            _("The node to subscribe to has been removed")
          );
          infc_request_manager_fail_request(
            priv-&gt;request_manager,
            INFC_REQUEST(request-&gt;shared.session.request),
            error
          );
          g_error_free(error);
          g_object_unref(request-&gt;shared.session.request);
          request-&gt;shared.session.request = NULL;
        }
      }
      break;
    case INFC_BROWSER_SUBREQ_ADD_NODE:
      if(request-&gt;shared.add_node.parent == node)
      {
        request-&gt;shared.add_node.parent = NULL;
        if(request-&gt;shared.add_node.request != NULL)
        {
          error = g_error_new_literal(
            inf_directory_error_quark(),
            INF_DIRECTORY_ERROR_NO_SUCH_NODE,
            _("The subdirectory into which the new node should have been "
              "created has been removed")
          );
          infc_request_manager_fail_request(
            priv-&gt;request_manager,
            INFC_REQUEST(request-&gt;shared.add_node.request),
            error
          );
          g_error_free(error);
          g_object_unref(request-&gt;shared.add_node.request);
          request-&gt;shared.add_node.request = NULL;
        }
      }
      break;
    case INFC_BROWSER_SUBREQ_SYNC_IN:
      if(request-&gt;shared.sync_in.parent == node)
      {
        request-&gt;shared.sync_in.parent = NULL;
        g_assert(request-&gt;shared.sync_in.request != NULL);
        error = g_error_new_literal(
          inf_directory_error_quark(),
          INF_DIRECTORY_ERROR_NO_SUCH_NODE,
          _("The subdirectory into which the new node should have been "
            "created has been removed")
        );
        infc_request_manager_fail_request(
          priv-&gt;request_manager,
          INFC_REQUEST(request-&gt;shared.sync_in.request),
          error
        );
        g_error_free(error);
        g_object_unref(request-&gt;shared.sync_in.request);
        request-&gt;shared.sync_in.request = NULL;
      }
      break;
    default:
      g_assert_not_reached();
      break;
    }
  }
  if(node-&gt;parent != NULL)
    infc_browser_node_unlink(node);
  if(node-&gt;acl != NULL)
    inf_acl_sheet_set_free(node-&gt;acl);
  removed = g_hash_table_remove(priv-&gt;nodes, GUINT_TO_POINTER(node-&gt;id));
  g_assert(removed == TRUE);
  g_free(node-&gt;name);
  g_slice_free(InfcBrowserNode, node);
}
static void
infc_browser_remove_acl_sheet_from_sheet_set(InfAclSheetSet* sheet_set,
                                             InfAclAccountId account)
{
  InfAclSheet* sheet;
  if(sheet_set != NULL)
  {
    sheet = inf_acl_sheet_set_find_sheet(sheet_set, account);
    if(sheet != NULL)
      inf_acl_sheet_set_remove_sheet(sheet_set, sheet);
  }
}
static void
infc_browser_remove_account_from_sheets(InfcBrowser* browser,
                                        InfcBrowserNode* node,
                                        InfAclAccountId account)
{
  InfcBrowserNode* child;
  InfAclSheet* sheet;
  InfAclSheet announce_sheet;
  InfAclSheetSet sheet_set;
  InfBrowserIter iter;
  if(node-&gt;type == INFC_BROWSER_NODE_SUBDIRECTORY &amp;&amp;
     node-&gt;shared.subdir.explored)
  {
    for(child = node-&gt;shared.subdir.child; child != NULL; child = child-&gt;next)
    {
      infc_browser_remove_account_from_sheets(browser, child, account);
    }
  }
  if(node-&gt;acl != NULL)
  {
    sheet = inf_acl_sheet_set_find_sheet(node-&gt;acl, account);
    if(sheet != NULL)
    {
      announce_sheet = *sheet;
      inf_acl_sheet_set_remove_sheet(node-&gt;acl, sheet);
      inf_acl_mask_clear(&amp;announce_sheet.mask);
      sheet_set.own_sheets = NULL;
      sheet_set.sheets = &amp;announce_sheet;
      sheet_set.n_sheets = 1;
      iter.node = node;
      iter.node_id = node-&gt;id;
      inf_browser_acl_changed(INF_BROWSER(browser), &amp;iter, &amp;sheet_set, NULL);
    }
  }
}
static void
infc_browser_enforce_single_acl(InfcBrowser* browser,
                                InfcBrowserNode* node,
                                InfcRequest* request,
                                const InfAclSheet* new_sheet)
{
  InfcBrowserPrivate* priv;
  InfBrowser* ibrowser;
  InfBrowserIter iter;
  InfAclAccountId account;
  InfAclMask mask;
  InfcRequest* req;
  GError* error;
  InfcBrowserNode* child;
  GSList* item;
  InfcBrowserSubreq* subreq;
  InfAclAccountId default_id;
  InfAclSheetSet* sheet_set;
  InfAclSheet* sheet;
  InfAclSheet* added_sheet;
  priv = INFC_BROWSER_PRIVATE(browser);
  ibrowser = INF_BROWSER(browser);
  iter.node = node;
  iter.node_id = node-&gt;id;
  account = priv-&gt;local_account-&gt;id;
  g_assert(new_sheet == NULL || new_sheet-&gt;account == account);
  if(node-&gt;type == INFC_BROWSER_NODE_SUBDIRECTORY)
  {
    if(node-&gt;shared.subdir.explored == TRUE)
    {
      inf_acl_mask_set1(&amp;mask, INF_ACL_CAN_EXPLORE_NODE);
      if(!inf_browser_check_acl(ibrowser, &amp;iter, account, &amp;mask, NULL))
      {
        req = INFC_REQUEST(
          inf_browser_get_pending_request(
            ibrowser,
            &amp;iter,
            "explore-node"
          )
        );
        if(req != NULL)
        {
          error = NULL;
          g_set_error_literal(
            &amp;error,
            inf_request_error_quark(),
            INF_REQUEST_ERROR_NOT_AUTHORIZED,
            _("Permissions to explore this node have been revoked")
          );
          infc_request_manager_fail_request(priv-&gt;request_manager, req, error);
          g_error_free(error);
        }
        while(node-&gt;shared.subdir.child != NULL)
        {
          child = node-&gt;shared.subdir.child;
          infc_browser_node_unregister(browser, child, request);
          infc_browser_node_free(browser, child);
        }
        for(item = priv-&gt;subscription_requests; item != NULL; )
        {
          subreq = (InfcBrowserSubreq*)item-&gt;data;
          item = item-&gt;next;
          switch(subreq-&gt;type)
          {
          case INFC_BROWSER_SUBREQ_CHAT:
          case INFC_BROWSER_SUBREQ_SESSION:
            break;
          case INFC_BROWSER_SUBREQ_ADD_NODE:
            if(subreq-&gt;shared.add_node.parent == node)
            {
              subreq-&gt;shared.add_node.parent = NULL;
              if(subreq-&gt;shared.add_node.request != NULL)
              {
                error = NULL;
                g_set_error_literal(
                  &amp;error,
                  inf_request_error_quark(),
                  INF_REQUEST_ERROR_NOT_AUTHORIZED,
                  _("Permissions to explore the parent node "
                    "have been revoked")
                );
                infc_request_manager_fail_request(
                  priv-&gt;request_manager,
                  subreq-&gt;shared.add_node.request,
                  error
                );
                g_error_free(error);
                g_object_unref(subreq-&gt;shared.add_node.request);
                subreq-&gt;shared.add_node.request = NULL;
              }
            }
            break;
          case INFC_BROWSER_SUBREQ_SYNC_IN:
            if(subreq-&gt;shared.sync_in.parent == node)
            {
              subreq-&gt;shared.sync_in.parent = NULL;
              if(subreq-&gt;shared.sync_in.request != NULL)
              {
                error = NULL;
                g_set_error_literal(
                  &amp;error,
                  inf_request_error_quark(),
                  INF_REQUEST_ERROR_NOT_AUTHORIZED,
                  _("Permissions to explore the parent node "
                    "have been revoked")
                );
                infc_request_manager_fail_request(
                  priv-&gt;request_manager,
                  subreq-&gt;shared.sync_in.request,
                  error
                );
                g_error_free(error);
                g_object_unref(subreq-&gt;shared.sync_in.request);
                subreq-&gt;shared.sync_in.request = NULL;
              }
            }
            break;
          default:
            g_assert_not_reached();
            break;
          }
        }
        node-&gt;shared.subdir.explored = FALSE;
      }
    }
  }
  else
  {
  }
  if(node-&gt;acl_queried == TRUE)
  {
    inf_acl_mask_set1(&amp;mask, INF_ACL_CAN_QUERY_ACL);
    if(inf_browser_check_acl(ibrowser, &amp;iter, account, &amp;mask, NULL) == FALSE)
      node-&gt;acl_queried = FALSE;
  }
  if(node-&gt;acl_queried == FALSE)
  {
    if(node-&gt;acl != NULL)
      sheet_set = inf_acl_sheet_set_get_clear_sheets(node-&gt;acl);
    else
      sheet_set = inf_acl_sheet_set_new();
    default_id = inf_acl_account_id_from_string("default");
    sheet = inf_acl_sheet_set_find_sheet(sheet_set, default_id);
    if(sheet != NULL) inf_acl_sheet_set_remove_sheet(sheet_set, sheet);
    if(priv-&gt;local_account-&gt;id != default_id)
    {
      sheet =
        inf_acl_sheet_set_find_sheet(sheet_set, priv-&gt;local_account-&gt;id);
      if(sheet != NULL)
      {
        inf_acl_sheet_set_remove_sheet(sheet_set, sheet);
        g_assert(new_sheet == NULL);
      }
      else if(new_sheet != NULL)
      {
        added_sheet =
          inf_acl_sheet_set_add_sheet(sheet_set, new_sheet-&gt;account);
        *added_sheet = *new_sheet;
      }
    }
    if(sheet_set != NULL &amp;&amp; sheet_set-&gt;n_sheets &gt; 0)
    {
      node-&gt;acl = inf_acl_sheet_set_merge_sheets(node-&gt;acl, sheet_set);
      for(item = priv-&gt;subscription_requests; item != NULL; )
      {
        subreq = (InfcBrowserSubreq*)item-&gt;data;
        item = item-&gt;next;
        switch(subreq-&gt;type)
        {
        case INFC_BROWSER_SUBREQ_CHAT:
        case INFC_BROWSER_SUBREQ_SESSION:
          break;
        case INFC_BROWSER_SUBREQ_ADD_NODE:
          if(subreq-&gt;shared.add_node.parent == node)
          {
            subreq-&gt;shared.add_node.sheet_set =
              inf_acl_sheet_set_merge_sheets(
                subreq-&gt;shared.add_node.sheet_set,
                sheet_set
              );
          }
          break;
        case INFC_BROWSER_SUBREQ_SYNC_IN:
          if(subreq-&gt;shared.sync_in.parent == node)
          {
            subreq-&gt;shared.sync_in.sheet_set = inf_acl_sheet_set_merge_sheets(
              subreq-&gt;shared.sync_in.sheet_set,
              sheet_set
            );
          }
          break;
        default:
          g_assert_not_reached();
          break;
        }
      }
      inf_browser_acl_changed(
        INF_BROWSER(browser),
        &amp;iter,
        sheet_set,
        INF_REQUEST(request)
      );
    }
    inf_acl_sheet_set_free(sheet_set);
  }
}
static void
infc_browser_enforce_acl(InfcBrowser* browser,
                         InfcBrowserNode* node,
                         InfcRequest* request,
                         GHashTable* new_acls)
{
  InfBrowser* ibrowser;
  InfcBrowserPrivate* priv;
  InfcBrowserNode* child;
  InfBrowserIter iter;
  InfAclMask mask;
  const InfAclSheet* sheet;
  InfAclAccountId account;
  ibrowser = INF_BROWSER(browser);
  priv = INFC_BROWSER_PRIVATE(browser);
  if(node == priv-&gt;root &amp;&amp;
     priv-&gt;account_list_status == INFC_BROWSER_ACCOUNT_LIST_NOTIFICATIONS)
  {
    iter.node = node;
    iter.node_id = node-&gt;id;
    inf_acl_mask_set1(&amp;mask, INF_ACL_CAN_QUERY_ACCOUNT_LIST);
    account = priv-&gt;local_account-&gt;id;
    if(inf_browser_check_acl(ibrowser, &amp;iter, account, &amp;mask, NULL) == FALSE)
    {
      priv-&gt;account_list_status = INFC_BROWSER_ACCOUNT_LIST_NO_NOTIFICATIONS;
    }
  }
  sheet = NULL;
  if(new_acls != NULL)
    sheet = g_hash_table_lookup(new_acls, GUINT_TO_POINTER(node-&gt;id));
  infc_browser_enforce_single_acl(browser, node, request, sheet);
  if(node-&gt;type == INFC_BROWSER_NODE_SUBDIRECTORY)
  {
    for(child = node-&gt;shared.subdir.child; child != NULL; child = child-&gt;next)
    {
      infc_browser_enforce_acl(browser, child, request, new_acls);
    }
  }
}
static void
infc_browser_session_notify_subscription_group_cb(InfSession* session,
                                                  const GParamSpec* spec,
                                                  gpointer user_data)
{
  InfcBrowser* browser;
  InfcBrowserPrivate* priv;
  InfBrowserIter* iter;
  InfcBrowserNode* node;
  InfcSessionProxy* proxy;
  InfSession* proxy_session;
  browser = INFC_BROWSER(user_data);
  priv = INFC_BROWSER_PRIVATE(browser);
  if(inf_session_get_subscription_group(session) == NULL)
  {
    iter = (InfBrowserIter*)g_object_get_qdata(
      G_OBJECT(session),
      infc_browser_session_proxy_quark
    );
    if(iter != NULL)
    {
      g_assert(
        g_hash_table_lookup(
          INFC_BROWSER_PRIVATE(browser)-&gt;nodes,
          GUINT_TO_POINTER(iter-&gt;node_id)
        ) == iter-&gt;node
      );
      node = (InfcBrowserNode*)iter-&gt;node;
      g_assert(node-&gt;type == INFC_BROWSER_NODE_NOTE_KNOWN);
      g_assert(node-&gt;shared.known.session != NULL);
      g_object_get(
        G_OBJECT(node-&gt;shared.known.session),
        "session", &amp;proxy_session,
        NULL
      );
      g_assert(proxy_session == session);
      g_object_unref(proxy_session);
      infc_browser_session_remove_session(browser, node, NULL);
    }
    else
    {
      g_assert(priv-&gt;chat_session != NULL);
      g_object_get(
        G_OBJECT(priv-&gt;chat_session),
        "session", &amp;proxy_session,
        NULL
      );
      g_assert(proxy_session == session);
      inf_signal_handlers_disconnect_by_func(
        proxy_session,
        G_CALLBACK(infc_browser_session_notify_subscription_group_cb),
        browser
      );
      g_object_unref(proxy_session);
      proxy = priv-&gt;chat_session;
      priv-&gt;chat_session = NULL;
      g_object_notify(G_OBJECT(browser), "chat-session");
      inf_browser_unsubscribe_session(
        INF_BROWSER(browser),
        NULL,
        INF_SESSION_PROXY(proxy),
        NULL
      );
      g_object_unref(proxy);
    }
  }
}
static void
infc_browser_welcome_timeout_func(gpointer user_data)
{
  InfcBrowser* browser;
  InfcBrowserPrivate* priv;
  GError* error;
  browser = INFC_BROWSER(user_data);
  priv = INFC_BROWSER_PRIVATE(browser);
  priv-&gt;welcome_timeout = NULL;
  error = NULL;
  g_set_error_literal(
    &amp;error,
    inf_directory_error_quark(),
    INF_DIRECTORY_ERROR_NO_WELCOME_MESSAGE,
    _("The server did not send an initial welcome message. This means that "
      "the server is running a lower version of the software which is "
      "incompatible to the client. Consider downgrading the client, or ask "
      "the server administrators to upgrade their software.")
  );
  inf_browser_error(INF_BROWSER(browser), error);
  g_error_free(error);
  g_assert(priv-&gt;status != INF_BROWSER_CLOSED);
  priv-&gt;status = INF_BROWSER_CLOSED;
  g_object_notify(G_OBJECT(browser), "status");
}
static void
infc_browser_member_removed_cb(InfCommunicationGroup* group,
                               InfXmlConnection* connection,
                               gpointer user_data);
static void
infc_browser_connected(InfcBrowser* browser)
{
  InfcBrowserPrivate* priv;
  priv = INFC_BROWSER_PRIVATE(browser);
  g_assert(priv-&gt;group == NULL);
  priv-&gt;group = inf_communication_manager_join_group(
    priv-&gt;communication_manager,
    "InfDirectory",
    priv-&gt;connection,
    "central"
  );
  g_assert(priv-&gt;group != NULL);
  inf_communication_group_set_target(
    INF_COMMUNICATION_GROUP(priv-&gt;group),
    INF_COMMUNICATION_OBJECT(browser)
  );
  g_signal_connect(
    priv-&gt;group,
    "member-removed",
    G_CALLBACK(infc_browser_member_removed_cb),
    browser
  );
  if(priv-&gt;status != INF_BROWSER_OPENING)
  {
    priv-&gt;status = INF_BROWSER_OPENING;
    g_object_notify(G_OBJECT(browser), "status");
  }
  g_assert(priv-&gt;welcome_timeout == NULL);
  priv-&gt;welcome_timeout = inf_io_add_timeout(
    priv-&gt;io,
    5*1000,
    infc_browser_welcome_timeout_func,
    browser,
    NULL
  );
}
static void
infc_browser_disconnected(InfcBrowser* browser)
{
  InfcBrowserPrivate* priv;
  InfcBrowserNode* child;
  InfcBrowserNode* next;
  InfSession* session;
  InfBrowserIter iter;
  priv = INFC_BROWSER_PRIVATE(browser);
  while(priv-&gt;sync_ins != NULL)
    infc_browser_remove_sync_in(browser, priv-&gt;sync_ins-&gt;data);
  while(priv-&gt;subscription_requests != NULL)
    infc_browser_remove_subreq(browser, priv-&gt;subscription_requests-&gt;data);
  if(priv-&gt;request_manager)
  {
    infc_request_manager_clear(priv-&gt;request_manager);
    g_object_unref(priv-&gt;request_manager);
    priv-&gt;request_manager = NULL;
  }
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(priv-&gt;group),
    G_CALLBACK(infc_browser_member_removed_cb),
    browser
  );
  g_object_unref(priv-&gt;group);
  priv-&gt;group = NULL;
#if 0
  for(child = priv-&gt;root-&gt;shared.subdir.child; child != NULL; child = next)
  {
    next = child-&gt;next;
    infc_browser_node_unregister(browser, child);
    infc_browser_node_free(browser, child);
  }
#endif
  if(priv-&gt;root != NULL)
  {
    infc_browser_session_remove_child_sessions(browser, priv-&gt;root, NULL);
    infc_browser_node_unregister(browser, priv-&gt;root, NULL);
    infc_browser_node_free(browser, priv-&gt;root);
    priv-&gt;root = NULL;
  }
  priv-&gt;account_list_status = INFC_BROWSER_ACCOUNT_LIST_NOT_QUERIED;
  priv-&gt;local_account = NULL;
  if(priv-&gt;accounts != NULL)
  {
    g_hash_table_destroy(priv-&gt;accounts);
    priv-&gt;accounts = NULL;
  }
  g_object_freeze_notify(G_OBJECT(browser));
  if(priv-&gt;chat_session != NULL)
  {
    g_object_get(G_OBJECT(priv-&gt;chat_session), "session", &amp;session, NULL);
    inf_signal_handlers_disconnect_by_func(
      session,
      G_CALLBACK(infc_browser_session_notify_subscription_group_cb),
      browser
    );
    g_object_unref(session);
    g_object_unref(priv-&gt;chat_session);
    priv-&gt;chat_session = NULL;
    g_object_notify(G_OBJECT(browser), "chat-session");
  }
  if(priv-&gt;welcome_timeout != NULL)
  {
    inf_io_remove_timeout(priv-&gt;io, priv-&gt;welcome_timeout);
    priv-&gt;welcome_timeout = NULL;
  }
  priv-&gt;status = INF_BROWSER_CLOSED;
  g_object_notify(G_OBJECT(browser), "status");
  g_object_thaw_notify(G_OBJECT(browser));
}
static void
infc_browser_member_removed_cb(InfCommunicationGroup* group,
                               InfXmlConnection* connection,
                               gpointer user_data)
{
  InfcBrowser* browser;
  InfcBrowserPrivate* priv;
  browser = INFC_BROWSER(user_data);
  priv = INFC_BROWSER_PRIVATE(browser);
  g_assert(INF_COMMUNICATION_GROUP(priv-&gt;group) == group);
  if(connection == priv-&gt;connection)
    infc_browser_disconnected(browser);
}
static void
infc_browser_connection_notify_status_cb(GObject* object,
                                         GParamSpec* pspec,
                                         gpointer user_data)
{
  InfcBrowser* browser;
  InfcBrowserPrivate* priv;
  InfXmlConnectionStatus status;
  browser = INFC_BROWSER(user_data);
  priv = INFC_BROWSER_PRIVATE(browser);
  g_object_get(object, "status", &amp;status, NULL);
  switch(status)
  {
  case INF_XML_CONNECTION_OPENING:
    if(priv-&gt;status != INF_BROWSER_OPENING)
    {
      priv-&gt;status = INF_BROWSER_OPENING;
      g_object_notify(G_OBJECT(browser), "status");
    }
    break;
  case INF_XML_CONNECTION_OPEN:
    infc_browser_connected(browser);
    break;
  case INF_XML_CONNECTION_CLOSING:
  case INF_XML_CONNECTION_CLOSED:
    if(priv-&gt;group == NULL &amp;&amp; priv-&gt;status != INF_BROWSER_CLOSED)
    {
      g_assert(priv-&gt;request_manager == NULL);
      priv-&gt;status = INF_BROWSER_CLOSED;
      g_object_notify(G_OBJECT(browser), "status");
    }
    break;
  default:
    g_assert_not_reached();
    break;
  }
}
static void
infc_browser_connection_error_cb(InfXmlConnection* connection,
                                 const GError* error,
                                 gpointer user_data)
{
  InfcBrowser* browser;
  browser = INFC_BROWSER(user_data);
  inf_browser_error(INF_BROWSER(browser), error);
}
static xmlNodePtr
infc_browser_request_to_xml(InfcRequest* request)
{
  xmlNodePtr xml;
  gchar* type;
  guint seq;
  gchar seq_buffer[16];
  g_object_get(G_OBJECT(request), "type", &amp;type, "seq", &amp;seq, NULL);
  sprintf(seq_buffer, "%u", seq);
  xml = xmlNewNode(NULL, (const xmlChar*)type);
  xmlNewProp(xml, (const xmlChar*)"seq", (const xmlChar*)seq_buffer);
  g_free(type);
  return xml;
}
static GError*
infc_browser_method_unsupported_error(const gchar* method_name,
                                      InfXmlConnection* connection)
{
  GError* error;
  gchar* network;
  g_object_get(G_OBJECT(connection), "network", &amp;network, NULL);
  error = g_error_new(
    inf_directory_error_quark(),
    INF_DIRECTORY_ERROR_METHOD_UNSUPPORTED,
    _("This session requires communication method `%s' which is not "
      "installed for network `%s'"),
    method_name,
    network
  );
<a name="2"></a>
  g_free(network);
  return error;
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
static void
infc_browser_init(InfcBrowser* browser)
{
  InfcBrowserPrivate* priv;
  priv = INFC_BROWSER_PRIVATE(browser);
  priv-&gt;io = NULL;
  priv-&gt;communication_manager = NULL;
  priv-&gt;group = NULL;
  priv-&gt;connection = NULL;
  priv-&gt;seq_id = 0;</b></font>
  priv-&gt;welcome_timeout = NULL;
  priv-&gt;request_manager = NULL;
  priv-&gt;plugins = g_hash_table_new(g_str_hash, g_str_equal);
  priv-&gt;status = INF_BROWSER_CLOSED;
  priv-&gt;nodes = g_hash_table_new(NULL, NULL);
  priv-&gt;root = NULL;
  priv-&gt;accounts = NULL;
  priv-&gt;local_account = NULL;
  priv-&gt;account_list_status = INFC_BROWSER_ACCOUNT_LIST_NOT_QUERIED;
  priv-&gt;sync_ins = NULL;
  priv-&gt;subscription_requests = NULL;
  priv-&gt;chat_session = NULL;
}
static void
infc_browser_dispose(GObject* object)
{
  InfcBrowser* browser;
  InfcBrowserPrivate* priv;
  InfSession* session;
  browser = INFC_BROWSER(object);
  priv = INFC_BROWSER_PRIVATE(browser);
#if 0
  infc_browser_set_connection(browser, NULL);
#else
  if(priv-&gt;group != NULL)
    infc_browser_disconnected(browser);
  g_assert(priv-&gt;group == NULL);
  g_assert(priv-&gt;accounts == NULL);
  g_assert(priv-&gt;sync_ins == NULL);
  g_assert(priv-&gt;subscription_requests == NULL);
  if(priv-&gt;connection != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      priv-&gt;connection,
      G_CALLBACK(infc_browser_connection_notify_status_cb),
      browser
    );
    inf_signal_handlers_disconnect_by_func(
      priv-&gt;connection,
      G_CALLBACK(infc_browser_connection_error_cb),
      browser
    );
    g_object_unref(priv-&gt;connection);
    priv-&gt;connection = NULL;
  }
#endif
  if(priv-&gt;chat_session != NULL)
  {
    g_object_get(G_OBJECT(priv-&gt;chat_session), "session", &amp;session, NULL);
    inf_session_close(session);
    g_object_unref(session);
  }
  g_assert(priv-&gt;chat_session == NULL);
  g_object_unref(priv-&gt;communication_manager);
  priv-&gt;communication_manager = NULL;
  g_hash_table_destroy(priv-&gt;plugins);
  priv-&gt;plugins = NULL;
  g_assert(priv-&gt;request_manager == NULL);
  if(priv-&gt;welcome_timeout != NULL)
  {
    inf_io_remove_timeout(priv-&gt;io, priv-&gt;welcome_timeout);
    priv-&gt;welcome_timeout = NULL;
  }
  if(priv-&gt;io != NULL)
  {
    g_object_unref(G_OBJECT(priv-&gt;io));
    priv-&gt;io = NULL;
  }
  G_OBJECT_CLASS(infc_browser_parent_class)-&gt;dispose(object);
}
static void
infc_browser_finalize(GObject* object)
{
  InfcBrowser* browser;
<a name="0"></a>  InfcBrowserPrivate* priv;
  browser = INFC_BROWSER(object);
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  priv = INFC_BROWSER_PRIVATE(browser);
  g_hash_table_destroy(priv-&gt;nodes);
  priv-&gt;nodes = NULL;
  G_OBJECT_CLASS(infc_browser_parent_class)-&gt;finalize(object);
}
static void
infc_browser_set_property(GObject* object,
                          guint prop_id,
                          const GValue* value,
                          GParamSpec* pspec)
{
  InfcBrowser* browser;
  InfcBrowserPrivate* priv;
  InfXmlConnectionStatus status;
  browser = INFC_BROWSER(object);
  priv = INFC_BROWSER_PRIVATE(browser);
  switch(prop_id)
  {
  case PROP_IO:
    g_assert(priv-&gt;io == NULL);     priv-&gt;io = INF_IO(g_value_dup_object(value));
    break;
  case PROP_COMMUNICATION_MANAGER:</b></font>
    g_assert(priv-&gt;communication_manager == NULL);     priv-&gt;communication_manager =
      INF_COMMUNICATION_MANAGER(g_value_dup_object(value));
    break;
  case PROP_CONNECTION:
    if(priv-&gt;connection != NULL)
    {
      if(priv-&gt;group != NULL)
        infc_browser_disconnected(browser);
      inf_signal_handlers_disconnect_by_func(
        priv-&gt;connection,
        G_CALLBACK(infc_browser_connection_notify_status_cb),
        browser
      );
      inf_signal_handlers_disconnect_by_func(
        priv-&gt;connection,
        G_CALLBACK(infc_browser_connection_error_cb),
        browser
      );
      g_object_unref(priv-&gt;connection);
    }
    priv-&gt;connection = INF_XML_CONNECTION(g_value_get_object(value));
    if(priv-&gt;connection)
    {
      g_object_ref(priv-&gt;connection);
      g_object_get(G_OBJECT(priv-&gt;connection), "status", &amp;status, NULL);
      g_signal_connect(
        G_OBJECT(priv-&gt;connection),
        "notify::status",
        G_CALLBACK(infc_browser_connection_notify_status_cb),
        browser
      );
      g_signal_connect(
        G_OBJECT(priv-&gt;connection),
        "error",
        G_CALLBACK(infc_browser_connection_error_cb),
        browser
      );
      switch(status)
      {
      case INF_XML_CONNECTION_OPENING:
        if(priv-&gt;status != INF_BROWSER_OPENING)
        {
          priv-&gt;status = INF_BROWSER_OPENING;
          g_object_notify(G_OBJECT(browser), "status");
        }
        break;
      case INF_XML_CONNECTION_OPEN:
        infc_browser_connected(browser);
        break;
      case INF_XML_CONNECTION_CLOSING:
      case INF_XML_CONNECTION_CLOSED:
        if(priv-&gt;status != INF_BROWSER_CLOSED)
        {
          priv-&gt;status = INF_BROWSER_CLOSED;
          g_object_notify(G_OBJECT(browser), "status");
        }
        break;
      }
    }
    else
    {
      if(priv-&gt;status != INF_BROWSER_CLOSED)
      {
        priv-&gt;status = INF_BROWSER_CLOSED;
        g_object_notify(G_OBJECT(browser), "status");
      }
    }
    break;
<a name="1"></a>  case PROP_STATUS:
  case PROP_CHAT_SESSION:
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
infc_browser_get_property(GObject* object,
                          guint prop_id,
                          GValue* value,
                          GParamSpec* pspec)
{
  InfcBrowser* browser;
  InfcBrowserPrivate* priv;
  browser = INFC_BROWSER(object);
  priv = INFC_BROWSER_PRIVATE(browser);
  switch(prop_id)
  {
  case PROP_IO:
    g_value_set_object(value, G_OBJECT(priv-&gt;io));
    break;
  case PROP_COMMUNICATION_MANAGER:
    g_value_set_object(value, G_OBJECT(priv-&gt;communication_manager));
    break;</b></font>
  case PROP_CONNECTION:
    g_value_set_object(value, G_OBJECT(priv-&gt;connection));
    break;
  case PROP_STATUS:
    g_value_set_enum(value, priv-&gt;status);
    break;
  case PROP_CHAT_SESSION:
    g_value_set_object(value, G_OBJECT(priv-&gt;chat_session));
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static InfcBrowserSubreq*
infc_browser_add_subreq_common(InfcBrowser* browser,
                               InfcBrowserSubreqType type,
                               guint node_id)
{
  InfcBrowserPrivate* priv;
  InfcBrowserSubreq* request;
  priv = INFC_BROWSER_PRIVATE(browser);
  request = g_slice_new(InfcBrowserSubreq);
  request-&gt;type = type;
  request-&gt;node_id = node_id;
  priv-&gt;subscription_requests =
    g_slist_prepend(priv-&gt;subscription_requests, request);
  return request;
}
static InfcBrowserSubreq*
infc_browser_add_subreq_chat(InfcBrowser* browser,
                             InfcRequest* request,
                             InfCommunicationJoinedGroup* group)
{
  InfcBrowserSubreq* subreq;
  subreq = infc_browser_add_subreq_common(
    browser,
    INFC_BROWSER_SUBREQ_CHAT,
    0
  );
  subreq-&gt;shared.chat.request = request;
  subreq-&gt;shared.chat.subscription_group = group;
  if(request != NULL)
    g_object_ref(request);
  g_object_ref(group);
  return subreq;
}
static InfcBrowserSubreq*
infc_browser_add_subreq_session(InfcBrowser* browser,
                                InfcBrowserNode* node,
                                InfcRequest* request,
                                InfCommunicationJoinedGroup* group)
{
  InfcBrowserSubreq* subreq;
  subreq = infc_browser_add_subreq_common(
    browser,
    INFC_BROWSER_SUBREQ_SESSION,
    node-&gt;id
  );
  subreq-&gt;shared.session.node = node;
  subreq-&gt;shared.session.request = request;
  subreq-&gt;shared.session.subscription_group = group;
  if(request != NULL)
    g_object_ref(request);
  g_object_ref(group);
  return subreq;
}
static InfcBrowserSubreq*
infc_browser_add_subreq_add_node(InfcBrowser* browser,
                                 guint node_id,
                                 InfcBrowserNode* parent,
                                 const InfcNotePlugin* plugin,
                                 const gchar* name,
                                 const InfAclSheetSet* sheet_set,
                                 InfcRequest* request,
                                 InfCommunicationJoinedGroup* group)
{
  InfcBrowserSubreq* subreq;
  subreq = infc_browser_add_subreq_common(
    browser,
    INFC_BROWSER_SUBREQ_ADD_NODE,
    node_id
  );
  subreq-&gt;shared.add_node.parent = parent;
  subreq-&gt;shared.add_node.plugin = plugin;
  subreq-&gt;shared.add_node.name = g_strdup(name);
  if(sheet_set != NULL)
    subreq-&gt;shared.add_node.sheet_set = inf_acl_sheet_set_copy(sheet_set);
  else
    subreq-&gt;shared.add_node.sheet_set = NULL;
  subreq-&gt;shared.add_node.request = request;
  subreq-&gt;shared.add_node.subscription_group = group;
  if(request != NULL)
    g_object_ref(request);
  g_object_ref(group);
  return subreq;
}
static InfcBrowserSubreq*
infc_browser_add_subreq_sync_in(InfcBrowser* browser,
                                guint node_id,
                                InfcBrowserNode* parent,
                                const InfcNotePlugin* plugin,
                                const gchar* name,
                                const InfAclSheetSet* sheet_set,
                                InfcRequest* request,
                                InfSession* session,
                                InfCommunicationJoinedGroup* sync_group,
                                InfCommunicationJoinedGroup* sub_group)
{
  InfcBrowserSubreq* subreq;
  g_assert(request != NULL);
  g_assert(sync_group != NULL);
  g_assert(session != NULL);
  subreq = infc_browser_add_subreq_common(
    browser,
    INFC_BROWSER_SUBREQ_SYNC_IN,
    node_id
  );
  subreq-&gt;shared.sync_in.parent = parent;
  subreq-&gt;shared.sync_in.plugin = plugin;
  subreq-&gt;shared.sync_in.name = g_strdup(name);
  if(sheet_set != NULL)
    subreq-&gt;shared.sync_in.sheet_set = inf_acl_sheet_set_copy(sheet_set);
  else
    subreq-&gt;shared.sync_in.sheet_set = NULL;
  subreq-&gt;shared.sync_in.request = request;
  subreq-&gt;shared.sync_in.session = session;
  subreq-&gt;shared.sync_in.synchronization_group = sync_group;
  subreq-&gt;shared.sync_in.subscription_group = sub_group;
  g_object_ref(request);
  g_object_ref(session);
  g_object_ref(sync_group);
  if(sub_group != NULL)
    g_object_ref(sub_group);
  return subreq;
}
static void
infc_browser_free_subreq(InfcBrowserSubreq* request)
{
  switch(request-&gt;type)
  {
  case INFC_BROWSER_SUBREQ_CHAT:
    g_object_unref(request-&gt;shared.chat.subscription_group);
    if(request-&gt;shared.chat.request != NULL)
      g_object_unref(request-&gt;shared.chat.request);
    break;
  case INFC_BROWSER_SUBREQ_SESSION:
    g_object_unref(request-&gt;shared.session.subscription_group);
    if(request-&gt;shared.session.request != NULL)
      g_object_unref(request-&gt;shared.session.request);
    break;
  case INFC_BROWSER_SUBREQ_ADD_NODE:
    g_object_unref(request-&gt;shared.add_node.subscription_group);
    if(request-&gt;shared.add_node.request != NULL)
      g_object_unref(request-&gt;shared.add_node.request);
    if(request-&gt;shared.add_node.sheet_set != NULL)
      inf_acl_sheet_set_free(request-&gt;shared.add_node.sheet_set);
    g_free(request-&gt;shared.add_node.name);
    break;
  case INFC_BROWSER_SUBREQ_SYNC_IN:
    if(request-&gt;shared.sync_in.subscription_group != NULL)
      g_object_unref(request-&gt;shared.sync_in.subscription_group);
    g_object_unref(request-&gt;shared.sync_in.synchronization_group);
    g_object_unref(request-&gt;shared.sync_in.session);
    if(request-&gt;shared.sync_in.request != NULL)
      g_object_unref(request-&gt;shared.sync_in.request);
    if(request-&gt;shared.sync_in.sheet_set != NULL)
      inf_acl_sheet_set_free(request-&gt;shared.sync_in.sheet_set);
    g_free(request-&gt;shared.sync_in.name);
    break;
  default:
    g_assert_not_reached();
    break;
  }
  g_slice_free(InfcBrowserSubreq, request);
}
static void
infc_browser_unlink_subreq(InfcBrowser* browser,
                           InfcBrowserSubreq* request)
{
  InfcBrowserPrivate* priv;
  priv = INFC_BROWSER_PRIVATE(browser);
  priv-&gt;subscription_requests =
    g_slist_remove(priv-&gt;subscription_requests, request);
}
static void
infc_browser_remove_subreq(InfcBrowser* browser,
                           InfcBrowserSubreq* request)
{
  infc_browser_unlink_subreq(browser, request);
  infc_browser_free_subreq(request);
}
static InfcBrowserSubreq*
infc_browser_find_subreq(InfcBrowser* browser,
                         guint node_id)
{
  InfcBrowserPrivate* priv;
  GSList* item;
  InfcBrowserSubreq* subreq;
  priv = INFC_BROWSER_PRIVATE(browser);
  for(item = priv-&gt;subscription_requests; item != NULL; item = item-&gt;next)
  {
    subreq = (InfcBrowserSubreq*)item-&gt;data;
    switch(subreq-&gt;type)
    {
    case INFC_BROWSER_SUBREQ_CHAT:
    case INFC_BROWSER_SUBREQ_SESSION:
      break;
    case INFC_BROWSER_SUBREQ_ADD_NODE:
      if(subreq-&gt;node_id == node_id)
        return subreq;
      break;
    case INFC_BROWSER_SUBREQ_SYNC_IN:
      if(subreq-&gt;node_id == node_id)
        return subreq;
      break;
    default:
      g_assert_not_reached();
      break;
    }
  }
  return NULL;
}
static void
infc_browser_sync_in_synchronization_failed_cb(InfSession* session,
                                               InfXmlConnection* connection,
                                               GError* error,
                                               gpointer user_data)
{
  InfcBrowserSyncIn* sync_in;
  InfcBrowser* browser;
  InfcBrowserNode* node;
  sync_in = (InfcBrowserSyncIn*)user_data;
  if(connection != sync_in-&gt;connection) return;
  browser = sync_in-&gt;browser;
  node = sync_in-&gt;node;
  g_object_ref(browser);
  infc_browser_remove_sync_in(browser, sync_in);
  infc_browser_node_unregister(browser, node, NULL);
  infc_browser_node_free(browser, node);
  g_object_unref(browser);
}
static void
infc_browser_sync_in_synchronization_complete_cb(InfSession* session,
                                                 InfXmlConnection* connection,
                                                 gpointer user_data)
{
  InfcBrowserSyncIn* sync_in;
  sync_in = (InfcBrowserSyncIn*)user_data;
  if(connection != sync_in-&gt;connection) return;
  infc_browser_remove_sync_in(sync_in-&gt;browser, sync_in);
}
static InfcBrowserSyncIn*
infc_browser_add_sync_in(InfcBrowser* browser,
                         InfcBrowserNode* node,
                         InfXmlConnection* connection,
                         InfcSessionProxy* proxy)
{
  InfcBrowserPrivate* priv;
  InfcBrowserSyncIn* sync_in;
  InfSession* session;
  priv = INFC_BROWSER_PRIVATE(browser);
  sync_in = g_slice_new(InfcBrowserSyncIn);
  sync_in-&gt;browser = browser;
  sync_in-&gt;node = node;
  sync_in-&gt;connection = connection;
  sync_in-&gt;proxy = proxy;
  g_object_ref(proxy);
  g_object_get(G_OBJECT(proxy), "session", &amp;session, NULL);
  g_signal_connect(
    session,
    "synchronization-failed",
    G_CALLBACK(infc_browser_sync_in_synchronization_failed_cb),
    sync_in
  );
  g_signal_connect(
    session,
    "synchronization-complete",
    G_CALLBACK(infc_browser_sync_in_synchronization_complete_cb),
    sync_in
  );
  g_object_unref(session);
  priv-&gt;sync_ins = g_slist_prepend(priv-&gt;sync_ins, sync_in);
  return sync_in;
}
static void
infc_browser_remove_sync_in(InfcBrowser* browser,
                            InfcBrowserSyncIn* sync_in)
{
  InfcBrowserPrivate* priv;
  InfSession* session;
  priv = INFC_BROWSER_PRIVATE(browser);
  g_object_get(G_OBJECT(sync_in-&gt;proxy), "session", &amp;session, NULL);
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(session),
    G_CALLBACK(infc_browser_sync_in_synchronization_complete_cb),
    sync_in
  );
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(session),
    G_CALLBACK(infc_browser_sync_in_synchronization_failed_cb),
    sync_in
  );
  g_object_unref(session);
  g_object_unref(sync_in-&gt;proxy);
  g_slice_free(InfcBrowserSyncIn, sync_in);
  priv-&gt;sync_ins = g_slist_remove(priv-&gt;sync_ins, sync_in);
}
static InfcBrowserNode*
infc_browser_node_add_subdirectory(InfcBrowser* browser,
                                   InfcBrowserNode* parent,
                                   InfcRequest* request,
                                   guint id,
                                   const gchar* name,
                                   const InfAclSheetSet* sheet_set)
{
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  g_assert(parent-&gt;type == INFC_BROWSER_NODE_SUBDIRECTORY);
  g_assert(parent-&gt;shared.subdir.explored == TRUE);
  priv = INFC_BROWSER_PRIVATE(browser);
  node = infc_browser_node_new_subdirectory(
    browser,
    parent,
    id,
    name,
    sheet_set
  );
  infc_browser_node_register(browser, node, request);
  return node;
}
static InfcBrowserNode*
infc_browser_node_add_note(InfcBrowser* browser,
                           InfcBrowserNode* parent,
                           InfcRequest* request,
                           guint id,
                           const gchar* name,
                           const gchar* type,
                           const InfAclSheetSet* sheet_set,
                           InfcSessionProxy* sync_in_session)
{
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  g_assert(parent-&gt;type == INFC_BROWSER_NODE_SUBDIRECTORY);
  g_assert(parent-&gt;shared.subdir.explored == TRUE);
  priv = INFC_BROWSER_PRIVATE(browser);
  g_assert(priv-&gt;connection != NULL);
  node = infc_browser_node_new_note(
    browser,
    parent,
    id,
    name,
    type,
    sheet_set
  );
  if(sync_in_session != NULL)
  {
    infc_browser_add_sync_in(
      browser,
      node,
      priv-&gt;connection,
      sync_in_session
    );
  }
  infc_browser_node_register(browser, node, request);
  return node;
}
static void
infc_browser_subscribe_ack(InfcBrowser* browser,
                           InfXmlConnection* connection,
                           InfcBrowserSubreq* request)
{
  InfcBrowserPrivate* priv;
  xmlNodePtr xml;
  priv = INFC_BROWSER_PRIVATE(browser);
  xml = xmlNewNode(NULL, (const xmlChar*)"subscribe-ack");
  if(request-&gt;type != INFC_BROWSER_SUBREQ_CHAT)
    inf_xml_util_set_attribute_uint(xml, "id", request-&gt;node_id);
  inf_communication_group_send_message(
    INF_COMMUNICATION_GROUP(priv-&gt;group),
    connection,
    xml
  );
}
static void
infc_browser_subscribe_nack(InfcBrowser* browser,
                            InfXmlConnection* connection,
                            guint node_id)
{
  InfcBrowserPrivate* priv;
  xmlNodePtr xml;
  priv = INFC_BROWSER_PRIVATE(browser);
  xml = xmlNewNode(NULL, (const xmlChar*)"subscribe-nack");
  if(node_id &gt; 0) inf_xml_util_set_attribute_uint(xml, "id", node_id);
  inf_communication_group_send_message(
    INF_COMMUNICATION_GROUP(priv-&gt;group),
    connection,
    xml
  );
}
static InfcBrowserNode*
infc_browser_get_node_from_xml(InfcBrowser* browser,
                               xmlNodePtr xml,
                               const gchar* attrib,
                               GError** error)
{
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  guint node_id;
  gboolean has_node;
  priv = INFC_BROWSER_PRIVATE(browser);
  has_node = inf_xml_util_get_attribute_uint_required(
    xml,
    attrib,
    &amp;node_id,
    error
  );
  if(has_node == FALSE) return NULL;
  node = g_hash_table_lookup(priv-&gt;nodes, GUINT_TO_POINTER(node_id));
  if(node == NULL)
  {
    g_set_error(
      error,
      inf_directory_error_quark(),
      INF_DIRECTORY_ERROR_NO_SUCH_NODE,
      _("There is no such node with ID %u"),
      node_id
    );
    return NULL;
  }
  else
  {
    return node;
  }
}
static InfcBrowserNode*
infc_browser_get_node_from_xml_typed(InfcBrowser* browser,
                                     xmlNodePtr xml,
                                     const gchar* attrib,
                                     InfcBrowserNodeType mask,
                                     GError** error)
{
  InfcBrowserNode* node;
  g_assert(mask != 0);
  node = infc_browser_get_node_from_xml(browser, xml, attrib, error);
  if(node != NULL &amp;&amp; (node-&gt;type &amp; mask) == 0)
  {
    if(mask &amp; INFC_BROWSER_NODE_SUBDIRECTORY)
    {
      g_set_error_literal(
        error,
        inf_directory_error_quark(),
        INF_DIRECTORY_ERROR_NOT_A_SUBDIRECTORY,
        inf_directory_strerror(INF_DIRECTORY_ERROR_NOT_A_SUBDIRECTORY)
      );
    }
    else
    {
      g_set_error_literal(
        error,
        inf_directory_error_quark(),
        INF_DIRECTORY_ERROR_NOT_A_NOTE,
        inf_directory_strerror(INF_DIRECTORY_ERROR_NOT_A_NOTE)
      );
    }
    return NULL;
  }
  else
  {
    return node;
  }
}
static gboolean
infc_browser_validate_progress_request(InfcBrowser* browser,
                                       InfcProgressRequest* request,
                                       GError** error)
{
  guint current;
  guint total;
  if(infc_progress_request_get_initiated(request) == FALSE)
  {
    g_set_error_literal(
      error,
      inf_directory_error_quark(),
      INF_DIRECTORY_ERROR_NOT_INITIATED,
      inf_directory_strerror(INF_DIRECTORY_ERROR_NOT_INITIATED)
    );
    return FALSE;
  }
  else
  {
    g_object_get(
      G_OBJECT(request),
      "current", &amp;current,
      "total", &amp;total,
      NULL
    );
    if(current &gt;= total)
    {
      g_set_error_literal(
        error,
        inf_directory_error_quark(),
        INF_DIRECTORY_ERROR_TOO_MANY_CHILDREN,
        inf_directory_strerror(INF_DIRECTORY_ERROR_TOO_MANY_CHILDREN)
      );
      return FALSE;
    }
    else
    {
      return TRUE;
    }
  }
}
static InfcRequest*
infc_browser_get_add_node_request_from_xml(InfcBrowser* browser,
                                           xmlNodePtr xml,
                                           GError** error)
{
  InfcBrowserPrivate* priv;
  InfcRequest* request;
  gchar* type;
  gboolean result;
  priv = INFC_BROWSER_PRIVATE(browser);
  request = infc_request_manager_get_request_by_xml(
    priv-&gt;request_manager,
    NULL,
    xml,
    NULL
  );
  if(request != NULL)
  {
    g_object_get(G_OBJECT(request), "type", &amp;type, NULL);
    if(strcmp(type, "add-node") != 0 &amp;&amp; strcmp(type, "explore-node") != 0)
    {
      g_set_error(
        error,
        inf_request_error_quark(),
        INF_REQUEST_ERROR_INVALID_SEQ,
        _("The request contains a sequence number referring to a request of "
          "type '%s', but a request of either 'explore-node' or 'add-node' "
          "was expected."),
        type
      );
      g_free(type);
      return NULL;
    }
    if(strcmp(type, "explore-node") == 0)
    {
      g_assert(INFC_IS_PROGRESS_REQUEST(request));
      result = infc_browser_validate_progress_request(
        browser,
        INFC_PROGRESS_REQUEST(request),
        error
      );
      if(result == FALSE)
      {
        g_free(type);
        return NULL;
      }
    }
    g_free(type);
  }
  return request;
}
static void
infc_browser_process_add_node_request(InfcBrowser* browser,
                                      InfcRequest* request,
                                      InfcBrowserNode* node)
{
  InfcBrowserPrivate* priv;
  InfBrowserIter parent_iter;
  InfBrowserIter iter;
  priv = INFC_BROWSER_PRIVATE(browser);
  if(INFC_IS_PROGRESS_REQUEST(request))
  {
    infc_progress_request_progress(INFC_PROGRESS_REQUEST(request));
  }
  else
  {
    g_object_get(G_OBJECT(request), "node-id", &amp;parent_iter.node_id, NULL);
    g_assert(parent_iter.node_id != G_MAXUINT);
    parent_iter.node = g_hash_table_lookup(
      priv-&gt;nodes,
      GUINT_TO_POINTER(parent_iter.node_id)
    );
    g_assert(parent_iter.node != NULL);
    iter.node_id = node-&gt;id;
    iter.node = node;
    g_assert(node-&gt;parent == parent_iter.node);
    infc_request_manager_finish_request(
      priv-&gt;request_manager,
      request,
      inf_request_result_make_add_node(
        INF_BROWSER(browser),
        &amp;parent_iter,
        &amp;iter
      )
    );
  }
}
static InfCommunicationJoinedGroup*
infc_browser_create_group_from_xml(InfcBrowser* browser,
                                   InfXmlConnection* connection,
                                   xmlNodePtr xml,
                                   GError** error)
{
  InfcBrowserPrivate* priv;
  xmlChar* method_name;
  xmlChar* group_name;
  InfCommunicationJoinedGroup* group;
  priv = INFC_BROWSER_PRIVATE(browser);
  method_name = inf_xml_util_get_attribute_required(xml, "method", error);
  if(method_name == NULL) return FALSE;
  group_name = inf_xml_util_get_attribute_required(xml, "group", error);
  if(group_name == NULL) { xmlFree(method_name); return FALSE; }
  group = inf_communication_manager_join_group(
    priv-&gt;communication_manager,
    (const gchar*)group_name,
    connection,
    (const gchar*)method_name
  );
  if(!group)
  {
    g_propagate_error(
      error,
      infc_browser_method_unsupported_error(
        (const gchar*)method_name,
        connection
      )
    );
  }
  xmlFree(group_name);
  xmlFree(method_name);
  return group;
}
static void
infc_browser_subscribe_session(InfcBrowser* browser,
                               InfcBrowserNode* node,
                               InfcRequest* request,
                               InfCommunicationJoinedGroup* group,
                               InfXmlConnection* connection,
                               gboolean initial_sync)
{
  InfcBrowserPrivate* priv;
  InfcSessionProxy* proxy;
  InfBrowserIter iter;
  GString* path;
  InfSession* session;
  priv = INFC_BROWSER_PRIVATE(browser);
  g_assert(node-&gt;type == INFC_BROWSER_NODE_NOTE_KNOWN);
  g_assert(node-&gt;shared.known.plugin != NULL);
  g_assert(node-&gt;shared.known.session == NULL);
  path = g_string_sized_new(128);
  infc_browser_node_get_path_string(node, path);
  if(initial_sync)
  {
    session = node-&gt;shared.known.plugin-&gt;session_new(
      priv-&gt;io,
      priv-&gt;communication_manager,
      INF_SESSION_SYNCHRONIZING,
      INF_COMMUNICATION_GROUP(group),
      connection,
      path-&gt;str,
      node-&gt;shared.known.plugin-&gt;user_data
    );
  }
  else
  {
    session = node-&gt;shared.known.plugin-&gt;session_new(
      priv-&gt;io,
      priv-&gt;communication_manager,
      INF_SESSION_RUNNING,
      NULL,
      NULL,
      path-&gt;str,
      node-&gt;shared.known.plugin-&gt;user_data
    );
  }
  g_string_free(path, TRUE);
  proxy = g_object_new(INFC_TYPE_SESSION_PROXY, "session", session, NULL);
  inf_communication_group_set_target(
    INF_COMMUNICATION_GROUP(group),
    INF_COMMUNICATION_OBJECT(proxy)
  );
  infc_session_proxy_set_connection(proxy, group, connection, priv-&gt;seq_id);
  g_object_unref(session);
  iter.node_id = node-&gt;id;
  iter.node = node;
  inf_browser_subscribe_session(
    INF_BROWSER(browser),
    &amp;iter,
    INF_SESSION_PROXY(proxy),
    INF_REQUEST(request)
  );
  g_object_unref(proxy);
}
static gboolean
infc_browser_handle_welcome(InfcBrowser* browser,
                            InfXmlConnection* connection,
                            xmlNodePtr xml,
                            GError** error)
{
  InfcBrowserPrivate* priv;
  xmlChar* version;
  guint server_major;
  guint server_minor;
  guint own_major;
  guint own_minor;
  gboolean result;
  InfAclSheetSet* sheet_set;
  xmlNodePtr node;
  InfAclAccountId default_id;
  InfAclAccount* default_account;
  GError* local_error;
  InfAclSheet* sheet;
  InfAclMask default_mask;
  priv = INFC_BROWSER_PRIVATE(browser);
  version = inf_xml_util_get_attribute_required(
    xml,
    "protocol-version",
    error);
  if(!version) return FALSE;
  result = inf_protocol_parse_version(
    (const gchar*)version,
    &amp;server_major, &amp;server_minor,
    error
  );
  xmlFree(version);
  if(!result) return FALSE;
  result = inf_protocol_parse_version(
    inf_protocol_get_version(),
    &amp;own_major, &amp;own_minor,
    NULL
  );
  g_assert(result == TRUE);
  if(server_major &lt; own_major)
  {
    g_set_error_literal(
      error,
      inf_directory_error_quark(),
      INF_DIRECTORY_ERROR_VERSION_MISMATCH,
      _("The server uses an older version of the protocol which is no longer "
        "supported by this client. Consider using an earlier version of it, "
        "or ask the server administrators to upgrade their software.")
    );
    return FALSE;
  }
  if(server_major &gt; own_major)
  {
    g_set_error_literal(
      error,
      inf_directory_error_quark(),
      INF_DIRECTORY_ERROR_VERSION_MISMATCH,
      _("The server uses a newer version of the protocol which is not "
        "supported by this client. Consider upgrading your client.")
    );
    return FALSE;
  }
  result = inf_xml_util_get_attribute_uint_required(
    xml,
    "sequence-id",
    &amp;priv-&gt;seq_id,
    error
  );
  if(!result) return FALSE;
  g_assert(priv-&gt;accounts == NULL);
  g_assert(priv-&gt;local_account == NULL);
  priv-&gt;accounts = g_hash_table_new_full(
    NULL,
    NULL,
    NULL,
    (GDestroyNotify)inf_acl_account_free
  );
  default_id = inf_acl_account_id_from_string("default");
  default_account = inf_acl_account_new(default_id, NULL);
  g_hash_table_insert(
    priv-&gt;accounts, 
    INF_ACL_ACCOUNT_ID_TO_POINTER(default_account-&gt;id),
    default_account
  );
  priv-&gt;local_account = default_account;
  for(node = xml-&gt;children; node != NULL; node = node-&gt;next)
  {
    if(node-&gt;type != XML_ELEMENT_NODE) continue;
    if(strcmp(node-&gt;name, "account") == 0)
    {
      priv-&gt;local_account = inf_acl_account_from_xml(node, error);
      if(priv-&gt;local_account == NULL)
      {
        g_hash_table_destroy(priv-&gt;accounts);
        priv-&gt;accounts = NULL;
        return FALSE;
      }
      g_hash_table_insert(
        priv-&gt;accounts,
        INF_ACL_ACCOUNT_ID_TO_POINTER(priv-&gt;local_account-&gt;id),
        (gpointer)priv-&gt;local_account
      );
      break;
    }
  }
  local_error = NULL;
  sheet_set = inf_acl_sheet_set_from_xml(xml, &amp;local_error);
  if(local_error != NULL)
  {
    g_hash_table_destroy(priv-&gt;accounts);
    priv-&gt;accounts = NULL;
    priv-&gt;local_account = NULL;
    g_propagate_error(error, local_error);
    return FALSE;
  }
  if(sheet_set == NULL)
    sheet_set = inf_acl_sheet_set_new();
  sheet = inf_acl_sheet_set_add_sheet(sheet_set, default_id);
  default_mask = sheet-&gt;mask;
  inf_acl_mask_neg(&amp;default_mask, &amp;default_mask);
  inf_acl_mask_and(&amp;default_mask, &amp;INF_ACL_MASK_DEFAULT, &amp;default_mask);
  inf_acl_mask_or(&amp;sheet-&gt;perms, &amp;default_mask, &amp;sheet-&gt;perms);
  sheet-&gt;mask = INF_ACL_MASK_ALL;
  g_assert(priv-&gt;root == NULL);
  priv-&gt;root = infc_browser_node_new_subdirectory(
    browser,
    NULL,
    0,
    NULL,
    sheet_set
  );
  inf_acl_sheet_set_free(sheet_set);
  g_assert(priv-&gt;request_manager == NULL);
  priv-&gt;request_manager = infc_request_manager_new(priv-&gt;seq_id);
  priv-&gt;status = INF_BROWSER_OPEN;
  g_object_notify(G_OBJECT(browser), "status");
  inf_browser_acl_account_added(INF_BROWSER(browser), default_account, NULL);
  if(priv-&gt;local_account != default_account)
  {
    inf_browser_acl_account_added(
      INF_BROWSER(browser),
      priv-&gt;local_account,
      NULL
    );
  }
  return TRUE;
}
static gboolean
infc_browser_handle_explore_begin(InfcBrowser* browser,
                                  InfXmlConnection* connection,
                                  xmlNodePtr xml,
                                  GError** error)
{
  InfcBrowserPrivate* priv;
  InfcRequest* request;
  guint total;
  guint node_id;
  InfcBrowserNode* node;
  priv = INFC_BROWSER_PRIVATE(browser);
  request = infc_request_manager_get_request_by_xml_required(
    priv-&gt;request_manager,
    "explore-node",
    xml,
    error
  );
  if(request == NULL) return FALSE;
  g_assert(INFC_IS_PROGRESS_REQUEST(request));
  if(!inf_xml_util_get_attribute_uint_required(xml, "total", &amp;total, error))
    return FALSE;
  g_object_get(G_OBJECT(request), "node-id", &amp;node_id, NULL);
  g_assert(node_id != G_MAXUINT);
  node = g_hash_table_lookup(priv-&gt;nodes, GUINT_TO_POINTER(node_id));
  if(node == NULL)
  {
    g_set_error_literal(
      error,
      inf_directory_error_quark(),
      INF_DIRECTORY_ERROR_NO_SUCH_NODE,
      _("Node to explore does no longer exist")
    );
    return FALSE;
  }
  else if(node-&gt;type != INFC_BROWSER_NODE_SUBDIRECTORY)
  {
    g_set_error_literal(
      error,
      inf_directory_error_quark(),
      INF_DIRECTORY_ERROR_NOT_A_SUBDIRECTORY,
      _("Node to explore is not a subdirectory")
    );
    return FALSE;
  }
  else if(node-&gt;shared.subdir.explored == TRUE)
  {
    g_set_error_literal(
      error,
      inf_directory_error_quark(),
      INF_DIRECTORY_ERROR_ALREADY_EXPLORED,
      _("Node to explore is already explored")
    );
    return FALSE;
  }
  else
  {
    node-&gt;shared.subdir.explored = TRUE;
    infc_progress_request_initiated(INFC_PROGRESS_REQUEST(request), total);
    return TRUE;
  }
}
static gboolean
infc_browser_handle_explore_end(InfcBrowser* browser,
                                InfXmlConnection* connection,
                                xmlNodePtr xml,
                                GError** error)
{
  InfcBrowserPrivate* priv;
  InfcRequest* request;
  guint current;
  guint total;
  InfBrowserIter iter;
  priv = INFC_BROWSER_PRIVATE(browser);
  request = infc_request_manager_get_request_by_xml_required(
    priv-&gt;request_manager,
    "explore-node",
    xml,
    error
  );
  if(request == NULL) return FALSE;
  g_assert(INFC_IS_PROGRESS_REQUEST(request));
  g_object_get(G_OBJECT(request), "current", &amp;current, "total", &amp;total, NULL);
  if(current &lt; total)
  {
    g_set_error_literal(
      error,
      inf_directory_error_quark(),
      INF_DIRECTORY_ERROR_TOO_FEW_CHILDREN,
      _("Not all nodes were received before explore-end was received")
    );
    return FALSE;
  }
  else
  {
    g_object_get(G_OBJECT(request), "node-id", &amp;iter.node_id, NULL);
    iter.node = g_hash_table_lookup(
      priv-&gt;nodes,
      GUINT_TO_POINTER(iter.node_id)
    );
    g_assert(iter.node != NULL);
    infc_request_manager_finish_request(
      priv-&gt;request_manager,
      request,
      inf_request_result_make_explore_node(INF_BROWSER(browser), &amp;iter)
    );
    return TRUE;
  }
}
static gboolean
infc_browser_handle_add_node(InfcBrowser* browser,
                             InfXmlConnection* connection,
                             xmlNodePtr xml,
                             GError** error)
{
  InfcBrowserPrivate* priv;
  InfcBrowserNode* parent;
  InfcBrowserNode* node;
  guint id;
  xmlChar* name;
  xmlChar* type;
  InfAclSheetSet* sheet_set;
  InfcRequest* request;
  GError* local_error;
  xmlNodePtr child;
  const InfcNotePlugin* plugin;
  InfCommunicationJoinedGroup* group;
  InfcBrowserSubreq* subreq;
  gboolean result;
  priv = INFC_BROWSER_PRIVATE(browser);
  if(inf_xml_util_get_attribute_uint_required(xml, "id", &amp;id, error) == FALSE)
    return FALSE;
  if(g_hash_table_lookup(priv-&gt;nodes, GUINT_TO_POINTER(id)) != NULL ||
     infc_browser_find_subreq(browser, id) != NULL)
  {
    g_set_error(
      error,
      inf_directory_error_quark(),
      INF_DIRECTORY_ERROR_NODE_EXISTS,
      _("Node with ID \"%u\" exists already"),
      id
    );
    return FALSE;
  }
  parent = infc_browser_get_node_from_xml_typed(
    browser,
    xml,
    "parent",
    INFC_BROWSER_NODE_SUBDIRECTORY,
    error
  );
  if(parent == NULL) return FALSE;
  if(parent-&gt;shared.subdir.explored == FALSE)
  {
    g_set_error_literal(
      error,
      inf_directory_error_quark(),
      INF_DIRECTORY_ERROR_NOT_EXPLORED,
      _("The parent node has not been explored yet")
    );
    return FALSE;
  }
  local_error = NULL;
  request =
    infc_browser_get_add_node_request_from_xml(browser, xml, &amp;local_error);
  if(local_error != NULL)
  {
    g_propagate_error(error, local_error);
    return FALSE;
  }
  type = inf_xml_util_get_attribute_required(xml, "type", error);
  if(type == NULL) return FALSE;
  name = inf_xml_util_get_attribute_required(xml, "name", error);
  if(name == NULL)
  {
    xmlFree(type);
    return FALSE;
  }
  sheet_set = inf_acl_sheet_set_from_xml(xml, &amp;local_error);
  if(local_error != NULL)
  {
    xmlFree(type);
    xmlFree(name);
    g_propagate_error(error, local_error);
    return FALSE;
  }
  if(strcmp((const gchar*)type, "InfSubdirectory") == 0)
  {
    node = infc_browser_node_add_subdirectory(
      browser,
      parent,
      request,
      id,
      (const gchar*)name,
      sheet_set
    );
    if(request != NULL)
    {
      infc_browser_process_add_node_request(
        browser,
        request,
        node
      );
    }
    result = TRUE;
  }
  else
  {
    for(child = xml-&gt;children; child != NULL; child = child-&gt;next)
      if(strcmp((const char*)child-&gt;name, "subscribe") == 0)
        break;
    if(child != NULL)
    {
      if(request != NULL &amp;&amp; INFC_IS_PROGRESS_REQUEST(request))
      {
        g_set_error_literal(
          error,
          inf_request_error_quark(),
          INF_REQUEST_ERROR_INVALID_SEQ,
          _("Explored nodes cannot be initially be subscribed to")
        );
        result = FALSE;
      }
      else
      {
        plugin = g_hash_table_lookup(priv-&gt;plugins, type);
        if(plugin == NULL)
        {
          g_set_error(
            error,
            inf_directory_error_quark(),
            INF_DIRECTORY_ERROR_TYPE_UNKNOWN,
            _("Note type \"%s\" not known"),
            (const gchar*)type
          );
          infc_browser_subscribe_nack(browser, connection, id);
          result = FALSE;
        }
        else
        {
          group = infc_browser_create_group_from_xml(
            browser,
            connection,
            child,
            error
          );
          if(group == NULL)
          {
            infc_browser_subscribe_nack(browser, connection, id);
            result = FALSE;
          }
          else
          {
            subreq = infc_browser_add_subreq_add_node(
              browser,
              id,
              parent,
              plugin,
              (const gchar*)name,
              sheet_set,
              request,
              group
            );
            g_object_unref(group);
            infc_browser_subscribe_ack(browser, connection, subreq);
            result = TRUE;
          }
        }
      }
    }
    else
    {
      node = infc_browser_node_add_note(
        browser,
        parent,
        request,
        id,
        (const gchar*)name,
        (const gchar*)type,
        sheet_set,
        NULL
      );
      if(request != NULL)
      {
        infc_browser_process_add_node_request(
          browser,
          request,
          node
        );
      }
      result = TRUE;
    }
  }
  if(sheet_set != NULL)
    inf_acl_sheet_set_free(sheet_set);
  xmlFree(type);
  xmlFree(name);
  return result;
}
static gboolean
infc_browser_handle_sync_in(InfcBrowser* browser,
                            InfXmlConnection* connection,
                            xmlNodePtr xml,
                            GError** error)
{
  InfcBrowserPrivate* priv;
  guint id;
  InfcBrowserNode* parent;
  InfcRequest* request;
  InfSession* session;
  const InfcNotePlugin* plugin;
  InfCommunicationJoinedGroup* sync_group;
  xmlChar* type;
  xmlChar* name;
  GError* local_error;
  InfAclSheetSet* sheet_set;
  xmlNodePtr child;
  InfcBrowserSubreq* subreq;
  gboolean result;
  priv = INFC_BROWSER_PRIVATE(browser); 
  if(inf_xml_util_get_attribute_uint_required(xml, "id", &amp;id, error) == FALSE)
    return FALSE;
  if(g_hash_table_lookup(priv-&gt;nodes, GUINT_TO_POINTER(id)) != NULL ||
     infc_browser_find_subreq(browser, id) != NULL)
  {
    g_set_error(
      error,
      inf_directory_error_quark(),
      INF_DIRECTORY_ERROR_NODE_EXISTS,
      _("Node with ID \"%u\" exists already"),
      id
    );
    return FALSE;
  }
  parent = infc_browser_get_node_from_xml_typed(
    browser,
    xml,
    "parent",
    INFC_BROWSER_NODE_SUBDIRECTORY,
    error
  );
  if(parent == NULL) return FALSE;
  request = infc_request_manager_get_request_by_xml_required(
    priv-&gt;request_manager,
    "add-node",
    xml,
    error
  );
  if(!request) return FALSE;
  session = g_object_steal_qdata(
    G_OBJECT(request),
    infc_browser_sync_in_session_quark
  );
  plugin = g_object_steal_qdata(
    G_OBJECT(request),
    infc_browser_sync_in_plugin_quark
  );
  if(session == NULL)
  {
    g_set_error_literal(
      error,
      inf_directory_error_quark(),
      INF_DIRECTORY_ERROR_UNEXPECTED_SYNC_IN,
      _("Received sync-in without having requested one")
    );
    return FALSE;
  }
  g_assert(plugin != NULL);
  result = FALSE;
  type = inf_xml_util_get_attribute_required(xml, "type", error);
  if(type != NULL)
  {
    if(strcmp((const char*)type, plugin-&gt;note_type) != 0)
    {
      g_set_error(
        error,
        inf_directory_error_quark(),
        INF_DIRECTORY_ERROR_UNEXPECTED_SYNC_IN,
        _("Expected note type \"%s\" for sync-in, but received \"%s\""),
        plugin-&gt;note_type,
        (const gchar*)type
      );
    }
    else
    {
      name = inf_xml_util_get_attribute_required(xml, "name", error);
      if(name != NULL)
      {
        local_error = NULL;
        sheet_set = inf_acl_sheet_set_from_xml(xml, &amp;local_error);
        if(local_error != NULL)
        {
          g_propagate_error(error, local_error);
        }
        else
        {
          sync_group = infc_browser_create_group_from_xml(
            browser,
            connection,
            xml,
            error
          );
          if(sync_group == NULL)
          {
            infc_browser_subscribe_nack(browser, connection, id);
          }
          else
          {
            for(child = xml-&gt;children; child != NULL; child = child-&gt;next)
              if(strcmp((const char*)child-&gt;name, "subscribe") == 0)
                break;
            subreq = infc_browser_add_subreq_sync_in(
              browser,
              id,
              parent,
              plugin,
              (const gchar*)name,
              sheet_set,
              request,
              session,
              sync_group,
              child != NULL ? sync_group : NULL
            );
            g_object_unref(sync_group);
            infc_browser_subscribe_ack(browser, connection, subreq);
            result = TRUE;
          }
          if(sheet_set != NULL)
            inf_acl_sheet_set_free(sheet_set);
        }
        xmlFree(name);
      }
    }
    xmlFree(type);
  }
  g_object_unref(session);
  return result;
}
static gboolean
infc_browser_handle_remove_node(InfcBrowser* browser,
                                InfXmlConnection* connection,
                                xmlNodePtr xml,
                                GError** error)
{
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  InfcRequest* request;
  InfBrowserIter iter;
  priv = INFC_BROWSER_PRIVATE(browser);
  node = infc_browser_get_node_from_xml(browser, xml, "id", error);
  if(node == NULL) return FALSE;
  request = infc_request_manager_get_request_by_xml(
    priv-&gt;request_manager,
    "remove-node",
    xml,
    NULL
  );
  if(request != NULL)
  {
    g_object_ref(request);
    iter.node_id = node-&gt;id;
    iter.node = node;
    infc_request_manager_finish_request(
      priv-&gt;request_manager,
      request,
      inf_request_result_make_remove_node(INF_BROWSER(browser), &amp;iter)
    );
  }
  infc_browser_session_remove_child_sessions(browser, node, request);
  infc_browser_node_unregister(browser, node, request);
  infc_browser_node_free(browser, node);
  if(request != NULL)
    g_object_unref(request);
  return TRUE;
}
static gboolean
infc_browser_handle_subscribe_session(InfcBrowser* browser,
                                      InfXmlConnection* connection,
                                      xmlNodePtr xml,
                                      GError** error)
{
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  InfcRequest* request;
  InfCommunicationJoinedGroup* group;
  InfcBrowserSubreq* subreq;
  priv = INFC_BROWSER_PRIVATE(browser);
  node = infc_browser_get_node_from_xml_typed(
    browser,
    xml,
    "id",
    INFC_BROWSER_NODE_NOTE_KNOWN | INFC_BROWSER_NODE_NOTE_UNKNOWN,
    error
  );
  if(node == NULL) return FALSE;
  if(node-&gt;type == INFC_BROWSER_NODE_NOTE_UNKNOWN)
  {
    g_set_error(
      error,
      inf_directory_error_quark(),
      INF_DIRECTORY_ERROR_TYPE_UNKNOWN,
      _("Note type '%s' is not supported"),
      node-&gt;shared.unknown.type
    );
    infc_browser_subscribe_nack(browser, connection, node-&gt;id);
    return FALSE;
  }
  if(node-&gt;shared.known.session != NULL)
  {
    g_set_error_literal(
      error,
      inf_directory_error_quark(),
      INF_DIRECTORY_ERROR_ALREADY_SUBSCRIBED,
      _("Already subscribed to this session")
    );
    return FALSE;
  }
  group = infc_browser_create_group_from_xml(
    browser,
    connection,
    xml,
    error
  );
  if(!group)
  {
    infc_browser_subscribe_nack(browser, connection, node-&gt;id);
    return FALSE;
  }
  request = infc_request_manager_get_request_by_xml(
    priv-&gt;request_manager,
    "subscribe-session",
    xml,
    NULL
  );
  subreq = infc_browser_add_subreq_session(browser, node, request, group);
  g_object_unref(group);
  infc_browser_subscribe_ack(browser, connection, subreq);
  return TRUE;
}
static gboolean
infc_browser_handle_subscribe_chat(InfcBrowser* browser,
                                   InfXmlConnection* connection,
                                   xmlNodePtr xml,
                                   GError** error)
{
  InfcBrowserPrivate* priv;
  InfcRequest* request;
  InfCommunicationJoinedGroup* group;
  InfcBrowserSubreq* subreq;
  priv = INFC_BROWSER_PRIVATE(browser);
  if(priv-&gt;chat_session != NULL)
  {
    g_set_error_literal(
      error,
      inf_directory_error_quark(),
      INF_DIRECTORY_ERROR_ALREADY_SUBSCRIBED,
      _("Already subscribed to the chat session")
    );
    return FALSE;
  }
  group = infc_browser_create_group_from_xml(
    browser,
    connection,
    xml,
    error
  );
  if(!group)
  {
    infc_browser_subscribe_nack(browser, connection, 0);
    return FALSE;
  }
  request = infc_request_manager_get_request_by_xml(
    priv-&gt;request_manager,
    "subscribe-chat",
    xml,
    NULL
  );
  subreq = infc_browser_add_subreq_chat(browser, request, group);
  g_object_unref(group);
  infc_browser_subscribe_ack(browser, connection, subreq);
  return TRUE;
}
static gboolean
infc_browser_handle_save_session_in_progress(InfcBrowser* browser,
                                             InfXmlConnection* connection,
                                             xmlNodePtr xml,
                                             GError** error)
{
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  InfcRequest* request;
  priv = INFC_BROWSER_PRIVATE(browser);
  node = infc_browser_get_node_from_xml_typed(
    browser,
    xml,
    "id",
    INFC_BROWSER_NODE_NOTE_KNOWN,
    error
  );
  if(node == NULL) return FALSE;
  request = infc_request_manager_get_request_by_xml(
    priv-&gt;request_manager,
    "save-session",
    xml,
    NULL
  );
  if(request != NULL)
  {
  }
  return TRUE;
}
static gboolean
infc_browser_handle_saved_session(InfcBrowser* browser,
                                  InfXmlConnection* connection,
                                  xmlNodePtr xml,
                                  GError** error)
{
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  InfcRequest* request;
  InfBrowserIter iter;
  priv = INFC_BROWSER_PRIVATE(browser);
  node = infc_browser_get_node_from_xml_typed(
    browser,
    xml,
    "id",
    INFC_BROWSER_NODE_NOTE_KNOWN,
    error
  );
  if(node == NULL) return FALSE;
  request = infc_request_manager_get_request_by_xml(
    priv-&gt;request_manager,
    "save-session",
    xml,
    NULL
  );
  if(request != NULL)
  {
    iter.node_id = node-&gt;id;
    iter.node = node;
    infc_request_manager_finish_request(
      priv-&gt;request_manager,
      request,
      inf_request_result_make_save_session(INF_BROWSER(browser), &amp;iter)
    );
  }
  return TRUE;
}
static gboolean
infc_browser_handle_acl_account_list_begin(InfcBrowser* browser,
                                           InfXmlConnection* connection,
                                           xmlNodePtr xml,
                                           GError** error)
{
  InfcBrowserPrivate* priv;
  InfcRequest* request;
  guint total;
  guint notifications_enabled;
  gboolean result;
  guint node_id;
  InfcBrowserNode* node;
  InfBrowserIter iter;
  priv = INFC_BROWSER_PRIVATE(browser);
  request = infc_request_manager_get_request_by_xml_required(
    priv-&gt;request_manager,
    "query-acl-account-list",
    xml,
    error
  );
  if(request == NULL) return FALSE;
  g_assert(INFC_IS_PROGRESS_REQUEST(request));
  if(!inf_xml_util_get_attribute_uint_required(xml, "total", &amp;total, error))
    return FALSE;
  result = inf_xml_util_get_attribute_uint_required(
    xml,
    "notifications-enabled",
    &amp;notifications_enabled,
    error
  );
  if(result == FALSE)
    return FALSE;
  g_object_set_qdata_full(
    G_OBJECT(request),
    infc_browser_query_acl_account_list_accounts_quark,
    g_hash_table_new(NULL, NULL),
    (GDestroyNotify)g_hash_table_destroy
  );
  if(notifications_enabled)
    priv-&gt;account_list_status = INFC_BROWSER_ACCOUNT_LIST_NOTIFICATIONS;
  else
    priv-&gt;account_list_status = INFC_BROWSER_ACCOUNT_LIST_NO_NOTIFICATIONS;
  infc_progress_request_initiated(INFC_PROGRESS_REQUEST(request), total);
  return TRUE;
}
static gboolean
infc_browser_handle_acl_account_list_end(InfcBrowser* browser,
                                         InfXmlConnection* connection,
                                         xmlNodePtr xml,
                                         GError** error)
{
  InfcBrowserPrivate* priv;
  InfcRequest* request;
  guint current;
  guint total;
  InfBrowserIter iter;
  InfAclAccountId default_id;
  GHashTable* table;
  GHashTableIter hash_iter;
  gpointer value;
  InfAclAccount* account;
  GSList* to_be_removed;
  GSList* item;
  InfAclAccount* accounts;
  guint n_accounts;
  gboolean does_notifications;
  priv = INFC_BROWSER_PRIVATE(browser);
  request = infc_request_manager_get_request_by_xml_required(
    priv-&gt;request_manager,
    "query-acl-account-list",
    xml,
    error
  );
  if(request == NULL) return FALSE;
  g_assert(INFC_IS_PROGRESS_REQUEST(request));
  g_object_get(G_OBJECT(request), "current", &amp;current, "total", &amp;total, NULL);
  if(current &lt; total)
  {
    g_set_error_literal(
      error,
      inf_directory_error_quark(),
      INF_DIRECTORY_ERROR_TOO_FEW_CHILDREN,
      _("Not all users have been transmitted before "
        "user-list-end was received")
    );
    return FALSE;
  }
  else
  {
    table = g_object_get_qdata(
      G_OBJECT(request),
      infc_browser_query_acl_account_list_accounts_quark
    );
    to_be_removed = NULL;
    default_id = inf_acl_account_id_from_string("default");
    g_hash_table_iter_init(&amp;hash_iter, priv-&gt;accounts);
    while(g_hash_table_iter_next(&amp;hash_iter, NULL, &amp;value))
    {
      account = (InfAclAccount*)value;
      if(account != priv-&gt;local_account &amp;&amp;
         account-&gt;id != default_id &amp;&amp;
         g_hash_table_lookup(table, account) == NULL)
      {
        to_be_removed = g_slist_prepend(to_be_removed, account);
      }
    }
    for(item = to_be_removed; item != NULL; item = item-&gt;next)
    {
      account = (InfAclAccount*)item-&gt;data;
      g_hash_table_steal(
        priv-&gt;accounts,
        INF_ACL_ACCOUNT_ID_TO_POINTER(account-&gt;id)
      );
      inf_browser_acl_account_removed(INF_BROWSER(browser), account, NULL);
      inf_acl_account_free(account);
    }
    accounts = infc_browser_make_acl_account_list(browser, &amp;n_accounts);
    switch(priv-&gt;account_list_status)
    {
    case INFC_BROWSER_ACCOUNT_LIST_NOT_QUERIED:
      g_assert_not_reached();
      break;
    case INFC_BROWSER_ACCOUNT_LIST_NO_NOTIFICATIONS:
      does_notifications = FALSE;
      break;
    case INFC_BROWSER_ACCOUNT_LIST_NOTIFICATIONS:
      does_notifications = TRUE;
      break;
    default:
      g_assert_not_reached();
      break;
    }
    infc_request_manager_finish_request(
      priv-&gt;request_manager,
      request,
      inf_request_result_make_query_acl_account_list(
        INF_BROWSER(browser),
        accounts,
        n_accounts,
        does_notifications
      )
    );
    g_free(accounts);
    return TRUE;
  }
}
static void
infc_browser_handle_add_acl_account_foreach_func(InfcRequest* request,
                                                 gpointer user_data)
{
  GHashTable* table;
  table = g_object_get_qdata(
    G_OBJECT(request),
    infc_browser_query_acl_account_list_accounts_quark
  );
  g_hash_table_insert(table, user_data, user_data);
}
static gboolean
infc_browser_handle_add_acl_account(InfcBrowser* browser,
                                    InfXmlConnection* connection,
                                    xmlNodePtr xml,
                                    GError** error)
{
  InfcBrowserPrivate* priv;
  GError* local_error;
  InfcRequest* request;
  gboolean result;
  InfAclAccount* account;
  InfAclAccount* cache_account;
  gchar* id;
  priv = INFC_BROWSER_PRIVATE(browser);
  local_error = NULL;
  request = infc_request_manager_get_request_by_xml(
    priv-&gt;request_manager,
    "query-acl-account-list",
    xml,
    &amp;local_error
  );
  if(local_error != NULL)
  {
    g_propagate_error(error, local_error);
    return FALSE;
  }
  if(request != NULL)
  {
    g_assert(INFC_IS_PROGRESS_REQUEST(request));
    result = infc_browser_validate_progress_request(
      browser,
      INFC_PROGRESS_REQUEST(request),
      error
    );
    if(result == FALSE)
      return FALSE;
  }
  account = inf_acl_account_from_xml(xml, error);
  if(account == NULL) return FALSE;
  cache_account = g_hash_table_lookup(
    priv-&gt;accounts,
    INF_ACL_ACCOUNT_ID_TO_POINTER(account-&gt;id)
  );
  if(cache_account != NULL)
  {
    if(strcmp(cache_account-&gt;name, account-&gt;name) != 0)
    {
      g_free(cache_account-&gt;name);
      cache_account-&gt;name = g_strdup(account-&gt;name);
    }
    inf_acl_account_free(account);
  }
  else
  {
    g_hash_table_insert(
      priv-&gt;accounts,
      INF_ACL_ACCOUNT_ID_TO_POINTER(account-&gt;id),
      account
    );
    inf_browser_acl_account_added(
      INF_BROWSER(browser),
      account,
      INF_REQUEST(request)
    );
    cache_account = account;
  }
  if(request != NULL)
    infc_progress_request_progress(INFC_PROGRESS_REQUEST(request));
  infc_request_manager_foreach_named_request(
    priv-&gt;request_manager,
    "query-acl-account-list",
    infc_browser_handle_add_acl_account_foreach_func,
    cache_account
  );
  return TRUE;
}
static gboolean
infc_browser_handle_lookup_acl_accounts(InfcBrowser* browser,
                                        InfXmlConnection* connection,
                                        xmlNodePtr xml,
                                        GError** error)
{
  InfcBrowserPrivate* priv;
  GError* local_error;
  InfcRequest* request;
  xmlNodePtr child;
  GPtrArray* accounts;
  InfAclAccount* account;
  InfAclAccount* existing_account;
  InfAclAccount req_account;
  InfcBrowserLookupAclAccountByByNameData lookup_data;
  GArray* req_accounts;
  guint i;
  guint len;
  gchar* name;
  const InfAclAccountId* ids;
  guint n_ids;
  priv = INFC_BROWSER_PRIVATE(browser);
  local_error = NULL;
  request = infc_request_manager_get_request_by_xml(
    priv-&gt;request_manager,
    "lookup-acl-accounts",
    xml,
    error
  );
  if(local_error != NULL)
  {
    g_propagate_error(error, local_error);
    return FALSE;
  }
  accounts = g_ptr_array_new();
  for(child = xml-&gt;children; child != NULL; child = child-&gt;next)
  {
    if(child-&gt;type != XML_ELEMENT_NODE) continue;
    if(strcmp((const gchar*)child-&gt;name, "account") == 0)
    {
      account = inf_acl_account_from_xml(child, error);
      if(account == NULL)
      {
        for(i = 0; i &lt; accounts-&gt;len; ++i)
          inf_acl_account_free(accounts-&gt;pdata[i]);
        g_ptr_array_free(accounts, TRUE);
        return FALSE;
      }
      g_ptr_array_add(accounts, account);
    }
  }
  for(i = 0; i &lt; accounts-&gt;len; ++i)
  {
    account = (InfAclAccount*)accounts-&gt;pdata[i];
    existing_account = g_hash_table_lookup(
      priv-&gt;accounts,
      INF_ACL_ACCOUNT_ID_TO_POINTER(account-&gt;id)
    );
    if(existing_account != NULL)
    {
      if(strcmp(existing_account-&gt;name, account-&gt;name) != 0)
      {
        g_free(existing_account-&gt;name);
        existing_account-&gt;name = g_strdup(account-&gt;name);
      }
      inf_acl_account_free(account);
    }
    else
    {
      if(priv-&gt;account_list_status == INFC_BROWSER_ACCOUNT_LIST_NOTIFICATIONS)
      {
        g_warning(
          _("Unknown account ID \"%s\" in server reply of "
            "\"%s\". Typically, this means the server claimed it notified us "
            "about new connections as soon as they are available, but it "
            "did not do so."),
          inf_acl_account_id_to_string(account-&gt;id),
          "lookup-acl-accounts"
        );
      }
      g_hash_table_insert(
        priv-&gt;accounts,
        INF_ACL_ACCOUNT_ID_TO_POINTER(account-&gt;id),
        account
      );
      inf_browser_acl_account_added(
        INF_BROWSER(browser),
        account,
        INF_REQUEST(request)
      );
    }
  }
  g_ptr_array_free(accounts, TRUE);
  if(request != NULL)
  {
    ids = g_object_get_qdata(
      G_OBJECT(request), 
      infc_browser_lookup_acl_accounts_ids_quark
    );
    n_ids = GPOINTER_TO_UINT(
      g_object_get_qdata(
        G_OBJECT(request),
        infc_browser_lookup_acl_accounts_n_ids_quark
      )
    );
    name = g_object_get_qdata(
      G_OBJECT(request),
      infc_browser_lookup_acl_accounts_name_quark
    );
    req_accounts = g_array_new(FALSE, FALSE, sizeof(InfAclAccount));
    if(ids != NULL)
    {
      g_assert(n_ids &gt; 0);
      for(i = 0; i &lt; n_ids; ++i)
      {
        account = g_hash_table_lookup(
          priv-&gt;accounts,
          INF_ACL_ACCOUNT_ID_TO_POINTER(ids[i])
        );
        if(account != NULL)
        {
          g_array_append_val(req_accounts, *account);
        }
        else
        {
          req_account.id = ids[i];
          req_account.name = NULL;
          g_array_append_val(req_accounts, req_account);
        }
      }
    }
    if(name != NULL)
    {
      len = req_accounts-&gt;len;
      lookup_data.name = name;
      lookup_data.accounts = req_accounts;
      g_hash_table_foreach(
        priv-&gt;accounts,
        infc_browser_browser_lookup_acl_account_by_name_find_func,
        &amp;lookup_data
      );
      if(req_accounts-&gt;len == len)
      {
        req_account.id = 0;
        req_account.name = name;
        g_array_append_val(req_accounts, req_account);
      }
    }
    infc_request_manager_finish_request(
      priv-&gt;request_manager,
      request,
      inf_request_result_make_lookup_acl_accounts(
        INF_BROWSER(browser),
        (InfAclAccount*)req_accounts-&gt;data,
        req_accounts-&gt;len
      )
    );
    g_array_free(req_accounts, TRUE);
  }
  return TRUE;
}
static gboolean
infc_browser_handle_change_acl_account(InfcBrowser* browser,
                                       InfXmlConnection* connection,
                                       xmlNodePtr xml,
                                       GError** error)
{
  InfcBrowserPrivate* priv;
  InfAclAccount* account;
  InfAclAccount* existing_account;
  GHashTable* new_acls;
  xmlNodePtr child;
  gboolean res;
  InfAclSheet* sheet;
  guint node_id;
  priv = INFC_BROWSER_PRIVATE(browser);
  account = inf_acl_account_from_xml(xml, error);
  if(account == NULL) return FALSE;
  existing_account = g_hash_table_lookup(
    priv-&gt;accounts,
    INF_ACL_ACCOUNT_ID_TO_POINTER(account-&gt;id)
  );
  if(existing_account != NULL)
  {
    if(account-&gt;name == NULL || existing_account-&gt;name == NULL ||
       strcmp(account-&gt;name, existing_account-&gt;name) != 0)
    {
      g_free(existing_account-&gt;name);
      existing_account-&gt;name = g_strdup(account-&gt;name);
    }
    inf_acl_account_free(account);
    account = existing_account;
  }
  new_acls = g_hash_table_new_full(
    NULL,
    NULL,
    NULL,
    (GDestroyNotify)inf_acl_sheet_free
  );
  for(child = xml-&gt;children; child != NULL; child = child-&gt;next)
  {
    if(child-&gt;type != XML_ELEMENT_NODE) continue;
    if(strcmp((const gchar*)child-&gt;name, "acl") == 0)
    {
      res = inf_xml_util_get_attribute_uint_required(
        child,
        "node-id",
        &amp;node_id,
        error
      );
      if(res == FALSE)
      {
        if(account != existing_account)
          inf_acl_account_free(account);
        g_hash_table_destroy(new_acls);
        return FALSE;
      }
      sheet = inf_acl_sheet_new(account-&gt;id);
      res = inf_acl_sheet_perms_from_xml(
        child,
        &amp;sheet-&gt;mask,
        &amp;sheet-&gt;perms,
        error
      );
      if(res == FALSE)
      {
        inf_acl_sheet_free(sheet);
        if(account != existing_account)
          inf_acl_account_free(account);
        g_hash_table_destroy(new_acls);
        return FALSE;
      }
      g_hash_table_insert(new_acls, GUINT_TO_POINTER(node_id), sheet);
    }
  }
  if(account != existing_account)
  {
    g_hash_table_insert(
      priv-&gt;accounts,
      INF_ACL_ACCOUNT_ID_TO_POINTER(account-&gt;id),
      account
    );
    inf_browser_acl_account_added(
      INF_BROWSER(browser),
      account,
      NULL
    );
  }
  priv-&gt;local_account = account;
  infc_browser_enforce_acl(browser, priv-&gt;root, NULL, new_acls);
  g_hash_table_destroy(new_acls);
  inf_browser_acl_local_account_changed(INF_BROWSER(browser), account, NULL);
  return TRUE;
}
static gboolean
infc_browser_handle_create_acl_account(InfcBrowser* browser,
                                       InfXmlConnection* connection,
                                       xmlNodePtr xml,
                                       GError** error)
{
  InfcBrowserPrivate* priv;
  InfcRequest* request;
  xmlNodePtr child;
  gnutls_datum_t cert_text;
  int res;
  gnutls_x509_crt_t cert;
  gnutls_x509_crt_t* certs;
  guint n_certs;
  GError* local_error;
  int verify_result;
  InfCertificateChain* new_chain;
  InfAclAccount* account;
  InfAclAccount* existing_account;
  priv = INFC_BROWSER_PRIVATE(browser);
  request = infc_request_manager_get_request_by_xml(
    priv-&gt;request_manager,
    "create-acl-account",
    xml,
    NULL
  );
  if(request == NULL)
  {
    g_set_error_literal(
      error,
      inf_directory_error_quark(),
      INF_DIRECTORY_ERROR_UNEXPECTED_MESSAGE,
      _("No certificate request has been made")
    );
    return FALSE;
  }
  cert_text.data = NULL;
  for(child = xml-&gt;children; child != NULL; child = child-&gt;next)
  {
    if(child-&gt;type != XML_ELEMENT_NODE) continue;
    if(strcmp((const char*)child-&gt;name, "certificate") == 0)
    {
      if(child-&gt;children != NULL &amp;&amp; child-&gt;children-&gt;type == XML_TEXT_NODE)
      {
        cert_text.data = (char*)child-&gt;children-&gt;content;
        cert_text.size = strlen(cert_text.data);
      }
    }
  }
  if(cert_text.data == NULL)
  {
    g_set_error_literal(
      error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_NO_SUCH_ATTRIBUTE,
      _("No certificate provided")
    );
    return FALSE;
  }
  n_certs = 10;
  certs = g_malloc(n_certs * sizeof(gnutls_x509_crt_t));
  res = gnutls_x509_crt_list_import(
    certs,
    &amp;n_certs,
    &amp;cert_text,
    GNUTLS_X509_FMT_PEM,
    GNUTLS_X509_CRT_LIST_FAIL_IF_UNSORTED |
    GNUTLS_X509_CRT_LIST_IMPORT_FAIL_IF_EXCEED
  );
  if(res &lt; 0)
  {
    g_free(certs);
    inf_gnutls_set_error(error, res);
    return FALSE;
  }
  else if(res == 0)
  {
    g_set_error_literal(
      error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_NO_SUCH_ATTRIBUTE,
      _("No certificate provided")
    );
    g_free(certs);
    return FALSE;
  }
  certs = g_realloc(certs, n_certs * sizeof(gnutls_x509_crt_t));
  new_chain = inf_certificate_chain_new(certs, n_certs);
#if 0
  g_object_get(G_OBJECT(connection), "remote-certificate", &amp;chain, NULL);
  if(chain == NULL)
  {
    g_set_error_literal(
      error,
      inf_directory_error_quark(),
      INF_DIRECTORY_ERROR_OPERATION_UNSUPPORTED,
      _("Cannot verify the certificate without server certificate")
    );
    gnutls_x509_crt_deinit(cert);
    return FALSE;
  }
  root_cert = inf_certificate_chain_get_root_certificate(chain);
#endif
  res = gnutls_x509_crt_list_verify(
    certs,
    n_certs,
    &amp;certs[n_certs - 1],
    1,
    NULL,
    0,
    GNUTLS_VERIFY_DO_NOT_ALLOW_X509_V1_CA_CRT | GNUTLS_VERIFY_DISABLE_CA_SIGN,
    &amp;verify_result
  );
  if(res != GNUTLS_E_SUCCESS || (verify_result &amp; GNUTLS_CERT_INVALID) != 0)
  {
    if(res != GNUTLS_E_SUCCESS)
    {
      inf_gnutls_set_error(error, res);
    }
    else
    {
      local_error = NULL;
      inf_gnutls_certificate_verification_set_error(
        &amp;local_error,
        verify_result
      );
      g_set_error(
        error,
        inf_directory_error_quark(),
        INF_DIRECTORY_ERROR_INVALID_CERTIFICATE,
        _("Server sent an invalid certificate (%s)"),
        local_error-&gt;message
      );
      g_error_free(local_error);
    }
    inf_certificate_chain_unref(new_chain);
    return FALSE;
  }
  account = inf_acl_account_from_xml(xml, error);
  if(account == NULL)
  {
    inf_certificate_chain_unref(new_chain);
    return FALSE;
  }
  existing_account = g_hash_table_lookup(
    priv-&gt;accounts,
    INF_ACL_ACCOUNT_ID_TO_POINTER(account-&gt;id)
  );
  if(existing_account != NULL)
  {
    inf_acl_account_free(account);
    account = existing_account;
  }
  else
  {
    g_hash_table_insert(
      priv-&gt;accounts,
      INF_ACL_ACCOUNT_ID_TO_POINTER(account-&gt;id),
      account
    );
    inf_browser_acl_account_added(
      INF_BROWSER(browser),
      account,
      INF_REQUEST(request)
    );
  }
  infc_request_manager_finish_request(
    priv-&gt;request_manager,
    request,
    inf_request_result_make_create_acl_account(
      INF_BROWSER(browser),
      account,
      new_chain
    )
  );
  inf_certificate_chain_unref(new_chain);
  return TRUE;
}
static gboolean
infc_browser_handle_remove_acl_account(InfcBrowser* browser,
                                       InfXmlConnection* connection,
                                       xmlNodePtr xml,
                                       GError** error)
{
  InfcBrowserPrivate* priv;
  InfcRequest* request;
  xmlChar* account_id;
  InfAclAccountId account;
  InfAclAccount* acc;
  InfAclAccount report_acc;
  InfAclAccountId default_id;
  GSList* item;
  InfcBrowserSubreq* subreq;
  priv = INFC_BROWSER_PRIVATE(browser);
  request = infc_request_manager_get_request_by_xml(
    priv-&gt;request_manager,
    "remove-acl-account",
    xml,
    NULL
  );
  account_id = inf_xml_util_get_attribute_required(xml, "id", error);
  if(account_id == NULL) return FALSE;
  account = inf_acl_account_id_from_string((const gchar*)account_id);
  if(account == 0)
  {
    xmlFree(account_id);
    return TRUE;
  }
  xmlFree(account_id);
  default_id = inf_acl_account_id_from_string("default");
  if(account == default_id)
  {
    g_set_error_literal(
      error,
      inf_directory_error_quark(),
      INF_DIRECTORY_ERROR_NO_SUCH_ACCOUNT,
      _("The default account cannot be removed")
    );
    return FALSE;
  }
  if(priv-&gt;local_account-&gt;id == account)
  {
    priv-&gt;local_account = g_hash_table_lookup(
      priv-&gt;accounts,
      INF_ACL_ACCOUNT_ID_TO_POINTER(default_id)
    );
    g_assert(priv-&gt;local_account != NULL);
    infc_browser_enforce_acl(browser, priv-&gt;root, NULL, NULL);
    inf_browser_acl_local_account_changed(
      INF_BROWSER(browser),
      priv-&gt;local_account,
      NULL
    );
  }
  infc_browser_remove_account_from_sheets(browser, priv-&gt;root, account);
  for(item = priv-&gt;subscription_requests; item != NULL; item = item-&gt;next)
  {
    subreq = (InfcBrowserSubreq*)item-&gt;data;
    switch(subreq-&gt;type)
    {
    case INFC_BROWSER_SUBREQ_CHAT:
    case INFC_BROWSER_SUBREQ_SESSION:
      break;
    case INFC_BROWSER_SUBREQ_ADD_NODE:
      infc_browser_remove_acl_sheet_from_sheet_set(
        subreq-&gt;shared.add_node.sheet_set,
        account
      );
      break;
    case INFC_BROWSER_SUBREQ_SYNC_IN:
      infc_browser_remove_acl_sheet_from_sheet_set(
        subreq-&gt;shared.sync_in.sheet_set,
        account
      );
      break;
    }
  }
  acc = g_hash_table_lookup(
    priv-&gt;accounts,
    INF_ACL_ACCOUNT_ID_TO_POINTER(account)
  );
  if(acc != NULL)
  {
    g_hash_table_steal(
      priv-&gt;accounts,
      INF_ACL_ACCOUNT_ID_TO_POINTER(account)
    );
  }
  else
  {
    report_acc.id = account;
    report_acc.name = NULL;     acc = &amp;report_acc;
  }
  if(request != NULL)
  {
    infc_request_manager_finish_request(
      priv-&gt;request_manager,
      request,
      inf_request_result_make_remove_acl_account(
        INF_BROWSER(browser),
        acc
      )
    );
  }
  inf_browser_acl_account_removed(INF_BROWSER(browser), acc, NULL);
  if(acc != &amp;report_acc)
    inf_acl_account_free(acc);
  return TRUE;
}
static gboolean
infc_browser_handle_set_acl(InfcBrowser* browser,
                            InfXmlConnection* connection,
                            xmlNodePtr xml,
                            GError** error)
{
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  InfAclSheetSet* sheet_set;
  GError* local_error;
  InfcRequest* request;
  gchar* request_type;
  InfBrowserIter iter;
  InfAclAccountId default_id;
  InfAclSheet* default_sheet;
  InfAclMask default_mask;
  priv = INFC_BROWSER_PRIVATE(browser);
  node = infc_browser_get_node_from_xml(browser, xml, "id", error);
  if(node == NULL) return FALSE;
  local_error = NULL;
  sheet_set = inf_acl_sheet_set_from_xml(xml, &amp;local_error);
  if(local_error != NULL)
  {
    g_propagate_error(error, local_error);
    return FALSE;
  }
  request = infc_request_manager_get_request_by_xml(
    priv-&gt;request_manager,
    NULL,
    xml,
    &amp;local_error
  );
  if(local_error != NULL)
  {
    g_propagate_error(error, local_error);
    return FALSE;
  }
  if(request != NULL)
  {
    g_object_get(G_OBJECT(request), "type", &amp;request_type, NULL);
    if(strcmp(request_type, "query-acl") == 0)
    {
      g_assert(node-&gt;acl_queried == FALSE);
      node-&gt;acl_queried = TRUE;
    }
    else if(strcmp(request_type, "set-acl") != 0)
    {
      g_set_error(
        error,
        inf_request_error_quark(),
        INF_REQUEST_ERROR_INVALID_SEQ,
        _("The request contains a sequence number referring to a request of "
          "type '%s', but a request of either 'query-acl' or 'set-acl' "
          "was expected."),
        request_type
      );
      g_free(request_type);
      return FALSE;
    }
  }
  iter.node_id = node-&gt;id;
  iter.node = node;
  if(sheet_set != NULL)
  {
    if(sheet_set-&gt;n_sheets &gt; 0)
    {
      if(node == priv-&gt;root)
      {
        default_id = inf_acl_account_id_from_string("default");
        default_sheet =
          inf_acl_sheet_set_find_sheet(sheet_set, default_id);
        if(default_sheet != NULL)
        {
          default_mask = default_sheet-&gt;mask;
          inf_acl_mask_and(
            &amp;default_sheet-&gt;perms,
            &amp;default_sheet-&gt;mask,
            &amp;default_sheet-&gt;perms
          );
          inf_acl_mask_neg(&amp;default_mask, &amp;default_mask);
          inf_acl_mask_and(
            &amp;default_mask,
            &amp;INF_ACL_MASK_DEFAULT,
            &amp;default_mask
          );
          inf_acl_mask_or(
            &amp;default_sheet-&gt;perms,
            &amp;default_mask,
            &amp;default_sheet-&gt;perms
          );
          default_sheet-&gt;mask = INF_ACL_MASK_ALL;
        }
      }
      node-&gt;acl = inf_acl_sheet_set_merge_sheets(node-&gt;acl, sheet_set);
      infc_browser_enforce_acl(browser, node, request, NULL);
      inf_browser_acl_changed(
        INF_BROWSER(browser),
        &amp;iter,
        sheet_set,
        INF_REQUEST(request)
      );
    }
    inf_acl_sheet_set_free(sheet_set);
  }
  if(request != NULL)
  {
    g_object_get(G_OBJECT(request), "type", &amp;request_type, NULL);
    if(strcmp(request_type, "query-acl") == 0)
    {
      infc_request_manager_finish_request(
        priv-&gt;request_manager,
        request,
        inf_request_result_make_query_acl(
          INF_BROWSER(browser),
          &amp;iter,
          node-&gt;acl
        )
      );
    }
    else
    {
      infc_request_manager_finish_request(
        priv-&gt;request_manager,
        request,
        inf_request_result_make_set_acl(INF_BROWSER(browser), &amp;iter)
      );
    }
    g_free(request_type);
  }
  return TRUE;
}
static gboolean
infc_browser_handle_request_failed(InfcBrowser* browser,
                                   InfXmlConnection* connection,
                                   xmlNodePtr xml,
                                   GError** error)
{
  InfcBrowserPrivate* priv;
  InfcBrowserClass* browserc_class;
  InfcRequest* request;
  xmlChar* domain;
  gboolean has_code;
  guint code;
  GError* req_error;
  priv = INFC_BROWSER_PRIVATE(browser);
  browserc_class = INFC_BROWSER_GET_CLASS(browser);
  request = infc_request_manager_get_request_by_xml_required(
    priv-&gt;request_manager,
    NULL,
    xml,
    error
  );
  if(request == NULL) return FALSE;
  has_code = inf_xml_util_get_attribute_uint_required(
    xml,
    "code",
    &amp;code,
    error
  );
  if(has_code == FALSE) return FALSE;
  domain = inf_xml_util_get_attribute_required(xml, "domain", error);
  if(domain == NULL) return FALSE;
  req_error = NULL;
  if(g_quark_from_string((gchar*)domain) == inf_directory_error_quark())
  {
    g_set_error_literal(
      &amp;req_error,
      inf_directory_error_quark(),
      code,
      inf_directory_strerror(code)
    );
  }
  else if(g_quark_from_string((gchar*)domain) == inf_request_error_quark())
  {
    g_set_error_literal(
      &amp;req_error,
      inf_request_error_quark(),
      code,
      inf_request_strerror(code)
    );
  }
  else
  {
    g_set_error(
      &amp;req_error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_UNKNOWN_DOMAIN,
      _("Error comes from unknown error domain '%s' (code %u)"),
      (const gchar*)domain,
      code
    );
  }
  xmlFree(domain);
  infc_request_manager_fail_request(
    priv-&gt;request_manager,
    request,
    req_error
  );
  g_error_free(req_error);
  return TRUE;
}
static InfCommunicationScope
infc_browser_communication_object_received(InfCommunicationObject* object,
                                           InfXmlConnection* connection,
                                           xmlNodePtr node)
{
  InfcBrowser* browser;
  InfcBrowserPrivate* priv;
  GError* local_error;
  GError* seq_error;
  InfcRequest* request;
  browser = INFC_BROWSER(object);
  priv = INFC_BROWSER_PRIVATE(browser);
  local_error = NULL;
  if(priv-&gt;status == INF_BROWSER_OPENING &amp;&amp;
     strcmp((const gchar*)node-&gt;name, "welcome") == 0)
  {
    if(priv-&gt;welcome_timeout != NULL)
    {
      inf_io_remove_timeout(priv-&gt;io, priv-&gt;welcome_timeout);
      priv-&gt;welcome_timeout = NULL;
    }
    if(!infc_browser_handle_welcome(browser, connection, node, &amp;local_error))
    {
      inf_browser_error(INF_BROWSER(browser), local_error);
      g_error_free(local_error);
      local_error = NULL;
      priv-&gt;status = INF_BROWSER_CLOSED;
      g_object_notify(G_OBJECT(browser), "status");
    }
  }
  else if(strcmp((const gchar*)node-&gt;name, "request-failed") == 0)
  {
    infc_browser_handle_request_failed(
      browser,
      connection,
      node,
      &amp;local_error
    );
  }
  else if(strcmp((const gchar*)node-&gt;name, "explore-begin") == 0)
  {
    infc_browser_handle_explore_begin(
      browser,
      connection,
      node,
      &amp;local_error
    );
  }
  else if(strcmp((const gchar*)node-&gt;name, "explore-end") == 0)
  {
    infc_browser_handle_explore_end(
      browser,
      connection,
      node,
      &amp;local_error
    );
  }
  else if(strcmp((const gchar*)node-&gt;name, "add-node") == 0)
  {
    infc_browser_handle_add_node(
      browser,
      connection,
      node,
      &amp;local_error
    );
  }
  else if(strcmp((const gchar*)node-&gt;name, "sync-in") == 0)
  {
    infc_browser_handle_sync_in(
      browser,
      connection,
      node,
      &amp;local_error
    );
  }
  else if(strcmp((const gchar*)node-&gt;name, "remove-node") == 0)
  {
    infc_browser_handle_remove_node(
      browser,
      connection,
      node,
      &amp;local_error
    );
  }
  else if(strcmp((const gchar*)node-&gt;name, "subscribe-session") == 0)
  {
    infc_browser_handle_subscribe_session(
      browser,
      connection,
      node,
      &amp;local_error
    );
  }
  else if(strcmp((const gchar*)node-&gt;name, "subscribe-chat") == 0)
  {
    infc_browser_handle_subscribe_chat(
      browser,
      connection,
      node,
      &amp;local_error
    );
  }
  else if(strcmp((const gchar*)node-&gt;name, "save-session-in-progress") == 0)
  {
    infc_browser_handle_save_session_in_progress(
      browser,
      connection,
      node,
      &amp;local_error
    );
  }
  else if(strcmp((const gchar*)node-&gt;name, "saved-session") == 0)
  {
    infc_browser_handle_saved_session(
      browser,
      connection,
      node,
      &amp;local_error
    );
  }
  else if(strcmp((const gchar*)node-&gt;name, "acl-account-list-begin") == 0)
  {
    infc_browser_handle_acl_account_list_begin(
      browser,
      connection,
      node,
      &amp;local_error
    );
  }
  else if(strcmp((const gchar*)node-&gt;name, "acl-account-list-end") == 0)
  {
    infc_browser_handle_acl_account_list_end(
      browser,
      connection,
      node,
      &amp;local_error
    );
  }
  else if(strcmp((const gchar*)node-&gt;name, "add-acl-account") == 0)
  {
    infc_browser_handle_add_acl_account(
      browser,
      connection,
      node,
      &amp;local_error
    );
  }
  else if(strcmp((const gchar*)node-&gt;name, "lookup-acl-accounts") == 0)
  {
    infc_browser_handle_lookup_acl_accounts(
      browser,
      connection,
      node,
      &amp;local_error
    );
  }
  else if(strcmp((const gchar*)node-&gt;name, "change-acl-account") == 0)
  {
    infc_browser_handle_change_acl_account(
      browser,
      connection,
      node,
      &amp;local_error
    );
  }
  else if(strcmp((const gchar*)node-&gt;name, "create-acl-account") == 0)
  {
    infc_browser_handle_create_acl_account(
      browser,
      connection,
      node,
      &amp;local_error
    );
  }
  else if(strcmp((const gchar*)node-&gt;name, "remove-acl-account") == 0)
  {
    infc_browser_handle_remove_acl_account(
      browser,
      connection,
      node,
      &amp;local_error
    );
  }
  else if(strcmp((const gchar*)node-&gt;name, "set-acl") == 0)
  {
    infc_browser_handle_set_acl(
      browser,
      connection,
      node,
      &amp;local_error
    );
  }
  else
  {
    g_set_error(
      &amp;local_error,
      inf_directory_error_quark(),
      INF_DIRECTORY_ERROR_UNEXPECTED_MESSAGE,
      _("Received unexpected network message \"%s\""),
      (const gchar*)node-&gt;name
    );
  }
  if(local_error != NULL)
  {
    request = infc_request_manager_get_request_by_xml(
      priv-&gt;request_manager,
      NULL,
      node,
      NULL
    );
    if(request != NULL)
    {
      seq_error = NULL;
      g_set_error(
        &amp;seq_error,
        inf_request_error_quark(),
        INF_REQUEST_ERROR_REPLY_UNPROCESSED,
        _("Server reply could not be processed: %s"),
        local_error-&gt;message
      );
      infc_request_manager_fail_request(
        priv-&gt;request_manager,
        request,
        seq_error
      );
      g_error_free(seq_error);
    }
    inf_browser_error(INF_BROWSER(browser), local_error);
    g_error_free(local_error);
  }
  return INF_COMMUNICATION_SCOPE_PTP;
}
static void
infc_browser_communication_object_sent(InfCommunicationObject* object,
                                       InfXmlConnection* connection,
                                       xmlNodePtr xml)
{
  InfcBrowser* browser;
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  gboolean has_id;
  guint node_id;
  GSList* item;
  InfCommunicationJoinedGroup* sync_group;
  InfcBrowserSubreq* subreq;
  InfChatBuffer* buffer;
  InfChatSession* session;
  InfcSessionProxy* proxy;
  InfBrowserIter parent_iter;
  InfBrowserIter iter;
  if(strcmp((const char*)xml-&gt;name, "subscribe-ack") == 0)
  {
    browser = INFC_BROWSER(object);
    priv = INFC_BROWSER_PRIVATE(browser);
    has_id = inf_xml_util_get_attribute_uint(xml, "id", &amp;node_id, NULL);
    for(item = priv-&gt;subscription_requests; item != NULL; item = item-&gt;next)
    {
      subreq = (InfcBrowserSubreq*)item-&gt;data;
      if( (has_id  &amp;&amp; subreq-&gt;node_id == node_id) ||
          (!has_id &amp;&amp; subreq-&gt;node_id == 0))
      {
        break;
      }
    }
    if(item == NULL) return;
    infc_browser_unlink_subreq(browser, subreq);
    switch(subreq-&gt;type)
    {
    case INFC_BROWSER_SUBREQ_CHAT:
      g_assert(has_id == FALSE);
      g_assert(priv-&gt;chat_session == NULL);
      buffer = inf_chat_buffer_new(256);
      session = inf_chat_session_new(
        priv-&gt;communication_manager,
        buffer,
        INF_SESSION_SYNCHRONIZING,
        INF_COMMUNICATION_GROUP(subreq-&gt;shared.chat.subscription_group),
        connection
      );
      g_object_unref(buffer);
      proxy = g_object_new(INFC_TYPE_SESSION_PROXY, "session", session, NULL);
      inf_communication_group_set_target(
        INF_COMMUNICATION_GROUP(subreq-&gt;shared.chat.subscription_group),
        INF_COMMUNICATION_OBJECT(proxy)
      );
      infc_session_proxy_set_connection(
        proxy,
        subreq-&gt;shared.chat.subscription_group,
        connection,
        priv-&gt;seq_id
      );
      g_object_unref(session);
      inf_browser_subscribe_session(
        INF_BROWSER(browser),
        NULL,
        INF_SESSION_PROXY(proxy),
        INF_REQUEST(subreq-&gt;shared.chat.request)
      );
      if(subreq-&gt;shared.chat.request != NULL)
      {
        infc_request_manager_finish_request(
          priv-&gt;request_manager,
          subreq-&gt;shared.chat.request,
          inf_request_result_make_subscribe_chat(
            INF_BROWSER(browser),
            INF_SESSION_PROXY(proxy)
          )
        );
      }
      g_object_unref(proxy);
      break;
    case INFC_BROWSER_SUBREQ_SESSION:
      g_assert(has_id == TRUE);
      if(subreq-&gt;shared.session.node != NULL)
      {
        g_assert(subreq-&gt;shared.session.node-&gt;id == node_id);
        infc_browser_subscribe_session(
          browser,
          subreq-&gt;shared.session.node,
          subreq-&gt;shared.session.request,
          subreq-&gt;shared.session.subscription_group,
          connection,
          TRUE
        );
        if(subreq-&gt;shared.session.request != NULL)
        {
          iter.node = subreq-&gt;shared.session.node;
          iter.node_id = node_id;
          g_assert(
            subreq-&gt;shared.session.node-&gt;type == INFC_BROWSER_NODE_NOTE_KNOWN
          );
          proxy = subreq-&gt;shared.session.node-&gt;shared.known.session;
          g_assert(proxy != NULL);
          infc_request_manager_finish_request(
            priv-&gt;request_manager,
            subreq-&gt;shared.session.request,
            inf_request_result_make_subscribe_session(
              INF_BROWSER(browser),
              &amp;iter,
              INF_SESSION_PROXY(proxy)
            )
          );
        }
      }
      break;
    case INFC_BROWSER_SUBREQ_ADD_NODE:
      g_assert(has_id == TRUE);
      if(subreq-&gt;shared.add_node.parent != NULL)
      {
        g_assert(
          g_hash_table_lookup(priv-&gt;nodes, GUINT_TO_POINTER(node_id)) == NULL
        );
        g_assert(infc_browser_find_subreq(browser, node_id) == NULL);
        node = infc_browser_node_add_note(
          browser,
          subreq-&gt;shared.add_node.parent,
          subreq-&gt;shared.add_node.request,
          node_id,
          subreq-&gt;shared.add_node.name,
          subreq-&gt;shared.add_node.plugin-&gt;note_type,
          subreq-&gt;shared.add_node.sheet_set,
          NULL
        );
        g_assert(node-&gt;type == INFC_BROWSER_NODE_NOTE_KNOWN);
        infc_browser_subscribe_session(
          browser,
          node,
          subreq-&gt;shared.add_node.request,
          subreq-&gt;shared.add_node.subscription_group,
          connection,
          FALSE
        );
        if(subreq-&gt;shared.add_node.request != NULL)
        {
          parent_iter.node_id = subreq-&gt;shared.sync_in.parent-&gt;id;
          parent_iter.node = subreq-&gt;shared.sync_in.parent;
          iter.node = node;
          iter.node_id = node_id;
          infc_request_manager_finish_request(
            priv-&gt;request_manager,
            subreq-&gt;shared.add_node.request,
            inf_request_result_make_add_node(
              INF_BROWSER(browser),
              &amp;parent_iter,
              &amp;iter
            )
          );
        }
      }
      break;
    case INFC_BROWSER_SUBREQ_SYNC_IN:
      g_assert(has_id == TRUE);
      if(subreq-&gt;shared.sync_in.parent != NULL)
      {
        g_assert(
          g_hash_table_lookup(priv-&gt;nodes, GUINT_TO_POINTER(node_id)) == NULL
        );
        g_assert(infc_browser_find_subreq(browser, node_id) == NULL);
        proxy = g_object_new(
          INFC_TYPE_SESSION_PROXY,
          "session", subreq-&gt;shared.sync_in.session,
          NULL
        );
        sync_group = subreq-&gt;shared.sync_in.synchronization_group;
        inf_communication_group_set_target(
          INF_COMMUNICATION_GROUP(sync_group),
          INF_COMMUNICATION_OBJECT(proxy)
        );
        inf_session_synchronize_to(
          subreq-&gt;shared.sync_in.session,
          INF_COMMUNICATION_GROUP(sync_group),
          connection
        );
        node = infc_browser_node_add_note(
          browser,
          subreq-&gt;shared.sync_in.parent,
          subreq-&gt;shared.sync_in.request,
          node_id,
          subreq-&gt;shared.sync_in.name,
          subreq-&gt;shared.sync_in.plugin-&gt;note_type,
          subreq-&gt;shared.sync_in.sheet_set,
          proxy
        );
        g_assert(node-&gt;type == INFC_BROWSER_NODE_NOTE_KNOWN);
        parent_iter.node_id = subreq-&gt;shared.sync_in.parent-&gt;id;
        parent_iter.node = subreq-&gt;shared.sync_in.parent;
        iter.node_id = node-&gt;id;
        iter.node = node;
        if(subreq-&gt;shared.sync_in.subscription_group != NULL)
        {
          g_assert(
            inf_session_get_subscription_group(
              subreq-&gt;shared.sync_in.session
            ) == NULL
          );
          if(subreq-&gt;shared.sync_in.subscription_group != sync_group)
          {
            inf_communication_group_set_target(
              INF_COMMUNICATION_GROUP(
                subreq-&gt;shared.sync_in.subscription_group
              ),
              INF_COMMUNICATION_OBJECT(proxy)
            );
          }
          infc_session_proxy_set_connection(
            proxy,
            subreq-&gt;shared.sync_in.subscription_group,
            connection,
            priv-&gt;seq_id
          );
          inf_browser_subscribe_session(
            INF_BROWSER(browser),
            &amp;iter,
            INF_SESSION_PROXY(proxy),
            INF_REQUEST(subreq-&gt;shared.sync_in.request)
          );
        }
        g_object_unref(proxy);
        g_assert(subreq-&gt;shared.sync_in.request != NULL);
        infc_request_manager_finish_request(
          priv-&gt;request_manager,
          subreq-&gt;shared.sync_in.request,
          inf_request_result_make_add_node(
            INF_BROWSER(browser),
            &amp;parent_iter,
            &amp;iter
          )
        );
      }
      break;
    default:
      g_assert_not_reached();
      break;
    }
    infc_browser_free_subreq(subreq);
  }
}
static void
infc_browser_browser_subscribe_session(InfBrowser* browser,
                                       const InfBrowserIter* iter,
                                       InfSessionProxy* proxy,
                                       InfRequest* request)
{
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  InfSession* session;
  priv = INFC_BROWSER_PRIVATE(browser);
  g_assert(INFC_IS_SESSION_PROXY(proxy));
  g_object_get(G_OBJECT(proxy), "session", &amp;session, NULL);
  if(iter != NULL)
  {
    node = (InfcBrowserNode*)iter-&gt;node;
    g_assert(
      g_hash_table_lookup(priv-&gt;nodes, GUINT_TO_POINTER(iter-&gt;node_id)) ==
      node
    );
    g_assert(node-&gt;type == INFC_BROWSER_NODE_NOTE_KNOWN);
    g_assert(node-&gt;shared.known.session == NULL);
    node-&gt;shared.known.session = INFC_SESSION_PROXY(proxy);
    g_object_ref(proxy);
    g_object_set_qdata_full(
      G_OBJECT(session),
      infc_browser_session_proxy_quark,
      inf_browser_iter_copy(iter),
      (GDestroyNotify)inf_browser_iter_free
    );
  }
  else
  {
    g_assert(priv-&gt;chat_session == NULL);
    g_object_ref(proxy);
    priv-&gt;chat_session = INFC_SESSION_PROXY(proxy);
    g_object_notify(G_OBJECT(browser), "chat-session");
  }
  g_signal_connect(
    session,
    "notify::subscription-group",
    G_CALLBACK(infc_browser_session_notify_subscription_group_cb),
    browser
  );
  g_object_unref(session);
}
static gboolean
infc_browser_browser_get_root(InfBrowser* browser,
                              InfBrowserIter* iter)
{
  InfcBrowserPrivate* priv;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), FALSE);
  g_return_val_if_fail(iter != NULL, FALSE);
  priv = INFC_BROWSER_PRIVATE(browser);
  g_return_val_if_fail(priv-&gt;status == INF_BROWSER_OPEN, FALSE);
  g_assert(priv-&gt;root != NULL);
  iter-&gt;node_id = priv-&gt;root-&gt;id;
  iter-&gt;node = priv-&gt;root;
  return TRUE;
}
static gboolean
infc_browser_browser_get_next(InfBrowser* browser,
                              InfBrowserIter* iter)
{
  InfcBrowserNode* node;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), FALSE);
  infc_browser_return_val_if_iter_fail(browser, iter, FALSE);
  node = (InfcBrowserNode*)iter-&gt;node;
  if(node-&gt;next != NULL)
  {
    iter-&gt;node_id = node-&gt;next-&gt;id;
    iter-&gt;node = node-&gt;next;
    return TRUE;
  }
  else
  {
    return FALSE;
  }
}
static gboolean
infc_browser_browser_get_prev(InfBrowser* browser,
                              InfBrowserIter* iter)
{
  InfcBrowserNode* node;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), FALSE);
  infc_browser_return_val_if_iter_fail(browser, iter, FALSE);
  node = (InfcBrowserNode*)iter-&gt;node;
  if(node-&gt;prev != NULL)
  {
    iter-&gt;node_id = node-&gt;prev-&gt;id;
    iter-&gt;node = node-&gt;prev;
    return TRUE;
  }
  else
  {
    return FALSE;
  }
}
static gboolean
infc_browser_browser_get_parent(InfBrowser* browser,
                                InfBrowserIter* iter)
{
  InfcBrowserNode* node;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), FALSE);
  infc_browser_return_val_if_iter_fail(browser, iter, FALSE);
  node = (InfcBrowserNode*)iter-&gt;node;
  if(node-&gt;parent != NULL)
  {
    iter-&gt;node_id = node-&gt;parent-&gt;id;
    iter-&gt;node = node-&gt;parent;
    return TRUE;
  }
  else
  {
    return FALSE;
  }
}
static gboolean
infc_browser_browser_get_child(InfBrowser* browser,
                               InfBrowserIter* iter)
{
  InfcBrowserNode* node;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), FALSE);
  infc_browser_return_val_if_iter_fail(browser, iter, FALSE);
  node = (InfcBrowserNode*)iter-&gt;node;
  g_return_val_if_fail(node-&gt;shared.subdir.explored == TRUE, FALSE);
  if(node-&gt;shared.subdir.child != NULL)
  {
    iter-&gt;node_id = node-&gt;shared.subdir.child-&gt;id;
    iter-&gt;node = node-&gt;shared.subdir.child;
    return TRUE;
  }
  else
  {
    return FALSE;
  }
}
static InfRequest*
infc_browser_browser_explore(InfBrowser* browser,
                             const InfBrowserIter* iter,
                             InfRequestFunc func,
                             gpointer user_data)
{
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  InfcRequest* request;
  xmlNodePtr xml;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
  infc_browser_return_val_if_iter_fail(browser, iter, NULL);
  node = (InfcBrowserNode*)iter-&gt;node;
  infc_browser_return_val_if_subdir_fail(node, NULL);
  g_return_val_if_fail(node-&gt;shared.subdir.explored == FALSE, NULL);
  g_return_val_if_fail(
    inf_browser_get_pending_request(browser, iter, "explore-node") == NULL,
    NULL
  );
  priv = INFC_BROWSER_PRIVATE(browser);
  g_return_val_if_fail(priv-&gt;connection != NULL, NULL);
  g_return_val_if_fail(priv-&gt;status == INF_BROWSER_OPEN, NULL);
  request = infc_request_manager_add_request(
    priv-&gt;request_manager,
    INFC_TYPE_PROGRESS_REQUEST,
    "explore-node",
    G_CALLBACK(func),
    user_data,
    "node_id", node-&gt;id,
    NULL
  );
  inf_browser_begin_request(browser, iter, INF_REQUEST(request));
  xml = infc_browser_request_to_xml(request);
  inf_xml_util_set_attribute_uint(xml, "id", node-&gt;id);
  inf_communication_group_send_message(
    INF_COMMUNICATION_GROUP(priv-&gt;group),
    priv-&gt;connection,
    xml
  );
  return INF_REQUEST(request);
}
static gboolean
infc_browser_browser_get_explored(InfBrowser* browser,
                                  const InfBrowserIter* iter)
{
  InfcBrowserNode* node;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), FALSE);
  infc_browser_return_val_if_iter_fail(browser, iter, FALSE);
  node = (InfcBrowserNode*)iter-&gt;node;
  infc_browser_return_val_if_subdir_fail(node, FALSE);
  return node-&gt;shared.subdir.explored;
}
static gboolean
infc_browser_browser_is_subdirectory(InfBrowser* browser,
                                     const InfBrowserIter* iter)
{
  InfcBrowserNode* node;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), FALSE);
  infc_browser_return_val_if_iter_fail(browser, iter, FALSE);
  node = (InfcBrowserNode*)iter-&gt;node;
  if(node-&gt;type == INFC_BROWSER_NODE_SUBDIRECTORY)
    return TRUE;
  return FALSE;
}
static InfRequest*
infc_browser_browser_add_note(InfBrowser* infbrowser,
                              const InfBrowserIter* iter,
                              const char* name,
                              const char* type,
                              const InfAclSheetSet* sheet_set,
                              InfSession* session,
                              gboolean initial_subscribe,
                              InfRequestFunc func,
                              gpointer user_data)
{
  InfcBrowser* browser;
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  const InfcNotePlugin* plugin;
  InfcRequest* request;
  xmlNodePtr xml;
  g_return_val_if_fail(INFC_IS_BROWSER(infbrowser), NULL);
  browser = INFC_BROWSER(infbrowser);
  infc_browser_return_val_if_iter_fail(browser, iter, NULL);
  node = (InfcBrowserNode*)iter-&gt;node;
  infc_browser_return_val_if_subdir_fail(node, NULL);
  g_return_val_if_fail(node-&gt;shared.subdir.explored == TRUE, NULL);
  priv = INFC_BROWSER_PRIVATE(browser);
  g_return_val_if_fail(priv-&gt;connection != NULL, NULL);
  g_return_val_if_fail(priv-&gt;status == INF_BROWSER_OPEN, NULL);
  plugin = infc_browser_lookup_plugin(browser, type);
  g_return_val_if_fail(plugin != NULL, NULL);
  request = infc_request_manager_add_request(
    priv-&gt;request_manager,
    INFC_TYPE_REQUEST,
    "add-node",
    G_CALLBACK(func),
    user_data,
    "node-id", iter-&gt;node_id,
    NULL
  );
  if(session != NULL)
  {
    g_object_ref(session);
    g_object_set_qdata_full(
      G_OBJECT(request),
      infc_browser_sync_in_session_quark,
      session,
      g_object_unref
    );
    g_object_set_qdata(
      G_OBJECT(request),
      infc_browser_sync_in_plugin_quark,
      *(gpointer*)(gpointer)&amp;plugin
    );
  }
  inf_browser_begin_request(INF_BROWSER(browser), iter, INF_REQUEST(request));
  xml = infc_browser_request_to_xml(request);
  inf_xml_util_set_attribute_uint(xml, "parent", node-&gt;id);
  inf_xml_util_set_attribute(xml, "type", type);
  inf_xml_util_set_attribute(xml, "name", name);
  if(sheet_set != NULL)
    inf_acl_sheet_set_to_xml(sheet_set, xml);
  if(initial_subscribe != FALSE)
    xmlNewChild(xml, NULL, (const xmlChar*)"subscribe", NULL);
  if(session != NULL)
    xmlNewChild(xml, NULL, (const xmlChar*)"sync-in", NULL);
  inf_communication_group_send_message(
    INF_COMMUNICATION_GROUP(priv-&gt;group),
    priv-&gt;connection,
    xml
  );
  return INF_REQUEST(request);
}
static InfRequest*
infc_browser_browser_add_subdirectory(InfBrowser* infbrowser,
                                      const InfBrowserIter* iter,
                                      const char* name,
                                      const InfAclSheetSet* sheet_set,
                                      InfRequestFunc func,
                                      gpointer user_data)
{
  InfcBrowser* browser;
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  InfcRequest* request;
  xmlNodePtr xml;
  g_return_val_if_fail(INFC_IS_BROWSER(infbrowser), NULL);
  browser = INFC_BROWSER(infbrowser);
  infc_browser_return_val_if_iter_fail(browser, iter, NULL);
  node = (InfcBrowserNode*)iter-&gt;node;
  infc_browser_return_val_if_subdir_fail(node, NULL);
  g_return_val_if_fail(node-&gt;shared.subdir.explored == TRUE, NULL);
  priv = INFC_BROWSER_PRIVATE(browser);
  g_return_val_if_fail(priv-&gt;connection != NULL, NULL);
  g_return_val_if_fail(priv-&gt;status == INF_BROWSER_OPEN, NULL);
  request = infc_request_manager_add_request(
    priv-&gt;request_manager,
    INFC_TYPE_REQUEST,
    "add-node",
    G_CALLBACK(func), user_data,
    "node-id", iter-&gt;node_id,
    NULL
  );
  inf_browser_begin_request(INF_BROWSER(browser), iter, INF_REQUEST(request));
  xml = infc_browser_request_to_xml(request);
  inf_xml_util_set_attribute_uint(xml, "parent", node-&gt;id);
  inf_xml_util_set_attribute(xml, "type", "InfSubdirectory");
  inf_xml_util_set_attribute(xml, "name", name);
  if(sheet_set != NULL)
    inf_acl_sheet_set_to_xml(sheet_set, xml);
  inf_communication_group_send_message(
    INF_COMMUNICATION_GROUP(priv-&gt;group),
    priv-&gt;connection,
    xml
  );
  return INF_REQUEST(request);
}
static InfRequest*
infc_browser_browser_remove_node(InfBrowser* infbrowser,
                                 const InfBrowserIter* iter,
                                 InfRequestFunc func,
                                 gpointer user_data)
{
  InfcBrowser* browser;
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  InfcRequest* request;
  xmlNodePtr xml;
  g_return_val_if_fail(INFC_IS_BROWSER(infbrowser), NULL);
  browser = INFC_BROWSER(infbrowser);
  infc_browser_return_val_if_iter_fail(browser, iter, NULL);
  priv = INFC_BROWSER_PRIVATE(browser);
  node = (InfcBrowserNode*)iter-&gt;node;
  g_return_val_if_fail(node-&gt;parent != NULL, NULL);
  g_return_val_if_fail(priv-&gt;connection != NULL, NULL);
  g_return_val_if_fail(priv-&gt;status == INF_BROWSER_OPEN, NULL);
  request = infc_request_manager_add_request(
    priv-&gt;request_manager,
    INFC_TYPE_REQUEST,
    "remove-node",
    G_CALLBACK(func),
    user_data,
    "node-id", iter-&gt;node_id,
    NULL
  );
  inf_browser_begin_request(INF_BROWSER(browser), iter, INF_REQUEST(request));
  xml = infc_browser_request_to_xml(request);
  inf_xml_util_set_attribute_uint(xml, "id", node-&gt;id);
  inf_communication_group_send_message(
    INF_COMMUNICATION_GROUP(priv-&gt;group),
    priv-&gt;connection,
    xml
  );
  return INF_REQUEST(request);
}
static const gchar*
infc_browser_browser_get_node_name(InfBrowser* browser,
                                   const InfBrowserIter* iter)
{
  InfcBrowserNode* node;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
  infc_browser_return_val_if_iter_fail(browser, iter, NULL);
  node = (InfcBrowserNode*)iter-&gt;node;
  return node-&gt;name;
}
static const gchar*
infc_browser_browser_get_node_type(InfBrowser* infbrowser,
                                   const InfBrowserIter* iter)
{
  InfcBrowser* browser;
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  g_return_val_if_fail(INFC_IS_BROWSER(infbrowser), NULL);
  browser = INFC_BROWSER(infbrowser);
  infc_browser_return_val_if_iter_fail(browser, iter, NULL);
  priv = INFC_BROWSER_PRIVATE(browser);
  node = (InfcBrowserNode*)iter-&gt;node;
  switch(node-&gt;type)
  {
  case INFC_BROWSER_NODE_SUBDIRECTORY:
    g_return_val_if_reached(NULL);
    return NULL;
  case INFC_BROWSER_NODE_NOTE_KNOWN:
    return node-&gt;shared.known.plugin-&gt;note_type;
  case INFC_BROWSER_NODE_NOTE_UNKNOWN:
    return node-&gt;shared.unknown.type;
  default:
    g_assert_not_reached();
    return NULL;
  }
}
static InfRequest*
infc_browser_browser_subscribe(InfBrowser* browser,
                               const InfBrowserIter* iter,
                               InfRequestFunc func,
                               gpointer user_data)
{
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  InfcRequest* request;
  xmlNodePtr xml;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
  infc_browser_return_val_if_iter_fail(INFC_BROWSER(browser), iter, NULL);
  priv = INFC_BROWSER_PRIVATE(browser);
  node = (InfcBrowserNode*)iter-&gt;node;
  g_return_val_if_fail(priv-&gt;connection != NULL, NULL);
  g_return_val_if_fail(priv-&gt;status == INF_BROWSER_OPEN, NULL);
  g_return_val_if_fail(node-&gt;type == INFC_BROWSER_NODE_NOTE_KNOWN, NULL);
  g_return_val_if_fail(node-&gt;shared.known.session == NULL, NULL);
  g_return_val_if_fail(
    inf_browser_get_pending_request(
      browser,
      iter,
      "subscribe-session"
    ) == NULL,
    NULL
  );
  request = infc_request_manager_add_request(
    priv-&gt;request_manager,
    INFC_TYPE_REQUEST,
    "subscribe-session",
    G_CALLBACK(func),
    user_data,
    "node-id", iter-&gt;node_id,
    NULL
  );
  inf_browser_begin_request(browser, iter, INF_REQUEST(request));
  xml = infc_browser_request_to_xml(request);
  inf_xml_util_set_attribute_uint(xml, "id", node-&gt;id);
  inf_communication_group_send_message(
    INF_COMMUNICATION_GROUP(priv-&gt;group),
    priv-&gt;connection,
    xml
  );
  return INF_REQUEST(request);
}
static InfSessionProxy*
infc_browser_browser_get_session(InfBrowser* browser,
                                 const InfBrowserIter* iter)
{
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
  infc_browser_return_val_if_iter_fail(browser, iter, NULL);
  priv = INFC_BROWSER_PRIVATE(browser);
  node = (InfcBrowserNode*)iter-&gt;node;
  if(node-&gt;type != INFC_BROWSER_NODE_NOTE_KNOWN) return NULL;
  return INF_SESSION_PROXY(node-&gt;shared.known.session);
}
static GSList*
infc_browser_browser_list_pending_requests(InfBrowser* browser,
                                           const InfBrowserIter* iter,
                                           const gchar* request_type)
{
  InfcBrowserPrivate* priv;
  InfcBrowserListPendingRequestsForeachData data;
  data.iter = iter;
  data.result = NULL;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
  if(iter != NULL)
  {
    infc_browser_return_val_if_iter_fail(browser, iter, NULL);
  }
  priv = INFC_BROWSER_PRIVATE(browser);
  if(priv-&gt;request_manager != NULL)
  {
    if(request_type == NULL)
    {
      infc_request_manager_foreach_request(
        priv-&gt;request_manager,
        infc_browser_browser_list_pending_requests_foreach_func,
        &amp;data
      );
    }
    else
    {
      infc_request_manager_foreach_named_request(
        priv-&gt;request_manager,
        request_type,
        infc_browser_browser_list_pending_requests_foreach_func,
        &amp;data
      );
    }
  }
  return data.result;
}
static gboolean
infc_browser_browser_iter_from_request(InfBrowser* browser,
                                       InfRequest* request,
                                       InfBrowserIter* iter)
{
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  guint node_id;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), FALSE);
  g_return_val_if_fail(INFC_IS_REQUEST(request), FALSE);
  g_return_val_if_fail(iter != NULL, FALSE);
  priv = INFC_BROWSER_PRIVATE(browser);
  g_object_get(G_OBJECT(request), "node-id", &amp;node_id, NULL);
  if(node_id == G_MAXUINT) return FALSE;
  node = g_hash_table_lookup(priv-&gt;nodes, GUINT_TO_POINTER(node_id));
  if(node == NULL) return FALSE;
  iter-&gt;node_id = node_id;
  iter-&gt;node = node;
  return TRUE;
}
static InfRequest*
infc_browser_browser_query_acl_account_list(InfBrowser* browser,
                                            InfRequestFunc func,
                                            gpointer user_data)
{
  InfcBrowserPrivate* priv;
  InfcRequest* request;
  xmlNodePtr xml;
  InfAclAccount* accounts;
  guint n_accounts;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
  priv = INFC_BROWSER_PRIVATE(browser);
  g_return_val_if_fail(priv-&gt;status == INF_BROWSER_OPEN, NULL);
  g_return_val_if_fail(
    inf_browser_get_pending_request(
      INF_BROWSER(browser),
      NULL,
      "query-acl-account-list"
    ) == NULL,
    NULL
  );
  request = infc_request_manager_add_request(
    priv-&gt;request_manager,
    INFC_TYPE_PROGRESS_REQUEST,
    "query-acl-account-list",
    G_CALLBACK(func),
    user_data,
    NULL
  );
  inf_browser_begin_request(browser, NULL, INF_REQUEST(request));
  switch(priv-&gt;account_list_status)
  {
  case INFC_BROWSER_ACCOUNT_LIST_NOT_QUERIED:
  case INFC_BROWSER_ACCOUNT_LIST_NO_NOTIFICATIONS:
    xml = infc_browser_request_to_xml(request);
    inf_communication_group_send_message(
      INF_COMMUNICATION_GROUP(priv-&gt;group),
      priv-&gt;connection,
      xml
    );
    break;
  case INFC_BROWSER_ACCOUNT_LIST_NOTIFICATIONS:
    accounts = infc_browser_make_acl_account_list(
      INFC_BROWSER(browser),
      &amp;n_accounts
    );
    infc_request_manager_finish_request(
      priv-&gt;request_manager,
      request,
      inf_request_result_make_query_acl_account_list(
        INF_BROWSER(browser),
        accounts,
        n_accounts,
        TRUE
      )
    );
    g_free(accounts);
    request = NULL;
    break;
  }
  return INF_REQUEST(request);
}
static const InfAclAccount*
infc_browser_browser_get_acl_default_account(InfBrowser* infbrowser)
{
  InfcBrowser* browser;
  InfcBrowserPrivate* priv;
  InfAclAccountId default_id;
  InfAclAccount* default_account;
  browser = INFC_BROWSER(infbrowser);
  priv = INFC_BROWSER_PRIVATE(browser);
  g_return_val_if_fail(priv-&gt;status == INF_BROWSER_OPEN, NULL);
  default_id = inf_acl_account_id_from_string("default");
  default_account = g_hash_table_lookup(
    priv-&gt;accounts,
    INF_ACL_ACCOUNT_ID_TO_POINTER(default_id)
  );
  g_assert(default_account != NULL);
  return default_account;
}
static const InfAclAccount*
infc_browser_browser_get_acl_local_account(InfBrowser* infbrowser)
{
  InfcBrowser* browser;
  InfcBrowserPrivate* priv;
  browser = INFC_BROWSER(infbrowser);
  priv = INFC_BROWSER_PRIVATE(browser);
  g_return_val_if_fail(priv-&gt;status == INF_BROWSER_OPEN, NULL);
  g_assert(priv-&gt;local_account != NULL);
  return priv-&gt;local_account;
}
static InfRequest*
infc_browser_browser_lookup_acl_accounts(InfBrowser* infbrowser,
                                         const InfAclAccountId* ids,
                                         guint n_ids,
                                         InfRequestFunc func,
                                         gpointer user_data)
{
  InfcBrowser* browser;
  InfcBrowserPrivate* priv;
  InfcRequest* request;
  guint i;
  const InfAclAccount* account;
  InfAclAccount* accounts;
  guint n_accounts;
  xmlNodePtr xml;
  InfAclAccountId* ids_req;
  browser = INFC_BROWSER(infbrowser);
  priv = INFC_BROWSER_PRIVATE(browser);
  request = infc_request_manager_add_request(
    priv-&gt;request_manager,
    INFC_TYPE_REQUEST,
    "lookup-acl-accounts",
    G_CALLBACK(func),
    user_data,
    NULL
  );
  if(priv-&gt;account_list_status != INFC_BROWSER_ACCOUNT_LIST_NOTIFICATIONS)
    xml = infc_browser_request_to_xml(request);
  else
    xml = NULL;
  accounts = g_malloc(sizeof(InfAclAccount) * n_ids);
  n_accounts = 0;
  for(i = 0; i &lt; n_ids; ++i)
  {
    account = g_hash_table_lookup(
      priv-&gt;accounts,
      INF_ACL_ACCOUNT_ID_TO_POINTER(ids[i])
    );
    if(account != NULL)
    {
      accounts[i] = *account;
      ++n_accounts;
    }
    else
    {
      accounts[i].id = ids[i];
      accounts[i].name = NULL;
      if(xml != NULL)
      {
        xmlNewChild(
          xml,
          NULL,
          (const xmlChar*)"id",
          (const xmlChar*)inf_acl_account_id_to_string(ids[i])
        );
      }
    }
  }
  if(xml == NULL || n_accounts == n_ids)
  {
    if(xml != NULL) xmlFreeNode(xml);
    infc_request_manager_finish_request(
      priv-&gt;request_manager,
      request,
      inf_request_result_make_lookup_acl_accounts(
        INF_BROWSER(browser),
        accounts,
        n_ids
      )
    );
    request = NULL;
  }
  else
  {
    ids_req = g_malloc(sizeof(InfAclAccountId) * n_ids);
    for(i = 0; i &lt; n_ids; ++i)
      ids_req[i] = ids[i];
    g_object_set_qdata_full(
      G_OBJECT(request),
      infc_browser_lookup_acl_accounts_ids_quark,
      ids_req,
      g_free
    );
    g_object_set_qdata(
      G_OBJECT(request),
      infc_browser_lookup_acl_accounts_n_ids_quark,
      GUINT_TO_POINTER(n_ids)
    );
    inf_communication_group_send_message(
      INF_COMMUNICATION_GROUP(priv-&gt;group),
      priv-&gt;connection,
      xml
    );
  }
  g_free(accounts);
  return INF_REQUEST(request);
}
static InfRequest*
infc_browser_browser_lookup_acl_account_by_name(InfBrowser* infbrowser,
                                                const gchar* name,
                                                InfRequestFunc func,
                                                gpointer user_data)
{
  InfcBrowser* browser;
  InfcBrowserPrivate* priv;
  InfcRequest* request;
  GArray* cached_accounts;
  InfcBrowserLookupAclAccountByByNameData lookup_data;
  InfAclAccount result_acc;
  xmlNodePtr xml;
  browser = INFC_BROWSER(infbrowser);
  priv = INFC_BROWSER_PRIVATE(browser);
  request = infc_request_manager_add_request(
    priv-&gt;request_manager,
    INFC_TYPE_REQUEST,
    "lookup-acl-accounts",
    G_CALLBACK(func),
    user_data,
    NULL
  );
  lookup_data.name = name;
  lookup_data.accounts = g_array_new(FALSE, FALSE, sizeof(InfAclAccount));
  g_hash_table_foreach(
    priv-&gt;accounts,
    infc_browser_browser_lookup_acl_account_by_name_find_func,
    &amp;lookup_data
  );
  if(lookup_data.accounts-&gt;len == 0)
  {
    if(priv-&gt;account_list_status == INFC_BROWSER_ACCOUNT_LIST_NOTIFICATIONS)
    {
      result_acc.id = 0;
      result_acc.name = (gchar*)name;
      infc_request_manager_finish_request(
        priv-&gt;request_manager,
        request,
        inf_request_result_make_lookup_acl_accounts(
          INF_BROWSER(browser),
          &amp;result_acc,
          1
        )
      );
      request = NULL;
    }
    else
    {
      xml = infc_browser_request_to_xml(request);
      xmlNewChild(xml, NULL, (const xmlChar*)"name", (const xmlChar*)name);
      g_object_set_qdata_full(
        G_OBJECT(request),
        infc_browser_lookup_acl_accounts_name_quark,
        g_strdup(name),
        g_free
      );
      inf_communication_group_send_message(
        INF_COMMUNICATION_GROUP(priv-&gt;group),
        priv-&gt;connection,
        xml
      );
    }
  }
  else
  {
    infc_request_manager_finish_request(
      priv-&gt;request_manager,
      request,
      inf_request_result_make_lookup_acl_accounts(
        INF_BROWSER(browser),
        (InfAclAccount*)lookup_data.accounts-&gt;data,
        lookup_data.accounts-&gt;len
      )
    );
    request = NULL;
  }
  g_array_free(lookup_data.accounts, TRUE);
  return INF_REQUEST(request);
}
static InfRequest*
infc_browser_browser_create_acl_account(InfBrowser* browser,
                                        gnutls_x509_crq_t crq,
                                        InfRequestFunc func,
                                        gpointer user_data)
{
  InfcBrowserPrivate* priv;
  InfcRequest* request;
  xmlNodePtr xml;
  xmlNodePtr crqNode;
  GError* error;
  gchar* crq_text;
  size_t size;
  int res;
  priv = INFC_BROWSER_PRIVATE(browser);
  request = infc_request_manager_add_request(
    priv-&gt;request_manager,
    INFC_TYPE_REQUEST,
    "create-acl-account",
    G_CALLBACK(func),
    user_data,
    NULL
  );
  inf_browser_begin_request(INF_BROWSER(browser), NULL, INF_REQUEST(request));
  size = 0;
  res = gnutls_x509_crq_export(crq, GNUTLS_X509_FMT_PEM, NULL, &amp;size);
  if(res != GNUTLS_E_SHORT_MEMORY_BUFFER)
  {
    error = NULL;
    inf_gnutls_set_error(&amp;error, res);
    infc_request_manager_fail_request(priv-&gt;request_manager, request, error);
    g_error_free(error);
    g_object_unref(request);
    return NULL;
  }
  crq_text = g_malloc(size);
  res = gnutls_x509_crq_export(crq, GNUTLS_X509_FMT_PEM, crq_text, &amp;size);
  if(res != GNUTLS_E_SUCCESS)
  {
    g_free(crq_text);
    error = NULL;
    inf_gnutls_set_error(&amp;error, res);
    infc_request_manager_fail_request(priv-&gt;request_manager, request, error);
    g_error_free(error);
    g_object_unref(request);
    return NULL;
  }
  xml = infc_browser_request_to_xml(request);
  crqNode = xmlNewChild(xml, NULL, (const xmlChar*)"crq", NULL);
  xmlNodeAddContentLen(crqNode, (const xmlChar*)crq_text, size);
  g_free(crq_text);
  inf_communication_group_send_message(
    INF_COMMUNICATION_GROUP(priv-&gt;group),
    priv-&gt;connection,
    xml
  );
  return INF_REQUEST(request);
}
static InfRequest*
infc_browser_browser_remove_acl_account(InfBrowser* browser,
                                        InfAclAccountId account,
                                        InfRequestFunc func,
                                        gpointer user_data)
{
  InfcBrowserPrivate* priv;
  InfcRequest* request;
  xmlNodePtr xml;
  priv = INFC_BROWSER_PRIVATE(browser);
  request = infc_request_manager_add_request(
    priv-&gt;request_manager,
    INFC_TYPE_REQUEST,
    "remove-acl-account",
    G_CALLBACK(func),
    user_data,
    NULL
  );
  inf_browser_begin_request(INF_BROWSER(browser), NULL, INF_REQUEST(request));
  xml = infc_browser_request_to_xml(request);
  inf_xml_util_set_attribute(
    xml,
    "id",
    inf_acl_account_id_to_string(account)
  );
  inf_communication_group_send_message(
    INF_COMMUNICATION_GROUP(priv-&gt;group),
    priv-&gt;connection,
    xml
  );
  return INF_REQUEST(request);
}
static InfRequest*
infc_browser_browser_query_acl(InfBrowser* browser,
                               const InfBrowserIter* iter,
                               InfRequestFunc func,
                               gpointer user_data)
{
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  InfcRequest* request;
  xmlNodePtr xml;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
  infc_browser_return_val_if_iter_fail(INFC_BROWSER(browser), iter, NULL);
  node = (InfcBrowserNode*)iter-&gt;node;
  priv = INFC_BROWSER_PRIVATE(browser);
  g_return_val_if_fail(priv-&gt;connection != NULL, NULL);
  g_return_val_if_fail(priv-&gt;status == INF_BROWSER_OPEN, NULL);
  g_return_val_if_fail(node-&gt;acl_queried == FALSE, NULL);
  g_return_val_if_fail(
    inf_browser_get_pending_request(browser, iter, "query-acl") == NULL,
    NULL
  );
  request = infc_request_manager_add_request(
    priv-&gt;request_manager,
    INFC_TYPE_REQUEST,
    "query-acl",
    G_CALLBACK(func),
    user_data,
    "node-id", node-&gt;id,
    NULL
  );
  inf_browser_begin_request(browser, iter, INF_REQUEST(request));
  xml = infc_browser_request_to_xml(request);
  inf_xml_util_set_attribute_uint(xml, "id", node-&gt;id);
  inf_communication_group_send_message(
    INF_COMMUNICATION_GROUP(priv-&gt;group),
    priv-&gt;connection,
    xml
  );
  return INF_REQUEST(request);
}
static gboolean
infc_browser_browser_has_acl(InfBrowser* browser,
                             const InfBrowserIter* iter,
                             InfAclAccountId account)
{
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  InfAclAccountId default_id;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), FALSE);
  infc_browser_return_val_if_iter_fail(INFC_BROWSER(browser), iter, FALSE);
  priv = INFC_BROWSER_PRIVATE(browser);
  node = (InfcBrowserNode*)iter-&gt;node;
  if(node-&gt;acl_queried == TRUE)
    return TRUE;
  if(account != 0)
  {
    if(account == priv-&gt;local_account-&gt;id)
      return TRUE;
    default_id = inf_acl_account_id_from_string("default");
    if(account == default_id)
      return TRUE;
  }
  return FALSE;
}
static const InfAclSheetSet*
infc_browser_browser_get_acl(InfBrowser* browser,
                             const InfBrowserIter* iter)
{
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
  infc_browser_return_val_if_iter_fail(INFC_BROWSER(browser), iter, NULL);
  node = (InfcBrowserNode*)iter-&gt;node;
  return node-&gt;acl;
}
static InfRequest*
infc_browser_browser_set_acl(InfBrowser* browser,
                             const InfBrowserIter* iter,
                             const InfAclSheetSet* sheet_set,
                             InfRequestFunc func,
                             gpointer user_data)
{
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  InfcRequest* request;
  xmlNodePtr xml;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
  infc_browser_return_val_if_iter_fail(INFC_BROWSER(browser), iter, NULL);
  node = (InfcBrowserNode*)iter-&gt;node;
  priv = INFC_BROWSER_PRIVATE(browser);
  g_return_val_if_fail(priv-&gt;connection != NULL, NULL);
  g_return_val_if_fail(priv-&gt;status == INF_BROWSER_OPEN, NULL);
  g_return_val_if_fail(node-&gt;acl_queried == TRUE, NULL);
  request = infc_request_manager_add_request(
    priv-&gt;request_manager,
    INFC_TYPE_REQUEST,
    "set-acl",
    G_CALLBACK(func),
    user_data,
    "node-id", node-&gt;id,
    NULL
  );
  inf_browser_begin_request(browser, iter, INF_REQUEST(request));
  xml = infc_browser_request_to_xml(request);
  inf_xml_util_set_attribute_uint(xml, "id", node-&gt;id);
  inf_acl_sheet_set_to_xml(sheet_set, xml);
  inf_communication_group_send_message(
    INF_COMMUNICATION_GROUP(priv-&gt;group),
    priv-&gt;connection,
    xml
  );
  return INF_REQUEST(request);
}
static void
infc_browser_class_init(InfcBrowserClass* browser_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(browser_class);
  object_class-&gt;dispose = infc_browser_dispose;
  object_class-&gt;finalize = infc_browser_finalize;
  object_class-&gt;set_property = infc_browser_set_property;
  object_class-&gt;get_property = infc_browser_get_property;
  infc_browser_session_proxy_quark = g_quark_from_static_string(
    "infc-browser-session-proxy-quark"
  );
  infc_browser_sync_in_session_quark = g_quark_from_static_string(
    "infc-browser-sync-in-session-quark"
  );
  infc_browser_sync_in_plugin_quark = g_quark_from_static_string(
    "infc-browser-sync-in-plugin-quark"
  );
  infc_browser_lookup_acl_accounts_ids_quark = g_quark_from_static_string(
    "infc-browser-lookup-acl-accounts-ids-quark"
  );
  infc_browser_lookup_acl_accounts_n_ids_quark = g_quark_from_static_string(
    "infc-browser-lookup-acl-accounts-n-ids-quark"
  );
  infc_browser_lookup_acl_accounts_name_quark = g_quark_from_static_string(
    "infc-browser-lookup-acl-accounts-name-quark"
  );
  infc_browser_query_acl_account_list_accounts_quark =
    g_quark_from_static_string(
      "infc-browser-query-acl-account-list-accounts-quark"
    );
  g_object_class_install_property(
    object_class,
    PROP_IO,
    g_param_spec_object(
      "io",
      "IO",
      "The InfIo to schedule timeouts",
      INF_TYPE_IO,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_COMMUNICATION_MANAGER,
    g_param_spec_object(
      "communication-manager",
      "Communication manager",
      "The communication manager for the browser",
      INF_COMMUNICATION_TYPE_MANAGER,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_CONNECTION,
    g_param_spec_object(
      "connection",
      "Server connection",
      "Connection to the server exposing the directory to browse",
      INF_TYPE_XML_CONNECTION,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_CHAT_SESSION,
    g_param_spec_object(
      "chat-session",
      "Chat session",
      "Active chat session",
      INFC_TYPE_SESSION_PROXY,
      G_PARAM_READABLE
    )
  );
  g_object_class_override_property(object_class, PROP_STATUS, "status");
}
static void
infc_browser_communication_object_iface_init(
  InfCommunicationObjectInterface* iface)
{
  iface-&gt;received = infc_browser_communication_object_received;
  iface-&gt;sent = infc_browser_communication_object_sent;
}
static void
infc_browser_browser_iface_init(InfBrowserInterface* iface)
{
  iface-&gt;error = NULL;
  iface-&gt;node_added = NULL;
  iface-&gt;node_removed = NULL;
  iface-&gt;subscribe_session = infc_browser_browser_subscribe_session;
  iface-&gt;unsubscribe_session = NULL;
  iface-&gt;begin_request = NULL;
  iface-&gt;acl_account_added = NULL;
  iface-&gt;acl_account_removed = NULL;
  iface-&gt;acl_local_account_changed = NULL;
  iface-&gt;acl_changed = NULL;
  iface-&gt;get_root = infc_browser_browser_get_root;
  iface-&gt;get_next = infc_browser_browser_get_next;
  iface-&gt;get_prev = infc_browser_browser_get_prev;
  iface-&gt;get_parent = infc_browser_browser_get_parent;
  iface-&gt;get_child = infc_browser_browser_get_child;
  iface-&gt;explore = infc_browser_browser_explore;
  iface-&gt;get_explored = infc_browser_browser_get_explored;
  iface-&gt;is_subdirectory = infc_browser_browser_is_subdirectory;
  iface-&gt;add_note = infc_browser_browser_add_note;
  iface-&gt;add_subdirectory = infc_browser_browser_add_subdirectory;
  iface-&gt;remove_node = infc_browser_browser_remove_node;
  iface-&gt;get_node_name = infc_browser_browser_get_node_name;
  iface-&gt;get_node_type = infc_browser_browser_get_node_type;
  iface-&gt;subscribe = infc_browser_browser_subscribe;
  iface-&gt;get_session = infc_browser_browser_get_session;
  iface-&gt;list_pending_requests = infc_browser_browser_list_pending_requests;
  iface-&gt;iter_from_request = infc_browser_browser_iter_from_request;
  iface-&gt;get_acl_default_account = infc_browser_browser_get_acl_default_account;
  iface-&gt;get_acl_local_account = infc_browser_browser_get_acl_local_account;
  iface-&gt;query_acl_account_list = infc_browser_browser_query_acl_account_list;
  iface-&gt;lookup_acl_accounts = infc_browser_browser_lookup_acl_accounts;
  iface-&gt;lookup_acl_account_by_name =
    infc_browser_browser_lookup_acl_account_by_name;
  iface-&gt;create_acl_account = infc_browser_browser_create_acl_account;
  iface-&gt;remove_acl_account = infc_browser_browser_remove_acl_account;
  iface-&gt;query_acl = infc_browser_browser_query_acl;
  iface-&gt;has_acl = infc_browser_browser_has_acl;
  iface-&gt;get_acl = infc_browser_browser_get_acl;
  iface-&gt;set_acl = infc_browser_browser_set_acl;
}
InfcBrowser*
infc_browser_new(InfIo* io,
                 InfCommunicationManager* comm_manager,
                 InfXmlConnection* connection)
{
  GObject* object;
  g_return_val_if_fail(INF_IS_IO(io), NULL);
  g_return_val_if_fail(INF_COMMUNICATION_IS_MANAGER(comm_manager), NULL);
  g_return_val_if_fail(INF_IS_XML_CONNECTION(connection), NULL);
  object = g_object_new(
    INFC_TYPE_BROWSER,
    "io", io,
    "communication-manager", comm_manager,
    "connection", connection,
    NULL
  );
  return INFC_BROWSER(object);
}
InfCommunicationManager*
infc_browser_get_communication_manager(InfcBrowser* browser)
{
  g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
  return INFC_BROWSER_PRIVATE(browser)-&gt;communication_manager;
}
InfXmlConnection*
infc_browser_get_connection(InfcBrowser* browser)
{
  g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
  return INFC_BROWSER_PRIVATE(browser)-&gt;connection;
}
gboolean
infc_browser_add_plugin(InfcBrowser* browser,
                        const InfcNotePlugin* plugin)
{
  InfcBrowserPrivate* priv;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), FALSE);
  g_return_val_if_fail(plugin != NULL, FALSE);
  priv = INFC_BROWSER_PRIVATE(browser);
  if(g_hash_table_lookup(priv-&gt;plugins, plugin-&gt;note_type) != NULL)
    return FALSE;
  g_hash_table_insert(
    priv-&gt;plugins,
    *(const gpointer*)(gconstpointer)&amp;plugin-&gt;note_type,
    *(gpointer*)(gpointer)&amp;plugin
  );
  return TRUE;
}
const InfcNotePlugin*
infc_browser_lookup_plugin(InfcBrowser* browser,
                           const gchar* note_type)
{
  InfcBrowserPrivate* priv;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
  g_return_val_if_fail(note_type != NULL, NULL);
  priv = INFC_BROWSER_PRIVATE(browser);
  return (const InfcNotePlugin*)g_hash_table_lookup(priv-&gt;plugins, note_type);
}
InfRequest*
infc_browser_iter_save_session(InfcBrowser* browser,
                               const InfBrowserIter* iter,
                               InfRequestFunc func,
                               gpointer user_data)
{
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  InfcRequest* request;
  xmlNodePtr xml;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
  infc_browser_return_val_if_iter_fail(browser, iter, NULL);
  priv = INFC_BROWSER_PRIVATE(browser);
  node = (InfcBrowserNode*)iter-&gt;node;
  g_return_val_if_fail(priv-&gt;connection != NULL, NULL);
  g_return_val_if_fail(node-&gt;type == INFC_BROWSER_NODE_NOTE_KNOWN, NULL);
  request = infc_request_manager_add_request(
    priv-&gt;request_manager,
    INFC_TYPE_REQUEST,
    "save-session",
    G_CALLBACK(func),
    user_data,
    "node-id", iter-&gt;node_id,
    NULL
  );
  inf_browser_begin_request(INF_BROWSER(browser), iter, INF_REQUEST(request));
  xml = infc_browser_request_to_xml(request);
  inf_xml_util_set_attribute_uint(xml, "id", node-&gt;id);
  inf_communication_group_send_message(
    INF_COMMUNICATION_GROUP(priv-&gt;group),
    priv-&gt;connection,
    xml
  );
  return INF_REQUEST(request);
}
InfcSessionProxy*
infc_browser_iter_get_sync_in(InfcBrowser* browser,
                              const InfBrowserIter* iter)
{
  InfcBrowserPrivate* priv;
  GSList* item;
  InfcBrowserSyncIn* sync_in;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
  infc_browser_return_val_if_iter_fail(browser, iter, NULL);
  priv = INFC_BROWSER_PRIVATE(browser);
  for(item = priv-&gt;sync_ins; item != NULL; item = item-&gt;next)
  {
    sync_in = (InfcBrowserSyncIn*)item-&gt;data;
    if(sync_in-&gt;node == iter-&gt;node)
      return sync_in-&gt;proxy;
  }
  return NULL;
}
GSList*
infc_browser_iter_get_sync_in_requests(InfcBrowser* browser,
                                       const InfBrowserIter* iter)
{
  InfcBrowserPrivate* priv;
  InfcBrowserNode* node;
  InfcBrowserIterGetSyncInRequestsForeachData data;
  data.iter = iter;
  data.result = NULL;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
  infc_browser_return_val_if_iter_fail(browser, iter, NULL);
  node = (InfcBrowserNode*)iter-&gt;node;
  infc_browser_return_val_if_subdir_fail(node, NULL);
  priv = INFC_BROWSER_PRIVATE(browser);
  if(priv-&gt;request_manager != NULL)
  {
    infc_request_manager_foreach_named_request(
      priv-&gt;request_manager,
      "add-node",
      infc_browser_iter_get_sync_in_requests_foreach_func,
      &amp;data
    );
  }
  return data.result;
}
gboolean
infc_browser_iter_is_valid(InfcBrowser* browser,
                           const InfBrowserIter* iter)
{
  InfcBrowserPrivate* priv;
  gpointer node;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), FALSE);
  if(!iter) return FALSE;
  priv = INFC_BROWSER_PRIVATE(browser);
  node = g_hash_table_lookup(priv-&gt;nodes, GUINT_TO_POINTER(iter-&gt;node_id));
  return node != NULL &amp;&amp; node == iter-&gt;node;
}
InfRequest*
infc_browser_subscribe_chat(InfcBrowser* browser,
                            InfRequestFunc func,
                            gpointer user_data)
{
  InfcBrowserPrivate* priv;
  InfcRequest* request;
  xmlNodePtr xml;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
  g_return_val_if_fail(infc_browser_get_chat_session(browser) == NULL, NULL);
  g_return_val_if_fail(
    infc_browser_get_subscribe_chat_request(browser) == NULL,
    NULL
  );
  priv = INFC_BROWSER_PRIVATE(browser);
  request = infc_request_manager_add_request(
    priv-&gt;request_manager,
    INFC_TYPE_REQUEST,
    "subscribe-chat",
    G_CALLBACK(func),
    user_data,
    NULL
  );
  inf_browser_begin_request(INF_BROWSER(browser), NULL, INF_REQUEST(request));
  xml = infc_browser_request_to_xml(request);
  inf_communication_group_send_message(
    INF_COMMUNICATION_GROUP(priv-&gt;group),
    priv-&gt;connection,
    xml
  );
  return INF_REQUEST(request);
}
InfRequest*
infc_browser_get_subscribe_chat_request(InfcBrowser* browser)
{
  InfcBrowserPrivate* priv;
  InfcBrowserIterGetChatRequestForeachData data;
  data.result = NULL;
  g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
  priv = INFC_BROWSER_PRIVATE(browser);
  if(priv-&gt;request_manager != NULL)
  {
    infc_request_manager_foreach_named_request(
      priv-&gt;request_manager,
      "subscribe-chat",
      infc_browser_get_chat_request_foreach_func,
      &amp;data
    );
  }
  return INF_REQUEST(data.result);
}
InfcSessionProxy*
infc_browser_get_chat_session(InfcBrowser* browser)
{
  g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
  return INFC_BROWSER_PRIVATE(browser)-&gt;chat_session;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
