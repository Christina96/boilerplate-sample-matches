<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-adopted-session-record.c &amp; infc-browser.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-adopted-session-record.c &amp; infc-browser.c
      </h3>
<h1 align="center">
        2.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-adopted-session-record.c (14.420063%)<th>infc-browser.c (1.3909888%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(405-431)<td><a href="#" name="0">(1761-1788)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(433-458)<td><a href="#" name="1">(1873-1898)</a><td align="center"><font color="#e10000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(342-358)<td><a href="#" name="2">(1643-1659)</a><td align="center"><font color="#d20000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-adopted-session-record.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/adopted/inf-adopted-session-record.h&gt;
2 #include &lt;libinfinity/common/inf-xml-util.h&gt;
3 #include &lt;libinfinity/inf-i18n.h&gt;
4 #include &lt;libinfinity/inf-signals.h&gt;
5 #include &lt;libxml/xmlwriter.h&gt;
6 #include &lt;errno.h&gt;
7 #include &lt;string.h&gt;
8 typedef struct _InfAdoptedSessionRecordPrivate InfAdoptedSessionRecordPrivate;
9 struct _InfAdoptedSessionRecordPrivate {
10   InfAdoptedSession* session;
11   xmlTextWriterPtr writer;
12   FILE* file;
13   gchar* filename;
14   GHashTable* last_send_table;
15 };
16 enum {
17   PROP_0,
18   PROP_SESSION,
19   PROP_FILENAME
20 };
21 #define INF_ADOPTED_SESSION_RECORD_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_ADOPTED_TYPE_SESSION_RECORD, InfAdoptedSessionRecordPrivate))
22 static GQuark libxml2_writer_error_quark;
23 G_DEFINE_TYPE_WITH_CODE(InfAdoptedSessionRecord, inf_adopted_session_record, G_TYPE_OBJECT,
24   G_ADD_PRIVATE(InfAdoptedSessionRecord))
25 static void
26 inf_adopted_session_record_handle_xml_error(InfAdoptedSessionRecord* record)
27 {
28   InfAdoptedSessionRecordPrivate* priv;
29   xmlErrorPtr xmlerror;
30   priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
31   xmlerror = xmlGetLastError();
32   g_warning(
33     _("Error writing record \"%s\": %s"),
34     priv-&gt;filename,
35     xmlerror-&gt;message
36   );
37 }
38 static void
39 inf_adopted_session_record_write_node(InfAdoptedSessionRecord* record,
40                                       xmlNodePtr xml)
41 {
42   InfAdoptedSessionRecordPrivate* priv;
43   xmlAttrPtr attr;
44   xmlChar* value;
45   xmlNodePtr child;
46   int result;
47   priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
48   result = xmlTextWriterStartElement(priv-&gt;writer, xml-&gt;name);
49   if(result &lt; 0) inf_adopted_session_record_handle_xml_error(record);
50   for(attr = xml-&gt;properties; attr != NULL; attr = attr-&gt;next)
51   {
52     value = xmlGetProp(xml, attr-&gt;name);
53     result = xmlTextWriterWriteAttribute(priv-&gt;writer, attr-&gt;name, value);
54     if(result &lt; 0) inf_adopted_session_record_handle_xml_error(record);
55     xmlFree(value);
56   }
57   for(child = xml-&gt;children; child != NULL; child = child-&gt;next)
58   {
59     if(child-&gt;type == XML_ELEMENT_NODE)
60     {
61       inf_adopted_session_record_write_node(record, child);
62     }
63     else if(child-&gt;type == XML_TEXT_NODE)
64     {
65       value = xmlNodeGetContent(child);
66       result = xmlTextWriterWriteString(priv-&gt;writer, value);
67       if(result &lt; 0) inf_adopted_session_record_handle_xml_error(record);
68       xmlFree(value);
69     }
70   }
71   result = xmlTextWriterEndElement(priv-&gt;writer);
72   if(result &lt; 0) inf_adopted_session_record_handle_xml_error(record);
73 }
74 static void
75 inf_adopted_session_record_user_joined(InfAdoptedSessionRecord* record,
76                                        InfAdoptedUser* user)
77 {
78   InfAdoptedSessionRecordPrivate* priv;
79   priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
80   g_hash_table_insert(
81     priv-&gt;last_send_table,
82     user,
83     inf_adopted_state_vector_copy(inf_adopted_user_get_vector(user))
84   );
85 }
86 static void
87 inf_adopted_session_record_begin_execute_request_cb(InfAdoptedAlgorithm* algo,
88                                                     InfAdoptedUser* user,
89                                                     InfAdoptedRequest* req,
90                                                     gpointer user_data)
91 {
92   InfAdoptedSessionRecord* record;
93   InfAdoptedSessionRecordPrivate* priv;
94   InfAdoptedSessionClass* session_class;
95   InfAdoptedStateVector* previous;
96   xmlNodePtr xml;
97   int result;
98   record = INF_ADOPTED_SESSION_RECORD(user_data);
99   priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
100   session_class = INF_ADOPTED_SESSION_GET_CLASS(priv-&gt;session);
101   xml = xmlNewNode(NULL, (const xmlChar*)"request");
102   previous = g_hash_table_lookup(priv-&gt;last_send_table, user);
103   g_assert(previous != NULL);
104   session_class-&gt;request_to_xml(priv-&gt;session, xml, req, previous, FALSE);
105   inf_xml_util_set_attribute_double(
106     xml,
107     "received",
108     inf_adopted_request_get_receive_time(req) / 1000000.
109   );
110   inf_xml_util_set_attribute_double(
111     xml,
112     "executed",
113     inf_adopted_request_get_execute_time(req) / 1000000.
114   );
115   inf_adopted_session_record_write_node(record, xml);
116   xmlFreeNode(xml);
117   result = xmlTextWriterFlush(priv-&gt;writer);
118   if(result &lt; 0) inf_adopted_session_record_handle_xml_error(record);
119   fflush(priv-&gt;file);
120   previous =
121     inf_adopted_state_vector_copy(inf_adopted_request_get_vector(req));
122   if(inf_adopted_request_affects_buffer(req))
123     inf_adopted_state_vector_add(previous, inf_user_get_id(INF_USER(user)), 1);
124   g_hash_table_insert(priv-&gt;last_send_table, user, previous);
125 }
126 static void
127 inf_adopted_session_record_add_user_cb(InfUserTable* user_table,
128                                        InfUser* user,
129                                        gpointer user_data)
130 {
131   InfAdoptedSessionRecord* record;
132   InfAdoptedSessionRecordPrivate* priv;
133   xmlNodePtr xml;
134   int result;
135   record = INF_ADOPTED_SESSION_RECORD(user_data);
136   priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
137   inf_adopted_session_record_user_joined(record, INF_ADOPTED_USER(user));
138   result = xmlTextWriterWriteString(priv-&gt;writer, (const xmlChar*)"\n  ");
139   if(result &lt; 0) inf_adopted_session_record_handle_xml_error(record);
140   xml = xmlNewNode(NULL, (const xmlChar*)"user");
141   inf_session_user_to_xml(INF_SESSION(priv-&gt;session), user, xml);
142   inf_xml_util_set_attribute_double(
143     xml,
144     "executed",
145     g_get_real_time() / 1000000.
146   );
147   inf_adopted_session_record_write_node(record, xml);
148   xmlFreeNode(xml);
149   result = xmlTextWriterFlush(priv-&gt;writer);
150   if(result &lt; 0) inf_adopted_session_record_handle_xml_error(record);
151   fflush(priv-&gt;file);
152 }
153 static void
154 inf_adopted_session_record_start_foreach_user_func(InfUser* user,
155                                                    gpointer user_data)
156 {
157   inf_adopted_session_record_user_joined(
158     INF_ADOPTED_SESSION_RECORD(user_data),
159     INF_ADOPTED_USER(user)
160   );
161 }
162 static void
163 inf_adopted_session_record_real_start(InfAdoptedSessionRecord* record)
164 {
165   InfAdoptedSessionRecordPrivate* priv;
166   InfAdoptedAlgorithm* algorithm;
167   InfUserTable* user_table;
168   xmlNodePtr xml;
169   xmlNodePtr child;
170   xmlNodePtr cur;
171   int result;
172   guint total;
173   InfSessionClass* session_class;
174   priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
175   algorithm = inf_adopted_session_get_algorithm(priv-&gt;session);
176   user_table = inf_session_get_user_table(INF_SESSION(priv-&gt;session));
177   session_class = INF_SESSION_GET_CLASS(priv-&gt;session);
178   g_signal_connect(
179     G_OBJECT(algorithm),
180     "begin-execute-request",
181     G_CALLBACK(inf_adopted_session_record_begin_execute_request_cb),
182     record
183   );
184   g_signal_connect(
185     G_OBJECT(user_table),
186     "add-user",
187     G_CALLBACK(inf_adopted_session_record_add_user_cb),
188     record
189   );
190   priv-&gt;last_send_table = g_hash_table_new_full(
191     NULL,
192     NULL,
193     NULL,
194     (GDestroyNotify)inf_adopted_state_vector_free
195   );
196   inf_user_table_foreach_user(
197     inf_session_get_user_table(INF_SESSION(priv-&gt;session)),
198     inf_adopted_session_record_start_foreach_user_func,
199     record
200   );
201   result = xmlTextWriterStartDocument(priv-&gt;writer, NULL, "UTF-8", NULL);
202   if(result &lt; 0) inf_adopted_session_record_handle_xml_error(record);
203   result = xmlTextWriterStartElement(
204     priv-&gt;writer,
205     (const xmlChar*)"infinote-adopted-session-record"
206   );
207   if(result &lt; 0) inf_adopted_session_record_handle_xml_error(record);
208   xml = xmlNewNode(NULL, (const xmlChar*)"initial");
209   child = xmlNewChild(xml, NULL, (const xmlChar*)"sync-begin", NULL);
210   session_class-&gt;to_xml_sync(INF_SESSION(priv-&gt;session), xml);
211   xmlNewChild(xml, NULL, (const xmlChar*)"sync-end", NULL);
212   total = 0;
213   for(cur = child; cur != NULL; cur = cur-&gt;next)
214     ++ total;
215   inf_xml_util_set_attribute_uint(child, "num-messages", total - 2);
216   inf_adopted_session_record_write_node(record, xml);
217   xmlFreeNode(xml);
218   result = xmlTextWriterFlush(priv-&gt;writer);
219   if(result &lt; 0) inf_adopted_session_record_handle_xml_error(record);
220   fflush(priv-&gt;file);
221 }
222 static void
223 inf_adopted_session_record_synchronization_complete_cb(InfSession* session,
224                                                        InfXmlConnection* conn,
225                                                        gpointer user_data)
226 {
227   InfAdoptedSessionRecord* record;
228   record = INF_ADOPTED_SESSION_RECORD(user_data);
229   inf_signal_handlers_disconnect_by_func(
230     G_OBJECT(session),
231     G_CALLBACK(inf_adopted_session_record_synchronization_complete_cb),
232     record
233 <a name="2"></a>  );
234   inf_adopted_session_record_real_start(record);
235 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
236 static void
237 inf_adopted_session_record_init(InfAdoptedSessionRecord* record)
238 {
239   InfAdoptedSessionRecordPrivate* priv;
240   priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
241   priv-&gt;session = NULL;
242   priv-&gt;writer = NULL;
243   priv-&gt;file = NULL;
244   priv-&gt;filename = NULL;
245   priv-&gt;last_send_table = NULL;</b></font>
246 }
247 static void
248 inf_adopted_session_record_dispose(GObject* object)
249 {
250   InfAdoptedSessionRecord* record;
251   InfAdoptedSessionRecordPrivate* priv;
252   GError* error;
253   record = INF_ADOPTED_SESSION_RECORD(object);
254   priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
255   if(priv-&gt;writer != NULL)
256   {
257     error = NULL;
258     inf_adopted_session_record_stop_recording(record, &amp;error);
259     if(error != NULL)
260     {
261       g_assert(priv-&gt;filename != NULL);
262       g_warning(
263         "Error while finishing record `%s': %s",
264         priv-&gt;filename,
265         error-&gt;message
266       );
267       g_error_free(error);
268     }
269   }
270   if(priv-&gt;session != NULL)
271   {
272     g_object_unref(priv-&gt;session);
273     priv-&gt;session = NULL;
274   }
275   G_OBJECT_CLASS(inf_adopted_session_record_parent_class)-&gt;dispose(object);
276 }
277 static void
278 inf_adopted_session_record_finalize(GObject* object)
279 {
280 <a name="0"></a>  InfAdoptedSessionRecord* record;
281   InfAdoptedSessionRecordPrivate* priv;
282 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  record = INF_ADOPTED_SESSION_RECORD(object);
283   priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
284   g_assert(priv-&gt;filename == NULL);
285   G_OBJECT_CLASS(inf_adopted_session_record_parent_class)-&gt;finalize(object);
286 }
287 static void
288 inf_adopted_session_record_set_property(GObject* object,
289                                         guint prop_id,
290                                         const GValue* value,
291                                         GParamSpec* pspec)
292 {
293   InfAdoptedSessionRecord* record;
294   InfAdoptedSessionRecordPrivate* priv;
295   record = INF_ADOPTED_SESSION_RECORD(object);
296   priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
297   switch(prop_id)
298   {
299   case PROP_SESSION:
300     g_assert(priv-&gt;session == NULL);     priv-&gt;session = INF_ADOPTED_SESSION(g_value_dup_object(value));
301 <a name="1"></a>    break;
302   case PROP_FILENAME:</b></font>
303 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  default:
304     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
305     break;
306   }
307 }
308 static void
309 inf_adopted_session_record_get_property(GObject* object,
310                                         guint prop_id,
311                                         GValue* value,
312                                         GParamSpec* pspec)
313 {
314   InfAdoptedSessionRecord* record;
315   InfAdoptedSessionRecordPrivate* priv;
316   record = INF_ADOPTED_SESSION_RECORD(object);
317   priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
318   switch(prop_id)
319   {
320   case PROP_SESSION:
321     g_value_set_object(value, G_OBJECT(priv-&gt;session));
322     break;
323   case PROP_FILENAME:
324     g_value_set_string(value, priv-&gt;filename);
325     break;</b></font>
326   default:
327     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
328     break;
329   }
330 }
331 static void
332 inf_adopted_session_record_class_init(
333   InfAdoptedSessionRecordClass* record_class)
334 {
335   GObjectClass* object_class;
336   object_class = G_OBJECT_CLASS(record_class);
337   object_class-&gt;dispose = inf_adopted_session_record_dispose;
338   object_class-&gt;finalize = inf_adopted_session_record_finalize;
339   object_class-&gt;set_property = inf_adopted_session_record_set_property;
340   object_class-&gt;get_property = inf_adopted_session_record_get_property;
341   libxml2_writer_error_quark =
342     g_quark_from_static_string("LIBXML2_WRITER_ERROR");
343   g_object_class_install_property(
344     object_class,
345     PROP_SESSION,
346     g_param_spec_object(
347       "session",
348       "Session",
349       "The session to record",
350       INF_ADOPTED_TYPE_SESSION,
351       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
352     )
353   );
354   g_object_class_install_property(
355     object_class,
356     PROP_FILENAME,
357     g_param_spec_string(
358       "filename",
359       "Filename",
360       "The filename of the record file",
361       NULL,
362       G_PARAM_READABLE
363     )
364   );
365 }
366 InfAdoptedSessionRecord*
367 inf_adopted_session_record_new(InfAdoptedSession* session)
368 {
369   GObject* object;
370   g_return_val_if_fail(INF_ADOPTED_IS_SESSION(session), NULL);
371   object = g_object_new(
372     INF_ADOPTED_TYPE_SESSION_RECORD,
373     "session", session,
374     NULL
375   );
376   return INF_ADOPTED_SESSION_RECORD(object);
377 }
378 gboolean
379 inf_adopted_session_record_start_recording(InfAdoptedSessionRecord* record,
380                                            const gchar* filename,
381                                            GError** error)
382 {
383   InfAdoptedSessionRecordPrivate* priv;
384   InfSessionStatus status;
385   xmlOutputBufferPtr buffer;
386   xmlErrorPtr xmlerror;
387   int errcode;
388   g_return_val_if_fail(INF_ADOPTED_IS_SESSION_RECORD(record), FALSE);
389   g_return_val_if_fail(filename != NULL, FALSE);
390   g_return_val_if_fail(error == NULL || *error == NULL, FALSE);
391   priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
392   status = inf_session_get_status(INF_SESSION(priv-&gt;session));
393   g_return_val_if_fail(priv-&gt;writer == NULL, FALSE);
394   g_return_val_if_fail(status != INF_SESSION_CLOSED, FALSE);
395   priv-&gt;file = fopen(filename, "w");
396   if(priv-&gt;file == NULL)
397   {
398     errcode = errno;
399     g_set_error_literal(
400       error,
401       g_quark_from_static_string("ERRNO_ERROR"),
402       errcode,
403       strerror(errcode)
404     );
405     return FALSE;
406   }
407   buffer = xmlOutputBufferCreateFile(priv-&gt;file, NULL);
408   if(buffer == NULL)
409   {
410     fclose(priv-&gt;file);
411     priv-&gt;file = NULL;
412     xmlerror = xmlGetLastError();
413     g_set_error_literal(
414       error,
415       libxml2_writer_error_quark,
416       xmlerror-&gt;code,
417       xmlerror-&gt;message
418     );
419     return FALSE;
420   }
421   priv-&gt;writer = xmlNewTextWriter(buffer);
422   if(priv-&gt;writer == NULL)
423   {
424     xmlOutputBufferClose(buffer);
425     priv-&gt;file = NULL;
426     xmlerror = xmlGetLastError();
427     g_set_error_literal(
428       error,
429       libxml2_writer_error_quark,
430       xmlerror-&gt;code,
431       xmlerror-&gt;message
432     );
433     return FALSE;
434   }
435   xmlTextWriterSetIndent(priv-&gt;writer, 1);
436   switch(status)
437   {
438   case INF_SESSION_SYNCHRONIZING:
439     g_signal_connect_after(
440       G_OBJECT(priv-&gt;session),
441       "synchronization-complete",
442       G_CALLBACK(inf_adopted_session_record_synchronization_complete_cb),
443       record
444     );
445     break;
446   case INF_SESSION_RUNNING:
447     inf_adopted_session_record_real_start(record);
448     break;
449   default:
450     g_assert_not_reached();
451     break;
452   }
453   g_assert(priv-&gt;filename == NULL);
454   priv-&gt;filename = g_strdup(filename);
455   g_object_notify(G_OBJECT(record), "filename");
456   return TRUE;
457 }
458 gboolean
459 inf_adopted_session_record_stop_recording(InfAdoptedSessionRecord* record,
460                                           GError** error)
461 {
462   InfAdoptedSessionRecordPrivate* priv;
463   InfSessionStatus status;
464   InfAdoptedAlgorithm* algorithm;
465   InfUserTable* user_table;
466   xmlErrorPtr xmlerror;
467   int result;
468   g_return_val_if_fail(INF_ADOPTED_IS_SESSION_RECORD(record), FALSE);
469   g_return_val_if_fail(error == NULL || *error == NULL, FALSE);
470   priv = INF_ADOPTED_SESSION_RECORD_PRIVATE(record);
471   g_return_val_if_fail(priv-&gt;writer != NULL, FALSE);
472   inf_signal_handlers_disconnect_by_func(
473     G_OBJECT(priv-&gt;session),
474     G_CALLBACK(inf_adopted_session_record_synchronization_complete_cb),
475     record
476   );
477   status = inf_session_get_status(INF_SESSION(priv-&gt;session));
478   if(status != INF_SESSION_SYNCHRONIZING)
479   {
480     user_table = inf_session_get_user_table(INF_SESSION(priv-&gt;session));
481     if(status != INF_SESSION_CLOSED)
482     {
483       algorithm = inf_adopted_session_get_algorithm(priv-&gt;session);
484       g_assert(algorithm != NULL);
485       inf_signal_handlers_disconnect_by_func(
486         G_OBJECT(algorithm),
487         G_CALLBACK(inf_adopted_session_record_begin_execute_request_cb),
488         record
489       );
490     }
491     inf_signal_handlers_disconnect_by_func(
492       G_OBJECT(user_table),
493       G_CALLBACK(inf_adopted_session_record_add_user_cb),
494       record
495     );
496   }
497   result = xmlTextWriterWriteString(priv-&gt;writer, (const xmlChar*)"\n");
498   if(result &lt; 0) inf_adopted_session_record_handle_xml_error(record);
499   result = xmlTextWriterEndDocument(priv-&gt;writer);
500   if(result &lt; 0)
501   {
502     xmlerror = xmlGetLastError();
503     g_set_error_literal(
504       error,
505       libxml2_writer_error_quark,
506       xmlerror-&gt;code,
507       xmlerror-&gt;message
508     );
509     return FALSE;
510   }
511   xmlFreeTextWriter(priv-&gt;writer);
512   priv-&gt;writer = NULL;
513   priv-&gt;file = NULL;
514   g_free(priv-&gt;filename);
515   priv-&gt;filename = NULL;
516   if(priv-&gt;last_send_table != NULL)
517   {
518     g_hash_table_unref(priv-&gt;last_send_table);
519     priv-&gt;last_send_table = NULL;
520   }
521   g_object_notify(G_OBJECT(record), "filename");
522   return result &gt;= 0;
523 }
524 gboolean
525 inf_adopted_session_record_is_recording(InfAdoptedSessionRecord* record)
526 {
527   g_return_val_if_fail(INF_ADOPTED_IS_SESSION_RECORD(record), FALSE);
528   return INF_ADOPTED_SESSION_RECORD_PRIVATE(record)-&gt;writer != NULL;
529 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>infc-browser.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/client/infc-browser.h&gt;
2 #include &lt;libinfinity/client/infc-progress-request.h&gt;
3 #include &lt;libinfinity/client/infc-request-manager.h&gt;
4 #include &lt;libinfinity/common/inf-request-result.h&gt;
5 #include &lt;libinfinity/common/inf-chat-session.h&gt;
6 #include &lt;libinfinity/common/inf-cert-util.h&gt;
7 #include &lt;libinfinity/common/inf-xml-util.h&gt;
8 #include &lt;libinfinity/common/inf-protocol.h&gt;
9 #include &lt;libinfinity/common/inf-error.h&gt;
10 #include &lt;libinfinity/inf-i18n.h&gt;
11 #include &lt;libinfinity/inf-signals.h&gt;
12 #include &lt;string.h&gt;
13 #ifdef G_OS_WIN32
14 # ifdef ERROR
15 #  undef ERROR
16 # endif
17 #endif
18 typedef enum _InfcBrowserNodeType {
19   INFC_BROWSER_NODE_SUBDIRECTORY = 1 &lt;&lt; 0,
20   INFC_BROWSER_NODE_NOTE_KNOWN   = 1 &lt;&lt; 1,
21   INFC_BROWSER_NODE_NOTE_UNKNOWN = 1 &lt;&lt; 2
22 } InfcBrowserNodeType;
23 typedef struct _InfcBrowserMakeAclAccountListData
24   InfcBrowserMakeAclAccountListData;
25 struct _InfcBrowserMakeAclAccountListData {
26   InfAclAccount* accounts;
27   guint index;
28 };
29 typedef struct _InfcBrowserLookupAclAccountByByNameData
30   InfcBrowserLookupAclAccountByByNameData;
31 struct _InfcBrowserLookupAclAccountByByNameData {
32   const gchar* name;
33   GArray* accounts;
34 };
35 typedef struct _InfcBrowserListPendingRequestsForeachData
36   InfcBrowserListPendingRequestsForeachData;
37 struct _InfcBrowserListPendingRequestsForeachData {
38   const InfBrowserIter* iter;
39   GSList* result;
40 };
41 typedef struct _InfcBrowserIterGetChatRequestForeachData
42   InfcBrowserIterGetChatRequestForeachData;
43 struct _InfcBrowserIterGetChatRequestForeachData {
44   const InfBrowserIter* iter;
45   InfcRequest* result;
46 };
47 typedef struct _InfcBrowserIterGetSyncInRequestsForeachData
48   InfcBrowserIterGetSyncInRequestsForeachData;
49 struct _InfcBrowserIterGetSyncInRequestsForeachData {
50   const InfBrowserIter* iter;
51   GSList* result;
52 };
53 typedef struct _InfcBrowserNode InfcBrowserNode;
54 struct _InfcBrowserNode {
55   InfcBrowserNode* parent;
56   InfcBrowserNode* prev;
57   InfcBrowserNode* next;
58   guint id;
59   gchar* name;
60   InfcBrowserNodeType type;
61   InfAclSheetSet* acl;
62   gboolean acl_queried;
63   union {
64     struct {
65       InfcSessionProxy* session;
66       const InfcNotePlugin* plugin;
67     } known;
68     struct {
69       gchar* type;
70     } unknown;
71     struct {
72       InfcBrowserNode* child;
73       gboolean explored;
74     } subdir;
75   } shared;
76 };
77 typedef struct _InfcBrowserSyncIn InfcBrowserSyncIn;
78 struct _InfcBrowserSyncIn {
79   InfcBrowser* browser;
80   InfcBrowserNode* node;
81   InfcSessionProxy* proxy;
82 };
83 typedef enum _InfcBrowserSubreqType {
84   INFC_BROWSER_SUBREQ_CHAT,
85   INFC_BROWSER_SUBREQ_SESSION,
86   INFC_BROWSER_SUBREQ_ADD_NODE,
87   INFC_BROWSER_SUBREQ_SYNC_IN
88 } InfcBrowserSubreqType;
89 typedef struct _InfcBrowserSubreq InfcBrowserSubreq;
90 struct _InfcBrowserSubreq {
91   InfcBrowserSubreqType type;
92   guint node_id;
93   union {
94     struct {
95       InfcRequest* request;
96       InfCommunicationJoinedGroup* subscription_group;
97     } chat;
98     struct {
99       InfcBrowserNode* node;
100       InfcRequest* request;
101       InfCommunicationJoinedGroup* subscription_group;
102     } session;
103     struct {
104       InfcBrowserNode* parent;
105       const InfcNotePlugin* plugin;
106       gchar* name;
107       InfAclSheetSet* sheet_set;
108       InfcRequest* request;
109       InfCommunicationJoinedGroup* subscription_group;
110     } add_node;
111     struct {
112       InfcBrowserNode* parent;
113       const InfcNotePlugin* plugin;
114       gchar* name;
115       InfAclSheetSet* sheet_set;
116       InfcRequest* request;
117       InfCommunicationJoinedGroup* synchronization_group;
118       InfCommunicationJoinedGroup* subscription_group;       InfSession* session;
119     } sync_in;
120   } shared;
121 };
122 typedef enum _InfcBrowserAccountListStatus {
123   INFC_BROWSER_ACCOUNT_LIST_NOT_QUERIED,
124   INFC_BROWSER_ACCOUNT_LIST_NO_NOTIFICATIONS,
125   INFC_BROWSER_ACCOUNT_LIST_NOTIFICATIONS
126 } InfcBrowserAccountListStatus;
127 typedef struct _InfcBrowserPrivate InfcBrowserPrivate;
128 struct _InfcBrowserPrivate {
129   InfIo* io;
130   InfCommunicationManager* communication_manager;
131   InfCommunicationJoinedGroup* group;
132   InfXmlConnection* connection;
133   guint seq_id;
134   InfIoTimeout* welcome_timeout;
135   InfcRequestManager* request_manager;
136   GHashTable* plugins; 
137   InfBrowserStatus status;
138   GHashTable* nodes;   InfcBrowserNode* root;
139   GHashTable* accounts;   const InfAclAccount* local_account;
140   InfcBrowserAccountListStatus account_list_status;
141   GSList* sync_ins;
142   GSList* subscription_requests;
143   InfcSessionProxy* chat_session;
144 };
145 #define INFC_BROWSER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFC_TYPE_BROWSER, InfcBrowserPrivate))
146 enum {
147   PROP_0,
148   PROP_IO,
149   PROP_COMMUNICATION_MANAGER,
150   PROP_CONNECTION,
151   PROP_STATUS,
152   PROP_CHAT_SESSION
153 };
154 #define infc_browser_return_if_iter_fail(browser, iter) \
155   g_return_if_fail( \
156     iter != NULL &amp;&amp; \
157     g_hash_table_lookup( \
158       INFC_BROWSER_PRIVATE(INFC_BROWSER(browser))-&gt;nodes, \
159       GUINT_TO_POINTER((iter)-&gt;node_id) \
160     ) == (iter)-&gt;node \
161   )
162 #define infc_browser_return_val_if_iter_fail(browser, iter, val) \
163   g_return_val_if_fail( \
164     iter != NULL &amp;&amp; \
165     g_hash_table_lookup( \
166       INFC_BROWSER_PRIVATE(INFC_BROWSER(browser))-&gt;nodes, \
167       GUINT_TO_POINTER((iter)-&gt;node_id) \
168     ) == (iter)-&gt;node, \
169     val \
170   )
171 #define infc_browser_return_if_subdir_fail(node) \
172   g_return_if_fail( \
173     ((InfcBrowserNode*)node)-&gt;type == INFC_BROWSER_NODE_SUBDIRECTORY \
174   )
175 #define infc_browser_return_val_if_subdir_fail(node, val) \
176   g_return_val_if_fail( \
177     ((InfcBrowserNode*)node)-&gt;type == INFC_BROWSER_NODE_SUBDIRECTORY, \
178     val \
179   )
180 static GQuark infc_browser_session_proxy_quark;
181 static GQuark infc_browser_sync_in_session_quark;
182 static GQuark infc_browser_sync_in_plugin_quark;
183 static GQuark infc_browser_lookup_acl_accounts_ids_quark;
184 static GQuark infc_browser_lookup_acl_accounts_n_ids_quark;
185 static GQuark infc_browser_lookup_acl_accounts_name_quark;
186 static GQuark infc_browser_query_acl_account_list_accounts_quark;
187 static void infc_browser_communication_object_iface_init(InfCommunicationObjectInterface* iface);
188 static void infc_browser_browser_iface_init(InfBrowserInterface* iface);
189 G_DEFINE_TYPE_WITH_CODE(InfcBrowser, infc_browser, G_TYPE_OBJECT,
190   G_ADD_PRIVATE(InfcBrowser)
191   G_IMPLEMENT_INTERFACE(INF_COMMUNICATION_TYPE_OBJECT, infc_browser_communication_object_iface_init)
192   G_IMPLEMENT_INTERFACE(INF_TYPE_BROWSER, infc_browser_browser_iface_init))
193 static void
194 infc_browser_make_acl_account_list_foreach_func(gpointer key,
195                                                 gpointer value,
196                                                 gpointer user_data)
197 {
198   InfcBrowserMakeAclAccountListData* data;
199   data = (InfcBrowserMakeAclAccountListData*)user_data;
200   data-&gt;accounts[data-&gt;index++] = *(const InfAclAccount*)value;
201 }
202 static void
203 infc_browser_browser_lookup_acl_account_by_name_find_func(gpointer key,
204                                                           gpointer value,
205                                                           gpointer user_data)
206 {
207   const InfcBrowserLookupAclAccountByByNameData* data;
208   const InfAclAccount* acc;
209   data = (InfcBrowserLookupAclAccountByByNameData*)user_data;
210   acc = (const InfAclAccount*)value;
211   if(acc-&gt;name != NULL)
212    if(strcmp(acc-&gt;name, data-&gt;name) == 0)
213      g_array_append_val(data-&gt;accounts, *acc);
214 }
215 InfAclAccount*
216 infc_browser_make_acl_account_list(InfcBrowser* browser,
217                                    guint* n_accounts)
218 {
219   InfcBrowserPrivate* priv;
220   InfcBrowserMakeAclAccountListData data;
221   guint n;
222   priv = INFC_BROWSER_PRIVATE(browser);
223   n = g_hash_table_size(priv-&gt;accounts);
224   data.index = 0;
225   data.accounts = g_malloc(sizeof(InfAclAccount) * n);
226   g_hash_table_foreach(
227     priv-&gt;accounts,
228     infc_browser_make_acl_account_list_foreach_func,
229     &amp;data
230   );
231   g_assert(data.index == n);
232   if(n_accounts != NULL) *n_accounts = n;
233   return data.accounts;
234 }
235 static void
236 infc_browser_browser_list_pending_requests_foreach_func(InfcRequest* request,
237                                                         gpointer user_data)
238 {
239   InfcBrowserListPendingRequestsForeachData* data;
240   guint node_id;
241   data = (InfcBrowserListPendingRequestsForeachData*)user_data;
242   g_object_get(G_OBJECT(request), "node-id", &amp;node_id, NULL);
243   if(node_id == G_MAXUINT)
244   {
245     if(data-&gt;iter == NULL)
246       data-&gt;result = g_slist_prepend(data-&gt;result, request);
247   }
248   else
249   {
250     if(data-&gt;iter != NULL &amp;&amp; node_id == data-&gt;iter-&gt;node_id)
251       data-&gt;result = g_slist_prepend(data-&gt;result, request);
252   }
253 }
254 static void
255 infc_browser_iter_get_sync_in_requests_foreach_func(InfcRequest* request,
256                                                     gpointer user_data)
257 {
258   InfcBrowserIterGetSyncInRequestsForeachData* data;
259   InfSession* session;
260   guint node_id;
261   data = (InfcBrowserIterGetSyncInRequestsForeachData*)user_data;
262   session = g_object_get_qdata(
263     G_OBJECT(request),
264     infc_browser_sync_in_session_quark
265   );
266   if(session != NULL)
267   {
268     g_object_get(G_OBJECT(request), "node-id", &amp;node_id, NULL);
269     if(node_id != G_MAXUINT &amp;&amp; node_id == data-&gt;iter-&gt;node_id)
270       data-&gt;result = g_slist_prepend(data-&gt;result, request);
271   }
272 }
273 static void
274 infc_browser_get_chat_request_foreach_func(InfcRequest* request,
275                                            gpointer user_data)
276 {
277   InfcBrowserIterGetChatRequestForeachData* data;
278   data = (InfcBrowserIterGetChatRequestForeachData*)user_data;
279   g_assert(data-&gt;result == NULL);
280   data-&gt;result = request;
281 }
282 static void
283 infc_browser_node_get_path_string(InfcBrowserNode* node,
284                                    GString* string)
285 {
286   g_return_if_fail(node != NULL);
287   g_return_if_fail(string != NULL);
288   if(node-&gt;parent != NULL)
289   {
290     g_assert(node-&gt;name != NULL);
291     if(node-&gt;parent-&gt;parent != NULL)
292       infc_browser_node_get_path_string(node-&gt;parent, string);
293     g_string_append_c(string, '/');
294     g_string_append(string, node-&gt;name);
295   }
296   else
297   {
298     g_assert(node-&gt;name == NULL);
299     g_string_append_c(string, '/');
300   }
301 }
302 static void
303 infc_browser_node_get_path(InfcBrowserNode* node,
304                            gchar** path,
305                            gsize* len)
306 {
307   GString* str;
308   g_return_if_fail(node != NULL);
309   g_return_if_fail(path != NULL);
310   str = g_string_sized_new(128);
311   infc_browser_node_get_path_string(node, str);
312   *path = str-&gt;str;
313   if(len != NULL)
314     *len = str-&gt;len;
315   g_string_free(str, FALSE);
316 }
317 static void
318 infc_browser_node_link(InfcBrowserNode* node,
319                        InfcBrowserNode* parent)
320 {
321   g_assert(parent != NULL);
322   g_assert(parent-&gt;type == INFC_BROWSER_NODE_SUBDIRECTORY);
323   node-&gt;prev = NULL;
324   if(parent-&gt;shared.subdir.child != NULL)
325   {
326     parent-&gt;shared.subdir.child-&gt;prev = node;
327     node-&gt;next = parent-&gt;shared.subdir.child;
328   }
329   else
330   {
331     node-&gt;next = NULL;
332   }
333   parent-&gt;shared.subdir.child = node;
334 }
335 static void
336 infc_browser_node_unlink(InfcBrowserNode* node)
337 {
338   g_assert(node-&gt;parent != NULL);
339   g_assert(node-&gt;parent-&gt;type == INFC_BROWSER_NODE_SUBDIRECTORY);
340   if(node-&gt;prev != NULL)
341     node-&gt;prev-&gt;next = node-&gt;next;
342   else
343     node-&gt;parent-&gt;shared.subdir.child = node-&gt;next;
344   if(node-&gt;next != NULL)
345     node-&gt;next-&gt;prev = node-&gt;prev;
346 }
347 static InfcBrowserNode*
348 infc_browser_node_new_common(InfcBrowser* browser,
349                              InfcBrowserNode* parent,
350                              guint id,
351                              InfcBrowserNodeType type,
352                              const gchar* name,
353                              const InfAclSheetSet* sheet_set)
354 {
355   InfcBrowserPrivate* priv;
356   InfcBrowserNode* node;
357   InfBrowserIter iter;
358   priv = INFC_BROWSER_PRIVATE(browser);
359   node = g_slice_new(InfcBrowserNode);
360   node-&gt;parent = parent;
361   node-&gt;id = id;
362   node-&gt;name = g_strdup(name);
363   node-&gt;type = type;
364   if(sheet_set != NULL)
365     node-&gt;acl = inf_acl_sheet_set_copy(sheet_set);
366   else
367     node-&gt;acl = NULL;
368   node-&gt;acl_queried = FALSE;
369   if(parent != NULL)
370   {
371     infc_browser_node_link(node, parent);
372   }
373   else
374   {
375     node-&gt;prev = NULL;
376     node-&gt;next = NULL;
377   }
378   g_assert(
379     g_hash_table_lookup(priv-&gt;nodes, GUINT_TO_POINTER(node-&gt;id)) == NULL
380   );
381   g_hash_table_insert(priv-&gt;nodes, GUINT_TO_POINTER(node-&gt;id), node);
382   return node;
383 }
384 static InfcBrowserNode*
385 infc_browser_node_new_subdirectory(InfcBrowser* browser,
386                                    InfcBrowserNode* parent,
387                                    guint id,
388                                    const gchar* name,
389                                    const InfAclSheetSet* sheet_set)
390 {
391   InfcBrowserNode* node;
392   node = infc_browser_node_new_common(
393     browser,
394     parent,
395     id,
396     INFC_BROWSER_NODE_SUBDIRECTORY,
397     name,
398     sheet_set
399   );
400   node-&gt;shared.subdir.explored = FALSE;
401   node-&gt;shared.subdir.child = NULL;
402   return node;
403 }
404 static InfcBrowserNode*
405 infc_browser_node_new_note(InfcBrowser* browser,
406                            InfcBrowserNode* parent,
407                            guint id,
408                            const gchar* name,
409                            const gchar* type,
410                            const InfAclSheetSet* sheet_set)
411 {
412   InfcBrowserPrivate* priv;
413   InfcBrowserNode* node;
414   InfcNotePlugin* plugin;
415   priv = INFC_BROWSER_PRIVATE(browser);
416   plugin = g_hash_table_lookup(priv-&gt;plugins, type);
417   node = infc_browser_node_new_common(
418     browser,
419     parent,
420     id,
421     (plugin != NULL) ? INFC_BROWSER_NODE_NOTE_KNOWN :
422       INFC_BROWSER_NODE_NOTE_UNKNOWN,
423     name,
424     sheet_set
425   );
426   if(plugin != NULL)
427   {
428     node-&gt;shared.known.plugin = plugin;
429     node-&gt;shared.known.session = NULL;
430   }
431   else
432   {
433     node-&gt;shared.unknown.type = g_strdup(type);
434   }
435   return node;
436 }
437 static void
438 infc_browser_session_notify_subscription_group_cb(InfSession* session,
439                                                   const GParamSpec* pspec,
440                                                   gpointer user_data);
441 static void
442 infc_browser_session_remove_session(InfcBrowser* browser,
443                                     InfcBrowserNode* node,
444                                     InfcRequest* request)
445 {
446   InfSession* session;
447   InfcSessionProxy* proxy;
448   InfBrowserIter iter;
449   g_assert(node-&gt;type == INFC_BROWSER_NODE_NOTE_KNOWN);
450   g_assert(node-&gt;shared.known.session != NULL);
451   proxy = node-&gt;shared.known.session;
452   g_object_get(G_OBJECT(proxy), "session", &amp;session, NULL);
453   inf_signal_handlers_disconnect_by_func(
454     session,
455     G_CALLBACK(infc_browser_session_notify_subscription_group_cb),
456     browser
457   );
458   g_object_set_qdata(
459     G_OBJECT(session),
460     infc_browser_session_proxy_quark,
461     NULL
462   );
463   node-&gt;shared.known.session = NULL;
464   inf_browser_unsubscribe_session(
465     INF_BROWSER(browser),
466     &amp;iter,
467     INF_SESSION_PROXY(proxy),
468     INF_REQUEST(request)
469   );
470   g_object_unref(session);
471   g_object_unref(proxy);
472 }
473 static void
474 infc_browser_session_remove_child_sessions(InfcBrowser* browser,
475                                            InfcBrowserNode* node,
476                                            InfcRequest* request)
477 {
478   InfcBrowserNode* child;
479   switch(node-&gt;type)
480   {
481   case INFC_BROWSER_NODE_SUBDIRECTORY:
482     if(node-&gt;shared.subdir.explored == TRUE)
483     {
484       for(child = node-&gt;shared.subdir.child;
485           child != NULL;
486           child = child-&gt;next)
487       {
488         infc_browser_session_remove_child_sessions(browser, child, request);
489       }
490     }
491     break;
492   case INFC_BROWSER_NODE_NOTE_KNOWN:
493     if(node-&gt;shared.known.session != NULL)
494       infc_browser_session_remove_session(browser, node, request);
495     break;
496   case INFC_BROWSER_NODE_NOTE_UNKNOWN:
497     break;
498   }
499 }
500 static void
501 infc_browser_node_register(InfcBrowser* browser,
502                            InfcBrowserNode* node,
503                            InfcRequest* request)
504 {
505   InfBrowserIter iter;
506   iter.node_id = node-&gt;id;
507   iter.node = node;
508   inf_browser_node_added(INF_BROWSER(browser), &amp;iter, INF_REQUEST(request));
509 }
510 static void
511 infc_browser_node_unregister(InfcBrowser* browser,
512                              InfcBrowserNode* node,
513                              InfcRequest* request)
514 {
515   InfBrowserIter iter;
516   iter.node_id = node-&gt;id;
517   iter.node = node;
518   inf_browser_node_removed(INF_BROWSER(browser), &amp;iter, INF_REQUEST(request));
519 }
520 static void
521 infc_browser_remove_sync_in(InfcBrowser* browser,
522                             InfcBrowserSyncIn* sync_in);
523 static void
524 infc_browser_remove_subreq(InfcBrowser* browser,
525                            InfcBrowserSubreq* request);
526 static void
527 infc_browser_node_free(InfcBrowser* browser,
528                        InfcBrowserNode* node)
529 {
530   InfcBrowserPrivate* priv;
531   gboolean removed;
532   GSList* item;
533   InfcBrowserSyncIn* sync_in;
534   InfcBrowserSubreq* request;
535   InfBrowserIter iter;
536   GError* error;
537   priv = INFC_BROWSER_PRIVATE(browser);
538   switch(node-&gt;type)
539   {
540   case INFC_BROWSER_NODE_SUBDIRECTORY:
541     while(node-&gt;shared.subdir.child != NULL)
542       infc_browser_node_free(browser, node-&gt;shared.subdir.child);
543     break;
544   case INFC_BROWSER_NODE_NOTE_KNOWN:
545     g_assert(node-&gt;shared.known.session == NULL);
546     break;
547   case INFC_BROWSER_NODE_NOTE_UNKNOWN:
548     g_free(node-&gt;shared.unknown.type);
549     break;
550   default:
551     g_assert_not_reached();
552     break;
553   }
554   for(item = priv-&gt;sync_ins; item != NULL; )
555   {
556     sync_in = (InfcBrowserSyncIn*)item-&gt;data;
557     item = item-&gt;next;
558     if(sync_in-&gt;node == node)
559       infc_browser_remove_sync_in(browser, sync_in);
560   }
561   for(item = priv-&gt;subscription_requests; item != NULL; )
562   {
563     request = (InfcBrowserSubreq*)item-&gt;data;
564     item = item-&gt;next;
565     switch(request-&gt;type)
566     {
567     case INFC_BROWSER_SUBREQ_SESSION:
568       if(request-&gt;shared.session.node == node)
569       {
570         request-&gt;shared.session.node = NULL;
571         if(request-&gt;shared.session.request != NULL)
572         {
573           error = g_error_new_literal(
574             inf_directory_error_quark(),
575             INF_DIRECTORY_ERROR_NO_SUCH_NODE,
576             _("The node to subscribe to has been removed")
577           );
578           infc_request_manager_fail_request(
579             priv-&gt;request_manager,
580             INFC_REQUEST(request-&gt;shared.session.request),
581             error
582           );
583           g_error_free(error);
584           g_object_unref(request-&gt;shared.session.request);
585           request-&gt;shared.session.request = NULL;
586         }
587       }
588       break;
589     case INFC_BROWSER_SUBREQ_ADD_NODE:
590       if(request-&gt;shared.add_node.parent == node)
591       {
592         request-&gt;shared.add_node.parent = NULL;
593         if(request-&gt;shared.add_node.request != NULL)
594         {
595           error = g_error_new_literal(
596             inf_directory_error_quark(),
597             INF_DIRECTORY_ERROR_NO_SUCH_NODE,
598             _("The subdirectory into which the new node should have been "
599               "created has been removed")
600           );
601           infc_request_manager_fail_request(
602             priv-&gt;request_manager,
603             INFC_REQUEST(request-&gt;shared.add_node.request),
604             error
605           );
606           g_error_free(error);
607           g_object_unref(request-&gt;shared.add_node.request);
608           request-&gt;shared.add_node.request = NULL;
609         }
610       }
611       break;
612     case INFC_BROWSER_SUBREQ_SYNC_IN:
613       if(request-&gt;shared.sync_in.parent == node)
614       {
615         request-&gt;shared.sync_in.parent = NULL;
616         g_assert(request-&gt;shared.sync_in.request != NULL);
617         error = g_error_new_literal(
618           inf_directory_error_quark(),
619           INF_DIRECTORY_ERROR_NO_SUCH_NODE,
620           _("The subdirectory into which the new node should have been "
621             "created has been removed")
622         );
623         infc_request_manager_fail_request(
624           priv-&gt;request_manager,
625           INFC_REQUEST(request-&gt;shared.sync_in.request),
626           error
627         );
628         g_error_free(error);
629         g_object_unref(request-&gt;shared.sync_in.request);
630         request-&gt;shared.sync_in.request = NULL;
631       }
632       break;
633     default:
634       g_assert_not_reached();
635       break;
636     }
637   }
638   if(node-&gt;parent != NULL)
639     infc_browser_node_unlink(node);
640   if(node-&gt;acl != NULL)
641     inf_acl_sheet_set_free(node-&gt;acl);
642   removed = g_hash_table_remove(priv-&gt;nodes, GUINT_TO_POINTER(node-&gt;id));
643   g_assert(removed == TRUE);
644   g_free(node-&gt;name);
645   g_slice_free(InfcBrowserNode, node);
646 }
647 static void
648 infc_browser_remove_acl_sheet_from_sheet_set(InfAclSheetSet* sheet_set,
649                                              InfAclAccountId account)
650 {
651   InfAclSheet* sheet;
652   if(sheet_set != NULL)
653   {
654     sheet = inf_acl_sheet_set_find_sheet(sheet_set, account);
655     if(sheet != NULL)
656       inf_acl_sheet_set_remove_sheet(sheet_set, sheet);
657   }
658 }
659 static void
660 infc_browser_remove_account_from_sheets(InfcBrowser* browser,
661                                         InfcBrowserNode* node,
662                                         InfAclAccountId account)
663 {
664   InfcBrowserNode* child;
665   InfAclSheet* sheet;
666   InfAclSheet announce_sheet;
667   InfAclSheetSet sheet_set;
668   InfBrowserIter iter;
669   if(node-&gt;type == INFC_BROWSER_NODE_SUBDIRECTORY &amp;&amp;
670      node-&gt;shared.subdir.explored)
671   {
672     for(child = node-&gt;shared.subdir.child; child != NULL; child = child-&gt;next)
673     {
674       infc_browser_remove_account_from_sheets(browser, child, account);
675     }
676   }
677   if(node-&gt;acl != NULL)
678   {
679     sheet = inf_acl_sheet_set_find_sheet(node-&gt;acl, account);
680     if(sheet != NULL)
681     {
682       announce_sheet = *sheet;
683       inf_acl_sheet_set_remove_sheet(node-&gt;acl, sheet);
684       inf_acl_mask_clear(&amp;announce_sheet.mask);
685       sheet_set.own_sheets = NULL;
686       sheet_set.sheets = &amp;announce_sheet;
687       sheet_set.n_sheets = 1;
688       iter.node = node;
689       iter.node_id = node-&gt;id;
690       inf_browser_acl_changed(INF_BROWSER(browser), &amp;iter, &amp;sheet_set, NULL);
691     }
692   }
693 }
694 static void
695 infc_browser_enforce_single_acl(InfcBrowser* browser,
696                                 InfcBrowserNode* node,
697                                 InfcRequest* request,
698                                 const InfAclSheet* new_sheet)
699 {
700   InfcBrowserPrivate* priv;
701   InfBrowser* ibrowser;
702   InfBrowserIter iter;
703   InfAclAccountId account;
704   InfAclMask mask;
705   InfcRequest* req;
706   GError* error;
707   InfcBrowserNode* child;
708   GSList* item;
709   InfcBrowserSubreq* subreq;
710   InfAclAccountId default_id;
711   InfAclSheetSet* sheet_set;
712   InfAclSheet* sheet;
713   InfAclSheet* added_sheet;
714   priv = INFC_BROWSER_PRIVATE(browser);
715   ibrowser = INF_BROWSER(browser);
716   iter.node = node;
717   iter.node_id = node-&gt;id;
718   account = priv-&gt;local_account-&gt;id;
719   g_assert(new_sheet == NULL || new_sheet-&gt;account == account);
720   if(node-&gt;type == INFC_BROWSER_NODE_SUBDIRECTORY)
721   {
722     if(node-&gt;shared.subdir.explored == TRUE)
723     {
724       inf_acl_mask_set1(&amp;mask, INF_ACL_CAN_EXPLORE_NODE);
725       if(!inf_browser_check_acl(ibrowser, &amp;iter, account, &amp;mask, NULL))
726       {
727         req = INFC_REQUEST(
728           inf_browser_get_pending_request(
729             ibrowser,
730             &amp;iter,
731             "explore-node"
732           )
733         );
734         if(req != NULL)
735         {
736           error = NULL;
737           g_set_error_literal(
738             &amp;error,
739             inf_request_error_quark(),
740             INF_REQUEST_ERROR_NOT_AUTHORIZED,
741             _("Permissions to explore this node have been revoked")
742           );
743           infc_request_manager_fail_request(priv-&gt;request_manager, req, error);
744           g_error_free(error);
745         }
746         while(node-&gt;shared.subdir.child != NULL)
747         {
748           child = node-&gt;shared.subdir.child;
749           infc_browser_node_unregister(browser, child, request);
750           infc_browser_node_free(browser, child);
751         }
752         for(item = priv-&gt;subscription_requests; item != NULL; )
753         {
754           subreq = (InfcBrowserSubreq*)item-&gt;data;
755           item = item-&gt;next;
756           switch(subreq-&gt;type)
757           {
758           case INFC_BROWSER_SUBREQ_CHAT:
759           case INFC_BROWSER_SUBREQ_SESSION:
760             break;
761           case INFC_BROWSER_SUBREQ_ADD_NODE:
762             if(subreq-&gt;shared.add_node.parent == node)
763             {
764               subreq-&gt;shared.add_node.parent = NULL;
765               if(subreq-&gt;shared.add_node.request != NULL)
766               {
767                 error = NULL;
768                 g_set_error_literal(
769                   &amp;error,
770                   inf_request_error_quark(),
771                   INF_REQUEST_ERROR_NOT_AUTHORIZED,
772                   _("Permissions to explore the parent node "
773                     "have been revoked")
774                 );
775                 infc_request_manager_fail_request(
776                   priv-&gt;request_manager,
777                   subreq-&gt;shared.add_node.request,
778                   error
779                 );
780                 g_error_free(error);
781                 g_object_unref(subreq-&gt;shared.add_node.request);
782                 subreq-&gt;shared.add_node.request = NULL;
783               }
784             }
785             break;
786           case INFC_BROWSER_SUBREQ_SYNC_IN:
787             if(subreq-&gt;shared.sync_in.parent == node)
788             {
789               subreq-&gt;shared.sync_in.parent = NULL;
790               if(subreq-&gt;shared.sync_in.request != NULL)
791               {
792                 error = NULL;
793                 g_set_error_literal(
794                   &amp;error,
795                   inf_request_error_quark(),
796                   INF_REQUEST_ERROR_NOT_AUTHORIZED,
797                   _("Permissions to explore the parent node "
798                     "have been revoked")
799                 );
800                 infc_request_manager_fail_request(
801                   priv-&gt;request_manager,
802                   subreq-&gt;shared.sync_in.request,
803                   error
804                 );
805                 g_error_free(error);
806                 g_object_unref(subreq-&gt;shared.sync_in.request);
807                 subreq-&gt;shared.sync_in.request = NULL;
808               }
809             }
810             break;
811           default:
812             g_assert_not_reached();
813             break;
814           }
815         }
816         node-&gt;shared.subdir.explored = FALSE;
817       }
818     }
819   }
820   else
821   {
822   }
823   if(node-&gt;acl_queried == TRUE)
824   {
825     inf_acl_mask_set1(&amp;mask, INF_ACL_CAN_QUERY_ACL);
826     if(inf_browser_check_acl(ibrowser, &amp;iter, account, &amp;mask, NULL) == FALSE)
827       node-&gt;acl_queried = FALSE;
828   }
829   if(node-&gt;acl_queried == FALSE)
830   {
831     if(node-&gt;acl != NULL)
832       sheet_set = inf_acl_sheet_set_get_clear_sheets(node-&gt;acl);
833     else
834       sheet_set = inf_acl_sheet_set_new();
835     default_id = inf_acl_account_id_from_string("default");
836     sheet = inf_acl_sheet_set_find_sheet(sheet_set, default_id);
837     if(sheet != NULL) inf_acl_sheet_set_remove_sheet(sheet_set, sheet);
838     if(priv-&gt;local_account-&gt;id != default_id)
839     {
840       sheet =
841         inf_acl_sheet_set_find_sheet(sheet_set, priv-&gt;local_account-&gt;id);
842       if(sheet != NULL)
843       {
844         inf_acl_sheet_set_remove_sheet(sheet_set, sheet);
845         g_assert(new_sheet == NULL);
846       }
847       else if(new_sheet != NULL)
848       {
849         added_sheet =
850           inf_acl_sheet_set_add_sheet(sheet_set, new_sheet-&gt;account);
851         *added_sheet = *new_sheet;
852       }
853     }
854     if(sheet_set != NULL &amp;&amp; sheet_set-&gt;n_sheets &gt; 0)
855     {
856       node-&gt;acl = inf_acl_sheet_set_merge_sheets(node-&gt;acl, sheet_set);
857       for(item = priv-&gt;subscription_requests; item != NULL; )
858       {
859         subreq = (InfcBrowserSubreq*)item-&gt;data;
860         item = item-&gt;next;
861         switch(subreq-&gt;type)
862         {
863         case INFC_BROWSER_SUBREQ_CHAT:
864         case INFC_BROWSER_SUBREQ_SESSION:
865           break;
866         case INFC_BROWSER_SUBREQ_ADD_NODE:
867           if(subreq-&gt;shared.add_node.parent == node)
868           {
869             subreq-&gt;shared.add_node.sheet_set =
870               inf_acl_sheet_set_merge_sheets(
871                 subreq-&gt;shared.add_node.sheet_set,
872                 sheet_set
873               );
874           }
875           break;
876         case INFC_BROWSER_SUBREQ_SYNC_IN:
877           if(subreq-&gt;shared.sync_in.parent == node)
878           {
879             subreq-&gt;shared.sync_in.sheet_set = inf_acl_sheet_set_merge_sheets(
880               subreq-&gt;shared.sync_in.sheet_set,
881               sheet_set
882             );
883           }
884           break;
885         default:
886           g_assert_not_reached();
887           break;
888         }
889       }
890       inf_browser_acl_changed(
891         INF_BROWSER(browser),
892         &amp;iter,
893         sheet_set,
894         INF_REQUEST(request)
895       );
896     }
897     inf_acl_sheet_set_free(sheet_set);
898   }
899 }
900 static void
901 infc_browser_enforce_acl(InfcBrowser* browser,
902                          InfcBrowserNode* node,
903                          InfcRequest* request,
904                          GHashTable* new_acls)
905 {
906   InfBrowser* ibrowser;
907   InfcBrowserPrivate* priv;
908   InfcBrowserNode* child;
909   InfBrowserIter iter;
910   InfAclMask mask;
911   const InfAclSheet* sheet;
912   InfAclAccountId account;
913   ibrowser = INF_BROWSER(browser);
914   priv = INFC_BROWSER_PRIVATE(browser);
915   if(node == priv-&gt;root &amp;&amp;
916      priv-&gt;account_list_status == INFC_BROWSER_ACCOUNT_LIST_NOTIFICATIONS)
917   {
918     iter.node = node;
919     iter.node_id = node-&gt;id;
920     inf_acl_mask_set1(&amp;mask, INF_ACL_CAN_QUERY_ACCOUNT_LIST);
921     account = priv-&gt;local_account-&gt;id;
922     if(inf_browser_check_acl(ibrowser, &amp;iter, account, &amp;mask, NULL) == FALSE)
923     {
924       priv-&gt;account_list_status = INFC_BROWSER_ACCOUNT_LIST_NO_NOTIFICATIONS;
925     }
926   }
927   sheet = NULL;
928   if(new_acls != NULL)
929     sheet = g_hash_table_lookup(new_acls, GUINT_TO_POINTER(node-&gt;id));
930   infc_browser_enforce_single_acl(browser, node, request, sheet);
931   if(node-&gt;type == INFC_BROWSER_NODE_SUBDIRECTORY)
932   {
933     for(child = node-&gt;shared.subdir.child; child != NULL; child = child-&gt;next)
934     {
935       infc_browser_enforce_acl(browser, child, request, new_acls);
936     }
937   }
938 }
939 static void
940 infc_browser_session_notify_subscription_group_cb(InfSession* session,
941                                                   const GParamSpec* spec,
942                                                   gpointer user_data)
943 {
944   InfcBrowser* browser;
945   InfcBrowserPrivate* priv;
946   InfBrowserIter* iter;
947   InfcBrowserNode* node;
948   InfcSessionProxy* proxy;
949   InfSession* proxy_session;
950   browser = INFC_BROWSER(user_data);
951   priv = INFC_BROWSER_PRIVATE(browser);
952   if(inf_session_get_subscription_group(session) == NULL)
953   {
954     iter = (InfBrowserIter*)g_object_get_qdata(
955       G_OBJECT(session),
956       infc_browser_session_proxy_quark
957     );
958     if(iter != NULL)
959     {
960       g_assert(
961         g_hash_table_lookup(
962           INFC_BROWSER_PRIVATE(browser)-&gt;nodes,
963           GUINT_TO_POINTER(iter-&gt;node_id)
964         ) == iter-&gt;node
965       );
966       node = (InfcBrowserNode*)iter-&gt;node;
967       g_assert(node-&gt;type == INFC_BROWSER_NODE_NOTE_KNOWN);
968       g_assert(node-&gt;shared.known.session != NULL);
969       g_object_get(
970         G_OBJECT(node-&gt;shared.known.session),
971         "session", &amp;proxy_session,
972         NULL
973       );
974       g_assert(proxy_session == session);
975       g_object_unref(proxy_session);
976       infc_browser_session_remove_session(browser, node, NULL);
977     }
978     else
979     {
980       g_assert(priv-&gt;chat_session != NULL);
981       g_object_get(
982         G_OBJECT(priv-&gt;chat_session),
983         "session", &amp;proxy_session,
984         NULL
985       );
986       g_assert(proxy_session == session);
987       inf_signal_handlers_disconnect_by_func(
988         proxy_session,
989         G_CALLBACK(infc_browser_session_notify_subscription_group_cb),
990         browser
991       );
992       g_object_unref(proxy_session);
993       proxy = priv-&gt;chat_session;
994       priv-&gt;chat_session = NULL;
995       g_object_notify(G_OBJECT(browser), "chat-session");
996       inf_browser_unsubscribe_session(
997         INF_BROWSER(browser),
998         NULL,
999         INF_SESSION_PROXY(proxy),
1000         NULL
1001       );
1002       g_object_unref(proxy);
1003     }
1004   }
1005 }
1006 static void
1007 infc_browser_welcome_timeout_func(gpointer user_data)
1008 {
1009   InfcBrowser* browser;
1010   InfcBrowserPrivate* priv;
1011   GError* error;
1012   browser = INFC_BROWSER(user_data);
1013   priv = INFC_BROWSER_PRIVATE(browser);
1014   priv-&gt;welcome_timeout = NULL;
1015   error = NULL;
1016   g_set_error_literal(
1017     &amp;error,
1018     inf_directory_error_quark(),
1019     INF_DIRECTORY_ERROR_NO_WELCOME_MESSAGE,
1020     _("The server did not send an initial welcome message. This means that "
1021       "the server is running a lower version of the software which is "
1022       "incompatible to the client. Consider downgrading the client, or ask "
1023       "the server administrators to upgrade their software.")
1024   );
1025   inf_browser_error(INF_BROWSER(browser), error);
1026   g_error_free(error);
1027   g_assert(priv-&gt;status != INF_BROWSER_CLOSED);
1028   priv-&gt;status = INF_BROWSER_CLOSED;
1029   g_object_notify(G_OBJECT(browser), "status");
1030 }
1031 static void
1032 infc_browser_member_removed_cb(InfCommunicationGroup* group,
1033                                InfXmlConnection* connection,
1034                                gpointer user_data);
1035 static void
1036 infc_browser_connected(InfcBrowser* browser)
1037 {
1038   InfcBrowserPrivate* priv;
1039   priv = INFC_BROWSER_PRIVATE(browser);
1040   g_assert(priv-&gt;group == NULL);
1041   priv-&gt;group = inf_communication_manager_join_group(
1042     priv-&gt;communication_manager,
1043     "InfDirectory",
1044     priv-&gt;connection,
1045     "central"
1046   );
1047   g_assert(priv-&gt;group != NULL);
1048   inf_communication_group_set_target(
1049     INF_COMMUNICATION_GROUP(priv-&gt;group),
1050     INF_COMMUNICATION_OBJECT(browser)
1051   );
1052   g_signal_connect(
1053     priv-&gt;group,
1054     "member-removed",
1055     G_CALLBACK(infc_browser_member_removed_cb),
1056     browser
1057   );
1058   if(priv-&gt;status != INF_BROWSER_OPENING)
1059   {
1060     priv-&gt;status = INF_BROWSER_OPENING;
1061     g_object_notify(G_OBJECT(browser), "status");
1062   }
1063   g_assert(priv-&gt;welcome_timeout == NULL);
1064   priv-&gt;welcome_timeout = inf_io_add_timeout(
1065     priv-&gt;io,
1066     5*1000,
1067     infc_browser_welcome_timeout_func,
1068     browser,
1069     NULL
1070   );
1071 }
1072 static void
1073 infc_browser_disconnected(InfcBrowser* browser)
1074 {
1075   InfcBrowserPrivate* priv;
1076   InfcBrowserNode* child;
1077   InfcBrowserNode* next;
1078   InfSession* session;
1079   InfBrowserIter iter;
1080   priv = INFC_BROWSER_PRIVATE(browser);
1081   while(priv-&gt;sync_ins != NULL)
1082     infc_browser_remove_sync_in(browser, priv-&gt;sync_ins-&gt;data);
1083   while(priv-&gt;subscription_requests != NULL)
1084     infc_browser_remove_subreq(browser, priv-&gt;subscription_requests-&gt;data);
1085   if(priv-&gt;request_manager)
1086   {
1087     infc_request_manager_clear(priv-&gt;request_manager);
1088     g_object_unref(priv-&gt;request_manager);
1089     priv-&gt;request_manager = NULL;
1090   }
1091   inf_signal_handlers_disconnect_by_func(
1092     G_OBJECT(priv-&gt;group),
1093     G_CALLBACK(infc_browser_member_removed_cb),
1094     browser
1095   );
1096   g_object_unref(priv-&gt;group);
1097   priv-&gt;group = NULL;
1098 #if 0
1099   for(child = priv-&gt;root-&gt;shared.subdir.child; child != NULL; child = next)
1100   {
1101     next = child-&gt;next;
1102     infc_browser_node_unregister(browser, child);
1103     infc_browser_node_free(browser, child);
1104   }
1105 #endif
1106   if(priv-&gt;root != NULL)
1107   {
1108     infc_browser_session_remove_child_sessions(browser, priv-&gt;root, NULL);
1109     infc_browser_node_unregister(browser, priv-&gt;root, NULL);
1110     infc_browser_node_free(browser, priv-&gt;root);
1111     priv-&gt;root = NULL;
1112   }
1113   priv-&gt;account_list_status = INFC_BROWSER_ACCOUNT_LIST_NOT_QUERIED;
1114   priv-&gt;local_account = NULL;
1115   if(priv-&gt;accounts != NULL)
1116   {
1117     g_hash_table_destroy(priv-&gt;accounts);
1118     priv-&gt;accounts = NULL;
1119   }
1120   g_object_freeze_notify(G_OBJECT(browser));
1121   if(priv-&gt;chat_session != NULL)
1122   {
1123     g_object_get(G_OBJECT(priv-&gt;chat_session), "session", &amp;session, NULL);
1124     inf_signal_handlers_disconnect_by_func(
1125       session,
1126       G_CALLBACK(infc_browser_session_notify_subscription_group_cb),
1127       browser
1128     );
1129     g_object_unref(session);
1130     g_object_unref(priv-&gt;chat_session);
1131     priv-&gt;chat_session = NULL;
1132     g_object_notify(G_OBJECT(browser), "chat-session");
1133   }
1134   if(priv-&gt;welcome_timeout != NULL)
1135   {
1136     inf_io_remove_timeout(priv-&gt;io, priv-&gt;welcome_timeout);
1137     priv-&gt;welcome_timeout = NULL;
1138   }
1139   priv-&gt;status = INF_BROWSER_CLOSED;
1140   g_object_notify(G_OBJECT(browser), "status");
1141   g_object_thaw_notify(G_OBJECT(browser));
1142 }
1143 static void
1144 infc_browser_member_removed_cb(InfCommunicationGroup* group,
1145                                InfXmlConnection* connection,
1146                                gpointer user_data)
1147 {
1148   InfcBrowser* browser;
1149   InfcBrowserPrivate* priv;
1150   browser = INFC_BROWSER(user_data);
1151   priv = INFC_BROWSER_PRIVATE(browser);
1152   g_assert(INF_COMMUNICATION_GROUP(priv-&gt;group) == group);
1153   if(connection == priv-&gt;connection)
1154     infc_browser_disconnected(browser);
1155 }
1156 static void
1157 infc_browser_connection_notify_status_cb(GObject* object,
1158                                          GParamSpec* pspec,
1159                                          gpointer user_data)
1160 {
1161   InfcBrowser* browser;
1162   InfcBrowserPrivate* priv;
1163   InfXmlConnectionStatus status;
1164   browser = INFC_BROWSER(user_data);
1165   priv = INFC_BROWSER_PRIVATE(browser);
1166   g_object_get(object, "status", &amp;status, NULL);
1167   switch(status)
1168   {
1169   case INF_XML_CONNECTION_OPENING:
1170     if(priv-&gt;status != INF_BROWSER_OPENING)
1171     {
1172       priv-&gt;status = INF_BROWSER_OPENING;
1173       g_object_notify(G_OBJECT(browser), "status");
1174     }
1175     break;
1176   case INF_XML_CONNECTION_OPEN:
1177     infc_browser_connected(browser);
1178     break;
1179   case INF_XML_CONNECTION_CLOSING:
1180   case INF_XML_CONNECTION_CLOSED:
1181     if(priv-&gt;group == NULL &amp;&amp; priv-&gt;status != INF_BROWSER_CLOSED)
1182     {
1183       g_assert(priv-&gt;request_manager == NULL);
1184       priv-&gt;status = INF_BROWSER_CLOSED;
1185       g_object_notify(G_OBJECT(browser), "status");
1186     }
1187     break;
1188   default:
1189     g_assert_not_reached();
1190     break;
1191   }
1192 }
1193 static void
1194 infc_browser_connection_error_cb(InfXmlConnection* connection,
1195                                  const GError* error,
1196                                  gpointer user_data)
1197 {
1198   InfcBrowser* browser;
1199   browser = INFC_BROWSER(user_data);
1200   inf_browser_error(INF_BROWSER(browser), error);
1201 }
1202 static xmlNodePtr
1203 infc_browser_request_to_xml(InfcRequest* request)
1204 {
1205   xmlNodePtr xml;
1206   gchar* type;
1207   guint seq;
1208   gchar seq_buffer[16];
1209   g_object_get(G_OBJECT(request), "type", &amp;type, "seq", &amp;seq, NULL);
1210   sprintf(seq_buffer, "%u", seq);
1211   xml = xmlNewNode(NULL, (const xmlChar*)type);
1212   xmlNewProp(xml, (const xmlChar*)"seq", (const xmlChar*)seq_buffer);
1213   g_free(type);
1214   return xml;
1215 }
1216 static GError*
1217 infc_browser_method_unsupported_error(const gchar* method_name,
1218                                       InfXmlConnection* connection)
1219 {
1220   GError* error;
1221   gchar* network;
1222   g_object_get(G_OBJECT(connection), "network", &amp;network, NULL);
1223   error = g_error_new(
1224     inf_directory_error_quark(),
1225     INF_DIRECTORY_ERROR_METHOD_UNSUPPORTED,
1226     _("This session requires communication method `%s' which is not "
1227       "installed for network `%s'"),
1228     method_name,
1229     network
1230   );
1231 <a name="2"></a>
1232   g_free(network);
1233   return error;
1234 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
1235 static void
1236 infc_browser_init(InfcBrowser* browser)
1237 {
1238   InfcBrowserPrivate* priv;
1239   priv = INFC_BROWSER_PRIVATE(browser);
1240   priv-&gt;io = NULL;
1241   priv-&gt;communication_manager = NULL;
1242   priv-&gt;group = NULL;
1243   priv-&gt;connection = NULL;
1244   priv-&gt;seq_id = 0;</b></font>
1245   priv-&gt;welcome_timeout = NULL;
1246   priv-&gt;request_manager = NULL;
1247   priv-&gt;plugins = g_hash_table_new(g_str_hash, g_str_equal);
1248   priv-&gt;status = INF_BROWSER_CLOSED;
1249   priv-&gt;nodes = g_hash_table_new(NULL, NULL);
1250   priv-&gt;root = NULL;
1251   priv-&gt;accounts = NULL;
1252   priv-&gt;local_account = NULL;
1253   priv-&gt;account_list_status = INFC_BROWSER_ACCOUNT_LIST_NOT_QUERIED;
1254   priv-&gt;sync_ins = NULL;
1255   priv-&gt;subscription_requests = NULL;
1256   priv-&gt;chat_session = NULL;
1257 }
1258 static void
1259 infc_browser_dispose(GObject* object)
1260 {
1261   InfcBrowser* browser;
1262   InfcBrowserPrivate* priv;
1263   InfSession* session;
1264   browser = INFC_BROWSER(object);
1265   priv = INFC_BROWSER_PRIVATE(browser);
1266 #if 0
1267   infc_browser_set_connection(browser, NULL);
1268 #else
1269   if(priv-&gt;group != NULL)
1270     infc_browser_disconnected(browser);
1271   g_assert(priv-&gt;group == NULL);
1272   g_assert(priv-&gt;accounts == NULL);
1273   g_assert(priv-&gt;sync_ins == NULL);
1274   g_assert(priv-&gt;subscription_requests == NULL);
1275   if(priv-&gt;connection != NULL)
1276   {
1277     inf_signal_handlers_disconnect_by_func(
1278       priv-&gt;connection,
1279       G_CALLBACK(infc_browser_connection_notify_status_cb),
1280       browser
1281     );
1282     inf_signal_handlers_disconnect_by_func(
1283       priv-&gt;connection,
1284       G_CALLBACK(infc_browser_connection_error_cb),
1285       browser
1286     );
1287     g_object_unref(priv-&gt;connection);
1288     priv-&gt;connection = NULL;
1289   }
1290 #endif
1291   if(priv-&gt;chat_session != NULL)
1292   {
1293     g_object_get(G_OBJECT(priv-&gt;chat_session), "session", &amp;session, NULL);
1294     inf_session_close(session);
1295     g_object_unref(session);
1296   }
1297   g_assert(priv-&gt;chat_session == NULL);
1298   g_object_unref(priv-&gt;communication_manager);
1299   priv-&gt;communication_manager = NULL;
1300   g_hash_table_destroy(priv-&gt;plugins);
1301   priv-&gt;plugins = NULL;
1302   g_assert(priv-&gt;request_manager == NULL);
1303   if(priv-&gt;welcome_timeout != NULL)
1304   {
1305     inf_io_remove_timeout(priv-&gt;io, priv-&gt;welcome_timeout);
1306     priv-&gt;welcome_timeout = NULL;
1307   }
1308   if(priv-&gt;io != NULL)
1309   {
1310     g_object_unref(G_OBJECT(priv-&gt;io));
1311     priv-&gt;io = NULL;
1312   }
1313   G_OBJECT_CLASS(infc_browser_parent_class)-&gt;dispose(object);
1314 }
1315 static void
1316 infc_browser_finalize(GObject* object)
1317 {
1318   InfcBrowser* browser;
1319 <a name="0"></a>  InfcBrowserPrivate* priv;
1320   browser = INFC_BROWSER(object);
1321 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  priv = INFC_BROWSER_PRIVATE(browser);
1322   g_hash_table_destroy(priv-&gt;nodes);
1323   priv-&gt;nodes = NULL;
1324   G_OBJECT_CLASS(infc_browser_parent_class)-&gt;finalize(object);
1325 }
1326 static void
1327 infc_browser_set_property(GObject* object,
1328                           guint prop_id,
1329                           const GValue* value,
1330                           GParamSpec* pspec)
1331 {
1332   InfcBrowser* browser;
1333   InfcBrowserPrivate* priv;
1334   InfXmlConnectionStatus status;
1335   browser = INFC_BROWSER(object);
1336   priv = INFC_BROWSER_PRIVATE(browser);
1337   switch(prop_id)
1338   {
1339   case PROP_IO:
1340     g_assert(priv-&gt;io == NULL);     priv-&gt;io = INF_IO(g_value_dup_object(value));
1341     break;
1342   case PROP_COMMUNICATION_MANAGER:</b></font>
1343     g_assert(priv-&gt;communication_manager == NULL);     priv-&gt;communication_manager =
1344       INF_COMMUNICATION_MANAGER(g_value_dup_object(value));
1345     break;
1346   case PROP_CONNECTION:
1347     if(priv-&gt;connection != NULL)
1348     {
1349       if(priv-&gt;group != NULL)
1350         infc_browser_disconnected(browser);
1351       inf_signal_handlers_disconnect_by_func(
1352         priv-&gt;connection,
1353         G_CALLBACK(infc_browser_connection_notify_status_cb),
1354         browser
1355       );
1356       inf_signal_handlers_disconnect_by_func(
1357         priv-&gt;connection,
1358         G_CALLBACK(infc_browser_connection_error_cb),
1359         browser
1360       );
1361       g_object_unref(priv-&gt;connection);
1362     }
1363     priv-&gt;connection = INF_XML_CONNECTION(g_value_get_object(value));
1364     if(priv-&gt;connection)
1365     {
1366       g_object_ref(priv-&gt;connection);
1367       g_object_get(G_OBJECT(priv-&gt;connection), "status", &amp;status, NULL);
1368       g_signal_connect(
1369         G_OBJECT(priv-&gt;connection),
1370         "notify::status",
1371         G_CALLBACK(infc_browser_connection_notify_status_cb),
1372         browser
1373       );
1374       g_signal_connect(
1375         G_OBJECT(priv-&gt;connection),
1376         "error",
1377         G_CALLBACK(infc_browser_connection_error_cb),
1378         browser
1379       );
1380       switch(status)
1381       {
1382       case INF_XML_CONNECTION_OPENING:
1383         if(priv-&gt;status != INF_BROWSER_OPENING)
1384         {
1385           priv-&gt;status = INF_BROWSER_OPENING;
1386           g_object_notify(G_OBJECT(browser), "status");
1387         }
1388         break;
1389       case INF_XML_CONNECTION_OPEN:
1390         infc_browser_connected(browser);
1391         break;
1392       case INF_XML_CONNECTION_CLOSING:
1393       case INF_XML_CONNECTION_CLOSED:
1394         if(priv-&gt;status != INF_BROWSER_CLOSED)
1395         {
1396           priv-&gt;status = INF_BROWSER_CLOSED;
1397           g_object_notify(G_OBJECT(browser), "status");
1398         }
1399         break;
1400       }
1401     }
1402     else
1403     {
1404       if(priv-&gt;status != INF_BROWSER_CLOSED)
1405       {
1406         priv-&gt;status = INF_BROWSER_CLOSED;
1407         g_object_notify(G_OBJECT(browser), "status");
1408       }
1409     }
1410     break;
1411 <a name="1"></a>  case PROP_STATUS:
1412   case PROP_CHAT_SESSION:
1413 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  default:
1414     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
1415     break;
1416   }
1417 }
1418 static void
1419 infc_browser_get_property(GObject* object,
1420                           guint prop_id,
1421                           GValue* value,
1422                           GParamSpec* pspec)
1423 {
1424   InfcBrowser* browser;
1425   InfcBrowserPrivate* priv;
1426   browser = INFC_BROWSER(object);
1427   priv = INFC_BROWSER_PRIVATE(browser);
1428   switch(prop_id)
1429   {
1430   case PROP_IO:
1431     g_value_set_object(value, G_OBJECT(priv-&gt;io));
1432     break;
1433   case PROP_COMMUNICATION_MANAGER:
1434     g_value_set_object(value, G_OBJECT(priv-&gt;communication_manager));
1435     break;</b></font>
1436   case PROP_CONNECTION:
1437     g_value_set_object(value, G_OBJECT(priv-&gt;connection));
1438     break;
1439   case PROP_STATUS:
1440     g_value_set_enum(value, priv-&gt;status);
1441     break;
1442   case PROP_CHAT_SESSION:
1443     g_value_set_object(value, G_OBJECT(priv-&gt;chat_session));
1444     break;
1445   default:
1446     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
1447     break;
1448   }
1449 }
1450 static InfcBrowserSubreq*
1451 infc_browser_add_subreq_common(InfcBrowser* browser,
1452                                InfcBrowserSubreqType type,
1453                                guint node_id)
1454 {
1455   InfcBrowserPrivate* priv;
1456   InfcBrowserSubreq* request;
1457   priv = INFC_BROWSER_PRIVATE(browser);
1458   request = g_slice_new(InfcBrowserSubreq);
1459   request-&gt;type = type;
1460   request-&gt;node_id = node_id;
1461   priv-&gt;subscription_requests =
1462     g_slist_prepend(priv-&gt;subscription_requests, request);
1463   return request;
1464 }
1465 static InfcBrowserSubreq*
1466 infc_browser_add_subreq_chat(InfcBrowser* browser,
1467                              InfcRequest* request,
1468                              InfCommunicationJoinedGroup* group)
1469 {
1470   InfcBrowserSubreq* subreq;
1471   subreq = infc_browser_add_subreq_common(
1472     browser,
1473     INFC_BROWSER_SUBREQ_CHAT,
1474     0
1475   );
1476   subreq-&gt;shared.chat.request = request;
1477   subreq-&gt;shared.chat.subscription_group = group;
1478   if(request != NULL)
1479     g_object_ref(request);
1480   g_object_ref(group);
1481   return subreq;
1482 }
1483 static InfcBrowserSubreq*
1484 infc_browser_add_subreq_session(InfcBrowser* browser,
1485                                 InfcBrowserNode* node,
1486                                 InfcRequest* request,
1487                                 InfCommunicationJoinedGroup* group)
1488 {
1489   InfcBrowserSubreq* subreq;
1490   subreq = infc_browser_add_subreq_common(
1491     browser,
1492     INFC_BROWSER_SUBREQ_SESSION,
1493     node-&gt;id
1494   );
1495   subreq-&gt;shared.session.node = node;
1496   subreq-&gt;shared.session.request = request;
1497   subreq-&gt;shared.session.subscription_group = group;
1498   if(request != NULL)
1499     g_object_ref(request);
1500   g_object_ref(group);
1501   return subreq;
1502 }
1503 static InfcBrowserSubreq*
1504 infc_browser_add_subreq_add_node(InfcBrowser* browser,
1505                                  guint node_id,
1506                                  InfcBrowserNode* parent,
1507                                  const InfcNotePlugin* plugin,
1508                                  const gchar* name,
1509                                  const InfAclSheetSet* sheet_set,
1510                                  InfcRequest* request,
1511                                  InfCommunicationJoinedGroup* group)
1512 {
1513   InfcBrowserSubreq* subreq;
1514   subreq = infc_browser_add_subreq_common(
1515     browser,
1516     INFC_BROWSER_SUBREQ_ADD_NODE,
1517     node_id
1518   );
1519   subreq-&gt;shared.add_node.parent = parent;
1520   subreq-&gt;shared.add_node.plugin = plugin;
1521   subreq-&gt;shared.add_node.name = g_strdup(name);
1522   if(sheet_set != NULL)
1523     subreq-&gt;shared.add_node.sheet_set = inf_acl_sheet_set_copy(sheet_set);
1524   else
1525     subreq-&gt;shared.add_node.sheet_set = NULL;
1526   subreq-&gt;shared.add_node.request = request;
1527   subreq-&gt;shared.add_node.subscription_group = group;
1528   if(request != NULL)
1529     g_object_ref(request);
1530   g_object_ref(group);
1531   return subreq;
1532 }
1533 static InfcBrowserSubreq*
1534 infc_browser_add_subreq_sync_in(InfcBrowser* browser,
1535                                 guint node_id,
1536                                 InfcBrowserNode* parent,
1537                                 const InfcNotePlugin* plugin,
1538                                 const gchar* name,
1539                                 const InfAclSheetSet* sheet_set,
1540                                 InfcRequest* request,
1541                                 InfSession* session,
1542                                 InfCommunicationJoinedGroup* sync_group,
1543                                 InfCommunicationJoinedGroup* sub_group)
1544 {
1545   InfcBrowserSubreq* subreq;
1546   g_assert(request != NULL);
1547   g_assert(sync_group != NULL);
1548   g_assert(session != NULL);
1549   subreq = infc_browser_add_subreq_common(
1550     browser,
1551     INFC_BROWSER_SUBREQ_SYNC_IN,
1552     node_id
1553   );
1554   subreq-&gt;shared.sync_in.parent = parent;
1555   subreq-&gt;shared.sync_in.plugin = plugin;
1556   subreq-&gt;shared.sync_in.name = g_strdup(name);
1557   if(sheet_set != NULL)
1558     subreq-&gt;shared.sync_in.sheet_set = inf_acl_sheet_set_copy(sheet_set);
1559   else
1560     subreq-&gt;shared.sync_in.sheet_set = NULL;
1561   subreq-&gt;shared.sync_in.request = request;
1562   subreq-&gt;shared.sync_in.session = session;
1563   subreq-&gt;shared.sync_in.synchronization_group = sync_group;
1564   subreq-&gt;shared.sync_in.subscription_group = sub_group;
1565   g_object_ref(request);
1566   g_object_ref(session);
1567   g_object_ref(sync_group);
1568   if(sub_group != NULL)
1569     g_object_ref(sub_group);
1570   return subreq;
1571 }
1572 static void
1573 infc_browser_free_subreq(InfcBrowserSubreq* request)
1574 {
1575   switch(request-&gt;type)
1576   {
1577   case INFC_BROWSER_SUBREQ_CHAT:
1578     g_object_unref(request-&gt;shared.chat.subscription_group);
1579     if(request-&gt;shared.chat.request != NULL)
1580       g_object_unref(request-&gt;shared.chat.request);
1581     break;
1582   case INFC_BROWSER_SUBREQ_SESSION:
1583     g_object_unref(request-&gt;shared.session.subscription_group);
1584     if(request-&gt;shared.session.request != NULL)
1585       g_object_unref(request-&gt;shared.session.request);
1586     break;
1587   case INFC_BROWSER_SUBREQ_ADD_NODE:
1588     g_object_unref(request-&gt;shared.add_node.subscription_group);
1589     if(request-&gt;shared.add_node.request != NULL)
1590       g_object_unref(request-&gt;shared.add_node.request);
1591     if(request-&gt;shared.add_node.sheet_set != NULL)
1592       inf_acl_sheet_set_free(request-&gt;shared.add_node.sheet_set);
1593     g_free(request-&gt;shared.add_node.name);
1594     break;
1595   case INFC_BROWSER_SUBREQ_SYNC_IN:
1596     if(request-&gt;shared.sync_in.subscription_group != NULL)
1597       g_object_unref(request-&gt;shared.sync_in.subscription_group);
1598     g_object_unref(request-&gt;shared.sync_in.synchronization_group);
1599     g_object_unref(request-&gt;shared.sync_in.session);
1600     if(request-&gt;shared.sync_in.request != NULL)
1601       g_object_unref(request-&gt;shared.sync_in.request);
1602     if(request-&gt;shared.sync_in.sheet_set != NULL)
1603       inf_acl_sheet_set_free(request-&gt;shared.sync_in.sheet_set);
1604     g_free(request-&gt;shared.sync_in.name);
1605     break;
1606   default:
1607     g_assert_not_reached();
1608     break;
1609   }
1610   g_slice_free(InfcBrowserSubreq, request);
1611 }
1612 static void
1613 infc_browser_unlink_subreq(InfcBrowser* browser,
1614                            InfcBrowserSubreq* request)
1615 {
1616   InfcBrowserPrivate* priv;
1617   priv = INFC_BROWSER_PRIVATE(browser);
1618   priv-&gt;subscription_requests =
1619     g_slist_remove(priv-&gt;subscription_requests, request);
1620 }
1621 static void
1622 infc_browser_remove_subreq(InfcBrowser* browser,
1623                            InfcBrowserSubreq* request)
1624 {
1625   infc_browser_unlink_subreq(browser, request);
1626   infc_browser_free_subreq(request);
1627 }
1628 static InfcBrowserSubreq*
1629 infc_browser_find_subreq(InfcBrowser* browser,
1630                          guint node_id)
1631 {
1632   InfcBrowserPrivate* priv;
1633   GSList* item;
1634   InfcBrowserSubreq* subreq;
1635   priv = INFC_BROWSER_PRIVATE(browser);
1636   for(item = priv-&gt;subscription_requests; item != NULL; item = item-&gt;next)
1637   {
1638     subreq = (InfcBrowserSubreq*)item-&gt;data;
1639     switch(subreq-&gt;type)
1640     {
1641     case INFC_BROWSER_SUBREQ_CHAT:
1642     case INFC_BROWSER_SUBREQ_SESSION:
1643       break;
1644     case INFC_BROWSER_SUBREQ_ADD_NODE:
1645       if(subreq-&gt;node_id == node_id)
1646         return subreq;
1647       break;
1648     case INFC_BROWSER_SUBREQ_SYNC_IN:
1649       if(subreq-&gt;node_id == node_id)
1650         return subreq;
1651       break;
1652     default:
1653       g_assert_not_reached();
1654       break;
1655     }
1656   }
1657   return NULL;
1658 }
1659 static void
1660 infc_browser_sync_in_synchronization_failed_cb(InfSession* session,
1661                                                InfXmlConnection* connection,
1662                                                GError* error,
1663                                                gpointer user_data)
1664 {
1665   InfcBrowserSyncIn* sync_in;
1666   InfcBrowser* browser;
1667   InfcBrowserNode* node;
1668   sync_in = (InfcBrowserSyncIn*)user_data;
1669   if(connection != sync_in-&gt;connection) return;
1670   browser = sync_in-&gt;browser;
1671   node = sync_in-&gt;node;
1672   g_object_ref(browser);
1673   infc_browser_remove_sync_in(browser, sync_in);
1674   infc_browser_node_unregister(browser, node, NULL);
1675   infc_browser_node_free(browser, node);
1676   g_object_unref(browser);
1677 }
1678 static void
1679 infc_browser_sync_in_synchronization_complete_cb(InfSession* session,
1680                                                  InfXmlConnection* connection,
1681                                                  gpointer user_data)
1682 {
1683   InfcBrowserSyncIn* sync_in;
1684   sync_in = (InfcBrowserSyncIn*)user_data;
1685   if(connection != sync_in-&gt;connection) return;
1686   infc_browser_remove_sync_in(sync_in-&gt;browser, sync_in);
1687 }
1688 static InfcBrowserSyncIn*
1689 infc_browser_add_sync_in(InfcBrowser* browser,
1690                          InfcBrowserNode* node,
1691                          InfXmlConnection* connection,
1692                          InfcSessionProxy* proxy)
1693 {
1694   InfcBrowserPrivate* priv;
1695   InfcBrowserSyncIn* sync_in;
1696   InfSession* session;
1697   priv = INFC_BROWSER_PRIVATE(browser);
1698   sync_in = g_slice_new(InfcBrowserSyncIn);
1699   sync_in-&gt;browser = browser;
1700   sync_in-&gt;node = node;
1701   sync_in-&gt;connection = connection;
1702   sync_in-&gt;proxy = proxy;
1703   g_object_ref(proxy);
1704   g_object_get(G_OBJECT(proxy), "session", &amp;session, NULL);
1705   g_signal_connect(
1706     session,
1707     "synchronization-failed",
1708     G_CALLBACK(infc_browser_sync_in_synchronization_failed_cb),
1709     sync_in
1710   );
1711   g_signal_connect(
1712     session,
1713     "synchronization-complete",
1714     G_CALLBACK(infc_browser_sync_in_synchronization_complete_cb),
1715     sync_in
1716   );
1717   g_object_unref(session);
1718   priv-&gt;sync_ins = g_slist_prepend(priv-&gt;sync_ins, sync_in);
1719   return sync_in;
1720 }
1721 static void
1722 infc_browser_remove_sync_in(InfcBrowser* browser,
1723                             InfcBrowserSyncIn* sync_in)
1724 {
1725   InfcBrowserPrivate* priv;
1726   InfSession* session;
1727   priv = INFC_BROWSER_PRIVATE(browser);
1728   g_object_get(G_OBJECT(sync_in-&gt;proxy), "session", &amp;session, NULL);
1729   inf_signal_handlers_disconnect_by_func(
1730     G_OBJECT(session),
1731     G_CALLBACK(infc_browser_sync_in_synchronization_complete_cb),
1732     sync_in
1733   );
1734   inf_signal_handlers_disconnect_by_func(
1735     G_OBJECT(session),
1736     G_CALLBACK(infc_browser_sync_in_synchronization_failed_cb),
1737     sync_in
1738   );
1739   g_object_unref(session);
1740   g_object_unref(sync_in-&gt;proxy);
1741   g_slice_free(InfcBrowserSyncIn, sync_in);
1742   priv-&gt;sync_ins = g_slist_remove(priv-&gt;sync_ins, sync_in);
1743 }
1744 static InfcBrowserNode*
1745 infc_browser_node_add_subdirectory(InfcBrowser* browser,
1746                                    InfcBrowserNode* parent,
1747                                    InfcRequest* request,
1748                                    guint id,
1749                                    const gchar* name,
1750                                    const InfAclSheetSet* sheet_set)
1751 {
1752   InfcBrowserPrivate* priv;
1753   InfcBrowserNode* node;
1754   g_assert(parent-&gt;type == INFC_BROWSER_NODE_SUBDIRECTORY);
1755   g_assert(parent-&gt;shared.subdir.explored == TRUE);
1756   priv = INFC_BROWSER_PRIVATE(browser);
1757   node = infc_browser_node_new_subdirectory(
1758     browser,
1759     parent,
1760     id,
1761     name,
1762     sheet_set
1763   );
1764   infc_browser_node_register(browser, node, request);
1765   return node;
1766 }
1767 static InfcBrowserNode*
1768 infc_browser_node_add_note(InfcBrowser* browser,
1769                            InfcBrowserNode* parent,
1770                            InfcRequest* request,
1771                            guint id,
1772                            const gchar* name,
1773                            const gchar* type,
1774                            const InfAclSheetSet* sheet_set,
1775                            InfcSessionProxy* sync_in_session)
1776 {
1777   InfcBrowserPrivate* priv;
1778   InfcBrowserNode* node;
1779   g_assert(parent-&gt;type == INFC_BROWSER_NODE_SUBDIRECTORY);
1780   g_assert(parent-&gt;shared.subdir.explored == TRUE);
1781   priv = INFC_BROWSER_PRIVATE(browser);
1782   g_assert(priv-&gt;connection != NULL);
1783   node = infc_browser_node_new_note(
1784     browser,
1785     parent,
1786     id,
1787     name,
1788     type,
1789     sheet_set
1790   );
1791   if(sync_in_session != NULL)
1792   {
1793     infc_browser_add_sync_in(
1794       browser,
1795       node,
1796       priv-&gt;connection,
1797       sync_in_session
1798     );
1799   }
1800   infc_browser_node_register(browser, node, request);
1801   return node;
1802 }
1803 static void
1804 infc_browser_subscribe_ack(InfcBrowser* browser,
1805                            InfXmlConnection* connection,
1806                            InfcBrowserSubreq* request)
1807 {
1808   InfcBrowserPrivate* priv;
1809   xmlNodePtr xml;
1810   priv = INFC_BROWSER_PRIVATE(browser);
1811   xml = xmlNewNode(NULL, (const xmlChar*)"subscribe-ack");
1812   if(request-&gt;type != INFC_BROWSER_SUBREQ_CHAT)
1813     inf_xml_util_set_attribute_uint(xml, "id", request-&gt;node_id);
1814   inf_communication_group_send_message(
1815     INF_COMMUNICATION_GROUP(priv-&gt;group),
1816     connection,
1817     xml
1818   );
1819 }
1820 static void
1821 infc_browser_subscribe_nack(InfcBrowser* browser,
1822                             InfXmlConnection* connection,
1823                             guint node_id)
1824 {
1825   InfcBrowserPrivate* priv;
1826   xmlNodePtr xml;
1827   priv = INFC_BROWSER_PRIVATE(browser);
1828   xml = xmlNewNode(NULL, (const xmlChar*)"subscribe-nack");
1829   if(node_id &gt; 0) inf_xml_util_set_attribute_uint(xml, "id", node_id);
1830   inf_communication_group_send_message(
1831     INF_COMMUNICATION_GROUP(priv-&gt;group),
1832     connection,
1833     xml
1834   );
1835 }
1836 static InfcBrowserNode*
1837 infc_browser_get_node_from_xml(InfcBrowser* browser,
1838                                xmlNodePtr xml,
1839                                const gchar* attrib,
1840                                GError** error)
1841 {
1842   InfcBrowserPrivate* priv;
1843   InfcBrowserNode* node;
1844   guint node_id;
1845   gboolean has_node;
1846   priv = INFC_BROWSER_PRIVATE(browser);
1847   has_node = inf_xml_util_get_attribute_uint_required(
1848     xml,
1849     attrib,
1850     &amp;node_id,
1851     error
1852   );
1853   if(has_node == FALSE) return NULL;
1854   node = g_hash_table_lookup(priv-&gt;nodes, GUINT_TO_POINTER(node_id));
1855   if(node == NULL)
1856   {
1857     g_set_error(
1858       error,
1859       inf_directory_error_quark(),
1860       INF_DIRECTORY_ERROR_NO_SUCH_NODE,
1861       _("There is no such node with ID %u"),
1862       node_id
1863     );
1864     return NULL;
1865   }
1866   else
1867   {
1868     return node;
1869   }
1870 }
1871 static InfcBrowserNode*
1872 infc_browser_get_node_from_xml_typed(InfcBrowser* browser,
1873                                      xmlNodePtr xml,
1874                                      const gchar* attrib,
1875                                      InfcBrowserNodeType mask,
1876                                      GError** error)
1877 {
1878   InfcBrowserNode* node;
1879   g_assert(mask != 0);
1880   node = infc_browser_get_node_from_xml(browser, xml, attrib, error);
1881   if(node != NULL &amp;&amp; (node-&gt;type &amp; mask) == 0)
1882   {
1883     if(mask &amp; INFC_BROWSER_NODE_SUBDIRECTORY)
1884     {
1885       g_set_error_literal(
1886         error,
1887         inf_directory_error_quark(),
1888         INF_DIRECTORY_ERROR_NOT_A_SUBDIRECTORY,
1889         inf_directory_strerror(INF_DIRECTORY_ERROR_NOT_A_SUBDIRECTORY)
1890       );
1891     }
1892     else
1893     {
1894       g_set_error_literal(
1895         error,
1896         inf_directory_error_quark(),
1897         INF_DIRECTORY_ERROR_NOT_A_NOTE,
1898         inf_directory_strerror(INF_DIRECTORY_ERROR_NOT_A_NOTE)
1899       );
1900     }
1901     return NULL;
1902   }
1903   else
1904   {
1905     return node;
1906   }
1907 }
1908 static gboolean
1909 infc_browser_validate_progress_request(InfcBrowser* browser,
1910                                        InfcProgressRequest* request,
1911                                        GError** error)
1912 {
1913   guint current;
1914   guint total;
1915   if(infc_progress_request_get_initiated(request) == FALSE)
1916   {
1917     g_set_error_literal(
1918       error,
1919       inf_directory_error_quark(),
1920       INF_DIRECTORY_ERROR_NOT_INITIATED,
1921       inf_directory_strerror(INF_DIRECTORY_ERROR_NOT_INITIATED)
1922     );
1923     return FALSE;
1924   }
1925   else
1926   {
1927     g_object_get(
1928       G_OBJECT(request),
1929       "current", &amp;current,
1930       "total", &amp;total,
1931       NULL
1932     );
1933     if(current &gt;= total)
1934     {
1935       g_set_error_literal(
1936         error,
1937         inf_directory_error_quark(),
1938         INF_DIRECTORY_ERROR_TOO_MANY_CHILDREN,
1939         inf_directory_strerror(INF_DIRECTORY_ERROR_TOO_MANY_CHILDREN)
1940       );
1941       return FALSE;
1942     }
1943     else
1944     {
1945       return TRUE;
1946     }
1947   }
1948 }
1949 static InfcRequest*
1950 infc_browser_get_add_node_request_from_xml(InfcBrowser* browser,
1951                                            xmlNodePtr xml,
1952                                            GError** error)
1953 {
1954   InfcBrowserPrivate* priv;
1955   InfcRequest* request;
1956   gchar* type;
1957   gboolean result;
1958   priv = INFC_BROWSER_PRIVATE(browser);
1959   request = infc_request_manager_get_request_by_xml(
1960     priv-&gt;request_manager,
1961     NULL,
1962     xml,
1963     NULL
1964   );
1965   if(request != NULL)
1966   {
1967     g_object_get(G_OBJECT(request), "type", &amp;type, NULL);
1968     if(strcmp(type, "add-node") != 0 &amp;&amp; strcmp(type, "explore-node") != 0)
1969     {
1970       g_set_error(
1971         error,
1972         inf_request_error_quark(),
1973         INF_REQUEST_ERROR_INVALID_SEQ,
1974         _("The request contains a sequence number referring to a request of "
1975           "type '%s', but a request of either 'explore-node' or 'add-node' "
1976           "was expected."),
1977         type
1978       );
1979       g_free(type);
1980       return NULL;
1981     }
1982     if(strcmp(type, "explore-node") == 0)
1983     {
1984       g_assert(INFC_IS_PROGRESS_REQUEST(request));
1985       result = infc_browser_validate_progress_request(
1986         browser,
1987         INFC_PROGRESS_REQUEST(request),
1988         error
1989       );
1990       if(result == FALSE)
1991       {
1992         g_free(type);
1993         return NULL;
1994       }
1995     }
1996     g_free(type);
1997   }
1998   return request;
1999 }
2000 static void
2001 infc_browser_process_add_node_request(InfcBrowser* browser,
2002                                       InfcRequest* request,
2003                                       InfcBrowserNode* node)
2004 {
2005   InfcBrowserPrivate* priv;
2006   InfBrowserIter parent_iter;
2007   InfBrowserIter iter;
2008   priv = INFC_BROWSER_PRIVATE(browser);
2009   if(INFC_IS_PROGRESS_REQUEST(request))
2010   {
2011     infc_progress_request_progress(INFC_PROGRESS_REQUEST(request));
2012   }
2013   else
2014   {
2015     g_object_get(G_OBJECT(request), "node-id", &amp;parent_iter.node_id, NULL);
2016     g_assert(parent_iter.node_id != G_MAXUINT);
2017     parent_iter.node = g_hash_table_lookup(
2018       priv-&gt;nodes,
2019       GUINT_TO_POINTER(parent_iter.node_id)
2020     );
2021     g_assert(parent_iter.node != NULL);
2022     iter.node_id = node-&gt;id;
2023     iter.node = node;
2024     g_assert(node-&gt;parent == parent_iter.node);
2025     infc_request_manager_finish_request(
2026       priv-&gt;request_manager,
2027       request,
2028       inf_request_result_make_add_node(
2029         INF_BROWSER(browser),
2030         &amp;parent_iter,
2031         &amp;iter
2032       )
2033     );
2034   }
2035 }
2036 static InfCommunicationJoinedGroup*
2037 infc_browser_create_group_from_xml(InfcBrowser* browser,
2038                                    InfXmlConnection* connection,
2039                                    xmlNodePtr xml,
2040                                    GError** error)
2041 {
2042   InfcBrowserPrivate* priv;
2043   xmlChar* method_name;
2044   xmlChar* group_name;
2045   InfCommunicationJoinedGroup* group;
2046   priv = INFC_BROWSER_PRIVATE(browser);
2047   method_name = inf_xml_util_get_attribute_required(xml, "method", error);
2048   if(method_name == NULL) return FALSE;
2049   group_name = inf_xml_util_get_attribute_required(xml, "group", error);
2050   if(group_name == NULL) { xmlFree(method_name); return FALSE; }
2051   group = inf_communication_manager_join_group(
2052     priv-&gt;communication_manager,
2053     (const gchar*)group_name,
2054     connection,
2055     (const gchar*)method_name
2056   );
2057   if(!group)
2058   {
2059     g_propagate_error(
2060       error,
2061       infc_browser_method_unsupported_error(
2062         (const gchar*)method_name,
2063         connection
2064       )
2065     );
2066   }
2067   xmlFree(group_name);
2068   xmlFree(method_name);
2069   return group;
2070 }
2071 static void
2072 infc_browser_subscribe_session(InfcBrowser* browser,
2073                                InfcBrowserNode* node,
2074                                InfcRequest* request,
2075                                InfCommunicationJoinedGroup* group,
2076                                InfXmlConnection* connection,
2077                                gboolean initial_sync)
2078 {
2079   InfcBrowserPrivate* priv;
2080   InfcSessionProxy* proxy;
2081   InfBrowserIter iter;
2082   GString* path;
2083   InfSession* session;
2084   priv = INFC_BROWSER_PRIVATE(browser);
2085   g_assert(node-&gt;type == INFC_BROWSER_NODE_NOTE_KNOWN);
2086   g_assert(node-&gt;shared.known.plugin != NULL);
2087   g_assert(node-&gt;shared.known.session == NULL);
2088   path = g_string_sized_new(128);
2089   infc_browser_node_get_path_string(node, path);
2090   if(initial_sync)
2091   {
2092     session = node-&gt;shared.known.plugin-&gt;session_new(
2093       priv-&gt;io,
2094       priv-&gt;communication_manager,
2095       INF_SESSION_SYNCHRONIZING,
2096       INF_COMMUNICATION_GROUP(group),
2097       connection,
2098       path-&gt;str,
2099       node-&gt;shared.known.plugin-&gt;user_data
2100     );
2101   }
2102   else
2103   {
2104     session = node-&gt;shared.known.plugin-&gt;session_new(
2105       priv-&gt;io,
2106       priv-&gt;communication_manager,
2107       INF_SESSION_RUNNING,
2108       NULL,
2109       NULL,
2110       path-&gt;str,
2111       node-&gt;shared.known.plugin-&gt;user_data
2112     );
2113   }
2114   g_string_free(path, TRUE);
2115   proxy = g_object_new(INFC_TYPE_SESSION_PROXY, "session", session, NULL);
2116   inf_communication_group_set_target(
2117     INF_COMMUNICATION_GROUP(group),
2118     INF_COMMUNICATION_OBJECT(proxy)
2119   );
2120   infc_session_proxy_set_connection(proxy, group, connection, priv-&gt;seq_id);
2121   g_object_unref(session);
2122   iter.node_id = node-&gt;id;
2123   iter.node = node;
2124   inf_browser_subscribe_session(
2125     INF_BROWSER(browser),
2126     &amp;iter,
2127     INF_SESSION_PROXY(proxy),
2128     INF_REQUEST(request)
2129   );
2130   g_object_unref(proxy);
2131 }
2132 static gboolean
2133 infc_browser_handle_welcome(InfcBrowser* browser,
2134                             InfXmlConnection* connection,
2135                             xmlNodePtr xml,
2136                             GError** error)
2137 {
2138   InfcBrowserPrivate* priv;
2139   xmlChar* version;
2140   guint server_major;
2141   guint server_minor;
2142   guint own_major;
2143   guint own_minor;
2144   gboolean result;
2145   InfAclSheetSet* sheet_set;
2146   xmlNodePtr node;
2147   InfAclAccountId default_id;
2148   InfAclAccount* default_account;
2149   GError* local_error;
2150   InfAclSheet* sheet;
2151   InfAclMask default_mask;
2152   priv = INFC_BROWSER_PRIVATE(browser);
2153   version = inf_xml_util_get_attribute_required(
2154     xml,
2155     "protocol-version",
2156     error);
2157   if(!version) return FALSE;
2158   result = inf_protocol_parse_version(
2159     (const gchar*)version,
2160     &amp;server_major, &amp;server_minor,
2161     error
2162   );
2163   xmlFree(version);
2164   if(!result) return FALSE;
2165   result = inf_protocol_parse_version(
2166     inf_protocol_get_version(),
2167     &amp;own_major, &amp;own_minor,
2168     NULL
2169   );
2170   g_assert(result == TRUE);
2171   if(server_major &lt; own_major)
2172   {
2173     g_set_error_literal(
2174       error,
2175       inf_directory_error_quark(),
2176       INF_DIRECTORY_ERROR_VERSION_MISMATCH,
2177       _("The server uses an older version of the protocol which is no longer "
2178         "supported by this client. Consider using an earlier version of it, "
2179         "or ask the server administrators to upgrade their software.")
2180     );
2181     return FALSE;
2182   }
2183   if(server_major &gt; own_major)
2184   {
2185     g_set_error_literal(
2186       error,
2187       inf_directory_error_quark(),
2188       INF_DIRECTORY_ERROR_VERSION_MISMATCH,
2189       _("The server uses a newer version of the protocol which is not "
2190         "supported by this client. Consider upgrading your client.")
2191     );
2192     return FALSE;
2193   }
2194   result = inf_xml_util_get_attribute_uint_required(
2195     xml,
2196     "sequence-id",
2197     &amp;priv-&gt;seq_id,
2198     error
2199   );
2200   if(!result) return FALSE;
2201   g_assert(priv-&gt;accounts == NULL);
2202   g_assert(priv-&gt;local_account == NULL);
2203   priv-&gt;accounts = g_hash_table_new_full(
2204     NULL,
2205     NULL,
2206     NULL,
2207     (GDestroyNotify)inf_acl_account_free
2208   );
2209   default_id = inf_acl_account_id_from_string("default");
2210   default_account = inf_acl_account_new(default_id, NULL);
2211   g_hash_table_insert(
2212     priv-&gt;accounts, 
2213     INF_ACL_ACCOUNT_ID_TO_POINTER(default_account-&gt;id),
2214     default_account
2215   );
2216   priv-&gt;local_account = default_account;
2217   for(node = xml-&gt;children; node != NULL; node = node-&gt;next)
2218   {
2219     if(node-&gt;type != XML_ELEMENT_NODE) continue;
2220     if(strcmp(node-&gt;name, "account") == 0)
2221     {
2222       priv-&gt;local_account = inf_acl_account_from_xml(node, error);
2223       if(priv-&gt;local_account == NULL)
2224       {
2225         g_hash_table_destroy(priv-&gt;accounts);
2226         priv-&gt;accounts = NULL;
2227         return FALSE;
2228       }
2229       g_hash_table_insert(
2230         priv-&gt;accounts,
2231         INF_ACL_ACCOUNT_ID_TO_POINTER(priv-&gt;local_account-&gt;id),
2232         (gpointer)priv-&gt;local_account
2233       );
2234       break;
2235     }
2236   }
2237   local_error = NULL;
2238   sheet_set = inf_acl_sheet_set_from_xml(xml, &amp;local_error);
2239   if(local_error != NULL)
2240   {
2241     g_hash_table_destroy(priv-&gt;accounts);
2242     priv-&gt;accounts = NULL;
2243     priv-&gt;local_account = NULL;
2244     g_propagate_error(error, local_error);
2245     return FALSE;
2246   }
2247   if(sheet_set == NULL)
2248     sheet_set = inf_acl_sheet_set_new();
2249   sheet = inf_acl_sheet_set_add_sheet(sheet_set, default_id);
2250   default_mask = sheet-&gt;mask;
2251   inf_acl_mask_neg(&amp;default_mask, &amp;default_mask);
2252   inf_acl_mask_and(&amp;default_mask, &amp;INF_ACL_MASK_DEFAULT, &amp;default_mask);
2253   inf_acl_mask_or(&amp;sheet-&gt;perms, &amp;default_mask, &amp;sheet-&gt;perms);
2254   sheet-&gt;mask = INF_ACL_MASK_ALL;
2255   g_assert(priv-&gt;root == NULL);
2256   priv-&gt;root = infc_browser_node_new_subdirectory(
2257     browser,
2258     NULL,
2259     0,
2260     NULL,
2261     sheet_set
2262   );
2263   inf_acl_sheet_set_free(sheet_set);
2264   g_assert(priv-&gt;request_manager == NULL);
2265   priv-&gt;request_manager = infc_request_manager_new(priv-&gt;seq_id);
2266   priv-&gt;status = INF_BROWSER_OPEN;
2267   g_object_notify(G_OBJECT(browser), "status");
2268   inf_browser_acl_account_added(INF_BROWSER(browser), default_account, NULL);
2269   if(priv-&gt;local_account != default_account)
2270   {
2271     inf_browser_acl_account_added(
2272       INF_BROWSER(browser),
2273       priv-&gt;local_account,
2274       NULL
2275     );
2276   }
2277   return TRUE;
2278 }
2279 static gboolean
2280 infc_browser_handle_explore_begin(InfcBrowser* browser,
2281                                   InfXmlConnection* connection,
2282                                   xmlNodePtr xml,
2283                                   GError** error)
2284 {
2285   InfcBrowserPrivate* priv;
2286   InfcRequest* request;
2287   guint total;
2288   guint node_id;
2289   InfcBrowserNode* node;
2290   priv = INFC_BROWSER_PRIVATE(browser);
2291   request = infc_request_manager_get_request_by_xml_required(
2292     priv-&gt;request_manager,
2293     "explore-node",
2294     xml,
2295     error
2296   );
2297   if(request == NULL) return FALSE;
2298   g_assert(INFC_IS_PROGRESS_REQUEST(request));
2299   if(!inf_xml_util_get_attribute_uint_required(xml, "total", &amp;total, error))
2300     return FALSE;
2301   g_object_get(G_OBJECT(request), "node-id", &amp;node_id, NULL);
2302   g_assert(node_id != G_MAXUINT);
2303   node = g_hash_table_lookup(priv-&gt;nodes, GUINT_TO_POINTER(node_id));
2304   if(node == NULL)
2305   {
2306     g_set_error_literal(
2307       error,
2308       inf_directory_error_quark(),
2309       INF_DIRECTORY_ERROR_NO_SUCH_NODE,
2310       _("Node to explore does no longer exist")
2311     );
2312     return FALSE;
2313   }
2314   else if(node-&gt;type != INFC_BROWSER_NODE_SUBDIRECTORY)
2315   {
2316     g_set_error_literal(
2317       error,
2318       inf_directory_error_quark(),
2319       INF_DIRECTORY_ERROR_NOT_A_SUBDIRECTORY,
2320       _("Node to explore is not a subdirectory")
2321     );
2322     return FALSE;
2323   }
2324   else if(node-&gt;shared.subdir.explored == TRUE)
2325   {
2326     g_set_error_literal(
2327       error,
2328       inf_directory_error_quark(),
2329       INF_DIRECTORY_ERROR_ALREADY_EXPLORED,
2330       _("Node to explore is already explored")
2331     );
2332     return FALSE;
2333   }
2334   else
2335   {
2336     node-&gt;shared.subdir.explored = TRUE;
2337     infc_progress_request_initiated(INFC_PROGRESS_REQUEST(request), total);
2338     return TRUE;
2339   }
2340 }
2341 static gboolean
2342 infc_browser_handle_explore_end(InfcBrowser* browser,
2343                                 InfXmlConnection* connection,
2344                                 xmlNodePtr xml,
2345                                 GError** error)
2346 {
2347   InfcBrowserPrivate* priv;
2348   InfcRequest* request;
2349   guint current;
2350   guint total;
2351   InfBrowserIter iter;
2352   priv = INFC_BROWSER_PRIVATE(browser);
2353   request = infc_request_manager_get_request_by_xml_required(
2354     priv-&gt;request_manager,
2355     "explore-node",
2356     xml,
2357     error
2358   );
2359   if(request == NULL) return FALSE;
2360   g_assert(INFC_IS_PROGRESS_REQUEST(request));
2361   g_object_get(G_OBJECT(request), "current", &amp;current, "total", &amp;total, NULL);
2362   if(current &lt; total)
2363   {
2364     g_set_error_literal(
2365       error,
2366       inf_directory_error_quark(),
2367       INF_DIRECTORY_ERROR_TOO_FEW_CHILDREN,
2368       _("Not all nodes were received before explore-end was received")
2369     );
2370     return FALSE;
2371   }
2372   else
2373   {
2374     g_object_get(G_OBJECT(request), "node-id", &amp;iter.node_id, NULL);
2375     iter.node = g_hash_table_lookup(
2376       priv-&gt;nodes,
2377       GUINT_TO_POINTER(iter.node_id)
2378     );
2379     g_assert(iter.node != NULL);
2380     infc_request_manager_finish_request(
2381       priv-&gt;request_manager,
2382       request,
2383       inf_request_result_make_explore_node(INF_BROWSER(browser), &amp;iter)
2384     );
2385     return TRUE;
2386   }
2387 }
2388 static gboolean
2389 infc_browser_handle_add_node(InfcBrowser* browser,
2390                              InfXmlConnection* connection,
2391                              xmlNodePtr xml,
2392                              GError** error)
2393 {
2394   InfcBrowserPrivate* priv;
2395   InfcBrowserNode* parent;
2396   InfcBrowserNode* node;
2397   guint id;
2398   xmlChar* name;
2399   xmlChar* type;
2400   InfAclSheetSet* sheet_set;
2401   InfcRequest* request;
2402   GError* local_error;
2403   xmlNodePtr child;
2404   const InfcNotePlugin* plugin;
2405   InfCommunicationJoinedGroup* group;
2406   InfcBrowserSubreq* subreq;
2407   gboolean result;
2408   priv = INFC_BROWSER_PRIVATE(browser);
2409   if(inf_xml_util_get_attribute_uint_required(xml, "id", &amp;id, error) == FALSE)
2410     return FALSE;
2411   if(g_hash_table_lookup(priv-&gt;nodes, GUINT_TO_POINTER(id)) != NULL ||
2412      infc_browser_find_subreq(browser, id) != NULL)
2413   {
2414     g_set_error(
2415       error,
2416       inf_directory_error_quark(),
2417       INF_DIRECTORY_ERROR_NODE_EXISTS,
2418       _("Node with ID \"%u\" exists already"),
2419       id
2420     );
2421     return FALSE;
2422   }
2423   parent = infc_browser_get_node_from_xml_typed(
2424     browser,
2425     xml,
2426     "parent",
2427     INFC_BROWSER_NODE_SUBDIRECTORY,
2428     error
2429   );
2430   if(parent == NULL) return FALSE;
2431   if(parent-&gt;shared.subdir.explored == FALSE)
2432   {
2433     g_set_error_literal(
2434       error,
2435       inf_directory_error_quark(),
2436       INF_DIRECTORY_ERROR_NOT_EXPLORED,
2437       _("The parent node has not been explored yet")
2438     );
2439     return FALSE;
2440   }
2441   local_error = NULL;
2442   request =
2443     infc_browser_get_add_node_request_from_xml(browser, xml, &amp;local_error);
2444   if(local_error != NULL)
2445   {
2446     g_propagate_error(error, local_error);
2447     return FALSE;
2448   }
2449   type = inf_xml_util_get_attribute_required(xml, "type", error);
2450   if(type == NULL) return FALSE;
2451   name = inf_xml_util_get_attribute_required(xml, "name", error);
2452   if(name == NULL)
2453   {
2454     xmlFree(type);
2455     return FALSE;
2456   }
2457   sheet_set = inf_acl_sheet_set_from_xml(xml, &amp;local_error);
2458   if(local_error != NULL)
2459   {
2460     xmlFree(type);
2461     xmlFree(name);
2462     g_propagate_error(error, local_error);
2463     return FALSE;
2464   }
2465   if(strcmp((const gchar*)type, "InfSubdirectory") == 0)
2466   {
2467     node = infc_browser_node_add_subdirectory(
2468       browser,
2469       parent,
2470       request,
2471       id,
2472       (const gchar*)name,
2473       sheet_set
2474     );
2475     if(request != NULL)
2476     {
2477       infc_browser_process_add_node_request(
2478         browser,
2479         request,
2480         node
2481       );
2482     }
2483     result = TRUE;
2484   }
2485   else
2486   {
2487     for(child = xml-&gt;children; child != NULL; child = child-&gt;next)
2488       if(strcmp((const char*)child-&gt;name, "subscribe") == 0)
2489         break;
2490     if(child != NULL)
2491     {
2492       if(request != NULL &amp;&amp; INFC_IS_PROGRESS_REQUEST(request))
2493       {
2494         g_set_error_literal(
2495           error,
2496           inf_request_error_quark(),
2497           INF_REQUEST_ERROR_INVALID_SEQ,
2498           _("Explored nodes cannot be initially be subscribed to")
2499         );
2500         result = FALSE;
2501       }
2502       else
2503       {
2504         plugin = g_hash_table_lookup(priv-&gt;plugins, type);
2505         if(plugin == NULL)
2506         {
2507           g_set_error(
2508             error,
2509             inf_directory_error_quark(),
2510             INF_DIRECTORY_ERROR_TYPE_UNKNOWN,
2511             _("Note type \"%s\" not known"),
2512             (const gchar*)type
2513           );
2514           infc_browser_subscribe_nack(browser, connection, id);
2515           result = FALSE;
2516         }
2517         else
2518         {
2519           group = infc_browser_create_group_from_xml(
2520             browser,
2521             connection,
2522             child,
2523             error
2524           );
2525           if(group == NULL)
2526           {
2527             infc_browser_subscribe_nack(browser, connection, id);
2528             result = FALSE;
2529           }
2530           else
2531           {
2532             subreq = infc_browser_add_subreq_add_node(
2533               browser,
2534               id,
2535               parent,
2536               plugin,
2537               (const gchar*)name,
2538               sheet_set,
2539               request,
2540               group
2541             );
2542             g_object_unref(group);
2543             infc_browser_subscribe_ack(browser, connection, subreq);
2544             result = TRUE;
2545           }
2546         }
2547       }
2548     }
2549     else
2550     {
2551       node = infc_browser_node_add_note(
2552         browser,
2553         parent,
2554         request,
2555         id,
2556         (const gchar*)name,
2557         (const gchar*)type,
2558         sheet_set,
2559         NULL
2560       );
2561       if(request != NULL)
2562       {
2563         infc_browser_process_add_node_request(
2564           browser,
2565           request,
2566           node
2567         );
2568       }
2569       result = TRUE;
2570     }
2571   }
2572   if(sheet_set != NULL)
2573     inf_acl_sheet_set_free(sheet_set);
2574   xmlFree(type);
2575   xmlFree(name);
2576   return result;
2577 }
2578 static gboolean
2579 infc_browser_handle_sync_in(InfcBrowser* browser,
2580                             InfXmlConnection* connection,
2581                             xmlNodePtr xml,
2582                             GError** error)
2583 {
2584   InfcBrowserPrivate* priv;
2585   guint id;
2586   InfcBrowserNode* parent;
2587   InfcRequest* request;
2588   InfSession* session;
2589   const InfcNotePlugin* plugin;
2590   InfCommunicationJoinedGroup* sync_group;
2591   xmlChar* type;
2592   xmlChar* name;
2593   GError* local_error;
2594   InfAclSheetSet* sheet_set;
2595   xmlNodePtr child;
2596   InfcBrowserSubreq* subreq;
2597   gboolean result;
2598   priv = INFC_BROWSER_PRIVATE(browser); 
2599   if(inf_xml_util_get_attribute_uint_required(xml, "id", &amp;id, error) == FALSE)
2600     return FALSE;
2601   if(g_hash_table_lookup(priv-&gt;nodes, GUINT_TO_POINTER(id)) != NULL ||
2602      infc_browser_find_subreq(browser, id) != NULL)
2603   {
2604     g_set_error(
2605       error,
2606       inf_directory_error_quark(),
2607       INF_DIRECTORY_ERROR_NODE_EXISTS,
2608       _("Node with ID \"%u\" exists already"),
2609       id
2610     );
2611     return FALSE;
2612   }
2613   parent = infc_browser_get_node_from_xml_typed(
2614     browser,
2615     xml,
2616     "parent",
2617     INFC_BROWSER_NODE_SUBDIRECTORY,
2618     error
2619   );
2620   if(parent == NULL) return FALSE;
2621   request = infc_request_manager_get_request_by_xml_required(
2622     priv-&gt;request_manager,
2623     "add-node",
2624     xml,
2625     error
2626   );
2627   if(!request) return FALSE;
2628   session = g_object_steal_qdata(
2629     G_OBJECT(request),
2630     infc_browser_sync_in_session_quark
2631   );
2632   plugin = g_object_steal_qdata(
2633     G_OBJECT(request),
2634     infc_browser_sync_in_plugin_quark
2635   );
2636   if(session == NULL)
2637   {
2638     g_set_error_literal(
2639       error,
2640       inf_directory_error_quark(),
2641       INF_DIRECTORY_ERROR_UNEXPECTED_SYNC_IN,
2642       _("Received sync-in without having requested one")
2643     );
2644     return FALSE;
2645   }
2646   g_assert(plugin != NULL);
2647   result = FALSE;
2648   type = inf_xml_util_get_attribute_required(xml, "type", error);
2649   if(type != NULL)
2650   {
2651     if(strcmp((const char*)type, plugin-&gt;note_type) != 0)
2652     {
2653       g_set_error(
2654         error,
2655         inf_directory_error_quark(),
2656         INF_DIRECTORY_ERROR_UNEXPECTED_SYNC_IN,
2657         _("Expected note type \"%s\" for sync-in, but received \"%s\""),
2658         plugin-&gt;note_type,
2659         (const gchar*)type
2660       );
2661     }
2662     else
2663     {
2664       name = inf_xml_util_get_attribute_required(xml, "name", error);
2665       if(name != NULL)
2666       {
2667         local_error = NULL;
2668         sheet_set = inf_acl_sheet_set_from_xml(xml, &amp;local_error);
2669         if(local_error != NULL)
2670         {
2671           g_propagate_error(error, local_error);
2672         }
2673         else
2674         {
2675           sync_group = infc_browser_create_group_from_xml(
2676             browser,
2677             connection,
2678             xml,
2679             error
2680           );
2681           if(sync_group == NULL)
2682           {
2683             infc_browser_subscribe_nack(browser, connection, id);
2684           }
2685           else
2686           {
2687             for(child = xml-&gt;children; child != NULL; child = child-&gt;next)
2688               if(strcmp((const char*)child-&gt;name, "subscribe") == 0)
2689                 break;
2690             subreq = infc_browser_add_subreq_sync_in(
2691               browser,
2692               id,
2693               parent,
2694               plugin,
2695               (const gchar*)name,
2696               sheet_set,
2697               request,
2698               session,
2699               sync_group,
2700               child != NULL ? sync_group : NULL
2701             );
2702             g_object_unref(sync_group);
2703             infc_browser_subscribe_ack(browser, connection, subreq);
2704             result = TRUE;
2705           }
2706           if(sheet_set != NULL)
2707             inf_acl_sheet_set_free(sheet_set);
2708         }
2709         xmlFree(name);
2710       }
2711     }
2712     xmlFree(type);
2713   }
2714   g_object_unref(session);
2715   return result;
2716 }
2717 static gboolean
2718 infc_browser_handle_remove_node(InfcBrowser* browser,
2719                                 InfXmlConnection* connection,
2720                                 xmlNodePtr xml,
2721                                 GError** error)
2722 {
2723   InfcBrowserPrivate* priv;
2724   InfcBrowserNode* node;
2725   InfcRequest* request;
2726   InfBrowserIter iter;
2727   priv = INFC_BROWSER_PRIVATE(browser);
2728   node = infc_browser_get_node_from_xml(browser, xml, "id", error);
2729   if(node == NULL) return FALSE;
2730   request = infc_request_manager_get_request_by_xml(
2731     priv-&gt;request_manager,
2732     "remove-node",
2733     xml,
2734     NULL
2735   );
2736   if(request != NULL)
2737   {
2738     g_object_ref(request);
2739     iter.node_id = node-&gt;id;
2740     iter.node = node;
2741     infc_request_manager_finish_request(
2742       priv-&gt;request_manager,
2743       request,
2744       inf_request_result_make_remove_node(INF_BROWSER(browser), &amp;iter)
2745     );
2746   }
2747   infc_browser_session_remove_child_sessions(browser, node, request);
2748   infc_browser_node_unregister(browser, node, request);
2749   infc_browser_node_free(browser, node);
2750   if(request != NULL)
2751     g_object_unref(request);
2752   return TRUE;
2753 }
2754 static gboolean
2755 infc_browser_handle_subscribe_session(InfcBrowser* browser,
2756                                       InfXmlConnection* connection,
2757                                       xmlNodePtr xml,
2758                                       GError** error)
2759 {
2760   InfcBrowserPrivate* priv;
2761   InfcBrowserNode* node;
2762   InfcRequest* request;
2763   InfCommunicationJoinedGroup* group;
2764   InfcBrowserSubreq* subreq;
2765   priv = INFC_BROWSER_PRIVATE(browser);
2766   node = infc_browser_get_node_from_xml_typed(
2767     browser,
2768     xml,
2769     "id",
2770     INFC_BROWSER_NODE_NOTE_KNOWN | INFC_BROWSER_NODE_NOTE_UNKNOWN,
2771     error
2772   );
2773   if(node == NULL) return FALSE;
2774   if(node-&gt;type == INFC_BROWSER_NODE_NOTE_UNKNOWN)
2775   {
2776     g_set_error(
2777       error,
2778       inf_directory_error_quark(),
2779       INF_DIRECTORY_ERROR_TYPE_UNKNOWN,
2780       _("Note type '%s' is not supported"),
2781       node-&gt;shared.unknown.type
2782     );
2783     infc_browser_subscribe_nack(browser, connection, node-&gt;id);
2784     return FALSE;
2785   }
2786   if(node-&gt;shared.known.session != NULL)
2787   {
2788     g_set_error_literal(
2789       error,
2790       inf_directory_error_quark(),
2791       INF_DIRECTORY_ERROR_ALREADY_SUBSCRIBED,
2792       _("Already subscribed to this session")
2793     );
2794     return FALSE;
2795   }
2796   group = infc_browser_create_group_from_xml(
2797     browser,
2798     connection,
2799     xml,
2800     error
2801   );
2802   if(!group)
2803   {
2804     infc_browser_subscribe_nack(browser, connection, node-&gt;id);
2805     return FALSE;
2806   }
2807   request = infc_request_manager_get_request_by_xml(
2808     priv-&gt;request_manager,
2809     "subscribe-session",
2810     xml,
2811     NULL
2812   );
2813   subreq = infc_browser_add_subreq_session(browser, node, request, group);
2814   g_object_unref(group);
2815   infc_browser_subscribe_ack(browser, connection, subreq);
2816   return TRUE;
2817 }
2818 static gboolean
2819 infc_browser_handle_subscribe_chat(InfcBrowser* browser,
2820                                    InfXmlConnection* connection,
2821                                    xmlNodePtr xml,
2822                                    GError** error)
2823 {
2824   InfcBrowserPrivate* priv;
2825   InfcRequest* request;
2826   InfCommunicationJoinedGroup* group;
2827   InfcBrowserSubreq* subreq;
2828   priv = INFC_BROWSER_PRIVATE(browser);
2829   if(priv-&gt;chat_session != NULL)
2830   {
2831     g_set_error_literal(
2832       error,
2833       inf_directory_error_quark(),
2834       INF_DIRECTORY_ERROR_ALREADY_SUBSCRIBED,
2835       _("Already subscribed to the chat session")
2836     );
2837     return FALSE;
2838   }
2839   group = infc_browser_create_group_from_xml(
2840     browser,
2841     connection,
2842     xml,
2843     error
2844   );
2845   if(!group)
2846   {
2847     infc_browser_subscribe_nack(browser, connection, 0);
2848     return FALSE;
2849   }
2850   request = infc_request_manager_get_request_by_xml(
2851     priv-&gt;request_manager,
2852     "subscribe-chat",
2853     xml,
2854     NULL
2855   );
2856   subreq = infc_browser_add_subreq_chat(browser, request, group);
2857   g_object_unref(group);
2858   infc_browser_subscribe_ack(browser, connection, subreq);
2859   return TRUE;
2860 }
2861 static gboolean
2862 infc_browser_handle_save_session_in_progress(InfcBrowser* browser,
2863                                              InfXmlConnection* connection,
2864                                              xmlNodePtr xml,
2865                                              GError** error)
2866 {
2867   InfcBrowserPrivate* priv;
2868   InfcBrowserNode* node;
2869   InfcRequest* request;
2870   priv = INFC_BROWSER_PRIVATE(browser);
2871   node = infc_browser_get_node_from_xml_typed(
2872     browser,
2873     xml,
2874     "id",
2875     INFC_BROWSER_NODE_NOTE_KNOWN,
2876     error
2877   );
2878   if(node == NULL) return FALSE;
2879   request = infc_request_manager_get_request_by_xml(
2880     priv-&gt;request_manager,
2881     "save-session",
2882     xml,
2883     NULL
2884   );
2885   if(request != NULL)
2886   {
2887   }
2888   return TRUE;
2889 }
2890 static gboolean
2891 infc_browser_handle_saved_session(InfcBrowser* browser,
2892                                   InfXmlConnection* connection,
2893                                   xmlNodePtr xml,
2894                                   GError** error)
2895 {
2896   InfcBrowserPrivate* priv;
2897   InfcBrowserNode* node;
2898   InfcRequest* request;
2899   InfBrowserIter iter;
2900   priv = INFC_BROWSER_PRIVATE(browser);
2901   node = infc_browser_get_node_from_xml_typed(
2902     browser,
2903     xml,
2904     "id",
2905     INFC_BROWSER_NODE_NOTE_KNOWN,
2906     error
2907   );
2908   if(node == NULL) return FALSE;
2909   request = infc_request_manager_get_request_by_xml(
2910     priv-&gt;request_manager,
2911     "save-session",
2912     xml,
2913     NULL
2914   );
2915   if(request != NULL)
2916   {
2917     iter.node_id = node-&gt;id;
2918     iter.node = node;
2919     infc_request_manager_finish_request(
2920       priv-&gt;request_manager,
2921       request,
2922       inf_request_result_make_save_session(INF_BROWSER(browser), &amp;iter)
2923     );
2924   }
2925   return TRUE;
2926 }
2927 static gboolean
2928 infc_browser_handle_acl_account_list_begin(InfcBrowser* browser,
2929                                            InfXmlConnection* connection,
2930                                            xmlNodePtr xml,
2931                                            GError** error)
2932 {
2933   InfcBrowserPrivate* priv;
2934   InfcRequest* request;
2935   guint total;
2936   guint notifications_enabled;
2937   gboolean result;
2938   guint node_id;
2939   InfcBrowserNode* node;
2940   InfBrowserIter iter;
2941   priv = INFC_BROWSER_PRIVATE(browser);
2942   request = infc_request_manager_get_request_by_xml_required(
2943     priv-&gt;request_manager,
2944     "query-acl-account-list",
2945     xml,
2946     error
2947   );
2948   if(request == NULL) return FALSE;
2949   g_assert(INFC_IS_PROGRESS_REQUEST(request));
2950   if(!inf_xml_util_get_attribute_uint_required(xml, "total", &amp;total, error))
2951     return FALSE;
2952   result = inf_xml_util_get_attribute_uint_required(
2953     xml,
2954     "notifications-enabled",
2955     &amp;notifications_enabled,
2956     error
2957   );
2958   if(result == FALSE)
2959     return FALSE;
2960   g_object_set_qdata_full(
2961     G_OBJECT(request),
2962     infc_browser_query_acl_account_list_accounts_quark,
2963     g_hash_table_new(NULL, NULL),
2964     (GDestroyNotify)g_hash_table_destroy
2965   );
2966   if(notifications_enabled)
2967     priv-&gt;account_list_status = INFC_BROWSER_ACCOUNT_LIST_NOTIFICATIONS;
2968   else
2969     priv-&gt;account_list_status = INFC_BROWSER_ACCOUNT_LIST_NO_NOTIFICATIONS;
2970   infc_progress_request_initiated(INFC_PROGRESS_REQUEST(request), total);
2971   return TRUE;
2972 }
2973 static gboolean
2974 infc_browser_handle_acl_account_list_end(InfcBrowser* browser,
2975                                          InfXmlConnection* connection,
2976                                          xmlNodePtr xml,
2977                                          GError** error)
2978 {
2979   InfcBrowserPrivate* priv;
2980   InfcRequest* request;
2981   guint current;
2982   guint total;
2983   InfBrowserIter iter;
2984   InfAclAccountId default_id;
2985   GHashTable* table;
2986   GHashTableIter hash_iter;
2987   gpointer value;
2988   InfAclAccount* account;
2989   GSList* to_be_removed;
2990   GSList* item;
2991   InfAclAccount* accounts;
2992   guint n_accounts;
2993   gboolean does_notifications;
2994   priv = INFC_BROWSER_PRIVATE(browser);
2995   request = infc_request_manager_get_request_by_xml_required(
2996     priv-&gt;request_manager,
2997     "query-acl-account-list",
2998     xml,
2999     error
3000   );
3001   if(request == NULL) return FALSE;
3002   g_assert(INFC_IS_PROGRESS_REQUEST(request));
3003   g_object_get(G_OBJECT(request), "current", &amp;current, "total", &amp;total, NULL);
3004   if(current &lt; total)
3005   {
3006     g_set_error_literal(
3007       error,
3008       inf_directory_error_quark(),
3009       INF_DIRECTORY_ERROR_TOO_FEW_CHILDREN,
3010       _("Not all users have been transmitted before "
3011         "user-list-end was received")
3012     );
3013     return FALSE;
3014   }
3015   else
3016   {
3017     table = g_object_get_qdata(
3018       G_OBJECT(request),
3019       infc_browser_query_acl_account_list_accounts_quark
3020     );
3021     to_be_removed = NULL;
3022     default_id = inf_acl_account_id_from_string("default");
3023     g_hash_table_iter_init(&amp;hash_iter, priv-&gt;accounts);
3024     while(g_hash_table_iter_next(&amp;hash_iter, NULL, &amp;value))
3025     {
3026       account = (InfAclAccount*)value;
3027       if(account != priv-&gt;local_account &amp;&amp;
3028          account-&gt;id != default_id &amp;&amp;
3029          g_hash_table_lookup(table, account) == NULL)
3030       {
3031         to_be_removed = g_slist_prepend(to_be_removed, account);
3032       }
3033     }
3034     for(item = to_be_removed; item != NULL; item = item-&gt;next)
3035     {
3036       account = (InfAclAccount*)item-&gt;data;
3037       g_hash_table_steal(
3038         priv-&gt;accounts,
3039         INF_ACL_ACCOUNT_ID_TO_POINTER(account-&gt;id)
3040       );
3041       inf_browser_acl_account_removed(INF_BROWSER(browser), account, NULL);
3042       inf_acl_account_free(account);
3043     }
3044     accounts = infc_browser_make_acl_account_list(browser, &amp;n_accounts);
3045     switch(priv-&gt;account_list_status)
3046     {
3047     case INFC_BROWSER_ACCOUNT_LIST_NOT_QUERIED:
3048       g_assert_not_reached();
3049       break;
3050     case INFC_BROWSER_ACCOUNT_LIST_NO_NOTIFICATIONS:
3051       does_notifications = FALSE;
3052       break;
3053     case INFC_BROWSER_ACCOUNT_LIST_NOTIFICATIONS:
3054       does_notifications = TRUE;
3055       break;
3056     default:
3057       g_assert_not_reached();
3058       break;
3059     }
3060     infc_request_manager_finish_request(
3061       priv-&gt;request_manager,
3062       request,
3063       inf_request_result_make_query_acl_account_list(
3064         INF_BROWSER(browser),
3065         accounts,
3066         n_accounts,
3067         does_notifications
3068       )
3069     );
3070     g_free(accounts);
3071     return TRUE;
3072   }
3073 }
3074 static void
3075 infc_browser_handle_add_acl_account_foreach_func(InfcRequest* request,
3076                                                  gpointer user_data)
3077 {
3078   GHashTable* table;
3079   table = g_object_get_qdata(
3080     G_OBJECT(request),
3081     infc_browser_query_acl_account_list_accounts_quark
3082   );
3083   g_hash_table_insert(table, user_data, user_data);
3084 }
3085 static gboolean
3086 infc_browser_handle_add_acl_account(InfcBrowser* browser,
3087                                     InfXmlConnection* connection,
3088                                     xmlNodePtr xml,
3089                                     GError** error)
3090 {
3091   InfcBrowserPrivate* priv;
3092   GError* local_error;
3093   InfcRequest* request;
3094   gboolean result;
3095   InfAclAccount* account;
3096   InfAclAccount* cache_account;
3097   gchar* id;
3098   priv = INFC_BROWSER_PRIVATE(browser);
3099   local_error = NULL;
3100   request = infc_request_manager_get_request_by_xml(
3101     priv-&gt;request_manager,
3102     "query-acl-account-list",
3103     xml,
3104     &amp;local_error
3105   );
3106   if(local_error != NULL)
3107   {
3108     g_propagate_error(error, local_error);
3109     return FALSE;
3110   }
3111   if(request != NULL)
3112   {
3113     g_assert(INFC_IS_PROGRESS_REQUEST(request));
3114     result = infc_browser_validate_progress_request(
3115       browser,
3116       INFC_PROGRESS_REQUEST(request),
3117       error
3118     );
3119     if(result == FALSE)
3120       return FALSE;
3121   }
3122   account = inf_acl_account_from_xml(xml, error);
3123   if(account == NULL) return FALSE;
3124   cache_account = g_hash_table_lookup(
3125     priv-&gt;accounts,
3126     INF_ACL_ACCOUNT_ID_TO_POINTER(account-&gt;id)
3127   );
3128   if(cache_account != NULL)
3129   {
3130     if(strcmp(cache_account-&gt;name, account-&gt;name) != 0)
3131     {
3132       g_free(cache_account-&gt;name);
3133       cache_account-&gt;name = g_strdup(account-&gt;name);
3134     }
3135     inf_acl_account_free(account);
3136   }
3137   else
3138   {
3139     g_hash_table_insert(
3140       priv-&gt;accounts,
3141       INF_ACL_ACCOUNT_ID_TO_POINTER(account-&gt;id),
3142       account
3143     );
3144     inf_browser_acl_account_added(
3145       INF_BROWSER(browser),
3146       account,
3147       INF_REQUEST(request)
3148     );
3149     cache_account = account;
3150   }
3151   if(request != NULL)
3152     infc_progress_request_progress(INFC_PROGRESS_REQUEST(request));
3153   infc_request_manager_foreach_named_request(
3154     priv-&gt;request_manager,
3155     "query-acl-account-list",
3156     infc_browser_handle_add_acl_account_foreach_func,
3157     cache_account
3158   );
3159   return TRUE;
3160 }
3161 static gboolean
3162 infc_browser_handle_lookup_acl_accounts(InfcBrowser* browser,
3163                                         InfXmlConnection* connection,
3164                                         xmlNodePtr xml,
3165                                         GError** error)
3166 {
3167   InfcBrowserPrivate* priv;
3168   GError* local_error;
3169   InfcRequest* request;
3170   xmlNodePtr child;
3171   GPtrArray* accounts;
3172   InfAclAccount* account;
3173   InfAclAccount* existing_account;
3174   InfAclAccount req_account;
3175   InfcBrowserLookupAclAccountByByNameData lookup_data;
3176   GArray* req_accounts;
3177   guint i;
3178   guint len;
3179   gchar* name;
3180   const InfAclAccountId* ids;
3181   guint n_ids;
3182   priv = INFC_BROWSER_PRIVATE(browser);
3183   local_error = NULL;
3184   request = infc_request_manager_get_request_by_xml(
3185     priv-&gt;request_manager,
3186     "lookup-acl-accounts",
3187     xml,
3188     error
3189   );
3190   if(local_error != NULL)
3191   {
3192     g_propagate_error(error, local_error);
3193     return FALSE;
3194   }
3195   accounts = g_ptr_array_new();
3196   for(child = xml-&gt;children; child != NULL; child = child-&gt;next)
3197   {
3198     if(child-&gt;type != XML_ELEMENT_NODE) continue;
3199     if(strcmp((const gchar*)child-&gt;name, "account") == 0)
3200     {
3201       account = inf_acl_account_from_xml(child, error);
3202       if(account == NULL)
3203       {
3204         for(i = 0; i &lt; accounts-&gt;len; ++i)
3205           inf_acl_account_free(accounts-&gt;pdata[i]);
3206         g_ptr_array_free(accounts, TRUE);
3207         return FALSE;
3208       }
3209       g_ptr_array_add(accounts, account);
3210     }
3211   }
3212   for(i = 0; i &lt; accounts-&gt;len; ++i)
3213   {
3214     account = (InfAclAccount*)accounts-&gt;pdata[i];
3215     existing_account = g_hash_table_lookup(
3216       priv-&gt;accounts,
3217       INF_ACL_ACCOUNT_ID_TO_POINTER(account-&gt;id)
3218     );
3219     if(existing_account != NULL)
3220     {
3221       if(strcmp(existing_account-&gt;name, account-&gt;name) != 0)
3222       {
3223         g_free(existing_account-&gt;name);
3224         existing_account-&gt;name = g_strdup(account-&gt;name);
3225       }
3226       inf_acl_account_free(account);
3227     }
3228     else
3229     {
3230       if(priv-&gt;account_list_status == INFC_BROWSER_ACCOUNT_LIST_NOTIFICATIONS)
3231       {
3232         g_warning(
3233           _("Unknown account ID \"%s\" in server reply of "
3234             "\"%s\". Typically, this means the server claimed it notified us "
3235             "about new connections as soon as they are available, but it "
3236             "did not do so."),
3237           inf_acl_account_id_to_string(account-&gt;id),
3238           "lookup-acl-accounts"
3239         );
3240       }
3241       g_hash_table_insert(
3242         priv-&gt;accounts,
3243         INF_ACL_ACCOUNT_ID_TO_POINTER(account-&gt;id),
3244         account
3245       );
3246       inf_browser_acl_account_added(
3247         INF_BROWSER(browser),
3248         account,
3249         INF_REQUEST(request)
3250       );
3251     }
3252   }
3253   g_ptr_array_free(accounts, TRUE);
3254   if(request != NULL)
3255   {
3256     ids = g_object_get_qdata(
3257       G_OBJECT(request), 
3258       infc_browser_lookup_acl_accounts_ids_quark
3259     );
3260     n_ids = GPOINTER_TO_UINT(
3261       g_object_get_qdata(
3262         G_OBJECT(request),
3263         infc_browser_lookup_acl_accounts_n_ids_quark
3264       )
3265     );
3266     name = g_object_get_qdata(
3267       G_OBJECT(request),
3268       infc_browser_lookup_acl_accounts_name_quark
3269     );
3270     req_accounts = g_array_new(FALSE, FALSE, sizeof(InfAclAccount));
3271     if(ids != NULL)
3272     {
3273       g_assert(n_ids &gt; 0);
3274       for(i = 0; i &lt; n_ids; ++i)
3275       {
3276         account = g_hash_table_lookup(
3277           priv-&gt;accounts,
3278           INF_ACL_ACCOUNT_ID_TO_POINTER(ids[i])
3279         );
3280         if(account != NULL)
3281         {
3282           g_array_append_val(req_accounts, *account);
3283         }
3284         else
3285         {
3286           req_account.id = ids[i];
3287           req_account.name = NULL;
3288           g_array_append_val(req_accounts, req_account);
3289         }
3290       }
3291     }
3292     if(name != NULL)
3293     {
3294       len = req_accounts-&gt;len;
3295       lookup_data.name = name;
3296       lookup_data.accounts = req_accounts;
3297       g_hash_table_foreach(
3298         priv-&gt;accounts,
3299         infc_browser_browser_lookup_acl_account_by_name_find_func,
3300         &amp;lookup_data
3301       );
3302       if(req_accounts-&gt;len == len)
3303       {
3304         req_account.id = 0;
3305         req_account.name = name;
3306         g_array_append_val(req_accounts, req_account);
3307       }
3308     }
3309     infc_request_manager_finish_request(
3310       priv-&gt;request_manager,
3311       request,
3312       inf_request_result_make_lookup_acl_accounts(
3313         INF_BROWSER(browser),
3314         (InfAclAccount*)req_accounts-&gt;data,
3315         req_accounts-&gt;len
3316       )
3317     );
3318     g_array_free(req_accounts, TRUE);
3319   }
3320   return TRUE;
3321 }
3322 static gboolean
3323 infc_browser_handle_change_acl_account(InfcBrowser* browser,
3324                                        InfXmlConnection* connection,
3325                                        xmlNodePtr xml,
3326                                        GError** error)
3327 {
3328   InfcBrowserPrivate* priv;
3329   InfAclAccount* account;
3330   InfAclAccount* existing_account;
3331   GHashTable* new_acls;
3332   xmlNodePtr child;
3333   gboolean res;
3334   InfAclSheet* sheet;
3335   guint node_id;
3336   priv = INFC_BROWSER_PRIVATE(browser);
3337   account = inf_acl_account_from_xml(xml, error);
3338   if(account == NULL) return FALSE;
3339   existing_account = g_hash_table_lookup(
3340     priv-&gt;accounts,
3341     INF_ACL_ACCOUNT_ID_TO_POINTER(account-&gt;id)
3342   );
3343   if(existing_account != NULL)
3344   {
3345     if(account-&gt;name == NULL || existing_account-&gt;name == NULL ||
3346        strcmp(account-&gt;name, existing_account-&gt;name) != 0)
3347     {
3348       g_free(existing_account-&gt;name);
3349       existing_account-&gt;name = g_strdup(account-&gt;name);
3350     }
3351     inf_acl_account_free(account);
3352     account = existing_account;
3353   }
3354   new_acls = g_hash_table_new_full(
3355     NULL,
3356     NULL,
3357     NULL,
3358     (GDestroyNotify)inf_acl_sheet_free
3359   );
3360   for(child = xml-&gt;children; child != NULL; child = child-&gt;next)
3361   {
3362     if(child-&gt;type != XML_ELEMENT_NODE) continue;
3363     if(strcmp((const gchar*)child-&gt;name, "acl") == 0)
3364     {
3365       res = inf_xml_util_get_attribute_uint_required(
3366         child,
3367         "node-id",
3368         &amp;node_id,
3369         error
3370       );
3371       if(res == FALSE)
3372       {
3373         if(account != existing_account)
3374           inf_acl_account_free(account);
3375         g_hash_table_destroy(new_acls);
3376         return FALSE;
3377       }
3378       sheet = inf_acl_sheet_new(account-&gt;id);
3379       res = inf_acl_sheet_perms_from_xml(
3380         child,
3381         &amp;sheet-&gt;mask,
3382         &amp;sheet-&gt;perms,
3383         error
3384       );
3385       if(res == FALSE)
3386       {
3387         inf_acl_sheet_free(sheet);
3388         if(account != existing_account)
3389           inf_acl_account_free(account);
3390         g_hash_table_destroy(new_acls);
3391         return FALSE;
3392       }
3393       g_hash_table_insert(new_acls, GUINT_TO_POINTER(node_id), sheet);
3394     }
3395   }
3396   if(account != existing_account)
3397   {
3398     g_hash_table_insert(
3399       priv-&gt;accounts,
3400       INF_ACL_ACCOUNT_ID_TO_POINTER(account-&gt;id),
3401       account
3402     );
3403     inf_browser_acl_account_added(
3404       INF_BROWSER(browser),
3405       account,
3406       NULL
3407     );
3408   }
3409   priv-&gt;local_account = account;
3410   infc_browser_enforce_acl(browser, priv-&gt;root, NULL, new_acls);
3411   g_hash_table_destroy(new_acls);
3412   inf_browser_acl_local_account_changed(INF_BROWSER(browser), account, NULL);
3413   return TRUE;
3414 }
3415 static gboolean
3416 infc_browser_handle_create_acl_account(InfcBrowser* browser,
3417                                        InfXmlConnection* connection,
3418                                        xmlNodePtr xml,
3419                                        GError** error)
3420 {
3421   InfcBrowserPrivate* priv;
3422   InfcRequest* request;
3423   xmlNodePtr child;
3424   gnutls_datum_t cert_text;
3425   int res;
3426   gnutls_x509_crt_t cert;
3427   gnutls_x509_crt_t* certs;
3428   guint n_certs;
3429   GError* local_error;
3430   int verify_result;
3431   InfCertificateChain* new_chain;
3432   InfAclAccount* account;
3433   InfAclAccount* existing_account;
3434   priv = INFC_BROWSER_PRIVATE(browser);
3435   request = infc_request_manager_get_request_by_xml(
3436     priv-&gt;request_manager,
3437     "create-acl-account",
3438     xml,
3439     NULL
3440   );
3441   if(request == NULL)
3442   {
3443     g_set_error_literal(
3444       error,
3445       inf_directory_error_quark(),
3446       INF_DIRECTORY_ERROR_UNEXPECTED_MESSAGE,
3447       _("No certificate request has been made")
3448     );
3449     return FALSE;
3450   }
3451   cert_text.data = NULL;
3452   for(child = xml-&gt;children; child != NULL; child = child-&gt;next)
3453   {
3454     if(child-&gt;type != XML_ELEMENT_NODE) continue;
3455     if(strcmp((const char*)child-&gt;name, "certificate") == 0)
3456     {
3457       if(child-&gt;children != NULL &amp;&amp; child-&gt;children-&gt;type == XML_TEXT_NODE)
3458       {
3459         cert_text.data = (char*)child-&gt;children-&gt;content;
3460         cert_text.size = strlen(cert_text.data);
3461       }
3462     }
3463   }
3464   if(cert_text.data == NULL)
3465   {
3466     g_set_error_literal(
3467       error,
3468       inf_request_error_quark(),
3469       INF_REQUEST_ERROR_NO_SUCH_ATTRIBUTE,
3470       _("No certificate provided")
3471     );
3472     return FALSE;
3473   }
3474   n_certs = 10;
3475   certs = g_malloc(n_certs * sizeof(gnutls_x509_crt_t));
3476   res = gnutls_x509_crt_list_import(
3477     certs,
3478     &amp;n_certs,
3479     &amp;cert_text,
3480     GNUTLS_X509_FMT_PEM,
3481     GNUTLS_X509_CRT_LIST_FAIL_IF_UNSORTED |
3482     GNUTLS_X509_CRT_LIST_IMPORT_FAIL_IF_EXCEED
3483   );
3484   if(res &lt; 0)
3485   {
3486     g_free(certs);
3487     inf_gnutls_set_error(error, res);
3488     return FALSE;
3489   }
3490   else if(res == 0)
3491   {
3492     g_set_error_literal(
3493       error,
3494       inf_request_error_quark(),
3495       INF_REQUEST_ERROR_NO_SUCH_ATTRIBUTE,
3496       _("No certificate provided")
3497     );
3498     g_free(certs);
3499     return FALSE;
3500   }
3501   certs = g_realloc(certs, n_certs * sizeof(gnutls_x509_crt_t));
3502   new_chain = inf_certificate_chain_new(certs, n_certs);
3503 #if 0
3504   g_object_get(G_OBJECT(connection), "remote-certificate", &amp;chain, NULL);
3505   if(chain == NULL)
3506   {
3507     g_set_error_literal(
3508       error,
3509       inf_directory_error_quark(),
3510       INF_DIRECTORY_ERROR_OPERATION_UNSUPPORTED,
3511       _("Cannot verify the certificate without server certificate")
3512     );
3513     gnutls_x509_crt_deinit(cert);
3514     return FALSE;
3515   }
3516   root_cert = inf_certificate_chain_get_root_certificate(chain);
3517 #endif
3518   res = gnutls_x509_crt_list_verify(
3519     certs,
3520     n_certs,
3521     &amp;certs[n_certs - 1],
3522     1,
3523     NULL,
3524     0,
3525     GNUTLS_VERIFY_DO_NOT_ALLOW_X509_V1_CA_CRT | GNUTLS_VERIFY_DISABLE_CA_SIGN,
3526     &amp;verify_result
3527   );
3528   if(res != GNUTLS_E_SUCCESS || (verify_result &amp; GNUTLS_CERT_INVALID) != 0)
3529   {
3530     if(res != GNUTLS_E_SUCCESS)
3531     {
3532       inf_gnutls_set_error(error, res);
3533     }
3534     else
3535     {
3536       local_error = NULL;
3537       inf_gnutls_certificate_verification_set_error(
3538         &amp;local_error,
3539         verify_result
3540       );
3541       g_set_error(
3542         error,
3543         inf_directory_error_quark(),
3544         INF_DIRECTORY_ERROR_INVALID_CERTIFICATE,
3545         _("Server sent an invalid certificate (%s)"),
3546         local_error-&gt;message
3547       );
3548       g_error_free(local_error);
3549     }
3550     inf_certificate_chain_unref(new_chain);
3551     return FALSE;
3552   }
3553   account = inf_acl_account_from_xml(xml, error);
3554   if(account == NULL)
3555   {
3556     inf_certificate_chain_unref(new_chain);
3557     return FALSE;
3558   }
3559   existing_account = g_hash_table_lookup(
3560     priv-&gt;accounts,
3561     INF_ACL_ACCOUNT_ID_TO_POINTER(account-&gt;id)
3562   );
3563   if(existing_account != NULL)
3564   {
3565     inf_acl_account_free(account);
3566     account = existing_account;
3567   }
3568   else
3569   {
3570     g_hash_table_insert(
3571       priv-&gt;accounts,
3572       INF_ACL_ACCOUNT_ID_TO_POINTER(account-&gt;id),
3573       account
3574     );
3575     inf_browser_acl_account_added(
3576       INF_BROWSER(browser),
3577       account,
3578       INF_REQUEST(request)
3579     );
3580   }
3581   infc_request_manager_finish_request(
3582     priv-&gt;request_manager,
3583     request,
3584     inf_request_result_make_create_acl_account(
3585       INF_BROWSER(browser),
3586       account,
3587       new_chain
3588     )
3589   );
3590   inf_certificate_chain_unref(new_chain);
3591   return TRUE;
3592 }
3593 static gboolean
3594 infc_browser_handle_remove_acl_account(InfcBrowser* browser,
3595                                        InfXmlConnection* connection,
3596                                        xmlNodePtr xml,
3597                                        GError** error)
3598 {
3599   InfcBrowserPrivate* priv;
3600   InfcRequest* request;
3601   xmlChar* account_id;
3602   InfAclAccountId account;
3603   InfAclAccount* acc;
3604   InfAclAccount report_acc;
3605   InfAclAccountId default_id;
3606   GSList* item;
3607   InfcBrowserSubreq* subreq;
3608   priv = INFC_BROWSER_PRIVATE(browser);
3609   request = infc_request_manager_get_request_by_xml(
3610     priv-&gt;request_manager,
3611     "remove-acl-account",
3612     xml,
3613     NULL
3614   );
3615   account_id = inf_xml_util_get_attribute_required(xml, "id", error);
3616   if(account_id == NULL) return FALSE;
3617   account = inf_acl_account_id_from_string((const gchar*)account_id);
3618   if(account == 0)
3619   {
3620     xmlFree(account_id);
3621     return TRUE;
3622   }
3623   xmlFree(account_id);
3624   default_id = inf_acl_account_id_from_string("default");
3625   if(account == default_id)
3626   {
3627     g_set_error_literal(
3628       error,
3629       inf_directory_error_quark(),
3630       INF_DIRECTORY_ERROR_NO_SUCH_ACCOUNT,
3631       _("The default account cannot be removed")
3632     );
3633     return FALSE;
3634   }
3635   if(priv-&gt;local_account-&gt;id == account)
3636   {
3637     priv-&gt;local_account = g_hash_table_lookup(
3638       priv-&gt;accounts,
3639       INF_ACL_ACCOUNT_ID_TO_POINTER(default_id)
3640     );
3641     g_assert(priv-&gt;local_account != NULL);
3642     infc_browser_enforce_acl(browser, priv-&gt;root, NULL, NULL);
3643     inf_browser_acl_local_account_changed(
3644       INF_BROWSER(browser),
3645       priv-&gt;local_account,
3646       NULL
3647     );
3648   }
3649   infc_browser_remove_account_from_sheets(browser, priv-&gt;root, account);
3650   for(item = priv-&gt;subscription_requests; item != NULL; item = item-&gt;next)
3651   {
3652     subreq = (InfcBrowserSubreq*)item-&gt;data;
3653     switch(subreq-&gt;type)
3654     {
3655     case INFC_BROWSER_SUBREQ_CHAT:
3656     case INFC_BROWSER_SUBREQ_SESSION:
3657       break;
3658     case INFC_BROWSER_SUBREQ_ADD_NODE:
3659       infc_browser_remove_acl_sheet_from_sheet_set(
3660         subreq-&gt;shared.add_node.sheet_set,
3661         account
3662       );
3663       break;
3664     case INFC_BROWSER_SUBREQ_SYNC_IN:
3665       infc_browser_remove_acl_sheet_from_sheet_set(
3666         subreq-&gt;shared.sync_in.sheet_set,
3667         account
3668       );
3669       break;
3670     }
3671   }
3672   acc = g_hash_table_lookup(
3673     priv-&gt;accounts,
3674     INF_ACL_ACCOUNT_ID_TO_POINTER(account)
3675   );
3676   if(acc != NULL)
3677   {
3678     g_hash_table_steal(
3679       priv-&gt;accounts,
3680       INF_ACL_ACCOUNT_ID_TO_POINTER(account)
3681     );
3682   }
3683   else
3684   {
3685     report_acc.id = account;
3686     report_acc.name = NULL;     acc = &amp;report_acc;
3687   }
3688   if(request != NULL)
3689   {
3690     infc_request_manager_finish_request(
3691       priv-&gt;request_manager,
3692       request,
3693       inf_request_result_make_remove_acl_account(
3694         INF_BROWSER(browser),
3695         acc
3696       )
3697     );
3698   }
3699   inf_browser_acl_account_removed(INF_BROWSER(browser), acc, NULL);
3700   if(acc != &amp;report_acc)
3701     inf_acl_account_free(acc);
3702   return TRUE;
3703 }
3704 static gboolean
3705 infc_browser_handle_set_acl(InfcBrowser* browser,
3706                             InfXmlConnection* connection,
3707                             xmlNodePtr xml,
3708                             GError** error)
3709 {
3710   InfcBrowserPrivate* priv;
3711   InfcBrowserNode* node;
3712   InfAclSheetSet* sheet_set;
3713   GError* local_error;
3714   InfcRequest* request;
3715   gchar* request_type;
3716   InfBrowserIter iter;
3717   InfAclAccountId default_id;
3718   InfAclSheet* default_sheet;
3719   InfAclMask default_mask;
3720   priv = INFC_BROWSER_PRIVATE(browser);
3721   node = infc_browser_get_node_from_xml(browser, xml, "id", error);
3722   if(node == NULL) return FALSE;
3723   local_error = NULL;
3724   sheet_set = inf_acl_sheet_set_from_xml(xml, &amp;local_error);
3725   if(local_error != NULL)
3726   {
3727     g_propagate_error(error, local_error);
3728     return FALSE;
3729   }
3730   request = infc_request_manager_get_request_by_xml(
3731     priv-&gt;request_manager,
3732     NULL,
3733     xml,
3734     &amp;local_error
3735   );
3736   if(local_error != NULL)
3737   {
3738     g_propagate_error(error, local_error);
3739     return FALSE;
3740   }
3741   if(request != NULL)
3742   {
3743     g_object_get(G_OBJECT(request), "type", &amp;request_type, NULL);
3744     if(strcmp(request_type, "query-acl") == 0)
3745     {
3746       g_assert(node-&gt;acl_queried == FALSE);
3747       node-&gt;acl_queried = TRUE;
3748     }
3749     else if(strcmp(request_type, "set-acl") != 0)
3750     {
3751       g_set_error(
3752         error,
3753         inf_request_error_quark(),
3754         INF_REQUEST_ERROR_INVALID_SEQ,
3755         _("The request contains a sequence number referring to a request of "
3756           "type '%s', but a request of either 'query-acl' or 'set-acl' "
3757           "was expected."),
3758         request_type
3759       );
3760       g_free(request_type);
3761       return FALSE;
3762     }
3763   }
3764   iter.node_id = node-&gt;id;
3765   iter.node = node;
3766   if(sheet_set != NULL)
3767   {
3768     if(sheet_set-&gt;n_sheets &gt; 0)
3769     {
3770       if(node == priv-&gt;root)
3771       {
3772         default_id = inf_acl_account_id_from_string("default");
3773         default_sheet =
3774           inf_acl_sheet_set_find_sheet(sheet_set, default_id);
3775         if(default_sheet != NULL)
3776         {
3777           default_mask = default_sheet-&gt;mask;
3778           inf_acl_mask_and(
3779             &amp;default_sheet-&gt;perms,
3780             &amp;default_sheet-&gt;mask,
3781             &amp;default_sheet-&gt;perms
3782           );
3783           inf_acl_mask_neg(&amp;default_mask, &amp;default_mask);
3784           inf_acl_mask_and(
3785             &amp;default_mask,
3786             &amp;INF_ACL_MASK_DEFAULT,
3787             &amp;default_mask
3788           );
3789           inf_acl_mask_or(
3790             &amp;default_sheet-&gt;perms,
3791             &amp;default_mask,
3792             &amp;default_sheet-&gt;perms
3793           );
3794           default_sheet-&gt;mask = INF_ACL_MASK_ALL;
3795         }
3796       }
3797       node-&gt;acl = inf_acl_sheet_set_merge_sheets(node-&gt;acl, sheet_set);
3798       infc_browser_enforce_acl(browser, node, request, NULL);
3799       inf_browser_acl_changed(
3800         INF_BROWSER(browser),
3801         &amp;iter,
3802         sheet_set,
3803         INF_REQUEST(request)
3804       );
3805     }
3806     inf_acl_sheet_set_free(sheet_set);
3807   }
3808   if(request != NULL)
3809   {
3810     g_object_get(G_OBJECT(request), "type", &amp;request_type, NULL);
3811     if(strcmp(request_type, "query-acl") == 0)
3812     {
3813       infc_request_manager_finish_request(
3814         priv-&gt;request_manager,
3815         request,
3816         inf_request_result_make_query_acl(
3817           INF_BROWSER(browser),
3818           &amp;iter,
3819           node-&gt;acl
3820         )
3821       );
3822     }
3823     else
3824     {
3825       infc_request_manager_finish_request(
3826         priv-&gt;request_manager,
3827         request,
3828         inf_request_result_make_set_acl(INF_BROWSER(browser), &amp;iter)
3829       );
3830     }
3831     g_free(request_type);
3832   }
3833   return TRUE;
3834 }
3835 static gboolean
3836 infc_browser_handle_request_failed(InfcBrowser* browser,
3837                                    InfXmlConnection* connection,
3838                                    xmlNodePtr xml,
3839                                    GError** error)
3840 {
3841   InfcBrowserPrivate* priv;
3842   InfcBrowserClass* browserc_class;
3843   InfcRequest* request;
3844   xmlChar* domain;
3845   gboolean has_code;
3846   guint code;
3847   GError* req_error;
3848   priv = INFC_BROWSER_PRIVATE(browser);
3849   browserc_class = INFC_BROWSER_GET_CLASS(browser);
3850   request = infc_request_manager_get_request_by_xml_required(
3851     priv-&gt;request_manager,
3852     NULL,
3853     xml,
3854     error
3855   );
3856   if(request == NULL) return FALSE;
3857   has_code = inf_xml_util_get_attribute_uint_required(
3858     xml,
3859     "code",
3860     &amp;code,
3861     error
3862   );
3863   if(has_code == FALSE) return FALSE;
3864   domain = inf_xml_util_get_attribute_required(xml, "domain", error);
3865   if(domain == NULL) return FALSE;
3866   req_error = NULL;
3867   if(g_quark_from_string((gchar*)domain) == inf_directory_error_quark())
3868   {
3869     g_set_error_literal(
3870       &amp;req_error,
3871       inf_directory_error_quark(),
3872       code,
3873       inf_directory_strerror(code)
3874     );
3875   }
3876   else if(g_quark_from_string((gchar*)domain) == inf_request_error_quark())
3877   {
3878     g_set_error_literal(
3879       &amp;req_error,
3880       inf_request_error_quark(),
3881       code,
3882       inf_request_strerror(code)
3883     );
3884   }
3885   else
3886   {
3887     g_set_error(
3888       &amp;req_error,
3889       inf_request_error_quark(),
3890       INF_REQUEST_ERROR_UNKNOWN_DOMAIN,
3891       _("Error comes from unknown error domain '%s' (code %u)"),
3892       (const gchar*)domain,
3893       code
3894     );
3895   }
3896   xmlFree(domain);
3897   infc_request_manager_fail_request(
3898     priv-&gt;request_manager,
3899     request,
3900     req_error
3901   );
3902   g_error_free(req_error);
3903   return TRUE;
3904 }
3905 static InfCommunicationScope
3906 infc_browser_communication_object_received(InfCommunicationObject* object,
3907                                            InfXmlConnection* connection,
3908                                            xmlNodePtr node)
3909 {
3910   InfcBrowser* browser;
3911   InfcBrowserPrivate* priv;
3912   GError* local_error;
3913   GError* seq_error;
3914   InfcRequest* request;
3915   browser = INFC_BROWSER(object);
3916   priv = INFC_BROWSER_PRIVATE(browser);
3917   local_error = NULL;
3918   if(priv-&gt;status == INF_BROWSER_OPENING &amp;&amp;
3919      strcmp((const gchar*)node-&gt;name, "welcome") == 0)
3920   {
3921     if(priv-&gt;welcome_timeout != NULL)
3922     {
3923       inf_io_remove_timeout(priv-&gt;io, priv-&gt;welcome_timeout);
3924       priv-&gt;welcome_timeout = NULL;
3925     }
3926     if(!infc_browser_handle_welcome(browser, connection, node, &amp;local_error))
3927     {
3928       inf_browser_error(INF_BROWSER(browser), local_error);
3929       g_error_free(local_error);
3930       local_error = NULL;
3931       priv-&gt;status = INF_BROWSER_CLOSED;
3932       g_object_notify(G_OBJECT(browser), "status");
3933     }
3934   }
3935   else if(strcmp((const gchar*)node-&gt;name, "request-failed") == 0)
3936   {
3937     infc_browser_handle_request_failed(
3938       browser,
3939       connection,
3940       node,
3941       &amp;local_error
3942     );
3943   }
3944   else if(strcmp((const gchar*)node-&gt;name, "explore-begin") == 0)
3945   {
3946     infc_browser_handle_explore_begin(
3947       browser,
3948       connection,
3949       node,
3950       &amp;local_error
3951     );
3952   }
3953   else if(strcmp((const gchar*)node-&gt;name, "explore-end") == 0)
3954   {
3955     infc_browser_handle_explore_end(
3956       browser,
3957       connection,
3958       node,
3959       &amp;local_error
3960     );
3961   }
3962   else if(strcmp((const gchar*)node-&gt;name, "add-node") == 0)
3963   {
3964     infc_browser_handle_add_node(
3965       browser,
3966       connection,
3967       node,
3968       &amp;local_error
3969     );
3970   }
3971   else if(strcmp((const gchar*)node-&gt;name, "sync-in") == 0)
3972   {
3973     infc_browser_handle_sync_in(
3974       browser,
3975       connection,
3976       node,
3977       &amp;local_error
3978     );
3979   }
3980   else if(strcmp((const gchar*)node-&gt;name, "remove-node") == 0)
3981   {
3982     infc_browser_handle_remove_node(
3983       browser,
3984       connection,
3985       node,
3986       &amp;local_error
3987     );
3988   }
3989   else if(strcmp((const gchar*)node-&gt;name, "subscribe-session") == 0)
3990   {
3991     infc_browser_handle_subscribe_session(
3992       browser,
3993       connection,
3994       node,
3995       &amp;local_error
3996     );
3997   }
3998   else if(strcmp((const gchar*)node-&gt;name, "subscribe-chat") == 0)
3999   {
4000     infc_browser_handle_subscribe_chat(
4001       browser,
4002       connection,
4003       node,
4004       &amp;local_error
4005     );
4006   }
4007   else if(strcmp((const gchar*)node-&gt;name, "save-session-in-progress") == 0)
4008   {
4009     infc_browser_handle_save_session_in_progress(
4010       browser,
4011       connection,
4012       node,
4013       &amp;local_error
4014     );
4015   }
4016   else if(strcmp((const gchar*)node-&gt;name, "saved-session") == 0)
4017   {
4018     infc_browser_handle_saved_session(
4019       browser,
4020       connection,
4021       node,
4022       &amp;local_error
4023     );
4024   }
4025   else if(strcmp((const gchar*)node-&gt;name, "acl-account-list-begin") == 0)
4026   {
4027     infc_browser_handle_acl_account_list_begin(
4028       browser,
4029       connection,
4030       node,
4031       &amp;local_error
4032     );
4033   }
4034   else if(strcmp((const gchar*)node-&gt;name, "acl-account-list-end") == 0)
4035   {
4036     infc_browser_handle_acl_account_list_end(
4037       browser,
4038       connection,
4039       node,
4040       &amp;local_error
4041     );
4042   }
4043   else if(strcmp((const gchar*)node-&gt;name, "add-acl-account") == 0)
4044   {
4045     infc_browser_handle_add_acl_account(
4046       browser,
4047       connection,
4048       node,
4049       &amp;local_error
4050     );
4051   }
4052   else if(strcmp((const gchar*)node-&gt;name, "lookup-acl-accounts") == 0)
4053   {
4054     infc_browser_handle_lookup_acl_accounts(
4055       browser,
4056       connection,
4057       node,
4058       &amp;local_error
4059     );
4060   }
4061   else if(strcmp((const gchar*)node-&gt;name, "change-acl-account") == 0)
4062   {
4063     infc_browser_handle_change_acl_account(
4064       browser,
4065       connection,
4066       node,
4067       &amp;local_error
4068     );
4069   }
4070   else if(strcmp((const gchar*)node-&gt;name, "create-acl-account") == 0)
4071   {
4072     infc_browser_handle_create_acl_account(
4073       browser,
4074       connection,
4075       node,
4076       &amp;local_error
4077     );
4078   }
4079   else if(strcmp((const gchar*)node-&gt;name, "remove-acl-account") == 0)
4080   {
4081     infc_browser_handle_remove_acl_account(
4082       browser,
4083       connection,
4084       node,
4085       &amp;local_error
4086     );
4087   }
4088   else if(strcmp((const gchar*)node-&gt;name, "set-acl") == 0)
4089   {
4090     infc_browser_handle_set_acl(
4091       browser,
4092       connection,
4093       node,
4094       &amp;local_error
4095     );
4096   }
4097   else
4098   {
4099     g_set_error(
4100       &amp;local_error,
4101       inf_directory_error_quark(),
4102       INF_DIRECTORY_ERROR_UNEXPECTED_MESSAGE,
4103       _("Received unexpected network message \"%s\""),
4104       (const gchar*)node-&gt;name
4105     );
4106   }
4107   if(local_error != NULL)
4108   {
4109     request = infc_request_manager_get_request_by_xml(
4110       priv-&gt;request_manager,
4111       NULL,
4112       node,
4113       NULL
4114     );
4115     if(request != NULL)
4116     {
4117       seq_error = NULL;
4118       g_set_error(
4119         &amp;seq_error,
4120         inf_request_error_quark(),
4121         INF_REQUEST_ERROR_REPLY_UNPROCESSED,
4122         _("Server reply could not be processed: %s"),
4123         local_error-&gt;message
4124       );
4125       infc_request_manager_fail_request(
4126         priv-&gt;request_manager,
4127         request,
4128         seq_error
4129       );
4130       g_error_free(seq_error);
4131     }
4132     inf_browser_error(INF_BROWSER(browser), local_error);
4133     g_error_free(local_error);
4134   }
4135   return INF_COMMUNICATION_SCOPE_PTP;
4136 }
4137 static void
4138 infc_browser_communication_object_sent(InfCommunicationObject* object,
4139                                        InfXmlConnection* connection,
4140                                        xmlNodePtr xml)
4141 {
4142   InfcBrowser* browser;
4143   InfcBrowserPrivate* priv;
4144   InfcBrowserNode* node;
4145   gboolean has_id;
4146   guint node_id;
4147   GSList* item;
4148   InfCommunicationJoinedGroup* sync_group;
4149   InfcBrowserSubreq* subreq;
4150   InfChatBuffer* buffer;
4151   InfChatSession* session;
4152   InfcSessionProxy* proxy;
4153   InfBrowserIter parent_iter;
4154   InfBrowserIter iter;
4155   if(strcmp((const char*)xml-&gt;name, "subscribe-ack") == 0)
4156   {
4157     browser = INFC_BROWSER(object);
4158     priv = INFC_BROWSER_PRIVATE(browser);
4159     has_id = inf_xml_util_get_attribute_uint(xml, "id", &amp;node_id, NULL);
4160     for(item = priv-&gt;subscription_requests; item != NULL; item = item-&gt;next)
4161     {
4162       subreq = (InfcBrowserSubreq*)item-&gt;data;
4163       if( (has_id  &amp;&amp; subreq-&gt;node_id == node_id) ||
4164           (!has_id &amp;&amp; subreq-&gt;node_id == 0))
4165       {
4166         break;
4167       }
4168     }
4169     if(item == NULL) return;
4170     infc_browser_unlink_subreq(browser, subreq);
4171     switch(subreq-&gt;type)
4172     {
4173     case INFC_BROWSER_SUBREQ_CHAT:
4174       g_assert(has_id == FALSE);
4175       g_assert(priv-&gt;chat_session == NULL);
4176       buffer = inf_chat_buffer_new(256);
4177       session = inf_chat_session_new(
4178         priv-&gt;communication_manager,
4179         buffer,
4180         INF_SESSION_SYNCHRONIZING,
4181         INF_COMMUNICATION_GROUP(subreq-&gt;shared.chat.subscription_group),
4182         connection
4183       );
4184       g_object_unref(buffer);
4185       proxy = g_object_new(INFC_TYPE_SESSION_PROXY, "session", session, NULL);
4186       inf_communication_group_set_target(
4187         INF_COMMUNICATION_GROUP(subreq-&gt;shared.chat.subscription_group),
4188         INF_COMMUNICATION_OBJECT(proxy)
4189       );
4190       infc_session_proxy_set_connection(
4191         proxy,
4192         subreq-&gt;shared.chat.subscription_group,
4193         connection,
4194         priv-&gt;seq_id
4195       );
4196       g_object_unref(session);
4197       inf_browser_subscribe_session(
4198         INF_BROWSER(browser),
4199         NULL,
4200         INF_SESSION_PROXY(proxy),
4201         INF_REQUEST(subreq-&gt;shared.chat.request)
4202       );
4203       if(subreq-&gt;shared.chat.request != NULL)
4204       {
4205         infc_request_manager_finish_request(
4206           priv-&gt;request_manager,
4207           subreq-&gt;shared.chat.request,
4208           inf_request_result_make_subscribe_chat(
4209             INF_BROWSER(browser),
4210             INF_SESSION_PROXY(proxy)
4211           )
4212         );
4213       }
4214       g_object_unref(proxy);
4215       break;
4216     case INFC_BROWSER_SUBREQ_SESSION:
4217       g_assert(has_id == TRUE);
4218       if(subreq-&gt;shared.session.node != NULL)
4219       {
4220         g_assert(subreq-&gt;shared.session.node-&gt;id == node_id);
4221         infc_browser_subscribe_session(
4222           browser,
4223           subreq-&gt;shared.session.node,
4224           subreq-&gt;shared.session.request,
4225           subreq-&gt;shared.session.subscription_group,
4226           connection,
4227           TRUE
4228         );
4229         if(subreq-&gt;shared.session.request != NULL)
4230         {
4231           iter.node = subreq-&gt;shared.session.node;
4232           iter.node_id = node_id;
4233           g_assert(
4234             subreq-&gt;shared.session.node-&gt;type == INFC_BROWSER_NODE_NOTE_KNOWN
4235           );
4236           proxy = subreq-&gt;shared.session.node-&gt;shared.known.session;
4237           g_assert(proxy != NULL);
4238           infc_request_manager_finish_request(
4239             priv-&gt;request_manager,
4240             subreq-&gt;shared.session.request,
4241             inf_request_result_make_subscribe_session(
4242               INF_BROWSER(browser),
4243               &amp;iter,
4244               INF_SESSION_PROXY(proxy)
4245             )
4246           );
4247         }
4248       }
4249       break;
4250     case INFC_BROWSER_SUBREQ_ADD_NODE:
4251       g_assert(has_id == TRUE);
4252       if(subreq-&gt;shared.add_node.parent != NULL)
4253       {
4254         g_assert(
4255           g_hash_table_lookup(priv-&gt;nodes, GUINT_TO_POINTER(node_id)) == NULL
4256         );
4257         g_assert(infc_browser_find_subreq(browser, node_id) == NULL);
4258         node = infc_browser_node_add_note(
4259           browser,
4260           subreq-&gt;shared.add_node.parent,
4261           subreq-&gt;shared.add_node.request,
4262           node_id,
4263           subreq-&gt;shared.add_node.name,
4264           subreq-&gt;shared.add_node.plugin-&gt;note_type,
4265           subreq-&gt;shared.add_node.sheet_set,
4266           NULL
4267         );
4268         g_assert(node-&gt;type == INFC_BROWSER_NODE_NOTE_KNOWN);
4269         infc_browser_subscribe_session(
4270           browser,
4271           node,
4272           subreq-&gt;shared.add_node.request,
4273           subreq-&gt;shared.add_node.subscription_group,
4274           connection,
4275           FALSE
4276         );
4277         if(subreq-&gt;shared.add_node.request != NULL)
4278         {
4279           parent_iter.node_id = subreq-&gt;shared.sync_in.parent-&gt;id;
4280           parent_iter.node = subreq-&gt;shared.sync_in.parent;
4281           iter.node = node;
4282           iter.node_id = node_id;
4283           infc_request_manager_finish_request(
4284             priv-&gt;request_manager,
4285             subreq-&gt;shared.add_node.request,
4286             inf_request_result_make_add_node(
4287               INF_BROWSER(browser),
4288               &amp;parent_iter,
4289               &amp;iter
4290             )
4291           );
4292         }
4293       }
4294       break;
4295     case INFC_BROWSER_SUBREQ_SYNC_IN:
4296       g_assert(has_id == TRUE);
4297       if(subreq-&gt;shared.sync_in.parent != NULL)
4298       {
4299         g_assert(
4300           g_hash_table_lookup(priv-&gt;nodes, GUINT_TO_POINTER(node_id)) == NULL
4301         );
4302         g_assert(infc_browser_find_subreq(browser, node_id) == NULL);
4303         proxy = g_object_new(
4304           INFC_TYPE_SESSION_PROXY,
4305           "session", subreq-&gt;shared.sync_in.session,
4306           NULL
4307         );
4308         sync_group = subreq-&gt;shared.sync_in.synchronization_group;
4309         inf_communication_group_set_target(
4310           INF_COMMUNICATION_GROUP(sync_group),
4311           INF_COMMUNICATION_OBJECT(proxy)
4312         );
4313         inf_session_synchronize_to(
4314           subreq-&gt;shared.sync_in.session,
4315           INF_COMMUNICATION_GROUP(sync_group),
4316           connection
4317         );
4318         node = infc_browser_node_add_note(
4319           browser,
4320           subreq-&gt;shared.sync_in.parent,
4321           subreq-&gt;shared.sync_in.request,
4322           node_id,
4323           subreq-&gt;shared.sync_in.name,
4324           subreq-&gt;shared.sync_in.plugin-&gt;note_type,
4325           subreq-&gt;shared.sync_in.sheet_set,
4326           proxy
4327         );
4328         g_assert(node-&gt;type == INFC_BROWSER_NODE_NOTE_KNOWN);
4329         parent_iter.node_id = subreq-&gt;shared.sync_in.parent-&gt;id;
4330         parent_iter.node = subreq-&gt;shared.sync_in.parent;
4331         iter.node_id = node-&gt;id;
4332         iter.node = node;
4333         if(subreq-&gt;shared.sync_in.subscription_group != NULL)
4334         {
4335           g_assert(
4336             inf_session_get_subscription_group(
4337               subreq-&gt;shared.sync_in.session
4338             ) == NULL
4339           );
4340           if(subreq-&gt;shared.sync_in.subscription_group != sync_group)
4341           {
4342             inf_communication_group_set_target(
4343               INF_COMMUNICATION_GROUP(
4344                 subreq-&gt;shared.sync_in.subscription_group
4345               ),
4346               INF_COMMUNICATION_OBJECT(proxy)
4347             );
4348           }
4349           infc_session_proxy_set_connection(
4350             proxy,
4351             subreq-&gt;shared.sync_in.subscription_group,
4352             connection,
4353             priv-&gt;seq_id
4354           );
4355           inf_browser_subscribe_session(
4356             INF_BROWSER(browser),
4357             &amp;iter,
4358             INF_SESSION_PROXY(proxy),
4359             INF_REQUEST(subreq-&gt;shared.sync_in.request)
4360           );
4361         }
4362         g_object_unref(proxy);
4363         g_assert(subreq-&gt;shared.sync_in.request != NULL);
4364         infc_request_manager_finish_request(
4365           priv-&gt;request_manager,
4366           subreq-&gt;shared.sync_in.request,
4367           inf_request_result_make_add_node(
4368             INF_BROWSER(browser),
4369             &amp;parent_iter,
4370             &amp;iter
4371           )
4372         );
4373       }
4374       break;
4375     default:
4376       g_assert_not_reached();
4377       break;
4378     }
4379     infc_browser_free_subreq(subreq);
4380   }
4381 }
4382 static void
4383 infc_browser_browser_subscribe_session(InfBrowser* browser,
4384                                        const InfBrowserIter* iter,
4385                                        InfSessionProxy* proxy,
4386                                        InfRequest* request)
4387 {
4388   InfcBrowserPrivate* priv;
4389   InfcBrowserNode* node;
4390   InfSession* session;
4391   priv = INFC_BROWSER_PRIVATE(browser);
4392   g_assert(INFC_IS_SESSION_PROXY(proxy));
4393   g_object_get(G_OBJECT(proxy), "session", &amp;session, NULL);
4394   if(iter != NULL)
4395   {
4396     node = (InfcBrowserNode*)iter-&gt;node;
4397     g_assert(
4398       g_hash_table_lookup(priv-&gt;nodes, GUINT_TO_POINTER(iter-&gt;node_id)) ==
4399       node
4400     );
4401     g_assert(node-&gt;type == INFC_BROWSER_NODE_NOTE_KNOWN);
4402     g_assert(node-&gt;shared.known.session == NULL);
4403     node-&gt;shared.known.session = INFC_SESSION_PROXY(proxy);
4404     g_object_ref(proxy);
4405     g_object_set_qdata_full(
4406       G_OBJECT(session),
4407       infc_browser_session_proxy_quark,
4408       inf_browser_iter_copy(iter),
4409       (GDestroyNotify)inf_browser_iter_free
4410     );
4411   }
4412   else
4413   {
4414     g_assert(priv-&gt;chat_session == NULL);
4415     g_object_ref(proxy);
4416     priv-&gt;chat_session = INFC_SESSION_PROXY(proxy);
4417     g_object_notify(G_OBJECT(browser), "chat-session");
4418   }
4419   g_signal_connect(
4420     session,
4421     "notify::subscription-group",
4422     G_CALLBACK(infc_browser_session_notify_subscription_group_cb),
4423     browser
4424   );
4425   g_object_unref(session);
4426 }
4427 static gboolean
4428 infc_browser_browser_get_root(InfBrowser* browser,
4429                               InfBrowserIter* iter)
4430 {
4431   InfcBrowserPrivate* priv;
4432   g_return_val_if_fail(INFC_IS_BROWSER(browser), FALSE);
4433   g_return_val_if_fail(iter != NULL, FALSE);
4434   priv = INFC_BROWSER_PRIVATE(browser);
4435   g_return_val_if_fail(priv-&gt;status == INF_BROWSER_OPEN, FALSE);
4436   g_assert(priv-&gt;root != NULL);
4437   iter-&gt;node_id = priv-&gt;root-&gt;id;
4438   iter-&gt;node = priv-&gt;root;
4439   return TRUE;
4440 }
4441 static gboolean
4442 infc_browser_browser_get_next(InfBrowser* browser,
4443                               InfBrowserIter* iter)
4444 {
4445   InfcBrowserNode* node;
4446   g_return_val_if_fail(INFC_IS_BROWSER(browser), FALSE);
4447   infc_browser_return_val_if_iter_fail(browser, iter, FALSE);
4448   node = (InfcBrowserNode*)iter-&gt;node;
4449   if(node-&gt;next != NULL)
4450   {
4451     iter-&gt;node_id = node-&gt;next-&gt;id;
4452     iter-&gt;node = node-&gt;next;
4453     return TRUE;
4454   }
4455   else
4456   {
4457     return FALSE;
4458   }
4459 }
4460 static gboolean
4461 infc_browser_browser_get_prev(InfBrowser* browser,
4462                               InfBrowserIter* iter)
4463 {
4464   InfcBrowserNode* node;
4465   g_return_val_if_fail(INFC_IS_BROWSER(browser), FALSE);
4466   infc_browser_return_val_if_iter_fail(browser, iter, FALSE);
4467   node = (InfcBrowserNode*)iter-&gt;node;
4468   if(node-&gt;prev != NULL)
4469   {
4470     iter-&gt;node_id = node-&gt;prev-&gt;id;
4471     iter-&gt;node = node-&gt;prev;
4472     return TRUE;
4473   }
4474   else
4475   {
4476     return FALSE;
4477   }
4478 }
4479 static gboolean
4480 infc_browser_browser_get_parent(InfBrowser* browser,
4481                                 InfBrowserIter* iter)
4482 {
4483   InfcBrowserNode* node;
4484   g_return_val_if_fail(INFC_IS_BROWSER(browser), FALSE);
4485   infc_browser_return_val_if_iter_fail(browser, iter, FALSE);
4486   node = (InfcBrowserNode*)iter-&gt;node;
4487   if(node-&gt;parent != NULL)
4488   {
4489     iter-&gt;node_id = node-&gt;parent-&gt;id;
4490     iter-&gt;node = node-&gt;parent;
4491     return TRUE;
4492   }
4493   else
4494   {
4495     return FALSE;
4496   }
4497 }
4498 static gboolean
4499 infc_browser_browser_get_child(InfBrowser* browser,
4500                                InfBrowserIter* iter)
4501 {
4502   InfcBrowserNode* node;
4503   g_return_val_if_fail(INFC_IS_BROWSER(browser), FALSE);
4504   infc_browser_return_val_if_iter_fail(browser, iter, FALSE);
4505   node = (InfcBrowserNode*)iter-&gt;node;
4506   g_return_val_if_fail(node-&gt;shared.subdir.explored == TRUE, FALSE);
4507   if(node-&gt;shared.subdir.child != NULL)
4508   {
4509     iter-&gt;node_id = node-&gt;shared.subdir.child-&gt;id;
4510     iter-&gt;node = node-&gt;shared.subdir.child;
4511     return TRUE;
4512   }
4513   else
4514   {
4515     return FALSE;
4516   }
4517 }
4518 static InfRequest*
4519 infc_browser_browser_explore(InfBrowser* browser,
4520                              const InfBrowserIter* iter,
4521                              InfRequestFunc func,
4522                              gpointer user_data)
4523 {
4524   InfcBrowserPrivate* priv;
4525   InfcBrowserNode* node;
4526   InfcRequest* request;
4527   xmlNodePtr xml;
4528   g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
4529   infc_browser_return_val_if_iter_fail(browser, iter, NULL);
4530   node = (InfcBrowserNode*)iter-&gt;node;
4531   infc_browser_return_val_if_subdir_fail(node, NULL);
4532   g_return_val_if_fail(node-&gt;shared.subdir.explored == FALSE, NULL);
4533   g_return_val_if_fail(
4534     inf_browser_get_pending_request(browser, iter, "explore-node") == NULL,
4535     NULL
4536   );
4537   priv = INFC_BROWSER_PRIVATE(browser);
4538   g_return_val_if_fail(priv-&gt;connection != NULL, NULL);
4539   g_return_val_if_fail(priv-&gt;status == INF_BROWSER_OPEN, NULL);
4540   request = infc_request_manager_add_request(
4541     priv-&gt;request_manager,
4542     INFC_TYPE_PROGRESS_REQUEST,
4543     "explore-node",
4544     G_CALLBACK(func),
4545     user_data,
4546     "node_id", node-&gt;id,
4547     NULL
4548   );
4549   inf_browser_begin_request(browser, iter, INF_REQUEST(request));
4550   xml = infc_browser_request_to_xml(request);
4551   inf_xml_util_set_attribute_uint(xml, "id", node-&gt;id);
4552   inf_communication_group_send_message(
4553     INF_COMMUNICATION_GROUP(priv-&gt;group),
4554     priv-&gt;connection,
4555     xml
4556   );
4557   return INF_REQUEST(request);
4558 }
4559 static gboolean
4560 infc_browser_browser_get_explored(InfBrowser* browser,
4561                                   const InfBrowserIter* iter)
4562 {
4563   InfcBrowserNode* node;
4564   g_return_val_if_fail(INFC_IS_BROWSER(browser), FALSE);
4565   infc_browser_return_val_if_iter_fail(browser, iter, FALSE);
4566   node = (InfcBrowserNode*)iter-&gt;node;
4567   infc_browser_return_val_if_subdir_fail(node, FALSE);
4568   return node-&gt;shared.subdir.explored;
4569 }
4570 static gboolean
4571 infc_browser_browser_is_subdirectory(InfBrowser* browser,
4572                                      const InfBrowserIter* iter)
4573 {
4574   InfcBrowserNode* node;
4575   g_return_val_if_fail(INFC_IS_BROWSER(browser), FALSE);
4576   infc_browser_return_val_if_iter_fail(browser, iter, FALSE);
4577   node = (InfcBrowserNode*)iter-&gt;node;
4578   if(node-&gt;type == INFC_BROWSER_NODE_SUBDIRECTORY)
4579     return TRUE;
4580   return FALSE;
4581 }
4582 static InfRequest*
4583 infc_browser_browser_add_note(InfBrowser* infbrowser,
4584                               const InfBrowserIter* iter,
4585                               const char* name,
4586                               const char* type,
4587                               const InfAclSheetSet* sheet_set,
4588                               InfSession* session,
4589                               gboolean initial_subscribe,
4590                               InfRequestFunc func,
4591                               gpointer user_data)
4592 {
4593   InfcBrowser* browser;
4594   InfcBrowserPrivate* priv;
4595   InfcBrowserNode* node;
4596   const InfcNotePlugin* plugin;
4597   InfcRequest* request;
4598   xmlNodePtr xml;
4599   g_return_val_if_fail(INFC_IS_BROWSER(infbrowser), NULL);
4600   browser = INFC_BROWSER(infbrowser);
4601   infc_browser_return_val_if_iter_fail(browser, iter, NULL);
4602   node = (InfcBrowserNode*)iter-&gt;node;
4603   infc_browser_return_val_if_subdir_fail(node, NULL);
4604   g_return_val_if_fail(node-&gt;shared.subdir.explored == TRUE, NULL);
4605   priv = INFC_BROWSER_PRIVATE(browser);
4606   g_return_val_if_fail(priv-&gt;connection != NULL, NULL);
4607   g_return_val_if_fail(priv-&gt;status == INF_BROWSER_OPEN, NULL);
4608   plugin = infc_browser_lookup_plugin(browser, type);
4609   g_return_val_if_fail(plugin != NULL, NULL);
4610   request = infc_request_manager_add_request(
4611     priv-&gt;request_manager,
4612     INFC_TYPE_REQUEST,
4613     "add-node",
4614     G_CALLBACK(func),
4615     user_data,
4616     "node-id", iter-&gt;node_id,
4617     NULL
4618   );
4619   if(session != NULL)
4620   {
4621     g_object_ref(session);
4622     g_object_set_qdata_full(
4623       G_OBJECT(request),
4624       infc_browser_sync_in_session_quark,
4625       session,
4626       g_object_unref
4627     );
4628     g_object_set_qdata(
4629       G_OBJECT(request),
4630       infc_browser_sync_in_plugin_quark,
4631       *(gpointer*)(gpointer)&amp;plugin
4632     );
4633   }
4634   inf_browser_begin_request(INF_BROWSER(browser), iter, INF_REQUEST(request));
4635   xml = infc_browser_request_to_xml(request);
4636   inf_xml_util_set_attribute_uint(xml, "parent", node-&gt;id);
4637   inf_xml_util_set_attribute(xml, "type", type);
4638   inf_xml_util_set_attribute(xml, "name", name);
4639   if(sheet_set != NULL)
4640     inf_acl_sheet_set_to_xml(sheet_set, xml);
4641   if(initial_subscribe != FALSE)
4642     xmlNewChild(xml, NULL, (const xmlChar*)"subscribe", NULL);
4643   if(session != NULL)
4644     xmlNewChild(xml, NULL, (const xmlChar*)"sync-in", NULL);
4645   inf_communication_group_send_message(
4646     INF_COMMUNICATION_GROUP(priv-&gt;group),
4647     priv-&gt;connection,
4648     xml
4649   );
4650   return INF_REQUEST(request);
4651 }
4652 static InfRequest*
4653 infc_browser_browser_add_subdirectory(InfBrowser* infbrowser,
4654                                       const InfBrowserIter* iter,
4655                                       const char* name,
4656                                       const InfAclSheetSet* sheet_set,
4657                                       InfRequestFunc func,
4658                                       gpointer user_data)
4659 {
4660   InfcBrowser* browser;
4661   InfcBrowserPrivate* priv;
4662   InfcBrowserNode* node;
4663   InfcRequest* request;
4664   xmlNodePtr xml;
4665   g_return_val_if_fail(INFC_IS_BROWSER(infbrowser), NULL);
4666   browser = INFC_BROWSER(infbrowser);
4667   infc_browser_return_val_if_iter_fail(browser, iter, NULL);
4668   node = (InfcBrowserNode*)iter-&gt;node;
4669   infc_browser_return_val_if_subdir_fail(node, NULL);
4670   g_return_val_if_fail(node-&gt;shared.subdir.explored == TRUE, NULL);
4671   priv = INFC_BROWSER_PRIVATE(browser);
4672   g_return_val_if_fail(priv-&gt;connection != NULL, NULL);
4673   g_return_val_if_fail(priv-&gt;status == INF_BROWSER_OPEN, NULL);
4674   request = infc_request_manager_add_request(
4675     priv-&gt;request_manager,
4676     INFC_TYPE_REQUEST,
4677     "add-node",
4678     G_CALLBACK(func), user_data,
4679     "node-id", iter-&gt;node_id,
4680     NULL
4681   );
4682   inf_browser_begin_request(INF_BROWSER(browser), iter, INF_REQUEST(request));
4683   xml = infc_browser_request_to_xml(request);
4684   inf_xml_util_set_attribute_uint(xml, "parent", node-&gt;id);
4685   inf_xml_util_set_attribute(xml, "type", "InfSubdirectory");
4686   inf_xml_util_set_attribute(xml, "name", name);
4687   if(sheet_set != NULL)
4688     inf_acl_sheet_set_to_xml(sheet_set, xml);
4689   inf_communication_group_send_message(
4690     INF_COMMUNICATION_GROUP(priv-&gt;group),
4691     priv-&gt;connection,
4692     xml
4693   );
4694   return INF_REQUEST(request);
4695 }
4696 static InfRequest*
4697 infc_browser_browser_remove_node(InfBrowser* infbrowser,
4698                                  const InfBrowserIter* iter,
4699                                  InfRequestFunc func,
4700                                  gpointer user_data)
4701 {
4702   InfcBrowser* browser;
4703   InfcBrowserPrivate* priv;
4704   InfcBrowserNode* node;
4705   InfcRequest* request;
4706   xmlNodePtr xml;
4707   g_return_val_if_fail(INFC_IS_BROWSER(infbrowser), NULL);
4708   browser = INFC_BROWSER(infbrowser);
4709   infc_browser_return_val_if_iter_fail(browser, iter, NULL);
4710   priv = INFC_BROWSER_PRIVATE(browser);
4711   node = (InfcBrowserNode*)iter-&gt;node;
4712   g_return_val_if_fail(node-&gt;parent != NULL, NULL);
4713   g_return_val_if_fail(priv-&gt;connection != NULL, NULL);
4714   g_return_val_if_fail(priv-&gt;status == INF_BROWSER_OPEN, NULL);
4715   request = infc_request_manager_add_request(
4716     priv-&gt;request_manager,
4717     INFC_TYPE_REQUEST,
4718     "remove-node",
4719     G_CALLBACK(func),
4720     user_data,
4721     "node-id", iter-&gt;node_id,
4722     NULL
4723   );
4724   inf_browser_begin_request(INF_BROWSER(browser), iter, INF_REQUEST(request));
4725   xml = infc_browser_request_to_xml(request);
4726   inf_xml_util_set_attribute_uint(xml, "id", node-&gt;id);
4727   inf_communication_group_send_message(
4728     INF_COMMUNICATION_GROUP(priv-&gt;group),
4729     priv-&gt;connection,
4730     xml
4731   );
4732   return INF_REQUEST(request);
4733 }
4734 static const gchar*
4735 infc_browser_browser_get_node_name(InfBrowser* browser,
4736                                    const InfBrowserIter* iter)
4737 {
4738   InfcBrowserNode* node;
4739   g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
4740   infc_browser_return_val_if_iter_fail(browser, iter, NULL);
4741   node = (InfcBrowserNode*)iter-&gt;node;
4742   return node-&gt;name;
4743 }
4744 static const gchar*
4745 infc_browser_browser_get_node_type(InfBrowser* infbrowser,
4746                                    const InfBrowserIter* iter)
4747 {
4748   InfcBrowser* browser;
4749   InfcBrowserPrivate* priv;
4750   InfcBrowserNode* node;
4751   g_return_val_if_fail(INFC_IS_BROWSER(infbrowser), NULL);
4752   browser = INFC_BROWSER(infbrowser);
4753   infc_browser_return_val_if_iter_fail(browser, iter, NULL);
4754   priv = INFC_BROWSER_PRIVATE(browser);
4755   node = (InfcBrowserNode*)iter-&gt;node;
4756   switch(node-&gt;type)
4757   {
4758   case INFC_BROWSER_NODE_SUBDIRECTORY:
4759     g_return_val_if_reached(NULL);
4760     return NULL;
4761   case INFC_BROWSER_NODE_NOTE_KNOWN:
4762     return node-&gt;shared.known.plugin-&gt;note_type;
4763   case INFC_BROWSER_NODE_NOTE_UNKNOWN:
4764     return node-&gt;shared.unknown.type;
4765   default:
4766     g_assert_not_reached();
4767     return NULL;
4768   }
4769 }
4770 static InfRequest*
4771 infc_browser_browser_subscribe(InfBrowser* browser,
4772                                const InfBrowserIter* iter,
4773                                InfRequestFunc func,
4774                                gpointer user_data)
4775 {
4776   InfcBrowserPrivate* priv;
4777   InfcBrowserNode* node;
4778   InfcRequest* request;
4779   xmlNodePtr xml;
4780   g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
4781   infc_browser_return_val_if_iter_fail(INFC_BROWSER(browser), iter, NULL);
4782   priv = INFC_BROWSER_PRIVATE(browser);
4783   node = (InfcBrowserNode*)iter-&gt;node;
4784   g_return_val_if_fail(priv-&gt;connection != NULL, NULL);
4785   g_return_val_if_fail(priv-&gt;status == INF_BROWSER_OPEN, NULL);
4786   g_return_val_if_fail(node-&gt;type == INFC_BROWSER_NODE_NOTE_KNOWN, NULL);
4787   g_return_val_if_fail(node-&gt;shared.known.session == NULL, NULL);
4788   g_return_val_if_fail(
4789     inf_browser_get_pending_request(
4790       browser,
4791       iter,
4792       "subscribe-session"
4793     ) == NULL,
4794     NULL
4795   );
4796   request = infc_request_manager_add_request(
4797     priv-&gt;request_manager,
4798     INFC_TYPE_REQUEST,
4799     "subscribe-session",
4800     G_CALLBACK(func),
4801     user_data,
4802     "node-id", iter-&gt;node_id,
4803     NULL
4804   );
4805   inf_browser_begin_request(browser, iter, INF_REQUEST(request));
4806   xml = infc_browser_request_to_xml(request);
4807   inf_xml_util_set_attribute_uint(xml, "id", node-&gt;id);
4808   inf_communication_group_send_message(
4809     INF_COMMUNICATION_GROUP(priv-&gt;group),
4810     priv-&gt;connection,
4811     xml
4812   );
4813   return INF_REQUEST(request);
4814 }
4815 static InfSessionProxy*
4816 infc_browser_browser_get_session(InfBrowser* browser,
4817                                  const InfBrowserIter* iter)
4818 {
4819   InfcBrowserPrivate* priv;
4820   InfcBrowserNode* node;
4821   g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
4822   infc_browser_return_val_if_iter_fail(browser, iter, NULL);
4823   priv = INFC_BROWSER_PRIVATE(browser);
4824   node = (InfcBrowserNode*)iter-&gt;node;
4825   if(node-&gt;type != INFC_BROWSER_NODE_NOTE_KNOWN) return NULL;
4826   return INF_SESSION_PROXY(node-&gt;shared.known.session);
4827 }
4828 static GSList*
4829 infc_browser_browser_list_pending_requests(InfBrowser* browser,
4830                                            const InfBrowserIter* iter,
4831                                            const gchar* request_type)
4832 {
4833   InfcBrowserPrivate* priv;
4834   InfcBrowserListPendingRequestsForeachData data;
4835   data.iter = iter;
4836   data.result = NULL;
4837   g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
4838   if(iter != NULL)
4839   {
4840     infc_browser_return_val_if_iter_fail(browser, iter, NULL);
4841   }
4842   priv = INFC_BROWSER_PRIVATE(browser);
4843   if(priv-&gt;request_manager != NULL)
4844   {
4845     if(request_type == NULL)
4846     {
4847       infc_request_manager_foreach_request(
4848         priv-&gt;request_manager,
4849         infc_browser_browser_list_pending_requests_foreach_func,
4850         &amp;data
4851       );
4852     }
4853     else
4854     {
4855       infc_request_manager_foreach_named_request(
4856         priv-&gt;request_manager,
4857         request_type,
4858         infc_browser_browser_list_pending_requests_foreach_func,
4859         &amp;data
4860       );
4861     }
4862   }
4863   return data.result;
4864 }
4865 static gboolean
4866 infc_browser_browser_iter_from_request(InfBrowser* browser,
4867                                        InfRequest* request,
4868                                        InfBrowserIter* iter)
4869 {
4870   InfcBrowserPrivate* priv;
4871   InfcBrowserNode* node;
4872   guint node_id;
4873   g_return_val_if_fail(INFC_IS_BROWSER(browser), FALSE);
4874   g_return_val_if_fail(INFC_IS_REQUEST(request), FALSE);
4875   g_return_val_if_fail(iter != NULL, FALSE);
4876   priv = INFC_BROWSER_PRIVATE(browser);
4877   g_object_get(G_OBJECT(request), "node-id", &amp;node_id, NULL);
4878   if(node_id == G_MAXUINT) return FALSE;
4879   node = g_hash_table_lookup(priv-&gt;nodes, GUINT_TO_POINTER(node_id));
4880   if(node == NULL) return FALSE;
4881   iter-&gt;node_id = node_id;
4882   iter-&gt;node = node;
4883   return TRUE;
4884 }
4885 static InfRequest*
4886 infc_browser_browser_query_acl_account_list(InfBrowser* browser,
4887                                             InfRequestFunc func,
4888                                             gpointer user_data)
4889 {
4890   InfcBrowserPrivate* priv;
4891   InfcRequest* request;
4892   xmlNodePtr xml;
4893   InfAclAccount* accounts;
4894   guint n_accounts;
4895   g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
4896   priv = INFC_BROWSER_PRIVATE(browser);
4897   g_return_val_if_fail(priv-&gt;status == INF_BROWSER_OPEN, NULL);
4898   g_return_val_if_fail(
4899     inf_browser_get_pending_request(
4900       INF_BROWSER(browser),
4901       NULL,
4902       "query-acl-account-list"
4903     ) == NULL,
4904     NULL
4905   );
4906   request = infc_request_manager_add_request(
4907     priv-&gt;request_manager,
4908     INFC_TYPE_PROGRESS_REQUEST,
4909     "query-acl-account-list",
4910     G_CALLBACK(func),
4911     user_data,
4912     NULL
4913   );
4914   inf_browser_begin_request(browser, NULL, INF_REQUEST(request));
4915   switch(priv-&gt;account_list_status)
4916   {
4917   case INFC_BROWSER_ACCOUNT_LIST_NOT_QUERIED:
4918   case INFC_BROWSER_ACCOUNT_LIST_NO_NOTIFICATIONS:
4919     xml = infc_browser_request_to_xml(request);
4920     inf_communication_group_send_message(
4921       INF_COMMUNICATION_GROUP(priv-&gt;group),
4922       priv-&gt;connection,
4923       xml
4924     );
4925     break;
4926   case INFC_BROWSER_ACCOUNT_LIST_NOTIFICATIONS:
4927     accounts = infc_browser_make_acl_account_list(
4928       INFC_BROWSER(browser),
4929       &amp;n_accounts
4930     );
4931     infc_request_manager_finish_request(
4932       priv-&gt;request_manager,
4933       request,
4934       inf_request_result_make_query_acl_account_list(
4935         INF_BROWSER(browser),
4936         accounts,
4937         n_accounts,
4938         TRUE
4939       )
4940     );
4941     g_free(accounts);
4942     request = NULL;
4943     break;
4944   }
4945   return INF_REQUEST(request);
4946 }
4947 static const InfAclAccount*
4948 infc_browser_browser_get_acl_default_account(InfBrowser* infbrowser)
4949 {
4950   InfcBrowser* browser;
4951   InfcBrowserPrivate* priv;
4952   InfAclAccountId default_id;
4953   InfAclAccount* default_account;
4954   browser = INFC_BROWSER(infbrowser);
4955   priv = INFC_BROWSER_PRIVATE(browser);
4956   g_return_val_if_fail(priv-&gt;status == INF_BROWSER_OPEN, NULL);
4957   default_id = inf_acl_account_id_from_string("default");
4958   default_account = g_hash_table_lookup(
4959     priv-&gt;accounts,
4960     INF_ACL_ACCOUNT_ID_TO_POINTER(default_id)
4961   );
4962   g_assert(default_account != NULL);
4963   return default_account;
4964 }
4965 static const InfAclAccount*
4966 infc_browser_browser_get_acl_local_account(InfBrowser* infbrowser)
4967 {
4968   InfcBrowser* browser;
4969   InfcBrowserPrivate* priv;
4970   browser = INFC_BROWSER(infbrowser);
4971   priv = INFC_BROWSER_PRIVATE(browser);
4972   g_return_val_if_fail(priv-&gt;status == INF_BROWSER_OPEN, NULL);
4973   g_assert(priv-&gt;local_account != NULL);
4974   return priv-&gt;local_account;
4975 }
4976 static InfRequest*
4977 infc_browser_browser_lookup_acl_accounts(InfBrowser* infbrowser,
4978                                          const InfAclAccountId* ids,
4979                                          guint n_ids,
4980                                          InfRequestFunc func,
4981                                          gpointer user_data)
4982 {
4983   InfcBrowser* browser;
4984   InfcBrowserPrivate* priv;
4985   InfcRequest* request;
4986   guint i;
4987   const InfAclAccount* account;
4988   InfAclAccount* accounts;
4989   guint n_accounts;
4990   xmlNodePtr xml;
4991   InfAclAccountId* ids_req;
4992   browser = INFC_BROWSER(infbrowser);
4993   priv = INFC_BROWSER_PRIVATE(browser);
4994   request = infc_request_manager_add_request(
4995     priv-&gt;request_manager,
4996     INFC_TYPE_REQUEST,
4997     "lookup-acl-accounts",
4998     G_CALLBACK(func),
4999     user_data,
5000     NULL
5001   );
5002   if(priv-&gt;account_list_status != INFC_BROWSER_ACCOUNT_LIST_NOTIFICATIONS)
5003     xml = infc_browser_request_to_xml(request);
5004   else
5005     xml = NULL;
5006   accounts = g_malloc(sizeof(InfAclAccount) * n_ids);
5007   n_accounts = 0;
5008   for(i = 0; i &lt; n_ids; ++i)
5009   {
5010     account = g_hash_table_lookup(
5011       priv-&gt;accounts,
5012       INF_ACL_ACCOUNT_ID_TO_POINTER(ids[i])
5013     );
5014     if(account != NULL)
5015     {
5016       accounts[i] = *account;
5017       ++n_accounts;
5018     }
5019     else
5020     {
5021       accounts[i].id = ids[i];
5022       accounts[i].name = NULL;
5023       if(xml != NULL)
5024       {
5025         xmlNewChild(
5026           xml,
5027           NULL,
5028           (const xmlChar*)"id",
5029           (const xmlChar*)inf_acl_account_id_to_string(ids[i])
5030         );
5031       }
5032     }
5033   }
5034   if(xml == NULL || n_accounts == n_ids)
5035   {
5036     if(xml != NULL) xmlFreeNode(xml);
5037     infc_request_manager_finish_request(
5038       priv-&gt;request_manager,
5039       request,
5040       inf_request_result_make_lookup_acl_accounts(
5041         INF_BROWSER(browser),
5042         accounts,
5043         n_ids
5044       )
5045     );
5046     request = NULL;
5047   }
5048   else
5049   {
5050     ids_req = g_malloc(sizeof(InfAclAccountId) * n_ids);
5051     for(i = 0; i &lt; n_ids; ++i)
5052       ids_req[i] = ids[i];
5053     g_object_set_qdata_full(
5054       G_OBJECT(request),
5055       infc_browser_lookup_acl_accounts_ids_quark,
5056       ids_req,
5057       g_free
5058     );
5059     g_object_set_qdata(
5060       G_OBJECT(request),
5061       infc_browser_lookup_acl_accounts_n_ids_quark,
5062       GUINT_TO_POINTER(n_ids)
5063     );
5064     inf_communication_group_send_message(
5065       INF_COMMUNICATION_GROUP(priv-&gt;group),
5066       priv-&gt;connection,
5067       xml
5068     );
5069   }
5070   g_free(accounts);
5071   return INF_REQUEST(request);
5072 }
5073 static InfRequest*
5074 infc_browser_browser_lookup_acl_account_by_name(InfBrowser* infbrowser,
5075                                                 const gchar* name,
5076                                                 InfRequestFunc func,
5077                                                 gpointer user_data)
5078 {
5079   InfcBrowser* browser;
5080   InfcBrowserPrivate* priv;
5081   InfcRequest* request;
5082   GArray* cached_accounts;
5083   InfcBrowserLookupAclAccountByByNameData lookup_data;
5084   InfAclAccount result_acc;
5085   xmlNodePtr xml;
5086   browser = INFC_BROWSER(infbrowser);
5087   priv = INFC_BROWSER_PRIVATE(browser);
5088   request = infc_request_manager_add_request(
5089     priv-&gt;request_manager,
5090     INFC_TYPE_REQUEST,
5091     "lookup-acl-accounts",
5092     G_CALLBACK(func),
5093     user_data,
5094     NULL
5095   );
5096   lookup_data.name = name;
5097   lookup_data.accounts = g_array_new(FALSE, FALSE, sizeof(InfAclAccount));
5098   g_hash_table_foreach(
5099     priv-&gt;accounts,
5100     infc_browser_browser_lookup_acl_account_by_name_find_func,
5101     &amp;lookup_data
5102   );
5103   if(lookup_data.accounts-&gt;len == 0)
5104   {
5105     if(priv-&gt;account_list_status == INFC_BROWSER_ACCOUNT_LIST_NOTIFICATIONS)
5106     {
5107       result_acc.id = 0;
5108       result_acc.name = (gchar*)name;
5109       infc_request_manager_finish_request(
5110         priv-&gt;request_manager,
5111         request,
5112         inf_request_result_make_lookup_acl_accounts(
5113           INF_BROWSER(browser),
5114           &amp;result_acc,
5115           1
5116         )
5117       );
5118       request = NULL;
5119     }
5120     else
5121     {
5122       xml = infc_browser_request_to_xml(request);
5123       xmlNewChild(xml, NULL, (const xmlChar*)"name", (const xmlChar*)name);
5124       g_object_set_qdata_full(
5125         G_OBJECT(request),
5126         infc_browser_lookup_acl_accounts_name_quark,
5127         g_strdup(name),
5128         g_free
5129       );
5130       inf_communication_group_send_message(
5131         INF_COMMUNICATION_GROUP(priv-&gt;group),
5132         priv-&gt;connection,
5133         xml
5134       );
5135     }
5136   }
5137   else
5138   {
5139     infc_request_manager_finish_request(
5140       priv-&gt;request_manager,
5141       request,
5142       inf_request_result_make_lookup_acl_accounts(
5143         INF_BROWSER(browser),
5144         (InfAclAccount*)lookup_data.accounts-&gt;data,
5145         lookup_data.accounts-&gt;len
5146       )
5147     );
5148     request = NULL;
5149   }
5150   g_array_free(lookup_data.accounts, TRUE);
5151   return INF_REQUEST(request);
5152 }
5153 static InfRequest*
5154 infc_browser_browser_create_acl_account(InfBrowser* browser,
5155                                         gnutls_x509_crq_t crq,
5156                                         InfRequestFunc func,
5157                                         gpointer user_data)
5158 {
5159   InfcBrowserPrivate* priv;
5160   InfcRequest* request;
5161   xmlNodePtr xml;
5162   xmlNodePtr crqNode;
5163   GError* error;
5164   gchar* crq_text;
5165   size_t size;
5166   int res;
5167   priv = INFC_BROWSER_PRIVATE(browser);
5168   request = infc_request_manager_add_request(
5169     priv-&gt;request_manager,
5170     INFC_TYPE_REQUEST,
5171     "create-acl-account",
5172     G_CALLBACK(func),
5173     user_data,
5174     NULL
5175   );
5176   inf_browser_begin_request(INF_BROWSER(browser), NULL, INF_REQUEST(request));
5177   size = 0;
5178   res = gnutls_x509_crq_export(crq, GNUTLS_X509_FMT_PEM, NULL, &amp;size);
5179   if(res != GNUTLS_E_SHORT_MEMORY_BUFFER)
5180   {
5181     error = NULL;
5182     inf_gnutls_set_error(&amp;error, res);
5183     infc_request_manager_fail_request(priv-&gt;request_manager, request, error);
5184     g_error_free(error);
5185     g_object_unref(request);
5186     return NULL;
5187   }
5188   crq_text = g_malloc(size);
5189   res = gnutls_x509_crq_export(crq, GNUTLS_X509_FMT_PEM, crq_text, &amp;size);
5190   if(res != GNUTLS_E_SUCCESS)
5191   {
5192     g_free(crq_text);
5193     error = NULL;
5194     inf_gnutls_set_error(&amp;error, res);
5195     infc_request_manager_fail_request(priv-&gt;request_manager, request, error);
5196     g_error_free(error);
5197     g_object_unref(request);
5198     return NULL;
5199   }
5200   xml = infc_browser_request_to_xml(request);
5201   crqNode = xmlNewChild(xml, NULL, (const xmlChar*)"crq", NULL);
5202   xmlNodeAddContentLen(crqNode, (const xmlChar*)crq_text, size);
5203   g_free(crq_text);
5204   inf_communication_group_send_message(
5205     INF_COMMUNICATION_GROUP(priv-&gt;group),
5206     priv-&gt;connection,
5207     xml
5208   );
5209   return INF_REQUEST(request);
5210 }
5211 static InfRequest*
5212 infc_browser_browser_remove_acl_account(InfBrowser* browser,
5213                                         InfAclAccountId account,
5214                                         InfRequestFunc func,
5215                                         gpointer user_data)
5216 {
5217   InfcBrowserPrivate* priv;
5218   InfcRequest* request;
5219   xmlNodePtr xml;
5220   priv = INFC_BROWSER_PRIVATE(browser);
5221   request = infc_request_manager_add_request(
5222     priv-&gt;request_manager,
5223     INFC_TYPE_REQUEST,
5224     "remove-acl-account",
5225     G_CALLBACK(func),
5226     user_data,
5227     NULL
5228   );
5229   inf_browser_begin_request(INF_BROWSER(browser), NULL, INF_REQUEST(request));
5230   xml = infc_browser_request_to_xml(request);
5231   inf_xml_util_set_attribute(
5232     xml,
5233     "id",
5234     inf_acl_account_id_to_string(account)
5235   );
5236   inf_communication_group_send_message(
5237     INF_COMMUNICATION_GROUP(priv-&gt;group),
5238     priv-&gt;connection,
5239     xml
5240   );
5241   return INF_REQUEST(request);
5242 }
5243 static InfRequest*
5244 infc_browser_browser_query_acl(InfBrowser* browser,
5245                                const InfBrowserIter* iter,
5246                                InfRequestFunc func,
5247                                gpointer user_data)
5248 {
5249   InfcBrowserPrivate* priv;
5250   InfcBrowserNode* node;
5251   InfcRequest* request;
5252   xmlNodePtr xml;
5253   g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
5254   infc_browser_return_val_if_iter_fail(INFC_BROWSER(browser), iter, NULL);
5255   node = (InfcBrowserNode*)iter-&gt;node;
5256   priv = INFC_BROWSER_PRIVATE(browser);
5257   g_return_val_if_fail(priv-&gt;connection != NULL, NULL);
5258   g_return_val_if_fail(priv-&gt;status == INF_BROWSER_OPEN, NULL);
5259   g_return_val_if_fail(node-&gt;acl_queried == FALSE, NULL);
5260   g_return_val_if_fail(
5261     inf_browser_get_pending_request(browser, iter, "query-acl") == NULL,
5262     NULL
5263   );
5264   request = infc_request_manager_add_request(
5265     priv-&gt;request_manager,
5266     INFC_TYPE_REQUEST,
5267     "query-acl",
5268     G_CALLBACK(func),
5269     user_data,
5270     "node-id", node-&gt;id,
5271     NULL
5272   );
5273   inf_browser_begin_request(browser, iter, INF_REQUEST(request));
5274   xml = infc_browser_request_to_xml(request);
5275   inf_xml_util_set_attribute_uint(xml, "id", node-&gt;id);
5276   inf_communication_group_send_message(
5277     INF_COMMUNICATION_GROUP(priv-&gt;group),
5278     priv-&gt;connection,
5279     xml
5280   );
5281   return INF_REQUEST(request);
5282 }
5283 static gboolean
5284 infc_browser_browser_has_acl(InfBrowser* browser,
5285                              const InfBrowserIter* iter,
5286                              InfAclAccountId account)
5287 {
5288   InfcBrowserPrivate* priv;
5289   InfcBrowserNode* node;
5290   InfAclAccountId default_id;
5291   g_return_val_if_fail(INFC_IS_BROWSER(browser), FALSE);
5292   infc_browser_return_val_if_iter_fail(INFC_BROWSER(browser), iter, FALSE);
5293   priv = INFC_BROWSER_PRIVATE(browser);
5294   node = (InfcBrowserNode*)iter-&gt;node;
5295   if(node-&gt;acl_queried == TRUE)
5296     return TRUE;
5297   if(account != 0)
5298   {
5299     if(account == priv-&gt;local_account-&gt;id)
5300       return TRUE;
5301     default_id = inf_acl_account_id_from_string("default");
5302     if(account == default_id)
5303       return TRUE;
5304   }
5305   return FALSE;
5306 }
5307 static const InfAclSheetSet*
5308 infc_browser_browser_get_acl(InfBrowser* browser,
5309                              const InfBrowserIter* iter)
5310 {
5311   InfcBrowserPrivate* priv;
5312   InfcBrowserNode* node;
5313   g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
5314   infc_browser_return_val_if_iter_fail(INFC_BROWSER(browser), iter, NULL);
5315   node = (InfcBrowserNode*)iter-&gt;node;
5316   return node-&gt;acl;
5317 }
5318 static InfRequest*
5319 infc_browser_browser_set_acl(InfBrowser* browser,
5320                              const InfBrowserIter* iter,
5321                              const InfAclSheetSet* sheet_set,
5322                              InfRequestFunc func,
5323                              gpointer user_data)
5324 {
5325   InfcBrowserPrivate* priv;
5326   InfcBrowserNode* node;
5327   InfcRequest* request;
5328   xmlNodePtr xml;
5329   g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
5330   infc_browser_return_val_if_iter_fail(INFC_BROWSER(browser), iter, NULL);
5331   node = (InfcBrowserNode*)iter-&gt;node;
5332   priv = INFC_BROWSER_PRIVATE(browser);
5333   g_return_val_if_fail(priv-&gt;connection != NULL, NULL);
5334   g_return_val_if_fail(priv-&gt;status == INF_BROWSER_OPEN, NULL);
5335   g_return_val_if_fail(node-&gt;acl_queried == TRUE, NULL);
5336   request = infc_request_manager_add_request(
5337     priv-&gt;request_manager,
5338     INFC_TYPE_REQUEST,
5339     "set-acl",
5340     G_CALLBACK(func),
5341     user_data,
5342     "node-id", node-&gt;id,
5343     NULL
5344   );
5345   inf_browser_begin_request(browser, iter, INF_REQUEST(request));
5346   xml = infc_browser_request_to_xml(request);
5347   inf_xml_util_set_attribute_uint(xml, "id", node-&gt;id);
5348   inf_acl_sheet_set_to_xml(sheet_set, xml);
5349   inf_communication_group_send_message(
5350     INF_COMMUNICATION_GROUP(priv-&gt;group),
5351     priv-&gt;connection,
5352     xml
5353   );
5354   return INF_REQUEST(request);
5355 }
5356 static void
5357 infc_browser_class_init(InfcBrowserClass* browser_class)
5358 {
5359   GObjectClass* object_class;
5360   object_class = G_OBJECT_CLASS(browser_class);
5361   object_class-&gt;dispose = infc_browser_dispose;
5362   object_class-&gt;finalize = infc_browser_finalize;
5363   object_class-&gt;set_property = infc_browser_set_property;
5364   object_class-&gt;get_property = infc_browser_get_property;
5365   infc_browser_session_proxy_quark = g_quark_from_static_string(
5366     "infc-browser-session-proxy-quark"
5367   );
5368   infc_browser_sync_in_session_quark = g_quark_from_static_string(
5369     "infc-browser-sync-in-session-quark"
5370   );
5371   infc_browser_sync_in_plugin_quark = g_quark_from_static_string(
5372     "infc-browser-sync-in-plugin-quark"
5373   );
5374   infc_browser_lookup_acl_accounts_ids_quark = g_quark_from_static_string(
5375     "infc-browser-lookup-acl-accounts-ids-quark"
5376   );
5377   infc_browser_lookup_acl_accounts_n_ids_quark = g_quark_from_static_string(
5378     "infc-browser-lookup-acl-accounts-n-ids-quark"
5379   );
5380   infc_browser_lookup_acl_accounts_name_quark = g_quark_from_static_string(
5381     "infc-browser-lookup-acl-accounts-name-quark"
5382   );
5383   infc_browser_query_acl_account_list_accounts_quark =
5384     g_quark_from_static_string(
5385       "infc-browser-query-acl-account-list-accounts-quark"
5386     );
5387   g_object_class_install_property(
5388     object_class,
5389     PROP_IO,
5390     g_param_spec_object(
5391       "io",
5392       "IO",
5393       "The InfIo to schedule timeouts",
5394       INF_TYPE_IO,
5395       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
5396     )
5397   );
5398   g_object_class_install_property(
5399     object_class,
5400     PROP_COMMUNICATION_MANAGER,
5401     g_param_spec_object(
5402       "communication-manager",
5403       "Communication manager",
5404       "The communication manager for the browser",
5405       INF_COMMUNICATION_TYPE_MANAGER,
5406       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
5407     )
5408   );
5409   g_object_class_install_property(
5410     object_class,
5411     PROP_CONNECTION,
5412     g_param_spec_object(
5413       "connection",
5414       "Server connection",
5415       "Connection to the server exposing the directory to browse",
5416       INF_TYPE_XML_CONNECTION,
5417       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
5418     )
5419   );
5420   g_object_class_install_property(
5421     object_class,
5422     PROP_CHAT_SESSION,
5423     g_param_spec_object(
5424       "chat-session",
5425       "Chat session",
5426       "Active chat session",
5427       INFC_TYPE_SESSION_PROXY,
5428       G_PARAM_READABLE
5429     )
5430   );
5431   g_object_class_override_property(object_class, PROP_STATUS, "status");
5432 }
5433 static void
5434 infc_browser_communication_object_iface_init(
5435   InfCommunicationObjectInterface* iface)
5436 {
5437   iface-&gt;received = infc_browser_communication_object_received;
5438   iface-&gt;sent = infc_browser_communication_object_sent;
5439 }
5440 static void
5441 infc_browser_browser_iface_init(InfBrowserInterface* iface)
5442 {
5443   iface-&gt;error = NULL;
5444   iface-&gt;node_added = NULL;
5445   iface-&gt;node_removed = NULL;
5446   iface-&gt;subscribe_session = infc_browser_browser_subscribe_session;
5447   iface-&gt;unsubscribe_session = NULL;
5448   iface-&gt;begin_request = NULL;
5449   iface-&gt;acl_account_added = NULL;
5450   iface-&gt;acl_account_removed = NULL;
5451   iface-&gt;acl_local_account_changed = NULL;
5452   iface-&gt;acl_changed = NULL;
5453   iface-&gt;get_root = infc_browser_browser_get_root;
5454   iface-&gt;get_next = infc_browser_browser_get_next;
5455   iface-&gt;get_prev = infc_browser_browser_get_prev;
5456   iface-&gt;get_parent = infc_browser_browser_get_parent;
5457   iface-&gt;get_child = infc_browser_browser_get_child;
5458   iface-&gt;explore = infc_browser_browser_explore;
5459   iface-&gt;get_explored = infc_browser_browser_get_explored;
5460   iface-&gt;is_subdirectory = infc_browser_browser_is_subdirectory;
5461   iface-&gt;add_note = infc_browser_browser_add_note;
5462   iface-&gt;add_subdirectory = infc_browser_browser_add_subdirectory;
5463   iface-&gt;remove_node = infc_browser_browser_remove_node;
5464   iface-&gt;get_node_name = infc_browser_browser_get_node_name;
5465   iface-&gt;get_node_type = infc_browser_browser_get_node_type;
5466   iface-&gt;subscribe = infc_browser_browser_subscribe;
5467   iface-&gt;get_session = infc_browser_browser_get_session;
5468   iface-&gt;list_pending_requests = infc_browser_browser_list_pending_requests;
5469   iface-&gt;iter_from_request = infc_browser_browser_iter_from_request;
5470   iface-&gt;get_acl_default_account = infc_browser_browser_get_acl_default_account;
5471   iface-&gt;get_acl_local_account = infc_browser_browser_get_acl_local_account;
5472   iface-&gt;query_acl_account_list = infc_browser_browser_query_acl_account_list;
5473   iface-&gt;lookup_acl_accounts = infc_browser_browser_lookup_acl_accounts;
5474   iface-&gt;lookup_acl_account_by_name =
5475     infc_browser_browser_lookup_acl_account_by_name;
5476   iface-&gt;create_acl_account = infc_browser_browser_create_acl_account;
5477   iface-&gt;remove_acl_account = infc_browser_browser_remove_acl_account;
5478   iface-&gt;query_acl = infc_browser_browser_query_acl;
5479   iface-&gt;has_acl = infc_browser_browser_has_acl;
5480   iface-&gt;get_acl = infc_browser_browser_get_acl;
5481   iface-&gt;set_acl = infc_browser_browser_set_acl;
5482 }
5483 InfcBrowser*
5484 infc_browser_new(InfIo* io,
5485                  InfCommunicationManager* comm_manager,
5486                  InfXmlConnection* connection)
5487 {
5488   GObject* object;
5489   g_return_val_if_fail(INF_IS_IO(io), NULL);
5490   g_return_val_if_fail(INF_COMMUNICATION_IS_MANAGER(comm_manager), NULL);
5491   g_return_val_if_fail(INF_IS_XML_CONNECTION(connection), NULL);
5492   object = g_object_new(
5493     INFC_TYPE_BROWSER,
5494     "io", io,
5495     "communication-manager", comm_manager,
5496     "connection", connection,
5497     NULL
5498   );
5499   return INFC_BROWSER(object);
5500 }
5501 InfCommunicationManager*
5502 infc_browser_get_communication_manager(InfcBrowser* browser)
5503 {
5504   g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
5505   return INFC_BROWSER_PRIVATE(browser)-&gt;communication_manager;
5506 }
5507 InfXmlConnection*
5508 infc_browser_get_connection(InfcBrowser* browser)
5509 {
5510   g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
5511   return INFC_BROWSER_PRIVATE(browser)-&gt;connection;
5512 }
5513 gboolean
5514 infc_browser_add_plugin(InfcBrowser* browser,
5515                         const InfcNotePlugin* plugin)
5516 {
5517   InfcBrowserPrivate* priv;
5518   g_return_val_if_fail(INFC_IS_BROWSER(browser), FALSE);
5519   g_return_val_if_fail(plugin != NULL, FALSE);
5520   priv = INFC_BROWSER_PRIVATE(browser);
5521   if(g_hash_table_lookup(priv-&gt;plugins, plugin-&gt;note_type) != NULL)
5522     return FALSE;
5523   g_hash_table_insert(
5524     priv-&gt;plugins,
5525     *(const gpointer*)(gconstpointer)&amp;plugin-&gt;note_type,
5526     *(gpointer*)(gpointer)&amp;plugin
5527   );
5528   return TRUE;
5529 }
5530 const InfcNotePlugin*
5531 infc_browser_lookup_plugin(InfcBrowser* browser,
5532                            const gchar* note_type)
5533 {
5534   InfcBrowserPrivate* priv;
5535   g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
5536   g_return_val_if_fail(note_type != NULL, NULL);
5537   priv = INFC_BROWSER_PRIVATE(browser);
5538   return (const InfcNotePlugin*)g_hash_table_lookup(priv-&gt;plugins, note_type);
5539 }
5540 InfRequest*
5541 infc_browser_iter_save_session(InfcBrowser* browser,
5542                                const InfBrowserIter* iter,
5543                                InfRequestFunc func,
5544                                gpointer user_data)
5545 {
5546   InfcBrowserPrivate* priv;
5547   InfcBrowserNode* node;
5548   InfcRequest* request;
5549   xmlNodePtr xml;
5550   g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
5551   infc_browser_return_val_if_iter_fail(browser, iter, NULL);
5552   priv = INFC_BROWSER_PRIVATE(browser);
5553   node = (InfcBrowserNode*)iter-&gt;node;
5554   g_return_val_if_fail(priv-&gt;connection != NULL, NULL);
5555   g_return_val_if_fail(node-&gt;type == INFC_BROWSER_NODE_NOTE_KNOWN, NULL);
5556   request = infc_request_manager_add_request(
5557     priv-&gt;request_manager,
5558     INFC_TYPE_REQUEST,
5559     "save-session",
5560     G_CALLBACK(func),
5561     user_data,
5562     "node-id", iter-&gt;node_id,
5563     NULL
5564   );
5565   inf_browser_begin_request(INF_BROWSER(browser), iter, INF_REQUEST(request));
5566   xml = infc_browser_request_to_xml(request);
5567   inf_xml_util_set_attribute_uint(xml, "id", node-&gt;id);
5568   inf_communication_group_send_message(
5569     INF_COMMUNICATION_GROUP(priv-&gt;group),
5570     priv-&gt;connection,
5571     xml
5572   );
5573   return INF_REQUEST(request);
5574 }
5575 InfcSessionProxy*
5576 infc_browser_iter_get_sync_in(InfcBrowser* browser,
5577                               const InfBrowserIter* iter)
5578 {
5579   InfcBrowserPrivate* priv;
5580   GSList* item;
5581   InfcBrowserSyncIn* sync_in;
5582   g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
5583   infc_browser_return_val_if_iter_fail(browser, iter, NULL);
5584   priv = INFC_BROWSER_PRIVATE(browser);
5585   for(item = priv-&gt;sync_ins; item != NULL; item = item-&gt;next)
5586   {
5587     sync_in = (InfcBrowserSyncIn*)item-&gt;data;
5588     if(sync_in-&gt;node == iter-&gt;node)
5589       return sync_in-&gt;proxy;
5590   }
5591   return NULL;
5592 }
5593 GSList*
5594 infc_browser_iter_get_sync_in_requests(InfcBrowser* browser,
5595                                        const InfBrowserIter* iter)
5596 {
5597   InfcBrowserPrivate* priv;
5598   InfcBrowserNode* node;
5599   InfcBrowserIterGetSyncInRequestsForeachData data;
5600   data.iter = iter;
5601   data.result = NULL;
5602   g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
5603   infc_browser_return_val_if_iter_fail(browser, iter, NULL);
5604   node = (InfcBrowserNode*)iter-&gt;node;
5605   infc_browser_return_val_if_subdir_fail(node, NULL);
5606   priv = INFC_BROWSER_PRIVATE(browser);
5607   if(priv-&gt;request_manager != NULL)
5608   {
5609     infc_request_manager_foreach_named_request(
5610       priv-&gt;request_manager,
5611       "add-node",
5612       infc_browser_iter_get_sync_in_requests_foreach_func,
5613       &amp;data
5614     );
5615   }
5616   return data.result;
5617 }
5618 gboolean
5619 infc_browser_iter_is_valid(InfcBrowser* browser,
5620                            const InfBrowserIter* iter)
5621 {
5622   InfcBrowserPrivate* priv;
5623   gpointer node;
5624   g_return_val_if_fail(INFC_IS_BROWSER(browser), FALSE);
5625   if(!iter) return FALSE;
5626   priv = INFC_BROWSER_PRIVATE(browser);
5627   node = g_hash_table_lookup(priv-&gt;nodes, GUINT_TO_POINTER(iter-&gt;node_id));
5628   return node != NULL &amp;&amp; node == iter-&gt;node;
5629 }
5630 InfRequest*
5631 infc_browser_subscribe_chat(InfcBrowser* browser,
5632                             InfRequestFunc func,
5633                             gpointer user_data)
5634 {
5635   InfcBrowserPrivate* priv;
5636   InfcRequest* request;
5637   xmlNodePtr xml;
5638   g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
5639   g_return_val_if_fail(infc_browser_get_chat_session(browser) == NULL, NULL);
5640   g_return_val_if_fail(
5641     infc_browser_get_subscribe_chat_request(browser) == NULL,
5642     NULL
5643   );
5644   priv = INFC_BROWSER_PRIVATE(browser);
5645   request = infc_request_manager_add_request(
5646     priv-&gt;request_manager,
5647     INFC_TYPE_REQUEST,
5648     "subscribe-chat",
5649     G_CALLBACK(func),
5650     user_data,
5651     NULL
5652   );
5653   inf_browser_begin_request(INF_BROWSER(browser), NULL, INF_REQUEST(request));
5654   xml = infc_browser_request_to_xml(request);
5655   inf_communication_group_send_message(
5656     INF_COMMUNICATION_GROUP(priv-&gt;group),
5657     priv-&gt;connection,
5658     xml
5659   );
5660   return INF_REQUEST(request);
5661 }
5662 InfRequest*
5663 infc_browser_get_subscribe_chat_request(InfcBrowser* browser)
5664 {
5665   InfcBrowserPrivate* priv;
5666   InfcBrowserIterGetChatRequestForeachData data;
5667   data.result = NULL;
5668   g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
5669   priv = INFC_BROWSER_PRIVATE(browser);
5670   if(priv-&gt;request_manager != NULL)
5671   {
5672     infc_request_manager_foreach_named_request(
5673       priv-&gt;request_manager,
5674       "subscribe-chat",
5675       infc_browser_get_chat_request_foreach_func,
5676       &amp;data
5677     );
5678   }
5679   return INF_REQUEST(data.result);
5680 }
5681 InfcSessionProxy*
5682 infc_browser_get_chat_session(InfcBrowser* browser)
5683 {
5684   g_return_val_if_fail(INFC_IS_BROWSER(browser), NULL);
5685   return INFC_BROWSER_PRIVATE(browser)-&gt;chat_session;
5686 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
