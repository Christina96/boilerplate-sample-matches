
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-threadsignaltest.c</h3>
            <pre><code>1  #include "varattrs.h"
2  #ifndef lint
3  static const char copyright[] _U_ =
4      "@(#) Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000\n\
5  The Regents of the University of California.  All rights reserved.\n";
6  #endif
7  #include <stdio.h>
8  #include <stdlib.h>
9  #include <string.h>
10  #include <stdarg.h>
11  #include <limits.h>
12  #ifdef _WIN32
13    #include <winsock2.h>
14    #include <windows.h>
15    #define THREAD_HANDLE			HANDLE
16    #define THREAD_FUNC_ARG_TYPE		LPVOID
17    #define THREAD_FUNC_RETURN_TYPE	DWORD __stdcall
18    #include "getopt.h"
19  #else
20    #include <pthread.h>
21    #include <signal.h>
22    #include <unistd.h>
23    #define THREAD_HANDLE			pthread_t
24    #define THREAD_FUNC_ARG_TYPE		void *
25    #define THREAD_FUNC_RETURN_TYPE	void *
26  #endif
27  #include <errno.h>
28  #include <sys/types.h>
29  #include <pcap.h>
30  #include "pcap/funcattrs.h"
31  #ifdef _WIN32
32    #include "portability.h"
33  #endif
34  static char *program_name;
35  static void countme(u_char *, const struct pcap_pkthdr *, const u_char *);
36  static void PCAP_NORETURN usage(void);
37  static void PCAP_NORETURN error(const char *, ...) PCAP_PRINTFLIKE(1, 2);
38  static void warning(const char *, ...) PCAP_PRINTFLIKE(1, 2);
39  static char *copy_argv(char **);
40  static pcap_t *pd;
41  #ifdef _WIN32
42  #define ERRBUF_SIZE	1024
43  static const char *
44  win32_strerror(DWORD error)
45  {
46    static char errbuf[ERRBUF_SIZE+1];
47    size_t errlen;
48    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, error, 0, errbuf,
49                  ERRBUF_SIZE, NULL);
50    errlen = strlen(errbuf);
51    if (errlen >= 2) {
52      errbuf[errlen - 1] = '\0';
53      errbuf[errlen - 2] = '\0';
54      errlen -= 2;
55    }
56    return errbuf;
57  }
58  #else
59  static void
60  catch_sigusr1(int sig _U_)
61  {
62  	printf("Got SIGUSR1\n");
63  }
64  #endif
65  static void
66  sleep_secs(int secs)
67  {
68  #ifdef _WIN32
69  	Sleep(secs*1000);
70  #else
71  	unsigned secs_remaining;
72  	if (secs <= 0)
73  		return;
74  	secs_remaining = secs;
75  	while (secs_remaining != 0)
76  		secs_remaining = sleep(secs_remaining);
77  #endif
78  }
79  static THREAD_FUNC_RETURN_TYPE
80  capture_thread_func(THREAD_FUNC_ARG_TYPE arg)
81  {
82  	char *device = arg;
83  	int packet_count;
84  	int status;
85  #ifndef _WIN32
86  	struct sigaction action;
87  	sigset_t mask;
88  #endif
89  #ifndef _WIN32
90  	sigemptyset(&mask);
91  	action.sa_handler = catch_sigusr1;
92  	action.sa_mask = mask;
93  	action.sa_flags = 0;
94  	if (sigaction(SIGUSR1, &action, NULL) == -1)
95  		error("Can't catch SIGUSR1: %s", strerror(errno));
96  #endif
97  	printf("Listening on %s\n", device);
98  	for (;;) {
99  		packet_count = 0;
100  		status = pcap_dispatch(pd, -1, countme,
101  		    (u_char *)&packet_count);
102  		if (status < 0)
103  			break;
104  		if (status != 0) {
105  			printf("%d packets seen, %d packets counted after pcap_dispatch returns\n",
106  			    status, packet_count);
107  		} else
108  			printf("No packets seen by pcap_dispatch\n");
109  	}
110  	if (status == PCAP_ERROR_BREAK) {
111  		putchar('\n');
112  		printf("Loop got broken\n");
113  	}
114  	(void)fflush(stdout);
115  	if (status == PCAP_ERROR) {
116  		(void)fprintf(stderr, "%s: pcap_dispatch: %s\n",
117  		    program_name, pcap_geterr(pd));
118  	}
119  	return 0;
120  }
121  int
122  main(int argc, char **argv)
123  {
124  	register int op;
125  	register char *cp, *cmdbuf, *device;
126  	int do_wakeup = 1;
127  	pcap_if_t *devlist;
128  	bpf_u_int32 localnet, netmask;
129  	struct bpf_program fcode;
130  	char ebuf[PCAP_ERRBUF_SIZE];
131  	int status;
132  	THREAD_HANDLE capture_thread;
133  #ifndef _WIN32
134  	void *retval;
135  #endif
136  	device = NULL;
137  	if ((cp = strrchr(argv[0], '/')) != NULL)
138  		program_name = cp + 1;
139  	else
140  		program_name = argv[0];
141  	opterr = 0;
142  	while ((op = getopt(argc, argv, "i:n")) != -1) {
143  		switch (op) {
144  		case 'i':
145  			device = optarg;
146  			break;
147  		case 'n':
148  			do_wakeup = 0;
149  			break;
150  		default:
151  			usage();
152  		}
153  	}
154  	if (device == NULL) {
155  		if (pcap_findalldevs(&devlist, ebuf) == -1)
156  			error("%s", ebuf);
157  		if (devlist == NULL)
158  			error("no interfaces available for capture");
159  		device = strdup(devlist->name);
160  		pcap_freealldevs(devlist);
161  	}
162  	*ebuf = '\0';
163  	pd = pcap_create(device, ebuf);
164  	if (pd == NULL)
165  		error("%s", ebuf);
166  	status = pcap_set_snaplen(pd, 65535);
167  	if (status != 0)
168  		error("%s: pcap_set_snaplen failed: %s",
169  			    device, pcap_statustostr(status));
170  	status = pcap_set_timeout(pd, 5*60*1000);
171  	if (status != 0)
172  		error("%s: pcap_set_timeout failed: %s",
173  		    device, pcap_statustostr(status));
174  	status = pcap_activate(pd);
175  	if (status < 0) {
176  		error("%s: %s\n(%s)", device,
177  		    pcap_statustostr(status), pcap_geterr(pd));
178  	} else if (status > 0) {
179  		warning("%s: %s\n(%s)", device,
180  		    pcap_statustostr(status), pcap_geterr(pd));
181  	}
182  	if (pcap_lookupnet(device, &localnet, &netmask, ebuf) < 0) {
<span onclick='openModal()' class='match'>183  		localnet = 0;
184  		netmask = 0;
185  		warning("%s", ebuf);
186  	}
187  	cmdbuf = copy_argv(&argv[optind]);
</span>188  	if (pcap_compile(pd, &fcode, cmdbuf, 1, netmask) < 0)
189  		error("%s", pcap_geterr(pd));
190  	if (pcap_setfilter(pd, &fcode) < 0)
191  		error("%s", pcap_geterr(pd));
192  #ifdef _WIN32
193  	capture_thread = CreateThread(NULL, 0, capture_thread_func, device,
194  	    0, NULL);
195  	if (capture_thread == NULL)
196  		error("Can't create capture thread: %s",
197  		    win32_strerror(GetLastError()));
198  #else
199  	status = pthread_create(&capture_thread, NULL, capture_thread_func,
200  	    device);
201  	if (status != 0)
202  		error("Can't create capture thread: %s", strerror(status));
203  #endif
204  	sleep_secs(60);
205  	printf("Doing pcap_breakloop()\n");
206  	pcap_breakloop(pd);
207  	if (do_wakeup) {
208  #ifdef _WIN32
209  		printf("Setting event\n");
210  		if (!SetEvent(pcap_getevent(pd)))
211  			error("Can't set event for pcap_t: %s",
212  			    win32_strerror(GetLastError()));
213  #else
214  		printf("Sending SIGUSR1\n");
215  		status = pthread_kill(capture_thread, SIGUSR1);
216  		if (status != 0)
217  			warning("Can't interrupt capture thread: %s",
218  			strerror(status));
219  #endif
220  	}
221  #ifdef _WIN32
222  	if (WaitForSingleObject(capture_thread, INFINITE) == WAIT_FAILED)
223  		error("Wait for thread termination failed: %s",
224  		    win32_strerror(GetLastError()));
225  	CloseHandle(capture_thread);
226  #else
227  	status = pthread_join(capture_thread, &retval);
228  	if (status != 0)
229  		error("Wait for thread termination failed: %s",
230  		    strerror(status));
231  #endif
232  	pcap_close(pd);
233  	pcap_freecode(&fcode);
234  	exit(status == -1 ? 1 : 0);
235  }
236  static void
237  countme(u_char *user, const struct pcap_pkthdr *h _U_, const u_char *sp _U_)
238  {
239  	int *counterp = (int *)user;
240  	(*counterp)++;
241  }
242  static void
243  usage(void)
244  {
245  	(void)fprintf(stderr, "Usage: %s [ -n ] [ -i interface ] [ expression ]\n",
246  	    program_name);
247  	exit(1);
248  }
249  static void
250  error(const char *fmt, ...)
251  {
252  	va_list ap;
253  	(void)fprintf(stderr, "%s: ", program_name);
254  	va_start(ap, fmt);
255  	(void)vfprintf(stderr, fmt, ap);
256  	va_end(ap);
257  	if (*fmt) {
258  		fmt += strlen(fmt);
259  		if (fmt[-1] != '\n')
260  			(void)fputc('\n', stderr);
261  	}
262  	exit(1);
263  }
264  static void
265  warning(const char *fmt, ...)
266  {
267  	va_list ap;
268  	(void)fprintf(stderr, "%s: WARNING: ", program_name);
269  	va_start(ap, fmt);
270  	(void)vfprintf(stderr, fmt, ap);
271  	va_end(ap);
272  	if (*fmt) {
273  		fmt += strlen(fmt);
274  		if (fmt[-1] != '\n')
275  			(void)fputc('\n', stderr);
276  	}
277  }
278  static char *
279  copy_argv(register char **argv)
280  {
281  	register char **p;
282  	register size_t len = 0;
283  	char *buf;
284  	char *src, *dst;
285  	p = argv;
286  	if (*p == 0)
287  		return 0;
288  	while (*p)
289  		len += strlen(*p++) + 1;
290  	buf = (char *)malloc(len);
291  	if (buf == NULL)
292  		error("copy_argv: malloc");
293  	p = argv;
294  	dst = buf;
295  	while ((src = *p++) != NULL) {
296  		while ((*dst++ = *src++) != '\0')
297  			;
298  		dst[-1] = ' ';
299  	}
300  	dst[-1] = '\0';
301  	return buf;
302  }
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-threadsignaltest.c</h3>
            <pre><code>1  #include "varattrs.h"
2  #ifndef lint
3  static const char copyright[] _U_ =
4      "@(#) Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000\n\
5  The Regents of the University of California.  All rights reserved.\n";
6  #endif
7  #include <stdio.h>
8  #include <stdlib.h>
9  #include <string.h>
10  #include <stdarg.h>
11  #include <limits.h>
12  #ifdef _WIN32
13    #include <winsock2.h>
14    #include <windows.h>
15    #define THREAD_HANDLE			HANDLE
16    #define THREAD_FUNC_ARG_TYPE		LPVOID
17    #define THREAD_FUNC_RETURN_TYPE	DWORD __stdcall
18    #include "getopt.h"
19  #else
20    #include <pthread.h>
21    #include <signal.h>
22    #include <unistd.h>
23    #define THREAD_HANDLE			pthread_t
24    #define THREAD_FUNC_ARG_TYPE		void *
25    #define THREAD_FUNC_RETURN_TYPE	void *
26  #endif
27  #include <errno.h>
28  #include <sys/types.h>
29  #include <pcap.h>
30  #include "pcap/funcattrs.h"
31  #ifdef _WIN32
32    #include "portability.h"
33  #endif
34  static char *program_name;
35  static void countme(u_char *, const struct pcap_pkthdr *, const u_char *);
36  static void PCAP_NORETURN usage(void);
37  static void PCAP_NORETURN error(const char *, ...) PCAP_PRINTFLIKE(1, 2);
38  static void warning(const char *, ...) PCAP_PRINTFLIKE(1, 2);
39  static char *copy_argv(char **);
40  static pcap_t *pd;
41  #ifdef _WIN32
42  #define ERRBUF_SIZE	1024
43  static const char *
44  win32_strerror(DWORD error)
45  {
46    static char errbuf[ERRBUF_SIZE+1];
47    size_t errlen;
48    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, error, 0, errbuf,
49                  ERRBUF_SIZE, NULL);
50    errlen = strlen(errbuf);
51    if (errlen >= 2) {
52      errbuf[errlen - 1] = '\0';
53      errbuf[errlen - 2] = '\0';
54      errlen -= 2;
55    }
56    return errbuf;
57  }
58  #else
59  static void
60  catch_sigusr1(int sig _U_)
61  {
62  	printf("Got SIGUSR1\n");
63  }
64  #endif
65  static void
66  sleep_secs(int secs)
67  {
68  #ifdef _WIN32
69  	Sleep(secs*1000);
70  #else
71  	unsigned secs_remaining;
72  	if (secs <= 0)
73  		return;
74  	secs_remaining = secs;
75  	while (secs_remaining != 0)
76  		secs_remaining = sleep(secs_remaining);
77  #endif
78  }
79  static THREAD_FUNC_RETURN_TYPE
80  capture_thread_func(THREAD_FUNC_ARG_TYPE arg)
81  {
82  	char *device = arg;
83  	int packet_count;
84  	int status;
85  #ifndef _WIN32
86  	struct sigaction action;
87  	sigset_t mask;
88  #endif
89  #ifndef _WIN32
90  	sigemptyset(&mask);
91  	action.sa_handler = catch_sigusr1;
92  	action.sa_mask = mask;
93  	action.sa_flags = 0;
94  	if (sigaction(SIGUSR1, &action, NULL) == -1)
95  		error("Can't catch SIGUSR1: %s", strerror(errno));
96  #endif
97  	printf("Listening on %s\n", device);
98  	for (;;) {
99  		packet_count = 0;
100  		status = pcap_dispatch(pd, -1, countme,
101  		    (u_char *)&packet_count);
102  		if (status < 0)
103  			break;
104  		if (status != 0) {
105  			printf("%d packets seen, %d packets counted after pcap_dispatch returns\n",
106  			    status, packet_count);
107  		} else
108  			printf("No packets seen by pcap_dispatch\n");
109  	}
110  	if (status == PCAP_ERROR_BREAK) {
111  		putchar('\n');
112  		printf("Loop got broken\n");
113  	}
114  	(void)fflush(stdout);
115  	if (status == PCAP_ERROR) {
116  		(void)fprintf(stderr, "%s: pcap_dispatch: %s\n",
117  		    program_name, pcap_geterr(pd));
118  	}
119  	return 0;
120  }
121  int
122  main(int argc, char **argv)
123  {
124  	register int op;
125  	register char *cp, *cmdbuf, *device;
126  	int do_wakeup = 1;
127  	pcap_if_t *devlist;
128  	bpf_u_int32 localnet, netmask;
129  	struct bpf_program fcode;
130  	char ebuf[PCAP_ERRBUF_SIZE];
131  	int status;
132  	THREAD_HANDLE capture_thread;
133  #ifndef _WIN32
134  	void *retval;
135  #endif
136  	device = NULL;
137  	if ((cp = strrchr(argv[0], '/')) != NULL)
138  		program_name = cp + 1;
139  	else
140  		program_name = argv[0];
141  	opterr = 0;
142  	while ((op = getopt(argc, argv, "i:n")) != -1) {
143  		switch (op) {
144  		case 'i':
145  			device = optarg;
146  			break;
147  		case 'n':
148  			do_wakeup = 0;
149  			break;
150  		default:
151  			usage();
152  		}
153  	}
154  	if (device == NULL) {
155  		if (pcap_findalldevs(&devlist, ebuf) == -1)
156  			error("%s", ebuf);
157  		if (devlist == NULL)
158  			error("no interfaces available for capture");
159  		device = strdup(devlist->name);
160  		pcap_freealldevs(devlist);
161  	}
162  	*ebuf = '\0';
163  	pd = pcap_create(device, ebuf);
164  	if (pd == NULL)
165  		error("%s", ebuf);
166  	status = pcap_set_snaplen(pd, 65535);
167  	if (status != 0)
168  		error("%s: pcap_set_snaplen failed: %s",
169  			    device, pcap_statustostr(status));
170  	status = pcap_set_timeout(pd, 5*60*1000);
171  	if (status != 0)
172  		error("%s: pcap_set_timeout failed: %s",
173  		    device, pcap_statustostr(status));
174  	status = pcap_activate(pd);
175  	if (status < 0) {
176  		error("%s: %s\n(%s)", device,
177  		    pcap_statustostr(status), pcap_geterr(pd));
178  	} else if (status > 0) {
179  		warning("%s: %s\n(%s)", device,
180  		    pcap_statustostr(status), pcap_geterr(pd));
181  	}
182  	if (pcap_lookupnet(device, &localnet, &netmask, ebuf) < 0) {
<span onclick='openModal()' class='match'>183  		localnet = 0;
184  		netmask = 0;
185  		warning("%s", ebuf);
186  	}
187  	cmdbuf = copy_argv(&argv[optind]);
</span>188  	if (pcap_compile(pd, &fcode, cmdbuf, 1, netmask) < 0)
189  		error("%s", pcap_geterr(pd));
190  	if (pcap_setfilter(pd, &fcode) < 0)
191  		error("%s", pcap_geterr(pd));
192  #ifdef _WIN32
193  	capture_thread = CreateThread(NULL, 0, capture_thread_func, device,
194  	    0, NULL);
195  	if (capture_thread == NULL)
196  		error("Can't create capture thread: %s",
197  		    win32_strerror(GetLastError()));
198  #else
199  	status = pthread_create(&capture_thread, NULL, capture_thread_func,
200  	    device);
201  	if (status != 0)
202  		error("Can't create capture thread: %s", strerror(status));
203  #endif
204  	sleep_secs(60);
205  	printf("Doing pcap_breakloop()\n");
206  	pcap_breakloop(pd);
207  	if (do_wakeup) {
208  #ifdef _WIN32
209  		printf("Setting event\n");
210  		if (!SetEvent(pcap_getevent(pd)))
211  			error("Can't set event for pcap_t: %s",
212  			    win32_strerror(GetLastError()));
213  #else
214  		printf("Sending SIGUSR1\n");
215  		status = pthread_kill(capture_thread, SIGUSR1);
216  		if (status != 0)
217  			warning("Can't interrupt capture thread: %s",
218  			strerror(status));
219  #endif
220  	}
221  #ifdef _WIN32
222  	if (WaitForSingleObject(capture_thread, INFINITE) == WAIT_FAILED)
223  		error("Wait for thread termination failed: %s",
224  		    win32_strerror(GetLastError()));
225  	CloseHandle(capture_thread);
226  #else
227  	status = pthread_join(capture_thread, &retval);
228  	if (status != 0)
229  		error("Wait for thread termination failed: %s",
230  		    strerror(status));
231  #endif
232  	pcap_close(pd);
233  	pcap_freecode(&fcode);
234  	exit(status == -1 ? 1 : 0);
235  }
236  static void
237  countme(u_char *user, const struct pcap_pkthdr *h _U_, const u_char *sp _U_)
238  {
239  	int *counterp = (int *)user;
240  	(*counterp)++;
241  }
242  static void
243  usage(void)
244  {
245  	(void)fprintf(stderr, "Usage: %s [ -n ] [ -i interface ] [ expression ]\n",
246  	    program_name);
247  	exit(1);
248  }
249  static void
250  error(const char *fmt, ...)
251  {
252  	va_list ap;
253  	(void)fprintf(stderr, "%s: ", program_name);
254  	va_start(ap, fmt);
255  	(void)vfprintf(stderr, fmt, ap);
256  	va_end(ap);
257  	if (*fmt) {
258  		fmt += strlen(fmt);
259  		if (fmt[-1] != '\n')
260  			(void)fputc('\n', stderr);
261  	}
262  	exit(1);
263  }
264  static void
265  warning(const char *fmt, ...)
266  {
267  	va_list ap;
268  	(void)fprintf(stderr, "%s: WARNING: ", program_name);
269  	va_start(ap, fmt);
270  	(void)vfprintf(stderr, fmt, ap);
271  	va_end(ap);
272  	if (*fmt) {
273  		fmt += strlen(fmt);
274  		if (fmt[-1] != '\n')
275  			(void)fputc('\n', stderr);
276  	}
277  }
278  static char *
279  copy_argv(register char **argv)
280  {
281  	register char **p;
282  	register size_t len = 0;
283  	char *buf;
284  	char *src, *dst;
285  	p = argv;
286  	if (*p == 0)
287  		return 0;
288  	while (*p)
289  		len += strlen(*p++) + 1;
290  	buf = (char *)malloc(len);
291  	if (buf == NULL)
292  		error("copy_argv: malloc");
293  	p = argv;
294  	dst = buf;
295  	while ((src = *p++) != NULL) {
296  		while ((*dst++ = *src++) != '\0')
297  			;
298  		dst[-1] = ' ';
299  	}
300  	dst[-1] = '\0';
301  	return buf;
302  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-threadsignaltest.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-threadsignaltest.c</div>
                </div>
                <div class="column column_space"><pre><code>183  		localnet = 0;
184  		netmask = 0;
185  		warning("%s", ebuf);
186  	}
187  	cmdbuf = copy_argv(&argv[optind]);
</pre></code></div>
                <div class="column column_space"><pre><code>183  		localnet = 0;
184  		netmask = 0;
185  		warning("%s", ebuf);
186  	}
187  	cmdbuf = copy_argv(&argv[optind]);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    