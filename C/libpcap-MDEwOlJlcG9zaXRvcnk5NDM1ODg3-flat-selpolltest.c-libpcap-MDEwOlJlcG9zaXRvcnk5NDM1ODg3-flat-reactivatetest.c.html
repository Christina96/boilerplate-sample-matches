
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 39, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-selpolltest.c</h3>
            <pre><code>1  #include "varattrs.h"
2  #ifndef lint
3  static const char copyright[] _U_ =
4      "@(#) Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000\n\
5  The Regents of the University of California.  All rights reserved.\n";
6  #endif
7  #include <pcap.h>
8  #include <stdio.h>
9  #include <stdlib.h>
10  #include <string.h>
11  #include <stdarg.h>
12  #include <unistd.h>
13  #include <errno.h>
14  #include <sys/types.h>
15  #ifdef HAVE_SYS_SELECT_H
16  #include <sys/select.h>
17  #else
18  #include <sys/time.h>	&bsol;* older UN*Xes */
19  #endif
20  #include <poll.h>
21  #include "pcap/funcattrs.h"
22  static char *program_name;
23  static void countme(u_char *, const struct pcap_pkthdr *, const u_char *);
24  static void PCAP_NORETURN usage(void);
25  static void PCAP_NORETURN error(const char *, ...) PCAP_PRINTFLIKE(1, 2);
26  static void warning(const char *, ...) PCAP_PRINTFLIKE(1, 2);
27  static char *copy_argv(char **);
28  static pcap_t *pd;
29  int
30  main(int argc, char **argv)
31  {
32  	register int op;
33  	bpf_u_int32 localnet, netmask;
34  	register char *cp, *cmdbuf, *device;
35  	int doselect, dopoll, dotimeout, dononblock, quiet;
36  	const char *mechanism;
37  	struct bpf_program fcode;
38  	char ebuf[PCAP_ERRBUF_SIZE];
39  	pcap_if_t *devlist;
40  	int selectable_fd = -1;
41  	const struct timeval *required_timeout;
42  	int status;
43  	int packet_count;
44  	device = NULL;
45  	doselect = 0;
46  	dopoll = 0;
47  	mechanism = NULL;
48  	dotimeout = 0;
49  	dononblock = 0;
50  	quiet = 0;
51  	if ((cp = strrchr(argv[0], '/')) != NULL)
52  		program_name = cp + 1;
53  	else
54  		program_name = argv[0];
55  	opterr = 0;
56  	while ((op = getopt(argc, argv, "i:sptnq")) != -1) {
57  		switch (op) {
58  		case 'i':
59  			device = optarg;
60  			break;
61  		case 's':
62  			doselect = 1;
63  			mechanism = "select() and pcap_dispatch()";
64  			break;
65  		case 'p':
66  			dopoll = 1;
67  			mechanism = "poll() and pcap_dispatch()";
68  			break;
69  		case 't':
70  			dotimeout = 1;
71  			break;
72  		case 'n':
73  			dononblock = 1;
74  			break;
75  		case 'q':
76  			quiet = 1;
77  			break;
78  		default:
79  			usage();
80  		}
81  	}
82  	if (doselect && dopoll) {
83  		fprintf(stderr, "selpolltest: choose select (-s) or poll (-p), but not both\n");
84  		return 1;
85  	}
86  	if (dotimeout && !doselect && !dopoll) {
87  		fprintf(stderr, "selpolltest: timeout (-t) requires select (-s) or poll (-p)\n");
88  		return 1;
89  	}
90  	if (device == NULL) {
91  		if (pcap_findalldevs(&devlist, ebuf) == -1)
92  			error("%s", ebuf);
93  		if (devlist == NULL)
94  			error("no interfaces available for capture");
95  		device = strdup(devlist->name);
96  		pcap_freealldevs(devlist);
97  	}
98  	*ebuf = '\0';
99  	pd = pcap_open_live(device, 65535, 0, 1000, ebuf);
100  	if (pd == NULL)
101  		error("%s", ebuf);
102  	else if (*ebuf)
103  		warning("%s", ebuf);
104  	if (pcap_lookupnet(device, &localnet, &netmask, ebuf) < 0) {
105  		localnet = 0;
106  		netmask = 0;
107  		warning("%s", ebuf);
108  	}
109  	cmdbuf = copy_argv(&argv[optind]);
110  	if (pcap_compile(pd, &fcode, cmdbuf, 1, netmask) < 0)
111  		error("%s", pcap_geterr(pd));
112  	if (pcap_setfilter(pd, &fcode) < 0)
113  		error("%s", pcap_geterr(pd));
114  	if (doselect || dopoll) {
115  		selectable_fd = pcap_get_selectable_fd(pd);
116  		if (selectable_fd == -1) {
117  			printf("Listening on %s, using %s, with a timeout\n",
118  			    device, mechanism);
119  			required_timeout = pcap_get_required_select_timeout(pd);
120  			if (required_timeout == NULL)
121  				error("select()/poll() isn't supported on %s, even with a timeout",
122  				    device);
123  			dononblock = 1;
124  		} else {
125  			printf("Listening on %s, using %s\n", device,
126  			    mechanism);
127  			required_timeout = NULL;
128  		}
129  	} else
130  		printf("Listening on %s, using pcap_dispatch()\n", device);
131  	if (dononblock) {
132  		if (pcap_setnonblock(pd, 1, ebuf) == -1)
133  			error("pcap_setnonblock failed: %s", ebuf);
134  	}
135  	if (doselect) {
136  		for (;;) {
137  			fd_set setread, setexcept;
138  			struct timeval seltimeout;
139  			struct timeval *timeoutp;
140  			FD_ZERO(&setread);
141  			if (selectable_fd != -1) {
142  				FD_SET(selectable_fd, &setread);
143  				FD_ZERO(&setexcept);
144  				FD_SET(selectable_fd, &setexcept);
145  			}
146  			required_timeout = pcap_get_required_select_timeout(pd);
147  			if (dotimeout) {
148  				seltimeout.tv_sec = 0;
149  				if (required_timeout != NULL &&
150  				    required_timeout->tv_usec < 1000)
151  					seltimeout.tv_usec = required_timeout->tv_usec;
152  				else
153  					seltimeout.tv_usec = 1000;
154  				timeoutp = &seltimeout;
155  			} else if (required_timeout != NULL) {
156  				seltimeout = *required_timeout;
157  				timeoutp = &seltimeout;
158  			} else {
159  				timeoutp = NULL;
160  			}
161  			status = select((selectable_fd == -1) ?
162  			    0 : selectable_fd + 1, &setread, NULL, &setexcept,
163  			    timeoutp);
164  			if (status == -1) {
165  				printf("Select returns error (%s)\n",
166  				    strerror(errno));
167  			} else {
168  				if (!quiet) {
169  					if (status == 0)
170  						printf("Select timed out: ");
171  					else{
172  						printf("Select returned a descriptor: ");
173  						if (FD_ISSET(selectable_fd, &setread))
174  							printf("readable, ");
175  						else
176  							printf("not readable, ");
177  						if (FD_ISSET(selectable_fd, &setexcept))
178  							printf("exceptional condition\n");
179  						else
180  							printf("no exceptional condition\n");
181  					}
182  				}
183  				packet_count = 0;
184  				status = pcap_dispatch(pd, -1, countme,
185  				    (u_char *)&packet_count);
186  				if (status < 0)
187  					break;
188  				if (status != 0 || packet_count != 0 ||
189  				    required_timeout != NULL) {
190  					printf("%d packets seen, %d packets counted after select returns\n",
191  					    status, packet_count);
192  				}
193  			}
194  		}
195  	} else if (dopoll) {
196  		for (;;) {
197  			struct pollfd fd;
198  			int polltimeout;
199  			fd.fd = selectable_fd;
200  			fd.events = POLLIN;
201  			required_timeout = pcap_get_required_select_timeout(pd);
202  			if (dotimeout)
203  				polltimeout = 1;
204  			else if (required_timeout != NULL &&
205  			    required_timeout->tv_usec >= 1000)
206  				polltimeout = (int)(required_timeout->tv_usec/1000);
207  			else
208  				polltimeout = -1;
209  			status = poll(&fd, (selectable_fd == -1) ? 0 : 1, polltimeout);
210  			if (status == -1) {
211  				printf("Poll returns error (%s)\n",
212  				    strerror(errno));
213  			} else {
214  				if (!quiet) {
215  					if (status == 0)
216  						printf("Poll timed out\n");
217  					else {
218  						printf("Poll returned a descriptor: ");
219  						if (fd.revents & POLLIN)
220  							printf("readable, ");
221  						else
222  							printf("not readable, ");
223  						if (fd.revents & POLLERR)
224  							printf("exceptional condition, ");
225  						else
226  							printf("no exceptional condition, ");
227  						if (fd.revents & POLLHUP)
228  							printf("disconnect, ");
229  						else
230  							printf("no disconnect, ");
231  						if (fd.revents & POLLNVAL)
232  							printf("invalid\n");
233  						else
234  							printf("not invalid\n");
235  					}
236  				}
237  				packet_count = 0;
238  				status = pcap_dispatch(pd, -1, countme,
239  				    (u_char *)&packet_count);
240  				if (status < 0)
241  					break;
242  				if (status != 0 || packet_count != 0 ||
243  				    required_timeout != NULL) {
244  					printf("%d packets seen, %d packets counted after poll returns\n",
245  					    status, packet_count);
246  				}
247  			}
248  		}
249  	} else {
250  		for (;;) {
251  			packet_count = 0;
252  			status = pcap_dispatch(pd, -1, countme,
253  			    (u_char *)&packet_count);
254  			if (status < 0)
255  				break;
256  			printf("%d packets seen, %d packets counted after pcap_dispatch returns\n",
257  			    status, packet_count);
258  		}
259  	}
260  	if (status == -2) {
261  		putchar('\n');
262  	}
263  	(void)fflush(stdout);
264  	if (status == -1) {
265  		(void)fprintf(stderr, "%s: pcap_dispatch: %s\n",
266  		    program_name, pcap_geterr(pd));
267  	}
268  	pcap_close(pd);
269  	exit(status == -1 ? 1 : 0);
270  }
271  static void
272  countme(u_char *user, const struct pcap_pkthdr *h _U_, const u_char *sp _U_)
273  {
274  	int *counterp = (int *)user;
275  	(*counterp)++;
276  }
277  static void
278  usage(void)
279  {
280  	(void)fprintf(stderr, "Usage: %s [ -sptnq ] [ -i interface ] [expression]\n",
281  	    program_name);
282  	exit(1);
283  }
284  static void
285  error(const char *fmt, ...)
286  {
287  	va_list ap;
288  	(void)fprintf(stderr, "%s: ", program_name);
289  	va_start(ap, fmt);
290  	(void)vfprintf(stderr, fmt, ap);
<span onclick='openModal()' class='match'>291  	va_end(ap);
292  	if (*fmt) {
293  		fmt += strlen(fmt);
294  		if (fmt[-1] != '\n')
295  			(void)fputc('\n', stderr);
296  	}
297  	exit(1);
</span>298  }
299  static void
300  warning(const char *fmt, ...)
301  {
302  	va_list ap;
303  	(void)fprintf(stderr, "%s: WARNING: ", program_name);
304  	va_start(ap, fmt);
305  	(void)vfprintf(stderr, fmt, ap);
306  	va_end(ap);
307  	if (*fmt) {
308  		fmt += strlen(fmt);
309  		if (fmt[-1] != '\n')
310  			(void)fputc('\n', stderr);
311  	}
312  }
313  static char *
314  copy_argv(register char **argv)
315  {
316  	register char **p;
317  	register size_t len = 0;
318  	char *buf;
319  	char *src, *dst;
320  	p = argv;
321  	if (*p == 0)
322  		return 0;
323  	while (*p)
324  		len += strlen(*p++) + 1;
325  	buf = (char *)malloc(len);
326  	if (buf == NULL)
327  		error("copy_argv: malloc");
328  	p = argv;
329  	dst = buf;
330  	while ((src = *p++) != NULL) {
331  		while ((*dst++ = *src++) != '\0')
332  			;
333  		dst[-1] = ' ';
334  	}
335  	dst[-1] = '\0';
336  	return buf;
337  }
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-reactivatetest.c</h3>
            <pre><code>1  #include "varattrs.h"
2  #ifndef lint
3  static const char copyright[] _U_ =
4      "@(#) Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000\n\
5  The Regents of the University of California.  All rights reserved.\n";
6  #endif
7  #include <pcap.h>
8  #include <stdio.h>
9  #include <stdlib.h>
10  #include <string.h>
11  #include <stdarg.h>
12  #include "pcap/funcattrs.h"
13  static void PCAP_NORETURN error(PCAP_FORMAT_STRING(const char *), ...) PCAP_PRINTFLIKE(1,2);
14  int
15  main(void)
16  {
17  	char ebuf[PCAP_ERRBUF_SIZE];
18  	pcap_t *pd;
19  	int status = 0;
20  	pd = pcap_open_live("lo0", 65535, 0, 1000, ebuf);
21  	if (pd == NULL) {
22  		pd = pcap_open_live("lo", 65535, 0, 1000, ebuf);
23  		if (pd == NULL) {
24  			error("Neither lo0 nor lo could be opened: %s",
25  			    ebuf);
26  		}
27  	}
28  	status = pcap_activate(pd);
29  	if (status != PCAP_ERROR_ACTIVATED) {
30  		if (status == 0)
31  			error("pcap_activate() of opened pcap_t succeeded");
32  		else if (status == PCAP_ERROR)
33  			error("pcap_activate() of opened pcap_t failed with %s, not PCAP_ERROR_ACTIVATED",
34  			    pcap_geterr(pd));
35  		else
36  			error("pcap_activate() of opened pcap_t failed with %s, not PCAP_ERROR_ACTIVATED",
37  			    pcap_statustostr(status));
38  	}
39  	return 0;
40  }
41  static void
42  error(const char *fmt, ...)
43  {
44  	va_list ap;
45  	(void)fprintf(stderr, "reactivatetest: ");
46  	va_start(ap, fmt);
47  	(void)vfprintf(stderr, fmt, ap);
<span onclick='openModal()' class='match'>48  	va_end(ap);
49  	if (*fmt) {
50  		fmt += strlen(fmt);
51  		if (fmt[-1] != '\n')
52  			(void)fputc('\n', stderr);
53  	}
54  	exit(1);
</span>55  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-selpolltest.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-reactivatetest.c</div>
                </div>
                <div class="column column_space"><pre><code>291  	va_end(ap);
292  	if (*fmt) {
293  		fmt += strlen(fmt);
294  		if (fmt[-1] != '\n')
295  			(void)fputc('\n', stderr);
296  	}
297  	exit(1);
</pre></code></div>
                <div class="column column_space"><pre><code>48  	va_end(ap);
49  	if (*fmt) {
50  		fmt += strlen(fmt);
51  		if (fmt[-1] != '\n')
52  			(void)fputc('\n', stderr);
53  	}
54  	exit(1);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    