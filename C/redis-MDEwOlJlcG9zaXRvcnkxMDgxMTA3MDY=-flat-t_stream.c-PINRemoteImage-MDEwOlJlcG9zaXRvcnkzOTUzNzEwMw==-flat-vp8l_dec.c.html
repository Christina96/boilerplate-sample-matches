
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.390702274975272%, Tokens: 9</h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-t_stream.c</h3>
            <pre><code>1  #include "server.h"
2  #include "endianconv.h"
3  #include "stream.h"
4  #define STREAM_BYTES_PER_LISTPACK 2048
5  #define STREAM_ITEM_FLAG_NONE 0             &bsol;* No special flags. */
6  #define STREAM_ITEM_FLAG_DELETED (1<<0)     &bsol;* Entry is delted. Skip it. */
7  #define STREAM_ITEM_FLAG_SAMEFIELDS (1<<1)  &bsol;* Same fields as master entry. */
8  void streamFreeCG(streamCG *cg);
9  void streamFreeNACK(streamNACK *na);
10  size_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer *consumer);
11  stream *streamNew(void) {
12      stream *s = zmalloc(sizeof(*s));
13      s->rax = raxNew();
14      s->length = 0;
15      s->last_id.ms = 0;
16      s->last_id.seq = 0;
17      s->cgroups = NULL; &bsol;* Created on demand to save memory when not used. */
18      return s;
19  }
20  void freeStream(stream *s) {
21      raxFreeWithCallback(s->rax,(void(*)(void*))lpFree);
22      if (s->cgroups)
23          raxFreeWithCallback(s->cgroups,(void(*)(void*))streamFreeCG);
24      zfree(s);
25  }
26  void streamIncrID(streamID *id) {
27      if (id->seq == UINT64_MAX) {
28          if (id->ms == UINT64_MAX) {
29              id->ms = id->seq = 0;
30          } else {
<span onclick='openModal()' class='match'>31              id->ms++;
32              id->seq = 0;
33          }
34      } else {
35          id->seq++;
36      }
37  }
</span>38  PORT_ULONG streamLength(const robj *subject) {
39      stream *s = subject->ptr;
40      return s->length;
41  }
42  void streamNextID(streamID *last_id, streamID *new_id) {
43      uint64_t ms = mstime();
44      if (ms > last_id->ms) {
45          new_id->ms = ms;
46          new_id->seq = 0;
47      } else {
48          *new_id = *last_id;
49          streamIncrID(new_id);
50      }
51  }
52  unsigned char *lpAppendInteger(unsigned char *lp, int64_t value) {
53      char buf[LONG_STR_SIZE];
54      int slen = ll2string(buf,sizeof(buf),value);
55      return lpAppend(lp,(unsigned char*)buf,slen);
56  }
57  unsigned char *lpReplaceInteger(unsigned char *lp, unsigned char **pos, int64_t value) {
58      char buf[LONG_STR_SIZE];
59      int slen = ll2string(buf,sizeof(buf),value);
60      return lpInsert(lp, (unsigned char*)buf, slen, *pos, LP_REPLACE, pos);
61  }
62  int64_t lpGetInteger(unsigned char *ele) {
63      int64_t v;
64      unsigned char *e = lpGet(ele,&v,NULL);
65      if (e == NULL) return v;
66      PORT_LONGLONG ll;
67      int retval = string2ll((char*)e,v,&ll);
68      serverAssert(retval != 0);
69      v = ll;
70      return v;
71  }
72  void streamLogListpackContent(unsigned char *lp) {
73      unsigned char *p = lpFirst(lp);
74      while(p) {
75          unsigned char buf[LP_INTBUF_SIZE];
76          int64_t v;
77          unsigned char *ele = lpGet(p,&v,buf);
78          serverLog(LL_WARNING,"- [%d] '%.*s'", (int)v, (int)v, ele);
79          p = lpNext(lp,p);
80      }
81  }
82  void streamEncodeID(void *buf, streamID *id) {
83      uint64_t e[2];
84      e[0] = htonu64(id->ms);
85      e[1] = htonu64(id->seq);
86      memcpy(buf,e,sizeof(e));
87  }
88  void streamDecodeID(void *buf, streamID *id) {
89      uint64_t e[2];
90      memcpy(e,buf,sizeof(e));
91      id->ms = ntohu64(e[0]);
92      id->seq = ntohu64(e[1]);
93  }
94  int streamCompareID(streamID *a, streamID *b) {
95      if (a->ms > b->ms) return 1;
96      else if (a->ms < b->ms) return -1;
97      else if (a->seq > b->seq) return 1;
98      else if (a->seq < b->seq) return -1;
99      return 0;
100  }
101  int streamAppendItem(stream *s, robj **argv, int64_t numfields, streamID *added_id, streamID *use_id) {
102      streamID id;
103      if (use_id)
104          id = *use_id;
105      else
106          streamNextID(&s->last_id,&id);
107      if (streamCompareID(&id,&s->last_id) <= 0) return C_ERR;
108      raxIterator ri;
109      raxStart(&ri,s->rax);
110      raxSeek(&ri,"$",NULL,0);
111      size_t lp_bytes = 0;        &bsol;* Total bytes in the tail listpack. */
112      unsigned char *lp = NULL;   &bsol;* Tail listpack pointer. */
113      if (raxNext(&ri)) {
114          lp = ri.data;
115          lp_bytes = lpBytes(lp);
116      }
117      raxStop(&ri);
118      uint64_t rax_key[2];    &bsol;* Key in the radix tree containing the listpack.*/
119      streamID master_id;     &bsol;* ID of the master entry in the listpack. */
120      if (lp != NULL) {
121          if (server.stream_node_max_bytes &&
122              lp_bytes >= server.stream_node_max_bytes)
123          {
124              lp = NULL;
125          } else if (server.stream_node_max_entries) {
126              int64_t count = lpGetInteger(lpFirst(lp));
127              if (count >= server.stream_node_max_entries) lp = NULL;
128          }
129      }
130      int flags = STREAM_ITEM_FLAG_NONE;
131      if (lp == NULL || lp_bytes >= server.stream_node_max_bytes) {
132          master_id = id;
133          streamEncodeID(rax_key,&id);
134          lp = lpNew();
135          lp = lpAppendInteger(lp,1); &bsol;* One item, the one we are adding. */
136          lp = lpAppendInteger(lp,0); &bsol;* Zero deleted so far. */
137          lp = lpAppendInteger(lp,numfields);
138          for (int64_t i = 0; i < numfields; i++) {
139              sds field = argv[i*2]->ptr;
140              lp = lpAppend(lp,(unsigned char*)field,sdslen(field));
141          }
142          lp = lpAppendInteger(lp,0); &bsol;* Master entry zero terminator. */
143          raxInsert(s->rax,(unsigned char*)&rax_key,sizeof(rax_key),lp,NULL);
144          flags |= STREAM_ITEM_FLAG_SAMEFIELDS;
145      } else {
146          serverAssert(ri.key_len == sizeof(rax_key));
147          memcpy(rax_key,ri.key,sizeof(rax_key));
148          streamDecodeID(rax_key,&master_id);
149          unsigned char *lp_ele = lpFirst(lp);
150          int64_t count = lpGetInteger(lp_ele);
151          lp = lpReplaceInteger(lp,&lp_ele,count+1);
152          lp_ele = lpNext(lp,lp_ele); &bsol;* seek deleted. */
153          lp_ele = lpNext(lp,lp_ele); &bsol;* seek master entry num fields. */
154          int64_t master_fields_count = lpGetInteger(lp_ele);
155          lp_ele = lpNext(lp,lp_ele);
156          if (numfields == master_fields_count) {
157              int64_t i;
158              for (i = 0; i < master_fields_count; i++) {
159                  sds field = argv[i*2]->ptr;
160                  int64_t e_len;
161                  unsigned char buf[LP_INTBUF_SIZE];
162                  unsigned char *e = lpGet(lp_ele,&e_len,buf);
163                  if (sdslen(field) != (size_t)e_len ||
164                      memcmp(e,field,e_len) != 0) break;
165                  lp_ele = lpNext(lp,lp_ele);
166              }
167              if (i == master_fields_count) flags |= STREAM_ITEM_FLAG_SAMEFIELDS;
168          }
169      }
170      lp = lpAppendInteger(lp,flags);
171      lp = lpAppendInteger(lp,id.ms - master_id.ms);
172      lp = lpAppendInteger(lp,id.seq - master_id.seq);
173      if (!(flags & STREAM_ITEM_FLAG_SAMEFIELDS))
174          lp = lpAppendInteger(lp,numfields);
175      for (int64_t i = 0; i < numfields; i++) {
176          sds field = argv[i*2]->ptr, value = argv[i*2+1]->ptr;
177          if (!(flags & STREAM_ITEM_FLAG_SAMEFIELDS))
178              lp = lpAppend(lp,(unsigned char*)field,sdslen(field));
179          lp = lpAppend(lp,(unsigned char*)value,sdslen(value));
180      }
181      int64_t lp_count = numfields;
182      lp_count += 3; &bsol;* Add the 3 fixed fields flags + ms-diff + seq-diff. */
183      if (!(flags & STREAM_ITEM_FLAG_SAMEFIELDS)) {
184          lp_count += numfields+1;
185      }
186      lp = lpAppendInteger(lp,lp_count);
187      if (ri.data != lp)
188          raxInsert(s->rax,(unsigned char*)&rax_key,sizeof(rax_key),lp,NULL);
189      s->length++;
190      s->last_id = id;
191      if (added_id) *added_id = id;
192      return C_OK;
193  }
194  int64_t streamTrimByLength(stream *s, size_t maxlen, int approx) {
195      if (s->length <= maxlen) return 0;
196      raxIterator ri;
197      raxStart(&ri,s->rax);
198      raxSeek(&ri,"^",NULL,0);
199      int64_t deleted = 0;
200      while(s->length > maxlen && raxNext(&ri)) {
201          unsigned char *lp = ri.data, *p = lpFirst(lp);
202          int64_t entries = lpGetInteger(p);
203          if (s->length - entries >= maxlen) {
204              lpFree(lp);
205              raxRemove(s->rax,ri.key,ri.key_len,NULL);
206              raxSeek(&ri,">=",ri.key,ri.key_len);
207              s->length -= entries;
208              deleted += entries;
209              continue;
210          }
211          if (approx) break;
212          int64_t to_delete = s->length - maxlen;
213          serverAssert(to_delete < entries);
214          lp = lpReplaceInteger(lp,&p,entries-to_delete);
215          p = lpNext(lp,p); &bsol;* Seek deleted field. */
216          int64_t marked_deleted = lpGetInteger(p);
217          lp = lpReplaceInteger(lp,&p,marked_deleted+to_delete);
218          p = lpNext(lp,p); &bsol;* Seek num-of-fields in the master entry. */
219          int64_t master_fields_count = lpGetInteger(p);
220          p = lpNext(lp,p); &bsol;* Seek the first field. */
221          for (int64_t j = 0; j < master_fields_count; j++)
222              p = lpNext(lp,p); &bsol;* Skip all master fields. */
223          p = lpNext(lp,p); &bsol;* Skip the zero master entry terminator. */
224          while(p) {
225              int flags = lpGetInteger(p);
226              int to_skip;
227              if (!(flags & STREAM_ITEM_FLAG_DELETED)) {
228                  flags |= STREAM_ITEM_FLAG_DELETED;
229                  lp = lpReplaceInteger(lp,&p,flags);
230                  deleted++;
231                  s->length--;
232                  if (s->length <= maxlen) break; &bsol;* Enough entries deleted. */
233              }
234              p = lpNext(lp,p); &bsol;* Skip ID ms delta. */
235              p = lpNext(lp,p); &bsol;* Skip ID seq delta. */
236              p = lpNext(lp,p); &bsol;* Seek num-fields or values (if compressed). */
237              if (flags & STREAM_ITEM_FLAG_SAMEFIELDS) {
238                  to_skip = master_fields_count;
239              } else {
240                  to_skip = lpGetInteger(p);
241                  to_skip = 1+(to_skip*2);
242              }
243              while(to_skip--) p = lpNext(lp,p); &bsol;* Skip the whole entry. */
244              p = lpNext(lp,p); &bsol;* Skip the final lp-count field. */
245          }
246          entries -= to_delete;
247          marked_deleted += to_delete;
248          if (entries + marked_deleted > 10 && marked_deleted > entries/2) {
249          }
250          raxInsert(s->rax,ri.key,ri.key_len,lp,NULL);
251          break; &bsol;* If we are here, there was enough to delete in the current
252                    node, so no need to go to the next node. */
253      }
254      raxStop(&ri);
255      return deleted;
256  }
257  void streamIteratorStart(streamIterator *si, stream *s, streamID *start, streamID *end, int rev) {
258      if (start) {
259          streamEncodeID(si->start_key,start);
260      } else {
261          si->start_key[0] = 0;
262          si->start_key[1] = 0;
263      }
264      if (end) {
265          streamEncodeID(si->end_key,end);
266      } else {
267          si->end_key[0] = UINT64_MAX;
268          si->end_key[1] = UINT64_MAX;
269      }
270      raxStart(&si->ri,s->rax);
271      if (!rev) {
272          if (start && (start->ms || start->seq)) {
273              raxSeek(&si->ri,"<=",(unsigned char*)si->start_key,
274                      sizeof(si->start_key));
275              if (raxEOF(&si->ri)) raxSeek(&si->ri,"^",NULL,0);
276          } else {
277              raxSeek(&si->ri,"^",NULL,0);
278          }
279      } else {
280          if (end && (end->ms || end->seq)) {
281              raxSeek(&si->ri,"<=",(unsigned char*)si->end_key,
282                      sizeof(si->end_key));
283              if (raxEOF(&si->ri)) raxSeek(&si->ri,"$",NULL,0);
284          } else {
285              raxSeek(&si->ri,"$",NULL,0);
286          }
287      }
288      si->stream = s;
289      si->lp = NULL; &bsol;* There is no current listpack right now. */
290      si->lp_ele = NULL; &bsol;* Current listpack cursor. */
291      si->rev = rev;  &bsol;* Direction, if non-zero reversed, from end to start. */
292  }
293  int streamIteratorGetID(streamIterator *si, streamID *id, int64_t *numfields) {
294      while(1) { &bsol;* Will stop when element > stop_key or end of radix tree. */
295          if (si->lp == NULL || si->lp_ele == NULL) {
296              if (!si->rev && !raxNext(&si->ri)) return 0;
297              else if (si->rev && !raxPrev(&si->ri)) return 0;
298              serverAssert(si->ri.key_len == sizeof(streamID));
299              streamDecodeID(si->ri.key,&si->master_id);
300              si->lp = si->ri.data;
301              si->lp_ele = lpFirst(si->lp);           &bsol;* Seek items count */
302              si->lp_ele = lpNext(si->lp,si->lp_ele); &bsol;* Seek deleted count. */
303              si->lp_ele = lpNext(si->lp,si->lp_ele); &bsol;* Seek num fields. */
304              si->master_fields_count = lpGetInteger(si->lp_ele);
305              si->lp_ele = lpNext(si->lp,si->lp_ele); &bsol;* Seek first field. */
306              si->master_fields_start = si->lp_ele;
307              if (!si->rev) {
308                  for (uint64_t i = 0; i < si->master_fields_count; i++)
309                      si->lp_ele = lpNext(si->lp,si->lp_ele);
310              } else {
311                  si->lp_ele = lpLast(si->lp);
312              }
313          } else if (si->rev) {
314              int lp_count = lpGetInteger(si->lp_ele);
315              while(lp_count--) si->lp_ele = lpPrev(si->lp,si->lp_ele);
316              si->lp_ele = lpPrev(si->lp,si->lp_ele);
317          }
318          while(1) {
319              if (!si->rev) {
320                  si->lp_ele = lpNext(si->lp,si->lp_ele);
321                  if (si->lp_ele == NULL) break;
322              } else {
323                  int64_t lp_count = lpGetInteger(si->lp_ele);
324                  if (lp_count == 0) { &bsol;* We reached the master entry. */
325                      si->lp = NULL;
326                      si->lp_ele = NULL;
327                      break;
328                  }
329                  while(lp_count--) si->lp_ele = lpPrev(si->lp,si->lp_ele);
330              }
331              si->lp_flags = si->lp_ele;
332              int flags = lpGetInteger(si->lp_ele);
333              si->lp_ele = lpNext(si->lp,si->lp_ele); &bsol;* Seek ID. */
334              *id = si->master_id;
335              id->ms += lpGetInteger(si->lp_ele);
336              si->lp_ele = lpNext(si->lp,si->lp_ele);
337              id->seq += lpGetInteger(si->lp_ele);
338              si->lp_ele = lpNext(si->lp,si->lp_ele);
339              unsigned char buf[sizeof(streamID)];
340              streamEncodeID(buf,id);
341              if (flags & STREAM_ITEM_FLAG_SAMEFIELDS) {
342                  *numfields = si->master_fields_count;
343              } else {
344                  *numfields = lpGetInteger(si->lp_ele);
345                  si->lp_ele = lpNext(si->lp,si->lp_ele);
346              }
347              if (!si->rev) {
348                  if (memcmp(buf,si->start_key,sizeof(streamID)) >= 0 &&
349                      !(flags & STREAM_ITEM_FLAG_DELETED))
350                  {
351                      if (memcmp(buf,si->end_key,sizeof(streamID)) > 0)
352                          return 0; &bsol;* We are already out of range. */
353                      si->entry_flags = flags;
354                      if (flags & STREAM_ITEM_FLAG_SAMEFIELDS)
355                          si->master_fields_ptr = si->master_fields_start;
356                      return 1; &bsol;* Valid item returned. */
357                  }
358              } else {
359                  if (memcmp(buf,si->end_key,sizeof(streamID)) <= 0 &&
360                      !(flags & STREAM_ITEM_FLAG_DELETED))
361                  {
362                      if (memcmp(buf,si->start_key,sizeof(streamID)) < 0)
363                          return 0; &bsol;* We are already out of range. */
364                      si->entry_flags = flags;
365                      if (flags & STREAM_ITEM_FLAG_SAMEFIELDS)
366                          si->master_fields_ptr = si->master_fields_start;
367                      return 1; &bsol;* Valid item returned. */
368                  }
369              }
370              if (!si->rev) {
371                  int64_t to_discard = (flags & STREAM_ITEM_FLAG_SAMEFIELDS) ?
372                                        *numfields : *numfields*2;
373                  for (int64_t i = 0; i < to_discard; i++)
374                      si->lp_ele = lpNext(si->lp,si->lp_ele);
375              } else {
376                  int64_t prev_times = 4; &bsol;* flag + id ms + id seq + one more to
377                                             go back to the previous entry "count"
378                                             field. */
379                  if (!(flags & STREAM_ITEM_FLAG_SAMEFIELDS)) prev_times++;
380                  while(prev_times--) si->lp_ele = lpPrev(si->lp,si->lp_ele);
381              }
382          }
383      }
384  }
385  void streamIteratorGetField(streamIterator *si, unsigned char **fieldptr, unsigned char **valueptr, int64_t *fieldlen, int64_t *valuelen) {
386      if (si->entry_flags & STREAM_ITEM_FLAG_SAMEFIELDS) {
387          *fieldptr = lpGet(si->master_fields_ptr,fieldlen,si->field_buf);
388          si->master_fields_ptr = lpNext(si->lp,si->master_fields_ptr);
389      } else {
390          *fieldptr = lpGet(si->lp_ele,fieldlen,si->field_buf);
391          si->lp_ele = lpNext(si->lp,si->lp_ele);
392      }
393      *valueptr = lpGet(si->lp_ele,valuelen,si->value_buf);
394      si->lp_ele = lpNext(si->lp,si->lp_ele);
395  }
396  void streamIteratorRemoveEntry(streamIterator *si, streamID *current) {
397      unsigned char *lp = si->lp;
398      int64_t aux;
399      int flags = lpGetInteger(si->lp_flags);
400      flags |= STREAM_ITEM_FLAG_DELETED;
401      lp = lpReplaceInteger(lp,&si->lp_flags,flags);
402      unsigned char *p = lpFirst(lp);
403      aux = lpGetInteger(p);
404      if (aux == 1) {
405          lpFree(lp);
406          raxRemove(si->stream->rax,si->ri.key,si->ri.key_len,NULL);
407      } else {
408          lp = lpReplaceInteger(lp,&p,aux-1);
409          p = lpNext(lp,p); &bsol;* Seek deleted field. */
410          aux = lpGetInteger(p);
411          lp = lpReplaceInteger(lp,&p,aux+1);
412          if (si->lp != lp)
413              raxInsert(si->stream->rax,si->ri.key,si->ri.key_len,lp,NULL);
414      }
415      si->stream->length--;
416      streamID start, end;
417      if (si->rev) {
418          streamDecodeID(si->start_key,&start);
419          end = *current;
420      } else {
421          start = *current;
422          streamDecodeID(si->end_key,&end);
423      }
424      streamIteratorStop(si);
425      streamIteratorStart(si,si->stream,&start,&end,si->rev);
426  }
427  void streamIteratorStop(streamIterator *si) {
428      raxStop(&si->ri);
429  }
430  int streamDeleteItem(stream *s, streamID *id) {
431      int deleted = 0;
432      streamIterator si;
433      streamIteratorStart(&si,s,id,id,0);
434      streamID myid;
435      int64_t numfields;
436      if (streamIteratorGetID(&si,&myid,&numfields)) {
437          streamIteratorRemoveEntry(&si,&myid);
438          deleted = 1;
439      }
440      streamIteratorStop(&si);
441      return deleted;
442  }
443  void streamLastValidID(stream *s, streamID *maxid)
444  {
445      streamIterator si;
446      streamIteratorStart(&si,s,NULL,NULL,1);
447      int64_t numfields;
448      streamIteratorGetID(&si,maxid,&numfields);
449      streamIteratorStop(&si);
450  }
451  void addReplyStreamID(client *c, streamID *id) {
452      sds replyid = sdscatfmt(sdsempty(),"%U-%U",id->ms,id->seq);
453      addReplyBulkSds(c,replyid);
454  }
455  robj *createObjectFromStreamID(streamID *id) {
456      return createObject(OBJ_STRING, sdscatfmt(sdsempty(),"%U-%U",
457                          id->ms,id->seq));
458  }
459  void streamPropagateXCLAIM(client *c, robj *key, streamCG *group, robj *groupname, robj *id, streamNACK *nack) {
460      robj *argv[14];
461      argv[0] = createStringObject("XCLAIM",6);
462      argv[1] = key;
463      argv[2] = groupname;
464      argv[3] = createStringObject(nack->consumer->name,sdslen(nack->consumer->name));
465      argv[4] = createStringObjectFromLongLong(0);
466      argv[5] = id;
467      argv[6] = createStringObject("TIME",4);
468      argv[7] = createStringObjectFromLongLong(nack->delivery_time);
469      argv[8] = createStringObject("RETRYCOUNT",10);
470      argv[9] = createStringObjectFromLongLong(nack->delivery_count);
471      argv[10] = createStringObject("FORCE",5);
472      argv[11] = createStringObject("JUSTID",6);
473      argv[12] = createStringObject("LASTID",6);
474      argv[13] = createObjectFromStreamID(&group->last_id);
475      propagate(server.xclaimCommand,c->db->id,argv,14,PROPAGATE_AOF|PROPAGATE_REPL);
476      decrRefCount(argv[0]);
477      decrRefCount(argv[3]);
478      decrRefCount(argv[4]);
479      decrRefCount(argv[6]);
480      decrRefCount(argv[7]);
481      decrRefCount(argv[8]);
482      decrRefCount(argv[9]);
483      decrRefCount(argv[10]);
484      decrRefCount(argv[11]);
485      decrRefCount(argv[12]);
486      decrRefCount(argv[13]);
487  }
488  void streamPropagateGroupID(client *c, robj *key, streamCG *group, robj *groupname) {
489      robj *argv[5];
490      argv[0] = createStringObject("XGROUP",6);
491      argv[1] = createStringObject("SETID",5);
492      argv[2] = key;
493      argv[3] = groupname;
494      argv[4] = createObjectFromStreamID(&group->last_id);
495      propagate(server.xgroupCommand,c->db->id,argv,5,PROPAGATE_AOF|PROPAGATE_REPL);
496      decrRefCount(argv[0]);
497      decrRefCount(argv[1]);
498      decrRefCount(argv[4]);
499  }
500  #define STREAM_RWR_NOACK (1<<0)         &bsol;* Do not create entries in the PEL. */
501  #define STREAM_RWR_RAWENTRIES (1<<1)    &bsol;* Do not emit protocol for array
502                                             boundaries, just the entries. */
503  #define STREAM_RWR_HISTORY (1<<2)       &bsol;* Only serve consumer local PEL. */
504  size_t streamReplyWithRange(client *c, stream *s, streamID *start, streamID *end, size_t count, int rev, streamCG *group, streamConsumer *consumer, int flags, streamPropInfo *spi) {
505      void *arraylen_ptr = NULL;
506      size_t arraylen = 0;
507      streamIterator si;
508      int64_t numfields;
509      streamID id;
510      int propagate_last_id = 0;
511      if (group && (flags & STREAM_RWR_HISTORY)) {
512          return streamReplyWithRangeFromConsumerPEL(c,s,start,end,count,
513                                                     consumer);
514      }
515      if (!(flags & STREAM_RWR_RAWENTRIES))
516          arraylen_ptr = addDeferredMultiBulkLength(c);
517      streamIteratorStart(&si,s,start,end,rev);
518      while(streamIteratorGetID(&si,&id,&numfields)) {
519          if (group && streamCompareID(&id,&group->last_id) > 0) {
520              group->last_id = id;
521              propagate_last_id = 1;
522          }
523          addReplyMultiBulkLen(c,2);
524          addReplyStreamID(c,&id);
525          addReplyMultiBulkLen(c,numfields*2);
526          while(numfields--) {
527              unsigned char *key, *value;
528              int64_t key_len, value_len;
529              streamIteratorGetField(&si,&key,&value,&key_len,&value_len);
530              addReplyBulkCBuffer(c,key,key_len);
531              addReplyBulkCBuffer(c,value,value_len);
532          }
533          if (group && !(flags & STREAM_RWR_NOACK)) {
534              unsigned char buf[sizeof(streamID)];
535              streamEncodeID(buf,&id);
536              streamNACK *nack = streamCreateNACK(consumer);
537              int group_inserted =
538                  raxTryInsert(group->pel,buf,sizeof(buf),nack,NULL);
539              int consumer_inserted =
540                  raxTryInsert(consumer->pel,buf,sizeof(buf),nack,NULL);
541              if (group_inserted == 0) {
542                  streamFreeNACK(nack);
543                  nack = raxFind(group->pel,buf,sizeof(buf));
544                  serverAssert(nack != raxNotFound);
545                  raxRemove(nack->consumer->pel,buf,sizeof(buf),NULL);
546                  nack->consumer = consumer;
547                  nack->delivery_time = mstime();
548                  nack->delivery_count = 1;
549                  raxInsert(consumer->pel,buf,sizeof(buf),nack,NULL);
550              } else if (group_inserted == 1 && consumer_inserted == 0) {
551                  serverPanic("NACK half-created. Should not be possible.");
552              }
553              if (spi) {
554                  robj *idarg = createObjectFromStreamID(&id);
555                  streamPropagateXCLAIM(c,spi->keyname,group,spi->groupname,idarg,nack);
556                  decrRefCount(idarg);
557              }
558          } else {
559              if (propagate_last_id)
560                  streamPropagateGroupID(c,spi->keyname,group,spi->groupname);
561          }
562          arraylen++;
563          if (count && count == arraylen) break;
564      }
565      streamIteratorStop(&si);
566      if (arraylen_ptr) setDeferredMultiBulkLength(c,arraylen_ptr,arraylen);
567      return arraylen;
568  }
569  size_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer *consumer) {
570      raxIterator ri;
571      unsigned char startkey[sizeof(streamID)];
572      unsigned char endkey[sizeof(streamID)];
573      streamEncodeID(startkey,start);
574      if (end) streamEncodeID(endkey,end);
575      size_t arraylen = 0;
576      void *arraylen_ptr = addDeferredMultiBulkLength(c);
577      raxStart(&ri,consumer->pel);
578      raxSeek(&ri,">=",startkey,sizeof(startkey));
579      while(raxNext(&ri) && (!count || arraylen < count)) {
580          if (end && memcmp(ri.key,end,ri.key_len) > 0) break;
581          streamID thisid;
582          streamDecodeID(ri.key,&thisid);
583          if (streamReplyWithRange(c,s,&thisid,&thisid,1,0,NULL,NULL,
584                                   STREAM_RWR_RAWENTRIES,NULL) == 0)
585          {
586              addReplyMultiBulkLen(c,2);
587              streamID id;
588              streamDecodeID(ri.key,&id);
589              addReplyStreamID(c,&id);
590              addReply(c,shared.nullmultibulk);
591          } else {
592              streamNACK *nack = ri.data;
593              nack->delivery_time = mstime();
594              nack->delivery_count++;
595          }
596          arraylen++;
597      }
598      raxStop(&ri);
599      setDeferredMultiBulkLength(c,arraylen_ptr,arraylen);
600      return arraylen;
601  }
602  robj *streamTypeLookupWriteOrCreate(client *c, robj *key) {
603      robj *o = lookupKeyWrite(c->db,key);
604      if (o == NULL) {
605          o = createStreamObject();
606          dbAdd(c->db,key,o);
607      } else {
608          if (o->type != OBJ_STREAM) {
609              addReply(c,shared.wrongtypeerr);
610              return NULL;
611          }
612      }
613      return o;
614  }
615  int string2ull(const char *s, PORT_ULONGLONG *value) {
616      PORT_LONGLONG ll;
617      if (string2ll(s,strlen(s),&ll)) {
618          if (ll < 0) return 0; &bsol;* Negative values are out of range. */
619          *value = ll;
620          return 1;
621      }
622      errno = 0;
623      char *endptr = NULL;
624      *value = strtoull(s,&endptr,10);
625      if (errno == EINVAL || errno == ERANGE || !(*s != '\0' && *endptr == '\0'))
626          return 0; &bsol;* strtoull() failed. */
627      return 1; &bsol;* Conversion done! */
628  }
629  int streamGenericParseIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq, int strict) {
630      char buf[128];
631      if (sdslen(o->ptr) > sizeof(buf)-1) goto invalid;
632      memcpy(buf,o->ptr,sdslen(o->ptr)+1);
633      if (strict && (buf[0] == '-' || buf[0] == '+') && buf[1] == '\0')
634          goto invalid;
635      if (buf[0] == '-' && buf[1] == '\0') {
636          id->ms = 0;
637          id->seq = 0;
638          return C_OK;
639      } else if (buf[0] == '+' && buf[1] == '\0') {
640          id->ms = UINT64_MAX;
641          id->seq = UINT64_MAX;
642          return C_OK;
643      }
644      char *dot = strchr(buf,'-');
645      if (dot) *dot = '\0';
646      PORT_ULONGLONG ms, seq;
647      if (string2ull(buf,&ms) == 0) goto invalid;
648      if (dot && string2ull(dot+1,&seq) == 0) goto invalid;
649      if (!dot) seq = missing_seq;
650      id->ms = ms;
651      id->seq = seq;
652      return C_OK;
653  invalid:
654      if (c) addReplyError(c,"Invalid stream ID specified as stream "
655                             "command argument");
656      return C_ERR;
657  }
658  int streamParseIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq) {
659      return streamGenericParseIDOrReply(c,o,id,missing_seq,0);
660  }
661  int streamParseStrictIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq) {
662      return streamGenericParseIDOrReply(c,o,id,missing_seq,1);
663  }
664  void streamRewriteApproxMaxlen(client *c, stream *s, int maxlen_arg_idx) {
665      robj *maxlen_obj = createStringObjectFromLongLong(s->length);
666      robj *equal_obj = createStringObject("=",1);
667      rewriteClientCommandArgument(c,maxlen_arg_idx,maxlen_obj);
668      rewriteClientCommandArgument(c,maxlen_arg_idx-1,equal_obj);
669      decrRefCount(equal_obj);
670      decrRefCount(maxlen_obj);
671  }
672  void xaddCommand(client *c) {
673      streamID id;
674      int id_given = 0; &bsol;* Was an ID different than "*" specified? */
675      PORT_LONGLONG maxlen = -1;  &bsol;* If left to -1 no trimming is performed. */
676      int approx_maxlen = 0;  &bsol;* If 1 only delete whole radix tree nodes, so
677                                 the maxium length is not applied verbatim. */
678      int maxlen_arg_idx = 0; &bsol;* Index of the count in MAXLEN, for rewriting. */
679      int i = 2; &bsol;* This is the first argument position where we could
680                    find an option, or the ID. */
681      for (; i < c->argc; i++) {
682          int moreargs = (c->argc-1) - i; &bsol;* Number of additional arguments. */
683          char *opt = c->argv[i]->ptr;
684          if (opt[0] == '*' && opt[1] == '\0') {
685              break;
686          } else if (!strcasecmp(opt,"maxlen") && moreargs) {
687              approx_maxlen = 0;
688              char *next = c->argv[i+1]->ptr;
689              if (moreargs >= 2 && next[0] == '~' && next[1] == '\0') {
690                  approx_maxlen = 1;
691                  i++;
692              } else if (moreargs >= 2 && next[0] == '=' && next[1] == '\0') {
693                  i++;
694              }
695              if (getLongLongFromObjectOrReply(c,c->argv[i+1],&maxlen,NULL)
696                  != C_OK) return;
697              if (maxlen < 0) {
698                  addReplyError(c,"The MAXLEN argument must be >= 0.");
699                  return;
700              }
701              i++;
702              maxlen_arg_idx = i;
703          } else {
704              if (streamParseStrictIDOrReply(c,c->argv[i],&id,0) != C_OK) return;
705              id_given = 1;
706              break;
707          }
708      }
709      int field_pos = i+1;
710      if ((c->argc - field_pos) < 2 || ((c->argc-field_pos) % 2) == 1) {
711          addReplyError(c,"wrong number of arguments for XADD");
712          return;
713      }
714      if (id_given && id.ms == 0 && id.seq == 0) {
715          addReplyError(c,"The ID specified in XADD must be greater than 0-0");
716          return;
717      }
718      robj *o;
719      stream *s;
720      if ((o = streamTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
721      s = o->ptr;
722      if (s->last_id.ms == UINT64_MAX && s->last_id.seq == UINT64_MAX) {
723          addReplyError(c,"The stream has exhausted the last possible ID, "
724                          "unable to add more items");
725          return;
726      }
727      if (streamAppendItem(s,c->argv+field_pos,(c->argc-field_pos)/2,
728          &id, id_given ? &id : NULL)
729          == C_ERR)
730      {
731          addReplyError(c,"The ID specified in XADD is equal or smaller than the "
732                          "target stream top item");
733          return;
734      }
735      addReplyStreamID(c,&id);
736      signalModifiedKey(c->db,c->argv[1]);
737      notifyKeyspaceEvent(NOTIFY_STREAM,"xadd",c->argv[1],c->db->id);
738      server.dirty++;
739      if (maxlen >= 0) {
740          if (streamTrimByLength(s,maxlen,approx_maxlen)) {
741              notifyKeyspaceEvent(NOTIFY_STREAM,"xtrim",c->argv[1],c->db->id);
742          }
743          if (approx_maxlen) streamRewriteApproxMaxlen(c,s,maxlen_arg_idx);
744      }
745      robj *idarg = createObjectFromStreamID(&id);
746      rewriteClientCommandArgument(c,i,idarg);
747      decrRefCount(idarg);
748      if (server.blocked_clients_by_type[BLOCKED_STREAM])
749          signalKeyAsReady(c->db, c->argv[1]);
750  }
751  void xrangeGenericCommand(client *c, int rev) {
752      robj *o;
753      stream *s;
754      streamID startid, endid;
755      PORT_LONGLONG count = -1;
756      robj *startarg = rev ? c->argv[3] : c->argv[2];
757      robj *endarg = rev ? c->argv[2] : c->argv[3];
758      if (streamParseIDOrReply(c,startarg,&startid,0) == C_ERR) return;
759      if (streamParseIDOrReply(c,endarg,&endid,UINT64_MAX) == C_ERR) return;
760      if (c->argc > 4) {
761          for (int j = 4; j < c->argc; j++) {
762              int additional = c->argc-j-1;
763              if (strcasecmp(c->argv[j]->ptr,"COUNT") == 0 && additional >= 1) {
764                  if (getLongLongFromObjectOrReply(c,c->argv[j+1],&count,NULL)
765                      != C_OK) return;
766                  if (count < 0) count = 0;
767                  j++; &bsol;* Consume additional arg. */
768              } else {
769                  addReply(c,shared.syntaxerr);
770                  return;
771              }
772          }
773      }
774      if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk)) == NULL
775          || checkType(c,o,OBJ_STREAM)) return;
776      s = o->ptr;
777      if (count == 0) {
778          addReply(c,shared.nullmultibulk);
779      } else {
780          if (count == -1) count = 0;
781          streamReplyWithRange(c,s,&startid,&endid,count,rev,NULL,NULL,0,NULL);
782      }
783  }
784  void xrangeCommand(client *c) {
785      xrangeGenericCommand(c,0);
786  }
787  void xrevrangeCommand(client *c) {
788      xrangeGenericCommand(c,1);
789  }
790  void xlenCommand(client *c) {
791      robj *o;
792      if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL
793          || checkType(c,o,OBJ_STREAM)) return;
794      stream *s = o->ptr;
795      addReplyLongLong(c,s->length);
796  }
797  #define XREAD_BLOCKED_DEFAULT_COUNT 1000
798  void xreadCommand(client *c) {
799      PORT_LONGLONG timeout = -1; &bsol;* -1 means, no BLOCK argument given. */
800      PORT_LONGLONG count = 0;
801      int streams_count = 0;
802      int streams_arg = 0;
803      int noack = 0;          &bsol;* True if NOACK option was specified. */
804      #define STREAMID_STATIC_VECTOR_LEN 8
805      streamID static_ids[STREAMID_STATIC_VECTOR_LEN];
806      streamID *ids = static_ids;
807      streamCG **groups = NULL;
808      int xreadgroup = sdslen(c->argv[0]->ptr) == 10; &bsol;* XREAD or XREADGROUP? */
809      robj *groupname = NULL;
810      robj *consumername = NULL;
811      for (int i = 1; i < c->argc; i++) {
812          int moreargs = c->argc-i-1;
813          char *o = c->argv[i]->ptr;
814          if (!strcasecmp(o,"BLOCK") && moreargs) {
815              i++;
816              if (getTimeoutFromObjectOrReply(c,c->argv[i],&timeout,
817                  UNIT_MILLISECONDS) != C_OK) return;
818          } else if (!strcasecmp(o,"COUNT") && moreargs) {
819              i++;
820              if (getLongLongFromObjectOrReply(c,c->argv[i],&count,NULL) != C_OK)
821                  return;
822              if (count < 0) count = 0;
823          } else if (!strcasecmp(o,"STREAMS") && moreargs) {
824              streams_arg = i+1;
825              streams_count = (c->argc-streams_arg);
826              if ((streams_count % 2) != 0) {
827                  addReplyError(c,"Unbalanced XREAD list of streams: "
828                                  "for each stream key an ID or '$' must be "
829                                  "specified.");
830                  return;
831              }
832              streams_count /= 2; &bsol;* We have two arguments for each stream. */
833              break;
834          } else if (!strcasecmp(o,"GROUP") && moreargs >= 2) {
835              if (!xreadgroup) {
836                  addReplyError(c,"The GROUP option is only supported by "
837                                  "XREADGROUP. You called XREAD instead.");
838                  return;
839              }
840              groupname = c->argv[i+1];
841              consumername = c->argv[i+2];
842              i += 2;
843          } else if (!strcasecmp(o,"NOACK")) {
844              if (!xreadgroup) {
845                  addReplyError(c,"The NOACK option is only supported by "
846                                  "XREADGROUP. You called XREAD instead.");
847                  return;
848              }
849              noack = 1;
850          } else {
851              addReply(c,shared.syntaxerr);
852              return;
853          }
854      }
855      if (streams_arg == 0) {
856          addReply(c,shared.syntaxerr);
857          return;
858      }
859      if (xreadgroup && groupname == NULL) {
860          addReplyError(c,"Missing GROUP option for XREADGROUP");
861          return;
862      }
863      if (streams_count > STREAMID_STATIC_VECTOR_LEN)
864          ids = zmalloc(sizeof(streamID)*streams_count);
865      if (groupname) groups = zmalloc(sizeof(streamCG*)*streams_count);
866      for (int i = streams_arg + streams_count; i < c->argc; i++) {
867          int id_idx = i - streams_arg - streams_count;
868          robj *key = c->argv[i-streams_count];
869          robj *o = lookupKeyRead(c->db,key);
870          if (o && checkType(c,o,OBJ_STREAM)) goto cleanup;
871          streamCG *group = NULL;
872          if (groupname) {
873              if (o == NULL ||
874                  (group = streamLookupCG(o->ptr,groupname->ptr)) == NULL)
875              {
876                  addReplyErrorFormat(c, "-NOGROUP No such key '%s' or consumer "
877                                         "group '%s' in XREADGROUP with GROUP "
878                                         "option",
879                                      (char*)key->ptr,(char*)groupname->ptr);
880                  goto cleanup;
881              }
882              groups[id_idx] = group;
883          }
884          if (strcmp(c->argv[i]->ptr,"$") == 0) {
885              if (xreadgroup) {
886                  addReplyError(c,"The $ ID is meaningless in the context of "
887                                  "XREADGROUP: you want to read the history of "
888                                  "this consumer by specifying a proper ID, or "
889                                  "use the > ID to get new messages. The $ ID would "
890                                  "just return an empty result set.");
891                  goto cleanup;
892              }
893              if (o) {
894                  stream *s = o->ptr;
895                  ids[id_idx] = s->last_id;
896              } else {
897                  ids[id_idx].ms = 0;
898                  ids[id_idx].seq = 0;
899              }
900              continue;
901          } else if (strcmp(c->argv[i]->ptr,">") == 0) {
902              if (!xreadgroup) {
903                  addReplyError(c,"The > ID can be specified only when calling "
904                                  "XREADGROUP using the GROUP <group> "
905                                  "<consumer> option.");
906                  goto cleanup;
907              }
908              ids[id_idx].ms = UINT64_MAX;
909              ids[id_idx].seq = UINT64_MAX;
910              continue;
911          }
912          if (streamParseStrictIDOrReply(c,c->argv[i],ids+id_idx,0) != C_OK)
913              goto cleanup;
914      }
915      size_t arraylen = 0;
916      void *arraylen_ptr = NULL;
917      for (int i = 0; i < streams_count; i++) {
918          robj *o = lookupKeyRead(c->db,c->argv[streams_arg+i]);
919          if (o == NULL) continue;
920          stream *s = o->ptr;
921          streamID *gt = ids+i; &bsol;* ID must be greater than this. */
922          int serve_synchronously = 0;
923          int serve_history = 0; &bsol;* True for XREADGROUP with ID != ">". */
924          if (groups) {
925              if (gt->ms != UINT64_MAX ||
926                  gt->seq != UINT64_MAX)
927              {
928                  serve_synchronously = 1;
929                  serve_history = 1;
930              } else if (s->length) {
931                  streamID maxid, *last = &groups[i]->last_id;
932                  streamLastValidID(s, &maxid);
933                  if (streamCompareID(&maxid, last) > 0) {
934                      serve_synchronously = 1;
935                      *gt = *last;
936                  }
937              }
938          } else if (s->length) {
939              streamID maxid;
940              streamLastValidID(s, &maxid);
941              if (streamCompareID(&maxid, gt) > 0) {
942                  serve_synchronously = 1;
943              }
944          }
945          if (serve_synchronously) {
946              arraylen++;
947              if (arraylen == 1) arraylen_ptr = addDeferredMultiBulkLength(c);
948              streamID start = *gt;
949              streamIncrID(&start);
950              addReplyMultiBulkLen(c,2);
951              addReplyBulk(c,c->argv[streams_arg+i]);
952              streamConsumer *consumer = NULL;
953              if (groups) consumer = streamLookupConsumer(groups[i],
954                                                          consumername->ptr,
955                                                          SLC_NONE);
956              streamPropInfo spi = {c->argv[i+streams_arg],groupname};
957              int flags = 0;
958              if (noack) flags |= STREAM_RWR_NOACK;
959              if (serve_history) flags |= STREAM_RWR_HISTORY;
960              streamReplyWithRange(c,s,&start,NULL,count,0,
961                                   groups ? groups[i] : NULL,
962                                   consumer, flags, &spi);
963              if (groups) server.dirty++;
964          }
965      }
966      if (arraylen) {
967          setDeferredMultiBulkLength(c,arraylen_ptr,arraylen);
968          goto cleanup;
969      }
970      if (timeout != -1) {
971          if (c->flags & CLIENT_MULTI) {
972              addReply(c,shared.nullmultibulk);
973              goto cleanup;
974          }
975          blockForKeys(c, BLOCKED_STREAM, c->argv+streams_arg, streams_count,
976                       timeout, NULL, ids);
977          c->bpop.xread_count = count ? count : XREAD_BLOCKED_DEFAULT_COUNT;
978          if (groupname) {
979              incrRefCount(groupname);
980              incrRefCount(consumername);
981              c->bpop.xread_group = groupname;
982              c->bpop.xread_consumer = consumername;
983              c->bpop.xread_group_noack = noack;
984          } else {
985              c->bpop.xread_group = NULL;
986              c->bpop.xread_consumer = NULL;
987          }
988          goto cleanup;
989      }
990      addReply(c,shared.nullmultibulk);
991  cleanup: &bsol;* Cleanup. */
992      preventCommandPropagation(c);
993      if (ids != static_ids) zfree(ids);
994      zfree(groups);
995  }
996  streamNACK *streamCreateNACK(streamConsumer *consumer) {
997      streamNACK *nack = zmalloc(sizeof(*nack));
998      nack->delivery_time = mstime();
999      nack->delivery_count = 1;
1000      nack->consumer = consumer;
1001      return nack;
1002  }
1003  void streamFreeNACK(streamNACK *na) {
1004      zfree(na);
1005  }
1006  void streamFreeConsumer(streamConsumer *sc) {
1007      raxFree(sc->pel); &bsol;* No value free callback: the PEL entries are shared
1008                           between the consumer and the main stream PEL. */
1009      sdsfree(sc->name);
1010      zfree(sc);
1011  }
1012  streamCG *streamCreateCG(stream *s, char *name, size_t namelen, streamID *id) {
1013      if (s->cgroups == NULL) s->cgroups = raxNew();
1014      if (raxFind(s->cgroups,(unsigned char*)name,namelen) != raxNotFound)
1015          return NULL;
1016      streamCG *cg = zmalloc(sizeof(*cg));
1017      cg->pel = raxNew();
1018      cg->consumers = raxNew();
1019      cg->last_id = *id;
1020      raxInsert(s->cgroups,(unsigned char*)name,namelen,cg,NULL);
1021      return cg;
1022  }
1023  void streamFreeCG(streamCG *cg) {
1024      raxFreeWithCallback(cg->pel,(void(*)(void*))streamFreeNACK);
1025      raxFreeWithCallback(cg->consumers,(void(*)(void*))streamFreeConsumer);
1026      zfree(cg);
1027  }
1028  streamCG *streamLookupCG(stream *s, sds groupname) {
1029      if (s->cgroups == NULL) return NULL;
1030      streamCG *cg = raxFind(s->cgroups,(unsigned char*)groupname,
1031                             sdslen(groupname));
1032      return (cg == raxNotFound) ? NULL : cg;
1033  }
1034  streamConsumer *streamLookupConsumer(streamCG *cg, sds name, int flags) {
1035      int create = !(flags & SLC_NOCREAT);
1036      int refresh = !(flags & SLC_NOREFRESH);
1037      streamConsumer *consumer = raxFind(cg->consumers,(unsigned char*)name,
1038                                 sdslen(name));
1039      if (consumer == raxNotFound) {
1040          if (!create) return NULL;
1041          consumer = zmalloc(sizeof(*consumer));
1042          consumer->name = sdsdup(name);
1043          consumer->pel = raxNew();
1044          raxInsert(cg->consumers,(unsigned char*)name,sdslen(name),
1045                    consumer,NULL);
1046      }
1047      if (refresh) consumer->seen_time = mstime();
1048      return consumer;
1049  }
1050  uint64_t streamDelConsumer(streamCG *cg, sds name) {
1051      streamConsumer *consumer =
1052          streamLookupConsumer(cg,name,SLC_NOCREAT|SLC_NOREFRESH);
1053      if (consumer == NULL) return 0;
1054      uint64_t retval = raxSize(consumer->pel);
1055      raxIterator ri;
1056      raxStart(&ri,consumer->pel);
1057      raxSeek(&ri,"^",NULL,0);
1058      while(raxNext(&ri)) {
1059          streamNACK *nack = ri.data;
1060          raxRemove(cg->pel,ri.key,ri.key_len,NULL);
1061          streamFreeNACK(nack);
1062      }
1063      raxStop(&ri);
1064      raxRemove(cg->consumers,(unsigned char*)name,sdslen(name),NULL);
1065      streamFreeConsumer(consumer);
1066      return retval;
1067  }
1068  void xgroupCommand(client *c) {
1069      const char *help[] = {
1070  "CREATE      <key> <groupname> <id or $> [opt] -- Create a new consumer group.",
1071  "            option MKSTREAM: create the empty stream if it does not exist.",
1072  "SETID       <key> <groupname> <id or $>  -- Set the current group ID.",
1073  "DESTROY     <key> <groupname>            -- Remove the specified group.",
1074  "DELCONSUMER <key> <groupname> <consumer> -- Remove the specified consumer.",
1075  "HELP                                     -- Prints this help.",
1076  NULL
1077      };
1078      stream *s = NULL;
1079      sds grpname = NULL;
1080      streamCG *cg = NULL;
1081      char *opt = c->argv[1]->ptr; &bsol;* Subcommand name. */
1082      int mkstream = 0;
1083      robj *o;
1084      if (c->argc == 6 && !strcasecmp(opt,"CREATE")) {
1085          if (strcasecmp(c->argv[5]->ptr,"MKSTREAM")) {
1086              addReplySubcommandSyntaxError(c);
1087              return;
1088          }
1089          mkstream = 1;
1090          grpname = c->argv[3]->ptr;
1091      }
1092      if (c->argc >= 4) {
1093          o = lookupKeyWrite(c->db,c->argv[2]);
1094          if (o) {
1095              if (checkType(c,o,OBJ_STREAM)) return;
1096              s = o->ptr;
1097          }
1098          grpname = c->argv[3]->ptr;
1099      }
1100      if (c->argc >= 4 && !mkstream) {
1101          if (s == NULL) {
1102              addReplyError(c,
1103                  "The XGROUP subcommand requires the key to exist. "
1104                  "Note that for CREATE you may want to use the MKSTREAM "
1105                  "option to create an empty stream automatically.");
1106              return;
1107          }
1108          if ((cg = streamLookupCG(s,grpname)) == NULL &&
1109              (!strcasecmp(opt,"SETID") ||
1110               !strcasecmp(opt,"DELCONSUMER")))
1111          {
1112              addReplyErrorFormat(c, "-NOGROUP No such consumer group '%s' "
1113                                     "for key name '%s'",
1114                                     (char*)grpname, (char*)c->argv[2]->ptr);
1115              return;
1116          }
1117      }
1118      if (!strcasecmp(opt,"CREATE") && (c->argc == 5 || c->argc == 6)) {
1119          streamID id;
1120          if (!strcmp(c->argv[4]->ptr,"$")) {
1121              if (s) {
1122                  id = s->last_id;
1123              } else {
1124                  id.ms = 0;
1125                  id.seq = 0;
1126              }
1127          } else if (streamParseStrictIDOrReply(c,c->argv[4],&id,0) != C_OK) {
1128              return;
1129          }
1130          if (s == NULL) {
1131              serverAssert(mkstream);
1132              o = createStreamObject();
1133              dbAdd(c->db,c->argv[2],o);
1134              s = o->ptr;
1135          }
1136          streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id);
1137          if (cg) {
1138              addReply(c,shared.ok);
1139              server.dirty++;
1140              notifyKeyspaceEvent(NOTIFY_STREAM,"xgroup-create",
1141                                  c->argv[2],c->db->id);
1142          } else {
1143              addReplySds(c,
1144                  sdsnew("-BUSYGROUP Consumer Group name already exists\r\n"));
1145          }
1146      } else if (!strcasecmp(opt,"SETID") && c->argc == 5) {
1147          streamID id;
1148          if (!strcmp(c->argv[4]->ptr,"$")) {
1149              id = s->last_id;
1150          } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
1151              return;
1152          }
1153          cg->last_id = id;
1154          addReply(c,shared.ok);
1155          server.dirty++;
1156          notifyKeyspaceEvent(NOTIFY_STREAM,"xgroup-setid",c->argv[2],c->db->id);
1157      } else if (!strcasecmp(opt,"DESTROY") && c->argc == 4) {
1158          if (cg) {
1159              raxRemove(s->cgroups,(unsigned char*)grpname,sdslen(grpname),NULL);
1160              streamFreeCG(cg);
1161              addReply(c,shared.cone);
1162              server.dirty++;
1163              notifyKeyspaceEvent(NOTIFY_STREAM,"xgroup-destroy",
1164                                  c->argv[2],c->db->id);
1165          } else {
1166              addReply(c,shared.czero);
1167          }
1168      } else if (!strcasecmp(opt,"DELCONSUMER") && c->argc == 5) {
1169          PORT_LONGLONG pending = streamDelConsumer(cg,c->argv[4]->ptr);
1170          addReplyLongLong(c,pending);
1171          server.dirty++;
1172          notifyKeyspaceEvent(NOTIFY_STREAM,"xgroup-delconsumer",
1173                              c->argv[2],c->db->id);
1174      } else if (!strcasecmp(opt,"HELP")) {
1175          addReplyHelp(c, help);
1176      } else {
1177          addReplySubcommandSyntaxError(c);
1178      }
1179  }
1180  void xsetidCommand(client *c) {
1181      robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr);
1182      if (o == NULL || checkType(c,o,OBJ_STREAM)) return;
1183      stream *s = o->ptr;
1184      streamID id;
1185      if (streamParseStrictIDOrReply(c,c->argv[2],&id,0) != C_OK) return;
1186      if (s->length > 0) {
1187          streamID maxid;
1188          streamLastValidID(s,&maxid);
1189          if (streamCompareID(&id,&maxid) < 0) {
1190              addReplyError(c,"The ID specified in XSETID is smaller than the "
1191                              "target stream top item");
1192              return;
1193          }
1194      }
1195      s->last_id = id;
1196      addReply(c,shared.ok);
1197      server.dirty++;
1198      notifyKeyspaceEvent(NOTIFY_STREAM,"xsetid",c->argv[1],c->db->id);
1199  }
1200  void xackCommand(client *c) {
1201      streamCG *group = NULL;
1202      robj *o = lookupKeyRead(c->db,c->argv[1]);
1203      if (o) {
1204          if (checkType(c,o,OBJ_STREAM)) return; &bsol;* Type error. */
1205          group = streamLookupCG(o->ptr,c->argv[2]->ptr);
1206      }
1207      if (o == NULL || group == NULL) {
1208          addReply(c,shared.czero);
1209          return;
1210      }
1211      int acknowledged = 0;
1212      for (int j = 3; j < c->argc; j++) {
1213          streamID id;
1214          unsigned char buf[sizeof(streamID)];
1215          if (streamParseStrictIDOrReply(c,c->argv[j],&id,0) != C_OK) return;
1216          streamEncodeID(buf,&id);
1217          streamNACK *nack = raxFind(group->pel,buf,sizeof(buf));
1218          if (nack != raxNotFound) {
1219              raxRemove(group->pel,buf,sizeof(buf),NULL);
1220              raxRemove(nack->consumer->pel,buf,sizeof(buf),NULL);
1221              streamFreeNACK(nack);
1222              acknowledged++;
1223              server.dirty++;
1224          }
1225      }
1226      addReplyLongLong(c,acknowledged);
1227  }
1228  void xpendingCommand(client *c) {
1229      int justinfo = c->argc == 3; &bsol;* Without the range just outputs general
1230                                      informations about the PEL. */
1231      robj *key = c->argv[1];
1232      robj *groupname = c->argv[2];
1233      robj *consumername = (c->argc == 7) ? c->argv[6] : NULL;
1234      streamID startid, endid;
1235      PORT_LONGLONG count;
1236      if (c->argc != 3 && c->argc != 6 && c->argc != 7) {
1237          addReply(c,shared.syntaxerr);
1238          return;
1239      }
1240      if (c->argc >= 6) {
1241          if (getLongLongFromObjectOrReply(c,c->argv[5],&count,NULL) == C_ERR)
1242              return;
1243          if (count < 0) count = 0;
1244          if (streamParseIDOrReply(c,c->argv[3],&startid,0) == C_ERR)
1245              return;
1246          if (streamParseIDOrReply(c,c->argv[4],&endid,UINT64_MAX) == C_ERR)
1247              return;
1248      }
1249      robj *o = lookupKeyRead(c->db,c->argv[1]);
1250      streamCG *group;
1251      if (o && checkType(c,o,OBJ_STREAM)) return;
1252      if (o == NULL ||
1253          (group = streamLookupCG(o->ptr,groupname->ptr)) == NULL)
1254      {
1255          addReplyErrorFormat(c, "-NOGROUP No such key '%s' or consumer "
1256                                 "group '%s'",
1257                                 (char*)key->ptr,(char*)groupname->ptr);
1258          return;
1259      }
1260      if (justinfo) {
1261          addReplyMultiBulkLen(c,4);
1262          addReplyLongLong(c,raxSize(group->pel));
1263          if (raxSize(group->pel) == 0) {
1264              addReply(c,shared.nullbulk); &bsol;* Start. */
1265              addReply(c,shared.nullbulk); &bsol;* End. */
1266              addReply(c,shared.nullmultibulk); &bsol;* Clients. */
1267          } else {
1268              raxIterator ri;
1269              raxStart(&ri,group->pel);
1270              raxSeek(&ri,"^",NULL,0);
1271              raxNext(&ri);
1272              streamDecodeID(ri.key,&startid);
1273              addReplyStreamID(c,&startid);
1274              raxSeek(&ri,"$",NULL,0);
1275              raxNext(&ri);
1276              streamDecodeID(ri.key,&endid);
1277              addReplyStreamID(c,&endid);
1278              raxStop(&ri);
1279              raxStart(&ri,group->consumers);
1280              raxSeek(&ri,"^",NULL,0);
1281              void *arraylen_ptr = addDeferredMultiBulkLength(c);
1282              size_t arraylen = 0;
1283              while(raxNext(&ri)) {
1284                  streamConsumer *consumer = ri.data;
1285                  if (raxSize(consumer->pel) == 0) continue;
1286                  addReplyMultiBulkLen(c,2);
1287                  addReplyBulkCBuffer(c,ri.key,ri.key_len);
1288                  addReplyBulkLongLong(c,raxSize(consumer->pel));
1289                  arraylen++;
1290              }
1291              setDeferredMultiBulkLength(c,arraylen_ptr,arraylen);
1292              raxStop(&ri);
1293          }
1294      }
1295      else {
1296          streamConsumer *consumer = NULL;
1297          if (consumername) {
1298              consumer = streamLookupConsumer(group,
1299                                              consumername->ptr,
1300                                              SLC_NOCREAT|SLC_NOREFRESH);
1301              if (consumer == NULL) {
1302                  addReplyMultiBulkLen(c,0);
1303                  return;
1304              }
1305          }
1306          rax *pel = consumer ? consumer->pel : group->pel;
1307          unsigned char startkey[sizeof(streamID)];
1308          unsigned char endkey[sizeof(streamID)];
1309          raxIterator ri;
1310          mstime_t now = mstime();
1311          streamEncodeID(startkey,&startid);
1312          streamEncodeID(endkey,&endid);
1313          raxStart(&ri,pel);
1314          raxSeek(&ri,">=",startkey,sizeof(startkey));
1315          void *arraylen_ptr = addDeferredMultiBulkLength(c);
1316          size_t arraylen = 0;
1317          while(count && raxNext(&ri) && memcmp(ri.key,endkey,ri.key_len) <= 0) {
1318              streamNACK *nack = ri.data;
1319              arraylen++;
1320              count--;
1321              addReplyMultiBulkLen(c,4);
1322              streamID id;
1323              streamDecodeID(ri.key,&id);
1324              addReplyStreamID(c,&id);
1325              addReplyBulkCBuffer(c,nack->consumer->name,
1326                                  sdslen(nack->consumer->name));
1327              mstime_t elapsed = now - nack->delivery_time;
1328              if (elapsed < 0) elapsed = 0;
1329              addReplyLongLong(c,elapsed);
1330              addReplyLongLong(c,nack->delivery_count);
1331          }
1332          raxStop(&ri);
1333          setDeferredMultiBulkLength(c,arraylen_ptr,arraylen);
1334      }
1335  }
1336  void xclaimCommand(client *c) {
1337      streamCG *group = NULL;
1338      robj *o = lookupKeyRead(c->db,c->argv[1]);
1339      PORT_LONGLONG minidle; &bsol;* Minimum idle time argument. */
1340      PORT_LONGLONG retrycount = -1;   &bsol;* -1 means RETRYCOUNT option not given. */
1341      mstime_t deliverytime = -1;  &bsol;* -1 means IDLE/TIME options not given. */
1342      int force = 0;
1343      int justid = 0;
1344      if (o) {
1345          if (checkType(c,o,OBJ_STREAM)) return; &bsol;* Type error. */
1346          group = streamLookupCG(o->ptr,c->argv[2]->ptr);
1347      }
1348      if (o == NULL || group == NULL) {
1349          addReplyErrorFormat(c,"-NOGROUP No such key '%s' or "
1350                                "consumer group '%s'", (char*)c->argv[1]->ptr,
1351                                (char*)c->argv[2]->ptr);
1352          return;
1353      }
1354      if (getLongLongFromObjectOrReply(c,c->argv[4],&minidle,
1355          "Invalid min-idle-time argument for XCLAIM")
1356          != C_OK) return;
1357      if (minidle < 0) minidle = 0;
1358      int j;
1359      for (j = 5; j < c->argc; j++) {
1360          streamID id;
1361          if (streamParseStrictIDOrReply(NULL,c->argv[j],&id,0) != C_OK) break;
1362      }
1363      int last_id_arg = j-1; &bsol;* Next time we iterate the IDs we now the range. */
1364      mstime_t now = mstime();
1365      streamID last_id = {0,0};
1366      int propagate_last_id = 0;
1367      for (; j < c->argc; j++) {
1368          int moreargs = (c->argc-1) - j; &bsol;* Number of additional arguments. */
1369          char *opt = c->argv[j]->ptr;
1370          if (!strcasecmp(opt,"FORCE")) {
1371              force = 1;
1372          } else if (!strcasecmp(opt,"JUSTID")) {
1373              justid = 1;
1374          } else if (!strcasecmp(opt,"IDLE") && moreargs) {
1375              j++;
1376              if (getLongLongFromObjectOrReply(c,c->argv[j],&deliverytime,
1377                  "Invalid IDLE option argument for XCLAIM")
1378                  != C_OK) return;
1379              deliverytime = now - deliverytime;
1380          } else if (!strcasecmp(opt,"TIME") && moreargs) {
1381              j++;
1382              if (getLongLongFromObjectOrReply(c,c->argv[j],&deliverytime,
1383                  "Invalid TIME option argument for XCLAIM")
1384                  != C_OK) return;
1385          } else if (!strcasecmp(opt,"RETRYCOUNT") && moreargs) {
1386              j++;
1387              if (getLongLongFromObjectOrReply(c,c->argv[j],&retrycount,
1388                  "Invalid RETRYCOUNT option argument for XCLAIM")
1389                  != C_OK) return;
1390          } else if (!strcasecmp(opt,"LASTID") && moreargs) {
1391              j++;
1392              if (streamParseStrictIDOrReply(c,c->argv[j],&last_id,0) != C_OK) return;
1393          } else {
1394              addReplyErrorFormat(c,"Unrecognized XCLAIM option '%s'",opt);
1395              return;
1396          }
1397      }
1398      if (streamCompareID(&last_id,&group->last_id) > 0) {
1399          group->last_id = last_id;
1400          propagate_last_id = 1;
1401      }
1402      if (deliverytime != -1) {
1403          if (deliverytime < 0 || deliverytime > now) deliverytime = now;
1404      } else {
1405          deliverytime = now;
1406      }
1407      streamConsumer *consumer = NULL;
1408      void *arraylenptr = addDeferredMultiBulkLength(c);
1409      size_t arraylen = 0;
1410      for (int j = 5; j <= last_id_arg; j++) {
1411          streamID id;
1412          unsigned char buf[sizeof(streamID)];
1413          if (streamParseStrictIDOrReply(c,c->argv[j],&id,0) != C_OK)
1414              serverPanic("StreamID invalid after check. Should not be possible.");
1415          streamEncodeID(buf,&id);
1416          streamNACK *nack = raxFind(group->pel,buf,sizeof(buf));
1417          if (force && nack == raxNotFound) {
1418              streamIterator myiterator;
1419              streamIteratorStart(&myiterator,o->ptr,&id,&id,0);
1420              int64_t numfields;
1421              int found = 0;
1422              streamID item_id;
1423              if (streamIteratorGetID(&myiterator,&item_id,&numfields)) found = 1;
1424              streamIteratorStop(&myiterator);
1425              if (!found) continue;
1426              nack = streamCreateNACK(NULL);
1427              raxInsert(group->pel,buf,sizeof(buf),nack,NULL);
1428          }
1429          if (nack != raxNotFound) {
1430              if (nack->consumer && minidle) {
1431                  mstime_t this_idle = now - nack->delivery_time;
1432                  if (this_idle < minidle) continue;
1433              }
1434              if (nack->consumer)
1435                  raxRemove(nack->consumer->pel,buf,sizeof(buf),NULL);
1436              if (consumer == NULL)
1437                  consumer = streamLookupConsumer(group,c->argv[3]->ptr,SLC_NONE);
1438              nack->consumer = consumer;
1439              nack->delivery_time = deliverytime;
1440              if (retrycount >= 0) {
1441                  nack->delivery_count = retrycount;
1442              } else if (!justid) {
1443                  nack->delivery_count++;
1444              }
1445              raxInsert(consumer->pel,buf,sizeof(buf),nack,NULL);
1446              if (justid) {
1447                  addReplyStreamID(c,&id);
1448              } else {
1449                  size_t emitted = streamReplyWithRange(c,o->ptr,&id,&id,1,0,
1450                                      NULL,NULL,STREAM_RWR_RAWENTRIES,NULL);
1451                  if (!emitted) addReply(c,shared.nullbulk);
1452              }
1453              arraylen++;
1454              streamPropagateXCLAIM(c,c->argv[1],group,c->argv[2],c->argv[j],nack);
1455              propagate_last_id = 0; &bsol;* Will be propagated by XCLAIM itself. */
1456              server.dirty++;
1457          }
1458      }
1459      if (propagate_last_id) {
1460          streamPropagateGroupID(c,c->argv[1],group,c->argv[2]);
1461          server.dirty++;
1462      }
1463      setDeferredMultiBulkLength(c,arraylenptr,arraylen);
1464      preventCommandPropagation(c);
1465  }
1466  void xdelCommand(client *c) {
1467      robj *o;
1468      if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL
1469          || checkType(c,o,OBJ_STREAM)) return;
1470      stream *s = o->ptr;
1471      streamID id;
1472      for (int j = 2; j < c->argc; j++) {
1473          if (streamParseStrictIDOrReply(c,c->argv[j],&id,0) != C_OK) return;
1474      }
1475      int deleted = 0;
1476      for (int j = 2; j < c->argc; j++) {
1477          streamParseStrictIDOrReply(c,c->argv[j],&id,0); &bsol;* Retval already checked. */
1478          deleted += streamDeleteItem(s,&id);
1479      }
1480      if (deleted) {
1481          signalModifiedKey(c->db,c->argv[1]);
1482          notifyKeyspaceEvent(NOTIFY_STREAM,"xdel",c->argv[1],c->db->id);
1483          server.dirty += deleted;
1484      }
1485      addReplyLongLong(c,deleted);
1486  }
1487  #define TRIM_STRATEGY_NONE 0
1488  #define TRIM_STRATEGY_MAXLEN 1
1489  void xtrimCommand(client *c) {
1490      robj *o;
1491      if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL
1492          || checkType(c,o,OBJ_STREAM)) return;
1493      stream *s = o->ptr;
1494      int trim_strategy = TRIM_STRATEGY_NONE;
1495      PORT_LONGLONG maxlen = -1;  &bsol;* If left to -1 no trimming is performed. */
1496      int approx_maxlen = 0;  &bsol;* If 1 only delete whole radix tree nodes, so
1497                                 the maxium length is not applied verbatim. */
1498      int maxlen_arg_idx = 0; &bsol;* Index of the count in MAXLEN, for rewriting. */
1499      int i = 2; &bsol;* Start of options. */
1500      for (; i < c->argc; i++) {
1501          int moreargs = (c->argc-1) - i; &bsol;* Number of additional arguments. */
1502          char *opt = c->argv[i]->ptr;
1503          if (!strcasecmp(opt,"maxlen") && moreargs) {
1504              approx_maxlen = 0;
1505              trim_strategy = TRIM_STRATEGY_MAXLEN;
1506              char *next = c->argv[i+1]->ptr;
1507              if (moreargs >= 2 && next[0] == '~' && next[1] == '\0') {
1508                  approx_maxlen = 1;
1509                  i++;
1510              } else if (moreargs >= 2 && next[0] == '=' && next[1] == '\0') {
1511                  i++;
1512              }
1513              if (getLongLongFromObjectOrReply(c,c->argv[i+1],&maxlen,NULL)
1514                  != C_OK) return;
1515              if (maxlen < 0) {
1516                  addReplyError(c,"The MAXLEN argument must be >= 0.");
1517                  return;
1518              }
1519              i++;
1520              maxlen_arg_idx = i;
1521          } else {
1522              addReply(c,shared.syntaxerr);
1523              return;
1524          }
1525      }
1526      int64_t deleted = 0;
1527      if (trim_strategy == TRIM_STRATEGY_MAXLEN) {
1528          deleted = streamTrimByLength(s,maxlen,approx_maxlen);
1529      } else {
1530          addReplyError(c,"XTRIM called without an option to trim the stream");
1531          return;
1532      }
1533      if (deleted) {
1534          signalModifiedKey(c->db,c->argv[1]);
1535          notifyKeyspaceEvent(NOTIFY_STREAM,"xtrim",c->argv[1],c->db->id);
1536          server.dirty += deleted;
1537          if (approx_maxlen) streamRewriteApproxMaxlen(c,s,maxlen_arg_idx);
1538      }
1539      addReplyLongLong(c,deleted);
1540  }
1541  void xinfoCommand(client *c) {
1542      const char *help[] = {
1543  "CONSUMERS <key> <groupname>  -- Show consumer groups of group <groupname>.",
1544  "GROUPS <key>                 -- Show the stream consumer groups.",
1545  "STREAM <key>                 -- Show information about the stream.",
1546  "HELP                         -- Print this help.",
1547  NULL
1548      };
1549      stream *s = NULL;
1550      char *opt;
1551      robj *key;
1552      if (!strcasecmp(c->argv[1]->ptr,"HELP")) {
1553          addReplyHelp(c, help);
1554          return;
1555      } else if (c->argc < 3) {
1556          addReplyError(c,"syntax error, try 'XINFO HELP'");
1557          return;
1558      }
1559      opt = c->argv[1]->ptr;
1560      key = c->argv[2];
1561      robj *o = lookupKeyWriteOrReply(c,key,shared.nokeyerr);
1562      if (o == NULL || checkType(c,o,OBJ_STREAM)) return;
1563      s = o->ptr;
1564      if (!strcasecmp(opt,"CONSUMERS") && c->argc == 4) {
1565          streamCG *cg = streamLookupCG(s,c->argv[3]->ptr);
1566          if (cg == NULL) {
1567              addReplyErrorFormat(c, "-NOGROUP No such consumer group '%s' "
1568                                     "for key name '%s'",
1569                                     (char*)c->argv[3]->ptr, (char*)key->ptr);
1570              return;
1571          }
1572          addReplyMultiBulkLen(c,raxSize(cg->consumers));
1573          raxIterator ri;
1574          raxStart(&ri,cg->consumers);
1575          raxSeek(&ri,"^",NULL,0);
1576          mstime_t now = mstime();
1577          while(raxNext(&ri)) {
1578              streamConsumer *consumer = ri.data;
1579              mstime_t idle = now - consumer->seen_time;
1580              if (idle < 0) idle = 0;
1581              addReplyMultiBulkLen(c,6);
1582              addReplyBulkCString(c,"name");
1583              addReplyBulkCBuffer(c,consumer->name,sdslen(consumer->name));
1584              addReplyBulkCString(c,"pending");
1585              addReplyLongLong(c,raxSize(consumer->pel));
1586              addReplyBulkCString(c,"idle");
1587              addReplyLongLong(c,idle);
1588          }
1589          raxStop(&ri);
1590      } else if (!strcasecmp(opt,"GROUPS") && c->argc == 3) {
1591          if (s->cgroups == NULL) {
1592              addReplyMultiBulkLen(c,0);
1593              return;
1594          }
1595          addReplyMultiBulkLen(c,raxSize(s->cgroups));
1596          raxIterator ri;
1597          raxStart(&ri,s->cgroups);
1598          raxSeek(&ri,"^",NULL,0);
1599          while(raxNext(&ri)) {
1600              streamCG *cg = ri.data;
1601              addReplyMultiBulkLen(c,8);
1602              addReplyBulkCString(c,"name");
1603              addReplyBulkCBuffer(c,ri.key,ri.key_len);
1604              addReplyBulkCString(c,"consumers");
1605              addReplyLongLong(c,raxSize(cg->consumers));
1606              addReplyBulkCString(c,"pending");
1607              addReplyLongLong(c,raxSize(cg->pel));
1608              addReplyBulkCString(c,"last-delivered-id");
1609              addReplyStreamID(c,&cg->last_id);
1610          }
1611          raxStop(&ri);
1612      } else if (!strcasecmp(opt,"STREAM") && c->argc == 3) {
1613          addReplyMultiBulkLen(c,14);
1614          addReplyBulkCString(c,"length");
1615          addReplyLongLong(c,s->length);
1616          addReplyBulkCString(c,"radix-tree-keys");
1617          addReplyLongLong(c,raxSize(s->rax));
1618          addReplyBulkCString(c,"radix-tree-nodes");
1619          addReplyLongLong(c,s->rax->numnodes);
1620          addReplyBulkCString(c,"groups");
1621          addReplyLongLong(c,s->cgroups ? raxSize(s->cgroups) : 0);
1622          addReplyBulkCString(c,"last-generated-id");
1623          addReplyStreamID(c,&s->last_id);
1624          int count;
1625          streamID start, end;
1626          start.ms = start.seq = 0;
1627          end.ms = end.seq = UINT64_MAX;
1628          addReplyBulkCString(c,"first-entry");
1629          count = streamReplyWithRange(c,s,&start,&end,1,0,NULL,NULL,
1630                                       STREAM_RWR_RAWENTRIES,NULL);
1631          if (!count) addReply(c,shared.nullbulk);
1632          addReplyBulkCString(c,"last-entry");
1633          count = streamReplyWithRange(c,s,&start,&end,1,1,NULL,NULL,
1634                                       STREAM_RWR_RAWENTRIES,NULL);
1635          if (!count) addReply(c,shared.nullbulk);
1636      } else {
1637          addReplySubcommandSyntaxError(c);
1638      }
1639  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vp8l_dec.c</h3>
            <pre><code>1  #include <stdlib.h>
2  #include "src/dec/alphai_dec.h"
3  #include "src/dec/vp8li_dec.h"
4  #include "src/dsp/dsp.h"
5  #include "src/dsp/lossless.h"
6  #include "src/dsp/lossless_common.h"
7  #include "src/dsp/yuv.h"
8  #include "src/utils/endian_inl_utils.h"
9  #include "src/utils/huffman_utils.h"
10  #include "src/utils/utils.h"
11  #define NUM_ARGB_CACHE_ROWS          16
12  static const int kCodeLengthLiterals = 16;
13  static const int kCodeLengthRepeatCode = 16;
14  static const uint8_t kCodeLengthExtraBits[3] = { 2, 3, 7 };
15  static const uint8_t kCodeLengthRepeatOffsets[3] = { 3, 3, 11 };
16  typedef enum {
17    GREEN = 0,
18    RED   = 1,
19    BLUE  = 2,
20    ALPHA = 3,
21    DIST  = 4
22  } HuffIndex;
23  static const uint16_t kAlphabetSize[HUFFMAN_CODES_PER_META_CODE] = {
24    NUM_LITERAL_CODES + NUM_LENGTH_CODES,
25    NUM_LITERAL_CODES, NUM_LITERAL_CODES, NUM_LITERAL_CODES,
26    NUM_DISTANCE_CODES
27  };
28  static const uint8_t kLiteralMap[HUFFMAN_CODES_PER_META_CODE] = {
29    0, 1, 1, 1, 0
30  };
31  #define NUM_CODE_LENGTH_CODES       19
32  static const uint8_t kCodeLengthCodeOrder[NUM_CODE_LENGTH_CODES] = {
33    17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
34  };
35  #define CODE_TO_PLANE_CODES        120
36  static const uint8_t kCodeToPlane[CODE_TO_PLANE_CODES] = {
37    0x18, 0x07, 0x17, 0x19, 0x28, 0x06, 0x27, 0x29, 0x16, 0x1a,
38    0x26, 0x2a, 0x38, 0x05, 0x37, 0x39, 0x15, 0x1b, 0x36, 0x3a,
39    0x25, 0x2b, 0x48, 0x04, 0x47, 0x49, 0x14, 0x1c, 0x35, 0x3b,
40    0x46, 0x4a, 0x24, 0x2c, 0x58, 0x45, 0x4b, 0x34, 0x3c, 0x03,
41    0x57, 0x59, 0x13, 0x1d, 0x56, 0x5a, 0x23, 0x2d, 0x44, 0x4c,
42    0x55, 0x5b, 0x33, 0x3d, 0x68, 0x02, 0x67, 0x69, 0x12, 0x1e,
43    0x66, 0x6a, 0x22, 0x2e, 0x54, 0x5c, 0x43, 0x4d, 0x65, 0x6b,
44    0x32, 0x3e, 0x78, 0x01, 0x77, 0x79, 0x53, 0x5d, 0x11, 0x1f,
45    0x64, 0x6c, 0x42, 0x4e, 0x76, 0x7a, 0x21, 0x2f, 0x75, 0x7b,
46    0x31, 0x3f, 0x63, 0x6d, 0x52, 0x5e, 0x00, 0x74, 0x7c, 0x41,
47    0x4f, 0x10, 0x20, 0x62, 0x6e, 0x30, 0x73, 0x7d, 0x51, 0x5f,
48    0x40, 0x72, 0x7e, 0x61, 0x6f, 0x50, 0x71, 0x7f, 0x60, 0x70
49  };
50  #define FIXED_TABLE_SIZE (630 * 3 + 410)
51  static const uint16_t kTableSize[12] = {
52    FIXED_TABLE_SIZE + 654,
53    FIXED_TABLE_SIZE + 656,
54    FIXED_TABLE_SIZE + 658,
55    FIXED_TABLE_SIZE + 662,
56    FIXED_TABLE_SIZE + 670,
57    FIXED_TABLE_SIZE + 686,
58    FIXED_TABLE_SIZE + 718,
59    FIXED_TABLE_SIZE + 782,
60    FIXED_TABLE_SIZE + 912,
61    FIXED_TABLE_SIZE + 1168,
62    FIXED_TABLE_SIZE + 1680,
63    FIXED_TABLE_SIZE + 2704
64  };
65  static int DecodeImageStream(int xsize, int ysize,
66                               int is_level0,
67                               VP8LDecoder* const dec,
68                               uint32_t** const decoded_data);
69  int VP8LCheckSignature(const uint8_t* const data, size_t size) {
70    return (size >= VP8L_FRAME_HEADER_SIZE &&
71            data[0] == VP8L_MAGIC_BYTE &&
72            (data[4] >> 5) == 0);  
73  }
74  static int ReadImageInfo(VP8LBitReader* const br,
75                           int* const width, int* const height,
76                           int* const has_alpha) {
77    if (VP8LReadBits(br, 8) != VP8L_MAGIC_BYTE) return 0;
78    *width = VP8LReadBits(br, VP8L_IMAGE_SIZE_BITS) + 1;
79    *height = VP8LReadBits(br, VP8L_IMAGE_SIZE_BITS) + 1;
80    *has_alpha = VP8LReadBits(br, 1);
81    if (VP8LReadBits(br, VP8L_VERSION_BITS) != 0) return 0;
82    return !br->eos_;
83  }
84  int VP8LGetInfo(const uint8_t* data, size_t data_size,
85                  int* const width, int* const height, int* const has_alpha) {
86    if (data == NULL || data_size < VP8L_FRAME_HEADER_SIZE) {
87      return 0;         
88    } else if (!VP8LCheckSignature(data, data_size)) {
89      return 0;         
90    } else {
91      int w, h, a;
92      VP8LBitReader br;
93      VP8LInitBitReader(&br, data, data_size);
94      if (!ReadImageInfo(&br, &w, &h, &a)) {
95        return 0;
96      }
97      if (width != NULL) *width = w;
98      if (height != NULL) *height = h;
99      if (has_alpha != NULL) *has_alpha = a;
100      return 1;
101    }
102  }
103  static WEBP_INLINE int GetCopyDistance(int distance_symbol,
104                                         VP8LBitReader* const br) {
105    int extra_bits, offset;
106    if (distance_symbol < 4) {
107      return distance_symbol + 1;
108    }
109    extra_bits = (distance_symbol - 2) >> 1;
110    offset = (2 + (distance_symbol & 1)) << extra_bits;
111    return offset + VP8LReadBits(br, extra_bits) + 1;
112  }
113  static WEBP_INLINE int GetCopyLength(int length_symbol,
114                                       VP8LBitReader* const br) {
115    return GetCopyDistance(length_symbol, br);
116  }
117  static WEBP_INLINE int PlaneCodeToDistance(int xsize, int plane_code) {
118    if (plane_code > CODE_TO_PLANE_CODES) {
119      return plane_code - CODE_TO_PLANE_CODES;
120    } else {
121      const int dist_code = kCodeToPlane[plane_code - 1];
122      const int yoffset = dist_code >> 4;
123      const int xoffset = 8 - (dist_code & 0xf);
124      const int dist = yoffset * xsize + xoffset;
125      return (dist >= 1) ? dist : 1;  
126    }
127  }
128  static WEBP_INLINE int ReadSymbol(const HuffmanCode* table,
129                                    VP8LBitReader* const br) {
130    int nbits;
131    uint32_t val = VP8LPrefetchBits(br);
132    table += val & HUFFMAN_TABLE_MASK;
133    nbits = table->bits - HUFFMAN_TABLE_BITS;
134    if (nbits > 0) {
135      VP8LSetBitPos(br, br->bit_pos_ + HUFFMAN_TABLE_BITS);
136      val = VP8LPrefetchBits(br);
137      table += table->value;
138      table += val & ((1 << nbits) - 1);
139    }
140    VP8LSetBitPos(br, br->bit_pos_ + table->bits);
141    return table->value;
142  }
143  #define BITS_SPECIAL_MARKER 0x100  
144  #define PACKED_NON_LITERAL_CODE 0  
145  static WEBP_INLINE int ReadPackedSymbols(const HTreeGroup* group,
146                                           VP8LBitReader* const br,
147                                           uint32_t* const dst) {
148    const uint32_t val = VP8LPrefetchBits(br) & (HUFFMAN_PACKED_TABLE_SIZE - 1);
149    const HuffmanCode32 code = group->packed_table[val];
150    assert(group->use_packed_table);
151    if (code.bits < BITS_SPECIAL_MARKER) {
152      VP8LSetBitPos(br, br->bit_pos_ + code.bits);
153      *dst = code.value;
154      return PACKED_NON_LITERAL_CODE;
155    } else {
156      VP8LSetBitPos(br, br->bit_pos_ + code.bits - BITS_SPECIAL_MARKER);
157      assert(code.value >= NUM_LITERAL_CODES);
158      return code.value;
159    }
160  }
161  static int AccumulateHCode(HuffmanCode hcode, int shift,
162                             HuffmanCode32* const huff) {
163    huff->bits += hcode.bits;
164    huff->value |= (uint32_t)hcode.value << shift;
165    assert(huff->bits <= HUFFMAN_TABLE_BITS);
166    return hcode.bits;
167  }
168  static void BuildPackedTable(HTreeGroup* const htree_group) {
169    uint32_t code;
170    for (code = 0; code < HUFFMAN_PACKED_TABLE_SIZE; ++code) {
171      uint32_t bits = code;
172      HuffmanCode32* const huff = &htree_group->packed_table[bits];
173      HuffmanCode hcode = htree_group->htrees[GREEN][bits];
174      if (hcode.value >= NUM_LITERAL_CODES) {
175        huff->bits = hcode.bits + BITS_SPECIAL_MARKER;
176        huff->value = hcode.value;
177      } else {
178        huff->bits = 0;
179        huff->value = 0;
180        bits >>= AccumulateHCode(hcode, 8, huff);
181        bits >>= AccumulateHCode(htree_group->htrees[RED][bits], 16, huff);
182        bits >>= AccumulateHCode(htree_group->htrees[BLUE][bits], 0, huff);
183        bits >>= AccumulateHCode(htree_group->htrees[ALPHA][bits], 24, huff);
184        (void)bits;
185      }
186    }
187  }
188  static int ReadHuffmanCodeLengths(
189      VP8LDecoder* const dec, const int* const code_length_code_lengths,
190      int num_symbols, int* const code_lengths) {
191    int ok = 0;
192    VP8LBitReader* const br = &dec->br_;
193    int symbol;
194    int max_symbol;
195    int prev_code_len = DEFAULT_CODE_LENGTH;
196    HuffmanCode table[1 << LENGTHS_TABLE_BITS];
197    if (!VP8LBuildHuffmanTable(table, LENGTHS_TABLE_BITS,
198                               code_length_code_lengths,
199                               NUM_CODE_LENGTH_CODES)) {
200      goto End;
201    }
202    if (VP8LReadBits(br, 1)) {    
203      const int length_nbits = 2 + 2 * VP8LReadBits(br, 3);
204      max_symbol = 2 + VP8LReadBits(br, length_nbits);
205      if (max_symbol > num_symbols) {
206        goto End;
207      }
208    } else {
209      max_symbol = num_symbols;
210    }
211    symbol = 0;
212    while (symbol < num_symbols) {
213      const HuffmanCode* p;
214      int code_len;
215      if (max_symbol-- == 0) break;
216      VP8LFillBitWindow(br);
217      p = &table[VP8LPrefetchBits(br) & LENGTHS_TABLE_MASK];
218      VP8LSetBitPos(br, br->bit_pos_ + p->bits);
219      code_len = p->value;
220      if (code_len < kCodeLengthLiterals) {
221        code_lengths[symbol++] = code_len;
222        if (code_len != 0) prev_code_len = code_len;
223      } else {
224        const int use_prev = (code_len == kCodeLengthRepeatCode);
225        const int slot = code_len - kCodeLengthLiterals;
226        const int extra_bits = kCodeLengthExtraBits[slot];
227        const int repeat_offset = kCodeLengthRepeatOffsets[slot];
228        int repeat = VP8LReadBits(br, extra_bits) + repeat_offset;
229        if (symbol + repeat > num_symbols) {
230          goto End;
231        } else {
232          const int length = use_prev ? prev_code_len : 0;
233          while (repeat-- > 0) code_lengths[symbol++] = length;
234        }
235      }
236    }
237    ok = 1;
238   End:
239    if (!ok) dec->status_ = VP8_STATUS_BITSTREAM_ERROR;
240    return ok;
241  }
242  static int ReadHuffmanCode(int alphabet_size, VP8LDecoder* const dec,
243                             int* const code_lengths, HuffmanCode* const table) {
244    int ok = 0;
245    int size = 0;
246    VP8LBitReader* const br = &dec->br_;
247    const int simple_code = VP8LReadBits(br, 1);
248    memset(code_lengths, 0, alphabet_size * sizeof(*code_lengths));
249    if (simple_code) {  
250      const int num_symbols = VP8LReadBits(br, 1) + 1;
251      const int first_symbol_len_code = VP8LReadBits(br, 1);
252      int symbol = VP8LReadBits(br, (first_symbol_len_code == 0) ? 1 : 8);
253      code_lengths[symbol] = 1;
254      if (num_symbols == 2) {
255        symbol = VP8LReadBits(br, 8);
256        code_lengths[symbol] = 1;
257      }
258      ok = 1;
259    } else {  
260      int i;
261      int code_length_code_lengths[NUM_CODE_LENGTH_CODES] = { 0 };
262      const int num_codes = VP8LReadBits(br, 4) + 4;
263      if (num_codes > NUM_CODE_LENGTH_CODES) {
264        dec->status_ = VP8_STATUS_BITSTREAM_ERROR;
265        return 0;
266      }
267      for (i = 0; i < num_codes; ++i) {
268        code_length_code_lengths[kCodeLengthCodeOrder[i]] = VP8LReadBits(br, 3);
269      }
270      ok = ReadHuffmanCodeLengths(dec, code_length_code_lengths, alphabet_size,
271                                  code_lengths);
272    }
273    ok = ok && !br->eos_;
274    if (ok) {
275      size = VP8LBuildHuffmanTable(table, HUFFMAN_TABLE_BITS,
276                                   code_lengths, alphabet_size);
277    }
278    if (!ok || size == 0) {
279      dec->status_ = VP8_STATUS_BITSTREAM_ERROR;
280      return 0;
281    }
282    return size;
283  }
284  static int ReadHuffmanCodes(VP8LDecoder* const dec, int xsize, int ysize,
285                              int color_cache_bits, int allow_recursion) {
286    int i, j;
287    VP8LBitReader* const br = &dec->br_;
288    VP8LMetadata* const hdr = &dec->hdr_;
289    uint32_t* huffman_image = NULL;
290    HTreeGroup* htree_groups = NULL;
291    HuffmanCode* huffman_tables = NULL;
292    HuffmanCode* huffman_table = NULL;
293    int num_htree_groups = 1;
294    int num_htree_groups_max = 1;
295    int max_alphabet_size = 0;
296    int* code_lengths = NULL;
297    const int table_size = kTableSize[color_cache_bits];
298    int* mapping = NULL;
299    int ok = 0;
300    if (allow_recursion && VP8LReadBits(br, 1)) {
301      const int huffman_precision = VP8LReadBits(br, 3) + 2;
302      const int huffman_xsize = VP8LSubSampleSize(xsize, huffman_precision);
303      const int huffman_ysize = VP8LSubSampleSize(ysize, huffman_precision);
304      const int huffman_pixs = huffman_xsize * huffman_ysize;
305      if (!DecodeImageStream(huffman_xsize, huffman_ysize, 0, dec,
306                             &huffman_image)) {
307        goto Error;
308      }
309      hdr->huffman_subsample_bits_ = huffman_precision;
310      for (i = 0; i < huffman_pixs; ++i) {
311        const int group = (huffman_image[i] >> 8) & 0xffff;
312        huffman_image[i] = group;
313        if (group >= num_htree_groups_max) {
314          num_htree_groups_max = group + 1;
315        }
316      }
317      if (num_htree_groups_max > 1000 || num_htree_groups_max > xsize * ysize) {
318        mapping = (int*)WebPSafeMalloc(num_htree_groups_max, sizeof(*mapping));
319        if (mapping == NULL) {
320          dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
321          goto Error;
322        }
323        memset(mapping, 0xff, num_htree_groups_max * sizeof(*mapping));
324        for (num_htree_groups = 0, i = 0; i < huffman_pixs; ++i) {
325          int* const mapped_group = &mapping[huffman_image[i]];
<span onclick='openModal()' class='match'>326          if (*mapped_group == -1) *mapped_group = num_htree_groups++;
327          huffman_image[i] = *mapped_group;
328        }
329      } else {
330        num_htree_groups = num_htree_groups_max;
331      }
332    }
</span>333    if (br->eos_) goto Error;
334    for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; ++j) {
335      int alphabet_size = kAlphabetSize[j];
336      if (j == 0 && color_cache_bits > 0) {
337        alphabet_size += 1 << color_cache_bits;
338      }
339      if (max_alphabet_size < alphabet_size) {
340        max_alphabet_size = alphabet_size;
341      }
342    }
343    code_lengths = (int*)WebPSafeCalloc((uint64_t)max_alphabet_size,
344                                        sizeof(*code_lengths));
345    huffman_tables = (HuffmanCode*)WebPSafeMalloc(num_htree_groups * table_size,
346                                                  sizeof(*huffman_tables));
347    htree_groups = VP8LHtreeGroupsNew(num_htree_groups);
348    if (htree_groups == NULL || code_lengths == NULL || huffman_tables == NULL) {
349      dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
350      goto Error;
351    }
352    huffman_table = huffman_tables;
353    for (i = 0; i < num_htree_groups_max; ++i) {
354      if (mapping != NULL && mapping[i] == -1) {
355        for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; ++j) {
356          int alphabet_size = kAlphabetSize[j];
357          if (j == 0 && color_cache_bits > 0) {
358            alphabet_size += (1 << color_cache_bits);
359          }
360          if (!ReadHuffmanCode(alphabet_size, dec, code_lengths, NULL)) {
361            goto Error;
362          }
363        }
364      } else {
365        HTreeGroup* const htree_group =
366            &htree_groups[(mapping == NULL) ? i : mapping[i]];
367        HuffmanCode** const htrees = htree_group->htrees;
368        int size;
369        int total_size = 0;
370        int is_trivial_literal = 1;
371        int max_bits = 0;
372        for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; ++j) {
373          int alphabet_size = kAlphabetSize[j];
374          htrees[j] = huffman_table;
375          if (j == 0 && color_cache_bits > 0) {
376            alphabet_size += (1 << color_cache_bits);
377          }
378          size = ReadHuffmanCode(alphabet_size, dec, code_lengths, huffman_table);
379          if (size == 0) {
380            goto Error;
381          }
382          if (is_trivial_literal && kLiteralMap[j] == 1) {
383            is_trivial_literal = (huffman_table->bits == 0);
384          }
385          total_size += huffman_table->bits;
386          huffman_table += size;
387          if (j <= ALPHA) {
388            int local_max_bits = code_lengths[0];
389            int k;
390            for (k = 1; k < alphabet_size; ++k) {
391              if (code_lengths[k] > local_max_bits) {
392                local_max_bits = code_lengths[k];
393              }
394            }
395            max_bits += local_max_bits;
396          }
397        }
398        htree_group->is_trivial_literal = is_trivial_literal;
399        htree_group->is_trivial_code = 0;
400        if (is_trivial_literal) {
401          const int red = htrees[RED][0].value;
402          const int blue = htrees[BLUE][0].value;
403          const int alpha = htrees[ALPHA][0].value;
404          htree_group->literal_arb = ((uint32_t)alpha << 24) | (red << 16) | blue;
405          if (total_size == 0 && htrees[GREEN][0].value < NUM_LITERAL_CODES) {
406            htree_group->is_trivial_code = 1;
407            htree_group->literal_arb |= htrees[GREEN][0].value << 8;
408          }
409        }
410        htree_group->use_packed_table =
411            !htree_group->is_trivial_code && (max_bits < HUFFMAN_PACKED_BITS);
412        if (htree_group->use_packed_table) BuildPackedTable(htree_group);
413      }
414    }
415    ok = 1;
416    hdr->huffman_image_ = huffman_image;
417    hdr->num_htree_groups_ = num_htree_groups;
418    hdr->htree_groups_ = htree_groups;
419    hdr->huffman_tables_ = huffman_tables;
420   Error:
421    WebPSafeFree(code_lengths);
422    WebPSafeFree(mapping);
423    if (!ok) {
424      WebPSafeFree(huffman_image);
425      WebPSafeFree(huffman_tables);
426      VP8LHtreeGroupsFree(htree_groups);
427    }
428    return ok;
429  }
430  #if !defined(WEBP_REDUCE_SIZE)
431  static int AllocateAndInitRescaler(VP8LDecoder* const dec, VP8Io* const io) {
432    const int num_channels = 4;
433    const int in_width = io->mb_w;
434    const int out_width = io->scaled_width;
435    const int in_height = io->mb_h;
436    const int out_height = io->scaled_height;
437    const uint64_t work_size = 2 * num_channels * (uint64_t)out_width;
438    rescaler_t* work;        
439    const uint64_t scaled_data_size = (uint64_t)out_width;
440    uint32_t* scaled_data;  
441    const uint64_t memory_size = sizeof(*dec->rescaler) +
442                                 work_size * sizeof(*work) +
443                                 scaled_data_size * sizeof(*scaled_data);
444    uint8_t* memory = (uint8_t*)WebPSafeMalloc(memory_size, sizeof(*memory));
445    if (memory == NULL) {
446      dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
447      return 0;
448    }
449    assert(dec->rescaler_memory == NULL);
450    dec->rescaler_memory = memory;
451    dec->rescaler = (WebPRescaler*)memory;
452    memory += sizeof(*dec->rescaler);
453    work = (rescaler_t*)memory;
454    memory += work_size * sizeof(*work);
455    scaled_data = (uint32_t*)memory;
456    WebPRescalerInit(dec->rescaler, in_width, in_height, (uint8_t*)scaled_data,
457                     out_width, out_height, 0, num_channels, work);
458    return 1;
459  }
460  #endif   
461  #if !defined(WEBP_REDUCE_SIZE)
462  static int Export(WebPRescaler* const rescaler, WEBP_CSP_MODE colorspace,
463                    int rgba_stride, uint8_t* const rgba) {
464    uint32_t* const src = (uint32_t*)rescaler->dst;
465    const int dst_width = rescaler->dst_width;
466    int num_lines_out = 0;
467    while (WebPRescalerHasPendingOutput(rescaler)) {
468      uint8_t* const dst = rgba + num_lines_out * rgba_stride;
469      WebPRescalerExportRow(rescaler);
470      WebPMultARGBRow(src, dst_width, 1);
471      VP8LConvertFromBGRA(src, dst_width, colorspace, dst);
472      ++num_lines_out;
473    }
474    return num_lines_out;
475  }
476  static int EmitRescaledRowsRGBA(const VP8LDecoder* const dec,
477                                  uint8_t* in, int in_stride, int mb_h,
478                                  uint8_t* const out, int out_stride) {
479    const WEBP_CSP_MODE colorspace = dec->output_->colorspace;
480    int num_lines_in = 0;
481    int num_lines_out = 0;
482    while (num_lines_in < mb_h) {
483      uint8_t* const row_in = in + num_lines_in * in_stride;
484      uint8_t* const row_out = out + num_lines_out * out_stride;
485      const int lines_left = mb_h - num_lines_in;
486      const int needed_lines = WebPRescaleNeededLines(dec->rescaler, lines_left);
487      int lines_imported;
488      assert(needed_lines > 0 && needed_lines <= lines_left);
489      WebPMultARGBRows(row_in, in_stride,
490                       dec->rescaler->src_width, needed_lines, 0);
491      lines_imported =
492          WebPRescalerImport(dec->rescaler, lines_left, row_in, in_stride);
493      assert(lines_imported == needed_lines);
494      num_lines_in += lines_imported;
495      num_lines_out += Export(dec->rescaler, colorspace, out_stride, row_out);
496    }
497    return num_lines_out;
498  }
499  #endif   
500  static int EmitRows(WEBP_CSP_MODE colorspace,
501                      const uint8_t* row_in, int in_stride,
502                      int mb_w, int mb_h,
503                      uint8_t* const out, int out_stride) {
504    int lines = mb_h;
505    uint8_t* row_out = out;
506    while (lines-- > 0) {
507      VP8LConvertFromBGRA((const uint32_t*)row_in, mb_w, colorspace, row_out);
508      row_in += in_stride;
509      row_out += out_stride;
510    }
511    return mb_h;  
512  }
513  static void ConvertToYUVA(const uint32_t* const src, int width, int y_pos,
514                            const WebPDecBuffer* const output) {
515    const WebPYUVABuffer* const buf = &output->u.YUVA;
516    WebPConvertARGBToY(src, buf->y + y_pos * buf->y_stride, width);
517    {
518      uint8_t* const u = buf->u + (y_pos >> 1) * buf->u_stride;
519      uint8_t* const v = buf->v + (y_pos >> 1) * buf->v_stride;
520      WebPConvertARGBToUV(src, u, v, width, !(y_pos & 1));
521    }
522    if (buf->a != NULL) {
523      uint8_t* const a = buf->a + y_pos * buf->a_stride;
524  #if defined(WORDS_BIGENDIAN)
525      WebPExtractAlpha((uint8_t*)src + 0, 0, width, 1, a, 0);
526  #else
527      WebPExtractAlpha((uint8_t*)src + 3, 0, width, 1, a, 0);
528  #endif
529    }
530  }
531  static int ExportYUVA(const VP8LDecoder* const dec, int y_pos) {
532    WebPRescaler* const rescaler = dec->rescaler;
533    uint32_t* const src = (uint32_t*)rescaler->dst;
534    const int dst_width = rescaler->dst_width;
535    int num_lines_out = 0;
536    while (WebPRescalerHasPendingOutput(rescaler)) {
537      WebPRescalerExportRow(rescaler);
538      WebPMultARGBRow(src, dst_width, 1);
539      ConvertToYUVA(src, dst_width, y_pos, dec->output_);
540      ++y_pos;
541      ++num_lines_out;
542    }
543    return num_lines_out;
544  }
545  static int EmitRescaledRowsYUVA(const VP8LDecoder* const dec,
546                                  uint8_t* in, int in_stride, int mb_h) {
547    int num_lines_in = 0;
548    int y_pos = dec->last_out_row_;
549    while (num_lines_in < mb_h) {
550      const int lines_left = mb_h - num_lines_in;
551      const int needed_lines = WebPRescaleNeededLines(dec->rescaler, lines_left);
552      int lines_imported;
553      WebPMultARGBRows(in, in_stride, dec->rescaler->src_width, needed_lines, 0);
554      lines_imported =
555          WebPRescalerImport(dec->rescaler, lines_left, in, in_stride);
556      assert(lines_imported == needed_lines);
557      num_lines_in += lines_imported;
558      in += needed_lines * in_stride;
559      y_pos += ExportYUVA(dec, y_pos);
560    }
561    return y_pos;
562  }
563  static int EmitRowsYUVA(const VP8LDecoder* const dec,
564                          const uint8_t* in, int in_stride,
565                          int mb_w, int num_rows) {
566    int y_pos = dec->last_out_row_;
567    while (num_rows-- > 0) {
568      ConvertToYUVA((const uint32_t*)in, mb_w, y_pos, dec->output_);
569      in += in_stride;
570      ++y_pos;
571    }
572    return y_pos;
573  }
574  static int SetCropWindow(VP8Io* const io, int y_start, int y_end,
575                           uint8_t** const in_data, int pixel_stride) {
576    assert(y_start < y_end);
577    assert(io->crop_left < io->crop_right);
578    if (y_end > io->crop_bottom) {
579      y_end = io->crop_bottom;  
580    }
581    if (y_start < io->crop_top) {
582      const int delta = io->crop_top - y_start;
583      y_start = io->crop_top;
584      *in_data += delta * pixel_stride;
585    }
586    if (y_start >= y_end) return 0;  
587    *in_data += io->crop_left * sizeof(uint32_t);
588    io->mb_y = y_start - io->crop_top;
589    io->mb_w = io->crop_right - io->crop_left;
590    io->mb_h = y_end - y_start;
591    return 1;  
592  }
593  static WEBP_INLINE int GetMetaIndex(
594      const uint32_t* const image, int xsize, int bits, int x, int y) {
595    if (bits == 0) return 0;
596    return image[xsize * (y >> bits) + (x >> bits)];
597  }
598  static WEBP_INLINE HTreeGroup* GetHtreeGroupForPos(VP8LMetadata* const hdr,
599                                                     int x, int y) {
600    const int meta_index = GetMetaIndex(hdr->huffman_image_, hdr->huffman_xsize_,
601                                        hdr->huffman_subsample_bits_, x, y);
602    assert(meta_index < hdr->num_htree_groups_);
603    return hdr->htree_groups_ + meta_index;
604  }
605  typedef void (*ProcessRowsFunc)(VP8LDecoder* const dec, int row);
606  static void ApplyInverseTransforms(VP8LDecoder* const dec,
607                                     int start_row, int num_rows,
608                                     const uint32_t* const rows) {
609    int n = dec->next_transform_;
610    const int cache_pixs = dec->width_ * num_rows;
611    const int end_row = start_row + num_rows;
612    const uint32_t* rows_in = rows;
613    uint32_t* const rows_out = dec->argb_cache_;
614    while (n-- > 0) {
615      VP8LTransform* const transform = &dec->transforms_[n];
616      VP8LInverseTransform(transform, start_row, end_row, rows_in, rows_out);
617      rows_in = rows_out;
618    }
619    if (rows_in != rows_out) {
620      memcpy(rows_out, rows_in, cache_pixs * sizeof(*rows_out));
621    }
622  }
623  static void ProcessRows(VP8LDecoder* const dec, int row) {
624    const uint32_t* const rows = dec->pixels_ + dec->width_ * dec->last_row_;
625    const int num_rows = row - dec->last_row_;
626    assert(row <= dec->io_->crop_bottom);
627    assert(num_rows <= NUM_ARGB_CACHE_ROWS);
628    if (num_rows > 0) {    
629      VP8Io* const io = dec->io_;
630      uint8_t* rows_data = (uint8_t*)dec->argb_cache_;
631      const int in_stride = io->width * sizeof(uint32_t);  
632      ApplyInverseTransforms(dec, dec->last_row_, num_rows, rows);
633      if (!SetCropWindow(io, dec->last_row_, row, &rows_data, in_stride)) {
634      } else {
635        const WebPDecBuffer* const output = dec->output_;
636        if (WebPIsRGBMode(output->colorspace)) {  
637          const WebPRGBABuffer* const buf = &output->u.RGBA;
638          uint8_t* const rgba = buf->rgba + dec->last_out_row_ * buf->stride;
639          const int num_rows_out =
640  #if !defined(WEBP_REDUCE_SIZE)
641           io->use_scaling ?
642              EmitRescaledRowsRGBA(dec, rows_data, in_stride, io->mb_h,
643                                   rgba, buf->stride) :
644  #endif  
645              EmitRows(output->colorspace, rows_data, in_stride,
646                       io->mb_w, io->mb_h, rgba, buf->stride);
647          dec->last_out_row_ += num_rows_out;
648        } else {                              
649          dec->last_out_row_ = io->use_scaling ?
650              EmitRescaledRowsYUVA(dec, rows_data, in_stride, io->mb_h) :
651              EmitRowsYUVA(dec, rows_data, in_stride, io->mb_w, io->mb_h);
652        }
653        assert(dec->last_out_row_ <= output->height);
654      }
655    }
656    dec->last_row_ = row;
657    assert(dec->last_row_ <= dec->height_);
658  }
659  static int Is8bOptimizable(const VP8LMetadata* const hdr) {
660    int i;
661    if (hdr->color_cache_size_ > 0) return 0;
662    for (i = 0; i < hdr->num_htree_groups_; ++i) {
663      HuffmanCode** const htrees = hdr->htree_groups_[i].htrees;
664      if (htrees[RED][0].bits > 0) return 0;
665      if (htrees[BLUE][0].bits > 0) return 0;
666      if (htrees[ALPHA][0].bits > 0) return 0;
667    }
668    return 1;
669  }
670  static void AlphaApplyFilter(ALPHDecoder* const alph_dec,
671                               int first_row, int last_row,
672                               uint8_t* out, int stride) {
673    if (alph_dec->filter_ != WEBP_FILTER_NONE) {
674      int y;
675      const uint8_t* prev_line = alph_dec->prev_line_;
676      assert(WebPUnfilters[alph_dec->filter_] != NULL);
677      for (y = first_row; y < last_row; ++y) {
678        WebPUnfilters[alph_dec->filter_](prev_line, out, out, stride);
679        prev_line = out;
680        out += stride;
681      }
682      alph_dec->prev_line_ = prev_line;
683    }
684  }
685  static void ExtractPalettedAlphaRows(VP8LDecoder* const dec, int last_row) {
686    ALPHDecoder* const alph_dec = (ALPHDecoder*)dec->io_->opaque;
687    const int top_row =
688        (alph_dec->filter_ == WEBP_FILTER_NONE ||
689         alph_dec->filter_ == WEBP_FILTER_HORIZONTAL) ? dec->io_->crop_top
690                                                      : dec->last_row_;
691    const int first_row = (dec->last_row_ < top_row) ? top_row : dec->last_row_;
692    assert(last_row <= dec->io_->crop_bottom);
693    if (last_row > first_row) {
694      const int width = dec->io_->width;
695      uint8_t* out = alph_dec->output_ + width * first_row;
696      const uint8_t* const in =
697        (uint8_t*)dec->pixels_ + dec->width_ * first_row;
698      VP8LTransform* const transform = &dec->transforms_[0];
699      assert(dec->next_transform_ == 1);
700      assert(transform->type_ == COLOR_INDEXING_TRANSFORM);
701      VP8LColorIndexInverseTransformAlpha(transform, first_row, last_row,
702                                          in, out);
703      AlphaApplyFilter(alph_dec, first_row, last_row, out, width);
704    }
705    dec->last_row_ = dec->last_out_row_ = last_row;
706  }
707  static WEBP_INLINE uint32_t Rotate8b(uint32_t V) {
708  #if defined(WORDS_BIGENDIAN)
709    return ((V & 0xff000000u) >> 24) | (V << 8);
710  #else
711    return ((V & 0xffu) << 24) | (V >> 8);
712  #endif
713  }
714  static WEBP_INLINE void CopySmallPattern8b(const uint8_t* src, uint8_t* dst,
715                                             int length, uint32_t pattern) {
716    int i;
717    while ((uintptr_t)dst & 3) {
718      *dst++ = *src++;
719      pattern = Rotate8b(pattern);
720      --length;
721    }
722    for (i = 0; i < (length >> 2); ++i) {
723      ((uint32_t*)dst)[i] = pattern;
724    }
725    for (i <<= 2; i < length; ++i) {
726      dst[i] = src[i];
727    }
728  }
729  static WEBP_INLINE void CopyBlock8b(uint8_t* const dst, int dist, int length) {
730    const uint8_t* src = dst - dist;
731    if (length >= 8) {
732      uint32_t pattern = 0;
733      switch (dist) {
734        case 1:
735          pattern = src[0];
736  #if defined(__arm__) || defined(_M_ARM)   
737          pattern |= pattern << 8;
738          pattern |= pattern << 16;
739  #elif defined(WEBP_USE_MIPS_DSP_R2)
740          __asm__ volatile ("replv.qb %0, %0" : "+r"(pattern));
741  #else
742          pattern = 0x01010101u * pattern;
743  #endif
744          break;
745        case 2:
746  #if !defined(WORDS_BIGENDIAN)
747          memcpy(&pattern, src, sizeof(uint16_t));
748  #else
749          pattern = ((uint32_t)src[0] << 8) | src[1];
750  #endif
751  #if defined(__arm__) || defined(_M_ARM)
752          pattern |= pattern << 16;
753  #elif defined(WEBP_USE_MIPS_DSP_R2)
754          __asm__ volatile ("replv.ph %0, %0" : "+r"(pattern));
755  #else
756          pattern = 0x00010001u * pattern;
757  #endif
758          break;
759        case 4:
760          memcpy(&pattern, src, sizeof(uint32_t));
761          break;
762        default:
763          goto Copy;
764          break;
765      }
766      CopySmallPattern8b(src, dst, length, pattern);
767      return;
768    }
769   Copy:
770    if (dist >= length) {  
771      memcpy(dst, src, length * sizeof(*dst));
772    } else {
773      int i;
774      for (i = 0; i < length; ++i) dst[i] = src[i];
775    }
776  }
777  static WEBP_INLINE void CopySmallPattern32b(const uint32_t* src,
778                                              uint32_t* dst,
779                                              int length, uint64_t pattern) {
780    int i;
781    if ((uintptr_t)dst & 4) {           
782      *dst++ = *src++;
783      pattern = (pattern >> 32) | (pattern << 32);
784      --length;
785    }
786    assert(0 == ((uintptr_t)dst & 7));
787    for (i = 0; i < (length >> 1); ++i) {
788      ((uint64_t*)dst)[i] = pattern;    
789    }
790    if (length & 1) {                   
791      dst[i << 1] = src[i << 1];
792    }
793  }
794  static WEBP_INLINE void CopyBlock32b(uint32_t* const dst,
795                                       int dist, int length) {
796    const uint32_t* const src = dst - dist;
797    if (dist <= 2 && length >= 4 && ((uintptr_t)dst & 3) == 0) {
798      uint64_t pattern;
799      if (dist == 1) {
800        pattern = (uint64_t)src[0];
801        pattern |= pattern << 32;
802      } else {
803        memcpy(&pattern, src, sizeof(pattern));
804      }
805      CopySmallPattern32b(src, dst, length, pattern);
806    } else if (dist >= length) {  
807      memcpy(dst, src, length * sizeof(*dst));
808    } else {
809      int i;
810      for (i = 0; i < length; ++i) dst[i] = src[i];
811    }
812  }
813  static int DecodeAlphaData(VP8LDecoder* const dec, uint8_t* const data,
814                             int width, int height, int last_row) {
815    int ok = 1;
816    int row = dec->last_pixel_ / width;
817    int col = dec->last_pixel_ % width;
818    VP8LBitReader* const br = &dec->br_;
819    VP8LMetadata* const hdr = &dec->hdr_;
820    int pos = dec->last_pixel_;         
821    const int end = width * height;     
822    const int last = width * last_row;  
823    const int len_code_limit = NUM_LITERAL_CODES + NUM_LENGTH_CODES;
824    const int mask = hdr->huffman_mask_;
825    const HTreeGroup* htree_group =
826        (pos < last) ? GetHtreeGroupForPos(hdr, col, row) : NULL;
827    assert(pos <= end);
828    assert(last_row <= height);
829    assert(Is8bOptimizable(hdr));
830    while (!br->eos_ && pos < last) {
831      int code;
832      if ((col & mask) == 0) {
833        htree_group = GetHtreeGroupForPos(hdr, col, row);
834      }
835      assert(htree_group != NULL);
836      VP8LFillBitWindow(br);
837      code = ReadSymbol(htree_group->htrees[GREEN], br);
838      if (code < NUM_LITERAL_CODES) {  
839        data[pos] = code;
840        ++pos;
841        ++col;
842        if (col >= width) {
843          col = 0;
844          ++row;
845          if (row <= last_row && (row % NUM_ARGB_CACHE_ROWS == 0)) {
846            ExtractPalettedAlphaRows(dec, row);
847          }
848        }
849      } else if (code < len_code_limit) {  
850        int dist_code, dist;
851        const int length_sym = code - NUM_LITERAL_CODES;
852        const int length = GetCopyLength(length_sym, br);
853        const int dist_symbol = ReadSymbol(htree_group->htrees[DIST], br);
854        VP8LFillBitWindow(br);
855        dist_code = GetCopyDistance(dist_symbol, br);
856        dist = PlaneCodeToDistance(width, dist_code);
857        if (pos >= dist && end - pos >= length) {
858          CopyBlock8b(data + pos, dist, length);
859        } else {
860          ok = 0;
861          goto End;
862        }
863        pos += length;
864        col += length;
865        while (col >= width) {
866          col -= width;
867          ++row;
868          if (row <= last_row && (row % NUM_ARGB_CACHE_ROWS == 0)) {
869            ExtractPalettedAlphaRows(dec, row);
870          }
871        }
872        if (pos < last && (col & mask)) {
873          htree_group = GetHtreeGroupForPos(hdr, col, row);
874        }
875      } else {  
876        ok = 0;
877        goto End;
878      }
879      br->eos_ = VP8LIsEndOfStream(br);
880    }
881    ExtractPalettedAlphaRows(dec, row > last_row ? last_row : row);
882   End:
883    br->eos_ = VP8LIsEndOfStream(br);
884    if (!ok || (br->eos_ && pos < end)) {
885      ok = 0;
886      dec->status_ = br->eos_ ? VP8_STATUS_SUSPENDED
887                              : VP8_STATUS_BITSTREAM_ERROR;
888    } else {
889      dec->last_pixel_ = pos;
890    }
891    return ok;
892  }
893  static void SaveState(VP8LDecoder* const dec, int last_pixel) {
894    assert(dec->incremental_);
895    dec->saved_br_ = dec->br_;
896    dec->saved_last_pixel_ = last_pixel;
897    if (dec->hdr_.color_cache_size_ > 0) {
898      VP8LColorCacheCopy(&dec->hdr_.color_cache_, &dec->hdr_.saved_color_cache_);
899    }
900  }
901  static void RestoreState(VP8LDecoder* const dec) {
902    assert(dec->br_.eos_);
903    dec->status_ = VP8_STATUS_SUSPENDED;
904    dec->br_ = dec->saved_br_;
905    dec->last_pixel_ = dec->saved_last_pixel_;
906    if (dec->hdr_.color_cache_size_ > 0) {
907      VP8LColorCacheCopy(&dec->hdr_.saved_color_cache_, &dec->hdr_.color_cache_);
908    }
909  }
910  #define SYNC_EVERY_N_ROWS 8  
911  static int DecodeImageData(VP8LDecoder* const dec, uint32_t* const data,
912                             int width, int height, int last_row,
913                             ProcessRowsFunc process_func) {
914    int row = dec->last_pixel_ / width;
915    int col = dec->last_pixel_ % width;
916    VP8LBitReader* const br = &dec->br_;
917    VP8LMetadata* const hdr = &dec->hdr_;
918    uint32_t* src = data + dec->last_pixel_;
919    uint32_t* last_cached = src;
920    uint32_t* const src_end = data + width * height;     
921    uint32_t* const src_last = data + width * last_row;  
922    const int len_code_limit = NUM_LITERAL_CODES + NUM_LENGTH_CODES;
923    const int color_cache_limit = len_code_limit + hdr->color_cache_size_;
924    int next_sync_row = dec->incremental_ ? row : 1 << 24;
925    VP8LColorCache* const color_cache =
926        (hdr->color_cache_size_ > 0) ? &hdr->color_cache_ : NULL;
927    const int mask = hdr->huffman_mask_;
928    const HTreeGroup* htree_group =
929        (src < src_last) ? GetHtreeGroupForPos(hdr, col, row) : NULL;
930    assert(dec->last_row_ < last_row);
931    assert(src_last <= src_end);
932    while (src < src_last) {
933      int code;
934      if (row >= next_sync_row) {
935        SaveState(dec, (int)(src - data));
936        next_sync_row = row + SYNC_EVERY_N_ROWS;
937      }
938      if ((col & mask) == 0) {
939        htree_group = GetHtreeGroupForPos(hdr, col, row);
940      }
941      assert(htree_group != NULL);
942      if (htree_group->is_trivial_code) {
943        *src = htree_group->literal_arb;
944        goto AdvanceByOne;
945      }
946      VP8LFillBitWindow(br);
947      if (htree_group->use_packed_table) {
948        code = ReadPackedSymbols(htree_group, br, src);
949        if (VP8LIsEndOfStream(br)) break;
950        if (code == PACKED_NON_LITERAL_CODE) goto AdvanceByOne;
951      } else {
952        code = ReadSymbol(htree_group->htrees[GREEN], br);
953      }
954      if (VP8LIsEndOfStream(br)) break;
955      if (code < NUM_LITERAL_CODES) {  
956        if (htree_group->is_trivial_literal) {
957          *src = htree_group->literal_arb | (code << 8);
958        } else {
959          int red, blue, alpha;
960          red = ReadSymbol(htree_group->htrees[RED], br);
961          VP8LFillBitWindow(br);
962          blue = ReadSymbol(htree_group->htrees[BLUE], br);
963          alpha = ReadSymbol(htree_group->htrees[ALPHA], br);
964          if (VP8LIsEndOfStream(br)) break;
965          *src = ((uint32_t)alpha << 24) | (red << 16) | (code << 8) | blue;
966        }
967      AdvanceByOne:
968        ++src;
969        ++col;
970        if (col >= width) {
971          col = 0;
972          ++row;
973          if (process_func != NULL) {
974            if (row <= last_row && (row % NUM_ARGB_CACHE_ROWS == 0)) {
975              process_func(dec, row);
976            }
977          }
978          if (color_cache != NULL) {
979            while (last_cached < src) {
980              VP8LColorCacheInsert(color_cache, *last_cached++);
981            }
982          }
983        }
984      } else if (code < len_code_limit) {  
985        int dist_code, dist;
986        const int length_sym = code - NUM_LITERAL_CODES;
987        const int length = GetCopyLength(length_sym, br);
988        const int dist_symbol = ReadSymbol(htree_group->htrees[DIST], br);
989        VP8LFillBitWindow(br);
990        dist_code = GetCopyDistance(dist_symbol, br);
991        dist = PlaneCodeToDistance(width, dist_code);
992        if (VP8LIsEndOfStream(br)) break;
993        if (src - data < (ptrdiff_t)dist || src_end - src < (ptrdiff_t)length) {
994          goto Error;
995        } else {
996          CopyBlock32b(src, dist, length);
997        }
998        src += length;
999        col += length;
1000        while (col >= width) {
1001          col -= width;
1002          ++row;
1003          if (process_func != NULL) {
1004            if (row <= last_row && (row % NUM_ARGB_CACHE_ROWS == 0)) {
1005              process_func(dec, row);
1006            }
1007          }
1008        }
1009        assert(src <= src_end);
1010        if (col & mask) htree_group = GetHtreeGroupForPos(hdr, col, row);
1011        if (color_cache != NULL) {
1012          while (last_cached < src) {
1013            VP8LColorCacheInsert(color_cache, *last_cached++);
1014          }
1015        }
1016      } else if (code < color_cache_limit) {  
1017        const int key = code - len_code_limit;
1018        assert(color_cache != NULL);
1019        while (last_cached < src) {
1020          VP8LColorCacheInsert(color_cache, *last_cached++);
1021        }
1022        *src = VP8LColorCacheLookup(color_cache, key);
1023        goto AdvanceByOne;
1024      } else {  
1025        goto Error;
1026      }
1027    }
1028    br->eos_ = VP8LIsEndOfStream(br);
1029    if (dec->incremental_ && br->eos_ && src < src_end) {
1030      RestoreState(dec);
1031    } else if (!br->eos_) {
1032      if (process_func != NULL) {
1033        process_func(dec, row > last_row ? last_row : row);
1034      }
1035      dec->status_ = VP8_STATUS_OK;
1036      dec->last_pixel_ = (int)(src - data);  
1037    } else {
1038      goto Error;
1039    }
1040    return 1;
1041   Error:
1042    dec->status_ = VP8_STATUS_BITSTREAM_ERROR;
1043    return 0;
1044  }
1045  static void ClearTransform(VP8LTransform* const transform) {
1046    WebPSafeFree(transform->data_);
1047    transform->data_ = NULL;
1048  }
1049  static int ExpandColorMap(int num_colors, VP8LTransform* const transform) {
1050    int i;
1051    const int final_num_colors = 1 << (8 >> transform->bits_);
1052    uint32_t* const new_color_map =
1053        (uint32_t*)WebPSafeMalloc((uint64_t)final_num_colors,
1054                                  sizeof(*new_color_map));
1055    if (new_color_map == NULL) {
1056      return 0;
1057    } else {
1058      uint8_t* const data = (uint8_t*)transform->data_;
1059      uint8_t* const new_data = (uint8_t*)new_color_map;
1060      new_color_map[0] = transform->data_[0];
1061      for (i = 4; i < 4 * num_colors; ++i) {
1062        new_data[i] = (data[i] + new_data[i - 4]) & 0xff;
1063      }
1064      for (; i < 4 * final_num_colors; ++i) {
1065        new_data[i] = 0;  
1066      }
1067      WebPSafeFree(transform->data_);
1068      transform->data_ = new_color_map;
1069    }
1070    return 1;
1071  }
1072  static int ReadTransform(int* const xsize, int const* ysize,
1073                           VP8LDecoder* const dec) {
1074    int ok = 1;
1075    VP8LBitReader* const br = &dec->br_;
1076    VP8LTransform* transform = &dec->transforms_[dec->next_transform_];
1077    const VP8LImageTransformType type =
1078        (VP8LImageTransformType)VP8LReadBits(br, 2);
1079    if (dec->transforms_seen_ & (1U << type)) {
1080      return 0;  
1081    }
1082    dec->transforms_seen_ |= (1U << type);
1083    transform->type_ = type;
1084    transform->xsize_ = *xsize;
1085    transform->ysize_ = *ysize;
1086    transform->data_ = NULL;
1087    ++dec->next_transform_;
1088    assert(dec->next_transform_ <= NUM_TRANSFORMS);
1089    switch (type) {
1090      case PREDICTOR_TRANSFORM:
1091      case CROSS_COLOR_TRANSFORM:
1092        transform->bits_ = VP8LReadBits(br, 3) + 2;
1093        ok = DecodeImageStream(VP8LSubSampleSize(transform->xsize_,
1094                                                 transform->bits_),
1095                               VP8LSubSampleSize(transform->ysize_,
1096                                                 transform->bits_),
1097                               0, dec, &transform->data_);
1098        break;
1099      case COLOR_INDEXING_TRANSFORM: {
1100         const int num_colors = VP8LReadBits(br, 8) + 1;
1101         const int bits = (num_colors > 16) ? 0
1102                        : (num_colors > 4) ? 1
1103                        : (num_colors > 2) ? 2
1104                        : 3;
1105         *xsize = VP8LSubSampleSize(transform->xsize_, bits);
1106         transform->bits_ = bits;
1107         ok = DecodeImageStream(num_colors, 1, 0, dec, &transform->data_);
1108         ok = ok && ExpandColorMap(num_colors, transform);
1109        break;
1110      }
1111      case SUBTRACT_GREEN:
1112        break;
1113      default:
1114        assert(0);    
1115        break;
1116    }
1117    return ok;
1118  }
1119  static void InitMetadata(VP8LMetadata* const hdr) {
1120    assert(hdr != NULL);
1121    memset(hdr, 0, sizeof(*hdr));
1122  }
1123  static void ClearMetadata(VP8LMetadata* const hdr) {
1124    assert(hdr != NULL);
1125    WebPSafeFree(hdr->huffman_image_);
1126    WebPSafeFree(hdr->huffman_tables_);
1127    VP8LHtreeGroupsFree(hdr->htree_groups_);
1128    VP8LColorCacheClear(&hdr->color_cache_);
1129    VP8LColorCacheClear(&hdr->saved_color_cache_);
1130    InitMetadata(hdr);
1131  }
1132  VP8LDecoder* VP8LNew(void) {
1133    VP8LDecoder* const dec = (VP8LDecoder*)WebPSafeCalloc(1ULL, sizeof(*dec));
1134    if (dec == NULL) return NULL;
1135    dec->status_ = VP8_STATUS_OK;
1136    dec->state_ = READ_DIM;
1137    VP8LDspInit();  
1138    return dec;
1139  }
1140  void VP8LClear(VP8LDecoder* const dec) {
1141    int i;
1142    if (dec == NULL) return;
1143    ClearMetadata(&dec->hdr_);
1144    WebPSafeFree(dec->pixels_);
1145    dec->pixels_ = NULL;
1146    for (i = 0; i < dec->next_transform_; ++i) {
1147      ClearTransform(&dec->transforms_[i]);
1148    }
1149    dec->next_transform_ = 0;
1150    dec->transforms_seen_ = 0;
1151    WebPSafeFree(dec->rescaler_memory);
1152    dec->rescaler_memory = NULL;
1153    dec->output_ = NULL;   
1154  }
1155  void VP8LDelete(VP8LDecoder* const dec) {
1156    if (dec != NULL) {
1157      VP8LClear(dec);
1158      WebPSafeFree(dec);
1159    }
1160  }
1161  static void UpdateDecoder(VP8LDecoder* const dec, int width, int height) {
1162    VP8LMetadata* const hdr = &dec->hdr_;
1163    const int num_bits = hdr->huffman_subsample_bits_;
1164    dec->width_ = width;
1165    dec->height_ = height;
1166    hdr->huffman_xsize_ = VP8LSubSampleSize(width, num_bits);
1167    hdr->huffman_mask_ = (num_bits == 0) ? ~0 : (1 << num_bits) - 1;
1168  }
1169  static int DecodeImageStream(int xsize, int ysize,
1170                               int is_level0,
1171                               VP8LDecoder* const dec,
1172                               uint32_t** const decoded_data) {
1173    int ok = 1;
1174    int transform_xsize = xsize;
1175    int transform_ysize = ysize;
1176    VP8LBitReader* const br = &dec->br_;
1177    VP8LMetadata* const hdr = &dec->hdr_;
1178    uint32_t* data = NULL;
1179    int color_cache_bits = 0;
1180    if (is_level0) {
1181      while (ok && VP8LReadBits(br, 1)) {
1182        ok = ReadTransform(&transform_xsize, &transform_ysize, dec);
1183      }
1184    }
1185    if (ok && VP8LReadBits(br, 1)) {
1186      color_cache_bits = VP8LReadBits(br, 4);
1187      ok = (color_cache_bits >= 1 && color_cache_bits <= MAX_CACHE_BITS);
1188      if (!ok) {
1189        dec->status_ = VP8_STATUS_BITSTREAM_ERROR;
1190        goto End;
1191      }
1192    }
1193    ok = ok && ReadHuffmanCodes(dec, transform_xsize, transform_ysize,
1194                                color_cache_bits, is_level0);
1195    if (!ok) {
1196      dec->status_ = VP8_STATUS_BITSTREAM_ERROR;
1197      goto End;
1198    }
1199    if (color_cache_bits > 0) {
1200      hdr->color_cache_size_ = 1 << color_cache_bits;
1201      if (!VP8LColorCacheInit(&hdr->color_cache_, color_cache_bits)) {
1202        dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
1203        ok = 0;
1204        goto End;
1205      }
1206    } else {
1207      hdr->color_cache_size_ = 0;
1208    }
1209    UpdateDecoder(dec, transform_xsize, transform_ysize);
1210    if (is_level0) {   
1211      dec->state_ = READ_HDR;
1212      goto End;
1213    }
1214    {
1215      const uint64_t total_size = (uint64_t)transform_xsize * transform_ysize;
1216      data = (uint32_t*)WebPSafeMalloc(total_size, sizeof(*data));
1217      if (data == NULL) {
1218        dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
1219        ok = 0;
1220        goto End;
1221      }
1222    }
1223    ok = DecodeImageData(dec, data, transform_xsize, transform_ysize,
1224                         transform_ysize, NULL);
1225    ok = ok && !br->eos_;
1226   End:
1227    if (!ok) {
1228      WebPSafeFree(data);
1229      ClearMetadata(hdr);
1230    } else {
1231      if (decoded_data != NULL) {
1232        *decoded_data = data;
1233      } else {
1234        assert(data == NULL);
1235        assert(is_level0);
1236      }
1237      dec->last_pixel_ = 0;  
1238      if (!is_level0) ClearMetadata(hdr);  
1239    }
1240    return ok;
1241  }
1242  static int AllocateInternalBuffers32b(VP8LDecoder* const dec, int final_width) {
1243    const uint64_t num_pixels = (uint64_t)dec->width_ * dec->height_;
1244    const uint64_t cache_top_pixels = (uint16_t)final_width;
1245    const uint64_t cache_pixels = (uint64_t)final_width * NUM_ARGB_CACHE_ROWS;
1246    const uint64_t total_num_pixels =
1247        num_pixels + cache_top_pixels + cache_pixels;
1248    assert(dec->width_ <= final_width);
1249    dec->pixels_ = (uint32_t*)WebPSafeMalloc(total_num_pixels, sizeof(uint32_t));
1250    if (dec->pixels_ == NULL) {
1251      dec->argb_cache_ = NULL;    
1252      dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
1253      return 0;
1254    }
1255    dec->argb_cache_ = dec->pixels_ + num_pixels + cache_top_pixels;
1256    return 1;
1257  }
1258  static int AllocateInternalBuffers8b(VP8LDecoder* const dec) {
1259    const uint64_t total_num_pixels = (uint64_t)dec->width_ * dec->height_;
1260    dec->argb_cache_ = NULL;    
1261    dec->pixels_ = (uint32_t*)WebPSafeMalloc(total_num_pixels, sizeof(uint8_t));
1262    if (dec->pixels_ == NULL) {
1263      dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
1264      return 0;
1265    }
1266    return 1;
1267  }
1268  static void ExtractAlphaRows(VP8LDecoder* const dec, int last_row) {
1269    int cur_row = dec->last_row_;
1270    int num_rows = last_row - cur_row;
1271    const uint32_t* in = dec->pixels_ + dec->width_ * cur_row;
1272    assert(last_row <= dec->io_->crop_bottom);
1273    while (num_rows > 0) {
1274      const int num_rows_to_process =
1275          (num_rows > NUM_ARGB_CACHE_ROWS) ? NUM_ARGB_CACHE_ROWS : num_rows;
1276      ALPHDecoder* const alph_dec = (ALPHDecoder*)dec->io_->opaque;
1277      uint8_t* const output = alph_dec->output_;
1278      const int width = dec->io_->width;      
1279      const int cache_pixs = width * num_rows_to_process;
1280      uint8_t* const dst = output + width * cur_row;
1281      const uint32_t* const src = dec->argb_cache_;
1282      ApplyInverseTransforms(dec, cur_row, num_rows_to_process, in);
1283      WebPExtractGreen(src, dst, cache_pixs);
1284      AlphaApplyFilter(alph_dec,
1285                       cur_row, cur_row + num_rows_to_process, dst, width);
1286      num_rows -= num_rows_to_process;
1287      in += num_rows_to_process * dec->width_;
1288      cur_row += num_rows_to_process;
1289    }
1290    assert(cur_row == last_row);
1291    dec->last_row_ = dec->last_out_row_ = last_row;
1292  }
1293  int VP8LDecodeAlphaHeader(ALPHDecoder* const alph_dec,
1294                            const uint8_t* const data, size_t data_size) {
1295    int ok = 0;
1296    VP8LDecoder* dec = VP8LNew();
1297    if (dec == NULL) return 0;
1298    assert(alph_dec != NULL);
1299    dec->width_ = alph_dec->width_;
1300    dec->height_ = alph_dec->height_;
1301    dec->io_ = &alph_dec->io_;
1302    dec->io_->opaque = alph_dec;
1303    dec->io_->width = alph_dec->width_;
1304    dec->io_->height = alph_dec->height_;
1305    dec->status_ = VP8_STATUS_OK;
1306    VP8LInitBitReader(&dec->br_, data, data_size);
1307    if (!DecodeImageStream(alph_dec->width_, alph_dec->height_, 1, dec, NULL)) {
1308      goto Err;
1309    }
1310    if (dec->next_transform_ == 1 &&
1311        dec->transforms_[0].type_ == COLOR_INDEXING_TRANSFORM &&
1312        Is8bOptimizable(&dec->hdr_)) {
1313      alph_dec->use_8b_decode_ = 1;
1314      ok = AllocateInternalBuffers8b(dec);
1315    } else {
1316      alph_dec->use_8b_decode_ = 0;
1317      ok = AllocateInternalBuffers32b(dec, alph_dec->width_);
1318    }
1319    if (!ok) goto Err;
1320    alph_dec->vp8l_dec_ = dec;
1321    return 1;
1322   Err:
1323    VP8LDelete(dec);
1324    return 0;
1325  }
1326  int VP8LDecodeAlphaImageStream(ALPHDecoder* const alph_dec, int last_row) {
1327    VP8LDecoder* const dec = alph_dec->vp8l_dec_;
1328    assert(dec != NULL);
1329    assert(last_row <= dec->height_);
1330    if (dec->last_row_ >= last_row) {
1331      return 1;  
1332    }
1333    if (!alph_dec->use_8b_decode_) WebPInitAlphaProcessing();
1334    return alph_dec->use_8b_decode_ ?
1335        DecodeAlphaData(dec, (uint8_t*)dec->pixels_, dec->width_, dec->height_,
1336                        last_row) :
1337        DecodeImageData(dec, dec->pixels_, dec->width_, dec->height_,
1338                        last_row, ExtractAlphaRows);
1339  }
1340  int VP8LDecodeHeader(VP8LDecoder* const dec, VP8Io* const io) {
1341    int width, height, has_alpha;
1342    if (dec == NULL) return 0;
1343    if (io == NULL) {
1344      dec->status_ = VP8_STATUS_INVALID_PARAM;
1345      return 0;
1346    }
1347    dec->io_ = io;
1348    dec->status_ = VP8_STATUS_OK;
1349    VP8LInitBitReader(&dec->br_, io->data, io->data_size);
1350    if (!ReadImageInfo(&dec->br_, &width, &height, &has_alpha)) {
1351      dec->status_ = VP8_STATUS_BITSTREAM_ERROR;
1352      goto Error;
1353    }
1354    dec->state_ = READ_DIM;
1355    io->width = width;
1356    io->height = height;
1357    if (!DecodeImageStream(width, height, 1, dec, NULL)) goto Error;
1358    return 1;
1359   Error:
1360    VP8LClear(dec);
1361    assert(dec->status_ != VP8_STATUS_OK);
1362    return 0;
1363  }
1364  int VP8LDecodeImage(VP8LDecoder* const dec) {
1365    VP8Io* io = NULL;
1366    WebPDecParams* params = NULL;
1367    if (dec == NULL) return 0;
1368    assert(dec->hdr_.huffman_tables_ != NULL);
1369    assert(dec->hdr_.htree_groups_ != NULL);
1370    assert(dec->hdr_.num_htree_groups_ > 0);
1371    io = dec->io_;
1372    assert(io != NULL);
1373    params = (WebPDecParams*)io->opaque;
1374    assert(params != NULL);
1375    if (dec->state_ != READ_DATA) {
1376      dec->output_ = params->output;
1377      assert(dec->output_ != NULL);
1378      if (!WebPIoInitFromOptions(params->options, io, MODE_BGRA)) {
1379        dec->status_ = VP8_STATUS_INVALID_PARAM;
1380        goto Err;
1381      }
1382      if (!AllocateInternalBuffers32b(dec, io->width)) goto Err;
1383  #if !defined(WEBP_REDUCE_SIZE)
1384      if (io->use_scaling && !AllocateAndInitRescaler(dec, io)) goto Err;
1385  #else
1386      if (io->use_scaling) {
1387        dec->status_ = VP8_STATUS_INVALID_PARAM;
1388        goto Err;
1389      }
1390  #endif
1391      if (io->use_scaling || WebPIsPremultipliedMode(dec->output_->colorspace)) {
1392        WebPInitAlphaProcessing();
1393      }
1394      if (!WebPIsRGBMode(dec->output_->colorspace)) {
1395        WebPInitConvertARGBToYUV();
1396        if (dec->output_->u.YUVA.a != NULL) WebPInitAlphaProcessing();
1397      }
1398      if (dec->incremental_) {
1399        if (dec->hdr_.color_cache_size_ > 0 &&
1400            dec->hdr_.saved_color_cache_.colors_ == NULL) {
1401          if (!VP8LColorCacheInit(&dec->hdr_.saved_color_cache_,
1402                                  dec->hdr_.color_cache_.hash_bits_)) {
1403            dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
1404            goto Err;
1405          }
1406        }
1407      }
1408      dec->state_ = READ_DATA;
1409    }
1410    if (!DecodeImageData(dec, dec->pixels_, dec->width_, dec->height_,
1411                         io->crop_bottom, ProcessRows)) {
1412      goto Err;
1413    }
1414    params->last_y = dec->last_out_row_;
1415    return 1;
1416   Err:
1417    VP8LClear(dec);
1418    assert(dec->status_ != VP8_STATUS_OK);
1419    return 0;
1420  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-t_stream.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vp8l_dec.c</div>
                </div>
                <div class="column column_space"><pre><code>31              id->ms++;
32              id->seq = 0;
33          }
34      } else {
35          id->seq++;
36      }
37  }
</pre></code></div>
                <div class="column column_space"><pre><code>326          if (*mapped_group == -1) *mapped_group = num_htree_groups++;
327          huffman_image[i] = *mapped_group;
328        }
329      } else {
330        num_htree_groups = num_htree_groups_max;
331      }
332    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    