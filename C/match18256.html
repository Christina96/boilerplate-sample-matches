<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for jpegload.c &amp; hist_local.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for jpegload.c &amp; hist_local.c
      </h3>
<h1 align="center">
        7.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>jpegload.c (7.9051385%)<th>hist_local.c (7.434944%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(391-414)<td><a href="#" name="0">(337-360)</a><td align="center"><font color="#ff0000">20</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>jpegload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;setjmp.h&gt;
8 #include &lt;vips/vips.h&gt;
9 #include &lt;vips/buf.h&gt;
10 #include &lt;vips/internal.h&gt;
11 #include "pforeign.h"
12 #ifdef HAVE_JPEG
13 #ifdef HAVE_EXIF
14 #ifdef UNTAGGED_EXIF
15 #include &lt;exif-data.h&gt;
16 #include &lt;exif-loader.h&gt;
17 #include &lt;exif-ifd.h&gt;
18 #include &lt;exif-utils.h&gt;
19 #include &lt;libexif/exif-data.h&gt;
20 #include &lt;libexif/exif-loader.h&gt;
21 #include &lt;libexif/exif-ifd.h&gt;
22 #include &lt;libexif/exif-utils.h&gt;
23 typedef struct _VipsForeignLoadJpeg {
24 	VipsForeignLoad parent_object;
25 	VipsSource *source;
26 	int shrink;
27 	gboolean autorotate;
28 } VipsForeignLoadJpeg;
29 typedef VipsForeignLoadClass VipsForeignLoadJpegClass;
30 G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadJpeg, vips_foreign_load_jpeg, 
31 	VIPS_TYPE_FOREIGN_LOAD );
32 static void
33 vips_foreign_load_jpeg_dispose( GObject *gobject )
34 {
35 	VipsForeignLoadJpeg *jpeg = (VipsForeignLoadJpeg *) gobject;
36 	VIPS_UNREF( jpeg-&gt;source );
37 	G_OBJECT_CLASS( vips_foreign_load_jpeg_parent_class )-&gt;
38 		dispose( gobject );
39 }
40 static int
41 vips_foreign_load_jpeg_build( VipsObject *object )
42 {
43 	VipsForeignLoadJpeg *jpeg = (VipsForeignLoadJpeg *) object;
44 	if( jpeg-&gt;shrink != 1 &amp;&amp; 
45 		jpeg-&gt;shrink != 2 &amp;&amp; 
46 		jpeg-&gt;shrink != 4 &amp;&amp; 
47 		jpeg-&gt;shrink != 8 ) {
48 		vips_error( "VipsFormatLoadJpeg", 
49 			_( "bad shrink factor %d" ), jpeg-&gt;shrink );
50 		return( -1 );
51 	}
52 	if( VIPS_OBJECT_CLASS( vips_foreign_load_jpeg_parent_class )-&gt;
53 		build( object ) )
54 		return( -1 );
55 	return( 0 );
56 }
57 static VipsForeignFlags
58 vips_foreign_load_jpeg_get_flags( VipsForeignLoad *load )
59 {
60 	return( VIPS_FOREIGN_SEQUENTIAL );
61 }
62 static VipsForeignFlags
63 vips_foreign_load_jpeg_get_flags_filename( const char *filename )
64 {
65 	return( VIPS_FOREIGN_SEQUENTIAL );
66 }
67 static int
68 vips_foreign_load_jpeg_header( VipsForeignLoad *load )
69 {
70 	VipsForeignLoadJpeg *jpeg = (VipsForeignLoadJpeg *) load;
71 	if( vips__jpeg_read_source( jpeg-&gt;source, 
72 		load-&gt;out, TRUE, jpeg-&gt;shrink, load-&gt;fail, jpeg-&gt;autorotate ) )
73 		return( -1 );
74 	return( 0 );
75 }
76 static int
77 vips_foreign_load_jpeg_load( VipsForeignLoad *load )
78 {
79 	VipsForeignLoadJpeg *jpeg = (VipsForeignLoadJpeg *) load;
80 	if( vips__jpeg_read_source( jpeg-&gt;source,
81 		load-&gt;real, FALSE, jpeg-&gt;shrink, load-&gt;fail, 
82 		jpeg-&gt;autorotate ) )
83 		return( -1 );
84 	return( 0 );
85 }
86 static void
87 vips_foreign_load_jpeg_class_init( VipsForeignLoadJpegClass *class )
88 {
89 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
90 	VipsObjectClass *object_class = (VipsObjectClass *) class;
91 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
92 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
93 	gobject_class-&gt;dispose = vips_foreign_load_jpeg_dispose;
94 	gobject_class-&gt;set_property = vips_object_set_property;
95 	gobject_class-&gt;get_property = vips_object_get_property;
96 	object_class-&gt;nickname = "jpegload_base";
97 	object_class-&gt;description = _( "load jpeg" );
98 	object_class-&gt;build = vips_foreign_load_jpeg_build;
99 	foreign_class-&gt;priority = 50;
100 	load_class-&gt;get_flags_filename = 
101 		vips_foreign_load_jpeg_get_flags_filename;
102 	load_class-&gt;get_flags = vips_foreign_load_jpeg_get_flags;
103 	load_class-&gt;header = vips_foreign_load_jpeg_header;
104 	load_class-&gt;load = vips_foreign_load_jpeg_load;
105 	VIPS_ARG_INT( class, "shrink", 20, 
106 		_( "Shrink" ), 
107 		_( "Shrink factor on load" ),
108 		VIPS_ARGUMENT_OPTIONAL_INPUT,
109 		G_STRUCT_OFFSET( VipsForeignLoadJpeg, shrink ),
110 		1, 16, 1 );
111 	VIPS_ARG_BOOL( class, "autorotate", 21, 
112 		_( "Autorotate" ), 
113 		_( "Rotate image using exif orientation" ),
114 		VIPS_ARGUMENT_OPTIONAL_INPUT,
115 		G_STRUCT_OFFSET( VipsForeignLoadJpeg, autorotate ),
116 		FALSE );
117 }
118 static void
119 vips_foreign_load_jpeg_init( VipsForeignLoadJpeg *jpeg )
120 {
121 	jpeg-&gt;shrink = 1;
122 }
123 typedef struct _VipsForeignLoadJpegSource {
124 	VipsForeignLoadJpeg parent_object;
125 	VipsSource *source;
126 } VipsForeignLoadJpegSource;
127 typedef VipsForeignLoadJpegClass VipsForeignLoadJpegSourceClass;
128 G_DEFINE_TYPE( VipsForeignLoadJpegSource, vips_foreign_load_jpeg_source, 
129 	vips_foreign_load_jpeg_get_type() );
130 static int
131 vips_foreign_load_jpeg_source_build( VipsObject *object )
132 {
133 	VipsForeignLoadJpeg *jpeg = (VipsForeignLoadJpeg *) object;
134 	VipsForeignLoadJpegSource *source = 
135 		(VipsForeignLoadJpegSource *) object;
136 	if( source-&gt;source ) {
137 		jpeg-&gt;source = source-&gt;source;
138 		g_object_ref( jpeg-&gt;source );
139 	}
140 	if( VIPS_OBJECT_CLASS( vips_foreign_load_jpeg_source_parent_class )-&gt;
141 		build( object ) )
142 		return( -1 );
143 	return( 0 );
144 }
145 static gboolean
146 vips_foreign_load_jpeg_source_is_a_source( VipsSource *source )
147 {
148 	return( vips__isjpeg_source( source ) );
149 }
150 static void
151 vips_foreign_load_jpeg_source_class_init( 
152 	VipsForeignLoadJpegSourceClass *class )
153 {
154 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
155 	VipsObjectClass *object_class = (VipsObjectClass *) class;
156 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
157 	gobject_class-&gt;set_property = vips_object_set_property;
158 	gobject_class-&gt;get_property = vips_object_get_property;
159 	object_class-&gt;nickname = "jpegload_source";
160 	object_class-&gt;description = _( "load image from jpeg source" );
161 	object_class-&gt;build = vips_foreign_load_jpeg_source_build;
162 	load_class-&gt;is_a_source = vips_foreign_load_jpeg_source_is_a_source;
163 	VIPS_ARG_OBJECT( class, "source", 1,
164 		_( "Source" ),
165 		_( "Source to load from" ),
166 		VIPS_ARGUMENT_REQUIRED_INPUT, 
167 		G_STRUCT_OFFSET( VipsForeignLoadJpegSource, source ),
168 		VIPS_TYPE_SOURCE );
169 }
170 static void
171 vips_foreign_load_jpeg_source_init( VipsForeignLoadJpegSource *source )
172 {
173 }
174 typedef struct _VipsForeignLoadJpegFile {
175 	VipsForeignLoadJpeg parent_object;
176 	char *filename; 
177 } VipsForeignLoadJpegFile;
178 typedef VipsForeignLoadJpegClass VipsForeignLoadJpegFileClass;
179 G_DEFINE_TYPE( VipsForeignLoadJpegFile, vips_foreign_load_jpeg_file, 
180 	vips_foreign_load_jpeg_get_type() );
181 static int
182 vips_foreign_load_jpeg_file_build( VipsObject *object )
183 {
184 	VipsForeignLoadJpeg *jpeg = (VipsForeignLoadJpeg *) object;
185 	VipsForeignLoadJpegFile *file = (VipsForeignLoadJpegFile *) object;
186 	if( file-&gt;filename &amp;&amp;
187 		!(jpeg-&gt;source = 
188 			vips_source_new_from_file( file-&gt;filename )) )
189 		return( -1 );
190 	if( VIPS_OBJECT_CLASS( vips_foreign_load_jpeg_file_parent_class )-&gt;
191 		build( object ) )
192 		return( -1 );
193 	return( 0 );
194 }
195 static gboolean
196 vips_foreign_load_jpeg_file_is_a( const char *filename )
197 {
198 	VipsSource *source;
199 	gboolean result;
200 	if( !(source = vips_source_new_from_file( filename )) ) 
201 		return( FALSE );
202 	result = vips_foreign_load_jpeg_source_is_a_source( source );
203 	VIPS_UNREF( source );
204 	return( result );
205 }
206 static void
207 vips_foreign_load_jpeg_file_class_init( VipsForeignLoadJpegFileClass *class )
208 {
209 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
210 	VipsObjectClass *object_class = (VipsObjectClass *) class;
211 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
212 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
213 	gobject_class-&gt;set_property = vips_object_set_property;
214 	gobject_class-&gt;get_property = vips_object_get_property;
215 	object_class-&gt;nickname = "jpegload";
216 	object_class-&gt;description = _( "load jpeg from file" );
217 	object_class-&gt;build = vips_foreign_load_jpeg_file_build;
218 	foreign_class-&gt;suffs = vips__jpeg_suffs;
219 	load_class-&gt;is_a = vips_foreign_load_jpeg_file_is_a;
220 	VIPS_ARG_STRING( class, "filename", 1, 
221 		_( "Filename" ),
222 		_( "Filename to load from" ),
223 		VIPS_ARGUMENT_REQUIRED_INPUT, 
224 		G_STRUCT_OFFSET( VipsForeignLoadJpegFile, filename ),
225 		NULL );
226 }
227 static void
228 vips_foreign_load_jpeg_file_init( VipsForeignLoadJpegFile *file )
229 {
230 }
231 typedef struct _VipsForeignLoadJpegBuffer {
232 	VipsForeignLoadJpeg parent_object;
233 	VipsBlob *blob;
234 } VipsForeignLoadJpegBuffer;
235 typedef VipsForeignLoadJpegClass VipsForeignLoadJpegBufferClass;
236 G_DEFINE_TYPE( VipsForeignLoadJpegBuffer, vips_foreign_load_jpeg_buffer, 
237 	vips_foreign_load_jpeg_get_type() );
238 static int
239 vips_foreign_load_jpeg_buffer_build( VipsObject *object )
240 {
241 	VipsForeignLoadJpeg *jpeg = (VipsForeignLoadJpeg *) object;
242 	VipsForeignLoadJpegBuffer *buffer = 
243 		(VipsForeignLoadJpegBuffer *) object;
244 	if( buffer-&gt;blob &amp;&amp;
245 		!(jpeg-&gt;source = vips_source_new_from_memory( 
246 			VIPS_AREA( buffer-&gt;blob )-&gt;data, 
247 			VIPS_AREA( buffer-&gt;blob )-&gt;length )) )
248 		return( -1 );
249 	if( VIPS_OBJECT_CLASS( vips_foreign_load_jpeg_buffer_parent_class )-&gt;
250 		build( object ) )
251 		return( -1 );
252 	return( 0 );
253 }
254 static gboolean
255 vips_foreign_load_jpeg_buffer_is_a_buffer( const void *buf, size_t len )
256 {
257 	VipsSource *source;
258 	gboolean result;
259 <a name="0"></a>
260 	if( !(source = vips_source_new_from_memory( buf, len )) ) 
261 		return( FALSE );
262 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	result = vips_foreign_load_jpeg_source_is_a_source( source );
263 	VIPS_UNREF( source );
264 	return( result );
265 }
266 static void
267 vips_foreign_load_jpeg_buffer_class_init( 
268 	VipsForeignLoadJpegBufferClass *class )
269 {
270 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
271 	VipsObjectClass *object_class = (VipsObjectClass *) class;
272 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
273 	gobject_class-&gt;set_property = vips_object_set_property;
274 	gobject_class-&gt;get_property = vips_object_get_property;
275 	object_class-&gt;nickname = "jpegload_buffer";
276 	object_class-&gt;description = _( "load jpeg from buffer" );
277 	object_class-&gt;build = vips_foreign_load_jpeg_buffer_build;
278 	load_class-&gt;is_a_buffer = vips_foreign_load_jpeg_buffer_is_a_buffer;
279 	VIPS_ARG_BOXED( class, "buffer", 1, </b></font>
280 		_( "Buffer" ),
281 		_( "Buffer to load from" ),
282 		VIPS_ARGUMENT_REQUIRED_INPUT, 
283 		G_STRUCT_OFFSET( VipsForeignLoadJpegBuffer, blob ),
284 		VIPS_TYPE_BLOB );
285 }
286 static void
287 vips_foreign_load_jpeg_buffer_init( VipsForeignLoadJpegBuffer *buffer )
288 {
289 }
290 int
291 vips_jpegload( const char *filename, VipsImage **out, ... )
292 {
293 	va_list ap;
294 	int result;
295 	va_start( ap, out );
296 	result = vips_call_split( "jpegload", ap, filename, out );
297 	va_end( ap );
298 	return( result );
299 }
300 int
301 vips_jpegload_buffer( void *buf, size_t len, VipsImage **out, ... )
302 {
303 	va_list ap;
304 	VipsBlob *blob;
305 	int result;
306 	blob = vips_blob_new( NULL, buf, len );
307 	va_start( ap, out );
308 	result = vips_call_split( "jpegload_buffer", ap, blob, out );
309 	va_end( ap );
310 	vips_area_unref( VIPS_AREA( blob ) );
311 	return( result );
312 }
313 int
314 vips_jpegload_source( VipsSource *source, VipsImage **out, ... )
315 {
316 	va_list ap;
317 	int result;
318 	va_start( ap, out );
319 	result = vips_call_split( "jpegload_source", ap, source, out );
320 	va_end( ap );
321 	return( result );
322 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>hist_local.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/internal.h&gt;
9 typedef struct _VipsHistLocal {
10 	VipsOperation parent_instance;
11 	VipsImage *in;
12 	VipsImage *out;
13 	int width;
14 	int height;
15 	int max_slope;
16 } VipsHistLocal;
17 typedef VipsOperationClass VipsHistLocalClass;
18 G_DEFINE_TYPE( VipsHistLocal, vips_hist_local, VIPS_TYPE_OPERATION );
19 typedef struct {
20 	VipsRegion *ir;		
21 	unsigned int **hist;
22 } VipsHistLocalSequence;
23 static int
24 vips_hist_local_stop( void *vseq, void *a, void *b )
25 {
26 	VipsHistLocalSequence *seq = (VipsHistLocalSequence *) vseq;
27 	VipsImage *in = (VipsImage *) a;
28 	VIPS_UNREF( seq-&gt;ir );
29 	if( seq-&gt;hist &amp;&amp;
30 		in ) {
31 		int i; 
32 		for( i = 0; i &lt; in-&gt;Bands; i++ )
33 			VIPS_FREE( seq-&gt;hist[i] );
34 	}
35 	VIPS_FREE( seq-&gt;hist );
36 	VIPS_FREE( seq );
37 	return( 0 );
38 }
39 static void *
40 vips_hist_local_start( VipsImage *out, void *a, void *b )
41 {
42 	VipsImage *in = (VipsImage *) a;
43 	VipsHistLocalSequence *seq;
44 	int i;
45 	if( !(seq = VIPS_NEW( NULL, VipsHistLocalSequence )) )
46 		 return( NULL );
47 	seq-&gt;ir = NULL;
48 	seq-&gt;hist = NULL;
49 	if( !(seq-&gt;ir = vips_region_new( in )) || 
50 		!(seq-&gt;hist = VIPS_ARRAY( NULL, in-&gt;Bands, unsigned int * )) ) {
51 		vips_hist_local_stop( seq, NULL, NULL );
52 		return( NULL ); 
53 	}
54 	for( i = 0; i &lt; in-&gt;Bands; i++ )
55 		if( !(seq-&gt;hist[i] = VIPS_ARRAY( NULL, 256, unsigned int )) ) {
56 		vips_hist_local_stop( seq, NULL, NULL );
57 		return( NULL ); 
58 	}
59 	return( seq );
60 }
61 static int
62 vips_hist_local_generate( VipsRegion *or, 
63 	void *vseq, void *a, void *b, gboolean *stop )
64 {
65 	VipsHistLocalSequence *seq = (VipsHistLocalSequence *) vseq;
66 	VipsImage *in = (VipsImage *) a;
67 	const VipsHistLocal *local = (VipsHistLocal *) b;
68 	VipsRect *r = &amp;or-&gt;valid;
69 	const int bands = in-&gt;Bands; 
70 	const int max_slope = local-&gt;max_slope;
71 	VipsRect irect;
72 	int y;
73 	int lsk;
74 	int centre;		
75 	irect.left = r-&gt;left;
76 	irect.top = r-&gt;top;
77 	irect.width = r-&gt;width + local-&gt;width; 
78 	irect.height = r-&gt;height + local-&gt;height; 
79 	if( vips_region_prepare( seq-&gt;ir, &amp;irect ) )
80 		return( -1 );
81 	lsk = VIPS_REGION_LSKIP( seq-&gt;ir );
82 	centre = lsk * (local-&gt;height / 2) + bands * (local-&gt;width / 2);
83 	for( y = 0; y &lt; r-&gt;height; y++ ) {
84 		VipsPel * restrict p = 
85 			VIPS_REGION_ADDR( seq-&gt;ir, r-&gt;left, r-&gt;top + y );
86 		VipsPel * restrict q = 
87 			VIPS_REGION_ADDR( or, r-&gt;left, r-&gt;top + y );
88 		VipsPel * restrict p1;
89 		int x, i, j, b;
90 		for( b = 0; b &lt; bands; b++ )
91 			memset( seq-&gt;hist[b], 0, 256 * sizeof( unsigned int ) );
92 		p1 = p;
93 		for( j = 0; j &lt; local-&gt;height; j++ ) {
94 			for( i = 0, x = 0; x &lt; local-&gt;width; x++ )
95 				for( b = 0; b &lt; bands; b++, i++ )
96 					seq-&gt;hist[b][p1[i]] += 1;
97 			p1 += lsk;
98 		}
99 		for( x = 0; x &lt; r-&gt;width; x++ ) {
100 			for( b = 0; b &lt; bands; b++ ) {
101 				unsigned int * restrict hist = seq-&gt;hist[b]; 
102 				const int target = p[centre + b];
103 				int sum;
104 				sum = 0;
105 				if( max_slope &gt; 0 ) {
106 					int sum_over;
107 					sum_over = 0;
108 					for( i = 0; i &lt;= target; i++ ) {
109 						if( hist[i] &gt; max_slope ) {
110 							sum_over += hist[i] - 
111 								max_slope;
112 							sum += max_slope;
113 						}
114 						else 
115 							sum += hist[i];
116 					}
117 					for( ; i &lt; 256; i++ ) {
118 						if( hist[i] &gt; max_slope ) 
119 							sum_over += hist[i] - 
120 								max_slope;
121 					}
122 					sum += (target + 1) * sum_over / 256;
123 				}
124 				else {
125 					sum = 0;
126 					for( i = 0; i &lt;= target; i++ )
127 						sum += hist[i];
128 				}
129 				q[b] = 255 * sum / 
130 					(local-&gt;width * local-&gt;height);
131 				p1 = p + b;
132 				for( j = 0; j &lt; local-&gt;height; j++ ) {
133 					hist[p1[0]] -= 1;
134 					hist[p1[bands * local-&gt;width]] += 1;
135 					p1 += lsk;
136 				}
137 			}
138 			p += bands;
139 			q += bands;
140 		}
141 	}
142 	return( 0 );
143 }
144 static int
145 vips_hist_local_build( VipsObject *object )
146 {
147 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
148 	VipsHistLocal *local = (VipsHistLocal *) object;
149 	VipsImage **t = (VipsImage **) vips_object_local_array( object, 3 );
150 	VipsImage *in;
151 	if( VIPS_OBJECT_CLASS( vips_hist_local_parent_class )-&gt;build( object ) )
152 		return( -1 );
153 	in = local-&gt;in; 
154 	if( vips_image_decode( in, &amp;t[0] ) )
155 		return( -1 );
156 	in = t[0]; 
157 	if( vips_check_format( class-&gt;nickname, in, VIPS_FORMAT_UCHAR ) )
158 		return( -1 );
159 	if( local-&gt;width &gt; in-&gt;Xsize || 
160 		local-&gt;height &gt; in-&gt;Ysize ) {
161 		vips_error( class-&gt;nickname, "%s", _( "window too large" ) );
162 		return( -1 );
163 	}
164 	if( vips_embed( in, &amp;t[1], 
165 		local-&gt;width / 2, local-&gt;height / 2, 
166 		in-&gt;Xsize + local-&gt;width - 1, in-&gt;Ysize + local-&gt;height - 1,
167 		"extend", VIPS_EXTEND_MIRROR,
168 		NULL ) )
169 		return( -1 );
170 	in = t[1];
171 	g_object_set( object, "out", vips_image_new(), NULL ); 
172 	if( vips_image_pipelinev( local-&gt;out, 
173 		VIPS_DEMAND_STYLE_FATSTRIP, in, NULL ) )
174 		return( -1 );
175 	local-&gt;out-&gt;Xsize -= local-&gt;width - 1;
176 	local-&gt;out-&gt;Ysize -= local-&gt;height - 1;
177 	if( vips_image_generate( local-&gt;out, 
178 		vips_hist_local_start, 
179 		vips_hist_local_generate, 
180 		vips_hist_local_stop, 
181 		in, local ) )
182 <a name="0"></a>		return( -1 );
183 	local-&gt;out-&gt;Xoffset = 0;
184 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	local-&gt;out-&gt;Yoffset = 0;
185 	vips_reorder_margin_hint( local-&gt;out, local-&gt;width * local-&gt;height ); 
186 	return( 0 );
187 }
188 static void
189 vips_hist_local_class_init( VipsHistLocalClass *class )
190 {
191 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
192 	VipsObjectClass *object_class = (VipsObjectClass *) class;
193 	VipsOperationClass *operation_class = VIPS_OPERATION_CLASS( class );
194 	gobject_class-&gt;set_property = vips_object_set_property;
195 	gobject_class-&gt;get_property = vips_object_get_property;
196 	object_class-&gt;nickname = "hist_local";
197 	object_class-&gt;description = _( "local histogram equalisation" );
198 	object_class-&gt;build = vips_hist_local_build;
199 	operation_class-&gt;flags = VIPS_OPERATION_SEQUENTIAL;
200 	VIPS_ARG_IMAGE( class, "in", 1, </b></font>
201 		_( "Input" ), 
202 		_( "Input image" ),
203 		VIPS_ARGUMENT_REQUIRED_INPUT,
204 		G_STRUCT_OFFSET( VipsHistLocal, in ) );
205 	VIPS_ARG_IMAGE( class, "out", 2, 
206 		_( "Output" ), 
207 		_( "Output image" ),
208 		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
209 		G_STRUCT_OFFSET( VipsHistLocal, out ) );
210 	VIPS_ARG_INT( class, "width", 4, 
211 		_( "Width" ), 
212 		_( "Window width in pixels" ),
213 		VIPS_ARGUMENT_REQUIRED_INPUT,
214 		G_STRUCT_OFFSET( VipsHistLocal, width ),
215 		1, VIPS_MAX_COORD, 1 );
216 	VIPS_ARG_INT( class, "height", 5, 
217 		_( "Height" ), 
218 		_( "Window height in pixels" ),
219 		VIPS_ARGUMENT_REQUIRED_INPUT,
220 		G_STRUCT_OFFSET( VipsHistLocal, height ),
221 		1, VIPS_MAX_COORD, 1 );
222 	VIPS_ARG_INT( class, "max_slope", 6, 
223 		_( "Max slope" ), 
224 		_( "Maximum slope (CLAHE)" ),
225 		VIPS_ARGUMENT_OPTIONAL_INPUT,
226 		G_STRUCT_OFFSET( VipsHistLocal, max_slope ),
227 		0, 100, 0 );
228 }
229 static void
230 vips_hist_local_init( VipsHistLocal *local )
231 {
232 }
233 int 
234 vips_hist_local( VipsImage *in, VipsImage **out, int width, int height, ... )
235 {
236 	va_list ap;
237 	int result;
238 	va_start( ap, height );
239 	result = vips_call_split( "hist_local", ap, in, out, width, height );
240 	va_end( ap );
241 	return( result );
242 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
