
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 24, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-ziplist.c</h3>
            <pre><code>1  #include &lt;stdio.h&gt;
2  #include &lt;stdlib.h&gt;
3  #include &lt;string.h&gt;
4  #include &lt;stdint.h&gt;
5  #include &lt;limits.h&gt;
6  #include &quot;zmalloc.h&quot;
7  #include &quot;util.h&quot;
8  #include &quot;ziplist.h&quot;
9  #include &quot;endianconv.h&quot;
10  #include &quot;redisassert.h&quot;
11  #ifdef _WIN32
12  #include &quot;Win32_Interop/Win32_FDAPI.h&quot;
13  #endif
14  #define ZIP_END 255         &amp;bsol;* Special &quot;end of ziplist&quot; entry. */
15  #define ZIP_BIG_PREVLEN 254 &amp;bsol;* Max number of bytes of the previous entry, for
16                                 the &quot;prevlen&quot; field prefixing each entry, to be
17                                 represented with just a single byte. Otherwise
18                                 it is represented as FF AA BB CC DD, where
19                                 AA BB CC DD are a 4 bytes unsigned integer
20                                 representing the previous entry len. */
21  #define ZIP_STR_MASK 0xc0
22  #define ZIP_INT_MASK 0x30
23  #define ZIP_STR_06B (0 &lt;&lt; 6)
24  #define ZIP_STR_14B (1 &lt;&lt; 6)
25  #define ZIP_STR_32B (2 &lt;&lt; 6)
26  #define ZIP_INT_16B (0xc0 | 0&lt;&lt;4)
27  #define ZIP_INT_32B (0xc0 | 1&lt;&lt;4)
28  #define ZIP_INT_64B (0xc0 | 2&lt;&lt;4)
29  #define ZIP_INT_24B (0xc0 | 3&lt;&lt;4)
30  #define ZIP_INT_8B 0xfe
31  #define ZIP_INT_IMM_MASK 0x0f   &amp;bsol;* Mask to extract the 4 bits value. To add
32                                     one is needed to reconstruct the value. */
33  #define ZIP_INT_IMM_MIN 0xf1    &amp;bsol;* 11110001 */
34  #define ZIP_INT_IMM_MAX 0xfd    &amp;bsol;* 11111101 */
35  #define INT24_MAX 0x7fffff
36  #define INT24_MIN (-INT24_MAX - 1)
37  #define ZIP_IS_STR(enc) (((enc) &amp; ZIP_STR_MASK) &lt; ZIP_STR_MASK)
38  #define ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))
39  #define ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))
40  #define ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))
41  #define ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))
42  #define ZIPLIST_END_SIZE        (sizeof(uint8_t))
43  #define ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)
44  #define ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))
45  #define ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)
46  #define ZIPLIST_INCR_LENGTH(zl,incr) { \
47      if (ZIPLIST_LENGTH(zl) &lt; UINT16_MAX) \
48          ZIPLIST_LENGTH(zl) = intrev16ifbe(intrev16ifbe(ZIPLIST_LENGTH(zl))+incr); \
49  }
50  typedef struct zlentry {
51      unsigned int prevrawlensize; &amp;bsol;* Bytes used to encode the previous entry len*/
52      unsigned int prevrawlen;     &amp;bsol;* Previous entry len. */
53      unsigned int lensize;        &amp;bsol;* Bytes used to encode this entry type/len.
54                                      For example strings have a 1, 2 or 5 bytes
55                                      header. Integers always use a single byte.*/
56      unsigned int len;            &amp;bsol;* Bytes used to represent the actual entry.
57                                      For strings this is just the string length
58                                      while for integers it is 1, 2, 3, 4, 8 or
59                                      0 (for 4 bit immediate) depending on the
60                                      number range. */
61      unsigned int headersize;     &amp;bsol;* prevrawlensize + lensize. */
62      unsigned char encoding;      &amp;bsol;* Set to ZIP_STR_* or ZIP_INT_* depending on
63                                      the entry encoding. However for 4 bits
64                                      immediate integers this can assume a range
65                                      of values and must be range-checked. */
66      unsigned char *p;            &amp;bsol;* Pointer to the very start of the entry, that
67                                      is, this points to prev-entry-len field. */
68  } zlentry;
69  #define ZIPLIST_ENTRY_ZERO(zle) { \
70      (zle)-&gt;prevrawlensize = (zle)-&gt;prevrawlen = 0; \
71      (zle)-&gt;lensize = (zle)-&gt;len = (zle)-&gt;headersize = 0; \
72      (zle)-&gt;encoding = 0; \
73      (zle)-&gt;p = NULL; \
74  }
75  #define ZIP_ENTRY_ENCODING(ptr, encoding) do {  \
76      (encoding) = (ptr[0]); \
77      if ((encoding) &lt; ZIP_STR_MASK) (encoding) &amp;= ZIP_STR_MASK; \
78  } while(0)
79  unsigned int zipIntSize(unsigned char encoding) {
80      switch(encoding) {
81      case ZIP_INT_8B:  return 1;
82      case ZIP_INT_16B: return 2;
83      case ZIP_INT_24B: return 3;
84      case ZIP_INT_32B: return 4;
85      case ZIP_INT_64B: return 8;
86      }
87      if (encoding &gt;= ZIP_INT_IMM_MIN &amp;&amp; encoding &lt;= ZIP_INT_IMM_MAX)
88          return 0; &amp;bsol;* 4 bit immediate */
89      panic(&quot;Invalid integer encoding 0x%02X&quot;, encoding);
90      return 0;
91  }
92  unsigned int zipStoreEntryEncoding(unsigned char *p, unsigned char encoding, unsigned int rawlen) {
93      unsigned char len = 1, buf[5];
94      if (ZIP_IS_STR(encoding)) {
95          if (rawlen &lt;= 0x3f) {
96              if (!p) return len;
97              buf[0] = ZIP_STR_06B | rawlen;
98          } else if (rawlen &lt;= 0x3fff) {
99              len += 1;
100              if (!p) return len;
101              buf[0] = ZIP_STR_14B | ((rawlen &gt;&gt; 8) &amp; 0x3f);
102              buf[1] = rawlen &amp; 0xff;
103          } else {
104              len += 4;
105              if (!p) return len;
106              buf[0] = ZIP_STR_32B;
107              buf[1] = (rawlen &gt;&gt; 24) &amp; 0xff;
108              buf[2] = (rawlen &gt;&gt; 16) &amp; 0xff;
109              buf[3] = (rawlen &gt;&gt; 8) &amp; 0xff;
110              buf[4] = rawlen &amp; 0xff;
111          }
112      } else {
113          if (!p) return len;
114          buf[0] = encoding;
115      }
116      memcpy(p,buf,len);
117      return len;
118  }
119  #define ZIP_DECODE_LENGTH(ptr, encoding, lensize, len) do {                    \
120      ZIP_ENTRY_ENCODING((ptr), (encoding));                                     \
121      if ((encoding) &lt; ZIP_STR_MASK) {                                           \
122          if ((encoding) == ZIP_STR_06B) {                                       \
123              (lensize) = 1;                                                     \
124              (len) = (ptr)[0] &amp; 0x3f;                                           \
125          } else if ((encoding) == ZIP_STR_14B) {                                \
126              (lensize) = 2;                                                     \
127              (len) = (((ptr)[0] &amp; 0x3f) &lt;&lt; 8) | (ptr)[1];                       \
128          } else if ((encoding) == ZIP_STR_32B) {                                \
129              (lensize) = 5;                                                     \
130              (len) = ((ptr)[1] &lt;&lt; 24) |                                         \
131                      ((ptr)[2] &lt;&lt; 16) |                                         \
132                      ((ptr)[3] &lt;&lt;  8) |                                         \
133                      ((ptr)[4]);                                                \
134          } else {                                                               \
135              panic(&quot;Invalid string encoding 0x%02X&quot;, (encoding));               \
136          }                                                                      \
137      } else {                                                                   \
138          (lensize) = 1;                                                         \
139          (len) = zipIntSize(encoding);                                          \
140      }                                                                          \
141  } while(0);
142  int zipStorePrevEntryLengthLarge(unsigned char *p, unsigned int len) {
143      if (p != NULL) {
144          p[0] = ZIP_BIG_PREVLEN;
145          memcpy(p+1,&amp;len,sizeof(len));
146          memrev32ifbe(p+1);
147      }
148      return 1+sizeof(len);
149  }
150  unsigned int zipStorePrevEntryLength(unsigned char *p, unsigned int len) {
151      if (p == NULL) {
152          return (len &lt; ZIP_BIG_PREVLEN) ? 1 : sizeof(len)+1;
153      } else {
154          if (len &lt; ZIP_BIG_PREVLEN) {
155              p[0] = len;
156              return 1;
157          } else {
158              return zipStorePrevEntryLengthLarge(p,len);
159          }
160      }
161  }
162  #define ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do {                          \
163      if ((ptr)[0] &lt; ZIP_BIG_PREVLEN) {                                          \
164          (prevlensize) = 1;                                                     \
165      } else {                                                                   \
166          (prevlensize) = 5;                                                     \
167      }                                                                          \
168  } while(0);
169  #define ZIP_DECODE_PREVLEN(ptr, prevlensize, prevlen) do {                     \
170      ZIP_DECODE_PREVLENSIZE(ptr, prevlensize);                                  \
171      if ((prevlensize) == 1) {                                                  \
172          (prevlen) = (ptr)[0];                                                  \
173      } else if ((prevlensize) == 5) {                                           \
174          assert(sizeof((prevlen)) == 4);                                    \
175          memcpy(&amp;(prevlen), ((char*)(ptr)) + 1, 4);                             \
176          memrev32ifbe(&amp;prevlen);                                                \
177      }                                                                          \
178  } while(0);
179  int zipPrevLenByteDiff(unsigned char *p, unsigned int len) {
180      unsigned int prevlensize;
181      ZIP_DECODE_PREVLENSIZE(p, prevlensize);
182      return zipStorePrevEntryLength(NULL, len) - prevlensize;
183  }
184  unsigned int zipRawEntryLength(unsigned char *p) {
185      unsigned int prevlensize, encoding, lensize, len;
186      ZIP_DECODE_PREVLENSIZE(p, prevlensize);
187      ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len);
188      return prevlensize + lensize + len;
189  }
190  int zipTryEncoding(unsigned char *entry, unsigned int entrylen, PORT_LONGLONG *v, unsigned char *encoding) {
191      PORT_LONGLONG value;
192      if (entrylen &gt;= 32 || entrylen == 0) return 0;
193      if (string2ll((char*)entry,entrylen,&amp;value)) {
194          if (value &gt;= 0 &amp;&amp; value &lt;= 12) {
195              *encoding = (unsigned char)(ZIP_INT_IMM_MIN+value);                 WIN_PORT_FIX &amp;bsol;* cast (unsigned char) */
196          } else if (value &gt;= INT8_MIN &amp;&amp; value &lt;= INT8_MAX) {
197              *encoding = ZIP_INT_8B;
198          } else if (value &gt;= INT16_MIN &amp;&amp; value &lt;= INT16_MAX) {
199              *encoding = ZIP_INT_16B;
200          } else if (value &gt;= INT24_MIN &amp;&amp; value &lt;= INT24_MAX) {
201              *encoding = ZIP_INT_24B;
202          } else if (value &gt;= INT32_MIN &amp;&amp; value &lt;= INT32_MAX) {
203              *encoding = ZIP_INT_32B;
204          } else {
205              *encoding = ZIP_INT_64B;
206          }
207          *v = value;
208          return 1;
209      }
210      return 0;
211  }
212  void zipSaveInteger(unsigned char *p, int64_t value, unsigned char encoding) {
213      int16_t i16;
214      int32_t i32;
215      int64_t i64;
216      if (encoding == ZIP_INT_8B) {
217          ((int8_t*)p)[0] = (int8_t)value;
218      } else if (encoding == ZIP_INT_16B) {
219          i16 = (int16_t)value;                                                   WIN_PORT_FIX &amp;bsol;* cast (int16_t) */
220          memcpy(p,&amp;i16,sizeof(i16));
221          memrev16ifbe(p);
222      } else if (encoding == ZIP_INT_24B) {
223          i32 = (int32_t)(value&lt;&lt;8);                                              WIN_PORT_FIX &amp;bsol;* cast (int32_t) */
224          memrev32ifbe(&amp;i32);
225          memcpy(p,((uint8_t*)&amp;i32)+1,sizeof(i32)-sizeof(uint8_t));
226      } else if (encoding == ZIP_INT_32B) {
227          i32 = (int32_t)value;                                                   WIN_PORT_FIX &amp;bsol;* cast (int32_t) */
228          memcpy(p,&amp;i32,sizeof(i32));
229          memrev32ifbe(p);
230      } else if (encoding == ZIP_INT_64B) {
231          i64 = value;
232          memcpy(p,&amp;i64,sizeof(i64));
233          memrev64ifbe(p);
234      } else if (encoding &gt;= ZIP_INT_IMM_MIN &amp;&amp; encoding &lt;= ZIP_INT_IMM_MAX) {
235      } else {
236          assert(NULL);
237      }
238  }
239  int64_t zipLoadInteger(unsigned char *p, unsigned char encoding) {
240      int16_t i16;
241      int32_t i32;
242      int64_t i64, ret = 0;
243      if (encoding == ZIP_INT_8B) {
244          ret = ((int8_t*)p)[0];
245      } else if (encoding == ZIP_INT_16B) {
246          memcpy(&amp;i16,p,sizeof(i16));
247          memrev16ifbe(&amp;i16);
248          ret = i16;
249      } else if (encoding == ZIP_INT_32B) {
250          memcpy(&amp;i32,p,sizeof(i32));
251          memrev32ifbe(&amp;i32);
252          ret = i32;
253      } else if (encoding == ZIP_INT_24B) {
254          i32 = 0;
255          memcpy(((uint8_t*)&amp;i32)+1,p,sizeof(i32)-sizeof(uint8_t));
256          memrev32ifbe(&amp;i32);
257          ret = i32&gt;&gt;8;
258      } else if (encoding == ZIP_INT_64B) {
259          memcpy(&amp;i64,p,sizeof(i64));
260          memrev64ifbe(&amp;i64);
261          ret = i64;
262      } else if (encoding &gt;= ZIP_INT_IMM_MIN &amp;&amp; encoding &lt;= ZIP_INT_IMM_MAX) {
263          ret = (encoding &amp; ZIP_INT_IMM_MASK)-1;
264      } else {
265          assert(NULL);
266      }
267      return ret;
268  }
269  void zipEntry(unsigned char *p, zlentry *e) {
270      ZIP_DECODE_PREVLEN(p, e-&gt;prevrawlensize, e-&gt;prevrawlen);
271      ZIP_DECODE_LENGTH(p + e-&gt;prevrawlensize, e-&gt;encoding, e-&gt;lensize, e-&gt;len);
272      e-&gt;headersize = e-&gt;prevrawlensize + e-&gt;lensize;
273      e-&gt;p = p;
274  }
275  unsigned char *ziplistNew(void) {
276      unsigned int bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;
277      unsigned char *zl = zmalloc(bytes);
278      ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);
279      ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);
280      ZIPLIST_LENGTH(zl) = 0;
281      zl[bytes-1] = ZIP_END;
282      return zl;
283  }
284  unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {
285      zl = zrealloc(zl,len);
286      ZIPLIST_BYTES(zl) = intrev32ifbe(len);
287      zl[len-1] = ZIP_END;
288      return zl;
289  }
290  unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p) {
291      size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;
292      size_t offset, noffset, extra;
293      unsigned char *np;
294      zlentry cur, next;
295      while (p[0] != ZIP_END) {
296          zipEntry(p, &amp;cur);
297          rawlen = cur.headersize + cur.len;
298          rawlensize = zipStorePrevEntryLength(NULL,(unsigned int)rawlen);            WIN_PORT_FIX &amp;bsol;* cast (unsigned int) */
299          if (p[rawlen] == ZIP_END) break;
300          zipEntry(p+rawlen, &amp;next);
301          if (next.prevrawlen == rawlen) break;
302          if (next.prevrawlensize &lt; rawlensize) {
303              offset = p-zl;
304              extra = rawlensize-next.prevrawlensize;
305              zl = ziplistResize(zl,(unsigned int)(curlen+extra));                WIN_PORT_FIX &amp;bsol;* cast (unsigned int) */
306              p = zl+offset;
307              np = p+rawlen;
308              noffset = np-zl;
309              if ((zl+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np) {
310                  ZIPLIST_TAIL_OFFSET(zl) =
311                      (uint32_t)intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+extra); WIN_PORT_FIX &amp;bsol;* cast (uint32_t) */
312              }
313              memmove(np+rawlensize,
314                  np+next.prevrawlensize,
315                  curlen-noffset-next.prevrawlensize-1);
316              zipStorePrevEntryLength(np,(unsigned int)rawlen);                       WIN_PORT_FIX &amp;bsol;* cast (unsigned int) */
317              p += rawlen;
318              curlen += extra;
319          } else {
320              if (next.prevrawlensize &gt; rawlensize) {
321                  zipStorePrevEntryLengthLarge(p+rawlen,(unsigned int)rawlen);
322              } else {
323                  zipStorePrevEntryLength(p+rawlen,(unsigned int)rawlen);
324              }
325              break;
326          }
327      }
328      return zl;
329  }
330  unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num) {
331      unsigned int i, totlen, deleted = 0;
332      size_t offset;
333      int nextdiff = 0;
334      zlentry first, tail;
335      zipEntry(p, &amp;first);
336      for (i = 0; p[0] != ZIP_END &amp;&amp; i &lt; num; i++) {
337          p += zipRawEntryLength(p);
338          deleted++;
339      }
340      totlen = (unsigned int)(p-first.p); &amp;bsol;* Bytes taken by the element(s) to delete. */ WIN_PORT_FIX &amp;bsol;* cast (unsigned int) */
341      if (totlen &gt; 0) {
342          if (p[0] != ZIP_END) {
343              nextdiff = zipPrevLenByteDiff(p,first.prevrawlen);
344              p -= nextdiff;
345              zipStorePrevEntryLength(p,first.prevrawlen);
346              ZIPLIST_TAIL_OFFSET(zl) =
347                  intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))-totlen);
348              zipEntry(p, &amp;tail);
349              if (p[tail.headersize+tail.len] != ZIP_END) {
350                  ZIPLIST_TAIL_OFFSET(zl) =
351                     intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);
352              }
353              memmove(first.p,p,
354                  intrev32ifbe(ZIPLIST_BYTES(zl))-(p-zl)-1);
355          } else {
356              ZIPLIST_TAIL_OFFSET(zl) =
357                  (unsigned int)intrev32ifbe((first.p-zl)-first.prevrawlen);      WIN_PORT_FIX &amp;bsol;* cast (unsigned int) */
358          }
359          offset = first.p-zl;
360          zl = ziplistResize(zl, intrev32ifbe(ZIPLIST_BYTES(zl))-totlen+nextdiff);
361          ZIPLIST_INCR_LENGTH(zl,-deleted);
362          p = zl+offset;
363          if (nextdiff != 0)
364              zl = __ziplistCascadeUpdate(zl,p);
365      }
366      return zl;
367  }
368  unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {
369      size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;
370      unsigned int prevlensize, prevlen = 0;
371      size_t offset;
372      int nextdiff = 0;
373      unsigned char encoding = 0;
374      PORT_LONGLONG value = 123456789; &amp;bsol;* initialized to avoid warning. Using a value
375                                      that is easy to see if for some reason
376                                      we use it uninitialized. */
377      zlentry tail;
378      if (p[0] != ZIP_END) {
379          ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
380      } else {
381          unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);
382          if (ptail[0] != ZIP_END) {
383              prevlen = zipRawEntryLength(ptail);
384          }
385      }
386      if (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) {
387          reqlen = zipIntSize(encoding);
388      } else {
389          reqlen = slen;
390      }
391      reqlen += zipStorePrevEntryLength(NULL,(unsigned int)prevlen); WIN_PORT_FIX &amp;bsol;* cast (unsigned int) */
392      reqlen += zipStoreEntryEncoding(NULL,encoding,slen);
393      int forcelarge = 0;
394      nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,(unsigned int)reqlen) : 0;  WIN_PORT_FIX &amp;bsol;* cast (unsigned int) */
395      if (nextdiff == -4 &amp;&amp; reqlen &lt; 4) {
396          nextdiff = 0;
397          forcelarge = 1;
398      }
399      offset = p-zl;
400      zl = ziplistResize(zl,(unsigned int)(curlen+reqlen+nextdiff));              WIN_PORT_FIX &amp;bsol;* cast (unsigned int) */
401      p = zl+offset;
402      if (p[0] != ZIP_END) {
403          memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);
404          if (forcelarge)
405              zipStorePrevEntryLengthLarge(p+reqlen,reqlen);
406          else
407              zipStorePrevEntryLength(p+reqlen,reqlen);
408          ZIPLIST_TAIL_OFFSET(zl) =
409              (uint32_t)intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen); WIN_PORT_FIX &amp;bsol;* cast (uint32_t) */
410          zipEntry(p+reqlen, &amp;tail);
411          if (p[reqlen+tail.headersize+tail.len] != ZIP_END) {
412              ZIPLIST_TAIL_OFFSET(zl) =
413                  intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);
414          }
415      } else {
416          ZIPLIST_TAIL_OFFSET(zl) = (uint32_t)intrev32ifbe(p-zl);                 WIN_PORT_FIX &amp;bsol;* cast (uint32_) */
417      }
418      if (nextdiff != 0) {
419          offset = p-zl;
420          zl = __ziplistCascadeUpdate(zl,p+reqlen);
421          p = zl+offset;
422      }
423      p += zipStorePrevEntryLength(p,prevlen);
424      p += zipStoreEntryEncoding(p,encoding,slen);
425      if (ZIP_IS_STR(encoding)) {
426          memcpy(p,s,slen);
427      } else {
428          zipSaveInteger(p,value,encoding);
429      }
430      ZIPLIST_INCR_LENGTH(zl,1);
431      return zl;
432  }
433  unsigned char *ziplistMerge(unsigned char **first, unsigned char **second) {
434      if (first == NULL || *first == NULL || second == NULL || *second == NULL)
435          return NULL;
436      if (*first == *second)
437          return NULL;
438      size_t first_bytes = intrev32ifbe(ZIPLIST_BYTES(*first));
<span onclick='openModal()' class='match'>439      size_t first_len = intrev16ifbe(ZIPLIST_LENGTH(*first));
440      size_t second_bytes = intrev32ifbe(ZIPLIST_BYTES(*second));
441      size_t second_len = intrev16ifbe(ZIPLIST_LENGTH(*second));
</span>442      int append;
443      unsigned char *source, *target;
444      size_t target_bytes, source_bytes;
445      if (first_len &gt;= second_len) {
446          target = *first;
447          target_bytes = first_bytes;
448          source = *second;
449          source_bytes = second_bytes;
450          append = 1;
451      } else {
452          target = *second;
453          target_bytes = second_bytes;
454          source = *first;
455          source_bytes = first_bytes;
456          append = 0;
457      }
458      size_t zlbytes = first_bytes + second_bytes -
459                       ZIPLIST_HEADER_SIZE - ZIPLIST_END_SIZE;
460      size_t zllength = first_len + second_len;
461      zllength = zllength &lt; UINT16_MAX ? zllength : UINT16_MAX;
462      size_t first_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*first));
463      size_t second_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*second));
464      target = zrealloc(target, zlbytes);
465      if (append) {
466          memcpy(target + target_bytes - ZIPLIST_END_SIZE,
467                 source + ZIPLIST_HEADER_SIZE,
468                 source_bytes - ZIPLIST_HEADER_SIZE);
469      } else {
470          memmove(target + source_bytes - ZIPLIST_END_SIZE,
471                  target + ZIPLIST_HEADER_SIZE,
472                  target_bytes - ZIPLIST_HEADER_SIZE);
473          memcpy(target, source, source_bytes - ZIPLIST_END_SIZE);
474      }
475      ZIPLIST_BYTES(target) = intrev32ifbe(zlbytes);
476      ZIPLIST_LENGTH(target) = intrev16ifbe(zllength);
477      ZIPLIST_TAIL_OFFSET(target) = intrev32ifbe(
478                                     (first_bytes - ZIPLIST_END_SIZE) +
479                                     (second_offset - ZIPLIST_HEADER_SIZE));
480      target = __ziplistCascadeUpdate(target, target+first_offset);
481      if (append) {
482          zfree(*second);
483          *second = NULL;
484          *first = target;
485      } else {
486          zfree(*first);
487          *first = NULL;
488          *second = target;
489      }
490      return target;
491  }
492  unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where) {
493      unsigned char *p;
494      p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);
495      return __ziplistInsert(zl,p,s,slen);
496  }
497  unsigned char *ziplistIndex(unsigned char *zl, int index) {
498      unsigned char *p;
499      unsigned int prevlensize, prevlen = 0;
500      if (index &lt; 0) {
501          index = (-index)-1;
502          p = ZIPLIST_ENTRY_TAIL(zl);
503          if (p[0] != ZIP_END) {
504              ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
505              while (prevlen &gt; 0 &amp;&amp; index--) {
506                  p -= prevlen;
507                  ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
508              }
509          }
510      } else {
511          p = ZIPLIST_ENTRY_HEAD(zl);
512          while (p[0] != ZIP_END &amp;&amp; index--) {
513              p += zipRawEntryLength(p);
514          }
515      }
516      return (p[0] == ZIP_END || index &gt; 0) ? NULL : p;
517  }
518  unsigned char *ziplistNext(unsigned char *zl, unsigned char *p) {
519      ((void) zl);
520      if (p[0] == ZIP_END) {
521          return NULL;
522      }
523      p += zipRawEntryLength(p);
524      if (p[0] == ZIP_END) {
525          return NULL;
526      }
527      return p;
528  }
529  unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p) {
530      unsigned int prevlensize, prevlen = 0;
531      if (p[0] == ZIP_END) {
532          p = ZIPLIST_ENTRY_TAIL(zl);
533          return (p[0] == ZIP_END) ? NULL : p;
534      } else if (p == ZIPLIST_ENTRY_HEAD(zl)) {
535          return NULL;
536      } else {
537          ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
538          assert(prevlen &gt; 0);
539          return p-prevlen;
540      }
541  }
542  unsigned int ziplistGet(unsigned char *p, unsigned char **sstr, unsigned int *slen, PORT_LONGLONG *sval) {
543      zlentry entry;
544      if (p == NULL || p[0] == ZIP_END) return 0;
545      if (sstr) *sstr = NULL;
546      zipEntry(p, &amp;entry);
547      if (ZIP_IS_STR(entry.encoding)) {
548          if (sstr) {
549              *slen = entry.len;
550              *sstr = p+entry.headersize;
551          }
552      } else {
553          if (sval) {
554              *sval = zipLoadInteger(p+entry.headersize,entry.encoding);
555          }
556      }
557      return 1;
558  }
559  unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {
560      return __ziplistInsert(zl,p,s,slen);
561  }
562  unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p) {
563      size_t offset = *p-zl;
564      zl = __ziplistDelete(zl,*p,1);
565      *p = zl+offset;
566      return zl;
567  }
568  unsigned char *ziplistDeleteRange(unsigned char *zl, int index, unsigned int num) {
569      unsigned char *p = ziplistIndex(zl,index);
570      return (p == NULL) ? zl : __ziplistDelete(zl,p,num);
571  }
572  unsigned int ziplistCompare(unsigned char *p, unsigned char *sstr, unsigned int slen) {
573      zlentry entry;
574      unsigned char sencoding;
575      PORT_LONGLONG zval, sval;
576      if (p[0] == ZIP_END) return 0;
577      zipEntry(p, &amp;entry);
578      if (ZIP_IS_STR(entry.encoding)) {
579          if (entry.len == slen) {
580              return memcmp(p+entry.headersize,sstr,slen) == 0;
581          } else {
582              return 0;
583          }
584      } else {
585          if (zipTryEncoding(sstr,slen,&amp;sval,&amp;sencoding)) {
586            zval = zipLoadInteger(p+entry.headersize,entry.encoding);
587            return zval == sval;
588          }
589      }
590      return 0;
591  }
592  unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip) {
593      int skipcnt = 0;
594      unsigned char vencoding = 0;
595      PORT_LONGLONG vll = 0;
596      while (p[0] != ZIP_END) {
597          unsigned int prevlensize, encoding, lensize, len;
598          unsigned char *q;
599          ZIP_DECODE_PREVLENSIZE(p, prevlensize);
600          ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len);
601          q = p + prevlensize + lensize;
602          if (skipcnt == 0) {
603              if (ZIP_IS_STR(encoding)) {
604                  if (len == vlen &amp;&amp; memcmp(q, vstr, vlen) == 0) {
605                      return p;
606                  }
607              } else {
608                  if (vencoding == 0) {
609                      if (!zipTryEncoding(vstr, vlen, &amp;vll, &amp;vencoding)) {
610                          vencoding = UCHAR_MAX;
611                      }
612                      assert(vencoding);
613                  }
614                  if (vencoding != UCHAR_MAX) {
615                      PORT_LONGLONG ll = zipLoadInteger(q, encoding);
616                      if (ll == vll) {
617                          return p;
618                      }
619                  }
620              }
621              skipcnt = skip;
622          } else {
623              skipcnt--;
624          }
625          p = q + len;
626      }
627      return NULL;
628  }
629  unsigned int ziplistLen(unsigned char *zl) {
630      unsigned int len = 0;
631      if (intrev16ifbe(ZIPLIST_LENGTH(zl)) &lt; UINT16_MAX) {
632          len = intrev16ifbe(ZIPLIST_LENGTH(zl));
633      } else {
634          unsigned char *p = zl+ZIPLIST_HEADER_SIZE;
635          while (*p != ZIP_END) {
636              p += zipRawEntryLength(p);
637              len++;
638          }
639          if (len &lt; UINT16_MAX) ZIPLIST_LENGTH(zl) = intrev16ifbe(len);
640      }
641      return len;
642  }
643  size_t ziplistBlobLen(unsigned char *zl) {
644      return intrev32ifbe(ZIPLIST_BYTES(zl));
645  }
646  void ziplistRepr(unsigned char *zl) {
647      unsigned char *p;
648      int index = 0;
649      zlentry entry;
650      printf(
651          &quot;{total bytes %d} &quot;
652          &quot;{num entries %u}\n&quot;
653          &quot;{tail offset %u}\n&quot;,
654          intrev32ifbe(ZIPLIST_BYTES(zl)),
655          intrev16ifbe(ZIPLIST_LENGTH(zl)),
656          intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)));
657      p = ZIPLIST_ENTRY_HEAD(zl);
658      while(*p != ZIP_END) {
659          zipEntry(p, &amp;entry);
660          printf(
661              &quot;{\n&quot;
662                  &quot;\taddr 0x%08lx,\n&quot;
663                  &quot;\tindex %2d,\n&quot;
664                  &quot;\toffset %5ld,\n&quot;
665                  &quot;\thdr+entry len: %5u,\n&quot;
666                  &quot;\thdr len%2u,\n&quot;
667                  &quot;\tprevrawlen: %5u,\n&quot;
668                  &quot;\tprevrawlensize: %2u,\n&quot;
669                  &quot;\tpayload %5u\n&quot;,
670              (PORT_ULONG)p,
671              index,
672              (PORT_ULONG) (p-zl),
673              entry.headersize+entry.len,
674              entry.headersize,
675              entry.prevrawlen,
676              entry.prevrawlensize,
677              entry.len);
678          printf(&quot;\tbytes: &quot;);
679          for (unsigned int i = 0; i &lt; entry.headersize+entry.len; i++) {
680              printf(&quot;%02x|&quot;,p[i]);
681          }
682          printf(&quot;\n&quot;);
683          p += entry.headersize;
684          if (ZIP_IS_STR(entry.encoding)) {
685              printf(&quot;\t[str]&quot;);
686              if (entry.len &gt; 40) {
687                  if (fwrite(p,40,1,stdout) == 0) perror(&quot;fwrite&quot;);
688                  printf(&quot;...&quot;);
689              } else {
690                  if (entry.len &amp;&amp;
691                      fwrite(p,entry.len,1,stdout) == 0) perror(&quot;fwrite&quot;);
692              }
693          } else {
694              printf(&quot;\t[int]%lld&quot;, (PORT_LONGLONG) zipLoadInteger(p,entry.encoding));
695          }
696          printf(&quot;\n}\n&quot;);
697          p += entry.len;
698          index++;
699      }
700      printf(&quot;{end}\n\n&quot;);
701  }
702  #ifdef REDIS_TEST
703  #include &lt;sys/time.h&gt;
704  #include &quot;adlist.h&quot;
705  #include &quot;sds.h&quot;
706  #define debug(f, ...) { if (DEBUG) printf(f, __VA_ARGS__); }
707  static unsigned char *createList() {
708      unsigned char *zl = ziplistNew();
709      zl = ziplistPush(zl, (unsigned char*)&quot;foo&quot;, 3, ZIPLIST_TAIL);
710      zl = ziplistPush(zl, (unsigned char*)&quot;quux&quot;, 4, ZIPLIST_TAIL);
711      zl = ziplistPush(zl, (unsigned char*)&quot;hello&quot;, 5, ZIPLIST_HEAD);
712      zl = ziplistPush(zl, (unsigned char*)&quot;1024&quot;, 4, ZIPLIST_TAIL);
713      return zl;
714  }
715  static unsigned char *createIntList() {
716      unsigned char *zl = ziplistNew();
717      char buf[32];
718      sprintf(buf, &quot;100&quot;);
719      zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
720      sprintf(buf, &quot;128000&quot;);
721      zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
722      sprintf(buf, &quot;-100&quot;);
723      zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_HEAD);
724      sprintf(buf, &quot;4294967296&quot;);
725      zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_HEAD);
726      sprintf(buf, &quot;non integer&quot;);
727      zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
728      sprintf(buf, &quot;much much longer non integer&quot;);
729      zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
730      return zl;
731  }
732  static PORT_LONGLONG usec(void) {
733  #ifdef _WIN32
734      return GetHighResRelativeTime(1000000);
735  #else
736      struct timeval tv;
737      gettimeofday(&amp;tv,NULL);
738      return (((long long)tv.tv_sec)*1000000)+tv.tv_usec;
739  #endif
740  }
741  static void stress(int pos, int num, int maxsize, int dnum) {
742      int i,j,k;
743      unsigned char *zl;
744      char posstr[2][5] = { &quot;HEAD&quot;, &quot;TAIL&quot; };
745      PORT_LONGLONG start;
746      for (i = 0; i &lt; maxsize; i+=dnum) {
747          zl = ziplistNew();
748          for (j = 0; j &lt; i; j++) {
749              zl = ziplistPush(zl,(unsigned char*)&quot;quux&quot;,4,ZIPLIST_TAIL);
750          }
751          start = usec();
752          for (k = 0; k &lt; num; k++) {
753              zl = ziplistPush(zl,(unsigned char*)&quot;quux&quot;,4,pos);
754              zl = ziplistDeleteRange(zl,0,1);
755          }
756          printf(&quot;List size: %8d, bytes: %8d, %dx push+pop (%s): %6lld usec\n&quot;,
757              i,intrev32ifbe(ZIPLIST_BYTES(zl)),num,posstr[pos],usec()-start);
758          zfree(zl);
759      }
760  }
761  static unsigned char *pop(unsigned char *zl, int where) {
762      unsigned char *p, *vstr;
763      unsigned int vlen;
764      PORT_LONGLONG vlong;
765      p = ziplistIndex(zl,where == ZIPLIST_HEAD ? 0 : -1);
766      if (ziplistGet(p,&amp;vstr,&amp;vlen,&amp;vlong)) {
767          if (where == ZIPLIST_HEAD)
768              printf(&quot;Pop head: &quot;);
769          else
770              printf(&quot;Pop tail: &quot;);
771          if (vstr) {
772              if (vlen &amp;&amp; fwrite(vstr,vlen,1,stdout) == 0) perror(&quot;fwrite&quot;);
773          }
774          else {
775              printf(&quot;%lld&quot;, vlong);
776          }
777          printf(&quot;\n&quot;);
778          return ziplistDelete(zl,&amp;p);
779      } else {
780          printf(&quot;ERROR: Could not pop\n&quot;);
781          exit(1);
782      }
783  }
784  static int randstring(char *target, unsigned int min, unsigned int max) {
785      int p = 0;
786      int len = min+rand()%(max-min+1);
787      int minval, maxval;
788      switch(rand() % 3) {
789      case 0:
790          minval = 0;
791          maxval = 255;
792      break;
793      case 1:
794          minval = 48;
795          maxval = 122;
796      break;
797      case 2:
798          minval = 48;
799          maxval = 52;
800      break;
801      default:
802          assert(NULL);
803      }
804      while(p &lt; len)
805          target[p++] = minval+rand()%(maxval-minval+1);
806      return len;
807  }
808  static void verify(unsigned char *zl, zlentry *e) {
809      int len = ziplistLen(zl);
810      zlentry _e;
811      ZIPLIST_ENTRY_ZERO(&amp;_e);
812      for (int i = 0; i &lt; len; i++) {
813          memset(&amp;e[i], 0, sizeof(zlentry));
814          zipEntry(ziplistIndex(zl, i), &amp;e[i]);
815          memset(&amp;_e, 0, sizeof(zlentry));
816          zipEntry(ziplistIndex(zl, -len+i), &amp;_e);
817          assert(memcmp(&amp;e[i], &amp;_e, sizeof(zlentry)) == 0);
818      }
819  }
820  int ziplistTest(int argc, char **argv) {
821      unsigned char *zl, *p;
822      unsigned char *entry;
823      unsigned int elen;
824      PORT_LONGLONG value;
825      if (argc == 2)
826          srand(atoi(argv[1]));
827      zl = createIntList();
828      ziplistRepr(zl);
829      zfree(zl);
830      zl = createList();
831      ziplistRepr(zl);
832      zl = pop(zl,ZIPLIST_TAIL);
833      ziplistRepr(zl);
834      zl = pop(zl,ZIPLIST_HEAD);
835      ziplistRepr(zl);
836      zl = pop(zl,ZIPLIST_TAIL);
837      ziplistRepr(zl);
838      zl = pop(zl,ZIPLIST_TAIL);
839      ziplistRepr(zl);
840      zfree(zl);
841      printf(&quot;Get element at index 3:\n&quot;);
842      {
843          zl = createList();
844          p = ziplistIndex(zl, 3);
845          if (!ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
846              printf(&quot;ERROR: Could not access index 3\n&quot;);
847              return 1;
848          }
849          if (entry) {
850              if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0) perror(&quot;fwrite&quot;);
851              printf(&quot;\n&quot;);
852          } else {
853              printf(&quot;%lld\n&quot;, value);
854          }
855          printf(&quot;\n&quot;);
856          zfree(zl);
857      }
858      printf(&quot;Get element at index 4 (out of range):\n&quot;);
859      {
860          zl = createList();
861          p = ziplistIndex(zl, 4);
862          if (p == NULL) {
863              printf(&quot;No entry\n&quot;);
864          } else {
865              printf(&quot;ERROR: Out of range index should return NULL, returned offset: %ld\n&quot;, p-zl);
866              return 1;
867          }
868          printf(&quot;\n&quot;);
869          zfree(zl);
870      }
871      printf(&quot;Get element at index -1 (last element):\n&quot;);
872      {
873          zl = createList();
874          p = ziplistIndex(zl, -1);
875          if (!ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
876              printf(&quot;ERROR: Could not access index -1\n&quot;);
877              return 1;
878          }
879          if (entry) {
880              if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0) perror(&quot;fwrite&quot;);
881              printf(&quot;\n&quot;);
882          } else {
883              printf(&quot;%lld\n&quot;, value);
884          }
885          printf(&quot;\n&quot;);
886          zfree(zl);
887      }
888      printf(&quot;Get element at index -4 (first element):\n&quot;);
889      {
890          zl = createList();
891          p = ziplistIndex(zl, -4);
892          if (!ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
893              printf(&quot;ERROR: Could not access index -4\n&quot;);
894              return 1;
895          }
896          if (entry) {
897              if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0) perror(&quot;fwrite&quot;);
898              printf(&quot;\n&quot;);
899          } else {
900              printf(&quot;%lld\n&quot;, value);
901          }
902          printf(&quot;\n&quot;);
903          zfree(zl);
904      }
905      printf(&quot;Get element at index -5 (reverse out of range):\n&quot;);
906      {
907          zl = createList();
908          p = ziplistIndex(zl, -5);
909          if (p == NULL) {
910              printf(&quot;No entry\n&quot;);
911          } else {
912              printf(&quot;ERROR: Out of range index should return NULL, returned offset: %ld\n&quot;, p-zl);
913              return 1;
914          }
915          printf(&quot;\n&quot;);
916          zfree(zl);
917      }
918      printf(&quot;Iterate list from 0 to end:\n&quot;);
919      {
920          zl = createList();
921          p = ziplistIndex(zl, 0);
922          while (ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
923              printf(&quot;Entry: &quot;);
924              if (entry) {
925                  if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0) perror(&quot;fwrite&quot;);
926              } else {
927                  printf(&quot;%lld&quot;, value);
928              }
929              p = ziplistNext(zl,p);
930              printf(&quot;\n&quot;);
931          }
932          printf(&quot;\n&quot;);
933          zfree(zl);
934      }
935      printf(&quot;Iterate list from 1 to end:\n&quot;);
936      {
937          zl = createList();
938          p = ziplistIndex(zl, 1);
939          while (ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
940              printf(&quot;Entry: &quot;);
941              if (entry) {
942                  if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0) perror(&quot;fwrite&quot;);
943              } else {
944                  printf(&quot;%lld&quot;, value);
945              }
946              p = ziplistNext(zl,p);
947              printf(&quot;\n&quot;);
948          }
949          printf(&quot;\n&quot;);
950          zfree(zl);
951      }
952      printf(&quot;Iterate list from 2 to end:\n&quot;);
953      {
954          zl = createList();
955          p = ziplistIndex(zl, 2);
956          while (ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
957              printf(&quot;Entry: &quot;);
958              if (entry) {
959                  if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0) perror(&quot;fwrite&quot;);
960              } else {
961                  printf(&quot;%lld&quot;, value);
962              }
963              p = ziplistNext(zl,p);
964              printf(&quot;\n&quot;);
965          }
966          printf(&quot;\n&quot;);
967          zfree(zl);
968      }
969      printf(&quot;Iterate starting out of range:\n&quot;);
970      {
971          zl = createList();
972          p = ziplistIndex(zl, 4);
973          if (!ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
974              printf(&quot;No entry\n&quot;);
975          } else {
976              printf(&quot;ERROR\n&quot;);
977          }
978          printf(&quot;\n&quot;);
979          zfree(zl);
980      }
981      printf(&quot;Iterate from back to front:\n&quot;);
982      {
983          zl = createList();
984          p = ziplistIndex(zl, -1);
985          while (ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
986              printf(&quot;Entry: &quot;);
987              if (entry) {
988                  if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0) perror(&quot;fwrite&quot;);
989              } else {
990                  printf(&quot;%lld&quot;, value);
991              }
992              p = ziplistPrev(zl,p);
993              printf(&quot;\n&quot;);
994          }
995          printf(&quot;\n&quot;);
996          zfree(zl);
997      }
998      printf(&quot;Iterate from back to front, deleting all items:\n&quot;);
999      {
1000          zl = createList();
1001          p = ziplistIndex(zl, -1);
1002          while (ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
1003              printf(&quot;Entry: &quot;);
1004              if (entry) {
1005                  if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0) perror(&quot;fwrite&quot;);
1006              } else {
1007                  printf(&quot;%lld&quot;, value);
1008              }
1009              zl = ziplistDelete(zl,&amp;p);
1010              p = ziplistPrev(zl,p);
1011              printf(&quot;\n&quot;);
1012          }
1013          printf(&quot;\n&quot;);
1014          zfree(zl);
1015      }
1016      printf(&quot;Delete inclusive range 0,0:\n&quot;);
1017      {
1018          zl = createList();
1019          zl = ziplistDeleteRange(zl, 0, 1);
1020          ziplistRepr(zl);
1021          zfree(zl);
1022      }
1023      printf(&quot;Delete inclusive range 0,1:\n&quot;);
1024      {
1025          zl = createList();
1026          zl = ziplistDeleteRange(zl, 0, 2);
1027          ziplistRepr(zl);
1028          zfree(zl);
1029      }
1030      printf(&quot;Delete inclusive range 1,2:\n&quot;);
1031      {
1032          zl = createList();
1033          zl = ziplistDeleteRange(zl, 1, 2);
1034          ziplistRepr(zl);
1035          zfree(zl);
1036      }
1037      printf(&quot;Delete with start index out of range:\n&quot;);
1038      {
1039          zl = createList();
1040          zl = ziplistDeleteRange(zl, 5, 1);
1041          ziplistRepr(zl);
1042          zfree(zl);
1043      }
1044      printf(&quot;Delete with num overflow:\n&quot;);
1045      {
1046          zl = createList();
1047          zl = ziplistDeleteRange(zl, 1, 5);
1048          ziplistRepr(zl);
1049          zfree(zl);
1050      }
1051      printf(&quot;Delete foo while iterating:\n&quot;);
1052      {
1053          zl = createList();
1054          p = ziplistIndex(zl,0);
1055          while (ziplistGet(p,&amp;entry,&amp;elen,&amp;value)) {
1056              if (entry &amp;&amp; strncmp(&quot;foo&quot;,(char*)entry,elen) == 0) {
1057                  printf(&quot;Delete foo\n&quot;);
1058                  zl = ziplistDelete(zl,&amp;p);
1059              } else {
1060                  printf(&quot;Entry: &quot;);
1061                  if (entry) {
1062                      if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0)
1063                          perror(&quot;fwrite&quot;);
1064                  } else {
1065                      printf(&quot;%lld&quot;,value);
1066                  }
1067                  p = ziplistNext(zl,p);
1068                  printf(&quot;\n&quot;);
1069              }
1070          }
1071          printf(&quot;\n&quot;);
1072          ziplistRepr(zl);
1073          zfree(zl);
1074      }
1075      printf(&quot;Regression test for &gt;255 byte strings:\n&quot;);
1076      {
1077          char v1[257] = {0}, v2[257] = {0};
1078          memset(v1,&#x27;x&#x27;,256);
1079          memset(v2,&#x27;y&#x27;,256);
1080          zl = ziplistNew();
1081          zl = ziplistPush(zl,(unsigned char*)v1,strlen(v1),ZIPLIST_TAIL);
1082          zl = ziplistPush(zl,(unsigned char*)v2,strlen(v2),ZIPLIST_TAIL);
1083          p = ziplistIndex(zl,0);
1084          assert(ziplistGet(p,&amp;entry,&amp;elen,&amp;value));
1085          assert(strncmp(v1,(char*)entry,elen) == 0);
1086          p = ziplistIndex(zl,1);
1087          assert(ziplistGet(p,&amp;entry,&amp;elen,&amp;value));
1088          assert(strncmp(v2,(char*)entry,elen) == 0);
1089          printf(&quot;SUCCESS\n\n&quot;);
1090          zfree(zl);
1091      }
1092      printf(&quot;Regression test deleting next to last entries:\n&quot;);
1093      {
1094          char v[3][257] = {{0}};
1095          zlentry e[3] = {{.prevrawlensize = 0, .prevrawlen = 0, .lensize = 0,
1096                           .len = 0, .headersize = 0, .encoding = 0, .p = NULL}};
1097          size_t i;
1098          for (i = 0; i &lt; (sizeof(v)/sizeof(v[0])); i++) {
1099              memset(v[i], &#x27;a&#x27; + i, sizeof(v[0]));
1100          }
1101          v[0][256] = &#x27;\0&#x27;;
1102          v[1][  1] = &#x27;\0&#x27;;
1103          v[2][256] = &#x27;\0&#x27;;
1104          zl = ziplistNew();
1105          for (i = 0; i &lt; (sizeof(v)/sizeof(v[0])); i++) {
1106              zl = ziplistPush(zl, (unsigned char *) v[i], strlen(v[i]), ZIPLIST_TAIL);
1107          }
1108          verify(zl, e);
1109          assert(e[0].prevrawlensize == 1);
1110          assert(e[1].prevrawlensize == 5);
1111          assert(e[2].prevrawlensize == 1);
1112          unsigned char *p = e[1].p;
1113          zl = ziplistDelete(zl, &amp;p);
1114          verify(zl, e);
1115          assert(e[0].prevrawlensize == 1);
1116          assert(e[1].prevrawlensize == 5);
1117          printf(&quot;SUCCESS\n\n&quot;);
1118          zfree(zl);
1119      }
1120      printf(&quot;Create long list and check indices:\n&quot;);
1121      {
1122          zl = ziplistNew();
1123          char buf[32];
1124          int i,len;
1125          for (i = 0; i &lt; 1000; i++) {
1126              len = sprintf(buf,&quot;%d&quot;,i);
1127              zl = ziplistPush(zl,(unsigned char*)buf,len,ZIPLIST_TAIL);
1128          }
1129          for (i = 0; i &lt; 1000; i++) {
1130              p = ziplistIndex(zl,i);
1131              assert(ziplistGet(p,NULL,NULL,&amp;value));
1132              assert(i == value);
1133              p = ziplistIndex(zl,-i-1);
1134              assert(ziplistGet(p,NULL,NULL,&amp;value));
1135              assert(999-i == value);
1136          }
1137          printf(&quot;SUCCESS\n\n&quot;);
1138          zfree(zl);
1139      }
1140      printf(&quot;Compare strings with ziplist entries:\n&quot;);
1141      {
1142          zl = createList();
1143          p = ziplistIndex(zl,0);
1144          if (!ziplistCompare(p,(unsigned char*)&quot;hello&quot;,5)) {
1145              printf(&quot;ERROR: not \&quot;hello\&quot;\n&quot;);
1146              return 1;
1147          }
1148          if (ziplistCompare(p,(unsigned char*)&quot;hella&quot;,5)) {
1149              printf(&quot;ERROR: \&quot;hella\&quot;\n&quot;);
1150              return 1;
1151          }
1152          p = ziplistIndex(zl,3);
1153          if (!ziplistCompare(p,(unsigned char*)&quot;1024&quot;,4)) {
1154              printf(&quot;ERROR: not \&quot;1024\&quot;\n&quot;);
1155              return 1;
1156          }
1157          if (ziplistCompare(p,(unsigned char*)&quot;1025&quot;,4)) {
1158              printf(&quot;ERROR: \&quot;1025\&quot;\n&quot;);
1159              return 1;
1160          }
1161          printf(&quot;SUCCESS\n\n&quot;);
1162          zfree(zl);
1163      }
1164      printf(&quot;Merge test:\n&quot;);
1165      {
1166          zl = createList();
1167          unsigned char *zl2 = createList();
1168          unsigned char *zl3 = ziplistNew();
1169          unsigned char *zl4 = ziplistNew();
1170          if (ziplistMerge(&amp;zl4, &amp;zl4)) {
1171              printf(&quot;ERROR: Allowed merging of one ziplist into itself.\n&quot;);
1172              return 1;
1173          }
1174          zl4 = ziplistMerge(&amp;zl3, &amp;zl4);
1175          ziplistRepr(zl4);
1176          if (ziplistLen(zl4)) {
1177              printf(&quot;ERROR: Merging two empty ziplists created entries.\n&quot;);
1178              return 1;
1179          }
1180          zfree(zl4);
1181          zl2 = ziplistMerge(&amp;zl, &amp;zl2);
1182          ziplistRepr(zl2);
1183          if (ziplistLen(zl2) != 8) {
1184              printf(&quot;ERROR: Merged length not 8, but: %u\n&quot;, ziplistLen(zl2));
1185              return 1;
1186          }
1187          p = ziplistIndex(zl2,0);
1188          if (!ziplistCompare(p,(unsigned char*)&quot;hello&quot;,5)) {
1189              printf(&quot;ERROR: not \&quot;hello\&quot;\n&quot;);
1190              return 1;
1191          }
1192          if (ziplistCompare(p,(unsigned char*)&quot;hella&quot;,5)) {
1193              printf(&quot;ERROR: \&quot;hella\&quot;\n&quot;);
1194              return 1;
1195          }
1196          p = ziplistIndex(zl2,3);
1197          if (!ziplistCompare(p,(unsigned char*)&quot;1024&quot;,4)) {
1198              printf(&quot;ERROR: not \&quot;1024\&quot;\n&quot;);
1199              return 1;
1200          }
1201          if (ziplistCompare(p,(unsigned char*)&quot;1025&quot;,4)) {
1202              printf(&quot;ERROR: \&quot;1025\&quot;\n&quot;);
1203              return 1;
1204          }
1205          p = ziplistIndex(zl2,4);
1206          if (!ziplistCompare(p,(unsigned char*)&quot;hello&quot;,5)) {
1207              printf(&quot;ERROR: not \&quot;hello\&quot;\n&quot;);
1208              return 1;
1209          }
1210          if (ziplistCompare(p,(unsigned char*)&quot;hella&quot;,5)) {
1211              printf(&quot;ERROR: \&quot;hella\&quot;\n&quot;);
1212              return 1;
1213          }
1214          p = ziplistIndex(zl2,7);
1215          if (!ziplistCompare(p,(unsigned char*)&quot;1024&quot;,4)) {
1216              printf(&quot;ERROR: not \&quot;1024\&quot;\n&quot;);
1217              return 1;
1218          }
1219          if (ziplistCompare(p,(unsigned char*)&quot;1025&quot;,4)) {
1220              printf(&quot;ERROR: \&quot;1025\&quot;\n&quot;);
1221              return 1;
1222          }
1223          printf(&quot;SUCCESS\n\n&quot;);
1224          zfree(zl);
1225      }
1226      printf(&quot;Stress with random payloads of different encoding:\n&quot;);
1227      {
1228          int i,j,len,where;
1229          unsigned char *p;
1230          char buf[1024];
1231          int buflen;
1232          list *ref;
1233          listNode *refnode;
1234          unsigned char *sstr;
1235          unsigned int slen;
1236          PORT_LONGLONG sval;
1237          for (i = 0; i &lt; 20000; i++) {
1238              zl = ziplistNew();
1239              ref = listCreate();
1240              listSetFreeMethod(ref,(void (*)(void*))sdsfree);
1241              len = rand() % 256;
1242              for (j = 0; j &lt; len; j++) {
1243                  where = (rand() &amp; 1) ? ZIPLIST_HEAD : ZIPLIST_TAIL;
1244                  if (rand() % 2) {
1245                      buflen = randstring(buf,1,sizeof(buf)-1);
1246                  } else {
1247                      switch(rand() % 3) {
1248                      case 0:
1249                          buflen = sprintf(buf,&quot;%lld&quot;,(0LL + rand()) &gt;&gt; 20);
1250                          break;
1251                      case 1:
1252                          buflen = sprintf(buf,&quot;%lld&quot;,(0LL + rand()));
1253                          break;
1254                      case 2:
1255                          buflen = sprintf(buf,&quot;%lld&quot;,(0LL + rand()) &lt;&lt; 20);
1256                          break;
1257                      default:
1258                          assert(NULL);
1259                      }
1260                  }
1261                  zl = ziplistPush(zl, (unsigned char*)buf, buflen, where);
1262                  if (where == ZIPLIST_HEAD) {
1263                      listAddNodeHead(ref,sdsnewlen(buf, buflen));
1264                  } else if (where == ZIPLIST_TAIL) {
1265                      listAddNodeTail(ref,sdsnewlen(buf, buflen));
1266                  } else {
1267                      assert(NULL);
1268                  }
1269              }
1270              assert(listLength(ref) == ziplistLen(zl));
1271              for (j = 0; j &lt; len; j++) {
1272                  p = ziplistIndex(zl,j);
1273                  refnode = listIndex(ref,j);
1274                  assert(ziplistGet(p,&amp;sstr,&amp;slen,&amp;sval));
1275                  if (sstr == NULL) {
1276                      buflen = sprintf(buf,&quot;%lld&quot;,sval);
1277                  } else {
1278                      buflen = slen;
1279                      memcpy(buf,sstr,buflen);
1280                      buf[buflen] = &#x27;\0&#x27;;
1281                  }
1282                  assert(memcmp(buf,listNodeValue(refnode),buflen) == 0);
1283              }
1284              zfree(zl);
1285              listRelease(ref);
1286          }
1287          printf(&quot;SUCCESS\n\n&quot;);
1288      }
1289      printf(&quot;Stress with variable ziplist size:\n&quot;);
1290      {
1291          stress(ZIPLIST_HEAD,100000,16384,256);
1292          stress(ZIPLIST_TAIL,100000,16384,256);
1293      }
1294      return 0;
1295  }
1296  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-ziplist.c</h3>
            <pre><code>1  #include &lt;stdio.h&gt;
2  #include &lt;stdlib.h&gt;
3  #include &lt;string.h&gt;
4  #include &lt;stdint.h&gt;
5  #include &lt;limits.h&gt;
6  #include &quot;zmalloc.h&quot;
7  #include &quot;util.h&quot;
8  #include &quot;ziplist.h&quot;
9  #include &quot;endianconv.h&quot;
10  #include &quot;redisassert.h&quot;
11  #ifdef _WIN32
12  #include &quot;Win32_Interop/Win32_FDAPI.h&quot;
13  #endif
14  #define ZIP_END 255         &amp;bsol;* Special &quot;end of ziplist&quot; entry. */
15  #define ZIP_BIG_PREVLEN 254 &amp;bsol;* Max number of bytes of the previous entry, for
16                                 the &quot;prevlen&quot; field prefixing each entry, to be
17                                 represented with just a single byte. Otherwise
18                                 it is represented as FF AA BB CC DD, where
19                                 AA BB CC DD are a 4 bytes unsigned integer
20                                 representing the previous entry len. */
21  #define ZIP_STR_MASK 0xc0
22  #define ZIP_INT_MASK 0x30
23  #define ZIP_STR_06B (0 &lt;&lt; 6)
24  #define ZIP_STR_14B (1 &lt;&lt; 6)
25  #define ZIP_STR_32B (2 &lt;&lt; 6)
26  #define ZIP_INT_16B (0xc0 | 0&lt;&lt;4)
27  #define ZIP_INT_32B (0xc0 | 1&lt;&lt;4)
28  #define ZIP_INT_64B (0xc0 | 2&lt;&lt;4)
29  #define ZIP_INT_24B (0xc0 | 3&lt;&lt;4)
30  #define ZIP_INT_8B 0xfe
31  #define ZIP_INT_IMM_MASK 0x0f   &amp;bsol;* Mask to extract the 4 bits value. To add
32                                     one is needed to reconstruct the value. */
33  #define ZIP_INT_IMM_MIN 0xf1    &amp;bsol;* 11110001 */
34  #define ZIP_INT_IMM_MAX 0xfd    &amp;bsol;* 11111101 */
35  #define INT24_MAX 0x7fffff
36  #define INT24_MIN (-INT24_MAX - 1)
37  #define ZIP_IS_STR(enc) (((enc) &amp; ZIP_STR_MASK) &lt; ZIP_STR_MASK)
38  #define ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))
39  #define ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))
40  #define ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))
41  #define ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))
42  #define ZIPLIST_END_SIZE        (sizeof(uint8_t))
43  #define ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)
44  #define ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))
45  #define ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)
46  #define ZIPLIST_INCR_LENGTH(zl,incr) { \
47      if (ZIPLIST_LENGTH(zl) &lt; UINT16_MAX) \
48          ZIPLIST_LENGTH(zl) = intrev16ifbe(intrev16ifbe(ZIPLIST_LENGTH(zl))+incr); \
49  }
50  typedef struct zlentry {
51      unsigned int prevrawlensize; &amp;bsol;* Bytes used to encode the previous entry len*/
52      unsigned int prevrawlen;     &amp;bsol;* Previous entry len. */
53      unsigned int lensize;        &amp;bsol;* Bytes used to encode this entry type/len.
54                                      For example strings have a 1, 2 or 5 bytes
55                                      header. Integers always use a single byte.*/
56      unsigned int len;            &amp;bsol;* Bytes used to represent the actual entry.
57                                      For strings this is just the string length
58                                      while for integers it is 1, 2, 3, 4, 8 or
59                                      0 (for 4 bit immediate) depending on the
60                                      number range. */
61      unsigned int headersize;     &amp;bsol;* prevrawlensize + lensize. */
62      unsigned char encoding;      &amp;bsol;* Set to ZIP_STR_* or ZIP_INT_* depending on
63                                      the entry encoding. However for 4 bits
64                                      immediate integers this can assume a range
65                                      of values and must be range-checked. */
66      unsigned char *p;            &amp;bsol;* Pointer to the very start of the entry, that
67                                      is, this points to prev-entry-len field. */
68  } zlentry;
69  #define ZIPLIST_ENTRY_ZERO(zle) { \
70      (zle)-&gt;prevrawlensize = (zle)-&gt;prevrawlen = 0; \
71      (zle)-&gt;lensize = (zle)-&gt;len = (zle)-&gt;headersize = 0; \
72      (zle)-&gt;encoding = 0; \
73      (zle)-&gt;p = NULL; \
74  }
75  #define ZIP_ENTRY_ENCODING(ptr, encoding) do {  \
76      (encoding) = (ptr[0]); \
77      if ((encoding) &lt; ZIP_STR_MASK) (encoding) &amp;= ZIP_STR_MASK; \
78  } while(0)
79  unsigned int zipIntSize(unsigned char encoding) {
80      switch(encoding) {
81      case ZIP_INT_8B:  return 1;
82      case ZIP_INT_16B: return 2;
83      case ZIP_INT_24B: return 3;
84      case ZIP_INT_32B: return 4;
85      case ZIP_INT_64B: return 8;
86      }
87      if (encoding &gt;= ZIP_INT_IMM_MIN &amp;&amp; encoding &lt;= ZIP_INT_IMM_MAX)
88          return 0; &amp;bsol;* 4 bit immediate */
89      panic(&quot;Invalid integer encoding 0x%02X&quot;, encoding);
90      return 0;
91  }
92  unsigned int zipStoreEntryEncoding(unsigned char *p, unsigned char encoding, unsigned int rawlen) {
93      unsigned char len = 1, buf[5];
94      if (ZIP_IS_STR(encoding)) {
95          if (rawlen &lt;= 0x3f) {
96              if (!p) return len;
97              buf[0] = ZIP_STR_06B | rawlen;
98          } else if (rawlen &lt;= 0x3fff) {
99              len += 1;
100              if (!p) return len;
101              buf[0] = ZIP_STR_14B | ((rawlen &gt;&gt; 8) &amp; 0x3f);
102              buf[1] = rawlen &amp; 0xff;
103          } else {
104              len += 4;
105              if (!p) return len;
106              buf[0] = ZIP_STR_32B;
107              buf[1] = (rawlen &gt;&gt; 24) &amp; 0xff;
108              buf[2] = (rawlen &gt;&gt; 16) &amp; 0xff;
109              buf[3] = (rawlen &gt;&gt; 8) &amp; 0xff;
110              buf[4] = rawlen &amp; 0xff;
111          }
112      } else {
113          if (!p) return len;
114          buf[0] = encoding;
115      }
116      memcpy(p,buf,len);
117      return len;
118  }
119  #define ZIP_DECODE_LENGTH(ptr, encoding, lensize, len) do {                    \
120      ZIP_ENTRY_ENCODING((ptr), (encoding));                                     \
121      if ((encoding) &lt; ZIP_STR_MASK) {                                           \
122          if ((encoding) == ZIP_STR_06B) {                                       \
123              (lensize) = 1;                                                     \
124              (len) = (ptr)[0] &amp; 0x3f;                                           \
125          } else if ((encoding) == ZIP_STR_14B) {                                \
126              (lensize) = 2;                                                     \
127              (len) = (((ptr)[0] &amp; 0x3f) &lt;&lt; 8) | (ptr)[1];                       \
128          } else if ((encoding) == ZIP_STR_32B) {                                \
129              (lensize) = 5;                                                     \
130              (len) = ((ptr)[1] &lt;&lt; 24) |                                         \
131                      ((ptr)[2] &lt;&lt; 16) |                                         \
132                      ((ptr)[3] &lt;&lt;  8) |                                         \
133                      ((ptr)[4]);                                                \
134          } else {                                                               \
135              panic(&quot;Invalid string encoding 0x%02X&quot;, (encoding));               \
136          }                                                                      \
137      } else {                                                                   \
138          (lensize) = 1;                                                         \
139          (len) = zipIntSize(encoding);                                          \
140      }                                                                          \
141  } while(0);
142  int zipStorePrevEntryLengthLarge(unsigned char *p, unsigned int len) {
143      if (p != NULL) {
144          p[0] = ZIP_BIG_PREVLEN;
145          memcpy(p+1,&amp;len,sizeof(len));
146          memrev32ifbe(p+1);
147      }
148      return 1+sizeof(len);
149  }
150  unsigned int zipStorePrevEntryLength(unsigned char *p, unsigned int len) {
151      if (p == NULL) {
152          return (len &lt; ZIP_BIG_PREVLEN) ? 1 : sizeof(len)+1;
153      } else {
154          if (len &lt; ZIP_BIG_PREVLEN) {
155              p[0] = len;
156              return 1;
157          } else {
158              return zipStorePrevEntryLengthLarge(p,len);
159          }
160      }
161  }
162  #define ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do {                          \
163      if ((ptr)[0] &lt; ZIP_BIG_PREVLEN) {                                          \
164          (prevlensize) = 1;                                                     \
165      } else {                                                                   \
166          (prevlensize) = 5;                                                     \
167      }                                                                          \
168  } while(0);
169  #define ZIP_DECODE_PREVLEN(ptr, prevlensize, prevlen) do {                     \
170      ZIP_DECODE_PREVLENSIZE(ptr, prevlensize);                                  \
171      if ((prevlensize) == 1) {                                                  \
172          (prevlen) = (ptr)[0];                                                  \
173      } else if ((prevlensize) == 5) {                                           \
174          assert(sizeof((prevlen)) == 4);                                    \
175          memcpy(&amp;(prevlen), ((char*)(ptr)) + 1, 4);                             \
176          memrev32ifbe(&amp;prevlen);                                                \
177      }                                                                          \
178  } while(0);
179  int zipPrevLenByteDiff(unsigned char *p, unsigned int len) {
180      unsigned int prevlensize;
181      ZIP_DECODE_PREVLENSIZE(p, prevlensize);
182      return zipStorePrevEntryLength(NULL, len) - prevlensize;
183  }
184  unsigned int zipRawEntryLength(unsigned char *p) {
185      unsigned int prevlensize, encoding, lensize, len;
186      ZIP_DECODE_PREVLENSIZE(p, prevlensize);
187      ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len);
188      return prevlensize + lensize + len;
189  }
190  int zipTryEncoding(unsigned char *entry, unsigned int entrylen, PORT_LONGLONG *v, unsigned char *encoding) {
191      PORT_LONGLONG value;
192      if (entrylen &gt;= 32 || entrylen == 0) return 0;
193      if (string2ll((char*)entry,entrylen,&amp;value)) {
194          if (value &gt;= 0 &amp;&amp; value &lt;= 12) {
195              *encoding = (unsigned char)(ZIP_INT_IMM_MIN+value);                 WIN_PORT_FIX &amp;bsol;* cast (unsigned char) */
196          } else if (value &gt;= INT8_MIN &amp;&amp; value &lt;= INT8_MAX) {
197              *encoding = ZIP_INT_8B;
198          } else if (value &gt;= INT16_MIN &amp;&amp; value &lt;= INT16_MAX) {
199              *encoding = ZIP_INT_16B;
200          } else if (value &gt;= INT24_MIN &amp;&amp; value &lt;= INT24_MAX) {
201              *encoding = ZIP_INT_24B;
202          } else if (value &gt;= INT32_MIN &amp;&amp; value &lt;= INT32_MAX) {
203              *encoding = ZIP_INT_32B;
204          } else {
205              *encoding = ZIP_INT_64B;
206          }
207          *v = value;
208          return 1;
209      }
210      return 0;
211  }
212  void zipSaveInteger(unsigned char *p, int64_t value, unsigned char encoding) {
213      int16_t i16;
214      int32_t i32;
215      int64_t i64;
216      if (encoding == ZIP_INT_8B) {
217          ((int8_t*)p)[0] = (int8_t)value;
218      } else if (encoding == ZIP_INT_16B) {
219          i16 = (int16_t)value;                                                   WIN_PORT_FIX &amp;bsol;* cast (int16_t) */
220          memcpy(p,&amp;i16,sizeof(i16));
221          memrev16ifbe(p);
222      } else if (encoding == ZIP_INT_24B) {
223          i32 = (int32_t)(value&lt;&lt;8);                                              WIN_PORT_FIX &amp;bsol;* cast (int32_t) */
224          memrev32ifbe(&amp;i32);
225          memcpy(p,((uint8_t*)&amp;i32)+1,sizeof(i32)-sizeof(uint8_t));
226      } else if (encoding == ZIP_INT_32B) {
227          i32 = (int32_t)value;                                                   WIN_PORT_FIX &amp;bsol;* cast (int32_t) */
228          memcpy(p,&amp;i32,sizeof(i32));
229          memrev32ifbe(p);
230      } else if (encoding == ZIP_INT_64B) {
231          i64 = value;
232          memcpy(p,&amp;i64,sizeof(i64));
233          memrev64ifbe(p);
234      } else if (encoding &gt;= ZIP_INT_IMM_MIN &amp;&amp; encoding &lt;= ZIP_INT_IMM_MAX) {
235      } else {
236          assert(NULL);
237      }
238  }
239  int64_t zipLoadInteger(unsigned char *p, unsigned char encoding) {
240      int16_t i16;
241      int32_t i32;
242      int64_t i64, ret = 0;
243      if (encoding == ZIP_INT_8B) {
244          ret = ((int8_t*)p)[0];
245      } else if (encoding == ZIP_INT_16B) {
246          memcpy(&amp;i16,p,sizeof(i16));
247          memrev16ifbe(&amp;i16);
248          ret = i16;
249      } else if (encoding == ZIP_INT_32B) {
250          memcpy(&amp;i32,p,sizeof(i32));
251          memrev32ifbe(&amp;i32);
252          ret = i32;
253      } else if (encoding == ZIP_INT_24B) {
254          i32 = 0;
255          memcpy(((uint8_t*)&amp;i32)+1,p,sizeof(i32)-sizeof(uint8_t));
256          memrev32ifbe(&amp;i32);
257          ret = i32&gt;&gt;8;
258      } else if (encoding == ZIP_INT_64B) {
259          memcpy(&amp;i64,p,sizeof(i64));
260          memrev64ifbe(&amp;i64);
261          ret = i64;
262      } else if (encoding &gt;= ZIP_INT_IMM_MIN &amp;&amp; encoding &lt;= ZIP_INT_IMM_MAX) {
263          ret = (encoding &amp; ZIP_INT_IMM_MASK)-1;
264      } else {
265          assert(NULL);
266      }
267      return ret;
268  }
269  void zipEntry(unsigned char *p, zlentry *e) {
270      ZIP_DECODE_PREVLEN(p, e-&gt;prevrawlensize, e-&gt;prevrawlen);
271      ZIP_DECODE_LENGTH(p + e-&gt;prevrawlensize, e-&gt;encoding, e-&gt;lensize, e-&gt;len);
272      e-&gt;headersize = e-&gt;prevrawlensize + e-&gt;lensize;
273      e-&gt;p = p;
274  }
275  unsigned char *ziplistNew(void) {
276      unsigned int bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;
277      unsigned char *zl = zmalloc(bytes);
278      ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);
279      ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);
280      ZIPLIST_LENGTH(zl) = 0;
281      zl[bytes-1] = ZIP_END;
282      return zl;
283  }
284  unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {
285      zl = zrealloc(zl,len);
286      ZIPLIST_BYTES(zl) = intrev32ifbe(len);
287      zl[len-1] = ZIP_END;
288      return zl;
289  }
290  unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p) {
291      size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;
292      size_t offset, noffset, extra;
293      unsigned char *np;
294      zlentry cur, next;
295      while (p[0] != ZIP_END) {
296          zipEntry(p, &amp;cur);
297          rawlen = cur.headersize + cur.len;
298          rawlensize = zipStorePrevEntryLength(NULL,(unsigned int)rawlen);            WIN_PORT_FIX &amp;bsol;* cast (unsigned int) */
299          if (p[rawlen] == ZIP_END) break;
300          zipEntry(p+rawlen, &amp;next);
301          if (next.prevrawlen == rawlen) break;
302          if (next.prevrawlensize &lt; rawlensize) {
303              offset = p-zl;
304              extra = rawlensize-next.prevrawlensize;
305              zl = ziplistResize(zl,(unsigned int)(curlen+extra));                WIN_PORT_FIX &amp;bsol;* cast (unsigned int) */
306              p = zl+offset;
307              np = p+rawlen;
308              noffset = np-zl;
309              if ((zl+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np) {
310                  ZIPLIST_TAIL_OFFSET(zl) =
311                      (uint32_t)intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+extra); WIN_PORT_FIX &amp;bsol;* cast (uint32_t) */
312              }
313              memmove(np+rawlensize,
314                  np+next.prevrawlensize,
315                  curlen-noffset-next.prevrawlensize-1);
316              zipStorePrevEntryLength(np,(unsigned int)rawlen);                       WIN_PORT_FIX &amp;bsol;* cast (unsigned int) */
317              p += rawlen;
318              curlen += extra;
319          } else {
320              if (next.prevrawlensize &gt; rawlensize) {
321                  zipStorePrevEntryLengthLarge(p+rawlen,(unsigned int)rawlen);
322              } else {
323                  zipStorePrevEntryLength(p+rawlen,(unsigned int)rawlen);
324              }
325              break;
326          }
327      }
328      return zl;
329  }
330  unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num) {
331      unsigned int i, totlen, deleted = 0;
332      size_t offset;
333      int nextdiff = 0;
334      zlentry first, tail;
335      zipEntry(p, &amp;first);
336      for (i = 0; p[0] != ZIP_END &amp;&amp; i &lt; num; i++) {
337          p += zipRawEntryLength(p);
338          deleted++;
339      }
340      totlen = (unsigned int)(p-first.p); &amp;bsol;* Bytes taken by the element(s) to delete. */ WIN_PORT_FIX &amp;bsol;* cast (unsigned int) */
341      if (totlen &gt; 0) {
342          if (p[0] != ZIP_END) {
343              nextdiff = zipPrevLenByteDiff(p,first.prevrawlen);
344              p -= nextdiff;
345              zipStorePrevEntryLength(p,first.prevrawlen);
346              ZIPLIST_TAIL_OFFSET(zl) =
347                  intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))-totlen);
348              zipEntry(p, &amp;tail);
349              if (p[tail.headersize+tail.len] != ZIP_END) {
350                  ZIPLIST_TAIL_OFFSET(zl) =
351                     intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);
352              }
353              memmove(first.p,p,
354                  intrev32ifbe(ZIPLIST_BYTES(zl))-(p-zl)-1);
355          } else {
356              ZIPLIST_TAIL_OFFSET(zl) =
357                  (unsigned int)intrev32ifbe((first.p-zl)-first.prevrawlen);      WIN_PORT_FIX &amp;bsol;* cast (unsigned int) */
358          }
359          offset = first.p-zl;
360          zl = ziplistResize(zl, intrev32ifbe(ZIPLIST_BYTES(zl))-totlen+nextdiff);
361          ZIPLIST_INCR_LENGTH(zl,-deleted);
362          p = zl+offset;
363          if (nextdiff != 0)
364              zl = __ziplistCascadeUpdate(zl,p);
365      }
366      return zl;
367  }
368  unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {
369      size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;
370      unsigned int prevlensize, prevlen = 0;
371      size_t offset;
372      int nextdiff = 0;
373      unsigned char encoding = 0;
374      PORT_LONGLONG value = 123456789; &amp;bsol;* initialized to avoid warning. Using a value
375                                      that is easy to see if for some reason
376                                      we use it uninitialized. */
377      zlentry tail;
378      if (p[0] != ZIP_END) {
379          ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
380      } else {
381          unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);
382          if (ptail[0] != ZIP_END) {
383              prevlen = zipRawEntryLength(ptail);
384          }
385      }
386      if (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) {
387          reqlen = zipIntSize(encoding);
388      } else {
389          reqlen = slen;
390      }
391      reqlen += zipStorePrevEntryLength(NULL,(unsigned int)prevlen); WIN_PORT_FIX &amp;bsol;* cast (unsigned int) */
392      reqlen += zipStoreEntryEncoding(NULL,encoding,slen);
393      int forcelarge = 0;
394      nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,(unsigned int)reqlen) : 0;  WIN_PORT_FIX &amp;bsol;* cast (unsigned int) */
395      if (nextdiff == -4 &amp;&amp; reqlen &lt; 4) {
396          nextdiff = 0;
397          forcelarge = 1;
398      }
399      offset = p-zl;
400      zl = ziplistResize(zl,(unsigned int)(curlen+reqlen+nextdiff));              WIN_PORT_FIX &amp;bsol;* cast (unsigned int) */
401      p = zl+offset;
402      if (p[0] != ZIP_END) {
403          memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);
404          if (forcelarge)
405              zipStorePrevEntryLengthLarge(p+reqlen,reqlen);
406          else
407              zipStorePrevEntryLength(p+reqlen,reqlen);
408          ZIPLIST_TAIL_OFFSET(zl) =
409              (uint32_t)intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen); WIN_PORT_FIX &amp;bsol;* cast (uint32_t) */
410          zipEntry(p+reqlen, &amp;tail);
411          if (p[reqlen+tail.headersize+tail.len] != ZIP_END) {
412              ZIPLIST_TAIL_OFFSET(zl) =
413                  intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);
414          }
415      } else {
416          ZIPLIST_TAIL_OFFSET(zl) = (uint32_t)intrev32ifbe(p-zl);                 WIN_PORT_FIX &amp;bsol;* cast (uint32_) */
417      }
418      if (nextdiff != 0) {
419          offset = p-zl;
420          zl = __ziplistCascadeUpdate(zl,p+reqlen);
421          p = zl+offset;
422      }
423      p += zipStorePrevEntryLength(p,prevlen);
424      p += zipStoreEntryEncoding(p,encoding,slen);
425      if (ZIP_IS_STR(encoding)) {
426          memcpy(p,s,slen);
427      } else {
428          zipSaveInteger(p,value,encoding);
429      }
430      ZIPLIST_INCR_LENGTH(zl,1);
431      return zl;
432  }
433  unsigned char *ziplistMerge(unsigned char **first, unsigned char **second) {
434      if (first == NULL || *first == NULL || second == NULL || *second == NULL)
435          return NULL;
436      if (*first == *second)
437          return NULL;
438      size_t first_bytes = intrev32ifbe(ZIPLIST_BYTES(*first));
439      size_t first_len = intrev16ifbe(ZIPLIST_LENGTH(*first));
440      size_t second_bytes = intrev32ifbe(ZIPLIST_BYTES(*second));
441      size_t second_len = intrev16ifbe(ZIPLIST_LENGTH(*second));
442      int append;
443      unsigned char *source, *target;
444      size_t target_bytes, source_bytes;
445      if (first_len &gt;= second_len) {
446          target = *first;
447          target_bytes = first_bytes;
448          source = *second;
449          source_bytes = second_bytes;
450          append = 1;
451      } else {
452          target = *second;
453          target_bytes = second_bytes;
454          source = *first;
455          source_bytes = first_bytes;
456          append = 0;
457      }
458      size_t zlbytes = first_bytes + second_bytes -
459                       ZIPLIST_HEADER_SIZE - ZIPLIST_END_SIZE;
460      size_t zllength = first_len + second_len;
461      zllength = zllength &lt; UINT16_MAX ? zllength : UINT16_MAX;
<span onclick='openModal()' class='match'>462      size_t first_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*first));
463      size_t second_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*second));
464      target = zrealloc(target, zlbytes);
</span>465      if (append) {
466          memcpy(target + target_bytes - ZIPLIST_END_SIZE,
467                 source + ZIPLIST_HEADER_SIZE,
468                 source_bytes - ZIPLIST_HEADER_SIZE);
469      } else {
470          memmove(target + source_bytes - ZIPLIST_END_SIZE,
471                  target + ZIPLIST_HEADER_SIZE,
472                  target_bytes - ZIPLIST_HEADER_SIZE);
473          memcpy(target, source, source_bytes - ZIPLIST_END_SIZE);
474      }
475      ZIPLIST_BYTES(target) = intrev32ifbe(zlbytes);
476      ZIPLIST_LENGTH(target) = intrev16ifbe(zllength);
477      ZIPLIST_TAIL_OFFSET(target) = intrev32ifbe(
478                                     (first_bytes - ZIPLIST_END_SIZE) +
479                                     (second_offset - ZIPLIST_HEADER_SIZE));
480      target = __ziplistCascadeUpdate(target, target+first_offset);
481      if (append) {
482          zfree(*second);
483          *second = NULL;
484          *first = target;
485      } else {
486          zfree(*first);
487          *first = NULL;
488          *second = target;
489      }
490      return target;
491  }
492  unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where) {
493      unsigned char *p;
494      p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);
495      return __ziplistInsert(zl,p,s,slen);
496  }
497  unsigned char *ziplistIndex(unsigned char *zl, int index) {
498      unsigned char *p;
499      unsigned int prevlensize, prevlen = 0;
500      if (index &lt; 0) {
501          index = (-index)-1;
502          p = ZIPLIST_ENTRY_TAIL(zl);
503          if (p[0] != ZIP_END) {
504              ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
505              while (prevlen &gt; 0 &amp;&amp; index--) {
506                  p -= prevlen;
507                  ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
508              }
509          }
510      } else {
511          p = ZIPLIST_ENTRY_HEAD(zl);
512          while (p[0] != ZIP_END &amp;&amp; index--) {
513              p += zipRawEntryLength(p);
514          }
515      }
516      return (p[0] == ZIP_END || index &gt; 0) ? NULL : p;
517  }
518  unsigned char *ziplistNext(unsigned char *zl, unsigned char *p) {
519      ((void) zl);
520      if (p[0] == ZIP_END) {
521          return NULL;
522      }
523      p += zipRawEntryLength(p);
524      if (p[0] == ZIP_END) {
525          return NULL;
526      }
527      return p;
528  }
529  unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p) {
530      unsigned int prevlensize, prevlen = 0;
531      if (p[0] == ZIP_END) {
532          p = ZIPLIST_ENTRY_TAIL(zl);
533          return (p[0] == ZIP_END) ? NULL : p;
534      } else if (p == ZIPLIST_ENTRY_HEAD(zl)) {
535          return NULL;
536      } else {
537          ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
538          assert(prevlen &gt; 0);
539          return p-prevlen;
540      }
541  }
542  unsigned int ziplistGet(unsigned char *p, unsigned char **sstr, unsigned int *slen, PORT_LONGLONG *sval) {
543      zlentry entry;
544      if (p == NULL || p[0] == ZIP_END) return 0;
545      if (sstr) *sstr = NULL;
546      zipEntry(p, &amp;entry);
547      if (ZIP_IS_STR(entry.encoding)) {
548          if (sstr) {
549              *slen = entry.len;
550              *sstr = p+entry.headersize;
551          }
552      } else {
553          if (sval) {
554              *sval = zipLoadInteger(p+entry.headersize,entry.encoding);
555          }
556      }
557      return 1;
558  }
559  unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {
560      return __ziplistInsert(zl,p,s,slen);
561  }
562  unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p) {
563      size_t offset = *p-zl;
564      zl = __ziplistDelete(zl,*p,1);
565      *p = zl+offset;
566      return zl;
567  }
568  unsigned char *ziplistDeleteRange(unsigned char *zl, int index, unsigned int num) {
569      unsigned char *p = ziplistIndex(zl,index);
570      return (p == NULL) ? zl : __ziplistDelete(zl,p,num);
571  }
572  unsigned int ziplistCompare(unsigned char *p, unsigned char *sstr, unsigned int slen) {
573      zlentry entry;
574      unsigned char sencoding;
575      PORT_LONGLONG zval, sval;
576      if (p[0] == ZIP_END) return 0;
577      zipEntry(p, &amp;entry);
578      if (ZIP_IS_STR(entry.encoding)) {
579          if (entry.len == slen) {
580              return memcmp(p+entry.headersize,sstr,slen) == 0;
581          } else {
582              return 0;
583          }
584      } else {
585          if (zipTryEncoding(sstr,slen,&amp;sval,&amp;sencoding)) {
586            zval = zipLoadInteger(p+entry.headersize,entry.encoding);
587            return zval == sval;
588          }
589      }
590      return 0;
591  }
592  unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip) {
593      int skipcnt = 0;
594      unsigned char vencoding = 0;
595      PORT_LONGLONG vll = 0;
596      while (p[0] != ZIP_END) {
597          unsigned int prevlensize, encoding, lensize, len;
598          unsigned char *q;
599          ZIP_DECODE_PREVLENSIZE(p, prevlensize);
600          ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len);
601          q = p + prevlensize + lensize;
602          if (skipcnt == 0) {
603              if (ZIP_IS_STR(encoding)) {
604                  if (len == vlen &amp;&amp; memcmp(q, vstr, vlen) == 0) {
605                      return p;
606                  }
607              } else {
608                  if (vencoding == 0) {
609                      if (!zipTryEncoding(vstr, vlen, &amp;vll, &amp;vencoding)) {
610                          vencoding = UCHAR_MAX;
611                      }
612                      assert(vencoding);
613                  }
614                  if (vencoding != UCHAR_MAX) {
615                      PORT_LONGLONG ll = zipLoadInteger(q, encoding);
616                      if (ll == vll) {
617                          return p;
618                      }
619                  }
620              }
621              skipcnt = skip;
622          } else {
623              skipcnt--;
624          }
625          p = q + len;
626      }
627      return NULL;
628  }
629  unsigned int ziplistLen(unsigned char *zl) {
630      unsigned int len = 0;
631      if (intrev16ifbe(ZIPLIST_LENGTH(zl)) &lt; UINT16_MAX) {
632          len = intrev16ifbe(ZIPLIST_LENGTH(zl));
633      } else {
634          unsigned char *p = zl+ZIPLIST_HEADER_SIZE;
635          while (*p != ZIP_END) {
636              p += zipRawEntryLength(p);
637              len++;
638          }
639          if (len &lt; UINT16_MAX) ZIPLIST_LENGTH(zl) = intrev16ifbe(len);
640      }
641      return len;
642  }
643  size_t ziplistBlobLen(unsigned char *zl) {
644      return intrev32ifbe(ZIPLIST_BYTES(zl));
645  }
646  void ziplistRepr(unsigned char *zl) {
647      unsigned char *p;
648      int index = 0;
649      zlentry entry;
650      printf(
651          &quot;{total bytes %d} &quot;
652          &quot;{num entries %u}\n&quot;
653          &quot;{tail offset %u}\n&quot;,
654          intrev32ifbe(ZIPLIST_BYTES(zl)),
655          intrev16ifbe(ZIPLIST_LENGTH(zl)),
656          intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)));
657      p = ZIPLIST_ENTRY_HEAD(zl);
658      while(*p != ZIP_END) {
659          zipEntry(p, &amp;entry);
660          printf(
661              &quot;{\n&quot;
662                  &quot;\taddr 0x%08lx,\n&quot;
663                  &quot;\tindex %2d,\n&quot;
664                  &quot;\toffset %5ld,\n&quot;
665                  &quot;\thdr+entry len: %5u,\n&quot;
666                  &quot;\thdr len%2u,\n&quot;
667                  &quot;\tprevrawlen: %5u,\n&quot;
668                  &quot;\tprevrawlensize: %2u,\n&quot;
669                  &quot;\tpayload %5u\n&quot;,
670              (PORT_ULONG)p,
671              index,
672              (PORT_ULONG) (p-zl),
673              entry.headersize+entry.len,
674              entry.headersize,
675              entry.prevrawlen,
676              entry.prevrawlensize,
677              entry.len);
678          printf(&quot;\tbytes: &quot;);
679          for (unsigned int i = 0; i &lt; entry.headersize+entry.len; i++) {
680              printf(&quot;%02x|&quot;,p[i]);
681          }
682          printf(&quot;\n&quot;);
683          p += entry.headersize;
684          if (ZIP_IS_STR(entry.encoding)) {
685              printf(&quot;\t[str]&quot;);
686              if (entry.len &gt; 40) {
687                  if (fwrite(p,40,1,stdout) == 0) perror(&quot;fwrite&quot;);
688                  printf(&quot;...&quot;);
689              } else {
690                  if (entry.len &amp;&amp;
691                      fwrite(p,entry.len,1,stdout) == 0) perror(&quot;fwrite&quot;);
692              }
693          } else {
694              printf(&quot;\t[int]%lld&quot;, (PORT_LONGLONG) zipLoadInteger(p,entry.encoding));
695          }
696          printf(&quot;\n}\n&quot;);
697          p += entry.len;
698          index++;
699      }
700      printf(&quot;{end}\n\n&quot;);
701  }
702  #ifdef REDIS_TEST
703  #include &lt;sys/time.h&gt;
704  #include &quot;adlist.h&quot;
705  #include &quot;sds.h&quot;
706  #define debug(f, ...) { if (DEBUG) printf(f, __VA_ARGS__); }
707  static unsigned char *createList() {
708      unsigned char *zl = ziplistNew();
709      zl = ziplistPush(zl, (unsigned char*)&quot;foo&quot;, 3, ZIPLIST_TAIL);
710      zl = ziplistPush(zl, (unsigned char*)&quot;quux&quot;, 4, ZIPLIST_TAIL);
711      zl = ziplistPush(zl, (unsigned char*)&quot;hello&quot;, 5, ZIPLIST_HEAD);
712      zl = ziplistPush(zl, (unsigned char*)&quot;1024&quot;, 4, ZIPLIST_TAIL);
713      return zl;
714  }
715  static unsigned char *createIntList() {
716      unsigned char *zl = ziplistNew();
717      char buf[32];
718      sprintf(buf, &quot;100&quot;);
719      zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
720      sprintf(buf, &quot;128000&quot;);
721      zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
722      sprintf(buf, &quot;-100&quot;);
723      zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_HEAD);
724      sprintf(buf, &quot;4294967296&quot;);
725      zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_HEAD);
726      sprintf(buf, &quot;non integer&quot;);
727      zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
728      sprintf(buf, &quot;much much longer non integer&quot;);
729      zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
730      return zl;
731  }
732  static PORT_LONGLONG usec(void) {
733  #ifdef _WIN32
734      return GetHighResRelativeTime(1000000);
735  #else
736      struct timeval tv;
737      gettimeofday(&amp;tv,NULL);
738      return (((long long)tv.tv_sec)*1000000)+tv.tv_usec;
739  #endif
740  }
741  static void stress(int pos, int num, int maxsize, int dnum) {
742      int i,j,k;
743      unsigned char *zl;
744      char posstr[2][5] = { &quot;HEAD&quot;, &quot;TAIL&quot; };
745      PORT_LONGLONG start;
746      for (i = 0; i &lt; maxsize; i+=dnum) {
747          zl = ziplistNew();
748          for (j = 0; j &lt; i; j++) {
749              zl = ziplistPush(zl,(unsigned char*)&quot;quux&quot;,4,ZIPLIST_TAIL);
750          }
751          start = usec();
752          for (k = 0; k &lt; num; k++) {
753              zl = ziplistPush(zl,(unsigned char*)&quot;quux&quot;,4,pos);
754              zl = ziplistDeleteRange(zl,0,1);
755          }
756          printf(&quot;List size: %8d, bytes: %8d, %dx push+pop (%s): %6lld usec\n&quot;,
757              i,intrev32ifbe(ZIPLIST_BYTES(zl)),num,posstr[pos],usec()-start);
758          zfree(zl);
759      }
760  }
761  static unsigned char *pop(unsigned char *zl, int where) {
762      unsigned char *p, *vstr;
763      unsigned int vlen;
764      PORT_LONGLONG vlong;
765      p = ziplistIndex(zl,where == ZIPLIST_HEAD ? 0 : -1);
766      if (ziplistGet(p,&amp;vstr,&amp;vlen,&amp;vlong)) {
767          if (where == ZIPLIST_HEAD)
768              printf(&quot;Pop head: &quot;);
769          else
770              printf(&quot;Pop tail: &quot;);
771          if (vstr) {
772              if (vlen &amp;&amp; fwrite(vstr,vlen,1,stdout) == 0) perror(&quot;fwrite&quot;);
773          }
774          else {
775              printf(&quot;%lld&quot;, vlong);
776          }
777          printf(&quot;\n&quot;);
778          return ziplistDelete(zl,&amp;p);
779      } else {
780          printf(&quot;ERROR: Could not pop\n&quot;);
781          exit(1);
782      }
783  }
784  static int randstring(char *target, unsigned int min, unsigned int max) {
785      int p = 0;
786      int len = min+rand()%(max-min+1);
787      int minval, maxval;
788      switch(rand() % 3) {
789      case 0:
790          minval = 0;
791          maxval = 255;
792      break;
793      case 1:
794          minval = 48;
795          maxval = 122;
796      break;
797      case 2:
798          minval = 48;
799          maxval = 52;
800      break;
801      default:
802          assert(NULL);
803      }
804      while(p &lt; len)
805          target[p++] = minval+rand()%(maxval-minval+1);
806      return len;
807  }
808  static void verify(unsigned char *zl, zlentry *e) {
809      int len = ziplistLen(zl);
810      zlentry _e;
811      ZIPLIST_ENTRY_ZERO(&amp;_e);
812      for (int i = 0; i &lt; len; i++) {
813          memset(&amp;e[i], 0, sizeof(zlentry));
814          zipEntry(ziplistIndex(zl, i), &amp;e[i]);
815          memset(&amp;_e, 0, sizeof(zlentry));
816          zipEntry(ziplistIndex(zl, -len+i), &amp;_e);
817          assert(memcmp(&amp;e[i], &amp;_e, sizeof(zlentry)) == 0);
818      }
819  }
820  int ziplistTest(int argc, char **argv) {
821      unsigned char *zl, *p;
822      unsigned char *entry;
823      unsigned int elen;
824      PORT_LONGLONG value;
825      if (argc == 2)
826          srand(atoi(argv[1]));
827      zl = createIntList();
828      ziplistRepr(zl);
829      zfree(zl);
830      zl = createList();
831      ziplistRepr(zl);
832      zl = pop(zl,ZIPLIST_TAIL);
833      ziplistRepr(zl);
834      zl = pop(zl,ZIPLIST_HEAD);
835      ziplistRepr(zl);
836      zl = pop(zl,ZIPLIST_TAIL);
837      ziplistRepr(zl);
838      zl = pop(zl,ZIPLIST_TAIL);
839      ziplistRepr(zl);
840      zfree(zl);
841      printf(&quot;Get element at index 3:\n&quot;);
842      {
843          zl = createList();
844          p = ziplistIndex(zl, 3);
845          if (!ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
846              printf(&quot;ERROR: Could not access index 3\n&quot;);
847              return 1;
848          }
849          if (entry) {
850              if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0) perror(&quot;fwrite&quot;);
851              printf(&quot;\n&quot;);
852          } else {
853              printf(&quot;%lld\n&quot;, value);
854          }
855          printf(&quot;\n&quot;);
856          zfree(zl);
857      }
858      printf(&quot;Get element at index 4 (out of range):\n&quot;);
859      {
860          zl = createList();
861          p = ziplistIndex(zl, 4);
862          if (p == NULL) {
863              printf(&quot;No entry\n&quot;);
864          } else {
865              printf(&quot;ERROR: Out of range index should return NULL, returned offset: %ld\n&quot;, p-zl);
866              return 1;
867          }
868          printf(&quot;\n&quot;);
869          zfree(zl);
870      }
871      printf(&quot;Get element at index -1 (last element):\n&quot;);
872      {
873          zl = createList();
874          p = ziplistIndex(zl, -1);
875          if (!ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
876              printf(&quot;ERROR: Could not access index -1\n&quot;);
877              return 1;
878          }
879          if (entry) {
880              if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0) perror(&quot;fwrite&quot;);
881              printf(&quot;\n&quot;);
882          } else {
883              printf(&quot;%lld\n&quot;, value);
884          }
885          printf(&quot;\n&quot;);
886          zfree(zl);
887      }
888      printf(&quot;Get element at index -4 (first element):\n&quot;);
889      {
890          zl = createList();
891          p = ziplistIndex(zl, -4);
892          if (!ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
893              printf(&quot;ERROR: Could not access index -4\n&quot;);
894              return 1;
895          }
896          if (entry) {
897              if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0) perror(&quot;fwrite&quot;);
898              printf(&quot;\n&quot;);
899          } else {
900              printf(&quot;%lld\n&quot;, value);
901          }
902          printf(&quot;\n&quot;);
903          zfree(zl);
904      }
905      printf(&quot;Get element at index -5 (reverse out of range):\n&quot;);
906      {
907          zl = createList();
908          p = ziplistIndex(zl, -5);
909          if (p == NULL) {
910              printf(&quot;No entry\n&quot;);
911          } else {
912              printf(&quot;ERROR: Out of range index should return NULL, returned offset: %ld\n&quot;, p-zl);
913              return 1;
914          }
915          printf(&quot;\n&quot;);
916          zfree(zl);
917      }
918      printf(&quot;Iterate list from 0 to end:\n&quot;);
919      {
920          zl = createList();
921          p = ziplistIndex(zl, 0);
922          while (ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
923              printf(&quot;Entry: &quot;);
924              if (entry) {
925                  if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0) perror(&quot;fwrite&quot;);
926              } else {
927                  printf(&quot;%lld&quot;, value);
928              }
929              p = ziplistNext(zl,p);
930              printf(&quot;\n&quot;);
931          }
932          printf(&quot;\n&quot;);
933          zfree(zl);
934      }
935      printf(&quot;Iterate list from 1 to end:\n&quot;);
936      {
937          zl = createList();
938          p = ziplistIndex(zl, 1);
939          while (ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
940              printf(&quot;Entry: &quot;);
941              if (entry) {
942                  if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0) perror(&quot;fwrite&quot;);
943              } else {
944                  printf(&quot;%lld&quot;, value);
945              }
946              p = ziplistNext(zl,p);
947              printf(&quot;\n&quot;);
948          }
949          printf(&quot;\n&quot;);
950          zfree(zl);
951      }
952      printf(&quot;Iterate list from 2 to end:\n&quot;);
953      {
954          zl = createList();
955          p = ziplistIndex(zl, 2);
956          while (ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
957              printf(&quot;Entry: &quot;);
958              if (entry) {
959                  if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0) perror(&quot;fwrite&quot;);
960              } else {
961                  printf(&quot;%lld&quot;, value);
962              }
963              p = ziplistNext(zl,p);
964              printf(&quot;\n&quot;);
965          }
966          printf(&quot;\n&quot;);
967          zfree(zl);
968      }
969      printf(&quot;Iterate starting out of range:\n&quot;);
970      {
971          zl = createList();
972          p = ziplistIndex(zl, 4);
973          if (!ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
974              printf(&quot;No entry\n&quot;);
975          } else {
976              printf(&quot;ERROR\n&quot;);
977          }
978          printf(&quot;\n&quot;);
979          zfree(zl);
980      }
981      printf(&quot;Iterate from back to front:\n&quot;);
982      {
983          zl = createList();
984          p = ziplistIndex(zl, -1);
985          while (ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
986              printf(&quot;Entry: &quot;);
987              if (entry) {
988                  if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0) perror(&quot;fwrite&quot;);
989              } else {
990                  printf(&quot;%lld&quot;, value);
991              }
992              p = ziplistPrev(zl,p);
993              printf(&quot;\n&quot;);
994          }
995          printf(&quot;\n&quot;);
996          zfree(zl);
997      }
998      printf(&quot;Iterate from back to front, deleting all items:\n&quot;);
999      {
1000          zl = createList();
1001          p = ziplistIndex(zl, -1);
1002          while (ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
1003              printf(&quot;Entry: &quot;);
1004              if (entry) {
1005                  if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0) perror(&quot;fwrite&quot;);
1006              } else {
1007                  printf(&quot;%lld&quot;, value);
1008              }
1009              zl = ziplistDelete(zl,&amp;p);
1010              p = ziplistPrev(zl,p);
1011              printf(&quot;\n&quot;);
1012          }
1013          printf(&quot;\n&quot;);
1014          zfree(zl);
1015      }
1016      printf(&quot;Delete inclusive range 0,0:\n&quot;);
1017      {
1018          zl = createList();
1019          zl = ziplistDeleteRange(zl, 0, 1);
1020          ziplistRepr(zl);
1021          zfree(zl);
1022      }
1023      printf(&quot;Delete inclusive range 0,1:\n&quot;);
1024      {
1025          zl = createList();
1026          zl = ziplistDeleteRange(zl, 0, 2);
1027          ziplistRepr(zl);
1028          zfree(zl);
1029      }
1030      printf(&quot;Delete inclusive range 1,2:\n&quot;);
1031      {
1032          zl = createList();
1033          zl = ziplistDeleteRange(zl, 1, 2);
1034          ziplistRepr(zl);
1035          zfree(zl);
1036      }
1037      printf(&quot;Delete with start index out of range:\n&quot;);
1038      {
1039          zl = createList();
1040          zl = ziplistDeleteRange(zl, 5, 1);
1041          ziplistRepr(zl);
1042          zfree(zl);
1043      }
1044      printf(&quot;Delete with num overflow:\n&quot;);
1045      {
1046          zl = createList();
1047          zl = ziplistDeleteRange(zl, 1, 5);
1048          ziplistRepr(zl);
1049          zfree(zl);
1050      }
1051      printf(&quot;Delete foo while iterating:\n&quot;);
1052      {
1053          zl = createList();
1054          p = ziplistIndex(zl,0);
1055          while (ziplistGet(p,&amp;entry,&amp;elen,&amp;value)) {
1056              if (entry &amp;&amp; strncmp(&quot;foo&quot;,(char*)entry,elen) == 0) {
1057                  printf(&quot;Delete foo\n&quot;);
1058                  zl = ziplistDelete(zl,&amp;p);
1059              } else {
1060                  printf(&quot;Entry: &quot;);
1061                  if (entry) {
1062                      if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0)
1063                          perror(&quot;fwrite&quot;);
1064                  } else {
1065                      printf(&quot;%lld&quot;,value);
1066                  }
1067                  p = ziplistNext(zl,p);
1068                  printf(&quot;\n&quot;);
1069              }
1070          }
1071          printf(&quot;\n&quot;);
1072          ziplistRepr(zl);
1073          zfree(zl);
1074      }
1075      printf(&quot;Regression test for &gt;255 byte strings:\n&quot;);
1076      {
1077          char v1[257] = {0}, v2[257] = {0};
1078          memset(v1,&#x27;x&#x27;,256);
1079          memset(v2,&#x27;y&#x27;,256);
1080          zl = ziplistNew();
1081          zl = ziplistPush(zl,(unsigned char*)v1,strlen(v1),ZIPLIST_TAIL);
1082          zl = ziplistPush(zl,(unsigned char*)v2,strlen(v2),ZIPLIST_TAIL);
1083          p = ziplistIndex(zl,0);
1084          assert(ziplistGet(p,&amp;entry,&amp;elen,&amp;value));
1085          assert(strncmp(v1,(char*)entry,elen) == 0);
1086          p = ziplistIndex(zl,1);
1087          assert(ziplistGet(p,&amp;entry,&amp;elen,&amp;value));
1088          assert(strncmp(v2,(char*)entry,elen) == 0);
1089          printf(&quot;SUCCESS\n\n&quot;);
1090          zfree(zl);
1091      }
1092      printf(&quot;Regression test deleting next to last entries:\n&quot;);
1093      {
1094          char v[3][257] = {{0}};
1095          zlentry e[3] = {{.prevrawlensize = 0, .prevrawlen = 0, .lensize = 0,
1096                           .len = 0, .headersize = 0, .encoding = 0, .p = NULL}};
1097          size_t i;
1098          for (i = 0; i &lt; (sizeof(v)/sizeof(v[0])); i++) {
1099              memset(v[i], &#x27;a&#x27; + i, sizeof(v[0]));
1100          }
1101          v[0][256] = &#x27;\0&#x27;;
1102          v[1][  1] = &#x27;\0&#x27;;
1103          v[2][256] = &#x27;\0&#x27;;
1104          zl = ziplistNew();
1105          for (i = 0; i &lt; (sizeof(v)/sizeof(v[0])); i++) {
1106              zl = ziplistPush(zl, (unsigned char *) v[i], strlen(v[i]), ZIPLIST_TAIL);
1107          }
1108          verify(zl, e);
1109          assert(e[0].prevrawlensize == 1);
1110          assert(e[1].prevrawlensize == 5);
1111          assert(e[2].prevrawlensize == 1);
1112          unsigned char *p = e[1].p;
1113          zl = ziplistDelete(zl, &amp;p);
1114          verify(zl, e);
1115          assert(e[0].prevrawlensize == 1);
1116          assert(e[1].prevrawlensize == 5);
1117          printf(&quot;SUCCESS\n\n&quot;);
1118          zfree(zl);
1119      }
1120      printf(&quot;Create long list and check indices:\n&quot;);
1121      {
1122          zl = ziplistNew();
1123          char buf[32];
1124          int i,len;
1125          for (i = 0; i &lt; 1000; i++) {
1126              len = sprintf(buf,&quot;%d&quot;,i);
1127              zl = ziplistPush(zl,(unsigned char*)buf,len,ZIPLIST_TAIL);
1128          }
1129          for (i = 0; i &lt; 1000; i++) {
1130              p = ziplistIndex(zl,i);
1131              assert(ziplistGet(p,NULL,NULL,&amp;value));
1132              assert(i == value);
1133              p = ziplistIndex(zl,-i-1);
1134              assert(ziplistGet(p,NULL,NULL,&amp;value));
1135              assert(999-i == value);
1136          }
1137          printf(&quot;SUCCESS\n\n&quot;);
1138          zfree(zl);
1139      }
1140      printf(&quot;Compare strings with ziplist entries:\n&quot;);
1141      {
1142          zl = createList();
1143          p = ziplistIndex(zl,0);
1144          if (!ziplistCompare(p,(unsigned char*)&quot;hello&quot;,5)) {
1145              printf(&quot;ERROR: not \&quot;hello\&quot;\n&quot;);
1146              return 1;
1147          }
1148          if (ziplistCompare(p,(unsigned char*)&quot;hella&quot;,5)) {
1149              printf(&quot;ERROR: \&quot;hella\&quot;\n&quot;);
1150              return 1;
1151          }
1152          p = ziplistIndex(zl,3);
1153          if (!ziplistCompare(p,(unsigned char*)&quot;1024&quot;,4)) {
1154              printf(&quot;ERROR: not \&quot;1024\&quot;\n&quot;);
1155              return 1;
1156          }
1157          if (ziplistCompare(p,(unsigned char*)&quot;1025&quot;,4)) {
1158              printf(&quot;ERROR: \&quot;1025\&quot;\n&quot;);
1159              return 1;
1160          }
1161          printf(&quot;SUCCESS\n\n&quot;);
1162          zfree(zl);
1163      }
1164      printf(&quot;Merge test:\n&quot;);
1165      {
1166          zl = createList();
1167          unsigned char *zl2 = createList();
1168          unsigned char *zl3 = ziplistNew();
1169          unsigned char *zl4 = ziplistNew();
1170          if (ziplistMerge(&amp;zl4, &amp;zl4)) {
1171              printf(&quot;ERROR: Allowed merging of one ziplist into itself.\n&quot;);
1172              return 1;
1173          }
1174          zl4 = ziplistMerge(&amp;zl3, &amp;zl4);
1175          ziplistRepr(zl4);
1176          if (ziplistLen(zl4)) {
1177              printf(&quot;ERROR: Merging two empty ziplists created entries.\n&quot;);
1178              return 1;
1179          }
1180          zfree(zl4);
1181          zl2 = ziplistMerge(&amp;zl, &amp;zl2);
1182          ziplistRepr(zl2);
1183          if (ziplistLen(zl2) != 8) {
1184              printf(&quot;ERROR: Merged length not 8, but: %u\n&quot;, ziplistLen(zl2));
1185              return 1;
1186          }
1187          p = ziplistIndex(zl2,0);
1188          if (!ziplistCompare(p,(unsigned char*)&quot;hello&quot;,5)) {
1189              printf(&quot;ERROR: not \&quot;hello\&quot;\n&quot;);
1190              return 1;
1191          }
1192          if (ziplistCompare(p,(unsigned char*)&quot;hella&quot;,5)) {
1193              printf(&quot;ERROR: \&quot;hella\&quot;\n&quot;);
1194              return 1;
1195          }
1196          p = ziplistIndex(zl2,3);
1197          if (!ziplistCompare(p,(unsigned char*)&quot;1024&quot;,4)) {
1198              printf(&quot;ERROR: not \&quot;1024\&quot;\n&quot;);
1199              return 1;
1200          }
1201          if (ziplistCompare(p,(unsigned char*)&quot;1025&quot;,4)) {
1202              printf(&quot;ERROR: \&quot;1025\&quot;\n&quot;);
1203              return 1;
1204          }
1205          p = ziplistIndex(zl2,4);
1206          if (!ziplistCompare(p,(unsigned char*)&quot;hello&quot;,5)) {
1207              printf(&quot;ERROR: not \&quot;hello\&quot;\n&quot;);
1208              return 1;
1209          }
1210          if (ziplistCompare(p,(unsigned char*)&quot;hella&quot;,5)) {
1211              printf(&quot;ERROR: \&quot;hella\&quot;\n&quot;);
1212              return 1;
1213          }
1214          p = ziplistIndex(zl2,7);
1215          if (!ziplistCompare(p,(unsigned char*)&quot;1024&quot;,4)) {
1216              printf(&quot;ERROR: not \&quot;1024\&quot;\n&quot;);
1217              return 1;
1218          }
1219          if (ziplistCompare(p,(unsigned char*)&quot;1025&quot;,4)) {
1220              printf(&quot;ERROR: \&quot;1025\&quot;\n&quot;);
1221              return 1;
1222          }
1223          printf(&quot;SUCCESS\n\n&quot;);
1224          zfree(zl);
1225      }
1226      printf(&quot;Stress with random payloads of different encoding:\n&quot;);
1227      {
1228          int i,j,len,where;
1229          unsigned char *p;
1230          char buf[1024];
1231          int buflen;
1232          list *ref;
1233          listNode *refnode;
1234          unsigned char *sstr;
1235          unsigned int slen;
1236          PORT_LONGLONG sval;
1237          for (i = 0; i &lt; 20000; i++) {
1238              zl = ziplistNew();
1239              ref = listCreate();
1240              listSetFreeMethod(ref,(void (*)(void*))sdsfree);
1241              len = rand() % 256;
1242              for (j = 0; j &lt; len; j++) {
1243                  where = (rand() &amp; 1) ? ZIPLIST_HEAD : ZIPLIST_TAIL;
1244                  if (rand() % 2) {
1245                      buflen = randstring(buf,1,sizeof(buf)-1);
1246                  } else {
1247                      switch(rand() % 3) {
1248                      case 0:
1249                          buflen = sprintf(buf,&quot;%lld&quot;,(0LL + rand()) &gt;&gt; 20);
1250                          break;
1251                      case 1:
1252                          buflen = sprintf(buf,&quot;%lld&quot;,(0LL + rand()));
1253                          break;
1254                      case 2:
1255                          buflen = sprintf(buf,&quot;%lld&quot;,(0LL + rand()) &lt;&lt; 20);
1256                          break;
1257                      default:
1258                          assert(NULL);
1259                      }
1260                  }
1261                  zl = ziplistPush(zl, (unsigned char*)buf, buflen, where);
1262                  if (where == ZIPLIST_HEAD) {
1263                      listAddNodeHead(ref,sdsnewlen(buf, buflen));
1264                  } else if (where == ZIPLIST_TAIL) {
1265                      listAddNodeTail(ref,sdsnewlen(buf, buflen));
1266                  } else {
1267                      assert(NULL);
1268                  }
1269              }
1270              assert(listLength(ref) == ziplistLen(zl));
1271              for (j = 0; j &lt; len; j++) {
1272                  p = ziplistIndex(zl,j);
1273                  refnode = listIndex(ref,j);
1274                  assert(ziplistGet(p,&amp;sstr,&amp;slen,&amp;sval));
1275                  if (sstr == NULL) {
1276                      buflen = sprintf(buf,&quot;%lld&quot;,sval);
1277                  } else {
1278                      buflen = slen;
1279                      memcpy(buf,sstr,buflen);
1280                      buf[buflen] = &#x27;\0&#x27;;
1281                  }
1282                  assert(memcmp(buf,listNodeValue(refnode),buflen) == 0);
1283              }
1284              zfree(zl);
1285              listRelease(ref);
1286          }
1287          printf(&quot;SUCCESS\n\n&quot;);
1288      }
1289      printf(&quot;Stress with variable ziplist size:\n&quot;);
1290      {
1291          stress(ZIPLIST_HEAD,100000,16384,256);
1292          stress(ZIPLIST_TAIL,100000,16384,256);
1293      }
1294      return 0;
1295  }
1296  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-ziplist.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-ziplist.c</div>
                </div>
                <div class="column column_space"><pre><code>439      size_t first_len = intrev16ifbe(ZIPLIST_LENGTH(*first));
440      size_t second_bytes = intrev32ifbe(ZIPLIST_BYTES(*second));
441      size_t second_len = intrev16ifbe(ZIPLIST_LENGTH(*second));
</pre></code></div>
                <div class="column column_space"><pre><code>462      size_t first_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*first));
463      size_t second_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*second));
464      target = zrealloc(target, zlbytes);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    