
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-gif2webp.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdio.h>
3  #include <stdlib.h>
4  #include <string.h>
5  #ifdef HAVE_CONFIG_H
6  #include "webp/config.h"
7  #endif
8  #ifdef WEBP_HAVE_GIF
9  #if defined(HAVE_UNISTD_H) && HAVE_UNISTD_H
10  #include <unistd.h>
11  #endif
12  #include <gif_lib.h>
13  #include "webp/encode.h"
14  #include "webp/mux.h"
15  #include "../examples/example_util.h"
16  #include "../imageio/imageio_util.h"
17  #include "./gifdec.h"
18  #include "./unicode.h"
19  #include "./unicode_gif.h"
20  #if !defined(STDIN_FILENO)
21  #define STDIN_FILENO 0
22  #endif
23  static int transparent_index = GIF_INDEX_INVALID;  
24  static const char* const kErrorMessages[-WEBP_MUX_NOT_ENOUGH_DATA + 1] = {
25    "WEBP_MUX_NOT_FOUND", "WEBP_MUX_INVALID_ARGUMENT", "WEBP_MUX_BAD_DATA",
26    "WEBP_MUX_MEMORY_ERROR", "WEBP_MUX_NOT_ENOUGH_DATA"
27  };
28  static const char* ErrorString(WebPMuxError err) {
29    assert(err <= WEBP_MUX_NOT_FOUND && err >= WEBP_MUX_NOT_ENOUGH_DATA);
30    return kErrorMessages[-err];
31  }
32  enum {
33    METADATA_ICC  = (1 << 0),
34    METADATA_XMP  = (1 << 1),
35    METADATA_ALL  = METADATA_ICC | METADATA_XMP
36  };
37  static void Help(void) {
38    printf("Usage:\n");
39    printf(" gif2webp [options] gif_file -o webp_file\n");
40    printf("Options:\n");
41    printf("  -h / -help ............. this help\n");
42    printf("  -lossy ................. encode image using lossy compression\n");
43    printf("  -mixed ................. for each frame in the image, pick lossy\n"
44           "                           or lossless compression heuristically\n");
45    printf("  -q <float> ............. quality factor (0:small..100:big)\n");
46    printf("  -m <int> ............... compression method (0=fast, 6=slowest)\n");
47    printf("  -min_size .............. minimize output size (default:off)\n"
48           "                           lossless compression by default; can be\n"
49           "                           combined with -q, -m, -lossy or -mixed\n"
50           "                           options\n");
51    printf("  -kmin <int> ............ min distance between key frames\n");
52    printf("  -kmax <int> ............ max distance between key frames\n");
53    printf("  -f <int> ............... filter strength (0=off..100)\n");
54    printf("  -metadata <string> ..... comma separated list of metadata to\n");
55    printf("                           ");
56    printf("copy from the input to the output if present\n");
57    printf("                           ");
58    printf("Valid values: all, none, icc, xmp (default)\n");
59    printf("  -loop_compatibility .... use compatibility mode for Chrome\n");
60    printf("                           version prior to M62 (inclusive)\n");
61    printf("  -mt .................... use multi-threading if available\n");
62    printf("\n");
63    printf("  -version ............... print version number and exit\n");
64    printf("  -v ..................... verbose\n");
65    printf("  -quiet ................. don't print anything\n");
66    printf("\n");
67  }
68  int main(int argc, const char* argv[]) {
69    int verbose = 0;
70    int gif_error = GIF_ERROR;
71    WebPMuxError err = WEBP_MUX_OK;
72    int ok = 0;
73    const W_CHAR* in_file = NULL, *out_file = NULL;
74    GifFileType* gif = NULL;
75    int frame_duration = 0;
76    int frame_timestamp = 0;
77    GIFDisposeMethod orig_dispose = GIF_DISPOSE_NONE;
78    WebPPicture frame;                
79    WebPPicture curr_canvas;          
80    WebPPicture prev_canvas;          
81    WebPAnimEncoder* enc = NULL;
82    WebPAnimEncoderOptions enc_options;
83    WebPConfig config;
84    int frame_number = 0;     
85    int done;
86    int c;
87    int quiet = 0;
88    WebPData webp_data;
89    int keep_metadata = METADATA_XMP;  
90    WebPData icc_data;
91    int stored_icc = 0;         
92    WebPData xmp_data;
93    int stored_xmp = 0;         
94    int loop_count = 0;         
95    int stored_loop_count = 0;  
96    int loop_compatibility = 0;
97    WebPMux* mux = NULL;
98    int default_kmin = 1;  
99    int default_kmax = 1;
100    INIT_WARGV(argc, argv);
101    if (!WebPConfigInit(&config) || !WebPAnimEncoderOptionsInit(&enc_options) ||
102        !WebPPictureInit(&frame) || !WebPPictureInit(&curr_canvas) ||
103        !WebPPictureInit(&prev_canvas)) {
104      fprintf(stderr, "Error! Version mismatch!\n");
105      FREE_WARGV_AND_RETURN(-1);
106    }
107    config.lossless = 1;  
108    WebPDataInit(&webp_data);
109    WebPDataInit(&icc_data);
110    WebPDataInit(&xmp_data);
111    if (argc == 1) {
112      Help();
113      FREE_WARGV_AND_RETURN(0);
114    }
115    for (c = 1; c < argc; ++c) {
116      int parse_error = 0;
117      if (!strcmp(argv[c], "-h") || !strcmp(argv[c], "-help")) {
118        Help();
119        FREE_WARGV_AND_RETURN(0);
120      } else if (!strcmp(argv[c], "-o") && c < argc - 1) {
121        out_file = GET_WARGV(argv, ++c);
122      } else if (!strcmp(argv[c], "-lossy")) {
123        config.lossless = 0;
124      } else if (!strcmp(argv[c], "-mixed")) {
125        enc_options.allow_mixed = 1;
126        config.lossless = 0;
127      } else if (!strcmp(argv[c], "-loop_compatibility")) {
128        loop_compatibility = 1;
129      } else if (!strcmp(argv[c], "-q") && c < argc - 1) {
130        config.quality = ExUtilGetFloat(argv[++c], &parse_error);
131      } else if (!strcmp(argv[c], "-m") && c < argc - 1) {
132        config.method = ExUtilGetInt(argv[++c], 0, &parse_error);
133      } else if (!strcmp(argv[c], "-min_size")) {
134        enc_options.minimize_size = 1;
135      } else if (!strcmp(argv[c], "-kmax") && c < argc - 1) {
136        enc_options.kmax = ExUtilGetInt(argv[++c], 0, &parse_error);
137        default_kmax = 0;
138      } else if (!strcmp(argv[c], "-kmin") && c < argc - 1) {
139        enc_options.kmin = ExUtilGetInt(argv[++c], 0, &parse_error);
140        default_kmin = 0;
141      } else if (!strcmp(argv[c], "-f") && c < argc - 1) {
142        config.filter_strength = ExUtilGetInt(argv[++c], 0, &parse_error);
143      } else if (!strcmp(argv[c], "-metadata") && c < argc - 1) {
144        static const struct {
145          const char* option;
146          int flag;
147        } kTokens[] = {
148          { "all",  METADATA_ALL },
149          { "none", 0 },
150          { "icc",  METADATA_ICC },
151          { "xmp",  METADATA_XMP },
152        };
153        const size_t kNumTokens = sizeof(kTokens) / sizeof(*kTokens);
154        const char* start = argv[++c];
155        const char* const end = start + strlen(start);
156        keep_metadata = 0;
157        while (start < end) {
158          size_t i;
159          const char* token = strchr(start, ',');
160          if (token == NULL) token = end;
161          for (i = 0; i < kNumTokens; ++i) {
162            if ((size_t)(token - start) == strlen(kTokens[i].option) &&
163                !strncmp(start, kTokens[i].option, strlen(kTokens[i].option))) {
164              if (kTokens[i].flag != 0) {
165                keep_metadata |= kTokens[i].flag;
166              } else {
167                keep_metadata = 0;
168              }
169              break;
170            }
171          }
172          if (i == kNumTokens) {
173            fprintf(stderr, "Error! Unknown metadata type '%.*s'\n",
174                    (int)(token - start), start);
175            Help();
176            FREE_WARGV_AND_RETURN(-1);
177          }
178          start = token + 1;
179        }
180      } else if (!strcmp(argv[c], "-mt")) {
181        ++config.thread_level;
182      } else if (!strcmp(argv[c], "-version")) {
183        const int enc_version = WebPGetEncoderVersion();
184        const int mux_version = WebPGetMuxVersion();
185        printf("WebP Encoder version: %d.%d.%d\nWebP Mux version: %d.%d.%d\n",
186               (enc_version >> 16) & 0xff, (enc_version >> 8) & 0xff,
187               enc_version & 0xff, (mux_version >> 16) & 0xff,
188               (mux_version >> 8) & 0xff, mux_version & 0xff);
189        FREE_WARGV_AND_RETURN(0);
190      } else if (!strcmp(argv[c], "-quiet")) {
191        quiet = 1;
192        enc_options.verbose = 0;
193      } else if (!strcmp(argv[c], "-v")) {
194        verbose = 1;
195        enc_options.verbose = 1;
196      } else if (!strcmp(argv[c], "--")) {
197        if (c < argc - 1) in_file = GET_WARGV(argv, ++c);
198        break;
199      } else if (argv[c][0] == '-') {
200        fprintf(stderr, "Error! Unknown option '%s'\n", argv[c]);
201        Help();
202        FREE_WARGV_AND_RETURN(-1);
203      } else {
<span onclick='openModal()' class='match'>204        in_file = GET_WARGV(argv, c);
205      }
206      if (parse_error) {
207        Help();
</span>208        FREE_WARGV_AND_RETURN(-1);
209      }
210    }
211    if (default_kmin) {
212      enc_options.kmin = config.lossless ? 9 : 3;
213    }
214    if (default_kmax) {
215      enc_options.kmax = config.lossless ? 17 : 5;
216    }
217    if (!WebPValidateConfig(&config)) {
218      fprintf(stderr, "Error! Invalid configuration.\n");
219      goto End;
220    }
221    if (in_file == NULL) {
222      fprintf(stderr, "No input file specified!\n");
223      Help();
224      goto End;
225    }
226    gif = DGifOpenFileUnicode(in_file, &gif_error);
227    if (gif == NULL) goto End;
228    done = 0;
229    do {
230      GifRecordType type;
231      if (DGifGetRecordType(gif, &type) == GIF_ERROR) goto End;
232      switch (type) {
233        case IMAGE_DESC_RECORD_TYPE: {
234          GIFFrameRect gif_rect;
235          GifImageDesc* const image_desc = &gif->Image;
236          if (!DGifGetImageDesc(gif)) goto End;
237          if (frame_number == 0) {
238            if (verbose) {
239              printf("Canvas screen: %d x %d\n", gif->SWidth, gif->SHeight);
240            }
241            if (gif->SWidth == 0 || gif->SHeight == 0) {
242              image_desc->Left = 0;
243              image_desc->Top = 0;
244              gif->SWidth = image_desc->Width;
245              gif->SHeight = image_desc->Height;
246              if (gif->SWidth <= 0 || gif->SHeight <= 0) {
247                goto End;
248              }
249              if (verbose) {
250                printf("Fixed canvas screen dimension to: %d x %d\n",
251                       gif->SWidth, gif->SHeight);
252              }
253            }
254            frame.width = gif->SWidth;
255            frame.height = gif->SHeight;
256            frame.use_argb = 1;
257            if (!WebPPictureAlloc(&frame)) goto End;
258            GIFClearPic(&frame, NULL);
259            WebPPictureCopy(&frame, &curr_canvas);
260            WebPPictureCopy(&frame, &prev_canvas);
261            GIFGetBackgroundColor(gif->SColorMap, gif->SBackGroundColor,
262                                  transparent_index,
263                                  &enc_options.anim_params.bgcolor);
264            enc = WebPAnimEncoderNew(curr_canvas.width, curr_canvas.height,
265                                     &enc_options);
266            if (enc == NULL) {
267              fprintf(stderr,
268                      "Error! Could not create encoder object. Possibly due to "
269                      "a memory error.\n");
270              goto End;
271            }
272          }
273          if (image_desc->Width == 0 || image_desc->Height == 0) {
274            image_desc->Width = gif->SWidth;
275            image_desc->Height = gif->SHeight;
276          }
277          if (!GIFReadFrame(gif, transparent_index, &gif_rect, &frame)) {
278            goto End;
279          }
280          GIFBlendFrames(&frame, &gif_rect, &curr_canvas);
281          if (!WebPAnimEncoderAdd(enc, &curr_canvas, frame_timestamp, &config)) {
282            fprintf(stderr, "Error while adding frame #%d: %s\n", frame_number,
283                    WebPAnimEncoderGetError(enc));
284            goto End;
285          } else {
286            ++frame_number;
287          }
288          GIFDisposeFrame(orig_dispose, &gif_rect, &prev_canvas, &curr_canvas);
289          GIFCopyPixels(&curr_canvas, &prev_canvas);
290          if (frame_duration <= 10) {
291            frame_duration = 100;
292          }
293          frame_timestamp += frame_duration;
294          orig_dispose = GIF_DISPOSE_NONE;
295          frame_duration = 0;
296          transparent_index = GIF_INDEX_INVALID;
297          break;
298        }
299        case EXTENSION_RECORD_TYPE: {
300          int extension;
301          GifByteType* data = NULL;
302          if (DGifGetExtension(gif, &extension, &data) == GIF_ERROR) {
303            goto End;
304          }
305          if (data == NULL) continue;
306          switch (extension) {
307            case COMMENT_EXT_FUNC_CODE: {
308              break;  
309            }
310            case GRAPHICS_EXT_FUNC_CODE: {
311              if (!GIFReadGraphicsExtension(data, &frame_duration, &orig_dispose,
312                                            &transparent_index)) {
313                goto End;
314              }
315              break;
316            }
317            case PLAINTEXT_EXT_FUNC_CODE: {
318              break;
319            }
320            case APPLICATION_EXT_FUNC_CODE: {
321              if (data[0] != 11) break;    
322              if (!memcmp(data + 1, "NETSCAPE2.0", 11) ||
323                  !memcmp(data + 1, "ANIMEXTS1.0", 11)) {
324                if (!GIFReadLoopCount(gif, &data, &loop_count)) {
325                  goto End;
326                }
327                if (verbose) {
328                  fprintf(stderr, "Loop count: %d\n", loop_count);
329                }
330                stored_loop_count = loop_compatibility ? (loop_count != 0) : 1;
331              } else {  
332                const int is_xmp = (keep_metadata & METADATA_XMP) &&
333                                   !stored_xmp &&
334                                   !memcmp(data + 1, "XMP DataXMP", 11);
335                const int is_icc = (keep_metadata & METADATA_ICC) &&
336                                   !stored_icc &&
337                                   !memcmp(data + 1, "ICCRGBG1012", 11);
338                if (is_xmp || is_icc) {
339                  if (!GIFReadMetadata(gif, &data,
340                                       is_xmp ? &xmp_data : &icc_data)) {
341                    goto End;
342                  }
343                  if (is_icc) {
344                    stored_icc = 1;
345                  } else if (is_xmp) {
346                    stored_xmp = 1;
347                  }
348                }
349              }
350              break;
351            }
352            default: {
353              break;  
354            }
355          }
356          while (data != NULL) {
357            if (DGifGetExtensionNext(gif, &data) == GIF_ERROR) goto End;
358          }
359          break;
360        }
361        case TERMINATE_RECORD_TYPE: {
362          done = 1;
363          break;
364        }
365        default: {
366          if (verbose) {
367            fprintf(stderr, "Skipping over unknown record type %d\n", type);
368          }
369          break;
370        }
371      }
372    } while (!done);
373    if (!WebPAnimEncoderAdd(enc, NULL, frame_timestamp, NULL)) {
374      fprintf(stderr, "Error flushing WebP muxer.\n");
375      fprintf(stderr, "%s\n", WebPAnimEncoderGetError(enc));
376    }
377    if (!WebPAnimEncoderAssemble(enc, &webp_data)) {
378      fprintf(stderr, "%s\n", WebPAnimEncoderGetError(enc));
379      goto End;
380    }
381    if (!loop_compatibility) {
382      if (!stored_loop_count) {
383        if (frame_number > 1) {
384          stored_loop_count = 1;
385          loop_count = 1;
386        }
387      } else if (loop_count > 0 && loop_count < 65535) {
388        loop_count += 1;
389      }
390    }
391    if (loop_count == 0) stored_loop_count = 0;
392    if (stored_loop_count || stored_icc || stored_xmp) {
393      mux = WebPMuxCreate(&webp_data, 1);
394      if (mux == NULL) {
395        fprintf(stderr, "ERROR: Could not re-mux to add loop count/metadata.\n");
396        goto End;
397      }
398      WebPDataClear(&webp_data);
399      if (stored_loop_count) {  
400        WebPMuxAnimParams new_params;
401        err = WebPMuxGetAnimationParams(mux, &new_params);
402        if (err != WEBP_MUX_OK) {
403          fprintf(stderr, "ERROR (%s): Could not fetch loop count.\n",
404                  ErrorString(err));
405          goto End;
406        }
407        new_params.loop_count = loop_count;
408        err = WebPMuxSetAnimationParams(mux, &new_params);
409        if (err != WEBP_MUX_OK) {
410          fprintf(stderr, "ERROR (%s): Could not update loop count.\n",
411                  ErrorString(err));
412          goto End;
413        }
414      }
415      if (stored_icc) {   
416        err = WebPMuxSetChunk(mux, "ICCP", &icc_data, 1);
417        if (verbose) {
418          fprintf(stderr, "ICC size: %d\n", (int)icc_data.size);
419        }
420        if (err != WEBP_MUX_OK) {
421          fprintf(stderr, "ERROR (%s): Could not set ICC chunk.\n",
422                  ErrorString(err));
423          goto End;
424        }
425      }
426      if (stored_xmp) {   
427        err = WebPMuxSetChunk(mux, "XMP ", &xmp_data, 1);
428        if (verbose) {
429          fprintf(stderr, "XMP size: %d\n", (int)xmp_data.size);
430        }
431        if (err != WEBP_MUX_OK) {
432          fprintf(stderr, "ERROR (%s): Could not set XMP chunk.\n",
433                  ErrorString(err));
434          goto End;
435        }
436      }
437      err = WebPMuxAssemble(mux, &webp_data);
438      if (err != WEBP_MUX_OK) {
439        fprintf(stderr, "ERROR (%s): Could not assemble when re-muxing to add "
440                "loop count/metadata.\n", ErrorString(err));
441        goto End;
442      }
443    }
444    if (out_file != NULL) {
445      if (!ImgIoUtilWriteFile((const char*)out_file, webp_data.bytes,
446                              webp_data.size)) {
447        WFPRINTF(stderr, "Error writing output file: %s\n", out_file);
448        goto End;
449      }
450      if (!quiet) {
451        if (!WSTRCMP(out_file, "-")) {
452          fprintf(stderr, "Saved %d bytes to STDIO\n",
453                  (int)webp_data.size);
454        } else {
455          WFPRINTF(stderr, "Saved output file (%d bytes): %s\n",
456                   (int)webp_data.size, out_file);
457        }
458      }
459    } else {
460      if (!quiet) {
461        fprintf(stderr, "Nothing written; use -o flag to save the result "
462                        "(%d bytes).\n", (int)webp_data.size);
463      }
464    }
465    ok = 1;
466    gif_error = GIF_OK;
467   End:
468    WebPDataClear(&icc_data);
469    WebPDataClear(&xmp_data);
470    WebPMuxDelete(mux);
471    WebPDataClear(&webp_data);
472    WebPPictureFree(&frame);
473    WebPPictureFree(&curr_canvas);
474    WebPPictureFree(&prev_canvas);
475    WebPAnimEncoderDelete(enc);
476    if (gif_error != GIF_OK) {
477      GIFDisplayError(gif, gif_error);
478    }
479    if (gif != NULL) {
480  #if LOCAL_GIF_PREREQ(5,1)
481      DGifCloseFile(gif, &gif_error);
482  #else
483      DGifCloseFile(gif);
484  #endif
485    }
486    FREE_WARGV_AND_RETURN(!ok);
487  }
488  #else  
489  int main(int argc, const char* argv[]) {
490    fprintf(stderr, "GIF support not enabled in %s.\n", argv[0]);
491    (void)argc;
492    return 0;
493  }
494  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-gif2webp.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdio.h>
3  #include <stdlib.h>
4  #include <string.h>
5  #ifdef HAVE_CONFIG_H
6  #include "webp/config.h"
7  #endif
8  #ifdef WEBP_HAVE_GIF
9  #if defined(HAVE_UNISTD_H) && HAVE_UNISTD_H
10  #include <unistd.h>
11  #endif
12  #include <gif_lib.h>
13  #include "webp/encode.h"
14  #include "webp/mux.h"
15  #include "../examples/example_util.h"
16  #include "../imageio/imageio_util.h"
17  #include "./gifdec.h"
18  #include "./unicode.h"
19  #include "./unicode_gif.h"
20  #if !defined(STDIN_FILENO)
21  #define STDIN_FILENO 0
22  #endif
23  static int transparent_index = GIF_INDEX_INVALID;  
24  static const char* const kErrorMessages[-WEBP_MUX_NOT_ENOUGH_DATA + 1] = {
25    "WEBP_MUX_NOT_FOUND", "WEBP_MUX_INVALID_ARGUMENT", "WEBP_MUX_BAD_DATA",
26    "WEBP_MUX_MEMORY_ERROR", "WEBP_MUX_NOT_ENOUGH_DATA"
27  };
28  static const char* ErrorString(WebPMuxError err) {
29    assert(err <= WEBP_MUX_NOT_FOUND && err >= WEBP_MUX_NOT_ENOUGH_DATA);
30    return kErrorMessages[-err];
31  }
32  enum {
33    METADATA_ICC  = (1 << 0),
34    METADATA_XMP  = (1 << 1),
35    METADATA_ALL  = METADATA_ICC | METADATA_XMP
36  };
37  static void Help(void) {
38    printf("Usage:\n");
39    printf(" gif2webp [options] gif_file -o webp_file\n");
40    printf("Options:\n");
41    printf("  -h / -help ............. this help\n");
42    printf("  -lossy ................. encode image using lossy compression\n");
43    printf("  -mixed ................. for each frame in the image, pick lossy\n"
44           "                           or lossless compression heuristically\n");
45    printf("  -q <float> ............. quality factor (0:small..100:big)\n");
46    printf("  -m <int> ............... compression method (0=fast, 6=slowest)\n");
47    printf("  -min_size .............. minimize output size (default:off)\n"
48           "                           lossless compression by default; can be\n"
49           "                           combined with -q, -m, -lossy or -mixed\n"
50           "                           options\n");
51    printf("  -kmin <int> ............ min distance between key frames\n");
52    printf("  -kmax <int> ............ max distance between key frames\n");
53    printf("  -f <int> ............... filter strength (0=off..100)\n");
54    printf("  -metadata <string> ..... comma separated list of metadata to\n");
55    printf("                           ");
56    printf("copy from the input to the output if present\n");
57    printf("                           ");
58    printf("Valid values: all, none, icc, xmp (default)\n");
59    printf("  -loop_compatibility .... use compatibility mode for Chrome\n");
60    printf("                           version prior to M62 (inclusive)\n");
61    printf("  -mt .................... use multi-threading if available\n");
62    printf("\n");
63    printf("  -version ............... print version number and exit\n");
64    printf("  -v ..................... verbose\n");
65    printf("  -quiet ................. don't print anything\n");
66    printf("\n");
67  }
68  int main(int argc, const char* argv[]) {
69    int verbose = 0;
70    int gif_error = GIF_ERROR;
71    WebPMuxError err = WEBP_MUX_OK;
72    int ok = 0;
73    const W_CHAR* in_file = NULL, *out_file = NULL;
74    GifFileType* gif = NULL;
75    int frame_duration = 0;
76    int frame_timestamp = 0;
77    GIFDisposeMethod orig_dispose = GIF_DISPOSE_NONE;
78    WebPPicture frame;                
79    WebPPicture curr_canvas;          
80    WebPPicture prev_canvas;          
81    WebPAnimEncoder* enc = NULL;
82    WebPAnimEncoderOptions enc_options;
83    WebPConfig config;
84    int frame_number = 0;     
85    int done;
86    int c;
87    int quiet = 0;
88    WebPData webp_data;
89    int keep_metadata = METADATA_XMP;  
90    WebPData icc_data;
91    int stored_icc = 0;         
92    WebPData xmp_data;
93    int stored_xmp = 0;         
94    int loop_count = 0;         
95    int stored_loop_count = 0;  
96    int loop_compatibility = 0;
97    WebPMux* mux = NULL;
98    int default_kmin = 1;  
99    int default_kmax = 1;
100    INIT_WARGV(argc, argv);
101    if (!WebPConfigInit(&config) || !WebPAnimEncoderOptionsInit(&enc_options) ||
102        !WebPPictureInit(&frame) || !WebPPictureInit(&curr_canvas) ||
103        !WebPPictureInit(&prev_canvas)) {
104      fprintf(stderr, "Error! Version mismatch!\n");
105      FREE_WARGV_AND_RETURN(-1);
106    }
107    config.lossless = 1;  
108    WebPDataInit(&webp_data);
109    WebPDataInit(&icc_data);
110    WebPDataInit(&xmp_data);
111    if (argc == 1) {
112      Help();
113      FREE_WARGV_AND_RETURN(0);
114    }
115    for (c = 1; c < argc; ++c) {
116      int parse_error = 0;
117      if (!strcmp(argv[c], "-h") || !strcmp(argv[c], "-help")) {
118        Help();
119        FREE_WARGV_AND_RETURN(0);
120      } else if (!strcmp(argv[c], "-o") && c < argc - 1) {
121        out_file = GET_WARGV(argv, ++c);
122      } else if (!strcmp(argv[c], "-lossy")) {
123        config.lossless = 0;
124      } else if (!strcmp(argv[c], "-mixed")) {
125        enc_options.allow_mixed = 1;
126        config.lossless = 0;
127      } else if (!strcmp(argv[c], "-loop_compatibility")) {
128        loop_compatibility = 1;
129      } else if (!strcmp(argv[c], "-q") && c < argc - 1) {
130        config.quality = ExUtilGetFloat(argv[++c], &parse_error);
131      } else if (!strcmp(argv[c], "-m") && c < argc - 1) {
132        config.method = ExUtilGetInt(argv[++c], 0, &parse_error);
133      } else if (!strcmp(argv[c], "-min_size")) {
134        enc_options.minimize_size = 1;
135      } else if (!strcmp(argv[c], "-kmax") && c < argc - 1) {
136        enc_options.kmax = ExUtilGetInt(argv[++c], 0, &parse_error);
137        default_kmax = 0;
138      } else if (!strcmp(argv[c], "-kmin") && c < argc - 1) {
139        enc_options.kmin = ExUtilGetInt(argv[++c], 0, &parse_error);
140        default_kmin = 0;
141      } else if (!strcmp(argv[c], "-f") && c < argc - 1) {
142        config.filter_strength = ExUtilGetInt(argv[++c], 0, &parse_error);
143      } else if (!strcmp(argv[c], "-metadata") && c < argc - 1) {
144        static const struct {
145          const char* option;
146          int flag;
147        } kTokens[] = {
148          { "all",  METADATA_ALL },
149          { "none", 0 },
150          { "icc",  METADATA_ICC },
151          { "xmp",  METADATA_XMP },
152        };
153        const size_t kNumTokens = sizeof(kTokens) / sizeof(*kTokens);
154        const char* start = argv[++c];
155        const char* const end = start + strlen(start);
156        keep_metadata = 0;
157        while (start < end) {
158          size_t i;
159          const char* token = strchr(start, ',');
160          if (token == NULL) token = end;
161          for (i = 0; i < kNumTokens; ++i) {
162            if ((size_t)(token - start) == strlen(kTokens[i].option) &&
163                !strncmp(start, kTokens[i].option, strlen(kTokens[i].option))) {
164              if (kTokens[i].flag != 0) {
165                keep_metadata |= kTokens[i].flag;
166              } else {
167                keep_metadata = 0;
168              }
169              break;
170            }
171          }
172          if (i == kNumTokens) {
173            fprintf(stderr, "Error! Unknown metadata type '%.*s'\n",
174                    (int)(token - start), start);
175            Help();
176            FREE_WARGV_AND_RETURN(-1);
177          }
178          start = token + 1;
179        }
180      } else if (!strcmp(argv[c], "-mt")) {
181        ++config.thread_level;
182      } else if (!strcmp(argv[c], "-version")) {
183        const int enc_version = WebPGetEncoderVersion();
184        const int mux_version = WebPGetMuxVersion();
185        printf("WebP Encoder version: %d.%d.%d\nWebP Mux version: %d.%d.%d\n",
186               (enc_version >> 16) & 0xff, (enc_version >> 8) & 0xff,
187               enc_version & 0xff, (mux_version >> 16) & 0xff,
188               (mux_version >> 8) & 0xff, mux_version & 0xff);
189        FREE_WARGV_AND_RETURN(0);
190      } else if (!strcmp(argv[c], "-quiet")) {
191        quiet = 1;
192        enc_options.verbose = 0;
193      } else if (!strcmp(argv[c], "-v")) {
194        verbose = 1;
195        enc_options.verbose = 1;
196      } else if (!strcmp(argv[c], "--")) {
197        if (c < argc - 1) in_file = GET_WARGV(argv, ++c);
198        break;
199      } else if (argv[c][0] == '-') {
200        fprintf(stderr, "Error! Unknown option '%s'\n", argv[c]);
201        Help();
202        FREE_WARGV_AND_RETURN(-1);
203      } else {
<span onclick='openModal()' class='match'>204        in_file = GET_WARGV(argv, c);
205      }
206      if (parse_error) {
207        Help();
</span>208        FREE_WARGV_AND_RETURN(-1);
209      }
210    }
211    if (default_kmin) {
212      enc_options.kmin = config.lossless ? 9 : 3;
213    }
214    if (default_kmax) {
215      enc_options.kmax = config.lossless ? 17 : 5;
216    }
217    if (!WebPValidateConfig(&config)) {
218      fprintf(stderr, "Error! Invalid configuration.\n");
219      goto End;
220    }
221    if (in_file == NULL) {
222      fprintf(stderr, "No input file specified!\n");
223      Help();
224      goto End;
225    }
226    gif = DGifOpenFileUnicode(in_file, &gif_error);
227    if (gif == NULL) goto End;
228    done = 0;
229    do {
230      GifRecordType type;
231      if (DGifGetRecordType(gif, &type) == GIF_ERROR) goto End;
232      switch (type) {
233        case IMAGE_DESC_RECORD_TYPE: {
234          GIFFrameRect gif_rect;
235          GifImageDesc* const image_desc = &gif->Image;
236          if (!DGifGetImageDesc(gif)) goto End;
237          if (frame_number == 0) {
238            if (verbose) {
239              printf("Canvas screen: %d x %d\n", gif->SWidth, gif->SHeight);
240            }
241            if (gif->SWidth == 0 || gif->SHeight == 0) {
242              image_desc->Left = 0;
243              image_desc->Top = 0;
244              gif->SWidth = image_desc->Width;
245              gif->SHeight = image_desc->Height;
246              if (gif->SWidth <= 0 || gif->SHeight <= 0) {
247                goto End;
248              }
249              if (verbose) {
250                printf("Fixed canvas screen dimension to: %d x %d\n",
251                       gif->SWidth, gif->SHeight);
252              }
253            }
254            frame.width = gif->SWidth;
255            frame.height = gif->SHeight;
256            frame.use_argb = 1;
257            if (!WebPPictureAlloc(&frame)) goto End;
258            GIFClearPic(&frame, NULL);
259            WebPPictureCopy(&frame, &curr_canvas);
260            WebPPictureCopy(&frame, &prev_canvas);
261            GIFGetBackgroundColor(gif->SColorMap, gif->SBackGroundColor,
262                                  transparent_index,
263                                  &enc_options.anim_params.bgcolor);
264            enc = WebPAnimEncoderNew(curr_canvas.width, curr_canvas.height,
265                                     &enc_options);
266            if (enc == NULL) {
267              fprintf(stderr,
268                      "Error! Could not create encoder object. Possibly due to "
269                      "a memory error.\n");
270              goto End;
271            }
272          }
273          if (image_desc->Width == 0 || image_desc->Height == 0) {
274            image_desc->Width = gif->SWidth;
275            image_desc->Height = gif->SHeight;
276          }
277          if (!GIFReadFrame(gif, transparent_index, &gif_rect, &frame)) {
278            goto End;
279          }
280          GIFBlendFrames(&frame, &gif_rect, &curr_canvas);
281          if (!WebPAnimEncoderAdd(enc, &curr_canvas, frame_timestamp, &config)) {
282            fprintf(stderr, "Error while adding frame #%d: %s\n", frame_number,
283                    WebPAnimEncoderGetError(enc));
284            goto End;
285          } else {
286            ++frame_number;
287          }
288          GIFDisposeFrame(orig_dispose, &gif_rect, &prev_canvas, &curr_canvas);
289          GIFCopyPixels(&curr_canvas, &prev_canvas);
290          if (frame_duration <= 10) {
291            frame_duration = 100;
292          }
293          frame_timestamp += frame_duration;
294          orig_dispose = GIF_DISPOSE_NONE;
295          frame_duration = 0;
296          transparent_index = GIF_INDEX_INVALID;
297          break;
298        }
299        case EXTENSION_RECORD_TYPE: {
300          int extension;
301          GifByteType* data = NULL;
302          if (DGifGetExtension(gif, &extension, &data) == GIF_ERROR) {
303            goto End;
304          }
305          if (data == NULL) continue;
306          switch (extension) {
307            case COMMENT_EXT_FUNC_CODE: {
308              break;  
309            }
310            case GRAPHICS_EXT_FUNC_CODE: {
311              if (!GIFReadGraphicsExtension(data, &frame_duration, &orig_dispose,
312                                            &transparent_index)) {
313                goto End;
314              }
315              break;
316            }
317            case PLAINTEXT_EXT_FUNC_CODE: {
318              break;
319            }
320            case APPLICATION_EXT_FUNC_CODE: {
321              if (data[0] != 11) break;    
322              if (!memcmp(data + 1, "NETSCAPE2.0", 11) ||
323                  !memcmp(data + 1, "ANIMEXTS1.0", 11)) {
324                if (!GIFReadLoopCount(gif, &data, &loop_count)) {
325                  goto End;
326                }
327                if (verbose) {
328                  fprintf(stderr, "Loop count: %d\n", loop_count);
329                }
330                stored_loop_count = loop_compatibility ? (loop_count != 0) : 1;
331              } else {  
332                const int is_xmp = (keep_metadata & METADATA_XMP) &&
333                                   !stored_xmp &&
334                                   !memcmp(data + 1, "XMP DataXMP", 11);
335                const int is_icc = (keep_metadata & METADATA_ICC) &&
336                                   !stored_icc &&
337                                   !memcmp(data + 1, "ICCRGBG1012", 11);
338                if (is_xmp || is_icc) {
339                  if (!GIFReadMetadata(gif, &data,
340                                       is_xmp ? &xmp_data : &icc_data)) {
341                    goto End;
342                  }
343                  if (is_icc) {
344                    stored_icc = 1;
345                  } else if (is_xmp) {
346                    stored_xmp = 1;
347                  }
348                }
349              }
350              break;
351            }
352            default: {
353              break;  
354            }
355          }
356          while (data != NULL) {
357            if (DGifGetExtensionNext(gif, &data) == GIF_ERROR) goto End;
358          }
359          break;
360        }
361        case TERMINATE_RECORD_TYPE: {
362          done = 1;
363          break;
364        }
365        default: {
366          if (verbose) {
367            fprintf(stderr, "Skipping over unknown record type %d\n", type);
368          }
369          break;
370        }
371      }
372    } while (!done);
373    if (!WebPAnimEncoderAdd(enc, NULL, frame_timestamp, NULL)) {
374      fprintf(stderr, "Error flushing WebP muxer.\n");
375      fprintf(stderr, "%s\n", WebPAnimEncoderGetError(enc));
376    }
377    if (!WebPAnimEncoderAssemble(enc, &webp_data)) {
378      fprintf(stderr, "%s\n", WebPAnimEncoderGetError(enc));
379      goto End;
380    }
381    if (!loop_compatibility) {
382      if (!stored_loop_count) {
383        if (frame_number > 1) {
384          stored_loop_count = 1;
385          loop_count = 1;
386        }
387      } else if (loop_count > 0 && loop_count < 65535) {
388        loop_count += 1;
389      }
390    }
391    if (loop_count == 0) stored_loop_count = 0;
392    if (stored_loop_count || stored_icc || stored_xmp) {
393      mux = WebPMuxCreate(&webp_data, 1);
394      if (mux == NULL) {
395        fprintf(stderr, "ERROR: Could not re-mux to add loop count/metadata.\n");
396        goto End;
397      }
398      WebPDataClear(&webp_data);
399      if (stored_loop_count) {  
400        WebPMuxAnimParams new_params;
401        err = WebPMuxGetAnimationParams(mux, &new_params);
402        if (err != WEBP_MUX_OK) {
403          fprintf(stderr, "ERROR (%s): Could not fetch loop count.\n",
404                  ErrorString(err));
405          goto End;
406        }
407        new_params.loop_count = loop_count;
408        err = WebPMuxSetAnimationParams(mux, &new_params);
409        if (err != WEBP_MUX_OK) {
410          fprintf(stderr, "ERROR (%s): Could not update loop count.\n",
411                  ErrorString(err));
412          goto End;
413        }
414      }
415      if (stored_icc) {   
416        err = WebPMuxSetChunk(mux, "ICCP", &icc_data, 1);
417        if (verbose) {
418          fprintf(stderr, "ICC size: %d\n", (int)icc_data.size);
419        }
420        if (err != WEBP_MUX_OK) {
421          fprintf(stderr, "ERROR (%s): Could not set ICC chunk.\n",
422                  ErrorString(err));
423          goto End;
424        }
425      }
426      if (stored_xmp) {   
427        err = WebPMuxSetChunk(mux, "XMP ", &xmp_data, 1);
428        if (verbose) {
429          fprintf(stderr, "XMP size: %d\n", (int)xmp_data.size);
430        }
431        if (err != WEBP_MUX_OK) {
432          fprintf(stderr, "ERROR (%s): Could not set XMP chunk.\n",
433                  ErrorString(err));
434          goto End;
435        }
436      }
437      err = WebPMuxAssemble(mux, &webp_data);
438      if (err != WEBP_MUX_OK) {
439        fprintf(stderr, "ERROR (%s): Could not assemble when re-muxing to add "
440                "loop count/metadata.\n", ErrorString(err));
441        goto End;
442      }
443    }
444    if (out_file != NULL) {
445      if (!ImgIoUtilWriteFile((const char*)out_file, webp_data.bytes,
446                              webp_data.size)) {
447        WFPRINTF(stderr, "Error writing output file: %s\n", out_file);
448        goto End;
449      }
450      if (!quiet) {
451        if (!WSTRCMP(out_file, "-")) {
452          fprintf(stderr, "Saved %d bytes to STDIO\n",
453                  (int)webp_data.size);
454        } else {
455          WFPRINTF(stderr, "Saved output file (%d bytes): %s\n",
456                   (int)webp_data.size, out_file);
457        }
458      }
459    } else {
460      if (!quiet) {
461        fprintf(stderr, "Nothing written; use -o flag to save the result "
462                        "(%d bytes).\n", (int)webp_data.size);
463      }
464    }
465    ok = 1;
466    gif_error = GIF_OK;
467   End:
468    WebPDataClear(&icc_data);
469    WebPDataClear(&xmp_data);
470    WebPMuxDelete(mux);
471    WebPDataClear(&webp_data);
472    WebPPictureFree(&frame);
473    WebPPictureFree(&curr_canvas);
474    WebPPictureFree(&prev_canvas);
475    WebPAnimEncoderDelete(enc);
476    if (gif_error != GIF_OK) {
477      GIFDisplayError(gif, gif_error);
478    }
479    if (gif != NULL) {
480  #if LOCAL_GIF_PREREQ(5,1)
481      DGifCloseFile(gif, &gif_error);
482  #else
483      DGifCloseFile(gif);
484  #endif
485    }
486    FREE_WARGV_AND_RETURN(!ok);
487  }
488  #else  
489  int main(int argc, const char* argv[]) {
490    fprintf(stderr, "GIF support not enabled in %s.\n", argv[0]);
491    (void)argc;
492    return 0;
493  }
494  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-gif2webp.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-gif2webp.c</div>
                </div>
                <div class="column column_space"><pre><code>204        in_file = GET_WARGV(argv, c);
205      }
206      if (parse_error) {
207        Help();
</pre></code></div>
                <div class="column column_space"><pre><code>204        in_file = GET_WARGV(argv, c);
205      }
206      if (parse_error) {
207        Help();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    