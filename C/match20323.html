<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for eye.c &amp; tilecache.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for eye.c &amp; tilecache.c
      </h3>
<h1 align="center">
        6.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>eye.c (32.07547%)<th>tilecache.c (3.7444935%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(88-105)<td><a href="#" name="0">(378-395)</a><td align="center"><font color="#ff0000">17</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>eye.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* make a test pattern to show the eye's frequency response
 *
 * Copyright: 1990, 1991, N.Dessipris.
 *
 * Author N. Dessipris
 * Written on 30/05/1990
 * Updated on: 27/01/1991, 07/03/1991,
 * 22/7/93 JC
 *	- im_outcheck() added
 * 30/8/95 JC
 *	- modernized
 * 1/2/11
 * 	- gtk-doc
 * 13/6/13
 * 	- redo as a class
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/*
#define VIPS_DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

#include &lt;vips/vips.h&gt;

#include "pcreate.h"
#include "point.h"

typedef struct _VipsEye {
	VipsPoint parent_instance;

	double factor;

} VipsEye;

typedef VipsPointClass VipsEyeClass;

G_DEFINE_TYPE( VipsEye, vips_eye, VIPS_TYPE_POINT );

static float
vips_eye_point( VipsPoint *point, int x, int y ) 
{
	VipsEye *eye = (VipsEye *) point;

	/* VIPS_MAX to prevent /0.
	 */
	int max_x = VIPS_MAX( point-&gt;width - 1, 1 );
	int max_y = VIPS_MAX( point-&gt;height - 1, 1 );

<a name="0"></a>	double c = eye-&gt;factor * VIPS_PI / (2 * max_x);
	double h = max_y * max_y;

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( y * y * cos( c * x * x ) / h );
}

static void
vips_eye_class_init( VipsEyeClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
	VipsPointClass *point_class = VIPS_POINT_CLASS( class );

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	vobject_class-&gt;nickname = "eye";
	vobject_class-&gt;description = 
		_( "make an image showing the eye's spatial response" );

	point_class-&gt;point = vips_eye_point;</b></font>

	VIPS_ARG_DOUBLE( class, "factor", 6, 
		_( "Factor" ), 
		_( "Maximum spatial frequency" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsEye, factor ),
		0.0, 1.0, 0.5 );
}

static void
vips_eye_init( VipsEye *eye )
{
	eye-&gt;factor = 0.5;
}


/**
 * vips_eye:
 * @out: (out): output image
 * @width: image size
 * @height: image size
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @factor: maximum spatial frequency
 * * @uchar: output a uchar image
 *
 * Create a test pattern with increasing spatial frequence in X and 
 * amplitude in Y. @factor should be between 0 and 1 and determines the 
 * maximum spatial frequency.
 *
 * Set @uchar to output a uchar image. 
 *
 * See also: vips_zone().
 *
 * Returns: 0 on success, -1 on error
 */
int
vips_eye( VipsImage **out, int width, int height, ... )
{
	va_list ap;
	int result;

	va_start( ap, height );
	result = vips_call_split( "eye", ap, out, width, height );
	va_end( ap );

	return( result );
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>tilecache.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* Simple tile or line cache.
 *
 * This isn't the same as the sinkscreen cache: we don't sub-divide, and we 
 * single-thread our callee.
 *
 * 23/8/06
 * 	- take ownership of reused tiles in case the cache is being shared
 * 13/2/07
 * 	- release ownership after fillng with pixels in case we read across
 * 	  threads
 * 4/2/10
 * 	- gtkdoc
 * 12/12/10
 * 	- use im_prepare_to() and avoid making a sequence for every cache tile
 * 5/12/11
 * 	- rework as a class
 * 23/6/12
 * 	- listen for "minimise" signal
 * 23/8/12
 * 	- split to line and tile cache
 * 	- use a hash table instead of a list
 * 13/9/12
 * 	- oops, linecache was oversized
 * 12/11/12
 * 	- make linecache 50% larger to give some slop room
 * 8/10/12
 * 	- make it optionally threaded
 * 21/2/13
 * 	- could deadlock if downstream raised an error (thanks Todd)
 * 25/4/13
 * 	- cache minimisation is optional, see "persistent" flag
 * 26/8/14 Lovell
 * 	- free the hash table in _dispose()
 * 11/7/16
 * 	- terminate on tile calc error
 * 7/3/17
 * 	- remove "access" on linecache, use the base class instead
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a cache of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/*
#define VIPS_DEBUG_RED
#define VIPS_DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/internal.h&gt;
#include &lt;vips/debug.h&gt;

#include "pconversion.h"

/* A tile in cache can be in one of three states:
 *
 * DATA		- the tile holds valid pixels 
 * CALC		- some thread somewhere is calculating it
 * PEND		- some thread somewhere wants it
 */
typedef enum VipsTileState {
	VIPS_TILE_STATE_DATA,
	VIPS_TILE_STATE_CALC,
	VIPS_TILE_STATE_PEND
} VipsTileState;

/* A tile in our cache.
 */
typedef struct _VipsTile {
	struct _VipsBlockCache *cache;

	VipsTileState state;

	VipsRegion *region;		/* Region with private mem for data */

	/* We count how many threads are relying on this tile. This tile can't
	 * be flushed if ref_count &gt; 0.
	 */
	int ref_count; 

	/* Tile position. Just use left/top to calculate a hash. This is the
	 * key for the hash table. Don't use region-&gt;valid in case the region
	 * pointer is NULL.
	 */
	VipsRect pos; 
} VipsTile;

typedef struct _VipsBlockCache {
	VipsConversion parent_instance;

	VipsImage *in;
	int tile_width;	
	int tile_height;
	int max_tiles;

	VipsAccess access;
	gboolean threaded;
	gboolean persistent;

	int ntiles;			/* Current cache size */
	GMutex *lock;			/* Lock everything here */
	GCond *new_tile;		/* A new tile is ready */
	GHashTable *tiles;		/* Tiles, hashed by coordinates */
	GQueue *recycle;		/* Queue of unreffed tiles to reuse */
} VipsBlockCache;

typedef VipsConversionClass VipsBlockCacheClass;

G_DEFINE_ABSTRACT_TYPE( VipsBlockCache, vips_block_cache, 
	VIPS_TYPE_CONVERSION );

#define VIPS_TYPE_BLOCK_CACHE (vips_block_cache_get_type())

static void
vips_block_cache_drop_all( VipsBlockCache *cache )
{
	/* FIXME this is a disaster if active threads are working on tiles. We
	 * should have something to block new requests, and only dispose once
	 * all tiles are unreffed.
	 */
	g_hash_table_remove_all( cache-&gt;tiles ); 
}

static void
vips_block_cache_dispose( GObject *gobject )
{
	VipsBlockCache *cache = (VipsBlockCache *) gobject;

	vips_block_cache_drop_all( cache );
	VIPS_FREEF( vips_g_mutex_free, cache-&gt;lock );
	VIPS_FREEF( vips_g_cond_free, cache-&gt;new_tile );

	if( cache-&gt;tiles )
		g_assert( g_hash_table_size( cache-&gt;tiles ) == 0 );
	VIPS_FREEF( g_hash_table_destroy, cache-&gt;tiles );
	VIPS_FREEF( g_queue_free, cache-&gt;recycle );

	G_OBJECT_CLASS( vips_block_cache_parent_class )-&gt;dispose( gobject );
}

static int
vips_tile_move( VipsTile *tile, int x, int y )
{
	/* We are changing x/y and therefore the hash value. We must unlink
	 * from the old hash position and relink at the new place.
	 */
	g_hash_table_steal( tile-&gt;cache-&gt;tiles, &amp;tile-&gt;pos );

	tile-&gt;pos.left = x;
	tile-&gt;pos.top = y;
	tile-&gt;pos.width = tile-&gt;cache-&gt;tile_width;
	tile-&gt;pos.height = tile-&gt;cache-&gt;tile_height;

	g_hash_table_insert( tile-&gt;cache-&gt;tiles, &amp;tile-&gt;pos, tile );

	if( vips_region_buffer( tile-&gt;region, &amp;tile-&gt;pos ) )
		return( -1 );

	/* No data yet, but someone must want it.
	 */
	tile-&gt;state = VIPS_TILE_STATE_PEND;

	return( 0 );
}

static VipsTile *
vips_tile_new( VipsBlockCache *cache, int x, int y )
{
	VipsTile *tile;

	if( !(tile = VIPS_NEW( NULL, VipsTile )) )
		return( NULL );

	tile-&gt;cache = cache;
	tile-&gt;state = VIPS_TILE_STATE_PEND;
	tile-&gt;ref_count = 0;
	tile-&gt;region = NULL;
	tile-&gt;pos.left = x;
	tile-&gt;pos.top = y;
	tile-&gt;pos.width = cache-&gt;tile_width;
	tile-&gt;pos.height = cache-&gt;tile_height;
	g_hash_table_insert( cache-&gt;tiles, &amp;tile-&gt;pos, tile );
	g_queue_push_tail( tile-&gt;cache-&gt;recycle, tile );
	g_assert( cache-&gt;ntiles &gt;= 0 );
	cache-&gt;ntiles += 1;

	if( !(tile-&gt;region = vips_region_new( cache-&gt;in )) ) {
		g_hash_table_remove( cache-&gt;tiles, &amp;tile-&gt;pos );
		return( NULL );
	}

	vips__region_no_ownership( tile-&gt;region );

	if( vips_tile_move( tile, x, y ) ) {
		g_hash_table_remove( cache-&gt;tiles, &amp;tile-&gt;pos );
		return( NULL );
	}

	return( tile );
}

/* Do we have a tile in the cache?
 */
static VipsTile *
vips_tile_search( VipsBlockCache *cache, int x, int y )
{
	VipsRect pos;
	VipsTile *tile;

	pos.left = x;
	pos.top = y;
	pos.width = cache-&gt;tile_width;
	pos.height = cache-&gt;tile_height;
	tile = (VipsTile *) g_hash_table_lookup( cache-&gt;tiles, &amp;pos );

	return( tile );
}

static void
vips_tile_find_is_topper( gpointer element, gpointer user_data )
{
	VipsTile *this = (VipsTile *) element;
	VipsTile **best = (VipsTile **) user_data;

	if( !*best ||
		this-&gt;pos.top &lt; (*best)-&gt;pos.top )
		*best = this;
}

/* Search the recycle list for the topmost tile.
 */
static VipsTile *
vips_tile_find_topmost( GQueue *recycle )
{
	VipsTile *tile;

	tile = NULL;
	g_queue_foreach( recycle, vips_tile_find_is_topper, &amp;tile );

	return( tile );
}

/* Find existing tile, make a new tile, or if we have a full set of tiles, 
 * reuse one.
 */
static VipsTile *
vips_tile_find( VipsBlockCache *cache, int x, int y )
{
	VipsTile *tile;

	/* In cache already?
	 */
	if( (tile = vips_tile_search( cache, x, y )) ) {
		VIPS_DEBUG_MSG_RED( "vips_tile_find: "
			"tile %d x %d in cache\n", x, y ); 
		return( tile );
	}

	/* VipsBlockCache not full?
	 */
	if( cache-&gt;max_tiles == -1 ||
		cache-&gt;ntiles &lt; cache-&gt;max_tiles ) {
		VIPS_DEBUG_MSG_RED( "vips_tile_find: "
			"making new tile at %d x %d\n", x, y ); 
		if( !(tile = vips_tile_new( cache, x, y )) )
			return( NULL );

		return( tile );
	}

	/* Reuse an old one, if there are any. We just peek the tile pointer,
	 * it is removed from the recycle list later on _ref.
	 */
	if( cache-&gt;recycle ) {
		if( cache-&gt;access == VIPS_ACCESS_RANDOM ) 
			tile = g_queue_peek_head( cache-&gt;recycle ); 
		else
			/* This is slower :( We have to search the recycle
			 * queue.
			 */
			tile = vips_tile_find_topmost( cache-&gt;recycle ); 
	}

	if( !tile ) {
		/* There are no tiles we can reuse -- we have to make another
		 * for now. They will get culled down again next time around.
		 */
		if( !(tile = vips_tile_new( cache, x, y )) ) 
			return( NULL );

		return( tile );
	}

	VIPS_DEBUG_MSG_RED( "vips_tile_find: reusing tile %d x %d\n", 
		tile-&gt;pos.left, tile-&gt;pos.top );

	if( vips_tile_move( tile, x, y ) )
		return( NULL );

	return( tile );
}

static gboolean            
vips_tile_unlocked( gpointer key, gpointer value, gpointer user_data )
{
	VipsTile *tile = (VipsTile *) value;

	return( !tile-&gt;ref_count );
}

static void
vips_block_cache_minimise( VipsImage *image, VipsBlockCache *cache )
{
	VIPS_DEBUG_MSG( "vips_block_cache_minimise:\n" ); 

	g_mutex_lock( cache-&gt;lock );

	/* We can't drop tiles that are in use.
	 */
	g_hash_table_foreach_remove( cache-&gt;tiles, 
		vips_tile_unlocked, NULL );

	g_mutex_unlock( cache-&gt;lock );
}

static int
vips_block_cache_build( VipsObject *object )
{
	VipsConversion *conversion = VIPS_CONVERSION( object );
	VipsBlockCache *cache = (VipsBlockCache *) object;

	VIPS_DEBUG_MSG( "vips_block_cache_build:\n" );

	if( VIPS_OBJECT_CLASS( vips_block_cache_parent_class )-&gt;
		build( object ) )
		return( -1 );

	VIPS_DEBUG_MSG( "vips_block_cache_build: max size = %g MB\n",
		(cache-&gt;max_tiles * cache-&gt;tile_width * cache-&gt;tile_height *
		 	VIPS_IMAGE_SIZEOF_PEL( cache-&gt;in )) / (1024 * 1024.0) );

	if( !cache-&gt;persistent )
<a name="0"></a>		g_signal_connect( conversion-&gt;out, "minimise", 
			G_CALLBACK( vips_block_cache_minimise ), cache );

<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
}

static void
vips_block_cache_class_init( VipsBlockCacheClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
	VipsOperationClass *operation_class = VIPS_OPERATION_CLASS( class );

	VIPS_DEBUG_MSG( "vips_block_cache_class_init\n" );

	gobject_class-&gt;dispose = vips_block_cache_dispose;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	vobject_class-&gt;nickname = "blockcache";
	vobject_class-&gt;description = _( "cache an image" );</b></font>
	vobject_class-&gt;build = vips_block_cache_build;

	operation_class-&gt;flags = VIPS_OPERATION_SEQUENTIAL;

	VIPS_ARG_IMAGE( class, "in", 1, 
		_( "Input" ), 
		_( "Input image" ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsBlockCache, in ) );

	VIPS_ARG_INT( class, "tile_height", 4, 
		_( "Tile height" ), 
		_( "Tile height in pixels" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsBlockCache, tile_height ),
		1, 1000000, 128 );

	VIPS_ARG_ENUM( class, "access", 6, 
		_( "Access" ), 
		_( "Expected access pattern" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsBlockCache, access ),
		VIPS_TYPE_ACCESS, VIPS_ACCESS_RANDOM );

	VIPS_ARG_BOOL( class, "threaded", 7, 
		_( "Threaded" ), 
		_( "Allow threaded access" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsBlockCache, threaded ),
		FALSE );

	VIPS_ARG_BOOL( class, "persistent", 8, 
		_( "Persistent" ), 
		_( "Keep cache between evaluations" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsBlockCache, persistent ),
		FALSE );
}

static unsigned int
vips_rect_hash( VipsRect *pos )
{
	guint hash;

	/* We could shift down by the tile size?
	 *
	 * X discrimination is more important than Y, since
	 * most tiles will have a similar Y. 
	 */
	hash = (guint) pos-&gt;left ^ ((guint) pos-&gt;top &lt;&lt; 16);

	return( hash );
}

static gboolean 
vips_rect_equal( VipsRect *a, VipsRect *b )
{
	return( a-&gt;left == b-&gt;left &amp;&amp; a-&gt;top == b-&gt;top );
}

static void
vips_tile_destroy( VipsTile *tile )
{
	VipsBlockCache *cache = tile-&gt;cache;

	VIPS_DEBUG_MSG_RED( "vips_tile_destroy: tile %d, %d (%p)\n", 
		tile-&gt;pos.left, tile-&gt;pos.top, tile ); 

	/* 0 ref tiles should be on the recycle list.
	 */
	g_assert( tile-&gt;ref_count == 0 );
	g_assert( g_queue_find( tile-&gt;cache-&gt;recycle, tile ) );
	g_queue_remove( cache-&gt;recycle, tile );

	cache-&gt;ntiles -= 1;
	g_assert( cache-&gt;ntiles &gt;= 0 );
	tile-&gt;cache = NULL;

	VIPS_UNREF( tile-&gt;region );

	g_free( tile );
}

static void
vips_block_cache_init( VipsBlockCache *cache )
{
	cache-&gt;tile_width = 128;
	cache-&gt;tile_height = 128;
	cache-&gt;max_tiles = 1000;
	cache-&gt;access = VIPS_ACCESS_RANDOM;
	cache-&gt;threaded = FALSE;
	cache-&gt;persistent = FALSE;

	cache-&gt;ntiles = 0;
	cache-&gt;lock = vips_g_mutex_new();
	cache-&gt;new_tile = vips_g_cond_new();
	cache-&gt;tiles = g_hash_table_new_full( 
		(GHashFunc) vips_rect_hash, 
		(GEqualFunc) vips_rect_equal,
		NULL,
		(GDestroyNotify) vips_tile_destroy );
	cache-&gt;recycle = g_queue_new();
}

typedef struct _VipsTileCache {
	VipsBlockCache parent_instance;

} VipsTileCache;

typedef VipsBlockCacheClass VipsTileCacheClass;

G_DEFINE_TYPE( VipsTileCache, vips_tile_cache, VIPS_TYPE_BLOCK_CACHE );

static void
vips_tile_unref( VipsTile *tile )
{
	g_assert( tile-&gt;ref_count &gt; 0 );

	tile-&gt;ref_count -= 1;

	if( tile-&gt;ref_count == 0 ) {
		/* Place at the end of the recycle queue. We pop from the
		 * front when selecting an unused tile for reuse.
		 */
		g_assert( !g_queue_find( tile-&gt;cache-&gt;recycle, tile ) );

		g_queue_push_tail( tile-&gt;cache-&gt;recycle, tile );
	}
}

static void
vips_tile_ref( VipsTile *tile )
{
	tile-&gt;ref_count += 1;

	g_assert( tile-&gt;ref_count &gt; 0 );

	if( tile-&gt;ref_count == 1 ) {
		g_assert( g_queue_find( tile-&gt;cache-&gt;recycle, tile ) );

		g_queue_remove( tile-&gt;cache-&gt;recycle, tile );
	}
}

static void
vips_tile_cache_unref( GSList *work )
{
	GSList *p;

	for( p = work; p; p = p-&gt;next ) 
		vips_tile_unref( (VipsTile *) p-&gt;data ); 

	g_slist_free( work );
}

/* Make a set of work tiles.
 */
static GSList *
vips_tile_cache_ref( VipsBlockCache *cache, VipsRect *r )
{
	const int tw = cache-&gt;tile_width;
	const int th = cache-&gt;tile_height;

	/* Find top left of tiles we need.
	 */
	const int xs = (r-&gt;left / tw) * tw;
	const int ys = (r-&gt;top / th) * th;

	GSList *work;
	VipsTile *tile;
	int x, y;

	/* Ref all the tiles we will need.
	 */
	work = NULL;
	for( y = ys; y &lt; VIPS_RECT_BOTTOM( r ); y += th )
		for( x = xs; x &lt; VIPS_RECT_RIGHT( r ); x += tw ) {
			if( !(tile = vips_tile_find( cache, x, y )) ) {
				vips_tile_cache_unref( work );
				return( NULL );
			}

			vips_tile_ref( tile ); 

			/* We must append, since we want to keep tile ordering
			 * for sequential sources.
			 */
			work = g_slist_append( work, tile );

			VIPS_DEBUG_MSG_RED( "vips_tile_cache_ref: "
				"tile %d, %d (%p)\n", x, y, tile ); 
		}

	return( work );
}

static void
vips_tile_paste( VipsTile *tile, VipsRegion *or )
{
	VipsRect hit;

	/* The part of the tile that we need.
	 */
	vips_rect_intersectrect( &amp;or-&gt;valid, &amp;tile-&gt;pos, &amp;hit );
	if( !vips_rect_isempty( &amp;hit ) )
		vips_region_copy( tile-&gt;region, or, &amp;hit, hit.left, hit.top ); 
}

/* Also called from vips_line_cache_gen(), beware.
 */
static int
vips_tile_cache_gen( VipsRegion *or, 
	void *seq, void *a, void *b, gboolean *stop )
{
	VipsRegion *in = (VipsRegion *) seq;
	VipsBlockCache *cache = (VipsBlockCache *) b;
	VipsRect *r = &amp;or-&gt;valid;

	VipsTile *tile;
	GSList *work;
	GSList *p;
	int result;

	result = 0;

	VIPS_GATE_START( "vips_tile_cache_gen: wait1" );

	g_mutex_lock( cache-&gt;lock );

	VIPS_GATE_STOP( "vips_tile_cache_gen: wait1" );

	VIPS_DEBUG_MSG_RED( "vips_tile_cache_gen: "
		"left = %d, top = %d, width = %d, height = %d\n",
		r-&gt;left, r-&gt;top, r-&gt;width, r-&gt;height );

	/* Ref all the tiles we will need.
	 */
	work = vips_tile_cache_ref( cache, r );

	while( work ) {
		/* Search for data tiles: easy, we can just paste those in.
		 */
		for(;;) { 
			for( p = work; p; p = p-&gt;next ) { 
				tile = (VipsTile *) p-&gt;data;

				if( tile-&gt;state == VIPS_TILE_STATE_DATA ) 
					break;
			}

			if( !p )
				break;

			VIPS_DEBUG_MSG_RED( "vips_tile_cache_gen: "
				"pasting %p\n", tile ); 

			vips_tile_paste( tile, or );

			/* We're done with this tile.
			 */
			work = g_slist_remove( work, tile );
			vips_tile_unref( tile ); 
		}

		/* Calculate the first PEND tile we find on the work list. We
		 * don't calculate all PEND tiles since after the first, more
		 * DATA tiles might heve been made available by other threads
		 * and we want to get them out of the way as soon as we can.
		 */
		for( p = work; p; p = p-&gt;next ) { 
			tile = (VipsTile *) p-&gt;data;

			if( tile-&gt;state == VIPS_TILE_STATE_PEND ) {
				tile-&gt;state = VIPS_TILE_STATE_CALC;

				VIPS_DEBUG_MSG_RED( "vips_tile_cache_gen: "
					"calc of %p\n", tile ); 

				/* In threaded mode, we let other threads run
				 * while we calc this tile. In non-threaded
				 * mode, we keep the lock and make 'em wait.
				 */
				if( cache-&gt;threaded ) 
					g_mutex_unlock( cache-&gt;lock );

				/* Don't compute if we've seen an error
				 * previously.
				 */
				if( !result )
					result = vips_region_prepare_to( in, 
						tile-&gt;region, 
						&amp;tile-&gt;pos, 
						tile-&gt;pos.left, tile-&gt;pos.top );

				if( cache-&gt;threaded ) {
					VIPS_GATE_START( "vips_tile_cache_gen: "
						"wait2" );

					g_mutex_lock( cache-&gt;lock );

					VIPS_GATE_STOP( "vips_tile_cache_gen: "
						"wait2" );
				}

				/* If there was an error calculating this
				 * tile, black it out and terminate
				 * calculation. We have to stop so we can
				 * support things like --fail on jpegload.
				 *
				 * Don't return early, we'd deadlock. 
				 */
				if( result ) {
					VIPS_DEBUG_MSG_RED( 
						"vips_tile_cache_gen: "
						"error on tile %p\n", tile ); 

					g_warning( _( "error in tile %d x %d" ),
						tile-&gt;pos.left, tile-&gt;pos.top );

					vips_region_black( tile-&gt;region );

					*stop = TRUE;
				}

				tile-&gt;state = VIPS_TILE_STATE_DATA;

				/* Let everyone know there's a new DATA tile. 
				 * They need to all check their work lists.
				 */
				g_cond_broadcast( cache-&gt;new_tile );

				break;
			}
		}

		/* There are no PEND or DATA tiles, we must need a tile some
		 * other thread is currently calculating.
		 *
		 * We must block until the CALC tiles we need are done.
		 */
		if( !p &amp;&amp; 
			work ) {
			for( p = work; p; p = p-&gt;next ) { 
				tile = (VipsTile *) p-&gt;data;

				g_assert( tile-&gt;state == VIPS_TILE_STATE_CALC );
			}

			VIPS_DEBUG_MSG_RED( "vips_tile_cache_gen: waiting\n" ); 

			VIPS_GATE_START( "vips_tile_cache_gen: wait3" );

			g_cond_wait( cache-&gt;new_tile, cache-&gt;lock );

			VIPS_GATE_STOP( "vips_tile_cache_gen: wait3" );

			VIPS_DEBUG_MSG( "vips_tile_cache_gen: awake!\n" ); 
		}
	}

	g_mutex_unlock( cache-&gt;lock );

	return( result );
}

static int
vips_tile_cache_build( VipsObject *object )
{
	VipsConversion *conversion = VIPS_CONVERSION( object );
	VipsBlockCache *block_cache = (VipsBlockCache *) object;
	VipsTileCache *cache = (VipsTileCache *) object;

	VIPS_DEBUG_MSG( "vips_tile_cache_build\n" );

	if( VIPS_OBJECT_CLASS( vips_tile_cache_parent_class )-&gt;
		build( object ) )
		return( -1 );

	if( vips_image_pio_input( block_cache-&gt;in ) )
		return( -1 );

	if( vips_image_pipelinev( conversion-&gt;out, 
		VIPS_DEMAND_STYLE_SMALLTILE, block_cache-&gt;in, NULL ) )
		return( -1 );

	if( vips_image_generate( conversion-&gt;out,
		vips_start_one, vips_tile_cache_gen, vips_stop_one, 
		block_cache-&gt;in, cache ) )
		return( -1 );

	return( 0 );
}

static void
vips_tile_cache_class_init( VipsTileCacheClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );

	VIPS_DEBUG_MSG( "vips_tile_cache_class_init\n" );

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	vobject_class-&gt;nickname = "tilecache";
	vobject_class-&gt;description = _( "cache an image as a set of tiles" );
	vobject_class-&gt;build = vips_tile_cache_build;

	VIPS_ARG_INT( class, "tile_width", 3, 
		_( "Tile width" ), 
		_( "Tile width in pixels" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsBlockCache, tile_width ),
		1, 1000000, 128 );

	VIPS_ARG_INT( class, "max_tiles", 5, 
		_( "Max tiles" ), 
		_( "Maximum number of tiles to cache" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsBlockCache, max_tiles ),
		-1, 1000000, 1000 );

}

static void
vips_tile_cache_init( VipsTileCache *cache )
{
}

/**
 * vips_tilecache: (method)
 * @in: input image
 * @out: (out): output image
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @tile_width: width of tiles in cache
 * * @tile_height: height of tiles in cache
 * * @max_tiles: maximum number of tiles to cache
 * * @access: hint expected access pattern #VipsAccess
 * * @threaded: allow many threads
 * * @persistent: don't drop cache at end of computation
 *
 * This operation behaves rather like vips_copy() between images
 * @in and @out, except that it keeps a cache of computed pixels. 
 * This cache is made of up to @max_tiles tiles (a value of -1 
 * means any number of tiles), and each tile is of size @tile_width
 * by @tile_height pixels. 
 *
 * Each cache tile is made with a single call to 
 * vips_region_prepare(). 
 *
 * When the cache fills, a tile is chosen for reuse. If @access is
 * #VIPS_ACCESS_RANDOM, then the least-recently-used tile is reused. If 
 * @access is #VIPS_ACCESS_SEQUENTIAL 
 * the top-most tile is reused.
 *
 * By default, @tile_width and @tile_height are 128 pixels, and the operation
 * will cache up to 1,000 tiles. @access defaults to #VIPS_ACCESS_RANDOM.
 *
 * Normally, only a single thread at once is allowed to calculate tiles. If
 * you set @threaded to %TRUE, vips_tilecache() will allow many threads to
 * calculate tiles at once, and share the cache between them.
 *
 * Normally the cache is dropped when computation finishes. Set @persistent to
 * %TRUE to keep the cache between computations.
 *
 * See also: vips_cache(), vips_linecache().
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_tilecache( VipsImage *in, VipsImage **out, ... )
{
	va_list ap;
	int result;

	va_start( ap, out );
	result = vips_call_split( "tilecache", ap, in, out );
	va_end( ap );

	return( result );
}

typedef struct _VipsLineCache {
	VipsBlockCache parent_instance;

} VipsLineCache;

typedef VipsBlockCacheClass VipsLineCacheClass;

G_DEFINE_TYPE( VipsLineCache, vips_line_cache, VIPS_TYPE_BLOCK_CACHE );

static int
vips_line_cache_gen( VipsRegion *or, 
	void *seq, void *a, void *b, gboolean *stop )
{
	VipsBlockCache *block_cache = (VipsBlockCache *) b;

	VIPS_GATE_START( "vips_line_cache_gen: wait" );

	g_mutex_lock( block_cache-&gt;lock );

	VIPS_GATE_STOP( "vips_line_cache_gen: wait" );

	/* We size up the cache to the largest request.
	 */
	if( or-&gt;valid.height &gt; 
		block_cache-&gt;max_tiles * block_cache-&gt;tile_height ) {
		block_cache-&gt;max_tiles = 
			1 + (or-&gt;valid.height / block_cache-&gt;tile_height);
		VIPS_DEBUG_MSG( "vips_line_cache_gen: bumped max_tiles to %d\n",
			block_cache-&gt;max_tiles ); 
	}

	g_mutex_unlock( block_cache-&gt;lock );

	return( vips_tile_cache_gen( or, seq, a, b, stop ) ); 
}

static int
vips_line_cache_build( VipsObject *object )
{
	VipsConversion *conversion = VIPS_CONVERSION( object );
	VipsBlockCache *block_cache = (VipsBlockCache *) object;
	VipsLineCache *cache = (VipsLineCache *) object;

	int tile_width;
	int tile_height;
	int n_lines;

	VIPS_DEBUG_MSG( "vips_line_cache_build\n" );

	if( !vips_object_argument_isset( object, "access" ) ) 
		block_cache-&gt;access = VIPS_ACCESS_SEQUENTIAL;

	if( VIPS_OBJECT_CLASS( vips_line_cache_parent_class )-&gt;
		build( object ) )
		return( -1 );

	/* This can go up with request size, see vips_line_cache_gen().
	 */
	vips_get_tile_size( block_cache-&gt;in, 
		&amp;tile_width, &amp;tile_height, &amp;n_lines );
	block_cache-&gt;tile_width = block_cache-&gt;in-&gt;Xsize;

	/* Output has two buffers n_lines height, so 2 * n_lines is the maximum
	 * non-locality from threading. Double again for conv, rounding, etc. 
	 *
	 * tile_height can be huge for things like tiff read, where we can
	 * have a whole strip in a single tile ... we still need to have a
	 * minimum of two strips, so we can handle requests that straddle a
	 * tile boundary.
	 */
	block_cache-&gt;max_tiles = VIPS_MAX( 2, 
		4 * n_lines / block_cache-&gt;tile_height );

	VIPS_DEBUG_MSG( "vips_line_cache_build: n_lines = %d\n", 
		n_lines );
	VIPS_DEBUG_MSG( "vips_line_cache_build: max_tiles = %d\n", 
		block_cache-&gt;max_tiles ); 
	VIPS_DEBUG_MSG( "vips_line_cache_build: tile_height = %d\n", 
		block_cache-&gt;tile_height ); 
	VIPS_DEBUG_MSG( "vips_line_cache_build: max size = %g MB\n",
		(block_cache-&gt;max_tiles * 
		 block_cache-&gt;tile_width * 
		 block_cache-&gt;tile_height * 
		 VIPS_IMAGE_SIZEOF_PEL( block_cache-&gt;in )) / (1024 * 1024.0) );

	if( vips_image_pio_input( block_cache-&gt;in ) )
		return( -1 );

	if( vips_image_pipelinev( conversion-&gt;out, 
		VIPS_DEMAND_STYLE_THINSTRIP, block_cache-&gt;in, NULL ) )
		return( -1 );

	if( vips_image_generate( conversion-&gt;out,
		vips_start_one, vips_line_cache_gen, vips_stop_one, 
		block_cache-&gt;in, cache ) )
		return( -1 );

	return( 0 );
}

static void
vips_line_cache_class_init( VipsLineCacheClass *class )
{
	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );

	VIPS_DEBUG_MSG( "vips_line_cache_class_init\n" );

	vobject_class-&gt;nickname = "linecache";
	vobject_class-&gt;description = _( "cache an image as a set of lines" );
	vobject_class-&gt;build = vips_line_cache_build;

}

static void
vips_line_cache_init( VipsLineCache *cache )
{
}

/**
 * vips_linecache: (method)
 * @in: input image
 * @out: (out): output image
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @access: hint expected access pattern #VipsAccess
 * * @tile_height: height of tiles in cache
 * * @threaded: allow many threads
 *
 * This operation behaves rather like vips_copy() between images
 * @in and @out, except that it keeps a cache of computed scanlines. 
 *
 * The number of lines cached is enough for a small amount of non-local
 * access. 
 *
 * Each cache tile is made with a single call to 
 * vips_region_prepare(). 
 *
 * When the cache fills, a tile is chosen for reuse. If @access is
 * #VIPS_ACCESS_RANDOM, then the least-recently-used tile is reused. If 
 * @access is #VIPS_ACCESS_SEQUENTIAL, then 
 * the top-most tile is reused. @access defaults to #VIPS_ACCESS_RANDOM.
 *
 * @tile_height can be used to set the size of the strips that
 * vips_linecache() uses. The default is 1 (a single scanline).
 *
 * Normally, only a single thread at once is allowed to calculate tiles. If
 * you set @threaded to %TRUE, vips_linecache() will allow many threads to
 * calculate tiles at once and share the cache between them.
 *
 * See also: vips_cache(), vips_tilecache(). 
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_linecache( VipsImage *in, VipsImage **out, ... )
{
	va_list ap;
	int result;

	va_start( ap, out );
	result = vips_call_split( "linecache", ap, in, out );
	va_end( ap );

	return( result );
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
