<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for eye.c &amp; tilecache.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for eye.c &amp; tilecache.c
      </h3>
<h1 align="center">
        6.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>eye.c (32.07547%)<th>tilecache.c (3.7444935%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(88-105)<td><a href="#" name="0">(378-395)</a><td align="center"><font color="#ff0000">17</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>eye.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;stdlib.h&gt;
7 #include &lt;math.h&gt;
8 #include &lt;vips/vips.h&gt;
9 #include "pcreate.h"
10 #include "point.h"
11 typedef struct _VipsEye {
12 	VipsPoint parent_instance;
13 	double factor;
14 } VipsEye;
15 typedef VipsPointClass VipsEyeClass;
16 G_DEFINE_TYPE( VipsEye, vips_eye, VIPS_TYPE_POINT );
17 static float
18 vips_eye_point( VipsPoint *point, int x, int y ) 
19 {
20 	VipsEye *eye = (VipsEye *) point;
21 	int max_x = VIPS_MAX( point-&gt;width - 1, 1 );
22 	int max_y = VIPS_MAX( point-&gt;height - 1, 1 );
23 <a name="0"></a>	double c = eye-&gt;factor * VIPS_PI / (2 * max_x);
24 	double h = max_y * max_y;
25 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( y * y * cos( c * x * x ) / h );
26 }
27 static void
28 vips_eye_class_init( VipsEyeClass *class )
29 {
30 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
31 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
32 	VipsPointClass *point_class = VIPS_POINT_CLASS( class );
33 	gobject_class-&gt;set_property = vips_object_set_property;
34 	gobject_class-&gt;get_property = vips_object_get_property;
35 	vobject_class-&gt;nickname = "eye";
36 	vobject_class-&gt;description = 
37 		_( "make an image showing the eye's spatial response" );
38 	point_class-&gt;point = vips_eye_point;</b></font>
39 	VIPS_ARG_DOUBLE( class, "factor", 6, 
40 		_( "Factor" ), 
41 		_( "Maximum spatial frequency" ),
42 		VIPS_ARGUMENT_OPTIONAL_INPUT,
43 		G_STRUCT_OFFSET( VipsEye, factor ),
44 		0.0, 1.0, 0.5 );
45 }
46 static void
47 vips_eye_init( VipsEye *eye )
48 {
49 	eye-&gt;factor = 0.5;
50 }
51 int
52 vips_eye( VipsImage **out, int width, int height, ... )
53 {
54 	va_list ap;
55 	int result;
56 	va_start( ap, height );
57 	result = vips_call_split( "eye", ap, out, width, height );
58 	va_end( ap );
59 	return( result );
60 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>tilecache.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/internal.h&gt;
9 #include &lt;vips/debug.h&gt;
10 #include "pconversion.h"
11 typedef enum VipsTileState {
12 	VIPS_TILE_STATE_DATA,
13 	VIPS_TILE_STATE_CALC,
14 	VIPS_TILE_STATE_PEND
15 } VipsTileState;
16 typedef struct _VipsTile {
17 	struct _VipsBlockCache *cache;
18 	VipsTileState state;
19 	VipsRegion *region;		
20 	int ref_count; 
21 	VipsRect pos; 
22 } VipsTile;
23 typedef struct _VipsBlockCache {
24 	VipsConversion parent_instance;
25 	VipsImage *in;
26 	int tile_width;	
27 	int tile_height;
28 	int max_tiles;
29 	VipsAccess access;
30 	gboolean threaded;
31 	gboolean persistent;
32 	int ntiles;				GMutex *lock;				GCond *new_tile;			GHashTable *tiles;			GQueue *recycle;		} VipsBlockCache;
33 typedef VipsConversionClass VipsBlockCacheClass;
34 G_DEFINE_ABSTRACT_TYPE( VipsBlockCache, vips_block_cache, 
35 	VIPS_TYPE_CONVERSION );
36 #define VIPS_TYPE_BLOCK_CACHE (vips_block_cache_get_type())
37 static void
38 vips_block_cache_drop_all( VipsBlockCache *cache )
39 {
40 	g_hash_table_remove_all( cache-&gt;tiles ); 
41 }
42 static void
43 vips_block_cache_dispose( GObject *gobject )
44 {
45 	VipsBlockCache *cache = (VipsBlockCache *) gobject;
46 	vips_block_cache_drop_all( cache );
47 	VIPS_FREEF( vips_g_mutex_free, cache-&gt;lock );
48 	VIPS_FREEF( vips_g_cond_free, cache-&gt;new_tile );
49 	if( cache-&gt;tiles )
50 		g_assert( g_hash_table_size( cache-&gt;tiles ) == 0 );
51 	VIPS_FREEF( g_hash_table_destroy, cache-&gt;tiles );
52 	VIPS_FREEF( g_queue_free, cache-&gt;recycle );
53 	G_OBJECT_CLASS( vips_block_cache_parent_class )-&gt;dispose( gobject );
54 }
55 static int
56 vips_tile_move( VipsTile *tile, int x, int y )
57 {
58 	g_hash_table_steal( tile-&gt;cache-&gt;tiles, &amp;tile-&gt;pos );
59 	tile-&gt;pos.left = x;
60 	tile-&gt;pos.top = y;
61 	tile-&gt;pos.width = tile-&gt;cache-&gt;tile_width;
62 	tile-&gt;pos.height = tile-&gt;cache-&gt;tile_height;
63 	g_hash_table_insert( tile-&gt;cache-&gt;tiles, &amp;tile-&gt;pos, tile );
64 	if( vips_region_buffer( tile-&gt;region, &amp;tile-&gt;pos ) )
65 		return( -1 );
66 	tile-&gt;state = VIPS_TILE_STATE_PEND;
67 	return( 0 );
68 }
69 static VipsTile *
70 vips_tile_new( VipsBlockCache *cache, int x, int y )
71 {
72 	VipsTile *tile;
73 	if( !(tile = VIPS_NEW( NULL, VipsTile )) )
74 		return( NULL );
75 	tile-&gt;cache = cache;
76 	tile-&gt;state = VIPS_TILE_STATE_PEND;
77 	tile-&gt;ref_count = 0;
78 	tile-&gt;region = NULL;
79 	tile-&gt;pos.left = x;
80 	tile-&gt;pos.top = y;
81 	tile-&gt;pos.width = cache-&gt;tile_width;
82 	tile-&gt;pos.height = cache-&gt;tile_height;
83 	g_hash_table_insert( cache-&gt;tiles, &amp;tile-&gt;pos, tile );
84 	g_queue_push_tail( tile-&gt;cache-&gt;recycle, tile );
85 	g_assert( cache-&gt;ntiles &gt;= 0 );
86 	cache-&gt;ntiles += 1;
87 	if( !(tile-&gt;region = vips_region_new( cache-&gt;in )) ) {
88 		g_hash_table_remove( cache-&gt;tiles, &amp;tile-&gt;pos );
89 		return( NULL );
90 	}
91 	vips__region_no_ownership( tile-&gt;region );
92 	if( vips_tile_move( tile, x, y ) ) {
93 		g_hash_table_remove( cache-&gt;tiles, &amp;tile-&gt;pos );
94 		return( NULL );
95 	}
96 	return( tile );
97 }
98 static VipsTile *
99 vips_tile_search( VipsBlockCache *cache, int x, int y )
100 {
101 	VipsRect pos;
102 	VipsTile *tile;
103 	pos.left = x;
104 	pos.top = y;
105 	pos.width = cache-&gt;tile_width;
106 	pos.height = cache-&gt;tile_height;
107 	tile = (VipsTile *) g_hash_table_lookup( cache-&gt;tiles, &amp;pos );
108 	return( tile );
109 }
110 static void
111 vips_tile_find_is_topper( gpointer element, gpointer user_data )
112 {
113 	VipsTile *this = (VipsTile *) element;
114 	VipsTile **best = (VipsTile **) user_data;
115 	if( !*best ||
116 		this-&gt;pos.top &lt; (*best)-&gt;pos.top )
117 		*best = this;
118 }
119 static VipsTile *
120 vips_tile_find_topmost( GQueue *recycle )
121 {
122 	VipsTile *tile;
123 	tile = NULL;
124 	g_queue_foreach( recycle, vips_tile_find_is_topper, &amp;tile );
125 	return( tile );
126 }
127 static VipsTile *
128 vips_tile_find( VipsBlockCache *cache, int x, int y )
129 {
130 	VipsTile *tile;
131 	if( (tile = vips_tile_search( cache, x, y )) ) {
132 		VIPS_DEBUG_MSG_RED( "vips_tile_find: "
133 			"tile %d x %d in cache\n", x, y ); 
134 		return( tile );
135 	}
136 	if( cache-&gt;max_tiles == -1 ||
137 		cache-&gt;ntiles &lt; cache-&gt;max_tiles ) {
138 		VIPS_DEBUG_MSG_RED( "vips_tile_find: "
139 			"making new tile at %d x %d\n", x, y ); 
140 		if( !(tile = vips_tile_new( cache, x, y )) )
141 			return( NULL );
142 		return( tile );
143 	}
144 	if( cache-&gt;recycle ) {
145 		if( cache-&gt;access == VIPS_ACCESS_RANDOM ) 
146 			tile = g_queue_peek_head( cache-&gt;recycle ); 
147 		else
148 			tile = vips_tile_find_topmost( cache-&gt;recycle ); 
149 	}
150 	if( !tile ) {
151 		if( !(tile = vips_tile_new( cache, x, y )) ) 
152 			return( NULL );
153 		return( tile );
154 	}
155 	VIPS_DEBUG_MSG_RED( "vips_tile_find: reusing tile %d x %d\n", 
156 		tile-&gt;pos.left, tile-&gt;pos.top );
157 	if( vips_tile_move( tile, x, y ) )
158 		return( NULL );
159 	return( tile );
160 }
161 static gboolean            
162 vips_tile_unlocked( gpointer key, gpointer value, gpointer user_data )
163 {
164 	VipsTile *tile = (VipsTile *) value;
165 	return( !tile-&gt;ref_count );
166 }
167 static void
168 vips_block_cache_minimise( VipsImage *image, VipsBlockCache *cache )
169 {
170 	VIPS_DEBUG_MSG( "vips_block_cache_minimise:\n" ); 
171 	g_mutex_lock( cache-&gt;lock );
172 	g_hash_table_foreach_remove( cache-&gt;tiles, 
173 		vips_tile_unlocked, NULL );
174 	g_mutex_unlock( cache-&gt;lock );
175 }
176 static int
177 vips_block_cache_build( VipsObject *object )
178 {
179 	VipsConversion *conversion = VIPS_CONVERSION( object );
180 	VipsBlockCache *cache = (VipsBlockCache *) object;
181 	VIPS_DEBUG_MSG( "vips_block_cache_build:\n" );
182 	if( VIPS_OBJECT_CLASS( vips_block_cache_parent_class )-&gt;
183 		build( object ) )
184 		return( -1 );
185 	VIPS_DEBUG_MSG( "vips_block_cache_build: max size = %g MB\n",
186 		(cache-&gt;max_tiles * cache-&gt;tile_width * cache-&gt;tile_height *
187 		 	VIPS_IMAGE_SIZEOF_PEL( cache-&gt;in )) / (1024 * 1024.0) );
188 	if( !cache-&gt;persistent )
189 <a name="0"></a>		g_signal_connect( conversion-&gt;out, "minimise", 
190 			G_CALLBACK( vips_block_cache_minimise ), cache );
191 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
192 }
193 static void
194 vips_block_cache_class_init( VipsBlockCacheClass *class )
195 {
196 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
197 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
198 	VipsOperationClass *operation_class = VIPS_OPERATION_CLASS( class );
199 	VIPS_DEBUG_MSG( "vips_block_cache_class_init\n" );
200 	gobject_class-&gt;dispose = vips_block_cache_dispose;
201 	gobject_class-&gt;set_property = vips_object_set_property;
202 	gobject_class-&gt;get_property = vips_object_get_property;
203 	vobject_class-&gt;nickname = "blockcache";
204 	vobject_class-&gt;description = _( "cache an image" );</b></font>
205 	vobject_class-&gt;build = vips_block_cache_build;
206 	operation_class-&gt;flags = VIPS_OPERATION_SEQUENTIAL;
207 	VIPS_ARG_IMAGE( class, "in", 1, 
208 		_( "Input" ), 
209 		_( "Input image" ),
210 		VIPS_ARGUMENT_REQUIRED_INPUT,
211 		G_STRUCT_OFFSET( VipsBlockCache, in ) );
212 	VIPS_ARG_INT( class, "tile_height", 4, 
213 		_( "Tile height" ), 
214 		_( "Tile height in pixels" ),
215 		VIPS_ARGUMENT_OPTIONAL_INPUT,
216 		G_STRUCT_OFFSET( VipsBlockCache, tile_height ),
217 		1, 1000000, 128 );
218 	VIPS_ARG_ENUM( class, "access", 6, 
219 		_( "Access" ), 
220 		_( "Expected access pattern" ),
221 		VIPS_ARGUMENT_OPTIONAL_INPUT,
222 		G_STRUCT_OFFSET( VipsBlockCache, access ),
223 		VIPS_TYPE_ACCESS, VIPS_ACCESS_RANDOM );
224 	VIPS_ARG_BOOL( class, "threaded", 7, 
225 		_( "Threaded" ), 
226 		_( "Allow threaded access" ),
227 		VIPS_ARGUMENT_OPTIONAL_INPUT,
228 		G_STRUCT_OFFSET( VipsBlockCache, threaded ),
229 		FALSE );
230 	VIPS_ARG_BOOL( class, "persistent", 8, 
231 		_( "Persistent" ), 
232 		_( "Keep cache between evaluations" ),
233 		VIPS_ARGUMENT_OPTIONAL_INPUT,
234 		G_STRUCT_OFFSET( VipsBlockCache, persistent ),
235 		FALSE );
236 }
237 static unsigned int
238 vips_rect_hash( VipsRect *pos )
239 {
240 	guint hash;
241 	hash = (guint) pos-&gt;left ^ ((guint) pos-&gt;top &lt;&lt; 16);
242 	return( hash );
243 }
244 static gboolean 
245 vips_rect_equal( VipsRect *a, VipsRect *b )
246 {
247 	return( a-&gt;left == b-&gt;left &amp;&amp; a-&gt;top == b-&gt;top );
248 }
249 static void
250 vips_tile_destroy( VipsTile *tile )
251 {
252 	VipsBlockCache *cache = tile-&gt;cache;
253 	VIPS_DEBUG_MSG_RED( "vips_tile_destroy: tile %d, %d (%p)\n", 
254 		tile-&gt;pos.left, tile-&gt;pos.top, tile ); 
255 	g_assert( tile-&gt;ref_count == 0 );
256 	g_assert( g_queue_find( tile-&gt;cache-&gt;recycle, tile ) );
257 	g_queue_remove( cache-&gt;recycle, tile );
258 	cache-&gt;ntiles -= 1;
259 	g_assert( cache-&gt;ntiles &gt;= 0 );
260 	tile-&gt;cache = NULL;
261 	VIPS_UNREF( tile-&gt;region );
262 	g_free( tile );
263 }
264 static void
265 vips_block_cache_init( VipsBlockCache *cache )
266 {
267 	cache-&gt;tile_width = 128;
268 	cache-&gt;tile_height = 128;
269 	cache-&gt;max_tiles = 1000;
270 	cache-&gt;access = VIPS_ACCESS_RANDOM;
271 	cache-&gt;threaded = FALSE;
272 	cache-&gt;persistent = FALSE;
273 	cache-&gt;ntiles = 0;
274 	cache-&gt;lock = vips_g_mutex_new();
275 	cache-&gt;new_tile = vips_g_cond_new();
276 	cache-&gt;tiles = g_hash_table_new_full( 
277 		(GHashFunc) vips_rect_hash, 
278 		(GEqualFunc) vips_rect_equal,
279 		NULL,
280 		(GDestroyNotify) vips_tile_destroy );
281 	cache-&gt;recycle = g_queue_new();
282 }
283 typedef struct _VipsTileCache {
284 	VipsBlockCache parent_instance;
285 } VipsTileCache;
286 typedef VipsBlockCacheClass VipsTileCacheClass;
287 G_DEFINE_TYPE( VipsTileCache, vips_tile_cache, VIPS_TYPE_BLOCK_CACHE );
288 static void
289 vips_tile_unref( VipsTile *tile )
290 {
291 	g_assert( tile-&gt;ref_count &gt; 0 );
292 	tile-&gt;ref_count -= 1;
293 	if( tile-&gt;ref_count == 0 ) {
294 		g_assert( !g_queue_find( tile-&gt;cache-&gt;recycle, tile ) );
295 		g_queue_push_tail( tile-&gt;cache-&gt;recycle, tile );
296 	}
297 }
298 static void
299 vips_tile_ref( VipsTile *tile )
300 {
301 	tile-&gt;ref_count += 1;
302 	g_assert( tile-&gt;ref_count &gt; 0 );
303 	if( tile-&gt;ref_count == 1 ) {
304 		g_assert( g_queue_find( tile-&gt;cache-&gt;recycle, tile ) );
305 		g_queue_remove( tile-&gt;cache-&gt;recycle, tile );
306 	}
307 }
308 static void
309 vips_tile_cache_unref( GSList *work )
310 {
311 	GSList *p;
312 	for( p = work; p; p = p-&gt;next ) 
313 		vips_tile_unref( (VipsTile *) p-&gt;data ); 
314 	g_slist_free( work );
315 }
316 static GSList *
317 vips_tile_cache_ref( VipsBlockCache *cache, VipsRect *r )
318 {
319 	const int tw = cache-&gt;tile_width;
320 	const int th = cache-&gt;tile_height;
321 	const int xs = (r-&gt;left / tw) * tw;
322 	const int ys = (r-&gt;top / th) * th;
323 	GSList *work;
324 	VipsTile *tile;
325 	int x, y;
326 	work = NULL;
327 	for( y = ys; y &lt; VIPS_RECT_BOTTOM( r ); y += th )
328 		for( x = xs; x &lt; VIPS_RECT_RIGHT( r ); x += tw ) {
329 			if( !(tile = vips_tile_find( cache, x, y )) ) {
330 				vips_tile_cache_unref( work );
331 				return( NULL );
332 			}
333 			vips_tile_ref( tile ); 
334 			work = g_slist_append( work, tile );
335 			VIPS_DEBUG_MSG_RED( "vips_tile_cache_ref: "
336 				"tile %d, %d (%p)\n", x, y, tile ); 
337 		}
338 	return( work );
339 }
340 static void
341 vips_tile_paste( VipsTile *tile, VipsRegion *or )
342 {
343 	VipsRect hit;
344 	vips_rect_intersectrect( &amp;or-&gt;valid, &amp;tile-&gt;pos, &amp;hit );
345 	if( !vips_rect_isempty( &amp;hit ) )
346 		vips_region_copy( tile-&gt;region, or, &amp;hit, hit.left, hit.top ); 
347 }
348 static int
349 vips_tile_cache_gen( VipsRegion *or, 
350 	void *seq, void *a, void *b, gboolean *stop )
351 {
352 	VipsRegion *in = (VipsRegion *) seq;
353 	VipsBlockCache *cache = (VipsBlockCache *) b;
354 	VipsRect *r = &amp;or-&gt;valid;
355 	VipsTile *tile;
356 	GSList *work;
357 	GSList *p;
358 	int result;
359 	result = 0;
360 	VIPS_GATE_START( "vips_tile_cache_gen: wait1" );
361 	g_mutex_lock( cache-&gt;lock );
362 	VIPS_GATE_STOP( "vips_tile_cache_gen: wait1" );
363 	VIPS_DEBUG_MSG_RED( "vips_tile_cache_gen: "
364 		"left = %d, top = %d, width = %d, height = %d\n",
365 		r-&gt;left, r-&gt;top, r-&gt;width, r-&gt;height );
366 	work = vips_tile_cache_ref( cache, r );
367 	while( work ) {
368 		for(;;) { 
369 			for( p = work; p; p = p-&gt;next ) { 
370 				tile = (VipsTile *) p-&gt;data;
371 				if( tile-&gt;state == VIPS_TILE_STATE_DATA ) 
372 					break;
373 			}
374 			if( !p )
375 				break;
376 			VIPS_DEBUG_MSG_RED( "vips_tile_cache_gen: "
377 				"pasting %p\n", tile ); 
378 			vips_tile_paste( tile, or );
379 			work = g_slist_remove( work, tile );
380 			vips_tile_unref( tile ); 
381 		}
382 		for( p = work; p; p = p-&gt;next ) { 
383 			tile = (VipsTile *) p-&gt;data;
384 			if( tile-&gt;state == VIPS_TILE_STATE_PEND ) {
385 				tile-&gt;state = VIPS_TILE_STATE_CALC;
386 				VIPS_DEBUG_MSG_RED( "vips_tile_cache_gen: "
387 					"calc of %p\n", tile ); 
388 				if( cache-&gt;threaded ) 
389 					g_mutex_unlock( cache-&gt;lock );
390 				if( !result )
391 					result = vips_region_prepare_to( in, 
392 						tile-&gt;region, 
393 						&amp;tile-&gt;pos, 
394 						tile-&gt;pos.left, tile-&gt;pos.top );
395 				if( cache-&gt;threaded ) {
396 					VIPS_GATE_START( "vips_tile_cache_gen: "
397 						"wait2" );
398 					g_mutex_lock( cache-&gt;lock );
399 					VIPS_GATE_STOP( "vips_tile_cache_gen: "
400 						"wait2" );
401 				}
402 				if( result ) {
403 					VIPS_DEBUG_MSG_RED( 
404 						"vips_tile_cache_gen: "
405 						"error on tile %p\n", tile ); 
406 					g_warning( _( "error in tile %d x %d" ),
407 						tile-&gt;pos.left, tile-&gt;pos.top );
408 					vips_region_black( tile-&gt;region );
409 					*stop = TRUE;
410 				}
411 				tile-&gt;state = VIPS_TILE_STATE_DATA;
412 				g_cond_broadcast( cache-&gt;new_tile );
413 				break;
414 			}
415 		}
416 		if( !p &amp;&amp; 
417 			work ) {
418 			for( p = work; p; p = p-&gt;next ) { 
419 				tile = (VipsTile *) p-&gt;data;
420 				g_assert( tile-&gt;state == VIPS_TILE_STATE_CALC );
421 			}
422 			VIPS_DEBUG_MSG_RED( "vips_tile_cache_gen: waiting\n" ); 
423 			VIPS_GATE_START( "vips_tile_cache_gen: wait3" );
424 			g_cond_wait( cache-&gt;new_tile, cache-&gt;lock );
425 			VIPS_GATE_STOP( "vips_tile_cache_gen: wait3" );
426 			VIPS_DEBUG_MSG( "vips_tile_cache_gen: awake!\n" ); 
427 		}
428 	}
429 	g_mutex_unlock( cache-&gt;lock );
430 	return( result );
431 }
432 static int
433 vips_tile_cache_build( VipsObject *object )
434 {
435 	VipsConversion *conversion = VIPS_CONVERSION( object );
436 	VipsBlockCache *block_cache = (VipsBlockCache *) object;
437 	VipsTileCache *cache = (VipsTileCache *) object;
438 	VIPS_DEBUG_MSG( "vips_tile_cache_build\n" );
439 	if( VIPS_OBJECT_CLASS( vips_tile_cache_parent_class )-&gt;
440 		build( object ) )
441 		return( -1 );
442 	if( vips_image_pio_input( block_cache-&gt;in ) )
443 		return( -1 );
444 	if( vips_image_pipelinev( conversion-&gt;out, 
445 		VIPS_DEMAND_STYLE_SMALLTILE, block_cache-&gt;in, NULL ) )
446 		return( -1 );
447 	if( vips_image_generate( conversion-&gt;out,
448 		vips_start_one, vips_tile_cache_gen, vips_stop_one, 
449 		block_cache-&gt;in, cache ) )
450 		return( -1 );
451 	return( 0 );
452 }
453 static void
454 vips_tile_cache_class_init( VipsTileCacheClass *class )
455 {
456 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
457 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
458 	VIPS_DEBUG_MSG( "vips_tile_cache_class_init\n" );
459 	gobject_class-&gt;set_property = vips_object_set_property;
460 	gobject_class-&gt;get_property = vips_object_get_property;
461 	vobject_class-&gt;nickname = "tilecache";
462 	vobject_class-&gt;description = _( "cache an image as a set of tiles" );
463 	vobject_class-&gt;build = vips_tile_cache_build;
464 	VIPS_ARG_INT( class, "tile_width", 3, 
465 		_( "Tile width" ), 
466 		_( "Tile width in pixels" ),
467 		VIPS_ARGUMENT_OPTIONAL_INPUT,
468 		G_STRUCT_OFFSET( VipsBlockCache, tile_width ),
469 		1, 1000000, 128 );
470 	VIPS_ARG_INT( class, "max_tiles", 5, 
471 		_( "Max tiles" ), 
472 		_( "Maximum number of tiles to cache" ),
473 		VIPS_ARGUMENT_OPTIONAL_INPUT,
474 		G_STRUCT_OFFSET( VipsBlockCache, max_tiles ),
475 		-1, 1000000, 1000 );
476 }
477 static void
478 vips_tile_cache_init( VipsTileCache *cache )
479 {
480 }
481 int
482 vips_tilecache( VipsImage *in, VipsImage **out, ... )
483 {
484 	va_list ap;
485 	int result;
486 	va_start( ap, out );
487 	result = vips_call_split( "tilecache", ap, in, out );
488 	va_end( ap );
489 	return( result );
490 }
491 typedef struct _VipsLineCache {
492 	VipsBlockCache parent_instance;
493 } VipsLineCache;
494 typedef VipsBlockCacheClass VipsLineCacheClass;
495 G_DEFINE_TYPE( VipsLineCache, vips_line_cache, VIPS_TYPE_BLOCK_CACHE );
496 static int
497 vips_line_cache_gen( VipsRegion *or, 
498 	void *seq, void *a, void *b, gboolean *stop )
499 {
500 	VipsBlockCache *block_cache = (VipsBlockCache *) b;
501 	VIPS_GATE_START( "vips_line_cache_gen: wait" );
502 	g_mutex_lock( block_cache-&gt;lock );
503 	VIPS_GATE_STOP( "vips_line_cache_gen: wait" );
504 	if( or-&gt;valid.height &gt; 
505 		block_cache-&gt;max_tiles * block_cache-&gt;tile_height ) {
506 		block_cache-&gt;max_tiles = 
507 			1 + (or-&gt;valid.height / block_cache-&gt;tile_height);
508 		VIPS_DEBUG_MSG( "vips_line_cache_gen: bumped max_tiles to %d\n",
509 			block_cache-&gt;max_tiles ); 
510 	}
511 	g_mutex_unlock( block_cache-&gt;lock );
512 	return( vips_tile_cache_gen( or, seq, a, b, stop ) ); 
513 }
514 static int
515 vips_line_cache_build( VipsObject *object )
516 {
517 	VipsConversion *conversion = VIPS_CONVERSION( object );
518 	VipsBlockCache *block_cache = (VipsBlockCache *) object;
519 	VipsLineCache *cache = (VipsLineCache *) object;
520 	int tile_width;
521 	int tile_height;
522 	int n_lines;
523 	VIPS_DEBUG_MSG( "vips_line_cache_build\n" );
524 	if( !vips_object_argument_isset( object, "access" ) ) 
525 		block_cache-&gt;access = VIPS_ACCESS_SEQUENTIAL;
526 	if( VIPS_OBJECT_CLASS( vips_line_cache_parent_class )-&gt;
527 		build( object ) )
528 		return( -1 );
529 	vips_get_tile_size( block_cache-&gt;in, 
530 		&amp;tile_width, &amp;tile_height, &amp;n_lines );
531 	block_cache-&gt;tile_width = block_cache-&gt;in-&gt;Xsize;
532 	block_cache-&gt;max_tiles = VIPS_MAX( 2, 
533 		4 * n_lines / block_cache-&gt;tile_height );
534 	VIPS_DEBUG_MSG( "vips_line_cache_build: n_lines = %d\n", 
535 		n_lines );
536 	VIPS_DEBUG_MSG( "vips_line_cache_build: max_tiles = %d\n", 
537 		block_cache-&gt;max_tiles ); 
538 	VIPS_DEBUG_MSG( "vips_line_cache_build: tile_height = %d\n", 
539 		block_cache-&gt;tile_height ); 
540 	VIPS_DEBUG_MSG( "vips_line_cache_build: max size = %g MB\n",
541 		(block_cache-&gt;max_tiles * 
542 		 block_cache-&gt;tile_width * 
543 		 block_cache-&gt;tile_height * 
544 		 VIPS_IMAGE_SIZEOF_PEL( block_cache-&gt;in )) / (1024 * 1024.0) );
545 	if( vips_image_pio_input( block_cache-&gt;in ) )
546 		return( -1 );
547 	if( vips_image_pipelinev( conversion-&gt;out, 
548 		VIPS_DEMAND_STYLE_THINSTRIP, block_cache-&gt;in, NULL ) )
549 		return( -1 );
550 	if( vips_image_generate( conversion-&gt;out,
551 		vips_start_one, vips_line_cache_gen, vips_stop_one, 
552 		block_cache-&gt;in, cache ) )
553 		return( -1 );
554 	return( 0 );
555 }
556 static void
557 vips_line_cache_class_init( VipsLineCacheClass *class )
558 {
559 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
560 	VIPS_DEBUG_MSG( "vips_line_cache_class_init\n" );
561 	vobject_class-&gt;nickname = "linecache";
562 	vobject_class-&gt;description = _( "cache an image as a set of lines" );
563 	vobject_class-&gt;build = vips_line_cache_build;
564 }
565 static void
566 vips_line_cache_init( VipsLineCache *cache )
567 {
568 }
569 int
570 vips_linecache( VipsImage *in, VipsImage **out, ... )
571 {
572 	va_list ap;
573 	int result;
574 	va_start( ap, out );
575 	result = vips_call_split( "linecache", ap, in, out );
576 	va_end( ap );
577 	return( result );
578 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
