
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_twi.h</h3>
            <pre><code>1  #ifndef NRF_TWI_H__
2  #define NRF_TWI_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  typedef enum
8  {
9      NRF_TWI_TASK_STARTRX = offsetof(NRF_TWI_Type, TASKS_STARTRX), 
10      NRF_TWI_TASK_STARTTX = offsetof(NRF_TWI_Type, TASKS_STARTTX), 
11      NRF_TWI_TASK_STOP    = offsetof(NRF_TWI_Type, TASKS_STOP),    
12      NRF_TWI_TASK_SUSPEND = offsetof(NRF_TWI_Type, TASKS_SUSPEND), 
13      NRF_TWI_TASK_RESUME  = offsetof(NRF_TWI_Type, TASKS_RESUME)   
14  } nrf_twi_task_t;
15  typedef enum
16  {
17      NRF_TWI_EVENT_STOPPED   = offsetof(NRF_TWI_Type, EVENTS_STOPPED),  
18      NRF_TWI_EVENT_RXDREADY  = offsetof(NRF_TWI_Type, EVENTS_RXDREADY), 
19      NRF_TWI_EVENT_TXDSENT   = offsetof(NRF_TWI_Type, EVENTS_TXDSENT),  
20      NRF_TWI_EVENT_ERROR     = offsetof(NRF_TWI_Type, EVENTS_ERROR),    
21      NRF_TWI_EVENT_BB        = offsetof(NRF_TWI_Type, EVENTS_BB),       
22      NRF_TWI_EVENT_SUSPENDED = offsetof(NRF_TWI_Type, EVENTS_SUSPENDED) 
23  } nrf_twi_event_t;
24  typedef enum
25  {
<span onclick='openModal()' class='match'>26      NRF_TWI_SHORT_BB_SUSPEND_MASK = TWI_SHORTS_BB_SUSPEND_Msk,  
27      NRF_TWI_SHORT_BB_STOP_MASK    = TWI_SHORTS_BB_STOP_Msk,     
28      NRF_TWI_ALL_SHORTS_MASK       = TWI_SHORTS_BB_SUSPEND_Msk |
29                                      TWI_SHORTS_BB_STOP_Msk      
30  } nrf_twi_short_mask_t;
31  typedef enum
</span>32  {
33      NRF_TWI_INT_STOPPED_MASK    = TWI_INTENSET_STOPPED_Msk,    
34      NRF_TWI_INT_RXDREADY_MASK   = TWI_INTENSET_RXDREADY_Msk,   
35      NRF_TWI_INT_TXDSENT_MASK    = TWI_INTENSET_TXDSENT_Msk,    
36      NRF_TWI_INT_ERROR_MASK      = TWI_INTENSET_ERROR_Msk,      
37      NRF_TWI_INT_BB_MASK         = TWI_INTENSET_BB_Msk,         
38      NRF_TWI_INT_SUSPENDED_MASK  = TWI_INTENSET_SUSPENDED_Msk,  
39      NRF_TWI_ALL_INTS_MASK       = TWI_INTENSET_STOPPED_Msk   |
40                                    TWI_INTENSET_RXDREADY_Msk  |
41                                    TWI_INTENSET_TXDSENT_Msk   |
42                                    TWI_INTENSET_ERROR_Msk     |
43                                    TWI_INTENSET_BB_Msk        |
44                                    TWI_INTENSET_SUSPENDED_Msk   
45  } nrf_twi_int_mask_t;
46  typedef enum
47  {
48      NRF_TWI_ERROR_ADDRESS_NACK = TWI_ERRORSRC_ANACK_Msk,  
49      NRF_TWI_ERROR_DATA_NACK    = TWI_ERRORSRC_DNACK_Msk,  
50      NRF_TWI_ERROR_OVERRUN      = TWI_ERRORSRC_OVERRUN_Msk 
51  } nrf_twi_error_t;
52  typedef enum
53  {
54      NRF_TWI_FREQ_100K = TWI_FREQUENCY_FREQUENCY_K100, 
55      NRF_TWI_FREQ_250K = TWI_FREQUENCY_FREQUENCY_K250, 
56      NRF_TWI_FREQ_400K = TWI_FREQUENCY_FREQUENCY_K400  
57  } nrf_twi_frequency_t;
58  NRF_STATIC_INLINE void nrf_twi_task_trigger(NRF_TWI_Type * p_reg,
59                                              nrf_twi_task_t task);
60  NRF_STATIC_INLINE uint32_t nrf_twi_task_address_get(NRF_TWI_Type const * p_reg,
61                                                      nrf_twi_task_t       task);
62  NRF_STATIC_INLINE void nrf_twi_event_clear(NRF_TWI_Type *  p_reg,
63                                             nrf_twi_event_t event);
64  NRF_STATIC_INLINE bool nrf_twi_event_check(NRF_TWI_Type const * p_reg,
65                                             nrf_twi_event_t      event);
66  NRF_STATIC_INLINE uint32_t nrf_twi_event_address_get(NRF_TWI_Type const * p_reg,
67                                                       nrf_twi_event_t      event);
68  NRF_STATIC_INLINE void nrf_twi_shorts_enable(NRF_TWI_Type * p_reg,
69                                               uint32_t       mask);
70  NRF_STATIC_INLINE void nrf_twi_shorts_disable(NRF_TWI_Type * p_reg,
71                                                uint32_t       mask);
72  NRF_STATIC_INLINE void nrf_twi_int_enable(NRF_TWI_Type * p_reg,
73                                            uint32_t       mask);
74  NRF_STATIC_INLINE void nrf_twi_int_disable(NRF_TWI_Type * p_reg,
75                                             uint32_t       mask);
76  NRF_STATIC_INLINE uint32_t nrf_twi_int_enable_check(NRF_TWI_Type const * p_reg, uint32_t mask);
77  NRF_STATIC_INLINE void nrf_twi_enable(NRF_TWI_Type * p_reg);
78  NRF_STATIC_INLINE void nrf_twi_disable(NRF_TWI_Type * p_reg);
79  NRF_STATIC_INLINE void nrf_twi_pins_set(NRF_TWI_Type * p_reg,
80                                          uint32_t       scl_pin,
81                                          uint32_t       sda_pin);
82  NRF_STATIC_INLINE uint32_t nrf_twi_scl_pin_get(NRF_TWI_Type const * p_reg);
83  NRF_STATIC_INLINE uint32_t nrf_twi_sda_pin_get(NRF_TWI_Type const * p_reg);
84  NRF_STATIC_INLINE void nrf_twi_frequency_set(NRF_TWI_Type *      p_reg,
85                                               nrf_twi_frequency_t frequency);
86  NRF_STATIC_INLINE uint32_t nrf_twi_errorsrc_get_and_clear(NRF_TWI_Type * p_reg);
87  NRF_STATIC_INLINE void nrf_twi_address_set(NRF_TWI_Type * p_reg, uint8_t address);
88  NRF_STATIC_INLINE uint8_t nrf_twi_rxd_get(NRF_TWI_Type const * p_reg);
89  NRF_STATIC_INLINE void nrf_twi_txd_set(NRF_TWI_Type * p_reg, uint8_t data);
90  NRF_STATIC_INLINE void nrf_twi_shorts_set(NRF_TWI_Type * p_reg,
91                                            uint32_t       mask);
92  #ifndef NRF_DECLARE_ONLY
93  NRF_STATIC_INLINE void nrf_twi_task_trigger(NRF_TWI_Type * p_reg,
94                                              nrf_twi_task_t task)
95  {
96      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
97  }
98  NRF_STATIC_INLINE uint32_t nrf_twi_task_address_get(NRF_TWI_Type const * p_reg,
99                                                      nrf_twi_task_t       task)
100  {
101      return (uint32_t)((uint8_t *)p_reg + (uint32_t)task);
102  }
103  NRF_STATIC_INLINE void nrf_twi_event_clear(NRF_TWI_Type  * p_reg,
104                                             nrf_twi_event_t event)
105  {
106      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
107  #if __CORTEX_M == 0x04
108      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
109      (void)dummy;
110  #endif
111  }
112  NRF_STATIC_INLINE bool nrf_twi_event_check(NRF_TWI_Type const * p_reg,
113                                             nrf_twi_event_t      event)
114  {
115      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
116  }
117  NRF_STATIC_INLINE uint32_t nrf_twi_event_address_get(NRF_TWI_Type const * p_reg,
118                                                       nrf_twi_event_t      event)
119  {
120      return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
121  }
122  NRF_STATIC_INLINE void nrf_twi_shorts_enable(NRF_TWI_Type * p_reg,
123                                               uint32_t       mask)
124  {
125      p_reg->SHORTS |= mask;
126  }
127  NRF_STATIC_INLINE void nrf_twi_shorts_disable(NRF_TWI_Type * p_reg,
128                                                uint32_t       mask)
129  {
130      p_reg->SHORTS &= ~(mask);
131  }
132  NRF_STATIC_INLINE void nrf_twi_int_enable(NRF_TWI_Type * p_reg,
133                                            uint32_t       mask)
134  {
135      p_reg->INTENSET = mask;
136  }
137  NRF_STATIC_INLINE void nrf_twi_int_disable(NRF_TWI_Type * p_reg,
138                                             uint32_t       mask)
139  {
140      p_reg->INTENCLR = mask;
141  }
142  NRF_STATIC_INLINE uint32_t nrf_twi_int_enable_check(NRF_TWI_Type const * p_reg, uint32_t mask)
143  {
144      return p_reg->INTENSET & mask;
145  }
146  NRF_STATIC_INLINE void nrf_twi_enable(NRF_TWI_Type * p_reg)
147  {
148      p_reg->ENABLE = (TWI_ENABLE_ENABLE_Enabled << TWI_ENABLE_ENABLE_Pos);
149  }
150  NRF_STATIC_INLINE void nrf_twi_disable(NRF_TWI_Type * p_reg)
151  {
152      p_reg->ENABLE = (TWI_ENABLE_ENABLE_Disabled << TWI_ENABLE_ENABLE_Pos);
153  }
154  NRF_STATIC_INLINE void nrf_twi_pins_set(NRF_TWI_Type * p_reg,
155                                          uint32_t       scl_pin,
156                                          uint32_t       sda_pin)
157  {
158  #if defined(TWI_PSEL_SCL_CONNECT_Pos)
159      p_reg->PSEL.SCL = scl_pin;
160  #else
161      p_reg->PSELSCL = scl_pin;
162  #endif
163  #if defined(TWI_PSEL_SDA_CONNECT_Pos)
164      p_reg->PSEL.SDA = sda_pin;
165  #else
166      p_reg->PSELSDA = sda_pin;
167  #endif
168  }
169  NRF_STATIC_INLINE uint32_t nrf_twi_scl_pin_get(NRF_TWI_Type const * p_reg)
170  {
171  #if defined(TWI_PSEL_SCL_CONNECT_Pos)
172      return p_reg->PSEL.SCL;
173  #else
174      return p_reg->PSELSCL;
175  #endif
176  }
177  NRF_STATIC_INLINE uint32_t nrf_twi_sda_pin_get(NRF_TWI_Type const * p_reg)
178  {
179  #if defined(TWI_PSEL_SDA_CONNECT_Pos)
180      return p_reg->PSEL.SDA;
181  #else
182      return p_reg->PSELSDA;
183  #endif
184  }
185  NRF_STATIC_INLINE void nrf_twi_frequency_set(NRF_TWI_Type *      p_reg,
186                                               nrf_twi_frequency_t frequency)
187  {
188      p_reg->FREQUENCY = frequency;
189  }
190  NRF_STATIC_INLINE uint32_t nrf_twi_errorsrc_get_and_clear(NRF_TWI_Type * p_reg)
191  {
192      uint32_t error_source = p_reg->ERRORSRC;
193      p_reg->ERRORSRC = error_source;
194      return error_source;
195  }
196  NRF_STATIC_INLINE void nrf_twi_address_set(NRF_TWI_Type * p_reg, uint8_t address)
197  {
198      p_reg->ADDRESS = address;
199  }
200  NRF_STATIC_INLINE uint8_t nrf_twi_rxd_get(NRF_TWI_Type const * p_reg)
201  {
202      return (uint8_t)p_reg->RXD;
203  }
204  NRF_STATIC_INLINE void nrf_twi_txd_set(NRF_TWI_Type * p_reg, uint8_t data)
205  {
206      p_reg->TXD = data;
207  }
208  NRF_STATIC_INLINE void nrf_twi_shorts_set(NRF_TWI_Type * p_reg,
209                                            uint32_t       mask)
210  {
211      p_reg->SHORTS = mask;
212  }
213  #endif 
214  #ifdef __cplusplus
215  }
216  #endif
217  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_nvmc.h</h3>
            <pre><code>1  #ifndef NRF_NVMC_H__
2  #define NRF_NVMC_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #if defined(NVMC_ERASEPAGEPARTIALCFG_DURATION_Msk) || defined(__NRFX_DOXYGEN__)
8  #define NRF_NVMC_PARTIAL_ERASE_PRESENT
9  #endif
10  typedef enum
11  {
12      NRF_NVMC_MODE_READONLY      = NVMC_CONFIG_WEN_Ren, 
13      NRF_NVMC_MODE_WRITE         = NVMC_CONFIG_WEN_Wen, 
14      NRF_NVMC_MODE_ERASE         = NVMC_CONFIG_WEN_Een, 
15  #if defined(NVMC_CONFIG_WEN_PEen)
16      NRF_NVMC_MODE_PARTIAL_ERASE = NVMC_CONFIG_WEN_PEen 
17  #endif
18  } nrf_nvmc_mode_t;
19  #if defined(NVMC_CONFIGNS_WEN_Msk) || defined(__NRFX_DOXYGEN__)
20  typedef enum
21  {
22      NRF_NVMC_NS_MODE_READONLY = NVMC_CONFIGNS_WEN_Ren, 
23      NRF_NVMC_NS_MODE_WRITE    = NVMC_CONFIGNS_WEN_Wen, 
24      NRF_NVMC_NS_MODE_ERASE    = NVMC_CONFIGNS_WEN_Een, 
25  } nrf_nvmc_ns_mode_t;
26  #endif
27  #if defined(NVMC_FEATURE_CACHE_PRESENT)
28  typedef enum
29  {
<span onclick='openModal()' class='match'>30      NRF_NVMC_ICACHE_DISABLE               = NVMC_ICACHECNF_CACHEEN_Disabled, 
31      NRF_NVMC_ICACHE_ENABLE                = NVMC_ICACHECNF_CACHEEN_Enabled,  
32      NRF_NVMC_ICACHE_ENABLE_WITH_PROFILING = NVMC_ICACHECNF_CACHEEN_Enabled | 
33                                              NVMC_ICACHECNF_CACHEPROFEN_Msk
34  } nrf_nvmc_icache_config_t;
35  #endif 
</span>36  NRF_STATIC_INLINE bool nrf_nvmc_ready_check(NRF_NVMC_Type const * p_reg);
37  #if defined(NVMC_READYNEXT_READYNEXT_Msk) || defined(__NRFX_DOXYGEN__)
38  NRF_STATIC_INLINE bool nrf_nvmc_write_ready_check(NRF_NVMC_Type const * p_reg);
39  #endif 
40  NRF_STATIC_INLINE void nrf_nvmc_mode_set(NRF_NVMC_Type * p_reg,
41                                           nrf_nvmc_mode_t mode);
42  #if defined(NVMC_CONFIGNS_WEN_Msk) || defined(__NRFX_DOXYGEN__)
43  NRF_STATIC_INLINE void nrf_nvmc_nonsecure_mode_set(NRF_NVMC_Type *    p_reg,
44                                                     nrf_nvmc_ns_mode_t mode);
45  #endif
46  NRF_STATIC_INLINE void nrf_nvmc_page_erase_start(NRF_NVMC_Type * p_reg,
47                                                   uint32_t        page_addr);
48  #if defined(NVMC_ERASEUICR_ERASEUICR_Msk) || defined(__NRFX_DOXYGEN__)
49  NRF_STATIC_INLINE void nrf_nvmc_uicr_erase_start(NRF_NVMC_Type * p_reg);
50  #endif
51  NRF_STATIC_INLINE void nrf_nvmc_erase_all_start(NRF_NVMC_Type * p_reg);
52  #if defined(NRF_NVMC_PARTIAL_ERASE_PRESENT)
53  NRF_STATIC_INLINE void nrf_nvmc_partial_erase_duration_set(NRF_NVMC_Type * p_reg,
54                                                             uint32_t        duration_ms);
55  NRF_STATIC_INLINE uint32_t nrf_nvmc_partial_erase_duration_get(NRF_NVMC_Type const * p_reg);
56  NRF_STATIC_INLINE void nrf_nvmc_page_partial_erase_start(NRF_NVMC_Type * p_reg,
57                                                           uint32_t        page_addr);
58  #endif 
59  #if defined(NVMC_FEATURE_CACHE_PRESENT)
60  NRF_STATIC_INLINE void nrf_nvmc_icache_config_set(NRF_NVMC_Type *          p_reg,
61                                                    nrf_nvmc_icache_config_t config);
62  NRF_STATIC_INLINE bool nrf_nvmc_icache_enable_check(NRF_NVMC_Type const * p_reg);
63  NRF_STATIC_INLINE bool nrf_nvmc_icache_profiling_enable_check(NRF_NVMC_Type const * p_reg);
64  NRF_STATIC_INLINE uint32_t nrf_nvmc_icache_hit_get(NRF_NVMC_Type const * p_reg);
65  NRF_STATIC_INLINE uint32_t nrf_nvmc_icache_miss_get(NRF_NVMC_Type const * p_reg);
66   NRF_STATIC_INLINE void nrf_nvmc_icache_hit_miss_reset(NRF_NVMC_Type * p_reg);
67  #endif 
68  #ifndef NRF_DECLARE_ONLY
69  NRF_STATIC_INLINE bool nrf_nvmc_ready_check(NRF_NVMC_Type const * p_reg)
70  {
71      return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
72  }
73  #if defined(NVMC_READYNEXT_READYNEXT_Msk)
74  NRF_STATIC_INLINE bool nrf_nvmc_write_ready_check(NRF_NVMC_Type const * p_reg)
75  {
76      return (bool)(p_reg->READYNEXT & NVMC_READYNEXT_READYNEXT_Msk);
77  }
78  #endif
79  NRF_STATIC_INLINE void nrf_nvmc_mode_set(NRF_NVMC_Type * p_reg,
80                                           nrf_nvmc_mode_t mode)
81  {
82      p_reg->CONFIG = (uint32_t)mode;
83  }
84  #if defined(NVMC_CONFIGNS_WEN_Msk)
85  NRF_STATIC_INLINE void nrf_nvmc_nonsecure_mode_set(NRF_NVMC_Type *    p_reg,
86                                                     nrf_nvmc_ns_mode_t mode)
87  {
88      p_reg->CONFIGNS = (uint32_t)mode;
89  }
90  #endif
91  NRF_STATIC_INLINE void nrf_nvmc_page_erase_start(NRF_NVMC_Type * p_reg,
92                                                   uint32_t        page_addr)
93  {
94  #if defined(NRF51)
95      uint32_t cr0_len = NRF_UICR->CLENR0 == 0xFFFFFFFF ? 0 : NRF_UICR->CLENR0;
96      if (page_addr < cr0_len)
97      {
98          p_reg->ERASEPCR0 = page_addr;
99      }
100      else
101      {
102          p_reg->ERASEPCR1 = page_addr;
103      }
104  #elif defined(NRF52_SERIES)
105      p_reg->ERASEPAGE = page_addr;
106  #elif defined(NRF9160_XXAA) || defined(NRF5340_XXAA_APPLICATION) || defined(NRF5340_XXAA_NETWORK)
107      *(volatile uint32_t *)page_addr = 0xFFFFFFFF;
108      (void)p_reg;
109  #else
110      #error "Unknown device."
111  #endif
112  }
113  #if defined(NVMC_ERASEUICR_ERASEUICR_Msk)
114  NRF_STATIC_INLINE void nrf_nvmc_uicr_erase_start(NRF_NVMC_Type * p_reg)
115  {
116      p_reg->ERASEUICR = 1;
117  }
118  #endif
119  NRF_STATIC_INLINE void nrf_nvmc_erase_all_start(NRF_NVMC_Type * p_reg)
120  {
121      p_reg->ERASEALL = 1;
122  }
123  #if defined(NRF_NVMC_PARTIAL_ERASE_PRESENT)
124  NRF_STATIC_INLINE void nrf_nvmc_partial_erase_duration_set(NRF_NVMC_Type * p_reg,
125                                                             uint32_t        duration_ms)
126  {
127      p_reg->ERASEPAGEPARTIALCFG = duration_ms;
128  }
129  NRF_STATIC_INLINE uint32_t nrf_nvmc_partial_erase_duration_get(NRF_NVMC_Type const * p_reg)
130  {
131      return p_reg->ERASEPAGEPARTIALCFG;
132  }
133  NRF_STATIC_INLINE void nrf_nvmc_page_partial_erase_start(NRF_NVMC_Type * p_reg,
134                                                           uint32_t        page_addr)
135  {
136  #if defined(NVMC_ERASEPAGEPARTIAL_ERASEPAGEPARTIAL_Msk)
137      p_reg->ERASEPAGEPARTIAL = page_addr;
138  #elif defined(NRF9160_XXAA) || defined(NRF5340_XXAA_APPLICATION) || defined(NRF5340_XXAA_NETWORK)
139      nrf_nvmc_page_erase_start(p_reg, page_addr);
140  #else
141      #error "Unknown device."
142  #endif
143  }
144  #endif 
145  #if defined(NVMC_FEATURE_CACHE_PRESENT)
146  NRF_STATIC_INLINE void nrf_nvmc_icache_config_set(NRF_NVMC_Type *          p_reg,
147                                                    nrf_nvmc_icache_config_t config)
148  {
149  #if defined(NRF5340_XXAA_NETWORK) || defined(NRF9160_XXAA)
150      if (config == NRF_NVMC_ICACHE_DISABLE)
151      {
152          NRFX_CRITICAL_SECTION_ENTER();
153          __ISB();
154          p_reg->ICACHECNF = (uint32_t)NRF_NVMC_ICACHE_DISABLE;
155          __ISB();
156          NRFX_CRITICAL_SECTION_EXIT();
157      }
158      else
159  #endif
160      {
161          p_reg->ICACHECNF = (uint32_t)config;
162      }
163  }
164  NRF_STATIC_INLINE bool nrf_nvmc_icache_enable_check(NRF_NVMC_Type const * p_reg)
165  {
166      return (bool)(p_reg->ICACHECNF & NVMC_ICACHECNF_CACHEEN_Msk);
167  }
168  NRF_STATIC_INLINE bool nrf_nvmc_icache_profiling_enable_check(NRF_NVMC_Type const * p_reg)
169  {
170      return (bool)(p_reg->ICACHECNF & NVMC_ICACHECNF_CACHEPROFEN_Msk);
171  }
172  NRF_STATIC_INLINE uint32_t nrf_nvmc_icache_hit_get(NRF_NVMC_Type const * p_reg)
173  {
174      return p_reg->IHIT;
175  }
176  NRF_STATIC_INLINE uint32_t nrf_nvmc_icache_miss_get(NRF_NVMC_Type const * p_reg)
177  {
178      return p_reg->IMISS;
179  }
180  NRF_STATIC_INLINE void nrf_nvmc_icache_hit_miss_reset(NRF_NVMC_Type * p_reg)
181  {
182      p_reg->IHIT = 0;
183      p_reg->IMISS = 0;
184  }
185  #endif 
186  #endif 
187  #ifdef __cplusplus
188  }
189  #endif
190  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_twi.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_nvmc.h</div>
                </div>
                <div class="column column_space"><pre><code>26      NRF_TWI_SHORT_BB_SUSPEND_MASK = TWI_SHORTS_BB_SUSPEND_Msk,  
27      NRF_TWI_SHORT_BB_STOP_MASK    = TWI_SHORTS_BB_STOP_Msk,     
28      NRF_TWI_ALL_SHORTS_MASK       = TWI_SHORTS_BB_SUSPEND_Msk |
29                                      TWI_SHORTS_BB_STOP_Msk      
30  } nrf_twi_short_mask_t;
31  typedef enum
</pre></code></div>
                <div class="column column_space"><pre><code>30      NRF_NVMC_ICACHE_DISABLE               = NVMC_ICACHECNF_CACHEEN_Disabled, 
31      NRF_NVMC_ICACHE_ENABLE                = NVMC_ICACHECNF_CACHEEN_Enabled,  
32      NRF_NVMC_ICACHE_ENABLE_WITH_PROFILING = NVMC_ICACHECNF_CACHEEN_Enabled | 
33                                              NVMC_ICACHECNF_CACHEPROFEN_Msk
34  } nrf_nvmc_icache_config_t;
35  #endif 
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    