<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for omclickhouse.c & imhttp.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for omclickhouse.c & imhttp.c
      </h3>
      <h1 align="center">
        9.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>omclickhouse.c (12.328767%)<TH>imhttp.c (7.1770334%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1120-0.html#0',2,'match1120-1.html#0',3)" NAME="0">(132-149)<TD><A HREF="javascript:ZweiFrames('match1120-0.html#0',2,'match1120-1.html#0',3)" NAME="0">(160-180)</A><TD ALIGN=center><FONT COLOR="#ff0000">30</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1120-0.html#1',2,'match1120-1.html#1',3)" NAME="1">(835-840)<TD><A HREF="javascript:ZweiFrames('match1120-0.html#1',2,'match1120-1.html#1',3)" NAME="1">(1007-1012)</A><TD ALIGN=center><FONT COLOR="#900000">17</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match1120-0.html#2',2,'match1120-1.html#2',3)" NAME="2">(821-834)<TD><A HREF="javascript:ZweiFrames('match1120-0.html#2',2,'match1120-1.html#2',3)" NAME="2">(993-1006)</A><TD ALIGN=center><FONT COLOR="#900000">17</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match1120-0.html#3',2,'match1120-1.html#3',3)" NAME="3">(154-164)<TD><A HREF="javascript:ZweiFrames('match1120-0.html#3',2,'match1120-1.html#3',3)" NAME="3">(220-226)</A><TD ALIGN=center><FONT COLOR="#770000">14</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match1120-0.html#4',2,'match1120-1.html#4',3)" NAME="4">(919-934)<TD><A HREF="javascript:ZweiFrames('match1120-0.html#4',2,'match1120-1.html#4',3)" NAME="4">(237-244)</A><TD ALIGN=center><FONT COLOR="#660000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>omclickhouse.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* omclickhouse.c
 * This is the https://clickhouse.yandex/ output module.
 *
 * Copyright 2018 Pascal Withopf and Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;memory.h&gt;
#include &lt;string.h&gt;
#include &lt;curl/curl.h&gt;
#include &lt;curl/easy.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#if defined(__FreeBSD__)
#include &lt;unistd.h&gt;
#endif
#include &lt;json.h&gt;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;template.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;statsobj.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;unicode-helper.h&quot;
#include &quot;obj-types.h&quot;
#include &quot;ratelimit.h&quot;
#include &quot;ruleset.h&quot;

#ifndef O_LARGEFILE
#  define O_LARGEFILE 0
#endif

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;omclickhouse&quot;)

/* internal structures */
DEF_OMOD_STATIC_DATA
DEFobjCurrIf(statsobj)
DEFobjCurrIf(prop)
DEFobjCurrIf(ruleset)

statsobj_t *indexStats;
STATSCOUNTER_DEF(indexSubmit, mutIndexSubmit)
STATSCOUNTER_DEF(indexHTTPFail, mutIndexHTTPFail)
STATSCOUNTER_DEF(indexHTTPReqFail, mutIndexHTTPReqFail)
STATSCOUNTER_DEF(indexFail, mutIndexFail)
STATSCOUNTER_DEF(indexSuccess, mutIndexSuccess)



typedef struct curl_slist HEADER;
typedef struct instanceConf_s {
	uchar *serverBaseUrl;
	int port;
	uchar *user;
	uchar *pwd;
	long healthCheckTimeout;
	long timeout;
	uchar *authBuf;
	uchar *tplName;
	sbool useHttps;
	sbool allowUnsignedCerts;
	sbool skipVerifyHost;
	int fdErrFile;
	uchar *errorFile;
	sbool bulkmode;
	size_t maxbytes;
	uchar *caCertFile;
	uchar *myCertFile;
	uchar *myPrivKeyFile;
	struct instanceConf_s *next;
} instanceData;

struct modConfData_s {
	rsconf_t *pConf;		/* our overall config object */
	instanceConf_t *root, *tail;
};
static modConfData_t *loadModConf = NULL;	/* modConf ptr to use for the current load process */

typedef struct wrkrInstanceData {
	PTR_ASSERT_DEF
	instanceData *pData;
	CURL	*curlPostHandle;	/* libcurl session handle for posting data to the server */
	HEADER	*curlHeader;	/* json POST request info */
	CURL	*curlCheckConnHandle;	/* libcurl session handle for checking the server connection */
	int replyLen;
	char *reply;
	uchar *restURL;
	struct {
		es_str_t *data;
		int nmemb;	/* number of messages in batch (for statistics counting) */
	} batch;
	sbool insertErrorSent;  /* needed for insert error message */
} wrkrInstanceData_t;

/* tables for interfacing with the v6 config system */
/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
	{ &quot;server&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;port&quot;, eCmdHdlrInt, 0 },
	{ &quot;user&quot;, eCmdHdlrGetWord, 0 },
<A NAME="0"></A>	{ &quot;pwd&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;healthchecktimeout&quot;, eCmdHdlrInt, 0 },
	{ &quot;timeout&quot;, eCmdHdlrInt, 0 },
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1120-1.html#0',3,'match1120-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	{ &quot;template&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;usehttps&quot;, eCmdHdlrBinary, 0 },
	{ &quot;allowunsignedcerts&quot;, eCmdHdlrBinary, 0 },
	{ &quot;skipverifyhost&quot;, eCmdHdlrBinary, 0 },
	{ &quot;errorfile&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;bulkmode&quot;, eCmdHdlrBinary, 0 },
	{ &quot;maxbytes&quot;, eCmdHdlrSize, 0 },
	{ &quot;tls.cacert&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.mycert&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.myprivkey&quot;, eCmdHdlrString, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};

static rsRetVal curlSetup(wrkrInstanceData_t *pWrkrData);</B></FONT>

<A NAME="3"></A>BEGINcreateInstance
CODESTARTcreateInstance
	pData-&gt;fdErrFile = -1;
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match1120-1.html#3',3,'match1120-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	pData-&gt;caCertFile = NULL;
	pData-&gt;myCertFile = NULL;
	pData-&gt;myPrivKeyFile = NULL;
ENDcreateInstance

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	pWrkrData-&gt;curlHeader = NULL;
	pWrkrData-&gt;curlPostHandle = NULL;
	pWrkrData-&gt;curlCheckConnHandle = NULL;
	pWrkrData-&gt;restURL = NULL;</B></FONT>
	if(pData-&gt;bulkmode) {
		if((pWrkrData-&gt;batch.data = es_newStr(1024)) == NULL) {
			LogError(0, RS_RET_OUT_OF_MEMORY,
				&quot;omclickhouse: error creating batch string &quot;
			        &quot;turned off bulk mode\n&quot;);
			pData-&gt;bulkmode = 0; /* at least it works */
		}
	}
	pWrkrData-&gt;insertErrorSent = 0;

	iRet = curlSetup(pWrkrData);
ENDcreateWrkrInstance

BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature

BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;serverBaseUrl);
	free(pData-&gt;user);
	free(pData-&gt;pwd);
	free(pData-&gt;authBuf);
	if(pData-&gt;fdErrFile != -1)
		close(pData-&gt;fdErrFile);
	free(pData-&gt;errorFile);
	free(pData-&gt;tplName);
	free(pData-&gt;caCertFile);
	free(pData-&gt;myCertFile);
	free(pData-&gt;myPrivKeyFile);
ENDfreeInstance

BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	if(pWrkrData-&gt;curlHeader != NULL) {
		curl_slist_free_all(pWrkrData-&gt;curlHeader);
		pWrkrData-&gt;curlHeader = NULL;
	}
	if(pWrkrData-&gt;curlCheckConnHandle != NULL) {
		curl_easy_cleanup(pWrkrData-&gt;curlCheckConnHandle);
		pWrkrData-&gt;curlCheckConnHandle = NULL;
	}
	if(pWrkrData-&gt;curlPostHandle != NULL) {
		curl_easy_cleanup(pWrkrData-&gt;curlPostHandle);
		pWrkrData-&gt;curlPostHandle = NULL;
	}
	if (pWrkrData-&gt;restURL != NULL) {
		free(pWrkrData-&gt;restURL);
		pWrkrData-&gt;restURL = NULL;
	}
	es_deleteStr(pWrkrData-&gt;batch.data);
ENDfreeWrkrInstance

BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	dbgprintf(&quot;omclickhouse\n&quot;);
	dbgprintf(&quot;\tserver='%s'\n&quot;, pData-&gt;serverBaseUrl);
	dbgprintf(&quot;\tport='%d'\n&quot;, pData-&gt;port);
	dbgprintf(&quot;\tuser='%s'\n&quot;, pData-&gt;user);
	dbgprintf(&quot;\tpwd='%s'\n&quot;, pData-&gt;pwd);
	dbgprintf(&quot;\thealthCheckTimeout=%lu\n&quot;, pData-&gt;healthCheckTimeout);
	dbgprintf(&quot;\ttimeout=%lu\n&quot;, pData-&gt;timeout);
	dbgprintf(&quot;\ttemplate='%s'\n&quot;, pData-&gt;tplName);
	dbgprintf(&quot;\tusehttps='%d'\n&quot;, pData-&gt;useHttps);
	dbgprintf(&quot;\tallowunsignedcerts='%d'\n&quot;, pData-&gt;allowUnsignedCerts);
	dbgprintf(&quot;\tskipverifyhost='%d'\n&quot;, pData-&gt;skipVerifyHost);
	dbgprintf(&quot;\terrorFile='%s'\n&quot;, pData-&gt;errorFile);
	dbgprintf(&quot;\tbulkmode='%d'\n&quot;, pData-&gt;bulkmode);
	dbgprintf(&quot;\tmaxbytes='%zu'\n&quot;, pData-&gt;maxbytes);
	dbgprintf(&quot;\ttls.cacert='%s'\n&quot;, pData-&gt;caCertFile);
	dbgprintf(&quot;\ttls.mycert='%s'\n&quot;, pData-&gt;myCertFile);
	dbgprintf(&quot;\ttls.myprivkey='%s'\n&quot;, pData-&gt;myPrivKeyFile);
ENDdbgPrintInstInfo


/* checks if connection to clickhouse can be established
 */
static rsRetVal ATTR_NONNULL()
checkConn(wrkrInstanceData_t *const pWrkrData)
{
	CURL *curl;
	CURLcode res;
	char errbuf[CURL_ERROR_SIZE] = &quot;&quot;;
	const char* healthCheckMessage =&quot;SELECT 1&quot;;
	DEFiRet;

	pWrkrData-&gt;reply = NULL;
	pWrkrData-&gt;replyLen = 0;
	curl = pWrkrData-&gt;curlCheckConnHandle;
	

	curl_easy_setopt(curl, CURLOPT_URL, pWrkrData-&gt;restURL);
	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, healthCheckMessage);
	curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, strlen(healthCheckMessage));
	curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, errbuf);
	res = curl_easy_perform(curl);

	if (res == CURLE_OK) {
		DBGPRINTF(&quot;omclickhouse: checkConn completed with success\n&quot;);
		ABORT_FINALIZE(RS_RET_OK);
	}

	DBGPRINTF(&quot;omclickhouse: checkConn failed: %s\n&quot;,
		curl_easy_strerror(res));

	LogMsg(0, RS_RET_SUSPENDED, LOG_WARNING,
		&quot;omclickhouse: checkConn failed.&quot;);
	ABORT_FINALIZE(RS_RET_SUSPENDED);

finalize_it:
	free(pWrkrData-&gt;reply);
	pWrkrData-&gt;reply = NULL; /* don't leave dangling pointer */
	RETiRet;
}


BEGINtryResume
CODESTARTtryResume
	dbgprintf(&quot;omclickhouse: tryResume called\n&quot;);
	iRet = checkConn(pWrkrData);
ENDtryResume


/*
 * Dumps entire bulk request and response in error log
 */
static rsRetVal
getDataErrorDefault(wrkrInstanceData_t *pWrkrData, char *reply, uchar *reqmsg, char **rendered)
{
	DEFiRet;
	fjson_object *req=NULL;
	fjson_object *errRoot=NULL;

	if((req=fjson_object_new_object()) == NULL) ABORT_FINALIZE(RS_RET_ERR);
	fjson_object_object_add(req, &quot;url&quot;, fjson_object_new_string((char*)pWrkrData-&gt;restURL));
	fjson_object_object_add(req, &quot;postdata&quot;, fjson_object_new_string((char*)reqmsg));

	if((errRoot=fjson_object_new_object()) == NULL) ABORT_FINALIZE(RS_RET_ERR);
	fjson_object_object_add(errRoot, &quot;request&quot;, req);
	fjson_object_object_add(errRoot, &quot;reply&quot;, fjson_object_new_string(reply));
	*rendered = strdup((char*)fjson_object_to_json_string(errRoot));

	req=NULL;
	fjson_object_put(errRoot);

	finalize_it:
		fjson_object_put(req);
		RETiRet;
}


/* write data error request/replies to separate error file
 * Note: we open the file but never close it before exit. If it
 * needs to be closed, HUP must be sent.
 */
static rsRetVal ATTR_NONNULL()
writeDataError(wrkrInstanceData_t *const pWrkrData, uchar *const reqmsg)
{
	DEFiRet;
	instanceData *pData = pWrkrData-&gt;pData;
	char *rendered = pWrkrData-&gt;reply;
	size_t toWrite;
	ssize_t wrRet;

	if(pData-&gt;errorFile == NULL) {
		dbgprintf(&quot;omclickhouse: no local error logger defined - &quot;
		          &quot;ignoring ClickHouse error information\n&quot;);
		FINALIZE;
	}


	if(pData-&gt;fdErrFile == -1) {
		pData-&gt;fdErrFile = open((char*)pData-&gt;errorFile,
					O_WRONLY|O_CREAT|O_APPEND|O_LARGEFILE|O_CLOEXEC,
					S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP);
		if(pData-&gt;fdErrFile == -1) {
			LogError(errno, RS_RET_ERR, &quot;omclickhouse: error opening error file %s&quot;,
				pData-&gt;errorFile);
			ABORT_FINALIZE(RS_RET_ERR);
		}
	}

	if(getDataErrorDefault(pWrkrData, pWrkrData-&gt;reply, reqmsg, &amp;rendered) != RS_RET_OK) {
		ABORT_FINALIZE(RS_RET_ERR);
	}

	/* we do not do real error-handling on the err file, as this finally complicates
	 * things way to much.
	 */
	dbgprintf(&quot;omclickhouse: message sent: '%s'\n&quot;, reqmsg);
	dbgprintf(&quot;omclickhouse: error record: '%s'\n&quot;, rendered);
	toWrite = strlen(rendered) + 1;
	/* Note: we overwrite the '\0' terminator with '\n' -- so we avoid
	 * caling malloc() -- write() does NOT need '\0'!
	 */
	rendered[toWrite-1] = '\n'; /* NO LONGER A STRING! */
	wrRet = write(pData-&gt;fdErrFile, rendered, toWrite);
	if(wrRet != (ssize_t) toWrite) {
		LogError(errno, RS_RET_IO_ERROR,
			&quot;omclickhouse: error writing error file %s, write returned %lld&quot;,
			pData-&gt;errorFile, (long long) wrRet);
	}

finalize_it:
	RETiRet;
}


static rsRetVal
checkResult(wrkrInstanceData_t *pWrkrData, uchar *reqmsg)
{
	DEFiRet;

	if(strstr(pWrkrData-&gt;reply, &quot; = DB::Exception&quot;) != NULL) {
		dbgprintf(&quot;omclickhouse: action failed with error: %s\n&quot;, pWrkrData-&gt;reply);
		iRet = RS_RET_DATAFAIL;
	}

	if(iRet == RS_RET_DATAFAIL) {
		STATSCOUNTER_INC(indexFail, mutIndexFail);
		writeDataError(pWrkrData, reqmsg);
		iRet = RS_RET_OK; /* we have handled the problem! */
	}


	if(iRet != RS_RET_OK) {
		STATSCOUNTER_INC(indexFail, mutIndexFail);
	}
	RETiRet;
}

static rsRetVal ATTR_NONNULL(1)
setPostURL(wrkrInstanceData_t *const pWrkrData)
{
	char* baseUrl;
	es_str_t *url;
	DEFiRet;
	instanceData *const pData = pWrkrData-&gt;pData;

	baseUrl = (char*)pData-&gt;serverBaseUrl;
	url = es_newStrFromCStr(baseUrl, strlen(baseUrl));
	if (url == NULL) {
		LogError(0, RS_RET_OUT_OF_MEMORY,
			&quot;omclickhouse: error allocating new estr for POST url.&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	if(pWrkrData-&gt;restURL != NULL)
		free(pWrkrData-&gt;restURL);

	pWrkrData-&gt;restURL = (uchar*)es_str2cstr(url, NULL);
	curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_URL, pWrkrData-&gt;restURL);
	dbgprintf(&quot;omclickhouse: using REST URL: '%s'\n&quot;, pWrkrData-&gt;restURL);

finalize_it:
	if (url != NULL)
		es_deleteStr(url);
	RETiRet;
}


/* this method computes the next data set to be added to the batch
 * returns the expected size of adding the next message into the
 * batched request to clickhouse
 */
static size_t
computeBulkMessage(const wrkrInstanceData_t *const pWrkrData,
	const uchar *const message, char **newMessage)
{
	size_t r = 0;
	char *v;
	if (pWrkrData-&gt;batch.nmemb != 0
	&amp;&amp; (v = strstr((const char *)message, &quot;VALUES&quot;)) != NULL
	&amp;&amp; (v = strchr(v, '(')) != NULL
	) {
		*newMessage = v;
		r = strlen(*newMessage);
	} else {
		*newMessage = (char*)message;
		r = strlen(*newMessage);
	}
	dbgprintf(&quot;omclickhouse: computeBulkMessage: new message part: %s\n&quot;, *newMessage);

	return r;
}


/* This method builds the batch, that will be submitted.
 */
static rsRetVal
buildBatch(wrkrInstanceData_t *pWrkrData, char *message)
{
	DEFiRet;
	int length = strlen(message);
	int r;

	r = es_addBuf(&amp;pWrkrData-&gt;batch.data, message, length);
	if(r != 0) {
		LogError(0, RS_RET_ERR, &quot;omclickhouse: growing batch failed with code %d&quot;, r);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	++pWrkrData-&gt;batch.nmemb;
	iRet = RS_RET_OK;

finalize_it:
	RETiRet;
}


static void ATTR_NONNULL()
initializeBatch(wrkrInstanceData_t *pWrkrData)
{
	es_emptyStr(pWrkrData-&gt;batch.data);
	pWrkrData-&gt;batch.nmemb = 0;
}


static rsRetVal ATTR_NONNULL(1, 2)
curlPost(wrkrInstanceData_t *pWrkrData, uchar *message, int msglen, const int nmsgs)
{
	CURLcode code;
	CURL *const curl = pWrkrData-&gt;curlPostHandle;
	char errbuf[CURL_ERROR_SIZE] = &quot;&quot;;
	DEFiRet;

	if(!strstr((char*)message, &quot;INSERT INTO&quot;) &amp;&amp; !pWrkrData-&gt;insertErrorSent) {
		indexHTTPFail += nmsgs;
		LogError(0, RS_RET_ERR, &quot;omclickhouse: Message is no Insert query: &quot;
				&quot;Message suspended: %s&quot;, (char*)message);
		pWrkrData-&gt;insertErrorSent = 1;
		ABORT_FINALIZE(RS_RET_ERR);
	}

	pWrkrData-&gt;reply = NULL;
	pWrkrData-&gt;replyLen = 0;

	CHKiRet(setPostURL(pWrkrData));

	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, (char *)message);
	curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, msglen);
	curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, errbuf);
	code = curl_easy_perform(curl);
	dbgprintf(&quot;curl returned %lld\n&quot;, (long long) code);
	if (code != CURLE_OK &amp;&amp; code != CURLE_HTTP_RETURNED_ERROR) {
		STATSCOUNTER_INC(indexHTTPReqFail, mutIndexHTTPReqFail);
		indexHTTPFail += nmsgs;
		LogError(0, RS_RET_SUSPENDED,
			&quot;omclickhouse: we are suspending ourselfs due &quot;
			&quot;to server failure %lld: %s&quot;, (long long) code, errbuf);
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}

	if(pWrkrData-&gt;reply == NULL) {
		dbgprintf(&quot;omclickhouse: pWrkrData reply==NULL, replyLen = '%d'\n&quot;,
			pWrkrData-&gt;replyLen);
		STATSCOUNTER_INC(indexSuccess, mutIndexSuccess);
	} else {
		dbgprintf(&quot;omclickhouse: pWrkrData replyLen = '%d'\n&quot;, pWrkrData-&gt;replyLen);
		if(pWrkrData-&gt;replyLen &gt; 0) {
			pWrkrData-&gt;reply[pWrkrData-&gt;replyLen] = '\0';
			/* Append 0 Byte if replyLen is above 0 - byte has been reserved in malloc */
		}
		dbgprintf(&quot;omclickhouse: pWrkrData reply: '%s'\n&quot;, pWrkrData-&gt;reply);
		CHKiRet(checkResult(pWrkrData, message));
	}

finalize_it:
	free(pWrkrData-&gt;reply);
	pWrkrData-&gt;reply = NULL; /* don't leave dangling pointer */
	RETiRet;
}


static rsRetVal
submitBatch(wrkrInstanceData_t *pWrkrData)
{
	char *cstr = NULL;
	DEFiRet;

	cstr = es_str2cstr(pWrkrData-&gt;batch.data, NULL);
	dbgprintf(&quot;omclickhouse: submitBatch, batch: '%s'\n&quot;, cstr);

	CHKiRet(curlPost(pWrkrData, (uchar*) cstr, strlen(cstr), pWrkrData-&gt;batch.nmemb));

finalize_it:
	free(cstr);
	RETiRet;
}


BEGINbeginTransaction
CODESTARTbeginTransaction
	if(!pWrkrData-&gt;pData-&gt;bulkmode) {
		FINALIZE;
	}

	initializeBatch(pWrkrData);
finalize_it:
ENDbeginTransaction


BEGINdoAction
	char *batchPart = NULL;
CODESTARTdoAction
	dbgprintf(&quot;CODESTARTdoAction: entered\n&quot;);
	STATSCOUNTER_INC(indexSubmit, mutIndexSubmit);

	if(pWrkrData-&gt;pData-&gt;bulkmode) {
		const size_t nBytes = computeBulkMessage(pWrkrData, ppString[0], &amp;batchPart);
		dbgprintf(&quot;pascal: doAction: message: %s\n&quot;, batchPart);

		/* If max bytes is set and this next message will put us over the limit,
		* submit the current buffer and reset */
		if(pWrkrData-&gt;pData-&gt;maxbytes &gt; 0
			&amp;&amp; es_strlen(pWrkrData-&gt;batch.data) + nBytes &gt; pWrkrData-&gt;pData-&gt;maxbytes) {

			dbgprintf(&quot;omclickhouse: maxbytes limit reached, submitting partial &quot;
				&quot;batch of %d elements.\n&quot;, pWrkrData-&gt;batch.nmemb);
			CHKiRet(submitBatch(pWrkrData));
			initializeBatch(pWrkrData);
			batchPart = (char*)ppString[0];
		}

		CHKiRet(buildBatch(pWrkrData, batchPart));

		iRet = pWrkrData-&gt;batch.nmemb == 1 ? RS_RET_PREVIOUS_COMMITTED : RS_RET_DEFER_COMMIT;
	} else {
		CHKiRet(curlPost(pWrkrData, ppString[0], strlen((char*)ppString[0]), 1));
	}
finalize_it:
ENDdoAction


BEGINendTransaction
CODESTARTendTransaction
/* End Transaction only if batch data is not empty */
	if (pWrkrData-&gt;batch.data != NULL &amp;&amp; pWrkrData-&gt;batch.nmemb &gt; 0) {
		CHKiRet(submitBatch(pWrkrData));
	} else {
		dbgprintf(&quot;omclickhouse: endTransaction, pWrkrData-&gt;batch.data is NULL, &quot;
			&quot;nothing to send. \n&quot;);
	}
finalize_it:
ENDendTransaction

static void ATTR_NONNULL()
setInstParamDefaults(instanceData *const pData)
{
	pData-&gt;serverBaseUrl = NULL;
	pData-&gt;port = 8123;
	pData-&gt;user = NULL;
	pData-&gt;pwd = NULL;
	pData-&gt;healthCheckTimeout = 3500;
	pData-&gt;timeout = 0;
	pData-&gt;authBuf = NULL;
	pData-&gt;tplName = NULL;
	pData-&gt;useHttps = 1;
	pData-&gt;allowUnsignedCerts = 1;
	pData-&gt;skipVerifyHost = 0;
	pData-&gt;errorFile = NULL;
	pData-&gt;bulkmode = 1;
	pData-&gt;maxbytes = 104857600; //100MB
	pData-&gt;caCertFile = NULL;
	pData-&gt;myCertFile = NULL;
	pData-&gt;myPrivKeyFile = NULL;
}

/* POST result string ... useful for debugging */
static size_t
curlResult(void *ptr, size_t size, size_t nmemb, void *userdata)
{
	char *p = (char *)ptr;
	wrkrInstanceData_t *pWrkrData = (wrkrInstanceData_t*) userdata;
	char *buf;
	size_t newlen;
	newlen = pWrkrData-&gt;replyLen + size*nmemb;
	if((buf = realloc(pWrkrData-&gt;reply, newlen + 1)) == NULL) {
		LogError(errno, RS_RET_ERR, &quot;omclickhouse: realloc failed in curlResult&quot;);
		return 0; /* abort due to failure */
	}
	memcpy(buf+pWrkrData-&gt;replyLen, p, size*nmemb);
	pWrkrData-&gt;replyLen = newlen;
	pWrkrData-&gt;reply = buf;
	return size*nmemb;
}

static void ATTR_NONNULL()
curlSetupCommon(wrkrInstanceData_t *const pWrkrData, CURL *const handle)
{
	curl_easy_setopt(handle, CURLOPT_HTTPHEADER, pWrkrData-&gt;curlHeader);
	curl_easy_setopt(handle, CURLOPT_NOSIGNAL, TRUE);
	curl_easy_setopt(handle, CURLOPT_WRITEFUNCTION, curlResult);
	curl_easy_setopt(handle, CURLOPT_WRITEDATA, pWrkrData);
	if(pWrkrData-&gt;pData-&gt;allowUnsignedCerts)
		curl_easy_setopt(handle, CURLOPT_SSL_VERIFYPEER, FALSE);
	if(pWrkrData-&gt;pData-&gt;skipVerifyHost)
		curl_easy_setopt(handle, CURLOPT_SSL_VERIFYHOST, FALSE);
	if(pWrkrData-&gt;pData-&gt;authBuf != NULL) {
		curl_easy_setopt(handle, CURLOPT_USERPWD, pWrkrData-&gt;pData-&gt;authBuf);
		curl_easy_setopt(handle, CURLOPT_PROXYAUTH, CURLAUTH_ANY);
	}

	if(pWrkrData-&gt;pData-&gt;caCertFile) {
		curl_easy_setopt(handle, CURLOPT_CAINFO, pWrkrData-&gt;pData-&gt;caCertFile);
	}
	if(pWrkrData-&gt;pData-&gt;myCertFile) {
		curl_easy_setopt(handle, CURLOPT_SSLCERT, pWrkrData-&gt;pData-&gt;myCertFile);
	}
	if(pWrkrData-&gt;pData-&gt;myPrivKeyFile) {
		curl_easy_setopt(handle, CURLOPT_SSLKEY, pWrkrData-&gt;pData-&gt;myPrivKeyFile);
	}
	/* uncomment for in-dept debuggung:
	curl_easy_setopt(handle, CURLOPT_VERBOSE, TRUE); */
}


static void ATTR_NONNULL()
curlCheckConnSetup(wrkrInstanceData_t *const pWrkrData)
{
	curlSetupCommon(pWrkrData, pWrkrData-&gt;curlCheckConnHandle);
	curl_easy_setopt(pWrkrData-&gt;curlCheckConnHandle,
		CURLOPT_TIMEOUT_MS, pWrkrData-&gt;pData-&gt;healthCheckTimeout);
}


static void ATTR_NONNULL(1)
curlPostSetup(wrkrInstanceData_t *const pWrkrData)
{
	curlSetupCommon(pWrkrData, pWrkrData-&gt;curlPostHandle);
	curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_POST, 1);
	if(pWrkrData-&gt;pData-&gt;timeout) {
		curl_easy_setopt(pWrkrData-&gt;curlPostHandle,
			CURLOPT_TIMEOUT_MS, pWrkrData-&gt;pData-&gt;timeout);
	}
}

#define CONTENT_JSON &quot;Content-Type: application/json; charset=utf-8&quot;

static rsRetVal ATTR_NONNULL()
curlSetup(wrkrInstanceData_t *const pWrkrData)
{
	DEFiRet;
	pWrkrData-&gt;curlHeader = curl_slist_append(NULL, CONTENT_JSON);
	CHKmalloc(pWrkrData-&gt;curlPostHandle = curl_easy_init());
	curlPostSetup(pWrkrData);

	CHKmalloc(pWrkrData-&gt;curlCheckConnHandle = curl_easy_init());
	curlCheckConnSetup(pWrkrData);

finalize_it:
	if(iRet != RS_RET_OK &amp;&amp; pWrkrData-&gt;curlPostHandle != NULL) {
		curl_easy_cleanup(pWrkrData-&gt;curlPostHandle);
		pWrkrData-&gt;curlPostHandle = NULL;
	}
	RETiRet;
}

static rsRetVal
computeAuthHeader(char* user, char* pwd, uchar** authBuf)
{
	DEFiRet;
	int r;

	es_str_t* auth = es_newStr(1024);
	if (auth == NULL) {
		LogError(0, RS_RET_OUT_OF_MEMORY,
			&quot;omclickhouse: failed to allocate es_str auth for auth header construction&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	r = es_addBuf(&amp;auth, user, strlen(user));
	if(r == 0)
		r = es_addChar(&amp;auth, ':');
	if(r == 0 &amp;&amp; pwd != NULL)
		r = es_addBuf(&amp;auth, pwd, strlen(pwd));
	if(r == 0)
		*authBuf = (uchar*) es_str2cstr(auth, NULL);

	if (r != 0 || *authBuf == NULL) {
		LogError(0, RS_RET_ERR, &quot;omclickhouse: failed to build auth header\n&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}

finalize_it:
	if (auth != NULL)
		es_deleteStr(auth);
	RETiRet;
}

/* Build basic URL part, which includes hostname, port, user, pwd as follows:
 * http://user:pwd@hostname:port/ based on a server param
 * Newly creates a cstr for this purpose.
 */
static rsRetVal
computeBaseUrl(const char* server, const int port, const sbool useHttps, instanceData *pData)
{
#	define SCHEME_HTTPS &quot;https://&quot;
#	define SCHEME_HTTP &quot;http://&quot;

	char portBuf[64];
	int r = 0;
	const char *host = server;
	DEFiRet;

	assert(server[strlen(server)-1] != '/');

	es_str_t *urlBuf = es_newStr(256);
	if (urlBuf == NULL) {
		LogError(0, RS_RET_OUT_OF_MEMORY,
		&quot;omclickhouse: failed to allocate es_str urlBuf in computeBaseUrl&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	/* Find where the hostname/ip of the server starts. If the scheme is not specified
	  in the uri, start the buffer with a scheme corresponding to the useHttps parameter.
	*/
	if(strcasestr(server, SCHEME_HTTP)) {
		host = server + strlen(SCHEME_HTTP);
	} else if(strcasestr(server, SCHEME_HTTPS)) {
		host = server + strlen(SCHEME_HTTPS);
	} else {
		r = useHttps ? es_addBuf(&amp;urlBuf, SCHEME_HTTPS, sizeof(SCHEME_HTTPS)-1) :
			es_addBuf(&amp;urlBuf, SCHEME_HTTP, sizeof(SCHEME_HTTP)-1);
	}
	if (r == 0)
		r = es_addBuf(&amp;urlBuf, (char *)server, strlen(server));
	if (r == 0 &amp;&amp; !strchr(host, ':')) {
		snprintf(portBuf, sizeof(portBuf), &quot;:%d&quot;, port);
		r = es_addBuf(&amp;urlBuf, portBuf, strlen(portBuf));
	}
	if (r == 0)
		r = es_addChar(&amp;urlBuf, '/');
	if (r == 0)
		pData-&gt;serverBaseUrl = (uchar*) es_str2cstr(urlBuf, NULL);

	if (r != 0 || pData-&gt;serverBaseUrl == NULL) {
		LogError(0, RS_RET_ERR, &quot;omclickhouse: error occurred computing baseUrl from &quot;
			&quot;server %s&quot;, server);
		ABORT_FINALIZE(RS_RET_ERR);
	}
finalize_it:
	if (urlBuf) {
		es_deleteStr(urlBuf);
	}
	RETiRet;
}

BEGINnewActInst
	struct cnfparamvals *pvals;
	uchar *server = NULL;
	int i;
<A NAME="2"></A>	FILE *fp;
	char errStr[1024];
CODESTARTnewActInst
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match1120-1.html#2',3,'match1120-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, &quot;server&quot;)) {
<A NAME="1"></A>			server = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;port&quot;)) {
			pData-&gt;port = (int) pvals[i].val.d.n;</B></FONT>
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1120-1.html#1',3,'match1120-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		} else if(!strcmp(actpblk.descr[i].name, &quot;user&quot;)) {
			pData-&gt;user = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;pwd&quot;)) {
			pData-&gt;pwd = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;healthchecktimeout&quot;)) {
			pData-&gt;healthCheckTimeout = (long) pvals[i].val.d.n;</B></FONT>
		} else if(!strcmp(actpblk.descr[i].name, &quot;timeout&quot;)) {
			pData-&gt;timeout = (long) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;template&quot;)) {
			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;usehttps&quot;)) {
			pData-&gt;useHttps = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;allowunsignedcerts&quot;)) {
			pData-&gt;allowUnsignedCerts = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;skipverifyhost&quot;)) {
			pData-&gt;skipVerifyHost = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;errorfile&quot;)) {
			pData-&gt;errorFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;bulkmode&quot;)) {
			pData-&gt;bulkmode = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;maxbytes&quot;)) {
			pData-&gt;maxbytes = (size_t) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;tls.cacert&quot;)) {
			pData-&gt;caCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;caCertFile, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				LogError(0, RS_RET_NO_FILE_ACCESS,
					&quot;error: omclickhouse: 'tls.cacert' file %s couldn't be accessed: %s\n&quot;,
						pData-&gt;caCertFile, errStr);
			} else {
				fclose(fp);
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;tls.mycert&quot;)) {
			pData-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;myCertFile, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				LogError(0, RS_RET_NO_FILE_ACCESS,
					&quot;error: omclickhouse: 'tls.mycert' file %s couldn't be accessed: %s\n&quot;,
						pData-&gt;myCertFile, errStr);
			} else {
				fclose(fp);
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;tls.myprivkey&quot;)) {
			pData-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;myPrivKeyFile, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				LogError(0, RS_RET_NO_FILE_ACCESS,
					&quot;error: omclickhouse: 'tls.myprivkey' file %s couldn't be accessed: %s\n&quot;,
						pData-&gt;myPrivKeyFile, errStr);
			} else {
				fclose(fp);
			}
		} else {
			LogError(0, RS_RET_INTERNAL_ERROR, &quot;omclickhouse: program error, &quot;
				&quot;non-handled param '%s'&quot;, actpblk.descr[i].name);
		}
	}


	if(pData-&gt;user == NULL &amp;&amp; pData-&gt;pwd != NULL) {
		LogMsg(0, RS_RET_OK, LOG_WARNING, &quot;omclickhouse: No user was specified &quot;
				&quot;but a password was given.&quot;);
	}

	if(pData-&gt;user != NULL)
		CHKiRet(computeAuthHeader((char*) pData-&gt;user, (char*) pData-&gt;pwd, &amp;pData-&gt;authBuf));

	CODE_STD_STRING_REQUESTnewActInst(1)
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)strdup((pData-&gt;tplName == NULL) ?
		&quot; StdClickHouseFmt&quot; : (char*)pData-&gt;tplName), OMSR_RQD_TPL_OPT_SQL));

	if(server != NULL) {
		CHKiRet(computeBaseUrl((const char*)server, pData-&gt;port, pData-&gt;useHttps, pData));
	} else {
		LogMsg(0, RS_RET_OK, LOG_WARNING,
			&quot;omclickhouse: No servers specified, using localhost&quot;);
		CHKiRet(computeBaseUrl(&quot;localhost&quot;, pData-&gt;port, pData-&gt;useHttps,
					pData));
<A NAME="4"></A>	}

	/* node created, let's add to list of instance configs for the module */
<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match1120-1.html#4',3,'match1120-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	if(loadModConf-&gt;tail == NULL) {
		loadModConf-&gt;tail = loadModConf-&gt;root = pData;
	} else {
		loadModConf-&gt;tail-&gt;next = pData;
		loadModConf-&gt;tail = pData;
	}

CODE_STD_FINALIZERnewActInst
	free(server);
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst


BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;</B></FONT>
	pModConf-&gt;pConf = pConf;
	pModConf-&gt;root = pModConf-&gt;tail = NULL;
ENDbeginCnfLoad


BEGINendCnfLoad
CODESTARTendCnfLoad
	loadModConf = NULL; /* done loading */
ENDendCnfLoad


BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf


BEGINactivateCnf
CODESTARTactivateCnf
ENDactivateCnf


BEGINfreeCnf
CODESTARTfreeCnf
ENDfreeCnf


BEGINdoHUP
CODESTARTdoHUP
	if(pData-&gt;fdErrFile != -1) {
		close(pData-&gt;fdErrFile);
		pData-&gt;fdErrFile = -1;
	}
ENDdoHUP


BEGINmodExit
CODESTARTmodExit
	curl_global_cleanup();
	statsobj.Destruct(&amp;indexStats);
	objRelease(statsobj, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
ENDmodExit

NO_LEGACY_CONF_parseSelectorAct

BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_doHUP
CODEqueryEtryPt_TXIF_OMOD_QUERIES /* we support the transactional interface! */
CODEqueryEtryPt_STD_CONF2_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(statsobj, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));

	if (curl_global_init(CURL_GLOBAL_ALL) != 0) {
		LogError(0, RS_RET_OBJ_CREATION_FAILED, &quot;CURL fail. -indexing disabled&quot;);
		ABORT_FINALIZE(RS_RET_OBJ_CREATION_FAILED);
	}

	/* support statistics gathering */
	CHKiRet(statsobj.Construct(&amp;indexStats));
	CHKiRet(statsobj.SetName(indexStats, (uchar *)&quot;omclickhouse&quot;));
	CHKiRet(statsobj.SetOrigin(indexStats, (uchar *)&quot;omclickhouse&quot;));
	STATSCOUNTER_INIT(indexSubmit, mutIndexSubmit);
	CHKiRet(statsobj.AddCounter(indexStats, (uchar *)&quot;submitted&quot;,
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;indexSubmit));
	STATSCOUNTER_INIT(indexHTTPFail, mutIndexHTTPFail);
	CHKiRet(statsobj.AddCounter(indexStats, (uchar *)&quot;failed.http&quot;,
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;indexHTTPFail));
	STATSCOUNTER_INIT(indexHTTPReqFail, mutIndexHTTPReqFail);
	CHKiRet(statsobj.AddCounter(indexStats, (uchar *)&quot;failed.httprequests&quot;,
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;indexHTTPReqFail));
	STATSCOUNTER_INIT(indexFail, mutIndexFail);
	CHKiRet(statsobj.AddCounter(indexStats, (uchar *)&quot;failed.clickhouse&quot;,
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;indexFail));
	STATSCOUNTER_INIT(indexSuccess, mutIndexSuccess);
	CHKiRet(statsobj.AddCounter(indexStats, (uchar *)&quot;response.success&quot;,
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;indexSuccess));
	CHKiRet(statsobj.ConstructFinalize(indexStats));

ENDmodInit

/* vi:set ai:
 */
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>imhttp.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* imhttp.c
 * This is an input module for receiving http input.
 *
 * This file is contribution of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include &quot;config.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;ctype.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &quot;rsyslog.h&quot;
#include &quot;cfsysline.h&quot;		/* access to config file objects */
#include &quot;module-template.h&quot;
#include &quot;ruleset.h&quot;
#include &quot;unicode-helper.h&quot;
#include &quot;rsyslog.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;statsobj.h&quot;
#include &quot;ratelimit.h&quot;
#include &quot;dirty.h&quot;

#include &quot;civetweb.h&quot;
#include &lt;apr_base64.h&gt;
#include &lt;apr_md5.h&gt;

MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;imhttp&quot;)

/* static data */
DEF_OMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(prop)
DEFobjCurrIf(ruleset)
DEFobjCurrIf(statsobj)

#define CIVETWEB_OPTION_NAME_PORTS         &quot;listening_ports&quot;
#define CIVETWEB_OPTION_NAME_DOCUMENT_ROOT &quot;document_root&quot;
#define MAX_READ_BUFFER_SIZE  16384
#define INIT_SCRATCH_BUF_SIZE 4096
/* General purpose buffer size. */
#define IMHTTP_MAX_BUF_LEN (8192)

struct option {
	const char *name;
	const char *val;
};

struct auth_s {
	char workbuf[IMHTTP_MAX_BUF_LEN];
	char* pworkbuf;
	size_t workbuf_len;
	char* pszUser;
	char* pszPasswd;
};

struct data_parse_s {
	sbool  content_compressed;
	sbool bzInitDone; /* did we do an init of zstrm already? */
	z_stream zstrm;	/* zip stream to use for tcp compression */
	// Currently only used for octet specific parsing
	enum {
		eAtStrtFram,
		eInOctetCnt,
		eInMsg,
	} inputState;
	size_t iOctetsRemain;	/* Number of Octets remaining in message */
	enum {
		TCP_FRAMING_OCTET_STUFFING,
		TCP_FRAMING_OCTET_COUNTING
	} framingMode;
};

struct modConfData_s {
	rsconf_t *pConf;  /* our overall config object */
	instanceConf_t *root, *tail;
	struct option ports;
	struct option docroot;
	struct option *options;
	int nOptions;
};

struct instanceConf_s {
	struct instanceConf_s *next;
	uchar *pszBindRuleset;    /* name of ruleset to bind to */
	uchar *pszEndpoint;       /* endpoint to configure */
	uchar *pszBasicAuthFile;       /* file containing basic auth users/pass */
	ruleset_t *pBindRuleset;  /* ruleset to bind listener to (use system default if unspecified) */
	ratelimit_t *ratelimiter;
	unsigned int ratelimitInterval;
	unsigned int ratelimitBurst;
	uchar *pszInputName;	  /* value for inputname property, NULL is OK and handled by core engine */
	prop_t *pInputName;
	sbool flowControl;
	sbool bDisableLFDelim;
	sbool bSuppOctetFram;
	sbool bAddMetadata;
};

struct conn_wrkr_s {
	struct data_parse_s parseState;
	uchar* pMsg;						/* msg scratch buffer */
	size_t iMsg;						/* index of next char to store in msg */
	uchar zipBuf[64*1024];
	multi_submit_t multiSub;
	smsg_t *pMsgs[CONF_NUM_MULTISUB];
	char *pReadBuf;
	size_t readBufSize;
	prop_t *propRemoteAddr;
	const struct mg_request_info *pri; /* do not free me - used to hold a reference only */
	char *pScratchBuf;
	size_t scratchBufSize;
};

static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current load process */
static prop_t *pInputName = NULL;

//static size_t s_iMaxLine = 16; /* get maximum size we currently support */
static size_t s_iMaxLine = 16384; /* get maximum size we currently support */

/* module-global parameters */
static struct cnfparamdescr modpdescr[] = {
	{ &quot;ports&quot;, eCmdHdlrString, 0 },
	{ &quot;documentroot&quot;, eCmdHdlrString, 0 },
	{ &quot;liboptions&quot;, eCmdHdlrArray, 0 },
};

static struct cnfparamblk modpblk = {
	CNFPARAMBLK_VERSION,
	sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	modpdescr
<A NAME="0"></A>};

static struct cnfparamdescr inppdescr[] = {
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1120-0.html#0',2,'match1120-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	{ &quot;endpoint&quot;, eCmdHdlrString, 0},
	{ &quot;basicauthfile&quot;, eCmdHdlrString, 0},
	{ &quot;ruleset&quot;, eCmdHdlrString, 0 },
	{ &quot;flowcontrol&quot;, eCmdHdlrBinary, 0 },
	{ &quot;disablelfdelimiter&quot;, eCmdHdlrBinary, 0 },
	{ &quot;supportoctetcountedframing&quot;, eCmdHdlrBinary, 0 },
	{ &quot;name&quot;, eCmdHdlrString, 0 },
	{ &quot;ratelimit.interval&quot;, eCmdHdlrInt, 0 },
	{ &quot;ratelimit.burst&quot;, eCmdHdlrInt, 0 },
	{ &quot;addmetadata&quot;, eCmdHdlrBinary, 0 }
};

#include &quot;im-helper.h&quot; /* must be included AFTER the type definitions! */

static struct cnfparamblk inppblk = {
	CNFPARAMBLK_VERSION,
	sizeof(inppdescr)/sizeof(struct cnfparamdescr),
	inppdescr
};

static struct {</B></FONT>
	statsobj_t *stats;
	STATSCOUNTER_DEF(ctrSubmitted, mutCtrSubmitted)
	STATSCOUNTER_DEF(ctrFailed, mutCtrFailed);
	STATSCOUNTER_DEF(ctrDiscarded, mutCtrDiscarded);
} statsCounter;

#include &quot;im-helper.h&quot; /* must be included AFTER the type definitions! */

#define min(a, b) \
	({ __typeof__ (a) _a = (a); \
	__typeof__ (b) _b = (b); \
	_a &lt; _b ? _a : _b; })

#define	EXIT_FAILURE	1
#define	EXIT_SUCCESS	0
#define EXIT_URI &quot;/exit&quot;
volatile int exitNow = 0;

struct mg_callbacks callbacks;

typedef struct httpserv_s {
	struct mg_context *ctx;
	struct mg_callbacks callbacks;
	const char **civetweb_options;
	size_t civetweb_options_count;
} httpserv_t;

static httpserv_t *s_httpserv;

/* FORWARD DECLARATIONS */
static rsRetVal processData(const instanceConf_t *const inst,
	struct conn_wrkr_s *connWrkr, const char* buf, size_t len);

static rsRetVal
createInstance(instanceConf_t **pinst)
{
<A NAME="3"></A>	instanceConf_t *inst;
	DEFiRet;
	CHKmalloc(inst = calloc(1, sizeof(instanceConf_t)));
<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1120-0.html#3',2,'match1120-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	inst-&gt;next = NULL;
	inst-&gt;pszBindRuleset = NULL;
	inst-&gt;pBindRuleset = NULL;
	inst-&gt;pszEndpoint = NULL;
	inst-&gt;pszBasicAuthFile = NULL;
	inst-&gt;ratelimiter = NULL;
	inst-&gt;pszInputName = NULL;</B></FONT>
	inst-&gt;pInputName = NULL;
	inst-&gt;ratelimitBurst = 10000; /* arbitrary high limit */
	inst-&gt;ratelimitInterval = 0; /* off */
	inst-&gt;flowControl = 1;
	inst-&gt;bDisableLFDelim = 0;
	inst-&gt;bSuppOctetFram = 0;
	inst-&gt;bAddMetadata = 0;
<A NAME="4"></A>	// construct statsobj

	/* node created, let's add to config */
<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1120-0.html#4',2,'match1120-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	if(loadModConf-&gt;tail == NULL) {
		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
	} else {
		loadModConf-&gt;tail-&gt;next = inst;
		loadModConf-&gt;tail = inst;
	}

	*pinst = inst;</B></FONT>
finalize_it:
	RETiRet;
}

static rsRetVal
processCivetwebOptions(char *const param,
	const char **const name,
	const char **const paramval)
{
	DEFiRet;
	char *val = strstr(param, &quot;=&quot;);
	if(val == NULL) {
		LogError(0, RS_RET_PARAM_ERROR, &quot;missing equal sign in &quot;
				&quot;parameter '%s'&quot;, param);
		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
	}
	*val = '\0'; /* terminates name */
	++val; /* now points to begin of value */
	CHKmalloc(*name = strdup(param));
	CHKmalloc(*paramval = strdup(val));

finalize_it:
	RETiRet;
}

static sbool valid_civetweb_option(const struct mg_option *valid_opts, const char* option)
{
	const struct mg_option *pvalid_opts = valid_opts;
	for (; pvalid_opts != NULL &amp;&amp; pvalid_opts-&gt;name != NULL; pvalid_opts++) {
		if (strcmp(pvalid_opts-&gt;name, option) == 0) {
			return TRUE;
		}
	}
	return FALSE;
}

#if 0
static int
log_message(__attribute__((unused)) const struct mg_connection *conn, const char *message)
{
	puts(message);
	return 1;
}
#endif
/*
	*   thread_type:
	*     0 indicates the master thread
	*     1 indicates a worker thread handling client connections
	*     2 indicates an internal helper thread (timer thread)
*/
static void*
init_thread(__attribute__((unused)) const struct mg_context *ctx, int thread_type)
{
	DEFiRet;
	struct conn_wrkr_s *data = NULL;
	if (thread_type == 1) {
		CHKmalloc(data = calloc(1, sizeof(struct conn_wrkr_s)));
		data-&gt;pMsg = NULL;
		data-&gt;iMsg = 0;
		data-&gt;parseState.bzInitDone = 0;
		data-&gt;parseState.content_compressed = 0;
		data-&gt;parseState.inputState = eAtStrtFram;
		data-&gt;parseState.iOctetsRemain = 0;
		data-&gt;multiSub.maxElem = CONF_NUM_MULTISUB;
		data-&gt;multiSub.ppMsgs = data-&gt;pMsgs;
		data-&gt;multiSub.nElem = 0;
		data-&gt;pReadBuf = malloc(MAX_READ_BUFFER_SIZE);
		data-&gt;readBufSize = MAX_READ_BUFFER_SIZE;

		data-&gt;parseState.bzInitDone = 0;
		data-&gt;parseState.content_compressed = 0;
		data-&gt;parseState.inputState = eAtStrtFram;
		data-&gt;parseState.iOctetsRemain = 0;

		CHKmalloc(data-&gt;pMsg = calloc(1, 1 + s_iMaxLine));
		data-&gt;iMsg = 0;
		data-&gt;propRemoteAddr = NULL;
		data-&gt;pScratchBuf = NULL;
		data-&gt;scratchBufSize = 0;
	}

finalize_it:
	if (iRet != RS_RET_OK) {
		free(data);
		return NULL;
	}
	return data;
}

static void
exit_thread(__attribute__((unused)) const struct mg_context *ctx,
	__attribute__((unused)) int thread_type, void *thread_pointer)
{
	if (thread_type == 1) {
		struct conn_wrkr_s *data = (struct conn_wrkr_s *) thread_pointer;
		if (data-&gt;propRemoteAddr) {
			prop.Destruct(&amp;data-&gt;propRemoteAddr);
		}
		if (data-&gt;scratchBufSize) {
			free(data-&gt;pScratchBuf);
		}
		free(data-&gt;pReadBuf);
		free(data-&gt;pMsg);
		free(data);
	}
}

static rsRetVal
msgAddMetadataFromHttpHeader(smsg_t *const __restrict__ pMsg, struct conn_wrkr_s *connWrkr)
{
	struct json_object *json = NULL;
	DEFiRet;
	const struct mg_request_info *ri = connWrkr-&gt;pri;
	#define MAX_HTTP_HEADERS 64	/* hard limit */
	int count = min(ri-&gt;num_headers, MAX_HTTP_HEADERS);

	CHKmalloc(json = json_object_new_object());
	for (int i = 0 ; i &lt; count ; i++ ) {
		struct json_object *const jval = json_object_new_string(ri-&gt;http_headers[i].value);
		CHKmalloc(jval);
		/* truncate header names bigger than INIT_SCRATCH_BUF_SIZE */
		strncpy(connWrkr-&gt;pScratchBuf, ri-&gt;http_headers[i].name, connWrkr-&gt;scratchBufSize - 1);
		/* make header lowercase */
		char* pname = connWrkr-&gt;pScratchBuf;
		while (pname &amp;&amp; *pname != '\0') {
			*pname = tolower(*pname);
			pname++;
		}
		json_object_object_add(json, (const char *const)connWrkr-&gt;pScratchBuf, jval);
	}
	CHKiRet(msgAddJSON(pMsg, (uchar*)&quot;!metadata!httpheaders&quot;, json, 0, 0));

finalize_it:
	if (iRet != RS_RET_OK &amp;&amp; json) {
		json_object_put(json);
	}
	RETiRet;
}

static rsRetVal
msgAddMetadataFromHttpQueryParams(smsg_t *const __restrict__ pMsg, struct conn_wrkr_s *connWrkr)
{
	struct json_object *json = NULL;
	DEFiRet;
	const struct mg_request_info *ri = connWrkr-&gt;pri;

	if (ri &amp;&amp; ri-&gt;query_string) {
		strncpy(connWrkr-&gt;pScratchBuf, ri-&gt;query_string, connWrkr-&gt;scratchBufSize - 1);
		char *pquery_str = connWrkr-&gt;pScratchBuf;
		if (pquery_str) {
			CHKmalloc(json = json_object_new_object());

			char* saveptr = NULL;
			char *kv_pair = strtok_r(pquery_str, &quot;&amp;;&quot;, &amp;saveptr);

			for ( ; kv_pair != NULL; kv_pair = strtok_r(NULL, &quot;&amp;;&quot;, &amp;saveptr)) {
				char *saveptr2 = NULL;
				char *key = strtok_r(kv_pair, &quot;=&quot;, &amp;saveptr2);
				if (key) {
					char *value = strtok_r(NULL, &quot;=&quot;, &amp;saveptr2);
					struct json_object *const jval = json_object_new_string(value);
					CHKmalloc(jval);
					json_object_object_add(json, (const char *)key, jval);
				}
			}
			CHKiRet(msgAddJSON(pMsg, (uchar*)&quot;!metadata!queryparams&quot;, json, 0, 0));
		}
	}
finalize_it:
	if (iRet != RS_RET_OK &amp;&amp; json) {
		json_object_put(json);
	}
	RETiRet;
}

static rsRetVal
doSubmitMsg(const instanceConf_t *const __restrict__ inst,
	struct conn_wrkr_s *connWrkr, const uchar* msg, size_t len)
{
	smsg_t *pMsg;
	DEFiRet;

	assert(len &lt;= s_iMaxLine);
	if (len == 0) {
		DBGPRINTF(&quot;discarding zero-sized message\n&quot;);
		FINALIZE;
	}

	CHKiRet(msgConstruct(&amp;pMsg));
	MsgSetFlowControlType(pMsg, inst-&gt;flowControl
			            ? eFLOWCTL_LIGHT_DELAY : eFLOWCTL_NO_DELAY);
	if (inst-&gt;pInputName) {
		MsgSetInputName(pMsg, inst-&gt;pInputName);
	} else {
		MsgSetInputName(pMsg, pInputName);
	}
	MsgSetRawMsg(pMsg, (const char*)msg, len);
	MsgSetMSGoffs(pMsg, 0);	/* we do not have a header... */
	if (connWrkr-&gt;propRemoteAddr) {
		MsgSetRcvFromIP(pMsg, connWrkr-&gt;propRemoteAddr);
	}
	if (inst) {
		MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
	}
	// TODO: make these flags configurable.
	pMsg-&gt;msgFlags = NEEDS_PARSING | PARSE_HOSTNAME;

	if (inst-&gt;bAddMetadata) {
		CHKiRet(msgAddMetadataFromHttpHeader(pMsg, connWrkr));
		CHKiRet(msgAddMetadataFromHttpQueryParams(pMsg, connWrkr));
	}

	ratelimitAddMsg(inst-&gt;ratelimiter, &amp;connWrkr-&gt;multiSub, pMsg);
	STATSCOUNTER_INC(statsCounter.ctrSubmitted, statsCounter.mutCtrSubmitted);
finalize_it:
	connWrkr-&gt;iMsg = 0;
	if (iRet != RS_RET_OK) {
		STATSCOUNTER_INC(statsCounter.ctrDiscarded, statsCounter.mutCtrDiscarded);
	}
	RETiRet;
}


static rsRetVal
processOctetMsgLen(const instanceConf_t *const inst, struct conn_wrkr_s *connWrkr, char ch)
{
	DEFiRet;
	if (connWrkr-&gt;parseState.inputState == eAtStrtFram) {
		if (inst-&gt;bSuppOctetFram &amp;&amp; isdigit(ch)) {
			connWrkr-&gt;parseState.inputState = eInOctetCnt;
			connWrkr-&gt;parseState.iOctetsRemain = 0;
			connWrkr-&gt;parseState.framingMode = TCP_FRAMING_OCTET_COUNTING;
		} else {
			connWrkr-&gt;parseState.inputState = eInMsg;
			connWrkr-&gt;parseState.framingMode = TCP_FRAMING_OCTET_STUFFING;
		}
	}

	// parsing character.
	if (connWrkr-&gt;parseState.inputState == eInOctetCnt) {
		if (isdigit(ch)) {
			if (connWrkr-&gt;parseState.iOctetsRemain &lt;= 200000000) {
				connWrkr-&gt;parseState.iOctetsRemain = connWrkr-&gt;parseState.iOctetsRemain * 10 + ch - '0';
			}
			// temporarily save this character into the message buffer
			if(connWrkr-&gt;iMsg + 1 &lt; s_iMaxLine) {
				connWrkr-&gt;pMsg[connWrkr-&gt;iMsg++] = ch;
			}
		} else {
			const char *remoteAddr = &quot;&quot;;
			if (connWrkr-&gt;propRemoteAddr) {
				remoteAddr = (const char *)propGetSzStr(connWrkr-&gt;propRemoteAddr);
			}

			/* handle space delimeter */
			if (ch != ' ') {
				LogError(0, NO_ERRCODE, &quot;Framing Error in received TCP message &quot;
					&quot;from peer: (ip) %s: to input: %s, delimiter is not &quot;
					&quot;SP but has ASCII value %d.&quot;,
					remoteAddr, inst-&gt;pszInputName, ch);
			}

			if (connWrkr-&gt;parseState.iOctetsRemain &lt; 1) {
				LogError(0, NO_ERRCODE, &quot;Framing Error in received TCP message&quot;
					&quot; from peer: (ip) %s: delimiter is not &quot;
					&quot;SP but has ASCII value %d.&quot;,
					remoteAddr, ch);
			} else if (connWrkr-&gt;parseState.iOctetsRemain &gt; s_iMaxLine) {
				DBGPRINTF(&quot;truncating message with %lu octets - max msg size is %lu\n&quot;,
									connWrkr-&gt;parseState.iOctetsRemain, s_iMaxLine);
				LogError(0, NO_ERRCODE, &quot;received oversize message from peer: &quot;
					&quot;(hostname) (ip) %s: size is %lu bytes, max msg &quot;
					&quot;size is %lu, truncating...&quot;,
					remoteAddr, connWrkr-&gt;parseState.iOctetsRemain, s_iMaxLine);
			}
			connWrkr-&gt;parseState.inputState = eInMsg;
		}
		/* reset msg len for actual message processing */
		connWrkr-&gt;iMsg = 0;
		/* retrieve next character */
	}
	RETiRet;
}

static rsRetVal
processOctetCounting(const instanceConf_t *const inst,
	struct conn_wrkr_s *connWrkr, const char* buf, size_t len)
{
	DEFiRet;
	const uchar* pbuf = (const uchar*)buf;
	const uchar* pbufLast = pbuf + len;

	while (pbuf &lt; pbufLast) {
		char ch = *pbuf;

		if (connWrkr-&gt;parseState.inputState == eAtStrtFram || connWrkr-&gt;parseState.inputState == eInOctetCnt) {
			processOctetMsgLen(inst, connWrkr, ch);
			if (connWrkr-&gt;parseState.framingMode == TCP_FRAMING_OCTET_COUNTING) {
				pbuf++;
			}
		} else if (connWrkr-&gt;parseState.inputState == eInMsg) {
			if (connWrkr-&gt;parseState.framingMode == TCP_FRAMING_OCTET_STUFFING) {
				if (connWrkr-&gt;iMsg &lt; s_iMaxLine) {
					if (ch == '\n') {
						doSubmitMsg(inst, connWrkr, connWrkr-&gt;pMsg, connWrkr-&gt;iMsg);
						connWrkr-&gt;parseState.inputState = eAtStrtFram;
					} else {
						connWrkr-&gt;pMsg[connWrkr-&gt;iMsg++] = ch;
					}
				} else {
					doSubmitMsg(inst, connWrkr, connWrkr-&gt;pMsg, connWrkr-&gt;iMsg);
					connWrkr-&gt;parseState.inputState = eAtStrtFram;
				}
				pbuf++;
			} else {
				assert (connWrkr-&gt;parseState.framingMode == TCP_FRAMING_OCTET_COUNTING);
				/* parsing payload */
				size_t remainingBytes = pbufLast - pbuf;
				// figure out how much is in block
				size_t count = min (connWrkr-&gt;parseState.iOctetsRemain, remainingBytes);
				if (connWrkr-&gt;iMsg + count &gt;= s_iMaxLine) {
					count = s_iMaxLine - connWrkr-&gt;iMsg;
				}

				// just copy the bytes
				if (count) {
					memcpy(connWrkr-&gt;pMsg + connWrkr-&gt;iMsg, pbuf, count);
					pbuf += count;
					connWrkr-&gt;iMsg += count;
					connWrkr-&gt;parseState.iOctetsRemain -= count;
				}

				if (connWrkr-&gt;parseState.iOctetsRemain == 0) {
					doSubmitMsg(inst, connWrkr, connWrkr-&gt;pMsg, connWrkr-&gt;iMsg);
					connWrkr-&gt;parseState.inputState = eAtStrtFram;
				}
			}
		} else {
			// unexpected
			assert(0);
			break;
		}
	}
	RETiRet;
}

static rsRetVal
processDisableLF(const instanceConf_t *const inst,
	struct conn_wrkr_s *connWrkr, const char* buf, size_t len)
{
	DEFiRet;
	const uchar *pbuf = (const uchar*)buf;
	size_t remainingBytes = len;
	const uchar* pbufLast = pbuf + len;

	while (pbuf &lt; pbufLast) {
		size_t count = 0;
		if (connWrkr-&gt;iMsg + remainingBytes &gt;= s_iMaxLine) {
			count = s_iMaxLine - connWrkr-&gt;iMsg;
		} else {
			count = remainingBytes;
		}

		if (count) {
			memcpy(connWrkr-&gt;pMsg + connWrkr-&gt;iMsg, pbuf, count);
			pbuf += count;
			connWrkr-&gt;iMsg += count;
			remainingBytes -= count;
		}
		doSubmitMsg(inst, connWrkr, connWrkr-&gt;pMsg, connWrkr-&gt;iMsg);
	}
	RETiRet;
}

static rsRetVal
processDataUncompressed(const instanceConf_t *const inst,
	struct conn_wrkr_s *connWrkr, const char* buf, size_t len)
{
	const uchar *pbuf = (const uchar*)buf;
	DEFiRet;

	if (inst-&gt;bDisableLFDelim) {
		/* do block processing */
		iRet = processDisableLF(inst, connWrkr, buf, len);
	} else if (inst-&gt;bSuppOctetFram) {
		iRet = processOctetCounting(inst, connWrkr, buf, len);
	} else {
		const uchar* pbufLast = pbuf + len;
		while (pbuf &lt; pbufLast) {
			char ch = *pbuf;
			if (connWrkr-&gt;iMsg &lt; s_iMaxLine) {
				if (ch == '\n') {
					doSubmitMsg(inst, connWrkr, connWrkr-&gt;pMsg, connWrkr-&gt;iMsg);
				} else {
					connWrkr-&gt;pMsg[connWrkr-&gt;iMsg++] = ch;
				}
			} else {
				doSubmitMsg(inst, connWrkr, connWrkr-&gt;pMsg, connWrkr-&gt;iMsg);
			}
			pbuf++;
		}
	}
	RETiRet;
}

static rsRetVal
processDataCompressed(const instanceConf_t *const inst,
	struct conn_wrkr_s *connWrkr, const char* buf, size_t len)
{
	DEFiRet;

	if (!connWrkr-&gt;parseState.bzInitDone) {
		/* allocate deflate state */
		connWrkr-&gt;parseState.zstrm.zalloc = Z_NULL;
		connWrkr-&gt;parseState.zstrm.zfree = Z_NULL;
		connWrkr-&gt;parseState.zstrm.opaque = Z_NULL;
		int rc = inflateInit2(&amp;connWrkr-&gt;parseState.zstrm, (MAX_WBITS | 16));
		if (rc != Z_OK) {
			dbgprintf(&quot;imhttp: error %d returned from zlib/inflateInit()\n&quot;, rc);
			ABORT_FINALIZE(RS_RET_ZLIB_ERR);
		}
		connWrkr-&gt;parseState.bzInitDone = 1;
	}

	connWrkr-&gt;parseState.zstrm.next_in = (Bytef*) buf;
	connWrkr-&gt;parseState.zstrm.avail_in = len;
	/* run inflate() on buffer until everything has been uncompressed */
	int outtotal = 0;
	do {
		int zRet = 0;
		int outavail = 0;
		dbgprintf(&quot;imhttp: in inflate() loop, avail_in %d, total_in %ld\n&quot;,
				connWrkr-&gt;parseState.zstrm.avail_in, connWrkr-&gt;parseState.zstrm.total_in);

		connWrkr-&gt;parseState.zstrm.avail_out = sizeof(connWrkr-&gt;zipBuf);
		connWrkr-&gt;parseState.zstrm.next_out = connWrkr-&gt;zipBuf;
		zRet = inflate(&amp;connWrkr-&gt;parseState.zstrm, Z_SYNC_FLUSH);
		dbgprintf(&quot;imhttp: inflate(), ret: %d, avail_out: %d\n&quot;, zRet, connWrkr-&gt;parseState.zstrm.avail_out);
		outavail = sizeof(connWrkr-&gt;zipBuf) - connWrkr-&gt;parseState.zstrm.avail_out;
		if (outavail != 0) {
			outtotal += outavail;
			CHKiRet(processDataUncompressed(inst, connWrkr, (const char*)connWrkr-&gt;zipBuf, outavail));
		}
	} while (connWrkr-&gt;parseState.zstrm.avail_out == 0);

	dbgprintf(&quot;imhttp: processDataCompressed complete, sizes: in %lld, out %llu\n&quot;, (long long) len,
		(long long unsigned) outtotal);

finalize_it:
	RETiRet;
}

static rsRetVal
processData(const instanceConf_t *const inst,
	struct conn_wrkr_s *connWrkr, const char* buf, size_t len)
{
	DEFiRet;

	//inst-&gt;bDisableLFDelim = 0;
	if (connWrkr-&gt;parseState.content_compressed) {
		iRet = processDataCompressed(inst, connWrkr, buf, len);
	} else {
		iRet = processDataUncompressed(inst, connWrkr, buf, len);
	}

	RETiRet;
}

/* Return 1 on success. Always initializes the auth structure. */
static int
parse_auth_header(struct mg_connection *conn, struct auth_s *auth)
{
	if (!auth || !conn) {
		return 0;
	}

	const char *auth_header = NULL;
	if (((auth_header = mg_get_header(conn, &quot;Authorization&quot;)) == NULL) ||
			strncasecmp(auth_header, &quot;Basic &quot;, 6) != 0) {
		return 0;
	}

	/* Parse authorization header */
	const char* src = auth_header + 6;
	size_t len = apr_base64_decode_len((const char*)src);
	auth-&gt;pworkbuf = auth-&gt;workbuf;
	if (len &gt; sizeof(auth-&gt;workbuf)) {
		auth-&gt;pworkbuf = calloc(0, len);
		auth-&gt;workbuf_len = len;
	}
	len = apr_base64_decode(auth-&gt;pworkbuf, src);
	if (len == 0) {
		return 0;
	}

	char *passwd = NULL, *saveptr = NULL;
	char *user = strtok_r(auth-&gt;pworkbuf, &quot;:&quot;, &amp;saveptr);
	if (user) {
		passwd = strtok_r(NULL, &quot;:&quot;, &amp;saveptr);
	}

	auth-&gt;pszUser = user;
	auth-&gt;pszPasswd = passwd;

	return 1;
}

static int
read_auth_file(FILE* filep, struct auth_s *auth)
{
	if (!filep) {
		return 0;
	}
	char workbuf[IMHTTP_MAX_BUF_LEN];
	size_t l = 0;
	char* user;
	char* passwd;

	while (fgets(workbuf, sizeof(workbuf), filep)) {
		l = strnlen(workbuf, sizeof(workbuf));
		while (l &gt; 0) {
			if (isspace(workbuf[l-1]) || iscntrl(workbuf[l-1])) {
				l--;
				workbuf[l] = 0;
			} else {
				break;
			}
		}

		if (l &lt; 1) {
			continue;
		}

		if (workbuf[0] == '#') {
			continue;
		}

		user = workbuf;
		passwd = strchr(workbuf, ':');
		if (!passwd) {
			continue;
		}
		*passwd = '\0';
		passwd++;

		if (!strcasecmp(auth-&gt;pszUser, user)) {
			return (apr_password_validate(auth-&gt;pszPasswd, passwd) == APR_SUCCESS);
		}
	}
	return 0;
}

/* Authorize against the opened passwords file. Return 1 if authorized. */
static int
authorize(struct mg_connection* conn, FILE* filep)
{
	if (!conn || !filep) {
		return 0;
	}

	struct auth_s auth = { .workbuf_len=0, .pworkbuf=NULL, .pszUser=NULL, .pszPasswd=NULL};
	if (!parse_auth_header(conn, &amp;auth)) {
		return 0;
	}

	/* validate against htpasswd file */
	return read_auth_file(filep, &amp;auth);
}

/* Provides Basic Authorization handling that validates against a 'htpasswd' file.
	see also: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization
*/
static int
basicAuthHandler(struct mg_connection *conn, void *cbdata)
{
	const instanceConf_t* inst = (const instanceConf_t*) cbdata;
	char errStr[512];
	FILE *fp = NULL;
	int ret = 1;

	if (!inst-&gt;pszBasicAuthFile) {
		mg_cry(conn, &quot;warning: 'BasicAuthFile' not configured.\n&quot;);
		ret = 0;
		goto finalize;
	}

	fp = fopen((const char *)inst-&gt;pszBasicAuthFile, &quot;r&quot;);
	if (fp == NULL) {
		if (strerror_r(errno, errStr, sizeof(errStr)) == 0) {
			mg_cry(conn,
					&quot;error: 'BasicAuthFile' file '%s' could not be accessed: %s\n&quot;,
					inst-&gt;pszBasicAuthFile, errStr);
		} else {
			mg_cry(conn,
					&quot;error: 'BasicAuthFile' file '%s' could not be accessed: %d\n&quot;,
					inst-&gt;pszBasicAuthFile, errno);
		}
		ret = 0;
		goto finalize;
	}

	ret = authorize(conn, fp);

finalize:
	if (!ret) {
		mg_send_http_error(conn, 401, &quot;WWW-Authenticate: Basic realm=\&quot;User Visible Realm\&quot;\n&quot;);
	}
	if (fp ) {
		fclose(fp);
	}
	return ret;
}

/* cbdata should actually contain instance data and we can actually use this instance data
 * to hold reusable scratch buffer.
 */
static int
postHandler(struct mg_connection *conn, void *cbdata)
{
	int rc = 1;
	instanceConf_t* inst = (instanceConf_t*) cbdata;
	const struct mg_request_info *ri = mg_get_request_info(conn);
	struct conn_wrkr_s *connWrkr = mg_get_thread_pointer(conn);
	connWrkr-&gt;multiSub.nElem = 0;
	memset(&amp;connWrkr-&gt;parseState, 0, sizeof(connWrkr-&gt;parseState));
	connWrkr-&gt;pri = ri;

	if (inst-&gt;bAddMetadata &amp;&amp; connWrkr-&gt;scratchBufSize == 0) {
		connWrkr-&gt;pScratchBuf = calloc(1, INIT_SCRATCH_BUF_SIZE);
		if (!connWrkr-&gt;pScratchBuf) {
			mg_cry(conn, &quot;%s() - could not alloc scratch buffer!\n&quot;, __FUNCTION__);
			rc = 500;
			FINALIZE;
		}
		connWrkr-&gt;scratchBufSize = INIT_SCRATCH_BUF_SIZE;
	}

	if (0 != strcmp(ri-&gt;request_method, &quot;POST&quot;)) {
		/* Not a POST request */
		int ret = mg_get_request_link(conn, connWrkr-&gt;pReadBuf, connWrkr-&gt;readBufSize);
		mg_printf(conn,
		          &quot;HTTP/1.1 405 Method Not Allowed\r\nConnection: close\r\n&quot;);
		mg_printf(conn, &quot;Content-Type: text/plain\r\n\r\n&quot;);
		mg_printf(conn,
		          &quot;%s method not allowed in the POST handler\n&quot;,
		          ri-&gt;request_method);
		if (ret &gt;= 0) {
			mg_printf(conn,
			          &quot;use a web tool to send a POST request to %s\n&quot;,
			          connWrkr-&gt;pReadBuf);
		}
		STATSCOUNTER_INC(statsCounter.ctrFailed, statsCounter.mutCtrFailed);
		rc = 405;
		FINALIZE;
	}

	if (ri-&gt;remote_addr[0] != '\0') {
		size_t len = strnlen(ri-&gt;remote_addr, sizeof(ri-&gt;remote_addr));
		prop.CreateOrReuseStringProp(&amp;connWrkr-&gt;propRemoteAddr, (const uchar*)ri-&gt;remote_addr, len);
	}

	if (ri-&gt;content_length &gt;= 0) {
		/* We know the content length in advance */
		if (ri-&gt;content_length &gt; (long long) connWrkr-&gt;readBufSize) {
			connWrkr-&gt;pReadBuf = realloc(connWrkr-&gt;pReadBuf, ri-&gt;content_length+1);
			if (!connWrkr-&gt;pReadBuf) {
				mg_cry(conn, &quot;%s() - realloc failed!\n&quot;, __FUNCTION__);
				FINALIZE;
			}
			connWrkr-&gt;readBufSize = ri-&gt;content_length+1;
		}
	} else {
		/* We must read until we find the end (chunked encoding
		 * or connection close), indicated my mg_read returning 0 */
	}

	if (ri-&gt;num_headers &gt; 0) {
		int i;
		for (i = 0; i &lt; ri-&gt;num_headers; i++) {
			if (!strcasecmp(ri-&gt;http_headers[i].name, &quot;content-encoding&quot;) &amp;&amp;
					!strcasecmp(ri-&gt;http_headers[i].value, &quot;gzip&quot;)) {
				connWrkr-&gt;parseState.content_compressed = 1;
			}
		}
	}

	while (1) {
		int count = mg_read(conn, connWrkr-&gt;pReadBuf, connWrkr-&gt;readBufSize);
		if (count &gt; 0) {
			processData(inst, connWrkr, (const char*)connWrkr-&gt;pReadBuf, count);
		} else {
			break;
		}
	}

	/* submit remainder */
	doSubmitMsg(inst, connWrkr, connWrkr-&gt;pMsg, connWrkr-&gt;iMsg);
	multiSubmitFlush(&amp;connWrkr-&gt;multiSub);

	mg_send_http_ok(conn, &quot;text/plain&quot;, 0);
	rc = 200;

finalize_it:
	if (connWrkr-&gt;parseState.bzInitDone) {
		inflateEnd(&amp;connWrkr-&gt;parseState.zstrm);
	}
	/* reset */
	connWrkr-&gt;iMsg = 0;

	return rc;
}

static int runloop(void)
{
	dbgprintf(&quot;imhttp started.\n&quot;);

	/* Add handler for form data */
	for(instanceConf_t *inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		assert(inst-&gt;pszEndpoint);
		if (inst-&gt;pszEndpoint) {
			dbgprintf(&quot;setting request handler: '%s'\n&quot;, inst-&gt;pszEndpoint);
			mg_set_request_handler(s_httpserv-&gt;ctx, (char *)inst-&gt;pszEndpoint, postHandler, inst);
			if (inst-&gt;pszBasicAuthFile) {
				mg_set_auth_handler(s_httpserv-&gt;ctx, (char *)inst-&gt;pszEndpoint, basicAuthHandler, inst);
			}
		}
	}

	/* Wait until the server should be closed */
	while(glbl.GetGlobalInputTermState() == 0) {
		sleep(1);
	}
	return EXIT_SUCCESS;
}

BEGINnewInpInst
	struct cnfparamvals *pvals;
	instanceConf_t *inst;
	int i;
CODESTARTnewInpInst
	DBGPRINTF(&quot;newInpInst (imhttp)\n&quot;);
	pvals = nvlstGetParams(lst, &amp;inppblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS,
			        &quot;imhttp: required parameter are missing\n&quot;);
<A NAME="2"></A>		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1120-0.html#2',2,'match1120-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	if(Debug) {
		dbgprintf(&quot;input param blk in imtcp:\n&quot;);
		cnfparamsPrint(&amp;inppblk, pvals);
	}

	CHKiRet(createInstance(&amp;inst));

	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(inppblk.descr[i].name, &quot;endpoint&quot;)) {
<A NAME="1"></A>			inst-&gt;pszEndpoint = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, &quot;basicauthfile&quot;)) {
			inst-&gt;pszBasicAuthFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1120-0.html#1',2,'match1120-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		} else if(!strcmp(inppblk.descr[i].name, &quot;ruleset&quot;)) {
			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, &quot;name&quot;)) {
			inst-&gt;pszInputName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, &quot;ratelimit.burst&quot;)) {
			inst-&gt;ratelimitBurst = (unsigned int) pvals[i].val.d.n;</B></FONT>
		} else if(!strcmp(inppblk.descr[i].name, &quot;ratelimit.interval&quot;)) {
			inst-&gt;ratelimitInterval = (unsigned int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;flowcontrol&quot;)) {
			inst-&gt;flowControl = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;disablelfdelimiter&quot;)) {
			inst-&gt;bDisableLFDelim = (int) pvals[i].val.d.n;
		} else if (!strcmp(inppblk.descr[i].name, &quot;supportoctetcountedframing&quot;)) {
			inst-&gt;bSuppOctetFram = (int) pvals[i].val.d.n;
		} else if (!strcmp(inppblk.descr[i].name, &quot;addmetadata&quot;)) {
			inst-&gt;bAddMetadata = (int) pvals[i].val.d.n;
		} else {
			dbgprintf(&quot;imhttp: program error, non-handled &quot;
			  &quot;param '%s'\n&quot;, inppblk.descr[i].name);
		}
	}

	if (inst-&gt;pszInputName) {
		CHKiRet(prop.Construct(&amp;inst-&gt;pInputName));
		CHKiRet(prop.SetString(inst-&gt;pInputName, inst-&gt;pszInputName, ustrlen(inst-&gt;pszInputName)));
		CHKiRet(prop.ConstructFinalize(inst-&gt;pInputName));
	}
	CHKiRet(ratelimitNew(&amp;inst-&gt;ratelimiter, &quot;imphttp&quot;, NULL));
	ratelimitSetLinuxLike(inst-&gt;ratelimiter, inst-&gt;ratelimitInterval, inst-&gt;ratelimitBurst);

finalize_it:
CODE_STD_FINALIZERnewInpInst
	cnfparamvalsDestruct(pvals, &amp;inppblk);
ENDnewInpInst


BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	loadModConf-&gt;ports.name = NULL;
	loadModConf-&gt;docroot.name = NULL;
	loadModConf-&gt;nOptions = 0;
	loadModConf-&gt;options = NULL;
ENDbeginCnfLoad


BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;imhttp: error processing module &quot;
				&quot;config parameters [module(...)]&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf(&quot;module (global) param blk for imhttp:\n&quot;);
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(int i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(modpblk.descr[i].name, &quot;ports&quot;)) {
			assert(loadModConf-&gt;ports.name == NULL);
			assert(loadModConf-&gt;ports.val == NULL);
			loadModConf-&gt;ports.name = strdup(CIVETWEB_OPTION_NAME_PORTS);
			loadModConf-&gt;ports.val = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(modpblk.descr[i].name, &quot;documentroot&quot;)) {
			assert(loadModConf-&gt;docroot.name == NULL);
			assert(loadModConf-&gt;docroot.val == NULL);
			loadModConf-&gt;docroot.name = strdup(CIVETWEB_OPTION_NAME_DOCUMENT_ROOT);
			loadModConf-&gt;docroot.val = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, &quot;liboptions&quot;)) {
			loadModConf-&gt;nOptions = pvals[i].val.d.ar-&gt;nmemb;
			CHKmalloc(loadModConf-&gt;options = malloc(sizeof(struct option) *
			                                      pvals[i].val.d.ar-&gt;nmemb ));
			for(int j = 0 ; j &lt;  pvals[i].val.d.ar-&gt;nmemb ; ++j) {
				char *cstr = es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
				CHKiRet(processCivetwebOptions(cstr, &amp;loadModConf-&gt;options[j].name,
					&amp;loadModConf-&gt;options[j].val));
				free(cstr);
			}
		} else {
			dbgprintf(&quot;imhttp: program error, non-handled &quot;
			  &quot;param '%s' in beginCnfLoad\n&quot;, modpblk.descr[i].name);
		}
	}

finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf


BEGINendCnfLoad
CODESTARTendCnfLoad
	loadModConf = NULL; /* done loading */
ENDendCnfLoad

/* function to generate error message if framework does not find requested ruleset */
static inline void
std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
{
	LogError(0, NO_ERRCODE, &quot;imhttp: ruleset '%s' for %s not found - &quot;
			&quot;using default ruleset instead&quot;, inst-&gt;pszBindRuleset,
			inst-&gt;pszEndpoint);
}

BEGINcheckCnf
	instanceConf_t *inst;
CODESTARTcheckCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		std_checkRuleset(pModConf, inst);
	}
	/* verify civetweb options are valid */
	const struct mg_option *valid_opts = mg_get_valid_options();
	for (int i = 0; i &lt; pModConf-&gt;nOptions; ++i) {
		if (!valid_civetweb_option(valid_opts, pModConf-&gt;options[i].name)) {
			LogError(0, RS_RET_CONF_PARSE_WARNING, &quot;imhttp: module loaded, but &quot;
			&quot;invalid civetweb option found - imhttp may not receive connections.&quot;);
			iRet = RS_RET_CONF_PARSE_WARNING;
		}
	}
ENDcheckCnf


BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;

	if (!s_httpserv) {
		CHKmalloc(s_httpserv = calloc(1, sizeof(httpserv_t)));
	}
	/* options represents (key, value) so allocate 2x, and null terminated */
	size_t count = 1;
	if (runModConf-&gt;ports.val) {
		count += 2;
	}
	if (runModConf-&gt;docroot.val) {
		count += 2;
	}
	count += (2 * runModConf-&gt;nOptions);
	CHKmalloc(s_httpserv-&gt;civetweb_options = calloc(count, sizeof(*s_httpserv-&gt;civetweb_options)));

	const char **pcivetweb_options = s_httpserv-&gt;civetweb_options;
	if (runModConf-&gt;nOptions) {
		s_httpserv-&gt;civetweb_options_count = count;
		for (int i = 0; i &lt; runModConf-&gt;nOptions; ++i) {
			*pcivetweb_options = runModConf-&gt;options[i].name;
			pcivetweb_options++;
			*pcivetweb_options = runModConf-&gt;options[i].val;
			pcivetweb_options++;
		}
	}
	/* append port, docroot */
	if (runModConf-&gt;ports.val) {
		*pcivetweb_options = runModConf-&gt;ports.name;
		pcivetweb_options++;
		*pcivetweb_options = runModConf-&gt;ports.val;
		pcivetweb_options++;
	}
	if (runModConf-&gt;docroot.val) {
		*pcivetweb_options = runModConf-&gt;docroot.name;
		pcivetweb_options++;
		*pcivetweb_options = runModConf-&gt;docroot.val;
		pcivetweb_options++;
	}

	const char **option = s_httpserv-&gt;civetweb_options;
	for (; option &amp;&amp; *option != NULL; option++) {
		dbgprintf(&quot;imhttp: civetweb option: %s\n&quot;, *option);
	}

	CHKiRet(statsobj.Construct(&amp;statsCounter.stats));
	CHKiRet(statsobj.SetName(statsCounter.stats, UCHAR_CONSTANT(&quot;imhttp&quot;)));
	CHKiRet(statsobj.SetOrigin(statsCounter.stats, UCHAR_CONSTANT(&quot;imhttp&quot;)));
	STATSCOUNTER_INIT(statsCounter.ctrSubmitted, statsCounter.mutCtrSubmitted);
	CHKiRet(statsobj.AddCounter(statsCounter.stats, UCHAR_CONSTANT(&quot;submitted&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(statsCounter.ctrSubmitted)));

	STATSCOUNTER_INIT(statsCounter.ctrFailed, statsCounter.mutCtrFailed);
	CHKiRet(statsobj.AddCounter(statsCounter.stats, UCHAR_CONSTANT(&quot;failed&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(statsCounter.ctrFailed)));

	STATSCOUNTER_INIT(statsCounter.ctrDiscarded, statsCounter.mutCtrDiscarded);
	CHKiRet(statsobj.AddCounter(statsCounter.stats, UCHAR_CONSTANT(&quot;discarded&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(statsCounter.ctrDiscarded)));

	CHKiRet(statsobj.ConstructFinalize(statsCounter.stats));

	/* init civetweb libs and start server w/no input */
	mg_init_library(MG_FEATURES_TLS);
	memset(&amp;callbacks, 0, sizeof(callbacks));
	//callbacks.log_message = log_message;
	//callbacks.init_ssl = init_ssl;
	callbacks.init_thread = init_thread;
	callbacks.exit_thread = exit_thread;
	s_httpserv-&gt;ctx = mg_start(&amp;callbacks, NULL, s_httpserv-&gt;civetweb_options);
	/* Check return value: */
	if (s_httpserv-&gt;ctx == NULL) {
		LogError(0, RS_RET_INTERNAL_ERROR, &quot;Cannot start CivetWeb - mg_start failed.\n&quot;);
		ABORT_FINALIZE(RS_RET_INTERNAL_ERROR);
	}

	finalize_it:
	if (iRet != RS_RET_OK) {
		free(s_httpserv);
		s_httpserv = NULL;
		LogError(0, NO_ERRCODE, &quot;imhttp: error %d trying to activate configuration&quot;, iRet);
	}
	RETiRet;
ENDactivateCnf

BEGINfreeCnf
	instanceConf_t *inst, *del;
CODESTARTfreeCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
		if (inst-&gt;ratelimiter) {
			ratelimitDestruct(inst-&gt;ratelimiter);
		}
		if (inst-&gt;pInputName) {
			prop.Destruct(&amp;inst-&gt;pInputName);
		}
		free(inst-&gt;pszEndpoint);
		free(inst-&gt;pszBasicAuthFile);
		free(inst-&gt;pszBindRuleset);
		free(inst-&gt;pszInputName);

		del = inst;
		inst = inst-&gt;next;
		free(del);
	}

	for (int i = 0; i &lt; pModConf-&gt;nOptions; ++i) {
		free((void*) pModConf-&gt;options[i].name);
		free((void*) pModConf-&gt;options[i].val);
	}
	free(pModConf-&gt;options);

	free((void*)pModConf-&gt;ports.name);
	free((void*)pModConf-&gt;ports.val);
	free((void*)pModConf-&gt;docroot.name);
	free((void*)pModConf-&gt;docroot.val);

	if (statsCounter.stats) {
		statsobj.Destruct(&amp;statsCounter.stats);
	}
ENDfreeCnf


/* This function is called to gather input.
 */
BEGINrunInput
CODESTARTrunInput
	runloop();
ENDrunInput

/* initialize and return if will run or not */
BEGINwillRun
CODESTARTwillRun
ENDwillRun

BEGINafterRun
CODESTARTafterRun
	if (s_httpserv) {
		mg_stop(s_httpserv-&gt;ctx);
		mg_exit_library();
		free(s_httpserv-&gt;civetweb_options);
		free(s_httpserv);
	}
ENDafterRun


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	// if(eFeat == sFEATURENonCancelInputTermination)
	// 	iRet = RS_RET_OK;
ENDisCompatibleWithFeature


BEGINmodExit
CODESTARTmodExit
	if(pInputName != NULL) {
		prop.Destruct(&amp;pInputName);
	}

	/* release objects we used */
	objRelease(statsobj, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
ENDmodExit

BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));

	/* we need to create the inputName property (only once during our lifetime) */
	CHKiRet(prop.Construct(&amp;pInputName));
	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT(&quot;imhttp&quot;), sizeof(&quot;imhttp&quot;) - 1));
	CHKiRet(prop.ConstructFinalize(pInputName));
ENDmodInit
</PRE>
</div>
  </div>
</body>
</html>
