<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for omclickhouse.c &amp; imhttp.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for omclickhouse.c &amp; imhttp.c
      </h3>
<h1 align="center">
        9.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>omclickhouse.c (12.328767%)<th>imhttp.c (7.1770334%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(132-149)<td><a href="#" name="0">(160-180)</a><td align="center"><font color="#ff0000">30</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(835-840)<td><a href="#" name="1">(1007-1012)</a><td align="center"><font color="#900000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(821-834)<td><a href="#" name="2">(993-1006)</a><td align="center"><font color="#900000">17</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(154-164)<td><a href="#" name="3">(220-226)</a><td align="center"><font color="#770000">14</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(919-934)<td><a href="#" name="4">(237-244)</a><td align="center"><font color="#660000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>omclickhouse.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* omclickhouse.c
 * This is the https://clickhouse.yandex/ output module.
 *
 * Copyright 2018 Pascal Withopf and Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "config.h"
#include "rsyslog.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;memory.h&gt;
#include &lt;string.h&gt;
#include &lt;curl/curl.h&gt;
#include &lt;curl/easy.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#if defined(__FreeBSD__)
#include &lt;unistd.h&gt;
#endif
#include &lt;json.h&gt;
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "statsobj.h"
#include "cfsysline.h"
#include "unicode-helper.h"
#include "obj-types.h"
#include "ratelimit.h"
#include "ruleset.h"

#ifndef O_LARGEFILE
#  define O_LARGEFILE 0
#endif

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("omclickhouse")

/* internal structures */
DEF_OMOD_STATIC_DATA
DEFobjCurrIf(statsobj)
DEFobjCurrIf(prop)
DEFobjCurrIf(ruleset)

statsobj_t *indexStats;
STATSCOUNTER_DEF(indexSubmit, mutIndexSubmit)
STATSCOUNTER_DEF(indexHTTPFail, mutIndexHTTPFail)
STATSCOUNTER_DEF(indexHTTPReqFail, mutIndexHTTPReqFail)
STATSCOUNTER_DEF(indexFail, mutIndexFail)
STATSCOUNTER_DEF(indexSuccess, mutIndexSuccess)



typedef struct curl_slist HEADER;
typedef struct instanceConf_s {
	uchar *serverBaseUrl;
	int port;
	uchar *user;
	uchar *pwd;
	long healthCheckTimeout;
	long timeout;
	uchar *authBuf;
	uchar *tplName;
	sbool useHttps;
	sbool allowUnsignedCerts;
	sbool skipVerifyHost;
	int fdErrFile;
	uchar *errorFile;
	sbool bulkmode;
	size_t maxbytes;
	uchar *caCertFile;
	uchar *myCertFile;
	uchar *myPrivKeyFile;
	struct instanceConf_s *next;
} instanceData;

struct modConfData_s {
	rsconf_t *pConf;		/* our overall config object */
	instanceConf_t *root, *tail;
};
static modConfData_t *loadModConf = NULL;	/* modConf ptr to use for the current load process */

typedef struct wrkrInstanceData {
	PTR_ASSERT_DEF
	instanceData *pData;
	CURL	*curlPostHandle;	/* libcurl session handle for posting data to the server */
	HEADER	*curlHeader;	/* json POST request info */
	CURL	*curlCheckConnHandle;	/* libcurl session handle for checking the server connection */
	int replyLen;
	char *reply;
	uchar *restURL;
	struct {
		es_str_t *data;
		int nmemb;	/* number of messages in batch (for statistics counting) */
	} batch;
	sbool insertErrorSent;  /* needed for insert error message */
} wrkrInstanceData_t;

/* tables for interfacing with the v6 config system */
/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
	{ "server", eCmdHdlrGetWord, 0 },
	{ "port", eCmdHdlrInt, 0 },
	{ "user", eCmdHdlrGetWord, 0 },
<a name="0"></a>	{ "pwd", eCmdHdlrGetWord, 0 },
	{ "healthchecktimeout", eCmdHdlrInt, 0 },
	{ "timeout", eCmdHdlrInt, 0 },
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "template", eCmdHdlrGetWord, 0 },
	{ "usehttps", eCmdHdlrBinary, 0 },
	{ "allowunsignedcerts", eCmdHdlrBinary, 0 },
	{ "skipverifyhost", eCmdHdlrBinary, 0 },
	{ "errorfile", eCmdHdlrGetWord, 0 },
	{ "bulkmode", eCmdHdlrBinary, 0 },
	{ "maxbytes", eCmdHdlrSize, 0 },
	{ "tls.cacert", eCmdHdlrString, 0 },
	{ "tls.mycert", eCmdHdlrString, 0 },
	{ "tls.myprivkey", eCmdHdlrString, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};

static rsRetVal curlSetup(wrkrInstanceData_t *pWrkrData);</b></font>

<a name="3"></a>BEGINcreateInstance
CODESTARTcreateInstance
	pData-&gt;fdErrFile = -1;
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	pData-&gt;caCertFile = NULL;
	pData-&gt;myCertFile = NULL;
	pData-&gt;myPrivKeyFile = NULL;
ENDcreateInstance

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	pWrkrData-&gt;curlHeader = NULL;
	pWrkrData-&gt;curlPostHandle = NULL;
	pWrkrData-&gt;curlCheckConnHandle = NULL;
	pWrkrData-&gt;restURL = NULL;</b></font>
	if(pData-&gt;bulkmode) {
		if((pWrkrData-&gt;batch.data = es_newStr(1024)) == NULL) {
			LogError(0, RS_RET_OUT_OF_MEMORY,
				"omclickhouse: error creating batch string "
			        "turned off bulk mode\n");
			pData-&gt;bulkmode = 0; /* at least it works */
		}
	}
	pWrkrData-&gt;insertErrorSent = 0;

	iRet = curlSetup(pWrkrData);
ENDcreateWrkrInstance

BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature

BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;serverBaseUrl);
	free(pData-&gt;user);
	free(pData-&gt;pwd);
	free(pData-&gt;authBuf);
	if(pData-&gt;fdErrFile != -1)
		close(pData-&gt;fdErrFile);
	free(pData-&gt;errorFile);
	free(pData-&gt;tplName);
	free(pData-&gt;caCertFile);
	free(pData-&gt;myCertFile);
	free(pData-&gt;myPrivKeyFile);
ENDfreeInstance

BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	if(pWrkrData-&gt;curlHeader != NULL) {
		curl_slist_free_all(pWrkrData-&gt;curlHeader);
		pWrkrData-&gt;curlHeader = NULL;
	}
	if(pWrkrData-&gt;curlCheckConnHandle != NULL) {
		curl_easy_cleanup(pWrkrData-&gt;curlCheckConnHandle);
		pWrkrData-&gt;curlCheckConnHandle = NULL;
	}
	if(pWrkrData-&gt;curlPostHandle != NULL) {
		curl_easy_cleanup(pWrkrData-&gt;curlPostHandle);
		pWrkrData-&gt;curlPostHandle = NULL;
	}
	if (pWrkrData-&gt;restURL != NULL) {
		free(pWrkrData-&gt;restURL);
		pWrkrData-&gt;restURL = NULL;
	}
	es_deleteStr(pWrkrData-&gt;batch.data);
ENDfreeWrkrInstance

BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	dbgprintf("omclickhouse\n");
	dbgprintf("\tserver='%s'\n", pData-&gt;serverBaseUrl);
	dbgprintf("\tport='%d'\n", pData-&gt;port);
	dbgprintf("\tuser='%s'\n", pData-&gt;user);
	dbgprintf("\tpwd='%s'\n", pData-&gt;pwd);
	dbgprintf("\thealthCheckTimeout=%lu\n", pData-&gt;healthCheckTimeout);
	dbgprintf("\ttimeout=%lu\n", pData-&gt;timeout);
	dbgprintf("\ttemplate='%s'\n", pData-&gt;tplName);
	dbgprintf("\tusehttps='%d'\n", pData-&gt;useHttps);
	dbgprintf("\tallowunsignedcerts='%d'\n", pData-&gt;allowUnsignedCerts);
	dbgprintf("\tskipverifyhost='%d'\n", pData-&gt;skipVerifyHost);
	dbgprintf("\terrorFile='%s'\n", pData-&gt;errorFile);
	dbgprintf("\tbulkmode='%d'\n", pData-&gt;bulkmode);
	dbgprintf("\tmaxbytes='%zu'\n", pData-&gt;maxbytes);
	dbgprintf("\ttls.cacert='%s'\n", pData-&gt;caCertFile);
	dbgprintf("\ttls.mycert='%s'\n", pData-&gt;myCertFile);
	dbgprintf("\ttls.myprivkey='%s'\n", pData-&gt;myPrivKeyFile);
ENDdbgPrintInstInfo


/* checks if connection to clickhouse can be established
 */
static rsRetVal ATTR_NONNULL()
checkConn(wrkrInstanceData_t *const pWrkrData)
{
	CURL *curl;
	CURLcode res;
	char errbuf[CURL_ERROR_SIZE] = "";
	const char* healthCheckMessage ="SELECT 1";
	DEFiRet;

	pWrkrData-&gt;reply = NULL;
	pWrkrData-&gt;replyLen = 0;
	curl = pWrkrData-&gt;curlCheckConnHandle;
	

	curl_easy_setopt(curl, CURLOPT_URL, pWrkrData-&gt;restURL);
	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, healthCheckMessage);
	curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, strlen(healthCheckMessage));
	curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, errbuf);
	res = curl_easy_perform(curl);

	if (res == CURLE_OK) {
		DBGPRINTF("omclickhouse: checkConn completed with success\n");
		ABORT_FINALIZE(RS_RET_OK);
	}

	DBGPRINTF("omclickhouse: checkConn failed: %s\n",
		curl_easy_strerror(res));

	LogMsg(0, RS_RET_SUSPENDED, LOG_WARNING,
		"omclickhouse: checkConn failed.");
	ABORT_FINALIZE(RS_RET_SUSPENDED);

finalize_it:
	free(pWrkrData-&gt;reply);
	pWrkrData-&gt;reply = NULL; /* don't leave dangling pointer */
	RETiRet;
}


BEGINtryResume
CODESTARTtryResume
	dbgprintf("omclickhouse: tryResume called\n");
	iRet = checkConn(pWrkrData);
ENDtryResume


/*
 * Dumps entire bulk request and response in error log
 */
static rsRetVal
getDataErrorDefault(wrkrInstanceData_t *pWrkrData, char *reply, uchar *reqmsg, char **rendered)
{
	DEFiRet;
	fjson_object *req=NULL;
	fjson_object *errRoot=NULL;

	if((req=fjson_object_new_object()) == NULL) ABORT_FINALIZE(RS_RET_ERR);
	fjson_object_object_add(req, "url", fjson_object_new_string((char*)pWrkrData-&gt;restURL));
	fjson_object_object_add(req, "postdata", fjson_object_new_string((char*)reqmsg));

	if((errRoot=fjson_object_new_object()) == NULL) ABORT_FINALIZE(RS_RET_ERR);
	fjson_object_object_add(errRoot, "request", req);
	fjson_object_object_add(errRoot, "reply", fjson_object_new_string(reply));
	*rendered = strdup((char*)fjson_object_to_json_string(errRoot));

	req=NULL;
	fjson_object_put(errRoot);

	finalize_it:
		fjson_object_put(req);
		RETiRet;
}


/* write data error request/replies to separate error file
 * Note: we open the file but never close it before exit. If it
 * needs to be closed, HUP must be sent.
 */
static rsRetVal ATTR_NONNULL()
writeDataError(wrkrInstanceData_t *const pWrkrData, uchar *const reqmsg)
{
	DEFiRet;
	instanceData *pData = pWrkrData-&gt;pData;
	char *rendered = pWrkrData-&gt;reply;
	size_t toWrite;
	ssize_t wrRet;

	if(pData-&gt;errorFile == NULL) {
		dbgprintf("omclickhouse: no local error logger defined - "
		          "ignoring ClickHouse error information\n");
		FINALIZE;
	}


	if(pData-&gt;fdErrFile == -1) {
		pData-&gt;fdErrFile = open((char*)pData-&gt;errorFile,
					O_WRONLY|O_CREAT|O_APPEND|O_LARGEFILE|O_CLOEXEC,
					S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP);
		if(pData-&gt;fdErrFile == -1) {
			LogError(errno, RS_RET_ERR, "omclickhouse: error opening error file %s",
				pData-&gt;errorFile);
			ABORT_FINALIZE(RS_RET_ERR);
		}
	}

	if(getDataErrorDefault(pWrkrData, pWrkrData-&gt;reply, reqmsg, &amp;rendered) != RS_RET_OK) {
		ABORT_FINALIZE(RS_RET_ERR);
	}

	/* we do not do real error-handling on the err file, as this finally complicates
	 * things way to much.
	 */
	dbgprintf("omclickhouse: message sent: '%s'\n", reqmsg);
	dbgprintf("omclickhouse: error record: '%s'\n", rendered);
	toWrite = strlen(rendered) + 1;
	/* Note: we overwrite the '\0' terminator with '\n' -- so we avoid
	 * caling malloc() -- write() does NOT need '\0'!
	 */
	rendered[toWrite-1] = '\n'; /* NO LONGER A STRING! */
	wrRet = write(pData-&gt;fdErrFile, rendered, toWrite);
	if(wrRet != (ssize_t) toWrite) {
		LogError(errno, RS_RET_IO_ERROR,
			"omclickhouse: error writing error file %s, write returned %lld",
			pData-&gt;errorFile, (long long) wrRet);
	}

finalize_it:
	RETiRet;
}


static rsRetVal
checkResult(wrkrInstanceData_t *pWrkrData, uchar *reqmsg)
{
	DEFiRet;

	if(strstr(pWrkrData-&gt;reply, " = DB::Exception") != NULL) {
		dbgprintf("omclickhouse: action failed with error: %s\n", pWrkrData-&gt;reply);
		iRet = RS_RET_DATAFAIL;
	}

	if(iRet == RS_RET_DATAFAIL) {
		STATSCOUNTER_INC(indexFail, mutIndexFail);
		writeDataError(pWrkrData, reqmsg);
		iRet = RS_RET_OK; /* we have handled the problem! */
	}


	if(iRet != RS_RET_OK) {
		STATSCOUNTER_INC(indexFail, mutIndexFail);
	}
	RETiRet;
}

static rsRetVal ATTR_NONNULL(1)
setPostURL(wrkrInstanceData_t *const pWrkrData)
{
	char* baseUrl;
	es_str_t *url;
	DEFiRet;
	instanceData *const pData = pWrkrData-&gt;pData;

	baseUrl = (char*)pData-&gt;serverBaseUrl;
	url = es_newStrFromCStr(baseUrl, strlen(baseUrl));
	if (url == NULL) {
		LogError(0, RS_RET_OUT_OF_MEMORY,
			"omclickhouse: error allocating new estr for POST url.");
		ABORT_FINALIZE(RS_RET_ERR);
	}

	if(pWrkrData-&gt;restURL != NULL)
		free(pWrkrData-&gt;restURL);

	pWrkrData-&gt;restURL = (uchar*)es_str2cstr(url, NULL);
	curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_URL, pWrkrData-&gt;restURL);
	dbgprintf("omclickhouse: using REST URL: '%s'\n", pWrkrData-&gt;restURL);

finalize_it:
	if (url != NULL)
		es_deleteStr(url);
	RETiRet;
}


/* this method computes the next data set to be added to the batch
 * returns the expected size of adding the next message into the
 * batched request to clickhouse
 */
static size_t
computeBulkMessage(const wrkrInstanceData_t *const pWrkrData,
	const uchar *const message, char **newMessage)
{
	size_t r = 0;
	char *v;
	if (pWrkrData-&gt;batch.nmemb != 0
	&amp;&amp; (v = strstr((const char *)message, "VALUES")) != NULL
	&amp;&amp; (v = strchr(v, '(')) != NULL
	) {
		*newMessage = v;
		r = strlen(*newMessage);
	} else {
		*newMessage = (char*)message;
		r = strlen(*newMessage);
	}
	dbgprintf("omclickhouse: computeBulkMessage: new message part: %s\n", *newMessage);

	return r;
}


/* This method builds the batch, that will be submitted.
 */
static rsRetVal
buildBatch(wrkrInstanceData_t *pWrkrData, char *message)
{
	DEFiRet;
	int length = strlen(message);
	int r;

	r = es_addBuf(&amp;pWrkrData-&gt;batch.data, message, length);
	if(r != 0) {
		LogError(0, RS_RET_ERR, "omclickhouse: growing batch failed with code %d", r);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	++pWrkrData-&gt;batch.nmemb;
	iRet = RS_RET_OK;

finalize_it:
	RETiRet;
}


static void ATTR_NONNULL()
initializeBatch(wrkrInstanceData_t *pWrkrData)
{
	es_emptyStr(pWrkrData-&gt;batch.data);
	pWrkrData-&gt;batch.nmemb = 0;
}


static rsRetVal ATTR_NONNULL(1, 2)
curlPost(wrkrInstanceData_t *pWrkrData, uchar *message, int msglen, const int nmsgs)
{
	CURLcode code;
	CURL *const curl = pWrkrData-&gt;curlPostHandle;
	char errbuf[CURL_ERROR_SIZE] = "";
	DEFiRet;

	if(!strstr((char*)message, "INSERT INTO") &amp;&amp; !pWrkrData-&gt;insertErrorSent) {
		indexHTTPFail += nmsgs;
		LogError(0, RS_RET_ERR, "omclickhouse: Message is no Insert query: "
				"Message suspended: %s", (char*)message);
		pWrkrData-&gt;insertErrorSent = 1;
		ABORT_FINALIZE(RS_RET_ERR);
	}

	pWrkrData-&gt;reply = NULL;
	pWrkrData-&gt;replyLen = 0;

	CHKiRet(setPostURL(pWrkrData));

	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, (char *)message);
	curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, msglen);
	curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, errbuf);
	code = curl_easy_perform(curl);
	dbgprintf("curl returned %lld\n", (long long) code);
	if (code != CURLE_OK &amp;&amp; code != CURLE_HTTP_RETURNED_ERROR) {
		STATSCOUNTER_INC(indexHTTPReqFail, mutIndexHTTPReqFail);
		indexHTTPFail += nmsgs;
		LogError(0, RS_RET_SUSPENDED,
			"omclickhouse: we are suspending ourselfs due "
			"to server failure %lld: %s", (long long) code, errbuf);
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}

	if(pWrkrData-&gt;reply == NULL) {
		dbgprintf("omclickhouse: pWrkrData reply==NULL, replyLen = '%d'\n",
			pWrkrData-&gt;replyLen);
		STATSCOUNTER_INC(indexSuccess, mutIndexSuccess);
	} else {
		dbgprintf("omclickhouse: pWrkrData replyLen = '%d'\n", pWrkrData-&gt;replyLen);
		if(pWrkrData-&gt;replyLen &gt; 0) {
			pWrkrData-&gt;reply[pWrkrData-&gt;replyLen] = '\0';
			/* Append 0 Byte if replyLen is above 0 - byte has been reserved in malloc */
		}
		dbgprintf("omclickhouse: pWrkrData reply: '%s'\n", pWrkrData-&gt;reply);
		CHKiRet(checkResult(pWrkrData, message));
	}

finalize_it:
	free(pWrkrData-&gt;reply);
	pWrkrData-&gt;reply = NULL; /* don't leave dangling pointer */
	RETiRet;
}


static rsRetVal
submitBatch(wrkrInstanceData_t *pWrkrData)
{
	char *cstr = NULL;
	DEFiRet;

	cstr = es_str2cstr(pWrkrData-&gt;batch.data, NULL);
	dbgprintf("omclickhouse: submitBatch, batch: '%s'\n", cstr);

	CHKiRet(curlPost(pWrkrData, (uchar*) cstr, strlen(cstr), pWrkrData-&gt;batch.nmemb));

finalize_it:
	free(cstr);
	RETiRet;
}


BEGINbeginTransaction
CODESTARTbeginTransaction
	if(!pWrkrData-&gt;pData-&gt;bulkmode) {
		FINALIZE;
	}

	initializeBatch(pWrkrData);
finalize_it:
ENDbeginTransaction


BEGINdoAction
	char *batchPart = NULL;
CODESTARTdoAction
	dbgprintf("CODESTARTdoAction: entered\n");
	STATSCOUNTER_INC(indexSubmit, mutIndexSubmit);

	if(pWrkrData-&gt;pData-&gt;bulkmode) {
		const size_t nBytes = computeBulkMessage(pWrkrData, ppString[0], &amp;batchPart);
		dbgprintf("pascal: doAction: message: %s\n", batchPart);

		/* If max bytes is set and this next message will put us over the limit,
		* submit the current buffer and reset */
		if(pWrkrData-&gt;pData-&gt;maxbytes &gt; 0
			&amp;&amp; es_strlen(pWrkrData-&gt;batch.data) + nBytes &gt; pWrkrData-&gt;pData-&gt;maxbytes) {

			dbgprintf("omclickhouse: maxbytes limit reached, submitting partial "
				"batch of %d elements.\n", pWrkrData-&gt;batch.nmemb);
			CHKiRet(submitBatch(pWrkrData));
			initializeBatch(pWrkrData);
			batchPart = (char*)ppString[0];
		}

		CHKiRet(buildBatch(pWrkrData, batchPart));

		iRet = pWrkrData-&gt;batch.nmemb == 1 ? RS_RET_PREVIOUS_COMMITTED : RS_RET_DEFER_COMMIT;
	} else {
		CHKiRet(curlPost(pWrkrData, ppString[0], strlen((char*)ppString[0]), 1));
	}
finalize_it:
ENDdoAction


BEGINendTransaction
CODESTARTendTransaction
/* End Transaction only if batch data is not empty */
	if (pWrkrData-&gt;batch.data != NULL &amp;&amp; pWrkrData-&gt;batch.nmemb &gt; 0) {
		CHKiRet(submitBatch(pWrkrData));
	} else {
		dbgprintf("omclickhouse: endTransaction, pWrkrData-&gt;batch.data is NULL, "
			"nothing to send. \n");
	}
finalize_it:
ENDendTransaction

static void ATTR_NONNULL()
setInstParamDefaults(instanceData *const pData)
{
	pData-&gt;serverBaseUrl = NULL;
	pData-&gt;port = 8123;
	pData-&gt;user = NULL;
	pData-&gt;pwd = NULL;
	pData-&gt;healthCheckTimeout = 3500;
	pData-&gt;timeout = 0;
	pData-&gt;authBuf = NULL;
	pData-&gt;tplName = NULL;
	pData-&gt;useHttps = 1;
	pData-&gt;allowUnsignedCerts = 1;
	pData-&gt;skipVerifyHost = 0;
	pData-&gt;errorFile = NULL;
	pData-&gt;bulkmode = 1;
	pData-&gt;maxbytes = 104857600; //100MB
	pData-&gt;caCertFile = NULL;
	pData-&gt;myCertFile = NULL;
	pData-&gt;myPrivKeyFile = NULL;
}

/* POST result string ... useful for debugging */
static size_t
curlResult(void *ptr, size_t size, size_t nmemb, void *userdata)
{
	char *p = (char *)ptr;
	wrkrInstanceData_t *pWrkrData = (wrkrInstanceData_t*) userdata;
	char *buf;
	size_t newlen;
	newlen = pWrkrData-&gt;replyLen + size*nmemb;
	if((buf = realloc(pWrkrData-&gt;reply, newlen + 1)) == NULL) {
		LogError(errno, RS_RET_ERR, "omclickhouse: realloc failed in curlResult");
		return 0; /* abort due to failure */
	}
	memcpy(buf+pWrkrData-&gt;replyLen, p, size*nmemb);
	pWrkrData-&gt;replyLen = newlen;
	pWrkrData-&gt;reply = buf;
	return size*nmemb;
}

static void ATTR_NONNULL()
curlSetupCommon(wrkrInstanceData_t *const pWrkrData, CURL *const handle)
{
	curl_easy_setopt(handle, CURLOPT_HTTPHEADER, pWrkrData-&gt;curlHeader);
	curl_easy_setopt(handle, CURLOPT_NOSIGNAL, TRUE);
	curl_easy_setopt(handle, CURLOPT_WRITEFUNCTION, curlResult);
	curl_easy_setopt(handle, CURLOPT_WRITEDATA, pWrkrData);
	if(pWrkrData-&gt;pData-&gt;allowUnsignedCerts)
		curl_easy_setopt(handle, CURLOPT_SSL_VERIFYPEER, FALSE);
	if(pWrkrData-&gt;pData-&gt;skipVerifyHost)
		curl_easy_setopt(handle, CURLOPT_SSL_VERIFYHOST, FALSE);
	if(pWrkrData-&gt;pData-&gt;authBuf != NULL) {
		curl_easy_setopt(handle, CURLOPT_USERPWD, pWrkrData-&gt;pData-&gt;authBuf);
		curl_easy_setopt(handle, CURLOPT_PROXYAUTH, CURLAUTH_ANY);
	}

	if(pWrkrData-&gt;pData-&gt;caCertFile) {
		curl_easy_setopt(handle, CURLOPT_CAINFO, pWrkrData-&gt;pData-&gt;caCertFile);
	}
	if(pWrkrData-&gt;pData-&gt;myCertFile) {
		curl_easy_setopt(handle, CURLOPT_SSLCERT, pWrkrData-&gt;pData-&gt;myCertFile);
	}
	if(pWrkrData-&gt;pData-&gt;myPrivKeyFile) {
		curl_easy_setopt(handle, CURLOPT_SSLKEY, pWrkrData-&gt;pData-&gt;myPrivKeyFile);
	}
	/* uncomment for in-dept debuggung:
	curl_easy_setopt(handle, CURLOPT_VERBOSE, TRUE); */
}


static void ATTR_NONNULL()
curlCheckConnSetup(wrkrInstanceData_t *const pWrkrData)
{
	curlSetupCommon(pWrkrData, pWrkrData-&gt;curlCheckConnHandle);
	curl_easy_setopt(pWrkrData-&gt;curlCheckConnHandle,
		CURLOPT_TIMEOUT_MS, pWrkrData-&gt;pData-&gt;healthCheckTimeout);
}


static void ATTR_NONNULL(1)
curlPostSetup(wrkrInstanceData_t *const pWrkrData)
{
	curlSetupCommon(pWrkrData, pWrkrData-&gt;curlPostHandle);
	curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_POST, 1);
	if(pWrkrData-&gt;pData-&gt;timeout) {
		curl_easy_setopt(pWrkrData-&gt;curlPostHandle,
			CURLOPT_TIMEOUT_MS, pWrkrData-&gt;pData-&gt;timeout);
	}
}

#define CONTENT_JSON "Content-Type: application/json; charset=utf-8"

static rsRetVal ATTR_NONNULL()
curlSetup(wrkrInstanceData_t *const pWrkrData)
{
	DEFiRet;
	pWrkrData-&gt;curlHeader = curl_slist_append(NULL, CONTENT_JSON);
	CHKmalloc(pWrkrData-&gt;curlPostHandle = curl_easy_init());
	curlPostSetup(pWrkrData);

	CHKmalloc(pWrkrData-&gt;curlCheckConnHandle = curl_easy_init());
	curlCheckConnSetup(pWrkrData);

finalize_it:
	if(iRet != RS_RET_OK &amp;&amp; pWrkrData-&gt;curlPostHandle != NULL) {
		curl_easy_cleanup(pWrkrData-&gt;curlPostHandle);
		pWrkrData-&gt;curlPostHandle = NULL;
	}
	RETiRet;
}

static rsRetVal
computeAuthHeader(char* user, char* pwd, uchar** authBuf)
{
	DEFiRet;
	int r;

	es_str_t* auth = es_newStr(1024);
	if (auth == NULL) {
		LogError(0, RS_RET_OUT_OF_MEMORY,
			"omclickhouse: failed to allocate es_str auth for auth header construction");
		ABORT_FINALIZE(RS_RET_ERR);
	}

	r = es_addBuf(&amp;auth, user, strlen(user));
	if(r == 0)
		r = es_addChar(&amp;auth, ':');
	if(r == 0 &amp;&amp; pwd != NULL)
		r = es_addBuf(&amp;auth, pwd, strlen(pwd));
	if(r == 0)
		*authBuf = (uchar*) es_str2cstr(auth, NULL);

	if (r != 0 || *authBuf == NULL) {
		LogError(0, RS_RET_ERR, "omclickhouse: failed to build auth header\n");
		ABORT_FINALIZE(RS_RET_ERR);
	}

finalize_it:
	if (auth != NULL)
		es_deleteStr(auth);
	RETiRet;
}

/* Build basic URL part, which includes hostname, port, user, pwd as follows:
 * http://user:pwd@hostname:port/ based on a server param
 * Newly creates a cstr for this purpose.
 */
static rsRetVal
computeBaseUrl(const char* server, const int port, const sbool useHttps, instanceData *pData)
{
#	define SCHEME_HTTPS "https://"
#	define SCHEME_HTTP "http://"

	char portBuf[64];
	int r = 0;
	const char *host = server;
	DEFiRet;

	assert(server[strlen(server)-1] != '/');

	es_str_t *urlBuf = es_newStr(256);
	if (urlBuf == NULL) {
		LogError(0, RS_RET_OUT_OF_MEMORY,
		"omclickhouse: failed to allocate es_str urlBuf in computeBaseUrl");
		ABORT_FINALIZE(RS_RET_ERR);
	}

	/* Find where the hostname/ip of the server starts. If the scheme is not specified
	  in the uri, start the buffer with a scheme corresponding to the useHttps parameter.
	*/
	if(strcasestr(server, SCHEME_HTTP)) {
		host = server + strlen(SCHEME_HTTP);
	} else if(strcasestr(server, SCHEME_HTTPS)) {
		host = server + strlen(SCHEME_HTTPS);
	} else {
		r = useHttps ? es_addBuf(&amp;urlBuf, SCHEME_HTTPS, sizeof(SCHEME_HTTPS)-1) :
			es_addBuf(&amp;urlBuf, SCHEME_HTTP, sizeof(SCHEME_HTTP)-1);
	}
	if (r == 0)
		r = es_addBuf(&amp;urlBuf, (char *)server, strlen(server));
	if (r == 0 &amp;&amp; !strchr(host, ':')) {
		snprintf(portBuf, sizeof(portBuf), ":%d", port);
		r = es_addBuf(&amp;urlBuf, portBuf, strlen(portBuf));
	}
	if (r == 0)
		r = es_addChar(&amp;urlBuf, '/');
	if (r == 0)
		pData-&gt;serverBaseUrl = (uchar*) es_str2cstr(urlBuf, NULL);

	if (r != 0 || pData-&gt;serverBaseUrl == NULL) {
		LogError(0, RS_RET_ERR, "omclickhouse: error occurred computing baseUrl from "
			"server %s", server);
		ABORT_FINALIZE(RS_RET_ERR);
	}
finalize_it:
	if (urlBuf) {
		es_deleteStr(urlBuf);
	}
	RETiRet;
}

BEGINnewActInst
	struct cnfparamvals *pvals;
	uchar *server = NULL;
	int i;
<a name="2"></a>	FILE *fp;
	char errStr[1024];
CODESTARTnewActInst
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, "server")) {
<a name="1"></a>			server = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "port")) {
			pData-&gt;port = (int) pvals[i].val.d.n;</b></font>
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(actpblk.descr[i].name, "user")) {
			pData-&gt;user = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "pwd")) {
			pData-&gt;pwd = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "healthchecktimeout")) {
			pData-&gt;healthCheckTimeout = (long) pvals[i].val.d.n;</b></font>
		} else if(!strcmp(actpblk.descr[i].name, "timeout")) {
			pData-&gt;timeout = (long) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "template")) {
			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "usehttps")) {
			pData-&gt;useHttps = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "allowunsignedcerts")) {
			pData-&gt;allowUnsignedCerts = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "skipverifyhost")) {
			pData-&gt;skipVerifyHost = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "errorfile")) {
			pData-&gt;errorFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "bulkmode")) {
			pData-&gt;bulkmode = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "maxbytes")) {
			pData-&gt;maxbytes = (size_t) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "tls.cacert")) {
			pData-&gt;caCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;caCertFile, "r");
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				LogError(0, RS_RET_NO_FILE_ACCESS,
					"error: omclickhouse: 'tls.cacert' file %s couldn't be accessed: %s\n",
						pData-&gt;caCertFile, errStr);
			} else {
				fclose(fp);
			}
		} else if(!strcmp(actpblk.descr[i].name, "tls.mycert")) {
			pData-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;myCertFile, "r");
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				LogError(0, RS_RET_NO_FILE_ACCESS,
					"error: omclickhouse: 'tls.mycert' file %s couldn't be accessed: %s\n",
						pData-&gt;myCertFile, errStr);
			} else {
				fclose(fp);
			}
		} else if(!strcmp(actpblk.descr[i].name, "tls.myprivkey")) {
			pData-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;myPrivKeyFile, "r");
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				LogError(0, RS_RET_NO_FILE_ACCESS,
					"error: omclickhouse: 'tls.myprivkey' file %s couldn't be accessed: %s\n",
						pData-&gt;myPrivKeyFile, errStr);
			} else {
				fclose(fp);
			}
		} else {
			LogError(0, RS_RET_INTERNAL_ERROR, "omclickhouse: program error, "
				"non-handled param '%s'", actpblk.descr[i].name);
		}
	}


	if(pData-&gt;user == NULL &amp;&amp; pData-&gt;pwd != NULL) {
		LogMsg(0, RS_RET_OK, LOG_WARNING, "omclickhouse: No user was specified "
				"but a password was given.");
	}

	if(pData-&gt;user != NULL)
		CHKiRet(computeAuthHeader((char*) pData-&gt;user, (char*) pData-&gt;pwd, &amp;pData-&gt;authBuf));

	CODE_STD_STRING_REQUESTnewActInst(1)
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)strdup((pData-&gt;tplName == NULL) ?
		" StdClickHouseFmt" : (char*)pData-&gt;tplName), OMSR_RQD_TPL_OPT_SQL));

	if(server != NULL) {
		CHKiRet(computeBaseUrl((const char*)server, pData-&gt;port, pData-&gt;useHttps, pData));
	} else {
		LogMsg(0, RS_RET_OK, LOG_WARNING,
			"omclickhouse: No servers specified, using localhost");
		CHKiRet(computeBaseUrl("localhost", pData-&gt;port, pData-&gt;useHttps,
					pData));
<a name="4"></a>	}

	/* node created, let's add to list of instance configs for the module */
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if(loadModConf-&gt;tail == NULL) {
		loadModConf-&gt;tail = loadModConf-&gt;root = pData;
	} else {
		loadModConf-&gt;tail-&gt;next = pData;
		loadModConf-&gt;tail = pData;
	}

CODE_STD_FINALIZERnewActInst
	free(server);
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst


BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;</b></font>
	pModConf-&gt;pConf = pConf;
	pModConf-&gt;root = pModConf-&gt;tail = NULL;
ENDbeginCnfLoad


BEGINendCnfLoad
CODESTARTendCnfLoad
	loadModConf = NULL; /* done loading */
ENDendCnfLoad


BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf


BEGINactivateCnf
CODESTARTactivateCnf
ENDactivateCnf


BEGINfreeCnf
CODESTARTfreeCnf
ENDfreeCnf


BEGINdoHUP
CODESTARTdoHUP
	if(pData-&gt;fdErrFile != -1) {
		close(pData-&gt;fdErrFile);
		pData-&gt;fdErrFile = -1;
	}
ENDdoHUP


BEGINmodExit
CODESTARTmodExit
	curl_global_cleanup();
	statsobj.Destruct(&amp;indexStats);
	objRelease(statsobj, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
ENDmodExit

NO_LEGACY_CONF_parseSelectorAct

BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_doHUP
CODEqueryEtryPt_TXIF_OMOD_QUERIES /* we support the transactional interface! */
CODEqueryEtryPt_STD_CONF2_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(statsobj, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));

	if (curl_global_init(CURL_GLOBAL_ALL) != 0) {
		LogError(0, RS_RET_OBJ_CREATION_FAILED, "CURL fail. -indexing disabled");
		ABORT_FINALIZE(RS_RET_OBJ_CREATION_FAILED);
	}

	/* support statistics gathering */
	CHKiRet(statsobj.Construct(&amp;indexStats));
	CHKiRet(statsobj.SetName(indexStats, (uchar *)"omclickhouse"));
	CHKiRet(statsobj.SetOrigin(indexStats, (uchar *)"omclickhouse"));
	STATSCOUNTER_INIT(indexSubmit, mutIndexSubmit);
	CHKiRet(statsobj.AddCounter(indexStats, (uchar *)"submitted",
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;indexSubmit));
	STATSCOUNTER_INIT(indexHTTPFail, mutIndexHTTPFail);
	CHKiRet(statsobj.AddCounter(indexStats, (uchar *)"failed.http",
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;indexHTTPFail));
	STATSCOUNTER_INIT(indexHTTPReqFail, mutIndexHTTPReqFail);
	CHKiRet(statsobj.AddCounter(indexStats, (uchar *)"failed.httprequests",
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;indexHTTPReqFail));
	STATSCOUNTER_INIT(indexFail, mutIndexFail);
	CHKiRet(statsobj.AddCounter(indexStats, (uchar *)"failed.clickhouse",
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;indexFail));
	STATSCOUNTER_INIT(indexSuccess, mutIndexSuccess);
	CHKiRet(statsobj.AddCounter(indexStats, (uchar *)"response.success",
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;indexSuccess));
	CHKiRet(statsobj.ConstructFinalize(indexStats));

ENDmodInit

/* vi:set ai:
 */
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>imhttp.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* imhttp.c
 * This is an input module for receiving http input.
 *
 * This file is contribution of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;ctype.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include "rsyslog.h"
#include "cfsysline.h"		/* access to config file objects */
#include "module-template.h"
#include "ruleset.h"
#include "unicode-helper.h"
#include "rsyslog.h"
#include "errmsg.h"
#include "statsobj.h"
#include "ratelimit.h"
#include "dirty.h"

#include "civetweb.h"
#include &lt;apr_base64.h&gt;
#include &lt;apr_md5.h&gt;

MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("imhttp")

/* static data */
DEF_OMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(prop)
DEFobjCurrIf(ruleset)
DEFobjCurrIf(statsobj)

#define CIVETWEB_OPTION_NAME_PORTS         "listening_ports"
#define CIVETWEB_OPTION_NAME_DOCUMENT_ROOT "document_root"
#define MAX_READ_BUFFER_SIZE  16384
#define INIT_SCRATCH_BUF_SIZE 4096
/* General purpose buffer size. */
#define IMHTTP_MAX_BUF_LEN (8192)

struct option {
	const char *name;
	const char *val;
};

struct auth_s {
	char workbuf[IMHTTP_MAX_BUF_LEN];
	char* pworkbuf;
	size_t workbuf_len;
	char* pszUser;
	char* pszPasswd;
};

struct data_parse_s {
	sbool  content_compressed;
	sbool bzInitDone; /* did we do an init of zstrm already? */
	z_stream zstrm;	/* zip stream to use for tcp compression */
	// Currently only used for octet specific parsing
	enum {
		eAtStrtFram,
		eInOctetCnt,
		eInMsg,
	} inputState;
	size_t iOctetsRemain;	/* Number of Octets remaining in message */
	enum {
		TCP_FRAMING_OCTET_STUFFING,
		TCP_FRAMING_OCTET_COUNTING
	} framingMode;
};

struct modConfData_s {
	rsconf_t *pConf;  /* our overall config object */
	instanceConf_t *root, *tail;
	struct option ports;
	struct option docroot;
	struct option *options;
	int nOptions;
};

struct instanceConf_s {
	struct instanceConf_s *next;
	uchar *pszBindRuleset;    /* name of ruleset to bind to */
	uchar *pszEndpoint;       /* endpoint to configure */
	uchar *pszBasicAuthFile;       /* file containing basic auth users/pass */
	ruleset_t *pBindRuleset;  /* ruleset to bind listener to (use system default if unspecified) */
	ratelimit_t *ratelimiter;
	unsigned int ratelimitInterval;
	unsigned int ratelimitBurst;
	uchar *pszInputName;	  /* value for inputname property, NULL is OK and handled by core engine */
	prop_t *pInputName;
	sbool flowControl;
	sbool bDisableLFDelim;
	sbool bSuppOctetFram;
	sbool bAddMetadata;
};

struct conn_wrkr_s {
	struct data_parse_s parseState;
	uchar* pMsg;						/* msg scratch buffer */
	size_t iMsg;						/* index of next char to store in msg */
	uchar zipBuf[64*1024];
	multi_submit_t multiSub;
	smsg_t *pMsgs[CONF_NUM_MULTISUB];
	char *pReadBuf;
	size_t readBufSize;
	prop_t *propRemoteAddr;
	const struct mg_request_info *pri; /* do not free me - used to hold a reference only */
	char *pScratchBuf;
	size_t scratchBufSize;
};

static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current load process */
static prop_t *pInputName = NULL;

//static size_t s_iMaxLine = 16; /* get maximum size we currently support */
static size_t s_iMaxLine = 16384; /* get maximum size we currently support */

/* module-global parameters */
static struct cnfparamdescr modpdescr[] = {
	{ "ports", eCmdHdlrString, 0 },
	{ "documentroot", eCmdHdlrString, 0 },
	{ "liboptions", eCmdHdlrArray, 0 },
};

static struct cnfparamblk modpblk = {
	CNFPARAMBLK_VERSION,
	sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	modpdescr
<a name="0"></a>};

static struct cnfparamdescr inppdescr[] = {
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "endpoint", eCmdHdlrString, 0},
	{ "basicauthfile", eCmdHdlrString, 0},
	{ "ruleset", eCmdHdlrString, 0 },
	{ "flowcontrol", eCmdHdlrBinary, 0 },
	{ "disablelfdelimiter", eCmdHdlrBinary, 0 },
	{ "supportoctetcountedframing", eCmdHdlrBinary, 0 },
	{ "name", eCmdHdlrString, 0 },
	{ "ratelimit.interval", eCmdHdlrInt, 0 },
	{ "ratelimit.burst", eCmdHdlrInt, 0 },
	{ "addmetadata", eCmdHdlrBinary, 0 }
};

#include "im-helper.h" /* must be included AFTER the type definitions! */

static struct cnfparamblk inppblk = {
	CNFPARAMBLK_VERSION,
	sizeof(inppdescr)/sizeof(struct cnfparamdescr),
	inppdescr
};

static struct {</b></font>
	statsobj_t *stats;
	STATSCOUNTER_DEF(ctrSubmitted, mutCtrSubmitted)
	STATSCOUNTER_DEF(ctrFailed, mutCtrFailed);
	STATSCOUNTER_DEF(ctrDiscarded, mutCtrDiscarded);
} statsCounter;

#include "im-helper.h" /* must be included AFTER the type definitions! */

#define min(a, b) \
	({ __typeof__ (a) _a = (a); \
	__typeof__ (b) _b = (b); \
	_a &lt; _b ? _a : _b; })

#define	EXIT_FAILURE	1
#define	EXIT_SUCCESS	0
#define EXIT_URI "/exit"
volatile int exitNow = 0;

struct mg_callbacks callbacks;

typedef struct httpserv_s {
	struct mg_context *ctx;
	struct mg_callbacks callbacks;
	const char **civetweb_options;
	size_t civetweb_options_count;
} httpserv_t;

static httpserv_t *s_httpserv;

/* FORWARD DECLARATIONS */
static rsRetVal processData(const instanceConf_t *const inst,
	struct conn_wrkr_s *connWrkr, const char* buf, size_t len);

static rsRetVal
createInstance(instanceConf_t **pinst)
{
<a name="3"></a>	instanceConf_t *inst;
	DEFiRet;
	CHKmalloc(inst = calloc(1, sizeof(instanceConf_t)));
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	inst-&gt;next = NULL;
	inst-&gt;pszBindRuleset = NULL;
	inst-&gt;pBindRuleset = NULL;
	inst-&gt;pszEndpoint = NULL;
	inst-&gt;pszBasicAuthFile = NULL;
	inst-&gt;ratelimiter = NULL;
	inst-&gt;pszInputName = NULL;</b></font>
	inst-&gt;pInputName = NULL;
	inst-&gt;ratelimitBurst = 10000; /* arbitrary high limit */
	inst-&gt;ratelimitInterval = 0; /* off */
	inst-&gt;flowControl = 1;
	inst-&gt;bDisableLFDelim = 0;
	inst-&gt;bSuppOctetFram = 0;
	inst-&gt;bAddMetadata = 0;
<a name="4"></a>	// construct statsobj

	/* node created, let's add to config */
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(loadModConf-&gt;tail == NULL) {
		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
	} else {
		loadModConf-&gt;tail-&gt;next = inst;
		loadModConf-&gt;tail = inst;
	}

	*pinst = inst;</b></font>
finalize_it:
	RETiRet;
}

static rsRetVal
processCivetwebOptions(char *const param,
	const char **const name,
	const char **const paramval)
{
	DEFiRet;
	char *val = strstr(param, "=");
	if(val == NULL) {
		LogError(0, RS_RET_PARAM_ERROR, "missing equal sign in "
				"parameter '%s'", param);
		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
	}
	*val = '\0'; /* terminates name */
	++val; /* now points to begin of value */
	CHKmalloc(*name = strdup(param));
	CHKmalloc(*paramval = strdup(val));

finalize_it:
	RETiRet;
}

static sbool valid_civetweb_option(const struct mg_option *valid_opts, const char* option)
{
	const struct mg_option *pvalid_opts = valid_opts;
	for (; pvalid_opts != NULL &amp;&amp; pvalid_opts-&gt;name != NULL; pvalid_opts++) {
		if (strcmp(pvalid_opts-&gt;name, option) == 0) {
			return TRUE;
		}
	}
	return FALSE;
}

#if 0
static int
log_message(__attribute__((unused)) const struct mg_connection *conn, const char *message)
{
	puts(message);
	return 1;
}
#endif
/*
	*   thread_type:
	*     0 indicates the master thread
	*     1 indicates a worker thread handling client connections
	*     2 indicates an internal helper thread (timer thread)
*/
static void*
init_thread(__attribute__((unused)) const struct mg_context *ctx, int thread_type)
{
	DEFiRet;
	struct conn_wrkr_s *data = NULL;
	if (thread_type == 1) {
		CHKmalloc(data = calloc(1, sizeof(struct conn_wrkr_s)));
		data-&gt;pMsg = NULL;
		data-&gt;iMsg = 0;
		data-&gt;parseState.bzInitDone = 0;
		data-&gt;parseState.content_compressed = 0;
		data-&gt;parseState.inputState = eAtStrtFram;
		data-&gt;parseState.iOctetsRemain = 0;
		data-&gt;multiSub.maxElem = CONF_NUM_MULTISUB;
		data-&gt;multiSub.ppMsgs = data-&gt;pMsgs;
		data-&gt;multiSub.nElem = 0;
		data-&gt;pReadBuf = malloc(MAX_READ_BUFFER_SIZE);
		data-&gt;readBufSize = MAX_READ_BUFFER_SIZE;

		data-&gt;parseState.bzInitDone = 0;
		data-&gt;parseState.content_compressed = 0;
		data-&gt;parseState.inputState = eAtStrtFram;
		data-&gt;parseState.iOctetsRemain = 0;

		CHKmalloc(data-&gt;pMsg = calloc(1, 1 + s_iMaxLine));
		data-&gt;iMsg = 0;
		data-&gt;propRemoteAddr = NULL;
		data-&gt;pScratchBuf = NULL;
		data-&gt;scratchBufSize = 0;
	}

finalize_it:
	if (iRet != RS_RET_OK) {
		free(data);
		return NULL;
	}
	return data;
}

static void
exit_thread(__attribute__((unused)) const struct mg_context *ctx,
	__attribute__((unused)) int thread_type, void *thread_pointer)
{
	if (thread_type == 1) {
		struct conn_wrkr_s *data = (struct conn_wrkr_s *) thread_pointer;
		if (data-&gt;propRemoteAddr) {
			prop.Destruct(&amp;data-&gt;propRemoteAddr);
		}
		if (data-&gt;scratchBufSize) {
			free(data-&gt;pScratchBuf);
		}
		free(data-&gt;pReadBuf);
		free(data-&gt;pMsg);
		free(data);
	}
}

static rsRetVal
msgAddMetadataFromHttpHeader(smsg_t *const __restrict__ pMsg, struct conn_wrkr_s *connWrkr)
{
	struct json_object *json = NULL;
	DEFiRet;
	const struct mg_request_info *ri = connWrkr-&gt;pri;
	#define MAX_HTTP_HEADERS 64	/* hard limit */
	int count = min(ri-&gt;num_headers, MAX_HTTP_HEADERS);

	CHKmalloc(json = json_object_new_object());
	for (int i = 0 ; i &lt; count ; i++ ) {
		struct json_object *const jval = json_object_new_string(ri-&gt;http_headers[i].value);
		CHKmalloc(jval);
		/* truncate header names bigger than INIT_SCRATCH_BUF_SIZE */
		strncpy(connWrkr-&gt;pScratchBuf, ri-&gt;http_headers[i].name, connWrkr-&gt;scratchBufSize - 1);
		/* make header lowercase */
		char* pname = connWrkr-&gt;pScratchBuf;
		while (pname &amp;&amp; *pname != '\0') {
			*pname = tolower(*pname);
			pname++;
		}
		json_object_object_add(json, (const char *const)connWrkr-&gt;pScratchBuf, jval);
	}
	CHKiRet(msgAddJSON(pMsg, (uchar*)"!metadata!httpheaders", json, 0, 0));

finalize_it:
	if (iRet != RS_RET_OK &amp;&amp; json) {
		json_object_put(json);
	}
	RETiRet;
}

static rsRetVal
msgAddMetadataFromHttpQueryParams(smsg_t *const __restrict__ pMsg, struct conn_wrkr_s *connWrkr)
{
	struct json_object *json = NULL;
	DEFiRet;
	const struct mg_request_info *ri = connWrkr-&gt;pri;

	if (ri &amp;&amp; ri-&gt;query_string) {
		strncpy(connWrkr-&gt;pScratchBuf, ri-&gt;query_string, connWrkr-&gt;scratchBufSize - 1);
		char *pquery_str = connWrkr-&gt;pScratchBuf;
		if (pquery_str) {
			CHKmalloc(json = json_object_new_object());

			char* saveptr = NULL;
			char *kv_pair = strtok_r(pquery_str, "&amp;;", &amp;saveptr);

			for ( ; kv_pair != NULL; kv_pair = strtok_r(NULL, "&amp;;", &amp;saveptr)) {
				char *saveptr2 = NULL;
				char *key = strtok_r(kv_pair, "=", &amp;saveptr2);
				if (key) {
					char *value = strtok_r(NULL, "=", &amp;saveptr2);
					struct json_object *const jval = json_object_new_string(value);
					CHKmalloc(jval);
					json_object_object_add(json, (const char *)key, jval);
				}
			}
			CHKiRet(msgAddJSON(pMsg, (uchar*)"!metadata!queryparams", json, 0, 0));
		}
	}
finalize_it:
	if (iRet != RS_RET_OK &amp;&amp; json) {
		json_object_put(json);
	}
	RETiRet;
}

static rsRetVal
doSubmitMsg(const instanceConf_t *const __restrict__ inst,
	struct conn_wrkr_s *connWrkr, const uchar* msg, size_t len)
{
	smsg_t *pMsg;
	DEFiRet;

	assert(len &lt;= s_iMaxLine);
	if (len == 0) {
		DBGPRINTF("discarding zero-sized message\n");
		FINALIZE;
	}

	CHKiRet(msgConstruct(&amp;pMsg));
	MsgSetFlowControlType(pMsg, inst-&gt;flowControl
			            ? eFLOWCTL_LIGHT_DELAY : eFLOWCTL_NO_DELAY);
	if (inst-&gt;pInputName) {
		MsgSetInputName(pMsg, inst-&gt;pInputName);
	} else {
		MsgSetInputName(pMsg, pInputName);
	}
	MsgSetRawMsg(pMsg, (const char*)msg, len);
	MsgSetMSGoffs(pMsg, 0);	/* we do not have a header... */
	if (connWrkr-&gt;propRemoteAddr) {
		MsgSetRcvFromIP(pMsg, connWrkr-&gt;propRemoteAddr);
	}
	if (inst) {
		MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
	}
	// TODO: make these flags configurable.
	pMsg-&gt;msgFlags = NEEDS_PARSING | PARSE_HOSTNAME;

	if (inst-&gt;bAddMetadata) {
		CHKiRet(msgAddMetadataFromHttpHeader(pMsg, connWrkr));
		CHKiRet(msgAddMetadataFromHttpQueryParams(pMsg, connWrkr));
	}

	ratelimitAddMsg(inst-&gt;ratelimiter, &amp;connWrkr-&gt;multiSub, pMsg);
	STATSCOUNTER_INC(statsCounter.ctrSubmitted, statsCounter.mutCtrSubmitted);
finalize_it:
	connWrkr-&gt;iMsg = 0;
	if (iRet != RS_RET_OK) {
		STATSCOUNTER_INC(statsCounter.ctrDiscarded, statsCounter.mutCtrDiscarded);
	}
	RETiRet;
}


static rsRetVal
processOctetMsgLen(const instanceConf_t *const inst, struct conn_wrkr_s *connWrkr, char ch)
{
	DEFiRet;
	if (connWrkr-&gt;parseState.inputState == eAtStrtFram) {
		if (inst-&gt;bSuppOctetFram &amp;&amp; isdigit(ch)) {
			connWrkr-&gt;parseState.inputState = eInOctetCnt;
			connWrkr-&gt;parseState.iOctetsRemain = 0;
			connWrkr-&gt;parseState.framingMode = TCP_FRAMING_OCTET_COUNTING;
		} else {
			connWrkr-&gt;parseState.inputState = eInMsg;
			connWrkr-&gt;parseState.framingMode = TCP_FRAMING_OCTET_STUFFING;
		}
	}

	// parsing character.
	if (connWrkr-&gt;parseState.inputState == eInOctetCnt) {
		if (isdigit(ch)) {
			if (connWrkr-&gt;parseState.iOctetsRemain &lt;= 200000000) {
				connWrkr-&gt;parseState.iOctetsRemain = connWrkr-&gt;parseState.iOctetsRemain * 10 + ch - '0';
			}
			// temporarily save this character into the message buffer
			if(connWrkr-&gt;iMsg + 1 &lt; s_iMaxLine) {
				connWrkr-&gt;pMsg[connWrkr-&gt;iMsg++] = ch;
			}
		} else {
			const char *remoteAddr = "";
			if (connWrkr-&gt;propRemoteAddr) {
				remoteAddr = (const char *)propGetSzStr(connWrkr-&gt;propRemoteAddr);
			}

			/* handle space delimeter */
			if (ch != ' ') {
				LogError(0, NO_ERRCODE, "Framing Error in received TCP message "
					"from peer: (ip) %s: to input: %s, delimiter is not "
					"SP but has ASCII value %d.",
					remoteAddr, inst-&gt;pszInputName, ch);
			}

			if (connWrkr-&gt;parseState.iOctetsRemain &lt; 1) {
				LogError(0, NO_ERRCODE, "Framing Error in received TCP message"
					" from peer: (ip) %s: delimiter is not "
					"SP but has ASCII value %d.",
					remoteAddr, ch);
			} else if (connWrkr-&gt;parseState.iOctetsRemain &gt; s_iMaxLine) {
				DBGPRINTF("truncating message with %lu octets - max msg size is %lu\n",
									connWrkr-&gt;parseState.iOctetsRemain, s_iMaxLine);
				LogError(0, NO_ERRCODE, "received oversize message from peer: "
					"(hostname) (ip) %s: size is %lu bytes, max msg "
					"size is %lu, truncating...",
					remoteAddr, connWrkr-&gt;parseState.iOctetsRemain, s_iMaxLine);
			}
			connWrkr-&gt;parseState.inputState = eInMsg;
		}
		/* reset msg len for actual message processing */
		connWrkr-&gt;iMsg = 0;
		/* retrieve next character */
	}
	RETiRet;
}

static rsRetVal
processOctetCounting(const instanceConf_t *const inst,
	struct conn_wrkr_s *connWrkr, const char* buf, size_t len)
{
	DEFiRet;
	const uchar* pbuf = (const uchar*)buf;
	const uchar* pbufLast = pbuf + len;

	while (pbuf &lt; pbufLast) {
		char ch = *pbuf;

		if (connWrkr-&gt;parseState.inputState == eAtStrtFram || connWrkr-&gt;parseState.inputState == eInOctetCnt) {
			processOctetMsgLen(inst, connWrkr, ch);
			if (connWrkr-&gt;parseState.framingMode == TCP_FRAMING_OCTET_COUNTING) {
				pbuf++;
			}
		} else if (connWrkr-&gt;parseState.inputState == eInMsg) {
			if (connWrkr-&gt;parseState.framingMode == TCP_FRAMING_OCTET_STUFFING) {
				if (connWrkr-&gt;iMsg &lt; s_iMaxLine) {
					if (ch == '\n') {
						doSubmitMsg(inst, connWrkr, connWrkr-&gt;pMsg, connWrkr-&gt;iMsg);
						connWrkr-&gt;parseState.inputState = eAtStrtFram;
					} else {
						connWrkr-&gt;pMsg[connWrkr-&gt;iMsg++] = ch;
					}
				} else {
					doSubmitMsg(inst, connWrkr, connWrkr-&gt;pMsg, connWrkr-&gt;iMsg);
					connWrkr-&gt;parseState.inputState = eAtStrtFram;
				}
				pbuf++;
			} else {
				assert (connWrkr-&gt;parseState.framingMode == TCP_FRAMING_OCTET_COUNTING);
				/* parsing payload */
				size_t remainingBytes = pbufLast - pbuf;
				// figure out how much is in block
				size_t count = min (connWrkr-&gt;parseState.iOctetsRemain, remainingBytes);
				if (connWrkr-&gt;iMsg + count &gt;= s_iMaxLine) {
					count = s_iMaxLine - connWrkr-&gt;iMsg;
				}

				// just copy the bytes
				if (count) {
					memcpy(connWrkr-&gt;pMsg + connWrkr-&gt;iMsg, pbuf, count);
					pbuf += count;
					connWrkr-&gt;iMsg += count;
					connWrkr-&gt;parseState.iOctetsRemain -= count;
				}

				if (connWrkr-&gt;parseState.iOctetsRemain == 0) {
					doSubmitMsg(inst, connWrkr, connWrkr-&gt;pMsg, connWrkr-&gt;iMsg);
					connWrkr-&gt;parseState.inputState = eAtStrtFram;
				}
			}
		} else {
			// unexpected
			assert(0);
			break;
		}
	}
	RETiRet;
}

static rsRetVal
processDisableLF(const instanceConf_t *const inst,
	struct conn_wrkr_s *connWrkr, const char* buf, size_t len)
{
	DEFiRet;
	const uchar *pbuf = (const uchar*)buf;
	size_t remainingBytes = len;
	const uchar* pbufLast = pbuf + len;

	while (pbuf &lt; pbufLast) {
		size_t count = 0;
		if (connWrkr-&gt;iMsg + remainingBytes &gt;= s_iMaxLine) {
			count = s_iMaxLine - connWrkr-&gt;iMsg;
		} else {
			count = remainingBytes;
		}

		if (count) {
			memcpy(connWrkr-&gt;pMsg + connWrkr-&gt;iMsg, pbuf, count);
			pbuf += count;
			connWrkr-&gt;iMsg += count;
			remainingBytes -= count;
		}
		doSubmitMsg(inst, connWrkr, connWrkr-&gt;pMsg, connWrkr-&gt;iMsg);
	}
	RETiRet;
}

static rsRetVal
processDataUncompressed(const instanceConf_t *const inst,
	struct conn_wrkr_s *connWrkr, const char* buf, size_t len)
{
	const uchar *pbuf = (const uchar*)buf;
	DEFiRet;

	if (inst-&gt;bDisableLFDelim) {
		/* do block processing */
		iRet = processDisableLF(inst, connWrkr, buf, len);
	} else if (inst-&gt;bSuppOctetFram) {
		iRet = processOctetCounting(inst, connWrkr, buf, len);
	} else {
		const uchar* pbufLast = pbuf + len;
		while (pbuf &lt; pbufLast) {
			char ch = *pbuf;
			if (connWrkr-&gt;iMsg &lt; s_iMaxLine) {
				if (ch == '\n') {
					doSubmitMsg(inst, connWrkr, connWrkr-&gt;pMsg, connWrkr-&gt;iMsg);
				} else {
					connWrkr-&gt;pMsg[connWrkr-&gt;iMsg++] = ch;
				}
			} else {
				doSubmitMsg(inst, connWrkr, connWrkr-&gt;pMsg, connWrkr-&gt;iMsg);
			}
			pbuf++;
		}
	}
	RETiRet;
}

static rsRetVal
processDataCompressed(const instanceConf_t *const inst,
	struct conn_wrkr_s *connWrkr, const char* buf, size_t len)
{
	DEFiRet;

	if (!connWrkr-&gt;parseState.bzInitDone) {
		/* allocate deflate state */
		connWrkr-&gt;parseState.zstrm.zalloc = Z_NULL;
		connWrkr-&gt;parseState.zstrm.zfree = Z_NULL;
		connWrkr-&gt;parseState.zstrm.opaque = Z_NULL;
		int rc = inflateInit2(&amp;connWrkr-&gt;parseState.zstrm, (MAX_WBITS | 16));
		if (rc != Z_OK) {
			dbgprintf("imhttp: error %d returned from zlib/inflateInit()\n", rc);
			ABORT_FINALIZE(RS_RET_ZLIB_ERR);
		}
		connWrkr-&gt;parseState.bzInitDone = 1;
	}

	connWrkr-&gt;parseState.zstrm.next_in = (Bytef*) buf;
	connWrkr-&gt;parseState.zstrm.avail_in = len;
	/* run inflate() on buffer until everything has been uncompressed */
	int outtotal = 0;
	do {
		int zRet = 0;
		int outavail = 0;
		dbgprintf("imhttp: in inflate() loop, avail_in %d, total_in %ld\n",
				connWrkr-&gt;parseState.zstrm.avail_in, connWrkr-&gt;parseState.zstrm.total_in);

		connWrkr-&gt;parseState.zstrm.avail_out = sizeof(connWrkr-&gt;zipBuf);
		connWrkr-&gt;parseState.zstrm.next_out = connWrkr-&gt;zipBuf;
		zRet = inflate(&amp;connWrkr-&gt;parseState.zstrm, Z_SYNC_FLUSH);
		dbgprintf("imhttp: inflate(), ret: %d, avail_out: %d\n", zRet, connWrkr-&gt;parseState.zstrm.avail_out);
		outavail = sizeof(connWrkr-&gt;zipBuf) - connWrkr-&gt;parseState.zstrm.avail_out;
		if (outavail != 0) {
			outtotal += outavail;
			CHKiRet(processDataUncompressed(inst, connWrkr, (const char*)connWrkr-&gt;zipBuf, outavail));
		}
	} while (connWrkr-&gt;parseState.zstrm.avail_out == 0);

	dbgprintf("imhttp: processDataCompressed complete, sizes: in %lld, out %llu\n", (long long) len,
		(long long unsigned) outtotal);

finalize_it:
	RETiRet;
}

static rsRetVal
processData(const instanceConf_t *const inst,
	struct conn_wrkr_s *connWrkr, const char* buf, size_t len)
{
	DEFiRet;

	//inst-&gt;bDisableLFDelim = 0;
	if (connWrkr-&gt;parseState.content_compressed) {
		iRet = processDataCompressed(inst, connWrkr, buf, len);
	} else {
		iRet = processDataUncompressed(inst, connWrkr, buf, len);
	}

	RETiRet;
}

/* Return 1 on success. Always initializes the auth structure. */
static int
parse_auth_header(struct mg_connection *conn, struct auth_s *auth)
{
	if (!auth || !conn) {
		return 0;
	}

	const char *auth_header = NULL;
	if (((auth_header = mg_get_header(conn, "Authorization")) == NULL) ||
			strncasecmp(auth_header, "Basic ", 6) != 0) {
		return 0;
	}

	/* Parse authorization header */
	const char* src = auth_header + 6;
	size_t len = apr_base64_decode_len((const char*)src);
	auth-&gt;pworkbuf = auth-&gt;workbuf;
	if (len &gt; sizeof(auth-&gt;workbuf)) {
		auth-&gt;pworkbuf = calloc(0, len);
		auth-&gt;workbuf_len = len;
	}
	len = apr_base64_decode(auth-&gt;pworkbuf, src);
	if (len == 0) {
		return 0;
	}

	char *passwd = NULL, *saveptr = NULL;
	char *user = strtok_r(auth-&gt;pworkbuf, ":", &amp;saveptr);
	if (user) {
		passwd = strtok_r(NULL, ":", &amp;saveptr);
	}

	auth-&gt;pszUser = user;
	auth-&gt;pszPasswd = passwd;

	return 1;
}

static int
read_auth_file(FILE* filep, struct auth_s *auth)
{
	if (!filep) {
		return 0;
	}
	char workbuf[IMHTTP_MAX_BUF_LEN];
	size_t l = 0;
	char* user;
	char* passwd;

	while (fgets(workbuf, sizeof(workbuf), filep)) {
		l = strnlen(workbuf, sizeof(workbuf));
		while (l &gt; 0) {
			if (isspace(workbuf[l-1]) || iscntrl(workbuf[l-1])) {
				l--;
				workbuf[l] = 0;
			} else {
				break;
			}
		}

		if (l &lt; 1) {
			continue;
		}

		if (workbuf[0] == '#') {
			continue;
		}

		user = workbuf;
		passwd = strchr(workbuf, ':');
		if (!passwd) {
			continue;
		}
		*passwd = '\0';
		passwd++;

		if (!strcasecmp(auth-&gt;pszUser, user)) {
			return (apr_password_validate(auth-&gt;pszPasswd, passwd) == APR_SUCCESS);
		}
	}
	return 0;
}

/* Authorize against the opened passwords file. Return 1 if authorized. */
static int
authorize(struct mg_connection* conn, FILE* filep)
{
	if (!conn || !filep) {
		return 0;
	}

	struct auth_s auth = { .workbuf_len=0, .pworkbuf=NULL, .pszUser=NULL, .pszPasswd=NULL};
	if (!parse_auth_header(conn, &amp;auth)) {
		return 0;
	}

	/* validate against htpasswd file */
	return read_auth_file(filep, &amp;auth);
}

/* Provides Basic Authorization handling that validates against a 'htpasswd' file.
	see also: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization
*/
static int
basicAuthHandler(struct mg_connection *conn, void *cbdata)
{
	const instanceConf_t* inst = (const instanceConf_t*) cbdata;
	char errStr[512];
	FILE *fp = NULL;
	int ret = 1;

	if (!inst-&gt;pszBasicAuthFile) {
		mg_cry(conn, "warning: 'BasicAuthFile' not configured.\n");
		ret = 0;
		goto finalize;
	}

	fp = fopen((const char *)inst-&gt;pszBasicAuthFile, "r");
	if (fp == NULL) {
		if (strerror_r(errno, errStr, sizeof(errStr)) == 0) {
			mg_cry(conn,
					"error: 'BasicAuthFile' file '%s' could not be accessed: %s\n",
					inst-&gt;pszBasicAuthFile, errStr);
		} else {
			mg_cry(conn,
					"error: 'BasicAuthFile' file '%s' could not be accessed: %d\n",
					inst-&gt;pszBasicAuthFile, errno);
		}
		ret = 0;
		goto finalize;
	}

	ret = authorize(conn, fp);

finalize:
	if (!ret) {
		mg_send_http_error(conn, 401, "WWW-Authenticate: Basic realm=\"User Visible Realm\"\n");
	}
	if (fp ) {
		fclose(fp);
	}
	return ret;
}

/* cbdata should actually contain instance data and we can actually use this instance data
 * to hold reusable scratch buffer.
 */
static int
postHandler(struct mg_connection *conn, void *cbdata)
{
	int rc = 1;
	instanceConf_t* inst = (instanceConf_t*) cbdata;
	const struct mg_request_info *ri = mg_get_request_info(conn);
	struct conn_wrkr_s *connWrkr = mg_get_thread_pointer(conn);
	connWrkr-&gt;multiSub.nElem = 0;
	memset(&amp;connWrkr-&gt;parseState, 0, sizeof(connWrkr-&gt;parseState));
	connWrkr-&gt;pri = ri;

	if (inst-&gt;bAddMetadata &amp;&amp; connWrkr-&gt;scratchBufSize == 0) {
		connWrkr-&gt;pScratchBuf = calloc(1, INIT_SCRATCH_BUF_SIZE);
		if (!connWrkr-&gt;pScratchBuf) {
			mg_cry(conn, "%s() - could not alloc scratch buffer!\n", __FUNCTION__);
			rc = 500;
			FINALIZE;
		}
		connWrkr-&gt;scratchBufSize = INIT_SCRATCH_BUF_SIZE;
	}

	if (0 != strcmp(ri-&gt;request_method, "POST")) {
		/* Not a POST request */
		int ret = mg_get_request_link(conn, connWrkr-&gt;pReadBuf, connWrkr-&gt;readBufSize);
		mg_printf(conn,
		          "HTTP/1.1 405 Method Not Allowed\r\nConnection: close\r\n");
		mg_printf(conn, "Content-Type: text/plain\r\n\r\n");
		mg_printf(conn,
		          "%s method not allowed in the POST handler\n",
		          ri-&gt;request_method);
		if (ret &gt;= 0) {
			mg_printf(conn,
			          "use a web tool to send a POST request to %s\n",
			          connWrkr-&gt;pReadBuf);
		}
		STATSCOUNTER_INC(statsCounter.ctrFailed, statsCounter.mutCtrFailed);
		rc = 405;
		FINALIZE;
	}

	if (ri-&gt;remote_addr[0] != '\0') {
		size_t len = strnlen(ri-&gt;remote_addr, sizeof(ri-&gt;remote_addr));
		prop.CreateOrReuseStringProp(&amp;connWrkr-&gt;propRemoteAddr, (const uchar*)ri-&gt;remote_addr, len);
	}

	if (ri-&gt;content_length &gt;= 0) {
		/* We know the content length in advance */
		if (ri-&gt;content_length &gt; (long long) connWrkr-&gt;readBufSize) {
			connWrkr-&gt;pReadBuf = realloc(connWrkr-&gt;pReadBuf, ri-&gt;content_length+1);
			if (!connWrkr-&gt;pReadBuf) {
				mg_cry(conn, "%s() - realloc failed!\n", __FUNCTION__);
				FINALIZE;
			}
			connWrkr-&gt;readBufSize = ri-&gt;content_length+1;
		}
	} else {
		/* We must read until we find the end (chunked encoding
		 * or connection close), indicated my mg_read returning 0 */
	}

	if (ri-&gt;num_headers &gt; 0) {
		int i;
		for (i = 0; i &lt; ri-&gt;num_headers; i++) {
			if (!strcasecmp(ri-&gt;http_headers[i].name, "content-encoding") &amp;&amp;
					!strcasecmp(ri-&gt;http_headers[i].value, "gzip")) {
				connWrkr-&gt;parseState.content_compressed = 1;
			}
		}
	}

	while (1) {
		int count = mg_read(conn, connWrkr-&gt;pReadBuf, connWrkr-&gt;readBufSize);
		if (count &gt; 0) {
			processData(inst, connWrkr, (const char*)connWrkr-&gt;pReadBuf, count);
		} else {
			break;
		}
	}

	/* submit remainder */
	doSubmitMsg(inst, connWrkr, connWrkr-&gt;pMsg, connWrkr-&gt;iMsg);
	multiSubmitFlush(&amp;connWrkr-&gt;multiSub);

	mg_send_http_ok(conn, "text/plain", 0);
	rc = 200;

finalize_it:
	if (connWrkr-&gt;parseState.bzInitDone) {
		inflateEnd(&amp;connWrkr-&gt;parseState.zstrm);
	}
	/* reset */
	connWrkr-&gt;iMsg = 0;

	return rc;
}

static int runloop(void)
{
	dbgprintf("imhttp started.\n");

	/* Add handler for form data */
	for(instanceConf_t *inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		assert(inst-&gt;pszEndpoint);
		if (inst-&gt;pszEndpoint) {
			dbgprintf("setting request handler: '%s'\n", inst-&gt;pszEndpoint);
			mg_set_request_handler(s_httpserv-&gt;ctx, (char *)inst-&gt;pszEndpoint, postHandler, inst);
			if (inst-&gt;pszBasicAuthFile) {
				mg_set_auth_handler(s_httpserv-&gt;ctx, (char *)inst-&gt;pszEndpoint, basicAuthHandler, inst);
			}
		}
	}

	/* Wait until the server should be closed */
	while(glbl.GetGlobalInputTermState() == 0) {
		sleep(1);
	}
	return EXIT_SUCCESS;
}

BEGINnewInpInst
	struct cnfparamvals *pvals;
	instanceConf_t *inst;
	int i;
CODESTARTnewInpInst
	DBGPRINTF("newInpInst (imhttp)\n");
	pvals = nvlstGetParams(lst, &amp;inppblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS,
			        "imhttp: required parameter are missing\n");
<a name="2"></a>		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(Debug) {
		dbgprintf("input param blk in imtcp:\n");
		cnfparamsPrint(&amp;inppblk, pvals);
	}

	CHKiRet(createInstance(&amp;inst));

	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(inppblk.descr[i].name, "endpoint")) {
<a name="1"></a>			inst-&gt;pszEndpoint = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "basicauthfile")) {
			inst-&gt;pszBasicAuthFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "name")) {
			inst-&gt;pszInputName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "ratelimit.burst")) {
			inst-&gt;ratelimitBurst = (unsigned int) pvals[i].val.d.n;</b></font>
		} else if(!strcmp(inppblk.descr[i].name, "ratelimit.interval")) {
			inst-&gt;ratelimitInterval = (unsigned int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "flowcontrol")) {
			inst-&gt;flowControl = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "disablelfdelimiter")) {
			inst-&gt;bDisableLFDelim = (int) pvals[i].val.d.n;
		} else if (!strcmp(inppblk.descr[i].name, "supportoctetcountedframing")) {
			inst-&gt;bSuppOctetFram = (int) pvals[i].val.d.n;
		} else if (!strcmp(inppblk.descr[i].name, "addmetadata")) {
			inst-&gt;bAddMetadata = (int) pvals[i].val.d.n;
		} else {
			dbgprintf("imhttp: program error, non-handled "
			  "param '%s'\n", inppblk.descr[i].name);
		}
	}

	if (inst-&gt;pszInputName) {
		CHKiRet(prop.Construct(&amp;inst-&gt;pInputName));
		CHKiRet(prop.SetString(inst-&gt;pInputName, inst-&gt;pszInputName, ustrlen(inst-&gt;pszInputName)));
		CHKiRet(prop.ConstructFinalize(inst-&gt;pInputName));
	}
	CHKiRet(ratelimitNew(&amp;inst-&gt;ratelimiter, "imphttp", NULL));
	ratelimitSetLinuxLike(inst-&gt;ratelimiter, inst-&gt;ratelimitInterval, inst-&gt;ratelimitBurst);

finalize_it:
CODE_STD_FINALIZERnewInpInst
	cnfparamvalsDestruct(pvals, &amp;inppblk);
ENDnewInpInst


BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	loadModConf-&gt;ports.name = NULL;
	loadModConf-&gt;docroot.name = NULL;
	loadModConf-&gt;nOptions = 0;
	loadModConf-&gt;options = NULL;
ENDbeginCnfLoad


BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, "imhttp: error processing module "
				"config parameters [module(...)]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf("module (global) param blk for imhttp:\n");
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(int i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(modpblk.descr[i].name, "ports")) {
			assert(loadModConf-&gt;ports.name == NULL);
			assert(loadModConf-&gt;ports.val == NULL);
			loadModConf-&gt;ports.name = strdup(CIVETWEB_OPTION_NAME_PORTS);
			loadModConf-&gt;ports.val = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(modpblk.descr[i].name, "documentroot")) {
			assert(loadModConf-&gt;docroot.name == NULL);
			assert(loadModConf-&gt;docroot.val == NULL);
			loadModConf-&gt;docroot.name = strdup(CIVETWEB_OPTION_NAME_DOCUMENT_ROOT);
			loadModConf-&gt;docroot.val = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, "liboptions")) {
			loadModConf-&gt;nOptions = pvals[i].val.d.ar-&gt;nmemb;
			CHKmalloc(loadModConf-&gt;options = malloc(sizeof(struct option) *
			                                      pvals[i].val.d.ar-&gt;nmemb ));
			for(int j = 0 ; j &lt;  pvals[i].val.d.ar-&gt;nmemb ; ++j) {
				char *cstr = es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
				CHKiRet(processCivetwebOptions(cstr, &amp;loadModConf-&gt;options[j].name,
					&amp;loadModConf-&gt;options[j].val));
				free(cstr);
			}
		} else {
			dbgprintf("imhttp: program error, non-handled "
			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
		}
	}

finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf


BEGINendCnfLoad
CODESTARTendCnfLoad
	loadModConf = NULL; /* done loading */
ENDendCnfLoad

/* function to generate error message if framework does not find requested ruleset */
static inline void
std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
{
	LogError(0, NO_ERRCODE, "imhttp: ruleset '%s' for %s not found - "
			"using default ruleset instead", inst-&gt;pszBindRuleset,
			inst-&gt;pszEndpoint);
}

BEGINcheckCnf
	instanceConf_t *inst;
CODESTARTcheckCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		std_checkRuleset(pModConf, inst);
	}
	/* verify civetweb options are valid */
	const struct mg_option *valid_opts = mg_get_valid_options();
	for (int i = 0; i &lt; pModConf-&gt;nOptions; ++i) {
		if (!valid_civetweb_option(valid_opts, pModConf-&gt;options[i].name)) {
			LogError(0, RS_RET_CONF_PARSE_WARNING, "imhttp: module loaded, but "
			"invalid civetweb option found - imhttp may not receive connections.");
			iRet = RS_RET_CONF_PARSE_WARNING;
		}
	}
ENDcheckCnf


BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;

	if (!s_httpserv) {
		CHKmalloc(s_httpserv = calloc(1, sizeof(httpserv_t)));
	}
	/* options represents (key, value) so allocate 2x, and null terminated */
	size_t count = 1;
	if (runModConf-&gt;ports.val) {
		count += 2;
	}
	if (runModConf-&gt;docroot.val) {
		count += 2;
	}
	count += (2 * runModConf-&gt;nOptions);
	CHKmalloc(s_httpserv-&gt;civetweb_options = calloc(count, sizeof(*s_httpserv-&gt;civetweb_options)));

	const char **pcivetweb_options = s_httpserv-&gt;civetweb_options;
	if (runModConf-&gt;nOptions) {
		s_httpserv-&gt;civetweb_options_count = count;
		for (int i = 0; i &lt; runModConf-&gt;nOptions; ++i) {
			*pcivetweb_options = runModConf-&gt;options[i].name;
			pcivetweb_options++;
			*pcivetweb_options = runModConf-&gt;options[i].val;
			pcivetweb_options++;
		}
	}
	/* append port, docroot */
	if (runModConf-&gt;ports.val) {
		*pcivetweb_options = runModConf-&gt;ports.name;
		pcivetweb_options++;
		*pcivetweb_options = runModConf-&gt;ports.val;
		pcivetweb_options++;
	}
	if (runModConf-&gt;docroot.val) {
		*pcivetweb_options = runModConf-&gt;docroot.name;
		pcivetweb_options++;
		*pcivetweb_options = runModConf-&gt;docroot.val;
		pcivetweb_options++;
	}

	const char **option = s_httpserv-&gt;civetweb_options;
	for (; option &amp;&amp; *option != NULL; option++) {
		dbgprintf("imhttp: civetweb option: %s\n", *option);
	}

	CHKiRet(statsobj.Construct(&amp;statsCounter.stats));
	CHKiRet(statsobj.SetName(statsCounter.stats, UCHAR_CONSTANT("imhttp")));
	CHKiRet(statsobj.SetOrigin(statsCounter.stats, UCHAR_CONSTANT("imhttp")));
	STATSCOUNTER_INIT(statsCounter.ctrSubmitted, statsCounter.mutCtrSubmitted);
	CHKiRet(statsobj.AddCounter(statsCounter.stats, UCHAR_CONSTANT("submitted"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(statsCounter.ctrSubmitted)));

	STATSCOUNTER_INIT(statsCounter.ctrFailed, statsCounter.mutCtrFailed);
	CHKiRet(statsobj.AddCounter(statsCounter.stats, UCHAR_CONSTANT("failed"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(statsCounter.ctrFailed)));

	STATSCOUNTER_INIT(statsCounter.ctrDiscarded, statsCounter.mutCtrDiscarded);
	CHKiRet(statsobj.AddCounter(statsCounter.stats, UCHAR_CONSTANT("discarded"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(statsCounter.ctrDiscarded)));

	CHKiRet(statsobj.ConstructFinalize(statsCounter.stats));

	/* init civetweb libs and start server w/no input */
	mg_init_library(MG_FEATURES_TLS);
	memset(&amp;callbacks, 0, sizeof(callbacks));
	//callbacks.log_message = log_message;
	//callbacks.init_ssl = init_ssl;
	callbacks.init_thread = init_thread;
	callbacks.exit_thread = exit_thread;
	s_httpserv-&gt;ctx = mg_start(&amp;callbacks, NULL, s_httpserv-&gt;civetweb_options);
	/* Check return value: */
	if (s_httpserv-&gt;ctx == NULL) {
		LogError(0, RS_RET_INTERNAL_ERROR, "Cannot start CivetWeb - mg_start failed.\n");
		ABORT_FINALIZE(RS_RET_INTERNAL_ERROR);
	}

	finalize_it:
	if (iRet != RS_RET_OK) {
		free(s_httpserv);
		s_httpserv = NULL;
		LogError(0, NO_ERRCODE, "imhttp: error %d trying to activate configuration", iRet);
	}
	RETiRet;
ENDactivateCnf

BEGINfreeCnf
	instanceConf_t *inst, *del;
CODESTARTfreeCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
		if (inst-&gt;ratelimiter) {
			ratelimitDestruct(inst-&gt;ratelimiter);
		}
		if (inst-&gt;pInputName) {
			prop.Destruct(&amp;inst-&gt;pInputName);
		}
		free(inst-&gt;pszEndpoint);
		free(inst-&gt;pszBasicAuthFile);
		free(inst-&gt;pszBindRuleset);
		free(inst-&gt;pszInputName);

		del = inst;
		inst = inst-&gt;next;
		free(del);
	}

	for (int i = 0; i &lt; pModConf-&gt;nOptions; ++i) {
		free((void*) pModConf-&gt;options[i].name);
		free((void*) pModConf-&gt;options[i].val);
	}
	free(pModConf-&gt;options);

	free((void*)pModConf-&gt;ports.name);
	free((void*)pModConf-&gt;ports.val);
	free((void*)pModConf-&gt;docroot.name);
	free((void*)pModConf-&gt;docroot.val);

	if (statsCounter.stats) {
		statsobj.Destruct(&amp;statsCounter.stats);
	}
ENDfreeCnf


/* This function is called to gather input.
 */
BEGINrunInput
CODESTARTrunInput
	runloop();
ENDrunInput

/* initialize and return if will run or not */
BEGINwillRun
CODESTARTwillRun
ENDwillRun

BEGINafterRun
CODESTARTafterRun
	if (s_httpserv) {
		mg_stop(s_httpserv-&gt;ctx);
		mg_exit_library();
		free(s_httpserv-&gt;civetweb_options);
		free(s_httpserv);
	}
ENDafterRun


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	// if(eFeat == sFEATURENonCancelInputTermination)
	// 	iRet = RS_RET_OK;
ENDisCompatibleWithFeature


BEGINmodExit
CODESTARTmodExit
	if(pInputName != NULL) {
		prop.Destruct(&amp;pInputName);
	}

	/* release objects we used */
	objRelease(statsobj, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
ENDmodExit

BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));

	/* we need to create the inputName property (only once during our lifetime) */
	CHKiRet(prop.Construct(&amp;pInputName));
	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("imhttp"), sizeof("imhttp") - 1));
	CHKiRet(prop.ConstructFinalize(pInputName));
ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
