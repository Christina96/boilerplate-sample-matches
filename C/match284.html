<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for infc-request.c &amp; inf-text-default-insert-operation.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for infc-request.c &amp; inf-text-default-insert-operation.c
      </h3>
<h1 align="center">
        43.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>infc-request.c (57.575756%)<th>inf-text-default-insert-operation.c (34.969326%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(69-99)<td><a href="#" name="0">(61-91)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(113-138)<td><a href="#" name="1">(98-123)</a><td align="center"><font color="#ef0000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(176-224)<td><a href="#" name="2">(285-333)</a><td align="center"><font color="#df0000">14</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(35-59)<td><a href="#" name="3">(29-46)</a><td align="center"><font color="#bf0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>infc-request.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* infcinote - Collaborative notetaking application
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

/**
 * SECTION:infc-request
 * @title: InfcRequest
 * @short_description: Asynchronous request
 * @include: libinfinity/client/infc-request.h
 * @see_also: #InfcBrowser
 * @stability: Unstable
 *
 * #InfcRequest represents an asynchronous operation on the client side,
 * waiting for a reply from the server.
 */

<a name="3"></a>#include &lt;libinfinity/client/infc-request.h&gt;
#include &lt;libinfinity/common/inf-request.h&gt;

<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>typedef struct _InfcRequestPrivate InfcRequestPrivate;
struct _InfcRequestPrivate {
  gchar* type;
  guint seq;
  guint node_id;
  gboolean finished;
};

enum {
  PROP_0,

  PROP_TYPE,
  PROP_SEQ,
  PROP_PROGRESS,
  PROP_NODE_ID
};

#define INFC_REQUEST_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFC_TYPE_REQUEST, InfcRequestPrivate))

static void infc_request_request_iface_init(InfRequestInterface* iface);
G_DEFINE_TYPE_WITH_CODE(InfcRequest, infc_request, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfcRequest)
  G_IMPLEMENT_INTERFACE(INF_TYPE_REQUEST, infc_request_request_iface_init))

static void</b></font>
infc_request_init(InfcRequest* request)
{
  InfcRequestPrivate* priv;
  priv = INFC_REQUEST_PRIVATE(request);

  priv-&gt;type = NULL;
<a name="0"></a>  priv-&gt;seq = G_MAXUINT;
  priv-&gt;node_id = G_MAXUINT;
  priv-&gt;finished = FALSE;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

static void
infc_request_finalize(GObject* object)
{
  InfcRequest* request;
  InfcRequestPrivate* priv;

  request = INFC_REQUEST(object);
  priv = INFC_REQUEST_PRIVATE(request);

  g_free(priv-&gt;type);

  G_OBJECT_CLASS(infc_request_parent_class)-&gt;finalize(object);
}

static void
infc_request_set_property(GObject* object,
                          guint prop_id,
                          const GValue* value,
                          GParamSpec* pspec)
{
  InfcRequest* request;
  InfcRequestPrivate* priv;

  request = INFC_REQUEST(object);
  priv = INFC_REQUEST_PRIVATE(request);

  switch(prop_id)
  {
  case PROP_TYPE:</b></font>
    g_assert(priv-&gt;type == NULL); /* construct only */
    priv-&gt;type = g_value_dup_string(value);
    break;
  case PROP_SEQ:
    g_assert(priv-&gt;seq == G_MAXUINT); /* construct only */
    priv-&gt;seq = g_value_get_uint(value);
    break;
  case PROP_NODE_ID:
    g_assert(priv-&gt;node_id == G_MAXUINT); /* construct only */
    priv-&gt;node_id = g_value_get_uint(value);
<a name="1"></a>    break;
  case PROP_PROGRESS:
    /* read only */
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
infc_request_get_property(GObject* object,
                          guint prop_id,
                          GValue* value,
                          GParamSpec* pspec)
{
  InfcRequest* request;
  InfcRequestPrivate* priv;

  request = INFC_REQUEST(object);
  priv = INFC_REQUEST_PRIVATE(request);

  switch(prop_id)
  {
  case PROP_TYPE:
    g_value_set_string(value, priv-&gt;type);
    break;
  case PROP_SEQ:
    g_value_set_uint(value, priv-&gt;seq);
    break;</b></font>
  case PROP_NODE_ID:
    g_value_set_uint(value, priv-&gt;node_id);
    break;
  case PROP_PROGRESS:
    if(priv-&gt;finished)
      g_value_set_double(value, 1.0);
    else
      g_value_set_double(value, 0.0);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static gboolean
infc_request_is_local(InfRequest* request)
{
  InfcRequestPrivate* priv;
  priv = INFC_REQUEST_PRIVATE(request);

  if(priv-&gt;seq == G_MAXUINT)
    return FALSE;

  return TRUE;
}

static void
infc_request_finished(InfRequest* request,
                      const InfRequestResult* result,
                      const GError* error)
{
  InfcRequestPrivate* priv;
  priv = INFC_REQUEST_PRIVATE(request);
<a name="2"></a>
  priv-&gt;finished = TRUE;
  g_object_notify(G_OBJECT(request), "progress");
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

static void
infc_request_class_init(InfcRequestClass* request_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(request_class);

  object_class-&gt;finalize = infc_request_finalize;
  object_class-&gt;set_property = infc_request_set_property;
  object_class-&gt;get_property = infc_request_get_property;

  g_object_class_install_property(
    object_class,
    PROP_SEQ,
    g_param_spec_uint(
      "seq",
      "Seq",
      "The sequence number of the request",
      0,
      G_MAXUINT,
      0,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_NODE_ID,
    g_param_spec_uint(
      "node-id",
      "Node ID",
      "The ID of the node affected by this request",
      0,
      G_MAXUINT,
      G_MAXUINT,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_override_property(object_class, PROP_TYPE, "type");
  g_object_class_override_property(object_class, PROP_PROGRESS, "progress");
}

static void
infc_request_request_iface_init(InfRequestInterface* iface)
{
  iface-&gt;finished = infc_request_finished;
  iface-&gt;is_local = infc_request_is_local;</b></font>
}

/* vim:set et sw=2 ts=2: */
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-default-insert-operation.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include &lt;libinftext/inf-text-default-insert-operation.h&gt;
#include &lt;libinftext/inf-text-default-delete-operation.h&gt;
#include &lt;libinftext/inf-text-insert-operation.h&gt;
#include &lt;libinftext/inf-text-delete-operation.h&gt;
#include &lt;libinftext/inf-text-buffer.h&gt;

<a name="3"></a>#include &lt;libinfinity/adopted/inf-adopted-operation.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;

<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>typedef struct _InfTextDefaultInsertOperationPrivate
  InfTextDefaultInsertOperationPrivate;
struct _InfTextDefaultInsertOperationPrivate {
  guint position;
  InfTextChunk* chunk;
};

enum {
  PROP_0,

  PROP_POSITION,
  PROP_CHUNK
};

#define INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_TYPE_DEFAULT_INSERT_OPERATION, InfTextDefaultInsertOperationPrivate))

static void inf_text_default_insert_operation_operation_iface_init(InfAdoptedOperationInterface* iface);
static void inf_text_default_insert_operation_insert_operation_iface_init(InfTextInsertOperationInterface* iface);</b></font>
G_DEFINE_TYPE_WITH_CODE(InfTextDefaultInsertOperation, inf_text_default_insert_operation, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfTextDefaultInsertOperation)
  G_IMPLEMENT_INTERFACE(INF_ADOPTED_TYPE_OPERATION, inf_text_default_insert_operation_operation_iface_init)
  G_IMPLEMENT_INTERFACE(INF_TEXT_TYPE_INSERT_OPERATION, inf_text_default_insert_operation_insert_operation_iface_init))

static void
inf_text_default_insert_operation_init(
  InfTextDefaultInsertOperation* operation)
{
  InfTextDefaultInsertOperationPrivate* priv;
  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);
<a name="0"></a>
  priv-&gt;position = 0;
  priv-&gt;chunk = NULL;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

static void
inf_text_default_insert_operation_finalize(GObject* object)
{
  InfTextDefaultInsertOperation* operation;
  InfTextDefaultInsertOperationPrivate* priv;

  operation = INF_TEXT_DEFAULT_INSERT_OPERATION(object);
  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);

  inf_text_chunk_free(priv-&gt;chunk);

  G_OBJECT_CLASS(inf_text_default_insert_operation_parent_class)-&gt;finalize(object);
}

static void
inf_text_default_insert_operation_set_property(GObject* object,
                                               guint prop_id,
                                               const GValue* value,
                                               GParamSpec* pspec)
{
  InfTextDefaultInsertOperation* operation;
  InfTextDefaultInsertOperationPrivate* priv;

  operation = INF_TEXT_DEFAULT_INSERT_OPERATION(object);
  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);

  switch(prop_id)
  {
  case PROP_POSITION:</b></font>
    priv-&gt;position = g_value_get_uint(value);
    break;
  case PROP_CHUNK:
<a name="1"></a>    g_assert(priv-&gt;chunk == NULL); /* construct only */
    priv-&gt;chunk = (InfTextChunk*)g_value_dup_boxed(value);
    break;
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_text_default_insert_operation_get_property(GObject* object,
                                               guint prop_id,
                                               GValue* value,
                                               GParamSpec* pspec)
{
  InfTextDefaultInsertOperation* operation;
  InfTextDefaultInsertOperationPrivate* priv;

  operation = INF_TEXT_DEFAULT_INSERT_OPERATION(object);
  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);

  switch(prop_id)
  {
  case PROP_POSITION:
    g_value_set_uint(value, priv-&gt;position);
    break;
  case PROP_CHUNK:
    g_value_set_boxed(value, priv-&gt;chunk);
    break;</b></font>
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static gboolean
inf_text_default_insert_operation_need_concurrency_id(
  InfAdoptedOperation* operation,
  InfAdoptedOperation* against)
{
  g_assert(INF_TEXT_IS_DEFAULT_INSERT_OPERATION(operation));

  return inf_text_insert_operation_need_concurrency_id(
    INF_TEXT_INSERT_OPERATION(operation),
    against
  );
}

static InfAdoptedOperation*
inf_text_default_insert_operation_transform(InfAdoptedOperation* operation,
                                            InfAdoptedOperation* against,
                                            InfAdoptedOperation* op_lcs,
                                            InfAdoptedOperation* against_lcs,
                                            InfAdoptedConcurrencyId cid)
{
  g_assert(INF_TEXT_IS_DEFAULT_INSERT_OPERATION(operation));

  if(INF_TEXT_IS_INSERT_OPERATION(against))
  {
    g_assert(op_lcs == NULL ||
             INF_TEXT_IS_INSERT_OPERATION(op_lcs));
    g_assert(against_lcs == NULL ||
             INF_TEXT_IS_INSERT_OPERATION(against_lcs));

    return inf_text_insert_operation_transform_insert(
      INF_TEXT_INSERT_OPERATION(operation),
      INF_TEXT_INSERT_OPERATION(against),
      INF_TEXT_INSERT_OPERATION(op_lcs),
      INF_TEXT_INSERT_OPERATION(against_lcs),
      cid
    );
  }
  else if(INF_TEXT_IS_DELETE_OPERATION(against))
  {
    return inf_text_insert_operation_transform_delete(
      INF_TEXT_INSERT_OPERATION(operation),
      INF_TEXT_DELETE_OPERATION(against)
    );
  }
  else
  {
    g_assert_not_reached();
    return NULL;
  }
}

static InfAdoptedOperation*
inf_text_default_insert_operation_copy(InfAdoptedOperation* operation)
{
  InfTextDefaultInsertOperationPrivate* priv;
  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);

  return INF_ADOPTED_OPERATION(
    g_object_new(
      INF_TEXT_TYPE_DEFAULT_INSERT_OPERATION,
      "position", priv-&gt;position,
      "chunk", priv-&gt;chunk,
      NULL
    )
  );
}

static InfAdoptedOperationFlags
inf_text_default_insert_operation_get_flags(InfAdoptedOperation* operation)
{
  return INF_ADOPTED_OPERATION_AFFECTS_BUFFER |
         INF_ADOPTED_OPERATION_REVERSIBLE;
}

static gboolean
inf_text_default_insert_operation_apply(InfAdoptedOperation* operation,
                                        InfAdoptedUser* by,
                                        InfBuffer* buffer,
                                        GError** error)
{
  InfTextDefaultInsertOperationPrivate* priv;

  g_assert(INF_TEXT_IS_DEFAULT_INSERT_OPERATION(operation));
  g_assert(INF_TEXT_IS_BUFFER(buffer));

  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);

  if(priv-&gt;position &gt; inf_text_buffer_get_length(INF_TEXT_BUFFER(buffer)))
  {
    g_set_error_literal(
      error,
      g_quark_from_static_string("INF_TEXT_OPERATION_ERROR"),
      INF_TEXT_OPERATION_ERROR_INVALID_INSERT,
      _("Attempt to insert text after the end of the document")
    );

    return FALSE;
  }
  else
  {
    inf_text_buffer_insert_chunk(
      INF_TEXT_BUFFER(buffer),
      priv-&gt;position,
      priv-&gt;chunk,
      INF_USER(by)
    );

    return TRUE;
  }
}

static InfAdoptedOperation*
inf_text_default_insert_operation_revert(InfAdoptedOperation* operation)
{
  InfTextDefaultInsertOperationPrivate* priv;
  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);

  return INF_ADOPTED_OPERATION(
    inf_text_default_delete_operation_new(priv-&gt;position, priv-&gt;chunk)
  );
}

static guint
inf_text_default_insert_operation_get_position(InfTextInsertOperation* op)
{
  return INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(op)-&gt;position;
}

static guint
inf_text_default_insert_operation_get_length(
  InfTextInsertOperation* operation)
{
  return inf_text_chunk_get_length(
    INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation)-&gt;chunk
  );
}

static InfTextInsertOperation*
inf_text_default_insert_operation_transform_position(
  InfTextInsertOperation* operation,
  guint position)
{
  InfTextDefaultInsertOperationPrivate* priv;
  GObject* result;

  priv = INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation);

  result = g_object_new(
    INF_TEXT_TYPE_DEFAULT_INSERT_OPERATION,
    "position", position,
    "chunk", priv-&gt;chunk,
    NULL
<a name="2"></a>  );

  return INF_TEXT_INSERT_OPERATION(result);
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

static void
inf_text_default_insert_operation_class_init(
  InfTextDefaultInsertOperationClass* default_insert_operation_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(default_insert_operation_class);

  object_class-&gt;finalize = inf_text_default_insert_operation_finalize;
  object_class-&gt;set_property =
    inf_text_default_insert_operation_set_property;
  object_class-&gt;get_property =
    inf_text_default_insert_operation_get_property;

  g_object_class_install_property(
    object_class,
    PROP_POSITION,
    g_param_spec_uint(
      "position",
      "Position",
      "Insertion position",
      0,
      G_MAXUINT,
      0,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_CHUNK,
    g_param_spec_boxed(
      "chunk",
      "Chunk",
      "The text to insert",
      INF_TEXT_TYPE_CHUNK,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
}

static void
inf_text_default_insert_operation_operation_iface_init(
  InfAdoptedOperationInterface* iface)
{
  iface-&gt;need_concurrency_id =
    inf_text_default_insert_operation_need_concurrency_id;
  iface-&gt;transform = inf_text_default_insert_operation_transform;</b></font>
  iface-&gt;copy = inf_text_default_insert_operation_copy;
  iface-&gt;get_flags = inf_text_default_insert_operation_get_flags;
  iface-&gt;apply = inf_text_default_insert_operation_apply;
  iface-&gt;apply_transformed = NULL;
  iface-&gt;revert = inf_text_default_insert_operation_revert;
}

static void
inf_text_default_insert_operation_insert_operation_iface_init(
  InfTextInsertOperationInterface* iface)
{
  iface-&gt;get_position = inf_text_default_insert_operation_get_position;
  iface-&gt;get_length = inf_text_default_insert_operation_get_length;
  iface-&gt;transform_position =
    inf_text_default_insert_operation_transform_position;
}

/**
 * inf_text_default_insert_operation_new: (constructor)
 * @pos: The position at which to insert text.
 * @chunk: The text to insert.
 *
 * Creates a new insert operation that, when applied, inserts @chunk
 * at @pos.
 *
 * Returns: (transfer full): A new #InfTextDefaultInsertOperation.
 **/
InfTextDefaultInsertOperation*
inf_text_default_insert_operation_new(guint pos,
                                      InfTextChunk* chunk)
{
  GObject* object;

  g_return_val_if_fail(chunk != NULL, NULL);

  object = g_object_new(
    INF_TEXT_TYPE_DEFAULT_INSERT_OPERATION,
    "position", pos,
    "chunk", chunk,
    NULL
  );

  return INF_TEXT_DEFAULT_INSERT_OPERATION(object);
}

/**
 * inf_text_default_insert_operation_get_chunk:
 * @operation: A #InfTextDefaultInsertOperation.
 *
 * Returns the text inserted by @operation.
 *
 * Returns: (transfer none): A #InfTextChunk, owned by the operation.
 **/
InfTextChunk*
inf_text_default_insert_operation_get_chunk(InfTextDefaultInsertOperation* operation)
{
  g_return_val_if_fail(INF_TEXT_IS_DEFAULT_INSERT_OPERATION(operation), NULL);
  return INF_TEXT_DEFAULT_INSERT_OPERATION_PRIVATE(operation)-&gt;chunk;
}

/* vim:set et sw=2 ts=2: */
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
