<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for lluv_pipe.c & lluv_fs_poll.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for lluv_pipe.c & lluv_fs_poll.c
      </h3>
      <h1 align="center">
        44.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>lluv_pipe.c (34.798534%)<TH>lluv_fs_poll.c (62.091503%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match35-0.html#0',2,'match35-1.html#0',3)" NAME="0">(137-169)<TD><A HREF="javascript:ZweiFrames('match35-0.html#0',2,'match35-1.html#0',3)" NAME="0">(93-123)</A><TD ALIGN=center><FONT COLOR="#ff0000">38</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match35-0.html#1',2,'match35-1.html#1',3)" NAME="1">(235-258)<TD><A HREF="javascript:ZweiFrames('match35-0.html#1',2,'match35-1.html#1',3)" NAME="1">(124-145)</A><TD ALIGN=center><FONT COLOR="#c20000">29</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match35-0.html#2',2,'match35-1.html#2',3)" NAME="2">(35-50)<TD><A HREF="javascript:ZweiFrames('match35-0.html#2',2,'match35-1.html#2',3)" NAME="2">(28-43)</A><TD ALIGN=center><FONT COLOR="#640000">15</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match35-0.html#3',2,'match35-1.html#3',3)" NAME="3">(205-213)<TD><A HREF="javascript:ZweiFrames('match35-0.html#3',2,'match35-1.html#3',3)" NAME="3">(80-88)</A><TD ALIGN=center><FONT COLOR="#570000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>lluv_pipe.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/******************************************************************************
* Author: Alexey Melnichuk &lt;alexeymelnichuck@gmail.com&gt;
*
* Copyright (C) 2014-2016 Alexey Melnichuk &lt;alexeymelnichuck@gmail.com&gt;
*
* Licensed according to the included 'LICENSE' document
*
* This file is part of lua-lluv library.
******************************************************************************/

#include &quot;lluv.h&quot;
#include &quot;lluv_handle.h&quot;
#include &quot;lluv_stream.h&quot;
#include &quot;lluv_pipe.h&quot;
#include &quot;lluv_loop.h&quot;
#include &quot;lluv_error.h&quot;
#include &quot;lluv_req.h&quot;
#include &lt;assert.h&gt;

#define LLUV_PIPE_NAME LLUV_PREFIX&quot; Pipe&quot;
static const char *LLUV_PIPE = LLUV_PIPE_NAME;

LLUV_INTERNAL int lluv_pipe_index(lua_State *L){
  return lluv__index(L, LLUV_PIPE, lluv_stream_index);
}

LLUV_IMPL_SAFE_(lluv_pipe_create){
  lluv_loop_t *loop  = lluv_opt_loop(L, 1, LLUV_FLAG_OPEN);
  int ipc = lua_toboolean(L, loop ? 2 : 1);
  lluv_handle_t *handle; int err;

<A NAME="2"></A>  if(!loop) loop = lluv_default_loop(L);

  handle = lluv_stream_create(L, UV_NAMED_PIPE, safe_flag | INHERITE_FLAGS(loop));
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match35-1.html#2',3,'match35-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  err = uv_pipe_init(loop-&gt;handle, LLUV_H(handle, uv_pipe_t), ipc);
  if(err &lt; 0){
    lluv_handle_cleanup(L, handle, -1);
    return lluv_fail(L, safe_flag | loop-&gt;flags, LLUV_ERR_UV, (uv_errno_t)err, NULL);
  }
  return 1;
}

static lluv_handle_t* lluv_check_pipe(lua_State *L, int idx, lluv_flags_t flags){
  lluv_handle_t *handle = lluv_check_stream(L, idx, flags);
  luaL_argcheck (L, LLUV_H(handle, uv_handle_t)-&gt;type == UV_NAMED_PIPE, idx, LLUV_PIPE_NAME&quot; expected&quot;);

  return handle;
}

static int lluv_pipe_open(lua_State *L){</B></FONT>
  lluv_handle_t  *handle = lluv_check_pipe(L, 1, LLUV_FLAG_OPEN);
  uv_file fd = (uv_file)lutil_checkint64(L, 2);
  int err = uv_pipe_open(LLUV_H(handle, uv_pipe_t), fd);
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }

  lua_settop(L, 1);
  return 1;
}

#if LLUV_UV_VER_GE(1, 16, 0)

static int lluv_pipe_chmod(lua_State *L){
  static const lluv_uv_const_t FLAGS[] = {
    { UV_READABLE, &quot;read&quot;     },
    { UV_READABLE, &quot;readable&quot; },
    { UV_WRITABLE, &quot;write&quot;    },
    { UV_WRITABLE, &quot;writable&quot; },

    { 0, NULL }
  };

  lluv_handle_t *handle = lluv_check_pipe(L, 1, LLUV_FLAG_OPEN);
  int flags = UV_READABLE, err;

  if(!lua_isnoneornil(L, 2)){
    flags = lluv_opt_flags_ui_2(L, 2, flags, FLAGS);
  }

  lua_settop(L, 1);

  err = uv_pipe_chmod(LLUV_H(handle, uv_pipe_t), flags);
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }

  return 1;
}

#endif

static int lluv_pipe_bind(lua_State *L){
  lluv_handle_t *handle = lluv_check_pipe(L, 1, LLUV_FLAG_OPEN);
  const char      *addr = luaL_checkstring(L, 2);
  int               err = uv_pipe_bind(LLUV_H(handle, uv_pipe_t), addr);
  int top = lua_gettop(L);
  if(top &gt; 3) lua_settop(L, top = 3);

  if(err &lt; 0){
    if(!lua_isfunction(L, top)){
      return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, addr);
    }
    lua_pushvalue(L, 1);
    lluv_error_create(L, LLUV_ERR_UV, err, addr);
    lluv_loop_defer_call(L, lluv_loop_by_handle(&amp;handle-&gt;handle), 2);
  }
  else if(lua_isfunction(L, top)){
    lua_pushvalue(L, 1);
    lua_pushnil(L);
    lua_pushvalue(L, 2);
    lluv_loop_defer_call(L, lluv_loop_by_handle(&amp;handle-&gt;handle), 3);
  }

  lua_settop(L, 1);
  return 1;
}

static int lluv_pipe_ipc(lua_State *L){
  lluv_handle_t *handle = lluv_check_pipe(L, 1, LLUV_FLAG_OPEN);
  lua_settop(L, 1);
  lua_pushboolean(L, LLUV_H(handle, uv_pipe_t)-&gt;ipc);
  return 1;
}

static int lluv_pipe_connect(lua_State *L){
  lluv_handle_t  *handle = lluv_check_pipe(L, 1, LLUV_FLAG_OPEN);
  const char       *addr = luaL_checkstring(L, 2);
  lluv_req_t       *req;

  lluv_check_args_with_cb(L, 3);
  req = lluv_req_new(L, UV_CONNECT, handle);

<A NAME="0"></A>  uv_pipe_connect( LLUV_R(req, connect), LLUV_H(handle, uv_pipe_t), addr, lluv_on_stream_connect_cb);

  lua_settop(L, 1);
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match35-1.html#0',3,'match35-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  return 1;
}

static int lluv_pipe_getsockname(lua_State *L){
  lluv_handle_t  *handle = lluv_check_pipe(L, 1, LLUV_FLAG_OPEN);
  char buf[255]; size_t len = sizeof(buf);
  int err = uv_pipe_getsockname(LLUV_H(handle, uv_pipe_t), buf, &amp;len);
  if(err &gt;= 0){
    lua_pushlstring(L, buf, len);
    return 1;
  }
  if(err != UV_ENOBUFS){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }
  {
    char *buf = lluv_alloc(L, len);
    if(!buf){
      return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
    }
    err = uv_pipe_getsockname(LLUV_H(handle, uv_pipe_t), buf, &amp;len);
    if(err &lt; 0){
      lluv_free(L, buf);
      return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
    }
    lua_pushlstring(L, buf, len);
    lluv_free(L, buf);
    return 1;
  }
}

#if LLUV_UV_VER_GE(1,3,0)

static int lluv_pipe_getpeername(lua_State *L){</B></FONT>
  lluv_handle_t  *handle = lluv_check_pipe(L, 1, LLUV_FLAG_OPEN);
  char buf[255]; size_t len = sizeof(buf);
  int err = uv_pipe_getpeername(LLUV_H(handle, uv_pipe_t), buf, &amp;len);
  if(err &gt;= 0){
    lua_pushlstring(L, buf, len);
    return 1;
  }
  if(err != UV_ENOBUFS){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }
  {
    char *buf = lluv_alloc(L, len);
    if(!buf){
      return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
    }
    err = uv_pipe_getpeername(LLUV_H(handle, uv_pipe_t), buf, &amp;len);
    if(err &lt; 0){
      lluv_free(L, buf);
      return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
    }
    lua_pushlstring(L, buf, len);
    lluv_free(L, buf);
    return 1;
  }
}

#endif

static int lluv_pipe_pending_instances(lua_State *L){
  lluv_handle_t  *handle = lluv_check_pipe(L, 1, LLUV_FLAG_OPEN);
  int count              = luaL_checkint(L, 2);

<A NAME="3"></A>  uv_pipe_pending_instances(LLUV_H(handle, uv_pipe_t), count);

  lua_settop(L, 1);
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match35-1.html#3',3,'match35-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  return 1;
}

static int lluv_pipe_pending_count(lua_State *L){
  lluv_handle_t  *handle = lluv_check_pipe(L, 1, LLUV_FLAG_OPEN);
  int err = uv_pipe_pending_count(LLUV_H(handle, uv_pipe_t));
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }</B></FONT>
  lua_pushnumber(L, err);
  return 1;
}

static int lluv_pipe_pending_type(lua_State *L){
  lluv_handle_t  *handle = lluv_check_pipe(L, 1, LLUV_FLAG_OPEN);
  uv_handle_type    type = uv_pipe_pending_type(LLUV_H(handle, uv_pipe_t));
  lua_pushnumber(L, type);
  return 1;
}

static const struct luaL_Reg lluv_pipe_methods[] = {
  { &quot;open&quot;,              lluv_pipe_open              },
  { &quot;bind&quot;,              lluv_pipe_bind              },
  { &quot;connect&quot;,           lluv_pipe_connect           },
  { &quot;getsockname&quot;,       lluv_pipe_getsockname       },
  { &quot;ipc&quot;,               lluv_pipe_ipc               },
#if LLUV_UV_VER_GE(1,3,0)
<A NAME="1"></A>  { &quot;getpeername&quot;,       lluv_pipe_getpeername       },
#endif
  { &quot;pending_instances&quot;, lluv_pipe_pending_instances },
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match35-1.html#1',3,'match35-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  { &quot;pending_count&quot;,     lluv_pipe_pending_count     },
  { &quot;pending_type&quot;,      lluv_pipe_pending_type      },
#if LLUV_UV_VER_GE(1, 16, 0)
  { &quot;chmod&quot;,             lluv_pipe_chmod             },
#endif

  {NULL,NULL}
};

#define LLUV_FUNCTIONS(F)         \
  {&quot;pipe&quot;, lluv_pipe_create_##F}, \

static const struct luaL_Reg lluv_functions[][2] = {
  {
    LLUV_FUNCTIONS(unsafe)

    {NULL,NULL}
  },
  {
    LLUV_FUNCTIONS(safe)

    {NULL,NULL}
  },
};</B></FONT>

LLUV_INTERNAL void lluv_pipe_initlib(lua_State *L, int nup, int safe){
  lutil_pushnvalues(L, nup);
  if(!lutil_createmetap(L, LLUV_PIPE, lluv_pipe_methods, nup))
    lua_pop(L, nup);
  lua_pop(L, 1);

  luaL_setfuncs(L, lluv_functions[safe], nup);
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lluv_fs_poll.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/******************************************************************************
* Author: Alexey Melnichuk &lt;alexeymelnichuck@gmail.com&gt;
*
* Copyright (C) 2014-2016 Alexey Melnichuk &lt;alexeymelnichuck@gmail.com&gt;
*
* Licensed according to the included 'LICENSE' document
*
* This file is part of lua-lluv library.
******************************************************************************/

#include &quot;lluv.h&quot;
#include &quot;lluv_handle.h&quot;
#include &quot;lluv_fs_poll.h&quot;
#include &quot;lluv_loop.h&quot;
#include &quot;lluv_error.h&quot;
#include &lt;assert.h&gt;

#define LLUV_FS_POLL_NAME LLUV_PREFIX&quot; FS Poll&quot;
static const char *LLUV_FS_POLL = LLUV_FS_POLL_NAME;

LLUV_INTERNAL int lluv_fs_poll_index(lua_State *L){
  return lluv__index(L, LLUV_FS_POLL, lluv_handle_index);
}

<A NAME="2"></A>LLUV_IMPL_SAFE(lluv_fs_poll_create){
  lluv_loop_t   *loop   = lluv_opt_loop_ex(L, 1, LLUV_FLAG_OPEN);
  lluv_handle_t *handle = lluv_handle_create(L, UV_FS_POLL, safe_flag | INHERITE_FLAGS(loop));
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match35-0.html#2',2,'match35-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  int err = uv_fs_poll_init(loop-&gt;handle, LLUV_H(handle, uv_fs_poll_t));
  if(err &lt; 0){
    lluv_handle_cleanup(L, handle, -1);
    return lluv_fail(L, safe_flag | loop-&gt;flags, LLUV_ERR_UV, (uv_errno_t)err, NULL);
  }
  return 1;
}

static lluv_handle_t* lluv_check_fs_poll(lua_State *L, int idx, lluv_flags_t flags){
  lluv_handle_t *handle = lluv_check_handle(L, idx, flags);
  luaL_argcheck (L, LLUV_H(handle, uv_handle_t)-&gt;type == UV_FS_POLL, idx, LLUV_FS_POLL_NAME&quot; expected&quot;);

  return handle;
}

static void lluv_on_fs_poll_start(uv_fs_poll_t *arg, int status, const uv_stat_t* prev, const uv_stat_t* curr){</B></FONT>
  lluv_handle_t *handle = lluv_handle_byptr((uv_handle_t*)arg);
  lua_State *L = LLUV_HCALLBACK_L(handle);

  LLUV_CHECK_LOOP_CB_INVARIANT(L);

  lua_rawgeti(L, LLUV_LUA_REGISTRY, LLUV_START_CB(handle));
  assert(!lua_isnil(L, -1)); /* is callble */

  lluv_handle_pushself(L, handle);
  lluv_push_status(L, status);

  if(prev)lluv_push_stat(L, prev); else lua_pushnil(L);
  if(curr)lluv_push_stat(L, curr); else lua_pushnil(L);

  LLUV_HANDLE_CALL_CB(L, handle, 4);

  LLUV_CHECK_LOOP_CB_INVARIANT(L);
}

static int lluv_fs_poll_start(lua_State *L){
  lluv_handle_t *handle = lluv_check_fs_poll(L, 1, LLUV_FLAG_OPEN);
  const char *path   = luaL_checkstring(L, 2);
  /* For maximum portability, use multi-second intervals.                   */
  /* Sub-second intervals will not detect all changes on many file systems. */
  unsigned int interval = 5000;
  int err;

  if(lua_gettop(L) &gt; 3) interval = luaL_optint(L, 3, interval);

  lluv_check_args_with_cb(L, 4);
  LLUV_START_CB(handle) = luaL_ref(L, LLUV_LUA_REGISTRY);

  err = uv_fs_poll_start(LLUV_H(handle, uv_fs_poll_t), lluv_on_fs_poll_start, path, interval);
<A NAME="3"></A>
  if(err &gt;= 0) lluv_handle_lock(L, handle, LLUV_LOCK_START);

<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match35-0.html#3',2,'match35-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  return lluv_return(L, handle, LLUV_START_CB(handle), err);
}

static int lluv_fs_poll_stop(lua_State *L){
  lluv_handle_t *handle = lluv_check_fs_poll(L, 1, LLUV_FLAG_OPEN);
  int err = uv_fs_poll_stop(LLUV_H(handle, uv_fs_poll_t));
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }</B></FONT>

<A NAME="0"></A>  lluv_handle_unlock(L, handle, LLUV_LOCK_START);

  lua_settop(L, 1);
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match35-0.html#0',2,'match35-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  return 1;
}

static int lluv_fs_getpath(lua_State *L){
  lluv_handle_t  *handle = lluv_check_fs_poll(L, 1, LLUV_FLAG_OPEN);
  char buf[255]; size_t len = sizeof(buf);
  int err = uv_fs_poll_getpath(LLUV_H(handle, uv_fs_poll_t), buf, &amp;len);
  if(err &gt;= 0){
    lua_pushlstring(L, buf, len);
    return 1;
  }
  if(err != UV_ENOBUFS){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }
  {
    char *buf = lluv_alloc(L, len);
    if(!buf){
      return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
    }
    err = uv_fs_poll_getpath(LLUV_H(handle, uv_fs_poll_t), buf, &amp;len);
    if(err &lt; 0){
      lluv_free(L, buf);
      return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
    }
    lua_pushlstring(L, buf, len);
    lluv_free(L, buf);
    return 1;
  }
<A NAME="1"></A>}

static const struct luaL_Reg lluv_fs_poll_methods[] = {</B></FONT>
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match35-0.html#1',2,'match35-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  { &quot;start&quot;,      lluv_fs_poll_start      },
  { &quot;stop&quot;,       lluv_fs_poll_stop       },
  { &quot;getpath&quot;,    lluv_fs_getpath          },

  {NULL,NULL}
};

#define LLUV_FS_POLL_FUNCTIONS(F)       \
  {&quot;fs_poll&quot;, lluv_fs_poll_create_##F}, \

static const struct luaL_Reg lluv_fs_poll_functions[][2] = {
  {
    LLUV_FS_POLL_FUNCTIONS(unsafe)

    {NULL,NULL}
  },
  {
    LLUV_FS_POLL_FUNCTIONS(safe)

    {NULL,NULL}
  },
};</B></FONT>

static const lluv_uv_const_t lluv_fs_poll_constants[] = {

  { 0, NULL }
};

LLUV_INTERNAL void lluv_fs_poll_initlib(lua_State *L, int nup, int safe){
  lutil_pushnvalues(L, nup);
  if(!lutil_createmetap(L, LLUV_FS_POLL, lluv_fs_poll_methods, nup))
    lua_pop(L, nup);
  lua_pop(L, 1);

  luaL_setfuncs(L, lluv_fs_poll_functions[safe], nup);
  lluv_register_constants(L, lluv_fs_poll_constants);
}
</PRE>
</div>
  </div>
</body>
</html>
