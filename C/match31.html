<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ass_render.c &amp; wyhash.h</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ass_render.c &amp; wyhash.h
      </h3>
<h1 align="center">
        3.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ass_render.c (1.7955801%)<th>wyhash.h (20.392157%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1008-1036)<td><a href="#" name="0">(59-82)</a><td align="center"><font color="#ff0000">24</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1036-1053)<td><a href="#" name="1">(46-59)</a><td align="center"><font color="#9f0000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(2074-2086)<td><a href="#" name="2">(127-135)</a><td align="center"><font color="#8a0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ass_render.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "ass_compat.h"
3 #include &lt;assert.h&gt;
4 #include &lt;math.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;stdbool.h&gt;
7 #include "ass.h"
8 #include "ass_outline.h"
9 #include "ass_render.h"
10 #include "ass_parse.h"
11 #include "ass_priv.h"
12 #include "ass_shaper.h"
13 #define MAX_GLYPHS_INITIAL 1024
14 #define MAX_LINES_INITIAL 64
15 #define MAX_BITMAPS_INITIAL 16
16 #define MAX_SUB_BITMAPS_INITIAL 64
17 #define SUBPIXEL_MASK 63
18 #define STROKER_PRECISION 16     #define RASTERIZER_PRECISION 16  #define POSITION_PRECISION 8.0   #define MAX_PERSP_SCALE 16.0
19 #define SUBPIXEL_ORDER 3  #define BLUR_PRECISION (1.0 / 256)  
20 ASS_Renderer *ass_renderer_init(ASS_Library *library)
21 {
22     int error;
23     FT_Library ft;
24     ASS_Renderer *priv = 0;
25     int vmajor, vminor, vpatch;
26     ass_msg(library, MSGL_INFO, "libass API version: 0x%X", LIBASS_VERSION);
27     ass_msg(library, MSGL_INFO, "libass source: %s", CONFIG_SOURCEVERSION);
28     error = FT_Init_FreeType(&amp;ft);
29     if (error) {
30         ass_msg(library, MSGL_FATAL, "%s failed", "FT_Init_FreeType");
31         goto fail;
32     }
33     FT_Library_Version(ft, &amp;vmajor, &amp;vminor, &amp;vpatch);
34     ass_msg(library, MSGL_V, "Raster: FreeType %d.%d.%d",
35            vmajor, vminor, vpatch);
36     priv = calloc(1, sizeof(ASS_Renderer));
37     if (!priv) {
38         FT_Done_FreeType(ft);
39         goto fail;
40     }
41     priv-&gt;library = library;
42     priv-&gt;ftlibrary = ft;
43 #if CONFIG_ASM &amp;&amp; ARCH_X86
44     bool sse2, avx2;
45     ass_cpu_capabilities(&amp;sse2, &amp;avx2);
46     if (avx2)
47         priv-&gt;engine = &amp;ass_bitmap_engine_avx2;
48     else if (sse2)
49         priv-&gt;engine = &amp;ass_bitmap_engine_sse2;
50     else
51         priv-&gt;engine = &amp;ass_bitmap_engine_c;
52 #else
53     priv-&gt;engine = &amp;ass_bitmap_engine_c;
54 #endif
55     if (!rasterizer_init(priv-&gt;engine, &amp;priv-&gt;rasterizer, RASTERIZER_PRECISION))
56         goto fail;
57     priv-&gt;cache.font_cache = ass_font_cache_create();
58     priv-&gt;cache.bitmap_cache = ass_bitmap_cache_create();
59     priv-&gt;cache.composite_cache = ass_composite_cache_create();
60     priv-&gt;cache.outline_cache = ass_outline_cache_create();
61     if (!priv-&gt;cache.font_cache || !priv-&gt;cache.bitmap_cache || !priv-&gt;cache.composite_cache || !priv-&gt;cache.outline_cache)
62         goto fail;
63     priv-&gt;cache.glyph_max = GLYPH_CACHE_MAX;
64     priv-&gt;cache.bitmap_max_size = BITMAP_CACHE_MAX_SIZE;
65     priv-&gt;cache.composite_max_size = COMPOSITE_CACHE_MAX_SIZE;
66     priv-&gt;text_info.max_bitmaps = MAX_BITMAPS_INITIAL;
67     priv-&gt;text_info.max_glyphs = MAX_GLYPHS_INITIAL;
68     priv-&gt;text_info.max_lines = MAX_LINES_INITIAL;
69     priv-&gt;text_info.n_bitmaps = 0;
70     priv-&gt;text_info.combined_bitmaps = calloc(MAX_BITMAPS_INITIAL, sizeof(CombinedBitmapInfo));
71     priv-&gt;text_info.glyphs = calloc(MAX_GLYPHS_INITIAL, sizeof(GlyphInfo));
72     priv-&gt;text_info.lines = calloc(MAX_LINES_INITIAL, sizeof(LineInfo));
73     if (!priv-&gt;text_info.combined_bitmaps || !priv-&gt;text_info.glyphs || !priv-&gt;text_info.lines)
74         goto fail;
75     priv-&gt;settings.font_size_coeff = 1.;
76     priv-&gt;settings.selective_style_overrides = ASS_OVERRIDE_BIT_SELECTIVE_FONT_SCALE;
77     if (!(priv-&gt;shaper = ass_shaper_new()))
78         goto fail;
79     ass_shaper_info(library);
80     priv-&gt;settings.shaper = ASS_SHAPING_COMPLEX;
81     ass_msg(library, MSGL_V, "Initialized");
82     return priv;
83 fail:
84     ass_msg(library, MSGL_ERR, "Initialization failed");
85     ass_renderer_done(priv);
86     return NULL;
87 }
88 void ass_renderer_done(ASS_Renderer *render_priv)
89 {
90     if (!render_priv)
91         return;
92     ass_frame_unref(render_priv-&gt;images_root);
93     ass_frame_unref(render_priv-&gt;prev_images_root);
94     ass_cache_done(render_priv-&gt;cache.composite_cache);
95     ass_cache_done(render_priv-&gt;cache.bitmap_cache);
96     ass_cache_done(render_priv-&gt;cache.outline_cache);
97     ass_shaper_free(render_priv-&gt;shaper);
98     ass_cache_done(render_priv-&gt;cache.font_cache);
99     rasterizer_done(&amp;render_priv-&gt;rasterizer);
100     if (render_priv-&gt;fontselect)
101         ass_fontselect_free(render_priv-&gt;fontselect);
102     if (render_priv-&gt;ftlibrary)
103         FT_Done_FreeType(render_priv-&gt;ftlibrary);
104     free(render_priv-&gt;eimg);
105     free(render_priv-&gt;text_info.glyphs);
106     free(render_priv-&gt;text_info.lines);
107     free(render_priv-&gt;text_info.combined_bitmaps);
108     free(render_priv-&gt;settings.default_font);
109     free(render_priv-&gt;settings.default_family);
110     free(render_priv-&gt;user_override_style.FontName);
111     free(render_priv);
112 }
113 static ASS_Image *my_draw_bitmap(unsigned char *bitmap, int bitmap_w,
114                                  int bitmap_h, int stride, int dst_x,
115                                  int dst_y, uint32_t color,
116                                  CompositeHashValue *source)
117 {
118     ASS_ImagePriv *img = malloc(sizeof(ASS_ImagePriv));
119     if (!img) {
120         if (!source)
121             ass_aligned_free(bitmap);
122         return NULL;
123     }
124     img-&gt;result.w = bitmap_w;
125     img-&gt;result.h = bitmap_h;
126     img-&gt;result.stride = stride;
127     img-&gt;result.bitmap = bitmap;
128     img-&gt;result.color = color;
129     img-&gt;result.dst_x = dst_x;
130     img-&gt;result.dst_y = dst_y;
131     img-&gt;source = source;
132     ass_cache_inc_ref(source);
133     img-&gt;buffer = source ? NULL : bitmap;
134     img-&gt;ref_count = 0;
135     return &amp;img-&gt;result;
136 }
137 static double x2scr_pos(ASS_Renderer *render_priv, double x)
138 {
139     return x * render_priv-&gt;orig_width / render_priv-&gt;font_scale_x / render_priv-&gt;track-&gt;PlayResX +
140         render_priv-&gt;settings.left_margin;
141 }
142 static double x2scr_left(ASS_Renderer *render_priv, double x)
143 {
144     if (render_priv-&gt;state.explicit || !render_priv-&gt;settings.use_margins)
145         return x2scr_pos(render_priv, x);
146     return x * render_priv-&gt;fit_width / render_priv-&gt;font_scale_x /
147         render_priv-&gt;track-&gt;PlayResX;
148 }
149 static double x2scr_right(ASS_Renderer *render_priv, double x)
150 {
151     if (render_priv-&gt;state.explicit || !render_priv-&gt;settings.use_margins)
152         return x2scr_pos(render_priv, x);
153     return x * render_priv-&gt;fit_width / render_priv-&gt;font_scale_x /
154         render_priv-&gt;track-&gt;PlayResX +
155         (render_priv-&gt;width - render_priv-&gt;fit_width);
156 }
157 static double x2scr_pos_scaled(ASS_Renderer *render_priv, double x)
158 {
159     return x * render_priv-&gt;orig_width / render_priv-&gt;track-&gt;PlayResX +
160         render_priv-&gt;settings.left_margin;
161 }
162 static double y2scr_pos(ASS_Renderer *render_priv, double y)
163 {
164     return y * render_priv-&gt;orig_height / render_priv-&gt;track-&gt;PlayResY +
165         render_priv-&gt;settings.top_margin;
166 }
167 static double y2scr(ASS_Renderer *render_priv, double y)
168 {
169     if (render_priv-&gt;state.explicit || !render_priv-&gt;settings.use_margins)
170         return y2scr_pos(render_priv, y);
171     return y * render_priv-&gt;fit_height /
172         render_priv-&gt;track-&gt;PlayResY +
173         (render_priv-&gt;height - render_priv-&gt;fit_height) * 0.5;
174 }
175 static double y2scr_top(ASS_Renderer *render_priv, double y)
176 {
177     if (render_priv-&gt;state.explicit || !render_priv-&gt;settings.use_margins)
178         return y2scr_pos(render_priv, y);
179     return y * render_priv-&gt;fit_height /
180         render_priv-&gt;track-&gt;PlayResY;
181 }
182 static double y2scr_sub(ASS_Renderer *render_priv, double y)
183 {
184     if (render_priv-&gt;state.explicit || !render_priv-&gt;settings.use_margins)
185         return y2scr_pos(render_priv, y);
186     return y * render_priv-&gt;fit_height /
187         render_priv-&gt;track-&gt;PlayResY +
188         (render_priv-&gt;height - render_priv-&gt;fit_height);
189 }
190 static ASS_Image **render_glyph_i(ASS_Renderer *render_priv,
191                                   Bitmap *bm, int dst_x, int dst_y,
192                                   uint32_t color, uint32_t color2, int brk,
193                                   ASS_Image **tail, unsigned type,
194                                   CompositeHashValue *source)
195 {
196     int i, j, x0, y0, x1, y1, cx0, cy0, cx1, cy1, sx, sy, zx, zy;
197     Rect r[4];
198     ASS_Image *img;
199     dst_x += bm-&gt;left;
200     dst_y += bm-&gt;top;
201     brk -= dst_x;
202     zx = x2scr_pos_scaled(render_priv, 0);
203     zy = y2scr_pos(render_priv, 0);
204     sx = x2scr_pos_scaled(render_priv, render_priv-&gt;track-&gt;PlayResX);
205     sy = y2scr_pos(render_priv, render_priv-&gt;track-&gt;PlayResY);
206     x0 = 0;
207     y0 = 0;
208     x1 = bm-&gt;w;
209     y1 = bm-&gt;h;
210     cx0 = render_priv-&gt;state.clip_x0 - dst_x;
211     cy0 = render_priv-&gt;state.clip_y0 - dst_y;
212     cx1 = render_priv-&gt;state.clip_x1 - dst_x;
213     cy1 = render_priv-&gt;state.clip_y1 - dst_y;
214     i = 0;
215     r[i].x0 = x0;
216     r[i].y0 = y0;
217     r[i].x1 = (cx0 &gt; x1) ? x1 : cx0;
218     r[i].y1 = y1;
219     if (r[i].x1 &gt; r[i].x0 &amp;&amp; r[i].y1 &gt; r[i].y0) i++;
220     r[i].x0 = (cx0 &lt; 0) ? x0 : cx0;
221     r[i].y0 = y0;
222     r[i].x1 = (cx1 &gt; x1) ? x1 : cx1;
223     r[i].y1 = (cy0 &gt; y1) ? y1 : cy0;
224     if (r[i].x1 &gt; r[i].x0 &amp;&amp; r[i].y1 &gt; r[i].y0) i++;
225     r[i].x0 = (cx0 &lt; 0) ? x0 : cx0;
226     r[i].y0 = (cy1 &lt; 0) ? y0 : cy1;
227     r[i].x1 = (cx1 &gt; x1) ? x1 : cx1;
228     r[i].y1 = y1;
229     if (r[i].x1 &gt; r[i].x0 &amp;&amp; r[i].y1 &gt; r[i].y0) i++;
230     r[i].x0 = (cx1 &lt; 0) ? x0 : cx1;
231     r[i].y0 = y0;
232     r[i].x1 = x1;
233     r[i].y1 = y1;
234     if (r[i].x1 &gt; r[i].x0 &amp;&amp; r[i].y1 &gt; r[i].y0) i++;
235     for (j = 0; j &lt; i; j++) {
236         r[j].x0 = (r[j].x0 + dst_x &lt; zx) ? zx - dst_x : r[j].x0;
237         r[j].y0 = (r[j].y0 + dst_y &lt; zy) ? zy - dst_y : r[j].y0;
238         r[j].x1 = (r[j].x1 + dst_x &gt; sx) ? sx - dst_x : r[j].x1;
239         r[j].y1 = (r[j].y1 + dst_y &gt; sy) ? sy - dst_y : r[j].y1;
240     }
241     for (j = 0; j &lt; i; j++) {
242         int lbrk = brk;
243         if (r[j].x1 &lt;= r[j].x0 || r[j].y1 &lt;= r[j].y0)
244             continue;
245         if (lbrk &gt; r[j].x0) {
246             if (lbrk &gt; r[j].x1) lbrk = r[j].x1;
247             img = my_draw_bitmap(bm-&gt;buffer + r[j].y0 * bm-&gt;stride + r[j].x0,
248                                  lbrk - r[j].x0, r[j].y1 - r[j].y0, bm-&gt;stride,
249                                  dst_x + r[j].x0, dst_y + r[j].y0, color, source);
250             if (!img) break;
251             img-&gt;type = type;
252             *tail = img;
253             tail = &amp;img-&gt;next;
254         }
255         if (lbrk &lt; r[j].x1) {
256             if (lbrk &lt; r[j].x0) lbrk = r[j].x0;
257             img = my_draw_bitmap(bm-&gt;buffer + r[j].y0 * bm-&gt;stride + lbrk,
258                                  r[j].x1 - lbrk, r[j].y1 - r[j].y0, bm-&gt;stride,
259                                  dst_x + lbrk, dst_y + r[j].y0, color2, source);
260             if (!img) break;
261             img-&gt;type = type;
262             *tail = img;
263             tail = &amp;img-&gt;next;
264         }
265     }
266     return tail;
267 }
268 static ASS_Image **
269 render_glyph(ASS_Renderer *render_priv, Bitmap *bm, int dst_x, int dst_y,
270              uint32_t color, uint32_t color2, int brk, ASS_Image **tail,
271              unsigned type, CompositeHashValue *source)
272 {
273     if (render_priv-&gt;state.clip_mode)
274         return render_glyph_i(render_priv, bm, dst_x, dst_y, color, color2,
275                               brk, tail, type, source);
276     int b_x0, b_y0, b_x1, b_y1;     int clip_x0, clip_y0, clip_x1, clip_y1;
277     int tmp;
278     ASS_Image *img;
279     dst_x += bm-&gt;left;
280     dst_y += bm-&gt;top;
281     brk -= dst_x;
282     clip_x0 = FFMINMAX(render_priv-&gt;state.clip_x0, 0, render_priv-&gt;width);
283     clip_y0 = FFMINMAX(render_priv-&gt;state.clip_y0, 0, render_priv-&gt;height);
284     clip_x1 = FFMINMAX(render_priv-&gt;state.clip_x1, 0, render_priv-&gt;width);
285     clip_y1 = FFMINMAX(render_priv-&gt;state.clip_y1, 0, render_priv-&gt;height);
286     b_x0 = 0;
287     b_y0 = 0;
288     b_x1 = bm-&gt;w;
289     b_y1 = bm-&gt;h;
290     tmp = dst_x - clip_x0;
291     if (tmp &lt; 0)
292         b_x0 = -tmp;
293     tmp = dst_y - clip_y0;
294     if (tmp &lt; 0)
295         b_y0 = -tmp;
296     tmp = clip_x1 - dst_x - bm-&gt;w;
297     if (tmp &lt; 0)
298         b_x1 = bm-&gt;w + tmp;
299     tmp = clip_y1 - dst_y - bm-&gt;h;
300     if (tmp &lt; 0)
301         b_y1 = bm-&gt;h + tmp;
302     if ((b_y0 &gt;= b_y1) || (b_x0 &gt;= b_x1))
303         return tail;
304     if (brk &gt; b_x0) {                   if (brk &gt; b_x1)
305             brk = b_x1;
306         img = my_draw_bitmap(bm-&gt;buffer + bm-&gt;stride * b_y0 + b_x0,
307                              brk - b_x0, b_y1 - b_y0, bm-&gt;stride,
308                              dst_x + b_x0, dst_y + b_y0, color, source);
309         if (!img) return tail;
310         img-&gt;type = type;
311         *tail = img;
312         tail = &amp;img-&gt;next;
313     }
314     if (brk &lt; b_x1) {                   if (brk &lt; b_x0)
315             brk = b_x0;
316         img = my_draw_bitmap(bm-&gt;buffer + bm-&gt;stride * b_y0 + brk,
317                              b_x1 - brk, b_y1 - b_y0, bm-&gt;stride,
318                              dst_x + brk, dst_y + b_y0, color2, source);
319         if (!img) return tail;
320         img-&gt;type = type;
321         *tail = img;
322         tail = &amp;img-&gt;next;
323     }
324     return tail;
325 }
326 static bool quantize_transform(double m[3][3], ASS_Vector *pos,
327                                ASS_DVector *offset, bool first,
328                                BitmapHashKey *key)
329 {
330     const double max_val = 1000000;
331     const ASS_Rect *bbox = &amp;key-&gt;outline-&gt;cbox;
332     double x0 = (bbox-&gt;x_min + bbox-&gt;x_max) / 2.0;
333     double y0 = (bbox-&gt;y_min + bbox-&gt;y_max) / 2.0;
334     double dx = (bbox-&gt;x_max - bbox-&gt;x_min) / 2.0 + 64;
335     double dy = (bbox-&gt;y_max - bbox-&gt;y_min) / 2.0 + 64;
336     for (int i = 0; i &lt; 3; i++)
337         m[i][2] += m[i][0] * x0 + m[i][1] * y0;
338     if (m[2][2] &lt;= 0)
339         return false;
340     double w = 1 / m[2][2];
341     double center[2] = { m[0][2] * w, m[1][2] * w };
342     for (int i = 0; i &lt; 2; i++)
343         for (int j = 0; j &lt; 2; j++)
344             m[i][j] -= m[2][j] * center[i];
345     double delta[2] = {0};
346     if (!first) {
347         delta[0] = offset-&gt;x;
348         delta[1] = offset-&gt;y;
349     }
350     int32_t qr[2];      for (int i = 0; i &lt; 2; i++) {
351         center[i] /= 64 &gt;&gt; SUBPIXEL_ORDER;
352         center[i] -= delta[i];
353         if (!(fabs(center[i]) &lt; max_val))
354             return false;
355         qr[i] = lrint(center[i]);
356     }
357     double z0 = m[2][2] - fabs(m[2][0]) * dx - fabs(m[2][1]) * dy;
358     w = 1.0 / POSITION_PRECISION / FFMAX(z0, m[2][2] / MAX_PERSP_SCALE);
359     double mul[2] = { dx * w, dy * w };  
360     int32_t qm[3][2];
361     for (int i = 0; i &lt; 2; i++)
362         for (int j = 0; j &lt; 2; j++) {
363             double val = m[i][j] * mul[j];
364             if (!(fabs(val) &lt; max_val))
365                 return false;
366             qm[i][j] = lrint(val);
367         }
368     int32_t qmx = abs(qm[0][0]) + abs(qm[0][1]);
369     int32_t qmy = abs(qm[1][0]) + abs(qm[1][1]);
370     w = POSITION_PRECISION * FFMAX(qmx, qmy);
371     mul[0] *= w;
372     mul[1] *= w;
373     for (int j = 0; j &lt; 2; j++) {
374         double val = m[2][j] * mul[j];
375         if (!(fabs(val) &lt; max_val))
376             return false;
377         qm[2][j] = lrint(val);
378     }
379     if (first &amp;&amp; offset) {
380         offset-&gt;x = center[0] - qr[0];
381         offset-&gt;y = center[1] - qr[1];
382     }
383     *pos = (ASS_Vector) {
384         .x = qr[0] &gt;&gt; SUBPIXEL_ORDER,
385         .y = qr[1] &gt;&gt; SUBPIXEL_ORDER,
386     };
387     key-&gt;offset.x = qr[0] &amp; ((1 &lt;&lt; SUBPIXEL_ORDER) - 1);
388     key-&gt;offset.y = qr[1] &amp; ((1 &lt;&lt; SUBPIXEL_ORDER) - 1);
389     key-&gt;matrix_x.x = qm[0][0];  key-&gt;matrix_x.y = qm[0][1];
390     key-&gt;matrix_y.x = qm[1][0];  key-&gt;matrix_y.y = qm[1][1];
391     key-&gt;matrix_z.x = qm[2][0];  key-&gt;matrix_z.y = qm[2][1];
392     return true;
393 }
394 static void restore_transform(double m[3][3], const BitmapHashKey *key)
395 {
396     const ASS_Rect *bbox = &amp;key-&gt;outline-&gt;cbox;
397     double x0 = (bbox-&gt;x_min + bbox-&gt;x_max) / 2.0;
398     double y0 = (bbox-&gt;y_min + bbox-&gt;y_max) / 2.0;
399     double dx = (bbox-&gt;x_max - bbox-&gt;x_min) / 2.0 + 64;
400     double dy = (bbox-&gt;y_max - bbox-&gt;y_min) / 2.0 + 64;
401     double q_x = POSITION_PRECISION / dx;
402     double q_y = POSITION_PRECISION / dy;
403     m[0][0] = key-&gt;matrix_x.x * q_x;
404     m[0][1] = key-&gt;matrix_x.y * q_y;
405     m[1][0] = key-&gt;matrix_y.x * q_x;
406     m[1][1] = key-&gt;matrix_y.y * q_y;
407     int32_t qmx = abs(key-&gt;matrix_x.x) + abs(key-&gt;matrix_x.y);
408     int32_t qmy = abs(key-&gt;matrix_y.x) + abs(key-&gt;matrix_y.y);
409     double scale_z = 1.0 / POSITION_PRECISION / FFMAX(qmx, qmy);
410     m[2][0] = key-&gt;matrix_z.x * q_x * scale_z;      m[2][1] = key-&gt;matrix_z.y * q_y * scale_z;  
411     m[0][2] = m[1][2] = 0;
412     m[2][2] = 1 + fabs(m[2][0]) * dx + fabs(m[2][1]) * dy;
413     m[2][2] = FFMIN(m[2][2], MAX_PERSP_SCALE);
414     double center[2] = {
415         key-&gt;offset.x * (64 &gt;&gt; SUBPIXEL_ORDER),
416         key-&gt;offset.y * (64 &gt;&gt; SUBPIXEL_ORDER),
417     };
418     for (int i = 0; i &lt; 2; i++)
419         for (int j = 0; j &lt; 3; j++)
420             m[i][j] += m[2][j] * center[i];
421     for (int i = 0; i &lt; 3; i++)
422         m[i][2] -= m[i][0] * x0 + m[i][1] * y0;
423 }
424 static inline size_t bitmap_size(const Bitmap *bm)
425 {
426     return bm-&gt;stride * bm-&gt;h;
427 }
428 static void blend_vector_clip(ASS_Renderer *render_priv, ASS_Image *head)
429 {
430     if (!render_priv-&gt;state.clip_drawing_text.str)
431         return;
432     OutlineHashKey ol_key;
433     ol_key.type = OUTLINE_DRAWING;
434     ol_key.u.drawing.text = render_priv-&gt;state.clip_drawing_text;
435     double m[3][3] = {{0}};
436     int32_t scale_base = lshiftwrapi(1, render_priv-&gt;state.clip_drawing_scale - 1);
437     double w = scale_base &gt; 0 ? (render_priv-&gt;font_scale / scale_base) : 0;
438     m[0][0] = render_priv-&gt;font_scale_x * w;
439     m[1][1] = w;
440     m[2][2] = 1;
441     m[0][2] = int_to_d6(render_priv-&gt;settings.left_margin);
442     m[1][2] = int_to_d6(render_priv-&gt;settings.top_margin);
443     ASS_Vector pos;
444     BitmapHashKey key;
445     key.outline = ass_cache_get(render_priv-&gt;cache.outline_cache, &amp;ol_key, render_priv);
446     if (!key.outline || !key.outline-&gt;valid ||
447             !quantize_transform(m, &amp;pos, NULL, true, &amp;key)) {
448         ass_cache_dec_ref(key.outline);
449         return;
450     }
451     Bitmap *clip_bm = ass_cache_get(render_priv-&gt;cache.bitmap_cache, &amp;key, render_priv);
452     if (!clip_bm)
453         return;
454     for (ASS_Image *cur = head; cur; cur = cur-&gt;next) {
455         int left, top, right, bottom, w, h;
456         int ax, ay, aw, ah, as;
457         int bx, by, bw, bh, bs;
458         int aleft, atop, bleft, btop;
459         unsigned char *abuffer, *bbuffer, *nbuffer;
460         abuffer = cur-&gt;bitmap;
461         bbuffer = clip_bm-&gt;buffer;
462         ax = cur-&gt;dst_x;
463         ay = cur-&gt;dst_y;
464         aw = cur-&gt;w;
465         ah = cur-&gt;h;
466         as = cur-&gt;stride;
467         bx = pos.x + clip_bm-&gt;left;
468         by = pos.y + clip_bm-&gt;top;
469         bw = clip_bm-&gt;w;
470         bh = clip_bm-&gt;h;
471         bs = clip_bm-&gt;stride;
472         left = (ax &gt; bx) ? ax : bx;
473         top = (ay &gt; by) ? ay : by;
474         right = ((ax + aw) &lt; (bx + bw)) ? (ax + aw) : (bx + bw);
475         bottom = ((ay + ah) &lt; (by + bh)) ? (ay + ah) : (by + bh);
476         aleft = left - ax;
477         atop = top - ay;
478         w = right - left;
479         h = bottom - top;
480         bleft = left - bx;
481         btop = top - by;
482         unsigned align = 1 &lt;&lt; render_priv-&gt;engine-&gt;align_order;
483         if (render_priv-&gt;state.clip_drawing_mode) {
484             if (ax + aw &lt; bx || ay + ah &lt; by || ax &gt; bx + bw ||
485                 ay &gt; by + bh || !h || !w) {
486                 continue;
487             }
488             nbuffer = ass_aligned_alloc(align, as * ah + align, false);
489             if (!nbuffer)
490                 break;
491             memcpy(nbuffer, abuffer, ((ah - 1) * as) + aw);
492             render_priv-&gt;engine-&gt;imul_bitmaps(nbuffer + atop * as + aleft, as,
493                                               bbuffer + btop * bs + bleft, bs,
494                                               w, h);
495         } else {
496             if (ax + aw &lt; bx || ay + ah &lt; by || ax &gt; bx + bw ||
497                 ay &gt; by + bh || !h || !w) {
498                 cur-&gt;w = cur-&gt;h = cur-&gt;stride = 0;
499                 continue;
500             }
501             unsigned ns = ass_align(align, w);
502             nbuffer = ass_aligned_alloc(align, ns * h + align, false);
503             if (!nbuffer)
504                 break;
505             render_priv-&gt;engine-&gt;mul_bitmaps(nbuffer, ns,
506                                              abuffer + atop * as + aleft, as,
507                                              bbuffer + btop * bs + bleft, bs,
508                                              w, h);
509             cur-&gt;dst_x += aleft;
510             cur-&gt;dst_y += atop;
511             cur-&gt;w = w;
512             cur-&gt;h = h;
513             cur-&gt;stride = ns;
514         }
515         ASS_ImagePriv *priv = (ASS_ImagePriv *) cur;
516         priv-&gt;buffer = cur-&gt;bitmap = nbuffer;
517         ass_cache_dec_ref(priv-&gt;source);
518         priv-&gt;source = NULL;
519     }
520     ass_cache_dec_ref(clip_bm);
521 }
522 static ASS_Image *render_text(ASS_Renderer *render_priv)
523 {
524     ASS_Image *head;
525     ASS_Image **tail = &amp;head;
526     unsigned n_bitmaps = render_priv-&gt;text_info.n_bitmaps;
527     CombinedBitmapInfo *bitmaps = render_priv-&gt;text_info.combined_bitmaps;
528     for (unsigned i = 0; i &lt; n_bitmaps; i++) {
529         CombinedBitmapInfo *info = &amp;bitmaps[i];
530         if (!info-&gt;bm_s || render_priv-&gt;state.border_style == 4)
531             continue;
532         tail =
533             render_glyph(render_priv, info-&gt;bm_s, info-&gt;x, info-&gt;y, info-&gt;c[3], 0,
534                          1000000, tail, IMAGE_TYPE_SHADOW, info-&gt;image);
535     }
536     for (unsigned i = 0; i &lt; n_bitmaps; i++) {
537         CombinedBitmapInfo *info = &amp;bitmaps[i];
538         if (!info-&gt;bm_o)
539             continue;
540         if ((info-&gt;effect_type == EF_KARAOKE_KO)
541                 &amp;&amp; (info-&gt;effect_timing &lt;= 0)) {
542         } else {
543             tail =
544                 render_glyph(render_priv, info-&gt;bm_o, info-&gt;x, info-&gt;y, info-&gt;c[2],
545                              0, 1000000, tail, IMAGE_TYPE_OUTLINE, info-&gt;image);
546         }
547     }
548     for (unsigned i = 0; i &lt; n_bitmaps; i++) {
549         CombinedBitmapInfo *info = &amp;bitmaps[i];
550         if (!info-&gt;bm)
551             continue;
552         if ((info-&gt;effect_type == EF_KARAOKE)
553                 || (info-&gt;effect_type == EF_KARAOKE_KO)) {
554             if (info-&gt;effect_timing &gt; 0)
555                 tail =
556                     render_glyph(render_priv, info-&gt;bm, info-&gt;x, info-&gt;y,
557                                  info-&gt;c[0], 0, 1000000, tail,
558                                  IMAGE_TYPE_CHARACTER, info-&gt;image);
559             else
560                 tail =
561                     render_glyph(render_priv, info-&gt;bm, info-&gt;x, info-&gt;y,
562                                  info-&gt;c[1], 0, 1000000, tail,
563                                  IMAGE_TYPE_CHARACTER, info-&gt;image);
564         } else if (info-&gt;effect_type == EF_KARAOKE_KF) {
565             tail =
566                 render_glyph(render_priv, info-&gt;bm, info-&gt;x, info-&gt;y, info-&gt;c[0],
567                              info-&gt;c[1], info-&gt;effect_timing, tail,
568                              IMAGE_TYPE_CHARACTER, info-&gt;image);
569         } else
570             tail =
571                 render_glyph(render_priv, info-&gt;bm, info-&gt;x, info-&gt;y, info-&gt;c[0],
572                              0, 1000000, tail, IMAGE_TYPE_CHARACTER, info-&gt;image);
573     }
574     for (unsigned i = 0; i &lt; n_bitmaps; i++)
575         ass_cache_dec_ref(bitmaps[i].image);
576     *tail = 0;
577     blend_vector_clip(render_priv, head);
578     return head;
579 }
580 static void compute_string_bbox(TextInfo *text, ASS_DRect *bbox)
581 {
582     if (text-&gt;length &gt; 0) {
583         bbox-&gt;x_min = +32000;
584         bbox-&gt;x_max = -32000;
585         bbox-&gt;y_min = -text-&gt;lines[0].asc;
586         bbox-&gt;y_max = bbox-&gt;y_min + text-&gt;height;
587         for (int i = 0; i &lt; text-&gt;length; i++) {
588             GlyphInfo *info = text-&gt;glyphs + i;
589             if (info-&gt;skip) continue;
590             double s = d6_to_double(info-&gt;pos.x);
591             double e = s + d6_to_double(info-&gt;cluster_advance.x);
592             bbox-&gt;x_min = FFMIN(bbox-&gt;x_min, s);
593             bbox-&gt;x_max = FFMAX(bbox-&gt;x_max, e);
594         }
595     } else
596         bbox-&gt;x_min = bbox-&gt;x_max = bbox-&gt;y_min = bbox-&gt;y_max = 0;
597 }
598 static ASS_Style *handle_selective_style_overrides(ASS_Renderer *render_priv,
599                                                    ASS_Style *rstyle)
600 {
601     ASS_Style *script = render_priv-&gt;track-&gt;styles +
602                         render_priv-&gt;state.event-&gt;Style;
603     ASS_Style *user = &amp;render_priv-&gt;user_override_style;
604     ASS_Style *new = &amp;render_priv-&gt;state.override_style_temp_storage;
605     int explicit = render_priv-&gt;state.explicit;
606     int requested = render_priv-&gt;settings.selective_style_overrides;
607     double scale;
608     user-&gt;Name = "OverrideStyle"; 
609     if (!rstyle)
610         rstyle = script;
611     *new = *rstyle;
612     render_priv-&gt;state.apply_font_scale =
613         !explicit || !(requested &amp; ASS_OVERRIDE_BIT_SELECTIVE_FONT_SCALE);
614     if (explicit)
615         requested = 0;
616     if (requested &amp; ASS_OVERRIDE_BIT_STYLE)
617         requested |= ASS_OVERRIDE_BIT_FONT_NAME |
618                      ASS_OVERRIDE_BIT_FONT_SIZE_FIELDS |
619                      ASS_OVERRIDE_BIT_COLORS |
620                      ASS_OVERRIDE_BIT_BORDER |
621                      ASS_OVERRIDE_BIT_ATTRIBUTES;
622     if (requested &amp; ASS_OVERRIDE_FULL_STYLE)
623         *new = *user;
624     scale = render_priv-&gt;track-&gt;PlayResY / 288.0;
625     if (requested &amp; ASS_OVERRIDE_BIT_FONT_SIZE_FIELDS) {
626         new-&gt;FontSize = user-&gt;FontSize * scale;
627         new-&gt;Spacing = user-&gt;Spacing * scale;
628         new-&gt;ScaleX = user-&gt;ScaleX;
629         new-&gt;ScaleY = user-&gt;ScaleY;
630     }
631     if (requested &amp; ASS_OVERRIDE_BIT_FONT_NAME) {
632         new-&gt;FontName = user-&gt;FontName;
633         new-&gt;treat_fontname_as_pattern = user-&gt;treat_fontname_as_pattern;
634     }
635     if (requested &amp; ASS_OVERRIDE_BIT_COLORS) {
636         new-&gt;PrimaryColour = user-&gt;PrimaryColour;
637         new-&gt;SecondaryColour = user-&gt;SecondaryColour;
638         new-&gt;OutlineColour = user-&gt;OutlineColour;
639         new-&gt;BackColour = user-&gt;BackColour;
640     }
641     if (requested &amp; ASS_OVERRIDE_BIT_ATTRIBUTES) {
642         new-&gt;Bold = user-&gt;Bold;
643         new-&gt;Italic = user-&gt;Italic;
644         new-&gt;Underline = user-&gt;Underline;
645         new-&gt;StrikeOut = user-&gt;StrikeOut;
646     }
647     if (requested &amp; ASS_OVERRIDE_BIT_BORDER) {
648         new-&gt;BorderStyle = user-&gt;BorderStyle;
649         new-&gt;Outline = user-&gt;Outline * scale;
650         new-&gt;Shadow = user-&gt;Shadow * scale;
651     }
652     if (requested &amp; ASS_OVERRIDE_BIT_ALIGNMENT)
653         new-&gt;Alignment = user-&gt;Alignment;
654     if (requested &amp; ASS_OVERRIDE_BIT_JUSTIFY)
655         new-&gt;Justify = user-&gt;Justify;
656     if (requested &amp; ASS_OVERRIDE_BIT_MARGINS) {
657         new-&gt;MarginL = user-&gt;MarginL;
658         new-&gt;MarginR = user-&gt;MarginR;
659         new-&gt;MarginV = user-&gt;MarginV;
660     }
661     if (!new-&gt;FontName)
662         new-&gt;FontName = rstyle-&gt;FontName;
663     render_priv-&gt;state.style = new;
664     render_priv-&gt;state.overrides = requested;
665     return new;
666 }
667 static void init_font_scale(ASS_Renderer *render_priv)
668 {
669     ASS_Settings *settings_priv = &amp;render_priv-&gt;settings;
670     double font_scr_h = render_priv-&gt;orig_height;
671     if (!render_priv-&gt;state.explicit &amp;&amp; render_priv-&gt;settings.use_margins)
672         font_scr_h = render_priv-&gt;fit_height;
673     render_priv-&gt;font_scale = font_scr_h / render_priv-&gt;track-&gt;PlayResY;
674     if (settings_priv-&gt;storage_height)
675         render_priv-&gt;blur_scale = font_scr_h / settings_priv-&gt;storage_height;
676     else
677         render_priv-&gt;blur_scale = font_scr_h / render_priv-&gt;track-&gt;PlayResY;
678     if (render_priv-&gt;track-&gt;ScaledBorderAndShadow)
679         render_priv-&gt;border_scale =
680             font_scr_h / render_priv-&gt;track-&gt;PlayResY;
681     else
682         render_priv-&gt;border_scale = render_priv-&gt;blur_scale;
683     if (render_priv-&gt;state.apply_font_scale) {
684         render_priv-&gt;font_scale *= settings_priv-&gt;font_size_coeff;
685         render_priv-&gt;border_scale *= settings_priv-&gt;font_size_coeff;
686         render_priv-&gt;blur_scale *= settings_priv-&gt;font_size_coeff;
687     }
688 }
689 void reset_render_context(ASS_Renderer *render_priv, ASS_Style *style)
690 {
691     style = handle_selective_style_overrides(render_priv, style);
692     init_font_scale(render_priv);
693     render_priv-&gt;state.c[0] = style-&gt;PrimaryColour;
694     render_priv-&gt;state.c[1] = style-&gt;SecondaryColour;
695     render_priv-&gt;state.c[2] = style-&gt;OutlineColour;
696     render_priv-&gt;state.c[3] = style-&gt;BackColour;
697 <a name="0"></a>    render_priv-&gt;state.flags =
698         (style-&gt;Underline ? DECO_UNDERLINE : 0) |
699         (style-&gt;StrikeOut ? DECO_STRIKETHROUGH : 0);
700 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    render_priv-&gt;state.font_size = style-&gt;FontSize;
701     render_priv-&gt;state.family.str = style-&gt;FontName;
702     render_priv-&gt;state.family.len = strlen(style-&gt;FontName);
703     render_priv-&gt;state.treat_family_as_pattern = style-&gt;treat_fontname_as_pattern;
704     render_priv-&gt;state.bold = style-&gt;Bold;
705     render_priv-&gt;state.italic = style-&gt;Italic;
706     update_font(render_priv);
707     render_priv-&gt;state.border_style = style-&gt;BorderStyle;
708     render_priv-&gt;state.border_x = style-&gt;Outline;
709     render_priv-&gt;state.border_y = style-&gt;Outline;
710     render_priv-&gt;state.scale_x = style-&gt;ScaleX;
711     render_priv-&gt;state.scale_y = style-&gt;ScaleY;
712     render_priv-&gt;state.hspacing = style-&gt;Spacing;
713     render_priv-&gt;state.be = 0;
714     render_priv-&gt;state.blur = style-&gt;Blur;
715     render_priv-&gt;state.shadow_x = style-&gt;Shadow;
716     render_priv-&gt;state.shadow_y = style-&gt;Shadow;
717     render_priv-&gt;state.frx = render_priv-&gt;state.fry = 0.;
718     render_priv-&gt;state.frz = style-&gt;Angle;
719     render_priv-&gt;state.fax = render_priv-&gt;state.fay = 0.;
720     render_priv-&gt;state.font_encoding = style-&gt;Encoding;
721 }
722 static void</b></font><font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>
723 init_render_context(ASS_Renderer *render_priv, ASS_Event *event)
724 {
725     render_priv-&gt;state.event = event;
726     render_priv-&gt;state.parsed_tags = 0;
727     render_priv-&gt;state.evt_type = EVENT_NORMAL;
728     render_priv-&gt;state.wrap_style = render_priv-&gt;track-&gt;WrapStyle;
729     render_priv-&gt;state.pos_x = 0;
730     render_priv-&gt;state.pos_y = 0;
731     render_priv-&gt;state.org_x = 0;
732     render_priv-&gt;state.org_y = 0;
733     render_priv-&gt;state.have_origin = 0;
734     render_priv-&gt;state.clip_x0 = 0;
735     render_priv-&gt;state.clip_y0 = 0;
736     render_priv-&gt;state.clip_x1 = render_priv-&gt;track-&gt;PlayResX;
737     render_priv-&gt;state.clip_y1 = render_priv-&gt;track-&gt;PlayResY;</b></font>
738     render_priv-&gt;state.clip_mode = 0;
739     render_priv-&gt;state.detect_collisions = 1;
740     render_priv-&gt;state.fade = 0;
741     render_priv-&gt;state.drawing_scale = 0;
742     render_priv-&gt;state.pbo = 0;
743     render_priv-&gt;state.effect_type = EF_NONE;
744     render_priv-&gt;state.effect_timing = 0;
745     render_priv-&gt;state.effect_skip_timing = 0;
746     apply_transition_effects(render_priv, event);
747     render_priv-&gt;state.explicit = render_priv-&gt;state.evt_type != EVENT_NORMAL ||
748                                   event_has_hard_overrides(event-&gt;Text);
749     reset_render_context(render_priv, NULL);
750     render_priv-&gt;state.alignment = render_priv-&gt;state.style-&gt;Alignment;
751     render_priv-&gt;state.justify = render_priv-&gt;state.style-&gt;Justify;
752 }
753 static void free_render_context(ASS_Renderer *render_priv)
754 {
755     ass_cache_dec_ref(render_priv-&gt;state.font);
756     render_priv-&gt;state.font = NULL;
757     render_priv-&gt;state.family.str = NULL;
758     render_priv-&gt;state.family.len = 0;
759     render_priv-&gt;state.clip_drawing_text.str = NULL;
760     render_priv-&gt;state.clip_drawing_text.len = 0;
761     render_priv-&gt;text_info.length = 0;
762 }
763 static void
764 get_outline_glyph(ASS_Renderer *priv, GlyphInfo *info)
765 {
766     OutlineHashValue *val;
767     ASS_DVector scale, offset = {0};
768     int32_t asc, desc;
769     OutlineHashKey key;
770     if (info-&gt;drawing_text.str) {
771         key.type = OUTLINE_DRAWING;
772         key.u.drawing.text = info-&gt;drawing_text;
773         val = ass_cache_get(priv-&gt;cache.outline_cache, &amp;key, priv);
774         if (!val || !val-&gt;valid) {
775             ass_cache_dec_ref(val);
776             return;
777         }
778         int32_t scale_base = lshiftwrapi(1, info-&gt;drawing_scale - 1);
779         double w = scale_base &gt; 0 ? (priv-&gt;font_scale / scale_base) : 0;
780         scale.x = info-&gt;scale_x * w;
781         scale.y = info-&gt;scale_y * w;
782         desc = 64 * info-&gt;drawing_pbo;
783         asc = val-&gt;asc - desc;
784         offset.y = -asc * scale.y;
785     } else {
786         key.type = OUTLINE_GLYPH;
787         GlyphHashKey *k = &amp;key.u.glyph;
788         k-&gt;font = info-&gt;font;
789         k-&gt;size = info-&gt;font_size;
790         k-&gt;face_index = info-&gt;face_index;
791         k-&gt;glyph_index = info-&gt;glyph_index;
792         k-&gt;bold = info-&gt;bold;
793         k-&gt;italic = info-&gt;italic;
794         k-&gt;flags = info-&gt;flags;
795         val = ass_cache_get(priv-&gt;cache.outline_cache, &amp;key, priv);
796         if (!val || !val-&gt;valid) {
797             ass_cache_dec_ref(val);
798             return;
799         }
800         scale.x = info-&gt;scale_x;
801         scale.y = info-&gt;scale_y;
802         asc  = val-&gt;asc;
803         desc = val-&gt;desc;
804     }
805     info-&gt;outline = val;
806     info-&gt;transform.scale = scale;
807     info-&gt;transform.offset = offset;
808     info-&gt;bbox.x_min = lrint(val-&gt;cbox.x_min * scale.x + offset.x);
809     info-&gt;bbox.y_min = lrint(val-&gt;cbox.y_min * scale.y + offset.y);
810     info-&gt;bbox.x_max = lrint(val-&gt;cbox.x_max * scale.x + offset.x);
811     info-&gt;bbox.y_max = lrint(val-&gt;cbox.y_max * scale.y + offset.y);
812     if (info-&gt;drawing_text.str || priv-&gt;settings.shaper == ASS_SHAPING_SIMPLE) {
813         info-&gt;cluster_advance.x = info-&gt;advance.x = lrint(val-&gt;advance * scale.x);
814         info-&gt;cluster_advance.y = info-&gt;advance.y = 0;
815     }
816     info-&gt;asc  = lrint(asc  * scale.y);
817     info-&gt;desc = lrint(desc * scale.y);
818 }
819 size_t ass_outline_construct(void *key, void *value, void *priv)
820 {
821     ASS_Renderer *render_priv = priv;
822     OutlineHashKey *outline_key = key;
823     OutlineHashValue *v = value;
824     memset(v, 0, sizeof(*v));
825     switch (outline_key-&gt;type) {
826     case OUTLINE_GLYPH:
827         {
828             GlyphHashKey *k = &amp;outline_key-&gt;u.glyph;
829             ass_face_set_size(k-&gt;font-&gt;faces[k-&gt;face_index], k-&gt;size);
830             if (!ass_font_get_glyph(k-&gt;font, k-&gt;face_index, k-&gt;glyph_index,
831                                     render_priv-&gt;settings.hinting))
832                 return 1;
833             if (!ass_get_glyph_outline(&amp;v-&gt;outline[0], &amp;v-&gt;advance,
834                                        k-&gt;font-&gt;faces[k-&gt;face_index],
835                                        k-&gt;flags))
836                 return 1;
837             ass_font_get_asc_desc(k-&gt;font, k-&gt;face_index,
838                                   &amp;v-&gt;asc, &amp;v-&gt;desc);
839             break;
840         }
841     case OUTLINE_DRAWING:
842         {
843             ASS_Rect bbox;
844             const char *text = outline_key-&gt;u.drawing.text.str;              if (!ass_drawing_parse(&amp;v-&gt;outline[0], &amp;bbox, text, render_priv-&gt;library))
845                 return 1;
846             v-&gt;advance = bbox.x_max - bbox.x_min;
847             v-&gt;asc = bbox.y_max - bbox.y_min;
848             v-&gt;desc = 0;
849             break;
850         }
851     case OUTLINE_BORDER:
852         {
853             BorderHashKey *k = &amp;outline_key-&gt;u.border;
854             if (!k-&gt;border.x &amp;&amp; !k-&gt;border.y)
855                 break;
856             if (!k-&gt;outline-&gt;outline[0].n_points)
857                 break;
858             ASS_Outline src;
859             if (!outline_scale_pow2(&amp;src, &amp;k-&gt;outline-&gt;outline[0],
860                                     k-&gt;scale_ord_x, k-&gt;scale_ord_y))
861                 return 1;
862             if (!outline_stroke(&amp;v-&gt;outline[0], &amp;v-&gt;outline[1], &amp;src,
863                                 k-&gt;border.x * STROKER_PRECISION,
864                                 k-&gt;border.y * STROKER_PRECISION,
865                                 STROKER_PRECISION)) {
866                 ass_msg(render_priv-&gt;library, MSGL_WARN, "Cannot stroke outline");
867                 outline_free(&amp;v-&gt;outline[0]);
868                 outline_free(&amp;v-&gt;outline[1]);
869                 outline_free(&amp;src);
870                 return 1;
871             }
872             outline_free(&amp;src);
873             break;
874         }
875     case OUTLINE_BOX:
876         {
877             ASS_Outline *ol = &amp;v-&gt;outline[0];
878             if (!outline_alloc(ol, 4, 4))
879                 return 1;
880             ol-&gt;points[0].x = ol-&gt;points[3].x = 0;
881             ol-&gt;points[1].x = ol-&gt;points[2].x = 64;
882             ol-&gt;points[0].y = ol-&gt;points[1].y = 0;
883             ol-&gt;points[2].y = ol-&gt;points[3].y = 64;
884             ol-&gt;segments[0] = OUTLINE_LINE_SEGMENT;
885             ol-&gt;segments[1] = OUTLINE_LINE_SEGMENT;
886             ol-&gt;segments[2] = OUTLINE_LINE_SEGMENT;
887             ol-&gt;segments[3] = OUTLINE_LINE_SEGMENT | OUTLINE_CONTOUR_END;
888             ol-&gt;n_points = ol-&gt;n_segments = 4;
889             break;
890         }
891     default:
892         return 1;
893     }
894     rectangle_reset(&amp;v-&gt;cbox);
895     outline_update_cbox(&amp;v-&gt;outline[0], &amp;v-&gt;cbox);
896     outline_update_cbox(&amp;v-&gt;outline[1], &amp;v-&gt;cbox);
897     if (v-&gt;cbox.x_min &gt; v-&gt;cbox.x_max || v-&gt;cbox.y_min &gt; v-&gt;cbox.y_max)
898         v-&gt;cbox.x_min = v-&gt;cbox.y_min = v-&gt;cbox.x_max = v-&gt;cbox.y_max = 0;
899     v-&gt;valid = true;
900     return 1;
901 }
902 static void calc_transform_matrix(ASS_Renderer *render_priv,
903                                   GlyphInfo *info, double m[3][3])
904 {
905     double frx = ASS_PI / 180 * info-&gt;frx;
906     double fry = ASS_PI / 180 * info-&gt;fry;
907     double frz = ASS_PI / 180 * info-&gt;frz;
908     double sx = -sin(frx), cx = cos(frx);
909     double sy =  sin(fry), cy = cos(fry);
910     double sz = -sin(frz), cz = cos(frz);
911     double fax = info-&gt;fax * info-&gt;scale_x / info-&gt;scale_y;
912     double fay = info-&gt;fay * info-&gt;scale_y / info-&gt;scale_x;
913     double x1[3] = { 1, fax, info-&gt;shift.x + info-&gt;asc * fax };
914     double y1[3] = { fay, 1, info-&gt;shift.y };
915     double x2[3], y2[3];
916     for (int i = 0; i &lt; 3; i++) {
917         x2[i] = x1[i] * cz - y1[i] * sz;
918         y2[i] = x1[i] * sz + y1[i] * cz;
919     }
920     double y3[3], z3[3];
921     for (int i = 0; i &lt; 3; i++) {
922         y3[i] = y2[i] * cx;
923         z3[i] = y2[i] * sx;
924     }
925     double x4[3], z4[3];
926     for (int i = 0; i &lt; 3; i++) {
927         x4[i] = x2[i] * cy - z3[i] * sy;
928         z4[i] = x2[i] * sy + z3[i] * cy;
929     }
930     double dist = 20000 * render_priv-&gt;blur_scale;
931     z4[2] += dist;
932     double scale_x = dist * render_priv-&gt;font_scale_x;
933     double offs_x = info-&gt;pos.x - info-&gt;shift.x * render_priv-&gt;font_scale_x;
934     double offs_y = info-&gt;pos.y - info-&gt;shift.y;
935     for (int i = 0; i &lt; 3; i++) {
936         m[0][i] = z4[i] * offs_x + x4[i] * scale_x;
937         m[1][i] = z4[i] * offs_y + y3[i] * dist;
938         m[2][i] = z4[i];
939     }
940 }
941 static void
942 get_bitmap_glyph(ASS_Renderer *render_priv, GlyphInfo *info,
943                  int32_t *leftmost_x,
944                  ASS_Vector *pos, ASS_Vector *pos_o,
945                  ASS_DVector *offset, bool first, int flags)
946 {
947     if (!info-&gt;outline || info-&gt;symbol == '\n' || info-&gt;symbol == 0 || info-&gt;skip) {
948         ass_cache_dec_ref(info-&gt;outline);
949         return;
950     }
951     double m1[3][3], m2[3][3], m[3][3];
952     const ASS_Transform *tr = &amp;info-&gt;transform;
953     calc_transform_matrix(render_priv, info, m1);
954     for (int i = 0; i &lt; 3; i++) {
955         m2[i][0] = m1[i][0] * tr-&gt;scale.x;
956         m2[i][1] = m1[i][1] * tr-&gt;scale.y;
957         m2[i][2] = m1[i][0] * tr-&gt;offset.x + m1[i][1] * tr-&gt;offset.y + m1[i][2];
958     }
959     memcpy(m, m2, sizeof(m));
960     if (info-&gt;effect_type == EF_KARAOKE_KF)
961         outline_update_min_transformed_x(&amp;info-&gt;outline-&gt;outline[0], m, leftmost_x);
962     BitmapHashKey key;
963     key.outline = info-&gt;outline;
964     if (!quantize_transform(m, pos, offset, first, &amp;key)) {
965         ass_cache_dec_ref(info-&gt;outline);
966         return;
967     }
968     info-&gt;bm = ass_cache_get(render_priv-&gt;cache.bitmap_cache, &amp;key, render_priv);
969     if (!info-&gt;bm || !info-&gt;bm-&gt;buffer) {
970         ass_cache_dec_ref(info-&gt;bm);
971         info-&gt;bm = NULL;
972     }
973     *pos_o = *pos;
974     OutlineHashKey ol_key;
975     if (flags &amp; FILTER_BORDER_STYLE_3) {
976         if (!(flags &amp; (FILTER_NONZERO_BORDER | FILTER_NONZERO_SHADOW)))
977             return;
978         ol_key.type = OUTLINE_BOX;
979         double w = 64 * render_priv-&gt;border_scale;
980         ASS_DVector bord = { info-&gt;border_x * w, info-&gt;border_y * w };
981         double width = info-&gt;hspacing_scaled + info-&gt;advance.x;
982         double height = info-&gt;asc + info-&gt;desc;
983         ASS_DVector orig_scale;
984         orig_scale.x = info-&gt;scale_x * info-&gt;scale_fix;
985         orig_scale.y = info-&gt;scale_y * info-&gt;scale_fix;
986         bord.x *= orig_scale.x;
987         bord.y *= orig_scale.y;
988         width  *= orig_scale.x;
989         height *= orig_scale.y;
990         bord.x = FFMAX(64, bord.x);
991         bord.y = FFMAX(64, bord.y);
992         ASS_DVector scale = {
993             (width  + 2 * bord.x) / 64,
994             (height + 2 * bord.y) / 64,
995         };
996         ASS_DVector offset = { -bord.x, -bord.y - info-&gt;asc };
997         for (int i = 0; i &lt; 3; i++) {
998             m[i][0] = m1[i][0] * scale.x;
999             m[i][1] = m1[i][1] * scale.y;
1000             m[i][2] = m1[i][0] * offset.x + m1[i][1] * offset.y + m1[i][2];
1001         }
1002     } else {
1003         if (!(flags &amp; FILTER_NONZERO_BORDER))
1004             return;
1005         ol_key.type = OUTLINE_BORDER;
1006         BorderHashKey *k = &amp;ol_key.u.border;
1007         k-&gt;outline = info-&gt;outline;
1008         double w = 64 * render_priv-&gt;border_scale;
1009         double bord_x = w * info-&gt;border_x / tr-&gt;scale.x;
1010         double bord_y = w * info-&gt;border_y / tr-&gt;scale.y;
1011         const ASS_Rect *bbox = &amp;info-&gt;outline-&gt;cbox;
1012         double dx = (bbox-&gt;x_max - bbox-&gt;x_min) / 2.0 + (bord_x + 64);
1013         double dy = (bbox-&gt;y_max - bbox-&gt;y_min) / 2.0 + (bord_y + 64);
1014         double mxx = fabs(m[0][0]), mxy = fabs(m[0][1]);
1015         double myx = fabs(m[1][0]), myy = fabs(m[1][1]);
1016         double mzx = fabs(m[2][0]), mzy = fabs(m[2][1]);
1017         double z0 = m[2][2] - mzx * dx - mzy * dy;
1018         w = 1 / FFMAX(z0, m[2][2] / MAX_PERSP_SCALE);
1019         double x_lim = mxx * dx + mxy * dy;
1020         double y_lim = myx * dx + myy * dy;
1021         double rz = FFMAX(x_lim, y_lim) * w;
1022         w *= STROKER_PRECISION / POSITION_PRECISION;
1023         frexp(w * (FFMAX(mxx, myx) + mzx * rz), &amp;k-&gt;scale_ord_x);
1024         frexp(w * (FFMAX(mxy, myy) + mzy * rz), &amp;k-&gt;scale_ord_y);
1025         bord_x = ldexp(bord_x, k-&gt;scale_ord_x);
1026         bord_y = ldexp(bord_y, k-&gt;scale_ord_y);
1027         if (!(bord_x &lt; OUTLINE_MAX &amp;&amp; bord_y &lt; OUTLINE_MAX))
1028             return;
1029         k-&gt;border.x = lrint(bord_x / STROKER_PRECISION);
1030         k-&gt;border.y = lrint(bord_y / STROKER_PRECISION);
1031         if (!k-&gt;border.x &amp;&amp; !k-&gt;border.y) {
1032             ass_cache_inc_ref(info-&gt;bm);
1033             info-&gt;bm_o = info-&gt;bm;
1034             return;
1035         }
1036         for (int i = 0; i &lt; 3; i++) {
1037             m[i][0] = ldexp(m2[i][0], -k-&gt;scale_ord_x);
1038             m[i][1] = ldexp(m2[i][1], -k-&gt;scale_ord_y);
1039             m[i][2] = m2[i][2];
1040         }
1041     }
1042     key.outline = ass_cache_get(render_priv-&gt;cache.outline_cache, &amp;ol_key, render_priv);
1043     if (!key.outline || !key.outline-&gt;valid ||
1044             !quantize_transform(m, pos_o, offset, false, &amp;key)) {
1045         ass_cache_dec_ref(key.outline);
1046         return;
1047     }
1048     info-&gt;bm_o = ass_cache_get(render_priv-&gt;cache.bitmap_cache, &amp;key, render_priv);
1049     if (!info-&gt;bm_o || !info-&gt;bm_o-&gt;buffer) {
1050         ass_cache_dec_ref(info-&gt;bm_o);
1051         info-&gt;bm_o = NULL;
1052         *pos_o = *pos;
1053     } else if (!info-&gt;bm)
1054         *pos = *pos_o;
1055 }
1056 size_t ass_bitmap_construct(void *key, void *value, void *priv)
1057 {
1058     ASS_Renderer *render_priv = priv;
1059     BitmapHashKey *k = key;
1060     Bitmap *bm = value;
1061     double m[3][3];
1062     restore_transform(m, k);
1063     ASS_Outline outline[2];
1064     if (k-&gt;matrix_z.x || k-&gt;matrix_z.y) {
1065         outline_transform_3d(&amp;outline[0], &amp;k-&gt;outline-&gt;outline[0], m);
1066         outline_transform_3d(&amp;outline[1], &amp;k-&gt;outline-&gt;outline[1], m);
1067     } else {
1068         outline_transform_2d(&amp;outline[0], &amp;k-&gt;outline-&gt;outline[0], m);
1069         outline_transform_2d(&amp;outline[1], &amp;k-&gt;outline-&gt;outline[1], m);
1070     }
1071     if (!outline_to_bitmap(render_priv, bm, &amp;outline[0], &amp;outline[1]))
1072         memset(bm, 0, sizeof(*bm));
1073     outline_free(&amp;outline[0]);
1074     outline_free(&amp;outline[1]);
1075     return sizeof(BitmapHashKey) + sizeof(Bitmap) + bitmap_size(bm);
1076 }
1077 static void measure_text_on_eol(ASS_Renderer *render_priv, double scale, int cur_line,
1078                                 int max_asc, int max_desc,
1079                                 double max_border_x, double max_border_y)
1080 {
1081     render_priv-&gt;text_info.lines[cur_line].asc  = scale * max_asc;
1082     render_priv-&gt;text_info.lines[cur_line].desc = scale * max_desc;
1083     render_priv-&gt;text_info.height += scale * max_asc + scale * max_desc;
1084     render_priv-&gt;text_info.border_bottom = (int) (render_priv-&gt;border_scale * max_border_y + 0.5);
1085     if (cur_line == 0)
1086         render_priv-&gt;text_info.border_top = render_priv-&gt;text_info.border_bottom;
1087     render_priv-&gt;text_info.border_x = FFMAX(render_priv-&gt;text_info.border_x,
1088             (int) (render_priv-&gt;border_scale * max_border_x + 0.5));
1089 }
1090 static void measure_text(ASS_Renderer *render_priv)
1091 {
1092     TextInfo *text_info = &amp;render_priv-&gt;text_info;
1093     text_info-&gt;height = 0;
1094     text_info-&gt;border_x = 0;
1095     int cur_line = 0;
1096     double scale = 0.5 / 64;
1097     int max_asc = 0, max_desc = 0;
1098     double max_border_y = 0, max_border_x = 0;
1099     bool empty_trimmed_line = true;
1100     for (int i = 0; i &lt; text_info-&gt;length; i++) {
1101         if (text_info-&gt;glyphs[i].linebreak) {
1102             measure_text_on_eol(render_priv, scale, cur_line,
1103                     max_asc, max_desc, max_border_x, max_border_y);
1104             empty_trimmed_line = true;
1105             max_asc = max_desc = 0;
1106             max_border_y = max_border_x = 0;
1107             scale = 0.5 / 64;
1108             cur_line++;
1109         }
1110         GlyphInfo *cur = text_info-&gt;glyphs + i;
1111         if (empty_trimmed_line &amp;&amp; !cur-&gt;is_trimmed_whitespace) {
1112             empty_trimmed_line = false;
1113             max_asc = max_desc = 0;
1114             max_border_y = max_border_x = 0;
1115         } else if (!empty_trimmed_line &amp;&amp; cur-&gt;is_trimmed_whitespace) {
1116             continue;
1117         }
1118         max_asc  = FFMAX(max_asc,  cur-&gt;asc);
1119         max_desc = FFMAX(max_desc, cur-&gt;desc);
1120         max_border_y = FFMAX(max_border_y, cur-&gt;border_y);
1121         max_border_x = FFMAX(max_border_x, cur-&gt;border_x);
1122         if (cur-&gt;symbol != '\n')
1123             scale = 1.0 / 64;
1124     }
1125     assert(cur_line == text_info-&gt;n_lines - 1);
1126     measure_text_on_eol(render_priv, scale, cur_line,
1127             max_asc, max_desc, max_border_x, max_border_y);
1128     text_info-&gt;height += cur_line * render_priv-&gt;settings.line_spacing;
1129 }
1130 #define IS_WHITESPACE(x) ((x-&gt;symbol == ' ' || x-&gt;symbol == '\n') \
1131                           &amp;&amp; !x-&gt;linebreak)
1132 static void trim_whitespace(ASS_Renderer *render_priv)
1133 {
1134     int i, j;
1135     GlyphInfo *cur;
1136     TextInfo *ti = &amp;render_priv-&gt;text_info;
1137     i = ti-&gt;length - 1;
1138     cur = ti-&gt;glyphs + i;
1139     while (i &amp;&amp; IS_WHITESPACE(cur)) {
1140         cur-&gt;skip = true;
1141         cur-&gt;is_trimmed_whitespace = true;
1142         cur = ti-&gt;glyphs + --i;
1143     }
1144     i = 0;
1145     cur = ti-&gt;glyphs;
1146     while (i &lt; ti-&gt;length &amp;&amp; IS_WHITESPACE(cur)) {
1147         cur-&gt;skip = true;
1148         cur-&gt;is_trimmed_whitespace = true;
1149         cur = ti-&gt;glyphs + ++i;
1150     }
1151     if (i &lt; ti-&gt;length)
1152         cur-&gt;starts_new_run = true;
1153     for (i = 0; i &lt; ti-&gt;length; ++i) {
1154         cur = ti-&gt;glyphs + i;
1155         if (cur-&gt;linebreak) {
1156             j = i - 1;
1157             cur = ti-&gt;glyphs + j;
1158             while (j &amp;&amp; IS_WHITESPACE(cur)) {
1159                 cur-&gt;skip = true;
1160                 cur-&gt;is_trimmed_whitespace = true;
1161                 cur = ti-&gt;glyphs + --j;
1162             }
1163             cur = ti-&gt;glyphs + i;
1164             if (cur-&gt;symbol == ' ' || cur-&gt;symbol == '\n') {
1165                 cur-&gt;skip = true;
1166                 cur-&gt;is_trimmed_whitespace = true;
1167                 j = i + 1;
1168                 cur = ti-&gt;glyphs + j;
1169                 while (j &lt; ti-&gt;length &amp;&amp; IS_WHITESPACE(cur)) {
1170                     cur-&gt;skip = true;
1171                     cur-&gt;is_trimmed_whitespace = true;
1172                     cur = ti-&gt;glyphs + ++j;
1173                 }
1174                 i = j - 1;
1175             }
1176             if (cur &lt; ti-&gt;glyphs + ti-&gt;length)
1177                 cur-&gt;starts_new_run = true;
1178         }
1179     }
1180 }
1181 #undef IS_WHITESPACE
1182 static void
1183 wrap_lines_smart(ASS_Renderer *render_priv, double max_text_width)
1184 {
1185     int i;
1186     GlyphInfo *cur, *s1, *e1, *s2, *s3;
1187     int last_space;
1188     int break_type;
1189     int exit;
1190     double pen_shift_x;
1191     double pen_shift_y;
1192     int cur_line;
1193     TextInfo *text_info = &amp;render_priv-&gt;text_info;
1194     last_space = -1;
1195     text_info-&gt;n_lines = 1;
1196     break_type = 0;
1197     s1 = text_info-&gt;glyphs;         for (i = 0; i &lt; text_info-&gt;length; ++i) {
1198         int break_at = -1;
1199         double s_offset, len;
1200         cur = text_info-&gt;glyphs + i;
1201         s_offset = d6_to_double(s1-&gt;bbox.x_min + s1-&gt;pos.x);
1202         len = d6_to_double(cur-&gt;bbox.x_max + cur-&gt;pos.x) - s_offset;
1203         if (cur-&gt;symbol == '\n') {
1204             break_type = 2;
1205             break_at = i;
1206             ass_msg(render_priv-&gt;library, MSGL_DBG2,
1207                     "forced line break at %d", break_at);
1208         } else if (cur-&gt;symbol == ' ') {
1209             last_space = i;
1210         } else if (len &gt;= max_text_width
1211                    &amp;&amp; (render_priv-&gt;state.wrap_style != 2)) {
1212             break_type = 1;
1213             break_at = last_space;
1214             if (break_at &gt;= 0)
1215                 ass_msg(render_priv-&gt;library, MSGL_DBG2, "line break at %d",
1216                         break_at);
1217         }
1218         if (break_at != -1) {
1219             int lead = break_at + 1;                if (text_info-&gt;n_lines &gt;= text_info-&gt;max_lines) {
1220                 text_info-&gt;max_lines *= 2;
1221                 text_info-&gt;lines = realloc(text_info-&gt;lines,
1222                                            sizeof(LineInfo) *
1223                                            text_info-&gt;max_lines);
1224             }
1225             if (lead &lt; text_info-&gt;length) {
1226                 text_info-&gt;glyphs[lead].linebreak = break_type;
1227                 last_space = -1;
1228                 s1 = text_info-&gt;glyphs + lead;
1229                 text_info-&gt;n_lines++;
1230             }
1231         }
1232     }
1233 #define DIFF(x,y) (((x) &lt; (y)) ? (y - x) : (x - y))
1234     exit = 0;
1235     while (!exit &amp;&amp; render_priv-&gt;state.wrap_style != 1) {
1236         exit = 1;
1237         s3 = text_info-&gt;glyphs;
1238         s1 = s2 = 0;
1239         for (i = 0; i &lt;= text_info-&gt;length; ++i) {
1240             cur = text_info-&gt;glyphs + i;
1241             if ((i == text_info-&gt;length) || cur-&gt;linebreak) {
1242                 s1 = s2;
1243                 s2 = s3;
1244                 s3 = cur;
1245                 if (s1 &amp;&amp; (s2-&gt;linebreak == 1)) {                           double l1, l2, l1_new, l2_new;
1246                     GlyphInfo *w = s2;
1247                     do {
1248                         --w;
1249                     } while ((w &gt; s1) &amp;&amp; (w-&gt;symbol == ' '));
1250                     while ((w &gt; s1) &amp;&amp; (w-&gt;symbol != ' ')) {
1251                         --w;
1252                     }
1253                     e1 = w;
1254                     while ((e1 &gt; s1) &amp;&amp; (e1-&gt;symbol == ' ')) {
1255                         --e1;
1256                     }
1257                     if (w-&gt;symbol == ' ')
1258                         ++w;
1259                     l1 = d6_to_double(((s2 - 1)-&gt;bbox.x_max + (s2 - 1)-&gt;pos.x) -
1260                         (s1-&gt;bbox.x_min + s1-&gt;pos.x));
1261                     l2 = d6_to_double(((s3 - 1)-&gt;bbox.x_max + (s3 - 1)-&gt;pos.x) -
1262                         (s2-&gt;bbox.x_min + s2-&gt;pos.x));
1263                     l1_new = d6_to_double(
1264                         (e1-&gt;bbox.x_max + e1-&gt;pos.x) -
1265                         (s1-&gt;bbox.x_min + s1-&gt;pos.x));
1266                     l2_new = d6_to_double(
1267                         ((s3 - 1)-&gt;bbox.x_max + (s3 - 1)-&gt;pos.x) -
1268                         (w-&gt;bbox.x_min + w-&gt;pos.x));
1269                     if (DIFF(l1_new, l2_new) &lt; DIFF(l1, l2)) {
1270                         if (w-&gt;linebreak || w == text_info-&gt;glyphs)
1271                             text_info-&gt;n_lines--;
1272                         if (w != text_info-&gt;glyphs)
1273                             w-&gt;linebreak = 1;
1274                         s2-&gt;linebreak = 0;
1275                         exit = 0;
1276                     }
1277                 }
1278             }
1279             if (i == text_info-&gt;length)
1280                 break;
1281         }
1282     }
1283     assert(text_info-&gt;n_lines &gt;= 1);
1284 #undef DIFF
1285     trim_whitespace(render_priv);
1286     measure_text(render_priv);
1287     cur_line = 1;
1288     i = 0;
1289     cur = text_info-&gt;glyphs + i;
1290     while (i &lt; text_info-&gt;length &amp;&amp; cur-&gt;skip)
1291         cur = text_info-&gt;glyphs + ++i;
1292     pen_shift_x = d6_to_double(-cur-&gt;pos.x);
1293     pen_shift_y = 0.;
1294     for (i = 0; i &lt; text_info-&gt;length; ++i) {
1295         cur = text_info-&gt;glyphs + i;
1296         if (cur-&gt;linebreak) {
1297             while (i &lt; text_info-&gt;length &amp;&amp; cur-&gt;skip &amp;&amp; cur-&gt;symbol != '\n')
1298                 cur = text_info-&gt;glyphs + ++i;
1299             double height =
1300                 text_info-&gt;lines[cur_line - 1].desc +
1301                 text_info-&gt;lines[cur_line].asc;
1302             text_info-&gt;lines[cur_line - 1].len = i -
1303                 text_info-&gt;lines[cur_line - 1].offset;
1304             text_info-&gt;lines[cur_line].offset = i;
1305             cur_line++;
1306             pen_shift_x = d6_to_double(-cur-&gt;pos.x);
1307             pen_shift_y += height + render_priv-&gt;settings.line_spacing;
1308         }
1309         cur-&gt;pos.x += double_to_d6(pen_shift_x);
1310         cur-&gt;pos.y += double_to_d6(pen_shift_y);
1311     }
1312     text_info-&gt;lines[cur_line - 1].len =
1313         text_info-&gt;length - text_info-&gt;lines[cur_line - 1].offset;
1314 #if 0
1315     for (i = 0; i &lt; text_info-&gt;n_lines; i++) {
1316         printf("line %d offset %d length %d\n", i, text_info-&gt;lines[i].offset,
1317                 text_info-&gt;lines[i].len);
1318     }
1319 #endif
1320 }
1321 static void get_base_point(ASS_DRect *bbox, int alignment, double *bx, double *by)
1322 {
1323     const int halign = alignment &amp; 3;
1324     const int valign = alignment &amp; 12;
1325     if (bx)
1326         switch (halign) {
1327         case HALIGN_LEFT:
1328             *bx = bbox-&gt;x_min;
1329             break;
1330         case HALIGN_CENTER:
1331             *bx = (bbox-&gt;x_max + bbox-&gt;x_min) / 2.0;
1332             break;
1333         case HALIGN_RIGHT:
1334             *bx = bbox-&gt;x_max;
1335             break;
1336         }
1337     if (by)
1338         switch (valign) {
1339         case VALIGN_TOP:
1340             *by = bbox-&gt;y_min;
1341             break;
1342         case VALIGN_CENTER:
1343             *by = (bbox-&gt;y_max + bbox-&gt;y_min) / 2.0;
1344             break;
1345         case VALIGN_SUB:
1346             *by = bbox-&gt;y_max;
1347             break;
1348         }
1349 }
1350 static void
1351 fix_glyph_scaling(ASS_Renderer *priv, GlyphInfo *glyph)
1352 {
1353     double ft_size;
1354     if (priv-&gt;settings.hinting == ASS_HINTING_NONE) {
1355         ft_size = 256.0;
1356     } else {
1357         ft_size = glyph-&gt;scale_y * glyph-&gt;font_size;
1358     }
1359     double mul = glyph-&gt;font_size / ft_size;
1360     glyph-&gt;scale_fix = 1 / mul;
1361     glyph-&gt;scale_x *= mul;
1362     glyph-&gt;scale_y *= mul;
1363     glyph-&gt;font_size = ft_size;
1364 }
1365 static void split_style_runs(ASS_Renderer *render_priv)
1366 {
1367     Effect last_effect_type = render_priv-&gt;text_info.glyphs[0].effect_type;
1368     render_priv-&gt;text_info.glyphs[0].starts_new_run = true;
1369     for (int i = 1; i &lt; render_priv-&gt;text_info.length; i++) {
1370         GlyphInfo *info = render_priv-&gt;text_info.glyphs + i;
1371         GlyphInfo *last = render_priv-&gt;text_info.glyphs + (i - 1);
1372         Effect effect_type = info-&gt;effect_type;
1373         info-&gt;starts_new_run =
1374             info-&gt;effect_timing ||              (effect_type != EF_NONE &amp;&amp; effect_type != last_effect_type) ||
1375             info-&gt;drawing_text.str ||
1376             last-&gt;drawing_text.str ||
1377             !ass_string_equal(last-&gt;font-&gt;desc.family, info-&gt;font-&gt;desc.family) ||
1378             last-&gt;font-&gt;desc.vertical != info-&gt;font-&gt;desc.vertical ||
1379             last-&gt;font_size != info-&gt;font_size ||
1380             last-&gt;c[0] != info-&gt;c[0] ||
1381             last-&gt;c[1] != info-&gt;c[1] ||
1382             last-&gt;c[2] != info-&gt;c[2] ||
1383             last-&gt;c[3] != info-&gt;c[3] ||
1384             last-&gt;be != info-&gt;be ||
1385             last-&gt;blur != info-&gt;blur ||
1386             last-&gt;shadow_x != info-&gt;shadow_x ||
1387             last-&gt;shadow_y != info-&gt;shadow_y ||
1388             last-&gt;frx != info-&gt;frx ||
1389             last-&gt;fry != info-&gt;fry ||
1390             last-&gt;frz != info-&gt;frz ||
1391             last-&gt;fax != info-&gt;fax ||
1392             last-&gt;fay != info-&gt;fay ||
1393             last-&gt;scale_x != info-&gt;scale_x ||
1394             last-&gt;scale_y != info-&gt;scale_y ||
1395             last-&gt;border_style != info-&gt;border_style ||
1396             last-&gt;border_x != info-&gt;border_x ||
1397             last-&gt;border_y != info-&gt;border_y ||
1398             last-&gt;hspacing != info-&gt;hspacing ||
1399             last-&gt;italic != info-&gt;italic ||
1400             last-&gt;bold != info-&gt;bold ||
1401             ((last-&gt;flags ^ info-&gt;flags) &amp; ~DECO_ROTATE);
1402         if (effect_type != EF_NONE)
1403             last_effect_type = effect_type;
1404     }
1405 }
1406 static bool parse_events(ASS_Renderer *render_priv, ASS_Event *event)
1407 {
1408     TextInfo *text_info = &amp;render_priv-&gt;text_info;
1409     char *p = event-&gt;Text, *q;
1410     while (true) {
1411         ASS_StringView drawing_text = {NULL, 0};
1412         unsigned code = 0;
1413         while (*p) {
1414             if ((*p == '{') &amp;&amp; (q = strchr(p, '}'))) {
1415                 p = parse_tags(render_priv, p, q, 1., false);
1416                 assert(*p == '}');
1417                 p++;
1418             } else if (render_priv-&gt;state.drawing_scale) {
1419                 q = p;
1420                 if (*p == '{')
1421                     q++;
1422                 while ((*q != '{') &amp;&amp; (*q != 0))
1423                     q++;
1424                 drawing_text.str = p;
1425                 drawing_text.len = q - p;
1426                 code = 0xfffc;                 p = q;
1427                 break;
1428             } else {
1429                 code = get_next_char(render_priv, &amp;p);
1430                 break;
1431             }
1432         }
1433         if (code == 0)
1434             break;
1435         if (!render_priv-&gt;state.font)
1436             goto fail;
1437         if (text_info-&gt;length &gt;= text_info-&gt;max_glyphs) {
1438             int new_max = 2 * FFMIN(text_info-&gt;max_glyphs, INT_MAX / 2);
1439             if (text_info-&gt;length &gt;= new_max)
1440                 goto fail;
1441             if (!ASS_REALLOC_ARRAY(text_info-&gt;glyphs, new_max))
1442                 goto fail;
1443             text_info-&gt;max_glyphs = new_max;
1444         }
1445         GlyphInfo *info = &amp;text_info-&gt;glyphs[text_info-&gt;length];
1446         memset(info, 0, sizeof(GlyphInfo));
1447         if (drawing_text.str) {
1448             info-&gt;drawing_text = drawing_text;
1449             info-&gt;drawing_scale = render_priv-&gt;state.drawing_scale;
1450             info-&gt;drawing_pbo = render_priv-&gt;state.pbo;
1451         }
1452         info-&gt;symbol = code;
1453         info-&gt;font = render_priv-&gt;state.font;
1454         if (!drawing_text.str)
1455             ass_cache_inc_ref(info-&gt;font);
1456         for (int i = 0; i &lt; 4; i++) {
1457             uint32_t clr = render_priv-&gt;state.c[i];
1458             info-&gt;a_pre_fade[i] = _a(clr);
1459             if (render_priv-&gt;state.fade &gt; 0)
1460                 change_alpha(&amp;clr,
1461                              mult_alpha(_a(clr), render_priv-&gt;state.fade), 1.);
1462             info-&gt;c[i] = clr;
1463         }
1464         info-&gt;effect_type = render_priv-&gt;state.effect_type;
1465         info-&gt;effect_timing = render_priv-&gt;state.effect_timing;
1466         info-&gt;effect_skip_timing = render_priv-&gt;state.effect_skip_timing;
1467         info-&gt;font_size =
1468             fabs(render_priv-&gt;state.font_size * render_priv-&gt;font_scale);
1469         info-&gt;be = render_priv-&gt;state.be;
1470         info-&gt;blur = render_priv-&gt;state.blur;
1471         info-&gt;shadow_x = render_priv-&gt;state.shadow_x;
1472         info-&gt;shadow_y = render_priv-&gt;state.shadow_y;
1473         info-&gt;scale_x = render_priv-&gt;state.scale_x;
1474         info-&gt;scale_y = render_priv-&gt;state.scale_y;
1475         info-&gt;border_style = render_priv-&gt;state.border_style;
1476         info-&gt;border_x = render_priv-&gt;state.border_x;
1477         info-&gt;border_y = render_priv-&gt;state.border_y;
1478         info-&gt;hspacing = render_priv-&gt;state.hspacing;
1479         info-&gt;bold = render_priv-&gt;state.bold;
1480         info-&gt;italic = render_priv-&gt;state.italic;
1481         info-&gt;flags = render_priv-&gt;state.flags;
1482         if (info-&gt;font-&gt;desc.vertical &amp;&amp; code &gt;= VERTICAL_LOWER_BOUND)
1483             info-&gt;flags |= DECO_ROTATE;
1484         info-&gt;frx = render_priv-&gt;state.frx;
1485         info-&gt;fry = render_priv-&gt;state.fry;
1486         info-&gt;frz = render_priv-&gt;state.frz;
1487         info-&gt;fax = render_priv-&gt;state.fax;
1488         info-&gt;fay = render_priv-&gt;state.fay;
1489         info-&gt;fade = render_priv-&gt;state.fade;
1490         info-&gt;hspacing_scaled = 0;
1491         info-&gt;scale_fix = 1;
1492         if (!drawing_text.str) {
1493             info-&gt;hspacing_scaled = double_to_d6(info-&gt;hspacing *
1494                     render_priv-&gt;font_scale * info-&gt;scale_x);
1495             fix_glyph_scaling(render_priv, info);
1496         }
1497         text_info-&gt;length++;
1498         render_priv-&gt;state.effect_type = EF_NONE;
1499         render_priv-&gt;state.effect_timing = 0;
1500         render_priv-&gt;state.effect_skip_timing = 0;
1501     }
1502     return true;
1503 fail:
1504     free_render_context(render_priv);
1505     return false;
1506 }
1507 static void retrieve_glyphs(ASS_Renderer *render_priv)
1508 {
1509     GlyphInfo *glyphs = render_priv-&gt;text_info.glyphs;
1510     int i;
1511     for (i = 0; i &lt; render_priv-&gt;text_info.length; i++) {
1512         GlyphInfo *info = glyphs + i;
1513         do {
1514             get_outline_glyph(render_priv, info);
1515             info = info-&gt;next;
1516         } while (info);
1517         info = glyphs + i;
1518         if (i &amp;&amp; glyphs[i - 1].italic &amp;&amp; !info-&gt;italic) {
1519             int back = i - 1;
1520             GlyphInfo *og = &amp;glyphs[back];
1521             while (back &amp;&amp; og-&gt;bbox.x_max - og-&gt;bbox.x_min == 0
1522                     &amp;&amp; og-&gt;italic)
1523                 og = &amp;glyphs[--back];
1524             if (og-&gt;bbox.x_max &gt; og-&gt;cluster_advance.x)
1525                 og-&gt;cluster_advance.x = og-&gt;bbox.x_max;
1526         }
1527         info-&gt;cluster_advance.x += info-&gt;hspacing_scaled;
1528     }
1529 }
1530 <a name="2"></a>static void preliminary_layout(ASS_Renderer *render_priv)
1531 {
1532     ASS_Vector pen = { 0, 0 };
1533 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    for (int i = 0; i &lt; render_priv-&gt;text_info.length; i++) {
1534         GlyphInfo *info = render_priv-&gt;text_info.glyphs + i;
1535         ASS_Vector cluster_pen = pen;
1536         do {
1537             info-&gt;pos.x = cluster_pen.x;
1538             info-&gt;pos.y = cluster_pen.y;
1539             cluster_pen.x += info-&gt;advance.x;
1540             cluster_pen.y += info-&gt;advance.y;
1541             info = info-&gt;next;
1542         } while (info);
1543         info = render_priv-&gt;text_info.glyphs + i;</b></font>
1544         pen.x += info-&gt;cluster_advance.x;
1545         pen.y += info-&gt;cluster_advance.y;
1546     }
1547 }
1548 static void reorder_text(ASS_Renderer *render_priv)
1549 {
1550     TextInfo *text_info = &amp;render_priv-&gt;text_info;
1551     FriBidiStrIndex *cmap = ass_shaper_reorder(render_priv-&gt;shaper, text_info);
1552     if (!cmap) {
1553         ass_msg(render_priv-&gt;library, MSGL_ERR, "Failed to reorder text");
1554         ass_shaper_cleanup(render_priv-&gt;shaper, text_info);
1555         free_render_context(render_priv);
1556         return;
1557     }
1558     ASS_Vector pen = { 0, 0 };
1559     int lineno = 1;
1560     for (int i = 0; i &lt; text_info-&gt;length; i++) {
1561         GlyphInfo *info = text_info-&gt;glyphs + cmap[i];
1562         if (text_info-&gt;glyphs[i].linebreak) {
1563             pen.x = 0;
1564             pen.y += double_to_d6(text_info-&gt;lines[lineno-1].desc);
1565             pen.y += double_to_d6(text_info-&gt;lines[lineno].asc);
1566             pen.y += double_to_d6(render_priv-&gt;settings.line_spacing);
1567             lineno++;
1568         }
1569         if (info-&gt;skip)
1570             continue;
1571         ASS_Vector cluster_pen = pen;
1572         pen.x += info-&gt;cluster_advance.x;
1573         pen.y += info-&gt;cluster_advance.y;
1574         while (info) {
1575             info-&gt;pos.x = info-&gt;offset.x + cluster_pen.x;
1576             info-&gt;pos.y = info-&gt;offset.y + cluster_pen.y;
1577             cluster_pen.x += info-&gt;advance.x;
1578             cluster_pen.y += info-&gt;advance.y;
1579             info = info-&gt;next;
1580         }
1581     }
1582 }
1583 static void apply_baseline_shear(ASS_Renderer *render_priv)
1584 {
1585     TextInfo *text_info = &amp;render_priv-&gt;text_info;
1586     FriBidiStrIndex *cmap = ass_shaper_get_reorder_map(render_priv-&gt;shaper);
1587     int32_t shear = 0;
1588     bool whole_text_layout =
1589         render_priv-&gt;track-&gt;parser_priv-&gt;feature_flags &amp;
1590         FEATURE_MASK(ASS_FEATURE_WHOLE_TEXT_LAYOUT);
1591     for (int i = 0; i &lt; text_info-&gt;length; i++) {
1592         GlyphInfo *info = text_info-&gt;glyphs + cmap[i];
1593         if (text_info-&gt;glyphs[i].linebreak ||
1594             (!whole_text_layout &amp;&amp; text_info-&gt;glyphs[i].starts_new_run))
1595             shear = 0;
1596         if (!info-&gt;scale_x || !info-&gt;scale_y)
1597             info-&gt;skip = true;
1598         if (info-&gt;skip)
1599             continue;
1600         for (GlyphInfo *cur = info; cur; cur = cur-&gt;next)
1601             cur-&gt;pos.y += shear;
1602         shear += (info-&gt;fay / info-&gt;scale_x * info-&gt;scale_y) * info-&gt;cluster_advance.x;
1603     }
1604 }
1605 static void align_lines(ASS_Renderer *render_priv, double max_text_width)
1606 {
1607     TextInfo *text_info = &amp;render_priv-&gt;text_info;
1608     GlyphInfo *glyphs = text_info-&gt;glyphs;
1609     int i, j;
1610     double width = 0;
1611     int last_break = -1;
1612     int halign = render_priv-&gt;state.alignment &amp; 3;
1613     int justify = render_priv-&gt;state.justify;
1614     double max_width = 0;
1615     if (render_priv-&gt;state.evt_type &amp; EVENT_HSCROLL) {
1616         justify = halign;
1617         halign = HALIGN_LEFT;
1618     }
1619     for (i = 0; i &lt;= text_info-&gt;length; ++i) {           if ((i == text_info-&gt;length) || glyphs[i].linebreak) {
1620             max_width = FFMAX(max_width,width);
1621             width = 0;
1622         }
1623         if (i &lt; text_info-&gt;length &amp;&amp; !glyphs[i].skip &amp;&amp;
1624                 glyphs[i].symbol != '\n' &amp;&amp; glyphs[i].symbol != 0) {
1625             width += d6_to_double(glyphs[i].cluster_advance.x);
1626         }
1627     }
1628     for (i = 0; i &lt;= text_info-&gt;length; ++i) {           if ((i == text_info-&gt;length) || glyphs[i].linebreak) {
1629             double shift = 0;
1630             if (halign == HALIGN_LEFT) {                    if (justify == ASS_JUSTIFY_RIGHT) {
1631                     shift = max_width - width;
1632                 } else if (justify == ASS_JUSTIFY_CENTER) {
1633                     shift = (max_width - width) / 2.0;
1634                 } else {
1635                     shift = 0;
1636                 }
1637             } else if (halign == HALIGN_RIGHT) {                    if (justify == ASS_JUSTIFY_LEFT) {
1638                     shift = max_text_width - max_width;
1639                 } else if (justify == ASS_JUSTIFY_CENTER) {
1640                     shift = max_text_width - max_width + (max_width - width) / 2.0;
1641                 } else {
1642                     shift = max_text_width - width;
1643                 }
1644             } else if (halign == HALIGN_CENTER) {                   if (justify == ASS_JUSTIFY_LEFT) {
1645                     shift = (max_text_width - max_width) / 2.0;
1646                 } else if (justify == ASS_JUSTIFY_RIGHT) {
1647                     shift = (max_text_width - max_width) / 2.0 + max_width - width;
1648                 } else {
1649                     shift = (max_text_width - width) / 2.0;
1650                 }
1651             }
1652             for (j = last_break + 1; j &lt; i; ++j) {
1653                 GlyphInfo *info = glyphs + j;
1654                 while (info) {
1655                     info-&gt;pos.x += double_to_d6(shift);
1656                     info = info-&gt;next;
1657                 }
1658             }
1659             last_break = i - 1;
1660             width = 0;
1661         }
1662         if (i &lt; text_info-&gt;length &amp;&amp; !glyphs[i].skip &amp;&amp;
1663                 glyphs[i].symbol != '\n' &amp;&amp; glyphs[i].symbol != 0) {
1664             width += d6_to_double(glyphs[i].cluster_advance.x);
1665         }
1666     }
1667 }
1668 static void calculate_rotation_params(ASS_Renderer *render_priv, ASS_DRect *bbox,
1669                                       double device_x, double device_y)
1670 {
1671     ASS_DVector center;
1672     if (render_priv-&gt;state.have_origin) {
1673         center.x = x2scr_pos(render_priv, render_priv-&gt;state.org_x);
1674         center.y = y2scr_pos(render_priv, render_priv-&gt;state.org_y);
1675     } else {
1676         double bx = 0., by = 0.;
1677         get_base_point(bbox, render_priv-&gt;state.alignment, &amp;bx, &amp;by);
1678         center.x = device_x + bx;
1679         center.y = device_y + by;
1680     }
1681     TextInfo *text_info = &amp;render_priv-&gt;text_info;
1682     for (int i = 0; i &lt; text_info-&gt;length; i++) {
1683         GlyphInfo *info = text_info-&gt;glyphs + i;
1684         while (info) {
1685             info-&gt;shift.x = info-&gt;pos.x + double_to_d6(device_x - center.x +
1686                     info-&gt;shadow_x * render_priv-&gt;border_scale /
1687                     render_priv-&gt;font_scale_x);
1688             info-&gt;shift.y = info-&gt;pos.y + double_to_d6(device_y - center.y +
1689                     info-&gt;shadow_y * render_priv-&gt;border_scale);
1690             info = info-&gt;next;
1691         }
1692     }
1693 }
1694 static int quantize_blur(double radius, int32_t *shadow_mask)
1695 {
1696     const double scale = 64 * BLUR_PRECISION / POSITION_PRECISION;
1697     radius *= scale;
1698     int ord;
1699     frexp((1 + radius) * (POSITION_PRECISION / 2), &amp;ord);
1700     *shadow_mask = ((uint32_t) 1 &lt;&lt; ord) - 1;
1701     return lrint(log1p(radius) / BLUR_PRECISION);
1702 }
1703 static double restore_blur(int qblur)
1704 {
1705     const double scale = 64 * BLUR_PRECISION / POSITION_PRECISION;
1706     double sigma = expm1(BLUR_PRECISION * qblur) / scale;
1707     return sigma * sigma;
1708 }
1709 static void render_and_combine_glyphs(ASS_Renderer *render_priv,
1710                                       double device_x, double device_y)
1711 {
1712     TextInfo *text_info = &amp;render_priv-&gt;text_info;
1713     int left = render_priv-&gt;settings.left_margin;
1714     device_x = (device_x - left) * render_priv-&gt;font_scale_x + left;
1715     unsigned nb_bitmaps = 0;
1716     bool new_run = true;
1717     CombinedBitmapInfo *combined_info = text_info-&gt;combined_bitmaps;
1718     CombinedBitmapInfo *current_info = NULL;
1719     ASS_DVector offset;
1720     for (int i = 0; i &lt; text_info-&gt;length; i++) {
1721         GlyphInfo *info = text_info-&gt;glyphs + i;
1722         if (info-&gt;starts_new_run) new_run = true;
1723         if (info-&gt;skip) {
1724             for (; info; info = info-&gt;next)
1725                 ass_cache_dec_ref(info-&gt;outline);
1726             continue;
1727         }
1728         for (; info; info = info-&gt;next) {
1729             int flags = 0;
1730             if (info-&gt;border_style == 3)
1731                 flags |= FILTER_BORDER_STYLE_3;
1732             if (info-&gt;border_x || info-&gt;border_y)
1733                 flags |= FILTER_NONZERO_BORDER;
1734             if (info-&gt;shadow_x || info-&gt;shadow_y)
1735                 flags |= FILTER_NONZERO_SHADOW;
1736             if (flags &amp; FILTER_NONZERO_SHADOW &amp;&amp;
1737                 (info-&gt;effect_type == EF_KARAOKE_KF ||
1738                  info-&gt;effect_type == EF_KARAOKE_KO ||
1739                  (info-&gt;a_pre_fade[0]) != 0xFF ||
1740                  info-&gt;border_style == 3))
1741                 flags |= FILTER_FILL_IN_SHADOW;
1742             if (!(flags &amp; FILTER_NONZERO_BORDER) &amp;&amp;
1743                 !(flags &amp; FILTER_FILL_IN_SHADOW))
1744                 flags &amp;= ~FILTER_NONZERO_SHADOW;
1745             if ((flags &amp; FILTER_NONZERO_BORDER &amp;&amp;
1746                  info-&gt;a_pre_fade[0] == 0 &amp;&amp;
1747                  info-&gt;a_pre_fade[1] == 0 &amp;&amp;
1748                  info-&gt;fade == 0) ||
1749                 info-&gt;border_style == 3)
1750                 flags |= FILTER_FILL_IN_BORDER;
1751             if (new_run) {
1752                 if (nb_bitmaps &gt;= text_info-&gt;max_bitmaps) {
1753                     size_t new_size = 2 * text_info-&gt;max_bitmaps;
1754                     if (!ASS_REALLOC_ARRAY(text_info-&gt;combined_bitmaps, new_size)) {
1755                         ass_cache_dec_ref(info-&gt;outline);
1756                         continue;
1757                     }
1758                     text_info-&gt;max_bitmaps = new_size;
1759                     combined_info = text_info-&gt;combined_bitmaps;
1760                 }
1761                 current_info = &amp;combined_info[nb_bitmaps];
1762                 memcpy(&amp;current_info-&gt;c, &amp;info-&gt;c, sizeof(info-&gt;c));
1763                 current_info-&gt;effect_type = info-&gt;effect_type;
1764                 current_info-&gt;effect_timing = info-&gt;effect_timing;
1765                 current_info-&gt;leftmost_x = OUTLINE_MAX;
1766                 FilterDesc *filter = &amp;current_info-&gt;filter;
1767                 filter-&gt;flags = flags;
1768                 filter-&gt;be = info-&gt;be;
1769                 int32_t shadow_mask;
1770                 double blur_scale = render_priv-&gt;blur_scale * (2 / sqrt(log(256)));
1771                 filter-&gt;blur = quantize_blur(info-&gt;blur * blur_scale, &amp;shadow_mask);
1772                 if (flags &amp; FILTER_NONZERO_SHADOW) {
1773                     int32_t x = double_to_d6(info-&gt;shadow_x * render_priv-&gt;border_scale);
1774                     int32_t y = double_to_d6(info-&gt;shadow_y * render_priv-&gt;border_scale);
1775                     filter-&gt;shadow.x = (x + (shadow_mask &gt;&gt; 1)) &amp; ~shadow_mask;
1776                     filter-&gt;shadow.y = (y + (shadow_mask &gt;&gt; 1)) &amp; ~shadow_mask;
1777                 } else
1778                     filter-&gt;shadow.x = filter-&gt;shadow.y = 0;
1779                 current_info-&gt;x = current_info-&gt;y = INT_MAX;
1780                 current_info-&gt;bm = current_info-&gt;bm_o = current_info-&gt;bm_s = NULL;
1781                 current_info-&gt;image = NULL;
1782                 current_info-&gt;bitmap_count = current_info-&gt;max_bitmap_count = 0;
1783                 current_info-&gt;bitmaps = malloc(MAX_SUB_BITMAPS_INITIAL * sizeof(BitmapRef));
1784                 if (!current_info-&gt;bitmaps) {
1785                     ass_cache_dec_ref(info-&gt;outline);
1786                     continue;
1787                 }
1788                 current_info-&gt;max_bitmap_count = MAX_SUB_BITMAPS_INITIAL;
1789                 nb_bitmaps++;
1790                 new_run = false;
1791             }
1792             assert(current_info);
1793             ASS_Vector pos, pos_o;
1794             info-&gt;pos.x = double_to_d6(device_x + d6_to_double(info-&gt;pos.x) * render_priv-&gt;font_scale_x);
1795             info-&gt;pos.y = double_to_d6(device_y) + info-&gt;pos.y;
1796             get_bitmap_glyph(render_priv, info, &amp;current_info-&gt;leftmost_x, &amp;pos, &amp;pos_o,
1797                              &amp;offset, !current_info-&gt;bitmap_count, flags);
1798             if (!info-&gt;bm &amp;&amp; !info-&gt;bm_o) {
1799                 ass_cache_dec_ref(info-&gt;bm);
1800                 ass_cache_dec_ref(info-&gt;bm_o);
1801                 continue;
1802             }
1803             if (current_info-&gt;bitmap_count &gt;= current_info-&gt;max_bitmap_count) {
1804                 size_t new_size = 2 * current_info-&gt;max_bitmap_count;
1805                 if (!ASS_REALLOC_ARRAY(current_info-&gt;bitmaps, new_size)) {
1806                     ass_cache_dec_ref(info-&gt;bm);
1807                     ass_cache_dec_ref(info-&gt;bm_o);
1808                     continue;
1809                 }
1810                 current_info-&gt;max_bitmap_count = new_size;
1811             }
1812             current_info-&gt;bitmaps[current_info-&gt;bitmap_count].bm   = info-&gt;bm;
1813             current_info-&gt;bitmaps[current_info-&gt;bitmap_count].bm_o = info-&gt;bm_o;
1814             current_info-&gt;bitmaps[current_info-&gt;bitmap_count].pos   = pos;
1815             current_info-&gt;bitmaps[current_info-&gt;bitmap_count].pos_o = pos_o;
1816             current_info-&gt;bitmap_count++;
1817             current_info-&gt;x = FFMIN(current_info-&gt;x, pos.x);
1818             current_info-&gt;y = FFMIN(current_info-&gt;y, pos.y);
1819         }
1820     }
1821     for (int i = 0; i &lt; nb_bitmaps; i++) {
1822         CombinedBitmapInfo *info = &amp;combined_info[i];
1823         if (!info-&gt;bitmap_count) {
1824             free(info-&gt;bitmaps);
1825             continue;
1826         }
1827         if (info-&gt;effect_type == EF_KARAOKE_KF)
1828             info-&gt;effect_timing = lround(d6_to_double(info-&gt;leftmost_x) +
1829                 d6_to_double(info-&gt;effect_timing) * render_priv-&gt;font_scale_x);
1830         for (int j = 0; j &lt; info-&gt;bitmap_count; j++) {
1831             info-&gt;bitmaps[j].pos.x -= info-&gt;x;
1832             info-&gt;bitmaps[j].pos.y -= info-&gt;y;
1833             info-&gt;bitmaps[j].pos_o.x -= info-&gt;x;
1834             info-&gt;bitmaps[j].pos_o.y -= info-&gt;y;
1835         }
1836         CompositeHashKey key;
1837         key.filter = info-&gt;filter;
1838         key.bitmap_count = info-&gt;bitmap_count;
1839         key.bitmaps = info-&gt;bitmaps;
1840         CompositeHashValue *val = ass_cache_get(render_priv-&gt;cache.composite_cache, &amp;key, render_priv);
1841         if (!val)
1842             continue;
1843         if (val-&gt;bm.buffer)
1844             info-&gt;bm = &amp;val-&gt;bm;
1845         if (val-&gt;bm_o.buffer)
1846             info-&gt;bm_o = &amp;val-&gt;bm_o;
1847         if (val-&gt;bm_s.buffer)
1848             info-&gt;bm_s = &amp;val-&gt;bm_s;
1849         info-&gt;image = val;
1850         continue;
1851     }
1852     text_info-&gt;n_bitmaps = nb_bitmaps;
1853 }
1854 static inline void rectangle_combine(ASS_Rect *rect, const Bitmap *bm, ASS_Vector pos)
1855 {
1856     pos.x += bm-&gt;left;
1857     pos.y += bm-&gt;top;
1858     rectangle_update(rect, pos.x, pos.y, pos.x + bm-&gt;w, pos.y + bm-&gt;h);
1859 }
1860 size_t ass_composite_construct(void *key, void *value, void *priv)
1861 {
1862     ASS_Renderer *render_priv = priv;
1863     CompositeHashKey *k = key;
1864     CompositeHashValue *v = value;
1865     memset(v, 0, sizeof(*v));
1866     ASS_Rect rect, rect_o;
1867     rectangle_reset(&amp;rect);
1868     rectangle_reset(&amp;rect_o);
1869     size_t n_bm = 0, n_bm_o = 0;
1870     BitmapRef *last = NULL, *last_o = NULL;
1871     for (int i = 0; i &lt; k-&gt;bitmap_count; i++) {
1872         BitmapRef *ref = &amp;k-&gt;bitmaps[i];
1873         if (ref-&gt;bm) {
1874             rectangle_combine(&amp;rect, ref-&gt;bm, ref-&gt;pos);
1875             last = ref;
1876             n_bm++;
1877         }
1878         if (ref-&gt;bm_o) {
1879             rectangle_combine(&amp;rect_o, ref-&gt;bm_o, ref-&gt;pos_o);
1880             last_o = ref;
1881             n_bm_o++;
1882         }
1883     }
1884     int bord = be_padding(k-&gt;filter.be);
1885     if (!bord &amp;&amp; n_bm == 1) {
1886         copy_bitmap(render_priv-&gt;engine, &amp;v-&gt;bm, last-&gt;bm);
1887         v-&gt;bm.left += last-&gt;pos.x;
1888         v-&gt;bm.top  += last-&gt;pos.y;
1889     } else if (n_bm &amp;&amp; alloc_bitmap(render_priv-&gt;engine, &amp;v-&gt;bm,
1890                                     rect.x_max - rect.x_min + 2 * bord,
1891                                     rect.y_max - rect.y_min + 2 * bord,
1892                                     true)) {
1893         Bitmap *dst = &amp;v-&gt;bm;
1894         dst-&gt;left = rect.x_min - bord;
1895         dst-&gt;top  = rect.y_min - bord;
1896         for (int i = 0; i &lt; k-&gt;bitmap_count; i++) {
1897             Bitmap *src = k-&gt;bitmaps[i].bm;
1898             if (!src)
1899                 continue;
1900             int x = k-&gt;bitmaps[i].pos.x + src-&gt;left - dst-&gt;left;
1901             int y = k-&gt;bitmaps[i].pos.y + src-&gt;top  - dst-&gt;top;
1902             assert(x &gt;= 0 &amp;&amp; x + src-&gt;w &lt;= dst-&gt;w);
1903             assert(y &gt;= 0 &amp;&amp; y + src-&gt;h &lt;= dst-&gt;h);
1904             unsigned char *buf = dst-&gt;buffer + y * dst-&gt;stride + x;
1905             render_priv-&gt;engine-&gt;add_bitmaps(buf, dst-&gt;stride,
1906                                              src-&gt;buffer, src-&gt;stride,
1907                                              src-&gt;w, src-&gt;h);
1908         }
1909     }
1910     if (!bord &amp;&amp; n_bm_o == 1) {
1911         copy_bitmap(render_priv-&gt;engine, &amp;v-&gt;bm_o, last_o-&gt;bm_o);
1912         v-&gt;bm_o.left += last_o-&gt;pos_o.x;
1913         v-&gt;bm_o.top  += last_o-&gt;pos_o.y;
1914     } else if (n_bm_o &amp;&amp; alloc_bitmap(render_priv-&gt;engine, &amp;v-&gt;bm_o,
1915                                       rect_o.x_max - rect_o.x_min + 2 * bord,
1916                                       rect_o.y_max - rect_o.y_min + 2 * bord,
1917                                       true)) {
1918         Bitmap *dst = &amp;v-&gt;bm_o;
1919         dst-&gt;left = rect_o.x_min - bord;
1920         dst-&gt;top  = rect_o.y_min - bord;
1921         for (int i = 0; i &lt; k-&gt;bitmap_count; i++) {
1922             Bitmap *src = k-&gt;bitmaps[i].bm_o;
1923             if (!src)
1924                 continue;
1925             int x = k-&gt;bitmaps[i].pos_o.x + src-&gt;left - dst-&gt;left;
1926             int y = k-&gt;bitmaps[i].pos_o.y + src-&gt;top  - dst-&gt;top;
1927             assert(x &gt;= 0 &amp;&amp; x + src-&gt;w &lt;= dst-&gt;w);
1928             assert(y &gt;= 0 &amp;&amp; y + src-&gt;h &lt;= dst-&gt;h);
1929             unsigned char *buf = dst-&gt;buffer + y * dst-&gt;stride + x;
1930             render_priv-&gt;engine-&gt;add_bitmaps(buf, dst-&gt;stride,
1931                                              src-&gt;buffer, src-&gt;stride,
1932                                              src-&gt;w, src-&gt;h);
1933         }
1934     }
1935     int flags = k-&gt;filter.flags;
1936     double r2 = restore_blur(k-&gt;filter.blur);
1937     if (!(flags &amp; FILTER_NONZERO_BORDER) || (flags &amp; FILTER_BORDER_STYLE_3))
1938         ass_synth_blur(render_priv-&gt;engine, &amp;v-&gt;bm, k-&gt;filter.be, r2);
1939     ass_synth_blur(render_priv-&gt;engine, &amp;v-&gt;bm_o, k-&gt;filter.be, r2);
1940     if (!(flags &amp; FILTER_FILL_IN_BORDER) &amp;&amp; !(flags &amp; FILTER_FILL_IN_SHADOW))
1941         fix_outline(&amp;v-&gt;bm, &amp;v-&gt;bm_o);
1942     if (flags &amp; FILTER_NONZERO_SHADOW) {
1943         if (flags &amp; FILTER_NONZERO_BORDER) {
1944             copy_bitmap(render_priv-&gt;engine, &amp;v-&gt;bm_s, &amp;v-&gt;bm_o);
1945             if ((flags &amp; FILTER_FILL_IN_BORDER) &amp;&amp; !(flags &amp; FILTER_FILL_IN_SHADOW))
1946                 fix_outline(&amp;v-&gt;bm, &amp;v-&gt;bm_s);
1947         } else if (flags &amp; FILTER_BORDER_STYLE_3) {
1948             v-&gt;bm_s = v-&gt;bm_o;
1949             memset(&amp;v-&gt;bm_o, 0, sizeof(v-&gt;bm_o));
1950         } else {
1951             copy_bitmap(render_priv-&gt;engine, &amp;v-&gt;bm_s, &amp;v-&gt;bm);
1952         }
1953         v-&gt;bm_s.left += k-&gt;filter.shadow.x &gt;&gt; 6;
1954         v-&gt;bm_s.top  += k-&gt;filter.shadow.y &gt;&gt; 6;
1955         shift_bitmap(&amp;v-&gt;bm_s, k-&gt;filter.shadow.x &amp; SUBPIXEL_MASK, k-&gt;filter.shadow.y &amp; SUBPIXEL_MASK);
1956     }
1957     if ((flags &amp; FILTER_FILL_IN_SHADOW) &amp;&amp; !(flags &amp; FILTER_FILL_IN_BORDER))
1958         fix_outline(&amp;v-&gt;bm, &amp;v-&gt;bm_o);
1959     return sizeof(CompositeHashKey) + sizeof(CompositeHashValue) +
1960         bitmap_size(&amp;v-&gt;bm) + bitmap_size(&amp;v-&gt;bm_o) + bitmap_size(&amp;v-&gt;bm_s);
1961 }
1962 static void add_background(ASS_Renderer *render_priv, EventImages *event_images)
1963 {
1964     int size_x = render_priv-&gt;state.shadow_x &gt; 0 ?
1965         lround(render_priv-&gt;state.shadow_x * render_priv-&gt;border_scale) : 0;
1966     int size_y = render_priv-&gt;state.shadow_y &gt; 0 ?
1967         lround(render_priv-&gt;state.shadow_y * render_priv-&gt;border_scale) : 0;
1968     int left    = event_images-&gt;left - size_x;
1969     int top     = event_images-&gt;top  - size_y;
1970     int right   = event_images-&gt;left + event_images-&gt;width  + size_x;
1971     int bottom  = event_images-&gt;top  + event_images-&gt;height + size_y;
1972     left        = FFMINMAX(left,   0, render_priv-&gt;width);
1973     top         = FFMINMAX(top,    0, render_priv-&gt;height);
1974     right       = FFMINMAX(right,  0, render_priv-&gt;width);
1975     bottom      = FFMINMAX(bottom, 0, render_priv-&gt;height);
1976     int w = right - left;
1977     int h = bottom - top;
1978     if (w &lt; 1 || h &lt; 1)
1979         return;
1980     void *nbuffer = ass_aligned_alloc(1, w * h, false);
1981     if (!nbuffer)
1982         return;
1983     memset(nbuffer, 0xFF, w * h);
1984     ASS_Image *img = my_draw_bitmap(nbuffer, w, h, w, left, top,
1985                                     render_priv-&gt;state.c[3], NULL);
1986     if (img) {
1987         img-&gt;next = event_images-&gt;imgs;
1988         event_images-&gt;imgs = img;
1989     }
1990 }
1991 static bool
1992 ass_render_event(ASS_Renderer *render_priv, ASS_Event *event,
1993                  EventImages *event_images)
1994 {
1995     if (event-&gt;Style &gt;= render_priv-&gt;track-&gt;n_styles) {
1996         ass_msg(render_priv-&gt;library, MSGL_WARN, "No style found");
1997         return false;
1998     }
1999     if (!event-&gt;Text) {
2000         ass_msg(render_priv-&gt;library, MSGL_WARN, "Empty event");
2001         return false;
2002     }
2003     free_render_context(render_priv);
2004     init_render_context(render_priv, event);
2005     if (!parse_events(render_priv, event))
2006         return false;
2007     TextInfo *text_info = &amp;render_priv-&gt;text_info;
2008     if (text_info-&gt;length == 0) {
2009         free_render_context(render_priv);
2010         return false;
2011     }
2012     split_style_runs(render_priv);
2013     ass_shaper_set_base_direction(render_priv-&gt;shaper,
2014             resolve_base_direction(render_priv-&gt;state.font_encoding));
2015     ass_shaper_find_runs(render_priv-&gt;shaper, render_priv, text_info-&gt;glyphs,
2016             text_info-&gt;length);
2017     if (!ass_shaper_shape(render_priv-&gt;shaper, text_info)) {
2018         ass_msg(render_priv-&gt;library, MSGL_ERR, "Failed to shape text");
2019         free_render_context(render_priv);
2020         return false;
2021     }
2022     retrieve_glyphs(render_priv);
2023     preliminary_layout(render_priv);
2024     int valign = render_priv-&gt;state.alignment &amp; 12;
2025     int MarginL =
2026         (event-&gt;MarginL) ? event-&gt;MarginL : render_priv-&gt;state.style-&gt;MarginL;
2027     int MarginR =
2028         (event-&gt;MarginR) ? event-&gt;MarginR : render_priv-&gt;state.style-&gt;MarginR;
2029     int MarginV =
2030         (event-&gt;MarginV) ? event-&gt;MarginV : render_priv-&gt;state.style-&gt;MarginV;
2031     double max_text_width =
2032         x2scr_right(render_priv, render_priv-&gt;track-&gt;PlayResX - MarginR) -
2033         x2scr_left(render_priv, MarginL);
2034     wrap_lines_smart(render_priv, max_text_width);
2035     process_karaoke_effects(render_priv);
2036     reorder_text(render_priv);
2037     align_lines(render_priv, max_text_width);
2038     ASS_DRect bbox;
2039     compute_string_bbox(text_info, &amp;bbox);
2040     apply_baseline_shear(render_priv);
2041     double device_x = 0;
2042     double device_y = 0;
2043     if (render_priv-&gt;state.evt_type &amp; EVENT_POSITIONED) {
2044         double base_x = 0;
2045         double base_y = 0;
2046         get_base_point(&amp;bbox, render_priv-&gt;state.alignment, &amp;base_x, &amp;base_y);
2047         device_x =
2048             x2scr_pos(render_priv, render_priv-&gt;state.pos_x) - base_x;
2049         device_y =
2050             y2scr_pos(render_priv, render_priv-&gt;state.pos_y) - base_y;
2051     }
2052     if (render_priv-&gt;state.evt_type &amp; EVENT_HSCROLL) {
2053         if (render_priv-&gt;state.scroll_direction == SCROLL_RL)
2054             device_x =
2055                 x2scr_pos(render_priv,
2056                       render_priv-&gt;track-&gt;PlayResX -
2057                       render_priv-&gt;state.scroll_shift);
2058         else if (render_priv-&gt;state.scroll_direction == SCROLL_LR)
2059             device_x =
2060                 x2scr_pos(render_priv, render_priv-&gt;state.scroll_shift) -
2061                 (bbox.x_max - bbox.x_min);
2062     } else if (!(render_priv-&gt;state.evt_type &amp; EVENT_POSITIONED)) {
2063         device_x = x2scr_left(render_priv, MarginL);
2064     }
2065     if (render_priv-&gt;state.evt_type &amp; EVENT_VSCROLL) {
2066         if (render_priv-&gt;state.scroll_direction == SCROLL_TB)
2067             device_y =
2068                 y2scr(render_priv,
2069                       render_priv-&gt;state.scroll_y0 +
2070                       render_priv-&gt;state.scroll_shift) -
2071                 bbox.y_max;
2072         else if (render_priv-&gt;state.scroll_direction == SCROLL_BT)
2073             device_y =
2074                 y2scr(render_priv,
2075                       render_priv-&gt;state.scroll_y1 -
2076                       render_priv-&gt;state.scroll_shift) -
2077                 bbox.y_min;
2078     } else if (!(render_priv-&gt;state.evt_type &amp; EVENT_POSITIONED)) {
2079         if (valign == VALIGN_TOP) {                 device_y =
2080                 y2scr_top(render_priv,
2081                           MarginV) + text_info-&gt;lines[0].asc;
2082         } else if (valign == VALIGN_CENTER) {               double scr_y =
2083                 y2scr(render_priv, render_priv-&gt;track-&gt;PlayResY / 2.0);
2084             device_y = scr_y - (bbox.y_max + bbox.y_min) / 2.0;
2085         } else {                            double line_pos = render_priv-&gt;state.explicit ?
2086                 0 : render_priv-&gt;settings.line_position;
2087             double scr_top, scr_bottom, scr_y0;
2088             if (valign != VALIGN_SUB)
2089                 ass_msg(render_priv-&gt;library, MSGL_V,
2090                        "Invalid valign, assuming 0 (subtitle)");
2091             scr_bottom =
2092                 y2scr_sub(render_priv,
2093                           render_priv-&gt;track-&gt;PlayResY - MarginV);
2094             scr_top = y2scr_top(render_priv, 0); //xxx not always 0?
2095             device_y = scr_bottom + (scr_top - scr_bottom) * line_pos / 100.0;
2096             device_y -= text_info-&gt;height;
2097             device_y += text_info-&gt;lines[0].asc;
2098             scr_y0 = scr_top + text_info-&gt;lines[0].asc;
2099             if (device_y &lt; scr_y0 &amp;&amp; line_pos &gt; 0) {
2100                 device_y = scr_y0;
2101             }
2102         }
2103     }
2104     if (render_priv-&gt;state.explicit || !render_priv-&gt;settings.use_margins) {
2105         render_priv-&gt;state.clip_x0 =
2106             x2scr_pos_scaled(render_priv, render_priv-&gt;state.clip_x0);
2107         render_priv-&gt;state.clip_x1 =
2108             x2scr_pos_scaled(render_priv, render_priv-&gt;state.clip_x1);
2109         render_priv-&gt;state.clip_y0 =
2110             y2scr_pos(render_priv, render_priv-&gt;state.clip_y0);
2111         render_priv-&gt;state.clip_y1 =
2112             y2scr_pos(render_priv, render_priv-&gt;state.clip_y1);
2113         if (render_priv-&gt;state.explicit) {
2114             double zx = x2scr_pos_scaled(render_priv, 0);
2115             double zy = y2scr_pos(render_priv, 0);
2116             double sx = x2scr_pos_scaled(render_priv, render_priv-&gt;track-&gt;PlayResX);
2117             double sy = y2scr_pos(render_priv, render_priv-&gt;track-&gt;PlayResY);
2118             render_priv-&gt;state.clip_x0 = FFMAX(render_priv-&gt;state.clip_x0, zx);
2119             render_priv-&gt;state.clip_y0 = FFMAX(render_priv-&gt;state.clip_y0, zy);
2120             render_priv-&gt;state.clip_x1 = FFMIN(render_priv-&gt;state.clip_x1, sx);
2121             render_priv-&gt;state.clip_y1 = FFMIN(render_priv-&gt;state.clip_y1, sy);
2122         }
2123     } else {
2124         render_priv-&gt;state.clip_x0 = 0;
2125         render_priv-&gt;state.clip_y0 = 0;
2126         render_priv-&gt;state.clip_x1 = render_priv-&gt;settings.frame_width;
2127         render_priv-&gt;state.clip_y1 = render_priv-&gt;settings.frame_height;
2128     }
2129     if (render_priv-&gt;state.evt_type &amp; EVENT_VSCROLL) {
2130         double y0 = y2scr_pos(render_priv, render_priv-&gt;state.scroll_y0);
2131         double y1 = y2scr_pos(render_priv, render_priv-&gt;state.scroll_y1);
2132         render_priv-&gt;state.clip_y0 = FFMAX(render_priv-&gt;state.clip_y0, y0);
2133         render_priv-&gt;state.clip_y1 = FFMIN(render_priv-&gt;state.clip_y1, y1);
2134     }
2135     calculate_rotation_params(render_priv, &amp;bbox, device_x, device_y);
2136     render_and_combine_glyphs(render_priv, device_x, device_y);
2137     memset(event_images, 0, sizeof(*event_images));
2138     event_images-&gt;top = device_y - text_info-&gt;lines[0].asc - text_info-&gt;border_top;
2139     event_images-&gt;height =
2140         text_info-&gt;height + text_info-&gt;border_bottom + text_info-&gt;border_top;
2141     event_images-&gt;left =
2142         (device_x + bbox.x_min) * render_priv-&gt;font_scale_x - text_info-&gt;border_x + 0.5;
2143     event_images-&gt;width =
2144         (bbox.x_max - bbox.x_min) * render_priv-&gt;font_scale_x
2145         + 2 * text_info-&gt;border_x + 0.5;
2146     event_images-&gt;detect_collisions = render_priv-&gt;state.detect_collisions;
2147     event_images-&gt;shift_direction = (valign == VALIGN_SUB) ? -1 : 1;
2148     event_images-&gt;event = event;
2149     event_images-&gt;imgs = render_text(render_priv);
2150     if (render_priv-&gt;state.border_style == 4)
2151         add_background(render_priv, event_images);
2152     ass_shaper_cleanup(render_priv-&gt;shaper, text_info);
2153     free_render_context(render_priv);
2154     return true;
2155 }
2156 static void check_cache_limits(ASS_Renderer *priv, CacheStore *cache)
2157 {
2158     ass_cache_cut(cache-&gt;composite_cache, cache-&gt;composite_max_size);
2159     ass_cache_cut(cache-&gt;bitmap_cache, cache-&gt;bitmap_max_size);
2160     ass_cache_cut(cache-&gt;outline_cache, cache-&gt;glyph_max);
2161 }
2162 static bool
2163 ass_start_frame(ASS_Renderer *render_priv, ASS_Track *track,
2164                 long long now)
2165 {
2166     ASS_Settings *settings_priv = &amp;render_priv-&gt;settings;
2167     if (!render_priv-&gt;settings.frame_width
2168         &amp;&amp; !render_priv-&gt;settings.frame_height)
2169         return false;               
2170     if (!render_priv-&gt;fontselect)
2171         return false;
2172     if (render_priv-&gt;library != track-&gt;library)
2173         return false;
2174     if (track-&gt;n_events == 0)
2175         return false;               
2176     render_priv-&gt;track = track;
2177     render_priv-&gt;time = now;
2178     ass_lazy_track_init(render_priv-&gt;library, render_priv-&gt;track);
2179     if (render_priv-&gt;library-&gt;num_fontdata != render_priv-&gt;num_emfonts) {
2180         assert(render_priv-&gt;library-&gt;num_fontdata &gt; render_priv-&gt;num_emfonts);
2181         render_priv-&gt;num_emfonts = ass_update_embedded_fonts(
2182             render_priv-&gt;fontselect, render_priv-&gt;num_emfonts);
2183     }
2184     ass_shaper_set_kerning(render_priv-&gt;shaper, track-&gt;Kerning);
2185     ass_shaper_set_language(render_priv-&gt;shaper, track-&gt;Language);
2186     ass_shaper_set_level(render_priv-&gt;shaper, render_priv-&gt;settings.shaper);
2187 #ifdef USE_FRIBIDI_EX_API
2188     ass_shaper_set_bidi_brackets(render_priv-&gt;shaper,
2189             track-&gt;parser_priv-&gt;feature_flags &amp; FEATURE_MASK(ASS_FEATURE_BIDI_BRACKETS));
2190 #endif
2191     ass_shaper_set_whole_text_layout(render_priv-&gt;shaper,
2192             track-&gt;parser_priv-&gt;feature_flags &amp; FEATURE_MASK(ASS_FEATURE_WHOLE_TEXT_LAYOUT));
2193     double par = render_priv-&gt;settings.par;
2194     if (par == 0.) {
2195         if (render_priv-&gt;orig_width &amp;&amp; render_priv-&gt;orig_height &amp;&amp;
2196             settings_priv-&gt;storage_width &amp;&amp; settings_priv-&gt;storage_height) {
2197             double dar = ((double) render_priv-&gt;orig_width) /
2198                          render_priv-&gt;orig_height;
2199             double sar = ((double) settings_priv-&gt;storage_width) /
2200                          settings_priv-&gt;storage_height;
2201             par = dar / sar;
2202         } else
2203             par = 1.0;
2204     }
2205     render_priv-&gt;font_scale_x = par;
2206     render_priv-&gt;prev_images_root = render_priv-&gt;images_root;
2207     render_priv-&gt;images_root = NULL;
2208     check_cache_limits(render_priv, &amp;render_priv-&gt;cache);
2209     return true;
2210 }
2211 static int cmp_event_layer(const void *p1, const void *p2)
2212 {
2213     ASS_Event *e1 = ((EventImages *) p1)-&gt;event;
2214     ASS_Event *e2 = ((EventImages *) p2)-&gt;event;
2215     if (e1-&gt;Layer &lt; e2-&gt;Layer)
2216         return -1;
2217     if (e1-&gt;Layer &gt; e2-&gt;Layer)
2218         return 1;
2219     if (e1-&gt;ReadOrder &lt; e2-&gt;ReadOrder)
2220         return -1;
2221     if (e1-&gt;ReadOrder &gt; e2-&gt;ReadOrder)
2222         return 1;
2223     return 0;
2224 }
2225 static ASS_RenderPriv *get_render_priv(ASS_Renderer *render_priv,
2226                                        ASS_Event *event)
2227 {
2228     if (!event-&gt;render_priv) {
2229         event-&gt;render_priv = calloc(1, sizeof(ASS_RenderPriv));
2230         if (!event-&gt;render_priv)
2231             return NULL;
2232     }
2233     if (render_priv-&gt;render_id != event-&gt;render_priv-&gt;render_id) {
2234         memset(event-&gt;render_priv, 0, sizeof(ASS_RenderPriv));
2235         event-&gt;render_priv-&gt;render_id = render_priv-&gt;render_id;
2236     }
2237     return event-&gt;render_priv;
2238 }
2239 static int overlap(Rect *s1, Rect *s2)
2240 {
2241     if (s1-&gt;y0 &gt;= s2-&gt;y1 || s2-&gt;y0 &gt;= s1-&gt;y1 ||
2242         s1-&gt;x0 &gt;= s2-&gt;x1 || s2-&gt;x0 &gt;= s1-&gt;x1)
2243         return 0;
2244     return 1;
2245 }
2246 static int cmp_rect_y0(const void *p1, const void *p2)
2247 {
2248     return ((Rect *) p1)-&gt;y0 - ((Rect *) p2)-&gt;y0;
2249 }
2250 static void
2251 shift_event(ASS_Renderer *render_priv, EventImages *ei, int shift)
2252 {
2253     ASS_Image *cur = ei-&gt;imgs;
2254     while (cur) {
2255         cur-&gt;dst_y += shift;
2256         if (cur-&gt;dst_y &lt; 0) {
2257             int clip = -cur-&gt;dst_y;
2258             cur-&gt;h -= clip;
2259             cur-&gt;bitmap += clip * cur-&gt;stride;
2260             cur-&gt;dst_y = 0;
2261         }
2262         if (cur-&gt;dst_y + cur-&gt;h &gt;= render_priv-&gt;height) {
2263             int clip = cur-&gt;dst_y + cur-&gt;h - render_priv-&gt;height;
2264             cur-&gt;h -= clip;
2265         }
2266         if (cur-&gt;h &lt;= 0) {
2267             cur-&gt;h = 0;
2268             cur-&gt;dst_y = 0;
2269         }
2270         cur = cur-&gt;next;
2271     }
2272     ei-&gt;top += shift;
2273 }
2274 static int fit_rect(Rect *s, Rect *fixed, int *cnt, int dir)
2275 {
2276     int i;
2277     int shift = 0;
2278     if (dir == 1)                       for (i = 0; i &lt; *cnt; ++i) {
2279             if (s-&gt;y1 + shift &lt;= fixed[i].y0 || s-&gt;y0 + shift &gt;= fixed[i].y1 ||
2280                 s-&gt;x1 &lt;= fixed[i].x0 || s-&gt;x0 &gt;= fixed[i].x1)
2281                 continue;
2282             shift = fixed[i].y1 - s-&gt;y0;
2283     } else                              for (i = *cnt - 1; i &gt;= 0; --i) {
2284             if (s-&gt;y1 + shift &lt;= fixed[i].y0 || s-&gt;y0 + shift &gt;= fixed[i].y1 ||
2285                 s-&gt;x1 &lt;= fixed[i].x0 || s-&gt;x0 &gt;= fixed[i].x1)
2286                 continue;
2287             shift = fixed[i].y0 - s-&gt;y1;
2288         }
2289     fixed[*cnt].y0 = s-&gt;y0 + shift;
2290     fixed[*cnt].y1 = s-&gt;y1 + shift;
2291     fixed[*cnt].x0 = s-&gt;x0;
2292     fixed[*cnt].x1 = s-&gt;x1;
2293     (*cnt)++;
2294     qsort(fixed, *cnt, sizeof(*fixed), cmp_rect_y0);
2295     return shift;
2296 }
2297 static void
2298 fix_collisions(ASS_Renderer *render_priv, EventImages *imgs, int cnt)
2299 {
2300     Rect *used = ass_realloc_array(NULL, cnt, sizeof(*used));
2301     int cnt_used = 0;
2302     int i, j;
2303     if (!used)
2304         return;
2305     for (i = 0; i &lt; cnt; ++i) {
2306         ASS_RenderPriv *priv;
2307         if (!imgs[i].detect_collisions || !imgs[i].height  || !imgs[i].width)
2308             continue;
2309         priv = get_render_priv(render_priv, imgs[i].event);
2310         if (priv &amp;&amp; priv-&gt;height &gt; 0) {             Rect s;
2311             s.y0 = priv-&gt;top;
2312             s.y1 = priv-&gt;top + priv-&gt;height;
2313             s.x0 = priv-&gt;left;
2314             s.x1 = priv-&gt;left + priv-&gt;width;
2315             if (priv-&gt;height != imgs[i].height) {                       ass_msg(render_priv-&gt;library, MSGL_WARN,
2316                         "Event height has changed");
2317                 priv-&gt;top = 0;
2318                 priv-&gt;height = 0;
2319                 priv-&gt;left = 0;
2320                 priv-&gt;width = 0;
2321             }
2322             for (j = 0; j &lt; cnt_used; ++j)
2323                 if (overlap(&amp;s, used + j)) {                        priv-&gt;top = 0;
2324                     priv-&gt;height = 0;
2325                     priv-&gt;left = 0;
2326                     priv-&gt;width = 0;
2327                 }
2328             if (priv-&gt;height &gt; 0) {                     used[cnt_used].y0 = priv-&gt;top;
2329                 used[cnt_used].y1 = priv-&gt;top + priv-&gt;height;
2330                 used[cnt_used].x0 = priv-&gt;left;
2331                 used[cnt_used].x1 = priv-&gt;left + priv-&gt;width;
2332                 cnt_used++;
2333                 shift_event(render_priv, imgs + i, priv-&gt;top - imgs[i].top);
2334             }
2335         }
2336     }
2337     qsort(used, cnt_used, sizeof(*used), cmp_rect_y0);
2338     for (i = 0; i &lt; cnt; ++i) {
2339         ASS_RenderPriv *priv;
2340         if (!imgs[i].detect_collisions || !imgs[i].height  || !imgs[i].width)
2341             continue;
2342         priv = get_render_priv(render_priv, imgs[i].event);
2343         if (priv &amp;&amp; priv-&gt;height == 0) {                    int shift;
2344             Rect s;
2345             s.y0 = imgs[i].top;
2346             s.y1 = imgs[i].top + imgs[i].height;
2347             s.x0 = imgs[i].left;
2348             s.x1 = imgs[i].left + imgs[i].width;
2349             shift = fit_rect(&amp;s, used, &amp;cnt_used, imgs[i].shift_direction);
2350             if (shift)
2351                 shift_event(render_priv, imgs + i, shift);
2352             priv-&gt;top = imgs[i].top;
2353             priv-&gt;height = imgs[i].height;
2354             priv-&gt;left = imgs[i].left;
2355             priv-&gt;width = imgs[i].width;
2356         }
2357     }
2358     free(used);
2359 }
2360 static int ass_image_compare(ASS_Image *i1, ASS_Image *i2)
2361 {
2362     if (i1-&gt;w != i2-&gt;w)
2363         return 2;
2364     if (i1-&gt;h != i2-&gt;h)
2365         return 2;
2366     if (i1-&gt;stride != i2-&gt;stride)
2367         return 2;
2368     if (i1-&gt;color != i2-&gt;color)
2369         return 2;
2370     if (i1-&gt;bitmap != i2-&gt;bitmap)
2371         return 2;
2372     if (i1-&gt;dst_x != i2-&gt;dst_x)
2373         return 1;
2374     if (i1-&gt;dst_y != i2-&gt;dst_y)
2375         return 1;
2376     return 0;
2377 }
2378 static int ass_detect_change(ASS_Renderer *priv)
2379 {
2380     ASS_Image *img, *img2;
2381     int diff;
2382     img = priv-&gt;prev_images_root;
2383     img2 = priv-&gt;images_root;
2384     diff = 0;
2385     while (img &amp;&amp; diff &lt; 2) {
2386         ASS_Image *next, *next2;
2387         next = img-&gt;next;
2388         if (img2) {
2389             int d = ass_image_compare(img, img2);
2390             if (d &gt; diff)
2391                 diff = d;
2392             next2 = img2-&gt;next;
2393         } else {
2394             diff = 2;
2395             break;
2396         }
2397         img = next;
2398         img2 = next2;
2399     }
2400     if (img2)
2401         diff = 2;
2402     return diff;
2403 }
2404 ASS_Image *ass_render_frame(ASS_Renderer *priv, ASS_Track *track,
2405                             long long now, int *detect_change)
2406 {
2407     if (!ass_start_frame(priv, track, now)) {
2408         if (detect_change)
2409             *detect_change = 2;
2410         return NULL;
2411     }
2412     int cnt = 0;
2413     for (int i = 0; i &lt; track-&gt;n_events; i++) {
2414         ASS_Event *event = track-&gt;events + i;
2415         if ((event-&gt;Start &lt;= now)
2416             &amp;&amp; (now &lt; (event-&gt;Start + event-&gt;Duration))) {
2417             if (cnt &gt;= priv-&gt;eimg_size) {
2418                 priv-&gt;eimg_size += 100;
2419                 priv-&gt;eimg =
2420                     realloc(priv-&gt;eimg,
2421                             priv-&gt;eimg_size * sizeof(EventImages));
2422             }
2423             if (ass_render_event(priv, event, priv-&gt;eimg + cnt))
2424                 cnt++;
2425         }
2426     }
2427     if (cnt &gt; 0)
2428         qsort(priv-&gt;eimg, cnt, sizeof(EventImages), cmp_event_layer);
2429     EventImages *last = priv-&gt;eimg;
2430     for (int i = 1; i &lt; cnt; i++)
2431         if (last-&gt;event-&gt;Layer != priv-&gt;eimg[i].event-&gt;Layer) {
2432             fix_collisions(priv, last, priv-&gt;eimg + i - last);
2433             last = priv-&gt;eimg + i;
2434         }
2435     if (cnt &gt; 0)
2436         fix_collisions(priv, last, priv-&gt;eimg + cnt - last);
2437     ASS_Image **tail = &amp;priv-&gt;images_root;
2438     for (int i = 0; i &lt; cnt; i++) {
2439         ASS_Image *cur = priv-&gt;eimg[i].imgs;
2440         while (cur) {
2441             *tail = cur;
2442             tail = &amp;cur-&gt;next;
2443             cur = cur-&gt;next;
2444         }
2445     }
2446     ass_frame_ref(priv-&gt;images_root);
2447     if (detect_change)
2448         *detect_change = ass_detect_change(priv);
2449     ass_frame_unref(priv-&gt;prev_images_root);
2450     priv-&gt;prev_images_root = NULL;
2451     return priv-&gt;images_root;
2452 }
2453 void ass_frame_ref(ASS_Image *img)
2454 {
2455     if (!img)
2456         return;
2457     ((ASS_ImagePriv *) img)-&gt;ref_count++;
2458 }
2459 void ass_frame_unref(ASS_Image *img)
2460 {
2461     if (!img || --((ASS_ImagePriv *) img)-&gt;ref_count)
2462         return;
2463     do {
2464         ASS_ImagePriv *priv = (ASS_ImagePriv *) img;
2465         img = img-&gt;next;
2466         ass_cache_dec_ref(priv-&gt;source);
2467         ass_aligned_free(priv-&gt;buffer);
2468         free(priv);
2469     } while (img);
2470 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>wyhash.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef wyhash_final_version_3
2 #define wyhash_final_version_3
3 #ifndef WYHASH_CONDOM
4 #define WYHASH_CONDOM 1
5 #endif
6 #ifndef WYHASH_32BIT_MUM
7 #define WYHASH_32BIT_MUM 0  
8 #endif
9 #include &lt;stdint.h&gt;
10 #include &lt;string.h&gt;
11 #if defined(_MSC_VER) &amp;&amp; defined(_M_X64)
12   #include &lt;intrin.h&gt;
13   #pragma intrinsic(_umul128)
14 #endif
15 #if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
16   #define _likely_(x)  __builtin_expect(x,1)
17   #define _unlikely_(x)  __builtin_expect(x,0)
18 #else
19   #define _likely_(x) (x)
20   #define _unlikely_(x) (x)
21 #endif
22 <a name="1"></a>
23 static inline uint64_t _wyrot(uint64_t x) { return (x&gt;&gt;32)|(x&lt;&lt;32); }
24 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static inline void _wymum(uint64_t *A, uint64_t *B){
25 #if(WYHASH_32BIT_MUM)
26   uint64_t hh=(*A&gt;&gt;32)*(*B&gt;&gt;32), hl=(*A&gt;&gt;32)*(uint32_t)*B, lh=(uint32_t)*A*(*B&gt;&gt;32), ll=(uint64_t)(uint32_t)*A*(uint32_t)*B;
27   #if(WYHASH_CONDOM&gt;1)
28   *A^=_wyrot(hl)^hh; *B^=_wyrot(lh)^ll;
29   #else
30   *A=_wyrot(hl)^hh; *B=_wyrot(lh)^ll;
31   #endif
32 #elif defined(__SIZEOF_INT128__)
33   __uint128_t r=*A; r*=*B; 
34 <a name="0"></a>  #if(WYHASH_CONDOM&gt;1)
35   *A^=(uint64_t)r; *B^=(uint64_t)(r&gt;&gt;64);
36   #else
37 </b></font><font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  *A=(uint64_t)r; *B=(uint64_t)(r&gt;&gt;64);
38   #endif
39 #elif defined(_MSC_VER) &amp;&amp; defined(_M_X64)
40   #if(WYHASH_CONDOM&gt;1)
41   uint64_t  a,  b;
42   a=_umul128(*A,*B,&amp;b);
43   *A^=a;  *B^=b;
44   #else
45   *A=_umul128(*A,*B,B);
46   #endif
47 #else
48   uint64_t ha=*A&gt;&gt;32, hb=*B&gt;&gt;32, la=(uint32_t)*A, lb=(uint32_t)*B, hi, lo;
49   uint64_t rh=ha*hb, rm0=ha*lb, rm1=hb*la, rl=la*lb, t=rl+(rm0&lt;&lt;32), c=t&lt;rl;
50   lo=t+(rm1&lt;&lt;32); c+=lo&lt;t; hi=rh+(rm0&gt;&gt;32)+(rm1&gt;&gt;32)+c;
51   #if(WYHASH_CONDOM&gt;1)
52   *A^=lo;  *B^=hi;
53   #else
54   *A=lo;  *B=hi;
55   #endif
56 #endif
57 }
58 static inline uint64_t _wymix(uint64_t A, uint64_t B){ _wymum(&amp;A,&amp;B); return A^B; }</b></font>
59 #ifndef WYHASH_LITTLE_ENDIAN
60   #if defined(_WIN32) || defined(__LITTLE_ENDIAN__) || (defined(__BYTE_ORDER__) &amp;&amp; __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
61     #define WYHASH_LITTLE_ENDIAN 1
62   #elif defined(__BIG_ENDIAN__) || (defined(__BYTE_ORDER__) &amp;&amp; __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
63     #define WYHASH_LITTLE_ENDIAN 0
64   #else
65     #warning could not determine endianness! Falling back to little endian.
66     #define WYHASH_LITTLE_ENDIAN 1
67   #endif
68 #endif
69 #if (WYHASH_LITTLE_ENDIAN)
70 static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&amp;v, p, 8); return v;}
71 static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&amp;v, p, 4); return v;}
72 #elif defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
73 static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&amp;v, p, 8); return __builtin_bswap64(v);}
74 static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&amp;v, p, 4); return __builtin_bswap32(v);}
75 #elif defined(_MSC_VER)
76 static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&amp;v, p, 8); return _byteswap_uint64(v);}
77 static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&amp;v, p, 4); return _byteswap_ulong(v);}
78 #else
79 static inline uint64_t _wyr8(const uint8_t *p) {
80   uint64_t v; memcpy(&amp;v, p, 8);
81   return (((v &gt;&gt; 56) &amp; 0xff)| ((v &gt;&gt; 40) &amp; 0xff00)| ((v &gt;&gt; 24) &amp; 0xff0000)| ((v &gt;&gt;  8) &amp; 0xff000000)| ((v &lt;&lt;  8) &amp; 0xff00000000)| ((v &lt;&lt; 24) &amp; 0xff0000000000)| ((v &lt;&lt; 40) &amp; 0xff000000000000)| ((v &lt;&lt; 56) &amp; 0xff00000000000000));
82 }
83 static inline uint64_t _wyr4(const uint8_t *p) {
84   uint32_t v; memcpy(&amp;v, p, 4);
85   return (((v &gt;&gt; 24) &amp; 0xff)| ((v &gt;&gt;  8) &amp; 0xff00)| ((v &lt;&lt;  8) &amp; 0xff0000)| ((v &lt;&lt; 24) &amp; 0xff000000));
86 }
87 #endif
88 static inline uint64_t _wyr3(const uint8_t *p, size_t k) { return (((uint64_t)p[0])&lt;&lt;16)|(((uint64_t)p[k&gt;&gt;1])&lt;&lt;8)|p[k-1];}
89 static inline uint64_t wyhash(const void *key, size_t len, uint64_t seed, const uint64_t *secret){
90   const uint8_t *p=(const uint8_t *)key; seed^=*secret;	uint64_t	a,	b;
91   if(_likely_(len&lt;=16)){
92     if(_likely_(len&gt;=4)){ a=(_wyr4(p)&lt;&lt;32)|_wyr4(p+((len&gt;&gt;3)&lt;&lt;2)); b=(_wyr4(p+len-4)&lt;&lt;32)|_wyr4(p+len-4-((len&gt;&gt;3)&lt;&lt;2)); }
93     else if(_likely_(len&gt;0)){ a=_wyr3(p,len); b=0;}
94     else a=b=0;
95 <a name="2"></a>  }
96   else{
97     size_t i=len; 
98 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    if(_unlikely_(i&gt;48)){
99       uint64_t see1=seed, see2=seed;
100       do{
101         seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);
102         see1=_wymix(_wyr8(p+16)^secret[2],_wyr8(p+24)^see1);
103         see2=_wymix(_wyr8(p+32)^secret[3],_wyr8(p+40)^see2);
104         p+=48; i-=48;
105       }while(_likely_(i&gt;48));
106       seed^=see1^see2;</b></font>
107     }
108     while(_unlikely_(i&gt;16)){  seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);  i-=16; p+=16;  }
109     a=_wyr8(p+i-16);  b=_wyr8(p+i-8);
110   }
111   return _wymix(secret[1]^len,_wymix(a^secret[1],b^seed));
112 }
113 static const uint64_t _wyp[4] = {0xa0761d6478bd642full, 0xe7037ed1a0b428dbull, 0x8ebc6af09c88c6e3ull, 0x589965cc75374cc3ull};
114 static inline uint64_t wyhash64(uint64_t A, uint64_t B){ A^=0xa0761d6478bd642full; B^=0xe7037ed1a0b428dbull; _wymum(&amp;A,&amp;B); return _wymix(A^0xa0761d6478bd642full,B^0xe7037ed1a0b428dbull);}
115 static inline uint64_t wyrand(uint64_t *seed){ *seed+=0xa0761d6478bd642full; return _wymix(*seed,*seed^0xe7037ed1a0b428dbull);}
116 static inline double wy2u01(uint64_t r){ const double _wynorm=1.0/(1ull&lt;&lt;52); return (r&gt;&gt;12)*_wynorm;}
117 static inline double wy2gau(uint64_t r){ const double _wynorm=1.0/(1ull&lt;&lt;20); return ((r&amp;0x1fffff)+((r&gt;&gt;21)&amp;0x1fffff)+((r&gt;&gt;42)&amp;0x1fffff))*_wynorm-3.0;}
118 #if(!WYHASH_32BIT_MUM)
119 static inline uint64_t wy2u0k(uint64_t r, uint64_t k){ _wymum(&amp;r,&amp;k); return k; }
120 #endif
121 static inline void make_secret(uint64_t seed, uint64_t *secret){
122   uint8_t c[] = {15, 23, 27, 29, 30, 39, 43, 45, 46, 51, 53, 54, 57, 58, 60, 71, 75, 77, 78, 83, 85, 86, 89, 90, 92, 99, 101, 102, 105, 106, 108, 113, 114, 116, 120, 135, 139, 141, 142, 147, 149, 150, 153, 154, 156, 163, 165, 166, 169, 170, 172, 177, 178, 180, 184, 195, 197, 198, 201, 202, 204, 209, 210, 212, 216, 225, 226, 228, 232, 240 };
123   for(size_t i=0;i&lt;4;i++){
124     uint8_t ok;
125     do{
126       ok=1; secret[i]=0;
127       for(size_t j=0;j&lt;64;j+=8) secret[i]|=((uint64_t)c[wyrand(&amp;seed)%sizeof(c)])&lt;&lt;j;
128       if(secret[i]%2==0){ ok=0; continue; }
129       for(size_t j=0;j&lt;i;j++) {
130 #if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
131         if(__builtin_popcountll(secret[j]^secret[i])!=32){ ok=0; break; }
132 #elif defined(_MSC_VER) &amp;&amp; defined(_M_X64)
133         if(_mm_popcnt_u64(secret[j]^secret[i])!=32){ ok=0; break; }
134 #else
135         uint64_t x = secret[j]^secret[i];
136         x -= (x &gt;&gt; 1) &amp; 0x5555555555555555;
137         x = (x &amp; 0x3333333333333333) + ((x &gt;&gt; 2) &amp; 0x3333333333333333);
138         x = (x + (x &gt;&gt; 4)) &amp; 0x0f0f0f0f0f0f0f0f;
139         x = (x * 0x0101010101010101) &gt;&gt; 56;
140         if(x!=32){ ok=0; break; }
141 #endif
142       }
143     }while(!ok);
144   }
145 }
146 #endif
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
