<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ass_render.c &amp; wyhash.h</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ass_render.c &amp; wyhash.h
      </h3>
<h1 align="center">
        3.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ass_render.c (1.7955801%)<th>wyhash.h (20.392157%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1008-1036)<td><a href="#" name="0">(59-82)</a><td align="center"><font color="#ff0000">24</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1036-1053)<td><a href="#" name="1">(46-59)</a><td align="center"><font color="#9f0000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(2074-2086)<td><a href="#" name="2">(127-135)</a><td align="center"><font color="#8a0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ass_render.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include "ass_compat.h"
#include &lt;assert.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;
#include &lt;stdbool.h&gt;
#include "ass.h"
#include "ass_outline.h"
#include "ass_render.h"
#include "ass_parse.h"
#include "ass_priv.h"
#include "ass_shaper.h"
#define MAX_GLYPHS_INITIAL 1024
#define MAX_LINES_INITIAL 64
#define MAX_BITMAPS_INITIAL 16
#define MAX_SUB_BITMAPS_INITIAL 64
#define SUBPIXEL_MASK 63
#define STROKER_PRECISION 16     #define RASTERIZER_PRECISION 16  #define POSITION_PRECISION 8.0   #define MAX_PERSP_SCALE 16.0
#define SUBPIXEL_ORDER 3  #define BLUR_PRECISION (1.0 / 256)  
ASS_Renderer *ass_renderer_init(ASS_Library *library)
{
    int error;
    FT_Library ft;
    ASS_Renderer *priv = 0;
    int vmajor, vminor, vpatch;
    ass_msg(library, MSGL_INFO, "libass API version: 0x%X", LIBASS_VERSION);
    ass_msg(library, MSGL_INFO, "libass source: %s", CONFIG_SOURCEVERSION);
    error = FT_Init_FreeType(&amp;ft);
    if (error) {
        ass_msg(library, MSGL_FATAL, "%s failed", "FT_Init_FreeType");
        goto fail;
    }
    FT_Library_Version(ft, &amp;vmajor, &amp;vminor, &amp;vpatch);
    ass_msg(library, MSGL_V, "Raster: FreeType %d.%d.%d",
           vmajor, vminor, vpatch);
    priv = calloc(1, sizeof(ASS_Renderer));
    if (!priv) {
        FT_Done_FreeType(ft);
        goto fail;
    }
    priv-&gt;library = library;
    priv-&gt;ftlibrary = ft;
#if CONFIG_ASM &amp;&amp; ARCH_X86
    bool sse2, avx2;
    ass_cpu_capabilities(&amp;sse2, &amp;avx2);
    if (avx2)
        priv-&gt;engine = &amp;ass_bitmap_engine_avx2;
    else if (sse2)
        priv-&gt;engine = &amp;ass_bitmap_engine_sse2;
    else
        priv-&gt;engine = &amp;ass_bitmap_engine_c;
#else
    priv-&gt;engine = &amp;ass_bitmap_engine_c;
#endif
    if (!rasterizer_init(priv-&gt;engine, &amp;priv-&gt;rasterizer, RASTERIZER_PRECISION))
        goto fail;
    priv-&gt;cache.font_cache = ass_font_cache_create();
    priv-&gt;cache.bitmap_cache = ass_bitmap_cache_create();
    priv-&gt;cache.composite_cache = ass_composite_cache_create();
    priv-&gt;cache.outline_cache = ass_outline_cache_create();
    if (!priv-&gt;cache.font_cache || !priv-&gt;cache.bitmap_cache || !priv-&gt;cache.composite_cache || !priv-&gt;cache.outline_cache)
        goto fail;
    priv-&gt;cache.glyph_max = GLYPH_CACHE_MAX;
    priv-&gt;cache.bitmap_max_size = BITMAP_CACHE_MAX_SIZE;
    priv-&gt;cache.composite_max_size = COMPOSITE_CACHE_MAX_SIZE;
    priv-&gt;text_info.max_bitmaps = MAX_BITMAPS_INITIAL;
    priv-&gt;text_info.max_glyphs = MAX_GLYPHS_INITIAL;
    priv-&gt;text_info.max_lines = MAX_LINES_INITIAL;
    priv-&gt;text_info.n_bitmaps = 0;
    priv-&gt;text_info.combined_bitmaps = calloc(MAX_BITMAPS_INITIAL, sizeof(CombinedBitmapInfo));
    priv-&gt;text_info.glyphs = calloc(MAX_GLYPHS_INITIAL, sizeof(GlyphInfo));
    priv-&gt;text_info.lines = calloc(MAX_LINES_INITIAL, sizeof(LineInfo));
    if (!priv-&gt;text_info.combined_bitmaps || !priv-&gt;text_info.glyphs || !priv-&gt;text_info.lines)
        goto fail;
    priv-&gt;settings.font_size_coeff = 1.;
    priv-&gt;settings.selective_style_overrides = ASS_OVERRIDE_BIT_SELECTIVE_FONT_SCALE;
    if (!(priv-&gt;shaper = ass_shaper_new()))
        goto fail;
    ass_shaper_info(library);
    priv-&gt;settings.shaper = ASS_SHAPING_COMPLEX;
    ass_msg(library, MSGL_V, "Initialized");
    return priv;
fail:
    ass_msg(library, MSGL_ERR, "Initialization failed");
    ass_renderer_done(priv);
    return NULL;
}
void ass_renderer_done(ASS_Renderer *render_priv)
{
    if (!render_priv)
        return;
    ass_frame_unref(render_priv-&gt;images_root);
    ass_frame_unref(render_priv-&gt;prev_images_root);
    ass_cache_done(render_priv-&gt;cache.composite_cache);
    ass_cache_done(render_priv-&gt;cache.bitmap_cache);
    ass_cache_done(render_priv-&gt;cache.outline_cache);
    ass_shaper_free(render_priv-&gt;shaper);
    ass_cache_done(render_priv-&gt;cache.font_cache);
    rasterizer_done(&amp;render_priv-&gt;rasterizer);
    if (render_priv-&gt;fontselect)
        ass_fontselect_free(render_priv-&gt;fontselect);
    if (render_priv-&gt;ftlibrary)
        FT_Done_FreeType(render_priv-&gt;ftlibrary);
    free(render_priv-&gt;eimg);
    free(render_priv-&gt;text_info.glyphs);
    free(render_priv-&gt;text_info.lines);
    free(render_priv-&gt;text_info.combined_bitmaps);
    free(render_priv-&gt;settings.default_font);
    free(render_priv-&gt;settings.default_family);
    free(render_priv-&gt;user_override_style.FontName);
    free(render_priv);
}
static ASS_Image *my_draw_bitmap(unsigned char *bitmap, int bitmap_w,
                                 int bitmap_h, int stride, int dst_x,
                                 int dst_y, uint32_t color,
                                 CompositeHashValue *source)
{
    ASS_ImagePriv *img = malloc(sizeof(ASS_ImagePriv));
    if (!img) {
        if (!source)
            ass_aligned_free(bitmap);
        return NULL;
    }
    img-&gt;result.w = bitmap_w;
    img-&gt;result.h = bitmap_h;
    img-&gt;result.stride = stride;
    img-&gt;result.bitmap = bitmap;
    img-&gt;result.color = color;
    img-&gt;result.dst_x = dst_x;
    img-&gt;result.dst_y = dst_y;
    img-&gt;source = source;
    ass_cache_inc_ref(source);
    img-&gt;buffer = source ? NULL : bitmap;
    img-&gt;ref_count = 0;
    return &amp;img-&gt;result;
}
static double x2scr_pos(ASS_Renderer *render_priv, double x)
{
    return x * render_priv-&gt;orig_width / render_priv-&gt;font_scale_x / render_priv-&gt;track-&gt;PlayResX +
        render_priv-&gt;settings.left_margin;
}
static double x2scr_left(ASS_Renderer *render_priv, double x)
{
    if (render_priv-&gt;state.explicit || !render_priv-&gt;settings.use_margins)
        return x2scr_pos(render_priv, x);
    return x * render_priv-&gt;fit_width / render_priv-&gt;font_scale_x /
        render_priv-&gt;track-&gt;PlayResX;
}
static double x2scr_right(ASS_Renderer *render_priv, double x)
{
    if (render_priv-&gt;state.explicit || !render_priv-&gt;settings.use_margins)
        return x2scr_pos(render_priv, x);
    return x * render_priv-&gt;fit_width / render_priv-&gt;font_scale_x /
        render_priv-&gt;track-&gt;PlayResX +
        (render_priv-&gt;width - render_priv-&gt;fit_width);
}
static double x2scr_pos_scaled(ASS_Renderer *render_priv, double x)
{
    return x * render_priv-&gt;orig_width / render_priv-&gt;track-&gt;PlayResX +
        render_priv-&gt;settings.left_margin;
}
static double y2scr_pos(ASS_Renderer *render_priv, double y)
{
    return y * render_priv-&gt;orig_height / render_priv-&gt;track-&gt;PlayResY +
        render_priv-&gt;settings.top_margin;
}
static double y2scr(ASS_Renderer *render_priv, double y)
{
    if (render_priv-&gt;state.explicit || !render_priv-&gt;settings.use_margins)
        return y2scr_pos(render_priv, y);
    return y * render_priv-&gt;fit_height /
        render_priv-&gt;track-&gt;PlayResY +
        (render_priv-&gt;height - render_priv-&gt;fit_height) * 0.5;
}
static double y2scr_top(ASS_Renderer *render_priv, double y)
{
    if (render_priv-&gt;state.explicit || !render_priv-&gt;settings.use_margins)
        return y2scr_pos(render_priv, y);
    return y * render_priv-&gt;fit_height /
        render_priv-&gt;track-&gt;PlayResY;
}
static double y2scr_sub(ASS_Renderer *render_priv, double y)
{
    if (render_priv-&gt;state.explicit || !render_priv-&gt;settings.use_margins)
        return y2scr_pos(render_priv, y);
    return y * render_priv-&gt;fit_height /
        render_priv-&gt;track-&gt;PlayResY +
        (render_priv-&gt;height - render_priv-&gt;fit_height);
}
static ASS_Image **render_glyph_i(ASS_Renderer *render_priv,
                                  Bitmap *bm, int dst_x, int dst_y,
                                  uint32_t color, uint32_t color2, int brk,
                                  ASS_Image **tail, unsigned type,
                                  CompositeHashValue *source)
{
    int i, j, x0, y0, x1, y1, cx0, cy0, cx1, cy1, sx, sy, zx, zy;
    Rect r[4];
    ASS_Image *img;
    dst_x += bm-&gt;left;
    dst_y += bm-&gt;top;
    brk -= dst_x;
    zx = x2scr_pos_scaled(render_priv, 0);
    zy = y2scr_pos(render_priv, 0);
    sx = x2scr_pos_scaled(render_priv, render_priv-&gt;track-&gt;PlayResX);
    sy = y2scr_pos(render_priv, render_priv-&gt;track-&gt;PlayResY);
    x0 = 0;
    y0 = 0;
    x1 = bm-&gt;w;
    y1 = bm-&gt;h;
    cx0 = render_priv-&gt;state.clip_x0 - dst_x;
    cy0 = render_priv-&gt;state.clip_y0 - dst_y;
    cx1 = render_priv-&gt;state.clip_x1 - dst_x;
    cy1 = render_priv-&gt;state.clip_y1 - dst_y;
    i = 0;
    r[i].x0 = x0;
    r[i].y0 = y0;
    r[i].x1 = (cx0 &gt; x1) ? x1 : cx0;
    r[i].y1 = y1;
    if (r[i].x1 &gt; r[i].x0 &amp;&amp; r[i].y1 &gt; r[i].y0) i++;
    r[i].x0 = (cx0 &lt; 0) ? x0 : cx0;
    r[i].y0 = y0;
    r[i].x1 = (cx1 &gt; x1) ? x1 : cx1;
    r[i].y1 = (cy0 &gt; y1) ? y1 : cy0;
    if (r[i].x1 &gt; r[i].x0 &amp;&amp; r[i].y1 &gt; r[i].y0) i++;
    r[i].x0 = (cx0 &lt; 0) ? x0 : cx0;
    r[i].y0 = (cy1 &lt; 0) ? y0 : cy1;
    r[i].x1 = (cx1 &gt; x1) ? x1 : cx1;
    r[i].y1 = y1;
    if (r[i].x1 &gt; r[i].x0 &amp;&amp; r[i].y1 &gt; r[i].y0) i++;
    r[i].x0 = (cx1 &lt; 0) ? x0 : cx1;
    r[i].y0 = y0;
    r[i].x1 = x1;
    r[i].y1 = y1;
    if (r[i].x1 &gt; r[i].x0 &amp;&amp; r[i].y1 &gt; r[i].y0) i++;
    for (j = 0; j &lt; i; j++) {
        r[j].x0 = (r[j].x0 + dst_x &lt; zx) ? zx - dst_x : r[j].x0;
        r[j].y0 = (r[j].y0 + dst_y &lt; zy) ? zy - dst_y : r[j].y0;
        r[j].x1 = (r[j].x1 + dst_x &gt; sx) ? sx - dst_x : r[j].x1;
        r[j].y1 = (r[j].y1 + dst_y &gt; sy) ? sy - dst_y : r[j].y1;
    }
    for (j = 0; j &lt; i; j++) {
        int lbrk = brk;
        if (r[j].x1 &lt;= r[j].x0 || r[j].y1 &lt;= r[j].y0)
            continue;
        if (lbrk &gt; r[j].x0) {
            if (lbrk &gt; r[j].x1) lbrk = r[j].x1;
            img = my_draw_bitmap(bm-&gt;buffer + r[j].y0 * bm-&gt;stride + r[j].x0,
                                 lbrk - r[j].x0, r[j].y1 - r[j].y0, bm-&gt;stride,
                                 dst_x + r[j].x0, dst_y + r[j].y0, color, source);
            if (!img) break;
            img-&gt;type = type;
            *tail = img;
            tail = &amp;img-&gt;next;
        }
        if (lbrk &lt; r[j].x1) {
            if (lbrk &lt; r[j].x0) lbrk = r[j].x0;
            img = my_draw_bitmap(bm-&gt;buffer + r[j].y0 * bm-&gt;stride + lbrk,
                                 r[j].x1 - lbrk, r[j].y1 - r[j].y0, bm-&gt;stride,
                                 dst_x + lbrk, dst_y + r[j].y0, color2, source);
            if (!img) break;
            img-&gt;type = type;
            *tail = img;
            tail = &amp;img-&gt;next;
        }
    }
    return tail;
}
static ASS_Image **
render_glyph(ASS_Renderer *render_priv, Bitmap *bm, int dst_x, int dst_y,
             uint32_t color, uint32_t color2, int brk, ASS_Image **tail,
             unsigned type, CompositeHashValue *source)
{
    if (render_priv-&gt;state.clip_mode)
        return render_glyph_i(render_priv, bm, dst_x, dst_y, color, color2,
                              brk, tail, type, source);
    int b_x0, b_y0, b_x1, b_y1;     int clip_x0, clip_y0, clip_x1, clip_y1;
    int tmp;
    ASS_Image *img;
    dst_x += bm-&gt;left;
    dst_y += bm-&gt;top;
    brk -= dst_x;
    clip_x0 = FFMINMAX(render_priv-&gt;state.clip_x0, 0, render_priv-&gt;width);
    clip_y0 = FFMINMAX(render_priv-&gt;state.clip_y0, 0, render_priv-&gt;height);
    clip_x1 = FFMINMAX(render_priv-&gt;state.clip_x1, 0, render_priv-&gt;width);
    clip_y1 = FFMINMAX(render_priv-&gt;state.clip_y1, 0, render_priv-&gt;height);
    b_x0 = 0;
    b_y0 = 0;
    b_x1 = bm-&gt;w;
    b_y1 = bm-&gt;h;
    tmp = dst_x - clip_x0;
    if (tmp &lt; 0)
        b_x0 = -tmp;
    tmp = dst_y - clip_y0;
    if (tmp &lt; 0)
        b_y0 = -tmp;
    tmp = clip_x1 - dst_x - bm-&gt;w;
    if (tmp &lt; 0)
        b_x1 = bm-&gt;w + tmp;
    tmp = clip_y1 - dst_y - bm-&gt;h;
    if (tmp &lt; 0)
        b_y1 = bm-&gt;h + tmp;
    if ((b_y0 &gt;= b_y1) || (b_x0 &gt;= b_x1))
        return tail;
    if (brk &gt; b_x0) {                   if (brk &gt; b_x1)
            brk = b_x1;
        img = my_draw_bitmap(bm-&gt;buffer + bm-&gt;stride * b_y0 + b_x0,
                             brk - b_x0, b_y1 - b_y0, bm-&gt;stride,
                             dst_x + b_x0, dst_y + b_y0, color, source);
        if (!img) return tail;
        img-&gt;type = type;
        *tail = img;
        tail = &amp;img-&gt;next;
    }
    if (brk &lt; b_x1) {                   if (brk &lt; b_x0)
            brk = b_x0;
        img = my_draw_bitmap(bm-&gt;buffer + bm-&gt;stride * b_y0 + brk,
                             b_x1 - brk, b_y1 - b_y0, bm-&gt;stride,
                             dst_x + brk, dst_y + b_y0, color2, source);
        if (!img) return tail;
        img-&gt;type = type;
        *tail = img;
        tail = &amp;img-&gt;next;
    }
    return tail;
}
static bool quantize_transform(double m[3][3], ASS_Vector *pos,
                               ASS_DVector *offset, bool first,
                               BitmapHashKey *key)
{
    const double max_val = 1000000;
    const ASS_Rect *bbox = &amp;key-&gt;outline-&gt;cbox;
    double x0 = (bbox-&gt;x_min + bbox-&gt;x_max) / 2.0;
    double y0 = (bbox-&gt;y_min + bbox-&gt;y_max) / 2.0;
    double dx = (bbox-&gt;x_max - bbox-&gt;x_min) / 2.0 + 64;
    double dy = (bbox-&gt;y_max - bbox-&gt;y_min) / 2.0 + 64;
    for (int i = 0; i &lt; 3; i++)
        m[i][2] += m[i][0] * x0 + m[i][1] * y0;
    if (m[2][2] &lt;= 0)
        return false;
    double w = 1 / m[2][2];
    double center[2] = { m[0][2] * w, m[1][2] * w };
    for (int i = 0; i &lt; 2; i++)
        for (int j = 0; j &lt; 2; j++)
            m[i][j] -= m[2][j] * center[i];
    double delta[2] = {0};
    if (!first) {
        delta[0] = offset-&gt;x;
        delta[1] = offset-&gt;y;
    }
    int32_t qr[2];      for (int i = 0; i &lt; 2; i++) {
        center[i] /= 64 &gt;&gt; SUBPIXEL_ORDER;
        center[i] -= delta[i];
        if (!(fabs(center[i]) &lt; max_val))
            return false;
        qr[i] = lrint(center[i]);
    }
    double z0 = m[2][2] - fabs(m[2][0]) * dx - fabs(m[2][1]) * dy;
    w = 1.0 / POSITION_PRECISION / FFMAX(z0, m[2][2] / MAX_PERSP_SCALE);
    double mul[2] = { dx * w, dy * w };  
    int32_t qm[3][2];
    for (int i = 0; i &lt; 2; i++)
        for (int j = 0; j &lt; 2; j++) {
            double val = m[i][j] * mul[j];
            if (!(fabs(val) &lt; max_val))
                return false;
            qm[i][j] = lrint(val);
        }
    int32_t qmx = abs(qm[0][0]) + abs(qm[0][1]);
    int32_t qmy = abs(qm[1][0]) + abs(qm[1][1]);
    w = POSITION_PRECISION * FFMAX(qmx, qmy);
    mul[0] *= w;
    mul[1] *= w;
    for (int j = 0; j &lt; 2; j++) {
        double val = m[2][j] * mul[j];
        if (!(fabs(val) &lt; max_val))
            return false;
        qm[2][j] = lrint(val);
    }
    if (first &amp;&amp; offset) {
        offset-&gt;x = center[0] - qr[0];
        offset-&gt;y = center[1] - qr[1];
    }
    *pos = (ASS_Vector) {
        .x = qr[0] &gt;&gt; SUBPIXEL_ORDER,
        .y = qr[1] &gt;&gt; SUBPIXEL_ORDER,
    };
    key-&gt;offset.x = qr[0] &amp; ((1 &lt;&lt; SUBPIXEL_ORDER) - 1);
    key-&gt;offset.y = qr[1] &amp; ((1 &lt;&lt; SUBPIXEL_ORDER) - 1);
    key-&gt;matrix_x.x = qm[0][0];  key-&gt;matrix_x.y = qm[0][1];
    key-&gt;matrix_y.x = qm[1][0];  key-&gt;matrix_y.y = qm[1][1];
    key-&gt;matrix_z.x = qm[2][0];  key-&gt;matrix_z.y = qm[2][1];
    return true;
}
static void restore_transform(double m[3][3], const BitmapHashKey *key)
{
    const ASS_Rect *bbox = &amp;key-&gt;outline-&gt;cbox;
    double x0 = (bbox-&gt;x_min + bbox-&gt;x_max) / 2.0;
    double y0 = (bbox-&gt;y_min + bbox-&gt;y_max) / 2.0;
    double dx = (bbox-&gt;x_max - bbox-&gt;x_min) / 2.0 + 64;
    double dy = (bbox-&gt;y_max - bbox-&gt;y_min) / 2.0 + 64;
    double q_x = POSITION_PRECISION / dx;
    double q_y = POSITION_PRECISION / dy;
    m[0][0] = key-&gt;matrix_x.x * q_x;
    m[0][1] = key-&gt;matrix_x.y * q_y;
    m[1][0] = key-&gt;matrix_y.x * q_x;
    m[1][1] = key-&gt;matrix_y.y * q_y;
    int32_t qmx = abs(key-&gt;matrix_x.x) + abs(key-&gt;matrix_x.y);
    int32_t qmy = abs(key-&gt;matrix_y.x) + abs(key-&gt;matrix_y.y);
    double scale_z = 1.0 / POSITION_PRECISION / FFMAX(qmx, qmy);
    m[2][0] = key-&gt;matrix_z.x * q_x * scale_z;      m[2][1] = key-&gt;matrix_z.y * q_y * scale_z;  
    m[0][2] = m[1][2] = 0;
    m[2][2] = 1 + fabs(m[2][0]) * dx + fabs(m[2][1]) * dy;
    m[2][2] = FFMIN(m[2][2], MAX_PERSP_SCALE);
    double center[2] = {
        key-&gt;offset.x * (64 &gt;&gt; SUBPIXEL_ORDER),
        key-&gt;offset.y * (64 &gt;&gt; SUBPIXEL_ORDER),
    };
    for (int i = 0; i &lt; 2; i++)
        for (int j = 0; j &lt; 3; j++)
            m[i][j] += m[2][j] * center[i];
    for (int i = 0; i &lt; 3; i++)
        m[i][2] -= m[i][0] * x0 + m[i][1] * y0;
}
static inline size_t bitmap_size(const Bitmap *bm)
{
    return bm-&gt;stride * bm-&gt;h;
}
static void blend_vector_clip(ASS_Renderer *render_priv, ASS_Image *head)
{
    if (!render_priv-&gt;state.clip_drawing_text.str)
        return;
    OutlineHashKey ol_key;
    ol_key.type = OUTLINE_DRAWING;
    ol_key.u.drawing.text = render_priv-&gt;state.clip_drawing_text;
    double m[3][3] = {{0}};
    int32_t scale_base = lshiftwrapi(1, render_priv-&gt;state.clip_drawing_scale - 1);
    double w = scale_base &gt; 0 ? (render_priv-&gt;font_scale / scale_base) : 0;
    m[0][0] = render_priv-&gt;font_scale_x * w;
    m[1][1] = w;
    m[2][2] = 1;
    m[0][2] = int_to_d6(render_priv-&gt;settings.left_margin);
    m[1][2] = int_to_d6(render_priv-&gt;settings.top_margin);
    ASS_Vector pos;
    BitmapHashKey key;
    key.outline = ass_cache_get(render_priv-&gt;cache.outline_cache, &amp;ol_key, render_priv);
    if (!key.outline || !key.outline-&gt;valid ||
            !quantize_transform(m, &amp;pos, NULL, true, &amp;key)) {
        ass_cache_dec_ref(key.outline);
        return;
    }
    Bitmap *clip_bm = ass_cache_get(render_priv-&gt;cache.bitmap_cache, &amp;key, render_priv);
    if (!clip_bm)
        return;
    for (ASS_Image *cur = head; cur; cur = cur-&gt;next) {
        int left, top, right, bottom, w, h;
        int ax, ay, aw, ah, as;
        int bx, by, bw, bh, bs;
        int aleft, atop, bleft, btop;
        unsigned char *abuffer, *bbuffer, *nbuffer;
        abuffer = cur-&gt;bitmap;
        bbuffer = clip_bm-&gt;buffer;
        ax = cur-&gt;dst_x;
        ay = cur-&gt;dst_y;
        aw = cur-&gt;w;
        ah = cur-&gt;h;
        as = cur-&gt;stride;
        bx = pos.x + clip_bm-&gt;left;
        by = pos.y + clip_bm-&gt;top;
        bw = clip_bm-&gt;w;
        bh = clip_bm-&gt;h;
        bs = clip_bm-&gt;stride;
        left = (ax &gt; bx) ? ax : bx;
        top = (ay &gt; by) ? ay : by;
        right = ((ax + aw) &lt; (bx + bw)) ? (ax + aw) : (bx + bw);
        bottom = ((ay + ah) &lt; (by + bh)) ? (ay + ah) : (by + bh);
        aleft = left - ax;
        atop = top - ay;
        w = right - left;
        h = bottom - top;
        bleft = left - bx;
        btop = top - by;
        unsigned align = 1 &lt;&lt; render_priv-&gt;engine-&gt;align_order;
        if (render_priv-&gt;state.clip_drawing_mode) {
            if (ax + aw &lt; bx || ay + ah &lt; by || ax &gt; bx + bw ||
                ay &gt; by + bh || !h || !w) {
                continue;
            }
            nbuffer = ass_aligned_alloc(align, as * ah + align, false);
            if (!nbuffer)
                break;
            memcpy(nbuffer, abuffer, ((ah - 1) * as) + aw);
            render_priv-&gt;engine-&gt;imul_bitmaps(nbuffer + atop * as + aleft, as,
                                              bbuffer + btop * bs + bleft, bs,
                                              w, h);
        } else {
            if (ax + aw &lt; bx || ay + ah &lt; by || ax &gt; bx + bw ||
                ay &gt; by + bh || !h || !w) {
                cur-&gt;w = cur-&gt;h = cur-&gt;stride = 0;
                continue;
            }
            unsigned ns = ass_align(align, w);
            nbuffer = ass_aligned_alloc(align, ns * h + align, false);
            if (!nbuffer)
                break;
            render_priv-&gt;engine-&gt;mul_bitmaps(nbuffer, ns,
                                             abuffer + atop * as + aleft, as,
                                             bbuffer + btop * bs + bleft, bs,
                                             w, h);
            cur-&gt;dst_x += aleft;
            cur-&gt;dst_y += atop;
            cur-&gt;w = w;
            cur-&gt;h = h;
            cur-&gt;stride = ns;
        }
        ASS_ImagePriv *priv = (ASS_ImagePriv *) cur;
        priv-&gt;buffer = cur-&gt;bitmap = nbuffer;
        ass_cache_dec_ref(priv-&gt;source);
        priv-&gt;source = NULL;
    }
    ass_cache_dec_ref(clip_bm);
}
static ASS_Image *render_text(ASS_Renderer *render_priv)
{
    ASS_Image *head;
    ASS_Image **tail = &amp;head;
    unsigned n_bitmaps = render_priv-&gt;text_info.n_bitmaps;
    CombinedBitmapInfo *bitmaps = render_priv-&gt;text_info.combined_bitmaps;
    for (unsigned i = 0; i &lt; n_bitmaps; i++) {
        CombinedBitmapInfo *info = &amp;bitmaps[i];
        if (!info-&gt;bm_s || render_priv-&gt;state.border_style == 4)
            continue;
        tail =
            render_glyph(render_priv, info-&gt;bm_s, info-&gt;x, info-&gt;y, info-&gt;c[3], 0,
                         1000000, tail, IMAGE_TYPE_SHADOW, info-&gt;image);
    }
    for (unsigned i = 0; i &lt; n_bitmaps; i++) {
        CombinedBitmapInfo *info = &amp;bitmaps[i];
        if (!info-&gt;bm_o)
            continue;
        if ((info-&gt;effect_type == EF_KARAOKE_KO)
                &amp;&amp; (info-&gt;effect_timing &lt;= 0)) {
        } else {
            tail =
                render_glyph(render_priv, info-&gt;bm_o, info-&gt;x, info-&gt;y, info-&gt;c[2],
                             0, 1000000, tail, IMAGE_TYPE_OUTLINE, info-&gt;image);
        }
    }
    for (unsigned i = 0; i &lt; n_bitmaps; i++) {
        CombinedBitmapInfo *info = &amp;bitmaps[i];
        if (!info-&gt;bm)
            continue;
        if ((info-&gt;effect_type == EF_KARAOKE)
                || (info-&gt;effect_type == EF_KARAOKE_KO)) {
            if (info-&gt;effect_timing &gt; 0)
                tail =
                    render_glyph(render_priv, info-&gt;bm, info-&gt;x, info-&gt;y,
                                 info-&gt;c[0], 0, 1000000, tail,
                                 IMAGE_TYPE_CHARACTER, info-&gt;image);
            else
                tail =
                    render_glyph(render_priv, info-&gt;bm, info-&gt;x, info-&gt;y,
                                 info-&gt;c[1], 0, 1000000, tail,
                                 IMAGE_TYPE_CHARACTER, info-&gt;image);
        } else if (info-&gt;effect_type == EF_KARAOKE_KF) {
            tail =
                render_glyph(render_priv, info-&gt;bm, info-&gt;x, info-&gt;y, info-&gt;c[0],
                             info-&gt;c[1], info-&gt;effect_timing, tail,
                             IMAGE_TYPE_CHARACTER, info-&gt;image);
        } else
            tail =
                render_glyph(render_priv, info-&gt;bm, info-&gt;x, info-&gt;y, info-&gt;c[0],
                             0, 1000000, tail, IMAGE_TYPE_CHARACTER, info-&gt;image);
    }
    for (unsigned i = 0; i &lt; n_bitmaps; i++)
        ass_cache_dec_ref(bitmaps[i].image);
    *tail = 0;
    blend_vector_clip(render_priv, head);
    return head;
}
static void compute_string_bbox(TextInfo *text, ASS_DRect *bbox)
{
    if (text-&gt;length &gt; 0) {
        bbox-&gt;x_min = +32000;
        bbox-&gt;x_max = -32000;
        bbox-&gt;y_min = -text-&gt;lines[0].asc;
        bbox-&gt;y_max = bbox-&gt;y_min + text-&gt;height;
        for (int i = 0; i &lt; text-&gt;length; i++) {
            GlyphInfo *info = text-&gt;glyphs + i;
            if (info-&gt;skip) continue;
            double s = d6_to_double(info-&gt;pos.x);
            double e = s + d6_to_double(info-&gt;cluster_advance.x);
            bbox-&gt;x_min = FFMIN(bbox-&gt;x_min, s);
            bbox-&gt;x_max = FFMAX(bbox-&gt;x_max, e);
        }
    } else
        bbox-&gt;x_min = bbox-&gt;x_max = bbox-&gt;y_min = bbox-&gt;y_max = 0;
}
static ASS_Style *handle_selective_style_overrides(ASS_Renderer *render_priv,
                                                   ASS_Style *rstyle)
{
    ASS_Style *script = render_priv-&gt;track-&gt;styles +
                        render_priv-&gt;state.event-&gt;Style;
    ASS_Style *user = &amp;render_priv-&gt;user_override_style;
    ASS_Style *new = &amp;render_priv-&gt;state.override_style_temp_storage;
    int explicit = render_priv-&gt;state.explicit;
    int requested = render_priv-&gt;settings.selective_style_overrides;
    double scale;
    user-&gt;Name = "OverrideStyle"; 
    if (!rstyle)
        rstyle = script;
    *new = *rstyle;
    render_priv-&gt;state.apply_font_scale =
        !explicit || !(requested &amp; ASS_OVERRIDE_BIT_SELECTIVE_FONT_SCALE);
    if (explicit)
        requested = 0;
    if (requested &amp; ASS_OVERRIDE_BIT_STYLE)
        requested |= ASS_OVERRIDE_BIT_FONT_NAME |
                     ASS_OVERRIDE_BIT_FONT_SIZE_FIELDS |
                     ASS_OVERRIDE_BIT_COLORS |
                     ASS_OVERRIDE_BIT_BORDER |
                     ASS_OVERRIDE_BIT_ATTRIBUTES;
    if (requested &amp; ASS_OVERRIDE_FULL_STYLE)
        *new = *user;
    scale = render_priv-&gt;track-&gt;PlayResY / 288.0;
    if (requested &amp; ASS_OVERRIDE_BIT_FONT_SIZE_FIELDS) {
        new-&gt;FontSize = user-&gt;FontSize * scale;
        new-&gt;Spacing = user-&gt;Spacing * scale;
        new-&gt;ScaleX = user-&gt;ScaleX;
        new-&gt;ScaleY = user-&gt;ScaleY;
    }
    if (requested &amp; ASS_OVERRIDE_BIT_FONT_NAME) {
        new-&gt;FontName = user-&gt;FontName;
        new-&gt;treat_fontname_as_pattern = user-&gt;treat_fontname_as_pattern;
    }
    if (requested &amp; ASS_OVERRIDE_BIT_COLORS) {
        new-&gt;PrimaryColour = user-&gt;PrimaryColour;
        new-&gt;SecondaryColour = user-&gt;SecondaryColour;
        new-&gt;OutlineColour = user-&gt;OutlineColour;
        new-&gt;BackColour = user-&gt;BackColour;
    }
    if (requested &amp; ASS_OVERRIDE_BIT_ATTRIBUTES) {
        new-&gt;Bold = user-&gt;Bold;
        new-&gt;Italic = user-&gt;Italic;
        new-&gt;Underline = user-&gt;Underline;
        new-&gt;StrikeOut = user-&gt;StrikeOut;
    }
    if (requested &amp; ASS_OVERRIDE_BIT_BORDER) {
        new-&gt;BorderStyle = user-&gt;BorderStyle;
        new-&gt;Outline = user-&gt;Outline * scale;
        new-&gt;Shadow = user-&gt;Shadow * scale;
    }
    if (requested &amp; ASS_OVERRIDE_BIT_ALIGNMENT)
        new-&gt;Alignment = user-&gt;Alignment;
    if (requested &amp; ASS_OVERRIDE_BIT_JUSTIFY)
        new-&gt;Justify = user-&gt;Justify;
    if (requested &amp; ASS_OVERRIDE_BIT_MARGINS) {
        new-&gt;MarginL = user-&gt;MarginL;
        new-&gt;MarginR = user-&gt;MarginR;
        new-&gt;MarginV = user-&gt;MarginV;
    }
    if (!new-&gt;FontName)
        new-&gt;FontName = rstyle-&gt;FontName;
    render_priv-&gt;state.style = new;
    render_priv-&gt;state.overrides = requested;
    return new;
}
static void init_font_scale(ASS_Renderer *render_priv)
{
    ASS_Settings *settings_priv = &amp;render_priv-&gt;settings;
    double font_scr_h = render_priv-&gt;orig_height;
    if (!render_priv-&gt;state.explicit &amp;&amp; render_priv-&gt;settings.use_margins)
        font_scr_h = render_priv-&gt;fit_height;
    render_priv-&gt;font_scale = font_scr_h / render_priv-&gt;track-&gt;PlayResY;
    if (settings_priv-&gt;storage_height)
        render_priv-&gt;blur_scale = font_scr_h / settings_priv-&gt;storage_height;
    else
        render_priv-&gt;blur_scale = font_scr_h / render_priv-&gt;track-&gt;PlayResY;
    if (render_priv-&gt;track-&gt;ScaledBorderAndShadow)
        render_priv-&gt;border_scale =
            font_scr_h / render_priv-&gt;track-&gt;PlayResY;
    else
        render_priv-&gt;border_scale = render_priv-&gt;blur_scale;
    if (render_priv-&gt;state.apply_font_scale) {
        render_priv-&gt;font_scale *= settings_priv-&gt;font_size_coeff;
        render_priv-&gt;border_scale *= settings_priv-&gt;font_size_coeff;
        render_priv-&gt;blur_scale *= settings_priv-&gt;font_size_coeff;
    }
}
void reset_render_context(ASS_Renderer *render_priv, ASS_Style *style)
{
    style = handle_selective_style_overrides(render_priv, style);
    init_font_scale(render_priv);
    render_priv-&gt;state.c[0] = style-&gt;PrimaryColour;
    render_priv-&gt;state.c[1] = style-&gt;SecondaryColour;
    render_priv-&gt;state.c[2] = style-&gt;OutlineColour;
    render_priv-&gt;state.c[3] = style-&gt;BackColour;
<a name="0"></a>    render_priv-&gt;state.flags =
        (style-&gt;Underline ? DECO_UNDERLINE : 0) |
        (style-&gt;StrikeOut ? DECO_STRIKETHROUGH : 0);
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    render_priv-&gt;state.font_size = style-&gt;FontSize;
    render_priv-&gt;state.family.str = style-&gt;FontName;
    render_priv-&gt;state.family.len = strlen(style-&gt;FontName);
    render_priv-&gt;state.treat_family_as_pattern = style-&gt;treat_fontname_as_pattern;
    render_priv-&gt;state.bold = style-&gt;Bold;
    render_priv-&gt;state.italic = style-&gt;Italic;
    update_font(render_priv);
    render_priv-&gt;state.border_style = style-&gt;BorderStyle;
    render_priv-&gt;state.border_x = style-&gt;Outline;
    render_priv-&gt;state.border_y = style-&gt;Outline;
    render_priv-&gt;state.scale_x = style-&gt;ScaleX;
    render_priv-&gt;state.scale_y = style-&gt;ScaleY;
    render_priv-&gt;state.hspacing = style-&gt;Spacing;
    render_priv-&gt;state.be = 0;
    render_priv-&gt;state.blur = style-&gt;Blur;
    render_priv-&gt;state.shadow_x = style-&gt;Shadow;
    render_priv-&gt;state.shadow_y = style-&gt;Shadow;
    render_priv-&gt;state.frx = render_priv-&gt;state.fry = 0.;
    render_priv-&gt;state.frz = style-&gt;Angle;
    render_priv-&gt;state.fax = render_priv-&gt;state.fay = 0.;
    render_priv-&gt;state.font_encoding = style-&gt;Encoding;
}
static void</b></font><font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>
init_render_context(ASS_Renderer *render_priv, ASS_Event *event)
{
    render_priv-&gt;state.event = event;
    render_priv-&gt;state.parsed_tags = 0;
    render_priv-&gt;state.evt_type = EVENT_NORMAL;
    render_priv-&gt;state.wrap_style = render_priv-&gt;track-&gt;WrapStyle;
    render_priv-&gt;state.pos_x = 0;
    render_priv-&gt;state.pos_y = 0;
    render_priv-&gt;state.org_x = 0;
    render_priv-&gt;state.org_y = 0;
    render_priv-&gt;state.have_origin = 0;
    render_priv-&gt;state.clip_x0 = 0;
    render_priv-&gt;state.clip_y0 = 0;
    render_priv-&gt;state.clip_x1 = render_priv-&gt;track-&gt;PlayResX;
    render_priv-&gt;state.clip_y1 = render_priv-&gt;track-&gt;PlayResY;</b></font>
    render_priv-&gt;state.clip_mode = 0;
    render_priv-&gt;state.detect_collisions = 1;
    render_priv-&gt;state.fade = 0;
    render_priv-&gt;state.drawing_scale = 0;
    render_priv-&gt;state.pbo = 0;
    render_priv-&gt;state.effect_type = EF_NONE;
    render_priv-&gt;state.effect_timing = 0;
    render_priv-&gt;state.effect_skip_timing = 0;
    apply_transition_effects(render_priv, event);
    render_priv-&gt;state.explicit = render_priv-&gt;state.evt_type != EVENT_NORMAL ||
                                  event_has_hard_overrides(event-&gt;Text);
    reset_render_context(render_priv, NULL);
    render_priv-&gt;state.alignment = render_priv-&gt;state.style-&gt;Alignment;
    render_priv-&gt;state.justify = render_priv-&gt;state.style-&gt;Justify;
}
static void free_render_context(ASS_Renderer *render_priv)
{
    ass_cache_dec_ref(render_priv-&gt;state.font);
    render_priv-&gt;state.font = NULL;
    render_priv-&gt;state.family.str = NULL;
    render_priv-&gt;state.family.len = 0;
    render_priv-&gt;state.clip_drawing_text.str = NULL;
    render_priv-&gt;state.clip_drawing_text.len = 0;
    render_priv-&gt;text_info.length = 0;
}
static void
get_outline_glyph(ASS_Renderer *priv, GlyphInfo *info)
{
    OutlineHashValue *val;
    ASS_DVector scale, offset = {0};
    int32_t asc, desc;
    OutlineHashKey key;
    if (info-&gt;drawing_text.str) {
        key.type = OUTLINE_DRAWING;
        key.u.drawing.text = info-&gt;drawing_text;
        val = ass_cache_get(priv-&gt;cache.outline_cache, &amp;key, priv);
        if (!val || !val-&gt;valid) {
            ass_cache_dec_ref(val);
            return;
        }
        int32_t scale_base = lshiftwrapi(1, info-&gt;drawing_scale - 1);
        double w = scale_base &gt; 0 ? (priv-&gt;font_scale / scale_base) : 0;
        scale.x = info-&gt;scale_x * w;
        scale.y = info-&gt;scale_y * w;
        desc = 64 * info-&gt;drawing_pbo;
        asc = val-&gt;asc - desc;
        offset.y = -asc * scale.y;
    } else {
        key.type = OUTLINE_GLYPH;
        GlyphHashKey *k = &amp;key.u.glyph;
        k-&gt;font = info-&gt;font;
        k-&gt;size = info-&gt;font_size;
        k-&gt;face_index = info-&gt;face_index;
        k-&gt;glyph_index = info-&gt;glyph_index;
        k-&gt;bold = info-&gt;bold;
        k-&gt;italic = info-&gt;italic;
        k-&gt;flags = info-&gt;flags;
        val = ass_cache_get(priv-&gt;cache.outline_cache, &amp;key, priv);
        if (!val || !val-&gt;valid) {
            ass_cache_dec_ref(val);
            return;
        }
        scale.x = info-&gt;scale_x;
        scale.y = info-&gt;scale_y;
        asc  = val-&gt;asc;
        desc = val-&gt;desc;
    }
    info-&gt;outline = val;
    info-&gt;transform.scale = scale;
    info-&gt;transform.offset = offset;
    info-&gt;bbox.x_min = lrint(val-&gt;cbox.x_min * scale.x + offset.x);
    info-&gt;bbox.y_min = lrint(val-&gt;cbox.y_min * scale.y + offset.y);
    info-&gt;bbox.x_max = lrint(val-&gt;cbox.x_max * scale.x + offset.x);
    info-&gt;bbox.y_max = lrint(val-&gt;cbox.y_max * scale.y + offset.y);
    if (info-&gt;drawing_text.str || priv-&gt;settings.shaper == ASS_SHAPING_SIMPLE) {
        info-&gt;cluster_advance.x = info-&gt;advance.x = lrint(val-&gt;advance * scale.x);
        info-&gt;cluster_advance.y = info-&gt;advance.y = 0;
    }
    info-&gt;asc  = lrint(asc  * scale.y);
    info-&gt;desc = lrint(desc * scale.y);
}
size_t ass_outline_construct(void *key, void *value, void *priv)
{
    ASS_Renderer *render_priv = priv;
    OutlineHashKey *outline_key = key;
    OutlineHashValue *v = value;
    memset(v, 0, sizeof(*v));
    switch (outline_key-&gt;type) {
    case OUTLINE_GLYPH:
        {
            GlyphHashKey *k = &amp;outline_key-&gt;u.glyph;
            ass_face_set_size(k-&gt;font-&gt;faces[k-&gt;face_index], k-&gt;size);
            if (!ass_font_get_glyph(k-&gt;font, k-&gt;face_index, k-&gt;glyph_index,
                                    render_priv-&gt;settings.hinting))
                return 1;
            if (!ass_get_glyph_outline(&amp;v-&gt;outline[0], &amp;v-&gt;advance,
                                       k-&gt;font-&gt;faces[k-&gt;face_index],
                                       k-&gt;flags))
                return 1;
            ass_font_get_asc_desc(k-&gt;font, k-&gt;face_index,
                                  &amp;v-&gt;asc, &amp;v-&gt;desc);
            break;
        }
    case OUTLINE_DRAWING:
        {
            ASS_Rect bbox;
            const char *text = outline_key-&gt;u.drawing.text.str;              if (!ass_drawing_parse(&amp;v-&gt;outline[0], &amp;bbox, text, render_priv-&gt;library))
                return 1;
            v-&gt;advance = bbox.x_max - bbox.x_min;
            v-&gt;asc = bbox.y_max - bbox.y_min;
            v-&gt;desc = 0;
            break;
        }
    case OUTLINE_BORDER:
        {
            BorderHashKey *k = &amp;outline_key-&gt;u.border;
            if (!k-&gt;border.x &amp;&amp; !k-&gt;border.y)
                break;
            if (!k-&gt;outline-&gt;outline[0].n_points)
                break;
            ASS_Outline src;
            if (!outline_scale_pow2(&amp;src, &amp;k-&gt;outline-&gt;outline[0],
                                    k-&gt;scale_ord_x, k-&gt;scale_ord_y))
                return 1;
            if (!outline_stroke(&amp;v-&gt;outline[0], &amp;v-&gt;outline[1], &amp;src,
                                k-&gt;border.x * STROKER_PRECISION,
                                k-&gt;border.y * STROKER_PRECISION,
                                STROKER_PRECISION)) {
                ass_msg(render_priv-&gt;library, MSGL_WARN, "Cannot stroke outline");
                outline_free(&amp;v-&gt;outline[0]);
                outline_free(&amp;v-&gt;outline[1]);
                outline_free(&amp;src);
                return 1;
            }
            outline_free(&amp;src);
            break;
        }
    case OUTLINE_BOX:
        {
            ASS_Outline *ol = &amp;v-&gt;outline[0];
            if (!outline_alloc(ol, 4, 4))
                return 1;
            ol-&gt;points[0].x = ol-&gt;points[3].x = 0;
            ol-&gt;points[1].x = ol-&gt;points[2].x = 64;
            ol-&gt;points[0].y = ol-&gt;points[1].y = 0;
            ol-&gt;points[2].y = ol-&gt;points[3].y = 64;
            ol-&gt;segments[0] = OUTLINE_LINE_SEGMENT;
            ol-&gt;segments[1] = OUTLINE_LINE_SEGMENT;
            ol-&gt;segments[2] = OUTLINE_LINE_SEGMENT;
            ol-&gt;segments[3] = OUTLINE_LINE_SEGMENT | OUTLINE_CONTOUR_END;
            ol-&gt;n_points = ol-&gt;n_segments = 4;
            break;
        }
    default:
        return 1;
    }
    rectangle_reset(&amp;v-&gt;cbox);
    outline_update_cbox(&amp;v-&gt;outline[0], &amp;v-&gt;cbox);
    outline_update_cbox(&amp;v-&gt;outline[1], &amp;v-&gt;cbox);
    if (v-&gt;cbox.x_min &gt; v-&gt;cbox.x_max || v-&gt;cbox.y_min &gt; v-&gt;cbox.y_max)
        v-&gt;cbox.x_min = v-&gt;cbox.y_min = v-&gt;cbox.x_max = v-&gt;cbox.y_max = 0;
    v-&gt;valid = true;
    return 1;
}
static void calc_transform_matrix(ASS_Renderer *render_priv,
                                  GlyphInfo *info, double m[3][3])
{
    double frx = ASS_PI / 180 * info-&gt;frx;
    double fry = ASS_PI / 180 * info-&gt;fry;
    double frz = ASS_PI / 180 * info-&gt;frz;
    double sx = -sin(frx), cx = cos(frx);
    double sy =  sin(fry), cy = cos(fry);
    double sz = -sin(frz), cz = cos(frz);
    double fax = info-&gt;fax * info-&gt;scale_x / info-&gt;scale_y;
    double fay = info-&gt;fay * info-&gt;scale_y / info-&gt;scale_x;
    double x1[3] = { 1, fax, info-&gt;shift.x + info-&gt;asc * fax };
    double y1[3] = { fay, 1, info-&gt;shift.y };
    double x2[3], y2[3];
    for (int i = 0; i &lt; 3; i++) {
        x2[i] = x1[i] * cz - y1[i] * sz;
        y2[i] = x1[i] * sz + y1[i] * cz;
    }
    double y3[3], z3[3];
    for (int i = 0; i &lt; 3; i++) {
        y3[i] = y2[i] * cx;
        z3[i] = y2[i] * sx;
    }
    double x4[3], z4[3];
    for (int i = 0; i &lt; 3; i++) {
        x4[i] = x2[i] * cy - z3[i] * sy;
        z4[i] = x2[i] * sy + z3[i] * cy;
    }
    double dist = 20000 * render_priv-&gt;blur_scale;
    z4[2] += dist;
    double scale_x = dist * render_priv-&gt;font_scale_x;
    double offs_x = info-&gt;pos.x - info-&gt;shift.x * render_priv-&gt;font_scale_x;
    double offs_y = info-&gt;pos.y - info-&gt;shift.y;
    for (int i = 0; i &lt; 3; i++) {
        m[0][i] = z4[i] * offs_x + x4[i] * scale_x;
        m[1][i] = z4[i] * offs_y + y3[i] * dist;
        m[2][i] = z4[i];
    }
}
static void
get_bitmap_glyph(ASS_Renderer *render_priv, GlyphInfo *info,
                 int32_t *leftmost_x,
                 ASS_Vector *pos, ASS_Vector *pos_o,
                 ASS_DVector *offset, bool first, int flags)
{
    if (!info-&gt;outline || info-&gt;symbol == '\n' || info-&gt;symbol == 0 || info-&gt;skip) {
        ass_cache_dec_ref(info-&gt;outline);
        return;
    }
    double m1[3][3], m2[3][3], m[3][3];
    const ASS_Transform *tr = &amp;info-&gt;transform;
    calc_transform_matrix(render_priv, info, m1);
    for (int i = 0; i &lt; 3; i++) {
        m2[i][0] = m1[i][0] * tr-&gt;scale.x;
        m2[i][1] = m1[i][1] * tr-&gt;scale.y;
        m2[i][2] = m1[i][0] * tr-&gt;offset.x + m1[i][1] * tr-&gt;offset.y + m1[i][2];
    }
    memcpy(m, m2, sizeof(m));
    if (info-&gt;effect_type == EF_KARAOKE_KF)
        outline_update_min_transformed_x(&amp;info-&gt;outline-&gt;outline[0], m, leftmost_x);
    BitmapHashKey key;
    key.outline = info-&gt;outline;
    if (!quantize_transform(m, pos, offset, first, &amp;key)) {
        ass_cache_dec_ref(info-&gt;outline);
        return;
    }
    info-&gt;bm = ass_cache_get(render_priv-&gt;cache.bitmap_cache, &amp;key, render_priv);
    if (!info-&gt;bm || !info-&gt;bm-&gt;buffer) {
        ass_cache_dec_ref(info-&gt;bm);
        info-&gt;bm = NULL;
    }
    *pos_o = *pos;
    OutlineHashKey ol_key;
    if (flags &amp; FILTER_BORDER_STYLE_3) {
        if (!(flags &amp; (FILTER_NONZERO_BORDER | FILTER_NONZERO_SHADOW)))
            return;
        ol_key.type = OUTLINE_BOX;
        double w = 64 * render_priv-&gt;border_scale;
        ASS_DVector bord = { info-&gt;border_x * w, info-&gt;border_y * w };
        double width = info-&gt;hspacing_scaled + info-&gt;advance.x;
        double height = info-&gt;asc + info-&gt;desc;
        ASS_DVector orig_scale;
        orig_scale.x = info-&gt;scale_x * info-&gt;scale_fix;
        orig_scale.y = info-&gt;scale_y * info-&gt;scale_fix;
        bord.x *= orig_scale.x;
        bord.y *= orig_scale.y;
        width  *= orig_scale.x;
        height *= orig_scale.y;
        bord.x = FFMAX(64, bord.x);
        bord.y = FFMAX(64, bord.y);
        ASS_DVector scale = {
            (width  + 2 * bord.x) / 64,
            (height + 2 * bord.y) / 64,
        };
        ASS_DVector offset = { -bord.x, -bord.y - info-&gt;asc };
        for (int i = 0; i &lt; 3; i++) {
            m[i][0] = m1[i][0] * scale.x;
            m[i][1] = m1[i][1] * scale.y;
            m[i][2] = m1[i][0] * offset.x + m1[i][1] * offset.y + m1[i][2];
        }
    } else {
        if (!(flags &amp; FILTER_NONZERO_BORDER))
            return;
        ol_key.type = OUTLINE_BORDER;
        BorderHashKey *k = &amp;ol_key.u.border;
        k-&gt;outline = info-&gt;outline;
        double w = 64 * render_priv-&gt;border_scale;
        double bord_x = w * info-&gt;border_x / tr-&gt;scale.x;
        double bord_y = w * info-&gt;border_y / tr-&gt;scale.y;
        const ASS_Rect *bbox = &amp;info-&gt;outline-&gt;cbox;
        double dx = (bbox-&gt;x_max - bbox-&gt;x_min) / 2.0 + (bord_x + 64);
        double dy = (bbox-&gt;y_max - bbox-&gt;y_min) / 2.0 + (bord_y + 64);
        double mxx = fabs(m[0][0]), mxy = fabs(m[0][1]);
        double myx = fabs(m[1][0]), myy = fabs(m[1][1]);
        double mzx = fabs(m[2][0]), mzy = fabs(m[2][1]);
        double z0 = m[2][2] - mzx * dx - mzy * dy;
        w = 1 / FFMAX(z0, m[2][2] / MAX_PERSP_SCALE);
        double x_lim = mxx * dx + mxy * dy;
        double y_lim = myx * dx + myy * dy;
        double rz = FFMAX(x_lim, y_lim) * w;
        w *= STROKER_PRECISION / POSITION_PRECISION;
        frexp(w * (FFMAX(mxx, myx) + mzx * rz), &amp;k-&gt;scale_ord_x);
        frexp(w * (FFMAX(mxy, myy) + mzy * rz), &amp;k-&gt;scale_ord_y);
        bord_x = ldexp(bord_x, k-&gt;scale_ord_x);
        bord_y = ldexp(bord_y, k-&gt;scale_ord_y);
        if (!(bord_x &lt; OUTLINE_MAX &amp;&amp; bord_y &lt; OUTLINE_MAX))
            return;
        k-&gt;border.x = lrint(bord_x / STROKER_PRECISION);
        k-&gt;border.y = lrint(bord_y / STROKER_PRECISION);
        if (!k-&gt;border.x &amp;&amp; !k-&gt;border.y) {
            ass_cache_inc_ref(info-&gt;bm);
            info-&gt;bm_o = info-&gt;bm;
            return;
        }
        for (int i = 0; i &lt; 3; i++) {
            m[i][0] = ldexp(m2[i][0], -k-&gt;scale_ord_x);
            m[i][1] = ldexp(m2[i][1], -k-&gt;scale_ord_y);
            m[i][2] = m2[i][2];
        }
    }
    key.outline = ass_cache_get(render_priv-&gt;cache.outline_cache, &amp;ol_key, render_priv);
    if (!key.outline || !key.outline-&gt;valid ||
            !quantize_transform(m, pos_o, offset, false, &amp;key)) {
        ass_cache_dec_ref(key.outline);
        return;
    }
    info-&gt;bm_o = ass_cache_get(render_priv-&gt;cache.bitmap_cache, &amp;key, render_priv);
    if (!info-&gt;bm_o || !info-&gt;bm_o-&gt;buffer) {
        ass_cache_dec_ref(info-&gt;bm_o);
        info-&gt;bm_o = NULL;
        *pos_o = *pos;
    } else if (!info-&gt;bm)
        *pos = *pos_o;
}
size_t ass_bitmap_construct(void *key, void *value, void *priv)
{
    ASS_Renderer *render_priv = priv;
    BitmapHashKey *k = key;
    Bitmap *bm = value;
    double m[3][3];
    restore_transform(m, k);
    ASS_Outline outline[2];
    if (k-&gt;matrix_z.x || k-&gt;matrix_z.y) {
        outline_transform_3d(&amp;outline[0], &amp;k-&gt;outline-&gt;outline[0], m);
        outline_transform_3d(&amp;outline[1], &amp;k-&gt;outline-&gt;outline[1], m);
    } else {
        outline_transform_2d(&amp;outline[0], &amp;k-&gt;outline-&gt;outline[0], m);
        outline_transform_2d(&amp;outline[1], &amp;k-&gt;outline-&gt;outline[1], m);
    }
    if (!outline_to_bitmap(render_priv, bm, &amp;outline[0], &amp;outline[1]))
        memset(bm, 0, sizeof(*bm));
    outline_free(&amp;outline[0]);
    outline_free(&amp;outline[1]);
    return sizeof(BitmapHashKey) + sizeof(Bitmap) + bitmap_size(bm);
}
static void measure_text_on_eol(ASS_Renderer *render_priv, double scale, int cur_line,
                                int max_asc, int max_desc,
                                double max_border_x, double max_border_y)
{
    render_priv-&gt;text_info.lines[cur_line].asc  = scale * max_asc;
    render_priv-&gt;text_info.lines[cur_line].desc = scale * max_desc;
    render_priv-&gt;text_info.height += scale * max_asc + scale * max_desc;
    render_priv-&gt;text_info.border_bottom = (int) (render_priv-&gt;border_scale * max_border_y + 0.5);
    if (cur_line == 0)
        render_priv-&gt;text_info.border_top = render_priv-&gt;text_info.border_bottom;
    render_priv-&gt;text_info.border_x = FFMAX(render_priv-&gt;text_info.border_x,
            (int) (render_priv-&gt;border_scale * max_border_x + 0.5));
}
static void measure_text(ASS_Renderer *render_priv)
{
    TextInfo *text_info = &amp;render_priv-&gt;text_info;
    text_info-&gt;height = 0;
    text_info-&gt;border_x = 0;
    int cur_line = 0;
    double scale = 0.5 / 64;
    int max_asc = 0, max_desc = 0;
    double max_border_y = 0, max_border_x = 0;
    bool empty_trimmed_line = true;
    for (int i = 0; i &lt; text_info-&gt;length; i++) {
        if (text_info-&gt;glyphs[i].linebreak) {
            measure_text_on_eol(render_priv, scale, cur_line,
                    max_asc, max_desc, max_border_x, max_border_y);
            empty_trimmed_line = true;
            max_asc = max_desc = 0;
            max_border_y = max_border_x = 0;
            scale = 0.5 / 64;
            cur_line++;
        }
        GlyphInfo *cur = text_info-&gt;glyphs + i;
        if (empty_trimmed_line &amp;&amp; !cur-&gt;is_trimmed_whitespace) {
            empty_trimmed_line = false;
            max_asc = max_desc = 0;
            max_border_y = max_border_x = 0;
        } else if (!empty_trimmed_line &amp;&amp; cur-&gt;is_trimmed_whitespace) {
            continue;
        }
        max_asc  = FFMAX(max_asc,  cur-&gt;asc);
        max_desc = FFMAX(max_desc, cur-&gt;desc);
        max_border_y = FFMAX(max_border_y, cur-&gt;border_y);
        max_border_x = FFMAX(max_border_x, cur-&gt;border_x);
        if (cur-&gt;symbol != '\n')
            scale = 1.0 / 64;
    }
    assert(cur_line == text_info-&gt;n_lines - 1);
    measure_text_on_eol(render_priv, scale, cur_line,
            max_asc, max_desc, max_border_x, max_border_y);
    text_info-&gt;height += cur_line * render_priv-&gt;settings.line_spacing;
}
#define IS_WHITESPACE(x) ((x-&gt;symbol == ' ' || x-&gt;symbol == '\n') \
                          &amp;&amp; !x-&gt;linebreak)
static void trim_whitespace(ASS_Renderer *render_priv)
{
    int i, j;
    GlyphInfo *cur;
    TextInfo *ti = &amp;render_priv-&gt;text_info;
    i = ti-&gt;length - 1;
    cur = ti-&gt;glyphs + i;
    while (i &amp;&amp; IS_WHITESPACE(cur)) {
        cur-&gt;skip = true;
        cur-&gt;is_trimmed_whitespace = true;
        cur = ti-&gt;glyphs + --i;
    }
    i = 0;
    cur = ti-&gt;glyphs;
    while (i &lt; ti-&gt;length &amp;&amp; IS_WHITESPACE(cur)) {
        cur-&gt;skip = true;
        cur-&gt;is_trimmed_whitespace = true;
        cur = ti-&gt;glyphs + ++i;
    }
    if (i &lt; ti-&gt;length)
        cur-&gt;starts_new_run = true;
    for (i = 0; i &lt; ti-&gt;length; ++i) {
        cur = ti-&gt;glyphs + i;
        if (cur-&gt;linebreak) {
            j = i - 1;
            cur = ti-&gt;glyphs + j;
            while (j &amp;&amp; IS_WHITESPACE(cur)) {
                cur-&gt;skip = true;
                cur-&gt;is_trimmed_whitespace = true;
                cur = ti-&gt;glyphs + --j;
            }
            cur = ti-&gt;glyphs + i;
            if (cur-&gt;symbol == ' ' || cur-&gt;symbol == '\n') {
                cur-&gt;skip = true;
                cur-&gt;is_trimmed_whitespace = true;
                j = i + 1;
                cur = ti-&gt;glyphs + j;
                while (j &lt; ti-&gt;length &amp;&amp; IS_WHITESPACE(cur)) {
                    cur-&gt;skip = true;
                    cur-&gt;is_trimmed_whitespace = true;
                    cur = ti-&gt;glyphs + ++j;
                }
                i = j - 1;
            }
            if (cur &lt; ti-&gt;glyphs + ti-&gt;length)
                cur-&gt;starts_new_run = true;
        }
    }
}
#undef IS_WHITESPACE
static void
wrap_lines_smart(ASS_Renderer *render_priv, double max_text_width)
{
    int i;
    GlyphInfo *cur, *s1, *e1, *s2, *s3;
    int last_space;
    int break_type;
    int exit;
    double pen_shift_x;
    double pen_shift_y;
    int cur_line;
    TextInfo *text_info = &amp;render_priv-&gt;text_info;
    last_space = -1;
    text_info-&gt;n_lines = 1;
    break_type = 0;
    s1 = text_info-&gt;glyphs;         for (i = 0; i &lt; text_info-&gt;length; ++i) {
        int break_at = -1;
        double s_offset, len;
        cur = text_info-&gt;glyphs + i;
        s_offset = d6_to_double(s1-&gt;bbox.x_min + s1-&gt;pos.x);
        len = d6_to_double(cur-&gt;bbox.x_max + cur-&gt;pos.x) - s_offset;
        if (cur-&gt;symbol == '\n') {
            break_type = 2;
            break_at = i;
            ass_msg(render_priv-&gt;library, MSGL_DBG2,
                    "forced line break at %d", break_at);
        } else if (cur-&gt;symbol == ' ') {
            last_space = i;
        } else if (len &gt;= max_text_width
                   &amp;&amp; (render_priv-&gt;state.wrap_style != 2)) {
            break_type = 1;
            break_at = last_space;
            if (break_at &gt;= 0)
                ass_msg(render_priv-&gt;library, MSGL_DBG2, "line break at %d",
                        break_at);
        }
        if (break_at != -1) {
            int lead = break_at + 1;                if (text_info-&gt;n_lines &gt;= text_info-&gt;max_lines) {
                text_info-&gt;max_lines *= 2;
                text_info-&gt;lines = realloc(text_info-&gt;lines,
                                           sizeof(LineInfo) *
                                           text_info-&gt;max_lines);
            }
            if (lead &lt; text_info-&gt;length) {
                text_info-&gt;glyphs[lead].linebreak = break_type;
                last_space = -1;
                s1 = text_info-&gt;glyphs + lead;
                text_info-&gt;n_lines++;
            }
        }
    }
#define DIFF(x,y) (((x) &lt; (y)) ? (y - x) : (x - y))
    exit = 0;
    while (!exit &amp;&amp; render_priv-&gt;state.wrap_style != 1) {
        exit = 1;
        s3 = text_info-&gt;glyphs;
        s1 = s2 = 0;
        for (i = 0; i &lt;= text_info-&gt;length; ++i) {
            cur = text_info-&gt;glyphs + i;
            if ((i == text_info-&gt;length) || cur-&gt;linebreak) {
                s1 = s2;
                s2 = s3;
                s3 = cur;
                if (s1 &amp;&amp; (s2-&gt;linebreak == 1)) {                           double l1, l2, l1_new, l2_new;
                    GlyphInfo *w = s2;
                    do {
                        --w;
                    } while ((w &gt; s1) &amp;&amp; (w-&gt;symbol == ' '));
                    while ((w &gt; s1) &amp;&amp; (w-&gt;symbol != ' ')) {
                        --w;
                    }
                    e1 = w;
                    while ((e1 &gt; s1) &amp;&amp; (e1-&gt;symbol == ' ')) {
                        --e1;
                    }
                    if (w-&gt;symbol == ' ')
                        ++w;
                    l1 = d6_to_double(((s2 - 1)-&gt;bbox.x_max + (s2 - 1)-&gt;pos.x) -
                        (s1-&gt;bbox.x_min + s1-&gt;pos.x));
                    l2 = d6_to_double(((s3 - 1)-&gt;bbox.x_max + (s3 - 1)-&gt;pos.x) -
                        (s2-&gt;bbox.x_min + s2-&gt;pos.x));
                    l1_new = d6_to_double(
                        (e1-&gt;bbox.x_max + e1-&gt;pos.x) -
                        (s1-&gt;bbox.x_min + s1-&gt;pos.x));
                    l2_new = d6_to_double(
                        ((s3 - 1)-&gt;bbox.x_max + (s3 - 1)-&gt;pos.x) -
                        (w-&gt;bbox.x_min + w-&gt;pos.x));
                    if (DIFF(l1_new, l2_new) &lt; DIFF(l1, l2)) {
                        if (w-&gt;linebreak || w == text_info-&gt;glyphs)
                            text_info-&gt;n_lines--;
                        if (w != text_info-&gt;glyphs)
                            w-&gt;linebreak = 1;
                        s2-&gt;linebreak = 0;
                        exit = 0;
                    }
                }
            }
            if (i == text_info-&gt;length)
                break;
        }
    }
    assert(text_info-&gt;n_lines &gt;= 1);
#undef DIFF
    trim_whitespace(render_priv);
    measure_text(render_priv);
    cur_line = 1;
    i = 0;
    cur = text_info-&gt;glyphs + i;
    while (i &lt; text_info-&gt;length &amp;&amp; cur-&gt;skip)
        cur = text_info-&gt;glyphs + ++i;
    pen_shift_x = d6_to_double(-cur-&gt;pos.x);
    pen_shift_y = 0.;
    for (i = 0; i &lt; text_info-&gt;length; ++i) {
        cur = text_info-&gt;glyphs + i;
        if (cur-&gt;linebreak) {
            while (i &lt; text_info-&gt;length &amp;&amp; cur-&gt;skip &amp;&amp; cur-&gt;symbol != '\n')
                cur = text_info-&gt;glyphs + ++i;
            double height =
                text_info-&gt;lines[cur_line - 1].desc +
                text_info-&gt;lines[cur_line].asc;
            text_info-&gt;lines[cur_line - 1].len = i -
                text_info-&gt;lines[cur_line - 1].offset;
            text_info-&gt;lines[cur_line].offset = i;
            cur_line++;
            pen_shift_x = d6_to_double(-cur-&gt;pos.x);
            pen_shift_y += height + render_priv-&gt;settings.line_spacing;
        }
        cur-&gt;pos.x += double_to_d6(pen_shift_x);
        cur-&gt;pos.y += double_to_d6(pen_shift_y);
    }
    text_info-&gt;lines[cur_line - 1].len =
        text_info-&gt;length - text_info-&gt;lines[cur_line - 1].offset;
#if 0
    for (i = 0; i &lt; text_info-&gt;n_lines; i++) {
        printf("line %d offset %d length %d\n", i, text_info-&gt;lines[i].offset,
                text_info-&gt;lines[i].len);
    }
#endif
}
static void get_base_point(ASS_DRect *bbox, int alignment, double *bx, double *by)
{
    const int halign = alignment &amp; 3;
    const int valign = alignment &amp; 12;
    if (bx)
        switch (halign) {
        case HALIGN_LEFT:
            *bx = bbox-&gt;x_min;
            break;
        case HALIGN_CENTER:
            *bx = (bbox-&gt;x_max + bbox-&gt;x_min) / 2.0;
            break;
        case HALIGN_RIGHT:
            *bx = bbox-&gt;x_max;
            break;
        }
    if (by)
        switch (valign) {
        case VALIGN_TOP:
            *by = bbox-&gt;y_min;
            break;
        case VALIGN_CENTER:
            *by = (bbox-&gt;y_max + bbox-&gt;y_min) / 2.0;
            break;
        case VALIGN_SUB:
            *by = bbox-&gt;y_max;
            break;
        }
}
static void
fix_glyph_scaling(ASS_Renderer *priv, GlyphInfo *glyph)
{
    double ft_size;
    if (priv-&gt;settings.hinting == ASS_HINTING_NONE) {
        ft_size = 256.0;
    } else {
        ft_size = glyph-&gt;scale_y * glyph-&gt;font_size;
    }
    double mul = glyph-&gt;font_size / ft_size;
    glyph-&gt;scale_fix = 1 / mul;
    glyph-&gt;scale_x *= mul;
    glyph-&gt;scale_y *= mul;
    glyph-&gt;font_size = ft_size;
}
static void split_style_runs(ASS_Renderer *render_priv)
{
    Effect last_effect_type = render_priv-&gt;text_info.glyphs[0].effect_type;
    render_priv-&gt;text_info.glyphs[0].starts_new_run = true;
    for (int i = 1; i &lt; render_priv-&gt;text_info.length; i++) {
        GlyphInfo *info = render_priv-&gt;text_info.glyphs + i;
        GlyphInfo *last = render_priv-&gt;text_info.glyphs + (i - 1);
        Effect effect_type = info-&gt;effect_type;
        info-&gt;starts_new_run =
            info-&gt;effect_timing ||              (effect_type != EF_NONE &amp;&amp; effect_type != last_effect_type) ||
            info-&gt;drawing_text.str ||
            last-&gt;drawing_text.str ||
            !ass_string_equal(last-&gt;font-&gt;desc.family, info-&gt;font-&gt;desc.family) ||
            last-&gt;font-&gt;desc.vertical != info-&gt;font-&gt;desc.vertical ||
            last-&gt;font_size != info-&gt;font_size ||
            last-&gt;c[0] != info-&gt;c[0] ||
            last-&gt;c[1] != info-&gt;c[1] ||
            last-&gt;c[2] != info-&gt;c[2] ||
            last-&gt;c[3] != info-&gt;c[3] ||
            last-&gt;be != info-&gt;be ||
            last-&gt;blur != info-&gt;blur ||
            last-&gt;shadow_x != info-&gt;shadow_x ||
            last-&gt;shadow_y != info-&gt;shadow_y ||
            last-&gt;frx != info-&gt;frx ||
            last-&gt;fry != info-&gt;fry ||
            last-&gt;frz != info-&gt;frz ||
            last-&gt;fax != info-&gt;fax ||
            last-&gt;fay != info-&gt;fay ||
            last-&gt;scale_x != info-&gt;scale_x ||
            last-&gt;scale_y != info-&gt;scale_y ||
            last-&gt;border_style != info-&gt;border_style ||
            last-&gt;border_x != info-&gt;border_x ||
            last-&gt;border_y != info-&gt;border_y ||
            last-&gt;hspacing != info-&gt;hspacing ||
            last-&gt;italic != info-&gt;italic ||
            last-&gt;bold != info-&gt;bold ||
            ((last-&gt;flags ^ info-&gt;flags) &amp; ~DECO_ROTATE);
        if (effect_type != EF_NONE)
            last_effect_type = effect_type;
    }
}
static bool parse_events(ASS_Renderer *render_priv, ASS_Event *event)
{
    TextInfo *text_info = &amp;render_priv-&gt;text_info;
    char *p = event-&gt;Text, *q;
    while (true) {
        ASS_StringView drawing_text = {NULL, 0};
        unsigned code = 0;
        while (*p) {
            if ((*p == '{') &amp;&amp; (q = strchr(p, '}'))) {
                p = parse_tags(render_priv, p, q, 1., false);
                assert(*p == '}');
                p++;
            } else if (render_priv-&gt;state.drawing_scale) {
                q = p;
                if (*p == '{')
                    q++;
                while ((*q != '{') &amp;&amp; (*q != 0))
                    q++;
                drawing_text.str = p;
                drawing_text.len = q - p;
                code = 0xfffc;                 p = q;
                break;
            } else {
                code = get_next_char(render_priv, &amp;p);
                break;
            }
        }
        if (code == 0)
            break;
        if (!render_priv-&gt;state.font)
            goto fail;
        if (text_info-&gt;length &gt;= text_info-&gt;max_glyphs) {
            int new_max = 2 * FFMIN(text_info-&gt;max_glyphs, INT_MAX / 2);
            if (text_info-&gt;length &gt;= new_max)
                goto fail;
            if (!ASS_REALLOC_ARRAY(text_info-&gt;glyphs, new_max))
                goto fail;
            text_info-&gt;max_glyphs = new_max;
        }
        GlyphInfo *info = &amp;text_info-&gt;glyphs[text_info-&gt;length];
        memset(info, 0, sizeof(GlyphInfo));
        if (drawing_text.str) {
            info-&gt;drawing_text = drawing_text;
            info-&gt;drawing_scale = render_priv-&gt;state.drawing_scale;
            info-&gt;drawing_pbo = render_priv-&gt;state.pbo;
        }
        info-&gt;symbol = code;
        info-&gt;font = render_priv-&gt;state.font;
        if (!drawing_text.str)
            ass_cache_inc_ref(info-&gt;font);
        for (int i = 0; i &lt; 4; i++) {
            uint32_t clr = render_priv-&gt;state.c[i];
            info-&gt;a_pre_fade[i] = _a(clr);
            if (render_priv-&gt;state.fade &gt; 0)
                change_alpha(&amp;clr,
                             mult_alpha(_a(clr), render_priv-&gt;state.fade), 1.);
            info-&gt;c[i] = clr;
        }
        info-&gt;effect_type = render_priv-&gt;state.effect_type;
        info-&gt;effect_timing = render_priv-&gt;state.effect_timing;
        info-&gt;effect_skip_timing = render_priv-&gt;state.effect_skip_timing;
        info-&gt;font_size =
            fabs(render_priv-&gt;state.font_size * render_priv-&gt;font_scale);
        info-&gt;be = render_priv-&gt;state.be;
        info-&gt;blur = render_priv-&gt;state.blur;
        info-&gt;shadow_x = render_priv-&gt;state.shadow_x;
        info-&gt;shadow_y = render_priv-&gt;state.shadow_y;
        info-&gt;scale_x = render_priv-&gt;state.scale_x;
        info-&gt;scale_y = render_priv-&gt;state.scale_y;
        info-&gt;border_style = render_priv-&gt;state.border_style;
        info-&gt;border_x = render_priv-&gt;state.border_x;
        info-&gt;border_y = render_priv-&gt;state.border_y;
        info-&gt;hspacing = render_priv-&gt;state.hspacing;
        info-&gt;bold = render_priv-&gt;state.bold;
        info-&gt;italic = render_priv-&gt;state.italic;
        info-&gt;flags = render_priv-&gt;state.flags;
        if (info-&gt;font-&gt;desc.vertical &amp;&amp; code &gt;= VERTICAL_LOWER_BOUND)
            info-&gt;flags |= DECO_ROTATE;
        info-&gt;frx = render_priv-&gt;state.frx;
        info-&gt;fry = render_priv-&gt;state.fry;
        info-&gt;frz = render_priv-&gt;state.frz;
        info-&gt;fax = render_priv-&gt;state.fax;
        info-&gt;fay = render_priv-&gt;state.fay;
        info-&gt;fade = render_priv-&gt;state.fade;
        info-&gt;hspacing_scaled = 0;
        info-&gt;scale_fix = 1;
        if (!drawing_text.str) {
            info-&gt;hspacing_scaled = double_to_d6(info-&gt;hspacing *
                    render_priv-&gt;font_scale * info-&gt;scale_x);
            fix_glyph_scaling(render_priv, info);
        }
        text_info-&gt;length++;
        render_priv-&gt;state.effect_type = EF_NONE;
        render_priv-&gt;state.effect_timing = 0;
        render_priv-&gt;state.effect_skip_timing = 0;
    }
    return true;
fail:
    free_render_context(render_priv);
    return false;
}
static void retrieve_glyphs(ASS_Renderer *render_priv)
{
    GlyphInfo *glyphs = render_priv-&gt;text_info.glyphs;
    int i;
    for (i = 0; i &lt; render_priv-&gt;text_info.length; i++) {
        GlyphInfo *info = glyphs + i;
        do {
            get_outline_glyph(render_priv, info);
            info = info-&gt;next;
        } while (info);
        info = glyphs + i;
        if (i &amp;&amp; glyphs[i - 1].italic &amp;&amp; !info-&gt;italic) {
            int back = i - 1;
            GlyphInfo *og = &amp;glyphs[back];
            while (back &amp;&amp; og-&gt;bbox.x_max - og-&gt;bbox.x_min == 0
                    &amp;&amp; og-&gt;italic)
                og = &amp;glyphs[--back];
            if (og-&gt;bbox.x_max &gt; og-&gt;cluster_advance.x)
                og-&gt;cluster_advance.x = og-&gt;bbox.x_max;
        }
        info-&gt;cluster_advance.x += info-&gt;hspacing_scaled;
    }
}
<a name="2"></a>static void preliminary_layout(ASS_Renderer *render_priv)
{
    ASS_Vector pen = { 0, 0 };
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    for (int i = 0; i &lt; render_priv-&gt;text_info.length; i++) {
        GlyphInfo *info = render_priv-&gt;text_info.glyphs + i;
        ASS_Vector cluster_pen = pen;
        do {
            info-&gt;pos.x = cluster_pen.x;
            info-&gt;pos.y = cluster_pen.y;
            cluster_pen.x += info-&gt;advance.x;
            cluster_pen.y += info-&gt;advance.y;
            info = info-&gt;next;
        } while (info);
        info = render_priv-&gt;text_info.glyphs + i;</b></font>
        pen.x += info-&gt;cluster_advance.x;
        pen.y += info-&gt;cluster_advance.y;
    }
}
static void reorder_text(ASS_Renderer *render_priv)
{
    TextInfo *text_info = &amp;render_priv-&gt;text_info;
    FriBidiStrIndex *cmap = ass_shaper_reorder(render_priv-&gt;shaper, text_info);
    if (!cmap) {
        ass_msg(render_priv-&gt;library, MSGL_ERR, "Failed to reorder text");
        ass_shaper_cleanup(render_priv-&gt;shaper, text_info);
        free_render_context(render_priv);
        return;
    }
    ASS_Vector pen = { 0, 0 };
    int lineno = 1;
    for (int i = 0; i &lt; text_info-&gt;length; i++) {
        GlyphInfo *info = text_info-&gt;glyphs + cmap[i];
        if (text_info-&gt;glyphs[i].linebreak) {
            pen.x = 0;
            pen.y += double_to_d6(text_info-&gt;lines[lineno-1].desc);
            pen.y += double_to_d6(text_info-&gt;lines[lineno].asc);
            pen.y += double_to_d6(render_priv-&gt;settings.line_spacing);
            lineno++;
        }
        if (info-&gt;skip)
            continue;
        ASS_Vector cluster_pen = pen;
        pen.x += info-&gt;cluster_advance.x;
        pen.y += info-&gt;cluster_advance.y;
        while (info) {
            info-&gt;pos.x = info-&gt;offset.x + cluster_pen.x;
            info-&gt;pos.y = info-&gt;offset.y + cluster_pen.y;
            cluster_pen.x += info-&gt;advance.x;
            cluster_pen.y += info-&gt;advance.y;
            info = info-&gt;next;
        }
    }
}
static void apply_baseline_shear(ASS_Renderer *render_priv)
{
    TextInfo *text_info = &amp;render_priv-&gt;text_info;
    FriBidiStrIndex *cmap = ass_shaper_get_reorder_map(render_priv-&gt;shaper);
    int32_t shear = 0;
    bool whole_text_layout =
        render_priv-&gt;track-&gt;parser_priv-&gt;feature_flags &amp;
        FEATURE_MASK(ASS_FEATURE_WHOLE_TEXT_LAYOUT);
    for (int i = 0; i &lt; text_info-&gt;length; i++) {
        GlyphInfo *info = text_info-&gt;glyphs + cmap[i];
        if (text_info-&gt;glyphs[i].linebreak ||
            (!whole_text_layout &amp;&amp; text_info-&gt;glyphs[i].starts_new_run))
            shear = 0;
        if (!info-&gt;scale_x || !info-&gt;scale_y)
            info-&gt;skip = true;
        if (info-&gt;skip)
            continue;
        for (GlyphInfo *cur = info; cur; cur = cur-&gt;next)
            cur-&gt;pos.y += shear;
        shear += (info-&gt;fay / info-&gt;scale_x * info-&gt;scale_y) * info-&gt;cluster_advance.x;
    }
}
static void align_lines(ASS_Renderer *render_priv, double max_text_width)
{
    TextInfo *text_info = &amp;render_priv-&gt;text_info;
    GlyphInfo *glyphs = text_info-&gt;glyphs;
    int i, j;
    double width = 0;
    int last_break = -1;
    int halign = render_priv-&gt;state.alignment &amp; 3;
    int justify = render_priv-&gt;state.justify;
    double max_width = 0;
    if (render_priv-&gt;state.evt_type &amp; EVENT_HSCROLL) {
        justify = halign;
        halign = HALIGN_LEFT;
    }
    for (i = 0; i &lt;= text_info-&gt;length; ++i) {           if ((i == text_info-&gt;length) || glyphs[i].linebreak) {
            max_width = FFMAX(max_width,width);
            width = 0;
        }
        if (i &lt; text_info-&gt;length &amp;&amp; !glyphs[i].skip &amp;&amp;
                glyphs[i].symbol != '\n' &amp;&amp; glyphs[i].symbol != 0) {
            width += d6_to_double(glyphs[i].cluster_advance.x);
        }
    }
    for (i = 0; i &lt;= text_info-&gt;length; ++i) {           if ((i == text_info-&gt;length) || glyphs[i].linebreak) {
            double shift = 0;
            if (halign == HALIGN_LEFT) {                    if (justify == ASS_JUSTIFY_RIGHT) {
                    shift = max_width - width;
                } else if (justify == ASS_JUSTIFY_CENTER) {
                    shift = (max_width - width) / 2.0;
                } else {
                    shift = 0;
                }
            } else if (halign == HALIGN_RIGHT) {                    if (justify == ASS_JUSTIFY_LEFT) {
                    shift = max_text_width - max_width;
                } else if (justify == ASS_JUSTIFY_CENTER) {
                    shift = max_text_width - max_width + (max_width - width) / 2.0;
                } else {
                    shift = max_text_width - width;
                }
            } else if (halign == HALIGN_CENTER) {                   if (justify == ASS_JUSTIFY_LEFT) {
                    shift = (max_text_width - max_width) / 2.0;
                } else if (justify == ASS_JUSTIFY_RIGHT) {
                    shift = (max_text_width - max_width) / 2.0 + max_width - width;
                } else {
                    shift = (max_text_width - width) / 2.0;
                }
            }
            for (j = last_break + 1; j &lt; i; ++j) {
                GlyphInfo *info = glyphs + j;
                while (info) {
                    info-&gt;pos.x += double_to_d6(shift);
                    info = info-&gt;next;
                }
            }
            last_break = i - 1;
            width = 0;
        }
        if (i &lt; text_info-&gt;length &amp;&amp; !glyphs[i].skip &amp;&amp;
                glyphs[i].symbol != '\n' &amp;&amp; glyphs[i].symbol != 0) {
            width += d6_to_double(glyphs[i].cluster_advance.x);
        }
    }
}
static void calculate_rotation_params(ASS_Renderer *render_priv, ASS_DRect *bbox,
                                      double device_x, double device_y)
{
    ASS_DVector center;
    if (render_priv-&gt;state.have_origin) {
        center.x = x2scr_pos(render_priv, render_priv-&gt;state.org_x);
        center.y = y2scr_pos(render_priv, render_priv-&gt;state.org_y);
    } else {
        double bx = 0., by = 0.;
        get_base_point(bbox, render_priv-&gt;state.alignment, &amp;bx, &amp;by);
        center.x = device_x + bx;
        center.y = device_y + by;
    }
    TextInfo *text_info = &amp;render_priv-&gt;text_info;
    for (int i = 0; i &lt; text_info-&gt;length; i++) {
        GlyphInfo *info = text_info-&gt;glyphs + i;
        while (info) {
            info-&gt;shift.x = info-&gt;pos.x + double_to_d6(device_x - center.x +
                    info-&gt;shadow_x * render_priv-&gt;border_scale /
                    render_priv-&gt;font_scale_x);
            info-&gt;shift.y = info-&gt;pos.y + double_to_d6(device_y - center.y +
                    info-&gt;shadow_y * render_priv-&gt;border_scale);
            info = info-&gt;next;
        }
    }
}
static int quantize_blur(double radius, int32_t *shadow_mask)
{
    const double scale = 64 * BLUR_PRECISION / POSITION_PRECISION;
    radius *= scale;
    int ord;
    frexp((1 + radius) * (POSITION_PRECISION / 2), &amp;ord);
    *shadow_mask = ((uint32_t) 1 &lt;&lt; ord) - 1;
    return lrint(log1p(radius) / BLUR_PRECISION);
}
static double restore_blur(int qblur)
{
    const double scale = 64 * BLUR_PRECISION / POSITION_PRECISION;
    double sigma = expm1(BLUR_PRECISION * qblur) / scale;
    return sigma * sigma;
}
static void render_and_combine_glyphs(ASS_Renderer *render_priv,
                                      double device_x, double device_y)
{
    TextInfo *text_info = &amp;render_priv-&gt;text_info;
    int left = render_priv-&gt;settings.left_margin;
    device_x = (device_x - left) * render_priv-&gt;font_scale_x + left;
    unsigned nb_bitmaps = 0;
    bool new_run = true;
    CombinedBitmapInfo *combined_info = text_info-&gt;combined_bitmaps;
    CombinedBitmapInfo *current_info = NULL;
    ASS_DVector offset;
    for (int i = 0; i &lt; text_info-&gt;length; i++) {
        GlyphInfo *info = text_info-&gt;glyphs + i;
        if (info-&gt;starts_new_run) new_run = true;
        if (info-&gt;skip) {
            for (; info; info = info-&gt;next)
                ass_cache_dec_ref(info-&gt;outline);
            continue;
        }
        for (; info; info = info-&gt;next) {
            int flags = 0;
            if (info-&gt;border_style == 3)
                flags |= FILTER_BORDER_STYLE_3;
            if (info-&gt;border_x || info-&gt;border_y)
                flags |= FILTER_NONZERO_BORDER;
            if (info-&gt;shadow_x || info-&gt;shadow_y)
                flags |= FILTER_NONZERO_SHADOW;
            if (flags &amp; FILTER_NONZERO_SHADOW &amp;&amp;
                (info-&gt;effect_type == EF_KARAOKE_KF ||
                 info-&gt;effect_type == EF_KARAOKE_KO ||
                 (info-&gt;a_pre_fade[0]) != 0xFF ||
                 info-&gt;border_style == 3))
                flags |= FILTER_FILL_IN_SHADOW;
            if (!(flags &amp; FILTER_NONZERO_BORDER) &amp;&amp;
                !(flags &amp; FILTER_FILL_IN_SHADOW))
                flags &amp;= ~FILTER_NONZERO_SHADOW;
            if ((flags &amp; FILTER_NONZERO_BORDER &amp;&amp;
                 info-&gt;a_pre_fade[0] == 0 &amp;&amp;
                 info-&gt;a_pre_fade[1] == 0 &amp;&amp;
                 info-&gt;fade == 0) ||
                info-&gt;border_style == 3)
                flags |= FILTER_FILL_IN_BORDER;
            if (new_run) {
                if (nb_bitmaps &gt;= text_info-&gt;max_bitmaps) {
                    size_t new_size = 2 * text_info-&gt;max_bitmaps;
                    if (!ASS_REALLOC_ARRAY(text_info-&gt;combined_bitmaps, new_size)) {
                        ass_cache_dec_ref(info-&gt;outline);
                        continue;
                    }
                    text_info-&gt;max_bitmaps = new_size;
                    combined_info = text_info-&gt;combined_bitmaps;
                }
                current_info = &amp;combined_info[nb_bitmaps];
                memcpy(&amp;current_info-&gt;c, &amp;info-&gt;c, sizeof(info-&gt;c));
                current_info-&gt;effect_type = info-&gt;effect_type;
                current_info-&gt;effect_timing = info-&gt;effect_timing;
                current_info-&gt;leftmost_x = OUTLINE_MAX;
                FilterDesc *filter = &amp;current_info-&gt;filter;
                filter-&gt;flags = flags;
                filter-&gt;be = info-&gt;be;
                int32_t shadow_mask;
                double blur_scale = render_priv-&gt;blur_scale * (2 / sqrt(log(256)));
                filter-&gt;blur = quantize_blur(info-&gt;blur * blur_scale, &amp;shadow_mask);
                if (flags &amp; FILTER_NONZERO_SHADOW) {
                    int32_t x = double_to_d6(info-&gt;shadow_x * render_priv-&gt;border_scale);
                    int32_t y = double_to_d6(info-&gt;shadow_y * render_priv-&gt;border_scale);
                    filter-&gt;shadow.x = (x + (shadow_mask &gt;&gt; 1)) &amp; ~shadow_mask;
                    filter-&gt;shadow.y = (y + (shadow_mask &gt;&gt; 1)) &amp; ~shadow_mask;
                } else
                    filter-&gt;shadow.x = filter-&gt;shadow.y = 0;
                current_info-&gt;x = current_info-&gt;y = INT_MAX;
                current_info-&gt;bm = current_info-&gt;bm_o = current_info-&gt;bm_s = NULL;
                current_info-&gt;image = NULL;
                current_info-&gt;bitmap_count = current_info-&gt;max_bitmap_count = 0;
                current_info-&gt;bitmaps = malloc(MAX_SUB_BITMAPS_INITIAL * sizeof(BitmapRef));
                if (!current_info-&gt;bitmaps) {
                    ass_cache_dec_ref(info-&gt;outline);
                    continue;
                }
                current_info-&gt;max_bitmap_count = MAX_SUB_BITMAPS_INITIAL;
                nb_bitmaps++;
                new_run = false;
            }
            assert(current_info);
            ASS_Vector pos, pos_o;
            info-&gt;pos.x = double_to_d6(device_x + d6_to_double(info-&gt;pos.x) * render_priv-&gt;font_scale_x);
            info-&gt;pos.y = double_to_d6(device_y) + info-&gt;pos.y;
            get_bitmap_glyph(render_priv, info, &amp;current_info-&gt;leftmost_x, &amp;pos, &amp;pos_o,
                             &amp;offset, !current_info-&gt;bitmap_count, flags);
            if (!info-&gt;bm &amp;&amp; !info-&gt;bm_o) {
                ass_cache_dec_ref(info-&gt;bm);
                ass_cache_dec_ref(info-&gt;bm_o);
                continue;
            }
            if (current_info-&gt;bitmap_count &gt;= current_info-&gt;max_bitmap_count) {
                size_t new_size = 2 * current_info-&gt;max_bitmap_count;
                if (!ASS_REALLOC_ARRAY(current_info-&gt;bitmaps, new_size)) {
                    ass_cache_dec_ref(info-&gt;bm);
                    ass_cache_dec_ref(info-&gt;bm_o);
                    continue;
                }
                current_info-&gt;max_bitmap_count = new_size;
            }
            current_info-&gt;bitmaps[current_info-&gt;bitmap_count].bm   = info-&gt;bm;
            current_info-&gt;bitmaps[current_info-&gt;bitmap_count].bm_o = info-&gt;bm_o;
            current_info-&gt;bitmaps[current_info-&gt;bitmap_count].pos   = pos;
            current_info-&gt;bitmaps[current_info-&gt;bitmap_count].pos_o = pos_o;
            current_info-&gt;bitmap_count++;
            current_info-&gt;x = FFMIN(current_info-&gt;x, pos.x);
            current_info-&gt;y = FFMIN(current_info-&gt;y, pos.y);
        }
    }
    for (int i = 0; i &lt; nb_bitmaps; i++) {
        CombinedBitmapInfo *info = &amp;combined_info[i];
        if (!info-&gt;bitmap_count) {
            free(info-&gt;bitmaps);
            continue;
        }
        if (info-&gt;effect_type == EF_KARAOKE_KF)
            info-&gt;effect_timing = lround(d6_to_double(info-&gt;leftmost_x) +
                d6_to_double(info-&gt;effect_timing) * render_priv-&gt;font_scale_x);
        for (int j = 0; j &lt; info-&gt;bitmap_count; j++) {
            info-&gt;bitmaps[j].pos.x -= info-&gt;x;
            info-&gt;bitmaps[j].pos.y -= info-&gt;y;
            info-&gt;bitmaps[j].pos_o.x -= info-&gt;x;
            info-&gt;bitmaps[j].pos_o.y -= info-&gt;y;
        }
        CompositeHashKey key;
        key.filter = info-&gt;filter;
        key.bitmap_count = info-&gt;bitmap_count;
        key.bitmaps = info-&gt;bitmaps;
        CompositeHashValue *val = ass_cache_get(render_priv-&gt;cache.composite_cache, &amp;key, render_priv);
        if (!val)
            continue;
        if (val-&gt;bm.buffer)
            info-&gt;bm = &amp;val-&gt;bm;
        if (val-&gt;bm_o.buffer)
            info-&gt;bm_o = &amp;val-&gt;bm_o;
        if (val-&gt;bm_s.buffer)
            info-&gt;bm_s = &amp;val-&gt;bm_s;
        info-&gt;image = val;
        continue;
    }
    text_info-&gt;n_bitmaps = nb_bitmaps;
}
static inline void rectangle_combine(ASS_Rect *rect, const Bitmap *bm, ASS_Vector pos)
{
    pos.x += bm-&gt;left;
    pos.y += bm-&gt;top;
    rectangle_update(rect, pos.x, pos.y, pos.x + bm-&gt;w, pos.y + bm-&gt;h);
}
size_t ass_composite_construct(void *key, void *value, void *priv)
{
    ASS_Renderer *render_priv = priv;
    CompositeHashKey *k = key;
    CompositeHashValue *v = value;
    memset(v, 0, sizeof(*v));
    ASS_Rect rect, rect_o;
    rectangle_reset(&amp;rect);
    rectangle_reset(&amp;rect_o);
    size_t n_bm = 0, n_bm_o = 0;
    BitmapRef *last = NULL, *last_o = NULL;
    for (int i = 0; i &lt; k-&gt;bitmap_count; i++) {
        BitmapRef *ref = &amp;k-&gt;bitmaps[i];
        if (ref-&gt;bm) {
            rectangle_combine(&amp;rect, ref-&gt;bm, ref-&gt;pos);
            last = ref;
            n_bm++;
        }
        if (ref-&gt;bm_o) {
            rectangle_combine(&amp;rect_o, ref-&gt;bm_o, ref-&gt;pos_o);
            last_o = ref;
            n_bm_o++;
        }
    }
    int bord = be_padding(k-&gt;filter.be);
    if (!bord &amp;&amp; n_bm == 1) {
        copy_bitmap(render_priv-&gt;engine, &amp;v-&gt;bm, last-&gt;bm);
        v-&gt;bm.left += last-&gt;pos.x;
        v-&gt;bm.top  += last-&gt;pos.y;
    } else if (n_bm &amp;&amp; alloc_bitmap(render_priv-&gt;engine, &amp;v-&gt;bm,
                                    rect.x_max - rect.x_min + 2 * bord,
                                    rect.y_max - rect.y_min + 2 * bord,
                                    true)) {
        Bitmap *dst = &amp;v-&gt;bm;
        dst-&gt;left = rect.x_min - bord;
        dst-&gt;top  = rect.y_min - bord;
        for (int i = 0; i &lt; k-&gt;bitmap_count; i++) {
            Bitmap *src = k-&gt;bitmaps[i].bm;
            if (!src)
                continue;
            int x = k-&gt;bitmaps[i].pos.x + src-&gt;left - dst-&gt;left;
            int y = k-&gt;bitmaps[i].pos.y + src-&gt;top  - dst-&gt;top;
            assert(x &gt;= 0 &amp;&amp; x + src-&gt;w &lt;= dst-&gt;w);
            assert(y &gt;= 0 &amp;&amp; y + src-&gt;h &lt;= dst-&gt;h);
            unsigned char *buf = dst-&gt;buffer + y * dst-&gt;stride + x;
            render_priv-&gt;engine-&gt;add_bitmaps(buf, dst-&gt;stride,
                                             src-&gt;buffer, src-&gt;stride,
                                             src-&gt;w, src-&gt;h);
        }
    }
    if (!bord &amp;&amp; n_bm_o == 1) {
        copy_bitmap(render_priv-&gt;engine, &amp;v-&gt;bm_o, last_o-&gt;bm_o);
        v-&gt;bm_o.left += last_o-&gt;pos_o.x;
        v-&gt;bm_o.top  += last_o-&gt;pos_o.y;
    } else if (n_bm_o &amp;&amp; alloc_bitmap(render_priv-&gt;engine, &amp;v-&gt;bm_o,
                                      rect_o.x_max - rect_o.x_min + 2 * bord,
                                      rect_o.y_max - rect_o.y_min + 2 * bord,
                                      true)) {
        Bitmap *dst = &amp;v-&gt;bm_o;
        dst-&gt;left = rect_o.x_min - bord;
        dst-&gt;top  = rect_o.y_min - bord;
        for (int i = 0; i &lt; k-&gt;bitmap_count; i++) {
            Bitmap *src = k-&gt;bitmaps[i].bm_o;
            if (!src)
                continue;
            int x = k-&gt;bitmaps[i].pos_o.x + src-&gt;left - dst-&gt;left;
            int y = k-&gt;bitmaps[i].pos_o.y + src-&gt;top  - dst-&gt;top;
            assert(x &gt;= 0 &amp;&amp; x + src-&gt;w &lt;= dst-&gt;w);
            assert(y &gt;= 0 &amp;&amp; y + src-&gt;h &lt;= dst-&gt;h);
            unsigned char *buf = dst-&gt;buffer + y * dst-&gt;stride + x;
            render_priv-&gt;engine-&gt;add_bitmaps(buf, dst-&gt;stride,
                                             src-&gt;buffer, src-&gt;stride,
                                             src-&gt;w, src-&gt;h);
        }
    }
    int flags = k-&gt;filter.flags;
    double r2 = restore_blur(k-&gt;filter.blur);
    if (!(flags &amp; FILTER_NONZERO_BORDER) || (flags &amp; FILTER_BORDER_STYLE_3))
        ass_synth_blur(render_priv-&gt;engine, &amp;v-&gt;bm, k-&gt;filter.be, r2);
    ass_synth_blur(render_priv-&gt;engine, &amp;v-&gt;bm_o, k-&gt;filter.be, r2);
    if (!(flags &amp; FILTER_FILL_IN_BORDER) &amp;&amp; !(flags &amp; FILTER_FILL_IN_SHADOW))
        fix_outline(&amp;v-&gt;bm, &amp;v-&gt;bm_o);
    if (flags &amp; FILTER_NONZERO_SHADOW) {
        if (flags &amp; FILTER_NONZERO_BORDER) {
            copy_bitmap(render_priv-&gt;engine, &amp;v-&gt;bm_s, &amp;v-&gt;bm_o);
            if ((flags &amp; FILTER_FILL_IN_BORDER) &amp;&amp; !(flags &amp; FILTER_FILL_IN_SHADOW))
                fix_outline(&amp;v-&gt;bm, &amp;v-&gt;bm_s);
        } else if (flags &amp; FILTER_BORDER_STYLE_3) {
            v-&gt;bm_s = v-&gt;bm_o;
            memset(&amp;v-&gt;bm_o, 0, sizeof(v-&gt;bm_o));
        } else {
            copy_bitmap(render_priv-&gt;engine, &amp;v-&gt;bm_s, &amp;v-&gt;bm);
        }
        v-&gt;bm_s.left += k-&gt;filter.shadow.x &gt;&gt; 6;
        v-&gt;bm_s.top  += k-&gt;filter.shadow.y &gt;&gt; 6;
        shift_bitmap(&amp;v-&gt;bm_s, k-&gt;filter.shadow.x &amp; SUBPIXEL_MASK, k-&gt;filter.shadow.y &amp; SUBPIXEL_MASK);
    }
    if ((flags &amp; FILTER_FILL_IN_SHADOW) &amp;&amp; !(flags &amp; FILTER_FILL_IN_BORDER))
        fix_outline(&amp;v-&gt;bm, &amp;v-&gt;bm_o);
    return sizeof(CompositeHashKey) + sizeof(CompositeHashValue) +
        bitmap_size(&amp;v-&gt;bm) + bitmap_size(&amp;v-&gt;bm_o) + bitmap_size(&amp;v-&gt;bm_s);
}
static void add_background(ASS_Renderer *render_priv, EventImages *event_images)
{
    int size_x = render_priv-&gt;state.shadow_x &gt; 0 ?
        lround(render_priv-&gt;state.shadow_x * render_priv-&gt;border_scale) : 0;
    int size_y = render_priv-&gt;state.shadow_y &gt; 0 ?
        lround(render_priv-&gt;state.shadow_y * render_priv-&gt;border_scale) : 0;
    int left    = event_images-&gt;left - size_x;
    int top     = event_images-&gt;top  - size_y;
    int right   = event_images-&gt;left + event_images-&gt;width  + size_x;
    int bottom  = event_images-&gt;top  + event_images-&gt;height + size_y;
    left        = FFMINMAX(left,   0, render_priv-&gt;width);
    top         = FFMINMAX(top,    0, render_priv-&gt;height);
    right       = FFMINMAX(right,  0, render_priv-&gt;width);
    bottom      = FFMINMAX(bottom, 0, render_priv-&gt;height);
    int w = right - left;
    int h = bottom - top;
    if (w &lt; 1 || h &lt; 1)
        return;
    void *nbuffer = ass_aligned_alloc(1, w * h, false);
    if (!nbuffer)
        return;
    memset(nbuffer, 0xFF, w * h);
    ASS_Image *img = my_draw_bitmap(nbuffer, w, h, w, left, top,
                                    render_priv-&gt;state.c[3], NULL);
    if (img) {
        img-&gt;next = event_images-&gt;imgs;
        event_images-&gt;imgs = img;
    }
}
static bool
ass_render_event(ASS_Renderer *render_priv, ASS_Event *event,
                 EventImages *event_images)
{
    if (event-&gt;Style &gt;= render_priv-&gt;track-&gt;n_styles) {
        ass_msg(render_priv-&gt;library, MSGL_WARN, "No style found");
        return false;
    }
    if (!event-&gt;Text) {
        ass_msg(render_priv-&gt;library, MSGL_WARN, "Empty event");
        return false;
    }
    free_render_context(render_priv);
    init_render_context(render_priv, event);
    if (!parse_events(render_priv, event))
        return false;
    TextInfo *text_info = &amp;render_priv-&gt;text_info;
    if (text_info-&gt;length == 0) {
        free_render_context(render_priv);
        return false;
    }
    split_style_runs(render_priv);
    ass_shaper_set_base_direction(render_priv-&gt;shaper,
            resolve_base_direction(render_priv-&gt;state.font_encoding));
    ass_shaper_find_runs(render_priv-&gt;shaper, render_priv, text_info-&gt;glyphs,
            text_info-&gt;length);
    if (!ass_shaper_shape(render_priv-&gt;shaper, text_info)) {
        ass_msg(render_priv-&gt;library, MSGL_ERR, "Failed to shape text");
        free_render_context(render_priv);
        return false;
    }
    retrieve_glyphs(render_priv);
    preliminary_layout(render_priv);
    int valign = render_priv-&gt;state.alignment &amp; 12;
    int MarginL =
        (event-&gt;MarginL) ? event-&gt;MarginL : render_priv-&gt;state.style-&gt;MarginL;
    int MarginR =
        (event-&gt;MarginR) ? event-&gt;MarginR : render_priv-&gt;state.style-&gt;MarginR;
    int MarginV =
        (event-&gt;MarginV) ? event-&gt;MarginV : render_priv-&gt;state.style-&gt;MarginV;
    double max_text_width =
        x2scr_right(render_priv, render_priv-&gt;track-&gt;PlayResX - MarginR) -
        x2scr_left(render_priv, MarginL);
    wrap_lines_smart(render_priv, max_text_width);
    process_karaoke_effects(render_priv);
    reorder_text(render_priv);
    align_lines(render_priv, max_text_width);
    ASS_DRect bbox;
    compute_string_bbox(text_info, &amp;bbox);
    apply_baseline_shear(render_priv);
    double device_x = 0;
    double device_y = 0;
    if (render_priv-&gt;state.evt_type &amp; EVENT_POSITIONED) {
        double base_x = 0;
        double base_y = 0;
        get_base_point(&amp;bbox, render_priv-&gt;state.alignment, &amp;base_x, &amp;base_y);
        device_x =
            x2scr_pos(render_priv, render_priv-&gt;state.pos_x) - base_x;
        device_y =
            y2scr_pos(render_priv, render_priv-&gt;state.pos_y) - base_y;
    }
    if (render_priv-&gt;state.evt_type &amp; EVENT_HSCROLL) {
        if (render_priv-&gt;state.scroll_direction == SCROLL_RL)
            device_x =
                x2scr_pos(render_priv,
                      render_priv-&gt;track-&gt;PlayResX -
                      render_priv-&gt;state.scroll_shift);
        else if (render_priv-&gt;state.scroll_direction == SCROLL_LR)
            device_x =
                x2scr_pos(render_priv, render_priv-&gt;state.scroll_shift) -
                (bbox.x_max - bbox.x_min);
    } else if (!(render_priv-&gt;state.evt_type &amp; EVENT_POSITIONED)) {
        device_x = x2scr_left(render_priv, MarginL);
    }
    if (render_priv-&gt;state.evt_type &amp; EVENT_VSCROLL) {
        if (render_priv-&gt;state.scroll_direction == SCROLL_TB)
            device_y =
                y2scr(render_priv,
                      render_priv-&gt;state.scroll_y0 +
                      render_priv-&gt;state.scroll_shift) -
                bbox.y_max;
        else if (render_priv-&gt;state.scroll_direction == SCROLL_BT)
            device_y =
                y2scr(render_priv,
                      render_priv-&gt;state.scroll_y1 -
                      render_priv-&gt;state.scroll_shift) -
                bbox.y_min;
    } else if (!(render_priv-&gt;state.evt_type &amp; EVENT_POSITIONED)) {
        if (valign == VALIGN_TOP) {                 device_y =
                y2scr_top(render_priv,
                          MarginV) + text_info-&gt;lines[0].asc;
        } else if (valign == VALIGN_CENTER) {               double scr_y =
                y2scr(render_priv, render_priv-&gt;track-&gt;PlayResY / 2.0);
            device_y = scr_y - (bbox.y_max + bbox.y_min) / 2.0;
        } else {                            double line_pos = render_priv-&gt;state.explicit ?
                0 : render_priv-&gt;settings.line_position;
            double scr_top, scr_bottom, scr_y0;
            if (valign != VALIGN_SUB)
                ass_msg(render_priv-&gt;library, MSGL_V,
                       "Invalid valign, assuming 0 (subtitle)");
            scr_bottom =
                y2scr_sub(render_priv,
                          render_priv-&gt;track-&gt;PlayResY - MarginV);
            scr_top = y2scr_top(render_priv, 0); //xxx not always 0?
            device_y = scr_bottom + (scr_top - scr_bottom) * line_pos / 100.0;
            device_y -= text_info-&gt;height;
            device_y += text_info-&gt;lines[0].asc;
            scr_y0 = scr_top + text_info-&gt;lines[0].asc;
            if (device_y &lt; scr_y0 &amp;&amp; line_pos &gt; 0) {
                device_y = scr_y0;
            }
        }
    }
    if (render_priv-&gt;state.explicit || !render_priv-&gt;settings.use_margins) {
        render_priv-&gt;state.clip_x0 =
            x2scr_pos_scaled(render_priv, render_priv-&gt;state.clip_x0);
        render_priv-&gt;state.clip_x1 =
            x2scr_pos_scaled(render_priv, render_priv-&gt;state.clip_x1);
        render_priv-&gt;state.clip_y0 =
            y2scr_pos(render_priv, render_priv-&gt;state.clip_y0);
        render_priv-&gt;state.clip_y1 =
            y2scr_pos(render_priv, render_priv-&gt;state.clip_y1);
        if (render_priv-&gt;state.explicit) {
            double zx = x2scr_pos_scaled(render_priv, 0);
            double zy = y2scr_pos(render_priv, 0);
            double sx = x2scr_pos_scaled(render_priv, render_priv-&gt;track-&gt;PlayResX);
            double sy = y2scr_pos(render_priv, render_priv-&gt;track-&gt;PlayResY);
            render_priv-&gt;state.clip_x0 = FFMAX(render_priv-&gt;state.clip_x0, zx);
            render_priv-&gt;state.clip_y0 = FFMAX(render_priv-&gt;state.clip_y0, zy);
            render_priv-&gt;state.clip_x1 = FFMIN(render_priv-&gt;state.clip_x1, sx);
            render_priv-&gt;state.clip_y1 = FFMIN(render_priv-&gt;state.clip_y1, sy);
        }
    } else {
        render_priv-&gt;state.clip_x0 = 0;
        render_priv-&gt;state.clip_y0 = 0;
        render_priv-&gt;state.clip_x1 = render_priv-&gt;settings.frame_width;
        render_priv-&gt;state.clip_y1 = render_priv-&gt;settings.frame_height;
    }
    if (render_priv-&gt;state.evt_type &amp; EVENT_VSCROLL) {
        double y0 = y2scr_pos(render_priv, render_priv-&gt;state.scroll_y0);
        double y1 = y2scr_pos(render_priv, render_priv-&gt;state.scroll_y1);
        render_priv-&gt;state.clip_y0 = FFMAX(render_priv-&gt;state.clip_y0, y0);
        render_priv-&gt;state.clip_y1 = FFMIN(render_priv-&gt;state.clip_y1, y1);
    }
    calculate_rotation_params(render_priv, &amp;bbox, device_x, device_y);
    render_and_combine_glyphs(render_priv, device_x, device_y);
    memset(event_images, 0, sizeof(*event_images));
    event_images-&gt;top = device_y - text_info-&gt;lines[0].asc - text_info-&gt;border_top;
    event_images-&gt;height =
        text_info-&gt;height + text_info-&gt;border_bottom + text_info-&gt;border_top;
    event_images-&gt;left =
        (device_x + bbox.x_min) * render_priv-&gt;font_scale_x - text_info-&gt;border_x + 0.5;
    event_images-&gt;width =
        (bbox.x_max - bbox.x_min) * render_priv-&gt;font_scale_x
        + 2 * text_info-&gt;border_x + 0.5;
    event_images-&gt;detect_collisions = render_priv-&gt;state.detect_collisions;
    event_images-&gt;shift_direction = (valign == VALIGN_SUB) ? -1 : 1;
    event_images-&gt;event = event;
    event_images-&gt;imgs = render_text(render_priv);
    if (render_priv-&gt;state.border_style == 4)
        add_background(render_priv, event_images);
    ass_shaper_cleanup(render_priv-&gt;shaper, text_info);
    free_render_context(render_priv);
    return true;
}
static void check_cache_limits(ASS_Renderer *priv, CacheStore *cache)
{
    ass_cache_cut(cache-&gt;composite_cache, cache-&gt;composite_max_size);
    ass_cache_cut(cache-&gt;bitmap_cache, cache-&gt;bitmap_max_size);
    ass_cache_cut(cache-&gt;outline_cache, cache-&gt;glyph_max);
}
static bool
ass_start_frame(ASS_Renderer *render_priv, ASS_Track *track,
                long long now)
{
    ASS_Settings *settings_priv = &amp;render_priv-&gt;settings;
    if (!render_priv-&gt;settings.frame_width
        &amp;&amp; !render_priv-&gt;settings.frame_height)
        return false;               
    if (!render_priv-&gt;fontselect)
        return false;
    if (render_priv-&gt;library != track-&gt;library)
        return false;
    if (track-&gt;n_events == 0)
        return false;               
    render_priv-&gt;track = track;
    render_priv-&gt;time = now;
    ass_lazy_track_init(render_priv-&gt;library, render_priv-&gt;track);
    if (render_priv-&gt;library-&gt;num_fontdata != render_priv-&gt;num_emfonts) {
        assert(render_priv-&gt;library-&gt;num_fontdata &gt; render_priv-&gt;num_emfonts);
        render_priv-&gt;num_emfonts = ass_update_embedded_fonts(
            render_priv-&gt;fontselect, render_priv-&gt;num_emfonts);
    }
    ass_shaper_set_kerning(render_priv-&gt;shaper, track-&gt;Kerning);
    ass_shaper_set_language(render_priv-&gt;shaper, track-&gt;Language);
    ass_shaper_set_level(render_priv-&gt;shaper, render_priv-&gt;settings.shaper);
#ifdef USE_FRIBIDI_EX_API
    ass_shaper_set_bidi_brackets(render_priv-&gt;shaper,
            track-&gt;parser_priv-&gt;feature_flags &amp; FEATURE_MASK(ASS_FEATURE_BIDI_BRACKETS));
#endif
    ass_shaper_set_whole_text_layout(render_priv-&gt;shaper,
            track-&gt;parser_priv-&gt;feature_flags &amp; FEATURE_MASK(ASS_FEATURE_WHOLE_TEXT_LAYOUT));
    double par = render_priv-&gt;settings.par;
    if (par == 0.) {
        if (render_priv-&gt;orig_width &amp;&amp; render_priv-&gt;orig_height &amp;&amp;
            settings_priv-&gt;storage_width &amp;&amp; settings_priv-&gt;storage_height) {
            double dar = ((double) render_priv-&gt;orig_width) /
                         render_priv-&gt;orig_height;
            double sar = ((double) settings_priv-&gt;storage_width) /
                         settings_priv-&gt;storage_height;
            par = dar / sar;
        } else
            par = 1.0;
    }
    render_priv-&gt;font_scale_x = par;
    render_priv-&gt;prev_images_root = render_priv-&gt;images_root;
    render_priv-&gt;images_root = NULL;
    check_cache_limits(render_priv, &amp;render_priv-&gt;cache);
    return true;
}
static int cmp_event_layer(const void *p1, const void *p2)
{
    ASS_Event *e1 = ((EventImages *) p1)-&gt;event;
    ASS_Event *e2 = ((EventImages *) p2)-&gt;event;
    if (e1-&gt;Layer &lt; e2-&gt;Layer)
        return -1;
    if (e1-&gt;Layer &gt; e2-&gt;Layer)
        return 1;
    if (e1-&gt;ReadOrder &lt; e2-&gt;ReadOrder)
        return -1;
    if (e1-&gt;ReadOrder &gt; e2-&gt;ReadOrder)
        return 1;
    return 0;
}
static ASS_RenderPriv *get_render_priv(ASS_Renderer *render_priv,
                                       ASS_Event *event)
{
    if (!event-&gt;render_priv) {
        event-&gt;render_priv = calloc(1, sizeof(ASS_RenderPriv));
        if (!event-&gt;render_priv)
            return NULL;
    }
    if (render_priv-&gt;render_id != event-&gt;render_priv-&gt;render_id) {
        memset(event-&gt;render_priv, 0, sizeof(ASS_RenderPriv));
        event-&gt;render_priv-&gt;render_id = render_priv-&gt;render_id;
    }
    return event-&gt;render_priv;
}
static int overlap(Rect *s1, Rect *s2)
{
    if (s1-&gt;y0 &gt;= s2-&gt;y1 || s2-&gt;y0 &gt;= s1-&gt;y1 ||
        s1-&gt;x0 &gt;= s2-&gt;x1 || s2-&gt;x0 &gt;= s1-&gt;x1)
        return 0;
    return 1;
}
static int cmp_rect_y0(const void *p1, const void *p2)
{
    return ((Rect *) p1)-&gt;y0 - ((Rect *) p2)-&gt;y0;
}
static void
shift_event(ASS_Renderer *render_priv, EventImages *ei, int shift)
{
    ASS_Image *cur = ei-&gt;imgs;
    while (cur) {
        cur-&gt;dst_y += shift;
        if (cur-&gt;dst_y &lt; 0) {
            int clip = -cur-&gt;dst_y;
            cur-&gt;h -= clip;
            cur-&gt;bitmap += clip * cur-&gt;stride;
            cur-&gt;dst_y = 0;
        }
        if (cur-&gt;dst_y + cur-&gt;h &gt;= render_priv-&gt;height) {
            int clip = cur-&gt;dst_y + cur-&gt;h - render_priv-&gt;height;
            cur-&gt;h -= clip;
        }
        if (cur-&gt;h &lt;= 0) {
            cur-&gt;h = 0;
            cur-&gt;dst_y = 0;
        }
        cur = cur-&gt;next;
    }
    ei-&gt;top += shift;
}
static int fit_rect(Rect *s, Rect *fixed, int *cnt, int dir)
{
    int i;
    int shift = 0;
    if (dir == 1)                       for (i = 0; i &lt; *cnt; ++i) {
            if (s-&gt;y1 + shift &lt;= fixed[i].y0 || s-&gt;y0 + shift &gt;= fixed[i].y1 ||
                s-&gt;x1 &lt;= fixed[i].x0 || s-&gt;x0 &gt;= fixed[i].x1)
                continue;
            shift = fixed[i].y1 - s-&gt;y0;
    } else                              for (i = *cnt - 1; i &gt;= 0; --i) {
            if (s-&gt;y1 + shift &lt;= fixed[i].y0 || s-&gt;y0 + shift &gt;= fixed[i].y1 ||
                s-&gt;x1 &lt;= fixed[i].x0 || s-&gt;x0 &gt;= fixed[i].x1)
                continue;
            shift = fixed[i].y0 - s-&gt;y1;
        }
    fixed[*cnt].y0 = s-&gt;y0 + shift;
    fixed[*cnt].y1 = s-&gt;y1 + shift;
    fixed[*cnt].x0 = s-&gt;x0;
    fixed[*cnt].x1 = s-&gt;x1;
    (*cnt)++;
    qsort(fixed, *cnt, sizeof(*fixed), cmp_rect_y0);
    return shift;
}
static void
fix_collisions(ASS_Renderer *render_priv, EventImages *imgs, int cnt)
{
    Rect *used = ass_realloc_array(NULL, cnt, sizeof(*used));
    int cnt_used = 0;
    int i, j;
    if (!used)
        return;
    for (i = 0; i &lt; cnt; ++i) {
        ASS_RenderPriv *priv;
        if (!imgs[i].detect_collisions || !imgs[i].height  || !imgs[i].width)
            continue;
        priv = get_render_priv(render_priv, imgs[i].event);
        if (priv &amp;&amp; priv-&gt;height &gt; 0) {             Rect s;
            s.y0 = priv-&gt;top;
            s.y1 = priv-&gt;top + priv-&gt;height;
            s.x0 = priv-&gt;left;
            s.x1 = priv-&gt;left + priv-&gt;width;
            if (priv-&gt;height != imgs[i].height) {                       ass_msg(render_priv-&gt;library, MSGL_WARN,
                        "Event height has changed");
                priv-&gt;top = 0;
                priv-&gt;height = 0;
                priv-&gt;left = 0;
                priv-&gt;width = 0;
            }
            for (j = 0; j &lt; cnt_used; ++j)
                if (overlap(&amp;s, used + j)) {                        priv-&gt;top = 0;
                    priv-&gt;height = 0;
                    priv-&gt;left = 0;
                    priv-&gt;width = 0;
                }
            if (priv-&gt;height &gt; 0) {                     used[cnt_used].y0 = priv-&gt;top;
                used[cnt_used].y1 = priv-&gt;top + priv-&gt;height;
                used[cnt_used].x0 = priv-&gt;left;
                used[cnt_used].x1 = priv-&gt;left + priv-&gt;width;
                cnt_used++;
                shift_event(render_priv, imgs + i, priv-&gt;top - imgs[i].top);
            }
        }
    }
    qsort(used, cnt_used, sizeof(*used), cmp_rect_y0);
    for (i = 0; i &lt; cnt; ++i) {
        ASS_RenderPriv *priv;
        if (!imgs[i].detect_collisions || !imgs[i].height  || !imgs[i].width)
            continue;
        priv = get_render_priv(render_priv, imgs[i].event);
        if (priv &amp;&amp; priv-&gt;height == 0) {                    int shift;
            Rect s;
            s.y0 = imgs[i].top;
            s.y1 = imgs[i].top + imgs[i].height;
            s.x0 = imgs[i].left;
            s.x1 = imgs[i].left + imgs[i].width;
            shift = fit_rect(&amp;s, used, &amp;cnt_used, imgs[i].shift_direction);
            if (shift)
                shift_event(render_priv, imgs + i, shift);
            priv-&gt;top = imgs[i].top;
            priv-&gt;height = imgs[i].height;
            priv-&gt;left = imgs[i].left;
            priv-&gt;width = imgs[i].width;
        }
    }
    free(used);
}
static int ass_image_compare(ASS_Image *i1, ASS_Image *i2)
{
    if (i1-&gt;w != i2-&gt;w)
        return 2;
    if (i1-&gt;h != i2-&gt;h)
        return 2;
    if (i1-&gt;stride != i2-&gt;stride)
        return 2;
    if (i1-&gt;color != i2-&gt;color)
        return 2;
    if (i1-&gt;bitmap != i2-&gt;bitmap)
        return 2;
    if (i1-&gt;dst_x != i2-&gt;dst_x)
        return 1;
    if (i1-&gt;dst_y != i2-&gt;dst_y)
        return 1;
    return 0;
}
static int ass_detect_change(ASS_Renderer *priv)
{
    ASS_Image *img, *img2;
    int diff;
    img = priv-&gt;prev_images_root;
    img2 = priv-&gt;images_root;
    diff = 0;
    while (img &amp;&amp; diff &lt; 2) {
        ASS_Image *next, *next2;
        next = img-&gt;next;
        if (img2) {
            int d = ass_image_compare(img, img2);
            if (d &gt; diff)
                diff = d;
            next2 = img2-&gt;next;
        } else {
            diff = 2;
            break;
        }
        img = next;
        img2 = next2;
    }
    if (img2)
        diff = 2;
    return diff;
}
ASS_Image *ass_render_frame(ASS_Renderer *priv, ASS_Track *track,
                            long long now, int *detect_change)
{
    if (!ass_start_frame(priv, track, now)) {
        if (detect_change)
            *detect_change = 2;
        return NULL;
    }
    int cnt = 0;
    for (int i = 0; i &lt; track-&gt;n_events; i++) {
        ASS_Event *event = track-&gt;events + i;
        if ((event-&gt;Start &lt;= now)
            &amp;&amp; (now &lt; (event-&gt;Start + event-&gt;Duration))) {
            if (cnt &gt;= priv-&gt;eimg_size) {
                priv-&gt;eimg_size += 100;
                priv-&gt;eimg =
                    realloc(priv-&gt;eimg,
                            priv-&gt;eimg_size * sizeof(EventImages));
            }
            if (ass_render_event(priv, event, priv-&gt;eimg + cnt))
                cnt++;
        }
    }
    if (cnt &gt; 0)
        qsort(priv-&gt;eimg, cnt, sizeof(EventImages), cmp_event_layer);
    EventImages *last = priv-&gt;eimg;
    for (int i = 1; i &lt; cnt; i++)
        if (last-&gt;event-&gt;Layer != priv-&gt;eimg[i].event-&gt;Layer) {
            fix_collisions(priv, last, priv-&gt;eimg + i - last);
            last = priv-&gt;eimg + i;
        }
    if (cnt &gt; 0)
        fix_collisions(priv, last, priv-&gt;eimg + cnt - last);
    ASS_Image **tail = &amp;priv-&gt;images_root;
    for (int i = 0; i &lt; cnt; i++) {
        ASS_Image *cur = priv-&gt;eimg[i].imgs;
        while (cur) {
            *tail = cur;
            tail = &amp;cur-&gt;next;
            cur = cur-&gt;next;
        }
    }
    ass_frame_ref(priv-&gt;images_root);
    if (detect_change)
        *detect_change = ass_detect_change(priv);
    ass_frame_unref(priv-&gt;prev_images_root);
    priv-&gt;prev_images_root = NULL;
    return priv-&gt;images_root;
}
void ass_frame_ref(ASS_Image *img)
{
    if (!img)
        return;
    ((ASS_ImagePriv *) img)-&gt;ref_count++;
}
void ass_frame_unref(ASS_Image *img)
{
    if (!img || --((ASS_ImagePriv *) img)-&gt;ref_count)
        return;
    do {
        ASS_ImagePriv *priv = (ASS_ImagePriv *) img;
        img = img-&gt;next;
        ass_cache_dec_ref(priv-&gt;source);
        ass_aligned_free(priv-&gt;buffer);
        free(priv);
    } while (img);
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>wyhash.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifndef wyhash_final_version_3
#define wyhash_final_version_3
#ifndef WYHASH_CONDOM
#define WYHASH_CONDOM 1
#endif
#ifndef WYHASH_32BIT_MUM
#define WYHASH_32BIT_MUM 0  
#endif
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;
#if defined(_MSC_VER) &amp;&amp; defined(_M_X64)
  #include &lt;intrin.h&gt;
  #pragma intrinsic(_umul128)
#endif
#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
  #define _likely_(x)  __builtin_expect(x,1)
  #define _unlikely_(x)  __builtin_expect(x,0)
#else
  #define _likely_(x) (x)
  #define _unlikely_(x) (x)
#endif
<a name="1"></a>
static inline uint64_t _wyrot(uint64_t x) { return (x&gt;&gt;32)|(x&lt;&lt;32); }
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static inline void _wymum(uint64_t *A, uint64_t *B){
#if(WYHASH_32BIT_MUM)
  uint64_t hh=(*A&gt;&gt;32)*(*B&gt;&gt;32), hl=(*A&gt;&gt;32)*(uint32_t)*B, lh=(uint32_t)*A*(*B&gt;&gt;32), ll=(uint64_t)(uint32_t)*A*(uint32_t)*B;
  #if(WYHASH_CONDOM&gt;1)
  *A^=_wyrot(hl)^hh; *B^=_wyrot(lh)^ll;
  #else
  *A=_wyrot(hl)^hh; *B=_wyrot(lh)^ll;
  #endif
#elif defined(__SIZEOF_INT128__)
  __uint128_t r=*A; r*=*B; 
<a name="0"></a>  #if(WYHASH_CONDOM&gt;1)
  *A^=(uint64_t)r; *B^=(uint64_t)(r&gt;&gt;64);
  #else
</b></font><font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  *A=(uint64_t)r; *B=(uint64_t)(r&gt;&gt;64);
  #endif
#elif defined(_MSC_VER) &amp;&amp; defined(_M_X64)
  #if(WYHASH_CONDOM&gt;1)
  uint64_t  a,  b;
  a=_umul128(*A,*B,&amp;b);
  *A^=a;  *B^=b;
  #else
  *A=_umul128(*A,*B,B);
  #endif
#else
  uint64_t ha=*A&gt;&gt;32, hb=*B&gt;&gt;32, la=(uint32_t)*A, lb=(uint32_t)*B, hi, lo;
  uint64_t rh=ha*hb, rm0=ha*lb, rm1=hb*la, rl=la*lb, t=rl+(rm0&lt;&lt;32), c=t&lt;rl;
  lo=t+(rm1&lt;&lt;32); c+=lo&lt;t; hi=rh+(rm0&gt;&gt;32)+(rm1&gt;&gt;32)+c;
  #if(WYHASH_CONDOM&gt;1)
  *A^=lo;  *B^=hi;
  #else
  *A=lo;  *B=hi;
  #endif
#endif
}
static inline uint64_t _wymix(uint64_t A, uint64_t B){ _wymum(&amp;A,&amp;B); return A^B; }</b></font>
#ifndef WYHASH_LITTLE_ENDIAN
  #if defined(_WIN32) || defined(__LITTLE_ENDIAN__) || (defined(__BYTE_ORDER__) &amp;&amp; __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
    #define WYHASH_LITTLE_ENDIAN 1
  #elif defined(__BIG_ENDIAN__) || (defined(__BYTE_ORDER__) &amp;&amp; __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
    #define WYHASH_LITTLE_ENDIAN 0
  #else
    #warning could not determine endianness! Falling back to little endian.
    #define WYHASH_LITTLE_ENDIAN 1
  #endif
#endif
#if (WYHASH_LITTLE_ENDIAN)
static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&amp;v, p, 8); return v;}
static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&amp;v, p, 4); return v;}
#elif defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&amp;v, p, 8); return __builtin_bswap64(v);}
static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&amp;v, p, 4); return __builtin_bswap32(v);}
#elif defined(_MSC_VER)
static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&amp;v, p, 8); return _byteswap_uint64(v);}
static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&amp;v, p, 4); return _byteswap_ulong(v);}
#else
static inline uint64_t _wyr8(const uint8_t *p) {
  uint64_t v; memcpy(&amp;v, p, 8);
  return (((v &gt;&gt; 56) &amp; 0xff)| ((v &gt;&gt; 40) &amp; 0xff00)| ((v &gt;&gt; 24) &amp; 0xff0000)| ((v &gt;&gt;  8) &amp; 0xff000000)| ((v &lt;&lt;  8) &amp; 0xff00000000)| ((v &lt;&lt; 24) &amp; 0xff0000000000)| ((v &lt;&lt; 40) &amp; 0xff000000000000)| ((v &lt;&lt; 56) &amp; 0xff00000000000000));
}
static inline uint64_t _wyr4(const uint8_t *p) {
  uint32_t v; memcpy(&amp;v, p, 4);
  return (((v &gt;&gt; 24) &amp; 0xff)| ((v &gt;&gt;  8) &amp; 0xff00)| ((v &lt;&lt;  8) &amp; 0xff0000)| ((v &lt;&lt; 24) &amp; 0xff000000));
}
#endif
static inline uint64_t _wyr3(const uint8_t *p, size_t k) { return (((uint64_t)p[0])&lt;&lt;16)|(((uint64_t)p[k&gt;&gt;1])&lt;&lt;8)|p[k-1];}
static inline uint64_t wyhash(const void *key, size_t len, uint64_t seed, const uint64_t *secret){
  const uint8_t *p=(const uint8_t *)key; seed^=*secret;	uint64_t	a,	b;
  if(_likely_(len&lt;=16)){
    if(_likely_(len&gt;=4)){ a=(_wyr4(p)&lt;&lt;32)|_wyr4(p+((len&gt;&gt;3)&lt;&lt;2)); b=(_wyr4(p+len-4)&lt;&lt;32)|_wyr4(p+len-4-((len&gt;&gt;3)&lt;&lt;2)); }
    else if(_likely_(len&gt;0)){ a=_wyr3(p,len); b=0;}
    else a=b=0;
<a name="2"></a>  }
  else{
    size_t i=len; 
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    if(_unlikely_(i&gt;48)){
      uint64_t see1=seed, see2=seed;
      do{
        seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);
        see1=_wymix(_wyr8(p+16)^secret[2],_wyr8(p+24)^see1);
        see2=_wymix(_wyr8(p+32)^secret[3],_wyr8(p+40)^see2);
        p+=48; i-=48;
      }while(_likely_(i&gt;48));
      seed^=see1^see2;</b></font>
    }
    while(_unlikely_(i&gt;16)){  seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);  i-=16; p+=16;  }
    a=_wyr8(p+i-16);  b=_wyr8(p+i-8);
  }
  return _wymix(secret[1]^len,_wymix(a^secret[1],b^seed));
}
static const uint64_t _wyp[4] = {0xa0761d6478bd642full, 0xe7037ed1a0b428dbull, 0x8ebc6af09c88c6e3ull, 0x589965cc75374cc3ull};
static inline uint64_t wyhash64(uint64_t A, uint64_t B){ A^=0xa0761d6478bd642full; B^=0xe7037ed1a0b428dbull; _wymum(&amp;A,&amp;B); return _wymix(A^0xa0761d6478bd642full,B^0xe7037ed1a0b428dbull);}
static inline uint64_t wyrand(uint64_t *seed){ *seed+=0xa0761d6478bd642full; return _wymix(*seed,*seed^0xe7037ed1a0b428dbull);}
static inline double wy2u01(uint64_t r){ const double _wynorm=1.0/(1ull&lt;&lt;52); return (r&gt;&gt;12)*_wynorm;}
static inline double wy2gau(uint64_t r){ const double _wynorm=1.0/(1ull&lt;&lt;20); return ((r&amp;0x1fffff)+((r&gt;&gt;21)&amp;0x1fffff)+((r&gt;&gt;42)&amp;0x1fffff))*_wynorm-3.0;}
#if(!WYHASH_32BIT_MUM)
static inline uint64_t wy2u0k(uint64_t r, uint64_t k){ _wymum(&amp;r,&amp;k); return k; }
#endif
static inline void make_secret(uint64_t seed, uint64_t *secret){
  uint8_t c[] = {15, 23, 27, 29, 30, 39, 43, 45, 46, 51, 53, 54, 57, 58, 60, 71, 75, 77, 78, 83, 85, 86, 89, 90, 92, 99, 101, 102, 105, 106, 108, 113, 114, 116, 120, 135, 139, 141, 142, 147, 149, 150, 153, 154, 156, 163, 165, 166, 169, 170, 172, 177, 178, 180, 184, 195, 197, 198, 201, 202, 204, 209, 210, 212, 216, 225, 226, 228, 232, 240 };
  for(size_t i=0;i&lt;4;i++){
    uint8_t ok;
    do{
      ok=1; secret[i]=0;
      for(size_t j=0;j&lt;64;j+=8) secret[i]|=((uint64_t)c[wyrand(&amp;seed)%sizeof(c)])&lt;&lt;j;
      if(secret[i]%2==0){ ok=0; continue; }
      for(size_t j=0;j&lt;i;j++) {
#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
        if(__builtin_popcountll(secret[j]^secret[i])!=32){ ok=0; break; }
#elif defined(_MSC_VER) &amp;&amp; defined(_M_X64)
        if(_mm_popcnt_u64(secret[j]^secret[i])!=32){ ok=0; break; }
#else
        uint64_t x = secret[j]^secret[i];
        x -= (x &gt;&gt; 1) &amp; 0x5555555555555555;
        x = (x &amp; 0x3333333333333333) + ((x &gt;&gt; 2) &amp; 0x3333333333333333);
        x = (x + (x &gt;&gt; 4)) &amp; 0x0f0f0f0f0f0f0f0f;
        x = (x * 0x0101010101010101) &gt;&gt; 56;
        if(x!=32){ ok=0; break; }
#endif
      }
    }while(!ok);
  }
}
#endif
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
