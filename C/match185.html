<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for bn_mp_sub_d.c & bn_mp_add_d.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for bn_mp_sub_d.c & bn_mp_add_d.c
      </h3>
      <h1 align="center">
        32.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>bn_mp_sub_d.c (32.35294%)<TH>bn_mp_add_d.c (32.35294%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match185-0.html#0',2,'match185-1.html#0',3)" NAME="0">(19-49)<TD><A HREF="javascript:ZweiFrames('match185-0.html#0',2,'match185-1.html#0',3)" NAME="0">(19-56)</A><TD ALIGN=center><FONT COLOR="#ff0000">22</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>bn_mp_sub_d.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#include &quot;tommath.h&quot;
#ifdef BN_MP_SUB_D_C
/* LibTomMath, multiple-precision integer library -- Tom St Denis
 *
 * LibTomMath is a library that provides multiple-precision
 * integer arithmetic as well as number theoretic functionality.
 *
 * The library was designed directly after the MPI library by
 * Michael Fromberger but has been written from scratch with
 * additional optimizations in place.
 *
 * The library is free for all purposes without any express
 * guarantee it works.
 *
 * Tom St Denis, tomstdenis@gmail.com, http://libtom.org
<A NAME="0"></A> */

/* single digit subtraction */
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match185-1.html#0',3,'match185-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>int
mp_sub_d (mp_int * a, mp_digit b, mp_int * c)
{
  mp_digit *tmpa, *tmpc, mu;
  int       res, ix, oldused;

  /* grow c as required */
  if (c-&gt;alloc &lt; a-&gt;used + 1) {
     if ((res = mp_grow(c, a-&gt;used + 1)) != MP_OKAY) {
        return res;
     }
  }

  /* if a is negative just do an unsigned
   * addition [with fudged signs]
   */
  if (a-&gt;sign == MP_NEG) {
     a-&gt;sign = MP_ZPOS;
     res     = mp_add_d(a, b, c);
     a-&gt;sign = c-&gt;sign = MP_NEG;

     /* clamp */
     mp_clamp(c);

     return res;
  }

  /* setup regs */
  oldused = c-&gt;used;
  tmpa    = a-&gt;dp;
  tmpc    = c-&gt;dp;</B></FONT>

  /* if a &lt;= b simply fix the single digit */
  if ((a-&gt;used == 1 &amp;&amp; a-&gt;dp[0] &lt;= b) || a-&gt;used == 0) {
     if (a-&gt;used == 1) {
        *tmpc++ = b - *tmpa;
     } else {
        *tmpc++ = b;
     }
     ix      = 1;

     /* negative/1digit */
     c-&gt;sign = MP_NEG;
     c-&gt;used = 1;
  } else {
     /* positive/size */
     c-&gt;sign = MP_ZPOS;
     c-&gt;used = a-&gt;used;

     /* subtract first digit */
     *tmpc    = *tmpa++ - b;
     mu       = *tmpc &gt;&gt; (sizeof(mp_digit) * CHAR_BIT - 1);
     *tmpc++ &amp;= MP_MASK;

     /* handle rest of the digits */
     for (ix = 1; ix &lt; a-&gt;used; ix++) {
        *tmpc    = *tmpa++ - mu;
        mu       = *tmpc &gt;&gt; (sizeof(mp_digit) * CHAR_BIT - 1);
        *tmpc++ &amp;= MP_MASK;
     }
  }

  /* zero excess digits */
  while (ix++ &lt; oldused) {
     *tmpc++ = 0;
  }
  mp_clamp(c);
  return MP_OKAY;
}

#endif

/* $Source: /cvs/libtom/libtommath/bn_mp_sub_d.c,v $ */
/* $Revision: 1.6 $ */
/* $Date: 2006/12/28 01:25:13 $ */
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>bn_mp_add_d.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#include &quot;tommath.h&quot;
#ifdef BN_MP_ADD_D_C
/* LibTomMath, multiple-precision integer library -- Tom St Denis
 *
 * LibTomMath is a library that provides multiple-precision
 * integer arithmetic as well as number theoretic functionality.
 *
 * The library was designed directly after the MPI library by
 * Michael Fromberger but has been written from scratch with
 * additional optimizations in place.
 *
 * The library is free for all purposes without any express
 * guarantee it works.
 *
 * Tom St Denis, tomstdenis@gmail.com, http://libtom.org
<A NAME="0"></A> */

/* single digit addition */
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match185-0.html#0',2,'match185-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>int
mp_add_d (mp_int * a, mp_digit b, mp_int * c)
{
  int     res, ix, oldused;
  mp_digit *tmpa, *tmpc, mu;

  /* grow c as required */
  if (c-&gt;alloc &lt; a-&gt;used + 1) {
     if ((res = mp_grow(c, a-&gt;used + 1)) != MP_OKAY) {
        return res;
     }
  }

  /* if a is negative and |a| &gt;= b, call c = |a| - b */
  if (a-&gt;sign == MP_NEG &amp;&amp; (a-&gt;used &gt; 1 || a-&gt;dp[0] &gt;= b)) {
     /* temporarily fix sign of a */
     a-&gt;sign = MP_ZPOS;

     /* c = |a| - b */
     res = mp_sub_d(a, b, c);

     /* fix sign  */
     a-&gt;sign = c-&gt;sign = MP_NEG;

     /* clamp */
     mp_clamp(c);

     return res;
  }

  /* old number of used digits in c */
  oldused = c-&gt;used;

  /* sign always positive */
  c-&gt;sign = MP_ZPOS;

  /* source alias */
  tmpa    = a-&gt;dp;</B></FONT>

  /* destination alias */
  tmpc    = c-&gt;dp;

  /* if a is positive */
  if (a-&gt;sign == MP_ZPOS) {
     /* add digit, after this we're propagating
      * the carry.
      */
     *tmpc   = *tmpa++ + b;
     mu      = *tmpc &gt;&gt; DIGIT_BIT;
     *tmpc++ &amp;= MP_MASK;

     /* now handle rest of the digits */
     for (ix = 1; ix &lt; a-&gt;used; ix++) {
        *tmpc   = *tmpa++ + mu;
        mu      = *tmpc &gt;&gt; DIGIT_BIT;
        *tmpc++ &amp;= MP_MASK;
     }
     /* set final carry */
     ix++;
     *tmpc++  = mu;

     /* setup size */
     c-&gt;used = a-&gt;used + 1;
  } else {
     /* a was negative and |a| &lt; b */
     c-&gt;used  = 1;

     /* the result is a single digit */
     if (a-&gt;used == 1) {
        *tmpc++  =  b - a-&gt;dp[0];
     } else {
        *tmpc++  =  b;
     }

     /* setup count so the clearing of oldused
      * can fall through correctly
      */
     ix       = 1;
  }

  /* now zero to oldused */
  while (ix++ &lt; oldused) {
     *tmpc++ = 0;
  }
  mp_clamp(c);

  return MP_OKAY;
}

#endif

/* $Source: /cvs/libtom/libtommath/bn_mp_add_d.c,v $ */
/* $Revision: 1.5 $ */
/* $Date: 2006/12/28 01:25:13 $ */
</PRE>
</div>
  </div>
</body>
</html>
