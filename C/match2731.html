<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-gtk-connection-view.c &amp; inf-discovery-avahi.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-gtk-connection-view.c &amp; inf-discovery-avahi.c
      </h3>
<h1 align="center">
        2.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-gtk-connection-view.c (6.060606%)<th>inf-discovery-avahi.c (1.55902%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(437-460)<td><a href="#" name="0">(1253-1276)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-gtk-connection-view.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinfgtk/inf-gtk-connection-view.h&gt;
#include &lt;libinfgtk/inf-gtk-certificate-view.h&gt;
#include &lt;libinfinity/common/inf-cert-util.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;gnutls/x509.h&gt;
typedef struct _InfGtkConnectionViewPrivate InfGtkConnectionViewPrivate;
struct _InfGtkConnectionViewPrivate {
  InfXmppConnection* connection;
  GtkWidget* remote_hostname;
  GtkWidget* remote_ipaddress;
  GtkWidget* local_ipaddress;
  GtkWidget* tls_version;
  GtkWidget* cipher_suite;
  GtkWidget* dh_prime_bits;
  GtkTreeStore* certificate_store;
  GtkWidget* certificate_expander;
  GtkWidget* certificate_tree_view;
  GtkWidget* certificate_info_view;
  GtkCellRenderer* text_renderer;
};
enum {
  PROP_0,
  PROP_CONNECTION
};
#define INF_GTK_CONNECTION_VIEW_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_GTK_TYPE_CONNECTION_VIEW, InfGtkConnectionViewPrivate))
G_DEFINE_TYPE_WITH_CODE(InfGtkConnectionView, inf_gtk_connection_view, GTK_TYPE_GRID,
  G_ADD_PRIVATE(InfGtkConnectionView))
static gchar*
inf_gtk_connection_view_format_ipaddress(InfIpAddress* address,
                                         guint port)
{
  gchar* out;
  gchar* str;
  str = inf_ip_address_to_string(address);
  switch(inf_ip_address_get_family(address))
  {
  case INF_IP_ADDRESS_IPV4:
    out = g_strdup_printf("%s:%u", str, port);
    break;
  case INF_IP_ADDRESS_IPV6:
    out = g_strdup_printf("[%s]:%u", str, port);
    break;
  default:
    g_assert_not_reached();
    out = NULL;
    break;
  }
  g_free(str);
  return out;
}
static void
inf_gtk_connection_view_set_chain(InfGtkConnectionView* view,
                                  InfCertificateChain* chain)
{
  InfGtkConnectionViewPrivate* priv;
  guint i;
  gnutls_x509_crt_t crt;
  GtkTreeIter prev_row;
  GtkTreeIter new_row;
  GtkTreeIter* parent;
  GtkTreePath* path;
  priv = INF_GTK_CONNECTION_VIEW_PRIVATE(view);
  gtk_tree_store_clear(priv-&gt;certificate_store);
  inf_gtk_certificate_view_set_certificate(
    INF_GTK_CERTIFICATE_VIEW(priv-&gt;certificate_info_view),
    NULL
  );
  parent = NULL;
  if(chain != NULL)
  {
    for(i = inf_certificate_chain_get_n_certificates(chain); i &gt; 0; -- i)
    {
      crt = inf_certificate_chain_get_nth_certificate(chain, i - 1);
      gtk_tree_store_append(priv-&gt;certificate_store, &amp;new_row, parent);
      gtk_tree_store_set(priv-&gt;certificate_store, &amp;new_row, 0, crt, -1);
      prev_row = new_row;
      parent = &amp;prev_row;
    }
    path = gtk_tree_model_get_path(
      GTK_TREE_MODEL(priv-&gt;certificate_store),
      &amp;new_row
    );
    gtk_tree_view_expand_to_path(
      GTK_TREE_VIEW(priv-&gt;certificate_tree_view),
      path
    );
    gtk_tree_selection_select_path(
      gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;certificate_tree_view)),
      path
    );
    gtk_tree_view_scroll_to_cell(
      GTK_TREE_VIEW(priv-&gt;certificate_tree_view),
      path,
      NULL,
      FALSE,
      0.0,
      0.0
    );
    gtk_tree_path_free(path);
    gtk_widget_show(priv-&gt;certificate_expander);
  }
  else
  {
    gtk_widget_hide(priv-&gt;certificate_expander);
  }
}
static void
inf_gtk_connection_view_selection_changed_cb(GtkTreeSelection* selection,
                                             gpointer user_data)
{
  InfGtkConnectionView* view;
  InfGtkConnectionViewPrivate* priv;
  GtkTreeIter iter;
  gnutls_x509_crt_t cert;
  view = INF_GTK_CONNECTION_VIEW(user_data);
  priv = INF_GTK_CONNECTION_VIEW_PRIVATE(view);
  if(gtk_tree_selection_get_selected(selection, NULL, &amp;iter))
  {
    gtk_tree_model_get(
      GTK_TREE_MODEL(priv-&gt;certificate_store),
      &amp;iter,
      0, &amp;cert,
      -1
    );
    inf_gtk_certificate_view_set_certificate(
      INF_GTK_CERTIFICATE_VIEW(priv-&gt;certificate_info_view),
      cert
    );
  }
  else
  {
    inf_gtk_certificate_view_set_certificate(
      INF_GTK_CERTIFICATE_VIEW(priv-&gt;certificate_info_view),
      NULL
    );
  }
}
static void
inf_gtk_connection_view_chain_data_func(GtkTreeViewColumn* column,
                                        GtkCellRenderer* renderer,
                                        GtkTreeModel* tree_model,
                                        GtkTreeIter* iter,
                                        gpointer user_data)
{
  gpointer crt_ptr;
  gnutls_x509_crt_t cert;
  GValue value = { 0 };
  gchar* common_name;
  gtk_tree_model_get(tree_model, iter, 0, &amp;crt_ptr, -1);
  cert = (gnutls_x509_crt_t)crt_ptr;
  common_name =
    inf_cert_util_get_dn_by_oid(cert, GNUTLS_OID_X520_COMMON_NAME, 0);
  g_value_init(&amp;value, G_TYPE_STRING);
  if(common_name != NULL)
    g_value_take_string(&amp;value, common_name);
  else
    g_value_set_static_string(&amp;value, _("&lt;Unknown Certificate Holder&gt;"));
  g_object_set_property(G_OBJECT(renderer), "text", &amp;value);
  g_value_unset(&amp;value);
}
static void
inf_gtk_connection_view_update_connection_info(InfGtkConnectionView* view,
                                               InfXmppConnection* connection)
{
  InfGtkConnectionViewPrivate* priv;
  InfTcpConnection* tcp;
  InfIpAddress* remote_address;
  guint remote_port;
  InfIpAddress* local_address;
  guint local_port;
  gchar* text;
  const gchar* cs;
  gnutls_kx_algorithm_t kx;
  gnutls_cipher_algorithm_t cipher;
  gnutls_mac_algorithm_t mac;
  gnutls_protocol_t ver;
  guint dh_prime_bits;
  priv = INF_GTK_CONNECTION_VIEW_PRIVATE(view);
  if(connection == NULL)
  {
    gtk_label_set_text(GTK_LABEL(priv-&gt;remote_hostname), NULL);
    gtk_label_set_text(GTK_LABEL(priv-&gt;remote_ipaddress), NULL);
    gtk_label_set_text(GTK_LABEL(priv-&gt;local_ipaddress), NULL);
    gtk_label_set_text(GTK_LABEL(priv-&gt;tls_version), NULL);
    gtk_label_set_text(GTK_LABEL(priv-&gt;cipher_suite), NULL);
    gtk_label_set_text(GTK_LABEL(priv-&gt;dh_prime_bits), NULL);
    inf_gtk_connection_view_set_chain(view, NULL);
  }
  else
  {
    g_object_get(G_OBJECT(connection), "remote-hostname", &amp;text, NULL);
    if(text != NULL)
    {
      gtk_label_set_text(GTK_LABEL(priv-&gt;remote_hostname), text);
    }
    else
    {
      text = g_markup_printf_escaped("&lt;i&gt;%s&lt;/i&gt;", _("Unknown"));
      gtk_label_set_markup(GTK_LABEL(priv-&gt;remote_hostname), text);
    }
    g_free(text);
    g_object_get(G_OBJECT(connection), "tcp-connection", &amp;tcp, NULL);
    g_object_get(
      G_OBJECT(tcp),
      "remote-address", &amp;remote_address,
      "remote-port", &amp;remote_port,
      "local-address", &amp;local_address,
      "local-port", &amp;local_port,
      NULL
    );
    g_object_unref(tcp);
    text = inf_gtk_connection_view_format_ipaddress(
      remote_address,
      remote_port
    );
    gtk_label_set_text(GTK_LABEL(priv-&gt;remote_ipaddress), text);
    g_free(text);
    text = inf_gtk_connection_view_format_ipaddress(
      local_address,
      local_port
    );
    gtk_label_set_text(GTK_LABEL(priv-&gt;local_ipaddress), text);
    g_free(text);
    inf_ip_address_free(remote_address);
    inf_ip_address_free(local_address);
    if(inf_xmpp_connection_get_tls_enabled(connection))
    {
      kx = inf_xmpp_connection_get_kx_algorithm(connection);
      cipher = inf_xmpp_connection_get_cipher_algorithm(connection);
      mac = inf_xmpp_connection_get_mac_algorithm(connection);
      ver = inf_xmpp_connection_get_tls_protocol(connection);
      dh_prime_bits = inf_xmpp_connection_get_dh_prime_bits(connection);
      gtk_label_set_text(
        GTK_LABEL(priv-&gt;tls_version),
        gnutls_protocol_get_name(ver)
      );
      cs = gnutls_cipher_suite_get_name(kx, cipher, mac);
      if(ver == GNUTLS_SSL3)
        text = g_strdup_printf("SSL_%s", cs);
      else
        text = g_strdup_printf("TLS_%s", cs);
      gtk_label_set_text(GTK_LABEL(priv-&gt;cipher_suite), text);
      g_free(text);
      if(dh_prime_bits &gt; 0)
      {
        text = g_markup_printf_escaped("%u bit", dh_prime_bits);
        gtk_label_set_text(GTK_LABEL(priv-&gt;dh_prime_bits), text);
      }
      else
      {
        text = g_markup_printf_escaped("&lt;i&gt;%s&lt;/i&gt;", _("N/A"));
        gtk_label_set_markup(GTK_LABEL(priv-&gt;dh_prime_bits), text);
      }
      g_free(text);
      inf_gtk_connection_view_set_chain(
        view,
        inf_xmpp_connection_get_peer_certificate(connection)
      );
    }
    else
    {
      text = g_markup_printf_escaped("&lt;i&gt;%s&lt;/i&gt;", _("No Encryption"));
      gtk_label_set_markup(GTK_LABEL(priv-&gt;tls_version), text);
      g_free(text);
      text = g_markup_printf_escaped("&lt;i&gt;%s&lt;/i&gt;", _("N/A"));
      gtk_label_set_markup(GTK_LABEL(priv-&gt;cipher_suite), text);
      gtk_label_set_markup(GTK_LABEL(priv-&gt;dh_prime_bits), text);
      g_free(text);
      inf_gtk_connection_view_set_chain(view, NULL);
    }
  }
}
static void
inf_gtk_connection_view_notify_tls_enabled_cb(GObject* object,
                                              GParamSpec* pspec,
                                              gpointer user_data)
{
  InfGtkConnectionView* view;
  InfGtkConnectionViewPrivate* priv;
  view = INF_GTK_CONNECTION_VIEW(user_data);
  priv = INF_GTK_CONNECTION_VIEW_PRIVATE(view);
  g_assert(priv-&gt;connection != NULL);
  inf_gtk_connection_view_update_connection_info(view, priv-&gt;connection);
}
static void
inf_gtk_connection_view_notify_credentials_cb(GObject* object,
                                              GParamSpec* pspec,
                                              gpointer user_data)
{
  InfGtkConnectionView* view;
  InfGtkConnectionViewPrivate* priv;
  view = INF_GTK_CONNECTION_VIEW(user_data);
  priv = INF_GTK_CONNECTION_VIEW_PRIVATE(view);
  g_assert(priv-&gt;connection != NULL);
  inf_gtk_connection_view_update_connection_info(view, priv-&gt;connection);
}
static void
inf_gtk_connection_view_init(InfGtkConnectionView* view)
{
  InfGtkConnectionViewPrivate* priv;
  priv = INF_GTK_CONNECTION_VIEW_PRIVATE(view);
  priv-&gt;connection = NULL;
  gtk_widget_init_template(GTK_WIDGET(view));
  gtk_tree_selection_set_mode(
    gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;certificate_tree_view)),
    GTK_SELECTION_BROWSE
  );
  gtk_tree_view_column_set_cell_data_func(
    gtk_tree_view_get_column(GTK_TREE_VIEW(priv-&gt;certificate_tree_view), 0),
    priv-&gt;text_renderer,
    inf_gtk_connection_view_chain_data_func,
    NULL,
    NULL
  );
}
static void
inf_gtk_connection_view_set_property(GObject* object,
                                     guint prop_id,
                                     const GValue* value,
                                     GParamSpec* pspec)
{
  InfGtkConnectionView* view;
  InfGtkConnectionViewPrivate* priv;
  view = INF_GTK_CONNECTION_VIEW(object);
  priv = INF_GTK_CONNECTION_VIEW_PRIVATE(view);
  switch(prop_id)
<a name="0"></a>  {
  case PROP_CONNECTION:
    inf_gtk_connection_view_set_connection(view, INF_XMPP_CONNECTION(value));
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_gtk_connection_view_get_property(GObject* object,
                                     guint prop_id,
                                     GValue* value,
                                     GParamSpec* pspec)
{
  InfGtkConnectionView* view;
  InfGtkConnectionViewPrivate* priv;
  view = INF_GTK_CONNECTION_VIEW(object);
  priv = INF_GTK_CONNECTION_VIEW_PRIVATE(view);
  switch(prop_id)
  {
  case PROP_CONNECTION:
    g_value_set_object(value, priv-&gt;connection);
    break;</b></font>
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_gtk_connection_view_dispose(GObject* object)
{
  InfGtkConnectionView* view;
  InfGtkConnectionViewPrivate* priv;
  view = INF_GTK_CONNECTION_VIEW(object);
  priv = INF_GTK_CONNECTION_VIEW_PRIVATE(view);
  if(priv-&gt;connection != NULL)
    inf_gtk_connection_view_set_connection(view, NULL);
  G_OBJECT_CLASS(inf_gtk_connection_view_parent_class)-&gt;dispose(object);
}
static void
inf_gtk_connection_view_class_init(
  InfGtkConnectionViewClass* connection_view_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(connection_view_class);
  object_class-&gt;set_property = inf_gtk_connection_view_set_property;
  object_class-&gt;get_property = inf_gtk_connection_view_get_property;
  object_class-&gt;dispose = inf_gtk_connection_view_dispose;
  gtk_widget_class_set_template_from_resource(
    GTK_WIDGET_CLASS(connection_view_class),
    "/de/0x539/libinfgtk/ui/infgtkconnectionview.ui"
  );
  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(object_class),
    InfGtkConnectionView,
    certificate_store
  );
  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(connection_view_class),
    InfGtkConnectionView,
    remote_hostname
  );
  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(connection_view_class),
    InfGtkConnectionView,
    remote_ipaddress
  );
  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(connection_view_class),
    InfGtkConnectionView,
    local_ipaddress
  );
  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(connection_view_class),
    InfGtkConnectionView,
    tls_version
  );
  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(connection_view_class),
    InfGtkConnectionView,
    cipher_suite
  );
  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(connection_view_class),
    InfGtkConnectionView,
    dh_prime_bits
  );
  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(object_class),
    InfGtkConnectionView,
    certificate_expander
  );
  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(object_class),
    InfGtkConnectionView,
    certificate_tree_view
  );
  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(object_class),
    InfGtkConnectionView,
    certificate_info_view
  );
  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(object_class),
    InfGtkConnectionView,
    text_renderer
  );
  gtk_widget_class_bind_template_callback(
    GTK_WIDGET_CLASS(object_class),
    inf_gtk_connection_view_selection_changed_cb
  );
  g_object_class_install_property(
    object_class,
    PROP_CONNECTION,
    g_param_spec_object(
      "connection",
      "Connection",
      "Connection for which to show parameters",
      INF_TYPE_XMPP_CONNECTION,
      G_PARAM_READWRITE
    )
  );
}
GtkWidget*
inf_gtk_connection_view_new(void)
{
  GObject* object;
  object = g_object_new(INF_GTK_TYPE_CONNECTION_VIEW, NULL);
  return GTK_WIDGET(object);
}
GtkWidget*
inf_gtk_connection_view_new_with_connection(InfXmppConnection* connection)
{
  GObject* object;
  g_return_val_if_fail(
    connection == NULL || INF_IS_XMPP_CONNECTION(connection),
    NULL
  );
  object = g_object_new(
    INF_GTK_TYPE_CONNECTION_VIEW,
    "connection", connection,
    NULL
  );
  return GTK_WIDGET(object);
}
void
inf_gtk_connection_view_set_connection(InfGtkConnectionView* view,
                                       InfXmppConnection* connection)
{
  InfGtkConnectionViewPrivate* priv;
  g_return_if_fail(INF_GTK_IS_CONNECTION_VIEW(view));
  g_return_if_fail(connection == NULL || INF_IS_XMPP_CONNECTION(connection));
  priv = INF_GTK_CONNECTION_VIEW_PRIVATE(view);
  if(priv-&gt;connection != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;connection),
      G_CALLBACK(inf_gtk_connection_view_notify_tls_enabled_cb),
      view
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;connection),
      G_CALLBACK(inf_gtk_connection_view_notify_credentials_cb),
      view
    );
    g_object_unref(priv-&gt;connection);
  }
  priv-&gt;connection = connection;
  if(connection != NULL)
  {
    g_object_ref(connection);
    g_signal_connect(
      G_OBJECT(connection),
      "notify::tls-enabled",
      G_CALLBACK(inf_gtk_connection_view_notify_tls_enabled_cb),
      view
    );
    g_signal_connect(
      G_OBJECT(connection),
      "notify::credentials",
      G_CALLBACK(inf_gtk_connection_view_notify_credentials_cb),
      view
    );
  }
  inf_gtk_connection_view_update_connection_info(view, connection);
  g_object_notify(G_OBJECT(view), "connection");
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-discovery-avahi.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinfinity/common/inf-discovery-avahi.h&gt;
#include &lt;libinfinity/common/inf-discovery.h&gt;
#include &lt;libinfinity/common/inf-local-publisher.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-config.h&gt; 
#ifdef LIBINFINITY_HAVE_AVAHI
#include &lt;avahi-client/client.h&gt;
#include &lt;avahi-client/lookup.h&gt;
#include &lt;avahi-client/publish.h&gt;
#include &lt;avahi-common/watch.h&gt;
#include &lt;avahi-common/malloc.h&gt;
#include &lt;avahi-common/timeval.h&gt;
#include &lt;avahi-common/alternative.h&gt;
#include &lt;avahi-common/error.h&gt;
#include &lt;sys/socket.h&gt; #include &lt;net/if.h&gt; #include &lt;string.h&gt;
struct AvahiWatch {
  InfDiscoveryAvahi* avahi;
  InfIoWatch* watch;
  InfNativeSocket socket;
  AvahiWatchEvent occurred_events;
  AvahiWatchCallback callback;
  void* userdata;
};
struct AvahiTimeout {
  InfDiscoveryAvahi* avahi;
  InfIoTimeout* timeout;
  AvahiTimeoutCallback callback;
  void* userdata;
};
typedef struct _InfDiscoveryAvahiInfoResolv InfDiscoveryAvahiInfoResolv;
struct _InfDiscoveryAvahiInfoResolv {
  InfDiscoveryResolvCompleteFunc complete_func;
  gpointer user_data;
};
struct _InfDiscoveryInfo {
  gchar* service_name;
  const gchar* service_type;
  gchar* domain;
  AvahiIfIndex interface;
  AvahiProtocol protocol;
  AvahiServiceResolver* service_resolver;
  InfXmppConnection* resolved;
  GSList* resolv;
};
struct _InfLocalPublisherItem {
  gchar* type;
  char* name;
  guint port;
  AvahiEntryGroup* entry_group;
};
typedef struct _InfDiscoveryAvahiDiscoverInfo InfDiscoveryAvahiDiscoverInfo;
struct _InfDiscoveryAvahiDiscoverInfo {
  gchar* type;   AvahiServiceBrowser* service_browser;
  GSList* discovered;
};
typedef struct _InfDiscoveryAvahiPrivate InfDiscoveryAvahiPrivate;
struct _InfDiscoveryAvahiPrivate {
  AvahiPoll poll;
  InfIo* io;
  InfXmppManager* xmpp_manager;
  InfXmppConnectionSecurityPolicy security_policy;
  InfKeepalive keepalive;
  InfCertificateCredentials* creds;
  InfSaslContext* sasl_context;
  gchar* sasl_mechanisms;
  AvahiClient* client;
  GSList* published;
  GHashTable* discovered; };
enum {
  PROP_0,
  PROP_XMPP_MANAGER,
  PROP_IO,
  PROP_CREDENTIALS,
  PROP_SASL_CONTEXT,
  PROP_SASL_MECHANISMS,
  PROP_SECURITY_POLICY,
  PROP_KEEPALIVE
};
#define INF_DISCOVERY_AVAHI_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_DISCOVERY_AVAHI, InfDiscoveryAvahiPrivate))
static GQuark inf_discovery_avahi_error_quark;
static void inf_discovery_avahi_discovery_iface_init(InfDiscoveryInterface* iface);
static void inf_discovery_avahi_local_publisher_iface_init(InfLocalPublisherInterface* iface);
G_DEFINE_TYPE_WITH_CODE(InfDiscoveryAvahi, inf_discovery_avahi, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfDiscoveryAvahi)
  G_IMPLEMENT_INTERFACE(INF_TYPE_DISCOVERY, inf_discovery_avahi_discovery_iface_init)
  G_IMPLEMENT_INTERFACE(INF_TYPE_LOCAL_PUBLISHER, inf_discovery_avahi_local_publisher_iface_init))
static void
inf_discovery_avahi_discovery_info_resolved_destroy_cb(gpointer user_data,
                                                       GObject* object)
{
  InfDiscoveryInfo* info;
  info = (InfDiscoveryInfo*)user_data;
  info-&gt;resolved = NULL;
}
static void
inf_discovery_avahi_info_resolv_complete(InfDiscoveryInfo* info)
{
  GSList* item;
  InfDiscoveryAvahiInfoResolv* resolv;
  g_assert(info-&gt;resolved != NULL);
  for(item = info-&gt;resolv; item != NULL; item = g_slist_next(item))
  {
    resolv = (InfDiscoveryAvahiInfoResolv*)item-&gt;data;
    resolv-&gt;complete_func(
      info,
      INF_XML_CONNECTION(info-&gt;resolved),
      NULL,
      resolv-&gt;user_data
    );
    g_slice_free(InfDiscoveryAvahiInfoResolv, resolv);
  }
  g_slist_free(info-&gt;resolv);
  info-&gt;resolv = NULL;
}
static void
inf_discovery_avahi_info_resolv_error(InfDiscoveryInfo* info,
                                      const GError* error)
{
  GSList* item;
  InfDiscoveryAvahiInfoResolv* resolv;
  for(item = info-&gt;resolv; item != NULL; item = g_slist_next(item))
  {
    resolv = (InfDiscoveryAvahiInfoResolv*)item-&gt;data;
    resolv-&gt;complete_func(info, NULL, error, resolv-&gt;user_data);
    g_slice_free(InfDiscoveryAvahiInfoResolv, resolv);
  }
  g_slist_free(info-&gt;resolv);
  info-&gt;resolv = NULL;
}
static void
inf_discovery_avahi_discovery_info_free(InfDiscoveryInfo* info)
{
  g_free(info-&gt;service_name);
  g_free(info-&gt;domain);
  if(info-&gt;service_resolver != NULL)
    avahi_service_resolver_free(info-&gt;service_resolver);
  if(info-&gt;resolved != NULL)
  {
    g_object_weak_unref(
      G_OBJECT(info-&gt;resolved),
      inf_discovery_avahi_discovery_info_resolved_destroy_cb,
      info
    );
  }
  inf_discovery_avahi_info_resolv_error(info, NULL);
  g_slist_free(info-&gt;resolv);
  g_slice_free(InfDiscoveryInfo, info);
}
static void
inf_discovery_avahi_publisher_item_free(gpointer data)
{
  InfLocalPublisherItem* item;
  item = (InfLocalPublisherItem*)data;
  if(item-&gt;entry_group != NULL)
    avahi_entry_group_free(item-&gt;entry_group);
  g_free(item-&gt;type);
  avahi_free(item-&gt;name);
  g_slice_free(InfLocalPublisherItem, item);
}
static void
inf_discovery_avahi_discover_info_free(gpointer data)
{
  InfDiscoveryAvahiDiscoverInfo* info;
  GSList* item;
  info = (InfDiscoveryAvahiDiscoverInfo*)data;
  for(item = info-&gt;discovered; item != NULL; item = g_slist_next(item))
    inf_discovery_avahi_discovery_info_free((InfDiscoveryInfo*)item-&gt;data);
  if(info-&gt;service_browser != NULL)
    avahi_service_browser_free(info-&gt;service_browser);
  g_slist_free(info-&gt;discovered);
  g_free(info-&gt;type);
  g_slice_free(InfDiscoveryAvahiDiscoverInfo, info);
}
static void
inf_discovery_avahi_service_resolver_callback(AvahiServiceResolver* resolver,
                                              AvahiIfIndex interface,
                                              AvahiProtocol protocol,
                                              AvahiResolverEvent event,
                                              const char* name,
                                              const char* type,
                                              const char* domain,
                                              const char* host_name,
                                              const AvahiAddress* address,
                                              uint16_t port,
                                              AvahiStringList* txt,
                                              AvahiLookupResultFlags flags,
                                              void* userdata)
{
  InfDiscoveryAvahi* avahi;
  InfDiscoveryAvahiPrivate* priv;
  InfDiscoveryAvahiDiscoverInfo* info;
  InfDiscoveryInfo* discovery_info;
  GSList* item;
  InfIpAddress* inf_addr;
  InfTcpConnection* tcp;
  InfXmppConnection* xmpp;
  InfXmlConnectionStatus status;
  GError* error;
  avahi = INF_DISCOVERY_AVAHI(userdata);
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
  info = g_hash_table_lookup(priv-&gt;discovered, type);
  g_assert(info != NULL);
  for(item = info-&gt;discovered; item != NULL; item = g_slist_next(item))
  {
    discovery_info = (InfDiscoveryInfo*)item-&gt;data;
    if(discovery_info-&gt;service_resolver == resolver)
      break;
  }
  g_assert(item != NULL);
  g_assert(discovery_info-&gt;resolved == NULL);
  discovery_info-&gt;service_resolver = NULL;
  switch(event)
  {
  case AVAHI_RESOLVER_FOUND:
    switch(address-&gt;proto)
    {
    case AVAHI_PROTO_INET:
      inf_addr = inf_ip_address_new_raw4(address-&gt;data.ipv4.address);
      break;
    case AVAHI_PROTO_INET6:
      inf_addr = inf_ip_address_new_raw6(address-&gt;data.ipv6.address);
      break;
    default:
      g_assert_not_reached();
      break;
    }
    xmpp = inf_xmpp_manager_lookup_connection_by_address(
      priv-&gt;xmpp_manager,
      inf_addr,
      port
    );
    if(xmpp == NULL)
    {
      tcp = inf_tcp_connection_new(priv-&gt;io, inf_addr, port);
      g_object_set(
        G_OBJECT(tcp),
        "device-index", discovery_info-&gt;interface,
        NULL
      );
      error = NULL;
      if(!inf_tcp_connection_set_keepalive(tcp, &amp;priv-&gt;keepalive, &amp;error) ||
         !inf_tcp_connection_open(tcp, &amp;error))
      {
        inf_discovery_avahi_info_resolv_error(discovery_info, error);
        g_error_free(error);
        g_object_unref(tcp);
      }
      else
      {
        xmpp = inf_xmpp_connection_new(
          tcp,
          INF_XMPP_CONNECTION_CLIENT,
          NULL,
          host_name,
          priv-&gt;security_policy,
          priv-&gt;creds,
          priv-&gt;sasl_context,
          priv-&gt;sasl_context == NULL ? NULL : priv-&gt;sasl_mechanisms
        );
        g_object_unref(tcp);
        inf_xmpp_manager_add_connection(priv-&gt;xmpp_manager, xmpp);
        discovery_info-&gt;resolved = xmpp;
        g_object_weak_ref(
          G_OBJECT(xmpp),
          inf_discovery_avahi_discovery_info_resolved_destroy_cb,
          discovery_info
        );
        inf_discovery_avahi_info_resolv_complete(discovery_info);
        g_object_unref(xmpp);
      }
    }
    else
    {
      discovery_info-&gt;resolved = xmpp;
      g_object_weak_ref(
        G_OBJECT(xmpp),
        inf_discovery_avahi_discovery_info_resolved_destroy_cb,
        discovery_info
      );
      g_object_get(G_OBJECT(xmpp), "status", &amp;status, NULL);
      if(status == INF_XML_CONNECTION_CLOSING)
      {
        inf_discovery_avahi_info_resolv_error(discovery_info, NULL);
      }
      else if(status == INF_XML_CONNECTION_CLOSED)
      {
        error = NULL;
        if(!inf_xml_connection_open(INF_XML_CONNECTION(xmpp), &amp;error))
        {
          inf_discovery_avahi_info_resolv_error(discovery_info, error);
          g_error_free(error);
        }
        else
        {
          inf_discovery_avahi_info_resolv_complete(discovery_info);
        }
      }
      else
      {
        inf_discovery_avahi_info_resolv_complete(discovery_info);
      }
    }
    inf_ip_address_free(inf_addr);
    break;
  case AVAHI_RESOLVER_FAILURE:
    error = NULL;
    g_set_error_literal(
      &amp;error,
      inf_discovery_avahi_error_quark,
      avahi_client_errno(avahi_service_resolver_get_client(resolver)),
      avahi_strerror(
        avahi_client_errno(avahi_service_resolver_get_client(resolver))
      )
    );
    inf_discovery_avahi_info_resolv_error(discovery_info, error);
    g_error_free(error);
    break;
  }
  avahi_service_resolver_free(resolver);
}
static void
inf_discovery_avahi_perform_undiscover(InfDiscoveryAvahi* avahi,
                                       InfDiscoveryAvahiDiscoverInfo* info);
static void
inf_discovery_avahi_perform_unpublish_item(InfLocalPublisherItem* item);
static void
inf_discovery_avahi_service_browser_callback(AvahiServiceBrowser* browser,
                                             AvahiIfIndex interface,
                                             AvahiProtocol protocol,
                                             AvahiBrowserEvent event,
                                             const char* name,
                                             const char* type,
                                             const char* domain,
                                             AvahiLookupResultFlags flags,
                                             void* userdata)
{
  InfDiscoveryAvahi* avahi;
  InfDiscoveryAvahiPrivate* priv;
  InfDiscoveryAvahiDiscoverInfo* info;
  InfDiscoveryInfo* discovery_info;
  GSList* item;
  avahi = INF_DISCOVERY_AVAHI(userdata);
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
  info = g_hash_table_lookup(priv-&gt;discovered, type);
  g_assert(info != NULL);
  switch(event)
  {
  case AVAHI_BROWSER_NEW:
    if((flags &amp; AVAHI_LOOKUP_RESULT_OUR_OWN) == 0)
    {
      discovery_info = g_slice_new(InfDiscoveryInfo);
      discovery_info-&gt;service_name = g_strdup(name);
      discovery_info-&gt;service_type = info-&gt;type;
      discovery_info-&gt;domain = g_strdup(domain);
      discovery_info-&gt;interface = interface;
      discovery_info-&gt;protocol = protocol;
      discovery_info-&gt;service_resolver = NULL;
      discovery_info-&gt;resolved = NULL;
      discovery_info-&gt;resolv = NULL;
      info-&gt;discovered = g_slist_prepend(info-&gt;discovered, discovery_info);
      inf_discovery_discovered(INF_DISCOVERY(avahi), discovery_info);
    }
    break;
  case AVAHI_BROWSER_REMOVE:
    for(item = info-&gt;discovered; item != NULL; item = g_slist_next(item))
    {
      discovery_info = (InfDiscoveryInfo*)item-&gt;data;
      g_assert(strcmp(discovery_info-&gt;service_type, type) == 0);
      if(strcmp(discovery_info-&gt;service_name, name) == 0 &amp;&amp;
         discovery_info-&gt;interface == interface &amp;&amp;
         discovery_info-&gt;protocol == protocol)
      {
        inf_discovery_undiscovered(INF_DISCOVERY(avahi), discovery_info);
        info-&gt;discovered = g_slist_remove(info-&gt;discovered, discovery_info);
        inf_discovery_avahi_discovery_info_free(discovery_info);
        break;
      }
    }
    break;
  case AVAHI_BROWSER_CACHE_EXHAUSTED:
    break;
  case AVAHI_BROWSER_ALL_FOR_NOW:
    break;
  case AVAHI_BROWSER_FAILURE:
    g_warning(
      _("Avahi service browser is in failure state. Services of type '%s' "
        "are no longer discovered.\n\nThe failure was: %s\n"),
      info-&gt;type,
      avahi_strerror(
        avahi_client_errno(avahi_service_browser_get_client(browser))
      )
    );
    inf_discovery_avahi_perform_undiscover(avahi, info);
    break;
  default:
    g_assert_not_reached();
    break;
  }
}
static void
inf_discovery_avahi_entry_group_add_service(InfLocalPublisherItem* item)
{
  char* new_name;
  int res;
  do
  {
    res = avahi_entry_group_add_service(
      item-&gt;entry_group,
      AVAHI_IF_UNSPEC,
      AVAHI_PROTO_UNSPEC,
      0,
      item-&gt;name,
      item-&gt;type,
      NULL,
      NULL,
      item-&gt;port,
      NULL
    );
    if(res != AVAHI_ERR_COLLISION) break;
    new_name = avahi_alternative_service_name(item-&gt;name);
    avahi_free(item-&gt;name);
    item-&gt;name = new_name;
  } while(1);
  if(res != 0)
  {
    g_warning(
      "Failed to publish service \"%s\" via avahi: %s",
      item-&gt;name,
      avahi_strerror(res)
    );
  }
}
static void
inf_discovery_avahi_entry_group_callback(AvahiEntryGroup* group,
                                         AvahiEntryGroupState state,
                                         void* userdata)
{
  InfLocalPublisherItem* item;
  char* new_name;
  item = (InfLocalPublisherItem*)userdata;
  switch(state)
  {
  case AVAHI_ENTRY_GROUP_UNCOMMITED:
    break;
  case AVAHI_ENTRY_GROUP_REGISTERING:
    break;
  case AVAHI_ENTRY_GROUP_ESTABLISHED:
    break;
  case AVAHI_ENTRY_GROUP_COLLISION:
    new_name = avahi_alternative_service_name(item-&gt;name);
    avahi_free(item-&gt;name);
    item-&gt;name = new_name;
    avahi_entry_group_reset(item-&gt;entry_group);
    inf_discovery_avahi_entry_group_add_service(item);
    avahi_entry_group_commit(item-&gt;entry_group);
    break;
  case AVAHI_ENTRY_GROUP_FAILURE:
    g_warning(
      _("Avahi entry group is in failure state. The service '%s' of type "
        "'%s' is no longer published.\n\nThe failure was: %s\n"),
      item-&gt;name,
      item-&gt;type,
      avahi_strerror(avahi_client_errno(avahi_entry_group_get_client(group)))
    );
    inf_discovery_avahi_perform_unpublish_item(item);
    break;
  default:
    g_assert_not_reached();
    break;
  }
}
static void
inf_discovery_avahi_perform_publish_item(InfDiscoveryAvahi* avahi,
                                         InfLocalPublisherItem* item)
{
  InfDiscoveryAvahiPrivate* priv;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
  if(item-&gt;entry_group == NULL)
  {
    item-&gt;entry_group = avahi_entry_group_new(
      priv-&gt;client,
      inf_discovery_avahi_entry_group_callback,
      item
    );
    inf_discovery_avahi_entry_group_add_service(item);
    avahi_entry_group_commit(item-&gt;entry_group);
  }
}
static void
inf_discovery_avahi_perform_unpublish_item(InfLocalPublisherItem* item)
{
  if(item-&gt;entry_group != NULL)
  {
    avahi_entry_group_free(item-&gt;entry_group);
    item-&gt;entry_group = NULL;
  }
}
static void
inf_discovery_avahi_perform_publish_all(InfDiscoveryAvahi* avahi)
{
  InfDiscoveryAvahiPrivate* priv;
  GSList* item;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
  for(item = priv-&gt;published; item != NULL; item = g_slist_next(item))
  {
    inf_discovery_avahi_perform_publish_item(
      avahi,
      (InfLocalPublisherItem*)item-&gt;data
    );
  }
}
static void
inf_discovery_avahi_perform_unpublish_all(InfDiscoveryAvahi* avahi)
{
  InfDiscoveryAvahiPrivate* priv;
  GSList* item;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
  for(item = priv-&gt;published; item != NULL; item = g_slist_next(item))
  {
    inf_discovery_avahi_perform_unpublish_item(
      (InfLocalPublisherItem*)item-&gt;data
    );
  }
}
static void
inf_discovery_avahi_perform_discover(InfDiscoveryAvahi* avahi,
                                     InfDiscoveryAvahiDiscoverInfo* info)
{
  InfDiscoveryAvahiPrivate* priv;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
  if(info-&gt;service_browser == NULL)
  {
    info-&gt;service_browser = avahi_service_browser_new(
      priv-&gt;client,
      AVAHI_IF_UNSPEC,
      AVAHI_PROTO_UNSPEC,
      info-&gt;type,
      NULL,
      0,
      inf_discovery_avahi_service_browser_callback,
      avahi
    );
  }
}
static void
inf_discovery_avahi_perform_undiscover(InfDiscoveryAvahi* avahi,
                                       InfDiscoveryAvahiDiscoverInfo* info)
{
  InfDiscoveryInfo* discovery_info;
  GSList* next;
  for(; info-&gt;discovered != NULL; info-&gt;discovered = next)
  {
    next = info-&gt;discovered-&gt;next;
    discovery_info = (InfDiscoveryInfo*)info-&gt;discovered-&gt;data;
    inf_discovery_undiscovered(INF_DISCOVERY(avahi), discovery_info);
    inf_discovery_avahi_discovery_info_free(discovery_info);
    info-&gt;discovered = g_slist_delete_link(
      info-&gt;discovered,
      info-&gt;discovered
    );
  }
  if(info-&gt;service_browser != NULL)
  {
    avahi_service_browser_free(info-&gt;service_browser);
    info-&gt;service_browser = NULL;
  }
}
static void
inf_discovery_avahi_perform_discover_all_foreach_func(gpointer key,
                                                      gpointer value,
                                                      gpointer user_data)
{
  inf_discovery_avahi_perform_discover(
    INF_DISCOVERY_AVAHI(user_data),
    (InfDiscoveryAvahiDiscoverInfo*)value
  );
}
static void
inf_discovery_avahi_perform_undiscover_all_foreach_func(gpointer key,
                                                        gpointer value,
                                                        gpointer user_data)
{
  inf_discovery_avahi_perform_undiscover(
    INF_DISCOVERY_AVAHI(user_data),
    (InfDiscoveryAvahiDiscoverInfo*)value
  );
}
static void
inf_discovery_avahi_perform_discover_all(InfDiscoveryAvahi* avahi)
{
  InfDiscoveryAvahiPrivate* priv;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
  g_hash_table_foreach(
    priv-&gt;discovered,
    inf_discovery_avahi_perform_discover_all_foreach_func,
    avahi
  );
}
static void
inf_discovery_avahi_perform_undiscover_all(InfDiscoveryAvahi* avahi)
{
  InfDiscoveryAvahiPrivate* priv;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
  g_hash_table_foreach(
    priv-&gt;discovered,
    inf_discovery_avahi_perform_undiscover_all_foreach_func,
    avahi
  );
}
static void
inf_discovery_avahi_client_callback(AvahiClient* client,
                                    AvahiClientState state,
                                    void* userdata);
static void
inf_discovery_avahi_create_client(InfDiscoveryAvahi* discovery)
{
  InfDiscoveryAvahiPrivate* priv;
  int error;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(discovery);
  priv-&gt;client = avahi_client_new(
    &amp;priv-&gt;poll,
    AVAHI_CLIENT_NO_FAIL,
    inf_discovery_avahi_client_callback,
    discovery,
    &amp;error
  );
  if(priv-&gt;client == NULL)
  {
    g_warning(_
      ("Failed to start Avahi client. Service discovery or publishing "
       "will not be possible.\n\nThe occurred failure was: %s"),
      avahi_strerror(error)
    );
  }
}
static void
inf_discovery_avahi_client_callback(AvahiClient* client,
                                    AvahiClientState state,
                                    void* userdata)
{
  InfDiscoveryAvahi* avahi;
  InfDiscoveryAvahiPrivate* priv;
  avahi = INF_DISCOVERY_AVAHI(userdata);
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
  switch(state)
  {
  case AVAHI_CLIENT_S_COLLISION:
    break;
  case AVAHI_CLIENT_S_REGISTERING:
    break;
  case AVAHI_CLIENT_S_RUNNING:
    inf_discovery_avahi_perform_publish_all(avahi);
    inf_discovery_avahi_perform_discover_all(avahi);
    break;
  case AVAHI_CLIENT_FAILURE:
    inf_discovery_avahi_perform_unpublish_all(avahi);
    inf_discovery_avahi_perform_undiscover_all(avahi);
    if(avahi_client_errno(client) != AVAHI_ERR_DISCONNECTED)
    {
      inf_discovery_avahi_create_client(avahi);
    }
    else
    {
      g_warning(
        _("Avahi client is in failure state. Service discovery or "
          "publishing is no longer possible.\n\nThe occurred failure "
          "was: %s\n"),
        avahi_strerror(avahi_client_errno(client))
      );
    }
  case AVAHI_CLIENT_CONNECTING:
    break;
  default:
    g_assert_not_reached();
    break;
  }
}
static AvahiWatchEvent
inf_discovery_avahi_from_io_event(InfIoEvent event)
{
  AvahiWatchEvent res;
  res = 0;
  if(event &amp; INF_IO_INCOMING) res |= AVAHI_WATCH_IN;
  if(event &amp; INF_IO_OUTGOING) res |= AVAHI_WATCH_OUT;
  if(event &amp; INF_IO_ERROR) res |= AVAHI_WATCH_ERR;
  return res;
}
static InfIoEvent
inf_discovery_avahi_to_io_event(AvahiWatchEvent event)
{
  InfIoEvent res;
  res = 0;
  if(event &amp; AVAHI_WATCH_IN) res |= INF_IO_INCOMING;
  if(event &amp; AVAHI_WATCH_OUT) res |= INF_IO_OUTGOING;
  if(event &amp; (AVAHI_WATCH_ERR | AVAHI_WATCH_HUP)) res |= INF_IO_ERROR;
  return res;
}
static void
inf_discovery_avahi_watch_cb(InfNativeSocket* socket,
                             InfIoEvent event,
                             gpointer user_data)
{
  AvahiWatch* watch;
  watch = (AvahiWatch*)user_data;
  watch-&gt;occurred_events = inf_discovery_avahi_from_io_event(event);
  watch-&gt;callback(watch, *socket, watch-&gt;occurred_events, watch-&gt;userdata);
}
static void
inf_discovery_avahi_timeout_cb(gpointer user_data)
{
  AvahiTimeout* timeout;
  timeout = (AvahiTimeout*)user_data;
  timeout-&gt;timeout = NULL;
  timeout-&gt;callback(timeout, timeout-&gt;userdata);
}
static AvahiWatch*
inf_discovery_avahi_watch_new(const AvahiPoll* api,
                              int fd,
                              AvahiWatchEvent event,
                              AvahiWatchCallback callback,
                              void* userdata)
{
  InfDiscoveryAvahi* avahi;
  InfDiscoveryAvahiPrivate* priv;
  AvahiWatch* watch;
  avahi = INF_DISCOVERY_AVAHI(api-&gt;userdata);
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
  watch = g_slice_new(AvahiWatch);
  watch-&gt;avahi = avahi;
  watch-&gt;socket = fd;
  watch-&gt;occurred_events = 0;
  watch-&gt;callback = callback;
  watch-&gt;userdata = userdata;
  watch-&gt;watch = inf_io_add_watch(
    priv-&gt;io,
    &amp;watch-&gt;socket,
    inf_discovery_avahi_to_io_event(event),
    inf_discovery_avahi_watch_cb,
    watch,
    NULL
  );
  return watch;
}
static void
inf_discovery_avahi_watch_update(AvahiWatch* watch,
                                 AvahiWatchEvent event)
{
  InfDiscoveryAvahiPrivate* priv;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(watch-&gt;avahi);
  inf_io_update_watch(
    priv-&gt;io,
    watch-&gt;watch,
    inf_discovery_avahi_to_io_event(event)
  );
}
static AvahiWatchEvent
inf_discovery_avahi_watch_get_events(AvahiWatch* watch)
{
  return watch-&gt;occurred_events;
}
static void
inf_discovery_avahi_watch_free(AvahiWatch* watch)
{
  InfDiscoveryAvahiPrivate* priv;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(watch-&gt;avahi);
  inf_io_remove_watch(priv-&gt;io, watch-&gt;watch);
  g_slice_free(AvahiWatch, watch);
}
static AvahiTimeout*
inf_discovery_avahi_timeout_new(const AvahiPoll* api,
                                const struct timeval* tv,
                                AvahiTimeoutCallback callback,
                                void* userdata)
{
  InfDiscoveryAvahi* avahi;
  InfDiscoveryAvahiPrivate* priv;
  AvahiTimeout* timeout;
  AvahiUsec usec;
  avahi = INF_DISCOVERY_AVAHI(api-&gt;userdata);
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
  timeout = g_slice_new(AvahiTimeout);
  timeout-&gt;avahi = avahi;
  timeout-&gt;callback = callback;
  timeout-&gt;userdata = userdata;
  if(tv != NULL)
  {
    usec = avahi_age(tv);
    if(usec &gt; 0) usec = 0;
    timeout-&gt;timeout = inf_io_add_timeout(
      priv-&gt;io,
      ((-usec) + 500) / 1000,
      inf_discovery_avahi_timeout_cb,
      timeout,
      NULL
    );
  }
  else
  {
    timeout-&gt;timeout = NULL;
  }
  return timeout;
}
static void
inf_discovery_avahi_timeout_update(AvahiTimeout* timeout,
                                   const struct timeval* tv)
{
  InfDiscoveryAvahiPrivate* priv;
  AvahiUsec usec;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(timeout-&gt;avahi);
  if(timeout-&gt;timeout != NULL)
    inf_io_remove_timeout(priv-&gt;io, timeout-&gt;timeout);
  if(tv != NULL)
  {
    usec = avahi_age(tv);
    if(usec &gt; 0) usec = 0;
    timeout-&gt;timeout = inf_io_add_timeout(
      priv-&gt;io,
      ((-usec) + 500) / 1000,
      inf_discovery_avahi_timeout_cb,
      timeout,
      NULL
    );
  }
  else
  {
    timeout-&gt;timeout = NULL;
  }
}
static void
inf_discovery_avahi_timeout_free(AvahiTimeout* timeout)
{
  InfDiscoveryAvahiPrivate* priv;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(timeout-&gt;avahi);
  if(timeout-&gt;timeout != NULL)
    inf_io_remove_timeout(priv-&gt;io, timeout-&gt;timeout);
  g_slice_free(AvahiTimeout, timeout);
}
static void
inf_discovery_avahi_init(InfDiscoveryAvahi* avahi)
{
  InfDiscoveryAvahiPrivate* priv;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
  priv-&gt;poll.userdata = avahi;
  priv-&gt;poll.watch_new = inf_discovery_avahi_watch_new;
  priv-&gt;poll.watch_update = inf_discovery_avahi_watch_update;
  priv-&gt;poll.watch_get_events = inf_discovery_avahi_watch_get_events;
  priv-&gt;poll.watch_free = inf_discovery_avahi_watch_free;
  priv-&gt;poll.timeout_new = inf_discovery_avahi_timeout_new;
  priv-&gt;poll.timeout_update = inf_discovery_avahi_timeout_update;
  priv-&gt;poll.timeout_free = inf_discovery_avahi_timeout_free;
  priv-&gt;io = NULL;
  priv-&gt;xmpp_manager = NULL;
  priv-&gt;security_policy = INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS;
  priv-&gt;keepalive.mask = 0;
  priv-&gt;creds = NULL;
  priv-&gt;sasl_context = NULL;
  priv-&gt;sasl_mechanisms = NULL;
  priv-&gt;client = NULL;
  priv-&gt;published = NULL;
  priv-&gt;discovered = g_hash_table_new_full(
    g_str_hash,
    g_str_equal,
    NULL,     inf_discovery_avahi_discover_info_free
  );
}
static void
inf_discovery_avahi_constructed(GObject* object)
{
  InfDiscoveryAvahiPrivate* priv;
  G_OBJECT_CLASS(inf_discovery_avahi_parent_class)-&gt;constructed(object);
  priv = INF_DISCOVERY_AVAHI_PRIVATE(object);
  g_assert(priv-&gt;io != NULL);
  inf_discovery_avahi_create_client(INF_DISCOVERY_AVAHI(object));
}
static void
inf_discovery_avahi_dispose(GObject* object)
{
  InfDiscoveryAvahi* avahi;
  InfDiscoveryAvahiPrivate* priv;
  GSList* item;
  avahi = INF_DISCOVERY_AVAHI(object);
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
  g_hash_table_destroy(priv-&gt;discovered);
  priv-&gt;discovered = NULL;
  for(item = priv-&gt;published; item != NULL; item = g_slist_next(item))
    inf_discovery_avahi_publisher_item_free(item-&gt;data);
  g_slist_free(priv-&gt;published);
  priv-&gt;published = NULL;
  if(priv-&gt;client != NULL)
  {
    avahi_client_free(priv-&gt;client);
    priv-&gt;client = NULL;
  }
  if(priv-&gt;xmpp_manager != NULL)
  {
    g_object_unref(G_OBJECT(priv-&gt;xmpp_manager));
    priv-&gt;xmpp_manager = NULL;
  }
  if(priv-&gt;creds != NULL)
  {
    inf_certificate_credentials_unref(priv-&gt;creds);
    priv-&gt;creds = NULL;
  }
  if(priv-&gt;sasl_context != NULL)
  {
    inf_sasl_context_unref(priv-&gt;sasl_context);
    priv-&gt;sasl_context = NULL;
  }
  if(priv-&gt;io != NULL)
  {
    g_object_unref(G_OBJECT(priv-&gt;io));
    priv-&gt;io = NULL;
  }
  G_OBJECT_CLASS(inf_discovery_avahi_parent_class)-&gt;dispose(object);
}
static void
inf_discovery_avahi_finalize(GObject* object)
{
  InfDiscoveryAvahi* avahi;
  InfDiscoveryAvahiPrivate* priv;
  avahi = INF_DISCOVERY_AVAHI(object);
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
  g_free(priv-&gt;sasl_mechanisms);
  G_OBJECT_CLASS(inf_discovery_avahi_parent_class)-&gt;finalize(object);
}
static void
inf_discovery_avahi_set_property(GObject* object,
                                 guint prop_id,
                                 const GValue* value,
                                 GParamSpec* pspec)
{
  InfDiscoveryAvahi* avahi;
  InfDiscoveryAvahiPrivate* priv;
  avahi = INF_DISCOVERY_AVAHI(object);
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
  switch(prop_id)
  {
  case PROP_IO:
    g_assert(priv-&gt;io == NULL);     priv-&gt;io = INF_IO(g_value_dup_object(value));
    break;
  case PROP_XMPP_MANAGER:
    g_assert(priv-&gt;xmpp_manager == NULL);     priv-&gt;xmpp_manager = INF_XMPP_MANAGER(g_value_dup_object(value));
    break;
  case PROP_CREDENTIALS:
    if(priv-&gt;creds != NULL) inf_certificate_credentials_unref(priv-&gt;creds);
    priv-&gt;creds = (InfCertificateCredentials*)g_value_dup_boxed(value);
    break;
  case PROP_SASL_CONTEXT:
    priv-&gt;sasl_context = (InfSaslContext*)g_value_dup_boxed(value);
    break;
  case PROP_SASL_MECHANISMS:
    g_free(priv-&gt;sasl_mechanisms);
    priv-&gt;sasl_mechanisms = g_value_dup_string(value);
    break;
  case PROP_SECURITY_POLICY:
    priv-&gt;security_policy = g_value_get_enum(value);
    break;
<a name="0"></a>  case PROP_KEEPALIVE:
    g_assert(g_value_get_boxed(value) != NULL);
    priv-&gt;keepalive = *(const InfKeepalive*)g_value_get_boxed(value);
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_discovery_avahi_get_property(GObject* object,
                                 guint prop_id,
                                 GValue* value,
                                 GParamSpec* pspec)
{
  InfDiscoveryAvahi* avahi;
  InfDiscoveryAvahiPrivate* priv;
  avahi = INF_DISCOVERY_AVAHI(object);
  priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
  switch(prop_id)
  {
  case PROP_IO:
    g_value_set_object(value, G_OBJECT(priv-&gt;io));
    break;</b></font>
  case PROP_XMPP_MANAGER:
    g_value_set_object(value, G_OBJECT(priv-&gt;xmpp_manager));
    break;
  case PROP_CREDENTIALS:
    g_value_set_boxed(value, priv-&gt;creds);
    break;
  case PROP_SASL_CONTEXT:
    g_value_set_boxed(value, priv-&gt;sasl_context);
    break;
  case PROP_SASL_MECHANISMS:
    g_value_set_string(value, priv-&gt;sasl_mechanisms);
    break;
  case PROP_SECURITY_POLICY:
    g_value_set_enum(value, priv-&gt;security_policy);
    break;
  case PROP_KEEPALIVE:
    g_value_set_boxed(value, &amp;priv-&gt;keepalive);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_discovery_avahi_discover(InfDiscovery* discovery,
                             const gchar* type)
{
  InfDiscoveryAvahiPrivate* priv;
  InfDiscoveryAvahiDiscoverInfo* info;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(discovery);
  info = g_hash_table_lookup(priv-&gt;discovered, type);
  if(info == NULL)
  {
    info = g_slice_new(InfDiscoveryAvahiDiscoverInfo);
    info-&gt;type = g_strdup(type);
    info-&gt;service_browser = NULL;
    info-&gt;discovered = NULL;
    g_hash_table_insert(priv-&gt;discovered, info-&gt;type, info);
    if(priv-&gt;client != NULL &amp;&amp;
       avahi_client_get_state(priv-&gt;client) == AVAHI_CLIENT_S_RUNNING)
    {
      inf_discovery_avahi_perform_discover(
        INF_DISCOVERY_AVAHI(discovery),
        info
      );
    }
  }
}
static GSList*
inf_discovery_avahi_get_discovered(InfDiscovery* discovery,
                                   const gchar* type)
{
  InfDiscoveryAvahiPrivate* priv;
  InfDiscoveryAvahiDiscoverInfo* info;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(discovery);
  info = g_hash_table_lookup(priv-&gt;discovered, type);
  if(info == NULL) return NULL;
  return g_slist_copy(info-&gt;discovered);
}
static void
inf_discovery_avahi_resolve(InfDiscovery* discovery,
                            InfDiscoveryInfo* info,
                            InfDiscoveryResolvCompleteFunc complete_func,
                            gpointer user_data)
{
  InfDiscoveryAvahiPrivate* priv;
  InfDiscoveryAvahiInfoResolv* resolv;
  InfXmlConnectionStatus status;
  int errno;
  GError* error;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(discovery);
  g_assert(priv-&gt;client != NULL);
  g_assert(avahi_client_get_state(priv-&gt;client) == AVAHI_CLIENT_S_RUNNING);
  if(info-&gt;resolved != NULL)
  {
    g_object_get(G_OBJECT(info-&gt;resolved), "status", &amp;status, NULL);
    switch(status)
    {
    case INF_XML_CONNECTION_CLOSED:
      error = NULL;
      if(!inf_xml_connection_open(INF_XML_CONNECTION(info-&gt;resolved), &amp;error))
      {
        complete_func(info, NULL, error, user_data);
        g_error_free(error);
      }
      else
      {
        complete_func(
          info,
          INF_XML_CONNECTION(info-&gt;resolved),
          NULL,
          user_data
        );
      }
      break;
    case INF_XML_CONNECTION_CLOSING:
      complete_func(info, NULL, NULL, user_data);
      break;
    case INF_XML_CONNECTION_OPENING:
    case INF_XML_CONNECTION_OPEN:
      complete_func(
        info,
        INF_XML_CONNECTION(info-&gt;resolved),
        NULL,
        user_data
      );
      break;
    default:
      g_assert_not_reached();
      break;
    }
  }
  else
  {
    resolv = g_slice_new(InfDiscoveryAvahiInfoResolv);
    resolv-&gt;complete_func = complete_func;
    resolv-&gt;user_data = user_data;
    info-&gt;resolv = g_slist_prepend(info-&gt;resolv, resolv);
    if(info-&gt;service_resolver == NULL)
    {
      info-&gt;service_resolver = avahi_service_resolver_new(
        priv-&gt;client,
        info-&gt;interface,
        info-&gt;protocol,
        info-&gt;service_name,
        info-&gt;service_type,
        info-&gt;domain,
        AVAHI_PROTO_UNSPEC,
        0,
        inf_discovery_avahi_service_resolver_callback,
        discovery
      );
      if(info-&gt;service_resolver == NULL)
      {
        error = NULL;
        errno = avahi_client_errno(
          avahi_service_resolver_get_client(info-&gt;service_resolver)
        );
        g_set_error_literal(
          &amp;error,
          inf_discovery_avahi_error_quark,
          errno,
          avahi_strerror(errno)
        );
        inf_discovery_avahi_info_resolv_error(info, error);
        g_error_free(error);
      }
    }
  }
}
static gchar*
inf_discovery_avahi_info_get_service_name(InfDiscovery* discovery,
                                          InfDiscoveryInfo* info)
{
  char device_name[IF_NAMESIZE];
  if(if_indextoname(info-&gt;interface, device_name) == NULL)
    return NULL;
  return g_strdup_printf(
    info-&gt;protocol == AVAHI_PROTO_INET ?
      _("%s (via %s on IPv4)") :
      _("%s (via %s on IPv6)"),
    info-&gt;service_name,
    device_name
  );
}
static const gchar*
inf_discovery_avahi_info_get_service_type(InfDiscovery* discovery,
                                          InfDiscoveryInfo* info)
{
  return info-&gt;service_type;
}
static InfLocalPublisherItem*
inf_discovery_avahi_publish(InfLocalPublisher* publisher,
                            const gchar* type,
                            const gchar* name,
                            guint port)
{
  InfDiscoveryAvahiPrivate* priv;
  InfLocalPublisherItem* item;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(publisher);
  item = g_slice_new(InfLocalPublisherItem);
  item-&gt;type = g_strdup(type);
  item-&gt;name = avahi_strdup(name);
  item-&gt;port = port;
  item-&gt;entry_group = NULL;
  priv-&gt;published = g_slist_prepend(priv-&gt;published, item);
  if(priv-&gt;client != NULL &amp;&amp;
     avahi_client_get_state(priv-&gt;client) == AVAHI_CLIENT_S_RUNNING)
  {
    inf_discovery_avahi_perform_publish_item(
      INF_DISCOVERY_AVAHI(publisher),
      item
    );
  }
  return item;
}
static void
inf_discovery_avahi_unpublish(InfLocalPublisher* publisher,
                              InfLocalPublisherItem* item)
{
  InfDiscoveryAvahiPrivate* priv;
  priv = INF_DISCOVERY_AVAHI_PRIVATE(publisher);
  g_assert(g_slist_find(priv-&gt;published, item) != NULL);
  inf_discovery_avahi_publisher_item_free(item);
  priv-&gt;published = g_slist_remove(priv-&gt;published, item);
}
static void
inf_discovery_avahi_class_init(InfDiscoveryAvahiClass* avahi_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(avahi_class);
  object_class-&gt;constructed = inf_discovery_avahi_constructed;
  object_class-&gt;dispose = inf_discovery_avahi_dispose;
  object_class-&gt;finalize = inf_discovery_avahi_finalize;
  object_class-&gt;set_property = inf_discovery_avahi_set_property;
  object_class-&gt;get_property = inf_discovery_avahi_get_property;
  inf_discovery_avahi_error_quark = g_quark_from_static_string(
    "INF_DISCOVERY_AVAHI_ERROR"
  );
  g_object_class_install_property(
    object_class,
    PROP_IO,
    g_param_spec_object(
      "io",
      "IO",
      "The IO object used for watching sockets and timeouts",
      INF_TYPE_IO,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_XMPP_MANAGER,
    g_param_spec_object(
      "xmpp-manager",
      "XMPP manager",
      "The XMPP manager to register resolved XMPP connections",
      INF_TYPE_XMPP_MANAGER,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_CREDENTIALS,
    g_param_spec_boxed(
      "credentials",
      "Certificate credentials",
      "The GnuTLS certificate credentials used for encrypting XMPP streams",
      INF_TYPE_CERTIFICATE_CREDENTIALS,
      G_PARAM_READWRITE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SASL_CONTEXT,
    g_param_spec_boxed(
      "sasl-context",
      "SASL context",
      "The SASL context used for authentication",
      INF_TYPE_SASL_CONTEXT,
      G_PARAM_READWRITE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SASL_MECHANISMS,
    g_param_spec_string(
      "sasl-mechanisms",
      "SASL mechanisms",
      "The accepted SASL mechanisms for authentication",
      NULL,
      G_PARAM_READWRITE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SECURITY_POLICY,
    g_param_spec_enum(
      "security-policy",
      "Security policy",
      "How to decide whether to use TLS",
      INF_TYPE_XMPP_CONNECTION_SECURITY_POLICY,
      INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS,
      G_PARAM_READWRITE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_KEEPALIVE,
    g_param_spec_boxed(
      "keepalive",
      "Keepalive",
      "The keepalive settings for new connections",
      INF_TYPE_KEEPALIVE,
      G_PARAM_READWRITE
    )
  );
}
static void
inf_discovery_avahi_discovery_iface_init(InfDiscoveryInterface* iface)
{
  iface-&gt;discover = inf_discovery_avahi_discover;
  iface-&gt;get_discovered = inf_discovery_avahi_get_discovered;
  iface-&gt;resolve = inf_discovery_avahi_resolve;
  iface-&gt;info_get_service_name = inf_discovery_avahi_info_get_service_name;
  iface-&gt;info_get_service_type = inf_discovery_avahi_info_get_service_type;
  iface-&gt;discovered = NULL;
  iface-&gt;undiscovered = NULL;
}
static void
inf_discovery_avahi_local_publisher_iface_init(
  InfLocalPublisherInterface* iface)
{
  iface-&gt;publish = inf_discovery_avahi_publish;
  iface-&gt;unpublish = inf_discovery_avahi_unpublish;
}
InfDiscoveryAvahi*
inf_discovery_avahi_new(InfIo* io,
                        InfXmppManager* manager,
                        InfCertificateCredentials* creds,
                        InfSaslContext* sasl_context,
                        const gchar* sasl_mechanisms)
{
  GObject* object;
  g_return_val_if_fail(INF_IS_IO(io), NULL);
  g_return_val_if_fail(INF_IS_XMPP_MANAGER(manager), NULL);
  object = g_object_new(
    INF_TYPE_DISCOVERY_AVAHI,
    "io", io,
    "xmpp-manager", manager,
    "credentials", creds,
    "sasl-context", sasl_context,
    "sasl-mechanisms", sasl_mechanisms,
    NULL
  );
  return INF_DISCOVERY_AVAHI(object);
}
void
inf_discovery_avahi_set_security_policy(InfDiscoveryAvahi* discovery,
                                        InfXmppConnectionSecurityPolicy plcy)
{
  g_return_if_fail(INF_IS_DISCOVERY_AVAHI(discovery));
  INF_DISCOVERY_AVAHI_PRIVATE(discovery)-&gt;security_policy = plcy;
}
InfXmppConnectionSecurityPolicy
inf_discovery_avahi_get_security_policy(InfDiscoveryAvahi* discovery)
{
  g_return_val_if_fail(
    INF_IS_DISCOVERY_AVAHI(discovery),
    INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS
  );
  return INF_DISCOVERY_AVAHI_PRIVATE(discovery)-&gt;security_policy;
}
void
inf_discovery_avahi_set_keepalive(InfDiscoveryAvahi* discovery,
                                  const InfKeepalive* keepalive)
{
  g_return_if_fail(INF_IS_DISCOVERY_AVAHI(discovery));
  g_return_if_fail(keepalive != NULL);
  INF_DISCOVERY_AVAHI_PRIVATE(discovery)-&gt;keepalive = *keepalive;
}
const InfKeepalive*
inf_discovery_avahi_get_keepalive(InfDiscoveryAvahi* discovery)
{
  g_return_val_if_fail(INF_IS_DISCOVERY_AVAHI(discovery), NULL);
  return &amp;INF_DISCOVERY_AVAHI_PRIVATE(discovery)-&gt;keepalive;
}
#endif 
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
