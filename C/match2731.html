<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-gtk-connection-view.c &amp; inf-discovery-avahi.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-gtk-connection-view.c &amp; inf-discovery-avahi.c
      </h3>
<h1 align="center">
        2.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-gtk-connection-view.c (6.060606%)<th>inf-discovery-avahi.c (1.55902%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(437-460)<td><a href="#" name="0">(1253-1276)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-gtk-connection-view.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfgtk/inf-gtk-connection-view.h&gt;
2 #include &lt;libinfgtk/inf-gtk-certificate-view.h&gt;
3 #include &lt;libinfinity/common/inf-cert-util.h&gt;
4 #include &lt;libinfinity/inf-signals.h&gt;
5 #include &lt;libinfinity/inf-i18n.h&gt;
6 #include &lt;gnutls/x509.h&gt;
7 typedef struct _InfGtkConnectionViewPrivate InfGtkConnectionViewPrivate;
8 struct _InfGtkConnectionViewPrivate {
9   InfXmppConnection* connection;
10   GtkWidget* remote_hostname;
11   GtkWidget* remote_ipaddress;
12   GtkWidget* local_ipaddress;
13   GtkWidget* tls_version;
14   GtkWidget* cipher_suite;
15   GtkWidget* dh_prime_bits;
16   GtkTreeStore* certificate_store;
17   GtkWidget* certificate_expander;
18   GtkWidget* certificate_tree_view;
19   GtkWidget* certificate_info_view;
20   GtkCellRenderer* text_renderer;
21 };
22 enum {
23   PROP_0,
24   PROP_CONNECTION
25 };
26 #define INF_GTK_CONNECTION_VIEW_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_GTK_TYPE_CONNECTION_VIEW, InfGtkConnectionViewPrivate))
27 G_DEFINE_TYPE_WITH_CODE(InfGtkConnectionView, inf_gtk_connection_view, GTK_TYPE_GRID,
28   G_ADD_PRIVATE(InfGtkConnectionView))
29 static gchar*
30 inf_gtk_connection_view_format_ipaddress(InfIpAddress* address,
31                                          guint port)
32 {
33   gchar* out;
34   gchar* str;
35   str = inf_ip_address_to_string(address);
36   switch(inf_ip_address_get_family(address))
37   {
38   case INF_IP_ADDRESS_IPV4:
39     out = g_strdup_printf("%s:%u", str, port);
40     break;
41   case INF_IP_ADDRESS_IPV6:
42     out = g_strdup_printf("[%s]:%u", str, port);
43     break;
44   default:
45     g_assert_not_reached();
46     out = NULL;
47     break;
48   }
49   g_free(str);
50   return out;
51 }
52 static void
53 inf_gtk_connection_view_set_chain(InfGtkConnectionView* view,
54                                   InfCertificateChain* chain)
55 {
56   InfGtkConnectionViewPrivate* priv;
57   guint i;
58   gnutls_x509_crt_t crt;
59   GtkTreeIter prev_row;
60   GtkTreeIter new_row;
61   GtkTreeIter* parent;
62   GtkTreePath* path;
63   priv = INF_GTK_CONNECTION_VIEW_PRIVATE(view);
64   gtk_tree_store_clear(priv-&gt;certificate_store);
65   inf_gtk_certificate_view_set_certificate(
66     INF_GTK_CERTIFICATE_VIEW(priv-&gt;certificate_info_view),
67     NULL
68   );
69   parent = NULL;
70   if(chain != NULL)
71   {
72     for(i = inf_certificate_chain_get_n_certificates(chain); i &gt; 0; -- i)
73     {
74       crt = inf_certificate_chain_get_nth_certificate(chain, i - 1);
75       gtk_tree_store_append(priv-&gt;certificate_store, &amp;new_row, parent);
76       gtk_tree_store_set(priv-&gt;certificate_store, &amp;new_row, 0, crt, -1);
77       prev_row = new_row;
78       parent = &amp;prev_row;
79     }
80     path = gtk_tree_model_get_path(
81       GTK_TREE_MODEL(priv-&gt;certificate_store),
82       &amp;new_row
83     );
84     gtk_tree_view_expand_to_path(
85       GTK_TREE_VIEW(priv-&gt;certificate_tree_view),
86       path
87     );
88     gtk_tree_selection_select_path(
89       gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;certificate_tree_view)),
90       path
91     );
92     gtk_tree_view_scroll_to_cell(
93       GTK_TREE_VIEW(priv-&gt;certificate_tree_view),
94       path,
95       NULL,
96       FALSE,
97       0.0,
98       0.0
99     );
100     gtk_tree_path_free(path);
101     gtk_widget_show(priv-&gt;certificate_expander);
102   }
103   else
104   {
105     gtk_widget_hide(priv-&gt;certificate_expander);
106   }
107 }
108 static void
109 inf_gtk_connection_view_selection_changed_cb(GtkTreeSelection* selection,
110                                              gpointer user_data)
111 {
112   InfGtkConnectionView* view;
113   InfGtkConnectionViewPrivate* priv;
114   GtkTreeIter iter;
115   gnutls_x509_crt_t cert;
116   view = INF_GTK_CONNECTION_VIEW(user_data);
117   priv = INF_GTK_CONNECTION_VIEW_PRIVATE(view);
118   if(gtk_tree_selection_get_selected(selection, NULL, &amp;iter))
119   {
120     gtk_tree_model_get(
121       GTK_TREE_MODEL(priv-&gt;certificate_store),
122       &amp;iter,
123       0, &amp;cert,
124       -1
125     );
126     inf_gtk_certificate_view_set_certificate(
127       INF_GTK_CERTIFICATE_VIEW(priv-&gt;certificate_info_view),
128       cert
129     );
130   }
131   else
132   {
133     inf_gtk_certificate_view_set_certificate(
134       INF_GTK_CERTIFICATE_VIEW(priv-&gt;certificate_info_view),
135       NULL
136     );
137   }
138 }
139 static void
140 inf_gtk_connection_view_chain_data_func(GtkTreeViewColumn* column,
141                                         GtkCellRenderer* renderer,
142                                         GtkTreeModel* tree_model,
143                                         GtkTreeIter* iter,
144                                         gpointer user_data)
145 {
146   gpointer crt_ptr;
147   gnutls_x509_crt_t cert;
148   GValue value = { 0 };
149   gchar* common_name;
150   gtk_tree_model_get(tree_model, iter, 0, &amp;crt_ptr, -1);
151   cert = (gnutls_x509_crt_t)crt_ptr;
152   common_name =
153     inf_cert_util_get_dn_by_oid(cert, GNUTLS_OID_X520_COMMON_NAME, 0);
154   g_value_init(&amp;value, G_TYPE_STRING);
155   if(common_name != NULL)
156     g_value_take_string(&amp;value, common_name);
157   else
158     g_value_set_static_string(&amp;value, _("&lt;Unknown Certificate Holder&gt;"));
159   g_object_set_property(G_OBJECT(renderer), "text", &amp;value);
160   g_value_unset(&amp;value);
161 }
162 static void
163 inf_gtk_connection_view_update_connection_info(InfGtkConnectionView* view,
164                                                InfXmppConnection* connection)
165 {
166   InfGtkConnectionViewPrivate* priv;
167   InfTcpConnection* tcp;
168   InfIpAddress* remote_address;
169   guint remote_port;
170   InfIpAddress* local_address;
171   guint local_port;
172   gchar* text;
173   const gchar* cs;
174   gnutls_kx_algorithm_t kx;
175   gnutls_cipher_algorithm_t cipher;
176   gnutls_mac_algorithm_t mac;
177   gnutls_protocol_t ver;
178   guint dh_prime_bits;
179   priv = INF_GTK_CONNECTION_VIEW_PRIVATE(view);
180   if(connection == NULL)
181   {
182     gtk_label_set_text(GTK_LABEL(priv-&gt;remote_hostname), NULL);
183     gtk_label_set_text(GTK_LABEL(priv-&gt;remote_ipaddress), NULL);
184     gtk_label_set_text(GTK_LABEL(priv-&gt;local_ipaddress), NULL);
185     gtk_label_set_text(GTK_LABEL(priv-&gt;tls_version), NULL);
186     gtk_label_set_text(GTK_LABEL(priv-&gt;cipher_suite), NULL);
187     gtk_label_set_text(GTK_LABEL(priv-&gt;dh_prime_bits), NULL);
188     inf_gtk_connection_view_set_chain(view, NULL);
189   }
190   else
191   {
192     g_object_get(G_OBJECT(connection), "remote-hostname", &amp;text, NULL);
193     if(text != NULL)
194     {
195       gtk_label_set_text(GTK_LABEL(priv-&gt;remote_hostname), text);
196     }
197     else
198     {
199       text = g_markup_printf_escaped("&lt;i&gt;%s&lt;/i&gt;", _("Unknown"));
200       gtk_label_set_markup(GTK_LABEL(priv-&gt;remote_hostname), text);
201     }
202     g_free(text);
203     g_object_get(G_OBJECT(connection), "tcp-connection", &amp;tcp, NULL);
204     g_object_get(
205       G_OBJECT(tcp),
206       "remote-address", &amp;remote_address,
207       "remote-port", &amp;remote_port,
208       "local-address", &amp;local_address,
209       "local-port", &amp;local_port,
210       NULL
211     );
212     g_object_unref(tcp);
213     text = inf_gtk_connection_view_format_ipaddress(
214       remote_address,
215       remote_port
216     );
217     gtk_label_set_text(GTK_LABEL(priv-&gt;remote_ipaddress), text);
218     g_free(text);
219     text = inf_gtk_connection_view_format_ipaddress(
220       local_address,
221       local_port
222     );
223     gtk_label_set_text(GTK_LABEL(priv-&gt;local_ipaddress), text);
224     g_free(text);
225     inf_ip_address_free(remote_address);
226     inf_ip_address_free(local_address);
227     if(inf_xmpp_connection_get_tls_enabled(connection))
228     {
229       kx = inf_xmpp_connection_get_kx_algorithm(connection);
230       cipher = inf_xmpp_connection_get_cipher_algorithm(connection);
231       mac = inf_xmpp_connection_get_mac_algorithm(connection);
232       ver = inf_xmpp_connection_get_tls_protocol(connection);
233       dh_prime_bits = inf_xmpp_connection_get_dh_prime_bits(connection);
234       gtk_label_set_text(
235         GTK_LABEL(priv-&gt;tls_version),
236         gnutls_protocol_get_name(ver)
237       );
238       cs = gnutls_cipher_suite_get_name(kx, cipher, mac);
239       if(ver == GNUTLS_SSL3)
240         text = g_strdup_printf("SSL_%s", cs);
241       else
242         text = g_strdup_printf("TLS_%s", cs);
243       gtk_label_set_text(GTK_LABEL(priv-&gt;cipher_suite), text);
244       g_free(text);
245       if(dh_prime_bits &gt; 0)
246       {
247         text = g_markup_printf_escaped("%u bit", dh_prime_bits);
248         gtk_label_set_text(GTK_LABEL(priv-&gt;dh_prime_bits), text);
249       }
250       else
251       {
252         text = g_markup_printf_escaped("&lt;i&gt;%s&lt;/i&gt;", _("N/A"));
253         gtk_label_set_markup(GTK_LABEL(priv-&gt;dh_prime_bits), text);
254       }
255       g_free(text);
256       inf_gtk_connection_view_set_chain(
257         view,
258         inf_xmpp_connection_get_peer_certificate(connection)
259       );
260     }
261     else
262     {
263       text = g_markup_printf_escaped("&lt;i&gt;%s&lt;/i&gt;", _("No Encryption"));
264       gtk_label_set_markup(GTK_LABEL(priv-&gt;tls_version), text);
265       g_free(text);
266       text = g_markup_printf_escaped("&lt;i&gt;%s&lt;/i&gt;", _("N/A"));
267       gtk_label_set_markup(GTK_LABEL(priv-&gt;cipher_suite), text);
268       gtk_label_set_markup(GTK_LABEL(priv-&gt;dh_prime_bits), text);
269       g_free(text);
270       inf_gtk_connection_view_set_chain(view, NULL);
271     }
272   }
273 }
274 static void
275 inf_gtk_connection_view_notify_tls_enabled_cb(GObject* object,
276                                               GParamSpec* pspec,
277                                               gpointer user_data)
278 {
279   InfGtkConnectionView* view;
280   InfGtkConnectionViewPrivate* priv;
281   view = INF_GTK_CONNECTION_VIEW(user_data);
282   priv = INF_GTK_CONNECTION_VIEW_PRIVATE(view);
283   g_assert(priv-&gt;connection != NULL);
284   inf_gtk_connection_view_update_connection_info(view, priv-&gt;connection);
285 }
286 static void
287 inf_gtk_connection_view_notify_credentials_cb(GObject* object,
288                                               GParamSpec* pspec,
289                                               gpointer user_data)
290 {
291   InfGtkConnectionView* view;
292   InfGtkConnectionViewPrivate* priv;
293   view = INF_GTK_CONNECTION_VIEW(user_data);
294   priv = INF_GTK_CONNECTION_VIEW_PRIVATE(view);
295   g_assert(priv-&gt;connection != NULL);
296   inf_gtk_connection_view_update_connection_info(view, priv-&gt;connection);
297 }
298 static void
299 inf_gtk_connection_view_init(InfGtkConnectionView* view)
300 {
301   InfGtkConnectionViewPrivate* priv;
302   priv = INF_GTK_CONNECTION_VIEW_PRIVATE(view);
303   priv-&gt;connection = NULL;
304   gtk_widget_init_template(GTK_WIDGET(view));
305   gtk_tree_selection_set_mode(
306     gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;certificate_tree_view)),
307     GTK_SELECTION_BROWSE
308   );
309   gtk_tree_view_column_set_cell_data_func(
310     gtk_tree_view_get_column(GTK_TREE_VIEW(priv-&gt;certificate_tree_view), 0),
311     priv-&gt;text_renderer,
312     inf_gtk_connection_view_chain_data_func,
313     NULL,
314     NULL
315   );
316 }
317 static void
318 inf_gtk_connection_view_set_property(GObject* object,
319                                      guint prop_id,
320                                      const GValue* value,
321                                      GParamSpec* pspec)
322 {
323   InfGtkConnectionView* view;
324   InfGtkConnectionViewPrivate* priv;
325   view = INF_GTK_CONNECTION_VIEW(object);
326   priv = INF_GTK_CONNECTION_VIEW_PRIVATE(view);
327   switch(prop_id)
328 <a name="0"></a>  {
329   case PROP_CONNECTION:
330     inf_gtk_connection_view_set_connection(view, INF_XMPP_CONNECTION(value));
331 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
332   default:
333     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
334     break;
335   }
336 }
337 static void
338 inf_gtk_connection_view_get_property(GObject* object,
339                                      guint prop_id,
340                                      GValue* value,
341                                      GParamSpec* pspec)
342 {
343   InfGtkConnectionView* view;
344   InfGtkConnectionViewPrivate* priv;
345   view = INF_GTK_CONNECTION_VIEW(object);
346   priv = INF_GTK_CONNECTION_VIEW_PRIVATE(view);
347   switch(prop_id)
348   {
349   case PROP_CONNECTION:
350     g_value_set_object(value, priv-&gt;connection);
351     break;</b></font>
352   default:
353     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
354     break;
355   }
356 }
357 static void
358 inf_gtk_connection_view_dispose(GObject* object)
359 {
360   InfGtkConnectionView* view;
361   InfGtkConnectionViewPrivate* priv;
362   view = INF_GTK_CONNECTION_VIEW(object);
363   priv = INF_GTK_CONNECTION_VIEW_PRIVATE(view);
364   if(priv-&gt;connection != NULL)
365     inf_gtk_connection_view_set_connection(view, NULL);
366   G_OBJECT_CLASS(inf_gtk_connection_view_parent_class)-&gt;dispose(object);
367 }
368 static void
369 inf_gtk_connection_view_class_init(
370   InfGtkConnectionViewClass* connection_view_class)
371 {
372   GObjectClass* object_class;
373   object_class = G_OBJECT_CLASS(connection_view_class);
374   object_class-&gt;set_property = inf_gtk_connection_view_set_property;
375   object_class-&gt;get_property = inf_gtk_connection_view_get_property;
376   object_class-&gt;dispose = inf_gtk_connection_view_dispose;
377   gtk_widget_class_set_template_from_resource(
378     GTK_WIDGET_CLASS(connection_view_class),
379     "/de/0x539/libinfgtk/ui/infgtkconnectionview.ui"
380   );
381   gtk_widget_class_bind_template_child_private(
382     GTK_WIDGET_CLASS(object_class),
383     InfGtkConnectionView,
384     certificate_store
385   );
386   gtk_widget_class_bind_template_child_private(
387     GTK_WIDGET_CLASS(connection_view_class),
388     InfGtkConnectionView,
389     remote_hostname
390   );
391   gtk_widget_class_bind_template_child_private(
392     GTK_WIDGET_CLASS(connection_view_class),
393     InfGtkConnectionView,
394     remote_ipaddress
395   );
396   gtk_widget_class_bind_template_child_private(
397     GTK_WIDGET_CLASS(connection_view_class),
398     InfGtkConnectionView,
399     local_ipaddress
400   );
401   gtk_widget_class_bind_template_child_private(
402     GTK_WIDGET_CLASS(connection_view_class),
403     InfGtkConnectionView,
404     tls_version
405   );
406   gtk_widget_class_bind_template_child_private(
407     GTK_WIDGET_CLASS(connection_view_class),
408     InfGtkConnectionView,
409     cipher_suite
410   );
411   gtk_widget_class_bind_template_child_private(
412     GTK_WIDGET_CLASS(connection_view_class),
413     InfGtkConnectionView,
414     dh_prime_bits
415   );
416   gtk_widget_class_bind_template_child_private(
417     GTK_WIDGET_CLASS(object_class),
418     InfGtkConnectionView,
419     certificate_expander
420   );
421   gtk_widget_class_bind_template_child_private(
422     GTK_WIDGET_CLASS(object_class),
423     InfGtkConnectionView,
424     certificate_tree_view
425   );
426   gtk_widget_class_bind_template_child_private(
427     GTK_WIDGET_CLASS(object_class),
428     InfGtkConnectionView,
429     certificate_info_view
430   );
431   gtk_widget_class_bind_template_child_private(
432     GTK_WIDGET_CLASS(object_class),
433     InfGtkConnectionView,
434     text_renderer
435   );
436   gtk_widget_class_bind_template_callback(
437     GTK_WIDGET_CLASS(object_class),
438     inf_gtk_connection_view_selection_changed_cb
439   );
440   g_object_class_install_property(
441     object_class,
442     PROP_CONNECTION,
443     g_param_spec_object(
444       "connection",
445       "Connection",
446       "Connection for which to show parameters",
447       INF_TYPE_XMPP_CONNECTION,
448       G_PARAM_READWRITE
449     )
450   );
451 }
452 GtkWidget*
453 inf_gtk_connection_view_new(void)
454 {
455   GObject* object;
456   object = g_object_new(INF_GTK_TYPE_CONNECTION_VIEW, NULL);
457   return GTK_WIDGET(object);
458 }
459 GtkWidget*
460 inf_gtk_connection_view_new_with_connection(InfXmppConnection* connection)
461 {
462   GObject* object;
463   g_return_val_if_fail(
464     connection == NULL || INF_IS_XMPP_CONNECTION(connection),
465     NULL
466   );
467   object = g_object_new(
468     INF_GTK_TYPE_CONNECTION_VIEW,
469     "connection", connection,
470     NULL
471   );
472   return GTK_WIDGET(object);
473 }
474 void
475 inf_gtk_connection_view_set_connection(InfGtkConnectionView* view,
476                                        InfXmppConnection* connection)
477 {
478   InfGtkConnectionViewPrivate* priv;
479   g_return_if_fail(INF_GTK_IS_CONNECTION_VIEW(view));
480   g_return_if_fail(connection == NULL || INF_IS_XMPP_CONNECTION(connection));
481   priv = INF_GTK_CONNECTION_VIEW_PRIVATE(view);
482   if(priv-&gt;connection != NULL)
483   {
484     inf_signal_handlers_disconnect_by_func(
485       G_OBJECT(priv-&gt;connection),
486       G_CALLBACK(inf_gtk_connection_view_notify_tls_enabled_cb),
487       view
488     );
489     inf_signal_handlers_disconnect_by_func(
490       G_OBJECT(priv-&gt;connection),
491       G_CALLBACK(inf_gtk_connection_view_notify_credentials_cb),
492       view
493     );
494     g_object_unref(priv-&gt;connection);
495   }
496   priv-&gt;connection = connection;
497   if(connection != NULL)
498   {
499     g_object_ref(connection);
500     g_signal_connect(
501       G_OBJECT(connection),
502       "notify::tls-enabled",
503       G_CALLBACK(inf_gtk_connection_view_notify_tls_enabled_cb),
504       view
505     );
506     g_signal_connect(
507       G_OBJECT(connection),
508       "notify::credentials",
509       G_CALLBACK(inf_gtk_connection_view_notify_credentials_cb),
510       view
511     );
512   }
513   inf_gtk_connection_view_update_connection_info(view, connection);
514   g_object_notify(G_OBJECT(view), "connection");
515 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-discovery-avahi.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/common/inf-discovery-avahi.h&gt;
2 #include &lt;libinfinity/common/inf-discovery.h&gt;
3 #include &lt;libinfinity/common/inf-local-publisher.h&gt;
4 #include &lt;libinfinity/inf-i18n.h&gt;
5 #include &lt;libinfinity/inf-config.h&gt; 
6 #ifdef LIBINFINITY_HAVE_AVAHI
7 #include &lt;avahi-client/client.h&gt;
8 #include &lt;avahi-client/lookup.h&gt;
9 #include &lt;avahi-client/publish.h&gt;
10 #include &lt;avahi-common/watch.h&gt;
11 #include &lt;avahi-common/malloc.h&gt;
12 #include &lt;avahi-common/timeval.h&gt;
13 #include &lt;avahi-common/alternative.h&gt;
14 #include &lt;avahi-common/error.h&gt;
15 #include &lt;sys/socket.h&gt; #include &lt;net/if.h&gt; #include &lt;string.h&gt;
16 struct AvahiWatch {
17   InfDiscoveryAvahi* avahi;
18   InfIoWatch* watch;
19   InfNativeSocket socket;
20   AvahiWatchEvent occurred_events;
21   AvahiWatchCallback callback;
22   void* userdata;
23 };
24 struct AvahiTimeout {
25   InfDiscoveryAvahi* avahi;
26   InfIoTimeout* timeout;
27   AvahiTimeoutCallback callback;
28   void* userdata;
29 };
30 typedef struct _InfDiscoveryAvahiInfoResolv InfDiscoveryAvahiInfoResolv;
31 struct _InfDiscoveryAvahiInfoResolv {
32   InfDiscoveryResolvCompleteFunc complete_func;
33   gpointer user_data;
34 };
35 struct _InfDiscoveryInfo {
36   gchar* service_name;
37   const gchar* service_type;
38   gchar* domain;
39   AvahiIfIndex interface;
40   AvahiProtocol protocol;
41   AvahiServiceResolver* service_resolver;
42   InfXmppConnection* resolved;
43   GSList* resolv;
44 };
45 struct _InfLocalPublisherItem {
46   gchar* type;
47   char* name;
48   guint port;
49   AvahiEntryGroup* entry_group;
50 };
51 typedef struct _InfDiscoveryAvahiDiscoverInfo InfDiscoveryAvahiDiscoverInfo;
52 struct _InfDiscoveryAvahiDiscoverInfo {
53   gchar* type;   AvahiServiceBrowser* service_browser;
54   GSList* discovered;
55 };
56 typedef struct _InfDiscoveryAvahiPrivate InfDiscoveryAvahiPrivate;
57 struct _InfDiscoveryAvahiPrivate {
58   AvahiPoll poll;
59   InfIo* io;
60   InfXmppManager* xmpp_manager;
61   InfXmppConnectionSecurityPolicy security_policy;
62   InfKeepalive keepalive;
63   InfCertificateCredentials* creds;
64   InfSaslContext* sasl_context;
65   gchar* sasl_mechanisms;
66   AvahiClient* client;
67   GSList* published;
68   GHashTable* discovered; };
69 enum {
70   PROP_0,
71   PROP_XMPP_MANAGER,
72   PROP_IO,
73   PROP_CREDENTIALS,
74   PROP_SASL_CONTEXT,
75   PROP_SASL_MECHANISMS,
76   PROP_SECURITY_POLICY,
77   PROP_KEEPALIVE
78 };
79 #define INF_DISCOVERY_AVAHI_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_DISCOVERY_AVAHI, InfDiscoveryAvahiPrivate))
80 static GQuark inf_discovery_avahi_error_quark;
81 static void inf_discovery_avahi_discovery_iface_init(InfDiscoveryInterface* iface);
82 static void inf_discovery_avahi_local_publisher_iface_init(InfLocalPublisherInterface* iface);
83 G_DEFINE_TYPE_WITH_CODE(InfDiscoveryAvahi, inf_discovery_avahi, G_TYPE_OBJECT,
84   G_ADD_PRIVATE(InfDiscoveryAvahi)
85   G_IMPLEMENT_INTERFACE(INF_TYPE_DISCOVERY, inf_discovery_avahi_discovery_iface_init)
86   G_IMPLEMENT_INTERFACE(INF_TYPE_LOCAL_PUBLISHER, inf_discovery_avahi_local_publisher_iface_init))
87 static void
88 inf_discovery_avahi_discovery_info_resolved_destroy_cb(gpointer user_data,
89                                                        GObject* object)
90 {
91   InfDiscoveryInfo* info;
92   info = (InfDiscoveryInfo*)user_data;
93   info-&gt;resolved = NULL;
94 }
95 static void
96 inf_discovery_avahi_info_resolv_complete(InfDiscoveryInfo* info)
97 {
98   GSList* item;
99   InfDiscoveryAvahiInfoResolv* resolv;
100   g_assert(info-&gt;resolved != NULL);
101   for(item = info-&gt;resolv; item != NULL; item = g_slist_next(item))
102   {
103     resolv = (InfDiscoveryAvahiInfoResolv*)item-&gt;data;
104     resolv-&gt;complete_func(
105       info,
106       INF_XML_CONNECTION(info-&gt;resolved),
107       NULL,
108       resolv-&gt;user_data
109     );
110     g_slice_free(InfDiscoveryAvahiInfoResolv, resolv);
111   }
112   g_slist_free(info-&gt;resolv);
113   info-&gt;resolv = NULL;
114 }
115 static void
116 inf_discovery_avahi_info_resolv_error(InfDiscoveryInfo* info,
117                                       const GError* error)
118 {
119   GSList* item;
120   InfDiscoveryAvahiInfoResolv* resolv;
121   for(item = info-&gt;resolv; item != NULL; item = g_slist_next(item))
122   {
123     resolv = (InfDiscoveryAvahiInfoResolv*)item-&gt;data;
124     resolv-&gt;complete_func(info, NULL, error, resolv-&gt;user_data);
125     g_slice_free(InfDiscoveryAvahiInfoResolv, resolv);
126   }
127   g_slist_free(info-&gt;resolv);
128   info-&gt;resolv = NULL;
129 }
130 static void
131 inf_discovery_avahi_discovery_info_free(InfDiscoveryInfo* info)
132 {
133   g_free(info-&gt;service_name);
134   g_free(info-&gt;domain);
135   if(info-&gt;service_resolver != NULL)
136     avahi_service_resolver_free(info-&gt;service_resolver);
137   if(info-&gt;resolved != NULL)
138   {
139     g_object_weak_unref(
140       G_OBJECT(info-&gt;resolved),
141       inf_discovery_avahi_discovery_info_resolved_destroy_cb,
142       info
143     );
144   }
145   inf_discovery_avahi_info_resolv_error(info, NULL);
146   g_slist_free(info-&gt;resolv);
147   g_slice_free(InfDiscoveryInfo, info);
148 }
149 static void
150 inf_discovery_avahi_publisher_item_free(gpointer data)
151 {
152   InfLocalPublisherItem* item;
153   item = (InfLocalPublisherItem*)data;
154   if(item-&gt;entry_group != NULL)
155     avahi_entry_group_free(item-&gt;entry_group);
156   g_free(item-&gt;type);
157   avahi_free(item-&gt;name);
158   g_slice_free(InfLocalPublisherItem, item);
159 }
160 static void
161 inf_discovery_avahi_discover_info_free(gpointer data)
162 {
163   InfDiscoveryAvahiDiscoverInfo* info;
164   GSList* item;
165   info = (InfDiscoveryAvahiDiscoverInfo*)data;
166   for(item = info-&gt;discovered; item != NULL; item = g_slist_next(item))
167     inf_discovery_avahi_discovery_info_free((InfDiscoveryInfo*)item-&gt;data);
168   if(info-&gt;service_browser != NULL)
169     avahi_service_browser_free(info-&gt;service_browser);
170   g_slist_free(info-&gt;discovered);
171   g_free(info-&gt;type);
172   g_slice_free(InfDiscoveryAvahiDiscoverInfo, info);
173 }
174 static void
175 inf_discovery_avahi_service_resolver_callback(AvahiServiceResolver* resolver,
176                                               AvahiIfIndex interface,
177                                               AvahiProtocol protocol,
178                                               AvahiResolverEvent event,
179                                               const char* name,
180                                               const char* type,
181                                               const char* domain,
182                                               const char* host_name,
183                                               const AvahiAddress* address,
184                                               uint16_t port,
185                                               AvahiStringList* txt,
186                                               AvahiLookupResultFlags flags,
187                                               void* userdata)
188 {
189   InfDiscoveryAvahi* avahi;
190   InfDiscoveryAvahiPrivate* priv;
191   InfDiscoveryAvahiDiscoverInfo* info;
192   InfDiscoveryInfo* discovery_info;
193   GSList* item;
194   InfIpAddress* inf_addr;
195   InfTcpConnection* tcp;
196   InfXmppConnection* xmpp;
197   InfXmlConnectionStatus status;
198   GError* error;
199   avahi = INF_DISCOVERY_AVAHI(userdata);
200   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
201   info = g_hash_table_lookup(priv-&gt;discovered, type);
202   g_assert(info != NULL);
203   for(item = info-&gt;discovered; item != NULL; item = g_slist_next(item))
204   {
205     discovery_info = (InfDiscoveryInfo*)item-&gt;data;
206     if(discovery_info-&gt;service_resolver == resolver)
207       break;
208   }
209   g_assert(item != NULL);
210   g_assert(discovery_info-&gt;resolved == NULL);
211   discovery_info-&gt;service_resolver = NULL;
212   switch(event)
213   {
214   case AVAHI_RESOLVER_FOUND:
215     switch(address-&gt;proto)
216     {
217     case AVAHI_PROTO_INET:
218       inf_addr = inf_ip_address_new_raw4(address-&gt;data.ipv4.address);
219       break;
220     case AVAHI_PROTO_INET6:
221       inf_addr = inf_ip_address_new_raw6(address-&gt;data.ipv6.address);
222       break;
223     default:
224       g_assert_not_reached();
225       break;
226     }
227     xmpp = inf_xmpp_manager_lookup_connection_by_address(
228       priv-&gt;xmpp_manager,
229       inf_addr,
230       port
231     );
232     if(xmpp == NULL)
233     {
234       tcp = inf_tcp_connection_new(priv-&gt;io, inf_addr, port);
235       g_object_set(
236         G_OBJECT(tcp),
237         "device-index", discovery_info-&gt;interface,
238         NULL
239       );
240       error = NULL;
241       if(!inf_tcp_connection_set_keepalive(tcp, &amp;priv-&gt;keepalive, &amp;error) ||
242          !inf_tcp_connection_open(tcp, &amp;error))
243       {
244         inf_discovery_avahi_info_resolv_error(discovery_info, error);
245         g_error_free(error);
246         g_object_unref(tcp);
247       }
248       else
249       {
250         xmpp = inf_xmpp_connection_new(
251           tcp,
252           INF_XMPP_CONNECTION_CLIENT,
253           NULL,
254           host_name,
255           priv-&gt;security_policy,
256           priv-&gt;creds,
257           priv-&gt;sasl_context,
258           priv-&gt;sasl_context == NULL ? NULL : priv-&gt;sasl_mechanisms
259         );
260         g_object_unref(tcp);
261         inf_xmpp_manager_add_connection(priv-&gt;xmpp_manager, xmpp);
262         discovery_info-&gt;resolved = xmpp;
263         g_object_weak_ref(
264           G_OBJECT(xmpp),
265           inf_discovery_avahi_discovery_info_resolved_destroy_cb,
266           discovery_info
267         );
268         inf_discovery_avahi_info_resolv_complete(discovery_info);
269         g_object_unref(xmpp);
270       }
271     }
272     else
273     {
274       discovery_info-&gt;resolved = xmpp;
275       g_object_weak_ref(
276         G_OBJECT(xmpp),
277         inf_discovery_avahi_discovery_info_resolved_destroy_cb,
278         discovery_info
279       );
280       g_object_get(G_OBJECT(xmpp), "status", &amp;status, NULL);
281       if(status == INF_XML_CONNECTION_CLOSING)
282       {
283         inf_discovery_avahi_info_resolv_error(discovery_info, NULL);
284       }
285       else if(status == INF_XML_CONNECTION_CLOSED)
286       {
287         error = NULL;
288         if(!inf_xml_connection_open(INF_XML_CONNECTION(xmpp), &amp;error))
289         {
290           inf_discovery_avahi_info_resolv_error(discovery_info, error);
291           g_error_free(error);
292         }
293         else
294         {
295           inf_discovery_avahi_info_resolv_complete(discovery_info);
296         }
297       }
298       else
299       {
300         inf_discovery_avahi_info_resolv_complete(discovery_info);
301       }
302     }
303     inf_ip_address_free(inf_addr);
304     break;
305   case AVAHI_RESOLVER_FAILURE:
306     error = NULL;
307     g_set_error_literal(
308       &amp;error,
309       inf_discovery_avahi_error_quark,
310       avahi_client_errno(avahi_service_resolver_get_client(resolver)),
311       avahi_strerror(
312         avahi_client_errno(avahi_service_resolver_get_client(resolver))
313       )
314     );
315     inf_discovery_avahi_info_resolv_error(discovery_info, error);
316     g_error_free(error);
317     break;
318   }
319   avahi_service_resolver_free(resolver);
320 }
321 static void
322 inf_discovery_avahi_perform_undiscover(InfDiscoveryAvahi* avahi,
323                                        InfDiscoveryAvahiDiscoverInfo* info);
324 static void
325 inf_discovery_avahi_perform_unpublish_item(InfLocalPublisherItem* item);
326 static void
327 inf_discovery_avahi_service_browser_callback(AvahiServiceBrowser* browser,
328                                              AvahiIfIndex interface,
329                                              AvahiProtocol protocol,
330                                              AvahiBrowserEvent event,
331                                              const char* name,
332                                              const char* type,
333                                              const char* domain,
334                                              AvahiLookupResultFlags flags,
335                                              void* userdata)
336 {
337   InfDiscoveryAvahi* avahi;
338   InfDiscoveryAvahiPrivate* priv;
339   InfDiscoveryAvahiDiscoverInfo* info;
340   InfDiscoveryInfo* discovery_info;
341   GSList* item;
342   avahi = INF_DISCOVERY_AVAHI(userdata);
343   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
344   info = g_hash_table_lookup(priv-&gt;discovered, type);
345   g_assert(info != NULL);
346   switch(event)
347   {
348   case AVAHI_BROWSER_NEW:
349     if((flags &amp; AVAHI_LOOKUP_RESULT_OUR_OWN) == 0)
350     {
351       discovery_info = g_slice_new(InfDiscoveryInfo);
352       discovery_info-&gt;service_name = g_strdup(name);
353       discovery_info-&gt;service_type = info-&gt;type;
354       discovery_info-&gt;domain = g_strdup(domain);
355       discovery_info-&gt;interface = interface;
356       discovery_info-&gt;protocol = protocol;
357       discovery_info-&gt;service_resolver = NULL;
358       discovery_info-&gt;resolved = NULL;
359       discovery_info-&gt;resolv = NULL;
360       info-&gt;discovered = g_slist_prepend(info-&gt;discovered, discovery_info);
361       inf_discovery_discovered(INF_DISCOVERY(avahi), discovery_info);
362     }
363     break;
364   case AVAHI_BROWSER_REMOVE:
365     for(item = info-&gt;discovered; item != NULL; item = g_slist_next(item))
366     {
367       discovery_info = (InfDiscoveryInfo*)item-&gt;data;
368       g_assert(strcmp(discovery_info-&gt;service_type, type) == 0);
369       if(strcmp(discovery_info-&gt;service_name, name) == 0 &amp;&amp;
370          discovery_info-&gt;interface == interface &amp;&amp;
371          discovery_info-&gt;protocol == protocol)
372       {
373         inf_discovery_undiscovered(INF_DISCOVERY(avahi), discovery_info);
374         info-&gt;discovered = g_slist_remove(info-&gt;discovered, discovery_info);
375         inf_discovery_avahi_discovery_info_free(discovery_info);
376         break;
377       }
378     }
379     break;
380   case AVAHI_BROWSER_CACHE_EXHAUSTED:
381     break;
382   case AVAHI_BROWSER_ALL_FOR_NOW:
383     break;
384   case AVAHI_BROWSER_FAILURE:
385     g_warning(
386       _("Avahi service browser is in failure state. Services of type '%s' "
387         "are no longer discovered.\n\nThe failure was: %s\n"),
388       info-&gt;type,
389       avahi_strerror(
390         avahi_client_errno(avahi_service_browser_get_client(browser))
391       )
392     );
393     inf_discovery_avahi_perform_undiscover(avahi, info);
394     break;
395   default:
396     g_assert_not_reached();
397     break;
398   }
399 }
400 static void
401 inf_discovery_avahi_entry_group_add_service(InfLocalPublisherItem* item)
402 {
403   char* new_name;
404   int res;
405   do
406   {
407     res = avahi_entry_group_add_service(
408       item-&gt;entry_group,
409       AVAHI_IF_UNSPEC,
410       AVAHI_PROTO_UNSPEC,
411       0,
412       item-&gt;name,
413       item-&gt;type,
414       NULL,
415       NULL,
416       item-&gt;port,
417       NULL
418     );
419     if(res != AVAHI_ERR_COLLISION) break;
420     new_name = avahi_alternative_service_name(item-&gt;name);
421     avahi_free(item-&gt;name);
422     item-&gt;name = new_name;
423   } while(1);
424   if(res != 0)
425   {
426     g_warning(
427       "Failed to publish service \"%s\" via avahi: %s",
428       item-&gt;name,
429       avahi_strerror(res)
430     );
431   }
432 }
433 static void
434 inf_discovery_avahi_entry_group_callback(AvahiEntryGroup* group,
435                                          AvahiEntryGroupState state,
436                                          void* userdata)
437 {
438   InfLocalPublisherItem* item;
439   char* new_name;
440   item = (InfLocalPublisherItem*)userdata;
441   switch(state)
442   {
443   case AVAHI_ENTRY_GROUP_UNCOMMITED:
444     break;
445   case AVAHI_ENTRY_GROUP_REGISTERING:
446     break;
447   case AVAHI_ENTRY_GROUP_ESTABLISHED:
448     break;
449   case AVAHI_ENTRY_GROUP_COLLISION:
450     new_name = avahi_alternative_service_name(item-&gt;name);
451     avahi_free(item-&gt;name);
452     item-&gt;name = new_name;
453     avahi_entry_group_reset(item-&gt;entry_group);
454     inf_discovery_avahi_entry_group_add_service(item);
455     avahi_entry_group_commit(item-&gt;entry_group);
456     break;
457   case AVAHI_ENTRY_GROUP_FAILURE:
458     g_warning(
459       _("Avahi entry group is in failure state. The service '%s' of type "
460         "'%s' is no longer published.\n\nThe failure was: %s\n"),
461       item-&gt;name,
462       item-&gt;type,
463       avahi_strerror(avahi_client_errno(avahi_entry_group_get_client(group)))
464     );
465     inf_discovery_avahi_perform_unpublish_item(item);
466     break;
467   default:
468     g_assert_not_reached();
469     break;
470   }
471 }
472 static void
473 inf_discovery_avahi_perform_publish_item(InfDiscoveryAvahi* avahi,
474                                          InfLocalPublisherItem* item)
475 {
476   InfDiscoveryAvahiPrivate* priv;
477   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
478   if(item-&gt;entry_group == NULL)
479   {
480     item-&gt;entry_group = avahi_entry_group_new(
481       priv-&gt;client,
482       inf_discovery_avahi_entry_group_callback,
483       item
484     );
485     inf_discovery_avahi_entry_group_add_service(item);
486     avahi_entry_group_commit(item-&gt;entry_group);
487   }
488 }
489 static void
490 inf_discovery_avahi_perform_unpublish_item(InfLocalPublisherItem* item)
491 {
492   if(item-&gt;entry_group != NULL)
493   {
494     avahi_entry_group_free(item-&gt;entry_group);
495     item-&gt;entry_group = NULL;
496   }
497 }
498 static void
499 inf_discovery_avahi_perform_publish_all(InfDiscoveryAvahi* avahi)
500 {
501   InfDiscoveryAvahiPrivate* priv;
502   GSList* item;
503   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
504   for(item = priv-&gt;published; item != NULL; item = g_slist_next(item))
505   {
506     inf_discovery_avahi_perform_publish_item(
507       avahi,
508       (InfLocalPublisherItem*)item-&gt;data
509     );
510   }
511 }
512 static void
513 inf_discovery_avahi_perform_unpublish_all(InfDiscoveryAvahi* avahi)
514 {
515   InfDiscoveryAvahiPrivate* priv;
516   GSList* item;
517   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
518   for(item = priv-&gt;published; item != NULL; item = g_slist_next(item))
519   {
520     inf_discovery_avahi_perform_unpublish_item(
521       (InfLocalPublisherItem*)item-&gt;data
522     );
523   }
524 }
525 static void
526 inf_discovery_avahi_perform_discover(InfDiscoveryAvahi* avahi,
527                                      InfDiscoveryAvahiDiscoverInfo* info)
528 {
529   InfDiscoveryAvahiPrivate* priv;
530   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
531   if(info-&gt;service_browser == NULL)
532   {
533     info-&gt;service_browser = avahi_service_browser_new(
534       priv-&gt;client,
535       AVAHI_IF_UNSPEC,
536       AVAHI_PROTO_UNSPEC,
537       info-&gt;type,
538       NULL,
539       0,
540       inf_discovery_avahi_service_browser_callback,
541       avahi
542     );
543   }
544 }
545 static void
546 inf_discovery_avahi_perform_undiscover(InfDiscoveryAvahi* avahi,
547                                        InfDiscoveryAvahiDiscoverInfo* info)
548 {
549   InfDiscoveryInfo* discovery_info;
550   GSList* next;
551   for(; info-&gt;discovered != NULL; info-&gt;discovered = next)
552   {
553     next = info-&gt;discovered-&gt;next;
554     discovery_info = (InfDiscoveryInfo*)info-&gt;discovered-&gt;data;
555     inf_discovery_undiscovered(INF_DISCOVERY(avahi), discovery_info);
556     inf_discovery_avahi_discovery_info_free(discovery_info);
557     info-&gt;discovered = g_slist_delete_link(
558       info-&gt;discovered,
559       info-&gt;discovered
560     );
561   }
562   if(info-&gt;service_browser != NULL)
563   {
564     avahi_service_browser_free(info-&gt;service_browser);
565     info-&gt;service_browser = NULL;
566   }
567 }
568 static void
569 inf_discovery_avahi_perform_discover_all_foreach_func(gpointer key,
570                                                       gpointer value,
571                                                       gpointer user_data)
572 {
573   inf_discovery_avahi_perform_discover(
574     INF_DISCOVERY_AVAHI(user_data),
575     (InfDiscoveryAvahiDiscoverInfo*)value
576   );
577 }
578 static void
579 inf_discovery_avahi_perform_undiscover_all_foreach_func(gpointer key,
580                                                         gpointer value,
581                                                         gpointer user_data)
582 {
583   inf_discovery_avahi_perform_undiscover(
584     INF_DISCOVERY_AVAHI(user_data),
585     (InfDiscoveryAvahiDiscoverInfo*)value
586   );
587 }
588 static void
589 inf_discovery_avahi_perform_discover_all(InfDiscoveryAvahi* avahi)
590 {
591   InfDiscoveryAvahiPrivate* priv;
592   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
593   g_hash_table_foreach(
594     priv-&gt;discovered,
595     inf_discovery_avahi_perform_discover_all_foreach_func,
596     avahi
597   );
598 }
599 static void
600 inf_discovery_avahi_perform_undiscover_all(InfDiscoveryAvahi* avahi)
601 {
602   InfDiscoveryAvahiPrivate* priv;
603   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
604   g_hash_table_foreach(
605     priv-&gt;discovered,
606     inf_discovery_avahi_perform_undiscover_all_foreach_func,
607     avahi
608   );
609 }
610 static void
611 inf_discovery_avahi_client_callback(AvahiClient* client,
612                                     AvahiClientState state,
613                                     void* userdata);
614 static void
615 inf_discovery_avahi_create_client(InfDiscoveryAvahi* discovery)
616 {
617   InfDiscoveryAvahiPrivate* priv;
618   int error;
619   priv = INF_DISCOVERY_AVAHI_PRIVATE(discovery);
620   priv-&gt;client = avahi_client_new(
621     &amp;priv-&gt;poll,
622     AVAHI_CLIENT_NO_FAIL,
623     inf_discovery_avahi_client_callback,
624     discovery,
625     &amp;error
626   );
627   if(priv-&gt;client == NULL)
628   {
629     g_warning(_
630       ("Failed to start Avahi client. Service discovery or publishing "
631        "will not be possible.\n\nThe occurred failure was: %s"),
632       avahi_strerror(error)
633     );
634   }
635 }
636 static void
637 inf_discovery_avahi_client_callback(AvahiClient* client,
638                                     AvahiClientState state,
639                                     void* userdata)
640 {
641   InfDiscoveryAvahi* avahi;
642   InfDiscoveryAvahiPrivate* priv;
643   avahi = INF_DISCOVERY_AVAHI(userdata);
644   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
645   switch(state)
646   {
647   case AVAHI_CLIENT_S_COLLISION:
648     break;
649   case AVAHI_CLIENT_S_REGISTERING:
650     break;
651   case AVAHI_CLIENT_S_RUNNING:
652     inf_discovery_avahi_perform_publish_all(avahi);
653     inf_discovery_avahi_perform_discover_all(avahi);
654     break;
655   case AVAHI_CLIENT_FAILURE:
656     inf_discovery_avahi_perform_unpublish_all(avahi);
657     inf_discovery_avahi_perform_undiscover_all(avahi);
658     if(avahi_client_errno(client) != AVAHI_ERR_DISCONNECTED)
659     {
660       inf_discovery_avahi_create_client(avahi);
661     }
662     else
663     {
664       g_warning(
665         _("Avahi client is in failure state. Service discovery or "
666           "publishing is no longer possible.\n\nThe occurred failure "
667           "was: %s\n"),
668         avahi_strerror(avahi_client_errno(client))
669       );
670     }
671   case AVAHI_CLIENT_CONNECTING:
672     break;
673   default:
674     g_assert_not_reached();
675     break;
676   }
677 }
678 static AvahiWatchEvent
679 inf_discovery_avahi_from_io_event(InfIoEvent event)
680 {
681   AvahiWatchEvent res;
682   res = 0;
683   if(event &amp; INF_IO_INCOMING) res |= AVAHI_WATCH_IN;
684   if(event &amp; INF_IO_OUTGOING) res |= AVAHI_WATCH_OUT;
685   if(event &amp; INF_IO_ERROR) res |= AVAHI_WATCH_ERR;
686   return res;
687 }
688 static InfIoEvent
689 inf_discovery_avahi_to_io_event(AvahiWatchEvent event)
690 {
691   InfIoEvent res;
692   res = 0;
693   if(event &amp; AVAHI_WATCH_IN) res |= INF_IO_INCOMING;
694   if(event &amp; AVAHI_WATCH_OUT) res |= INF_IO_OUTGOING;
695   if(event &amp; (AVAHI_WATCH_ERR | AVAHI_WATCH_HUP)) res |= INF_IO_ERROR;
696   return res;
697 }
698 static void
699 inf_discovery_avahi_watch_cb(InfNativeSocket* socket,
700                              InfIoEvent event,
701                              gpointer user_data)
702 {
703   AvahiWatch* watch;
704   watch = (AvahiWatch*)user_data;
705   watch-&gt;occurred_events = inf_discovery_avahi_from_io_event(event);
706   watch-&gt;callback(watch, *socket, watch-&gt;occurred_events, watch-&gt;userdata);
707 }
708 static void
709 inf_discovery_avahi_timeout_cb(gpointer user_data)
710 {
711   AvahiTimeout* timeout;
712   timeout = (AvahiTimeout*)user_data;
713   timeout-&gt;timeout = NULL;
714   timeout-&gt;callback(timeout, timeout-&gt;userdata);
715 }
716 static AvahiWatch*
717 inf_discovery_avahi_watch_new(const AvahiPoll* api,
718                               int fd,
719                               AvahiWatchEvent event,
720                               AvahiWatchCallback callback,
721                               void* userdata)
722 {
723   InfDiscoveryAvahi* avahi;
724   InfDiscoveryAvahiPrivate* priv;
725   AvahiWatch* watch;
726   avahi = INF_DISCOVERY_AVAHI(api-&gt;userdata);
727   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
728   watch = g_slice_new(AvahiWatch);
729   watch-&gt;avahi = avahi;
730   watch-&gt;socket = fd;
731   watch-&gt;occurred_events = 0;
732   watch-&gt;callback = callback;
733   watch-&gt;userdata = userdata;
734   watch-&gt;watch = inf_io_add_watch(
735     priv-&gt;io,
736     &amp;watch-&gt;socket,
737     inf_discovery_avahi_to_io_event(event),
738     inf_discovery_avahi_watch_cb,
739     watch,
740     NULL
741   );
742   return watch;
743 }
744 static void
745 inf_discovery_avahi_watch_update(AvahiWatch* watch,
746                                  AvahiWatchEvent event)
747 {
748   InfDiscoveryAvahiPrivate* priv;
749   priv = INF_DISCOVERY_AVAHI_PRIVATE(watch-&gt;avahi);
750   inf_io_update_watch(
751     priv-&gt;io,
752     watch-&gt;watch,
753     inf_discovery_avahi_to_io_event(event)
754   );
755 }
756 static AvahiWatchEvent
757 inf_discovery_avahi_watch_get_events(AvahiWatch* watch)
758 {
759   return watch-&gt;occurred_events;
760 }
761 static void
762 inf_discovery_avahi_watch_free(AvahiWatch* watch)
763 {
764   InfDiscoveryAvahiPrivate* priv;
765   priv = INF_DISCOVERY_AVAHI_PRIVATE(watch-&gt;avahi);
766   inf_io_remove_watch(priv-&gt;io, watch-&gt;watch);
767   g_slice_free(AvahiWatch, watch);
768 }
769 static AvahiTimeout*
770 inf_discovery_avahi_timeout_new(const AvahiPoll* api,
771                                 const struct timeval* tv,
772                                 AvahiTimeoutCallback callback,
773                                 void* userdata)
774 {
775   InfDiscoveryAvahi* avahi;
776   InfDiscoveryAvahiPrivate* priv;
777   AvahiTimeout* timeout;
778   AvahiUsec usec;
779   avahi = INF_DISCOVERY_AVAHI(api-&gt;userdata);
780   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
781   timeout = g_slice_new(AvahiTimeout);
782   timeout-&gt;avahi = avahi;
783   timeout-&gt;callback = callback;
784   timeout-&gt;userdata = userdata;
785   if(tv != NULL)
786   {
787     usec = avahi_age(tv);
788     if(usec &gt; 0) usec = 0;
789     timeout-&gt;timeout = inf_io_add_timeout(
790       priv-&gt;io,
791       ((-usec) + 500) / 1000,
792       inf_discovery_avahi_timeout_cb,
793       timeout,
794       NULL
795     );
796   }
797   else
798   {
799     timeout-&gt;timeout = NULL;
800   }
801   return timeout;
802 }
803 static void
804 inf_discovery_avahi_timeout_update(AvahiTimeout* timeout,
805                                    const struct timeval* tv)
806 {
807   InfDiscoveryAvahiPrivate* priv;
808   AvahiUsec usec;
809   priv = INF_DISCOVERY_AVAHI_PRIVATE(timeout-&gt;avahi);
810   if(timeout-&gt;timeout != NULL)
811     inf_io_remove_timeout(priv-&gt;io, timeout-&gt;timeout);
812   if(tv != NULL)
813   {
814     usec = avahi_age(tv);
815     if(usec &gt; 0) usec = 0;
816     timeout-&gt;timeout = inf_io_add_timeout(
817       priv-&gt;io,
818       ((-usec) + 500) / 1000,
819       inf_discovery_avahi_timeout_cb,
820       timeout,
821       NULL
822     );
823   }
824   else
825   {
826     timeout-&gt;timeout = NULL;
827   }
828 }
829 static void
830 inf_discovery_avahi_timeout_free(AvahiTimeout* timeout)
831 {
832   InfDiscoveryAvahiPrivate* priv;
833   priv = INF_DISCOVERY_AVAHI_PRIVATE(timeout-&gt;avahi);
834   if(timeout-&gt;timeout != NULL)
835     inf_io_remove_timeout(priv-&gt;io, timeout-&gt;timeout);
836   g_slice_free(AvahiTimeout, timeout);
837 }
838 static void
839 inf_discovery_avahi_init(InfDiscoveryAvahi* avahi)
840 {
841   InfDiscoveryAvahiPrivate* priv;
842   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
843   priv-&gt;poll.userdata = avahi;
844   priv-&gt;poll.watch_new = inf_discovery_avahi_watch_new;
845   priv-&gt;poll.watch_update = inf_discovery_avahi_watch_update;
846   priv-&gt;poll.watch_get_events = inf_discovery_avahi_watch_get_events;
847   priv-&gt;poll.watch_free = inf_discovery_avahi_watch_free;
848   priv-&gt;poll.timeout_new = inf_discovery_avahi_timeout_new;
849   priv-&gt;poll.timeout_update = inf_discovery_avahi_timeout_update;
850   priv-&gt;poll.timeout_free = inf_discovery_avahi_timeout_free;
851   priv-&gt;io = NULL;
852   priv-&gt;xmpp_manager = NULL;
853   priv-&gt;security_policy = INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS;
854   priv-&gt;keepalive.mask = 0;
855   priv-&gt;creds = NULL;
856   priv-&gt;sasl_context = NULL;
857   priv-&gt;sasl_mechanisms = NULL;
858   priv-&gt;client = NULL;
859   priv-&gt;published = NULL;
860   priv-&gt;discovered = g_hash_table_new_full(
861     g_str_hash,
862     g_str_equal,
863     NULL,     inf_discovery_avahi_discover_info_free
864   );
865 }
866 static void
867 inf_discovery_avahi_constructed(GObject* object)
868 {
869   InfDiscoveryAvahiPrivate* priv;
870   G_OBJECT_CLASS(inf_discovery_avahi_parent_class)-&gt;constructed(object);
871   priv = INF_DISCOVERY_AVAHI_PRIVATE(object);
872   g_assert(priv-&gt;io != NULL);
873   inf_discovery_avahi_create_client(INF_DISCOVERY_AVAHI(object));
874 }
875 static void
876 inf_discovery_avahi_dispose(GObject* object)
877 {
878   InfDiscoveryAvahi* avahi;
879   InfDiscoveryAvahiPrivate* priv;
880   GSList* item;
881   avahi = INF_DISCOVERY_AVAHI(object);
882   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
883   g_hash_table_destroy(priv-&gt;discovered);
884   priv-&gt;discovered = NULL;
885   for(item = priv-&gt;published; item != NULL; item = g_slist_next(item))
886     inf_discovery_avahi_publisher_item_free(item-&gt;data);
887   g_slist_free(priv-&gt;published);
888   priv-&gt;published = NULL;
889   if(priv-&gt;client != NULL)
890   {
891     avahi_client_free(priv-&gt;client);
892     priv-&gt;client = NULL;
893   }
894   if(priv-&gt;xmpp_manager != NULL)
895   {
896     g_object_unref(G_OBJECT(priv-&gt;xmpp_manager));
897     priv-&gt;xmpp_manager = NULL;
898   }
899   if(priv-&gt;creds != NULL)
900   {
901     inf_certificate_credentials_unref(priv-&gt;creds);
902     priv-&gt;creds = NULL;
903   }
904   if(priv-&gt;sasl_context != NULL)
905   {
906     inf_sasl_context_unref(priv-&gt;sasl_context);
907     priv-&gt;sasl_context = NULL;
908   }
909   if(priv-&gt;io != NULL)
910   {
911     g_object_unref(G_OBJECT(priv-&gt;io));
912     priv-&gt;io = NULL;
913   }
914   G_OBJECT_CLASS(inf_discovery_avahi_parent_class)-&gt;dispose(object);
915 }
916 static void
917 inf_discovery_avahi_finalize(GObject* object)
918 {
919   InfDiscoveryAvahi* avahi;
920   InfDiscoveryAvahiPrivate* priv;
921   avahi = INF_DISCOVERY_AVAHI(object);
922   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
923   g_free(priv-&gt;sasl_mechanisms);
924   G_OBJECT_CLASS(inf_discovery_avahi_parent_class)-&gt;finalize(object);
925 }
926 static void
927 inf_discovery_avahi_set_property(GObject* object,
928                                  guint prop_id,
929                                  const GValue* value,
930                                  GParamSpec* pspec)
931 {
932   InfDiscoveryAvahi* avahi;
933   InfDiscoveryAvahiPrivate* priv;
934   avahi = INF_DISCOVERY_AVAHI(object);
935   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
936   switch(prop_id)
937   {
938   case PROP_IO:
939     g_assert(priv-&gt;io == NULL);     priv-&gt;io = INF_IO(g_value_dup_object(value));
940     break;
941   case PROP_XMPP_MANAGER:
942     g_assert(priv-&gt;xmpp_manager == NULL);     priv-&gt;xmpp_manager = INF_XMPP_MANAGER(g_value_dup_object(value));
943     break;
944   case PROP_CREDENTIALS:
945     if(priv-&gt;creds != NULL) inf_certificate_credentials_unref(priv-&gt;creds);
946     priv-&gt;creds = (InfCertificateCredentials*)g_value_dup_boxed(value);
947     break;
948   case PROP_SASL_CONTEXT:
949     priv-&gt;sasl_context = (InfSaslContext*)g_value_dup_boxed(value);
950     break;
951   case PROP_SASL_MECHANISMS:
952     g_free(priv-&gt;sasl_mechanisms);
953     priv-&gt;sasl_mechanisms = g_value_dup_string(value);
954     break;
955   case PROP_SECURITY_POLICY:
956     priv-&gt;security_policy = g_value_get_enum(value);
957     break;
958 <a name="0"></a>  case PROP_KEEPALIVE:
959     g_assert(g_value_get_boxed(value) != NULL);
960     priv-&gt;keepalive = *(const InfKeepalive*)g_value_get_boxed(value);
961 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
962   default:
963     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
964     break;
965   }
966 }
967 static void
968 inf_discovery_avahi_get_property(GObject* object,
969                                  guint prop_id,
970                                  GValue* value,
971                                  GParamSpec* pspec)
972 {
973   InfDiscoveryAvahi* avahi;
974   InfDiscoveryAvahiPrivate* priv;
975   avahi = INF_DISCOVERY_AVAHI(object);
976   priv = INF_DISCOVERY_AVAHI_PRIVATE(avahi);
977   switch(prop_id)
978   {
979   case PROP_IO:
980     g_value_set_object(value, G_OBJECT(priv-&gt;io));
981     break;</b></font>
982   case PROP_XMPP_MANAGER:
983     g_value_set_object(value, G_OBJECT(priv-&gt;xmpp_manager));
984     break;
985   case PROP_CREDENTIALS:
986     g_value_set_boxed(value, priv-&gt;creds);
987     break;
988   case PROP_SASL_CONTEXT:
989     g_value_set_boxed(value, priv-&gt;sasl_context);
990     break;
991   case PROP_SASL_MECHANISMS:
992     g_value_set_string(value, priv-&gt;sasl_mechanisms);
993     break;
994   case PROP_SECURITY_POLICY:
995     g_value_set_enum(value, priv-&gt;security_policy);
996     break;
997   case PROP_KEEPALIVE:
998     g_value_set_boxed(value, &amp;priv-&gt;keepalive);
999     break;
1000   default:
1001     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
1002     break;
1003   }
1004 }
1005 static void
1006 inf_discovery_avahi_discover(InfDiscovery* discovery,
1007                              const gchar* type)
1008 {
1009   InfDiscoveryAvahiPrivate* priv;
1010   InfDiscoveryAvahiDiscoverInfo* info;
1011   priv = INF_DISCOVERY_AVAHI_PRIVATE(discovery);
1012   info = g_hash_table_lookup(priv-&gt;discovered, type);
1013   if(info == NULL)
1014   {
1015     info = g_slice_new(InfDiscoveryAvahiDiscoverInfo);
1016     info-&gt;type = g_strdup(type);
1017     info-&gt;service_browser = NULL;
1018     info-&gt;discovered = NULL;
1019     g_hash_table_insert(priv-&gt;discovered, info-&gt;type, info);
1020     if(priv-&gt;client != NULL &amp;&amp;
1021        avahi_client_get_state(priv-&gt;client) == AVAHI_CLIENT_S_RUNNING)
1022     {
1023       inf_discovery_avahi_perform_discover(
1024         INF_DISCOVERY_AVAHI(discovery),
1025         info
1026       );
1027     }
1028   }
1029 }
1030 static GSList*
1031 inf_discovery_avahi_get_discovered(InfDiscovery* discovery,
1032                                    const gchar* type)
1033 {
1034   InfDiscoveryAvahiPrivate* priv;
1035   InfDiscoveryAvahiDiscoverInfo* info;
1036   priv = INF_DISCOVERY_AVAHI_PRIVATE(discovery);
1037   info = g_hash_table_lookup(priv-&gt;discovered, type);
1038   if(info == NULL) return NULL;
1039   return g_slist_copy(info-&gt;discovered);
1040 }
1041 static void
1042 inf_discovery_avahi_resolve(InfDiscovery* discovery,
1043                             InfDiscoveryInfo* info,
1044                             InfDiscoveryResolvCompleteFunc complete_func,
1045                             gpointer user_data)
1046 {
1047   InfDiscoveryAvahiPrivate* priv;
1048   InfDiscoveryAvahiInfoResolv* resolv;
1049   InfXmlConnectionStatus status;
1050   int errno;
1051   GError* error;
1052   priv = INF_DISCOVERY_AVAHI_PRIVATE(discovery);
1053   g_assert(priv-&gt;client != NULL);
1054   g_assert(avahi_client_get_state(priv-&gt;client) == AVAHI_CLIENT_S_RUNNING);
1055   if(info-&gt;resolved != NULL)
1056   {
1057     g_object_get(G_OBJECT(info-&gt;resolved), "status", &amp;status, NULL);
1058     switch(status)
1059     {
1060     case INF_XML_CONNECTION_CLOSED:
1061       error = NULL;
1062       if(!inf_xml_connection_open(INF_XML_CONNECTION(info-&gt;resolved), &amp;error))
1063       {
1064         complete_func(info, NULL, error, user_data);
1065         g_error_free(error);
1066       }
1067       else
1068       {
1069         complete_func(
1070           info,
1071           INF_XML_CONNECTION(info-&gt;resolved),
1072           NULL,
1073           user_data
1074         );
1075       }
1076       break;
1077     case INF_XML_CONNECTION_CLOSING:
1078       complete_func(info, NULL, NULL, user_data);
1079       break;
1080     case INF_XML_CONNECTION_OPENING:
1081     case INF_XML_CONNECTION_OPEN:
1082       complete_func(
1083         info,
1084         INF_XML_CONNECTION(info-&gt;resolved),
1085         NULL,
1086         user_data
1087       );
1088       break;
1089     default:
1090       g_assert_not_reached();
1091       break;
1092     }
1093   }
1094   else
1095   {
1096     resolv = g_slice_new(InfDiscoveryAvahiInfoResolv);
1097     resolv-&gt;complete_func = complete_func;
1098     resolv-&gt;user_data = user_data;
1099     info-&gt;resolv = g_slist_prepend(info-&gt;resolv, resolv);
1100     if(info-&gt;service_resolver == NULL)
1101     {
1102       info-&gt;service_resolver = avahi_service_resolver_new(
1103         priv-&gt;client,
1104         info-&gt;interface,
1105         info-&gt;protocol,
1106         info-&gt;service_name,
1107         info-&gt;service_type,
1108         info-&gt;domain,
1109         AVAHI_PROTO_UNSPEC,
1110         0,
1111         inf_discovery_avahi_service_resolver_callback,
1112         discovery
1113       );
1114       if(info-&gt;service_resolver == NULL)
1115       {
1116         error = NULL;
1117         errno = avahi_client_errno(
1118           avahi_service_resolver_get_client(info-&gt;service_resolver)
1119         );
1120         g_set_error_literal(
1121           &amp;error,
1122           inf_discovery_avahi_error_quark,
1123           errno,
1124           avahi_strerror(errno)
1125         );
1126         inf_discovery_avahi_info_resolv_error(info, error);
1127         g_error_free(error);
1128       }
1129     }
1130   }
1131 }
1132 static gchar*
1133 inf_discovery_avahi_info_get_service_name(InfDiscovery* discovery,
1134                                           InfDiscoveryInfo* info)
1135 {
1136   char device_name[IF_NAMESIZE];
1137   if(if_indextoname(info-&gt;interface, device_name) == NULL)
1138     return NULL;
1139   return g_strdup_printf(
1140     info-&gt;protocol == AVAHI_PROTO_INET ?
1141       _("%s (via %s on IPv4)") :
1142       _("%s (via %s on IPv6)"),
1143     info-&gt;service_name,
1144     device_name
1145   );
1146 }
1147 static const gchar*
1148 inf_discovery_avahi_info_get_service_type(InfDiscovery* discovery,
1149                                           InfDiscoveryInfo* info)
1150 {
1151   return info-&gt;service_type;
1152 }
1153 static InfLocalPublisherItem*
1154 inf_discovery_avahi_publish(InfLocalPublisher* publisher,
1155                             const gchar* type,
1156                             const gchar* name,
1157                             guint port)
1158 {
1159   InfDiscoveryAvahiPrivate* priv;
1160   InfLocalPublisherItem* item;
1161   priv = INF_DISCOVERY_AVAHI_PRIVATE(publisher);
1162   item = g_slice_new(InfLocalPublisherItem);
1163   item-&gt;type = g_strdup(type);
1164   item-&gt;name = avahi_strdup(name);
1165   item-&gt;port = port;
1166   item-&gt;entry_group = NULL;
1167   priv-&gt;published = g_slist_prepend(priv-&gt;published, item);
1168   if(priv-&gt;client != NULL &amp;&amp;
1169      avahi_client_get_state(priv-&gt;client) == AVAHI_CLIENT_S_RUNNING)
1170   {
1171     inf_discovery_avahi_perform_publish_item(
1172       INF_DISCOVERY_AVAHI(publisher),
1173       item
1174     );
1175   }
1176   return item;
1177 }
1178 static void
1179 inf_discovery_avahi_unpublish(InfLocalPublisher* publisher,
1180                               InfLocalPublisherItem* item)
1181 {
1182   InfDiscoveryAvahiPrivate* priv;
1183   priv = INF_DISCOVERY_AVAHI_PRIVATE(publisher);
1184   g_assert(g_slist_find(priv-&gt;published, item) != NULL);
1185   inf_discovery_avahi_publisher_item_free(item);
1186   priv-&gt;published = g_slist_remove(priv-&gt;published, item);
1187 }
1188 static void
1189 inf_discovery_avahi_class_init(InfDiscoveryAvahiClass* avahi_class)
1190 {
1191   GObjectClass* object_class;
1192   object_class = G_OBJECT_CLASS(avahi_class);
1193   object_class-&gt;constructed = inf_discovery_avahi_constructed;
1194   object_class-&gt;dispose = inf_discovery_avahi_dispose;
1195   object_class-&gt;finalize = inf_discovery_avahi_finalize;
1196   object_class-&gt;set_property = inf_discovery_avahi_set_property;
1197   object_class-&gt;get_property = inf_discovery_avahi_get_property;
1198   inf_discovery_avahi_error_quark = g_quark_from_static_string(
1199     "INF_DISCOVERY_AVAHI_ERROR"
1200   );
1201   g_object_class_install_property(
1202     object_class,
1203     PROP_IO,
1204     g_param_spec_object(
1205       "io",
1206       "IO",
1207       "The IO object used for watching sockets and timeouts",
1208       INF_TYPE_IO,
1209       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1210     )
1211   );
1212   g_object_class_install_property(
1213     object_class,
1214     PROP_XMPP_MANAGER,
1215     g_param_spec_object(
1216       "xmpp-manager",
1217       "XMPP manager",
1218       "The XMPP manager to register resolved XMPP connections",
1219       INF_TYPE_XMPP_MANAGER,
1220       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1221     )
1222   );
1223   g_object_class_install_property(
1224     object_class,
1225     PROP_CREDENTIALS,
1226     g_param_spec_boxed(
1227       "credentials",
1228       "Certificate credentials",
1229       "The GnuTLS certificate credentials used for encrypting XMPP streams",
1230       INF_TYPE_CERTIFICATE_CREDENTIALS,
1231       G_PARAM_READWRITE
1232     )
1233   );
1234   g_object_class_install_property(
1235     object_class,
1236     PROP_SASL_CONTEXT,
1237     g_param_spec_boxed(
1238       "sasl-context",
1239       "SASL context",
1240       "The SASL context used for authentication",
1241       INF_TYPE_SASL_CONTEXT,
1242       G_PARAM_READWRITE
1243     )
1244   );
1245   g_object_class_install_property(
1246     object_class,
1247     PROP_SASL_MECHANISMS,
1248     g_param_spec_string(
1249       "sasl-mechanisms",
1250       "SASL mechanisms",
1251       "The accepted SASL mechanisms for authentication",
1252       NULL,
1253       G_PARAM_READWRITE
1254     )
1255   );
1256   g_object_class_install_property(
1257     object_class,
1258     PROP_SECURITY_POLICY,
1259     g_param_spec_enum(
1260       "security-policy",
1261       "Security policy",
1262       "How to decide whether to use TLS",
1263       INF_TYPE_XMPP_CONNECTION_SECURITY_POLICY,
1264       INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS,
1265       G_PARAM_READWRITE
1266     )
1267   );
1268   g_object_class_install_property(
1269     object_class,
1270     PROP_KEEPALIVE,
1271     g_param_spec_boxed(
1272       "keepalive",
1273       "Keepalive",
1274       "The keepalive settings for new connections",
1275       INF_TYPE_KEEPALIVE,
1276       G_PARAM_READWRITE
1277     )
1278   );
1279 }
1280 static void
1281 inf_discovery_avahi_discovery_iface_init(InfDiscoveryInterface* iface)
1282 {
1283   iface-&gt;discover = inf_discovery_avahi_discover;
1284   iface-&gt;get_discovered = inf_discovery_avahi_get_discovered;
1285   iface-&gt;resolve = inf_discovery_avahi_resolve;
1286   iface-&gt;info_get_service_name = inf_discovery_avahi_info_get_service_name;
1287   iface-&gt;info_get_service_type = inf_discovery_avahi_info_get_service_type;
1288   iface-&gt;discovered = NULL;
1289   iface-&gt;undiscovered = NULL;
1290 }
1291 static void
1292 inf_discovery_avahi_local_publisher_iface_init(
1293   InfLocalPublisherInterface* iface)
1294 {
1295   iface-&gt;publish = inf_discovery_avahi_publish;
1296   iface-&gt;unpublish = inf_discovery_avahi_unpublish;
1297 }
1298 InfDiscoveryAvahi*
1299 inf_discovery_avahi_new(InfIo* io,
1300                         InfXmppManager* manager,
1301                         InfCertificateCredentials* creds,
1302                         InfSaslContext* sasl_context,
1303                         const gchar* sasl_mechanisms)
1304 {
1305   GObject* object;
1306   g_return_val_if_fail(INF_IS_IO(io), NULL);
1307   g_return_val_if_fail(INF_IS_XMPP_MANAGER(manager), NULL);
1308   object = g_object_new(
1309     INF_TYPE_DISCOVERY_AVAHI,
1310     "io", io,
1311     "xmpp-manager", manager,
1312     "credentials", creds,
1313     "sasl-context", sasl_context,
1314     "sasl-mechanisms", sasl_mechanisms,
1315     NULL
1316   );
1317   return INF_DISCOVERY_AVAHI(object);
1318 }
1319 void
1320 inf_discovery_avahi_set_security_policy(InfDiscoveryAvahi* discovery,
1321                                         InfXmppConnectionSecurityPolicy plcy)
1322 {
1323   g_return_if_fail(INF_IS_DISCOVERY_AVAHI(discovery));
1324   INF_DISCOVERY_AVAHI_PRIVATE(discovery)-&gt;security_policy = plcy;
1325 }
1326 InfXmppConnectionSecurityPolicy
1327 inf_discovery_avahi_get_security_policy(InfDiscoveryAvahi* discovery)
1328 {
1329   g_return_val_if_fail(
1330     INF_IS_DISCOVERY_AVAHI(discovery),
1331     INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS
1332   );
1333   return INF_DISCOVERY_AVAHI_PRIVATE(discovery)-&gt;security_policy;
1334 }
1335 void
1336 inf_discovery_avahi_set_keepalive(InfDiscoveryAvahi* discovery,
1337                                   const InfKeepalive* keepalive)
1338 {
1339   g_return_if_fail(INF_IS_DISCOVERY_AVAHI(discovery));
1340   g_return_if_fail(keepalive != NULL);
1341   INF_DISCOVERY_AVAHI_PRIVATE(discovery)-&gt;keepalive = *keepalive;
1342 }
1343 const InfKeepalive*
1344 inf_discovery_avahi_get_keepalive(InfDiscoveryAvahi* discovery)
1345 {
1346   g_return_val_if_fail(INF_IS_DISCOVERY_AVAHI(discovery), NULL);
1347   return &amp;INF_DISCOVERY_AVAHI_PRIVATE(discovery)-&gt;keepalive;
1348 }
1349 #endif 
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
