<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for react_outc.c &amp; react_outc_trimol.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for react_outc.c &amp; react_outc_trimol.c
      </h3>
<h1 align="center">
        17.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>react_outc.c (18.681917%)<th>react_outc_trimol.c (16.310034%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(394-408)<td><a href="#" name="0">(249-264)</a><td align="center"><font color="#ff0000">30</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1675-1708)<td><a href="#" name="1">(441-477)</a><td align="center"><font color="#e50000">27</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(366-381)<td><a href="#" name="2">(78-96)</a><td align="center"><font color="#bb0000">22</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(652-662)<td><a href="#" name="3">(871-885)</a><td align="center"><font color="#aa0000">20</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(615-629)<td><a href="#" name="4">(845-864)</a><td align="center"><font color="#aa0000">20</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(1642-1661)<td><a href="#" name="5">(350-369)</a><td align="center"><font color="#a10000">19</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(755-766)<td><a href="#" name="6">(1121-1140)</a><td align="center"><font color="#900000">17</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(1383-1399)<td><a href="#" name="7">(1950-1967)</a><td align="center"><font color="#880000">16</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(1360-1374)<td><a href="#" name="8">(1929-1942)</a><td align="center"><font color="#880000">16</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(677-685)<td><a href="#" name="9">(918-930)</a><td align="center"><font color="#880000">16</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(1663-1674)<td><a href="#" name="10">(398-403)</a><td align="center"><font color="#7f0000">15</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(1305-1316)<td><a href="#" name="11">(1840-1851)</a><td align="center"><font color="#7f0000">15</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(686-692)<td><a href="#" name="12">(980-989)</a><td align="center"><font color="#7f0000">15</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(663-671)<td><a href="#" name="13">(895-905)</a><td align="center"><font color="#7f0000">15</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(1405-1421)<td><a href="#" name="14">(1970-1984)</a><td align="center"><font color="#770000">14</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(921-931)<td><a href="#" name="15">(1628-1638)</a><td align="center"><font color="#770000">14</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(552-576)<td><a href="#" name="16">(778-803)</a><td align="center"><font color="#770000">14</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(508-516)<td><a href="#" name="17">(679-688)</a><td align="center"><font color="#770000">14</font>
<tr onclick='openModal("#800517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#800517"><font color="#800517">-</font><td><a href="#" name="18">(1250-1255)<td><a href="#" name="18">(1760-1765)</a><td align="center"><font color="#660000">12</font>
<tr onclick='openModal("#f62817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f62817"><font color="#f62817">-</font><td><a href="#" name="19">(1043-1057)<td><a href="#" name="19">(1702-1715)</a><td align="center"><font color="#660000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>react_outc.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;vector&gt;
#include "logging.h"
#include "rng.h"
#include "util.h"
#include "grid_util.h"
#include "count_util.h"
#include "react.h"
#include "vol_util.h"
#include "wall_util.h"
#include "nfsim_func.h"
#include "mcell_reactions.h"
#include "diffuse.h"
#include "debug_config.h"
#include "debug.h"
#include "dump_state.h"
static int outcome_products_random(struct volume *world, struct wall *w,
                                   struct vector3 *hitpt, double t,
                                   struct rxn *rx, int path,
                                   struct abstract_molecule *reacA,
                                   struct abstract_molecule *reacB,
                                   short orientA, short orientB);
static int cleanup_and_block_rx(struct tile_neighbor *tn1, struct tile_neighbor *tn2);
int is_compatible_surface(void *req_species, struct wall *w) {
  struct surf_class_list *scl, *scl2;
  struct surf_class_list *rs_head = (struct surf_class_list *)req_species;
  if (rs_head == NULL)
    return 1;
  for (scl = w-&gt;surf_class_head; scl != NULL; scl = scl-&gt;next) {
    for (scl2 = rs_head; scl2 != NULL; scl2 = scl2-&gt;next) {
      if (scl-&gt;surf_class == scl2-&gt;surf_class)
        return 1;
    }
  }
  return 0;
}
void add_reactants_to_product_list(struct rxn *rx, struct abstract_molecule *reacA,
  struct abstract_molecule *reacB, struct abstract_molecule *reacC,
  struct abstract_molecule **player, char *player_type) {
  player[0] = reacA;
  player_type[0] = IS_SURF_MOL(reacA) ? PLAYER_SURF_MOL : PLAYER_VOL_MOL;
  if (rx-&gt;n_reactants &gt; 1) {
    if (reacB == NULL) {
      assert(rx-&gt;n_reactants == 2);
      player[1] = NULL;
      player_type[1] = PLAYER_WALL;
    } else {        player[1] = reacB;
      player_type[1] = IS_SURF_MOL(reacB) ? PLAYER_SURF_MOL : PLAYER_VOL_MOL;
    }
    if (rx-&gt;n_reactants &gt; 2) {
      if (reacC == NULL) {
        player[2] = NULL;
        player_type[2] = PLAYER_WALL;
      } else {
        player[2] = reacC;
        player_type[2] = IS_SURF_MOL(reacC) ? PLAYER_SURF_MOL : PLAYER_VOL_MOL;
      }
    }
  }
}
static bool is_rxn_unimol(struct rxn *rx) {
  if (rx-&gt;n_reactants == 1)
    return true;
  if (rx-&gt;n_reactants != 2)
    return false;
  if (!(rx-&gt;players[0]-&gt;flags &amp; ON_GRID))
    return false;
  return (rx-&gt;players[1]-&gt;flags &amp; IS_SURFACE) != 0;
}
void tiny_diffuse_3D(
    struct volume *world,
    struct subvolume *subvol,
    struct vector3 *displacement,
    struct vector3 *pos,
    struct wall *w) {
  struct vector3 temp_displacement = {
    displacement-&gt;x,
    displacement-&gt;y,
    displacement-&gt;z
  };
  struct collision *shead = ray_trace(
      world, pos, NULL, subvol, &amp;temp_displacement, w);
  if (shead-&gt;next != NULL) {
    shead = (struct collision *)ae_list_sort((struct abstract_element *)shead);
  }
  struct collision *smash = NULL;
  for (smash = shead; smash != NULL; smash = smash-&gt;next) {
    if ((smash-&gt;what &amp; COLLIDE_WALL) != 0) {
      vectorize(pos, &amp;(smash-&gt;loc), displacement);
      scalar_prod(displacement, 0.5, displacement);
      break;
    }
  }
  pos-&gt;x += displacement-&gt;x;
  pos-&gt;y += displacement-&gt;y;
  pos-&gt;z += displacement-&gt;z;
  subvol = find_subvolume(world, pos, subvol);
}
struct volume_molecule *
place_volume_product(struct volume *world, struct species *product_species, struct graph_data* graph,
                     struct surface_molecule *sm_reactant, struct wall *w,
                     struct subvolume *subvol, struct vector3 *hitpt,
                     short orient, double t, struct periodic_image *periodic_box) {
  struct vector3 pos = *hitpt;
  if (w) {
    double bump = (orient &gt; 0) ? EPS_C : -EPS_C;
    struct vector3 displacement = {2 * bump * w-&gt;normal.x,
                                   2 * bump * w-&gt;normal.y,
                                   2 * bump * w-&gt;normal.z,
                                  };
    tiny_diffuse_3D(world, subvol, &amp;displacement, &amp;pos, w);
  }
  struct volume_molecule *new_volume_mol;
  new_volume_mol =
      (struct volume_molecule *)CHECKED_MEM_GET(subvol-&gt;local_storage-&gt;mol, "volume molecule");
  new_volume_mol-&gt;birthplace = subvol-&gt;local_storage-&gt;mol;
  new_volume_mol-&gt;birthday = convert_iterations_to_seconds(
      world-&gt;start_iterations, world-&gt;time_unit,
      world-&gt;simulation_start_seconds, t);
  new_volume_mol-&gt;id = world-&gt;current_mol_id++;
  new_volume_mol-&gt;t = t;
  new_volume_mol-&gt;t2 = 0.0;
  new_volume_mol-&gt;periodic_box = CHECKED_MALLOC_STRUCT(struct periodic_image,
    "periodic image descriptor");
  new_volume_mol-&gt;periodic_box-&gt;x = periodic_box-&gt;x;
  new_volume_mol-&gt;periodic_box-&gt;y = periodic_box-&gt;y;
  new_volume_mol-&gt;periodic_box-&gt;z = periodic_box-&gt;z;
  new_volume_mol-&gt;properties = product_species;
  new_volume_mol-&gt;graph_data = graph;
  initialize_diffusion_function((struct abstract_molecule*) new_volume_mol);
  new_volume_mol-&gt;prev_v = NULL;
  new_volume_mol-&gt;next_v = NULL;
  new_volume_mol-&gt;pos = pos;
  new_volume_mol-&gt;subvol = subvol;
  new_volume_mol-&gt;index = 0;
  new_volume_mol-&gt;flags = TYPE_VOL | ACT_NEWBIE | IN_VOLUME | IN_SCHEDULE;
  if (new_volume_mol-&gt;get_space_step(new_volume_mol) &gt; 0.0)
    new_volume_mol-&gt;flags |= ACT_DIFFUSE;
  if ((product_species-&gt;flags &amp; COUNT_SOME_MASK) != 0)
    new_volume_mol-&gt;flags |= COUNT_ME;
  if (trigger_unimolecular(world-&gt;reaction_hash, world-&gt;rx_hashsize,
                           product_species-&gt;hashval,
                           (struct abstract_molecule *)new_volume_mol) != NULL)
    new_volume_mol-&gt;flags |= ACT_REACT;
  if (sm_reactant &amp;&amp; distinguishable(new_volume_mol-&gt;get_diffusion(new_volume_mol), 0, EPS_C)) {
    new_volume_mol-&gt;previous_wall = sm_reactant-&gt;grid-&gt;surface;
    new_volume_mol-&gt;index = sm_reactant-&gt;grid_index;
  }
  else {
    new_volume_mol-&gt;previous_wall = NULL;
    new_volume_mol-&gt;index = -1;
  }
  if (w) {
    if (world-&gt;surface_reversibility) {
      new_volume_mol-&gt;previous_wall = w;
      new_volume_mol-&gt;index = (orient &gt; 0) ? 1 : -1;
      new_volume_mol-&gt;flags |= ACT_CLAMPED;
    }
  } else if (world-&gt;volume_reversibility) {
    new_volume_mol-&gt;index = world-&gt;dissociation_index;
    new_volume_mol-&gt;flags |= ACT_CLAMPED;
  }
  ht_add_molecule_to_list(&amp;new_volume_mol-&gt;subvol-&gt;mol_by_species,
                          new_volume_mol);
  ++new_volume_mol-&gt;subvol-&gt;mol_count;
  if (schedule_add_mol(subvol-&gt;local_storage-&gt;timer, new_volume_mol))
    mcell_allocfailed("Failed to add newly created %s molecule to scheduler.",
                      product_species-&gt;sym-&gt;name);
  return new_volume_mol;
}
struct surface_molecule *
place_sm_product(struct volume *world, struct species *product_species, struct graph_data* graph,
                 struct surface_grid *grid, int grid_index,
                 struct vector2 *mol_uv_pos, short orient, double t,
                 struct periodic_image *periodic_box) {
  struct vector3 mol_xyz_pos;
  uv2xyz(mol_uv_pos, grid-&gt;surface, &amp;mol_xyz_pos);
  struct subvolume *sv = find_subvolume(world, &amp;mol_xyz_pos, grid-&gt;subvol);
  struct surface_molecule *new_surf_mol;
  new_surf_mol = (struct surface_molecule *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;smol, "surface molecule");
  new_surf_mol-&gt;birthplace = sv-&gt;local_storage-&gt;smol;
  new_surf_mol-&gt;birthday = convert_iterations_to_seconds(
      world-&gt;start_iterations, world-&gt;time_unit,
      world-&gt;simulation_start_seconds, t);
  new_surf_mol-&gt;id = world-&gt;current_mol_id++;
  new_surf_mol-&gt;t = t;
  new_surf_mol-&gt;t2 = 0.0;
  new_surf_mol-&gt;properties = product_species;
  new_surf_mol-&gt;graph_data = graph;
  initialize_diffusion_function((struct abstract_molecule*) new_surf_mol);
  new_surf_mol-&gt;periodic_box = CHECKED_MALLOC_STRUCT(struct periodic_image,
    "periodic image descriptor");
  new_surf_mol-&gt;periodic_box-&gt;x = periodic_box-&gt;x;
  new_surf_mol-&gt;periodic_box-&gt;y = periodic_box-&gt;y;
  new_surf_mol-&gt;periodic_box-&gt;z = periodic_box-&gt;z;
  new_surf_mol-&gt;flags = TYPE_SURF | ACT_NEWBIE | IN_SCHEDULE;
  if (new_surf_mol-&gt;get_space_step(new_surf_mol) &gt; 0)
    new_surf_mol-&gt;flags |= ACT_DIFFUSE;
  if (product_species-&gt;flags &amp; COUNT_ENCLOSED)
    new_surf_mol-&gt;flags |= COUNT_ME;
  new_surf_mol-&gt;grid = grid;
  new_surf_mol-&gt;grid_index = grid_index;
  new_surf_mol-&gt;s_pos = *mol_uv_pos;
  new_surf_mol-&gt;orient = orient;
  if (trigger_unimolecular(world-&gt;reaction_hash, world-&gt;rx_hashsize,
                           product_species-&gt;hashval,
                           (struct abstract_molecule *)new_surf_mol) != NULL ||
      (product_species-&gt;flags &amp; CAN_SURFWALL) != 0)
    new_surf_mol-&gt;flags |= ACT_REACT;
  ++grid-&gt;n_occupied;
  if (grid-&gt;sm_list[grid_index]) {
    remove_surfmol_from_list(
        &amp;grid-&gt;sm_list[grid_index], grid-&gt;sm_list[grid_index]-&gt;sm);
  }
  grid-&gt;sm_list[grid_index] = add_surfmol_with_unique_pb_to_list(
    grid-&gt;sm_list[grid_index], new_surf_mol);
  if (schedule_add_mol(sv-&gt;local_storage-&gt;timer, new_surf_mol))
    mcell_allocfailed("Failed to add newly created %s molecule to scheduler.",
                      product_species-&gt;sym-&gt;name);
  return new_surf_mol;
}
static int outcome_products_random(struct volume *world, struct wall *w,
                                   struct vector3 *hitpt, double t,
                                   struct rxn *rx, int path,
                                   struct abstract_molecule *reacA,
                                   struct abstract_molecule *reacB,
                                   short orientA, short orientB) {
#ifdef DEBUG_RXNS
  DUMP_CONDITION3(
    dump_processing_reaction(world-&gt;current_iterations, hitpt, t, rx, reacA, reacB, w);
    dump_molecule_species(reacA);
    if (reacB != nullptr) {
      mcell_log(" + ");
      dump_molecule_species(reacB);
    }
    mcell_log("\nreaction_index: %d\n", path);
    dump_rxn(rx, "", true);
  );
#endif
<a name="2"></a>  bool cross_wall = false; 
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  int const i0 = rx-&gt;product_idx[path]; 
  int const iN = rx-&gt;product_idx[path + 1]; 
  assert(iN &gt; i0);
  struct species **rx_players = rx-&gt;players + i0; 
  int const n_players = iN - i0;                  std::vector&lt;struct abstract_molecule *&gt; product(n_players);   std::vector&lt;char&gt; product_type(n_players);
  std::vector&lt;short&gt; product_orient(n_players);   std::vector&lt;struct surface_grid *&gt; product_grid(n_players);
  std::vector&lt;int&gt; product_grid_idx(n_players);   std::vector&lt;byte&gt; product_flag(n_players);    
  bool const is_unimol = is_rxn_unimol(rx);
  struct surface_grid *tile_grid;   int num_vacant_tiles = 0;       
  unsigned int reac_idx = UINT_MAX;
<a name="0"></a>  struct surface_grid *reac_grid = NULL, *mol_grid = NULL;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  for (int i = 0; i &lt; n_players; ++i) {
    product[i] = NULL;
    product_type[i] = PLAYER_NONE;
    product_orient[i] = 0;
    product_grid[i] = NULL;
    product_grid_idx[i] = -1;
    product_flag[i] = PRODUCT_FLAG_NOT_SET;
  }
  struct surface_molecule *const sm_1 =
      IS_SURF_MOL(reacA) ? (struct surface_molecule *)reacA : NULL;
  struct surface_molecule *const sm_2 =
      IS_SURF_MOL(reacB) ? (struct surface_molecule *)reacB : NULL;
  struct surface_molecule *const sm_reactant = sm_1 ? sm_1 : sm_2;</b></font>
  bool const is_orientable = (w != NULL) || (sm_reactant != NULL);
  struct region_list *rlp_head_wall_1 = NULL, *rlp_head_wall_2 = NULL;
  struct region_list *rlp_head_obj_1 = NULL, *rlp_head_obj_2 = NULL;
  int sm_bitmask = determine_molecule_region_topology(
      world, sm_1, sm_2, &amp;rlp_head_wall_1, &amp;rlp_head_wall_2, &amp;rlp_head_obj_1,
      &amp;rlp_head_obj_2, is_unimol);
  struct abstract_molecule *const initiator = reacA;
  short const initiatorOrient = orientA;
  assert(reacA != NULL);
  if (reacA-&gt;properties != rx-&gt;players[0]) {
    struct abstract_molecule *tmp_mol = reacA;
    reacA = reacB;
    reacB = tmp_mol;
    short tmp_orient = orientA;
    orientA = orientB;
    orientB = tmp_orient;
  }
  assert(reacA != NULL);
  add_reactants_to_product_list(rx, reacA, reacB, NULL, &amp;product[0], &amp;product_type[0]);
  int replace_p1 = (product_type[0] == PLAYER_SURF_MOL &amp;&amp; rx_players[0] == NULL);
  int replace_p2 = rx-&gt;n_reactants &gt; 1 &amp;&amp; (product_type[1] == PLAYER_SURF_MOL &amp;&amp;
                                           rx_players[1] == NULL);
  struct vector2 rxn_uv_pos;   int rxn_uv_idx = -1;         int num_surface_static_reactants = 0;   if (is_orientable) {
    if (sm_reactant) {
      rxn_uv_pos = sm_reactant-&gt;s_pos;
    } else {
      xyz2uv(hitpt, w, &amp;rxn_uv_pos);
    }
    assert(w != NULL);
    if (w-&gt;grid == NULL) {
      assert(!IS_SURF_MOL(reacA));
      if (create_grid(world, w, ((struct volume_molecule *)reacA)-&gt;subvol))
        mcell_allocfailed("Failed to create a grid for a wall.");
    }
    rxn_uv_idx = uv2grid(&amp;rxn_uv_pos, w-&gt;grid);
    if ((sm_1 != NULL) &amp;&amp; (!distinguishable(sm_1-&gt;get_diffusion(sm_1), 0, EPS_C))){
      num_surface_static_reactants++;
    }
    if ((sm_2 != NULL) &amp;&amp; (!distinguishable(sm_2-&gt;get_diffusion(sm_2), 0, EPS_C))){
      num_surface_static_reactants++;
    }
  }
  int num_surface_products = 0;
  int num_surface_static_products = 0;   for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
    if (rx_players[n_product] == NULL) {
      continue;
    }
    if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
      num_surface_products++;
      if (!distinguishable(rx_players[n_product]-&gt;D, 0, EPS_C))
        num_surface_static_products++;
    }
  }
  int mol_idx = INT_MAX;
  struct tile_neighbor *tile_nbr_head = NULL;   int tile_nbr_list_length = 0;
  struct tile_neighbor *tile_vacant_nbr_head = NULL;   if (is_orientable) {
    if (num_surface_products &gt; 0) {
      if (sm_reactant != NULL) {
        find_neighbor_tiles(world, sm_reactant, sm_reactant-&gt;grid,
                            sm_reactant-&gt;grid_index, 1, 0, &amp;tile_nbr_head,
                            &amp;tile_nbr_list_length);
      } else {
        find_neighbor_tiles(world, sm_reactant, w-&gt;grid, rxn_uv_idx, 1, 0,
                            &amp;tile_nbr_head, &amp;tile_nbr_list_length);
<a name="17"></a>      }
<font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>      for (struct tile_neighbor *tile_nbr = tile_nbr_head; tile_nbr != NULL;
           tile_nbr = tile_nbr-&gt;next) {
        struct surface_molecule_list *sm_list = tile_nbr-&gt;grid-&gt;sm_list[tile_nbr-&gt;idx]; 
        if (sm_list == NULL || sm_list-&gt;sm == NULL) {
          num_vacant_tiles++;
          push_tile_neighbor_to_list(&amp;tile_vacant_nbr_head, tile_nbr-&gt;grid, tile_nbr-&gt;idx);
        }
      }
    }</b></font>
    int num_recycled_tiles = 0;
    if (replace_p1 &amp;&amp; replace_p2) {
      num_recycled_tiles = 2;
    } else if (replace_p1 || replace_p2) {
      num_recycled_tiles = 1;
    }
    if (num_surface_products &gt; num_vacant_tiles + num_recycled_tiles) {
      return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
    }
    for (int n_product = 0; n_product &lt; n_players; ++n_product) {
      if (rx_players[n_product] == NULL) {
        continue;
      }
      int this_geometry = rx-&gt;geometries[i0 + n_product];
      int relative_orient = (this_geometry &lt; 0) ? -1 : 1;
      this_geometry = abs(this_geometry);
      if (this_geometry == 0) {
        product_orient[n_product] = (rng_uint(world-&gt;rng) &amp; 1) ? 1 : -1;
      } else {
        if (this_geometry &gt; (int)rx-&gt;n_reactants) {
          product_orient[n_product] = relative_orient *
              product_orient[this_geometry - rx-&gt;n_reactants - 1];
        } else if (this_geometry == 1) {
          product_orient[n_product] = relative_orient * orientA;
<a name="16"></a>        } else if (this_geometry == 2 &amp;&amp; reacB != NULL) {
          product_orient[n_product] = relative_orient * orientB;
        } else {
<font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>          product_orient[n_product] = relative_orient * 1;
        }
      }
      if (n_product &lt; (int)rx-&gt;n_reactants) {
        if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
          assert(IS_SURF_MOL(product[n_product]));
          struct surface_molecule *sm =
              (struct surface_molecule *)product[n_product];
          if (sm-&gt;orient != product_orient[n_product]) {
            if (product[n_product]-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS|COUNT_ENCLOSED)) {</b></font>
              count_region_from_scratch(world,
                                        product[n_product],                                         NULL,                                                       -1,                                                         NULL,                                         w,                                            t,                                            NULL);
            }
            if (((sm-&gt;flags &amp; ACT_REACT) != 0) &amp;&amp;
                ((sm-&gt;properties-&gt;flags &amp; CAN_SURFWALL) != 0)) {
              sm-&gt;t2 = 0;
            }
            sm-&gt;orient = product_orient[n_product];
            if (product[n_product]-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS|COUNT_ENCLOSED)) {
              count_region_from_scratch(world,
                                        product[n_product],                                         NULL,                                                       1,                                                          NULL,                                         w,                                            t,    <a name="4"></a>                                        NULL);
            }
          }
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        } else if (!is_unimol) {           if (product[n_product] == initiator) {
            if (product_orient[n_product] != initiatorOrient)
              cross_wall = true;
          }
        }
      }
    }
    if (num_surface_products == 1) {
      if (is_unimol &amp;&amp; replace_p1) {
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if (rx_players[n_product] == NULL ||</b></font>
             (rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0) {
            continue;
          }
          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
            product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
            product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
            replace_p1 = 0;
            break;
          }
        }
      } else if ((num_surface_static_reactants == 1) &amp;&amp; (num_surface_static_products == 1)
          &amp;&amp; (replace_p1 || replace_p2)) {
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if (rx_players[n_product] == NULL ||
              (rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0 ||
              distinguishable(rx_players[n_product]-&gt;D, 0, EPS_C)) {
<a name="3"></a>            continue;
          }
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            if (replace_p1 &amp;&amp; (!distinguishable(reacA-&gt;properties-&gt;D, 0, EPS_C))) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
              product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
              product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
              replace_p1 = 0;
              break;
            } else if (replace_p2 &amp;&amp; (!distinguishable(reacB-&gt;properties-&gt;D, 0, EPS_C))) {
<a name="13"></a>              product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
              product_grid[n_product] = ((struct surface_molecule *)reacB)-&gt;grid;
              product_grid_idx[n_product] = ((struct surface_molecule *)reacB)-&gt;grid_index;</b></font>
<font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>              break;
            }
          }
        }
      } else if (replace_p1 &amp;&amp; replace_p2) {
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if ((rx_players[n_product] == NULL) ||</b></font>
              ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
            continue;
<a name="9"></a>          }
          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>            if (reacA == initiator) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
              product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
              product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
              replace_p1 = 0;
            } else {
<a name="12"></a>              product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
              product_grid[n_product] = ((struct surface_molecule *)reacB)-&gt;grid;
              product_grid_idx[n_product] = ((struct surface_molecule *)reacB)-&gt;grid_index;</b></font>
<font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>            }
            break;
          }
        }
      } else if (replace_p1) {
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if ((rx_players[n_product] == NULL) ||</b></font>
              ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
            continue;
          }
          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
            product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
            product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
            replace_p1 = 0;
            break;
          }
        }
      } else if (replace_p2) {
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if ((rx_players[n_product] == NULL) |
              ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
            continue;
          }
          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
            product_grid[n_product] = ((struct surface_molecule *)reacB)-&gt;grid;
            product_grid_idx[n_product] = ((struct surface_molecule *)reacB)-&gt;grid_index;
            break;
          }
        }
      }
    } else if (num_surface_products &gt; 1) {
      if (num_surface_static_reactants &gt; 0) {
        bool replace_reacA = (!distinguishable(reacA-&gt;get_diffusion(reacA), 0, EPS_C)) &amp;&amp; replace_p1;
        bool replace_reacB =
            (reacB == NULL) ? false : (!distinguishable(reacB-&gt;get_diffusion(reacB), 0, EPS_C)) &amp;&amp; replace_p2;
        if (replace_reacA || replace_reacB) {
          int max_static_count = (num_surface_static_products &lt; num_surface_static_reactants)
            ? num_surface_static_products : num_surface_static_reactants;
          int count = 0;
          while (count &lt; max_static_count) {
            unsigned int rnd_num = rng_uint(world-&gt;rng) % n_players;
            if ((rnd_num &lt; rx-&gt;n_reactants) || (rx_players[rnd_num] == NULL) ||
                ((rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0) ||
                distinguishable(rx_players[rnd_num]-&gt;D, 0, EPS_C)) {
              continue;
            }
            if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
              if (replace_reacA) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
                product_grid[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid;
                product_grid_idx[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid_index;
                count++;
                replace_p1 = 0;
                replace_reacA = 0;
              } else if (replace_reacB) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
                product_grid[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid;
                product_grid_idx[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid_index;
<a name="6"></a>                count++;
                replace_p2 = 0;
                replace_reacB = 0;
<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>              }
            }
          }         }
      }
      if (replace_p1 || replace_p2) {
        int surf_prod_left = 0, surf_reactant_left = 0;
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if ((rx_players[n_product] == NULL) ||</b></font>
              ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
            continue;
          }
          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            surf_prod_left++;
          }
        }
        if (replace_p1) {
          surf_reactant_left++;
        }
        if (replace_p2) {
          surf_reactant_left++;
        }
        if (surf_prod_left &gt; 0) {
          int num_to_place = surf_prod_left;
          if (surf_prod_left &gt;= surf_reactant_left) {
            num_to_place = surf_reactant_left;
          }
          int count = 0;
          while (count &lt; num_to_place) {
            unsigned int rnd_num = rng_uint(world-&gt;rng) % n_players;
            if ((rnd_num &lt; rx-&gt;n_reactants) || (rx_players[rnd_num] == NULL) ||
                (rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0) {
             continue;
            }
            if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
              if (replace_p1) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
                product_grid[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid;
                product_grid_idx[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid_index;
                count++;
                replace_p1 = 0;
              } else if (replace_p2) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
                product_grid[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid;
                product_grid_idx[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid_index;
                replace_p2 = 0;
                count++;
              }
            }
          }         }
      }
    }
    if ((sm_reactant == NULL) &amp;&amp; (w != NULL) &amp;&amp; (num_surface_products &gt;= 1)) {
      assert(!IS_SURF_MOL(reacA));
      assert(rxn_uv_idx != -1);
      while (true) {
        unsigned int rnd_num = rng_uint(world-&gt;rng) % (n_players);
        if (rnd_num &lt;= 1 || (rx_players[rnd_num] == NULL) ||
            (rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0) {
          continue;
        }
        if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
          product_flag[rnd_num] = PRODUCT_FLAG_USE_UV_LOC;
          product_grid[rnd_num] = w-&gt;grid;
          product_grid_idx[rnd_num] = rxn_uv_idx;
          break;
        }
      }
    }
    if (is_unimol &amp;&amp; (sm_reactant != NULL) &amp;&amp; (num_surface_products == 2)) {
      reac_idx = sm_reactant-&gt;grid_index;
      reac_grid = sm_reactant-&gt;grid;
    }
    int do_it_once = 0;     int num_attempts = 0;
    for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
      if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
        if (product_flag[n_product] != PRODUCT_FLAG_NOT_SET) {
          continue;
        }
        if (num_vacant_tiles == 0) {
          return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
        }
        num_attempts = 0;
        while (true) {
          if (num_attempts &gt; SURFACE_DIFFUSION_RETRIES) {
            return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
          }
          unsigned int rnd_num = rng_uint(world-&gt;rng) % num_vacant_tiles;
          int tile_idx = -1;           tile_grid = NULL;
          if (get_tile_neighbor_from_list_of_vacant_neighbors(
                  tile_vacant_nbr_head, rnd_num, &amp;tile_grid, &amp;tile_idx) == 0) {
            return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
          }
          if (tile_idx &lt; 0) {
            continue;           }
          assert(tile_grid != NULL);
          if (!product_tile_can_be_reached(tile_grid-&gt;surface, rlp_head_wall_1,
            rlp_head_wall_2, rlp_head_obj_1, rlp_head_obj_2, sm_bitmask, is_unimol)) {
            uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
            num_attempts++;
            continue;
          }
          product_grid[n_product] = tile_grid;
          product_grid_idx[n_product] = tile_idx;
          product_flag[n_product] = PRODUCT_FLAG_USE_RANDOM;
          if (!do_it_once &amp;&amp; is_unimol &amp;&amp; (sm_reactant != NULL) &amp;&amp; (num_surface_products == 2)) {
            mol_idx = tile_idx;
            mol_grid = tile_grid;
            do_it_once = 1;
          }
          break;
        }       }
    }
  } 
  struct vector3 count_pos_xyz;
  struct periodic_image *periodic_box = ((struct volume_molecule *)reacA)-&gt;periodic_box;
  if (hitpt != NULL) {
    count_pos_xyz = *hitpt;
  } else if (sm_reactant) {
    uv2xyz(&amp;sm_reactant-&gt;s_pos, sm_reactant-&gt;grid-&gt;surface, &amp;count_pos_xyz);
  } else {
    count_pos_xyz = ((struct volume_molecule *)reacA)-&gt;pos;
  }
  struct vector3 mol_pos_tmp;
  struct subvolume *product_subvol = NULL;
  bool update_dissociation_index = false; 
  for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
<a name="15"></a>    struct graph_data* g_data = NULL;
    if (rx-&gt;product_graph_data != NULL)
      g_data = rx-&gt;product_graph_data[path][n_product - rx-&gt;n_reactants];
<font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    struct abstract_molecule *this_product = NULL;
    struct species *const product_species = rx_players[n_product];
    if (product_species-&gt;flags &amp; ON_GRID) {
      struct vector2 prod_uv_pos;
      if (world-&gt;randomize_smol_pos) {
        switch (product_flag[n_product]) {
        case PRODUCT_FLAG_USE_REACA_UV:</b></font>
          if (is_unimol &amp;&amp; (num_surface_products == 2) &amp;&amp; (sm_reactant != NULL)) {
            if (mol_grid == NULL) {
              mcell_internal_error("Error in surface product placement for the "
                                   "unimolecular reaction.");
            }
            find_closest_position(product_grid[n_product], product_grid_idx[n_product],
              mol_grid, mol_idx, &amp;prod_uv_pos);
          } else {
            prod_uv_pos = ((struct surface_molecule *)reacA)-&gt;s_pos;
          }
          break;
        case PRODUCT_FLAG_USE_REACB_UV:
          assert(reacB != NULL);
          prod_uv_pos = ((struct surface_molecule *)reacB)-&gt;s_pos;
          break;
        case PRODUCT_FLAG_USE_UV_LOC:
          prod_uv_pos = rxn_uv_pos;
          break;
        case PRODUCT_FLAG_USE_RANDOM:
          if (is_unimol &amp;&amp; replace_p1 &amp;&amp; (num_surface_products == 2)) {
            find_closest_position(product_grid[n_product],
                                  product_grid_idx[n_product], reac_grid,
                                  reac_idx, &amp;prod_uv_pos);
          } else {
            grid2uv_random(product_grid[n_product], product_grid_idx[n_product],
                           &amp;prod_uv_pos, world-&gt;rng);
          }
          break;
        default:
          UNHANDLED_CASE(product_flag[n_product]);
        }
      } else {
        grid2uv(product_grid[n_product], product_grid_idx[n_product], &amp;prod_uv_pos);
      }
      this_product = (struct abstract_molecule *)place_sm_product(
          world, product_species, g_data, product_grid[n_product],
          product_grid_idx[n_product], &amp;prod_uv_pos, product_orient[n_product],
          t, reacA-&gt;periodic_box);
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
          dump_surface_molecule((struct surface_molecule*)this_product, "", true, "  created sm:", world-&gt;current_iterations, this_product-&gt;t, true);
      );
#endif
      if (!hitpt) {
        if (reacA-&gt;properties-&gt;flags &amp; ON_GRID) {
          w = ((struct surface_molecule *)reacA)-&gt;grid-&gt;surface;
          uv2xyz(&amp;((struct surface_molecule *)reacA)-&gt;s_pos,
                 w, &amp;mol_pos_tmp);
          product_subvol = find_subvolume(world, &amp;mol_pos_tmp, NULL);
        } else {
          mol_pos_tmp = ((struct volume_molecule *)reacA)-&gt;pos;
          product_subvol = ((struct volume_molecule *)reacA)-&gt;subvol;
        }
        hitpt = &amp;mol_pos_tmp;
      } else if (product_subvol == NULL) {
        product_subvol = find_subvolume(world, hitpt, NULL);
      }
      this_product = (struct abstract_molecule *)place_volume_product(
          world, product_species, g_data, sm_reactant, w, product_subvol, hitpt,
          product_orient[n_product], t, reacA-&gt;periodic_box);
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
      		dump_volume_molecule((struct volume_molecule*)this_product, "", true, "  created vm:", world-&gt;current_iterations, this_product-&gt;t, true);
      );
#endif
      if (((struct volume_molecule *)this_product)-&gt;index &lt; DISSOCIATION_MAX)
        update_dissociation_index = true;
    }
    if(rx-&gt;product_graph_data != NULL){
      this_product-&gt;graph_data = g_data;
    }
    ++product_species-&gt;population;
    if (product_species-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED))
      count_region_from_scratch(world, this_product, NULL, 1, NULL, NULL, t, this_product-&gt;periodic_box);
#ifndef MCELL3_DO_NOT_REUSE_MOL_ID_UNIMOL_RXN
    if (is_unimol &amp;&amp; (n_players == 1)) {
      this_product-&gt;id = reacA-&gt;id;
      world-&gt;current_mol_id--;       continue;
    }
    if ((n_players == 3) &amp;&amp; product_type[1] == PLAYER_WALL) {
      this_product-&gt;id = reacA-&gt;id;
      world-&gt;current_mol_id--; <a name="19"></a>      continue;
    }
#endif
<font color="#f62817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  }
  if (update_dissociation_index) {
    ASSERT_FOR_MCELL4(false);
    if (--world-&gt;dissociation_index &lt; DISSOCIATION_MIN)
      world-&gt;dissociation_index = DISSOCIATION_MAX;
  }
  if (rx-&gt;info[path].pathname != NULL) {
    if (world-&gt;place_waypoints_flag)
      count_region_from_scratch(world, NULL, rx-&gt;info[path].pathname, 1,</b></font>
                                &amp;count_pos_xyz, w, t, periodic_box);
    if (rx-&gt;info[path].pathname-&gt;magic != NULL) {
      if (reaction_wizardry(world, rx-&gt;info[path].pathname-&gt;magic, w,
                            &amp;count_pos_xyz, t))
        mcell_allocfailed("Failed to complete reaction triggered release after "
                          "a '%s' reaction.",
                          rx-&gt;info[path].pathname-&gt;sym-&gt;name);
    }
  }
  delete_tile_neighbor_list(tile_nbr_head);
  delete_tile_neighbor_list(tile_vacant_nbr_head);
  delete_region_list(rlp_head_wall_1);
  delete_region_list(rlp_head_wall_2);
  delete_region_list(rlp_head_obj_1);
  delete_region_list(rlp_head_obj_2);
  return cross_wall ? RX_FLIP : RX_A_OK;
}
int outcome_unimolecular(struct volume *world, struct rxn *rx, int path,
                         struct abstract_molecule *reac, double t) {
  struct species *who_was_i = reac-&gt;properties;
  int result = RX_A_OK;
  struct volume_molecule *vm = NULL;
  struct surface_molecule *sm = NULL;
  if ((reac-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
    vm = (struct volume_molecule *)reac;
    if(reac-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
#if 0       for (int path = 0; path &lt; rx-&gt;n_pathways; path++) {
        outcome_nfsim(world, rx, path, reac, NULL, t);
      }
#else
      outcome_nfsim(world, rx, path, reac, NULL, t);
#endif
    }
    result = outcome_products_random(world, NULL, NULL, t, rx, path, reac,
                                       NULL, 0, 0);
  } else {
    sm = (struct surface_molecule *)reac;
      if ((strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_SURFACE_MOLECULES") == 0) ||
          (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_MOLECULES") == 0)) {
      } else {
        if(reac-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
          outcome_nfsim(world, rx, path, reac, NULL, t);
        }
        result = outcome_products_random(world, sm-&gt;grid-&gt;surface, NULL, t, rx,
                                         path, reac, NULL, sm-&gt;orient, 0);
      }
  }
  if (result == RX_BLOCKED)
    return RX_BLOCKED;
  if (result != RX_BLOCKED) {
    rx-&gt;info[path].count++;
    rx-&gt;n_occurred++;
    if(rx-&gt;product_graph_data != NULL){
      logNFSimReactions_c(rx-&gt;external_reaction_data[path].reaction_name);
    }
  }
  struct species *who_am_i = rx-&gt;players[rx-&gt;product_idx[path]];
  if (who_am_i == NULL) {
    if (vm != NULL) {
      vm-&gt;subvol-&gt;mol_count--;
      if (vm-&gt;flags &amp; IN_SCHEDULE)
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      if (vm-&gt;properties-&gt;flags &amp; COUNT_SOME_MASK) {
        count_region_from_scratch(world, (struct abstract_molecule *)vm, NULL,
                                  -1, &amp;(vm-&gt;pos), NULL, vm-&gt;t, vm-&gt;periodic_box);
      }
    } else {
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
        dump_surface_molecule(sm, "", true, "Unimolecular sm defunct:", world-&gt;current_iterations, sm-&gt;t, false);
      );
#endif
      remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
      sm-&gt;grid-&gt;n_occupied--;
      if (sm-&gt;flags &amp; IN_SCHEDULE) {
        sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
      if (sm-&gt;properties-&gt;flags &amp; COUNT_SOME_MASK) {
        count_region_from_scratch(world, (struct abstract_molecule *)sm, NULL,
                                  -1, NULL, NULL, sm-&gt;t, sm-&gt;periodic_box);
      }
    }
    free(reac-&gt;periodic_box);
    who_was_i-&gt;n_deceased++;
    double t_time = convert_iterations_to_seconds(
        world-&gt;start_iterations, world-&gt;time_unit,
        world-&gt;simulation_start_seconds, t);
    who_was_i-&gt;cum_lifetime_seconds += t_time - reac-&gt;birthday;
    who_was_i-&gt;population--;
    if (vm != NULL) {
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
        dump_volume_molecule(vm, "", true, "Unimolecular vm defunct:", world-&gt;current_iterations, vm-&gt;t, false);
      );
#endif
      collect_molecule(vm);
    }
    else {
      reac-&gt;properties = NULL;
      mem_put(reac-&gt;birthplace, reac);
    }
    return RX_DESTROY;
  } else if (who_am_i != who_was_i) {
    if (vm != NULL) {
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
        dump_volume_molecule(vm, "", true, "Unimolecular vm defunct:", world-&gt;current_iterations, vm-&gt;t, false);
      );
#endif
      collect_molecule(vm);
    }
    else
      reac-&gt;properties = NULL;
    return RX_DESTROY;
  } else
    return result;
}
int outcome_bimolecular(struct volume *world, struct rxn *rx, int path,
                        struct abstract_molecule *reacA,
                        struct abstract_molecule *reacB, short orientA,
                        short orientB, double t, struct vector3 *hitpt,
                        struct vector3 *loc_okay) {
#ifdef DEBUG_TIMING
  DUMP_CONDITION3(
      MCell::dump_outcome_bimolecular_timing(t);
  );
#endif
<a name="18"></a>
  assert(periodic_boxes_are_identical(reacA-&gt;periodic_box, reacB-&gt;periodic_box));
<font color="#800517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  struct surface_molecule *sm = NULL;
  struct volume_molecule *vm = NULL;
  struct wall *w = NULL;
  int result;
  int reacB_was_free = 0;</b></font>
  int killA, killB;
  if ((reacA-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
    if ((reacB-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
      sm = (struct surface_molecule *)reacB;
      w = sm-&gt;grid-&gt;surface;
    }
  } else {     sm = (struct surface_molecule *)reacA;
    w = sm-&gt;grid-&gt;surface;
  }
  if(reacA-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
    result = outcome_nfsim(world, rx, path, reacA, reacB, t);
    result = outcome_products_random(world, w, hitpt, t, rx, path, reacA, reacB,
                                     orientA, orientB);
  }
  else {
    result = outcome_products_random(world, w, hitpt, t, rx, path, reacA, reacB,
                                     orientA, orientB);
  }
  if (result == RX_BLOCKED)
    return RX_BLOCKED;
  rx-&gt;n_occurred++;
  rx-&gt;info[path].count++;
  if(rx-&gt;product_graph_data != NULL){
    logNFSimReactions_c(rx-&gt;external_reaction_data[path].reaction_name);
  }
  if (rx-&gt;players[0] == reacA-&gt;properties) {
    killB = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
    killA = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
  } else {
    killB = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
    killA = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
  }
  if (killB) {
#ifdef DEBUG_RXNS
    DUMP_CONDITION3(
      dump_volume_molecule((struct volume_molecule*)reacB, "", true, "  defunct m:", world-&gt;current_iterations, 0.0, false);
<a name="11"></a>    );
#endif
<font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    vm = NULL;
    if ((reacB-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
      sm = (struct surface_molecule *)reacB;
      remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
      sm-&gt;grid-&gt;n_occupied--;
      if (sm-&gt;flags &amp; IN_SURFACE)
        sm-&gt;flags -= IN_SURFACE;
      if (sm-&gt;flags &amp; IN_SCHEDULE) {
        sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
    } else if ((reacB-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {</b></font>
      vm = (struct volume_molecule *)reacB;
      vm-&gt;subvol-&gt;mol_count--;
      if (vm-&gt;flags &amp; IN_SCHEDULE) {
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
      reacB_was_free = 1;
    }
    if ((reacB-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) != 0) {
      count_region_from_scratch(world, reacB, NULL, -1, NULL, NULL, t, reacB-&gt;periodic_box);
    }
    free(reacB-&gt;periodic_box);
    reacB-&gt;periodic_box = NULL;
    reacB-&gt;properties-&gt;n_deceased++;
    double t_time = convert_iterations_to_seconds(
        world-&gt;start_iterations, world-&gt;time_unit,
        world-&gt;simulation_start_seconds, t);
    reacB-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacB-&gt;birthday;
    reacB-&gt;properties-&gt;population--;
    if (vm != NULL)
      collect_molecule(vm);
    else
      reacB-&gt;properties = NULL;
  }
  if (killA) {
#ifdef DEBUG_RXNS
    DUMP_CONDITION3(
      dump_volume_molecule((struct volume_molecule*)reacA, "", true, "  defunct m:", world-&gt;current_iterations, 0.0, false);
    );
#endif
    vm = NULL;
    if ((reacA-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
      sm = (struct surface_molecule *)reacA;
      remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
      sm-&gt;grid-&gt;n_occupied--;
<a name="8"></a>      if (sm-&gt;flags &amp; IN_SCHEDULE) {
        sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    } else if ((reacA-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
      vm = (struct volume_molecule *)reacA;
      vm-&gt;subvol-&gt;mol_count--;
      if (vm-&gt;flags &amp; IN_SCHEDULE) {
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
    }
    if ((reacA-&gt;properties-&gt;flags &amp; ON_GRID) !=
        0)     {
      if (reacA-&gt;properties-&gt;flags &amp;
          COUNT_SOME_MASK)       {
        count_region_from_scratch(world, reacA, NULL, -1, NULL, NULL, t, reacA-&gt;periodic_box);</b></font>
      }
    } else if (reacA-&gt;flags &amp; COUNT_ME) {
      if (hitpt == NULL || reacB_was_free ||
<a name="7"></a>          (reacB-&gt;properties != NULL &amp;&amp;
           (reacB-&gt;properties-&gt;flags &amp; NOT_FREE) == 0)) {
<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        count_region_from_scratch(world, reacA, NULL, -1, hitpt, NULL, t, reacA-&gt;periodic_box);
      {
        struct vector3 fake_hitpt;
        vm = (struct volume_molecule *)reacA;
        if (loc_okay == NULL)
          loc_okay = &amp;(vm-&gt;pos);
        fake_hitpt.x = 0.5 * hitpt-&gt;x + 0.5 * loc_okay-&gt;x;
        fake_hitpt.y = 0.5 * hitpt-&gt;y + 0.5 * loc_okay-&gt;y;
        fake_hitpt.z = 0.5 * hitpt-&gt;z + 0.5 * loc_okay-&gt;z;
        count_region_from_scratch(world, reacA, NULL, -1, &amp;fake_hitpt, NULL, t, reacA-&gt;periodic_box);</b></font>
      }
    }
<a name="14"></a>
    free(reacA-&gt;periodic_box);
    reacA-&gt;periodic_box = NULL;
<font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    reacA-&gt;properties-&gt;n_deceased++;
    double t_time = convert_iterations_to_seconds(
        world-&gt;start_iterations, world-&gt;time_unit,
        world-&gt;simulation_start_seconds, t);
    reacA-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacA-&gt;birthday;
    reacA-&gt;properties-&gt;population--;
    if (vm != NULL)
      collect_molecule(vm);
    else
      reacA-&gt;properties = NULL;
    return RX_DESTROY;
  }
  return result;
}</b></font>
int outcome_intersect(struct volume *world, struct rxn *rx, int path,
                      struct wall *surface, struct abstract_molecule *reac,
                      short orient, double t, struct vector3 *hitpt,
                      struct vector3 *loc_okay) {
  if (rx-&gt;n_pathways &lt;= RX_SPECIAL) {
    rx-&gt;n_occurred++;
    if (rx-&gt;n_pathways == RX_REFLEC)
      return RX_A_OK;
    else
      return RX_FLIP;   }
  int idx = rx-&gt;product_idx[path];
  if ((reac-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
    struct volume_molecule *vm = (struct volume_molecule *)reac;
    int result;
    if ((strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_MOLECULES") == 0) ||
        (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_VOLUME_MOLECULES") == 0)) {
      result = RX_DESTROY;
    } else {
      result = outcome_products_random(world, surface, hitpt, t, rx, path,
                                       reac, NULL, orient, 0);
    }
    if (result == RX_BLOCKED)
      return RX_A_OK; 
    rx-&gt;info[path].count++;
    rx-&gt;n_occurred++;
    if (rx-&gt;players[idx] == NULL) {
      vm-&gt;subvol-&gt;mol_count--;
      if (world-&gt;place_waypoints_flag &amp;&amp; (reac-&gt;flags &amp; COUNT_ME)) {
        if (hitpt == NULL) {
          count_region_from_scratch(
            world, reac, NULL, -1, NULL, NULL, t, reac-&gt;periodic_box);
        } else {
          struct vector3 fake_hitpt;
          if (loc_okay == NULL)
            loc_okay = &amp;(vm-&gt;pos);
          fake_hitpt.x = 0.5 * hitpt-&gt;x + 0.5 * loc_okay-&gt;x;
          fake_hitpt.y = 0.5 * hitpt-&gt;y + 0.5 * loc_okay-&gt;y;
          fake_hitpt.z = 0.5 * hitpt-&gt;z + 0.5 * loc_okay-&gt;z;
          count_region_from_scratch(world, reac, NULL, -1, &amp;fake_hitpt, NULL,
                                    t, reac-&gt;periodic_box);
        }
      }
      free(reac-&gt;periodic_box);
      reac-&gt;properties-&gt;n_deceased++;
      double t_time = convert_iterations_to_seconds(
          world-&gt;start_iterations, world-&gt;time_unit,
          world-&gt;simulation_start_seconds, t);
      reac-&gt;properties-&gt;cum_lifetime_seconds += t_time - reac-&gt;birthday;
      reac-&gt;properties-&gt;population--;
      if (vm-&gt;flags &amp; IN_SCHEDULE) {
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
         dump_volume_molecule((struct volume_molecule*)vm, "", true, "  defunct m:", world-&gt;current_iterations, 0.0, false);
      );
#endif
      collect_molecule(vm);
      return RX_DESTROY;
    } else
      return result;   } else {
    return RX_A_OK;
  }
}
int reaction_wizardry(struct volume *world, struct magic_list *incantation,
                      struct wall *surface, struct vector3 *hitpt, double t) {
  struct release_event_queue req; 
  req.next = NULL;
  req.event_time = t;
  req.train_counter = 0;
  req.train_high_time = t;
  if (hitpt == NULL) {
    init_matrix(req.t_matrix);
  } else if (surface == NULL ||
             !distinguishable(surface-&gt;normal.z, 1.0,
                              EPS_C))   {
    init_matrix(req.t_matrix);
    req.t_matrix[3][0] = hitpt-&gt;x;
    req.t_matrix[3][1] = hitpt-&gt;y;
    req.t_matrix[3][2] = hitpt-&gt;z;
  {
    struct vector3 scale = { 1.0, 1.0, 1.0 };     struct vector3 axis = { 1.0, 0.0, 0.0 };      double cos_theta;
    double degrees;
    cos_theta = surface-&gt;normal.z;     if (!distinguishable(cos_theta, -1.0, EPS_C)) {
      degrees = 180.0;     } else {
      axis.x = -surface-&gt;normal.y;
      axis.y = surface-&gt;normal.x;
      axis.z = 0.0;
      degrees = acos(cos_theta) * 180.0 / MY_PI;
    }
    tform_matrix(&amp;scale, hitpt, &amp;axis, degrees, req.t_matrix);
  }
  for (; incantation != NULL; incantation = incantation-&gt;next) {
    if (incantation-&gt;type != magic_release)
      continue; 
    req.release_site = (struct release_site_obj *)incantation-&gt;data;
    if (release_molecules(world, &amp;req))
      return 1;
  }
  return 0;
}
int determine_molecule_region_topology(
    struct volume *world, struct surface_molecule *sm_1,
    struct surface_molecule *sm_2, struct region_list **rlp_wall_1_ptr,
    struct region_list **rlp_wall_2_ptr, struct region_list **rlp_obj_1_ptr,
    struct region_list **rlp_obj_2_ptr, bool is_unimol) {
  int sm_bitmask = 0;
  struct wall *w_1, *w_2;
  struct region_list *rlp_head_wall_1 = NULL;
  struct region_list *rlp_head_wall_2 = NULL;
  struct region_list *rlp_head_obj_1 = NULL;
  struct region_list *rlp_head_obj_2 = NULL;
<a name="5"></a>    if ((sm_1 != NULL) &amp;&amp; (sm_2 != NULL)) {
<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
        (sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
        are_restricted_regions_for_species_on_object(
            world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
        are_restricted_regions_for_species_on_object(
            world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2)) {
      w_1 = sm_1-&gt;grid-&gt;surface;
      w_2 = sm_2-&gt;grid-&gt;surface;
      rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
      rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
      if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 != NULL)) {
        sm_bitmask |= ALL_INSIDE;
      }
      else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 == NULL)) {
        rlp_head_obj_1 =
<a name="10"></a>            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        rlp_head_obj_2 =</b></font>
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
<font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        sm_bitmask |= ALL_OUTSIDE;
      }
      else if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 == NULL)) {
        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        sm_bitmask |= SURF1_IN_SURF2_OUT;
      }
      else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 != NULL)) {</b></font>
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        sm_bitmask |= SURF1_OUT_SURF2_IN;
      }
    }
    else if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
             are_restricted_regions_for_species_on_object(
                 world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
             (!(sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
              !are_restricted_regions_for_species_on_object(
                   world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2))) {
      w_1 = sm_1-&gt;grid-&gt;surface;
      rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
      if (rlp_head_wall_1 != NULL) {
        sm_bitmask |= SURF1_IN;
      } else {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        sm_bitmask |= SURF1_OUT;
      }
    }
    else if ((sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
             are_restricted_regions_for_species_on_object(
                 world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2) &amp;&amp;
             (!(sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
              !are_restricted_regions_for_species_on_object(
                   world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1))) {
      w_2 = sm_2-&gt;grid-&gt;surface;
      rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
      if (rlp_head_wall_2 != NULL) {</b></font>
        sm_bitmask |= SURF2_IN;
      } else {
        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        sm_bitmask |= SURF2_OUT;
      }
    }
  }
  else if ((sm_1 != NULL) &amp;&amp; is_unimol) {
    if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
        are_restricted_regions_for_species_on_object(
            world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1)) {
      w_1 = sm_1-&gt;grid-&gt;surface;
      rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
      if (rlp_head_wall_1 != NULL) {
        sm_bitmask |= ALL_INSIDE;
      } else {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        sm_bitmask |= ALL_OUTSIDE;
      }
    }
  }
  *rlp_wall_1_ptr = rlp_head_wall_1;
  *rlp_wall_2_ptr = rlp_head_wall_2;
  *rlp_obj_1_ptr = rlp_head_obj_1;
  *rlp_obj_2_ptr = rlp_head_obj_2;
  return sm_bitmask;
}
bool product_tile_can_be_reached(struct wall *target,
                                 struct region_list *rlp_head_wall_1,
                                 struct region_list *rlp_head_wall_2,
                                 struct region_list *rlp_head_obj_1,
                                 struct region_list *rlp_head_obj_2,
                                 int sm_bitmask, bool is_unimol) {
  bool status = true;
  if (sm_bitmask &amp; ALL_INSIDE) {
    if (is_unimol) {
      if (!wall_belongs_to_all_regions_in_region_list(target,
                                                      rlp_head_wall_1)) {
        status = false;
      }
    } else {
      if (!wall_belongs_to_all_regions_in_region_list(target,
                                                      rlp_head_wall_1) ||
          !wall_belongs_to_all_regions_in_region_list(target,
                                                      rlp_head_wall_2)) {
        status = false;
      }
    }
  } else if (sm_bitmask &amp; ALL_OUTSIDE) {
    if (is_unimol) {
      if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1)) {
        status = false;
      }
    } else {
      if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1) ||
          wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_2)) {
        status = false;
      }
    }
  } else if (sm_bitmask &amp; SURF1_IN_SURF2_OUT) {
    if (!wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_1) ||
        wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_2)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF1_OUT_SURF2_IN) {
    if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1) ||
        !wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_2)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF1_IN) {
    if (!wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_1)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF1_OUT) {
    if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF2_IN) {
    if (!wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_2)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF2_OUT) {
    if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_2)) {
      status = false;
    }
  }
  return status;
}
int cleanup_and_block_rx(struct tile_neighbor *tn1, struct tile_neighbor *tn2) {
  if (tn1 != NULL) {
    delete_tile_neighbor_list(tn1);
  }
  if (tn2 != NULL) {
    delete_tile_neighbor_list(tn2);
  }
  return RX_BLOCKED;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>react_outc_trimol.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;vector&gt;
#include "logging.h"
#include "rng.h"
#include "util.h"
#include "grid_util.h"
#include "mcell_structs.h"
#include "count_util.h"
#include "react.h"
#include "vol_util.h"
#include "wall_util.h"
static int outcome_products_trimol_reaction_random(
    struct volume *world, struct wall *w, struct vector3 *hitpt, double t,
    struct rxn *rx, int path, struct abstract_molecule *reacA,
    struct abstract_molecule *reacB, struct abstract_molecule *reacC,
    short orientA, short orientB, short orientC);
static int outcome_products_trimol_reaction_random(
    struct volume *world, struct wall *w, struct vector3 *hitpt, double t,
    struct rxn *rx, int path, struct abstract_molecule *reacA,
    struct abstract_molecule *reacB, struct abstract_molecule *reacC,
    short orientA, short orientB, short orientC) {
  if (reacA != NULL &amp;&amp; reacB != NULL) {
    assert(periodic_boxes_are_identical(reacA-&gt;periodic_box, reacB-&gt;periodic_box));
  } else if (reacA != NULL &amp;&amp; reacC != NULL) {
    assert(periodic_boxes_are_identical(reacA-&gt;periodic_box, reacC-&gt;periodic_box));
  } else if (reacB != NULL &amp;&amp; reacC != NULL) {
    assert(periodic_boxes_are_identical(reacB-&gt;periodic_box, reacC-&gt;periodic_box));
  }
  bool update_dissociation_index =
      false;                 bool cross_wall = false; <a name="2"></a>  struct subvolume *last_subvol =
      NULL; 
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  int const i0 =
      rx-&gt;product_idx[path];   int const iN =
  assert(iN &gt; i0);
  struct species **rx_players =
      rx-&gt;players + i0; 
  int const n_players = iN - i0;                
  std::vector&lt;struct abstract_molecule *&gt; product(n_players);   std::vector&lt;char&gt; product_type(n_players);
  std::vector&lt;short&gt; product_orient(n_players);   std::vector&lt;struct surface_grid *&gt; product_grid(n_players);
  std::vector&lt;int&gt; product_grid_idx(n_players);   std::vector&lt;byte&gt; product_flag(n_players);    
  struct tile_neighbor *tile_nbr_head = NULL;   struct tile_neighbor *tile_nbr;               struct tile_neighbor *tile_vacant_nbr_head = NULL;
  struct surface_grid *tile_grid;   int tile_idx;                     unsigned int rnd_num;             int num_vacant_tiles = 0;         int num_surface_products = 0;     int num_surface_static_products =
      0;   int num_surface_static_reactants = 0;   int num_surface_reactants = 0;
  int num_surface_reactants_to_stay = 0;
  int list_length;   int replace_p1 = 0, replace_p2 = 0, replace_p3 = 0, only_one_to_replace = 0,
      two_to_replace = 0;
  int find_neighbor_tiles_flag = 0;
  struct wall *w_1, *w_2, *w_3;
  int all_inside_restricted_boundary = 0;
  int all_outside_restricted_boundary = 0;
  int sm_1_inside_sm_2_inside_grid_3_outside = 0;
  int sm_1_inside_sm_2_outside_grid_3_inside = 0;
  int sm_1_outside_sm_2_inside_grid_3_inside = 0;
  int sm_1_inside_sm_2_outside_grid_3_outside = 0;
  int sm_1_outside_sm_2_inside_grid_3_outside = 0;
  int sm_1_outside_sm_2_outside_grid_3_inside = 0;
  int only_sm_1_sm_2_inside = 0;
  int only_sm_1_inside_sm_2_outside = 0;
  int only_sm_1_outside_sm_2_inside = 0;
  int only_sm_1_sm_2_outside = 0;
  int only_sm_1_grid_3_inside = 0;
  int only_sm_1_inside_grid_3_outside = 0;
  int only_sm_1_outside_grid_3_inside = 0;
  int only_sm_1_grid_3_outside = 0;
  int only_sm_2_grid_3_inside = 0;
  int only_sm_2_inside_grid_3_outside = 0;
  int only_sm_2_outside_grid_3_inside = 0;
  int only_sm_2_grid_3_outside = 0;
  int only_sm_1_inside = 0;
  int only_sm_1_outside = 0;
  int only_sm_2_inside = 0;
  int only_sm_2_outside = 0;
  int only_grid_3_inside = 0;
  int only_grid_3_outside = 0;
  struct region_list *rlp_head_wall_1 = NULL, *rlp_head_wall_2 = NULL,
                     *rlp_head_wall_3 = NULL;
  struct region_list *rlp_head_obj_1 = NULL, *rlp_head_obj_2 = NULL,
                     *rlp_head_obj_3 = NULL;
  struct vector2 rxn_uv_pos;   int rxn_uv_idx = -1;       
  struct abstract_molecule *tmp_mol;
  short tmp_orient;
  if ((reacA == NULL) || (reacB == NULL) || (reacC == NULL)) {
    mcell_internal_error("One of the reactants in "
                         "'outcome_products_trimol_reaction_random()' is "
                         "NULL.");
<a name="0"></a>  }
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  for (int i = 0; i &lt; n_players; ++i) {
    product[i] = NULL;
    product_type[i] = PLAYER_NONE;
    product_orient[i] = 0;
    product_grid[i] = NULL;
    product_grid_idx[i] = -1;
    product_flag[i] = PRODUCT_FLAG_NOT_SET;
  }
  struct surface_molecule *const sm_1 =
      IS_SURF_MOL(reacA) ? (struct surface_molecule *)reacA : NULL;
  struct surface_molecule *const sm_2 =
      IS_SURF_MOL(reacB) ? (struct surface_molecule *)reacB : NULL;
  struct surface_molecule *const grid_3 =
      IS_SURF_MOL(reacC) ? (struct surface_molecule *)reacC : NULL;</b></font>
  struct surface_molecule *sm_reactant = NULL;
  if (sm_1 != NULL) {
    sm_reactant = sm_1;
  } else if (sm_2 != NULL) {
    sm_reactant = sm_2;
  } else if (grid_3 != NULL) {
    sm_reactant = grid_3;
  }
  bool const is_orientable = (w != NULL) || (sm_reactant != NULL);
  if ((sm_1 != NULL) &amp;&amp; (sm_2 != NULL) &amp;&amp; (grid_3 != NULL)) {
    if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
        (sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
        (grid_3-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
        are_restricted_regions_for_species_on_object(
            world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
        are_restricted_regions_for_species_on_object(
            world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2) &amp;&amp;
        are_restricted_regions_for_species_on_object(
            world, grid_3-&gt;grid-&gt;surface-&gt;parent_object, grid_3)) {
      w_1 = sm_1-&gt;grid-&gt;surface;
      w_2 = sm_2-&gt;grid-&gt;surface;
      w_3 = grid_3-&gt;grid-&gt;surface;
      rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
      rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
      rlp_head_wall_3 = find_restricted_regions_by_wall(world, w_3, grid_3);
      if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 != NULL) &amp;&amp;
          (rlp_head_wall_3 != NULL)) {
        all_inside_restricted_boundary = 1;
      } else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 == NULL) &amp;&amp;
                 (rlp_head_wall_3 == NULL)) {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        rlp_head_obj_3 = find_restricted_regions_by_object(
            world, w_3-&gt;parent_object, grid_3);
        all_outside_restricted_boundary = 1;
      } else if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 != NULL) &amp;&amp;
                 (rlp_head_wall_3 == NULL)) {
        rlp_head_obj_3 = find_restricted_regions_by_object(
            world, w_3-&gt;parent_object, grid_3);
        sm_1_inside_sm_2_inside_grid_3_outside = 1;
      } else if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_3 != NULL) &amp;&amp;
                 (rlp_head_wall_2 == NULL)) {
        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        sm_1_inside_sm_2_outside_grid_3_inside = 1;
      } else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 != NULL) &amp;&amp;
                 (rlp_head_wall_3 == NULL)) {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        rlp_head_obj_3 = find_restricted_regions_by_object(
            world, w_3-&gt;parent_object, grid_3);
        sm_1_outside_sm_2_inside_grid_3_outside = 1;
      } else if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 == NULL) &amp;&amp;
                 (rlp_head_wall_3 == NULL)) {
        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        rlp_head_obj_3 = find_restricted_regions_by_object(
            world, w_3-&gt;parent_object, grid_3);
        sm_1_inside_sm_2_outside_grid_3_outside = 1;
      } else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 != NULL) &amp;&amp;
                 (rlp_head_wall_3 != NULL)) {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        sm_1_outside_sm_2_inside_grid_3_inside = 1;
      } else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 == NULL) &amp;&amp;
                 (rlp_head_wall_3 != NULL)) {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        rlp_head_obj_2 =
<a name="5"></a>            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        sm_1_outside_sm_2_outside_grid_3_inside = 1;
      }
<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    } else if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
               are_restricted_regions_for_species_on_object(
                   world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
               (sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
               are_restricted_regions_for_species_on_object(
                   world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2) &amp;&amp;
               (!(grid_3-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
                !are_restricted_regions_for_species_on_object(
                     world, grid_3-&gt;grid-&gt;surface-&gt;parent_object, grid_3))) {
      w_1 = sm_1-&gt;grid-&gt;surface;
      rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
      w_2 = sm_2-&gt;grid-&gt;surface;
      rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
      if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 != NULL)) {
        only_sm_1_sm_2_inside = 1;
      } else if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 == NULL)) {
        only_sm_1_inside_sm_2_outside = 1;
        rlp_head_obj_2 =</b></font>
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
      } else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 != NULL)) {
        only_sm_1_outside_sm_2_inside = 1;
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
      } else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 == NULL)) {
        only_sm_1_sm_2_outside = 1;
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
      }
    } else if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
               are_restricted_regions_for_species_on_object(
                   world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
               (!(sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
                !are_restricted_regions_for_species_on_object(
                     world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2)) &amp;&amp;
               (grid_3-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
               are_restricted_regions_for_species_on_object(
                   world, grid_3-&gt;grid-&gt;surface-&gt;parent_object, grid_3)) {
      w_1 = sm_1-&gt;grid-&gt;surface;
      rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
<a name="10"></a>      w_3 = grid_3-&gt;grid-&gt;surface;
      rlp_head_wall_3 = find_restricted_regions_by_wall(world, w_3, grid_3);
      if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_3 != NULL)) {
<font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        only_sm_1_grid_3_inside = 1;
      } else if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_3 == NULL)) {
        only_sm_1_inside_grid_3_outside = 1;
        rlp_head_obj_3 = find_restricted_regions_by_object(
            world, w_3-&gt;parent_object, grid_3);
      } else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_3 != NULL)) {</b></font>
        only_sm_1_outside_grid_3_inside = 1;
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
      } else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_3 == NULL)) {
        only_sm_1_grid_3_outside = 1;
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        rlp_head_obj_3 = find_restricted_regions_by_object(
            world, w_3-&gt;parent_object, grid_3);
      }
    } else if ((!(sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
                (!are_restricted_regions_for_species_on_object(
                      world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1))) &amp;&amp;
               (sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
               are_restricted_regions_for_species_on_object(
                   world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2) &amp;&amp;
               (grid_3-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
               are_restricted_regions_for_species_on_object(
                   world, grid_3-&gt;grid-&gt;surface-&gt;parent_object, grid_3)) {
      w_2 = sm_2-&gt;grid-&gt;surface;
      rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
      w_3 = grid_3-&gt;grid-&gt;surface;
      rlp_head_wall_3 = find_restricted_regions_by_wall(world, w_3, grid_3);
      if ((rlp_head_wall_2 != NULL) &amp;&amp; (rlp_head_wall_3 != NULL)) {
        only_sm_2_grid_3_inside = 1;
      } else if ((rlp_head_wall_2 != NULL) &amp;&amp; (rlp_head_wall_3 == NULL)) {
        only_sm_2_inside_grid_3_outside = 1;
        rlp_head_obj_3 = find_restricted_regions_by_object(
            world, w_3-&gt;parent_object, grid_3);
      } else if ((rlp_head_wall_2 == NULL) &amp;&amp; (rlp_head_wall_3 != NULL)) {
        only_sm_2_outside_grid_3_inside = 1;
        rlp_head_obj_2 =
<a name="1"></a>            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
      } else if ((rlp_head_wall_2 == NULL) &amp;&amp; (rlp_head_wall_3 == NULL)) {
        only_sm_2_grid_3_outside = 1;
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        rlp_head_obj_3 = find_restricted_regions_by_object(
            world, w_3-&gt;parent_object, grid_3);
      }
    } else if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
               are_restricted_regions_for_species_on_object(
                   world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
               (!(sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
                !are_restricted_regions_for_species_on_object(
                     world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2)) &amp;&amp;
               (!(grid_3-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
                !are_restricted_regions_for_species_on_object(
                     world, grid_3-&gt;grid-&gt;surface-&gt;parent_object, grid_3))) {
      w_1 = sm_1-&gt;grid-&gt;surface;
      rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
      if (rlp_head_wall_1 != NULL) {
        only_sm_1_inside = 1;
      } else {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        only_sm_1_outside = 1;
      }
    } else if ((sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
               are_restricted_regions_for_species_on_object(
                   world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2) &amp;&amp;
               (!(sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
                !are_restricted_regions_for_species_on_object(
                     world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1)) &amp;&amp;
               (!(grid_3-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
                !are_restricted_regions_for_species_on_object(
                     world, grid_3-&gt;grid-&gt;surface-&gt;parent_object, grid_3))) {
      w_2 = sm_2-&gt;grid-&gt;surface;
      rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
      if (rlp_head_wall_2 != NULL)</b></font>
        only_sm_2_inside = 1;
      else {
        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        only_sm_2_outside = 1;
      }
    } else if ((grid_3-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
               are_restricted_regions_for_species_on_object(
                   world, grid_3-&gt;grid-&gt;surface-&gt;parent_object, grid_3) &amp;&amp;
               (!(sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
                !are_restricted_regions_for_species_on_object(
                     world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1)) &amp;&amp;
               (!(sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
                !are_restricted_regions_for_species_on_object(
                     world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2))) {
      w_3 = grid_3-&gt;grid-&gt;surface;
      rlp_head_wall_3 = find_restricted_regions_by_wall(world, w_3, grid_3);
      if (rlp_head_wall_3 != NULL)
        only_grid_3_inside = 1;
      else {
        rlp_head_obj_3 = find_restricted_regions_by_object(
            world, w_3-&gt;parent_object, grid_3);
        only_grid_3_outside = 1;
      }
    }
  }
  struct abstract_molecule *const initiator = reacA;
  short const initiatorOrient = orientA;
  if (reacA-&gt;properties == rx-&gt;players[0]) {
    if (reacB-&gt;properties == rx-&gt;players[2] &amp;&amp;
        reacB-&gt;properties != rx-&gt;players[1]) {
      tmp_mol = reacB;
      reacB = reacC;
      reacC = tmp_mol;
      tmp_orient = orientB;
      orientB = orientC;
      orientC = tmp_orient;
    }
  } else if (reacA-&gt;properties == rx-&gt;players[1]) {
    if (reacB-&gt;properties == rx-&gt;players[0] &amp;&amp;
        reacB-&gt;properties != rx-&gt;players[1]) {
      tmp_mol = reacB;
      reacB = reacA;
      reacA = tmp_mol;
      tmp_orient = orientB;
      orientB = orientA;
      orientA = tmp_orient;
    } else if (reacC-&gt;properties == rx-&gt;players[0]) {
      tmp_mol = reacA;
      reacA = reacC;
      reacC = tmp_mol;
      tmp_orient = orientA;
      orientA = orientC;
      orientC = tmp_orient;
      tmp_mol = reacB;
      reacB = reacC;
      reacC = tmp_mol;
      tmp_orient = orientB;
      orientB = orientC;
      orientC = tmp_orient;
    }
  } else if (reacA-&gt;properties == rx-&gt;players[2]) {
    if (reacB-&gt;properties == rx-&gt;players[0]) {
      tmp_mol = reacB;
      reacB = reacA;
      reacA = tmp_mol;
      tmp_orient = orientB;
      orientB = orientA;
      orientA = tmp_orient;
      tmp_mol = reacB;
      reacB = reacC;
      reacC = tmp_mol;
      tmp_orient = orientB;
      orientB = orientC;
      orientC = tmp_orient;
    } else if ((reacC-&gt;properties == rx-&gt;players[0]) &amp;&amp;
               (reacC-&gt;properties != rx-&gt;players[2])) {
      tmp_mol = reacA;
      reacA = reacC;
      reacC = tmp_mol;
      tmp_orient = orientA;
      orientA = orientC;
      orientC = tmp_orient;
    }
  }
  add_reactants_to_product_list(rx, reacA, reacB, reacC, &amp;product[0], &amp;product_type[0]);
  if (product_type[0] == PLAYER_SURF_MOL) {
    num_surface_reactants++;
    if (rx_players[0] == NULL)
      replace_p1 = 1;
    else
      num_surface_reactants_to_stay++;
  }
  if (product_type[1] == PLAYER_SURF_MOL) {
    num_surface_reactants++;
    if (rx_players[1] == NULL)
      replace_p2 = 1;
    else
      num_surface_reactants_to_stay++;
  }
  if (product_type[2] == PLAYER_SURF_MOL) {
    num_surface_reactants++;
    if (rx_players[2] == NULL)
      replace_p3 = 1;
    else
      num_surface_reactants_to_stay++;
  }
  if (replace_p1 &amp;&amp; (!replace_p2) &amp;&amp; (!replace_p3)) {
    only_one_to_replace = 1;
  } else if ((!replace_p1) &amp;&amp; replace_p2 &amp;&amp; (!replace_p3)) {
    only_one_to_replace = 1;
  } else if ((!replace_p1) &amp;&amp; (!replace_p2) &amp;&amp; replace_p3) {
    only_one_to_replace = 1;
  }
  if (replace_p1 &amp;&amp; (replace_p2) &amp;&amp; (!replace_p3)) {
    two_to_replace = 1;
  } else if (replace_p1 &amp;&amp; (!replace_p2) &amp;&amp; replace_p3) {
    two_to_replace = 1;
  } else if ((!replace_p1) &amp;&amp; replace_p2 &amp;&amp; replace_p3) {
    two_to_replace = 1;
  }
  for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
    if (rx_players[n_product] == NULL)
      continue;
    if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
      num_surface_products++;
      if (!distinguishable(rx_players[n_product]-&gt;D, 0, EPS_C))
        num_surface_static_products++;
    }
  }
  if (num_surface_reactants &gt;= 2)
    find_neighbor_tiles_flag = 1;
  if ((num_surface_reactants == 1) &amp;&amp; (num_surface_products &gt; 1))
    find_neighbor_tiles_flag = 1;
  if (is_orientable) {
    if (sm_reactant)
      rxn_uv_pos = sm_reactant-&gt;s_pos;
    else {
      xyz2uv(hitpt, w, &amp;rxn_uv_pos);
    }
    if ((w == NULL) &amp;&amp; (sm_reactant != NULL))
      w = sm_reactant-&gt;grid-&gt;surface;
    assert(w != NULL);
    if (w-&gt;grid == NULL) {
      assert(!IS_SURF_MOL(reacA));
      if (create_grid(world, w, ((struct volume_molecule *)reacA)-&gt;subvol))
        mcell_allocfailed("Failed to create a grid for a wall.");
    }
    if (find_neighbor_tiles_flag) {
      rxn_uv_idx = uv2grid(&amp;rxn_uv_pos, w-&gt;grid);
      if (sm_reactant != NULL) {
        find_neighbor_tiles(world, sm_reactant, sm_reactant-&gt;grid,
                            sm_reactant-&gt;grid_index, 1, 0, &amp;tile_nbr_head,
                            &amp;list_length);
      } else {
        find_neighbor_tiles(world, sm_reactant, w-&gt;grid, rxn_uv_idx, 1, 0,
                            &amp;tile_nbr_head, &amp;list_length);
<a name="17"></a>      }
<font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>      for (tile_nbr = tile_nbr_head; tile_nbr != NULL;
           tile_nbr = tile_nbr-&gt;next) {
        struct surface_molecule_list *sm_list = tile_nbr-&gt;grid-&gt;sm_list[tile_nbr-&gt;idx];
        if (sm_list == NULL || sm_list-&gt;sm == NULL) {
          num_vacant_tiles++;
          push_tile_neighbor_to_list(&amp;tile_vacant_nbr_head, tile_nbr-&gt;grid,
                                     tile_nbr-&gt;idx);
        }
      }
    }</b></font>
  }
  if ((sm_1 != NULL) &amp;&amp; !distinguishable(sm_1-&gt;properties-&gt;D, 0, EPS_C))
    num_surface_static_reactants++;
  if ((sm_2 != NULL) &amp;&amp; !distinguishable(sm_2-&gt;properties-&gt;D, 0, EPS_C))
    num_surface_static_reactants++;
  if ((grid_3 != NULL) &amp;&amp; !distinguishable(grid_3-&gt;properties-&gt;D, 0, EPS_C))
    num_surface_static_reactants++;
  if (is_orientable) {
    if (replace_p1 &amp;&amp; replace_p2 &amp;&amp; replace_p3) {
      if (num_surface_products &gt; num_vacant_tiles + 3) {
        if (tile_nbr_head != NULL)
          delete_tile_neighbor_list(tile_nbr_head);
        if (tile_vacant_nbr_head != NULL)
          delete_tile_neighbor_list(tile_vacant_nbr_head);
        return RX_BLOCKED;
      }
    } else if (two_to_replace) {
      if (num_surface_products &gt; num_vacant_tiles + 2) {
        if (tile_nbr_head != NULL)
          delete_tile_neighbor_list(tile_nbr_head);
        if (tile_vacant_nbr_head != NULL)
          delete_tile_neighbor_list(tile_vacant_nbr_head);
        return RX_BLOCKED;
      }
    } else if (only_one_to_replace) {
      if (num_surface_products &gt; num_vacant_tiles + 1) {
        if (tile_nbr_head != NULL)
          delete_tile_neighbor_list(tile_nbr_head);
        if (tile_vacant_nbr_head != NULL)
          delete_tile_neighbor_list(tile_vacant_nbr_head);
        return RX_BLOCKED;
      }
    } else {
      if (num_surface_products &gt; num_vacant_tiles) {
        if (tile_nbr_head != NULL)
          delete_tile_neighbor_list(tile_nbr_head);
        if (tile_vacant_nbr_head != NULL)
          delete_tile_neighbor_list(tile_vacant_nbr_head);
        return RX_BLOCKED;
      }
    }
    for (int n_product = 0; n_product &lt; n_players; ++n_product) {
      if (rx_players[n_product] == NULL)
        continue;
      int this_geometry = rx-&gt;geometries[i0 + n_product];
      if (this_geometry == 0)
        product_orient[n_product] = (rng_uint(world-&gt;rng) &amp; 1) ? 1 : -1;
      else {
        if (this_geometry &lt; 0) {
          this_geometry = -this_geometry;
          if (this_geometry &gt; (int)rx-&gt;n_reactants)
            product_orient[n_product] =
                -product_orient[this_geometry - rx-&gt;n_reactants - 1];
          else if (this_geometry == 1)
            product_orient[n_product] = -orientA;
          else if ((this_geometry == 2) &amp;&amp; (reacB != NULL))
            product_orient[n_product] = -orientB;
          else if ((this_geometry == 3) &amp;&amp; (reacC != NULL))
            product_orient[n_product] = -orientC;
          else
            product_orient[n_product] = -1;
        }
        else {
          if (this_geometry &gt; (int)rx-&gt;n_reactants)
            product_orient[n_product] =
                product_orient[this_geometry - rx-&gt;n_reactants - 1];
          else if (this_geometry == 1)
            product_orient[n_product] = orientA;
          else if ((this_geometry == 2) &amp;&amp; (reacB != NULL))
            product_orient[n_product] = orientB;
<a name="16"></a>          else if ((this_geometry == 3) &amp;&amp; (reacC != NULL))
            product_orient[n_product] = orientC;
          else
<font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>            product_orient[n_product] = 1;
        }
      }
      if (n_product &lt; (int)rx-&gt;n_reactants) {
        if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
          assert(IS_SURF_MOL(product[n_product]));
          struct surface_molecule *sm =
              (struct surface_molecule *)product[n_product];
          if (sm-&gt;orient != product_orient[n_product]) {
            if (product[n_product]-&gt;properties-&gt;flags &amp;</b></font>
                (COUNT_CONTENTS | COUNT_ENCLOSED))
              count_region_from_scratch(world,
                                        product[n_product],                                         NULL,                                                       -1,                                                         NULL,                                         w,                                            t,                                            NULL);
            if (((sm-&gt;flags &amp; ACT_REACT) != 0) &amp;&amp;
                ((sm-&gt;properties-&gt;flags &amp; CAN_SURFWALL) != 0))
              sm-&gt;t2 = 0;
            sm-&gt;orient = product_orient[n_product];
            if (product[n_product]-&gt;properties-&gt;flags &amp;
                (COUNT_CONTENTS | COUNT_ENCLOSED))
              count_region_from_scratch(world,
                                        product[n_product],                                         NULL,                                                       1,                                                          NULL,                                         w,                                            t,                                            NULL);
          }
<a name="4"></a>        }
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        else {
          if (product[n_product] == initiator) {
            if (product_orient[n_product] != initiatorOrient)
              cross_wall = true;
          }
        }
      }
    }
    if (num_surface_products == 1) {
      if ((num_surface_static_reactants == 1) &amp;&amp;
          (num_surface_static_products == 1) &amp;&amp;
          (replace_p1 || replace_p2 || replace_p3)) {
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players;
             n_product++) {
          if (rx_players[n_product] == NULL)</b></font>
            continue;
          if ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)
            continue;
<a name="3"></a>          if (distinguishable(rx_players[n_product]-&gt;D, 0, EPS_C))
            continue;
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            if (replace_p1 &amp;&amp; !distinguishable(reacA-&gt;properties-&gt;D, 0, EPS_C)) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
              product_grid[n_product] =
                  ((struct surface_molecule *)reacA)-&gt;grid;
              product_grid_idx[n_product] =
                  ((struct surface_molecule *)reacA)-&gt;grid_index;
              replace_p1 = 0;
              break;
            } else if (replace_p2 &amp;&amp; !distinguishable(reacB-&gt;properties-&gt;D, 0, EPS_C)) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
              product_grid[n_product] =
                  ((struct surface_molecule *)reacB)-&gt;grid;
              product_grid_idx[n_product] =
                  ((struct surface_molecule *)reacB)-&gt;grid_index;</b></font>
              replace_p2 = 0;
              break;
            } else if (replace_p3 &amp;&amp; !distinguishable(reacC-&gt;properties-&gt;D, 0, EPS_C)) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACC_UV;
              product_grid[n_product] =
                  ((struct surface_molecule *)reacC)-&gt;grid;
<a name="13"></a>              product_grid_idx[n_product] =
                  ((struct surface_molecule *)reacC)-&gt;grid_index;
              replace_p3 = 0;
<font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>              break;
            }
          }
        }
      } else if (replace_p1 &amp;&amp; replace_p2 &amp;&amp; replace_p3) {
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players;
             n_product++) {
          if (rx_players[n_product] == NULL)</b></font>
            continue;
          if ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)
            continue;
          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            if (reacA == initiator) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
              product_grid[n_product] =
                  ((struct surface_molecule *)reacA)-&gt;grid;
<a name="9"></a>              product_grid_idx[n_product] =
                  ((struct surface_molecule *)reacA)-&gt;grid_index;
              replace_p1 = 0;
<font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>            } else if (reacB == initiator) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
              product_grid[n_product] =
                  ((struct surface_molecule *)reacB)-&gt;grid;
              product_grid_idx[n_product] =
                  ((struct surface_molecule *)reacB)-&gt;grid_index;
              replace_p2 = 0;
            } else {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACC_UV;
              product_grid[n_product] =
                  ((struct surface_molecule *)reacC)-&gt;grid;
              product_grid_idx[n_product] =
                  ((struct surface_molecule *)reacC)-&gt;grid_index;</b></font>
              replace_p3 = 0;
            }
            break;
          }
        }
      } else if (two_to_replace) {
        while (true) {
          rnd_num = rng_uint(world-&gt;rng) % (rx-&gt;n_reactants);
          if ((rnd_num == 0) &amp;&amp; replace_p1)
            break;
          if ((rnd_num == 1) &amp;&amp; replace_p2)
            break;
          if ((rnd_num == 2) &amp;&amp; replace_p3)
            break;
        }
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players;
             n_product++) {
          if (rx_players[n_product] == NULL)
            continue;
          if ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)
            continue;
          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            if (rnd_num == 0) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
              product_grid[n_product] =
                  ((struct surface_molecule *)reacA)-&gt;grid;
              product_grid_idx[n_product] =
                  ((struct surface_molecule *)reacA)-&gt;grid_index;
              replace_p1 = 0;
            } else if (rnd_num == 1) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
              product_grid[n_product] =
                  ((struct surface_molecule *)reacB)-&gt;grid;
              product_grid_idx[n_product] =
                  ((struct surface_molecule *)reacB)-&gt;grid_index;
              replace_p2 = 0;
            } else if (rnd_num == 2) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACC_UV;
              product_grid[n_product] =
                  ((struct surface_molecule *)reacC)-&gt;grid;
<a name="12"></a>              product_grid_idx[n_product] =
                  ((struct surface_molecule *)reacC)-&gt;grid_index;
              replace_p3 = 0;
<font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>            }
            break;
          }
        }
      } else if (only_one_to_replace) {
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players;
             n_product++) {
          if (rx_players[n_product] == NULL)</b></font>
            continue;
          if ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)
            continue;
          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            if (replace_p1) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
              product_grid[n_product] =
                  ((struct surface_molecule *)reacA)-&gt;grid;
              product_grid_idx[n_product] =
                  ((struct surface_molecule *)reacA)-&gt;grid_index;
              replace_p1 = 0;
              break;
            } else if (replace_p2) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
              product_grid[n_product] =
                  ((struct surface_molecule *)reacB)-&gt;grid;
              product_grid_idx[n_product] =
                  ((struct surface_molecule *)reacB)-&gt;grid_index;
              replace_p2 = 0;
              break;
            } else {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACC_UV;
              product_grid[n_product] =
                  ((struct surface_molecule *)reacC)-&gt;grid;
              product_grid_idx[n_product] =
                  ((struct surface_molecule *)reacC)-&gt;grid_index;
              replace_p3 = 0;
              break;
            }
          }
        }
      }
    } else if (num_surface_products &gt; 1) {
      int count;
      if (num_surface_static_reactants &gt; 0) {
        if (num_surface_static_products &gt;= num_surface_static_reactants) {
          count = 0;
          while (count &lt; num_surface_static_reactants) {
            rnd_num = rng_uint(world-&gt;rng) % n_players;
            if (rnd_num &lt; 3)
              continue;
            if (rx_players[rnd_num] == NULL)
              continue;
            if ((rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0)
              continue;
            if (distinguishable(rx_players[rnd_num]-&gt;D, 0, EPS_C))
              continue;
            if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
              if ((!distinguishable(reacA-&gt;properties-&gt;D, 0, EPS_C)) &amp;&amp; replace_p1) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
                product_grid[rnd_num] =
                    ((struct surface_molecule *)reacA)-&gt;grid;
                product_grid_idx[rnd_num] =
                    ((struct surface_molecule *)reacA)-&gt;grid_index;
                replace_p1 = 0;
                count++;
                continue;
              }
              if ((!distinguishable(reacB-&gt;properties-&gt;D, 0, EPS_C)) &amp;&amp; replace_p2) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
                product_grid[rnd_num] =
                    ((struct surface_molecule *)reacB)-&gt;grid;
                product_grid_idx[rnd_num] =
                    ((struct surface_molecule *)reacB)-&gt;grid_index;
                replace_p2 = 0;
                count++;
                continue;
              }
              if ((!distinguishable(reacC-&gt;properties-&gt;D, 0, EPS_C)) &amp;&amp; replace_p3) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACC_UV;
                product_grid[rnd_num] =
                    ((struct surface_molecule *)reacC)-&gt;grid;
                product_grid_idx[rnd_num] =
                    ((struct surface_molecule *)reacC)-&gt;grid_index;
                replace_p3 = 0;
                count++;
                continue;
              }
            }
          } 
          count = 0;
          while (count &lt; num_surface_static_products) {
            rnd_num = rng_uint(world-&gt;rng) % n_players;
            if (rnd_num &lt; 3)
              continue;
            if (rx_players[rnd_num] == NULL)
              continue;
            if ((rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0)
              continue;
            if (distinguishable(rx_players[rnd_num]-&gt;D, 0, EPS_C))
              continue;
            if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
              if ((!distinguishable(reacA-&gt;properties-&gt;D, 0, EPS_C)) &amp;&amp; replace_p1) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
                product_grid[rnd_num] =
                    ((struct surface_molecule *)reacA)-&gt;grid;
                product_grid_idx[rnd_num] =
                    ((struct surface_molecule *)reacA)-&gt;grid_index;
                replace_p1 = 0;
                count++;
                continue;
              }
              if ((!distinguishable(reacB-&gt;properties-&gt;D, 0, EPS_C)) &amp;&amp; replace_p2) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
                product_grid[rnd_num] =
                    ((struct surface_molecule *)reacB)-&gt;grid;
                product_grid_idx[rnd_num] =
                    ((struct surface_molecule *)reacB)-&gt;grid_index;
                replace_p2 = 0;
                count++;
                continue;
              }
              if ((!distinguishable(reacC-&gt;properties-&gt;D, 0, EPS_C)) &amp;&amp; replace_p3) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACC_UV;
                product_grid[rnd_num] =
                    ((struct surface_molecule *)reacC)-&gt;grid;
                product_grid_idx[rnd_num] =
                    ((struct surface_molecule *)reacC)-&gt;grid_index;
<a name="6"></a>                replace_p3 = 0;
                count++;
                continue;
<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>              }
            }
          }         }
      }
      if (replace_p1 || replace_p2 || replace_p3) {
        int surf_prod_left = 0, surf_reactant_left = 0;
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players;
             n_product++) {
          if (rx_players[n_product] == NULL)</b></font>
            continue;
          if ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)
            continue;
          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET)
            surf_prod_left++;
        }
        if (replace_p1)
          surf_reactant_left++;
        if (replace_p2)
          surf_reactant_left++;
        if (replace_p3)
          surf_reactant_left++;
        if (surf_prod_left &gt; 0) {
          if (surf_prod_left &gt;= surf_reactant_left) {
            count = 0;
            while (count &lt; surf_reactant_left) {
              rnd_num = rng_uint(world-&gt;rng) % n_players;
              if (rnd_num &lt; 3)
                continue;
              if (rx_players[rnd_num] == NULL)
                continue;
              if ((rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0)
                continue;
              if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
                if (replace_p1) {
                  product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
                  product_grid[rnd_num] =
                      ((struct surface_molecule *)reacA)-&gt;grid;
                  product_grid_idx[rnd_num] =
                      ((struct surface_molecule *)reacA)-&gt;grid_index;
                  replace_p1 = 0;
                  count++;
                  continue;
                }
                if (replace_p2) {
                  product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
                  product_grid[rnd_num] =
                      ((struct surface_molecule *)reacB)-&gt;grid;
                  product_grid_idx[rnd_num] =
                      ((struct surface_molecule *)reacB)-&gt;grid_index;
                  replace_p2 = 0;
                  count++;
                  continue;
                }
                if (replace_p3) {
                  product_flag[rnd_num] = PRODUCT_FLAG_USE_REACC_UV;
                  product_grid[rnd_num] =
                      ((struct surface_molecule *)reacC)-&gt;grid;
                  product_grid_idx[rnd_num] =
                      ((struct surface_molecule *)reacC)-&gt;grid_index;
                  replace_p3 = 0;
                  count++;
                  continue;
                }
              }
            } 
          } else {             count = 0;
            while (count &lt; surf_prod_left) {
              rnd_num = rng_uint(world-&gt;rng) % n_players;
              if (rnd_num &lt; 3)
                continue;
              if (rx_players[rnd_num] == NULL)
                continue;
              if ((rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0)
                continue;
              if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
                if (replace_p1) {
                  product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
                  product_grid[rnd_num] =
                      ((struct surface_molecule *)reacA)-&gt;grid;
                  product_grid_idx[rnd_num] =
                      ((struct surface_molecule *)reacA)-&gt;grid_index;
                  replace_p1 = 0;
                  count++;
                  continue;
                }
                if (replace_p2) {
                  product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
                  product_grid[rnd_num] =
                      ((struct surface_molecule *)reacB)-&gt;grid;
                  product_grid_idx[rnd_num] =
                      ((struct surface_molecule *)reacB)-&gt;grid_index;
                  replace_p2 = 0;
                  count++;
                  continue;
                }
                if (replace_p3) {
                  product_flag[rnd_num] = PRODUCT_FLAG_USE_REACC_UV;
                  product_grid[rnd_num] =
                      ((struct surface_molecule *)reacC)-&gt;grid;
                  product_grid_idx[rnd_num] =
                      ((struct surface_molecule *)reacC)-&gt;grid_index;
                  replace_p3 = 0;
                  count++;
                  continue;
                }
              }
            }           }
        }
      }
    }
    int num_attempts = 0;
    for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
      if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
        if (product_flag[n_product] != PRODUCT_FLAG_NOT_SET)
          continue;
        if (num_vacant_tiles == 0) {
          if (tile_nbr_head != NULL)
            delete_tile_neighbor_list(tile_nbr_head);
          if (tile_vacant_nbr_head != NULL)
            delete_tile_neighbor_list(tile_vacant_nbr_head);
          return RX_BLOCKED;
        }
        while (true) {
          if (num_attempts &gt; SURFACE_DIFFUSION_RETRIES) {
            if (tile_nbr_head != NULL)
              delete_tile_neighbor_list(tile_nbr_head);
            if (tile_vacant_nbr_head != NULL)
              delete_tile_neighbor_list(tile_vacant_nbr_head);
            return RX_BLOCKED;
          }
          rnd_num = rng_uint(world-&gt;rng) % num_vacant_tiles;
          tile_idx = -1;
          tile_grid = NULL;
          if (get_tile_neighbor_from_list_of_vacant_neighbors(
                  tile_vacant_nbr_head, rnd_num, &amp;tile_grid, &amp;tile_idx) == 0) {
            if (tile_nbr_head != NULL)
              delete_tile_neighbor_list(tile_nbr_head);
            if (tile_vacant_nbr_head != NULL)
              delete_tile_neighbor_list(tile_vacant_nbr_head);
            return RX_BLOCKED;
          }
          if (tile_idx &lt; 0)
            continue; 
          assert(tile_grid != NULL);
          if (all_inside_restricted_boundary) {
            int cond_1 = 0, cond_2 = 0, cond_3 = 0;
            cond_1 = (!wall_belongs_to_all_regions_in_region_list(
                           tile_grid-&gt;surface, rlp_head_wall_1));
            cond_2 = (!wall_belongs_to_all_regions_in_region_list(
                           tile_grid-&gt;surface, rlp_head_wall_2));
            cond_3 = (!wall_belongs_to_all_regions_in_region_list(
                           tile_grid-&gt;surface, rlp_head_wall_3));
            if (cond_1 || cond_2 || cond_3) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (all_outside_restricted_boundary) {
            int cond_1 = 0, cond_2 = 0, cond_3 = 0;
            cond_1 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_1);
            cond_2 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_2);
            cond_3 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_3);
            if (cond_1 || cond_2 || cond_3) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (sm_1_inside_sm_2_inside_grid_3_outside) {
            int cond_1 = 0, cond_2 = 0, cond_3 = 0;
            cond_1 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_1));
            cond_2 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_2));
            cond_3 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_3);
            if (cond_1 || cond_2 || cond_3) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (sm_1_inside_sm_2_outside_grid_3_inside) {
            int cond_1 = 0, cond_2 = 0, cond_3 = 0;
            cond_1 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_1));
            cond_2 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_2);
            cond_3 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_3));
            if (cond_1 || cond_2 || cond_3) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (sm_1_inside_sm_2_outside_grid_3_outside) {
            int cond_1 = 0, cond_2 = 0, cond_3 = 0;
            cond_1 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_1));
            cond_2 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_2);
            cond_3 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_3);
            if (cond_1 || cond_2 || cond_3) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (sm_1_outside_sm_2_inside_grid_3_outside) {
            int cond_1 = 0, cond_2 = 0, cond_3 = 0;
            cond_1 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_1);
            cond_2 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_2));
            cond_3 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_3);
            if (cond_1 || cond_2 || cond_3) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (sm_1_outside_sm_2_inside_grid_3_inside) {
            int cond_1 = 0, cond_2 = 0, cond_3 = 0;
            cond_1 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_1);
            cond_2 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_2));
            cond_3 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_3));
            if (cond_1 || cond_2 || cond_3) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (sm_1_outside_sm_2_outside_grid_3_inside) {
            int cond_1 = 0, cond_2 = 0, cond_3 = 0;
            cond_1 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_1);
            cond_2 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_2);
            cond_3 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_3));
            if (cond_1 || cond_2 || cond_3) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_1_sm_2_inside) {
            int cond_1 = 0, cond_2 = 0;
            cond_1 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_1));
            cond_2 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_2));
            if (cond_1 || cond_2) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_1_inside_sm_2_outside) {
            int cond_1 = 0, cond_2 = 0;
            cond_1 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_1));
            cond_2 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_2);
            if (cond_1 || cond_2) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_1_outside_sm_2_inside) {
            int cond_1 = 0, cond_2 = 0;
            cond_1 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_1);
            cond_2 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_2));
            if (cond_1 || cond_2) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_1_sm_2_outside) {
            int cond_1 = 0, cond_2 = 0;
            cond_1 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_1);
            cond_2 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_2);
            if (cond_1 || cond_2) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_1_grid_3_inside) {
            int cond_1 = 0, cond_2 = 0;
            cond_1 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_1));
            cond_2 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_3));
            if (cond_1 || cond_2) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_1_inside_grid_3_outside) {
            int cond_1 = 0, cond_2 = 0;
            cond_1 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_1));
            cond_2 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_3);
            if (cond_1 || cond_2) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_1_outside_grid_3_inside) {
            int cond_1 = 0, cond_2 = 0;
            cond_1 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_1);
            cond_2 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_3));
            if (cond_1 || cond_2) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_1_grid_3_outside) {
            int cond_1 = 0, cond_2 = 0;
            cond_1 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_1);
            cond_2 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_3);
            if (cond_1 || cond_2) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_2_grid_3_inside) {
            int cond_1 = 0, cond_2 = 0;
            cond_1 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_2));
            cond_2 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_3));
            if (cond_1 || cond_2) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_2_inside_grid_3_outside) {
            int cond_1 = 0, cond_2 = 0;
            cond_1 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_2));
            cond_2 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_3);
            if (cond_1 || cond_2) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_2_outside_grid_3_inside) {
            int cond_1 = 0, cond_2 = 0;
            cond_1 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_2);
            cond_2 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_3));
            if (cond_1 || cond_2) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_2_grid_3_outside) {
            int cond_1 = 0, cond_2 = 0;
            cond_1 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_2);
            cond_2 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_3);
            if (cond_1 || cond_2) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_1_inside) {
            if (!wall_belongs_to_all_regions_in_region_list(tile_grid-&gt;surface,
                                                            rlp_head_wall_1)) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_1_outside) {
            if (wall_belongs_to_any_region_in_region_list(tile_grid-&gt;surface,
                                                          rlp_head_obj_1)) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_2_inside) {
            if (!wall_belongs_to_all_regions_in_region_list(tile_grid-&gt;surface,
                                                            rlp_head_wall_2)) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_2_outside) {
            if (wall_belongs_to_any_region_in_region_list(tile_grid-&gt;surface,
                                                          rlp_head_obj_2)) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_grid_3_inside) {
            if (!wall_belongs_to_all_regions_in_region_list(tile_grid-&gt;surface,
                                                            rlp_head_wall_3)) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_grid_3_outside) {
            if (wall_belongs_to_any_region_in_region_list(tile_grid-&gt;surface,
                                                          rlp_head_obj_3)) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          }
          product_grid[n_product] = tile_grid;
          product_grid_idx[n_product] = tile_idx;
          product_flag[n_product] = PRODUCT_FLAG_USE_RANDOM;
          break;
        }
      }
    }
  } 
  struct vector3 count_pos_xyz;
  if (hitpt != NULL)
    count_pos_xyz = *hitpt;
  else if (sm_reactant)
    uv2xyz(&amp;sm_reactant-&gt;s_pos, sm_reactant-&gt;grid-&gt;surface, &amp;count_pos_xyz);
  else
    count_pos_xyz = ((struct volume_molecule *)reacA)-&gt;pos;
<a name="15"></a>  struct vector3 mol_pos_tmp;
  struct subvolume *product_subvol = NULL;
  for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
<font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    struct abstract_molecule *this_product = NULL;
    struct species *const product_species = rx_players[n_product];
    if (product_species-&gt;flags &amp; ON_GRID) {
      struct vector2 prod_uv_pos;
      if (world-&gt;randomize_smol_pos) {
        switch (product_flag[n_product]) {
        case PRODUCT_FLAG_USE_REACA_UV:</b></font>
          prod_uv_pos = ((struct surface_molecule *)reacA)-&gt;s_pos;
          break;
        case PRODUCT_FLAG_USE_REACB_UV:
          prod_uv_pos = ((struct surface_molecule *)reacB)-&gt;s_pos;
          break;
        case PRODUCT_FLAG_USE_REACC_UV:
          prod_uv_pos = ((struct surface_molecule *)reacC)-&gt;s_pos;
          break;
        case PRODUCT_FLAG_USE_RANDOM:
          grid2uv_random(product_grid[n_product], product_grid_idx[n_product],
                         &amp;prod_uv_pos, world-&gt;rng);
          break;
        default:
          UNHANDLED_CASE(product_flag[n_product]);
        }
      } else
        grid2uv(product_grid[n_product], product_grid_idx[n_product],
                &amp;prod_uv_pos);
      this_product = (struct abstract_molecule *)place_sm_product(
          world, product_species, 0, product_grid[n_product],
          product_grid_idx[n_product], &amp;prod_uv_pos, product_orient[n_product],
          t, reacA-&gt;periodic_box);
    }
    else {
      if (!hitpt) {
        if (reacA-&gt;properties-&gt;flags &amp; ON_GRID) {
          uv2xyz(&amp;((struct surface_molecule *)reacA)-&gt;s_pos,
                 ((struct surface_molecule *)reacA)-&gt;grid-&gt;surface,
                 &amp;mol_pos_tmp);
          product_subvol = find_subvolume(world, &amp;mol_pos_tmp, last_subvol);
        }
        else {
          mol_pos_tmp = ((struct volume_molecule *)reacA)-&gt;pos;
          product_subvol = ((struct volume_molecule *)reacA)-&gt;subvol;
        }
        hitpt = &amp;mol_pos_tmp;
      } else
        product_subvol = find_subvolume(world, hitpt, last_subvol);
      this_product = (struct abstract_molecule *)place_volume_product(
          world, product_species, 0, sm_reactant, w, product_subvol, hitpt,
          product_orient[n_product], t, reacA-&gt;periodic_box);
      if (((struct volume_molecule *)this_product)-&gt;index &lt; DISSOCIATION_MAX)
        update_dissociation_index = true;
    }
<a name="19"></a>    ++product_species-&gt;population;
    if (product_species-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED))
      count_region_from_scratch(world, this_product, NULL, 1, NULL, NULL, t, NULL);
<font color="#f62817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  }
  if (update_dissociation_index) {
    if (--world-&gt;dissociation_index &lt; DISSOCIATION_MIN)
      world-&gt;dissociation_index = DISSOCIATION_MAX;
  }
  if (rx-&gt;info[path].pathname != NULL) {
    if (world-&gt;place_waypoints_flag)
      count_region_from_scratch(world, NULL, rx-&gt;info[path].pathname, 1,</b></font>
                                &amp;count_pos_xyz, w, t, NULL);
    if (rx-&gt;info[path].pathname-&gt;magic != NULL) {
      if (reaction_wizardry(world, rx-&gt;info[path].pathname-&gt;magic, w,
                            &amp;count_pos_xyz, t))
        mcell_allocfailed("Failed to complete reaction triggered release after "
                          "a '%s' reaction.",
                          rx-&gt;info[path].pathname-&gt;sym-&gt;name);
    }
  }
  if (tile_nbr_head != NULL)
    delete_tile_neighbor_list(tile_nbr_head);
  if (tile_vacant_nbr_head != NULL)
    delete_tile_neighbor_list(tile_vacant_nbr_head);
  return cross_wall ? RX_FLIP : RX_A_OK;
}
int outcome_trimolecular(struct volume *world, struct rxn *rx, int path,
                         struct abstract_molecule *reacA,
                         struct abstract_molecule *reacB,
<a name="18"></a>                         struct abstract_molecule *reacC, short orientA,
                         short orientB, short orientC, double t,
                         struct vector3 *hitpt, struct vector3 *loc_okay) {
<font color="#800517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  struct wall *w = NULL;
  struct volume_molecule *vm = NULL;
  struct surface_molecule *sm = NULL;
  int result;
  int killA = 0, killB = 0, killC = 0;</b></font>
  int reacA_is_free = 0;
  int reacB_is_free = 0;
  int reacC_is_free = 0;
  int num_surface_reactants = 0;
  if ((reacA-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
    reacA_is_free = 1;
  } else
    num_surface_reactants++;
  if ((reacB-&gt;properties-&gt;flags &amp; NOT_FREE) == 0)
    reacB_is_free = 1;
  else
    num_surface_reactants++;
  if ((reacC-&gt;properties-&gt;flags &amp; NOT_FREE) == 0)
    reacC_is_free = 1;
  else
    num_surface_reactants++;
  if (!reacA_is_free) {
    sm = (struct surface_molecule *)reacA;
  } else if (!reacB_is_free) {
    sm = (struct surface_molecule *)reacB;
  } else if (!reacC_is_free) {
    sm = (struct surface_molecule *)reacC;
  }
  if (sm != NULL)
    w = sm-&gt;grid-&gt;surface;
  result = outcome_products_trimol_reaction_random(world, w, hitpt, t, rx, path,
                                                   reacA, reacB, reacC, orientA,
                                                   orientB, orientC);
  if (result == RX_BLOCKED)
    return RX_BLOCKED;
  rx-&gt;n_occurred++;
  rx-&gt;info[path].count++;
  if (rx-&gt;players[0] == reacA-&gt;properties) {
    if (rx-&gt;players[1] == reacB-&gt;properties) {
      killC = (rx-&gt;players[rx-&gt;product_idx[path] + 2] == NULL);
      killB = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
      killA = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
    } else {
      killB = (rx-&gt;players[rx-&gt;product_idx[path] + 2] == NULL);
      killC = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
      killA = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
    }
  } else if (rx-&gt;players[0] == reacB-&gt;properties) {
    if (rx-&gt;players[1] == reacA-&gt;properties) {
      killC = (rx-&gt;players[rx-&gt;product_idx[path] + 2] == NULL);
      killA = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
      killB = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
    } else {
      killA = (rx-&gt;players[rx-&gt;product_idx[path] + 2] == NULL);
      killC = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
      killB = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
    }
  } else if (rx-&gt;players[0] == reacC-&gt;properties) {
    if (rx-&gt;players[1] == reacA-&gt;properties) {
      killB = (rx-&gt;players[rx-&gt;product_idx[path] + 2] == NULL);
      killA = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
      killC = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
    } else {
      killA = (rx-&gt;players[rx-&gt;product_idx[path] + 2] == NULL);
      killB = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
      killC = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
    }
<a name="11"></a>  }
  if (killC) {
<font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    vm = NULL;
    if ((reacC-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
      sm = (struct surface_molecule *)reacC;
      remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
      sm-&gt;grid-&gt;n_occupied--;
      if (sm-&gt;flags &amp; IN_SURFACE)
        sm-&gt;flags -= IN_SURFACE;
      if (sm-&gt;flags &amp; IN_SCHEDULE) {
        sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
    } else {</b></font>
      vm = (struct volume_molecule *)reacC;
      vm-&gt;subvol-&gt;mol_count--;
      if (vm-&gt;flags &amp; IN_SCHEDULE) {
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
    }
    if ((reacC-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) != 0) {
      count_region_from_scratch(world, reacC, NULL, -1, NULL, NULL, t, NULL);
    }
    reacC-&gt;properties-&gt;n_deceased++;
    double t_time = convert_iterations_to_seconds(
        world-&gt;start_iterations, world-&gt;time_unit,
        world-&gt;simulation_start_seconds, t);
    reacC-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacC-&gt;birthday;
    reacC-&gt;properties-&gt;population--;
    if (vm != NULL)
      collect_molecule(vm);
    else {
      reacC-&gt;properties = NULL;
      if ((reacC-&gt;flags &amp; IN_MASK) == 0)
        mem_put(reacC-&gt;birthplace, reacC);
    }
  }
  if (killB) {
    vm = NULL;
    if ((reacB-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
      sm = (struct surface_molecule *)reacB;
      remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
      sm-&gt;grid-&gt;n_occupied--;
      if (sm-&gt;flags &amp; IN_SURFACE)
        sm-&gt;flags -= IN_SURFACE;
      if (sm-&gt;flags &amp; IN_SCHEDULE) {
        sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
    } else {
      vm = (struct volume_molecule *)reacB;
      vm-&gt;subvol-&gt;mol_count--;
      if (vm-&gt;flags &amp; IN_SCHEDULE) {
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
    }
    if ((reacB-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) != 0) {
      count_region_from_scratch(world, reacB, NULL, -1, NULL, NULL, t, NULL);
    }
    reacB-&gt;properties-&gt;n_deceased++;
    double t_time = convert_iterations_to_seconds(
        world-&gt;start_iterations, world-&gt;time_unit,
        world-&gt;simulation_start_seconds, t);
    reacB-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacB-&gt;birthday;
    reacB-&gt;properties-&gt;population--;
    if (vm != NULL)
      collect_molecule(vm);
    else {
      reacB-&gt;properties = NULL;
      if ((reacB-&gt;flags &amp; IN_MASK) == 0)
        mem_put(reacB-&gt;birthplace, reacB);
    }
  }
  if (killA) {
    vm = NULL;
    if ((reacA-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
      sm = (struct surface_molecule *)reacA;
      remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
      sm-&gt;grid-&gt;n_occupied--;
      if (sm-&gt;flags &amp; IN_SURFACE)
        sm-&gt;flags -= IN_SURFACE;
<a name="8"></a>      if (sm-&gt;flags &amp; IN_SCHEDULE) {
        sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    } else {
      vm = (struct volume_molecule *)reacA;
      vm-&gt;subvol-&gt;mol_count--;
      if (vm-&gt;flags &amp; IN_SCHEDULE) {
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
    }
    if ((reacA-&gt;properties-&gt;flags &amp; ON_GRID) !=
        0)     {
      if (reacA-&gt;properties-&gt;flags &amp;
          COUNT_SOME_MASK)       {
        count_region_from_scratch(world, reacA, NULL, -1, NULL, NULL, t, NULL);</b></font>
      }
    } else if ((reacA-&gt;flags &amp; COUNT_ME) &amp;&amp; world-&gt;place_waypoints_flag) {
<a name="7"></a>      if (hitpt == NULL || (reacB_is_free &amp;&amp; reacC_is_free))
      {
<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        count_region_from_scratch(world, reacA, NULL, -1, hitpt, NULL, t, NULL);
      {
        struct vector3 fake_hitpt;
        vm = (struct volume_molecule *)reacA;
        if (loc_okay == NULL)
          loc_okay = &amp;(vm-&gt;pos);
        fake_hitpt.x = 0.5 * hitpt-&gt;x + 0.5 * loc_okay-&gt;x;
        fake_hitpt.y = 0.5 * hitpt-&gt;y + 0.5 * loc_okay-&gt;y;
        fake_hitpt.z = 0.5 * hitpt-&gt;z + 0.5 * loc_okay-&gt;z;
<a name="14"></a>        count_region_from_scratch(world, reacA, NULL, -1, &amp;fake_hitpt, NULL, t, NULL);</b></font>
      }
    }
<font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    reacA-&gt;properties-&gt;n_deceased++;
    double t_time = convert_iterations_to_seconds(
        world-&gt;start_iterations, world-&gt;time_unit,
        world-&gt;simulation_start_seconds, t);
    reacA-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacA-&gt;birthday;
    reacA-&gt;properties-&gt;population--;
    if (vm != NULL)
      collect_molecule(vm);
    else
      reacA-&gt;properties = NULL;
    return RX_DESTROY;
  }
  return result;
}</b></font>
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
