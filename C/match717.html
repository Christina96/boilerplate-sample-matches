<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for react_outc.c &amp; react_outc_trimol.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for react_outc.c &amp; react_outc_trimol.c
      </h3>
<h1 align="center">
        17.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>react_outc.c (18.681917%)<th>react_outc_trimol.c (16.310034%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(394-408)<td><a href="#" name="0">(249-264)</a><td align="center"><font color="#ff0000">30</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1675-1708)<td><a href="#" name="1">(441-477)</a><td align="center"><font color="#e50000">27</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(366-381)<td><a href="#" name="2">(78-96)</a><td align="center"><font color="#bb0000">22</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(652-662)<td><a href="#" name="3">(871-885)</a><td align="center"><font color="#aa0000">20</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(615-629)<td><a href="#" name="4">(845-864)</a><td align="center"><font color="#aa0000">20</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(1642-1661)<td><a href="#" name="5">(350-369)</a><td align="center"><font color="#a10000">19</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(755-766)<td><a href="#" name="6">(1121-1140)</a><td align="center"><font color="#900000">17</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(1383-1399)<td><a href="#" name="7">(1950-1967)</a><td align="center"><font color="#880000">16</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(1360-1374)<td><a href="#" name="8">(1929-1942)</a><td align="center"><font color="#880000">16</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(677-685)<td><a href="#" name="9">(918-930)</a><td align="center"><font color="#880000">16</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(1663-1674)<td><a href="#" name="10">(398-403)</a><td align="center"><font color="#7f0000">15</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(1305-1316)<td><a href="#" name="11">(1840-1851)</a><td align="center"><font color="#7f0000">15</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(686-692)<td><a href="#" name="12">(980-989)</a><td align="center"><font color="#7f0000">15</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(663-671)<td><a href="#" name="13">(895-905)</a><td align="center"><font color="#7f0000">15</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(1405-1421)<td><a href="#" name="14">(1970-1984)</a><td align="center"><font color="#770000">14</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(921-931)<td><a href="#" name="15">(1628-1638)</a><td align="center"><font color="#770000">14</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(552-576)<td><a href="#" name="16">(778-803)</a><td align="center"><font color="#770000">14</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(508-516)<td><a href="#" name="17">(679-688)</a><td align="center"><font color="#770000">14</font>
<tr onclick='openModal("#800517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#800517"><font color="#800517">-</font><td><a href="#" name="18">(1250-1255)<td><a href="#" name="18">(1760-1765)</a><td align="center"><font color="#660000">12</font>
<tr onclick='openModal("#f62817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f62817"><font color="#f62817">-</font><td><a href="#" name="19">(1043-1057)<td><a href="#" name="19">(1702-1715)</a><td align="center"><font color="#660000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>react_outc.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;string.h&gt;
3 #include &lt;math.h&gt;
4 #include &lt;stdlib.h&gt;
5 #include &lt;assert.h&gt;
6 #include &lt;vector&gt;
7 #include "logging.h"
8 #include "rng.h"
9 #include "util.h"
10 #include "grid_util.h"
11 #include "count_util.h"
12 #include "react.h"
13 #include "vol_util.h"
14 #include "wall_util.h"
15 #include "nfsim_func.h"
16 #include "mcell_reactions.h"
17 #include "diffuse.h"
18 #include "debug_config.h"
19 #include "debug.h"
20 #include "dump_state.h"
21 static int outcome_products_random(struct volume *world, struct wall *w,
22                                    struct vector3 *hitpt, double t,
23                                    struct rxn *rx, int path,
24                                    struct abstract_molecule *reacA,
25                                    struct abstract_molecule *reacB,
26                                    short orientA, short orientB);
27 static int cleanup_and_block_rx(struct tile_neighbor *tn1, struct tile_neighbor *tn2);
28 int is_compatible_surface(void *req_species, struct wall *w) {
29   struct surf_class_list *scl, *scl2;
30   struct surf_class_list *rs_head = (struct surf_class_list *)req_species;
31   if (rs_head == NULL)
32     return 1;
33   for (scl = w-&gt;surf_class_head; scl != NULL; scl = scl-&gt;next) {
34     for (scl2 = rs_head; scl2 != NULL; scl2 = scl2-&gt;next) {
35       if (scl-&gt;surf_class == scl2-&gt;surf_class)
36         return 1;
37     }
38   }
39   return 0;
40 }
41 void add_reactants_to_product_list(struct rxn *rx, struct abstract_molecule *reacA,
42   struct abstract_molecule *reacB, struct abstract_molecule *reacC,
43   struct abstract_molecule **player, char *player_type) {
44   player[0] = reacA;
45   player_type[0] = IS_SURF_MOL(reacA) ? PLAYER_SURF_MOL : PLAYER_VOL_MOL;
46   if (rx-&gt;n_reactants &gt; 1) {
47     if (reacB == NULL) {
48       assert(rx-&gt;n_reactants == 2);
49       player[1] = NULL;
50       player_type[1] = PLAYER_WALL;
51     } else {        player[1] = reacB;
52       player_type[1] = IS_SURF_MOL(reacB) ? PLAYER_SURF_MOL : PLAYER_VOL_MOL;
53     }
54     if (rx-&gt;n_reactants &gt; 2) {
55       if (reacC == NULL) {
56         player[2] = NULL;
57         player_type[2] = PLAYER_WALL;
58       } else {
59         player[2] = reacC;
60         player_type[2] = IS_SURF_MOL(reacC) ? PLAYER_SURF_MOL : PLAYER_VOL_MOL;
61       }
62     }
63   }
64 }
65 static bool is_rxn_unimol(struct rxn *rx) {
66   if (rx-&gt;n_reactants == 1)
67     return true;
68   if (rx-&gt;n_reactants != 2)
69     return false;
70   if (!(rx-&gt;players[0]-&gt;flags &amp; ON_GRID))
71     return false;
72   return (rx-&gt;players[1]-&gt;flags &amp; IS_SURFACE) != 0;
73 }
74 void tiny_diffuse_3D(
75     struct volume *world,
76     struct subvolume *subvol,
77     struct vector3 *displacement,
78     struct vector3 *pos,
79     struct wall *w) {
80   struct vector3 temp_displacement = {
81     displacement-&gt;x,
82     displacement-&gt;y,
83     displacement-&gt;z
84   };
85   struct collision *shead = ray_trace(
86       world, pos, NULL, subvol, &amp;temp_displacement, w);
87   if (shead-&gt;next != NULL) {
88     shead = (struct collision *)ae_list_sort((struct abstract_element *)shead);
89   }
90   struct collision *smash = NULL;
91   for (smash = shead; smash != NULL; smash = smash-&gt;next) {
92     if ((smash-&gt;what &amp; COLLIDE_WALL) != 0) {
93       vectorize(pos, &amp;(smash-&gt;loc), displacement);
94       scalar_prod(displacement, 0.5, displacement);
95       break;
96     }
97   }
98   pos-&gt;x += displacement-&gt;x;
99   pos-&gt;y += displacement-&gt;y;
100   pos-&gt;z += displacement-&gt;z;
101   subvol = find_subvolume(world, pos, subvol);
102 }
103 struct volume_molecule *
104 place_volume_product(struct volume *world, struct species *product_species, struct graph_data* graph,
105                      struct surface_molecule *sm_reactant, struct wall *w,
106                      struct subvolume *subvol, struct vector3 *hitpt,
107                      short orient, double t, struct periodic_image *periodic_box) {
108   struct vector3 pos = *hitpt;
109   if (w) {
110     double bump = (orient &gt; 0) ? EPS_C : -EPS_C;
111     struct vector3 displacement = {2 * bump * w-&gt;normal.x,
112                                    2 * bump * w-&gt;normal.y,
113                                    2 * bump * w-&gt;normal.z,
114                                   };
115     tiny_diffuse_3D(world, subvol, &amp;displacement, &amp;pos, w);
116   }
117   struct volume_molecule *new_volume_mol;
118   new_volume_mol =
119       (struct volume_molecule *)CHECKED_MEM_GET(subvol-&gt;local_storage-&gt;mol, "volume molecule");
120   new_volume_mol-&gt;birthplace = subvol-&gt;local_storage-&gt;mol;
121   new_volume_mol-&gt;birthday = convert_iterations_to_seconds(
122       world-&gt;start_iterations, world-&gt;time_unit,
123       world-&gt;simulation_start_seconds, t);
124   new_volume_mol-&gt;id = world-&gt;current_mol_id++;
125   new_volume_mol-&gt;t = t;
126   new_volume_mol-&gt;t2 = 0.0;
127   new_volume_mol-&gt;periodic_box = CHECKED_MALLOC_STRUCT(struct periodic_image,
128     "periodic image descriptor");
129   new_volume_mol-&gt;periodic_box-&gt;x = periodic_box-&gt;x;
130   new_volume_mol-&gt;periodic_box-&gt;y = periodic_box-&gt;y;
131   new_volume_mol-&gt;periodic_box-&gt;z = periodic_box-&gt;z;
132   new_volume_mol-&gt;properties = product_species;
133   new_volume_mol-&gt;graph_data = graph;
134   initialize_diffusion_function((struct abstract_molecule*) new_volume_mol);
135   new_volume_mol-&gt;prev_v = NULL;
136   new_volume_mol-&gt;next_v = NULL;
137   new_volume_mol-&gt;pos = pos;
138   new_volume_mol-&gt;subvol = subvol;
139   new_volume_mol-&gt;index = 0;
140   new_volume_mol-&gt;flags = TYPE_VOL | ACT_NEWBIE | IN_VOLUME | IN_SCHEDULE;
141   if (new_volume_mol-&gt;get_space_step(new_volume_mol) &gt; 0.0)
142     new_volume_mol-&gt;flags |= ACT_DIFFUSE;
143   if ((product_species-&gt;flags &amp; COUNT_SOME_MASK) != 0)
144     new_volume_mol-&gt;flags |= COUNT_ME;
145   if (trigger_unimolecular(world-&gt;reaction_hash, world-&gt;rx_hashsize,
146                            product_species-&gt;hashval,
147                            (struct abstract_molecule *)new_volume_mol) != NULL)
148     new_volume_mol-&gt;flags |= ACT_REACT;
149   if (sm_reactant &amp;&amp; distinguishable(new_volume_mol-&gt;get_diffusion(new_volume_mol), 0, EPS_C)) {
150     new_volume_mol-&gt;previous_wall = sm_reactant-&gt;grid-&gt;surface;
151     new_volume_mol-&gt;index = sm_reactant-&gt;grid_index;
152   }
153   else {
154     new_volume_mol-&gt;previous_wall = NULL;
155     new_volume_mol-&gt;index = -1;
156   }
157   if (w) {
158     if (world-&gt;surface_reversibility) {
159       new_volume_mol-&gt;previous_wall = w;
160       new_volume_mol-&gt;index = (orient &gt; 0) ? 1 : -1;
161       new_volume_mol-&gt;flags |= ACT_CLAMPED;
162     }
163   } else if (world-&gt;volume_reversibility) {
164     new_volume_mol-&gt;index = world-&gt;dissociation_index;
165     new_volume_mol-&gt;flags |= ACT_CLAMPED;
166   }
167   ht_add_molecule_to_list(&amp;new_volume_mol-&gt;subvol-&gt;mol_by_species,
168                           new_volume_mol);
169   ++new_volume_mol-&gt;subvol-&gt;mol_count;
170   if (schedule_add_mol(subvol-&gt;local_storage-&gt;timer, new_volume_mol))
171     mcell_allocfailed("Failed to add newly created %s molecule to scheduler.",
172                       product_species-&gt;sym-&gt;name);
173   return new_volume_mol;
174 }
175 struct surface_molecule *
176 place_sm_product(struct volume *world, struct species *product_species, struct graph_data* graph,
177                  struct surface_grid *grid, int grid_index,
178                  struct vector2 *mol_uv_pos, short orient, double t,
179                  struct periodic_image *periodic_box) {
180   struct vector3 mol_xyz_pos;
181   uv2xyz(mol_uv_pos, grid-&gt;surface, &amp;mol_xyz_pos);
182   struct subvolume *sv = find_subvolume(world, &amp;mol_xyz_pos, grid-&gt;subvol);
183   struct surface_molecule *new_surf_mol;
184   new_surf_mol = (struct surface_molecule *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;smol, "surface molecule");
185   new_surf_mol-&gt;birthplace = sv-&gt;local_storage-&gt;smol;
186   new_surf_mol-&gt;birthday = convert_iterations_to_seconds(
187       world-&gt;start_iterations, world-&gt;time_unit,
188       world-&gt;simulation_start_seconds, t);
189   new_surf_mol-&gt;id = world-&gt;current_mol_id++;
190   new_surf_mol-&gt;t = t;
191   new_surf_mol-&gt;t2 = 0.0;
192   new_surf_mol-&gt;properties = product_species;
193   new_surf_mol-&gt;graph_data = graph;
194   initialize_diffusion_function((struct abstract_molecule*) new_surf_mol);
195   new_surf_mol-&gt;periodic_box = CHECKED_MALLOC_STRUCT(struct periodic_image,
196     "periodic image descriptor");
197   new_surf_mol-&gt;periodic_box-&gt;x = periodic_box-&gt;x;
198   new_surf_mol-&gt;periodic_box-&gt;y = periodic_box-&gt;y;
199   new_surf_mol-&gt;periodic_box-&gt;z = periodic_box-&gt;z;
200   new_surf_mol-&gt;flags = TYPE_SURF | ACT_NEWBIE | IN_SCHEDULE;
201   if (new_surf_mol-&gt;get_space_step(new_surf_mol) &gt; 0)
202     new_surf_mol-&gt;flags |= ACT_DIFFUSE;
203   if (product_species-&gt;flags &amp; COUNT_ENCLOSED)
204     new_surf_mol-&gt;flags |= COUNT_ME;
205   new_surf_mol-&gt;grid = grid;
206   new_surf_mol-&gt;grid_index = grid_index;
207   new_surf_mol-&gt;s_pos = *mol_uv_pos;
208   new_surf_mol-&gt;orient = orient;
209   if (trigger_unimolecular(world-&gt;reaction_hash, world-&gt;rx_hashsize,
210                            product_species-&gt;hashval,
211                            (struct abstract_molecule *)new_surf_mol) != NULL ||
212       (product_species-&gt;flags &amp; CAN_SURFWALL) != 0)
213     new_surf_mol-&gt;flags |= ACT_REACT;
214   ++grid-&gt;n_occupied;
215   if (grid-&gt;sm_list[grid_index]) {
216     remove_surfmol_from_list(
217         &amp;grid-&gt;sm_list[grid_index], grid-&gt;sm_list[grid_index]-&gt;sm);
218   }
219   grid-&gt;sm_list[grid_index] = add_surfmol_with_unique_pb_to_list(
220     grid-&gt;sm_list[grid_index], new_surf_mol);
221   if (schedule_add_mol(sv-&gt;local_storage-&gt;timer, new_surf_mol))
222     mcell_allocfailed("Failed to add newly created %s molecule to scheduler.",
223                       product_species-&gt;sym-&gt;name);
224   return new_surf_mol;
225 }
226 static int outcome_products_random(struct volume *world, struct wall *w,
227                                    struct vector3 *hitpt, double t,
228                                    struct rxn *rx, int path,
229                                    struct abstract_molecule *reacA,
230                                    struct abstract_molecule *reacB,
231                                    short orientA, short orientB) {
232 #ifdef DEBUG_RXNS
233   DUMP_CONDITION3(
234     dump_processing_reaction(world-&gt;current_iterations, hitpt, t, rx, reacA, reacB, w);
235     dump_molecule_species(reacA);
236     if (reacB != nullptr) {
237       mcell_log(" + ");
238       dump_molecule_species(reacB);
239     }
240     mcell_log("\nreaction_index: %d\n", path);
241     dump_rxn(rx, "", true);
242   );
243 #endif
244 <a name="2"></a>  bool cross_wall = false; 
245 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  int const i0 = rx-&gt;product_idx[path]; 
246   int const iN = rx-&gt;product_idx[path + 1]; 
247   assert(iN &gt; i0);
248   struct species **rx_players = rx-&gt;players + i0; 
249   int const n_players = iN - i0;                  std::vector&lt;struct abstract_molecule *&gt; product(n_players);   std::vector&lt;char&gt; product_type(n_players);
250   std::vector&lt;short&gt; product_orient(n_players);   std::vector&lt;struct surface_grid *&gt; product_grid(n_players);
251   std::vector&lt;int&gt; product_grid_idx(n_players);   std::vector&lt;byte&gt; product_flag(n_players);    
252   bool const is_unimol = is_rxn_unimol(rx);
253   struct surface_grid *tile_grid;   int num_vacant_tiles = 0;       
254   unsigned int reac_idx = UINT_MAX;
255 <a name="0"></a>  struct surface_grid *reac_grid = NULL, *mol_grid = NULL;
256 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  for (int i = 0; i &lt; n_players; ++i) {
257     product[i] = NULL;
258     product_type[i] = PLAYER_NONE;
259     product_orient[i] = 0;
260     product_grid[i] = NULL;
261     product_grid_idx[i] = -1;
262     product_flag[i] = PRODUCT_FLAG_NOT_SET;
263   }
264   struct surface_molecule *const sm_1 =
265       IS_SURF_MOL(reacA) ? (struct surface_molecule *)reacA : NULL;
266   struct surface_molecule *const sm_2 =
267       IS_SURF_MOL(reacB) ? (struct surface_molecule *)reacB : NULL;
268   struct surface_molecule *const sm_reactant = sm_1 ? sm_1 : sm_2;</b></font>
269   bool const is_orientable = (w != NULL) || (sm_reactant != NULL);
270   struct region_list *rlp_head_wall_1 = NULL, *rlp_head_wall_2 = NULL;
271   struct region_list *rlp_head_obj_1 = NULL, *rlp_head_obj_2 = NULL;
272   int sm_bitmask = determine_molecule_region_topology(
273       world, sm_1, sm_2, &amp;rlp_head_wall_1, &amp;rlp_head_wall_2, &amp;rlp_head_obj_1,
274       &amp;rlp_head_obj_2, is_unimol);
275   struct abstract_molecule *const initiator = reacA;
276   short const initiatorOrient = orientA;
277   assert(reacA != NULL);
278   if (reacA-&gt;properties != rx-&gt;players[0]) {
279     struct abstract_molecule *tmp_mol = reacA;
280     reacA = reacB;
281     reacB = tmp_mol;
282     short tmp_orient = orientA;
283     orientA = orientB;
284     orientB = tmp_orient;
285   }
286   assert(reacA != NULL);
287   add_reactants_to_product_list(rx, reacA, reacB, NULL, &amp;product[0], &amp;product_type[0]);
288   int replace_p1 = (product_type[0] == PLAYER_SURF_MOL &amp;&amp; rx_players[0] == NULL);
289   int replace_p2 = rx-&gt;n_reactants &gt; 1 &amp;&amp; (product_type[1] == PLAYER_SURF_MOL &amp;&amp;
290                                            rx_players[1] == NULL);
291   struct vector2 rxn_uv_pos;   int rxn_uv_idx = -1;         int num_surface_static_reactants = 0;   if (is_orientable) {
292     if (sm_reactant) {
293       rxn_uv_pos = sm_reactant-&gt;s_pos;
294     } else {
295       xyz2uv(hitpt, w, &amp;rxn_uv_pos);
296     }
297     assert(w != NULL);
298     if (w-&gt;grid == NULL) {
299       assert(!IS_SURF_MOL(reacA));
300       if (create_grid(world, w, ((struct volume_molecule *)reacA)-&gt;subvol))
301         mcell_allocfailed("Failed to create a grid for a wall.");
302     }
303     rxn_uv_idx = uv2grid(&amp;rxn_uv_pos, w-&gt;grid);
304     if ((sm_1 != NULL) &amp;&amp; (!distinguishable(sm_1-&gt;get_diffusion(sm_1), 0, EPS_C))){
305       num_surface_static_reactants++;
306     }
307     if ((sm_2 != NULL) &amp;&amp; (!distinguishable(sm_2-&gt;get_diffusion(sm_2), 0, EPS_C))){
308       num_surface_static_reactants++;
309     }
310   }
311   int num_surface_products = 0;
312   int num_surface_static_products = 0;   for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
313     if (rx_players[n_product] == NULL) {
314       continue;
315     }
316     if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
317       num_surface_products++;
318       if (!distinguishable(rx_players[n_product]-&gt;D, 0, EPS_C))
319         num_surface_static_products++;
320     }
321   }
322   int mol_idx = INT_MAX;
323   struct tile_neighbor *tile_nbr_head = NULL;   int tile_nbr_list_length = 0;
324   struct tile_neighbor *tile_vacant_nbr_head = NULL;   if (is_orientable) {
325     if (num_surface_products &gt; 0) {
326       if (sm_reactant != NULL) {
327         find_neighbor_tiles(world, sm_reactant, sm_reactant-&gt;grid,
328                             sm_reactant-&gt;grid_index, 1, 0, &amp;tile_nbr_head,
329                             &amp;tile_nbr_list_length);
330       } else {
331         find_neighbor_tiles(world, sm_reactant, w-&gt;grid, rxn_uv_idx, 1, 0,
332                             &amp;tile_nbr_head, &amp;tile_nbr_list_length);
333 <a name="17"></a>      }
334 <font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>      for (struct tile_neighbor *tile_nbr = tile_nbr_head; tile_nbr != NULL;
335            tile_nbr = tile_nbr-&gt;next) {
336         struct surface_molecule_list *sm_list = tile_nbr-&gt;grid-&gt;sm_list[tile_nbr-&gt;idx]; 
337         if (sm_list == NULL || sm_list-&gt;sm == NULL) {
338           num_vacant_tiles++;
339           push_tile_neighbor_to_list(&amp;tile_vacant_nbr_head, tile_nbr-&gt;grid, tile_nbr-&gt;idx);
340         }
341       }
342     }</b></font>
343     int num_recycled_tiles = 0;
344     if (replace_p1 &amp;&amp; replace_p2) {
345       num_recycled_tiles = 2;
346     } else if (replace_p1 || replace_p2) {
347       num_recycled_tiles = 1;
348     }
349     if (num_surface_products &gt; num_vacant_tiles + num_recycled_tiles) {
350       return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
351     }
352     for (int n_product = 0; n_product &lt; n_players; ++n_product) {
353       if (rx_players[n_product] == NULL) {
354         continue;
355       }
356       int this_geometry = rx-&gt;geometries[i0 + n_product];
357       int relative_orient = (this_geometry &lt; 0) ? -1 : 1;
358       this_geometry = abs(this_geometry);
359       if (this_geometry == 0) {
360         product_orient[n_product] = (rng_uint(world-&gt;rng) &amp; 1) ? 1 : -1;
361       } else {
362         if (this_geometry &gt; (int)rx-&gt;n_reactants) {
363           product_orient[n_product] = relative_orient *
364               product_orient[this_geometry - rx-&gt;n_reactants - 1];
365         } else if (this_geometry == 1) {
366           product_orient[n_product] = relative_orient * orientA;
367 <a name="16"></a>        } else if (this_geometry == 2 &amp;&amp; reacB != NULL) {
368           product_orient[n_product] = relative_orient * orientB;
369         } else {
370 <font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>          product_orient[n_product] = relative_orient * 1;
371         }
372       }
373       if (n_product &lt; (int)rx-&gt;n_reactants) {
374         if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
375           assert(IS_SURF_MOL(product[n_product]));
376           struct surface_molecule *sm =
377               (struct surface_molecule *)product[n_product];
378           if (sm-&gt;orient != product_orient[n_product]) {
379             if (product[n_product]-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS|COUNT_ENCLOSED)) {</b></font>
380               count_region_from_scratch(world,
381                                         product[n_product],                                         NULL,                                                       -1,                                                         NULL,                                         w,                                            t,                                            NULL);
382             }
383             if (((sm-&gt;flags &amp; ACT_REACT) != 0) &amp;&amp;
384                 ((sm-&gt;properties-&gt;flags &amp; CAN_SURFWALL) != 0)) {
385               sm-&gt;t2 = 0;
386             }
387             sm-&gt;orient = product_orient[n_product];
388             if (product[n_product]-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS|COUNT_ENCLOSED)) {
389               count_region_from_scratch(world,
390                                         product[n_product],                                         NULL,                                                       1,                                                          NULL,                                         w,                                            t,    <a name="4"></a>                                        NULL);
391             }
392           }
393 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        } else if (!is_unimol) {           if (product[n_product] == initiator) {
394             if (product_orient[n_product] != initiatorOrient)
395               cross_wall = true;
396           }
397         }
398       }
399     }
400     if (num_surface_products == 1) {
401       if (is_unimol &amp;&amp; replace_p1) {
402         for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
403           if (rx_players[n_product] == NULL ||</b></font>
404              (rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0) {
405             continue;
406           }
407           if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
408             product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
409             product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
410             product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
411             replace_p1 = 0;
412             break;
413           }
414         }
415       } else if ((num_surface_static_reactants == 1) &amp;&amp; (num_surface_static_products == 1)
416           &amp;&amp; (replace_p1 || replace_p2)) {
417         for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
418           if (rx_players[n_product] == NULL ||
419               (rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0 ||
420               distinguishable(rx_players[n_product]-&gt;D, 0, EPS_C)) {
421 <a name="3"></a>            continue;
422           }
423 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
424             if (replace_p1 &amp;&amp; (!distinguishable(reacA-&gt;properties-&gt;D, 0, EPS_C))) {
425               product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
426               product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
427               product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
428               replace_p1 = 0;
429               break;
430             } else if (replace_p2 &amp;&amp; (!distinguishable(reacB-&gt;properties-&gt;D, 0, EPS_C))) {
431 <a name="13"></a>              product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
432               product_grid[n_product] = ((struct surface_molecule *)reacB)-&gt;grid;
433               product_grid_idx[n_product] = ((struct surface_molecule *)reacB)-&gt;grid_index;</b></font>
434 <font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>              break;
435             }
436           }
437         }
438       } else if (replace_p1 &amp;&amp; replace_p2) {
439         for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
440           if ((rx_players[n_product] == NULL) ||</b></font>
441               ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
442             continue;
443 <a name="9"></a>          }
444           if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
445 <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>            if (reacA == initiator) {
446               product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
447               product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
448               product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
449               replace_p1 = 0;
450             } else {
451 <a name="12"></a>              product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
452               product_grid[n_product] = ((struct surface_molecule *)reacB)-&gt;grid;
453               product_grid_idx[n_product] = ((struct surface_molecule *)reacB)-&gt;grid_index;</b></font>
454 <font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>            }
455             break;
456           }
457         }
458       } else if (replace_p1) {
459         for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
460           if ((rx_players[n_product] == NULL) ||</b></font>
461               ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
462             continue;
463           }
464           if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
465             product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
466             product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
467             product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
468             replace_p1 = 0;
469             break;
470           }
471         }
472       } else if (replace_p2) {
473         for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
474           if ((rx_players[n_product] == NULL) |
475               ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
476             continue;
477           }
478           if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
479             product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
480             product_grid[n_product] = ((struct surface_molecule *)reacB)-&gt;grid;
481             product_grid_idx[n_product] = ((struct surface_molecule *)reacB)-&gt;grid_index;
482             break;
483           }
484         }
485       }
486     } else if (num_surface_products &gt; 1) {
487       if (num_surface_static_reactants &gt; 0) {
488         bool replace_reacA = (!distinguishable(reacA-&gt;get_diffusion(reacA), 0, EPS_C)) &amp;&amp; replace_p1;
489         bool replace_reacB =
490             (reacB == NULL) ? false : (!distinguishable(reacB-&gt;get_diffusion(reacB), 0, EPS_C)) &amp;&amp; replace_p2;
491         if (replace_reacA || replace_reacB) {
492           int max_static_count = (num_surface_static_products &lt; num_surface_static_reactants)
493             ? num_surface_static_products : num_surface_static_reactants;
494           int count = 0;
495           while (count &lt; max_static_count) {
496             unsigned int rnd_num = rng_uint(world-&gt;rng) % n_players;
497             if ((rnd_num &lt; rx-&gt;n_reactants) || (rx_players[rnd_num] == NULL) ||
498                 ((rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0) ||
499                 distinguishable(rx_players[rnd_num]-&gt;D, 0, EPS_C)) {
500               continue;
501             }
502             if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
503               if (replace_reacA) {
504                 product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
505                 product_grid[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid;
506                 product_grid_idx[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid_index;
507                 count++;
508                 replace_p1 = 0;
509                 replace_reacA = 0;
510               } else if (replace_reacB) {
511                 product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
512                 product_grid[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid;
513                 product_grid_idx[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid_index;
514 <a name="6"></a>                count++;
515                 replace_p2 = 0;
516                 replace_reacB = 0;
517 <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>              }
518             }
519           }         }
520       }
521       if (replace_p1 || replace_p2) {
522         int surf_prod_left = 0, surf_reactant_left = 0;
523         for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
524           if ((rx_players[n_product] == NULL) ||</b></font>
525               ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
526             continue;
527           }
528           if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
529             surf_prod_left++;
530           }
531         }
532         if (replace_p1) {
533           surf_reactant_left++;
534         }
535         if (replace_p2) {
536           surf_reactant_left++;
537         }
538         if (surf_prod_left &gt; 0) {
539           int num_to_place = surf_prod_left;
540           if (surf_prod_left &gt;= surf_reactant_left) {
541             num_to_place = surf_reactant_left;
542           }
543           int count = 0;
544           while (count &lt; num_to_place) {
545             unsigned int rnd_num = rng_uint(world-&gt;rng) % n_players;
546             if ((rnd_num &lt; rx-&gt;n_reactants) || (rx_players[rnd_num] == NULL) ||
547                 (rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0) {
548              continue;
549             }
550             if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
551               if (replace_p1) {
552                 product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
553                 product_grid[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid;
554                 product_grid_idx[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid_index;
555                 count++;
556                 replace_p1 = 0;
557               } else if (replace_p2) {
558                 product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
559                 product_grid[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid;
560                 product_grid_idx[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid_index;
561                 replace_p2 = 0;
562                 count++;
563               }
564             }
565           }         }
566       }
567     }
568     if ((sm_reactant == NULL) &amp;&amp; (w != NULL) &amp;&amp; (num_surface_products &gt;= 1)) {
569       assert(!IS_SURF_MOL(reacA));
570       assert(rxn_uv_idx != -1);
571       while (true) {
572         unsigned int rnd_num = rng_uint(world-&gt;rng) % (n_players);
573         if (rnd_num &lt;= 1 || (rx_players[rnd_num] == NULL) ||
574             (rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0) {
575           continue;
576         }
577         if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
578           product_flag[rnd_num] = PRODUCT_FLAG_USE_UV_LOC;
579           product_grid[rnd_num] = w-&gt;grid;
580           product_grid_idx[rnd_num] = rxn_uv_idx;
581           break;
582         }
583       }
584     }
585     if (is_unimol &amp;&amp; (sm_reactant != NULL) &amp;&amp; (num_surface_products == 2)) {
586       reac_idx = sm_reactant-&gt;grid_index;
587       reac_grid = sm_reactant-&gt;grid;
588     }
589     int do_it_once = 0;     int num_attempts = 0;
590     for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
591       if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
592         if (product_flag[n_product] != PRODUCT_FLAG_NOT_SET) {
593           continue;
594         }
595         if (num_vacant_tiles == 0) {
596           return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
597         }
598         num_attempts = 0;
599         while (true) {
600           if (num_attempts &gt; SURFACE_DIFFUSION_RETRIES) {
601             return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
602           }
603           unsigned int rnd_num = rng_uint(world-&gt;rng) % num_vacant_tiles;
604           int tile_idx = -1;           tile_grid = NULL;
605           if (get_tile_neighbor_from_list_of_vacant_neighbors(
606                   tile_vacant_nbr_head, rnd_num, &amp;tile_grid, &amp;tile_idx) == 0) {
607             return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
608           }
609           if (tile_idx &lt; 0) {
610             continue;           }
611           assert(tile_grid != NULL);
612           if (!product_tile_can_be_reached(tile_grid-&gt;surface, rlp_head_wall_1,
613             rlp_head_wall_2, rlp_head_obj_1, rlp_head_obj_2, sm_bitmask, is_unimol)) {
614             uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
615             num_attempts++;
616             continue;
617           }
618           product_grid[n_product] = tile_grid;
619           product_grid_idx[n_product] = tile_idx;
620           product_flag[n_product] = PRODUCT_FLAG_USE_RANDOM;
621           if (!do_it_once &amp;&amp; is_unimol &amp;&amp; (sm_reactant != NULL) &amp;&amp; (num_surface_products == 2)) {
622             mol_idx = tile_idx;
623             mol_grid = tile_grid;
624             do_it_once = 1;
625           }
626           break;
627         }       }
628     }
629   } 
630   struct vector3 count_pos_xyz;
631   struct periodic_image *periodic_box = ((struct volume_molecule *)reacA)-&gt;periodic_box;
632   if (hitpt != NULL) {
633     count_pos_xyz = *hitpt;
634   } else if (sm_reactant) {
635     uv2xyz(&amp;sm_reactant-&gt;s_pos, sm_reactant-&gt;grid-&gt;surface, &amp;count_pos_xyz);
636   } else {
637     count_pos_xyz = ((struct volume_molecule *)reacA)-&gt;pos;
638   }
639   struct vector3 mol_pos_tmp;
640   struct subvolume *product_subvol = NULL;
641   bool update_dissociation_index = false; 
642   for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
643 <a name="15"></a>    struct graph_data* g_data = NULL;
644     if (rx-&gt;product_graph_data != NULL)
645       g_data = rx-&gt;product_graph_data[path][n_product - rx-&gt;n_reactants];
646 <font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    struct abstract_molecule *this_product = NULL;
647     struct species *const product_species = rx_players[n_product];
648     if (product_species-&gt;flags &amp; ON_GRID) {
649       struct vector2 prod_uv_pos;
650       if (world-&gt;randomize_smol_pos) {
651         switch (product_flag[n_product]) {
652         case PRODUCT_FLAG_USE_REACA_UV:</b></font>
653           if (is_unimol &amp;&amp; (num_surface_products == 2) &amp;&amp; (sm_reactant != NULL)) {
654             if (mol_grid == NULL) {
655               mcell_internal_error("Error in surface product placement for the "
656                                    "unimolecular reaction.");
657             }
658             find_closest_position(product_grid[n_product], product_grid_idx[n_product],
659               mol_grid, mol_idx, &amp;prod_uv_pos);
660           } else {
661             prod_uv_pos = ((struct surface_molecule *)reacA)-&gt;s_pos;
662           }
663           break;
664         case PRODUCT_FLAG_USE_REACB_UV:
665           assert(reacB != NULL);
666           prod_uv_pos = ((struct surface_molecule *)reacB)-&gt;s_pos;
667           break;
668         case PRODUCT_FLAG_USE_UV_LOC:
669           prod_uv_pos = rxn_uv_pos;
670           break;
671         case PRODUCT_FLAG_USE_RANDOM:
672           if (is_unimol &amp;&amp; replace_p1 &amp;&amp; (num_surface_products == 2)) {
673             find_closest_position(product_grid[n_product],
674                                   product_grid_idx[n_product], reac_grid,
675                                   reac_idx, &amp;prod_uv_pos);
676           } else {
677             grid2uv_random(product_grid[n_product], product_grid_idx[n_product],
678                            &amp;prod_uv_pos, world-&gt;rng);
679           }
680           break;
681         default:
682           UNHANDLED_CASE(product_flag[n_product]);
683         }
684       } else {
685         grid2uv(product_grid[n_product], product_grid_idx[n_product], &amp;prod_uv_pos);
686       }
687       this_product = (struct abstract_molecule *)place_sm_product(
688           world, product_species, g_data, product_grid[n_product],
689           product_grid_idx[n_product], &amp;prod_uv_pos, product_orient[n_product],
690           t, reacA-&gt;periodic_box);
691 #ifdef DEBUG_RXNS
692       DUMP_CONDITION3(
693           dump_surface_molecule((struct surface_molecule*)this_product, "", true, "  created sm:", world-&gt;current_iterations, this_product-&gt;t, true);
694       );
695 #endif
696       if (!hitpt) {
697         if (reacA-&gt;properties-&gt;flags &amp; ON_GRID) {
698           w = ((struct surface_molecule *)reacA)-&gt;grid-&gt;surface;
699           uv2xyz(&amp;((struct surface_molecule *)reacA)-&gt;s_pos,
700                  w, &amp;mol_pos_tmp);
701           product_subvol = find_subvolume(world, &amp;mol_pos_tmp, NULL);
702         } else {
703           mol_pos_tmp = ((struct volume_molecule *)reacA)-&gt;pos;
704           product_subvol = ((struct volume_molecule *)reacA)-&gt;subvol;
705         }
706         hitpt = &amp;mol_pos_tmp;
707       } else if (product_subvol == NULL) {
708         product_subvol = find_subvolume(world, hitpt, NULL);
709       }
710       this_product = (struct abstract_molecule *)place_volume_product(
711           world, product_species, g_data, sm_reactant, w, product_subvol, hitpt,
712           product_orient[n_product], t, reacA-&gt;periodic_box);
713 #ifdef DEBUG_RXNS
714       DUMP_CONDITION3(
715       		dump_volume_molecule((struct volume_molecule*)this_product, "", true, "  created vm:", world-&gt;current_iterations, this_product-&gt;t, true);
716       );
717 #endif
718       if (((struct volume_molecule *)this_product)-&gt;index &lt; DISSOCIATION_MAX)
719         update_dissociation_index = true;
720     }
721     if(rx-&gt;product_graph_data != NULL){
722       this_product-&gt;graph_data = g_data;
723     }
724     ++product_species-&gt;population;
725     if (product_species-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED))
726       count_region_from_scratch(world, this_product, NULL, 1, NULL, NULL, t, this_product-&gt;periodic_box);
727 #ifndef MCELL3_DO_NOT_REUSE_MOL_ID_UNIMOL_RXN
728     if (is_unimol &amp;&amp; (n_players == 1)) {
729       this_product-&gt;id = reacA-&gt;id;
730       world-&gt;current_mol_id--;       continue;
731     }
732     if ((n_players == 3) &amp;&amp; product_type[1] == PLAYER_WALL) {
733       this_product-&gt;id = reacA-&gt;id;
734       world-&gt;current_mol_id--; <a name="19"></a>      continue;
735     }
736 #endif
737 <font color="#f62817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  }
738   if (update_dissociation_index) {
739     ASSERT_FOR_MCELL4(false);
740     if (--world-&gt;dissociation_index &lt; DISSOCIATION_MIN)
741       world-&gt;dissociation_index = DISSOCIATION_MAX;
742   }
743   if (rx-&gt;info[path].pathname != NULL) {
744     if (world-&gt;place_waypoints_flag)
745       count_region_from_scratch(world, NULL, rx-&gt;info[path].pathname, 1,</b></font>
746                                 &amp;count_pos_xyz, w, t, periodic_box);
747     if (rx-&gt;info[path].pathname-&gt;magic != NULL) {
748       if (reaction_wizardry(world, rx-&gt;info[path].pathname-&gt;magic, w,
749                             &amp;count_pos_xyz, t))
750         mcell_allocfailed("Failed to complete reaction triggered release after "
751                           "a '%s' reaction.",
752                           rx-&gt;info[path].pathname-&gt;sym-&gt;name);
753     }
754   }
755   delete_tile_neighbor_list(tile_nbr_head);
756   delete_tile_neighbor_list(tile_vacant_nbr_head);
757   delete_region_list(rlp_head_wall_1);
758   delete_region_list(rlp_head_wall_2);
759   delete_region_list(rlp_head_obj_1);
760   delete_region_list(rlp_head_obj_2);
761   return cross_wall ? RX_FLIP : RX_A_OK;
762 }
763 int outcome_unimolecular(struct volume *world, struct rxn *rx, int path,
764                          struct abstract_molecule *reac, double t) {
765   struct species *who_was_i = reac-&gt;properties;
766   int result = RX_A_OK;
767   struct volume_molecule *vm = NULL;
768   struct surface_molecule *sm = NULL;
769   if ((reac-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
770     vm = (struct volume_molecule *)reac;
771     if(reac-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
772 #if 0       for (int path = 0; path &lt; rx-&gt;n_pathways; path++) {
773         outcome_nfsim(world, rx, path, reac, NULL, t);
774       }
775 #else
776       outcome_nfsim(world, rx, path, reac, NULL, t);
777 #endif
778     }
779     result = outcome_products_random(world, NULL, NULL, t, rx, path, reac,
780                                        NULL, 0, 0);
781   } else {
782     sm = (struct surface_molecule *)reac;
783       if ((strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_SURFACE_MOLECULES") == 0) ||
784           (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_MOLECULES") == 0)) {
785       } else {
786         if(reac-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
787           outcome_nfsim(world, rx, path, reac, NULL, t);
788         }
789         result = outcome_products_random(world, sm-&gt;grid-&gt;surface, NULL, t, rx,
790                                          path, reac, NULL, sm-&gt;orient, 0);
791       }
792   }
793   if (result == RX_BLOCKED)
794     return RX_BLOCKED;
795   if (result != RX_BLOCKED) {
796     rx-&gt;info[path].count++;
797     rx-&gt;n_occurred++;
798     if(rx-&gt;product_graph_data != NULL){
799       logNFSimReactions_c(rx-&gt;external_reaction_data[path].reaction_name);
800     }
801   }
802   struct species *who_am_i = rx-&gt;players[rx-&gt;product_idx[path]];
803   if (who_am_i == NULL) {
804     if (vm != NULL) {
805       vm-&gt;subvol-&gt;mol_count--;
806       if (vm-&gt;flags &amp; IN_SCHEDULE)
807         vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
808       if (vm-&gt;properties-&gt;flags &amp; COUNT_SOME_MASK) {
809         count_region_from_scratch(world, (struct abstract_molecule *)vm, NULL,
810                                   -1, &amp;(vm-&gt;pos), NULL, vm-&gt;t, vm-&gt;periodic_box);
811       }
812     } else {
813 #ifdef DEBUG_RXNS
814       DUMP_CONDITION3(
815         dump_surface_molecule(sm, "", true, "Unimolecular sm defunct:", world-&gt;current_iterations, sm-&gt;t, false);
816       );
817 #endif
818       remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
819       sm-&gt;grid-&gt;n_occupied--;
820       if (sm-&gt;flags &amp; IN_SCHEDULE) {
821         sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
822       }
823       if (sm-&gt;properties-&gt;flags &amp; COUNT_SOME_MASK) {
824         count_region_from_scratch(world, (struct abstract_molecule *)sm, NULL,
825                                   -1, NULL, NULL, sm-&gt;t, sm-&gt;periodic_box);
826       }
827     }
828     free(reac-&gt;periodic_box);
829     who_was_i-&gt;n_deceased++;
830     double t_time = convert_iterations_to_seconds(
831         world-&gt;start_iterations, world-&gt;time_unit,
832         world-&gt;simulation_start_seconds, t);
833     who_was_i-&gt;cum_lifetime_seconds += t_time - reac-&gt;birthday;
834     who_was_i-&gt;population--;
835     if (vm != NULL) {
836 #ifdef DEBUG_RXNS
837       DUMP_CONDITION3(
838         dump_volume_molecule(vm, "", true, "Unimolecular vm defunct:", world-&gt;current_iterations, vm-&gt;t, false);
839       );
840 #endif
841       collect_molecule(vm);
842     }
843     else {
844       reac-&gt;properties = NULL;
845       mem_put(reac-&gt;birthplace, reac);
846     }
847     return RX_DESTROY;
848   } else if (who_am_i != who_was_i) {
849     if (vm != NULL) {
850 #ifdef DEBUG_RXNS
851       DUMP_CONDITION3(
852         dump_volume_molecule(vm, "", true, "Unimolecular vm defunct:", world-&gt;current_iterations, vm-&gt;t, false);
853       );
854 #endif
855       collect_molecule(vm);
856     }
857     else
858       reac-&gt;properties = NULL;
859     return RX_DESTROY;
860   } else
861     return result;
862 }
863 int outcome_bimolecular(struct volume *world, struct rxn *rx, int path,
864                         struct abstract_molecule *reacA,
865                         struct abstract_molecule *reacB, short orientA,
866                         short orientB, double t, struct vector3 *hitpt,
867                         struct vector3 *loc_okay) {
868 #ifdef DEBUG_TIMING
869   DUMP_CONDITION3(
870       MCell::dump_outcome_bimolecular_timing(t);
871   );
872 #endif
873 <a name="18"></a>
874   assert(periodic_boxes_are_identical(reacA-&gt;periodic_box, reacB-&gt;periodic_box));
875 <font color="#800517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  struct surface_molecule *sm = NULL;
876   struct volume_molecule *vm = NULL;
877   struct wall *w = NULL;
878   int result;
879   int reacB_was_free = 0;</b></font>
880   int killA, killB;
881   if ((reacA-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
882     if ((reacB-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
883       sm = (struct surface_molecule *)reacB;
884       w = sm-&gt;grid-&gt;surface;
885     }
886   } else {     sm = (struct surface_molecule *)reacA;
887     w = sm-&gt;grid-&gt;surface;
888   }
889   if(reacA-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
890     result = outcome_nfsim(world, rx, path, reacA, reacB, t);
891     result = outcome_products_random(world, w, hitpt, t, rx, path, reacA, reacB,
892                                      orientA, orientB);
893   }
894   else {
895     result = outcome_products_random(world, w, hitpt, t, rx, path, reacA, reacB,
896                                      orientA, orientB);
897   }
898   if (result == RX_BLOCKED)
899     return RX_BLOCKED;
900   rx-&gt;n_occurred++;
901   rx-&gt;info[path].count++;
902   if(rx-&gt;product_graph_data != NULL){
903     logNFSimReactions_c(rx-&gt;external_reaction_data[path].reaction_name);
904   }
905   if (rx-&gt;players[0] == reacA-&gt;properties) {
906     killB = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
907     killA = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
908   } else {
909     killB = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
910     killA = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
911   }
912   if (killB) {
913 #ifdef DEBUG_RXNS
914     DUMP_CONDITION3(
915       dump_volume_molecule((struct volume_molecule*)reacB, "", true, "  defunct m:", world-&gt;current_iterations, 0.0, false);
916 <a name="11"></a>    );
917 #endif
918 <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    vm = NULL;
919     if ((reacB-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
920       sm = (struct surface_molecule *)reacB;
921       remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
922       sm-&gt;grid-&gt;n_occupied--;
923       if (sm-&gt;flags &amp; IN_SURFACE)
924         sm-&gt;flags -= IN_SURFACE;
925       if (sm-&gt;flags &amp; IN_SCHEDULE) {
926         sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
927       }
928     } else if ((reacB-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {</b></font>
929       vm = (struct volume_molecule *)reacB;
930       vm-&gt;subvol-&gt;mol_count--;
931       if (vm-&gt;flags &amp; IN_SCHEDULE) {
932         vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
933       }
934       reacB_was_free = 1;
935     }
936     if ((reacB-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) != 0) {
937       count_region_from_scratch(world, reacB, NULL, -1, NULL, NULL, t, reacB-&gt;periodic_box);
938     }
939     free(reacB-&gt;periodic_box);
940     reacB-&gt;periodic_box = NULL;
941     reacB-&gt;properties-&gt;n_deceased++;
942     double t_time = convert_iterations_to_seconds(
943         world-&gt;start_iterations, world-&gt;time_unit,
944         world-&gt;simulation_start_seconds, t);
945     reacB-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacB-&gt;birthday;
946     reacB-&gt;properties-&gt;population--;
947     if (vm != NULL)
948       collect_molecule(vm);
949     else
950       reacB-&gt;properties = NULL;
951   }
952   if (killA) {
953 #ifdef DEBUG_RXNS
954     DUMP_CONDITION3(
955       dump_volume_molecule((struct volume_molecule*)reacA, "", true, "  defunct m:", world-&gt;current_iterations, 0.0, false);
956     );
957 #endif
958     vm = NULL;
959     if ((reacA-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
960       sm = (struct surface_molecule *)reacA;
961       remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
962       sm-&gt;grid-&gt;n_occupied--;
963 <a name="8"></a>      if (sm-&gt;flags &amp; IN_SCHEDULE) {
964         sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
965       }
966 <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    } else if ((reacA-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
967       vm = (struct volume_molecule *)reacA;
968       vm-&gt;subvol-&gt;mol_count--;
969       if (vm-&gt;flags &amp; IN_SCHEDULE) {
970         vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
971       }
972     }
973     if ((reacA-&gt;properties-&gt;flags &amp; ON_GRID) !=
974         0)     {
975       if (reacA-&gt;properties-&gt;flags &amp;
976           COUNT_SOME_MASK)       {
977         count_region_from_scratch(world, reacA, NULL, -1, NULL, NULL, t, reacA-&gt;periodic_box);</b></font>
978       }
979     } else if (reacA-&gt;flags &amp; COUNT_ME) {
980       if (hitpt == NULL || reacB_was_free ||
981 <a name="7"></a>          (reacB-&gt;properties != NULL &amp;&amp;
982            (reacB-&gt;properties-&gt;flags &amp; NOT_FREE) == 0)) {
983 <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        count_region_from_scratch(world, reacA, NULL, -1, hitpt, NULL, t, reacA-&gt;periodic_box);
984       {
985         struct vector3 fake_hitpt;
986         vm = (struct volume_molecule *)reacA;
987         if (loc_okay == NULL)
988           loc_okay = &amp;(vm-&gt;pos);
989         fake_hitpt.x = 0.5 * hitpt-&gt;x + 0.5 * loc_okay-&gt;x;
990         fake_hitpt.y = 0.5 * hitpt-&gt;y + 0.5 * loc_okay-&gt;y;
991         fake_hitpt.z = 0.5 * hitpt-&gt;z + 0.5 * loc_okay-&gt;z;
992         count_region_from_scratch(world, reacA, NULL, -1, &amp;fake_hitpt, NULL, t, reacA-&gt;periodic_box);</b></font>
993       }
994     }
995 <a name="14"></a>
996     free(reacA-&gt;periodic_box);
997     reacA-&gt;periodic_box = NULL;
998 <font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    reacA-&gt;properties-&gt;n_deceased++;
999     double t_time = convert_iterations_to_seconds(
1000         world-&gt;start_iterations, world-&gt;time_unit,
1001         world-&gt;simulation_start_seconds, t);
1002     reacA-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacA-&gt;birthday;
1003     reacA-&gt;properties-&gt;population--;
1004     if (vm != NULL)
1005       collect_molecule(vm);
1006     else
1007       reacA-&gt;properties = NULL;
1008     return RX_DESTROY;
1009   }
1010   return result;
1011 }</b></font>
1012 int outcome_intersect(struct volume *world, struct rxn *rx, int path,
1013                       struct wall *surface, struct abstract_molecule *reac,
1014                       short orient, double t, struct vector3 *hitpt,
1015                       struct vector3 *loc_okay) {
1016   if (rx-&gt;n_pathways &lt;= RX_SPECIAL) {
1017     rx-&gt;n_occurred++;
1018     if (rx-&gt;n_pathways == RX_REFLEC)
1019       return RX_A_OK;
1020     else
1021       return RX_FLIP;   }
1022   int idx = rx-&gt;product_idx[path];
1023   if ((reac-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
1024     struct volume_molecule *vm = (struct volume_molecule *)reac;
1025     int result;
1026     if ((strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_MOLECULES") == 0) ||
1027         (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_VOLUME_MOLECULES") == 0)) {
1028       result = RX_DESTROY;
1029     } else {
1030       result = outcome_products_random(world, surface, hitpt, t, rx, path,
1031                                        reac, NULL, orient, 0);
1032     }
1033     if (result == RX_BLOCKED)
1034       return RX_A_OK; 
1035     rx-&gt;info[path].count++;
1036     rx-&gt;n_occurred++;
1037     if (rx-&gt;players[idx] == NULL) {
1038       vm-&gt;subvol-&gt;mol_count--;
1039       if (world-&gt;place_waypoints_flag &amp;&amp; (reac-&gt;flags &amp; COUNT_ME)) {
1040         if (hitpt == NULL) {
1041           count_region_from_scratch(
1042             world, reac, NULL, -1, NULL, NULL, t, reac-&gt;periodic_box);
1043         } else {
1044           struct vector3 fake_hitpt;
1045           if (loc_okay == NULL)
1046             loc_okay = &amp;(vm-&gt;pos);
1047           fake_hitpt.x = 0.5 * hitpt-&gt;x + 0.5 * loc_okay-&gt;x;
1048           fake_hitpt.y = 0.5 * hitpt-&gt;y + 0.5 * loc_okay-&gt;y;
1049           fake_hitpt.z = 0.5 * hitpt-&gt;z + 0.5 * loc_okay-&gt;z;
1050           count_region_from_scratch(world, reac, NULL, -1, &amp;fake_hitpt, NULL,
1051                                     t, reac-&gt;periodic_box);
1052         }
1053       }
1054       free(reac-&gt;periodic_box);
1055       reac-&gt;properties-&gt;n_deceased++;
1056       double t_time = convert_iterations_to_seconds(
1057           world-&gt;start_iterations, world-&gt;time_unit,
1058           world-&gt;simulation_start_seconds, t);
1059       reac-&gt;properties-&gt;cum_lifetime_seconds += t_time - reac-&gt;birthday;
1060       reac-&gt;properties-&gt;population--;
1061       if (vm-&gt;flags &amp; IN_SCHEDULE) {
1062         vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
1063       }
1064 #ifdef DEBUG_RXNS
1065       DUMP_CONDITION3(
1066          dump_volume_molecule((struct volume_molecule*)vm, "", true, "  defunct m:", world-&gt;current_iterations, 0.0, false);
1067       );
1068 #endif
1069       collect_molecule(vm);
1070       return RX_DESTROY;
1071     } else
1072       return result;   } else {
1073     return RX_A_OK;
1074   }
1075 }
1076 int reaction_wizardry(struct volume *world, struct magic_list *incantation,
1077                       struct wall *surface, struct vector3 *hitpt, double t) {
1078   struct release_event_queue req; 
1079   req.next = NULL;
1080   req.event_time = t;
1081   req.train_counter = 0;
1082   req.train_high_time = t;
1083   if (hitpt == NULL) {
1084     init_matrix(req.t_matrix);
1085   } else if (surface == NULL ||
1086              !distinguishable(surface-&gt;normal.z, 1.0,
1087                               EPS_C))   {
1088     init_matrix(req.t_matrix);
1089     req.t_matrix[3][0] = hitpt-&gt;x;
1090     req.t_matrix[3][1] = hitpt-&gt;y;
1091     req.t_matrix[3][2] = hitpt-&gt;z;
1092   {
1093     struct vector3 scale = { 1.0, 1.0, 1.0 };     struct vector3 axis = { 1.0, 0.0, 0.0 };      double cos_theta;
1094     double degrees;
1095     cos_theta = surface-&gt;normal.z;     if (!distinguishable(cos_theta, -1.0, EPS_C)) {
1096       degrees = 180.0;     } else {
1097       axis.x = -surface-&gt;normal.y;
1098       axis.y = surface-&gt;normal.x;
1099       axis.z = 0.0;
1100       degrees = acos(cos_theta) * 180.0 / MY_PI;
1101     }
1102     tform_matrix(&amp;scale, hitpt, &amp;axis, degrees, req.t_matrix);
1103   }
1104   for (; incantation != NULL; incantation = incantation-&gt;next) {
1105     if (incantation-&gt;type != magic_release)
1106       continue; 
1107     req.release_site = (struct release_site_obj *)incantation-&gt;data;
1108     if (release_molecules(world, &amp;req))
1109       return 1;
1110   }
1111   return 0;
1112 }
1113 int determine_molecule_region_topology(
1114     struct volume *world, struct surface_molecule *sm_1,
1115     struct surface_molecule *sm_2, struct region_list **rlp_wall_1_ptr,
1116     struct region_list **rlp_wall_2_ptr, struct region_list **rlp_obj_1_ptr,
1117     struct region_list **rlp_obj_2_ptr, bool is_unimol) {
1118   int sm_bitmask = 0;
1119   struct wall *w_1, *w_2;
1120   struct region_list *rlp_head_wall_1 = NULL;
1121   struct region_list *rlp_head_wall_2 = NULL;
1122   struct region_list *rlp_head_obj_1 = NULL;
1123   struct region_list *rlp_head_obj_2 = NULL;
1124 <a name="5"></a>    if ((sm_1 != NULL) &amp;&amp; (sm_2 != NULL)) {
1125 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
1126         (sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
1127         are_restricted_regions_for_species_on_object(
1128             world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
1129         are_restricted_regions_for_species_on_object(
1130             world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2)) {
1131       w_1 = sm_1-&gt;grid-&gt;surface;
1132       w_2 = sm_2-&gt;grid-&gt;surface;
1133       rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
1134       rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
1135       if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 != NULL)) {
1136         sm_bitmask |= ALL_INSIDE;
1137       }
1138       else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 == NULL)) {
1139         rlp_head_obj_1 =
1140 <a name="10"></a>            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
1141         rlp_head_obj_2 =</b></font>
1142             find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
1143 <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        sm_bitmask |= ALL_OUTSIDE;
1144       }
1145       else if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 == NULL)) {
1146         rlp_head_obj_2 =
1147             find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
1148         sm_bitmask |= SURF1_IN_SURF2_OUT;
1149       }
1150       else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 != NULL)) {</b></font>
1151 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        rlp_head_obj_1 =
1152             find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
1153         sm_bitmask |= SURF1_OUT_SURF2_IN;
1154       }
1155     }
1156     else if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
1157              are_restricted_regions_for_species_on_object(
1158                  world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
1159              (!(sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
1160               !are_restricted_regions_for_species_on_object(
1161                    world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2))) {
1162       w_1 = sm_1-&gt;grid-&gt;surface;
1163       rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
1164       if (rlp_head_wall_1 != NULL) {
1165         sm_bitmask |= SURF1_IN;
1166       } else {
1167         rlp_head_obj_1 =
1168             find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
1169         sm_bitmask |= SURF1_OUT;
1170       }
1171     }
1172     else if ((sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
1173              are_restricted_regions_for_species_on_object(
1174                  world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2) &amp;&amp;
1175              (!(sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
1176               !are_restricted_regions_for_species_on_object(
1177                    world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1))) {
1178       w_2 = sm_2-&gt;grid-&gt;surface;
1179       rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
1180       if (rlp_head_wall_2 != NULL) {</b></font>
1181         sm_bitmask |= SURF2_IN;
1182       } else {
1183         rlp_head_obj_2 =
1184             find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
1185         sm_bitmask |= SURF2_OUT;
1186       }
1187     }
1188   }
1189   else if ((sm_1 != NULL) &amp;&amp; is_unimol) {
1190     if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
1191         are_restricted_regions_for_species_on_object(
1192             world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1)) {
1193       w_1 = sm_1-&gt;grid-&gt;surface;
1194       rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
1195       if (rlp_head_wall_1 != NULL) {
1196         sm_bitmask |= ALL_INSIDE;
1197       } else {
1198         rlp_head_obj_1 =
1199             find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
1200         sm_bitmask |= ALL_OUTSIDE;
1201       }
1202     }
1203   }
1204   *rlp_wall_1_ptr = rlp_head_wall_1;
1205   *rlp_wall_2_ptr = rlp_head_wall_2;
1206   *rlp_obj_1_ptr = rlp_head_obj_1;
1207   *rlp_obj_2_ptr = rlp_head_obj_2;
1208   return sm_bitmask;
1209 }
1210 bool product_tile_can_be_reached(struct wall *target,
1211                                  struct region_list *rlp_head_wall_1,
1212                                  struct region_list *rlp_head_wall_2,
1213                                  struct region_list *rlp_head_obj_1,
1214                                  struct region_list *rlp_head_obj_2,
1215                                  int sm_bitmask, bool is_unimol) {
1216   bool status = true;
1217   if (sm_bitmask &amp; ALL_INSIDE) {
1218     if (is_unimol) {
1219       if (!wall_belongs_to_all_regions_in_region_list(target,
1220                                                       rlp_head_wall_1)) {
1221         status = false;
1222       }
1223     } else {
1224       if (!wall_belongs_to_all_regions_in_region_list(target,
1225                                                       rlp_head_wall_1) ||
1226           !wall_belongs_to_all_regions_in_region_list(target,
1227                                                       rlp_head_wall_2)) {
1228         status = false;
1229       }
1230     }
1231   } else if (sm_bitmask &amp; ALL_OUTSIDE) {
1232     if (is_unimol) {
1233       if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1)) {
1234         status = false;
1235       }
1236     } else {
1237       if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1) ||
1238           wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_2)) {
1239         status = false;
1240       }
1241     }
1242   } else if (sm_bitmask &amp; SURF1_IN_SURF2_OUT) {
1243     if (!wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_1) ||
1244         wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_2)) {
1245       status = false;
1246     }
1247   } else if (sm_bitmask &amp; SURF1_OUT_SURF2_IN) {
1248     if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1) ||
1249         !wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_2)) {
1250       status = false;
1251     }
1252   } else if (sm_bitmask &amp; SURF1_IN) {
1253     if (!wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_1)) {
1254       status = false;
1255     }
1256   } else if (sm_bitmask &amp; SURF1_OUT) {
1257     if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1)) {
1258       status = false;
1259     }
1260   } else if (sm_bitmask &amp; SURF2_IN) {
1261     if (!wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_2)) {
1262       status = false;
1263     }
1264   } else if (sm_bitmask &amp; SURF2_OUT) {
1265     if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_2)) {
1266       status = false;
1267     }
1268   }
1269   return status;
1270 }
1271 int cleanup_and_block_rx(struct tile_neighbor *tn1, struct tile_neighbor *tn2) {
1272   if (tn1 != NULL) {
1273     delete_tile_neighbor_list(tn1);
1274   }
1275   if (tn2 != NULL) {
1276     delete_tile_neighbor_list(tn2);
1277   }
1278   return RX_BLOCKED;
1279 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>react_outc_trimol.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;string.h&gt;
3 #include &lt;stdio.h&gt;
4 #include &lt;stdlib.h&gt;
5 #include &lt;assert.h&gt;
6 #include &lt;vector&gt;
7 #include "logging.h"
8 #include "rng.h"
9 #include "util.h"
10 #include "grid_util.h"
11 #include "mcell_structs.h"
12 #include "count_util.h"
13 #include "react.h"
14 #include "vol_util.h"
15 #include "wall_util.h"
16 static int outcome_products_trimol_reaction_random(
17     struct volume *world, struct wall *w, struct vector3 *hitpt, double t,
18     struct rxn *rx, int path, struct abstract_molecule *reacA,
19     struct abstract_molecule *reacB, struct abstract_molecule *reacC,
20     short orientA, short orientB, short orientC);
21 static int outcome_products_trimol_reaction_random(
22     struct volume *world, struct wall *w, struct vector3 *hitpt, double t,
23     struct rxn *rx, int path, struct abstract_molecule *reacA,
24     struct abstract_molecule *reacB, struct abstract_molecule *reacC,
25     short orientA, short orientB, short orientC) {
26   if (reacA != NULL &amp;&amp; reacB != NULL) {
27     assert(periodic_boxes_are_identical(reacA-&gt;periodic_box, reacB-&gt;periodic_box));
28   } else if (reacA != NULL &amp;&amp; reacC != NULL) {
29     assert(periodic_boxes_are_identical(reacA-&gt;periodic_box, reacC-&gt;periodic_box));
30   } else if (reacB != NULL &amp;&amp; reacC != NULL) {
31     assert(periodic_boxes_are_identical(reacB-&gt;periodic_box, reacC-&gt;periodic_box));
32   }
33   bool update_dissociation_index =
34       false;                 bool cross_wall = false; <a name="2"></a>  struct subvolume *last_subvol =
35       NULL; 
36 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  int const i0 =
37       rx-&gt;product_idx[path];   int const iN =
38   assert(iN &gt; i0);
39   struct species **rx_players =
40       rx-&gt;players + i0; 
41   int const n_players = iN - i0;                
42   std::vector&lt;struct abstract_molecule *&gt; product(n_players);   std::vector&lt;char&gt; product_type(n_players);
43   std::vector&lt;short&gt; product_orient(n_players);   std::vector&lt;struct surface_grid *&gt; product_grid(n_players);
44   std::vector&lt;int&gt; product_grid_idx(n_players);   std::vector&lt;byte&gt; product_flag(n_players);    
45   struct tile_neighbor *tile_nbr_head = NULL;   struct tile_neighbor *tile_nbr;               struct tile_neighbor *tile_vacant_nbr_head = NULL;
46   struct surface_grid *tile_grid;   int tile_idx;                     unsigned int rnd_num;             int num_vacant_tiles = 0;         int num_surface_products = 0;     int num_surface_static_products =
47       0;   int num_surface_static_reactants = 0;   int num_surface_reactants = 0;
48   int num_surface_reactants_to_stay = 0;
49   int list_length;   int replace_p1 = 0, replace_p2 = 0, replace_p3 = 0, only_one_to_replace = 0,
50       two_to_replace = 0;
51   int find_neighbor_tiles_flag = 0;
52   struct wall *w_1, *w_2, *w_3;
53   int all_inside_restricted_boundary = 0;
54   int all_outside_restricted_boundary = 0;
55   int sm_1_inside_sm_2_inside_grid_3_outside = 0;
56   int sm_1_inside_sm_2_outside_grid_3_inside = 0;
57   int sm_1_outside_sm_2_inside_grid_3_inside = 0;
58   int sm_1_inside_sm_2_outside_grid_3_outside = 0;
59   int sm_1_outside_sm_2_inside_grid_3_outside = 0;
60   int sm_1_outside_sm_2_outside_grid_3_inside = 0;
61   int only_sm_1_sm_2_inside = 0;
62   int only_sm_1_inside_sm_2_outside = 0;
63   int only_sm_1_outside_sm_2_inside = 0;
64   int only_sm_1_sm_2_outside = 0;
65   int only_sm_1_grid_3_inside = 0;
66   int only_sm_1_inside_grid_3_outside = 0;
67   int only_sm_1_outside_grid_3_inside = 0;
68   int only_sm_1_grid_3_outside = 0;
69   int only_sm_2_grid_3_inside = 0;
70   int only_sm_2_inside_grid_3_outside = 0;
71   int only_sm_2_outside_grid_3_inside = 0;
72   int only_sm_2_grid_3_outside = 0;
73   int only_sm_1_inside = 0;
74   int only_sm_1_outside = 0;
75   int only_sm_2_inside = 0;
76   int only_sm_2_outside = 0;
77   int only_grid_3_inside = 0;
78   int only_grid_3_outside = 0;
79   struct region_list *rlp_head_wall_1 = NULL, *rlp_head_wall_2 = NULL,
80                      *rlp_head_wall_3 = NULL;
81   struct region_list *rlp_head_obj_1 = NULL, *rlp_head_obj_2 = NULL,
82                      *rlp_head_obj_3 = NULL;
83   struct vector2 rxn_uv_pos;   int rxn_uv_idx = -1;       
84   struct abstract_molecule *tmp_mol;
85   short tmp_orient;
86   if ((reacA == NULL) || (reacB == NULL) || (reacC == NULL)) {
87     mcell_internal_error("One of the reactants in "
88                          "'outcome_products_trimol_reaction_random()' is "
89                          "NULL.");
90 <a name="0"></a>  }
91 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  for (int i = 0; i &lt; n_players; ++i) {
92     product[i] = NULL;
93     product_type[i] = PLAYER_NONE;
94     product_orient[i] = 0;
95     product_grid[i] = NULL;
96     product_grid_idx[i] = -1;
97     product_flag[i] = PRODUCT_FLAG_NOT_SET;
98   }
99   struct surface_molecule *const sm_1 =
100       IS_SURF_MOL(reacA) ? (struct surface_molecule *)reacA : NULL;
101   struct surface_molecule *const sm_2 =
102       IS_SURF_MOL(reacB) ? (struct surface_molecule *)reacB : NULL;
103   struct surface_molecule *const grid_3 =
104       IS_SURF_MOL(reacC) ? (struct surface_molecule *)reacC : NULL;</b></font>
105   struct surface_molecule *sm_reactant = NULL;
106   if (sm_1 != NULL) {
107     sm_reactant = sm_1;
108   } else if (sm_2 != NULL) {
109     sm_reactant = sm_2;
110   } else if (grid_3 != NULL) {
111     sm_reactant = grid_3;
112   }
113   bool const is_orientable = (w != NULL) || (sm_reactant != NULL);
114   if ((sm_1 != NULL) &amp;&amp; (sm_2 != NULL) &amp;&amp; (grid_3 != NULL)) {
115     if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
116         (sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
117         (grid_3-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
118         are_restricted_regions_for_species_on_object(
119             world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
120         are_restricted_regions_for_species_on_object(
121             world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2) &amp;&amp;
122         are_restricted_regions_for_species_on_object(
123             world, grid_3-&gt;grid-&gt;surface-&gt;parent_object, grid_3)) {
124       w_1 = sm_1-&gt;grid-&gt;surface;
125       w_2 = sm_2-&gt;grid-&gt;surface;
126       w_3 = grid_3-&gt;grid-&gt;surface;
127       rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
128       rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
129       rlp_head_wall_3 = find_restricted_regions_by_wall(world, w_3, grid_3);
130       if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 != NULL) &amp;&amp;
131           (rlp_head_wall_3 != NULL)) {
132         all_inside_restricted_boundary = 1;
133       } else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 == NULL) &amp;&amp;
134                  (rlp_head_wall_3 == NULL)) {
135         rlp_head_obj_1 =
136             find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
137         rlp_head_obj_2 =
138             find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
139         rlp_head_obj_3 = find_restricted_regions_by_object(
140             world, w_3-&gt;parent_object, grid_3);
141         all_outside_restricted_boundary = 1;
142       } else if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 != NULL) &amp;&amp;
143                  (rlp_head_wall_3 == NULL)) {
144         rlp_head_obj_3 = find_restricted_regions_by_object(
145             world, w_3-&gt;parent_object, grid_3);
146         sm_1_inside_sm_2_inside_grid_3_outside = 1;
147       } else if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_3 != NULL) &amp;&amp;
148                  (rlp_head_wall_2 == NULL)) {
149         rlp_head_obj_2 =
150             find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
151         sm_1_inside_sm_2_outside_grid_3_inside = 1;
152       } else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 != NULL) &amp;&amp;
153                  (rlp_head_wall_3 == NULL)) {
154         rlp_head_obj_1 =
155             find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
156         rlp_head_obj_3 = find_restricted_regions_by_object(
157             world, w_3-&gt;parent_object, grid_3);
158         sm_1_outside_sm_2_inside_grid_3_outside = 1;
159       } else if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 == NULL) &amp;&amp;
160                  (rlp_head_wall_3 == NULL)) {
161         rlp_head_obj_2 =
162             find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
163         rlp_head_obj_3 = find_restricted_regions_by_object(
164             world, w_3-&gt;parent_object, grid_3);
165         sm_1_inside_sm_2_outside_grid_3_outside = 1;
166       } else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 != NULL) &amp;&amp;
167                  (rlp_head_wall_3 != NULL)) {
168         rlp_head_obj_1 =
169             find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
170         sm_1_outside_sm_2_inside_grid_3_inside = 1;
171       } else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 == NULL) &amp;&amp;
172                  (rlp_head_wall_3 != NULL)) {
173         rlp_head_obj_1 =
174             find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
175         rlp_head_obj_2 =
176 <a name="5"></a>            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
177         sm_1_outside_sm_2_outside_grid_3_inside = 1;
178       }
179 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    } else if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
180                are_restricted_regions_for_species_on_object(
181                    world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
182                (sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
183                are_restricted_regions_for_species_on_object(
184                    world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2) &amp;&amp;
185                (!(grid_3-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
186                 !are_restricted_regions_for_species_on_object(
187                      world, grid_3-&gt;grid-&gt;surface-&gt;parent_object, grid_3))) {
188       w_1 = sm_1-&gt;grid-&gt;surface;
189       rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
190       w_2 = sm_2-&gt;grid-&gt;surface;
191       rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
192       if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 != NULL)) {
193         only_sm_1_sm_2_inside = 1;
194       } else if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 == NULL)) {
195         only_sm_1_inside_sm_2_outside = 1;
196         rlp_head_obj_2 =</b></font>
197             find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
198       } else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 != NULL)) {
199         only_sm_1_outside_sm_2_inside = 1;
200         rlp_head_obj_1 =
201             find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
202       } else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 == NULL)) {
203         only_sm_1_sm_2_outside = 1;
204         rlp_head_obj_1 =
205             find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
206         rlp_head_obj_2 =
207             find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
208       }
209     } else if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
210                are_restricted_regions_for_species_on_object(
211                    world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
212                (!(sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
213                 !are_restricted_regions_for_species_on_object(
214                      world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2)) &amp;&amp;
215                (grid_3-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
216                are_restricted_regions_for_species_on_object(
217                    world, grid_3-&gt;grid-&gt;surface-&gt;parent_object, grid_3)) {
218       w_1 = sm_1-&gt;grid-&gt;surface;
219       rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
220 <a name="10"></a>      w_3 = grid_3-&gt;grid-&gt;surface;
221       rlp_head_wall_3 = find_restricted_regions_by_wall(world, w_3, grid_3);
222       if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_3 != NULL)) {
223 <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        only_sm_1_grid_3_inside = 1;
224       } else if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_3 == NULL)) {
225         only_sm_1_inside_grid_3_outside = 1;
226         rlp_head_obj_3 = find_restricted_regions_by_object(
227             world, w_3-&gt;parent_object, grid_3);
228       } else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_3 != NULL)) {</b></font>
229         only_sm_1_outside_grid_3_inside = 1;
230         rlp_head_obj_1 =
231             find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
232       } else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_3 == NULL)) {
233         only_sm_1_grid_3_outside = 1;
234         rlp_head_obj_1 =
235             find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
236         rlp_head_obj_3 = find_restricted_regions_by_object(
237             world, w_3-&gt;parent_object, grid_3);
238       }
239     } else if ((!(sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
240                 (!are_restricted_regions_for_species_on_object(
241                       world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1))) &amp;&amp;
242                (sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
243                are_restricted_regions_for_species_on_object(
244                    world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2) &amp;&amp;
245                (grid_3-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
246                are_restricted_regions_for_species_on_object(
247                    world, grid_3-&gt;grid-&gt;surface-&gt;parent_object, grid_3)) {
248       w_2 = sm_2-&gt;grid-&gt;surface;
249       rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
250       w_3 = grid_3-&gt;grid-&gt;surface;
251       rlp_head_wall_3 = find_restricted_regions_by_wall(world, w_3, grid_3);
252       if ((rlp_head_wall_2 != NULL) &amp;&amp; (rlp_head_wall_3 != NULL)) {
253         only_sm_2_grid_3_inside = 1;
254       } else if ((rlp_head_wall_2 != NULL) &amp;&amp; (rlp_head_wall_3 == NULL)) {
255         only_sm_2_inside_grid_3_outside = 1;
256         rlp_head_obj_3 = find_restricted_regions_by_object(
257             world, w_3-&gt;parent_object, grid_3);
258       } else if ((rlp_head_wall_2 == NULL) &amp;&amp; (rlp_head_wall_3 != NULL)) {
259         only_sm_2_outside_grid_3_inside = 1;
260         rlp_head_obj_2 =
261 <a name="1"></a>            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
262       } else if ((rlp_head_wall_2 == NULL) &amp;&amp; (rlp_head_wall_3 == NULL)) {
263         only_sm_2_grid_3_outside = 1;
264 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        rlp_head_obj_2 =
265             find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
266         rlp_head_obj_3 = find_restricted_regions_by_object(
267             world, w_3-&gt;parent_object, grid_3);
268       }
269     } else if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
270                are_restricted_regions_for_species_on_object(
271                    world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
272                (!(sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
273                 !are_restricted_regions_for_species_on_object(
274                      world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2)) &amp;&amp;
275                (!(grid_3-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
276                 !are_restricted_regions_for_species_on_object(
277                      world, grid_3-&gt;grid-&gt;surface-&gt;parent_object, grid_3))) {
278       w_1 = sm_1-&gt;grid-&gt;surface;
279       rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
280       if (rlp_head_wall_1 != NULL) {
281         only_sm_1_inside = 1;
282       } else {
283         rlp_head_obj_1 =
284             find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
285         only_sm_1_outside = 1;
286       }
287     } else if ((sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
288                are_restricted_regions_for_species_on_object(
289                    world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2) &amp;&amp;
290                (!(sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
291                 !are_restricted_regions_for_species_on_object(
292                      world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1)) &amp;&amp;
293                (!(grid_3-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
294                 !are_restricted_regions_for_species_on_object(
295                      world, grid_3-&gt;grid-&gt;surface-&gt;parent_object, grid_3))) {
296       w_2 = sm_2-&gt;grid-&gt;surface;
297       rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
298       if (rlp_head_wall_2 != NULL)</b></font>
299         only_sm_2_inside = 1;
300       else {
301         rlp_head_obj_2 =
302             find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
303         only_sm_2_outside = 1;
304       }
305     } else if ((grid_3-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
306                are_restricted_regions_for_species_on_object(
307                    world, grid_3-&gt;grid-&gt;surface-&gt;parent_object, grid_3) &amp;&amp;
308                (!(sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
309                 !are_restricted_regions_for_species_on_object(
310                      world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1)) &amp;&amp;
311                (!(sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
312                 !are_restricted_regions_for_species_on_object(
313                      world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2))) {
314       w_3 = grid_3-&gt;grid-&gt;surface;
315       rlp_head_wall_3 = find_restricted_regions_by_wall(world, w_3, grid_3);
316       if (rlp_head_wall_3 != NULL)
317         only_grid_3_inside = 1;
318       else {
319         rlp_head_obj_3 = find_restricted_regions_by_object(
320             world, w_3-&gt;parent_object, grid_3);
321         only_grid_3_outside = 1;
322       }
323     }
324   }
325   struct abstract_molecule *const initiator = reacA;
326   short const initiatorOrient = orientA;
327   if (reacA-&gt;properties == rx-&gt;players[0]) {
328     if (reacB-&gt;properties == rx-&gt;players[2] &amp;&amp;
329         reacB-&gt;properties != rx-&gt;players[1]) {
330       tmp_mol = reacB;
331       reacB = reacC;
332       reacC = tmp_mol;
333       tmp_orient = orientB;
334       orientB = orientC;
335       orientC = tmp_orient;
336     }
337   } else if (reacA-&gt;properties == rx-&gt;players[1]) {
338     if (reacB-&gt;properties == rx-&gt;players[0] &amp;&amp;
339         reacB-&gt;properties != rx-&gt;players[1]) {
340       tmp_mol = reacB;
341       reacB = reacA;
342       reacA = tmp_mol;
343       tmp_orient = orientB;
344       orientB = orientA;
345       orientA = tmp_orient;
346     } else if (reacC-&gt;properties == rx-&gt;players[0]) {
347       tmp_mol = reacA;
348       reacA = reacC;
349       reacC = tmp_mol;
350       tmp_orient = orientA;
351       orientA = orientC;
352       orientC = tmp_orient;
353       tmp_mol = reacB;
354       reacB = reacC;
355       reacC = tmp_mol;
356       tmp_orient = orientB;
357       orientB = orientC;
358       orientC = tmp_orient;
359     }
360   } else if (reacA-&gt;properties == rx-&gt;players[2]) {
361     if (reacB-&gt;properties == rx-&gt;players[0]) {
362       tmp_mol = reacB;
363       reacB = reacA;
364       reacA = tmp_mol;
365       tmp_orient = orientB;
366       orientB = orientA;
367       orientA = tmp_orient;
368       tmp_mol = reacB;
369       reacB = reacC;
370       reacC = tmp_mol;
371       tmp_orient = orientB;
372       orientB = orientC;
373       orientC = tmp_orient;
374     } else if ((reacC-&gt;properties == rx-&gt;players[0]) &amp;&amp;
375                (reacC-&gt;properties != rx-&gt;players[2])) {
376       tmp_mol = reacA;
377       reacA = reacC;
378       reacC = tmp_mol;
379       tmp_orient = orientA;
380       orientA = orientC;
381       orientC = tmp_orient;
382     }
383   }
384   add_reactants_to_product_list(rx, reacA, reacB, reacC, &amp;product[0], &amp;product_type[0]);
385   if (product_type[0] == PLAYER_SURF_MOL) {
386     num_surface_reactants++;
387     if (rx_players[0] == NULL)
388       replace_p1 = 1;
389     else
390       num_surface_reactants_to_stay++;
391   }
392   if (product_type[1] == PLAYER_SURF_MOL) {
393     num_surface_reactants++;
394     if (rx_players[1] == NULL)
395       replace_p2 = 1;
396     else
397       num_surface_reactants_to_stay++;
398   }
399   if (product_type[2] == PLAYER_SURF_MOL) {
400     num_surface_reactants++;
401     if (rx_players[2] == NULL)
402       replace_p3 = 1;
403     else
404       num_surface_reactants_to_stay++;
405   }
406   if (replace_p1 &amp;&amp; (!replace_p2) &amp;&amp; (!replace_p3)) {
407     only_one_to_replace = 1;
408   } else if ((!replace_p1) &amp;&amp; replace_p2 &amp;&amp; (!replace_p3)) {
409     only_one_to_replace = 1;
410   } else if ((!replace_p1) &amp;&amp; (!replace_p2) &amp;&amp; replace_p3) {
411     only_one_to_replace = 1;
412   }
413   if (replace_p1 &amp;&amp; (replace_p2) &amp;&amp; (!replace_p3)) {
414     two_to_replace = 1;
415   } else if (replace_p1 &amp;&amp; (!replace_p2) &amp;&amp; replace_p3) {
416     two_to_replace = 1;
417   } else if ((!replace_p1) &amp;&amp; replace_p2 &amp;&amp; replace_p3) {
418     two_to_replace = 1;
419   }
420   for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
421     if (rx_players[n_product] == NULL)
422       continue;
423     if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
424       num_surface_products++;
425       if (!distinguishable(rx_players[n_product]-&gt;D, 0, EPS_C))
426         num_surface_static_products++;
427     }
428   }
429   if (num_surface_reactants &gt;= 2)
430     find_neighbor_tiles_flag = 1;
431   if ((num_surface_reactants == 1) &amp;&amp; (num_surface_products &gt; 1))
432     find_neighbor_tiles_flag = 1;
433   if (is_orientable) {
434     if (sm_reactant)
435       rxn_uv_pos = sm_reactant-&gt;s_pos;
436     else {
437       xyz2uv(hitpt, w, &amp;rxn_uv_pos);
438     }
439     if ((w == NULL) &amp;&amp; (sm_reactant != NULL))
440       w = sm_reactant-&gt;grid-&gt;surface;
441     assert(w != NULL);
442     if (w-&gt;grid == NULL) {
443       assert(!IS_SURF_MOL(reacA));
444       if (create_grid(world, w, ((struct volume_molecule *)reacA)-&gt;subvol))
445         mcell_allocfailed("Failed to create a grid for a wall.");
446     }
447     if (find_neighbor_tiles_flag) {
448       rxn_uv_idx = uv2grid(&amp;rxn_uv_pos, w-&gt;grid);
449       if (sm_reactant != NULL) {
450         find_neighbor_tiles(world, sm_reactant, sm_reactant-&gt;grid,
451                             sm_reactant-&gt;grid_index, 1, 0, &amp;tile_nbr_head,
452                             &amp;list_length);
453       } else {
454         find_neighbor_tiles(world, sm_reactant, w-&gt;grid, rxn_uv_idx, 1, 0,
455                             &amp;tile_nbr_head, &amp;list_length);
456 <a name="17"></a>      }
457 <font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>      for (tile_nbr = tile_nbr_head; tile_nbr != NULL;
458            tile_nbr = tile_nbr-&gt;next) {
459         struct surface_molecule_list *sm_list = tile_nbr-&gt;grid-&gt;sm_list[tile_nbr-&gt;idx];
460         if (sm_list == NULL || sm_list-&gt;sm == NULL) {
461           num_vacant_tiles++;
462           push_tile_neighbor_to_list(&amp;tile_vacant_nbr_head, tile_nbr-&gt;grid,
463                                      tile_nbr-&gt;idx);
464         }
465       }
466     }</b></font>
467   }
468   if ((sm_1 != NULL) &amp;&amp; !distinguishable(sm_1-&gt;properties-&gt;D, 0, EPS_C))
469     num_surface_static_reactants++;
470   if ((sm_2 != NULL) &amp;&amp; !distinguishable(sm_2-&gt;properties-&gt;D, 0, EPS_C))
471     num_surface_static_reactants++;
472   if ((grid_3 != NULL) &amp;&amp; !distinguishable(grid_3-&gt;properties-&gt;D, 0, EPS_C))
473     num_surface_static_reactants++;
474   if (is_orientable) {
475     if (replace_p1 &amp;&amp; replace_p2 &amp;&amp; replace_p3) {
476       if (num_surface_products &gt; num_vacant_tiles + 3) {
477         if (tile_nbr_head != NULL)
478           delete_tile_neighbor_list(tile_nbr_head);
479         if (tile_vacant_nbr_head != NULL)
480           delete_tile_neighbor_list(tile_vacant_nbr_head);
481         return RX_BLOCKED;
482       }
483     } else if (two_to_replace) {
484       if (num_surface_products &gt; num_vacant_tiles + 2) {
485         if (tile_nbr_head != NULL)
486           delete_tile_neighbor_list(tile_nbr_head);
487         if (tile_vacant_nbr_head != NULL)
488           delete_tile_neighbor_list(tile_vacant_nbr_head);
489         return RX_BLOCKED;
490       }
491     } else if (only_one_to_replace) {
492       if (num_surface_products &gt; num_vacant_tiles + 1) {
493         if (tile_nbr_head != NULL)
494           delete_tile_neighbor_list(tile_nbr_head);
495         if (tile_vacant_nbr_head != NULL)
496           delete_tile_neighbor_list(tile_vacant_nbr_head);
497         return RX_BLOCKED;
498       }
499     } else {
500       if (num_surface_products &gt; num_vacant_tiles) {
501         if (tile_nbr_head != NULL)
502           delete_tile_neighbor_list(tile_nbr_head);
503         if (tile_vacant_nbr_head != NULL)
504           delete_tile_neighbor_list(tile_vacant_nbr_head);
505         return RX_BLOCKED;
506       }
507     }
508     for (int n_product = 0; n_product &lt; n_players; ++n_product) {
509       if (rx_players[n_product] == NULL)
510         continue;
511       int this_geometry = rx-&gt;geometries[i0 + n_product];
512       if (this_geometry == 0)
513         product_orient[n_product] = (rng_uint(world-&gt;rng) &amp; 1) ? 1 : -1;
514       else {
515         if (this_geometry &lt; 0) {
516           this_geometry = -this_geometry;
517           if (this_geometry &gt; (int)rx-&gt;n_reactants)
518             product_orient[n_product] =
519                 -product_orient[this_geometry - rx-&gt;n_reactants - 1];
520           else if (this_geometry == 1)
521             product_orient[n_product] = -orientA;
522           else if ((this_geometry == 2) &amp;&amp; (reacB != NULL))
523             product_orient[n_product] = -orientB;
524           else if ((this_geometry == 3) &amp;&amp; (reacC != NULL))
525             product_orient[n_product] = -orientC;
526           else
527             product_orient[n_product] = -1;
528         }
529         else {
530           if (this_geometry &gt; (int)rx-&gt;n_reactants)
531             product_orient[n_product] =
532                 product_orient[this_geometry - rx-&gt;n_reactants - 1];
533           else if (this_geometry == 1)
534             product_orient[n_product] = orientA;
535           else if ((this_geometry == 2) &amp;&amp; (reacB != NULL))
536             product_orient[n_product] = orientB;
537 <a name="16"></a>          else if ((this_geometry == 3) &amp;&amp; (reacC != NULL))
538             product_orient[n_product] = orientC;
539           else
540 <font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>            product_orient[n_product] = 1;
541         }
542       }
543       if (n_product &lt; (int)rx-&gt;n_reactants) {
544         if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
545           assert(IS_SURF_MOL(product[n_product]));
546           struct surface_molecule *sm =
547               (struct surface_molecule *)product[n_product];
548           if (sm-&gt;orient != product_orient[n_product]) {
549             if (product[n_product]-&gt;properties-&gt;flags &amp;</b></font>
550                 (COUNT_CONTENTS | COUNT_ENCLOSED))
551               count_region_from_scratch(world,
552                                         product[n_product],                                         NULL,                                                       -1,                                                         NULL,                                         w,                                            t,                                            NULL);
553             if (((sm-&gt;flags &amp; ACT_REACT) != 0) &amp;&amp;
554                 ((sm-&gt;properties-&gt;flags &amp; CAN_SURFWALL) != 0))
555               sm-&gt;t2 = 0;
556             sm-&gt;orient = product_orient[n_product];
557             if (product[n_product]-&gt;properties-&gt;flags &amp;
558                 (COUNT_CONTENTS | COUNT_ENCLOSED))
559               count_region_from_scratch(world,
560                                         product[n_product],                                         NULL,                                                       1,                                                          NULL,                                         w,                                            t,                                            NULL);
561           }
562 <a name="4"></a>        }
563 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        else {
564           if (product[n_product] == initiator) {
565             if (product_orient[n_product] != initiatorOrient)
566               cross_wall = true;
567           }
568         }
569       }
570     }
571     if (num_surface_products == 1) {
572       if ((num_surface_static_reactants == 1) &amp;&amp;
573           (num_surface_static_products == 1) &amp;&amp;
574           (replace_p1 || replace_p2 || replace_p3)) {
575         for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players;
576              n_product++) {
577           if (rx_players[n_product] == NULL)</b></font>
578             continue;
579           if ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)
580             continue;
581 <a name="3"></a>          if (distinguishable(rx_players[n_product]-&gt;D, 0, EPS_C))
582             continue;
583 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
584             if (replace_p1 &amp;&amp; !distinguishable(reacA-&gt;properties-&gt;D, 0, EPS_C)) {
585               product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
586               product_grid[n_product] =
587                   ((struct surface_molecule *)reacA)-&gt;grid;
588               product_grid_idx[n_product] =
589                   ((struct surface_molecule *)reacA)-&gt;grid_index;
590               replace_p1 = 0;
591               break;
592             } else if (replace_p2 &amp;&amp; !distinguishable(reacB-&gt;properties-&gt;D, 0, EPS_C)) {
593               product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
594               product_grid[n_product] =
595                   ((struct surface_molecule *)reacB)-&gt;grid;
596               product_grid_idx[n_product] =
597                   ((struct surface_molecule *)reacB)-&gt;grid_index;</b></font>
598               replace_p2 = 0;
599               break;
600             } else if (replace_p3 &amp;&amp; !distinguishable(reacC-&gt;properties-&gt;D, 0, EPS_C)) {
601               product_flag[n_product] = PRODUCT_FLAG_USE_REACC_UV;
602               product_grid[n_product] =
603                   ((struct surface_molecule *)reacC)-&gt;grid;
604 <a name="13"></a>              product_grid_idx[n_product] =
605                   ((struct surface_molecule *)reacC)-&gt;grid_index;
606               replace_p3 = 0;
607 <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>              break;
608             }
609           }
610         }
611       } else if (replace_p1 &amp;&amp; replace_p2 &amp;&amp; replace_p3) {
612         for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players;
613              n_product++) {
614           if (rx_players[n_product] == NULL)</b></font>
615             continue;
616           if ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)
617             continue;
618           if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
619             if (reacA == initiator) {
620               product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
621               product_grid[n_product] =
622                   ((struct surface_molecule *)reacA)-&gt;grid;
623 <a name="9"></a>              product_grid_idx[n_product] =
624                   ((struct surface_molecule *)reacA)-&gt;grid_index;
625               replace_p1 = 0;
626 <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>            } else if (reacB == initiator) {
627               product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
628               product_grid[n_product] =
629                   ((struct surface_molecule *)reacB)-&gt;grid;
630               product_grid_idx[n_product] =
631                   ((struct surface_molecule *)reacB)-&gt;grid_index;
632               replace_p2 = 0;
633             } else {
634               product_flag[n_product] = PRODUCT_FLAG_USE_REACC_UV;
635               product_grid[n_product] =
636                   ((struct surface_molecule *)reacC)-&gt;grid;
637               product_grid_idx[n_product] =
638                   ((struct surface_molecule *)reacC)-&gt;grid_index;</b></font>
639               replace_p3 = 0;
640             }
641             break;
642           }
643         }
644       } else if (two_to_replace) {
645         while (true) {
646           rnd_num = rng_uint(world-&gt;rng) % (rx-&gt;n_reactants);
647           if ((rnd_num == 0) &amp;&amp; replace_p1)
648             break;
649           if ((rnd_num == 1) &amp;&amp; replace_p2)
650             break;
651           if ((rnd_num == 2) &amp;&amp; replace_p3)
652             break;
653         }
654         for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players;
655              n_product++) {
656           if (rx_players[n_product] == NULL)
657             continue;
658           if ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)
659             continue;
660           if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
661             if (rnd_num == 0) {
662               product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
663               product_grid[n_product] =
664                   ((struct surface_molecule *)reacA)-&gt;grid;
665               product_grid_idx[n_product] =
666                   ((struct surface_molecule *)reacA)-&gt;grid_index;
667               replace_p1 = 0;
668             } else if (rnd_num == 1) {
669               product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
670               product_grid[n_product] =
671                   ((struct surface_molecule *)reacB)-&gt;grid;
672               product_grid_idx[n_product] =
673                   ((struct surface_molecule *)reacB)-&gt;grid_index;
674               replace_p2 = 0;
675             } else if (rnd_num == 2) {
676               product_flag[n_product] = PRODUCT_FLAG_USE_REACC_UV;
677               product_grid[n_product] =
678                   ((struct surface_molecule *)reacC)-&gt;grid;
679 <a name="12"></a>              product_grid_idx[n_product] =
680                   ((struct surface_molecule *)reacC)-&gt;grid_index;
681               replace_p3 = 0;
682 <font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>            }
683             break;
684           }
685         }
686       } else if (only_one_to_replace) {
687         for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players;
688              n_product++) {
689           if (rx_players[n_product] == NULL)</b></font>
690             continue;
691           if ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)
692             continue;
693           if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
694             if (replace_p1) {
695               product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
696               product_grid[n_product] =
697                   ((struct surface_molecule *)reacA)-&gt;grid;
698               product_grid_idx[n_product] =
699                   ((struct surface_molecule *)reacA)-&gt;grid_index;
700               replace_p1 = 0;
701               break;
702             } else if (replace_p2) {
703               product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
704               product_grid[n_product] =
705                   ((struct surface_molecule *)reacB)-&gt;grid;
706               product_grid_idx[n_product] =
707                   ((struct surface_molecule *)reacB)-&gt;grid_index;
708               replace_p2 = 0;
709               break;
710             } else {
711               product_flag[n_product] = PRODUCT_FLAG_USE_REACC_UV;
712               product_grid[n_product] =
713                   ((struct surface_molecule *)reacC)-&gt;grid;
714               product_grid_idx[n_product] =
715                   ((struct surface_molecule *)reacC)-&gt;grid_index;
716               replace_p3 = 0;
717               break;
718             }
719           }
720         }
721       }
722     } else if (num_surface_products &gt; 1) {
723       int count;
724       if (num_surface_static_reactants &gt; 0) {
725         if (num_surface_static_products &gt;= num_surface_static_reactants) {
726           count = 0;
727           while (count &lt; num_surface_static_reactants) {
728             rnd_num = rng_uint(world-&gt;rng) % n_players;
729             if (rnd_num &lt; 3)
730               continue;
731             if (rx_players[rnd_num] == NULL)
732               continue;
733             if ((rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0)
734               continue;
735             if (distinguishable(rx_players[rnd_num]-&gt;D, 0, EPS_C))
736               continue;
737             if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
738               if ((!distinguishable(reacA-&gt;properties-&gt;D, 0, EPS_C)) &amp;&amp; replace_p1) {
739                 product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
740                 product_grid[rnd_num] =
741                     ((struct surface_molecule *)reacA)-&gt;grid;
742                 product_grid_idx[rnd_num] =
743                     ((struct surface_molecule *)reacA)-&gt;grid_index;
744                 replace_p1 = 0;
745                 count++;
746                 continue;
747               }
748               if ((!distinguishable(reacB-&gt;properties-&gt;D, 0, EPS_C)) &amp;&amp; replace_p2) {
749                 product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
750                 product_grid[rnd_num] =
751                     ((struct surface_molecule *)reacB)-&gt;grid;
752                 product_grid_idx[rnd_num] =
753                     ((struct surface_molecule *)reacB)-&gt;grid_index;
754                 replace_p2 = 0;
755                 count++;
756                 continue;
757               }
758               if ((!distinguishable(reacC-&gt;properties-&gt;D, 0, EPS_C)) &amp;&amp; replace_p3) {
759                 product_flag[rnd_num] = PRODUCT_FLAG_USE_REACC_UV;
760                 product_grid[rnd_num] =
761                     ((struct surface_molecule *)reacC)-&gt;grid;
762                 product_grid_idx[rnd_num] =
763                     ((struct surface_molecule *)reacC)-&gt;grid_index;
764                 replace_p3 = 0;
765                 count++;
766                 continue;
767               }
768             }
769           } 
770           count = 0;
771           while (count &lt; num_surface_static_products) {
772             rnd_num = rng_uint(world-&gt;rng) % n_players;
773             if (rnd_num &lt; 3)
774               continue;
775             if (rx_players[rnd_num] == NULL)
776               continue;
777             if ((rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0)
778               continue;
779             if (distinguishable(rx_players[rnd_num]-&gt;D, 0, EPS_C))
780               continue;
781             if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
782               if ((!distinguishable(reacA-&gt;properties-&gt;D, 0, EPS_C)) &amp;&amp; replace_p1) {
783                 product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
784                 product_grid[rnd_num] =
785                     ((struct surface_molecule *)reacA)-&gt;grid;
786                 product_grid_idx[rnd_num] =
787                     ((struct surface_molecule *)reacA)-&gt;grid_index;
788                 replace_p1 = 0;
789                 count++;
790                 continue;
791               }
792               if ((!distinguishable(reacB-&gt;properties-&gt;D, 0, EPS_C)) &amp;&amp; replace_p2) {
793                 product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
794                 product_grid[rnd_num] =
795                     ((struct surface_molecule *)reacB)-&gt;grid;
796                 product_grid_idx[rnd_num] =
797                     ((struct surface_molecule *)reacB)-&gt;grid_index;
798                 replace_p2 = 0;
799                 count++;
800                 continue;
801               }
802               if ((!distinguishable(reacC-&gt;properties-&gt;D, 0, EPS_C)) &amp;&amp; replace_p3) {
803                 product_flag[rnd_num] = PRODUCT_FLAG_USE_REACC_UV;
804                 product_grid[rnd_num] =
805                     ((struct surface_molecule *)reacC)-&gt;grid;
806                 product_grid_idx[rnd_num] =
807                     ((struct surface_molecule *)reacC)-&gt;grid_index;
808 <a name="6"></a>                replace_p3 = 0;
809                 count++;
810                 continue;
811 <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>              }
812             }
813           }         }
814       }
815       if (replace_p1 || replace_p2 || replace_p3) {
816         int surf_prod_left = 0, surf_reactant_left = 0;
817         for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players;
818              n_product++) {
819           if (rx_players[n_product] == NULL)</b></font>
820             continue;
821           if ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)
822             continue;
823           if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET)
824             surf_prod_left++;
825         }
826         if (replace_p1)
827           surf_reactant_left++;
828         if (replace_p2)
829           surf_reactant_left++;
830         if (replace_p3)
831           surf_reactant_left++;
832         if (surf_prod_left &gt; 0) {
833           if (surf_prod_left &gt;= surf_reactant_left) {
834             count = 0;
835             while (count &lt; surf_reactant_left) {
836               rnd_num = rng_uint(world-&gt;rng) % n_players;
837               if (rnd_num &lt; 3)
838                 continue;
839               if (rx_players[rnd_num] == NULL)
840                 continue;
841               if ((rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0)
842                 continue;
843               if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
844                 if (replace_p1) {
845                   product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
846                   product_grid[rnd_num] =
847                       ((struct surface_molecule *)reacA)-&gt;grid;
848                   product_grid_idx[rnd_num] =
849                       ((struct surface_molecule *)reacA)-&gt;grid_index;
850                   replace_p1 = 0;
851                   count++;
852                   continue;
853                 }
854                 if (replace_p2) {
855                   product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
856                   product_grid[rnd_num] =
857                       ((struct surface_molecule *)reacB)-&gt;grid;
858                   product_grid_idx[rnd_num] =
859                       ((struct surface_molecule *)reacB)-&gt;grid_index;
860                   replace_p2 = 0;
861                   count++;
862                   continue;
863                 }
864                 if (replace_p3) {
865                   product_flag[rnd_num] = PRODUCT_FLAG_USE_REACC_UV;
866                   product_grid[rnd_num] =
867                       ((struct surface_molecule *)reacC)-&gt;grid;
868                   product_grid_idx[rnd_num] =
869                       ((struct surface_molecule *)reacC)-&gt;grid_index;
870                   replace_p3 = 0;
871                   count++;
872                   continue;
873                 }
874               }
875             } 
876           } else {             count = 0;
877             while (count &lt; surf_prod_left) {
878               rnd_num = rng_uint(world-&gt;rng) % n_players;
879               if (rnd_num &lt; 3)
880                 continue;
881               if (rx_players[rnd_num] == NULL)
882                 continue;
883               if ((rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0)
884                 continue;
885               if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
886                 if (replace_p1) {
887                   product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
888                   product_grid[rnd_num] =
889                       ((struct surface_molecule *)reacA)-&gt;grid;
890                   product_grid_idx[rnd_num] =
891                       ((struct surface_molecule *)reacA)-&gt;grid_index;
892                   replace_p1 = 0;
893                   count++;
894                   continue;
895                 }
896                 if (replace_p2) {
897                   product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
898                   product_grid[rnd_num] =
899                       ((struct surface_molecule *)reacB)-&gt;grid;
900                   product_grid_idx[rnd_num] =
901                       ((struct surface_molecule *)reacB)-&gt;grid_index;
902                   replace_p2 = 0;
903                   count++;
904                   continue;
905                 }
906                 if (replace_p3) {
907                   product_flag[rnd_num] = PRODUCT_FLAG_USE_REACC_UV;
908                   product_grid[rnd_num] =
909                       ((struct surface_molecule *)reacC)-&gt;grid;
910                   product_grid_idx[rnd_num] =
911                       ((struct surface_molecule *)reacC)-&gt;grid_index;
912                   replace_p3 = 0;
913                   count++;
914                   continue;
915                 }
916               }
917             }           }
918         }
919       }
920     }
921     int num_attempts = 0;
922     for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
923       if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
924         if (product_flag[n_product] != PRODUCT_FLAG_NOT_SET)
925           continue;
926         if (num_vacant_tiles == 0) {
927           if (tile_nbr_head != NULL)
928             delete_tile_neighbor_list(tile_nbr_head);
929           if (tile_vacant_nbr_head != NULL)
930             delete_tile_neighbor_list(tile_vacant_nbr_head);
931           return RX_BLOCKED;
932         }
933         while (true) {
934           if (num_attempts &gt; SURFACE_DIFFUSION_RETRIES) {
935             if (tile_nbr_head != NULL)
936               delete_tile_neighbor_list(tile_nbr_head);
937             if (tile_vacant_nbr_head != NULL)
938               delete_tile_neighbor_list(tile_vacant_nbr_head);
939             return RX_BLOCKED;
940           }
941           rnd_num = rng_uint(world-&gt;rng) % num_vacant_tiles;
942           tile_idx = -1;
943           tile_grid = NULL;
944           if (get_tile_neighbor_from_list_of_vacant_neighbors(
945                   tile_vacant_nbr_head, rnd_num, &amp;tile_grid, &amp;tile_idx) == 0) {
946             if (tile_nbr_head != NULL)
947               delete_tile_neighbor_list(tile_nbr_head);
948             if (tile_vacant_nbr_head != NULL)
949               delete_tile_neighbor_list(tile_vacant_nbr_head);
950             return RX_BLOCKED;
951           }
952           if (tile_idx &lt; 0)
953             continue; 
954           assert(tile_grid != NULL);
955           if (all_inside_restricted_boundary) {
956             int cond_1 = 0, cond_2 = 0, cond_3 = 0;
957             cond_1 = (!wall_belongs_to_all_regions_in_region_list(
958                            tile_grid-&gt;surface, rlp_head_wall_1));
959             cond_2 = (!wall_belongs_to_all_regions_in_region_list(
960                            tile_grid-&gt;surface, rlp_head_wall_2));
961             cond_3 = (!wall_belongs_to_all_regions_in_region_list(
962                            tile_grid-&gt;surface, rlp_head_wall_3));
963             if (cond_1 || cond_2 || cond_3) {
964               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
965               num_attempts++;
966               continue;
967             }
968           } else if (all_outside_restricted_boundary) {
969             int cond_1 = 0, cond_2 = 0, cond_3 = 0;
970             cond_1 = wall_belongs_to_any_region_in_region_list(
971                 tile_grid-&gt;surface, rlp_head_obj_1);
972             cond_2 = wall_belongs_to_any_region_in_region_list(
973                 tile_grid-&gt;surface, rlp_head_obj_2);
974             cond_3 = wall_belongs_to_any_region_in_region_list(
975                 tile_grid-&gt;surface, rlp_head_obj_3);
976             if (cond_1 || cond_2 || cond_3) {
977               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
978               num_attempts++;
979               continue;
980             }
981           } else if (sm_1_inside_sm_2_inside_grid_3_outside) {
982             int cond_1 = 0, cond_2 = 0, cond_3 = 0;
983             cond_1 = !(wall_belongs_to_all_regions_in_region_list(
984                           tile_grid-&gt;surface, rlp_head_wall_1));
985             cond_2 = !(wall_belongs_to_all_regions_in_region_list(
986                           tile_grid-&gt;surface, rlp_head_wall_2));
987             cond_3 = wall_belongs_to_any_region_in_region_list(
988                 tile_grid-&gt;surface, rlp_head_obj_3);
989             if (cond_1 || cond_2 || cond_3) {
990               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
991               num_attempts++;
992               continue;
993             }
994           } else if (sm_1_inside_sm_2_outside_grid_3_inside) {
995             int cond_1 = 0, cond_2 = 0, cond_3 = 0;
996             cond_1 = !(wall_belongs_to_all_regions_in_region_list(
997                           tile_grid-&gt;surface, rlp_head_wall_1));
998             cond_2 = wall_belongs_to_any_region_in_region_list(
999                 tile_grid-&gt;surface, rlp_head_obj_2);
1000             cond_3 = !(wall_belongs_to_all_regions_in_region_list(
1001                           tile_grid-&gt;surface, rlp_head_wall_3));
1002             if (cond_1 || cond_2 || cond_3) {
1003               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
1004               num_attempts++;
1005               continue;
1006             }
1007           } else if (sm_1_inside_sm_2_outside_grid_3_outside) {
1008             int cond_1 = 0, cond_2 = 0, cond_3 = 0;
1009             cond_1 = !(wall_belongs_to_all_regions_in_region_list(
1010                           tile_grid-&gt;surface, rlp_head_wall_1));
1011             cond_2 = wall_belongs_to_any_region_in_region_list(
1012                 tile_grid-&gt;surface, rlp_head_obj_2);
1013             cond_3 = wall_belongs_to_any_region_in_region_list(
1014                 tile_grid-&gt;surface, rlp_head_obj_3);
1015             if (cond_1 || cond_2 || cond_3) {
1016               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
1017               num_attempts++;
1018               continue;
1019             }
1020           } else if (sm_1_outside_sm_2_inside_grid_3_outside) {
1021             int cond_1 = 0, cond_2 = 0, cond_3 = 0;
1022             cond_1 = wall_belongs_to_any_region_in_region_list(
1023                 tile_grid-&gt;surface, rlp_head_obj_1);
1024             cond_2 = !(wall_belongs_to_all_regions_in_region_list(
1025                           tile_grid-&gt;surface, rlp_head_wall_2));
1026             cond_3 = wall_belongs_to_any_region_in_region_list(
1027                 tile_grid-&gt;surface, rlp_head_obj_3);
1028             if (cond_1 || cond_2 || cond_3) {
1029               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
1030               num_attempts++;
1031               continue;
1032             }
1033           } else if (sm_1_outside_sm_2_inside_grid_3_inside) {
1034             int cond_1 = 0, cond_2 = 0, cond_3 = 0;
1035             cond_1 = wall_belongs_to_any_region_in_region_list(
1036                 tile_grid-&gt;surface, rlp_head_obj_1);
1037             cond_2 = !(wall_belongs_to_all_regions_in_region_list(
1038                           tile_grid-&gt;surface, rlp_head_wall_2));
1039             cond_3 = !(wall_belongs_to_all_regions_in_region_list(
1040                           tile_grid-&gt;surface, rlp_head_wall_3));
1041             if (cond_1 || cond_2 || cond_3) {
1042               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
1043               num_attempts++;
1044               continue;
1045             }
1046           } else if (sm_1_outside_sm_2_outside_grid_3_inside) {
1047             int cond_1 = 0, cond_2 = 0, cond_3 = 0;
1048             cond_1 = wall_belongs_to_any_region_in_region_list(
1049                 tile_grid-&gt;surface, rlp_head_obj_1);
1050             cond_2 = wall_belongs_to_any_region_in_region_list(
1051                 tile_grid-&gt;surface, rlp_head_obj_2);
1052             cond_3 = !(wall_belongs_to_all_regions_in_region_list(
1053                           tile_grid-&gt;surface, rlp_head_wall_3));
1054             if (cond_1 || cond_2 || cond_3) {
1055               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
1056               num_attempts++;
1057               continue;
1058             }
1059           } else if (only_sm_1_sm_2_inside) {
1060             int cond_1 = 0, cond_2 = 0;
1061             cond_1 = !(wall_belongs_to_all_regions_in_region_list(
1062                           tile_grid-&gt;surface, rlp_head_wall_1));
1063             cond_2 = !(wall_belongs_to_all_regions_in_region_list(
1064                           tile_grid-&gt;surface, rlp_head_wall_2));
1065             if (cond_1 || cond_2) {
1066               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
1067               num_attempts++;
1068               continue;
1069             }
1070           } else if (only_sm_1_inside_sm_2_outside) {
1071             int cond_1 = 0, cond_2 = 0;
1072             cond_1 = !(wall_belongs_to_all_regions_in_region_list(
1073                           tile_grid-&gt;surface, rlp_head_wall_1));
1074             cond_2 = wall_belongs_to_any_region_in_region_list(
1075                 tile_grid-&gt;surface, rlp_head_obj_2);
1076             if (cond_1 || cond_2) {
1077               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
1078               num_attempts++;
1079               continue;
1080             }
1081           } else if (only_sm_1_outside_sm_2_inside) {
1082             int cond_1 = 0, cond_2 = 0;
1083             cond_1 = wall_belongs_to_any_region_in_region_list(
1084                 tile_grid-&gt;surface, rlp_head_obj_1);
1085             cond_2 = !(wall_belongs_to_all_regions_in_region_list(
1086                           tile_grid-&gt;surface, rlp_head_wall_2));
1087             if (cond_1 || cond_2) {
1088               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
1089               num_attempts++;
1090               continue;
1091             }
1092           } else if (only_sm_1_sm_2_outside) {
1093             int cond_1 = 0, cond_2 = 0;
1094             cond_1 = wall_belongs_to_any_region_in_region_list(
1095                 tile_grid-&gt;surface, rlp_head_obj_1);
1096             cond_2 = wall_belongs_to_any_region_in_region_list(
1097                 tile_grid-&gt;surface, rlp_head_obj_2);
1098             if (cond_1 || cond_2) {
1099               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
1100               num_attempts++;
1101               continue;
1102             }
1103           } else if (only_sm_1_grid_3_inside) {
1104             int cond_1 = 0, cond_2 = 0;
1105             cond_1 = !(wall_belongs_to_all_regions_in_region_list(
1106                           tile_grid-&gt;surface, rlp_head_wall_1));
1107             cond_2 = !(wall_belongs_to_all_regions_in_region_list(
1108                           tile_grid-&gt;surface, rlp_head_wall_3));
1109             if (cond_1 || cond_2) {
1110               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
1111               num_attempts++;
1112               continue;
1113             }
1114           } else if (only_sm_1_inside_grid_3_outside) {
1115             int cond_1 = 0, cond_2 = 0;
1116             cond_1 = !(wall_belongs_to_all_regions_in_region_list(
1117                           tile_grid-&gt;surface, rlp_head_wall_1));
1118             cond_2 = wall_belongs_to_any_region_in_region_list(
1119                 tile_grid-&gt;surface, rlp_head_obj_3);
1120             if (cond_1 || cond_2) {
1121               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
1122               num_attempts++;
1123               continue;
1124             }
1125           } else if (only_sm_1_outside_grid_3_inside) {
1126             int cond_1 = 0, cond_2 = 0;
1127             cond_1 = wall_belongs_to_any_region_in_region_list(
1128                 tile_grid-&gt;surface, rlp_head_obj_1);
1129             cond_2 = !(wall_belongs_to_all_regions_in_region_list(
1130                           tile_grid-&gt;surface, rlp_head_wall_3));
1131             if (cond_1 || cond_2) {
1132               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
1133               num_attempts++;
1134               continue;
1135             }
1136           } else if (only_sm_1_grid_3_outside) {
1137             int cond_1 = 0, cond_2 = 0;
1138             cond_1 = wall_belongs_to_any_region_in_region_list(
1139                 tile_grid-&gt;surface, rlp_head_obj_1);
1140             cond_2 = wall_belongs_to_any_region_in_region_list(
1141                 tile_grid-&gt;surface, rlp_head_obj_3);
1142             if (cond_1 || cond_2) {
1143               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
1144               num_attempts++;
1145               continue;
1146             }
1147           } else if (only_sm_2_grid_3_inside) {
1148             int cond_1 = 0, cond_2 = 0;
1149             cond_1 = !(wall_belongs_to_all_regions_in_region_list(
1150                           tile_grid-&gt;surface, rlp_head_wall_2));
1151             cond_2 = !(wall_belongs_to_all_regions_in_region_list(
1152                           tile_grid-&gt;surface, rlp_head_wall_3));
1153             if (cond_1 || cond_2) {
1154               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
1155               num_attempts++;
1156               continue;
1157             }
1158           } else if (only_sm_2_inside_grid_3_outside) {
1159             int cond_1 = 0, cond_2 = 0;
1160             cond_1 = !(wall_belongs_to_all_regions_in_region_list(
1161                           tile_grid-&gt;surface, rlp_head_wall_2));
1162             cond_2 = wall_belongs_to_any_region_in_region_list(
1163                 tile_grid-&gt;surface, rlp_head_obj_3);
1164             if (cond_1 || cond_2) {
1165               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
1166               num_attempts++;
1167               continue;
1168             }
1169           } else if (only_sm_2_outside_grid_3_inside) {
1170             int cond_1 = 0, cond_2 = 0;
1171             cond_1 = wall_belongs_to_any_region_in_region_list(
1172                 tile_grid-&gt;surface, rlp_head_obj_2);
1173             cond_2 = !(wall_belongs_to_all_regions_in_region_list(
1174                           tile_grid-&gt;surface, rlp_head_wall_3));
1175             if (cond_1 || cond_2) {
1176               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
1177               num_attempts++;
1178               continue;
1179             }
1180           } else if (only_sm_2_grid_3_outside) {
1181             int cond_1 = 0, cond_2 = 0;
1182             cond_1 = wall_belongs_to_any_region_in_region_list(
1183                 tile_grid-&gt;surface, rlp_head_obj_2);
1184             cond_2 = wall_belongs_to_any_region_in_region_list(
1185                 tile_grid-&gt;surface, rlp_head_obj_3);
1186             if (cond_1 || cond_2) {
1187               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
1188               num_attempts++;
1189               continue;
1190             }
1191           } else if (only_sm_1_inside) {
1192             if (!wall_belongs_to_all_regions_in_region_list(tile_grid-&gt;surface,
1193                                                             rlp_head_wall_1)) {
1194               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
1195               num_attempts++;
1196               continue;
1197             }
1198           } else if (only_sm_1_outside) {
1199             if (wall_belongs_to_any_region_in_region_list(tile_grid-&gt;surface,
1200                                                           rlp_head_obj_1)) {
1201               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
1202               num_attempts++;
1203               continue;
1204             }
1205           } else if (only_sm_2_inside) {
1206             if (!wall_belongs_to_all_regions_in_region_list(tile_grid-&gt;surface,
1207                                                             rlp_head_wall_2)) {
1208               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
1209               num_attempts++;
1210               continue;
1211             }
1212           } else if (only_sm_2_outside) {
1213             if (wall_belongs_to_any_region_in_region_list(tile_grid-&gt;surface,
1214                                                           rlp_head_obj_2)) {
1215               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
1216               num_attempts++;
1217               continue;
1218             }
1219           } else if (only_grid_3_inside) {
1220             if (!wall_belongs_to_all_regions_in_region_list(tile_grid-&gt;surface,
1221                                                             rlp_head_wall_3)) {
1222               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
1223               num_attempts++;
1224               continue;
1225             }
1226           } else if (only_grid_3_outside) {
1227             if (wall_belongs_to_any_region_in_region_list(tile_grid-&gt;surface,
1228                                                           rlp_head_obj_3)) {
1229               uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
1230               num_attempts++;
1231               continue;
1232             }
1233           }
1234           product_grid[n_product] = tile_grid;
1235           product_grid_idx[n_product] = tile_idx;
1236           product_flag[n_product] = PRODUCT_FLAG_USE_RANDOM;
1237           break;
1238         }
1239       }
1240     }
1241   } 
1242   struct vector3 count_pos_xyz;
1243   if (hitpt != NULL)
1244     count_pos_xyz = *hitpt;
1245   else if (sm_reactant)
1246     uv2xyz(&amp;sm_reactant-&gt;s_pos, sm_reactant-&gt;grid-&gt;surface, &amp;count_pos_xyz);
1247   else
1248     count_pos_xyz = ((struct volume_molecule *)reacA)-&gt;pos;
1249 <a name="15"></a>  struct vector3 mol_pos_tmp;
1250   struct subvolume *product_subvol = NULL;
1251   for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
1252 <font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    struct abstract_molecule *this_product = NULL;
1253     struct species *const product_species = rx_players[n_product];
1254     if (product_species-&gt;flags &amp; ON_GRID) {
1255       struct vector2 prod_uv_pos;
1256       if (world-&gt;randomize_smol_pos) {
1257         switch (product_flag[n_product]) {
1258         case PRODUCT_FLAG_USE_REACA_UV:</b></font>
1259           prod_uv_pos = ((struct surface_molecule *)reacA)-&gt;s_pos;
1260           break;
1261         case PRODUCT_FLAG_USE_REACB_UV:
1262           prod_uv_pos = ((struct surface_molecule *)reacB)-&gt;s_pos;
1263           break;
1264         case PRODUCT_FLAG_USE_REACC_UV:
1265           prod_uv_pos = ((struct surface_molecule *)reacC)-&gt;s_pos;
1266           break;
1267         case PRODUCT_FLAG_USE_RANDOM:
1268           grid2uv_random(product_grid[n_product], product_grid_idx[n_product],
1269                          &amp;prod_uv_pos, world-&gt;rng);
1270           break;
1271         default:
1272           UNHANDLED_CASE(product_flag[n_product]);
1273         }
1274       } else
1275         grid2uv(product_grid[n_product], product_grid_idx[n_product],
1276                 &amp;prod_uv_pos);
1277       this_product = (struct abstract_molecule *)place_sm_product(
1278           world, product_species, 0, product_grid[n_product],
1279           product_grid_idx[n_product], &amp;prod_uv_pos, product_orient[n_product],
1280           t, reacA-&gt;periodic_box);
1281     }
1282     else {
1283       if (!hitpt) {
1284         if (reacA-&gt;properties-&gt;flags &amp; ON_GRID) {
1285           uv2xyz(&amp;((struct surface_molecule *)reacA)-&gt;s_pos,
1286                  ((struct surface_molecule *)reacA)-&gt;grid-&gt;surface,
1287                  &amp;mol_pos_tmp);
1288           product_subvol = find_subvolume(world, &amp;mol_pos_tmp, last_subvol);
1289         }
1290         else {
1291           mol_pos_tmp = ((struct volume_molecule *)reacA)-&gt;pos;
1292           product_subvol = ((struct volume_molecule *)reacA)-&gt;subvol;
1293         }
1294         hitpt = &amp;mol_pos_tmp;
1295       } else
1296         product_subvol = find_subvolume(world, hitpt, last_subvol);
1297       this_product = (struct abstract_molecule *)place_volume_product(
1298           world, product_species, 0, sm_reactant, w, product_subvol, hitpt,
1299           product_orient[n_product], t, reacA-&gt;periodic_box);
1300       if (((struct volume_molecule *)this_product)-&gt;index &lt; DISSOCIATION_MAX)
1301         update_dissociation_index = true;
1302     }
1303 <a name="19"></a>    ++product_species-&gt;population;
1304     if (product_species-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED))
1305       count_region_from_scratch(world, this_product, NULL, 1, NULL, NULL, t, NULL);
1306 <font color="#f62817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  }
1307   if (update_dissociation_index) {
1308     if (--world-&gt;dissociation_index &lt; DISSOCIATION_MIN)
1309       world-&gt;dissociation_index = DISSOCIATION_MAX;
1310   }
1311   if (rx-&gt;info[path].pathname != NULL) {
1312     if (world-&gt;place_waypoints_flag)
1313       count_region_from_scratch(world, NULL, rx-&gt;info[path].pathname, 1,</b></font>
1314                                 &amp;count_pos_xyz, w, t, NULL);
1315     if (rx-&gt;info[path].pathname-&gt;magic != NULL) {
1316       if (reaction_wizardry(world, rx-&gt;info[path].pathname-&gt;magic, w,
1317                             &amp;count_pos_xyz, t))
1318         mcell_allocfailed("Failed to complete reaction triggered release after "
1319                           "a '%s' reaction.",
1320                           rx-&gt;info[path].pathname-&gt;sym-&gt;name);
1321     }
1322   }
1323   if (tile_nbr_head != NULL)
1324     delete_tile_neighbor_list(tile_nbr_head);
1325   if (tile_vacant_nbr_head != NULL)
1326     delete_tile_neighbor_list(tile_vacant_nbr_head);
1327   return cross_wall ? RX_FLIP : RX_A_OK;
1328 }
1329 int outcome_trimolecular(struct volume *world, struct rxn *rx, int path,
1330                          struct abstract_molecule *reacA,
1331                          struct abstract_molecule *reacB,
1332 <a name="18"></a>                         struct abstract_molecule *reacC, short orientA,
1333                          short orientB, short orientC, double t,
1334                          struct vector3 *hitpt, struct vector3 *loc_okay) {
1335 <font color="#800517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  struct wall *w = NULL;
1336   struct volume_molecule *vm = NULL;
1337   struct surface_molecule *sm = NULL;
1338   int result;
1339   int killA = 0, killB = 0, killC = 0;</b></font>
1340   int reacA_is_free = 0;
1341   int reacB_is_free = 0;
1342   int reacC_is_free = 0;
1343   int num_surface_reactants = 0;
1344   if ((reacA-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
1345     reacA_is_free = 1;
1346   } else
1347     num_surface_reactants++;
1348   if ((reacB-&gt;properties-&gt;flags &amp; NOT_FREE) == 0)
1349     reacB_is_free = 1;
1350   else
1351     num_surface_reactants++;
1352   if ((reacC-&gt;properties-&gt;flags &amp; NOT_FREE) == 0)
1353     reacC_is_free = 1;
1354   else
1355     num_surface_reactants++;
1356   if (!reacA_is_free) {
1357     sm = (struct surface_molecule *)reacA;
1358   } else if (!reacB_is_free) {
1359     sm = (struct surface_molecule *)reacB;
1360   } else if (!reacC_is_free) {
1361     sm = (struct surface_molecule *)reacC;
1362   }
1363   if (sm != NULL)
1364     w = sm-&gt;grid-&gt;surface;
1365   result = outcome_products_trimol_reaction_random(world, w, hitpt, t, rx, path,
1366                                                    reacA, reacB, reacC, orientA,
1367                                                    orientB, orientC);
1368   if (result == RX_BLOCKED)
1369     return RX_BLOCKED;
1370   rx-&gt;n_occurred++;
1371   rx-&gt;info[path].count++;
1372   if (rx-&gt;players[0] == reacA-&gt;properties) {
1373     if (rx-&gt;players[1] == reacB-&gt;properties) {
1374       killC = (rx-&gt;players[rx-&gt;product_idx[path] + 2] == NULL);
1375       killB = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
1376       killA = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
1377     } else {
1378       killB = (rx-&gt;players[rx-&gt;product_idx[path] + 2] == NULL);
1379       killC = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
1380       killA = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
1381     }
1382   } else if (rx-&gt;players[0] == reacB-&gt;properties) {
1383     if (rx-&gt;players[1] == reacA-&gt;properties) {
1384       killC = (rx-&gt;players[rx-&gt;product_idx[path] + 2] == NULL);
1385       killA = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
1386       killB = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
1387     } else {
1388       killA = (rx-&gt;players[rx-&gt;product_idx[path] + 2] == NULL);
1389       killC = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
1390       killB = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
1391     }
1392   } else if (rx-&gt;players[0] == reacC-&gt;properties) {
1393     if (rx-&gt;players[1] == reacA-&gt;properties) {
1394       killB = (rx-&gt;players[rx-&gt;product_idx[path] + 2] == NULL);
1395       killA = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
1396       killC = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
1397     } else {
1398       killA = (rx-&gt;players[rx-&gt;product_idx[path] + 2] == NULL);
1399       killB = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
1400       killC = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
1401     }
1402 <a name="11"></a>  }
1403   if (killC) {
1404 <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    vm = NULL;
1405     if ((reacC-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
1406       sm = (struct surface_molecule *)reacC;
1407       remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
1408       sm-&gt;grid-&gt;n_occupied--;
1409       if (sm-&gt;flags &amp; IN_SURFACE)
1410         sm-&gt;flags -= IN_SURFACE;
1411       if (sm-&gt;flags &amp; IN_SCHEDULE) {
1412         sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
1413       }
1414     } else {</b></font>
1415       vm = (struct volume_molecule *)reacC;
1416       vm-&gt;subvol-&gt;mol_count--;
1417       if (vm-&gt;flags &amp; IN_SCHEDULE) {
1418         vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
1419       }
1420     }
1421     if ((reacC-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) != 0) {
1422       count_region_from_scratch(world, reacC, NULL, -1, NULL, NULL, t, NULL);
1423     }
1424     reacC-&gt;properties-&gt;n_deceased++;
1425     double t_time = convert_iterations_to_seconds(
1426         world-&gt;start_iterations, world-&gt;time_unit,
1427         world-&gt;simulation_start_seconds, t);
1428     reacC-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacC-&gt;birthday;
1429     reacC-&gt;properties-&gt;population--;
1430     if (vm != NULL)
1431       collect_molecule(vm);
1432     else {
1433       reacC-&gt;properties = NULL;
1434       if ((reacC-&gt;flags &amp; IN_MASK) == 0)
1435         mem_put(reacC-&gt;birthplace, reacC);
1436     }
1437   }
1438   if (killB) {
1439     vm = NULL;
1440     if ((reacB-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
1441       sm = (struct surface_molecule *)reacB;
1442       remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
1443       sm-&gt;grid-&gt;n_occupied--;
1444       if (sm-&gt;flags &amp; IN_SURFACE)
1445         sm-&gt;flags -= IN_SURFACE;
1446       if (sm-&gt;flags &amp; IN_SCHEDULE) {
1447         sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
1448       }
1449     } else {
1450       vm = (struct volume_molecule *)reacB;
1451       vm-&gt;subvol-&gt;mol_count--;
1452       if (vm-&gt;flags &amp; IN_SCHEDULE) {
1453         vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
1454       }
1455     }
1456     if ((reacB-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) != 0) {
1457       count_region_from_scratch(world, reacB, NULL, -1, NULL, NULL, t, NULL);
1458     }
1459     reacB-&gt;properties-&gt;n_deceased++;
1460     double t_time = convert_iterations_to_seconds(
1461         world-&gt;start_iterations, world-&gt;time_unit,
1462         world-&gt;simulation_start_seconds, t);
1463     reacB-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacB-&gt;birthday;
1464     reacB-&gt;properties-&gt;population--;
1465     if (vm != NULL)
1466       collect_molecule(vm);
1467     else {
1468       reacB-&gt;properties = NULL;
1469       if ((reacB-&gt;flags &amp; IN_MASK) == 0)
1470         mem_put(reacB-&gt;birthplace, reacB);
1471     }
1472   }
1473   if (killA) {
1474     vm = NULL;
1475     if ((reacA-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
1476       sm = (struct surface_molecule *)reacA;
1477       remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
1478       sm-&gt;grid-&gt;n_occupied--;
1479       if (sm-&gt;flags &amp; IN_SURFACE)
1480         sm-&gt;flags -= IN_SURFACE;
1481 <a name="8"></a>      if (sm-&gt;flags &amp; IN_SCHEDULE) {
1482         sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
1483       }
1484 <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    } else {
1485       vm = (struct volume_molecule *)reacA;
1486       vm-&gt;subvol-&gt;mol_count--;
1487       if (vm-&gt;flags &amp; IN_SCHEDULE) {
1488         vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
1489       }
1490     }
1491     if ((reacA-&gt;properties-&gt;flags &amp; ON_GRID) !=
1492         0)     {
1493       if (reacA-&gt;properties-&gt;flags &amp;
1494           COUNT_SOME_MASK)       {
1495         count_region_from_scratch(world, reacA, NULL, -1, NULL, NULL, t, NULL);</b></font>
1496       }
1497     } else if ((reacA-&gt;flags &amp; COUNT_ME) &amp;&amp; world-&gt;place_waypoints_flag) {
1498 <a name="7"></a>      if (hitpt == NULL || (reacB_is_free &amp;&amp; reacC_is_free))
1499       {
1500 <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        count_region_from_scratch(world, reacA, NULL, -1, hitpt, NULL, t, NULL);
1501       {
1502         struct vector3 fake_hitpt;
1503         vm = (struct volume_molecule *)reacA;
1504         if (loc_okay == NULL)
1505           loc_okay = &amp;(vm-&gt;pos);
1506         fake_hitpt.x = 0.5 * hitpt-&gt;x + 0.5 * loc_okay-&gt;x;
1507         fake_hitpt.y = 0.5 * hitpt-&gt;y + 0.5 * loc_okay-&gt;y;
1508         fake_hitpt.z = 0.5 * hitpt-&gt;z + 0.5 * loc_okay-&gt;z;
1509 <a name="14"></a>        count_region_from_scratch(world, reacA, NULL, -1, &amp;fake_hitpt, NULL, t, NULL);</b></font>
1510       }
1511     }
1512 <font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    reacA-&gt;properties-&gt;n_deceased++;
1513     double t_time = convert_iterations_to_seconds(
1514         world-&gt;start_iterations, world-&gt;time_unit,
1515         world-&gt;simulation_start_seconds, t);
1516     reacA-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacA-&gt;birthday;
1517     reacA-&gt;properties-&gt;population--;
1518     if (vm != NULL)
1519       collect_molecule(vm);
1520     else
1521       reacA-&gt;properties = NULL;
1522     return RX_DESTROY;
1523   }
1524   return result;
1525 }</b></font>
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
