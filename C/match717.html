<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for react_outc.c &amp; react_outc_trimol.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for react_outc.c &amp; react_outc_trimol.c
      </h3>
<h1 align="center">
        17.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>react_outc.c (18.681917%)<th>react_outc_trimol.c (16.310034%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(394-408)<td><a href="#" name="0">(249-264)</a><td align="center"><font color="#ff0000">30</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1675-1708)<td><a href="#" name="1">(441-477)</a><td align="center"><font color="#e50000">27</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(366-381)<td><a href="#" name="2">(78-96)</a><td align="center"><font color="#bb0000">22</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(652-662)<td><a href="#" name="3">(871-885)</a><td align="center"><font color="#aa0000">20</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(615-629)<td><a href="#" name="4">(845-864)</a><td align="center"><font color="#aa0000">20</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(1642-1661)<td><a href="#" name="5">(350-369)</a><td align="center"><font color="#a10000">19</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(755-766)<td><a href="#" name="6">(1121-1140)</a><td align="center"><font color="#900000">17</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(1383-1399)<td><a href="#" name="7">(1950-1967)</a><td align="center"><font color="#880000">16</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(1360-1374)<td><a href="#" name="8">(1929-1942)</a><td align="center"><font color="#880000">16</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(677-685)<td><a href="#" name="9">(918-930)</a><td align="center"><font color="#880000">16</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(1663-1674)<td><a href="#" name="10">(398-403)</a><td align="center"><font color="#7f0000">15</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(1305-1316)<td><a href="#" name="11">(1840-1851)</a><td align="center"><font color="#7f0000">15</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(686-692)<td><a href="#" name="12">(980-989)</a><td align="center"><font color="#7f0000">15</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(663-671)<td><a href="#" name="13">(895-905)</a><td align="center"><font color="#7f0000">15</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(1405-1421)<td><a href="#" name="14">(1970-1984)</a><td align="center"><font color="#770000">14</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(921-931)<td><a href="#" name="15">(1628-1638)</a><td align="center"><font color="#770000">14</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(552-576)<td><a href="#" name="16">(778-803)</a><td align="center"><font color="#770000">14</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(508-516)<td><a href="#" name="17">(679-688)</a><td align="center"><font color="#770000">14</font>
<tr onclick='openModal("#800517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#800517"><font color="#800517">-</font><td><a href="#" name="18">(1250-1255)<td><a href="#" name="18">(1760-1765)</a><td align="center"><font color="#660000">12</font>
<tr onclick='openModal("#f62817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f62817"><font color="#f62817">-</font><td><a href="#" name="19">(1043-1057)<td><a href="#" name="19">(1702-1715)</a><td align="center"><font color="#660000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>react_outc.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/******************************************************************************
 *
 * Copyright (C) 2006-2017 by
 * The Salk Institute for Biological Studies and
 * Pittsburgh Supercomputing Center, Carnegie Mellon University
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 *
******************************************************************************/

#include "config.h"

#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;vector&gt;

#include "logging.h"
#include "rng.h"
#include "util.h"
#include "grid_util.h"
#include "count_util.h"
#include "react.h"
#include "vol_util.h"
#include "wall_util.h"
#include "nfsim_func.h"
#include "mcell_reactions.h"

#include "diffuse.h"

#include "debug_config.h"
#include "debug.h"
#include "dump_state.h"

static int outcome_products_random(struct volume *world, struct wall *w,
                                   struct vector3 *hitpt, double t,
                                   struct rxn *rx, int path,
                                   struct abstract_molecule *reacA,
                                   struct abstract_molecule *reacB,
                                   short orientA, short orientB);


static int cleanup_and_block_rx(struct tile_neighbor *tn1, struct tile_neighbor *tn2);

int is_compatible_surface(void *req_species, struct wall *w) {
  struct surf_class_list *scl, *scl2;

  struct surf_class_list *rs_head = (struct surf_class_list *)req_species;

  if (rs_head == NULL)
    return 1;

  for (scl = w-&gt;surf_class_head; scl != NULL; scl = scl-&gt;next) {
    for (scl2 = rs_head; scl2 != NULL; scl2 = scl2-&gt;next) {
      if (scl-&gt;surf_class == scl2-&gt;surf_class)
        return 1;
    }
  }

  return 0;
}

void add_reactants_to_product_list(struct rxn *rx, struct abstract_molecule *reacA,
  struct abstract_molecule *reacB, struct abstract_molecule *reacC,
  struct abstract_molecule **player, char *player_type) {

  /* Add reacA to the list of players, saving the reactant's type. */
  player[0] = reacA;
  player_type[0] = IS_SURF_MOL(reacA) ? PLAYER_SURF_MOL : PLAYER_VOL_MOL;

  /* If we have a second reactant, add it to the list of players. */
  if (rx-&gt;n_reactants &gt; 1) {

    /* If the second reactant is a wall... */
    if (reacB == NULL) {
      assert(rx-&gt;n_reactants == 2);
      player[1] = NULL;
      player_type[1] = PLAYER_WALL;
    } else {  // else 2nd reactant is a wall
      player[1] = reacB;
      player_type[1] = IS_SURF_MOL(reacB) ? PLAYER_SURF_MOL : PLAYER_VOL_MOL;
    }

    if (rx-&gt;n_reactants &gt; 2) {
      if (reacC == NULL) {
        /* it's a wall. */
        player[2] = NULL;
        player_type[2] = PLAYER_WALL;
      } else {
        player[2] = reacC;
        player_type[2] = IS_SURF_MOL(reacC) ? PLAYER_SURF_MOL : PLAYER_VOL_MOL;
      }
    }
  }
}

static bool is_rxn_unimol(struct rxn *rx) {
  if (rx-&gt;n_reactants == 1)
    return true;

  if (rx-&gt;n_reactants != 2)
    return false;

  if (!(rx-&gt;players[0]-&gt;flags &amp; ON_GRID))
    return false;

  return (rx-&gt;players[1]-&gt;flags &amp; IS_SURFACE) != 0;
}

void tiny_diffuse_3D(
    struct volume *world,
    struct subvolume *subvol,
    struct vector3 *displacement,
    struct vector3 *pos,
    struct wall *w) {

  struct vector3 temp_displacement = {
    displacement-&gt;x,
    displacement-&gt;y,
    displacement-&gt;z
  };
  struct collision *shead = ray_trace(
      world, pos, NULL, subvol, &amp;temp_displacement, w);
  if (shead-&gt;next != NULL) {
    shead = (struct collision *)ae_list_sort((struct abstract_element *)shead);
  }

  struct collision *smash = NULL;
  for (smash = shead; smash != NULL; smash = smash-&gt;next) {
    if ((smash-&gt;what &amp; COLLIDE_WALL) != 0) {
      vectorize(pos, &amp;(smash-&gt;loc), displacement);
      scalar_prod(displacement, 0.5, displacement);
      break;
    }
  }
  pos-&gt;x += displacement-&gt;x;
  pos-&gt;y += displacement-&gt;y;
  pos-&gt;z += displacement-&gt;z;
  subvol = find_subvolume(world, pos, subvol);
}

struct volume_molecule *
place_volume_product(struct volume *world, struct species *product_species, struct graph_data* graph,
                     struct surface_molecule *sm_reactant, struct wall *w,
                     struct subvolume *subvol, struct vector3 *hitpt,
                     short orient, double t, struct periodic_image *periodic_box) {
  struct vector3 pos = *hitpt;

  /* For an orientable reaction, we need to move products away from the surface
   * to ensure they end up on the correct side of the plane. */
  if (w) {
    double bump = (orient &gt; 0) ? EPS_C : -EPS_C;
    struct vector3 displacement = {2 * bump * w-&gt;normal.x,
                                   2 * bump * w-&gt;normal.y,
                                   2 * bump * w-&gt;normal.z,
                                  };
    tiny_diffuse_3D(world, subvol, &amp;displacement, &amp;pos, w);
  }

  /* Allocate and initialize the molecule. */
  struct volume_molecule *new_volume_mol;
  new_volume_mol =
      (struct volume_molecule *)CHECKED_MEM_GET(subvol-&gt;local_storage-&gt;mol, "volume molecule");
  new_volume_mol-&gt;birthplace = subvol-&gt;local_storage-&gt;mol;
  new_volume_mol-&gt;birthday = convert_iterations_to_seconds(
      world-&gt;start_iterations, world-&gt;time_unit,
      world-&gt;simulation_start_seconds, t);
  new_volume_mol-&gt;id = world-&gt;current_mol_id++;
  new_volume_mol-&gt;t = t;
  new_volume_mol-&gt;t2 = 0.0;

  new_volume_mol-&gt;periodic_box = CHECKED_MALLOC_STRUCT(struct periodic_image,
    "periodic image descriptor");
  new_volume_mol-&gt;periodic_box-&gt;x = periodic_box-&gt;x;
  new_volume_mol-&gt;periodic_box-&gt;y = periodic_box-&gt;y;
  new_volume_mol-&gt;periodic_box-&gt;z = periodic_box-&gt;z;

  new_volume_mol-&gt;properties = product_species;
  new_volume_mol-&gt;graph_data = graph;
  initialize_diffusion_function((struct abstract_molecule*) new_volume_mol);

  new_volume_mol-&gt;prev_v = NULL;
  new_volume_mol-&gt;next_v = NULL;
  new_volume_mol-&gt;pos = pos;
  new_volume_mol-&gt;subvol = subvol;
  new_volume_mol-&gt;index = 0;
  new_volume_mol-&gt;flags = TYPE_VOL | ACT_NEWBIE | IN_VOLUME | IN_SCHEDULE;
  //if the molecule is extern then inherit the reactant's diffusion.
  //XXX: is this the best way?


  if (new_volume_mol-&gt;get_space_step(new_volume_mol) &gt; 0.0)
    new_volume_mol-&gt;flags |= ACT_DIFFUSE;
  if ((product_species-&gt;flags &amp; COUNT_SOME_MASK) != 0)
    new_volume_mol-&gt;flags |= COUNT_ME;

  /* Check whether the product can undergo unimolecular rxns; if so, mark it. */
  if (trigger_unimolecular(world-&gt;reaction_hash, world-&gt;rx_hashsize,
                           product_species-&gt;hashval,
                           (struct abstract_molecule *)new_volume_mol) != NULL)
    new_volume_mol-&gt;flags |= ACT_REACT;

  /* If this product resulted from a surface rxn, store the previous wall
   * position. */
  if (sm_reactant &amp;&amp; distinguishable(new_volume_mol-&gt;get_diffusion(new_volume_mol), 0, EPS_C)) {
    new_volume_mol-&gt;previous_wall = sm_reactant-&gt;grid-&gt;surface;

    /* This will be overwritten with orientation in the CLAMPED/surf.
     * reversibility case
     */
    new_volume_mol-&gt;index = sm_reactant-&gt;grid_index;
  }

  /* Else clear the previous wall position. */
  else {
    new_volume_mol-&gt;previous_wall = NULL;
    new_volume_mol-&gt;index = -1;
  }

  /* Set reversibility state for the new molecule. */
  if (w) {
    if (world-&gt;surface_reversibility) {
      /* Which direction did we move? */
      new_volume_mol-&gt;previous_wall = w;
      new_volume_mol-&gt;index = (orient &gt; 0) ? 1 : -1;
      new_volume_mol-&gt;flags |= ACT_CLAMPED;
    }
  } else if (world-&gt;volume_reversibility) {
    new_volume_mol-&gt;index = world-&gt;dissociation_index;
    new_volume_mol-&gt;flags |= ACT_CLAMPED;
  }

  /* Add the molecule to the subvolume */
  ht_add_molecule_to_list(&amp;new_volume_mol-&gt;subvol-&gt;mol_by_species,
                          new_volume_mol);
  ++new_volume_mol-&gt;subvol-&gt;mol_count;

  /* Add to the schedule. */
  if (schedule_add_mol(subvol-&gt;local_storage-&gt;timer, new_volume_mol))
    mcell_allocfailed("Failed to add newly created %s molecule to scheduler.",
                      product_species-&gt;sym-&gt;name);
  return new_volume_mol;
}

struct surface_molecule *
place_sm_product(struct volume *world, struct species *product_species, struct graph_data* graph,
                 struct surface_grid *grid, int grid_index,
                 struct vector2 *mol_uv_pos, short orient, double t,
                 struct periodic_image *periodic_box) {
  struct vector3 mol_xyz_pos;
  uv2xyz(mol_uv_pos, grid-&gt;surface, &amp;mol_xyz_pos);
  struct subvolume *sv = find_subvolume(world, &amp;mol_xyz_pos, grid-&gt;subvol);

  /* Allocate and initialize the molecule. */
  struct surface_molecule *new_surf_mol;
  new_surf_mol = (struct surface_molecule *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;smol, "surface molecule");
  new_surf_mol-&gt;birthplace = sv-&gt;local_storage-&gt;smol;
  new_surf_mol-&gt;birthday = convert_iterations_to_seconds(
      world-&gt;start_iterations, world-&gt;time_unit,
      world-&gt;simulation_start_seconds, t);
  new_surf_mol-&gt;id = world-&gt;current_mol_id++;
  new_surf_mol-&gt;t = t;
  new_surf_mol-&gt;t2 = 0.0;
  new_surf_mol-&gt;properties = product_species;
  //nfsim graph init
  new_surf_mol-&gt;graph_data = graph;
  initialize_diffusion_function((struct abstract_molecule*) new_surf_mol);
  new_surf_mol-&gt;periodic_box = CHECKED_MALLOC_STRUCT(struct periodic_image,
    "periodic image descriptor");
  new_surf_mol-&gt;periodic_box-&gt;x = periodic_box-&gt;x;
  new_surf_mol-&gt;periodic_box-&gt;y = periodic_box-&gt;y;
  new_surf_mol-&gt;periodic_box-&gt;z = periodic_box-&gt;z;

  new_surf_mol-&gt;flags = TYPE_SURF | ACT_NEWBIE | IN_SCHEDULE;
  if (new_surf_mol-&gt;get_space_step(new_surf_mol) &gt; 0)
    new_surf_mol-&gt;flags |= ACT_DIFFUSE;
  if (product_species-&gt;flags &amp; COUNT_ENCLOSED)
    new_surf_mol-&gt;flags |= COUNT_ME;
  new_surf_mol-&gt;grid = grid;
  new_surf_mol-&gt;grid_index = grid_index;
  new_surf_mol-&gt;s_pos = *mol_uv_pos;
  new_surf_mol-&gt;orient = orient;

  /* Check whether the product can undergo unimolecular rxns; if so, mark it. */
  if (trigger_unimolecular(world-&gt;reaction_hash, world-&gt;rx_hashsize,
                           product_species-&gt;hashval,
                           (struct abstract_molecule *)new_surf_mol) != NULL ||
      (product_species-&gt;flags &amp; CAN_SURFWALL) != 0)
    new_surf_mol-&gt;flags |= ACT_REACT;

  /* Add to the grid. */
  ++grid-&gt;n_occupied;
  if (grid-&gt;sm_list[grid_index]) {
    remove_surfmol_from_list(
        &amp;grid-&gt;sm_list[grid_index], grid-&gt;sm_list[grid_index]-&gt;sm);
  }
  grid-&gt;sm_list[grid_index] = add_surfmol_with_unique_pb_to_list(
    grid-&gt;sm_list[grid_index], new_surf_mol);

  /* Add to the schedule. */
  if (schedule_add_mol(sv-&gt;local_storage-&gt;timer, new_surf_mol))
    mcell_allocfailed("Failed to add newly created %s molecule to scheduler.",
                      product_species-&gt;sym-&gt;name);

  return new_surf_mol;
}

/***************************************************************************
outcome_products_random:
   In: world: simulation state
       w: first wall in the reaction
       hitpt: hit point (if any)
       t: time of the reaction
       rx: reaction
       path: path of the reaction
       reacA: first reactant (moving molecule)
       reacB: second reactant
       orientA: orientation of the first reactant
       orientB: orientation of the second reactant
   Out: Returns RX_A_OK, RX_FLIP or RX_BLOCKED.
Note: This function replaces surface reactants (if needed) by the surface
      products picked in the random order from the list of products. Also
      surface products are placed in the random order in the surrounding empty
      tiles. After this function execution some walls that do not have surface
      molecules and therefore do not have a grid may get a grid as side effect
      of calling functions "grid_all_neigbors_across_walls_through_vertices()"
      and "grid_all_neighbors_across_walls_through_edges()".
Note: If both reactants are surface molecules, and they are both located within
      the same restricted region border (REFL/ABSORB), then reaction products -
      surface molecules for which this region border is restrictive will be
      placed inside this region. If any of the conditions above are not true,
      the reaction products - surface molecules can be placed on any tile from
      the list of vacant tiles.
Note: Policy on surface products placement is described in the document
      "policy_surf_products_placement.doc" (see "src/docs").

****************************************************************************/
static int outcome_products_random(struct volume *world, struct wall *w,
                                   struct vector3 *hitpt, double t,
                                   struct rxn *rx, int path,
                                   struct abstract_molecule *reacA,
                                   struct abstract_molecule *reacB,
                                   short orientA, short orientB) {

#ifdef DEBUG_RXNS
  // NOTE: maybe make a single dump call out of this
  DUMP_CONDITION3(
    dump_processing_reaction(world-&gt;current_iterations, hitpt, t, rx, reacA, reacB, w);
    dump_molecule_species(reacA);
    if (reacB != nullptr) {
      mcell_log(" + ");
      dump_molecule_species(reacB);
    }
    mcell_log("\nreaction_index: %d\n", path);
    dump_rxn(rx, "", true);
  );
#endif

  /* Did the moving molecule cross the plane? */
<a name="2"></a>  bool cross_wall = false; 

  /* index of the first player for the pathway */
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  int const i0 = rx-&gt;product_idx[path]; 
  /* index of the first player for the next pathway */
  int const iN = rx-&gt;product_idx[path + 1]; 
  assert(iN &gt; i0);
  /* Players array from the reaction. */
  struct species **rx_players = rx-&gt;players + i0; 

  int const n_players = iN - i0;                /* number of reaction players */
  std::vector&lt;struct abstract_molecule *&gt; product(n_players); /* array of products */
  /* array that decodes the type of each product */
  std::vector&lt;char&gt; product_type(n_players);
  std::vector&lt;short&gt; product_orient(n_players); /* array of orientations for each product */
  /* array of surface_grids for products */
  std::vector&lt;struct surface_grid *&gt; product_grid(n_players);
  std::vector&lt;int&gt; product_grid_idx(n_players); /* array of grid indices for products */
  std::vector&lt;byte&gt; product_flag(n_players);    /* array of placement flags for products */</b></font>

  /* Unimol rxn (not mol-mol, not mol-wall) */
  bool const is_unimol = is_rxn_unimol(rx);

  struct surface_grid *tile_grid; /* surface grid the tile belongs to */
  int num_vacant_tiles = 0;       /* number of vacant tiles */

  /* used for product placement for the reaction of type A-&gt;B+C[rate] */
  unsigned int reac_idx = UINT_MAX;
<a name="0"></a>  struct surface_grid *reac_grid = NULL, *mol_grid = NULL;

  /* Clear the initial product info. */
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  for (int i = 0; i &lt; n_players; ++i) {
    product[i] = NULL;
    product_type[i] = PLAYER_NONE;
    product_orient[i] = 0;
    product_grid[i] = NULL;
    product_grid_idx[i] = -1;
    product_flag[i] = PRODUCT_FLAG_NOT_SET;
  }

  /* Flag indicating that a surface is somehow involved with this reaction. */
  struct surface_molecule *const sm_1 =
      IS_SURF_MOL(reacA) ? (struct surface_molecule *)reacA : NULL;
  struct surface_molecule *const sm_2 =
      IS_SURF_MOL(reacB) ? (struct surface_molecule *)reacB : NULL;
  struct surface_molecule *const sm_reactant = sm_1 ? sm_1 : sm_2;</b></font>
  bool const is_orientable = (w != NULL) || (sm_reactant != NULL);

  /* list of the restricted regions for the reactants by wall */
  struct region_list *rlp_head_wall_1 = NULL, *rlp_head_wall_2 = NULL;

  /* list of the restricted regions for the reactants by object */
  struct region_list *rlp_head_obj_1 = NULL, *rlp_head_obj_2 = NULL;

  int sm_bitmask = determine_molecule_region_topology(
      world, sm_1, sm_2, &amp;rlp_head_wall_1, &amp;rlp_head_wall_2, &amp;rlp_head_obj_1,
      &amp;rlp_head_obj_2, is_unimol);

  /* reacA is the molecule which initiated the reaction. */
  struct abstract_molecule *const initiator = reacA;
  short const initiatorOrient = orientA;

  /* Ensure that reacA and reacB are sorted in the same order as the rxn players. */
  assert(reacA != NULL);

  if (reacA-&gt;properties != rx-&gt;players[0]) {
    struct abstract_molecule *tmp_mol = reacA;
    reacA = reacB;
    reacB = tmp_mol;
    short tmp_orient = orientA;
    orientA = orientB;
    orientB = tmp_orient;
  }
  assert(reacA != NULL);

  add_reactants_to_product_list(rx, reacA, reacB, NULL, &amp;product[0], &amp;product_type[0]);

  /* Determine whether any of the reactants can be replaced by a product.
     This is only useful for surface molecules to make sure reactions of the
     type A + B -&gt; A don't push A to neighboring tiles */
  int replace_p1 = (product_type[0] == PLAYER_SURF_MOL &amp;&amp; rx_players[0] == NULL);
  int replace_p2 = rx-&gt;n_reactants &gt; 1 &amp;&amp; (product_type[1] == PLAYER_SURF_MOL &amp;&amp;
                                           rx_players[1] == NULL);

  /* Determine the point of reaction on the surface. */
  struct vector2 rxn_uv_pos; // position of reaction on wall
  int rxn_uv_idx = -1;       // tile index of where reaction occurred
  int num_surface_static_reactants = 0; // number of reactants with (D_2D == 0)
  if (is_orientable) {
    if (sm_reactant) {
      rxn_uv_pos = sm_reactant-&gt;s_pos;
    } else {
      xyz2uv(hitpt, w, &amp;rxn_uv_pos);
    }

    assert(w != NULL);
    if (w-&gt;grid == NULL) {
      /* reacA must be a volume molecule, or this wall would have a grid already. */
      assert(!IS_SURF_MOL(reacA));
      if (create_grid(world, w, ((struct volume_molecule *)reacA)-&gt;subvol))
        mcell_allocfailed("Failed to create a grid for a wall.");
    }
    rxn_uv_idx = uv2grid(&amp;rxn_uv_pos, w-&gt;grid);

    /* find out number of static surface reactants */
    if ((sm_1 != NULL) &amp;&amp; (!distinguishable(sm_1-&gt;get_diffusion(sm_1), 0, EPS_C))){
      num_surface_static_reactants++;
    }
    if ((sm_2 != NULL) &amp;&amp; (!distinguishable(sm_2-&gt;get_diffusion(sm_2), 0, EPS_C))){
      num_surface_static_reactants++;
    }
  }

  /* find out number of surface products */
  int num_surface_products = 0;
  int num_surface_static_products = 0; // number of products with (D_2D == 0)
  for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
    if (rx_players[n_product] == NULL) {
      continue;
    }
    if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
      num_surface_products++;
      if (!distinguishable(rx_players[n_product]-&gt;D, 0, EPS_C))
        num_surface_static_products++;
    }
  }

  int mol_idx = INT_MAX;
  /* If the reaction involves a surface, make sure there is room for each
   * product. */
  struct tile_neighbor *tile_nbr_head = NULL; // list of neighbor tiles
  int tile_nbr_list_length = 0;
  struct tile_neighbor *tile_vacant_nbr_head = NULL; // list of vacant neighbor tiles
  if (is_orientable) {
    if (num_surface_products &gt; 0) {
      if (sm_reactant != NULL) {
        find_neighbor_tiles(world, sm_reactant, sm_reactant-&gt;grid,
                            sm_reactant-&gt;grid_index, 1, 0, &amp;tile_nbr_head,
                            &amp;tile_nbr_list_length);
      } else {
        find_neighbor_tiles(world, sm_reactant, w-&gt;grid, rxn_uv_idx, 1, 0,
                            &amp;tile_nbr_head, &amp;tile_nbr_list_length);
<a name="17"></a>      }

      /* Create list of vacant tiles */
<font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>      for (struct tile_neighbor *tile_nbr = tile_nbr_head; tile_nbr != NULL;
           tile_nbr = tile_nbr-&gt;next) {
        struct surface_molecule_list *sm_list = tile_nbr-&gt;grid-&gt;sm_list[tile_nbr-&gt;idx]; 
        if (sm_list == NULL || sm_list-&gt;sm == NULL) {
          num_vacant_tiles++;
          push_tile_neighbor_to_list(&amp;tile_vacant_nbr_head, tile_nbr-&gt;grid, tile_nbr-&gt;idx);
        }
      }
    }</b></font>

    /* Can this reaction happen at all? */
    int num_recycled_tiles = 0;
    if (replace_p1 &amp;&amp; replace_p2) {
      num_recycled_tiles = 2;
    } else if (replace_p1 || replace_p2) {
      num_recycled_tiles = 1;
    }
    if (num_surface_products &gt; num_vacant_tiles + num_recycled_tiles) {
      return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
    }

    /* set the orientations of the products. */
    for (int n_product = 0; n_product &lt; n_players; ++n_product) {
      /* Skip NULL products */
      if (rx_players[n_product] == NULL) {
        continue;
      }

      int this_geometry = rx-&gt;geometries[i0 + n_product];
      int relative_orient = (this_geometry &lt; 0) ? -1 : 1;
      this_geometry = abs(this_geometry);

      /* Geometry of 0 means "random orientation" */
      if (this_geometry == 0) {
        product_orient[n_product] = (rng_uint(world-&gt;rng) &amp; 1) ? 1 : -1;
      } else {
        if (this_geometry &gt; (int)rx-&gt;n_reactants) {
          product_orient[n_product] = relative_orient *
              product_orient[this_geometry - rx-&gt;n_reactants - 1];
        } else if (this_geometry == 1) {
          product_orient[n_product] = relative_orient * orientA;
<a name="16"></a>        } else if (this_geometry == 2 &amp;&amp; reacB != NULL) {
          product_orient[n_product] = relative_orient * orientB;
        } else {
<font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>          product_orient[n_product] = relative_orient * 1;
        }
      }

      /* If this is a reactant... */
      if (n_product &lt; (int)rx-&gt;n_reactants) {
        /* If this is a surface molecule, we need to set its orientation. */
        if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
          assert(IS_SURF_MOL(product[n_product]));
          struct surface_molecule *sm =
              (struct surface_molecule *)product[n_product];

          /* If the new orientation doesn't match the old, we've got some work
           * to do. */
          if (sm-&gt;orient != product_orient[n_product]) {

            /* We're about to update the molecule's orientation, so we will
             * first remove it from the counts in case we have any
             * orientation-sensitive counts. Then, we will update the
             * orientation. Finally, we will add the molecule back into the
             * counts in its new orientation. */

            /* Remove molecule from counts in old orientation, if mol is
             * counted. */
            if (product[n_product]-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS|COUNT_ENCLOSED)) {</b></font>
              count_region_from_scratch(world,
                                        product[n_product], /* molecule */
                                        NULL,               /* rxn pathway */
                                        -1,                 /* remove count */
                                        NULL, /* Location at which to count */
                                        w,    /* Wall on which this happened */
                                        t,    /* Time of occurrence */
                                        NULL);
            }

            /* Force check for the unimolecular reactions
               after changing orientation.
               There are two possible cases to be covered here:
               1) when (sm-&gt;t2) was previously set to FOREVER
               2) there may be two or more unimolecular reactions involving surface
                class that have different kinetics.
             */
            if (((sm-&gt;flags &amp; ACT_REACT) != 0) &amp;&amp;
                ((sm-&gt;properties-&gt;flags &amp; CAN_SURFWALL) != 0)) {
              sm-&gt;t2 = 0;
            }

            /* Set the molecule's orientation. */
            sm-&gt;orient = product_orient[n_product];

            /* Add molecule back to counts in new orientation, if mol is
             * counted. */
            if (product[n_product]-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS|COUNT_ENCLOSED)) {
              count_region_from_scratch(world,
                                        product[n_product], /* molecule */
                                        NULL,               /* rxn pathway */
                                        1,                  /* add count */
                                        NULL, /* Location at which to count */
                                        w,    /* Wall on which this happened */
                                        t,    /* Time of occurrence */
<a name="4"></a>                                        NULL);
            }
          }
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        } else if (!is_unimol) { /* Otherwise, check if we've crossed the plane. */
          if (product[n_product] == initiator) {
            if (product_orient[n_product] != initiatorOrient)
              cross_wall = true;
          }
        }
      }
    }

    /* find out where to place surface products */
    /* Some special cases are listed below. */
    if (num_surface_products == 1) {
      if (is_unimol &amp;&amp; replace_p1) {
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if (rx_players[n_product] == NULL ||</b></font>
             (rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0) {
            continue;
          }

          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
            product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
            product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
            replace_p1 = 0;
            break;
          }
        }
      } else if ((num_surface_static_reactants == 1) &amp;&amp; (num_surface_static_products == 1)
          &amp;&amp; (replace_p1 || replace_p2)) {
        /* the lonely static product always replaces lonely static reactant */
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if (rx_players[n_product] == NULL ||
              (rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0 ||
              distinguishable(rx_players[n_product]-&gt;D, 0, EPS_C)) {
<a name="3"></a>            continue;
          }

<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            if (replace_p1 &amp;&amp; (!distinguishable(reacA-&gt;properties-&gt;D, 0, EPS_C))) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
              product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
              product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
              replace_p1 = 0;
              break;
            } else if (replace_p2 &amp;&amp; (!distinguishable(reacB-&gt;properties-&gt;D, 0, EPS_C))) {
<a name="13"></a>              product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
              product_grid[n_product] = ((struct surface_molecule *)reacB)-&gt;grid;
              product_grid_idx[n_product] = ((struct surface_molecule *)reacB)-&gt;grid_index;</b></font>
<font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>              break;
            }
          }
        }
      } else if (replace_p1 &amp;&amp; replace_p2) {
        /* if both reactants should be replaced and there is only one surface product
          here we make sure that the initiator molecule is replaced */
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if ((rx_players[n_product] == NULL) ||</b></font>
              ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
            continue;
<a name="9"></a>          }

          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>            if (reacA == initiator) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
              product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
              product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
              replace_p1 = 0;
            } else {
<a name="12"></a>              product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
              product_grid[n_product] = ((struct surface_molecule *)reacB)-&gt;grid;
              product_grid_idx[n_product] = ((struct surface_molecule *)reacB)-&gt;grid_index;</b></font>
<font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>            }
            break;
          }
        }
      } else if (replace_p1) {
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if ((rx_players[n_product] == NULL) ||</b></font>
              ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
            continue;
          }

          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
            product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
            product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
            replace_p1 = 0;
            break;
          }
        }
      } else if (replace_p2) {
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if ((rx_players[n_product] == NULL) |
              ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
            continue;
          }

          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
            product_grid[n_product] = ((struct surface_molecule *)reacB)-&gt;grid;
            product_grid_idx[n_product] = ((struct surface_molecule *)reacB)-&gt;grid_index;
            break;
          }
        }
      }
    } else if (num_surface_products &gt; 1) {
      /* more than one surface products */
      if (num_surface_static_reactants &gt; 0) {
        bool replace_reacA = (!distinguishable(reacA-&gt;get_diffusion(reacA), 0, EPS_C)) &amp;&amp; replace_p1;
        bool replace_reacB =
            (reacB == NULL) ? false : (!distinguishable(reacB-&gt;get_diffusion(reacB), 0, EPS_C)) &amp;&amp; replace_p2;

        if (replace_reacA || replace_reacB) {
          int max_static_count = (num_surface_static_products &lt; num_surface_static_reactants)
            ? num_surface_static_products : num_surface_static_reactants;

          int count = 0;
          while (count &lt; max_static_count) {
            unsigned int rnd_num = rng_uint(world-&gt;rng) % n_players;
            /* pass reactants */
            if ((rnd_num &lt; rx-&gt;n_reactants) || (rx_players[rnd_num] == NULL) ||
                ((rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0) ||
                distinguishable(rx_players[rnd_num]-&gt;D, 0, EPS_C)) {
              continue;
            }
            if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
              if (replace_reacA) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
                product_grid[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid;
                product_grid_idx[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid_index;
                count++;
                replace_p1 = 0;
                replace_reacA = 0;
              } else if (replace_reacB) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
                product_grid[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid;
                product_grid_idx[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid_index;
<a name="6"></a>                count++;
                replace_p2 = 0;
                replace_reacB = 0;
<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>              }
            }
          } /* end while */
        }
      }

      /* check whether there are any surface reactants left to replace with
       * surface products since we are done with static reactants/products */
      if (replace_p1 || replace_p2) {
        int surf_prod_left = 0, surf_reactant_left = 0;
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if ((rx_players[n_product] == NULL) ||</b></font>
              ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
            continue;
          }
          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            surf_prod_left++;
          }
        }
        if (replace_p1) {
          surf_reactant_left++;
        }
        if (replace_p2) {
          surf_reactant_left++;
        }

        if (surf_prod_left &gt; 0) {
          int num_to_place = surf_prod_left;
          if (surf_prod_left &gt;= surf_reactant_left) {
            num_to_place = surf_reactant_left;
          }
          int count = 0;
          while (count &lt; num_to_place) {
            unsigned int rnd_num = rng_uint(world-&gt;rng) % n_players;
            if ((rnd_num &lt; rx-&gt;n_reactants) || (rx_players[rnd_num] == NULL) ||
                (rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0) {
             continue;
            }
            if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
              if (replace_p1) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
                product_grid[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid;
                product_grid_idx[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid_index;
                count++;
                replace_p1 = 0;
              } else if (replace_p2) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
                product_grid[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid;
                product_grid_idx[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid_index;
                replace_p2 = 0;
                count++;
              }
            }
          } /* end while */
        }
      }
    }

    /* here we will find placement for the case of the reaction of type
     * "vol_mol + w -&gt; surf_mol + ...[rate] " */
    if ((sm_reactant == NULL) &amp;&amp; (w != NULL) &amp;&amp; (num_surface_products &gt;= 1)) {
      assert(!IS_SURF_MOL(reacA));
      assert(rxn_uv_idx != -1);

      while (true) {
        unsigned int rnd_num = rng_uint(world-&gt;rng) % (n_players);
        if (rnd_num &lt;= 1 || (rx_players[rnd_num] == NULL) ||
            (rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0) {
          continue;
        }

        if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
          product_flag[rnd_num] = PRODUCT_FLAG_USE_UV_LOC;
          product_grid[rnd_num] = w-&gt;grid;
          product_grid_idx[rnd_num] = rxn_uv_idx;
          break;
        }
      }
    }

    /* we will implement special placement policy for reaction of type of *
     * A-&gt;B+C[rate] */
    if (is_unimol &amp;&amp; (sm_reactant != NULL) &amp;&amp; (num_surface_products == 2)) {
      reac_idx = sm_reactant-&gt;grid_index;
      reac_grid = sm_reactant-&gt;grid;
    }

    // all other products are placed on one of the randomly chosen vacant tiles 
    int do_it_once = 0; /* flag */
    int num_attempts = 0;
    for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
      /* If the product is a volume product, no placement is required. */
      if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
        if (product_flag[n_product] != PRODUCT_FLAG_NOT_SET) {
          continue;
        }

        /* can't place products - reaction blocked */
        if (num_vacant_tiles == 0) {
          return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
        }

        num_attempts = 0;
        while (true) {
          if (num_attempts &gt; SURFACE_DIFFUSION_RETRIES) {
            return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
          }

          /* randomly pick a tile from the list */
          unsigned int rnd_num = rng_uint(world-&gt;rng) % num_vacant_tiles;
          int tile_idx = -1; /* index of the tile on the grid */
          tile_grid = NULL;
          if (get_tile_neighbor_from_list_of_vacant_neighbors(
                  tile_vacant_nbr_head, rnd_num, &amp;tile_grid, &amp;tile_idx) == 0) {
            return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
          }
          if (tile_idx &lt; 0) {
            continue; /* this tile was probed already */
          }
          assert(tile_grid != NULL);

          /* make sure we can get to the tile given the surface regions defined
           * in the model */
          //ASSERT_FOR_MCELL4(sm_bitmask == 0); - should not be needed anymore but keeping it as a marker for future debugging
          if (!product_tile_can_be_reached(tile_grid-&gt;surface, rlp_head_wall_1,
            rlp_head_wall_2, rlp_head_obj_1, rlp_head_obj_2, sm_bitmask, is_unimol)) {
            uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
            num_attempts++;
            continue;
          }

          product_grid[n_product] = tile_grid;
          product_grid_idx[n_product] = tile_idx;
          product_flag[n_product] = PRODUCT_FLAG_USE_RANDOM;
          if (!do_it_once &amp;&amp; is_unimol &amp;&amp; (sm_reactant != NULL) &amp;&amp; (num_surface_products == 2)) {
            /*remember this tile (used for the reaction A-&gt;B+C[rate]) */
            mol_idx = tile_idx;
            mol_grid = tile_grid;
            do_it_once = 1;
          }
          break;
        } /* end while */
      }
    }
  } /* end if (is_orientable) */

  /* Determine the location of the reaction for count purposes. */
  struct vector3 count_pos_xyz;
  struct periodic_image *periodic_box = ((struct volume_molecule *)reacA)-&gt;periodic_box;
  if (hitpt != NULL) {
    count_pos_xyz = *hitpt;
  } else if (sm_reactant) {
    uv2xyz(&amp;sm_reactant-&gt;s_pos, sm_reactant-&gt;grid-&gt;surface, &amp;count_pos_xyz);
  } else {
    count_pos_xyz = ((struct volume_molecule *)reacA)-&gt;pos;
  }

  /* Create and place each product. */
  struct vector3 mol_pos_tmp;
  struct subvolume *product_subvol = NULL;
  /* Do we need to advance the dissociation index? */
  bool update_dissociation_index = false; 
  for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
<a name="15"></a>    struct graph_data* g_data = NULL;
    if (rx-&gt;product_graph_data != NULL)
      g_data = rx-&gt;product_graph_data[path][n_product - rx-&gt;n_reactants];
<font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    struct abstract_molecule *this_product = NULL;
    struct species *const product_species = rx_players[n_product];

    /* If the product is a surface molecule, place it on the grid. */
    if (product_species-&gt;flags &amp; ON_GRID) {
      struct vector2 prod_uv_pos;

      /* Pick an appropriate position for the new molecule. */
      if (world-&gt;randomize_smol_pos) {
        switch (product_flag[n_product]) {
        case PRODUCT_FLAG_USE_REACA_UV:</b></font>
          if (is_unimol &amp;&amp; (num_surface_products == 2) &amp;&amp; (sm_reactant != NULL)) {
            if (mol_grid == NULL) {
              mcell_internal_error("Error in surface product placement for the "
                                   "unimolecular reaction.");
            }
            find_closest_position(product_grid[n_product], product_grid_idx[n_product],
              mol_grid, mol_idx, &amp;prod_uv_pos);
          } else {
            prod_uv_pos = ((struct surface_molecule *)reacA)-&gt;s_pos;
          }
          break;

        case PRODUCT_FLAG_USE_REACB_UV:
          assert(reacB != NULL);
          prod_uv_pos = ((struct surface_molecule *)reacB)-&gt;s_pos;
          break;

        case PRODUCT_FLAG_USE_UV_LOC:
          prod_uv_pos = rxn_uv_pos;
          break;

        case PRODUCT_FLAG_USE_RANDOM:
          if (is_unimol &amp;&amp; replace_p1 &amp;&amp; (num_surface_products == 2)) {
            find_closest_position(product_grid[n_product],
                                  product_grid_idx[n_product], reac_grid,
                                  reac_idx, &amp;prod_uv_pos);
          } else {
            grid2uv_random(product_grid[n_product], product_grid_idx[n_product],
                           &amp;prod_uv_pos, world-&gt;rng);
          }
          break;

        default:
          UNHANDLED_CASE(product_flag[n_product]);
          /*break;*/
        }
      } else {
        grid2uv(product_grid[n_product], product_grid_idx[n_product], &amp;prod_uv_pos);
      }

      this_product = (struct abstract_molecule *)place_sm_product(
          world, product_species, g_data, product_grid[n_product],
          product_grid_idx[n_product], &amp;prod_uv_pos, product_orient[n_product],
          t, reacA-&gt;periodic_box);

#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
          dump_surface_molecule((struct surface_molecule*)this_product, "", true, "  created sm:", world-&gt;current_iterations, this_product-&gt;t, true);
      );
#endif

    } else { /* else place the molecule in space. */
      /* For either a unimolecular reaction, or a reaction between two surface
         molecules we don't have a hitpoint. */
      if (!hitpt) {
        if (reacA-&gt;properties-&gt;flags &amp; ON_GRID) {
          /* Since we use reactA's position to compute the location of the reaction
             we also need to use its wall for picking the displacement later in
             place_volume_products */
          w = ((struct surface_molecule *)reacA)-&gt;grid-&gt;surface;
          uv2xyz(&amp;((struct surface_molecule *)reacA)-&gt;s_pos,
                 w, &amp;mol_pos_tmp);
          product_subvol = find_subvolume(world, &amp;mol_pos_tmp, NULL);
        } else {
          mol_pos_tmp = ((struct volume_molecule *)reacA)-&gt;pos;
          product_subvol = ((struct volume_molecule *)reacA)-&gt;subvol;
        }
        hitpt = &amp;mol_pos_tmp;
      } else if (product_subvol == NULL) {
        product_subvol = find_subvolume(world, hitpt, NULL);
      }

      this_product = (struct abstract_molecule *)place_volume_product(
          world, product_species, g_data, sm_reactant, w, product_subvol, hitpt,
          product_orient[n_product], t, reacA-&gt;periodic_box);

#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
      		dump_volume_molecule((struct volume_molecule*)this_product, "", true, "  created vm:", world-&gt;current_iterations, this_product-&gt;t, true);
      );
#endif

      if (((struct volume_molecule *)this_product)-&gt;index &lt; DISSOCIATION_MAX)
        update_dissociation_index = true;
    }

    /* Provide new molecule with graph information if it exists */
    if(rx-&gt;product_graph_data != NULL){
      this_product-&gt;graph_data = g_data;
    }


    /* Update molecule counts */
    ++product_species-&gt;population;
    if (product_species-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED))
      count_region_from_scratch(world, this_product, NULL, 1, NULL, NULL, t, this_product-&gt;periodic_box);

#ifndef MCELL3_DO_NOT_REUSE_MOL_ID_UNIMOL_RXN
    /* preserve molecule id if rxn is unimolecular with one product */
    if (is_unimol &amp;&amp; (n_players == 1)) {
      this_product-&gt;id = reacA-&gt;id;
      world-&gt;current_mol_id--; /* give back id we used */
      continue;
    }
    /* preserve molecule id if rxn is surface rxn with one product */
    if ((n_players == 3) &amp;&amp; product_type[1] == PLAYER_WALL) {
      this_product-&gt;id = reacA-&gt;id;
      world-&gt;current_mol_id--; /* give back id we used */
<a name="19"></a>      continue;
    }
#endif
<font color="#f62817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  }

  /* If necessary, update the dissociation index. */
  if (update_dissociation_index) {
    ASSERT_FOR_MCELL4(false);
    if (--world-&gt;dissociation_index &lt; DISSOCIATION_MIN)
      world-&gt;dissociation_index = DISSOCIATION_MAX;
  }

  /* Handle events triggered off of named reactions */
  if (rx-&gt;info[path].pathname != NULL) {
    /* No flags for reactions so we have to check regions if we have waypoints!
     * Fix to be more efficient for WORLD-only counts? */
    if (world-&gt;place_waypoints_flag)
      count_region_from_scratch(world, NULL, rx-&gt;info[path].pathname, 1,</b></font>
                                &amp;count_pos_xyz, w, t, periodic_box);

    /* Other magical stuff.  For now, can only trigger releases. */
    if (rx-&gt;info[path].pathname-&gt;magic != NULL) {
      if (reaction_wizardry(world, rx-&gt;info[path].pathname-&gt;magic, w,
                            &amp;count_pos_xyz, t))
        mcell_allocfailed("Failed to complete reaction triggered release after "
                          "a '%s' reaction.",
                          rx-&gt;info[path].pathname-&gt;sym-&gt;name);
    }
  }

  /* recover memory */
  delete_tile_neighbor_list(tile_nbr_head);
  delete_tile_neighbor_list(tile_vacant_nbr_head);
  delete_region_list(rlp_head_wall_1);
  delete_region_list(rlp_head_wall_2);
  delete_region_list(rlp_head_obj_1);
  delete_region_list(rlp_head_obj_2);

  return cross_wall ? RX_FLIP : RX_A_OK;
}



/*************************************************************************
outcome_unimolecular:
  In: world: simulation state
      rx: the reaction that is occuring
      path: the path that the reaction is taking
      reac: the molecule that is taking that path
      t: time that the reaction is occurring
  Out: Value based on outcome:
       RX_BLOCKED if there was no room to put products on grid
       RX_DESTROY if molecule no longer exists.
       RX_A_OK if it does.
       Products are created as needed.
*************************************************************************/
int outcome_unimolecular(struct volume *world, struct rxn *rx, int path,
                         struct abstract_molecule *reac, double t) {
  struct species *who_was_i = reac-&gt;properties;
  int result = RX_A_OK;
  struct volume_molecule *vm = NULL;
  struct surface_molecule *sm = NULL;
  //JJT: if this is a molecule marked as external leave it up to nfsim
  /*if(reac-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
    vm = (struct volume_molecule *)reac;
    //outcome_unimolecular_nfsim(world, rx, path, reac, t);
    outcome_nfsim(world, rx, path, reac, NULL, t);

    result = outcome_products_random(world, NULL, NULL, t, rx, path, reac, NULL, 0, 0);
  }*/
  if ((reac-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
    vm = (struct volume_molecule *)reac;

    //NFSim calculation
    if(reac-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
#if 0 // just to dump the whole rxn, fails later for some reason..
      // populate all pathways
      for (int path = 0; path &lt; rx-&gt;n_pathways; path++) {
        outcome_nfsim(world, rx, path, reac, NULL, t);
      }
#else
      outcome_nfsim(world, rx, path, reac, NULL, t);
#endif
    }
    result = outcome_products_random(world, NULL, NULL, t, rx, path, reac,
                                       NULL, 0, 0);
  } else {
    sm = (struct surface_molecule *)reac;
      /* we will not create products if the reaction is with an ABSORPTIVE
         region border */

      if ((strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_SURFACE_MOLECULES") == 0) ||
          (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_MOLECULES") == 0)) {
        /* do nothing */
      } else {
        //NFSim calculations
        if(reac-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
          outcome_nfsim(world, rx, path, reac, NULL, t);
        }
        result = outcome_products_random(world, sm-&gt;grid-&gt;surface, NULL, t, rx,
                                         path, reac, NULL, sm-&gt;orient, 0);
      }
  }

  if (result == RX_BLOCKED)
    return RX_BLOCKED;

  if (result != RX_BLOCKED) {
    rx-&gt;info[path].count++;
    rx-&gt;n_occurred++;
    if(rx-&gt;product_graph_data != NULL){
      logNFSimReactions_c(rx-&gt;external_reaction_data[path].reaction_name);

    }
  }

  struct species *who_am_i = rx-&gt;players[rx-&gt;product_idx[path]];

  if (who_am_i == NULL) {
    if (vm != NULL) {
      vm-&gt;subvol-&gt;mol_count--;
      if (vm-&gt;flags &amp; IN_SCHEDULE)
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      if (vm-&gt;properties-&gt;flags &amp; COUNT_SOME_MASK) {
        count_region_from_scratch(world, (struct abstract_molecule *)vm, NULL,
                                  -1, &amp;(vm-&gt;pos), NULL, vm-&gt;t, vm-&gt;periodic_box);
      }
    } else {
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
        dump_surface_molecule(sm, "", true, "Unimolecular sm defunct:", world-&gt;current_iterations, sm-&gt;t, false);
      );
#endif
      remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
      sm-&gt;grid-&gt;n_occupied--;
      if (sm-&gt;flags &amp; IN_SCHEDULE) {
        sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
      if (sm-&gt;properties-&gt;flags &amp; COUNT_SOME_MASK) {
        count_region_from_scratch(world, (struct abstract_molecule *)sm, NULL,
                                  -1, NULL, NULL, sm-&gt;t, sm-&gt;periodic_box);
      }
    }

    free(reac-&gt;periodic_box);
    who_was_i-&gt;n_deceased++;
    double t_time = convert_iterations_to_seconds(
        world-&gt;start_iterations, world-&gt;time_unit,
        world-&gt;simulation_start_seconds, t);
    who_was_i-&gt;cum_lifetime_seconds += t_time - reac-&gt;birthday;

    who_was_i-&gt;population--;
    if (vm != NULL) {
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
        dump_volume_molecule(vm, "", true, "Unimolecular vm defunct:", world-&gt;current_iterations, vm-&gt;t, false);
      );
#endif
      collect_molecule(vm);
    }
    else {
      reac-&gt;properties = NULL;
      mem_put(reac-&gt;birthplace, reac);
    }
    return RX_DESTROY;
  } else if (who_am_i != who_was_i) {
    if (vm != NULL) {
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
        dump_volume_molecule(vm, "", true, "Unimolecular vm defunct:", world-&gt;current_iterations, vm-&gt;t, false);
      );
#endif
      collect_molecule(vm);
    }
    else
      reac-&gt;properties = NULL;
    return RX_DESTROY;
  } else
    return result;
}

/*************************************************************************
outcome_bimolecular:
  In: reaction that's occurring
      path the reaction's taking
      two molecules that are reacting (first is moving one)
      orientations of the two molecules
      time that the reaction is occurring
      location of collision between molecules
  Out: Value based on outcome:
       RX_BLOCKED if there was no room to put products on grid
       RX_FLIP if the molecule goes across the membrane
       RX_DESTROY if the molecule no longer exists
       RX_A_OK if everything proceeded smoothly
       Products are created as needed.
  Note: reacA is the triggering molecule (e.g. moving)
*************************************************************************/
int outcome_bimolecular(struct volume *world, struct rxn *rx, int path,
                        struct abstract_molecule *reacA,
                        struct abstract_molecule *reacB, short orientA,
                        short orientB, double t, struct vector3 *hitpt,
                        struct vector3 *loc_okay) {
#ifdef DEBUG_TIMING
  DUMP_CONDITION3(
      MCell::dump_outcome_bimolecular_timing(t);
  );
#endif
<a name="18"></a>
  assert(periodic_boxes_are_identical(reacA-&gt;periodic_box, reacB-&gt;periodic_box));

<font color="#800517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  struct surface_molecule *sm = NULL;
  struct volume_molecule *vm = NULL;
  struct wall *w = NULL;
  /* struct storage *x; */
  int result;
  int reacB_was_free = 0;</b></font>
  int killA, killB;

  if ((reacA-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
    if ((reacB-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
      sm = (struct surface_molecule *)reacB;
      w = sm-&gt;grid-&gt;surface;
    }
  } else { /* Surface molecule */
    sm = (struct surface_molecule *)reacA;
    w = sm-&gt;grid-&gt;surface;
  }

  //JJT: if this is a molecule marked as external leave it up to nfsim
  if(reacA-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
    result = outcome_nfsim(world, rx, path, reacA, reacB, t);
    result = outcome_products_random(world, w, hitpt, t, rx, path, reacA, reacB,
                                     orientA, orientB);
  }

  else {
    result = outcome_products_random(world, w, hitpt, t, rx, path, reacA, reacB,
                                     orientA, orientB);
  }

  if (result == RX_BLOCKED)
    return RX_BLOCKED;

  rx-&gt;n_occurred++;
  rx-&gt;info[path].count++;
  if(rx-&gt;product_graph_data != NULL){
    logNFSimReactions_c(rx-&gt;external_reaction_data[path].reaction_name);
  }

  /* Figure out if either of the reactants was destroyed */
  if (rx-&gt;players[0] == reacA-&gt;properties) {
    killB = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
    killA = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
  } else {
    killB = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
    killA = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
  }

  if (killB) {
#ifdef DEBUG_RXNS
    DUMP_CONDITION3(
      dump_volume_molecule((struct volume_molecule*)reacB, "", true, "  defunct m:", world-&gt;current_iterations, 0.0, false);
<a name="11"></a>    );
#endif

<font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    vm = NULL;
    if ((reacB-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
      sm = (struct surface_molecule *)reacB;

      remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
      sm-&gt;grid-&gt;n_occupied--;
      if (sm-&gt;flags &amp; IN_SURFACE)
        sm-&gt;flags -= IN_SURFACE;
      if (sm-&gt;flags &amp; IN_SCHEDULE) {
        sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
    } else if ((reacB-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {</b></font>
      vm = (struct volume_molecule *)reacB;
      vm-&gt;subvol-&gt;mol_count--;
      if (vm-&gt;flags &amp; IN_SCHEDULE) {
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
      reacB_was_free = 1;
    }

    if ((reacB-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) != 0) {
      count_region_from_scratch(world, reacB, NULL, -1, NULL, NULL, t, reacB-&gt;periodic_box);
    }

    free(reacB-&gt;periodic_box);
    reacB-&gt;periodic_box = NULL;
    reacB-&gt;properties-&gt;n_deceased++;
    double t_time = convert_iterations_to_seconds(
        world-&gt;start_iterations, world-&gt;time_unit,
        world-&gt;simulation_start_seconds, t);
    reacB-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacB-&gt;birthday;
    reacB-&gt;properties-&gt;population--;

    if (vm != NULL)
      collect_molecule(vm);
    else
      reacB-&gt;properties = NULL;
  }

  if (killA) {
#ifdef DEBUG_RXNS
    DUMP_CONDITION3(
      dump_volume_molecule((struct volume_molecule*)reacA, "", true, "  defunct m:", world-&gt;current_iterations, 0.0, false);
    );
#endif

    vm = NULL;
    if ((reacA-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
      sm = (struct surface_molecule *)reacA;

      remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
      sm-&gt;grid-&gt;n_occupied--;
<a name="8"></a>      if (sm-&gt;flags &amp; IN_SCHEDULE) {
        sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    } else if ((reacA-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
      vm = (struct volume_molecule *)reacA;
      vm-&gt;subvol-&gt;mol_count--;
      if (vm-&gt;flags &amp; IN_SCHEDULE) {
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
    }

    if ((reacA-&gt;properties-&gt;flags &amp; ON_GRID) !=
        0) /* Surface molecule is OK where it is, doesn't obey COUNT_ME */
    {
      if (reacA-&gt;properties-&gt;flags &amp;
          COUNT_SOME_MASK) /* If we're ever counted, try to count us now */
      {
        count_region_from_scratch(world, reacA, NULL, -1, NULL, NULL, t, reacA-&gt;periodic_box);</b></font>
      }
    } else if (reacA-&gt;flags &amp; COUNT_ME) {
      /* Subtlety: we made it up to hitpt, but our position is wherever we were
       * before that! */
      if (hitpt == NULL || reacB_was_free ||
<a name="7"></a>          (reacB-&gt;properties != NULL &amp;&amp;
           (reacB-&gt;properties-&gt;flags &amp; NOT_FREE) == 0)) {
        /* Vol-vol rx should be counted at hitpt */
<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        count_region_from_scratch(world, reacA, NULL, -1, hitpt, NULL, t, reacA-&gt;periodic_box);
      } else /* Vol-surf but don't want to count exactly on a wall or we might
                count on the wrong side */
      {
        struct vector3 fake_hitpt;

        vm = (struct volume_molecule *)reacA;

        /* Halfway in between where we were and where we react should be a safe
         * away-from-wall place to remove us */
        if (loc_okay == NULL)
          loc_okay = &amp;(vm-&gt;pos);
        fake_hitpt.x = 0.5 * hitpt-&gt;x + 0.5 * loc_okay-&gt;x;
        fake_hitpt.y = 0.5 * hitpt-&gt;y + 0.5 * loc_okay-&gt;y;
        fake_hitpt.z = 0.5 * hitpt-&gt;z + 0.5 * loc_okay-&gt;z;

        count_region_from_scratch(world, reacA, NULL, -1, &amp;fake_hitpt, NULL, t, reacA-&gt;periodic_box);</b></font>
      }
    }
<a name="14"></a>
    free(reacA-&gt;periodic_box);
    reacA-&gt;periodic_box = NULL;
<font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    reacA-&gt;properties-&gt;n_deceased++;
    double t_time = convert_iterations_to_seconds(
        world-&gt;start_iterations, world-&gt;time_unit,
        world-&gt;simulation_start_seconds, t);
    reacA-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacA-&gt;birthday;
    reacA-&gt;properties-&gt;population--;

    if (vm != NULL)
      collect_molecule(vm);
    else
      reacA-&gt;properties = NULL;

    return RX_DESTROY;
  }

  return result;
}</b></font>

/*************************************************************************
outcome_intersect:
  In: world: simulation state
      rx: reaction that's taking place
      path: path the reaction's taking
      surface: wall that is being struck
      reac: molecule that is hitting the wall
      orient: orientation of the molecule
      t: time that the reaction is occurring
      hitpt: location of collision with wall
      loc_okay:
  Out: Value depending on outcome:
       RX_A_OK if the molecule reflects
       RX_FLIP if the molecule passes through
       RX_DESTROY if the molecule stops, is destroyed, etc.
       Additionally, products are created as needed.
  Note: Can assume molecule is always first in the reaction.
*************************************************************************/
int outcome_intersect(struct volume *world, struct rxn *rx, int path,
                      struct wall *surface, struct abstract_molecule *reac,
                      short orient, double t, struct vector3 *hitpt,
                      struct vector3 *loc_okay) {

  if (rx-&gt;n_pathways &lt;= RX_SPECIAL) {
    rx-&gt;n_occurred++;
    if (rx-&gt;n_pathways == RX_REFLEC)
      return RX_A_OK;
    else
      return RX_FLIP; /* Flip = transparent is default special case */
  }
  int idx = rx-&gt;product_idx[path];

  if ((reac-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
    struct volume_molecule *vm = (struct volume_molecule *)reac;

    /* If reaction object has ALL_MOLECULES or ALL_VOLUME_MOLECULES as the
     * first reactant it means that reaction is of the type ABSORPTIVE =
     * ALL_MOLECULES or ABSORPTIVE = ALL_VOLUME_MOLECULES since other cases
     * (REFLECTIVE/TRANSPARENT) are taken care above. But there are no products
     * for this reaction, so we do no need to go into "outcome_products()"
     * function. */

    int result;
    if ((strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_MOLECULES") == 0) ||
        (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_VOLUME_MOLECULES") == 0)) {
      result = RX_DESTROY;
    } else {
      result = outcome_products_random(world, surface, hitpt, t, rx, path,
                                       reac, NULL, orient, 0);
    }
    if (result == RX_BLOCKED)
      return RX_A_OK; /* reflect the molecule */

    rx-&gt;info[path].count++;
    rx-&gt;n_occurred++;

    if (rx-&gt;players[idx] == NULL) {
      /* The code below is also valid for the special reaction of the type
       * ABSORPTIVE = ALL_MOLECULES (or ALL_VOLUME_MOLECULES) */
      vm-&gt;subvol-&gt;mol_count--;
      if (world-&gt;place_waypoints_flag &amp;&amp; (reac-&gt;flags &amp; COUNT_ME)) {
        if (hitpt == NULL) {
          count_region_from_scratch(
            world, reac, NULL, -1, NULL, NULL, t, reac-&gt;periodic_box);
        } else {
          struct vector3 fake_hitpt;

          /* Halfway in between where we were and where we react should be a
           * safe away-from-wall place to remove us */
          if (loc_okay == NULL)
            loc_okay = &amp;(vm-&gt;pos);
          fake_hitpt.x = 0.5 * hitpt-&gt;x + 0.5 * loc_okay-&gt;x;
          fake_hitpt.y = 0.5 * hitpt-&gt;y + 0.5 * loc_okay-&gt;y;
          fake_hitpt.z = 0.5 * hitpt-&gt;z + 0.5 * loc_okay-&gt;z;

          count_region_from_scratch(world, reac, NULL, -1, &amp;fake_hitpt, NULL,
                                    t, reac-&gt;periodic_box);
        }
      }
      free(reac-&gt;periodic_box);
      reac-&gt;properties-&gt;n_deceased++;
      double t_time = convert_iterations_to_seconds(
          world-&gt;start_iterations, world-&gt;time_unit,
          world-&gt;simulation_start_seconds, t);
      reac-&gt;properties-&gt;cum_lifetime_seconds += t_time - reac-&gt;birthday;
      reac-&gt;properties-&gt;population--;
      if (vm-&gt;flags &amp; IN_SCHEDULE) {
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
         dump_volume_molecule((struct volume_molecule*)vm, "", true, "  defunct m:", world-&gt;current_iterations, 0.0, false);
      );
#endif
      collect_molecule(vm);
      return RX_DESTROY;
    } else
      return result; /* RX_A_OK or RX_FLIP */
  } else {
    /* Should really be an error because we should never call
     * outcome_intersect() on a surface molecule */
    return RX_A_OK;
  }
}

/*************************************************************************
reaction_wizardry:
  In: a list of releases to magically cause
      the wall associated with the release, if any
      the location of the release
      the time of the release
  Out: 0 if successful, 1 on failure (usually out of memory).
       Each release event in the list is triggered at a location that
       is relative to the location of the release and the surface normal
       of the wall.  The surface normal of the wall is considered to be
       the +Z direction.  Other coordinates are rotated in the "natural"
       way (i.e. the XYZ coordinate system has the Z-axis rotated directly
       to the direction of the normal and the other coordinates follow
       along naturally; if the normal is in the -Z direction, the rotation
       is about the X-axis.)
  Note: this function isn't all that cheap computationally because of
        all the math required to compute the right coordinate transform.
        If this gets really really heavily used, we should store the
        coordinate transform off of the wall data structure.
  Note: it would be more efficient to skip calculating the transform if
        the release type didn't use it (e.g. release by region).
  Note: if we wanted to be extra-super clever, we could actually schedule
        this event instead of running it and somehow have it start a
        time-shifted release pattern (so we could have delays and stuff).
*************************************************************************/
int reaction_wizardry(struct volume *world, struct magic_list *incantation,
                      struct wall *surface, struct vector3 *hitpt, double t) {
  struct release_event_queue req; /* Create a release event on the fly */

  /* Release event happens "now" */
  req.next = NULL;
  req.event_time = t;
  req.train_counter = 0;
  req.train_high_time = t;

  /* Set up transform to place products at site of reaction */
  if (hitpt == NULL) {
    init_matrix(req.t_matrix);
  } else if (surface == NULL ||
             !distinguishable(surface-&gt;normal.z, 1.0,
                              EPS_C)) /* Just need a translation */
  {
    init_matrix(req.t_matrix);
    req.t_matrix[3][0] = hitpt-&gt;x;
    req.t_matrix[3][1] = hitpt-&gt;y;
    req.t_matrix[3][2] = hitpt-&gt;z;
  } else /* Set up transform that will translate and then rotate Z axis to align
            with surface normal */
  {
    struct vector3 scale = { 1.0, 1.0, 1.0 }; /* No scaling */
    struct vector3 axis = { 1.0, 0.0, 0.0 };  /* X-axis is default */
    double cos_theta;
    double degrees;

    cos_theta = surface-&gt;normal.z; /* (0,0,1) . surface-&gt;normal */
    if (!distinguishable(cos_theta, -1.0, EPS_C)) {
      degrees = 180.0; /* Upside-down */
    } else {
      /* (0,0,1) x surface-&gt;normal */
      axis.x = -surface-&gt;normal.y;
      axis.y = surface-&gt;normal.x;
      axis.z = 0.0;

      degrees = acos(cos_theta) * 180.0 / MY_PI;
    }
    tform_matrix(&amp;scale, hitpt, &amp;axis, degrees, req.t_matrix);
  }

  /* Now we're ready to cast our spell! */
  for (; incantation != NULL; incantation = incantation-&gt;next) {
    if (incantation-&gt;type != magic_release)
      continue; /* Only know how to magically release stuff */

    req.release_site = (struct release_site_obj *)incantation-&gt;data;

    if (release_molecules(world, &amp;req))
      return 1;
  }

  return 0;
}

/************************************************************************
 *
 * this function determines where reactants grid1 and grid2 are located
 * (inside/outside) with respect to their restrictive region borders if
 * they have any.
 *
 * in: surface molecule 1 (located on wall 1)
 *     surface molecule 2 (located on wall 2)
 *     pointer to array with restrictive regions which contain wall 1
 *     pointer to array with restrictive regions which contain wall 2
 *     pointer to array with restrictive regions which don't contain wall 1
 *     pointer to array with restrictive regions which don't contain wall 2
 *
 * out: the 4 arrays with pointers to restrictive regions will be filled
 *      and returned
 *
 ***********************************************************************/
int determine_molecule_region_topology(
    struct volume *world, struct surface_molecule *sm_1,
    struct surface_molecule *sm_2, struct region_list **rlp_wall_1_ptr,
    struct region_list **rlp_wall_2_ptr, struct region_list **rlp_obj_1_ptr,
    struct region_list **rlp_obj_2_ptr, bool is_unimol) {
  int sm_bitmask = 0;
  struct wall *w_1, *w_2;
  struct region_list *rlp_head_wall_1 = NULL;
  struct region_list *rlp_head_wall_2 = NULL;
  struct region_list *rlp_head_obj_1 = NULL;
  struct region_list *rlp_head_obj_2 = NULL;

<a name="5"></a>  /* bimolecular reactions */
  if ((sm_1 != NULL) &amp;&amp; (sm_2 != NULL)) {
    /* both reactants have restrictive region borders */
<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
        (sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
        are_restricted_regions_for_species_on_object(
            world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
        are_restricted_regions_for_species_on_object(
            world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2)) {
      w_1 = sm_1-&gt;grid-&gt;surface;
      w_2 = sm_2-&gt;grid-&gt;surface;
      rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
      rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);

      /* both reactants are inside their respective restricted regions */
      if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 != NULL)) {
        sm_bitmask |= ALL_INSIDE;
      }
      /* both reactants are outside their respective restricted regions */
      else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 == NULL)) {
        rlp_head_obj_1 =
<a name="10"></a>            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        rlp_head_obj_2 =</b></font>
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
<font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        sm_bitmask |= ALL_OUTSIDE;
      }
      /* grid1 is inside and grid2 is outside of its respective
       * restrictive region */
      else if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 == NULL)) {
        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        sm_bitmask |= SURF1_IN_SURF2_OUT;
      }
<a name="1"></a>      /* grid2 is inside and grid1 is outside of its respective
       * restrictive region */
      else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 != NULL)) {</b></font>
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        sm_bitmask |= SURF1_OUT_SURF2_IN;
      }
    }

    /* only reactant sm_1 has restrictive region border property */
    else if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
             are_restricted_regions_for_species_on_object(
                 world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
             (!(sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
              !are_restricted_regions_for_species_on_object(
                   world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2))) {
      w_1 = sm_1-&gt;grid-&gt;surface;
      rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
      if (rlp_head_wall_1 != NULL) {
        sm_bitmask |= SURF1_IN;
      } else {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        sm_bitmask |= SURF1_OUT;
      }
    }

    /* only reactant "sm_2" has restrictive region border property */
    else if ((sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
             are_restricted_regions_for_species_on_object(
                 world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2) &amp;&amp;
             (!(sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
              !are_restricted_regions_for_species_on_object(
                   world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1))) {
      w_2 = sm_2-&gt;grid-&gt;surface;
      rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
      if (rlp_head_wall_2 != NULL) {</b></font>
        sm_bitmask |= SURF2_IN;
      } else {
        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        sm_bitmask |= SURF2_OUT;
      }
    }
  }

  /* unimolecular reactions */
  else if ((sm_1 != NULL) &amp;&amp; is_unimol) {
    if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
        are_restricted_regions_for_species_on_object(
            world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1)) {
      w_1 = sm_1-&gt;grid-&gt;surface;
      rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
      if (rlp_head_wall_1 != NULL) {
        sm_bitmask |= ALL_INSIDE;
      } else {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        sm_bitmask |= ALL_OUTSIDE;
      }
    }
  }

  *rlp_wall_1_ptr = rlp_head_wall_1;
  *rlp_wall_2_ptr = rlp_head_wall_2;
  *rlp_obj_1_ptr = rlp_head_obj_1;
  *rlp_obj_2_ptr = rlp_head_obj_2;

  return sm_bitmask;
}

/***********************************************************************
 *
 * this function tests if wall target can be reached for product placement
 * based on the previously stored reactant topology based on
 * sm_bitmask. Below, wall 1 is the wall containing reactant 1 and
 * wall 2 is the wall containing reactant 2.
 *
 * in: wall to test for product placement
 *     pointer to array with regions that contain wall 1
 *     pointer to array with regions that contain wall 2
 *     pointer to array with regions that do not contain wall 1
 *     pointer to array with regions that do not contain wall 2
 *
 * out: returns true or false depending if wall target can be
 *      used for product placement.
 *
 ***********************************************************************/
bool product_tile_can_be_reached(struct wall *target,
                                 struct region_list *rlp_head_wall_1,
                                 struct region_list *rlp_head_wall_2,
                                 struct region_list *rlp_head_obj_1,
                                 struct region_list *rlp_head_obj_2,
                                 int sm_bitmask, bool is_unimol) {
  bool status = true;

  if (sm_bitmask &amp; ALL_INSIDE) {
    if (is_unimol) {
      if (!wall_belongs_to_all_regions_in_region_list(target,
                                                      rlp_head_wall_1)) {
        status = false;
      }
    } else {
      /* bimol reaction */
      if (!wall_belongs_to_all_regions_in_region_list(target,
                                                      rlp_head_wall_1) ||
          !wall_belongs_to_all_regions_in_region_list(target,
                                                      rlp_head_wall_2)) {
        status = false;
      }
    }
  } else if (sm_bitmask &amp; ALL_OUTSIDE) {
    if (is_unimol) {
      if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1)) {
        status = false;
      }
    } else {
      if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1) ||
          wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_2)) {
        status = false;
      }
    }
  } else if (sm_bitmask &amp; SURF1_IN_SURF2_OUT) {
    if (!wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_1) ||
        wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_2)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF1_OUT_SURF2_IN) {
    if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1) ||
        !wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_2)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF1_IN) {
    if (!wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_1)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF1_OUT) {
    if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF2_IN) {
    if (!wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_2)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF2_OUT) {
    if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_2)) {
      status = false;
    }
  }

  return status;
}

/*
 * cleanup_and_block_rx is a simple helper function which deletes the provided
 * linked lists of tile_neighbors and the return RX_BLOCKED
 */
int cleanup_and_block_rx(struct tile_neighbor *tn1, struct tile_neighbor *tn2) {
  if (tn1 != NULL) {
    delete_tile_neighbor_list(tn1);
  }
  if (tn2 != NULL) {
    delete_tile_neighbor_list(tn2);
  }
  return RX_BLOCKED;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>react_outc_trimol.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/******************************************************************************
 *
 * Copyright (C) 2006-2017 by
 * The Salk Institute for Biological Studies and
 * Pittsburgh Supercomputing Center, Carnegie Mellon University
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 *
******************************************************************************/

#include "config.h"

#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;vector&gt;

#include "logging.h"
#include "rng.h"
#include "util.h"
#include "grid_util.h"
#include "mcell_structs.h"
#include "count_util.h"
#include "react.h"
#include "vol_util.h"
#include "wall_util.h"

static int outcome_products_trimol_reaction_random(
    struct volume *world, struct wall *w, struct vector3 *hitpt, double t,
    struct rxn *rx, int path, struct abstract_molecule *reacA,
    struct abstract_molecule *reacB, struct abstract_molecule *reacC,
    short orientA, short orientB, short orientC);

/*************************************************************************
outcome_products_trimol_reaction_random:
   In: first wall in the reaction
       hit point (if any)
       time of the reaction
       reaction
       path of the reaction
       first reactant (moving molecule)
       second reactant
       third reactant
       orientation of the first reactant
       orientation of the second reactant
       orientation of the third reactant
Note: This function replaces surface reactants (if needed) by the surface
       products picked in the random order from the list of products.
       It also places surface products on the randomly selected tiles
       from the list of neighbors.
Note: Policy on surface products placement is described in the document
      "policy_surf_products_placement.doc" (see "src/docs").

************************************************************************/
static int outcome_products_trimol_reaction_random(
    struct volume *world, struct wall *w, struct vector3 *hitpt, double t,
    struct rxn *rx, int path, struct abstract_molecule *reacA,
    struct abstract_molecule *reacB, struct abstract_molecule *reacC,
    short orientA, short orientB, short orientC) {

  if (reacA != NULL &amp;&amp; reacB != NULL) {
    assert(periodic_boxes_are_identical(reacA-&gt;periodic_box, reacB-&gt;periodic_box));
  } else if (reacA != NULL &amp;&amp; reacC != NULL) {
    assert(periodic_boxes_are_identical(reacA-&gt;periodic_box, reacC-&gt;periodic_box));
  } else if (reacB != NULL &amp;&amp; reacC != NULL) {
    assert(periodic_boxes_are_identical(reacB-&gt;periodic_box, reacC-&gt;periodic_box));
  }

  bool update_dissociation_index =
      false;               /* Do we need to advance the dissociation index? */
  bool cross_wall = false; /* Did the moving molecule cross the plane? */
<a name="2"></a>  struct subvolume *last_subvol =
      NULL; /* Last subvolume (guess used to speed sv finding) */

<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  int const i0 =
      rx-&gt;product_idx[path]; /* index of the first player for the pathway */
  int const iN =
      rx-&gt;product_idx[path + 1]; /* index of the first player for the next
                                    pathway */
  assert(iN &gt; i0);
  struct species **rx_players =
      rx-&gt;players + i0; /* Players array from the reaction. */

  int const n_players = iN - i0;                /* number of reaction players */

  std::vector&lt;struct abstract_molecule *&gt; product(n_players); /* array of products */
  /* array that decodes the type of each product */
  std::vector&lt;char&gt; product_type(n_players);
  std::vector&lt;short&gt; product_orient(n_players); /* array of orientations for each product */
  /* array of surface_grids for products */
  std::vector&lt;struct surface_grid *&gt; product_grid(n_players);
  std::vector&lt;int&gt; product_grid_idx(n_players); /* array of grid indices for products */
  std::vector&lt;byte&gt; product_flag(n_players);    /* array of placement flags for products */</b></font>

  struct tile_neighbor *tile_nbr_head = NULL; /* list of neighbor tiles */
  struct tile_neighbor *tile_nbr;             /* iterator */
  /* head of the linked list of vacant neighbor tiles */
  struct tile_neighbor *tile_vacant_nbr_head = NULL;
  struct surface_grid *tile_grid; /* surface grid the tile belongs to */
  int tile_idx;                   /* index of the tile on the grid */
  unsigned int rnd_num;           /* random number */
  int num_vacant_tiles = 0;       /* number of vacant tiles */
  int num_surface_products = 0;   /* not counting reactants */
  int num_surface_static_products =
      0; /* # of products with (D_2D == 0) not counting reactants */
  int num_surface_static_reactants = 0; /* # of reactants with (D_2D == 0) */
  /* total number of surface reactants */
  int num_surface_reactants = 0;
  /* number of surface reactants that are not replaced in the reaction */
  int num_surface_reactants_to_stay = 0;
  int list_length; /* length of the linked list tile_nbr_head */
  /* flags */
  int replace_p1 = 0, replace_p2 = 0, replace_p3 = 0, only_one_to_replace = 0,
      two_to_replace = 0;
  int find_neighbor_tiles_flag = 0;
  struct wall *w_1, *w_2, *w_3;

  /* flag that indicates that all reactants lie inside their
     respective restrictive regions */
  int all_inside_restricted_boundary = 0;
  /* flag that indicates that all reactants lie outside
     their respective restrictive regions */
  int all_outside_restricted_boundary = 0;

  /* flag that indicates that  reactants "sm_1" and "sm_2"
     lies inside and reactant "grid_3" lies outside of their
     respective restrictive regions */
  int sm_1_inside_sm_2_inside_grid_3_outside = 0;
  /* flag that indicates that  reactants "sm_1" and "grid_3"
     lies inside and reactant "sm_2" lies outside of their
     respective restrictive regions */
  int sm_1_inside_sm_2_outside_grid_3_inside = 0;
  /* flag that indicates that  reactant "sm_1" lies outside
     and reactants "sm_2" and "grid_3" lie inside of their
     respective restrictive regions */
  int sm_1_outside_sm_2_inside_grid_3_inside = 0;
  /* flag that indicates that  reactant "sm_1" lies inside
     and reactants "sm_2" and "grid_3" lie outside of their
     respective restrictive regions */
  int sm_1_inside_sm_2_outside_grid_3_outside = 0;
  /* flag that indicates that  reactants "sm_1" and "grid_3" lie outside
     and reactant "sm_2" lies inside of their
     respective restrictive regions */
  int sm_1_outside_sm_2_inside_grid_3_outside = 0;
  /* flag that indicates that  reactants "sm_1" and "sm_2"
     lie outside and reactant "grid_3" lies inside of their
     respective restrictive regions */
  int sm_1_outside_sm_2_outside_grid_3_inside = 0;

  /* flag that indicates that  reactants "sm_1" and "sm_2"
     lie inside their respective restrictive regions
     and reactant "grid_3" has no restrictive region border properties */
  int only_sm_1_sm_2_inside = 0;
  /* flag that indicates that  reactant "sm_1" lies inside
     and "sm_2" lies outside their respective restrictive regions
     and reactant "grid_3" has no restrictive region border properties */
  int only_sm_1_inside_sm_2_outside = 0;
  /* flag that indicates that  reactant "sm_1" lies outside
     and "sm_2" lies inside their respective restrictive regions
     and reactant "grid_3" has no restrictive region border properties */
  int only_sm_1_outside_sm_2_inside = 0;
  /* flag that indicates that  reactants "sm_1" and "sm_2"
     lie outside their respective restrictive regions
     and reactant "grid_3" has no restrictive region border properties */
  int only_sm_1_sm_2_outside = 0;

  /* flag that indicates that  reactants "sm_1" and "grid_3"
     lie inside their respective restrictive regions
     and reactant "sm_2" has no restrictive region border properties */
  int only_sm_1_grid_3_inside = 0;
  /* flag that indicates that  reactant "sm_1" lies inside
     and "grid_3" lies outside their respective restrictive regions
     and reactant "sm_2" has no restrictive region border properties */
  int only_sm_1_inside_grid_3_outside = 0;
  /* flag that indicates that  reactant "sm_1" lies outside
     and "grid_3" lies inside their respective restrictive regions
     and reactant "sm_2" has no restrictive region border properties */
  int only_sm_1_outside_grid_3_inside = 0;
  /* flag that indicates that  reactants "sm_1" and "grid_3"
     lie outside their respective restrictive regions
     and reactant "sm_2" has no restrictive region border properties */
  int only_sm_1_grid_3_outside = 0;

  /* flag that indicates that  reactants "sm_2" and "grid_3"
     lie inside their respective restrictive regions
     and reactant "sm_1" has no restrictive region border properties */
  int only_sm_2_grid_3_inside = 0;
  /* flag that indicates that  reactant "sm_2" lies inside
     and "grid_3" lies outside their respective restrictive regions
     and reactant "sm_1" has no restrictive region border properties */
  int only_sm_2_inside_grid_3_outside = 0;
  /* flag that indicates that  reactant "sm_2" lies outside
     and "grid_3" lies inside their respective restrictive regions
     and reactant "sm_1" has no restrictive region border properties */
  int only_sm_2_outside_grid_3_inside = 0;
  /* flag that indicates that  reactants "sm_2" and "grid_3"
     lie outside their respective restrictive regions
     and reactant "sm_1" has no restrictive region border properties */
  int only_sm_2_grid_3_outside = 0;

  /* flag that indicates that only reactant "sm_1" has
     restrictive regions on the object and it lies
     inside it's restrictive region.  */
  int only_sm_1_inside = 0;
  /* flag that indicates that only reactant "sm_1" has
     restrictive regions on the object and it lies
     outside it's restrictive region.  */
  int only_sm_1_outside = 0;
  /* flag that indicates that only reactant "sm_2" has
     restrictive regions on the object and it lies
     inside it's restrictive region.  */
  int only_sm_2_inside = 0;
  /* flag that indicates that only reactant "sm_2" has
     restrictive regions on the object and it lies
     outside it's restrictive region.  */
  int only_sm_2_outside = 0;
  /* flag that indicates that only reactant "grid_3" has
     restrictive regions on the object and it lies
     inside it's restrictive region.  */
  int only_grid_3_inside = 0;
  /* flag that indicates that only reactant "grid_3" has
     restrictive regions on the object and it lies
     outside it's restrictive region.  */
  int only_grid_3_outside = 0;

  /* list of the restricted regions for the reactants by wall */
  struct region_list *rlp_head_wall_1 = NULL, *rlp_head_wall_2 = NULL,
                     *rlp_head_wall_3 = NULL;
  /* list of the restricted regions for the reactants by object */
  struct region_list *rlp_head_obj_1 = NULL, *rlp_head_obj_2 = NULL,
                     *rlp_head_obj_3 = NULL;

  struct vector2 rxn_uv_pos; /* position of the reaction */
  int rxn_uv_idx = -1;       /* tile index of the reaction place */

  struct abstract_molecule *tmp_mol;
  short tmp_orient;

  if ((reacA == NULL) || (reacB == NULL) || (reacC == NULL)) {
    mcell_internal_error("One of the reactants in "
                         "'outcome_products_trimol_reaction_random()' is "
                         "NULL.");
<a name="0"></a>  }

  /* Clear the initial product info. */
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  for (int i = 0; i &lt; n_players; ++i) {
    product[i] = NULL;
    product_type[i] = PLAYER_NONE;
    product_orient[i] = 0;
    product_grid[i] = NULL;
    product_grid_idx[i] = -1;
    product_flag[i] = PRODUCT_FLAG_NOT_SET;
  }

  /* Flag indicating that a surface is somehow involved with this reaction. */
  struct surface_molecule *const sm_1 =
      IS_SURF_MOL(reacA) ? (struct surface_molecule *)reacA : NULL;
  struct surface_molecule *const sm_2 =
      IS_SURF_MOL(reacB) ? (struct surface_molecule *)reacB : NULL;
  struct surface_molecule *const grid_3 =
      IS_SURF_MOL(reacC) ? (struct surface_molecule *)reacC : NULL;</b></font>
  struct surface_molecule *sm_reactant = NULL;
  if (sm_1 != NULL) {
    sm_reactant = sm_1;
  } else if (sm_2 != NULL) {
    sm_reactant = sm_2;
  } else if (grid_3 != NULL) {
    sm_reactant = grid_3;
  }

  bool const is_orientable = (w != NULL) || (sm_reactant != NULL);

  /* Where are reactants relative to the restrictive region border? */
  if ((sm_1 != NULL) &amp;&amp; (sm_2 != NULL) &amp;&amp; (grid_3 != NULL)) {
    /* trimol_reaction */
    if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
        (sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
        (grid_3-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
        are_restricted_regions_for_species_on_object(
            world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
        are_restricted_regions_for_species_on_object(
            world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2) &amp;&amp;
        are_restricted_regions_for_species_on_object(
            world, grid_3-&gt;grid-&gt;surface-&gt;parent_object, grid_3)) {
      w_1 = sm_1-&gt;grid-&gt;surface;
      w_2 = sm_2-&gt;grid-&gt;surface;
      w_3 = grid_3-&gt;grid-&gt;surface;
      rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
      rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
      rlp_head_wall_3 = find_restricted_regions_by_wall(world, w_3, grid_3);

      if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 != NULL) &amp;&amp;
          (rlp_head_wall_3 != NULL)) {
        /* all reactants are inside their respective
           restricted regions */
        all_inside_restricted_boundary = 1;

      } else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 == NULL) &amp;&amp;
                 (rlp_head_wall_3 == NULL)) {
        /* all reactants are outside their respective
           restricted regions */
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        rlp_head_obj_3 = find_restricted_regions_by_object(
            world, w_3-&gt;parent_object, grid_3);

        all_outside_restricted_boundary = 1;
      } else if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 != NULL) &amp;&amp;
                 (rlp_head_wall_3 == NULL)) {
        rlp_head_obj_3 = find_restricted_regions_by_object(
            world, w_3-&gt;parent_object, grid_3);
        sm_1_inside_sm_2_inside_grid_3_outside = 1;
      } else if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_3 != NULL) &amp;&amp;
                 (rlp_head_wall_2 == NULL)) {
        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        sm_1_inside_sm_2_outside_grid_3_inside = 1;
      } else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 != NULL) &amp;&amp;
                 (rlp_head_wall_3 == NULL)) {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        rlp_head_obj_3 = find_restricted_regions_by_object(
            world, w_3-&gt;parent_object, grid_3);
        sm_1_outside_sm_2_inside_grid_3_outside = 1;
      } else if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 == NULL) &amp;&amp;
                 (rlp_head_wall_3 == NULL)) {
        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        rlp_head_obj_3 = find_restricted_regions_by_object(
            world, w_3-&gt;parent_object, grid_3);
        sm_1_inside_sm_2_outside_grid_3_outside = 1;
      } else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 != NULL) &amp;&amp;
                 (rlp_head_wall_3 != NULL)) {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        sm_1_outside_sm_2_inside_grid_3_inside = 1;
      } else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 == NULL) &amp;&amp;
                 (rlp_head_wall_3 != NULL)) {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        rlp_head_obj_2 =
<a name="5"></a>            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        sm_1_outside_sm_2_outside_grid_3_inside = 1;
      }
<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    } else if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
               are_restricted_regions_for_species_on_object(
                   world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
               (sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
               are_restricted_regions_for_species_on_object(
                   world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2) &amp;&amp;
               (!(grid_3-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
                !are_restricted_regions_for_species_on_object(
                     world, grid_3-&gt;grid-&gt;surface-&gt;parent_object, grid_3))) {
      /* only reactants "sm_1" and "sm_2" have restrictive
         region border property */
      w_1 = sm_1-&gt;grid-&gt;surface;
      rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
      w_2 = sm_2-&gt;grid-&gt;surface;
      rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
      if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 != NULL)) {
        only_sm_1_sm_2_inside = 1;
      } else if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 == NULL)) {
        only_sm_1_inside_sm_2_outside = 1;
        rlp_head_obj_2 =</b></font>
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
      } else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 != NULL)) {
        only_sm_1_outside_sm_2_inside = 1;
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
      } else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 == NULL)) {
        only_sm_1_sm_2_outside = 1;
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
      }
    } else if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
               are_restricted_regions_for_species_on_object(
                   world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
               (!(sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
                !are_restricted_regions_for_species_on_object(
                     world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2)) &amp;&amp;
               (grid_3-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
               are_restricted_regions_for_species_on_object(
                   world, grid_3-&gt;grid-&gt;surface-&gt;parent_object, grid_3)) {
      /* only reactants "sm_1" and "grid_3" have restrictive
         region border property */
      w_1 = sm_1-&gt;grid-&gt;surface;
      rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
<a name="10"></a>      w_3 = grid_3-&gt;grid-&gt;surface;
      rlp_head_wall_3 = find_restricted_regions_by_wall(world, w_3, grid_3);
      if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_3 != NULL)) {
<font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        only_sm_1_grid_3_inside = 1;
      } else if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_3 == NULL)) {
        only_sm_1_inside_grid_3_outside = 1;
        rlp_head_obj_3 = find_restricted_regions_by_object(
            world, w_3-&gt;parent_object, grid_3);
      } else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_3 != NULL)) {</b></font>
        only_sm_1_outside_grid_3_inside = 1;
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
      } else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_3 == NULL)) {
        only_sm_1_grid_3_outside = 1;
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        rlp_head_obj_3 = find_restricted_regions_by_object(
            world, w_3-&gt;parent_object, grid_3);
      }
    } else if ((!(sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
                (!are_restricted_regions_for_species_on_object(
                      world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1))) &amp;&amp;
               (sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
               are_restricted_regions_for_species_on_object(
                   world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2) &amp;&amp;
               (grid_3-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
               are_restricted_regions_for_species_on_object(
                   world, grid_3-&gt;grid-&gt;surface-&gt;parent_object, grid_3)) {
      /* only reactants "sm_2" and "grid_3" have restrictive
         region border property */
      w_2 = sm_2-&gt;grid-&gt;surface;
      rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
      w_3 = grid_3-&gt;grid-&gt;surface;
      rlp_head_wall_3 = find_restricted_regions_by_wall(world, w_3, grid_3);
      if ((rlp_head_wall_2 != NULL) &amp;&amp; (rlp_head_wall_3 != NULL)) {
        only_sm_2_grid_3_inside = 1;
      } else if ((rlp_head_wall_2 != NULL) &amp;&amp; (rlp_head_wall_3 == NULL)) {
        only_sm_2_inside_grid_3_outside = 1;
        rlp_head_obj_3 = find_restricted_regions_by_object(
            world, w_3-&gt;parent_object, grid_3);
      } else if ((rlp_head_wall_2 == NULL) &amp;&amp; (rlp_head_wall_3 != NULL)) {
        only_sm_2_outside_grid_3_inside = 1;
        rlp_head_obj_2 =
<a name="1"></a>            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
      } else if ((rlp_head_wall_2 == NULL) &amp;&amp; (rlp_head_wall_3 == NULL)) {
        only_sm_2_grid_3_outside = 1;
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        rlp_head_obj_3 = find_restricted_regions_by_object(
            world, w_3-&gt;parent_object, grid_3);
      }
    } else if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
               are_restricted_regions_for_species_on_object(
                   world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
               (!(sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
                !are_restricted_regions_for_species_on_object(
                     world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2)) &amp;&amp;
               (!(grid_3-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
                !are_restricted_regions_for_species_on_object(
                     world, grid_3-&gt;grid-&gt;surface-&gt;parent_object, grid_3))) {
      /* only reactant "sm_1" has restrictive region border property */
      w_1 = sm_1-&gt;grid-&gt;surface;
      rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
      if (rlp_head_wall_1 != NULL) {
        only_sm_1_inside = 1;
      } else {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        only_sm_1_outside = 1;
      }
    } else if ((sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
               are_restricted_regions_for_species_on_object(
                   world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2) &amp;&amp;
               (!(sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
                !are_restricted_regions_for_species_on_object(
                     world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1)) &amp;&amp;
               (!(grid_3-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
                !are_restricted_regions_for_species_on_object(
                     world, grid_3-&gt;grid-&gt;surface-&gt;parent_object, grid_3))) {
      /* only reactant "sm_2" has restrictive region border property */
      w_2 = sm_2-&gt;grid-&gt;surface;
      rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
      if (rlp_head_wall_2 != NULL)</b></font>
        only_sm_2_inside = 1;
      else {
        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        only_sm_2_outside = 1;
      }
    } else if ((grid_3-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
               are_restricted_regions_for_species_on_object(
                   world, grid_3-&gt;grid-&gt;surface-&gt;parent_object, grid_3) &amp;&amp;
               (!(sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
                !are_restricted_regions_for_species_on_object(
                     world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1)) &amp;&amp;
               (!(sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
                !are_restricted_regions_for_species_on_object(
                     world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2))) {
      /* only reactant "grid_3" has restrictive region border property */
      w_3 = grid_3-&gt;grid-&gt;surface;
      rlp_head_wall_3 = find_restricted_regions_by_wall(world, w_3, grid_3);
      if (rlp_head_wall_3 != NULL)
        only_grid_3_inside = 1;
      else {
        rlp_head_obj_3 = find_restricted_regions_by_object(
            world, w_3-&gt;parent_object, grid_3);
        only_grid_3_outside = 1;
      }
    }
  }

  /* reacA is the molecule which initiated the reaction. */
  struct abstract_molecule *const initiator = reacA;
  short const initiatorOrient = orientA;

  /* make sure that reacA corresponds to rx-&gt;players[0],
     reacB - to rx-&gt;players[1], and reacC - to rx-&gt;players[2]
     in trimolecular reaction */
  if (reacA-&gt;properties == rx-&gt;players[0]) {
    if (reacB-&gt;properties == rx-&gt;players[2] &amp;&amp;
        reacB-&gt;properties != rx-&gt;players[1]) {
      /* switch B and C */
      tmp_mol = reacB;
      reacB = reacC;
      reacC = tmp_mol;

      tmp_orient = orientB;
      orientB = orientC;
      orientC = tmp_orient;
    }
  } else if (reacA-&gt;properties == rx-&gt;players[1]) {

    if (reacB-&gt;properties == rx-&gt;players[0] &amp;&amp;
        reacB-&gt;properties != rx-&gt;players[1]) {
      /* switch reacA and reacB */
      tmp_mol = reacB;
      reacB = reacA;
      reacA = tmp_mol;

      tmp_orient = orientB;
      orientB = orientA;
      orientA = tmp_orient;
    } else if (reacC-&gt;properties == rx-&gt;players[0]) {
      /* switch reacA and reacC */
      tmp_mol = reacA;
      reacA = reacC;
      reacC = tmp_mol;

      tmp_orient = orientA;
      orientA = orientC;
      orientC = tmp_orient;
      /* now switch reacC and reacB  */
      tmp_mol = reacB;
      reacB = reacC;
      reacC = tmp_mol;

      tmp_orient = orientB;
      orientB = orientC;
      orientC = tmp_orient;
    }
  } else if (reacA-&gt;properties == rx-&gt;players[2]) {
    if (reacB-&gt;properties == rx-&gt;players[0]) {
      /* switch reacA and reacB */
      tmp_mol = reacB;
      reacB = reacA;
      reacA = tmp_mol;

      tmp_orient = orientB;
      orientB = orientA;
      orientA = tmp_orient;

      /* switch reacB and reacC */
      tmp_mol = reacB;
      reacB = reacC;
      reacC = tmp_mol;

      tmp_orient = orientB;
      orientB = orientC;
      orientC = tmp_orient;

    } else if ((reacC-&gt;properties == rx-&gt;players[0]) &amp;&amp;
               (reacC-&gt;properties != rx-&gt;players[2])) {
      /* switch reacA and reacC */
      tmp_mol = reacA;
      reacA = reacC;
      reacC = tmp_mol;

      tmp_orient = orientA;
      orientA = orientC;
      orientC = tmp_orient;
    }
  }

  add_reactants_to_product_list(rx, reacA, reacB, reacC, &amp;product[0], &amp;product_type[0]);

  /* Determine whether any of the reactants can be replaced by a product. */
  if (product_type[0] == PLAYER_SURF_MOL) {
    num_surface_reactants++;
    if (rx_players[0] == NULL)
      replace_p1 = 1;
    else
      num_surface_reactants_to_stay++;
  }
  if (product_type[1] == PLAYER_SURF_MOL) {
    num_surface_reactants++;
    if (rx_players[1] == NULL)
      replace_p2 = 1;
    else
      num_surface_reactants_to_stay++;
  }
  if (product_type[2] == PLAYER_SURF_MOL) {
    num_surface_reactants++;
    if (rx_players[2] == NULL)
      replace_p3 = 1;
    else
      num_surface_reactants_to_stay++;
  }

  if (replace_p1 &amp;&amp; (!replace_p2) &amp;&amp; (!replace_p3)) {
    only_one_to_replace = 1;
  } else if ((!replace_p1) &amp;&amp; replace_p2 &amp;&amp; (!replace_p3)) {
    only_one_to_replace = 1;
  } else if ((!replace_p1) &amp;&amp; (!replace_p2) &amp;&amp; replace_p3) {
    only_one_to_replace = 1;
  }
  if (replace_p1 &amp;&amp; (replace_p2) &amp;&amp; (!replace_p3)) {
    two_to_replace = 1;
  } else if (replace_p1 &amp;&amp; (!replace_p2) &amp;&amp; replace_p3) {
    two_to_replace = 1;
  } else if ((!replace_p1) &amp;&amp; replace_p2 &amp;&amp; replace_p3) {
    two_to_replace = 1;
  }

  /* find out number of surface products */
  for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
    if (rx_players[n_product] == NULL)
      continue;
    if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
      num_surface_products++;
      if (!distinguishable(rx_players[n_product]-&gt;D, 0, EPS_C))
        num_surface_static_products++;
    }
  }

  if (num_surface_reactants &gt;= 2)
    find_neighbor_tiles_flag = 1;
  if ((num_surface_reactants == 1) &amp;&amp; (num_surface_products &gt; 1))
    find_neighbor_tiles_flag = 1;

  /* Determine the point of reaction on the surface. */
  if (is_orientable) {
    if (sm_reactant)
      rxn_uv_pos = sm_reactant-&gt;s_pos;
    else {
      xyz2uv(hitpt, w, &amp;rxn_uv_pos);
    }

    if ((w == NULL) &amp;&amp; (sm_reactant != NULL))
      w = sm_reactant-&gt;grid-&gt;surface;

    assert(w != NULL);
    if (w-&gt;grid == NULL) {
      /* reacA must be a volume molecule, or this wall would have a grid
       * already. */
      assert(!IS_SURF_MOL(reacA));

      if (create_grid(world, w, ((struct volume_molecule *)reacA)-&gt;subvol))
        mcell_allocfailed("Failed to create a grid for a wall.");
    }

    if (find_neighbor_tiles_flag) {
      /* create list of neighbor tiles around rxn_uv_pos */
      rxn_uv_idx = uv2grid(&amp;rxn_uv_pos, w-&gt;grid);

      if (sm_reactant != NULL) {
        find_neighbor_tiles(world, sm_reactant, sm_reactant-&gt;grid,
                            sm_reactant-&gt;grid_index, 1, 0, &amp;tile_nbr_head,
                            &amp;list_length);
      } else {
        find_neighbor_tiles(world, sm_reactant, w-&gt;grid, rxn_uv_idx, 1, 0,
                            &amp;tile_nbr_head, &amp;list_length);
<a name="17"></a>      }

      /* Create list of vacant tiles */
<font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>      for (tile_nbr = tile_nbr_head; tile_nbr != NULL;
           tile_nbr = tile_nbr-&gt;next) {
        struct surface_molecule_list *sm_list = tile_nbr-&gt;grid-&gt;sm_list[tile_nbr-&gt;idx];
        if (sm_list == NULL || sm_list-&gt;sm == NULL) {
          num_vacant_tiles++;
          push_tile_neighbor_to_list(&amp;tile_vacant_nbr_head, tile_nbr-&gt;grid,
                                     tile_nbr-&gt;idx);
        }
      }
    }</b></font>
  }

  /* find out number of static surface reactants */
  if ((sm_1 != NULL) &amp;&amp; !distinguishable(sm_1-&gt;properties-&gt;D, 0, EPS_C))
    num_surface_static_reactants++;
  if ((sm_2 != NULL) &amp;&amp; !distinguishable(sm_2-&gt;properties-&gt;D, 0, EPS_C))
    num_surface_static_reactants++;
  if ((grid_3 != NULL) &amp;&amp; !distinguishable(grid_3-&gt;properties-&gt;D, 0, EPS_C))
    num_surface_static_reactants++;

  /* If the reaction involves a surface, make sure there is room for each
   * product. */
  if (is_orientable) {
    /* Can this reaction happen at all? */
    if (replace_p1 &amp;&amp; replace_p2 &amp;&amp; replace_p3) {
      if (num_surface_products &gt; num_vacant_tiles + 3) {
        if (tile_nbr_head != NULL)
          delete_tile_neighbor_list(tile_nbr_head);
        if (tile_vacant_nbr_head != NULL)
          delete_tile_neighbor_list(tile_vacant_nbr_head);
        return RX_BLOCKED;
      }
    } else if (two_to_replace) {
      if (num_surface_products &gt; num_vacant_tiles + 2) {
        if (tile_nbr_head != NULL)
          delete_tile_neighbor_list(tile_nbr_head);
        if (tile_vacant_nbr_head != NULL)
          delete_tile_neighbor_list(tile_vacant_nbr_head);
        return RX_BLOCKED;
      }
    } else if (only_one_to_replace) {
      if (num_surface_products &gt; num_vacant_tiles + 1) {
        if (tile_nbr_head != NULL)
          delete_tile_neighbor_list(tile_nbr_head);
        if (tile_vacant_nbr_head != NULL)
          delete_tile_neighbor_list(tile_vacant_nbr_head);
        return RX_BLOCKED;
      }
    } else {
      /* none of the reactants is replaced */
      if (num_surface_products &gt; num_vacant_tiles) {
        if (tile_nbr_head != NULL)
          delete_tile_neighbor_list(tile_nbr_head);
        if (tile_vacant_nbr_head != NULL)
          delete_tile_neighbor_list(tile_vacant_nbr_head);
        return RX_BLOCKED;
      }
    }

    /* set the orientations of the products. */
    for (int n_product = 0; n_product &lt; n_players; ++n_product) {
      /* Skip NULL reactants. */
      if (rx_players[n_product] == NULL)
        continue;

      int this_geometry = rx-&gt;geometries[i0 + n_product];

      /* Geometry of 0 means "random orientation" */
      if (this_geometry == 0)
        product_orient[n_product] = (rng_uint(world-&gt;rng) &amp; 1) ? 1 : -1;
      else {
        /* Geometry &lt; 0 means inverted orientation */
        if (this_geometry &lt; 0) {
          this_geometry = -this_geometry;
          if (this_geometry &gt; (int)rx-&gt;n_reactants)
            product_orient[n_product] =
                -product_orient[this_geometry - rx-&gt;n_reactants - 1];
          else if (this_geometry == 1)
            product_orient[n_product] = -orientA;
          else if ((this_geometry == 2) &amp;&amp; (reacB != NULL))
            product_orient[n_product] = -orientB;
          else if ((this_geometry == 3) &amp;&amp; (reacC != NULL))
            product_orient[n_product] = -orientC;
          else
            product_orient[n_product] = -1;
        }

        /* Geometry &gt; 0 means "positive" orientation. */
        else {
          if (this_geometry &gt; (int)rx-&gt;n_reactants)
            product_orient[n_product] =
                product_orient[this_geometry - rx-&gt;n_reactants - 1];
          else if (this_geometry == 1)
            product_orient[n_product] = orientA;
          else if ((this_geometry == 2) &amp;&amp; (reacB != NULL))
            product_orient[n_product] = orientB;
<a name="16"></a>          else if ((this_geometry == 3) &amp;&amp; (reacC != NULL))
            product_orient[n_product] = orientC;
          else
<font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>            product_orient[n_product] = 1;
        }
      }

      /* If this is a reactant... */
      if (n_product &lt; (int)rx-&gt;n_reactants) {
        /* If this is a surface molecule, we need to set its orientation. */
        if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
          assert(IS_SURF_MOL(product[n_product]));
          struct surface_molecule *sm =
              (struct surface_molecule *)product[n_product];

          /* If the new orientation doesn't match the old, we've got some work
           * to do. */
          if (sm-&gt;orient != product_orient[n_product]) {

            /* We're about to update the molecule's orientation, so we will
             * first remove it from the counts in case we have any
             * orientation-sensitive counts.  Then, we will update the
             * orientation.  Finally, we will add the molecule back into the
             * counts in its new orientation.
             */

            /* Remove molecule from counts in old orientation, if mol is
             * counted. */
            if (product[n_product]-&gt;properties-&gt;flags &amp;</b></font>
                (COUNT_CONTENTS | COUNT_ENCLOSED))
              count_region_from_scratch(world,
                                        product[n_product], /* molecule */
                                        NULL,               /* rxn pathway */
                                        -1,                 /* remove count */
                                        NULL, /* Location at which to count */
                                        w,    /* Wall on which this happened */
                                        t,    /* Time of occurrence */
                                        NULL);

            /* Force check for the unimolecular reactions
               after changing orientation.
               There are two possible cases to be covered here:
               1) when (sm-&gt;t2) was previously set to FOREVER
               2) there may be two or more unimolecular
                  reactions involving surface class that have
                  different kinetics.
             */
            if (((sm-&gt;flags &amp; ACT_REACT) != 0) &amp;&amp;
                ((sm-&gt;properties-&gt;flags &amp; CAN_SURFWALL) != 0))
              sm-&gt;t2 = 0;

            /* Set the molecule's orientation. */
            sm-&gt;orient = product_orient[n_product];

            /* Add molecule back to counts in new orientation, if mol is
             * counted. */
            if (product[n_product]-&gt;properties-&gt;flags &amp;
                (COUNT_CONTENTS | COUNT_ENCLOSED))
              count_region_from_scratch(world,
                                        product[n_product], /* molecule */
                                        NULL,               /* rxn pathway */
                                        1,                  /* add count */
                                        NULL, /* Location at which to count */
                                        w,    /* Wall on which this happened */
                                        t,    /* Time of occurrence */
                                        NULL);
          }
<a name="4"></a>        }

        /* Otherwise, check if we've crossed the plane. */
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        else {
          if (product[n_product] == initiator) {
            if (product_orient[n_product] != initiatorOrient)
              cross_wall = true;
          }
        }
      }
    }

    /* find out where to place surface products */
    /* Some special cases are listed below. */
    if (num_surface_products == 1) {
      if ((num_surface_static_reactants == 1) &amp;&amp;
          (num_surface_static_products == 1) &amp;&amp;
          (replace_p1 || replace_p2 || replace_p3)) {
        /* the lonely static product always replaces the lonely static reactant
         */
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players;
             n_product++) {
          if (rx_players[n_product] == NULL)</b></font>
            continue;
          if ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)
            continue;
<a name="3"></a>          if (distinguishable(rx_players[n_product]-&gt;D, 0, EPS_C))
            continue;

<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            if (replace_p1 &amp;&amp; !distinguishable(reacA-&gt;properties-&gt;D, 0, EPS_C)) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
              product_grid[n_product] =
                  ((struct surface_molecule *)reacA)-&gt;grid;
              product_grid_idx[n_product] =
                  ((struct surface_molecule *)reacA)-&gt;grid_index;
              replace_p1 = 0;
              break;
            } else if (replace_p2 &amp;&amp; !distinguishable(reacB-&gt;properties-&gt;D, 0, EPS_C)) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
              product_grid[n_product] =
                  ((struct surface_molecule *)reacB)-&gt;grid;
              product_grid_idx[n_product] =
                  ((struct surface_molecule *)reacB)-&gt;grid_index;</b></font>
              replace_p2 = 0;
              break;
            } else if (replace_p3 &amp;&amp; !distinguishable(reacC-&gt;properties-&gt;D, 0, EPS_C)) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACC_UV;
              product_grid[n_product] =
                  ((struct surface_molecule *)reacC)-&gt;grid;
<a name="13"></a>              product_grid_idx[n_product] =
                  ((struct surface_molecule *)reacC)-&gt;grid_index;
              replace_p3 = 0;
<font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>              break;
            }
          }
        }
      } else if (replace_p1 &amp;&amp; replace_p2 &amp;&amp; replace_p3) {
        /* if all reactants should be  replaced and there is only one
           surface product here we make sure that initiator molecule
           is replaced */
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players;
             n_product++) {
          if (rx_players[n_product] == NULL)</b></font>
            continue;
          if ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)
            continue;

          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            if (reacA == initiator) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
              product_grid[n_product] =
                  ((struct surface_molecule *)reacA)-&gt;grid;
<a name="9"></a>              product_grid_idx[n_product] =
                  ((struct surface_molecule *)reacA)-&gt;grid_index;
              replace_p1 = 0;
<font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>            } else if (reacB == initiator) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
              product_grid[n_product] =
                  ((struct surface_molecule *)reacB)-&gt;grid;
              product_grid_idx[n_product] =
                  ((struct surface_molecule *)reacB)-&gt;grid_index;
              replace_p2 = 0;
            } else {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACC_UV;
              product_grid[n_product] =
                  ((struct surface_molecule *)reacC)-&gt;grid;
              product_grid_idx[n_product] =
                  ((struct surface_molecule *)reacC)-&gt;grid_index;</b></font>
              replace_p3 = 0;
            }
            break;
          }
        }
      } else if (two_to_replace) {
        /* replace one of the two reactants randomly */
        while (true) {
          rnd_num = rng_uint(world-&gt;rng) % (rx-&gt;n_reactants);

          if ((rnd_num == 0) &amp;&amp; replace_p1)
            break;

          if ((rnd_num == 1) &amp;&amp; replace_p2)
            break;

          if ((rnd_num == 2) &amp;&amp; replace_p3)
            break;
        }

        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players;
             n_product++) {
          if (rx_players[n_product] == NULL)
            continue;
          if ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)
            continue;

          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            if (rnd_num == 0) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
              product_grid[n_product] =
                  ((struct surface_molecule *)reacA)-&gt;grid;
              product_grid_idx[n_product] =
                  ((struct surface_molecule *)reacA)-&gt;grid_index;
              replace_p1 = 0;
            } else if (rnd_num == 1) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
              product_grid[n_product] =
                  ((struct surface_molecule *)reacB)-&gt;grid;
              product_grid_idx[n_product] =
                  ((struct surface_molecule *)reacB)-&gt;grid_index;
              replace_p2 = 0;
            } else if (rnd_num == 2) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACC_UV;
              product_grid[n_product] =
                  ((struct surface_molecule *)reacC)-&gt;grid;
<a name="12"></a>              product_grid_idx[n_product] =
                  ((struct surface_molecule *)reacC)-&gt;grid_index;
              replace_p3 = 0;
<font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>            }
            break;
          }
        }

      } else if (only_one_to_replace) {
        /* no need for a random number here */
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players;
             n_product++) {
          if (rx_players[n_product] == NULL)</b></font>
            continue;
          if ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)
            continue;

          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            if (replace_p1) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
              product_grid[n_product] =
                  ((struct surface_molecule *)reacA)-&gt;grid;
              product_grid_idx[n_product] =
                  ((struct surface_molecule *)reacA)-&gt;grid_index;
              replace_p1 = 0;
              break;
            } else if (replace_p2) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
              product_grid[n_product] =
                  ((struct surface_molecule *)reacB)-&gt;grid;
              product_grid_idx[n_product] =
                  ((struct surface_molecule *)reacB)-&gt;grid_index;
              replace_p2 = 0;
              break;
            } else {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACC_UV;
              product_grid[n_product] =
                  ((struct surface_molecule *)reacC)-&gt;grid;
              product_grid_idx[n_product] =
                  ((struct surface_molecule *)reacC)-&gt;grid_index;
              replace_p3 = 0;
              break;
            }
          }
        }
      }

    } else if (num_surface_products &gt; 1) {
      int count;
      if (num_surface_static_reactants &gt; 0) {
        if (num_surface_static_products &gt;= num_surface_static_reactants) {
          count = 0;
          while (count &lt; num_surface_static_reactants) {
            rnd_num = rng_uint(world-&gt;rng) % n_players;
            /* pass reactants */
            if (rnd_num &lt; 3)
              continue;

            if (rx_players[rnd_num] == NULL)
              continue;
            if ((rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0)
              continue;
            if (distinguishable(rx_players[rnd_num]-&gt;D, 0, EPS_C))
              continue;

            if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
              if ((!distinguishable(reacA-&gt;properties-&gt;D, 0, EPS_C)) &amp;&amp; replace_p1) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
                product_grid[rnd_num] =
                    ((struct surface_molecule *)reacA)-&gt;grid;
                product_grid_idx[rnd_num] =
                    ((struct surface_molecule *)reacA)-&gt;grid_index;
                replace_p1 = 0;
                count++;
                continue;
              }
              if ((!distinguishable(reacB-&gt;properties-&gt;D, 0, EPS_C)) &amp;&amp; replace_p2) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
                product_grid[rnd_num] =
                    ((struct surface_molecule *)reacB)-&gt;grid;
                product_grid_idx[rnd_num] =
                    ((struct surface_molecule *)reacB)-&gt;grid_index;
                replace_p2 = 0;
                count++;
                continue;
              }
              if ((!distinguishable(reacC-&gt;properties-&gt;D, 0, EPS_C)) &amp;&amp; replace_p3) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACC_UV;
                product_grid[rnd_num] =
                    ((struct surface_molecule *)reacC)-&gt;grid;
                product_grid_idx[rnd_num] =
                    ((struct surface_molecule *)reacC)-&gt;grid_index;
                replace_p3 = 0;
                count++;
                continue;
              }
            }
          } /* end while */

        } else { /*(num_surface_static_products&lt;num_surface_static_reactants)*/
          count = 0;
          while (count &lt; num_surface_static_products) {
            rnd_num = rng_uint(world-&gt;rng) % n_players;
            /* pass reactants */
            if (rnd_num &lt; 3)
              continue;

            if (rx_players[rnd_num] == NULL)
              continue;
            if ((rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0)
              continue;
            if (distinguishable(rx_players[rnd_num]-&gt;D, 0, EPS_C))
              continue;

            if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
              if ((!distinguishable(reacA-&gt;properties-&gt;D, 0, EPS_C)) &amp;&amp; replace_p1) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
                product_grid[rnd_num] =
                    ((struct surface_molecule *)reacA)-&gt;grid;
                product_grid_idx[rnd_num] =
                    ((struct surface_molecule *)reacA)-&gt;grid_index;
                replace_p1 = 0;
                count++;
                continue;
              }
              if ((!distinguishable(reacB-&gt;properties-&gt;D, 0, EPS_C)) &amp;&amp; replace_p2) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
                product_grid[rnd_num] =
                    ((struct surface_molecule *)reacB)-&gt;grid;
                product_grid_idx[rnd_num] =
                    ((struct surface_molecule *)reacB)-&gt;grid_index;
                replace_p2 = 0;
                count++;
                continue;
              }
              if ((!distinguishable(reacC-&gt;properties-&gt;D, 0, EPS_C)) &amp;&amp; replace_p3) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACC_UV;
                product_grid[rnd_num] =
                    ((struct surface_molecule *)reacC)-&gt;grid;
                product_grid_idx[rnd_num] =
                    ((struct surface_molecule *)reacC)-&gt;grid_index;
<a name="6"></a>                replace_p3 = 0;
                count++;
                continue;
<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>              }
            }

          } /* end while */
        }
      }

      /* check whether there are any surface reactants left to replace
         with surface products since we are done with static
         reactants/products */

      if (replace_p1 || replace_p2 || replace_p3) {
        /* are there any surface products left that have not replaced yet
            reactants? */

        int surf_prod_left = 0, surf_reactant_left = 0;

        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players;
             n_product++) {
          if (rx_players[n_product] == NULL)</b></font>
            continue;
          if ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)
            continue;

          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET)
            surf_prod_left++;
        }

        if (replace_p1)
          surf_reactant_left++;
        if (replace_p2)
          surf_reactant_left++;
        if (replace_p3)
          surf_reactant_left++;

        if (surf_prod_left &gt; 0) {

          if (surf_prod_left &gt;= surf_reactant_left) {
            count = 0;
            while (count &lt; surf_reactant_left) {
              rnd_num = rng_uint(world-&gt;rng) % n_players;
              /* pass reactants */
              if (rnd_num &lt; 3)
                continue;

              if (rx_players[rnd_num] == NULL)
                continue;
              if ((rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0)
                continue;

              if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
                if (replace_p1) {
                  product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
                  product_grid[rnd_num] =
                      ((struct surface_molecule *)reacA)-&gt;grid;
                  product_grid_idx[rnd_num] =
                      ((struct surface_molecule *)reacA)-&gt;grid_index;
                  replace_p1 = 0;
                  count++;
                  continue;
                }
                if (replace_p2) {
                  product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
                  product_grid[rnd_num] =
                      ((struct surface_molecule *)reacB)-&gt;grid;
                  product_grid_idx[rnd_num] =
                      ((struct surface_molecule *)reacB)-&gt;grid_index;
                  replace_p2 = 0;
                  count++;
                  continue;
                }
                if (replace_p3) {
                  product_flag[rnd_num] = PRODUCT_FLAG_USE_REACC_UV;
                  product_grid[rnd_num] =
                      ((struct surface_molecule *)reacC)-&gt;grid;
                  product_grid_idx[rnd_num] =
                      ((struct surface_molecule *)reacC)-&gt;grid_index;
                  replace_p3 = 0;
                  count++;
                  continue;
                }
              }
            } /* end while */

          } else { /* surf_prod_left &lt; surf_reactant_left */
            count = 0;
            while (count &lt; surf_prod_left) {
              rnd_num = rng_uint(world-&gt;rng) % n_players;
              /* pass reactants */
              if (rnd_num &lt; 3)
                continue;

              if (rx_players[rnd_num] == NULL)
                continue;
              if ((rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0)
                continue;

              if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
                if (replace_p1) {
                  product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
                  product_grid[rnd_num] =
                      ((struct surface_molecule *)reacA)-&gt;grid;
                  product_grid_idx[rnd_num] =
                      ((struct surface_molecule *)reacA)-&gt;grid_index;
                  replace_p1 = 0;
                  count++;
                  continue;
                }
                if (replace_p2) {
                  product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
                  product_grid[rnd_num] =
                      ((struct surface_molecule *)reacB)-&gt;grid;
                  product_grid_idx[rnd_num] =
                      ((struct surface_molecule *)reacB)-&gt;grid_index;
                  replace_p2 = 0;
                  count++;
                  continue;
                }
                if (replace_p3) {
                  product_flag[rnd_num] = PRODUCT_FLAG_USE_REACC_UV;
                  product_grid[rnd_num] =
                      ((struct surface_molecule *)reacC)-&gt;grid;
                  product_grid_idx[rnd_num] =
                      ((struct surface_molecule *)reacC)-&gt;grid_index;
                  replace_p3 = 0;
                  count++;
                  continue;
                }
              }

            } /* end while */
          }
        }
      }
    }

    int num_attempts = 0;

    /* all other products are placed on one of the randomly chosen vacant
       tiles */
    for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
      /* If the product is a volume product, no placement is required. */
      if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
        if (product_flag[n_product] != PRODUCT_FLAG_NOT_SET)
          continue;

        if (num_vacant_tiles == 0) {
          if (tile_nbr_head != NULL)
            delete_tile_neighbor_list(tile_nbr_head);
          if (tile_vacant_nbr_head != NULL)
            delete_tile_neighbor_list(tile_vacant_nbr_head);
          return RX_BLOCKED;
        }

        while (true) {
          if (num_attempts &gt; SURFACE_DIFFUSION_RETRIES) {
            if (tile_nbr_head != NULL)
              delete_tile_neighbor_list(tile_nbr_head);
            if (tile_vacant_nbr_head != NULL)
              delete_tile_neighbor_list(tile_vacant_nbr_head);
            return RX_BLOCKED;
          }

          /* randomly pick a tile from the list */
          rnd_num = rng_uint(world-&gt;rng) % num_vacant_tiles;
          tile_idx = -1;
          tile_grid = NULL;

          if (get_tile_neighbor_from_list_of_vacant_neighbors(
                  tile_vacant_nbr_head, rnd_num, &amp;tile_grid, &amp;tile_idx) == 0) {
            if (tile_nbr_head != NULL)
              delete_tile_neighbor_list(tile_nbr_head);
            if (tile_vacant_nbr_head != NULL)
              delete_tile_neighbor_list(tile_vacant_nbr_head);
            return RX_BLOCKED;
          }
          if (tile_idx &lt; 0)
            continue; /* this tile was checked out before */

          assert(tile_grid != NULL);

          if (all_inside_restricted_boundary) {
            /* if this tile is not inside the restricted boundary
               - try again */
            int cond_1 = 0, cond_2 = 0, cond_3 = 0;
            cond_1 = (!wall_belongs_to_all_regions_in_region_list(
                           tile_grid-&gt;surface, rlp_head_wall_1));
            cond_2 = (!wall_belongs_to_all_regions_in_region_list(
                           tile_grid-&gt;surface, rlp_head_wall_2));
            cond_3 = (!wall_belongs_to_all_regions_in_region_list(
                           tile_grid-&gt;surface, rlp_head_wall_3));

            if (cond_1 || cond_2 || cond_3) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (all_outside_restricted_boundary) {
            int cond_1 = 0, cond_2 = 0, cond_3 = 0;
            cond_1 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_1);
            cond_2 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_2);
            cond_3 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_3);

            if (cond_1 || cond_2 || cond_3) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (sm_1_inside_sm_2_inside_grid_3_outside) {
            int cond_1 = 0, cond_2 = 0, cond_3 = 0;
            cond_1 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_1));
            cond_2 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_2));
            cond_3 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_3);

            if (cond_1 || cond_2 || cond_3) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (sm_1_inside_sm_2_outside_grid_3_inside) {
            int cond_1 = 0, cond_2 = 0, cond_3 = 0;
            cond_1 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_1));
            cond_2 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_2);
            cond_3 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_3));

            if (cond_1 || cond_2 || cond_3) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (sm_1_inside_sm_2_outside_grid_3_outside) {
            int cond_1 = 0, cond_2 = 0, cond_3 = 0;
            cond_1 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_1));
            cond_2 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_2);
            cond_3 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_3);

            if (cond_1 || cond_2 || cond_3) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (sm_1_outside_sm_2_inside_grid_3_outside) {
            int cond_1 = 0, cond_2 = 0, cond_3 = 0;
            cond_1 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_1);
            cond_2 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_2));
            cond_3 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_3);

            if (cond_1 || cond_2 || cond_3) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (sm_1_outside_sm_2_inside_grid_3_inside) {
            int cond_1 = 0, cond_2 = 0, cond_3 = 0;
            cond_1 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_1);
            cond_2 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_2));
            cond_3 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_3));

            if (cond_1 || cond_2 || cond_3) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (sm_1_outside_sm_2_outside_grid_3_inside) {
            int cond_1 = 0, cond_2 = 0, cond_3 = 0;
            cond_1 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_1);
            cond_2 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_2);
            cond_3 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_3));

            if (cond_1 || cond_2 || cond_3) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_1_sm_2_inside) {
            int cond_1 = 0, cond_2 = 0;
            cond_1 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_1));
            cond_2 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_2));

            if (cond_1 || cond_2) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_1_inside_sm_2_outside) {
            int cond_1 = 0, cond_2 = 0;
            cond_1 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_1));
            cond_2 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_2);

            if (cond_1 || cond_2) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_1_outside_sm_2_inside) {
            int cond_1 = 0, cond_2 = 0;
            cond_1 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_1);
            cond_2 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_2));

            if (cond_1 || cond_2) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_1_sm_2_outside) {
            int cond_1 = 0, cond_2 = 0;
            cond_1 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_1);
            cond_2 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_2);

            if (cond_1 || cond_2) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_1_grid_3_inside) {
            int cond_1 = 0, cond_2 = 0;
            cond_1 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_1));
            cond_2 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_3));

            if (cond_1 || cond_2) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_1_inside_grid_3_outside) {
            int cond_1 = 0, cond_2 = 0;
            cond_1 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_1));
            cond_2 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_3);

            if (cond_1 || cond_2) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_1_outside_grid_3_inside) {
            int cond_1 = 0, cond_2 = 0;
            cond_1 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_1);
            cond_2 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_3));

            if (cond_1 || cond_2) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_1_grid_3_outside) {
            int cond_1 = 0, cond_2 = 0;
            cond_1 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_1);
            cond_2 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_3);

            if (cond_1 || cond_2) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_2_grid_3_inside) {
            int cond_1 = 0, cond_2 = 0;
            cond_1 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_2));
            cond_2 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_3));

            if (cond_1 || cond_2) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_2_inside_grid_3_outside) {
            int cond_1 = 0, cond_2 = 0;
            cond_1 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_2));
            cond_2 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_3);

            if (cond_1 || cond_2) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_2_outside_grid_3_inside) {
            int cond_1 = 0, cond_2 = 0;
            cond_1 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_2);
            cond_2 = !(wall_belongs_to_all_regions_in_region_list(
                          tile_grid-&gt;surface, rlp_head_wall_3));

            if (cond_1 || cond_2) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_2_grid_3_outside) {
            int cond_1 = 0, cond_2 = 0;
            cond_1 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_2);
            cond_2 = wall_belongs_to_any_region_in_region_list(
                tile_grid-&gt;surface, rlp_head_obj_3);

            if (cond_1 || cond_2) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_1_inside) {
            if (!wall_belongs_to_all_regions_in_region_list(tile_grid-&gt;surface,
                                                            rlp_head_wall_1)) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_1_outside) {
            if (wall_belongs_to_any_region_in_region_list(tile_grid-&gt;surface,
                                                          rlp_head_obj_1)) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_2_inside) {
            if (!wall_belongs_to_all_regions_in_region_list(tile_grid-&gt;surface,
                                                            rlp_head_wall_2)) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_sm_2_outside) {
            if (wall_belongs_to_any_region_in_region_list(tile_grid-&gt;surface,
                                                          rlp_head_obj_2)) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_grid_3_inside) {
            if (!wall_belongs_to_all_regions_in_region_list(tile_grid-&gt;surface,
                                                            rlp_head_wall_3)) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          } else if (only_grid_3_outside) {
            if (wall_belongs_to_any_region_in_region_list(tile_grid-&gt;surface,
                                                          rlp_head_obj_3)) {
              uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
              num_attempts++;
              continue;
            }
          }

          product_grid[n_product] = tile_grid;
          product_grid_idx[n_product] = tile_idx;
          product_flag[n_product] = PRODUCT_FLAG_USE_RANDOM;

          break;
        }
      }
    }

  } /* end if (is_orientable) */

  /* Determine the location of the reaction for count purposes. */
  struct vector3 count_pos_xyz;
  if (hitpt != NULL)
    count_pos_xyz = *hitpt;
  else if (sm_reactant)
    uv2xyz(&amp;sm_reactant-&gt;s_pos, sm_reactant-&gt;grid-&gt;surface, &amp;count_pos_xyz);
  else
    count_pos_xyz = ((struct volume_molecule *)reacA)-&gt;pos;

  /* Create and place each product. */
<a name="15"></a>  struct vector3 mol_pos_tmp;
  struct subvolume *product_subvol = NULL;
  for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
<font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    struct abstract_molecule *this_product = NULL;
    struct species *const product_species = rx_players[n_product];

    /* If the product is a surface molecule, place it on the grid. */
    if (product_species-&gt;flags &amp; ON_GRID) {
      struct vector2 prod_uv_pos;

      /* Pick an appropriate position for the new molecule. */
      if (world-&gt;randomize_smol_pos) {
        switch (product_flag[n_product]) {
        case PRODUCT_FLAG_USE_REACA_UV:</b></font>
          prod_uv_pos = ((struct surface_molecule *)reacA)-&gt;s_pos;
          break;

        case PRODUCT_FLAG_USE_REACB_UV:
          prod_uv_pos = ((struct surface_molecule *)reacB)-&gt;s_pos;
          break;

        case PRODUCT_FLAG_USE_REACC_UV:
          prod_uv_pos = ((struct surface_molecule *)reacC)-&gt;s_pos;
          break;

        case PRODUCT_FLAG_USE_RANDOM:
          grid2uv_random(product_grid[n_product], product_grid_idx[n_product],
                         &amp;prod_uv_pos, world-&gt;rng);
          break;

        default:
          UNHANDLED_CASE(product_flag[n_product]);
          /*break;*/
        }
      } else
        grid2uv(product_grid[n_product], product_grid_idx[n_product],
                &amp;prod_uv_pos);

      this_product = (struct abstract_molecule *)place_sm_product(
          world, product_species, 0, product_grid[n_product],
          product_grid_idx[n_product], &amp;prod_uv_pos, product_orient[n_product],
          t, reacA-&gt;periodic_box);
    }

    /* else place the molecule in space. */
    else {
      /* Unless this is a unimolecular reaction, we will have a hitpt. */
      if (!hitpt) {
        /* If this is a unimolecular surface rxn... */
        if (reacA-&gt;properties-&gt;flags &amp; ON_GRID) {
          uv2xyz(&amp;((struct surface_molecule *)reacA)-&gt;s_pos,
                 ((struct surface_molecule *)reacA)-&gt;grid-&gt;surface,
                 &amp;mol_pos_tmp);
          product_subvol = find_subvolume(world, &amp;mol_pos_tmp, last_subvol);
        }

        /* ... else a unimolecular volume rxn. */
        else {
          mol_pos_tmp = ((struct volume_molecule *)reacA)-&gt;pos;
          product_subvol = ((struct volume_molecule *)reacA)-&gt;subvol;
        }
        hitpt = &amp;mol_pos_tmp;
      } else
        product_subvol = find_subvolume(world, hitpt, last_subvol);

      this_product = (struct abstract_molecule *)place_volume_product(
          world, product_species, 0, sm_reactant, w, product_subvol, hitpt,
          product_orient[n_product], t, reacA-&gt;periodic_box);

      if (((struct volume_molecule *)this_product)-&gt;index &lt; DISSOCIATION_MAX)
        update_dissociation_index = true;
    }

    /* Update molecule counts */
<a name="19"></a>    ++product_species-&gt;population;
    if (product_species-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED))
      count_region_from_scratch(world, this_product, NULL, 1, NULL, NULL, t, NULL);
<font color="#f62817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  }

  /* If necessary, update the dissociation index. */
  if (update_dissociation_index) {
    if (--world-&gt;dissociation_index &lt; DISSOCIATION_MIN)
      world-&gt;dissociation_index = DISSOCIATION_MAX;
  }

  /* Handle events triggered off of named reactions */
  if (rx-&gt;info[path].pathname != NULL) {
    /* No flags for reactions so we have to check regions if we have waypoints!
     * Fix to be more efficient for WORLD-only counts? */
    if (world-&gt;place_waypoints_flag)
      count_region_from_scratch(world, NULL, rx-&gt;info[path].pathname, 1,</b></font>
                                &amp;count_pos_xyz, w, t, NULL);

    /* Other magical stuff.  For now, can only trigger releases. */
    if (rx-&gt;info[path].pathname-&gt;magic != NULL) {
      if (reaction_wizardry(world, rx-&gt;info[path].pathname-&gt;magic, w,
                            &amp;count_pos_xyz, t))
        mcell_allocfailed("Failed to complete reaction triggered release after "
                          "a '%s' reaction.",
                          rx-&gt;info[path].pathname-&gt;sym-&gt;name);
    }
  }

  if (tile_nbr_head != NULL)
    delete_tile_neighbor_list(tile_nbr_head);
  if (tile_vacant_nbr_head != NULL)
    delete_tile_neighbor_list(tile_vacant_nbr_head);

  return cross_wall ? RX_FLIP : RX_A_OK;
}

/*************************************************************************
outcome_trimolecular:
  In: reaction that's occurring
      path the reaction's taking
      three molecules that are reacting (first is moving one
          and the last one is the furthest from the moving molecule or
          the one that is hit the latest)
      orientations of the molecules
      time that the reaction is occurring
      location of collision between moving molecule and the furthest target
  Out: Value based on outcome:
       RX_FLIP if the molecule goes across the membrane
       RX_DESTROY if the molecule no longer exists
       RX_A_OK if everything proceeded smoothly
       Products are created as needed.
  Note: reacA is the triggering molecule (e.g. moving)
        reacC is the target furthest from the reacA
*************************************************************************/
int outcome_trimolecular(struct volume *world, struct rxn *rx, int path,
                         struct abstract_molecule *reacA,
                         struct abstract_molecule *reacB,
<a name="18"></a>                         struct abstract_molecule *reacC, short orientA,
                         short orientB, short orientC, double t,
                         struct vector3 *hitpt, struct vector3 *loc_okay) {
<font color="#800517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  struct wall *w = NULL;
  struct volume_molecule *vm = NULL;
  struct surface_molecule *sm = NULL;
  int result;
  /* flags */
  int killA = 0, killB = 0, killC = 0;</b></font>
  int reacA_is_free = 0;
  int reacB_is_free = 0;
  int reacC_is_free = 0;
  int num_surface_reactants = 0;

  if ((reacA-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
    reacA_is_free = 1;
  } else
    num_surface_reactants++;

  if ((reacB-&gt;properties-&gt;flags &amp; NOT_FREE) == 0)
    reacB_is_free = 1;
  else
    num_surface_reactants++;

  if ((reacC-&gt;properties-&gt;flags &amp; NOT_FREE) == 0)
    reacC_is_free = 1;
  else
    num_surface_reactants++;

  if (!reacA_is_free) {
    sm = (struct surface_molecule *)reacA;
  } else if (!reacB_is_free) {
    sm = (struct surface_molecule *)reacB;
  } else if (!reacC_is_free) {
    sm = (struct surface_molecule *)reacC;
  }
  if (sm != NULL)
    w = sm-&gt;grid-&gt;surface;

  result = outcome_products_trimol_reaction_random(world, w, hitpt, t, rx, path,
                                                   reacA, reacB, reacC, orientA,
                                                   orientB, orientC);
  if (result == RX_BLOCKED)
    return RX_BLOCKED;

  rx-&gt;n_occurred++;
  rx-&gt;info[path].count++;

  /* Figure out if either of the reactants was destroyed */

  if (rx-&gt;players[0] == reacA-&gt;properties) {
    if (rx-&gt;players[1] == reacB-&gt;properties) {
      killC = (rx-&gt;players[rx-&gt;product_idx[path] + 2] == NULL);
      killB = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
      killA = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
    } else {
      killB = (rx-&gt;players[rx-&gt;product_idx[path] + 2] == NULL);
      killC = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
      killA = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
    }
  } else if (rx-&gt;players[0] == reacB-&gt;properties) {
    if (rx-&gt;players[1] == reacA-&gt;properties) {
      killC = (rx-&gt;players[rx-&gt;product_idx[path] + 2] == NULL);
      killA = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
      killB = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
    } else {
      killA = (rx-&gt;players[rx-&gt;product_idx[path] + 2] == NULL);
      killC = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
      killB = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
    }
  } else if (rx-&gt;players[0] == reacC-&gt;properties) {
    if (rx-&gt;players[1] == reacA-&gt;properties) {
      killB = (rx-&gt;players[rx-&gt;product_idx[path] + 2] == NULL);
      killA = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
      killC = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
    } else {
      killA = (rx-&gt;players[rx-&gt;product_idx[path] + 2] == NULL);
      killB = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
      killC = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
    }
<a name="11"></a>  }

  if (killC) {
<font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    vm = NULL;
    if ((reacC-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
      sm = (struct surface_molecule *)reacC;
      remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
      sm-&gt;grid-&gt;n_occupied--;
      if (sm-&gt;flags &amp; IN_SURFACE)
        sm-&gt;flags -= IN_SURFACE;

      if (sm-&gt;flags &amp; IN_SCHEDULE) {
        sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
    } else {</b></font>
      vm = (struct volume_molecule *)reacC;
      vm-&gt;subvol-&gt;mol_count--;
      if (vm-&gt;flags &amp; IN_SCHEDULE) {
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
    }

    if ((reacC-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) != 0) {
      count_region_from_scratch(world, reacC, NULL, -1, NULL, NULL, t, NULL);
    }

    reacC-&gt;properties-&gt;n_deceased++;
    double t_time = convert_iterations_to_seconds(
        world-&gt;start_iterations, world-&gt;time_unit,
        world-&gt;simulation_start_seconds, t);
    reacC-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacC-&gt;birthday;
    reacC-&gt;properties-&gt;population--;
    if (vm != NULL)
      collect_molecule(vm);
    else {
      reacC-&gt;properties = NULL;
      if ((reacC-&gt;flags &amp; IN_MASK) == 0)
        mem_put(reacC-&gt;birthplace, reacC);
    }
  }

  if (killB) {
    vm = NULL;
    if ((reacB-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
      sm = (struct surface_molecule *)reacB;
      remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
      sm-&gt;grid-&gt;n_occupied--;
      if (sm-&gt;flags &amp; IN_SURFACE)
        sm-&gt;flags -= IN_SURFACE;

      if (sm-&gt;flags &amp; IN_SCHEDULE) {
        sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
    } else {
      vm = (struct volume_molecule *)reacB;
      vm-&gt;subvol-&gt;mol_count--;
      if (vm-&gt;flags &amp; IN_SCHEDULE) {
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
    }

    if ((reacB-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) != 0) {
      count_region_from_scratch(world, reacB, NULL, -1, NULL, NULL, t, NULL);
    }

    reacB-&gt;properties-&gt;n_deceased++;
    double t_time = convert_iterations_to_seconds(
        world-&gt;start_iterations, world-&gt;time_unit,
        world-&gt;simulation_start_seconds, t);
    reacB-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacB-&gt;birthday;
    reacB-&gt;properties-&gt;population--;
    if (vm != NULL)
      collect_molecule(vm);
    else {
      reacB-&gt;properties = NULL;
      if ((reacB-&gt;flags &amp; IN_MASK) == 0)
        mem_put(reacB-&gt;birthplace, reacB);
    }
  }

  if (killA) {
    vm = NULL;
    if ((reacA-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
      sm = (struct surface_molecule *)reacA;
      remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
      sm-&gt;grid-&gt;n_occupied--;
      if (sm-&gt;flags &amp; IN_SURFACE)
        sm-&gt;flags -= IN_SURFACE;

<a name="8"></a>      if (sm-&gt;flags &amp; IN_SCHEDULE) {
        sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    } else {
      vm = (struct volume_molecule *)reacA;
      vm-&gt;subvol-&gt;mol_count--;
      if (vm-&gt;flags &amp; IN_SCHEDULE) {
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
    }
    if ((reacA-&gt;properties-&gt;flags &amp; ON_GRID) !=
        0) /* Surface molecule is OK where it is, doesn't obey COUNT_ME */
    {
      if (reacA-&gt;properties-&gt;flags &amp;
          COUNT_SOME_MASK) /* If we're ever counted, try to count us now */
      {
        count_region_from_scratch(world, reacA, NULL, -1, NULL, NULL, t, NULL);</b></font>
      }
    } else if ((reacA-&gt;flags &amp; COUNT_ME) &amp;&amp; world-&gt;place_waypoints_flag) {
      /* Subtlety: we made it up to hitpt, but our position is wherever we were
       * before that! */
<a name="7"></a>      if (hitpt == NULL || (reacB_is_free &amp;&amp; reacC_is_free))
          /* Vol-vol-vol rx should be counted at hitpt */
      {
<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        count_region_from_scratch(world, reacA, NULL, -1, hitpt, NULL, t, NULL);
      } else /* reaction involving surface or surface_molecule but we don't want
                to
                count exactly on a wall or we might count on the wrong side */
      {
        struct vector3 fake_hitpt;

        vm = (struct volume_molecule *)reacA;

        /* Halfway in between where we were and where we react should be a safe
         * away-from-wall place to remove us */
        if (loc_okay == NULL)
          loc_okay = &amp;(vm-&gt;pos);
        fake_hitpt.x = 0.5 * hitpt-&gt;x + 0.5 * loc_okay-&gt;x;
        fake_hitpt.y = 0.5 * hitpt-&gt;y + 0.5 * loc_okay-&gt;y;
        fake_hitpt.z = 0.5 * hitpt-&gt;z + 0.5 * loc_okay-&gt;z;

<a name="14"></a>        count_region_from_scratch(world, reacA, NULL, -1, &amp;fake_hitpt, NULL, t, NULL);</b></font>
      }
    }
<font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    reacA-&gt;properties-&gt;n_deceased++;
    double t_time = convert_iterations_to_seconds(
        world-&gt;start_iterations, world-&gt;time_unit,
        world-&gt;simulation_start_seconds, t);
    reacA-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacA-&gt;birthday;
    reacA-&gt;properties-&gt;population--;
    if (vm != NULL)
      collect_molecule(vm);
    else
      reacA-&gt;properties = NULL;

    return RX_DESTROY;
  }
  return result;
}</b></font>
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
