
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 14.042553191489363%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-hmac_memory.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_HMAC
3  int hmac_memory(int hash,
4                  const unsigned char *key,  unsigned long keylen,
5                  const unsigned char *in,   unsigned long inlen,
6                        unsigned char *out,  unsigned long *outlen)
7  {
8      hmac_state *hmac;
9      int         err;
10      LTC_ARGCHK(key    != NULL);
11      LTC_ARGCHK(in     != NULL);
12      LTC_ARGCHK(out    != NULL);
13      LTC_ARGCHK(outlen != NULL);
<span onclick='openModal()' class='match'>14      if ((err = hash_is_valid(hash)) != CRYPT_OK) {
15         return err;
16      }
17      if (hash_descriptor[hash].hmac_block != NULL) {
18          return hash_descriptor[hash].hmac_block(key, keylen, in, inlen, out, outlen);
19      }
</span>20      hmac = XMALLOC(sizeof(hmac_state));
21      if (hmac == NULL) {
22         return CRYPT_MEM;
23      }
24      if ((err = hmac_init(hmac, hash, key, keylen)) != CRYPT_OK) {
25         goto LBL_ERR;
26      }
27      if ((err = hmac_process(hmac, in, inlen)) != CRYPT_OK) {
28         goto LBL_ERR;
29      }
30      if ((err = hmac_done(hmac, out, outlen)) != CRYPT_OK) {
31         goto LBL_ERR;
32      }
33     err = CRYPT_OK;
34  LBL_ERR:
35  #ifdef LTC_CLEAN_STACK
36     zeromem(hmac, sizeof(hmac_state));
37  #endif
38     XFREE(hmac);
39     return err;
40  }
41  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ccm_memory.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_CCM_MODE
3  int ccm_memory(int cipher,
4      const unsigned char *key,    unsigned long keylen,
5      symmetric_key       *uskey,
6      const unsigned char *nonce,  unsigned long noncelen,
7      const unsigned char *header, unsigned long headerlen,
8            unsigned char *pt,     unsigned long ptlen,
9            unsigned char *ct,
10            unsigned char *tag,    unsigned long *taglen,
11                      int  direction)
12  {
13     unsigned char  PAD[16], ctr[16], CTRPAD[16], ptTag[16], b, *pt_real;
14     unsigned char *pt_work = NULL;
15     symmetric_key *skey;
16     int            err;
17     unsigned long  len, L, x, y, z, CTRlen;
18     if (uskey == NULL) {
19        LTC_ARGCHK(key    != NULL);
20     }
21     LTC_ARGCHK(nonce  != NULL);
22     if (headerlen > 0) {
23        LTC_ARGCHK(header != NULL);
24     }
25     LTC_ARGCHK(pt     != NULL);
26     LTC_ARGCHK(ct     != NULL);
27     LTC_ARGCHK(tag    != NULL);
28     LTC_ARGCHK(taglen != NULL);
29     pt_real = pt;
30  #ifdef LTC_FAST
31     if (16 % sizeof(LTC_FAST_TYPE)) {
32        return CRYPT_INVALID_ARG;
33     }
34  #endif
35     if ((err = cipher_is_valid(cipher)) != CRYPT_OK) {
36        return err;
37     }
38     if (cipher_descriptor[cipher].block_length != 16) {
39        return CRYPT_INVALID_CIPHER;
40     }
<span onclick='openModal()' class='match'>41     if (*taglen < 4 || *taglen > 16 || (*taglen % 2) == 1 || headerlen > 0x7fffffffu) {
42        return CRYPT_INVALID_ARG;
43     }
44     if (cipher_descriptor[cipher].accel_ccm_memory != NULL) {
45         return cipher_descriptor[cipher].accel_ccm_memory(
46             key,    keylen,
47             uskey,
48             nonce,  noncelen,
49             header, headerlen,
50             pt,     ptlen,
51             ct,
52             tag,    taglen,
53             direction);
54     }
</span>55     len = ptlen;
56     L   = 0;
57     while (len) {
58        ++L;
59        len >>= 8;
60     }
61     if (L <= 1) {
62        L = 2;
63     }
64     noncelen = (noncelen > 13) ? 13 : noncelen;
65     if ((15 - noncelen) > L) {
66        L = 15 - noncelen;
67     }
68     if (L > 8) {
69        return CRYPT_INVALID_ARG;
70     }
71     if (uskey == NULL) {
72        skey = XMALLOC(sizeof(*skey));
73        if (skey == NULL) {
74           return CRYPT_MEM;
75        }
76        if ((err = cipher_descriptor[cipher].setup(key, keylen, 0, skey)) != CRYPT_OK) {
77           XFREE(skey);
78           return err;
79        }
80     } else {
81        skey = uskey;
82     }
83     if (direction == CCM_DECRYPT && ptlen > 0) {
84        pt_work = XMALLOC(ptlen);
85        if (pt_work == NULL) {
86           goto error;
87        }
88        pt = pt_work;
89     }
90     x = 0;
91     PAD[x++] = (unsigned char)(((headerlen > 0) ? (1<<6) : 0) |
92              (((*taglen - 2)>>1)<<3)        |
93              (L-1));
94     for (y = 0; y < 15 - L; y++) {
95         PAD[x++] = nonce[y];
96     }
97     len = ptlen;
98     for (y = L; y < 4; y++) {
99         len <<= 8;
100     }
101     for (y = 0; L > 4 && (L-y)>4; y++) {
102         PAD[x++] = 0;
103     }
104     for (; y < L; y++) {
105         PAD[x++] = (unsigned char)((len >> 24) & 255);
106         len <<= 8;
107     }
108     if ((err = cipher_descriptor[cipher].ecb_encrypt(PAD, PAD, skey)) != CRYPT_OK) {
109         goto error;
110     }
111     if (headerlen > 0) {
112        x = 0;
113        if (headerlen < ((1UL<<16) - (1UL<<8))) {
114           PAD[x++] ^= (headerlen>>8) & 255;
115           PAD[x++] ^= headerlen & 255;
116        } else {
117           PAD[x++] ^= 0xFF;
118           PAD[x++] ^= 0xFE;
119           PAD[x++] ^= (headerlen>>24) & 255;
120           PAD[x++] ^= (headerlen>>16) & 255;
121           PAD[x++] ^= (headerlen>>8) & 255;
122           PAD[x++] ^= headerlen & 255;
123        }
124        for (y = 0; y < headerlen; y++) {
125            if (x == 16) {
126               if ((err = cipher_descriptor[cipher].ecb_encrypt(PAD, PAD, skey)) != CRYPT_OK) {
127                  goto error;
128               }
129               x = 0;
130            }
131            PAD[x++] ^= header[y];
132        }
133        if ((err = cipher_descriptor[cipher].ecb_encrypt(PAD, PAD, skey)) != CRYPT_OK) {
134           goto error;
135        }
136     }
137     x = 0;
138     ctr[x++] = (unsigned char)L-1;
139     for (y = 0; y < (16 - (L+1)); ++y) {
140        ctr[x++] = nonce[y];
141     }
142     while (x < 16) {
143        ctr[x++] = 0;
144     }
145     x      = 0;
146     CTRlen = 16;
147     if (ptlen > 0) {
148        y = 0;
149  #ifdef LTC_FAST
150        if (ptlen & ~15)  {
151            if (direction == CCM_ENCRYPT) {
152               for (; y < (ptlen & ~15); y += 16) {
153                  for (z = 15; z > 15-L; z--) {
154                      ctr[z] = (ctr[z] + 1) & 255;
155                      if (ctr[z]) break;
156                  }
157                  if ((err = cipher_descriptor[cipher].ecb_encrypt(ctr, CTRPAD, skey)) != CRYPT_OK) {
158                     goto error;
159                  }
160                  for (z = 0; z < 16; z += sizeof(LTC_FAST_TYPE)) {
161                      *(LTC_FAST_TYPE_PTR_CAST(&PAD[z]))  ^= *(LTC_FAST_TYPE_PTR_CAST(&pt[y+z]));
162                      *(LTC_FAST_TYPE_PTR_CAST(&ct[y+z])) = *(LTC_FAST_TYPE_PTR_CAST(&pt[y+z])) ^ *(LTC_FAST_TYPE_PTR_CAST(&CTRPAD[z]));
163                  }
164                  if ((err = cipher_descriptor[cipher].ecb_encrypt(PAD, PAD, skey)) != CRYPT_OK) {
165                     goto error;
166                  }
167               }
168            } else { &bsol;* direction == CCM_DECRYPT */
169               for (; y < (ptlen & ~15); y += 16) {
170                  for (z = 15; z > 15-L; z--) {
171                      ctr[z] = (ctr[z] + 1) & 255;
172                      if (ctr[z]) break;
173                  }
174                  if ((err = cipher_descriptor[cipher].ecb_encrypt(ctr, CTRPAD, skey)) != CRYPT_OK) {
175                     goto error;
176                  }
177                  for (z = 0; z < 16; z += sizeof(LTC_FAST_TYPE)) {
178                      *(LTC_FAST_TYPE_PTR_CAST(&pt[y+z])) = *(LTC_FAST_TYPE_PTR_CAST(&ct[y+z])) ^ *(LTC_FAST_TYPE_PTR_CAST(&CTRPAD[z]));
179                      *(LTC_FAST_TYPE_PTR_CAST(&PAD[z]))  ^= *(LTC_FAST_TYPE_PTR_CAST(&pt[y+z]));
180                  }
181                  if ((err = cipher_descriptor[cipher].ecb_encrypt(PAD, PAD, skey)) != CRYPT_OK) {
182                     goto error;
183                  }
184               }
185            }
186        }
187  #endif
188        for (; y < ptlen; y++) {
189            if (CTRlen == 16) {
190               for (z = 15; z > 15-L; z--) {
191                   ctr[z] = (ctr[z] + 1) & 255;
192                   if (ctr[z]) break;
193               }
194               if ((err = cipher_descriptor[cipher].ecb_encrypt(ctr, CTRPAD, skey)) != CRYPT_OK) {
195                  goto error;
196               }
197               CTRlen = 0;
198            }
199            if (direction == CCM_ENCRYPT) {
200               b     = pt[y];
201               ct[y] = b ^ CTRPAD[CTRlen++];
202            } else {
203               b     = ct[y] ^ CTRPAD[CTRlen++];
204               pt[y] = b;
205            }
206            if (x == 16) {
207               if ((err = cipher_descriptor[cipher].ecb_encrypt(PAD, PAD, skey)) != CRYPT_OK) {
208                  goto error;
209               }
210               x = 0;
211            }
212            PAD[x++] ^= b;
213        }
214        if (x != 0) {
215           if ((err = cipher_descriptor[cipher].ecb_encrypt(PAD, PAD, skey)) != CRYPT_OK) {
216              goto error;
217           }
218        }
219     }
220     for (y = 15; y > 15 - L; y--) {
221        ctr[y] = 0x00;
222     }
223     if ((err = cipher_descriptor[cipher].ecb_encrypt(ctr, CTRPAD, skey)) != CRYPT_OK) {
224        goto error;
225     }
226     if (skey != uskey) {
227        cipher_descriptor[cipher].done(skey);
228  #ifdef LTC_CLEAN_STACK
229        zeromem(skey,   sizeof(*skey));
230  #endif
231     }
232     if (direction == CCM_ENCRYPT) {
233        for (x = 0; x < 16 && x < *taglen; x++) {
234            tag[x] = PAD[x] ^ CTRPAD[x];
235        }
236        *taglen = x;
237     } else { &bsol;* direction == CCM_DECRYPT */
238        for (x = 0; x < 16 && x < *taglen; x++) {
239           ptTag[x] = tag[x] ^ CTRPAD[x];
240        }
241        *taglen = x;
242        err = XMEM_NEQ(ptTag, PAD, *taglen);
243        if (ptlen > 0) {
244           copy_or_zeromem(pt, pt_real, ptlen, err);
245        }
246     }
247  #ifdef LTC_CLEAN_STACK
248     zeromem(PAD,    sizeof(PAD));
249     zeromem(CTRPAD, sizeof(CTRPAD));
250     if (pt_work != NULL) {
251       zeromem(pt_work, ptlen);
252     }
253  #endif
254  error:
255     if (pt_work) {
256        XFREE(pt_work);
257     }
258     if (skey != uskey) {
259        XFREE(skey);
260     }
261     return err;
262  }
263  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-hmac_memory.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ccm_memory.c</div>
                </div>
                <div class="column column_space"><pre><code>14      if ((err = hash_is_valid(hash)) != CRYPT_OK) {
15         return err;
16      }
17      if (hash_descriptor[hash].hmac_block != NULL) {
18          return hash_descriptor[hash].hmac_block(key, keylen, in, inlen, out, outlen);
19      }
</pre></code></div>
                <div class="column column_space"><pre><code>41     if (*taglen < 4 || *taglen > 16 || (*taglen % 2) == 1 || headerlen > 0x7fffffffu) {
42        return CRYPT_INVALID_ARG;
43     }
44     if (cipher_descriptor[cipher].accel_ccm_memory != NULL) {
45         return cipher_descriptor[cipher].accel_ccm_memory(
46             key,    keylen,
47             uskey,
48             nonce,  noncelen,
49             header, headerlen,
50             pt,     ptlen,
51             ct,
52             tag,    taglen,
53             direction);
54     }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    