<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for parser.h &amp; decBasic.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for parser.h &amp; decBasic.c
      </h3>
<h1 align="center">
        2.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>parser.h (44.594593%)<th>decBasic.c (1.3100437%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(94-111)<td><a href="#" name="0">(1187-1215)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(67-81)<td><a href="#" name="1">(3120-3150)</a><td align="center"><font color="#d40000">15</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>parser.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef YY_YY_SRC_PARSER_H_INCLUDED
2 # define YY_YY_SRC_PARSER_H_INCLUDED
3 #ifndef YYDEBUG
4 # define YYDEBUG 0
5 #endif
6 #if YYDEBUG
7 extern int yydebug;
8 #endif
9 #line 11 "src/parser.y" 
10 #include "locfile.h"
11 struct lexer_param;
12 #define YYLTYPE location
13 #define YYLLOC_DEFAULT(Loc, Rhs, N)             \
14   do {                                          \
15     if (N) {                                    \
16       (Loc).start = YYRHSLOC(Rhs, 1).start;     \
17       (Loc).end = YYRHSLOC(Rhs, N).end;         \
18     } else {                                    \
19       (Loc).start = YYRHSLOC(Rhs, 0).end;       \
20       (Loc).end = YYRHSLOC(Rhs, 0).end;         \
21     }                                           \
22   } while (0)
23 #line 61 "src/parser.h" 
24 #ifndef YYTOKENTYPE
25 <a name="1"></a># define YYTOKENTYPE
26   enum yytokentype
27   {
28 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    INVALID_CHARACTER = 258,
29     IDENT = 259,
30     FIELD = 260,
31     LITERAL = 261,
32     FORMAT = 262,
33     REC = 263,
34     SETMOD = 264,
35     EQ = 265,
36     NEQ = 266,
37     DEFINEDOR = 267,
38     AS = 268,
39     DEF = 269,
40     MODULE = 270,
41     IMPORT = 271,
42     INCLUDE = 272,</b></font>
43     IF = 273,
44     THEN = 274,
45     ELSE = 275,
46     ELSE_IF = 276,
47     REDUCE = 277,
48     FOREACH = 278,
49     END = 279,
50     AND = 280,
51     OR = 281,
52 <a name="0"></a>    TRY = 282,
53     CATCH = 283,
54     LABEL = 284,
55 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    BREAK = 285,
56     LOC = 286,
57     SETPIPE = 287,
58     SETPLUS = 288,
59     SETMINUS = 289,
60     SETMULT = 290,
61     SETDIV = 291,
62     SETDEFINEDOR = 292,
63     LESSEQ = 293,
64     GREATEREQ = 294,
65     ALTERNATION = 295,
66     QQSTRING_START = 296,
67     QQSTRING_TEXT = 297,
68     QQSTRING_INTERP_START = 298,
69     QQSTRING_INTERP_END = 299,
70     QQSTRING_END = 300,
71     FUNCDEF = 301,
72     NONOPT = 302</b></font>
73   };
74 #endif
75 #define INVALID_CHARACTER 258
76 #define IDENT 259
77 #define FIELD 260
78 #define LITERAL 261
79 #define FORMAT 262
80 #define REC 263
81 #define SETMOD 264
82 #define EQ 265
83 #define NEQ 266
84 #define DEFINEDOR 267
85 #define AS 268
86 #define DEF 269
87 #define MODULE 270
88 #define IMPORT 271
89 #define INCLUDE 272
90 #define IF 273
91 #define THEN 274
92 #define ELSE 275
93 #define ELSE_IF 276
94 #define REDUCE 277
95 #define FOREACH 278
96 #define END 279
97 #define AND 280
98 #define OR 281
99 #define TRY 282
100 #define CATCH 283
101 #define LABEL 284
102 #define BREAK 285
103 #define LOC 286
104 #define SETPIPE 287
105 #define SETPLUS 288
106 #define SETMINUS 289
107 #define SETMULT 290
108 #define SETDIV 291
109 #define SETDEFINEDOR 292
110 #define LESSEQ 293
111 #define GREATEREQ 294
112 #define ALTERNATION 295
113 #define QQSTRING_START 296
114 #define QQSTRING_TEXT 297
115 #define QQSTRING_INTERP_START 298
116 #define QQSTRING_INTERP_END 299
117 #define QQSTRING_END 300
118 #define FUNCDEF 301
119 #define NONOPT 302
120 #if ! defined YYSTYPE &amp;&amp; ! defined YYSTYPE_IS_DECLARED
121 union YYSTYPE
122 {
123 #line 31 "src/parser.y" 
124   jv literal;
125   block blk;
126 #line 172 "src/parser.h" };
127 typedef union YYSTYPE YYSTYPE;
128 # define YYSTYPE_IS_TRIVIAL 1
129 # define YYSTYPE_IS_DECLARED 1
130 #endif
131 #if ! defined YYLTYPE &amp;&amp; ! defined YYLTYPE_IS_DECLARED
132 typedef struct YYLTYPE YYLTYPE;
133 struct YYLTYPE
134 {
135   int first_line;
136   int first_column;
137   int last_line;
138   int last_column;
139 };
140 # define YYLTYPE_IS_DECLARED 1
141 # define YYLTYPE_IS_TRIVIAL 1
142 #endif
143 int yyparse (block* answer, int* errors, struct locfile* locations, struct lexer_param* lexer_param_ptr);
#endif </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>decBasic.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #if !defined(QUAD)
2   #error decBasic.c must be included after decCommon.c
3 #endif
4 #if SINGLE
5   #error Routines in decBasic.c are for decDouble and decQuad only
6 #endif
7 #define DIVIDE      0x80000000     #define REMAINDER   0x40000000     #define DIVIDEINT   0x20000000     #define REMNEAR     0x10000000     
8 static decFloat *decDivide(decFloat *, const decFloat *,
9                               const decFloat *, decContext *, uInt);
10 static decFloat *decCanonical(decFloat *, const decFloat *);
11 static void      decFiniteMultiply(bcdnum *, uByte *, const decFloat *,
12                               const decFloat *);
13 static decFloat *decInfinity(decFloat *, const decFloat *);
14 static decFloat *decInvalid(decFloat *, decContext *);
15 static decFloat *decNaNs(decFloat *, const decFloat *, const decFloat *,
16                               decContext *);
17 static Int       decNumCompare(const decFloat *, const decFloat *, Flag);
18 static decFloat *decToIntegral(decFloat *, const decFloat *, decContext *,
19                               enum rounding, Flag);
20 static uInt      decToInt32(const decFloat *, decContext *, enum rounding,
21                               Flag, Flag);
22 static decFloat * decCanonical(decFloat *result, const decFloat *df) {
23   uInt encode, precode, dpd;         uInt inword, uoff, canon;          Int  n;                            if (df!=result) *result=*df;       if (DFISSPECIAL(result)) {
24     if (DFISINF(result)) return decInfinity(result, df);     DFWORD(result, 0)&amp;=~ECONNANMASK;        if (DFISCCZERO(df)) return result;      }
25   {   #if DOUBLE
26     uInt sourhi=DFWORD(df, 0);
27     uInt sourlo=DFWORD(df, 1);
28     if (CANONDPDOFF(sourhi, 8)
29      &amp;&amp; CANONDPDTWO(sourhi, sourlo, 30)
30      &amp;&amp; CANONDPDOFF(sourlo, 20)
31      &amp;&amp; CANONDPDOFF(sourlo, 10)
32      &amp;&amp; CANONDPDOFF(sourlo, 0)) return result;
33   #elif QUAD
34     uInt sourhi=DFWORD(df, 0);
35     uInt sourmh=DFWORD(df, 1);
36     uInt sourml=DFWORD(df, 2);
37     uInt sourlo=DFWORD(df, 3);
38     if (CANONDPDOFF(sourhi, 4)
39      &amp;&amp; CANONDPDTWO(sourhi, sourmh, 26)
40      &amp;&amp; CANONDPDOFF(sourmh, 16)
41      &amp;&amp; CANONDPDOFF(sourmh, 6)
42      &amp;&amp; CANONDPDTWO(sourmh, sourml, 28)
43      &amp;&amp; CANONDPDOFF(sourml, 18)
44      &amp;&amp; CANONDPDOFF(sourml, 8)
45      &amp;&amp; CANONDPDTWO(sourml, sourlo, 30)
46      &amp;&amp; CANONDPDOFF(sourlo, 20)
47      &amp;&amp; CANONDPDOFF(sourlo, 10)
48      &amp;&amp; CANONDPDOFF(sourlo, 0)) return result;
49   #endif
50   } 
51   inword=DECWORDS-1;                 uoff=0;                            encode=DFWORD(result, inword);
52   for (n=DECLETS-1; n&gt;=0; n--) {       dpd=encode&gt;&gt;uoff;
53     uoff+=10;
54     if (uoff&gt;32) {                       inword--;
55       encode=DFWORD(result, inword);
56       uoff-=32;
57       dpd|=encode&lt;&lt;(10-uoff);            }
58     dpd&amp;=0x3ff;                        if (dpd&lt;0x16e) continue;           canon=BIN2DPD[DPD2BIN[dpd]];       if (canon==dpd) continue;          if (uoff&gt;=10) {                      encode&amp;=~(0x3ff&lt;&lt;(uoff-10));       encode|=canon&lt;&lt;(uoff-10);          DFWORD(result, inword)=encode;          continue;
59       }
60     precode=DFWORD(result, inword+1);       precode&amp;=0xffffffff&gt;&gt;(10-uoff);         DFWORD(result, inword+1)=precode|(canon&lt;&lt;(32-(10-uoff)));
61     encode&amp;=0xffffffff&lt;&lt;uoff;               encode|=canon&gt;&gt;(10-uoff);               DFWORD(result, inword)=encode;          }   return result;
62   } 
63 #define DIVCOUNT  0                #define DIVBASE   ((uInt)BILLION)  #define DIVOPLEN  DECPMAX9         #define DIVACCLEN (DIVOPLEN*3)     static decFloat * decDivide(decFloat *result, const decFloat *dfl,
64                             const decFloat *dfr, decContext *set, uInt op) {
65   decFloat quotient;                 bcdnum num;                        uInt   acc[DIVACCLEN];             uInt   div[DIVOPLEN];              uInt   quo[DIVOPLEN+1];            uByte  bcdacc[(DIVOPLEN+1)*9+2];   uInt   *msua, *msud, *msuq;        Int    divunits, accunits;         Int    quodigits;                  uInt   *lsua, *lsuq;               Int    length, multiplier;         uInt   carry, sign;                uInt   *ua, *ud, *uq;              uByte  *ub;                        uInt   uiwork;                     uInt   divtop;                     #if DIVCOUNT
66   static uInt maxcount=0;            uInt   divcount=0;                 #endif
67   num.sign=(DFWORD(dfl, 0)^DFWORD(dfr, 0)) &amp; DECFLOAT_Sign;
68   if (DFISSPECIAL(dfl) || DFISSPECIAL(dfr)) {     if (DFISNAN(dfl) || DFISNAN(dfr)) return decNaNs(result, dfl, dfr, set);
69     if (DFISINF(dfl)) {
70       if (DFISINF(dfr)) return decInvalid(result, set);       if (op&amp;(REMAINDER|REMNEAR)) return decInvalid(result, set);       DFWORD(result, 0)=num.sign;
71       return decInfinity(result, result);
72       }
73     if (op&amp;(REMAINDER|REMNEAR)) return decCanonical(result, dfl);
74     decFloatZero(result);
75     if (op==DIVIDEINT) DFWORD(result, 0)|=num.sign;      else DFWORD(result, 0)=num.sign;            return result;
76     }
77   if (DFISZERO(dfr)) {                           if (DFISZERO(dfl)) {                           decFloatZero(result);
78       DFWORD(result, 0)=DECFLOAT_qNaN;
79       set-&gt;status|=DEC_Division_undefined;
80       return result;
81       }
82     if (op&amp;(REMAINDER|REMNEAR)) return decInvalid(result, set);     set-&gt;status|=DEC_Division_by_zero;
83     DFWORD(result, 0)=num.sign;
84     return decInfinity(result, result);          }
85   num.exponent=GETEXPUN(dfl)-GETEXPUN(dfr);    if (DFISZERO(dfl)) {                           if (op&amp;DIVIDEINT) {
86       decFloatZero(result);
87       DFWORD(result, 0)|=num.sign;                 return result;
88       }
89     if (!(op&amp;DIVIDE)) {                            num.exponent=MINI(GETEXPUN(dfl), GETEXPUN(dfr));
90       num.sign=DFWORD(dfl, 0)&amp;DECFLOAT_Sign;
91       }
92     bcdacc[0]=0;
93     num.msd=bcdacc;                              num.lsd=bcdacc;                              return decFinalize(result, &amp;num, set);       } 
94   GETCOEFFBILL(dfl, acc+DIVACCLEN-DIVOPLEN);
95   GETCOEFFBILL(dfr, div);
96   acc[0]=0;
97   acc[1]=0;
98   acc[2]=0;
99   acc[3]=0;
100   #if DOUBLE
101     #if DIVOPLEN!=2
102       #error Unexpected Double DIVOPLEN
103     #endif
104   #elif QUAD
105   acc[4]=0;
106   acc[5]=0;
107   acc[6]=0;
108   acc[7]=0;
109     #if DIVOPLEN!=4
110       #error Unexpected Quad DIVOPLEN
111     #endif
112   #endif
113   msua=acc+DIVACCLEN-1;         msuq=quo+DIVOPLEN;
114   for (msud=div+DIVOPLEN-1; *msud==0;) msud--;
115   divunits=(Int)(msud-div+1);   lsua=msua-divunits+1;         lsuq=msuq;                  
116   divtop=*msud&lt;&lt;2;
117   if (divunits&gt;1) {
118     uInt *um=msud-1;
119     uInt d=*um;
120     if (d&gt;=750000000) {divtop+=3; d-=750000000;}
121      else if (d&gt;=500000000) {divtop+=2; d-=500000000;}
122      else if (d&gt;=250000000) {divtop++; d-=250000000;}
123     if (d) divtop++;
124      else for (um--; um&gt;=div; um--) if (*um) {
125       divtop++;
126       break;
127       }
128     } 
129   #if DECTRACE
130   {Int i;
131   printf("----- div=");
132   for (i=divunits-1; i&gt;=0; i--) printf("%09ld ", (LI)div[i]);
133   printf("\n");}
134   #endif
135   quodigits=0;                  for (;; lsua--) {               #if DECCHECK
136     if (lsua&lt;acc) {
137       printf("Acc underrun...\n");
138       break;
139       }
140     #endif
141     #if DECTRACE
142     printf("Outer: quodigits=%ld acc=", (LI)quodigits);
143     for (ua=msua; ua&gt;=lsua; ua--) printf("%09ld ", (LI)*ua);
144     printf("\n");
145     #endif
146     *lsuq=0;                      for (;;) {                      for (; *msua==0 &amp;&amp; msua&gt;=lsua;) msua--;
147       accunits=(Int)(msua-lsua+1);                      if (accunits&lt;divunits) {
148         if (accunits==0) msua++;                          break;
149         }
150       if (accunits==divunits) {
151         for (ud=msud, ua=msua; ud&gt;div; ud--, ua--) if (*ud!=*ua) break;
152         if (*ud&gt;*ua) break;                               if (*ud==*ua) {                                     *lsuq+=1;                                         msua=lsua;                                        *msua=0;                                          break;
153           }
154         #define DIVLO 1000000U
155         #define DIVHI (DIVBASE/DIVLO)
156         #if DECUSE64
157           if (divunits&gt;1) {
158             uLong mul=(uLong)*msua * DIVBASE + *(msua-1);
159             uLong div=(uLong)*msud * DIVBASE + *(msud-1);
160             #if QUAD
161             if (divunits&gt;2) div++;
162             #endif
163             mul/=div;
164             multiplier=(Int)mul;
165             }
166            else multiplier=*msua/(*msud);
167         #else
168           if (divunits&gt;1 &amp;&amp; *msua&lt;DIVLO &amp;&amp; *msud&lt;DIVLO) {
169             multiplier=(*msua*DIVHI + *(msua-1)/DIVLO)
170                       /(*msud*DIVHI + *(msud-1)/DIVLO +1);
171             }
172            else multiplier=(*msua&lt;&lt;2)/divtop;
173         #endif
174         }
175        else {                                             #if DECUSE64
176           uLong mul;
177           if (divunits&gt;1 &amp;&amp; *msua&lt;DIVLO &amp;&amp; *msud&lt;DIVLO) {
178             mul=((uLong)*msua * DIVHI * DIVBASE) + *(msua-1) * DIVHI
179                + *(msua-2)/DIVLO;
180             mul/=(*msud*DIVHI + *(msud-1)/DIVLO +1);
181             }
182            else if (divunits==1) {
183             mul=(uLong)*msua * DIVBASE + *(msua-1);
184             mul/=*msud;                   }
185            else {
186             mul=(uLong)(*msua) * (uInt)(DIVBASE&lt;&lt;2)
187                 + (*(msua-1)&lt;&lt;2);
188             mul/=divtop;                  }
189           multiplier=(Int)mul;
190         #else
191           multiplier=*msua * ((DIVBASE&lt;&lt;2)/divtop);
192         #endif
193         }
194       if (multiplier==0) multiplier=1;                  *lsuq+=multiplier;
195       #if DIVCOUNT
196       divcount++;
197       #endif
198       #define DIVMAGIC  2305843009U                     #define DIVSHIFTA 29
199       #define DIVSHIFTB 32
200       carry=0;
201       for (ud=div, ua=lsua; ud&lt;=msud; ud++, ua++) {
202         uInt lo, hop;
203         #if DECUSE64
204           uLong sub=(uLong)multiplier*(*ud)+carry;
205           if (sub&lt;DIVBASE) {
206             carry=0;
207             lo=(uInt)sub;
208             }
209            else {
210             hop=(uInt)(sub&gt;&gt;DIVSHIFTA);
211             carry=(uInt)(((uLong)hop*DIVMAGIC)&gt;&gt;DIVSHIFTB);
212             lo=(uInt)sub;
213             lo-=carry*DIVBASE;                                if (lo&gt;=DIVBASE) {
214               lo-=DIVBASE;                                      carry++;
215               }
216             }
217         #else           uInt hi;
218           LONGMUL32HI(hi, *ud, multiplier);                 lo=multiplier*(*ud);                              lo+=carry;                                        carry=hi+(lo&lt;carry);                              if (carry || lo&gt;=DIVBASE) {                         hop=(carry&lt;&lt;3)+(lo&gt;&gt;DIVSHIFTA);                   LONGMUL32HI(carry, hop, DIVMAGIC);                lo-=(carry*DIVBASE);
219             if (lo&gt;=DIVBASE) {
220               lo-=DIVBASE;
221               carry++;
222               }
223             }
224         #endif
225         if (lo&gt;*ua) {                        *ua+=DIVBASE;
226           carry++;
227           }
228         *ua-=lo;
229         }       if (carry) *ua-=carry;             } 
230     #if DECTRACE
231     if (*lsuq || quodigits) printf("*lsuq=%09ld\n", (LI)*lsuq);
232     #endif
233     if (quodigits) {
234       quodigits+=9;                      lsuq--;
235       if (quodigits&gt;DECPMAX+1) break;         }
236      else if (*lsuq) {                   const uInt *pow;
237       for (pow=DECPOWERS; *lsuq&gt;=*pow; pow++) quodigits++;
238       lsuq--;
239       }
240     if (*msua!=0) continue;            if (lsua&gt;acc+DIVACCLEN-DIVOPLEN) continue;
241     for (; msua&gt;lsua &amp;&amp; *msua==0;) msua--;
242     if (*msua==0 &amp;&amp; msua==lsua) break;
243     } 
244   lsuq++;                            if (*msua) *lsuq|=1;             
245   #if DECTRACE
246   printf("DivQuo:");
247   for (uq=msuq; uq&gt;=lsuq; uq--) printf(" %09ld", (LI)*uq);
248   printf("\n");
249   #endif
250   for (uq=msuq, ub=bcdacc+1; uq&gt;=lsuq; uq--, ub+=9) {
251     uInt top, mid, rem;                     if (*uq==0) {                             UBFROMUI(ub, 0);                        UBFROMUI(ub+4, 0);                      *(ub+8)=0;                              continue;
252       }
253     #define divsplit9 1000000               #define divsplit6 1000                  top=*uq/divsplit9;
254     rem=*uq%divsplit9;
255     mid=rem/divsplit6;
256     rem=rem%divsplit6;
257     UBFROMUI(ub,   UBTOUI(&amp;BIN2BCD8[top*4]));
258     UBFROMUI(ub+3, UBTOUI(&amp;BIN2BCD8[mid*4]));
259     UBFROMUI(ub+6, UBTOUI(&amp;BIN2BCD8[rem*4]));
260     }   ub--;                                 
261   num.msd=bcdacc+1+(msuq-lsuq+1)*9-quodigits;
262   num.lsd=ub;
263   if (lsua&lt;acc+DIVACCLEN-DIVOPLEN) {        num.exponent-=(Int)((acc+DIVACCLEN-DIVOPLEN-lsua)*9);
264     if (*msua==0) {
265       for (; *ub==0;) ub--;                   num.exponent+=(Int)(num.lsd-ub);        num.lsd=ub;
266       }
267     } 
268   #if DIVCOUNT
269   if (divcount&gt;maxcount) {                  maxcount=divcount;
270     printf("DivNewMaxCount: %ld\n", (LI)maxcount);
271     }
272   #endif
273   if (op&amp;DIVIDE) return decFinalize(result, &amp;num, set); 
274   length=(Int)(num.lsd-num.msd+1);
275   if (length+num.exponent&gt;DECPMAX) {     decFloatZero(result);
276     DFWORD(result, 0)=DECFLOAT_qNaN;
277     set-&gt;status|=DEC_Division_impossible;
278     return result;
279     }
280   if (num.exponent&gt;=0) {               for (ub=num.lsd+1; ub&lt;=num.lsd+num.exponent; ub++) *ub=0;
281     num.lsd+=num.exponent;
282     }
283    else {                              Int drop=-num.exponent;
284     if (!(op&amp;REMNEAR)) {                 num.lsd-=drop;
285       if (num.lsd&lt;num.msd) {               num.lsd=num.msd;                   *num.lsd=0;                        }
286       }
287      else {                              uByte *roundat;                    uByte reround;                     *(num.msd-1)=0;                    if (drop&lt;length) roundat=num.lsd-drop+1;
288        else if (drop==length) roundat=num.msd;
289        else roundat=num.msd-1;           reround=*roundat;
290       for (ub=roundat+1; ub&lt;=num.lsd; ub++) {
291         if (*ub!=0) {
292           reround=DECSTICKYTAB[reround];
293           break;
294           }
295         }       if (roundat&gt;num.msd) num.lsd=roundat-1;
296        else {
297         num.msd--;                                   num.lsd=num.msd;                             }
298       if (reround!=0) {                              uInt bump=0;
299         if (reround&gt;5) bump=1;                        else if (reround==5)                          bump=*(num.lsd) &amp; 0x01;                    if (bump!=0) {                                 ub=num.lsd;
300           for (; UBTOUI(ub-3)==0x09090909; ub-=4) UBFROMUI(ub-3, 0);
301           for (; *ub==9; ub--) *ub=0;                  *ub+=1;
302           if (ub&lt;num.msd) num.msd--;                   }         }       }     }   num.exponent=0;                            
303   if (op&amp;DIVIDEINT) return decFinalize(result, &amp;num, set); 
304   decFinalize(&amp;quotient, &amp;num, set);           DFWORD(&amp;quotient, 0)^=DECFLOAT_Sign;         sign=DFWORD(dfl, 0);                         decFloatFMA(result, &amp;quotient, dfr, dfl, set);
305   if (!DFISZERO(result)) return result;
306   DFWORD(&amp;quotient, 0)=sign;                   return decFloatCopySign(result, result, &amp;quotient);
307   } 
308 #define MULTBASE  ((uInt)BILLION)  #define MULOPLEN  DECPMAX9         #define MULACCLEN (MULOPLEN*2)              #define LEADZEROS (MULACCLEN*9 - DECPMAX*2) 
309 #if DECEMAXD&gt;9
310   #error Exponent may overflow when doubled for Multiply
311 #endif
312 #if MULACCLEN!=(MULACCLEN/4)*4
313   #error MULACCLEN is not a multiple of 4
314 #endif
315 static void decFiniteMultiply(bcdnum *num, uByte *bcdacc,
316                               const decFloat *dfl, const decFloat *dfr) {
317   uInt   bufl[MULOPLEN];             uInt   bufr[MULOPLEN];             uInt   *ui, *uj;                   uByte  *ub;                        uInt   uiwork;                   
318   #if DECUSE64
319   uLong  accl[MULACCLEN];            uLong  *pl;                        uInt   acc[MULACCLEN];             #else
320   uInt   acc[MULACCLEN*2];           #endif
321   uInt   *pa;                      
322   num-&gt;sign=(DFWORD(dfl, 0)^DFWORD(dfr, 0)) &amp; DECFLOAT_Sign;
323   num-&gt;exponent=GETEXPUN(dfl)+GETEXPUN(dfr); 
324   GETCOEFFBILL(dfl, bufl);
325   GETCOEFFBILL(dfr, bufr);
326   #if DECTRACE &amp;&amp; 0
327     printf("CoeffbL:");
328     for (ui=bufl+MULOPLEN-1; ui&gt;=bufl; ui--) printf(" %08lx", (LI)*ui);
329     printf("\n");
330     printf("CoeffbR:");
331     for (uj=bufr+MULOPLEN-1; uj&gt;=bufr; uj--) printf(" %08lx", (LI)*uj);
332     printf("\n");
333   #endif
334 #if DECUSE64
335   #if MULACCLEN==4
336     accl[0]=0; accl[1]=0; accl[2]=0; accl[3]=0;
337   #else                                          for (pl=accl; pl&lt;accl+MULACCLEN; pl+=4) {
338       *pl=0; *(pl+1)=0; *(pl+2)=0; *(pl+3)=0;      }   #endif
339   for (ui=bufr; ui&lt;bufr+MULOPLEN; ui++) {     if (*ui==0) continue;                     pl=accl+(ui-bufr);                        for (uj=bufl; uj&lt;bufl+MULOPLEN; uj++, pl++) {       *pl+=((uLong)*ui)*(*uj);
340       }     } 
341   #define MULMAGIC 2305843009U            #if DOUBLE
342     #define MULSHIFTA 29
343     #define MULSHIFTB 32
344   #elif QUAD
345     #define MULSHIFTA 30
346     #define MULSHIFTB 31
347   #else
348     #error Unexpected type
349   #endif
350   #if DECTRACE
351   printf("MulAccl:");
352   for (pl=accl+MULACCLEN-1; pl&gt;=accl; pl--)
353     printf(" %08lx:%08lx", (LI)(*pl&gt;&gt;32), (LI)(*pl&amp;0xffffffff));
354   printf("\n");
355   #endif
356   for (pl=accl, pa=acc; pl&lt;accl+MULACCLEN; pl++, pa++) {     uInt lo, hop;                           uInt est;                               if (*pl&gt;=MULTBASE) {
357       hop=(uInt)(*pl&gt;&gt;MULSHIFTA);
358       est=(uInt)(((uLong)hop*MULMAGIC)&gt;&gt;MULSHIFTB);
359       lo=(uInt)(*pl-((uLong)est*MULTBASE));        if (lo&gt;=MULTBASE) {
360         lo-=MULTBASE;                           est++;
361         #if QUAD
362         if (lo&gt;=MULTBASE) {
363           lo-=MULTBASE;
364           est++;
365           }
366         #endif
367         }
368       *pa=lo;
369       *(pl+1)+=est;
370       }      else {                                   *pa=(uInt)*pl;                          }
371     } 
372 #else    for (pa=acc;; pa+=4) {                         *pa=0; *(pa+1)=0; *(pa+2)=0; *(pa+3)=0;      if (pa==acc+MULACCLEN*2-4) break;            } 
373   for (ui=bufr;; ui++) {                    uInt hi, lo;                            pa=acc+(ui-bufr);                       for (uj=bufl;; uj++, pa++) {              LONGMUL32HI(hi, *ui, *uj);              lo=(*ui)*(*uj);                         *pa+=lo;                                *(pa+MULACCLEN)+=hi+(*pa&lt;lo);           if (uj==bufl+MULOPLEN-1) break;
374       }
375     if (ui==bufr+MULOPLEN-1) break;
376     }
377   #define MULMAGIC 2305843009U            #if DOUBLE
378     #define MULSHIFTA 29
379     #define MULSHIFTB 32
380   #elif QUAD
381     #define MULSHIFTA 30
382     #define MULSHIFTB 31
383   #else
384     #error Unexpected type
385   #endif
386   #if DECTRACE
387   printf("MulHiLo:");
388   for (pa=acc+MULACCLEN-1; pa&gt;=acc; pa--)
389     printf(" %08lx:%08lx", (LI)*(pa+MULACCLEN), (LI)*pa);
390   printf("\n");
391   #endif
392   for (pa=acc;; pa++) {                     uInt hi, lo;                            uInt hop, estlo;                        #if QUAD
393     uInt esthi;                             #endif
394     lo=*pa;
395     hi=*(pa+MULACCLEN);                 
396     #if DOUBLE
397       hop=(hi&lt;&lt;3)+(lo&gt;&gt;MULSHIFTA);            LONGMUL32HI(estlo, hop, MULMAGIC);      lo-=(estlo*MULTBASE);
398       if (lo&gt;=MULTBASE) {
399         lo-=MULTBASE;
400         estlo++;
401         }
402     #elif QUAD
403       hop=(hi&lt;&lt;2)+(lo&gt;&gt;MULSHIFTA);            LONGMUL32HI(esthi, hop, MULMAGIC);      estlo=hop*MULMAGIC;                     estlo=(esthi&lt;&lt;1)+(estlo&gt;&gt;MULSHIFTB);       lo-=(estlo*MULTBASE);                   if (lo&gt;=MULTBASE) {
404         lo-=MULTBASE;
405         estlo++;
406         }
407       if (lo&gt;=MULTBASE) {
408         lo-=MULTBASE;
409         estlo++;
410         }
411     #else
412       #error Unexpected type
413     #endif
414     *pa=lo;
415     *(pa+1)+=estlo;
416     if (*(pa+1)&lt;estlo) *(pa+1+MULACCLEN)+=1;     if (pa==acc+MULACCLEN-2) break;              } #endif
417   #if DECTRACE
418   printf("MultAcc:");
419   for (pa=acc+MULACCLEN-1; pa&gt;=acc; pa--) printf(" %09ld", (LI)*pa);
420   printf("\n");
421   #endif
422   pa=acc+MULACCLEN-1;
423   if (*pa!=0) num-&gt;msd=bcdacc+LEADZEROS;   else {                                   num-&gt;msd=bcdacc;                        pa--;                                   for (; *pa==0; pa--) if (pa==acc) break;     }
424   for (ub=bcdacc;; pa--, ub+=9) {
425     if (*pa!=0) {                             uInt top, mid, rem;                     #define mulsplit9 1000000               #define mulsplit6 1000                  top=*pa/mulsplit9;
426       rem=*pa%mulsplit9;
427       mid=rem/mulsplit6;
428       rem=rem%mulsplit6;
429       UBFROMUI(ub,   UBTOUI(&amp;BIN2BCD8[top*4]));
430       UBFROMUI(ub+3, UBTOUI(&amp;BIN2BCD8[mid*4]));
431       UBFROMUI(ub+6, UBTOUI(&amp;BIN2BCD8[rem*4]));
432       }
433      else {                                   UBFROMUI(ub, 0);                        UBFROMUI(ub+4, 0);                      *(ub+8)=0;                              }
434     if (pa==acc) break;
435     } 
436   num-&gt;lsd=ub+8;                        
437   #if DECTRACE
438   decShowNum(num, "postmult");
439   decFloatShow(dfl, "dfl");
440   decFloatShow(dfr, "dfr");
441   #endif
442   return;
443   } 
444 decFloat * decFloatAbs(decFloat *result, const decFloat *df,
445                        decContext *set) {
446   if (DFISNAN(df)) return decNaNs(result, df, NULL, set);
447   decCanonical(result, df);               DFBYTE(result, 0)&amp;=~0x80;               return result;
448   } 
449 #if QUAD
450 const Int DECTESTMSD[64]={
451   0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5,   6,    7,
452   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 9, 8, 9, -32, -128,
453   0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5,   6,    7,
454   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 9, 8, 9, -32, -128};
455 #else
456 extern const Int DECTESTMSD[64];
457 #endif
458 decFloat * decFloatAdd(decFloat *result,
459                        const decFloat *dfl, const decFloat *dfr,
460                        decContext *set) {
461   bcdnum num;                        Int    bexpl, bexpr;               uByte  *ub, *us, *ut;              uInt   uiwork;                     #if QUAD
462   uShort uswork;                     #endif
463   uInt sourhil, sourhir;             uInt diffsign;                     uInt carry;                        Int  overlap;                      Int  summ;                         uByte acc[4+2+DECPMAX*3+8];
464   uByte buf[4+2+DECPMAX*2];
465   uByte *umsd, *ulsd;              
466   #if DECLITEND
467     #define CARRYPAT 0x01000000      #else
468     #define CARRYPAT 0x00000001      #endif
469   sourhil=DFWORD(dfl, 0);            summ=DECTESTMSD[sourhil&gt;&gt;26];      bexpr=DECCOMBEXP[sourhil&gt;&gt;26];     bexpr+=GETECON(dfl);             
470   sourhir=DFWORD(dfr, 0);            summ+=DECTESTMSD[sourhir&gt;&gt;26];     bexpl=DECCOMBEXP[sourhir&gt;&gt;26];
471   bexpl+=GETECON(dfr);
472   diffsign=(sourhil^sourhir)&amp;DECFLOAT_Sign;
473   if (summ&lt;=8) {                       if (summ&lt;0) {                        if (summ&lt;-64) return decNaNs(result, dfl, dfr, set);        if (summ==-64 &amp;&amp; diffsign) return decInvalid(result, set);
474       if (DFISINF(dfl)) return decInfinity(result, dfl);          return decInfinity(result, dfr);                            }
475     if (bexpr==bexpl &amp;&amp; !diffsign) {
476       uInt tac[DECLETS+1];                    uInt encode;                      
477       GETCOEFFTHOU(dfl, tac);                 ADDCOEFFTHOU(dfr, tac);
478 <a name="0"></a>      
479 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>      encode =BIN2DPD[tac[0]];
480       encode|=BIN2DPD[tac[1]]&lt;&lt;10;
481       encode|=BIN2DPD[tac[2]]&lt;&lt;20;
482       encode|=BIN2DPD[tac[3]]&lt;&lt;30;
483       DFWORD(result, (DECBYTES/4)-1)=encode;
484       encode =BIN2DPD[tac[3]]&gt;&gt;2;
485       encode|=BIN2DPD[tac[4]]&lt;&lt;8;
486       #if QUAD
487       encode|=BIN2DPD[tac[5]]&lt;&lt;18;
488       encode|=BIN2DPD[tac[6]]&lt;&lt;28;
489       DFWORD(result, 2)=encode;
490       encode =BIN2DPD[tac[6]]&gt;&gt;4;
491       encode|=BIN2DPD[tac[7]]&lt;&lt;6;
492       encode|=BIN2DPD[tac[8]]&lt;&lt;16;
493       encode|=BIN2DPD[tac[9]]&lt;&lt;26;
494       DFWORD(result, 1)=encode;
495       encode =BIN2DPD[tac[9]]&gt;&gt;6;
496       encode|=BIN2DPD[tac[10]]&lt;&lt;4;
497       #endif
498       encode|=sourhil &amp; (ECONMASK | DECFLOAT_Sign);</b></font>
499       tac[DECLETS]|=(bexpl&gt;&gt;DECECONL)&lt;&lt;4;
500       encode|=DECCOMBFROM[tac[DECLETS]];       DFWORD(result, 0)=encode;          
501       return result;
502       }     } 
503   if (bexpl&lt;=bexpr) {
504     Int bexpswap=bexpl;
505     bexpl=bexpr;
506     bexpr=bexpswap;
507     }
508    else {
509     const decFloat *dfswap=dfl;
510     dfl=dfr;
511     dfr=dfswap;
512     }
513   if (DFISZERO(dfl)) {
514     decCanonical(result, dfr);                   if (diffsign &amp;&amp; DFISZERO(result)) {
515       DFWORD(result, 0)&amp;=~DECFLOAT_Sign;           if (set-&gt;round==DEC_ROUND_FLOOR) DFWORD(result, 0)|=DECFLOAT_Sign;
516       }
517     return result;
518     } 
519   #if DOUBLE
520     #define COFF 4                        #elif QUAD
521     UBFROMUS(acc+4, 0);                     #define COFF 6                        #endif
522   GETCOEFF(dfl, acc+COFF);                ulsd=acc+COFF+DECPMAX-1;
523   umsd=acc+4;                           
524   #if DECTRACE
525   {bcdnum tum;
526   tum.msd=umsd;
527   tum.lsd=ulsd;
528   tum.exponent=bexpl-DECBIAS;
529   tum.sign=DFWORD(dfl, 0) &amp; DECFLOAT_Sign;
530   decShowNum(&amp;tum, "dflx");}
531   #endif
532   carry=0;                                if (diffsign) {
533     carry=CARRYPAT;                         UBFROMUI(acc+ 4, 0x09090909-UBTOUI(acc+ 4));
534     UBFROMUI(acc+ 8, 0x09090909-UBTOUI(acc+ 8));
535     UBFROMUI(acc+12, 0x09090909-UBTOUI(acc+12));
536     UBFROMUI(acc+16, 0x09090909-UBTOUI(acc+16));
537     #if QUAD
538     UBFROMUI(acc+20, 0x09090909-UBTOUI(acc+20));
539     UBFROMUI(acc+24, 0x09090909-UBTOUI(acc+24));
540     UBFROMUI(acc+28, 0x09090909-UBTOUI(acc+28));
541     UBFROMUI(acc+32, 0x09090909-UBTOUI(acc+32));
542     UBFROMUI(acc+36, 0x09090909-UBTOUI(acc+36));
543     #endif
544     } 
545   overlap=DECPMAX-(bexpl-bexpr);
546   #if DECTRACE
547   printf("exps: %ld %ld\n", (LI)(bexpl-DECBIAS), (LI)(bexpr-DECBIAS));
548   printf("Overlap=%ld carry=%08lx\n", (LI)overlap, (LI)carry);
549   #endif
550   if (overlap&lt;=0) {                         uInt gap;                               if (carry) {
551       for (ub=ulsd; *ub==9; ub--) *ub=0;
552       *ub+=1;
553       carry=0;                                }
554     gap=-overlap;
555     if (gap&gt;DECPMAX) {
556       bexpr+=gap-1;
557       gap=DECPMAX;
558       }
559     ub=ulsd+gap+1;                          ut=acc+COFF+DECPMAX;                    for (; ut&lt;ub; ut+=4) UBFROMUI(ut, 0);     if (overlap&lt;-DECPMAX) {                   *ub=(uByte)(!DFISZERO(dfr));            }
560      else {                                   GETCOEFF(dfr, ub);                      ub+=DECPMAX-1;                          }
561     ulsd=ub;                                } 
562    else {                                   if (overlap==DECPMAX) {                   ub=buf+COFF;                            #if QUAD
563       UBFROMUS(buf+4, 0);                     #endif
564       GETCOEFF(dfr, ub);                      }
565      else {                                   ub=buf+COFF+DECPMAX-overlap;            UBFROMUI(buf+4, 0);                     UBFROMUI(buf+8, 0);
566       if (ub&gt;buf+12) {
567         ut=buf+12;                              for (; ut&lt;ub; ut+=4) UBFROMUI(ut, 0);         }
568       GETCOEFF(dfr, ub);                
569       UBFROMUI(acc+COFF+DECPMAX,   UBTOUI(buf+COFF+DECPMAX));
570       UBFROMUI(acc+COFF+DECPMAX+4, UBTOUI(buf+COFF+DECPMAX+4));
571       if (buf+COFF+DECPMAX+8&lt;ub+DECPMAX) {
572         us=buf+COFF+DECPMAX+8;                  ut=acc+COFF+DECPMAX+8;                  for (; us&lt;ub+DECPMAX; us+=4, ut+=4) UBFROMUI(ut, UBTOUI(us));
573         }
574       } 
575     ulsd=acc+(ub-buf+DECPMAX-1);        
576     ut=acc+COFF+DECPMAX-4;                  us=buf+COFF+DECPMAX-4;              
577     #if !DECLITEND
578     for (; ut&gt;=acc+4; ut-=4, us-=4) {         carry+=UBTOUI(us);                      if (carry==0) continue;                 carry+=UBTOUI(ut);                      carry+=0x76f6f6f6;                      UBFROMUI(ut, (carry &amp; 0x0f0f0f0f) - ((carry &amp; 0x60606060)&gt;&gt;4));
579       carry&gt;&gt;=31;                             }     #else
580     for (; ut&gt;=acc+4; ut-=4, us-=4) {         carry+=UBTOUI(us);                      if (carry==0) continue;                 carry+=UBTOUI(ut);                      carry+=0x76767676;                      carry+=(carry &amp; 0x80000000)&gt;&gt;15;
581       carry+=(carry &amp; 0x00800000)&gt;&gt;15;
582       carry+=(carry &amp; 0x00008000)&gt;&gt;15;
583       carry-=(carry &amp; 0x60606060)&gt;&gt;4;         UBFROMUI(ut, carry &amp; 0x0f0f0f0f);       carry=(carry &amp; 0x00000080)&lt;&lt;17;
584       }     #endif
585     #if DECTRACE
586     {bcdnum tum;
587     printf("Add done, carry=%08lx, diffsign=%ld\n", (LI)carry, (LI)diffsign);
588     tum.msd=umsd;      tum.lsd=ulsd;
589     tum.exponent=0;
590     tum.sign=0;
591     decShowNum(&amp;tum, "dfadd");}
592     #endif
593     } 
594   if (diffsign) {                      if (!carry) {                        num.sign=DFWORD(dfl, 0) &amp; DECFLOAT_Sign;
595       #if !DECLITEND
596       *(ulsd+1)=0;
597       #endif
598       UBFROMUI(umsd,    0x09090909-UBTOUI(umsd));
599       UBFROMUI(umsd+4,  0x09090909-UBTOUI(umsd+4));
600       UBFROMUI(umsd+8,  0x09090909-UBTOUI(umsd+8));
601       UBFROMUI(umsd+12, 0x09090909-UBTOUI(umsd+12));
602       #if DOUBLE
603         #define BNEXT 16
604       #elif QUAD
605         UBFROMUI(umsd+16, 0x09090909-UBTOUI(umsd+16));
606         UBFROMUI(umsd+20, 0x09090909-UBTOUI(umsd+20));
607         UBFROMUI(umsd+24, 0x09090909-UBTOUI(umsd+24));
608         UBFROMUI(umsd+28, 0x09090909-UBTOUI(umsd+28));
609         UBFROMUI(umsd+32, 0x09090909-UBTOUI(umsd+32));
610         #define BNEXT 36
611       #endif
612       if (ulsd&gt;=umsd+BNEXT) {                   UBFROMUI(umsd+BNEXT,   0x09090909-UBTOUI(umsd+BNEXT));
613         UBFROMUI(umsd+BNEXT+4, 0x09090909-UBTOUI(umsd+BNEXT+4));
614         #if DOUBLE
615         #define BNEXTY (BNEXT+8)
616         #elif QUAD
617         UBFROMUI(umsd+BNEXT+8,  0x09090909-UBTOUI(umsd+BNEXT+8));
618         UBFROMUI(umsd+BNEXT+12, 0x09090909-UBTOUI(umsd+BNEXT+12));
619         #define BNEXTY (BNEXT+16)
620         #endif
621         if (ulsd&gt;=umsd+BNEXTY) {                  ut=umsd+BNEXTY;                         for (;;ut+=4) {
622             UBFROMUI(ut, 0x09090909-UBTOUI(ut));             if (ut&gt;=ulsd-3) break;                  }
623           }
624         }
625       for (ub=ulsd; *ub==9; ub--) *ub=0;
626       *ub+=1;
627       } 
628      else {                              num.sign=DFWORD(dfr, 0) &amp; DECFLOAT_Sign;
629       if (ISCOEFFZERO(acc+COFF)) {
630         umsd=acc+COFF+DECPMAX-1;           if (ulsd&gt;umsd) {                     umsd++;                            for (; UBTOUI(umsd)==0 &amp;&amp; umsd+3&lt;ulsd;) umsd+=4;
631           for (; *umsd==0 &amp;&amp; umsd&lt;ulsd;) umsd++;
632           }
633         if (*umsd==0) {                      num.sign=0;                        if (set-&gt;round==DEC_ROUND_FLOOR) num.sign=DECFLOAT_Sign;
634           }
635         }
636       }     } 
637    else {     num.sign=DFWORD(dfl, 0)&amp;DECFLOAT_Sign;
638     #if DOUBLE
639     if (carry) {                         *(acc+3)=1;                        umsd=acc+3;
640       }
641     #endif
642     } 
643   num.msd=umsd;                      num.lsd=ulsd;                      num.exponent=bexpr-DECBIAS;      
644   #if DECTRACE
645   decFloatShow(dfl, "dfl");
646   decFloatShow(dfr, "dfr");
647   decShowNum(&amp;num, "postadd");
648   #endif
649   return decFinalize(result, &amp;num, set);   } 
650 decFloat * decFloatAnd(decFloat *result,
651                        const decFloat *dfl, const decFloat *dfr,
652                        decContext *set) {
653   if (!DFISUINT01(dfl) || !DFISUINT01(dfr)
654    || !DFISCC01(dfl)   || !DFISCC01(dfr)) return decInvalid(result, set);
655   #if DOUBLE
656    DFWORD(result, 0)=ZEROWORD
657                    |((DFWORD(dfl, 0) &amp; DFWORD(dfr, 0))&amp;0x04009124);
658    DFWORD(result, 1)=(DFWORD(dfl, 1) &amp; DFWORD(dfr, 1))&amp;0x49124491;
659   #elif QUAD
660    DFWORD(result, 0)=ZEROWORD
661                    |((DFWORD(dfl, 0) &amp; DFWORD(dfr, 0))&amp;0x04000912);
662    DFWORD(result, 1)=(DFWORD(dfl, 1) &amp; DFWORD(dfr, 1))&amp;0x44912449;
663    DFWORD(result, 2)=(DFWORD(dfl, 2) &amp; DFWORD(dfr, 2))&amp;0x12449124;
664    DFWORD(result, 3)=(DFWORD(dfl, 3) &amp; DFWORD(dfr, 3))&amp;0x49124491;
665   #endif
666   return result;
667   } 
668 decFloat * decFloatCanonical(decFloat *result, const decFloat *df) {
669   return decCanonical(result, df);
670   } 
671 enum decClass decFloatClass(const decFloat *df) {
672   Int exp;                           if (DFISSPECIAL(df)) {
673     if (DFISQNAN(df)) return DEC_CLASS_QNAN;
674     if (DFISSNAN(df)) return DEC_CLASS_SNAN;
675     if (DFISSIGNED(df)) return DEC_CLASS_NEG_INF;
676     return DEC_CLASS_POS_INF;
677     }
678   if (DFISZERO(df)) {                  if (DFISSIGNED(df)) return DEC_CLASS_NEG_ZERO;
679     return DEC_CLASS_POS_ZERO;
680     }
681   exp=GETEXPUN(df)                      +decFloatDigits(df)-1;          if (exp&gt;=DECEMIN) {                  if (DFISSIGNED(df)) return DEC_CLASS_NEG_NORMAL;
682     return DEC_CLASS_POS_NORMAL;
683     }
684   if (DFISSIGNED(df)) return DEC_CLASS_NEG_SUBNORMAL;
685   return DEC_CLASS_POS_SUBNORMAL;
686   } 
687 const char *decFloatClassString(const decFloat *df) {
688   enum decClass eclass=decFloatClass(df);
689   if (eclass==DEC_CLASS_POS_NORMAL)    return DEC_ClassString_PN;
690   if (eclass==DEC_CLASS_NEG_NORMAL)    return DEC_ClassString_NN;
691   if (eclass==DEC_CLASS_POS_ZERO)      return DEC_ClassString_PZ;
692   if (eclass==DEC_CLASS_NEG_ZERO)      return DEC_ClassString_NZ;
693   if (eclass==DEC_CLASS_POS_SUBNORMAL) return DEC_ClassString_PS;
694   if (eclass==DEC_CLASS_NEG_SUBNORMAL) return DEC_ClassString_NS;
695   if (eclass==DEC_CLASS_POS_INF)       return DEC_ClassString_PI;
696   if (eclass==DEC_CLASS_NEG_INF)       return DEC_ClassString_NI;
697   if (eclass==DEC_CLASS_QNAN)          return DEC_ClassString_QN;
698   if (eclass==DEC_CLASS_SNAN)          return DEC_ClassString_SN;
699   return DEC_ClassString_UN;             } 
700 decFloat * decFloatCompare(decFloat *result,
701                            const decFloat *dfl, const decFloat *dfr,
702                            decContext *set) {
703   Int comp;                                    if (DFISNAN(dfl) || DFISNAN(dfr)) return decNaNs(result, dfl, dfr, set);
704   comp=decNumCompare(dfl, dfr, 0);
705   decFloatZero(result);
706   if (comp==0) return result;
707   DFBYTE(result, DECBYTES-1)=0x01;        if (comp&lt;0) DFBYTE(result, 0)|=0x80;    return result;
708   } 
709 decFloat * decFloatCompareSignal(decFloat *result,
710                                  const decFloat *dfl, const decFloat *dfr,
711                                  decContext *set) {
712   Int comp;                                    if (DFISNAN(dfl) || DFISNAN(dfr)) {
713     set-&gt;status|=DEC_Invalid_operation;
714     return decNaNs(result, dfl, dfr, set);
715     }
716   comp=decNumCompare(dfl, dfr, 0);
717   decFloatZero(result);
718   if (comp==0) return result;
719   DFBYTE(result, DECBYTES-1)=0x01;        if (comp&lt;0) DFBYTE(result, 0)|=0x80;    return result;
720   } 
721 decFloat * decFloatCompareTotal(decFloat *result,
722                                 const decFloat *dfl, const decFloat *dfr) {
723   Int  comp;                                   uInt uiwork;                                 #if QUAD
724   uShort uswork;                               #endif
725   if (DFISNAN(dfl) || DFISNAN(dfr)) {
726     Int nanl, nanr;                              nanl=DFISSNAN(dfl)+DFISQNAN(dfl)*2;          if (DFISSIGNED(dfl)) nanl=-nanl;
727     nanr=DFISSNAN(dfr)+DFISQNAN(dfr)*2;
728     if (DFISSIGNED(dfr)) nanr=-nanr;
729     if (nanl&gt;nanr) comp=+1;
730      else if (nanl&lt;nanr) comp=-1;
731      else {       uByte bufl[DECPMAX+4];                       uByte bufr[DECPMAX+4];                       uByte *ub, *uc;                              Int sigl;                                    sigl=(DFISSIGNED(dfl) ? -1 : +1);
732       #if QUAD
733         UBFROMUS(bufl, 0);
734         UBFROMUS(bufr, 0);
735       #endif
736       GETCOEFF(dfl, bufl+QUAD*2);                  GETCOEFF(dfr, bufr+QUAD*2);                  comp=0;                                      for (ub=bufl, uc=bufr; ub&lt;bufl+DECPMAX+QUAD*2; ub+=4, uc+=4) {
737         uInt ui=UBTOUI(ub);
738         if (ui==UBTOUI(uc)) continue;         for (;; ub++, uc++) {
739           if (*ub==*uc) continue;
740           if (*ub&gt;*uc) comp=sigl;                       else comp=-sigl;                             break;
741           }
742         }
743       }     }
744    else {
745     comp=decNumCompare(dfl, dfr, 1);        }
746   decFloatZero(result);
747   if (comp==0) return result;
748   DFBYTE(result, DECBYTES-1)=0x01;        if (comp&lt;0) DFBYTE(result, 0)|=0x80;    return result;
749   } 
750 decFloat * decFloatCompareTotalMag(decFloat *result,
751                                 const decFloat *dfl, const decFloat *dfr) {
752   decFloat a, b;                          if (DFISSIGNED(dfl)) {
753     decFloatCopyAbs(&amp;a, dfl);
754     dfl=&amp;a;
755     }
756   if (DFISSIGNED(dfr)) {
757     decFloatCopyAbs(&amp;b, dfr);
758     dfr=&amp;b;
759     }
760   return decFloatCompareTotal(result, dfl, dfr);
761   } 
762 decFloat * decFloatCopy(decFloat *result, const decFloat *dfl) {
763   if (dfl!=result) *result=*dfl;               return result;
764   } 
765 decFloat * decFloatCopyAbs(decFloat *result, const decFloat *dfl) {
766   if (dfl!=result) *result=*dfl;          DFBYTE(result, 0)&amp;=~0x80;               return result;
767   } 
768 decFloat * decFloatCopyNegate(decFloat *result, const decFloat *dfl) {
769   if (dfl!=result) *result=*dfl;          DFBYTE(result, 0)^=0x80;                return result;
770   } 
771 decFloat * decFloatCopySign(decFloat *result,
772                             const decFloat *dfl, const decFloat *dfr) {
773   uByte sign=(uByte)(DFBYTE(dfr, 0)&amp;0x80);     if (dfl!=result) *result=*dfl;               DFBYTE(result, 0)&amp;=~0x80;                    DFBYTE(result, 0)=(uByte)(DFBYTE(result, 0)|sign);   return result;
774   } 
775 #define dpdlenchk(n, form)  dpd=(form)&amp;0x3ff;     \
776   if (dpd) return (DECPMAX-1-3*(n))-(3-DPD2BCD8[dpd*4+3])
777 #define dpdlendun(n, form)  dpd=(form)&amp;0x3ff;     \
778   if (dpd==0) return 1;                           \
779   return (DECPMAX-1-3*(n))-(3-DPD2BCD8[dpd*4+3])
780 uInt decFloatDigits(const decFloat *df) {
781   uInt dpd;                          uInt sourhi=DFWORD(df, 0);         #if QUAD
782   uInt sourmh, sourml;
783   #endif
784   uInt sourlo;
785   if (DFISINF(df)) return 1;
786   if (!DFISNAN(df) &amp;&amp; DECCOMBMSD[sourhi&gt;&gt;26]) return DECPMAX;
787   #if DOUBLE
788     if (sourhi&amp;0x0003ffff) {           dpdlenchk(0, sourhi&gt;&gt;8);
789       sourlo=DFWORD(df, 1);
790       dpdlendun(1, (sourhi&lt;&lt;2) | (sourlo&gt;&gt;30));
791       }     sourlo=DFWORD(df, 1);      if (sourlo&amp;0xfff00000) {           dpdlenchk(1, sourlo&gt;&gt;30);        dpdlendun(2, sourlo&gt;&gt;20);
792       }     dpdlenchk(3, sourlo&gt;&gt;10);
793     dpdlendun(4, sourlo);
794   #elif QUAD
795     if (sourhi&amp;0x00003fff) {           dpdlenchk(0, sourhi&gt;&gt;4);
796       sourmh=DFWORD(df, 1);
797       dpdlendun(1, ((sourhi)&lt;&lt;6) | (sourmh&gt;&gt;26));
798       }     sourmh=DFWORD(df, 1);
799     if (sourmh) {
800       dpdlenchk(1, sourmh&gt;&gt;26);
801       dpdlenchk(2, sourmh&gt;&gt;16);
802       dpdlenchk(3, sourmh&gt;&gt;6);
803       sourml=DFWORD(df, 2);
804       dpdlendun(4, ((sourmh)&lt;&lt;4) | (sourml&gt;&gt;28));
805       }     sourml=DFWORD(df, 2);
806     if (sourml) {
807       dpdlenchk(4, sourml&gt;&gt;28);
808       dpdlenchk(5, sourml&gt;&gt;18);
809       dpdlenchk(6, sourml&gt;&gt;8);
810       sourlo=DFWORD(df, 3);
811       dpdlendun(7, ((sourml)&lt;&lt;2) | (sourlo&gt;&gt;30));
812       }     sourlo=DFWORD(df, 3);
813     if (sourlo&amp;0xfff00000) {           dpdlenchk(7, sourlo&gt;&gt;30);        dpdlendun(8, sourlo&gt;&gt;20);
814       }     dpdlenchk(9, sourlo&gt;&gt;10);
815     dpdlendun(10, sourlo);
816   #endif
817   } 
818 decFloat * decFloatDivide(decFloat *result,
819                           const decFloat *dfl, const decFloat *dfr,
820                           decContext *set) {
821   return decDivide(result, dfl, dfr, set, DIVIDE);
822   } 
823 decFloat * decFloatDivideInteger(decFloat *result,
824                              const decFloat *dfl, const decFloat *dfr,
825                              decContext *set) {
826   return decDivide(result, dfl, dfr, set, DIVIDEINT);
827   } 
828 decFloat * decFloatFMA(decFloat *result, const decFloat *dfl,
829                        const decFloat *dfr, const decFloat *dff,
830                        decContext *set) {
831   #define FMALEN (ROUNDUP4(1+ (DECPMAX9*18+1) +DECPMAX+2))
832   uByte  acc[FMALEN];                bcdnum mul;                        bcdnum fin;                        uByte  coe[ROUNDUP4(DECPMAX)];     bcdnum *hi, *lo;                   uInt   diffsign;                   uInt   hipad;                      Int    padding;                    uInt   carry;                      uByte  *ub, *uh, *ul;              uInt   uiwork;                   
833   if (DFISSPECIAL(dfl) || DFISSPECIAL(dfr) || DFISSPECIAL(dff)) {
834     decFloat proxy;                    if (DFISSNAN(dfl) || DFISSNAN(dfr)) return decNaNs(result, dfl, dfr, set);
835     if (DFISSNAN(dff)) return decNaNs(result, dff, NULL, set);
836     if (DFISNAN(dfl) || DFISNAN(dfr)) return decNaNs(result, dfl, dfr, set);
837     if (DFISNAN(dff)) return decNaNs(result, dff, NULL, set);
838     decFloatZero(&amp;proxy);
839     if (DFISINF(dfl)) {
840       if (DFISZERO(dfr)) return decInvalid(result, set);
841       decInfinity(&amp;proxy, &amp;proxy);
842       }
843      else if (DFISINF(dfr)) {
844       if (DFISZERO(dfl)) return decInvalid(result, set);
845       decInfinity(&amp;proxy, &amp;proxy);
846       }
847     DFWORD(&amp;proxy, 0)|=(DFWORD(dfl, 0)^DFWORD(dfr, 0))&amp;DECFLOAT_Sign;
848     if (!DFISINF(dff)) return decFloatCopy(result, &amp;proxy);
849     if (!DFISINF(&amp;proxy)) return decInfinity(result, dff);
850     if ((DFWORD(dff, 0)&amp;DECFLOAT_Sign)!=(DFWORD(&amp;proxy, 0)&amp;DECFLOAT_Sign))
851       return decInvalid(result, set);
852     return decFloatCopy(result, &amp;proxy);
853     }
854   decFiniteMultiply(&amp;mul, acc+1, dfl, dfr);
855   fin.exponent=GETEXPUN(dff);             fin.sign=DFWORD(dff, 0)&amp;DECFLOAT_Sign;
856   diffsign=mul.sign^fin.sign;             fin.msd=coe;
857   fin.lsd=coe+DECPMAX-1;
858   GETCOEFF(dff, coe);                   
859   if (mul.exponent&gt;=fin.exponent) {
860     hi=&amp;mul;
861     lo=&amp;fin;
862     }
863    else {
864     hi=&amp;fin;
865     lo=&amp;mul;
866     }
867   for (; UBTOUI(hi-&gt;msd)==0 &amp;&amp; hi-&gt;msd+3&lt;hi-&gt;lsd;) hi-&gt;msd+=4;
868   for (; *hi-&gt;msd==0 &amp;&amp; hi-&gt;msd&lt;hi-&gt;lsd;) hi-&gt;msd++;
869   for (; UBTOUI(lo-&gt;msd)==0 &amp;&amp; lo-&gt;msd+3&lt;lo-&gt;lsd;) lo-&gt;msd+=4;
870   for (; *lo-&gt;msd==0 &amp;&amp; lo-&gt;msd&lt;lo-&gt;lsd;) lo-&gt;msd++;
871   if (*hi-&gt;msd==0) {                             if (diffsign) {
872       if (*lo-&gt;msd==0) {                             lo-&gt;sign=0;
873         if (set-&gt;round==DEC_ROUND_FLOOR) lo-&gt;sign=DECFLOAT_Sign;
874         }       }     return decFinalize(result, lo, set);         } 
875   hipad=0;
876   carry=0;
877   if (diffsign) {
878     hipad=9;
879     carry=1;
880     for (uh=hi-&gt;msd; uh&lt;hi-&gt;lsd-3; uh+=4) UBFROMUI(uh, 0x09090909-UBTOUI(uh));
881     for (; uh&lt;=hi-&gt;lsd; uh++) *uh=(uByte)(0x09-*uh);
882     }
883   padding=hi-&gt;exponent-lo-&gt;exponent;
884   ub=acc+FMALEN-1;                   ul=lo-&gt;lsd;                      
885   if (padding!=0) {                
886     Int hilen=(Int)(hi-&gt;lsd-hi-&gt;msd+1);     Int lolen=(Int)(lo-&gt;lsd-lo-&gt;msd+1); 
887     if (hilen+padding-lolen &gt; DECPMAX+2) {         Int newexp=MINI(hi-&gt;exponent, hi-&gt;exponent+hilen-DECPMAX)-3;
888       lo-&gt;lsd=lo-&gt;msd;                             lo-&gt;exponent=newexp;                         padding=hi-&gt;exponent-lo-&gt;exponent;           ul=lo-&gt;lsd;                                  }
889     #if DECCHECK
890       if (padding&lt;=0) printf("FMA low padding: %ld\n", (LI)padding);
891       if (hilen+padding+1&gt;FMALEN)
892         printf("FMA excess hilen+padding: %ld+%ld \n", (LI)hilen, (LI)padding);
893     #endif
894     for (; ul-3&gt;=lo-&gt;msd &amp;&amp; padding&gt;3; padding-=4, ul-=4, ub-=4) {
895       UBFROMUI(ub-3, UBTOUI(ul-3));                }
896     for (; ul&gt;=lo-&gt;msd &amp;&amp; padding&gt;0; padding--, ul--, ub--) *ub=*ul;
897     for (;padding&gt;0; padding--, ub--) *ub=0;     }
898   uh=hi-&gt;lsd;
899   for (;; ub--) {
900     if (uh&lt;hi-&gt;msd || ul&lt;lo-&gt;msd) break;
901     *ub=(uByte)(carry+(*uh--)+(*ul--));
902     carry=0;
903     if (*ub&lt;10) continue;
904     *ub-=10;
905     carry=1;
906     } 
907   if (ul&lt;lo-&gt;msd) {               for (;; ub--) {
908       if (uh&lt;hi-&gt;msd) break;
909       *ub=(uByte)(carry+(*uh--));        carry=0;
910       if (*ub&lt;10) continue;
911       *ub-=10;
912       carry=1;
913       }     }
914    else {                         for (;; ub--) {
915       if (ul&lt;lo-&gt;msd) break;
916       *ub=(uByte)(carry+hipad+(*ul--));
917       carry=0;
918       if (*ub&lt;10) continue;
919       *ub-=10;
920       carry=1;
921       }     }
922   lo-&gt;msd=ub+1;
923   lo-&gt;lsd=acc+FMALEN-1;
924   if (!diffsign) {                     if (carry) {                         *ub=1;                             lo-&gt;msd--;                         }
925     }    else {                              if (!carry) {                        lo-&gt;sign=hi-&gt;sign;                 for (ul=lo-&gt;msd; ul&lt;lo-&gt;lsd-3; ul+=4) UBFROMUI(ul, 0x09090909-UBTOUI(ul));
926       for (; ul&lt;=lo-&gt;lsd; ul++) *ul=(uByte)(0x09-*ul);       for (ul--; *ul==9; ul--) *ul=0;
927       *ul+=1;
928       }      else {                              for (; UBTOUI(lo-&gt;msd)==0 &amp;&amp; lo-&gt;msd+3&lt;lo-&gt;lsd;) lo-&gt;msd+=4;
929       for (; *lo-&gt;msd==0 &amp;&amp; lo-&gt;msd&lt;lo-&gt;lsd;) lo-&gt;msd++;
930       if (*lo-&gt;msd==0) {                   lo-&gt;sign=0;                        if (set-&gt;round==DEC_ROUND_FLOOR) lo-&gt;sign=DECFLOAT_Sign;
931         }
932       }     } 
933   #if DECCHECK
934   if (lo-&gt;msd&lt;acc) {
935     printf("FMA underrun by %ld \n", (LI)(acc-lo-&gt;msd));
936     }
937   #endif
938   return decFinalize(result, lo, set);    } 
939 decFloat * decFloatFromInt32(decFloat *result, Int n) {
940   uInt u=(uInt)n;                         uInt encode;                            DFWORD(result, 0)=ZEROWORD;             #if QUAD
941     DFWORD(result, 1)=0;
942     DFWORD(result, 2)=0;
943   #endif
944   if (n&lt;0) {                                u=(~u)+1;
945     DFWORD(result, 0)|=DECFLOAT_Sign;
946     }
947   encode=BIN2DPD[u%1000];
948   u/=1000;
949   encode|=BIN2DPD[u%1000]&lt;&lt;10;
950   u/=1000;
951   encode|=BIN2DPD[u%1000]&lt;&lt;20;
952   u/=1000;                                encode|=u&lt;&lt;30;
953   DFWORD(result, DECWORDS-1)=encode;
954   return result;
955   } 
956 decFloat * decFloatFromUInt32(decFloat *result, uInt u) {
957   uInt encode;                            DFWORD(result, 0)=ZEROWORD;             #if QUAD
958     DFWORD(result, 1)=0;
959     DFWORD(result, 2)=0;
960   #endif
961   encode=BIN2DPD[u%1000];
962   u/=1000;
963   encode|=BIN2DPD[u%1000]&lt;&lt;10;
964   u/=1000;
965   encode|=BIN2DPD[u%1000]&lt;&lt;20;
966   u/=1000;                                encode|=u&lt;&lt;30;
967   DFWORD(result, DECWORDS-1)=encode;
968   DFWORD(result, DECWORDS-2)|=u&gt;&gt;2;       return result;
969   } 
970 decFloat * decFloatInvert(decFloat *result, const decFloat *df,
971                           decContext *set) {
972   uInt sourhi=DFWORD(df, 0);            
973   if (!DFISUINT01(df) || !DFISCC01(df)) return decInvalid(result, set);
974   #if DOUBLE
975    DFWORD(result, 0)=ZEROWORD|((~sourhi)&amp;0x04009124);
976    DFWORD(result, 1)=(~DFWORD(df, 1))   &amp;0x49124491;
977   #elif QUAD
978    DFWORD(result, 0)=ZEROWORD|((~sourhi)&amp;0x04000912);
979    DFWORD(result, 1)=(~DFWORD(df, 1))   &amp;0x44912449;
980    DFWORD(result, 2)=(~DFWORD(df, 2))   &amp;0x12449124;
981    DFWORD(result, 3)=(~DFWORD(df, 3))   &amp;0x49124491;
982   #endif
983   return result;
984   } 
985 uInt decFloatIsCanonical(const decFloat *df) {
986   if (DFISSPECIAL(df)) {
987     if (DFISINF(df)) {
988       if (DFWORD(df, 0)&amp;ECONMASK) return 0;        if (!DFISCCZERO(df)) return 0;               return 1;
989       }
990     if (DFWORD(df, 0)&amp;ECONNANMASK) return 0;     if (DFISCCZERO(df)) return 1;                }
991   {   #if DOUBLE
992     uInt sourhi=DFWORD(df, 0);
993     uInt sourlo=DFWORD(df, 1);
994     if (CANONDPDOFF(sourhi, 8)
995      &amp;&amp; CANONDPDTWO(sourhi, sourlo, 30)
996      &amp;&amp; CANONDPDOFF(sourlo, 20)
997      &amp;&amp; CANONDPDOFF(sourlo, 10)
998      &amp;&amp; CANONDPDOFF(sourlo, 0)) return 1;
999   #elif QUAD
1000     uInt sourhi=DFWORD(df, 0);
1001     uInt sourmh=DFWORD(df, 1);
1002     uInt sourml=DFWORD(df, 2);
1003     uInt sourlo=DFWORD(df, 3);
1004     if (CANONDPDOFF(sourhi, 4)
1005      &amp;&amp; CANONDPDTWO(sourhi, sourmh, 26)
1006      &amp;&amp; CANONDPDOFF(sourmh, 16)
1007      &amp;&amp; CANONDPDOFF(sourmh, 6)
1008      &amp;&amp; CANONDPDTWO(sourmh, sourml, 28)
1009      &amp;&amp; CANONDPDOFF(sourml, 18)
1010      &amp;&amp; CANONDPDOFF(sourml, 8)
1011      &amp;&amp; CANONDPDTWO(sourml, sourlo, 30)
1012      &amp;&amp; CANONDPDOFF(sourlo, 20)
1013      &amp;&amp; CANONDPDOFF(sourlo, 10)
1014      &amp;&amp; CANONDPDOFF(sourlo, 0)) return 1;
1015   #endif
1016   }   return 0;      }
1017 uInt decFloatIsFinite(const decFloat *df) {
1018   return !DFISSPECIAL(df);
1019   }
1020 uInt decFloatIsInfinite(const decFloat *df) {
1021   return DFISINF(df);
1022   }
1023 uInt decFloatIsInteger(const decFloat *df) {
1024   return DFISINT(df);
1025   }
1026 uInt decFloatIsLogical(const decFloat *df) {
1027   return DFISUINT01(df) &amp; DFISCC01(df);
1028   }
1029 uInt decFloatIsNaN(const decFloat *df) {
1030   return DFISNAN(df);
1031   }
1032 uInt decFloatIsNegative(const decFloat *df) {
1033   return DFISSIGNED(df) &amp;&amp; !DFISZERO(df) &amp;&amp; !DFISNAN(df);
1034   }
1035 uInt decFloatIsNormal(const decFloat *df) {
1036   Int exp;                           if (DFISSPECIAL(df)) return 0;
1037   if (DFISZERO(df)) return 0;
1038   exp=GETEXPUN(df)                      +decFloatDigits(df)-1;          return (exp&gt;=DECEMIN);             }
1039 uInt decFloatIsPositive(const decFloat *df) {
1040   return !DFISSIGNED(df) &amp;&amp; !DFISZERO(df) &amp;&amp; !DFISNAN(df);
1041   }
1042 uInt decFloatIsSignaling(const decFloat *df) {
1043   return DFISSNAN(df);
1044   }
1045 uInt decFloatIsSignalling(const decFloat *df) {
1046   return DFISSNAN(df);
1047   }
1048 uInt decFloatIsSigned(const decFloat *df) {
1049   return DFISSIGNED(df);
1050   }
1051 uInt decFloatIsSubnormal(const decFloat *df) {
1052   if (DFISSPECIAL(df)) return 0;
1053   if (decFloatIsNormal(df)) return 0;
1054   if (DFISZERO(df)) return 0;
1055   return 1;                                    }
1056 uInt decFloatIsZero(const decFloat *df) {
1057   return DFISZERO(df);
1058   } 
1059 decFloat * decFloatLogB(decFloat *result, const decFloat *df,
1060                         decContext *set) {
1061   Int ae;                                      if (DFISNAN(df)) return decNaNs(result, df, NULL, set);
1062   if (DFISINF(df)) {
1063     DFWORD(result, 0)=0;                         return decInfinity(result, result);          }
1064   if (DFISZERO(df)) {
1065     set-&gt;status|=DEC_Division_by_zero;           DFWORD(result, 0)=DECFLOAT_Sign;             return decInfinity(result, result);          }
1066   ae=GETEXPUN(df)                           +decFloatDigits(df)-1;                DFWORD(result, 0)=ZEROWORD;             if (ae&lt;0) {
1067     DFWORD(result, 0)|=DECFLOAT_Sign;       ae=-ae;
1068     }
1069   #if DOUBLE
1070     DFWORD(result, 1)=BIN2DPD[ae];        #elif QUAD
1071     DFWORD(result, 1)=0;
1072     DFWORD(result, 2)=0;
1073     DFWORD(result, 3)=(ae/1000)&lt;&lt;10;        DFWORD(result, 3)|=BIN2DPD[ae%1000];
1074   #endif
1075   return result;
1076   } 
1077 decFloat * decFloatMax(decFloat *result,
1078                        const decFloat *dfl, const decFloat *dfr,
1079                        decContext *set) {
1080   Int comp;
1081   if (DFISNAN(dfl)) {
1082     if (DFISNAN(dfr) || DFISSNAN(dfl)) return decNaNs(result, dfl, dfr, set);
1083     return decCanonical(result, dfr);            }
1084   if (DFISNAN(dfr)) {
1085     if (DFISSNAN(dfr)) return decNaNs(result, dfl, dfr, set);
1086     return decCanonical(result, dfl);            }
1087   comp=decNumCompare(dfl, dfr, 1);
1088   if (comp&gt;=0) return decCanonical(result, dfl);
1089   return decCanonical(result, dfr);
1090   } 
1091 decFloat * decFloatMaxMag(decFloat *result,
1092                        const decFloat *dfl, const decFloat *dfr,
1093                        decContext *set) {
1094   Int comp;
1095   decFloat absl, absr;
1096   if (DFISNAN(dfl) || DFISNAN(dfr)) return decFloatMax(result, dfl, dfr, set);
1097   decFloatCopyAbs(&amp;absl, dfl);
1098   decFloatCopyAbs(&amp;absr, dfr);
1099   comp=decNumCompare(&amp;absl, &amp;absr, 0);
1100   if (comp&gt;0) return decCanonical(result, dfl);
1101   if (comp&lt;0) return decCanonical(result, dfr);
1102   return decFloatMax(result, dfl, dfr, set);
1103   } 
1104 decFloat * decFloatMin(decFloat *result,
1105                        const decFloat *dfl, const decFloat *dfr,
1106                        decContext *set) {
1107   Int comp;
1108   if (DFISNAN(dfl)) {
1109     if (DFISNAN(dfr) || DFISSNAN(dfl)) return decNaNs(result, dfl, dfr, set);
1110     return decCanonical(result, dfr);            }
1111   if (DFISNAN(dfr)) {
1112     if (DFISSNAN(dfr)) return decNaNs(result, dfl, dfr, set);
1113     return decCanonical(result, dfl);            }
1114   comp=decNumCompare(dfl, dfr, 1);
1115   if (comp&lt;=0) return decCanonical(result, dfl);
1116   return decCanonical(result, dfr);
1117   } 
1118 decFloat * decFloatMinMag(decFloat *result,
1119                        const decFloat *dfl, const decFloat *dfr,
1120                        decContext *set) {
1121   Int comp;
1122   decFloat absl, absr;
1123   if (DFISNAN(dfl) || DFISNAN(dfr)) return decFloatMin(result, dfl, dfr, set);
1124   decFloatCopyAbs(&amp;absl, dfl);
1125   decFloatCopyAbs(&amp;absr, dfr);
1126   comp=decNumCompare(&amp;absl, &amp;absr, 0);
1127   if (comp&lt;0) return decCanonical(result, dfl);
1128   if (comp&gt;0) return decCanonical(result, dfr);
1129   return decFloatMin(result, dfl, dfr, set);
1130   } 
1131 decFloat * decFloatMinus(decFloat *result, const decFloat *df,
1132                          decContext *set) {
1133   if (DFISNAN(df)) return decNaNs(result, df, NULL, set);
1134   decCanonical(result, df);                         if (DFISZERO(df)) DFBYTE(result, 0)&amp;=~0x80;        else DFBYTE(result, 0)^=0x80;                    return result;
1135   } 
1136 decFloat * decFloatMultiply(decFloat *result,
1137                             const decFloat *dfl, const decFloat *dfr,
1138                             decContext *set) {
1139   bcdnum num;                        uByte  bcdacc[DECPMAX9*18+1];    
1140   if (DFISSPECIAL(dfl) || DFISSPECIAL(dfr)) {     if (DFISNAN(dfl) || DFISNAN(dfr)) return decNaNs(result, dfl, dfr, set);
1141     if (DFISINF(dfl) &amp;&amp; DFISZERO(dfr)) return decInvalid(result, set);
1142     if (DFISINF(dfr) &amp;&amp; DFISZERO(dfl)) return decInvalid(result, set);
1143     DFWORD(result, 0)=DFWORD(dfl, 0)^DFWORD(dfr, 0);     return decInfinity(result, result);
1144     }
1145   decFiniteMultiply(&amp;num, bcdacc, dfl, dfr);
1146   return decFinalize(result, &amp;num, set);   } 
1147 decFloat * decFloatNextMinus(decFloat *result, const decFloat *dfl,
1148                              decContext *set) {
1149   decFloat delta;                         uInt savestat;                          enum rounding saveround;              
1150   if (DFISINF(dfl) &amp;&amp; !DFISSIGNED(dfl)) {
1151     DFSETNMAX(result);
1152     return result;                          }
1153   decFloatZero(&amp;delta);                   DFWORD(&amp;delta, DECWORDS-1)=1;           DFWORD(&amp;delta, 0)=DECFLOAT_Sign;        saveround=set-&gt;round;                   set-&gt;round=DEC_ROUND_FLOOR;             savestat=set-&gt;status;                   decFloatAdd(result, dfl, &amp;delta, set);
1154   if (DFISZERO(result)) DFWORD(result, 0)^=DECFLOAT_Sign;   set-&gt;status&amp;=DEC_Invalid_operation;     set-&gt;status|=savestat;                  set-&gt;round=saveround;                   return result;
1155   } 
1156 decFloat * decFloatNextPlus(decFloat *result, const decFloat *dfl,
1157                             decContext *set) {
1158   uInt savestat;                          enum rounding saveround;                decFloat delta;                       
1159   if (DFISINF(dfl) &amp;&amp; DFISSIGNED(dfl)) {
1160     DFSETNMAX(result);
1161     DFWORD(result, 0)|=DECFLOAT_Sign;       return result;                          }
1162   decFloatZero(&amp;delta);                   DFWORD(&amp;delta, DECWORDS-1)=1;           DFWORD(&amp;delta, 0)=0;                    saveround=set-&gt;round;                   set-&gt;round=DEC_ROUND_CEILING;           savestat=set-&gt;status;                   decFloatAdd(result, dfl, &amp;delta, set);
1163   if (DFISZERO(result)) DFWORD(result, 0)^=DECFLOAT_Sign;   set-&gt;status&amp;=DEC_Invalid_operation;     set-&gt;status|=savestat;                  set-&gt;round=saveround;                   return result;
1164   } 
1165 decFloat * decFloatNextToward(decFloat *result,
1166                               const decFloat *dfl, const decFloat *dfr,
1167                               decContext *set) {
1168   decFloat delta;                         decFloat pointone;                      uInt  savestat;                         enum  rounding saveround;               uInt  deltatop;                         Int   comp;                           
1169   if (DFISNAN(dfl) || DFISNAN(dfr)) return decNaNs(result, dfl, dfr, set);
1170   comp=decNumCompare(dfl, dfr, 0);
1171   if (comp==0) return decFloatCopySign(result, dfl, dfr); 
1172   if (comp&lt;0) {     if (DFISINF(dfl) &amp;&amp; DFISSIGNED(dfl)) {         DFSETNMAX(result);
1173       DFWORD(result, 0)|=DECFLOAT_Sign;
1174       return result;
1175       }
1176     saveround=set-&gt;round;                        set-&gt;round=DEC_ROUND_CEILING;                deltatop=0;                                  }
1177    else {     if (DFISINF(dfl) &amp;&amp; !DFISSIGNED(dfl)) {        DFSETNMAX(result);
1178       return result;
1179       }
1180     saveround=set-&gt;round;                        set-&gt;round=DEC_ROUND_FLOOR;                  deltatop=DECFLOAT_Sign;                      }
1181   savestat=set-&gt;status;                        decFloatZero(&amp;delta);                   DFWORD(&amp;delta, DECWORDS-1)=1;           DFWORD(&amp;delta, 0)=deltatop;             decFloatFromString(&amp;pointone, "1E-1", set);   decFloatFMA(result, &amp;delta, &amp;pointone, dfl, set);
1182   if (decFloatIsNormal(result)) set-&gt;status=savestat;   set-&gt;round=saveround;                   return result;
1183   } 
1184 decFloat * decFloatOr(decFloat *result,
1185                        const decFloat *dfl, const decFloat *dfr,
1186                        decContext *set) {
1187   if (!DFISUINT01(dfl) || !DFISUINT01(dfr)
1188    || !DFISCC01(dfl)   || !DFISCC01(dfr)) return decInvalid(result, set);
1189   #if DOUBLE
1190    DFWORD(result, 0)=ZEROWORD
1191                    |((DFWORD(dfl, 0) | DFWORD(dfr, 0))&amp;0x04009124);
1192    DFWORD(result, 1)=(DFWORD(dfl, 1) | DFWORD(dfr, 1))&amp;0x49124491;
1193   #elif QUAD
1194    DFWORD(result, 0)=ZEROWORD
1195                    |((DFWORD(dfl, 0) | DFWORD(dfr, 0))&amp;0x04000912);
1196    DFWORD(result, 1)=(DFWORD(dfl, 1) | DFWORD(dfr, 1))&amp;0x44912449;
1197    DFWORD(result, 2)=(DFWORD(dfl, 2) | DFWORD(dfr, 2))&amp;0x12449124;
1198    DFWORD(result, 3)=(DFWORD(dfl, 3) | DFWORD(dfr, 3))&amp;0x49124491;
1199   #endif
1200   return result;
1201   } 
1202 decFloat * decFloatPlus(decFloat *result, const decFloat *df,
1203                         decContext *set) {
1204   if (DFISNAN(df)) return decNaNs(result, df, NULL, set);
1205   decCanonical(result, df);                         if (DFISZERO(df)) DFBYTE(result, 0)&amp;=~0x80;       return result;
1206   } 
1207 decFloat * decFloatQuantize(decFloat *result,
1208                             const decFloat *dfl, const decFloat *dfr,
1209                             decContext *set) {
1210   Int   explb, exprb;           uByte *ulsd;                  uByte *ub, *uc;               Int   drop;                   uInt  dpd;                    uInt  encode;                 uInt  sourhil, sourhir;       uInt  uiwork;                 #if QUAD
1211   uShort uswork;                #endif
1212   uByte buf[4+DECPMAX*3+2*QUAD];     #if DECTRACE
1213   bcdnum num;                        #endif
1214   sourhil=DFWORD(dfl, 0);            explb=DECCOMBEXP[sourhil&gt;&gt;26];     sourhir=DFWORD(dfr, 0);            exprb=DECCOMBEXP[sourhir&gt;&gt;26];
1215   if (EXPISSPECIAL(explb | exprb)) {     if (DFISNAN(dfl) || DFISNAN(dfr)) return decNaNs(result, dfl, dfr, set);
1216     if (DFISINF(dfl)!=DFISINF(dfr)) return decInvalid(result, set);
1217     return decInfinity(result, dfl);
1218     }
1219   explb+=GETECON(dfl);               exprb+=GETECON(dfr);             
1220   drop=exprb-explb;                  if (drop==0) return decCanonical(result, dfl); 
1221   #define BUFOFF (buf+4+DECPMAX)
1222   GETCOEFF(dfl, BUFOFF);           
1223   #if DECTRACE
1224   num.msd=BUFOFF;
1225   num.lsd=BUFOFF+DECPMAX-1;
1226   num.exponent=explb-DECBIAS;
1227   num.sign=sourhil &amp; DECFLOAT_Sign;
1228   decShowNum(&amp;num, "dfl");
1229   #endif
1230   if (drop&gt;0) {                             uByte *roundat;                              uByte reround;                           
1231     UBFROMUI(BUFOFF-4, 0);
1232     if (drop&lt;DECPMAX) {                            roundat=BUFOFF+DECPMAX-drop;
1233       reround=*roundat;
1234       for (ub=roundat+1; ub&lt;BUFOFF+DECPMAX; ub++) {
1235         if (*ub!=0) {                                  reround=DECSTICKYTAB[reround];               break;                                       }
1236         }       ulsd=roundat-1;                              }
1237      else {                                        if (drop==DECPMAX) {
1238         roundat=BUFOFF;
1239         reround=*roundat;
1240         }
1241        else {
1242         roundat=BUFOFF-1;
1243         reround=0;
1244         }
1245       for (ub=roundat+1; ub&lt;BUFOFF+DECPMAX; ub++) {
1246         if (*ub!=0) {                                  reround=DECSTICKYTAB[reround];               break;                                       }
1247         }       *BUFOFF=0;                                   ulsd=BUFOFF;                                 }
1248     if (reround!=0) {                              uInt bump=0;
1249       set-&gt;status|=DEC_Inexact;
1250       if (set-&gt;round==DEC_ROUND_HALF_EVEN) {         if (reround&gt;5) bump=1;                        else if (reround==5)                          bump=*ulsd &amp; 0x01;                         }        else switch (set-&gt;round) {
1251         case DEC_ROUND_DOWN: {
1252           break;}         case DEC_ROUND_HALF_DOWN: {
1253           if (reround&gt;5) bump=1;
1254           break;}         case DEC_ROUND_HALF_UP: {
1255           if (reround&gt;=5) bump=1;
1256           break;}         case DEC_ROUND_UP: {
1257           if (reround&gt;0) bump=1;
1258           break;}         case DEC_ROUND_CEILING: {
1259           if (!(sourhil&amp;DECFLOAT_Sign) &amp;&amp; reround&gt;0) bump=1;
1260           break;}         case DEC_ROUND_FLOOR: {
1261           if (sourhil&amp;DECFLOAT_Sign &amp;&amp; reround&gt;0) bump=1;
1262           break;}         case DEC_ROUND_05UP: {
1263           if (reround&gt;0) {             if (*ulsd==0 || *ulsd==5) bump=1;
1264             }
1265           break;}         default: {                set-&gt;status|=DEC_Invalid_context;
1266           #if DECCHECK
1267           printf("Unknown rounding mode: %ld\n", (LI)set-&gt;round);
1268           #endif
1269           break;}
1270         } 
1271       if (bump!=0) {                                 ub=ulsd;
1272         for (; UBTOUI(ub-3)==0x09090909; ub-=4) UBFROMUI(ub-3, 0);
1273         for (; *ub==9; ub--) *ub=0;
1274         *ub+=1;
1275         }       } 
1276     if (drop&gt;4) {
1277       UBFROMUI(BUFOFF-8, 0);                       for (uc=BUFOFF-12; uc&gt;ulsd-DECPMAX-3; uc-=4) UBFROMUI(uc, 0);
1278       }
1279     } 
1280    else {     if (-drop&gt;DECPMAX-1) {                         if (!ISCOEFFZERO(BUFOFF)) return decInvalid(result, set);
1281       ulsd=BUFOFF+DECPMAX-1;
1282       }
1283      else {       #if DECLITEND
1284       static const uInt dmask[]={0, 0x000000ff, 0x0000ffff, 0x00ffffff};
1285       #else
1286       static const uInt dmask[]={0, 0xff000000, 0xffff0000, 0xffffff00};
1287       #endif
1288       for (uc=BUFOFF+DECPMAX;; uc+=4) {
1289         UBFROMUI(uc, 0);
1290         if (UBTOUI(uc-DECPMAX)!=0) {                        if (uc&lt;=BUFOFF+DECPMAX+(-drop)-4)
1291             return decInvalid(result, set);
1292           if ((UBTOUI(uc-DECPMAX)&amp;dmask[(-drop)%4])!=0)
1293             return decInvalid(result, set);
1294           break;              }
1295         if (uc&gt;=BUFOFF+DECPMAX+(-drop)-4) break;          }
1296       ulsd=BUFOFF+DECPMAX+(-drop)-1;
1297       } <a name="1"></a>    } 
1298   #if DECTRACE
1299 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  num.msd=ulsd-DECPMAX+1;
1300   num.lsd=ulsd;
1301   num.exponent=explb-DECBIAS;
1302   num.sign=sourhil &amp; DECFLOAT_Sign;
1303   decShowNum(&amp;num, "res");
1304   #endif
1305   encode=((exprb&gt;&gt;DECECONL)&lt;&lt;4) + *(ulsd-DECPMAX+1);   encode=DECCOMBFROM[encode];                  encode|=sourhir &amp; ECONMASK;
1306   encode|=sourhil&amp;DECFLOAT_Sign;             
1307   #define getDPD3q(dpd, n) ub=ulsd-(3*(n))-2;                   \
1308     dpd=BCD2DPD[(*ub*256)+(*(ub+1)*16)+*(ub+2)];
1309   #if DOUBLE
1310     getDPD3q(dpd, 4); encode|=dpd&lt;&lt;8;
1311     getDPD3q(dpd, 3); encode|=dpd&gt;&gt;2;
1312     DFWORD(result, 0)=encode;
1313     encode=dpd&lt;&lt;30;
1314     getDPD3q(dpd, 2); encode|=dpd&lt;&lt;20;
1315     getDPD3q(dpd, 1); encode|=dpd&lt;&lt;10;
1316     getDPD3q(dpd, 0); encode|=dpd;</b></font>
1317     DFWORD(result, 1)=encode;
1318   #elif QUAD
1319     getDPD3q(dpd,10); encode|=dpd&lt;&lt;4;
1320     getDPD3q(dpd, 9); encode|=dpd&gt;&gt;6;
1321     DFWORD(result, 0)=encode;
1322     encode=dpd&lt;&lt;26;
1323     getDPD3q(dpd, 8); encode|=dpd&lt;&lt;16;
1324     getDPD3q(dpd, 7); encode|=dpd&lt;&lt;6;
1325     getDPD3q(dpd, 6); encode|=dpd&gt;&gt;4;
1326     DFWORD(result, 1)=encode;
1327     encode=dpd&lt;&lt;28;
1328     getDPD3q(dpd, 5); encode|=dpd&lt;&lt;18;
1329     getDPD3q(dpd, 4); encode|=dpd&lt;&lt;8;
1330     getDPD3q(dpd, 3); encode|=dpd&gt;&gt;2;
1331     DFWORD(result, 2)=encode;
1332     encode=dpd&lt;&lt;30;
1333     getDPD3q(dpd, 2); encode|=dpd&lt;&lt;20;
1334     getDPD3q(dpd, 1); encode|=dpd&lt;&lt;10;
1335     getDPD3q(dpd, 0); encode|=dpd;
1336     DFWORD(result, 3)=encode;
1337   #endif
1338   return result;
1339   } 
1340 decFloat * decFloatReduce(decFloat *result, const decFloat *df,
1341                           decContext *set) {
1342   bcdnum num;                             uByte buf[DECPMAX], *ub;                if (df!=result) *result=*df;            if (DFISNAN(df)) return decNaNs(result, df, NULL, set);     if (DFISINF(df)) return decInfinity(result, df);       if (DFISZERO(df)) {
1343     uInt sign=DFWORD(df, 0)&amp;DECFLOAT_Sign;
1344     decFloatZero(result);
1345     DFWORD(result, 0)|=sign;
1346     return result;                          }
1347   GETCOEFF(df, buf);
1348   ub=buf+DECPMAX-1;                       if (*ub) return result;                 for (ub--; *ub==0;) ub--;               num.sign=DFWORD(df, 0)&amp;DECFLOAT_Sign;   num.exponent=GETEXPUN(df)+(Int)(buf+DECPMAX-1-ub);   num.msd=buf;
1349   num.lsd=ub;
1350   return decFinalize(result, &amp;num, set);
1351   } 
1352 decFloat * decFloatRemainder(decFloat *result,
1353                              const decFloat *dfl, const decFloat *dfr,
1354                              decContext *set) {
1355   return decDivide(result, dfl, dfr, set, REMAINDER);
1356   } 
1357 decFloat * decFloatRemainderNear(decFloat *result,
1358                              const decFloat *dfl, const decFloat *dfr,
1359                              decContext *set) {
1360   return decDivide(result, dfl, dfr, set, REMNEAR);
1361   } 
1362 #define PHALF (ROUNDUP(DECPMAX/2, 4))   decFloat * decFloatRotate(decFloat *result,
1363                          const decFloat *dfl, const decFloat *dfr,
1364                          decContext *set) {
1365   Int rotate;                             uByte buf[DECPMAX+PHALF];               uInt digits, savestat;                  bcdnum num;                             uByte *ub;                            
1366   if (DFISNAN(dfl)||DFISNAN(dfr)) return decNaNs(result, dfl, dfr, set);
1367   if (!DFISINT(dfr)) return decInvalid(result, set);
1368   digits=decFloatDigits(dfr);                      if (digits&gt;2) return decInvalid(result, set);    rotate=DPD2BIN[DFWORD(dfr, DECWORDS-1)&amp;0x3ff];   if (rotate&gt;DECPMAX) return decInvalid(result, set);   if (DFISINF(dfl)) return decInfinity(result, dfl);    if (rotate==0 || rotate==DECPMAX) return decCanonical(result, dfl);
1369   if (DFISSIGNED(dfr)) rotate=-rotate;
1370   if (abs(rotate)&gt;PHALF) {
1371     if (rotate&lt;0) rotate=DECPMAX+rotate;
1372      else rotate=rotate-DECPMAX;
1373     }
1374   ub=buf;
1375   if (rotate&lt;0) ub+=PHALF;      GETCOEFF(dfl, ub);
1376   if (rotate&lt;0) {
1377     memcpy(buf, buf+DECPMAX, PHALF);
1378     num.msd=buf+PHALF+rotate;
1379     }
1380    else {
1381     memcpy(buf+DECPMAX, buf, PHALF);
1382     num.msd=buf+rotate;
1383     }
1384   num.lsd=num.msd+DECPMAX-1;
1385   num.sign=DFWORD(dfl, 0)&amp;DECFLOAT_Sign;
1386   num.exponent=GETEXPUN(dfl);
1387   savestat=set-&gt;status;                   decFinalize(result, &amp;num, set);
1388   set-&gt;status=savestat;                   return result;
1389   } 
1390 uInt decFloatSameQuantum(const decFloat *dfl, const decFloat *dfr) {
1391   if (DFISSPECIAL(dfl) || DFISSPECIAL(dfr)) {
1392     if (DFISNAN(dfl) &amp;&amp; DFISNAN(dfr)) return 1;
1393     if (DFISINF(dfl) &amp;&amp; DFISINF(dfr)) return 1;
1394     return 0;      }
1395   if (GETEXP(dfl)==GETEXP(dfr)) return 1;   return 0;
1396   } 
1397 #define SCALEBMAX 2*(DECEMAX+DECPMAX)   decFloat * decFloatScaleB(decFloat *result,
1398                           const decFloat *dfl, const decFloat *dfr,
1399                           decContext *set) {
1400   uInt digits;                            Int  expr;                            
1401   if (DFISNAN(dfl)||DFISNAN(dfr)) return decNaNs(result, dfl, dfr, set);
1402   if (!DFISINT(dfr)) return decInvalid(result, set);
1403   digits=decFloatDigits(dfr);                
1404   #if DOUBLE
1405   if (digits&gt;3) return decInvalid(result, set);     expr=DPD2BIN[DFWORD(dfr, 1)&amp;0x3ff];               #elif QUAD
1406   if (digits&gt;5) return decInvalid(result, set);     expr=DPD2BIN[DFWORD(dfr, 3)&amp;0x3ff]                    +DPD2BIN[(DFWORD(dfr, 3)&gt;&gt;10)&amp;0x3ff]*1000;    #endif
1407   if (expr&gt;SCALEBMAX) return decInvalid(result, set);    if (DFISINF(dfl)) return decInfinity(result, dfl);     if (DFISSIGNED(dfr)) expr=-expr;
1408   *result=*dfl;                                return decFloatSetExponent(result, set, GETEXPUN(result)+expr);
1409   } 
1410 decFloat * decFloatShift(decFloat *result,
1411                          const decFloat *dfl, const decFloat *dfr,
1412                          decContext *set) {
1413   Int    shift;                           uByte  buf[DECPMAX*2];                  uInt   digits, savestat;                bcdnum num;                             uInt   uiwork;                        
1414   if (DFISNAN(dfl)||DFISNAN(dfr)) return decNaNs(result, dfl, dfr, set);
1415   if (!DFISINT(dfr)) return decInvalid(result, set);
1416   digits=decFloatDigits(dfr);                       if (digits&gt;2) return decInvalid(result, set);     shift=DPD2BIN[DFWORD(dfr, DECWORDS-1)&amp;0x3ff];     if (shift&gt;DECPMAX) return decInvalid(result, set);   
1417   if (DFISINF(dfl)) return decInfinity(result, dfl);   if (shift==0) return decCanonical(result, dfl);
1418   if (shift==DECPMAX) {                          uByte sign=(uByte)(DFBYTE(dfl, 0)&amp;0x80);     decFloatZero(result);                        DFBYTE(result, 0)=(uByte)(DFBYTE(result, 0)|sign);     return result;
1419     }
1420   num.sign=DFWORD(dfl, 0)&amp;DECFLOAT_Sign;
1421   num.exponent=GETEXPUN(dfl);
1422   num.msd=buf;
1423   GETCOEFF(dfl, buf);
1424   if (DFISSIGNED(dfr)) {     num.lsd=buf+DECPMAX-shift-1;
1425     }
1426    else {     UBFROMUI(buf+DECPMAX, 0);               UBFROMUI(buf+DECPMAX+4, 0);             if (shift&gt;8) memset(buf+DECPMAX+8, 0, 8+QUAD*18);     num.msd+=shift;
1427     num.lsd=num.msd+DECPMAX-1;
1428     }
1429   savestat=set-&gt;status;                   decFinalize(result, &amp;num, set);
1430   set-&gt;status=savestat;                   return result;
1431   } 
1432 decFloat * decFloatSubtract(decFloat *result,
1433                             const decFloat *dfl, const decFloat *dfr,
1434                             decContext *set) {
1435   decFloat temp;
1436   if (DFISNAN(dfr)) return decFloatAdd(result, dfl, dfr, set);
1437   temp=*dfr;                                     DFBYTE(&amp;temp, 0)^=0x80;                        return decFloatAdd(result, dfl, &amp;temp, set);   } 
1438 uInt decFloatToUInt32(const decFloat *df, decContext *set,
1439                       enum rounding round) {
1440   return decToInt32(df, set, round, 0, 1);}
1441 uInt decFloatToUInt32Exact(const decFloat *df, decContext *set,
1442                            enum rounding round) {
1443   return decToInt32(df, set, round, 1, 1);}
1444 Int decFloatToInt32(const decFloat *df, decContext *set,
1445                     enum rounding round) {
1446   return (Int)decToInt32(df, set, round, 0, 0);}
1447 Int decFloatToInt32Exact(const decFloat *df, decContext *set,
1448                          enum rounding round) {
1449   return (Int)decToInt32(df, set, round, 1, 0);}
1450 decFloat * decFloatToIntegralValue(decFloat *result, const decFloat *df,
1451                                    decContext *set, enum rounding round) {
1452   return decToIntegral(result, df, set, round, 0);}
1453 decFloat * decFloatToIntegralExact(decFloat *result, const decFloat *df,
1454                                    decContext *set) {
1455   return decToIntegral(result, df, set, set-&gt;round, 1);}
1456 decFloat * decFloatXor(decFloat *result,
1457                        const decFloat *dfl, const decFloat *dfr,
1458                        decContext *set) {
1459   if (!DFISUINT01(dfl) || !DFISUINT01(dfr)
1460    || !DFISCC01(dfl)   || !DFISCC01(dfr)) return decInvalid(result, set);
1461   #if DOUBLE
1462    DFWORD(result, 0)=ZEROWORD
1463                    |((DFWORD(dfl, 0) ^ DFWORD(dfr, 0))&amp;0x04009124);
1464    DFWORD(result, 1)=(DFWORD(dfl, 1) ^ DFWORD(dfr, 1))&amp;0x49124491;
1465   #elif QUAD
1466    DFWORD(result, 0)=ZEROWORD
1467                    |((DFWORD(dfl, 0) ^ DFWORD(dfr, 0))&amp;0x04000912);
1468    DFWORD(result, 1)=(DFWORD(dfl, 1) ^ DFWORD(dfr, 1))&amp;0x44912449;
1469    DFWORD(result, 2)=(DFWORD(dfl, 2) ^ DFWORD(dfr, 2))&amp;0x12449124;
1470    DFWORD(result, 3)=(DFWORD(dfl, 3) ^ DFWORD(dfr, 3))&amp;0x49124491;
1471   #endif
1472   return result;
1473   } 
1474 static decFloat *decInvalid(decFloat *result, decContext *set) {
1475   decFloatZero(result);
1476   DFWORD(result, 0)=DECFLOAT_qNaN;
1477   set-&gt;status|=DEC_Invalid_operation;
1478   return result;
1479   } 
1480 static decFloat *decInfinity(decFloat *result, const decFloat *df) {
1481   uInt sign=DFWORD(df, 0);           decFloatZero(result);              DFWORD(result, 0)=DECFLOAT_Inf | (sign &amp; DECFLOAT_Sign);
1482   return result;
1483   } 
1484 static decFloat *decNaNs(decFloat *result,
1485                          const decFloat *dfl, const decFloat *dfr,
1486                          decContext *set) {
1487   if (dfr!=NULL &amp;&amp; DFISSNAN(dfr) &amp;&amp; !DFISSNAN(dfl)) dfl=dfr;   if (DFISSNAN(dfl)) {
1488     decCanonical(result, dfl);              DFWORD(result, 0)&amp;=~(DECFLOAT_qNaN ^ DECFLOAT_sNaN);     set-&gt;status|=DEC_Invalid_operation;
1489     return result;
1490     }
1491   if (!DFISNAN(dfl)) dfl=dfr;             return decCanonical(result, dfl);       } 
1492 static Int decNumCompare(const decFloat *dfl, const decFloat *dfr, Flag tot) {
1493   Int   sigl, sigr;                       Int   shift;                            uByte *ub, *uc;                         uInt  uiwork;                           uByte bufl[DECPMAX*2+QUAD*2+4];         uByte bufr[DECPMAX*2+QUAD*2+4];       
1494   sigl=1;
1495   if (DFISSIGNED(dfl)) {
1496     if (!DFISSIGNED(dfr)) {                   if (DFISZERO(dfl) &amp;&amp; DFISZERO(dfr) &amp;&amp; !tot) return 0;
1497       return -1;                              }
1498     sigl=-1;
1499     }
1500   if (DFISSIGNED(dfr)) {
1501     if (!DFISSIGNED(dfl)) {                   if (DFISZERO(dfl) &amp;&amp; DFISZERO(dfr) &amp;&amp; !tot) return 0;
1502       return +1;                              }
1503     }
1504   sigr=-sigl;                           
1505   if (DFISINF(dfl)) {
1506     if (DFISINF(dfr)) return 0;             return sigl;                            }
1507   if (DFISINF(dfr)) return sigr;        
1508   shift=GETEXP(dfl)-GETEXP(dfr);        
1509   if (DFISZERO(dfl)) {
1510     if (!DFISZERO(dfr)) return sigr;        if (shift==0 || !tot) return 0;
1511     if (shift&gt;0) return sigl;
1512     return sigr;                            }
1513    else {                                   if (DFISZERO(dfr)) return sigl;         }
1514   if (abs(shift)&gt;=DECPMAX) {                if (shift&gt;0) return sigl;
1515     return sigr;                            }
1516   #if QUAD
1517     UBFROMUI(bufl, 0);
1518     UBFROMUI(bufr, 0);
1519   #endif
1520   GETCOEFF(dfl, bufl+QUAD*2);             GETCOEFF(dfr, bufr+QUAD*2);             if (shift==0) {                           for (ub=bufl, uc=bufr; ub&lt;bufl+DECPMAX+QUAD*2; ub+=4, uc+=4) {
1521       uInt ui=UBTOUI(ub);
1522       if (ui==UBTOUI(uc)) continue;           for (;; ub++, uc++) {
1523         if (*ub&gt;*uc) return sigl;               if (*ub&lt;*uc) return sigr;               }
1524       }
1525     }    else if (shift&gt;0) {                      ub=bufl;                                UBFROMUI(bufl+DECPMAX+QUAD*2, 0);       UBFROMUI(bufl+DECPMAX+QUAD*2+4, 0);     if (shift&gt;8) {
1526       uByte *up;                              uByte *upend=bufl+DECPMAX+QUAD*2+shift;
1527       for (up=bufl+DECPMAX+QUAD*2+8; up&lt;upend; up+=4) UBFROMUI(up, 0);
1528       for (;; ub+=4) {
1529         if (UBTOUI(ub)!=0) return sigl;
1530         if (ub+4&gt;bufl+shift-4) break;
1531         }
1532       }
1533     for (; ub&lt;bufl+shift; ub++) if (*ub!=0) return sigl;
1534     for (uc=bufr; ; uc+=4, ub+=4) {
1535       uInt ui=UBTOUI(ub);
1536       if (ui!=UBTOUI(uc)) {                     for (;; uc++, ub++) {                     if (*ub&gt;*uc) return sigl;               if (*ub&lt;*uc) return sigr;               }
1537         }       if (uc==bufr+QUAD*2+DECPMAX-4) break;       }
1538     } 
1539    else {     uc=bufr;                                UBFROMUI(bufr+DECPMAX+QUAD*2, 0);       UBFROMUI(bufr+DECPMAX+QUAD*2+4, 0);     if (shift&lt;-8) {
1540       uByte *up;                              uByte *upend=bufr+DECPMAX+QUAD*2-shift;
1541       for (up=bufr+DECPMAX+QUAD*2+8; up&lt;upend; up+=4) UBFROMUI(up, 0);
1542       for (;; uc+=4) {
1543         if (UBTOUI(uc)!=0) return sigr;
1544         if (uc+4&gt;bufr-shift-4) break;
1545         }
1546       }
1547     for (; uc&lt;bufr-shift; uc++) if (*uc!=0) return sigr;
1548     for (ub=bufl; ; ub+=4, uc+=4) {
1549       uInt ui=UBTOUI(ub);
1550       if (ui!=UBTOUI(uc)) {                     for (;; ub++, uc++) {                     if (*ub&gt;*uc) return sigl;               if (*ub&lt;*uc) return sigr;               }
1551         }       if (ub==bufl+QUAD*2+DECPMAX-4) break;       }
1552     } 
1553   if (!tot) return 0;                     if (shift&gt;0) return sigl;               if (shift&lt;0) return sigr;               return 0;
1554   } 
1555 static uInt decToInt32(const decFloat *df, decContext *set,
1556                        enum rounding rmode, Flag exact, Flag unsign) {
1557   Int  exp;                          uInt sourhi, sourpen, sourlo;      uInt hi, lo;                       decFloat zero, result;             Int  i;                          
1558   sourhi=DFWORD(df, 0);                   exp=DECCOMBEXP[sourhi&gt;&gt;26];             if (EXPISSPECIAL(exp)) {                  set-&gt;status|=DEC_Invalid_operation;     return 0;
1559     }
1560   if (GETEXPUN(df)==0) result=*df;         else {                                   enum rounding saveround;                uInt savestatus;                        saveround=set-&gt;round;                   savestatus=set-&gt;status;                 set-&gt;round=rmode;                       decFloatZero(&amp;zero);                    set-&gt;status=0;                          decFloatQuantize(&amp;result, df, &amp;zero, set);     set-&gt;round=saveround;                   if (exact) set-&gt;status|=savestatus;      else set-&gt;status=savestatus;           }
1561   #if DOUBLE
1562   if ((DFWORD(&amp;result, 0)&amp;0x1c03ff00)!=0
1563    || (DFWORD(&amp;result, 0)&amp;0x60000000)==0x60000000) {
1564   #elif QUAD
1565   if ((DFWORD(&amp;result, 2)&amp;0xffffff00)!=0
1566    ||  DFWORD(&amp;result, 1)!=0
1567    || (DFWORD(&amp;result, 0)&amp;0x1c003fff)!=0
1568    || (DFWORD(&amp;result, 0)&amp;0x60000000)==0x60000000) {
1569   #endif
1570     set-&gt;status|=DEC_Invalid_operation;     return 0;
1571     }
1572   sourlo=DFWORD(&amp;result, DECWORDS-1);
1573   lo=DPD2BIN0[sourlo&amp;0x3ff]
1574     +DPD2BINK[(sourlo&gt;&gt;10)&amp;0x3ff]
1575     +DPD2BINM[(sourlo&gt;&gt;20)&amp;0x3ff];
1576   sourpen=DFWORD(&amp;result, DECWORDS-2);
1577   hi=DPD2BIN0[((sourpen&lt;&lt;2) | (sourlo&gt;&gt;30))&amp;0x3ff];
1578   if (unsign) {
1579     if (hi&gt;4 || (hi==4 &amp;&amp; lo&gt;294967295) || (hi+lo!=0 &amp;&amp; DFISSIGNED(&amp;result))) {
1580       set-&gt;status|=DEC_Invalid_operation;       return 0;
1581       }
1582     return hi*BILLION+lo;
1583     }
1584   if (hi&gt;2 || (hi==2 &amp;&amp; lo&gt;147483647)) {
1585     if (lo==147483648 &amp;&amp; hi==2 &amp;&amp; DFISSIGNED(&amp;result)) return 0x80000000;
1586     set-&gt;status|=DEC_Invalid_operation;     return 0;
1587     }
1588   i=hi*BILLION+lo;
1589   if (DFISSIGNED(&amp;result)) i=-i;
1590   return (uInt)i;
1591   } 
1592 static decFloat * decToIntegral(decFloat *result, const decFloat *df,
1593                                 decContext *set, enum rounding rmode,
1594                                 Flag exact) {
1595   Int  exp;                          uInt sourhi;                       enum rounding saveround;           uInt savestatus;                   decFloat zero;                   
1596   sourhi=DFWORD(df, 0);              exp=DECCOMBEXP[sourhi&gt;&gt;26];      
1597   if (EXPISSPECIAL(exp)) {             if (DFISNAN(df)) return decNaNs(result, df, NULL, set);
1598     return decInfinity(result, df);
1599     }
1600   exp+=GETECON(df)-DECBIAS;             
1601   if (exp&gt;=0) return decCanonical(result, df); 
1602   saveround=set-&gt;round;                   savestatus=set-&gt;status;                 set-&gt;round=rmode;                       decFloatZero(&amp;zero);                    decFloatQuantize(result, df, &amp;zero, set);   set-&gt;round=saveround;                   if (!exact) set-&gt;status=savestatus;     return result;
  } </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
