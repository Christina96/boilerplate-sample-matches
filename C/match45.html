<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for parser.h &amp; decBasic.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for parser.h &amp; decBasic.c
      </h3>
<h1 align="center">
        2.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>parser.h (44.594593%)<th>decBasic.c (1.3100437%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(94-111)<td><a href="#" name="0">(1187-1215)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(67-81)<td><a href="#" name="1">(3120-3150)</a><td align="center"><font color="#d40000">15</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>parser.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifndef YY_YY_SRC_PARSER_H_INCLUDED
# define YY_YY_SRC_PARSER_H_INCLUDED
#ifndef YYDEBUG
# define YYDEBUG 0
#endif
#if YYDEBUG
extern int yydebug;
#endif
#line 11 "src/parser.y" 
#include "locfile.h"
struct lexer_param;
#define YYLTYPE location
#define YYLLOC_DEFAULT(Loc, Rhs, N)             \
  do {                                          \
    if (N) {                                    \
      (Loc).start = YYRHSLOC(Rhs, 1).start;     \
      (Loc).end = YYRHSLOC(Rhs, N).end;         \
    } else {                                    \
      (Loc).start = YYRHSLOC(Rhs, 0).end;       \
      (Loc).end = YYRHSLOC(Rhs, 0).end;         \
    }                                           \
  } while (0)
#line 61 "src/parser.h" 
#ifndef YYTOKENTYPE
<a name="1"></a># define YYTOKENTYPE
  enum yytokentype
  {
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    INVALID_CHARACTER = 258,
    IDENT = 259,
    FIELD = 260,
    LITERAL = 261,
    FORMAT = 262,
    REC = 263,
    SETMOD = 264,
    EQ = 265,
    NEQ = 266,
    DEFINEDOR = 267,
    AS = 268,
    DEF = 269,
    MODULE = 270,
    IMPORT = 271,
    INCLUDE = 272,</b></font>
    IF = 273,
    THEN = 274,
    ELSE = 275,
    ELSE_IF = 276,
    REDUCE = 277,
    FOREACH = 278,
    END = 279,
    AND = 280,
    OR = 281,
<a name="0"></a>    TRY = 282,
    CATCH = 283,
    LABEL = 284,
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    BREAK = 285,
    LOC = 286,
    SETPIPE = 287,
    SETPLUS = 288,
    SETMINUS = 289,
    SETMULT = 290,
    SETDIV = 291,
    SETDEFINEDOR = 292,
    LESSEQ = 293,
    GREATEREQ = 294,
    ALTERNATION = 295,
    QQSTRING_START = 296,
    QQSTRING_TEXT = 297,
    QQSTRING_INTERP_START = 298,
    QQSTRING_INTERP_END = 299,
    QQSTRING_END = 300,
    FUNCDEF = 301,
    NONOPT = 302</b></font>
  };
#endif
#define INVALID_CHARACTER 258
#define IDENT 259
#define FIELD 260
#define LITERAL 261
#define FORMAT 262
#define REC 263
#define SETMOD 264
#define EQ 265
#define NEQ 266
#define DEFINEDOR 267
#define AS 268
#define DEF 269
#define MODULE 270
#define IMPORT 271
#define INCLUDE 272
#define IF 273
#define THEN 274
#define ELSE 275
#define ELSE_IF 276
#define REDUCE 277
#define FOREACH 278
#define END 279
#define AND 280
#define OR 281
#define TRY 282
#define CATCH 283
#define LABEL 284
#define BREAK 285
#define LOC 286
#define SETPIPE 287
#define SETPLUS 288
#define SETMINUS 289
#define SETMULT 290
#define SETDIV 291
#define SETDEFINEDOR 292
#define LESSEQ 293
#define GREATEREQ 294
#define ALTERNATION 295
#define QQSTRING_START 296
#define QQSTRING_TEXT 297
#define QQSTRING_INTERP_START 298
#define QQSTRING_INTERP_END 299
#define QQSTRING_END 300
#define FUNCDEF 301
#define NONOPT 302
#if ! defined YYSTYPE &amp;&amp; ! defined YYSTYPE_IS_DECLARED
union YYSTYPE
{
#line 31 "src/parser.y" 
  jv literal;
  block blk;
#line 172 "src/parser.h" };
typedef union YYSTYPE YYSTYPE;
# define YYSTYPE_IS_TRIVIAL 1
# define YYSTYPE_IS_DECLARED 1
#endif
#if ! defined YYLTYPE &amp;&amp; ! defined YYLTYPE_IS_DECLARED
typedef struct YYLTYPE YYLTYPE;
struct YYLTYPE
{
  int first_line;
  int first_column;
  int last_line;
  int last_column;
};
# define YYLTYPE_IS_DECLARED 1
# define YYLTYPE_IS_TRIVIAL 1
#endif
int yyparse (block* answer, int* errors, struct locfile* locations, struct lexer_param* lexer_param_ptr);
#endif </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>decBasic.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#if !defined(QUAD)
  #error decBasic.c must be included after decCommon.c
#endif
#if SINGLE
  #error Routines in decBasic.c are for decDouble and decQuad only
#endif
#define DIVIDE      0x80000000     #define REMAINDER   0x40000000     #define DIVIDEINT   0x20000000     #define REMNEAR     0x10000000     
static decFloat *decDivide(decFloat *, const decFloat *,
                              const decFloat *, decContext *, uInt);
static decFloat *decCanonical(decFloat *, const decFloat *);
static void      decFiniteMultiply(bcdnum *, uByte *, const decFloat *,
                              const decFloat *);
static decFloat *decInfinity(decFloat *, const decFloat *);
static decFloat *decInvalid(decFloat *, decContext *);
static decFloat *decNaNs(decFloat *, const decFloat *, const decFloat *,
                              decContext *);
static Int       decNumCompare(const decFloat *, const decFloat *, Flag);
static decFloat *decToIntegral(decFloat *, const decFloat *, decContext *,
                              enum rounding, Flag);
static uInt      decToInt32(const decFloat *, decContext *, enum rounding,
                              Flag, Flag);
static decFloat * decCanonical(decFloat *result, const decFloat *df) {
  uInt encode, precode, dpd;         uInt inword, uoff, canon;          Int  n;                            if (df!=result) *result=*df;       if (DFISSPECIAL(result)) {
    if (DFISINF(result)) return decInfinity(result, df);     DFWORD(result, 0)&amp;=~ECONNANMASK;        if (DFISCCZERO(df)) return result;      }
  {   #if DOUBLE
    uInt sourhi=DFWORD(df, 0);
    uInt sourlo=DFWORD(df, 1);
    if (CANONDPDOFF(sourhi, 8)
     &amp;&amp; CANONDPDTWO(sourhi, sourlo, 30)
     &amp;&amp; CANONDPDOFF(sourlo, 20)
     &amp;&amp; CANONDPDOFF(sourlo, 10)
     &amp;&amp; CANONDPDOFF(sourlo, 0)) return result;
  #elif QUAD
    uInt sourhi=DFWORD(df, 0);
    uInt sourmh=DFWORD(df, 1);
    uInt sourml=DFWORD(df, 2);
    uInt sourlo=DFWORD(df, 3);
    if (CANONDPDOFF(sourhi, 4)
     &amp;&amp; CANONDPDTWO(sourhi, sourmh, 26)
     &amp;&amp; CANONDPDOFF(sourmh, 16)
     &amp;&amp; CANONDPDOFF(sourmh, 6)
     &amp;&amp; CANONDPDTWO(sourmh, sourml, 28)
     &amp;&amp; CANONDPDOFF(sourml, 18)
     &amp;&amp; CANONDPDOFF(sourml, 8)
     &amp;&amp; CANONDPDTWO(sourml, sourlo, 30)
     &amp;&amp; CANONDPDOFF(sourlo, 20)
     &amp;&amp; CANONDPDOFF(sourlo, 10)
     &amp;&amp; CANONDPDOFF(sourlo, 0)) return result;
  #endif
  } 
  inword=DECWORDS-1;                 uoff=0;                            encode=DFWORD(result, inword);
  for (n=DECLETS-1; n&gt;=0; n--) {       dpd=encode&gt;&gt;uoff;
    uoff+=10;
    if (uoff&gt;32) {                       inword--;
      encode=DFWORD(result, inword);
      uoff-=32;
      dpd|=encode&lt;&lt;(10-uoff);            }
    dpd&amp;=0x3ff;                        if (dpd&lt;0x16e) continue;           canon=BIN2DPD[DPD2BIN[dpd]];       if (canon==dpd) continue;          if (uoff&gt;=10) {                      encode&amp;=~(0x3ff&lt;&lt;(uoff-10));       encode|=canon&lt;&lt;(uoff-10);          DFWORD(result, inword)=encode;          continue;
      }
    precode=DFWORD(result, inword+1);       precode&amp;=0xffffffff&gt;&gt;(10-uoff);         DFWORD(result, inword+1)=precode|(canon&lt;&lt;(32-(10-uoff)));
    encode&amp;=0xffffffff&lt;&lt;uoff;               encode|=canon&gt;&gt;(10-uoff);               DFWORD(result, inword)=encode;          }   return result;
  } 
#define DIVCOUNT  0                #define DIVBASE   ((uInt)BILLION)  #define DIVOPLEN  DECPMAX9         #define DIVACCLEN (DIVOPLEN*3)     static decFloat * decDivide(decFloat *result, const decFloat *dfl,
                            const decFloat *dfr, decContext *set, uInt op) {
  decFloat quotient;                 bcdnum num;                        uInt   acc[DIVACCLEN];             uInt   div[DIVOPLEN];              uInt   quo[DIVOPLEN+1];            uByte  bcdacc[(DIVOPLEN+1)*9+2];   uInt   *msua, *msud, *msuq;        Int    divunits, accunits;         Int    quodigits;                  uInt   *lsua, *lsuq;               Int    length, multiplier;         uInt   carry, sign;                uInt   *ua, *ud, *uq;              uByte  *ub;                        uInt   uiwork;                     uInt   divtop;                     #if DIVCOUNT
  static uInt maxcount=0;            uInt   divcount=0;                 #endif
  num.sign=(DFWORD(dfl, 0)^DFWORD(dfr, 0)) &amp; DECFLOAT_Sign;
  if (DFISSPECIAL(dfl) || DFISSPECIAL(dfr)) {     if (DFISNAN(dfl) || DFISNAN(dfr)) return decNaNs(result, dfl, dfr, set);
    if (DFISINF(dfl)) {
      if (DFISINF(dfr)) return decInvalid(result, set);       if (op&amp;(REMAINDER|REMNEAR)) return decInvalid(result, set);       DFWORD(result, 0)=num.sign;
      return decInfinity(result, result);
      }
    if (op&amp;(REMAINDER|REMNEAR)) return decCanonical(result, dfl);
    decFloatZero(result);
    if (op==DIVIDEINT) DFWORD(result, 0)|=num.sign;      else DFWORD(result, 0)=num.sign;            return result;
    }
  if (DFISZERO(dfr)) {                           if (DFISZERO(dfl)) {                           decFloatZero(result);
      DFWORD(result, 0)=DECFLOAT_qNaN;
      set-&gt;status|=DEC_Division_undefined;
      return result;
      }
    if (op&amp;(REMAINDER|REMNEAR)) return decInvalid(result, set);     set-&gt;status|=DEC_Division_by_zero;
    DFWORD(result, 0)=num.sign;
    return decInfinity(result, result);          }
  num.exponent=GETEXPUN(dfl)-GETEXPUN(dfr);    if (DFISZERO(dfl)) {                           if (op&amp;DIVIDEINT) {
      decFloatZero(result);
      DFWORD(result, 0)|=num.sign;                 return result;
      }
    if (!(op&amp;DIVIDE)) {                            num.exponent=MINI(GETEXPUN(dfl), GETEXPUN(dfr));
      num.sign=DFWORD(dfl, 0)&amp;DECFLOAT_Sign;
      }
    bcdacc[0]=0;
    num.msd=bcdacc;                              num.lsd=bcdacc;                              return decFinalize(result, &amp;num, set);       } 
  GETCOEFFBILL(dfl, acc+DIVACCLEN-DIVOPLEN);
  GETCOEFFBILL(dfr, div);
  acc[0]=0;
  acc[1]=0;
  acc[2]=0;
  acc[3]=0;
  #if DOUBLE
    #if DIVOPLEN!=2
      #error Unexpected Double DIVOPLEN
    #endif
  #elif QUAD
  acc[4]=0;
  acc[5]=0;
  acc[6]=0;
  acc[7]=0;
    #if DIVOPLEN!=4
      #error Unexpected Quad DIVOPLEN
    #endif
  #endif
  msua=acc+DIVACCLEN-1;         msuq=quo+DIVOPLEN;
  for (msud=div+DIVOPLEN-1; *msud==0;) msud--;
  divunits=(Int)(msud-div+1);   lsua=msua-divunits+1;         lsuq=msuq;                  
  divtop=*msud&lt;&lt;2;
  if (divunits&gt;1) {
    uInt *um=msud-1;
    uInt d=*um;
    if (d&gt;=750000000) {divtop+=3; d-=750000000;}
     else if (d&gt;=500000000) {divtop+=2; d-=500000000;}
     else if (d&gt;=250000000) {divtop++; d-=250000000;}
    if (d) divtop++;
     else for (um--; um&gt;=div; um--) if (*um) {
      divtop++;
      break;
      }
    } 
  #if DECTRACE
  {Int i;
  printf("----- div=");
  for (i=divunits-1; i&gt;=0; i--) printf("%09ld ", (LI)div[i]);
  printf("\n");}
  #endif
  quodigits=0;                  for (;; lsua--) {               #if DECCHECK
    if (lsua&lt;acc) {
      printf("Acc underrun...\n");
      break;
      }
    #endif
    #if DECTRACE
    printf("Outer: quodigits=%ld acc=", (LI)quodigits);
    for (ua=msua; ua&gt;=lsua; ua--) printf("%09ld ", (LI)*ua);
    printf("\n");
    #endif
    *lsuq=0;                      for (;;) {                      for (; *msua==0 &amp;&amp; msua&gt;=lsua;) msua--;
      accunits=(Int)(msua-lsua+1);                      if (accunits&lt;divunits) {
        if (accunits==0) msua++;                          break;
        }
      if (accunits==divunits) {
        for (ud=msud, ua=msua; ud&gt;div; ud--, ua--) if (*ud!=*ua) break;
        if (*ud&gt;*ua) break;                               if (*ud==*ua) {                                     *lsuq+=1;                                         msua=lsua;                                        *msua=0;                                          break;
          }
        #define DIVLO 1000000U
        #define DIVHI (DIVBASE/DIVLO)
        #if DECUSE64
          if (divunits&gt;1) {
            uLong mul=(uLong)*msua * DIVBASE + *(msua-1);
            uLong div=(uLong)*msud * DIVBASE + *(msud-1);
            #if QUAD
            if (divunits&gt;2) div++;
            #endif
            mul/=div;
            multiplier=(Int)mul;
            }
           else multiplier=*msua/(*msud);
        #else
          if (divunits&gt;1 &amp;&amp; *msua&lt;DIVLO &amp;&amp; *msud&lt;DIVLO) {
            multiplier=(*msua*DIVHI + *(msua-1)/DIVLO)
                      /(*msud*DIVHI + *(msud-1)/DIVLO +1);
            }
           else multiplier=(*msua&lt;&lt;2)/divtop;
        #endif
        }
       else {                                             #if DECUSE64
          uLong mul;
          if (divunits&gt;1 &amp;&amp; *msua&lt;DIVLO &amp;&amp; *msud&lt;DIVLO) {
            mul=((uLong)*msua * DIVHI * DIVBASE) + *(msua-1) * DIVHI
               + *(msua-2)/DIVLO;
            mul/=(*msud*DIVHI + *(msud-1)/DIVLO +1);
            }
           else if (divunits==1) {
            mul=(uLong)*msua * DIVBASE + *(msua-1);
            mul/=*msud;                   }
           else {
            mul=(uLong)(*msua) * (uInt)(DIVBASE&lt;&lt;2)
                + (*(msua-1)&lt;&lt;2);
            mul/=divtop;                  }
          multiplier=(Int)mul;
        #else
          multiplier=*msua * ((DIVBASE&lt;&lt;2)/divtop);
        #endif
        }
      if (multiplier==0) multiplier=1;                  *lsuq+=multiplier;
      #if DIVCOUNT
      divcount++;
      #endif
      #define DIVMAGIC  2305843009U                     #define DIVSHIFTA 29
      #define DIVSHIFTB 32
      carry=0;
      for (ud=div, ua=lsua; ud&lt;=msud; ud++, ua++) {
        uInt lo, hop;
        #if DECUSE64
          uLong sub=(uLong)multiplier*(*ud)+carry;
          if (sub&lt;DIVBASE) {
            carry=0;
            lo=(uInt)sub;
            }
           else {
            hop=(uInt)(sub&gt;&gt;DIVSHIFTA);
            carry=(uInt)(((uLong)hop*DIVMAGIC)&gt;&gt;DIVSHIFTB);
            lo=(uInt)sub;
            lo-=carry*DIVBASE;                                if (lo&gt;=DIVBASE) {
              lo-=DIVBASE;                                      carry++;
              }
            }
        #else           uInt hi;
          LONGMUL32HI(hi, *ud, multiplier);                 lo=multiplier*(*ud);                              lo+=carry;                                        carry=hi+(lo&lt;carry);                              if (carry || lo&gt;=DIVBASE) {                         hop=(carry&lt;&lt;3)+(lo&gt;&gt;DIVSHIFTA);                   LONGMUL32HI(carry, hop, DIVMAGIC);                lo-=(carry*DIVBASE);
            if (lo&gt;=DIVBASE) {
              lo-=DIVBASE;
              carry++;
              }
            }
        #endif
        if (lo&gt;*ua) {                        *ua+=DIVBASE;
          carry++;
          }
        *ua-=lo;
        }       if (carry) *ua-=carry;             } 
    #if DECTRACE
    if (*lsuq || quodigits) printf("*lsuq=%09ld\n", (LI)*lsuq);
    #endif
    if (quodigits) {
      quodigits+=9;                      lsuq--;
      if (quodigits&gt;DECPMAX+1) break;         }
     else if (*lsuq) {                   const uInt *pow;
      for (pow=DECPOWERS; *lsuq&gt;=*pow; pow++) quodigits++;
      lsuq--;
      }
    if (*msua!=0) continue;            if (lsua&gt;acc+DIVACCLEN-DIVOPLEN) continue;
    for (; msua&gt;lsua &amp;&amp; *msua==0;) msua--;
    if (*msua==0 &amp;&amp; msua==lsua) break;
    } 
  lsuq++;                            if (*msua) *lsuq|=1;             
  #if DECTRACE
  printf("DivQuo:");
  for (uq=msuq; uq&gt;=lsuq; uq--) printf(" %09ld", (LI)*uq);
  printf("\n");
  #endif
  for (uq=msuq, ub=bcdacc+1; uq&gt;=lsuq; uq--, ub+=9) {
    uInt top, mid, rem;                     if (*uq==0) {                             UBFROMUI(ub, 0);                        UBFROMUI(ub+4, 0);                      *(ub+8)=0;                              continue;
      }
    #define divsplit9 1000000               #define divsplit6 1000                  top=*uq/divsplit9;
    rem=*uq%divsplit9;
    mid=rem/divsplit6;
    rem=rem%divsplit6;
    UBFROMUI(ub,   UBTOUI(&amp;BIN2BCD8[top*4]));
    UBFROMUI(ub+3, UBTOUI(&amp;BIN2BCD8[mid*4]));
    UBFROMUI(ub+6, UBTOUI(&amp;BIN2BCD8[rem*4]));
    }   ub--;                                 
  num.msd=bcdacc+1+(msuq-lsuq+1)*9-quodigits;
  num.lsd=ub;
  if (lsua&lt;acc+DIVACCLEN-DIVOPLEN) {        num.exponent-=(Int)((acc+DIVACCLEN-DIVOPLEN-lsua)*9);
    if (*msua==0) {
      for (; *ub==0;) ub--;                   num.exponent+=(Int)(num.lsd-ub);        num.lsd=ub;
      }
    } 
  #if DIVCOUNT
  if (divcount&gt;maxcount) {                  maxcount=divcount;
    printf("DivNewMaxCount: %ld\n", (LI)maxcount);
    }
  #endif
  if (op&amp;DIVIDE) return decFinalize(result, &amp;num, set); 
  length=(Int)(num.lsd-num.msd+1);
  if (length+num.exponent&gt;DECPMAX) {     decFloatZero(result);
    DFWORD(result, 0)=DECFLOAT_qNaN;
    set-&gt;status|=DEC_Division_impossible;
    return result;
    }
  if (num.exponent&gt;=0) {               for (ub=num.lsd+1; ub&lt;=num.lsd+num.exponent; ub++) *ub=0;
    num.lsd+=num.exponent;
    }
   else {                              Int drop=-num.exponent;
    if (!(op&amp;REMNEAR)) {                 num.lsd-=drop;
      if (num.lsd&lt;num.msd) {               num.lsd=num.msd;                   *num.lsd=0;                        }
      }
     else {                              uByte *roundat;                    uByte reround;                     *(num.msd-1)=0;                    if (drop&lt;length) roundat=num.lsd-drop+1;
       else if (drop==length) roundat=num.msd;
       else roundat=num.msd-1;           reround=*roundat;
      for (ub=roundat+1; ub&lt;=num.lsd; ub++) {
        if (*ub!=0) {
          reround=DECSTICKYTAB[reround];
          break;
          }
        }       if (roundat&gt;num.msd) num.lsd=roundat-1;
       else {
        num.msd--;                                   num.lsd=num.msd;                             }
      if (reround!=0) {                              uInt bump=0;
        if (reround&gt;5) bump=1;                        else if (reround==5)                          bump=*(num.lsd) &amp; 0x01;                    if (bump!=0) {                                 ub=num.lsd;
          for (; UBTOUI(ub-3)==0x09090909; ub-=4) UBFROMUI(ub-3, 0);
          for (; *ub==9; ub--) *ub=0;                  *ub+=1;
          if (ub&lt;num.msd) num.msd--;                   }         }       }     }   num.exponent=0;                            
  if (op&amp;DIVIDEINT) return decFinalize(result, &amp;num, set); 
  decFinalize(&amp;quotient, &amp;num, set);           DFWORD(&amp;quotient, 0)^=DECFLOAT_Sign;         sign=DFWORD(dfl, 0);                         decFloatFMA(result, &amp;quotient, dfr, dfl, set);
  if (!DFISZERO(result)) return result;
  DFWORD(&amp;quotient, 0)=sign;                   return decFloatCopySign(result, result, &amp;quotient);
  } 
#define MULTBASE  ((uInt)BILLION)  #define MULOPLEN  DECPMAX9         #define MULACCLEN (MULOPLEN*2)              #define LEADZEROS (MULACCLEN*9 - DECPMAX*2) 
#if DECEMAXD&gt;9
  #error Exponent may overflow when doubled for Multiply
#endif
#if MULACCLEN!=(MULACCLEN/4)*4
  #error MULACCLEN is not a multiple of 4
#endif
static void decFiniteMultiply(bcdnum *num, uByte *bcdacc,
                              const decFloat *dfl, const decFloat *dfr) {
  uInt   bufl[MULOPLEN];             uInt   bufr[MULOPLEN];             uInt   *ui, *uj;                   uByte  *ub;                        uInt   uiwork;                   
  #if DECUSE64
  uLong  accl[MULACCLEN];            uLong  *pl;                        uInt   acc[MULACCLEN];             #else
  uInt   acc[MULACCLEN*2];           #endif
  uInt   *pa;                      
  num-&gt;sign=(DFWORD(dfl, 0)^DFWORD(dfr, 0)) &amp; DECFLOAT_Sign;
  num-&gt;exponent=GETEXPUN(dfl)+GETEXPUN(dfr); 
  GETCOEFFBILL(dfl, bufl);
  GETCOEFFBILL(dfr, bufr);
  #if DECTRACE &amp;&amp; 0
    printf("CoeffbL:");
    for (ui=bufl+MULOPLEN-1; ui&gt;=bufl; ui--) printf(" %08lx", (LI)*ui);
    printf("\n");
    printf("CoeffbR:");
    for (uj=bufr+MULOPLEN-1; uj&gt;=bufr; uj--) printf(" %08lx", (LI)*uj);
    printf("\n");
  #endif
#if DECUSE64
  #if MULACCLEN==4
    accl[0]=0; accl[1]=0; accl[2]=0; accl[3]=0;
  #else                                          for (pl=accl; pl&lt;accl+MULACCLEN; pl+=4) {
      *pl=0; *(pl+1)=0; *(pl+2)=0; *(pl+3)=0;      }   #endif
  for (ui=bufr; ui&lt;bufr+MULOPLEN; ui++) {     if (*ui==0) continue;                     pl=accl+(ui-bufr);                        for (uj=bufl; uj&lt;bufl+MULOPLEN; uj++, pl++) {       *pl+=((uLong)*ui)*(*uj);
      }     } 
  #define MULMAGIC 2305843009U            #if DOUBLE
    #define MULSHIFTA 29
    #define MULSHIFTB 32
  #elif QUAD
    #define MULSHIFTA 30
    #define MULSHIFTB 31
  #else
    #error Unexpected type
  #endif
  #if DECTRACE
  printf("MulAccl:");
  for (pl=accl+MULACCLEN-1; pl&gt;=accl; pl--)
    printf(" %08lx:%08lx", (LI)(*pl&gt;&gt;32), (LI)(*pl&amp;0xffffffff));
  printf("\n");
  #endif
  for (pl=accl, pa=acc; pl&lt;accl+MULACCLEN; pl++, pa++) {     uInt lo, hop;                           uInt est;                               if (*pl&gt;=MULTBASE) {
      hop=(uInt)(*pl&gt;&gt;MULSHIFTA);
      est=(uInt)(((uLong)hop*MULMAGIC)&gt;&gt;MULSHIFTB);
      lo=(uInt)(*pl-((uLong)est*MULTBASE));        if (lo&gt;=MULTBASE) {
        lo-=MULTBASE;                           est++;
        #if QUAD
        if (lo&gt;=MULTBASE) {
          lo-=MULTBASE;
          est++;
          }
        #endif
        }
      *pa=lo;
      *(pl+1)+=est;
      }      else {                                   *pa=(uInt)*pl;                          }
    } 
#else    for (pa=acc;; pa+=4) {                         *pa=0; *(pa+1)=0; *(pa+2)=0; *(pa+3)=0;      if (pa==acc+MULACCLEN*2-4) break;            } 
  for (ui=bufr;; ui++) {                    uInt hi, lo;                            pa=acc+(ui-bufr);                       for (uj=bufl;; uj++, pa++) {              LONGMUL32HI(hi, *ui, *uj);              lo=(*ui)*(*uj);                         *pa+=lo;                                *(pa+MULACCLEN)+=hi+(*pa&lt;lo);           if (uj==bufl+MULOPLEN-1) break;
      }
    if (ui==bufr+MULOPLEN-1) break;
    }
  #define MULMAGIC 2305843009U            #if DOUBLE
    #define MULSHIFTA 29
    #define MULSHIFTB 32
  #elif QUAD
    #define MULSHIFTA 30
    #define MULSHIFTB 31
  #else
    #error Unexpected type
  #endif
  #if DECTRACE
  printf("MulHiLo:");
  for (pa=acc+MULACCLEN-1; pa&gt;=acc; pa--)
    printf(" %08lx:%08lx", (LI)*(pa+MULACCLEN), (LI)*pa);
  printf("\n");
  #endif
  for (pa=acc;; pa++) {                     uInt hi, lo;                            uInt hop, estlo;                        #if QUAD
    uInt esthi;                             #endif
    lo=*pa;
    hi=*(pa+MULACCLEN);                 
    #if DOUBLE
      hop=(hi&lt;&lt;3)+(lo&gt;&gt;MULSHIFTA);            LONGMUL32HI(estlo, hop, MULMAGIC);      lo-=(estlo*MULTBASE);
      if (lo&gt;=MULTBASE) {
        lo-=MULTBASE;
        estlo++;
        }
    #elif QUAD
      hop=(hi&lt;&lt;2)+(lo&gt;&gt;MULSHIFTA);            LONGMUL32HI(esthi, hop, MULMAGIC);      estlo=hop*MULMAGIC;                     estlo=(esthi&lt;&lt;1)+(estlo&gt;&gt;MULSHIFTB);       lo-=(estlo*MULTBASE);                   if (lo&gt;=MULTBASE) {
        lo-=MULTBASE;
        estlo++;
        }
      if (lo&gt;=MULTBASE) {
        lo-=MULTBASE;
        estlo++;
        }
    #else
      #error Unexpected type
    #endif
    *pa=lo;
    *(pa+1)+=estlo;
    if (*(pa+1)&lt;estlo) *(pa+1+MULACCLEN)+=1;     if (pa==acc+MULACCLEN-2) break;              } #endif
  #if DECTRACE
  printf("MultAcc:");
  for (pa=acc+MULACCLEN-1; pa&gt;=acc; pa--) printf(" %09ld", (LI)*pa);
  printf("\n");
  #endif
  pa=acc+MULACCLEN-1;
  if (*pa!=0) num-&gt;msd=bcdacc+LEADZEROS;   else {                                   num-&gt;msd=bcdacc;                        pa--;                                   for (; *pa==0; pa--) if (pa==acc) break;     }
  for (ub=bcdacc;; pa--, ub+=9) {
    if (*pa!=0) {                             uInt top, mid, rem;                     #define mulsplit9 1000000               #define mulsplit6 1000                  top=*pa/mulsplit9;
      rem=*pa%mulsplit9;
      mid=rem/mulsplit6;
      rem=rem%mulsplit6;
      UBFROMUI(ub,   UBTOUI(&amp;BIN2BCD8[top*4]));
      UBFROMUI(ub+3, UBTOUI(&amp;BIN2BCD8[mid*4]));
      UBFROMUI(ub+6, UBTOUI(&amp;BIN2BCD8[rem*4]));
      }
     else {                                   UBFROMUI(ub, 0);                        UBFROMUI(ub+4, 0);                      *(ub+8)=0;                              }
    if (pa==acc) break;
    } 
  num-&gt;lsd=ub+8;                        
  #if DECTRACE
  decShowNum(num, "postmult");
  decFloatShow(dfl, "dfl");
  decFloatShow(dfr, "dfr");
  #endif
  return;
  } 
decFloat * decFloatAbs(decFloat *result, const decFloat *df,
                       decContext *set) {
  if (DFISNAN(df)) return decNaNs(result, df, NULL, set);
  decCanonical(result, df);               DFBYTE(result, 0)&amp;=~0x80;               return result;
  } 
#if QUAD
const Int DECTESTMSD[64]={
  0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5,   6,    7,
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 9, 8, 9, -32, -128,
  0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5,   6,    7,
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 9, 8, 9, -32, -128};
#else
extern const Int DECTESTMSD[64];
#endif
decFloat * decFloatAdd(decFloat *result,
                       const decFloat *dfl, const decFloat *dfr,
                       decContext *set) {
  bcdnum num;                        Int    bexpl, bexpr;               uByte  *ub, *us, *ut;              uInt   uiwork;                     #if QUAD
  uShort uswork;                     #endif
  uInt sourhil, sourhir;             uInt diffsign;                     uInt carry;                        Int  overlap;                      Int  summ;                         uByte acc[4+2+DECPMAX*3+8];
  uByte buf[4+2+DECPMAX*2];
  uByte *umsd, *ulsd;              
  #if DECLITEND
    #define CARRYPAT 0x01000000      #else
    #define CARRYPAT 0x00000001      #endif
  sourhil=DFWORD(dfl, 0);            summ=DECTESTMSD[sourhil&gt;&gt;26];      bexpr=DECCOMBEXP[sourhil&gt;&gt;26];     bexpr+=GETECON(dfl);             
  sourhir=DFWORD(dfr, 0);            summ+=DECTESTMSD[sourhir&gt;&gt;26];     bexpl=DECCOMBEXP[sourhir&gt;&gt;26];
  bexpl+=GETECON(dfr);
  diffsign=(sourhil^sourhir)&amp;DECFLOAT_Sign;
  if (summ&lt;=8) {                       if (summ&lt;0) {                        if (summ&lt;-64) return decNaNs(result, dfl, dfr, set);        if (summ==-64 &amp;&amp; diffsign) return decInvalid(result, set);
      if (DFISINF(dfl)) return decInfinity(result, dfl);          return decInfinity(result, dfr);                            }
    if (bexpr==bexpl &amp;&amp; !diffsign) {
      uInt tac[DECLETS+1];                    uInt encode;                      
      GETCOEFFTHOU(dfl, tac);                 ADDCOEFFTHOU(dfr, tac);
<a name="0"></a>      
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>      encode =BIN2DPD[tac[0]];
      encode|=BIN2DPD[tac[1]]&lt;&lt;10;
      encode|=BIN2DPD[tac[2]]&lt;&lt;20;
      encode|=BIN2DPD[tac[3]]&lt;&lt;30;
      DFWORD(result, (DECBYTES/4)-1)=encode;
      encode =BIN2DPD[tac[3]]&gt;&gt;2;
      encode|=BIN2DPD[tac[4]]&lt;&lt;8;
      #if QUAD
      encode|=BIN2DPD[tac[5]]&lt;&lt;18;
      encode|=BIN2DPD[tac[6]]&lt;&lt;28;
      DFWORD(result, 2)=encode;
      encode =BIN2DPD[tac[6]]&gt;&gt;4;
      encode|=BIN2DPD[tac[7]]&lt;&lt;6;
      encode|=BIN2DPD[tac[8]]&lt;&lt;16;
      encode|=BIN2DPD[tac[9]]&lt;&lt;26;
      DFWORD(result, 1)=encode;
      encode =BIN2DPD[tac[9]]&gt;&gt;6;
      encode|=BIN2DPD[tac[10]]&lt;&lt;4;
      #endif
      encode|=sourhil &amp; (ECONMASK | DECFLOAT_Sign);</b></font>
      tac[DECLETS]|=(bexpl&gt;&gt;DECECONL)&lt;&lt;4;
      encode|=DECCOMBFROM[tac[DECLETS]];       DFWORD(result, 0)=encode;          
      return result;
      }     } 
  if (bexpl&lt;=bexpr) {
    Int bexpswap=bexpl;
    bexpl=bexpr;
    bexpr=bexpswap;
    }
   else {
    const decFloat *dfswap=dfl;
    dfl=dfr;
    dfr=dfswap;
    }
  if (DFISZERO(dfl)) {
    decCanonical(result, dfr);                   if (diffsign &amp;&amp; DFISZERO(result)) {
      DFWORD(result, 0)&amp;=~DECFLOAT_Sign;           if (set-&gt;round==DEC_ROUND_FLOOR) DFWORD(result, 0)|=DECFLOAT_Sign;
      }
    return result;
    } 
  #if DOUBLE
    #define COFF 4                        #elif QUAD
    UBFROMUS(acc+4, 0);                     #define COFF 6                        #endif
  GETCOEFF(dfl, acc+COFF);                ulsd=acc+COFF+DECPMAX-1;
  umsd=acc+4;                           
  #if DECTRACE
  {bcdnum tum;
  tum.msd=umsd;
  tum.lsd=ulsd;
  tum.exponent=bexpl-DECBIAS;
  tum.sign=DFWORD(dfl, 0) &amp; DECFLOAT_Sign;
  decShowNum(&amp;tum, "dflx");}
  #endif
  carry=0;                                if (diffsign) {
    carry=CARRYPAT;                         UBFROMUI(acc+ 4, 0x09090909-UBTOUI(acc+ 4));
    UBFROMUI(acc+ 8, 0x09090909-UBTOUI(acc+ 8));
    UBFROMUI(acc+12, 0x09090909-UBTOUI(acc+12));
    UBFROMUI(acc+16, 0x09090909-UBTOUI(acc+16));
    #if QUAD
    UBFROMUI(acc+20, 0x09090909-UBTOUI(acc+20));
    UBFROMUI(acc+24, 0x09090909-UBTOUI(acc+24));
    UBFROMUI(acc+28, 0x09090909-UBTOUI(acc+28));
    UBFROMUI(acc+32, 0x09090909-UBTOUI(acc+32));
    UBFROMUI(acc+36, 0x09090909-UBTOUI(acc+36));
    #endif
    } 
  overlap=DECPMAX-(bexpl-bexpr);
  #if DECTRACE
  printf("exps: %ld %ld\n", (LI)(bexpl-DECBIAS), (LI)(bexpr-DECBIAS));
  printf("Overlap=%ld carry=%08lx\n", (LI)overlap, (LI)carry);
  #endif
  if (overlap&lt;=0) {                         uInt gap;                               if (carry) {
      for (ub=ulsd; *ub==9; ub--) *ub=0;
      *ub+=1;
      carry=0;                                }
    gap=-overlap;
    if (gap&gt;DECPMAX) {
      bexpr+=gap-1;
      gap=DECPMAX;
      }
    ub=ulsd+gap+1;                          ut=acc+COFF+DECPMAX;                    for (; ut&lt;ub; ut+=4) UBFROMUI(ut, 0);     if (overlap&lt;-DECPMAX) {                   *ub=(uByte)(!DFISZERO(dfr));            }
     else {                                   GETCOEFF(dfr, ub);                      ub+=DECPMAX-1;                          }
    ulsd=ub;                                } 
   else {                                   if (overlap==DECPMAX) {                   ub=buf+COFF;                            #if QUAD
      UBFROMUS(buf+4, 0);                     #endif
      GETCOEFF(dfr, ub);                      }
     else {                                   ub=buf+COFF+DECPMAX-overlap;            UBFROMUI(buf+4, 0);                     UBFROMUI(buf+8, 0);
      if (ub&gt;buf+12) {
        ut=buf+12;                              for (; ut&lt;ub; ut+=4) UBFROMUI(ut, 0);         }
      GETCOEFF(dfr, ub);                
      UBFROMUI(acc+COFF+DECPMAX,   UBTOUI(buf+COFF+DECPMAX));
      UBFROMUI(acc+COFF+DECPMAX+4, UBTOUI(buf+COFF+DECPMAX+4));
      if (buf+COFF+DECPMAX+8&lt;ub+DECPMAX) {
        us=buf+COFF+DECPMAX+8;                  ut=acc+COFF+DECPMAX+8;                  for (; us&lt;ub+DECPMAX; us+=4, ut+=4) UBFROMUI(ut, UBTOUI(us));
        }
      } 
    ulsd=acc+(ub-buf+DECPMAX-1);        
    ut=acc+COFF+DECPMAX-4;                  us=buf+COFF+DECPMAX-4;              
    #if !DECLITEND
    for (; ut&gt;=acc+4; ut-=4, us-=4) {         carry+=UBTOUI(us);                      if (carry==0) continue;                 carry+=UBTOUI(ut);                      carry+=0x76f6f6f6;                      UBFROMUI(ut, (carry &amp; 0x0f0f0f0f) - ((carry &amp; 0x60606060)&gt;&gt;4));
      carry&gt;&gt;=31;                             }     #else
    for (; ut&gt;=acc+4; ut-=4, us-=4) {         carry+=UBTOUI(us);                      if (carry==0) continue;                 carry+=UBTOUI(ut);                      carry+=0x76767676;                      carry+=(carry &amp; 0x80000000)&gt;&gt;15;
      carry+=(carry &amp; 0x00800000)&gt;&gt;15;
      carry+=(carry &amp; 0x00008000)&gt;&gt;15;
      carry-=(carry &amp; 0x60606060)&gt;&gt;4;         UBFROMUI(ut, carry &amp; 0x0f0f0f0f);       carry=(carry &amp; 0x00000080)&lt;&lt;17;
      }     #endif
    #if DECTRACE
    {bcdnum tum;
    printf("Add done, carry=%08lx, diffsign=%ld\n", (LI)carry, (LI)diffsign);
    tum.msd=umsd;      tum.lsd=ulsd;
    tum.exponent=0;
    tum.sign=0;
    decShowNum(&amp;tum, "dfadd");}
    #endif
    } 
  if (diffsign) {                      if (!carry) {                        num.sign=DFWORD(dfl, 0) &amp; DECFLOAT_Sign;
      #if !DECLITEND
      *(ulsd+1)=0;
      #endif
      UBFROMUI(umsd,    0x09090909-UBTOUI(umsd));
      UBFROMUI(umsd+4,  0x09090909-UBTOUI(umsd+4));
      UBFROMUI(umsd+8,  0x09090909-UBTOUI(umsd+8));
      UBFROMUI(umsd+12, 0x09090909-UBTOUI(umsd+12));
      #if DOUBLE
        #define BNEXT 16
      #elif QUAD
        UBFROMUI(umsd+16, 0x09090909-UBTOUI(umsd+16));
        UBFROMUI(umsd+20, 0x09090909-UBTOUI(umsd+20));
        UBFROMUI(umsd+24, 0x09090909-UBTOUI(umsd+24));
        UBFROMUI(umsd+28, 0x09090909-UBTOUI(umsd+28));
        UBFROMUI(umsd+32, 0x09090909-UBTOUI(umsd+32));
        #define BNEXT 36
      #endif
      if (ulsd&gt;=umsd+BNEXT) {                   UBFROMUI(umsd+BNEXT,   0x09090909-UBTOUI(umsd+BNEXT));
        UBFROMUI(umsd+BNEXT+4, 0x09090909-UBTOUI(umsd+BNEXT+4));
        #if DOUBLE
        #define BNEXTY (BNEXT+8)
        #elif QUAD
        UBFROMUI(umsd+BNEXT+8,  0x09090909-UBTOUI(umsd+BNEXT+8));
        UBFROMUI(umsd+BNEXT+12, 0x09090909-UBTOUI(umsd+BNEXT+12));
        #define BNEXTY (BNEXT+16)
        #endif
        if (ulsd&gt;=umsd+BNEXTY) {                  ut=umsd+BNEXTY;                         for (;;ut+=4) {
            UBFROMUI(ut, 0x09090909-UBTOUI(ut));             if (ut&gt;=ulsd-3) break;                  }
          }
        }
      for (ub=ulsd; *ub==9; ub--) *ub=0;
      *ub+=1;
      } 
     else {                              num.sign=DFWORD(dfr, 0) &amp; DECFLOAT_Sign;
      if (ISCOEFFZERO(acc+COFF)) {
        umsd=acc+COFF+DECPMAX-1;           if (ulsd&gt;umsd) {                     umsd++;                            for (; UBTOUI(umsd)==0 &amp;&amp; umsd+3&lt;ulsd;) umsd+=4;
          for (; *umsd==0 &amp;&amp; umsd&lt;ulsd;) umsd++;
          }
        if (*umsd==0) {                      num.sign=0;                        if (set-&gt;round==DEC_ROUND_FLOOR) num.sign=DECFLOAT_Sign;
          }
        }
      }     } 
   else {     num.sign=DFWORD(dfl, 0)&amp;DECFLOAT_Sign;
    #if DOUBLE
    if (carry) {                         *(acc+3)=1;                        umsd=acc+3;
      }
    #endif
    } 
  num.msd=umsd;                      num.lsd=ulsd;                      num.exponent=bexpr-DECBIAS;      
  #if DECTRACE
  decFloatShow(dfl, "dfl");
  decFloatShow(dfr, "dfr");
  decShowNum(&amp;num, "postadd");
  #endif
  return decFinalize(result, &amp;num, set);   } 
decFloat * decFloatAnd(decFloat *result,
                       const decFloat *dfl, const decFloat *dfr,
                       decContext *set) {
  if (!DFISUINT01(dfl) || !DFISUINT01(dfr)
   || !DFISCC01(dfl)   || !DFISCC01(dfr)) return decInvalid(result, set);
  #if DOUBLE
   DFWORD(result, 0)=ZEROWORD
                   |((DFWORD(dfl, 0) &amp; DFWORD(dfr, 0))&amp;0x04009124);
   DFWORD(result, 1)=(DFWORD(dfl, 1) &amp; DFWORD(dfr, 1))&amp;0x49124491;
  #elif QUAD
   DFWORD(result, 0)=ZEROWORD
                   |((DFWORD(dfl, 0) &amp; DFWORD(dfr, 0))&amp;0x04000912);
   DFWORD(result, 1)=(DFWORD(dfl, 1) &amp; DFWORD(dfr, 1))&amp;0x44912449;
   DFWORD(result, 2)=(DFWORD(dfl, 2) &amp; DFWORD(dfr, 2))&amp;0x12449124;
   DFWORD(result, 3)=(DFWORD(dfl, 3) &amp; DFWORD(dfr, 3))&amp;0x49124491;
  #endif
  return result;
  } 
decFloat * decFloatCanonical(decFloat *result, const decFloat *df) {
  return decCanonical(result, df);
  } 
enum decClass decFloatClass(const decFloat *df) {
  Int exp;                           if (DFISSPECIAL(df)) {
    if (DFISQNAN(df)) return DEC_CLASS_QNAN;
    if (DFISSNAN(df)) return DEC_CLASS_SNAN;
    if (DFISSIGNED(df)) return DEC_CLASS_NEG_INF;
    return DEC_CLASS_POS_INF;
    }
  if (DFISZERO(df)) {                  if (DFISSIGNED(df)) return DEC_CLASS_NEG_ZERO;
    return DEC_CLASS_POS_ZERO;
    }
  exp=GETEXPUN(df)                      +decFloatDigits(df)-1;          if (exp&gt;=DECEMIN) {                  if (DFISSIGNED(df)) return DEC_CLASS_NEG_NORMAL;
    return DEC_CLASS_POS_NORMAL;
    }
  if (DFISSIGNED(df)) return DEC_CLASS_NEG_SUBNORMAL;
  return DEC_CLASS_POS_SUBNORMAL;
  } 
const char *decFloatClassString(const decFloat *df) {
  enum decClass eclass=decFloatClass(df);
  if (eclass==DEC_CLASS_POS_NORMAL)    return DEC_ClassString_PN;
  if (eclass==DEC_CLASS_NEG_NORMAL)    return DEC_ClassString_NN;
  if (eclass==DEC_CLASS_POS_ZERO)      return DEC_ClassString_PZ;
  if (eclass==DEC_CLASS_NEG_ZERO)      return DEC_ClassString_NZ;
  if (eclass==DEC_CLASS_POS_SUBNORMAL) return DEC_ClassString_PS;
  if (eclass==DEC_CLASS_NEG_SUBNORMAL) return DEC_ClassString_NS;
  if (eclass==DEC_CLASS_POS_INF)       return DEC_ClassString_PI;
  if (eclass==DEC_CLASS_NEG_INF)       return DEC_ClassString_NI;
  if (eclass==DEC_CLASS_QNAN)          return DEC_ClassString_QN;
  if (eclass==DEC_CLASS_SNAN)          return DEC_ClassString_SN;
  return DEC_ClassString_UN;             } 
decFloat * decFloatCompare(decFloat *result,
                           const decFloat *dfl, const decFloat *dfr,
                           decContext *set) {
  Int comp;                                    if (DFISNAN(dfl) || DFISNAN(dfr)) return decNaNs(result, dfl, dfr, set);
  comp=decNumCompare(dfl, dfr, 0);
  decFloatZero(result);
  if (comp==0) return result;
  DFBYTE(result, DECBYTES-1)=0x01;        if (comp&lt;0) DFBYTE(result, 0)|=0x80;    return result;
  } 
decFloat * decFloatCompareSignal(decFloat *result,
                                 const decFloat *dfl, const decFloat *dfr,
                                 decContext *set) {
  Int comp;                                    if (DFISNAN(dfl) || DFISNAN(dfr)) {
    set-&gt;status|=DEC_Invalid_operation;
    return decNaNs(result, dfl, dfr, set);
    }
  comp=decNumCompare(dfl, dfr, 0);
  decFloatZero(result);
  if (comp==0) return result;
  DFBYTE(result, DECBYTES-1)=0x01;        if (comp&lt;0) DFBYTE(result, 0)|=0x80;    return result;
  } 
decFloat * decFloatCompareTotal(decFloat *result,
                                const decFloat *dfl, const decFloat *dfr) {
  Int  comp;                                   uInt uiwork;                                 #if QUAD
  uShort uswork;                               #endif
  if (DFISNAN(dfl) || DFISNAN(dfr)) {
    Int nanl, nanr;                              nanl=DFISSNAN(dfl)+DFISQNAN(dfl)*2;          if (DFISSIGNED(dfl)) nanl=-nanl;
    nanr=DFISSNAN(dfr)+DFISQNAN(dfr)*2;
    if (DFISSIGNED(dfr)) nanr=-nanr;
    if (nanl&gt;nanr) comp=+1;
     else if (nanl&lt;nanr) comp=-1;
     else {       uByte bufl[DECPMAX+4];                       uByte bufr[DECPMAX+4];                       uByte *ub, *uc;                              Int sigl;                                    sigl=(DFISSIGNED(dfl) ? -1 : +1);
      #if QUAD
        UBFROMUS(bufl, 0);
        UBFROMUS(bufr, 0);
      #endif
      GETCOEFF(dfl, bufl+QUAD*2);                  GETCOEFF(dfr, bufr+QUAD*2);                  comp=0;                                      for (ub=bufl, uc=bufr; ub&lt;bufl+DECPMAX+QUAD*2; ub+=4, uc+=4) {
        uInt ui=UBTOUI(ub);
        if (ui==UBTOUI(uc)) continue;         for (;; ub++, uc++) {
          if (*ub==*uc) continue;
          if (*ub&gt;*uc) comp=sigl;                       else comp=-sigl;                             break;
          }
        }
      }     }
   else {
    comp=decNumCompare(dfl, dfr, 1);        }
  decFloatZero(result);
  if (comp==0) return result;
  DFBYTE(result, DECBYTES-1)=0x01;        if (comp&lt;0) DFBYTE(result, 0)|=0x80;    return result;
  } 
decFloat * decFloatCompareTotalMag(decFloat *result,
                                const decFloat *dfl, const decFloat *dfr) {
  decFloat a, b;                          if (DFISSIGNED(dfl)) {
    decFloatCopyAbs(&amp;a, dfl);
    dfl=&amp;a;
    }
  if (DFISSIGNED(dfr)) {
    decFloatCopyAbs(&amp;b, dfr);
    dfr=&amp;b;
    }
  return decFloatCompareTotal(result, dfl, dfr);
  } 
decFloat * decFloatCopy(decFloat *result, const decFloat *dfl) {
  if (dfl!=result) *result=*dfl;               return result;
  } 
decFloat * decFloatCopyAbs(decFloat *result, const decFloat *dfl) {
  if (dfl!=result) *result=*dfl;          DFBYTE(result, 0)&amp;=~0x80;               return result;
  } 
decFloat * decFloatCopyNegate(decFloat *result, const decFloat *dfl) {
  if (dfl!=result) *result=*dfl;          DFBYTE(result, 0)^=0x80;                return result;
  } 
decFloat * decFloatCopySign(decFloat *result,
                            const decFloat *dfl, const decFloat *dfr) {
  uByte sign=(uByte)(DFBYTE(dfr, 0)&amp;0x80);     if (dfl!=result) *result=*dfl;               DFBYTE(result, 0)&amp;=~0x80;                    DFBYTE(result, 0)=(uByte)(DFBYTE(result, 0)|sign);   return result;
  } 
#define dpdlenchk(n, form)  dpd=(form)&amp;0x3ff;     \
  if (dpd) return (DECPMAX-1-3*(n))-(3-DPD2BCD8[dpd*4+3])
#define dpdlendun(n, form)  dpd=(form)&amp;0x3ff;     \
  if (dpd==0) return 1;                           \
  return (DECPMAX-1-3*(n))-(3-DPD2BCD8[dpd*4+3])
uInt decFloatDigits(const decFloat *df) {
  uInt dpd;                          uInt sourhi=DFWORD(df, 0);         #if QUAD
  uInt sourmh, sourml;
  #endif
  uInt sourlo;
  if (DFISINF(df)) return 1;
  if (!DFISNAN(df) &amp;&amp; DECCOMBMSD[sourhi&gt;&gt;26]) return DECPMAX;
  #if DOUBLE
    if (sourhi&amp;0x0003ffff) {           dpdlenchk(0, sourhi&gt;&gt;8);
      sourlo=DFWORD(df, 1);
      dpdlendun(1, (sourhi&lt;&lt;2) | (sourlo&gt;&gt;30));
      }     sourlo=DFWORD(df, 1);      if (sourlo&amp;0xfff00000) {           dpdlenchk(1, sourlo&gt;&gt;30);        dpdlendun(2, sourlo&gt;&gt;20);
      }     dpdlenchk(3, sourlo&gt;&gt;10);
    dpdlendun(4, sourlo);
  #elif QUAD
    if (sourhi&amp;0x00003fff) {           dpdlenchk(0, sourhi&gt;&gt;4);
      sourmh=DFWORD(df, 1);
      dpdlendun(1, ((sourhi)&lt;&lt;6) | (sourmh&gt;&gt;26));
      }     sourmh=DFWORD(df, 1);
    if (sourmh) {
      dpdlenchk(1, sourmh&gt;&gt;26);
      dpdlenchk(2, sourmh&gt;&gt;16);
      dpdlenchk(3, sourmh&gt;&gt;6);
      sourml=DFWORD(df, 2);
      dpdlendun(4, ((sourmh)&lt;&lt;4) | (sourml&gt;&gt;28));
      }     sourml=DFWORD(df, 2);
    if (sourml) {
      dpdlenchk(4, sourml&gt;&gt;28);
      dpdlenchk(5, sourml&gt;&gt;18);
      dpdlenchk(6, sourml&gt;&gt;8);
      sourlo=DFWORD(df, 3);
      dpdlendun(7, ((sourml)&lt;&lt;2) | (sourlo&gt;&gt;30));
      }     sourlo=DFWORD(df, 3);
    if (sourlo&amp;0xfff00000) {           dpdlenchk(7, sourlo&gt;&gt;30);        dpdlendun(8, sourlo&gt;&gt;20);
      }     dpdlenchk(9, sourlo&gt;&gt;10);
    dpdlendun(10, sourlo);
  #endif
  } 
decFloat * decFloatDivide(decFloat *result,
                          const decFloat *dfl, const decFloat *dfr,
                          decContext *set) {
  return decDivide(result, dfl, dfr, set, DIVIDE);
  } 
decFloat * decFloatDivideInteger(decFloat *result,
                             const decFloat *dfl, const decFloat *dfr,
                             decContext *set) {
  return decDivide(result, dfl, dfr, set, DIVIDEINT);
  } 
decFloat * decFloatFMA(decFloat *result, const decFloat *dfl,
                       const decFloat *dfr, const decFloat *dff,
                       decContext *set) {
  #define FMALEN (ROUNDUP4(1+ (DECPMAX9*18+1) +DECPMAX+2))
  uByte  acc[FMALEN];                bcdnum mul;                        bcdnum fin;                        uByte  coe[ROUNDUP4(DECPMAX)];     bcdnum *hi, *lo;                   uInt   diffsign;                   uInt   hipad;                      Int    padding;                    uInt   carry;                      uByte  *ub, *uh, *ul;              uInt   uiwork;                   
  if (DFISSPECIAL(dfl) || DFISSPECIAL(dfr) || DFISSPECIAL(dff)) {
    decFloat proxy;                    if (DFISSNAN(dfl) || DFISSNAN(dfr)) return decNaNs(result, dfl, dfr, set);
    if (DFISSNAN(dff)) return decNaNs(result, dff, NULL, set);
    if (DFISNAN(dfl) || DFISNAN(dfr)) return decNaNs(result, dfl, dfr, set);
    if (DFISNAN(dff)) return decNaNs(result, dff, NULL, set);
    decFloatZero(&amp;proxy);
    if (DFISINF(dfl)) {
      if (DFISZERO(dfr)) return decInvalid(result, set);
      decInfinity(&amp;proxy, &amp;proxy);
      }
     else if (DFISINF(dfr)) {
      if (DFISZERO(dfl)) return decInvalid(result, set);
      decInfinity(&amp;proxy, &amp;proxy);
      }
    DFWORD(&amp;proxy, 0)|=(DFWORD(dfl, 0)^DFWORD(dfr, 0))&amp;DECFLOAT_Sign;
    if (!DFISINF(dff)) return decFloatCopy(result, &amp;proxy);
    if (!DFISINF(&amp;proxy)) return decInfinity(result, dff);
    if ((DFWORD(dff, 0)&amp;DECFLOAT_Sign)!=(DFWORD(&amp;proxy, 0)&amp;DECFLOAT_Sign))
      return decInvalid(result, set);
    return decFloatCopy(result, &amp;proxy);
    }
  decFiniteMultiply(&amp;mul, acc+1, dfl, dfr);
  fin.exponent=GETEXPUN(dff);             fin.sign=DFWORD(dff, 0)&amp;DECFLOAT_Sign;
  diffsign=mul.sign^fin.sign;             fin.msd=coe;
  fin.lsd=coe+DECPMAX-1;
  GETCOEFF(dff, coe);                   
  if (mul.exponent&gt;=fin.exponent) {
    hi=&amp;mul;
    lo=&amp;fin;
    }
   else {
    hi=&amp;fin;
    lo=&amp;mul;
    }
  for (; UBTOUI(hi-&gt;msd)==0 &amp;&amp; hi-&gt;msd+3&lt;hi-&gt;lsd;) hi-&gt;msd+=4;
  for (; *hi-&gt;msd==0 &amp;&amp; hi-&gt;msd&lt;hi-&gt;lsd;) hi-&gt;msd++;
  for (; UBTOUI(lo-&gt;msd)==0 &amp;&amp; lo-&gt;msd+3&lt;lo-&gt;lsd;) lo-&gt;msd+=4;
  for (; *lo-&gt;msd==0 &amp;&amp; lo-&gt;msd&lt;lo-&gt;lsd;) lo-&gt;msd++;
  if (*hi-&gt;msd==0) {                             if (diffsign) {
      if (*lo-&gt;msd==0) {                             lo-&gt;sign=0;
        if (set-&gt;round==DEC_ROUND_FLOOR) lo-&gt;sign=DECFLOAT_Sign;
        }       }     return decFinalize(result, lo, set);         } 
  hipad=0;
  carry=0;
  if (diffsign) {
    hipad=9;
    carry=1;
    for (uh=hi-&gt;msd; uh&lt;hi-&gt;lsd-3; uh+=4) UBFROMUI(uh, 0x09090909-UBTOUI(uh));
    for (; uh&lt;=hi-&gt;lsd; uh++) *uh=(uByte)(0x09-*uh);
    }
  padding=hi-&gt;exponent-lo-&gt;exponent;
  ub=acc+FMALEN-1;                   ul=lo-&gt;lsd;                      
  if (padding!=0) {                
    Int hilen=(Int)(hi-&gt;lsd-hi-&gt;msd+1);     Int lolen=(Int)(lo-&gt;lsd-lo-&gt;msd+1); 
    if (hilen+padding-lolen &gt; DECPMAX+2) {         Int newexp=MINI(hi-&gt;exponent, hi-&gt;exponent+hilen-DECPMAX)-3;
      lo-&gt;lsd=lo-&gt;msd;                             lo-&gt;exponent=newexp;                         padding=hi-&gt;exponent-lo-&gt;exponent;           ul=lo-&gt;lsd;                                  }
    #if DECCHECK
      if (padding&lt;=0) printf("FMA low padding: %ld\n", (LI)padding);
      if (hilen+padding+1&gt;FMALEN)
        printf("FMA excess hilen+padding: %ld+%ld \n", (LI)hilen, (LI)padding);
    #endif
    for (; ul-3&gt;=lo-&gt;msd &amp;&amp; padding&gt;3; padding-=4, ul-=4, ub-=4) {
      UBFROMUI(ub-3, UBTOUI(ul-3));                }
    for (; ul&gt;=lo-&gt;msd &amp;&amp; padding&gt;0; padding--, ul--, ub--) *ub=*ul;
    for (;padding&gt;0; padding--, ub--) *ub=0;     }
  uh=hi-&gt;lsd;
  for (;; ub--) {
    if (uh&lt;hi-&gt;msd || ul&lt;lo-&gt;msd) break;
    *ub=(uByte)(carry+(*uh--)+(*ul--));
    carry=0;
    if (*ub&lt;10) continue;
    *ub-=10;
    carry=1;
    } 
  if (ul&lt;lo-&gt;msd) {               for (;; ub--) {
      if (uh&lt;hi-&gt;msd) break;
      *ub=(uByte)(carry+(*uh--));        carry=0;
      if (*ub&lt;10) continue;
      *ub-=10;
      carry=1;
      }     }
   else {                         for (;; ub--) {
      if (ul&lt;lo-&gt;msd) break;
      *ub=(uByte)(carry+hipad+(*ul--));
      carry=0;
      if (*ub&lt;10) continue;
      *ub-=10;
      carry=1;
      }     }
  lo-&gt;msd=ub+1;
  lo-&gt;lsd=acc+FMALEN-1;
  if (!diffsign) {                     if (carry) {                         *ub=1;                             lo-&gt;msd--;                         }
    }    else {                              if (!carry) {                        lo-&gt;sign=hi-&gt;sign;                 for (ul=lo-&gt;msd; ul&lt;lo-&gt;lsd-3; ul+=4) UBFROMUI(ul, 0x09090909-UBTOUI(ul));
      for (; ul&lt;=lo-&gt;lsd; ul++) *ul=(uByte)(0x09-*ul);       for (ul--; *ul==9; ul--) *ul=0;
      *ul+=1;
      }      else {                              for (; UBTOUI(lo-&gt;msd)==0 &amp;&amp; lo-&gt;msd+3&lt;lo-&gt;lsd;) lo-&gt;msd+=4;
      for (; *lo-&gt;msd==0 &amp;&amp; lo-&gt;msd&lt;lo-&gt;lsd;) lo-&gt;msd++;
      if (*lo-&gt;msd==0) {                   lo-&gt;sign=0;                        if (set-&gt;round==DEC_ROUND_FLOOR) lo-&gt;sign=DECFLOAT_Sign;
        }
      }     } 
  #if DECCHECK
  if (lo-&gt;msd&lt;acc) {
    printf("FMA underrun by %ld \n", (LI)(acc-lo-&gt;msd));
    }
  #endif
  return decFinalize(result, lo, set);    } 
decFloat * decFloatFromInt32(decFloat *result, Int n) {
  uInt u=(uInt)n;                         uInt encode;                            DFWORD(result, 0)=ZEROWORD;             #if QUAD
    DFWORD(result, 1)=0;
    DFWORD(result, 2)=0;
  #endif
  if (n&lt;0) {                                u=(~u)+1;
    DFWORD(result, 0)|=DECFLOAT_Sign;
    }
  encode=BIN2DPD[u%1000];
  u/=1000;
  encode|=BIN2DPD[u%1000]&lt;&lt;10;
  u/=1000;
  encode|=BIN2DPD[u%1000]&lt;&lt;20;
  u/=1000;                                encode|=u&lt;&lt;30;
  DFWORD(result, DECWORDS-1)=encode;
  return result;
  } 
decFloat * decFloatFromUInt32(decFloat *result, uInt u) {
  uInt encode;                            DFWORD(result, 0)=ZEROWORD;             #if QUAD
    DFWORD(result, 1)=0;
    DFWORD(result, 2)=0;
  #endif
  encode=BIN2DPD[u%1000];
  u/=1000;
  encode|=BIN2DPD[u%1000]&lt;&lt;10;
  u/=1000;
  encode|=BIN2DPD[u%1000]&lt;&lt;20;
  u/=1000;                                encode|=u&lt;&lt;30;
  DFWORD(result, DECWORDS-1)=encode;
  DFWORD(result, DECWORDS-2)|=u&gt;&gt;2;       return result;
  } 
decFloat * decFloatInvert(decFloat *result, const decFloat *df,
                          decContext *set) {
  uInt sourhi=DFWORD(df, 0);            
  if (!DFISUINT01(df) || !DFISCC01(df)) return decInvalid(result, set);
  #if DOUBLE
   DFWORD(result, 0)=ZEROWORD|((~sourhi)&amp;0x04009124);
   DFWORD(result, 1)=(~DFWORD(df, 1))   &amp;0x49124491;
  #elif QUAD
   DFWORD(result, 0)=ZEROWORD|((~sourhi)&amp;0x04000912);
   DFWORD(result, 1)=(~DFWORD(df, 1))   &amp;0x44912449;
   DFWORD(result, 2)=(~DFWORD(df, 2))   &amp;0x12449124;
   DFWORD(result, 3)=(~DFWORD(df, 3))   &amp;0x49124491;
  #endif
  return result;
  } 
uInt decFloatIsCanonical(const decFloat *df) {
  if (DFISSPECIAL(df)) {
    if (DFISINF(df)) {
      if (DFWORD(df, 0)&amp;ECONMASK) return 0;        if (!DFISCCZERO(df)) return 0;               return 1;
      }
    if (DFWORD(df, 0)&amp;ECONNANMASK) return 0;     if (DFISCCZERO(df)) return 1;                }
  {   #if DOUBLE
    uInt sourhi=DFWORD(df, 0);
    uInt sourlo=DFWORD(df, 1);
    if (CANONDPDOFF(sourhi, 8)
     &amp;&amp; CANONDPDTWO(sourhi, sourlo, 30)
     &amp;&amp; CANONDPDOFF(sourlo, 20)
     &amp;&amp; CANONDPDOFF(sourlo, 10)
     &amp;&amp; CANONDPDOFF(sourlo, 0)) return 1;
  #elif QUAD
    uInt sourhi=DFWORD(df, 0);
    uInt sourmh=DFWORD(df, 1);
    uInt sourml=DFWORD(df, 2);
    uInt sourlo=DFWORD(df, 3);
    if (CANONDPDOFF(sourhi, 4)
     &amp;&amp; CANONDPDTWO(sourhi, sourmh, 26)
     &amp;&amp; CANONDPDOFF(sourmh, 16)
     &amp;&amp; CANONDPDOFF(sourmh, 6)
     &amp;&amp; CANONDPDTWO(sourmh, sourml, 28)
     &amp;&amp; CANONDPDOFF(sourml, 18)
     &amp;&amp; CANONDPDOFF(sourml, 8)
     &amp;&amp; CANONDPDTWO(sourml, sourlo, 30)
     &amp;&amp; CANONDPDOFF(sourlo, 20)
     &amp;&amp; CANONDPDOFF(sourlo, 10)
     &amp;&amp; CANONDPDOFF(sourlo, 0)) return 1;
  #endif
  }   return 0;      }
uInt decFloatIsFinite(const decFloat *df) {
  return !DFISSPECIAL(df);
  }
uInt decFloatIsInfinite(const decFloat *df) {
  return DFISINF(df);
  }
uInt decFloatIsInteger(const decFloat *df) {
  return DFISINT(df);
  }
uInt decFloatIsLogical(const decFloat *df) {
  return DFISUINT01(df) &amp; DFISCC01(df);
  }
uInt decFloatIsNaN(const decFloat *df) {
  return DFISNAN(df);
  }
uInt decFloatIsNegative(const decFloat *df) {
  return DFISSIGNED(df) &amp;&amp; !DFISZERO(df) &amp;&amp; !DFISNAN(df);
  }
uInt decFloatIsNormal(const decFloat *df) {
  Int exp;                           if (DFISSPECIAL(df)) return 0;
  if (DFISZERO(df)) return 0;
  exp=GETEXPUN(df)                      +decFloatDigits(df)-1;          return (exp&gt;=DECEMIN);             }
uInt decFloatIsPositive(const decFloat *df) {
  return !DFISSIGNED(df) &amp;&amp; !DFISZERO(df) &amp;&amp; !DFISNAN(df);
  }
uInt decFloatIsSignaling(const decFloat *df) {
  return DFISSNAN(df);
  }
uInt decFloatIsSignalling(const decFloat *df) {
  return DFISSNAN(df);
  }
uInt decFloatIsSigned(const decFloat *df) {
  return DFISSIGNED(df);
  }
uInt decFloatIsSubnormal(const decFloat *df) {
  if (DFISSPECIAL(df)) return 0;
  if (decFloatIsNormal(df)) return 0;
  if (DFISZERO(df)) return 0;
  return 1;                                    }
uInt decFloatIsZero(const decFloat *df) {
  return DFISZERO(df);
  } 
decFloat * decFloatLogB(decFloat *result, const decFloat *df,
                        decContext *set) {
  Int ae;                                      if (DFISNAN(df)) return decNaNs(result, df, NULL, set);
  if (DFISINF(df)) {
    DFWORD(result, 0)=0;                         return decInfinity(result, result);          }
  if (DFISZERO(df)) {
    set-&gt;status|=DEC_Division_by_zero;           DFWORD(result, 0)=DECFLOAT_Sign;             return decInfinity(result, result);          }
  ae=GETEXPUN(df)                           +decFloatDigits(df)-1;                DFWORD(result, 0)=ZEROWORD;             if (ae&lt;0) {
    DFWORD(result, 0)|=DECFLOAT_Sign;       ae=-ae;
    }
  #if DOUBLE
    DFWORD(result, 1)=BIN2DPD[ae];        #elif QUAD
    DFWORD(result, 1)=0;
    DFWORD(result, 2)=0;
    DFWORD(result, 3)=(ae/1000)&lt;&lt;10;        DFWORD(result, 3)|=BIN2DPD[ae%1000];
  #endif
  return result;
  } 
decFloat * decFloatMax(decFloat *result,
                       const decFloat *dfl, const decFloat *dfr,
                       decContext *set) {
  Int comp;
  if (DFISNAN(dfl)) {
    if (DFISNAN(dfr) || DFISSNAN(dfl)) return decNaNs(result, dfl, dfr, set);
    return decCanonical(result, dfr);            }
  if (DFISNAN(dfr)) {
    if (DFISSNAN(dfr)) return decNaNs(result, dfl, dfr, set);
    return decCanonical(result, dfl);            }
  comp=decNumCompare(dfl, dfr, 1);
  if (comp&gt;=0) return decCanonical(result, dfl);
  return decCanonical(result, dfr);
  } 
decFloat * decFloatMaxMag(decFloat *result,
                       const decFloat *dfl, const decFloat *dfr,
                       decContext *set) {
  Int comp;
  decFloat absl, absr;
  if (DFISNAN(dfl) || DFISNAN(dfr)) return decFloatMax(result, dfl, dfr, set);
  decFloatCopyAbs(&amp;absl, dfl);
  decFloatCopyAbs(&amp;absr, dfr);
  comp=decNumCompare(&amp;absl, &amp;absr, 0);
  if (comp&gt;0) return decCanonical(result, dfl);
  if (comp&lt;0) return decCanonical(result, dfr);
  return decFloatMax(result, dfl, dfr, set);
  } 
decFloat * decFloatMin(decFloat *result,
                       const decFloat *dfl, const decFloat *dfr,
                       decContext *set) {
  Int comp;
  if (DFISNAN(dfl)) {
    if (DFISNAN(dfr) || DFISSNAN(dfl)) return decNaNs(result, dfl, dfr, set);
    return decCanonical(result, dfr);            }
  if (DFISNAN(dfr)) {
    if (DFISSNAN(dfr)) return decNaNs(result, dfl, dfr, set);
    return decCanonical(result, dfl);            }
  comp=decNumCompare(dfl, dfr, 1);
  if (comp&lt;=0) return decCanonical(result, dfl);
  return decCanonical(result, dfr);
  } 
decFloat * decFloatMinMag(decFloat *result,
                       const decFloat *dfl, const decFloat *dfr,
                       decContext *set) {
  Int comp;
  decFloat absl, absr;
  if (DFISNAN(dfl) || DFISNAN(dfr)) return decFloatMin(result, dfl, dfr, set);
  decFloatCopyAbs(&amp;absl, dfl);
  decFloatCopyAbs(&amp;absr, dfr);
  comp=decNumCompare(&amp;absl, &amp;absr, 0);
  if (comp&lt;0) return decCanonical(result, dfl);
  if (comp&gt;0) return decCanonical(result, dfr);
  return decFloatMin(result, dfl, dfr, set);
  } 
decFloat * decFloatMinus(decFloat *result, const decFloat *df,
                         decContext *set) {
  if (DFISNAN(df)) return decNaNs(result, df, NULL, set);
  decCanonical(result, df);                         if (DFISZERO(df)) DFBYTE(result, 0)&amp;=~0x80;        else DFBYTE(result, 0)^=0x80;                    return result;
  } 
decFloat * decFloatMultiply(decFloat *result,
                            const decFloat *dfl, const decFloat *dfr,
                            decContext *set) {
  bcdnum num;                        uByte  bcdacc[DECPMAX9*18+1];    
  if (DFISSPECIAL(dfl) || DFISSPECIAL(dfr)) {     if (DFISNAN(dfl) || DFISNAN(dfr)) return decNaNs(result, dfl, dfr, set);
    if (DFISINF(dfl) &amp;&amp; DFISZERO(dfr)) return decInvalid(result, set);
    if (DFISINF(dfr) &amp;&amp; DFISZERO(dfl)) return decInvalid(result, set);
    DFWORD(result, 0)=DFWORD(dfl, 0)^DFWORD(dfr, 0);     return decInfinity(result, result);
    }
  decFiniteMultiply(&amp;num, bcdacc, dfl, dfr);
  return decFinalize(result, &amp;num, set);   } 
decFloat * decFloatNextMinus(decFloat *result, const decFloat *dfl,
                             decContext *set) {
  decFloat delta;                         uInt savestat;                          enum rounding saveround;              
  if (DFISINF(dfl) &amp;&amp; !DFISSIGNED(dfl)) {
    DFSETNMAX(result);
    return result;                          }
  decFloatZero(&amp;delta);                   DFWORD(&amp;delta, DECWORDS-1)=1;           DFWORD(&amp;delta, 0)=DECFLOAT_Sign;        saveround=set-&gt;round;                   set-&gt;round=DEC_ROUND_FLOOR;             savestat=set-&gt;status;                   decFloatAdd(result, dfl, &amp;delta, set);
  if (DFISZERO(result)) DFWORD(result, 0)^=DECFLOAT_Sign;   set-&gt;status&amp;=DEC_Invalid_operation;     set-&gt;status|=savestat;                  set-&gt;round=saveround;                   return result;
  } 
decFloat * decFloatNextPlus(decFloat *result, const decFloat *dfl,
                            decContext *set) {
  uInt savestat;                          enum rounding saveround;                decFloat delta;                       
  if (DFISINF(dfl) &amp;&amp; DFISSIGNED(dfl)) {
    DFSETNMAX(result);
    DFWORD(result, 0)|=DECFLOAT_Sign;       return result;                          }
  decFloatZero(&amp;delta);                   DFWORD(&amp;delta, DECWORDS-1)=1;           DFWORD(&amp;delta, 0)=0;                    saveround=set-&gt;round;                   set-&gt;round=DEC_ROUND_CEILING;           savestat=set-&gt;status;                   decFloatAdd(result, dfl, &amp;delta, set);
  if (DFISZERO(result)) DFWORD(result, 0)^=DECFLOAT_Sign;   set-&gt;status&amp;=DEC_Invalid_operation;     set-&gt;status|=savestat;                  set-&gt;round=saveround;                   return result;
  } 
decFloat * decFloatNextToward(decFloat *result,
                              const decFloat *dfl, const decFloat *dfr,
                              decContext *set) {
  decFloat delta;                         decFloat pointone;                      uInt  savestat;                         enum  rounding saveround;               uInt  deltatop;                         Int   comp;                           
  if (DFISNAN(dfl) || DFISNAN(dfr)) return decNaNs(result, dfl, dfr, set);
  comp=decNumCompare(dfl, dfr, 0);
  if (comp==0) return decFloatCopySign(result, dfl, dfr); 
  if (comp&lt;0) {     if (DFISINF(dfl) &amp;&amp; DFISSIGNED(dfl)) {         DFSETNMAX(result);
      DFWORD(result, 0)|=DECFLOAT_Sign;
      return result;
      }
    saveround=set-&gt;round;                        set-&gt;round=DEC_ROUND_CEILING;                deltatop=0;                                  }
   else {     if (DFISINF(dfl) &amp;&amp; !DFISSIGNED(dfl)) {        DFSETNMAX(result);
      return result;
      }
    saveround=set-&gt;round;                        set-&gt;round=DEC_ROUND_FLOOR;                  deltatop=DECFLOAT_Sign;                      }
  savestat=set-&gt;status;                        decFloatZero(&amp;delta);                   DFWORD(&amp;delta, DECWORDS-1)=1;           DFWORD(&amp;delta, 0)=deltatop;             decFloatFromString(&amp;pointone, "1E-1", set);   decFloatFMA(result, &amp;delta, &amp;pointone, dfl, set);
  if (decFloatIsNormal(result)) set-&gt;status=savestat;   set-&gt;round=saveround;                   return result;
  } 
decFloat * decFloatOr(decFloat *result,
                       const decFloat *dfl, const decFloat *dfr,
                       decContext *set) {
  if (!DFISUINT01(dfl) || !DFISUINT01(dfr)
   || !DFISCC01(dfl)   || !DFISCC01(dfr)) return decInvalid(result, set);
  #if DOUBLE
   DFWORD(result, 0)=ZEROWORD
                   |((DFWORD(dfl, 0) | DFWORD(dfr, 0))&amp;0x04009124);
   DFWORD(result, 1)=(DFWORD(dfl, 1) | DFWORD(dfr, 1))&amp;0x49124491;
  #elif QUAD
   DFWORD(result, 0)=ZEROWORD
                   |((DFWORD(dfl, 0) | DFWORD(dfr, 0))&amp;0x04000912);
   DFWORD(result, 1)=(DFWORD(dfl, 1) | DFWORD(dfr, 1))&amp;0x44912449;
   DFWORD(result, 2)=(DFWORD(dfl, 2) | DFWORD(dfr, 2))&amp;0x12449124;
   DFWORD(result, 3)=(DFWORD(dfl, 3) | DFWORD(dfr, 3))&amp;0x49124491;
  #endif
  return result;
  } 
decFloat * decFloatPlus(decFloat *result, const decFloat *df,
                        decContext *set) {
  if (DFISNAN(df)) return decNaNs(result, df, NULL, set);
  decCanonical(result, df);                         if (DFISZERO(df)) DFBYTE(result, 0)&amp;=~0x80;       return result;
  } 
decFloat * decFloatQuantize(decFloat *result,
                            const decFloat *dfl, const decFloat *dfr,
                            decContext *set) {
  Int   explb, exprb;           uByte *ulsd;                  uByte *ub, *uc;               Int   drop;                   uInt  dpd;                    uInt  encode;                 uInt  sourhil, sourhir;       uInt  uiwork;                 #if QUAD
  uShort uswork;                #endif
  uByte buf[4+DECPMAX*3+2*QUAD];     #if DECTRACE
  bcdnum num;                        #endif
  sourhil=DFWORD(dfl, 0);            explb=DECCOMBEXP[sourhil&gt;&gt;26];     sourhir=DFWORD(dfr, 0);            exprb=DECCOMBEXP[sourhir&gt;&gt;26];
  if (EXPISSPECIAL(explb | exprb)) {     if (DFISNAN(dfl) || DFISNAN(dfr)) return decNaNs(result, dfl, dfr, set);
    if (DFISINF(dfl)!=DFISINF(dfr)) return decInvalid(result, set);
    return decInfinity(result, dfl);
    }
  explb+=GETECON(dfl);               exprb+=GETECON(dfr);             
  drop=exprb-explb;                  if (drop==0) return decCanonical(result, dfl); 
  #define BUFOFF (buf+4+DECPMAX)
  GETCOEFF(dfl, BUFOFF);           
  #if DECTRACE
  num.msd=BUFOFF;
  num.lsd=BUFOFF+DECPMAX-1;
  num.exponent=explb-DECBIAS;
  num.sign=sourhil &amp; DECFLOAT_Sign;
  decShowNum(&amp;num, "dfl");
  #endif
  if (drop&gt;0) {                             uByte *roundat;                              uByte reround;                           
    UBFROMUI(BUFOFF-4, 0);
    if (drop&lt;DECPMAX) {                            roundat=BUFOFF+DECPMAX-drop;
      reround=*roundat;
      for (ub=roundat+1; ub&lt;BUFOFF+DECPMAX; ub++) {
        if (*ub!=0) {                                  reround=DECSTICKYTAB[reround];               break;                                       }
        }       ulsd=roundat-1;                              }
     else {                                        if (drop==DECPMAX) {
        roundat=BUFOFF;
        reround=*roundat;
        }
       else {
        roundat=BUFOFF-1;
        reround=0;
        }
      for (ub=roundat+1; ub&lt;BUFOFF+DECPMAX; ub++) {
        if (*ub!=0) {                                  reround=DECSTICKYTAB[reround];               break;                                       }
        }       *BUFOFF=0;                                   ulsd=BUFOFF;                                 }
    if (reround!=0) {                              uInt bump=0;
      set-&gt;status|=DEC_Inexact;
      if (set-&gt;round==DEC_ROUND_HALF_EVEN) {         if (reround&gt;5) bump=1;                        else if (reround==5)                          bump=*ulsd &amp; 0x01;                         }        else switch (set-&gt;round) {
        case DEC_ROUND_DOWN: {
          break;}         case DEC_ROUND_HALF_DOWN: {
          if (reround&gt;5) bump=1;
          break;}         case DEC_ROUND_HALF_UP: {
          if (reround&gt;=5) bump=1;
          break;}         case DEC_ROUND_UP: {
          if (reround&gt;0) bump=1;
          break;}         case DEC_ROUND_CEILING: {
          if (!(sourhil&amp;DECFLOAT_Sign) &amp;&amp; reround&gt;0) bump=1;
          break;}         case DEC_ROUND_FLOOR: {
          if (sourhil&amp;DECFLOAT_Sign &amp;&amp; reround&gt;0) bump=1;
          break;}         case DEC_ROUND_05UP: {
          if (reround&gt;0) {             if (*ulsd==0 || *ulsd==5) bump=1;
            }
          break;}         default: {                set-&gt;status|=DEC_Invalid_context;
          #if DECCHECK
          printf("Unknown rounding mode: %ld\n", (LI)set-&gt;round);
          #endif
          break;}
        } 
      if (bump!=0) {                                 ub=ulsd;
        for (; UBTOUI(ub-3)==0x09090909; ub-=4) UBFROMUI(ub-3, 0);
        for (; *ub==9; ub--) *ub=0;
        *ub+=1;
        }       } 
    if (drop&gt;4) {
      UBFROMUI(BUFOFF-8, 0);                       for (uc=BUFOFF-12; uc&gt;ulsd-DECPMAX-3; uc-=4) UBFROMUI(uc, 0);
      }
    } 
   else {     if (-drop&gt;DECPMAX-1) {                         if (!ISCOEFFZERO(BUFOFF)) return decInvalid(result, set);
      ulsd=BUFOFF+DECPMAX-1;
      }
     else {       #if DECLITEND
      static const uInt dmask[]={0, 0x000000ff, 0x0000ffff, 0x00ffffff};
      #else
      static const uInt dmask[]={0, 0xff000000, 0xffff0000, 0xffffff00};
      #endif
      for (uc=BUFOFF+DECPMAX;; uc+=4) {
        UBFROMUI(uc, 0);
        if (UBTOUI(uc-DECPMAX)!=0) {                        if (uc&lt;=BUFOFF+DECPMAX+(-drop)-4)
            return decInvalid(result, set);
          if ((UBTOUI(uc-DECPMAX)&amp;dmask[(-drop)%4])!=0)
            return decInvalid(result, set);
          break;              }
        if (uc&gt;=BUFOFF+DECPMAX+(-drop)-4) break;          }
      ulsd=BUFOFF+DECPMAX+(-drop)-1;
      } <a name="1"></a>    } 
  #if DECTRACE
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  num.msd=ulsd-DECPMAX+1;
  num.lsd=ulsd;
  num.exponent=explb-DECBIAS;
  num.sign=sourhil &amp; DECFLOAT_Sign;
  decShowNum(&amp;num, "res");
  #endif
  encode=((exprb&gt;&gt;DECECONL)&lt;&lt;4) + *(ulsd-DECPMAX+1);   encode=DECCOMBFROM[encode];                  encode|=sourhir &amp; ECONMASK;
  encode|=sourhil&amp;DECFLOAT_Sign;             
  #define getDPD3q(dpd, n) ub=ulsd-(3*(n))-2;                   \
    dpd=BCD2DPD[(*ub*256)+(*(ub+1)*16)+*(ub+2)];
  #if DOUBLE
    getDPD3q(dpd, 4); encode|=dpd&lt;&lt;8;
    getDPD3q(dpd, 3); encode|=dpd&gt;&gt;2;
    DFWORD(result, 0)=encode;
    encode=dpd&lt;&lt;30;
    getDPD3q(dpd, 2); encode|=dpd&lt;&lt;20;
    getDPD3q(dpd, 1); encode|=dpd&lt;&lt;10;
    getDPD3q(dpd, 0); encode|=dpd;</b></font>
    DFWORD(result, 1)=encode;
  #elif QUAD
    getDPD3q(dpd,10); encode|=dpd&lt;&lt;4;
    getDPD3q(dpd, 9); encode|=dpd&gt;&gt;6;
    DFWORD(result, 0)=encode;
    encode=dpd&lt;&lt;26;
    getDPD3q(dpd, 8); encode|=dpd&lt;&lt;16;
    getDPD3q(dpd, 7); encode|=dpd&lt;&lt;6;
    getDPD3q(dpd, 6); encode|=dpd&gt;&gt;4;
    DFWORD(result, 1)=encode;
    encode=dpd&lt;&lt;28;
    getDPD3q(dpd, 5); encode|=dpd&lt;&lt;18;
    getDPD3q(dpd, 4); encode|=dpd&lt;&lt;8;
    getDPD3q(dpd, 3); encode|=dpd&gt;&gt;2;
    DFWORD(result, 2)=encode;
    encode=dpd&lt;&lt;30;
    getDPD3q(dpd, 2); encode|=dpd&lt;&lt;20;
    getDPD3q(dpd, 1); encode|=dpd&lt;&lt;10;
    getDPD3q(dpd, 0); encode|=dpd;
    DFWORD(result, 3)=encode;
  #endif
  return result;
  } 
decFloat * decFloatReduce(decFloat *result, const decFloat *df,
                          decContext *set) {
  bcdnum num;                             uByte buf[DECPMAX], *ub;                if (df!=result) *result=*df;            if (DFISNAN(df)) return decNaNs(result, df, NULL, set);     if (DFISINF(df)) return decInfinity(result, df);       if (DFISZERO(df)) {
    uInt sign=DFWORD(df, 0)&amp;DECFLOAT_Sign;
    decFloatZero(result);
    DFWORD(result, 0)|=sign;
    return result;                          }
  GETCOEFF(df, buf);
  ub=buf+DECPMAX-1;                       if (*ub) return result;                 for (ub--; *ub==0;) ub--;               num.sign=DFWORD(df, 0)&amp;DECFLOAT_Sign;   num.exponent=GETEXPUN(df)+(Int)(buf+DECPMAX-1-ub);   num.msd=buf;
  num.lsd=ub;
  return decFinalize(result, &amp;num, set);
  } 
decFloat * decFloatRemainder(decFloat *result,
                             const decFloat *dfl, const decFloat *dfr,
                             decContext *set) {
  return decDivide(result, dfl, dfr, set, REMAINDER);
  } 
decFloat * decFloatRemainderNear(decFloat *result,
                             const decFloat *dfl, const decFloat *dfr,
                             decContext *set) {
  return decDivide(result, dfl, dfr, set, REMNEAR);
  } 
#define PHALF (ROUNDUP(DECPMAX/2, 4))   decFloat * decFloatRotate(decFloat *result,
                         const decFloat *dfl, const decFloat *dfr,
                         decContext *set) {
  Int rotate;                             uByte buf[DECPMAX+PHALF];               uInt digits, savestat;                  bcdnum num;                             uByte *ub;                            
  if (DFISNAN(dfl)||DFISNAN(dfr)) return decNaNs(result, dfl, dfr, set);
  if (!DFISINT(dfr)) return decInvalid(result, set);
  digits=decFloatDigits(dfr);                      if (digits&gt;2) return decInvalid(result, set);    rotate=DPD2BIN[DFWORD(dfr, DECWORDS-1)&amp;0x3ff];   if (rotate&gt;DECPMAX) return decInvalid(result, set);   if (DFISINF(dfl)) return decInfinity(result, dfl);    if (rotate==0 || rotate==DECPMAX) return decCanonical(result, dfl);
  if (DFISSIGNED(dfr)) rotate=-rotate;
  if (abs(rotate)&gt;PHALF) {
    if (rotate&lt;0) rotate=DECPMAX+rotate;
     else rotate=rotate-DECPMAX;
    }
  ub=buf;
  if (rotate&lt;0) ub+=PHALF;      GETCOEFF(dfl, ub);
  if (rotate&lt;0) {
    memcpy(buf, buf+DECPMAX, PHALF);
    num.msd=buf+PHALF+rotate;
    }
   else {
    memcpy(buf+DECPMAX, buf, PHALF);
    num.msd=buf+rotate;
    }
  num.lsd=num.msd+DECPMAX-1;
  num.sign=DFWORD(dfl, 0)&amp;DECFLOAT_Sign;
  num.exponent=GETEXPUN(dfl);
  savestat=set-&gt;status;                   decFinalize(result, &amp;num, set);
  set-&gt;status=savestat;                   return result;
  } 
uInt decFloatSameQuantum(const decFloat *dfl, const decFloat *dfr) {
  if (DFISSPECIAL(dfl) || DFISSPECIAL(dfr)) {
    if (DFISNAN(dfl) &amp;&amp; DFISNAN(dfr)) return 1;
    if (DFISINF(dfl) &amp;&amp; DFISINF(dfr)) return 1;
    return 0;      }
  if (GETEXP(dfl)==GETEXP(dfr)) return 1;   return 0;
  } 
#define SCALEBMAX 2*(DECEMAX+DECPMAX)   decFloat * decFloatScaleB(decFloat *result,
                          const decFloat *dfl, const decFloat *dfr,
                          decContext *set) {
  uInt digits;                            Int  expr;                            
  if (DFISNAN(dfl)||DFISNAN(dfr)) return decNaNs(result, dfl, dfr, set);
  if (!DFISINT(dfr)) return decInvalid(result, set);
  digits=decFloatDigits(dfr);                
  #if DOUBLE
  if (digits&gt;3) return decInvalid(result, set);     expr=DPD2BIN[DFWORD(dfr, 1)&amp;0x3ff];               #elif QUAD
  if (digits&gt;5) return decInvalid(result, set);     expr=DPD2BIN[DFWORD(dfr, 3)&amp;0x3ff]                    +DPD2BIN[(DFWORD(dfr, 3)&gt;&gt;10)&amp;0x3ff]*1000;    #endif
  if (expr&gt;SCALEBMAX) return decInvalid(result, set);    if (DFISINF(dfl)) return decInfinity(result, dfl);     if (DFISSIGNED(dfr)) expr=-expr;
  *result=*dfl;                                return decFloatSetExponent(result, set, GETEXPUN(result)+expr);
  } 
decFloat * decFloatShift(decFloat *result,
                         const decFloat *dfl, const decFloat *dfr,
                         decContext *set) {
  Int    shift;                           uByte  buf[DECPMAX*2];                  uInt   digits, savestat;                bcdnum num;                             uInt   uiwork;                        
  if (DFISNAN(dfl)||DFISNAN(dfr)) return decNaNs(result, dfl, dfr, set);
  if (!DFISINT(dfr)) return decInvalid(result, set);
  digits=decFloatDigits(dfr);                       if (digits&gt;2) return decInvalid(result, set);     shift=DPD2BIN[DFWORD(dfr, DECWORDS-1)&amp;0x3ff];     if (shift&gt;DECPMAX) return decInvalid(result, set);   
  if (DFISINF(dfl)) return decInfinity(result, dfl);   if (shift==0) return decCanonical(result, dfl);
  if (shift==DECPMAX) {                          uByte sign=(uByte)(DFBYTE(dfl, 0)&amp;0x80);     decFloatZero(result);                        DFBYTE(result, 0)=(uByte)(DFBYTE(result, 0)|sign);     return result;
    }
  num.sign=DFWORD(dfl, 0)&amp;DECFLOAT_Sign;
  num.exponent=GETEXPUN(dfl);
  num.msd=buf;
  GETCOEFF(dfl, buf);
  if (DFISSIGNED(dfr)) {     num.lsd=buf+DECPMAX-shift-1;
    }
   else {     UBFROMUI(buf+DECPMAX, 0);               UBFROMUI(buf+DECPMAX+4, 0);             if (shift&gt;8) memset(buf+DECPMAX+8, 0, 8+QUAD*18);     num.msd+=shift;
    num.lsd=num.msd+DECPMAX-1;
    }
  savestat=set-&gt;status;                   decFinalize(result, &amp;num, set);
  set-&gt;status=savestat;                   return result;
  } 
decFloat * decFloatSubtract(decFloat *result,
                            const decFloat *dfl, const decFloat *dfr,
                            decContext *set) {
  decFloat temp;
  if (DFISNAN(dfr)) return decFloatAdd(result, dfl, dfr, set);
  temp=*dfr;                                     DFBYTE(&amp;temp, 0)^=0x80;                        return decFloatAdd(result, dfl, &amp;temp, set);   } 
uInt decFloatToUInt32(const decFloat *df, decContext *set,
                      enum rounding round) {
  return decToInt32(df, set, round, 0, 1);}
uInt decFloatToUInt32Exact(const decFloat *df, decContext *set,
                           enum rounding round) {
  return decToInt32(df, set, round, 1, 1);}
Int decFloatToInt32(const decFloat *df, decContext *set,
                    enum rounding round) {
  return (Int)decToInt32(df, set, round, 0, 0);}
Int decFloatToInt32Exact(const decFloat *df, decContext *set,
                         enum rounding round) {
  return (Int)decToInt32(df, set, round, 1, 0);}
decFloat * decFloatToIntegralValue(decFloat *result, const decFloat *df,
                                   decContext *set, enum rounding round) {
  return decToIntegral(result, df, set, round, 0);}
decFloat * decFloatToIntegralExact(decFloat *result, const decFloat *df,
                                   decContext *set) {
  return decToIntegral(result, df, set, set-&gt;round, 1);}
decFloat * decFloatXor(decFloat *result,
                       const decFloat *dfl, const decFloat *dfr,
                       decContext *set) {
  if (!DFISUINT01(dfl) || !DFISUINT01(dfr)
   || !DFISCC01(dfl)   || !DFISCC01(dfr)) return decInvalid(result, set);
  #if DOUBLE
   DFWORD(result, 0)=ZEROWORD
                   |((DFWORD(dfl, 0) ^ DFWORD(dfr, 0))&amp;0x04009124);
   DFWORD(result, 1)=(DFWORD(dfl, 1) ^ DFWORD(dfr, 1))&amp;0x49124491;
  #elif QUAD
   DFWORD(result, 0)=ZEROWORD
                   |((DFWORD(dfl, 0) ^ DFWORD(dfr, 0))&amp;0x04000912);
   DFWORD(result, 1)=(DFWORD(dfl, 1) ^ DFWORD(dfr, 1))&amp;0x44912449;
   DFWORD(result, 2)=(DFWORD(dfl, 2) ^ DFWORD(dfr, 2))&amp;0x12449124;
   DFWORD(result, 3)=(DFWORD(dfl, 3) ^ DFWORD(dfr, 3))&amp;0x49124491;
  #endif
  return result;
  } 
static decFloat *decInvalid(decFloat *result, decContext *set) {
  decFloatZero(result);
  DFWORD(result, 0)=DECFLOAT_qNaN;
  set-&gt;status|=DEC_Invalid_operation;
  return result;
  } 
static decFloat *decInfinity(decFloat *result, const decFloat *df) {
  uInt sign=DFWORD(df, 0);           decFloatZero(result);              DFWORD(result, 0)=DECFLOAT_Inf | (sign &amp; DECFLOAT_Sign);
  return result;
  } 
static decFloat *decNaNs(decFloat *result,
                         const decFloat *dfl, const decFloat *dfr,
                         decContext *set) {
  if (dfr!=NULL &amp;&amp; DFISSNAN(dfr) &amp;&amp; !DFISSNAN(dfl)) dfl=dfr;   if (DFISSNAN(dfl)) {
    decCanonical(result, dfl);              DFWORD(result, 0)&amp;=~(DECFLOAT_qNaN ^ DECFLOAT_sNaN);     set-&gt;status|=DEC_Invalid_operation;
    return result;
    }
  if (!DFISNAN(dfl)) dfl=dfr;             return decCanonical(result, dfl);       } 
static Int decNumCompare(const decFloat *dfl, const decFloat *dfr, Flag tot) {
  Int   sigl, sigr;                       Int   shift;                            uByte *ub, *uc;                         uInt  uiwork;                           uByte bufl[DECPMAX*2+QUAD*2+4];         uByte bufr[DECPMAX*2+QUAD*2+4];       
  sigl=1;
  if (DFISSIGNED(dfl)) {
    if (!DFISSIGNED(dfr)) {                   if (DFISZERO(dfl) &amp;&amp; DFISZERO(dfr) &amp;&amp; !tot) return 0;
      return -1;                              }
    sigl=-1;
    }
  if (DFISSIGNED(dfr)) {
    if (!DFISSIGNED(dfl)) {                   if (DFISZERO(dfl) &amp;&amp; DFISZERO(dfr) &amp;&amp; !tot) return 0;
      return +1;                              }
    }
  sigr=-sigl;                           
  if (DFISINF(dfl)) {
    if (DFISINF(dfr)) return 0;             return sigl;                            }
  if (DFISINF(dfr)) return sigr;        
  shift=GETEXP(dfl)-GETEXP(dfr);        
  if (DFISZERO(dfl)) {
    if (!DFISZERO(dfr)) return sigr;        if (shift==0 || !tot) return 0;
    if (shift&gt;0) return sigl;
    return sigr;                            }
   else {                                   if (DFISZERO(dfr)) return sigl;         }
  if (abs(shift)&gt;=DECPMAX) {                if (shift&gt;0) return sigl;
    return sigr;                            }
  #if QUAD
    UBFROMUI(bufl, 0);
    UBFROMUI(bufr, 0);
  #endif
  GETCOEFF(dfl, bufl+QUAD*2);             GETCOEFF(dfr, bufr+QUAD*2);             if (shift==0) {                           for (ub=bufl, uc=bufr; ub&lt;bufl+DECPMAX+QUAD*2; ub+=4, uc+=4) {
      uInt ui=UBTOUI(ub);
      if (ui==UBTOUI(uc)) continue;           for (;; ub++, uc++) {
        if (*ub&gt;*uc) return sigl;               if (*ub&lt;*uc) return sigr;               }
      }
    }    else if (shift&gt;0) {                      ub=bufl;                                UBFROMUI(bufl+DECPMAX+QUAD*2, 0);       UBFROMUI(bufl+DECPMAX+QUAD*2+4, 0);     if (shift&gt;8) {
      uByte *up;                              uByte *upend=bufl+DECPMAX+QUAD*2+shift;
      for (up=bufl+DECPMAX+QUAD*2+8; up&lt;upend; up+=4) UBFROMUI(up, 0);
      for (;; ub+=4) {
        if (UBTOUI(ub)!=0) return sigl;
        if (ub+4&gt;bufl+shift-4) break;
        }
      }
    for (; ub&lt;bufl+shift; ub++) if (*ub!=0) return sigl;
    for (uc=bufr; ; uc+=4, ub+=4) {
      uInt ui=UBTOUI(ub);
      if (ui!=UBTOUI(uc)) {                     for (;; uc++, ub++) {                     if (*ub&gt;*uc) return sigl;               if (*ub&lt;*uc) return sigr;               }
        }       if (uc==bufr+QUAD*2+DECPMAX-4) break;       }
    } 
   else {     uc=bufr;                                UBFROMUI(bufr+DECPMAX+QUAD*2, 0);       UBFROMUI(bufr+DECPMAX+QUAD*2+4, 0);     if (shift&lt;-8) {
      uByte *up;                              uByte *upend=bufr+DECPMAX+QUAD*2-shift;
      for (up=bufr+DECPMAX+QUAD*2+8; up&lt;upend; up+=4) UBFROMUI(up, 0);
      for (;; uc+=4) {
        if (UBTOUI(uc)!=0) return sigr;
        if (uc+4&gt;bufr-shift-4) break;
        }
      }
    for (; uc&lt;bufr-shift; uc++) if (*uc!=0) return sigr;
    for (ub=bufl; ; ub+=4, uc+=4) {
      uInt ui=UBTOUI(ub);
      if (ui!=UBTOUI(uc)) {                     for (;; ub++, uc++) {                     if (*ub&gt;*uc) return sigl;               if (*ub&lt;*uc) return sigr;               }
        }       if (ub==bufl+QUAD*2+DECPMAX-4) break;       }
    } 
  if (!tot) return 0;                     if (shift&gt;0) return sigl;               if (shift&lt;0) return sigr;               return 0;
  } 
static uInt decToInt32(const decFloat *df, decContext *set,
                       enum rounding rmode, Flag exact, Flag unsign) {
  Int  exp;                          uInt sourhi, sourpen, sourlo;      uInt hi, lo;                       decFloat zero, result;             Int  i;                          
  sourhi=DFWORD(df, 0);                   exp=DECCOMBEXP[sourhi&gt;&gt;26];             if (EXPISSPECIAL(exp)) {                  set-&gt;status|=DEC_Invalid_operation;     return 0;
    }
  if (GETEXPUN(df)==0) result=*df;         else {                                   enum rounding saveround;                uInt savestatus;                        saveround=set-&gt;round;                   savestatus=set-&gt;status;                 set-&gt;round=rmode;                       decFloatZero(&amp;zero);                    set-&gt;status=0;                          decFloatQuantize(&amp;result, df, &amp;zero, set);     set-&gt;round=saveround;                   if (exact) set-&gt;status|=savestatus;      else set-&gt;status=savestatus;           }
  #if DOUBLE
  if ((DFWORD(&amp;result, 0)&amp;0x1c03ff00)!=0
   || (DFWORD(&amp;result, 0)&amp;0x60000000)==0x60000000) {
  #elif QUAD
  if ((DFWORD(&amp;result, 2)&amp;0xffffff00)!=0
   ||  DFWORD(&amp;result, 1)!=0
   || (DFWORD(&amp;result, 0)&amp;0x1c003fff)!=0
   || (DFWORD(&amp;result, 0)&amp;0x60000000)==0x60000000) {
  #endif
    set-&gt;status|=DEC_Invalid_operation;     return 0;
    }
  sourlo=DFWORD(&amp;result, DECWORDS-1);
  lo=DPD2BIN0[sourlo&amp;0x3ff]
    +DPD2BINK[(sourlo&gt;&gt;10)&amp;0x3ff]
    +DPD2BINM[(sourlo&gt;&gt;20)&amp;0x3ff];
  sourpen=DFWORD(&amp;result, DECWORDS-2);
  hi=DPD2BIN0[((sourpen&lt;&lt;2) | (sourlo&gt;&gt;30))&amp;0x3ff];
  if (unsign) {
    if (hi&gt;4 || (hi==4 &amp;&amp; lo&gt;294967295) || (hi+lo!=0 &amp;&amp; DFISSIGNED(&amp;result))) {
      set-&gt;status|=DEC_Invalid_operation;       return 0;
      }
    return hi*BILLION+lo;
    }
  if (hi&gt;2 || (hi==2 &amp;&amp; lo&gt;147483647)) {
    if (lo==147483648 &amp;&amp; hi==2 &amp;&amp; DFISSIGNED(&amp;result)) return 0x80000000;
    set-&gt;status|=DEC_Invalid_operation;     return 0;
    }
  i=hi*BILLION+lo;
  if (DFISSIGNED(&amp;result)) i=-i;
  return (uInt)i;
  } 
static decFloat * decToIntegral(decFloat *result, const decFloat *df,
                                decContext *set, enum rounding rmode,
                                Flag exact) {
  Int  exp;                          uInt sourhi;                       enum rounding saveround;           uInt savestatus;                   decFloat zero;                   
  sourhi=DFWORD(df, 0);              exp=DECCOMBEXP[sourhi&gt;&gt;26];      
  if (EXPISSPECIAL(exp)) {             if (DFISNAN(df)) return decNaNs(result, df, NULL, set);
    return decInfinity(result, df);
    }
  exp+=GETECON(df)-DECBIAS;             
  if (exp&gt;=0) return decCanonical(result, df); 
  saveround=set-&gt;round;                   savestatus=set-&gt;status;                 set-&gt;round=rmode;                       decFloatZero(&amp;zero);                    decFloatQuantize(result, df, &amp;zero, set);   set-&gt;round=saveround;                   if (!exact) set-&gt;status=savestatus;     return result;
  } </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
