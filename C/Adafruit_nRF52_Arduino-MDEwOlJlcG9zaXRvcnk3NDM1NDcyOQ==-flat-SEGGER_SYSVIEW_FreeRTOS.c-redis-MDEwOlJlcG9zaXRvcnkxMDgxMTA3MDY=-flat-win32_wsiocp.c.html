
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.7303754266211606%, Tokens: 8</h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-SEGGER_SYSVIEW_FreeRTOS.c</h3>
            <pre><code>1  #if CFG_SYSVIEW
2  #include "FreeRTOS.h"
3  #include "task.h"
4  #include "SEGGER_SYSVIEW.h"
5  #include "SEGGER_SYSVIEW_FreeRTOS.h"
6  #include "string.h" 
7  typedef struct SYSVIEW_FREERTOS_TASK_STATUS SYSVIEW_FREERTOS_TASK_STATUS;
8  struct SYSVIEW_FREERTOS_TASK_STATUS {
9    U32         xHandle;
10    const char* pcTaskName;
11    unsigned    uxCurrentPriority;
12    U32         pxStack;
13    unsigned    uStackHighWaterMark;
14  };
15  static SYSVIEW_FREERTOS_TASK_STATUS _aTasks[SYSVIEW_FREERTOS_MAX_NOF_TASKS];
16  static unsigned _NumTasks;
17  static void _cbSendTaskList(void) {
18    unsigned n;
19    for (n = 0; n < _NumTasks; n++) {
20  #if INCLUDE_uxTaskGetStackHighWaterMark 
21      _aTasks[n].uStackHighWaterMark = uxTaskGetStackHighWaterMark((TaskHandle_t)_aTasks[n].xHandle);
22  #endif
23      SYSVIEW_SendTaskInfo((U32)_aTasks[n].xHandle, _aTasks[n].pcTaskName, (unsigned)_aTasks[n].uxCurrentPriority, (U32)_aTasks[n].pxStack, (unsigned)_aTasks[n].uStackHighWaterMark);
24    }
25  }
26  static U64 _cbGetTime(void) {
27    U64 Time;
28    Time = xTaskGetTickCountFromISR();
29    Time *= portTICK_PERIOD_MS;
30    Time *= 1000;
31    return Time;
32  }
33  void SYSVIEW_AddTask(U32 xHandle, const char* pcTaskName, unsigned uxCurrentPriority, U32  pxStack, unsigned uStackHighWaterMark) {
<span onclick='openModal()' class='match'>34    if (memcmp(pcTaskName, "IDLE", 5) == 0) {
35      return;
36    }
37    if (_NumTasks >= SYSVIEW_FREERTOS_MAX_NOF_TASKS) {
38      SEGGER_SYSVIEW_Warn("SYSTEMVIEW: Could not record task information. Maximum number of tasks reached.");
39      return;
40    }
</span>41    _aTasks[_NumTasks].xHandle = xHandle;
42    _aTasks[_NumTasks].pcTaskName = pcTaskName;
43    _aTasks[_NumTasks].uxCurrentPriority = uxCurrentPriority;
44    _aTasks[_NumTasks].pxStack = pxStack;
45    _aTasks[_NumTasks].uStackHighWaterMark = uStackHighWaterMark;
46    _NumTasks++;
47    SYSVIEW_SendTaskInfo(xHandle, pcTaskName,uxCurrentPriority, pxStack, uStackHighWaterMark);
48  }
49  void SYSVIEW_UpdateTask(U32 xHandle, const char* pcTaskName, unsigned uxCurrentPriority, U32 pxStack, unsigned uStackHighWaterMark) {
50    unsigned n;
51    if (memcmp(pcTaskName, "IDLE", 5) == 0) {
52      return;
53    }
54    for (n = 0; n < _NumTasks; n++) {
55      if (_aTasks[n].xHandle == xHandle) {
56        break;
57      }
58    }
59    if (n < _NumTasks) {
60      _aTasks[n].pcTaskName = pcTaskName;
61      _aTasks[n].uxCurrentPriority = uxCurrentPriority;
62      _aTasks[n].pxStack = pxStack;
63      _aTasks[n].uStackHighWaterMark = uStackHighWaterMark;
64      SYSVIEW_SendTaskInfo(xHandle, pcTaskName, uxCurrentPriority, pxStack, uStackHighWaterMark);
65    } else {
66      SYSVIEW_AddTask(xHandle, pcTaskName, uxCurrentPriority, pxStack, uStackHighWaterMark);
67    }
68  }
69  void SYSVIEW_DeleteTask(U32 xHandle) {
70    unsigned n;
71    if (_NumTasks == 0) {
72      return; 
73    }  
74    for (n = 0; n < _NumTasks; n++) {
75      if (_aTasks[n].xHandle == xHandle) {
76        break;
77      }
78    }
79    if (n == (_NumTasks - 1)) {  
80      memset(&_aTasks[n], 0, sizeof(_aTasks[n]));
81      _NumTasks--;
82    } else if (n < _NumTasks) {
83      _aTasks[n].xHandle             = _aTasks[_NumTasks - 1].xHandle;
84      _aTasks[n].pcTaskName          = _aTasks[_NumTasks - 1].pcTaskName;
85      _aTasks[n].uxCurrentPriority   = _aTasks[_NumTasks - 1].uxCurrentPriority;
86      _aTasks[n].pxStack             = _aTasks[_NumTasks - 1].pxStack;
87      _aTasks[n].uStackHighWaterMark = _aTasks[_NumTasks - 1].uStackHighWaterMark;
88      memset(&_aTasks[_NumTasks - 1], 0, sizeof(_aTasks[_NumTasks - 1]));
89      _NumTasks--;
90    }
91  }
92  void SYSVIEW_SendTaskInfo(U32 TaskID, const char* sName, unsigned Prio, U32 StackBase, unsigned StackSize) {
93    SEGGER_SYSVIEW_TASKINFO TaskInfo;
94    memset(&TaskInfo, 0, sizeof(TaskInfo)); 
95    TaskInfo.TaskID     = TaskID;
96    TaskInfo.sName      = sName;
97    TaskInfo.Prio       = Prio;
98    TaskInfo.StackBase  = StackBase;
99    TaskInfo.StackSize  = StackSize;
100    SEGGER_SYSVIEW_SendTaskInfo(&TaskInfo);
101  }
102  const SEGGER_SYSVIEW_OS_API SYSVIEW_X_OS_TraceAPI = {
103    _cbGetTime,
104    _cbSendTaskList,
105  };
106  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-win32_wsiocp.c</h3>
            <pre><code>1  #include "win32fixes.h"
2  #include "..\ae.h"
3  #include "..\adlist.h"
4  #include <mswsock.h>
5  #include "win32_wsiocp.h"
6  #include "Win32_FDAPI.h"
7  #include "Win32_Assert.h"
8  #include <errno.h>
9  static HANDLE iocph;
10  #define SUCCEEDED_WITH_IOCP(result) ((result) || (GetLastError() == ERROR_IO_PENDING))
11  static DWORD wsarecvflags;
12  static char zreadchar[1];
13  iocpSockState* WSIOCP_GetExistingSocketState(int fd) {
14      iocpSockState** socketState = (iocpSockState**) FDAPI_GetSocketStatePtr(fd);
15      if (socketState == NULL) {
16          return NULL;
17      } else {
18          return *socketState;
19      }
20  }
21  iocpSockState* WSIOCP_GetSocketState(int fd) {
22      iocpSockState** socketState = (iocpSockState**) FDAPI_GetSocketStatePtr(fd);
23      if (socketState == NULL) {
24          return NULL;
25      } else {
26          if (*socketState == NULL) {
27              *socketState = (iocpSockState *) CallocMemoryNoCOW(sizeof(iocpSockState));
28              if (*socketState != NULL) {
29                  (*socketState)->fd = fd;
30              }
31          }
32          return *socketState;
33      }
34  }
35  BOOL WSIOCP_CloseSocketState(iocpSockState* socketState) {
36      socketState->masks &= ~(SOCKET_ATTACHED | AE_WRITABLE | AE_READABLE);
37      if (socketState->wreqs == 0 &&
38          (socketState->masks & (READ_QUEUED | CONNECT_PENDING)) == 0) {
39          FreeMemoryNoCOW(socketState);
40          return TRUE;
41      } else {
42          socketState->masks |= CLOSE_PENDING;
43          return FALSE;
44      }
45  }
46  BOOL WSIOCP_CloseSocketStateRFD(int rfd) {
47      return WSIOCP_CloseSocketState(WSIOCP_GetExistingSocketState(rfd));
48  }
49  int WSIOCP_SocketAttach(int fd, iocpSockState *socketState) {
50      if (socketState == NULL) {
51          socketState = WSIOCP_GetSocketState(fd);
52      }
53      if (iocph != NULL && socketState != NULL) {
54          if (FDAPI_SocketAttachIOCP(fd, iocph)) {
55              socketState->masks = SOCKET_ATTACHED;
56              socketState->wreqs = 0;
57              return 0;
58          }
59      } else {
60          errno = WSAEINVAL;
61      }
62      return -1;
63  }
64  const int ACCEPTEX_ADDRESS_BUFFER_SIZE = sizeof(struct sockaddr_storage) + 32;
65  int WSIOCP_QueueAccept(int listenfd) {
66      iocpSockState *sockstate;
67      iocpSockState *accsockstate;
68      DWORD result, bytes;
69      int acceptfd;
70      aacceptreq * areq;
71      if ((sockstate = WSIOCP_GetSocketState(listenfd)) == NULL) {
72          errno = WSAEINVAL;
73          return -1;
74      }
75      acceptfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
76      if (acceptfd == -1) {
77          errno = WSAEINVAL;
78          return -1;
79      }
80      accsockstate = WSIOCP_GetSocketState(acceptfd);
81      if (accsockstate == NULL) {
82          errno = WSAEINVAL;
83          return -1;
84      }
85      accsockstate->masks = SOCKET_ATTACHED;
86      areq = (aacceptreq *) CallocMemoryNoCOW(sizeof(aacceptreq));
87      areq->buf = CallocMemoryNoCOW(ACCEPTEX_ADDRESS_BUFFER_SIZE * 2);
88      areq->accept = acceptfd;
89      areq->next = NULL;
90      result = FDAPI_AcceptEx(listenfd, acceptfd,
91                              areq->buf, 0,
92                              ACCEPTEX_ADDRESS_BUFFER_SIZE,
93                              ACCEPTEX_ADDRESS_BUFFER_SIZE,
94                              &bytes, &areq->ov);
95      if (SUCCEEDED_WITH_IOCP(result)){
96          sockstate->masks |= ACCEPT_PENDING;
97      } else {
98          errno = FDAPI_WSAGetLastError();
99          sockstate->masks &= ~ACCEPT_PENDING;
100          accsockstate->masks = 0;
101          close(acceptfd);
102          FreeMemoryNoCOW(areq->buf);
103          FreeMemoryNoCOW(areq);
104          return -1;
105      }
106      return 0;
107  }
108  int WSIOCP_Listen(int rfd, int backlog) {
109      iocpSockState *sockstate = WSIOCP_GetSocketState(rfd);
110      if (sockstate == NULL) {
111          errno = WSAEINVAL;
112          return SOCKET_ERROR;
113      }
114      if (WSIOCP_SocketAttach(rfd, sockstate) != 0) {
115          return SOCKET_ERROR;
116      }
117      sockstate->masks |= LISTEN_SOCK;
<span onclick='openModal()' class='match'>118      if (listen(rfd, backlog) != 0) {
119          return SOCKET_ERROR;
120      }
121      if (WSIOCP_QueueAccept(rfd) != 0) {
122          return SOCKET_ERROR;
123      }
</span>124      return 0;
125  }
126  int WSIOCP_Accept(int fd, struct sockaddr *sa, socklen_t *len) {
127      iocpSockState *sockstate;
128      int acceptfd;
129      int result;
130      SOCKADDR *plocalsa = NULL;
131      SOCKADDR *premotesa = NULL;
132      int locallen = 0;
133      int remotelen = 0;
134      aacceptreq * areq;
135      if ((sockstate = WSIOCP_GetSocketState(fd)) == NULL) {
136          errno = WSAEINVAL;
137          return SOCKET_ERROR;
138      }
139      areq = sockstate->reqs;
140      if (areq == NULL) {
141          errno = EWOULDBLOCK;
142          return SOCKET_ERROR;
143      }
144      sockstate->reqs = areq->next;
145      acceptfd = (int) areq->accept;
146      result = FDAPI_UpdateAcceptContext(acceptfd);
147      if (result == SOCKET_ERROR) {
148          errno = FDAPI_WSAGetLastError();
149          FreeMemoryNoCOW(areq->buf);
150          FreeMemoryNoCOW(areq);
151          return SOCKET_ERROR;
152      }
153      FDAPI_GetAcceptExSockaddrs(acceptfd,
154                                 areq->buf,
155                                 0,
156                                 ACCEPTEX_ADDRESS_BUFFER_SIZE,
157                                 ACCEPTEX_ADDRESS_BUFFER_SIZE,
158                                 &plocalsa, &locallen,
159                                 &premotesa, &remotelen);
160      if (sa != NULL) {
161          if (remotelen > 0) {
162              if (remotelen < *len) {
163                  *len = remotelen;
164              }
165              memcpy(sa, premotesa, *len);
166          } else {
167              *len = 0;
168          }
169      }
170      WSIOCP_SocketAttach(acceptfd, NULL);
171      FreeMemoryNoCOW(areq->buf);
172      FreeMemoryNoCOW(areq);
173      if (WSIOCP_QueueAccept(fd) == -1) {
174          return SOCKET_ERROR;
175      }
176      return acceptfd;
177  }
178  int WSIOCP_QueueNextRead(int fd) {
179      iocpSockState *sockstate;
180      int result;
181      WSABUF zreadbuf;
182      DWORD bytesReceived = 0;
183      DWORD recvFlags = 0;
184      if ((sockstate = WSIOCP_GetSocketState(fd)) == NULL) {
185          errno = WSAEINVAL;
186          return -1;
187      }
188      if ((sockstate->masks & SOCKET_ATTACHED) == 0) {
189          return 0;
190      }
191      memset(&sockstate->ov_read, 0, sizeof(sockstate->ov_read));
192      zreadbuf.buf = zreadchar;
193      zreadbuf.len = 0;
194      result = FDAPI_WSARecv(fd,
195                             &zreadbuf,
196                             1,
197                             &bytesReceived,
198                             &recvFlags,
199                             &sockstate->ov_read,
200                             NULL);
201      if (SUCCEEDED_WITH_IOCP(result == 0)){
202          sockstate->masks |= READ_QUEUED;
203      } else {
204          errno = FDAPI_WSAGetLastError();
205          sockstate->masks &= ~READ_QUEUED;
206          return -1;
207      }
208      return 0;
209  }
210  int WSIOCP_SocketSend(int fd, char *buf, int len, void *eventLoop,
211                        void *client, void *data, void *proc) {
212      iocpSockState *sockstate;
213      int result;
214      asendreq *areq;
215      DWORD bytesSent = 0;
216      sockstate = WSIOCP_GetSocketState(fd);
217      if (sockstate != NULL &&
218          (sockstate->masks & CONNECT_PENDING)) {
219          aeWait(fd, AE_WRITABLE, 50);
220      }
221      if (sockstate == NULL ||
222          (sockstate->masks & SOCKET_ATTACHED) == 0 ||
223          proc == NULL) {
224          result = (int) write(fd, buf, len);
225          if (result == SOCKET_ERROR) {
226              errno = FDAPI_WSAGetLastError();
227          }
228          return result;
229      }
230      areq = (asendreq *) CallocMemoryNoCOW(sizeof(asendreq));
231      areq->wbuf.len = len;
232      areq->wbuf.buf = buf;
233      areq->eventLoop = (aeEventLoop *) eventLoop;
234      areq->req.client = client;
235      areq->req.data = data;
236      areq->req.len = len;
237      areq->req.buf = buf;
238      areq->proc = (aeFileProc *) proc;
239      result = FDAPI_WSASend(fd,
240                             &areq->wbuf,
241                             1,
242                             &bytesSent,
243                             0,
244                             &areq->ov,
245                             NULL);
246      if (SUCCEEDED_WITH_IOCP(result == 0)) {
247          errno = WSA_IO_PENDING;
248          sockstate->wreqs++;
249          listAddNodeTail(&sockstate->wreqlist, areq);
250      } else {
251          errno = FDAPI_WSAGetLastError();
252          FreeMemoryNoCOW(areq);
253      }
254      return SOCKET_ERROR;
255  }
256  int WSIOCP_SocketConnect(int fd, const SOCKADDR_STORAGE *socketAddrStorage) {
257      const GUID wsaid_connectex = WSAID_CONNECTEX;
258      DWORD result;
259      iocpSockState *sockstate;
260      if ((sockstate = WSIOCP_GetSocketState(fd)) == NULL) {
261          errno = WSAEINVAL;
262          return SOCKET_ERROR;
263      }
264      if (WSIOCP_SocketAttach(fd, sockstate) != 0) {
265          return SOCKET_ERROR;
266      }
267      memset(&sockstate->ov_read, 0, sizeof(sockstate->ov_read));
268      switch (socketAddrStorage->ss_family) {
269          case AF_INET:
270          {
271              SOCKADDR_IN addr;
272              memset(&addr, 0, sizeof(SOCKADDR_IN));
273              addr.sin_family = socketAddrStorage->ss_family;
274              addr.sin_addr.S_un.S_addr = INADDR_ANY;
275              addr.sin_port = 0;
276              result = bind(fd, (SOCKADDR*) &addr, sizeof(addr));
277              result = FDAPI_ConnectEx(fd,
278                                       (SOCKADDR*) socketAddrStorage,
279                                       sizeof(SOCKADDR_IN),
280                                       NULL,
281                                       0,
282                                       NULL,
283                                       &sockstate->ov_read);
284              break;
285          }
286          case AF_INET6:
287          {
288              SOCKADDR_IN6 addr;
289              memset(&addr, 0, sizeof(SOCKADDR_IN6));
290              addr.sin6_family = socketAddrStorage->ss_family;
291              memset(&(addr.sin6_addr.u.Byte), 0, 16);
292              addr.sin6_port = 0;
293              result = bind(fd, (SOCKADDR*) &addr, sizeof(addr));
294              result = FDAPI_ConnectEx(fd,
295                                       (SOCKADDR*) socketAddrStorage,
296                                       sizeof(SOCKADDR_IN6),
297                                       NULL,
298                                       0,
299                                       NULL,
300                                       &sockstate->ov_read);
301              break;
302          }
303          default:
304          {
305              ASSERT(socketAddrStorage->ss_family == AF_INET || socketAddrStorage->ss_family == AF_INET6);
306              errno = WSAEINVAL;
307              return SOCKET_ERROR;
308          }
309      }
310      if (result != TRUE) {
311          result = FDAPI_WSAGetLastError();
312          if (result == ERROR_IO_PENDING) {
313              errno = WSA_IO_PENDING;
314              sockstate->masks |= CONNECT_PENDING;
315          } else {
316              errno = result;
317              return SOCKET_ERROR;
318          }
319      }
320      return 0;
321  }
322  int WSIOCP_SocketConnectBind(int fd, const SOCKADDR_STORAGE *socketAddrStorage, const char* source_addr) {
323      const GUID wsaid_connectex = WSAID_CONNECTEX;
324      DWORD result;
325      iocpSockState *sockstate;
326      if ((sockstate = WSIOCP_GetSocketState(fd)) == NULL) {
327          errno = WSAEINVAL;
328          return SOCKET_ERROR;
329      }
330      if (WSIOCP_SocketAttach(fd, sockstate) != 0) {
331          return SOCKET_ERROR;
332      }
333      memset(&sockstate->ov_read, 0, sizeof(sockstate->ov_read));
334      int storageSize = 0;
335      switch (socketAddrStorage->ss_family) {
336          case AF_INET:
337          {
338              storageSize = sizeof(SOCKADDR_IN);
339              SOCKADDR_IN addr;
340              memset(&addr, 0, storageSize);
341              addr.sin_family = socketAddrStorage->ss_family;
342              addr.sin_addr.S_un.S_addr = INADDR_ANY;
343              addr.sin_port = 0;
344              result = bind(fd, (SOCKADDR*) &addr, sizeof(addr));
345              break;
346          }
347          case AF_INET6:
348          {
349              storageSize = sizeof(SOCKADDR_IN6);
350              SOCKADDR_IN6 addr;
351              memset(&addr, 0, storageSize);
352              addr.sin6_family = socketAddrStorage->ss_family;
353              memset(&(addr.sin6_addr.u.Byte), 0, 16);
354              addr.sin6_port = 0;
355              result = bind(fd, (SOCKADDR*) &addr, sizeof(addr));
356              break;
357          }
358          default:
359          {
360              ASSERT(socketAddrStorage->ss_family == AF_INET || socketAddrStorage->ss_family == AF_INET6);
361              errno = WSAEINVAL;
362              return SOCKET_ERROR;
363          }
364      }
365      result = FDAPI_ConnectEx(fd, (const LPSOCKADDR) socketAddrStorage,
366                               storageSize, NULL, 0, NULL, &sockstate->ov_read);
367      if (result != TRUE) {
368          result = FDAPI_WSAGetLastError();
369          if (result == ERROR_IO_PENDING) {
370              errno = WSA_IO_PENDING;
371              sockstate->masks |= CONNECT_PENDING;
372          } else {
373              errno = result;
374              return SOCKET_ERROR;
375          }
376      }
377      return 0;
378  }
379  void WSIOCP_Init(HANDLE iocp) {
380      iocph = iocp;
381      FDAPI_SetCloseSocketState(WSIOCP_CloseSocketStateRFD);
382  }
383  void WSIOCP_Cleanup() {
384      iocph = NULL;
385  }
386  static HANDLE privateheap;
387  void* CallocMemoryNoCOW(size_t size) {
388      if (!privateheap) {
389          privateheap = HeapCreate(HEAP_GENERATE_EXCEPTIONS | HEAP_NO_SERIALIZE, 0, 0);
390      }
391      return HeapAlloc(privateheap, HEAP_ZERO_MEMORY, size);
392  }
393  void FreeMemoryNoCOW(void * ptr) {
394      HeapFree(privateheap, 0, ptr);
395  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-SEGGER_SYSVIEW_FreeRTOS.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-win32_wsiocp.c</div>
                <div class="column column_space"><pre><code>34    if (memcmp(pcTaskName, "IDLE", 5) == 0) {
35      return;
36    }
37    if (_NumTasks >= SYSVIEW_FREERTOS_MAX_NOF_TASKS) {
38      SEGGER_SYSVIEW_Warn("SYSTEMVIEW: Could not record task information. Maximum number of tasks reached.");
39      return;
40    }
</pre></code></div>
                <div class="column column_space"><pre><code>118      if (listen(rfd, backlog) != 0) {
119          return SOCKET_ERROR;
120      }
121      if (WSIOCP_QueueAccept(rfd) != 0) {
122          return SOCKET_ERROR;
123      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    