
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-extent_util.c</h3>
            <pre><code>1  #include "test/jemalloc_test.h"
2  #define TEST_UTIL_EINVAL(node, a, b, c, d, why_inval) do {		\
3  	assert_d_eq(mallctl("experimental.utilization." node,		\
4  	    a, b, c, d), EINVAL, "Should fail when " why_inval);	\
5  	assert_zu_eq(out_sz, out_sz_ref,				\
6  	    "Output size touched when given invalid arguments");	\
7  	assert_d_eq(memcmp(out, out_ref, out_sz_ref), 0,		\
8  	    "Output content touched when given invalid arguments");	\
9  } while (0)
10  #define TEST_UTIL_QUERY_EINVAL(a, b, c, d, why_inval)			\
11  	TEST_UTIL_EINVAL("query", a, b, c, d, why_inval)
12  #define TEST_UTIL_BATCH_EINVAL(a, b, c, d, why_inval)			\
13  	TEST_UTIL_EINVAL("batch_query", a, b, c, d, why_inval)
14  #define TEST_UTIL_VALID(node) do {					\
15          assert_d_eq(mallctl("experimental.utilization." node,		\
16  	    out, &out_sz, in, in_sz), 0,				\
17  	    "Should return 0 on correct arguments");			\
18          assert_zu_eq(out_sz, out_sz_ref, "incorrect output size");	\
19  	assert_d_ne(memcmp(out, out_ref, out_sz_ref), 0,		\
20  	    "Output content should be changed");			\
21  } while (0)
22  #define TEST_UTIL_BATCH_VALID TEST_UTIL_VALID("batch_query")
23  #define TEST_MAX_SIZE (1 << 20)
24  TEST_BEGIN(test_query) {
25  	size_t sz;
26  	for (sz = 7; sz <= TEST_MAX_SIZE && sz <= SC_LARGE_MAXCLASS;
27  	    sz += (sz <= SC_SMALL_MAXCLASS ? 1009 : 99989)) {
28  		void *p = mallocx(sz, 0);
29  		void **in = &p;
30  		size_t in_sz = sizeof(const void *);
31  		size_t out_sz = sizeof(void *) + sizeof(size_t) * 5;
32  		void *out = mallocx(out_sz, 0);
33  		void *out_ref = mallocx(out_sz, 0);
34  		size_t out_sz_ref = out_sz;
35  		assert_ptr_not_null(p,
36  		    "test pointer allocation failed");
37  		assert_ptr_not_null(out,
38  		    "test output allocation failed");
39  		assert_ptr_not_null(out_ref,
40  		    "test reference output allocation failed");
41  #define SLABCUR_READ(out) (*(void **)out)
42  #define COUNTS(out) ((size_t *)((void **)out + 1))
43  #define NFREE_READ(out) COUNTS(out)[0]
44  #define NREGS_READ(out) COUNTS(out)[1]
45  #define SIZE_READ(out) COUNTS(out)[2]
46  #define BIN_NFREE_READ(out) COUNTS(out)[3]
47  #define BIN_NREGS_READ(out) COUNTS(out)[4]
48  		SLABCUR_READ(out) = NULL;
49  		NFREE_READ(out) = NREGS_READ(out) = SIZE_READ(out) = -1;
50  		BIN_NFREE_READ(out) = BIN_NREGS_READ(out) = -1;
51  		memcpy(out_ref, out, out_sz);
52  		TEST_UTIL_QUERY_EINVAL(NULL, &out_sz, in, in_sz,
53  		    "old is NULL");
54  		TEST_UTIL_QUERY_EINVAL(out, NULL, in, in_sz,
55  		    "oldlenp is NULL");
56  		TEST_UTIL_QUERY_EINVAL(out, &out_sz, NULL, in_sz,
57  		    "newp is NULL");
58  		TEST_UTIL_QUERY_EINVAL(out, &out_sz, in, 0,
59  		    "newlen is zero");
60  		in_sz -= 1;
61  		TEST_UTIL_QUERY_EINVAL(out, &out_sz, in, in_sz,
62  		    "invalid newlen");
63  		in_sz += 1;
64  		out_sz_ref = out_sz -= 2 * sizeof(size_t);
65  		TEST_UTIL_QUERY_EINVAL(out, &out_sz, in, in_sz,
66  		    "invalid *oldlenp");
67  		out_sz_ref = out_sz += 2 * sizeof(size_t);
68  		TEST_UTIL_VALID("query");
69  		assert_zu_le(sz, SIZE_READ(out),
70  		    "Extent size should be at least allocation size");
71  		assert_zu_eq(SIZE_READ(out) & (PAGE - 1), 0,
72  		    "Extent size should be a multiple of page size");
73  		if (sz <= SC_SMALL_MAXCLASS) {
74  			assert_zu_le(NFREE_READ(out), NREGS_READ(out),
75  			    "Extent free count exceeded region count");
76  			assert_zu_le(NREGS_READ(out), SIZE_READ(out),
77  			    "Extent region count exceeded size");
78  			assert_zu_ne(NREGS_READ(out), 0,
79  			    "Extent region count must be positive");
80  			assert_ptr_not_null(SLABCUR_READ(out),
81  			    "Current slab is null");
82  			assert_true(NFREE_READ(out) == 0
83  			    || SLABCUR_READ(out) <= p,
84  			    "Allocation should follow first fit principle");
85  			if (config_stats) {
<span onclick='openModal()' class='match'>86  				assert_zu_le(BIN_NFREE_READ(out),
87  				    BIN_NREGS_READ(out),
88  				    "Bin free count exceeded region count");
89  				assert_zu_ne(BIN_NREGS_READ(out), 0,
</span>90  				    "Bin region count must be positive");
91  				assert_zu_le(NFREE_READ(out),
92  				    BIN_NFREE_READ(out),
93  				    "Extent free count exceeded bin free count");
94  				assert_zu_le(NREGS_READ(out),
95  				    BIN_NREGS_READ(out),
96  				    "Extent region count exceeded "
97  				    "bin region count");
98  				assert_zu_eq(BIN_NREGS_READ(out)
99  				    % NREGS_READ(out), 0,
100  				    "Bin region count isn't a multiple of "
101  				    "extent region count");
102  				assert_zu_le(
103  				    BIN_NFREE_READ(out) - NFREE_READ(out),
104  				    BIN_NREGS_READ(out) - NREGS_READ(out),
105  				    "Free count in other extents in the bin "
106  				    "exceeded region count in other extents "
107  				    "in the bin");
108  				assert_zu_le(NREGS_READ(out) - NFREE_READ(out),
109  				    BIN_NREGS_READ(out) - BIN_NFREE_READ(out),
110  				    "Extent utilized count exceeded "
111  				    "bin utilized count");
112  			}
113  		} else {
114  			assert_zu_eq(NFREE_READ(out), 0,
115  			    "Extent free count should be zero");
116  			assert_zu_eq(NREGS_READ(out), 1,
117  			    "Extent region count should be one");
118  			assert_ptr_null(SLABCUR_READ(out),
119  			    "Current slab must be null for large size classes");
120  			if (config_stats) {
121  				assert_zu_eq(BIN_NFREE_READ(out), 0,
122  				    "Bin free count must be zero for "
123  				    "large sizes");
124  				assert_zu_eq(BIN_NREGS_READ(out), 0,
125  				    "Bin region count must be zero for "
126  				    "large sizes");
127  			}
128  		}
129  #undef BIN_NREGS_READ
130  #undef BIN_NFREE_READ
131  #undef SIZE_READ
132  #undef NREGS_READ
133  #undef NFREE_READ
134  #undef COUNTS
135  #undef SLABCUR_READ
136  		free(out_ref);
137  		free(out);
138  		free(p);
139  	}
140  }
141  TEST_END
142  TEST_BEGIN(test_batch) {
143  	size_t sz;
144  	for (sz = 17; sz <= TEST_MAX_SIZE && sz <= SC_LARGE_MAXCLASS;
145  	    sz += (sz <= SC_SMALL_MAXCLASS ? 1019 : 99991)) {
146  		void *p = mallocx(sz, 0);
147  		void *q = mallocx(sz, 0);
148  		void *in[] = {p, q};
149  		size_t in_sz = sizeof(const void *) * 2;
150  		size_t out[] = {-1, -1, -1, -1, -1, -1};
151  		size_t out_sz = sizeof(size_t) * 6;
152  		size_t out_ref[] = {-1, -1, -1, -1, -1, -1};
153  		size_t out_sz_ref = out_sz;
154  		assert_ptr_not_null(p, "test pointer allocation failed");
155  		assert_ptr_not_null(q, "test pointer allocation failed");
156  		TEST_UTIL_BATCH_EINVAL(NULL, &out_sz, in, in_sz,
157  		    "old is NULL");
158  		TEST_UTIL_BATCH_EINVAL(out, NULL, in, in_sz,
159  		    "oldlenp is NULL");
160  		TEST_UTIL_BATCH_EINVAL(out, &out_sz, NULL, in_sz,
161  		    "newp is NULL");
162  		TEST_UTIL_BATCH_EINVAL(out, &out_sz, in, 0,
163  		    "newlen is zero");
164  		in_sz -= 1;
165  		TEST_UTIL_BATCH_EINVAL(out, &out_sz, in, in_sz,
166  		    "newlen is not an exact multiple");
167  		in_sz += 1;
168  		out_sz_ref = out_sz -= 2 * sizeof(size_t);
169  		TEST_UTIL_BATCH_EINVAL(out, &out_sz, in, in_sz,
170  		    "*oldlenp is not an exact multiple");
171  		out_sz_ref = out_sz += 2 * sizeof(size_t);
172  		in_sz -= sizeof(const void *);
173  		TEST_UTIL_BATCH_EINVAL(out, &out_sz, in, in_sz,
174  		    "*oldlenp and newlen do not match");
175  		in_sz += sizeof(const void *);
176  #define TEST_EQUAL_REF(i, message) \
177  	assert_d_eq(memcmp(out + (i) * 3, out_ref + (i) * 3, 3), 0, message)
178  #define NFREE_READ(out, i) out[(i) * 3]
179  #define NREGS_READ(out, i) out[(i) * 3 + 1]
180  #define SIZE_READ(out, i) out[(i) * 3 + 2]
181  		out_sz_ref = out_sz /= 2;
182  		in_sz /= 2;
183  		TEST_UTIL_BATCH_VALID;
184  		assert_zu_le(sz, SIZE_READ(out, 0),
185  		    "Extent size should be at least allocation size");
186  		assert_zu_eq(SIZE_READ(out, 0) & (PAGE - 1), 0,
187  		    "Extent size should be a multiple of page size");
188  		if (sz <= SC_SMALL_MAXCLASS) {
189  			assert_zu_le(NFREE_READ(out, 0), NREGS_READ(out, 0),
190  			    "Extent free count exceeded region count");
191  			assert_zu_le(NREGS_READ(out, 0), SIZE_READ(out, 0),
192  			    "Extent region count exceeded size");
193  			assert_zu_ne(NREGS_READ(out, 0), 0,
194  			    "Extent region count must be positive");
195  		} else {
196  			assert_zu_eq(NFREE_READ(out, 0), 0,
197  			    "Extent free count should be zero");
198  			assert_zu_eq(NREGS_READ(out, 0), 1,
199  			    "Extent region count should be one");
200  		}
201  		TEST_EQUAL_REF(1,
202  		    "Should not overwrite content beyond what's needed");
203  		in_sz *= 2;
204  		out_sz_ref = out_sz *= 2;
205  		memcpy(out_ref, out, 3 * sizeof(size_t));
206  		TEST_UTIL_BATCH_VALID;
207  		TEST_EQUAL_REF(0, "Statistics should be stable across calls");
208  		if (sz <= SC_SMALL_MAXCLASS) {
209  			assert_zu_le(NFREE_READ(out, 1), NREGS_READ(out, 1),
210  			    "Extent free count exceeded region count");
211  		} else {
212  			assert_zu_eq(NFREE_READ(out, 0), 0,
213  			    "Extent free count should be zero");
214  		}
215  		assert_zu_eq(NREGS_READ(out, 0), NREGS_READ(out, 1),
216  		    "Extent region count should be same for same region size");
217  		assert_zu_eq(SIZE_READ(out, 0), SIZE_READ(out, 1),
218  		    "Extent size should be same for same region size");
219  #undef SIZE_READ
220  #undef NREGS_READ
221  #undef NFREE_READ
222  #undef TEST_EQUAL_REF
223  		free(q);
224  		free(p);
225  	}
226  }
227  TEST_END
228  int
229  main(void) {
230  	assert_zu_lt(SC_SMALL_MAXCLASS, TEST_MAX_SIZE,
231  	    "Test case cannot cover large classes");
232  	return test(test_query, test_batch);
233  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-extent_util.c</h3>
            <pre><code>1  #include "test/jemalloc_test.h"
2  #define TEST_UTIL_EINVAL(node, a, b, c, d, why_inval) do {		\
3  	assert_d_eq(mallctl("experimental.utilization." node,		\
4  	    a, b, c, d), EINVAL, "Should fail when " why_inval);	\
5  	assert_zu_eq(out_sz, out_sz_ref,				\
6  	    "Output size touched when given invalid arguments");	\
7  	assert_d_eq(memcmp(out, out_ref, out_sz_ref), 0,		\
8  	    "Output content touched when given invalid arguments");	\
9  } while (0)
10  #define TEST_UTIL_QUERY_EINVAL(a, b, c, d, why_inval)			\
11  	TEST_UTIL_EINVAL("query", a, b, c, d, why_inval)
12  #define TEST_UTIL_BATCH_EINVAL(a, b, c, d, why_inval)			\
13  	TEST_UTIL_EINVAL("batch_query", a, b, c, d, why_inval)
14  #define TEST_UTIL_VALID(node) do {					\
15          assert_d_eq(mallctl("experimental.utilization." node,		\
16  	    out, &out_sz, in, in_sz), 0,				\
17  	    "Should return 0 on correct arguments");			\
18          assert_zu_eq(out_sz, out_sz_ref, "incorrect output size");	\
19  	assert_d_ne(memcmp(out, out_ref, out_sz_ref), 0,		\
20  	    "Output content should be changed");			\
21  } while (0)
22  #define TEST_UTIL_BATCH_VALID TEST_UTIL_VALID("batch_query")
23  #define TEST_MAX_SIZE (1 << 20)
24  TEST_BEGIN(test_query) {
25  	size_t sz;
26  	for (sz = 7; sz <= TEST_MAX_SIZE && sz <= SC_LARGE_MAXCLASS;
27  	    sz += (sz <= SC_SMALL_MAXCLASS ? 1009 : 99989)) {
28  		void *p = mallocx(sz, 0);
29  		void **in = &p;
30  		size_t in_sz = sizeof(const void *);
31  		size_t out_sz = sizeof(void *) + sizeof(size_t) * 5;
32  		void *out = mallocx(out_sz, 0);
33  		void *out_ref = mallocx(out_sz, 0);
34  		size_t out_sz_ref = out_sz;
35  		assert_ptr_not_null(p,
36  		    "test pointer allocation failed");
37  		assert_ptr_not_null(out,
38  		    "test output allocation failed");
39  		assert_ptr_not_null(out_ref,
40  		    "test reference output allocation failed");
41  #define SLABCUR_READ(out) (*(void **)out)
42  #define COUNTS(out) ((size_t *)((void **)out + 1))
43  #define NFREE_READ(out) COUNTS(out)[0]
44  #define NREGS_READ(out) COUNTS(out)[1]
45  #define SIZE_READ(out) COUNTS(out)[2]
46  #define BIN_NFREE_READ(out) COUNTS(out)[3]
47  #define BIN_NREGS_READ(out) COUNTS(out)[4]
48  		SLABCUR_READ(out) = NULL;
49  		NFREE_READ(out) = NREGS_READ(out) = SIZE_READ(out) = -1;
50  		BIN_NFREE_READ(out) = BIN_NREGS_READ(out) = -1;
51  		memcpy(out_ref, out, out_sz);
52  		TEST_UTIL_QUERY_EINVAL(NULL, &out_sz, in, in_sz,
53  		    "old is NULL");
54  		TEST_UTIL_QUERY_EINVAL(out, NULL, in, in_sz,
55  		    "oldlenp is NULL");
56  		TEST_UTIL_QUERY_EINVAL(out, &out_sz, NULL, in_sz,
57  		    "newp is NULL");
58  		TEST_UTIL_QUERY_EINVAL(out, &out_sz, in, 0,
59  		    "newlen is zero");
60  		in_sz -= 1;
61  		TEST_UTIL_QUERY_EINVAL(out, &out_sz, in, in_sz,
62  		    "invalid newlen");
63  		in_sz += 1;
64  		out_sz_ref = out_sz -= 2 * sizeof(size_t);
65  		TEST_UTIL_QUERY_EINVAL(out, &out_sz, in, in_sz,
66  		    "invalid *oldlenp");
67  		out_sz_ref = out_sz += 2 * sizeof(size_t);
68  		TEST_UTIL_VALID("query");
69  		assert_zu_le(sz, SIZE_READ(out),
70  		    "Extent size should be at least allocation size");
71  		assert_zu_eq(SIZE_READ(out) & (PAGE - 1), 0,
72  		    "Extent size should be a multiple of page size");
73  		if (sz <= SC_SMALL_MAXCLASS) {
74  			assert_zu_le(NFREE_READ(out), NREGS_READ(out),
75  			    "Extent free count exceeded region count");
<span onclick='openModal()' class='match'>76  			assert_zu_le(NREGS_READ(out), SIZE_READ(out),
77  			    "Extent region count exceeded size");
78  			assert_zu_ne(NREGS_READ(out), 0,
</span>79  			    "Extent region count must be positive");
80  			assert_ptr_not_null(SLABCUR_READ(out),
81  			    "Current slab is null");
82  			assert_true(NFREE_READ(out) == 0
83  			    || SLABCUR_READ(out) <= p,
84  			    "Allocation should follow first fit principle");
85  			if (config_stats) {
86  				assert_zu_le(BIN_NFREE_READ(out),
87  				    BIN_NREGS_READ(out),
88  				    "Bin free count exceeded region count");
89  				assert_zu_ne(BIN_NREGS_READ(out), 0,
90  				    "Bin region count must be positive");
91  				assert_zu_le(NFREE_READ(out),
92  				    BIN_NFREE_READ(out),
93  				    "Extent free count exceeded bin free count");
94  				assert_zu_le(NREGS_READ(out),
95  				    BIN_NREGS_READ(out),
96  				    "Extent region count exceeded "
97  				    "bin region count");
98  				assert_zu_eq(BIN_NREGS_READ(out)
99  				    % NREGS_READ(out), 0,
100  				    "Bin region count isn't a multiple of "
101  				    "extent region count");
102  				assert_zu_le(
103  				    BIN_NFREE_READ(out) - NFREE_READ(out),
104  				    BIN_NREGS_READ(out) - NREGS_READ(out),
105  				    "Free count in other extents in the bin "
106  				    "exceeded region count in other extents "
107  				    "in the bin");
108  				assert_zu_le(NREGS_READ(out) - NFREE_READ(out),
109  				    BIN_NREGS_READ(out) - BIN_NFREE_READ(out),
110  				    "Extent utilized count exceeded "
111  				    "bin utilized count");
112  			}
113  		} else {
114  			assert_zu_eq(NFREE_READ(out), 0,
115  			    "Extent free count should be zero");
116  			assert_zu_eq(NREGS_READ(out), 1,
117  			    "Extent region count should be one");
118  			assert_ptr_null(SLABCUR_READ(out),
119  			    "Current slab must be null for large size classes");
120  			if (config_stats) {
121  				assert_zu_eq(BIN_NFREE_READ(out), 0,
122  				    "Bin free count must be zero for "
123  				    "large sizes");
124  				assert_zu_eq(BIN_NREGS_READ(out), 0,
125  				    "Bin region count must be zero for "
126  				    "large sizes");
127  			}
128  		}
129  #undef BIN_NREGS_READ
130  #undef BIN_NFREE_READ
131  #undef SIZE_READ
132  #undef NREGS_READ
133  #undef NFREE_READ
134  #undef COUNTS
135  #undef SLABCUR_READ
136  		free(out_ref);
137  		free(out);
138  		free(p);
139  	}
140  }
141  TEST_END
142  TEST_BEGIN(test_batch) {
143  	size_t sz;
144  	for (sz = 17; sz <= TEST_MAX_SIZE && sz <= SC_LARGE_MAXCLASS;
145  	    sz += (sz <= SC_SMALL_MAXCLASS ? 1019 : 99991)) {
146  		void *p = mallocx(sz, 0);
147  		void *q = mallocx(sz, 0);
148  		void *in[] = {p, q};
149  		size_t in_sz = sizeof(const void *) * 2;
150  		size_t out[] = {-1, -1, -1, -1, -1, -1};
151  		size_t out_sz = sizeof(size_t) * 6;
152  		size_t out_ref[] = {-1, -1, -1, -1, -1, -1};
153  		size_t out_sz_ref = out_sz;
154  		assert_ptr_not_null(p, "test pointer allocation failed");
155  		assert_ptr_not_null(q, "test pointer allocation failed");
156  		TEST_UTIL_BATCH_EINVAL(NULL, &out_sz, in, in_sz,
157  		    "old is NULL");
158  		TEST_UTIL_BATCH_EINVAL(out, NULL, in, in_sz,
159  		    "oldlenp is NULL");
160  		TEST_UTIL_BATCH_EINVAL(out, &out_sz, NULL, in_sz,
161  		    "newp is NULL");
162  		TEST_UTIL_BATCH_EINVAL(out, &out_sz, in, 0,
163  		    "newlen is zero");
164  		in_sz -= 1;
165  		TEST_UTIL_BATCH_EINVAL(out, &out_sz, in, in_sz,
166  		    "newlen is not an exact multiple");
167  		in_sz += 1;
168  		out_sz_ref = out_sz -= 2 * sizeof(size_t);
169  		TEST_UTIL_BATCH_EINVAL(out, &out_sz, in, in_sz,
170  		    "*oldlenp is not an exact multiple");
171  		out_sz_ref = out_sz += 2 * sizeof(size_t);
172  		in_sz -= sizeof(const void *);
173  		TEST_UTIL_BATCH_EINVAL(out, &out_sz, in, in_sz,
174  		    "*oldlenp and newlen do not match");
175  		in_sz += sizeof(const void *);
176  #define TEST_EQUAL_REF(i, message) \
177  	assert_d_eq(memcmp(out + (i) * 3, out_ref + (i) * 3, 3), 0, message)
178  #define NFREE_READ(out, i) out[(i) * 3]
179  #define NREGS_READ(out, i) out[(i) * 3 + 1]
180  #define SIZE_READ(out, i) out[(i) * 3 + 2]
181  		out_sz_ref = out_sz /= 2;
182  		in_sz /= 2;
183  		TEST_UTIL_BATCH_VALID;
184  		assert_zu_le(sz, SIZE_READ(out, 0),
185  		    "Extent size should be at least allocation size");
186  		assert_zu_eq(SIZE_READ(out, 0) & (PAGE - 1), 0,
187  		    "Extent size should be a multiple of page size");
188  		if (sz <= SC_SMALL_MAXCLASS) {
189  			assert_zu_le(NFREE_READ(out, 0), NREGS_READ(out, 0),
190  			    "Extent free count exceeded region count");
191  			assert_zu_le(NREGS_READ(out, 0), SIZE_READ(out, 0),
192  			    "Extent region count exceeded size");
193  			assert_zu_ne(NREGS_READ(out, 0), 0,
194  			    "Extent region count must be positive");
195  		} else {
196  			assert_zu_eq(NFREE_READ(out, 0), 0,
197  			    "Extent free count should be zero");
198  			assert_zu_eq(NREGS_READ(out, 0), 1,
199  			    "Extent region count should be one");
200  		}
201  		TEST_EQUAL_REF(1,
202  		    "Should not overwrite content beyond what's needed");
203  		in_sz *= 2;
204  		out_sz_ref = out_sz *= 2;
205  		memcpy(out_ref, out, 3 * sizeof(size_t));
206  		TEST_UTIL_BATCH_VALID;
207  		TEST_EQUAL_REF(0, "Statistics should be stable across calls");
208  		if (sz <= SC_SMALL_MAXCLASS) {
209  			assert_zu_le(NFREE_READ(out, 1), NREGS_READ(out, 1),
210  			    "Extent free count exceeded region count");
211  		} else {
212  			assert_zu_eq(NFREE_READ(out, 0), 0,
213  			    "Extent free count should be zero");
214  		}
215  		assert_zu_eq(NREGS_READ(out, 0), NREGS_READ(out, 1),
216  		    "Extent region count should be same for same region size");
217  		assert_zu_eq(SIZE_READ(out, 0), SIZE_READ(out, 1),
218  		    "Extent size should be same for same region size");
219  #undef SIZE_READ
220  #undef NREGS_READ
221  #undef NFREE_READ
222  #undef TEST_EQUAL_REF
223  		free(q);
224  		free(p);
225  	}
226  }
227  TEST_END
228  int
229  main(void) {
230  	assert_zu_lt(SC_SMALL_MAXCLASS, TEST_MAX_SIZE,
231  	    "Test case cannot cover large classes");
232  	return test(test_query, test_batch);
233  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-extent_util.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-extent_util.c</div>
                </div>
                <div class="column column_space"><pre><code>86  				assert_zu_le(BIN_NFREE_READ(out),
87  				    BIN_NREGS_READ(out),
88  				    "Bin free count exceeded region count");
89  				assert_zu_ne(BIN_NREGS_READ(out), 0,
</pre></code></div>
                <div class="column column_space"><pre><code>76  			assert_zu_le(NREGS_READ(out), SIZE_READ(out),
77  			    "Extent region count exceeded size");
78  			assert_zu_ne(NREGS_READ(out), 0,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    