
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dft-r2hc.c</h3>
            <pre><code>1  #include "rdft/rdft.h"
2  #include "dft/dft.h"
3  typedef struct {
4       solver super;
5  } S;
6  typedef struct {
7       plan_dft super;
8       plan *cld;
9       INT ishift, oshift;
10       INT os;
11       INT n;
12  } P;
13  static void apply(const plan *ego_, R *ri, R *ii, R *ro, R *io)
14  {
15       const P *ego = (const P *) ego_;
16       INT n;
17       UNUSED(ii);
18       { &bsol;* transform vector of real & imag parts: */
19  	  plan_rdft *cld = (plan_rdft *) ego->cld;
20  	  cld->apply((plan *) cld, ri + ego->ishift, ro + ego->oshift);
21       }
22       n = ego->n;
23       if (n > 1) {
24  	  INT i, os = ego->os;
25  	  for (i = 1; i < (n + 1)/2; ++i) {
26  	       E rop, iop, iom, rom;
27  	       rop = ro[os * i];
28  	       iop = io[os * i];
29  	       rom = ro[os * (n - i)];
30  	       iom = io[os * (n - i)];
31  	       ro[os * i] = rop - iom;
32  	       io[os * i] = iop + rom;
33  	       ro[os * (n - i)] = rop + iom;
34  	       io[os * (n - i)] = iop - rom;
35  	  }
36       }
37  }
38  static void awake(plan *ego_, enum wakefulness wakefulness)
39  {
40       P *ego = (P *) ego_;
41       X(plan_awake)(ego->cld, wakefulness);
42  }
43  static void destroy(plan *ego_)
44  {
45       P *ego = (P *) ego_;
46       X(plan_destroy_internal)(ego->cld);
47  }
48  static void print(const plan *ego_, printer *p)
49  {
50       const P *ego = (const P *) ego_;
51       p->print(p, "(dft-r2hc-%D%(%p%))", ego->n, ego->cld);
52  }
53  static int applicable0(const problem *p_)
54  {
55       const problem_dft *p = (const problem_dft *) p_;
56       return ((p->sz->rnk == 1 && p->vecsz->rnk == 0)
57  	     || (p->sz->rnk == 0 && FINITE_RNK(p->vecsz->rnk))
58  	  );
59  }
60  static int splitp(R *r, R *i, INT n, INT s)
61  {
62       return ((r > i ? (r - i) : (i - r)) >= n * (s > 0 ? s : 0-s));
63  }
64  static int applicable(const problem *p_, const planner *plnr)
65  {
66       if (!applicable0(p_)) return 0;
67       {
68  	  const problem_dft *p = (const problem_dft *) p_;
69  	  if (p->sz->rnk == 0) return 1;
70  	  if (p->sz->rnk == 1 &&
71  	      splitp(p->ri, p->ii, p->sz->dims[0].n, p->sz->dims[0].is) &&
72  	      splitp(p->ro, p->io, p->sz->dims[0].n, p->sz->dims[0].os))
73  	       return 1;
74  	  return !(NO_DFT_R2HCP(plnr));
75       }
76  }
77  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
78  {
79       P *pln;
80       const problem_dft *p;
81       plan *cld;
82       INT ishift = 0, oshift = 0;
83       static const plan_adt padt = {
84  	  X(dft_solve), awake, print, destroy
85       };
86       UNUSED(ego_);
87       if (!applicable(p_, plnr))
88            return (plan *)0;
89       p = (const problem_dft *) p_;
90       {
91  	  tensor *ri_vec = X(mktensor_1d)(2, p->ii - p->ri, p->io - p->ro);
92  	  tensor *cld_vec = X(tensor_append)(ri_vec, p->vecsz);
93  	  int i;
94  	  for (i = 0; i < cld_vec->rnk; ++i) { &bsol;* make all istrides > 0 */
95  	       if (cld_vec->dims[i].is < 0) {
96  		    INT nm1 = cld_vec->dims[i].n - 1;
<span onclick='openModal()' class='match'>97  		    ishift -= nm1 * (cld_vec->dims[i].is *= -1);
98  		    oshift -= nm1 * (cld_vec->dims[i].os *= -1);
</span>99  	       }
100  	  }
101  	  cld = X(mkplan_d)(plnr, 
102  			    X(mkproblem_rdft_1)(p->sz, cld_vec, 
103  						p->ri + ishift, 
104  						p->ro + oshift, R2HC));
105  	  X(tensor_destroy2)(ri_vec, cld_vec);
106       }
107       if (!cld) return (plan *)0;
108       pln = MKPLAN_DFT(P, &padt, apply);
109       if (p->sz->rnk == 0) {
110  	  pln->n = 1;
111  	  pln->os = 0;
112       }
113       else {
114  	  pln->n = p->sz->dims[0].n;
115  	  pln->os = p->sz->dims[0].os;
116       }
117       pln->ishift = ishift;
118       pln->oshift = oshift;
119       pln->cld = cld;
120       pln->super.super.ops = cld->ops;
121       pln->super.super.ops.other += 8 * ((pln->n - 1)/2);
122       pln->super.super.ops.add += 4 * ((pln->n - 1)/2);
123       pln->super.super.ops.other += 1; &bsol;* estimator hack for nop plans */
124       return &(pln->super.super);
125  }
126  static solver *mksolver(void)
127  {
128       static const solver_adt sadt = { PROBLEM_DFT, mkplan, 0 };
129       S *slv = MKSOLVER(S, &sadt);
130       return &(slv->super);
131  }
132  void X(dft_r2hc_register)(planner *p)
133  {
134       REGISTER_SOLVER(p, mksolver());
135  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dft-r2hc.c</h3>
            <pre><code>1  #include "rdft/rdft.h"
2  #include "dft/dft.h"
3  typedef struct {
4       solver super;
5  } S;
6  typedef struct {
7       plan_dft super;
8       plan *cld;
9       INT ishift, oshift;
10       INT os;
11       INT n;
12  } P;
13  static void apply(const plan *ego_, R *ri, R *ii, R *ro, R *io)
14  {
15       const P *ego = (const P *) ego_;
16       INT n;
17       UNUSED(ii);
18       { &bsol;* transform vector of real & imag parts: */
19  	  plan_rdft *cld = (plan_rdft *) ego->cld;
20  	  cld->apply((plan *) cld, ri + ego->ishift, ro + ego->oshift);
21       }
22       n = ego->n;
23       if (n > 1) {
24  	  INT i, os = ego->os;
25  	  for (i = 1; i < (n + 1)/2; ++i) {
26  	       E rop, iop, iom, rom;
27  	       rop = ro[os * i];
28  	       iop = io[os * i];
29  	       rom = ro[os * (n - i)];
30  	       iom = io[os * (n - i)];
31  	       ro[os * i] = rop - iom;
32  	       io[os * i] = iop + rom;
33  	       ro[os * (n - i)] = rop + iom;
34  	       io[os * (n - i)] = iop - rom;
35  	  }
36       }
37  }
38  static void awake(plan *ego_, enum wakefulness wakefulness)
39  {
40       P *ego = (P *) ego_;
41       X(plan_awake)(ego->cld, wakefulness);
42  }
43  static void destroy(plan *ego_)
44  {
45       P *ego = (P *) ego_;
46       X(plan_destroy_internal)(ego->cld);
47  }
48  static void print(const plan *ego_, printer *p)
49  {
50       const P *ego = (const P *) ego_;
51       p->print(p, "(dft-r2hc-%D%(%p%))", ego->n, ego->cld);
52  }
53  static int applicable0(const problem *p_)
54  {
55       const problem_dft *p = (const problem_dft *) p_;
56       return ((p->sz->rnk == 1 && p->vecsz->rnk == 0)
57  	     || (p->sz->rnk == 0 && FINITE_RNK(p->vecsz->rnk))
58  	  );
59  }
60  static int splitp(R *r, R *i, INT n, INT s)
61  {
62       return ((r > i ? (r - i) : (i - r)) >= n * (s > 0 ? s : 0-s));
63  }
64  static int applicable(const problem *p_, const planner *plnr)
65  {
66       if (!applicable0(p_)) return 0;
67       {
68  	  const problem_dft *p = (const problem_dft *) p_;
69  	  if (p->sz->rnk == 0) return 1;
70  	  if (p->sz->rnk == 1 &&
71  	      splitp(p->ri, p->ii, p->sz->dims[0].n, p->sz->dims[0].is) &&
72  	      splitp(p->ro, p->io, p->sz->dims[0].n, p->sz->dims[0].os))
73  	       return 1;
74  	  return !(NO_DFT_R2HCP(plnr));
75       }
76  }
77  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
78  {
79       P *pln;
80       const problem_dft *p;
81       plan *cld;
82       INT ishift = 0, oshift = 0;
83       static const plan_adt padt = {
84  	  X(dft_solve), awake, print, destroy
85       };
86       UNUSED(ego_);
87       if (!applicable(p_, plnr))
88            return (plan *)0;
89       p = (const problem_dft *) p_;
90       {
91  	  tensor *ri_vec = X(mktensor_1d)(2, p->ii - p->ri, p->io - p->ro);
92  	  tensor *cld_vec = X(tensor_append)(ri_vec, p->vecsz);
93  	  int i;
94  	  for (i = 0; i < cld_vec->rnk; ++i) { &bsol;* make all istrides > 0 */
95  	       if (cld_vec->dims[i].is < 0) {
96  		    INT nm1 = cld_vec->dims[i].n - 1;
97  		    ishift -= nm1 * (cld_vec->dims[i].is *= -1);
<span onclick='openModal()' class='match'>98  		    oshift -= nm1 * (cld_vec->dims[i].os *= -1);
99  	       }
</span>100  	  }
101  	  cld = X(mkplan_d)(plnr, 
102  			    X(mkproblem_rdft_1)(p->sz, cld_vec, 
103  						p->ri + ishift, 
104  						p->ro + oshift, R2HC));
105  	  X(tensor_destroy2)(ri_vec, cld_vec);
106       }
107       if (!cld) return (plan *)0;
108       pln = MKPLAN_DFT(P, &padt, apply);
109       if (p->sz->rnk == 0) {
110  	  pln->n = 1;
111  	  pln->os = 0;
112       }
113       else {
114  	  pln->n = p->sz->dims[0].n;
115  	  pln->os = p->sz->dims[0].os;
116       }
117       pln->ishift = ishift;
118       pln->oshift = oshift;
119       pln->cld = cld;
120       pln->super.super.ops = cld->ops;
121       pln->super.super.ops.other += 8 * ((pln->n - 1)/2);
122       pln->super.super.ops.add += 4 * ((pln->n - 1)/2);
123       pln->super.super.ops.other += 1; &bsol;* estimator hack for nop plans */
124       return &(pln->super.super);
125  }
126  static solver *mksolver(void)
127  {
128       static const solver_adt sadt = { PROBLEM_DFT, mkplan, 0 };
129       S *slv = MKSOLVER(S, &sadt);
130       return &(slv->super);
131  }
132  void X(dft_r2hc_register)(planner *p)
133  {
134       REGISTER_SOLVER(p, mksolver());
135  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dft-r2hc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dft-r2hc.c</div>
                </div>
                <div class="column column_space"><pre><code>97  		    ishift -= nm1 * (cld_vec->dims[i].is *= -1);
98  		    oshift -= nm1 * (cld_vec->dims[i].os *= -1);
</pre></code></div>
                <div class="column column_space"><pre><code>98  		    oshift -= nm1 * (cld_vec->dims[i].os *= -1);
99  	       }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    