
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 23.05295950155763%, Tokens: 10</h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-blake2-impl_9.h</h3>
            <pre><code>1  #ifndef ARGON2_BLAKE2_IMPL_H
2  #define ARGON2_BLAKE2_IMPL_H
3  #include <stdint.h>
4  #if (defined(__BYTE_ORDER__) &&                                                \
5       (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)) ||                           \
6      defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) || defined(__MIPSEL__) || \
7      defined(__AARCH64EL__) || defined(__amd64__) || defined(__i386__) ||       \
8      defined(_M_IX86) || defined(_M_X64) || defined(_M_AMD64) ||                \
9      defined(_M_ARM)
10  #define NATIVE_LITTLE_ENDIAN
11  #endif
12  static inline uint32_t load32(const void *src) {
13  #if defined(NATIVE_LITTLE_ENDIAN)
14      return *(const uint32_t *)src;
15  #else
16      const uint8_t *p = (const uint8_t *)src;
17      uint32_t w = *p++;
18      w |= (uint32_t)(*p++) << 8;
19      w |= (uint32_t)(*p++) << 16;
20      w |= (uint32_t)(*p++) << 24;
21      return w;
22  #endif
23  }
24  static inline uint64_t load64(const void *src) {
25  #if defined(NATIVE_LITTLE_ENDIAN)
26      return *(const uint64_t *)src;
27  #else
28      const uint8_t *p = (const uint8_t *)src;
29      uint64_t w = *p++;
30      w |= (uint64_t)(*p++) << 8;
31      w |= (uint64_t)(*p++) << 16;
32      w |= (uint64_t)(*p++) << 24;
33      w |= (uint64_t)(*p++) << 32;
34      w |= (uint64_t)(*p++) << 40;
35      w |= (uint64_t)(*p++) << 48;
36      w |= (uint64_t)(*p++) << 56;
37      return w;
38  #endif
39  }
<span onclick='openModal()' class='match'>40  static inline void store32(void *dst, uint32_t w) {
41  #if defined(NATIVE_LITTLE_ENDIAN)
42      *(uint32_t *)dst = w;
43  #else
44      uint8_t *p = (uint8_t *)dst;
45      *p++ = (uint8_t)w;
46      w >>= 8;
47      *p++ = (uint8_t)w;
48      w >>= 8;
49      *p++ = (uint8_t)w;
</span>50      w >>= 8;
51      *p++ = (uint8_t)w;
52  #endif
53  }
54  static inline void store64(void *dst, uint64_t w) {
55  #if defined(NATIVE_LITTLE_ENDIAN)
56      *(uint64_t *)dst = w;
57  #else
58      uint8_t *p = (uint8_t *)dst;
59      *p++ = (uint8_t)w;
60      w >>= 8;
61      *p++ = (uint8_t)w;
62      w >>= 8;
63      *p++ = (uint8_t)w;
64      w >>= 8;
65      *p++ = (uint8_t)w;
66      w >>= 8;
67      *p++ = (uint8_t)w;
68      w >>= 8;
69      *p++ = (uint8_t)w;
70      w >>= 8;
71      *p++ = (uint8_t)w;
72      w >>= 8;
73      *p++ = (uint8_t)w;
74  #endif
75  }
76  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_i2s.h</h3>
            <pre><code>1  #ifndef NRF_I2S_H__
2  #define NRF_I2S_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #if defined(I2S_CONFIG_CLKCONFIG_CLKSRC_Msk) || defined(__NRFX_DOXYGEN__)
8  #define NRF_I2S_HAS_CLKCONFIG 1
9  #else
10  #define NRF_I2S_HAS_CLKCONFIG 0
11  #endif
12  #define NRF_I2S_PIN_NOT_CONNECTED  0xFFFFFFFF
13  typedef enum
14  {
15      NRF_I2S_TASK_START = offsetof(NRF_I2S_Type, TASKS_START), 
16      NRF_I2S_TASK_STOP  = offsetof(NRF_I2S_Type, TASKS_STOP)   
17  } nrf_i2s_task_t;
18  typedef enum
19  {
20      NRF_I2S_EVENT_RXPTRUPD   = offsetof(NRF_I2S_Type, EVENTS_RXPTRUPD),  
21      NRF_I2S_EVENT_TXPTRUPD   = offsetof(NRF_I2S_Type, EVENTS_TXPTRUPD),  
22      NRF_I2S_EVENT_STOPPED    = offsetof(NRF_I2S_Type, EVENTS_STOPPED),   
23  #if defined(I2S_INTENSET_FRAMESTART_Msk) || defined(__NRFX_DOXYGEN_)
24      NRF_I2S_EVENT_FRAMESTART = offsetof(NRF_I2S_Type, EVENTS_FRAMESTART) 
25  #endif
26  } nrf_i2s_event_t;
27  typedef enum
28  {
29      NRF_I2S_INT_RXPTRUPD_MASK   = I2S_INTENSET_RXPTRUPD_Msk,  
30      NRF_I2S_INT_TXPTRUPD_MASK   = I2S_INTENSET_TXPTRUPD_Msk,  
31      NRF_I2S_INT_STOPPED_MASK    = I2S_INTENSET_STOPPED_Msk,   
32  #if defined(I2S_INTENSET_FRAMESTART_Msk) || defined(__NRFX_DOXYGEN_)
33      NRF_I2S_INT_FRAMESTART_MASK = I2S_INTENCLR_FRAMESTART_Msk 
34  #endif
35  } nrf_i2s_int_mask_t;
36  typedef enum
37  {
38      NRF_I2S_MODE_MASTER = I2S_CONFIG_MODE_MODE_Master, 
39      NRF_I2S_MODE_SLAVE  = I2S_CONFIG_MODE_MODE_Slave   
40  } nrf_i2s_mode_t;
41  typedef enum
42  {
43      NRF_I2S_MCK_DISABLED  = 0,                                       
44  #if defined(I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV2) || defined(__NRFX_DOXYGEN__)
45      NRF_I2S_MCK_32MDIV2   = (int)I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV2, 
46  #endif
47  #if defined(I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV3) || defined(__NRFX_DOXYGEN__)
48      NRF_I2S_MCK_32MDIV3   = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV3,      
49  #endif
50  #if defined(I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV4) || defined(__NRFX_DOXYGEN__)
51      NRF_I2S_MCK_32MDIV4   = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV4,      
52  #endif
53  #if defined(I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV5) || defined(__NRFX_DOXYGEN__)
54      NRF_I2S_MCK_32MDIV5   = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV5,      
55  #endif
56  #if defined(I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV6) || defined(__NRFX_DOXYGEN__)
57      NRF_I2S_MCK_32MDIV6   = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV6,      
58  #endif
59      NRF_I2S_MCK_32MDIV8   = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV8,      
60      NRF_I2S_MCK_32MDIV10  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV10,     
61      NRF_I2S_MCK_32MDIV11  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV11,     
62      NRF_I2S_MCK_32MDIV15  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV15,     
63      NRF_I2S_MCK_32MDIV16  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV16,     
64      NRF_I2S_MCK_32MDIV21  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV21,     
65      NRF_I2S_MCK_32MDIV23  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV23,     
66      NRF_I2S_MCK_32MDIV30  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV30,     
67      NRF_I2S_MCK_32MDIV31  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV31,     
68      NRF_I2S_MCK_32MDIV32  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV32,     
69      NRF_I2S_MCK_32MDIV42  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV42,     
70      NRF_I2S_MCK_32MDIV63  = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV63,     
71      NRF_I2S_MCK_32MDIV125 = I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV125     
72  } nrf_i2s_mck_t;
73  typedef enum
<span onclick='openModal()' class='match'>74  {
75      NRF_I2S_RATIO_32X  = I2S_CONFIG_RATIO_RATIO_32X,  
76      NRF_I2S_RATIO_48X  = I2S_CONFIG_RATIO_RATIO_48X,  
77      NRF_I2S_RATIO_64X  = I2S_CONFIG_RATIO_RATIO_64X,  
78      NRF_I2S_RATIO_96X  = I2S_CONFIG_RATIO_RATIO_96X,  
79      NRF_I2S_RATIO_128X = I2S_CONFIG_RATIO_RATIO_128X, 
80      NRF_I2S_RATIO_192X = I2S_CONFIG_RATIO_RATIO_192X, 
81      NRF_I2S_RATIO_256X = I2S_CONFIG_RATIO_RATIO_256X, 
82      NRF_I2S_RATIO_384X = I2S_CONFIG_RATIO_RATIO_384X, 
83      NRF_I2S_RATIO_512X = I2S_CONFIG_RATIO_RATIO_512X  
</span>84  } nrf_i2s_ratio_t;
85  typedef enum
86  {
87      NRF_I2S_SWIDTH_8BIT          = I2S_CONFIG_SWIDTH_SWIDTH_8Bit,      
88      NRF_I2S_SWIDTH_16BIT         = I2S_CONFIG_SWIDTH_SWIDTH_16Bit,     
89      NRF_I2S_SWIDTH_24BIT         = I2S_CONFIG_SWIDTH_SWIDTH_24Bit,     
90  #if defined(I2S_CONFIG_SWIDTH_SWIDTH_32Bit) || defined(__NRFX_DOXYGEN__)
91      NRF_I2S_SWIDTH_32BIT         = I2S_CONFIG_SWIDTH_SWIDTH_32Bit,     
92  #endif
93  #if defined(I2S_CONFIG_SWIDTH_SWIDTH_8BitIn16) || defined(__NRFX_DOXYGEN__)
94      NRF_I2S_SWIDTH_8BIT_IN16BIT  = I2S_CONFIG_SWIDTH_SWIDTH_8BitIn16,  
95  #endif
96  #if defined(I2S_CONFIG_SWIDTH_SWIDTH_8BitIn32) || defined(__NRFX_DOXYGEN__)
97      NRF_I2S_SWIDTH_8BIT_IN32BIT  = I2S_CONFIG_SWIDTH_SWIDTH_8BitIn32,  
98  #endif
99  #if defined(I2S_CONFIG_SWIDTH_SWIDTH_16BitIn32) || defined(__NRFX_DOXYGEN__)
100      NRF_I2S_SWIDTH_16BIT_IN32BIT = I2S_CONFIG_SWIDTH_SWIDTH_16BitIn32, 
101  #endif
102  #if defined(I2S_CONFIG_SWIDTH_SWIDTH_24BitIn32) || defined(__NRFX_DOXYGEN__)
103      NRF_I2S_SWIDTH_24BIT_IN32BIT = I2S_CONFIG_SWIDTH_SWIDTH_24BitIn32, 
104  #endif
105  } nrf_i2s_swidth_t;
106  typedef enum
107  {
108      NRF_I2S_ALIGN_LEFT  = I2S_CONFIG_ALIGN_ALIGN_Left, 
109      NRF_I2S_ALIGN_RIGHT = I2S_CONFIG_ALIGN_ALIGN_Right 
110  } nrf_i2s_align_t;
111  typedef enum
112  {
113      NRF_I2S_FORMAT_I2S     = I2S_CONFIG_FORMAT_FORMAT_I2S,    
114      NRF_I2S_FORMAT_ALIGNED = I2S_CONFIG_FORMAT_FORMAT_Aligned 
115  } nrf_i2s_format_t;
116  typedef enum
117  {
118      NRF_I2S_CHANNELS_STEREO = I2S_CONFIG_CHANNELS_CHANNELS_Stereo, 
119      NRF_I2S_CHANNELS_LEFT   = I2S_CONFIG_CHANNELS_CHANNELS_Left,   
120      NRF_I2S_CHANNELS_RIGHT  = I2S_CONFIG_CHANNELS_CHANNELS_Right   
121  } nrf_i2s_channels_t;
122  #if NRF_I2S_HAS_CLKCONFIG
123  typedef enum
124  {
125      NRF_I2S_CLKSRC_PCLK32M = I2S_CONFIG_CLKCONFIG_CLKSRC_PCLK32M, 
126      NRF_I2S_CLKSRC_ACLK    = I2S_CONFIG_CLKCONFIG_CLKSRC_ACLK     
127  } nrf_i2s_clksrc_t;
128  #endif
129  NRF_STATIC_INLINE void nrf_i2s_task_trigger(NRF_I2S_Type * p_reg,
130                                              nrf_i2s_task_t task);
131  NRF_STATIC_INLINE uint32_t nrf_i2s_task_address_get(NRF_I2S_Type const * p_reg,
132                                                      nrf_i2s_task_t       task);
133  NRF_STATIC_INLINE void nrf_i2s_event_clear(NRF_I2S_Type *  p_reg,
134                                             nrf_i2s_event_t event);
135  NRF_STATIC_INLINE bool nrf_i2s_event_check(NRF_I2S_Type const * p_reg,
136                                             nrf_i2s_event_t      event);
137  NRF_STATIC_INLINE uint32_t nrf_i2s_event_address_get(NRF_I2S_Type const * p_reg,
138                                                       nrf_i2s_event_t      event);
139  NRF_STATIC_INLINE void nrf_i2s_int_enable(NRF_I2S_Type * p_reg, uint32_t mask);
140  NRF_STATIC_INLINE void nrf_i2s_int_disable(NRF_I2S_Type * p_reg, uint32_t mask);
141  NRF_STATIC_INLINE uint32_t nrf_i2s_int_enable_check(NRF_I2S_Type const * p_reg, uint32_t mask);
142  NRF_STATIC_INLINE void nrf_i2s_enable(NRF_I2S_Type * p_reg);
143  NRF_STATIC_INLINE void nrf_i2s_disable(NRF_I2S_Type * p_reg);
144  #if defined(DPPI_PRESENT) || defined(__NRFX_DOXYGEN__)
145  NRF_STATIC_INLINE void nrf_i2s_subscribe_set(NRF_I2S_Type * p_reg,
146                                               nrf_i2s_task_t task,
147                                               uint8_t        channel);
148  NRF_STATIC_INLINE void nrf_i2s_subscribe_clear(NRF_I2S_Type * p_reg,
149                                                 nrf_i2s_task_t task);
150  NRF_STATIC_INLINE void nrf_i2s_publish_set(NRF_I2S_Type *  p_reg,
151                                             nrf_i2s_event_t event,
152                                             uint8_t         channel);
153  NRF_STATIC_INLINE void nrf_i2s_publish_clear(NRF_I2S_Type *  p_reg,
154                                               nrf_i2s_event_t event);
155  #endif 
156  NRF_STATIC_INLINE void nrf_i2s_pins_set(NRF_I2S_Type * p_reg,
157                                          uint32_t       sck_pin,
158                                          uint32_t       lrck_pin,
159                                          uint32_t       mck_pin,
160                                          uint32_t       sdout_pin,
161                                          uint32_t       sdin_pin);
162  NRF_STATIC_INLINE bool nrf_i2s_configure(NRF_I2S_Type *     p_reg,
163                                           nrf_i2s_mode_t     mode,
164                                           nrf_i2s_format_t   format,
165                                           nrf_i2s_align_t    alignment,
166                                           nrf_i2s_swidth_t   sample_width,
167                                           nrf_i2s_channels_t channels,
168                                           nrf_i2s_mck_t      mck_setup,
169                                           nrf_i2s_ratio_t    ratio);
170  NRF_STATIC_INLINE void nrf_i2s_transfer_set(NRF_I2S_Type *   p_reg,
171                                              uint16_t         size,
172                                              uint32_t *       p_rx_buffer,
173                                              uint32_t const * p_tx_buffer);
174  NRF_STATIC_INLINE void nrf_i2s_rx_buffer_set(NRF_I2S_Type * p_reg,
175                                               uint32_t *     p_buffer);
176  NRF_STATIC_INLINE uint32_t * nrf_i2s_rx_buffer_get(NRF_I2S_Type const * p_reg);
177  NRF_STATIC_INLINE void nrf_i2s_tx_buffer_set(NRF_I2S_Type *   p_reg,
178                                               uint32_t const * p_buffer);
179  NRF_STATIC_INLINE uint32_t * nrf_i2s_tx_buffer_get(NRF_I2S_Type const * p_reg);
180  #if NRF_I2S_HAS_CLKCONFIG
181  NRF_STATIC_INLINE void nrf_i2s_clk_configure(NRF_I2S_Type *   p_reg,
182                                               nrf_i2s_clksrc_t clksrc,
183                                               bool             enable_bypass);
184  #endif
185  #ifndef NRF_DECLARE_ONLY
186  NRF_STATIC_INLINE void nrf_i2s_task_trigger(NRF_I2S_Type * p_reg,
187                                              nrf_i2s_task_t task)
188  {
189      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
190  }
191  NRF_STATIC_INLINE uint32_t nrf_i2s_task_address_get(NRF_I2S_Type const * p_reg,
192                                                      nrf_i2s_task_t       task)
193  {
194      return ((uint32_t)p_reg + (uint32_t)task);
195  }
196  NRF_STATIC_INLINE void nrf_i2s_event_clear(NRF_I2S_Type *  p_reg,
197                                             nrf_i2s_event_t event)
198  {
199      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
200  #if __CORTEX_M == 0x04
201      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
202      (void)dummy;
203  #endif
204  }
205  NRF_STATIC_INLINE bool nrf_i2s_event_check(NRF_I2S_Type const * p_reg,
206                                             nrf_i2s_event_t      event)
207  {
208      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
209  }
210  NRF_STATIC_INLINE uint32_t nrf_i2s_event_address_get(NRF_I2S_Type const * p_reg,
211                                                       nrf_i2s_event_t      event)
212  {
213      return ((uint32_t)p_reg + (uint32_t)event);
214  }
215  NRF_STATIC_INLINE void nrf_i2s_int_enable(NRF_I2S_Type * p_reg, uint32_t mask)
216  {
217      p_reg->INTENSET = mask;
218  }
219  NRF_STATIC_INLINE void nrf_i2s_int_disable(NRF_I2S_Type * p_reg, uint32_t mask)
220  {
221      p_reg->INTENCLR = mask;
222  }
223  NRF_STATIC_INLINE uint32_t nrf_i2s_int_enable_check(NRF_I2S_Type const * p_reg, uint32_t mask)
224  {
225      return p_reg->INTENSET & mask;
226  }
227  NRF_STATIC_INLINE void nrf_i2s_enable(NRF_I2S_Type * p_reg)
228  {
229      p_reg->ENABLE = (I2S_ENABLE_ENABLE_Enabled << I2S_ENABLE_ENABLE_Pos);
230  }
231  NRF_STATIC_INLINE void nrf_i2s_disable(NRF_I2S_Type * p_reg)
232  {
233      p_reg->ENABLE = (I2S_ENABLE_ENABLE_Disabled << I2S_ENABLE_ENABLE_Pos);
234  }
235  #if defined(DPPI_PRESENT)
236  NRF_STATIC_INLINE void nrf_i2s_subscribe_set(NRF_I2S_Type * p_reg,
237                                               nrf_i2s_task_t task,
238                                               uint8_t        channel)
239  {
240      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
241              ((uint32_t)channel | I2S_SUBSCRIBE_START_EN_Msk);
242  }
243  NRF_STATIC_INLINE void nrf_i2s_subscribe_clear(NRF_I2S_Type * p_reg,
244                                                 nrf_i2s_task_t task)
245  {
246      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
247  }
248  NRF_STATIC_INLINE void nrf_i2s_publish_set(NRF_I2S_Type *  p_reg,
249                                             nrf_i2s_event_t event,
250                                             uint8_t         channel)
251  {
252      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
253              ((uint32_t)channel | I2S_PUBLISH_STOPPED_EN_Msk);
254  }
255  NRF_STATIC_INLINE void nrf_i2s_publish_clear(NRF_I2S_Type *  p_reg,
256                                               nrf_i2s_event_t event)
257  {
258      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
259  }
260  #endif 
261  NRF_STATIC_INLINE void nrf_i2s_pins_set(NRF_I2S_Type * p_reg,
262                                          uint32_t       sck_pin,
263                                          uint32_t       lrck_pin,
264                                          uint32_t       mck_pin,
265                                          uint32_t       sdout_pin,
266                                          uint32_t       sdin_pin)
267  {
268      p_reg->PSEL.SCK   = sck_pin;
269      p_reg->PSEL.LRCK  = lrck_pin;
270      p_reg->PSEL.MCK   = mck_pin;
271      p_reg->PSEL.SDOUT = sdout_pin;
272      p_reg->PSEL.SDIN  = sdin_pin;
273  }
274  NRF_STATIC_INLINE bool nrf_i2s_configure(NRF_I2S_Type *     p_reg,
275                                           nrf_i2s_mode_t     mode,
276                                           nrf_i2s_format_t   format,
277                                           nrf_i2s_align_t    alignment,
278                                           nrf_i2s_swidth_t   sample_width,
279                                           nrf_i2s_channels_t channels,
280                                           nrf_i2s_mck_t      mck_setup,
281                                           nrf_i2s_ratio_t    ratio)
282  {
283      if (mode == NRF_I2S_MODE_MASTER)
284      {
285          if (((sample_width == NRF_I2S_SWIDTH_16BIT) &&
286                   (ratio == NRF_I2S_RATIO_48X))
287              ||
288              ((sample_width == NRF_I2S_SWIDTH_24BIT) &&
289                  ((ratio == NRF_I2S_RATIO_32X)  ||
290                   (ratio == NRF_I2S_RATIO_64X)  ||
291                   (ratio == NRF_I2S_RATIO_128X) ||
292                   (ratio == NRF_I2S_RATIO_256X) ||
293                   (ratio == NRF_I2S_RATIO_512X))))
294          {
295              return false;
296          }
297      }
298      p_reg->CONFIG.MODE     = mode;
299      p_reg->CONFIG.FORMAT   = format;
300      p_reg->CONFIG.ALIGN    = alignment;
301      p_reg->CONFIG.SWIDTH   = sample_width;
302      p_reg->CONFIG.CHANNELS = channels;
303      p_reg->CONFIG.RATIO    = ratio;
304      if (mck_setup == NRF_I2S_MCK_DISABLED)
305      {
306          p_reg->CONFIG.MCKEN =
307              (I2S_CONFIG_MCKEN_MCKEN_Disabled << I2S_CONFIG_MCKEN_MCKEN_Pos);
308      }
309      else
310      {
311          p_reg->CONFIG.MCKFREQ = mck_setup;
312          p_reg->CONFIG.MCKEN =
313              (I2S_CONFIG_MCKEN_MCKEN_Enabled << I2S_CONFIG_MCKEN_MCKEN_Pos);
314      }
315      return true;
316  }
317  NRF_STATIC_INLINE void nrf_i2s_transfer_set(NRF_I2S_Type *   p_reg,
318                                              uint16_t         size,
319                                              uint32_t *       p_buffer_rx,
320                                              uint32_t const * p_buffer_tx)
321  {
322      p_reg->RXTXD.MAXCNT = size;
323      nrf_i2s_rx_buffer_set(p_reg, p_buffer_rx);
324      p_reg->CONFIG.RXEN = (p_buffer_rx != NULL) ? 1 : 0;
325      nrf_i2s_tx_buffer_set(p_reg, p_buffer_tx);
326      p_reg->CONFIG.TXEN = (p_buffer_tx != NULL) ? 1 : 0;
327  }
328  NRF_STATIC_INLINE void nrf_i2s_rx_buffer_set(NRF_I2S_Type * p_reg,
329                                               uint32_t * p_buffer)
330  {
331      p_reg->RXD.PTR = (uint32_t)p_buffer;
332  }
333  NRF_STATIC_INLINE uint32_t * nrf_i2s_rx_buffer_get(NRF_I2S_Type const * p_reg)
334  {
335      return (uint32_t *)(p_reg->RXD.PTR);
336  }
337  NRF_STATIC_INLINE void nrf_i2s_tx_buffer_set(NRF_I2S_Type *   p_reg,
338                                               uint32_t const * p_buffer)
339  {
340      p_reg->TXD.PTR = (uint32_t)p_buffer;
341  }
342  NRF_STATIC_INLINE uint32_t * nrf_i2s_tx_buffer_get(NRF_I2S_Type const * p_reg)
343  {
344      return (uint32_t *)(p_reg->TXD.PTR);
345  }
346  #if NRF_I2S_HAS_CLKCONFIG
347  NRF_STATIC_INLINE void nrf_i2s_clk_configure(NRF_I2S_Type *   p_reg,
348                                               nrf_i2s_clksrc_t clksrc,
349                                               bool             enable_bypass)
350  {
351      p_reg->CONFIG.CLKCONFIG = ((uint32_t) clksrc << I2S_CONFIG_CLKCONFIG_CLKSRC_Pos) |
352                                ((uint32_t) enable_bypass << I2S_CONFIG_CLKCONFIG_BYPASS_Pos);
353  }
354  #endif
355  #endif 
356  #ifdef __cplusplus
357  }
358  #endif
359  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-blake2-impl_9.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_i2s.h</div>
                <div class="column column_space"><pre><code>40  static inline void store32(void *dst, uint32_t w) {
41  #if defined(NATIVE_LITTLE_ENDIAN)
42      *(uint32_t *)dst = w;
43  #else
44      uint8_t *p = (uint8_t *)dst;
45      *p++ = (uint8_t)w;
46      w >>= 8;
47      *p++ = (uint8_t)w;
48      w >>= 8;
49      *p++ = (uint8_t)w;
</pre></code></div>
                <div class="column column_space"><pre><code>74  {
75      NRF_I2S_RATIO_32X  = I2S_CONFIG_RATIO_RATIO_32X,  
76      NRF_I2S_RATIO_48X  = I2S_CONFIG_RATIO_RATIO_48X,  
77      NRF_I2S_RATIO_64X  = I2S_CONFIG_RATIO_RATIO_64X,  
78      NRF_I2S_RATIO_96X  = I2S_CONFIG_RATIO_RATIO_96X,  
79      NRF_I2S_RATIO_128X = I2S_CONFIG_RATIO_RATIO_128X, 
80      NRF_I2S_RATIO_192X = I2S_CONFIG_RATIO_RATIO_192X, 
81      NRF_I2S_RATIO_256X = I2S_CONFIG_RATIO_RATIO_256X, 
82      NRF_I2S_RATIO_384X = I2S_CONFIG_RATIO_RATIO_384X, 
83      NRF_I2S_RATIO_512X = I2S_CONFIG_RATIO_RATIO_512X  
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    