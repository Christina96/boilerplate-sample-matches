
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-daemon.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include "ftmacros.h"
5  #include "varattrs.h"
6  #include <errno.h>		
7  #include <stdlib.h>		
8  #include <string.h>		
9  #include <limits.h>		
10  #ifdef _WIN32
11    #include <process.h>		
12  #else
13    #include <unistd.h>
14    #include <pthread.h>
15    #include <signal.h>
16    #include <sys/time.h>
17    #include <sys/types.h>	
18    #include <pwd.h>		
19  #endif
20  #ifdef HAVE_GETSPNAM
21  #include <shadow.h>		
22  #endif
23  #include <pcap.h>		
24  #include "fmtutils.h"
25  #include "sockutils.h"		
26  #include "portability.h"
27  #include "rpcap-protocol.h"
28  #include "daemon.h"
29  #include "log.h"
30  #ifdef HAVE_OPENSSL
31  #include <openssl/ssl.h>
32  #include "sslutils.h"
33  #endif
34  #define RPCAP_TIMEOUT_INIT 90
35  #define RPCAP_TIMEOUT_RUNTIME 180
36  #define RPCAP_SUSPEND_WRONGAUTH 1
37  struct daemon_slpars
38  {
39  	SOCKET sockctrl;	
40  	SSL *ssl;		
41  	int isactive;		
42  	int nullAuthAllowed;	
43  };
44  struct session {
45  	SOCKET sockctrl;
46  	SOCKET sockdata;
47  	SSL *ctrl_ssl, *data_ssl; 
48  	uint8_t protocol_version;
49  	pcap_t *fp;
50  	unsigned int TotCapt;
51  	int	have_thread;
52  #ifdef _WIN32
53  	HANDLE thread;
54  #else
55  	pthread_t thread;
56  #endif
57  };
58  static int daemon_msg_err(SOCKET sockctrl, SSL *, uint32_t plen);
59  static int daemon_msg_auth_req(struct daemon_slpars *pars, uint32_t plen);
60  static int daemon_AuthUserPwd(char *username, char *password, char *errbuf);
61  static int daemon_msg_findallif_req(uint8_t ver, struct daemon_slpars *pars,
62      uint32_t plen);
63  static int daemon_msg_open_req(uint8_t ver, struct daemon_slpars *pars,
64      uint32_t plen, char *source, size_t sourcelen);
65  static int daemon_msg_startcap_req(uint8_t ver, struct daemon_slpars *pars,
66      uint32_t plen, char *source, char *data_port, struct session **sessionp,
67      struct rpcap_sampling *samp_param, int uses_ssl);
68  static int daemon_msg_endcap_req(uint8_t ver, struct daemon_slpars *pars,
69      struct session *session);
70  static int daemon_msg_updatefilter_req(uint8_t ver, struct daemon_slpars *pars,
71      struct session *session, uint32_t plen);
72  static int daemon_unpackapplyfilter(SOCKET sockctrl, SSL *, struct session *session, uint32_t *plenp, char *errbuf);
73  static int daemon_msg_stats_req(uint8_t ver, struct daemon_slpars *pars,
74      struct session *session, uint32_t plen, struct pcap_stat *stats,
75      unsigned int svrcapt);
76  static int daemon_msg_setsampling_req(uint8_t ver, struct daemon_slpars *pars,
77      uint32_t plen, struct rpcap_sampling *samp_param);
78  static void daemon_seraddr(struct sockaddr_storage *sockaddrin, struct rpcap_sockaddr *sockaddrout);
79  #ifdef _WIN32
80  static unsigned __stdcall daemon_thrdatamain(void *ptr);
81  #else
82  static void *daemon_thrdatamain(void *ptr);
83  static void noop_handler(int sign);
84  #endif
85  static int rpcapd_recv_msg_header(SOCKET sock, SSL *, struct rpcap_header *headerp);
86  static int rpcapd_recv(SOCKET sock, SSL *, char *buffer, size_t toread, uint32_t *plen, char *errmsgbuf);
87  static int rpcapd_discard(SOCKET sock, SSL *, uint32_t len);
88  static void session_close(struct session *);
89  struct tls_record_header {
90  	uint8_t type;		
91  	uint8_t version_major;	
92  	uint8_t version_injor;	
93  	uint8_t length_hi;	
94  	uint8_t length_lo;	
95  };
96  #define TLS_RECORD_HEADER_LEN	5	
97  #define TLS_RECORD_TYPE_ALERT		21
98  #define TLS_RECORD_TYPE_HANDSHAKE	22
99  struct tls_alert {
100  	uint8_t alert_level;
101  	uint8_t alert_description;
102  };
103  #define TLS_ALERT_LEN			2
104  #define TLS_ALERT_LEVEL_FATAL		2
105  #define TLS_ALERT_HANDSHAKE_FAILURE	40
106  static int is_url(const char *source);
107  #ifndef UINT16_MAX
108  #define UINT16_MAX	65535U
109  #endif
110  #ifndef UINT32_MAX
111  #define UINT32_MAX	4294967295U
112  #endif
113  int
114  daemon_serviceloop(SOCKET sockctrl, int isactive, char *passiveClients,
115      int nullAuthAllowed, char *data_port, int uses_ssl)
116  {
117  	uint8_t first_octet;
118  	struct tls_record_header tls_header;
119  	struct tls_alert tls_alert;
120  	struct daemon_slpars pars;		
121  	char errbuf[PCAP_ERRBUF_SIZE + 1];	
122  	char errmsgbuf[PCAP_ERRBUF_SIZE + 1];	
123  	int host_port_check_status;
124  	SSL *ssl = NULL;
125  	int nrecv;
126  	struct rpcap_header header;		
127  	uint32_t plen;				
128  	int authenticated = 0;			
129  	char source[PCAP_BUF_SIZE+1];		
130  	int got_source = 0;			
131  #ifndef _WIN32
132  	struct sigaction action;
133  #endif
134  	struct session *session = NULL;		
135  	const char *msg_type_string;		
136  	int client_told_us_to_close = 0;	
137  	struct pcap_stat stats;
138  	unsigned int svrcapt;
139  	struct rpcap_sampling samp_param;	
140  	fd_set rfds;				
141  	struct timeval tv;			
142  	int retval;				
143  	*errbuf = 0;	
144  	nrecv = sock_recv(sockctrl, NULL, (char *)&first_octet, 1,
145  	    SOCK_EOF_ISNT_ERROR|SOCK_MSG_PEEK, errbuf, PCAP_ERRBUF_SIZE);
146  	if (nrecv == -1)
147  	{
148  		rpcapd_log(LOGPRIO_ERROR, "Peek from client failed: %s", errbuf);
149  		goto end;
150  	}
151  	if (nrecv == 0)
152  	{
153  		goto end;
154  	}
155  #ifdef HAVE_OPENSSL
156  	if (uses_ssl)
157  	{
158  		if (first_octet != TLS_RECORD_TYPE_HANDSHAKE)
159  		{
160  			nrecv = rpcapd_recv_msg_header(sockctrl, NULL, &header);
161  			if (nrecv == -1)
162  			{
163  				goto end;
164  			}
165  			if (nrecv == -2)
166  			{
167  				goto end;
168  			}
169  			plen = header.plen;
170  			if (rpcapd_discard(sockctrl, NULL, plen) == -1)
171  			{
172  				goto end;
173  			}
174  			if (rpcap_senderror(sockctrl, NULL, header.ver,
175  			    PCAP_ERR_TLS_REQUIRED,
176  			    "TLS is required by this server", errbuf) == -1)
177  			{
178  				rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
179  				goto end;
180  			}
181  			goto end;
182  		}
183  		ssl = ssl_promotion(1, sockctrl, errbuf, PCAP_ERRBUF_SIZE);
184  		if (! ssl)
185  		{
186  			rpcapd_log(LOGPRIO_ERROR, "TLS handshake on control connection failed: %s",
187  			    errbuf);
188  			goto end;
189  		}
190  	}
191  	else
192  #endif
193  	{
194  		if (first_octet == TLS_RECORD_TYPE_HANDSHAKE)
195  		{
196  			nrecv = sock_recv(sockctrl, ssl, (char *) &tls_header,
197  			    sizeof tls_header, SOCK_RECEIVEALL_YES|SOCK_EOF_ISNT_ERROR,
198  			    errbuf, PCAP_ERRBUF_SIZE);
199  			if (nrecv == -1)
200  			{
201  				rpcapd_log(LOGPRIO_ERROR, "Read from client failed: %s", errbuf);
202  				goto end;
203  			}
204  			if (nrecv == 0)
205  			{
206  				goto end;
207  			}
208  			plen = (tls_header.length_hi << 8U) | tls_header.length_lo;
209  			if (rpcapd_discard(sockctrl, NULL, plen) == -1)
210  			{
211  				goto end;
212  			}
213  			tls_header.type = TLS_RECORD_TYPE_ALERT;
214  			tls_header.length_hi = 0;
215  			tls_header.length_lo = TLS_ALERT_LEN;
216  			if (sock_send(sockctrl, NULL, (char *) &tls_header,
217  			    TLS_RECORD_HEADER_LEN, errbuf, PCAP_ERRBUF_SIZE) == -1)
218  			{
219  				rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
220  				goto end;
221  			}
222  			tls_alert.alert_level = TLS_ALERT_LEVEL_FATAL;
223  			tls_alert.alert_description = TLS_ALERT_HANDSHAKE_FAILURE;
224  			if (sock_send(sockctrl, NULL, (char *) &tls_alert,
225  			    TLS_ALERT_LEN, errbuf, PCAP_ERRBUF_SIZE) == -1)
226  			{
227  				rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
228  				goto end;
229  			}
230  			goto end;
231  		}
232  	}
233  	pars.sockctrl = sockctrl;
234  	pars.ssl = ssl;
235  	pars.isactive = isactive;		
236  	pars.nullAuthAllowed = nullAuthAllowed;
237  	if (pars.isactive)
238  	{
239  		free(passiveClients);
240  		passiveClients = NULL;
241  	}
242  	else
243  	{
244  		struct sockaddr_storage from;
245  		socklen_t fromlen;
246  		fromlen = sizeof(struct sockaddr_storage);
247  		if (getpeername(pars.sockctrl, (struct sockaddr *)&from,
248  		    &fromlen) == -1)
249  		{
250  			sock_geterrmsg(errmsgbuf, PCAP_ERRBUF_SIZE,
251  			    "getpeername() failed");
252  			if (rpcap_senderror(pars.sockctrl, pars.ssl, 0, PCAP_ERR_NETW, errmsgbuf, errbuf) == -1)
253  				rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
254  			goto end;
255  		}
256  		host_port_check_status = sock_check_hostlist(passiveClients, RPCAP_HOSTLIST_SEP, &from, errmsgbuf, PCAP_ERRBUF_SIZE);
257  		free(passiveClients);
258  		passiveClients = NULL;
259  		if (host_port_check_status < 0)
260  		{
261  			if (host_port_check_status == -2) {
262  				rpcapd_log(LOGPRIO_ERROR, "%s", errmsgbuf);
263  			}
264  			if (rpcap_senderror(pars.sockctrl, pars.ssl, 0, PCAP_ERR_HOSTNOAUTH, errmsgbuf, errbuf) == -1)
265  				rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
266  			goto end;
267  		}
268  	}
269  #ifndef _WIN32
270  	memset(&action, 0, sizeof (action));
271  	action.sa_handler = noop_handler;
272  	action.sa_flags = 0;
273  	sigemptyset(&action.sa_mask);
274  	sigaction(SIGUSR1, &action, NULL);
275  #endif
276  	while (!authenticated)
277  	{
278  		if (!pars.isactive)
279  		{
280  			FD_ZERO(&rfds);
281  			tv.tv_sec = RPCAP_TIMEOUT_INIT;
282  			tv.tv_usec = 0;
283  			FD_SET(pars.sockctrl, &rfds);
284  			retval = select((int)pars.sockctrl + 1, &rfds, NULL, NULL, &tv);
285  			if (retval == -1)
286  			{
287  				sock_geterrmsg(errmsgbuf, PCAP_ERRBUF_SIZE,
288  				    "select() failed");
289  				if (rpcap_senderror(pars.sockctrl, pars.ssl, 0, PCAP_ERR_NETW, errmsgbuf, errbuf) == -1)
290  					rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
291  				goto end;
292  			}
293  			if (retval == 0)
294  			{
295  				if (rpcap_senderror(pars.sockctrl, pars.ssl, 0, PCAP_ERR_INITTIMEOUT, "The RPCAP initial timeout has expired", errbuf) == -1)
296  					rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
297  				goto end;
298  			}
299  		}
300  		nrecv = rpcapd_recv_msg_header(pars.sockctrl, pars.ssl, &header);
301  		if (nrecv == -1)
302  		{
303  			goto end;
304  		}
305  		if (nrecv == -2)
306  		{
307  			goto end;
308  		}
309  		plen = header.plen;
310  		if (header.ver != 0)
311  		{
312  			if (rpcap_senderror(pars.sockctrl, pars.ssl, header.ver,
313  			    PCAP_ERR_WRONGVER,
314  			    "RPCAP version in requests in the authentication phase must be 0",
315  			    errbuf) == -1)
316  			{
317  				rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
318  				goto end;
319  			}
320  			(void)rpcapd_discard(pars.sockctrl, pars.ssl, plen);
321  			goto end;
322  		}
323  		switch (header.type)
324  		{
325  			case RPCAP_MSG_AUTH_REQ:
326  				retval = daemon_msg_auth_req(&pars, plen);
327  				if (retval == -1)
328  				{
329  					goto end;
330  				}
331  				if (retval == -2)
332  				{
333  					continue;
334  				}
335  				authenticated = 1;
336  				break;
337  			case RPCAP_MSG_CLOSE:
338  				(void)rpcapd_discard(pars.sockctrl, pars.ssl, plen);
339  				goto end;
340  			case RPCAP_MSG_ERROR:
341  				(void)daemon_msg_err(pars.sockctrl, pars.ssl, plen);
342  				goto end;
343  			case RPCAP_MSG_FINDALLIF_REQ:
344  			case RPCAP_MSG_OPEN_REQ:
345  			case RPCAP_MSG_STARTCAP_REQ:
346  			case RPCAP_MSG_UPDATEFILTER_REQ:
347  			case RPCAP_MSG_STATS_REQ:
348  			case RPCAP_MSG_ENDCAP_REQ:
349  			case RPCAP_MSG_SETSAMPLING_REQ:
350  				msg_type_string = rpcap_msg_type_string(header.type);
351  				if (msg_type_string != NULL)
352  				{
353  					snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "%s request sent before authentication was completed", msg_type_string);
354  				}
355  				else
356  				{
357  					snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "Message of type %u sent before authentication was completed", header.type);
358  				}
359  				if (rpcap_senderror(pars.sockctrl, pars.ssl,
360  				    header.ver, PCAP_ERR_WRONGMSG,
361  				    errmsgbuf, errbuf) == -1)
362  				{
363  					rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
364  					goto end;
365  				}
366  				if (rpcapd_discard(pars.sockctrl, pars.ssl, plen) == -1)
367  				{
368  					goto end;
369  				}
370  				break;
371  			case RPCAP_MSG_PACKET:
372  			case RPCAP_MSG_FINDALLIF_REPLY:
373  			case RPCAP_MSG_OPEN_REPLY:
374  			case RPCAP_MSG_STARTCAP_REPLY:
375  			case RPCAP_MSG_UPDATEFILTER_REPLY:
376  			case RPCAP_MSG_AUTH_REPLY:
377  			case RPCAP_MSG_STATS_REPLY:
378  			case RPCAP_MSG_ENDCAP_REPLY:
379  			case RPCAP_MSG_SETSAMPLING_REPLY:
380  				msg_type_string = rpcap_msg_type_string(header.type);
381  				if (msg_type_string != NULL)
382  				{
383  					snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "Server-to-client message %s received from client", msg_type_string);
384  				}
385  				else
386  				{
387  					snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "Server-to-client message of type %u received from client", header.type);
388  				}
389  				if (rpcap_senderror(pars.sockctrl, pars.ssl,
390  				    header.ver, PCAP_ERR_WRONGMSG,
391  				    errmsgbuf, errbuf) == -1)
392  				{
393  					rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
394  					goto end;
395  				}
396  				if (rpcapd_discard(pars.sockctrl, pars.ssl, plen) == -1)
397  				{
398  					goto end;
399  				}
400  				break;
401  			default:
402  				snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "Unknown message type %u", header.type);
403  				if (rpcap_senderror(pars.sockctrl, pars.ssl,
404  				    header.ver, PCAP_ERR_WRONGMSG,
405  				    errmsgbuf, errbuf) == -1)
406  				{
407  					rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
408  					goto end;
409  				}
410  				if (rpcapd_discard(pars.sockctrl, pars.ssl, plen) == -1)
411  				{
412  					goto end;
413  				}
414  				break;
415  		}
416  	}
417  	stats.ps_ifdrop = 0;
418  	stats.ps_recv = 0;
419  	stats.ps_drop = 0;
420  	svrcapt = 0;
421  	for (;;)
422  	{
423  		errbuf[0] = 0;	
424  		if ((!pars.isactive) && (session == NULL || session->sockdata == 0))
425  		{
426  			FD_ZERO(&rfds);
427  			tv.tv_sec = RPCAP_TIMEOUT_RUNTIME;
428  			tv.tv_usec = 0;
429  			FD_SET(pars.sockctrl, &rfds);
430  #ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
431  			retval = 1;
432  #else
433  			retval = select((int)pars.sockctrl + 1, &rfds, NULL, NULL, &tv);
434  #endif
435  			if (retval == -1)
436  			{
437  				sock_geterrmsg(errmsgbuf, PCAP_ERRBUF_SIZE,
438  				    "select() failed");
439  				if (rpcap_senderror(pars.sockctrl, pars.ssl,
440  				    0, PCAP_ERR_NETW,
441  				    errmsgbuf, errbuf) == -1)
442  					rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
443  				goto end;
444  			}
445  			if (retval == 0)
446  			{
447  				if (rpcap_senderror(pars.sockctrl, pars.ssl,
448  				    0, PCAP_ERR_INITTIMEOUT,
449  				    "The RPCAP initial timeout has expired",
450  				    errbuf) == -1)
451  					rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
452  				goto end;
453  			}
454  		}
455  		nrecv = rpcapd_recv_msg_header(pars.sockctrl, pars.ssl, &header);
456  		if (nrecv == -1)
457  		{
458  			goto end;
459  		}
460  		if (nrecv == -2)
461  		{
462  			goto end;
463  		}
464  		plen = header.plen;
465  		if (!RPCAP_VERSION_IS_SUPPORTED(header.ver))
466  		{
467  			if (rpcap_senderror(pars.sockctrl, pars.ssl,
468  			    header.ver, PCAP_ERR_WRONGVER,
469  			    "RPCAP version in message isn't supported by the server",
470  			    errbuf) == -1)
471  			{
472  				rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
473  				goto end;
474  			}
475  			(void)rpcapd_discard(pars.sockctrl, pars.ssl, plen);
476  			goto end;
477  		}
478  		switch (header.type)
479  		{
480  			case RPCAP_MSG_ERROR:		
481  			{
482  				(void)daemon_msg_err(pars.sockctrl, pars.ssl, plen);
483  				break;
484  			}
485  			case RPCAP_MSG_FINDALLIF_REQ:
486  			{
487  				if (daemon_msg_findallif_req(header.ver, &pars, plen) == -1)
488  				{
489  					goto end;
490  				}
491  				break;
492  			}
493  			case RPCAP_MSG_OPEN_REQ:
494  			{
495  				retval = daemon_msg_open_req(header.ver, &pars,
496  				    plen, source, sizeof(source));
497  				if (retval == -1)
498  				{
499  					goto end;
500  				}
501  				got_source = 1;
502  				break;
503  			}
504  			case RPCAP_MSG_STARTCAP_REQ:
505  			{
506  				if (!got_source)
507  				{
508  					if (rpcap_senderror(pars.sockctrl, pars.ssl,
509  					    header.ver,
510  					    PCAP_ERR_STARTCAPTURE,
511  					    "No capture device was specified",
512  					    errbuf) == -1)
513  					{
514  						rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
515  						goto end;
516  					}
517  					if (rpcapd_discard(pars.sockctrl, pars.ssl, plen) == -1)
518  					{
519  						goto end;
520  					}
521  					break;
522  				}
523  				if (daemon_msg_startcap_req(header.ver, &pars,
524  				    plen, source, data_port, &session,
525  				    &samp_param, uses_ssl) == -1)
526  				{
527  					goto end;
528  				}
529  				break;
530  			}
531  			case RPCAP_MSG_UPDATEFILTER_REQ:
532  			{
533  				if (session)
534  				{
535  					if (daemon_msg_updatefilter_req(header.ver,
536  					    &pars, session, plen) == -1)
537  					{
538  						goto end;
539  					}
540  				}
541  				else
542  				{
543  					if (rpcap_senderror(pars.sockctrl, pars.ssl,
544  					    header.ver,
545  					    PCAP_ERR_UPDATEFILTER,
546  					    "Device not opened. Cannot update filter",
547  					    errbuf) == -1)
548  					{
549  						rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
550  						goto end;
551  					}
552  				}
553  				break;
554  			}
555  			case RPCAP_MSG_CLOSE:		
556  			{
557  				client_told_us_to_close = 1;
558  				rpcapd_log(LOGPRIO_DEBUG, "The other end system asked to close the connection.");
559  				goto end;
560  			}
561  			case RPCAP_MSG_STATS_REQ:
562  			{
563  				if (daemon_msg_stats_req(header.ver, &pars,
564  				    session, plen, &stats, svrcapt) == -1)
565  				{
566  					goto end;
567  				}
568  				break;
569  			}
570  			case RPCAP_MSG_ENDCAP_REQ:		
571  			{
572  				if (session)
573  				{
574  					if (pcap_stats(session->fp, &stats))
575  					{
576  						svrcapt = session->TotCapt;
577  					}
578  					else
579  					{
580  						stats.ps_ifdrop = 0;
581  						stats.ps_recv = 0;
582  						stats.ps_drop = 0;
583  						svrcapt = 0;
584  					}
585  					if (daemon_msg_endcap_req(header.ver,
586  					    &pars, session) == -1)
587  					{
588  						free(session);
589  						session = NULL;
590  						goto end;
591  					}
592  					free(session);
593  					session = NULL;
594  				}
595  				else
596  				{
597  					rpcap_senderror(pars.sockctrl, pars.ssl,
598  					    header.ver,
599  					    PCAP_ERR_ENDCAPTURE,
600  					    "Device not opened. Cannot close the capture",
601  					    errbuf);
602  				}
603  				break;
604  			}
605  			case RPCAP_MSG_SETSAMPLING_REQ:
606  			{
607  				if (daemon_msg_setsampling_req(header.ver,
608  				    &pars, plen, &samp_param) == -1)
609  				{
610  					goto end;
611  				}
612  				break;
613  			}
614  			case RPCAP_MSG_AUTH_REQ:
615  			{
616  				rpcapd_log(LOGPRIO_INFO, "The client sent an RPCAP_MSG_AUTH_REQ message after authentication was completed");
617  				if (rpcap_senderror(pars.sockctrl, pars.ssl,
618  				    header.ver,
619  				    PCAP_ERR_WRONGMSG,
620  				    "RPCAP_MSG_AUTH_REQ request sent after authentication was completed",
621  				    errbuf) == -1)
622  				{
623  					rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
624  					goto end;
625  				}
626  				if (rpcapd_discard(pars.sockctrl, pars.ssl, plen) == -1)
627  				{
628  					goto end;
629  				}
630  				goto end;
631  			case RPCAP_MSG_PACKET:
632  			case RPCAP_MSG_FINDALLIF_REPLY:
633  			case RPCAP_MSG_OPEN_REPLY:
634  			case RPCAP_MSG_STARTCAP_REPLY:
635  			case RPCAP_MSG_UPDATEFILTER_REPLY:
636  			case RPCAP_MSG_AUTH_REPLY:
637  			case RPCAP_MSG_STATS_REPLY:
638  			case RPCAP_MSG_ENDCAP_REPLY:
639  			case RPCAP_MSG_SETSAMPLING_REPLY:
640  				msg_type_string = rpcap_msg_type_string(header.type);
641  				if (msg_type_string != NULL)
642  				{
643  					rpcapd_log(LOGPRIO_INFO, "The client sent a %s server-to-client message", msg_type_string);
644  					snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "Server-to-client message %s received from client", msg_type_string);
645  				}
646  				else
647  				{
648  					rpcapd_log(LOGPRIO_INFO, "The client sent a server-to-client message of type %u", header.type);
649  					snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "Server-to-client message of type %u received from client", header.type);
650  				}
651  				if (rpcap_senderror(pars.sockctrl, pars.ssl,
652  				    header.ver, PCAP_ERR_WRONGMSG,
653  				    errmsgbuf, errbuf) == -1)
654  				{
655  					rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
656  					goto end;
657  				}
658  				if (rpcapd_discard(pars.sockctrl, pars.ssl, plen) == -1)
659  				{
660  					goto end;
661  				}
662  				goto end;
663  			default:
664  				rpcapd_log(LOGPRIO_INFO, "The client sent a message of type %u", header.type);
665  				snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "Unknown message type %u", header.type);
666  				if (rpcap_senderror(pars.sockctrl, pars.ssl,
667  				    header.ver, PCAP_ERR_WRONGMSG,
668  				    errbuf, errmsgbuf) == -1)
669  				{
670  					rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
671  					goto end;
672  				}
673  				if (rpcapd_discard(pars.sockctrl, pars.ssl, plen) == -1)
674  				{
675  					goto end;
676  				}
677  				goto end;
678  			}
679  		}
680  	}
681  end:
682  	if (session)
683  	{
684  		session_close(session);
685  		free(session);
686  		session = NULL;
687  	}
688  	if (passiveClients) {
689  		free(passiveClients);
690  	}
691  #ifdef HAVE_OPENSSL
692  	if (ssl)
693  	{
694  		ssl_finish(ssl);
695  	}
696  #endif
697  	sock_close(sockctrl, NULL, 0);
698  	rpcapd_log(LOGPRIO_DEBUG, "I'm exiting from the child loop");
699  	return client_told_us_to_close;
700  }
701  static int
702  daemon_msg_err(SOCKET sockctrl, SSL *ssl, uint32_t plen)
703  {
704  	char errbuf[PCAP_ERRBUF_SIZE];
705  	char remote_errbuf[PCAP_ERRBUF_SIZE];
706  	if (plen >= PCAP_ERRBUF_SIZE)
707  	{
708  		if (sock_recv(sockctrl, ssl, remote_errbuf, PCAP_ERRBUF_SIZE - 1,
709  		    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf,
710  		    PCAP_ERRBUF_SIZE) == -1)
711  		{
712  			rpcapd_log(LOGPRIO_ERROR, "Read from client failed: %s", errbuf);
713  			return -1;
714  		}
715  		if (rpcapd_discard(sockctrl, ssl, plen - (PCAP_ERRBUF_SIZE - 1)) == -1)
716  		{
717  			return -1;
718  		}
719  		remote_errbuf[PCAP_ERRBUF_SIZE - 1] = '\0';
720  	}
721  	else if (plen == 0)
722  	{
723  		remote_errbuf[0] = '\0';
724  	}
725  	else
726  	{
727  		if (sock_recv(sockctrl, ssl, remote_errbuf, plen,
728  		    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf,
729  		    PCAP_ERRBUF_SIZE) == -1)
730  		{
731  			rpcapd_log(LOGPRIO_ERROR, "Read from client failed: %s", errbuf);
732  			return -1;
733  		}
734  		remote_errbuf[plen] = '\0';
735  	}
736  	rpcapd_log(LOGPRIO_ERROR, "Error from client: %s", remote_errbuf);
737  	return 0;
738  }
739  static int
740  daemon_msg_auth_req(struct daemon_slpars *pars, uint32_t plen)
741  {
742  	char errbuf[PCAP_ERRBUF_SIZE];		
743  	char errmsgbuf[PCAP_ERRBUF_SIZE];	
744  	int status;
745  	struct rpcap_auth auth;			
746  	char sendbuf[RPCAP_NETBUF_SIZE];	
747  	int sendbufidx = 0;			
748  	struct rpcap_authreply *authreply;	
749  	status = rpcapd_recv(pars->sockctrl, pars->ssl, (char *) &auth, sizeof(struct rpcap_auth), &plen, errmsgbuf);
750  	if (status == -1)
751  	{
752  		return -1;
753  	}
754  	if (status == -2)
755  	{
756  		goto error;
757  	}
758  	switch (ntohs(auth.type))
759  	{
760  		case RPCAP_RMTAUTH_NULL:
761  		{
762  			if (!pars->nullAuthAllowed)
763  			{
764  				snprintf(errmsgbuf, PCAP_ERRBUF_SIZE,
765  				    "Authentication failed; NULL authentication not permitted.");
766  				if (rpcap_senderror(pars->sockctrl, pars->ssl,
767  				    0, PCAP_ERR_AUTH_FAILED, errmsgbuf, errbuf) == -1)
768  				{
769  					rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
770  					return -1;
771  				}
772  				goto error_noreply;
773  			}
774  			break;
775  		}
776  		case RPCAP_RMTAUTH_PWD:
777  		{
778  			char *username, *passwd;
779  			uint32_t usernamelen, passwdlen;
780  			usernamelen = ntohs(auth.slen1);
781  			username = (char *) malloc (usernamelen + 1);
782  			if (username == NULL)
783  			{
784  				pcap_fmt_errmsg_for_errno(errmsgbuf,
785  				    PCAP_ERRBUF_SIZE, errno, "malloc() failed");
786  				goto error;
787  			}
788  			status = rpcapd_recv(pars->sockctrl, pars->ssl, username, usernamelen, &plen, errmsgbuf);
789  			if (status == -1)
790  			{
791  				free(username);
792  				return -1;
793  			}
794  			if (status == -2)
795  			{
796  				free(username);
797  				goto error;
798  			}
799  			username[usernamelen] = '\0';
800  			passwdlen = ntohs(auth.slen2);
801  			passwd = (char *) malloc (passwdlen + 1);
802  			if (passwd == NULL)
803  			{
804  				pcap_fmt_errmsg_for_errno(errmsgbuf,
805  				    PCAP_ERRBUF_SIZE, errno, "malloc() failed");
806  				free(username);
807  				goto error;
808  			}
809  			status = rpcapd_recv(pars->sockctrl, pars->ssl, passwd, passwdlen, &plen, errmsgbuf);
810  			if (status == -1)
811  			{
812  				free(username);
813  				free(passwd);
814  				return -1;
815  			}
816  			if (status == -2)
817  			{
818  				free(username);
819  				free(passwd);
820  				goto error;
821  			}
822  			passwd[passwdlen] = '\0';
823  			if (daemon_AuthUserPwd(username, passwd, errmsgbuf))
824  			{
825  				free(username);
826  				free(passwd);
827  				if (rpcap_senderror(pars->sockctrl, pars->ssl,
828  				    0, PCAP_ERR_AUTH_FAILED, errmsgbuf, errbuf) == -1)
829  				{
830  					rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
831  					return -1;
832  				}
833  				sleep_secs(RPCAP_SUSPEND_WRONGAUTH);
834  				goto error_noreply;
835  			}
836  			free(username);
837  			free(passwd);
838  			break;
839  			}
840  		default:
841  			snprintf(errmsgbuf, PCAP_ERRBUF_SIZE,
842  			    "Authentication type not recognized.");
843  			if (rpcap_senderror(pars->sockctrl, pars->ssl,
844  			    0, PCAP_ERR_AUTH_TYPE_NOTSUP, errmsgbuf, errbuf) == -1)
845  			{
846  				rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
847  				return -1;
848  			}
849  			goto error_noreply;
850  	}
851  	if (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,
852  	    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
853  		goto error;
854  	rpcap_createhdr((struct rpcap_header *) sendbuf, 0,
855  	    RPCAP_MSG_AUTH_REPLY, 0, sizeof(struct rpcap_authreply));
856  	authreply = (struct rpcap_authreply *) &sendbuf[sendbufidx];
857  	if (sock_bufferize(NULL, sizeof(struct rpcap_authreply), NULL, &sendbufidx,
858  	    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
859  		goto error;
860  	memset(authreply, 0, sizeof(struct rpcap_authreply));
861  	authreply->minvers = RPCAP_MIN_VERSION;
862  	authreply->maxvers = RPCAP_MAX_VERSION;
863  	authreply->byte_order_magic = RPCAP_BYTE_ORDER_MAGIC;
864  	if (sock_send(pars->sockctrl, pars->ssl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)
865  	{
866  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
867  		return -1;
868  	}
869  	if (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)
870  	{
871  		return -1;
872  	}
873  	return 0;
874  error:
875  	if (rpcap_senderror(pars->sockctrl, pars->ssl, 0, PCAP_ERR_AUTH,
876  	    errmsgbuf, errbuf) == -1)
877  	{
878  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
879  		return -1;
880  	}
881  error_noreply:
882  	if (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)
883  	{
884  		return -1;
885  	}
886  	return -2;
887  }
888  static int
889  daemon_AuthUserPwd(char *username, char *password, char *errbuf)
890  {
891  #ifdef _WIN32
892  	DWORD error;
893  	HANDLE Token;
894  	char errmsgbuf[PCAP_ERRBUF_SIZE];	
895  	if (LogonUser(username, ".", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)
896  	{
897  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "Authentication failed");
898  		error = GetLastError();
899  		if (error != ERROR_LOGON_FAILURE)
900  		{
901  			pcap_fmt_errmsg_for_win32_err(errmsgbuf,
902  			    PCAP_ERRBUF_SIZE, error, "LogonUser() failed");
903  			rpcapd_log(LOGPRIO_ERROR, "%s", errmsgbuf);
904  		}
905  		return -1;
906  	}
907  	if (ImpersonateLoggedOnUser(Token) == 0)
908  	{
909  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "Authentication failed");
910  		pcap_fmt_errmsg_for_win32_err(errmsgbuf, PCAP_ERRBUF_SIZE,
911  		    GetLastError(), "ImpersonateLoggedOnUser() failed");
912  		rpcapd_log(LOGPRIO_ERROR, "%s", errmsgbuf);
913  		CloseHandle(Token);
914  		return -1;
915  	}
916  	CloseHandle(Token);
917  	return 0;
918  #else
919  	int error;
920  	struct passwd *user;
921  	char *user_password;
922  #ifdef HAVE_GETSPNAM
923  	struct spwd *usersp;
924  #endif
925  	char *crypt_password;
926  	if ((user = getpwnam(username)) == NULL)
927  	{
928  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "Authentication failed");
929  		return -1;
930  	}
931  #ifdef HAVE_GETSPNAM
932  	if ((usersp = getspnam(username)) == NULL)
933  	{
934  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "Authentication failed");
935  		return -1;
936  	}
937  	user_password = usersp->sp_pwdp;
938  #else
939  	user_password = user->pw_passwd;
940  #endif
941  	errno = 0;
942  	crypt_password = crypt(password, user_password);
943  	if (crypt_password == NULL)
944  	{
945  		error = errno;
946  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "Authentication failed");
947  		if (error == 0)
948  		{
949  			rpcapd_log(LOGPRIO_ERROR, "crypt() failed");
950  		}
951  		else
952  		{
953  			rpcapd_log(LOGPRIO_ERROR, "crypt() failed: %s",
954  			    strerror(error));
955  		}
956  		return -1;
957  	}
958  	if (strcmp(user_password, crypt_password) != 0)
959  	{
960  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "Authentication failed");
961  		return -1;
962  	}
963  	if (setuid(user->pw_uid))
964  	{
965  		error = errno;
966  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
967  		    error, "setuid");
968  		rpcapd_log(LOGPRIO_ERROR, "setuid() failed: %s",
969  		    strerror(error));
970  		return -1;
971  	}
972  	return 0;
973  #endif
974  }
975  #define CHECK_AND_INCREASE_REPLY_LEN(itemlen) \
976  	if (replylen > UINT32_MAX - (itemlen)) { \
977  		pcap_strlcpy(errmsgbuf, "Reply length doesn't fit in 32 bits", \
978  		    sizeof (errmsgbuf)); \
979  		goto error; \
980  	} \
981  	replylen += (uint32_t)(itemlen)
982  static int
983  daemon_msg_findallif_req(uint8_t ver, struct daemon_slpars *pars, uint32_t plen)
984  {
985  	char errbuf[PCAP_ERRBUF_SIZE];		
986  	char errmsgbuf[PCAP_ERRBUF_SIZE];	
987  	char sendbuf[RPCAP_NETBUF_SIZE];	
988  	int sendbufidx = 0;			
989  	pcap_if_t *alldevs = NULL;		
990  	pcap_if_t *d;				
991  	struct pcap_addr *address;		
992  	uint32_t replylen;			
993  	uint16_t nif = 0;			
994  	if (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)
995  	{
996  		return -1;
997  	}
998  	if (pcap_findalldevs(&alldevs, errmsgbuf) == -1)
999  		goto error;
1000  	if (alldevs == NULL)
1001  	{
1002  		if (rpcap_senderror(pars->sockctrl, pars->ssl, ver,
1003  			PCAP_ERR_NOREMOTEIF,
1004  			"No interfaces found! Make sure libpcap/WinPcap is properly installed"
1005  			" and you have the right to access to the remote device.",
1006  			errbuf) == -1)
1007  		{
1008  			rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
1009  			return -1;
1010  		}
1011  		return 0;
1012  	}
1013  	replylen = 0;
1014  	for (d = alldevs; d != NULL; d = d->next)
1015  	{
1016  		nif++;
1017  		if (d->description) {
1018  			size_t stringlen = strlen(d->description);
1019  			if (stringlen > UINT16_MAX) {
1020  				pcap_strlcpy(errmsgbuf,
<span onclick='openModal()' class='match'>1021  				    "Description length doesn't fit in 16 bits",
1022  				    sizeof (errmsgbuf));
1023  				goto error;
1024  			}
1025  			CHECK_AND_INCREASE_REPLY_LEN(stringlen);
1026  		}
1027  		if (d->name) {
</span>1028  			size_t stringlen = strlen(d->name);
1029  			if (stringlen > UINT16_MAX) {
1030  				pcap_strlcpy(errmsgbuf,
1031  				    "Name length doesn't fit in 16 bits",
1032  				    sizeof (errmsgbuf));
1033  				goto error;
1034  			}
1035  			CHECK_AND_INCREASE_REPLY_LEN(stringlen);
1036  		}
1037  		CHECK_AND_INCREASE_REPLY_LEN(sizeof(struct rpcap_findalldevs_if));
1038  		uint16_t naddrs = 0;
1039  		for (address = d->addresses; address != NULL; address = address->next)
1040  		{
1041  			switch (address->addr->sa_family)
1042  			{
1043  			case AF_INET:
1044  #ifdef AF_INET6
1045  			case AF_INET6:
1046  #endif
1047  				CHECK_AND_INCREASE_REPLY_LEN(sizeof(struct rpcap_sockaddr) * 4);
1048  				if (naddrs == UINT16_MAX) {
1049  					pcap_strlcpy(errmsgbuf,
1050  					    "Number of interfaces doesn't fit in 16 bits",
1051  					    sizeof (errmsgbuf));
1052  					goto error;
1053  				}
1054  				naddrs++;
1055  				break;
1056  			default:
1057  				break;
1058  			}
1059  		}
1060  	}
1061  	if (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,
1062  	    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf,
1063  	    PCAP_ERRBUF_SIZE) == -1)
1064  		goto error;
1065  	rpcap_createhdr((struct rpcap_header *) sendbuf, ver,
1066  	    RPCAP_MSG_FINDALLIF_REPLY, nif, replylen);
1067  	for (d = alldevs; d != NULL; d = d->next)
1068  	{
1069  		uint16_t lname, ldescr;
1070  		struct rpcap_findalldevs_if findalldevs_if;
1071  		if (d->description)
1072  			ldescr = (uint16_t) strlen(d->description);
1073  		else
1074  			ldescr = 0;
1075  		if (d->name)
1076  			lname = (uint16_t) strlen(d->name);
1077  		else
1078  			lname = 0;
1079  		findalldevs_if.desclen = htons(ldescr);
1080  		findalldevs_if.namelen = htons(lname);
1081  		findalldevs_if.flags = htonl(d->flags);
1082  		uint16_t naddrs = 0;
1083  		for (address = d->addresses; address != NULL; address = address->next)
1084  		{
1085  			switch (address->addr->sa_family)
1086  			{
1087  			case AF_INET:
1088  #ifdef AF_INET6
1089  			case AF_INET6:
1090  #endif
1091  				naddrs++;
1092  				break;
1093  			default:
1094  				break;
1095  			}
1096  		}
1097  		findalldevs_if.naddr = htons(naddrs);
1098  		findalldevs_if.dummy = 0;
1099  		if (sock_bufferize(&findalldevs_if, sizeof(struct rpcap_findalldevs_if), sendbuf,
1100  		    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errmsgbuf,
1101  		    PCAP_ERRBUF_SIZE) == -1)
1102  			goto error;
1103  		if (sock_bufferize(d->name, lname, sendbuf, &sendbufidx,
1104  		    RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errmsgbuf,
1105  		    PCAP_ERRBUF_SIZE) == -1)
1106  			goto error;
1107  		if (sock_bufferize(d->description, ldescr, sendbuf, &sendbufidx,
1108  		    RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errmsgbuf,
1109  		    PCAP_ERRBUF_SIZE) == -1)
1110  			goto error;
1111  		for (address = d->addresses; address != NULL; address = address->next)
1112  		{
1113  			struct rpcap_sockaddr *sockaddr;
1114  			switch (address->addr->sa_family)
1115  			{
1116  			case AF_INET:
1117  #ifdef AF_INET6
1118  			case AF_INET6:
1119  #endif
1120  				sockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];
1121  				if (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,
1122  				    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1123  					goto error;
1124  				daemon_seraddr((struct sockaddr_storage *) address->addr, sockaddr);
1125  				sockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];
1126  				if (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,
1127  				    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1128  					goto error;
1129  				daemon_seraddr((struct sockaddr_storage *) address->netmask, sockaddr);
1130  				sockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];
1131  				if (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,
1132  				    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1133  					goto error;
1134  				daemon_seraddr((struct sockaddr_storage *) address->broadaddr, sockaddr);
1135  				sockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];
1136  				if (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,
1137  				    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1138  					goto error;
1139  				daemon_seraddr((struct sockaddr_storage *) address->dstaddr, sockaddr);
1140  				break;
1141  			default:
1142  				break;
1143  			}
1144  		}
1145  	}
1146  	pcap_freealldevs(alldevs);
1147  	if (sock_send(pars->sockctrl, pars->ssl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)
1148  	{
1149  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
1150  		return -1;
1151  	}
1152  	return 0;
1153  error:
1154  	if (alldevs)
1155  		pcap_freealldevs(alldevs);
1156  	if (rpcap_senderror(pars->sockctrl, pars->ssl, ver,
1157  	    PCAP_ERR_FINDALLIF, errmsgbuf, errbuf) == -1)
1158  	{
1159  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
1160  		return -1;
1161  	}
1162  	return 0;
1163  }
1164  static int
1165  daemon_msg_open_req(uint8_t ver, struct daemon_slpars *pars, uint32_t plen,
1166      char *source, size_t sourcelen)
1167  {
1168  	char errbuf[PCAP_ERRBUF_SIZE];		
1169  	char errmsgbuf[PCAP_ERRBUF_SIZE];	
1170  	pcap_t *fp;				
1171  	int nread;
1172  	char sendbuf[RPCAP_NETBUF_SIZE];	
1173  	int sendbufidx = 0;			
1174  	struct rpcap_openreply *openreply;	
1175  	if (plen > sourcelen - 1)
1176  	{
1177  		snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "Source string too long");
1178  		goto error;
1179  	}
1180  	nread = sock_recv(pars->sockctrl, pars->ssl, source, plen,
1181  	    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);
1182  	if (nread == -1)
1183  	{
1184  		rpcapd_log(LOGPRIO_ERROR, "Read from client failed: %s", errbuf);
1185  		return -1;
1186  	}
1187  	source[nread] = '\0';
1188  	plen -= nread;
1189  	if (is_url(source))
1190  	{
1191  		snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "Source string refers to a remote device");
1192  		goto error;
1193  	}
1194  	if ((fp = pcap_open_live(source,
1195  			1500 &bsol;* fake snaplen */,
1196  			0 &bsol;* no promisc */,
1197  			1000 &bsol;* fake timeout */,
1198  			errmsgbuf)) == NULL)
1199  		goto error;
1200  	if (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,
1201  	    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1202  		goto error;
1203  	rpcap_createhdr((struct rpcap_header *) sendbuf, ver,
1204  	    RPCAP_MSG_OPEN_REPLY, 0, sizeof(struct rpcap_openreply));
1205  	openreply = (struct rpcap_openreply *) &sendbuf[sendbufidx];
1206  	if (sock_bufferize(NULL, sizeof(struct rpcap_openreply), NULL, &sendbufidx,
1207  	    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1208  		goto error;
1209  	memset(openreply, 0, sizeof(struct rpcap_openreply));
1210  	openreply->linktype = htonl(pcap_datalink(fp));
1211  	openreply->tzoff = 0;
1212  	pcap_close(fp);
1213  	if (sock_send(pars->sockctrl, pars->ssl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)
1214  	{
1215  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
1216  		return -1;
1217  	}
1218  	return 0;
1219  error:
1220  	if (rpcap_senderror(pars->sockctrl, pars->ssl, ver, PCAP_ERR_OPEN,
1221  	    errmsgbuf, errbuf) == -1)
1222  	{
1223  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
1224  		return -1;
1225  	}
1226  	if (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)
1227  	{
1228  		return -1;
1229  	}
1230  	return 0;
1231  }
1232  static int
1233  daemon_msg_startcap_req(uint8_t ver, struct daemon_slpars *pars, uint32_t plen,
1234      char *source, char *data_port, struct session **sessionp,
1235      struct rpcap_sampling *samp_param _U_, int uses_ssl)
1236  {
1237  	char errbuf[PCAP_ERRBUF_SIZE];		
1238  	char errmsgbuf[PCAP_ERRBUF_SIZE];	
1239  	char portdata[PCAP_BUF_SIZE];		
1240  	char peerhost[PCAP_BUF_SIZE];		
1241  	struct session *session = NULL;		
1242  	int status;
1243  	char sendbuf[RPCAP_NETBUF_SIZE];	
1244  	int sendbufidx = 0;			
1245  	struct addrinfo hints;			
1246  	struct addrinfo *addrinfo;		
1247  	struct sockaddr_storage saddr;		
1248  	socklen_t saddrlen;			
1249  	int ret;				
1250  	struct rpcap_startcapreq startcapreq;		
1251  	struct rpcap_startcapreply *startcapreply;	
1252  	int serveropen_dp;							
1253  	addrinfo = NULL;
1254  	status = rpcapd_recv(pars->sockctrl, pars->ssl, (char *) &startcapreq,
1255  	    sizeof(struct rpcap_startcapreq), &plen, errmsgbuf);
1256  	if (status == -1)
1257  	{
1258  		goto fatal_error;
1259  	}
1260  	if (status == -2)
1261  	{
1262  		goto error;
1263  	}
1264  	startcapreq.flags = ntohs(startcapreq.flags);
1265  	if (uses_ssl && (startcapreq.flags & RPCAP_STARTCAPREQ_FLAG_DGRAM))
1266  	{
1267  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
1268  		    "SSL not supported with UDP forward of remote packets");
1269  		goto error;
1270  	}
1271  	session = malloc(sizeof(struct session));
1272  	if (session == NULL)
1273  	{
1274  		snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "Can't allocate session structure");
1275  		goto error;
1276  	}
1277  	session->sockdata = INVALID_SOCKET;
1278  	session->ctrl_ssl = session->data_ssl = NULL;
1279  	session->have_thread = 0;
1280  #ifdef _WIN32
1281  	session->thread = INVALID_HANDLE_VALUE;
1282  #else
1283  	memset(&session->thread, 0, sizeof(session->thread));
1284  #endif
1285  	if ((session->fp = pcap_open_live(source,
1286  			ntohl(startcapreq.snaplen),
1287  			(startcapreq.flags & RPCAP_STARTCAPREQ_FLAG_PROMISC) ? 1 : 0 &bsol;* local device, other flags not needed */,
1288  			ntohl(startcapreq.read_timeout),
1289  			errmsgbuf)) == NULL)
1290  		goto error;
1291  #if 0
1292  	fp->rmt_samp.method = samp_param->method;
1293  	fp->rmt_samp.value = samp_param->value;
1294  #endif
1295  	serveropen_dp = (startcapreq.flags & RPCAP_STARTCAPREQ_FLAG_SERVEROPEN) || (startcapreq.flags & RPCAP_STARTCAPREQ_FLAG_DGRAM) || pars->isactive;
1296  	saddrlen = sizeof(struct sockaddr_storage);
1297  	if (getpeername(pars->sockctrl, (struct sockaddr *) &saddr, &saddrlen) == -1)
1298  	{
1299  		sock_geterrmsg(errmsgbuf, PCAP_ERRBUF_SIZE,
1300  		    "getpeername() failed");
1301  		goto error;
1302  	}
1303  	memset(&hints, 0, sizeof(struct addrinfo));
1304  	hints.ai_socktype = (startcapreq.flags & RPCAP_STARTCAPREQ_FLAG_DGRAM) ? SOCK_DGRAM : SOCK_STREAM;
1305  	hints.ai_family = saddr.ss_family;
1306  	if (serveropen_dp)		
1307  	{
1308  		snprintf(portdata, sizeof portdata, "%d", ntohs(startcapreq.portdata));
1309  		if (getnameinfo((struct sockaddr *) &saddr, saddrlen, peerhost,
1310  				sizeof(peerhost), NULL, 0, NI_NUMERICHOST))
1311  		{
1312  			sock_geterrmsg(errmsgbuf, PCAP_ERRBUF_SIZE,
1313  			    "getnameinfo() failed");
1314  			goto error;
1315  		}
1316  		if (sock_initaddress(peerhost, portdata, &hints, &addrinfo, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1317  			goto error;
1318  		if ((session->sockdata = sock_open(peerhost, addrinfo, SOCKOPEN_CLIENT, 0, errmsgbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)
1319  			goto error;
1320  	}
1321  	else		
1322  	{
1323  		hints.ai_flags = AI_PASSIVE;
1324  		if (data_port[0] != '\0')
1325  		{
1326  			if (sock_initaddress(NULL, data_port, &hints, &addrinfo, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1327  				goto error;
1328  		}
1329  		else
1330  		{
1331  			if (sock_initaddress(NULL, NULL, &hints, &addrinfo, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1332  				goto error;
1333  		}
1334  		if ((session->sockdata = sock_open(NULL, addrinfo, SOCKOPEN_SERVER, 1 &bsol;* max 1 connection in queue */, errmsgbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)
1335  			goto error;
1336  		saddrlen = sizeof(struct sockaddr_storage);
1337  		if (getsockname(session->sockdata, (struct sockaddr *) &saddr, &saddrlen) == -1)
1338  		{
1339  			sock_geterrmsg(errmsgbuf, PCAP_ERRBUF_SIZE,
1340  			    "getsockname() failed");
1341  			goto error;
1342  		}
1343  		if (getnameinfo((struct sockaddr *) &saddr, saddrlen, NULL,
1344  				0, portdata, sizeof(portdata), NI_NUMERICSERV))
1345  		{
1346  			sock_geterrmsg(errmsgbuf, PCAP_ERRBUF_SIZE,
1347  			    "getnameinfo() failed");
1348  			goto error;
1349  		}
1350  	}
1351  	freeaddrinfo(addrinfo);
1352  	addrinfo = NULL;
1353  	session->sockctrl = pars->sockctrl;
1354  	session->ctrl_ssl = pars->ssl;
1355  	session->protocol_version = ver;
1356  	ret = daemon_unpackapplyfilter(pars->sockctrl, pars->ssl, session, &plen, errmsgbuf);
1357  	if (ret == -1)
1358  	{
1359  		goto fatal_error;
1360  	}
1361  	if (ret == -2)
1362  	{
1363  		goto error;
1364  	}
1365  	if (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,
1366  	    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1367  		goto error;
1368  	rpcap_createhdr((struct rpcap_header *) sendbuf, ver,
1369  	    RPCAP_MSG_STARTCAP_REPLY, 0, sizeof(struct rpcap_startcapreply));
1370  	startcapreply = (struct rpcap_startcapreply *) &sendbuf[sendbufidx];
1371  	if (sock_bufferize(NULL, sizeof(struct rpcap_startcapreply), NULL,
1372  	    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1373  		goto error;
1374  	memset(startcapreply, 0, sizeof(struct rpcap_startcapreply));
1375  	startcapreply->bufsize = htonl(pcap_bufsize(session->fp));
1376  	if (!serveropen_dp)
1377  	{
1378  		unsigned short port = (unsigned short)strtoul(portdata,NULL,10);
1379  		startcapreply->portdata = htons(port);
1380  	}
1381  	if (sock_send(pars->sockctrl, pars->ssl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)
1382  	{
1383  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
1384  		goto fatal_error;
1385  	}
1386  	if (!serveropen_dp)
1387  	{
1388  		SOCKET socktemp;	
1389  		saddrlen = sizeof(struct sockaddr_storage);
1390  		socktemp = accept(session->sockdata, (struct sockaddr *) &saddr, &saddrlen);
1391  		if (socktemp == INVALID_SOCKET)
1392  		{
1393  			sock_geterrmsg(errbuf, PCAP_ERRBUF_SIZE,
1394  			   "accept() failed");
1395  			rpcapd_log(LOGPRIO_ERROR, "Accept of data connection failed: %s",
1396  			    errbuf);
1397  			goto error;
1398  		}
1399  		sock_close(session->sockdata, NULL, 0);
1400  		session->sockdata = socktemp;
1401  	}
1402  	SSL *ssl = NULL;
1403  	if (uses_ssl)
1404  	{
1405  #ifdef HAVE_OPENSSL
1406  		ssl = ssl_promotion(1, session->sockdata, errbuf, PCAP_ERRBUF_SIZE);
1407  		if (! ssl)
1408  		{
1409  			rpcapd_log(LOGPRIO_ERROR, "TLS handshake failed: %s", errbuf);
1410  			goto error;
1411  		}
1412  #endif
1413  	}
1414  	session->data_ssl = ssl;
1415  #ifdef _WIN32
1416  	session->thread = (HANDLE)_beginthreadex(NULL, 0, daemon_thrdatamain,
1417  	    (void *) session, 0, NULL);
1418  	if (session->thread == 0)
1419  	{
1420  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "Error creating the data thread");
1421  		goto error;
1422  	}
1423  #else
1424  	ret = pthread_create(&session->thread, NULL, daemon_thrdatamain,
1425  	    (void *) session);
1426  	if (ret != 0)
1427  	{
1428  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
1429  		    ret, "Error creating the data thread");
1430  		goto error;
1431  	}
1432  #endif
1433  	session->have_thread = 1;
1434  	if (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)
1435  		goto fatal_error;
1436  	*sessionp = session;
1437  	return 0;
1438  error:
1439  	*sessionp = NULL;
1440  	if (addrinfo)
1441  		freeaddrinfo(addrinfo);
1442  	if (session)
1443  	{
1444  		session_close(session);
1445  		free(session);
1446  	}
1447  	if (rpcap_senderror(pars->sockctrl, pars->ssl, ver,
1448  	    PCAP_ERR_STARTCAPTURE, errmsgbuf, errbuf) == -1)
1449  	{
1450  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
1451  		return -1;
1452  	}
1453  	if (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)
1454  	{
1455  		return -1;
1456  	}
1457  	return 0;
1458  fatal_error:
1459  	*sessionp = NULL;
1460  	if (session)
1461  	{
1462  		session_close(session);
1463  		free(session);
1464  	}
1465  	return -1;
1466  }
1467  static int
1468  daemon_msg_endcap_req(uint8_t ver, struct daemon_slpars *pars,
1469      struct session *session)
1470  {
1471  	char errbuf[PCAP_ERRBUF_SIZE];		
1472  	struct rpcap_header header;
1473  	session_close(session);
1474  	rpcap_createhdr(&header, ver, RPCAP_MSG_ENDCAP_REPLY, 0, 0);
1475  	if (sock_send(pars->sockctrl, pars->ssl, (char *) &header, sizeof(struct rpcap_header), errbuf, PCAP_ERRBUF_SIZE) == -1)
1476  	{
1477  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
1478  		return -1;
1479  	}
1480  	return 0;
1481  }
1482  #define RPCAP_BPF_MAXINSNS	8192
1483  static int
1484  daemon_unpackapplyfilter(SOCKET sockctrl, SSL *ctrl_ssl, struct session *session, uint32_t *plenp, char *errmsgbuf)
1485  {
1486  	int status;
1487  	struct rpcap_filter filter;
1488  	struct rpcap_filterbpf_insn insn;
1489  	struct bpf_insn *bf_insn;
1490  	struct bpf_program bf_prog;
1491  	unsigned int i;
1492  	status = rpcapd_recv(sockctrl, ctrl_ssl, (char *) &filter,
1493  	    sizeof(struct rpcap_filter), plenp, errmsgbuf);
1494  	if (status == -1)
1495  	{
1496  		return -1;
1497  	}
1498  	if (status == -2)
1499  	{
1500  		return -2;
1501  	}
1502  	bf_prog.bf_len = ntohl(filter.nitems);
1503  	if (ntohs(filter.filtertype) != RPCAP_UPDATEFILTER_BPF)
1504  	{
1505  		snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "Only BPF/NPF filters are currently supported");
1506  		return -2;
1507  	}
1508  	if (bf_prog.bf_len > RPCAP_BPF_MAXINSNS)
1509  	{
1510  		snprintf(errmsgbuf, PCAP_ERRBUF_SIZE,
1511  		    "Filter program is larger than the maximum size of %d instructions",
1512  		    RPCAP_BPF_MAXINSNS);
1513  		return -2;
1514  	}
1515  	bf_insn = (struct bpf_insn *) malloc (sizeof(struct bpf_insn) * bf_prog.bf_len);
1516  	if (bf_insn == NULL)
1517  	{
1518  		pcap_fmt_errmsg_for_errno(errmsgbuf, PCAP_ERRBUF_SIZE,
1519  		    errno, "malloc() failed");
1520  		return -2;
1521  	}
1522  	bf_prog.bf_insns = bf_insn;
1523  	for (i = 0; i < bf_prog.bf_len; i++)
1524  	{
1525  		status = rpcapd_recv(sockctrl, ctrl_ssl, (char *) &insn,
1526  		    sizeof(struct rpcap_filterbpf_insn), plenp, errmsgbuf);
1527  		if (status == -1)
1528  		{
1529  			return -1;
1530  		}
1531  		if (status == -2)
1532  		{
1533  			return -2;
1534  		}
1535  		bf_insn->code = ntohs(insn.code);
1536  		bf_insn->jf = insn.jf;
1537  		bf_insn->jt = insn.jt;
1538  		bf_insn->k = ntohl(insn.k);
1539  		bf_insn++;
1540  	}
1541  	if (bpf_validate(bf_prog.bf_insns, bf_prog.bf_len) == 0)
1542  	{
1543  		snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "The filter contains bogus instructions");
1544  		return -2;
1545  	}
1546  	if (pcap_setfilter(session->fp, &bf_prog))
1547  	{
1548  		snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "RPCAP error: %s", pcap_geterr(session->fp));
1549  		return -2;
1550  	}
1551  	return 0;
1552  }
1553  static int
1554  daemon_msg_updatefilter_req(uint8_t ver, struct daemon_slpars *pars,
1555      struct session *session, uint32_t plen)
1556  {
1557  	char errbuf[PCAP_ERRBUF_SIZE];
1558  	char errmsgbuf[PCAP_ERRBUF_SIZE];	
1559  	int ret;				
1560  	struct rpcap_header header;		
1561  	ret = daemon_unpackapplyfilter(pars->sockctrl, pars->ssl, session, &plen, errmsgbuf);
1562  	if (ret == -1)
1563  	{
1564  		return -1;
1565  	}
1566  	if (ret == -2)
1567  	{
1568  		goto error;
1569  	}
1570  	if (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)
1571  	{
1572  		return -1;
1573  	}
1574  	rpcap_createhdr(&header, ver, RPCAP_MSG_UPDATEFILTER_REPLY, 0, 0);
1575  	if (sock_send(pars->sockctrl, pars->ssl, (char *) &header, sizeof (struct rpcap_header), errbuf, PCAP_ERRBUF_SIZE))
1576  	{
1577  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
1578  		return -1;
1579  	}
1580  	return 0;
1581  error:
1582  	if (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)
1583  	{
1584  		return -1;
1585  	}
1586  	rpcap_senderror(pars->sockctrl, pars->ssl, ver, PCAP_ERR_UPDATEFILTER,
1587  	    errmsgbuf, NULL);
1588  	return 0;
1589  }
1590  static int
1591  daemon_msg_setsampling_req(uint8_t ver, struct daemon_slpars *pars, uint32_t plen,
1592      struct rpcap_sampling *samp_param)
1593  {
1594  	char errbuf[PCAP_ERRBUF_SIZE];		
1595  	char errmsgbuf[PCAP_ERRBUF_SIZE];
1596  	struct rpcap_header header;
1597  	struct rpcap_sampling rpcap_samp;
1598  	int status;
1599  	status = rpcapd_recv(pars->sockctrl, pars->ssl, (char *) &rpcap_samp, sizeof(struct rpcap_sampling), &plen, errmsgbuf);
1600  	if (status == -1)
1601  	{
1602  		return -1;
1603  	}
1604  	if (status == -2)
1605  	{
1606  		goto error;
1607  	}
1608  	samp_param->method = rpcap_samp.method;
1609  	samp_param->value = ntohl(rpcap_samp.value);
1610  	rpcap_createhdr(&header, ver, RPCAP_MSG_SETSAMPLING_REPLY, 0, 0);
1611  	if (sock_send(pars->sockctrl, pars->ssl, (char *) &header, sizeof (struct rpcap_header), errbuf, PCAP_ERRBUF_SIZE) == -1)
1612  	{
1613  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
1614  		return -1;
1615  	}
1616  	if (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)
1617  	{
1618  		return -1;
1619  	}
1620  	return 0;
1621  error:
1622  	if (rpcap_senderror(pars->sockctrl, pars->ssl, ver, PCAP_ERR_SETSAMPLING,
1623  	    errmsgbuf, errbuf) == -1)
1624  	{
1625  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
1626  		return -1;
1627  	}
1628  	if (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)
1629  	{
1630  		return -1;
1631  	}
1632  	return 0;
1633  }
1634  static int
1635  daemon_msg_stats_req(uint8_t ver, struct daemon_slpars *pars,
1636      struct session *session, uint32_t plen, struct pcap_stat *stats,
1637      unsigned int svrcapt)
1638  {
1639  	char errbuf[PCAP_ERRBUF_SIZE];		
1640  	char errmsgbuf[PCAP_ERRBUF_SIZE];	
1641  	char sendbuf[RPCAP_NETBUF_SIZE];	
1642  	int sendbufidx = 0;			
1643  	struct rpcap_stats *netstats;		
1644  	if (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)
1645  	{
1646  		return -1;
1647  	}
1648  	if (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,
1649  	    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1650  		goto error;
1651  	rpcap_createhdr((struct rpcap_header *) sendbuf, ver,
1652  	    RPCAP_MSG_STATS_REPLY, 0, (uint16_t) sizeof(struct rpcap_stats));
1653  	netstats = (struct rpcap_stats *) &sendbuf[sendbufidx];
1654  	if (sock_bufferize(NULL, sizeof(struct rpcap_stats), NULL,
1655  	    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1656  		goto error;
1657  	if (session && session->fp)
1658  	{
1659  		if (pcap_stats(session->fp, stats) == -1)
1660  		{
1661  			snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "%s", pcap_geterr(session->fp));
1662  			goto error;
1663  		}
1664  		netstats->ifdrop = htonl(stats->ps_ifdrop);
1665  		netstats->ifrecv = htonl(stats->ps_recv);
1666  		netstats->krnldrop = htonl(stats->ps_drop);
1667  		netstats->svrcapt = htonl(session->TotCapt);
1668  	}
1669  	else
1670  	{
1671  		netstats->ifdrop = htonl(stats->ps_ifdrop);
1672  		netstats->ifrecv = htonl(stats->ps_recv);
1673  		netstats->krnldrop = htonl(stats->ps_drop);
1674  		netstats->svrcapt = htonl(svrcapt);
1675  	}
1676  	if (sock_send(pars->sockctrl, pars->ssl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)
1677  	{
1678  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
1679  		return -1;
1680  	}
1681  	return 0;
1682  error:
1683  	rpcap_senderror(pars->sockctrl, pars->ssl, ver, PCAP_ERR_GETSTATS,
1684  	    errmsgbuf, NULL);
1685  	return 0;
1686  }
1687  #ifdef _WIN32
1688  static unsigned __stdcall
1689  #else
1690  static void *
1691  #endif
1692  daemon_thrdatamain(void *ptr)
1693  {
1694  	char errbuf[PCAP_ERRBUF_SIZE + 1];	
1695  	struct session *session;		
1696  	int retval;							
1697  	struct rpcap_pkthdr *net_pkt_header;
1698  	struct pcap_pkthdr *pkt_header;		
1699  	u_char *pkt_data;					
1700  	size_t sendbufsize;			
1701  	char *sendbuf;						
1702  	int sendbufidx;						
1703  	int status;
1704  #ifndef _WIN32
1705  	sigset_t sigusr1;			
1706  #endif
1707  	session = (struct session *) ptr;
1708  	session->TotCapt = 0;			
1709  	memset(errbuf, 0, sizeof(errbuf));
1710  	if (pcap_snapshot(session->fp) < 0)
1711  	{
1712  		rpcapd_log(LOGPRIO_ERROR,
1713  		    "Unable to allocate the buffer for this child thread: snapshot length of %d is negative",
1714  		        pcap_snapshot(session->fp));
1715  		sendbuf = NULL;	
1716  		goto error;
1717  	}
1718  	sendbufsize = sizeof(struct rpcap_header) + sizeof(struct rpcap_pkthdr) + pcap_snapshot(session->fp);
1719  	if (sendbufsize > INT_MAX)
1720  	{
1721  		rpcapd_log(LOGPRIO_ERROR,
1722  		    "Buffer size for this child thread would be larger than %d",
1723  		    INT_MAX);
1724  		sendbuf = NULL;	
1725  		goto error;
1726  	}
1727  	sendbuf = (char *) malloc (sendbufsize);
1728  	if (sendbuf == NULL)
1729  	{
1730  		rpcapd_log(LOGPRIO_ERROR,
1731  		    "Unable to allocate the buffer for this child thread");
1732  		goto error;
1733  	}
1734  #ifndef _WIN32
1735  	sigemptyset(&sigusr1);
1736  	sigaddset(&sigusr1, SIGUSR1);
1737  	pthread_sigmask(SIG_BLOCK, &sigusr1, NULL);
1738  #endif
1739  	for (;;)
1740  	{
1741  #ifndef _WIN32
1742  		pthread_sigmask(SIG_UNBLOCK, &sigusr1, NULL);
1743  #endif
1744  		retval = pcap_next_ex(session->fp, &pkt_header, (const u_char **) &pkt_data);	
1745  #ifndef _WIN32
1746  		pthread_sigmask(SIG_BLOCK, &sigusr1, NULL);
1747  #endif
1748  		if (retval < 0)
1749  			break;		
1750  		if (retval == 0)	
1751  			continue;
1752  		sendbufidx = 0;
1753  		if (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,
1754  		    &sendbufidx, (int)sendbufsize, SOCKBUF_CHECKONLY, errbuf,
1755  		    PCAP_ERRBUF_SIZE) == -1)
1756  		{
1757  			rpcapd_log(LOGPRIO_ERROR,
1758  			    "sock_bufferize() error sending packet message: %s",
1759  			    errbuf);
1760  			goto error;
1761  		}
1762  		rpcap_createhdr((struct rpcap_header *) sendbuf,
1763  		    session->protocol_version, RPCAP_MSG_PACKET, 0,
1764  		    (uint16_t) (sizeof(struct rpcap_pkthdr) + pkt_header->caplen));
1765  		net_pkt_header = (struct rpcap_pkthdr *) &sendbuf[sendbufidx];
1766  		if (sock_bufferize(NULL, sizeof(struct rpcap_pkthdr), NULL,
1767  		    &sendbufidx, (int)sendbufsize, SOCKBUF_CHECKONLY, errbuf,
1768  		    PCAP_ERRBUF_SIZE) == -1)
1769  		{
1770  			rpcapd_log(LOGPRIO_ERROR,
1771  			    "sock_bufferize() error sending packet message: %s",
1772  			    errbuf);
1773  			goto error;
1774  		}
1775  		net_pkt_header->caplen = htonl(pkt_header->caplen);
1776  		net_pkt_header->len = htonl(pkt_header->len);
1777  		net_pkt_header->npkt = htonl(++(session->TotCapt));
1778  		net_pkt_header->timestamp_sec = htonl((uint32_t)pkt_header->ts.tv_sec);
1779  		net_pkt_header->timestamp_usec = htonl((uint32_t)pkt_header->ts.tv_usec);
1780  		if (sock_bufferize((char *) pkt_data, pkt_header->caplen,
1781  		    sendbuf, &sendbufidx, (int)sendbufsize, SOCKBUF_BUFFERIZE,
1782  		    errbuf, PCAP_ERRBUF_SIZE) == -1)
1783  		{
1784  			rpcapd_log(LOGPRIO_ERROR,
1785  			    "sock_bufferize() error sending packet message: %s",
1786  			    errbuf);
1787  			goto error;
1788  		}
1789  		status = sock_send(session->sockdata, session->data_ssl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE);
1790  		if (status < 0)
1791  		{
1792  			if (status == -1)
1793  			{
1794  				rpcapd_log(LOGPRIO_ERROR,
1795  				    "Send of packet to client failed: %s",
1796  				    errbuf);
1797  			}
1798  			goto error;
1799  		}
1800  	}
1801  	if (retval < 0 && retval != PCAP_ERROR_BREAK)
1802  	{
1803  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "Error reading the packets: %s", pcap_geterr(session->fp));
1804  		rpcap_senderror(session->sockctrl, session->ctrl_ssl, session->protocol_version,
1805  		    PCAP_ERR_READEX, errbuf, NULL);
1806  	}
1807  error:
1808  	free(sendbuf);
1809  	return 0;
1810  }
1811  #ifndef _WIN32
1812  static void noop_handler(int sign _U_)
1813  {
1814  }
1815  #endif
1816  static void
1817  daemon_seraddr(struct sockaddr_storage *sockaddrin, struct rpcap_sockaddr *sockaddrout)
1818  {
1819  	memset(sockaddrout, 0, sizeof(struct sockaddr_storage));
1820  	if (sockaddrin == NULL) return;
1821  	switch (sockaddrin->ss_family)
1822  	{
1823  	case AF_INET:
1824  		{
1825  		struct sockaddr_in *sockaddrin_ipv4;
1826  		struct rpcap_sockaddr_in sockaddrout_ipv4;
1827  		sockaddrin_ipv4 = (struct sockaddr_in *) sockaddrin;
1828  		sockaddrout_ipv4.family = htons(RPCAP_AF_INET);
1829  		sockaddrout_ipv4.port = htons(sockaddrin_ipv4->sin_port);
1830  		memcpy(&sockaddrout_ipv4.addr, &sockaddrin_ipv4->sin_addr, sizeof(sockaddrout_ipv4.addr));
1831  		memset(sockaddrout_ipv4.zero, 0, sizeof(sockaddrout_ipv4.zero));
1832  		memcpy(sockaddrout, &sockaddrout_ipv4, sizeof(struct rpcap_sockaddr_in));
1833  		break;
1834  		}
1835  #ifdef AF_INET6
1836  	case AF_INET6:
1837  		{
1838  		struct sockaddr_in6 *sockaddrin_ipv6;
1839  		struct rpcap_sockaddr_in6 sockaddrout_ipv6;
1840  		sockaddrin_ipv6 = (struct sockaddr_in6 *) sockaddrin;
1841  		sockaddrout_ipv6.family = htons(RPCAP_AF_INET6);
1842  		sockaddrout_ipv6.port = htons(sockaddrin_ipv6->sin6_port);
1843  		sockaddrout_ipv6.flowinfo = htonl(sockaddrin_ipv6->sin6_flowinfo);
1844  		memcpy(&sockaddrout_ipv6.addr, &sockaddrin_ipv6->sin6_addr, sizeof(sockaddrout_ipv6.addr));
1845  		sockaddrout_ipv6.scope_id = htonl(sockaddrin_ipv6->sin6_scope_id);
1846  		memcpy(sockaddrout, &sockaddrout_ipv6, sizeof(struct rpcap_sockaddr_in6));
1847  		break;
1848  		}
1849  #endif
1850  	}
1851  }
1852  void sleep_secs(int secs)
1853  {
1854  #ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
1855  #ifdef _WIN32
1856  	Sleep(secs*1000);
1857  #else
1858  	unsigned secs_remaining;
1859  	if (secs <= 0)
1860  		return;
1861  	secs_remaining = secs;
1862  	while (secs_remaining != 0)
1863  		secs_remaining = sleep(secs_remaining);
1864  #endif
1865  #endif
1866  }
1867  static int
1868  rpcapd_recv_msg_header(SOCKET sock, SSL *ssl, struct rpcap_header *headerp)
1869  {
1870  	int nread;
1871  	char errbuf[PCAP_ERRBUF_SIZE];		
1872  	nread = sock_recv(sock, ssl, (char *) headerp, sizeof(struct rpcap_header),
1873  	    SOCK_RECEIVEALL_YES|SOCK_EOF_ISNT_ERROR, errbuf, PCAP_ERRBUF_SIZE);
1874  	if (nread == -1)
1875  	{
1876  		rpcapd_log(LOGPRIO_ERROR, "Read from client failed: %s", errbuf);
1877  		return -1;
1878  	}
1879  	if (nread == 0)
1880  	{
1881  		return -2;
1882  	}
1883  	headerp->plen = ntohl(headerp->plen);
1884  	return 0;
1885  }
1886  static int
1887  rpcapd_recv(SOCKET sock, SSL *ssl, char *buffer, size_t toread, uint32_t *plen, char *errmsgbuf)
1888  {
1889  	int nread;
1890  	char errbuf[PCAP_ERRBUF_SIZE];		
1891  	if (toread > *plen)
1892  	{
1893  		snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "Message payload is too short");
1894  		return -2;
1895  	}
1896  	nread = sock_recv(sock, ssl, buffer, toread,
1897  	    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);
1898  	if (nread == -1)
1899  	{
1900  		rpcapd_log(LOGPRIO_ERROR, "Read from client failed: %s", errbuf);
1901  		return -1;
1902  	}
1903  	*plen -= nread;
1904  	return 0;
1905  }
1906  static int
1907  rpcapd_discard(SOCKET sock, SSL *ssl, uint32_t len)
1908  {
1909  	char errbuf[PCAP_ERRBUF_SIZE + 1];	
1910  	if (len != 0)
1911  	{
1912  		if (sock_discard(sock, ssl, len, errbuf, PCAP_ERRBUF_SIZE) == -1)
1913  		{
1914  			rpcapd_log(LOGPRIO_ERROR, "Read from client failed: %s", errbuf);
1915  			return -1;
1916  		}
1917  	}
1918  	return 0;
1919  }
1920  static void session_close(struct session *session)
1921  {
1922  	if (session->have_thread)
1923  	{
1924  		pcap_breakloop(session->fp);
1925  #ifdef _WIN32
1926  		SetEvent(pcap_getevent(session->fp));
1927  		WaitForSingleObject(session->thread, INFINITE);
1928  		CloseHandle(session->thread);
1929  		session->have_thread = 0;
1930  		session->thread = INVALID_HANDLE_VALUE;
1931  #else
1932  		pthread_kill(session->thread, SIGUSR1);
1933  		pthread_join(session->thread, NULL);
1934  		session->have_thread = 0;
1935  		memset(&session->thread, 0, sizeof(session->thread));
1936  #endif
1937  	}
1938  #ifdef HAVE_OPENSSL
1939  	if (session->data_ssl)
1940  	{
1941  		ssl_finish(session->data_ssl);
1942  		session->data_ssl = NULL;
1943  	}
1944  #endif
1945  	if (session->sockdata != INVALID_SOCKET)
1946  	{
1947  		sock_close(session->sockdata, NULL, 0);
1948  		session->sockdata = INVALID_SOCKET;
1949  	}
1950  	if (session->fp)
1951  	{
1952  		pcap_close(session->fp);
1953  		session->fp = NULL;
1954  	}
1955  }
1956  static int
1957  is_url(const char *source)
1958  {
1959  	char *colonp;
1960  	colonp = strchr(source, ':');
1961  	if (colonp == NULL)
1962  	{
1963  		return (0);
1964  	}
1965  	if (strncmp(colonp + 1, "&bsol;&bsol;", 2) != 0)
1966  	{
1967  		return (0);
1968  	}
1969  	return (1);
1970  }
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-daemon.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include "ftmacros.h"
5  #include "varattrs.h"
6  #include <errno.h>		
7  #include <stdlib.h>		
8  #include <string.h>		
9  #include <limits.h>		
10  #ifdef _WIN32
11    #include <process.h>		
12  #else
13    #include <unistd.h>
14    #include <pthread.h>
15    #include <signal.h>
16    #include <sys/time.h>
17    #include <sys/types.h>	
18    #include <pwd.h>		
19  #endif
20  #ifdef HAVE_GETSPNAM
21  #include <shadow.h>		
22  #endif
23  #include <pcap.h>		
24  #include "fmtutils.h"
25  #include "sockutils.h"		
26  #include "portability.h"
27  #include "rpcap-protocol.h"
28  #include "daemon.h"
29  #include "log.h"
30  #ifdef HAVE_OPENSSL
31  #include <openssl/ssl.h>
32  #include "sslutils.h"
33  #endif
34  #define RPCAP_TIMEOUT_INIT 90
35  #define RPCAP_TIMEOUT_RUNTIME 180
36  #define RPCAP_SUSPEND_WRONGAUTH 1
37  struct daemon_slpars
38  {
39  	SOCKET sockctrl;	
40  	SSL *ssl;		
41  	int isactive;		
42  	int nullAuthAllowed;	
43  };
44  struct session {
45  	SOCKET sockctrl;
46  	SOCKET sockdata;
47  	SSL *ctrl_ssl, *data_ssl; 
48  	uint8_t protocol_version;
49  	pcap_t *fp;
50  	unsigned int TotCapt;
51  	int	have_thread;
52  #ifdef _WIN32
53  	HANDLE thread;
54  #else
55  	pthread_t thread;
56  #endif
57  };
58  static int daemon_msg_err(SOCKET sockctrl, SSL *, uint32_t plen);
59  static int daemon_msg_auth_req(struct daemon_slpars *pars, uint32_t plen);
60  static int daemon_AuthUserPwd(char *username, char *password, char *errbuf);
61  static int daemon_msg_findallif_req(uint8_t ver, struct daemon_slpars *pars,
62      uint32_t plen);
63  static int daemon_msg_open_req(uint8_t ver, struct daemon_slpars *pars,
64      uint32_t plen, char *source, size_t sourcelen);
65  static int daemon_msg_startcap_req(uint8_t ver, struct daemon_slpars *pars,
66      uint32_t plen, char *source, char *data_port, struct session **sessionp,
67      struct rpcap_sampling *samp_param, int uses_ssl);
68  static int daemon_msg_endcap_req(uint8_t ver, struct daemon_slpars *pars,
69      struct session *session);
70  static int daemon_msg_updatefilter_req(uint8_t ver, struct daemon_slpars *pars,
71      struct session *session, uint32_t plen);
72  static int daemon_unpackapplyfilter(SOCKET sockctrl, SSL *, struct session *session, uint32_t *plenp, char *errbuf);
73  static int daemon_msg_stats_req(uint8_t ver, struct daemon_slpars *pars,
74      struct session *session, uint32_t plen, struct pcap_stat *stats,
75      unsigned int svrcapt);
76  static int daemon_msg_setsampling_req(uint8_t ver, struct daemon_slpars *pars,
77      uint32_t plen, struct rpcap_sampling *samp_param);
78  static void daemon_seraddr(struct sockaddr_storage *sockaddrin, struct rpcap_sockaddr *sockaddrout);
79  #ifdef _WIN32
80  static unsigned __stdcall daemon_thrdatamain(void *ptr);
81  #else
82  static void *daemon_thrdatamain(void *ptr);
83  static void noop_handler(int sign);
84  #endif
85  static int rpcapd_recv_msg_header(SOCKET sock, SSL *, struct rpcap_header *headerp);
86  static int rpcapd_recv(SOCKET sock, SSL *, char *buffer, size_t toread, uint32_t *plen, char *errmsgbuf);
87  static int rpcapd_discard(SOCKET sock, SSL *, uint32_t len);
88  static void session_close(struct session *);
89  struct tls_record_header {
90  	uint8_t type;		
91  	uint8_t version_major;	
92  	uint8_t version_injor;	
93  	uint8_t length_hi;	
94  	uint8_t length_lo;	
95  };
96  #define TLS_RECORD_HEADER_LEN	5	
97  #define TLS_RECORD_TYPE_ALERT		21
98  #define TLS_RECORD_TYPE_HANDSHAKE	22
99  struct tls_alert {
100  	uint8_t alert_level;
101  	uint8_t alert_description;
102  };
103  #define TLS_ALERT_LEN			2
104  #define TLS_ALERT_LEVEL_FATAL		2
105  #define TLS_ALERT_HANDSHAKE_FAILURE	40
106  static int is_url(const char *source);
107  #ifndef UINT16_MAX
108  #define UINT16_MAX	65535U
109  #endif
110  #ifndef UINT32_MAX
111  #define UINT32_MAX	4294967295U
112  #endif
113  int
114  daemon_serviceloop(SOCKET sockctrl, int isactive, char *passiveClients,
115      int nullAuthAllowed, char *data_port, int uses_ssl)
116  {
117  	uint8_t first_octet;
118  	struct tls_record_header tls_header;
119  	struct tls_alert tls_alert;
120  	struct daemon_slpars pars;		
121  	char errbuf[PCAP_ERRBUF_SIZE + 1];	
122  	char errmsgbuf[PCAP_ERRBUF_SIZE + 1];	
123  	int host_port_check_status;
124  	SSL *ssl = NULL;
125  	int nrecv;
126  	struct rpcap_header header;		
127  	uint32_t plen;				
128  	int authenticated = 0;			
129  	char source[PCAP_BUF_SIZE+1];		
130  	int got_source = 0;			
131  #ifndef _WIN32
132  	struct sigaction action;
133  #endif
134  	struct session *session = NULL;		
135  	const char *msg_type_string;		
136  	int client_told_us_to_close = 0;	
137  	struct pcap_stat stats;
138  	unsigned int svrcapt;
139  	struct rpcap_sampling samp_param;	
140  	fd_set rfds;				
141  	struct timeval tv;			
142  	int retval;				
143  	*errbuf = 0;	
144  	nrecv = sock_recv(sockctrl, NULL, (char *)&first_octet, 1,
145  	    SOCK_EOF_ISNT_ERROR|SOCK_MSG_PEEK, errbuf, PCAP_ERRBUF_SIZE);
146  	if (nrecv == -1)
147  	{
148  		rpcapd_log(LOGPRIO_ERROR, "Peek from client failed: %s", errbuf);
149  		goto end;
150  	}
151  	if (nrecv == 0)
152  	{
153  		goto end;
154  	}
155  #ifdef HAVE_OPENSSL
156  	if (uses_ssl)
157  	{
158  		if (first_octet != TLS_RECORD_TYPE_HANDSHAKE)
159  		{
160  			nrecv = rpcapd_recv_msg_header(sockctrl, NULL, &header);
161  			if (nrecv == -1)
162  			{
163  				goto end;
164  			}
165  			if (nrecv == -2)
166  			{
167  				goto end;
168  			}
169  			plen = header.plen;
170  			if (rpcapd_discard(sockctrl, NULL, plen) == -1)
171  			{
172  				goto end;
173  			}
174  			if (rpcap_senderror(sockctrl, NULL, header.ver,
175  			    PCAP_ERR_TLS_REQUIRED,
176  			    "TLS is required by this server", errbuf) == -1)
177  			{
178  				rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
179  				goto end;
180  			}
181  			goto end;
182  		}
183  		ssl = ssl_promotion(1, sockctrl, errbuf, PCAP_ERRBUF_SIZE);
184  		if (! ssl)
185  		{
186  			rpcapd_log(LOGPRIO_ERROR, "TLS handshake on control connection failed: %s",
187  			    errbuf);
188  			goto end;
189  		}
190  	}
191  	else
192  #endif
193  	{
194  		if (first_octet == TLS_RECORD_TYPE_HANDSHAKE)
195  		{
196  			nrecv = sock_recv(sockctrl, ssl, (char *) &tls_header,
197  			    sizeof tls_header, SOCK_RECEIVEALL_YES|SOCK_EOF_ISNT_ERROR,
198  			    errbuf, PCAP_ERRBUF_SIZE);
199  			if (nrecv == -1)
200  			{
201  				rpcapd_log(LOGPRIO_ERROR, "Read from client failed: %s", errbuf);
202  				goto end;
203  			}
204  			if (nrecv == 0)
205  			{
206  				goto end;
207  			}
208  			plen = (tls_header.length_hi << 8U) | tls_header.length_lo;
209  			if (rpcapd_discard(sockctrl, NULL, plen) == -1)
210  			{
211  				goto end;
212  			}
213  			tls_header.type = TLS_RECORD_TYPE_ALERT;
214  			tls_header.length_hi = 0;
215  			tls_header.length_lo = TLS_ALERT_LEN;
216  			if (sock_send(sockctrl, NULL, (char *) &tls_header,
217  			    TLS_RECORD_HEADER_LEN, errbuf, PCAP_ERRBUF_SIZE) == -1)
218  			{
219  				rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
220  				goto end;
221  			}
222  			tls_alert.alert_level = TLS_ALERT_LEVEL_FATAL;
223  			tls_alert.alert_description = TLS_ALERT_HANDSHAKE_FAILURE;
224  			if (sock_send(sockctrl, NULL, (char *) &tls_alert,
225  			    TLS_ALERT_LEN, errbuf, PCAP_ERRBUF_SIZE) == -1)
226  			{
227  				rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
228  				goto end;
229  			}
230  			goto end;
231  		}
232  	}
233  	pars.sockctrl = sockctrl;
234  	pars.ssl = ssl;
235  	pars.isactive = isactive;		
236  	pars.nullAuthAllowed = nullAuthAllowed;
237  	if (pars.isactive)
238  	{
239  		free(passiveClients);
240  		passiveClients = NULL;
241  	}
242  	else
243  	{
244  		struct sockaddr_storage from;
245  		socklen_t fromlen;
246  		fromlen = sizeof(struct sockaddr_storage);
247  		if (getpeername(pars.sockctrl, (struct sockaddr *)&from,
248  		    &fromlen) == -1)
249  		{
250  			sock_geterrmsg(errmsgbuf, PCAP_ERRBUF_SIZE,
251  			    "getpeername() failed");
252  			if (rpcap_senderror(pars.sockctrl, pars.ssl, 0, PCAP_ERR_NETW, errmsgbuf, errbuf) == -1)
253  				rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
254  			goto end;
255  		}
256  		host_port_check_status = sock_check_hostlist(passiveClients, RPCAP_HOSTLIST_SEP, &from, errmsgbuf, PCAP_ERRBUF_SIZE);
257  		free(passiveClients);
258  		passiveClients = NULL;
259  		if (host_port_check_status < 0)
260  		{
261  			if (host_port_check_status == -2) {
262  				rpcapd_log(LOGPRIO_ERROR, "%s", errmsgbuf);
263  			}
264  			if (rpcap_senderror(pars.sockctrl, pars.ssl, 0, PCAP_ERR_HOSTNOAUTH, errmsgbuf, errbuf) == -1)
265  				rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
266  			goto end;
267  		}
268  	}
269  #ifndef _WIN32
270  	memset(&action, 0, sizeof (action));
271  	action.sa_handler = noop_handler;
272  	action.sa_flags = 0;
273  	sigemptyset(&action.sa_mask);
274  	sigaction(SIGUSR1, &action, NULL);
275  #endif
276  	while (!authenticated)
277  	{
278  		if (!pars.isactive)
279  		{
280  			FD_ZERO(&rfds);
281  			tv.tv_sec = RPCAP_TIMEOUT_INIT;
282  			tv.tv_usec = 0;
283  			FD_SET(pars.sockctrl, &rfds);
284  			retval = select((int)pars.sockctrl + 1, &rfds, NULL, NULL, &tv);
285  			if (retval == -1)
286  			{
287  				sock_geterrmsg(errmsgbuf, PCAP_ERRBUF_SIZE,
288  				    "select() failed");
289  				if (rpcap_senderror(pars.sockctrl, pars.ssl, 0, PCAP_ERR_NETW, errmsgbuf, errbuf) == -1)
290  					rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
291  				goto end;
292  			}
293  			if (retval == 0)
294  			{
295  				if (rpcap_senderror(pars.sockctrl, pars.ssl, 0, PCAP_ERR_INITTIMEOUT, "The RPCAP initial timeout has expired", errbuf) == -1)
296  					rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
297  				goto end;
298  			}
299  		}
300  		nrecv = rpcapd_recv_msg_header(pars.sockctrl, pars.ssl, &header);
301  		if (nrecv == -1)
302  		{
303  			goto end;
304  		}
305  		if (nrecv == -2)
306  		{
307  			goto end;
308  		}
309  		plen = header.plen;
310  		if (header.ver != 0)
311  		{
312  			if (rpcap_senderror(pars.sockctrl, pars.ssl, header.ver,
313  			    PCAP_ERR_WRONGVER,
314  			    "RPCAP version in requests in the authentication phase must be 0",
315  			    errbuf) == -1)
316  			{
317  				rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
318  				goto end;
319  			}
320  			(void)rpcapd_discard(pars.sockctrl, pars.ssl, plen);
321  			goto end;
322  		}
323  		switch (header.type)
324  		{
325  			case RPCAP_MSG_AUTH_REQ:
326  				retval = daemon_msg_auth_req(&pars, plen);
327  				if (retval == -1)
328  				{
329  					goto end;
330  				}
331  				if (retval == -2)
332  				{
333  					continue;
334  				}
335  				authenticated = 1;
336  				break;
337  			case RPCAP_MSG_CLOSE:
338  				(void)rpcapd_discard(pars.sockctrl, pars.ssl, plen);
339  				goto end;
340  			case RPCAP_MSG_ERROR:
341  				(void)daemon_msg_err(pars.sockctrl, pars.ssl, plen);
342  				goto end;
343  			case RPCAP_MSG_FINDALLIF_REQ:
344  			case RPCAP_MSG_OPEN_REQ:
345  			case RPCAP_MSG_STARTCAP_REQ:
346  			case RPCAP_MSG_UPDATEFILTER_REQ:
347  			case RPCAP_MSG_STATS_REQ:
348  			case RPCAP_MSG_ENDCAP_REQ:
349  			case RPCAP_MSG_SETSAMPLING_REQ:
350  				msg_type_string = rpcap_msg_type_string(header.type);
351  				if (msg_type_string != NULL)
352  				{
353  					snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "%s request sent before authentication was completed", msg_type_string);
354  				}
355  				else
356  				{
357  					snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "Message of type %u sent before authentication was completed", header.type);
358  				}
359  				if (rpcap_senderror(pars.sockctrl, pars.ssl,
360  				    header.ver, PCAP_ERR_WRONGMSG,
361  				    errmsgbuf, errbuf) == -1)
362  				{
363  					rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
364  					goto end;
365  				}
366  				if (rpcapd_discard(pars.sockctrl, pars.ssl, plen) == -1)
367  				{
368  					goto end;
369  				}
370  				break;
371  			case RPCAP_MSG_PACKET:
372  			case RPCAP_MSG_FINDALLIF_REPLY:
373  			case RPCAP_MSG_OPEN_REPLY:
374  			case RPCAP_MSG_STARTCAP_REPLY:
375  			case RPCAP_MSG_UPDATEFILTER_REPLY:
376  			case RPCAP_MSG_AUTH_REPLY:
377  			case RPCAP_MSG_STATS_REPLY:
378  			case RPCAP_MSG_ENDCAP_REPLY:
379  			case RPCAP_MSG_SETSAMPLING_REPLY:
380  				msg_type_string = rpcap_msg_type_string(header.type);
381  				if (msg_type_string != NULL)
382  				{
383  					snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "Server-to-client message %s received from client", msg_type_string);
384  				}
385  				else
386  				{
387  					snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "Server-to-client message of type %u received from client", header.type);
388  				}
389  				if (rpcap_senderror(pars.sockctrl, pars.ssl,
390  				    header.ver, PCAP_ERR_WRONGMSG,
391  				    errmsgbuf, errbuf) == -1)
392  				{
393  					rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
394  					goto end;
395  				}
396  				if (rpcapd_discard(pars.sockctrl, pars.ssl, plen) == -1)
397  				{
398  					goto end;
399  				}
400  				break;
401  			default:
402  				snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "Unknown message type %u", header.type);
403  				if (rpcap_senderror(pars.sockctrl, pars.ssl,
404  				    header.ver, PCAP_ERR_WRONGMSG,
405  				    errmsgbuf, errbuf) == -1)
406  				{
407  					rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
408  					goto end;
409  				}
410  				if (rpcapd_discard(pars.sockctrl, pars.ssl, plen) == -1)
411  				{
412  					goto end;
413  				}
414  				break;
415  		}
416  	}
417  	stats.ps_ifdrop = 0;
418  	stats.ps_recv = 0;
419  	stats.ps_drop = 0;
420  	svrcapt = 0;
421  	for (;;)
422  	{
423  		errbuf[0] = 0;	
424  		if ((!pars.isactive) && (session == NULL || session->sockdata == 0))
425  		{
426  			FD_ZERO(&rfds);
427  			tv.tv_sec = RPCAP_TIMEOUT_RUNTIME;
428  			tv.tv_usec = 0;
429  			FD_SET(pars.sockctrl, &rfds);
430  #ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
431  			retval = 1;
432  #else
433  			retval = select((int)pars.sockctrl + 1, &rfds, NULL, NULL, &tv);
434  #endif
435  			if (retval == -1)
436  			{
437  				sock_geterrmsg(errmsgbuf, PCAP_ERRBUF_SIZE,
438  				    "select() failed");
439  				if (rpcap_senderror(pars.sockctrl, pars.ssl,
440  				    0, PCAP_ERR_NETW,
441  				    errmsgbuf, errbuf) == -1)
442  					rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
443  				goto end;
444  			}
445  			if (retval == 0)
446  			{
447  				if (rpcap_senderror(pars.sockctrl, pars.ssl,
448  				    0, PCAP_ERR_INITTIMEOUT,
449  				    "The RPCAP initial timeout has expired",
450  				    errbuf) == -1)
451  					rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
452  				goto end;
453  			}
454  		}
455  		nrecv = rpcapd_recv_msg_header(pars.sockctrl, pars.ssl, &header);
456  		if (nrecv == -1)
457  		{
458  			goto end;
459  		}
460  		if (nrecv == -2)
461  		{
462  			goto end;
463  		}
464  		plen = header.plen;
465  		if (!RPCAP_VERSION_IS_SUPPORTED(header.ver))
466  		{
467  			if (rpcap_senderror(pars.sockctrl, pars.ssl,
468  			    header.ver, PCAP_ERR_WRONGVER,
469  			    "RPCAP version in message isn't supported by the server",
470  			    errbuf) == -1)
471  			{
472  				rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
473  				goto end;
474  			}
475  			(void)rpcapd_discard(pars.sockctrl, pars.ssl, plen);
476  			goto end;
477  		}
478  		switch (header.type)
479  		{
480  			case RPCAP_MSG_ERROR:		
481  			{
482  				(void)daemon_msg_err(pars.sockctrl, pars.ssl, plen);
483  				break;
484  			}
485  			case RPCAP_MSG_FINDALLIF_REQ:
486  			{
487  				if (daemon_msg_findallif_req(header.ver, &pars, plen) == -1)
488  				{
489  					goto end;
490  				}
491  				break;
492  			}
493  			case RPCAP_MSG_OPEN_REQ:
494  			{
495  				retval = daemon_msg_open_req(header.ver, &pars,
496  				    plen, source, sizeof(source));
497  				if (retval == -1)
498  				{
499  					goto end;
500  				}
501  				got_source = 1;
502  				break;
503  			}
504  			case RPCAP_MSG_STARTCAP_REQ:
505  			{
506  				if (!got_source)
507  				{
508  					if (rpcap_senderror(pars.sockctrl, pars.ssl,
509  					    header.ver,
510  					    PCAP_ERR_STARTCAPTURE,
511  					    "No capture device was specified",
512  					    errbuf) == -1)
513  					{
514  						rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
515  						goto end;
516  					}
517  					if (rpcapd_discard(pars.sockctrl, pars.ssl, plen) == -1)
518  					{
519  						goto end;
520  					}
521  					break;
522  				}
523  				if (daemon_msg_startcap_req(header.ver, &pars,
524  				    plen, source, data_port, &session,
525  				    &samp_param, uses_ssl) == -1)
526  				{
527  					goto end;
528  				}
529  				break;
530  			}
531  			case RPCAP_MSG_UPDATEFILTER_REQ:
532  			{
533  				if (session)
534  				{
535  					if (daemon_msg_updatefilter_req(header.ver,
536  					    &pars, session, plen) == -1)
537  					{
538  						goto end;
539  					}
540  				}
541  				else
542  				{
543  					if (rpcap_senderror(pars.sockctrl, pars.ssl,
544  					    header.ver,
545  					    PCAP_ERR_UPDATEFILTER,
546  					    "Device not opened. Cannot update filter",
547  					    errbuf) == -1)
548  					{
549  						rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
550  						goto end;
551  					}
552  				}
553  				break;
554  			}
555  			case RPCAP_MSG_CLOSE:		
556  			{
557  				client_told_us_to_close = 1;
558  				rpcapd_log(LOGPRIO_DEBUG, "The other end system asked to close the connection.");
559  				goto end;
560  			}
561  			case RPCAP_MSG_STATS_REQ:
562  			{
563  				if (daemon_msg_stats_req(header.ver, &pars,
564  				    session, plen, &stats, svrcapt) == -1)
565  				{
566  					goto end;
567  				}
568  				break;
569  			}
570  			case RPCAP_MSG_ENDCAP_REQ:		
571  			{
572  				if (session)
573  				{
574  					if (pcap_stats(session->fp, &stats))
575  					{
576  						svrcapt = session->TotCapt;
577  					}
578  					else
579  					{
580  						stats.ps_ifdrop = 0;
581  						stats.ps_recv = 0;
582  						stats.ps_drop = 0;
583  						svrcapt = 0;
584  					}
585  					if (daemon_msg_endcap_req(header.ver,
586  					    &pars, session) == -1)
587  					{
588  						free(session);
589  						session = NULL;
590  						goto end;
591  					}
592  					free(session);
593  					session = NULL;
594  				}
595  				else
596  				{
597  					rpcap_senderror(pars.sockctrl, pars.ssl,
598  					    header.ver,
599  					    PCAP_ERR_ENDCAPTURE,
600  					    "Device not opened. Cannot close the capture",
601  					    errbuf);
602  				}
603  				break;
604  			}
605  			case RPCAP_MSG_SETSAMPLING_REQ:
606  			{
607  				if (daemon_msg_setsampling_req(header.ver,
608  				    &pars, plen, &samp_param) == -1)
609  				{
610  					goto end;
611  				}
612  				break;
613  			}
614  			case RPCAP_MSG_AUTH_REQ:
615  			{
616  				rpcapd_log(LOGPRIO_INFO, "The client sent an RPCAP_MSG_AUTH_REQ message after authentication was completed");
617  				if (rpcap_senderror(pars.sockctrl, pars.ssl,
618  				    header.ver,
619  				    PCAP_ERR_WRONGMSG,
620  				    "RPCAP_MSG_AUTH_REQ request sent after authentication was completed",
621  				    errbuf) == -1)
622  				{
623  					rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
624  					goto end;
625  				}
626  				if (rpcapd_discard(pars.sockctrl, pars.ssl, plen) == -1)
627  				{
628  					goto end;
629  				}
630  				goto end;
631  			case RPCAP_MSG_PACKET:
632  			case RPCAP_MSG_FINDALLIF_REPLY:
633  			case RPCAP_MSG_OPEN_REPLY:
634  			case RPCAP_MSG_STARTCAP_REPLY:
635  			case RPCAP_MSG_UPDATEFILTER_REPLY:
636  			case RPCAP_MSG_AUTH_REPLY:
637  			case RPCAP_MSG_STATS_REPLY:
638  			case RPCAP_MSG_ENDCAP_REPLY:
639  			case RPCAP_MSG_SETSAMPLING_REPLY:
640  				msg_type_string = rpcap_msg_type_string(header.type);
641  				if (msg_type_string != NULL)
642  				{
643  					rpcapd_log(LOGPRIO_INFO, "The client sent a %s server-to-client message", msg_type_string);
644  					snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "Server-to-client message %s received from client", msg_type_string);
645  				}
646  				else
647  				{
648  					rpcapd_log(LOGPRIO_INFO, "The client sent a server-to-client message of type %u", header.type);
649  					snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "Server-to-client message of type %u received from client", header.type);
650  				}
651  				if (rpcap_senderror(pars.sockctrl, pars.ssl,
652  				    header.ver, PCAP_ERR_WRONGMSG,
653  				    errmsgbuf, errbuf) == -1)
654  				{
655  					rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
656  					goto end;
657  				}
658  				if (rpcapd_discard(pars.sockctrl, pars.ssl, plen) == -1)
659  				{
660  					goto end;
661  				}
662  				goto end;
663  			default:
664  				rpcapd_log(LOGPRIO_INFO, "The client sent a message of type %u", header.type);
665  				snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "Unknown message type %u", header.type);
666  				if (rpcap_senderror(pars.sockctrl, pars.ssl,
667  				    header.ver, PCAP_ERR_WRONGMSG,
668  				    errbuf, errmsgbuf) == -1)
669  				{
670  					rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
671  					goto end;
672  				}
673  				if (rpcapd_discard(pars.sockctrl, pars.ssl, plen) == -1)
674  				{
675  					goto end;
676  				}
677  				goto end;
678  			}
679  		}
680  	}
681  end:
682  	if (session)
683  	{
684  		session_close(session);
685  		free(session);
686  		session = NULL;
687  	}
688  	if (passiveClients) {
689  		free(passiveClients);
690  	}
691  #ifdef HAVE_OPENSSL
692  	if (ssl)
693  	{
694  		ssl_finish(ssl);
695  	}
696  #endif
697  	sock_close(sockctrl, NULL, 0);
698  	rpcapd_log(LOGPRIO_DEBUG, "I'm exiting from the child loop");
699  	return client_told_us_to_close;
700  }
701  static int
702  daemon_msg_err(SOCKET sockctrl, SSL *ssl, uint32_t plen)
703  {
704  	char errbuf[PCAP_ERRBUF_SIZE];
705  	char remote_errbuf[PCAP_ERRBUF_SIZE];
706  	if (plen >= PCAP_ERRBUF_SIZE)
707  	{
708  		if (sock_recv(sockctrl, ssl, remote_errbuf, PCAP_ERRBUF_SIZE - 1,
709  		    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf,
710  		    PCAP_ERRBUF_SIZE) == -1)
711  		{
712  			rpcapd_log(LOGPRIO_ERROR, "Read from client failed: %s", errbuf);
713  			return -1;
714  		}
715  		if (rpcapd_discard(sockctrl, ssl, plen - (PCAP_ERRBUF_SIZE - 1)) == -1)
716  		{
717  			return -1;
718  		}
719  		remote_errbuf[PCAP_ERRBUF_SIZE - 1] = '\0';
720  	}
721  	else if (plen == 0)
722  	{
723  		remote_errbuf[0] = '\0';
724  	}
725  	else
726  	{
727  		if (sock_recv(sockctrl, ssl, remote_errbuf, plen,
728  		    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf,
729  		    PCAP_ERRBUF_SIZE) == -1)
730  		{
731  			rpcapd_log(LOGPRIO_ERROR, "Read from client failed: %s", errbuf);
732  			return -1;
733  		}
734  		remote_errbuf[plen] = '\0';
735  	}
736  	rpcapd_log(LOGPRIO_ERROR, "Error from client: %s", remote_errbuf);
737  	return 0;
738  }
739  static int
740  daemon_msg_auth_req(struct daemon_slpars *pars, uint32_t plen)
741  {
742  	char errbuf[PCAP_ERRBUF_SIZE];		
743  	char errmsgbuf[PCAP_ERRBUF_SIZE];	
744  	int status;
745  	struct rpcap_auth auth;			
746  	char sendbuf[RPCAP_NETBUF_SIZE];	
747  	int sendbufidx = 0;			
748  	struct rpcap_authreply *authreply;	
749  	status = rpcapd_recv(pars->sockctrl, pars->ssl, (char *) &auth, sizeof(struct rpcap_auth), &plen, errmsgbuf);
750  	if (status == -1)
751  	{
752  		return -1;
753  	}
754  	if (status == -2)
755  	{
756  		goto error;
757  	}
758  	switch (ntohs(auth.type))
759  	{
760  		case RPCAP_RMTAUTH_NULL:
761  		{
762  			if (!pars->nullAuthAllowed)
763  			{
764  				snprintf(errmsgbuf, PCAP_ERRBUF_SIZE,
765  				    "Authentication failed; NULL authentication not permitted.");
766  				if (rpcap_senderror(pars->sockctrl, pars->ssl,
767  				    0, PCAP_ERR_AUTH_FAILED, errmsgbuf, errbuf) == -1)
768  				{
769  					rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
770  					return -1;
771  				}
772  				goto error_noreply;
773  			}
774  			break;
775  		}
776  		case RPCAP_RMTAUTH_PWD:
777  		{
778  			char *username, *passwd;
779  			uint32_t usernamelen, passwdlen;
780  			usernamelen = ntohs(auth.slen1);
781  			username = (char *) malloc (usernamelen + 1);
782  			if (username == NULL)
783  			{
784  				pcap_fmt_errmsg_for_errno(errmsgbuf,
785  				    PCAP_ERRBUF_SIZE, errno, "malloc() failed");
786  				goto error;
787  			}
788  			status = rpcapd_recv(pars->sockctrl, pars->ssl, username, usernamelen, &plen, errmsgbuf);
789  			if (status == -1)
790  			{
791  				free(username);
792  				return -1;
793  			}
794  			if (status == -2)
795  			{
796  				free(username);
797  				goto error;
798  			}
799  			username[usernamelen] = '\0';
800  			passwdlen = ntohs(auth.slen2);
801  			passwd = (char *) malloc (passwdlen + 1);
802  			if (passwd == NULL)
803  			{
804  				pcap_fmt_errmsg_for_errno(errmsgbuf,
805  				    PCAP_ERRBUF_SIZE, errno, "malloc() failed");
806  				free(username);
807  				goto error;
808  			}
809  			status = rpcapd_recv(pars->sockctrl, pars->ssl, passwd, passwdlen, &plen, errmsgbuf);
810  			if (status == -1)
811  			{
812  				free(username);
813  				free(passwd);
814  				return -1;
815  			}
816  			if (status == -2)
817  			{
818  				free(username);
819  				free(passwd);
820  				goto error;
821  			}
822  			passwd[passwdlen] = '\0';
823  			if (daemon_AuthUserPwd(username, passwd, errmsgbuf))
824  			{
825  				free(username);
826  				free(passwd);
827  				if (rpcap_senderror(pars->sockctrl, pars->ssl,
828  				    0, PCAP_ERR_AUTH_FAILED, errmsgbuf, errbuf) == -1)
829  				{
830  					rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
831  					return -1;
832  				}
833  				sleep_secs(RPCAP_SUSPEND_WRONGAUTH);
834  				goto error_noreply;
835  			}
836  			free(username);
837  			free(passwd);
838  			break;
839  			}
840  		default:
841  			snprintf(errmsgbuf, PCAP_ERRBUF_SIZE,
842  			    "Authentication type not recognized.");
843  			if (rpcap_senderror(pars->sockctrl, pars->ssl,
844  			    0, PCAP_ERR_AUTH_TYPE_NOTSUP, errmsgbuf, errbuf) == -1)
845  			{
846  				rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
847  				return -1;
848  			}
849  			goto error_noreply;
850  	}
851  	if (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,
852  	    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
853  		goto error;
854  	rpcap_createhdr((struct rpcap_header *) sendbuf, 0,
855  	    RPCAP_MSG_AUTH_REPLY, 0, sizeof(struct rpcap_authreply));
856  	authreply = (struct rpcap_authreply *) &sendbuf[sendbufidx];
857  	if (sock_bufferize(NULL, sizeof(struct rpcap_authreply), NULL, &sendbufidx,
858  	    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
859  		goto error;
860  	memset(authreply, 0, sizeof(struct rpcap_authreply));
861  	authreply->minvers = RPCAP_MIN_VERSION;
862  	authreply->maxvers = RPCAP_MAX_VERSION;
863  	authreply->byte_order_magic = RPCAP_BYTE_ORDER_MAGIC;
864  	if (sock_send(pars->sockctrl, pars->ssl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)
865  	{
866  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
867  		return -1;
868  	}
869  	if (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)
870  	{
871  		return -1;
872  	}
873  	return 0;
874  error:
875  	if (rpcap_senderror(pars->sockctrl, pars->ssl, 0, PCAP_ERR_AUTH,
876  	    errmsgbuf, errbuf) == -1)
877  	{
878  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
879  		return -1;
880  	}
881  error_noreply:
882  	if (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)
883  	{
884  		return -1;
885  	}
886  	return -2;
887  }
888  static int
889  daemon_AuthUserPwd(char *username, char *password, char *errbuf)
890  {
891  #ifdef _WIN32
892  	DWORD error;
893  	HANDLE Token;
894  	char errmsgbuf[PCAP_ERRBUF_SIZE];	
895  	if (LogonUser(username, ".", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)
896  	{
897  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "Authentication failed");
898  		error = GetLastError();
899  		if (error != ERROR_LOGON_FAILURE)
900  		{
901  			pcap_fmt_errmsg_for_win32_err(errmsgbuf,
902  			    PCAP_ERRBUF_SIZE, error, "LogonUser() failed");
903  			rpcapd_log(LOGPRIO_ERROR, "%s", errmsgbuf);
904  		}
905  		return -1;
906  	}
907  	if (ImpersonateLoggedOnUser(Token) == 0)
908  	{
909  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "Authentication failed");
910  		pcap_fmt_errmsg_for_win32_err(errmsgbuf, PCAP_ERRBUF_SIZE,
911  		    GetLastError(), "ImpersonateLoggedOnUser() failed");
912  		rpcapd_log(LOGPRIO_ERROR, "%s", errmsgbuf);
913  		CloseHandle(Token);
914  		return -1;
915  	}
916  	CloseHandle(Token);
917  	return 0;
918  #else
919  	int error;
920  	struct passwd *user;
921  	char *user_password;
922  #ifdef HAVE_GETSPNAM
923  	struct spwd *usersp;
924  #endif
925  	char *crypt_password;
926  	if ((user = getpwnam(username)) == NULL)
927  	{
928  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "Authentication failed");
929  		return -1;
930  	}
931  #ifdef HAVE_GETSPNAM
932  	if ((usersp = getspnam(username)) == NULL)
933  	{
934  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "Authentication failed");
935  		return -1;
936  	}
937  	user_password = usersp->sp_pwdp;
938  #else
939  	user_password = user->pw_passwd;
940  #endif
941  	errno = 0;
942  	crypt_password = crypt(password, user_password);
943  	if (crypt_password == NULL)
944  	{
945  		error = errno;
946  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "Authentication failed");
947  		if (error == 0)
948  		{
949  			rpcapd_log(LOGPRIO_ERROR, "crypt() failed");
950  		}
951  		else
952  		{
953  			rpcapd_log(LOGPRIO_ERROR, "crypt() failed: %s",
954  			    strerror(error));
955  		}
956  		return -1;
957  	}
958  	if (strcmp(user_password, crypt_password) != 0)
959  	{
960  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "Authentication failed");
961  		return -1;
962  	}
963  	if (setuid(user->pw_uid))
964  	{
965  		error = errno;
966  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
967  		    error, "setuid");
968  		rpcapd_log(LOGPRIO_ERROR, "setuid() failed: %s",
969  		    strerror(error));
970  		return -1;
971  	}
972  	return 0;
973  #endif
974  }
975  #define CHECK_AND_INCREASE_REPLY_LEN(itemlen) \
976  	if (replylen > UINT32_MAX - (itemlen)) { \
977  		pcap_strlcpy(errmsgbuf, "Reply length doesn't fit in 32 bits", \
978  		    sizeof (errmsgbuf)); \
979  		goto error; \
980  	} \
981  	replylen += (uint32_t)(itemlen)
982  static int
983  daemon_msg_findallif_req(uint8_t ver, struct daemon_slpars *pars, uint32_t plen)
984  {
985  	char errbuf[PCAP_ERRBUF_SIZE];		
986  	char errmsgbuf[PCAP_ERRBUF_SIZE];	
987  	char sendbuf[RPCAP_NETBUF_SIZE];	
988  	int sendbufidx = 0;			
989  	pcap_if_t *alldevs = NULL;		
990  	pcap_if_t *d;				
991  	struct pcap_addr *address;		
992  	uint32_t replylen;			
993  	uint16_t nif = 0;			
994  	if (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)
995  	{
996  		return -1;
997  	}
998  	if (pcap_findalldevs(&alldevs, errmsgbuf) == -1)
999  		goto error;
1000  	if (alldevs == NULL)
1001  	{
1002  		if (rpcap_senderror(pars->sockctrl, pars->ssl, ver,
1003  			PCAP_ERR_NOREMOTEIF,
1004  			"No interfaces found! Make sure libpcap/WinPcap is properly installed"
1005  			" and you have the right to access to the remote device.",
1006  			errbuf) == -1)
1007  		{
1008  			rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
1009  			return -1;
1010  		}
1011  		return 0;
1012  	}
1013  	replylen = 0;
1014  	for (d = alldevs; d != NULL; d = d->next)
1015  	{
1016  		nif++;
1017  		if (d->description) {
1018  			size_t stringlen = strlen(d->description);
1019  			if (stringlen > UINT16_MAX) {
1020  				pcap_strlcpy(errmsgbuf,
1021  				    "Description length doesn't fit in 16 bits",
1022  				    sizeof (errmsgbuf));
1023  				goto error;
1024  			}
1025  			CHECK_AND_INCREASE_REPLY_LEN(stringlen);
1026  		}
1027  		if (d->name) {
1028  			size_t stringlen = strlen(d->name);
1029  			if (stringlen > UINT16_MAX) {
1030  				pcap_strlcpy(errmsgbuf,
<span onclick='openModal()' class='match'>1031  				    "Name length doesn't fit in 16 bits",
1032  				    sizeof (errmsgbuf));
1033  				goto error;
1034  			}
1035  			CHECK_AND_INCREASE_REPLY_LEN(stringlen);
1036  		}
1037  		CHECK_AND_INCREASE_REPLY_LEN(sizeof(struct rpcap_findalldevs_if));
</span>1038  		uint16_t naddrs = 0;
1039  		for (address = d->addresses; address != NULL; address = address->next)
1040  		{
1041  			switch (address->addr->sa_family)
1042  			{
1043  			case AF_INET:
1044  #ifdef AF_INET6
1045  			case AF_INET6:
1046  #endif
1047  				CHECK_AND_INCREASE_REPLY_LEN(sizeof(struct rpcap_sockaddr) * 4);
1048  				if (naddrs == UINT16_MAX) {
1049  					pcap_strlcpy(errmsgbuf,
1050  					    "Number of interfaces doesn't fit in 16 bits",
1051  					    sizeof (errmsgbuf));
1052  					goto error;
1053  				}
1054  				naddrs++;
1055  				break;
1056  			default:
1057  				break;
1058  			}
1059  		}
1060  	}
1061  	if (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,
1062  	    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf,
1063  	    PCAP_ERRBUF_SIZE) == -1)
1064  		goto error;
1065  	rpcap_createhdr((struct rpcap_header *) sendbuf, ver,
1066  	    RPCAP_MSG_FINDALLIF_REPLY, nif, replylen);
1067  	for (d = alldevs; d != NULL; d = d->next)
1068  	{
1069  		uint16_t lname, ldescr;
1070  		struct rpcap_findalldevs_if findalldevs_if;
1071  		if (d->description)
1072  			ldescr = (uint16_t) strlen(d->description);
1073  		else
1074  			ldescr = 0;
1075  		if (d->name)
1076  			lname = (uint16_t) strlen(d->name);
1077  		else
1078  			lname = 0;
1079  		findalldevs_if.desclen = htons(ldescr);
1080  		findalldevs_if.namelen = htons(lname);
1081  		findalldevs_if.flags = htonl(d->flags);
1082  		uint16_t naddrs = 0;
1083  		for (address = d->addresses; address != NULL; address = address->next)
1084  		{
1085  			switch (address->addr->sa_family)
1086  			{
1087  			case AF_INET:
1088  #ifdef AF_INET6
1089  			case AF_INET6:
1090  #endif
1091  				naddrs++;
1092  				break;
1093  			default:
1094  				break;
1095  			}
1096  		}
1097  		findalldevs_if.naddr = htons(naddrs);
1098  		findalldevs_if.dummy = 0;
1099  		if (sock_bufferize(&findalldevs_if, sizeof(struct rpcap_findalldevs_if), sendbuf,
1100  		    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errmsgbuf,
1101  		    PCAP_ERRBUF_SIZE) == -1)
1102  			goto error;
1103  		if (sock_bufferize(d->name, lname, sendbuf, &sendbufidx,
1104  		    RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errmsgbuf,
1105  		    PCAP_ERRBUF_SIZE) == -1)
1106  			goto error;
1107  		if (sock_bufferize(d->description, ldescr, sendbuf, &sendbufidx,
1108  		    RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errmsgbuf,
1109  		    PCAP_ERRBUF_SIZE) == -1)
1110  			goto error;
1111  		for (address = d->addresses; address != NULL; address = address->next)
1112  		{
1113  			struct rpcap_sockaddr *sockaddr;
1114  			switch (address->addr->sa_family)
1115  			{
1116  			case AF_INET:
1117  #ifdef AF_INET6
1118  			case AF_INET6:
1119  #endif
1120  				sockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];
1121  				if (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,
1122  				    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1123  					goto error;
1124  				daemon_seraddr((struct sockaddr_storage *) address->addr, sockaddr);
1125  				sockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];
1126  				if (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,
1127  				    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1128  					goto error;
1129  				daemon_seraddr((struct sockaddr_storage *) address->netmask, sockaddr);
1130  				sockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];
1131  				if (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,
1132  				    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1133  					goto error;
1134  				daemon_seraddr((struct sockaddr_storage *) address->broadaddr, sockaddr);
1135  				sockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];
1136  				if (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,
1137  				    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1138  					goto error;
1139  				daemon_seraddr((struct sockaddr_storage *) address->dstaddr, sockaddr);
1140  				break;
1141  			default:
1142  				break;
1143  			}
1144  		}
1145  	}
1146  	pcap_freealldevs(alldevs);
1147  	if (sock_send(pars->sockctrl, pars->ssl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)
1148  	{
1149  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
1150  		return -1;
1151  	}
1152  	return 0;
1153  error:
1154  	if (alldevs)
1155  		pcap_freealldevs(alldevs);
1156  	if (rpcap_senderror(pars->sockctrl, pars->ssl, ver,
1157  	    PCAP_ERR_FINDALLIF, errmsgbuf, errbuf) == -1)
1158  	{
1159  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
1160  		return -1;
1161  	}
1162  	return 0;
1163  }
1164  static int
1165  daemon_msg_open_req(uint8_t ver, struct daemon_slpars *pars, uint32_t plen,
1166      char *source, size_t sourcelen)
1167  {
1168  	char errbuf[PCAP_ERRBUF_SIZE];		
1169  	char errmsgbuf[PCAP_ERRBUF_SIZE];	
1170  	pcap_t *fp;				
1171  	int nread;
1172  	char sendbuf[RPCAP_NETBUF_SIZE];	
1173  	int sendbufidx = 0;			
1174  	struct rpcap_openreply *openreply;	
1175  	if (plen > sourcelen - 1)
1176  	{
1177  		snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "Source string too long");
1178  		goto error;
1179  	}
1180  	nread = sock_recv(pars->sockctrl, pars->ssl, source, plen,
1181  	    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);
1182  	if (nread == -1)
1183  	{
1184  		rpcapd_log(LOGPRIO_ERROR, "Read from client failed: %s", errbuf);
1185  		return -1;
1186  	}
1187  	source[nread] = '\0';
1188  	plen -= nread;
1189  	if (is_url(source))
1190  	{
1191  		snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "Source string refers to a remote device");
1192  		goto error;
1193  	}
1194  	if ((fp = pcap_open_live(source,
1195  			1500 &bsol;* fake snaplen */,
1196  			0 &bsol;* no promisc */,
1197  			1000 &bsol;* fake timeout */,
1198  			errmsgbuf)) == NULL)
1199  		goto error;
1200  	if (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,
1201  	    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1202  		goto error;
1203  	rpcap_createhdr((struct rpcap_header *) sendbuf, ver,
1204  	    RPCAP_MSG_OPEN_REPLY, 0, sizeof(struct rpcap_openreply));
1205  	openreply = (struct rpcap_openreply *) &sendbuf[sendbufidx];
1206  	if (sock_bufferize(NULL, sizeof(struct rpcap_openreply), NULL, &sendbufidx,
1207  	    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1208  		goto error;
1209  	memset(openreply, 0, sizeof(struct rpcap_openreply));
1210  	openreply->linktype = htonl(pcap_datalink(fp));
1211  	openreply->tzoff = 0;
1212  	pcap_close(fp);
1213  	if (sock_send(pars->sockctrl, pars->ssl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)
1214  	{
1215  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
1216  		return -1;
1217  	}
1218  	return 0;
1219  error:
1220  	if (rpcap_senderror(pars->sockctrl, pars->ssl, ver, PCAP_ERR_OPEN,
1221  	    errmsgbuf, errbuf) == -1)
1222  	{
1223  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
1224  		return -1;
1225  	}
1226  	if (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)
1227  	{
1228  		return -1;
1229  	}
1230  	return 0;
1231  }
1232  static int
1233  daemon_msg_startcap_req(uint8_t ver, struct daemon_slpars *pars, uint32_t plen,
1234      char *source, char *data_port, struct session **sessionp,
1235      struct rpcap_sampling *samp_param _U_, int uses_ssl)
1236  {
1237  	char errbuf[PCAP_ERRBUF_SIZE];		
1238  	char errmsgbuf[PCAP_ERRBUF_SIZE];	
1239  	char portdata[PCAP_BUF_SIZE];		
1240  	char peerhost[PCAP_BUF_SIZE];		
1241  	struct session *session = NULL;		
1242  	int status;
1243  	char sendbuf[RPCAP_NETBUF_SIZE];	
1244  	int sendbufidx = 0;			
1245  	struct addrinfo hints;			
1246  	struct addrinfo *addrinfo;		
1247  	struct sockaddr_storage saddr;		
1248  	socklen_t saddrlen;			
1249  	int ret;				
1250  	struct rpcap_startcapreq startcapreq;		
1251  	struct rpcap_startcapreply *startcapreply;	
1252  	int serveropen_dp;							
1253  	addrinfo = NULL;
1254  	status = rpcapd_recv(pars->sockctrl, pars->ssl, (char *) &startcapreq,
1255  	    sizeof(struct rpcap_startcapreq), &plen, errmsgbuf);
1256  	if (status == -1)
1257  	{
1258  		goto fatal_error;
1259  	}
1260  	if (status == -2)
1261  	{
1262  		goto error;
1263  	}
1264  	startcapreq.flags = ntohs(startcapreq.flags);
1265  	if (uses_ssl && (startcapreq.flags & RPCAP_STARTCAPREQ_FLAG_DGRAM))
1266  	{
1267  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
1268  		    "SSL not supported with UDP forward of remote packets");
1269  		goto error;
1270  	}
1271  	session = malloc(sizeof(struct session));
1272  	if (session == NULL)
1273  	{
1274  		snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "Can't allocate session structure");
1275  		goto error;
1276  	}
1277  	session->sockdata = INVALID_SOCKET;
1278  	session->ctrl_ssl = session->data_ssl = NULL;
1279  	session->have_thread = 0;
1280  #ifdef _WIN32
1281  	session->thread = INVALID_HANDLE_VALUE;
1282  #else
1283  	memset(&session->thread, 0, sizeof(session->thread));
1284  #endif
1285  	if ((session->fp = pcap_open_live(source,
1286  			ntohl(startcapreq.snaplen),
1287  			(startcapreq.flags & RPCAP_STARTCAPREQ_FLAG_PROMISC) ? 1 : 0 &bsol;* local device, other flags not needed */,
1288  			ntohl(startcapreq.read_timeout),
1289  			errmsgbuf)) == NULL)
1290  		goto error;
1291  #if 0
1292  	fp->rmt_samp.method = samp_param->method;
1293  	fp->rmt_samp.value = samp_param->value;
1294  #endif
1295  	serveropen_dp = (startcapreq.flags & RPCAP_STARTCAPREQ_FLAG_SERVEROPEN) || (startcapreq.flags & RPCAP_STARTCAPREQ_FLAG_DGRAM) || pars->isactive;
1296  	saddrlen = sizeof(struct sockaddr_storage);
1297  	if (getpeername(pars->sockctrl, (struct sockaddr *) &saddr, &saddrlen) == -1)
1298  	{
1299  		sock_geterrmsg(errmsgbuf, PCAP_ERRBUF_SIZE,
1300  		    "getpeername() failed");
1301  		goto error;
1302  	}
1303  	memset(&hints, 0, sizeof(struct addrinfo));
1304  	hints.ai_socktype = (startcapreq.flags & RPCAP_STARTCAPREQ_FLAG_DGRAM) ? SOCK_DGRAM : SOCK_STREAM;
1305  	hints.ai_family = saddr.ss_family;
1306  	if (serveropen_dp)		
1307  	{
1308  		snprintf(portdata, sizeof portdata, "%d", ntohs(startcapreq.portdata));
1309  		if (getnameinfo((struct sockaddr *) &saddr, saddrlen, peerhost,
1310  				sizeof(peerhost), NULL, 0, NI_NUMERICHOST))
1311  		{
1312  			sock_geterrmsg(errmsgbuf, PCAP_ERRBUF_SIZE,
1313  			    "getnameinfo() failed");
1314  			goto error;
1315  		}
1316  		if (sock_initaddress(peerhost, portdata, &hints, &addrinfo, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1317  			goto error;
1318  		if ((session->sockdata = sock_open(peerhost, addrinfo, SOCKOPEN_CLIENT, 0, errmsgbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)
1319  			goto error;
1320  	}
1321  	else		
1322  	{
1323  		hints.ai_flags = AI_PASSIVE;
1324  		if (data_port[0] != '\0')
1325  		{
1326  			if (sock_initaddress(NULL, data_port, &hints, &addrinfo, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1327  				goto error;
1328  		}
1329  		else
1330  		{
1331  			if (sock_initaddress(NULL, NULL, &hints, &addrinfo, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1332  				goto error;
1333  		}
1334  		if ((session->sockdata = sock_open(NULL, addrinfo, SOCKOPEN_SERVER, 1 &bsol;* max 1 connection in queue */, errmsgbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)
1335  			goto error;
1336  		saddrlen = sizeof(struct sockaddr_storage);
1337  		if (getsockname(session->sockdata, (struct sockaddr *) &saddr, &saddrlen) == -1)
1338  		{
1339  			sock_geterrmsg(errmsgbuf, PCAP_ERRBUF_SIZE,
1340  			    "getsockname() failed");
1341  			goto error;
1342  		}
1343  		if (getnameinfo((struct sockaddr *) &saddr, saddrlen, NULL,
1344  				0, portdata, sizeof(portdata), NI_NUMERICSERV))
1345  		{
1346  			sock_geterrmsg(errmsgbuf, PCAP_ERRBUF_SIZE,
1347  			    "getnameinfo() failed");
1348  			goto error;
1349  		}
1350  	}
1351  	freeaddrinfo(addrinfo);
1352  	addrinfo = NULL;
1353  	session->sockctrl = pars->sockctrl;
1354  	session->ctrl_ssl = pars->ssl;
1355  	session->protocol_version = ver;
1356  	ret = daemon_unpackapplyfilter(pars->sockctrl, pars->ssl, session, &plen, errmsgbuf);
1357  	if (ret == -1)
1358  	{
1359  		goto fatal_error;
1360  	}
1361  	if (ret == -2)
1362  	{
1363  		goto error;
1364  	}
1365  	if (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,
1366  	    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1367  		goto error;
1368  	rpcap_createhdr((struct rpcap_header *) sendbuf, ver,
1369  	    RPCAP_MSG_STARTCAP_REPLY, 0, sizeof(struct rpcap_startcapreply));
1370  	startcapreply = (struct rpcap_startcapreply *) &sendbuf[sendbufidx];
1371  	if (sock_bufferize(NULL, sizeof(struct rpcap_startcapreply), NULL,
1372  	    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1373  		goto error;
1374  	memset(startcapreply, 0, sizeof(struct rpcap_startcapreply));
1375  	startcapreply->bufsize = htonl(pcap_bufsize(session->fp));
1376  	if (!serveropen_dp)
1377  	{
1378  		unsigned short port = (unsigned short)strtoul(portdata,NULL,10);
1379  		startcapreply->portdata = htons(port);
1380  	}
1381  	if (sock_send(pars->sockctrl, pars->ssl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)
1382  	{
1383  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
1384  		goto fatal_error;
1385  	}
1386  	if (!serveropen_dp)
1387  	{
1388  		SOCKET socktemp;	
1389  		saddrlen = sizeof(struct sockaddr_storage);
1390  		socktemp = accept(session->sockdata, (struct sockaddr *) &saddr, &saddrlen);
1391  		if (socktemp == INVALID_SOCKET)
1392  		{
1393  			sock_geterrmsg(errbuf, PCAP_ERRBUF_SIZE,
1394  			   "accept() failed");
1395  			rpcapd_log(LOGPRIO_ERROR, "Accept of data connection failed: %s",
1396  			    errbuf);
1397  			goto error;
1398  		}
1399  		sock_close(session->sockdata, NULL, 0);
1400  		session->sockdata = socktemp;
1401  	}
1402  	SSL *ssl = NULL;
1403  	if (uses_ssl)
1404  	{
1405  #ifdef HAVE_OPENSSL
1406  		ssl = ssl_promotion(1, session->sockdata, errbuf, PCAP_ERRBUF_SIZE);
1407  		if (! ssl)
1408  		{
1409  			rpcapd_log(LOGPRIO_ERROR, "TLS handshake failed: %s", errbuf);
1410  			goto error;
1411  		}
1412  #endif
1413  	}
1414  	session->data_ssl = ssl;
1415  #ifdef _WIN32
1416  	session->thread = (HANDLE)_beginthreadex(NULL, 0, daemon_thrdatamain,
1417  	    (void *) session, 0, NULL);
1418  	if (session->thread == 0)
1419  	{
1420  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "Error creating the data thread");
1421  		goto error;
1422  	}
1423  #else
1424  	ret = pthread_create(&session->thread, NULL, daemon_thrdatamain,
1425  	    (void *) session);
1426  	if (ret != 0)
1427  	{
1428  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
1429  		    ret, "Error creating the data thread");
1430  		goto error;
1431  	}
1432  #endif
1433  	session->have_thread = 1;
1434  	if (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)
1435  		goto fatal_error;
1436  	*sessionp = session;
1437  	return 0;
1438  error:
1439  	*sessionp = NULL;
1440  	if (addrinfo)
1441  		freeaddrinfo(addrinfo);
1442  	if (session)
1443  	{
1444  		session_close(session);
1445  		free(session);
1446  	}
1447  	if (rpcap_senderror(pars->sockctrl, pars->ssl, ver,
1448  	    PCAP_ERR_STARTCAPTURE, errmsgbuf, errbuf) == -1)
1449  	{
1450  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
1451  		return -1;
1452  	}
1453  	if (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)
1454  	{
1455  		return -1;
1456  	}
1457  	return 0;
1458  fatal_error:
1459  	*sessionp = NULL;
1460  	if (session)
1461  	{
1462  		session_close(session);
1463  		free(session);
1464  	}
1465  	return -1;
1466  }
1467  static int
1468  daemon_msg_endcap_req(uint8_t ver, struct daemon_slpars *pars,
1469      struct session *session)
1470  {
1471  	char errbuf[PCAP_ERRBUF_SIZE];		
1472  	struct rpcap_header header;
1473  	session_close(session);
1474  	rpcap_createhdr(&header, ver, RPCAP_MSG_ENDCAP_REPLY, 0, 0);
1475  	if (sock_send(pars->sockctrl, pars->ssl, (char *) &header, sizeof(struct rpcap_header), errbuf, PCAP_ERRBUF_SIZE) == -1)
1476  	{
1477  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
1478  		return -1;
1479  	}
1480  	return 0;
1481  }
1482  #define RPCAP_BPF_MAXINSNS	8192
1483  static int
1484  daemon_unpackapplyfilter(SOCKET sockctrl, SSL *ctrl_ssl, struct session *session, uint32_t *plenp, char *errmsgbuf)
1485  {
1486  	int status;
1487  	struct rpcap_filter filter;
1488  	struct rpcap_filterbpf_insn insn;
1489  	struct bpf_insn *bf_insn;
1490  	struct bpf_program bf_prog;
1491  	unsigned int i;
1492  	status = rpcapd_recv(sockctrl, ctrl_ssl, (char *) &filter,
1493  	    sizeof(struct rpcap_filter), plenp, errmsgbuf);
1494  	if (status == -1)
1495  	{
1496  		return -1;
1497  	}
1498  	if (status == -2)
1499  	{
1500  		return -2;
1501  	}
1502  	bf_prog.bf_len = ntohl(filter.nitems);
1503  	if (ntohs(filter.filtertype) != RPCAP_UPDATEFILTER_BPF)
1504  	{
1505  		snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "Only BPF/NPF filters are currently supported");
1506  		return -2;
1507  	}
1508  	if (bf_prog.bf_len > RPCAP_BPF_MAXINSNS)
1509  	{
1510  		snprintf(errmsgbuf, PCAP_ERRBUF_SIZE,
1511  		    "Filter program is larger than the maximum size of %d instructions",
1512  		    RPCAP_BPF_MAXINSNS);
1513  		return -2;
1514  	}
1515  	bf_insn = (struct bpf_insn *) malloc (sizeof(struct bpf_insn) * bf_prog.bf_len);
1516  	if (bf_insn == NULL)
1517  	{
1518  		pcap_fmt_errmsg_for_errno(errmsgbuf, PCAP_ERRBUF_SIZE,
1519  		    errno, "malloc() failed");
1520  		return -2;
1521  	}
1522  	bf_prog.bf_insns = bf_insn;
1523  	for (i = 0; i < bf_prog.bf_len; i++)
1524  	{
1525  		status = rpcapd_recv(sockctrl, ctrl_ssl, (char *) &insn,
1526  		    sizeof(struct rpcap_filterbpf_insn), plenp, errmsgbuf);
1527  		if (status == -1)
1528  		{
1529  			return -1;
1530  		}
1531  		if (status == -2)
1532  		{
1533  			return -2;
1534  		}
1535  		bf_insn->code = ntohs(insn.code);
1536  		bf_insn->jf = insn.jf;
1537  		bf_insn->jt = insn.jt;
1538  		bf_insn->k = ntohl(insn.k);
1539  		bf_insn++;
1540  	}
1541  	if (bpf_validate(bf_prog.bf_insns, bf_prog.bf_len) == 0)
1542  	{
1543  		snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "The filter contains bogus instructions");
1544  		return -2;
1545  	}
1546  	if (pcap_setfilter(session->fp, &bf_prog))
1547  	{
1548  		snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "RPCAP error: %s", pcap_geterr(session->fp));
1549  		return -2;
1550  	}
1551  	return 0;
1552  }
1553  static int
1554  daemon_msg_updatefilter_req(uint8_t ver, struct daemon_slpars *pars,
1555      struct session *session, uint32_t plen)
1556  {
1557  	char errbuf[PCAP_ERRBUF_SIZE];
1558  	char errmsgbuf[PCAP_ERRBUF_SIZE];	
1559  	int ret;				
1560  	struct rpcap_header header;		
1561  	ret = daemon_unpackapplyfilter(pars->sockctrl, pars->ssl, session, &plen, errmsgbuf);
1562  	if (ret == -1)
1563  	{
1564  		return -1;
1565  	}
1566  	if (ret == -2)
1567  	{
1568  		goto error;
1569  	}
1570  	if (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)
1571  	{
1572  		return -1;
1573  	}
1574  	rpcap_createhdr(&header, ver, RPCAP_MSG_UPDATEFILTER_REPLY, 0, 0);
1575  	if (sock_send(pars->sockctrl, pars->ssl, (char *) &header, sizeof (struct rpcap_header), errbuf, PCAP_ERRBUF_SIZE))
1576  	{
1577  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
1578  		return -1;
1579  	}
1580  	return 0;
1581  error:
1582  	if (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)
1583  	{
1584  		return -1;
1585  	}
1586  	rpcap_senderror(pars->sockctrl, pars->ssl, ver, PCAP_ERR_UPDATEFILTER,
1587  	    errmsgbuf, NULL);
1588  	return 0;
1589  }
1590  static int
1591  daemon_msg_setsampling_req(uint8_t ver, struct daemon_slpars *pars, uint32_t plen,
1592      struct rpcap_sampling *samp_param)
1593  {
1594  	char errbuf[PCAP_ERRBUF_SIZE];		
1595  	char errmsgbuf[PCAP_ERRBUF_SIZE];
1596  	struct rpcap_header header;
1597  	struct rpcap_sampling rpcap_samp;
1598  	int status;
1599  	status = rpcapd_recv(pars->sockctrl, pars->ssl, (char *) &rpcap_samp, sizeof(struct rpcap_sampling), &plen, errmsgbuf);
1600  	if (status == -1)
1601  	{
1602  		return -1;
1603  	}
1604  	if (status == -2)
1605  	{
1606  		goto error;
1607  	}
1608  	samp_param->method = rpcap_samp.method;
1609  	samp_param->value = ntohl(rpcap_samp.value);
1610  	rpcap_createhdr(&header, ver, RPCAP_MSG_SETSAMPLING_REPLY, 0, 0);
1611  	if (sock_send(pars->sockctrl, pars->ssl, (char *) &header, sizeof (struct rpcap_header), errbuf, PCAP_ERRBUF_SIZE) == -1)
1612  	{
1613  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
1614  		return -1;
1615  	}
1616  	if (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)
1617  	{
1618  		return -1;
1619  	}
1620  	return 0;
1621  error:
1622  	if (rpcap_senderror(pars->sockctrl, pars->ssl, ver, PCAP_ERR_SETSAMPLING,
1623  	    errmsgbuf, errbuf) == -1)
1624  	{
1625  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
1626  		return -1;
1627  	}
1628  	if (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)
1629  	{
1630  		return -1;
1631  	}
1632  	return 0;
1633  }
1634  static int
1635  daemon_msg_stats_req(uint8_t ver, struct daemon_slpars *pars,
1636      struct session *session, uint32_t plen, struct pcap_stat *stats,
1637      unsigned int svrcapt)
1638  {
1639  	char errbuf[PCAP_ERRBUF_SIZE];		
1640  	char errmsgbuf[PCAP_ERRBUF_SIZE];	
1641  	char sendbuf[RPCAP_NETBUF_SIZE];	
1642  	int sendbufidx = 0;			
1643  	struct rpcap_stats *netstats;		
1644  	if (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)
1645  	{
1646  		return -1;
1647  	}
1648  	if (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,
1649  	    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1650  		goto error;
1651  	rpcap_createhdr((struct rpcap_header *) sendbuf, ver,
1652  	    RPCAP_MSG_STATS_REPLY, 0, (uint16_t) sizeof(struct rpcap_stats));
1653  	netstats = (struct rpcap_stats *) &sendbuf[sendbufidx];
1654  	if (sock_bufferize(NULL, sizeof(struct rpcap_stats), NULL,
1655  	    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)
1656  		goto error;
1657  	if (session && session->fp)
1658  	{
1659  		if (pcap_stats(session->fp, stats) == -1)
1660  		{
1661  			snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "%s", pcap_geterr(session->fp));
1662  			goto error;
1663  		}
1664  		netstats->ifdrop = htonl(stats->ps_ifdrop);
1665  		netstats->ifrecv = htonl(stats->ps_recv);
1666  		netstats->krnldrop = htonl(stats->ps_drop);
1667  		netstats->svrcapt = htonl(session->TotCapt);
1668  	}
1669  	else
1670  	{
1671  		netstats->ifdrop = htonl(stats->ps_ifdrop);
1672  		netstats->ifrecv = htonl(stats->ps_recv);
1673  		netstats->krnldrop = htonl(stats->ps_drop);
1674  		netstats->svrcapt = htonl(svrcapt);
1675  	}
1676  	if (sock_send(pars->sockctrl, pars->ssl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)
1677  	{
1678  		rpcapd_log(LOGPRIO_ERROR, "Send to client failed: %s", errbuf);
1679  		return -1;
1680  	}
1681  	return 0;
1682  error:
1683  	rpcap_senderror(pars->sockctrl, pars->ssl, ver, PCAP_ERR_GETSTATS,
1684  	    errmsgbuf, NULL);
1685  	return 0;
1686  }
1687  #ifdef _WIN32
1688  static unsigned __stdcall
1689  #else
1690  static void *
1691  #endif
1692  daemon_thrdatamain(void *ptr)
1693  {
1694  	char errbuf[PCAP_ERRBUF_SIZE + 1];	
1695  	struct session *session;		
1696  	int retval;							
1697  	struct rpcap_pkthdr *net_pkt_header;
1698  	struct pcap_pkthdr *pkt_header;		
1699  	u_char *pkt_data;					
1700  	size_t sendbufsize;			
1701  	char *sendbuf;						
1702  	int sendbufidx;						
1703  	int status;
1704  #ifndef _WIN32
1705  	sigset_t sigusr1;			
1706  #endif
1707  	session = (struct session *) ptr;
1708  	session->TotCapt = 0;			
1709  	memset(errbuf, 0, sizeof(errbuf));
1710  	if (pcap_snapshot(session->fp) < 0)
1711  	{
1712  		rpcapd_log(LOGPRIO_ERROR,
1713  		    "Unable to allocate the buffer for this child thread: snapshot length of %d is negative",
1714  		        pcap_snapshot(session->fp));
1715  		sendbuf = NULL;	
1716  		goto error;
1717  	}
1718  	sendbufsize = sizeof(struct rpcap_header) + sizeof(struct rpcap_pkthdr) + pcap_snapshot(session->fp);
1719  	if (sendbufsize > INT_MAX)
1720  	{
1721  		rpcapd_log(LOGPRIO_ERROR,
1722  		    "Buffer size for this child thread would be larger than %d",
1723  		    INT_MAX);
1724  		sendbuf = NULL;	
1725  		goto error;
1726  	}
1727  	sendbuf = (char *) malloc (sendbufsize);
1728  	if (sendbuf == NULL)
1729  	{
1730  		rpcapd_log(LOGPRIO_ERROR,
1731  		    "Unable to allocate the buffer for this child thread");
1732  		goto error;
1733  	}
1734  #ifndef _WIN32
1735  	sigemptyset(&sigusr1);
1736  	sigaddset(&sigusr1, SIGUSR1);
1737  	pthread_sigmask(SIG_BLOCK, &sigusr1, NULL);
1738  #endif
1739  	for (;;)
1740  	{
1741  #ifndef _WIN32
1742  		pthread_sigmask(SIG_UNBLOCK, &sigusr1, NULL);
1743  #endif
1744  		retval = pcap_next_ex(session->fp, &pkt_header, (const u_char **) &pkt_data);	
1745  #ifndef _WIN32
1746  		pthread_sigmask(SIG_BLOCK, &sigusr1, NULL);
1747  #endif
1748  		if (retval < 0)
1749  			break;		
1750  		if (retval == 0)	
1751  			continue;
1752  		sendbufidx = 0;
1753  		if (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,
1754  		    &sendbufidx, (int)sendbufsize, SOCKBUF_CHECKONLY, errbuf,
1755  		    PCAP_ERRBUF_SIZE) == -1)
1756  		{
1757  			rpcapd_log(LOGPRIO_ERROR,
1758  			    "sock_bufferize() error sending packet message: %s",
1759  			    errbuf);
1760  			goto error;
1761  		}
1762  		rpcap_createhdr((struct rpcap_header *) sendbuf,
1763  		    session->protocol_version, RPCAP_MSG_PACKET, 0,
1764  		    (uint16_t) (sizeof(struct rpcap_pkthdr) + pkt_header->caplen));
1765  		net_pkt_header = (struct rpcap_pkthdr *) &sendbuf[sendbufidx];
1766  		if (sock_bufferize(NULL, sizeof(struct rpcap_pkthdr), NULL,
1767  		    &sendbufidx, (int)sendbufsize, SOCKBUF_CHECKONLY, errbuf,
1768  		    PCAP_ERRBUF_SIZE) == -1)
1769  		{
1770  			rpcapd_log(LOGPRIO_ERROR,
1771  			    "sock_bufferize() error sending packet message: %s",
1772  			    errbuf);
1773  			goto error;
1774  		}
1775  		net_pkt_header->caplen = htonl(pkt_header->caplen);
1776  		net_pkt_header->len = htonl(pkt_header->len);
1777  		net_pkt_header->npkt = htonl(++(session->TotCapt));
1778  		net_pkt_header->timestamp_sec = htonl((uint32_t)pkt_header->ts.tv_sec);
1779  		net_pkt_header->timestamp_usec = htonl((uint32_t)pkt_header->ts.tv_usec);
1780  		if (sock_bufferize((char *) pkt_data, pkt_header->caplen,
1781  		    sendbuf, &sendbufidx, (int)sendbufsize, SOCKBUF_BUFFERIZE,
1782  		    errbuf, PCAP_ERRBUF_SIZE) == -1)
1783  		{
1784  			rpcapd_log(LOGPRIO_ERROR,
1785  			    "sock_bufferize() error sending packet message: %s",
1786  			    errbuf);
1787  			goto error;
1788  		}
1789  		status = sock_send(session->sockdata, session->data_ssl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE);
1790  		if (status < 0)
1791  		{
1792  			if (status == -1)
1793  			{
1794  				rpcapd_log(LOGPRIO_ERROR,
1795  				    "Send of packet to client failed: %s",
1796  				    errbuf);
1797  			}
1798  			goto error;
1799  		}
1800  	}
1801  	if (retval < 0 && retval != PCAP_ERROR_BREAK)
1802  	{
1803  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "Error reading the packets: %s", pcap_geterr(session->fp));
1804  		rpcap_senderror(session->sockctrl, session->ctrl_ssl, session->protocol_version,
1805  		    PCAP_ERR_READEX, errbuf, NULL);
1806  	}
1807  error:
1808  	free(sendbuf);
1809  	return 0;
1810  }
1811  #ifndef _WIN32
1812  static void noop_handler(int sign _U_)
1813  {
1814  }
1815  #endif
1816  static void
1817  daemon_seraddr(struct sockaddr_storage *sockaddrin, struct rpcap_sockaddr *sockaddrout)
1818  {
1819  	memset(sockaddrout, 0, sizeof(struct sockaddr_storage));
1820  	if (sockaddrin == NULL) return;
1821  	switch (sockaddrin->ss_family)
1822  	{
1823  	case AF_INET:
1824  		{
1825  		struct sockaddr_in *sockaddrin_ipv4;
1826  		struct rpcap_sockaddr_in sockaddrout_ipv4;
1827  		sockaddrin_ipv4 = (struct sockaddr_in *) sockaddrin;
1828  		sockaddrout_ipv4.family = htons(RPCAP_AF_INET);
1829  		sockaddrout_ipv4.port = htons(sockaddrin_ipv4->sin_port);
1830  		memcpy(&sockaddrout_ipv4.addr, &sockaddrin_ipv4->sin_addr, sizeof(sockaddrout_ipv4.addr));
1831  		memset(sockaddrout_ipv4.zero, 0, sizeof(sockaddrout_ipv4.zero));
1832  		memcpy(sockaddrout, &sockaddrout_ipv4, sizeof(struct rpcap_sockaddr_in));
1833  		break;
1834  		}
1835  #ifdef AF_INET6
1836  	case AF_INET6:
1837  		{
1838  		struct sockaddr_in6 *sockaddrin_ipv6;
1839  		struct rpcap_sockaddr_in6 sockaddrout_ipv6;
1840  		sockaddrin_ipv6 = (struct sockaddr_in6 *) sockaddrin;
1841  		sockaddrout_ipv6.family = htons(RPCAP_AF_INET6);
1842  		sockaddrout_ipv6.port = htons(sockaddrin_ipv6->sin6_port);
1843  		sockaddrout_ipv6.flowinfo = htonl(sockaddrin_ipv6->sin6_flowinfo);
1844  		memcpy(&sockaddrout_ipv6.addr, &sockaddrin_ipv6->sin6_addr, sizeof(sockaddrout_ipv6.addr));
1845  		sockaddrout_ipv6.scope_id = htonl(sockaddrin_ipv6->sin6_scope_id);
1846  		memcpy(sockaddrout, &sockaddrout_ipv6, sizeof(struct rpcap_sockaddr_in6));
1847  		break;
1848  		}
1849  #endif
1850  	}
1851  }
1852  void sleep_secs(int secs)
1853  {
1854  #ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
1855  #ifdef _WIN32
1856  	Sleep(secs*1000);
1857  #else
1858  	unsigned secs_remaining;
1859  	if (secs <= 0)
1860  		return;
1861  	secs_remaining = secs;
1862  	while (secs_remaining != 0)
1863  		secs_remaining = sleep(secs_remaining);
1864  #endif
1865  #endif
1866  }
1867  static int
1868  rpcapd_recv_msg_header(SOCKET sock, SSL *ssl, struct rpcap_header *headerp)
1869  {
1870  	int nread;
1871  	char errbuf[PCAP_ERRBUF_SIZE];		
1872  	nread = sock_recv(sock, ssl, (char *) headerp, sizeof(struct rpcap_header),
1873  	    SOCK_RECEIVEALL_YES|SOCK_EOF_ISNT_ERROR, errbuf, PCAP_ERRBUF_SIZE);
1874  	if (nread == -1)
1875  	{
1876  		rpcapd_log(LOGPRIO_ERROR, "Read from client failed: %s", errbuf);
1877  		return -1;
1878  	}
1879  	if (nread == 0)
1880  	{
1881  		return -2;
1882  	}
1883  	headerp->plen = ntohl(headerp->plen);
1884  	return 0;
1885  }
1886  static int
1887  rpcapd_recv(SOCKET sock, SSL *ssl, char *buffer, size_t toread, uint32_t *plen, char *errmsgbuf)
1888  {
1889  	int nread;
1890  	char errbuf[PCAP_ERRBUF_SIZE];		
1891  	if (toread > *plen)
1892  	{
1893  		snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, "Message payload is too short");
1894  		return -2;
1895  	}
1896  	nread = sock_recv(sock, ssl, buffer, toread,
1897  	    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);
1898  	if (nread == -1)
1899  	{
1900  		rpcapd_log(LOGPRIO_ERROR, "Read from client failed: %s", errbuf);
1901  		return -1;
1902  	}
1903  	*plen -= nread;
1904  	return 0;
1905  }
1906  static int
1907  rpcapd_discard(SOCKET sock, SSL *ssl, uint32_t len)
1908  {
1909  	char errbuf[PCAP_ERRBUF_SIZE + 1];	
1910  	if (len != 0)
1911  	{
1912  		if (sock_discard(sock, ssl, len, errbuf, PCAP_ERRBUF_SIZE) == -1)
1913  		{
1914  			rpcapd_log(LOGPRIO_ERROR, "Read from client failed: %s", errbuf);
1915  			return -1;
1916  		}
1917  	}
1918  	return 0;
1919  }
1920  static void session_close(struct session *session)
1921  {
1922  	if (session->have_thread)
1923  	{
1924  		pcap_breakloop(session->fp);
1925  #ifdef _WIN32
1926  		SetEvent(pcap_getevent(session->fp));
1927  		WaitForSingleObject(session->thread, INFINITE);
1928  		CloseHandle(session->thread);
1929  		session->have_thread = 0;
1930  		session->thread = INVALID_HANDLE_VALUE;
1931  #else
1932  		pthread_kill(session->thread, SIGUSR1);
1933  		pthread_join(session->thread, NULL);
1934  		session->have_thread = 0;
1935  		memset(&session->thread, 0, sizeof(session->thread));
1936  #endif
1937  	}
1938  #ifdef HAVE_OPENSSL
1939  	if (session->data_ssl)
1940  	{
1941  		ssl_finish(session->data_ssl);
1942  		session->data_ssl = NULL;
1943  	}
1944  #endif
1945  	if (session->sockdata != INVALID_SOCKET)
1946  	{
1947  		sock_close(session->sockdata, NULL, 0);
1948  		session->sockdata = INVALID_SOCKET;
1949  	}
1950  	if (session->fp)
1951  	{
1952  		pcap_close(session->fp);
1953  		session->fp = NULL;
1954  	}
1955  }
1956  static int
1957  is_url(const char *source)
1958  {
1959  	char *colonp;
1960  	colonp = strchr(source, ':');
1961  	if (colonp == NULL)
1962  	{
1963  		return (0);
1964  	}
1965  	if (strncmp(colonp + 1, "&bsol;&bsol;", 2) != 0)
1966  	{
1967  		return (0);
1968  	}
1969  	return (1);
1970  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-daemon.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-daemon.c</div>
                </div>
                <div class="column column_space"><pre><code>1021  				    "Description length doesn't fit in 16 bits",
1022  				    sizeof (errmsgbuf));
1023  				goto error;
1024  			}
1025  			CHECK_AND_INCREASE_REPLY_LEN(stringlen);
1026  		}
1027  		if (d->name) {
</pre></code></div>
                <div class="column column_space"><pre><code>1031  				    "Name length doesn't fit in 16 bits",
1032  				    sizeof (errmsgbuf));
1033  				goto error;
1034  			}
1035  			CHECK_AND_INCREASE_REPLY_LEN(stringlen);
1036  		}
1037  		CHECK_AND_INCREASE_REPLY_LEN(sizeof(struct rpcap_findalldevs_if));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    