
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-lfs.c</h3>
            <pre><code>1  #include &quot;lfs.h&quot;
2  #include &quot;lfs_util.h&quot;
3  #include &lt;inttypes.h&gt;
4  static int lfs_cache_read(lfs_t *lfs, lfs_cache_t *rcache,
5          const lfs_cache_t *pcache, lfs_block_t block,
6          lfs_off_t off, void *buffer, lfs_size_t size) {
7      uint8_t *data = buffer;
8      LFS_ASSERT(block &lt; lfs-&gt;cfg-&gt;block_count);
9      while (size &gt; 0) {
10          if (pcache &amp;&amp; block == pcache-&gt;block &amp;&amp; off &gt;= pcache-&gt;off &amp;&amp;
11                  off &lt; pcache-&gt;off + lfs-&gt;cfg-&gt;prog_size) {
12              lfs_size_t diff = lfs_min(size,
13                      lfs-&gt;cfg-&gt;prog_size - (off-pcache-&gt;off));
14              memcpy(data, &amp;pcache-&gt;buffer[off-pcache-&gt;off], diff);
15              data += diff;
16              off += diff;
17              size -= diff;
18              continue;
19          }
20          if (block == rcache-&gt;block &amp;&amp; off &gt;= rcache-&gt;off &amp;&amp;
21                  off &lt; rcache-&gt;off + lfs-&gt;cfg-&gt;read_size) {
22              lfs_size_t diff = lfs_min(size,
23                      lfs-&gt;cfg-&gt;read_size - (off-rcache-&gt;off));
24              memcpy(data, &amp;rcache-&gt;buffer[off-rcache-&gt;off], diff);
25              data += diff;
26              off += diff;
27              size -= diff;
28              continue;
29          }
30          if (off % lfs-&gt;cfg-&gt;read_size == 0 &amp;&amp; size &gt;= lfs-&gt;cfg-&gt;read_size) {
31              lfs_size_t diff = size - (size % lfs-&gt;cfg-&gt;read_size);
32              int err = lfs-&gt;cfg-&gt;read(lfs-&gt;cfg, block, off, data, diff);
33              if (err) {
34                  return err;
35              }
36              data += diff;
37              off += diff;
38              size -= diff;
39              continue;
40          }
41          rcache-&gt;block = block;
42          rcache-&gt;off = off - (off % lfs-&gt;cfg-&gt;read_size);
43          int err = lfs-&gt;cfg-&gt;read(lfs-&gt;cfg, rcache-&gt;block,
44                  rcache-&gt;off, rcache-&gt;buffer, lfs-&gt;cfg-&gt;read_size);
45          if (err) {
46              return err;
47          }
48      }
49      return 0;
50  }
51  static int lfs_cache_cmp(lfs_t *lfs, lfs_cache_t *rcache,
52          const lfs_cache_t *pcache, lfs_block_t block,
53          lfs_off_t off, const void *buffer, lfs_size_t size) {
54      const uint8_t *data = buffer;
55      for (lfs_off_t i = 0; i &lt; size; i++) {
56          uint8_t c;
57          int err = lfs_cache_read(lfs, rcache, pcache,
58                  block, off+i, &amp;c, 1);
59          if (err) {
60              return err;
61          }
62          if (c != data[i]) {
63              return false;
64          }
65      }
66      return true;
67  }
68  static int lfs_cache_crc(lfs_t *lfs, lfs_cache_t *rcache,
69          const lfs_cache_t *pcache, lfs_block_t block,
70          lfs_off_t off, lfs_size_t size, uint32_t *crc) {
71      for (lfs_off_t i = 0; i &lt; size; i++) {
72          uint8_t c;
73          int err = lfs_cache_read(lfs, rcache, pcache,
74                  block, off+i, &amp;c, 1);
75          if (err) {
76              return err;
77          }
78          lfs_crc(crc, &amp;c, 1);
79      }
80      return 0;
81  }
82  static inline void lfs_cache_drop(lfs_t *lfs, lfs_cache_t *rcache) {
83      (void)lfs;
84      rcache-&gt;block = 0xffffffff;
85  }
86  static inline void lfs_cache_zero(lfs_t *lfs, lfs_cache_t *pcache) {
87      memset(pcache-&gt;buffer, 0xff, lfs-&gt;cfg-&gt;prog_size);
88      pcache-&gt;block = 0xffffffff;
89  }
90  static int lfs_cache_flush(lfs_t *lfs,
91          lfs_cache_t *pcache, lfs_cache_t *rcache) {
92      if (pcache-&gt;block != 0xffffffff) {
93          int err = lfs-&gt;cfg-&gt;prog(lfs-&gt;cfg, pcache-&gt;block,
94                  pcache-&gt;off, pcache-&gt;buffer, lfs-&gt;cfg-&gt;prog_size);
95          if (err) {
96              return err;
97          }
98          if (rcache) {
99              int res = lfs_cache_cmp(lfs, rcache, NULL, pcache-&gt;block,
100                      pcache-&gt;off, pcache-&gt;buffer, lfs-&gt;cfg-&gt;prog_size);
101              if (res &lt; 0) {
102                  return res;
103              }
104              if (!res) {
105                  return LFS_ERR_CORRUPT;
106              }
107          }
108          lfs_cache_zero(lfs, pcache);
109      }
110      return 0;
111  }
112  static int lfs_cache_prog(lfs_t *lfs, lfs_cache_t *pcache,
113          lfs_cache_t *rcache, lfs_block_t block,
114          lfs_off_t off, const void *buffer, lfs_size_t size) {
115      const uint8_t *data = buffer;
116      LFS_ASSERT(block &lt; lfs-&gt;cfg-&gt;block_count);
117      while (size &gt; 0) {
118          if (block == pcache-&gt;block &amp;&amp; off &gt;= pcache-&gt;off &amp;&amp;
119                  off &lt; pcache-&gt;off + lfs-&gt;cfg-&gt;prog_size) {
120              lfs_size_t diff = lfs_min(size,
121                      lfs-&gt;cfg-&gt;prog_size - (off-pcache-&gt;off));
122              memcpy(&amp;pcache-&gt;buffer[off-pcache-&gt;off], data, diff);
123              data += diff;
124              off += diff;
125              size -= diff;
126              if (off % lfs-&gt;cfg-&gt;prog_size == 0) {
127                  int err = lfs_cache_flush(lfs, pcache, rcache);
128                  if (err) {
129                      return err;
130                  }
131              }
132              continue;
133          }
134          LFS_ASSERT(pcache-&gt;block == 0xffffffff);
135          if (off % lfs-&gt;cfg-&gt;prog_size == 0 &amp;&amp;
136                  size &gt;= lfs-&gt;cfg-&gt;prog_size) {
137              lfs_size_t diff = size - (size % lfs-&gt;cfg-&gt;prog_size);
138              int err = lfs-&gt;cfg-&gt;prog(lfs-&gt;cfg, block, off, data, diff);
139              if (err) {
140                  return err;
141              }
142              if (rcache) {
143                  int res = lfs_cache_cmp(lfs, rcache, NULL,
144                          block, off, data, diff);
145                  if (res &lt; 0) {
146                      return res;
147                  }
148                  if (!res) {
149                      return LFS_ERR_CORRUPT;
150                  }
151              }
152              data += diff;
153              off += diff;
154              size -= diff;
155              continue;
156          }
157          pcache-&gt;block = block;
158          pcache-&gt;off = off - (off % lfs-&gt;cfg-&gt;prog_size);
159      }
160      return 0;
161  }
162  static int lfs_bd_read(lfs_t *lfs, lfs_block_t block,
163          lfs_off_t off, void *buffer, lfs_size_t size) {
164      return lfs_cache_read(lfs, &amp;lfs-&gt;rcache, NULL,
165              block, off, buffer, size);
166  }
167  static int lfs_bd_prog(lfs_t *lfs, lfs_block_t block,
168          lfs_off_t off, const void *buffer, lfs_size_t size) {
169      return lfs_cache_prog(lfs, &amp;lfs-&gt;pcache, NULL,
170              block, off, buffer, size);
171  }
172  static int lfs_bd_cmp(lfs_t *lfs, lfs_block_t block,
173          lfs_off_t off, const void *buffer, lfs_size_t size) {
174      return lfs_cache_cmp(lfs, &amp;lfs-&gt;rcache, NULL, block, off, buffer, size);
175  }
176  static int lfs_bd_crc(lfs_t *lfs, lfs_block_t block,
177          lfs_off_t off, lfs_size_t size, uint32_t *crc) {
178      return lfs_cache_crc(lfs, &amp;lfs-&gt;rcache, NULL, block, off, size, crc);
179  }
180  static int lfs_bd_erase(lfs_t *lfs, lfs_block_t block) {
181      return lfs-&gt;cfg-&gt;erase(lfs-&gt;cfg, block);
182  }
183  static int lfs_bd_sync(lfs_t *lfs) {
184      lfs_cache_drop(lfs, &amp;lfs-&gt;rcache);
185      int err = lfs_cache_flush(lfs, &amp;lfs-&gt;pcache, NULL);
186      if (err) {
187          return err;
188      }
189      return lfs-&gt;cfg-&gt;sync(lfs-&gt;cfg);
190  }
191  int lfs_traverse(lfs_t *lfs, int (*cb)(void*, lfs_block_t), void *data);
192  static int lfs_pred(lfs_t *lfs, const lfs_block_t dir[2], lfs_dir_t *pdir);
193  static int lfs_parent(lfs_t *lfs, const lfs_block_t dir[2],
194          lfs_dir_t *parent, lfs_entry_t *entry);
195  static int lfs_moved(lfs_t *lfs, const void *e);
196  static int lfs_relocate(lfs_t *lfs,
197          const lfs_block_t oldpair[2], const lfs_block_t newpair[2]);
198  int lfs_deorphan(lfs_t *lfs);
199  static int lfs_alloc_lookahead(void *p, lfs_block_t block) {
200      lfs_t *lfs = p;
201      lfs_block_t off = ((block - lfs-&gt;free.off)
202              + lfs-&gt;cfg-&gt;block_count) % lfs-&gt;cfg-&gt;block_count;
203      if (off &lt; lfs-&gt;free.size) {
204          lfs-&gt;free.buffer[off / 32] |= 1U &lt;&lt; (off % 32);
205      }
206      return 0;
207  }
208  static int lfs_alloc(lfs_t *lfs, lfs_block_t *block) {
209      while (true) {
210          while (lfs-&gt;free.i != lfs-&gt;free.size) {
211              lfs_block_t off = lfs-&gt;free.i;
212              lfs-&gt;free.i += 1;
213              lfs-&gt;free.ack -= 1;
214              if (!(lfs-&gt;free.buffer[off / 32] &amp; (1U &lt;&lt; (off % 32)))) {
215                  *block = (lfs-&gt;free.off + off) % lfs-&gt;cfg-&gt;block_count;
216                  while (lfs-&gt;free.i != lfs-&gt;free.size &amp;&amp;
217                          (lfs-&gt;free.buffer[lfs-&gt;free.i / 32]
218                              &amp; (1U &lt;&lt; (lfs-&gt;free.i % 32)))) {
219                      lfs-&gt;free.i += 1;
220                      lfs-&gt;free.ack -= 1;
221                  }
222                  return 0;
223              }
224          }
225          if (lfs-&gt;free.ack == 0) {
226              LFS_WARN(&quot;No more free space %&quot; PRIu32,
227                      lfs-&gt;free.i + lfs-&gt;free.off);
228              return LFS_ERR_NOSPC;
229          }
230          lfs-&gt;free.off = (lfs-&gt;free.off + lfs-&gt;free.size)
231                  % lfs-&gt;cfg-&gt;block_count;
232          lfs-&gt;free.size = lfs_min(lfs-&gt;cfg-&gt;lookahead, lfs-&gt;free.ack);
233          lfs-&gt;free.i = 0;
234          memset(lfs-&gt;free.buffer, 0, lfs-&gt;cfg-&gt;lookahead/8);
235          int err = lfs_traverse(lfs, lfs_alloc_lookahead, lfs);
236          if (err) {
237              return err;
238          }
239      }
240  }
241  static void lfs_alloc_ack(lfs_t *lfs) {
242      lfs-&gt;free.ack = lfs-&gt;cfg-&gt;block_count;
243  }
244  static void lfs_dir_fromle32(struct lfs_disk_dir *d) {
245      d-&gt;rev     = lfs_fromle32(d-&gt;rev);
246      d-&gt;size    = lfs_fromle32(d-&gt;size);
247      d-&gt;tail[0] = lfs_fromle32(d-&gt;tail[0]);
248      d-&gt;tail[1] = lfs_fromle32(d-&gt;tail[1]);
249  }
250  static void lfs_dir_tole32(struct lfs_disk_dir *d) {
251      d-&gt;rev     = lfs_tole32(d-&gt;rev);
252      d-&gt;size    = lfs_tole32(d-&gt;size);
253      d-&gt;tail[0] = lfs_tole32(d-&gt;tail[0]);
254      d-&gt;tail[1] = lfs_tole32(d-&gt;tail[1]);
255  }
256  static void lfs_entry_fromle32(struct lfs_disk_entry *d) {
257      d-&gt;u.dir[0] = lfs_fromle32(d-&gt;u.dir[0]);
258      d-&gt;u.dir[1] = lfs_fromle32(d-&gt;u.dir[1]);
259  }
260  static void lfs_entry_tole32(struct lfs_disk_entry *d) {
261      d-&gt;u.dir[0] = lfs_tole32(d-&gt;u.dir[0]);
262      d-&gt;u.dir[1] = lfs_tole32(d-&gt;u.dir[1]);
263  }
264  static void lfs_superblock_fromle32(struct lfs_disk_superblock *d) {
265      d-&gt;root[0]     = lfs_fromle32(d-&gt;root[0]);
266      d-&gt;root[1]     = lfs_fromle32(d-&gt;root[1]);
267      d-&gt;block_size  = lfs_fromle32(d-&gt;block_size);
268      d-&gt;block_count = lfs_fromle32(d-&gt;block_count);
269      d-&gt;version     = lfs_fromle32(d-&gt;version);
270  }
271  static void lfs_superblock_tole32(struct lfs_disk_superblock *d) {
272      d-&gt;root[0]     = lfs_tole32(d-&gt;root[0]);
273      d-&gt;root[1]     = lfs_tole32(d-&gt;root[1]);
274      d-&gt;block_size  = lfs_tole32(d-&gt;block_size);
275      d-&gt;block_count = lfs_tole32(d-&gt;block_count);
276      d-&gt;version     = lfs_tole32(d-&gt;version);
277  }
278  static inline void lfs_pairswap(lfs_block_t pair[2]) {
279      lfs_block_t t = pair[0];
280      pair[0] = pair[1];
281      pair[1] = t;
282  }
283  static inline bool lfs_pairisnull(const lfs_block_t pair[2]) {
284      return pair[0] == 0xffffffff || pair[1] == 0xffffffff;
285  }
286  static inline int lfs_paircmp(
287          const lfs_block_t paira[2],
288          const lfs_block_t pairb[2]) {
289      return !(paira[0] == pairb[0] || paira[1] == pairb[1] ||
290               paira[0] == pairb[1] || paira[1] == pairb[0]);
291  }
292  static inline bool lfs_pairsync(
293          const lfs_block_t paira[2],
294          const lfs_block_t pairb[2]) {
295      return (paira[0] == pairb[0] &amp;&amp; paira[1] == pairb[1]) ||
296             (paira[0] == pairb[1] &amp;&amp; paira[1] == pairb[0]);
297  }
298  static inline lfs_size_t lfs_entry_size(const lfs_entry_t *entry) {
299      return 4 + entry-&gt;d.elen + entry-&gt;d.alen + entry-&gt;d.nlen;
300  }
301  static int lfs_dir_alloc(lfs_t *lfs, lfs_dir_t *dir) {
302      for (int i = 0; i &lt; 2; i++) {
303          int err = lfs_alloc(lfs, &amp;dir-&gt;pair[i]);
304          if (err) {
305              return err;
306          }
307      }
308      int err = lfs_bd_read(lfs, dir-&gt;pair[0], 0, &amp;dir-&gt;d.rev, 4);
309      if (err &amp;&amp; err != LFS_ERR_CORRUPT) {
310          return err;
311      }
312      if (err != LFS_ERR_CORRUPT) {
313          dir-&gt;d.rev = lfs_fromle32(dir-&gt;d.rev);
314      }
315      dir-&gt;d.rev += 1;
316      dir-&gt;d.size = sizeof(dir-&gt;d)+4;
317      dir-&gt;d.tail[0] = 0xffffffff;
318      dir-&gt;d.tail[1] = 0xffffffff;
319      dir-&gt;off = sizeof(dir-&gt;d);
320      return 0;
321  }
322  static int lfs_dir_fetch(lfs_t *lfs,
323          lfs_dir_t *dir, const lfs_block_t pair[2]) {
324      const lfs_block_t tpair[2] = {pair[0], pair[1]};
325      bool valid = false;
326      for (int i = 0; i &lt; 2; i++) {
327          struct lfs_disk_dir test;
328          int err = lfs_bd_read(lfs, tpair[i], 0, &amp;test, sizeof(test));
329          lfs_dir_fromle32(&amp;test);
330          if (err) {
331              if (err == LFS_ERR_CORRUPT) {
332                  continue;
333              }
334              return err;
335          }
336          if (valid &amp;&amp; lfs_scmp(test.rev, dir-&gt;d.rev) &lt; 0) {
337              continue;
338          }
339          if ((0x7fffffff &amp; test.size) &lt; sizeof(test)+4 ||
340              (0x7fffffff &amp; test.size) &gt; lfs-&gt;cfg-&gt;block_size) {
341              continue;
342          }
343          uint32_t crc = 0xffffffff;
344          lfs_dir_tole32(&amp;test);
345          lfs_crc(&amp;crc, &amp;test, sizeof(test));
346          lfs_dir_fromle32(&amp;test);
347          err = lfs_bd_crc(lfs, tpair[i], sizeof(test),
348                  (0x7fffffff &amp; test.size) - sizeof(test), &amp;crc);
349          if (err) {
350              if (err == LFS_ERR_CORRUPT) {
351                  continue;
352              }
353              return err;
354          }
355          if (crc != 0) {
356              continue;
357          }
358          valid = true;
359          dir-&gt;pair[0] = tpair[(i+0) % 2];
360          dir-&gt;pair[1] = tpair[(i+1) % 2];
361          dir-&gt;off = sizeof(dir-&gt;d);
362          dir-&gt;d = test;
363      }
364      if (!valid) {
365          LFS_ERROR(&quot;Corrupted dir pair at %&quot; PRIu32 &quot; %&quot; PRIu32 ,
366                  tpair[0], tpair[1]);
367          return LFS_ERR_CORRUPT;
368      }
369      return 0;
370  }
371  struct lfs_region {
372      lfs_off_t oldoff;
373      lfs_size_t oldlen;
374      const void *newdata;
375      lfs_size_t newlen;
376  };
377  static int lfs_dir_commit(lfs_t *lfs, lfs_dir_t *dir,
378          const struct lfs_region *regions, int count) {
379      dir-&gt;d.rev += 1;
380      lfs_pairswap(dir-&gt;pair);
381      for (int i = 0; i &lt; count; i++) {
382          dir-&gt;d.size += regions[i].newlen - regions[i].oldlen;
383      }
384      const lfs_block_t oldpair[2] = {dir-&gt;pair[0], dir-&gt;pair[1]};
385      bool relocated = false;
386      while (true) {
387          if (true) {
388              int err = lfs_bd_erase(lfs, dir-&gt;pair[0]);
389              if (err) {
390                  if (err == LFS_ERR_CORRUPT) {
391                      goto relocate;
392                  }
393                  return err;
394              }
395              uint32_t crc = 0xffffffff;
396              lfs_dir_tole32(&amp;dir-&gt;d);
397              lfs_crc(&amp;crc, &amp;dir-&gt;d, sizeof(dir-&gt;d));
398              err = lfs_bd_prog(lfs, dir-&gt;pair[0], 0, &amp;dir-&gt;d, sizeof(dir-&gt;d));
399              lfs_dir_fromle32(&amp;dir-&gt;d);
400              if (err) {
401                  if (err == LFS_ERR_CORRUPT) {
402                      goto relocate;
403                  }
404                  return err;
405              }
406              int i = 0;
407              lfs_off_t oldoff = sizeof(dir-&gt;d);
408              lfs_off_t newoff = sizeof(dir-&gt;d);
409              while (newoff &lt; (0x7fffffff &amp; dir-&gt;d.size)-4) {
410                  if (i &lt; count &amp;&amp; regions[i].oldoff == oldoff) {
411                      lfs_crc(&amp;crc, regions[i].newdata, regions[i].newlen);
412                      err = lfs_bd_prog(lfs, dir-&gt;pair[0],
413                              newoff, regions[i].newdata, regions[i].newlen);
414                      if (err) {
415                          if (err == LFS_ERR_CORRUPT) {
416                              goto relocate;
417                          }
418                          return err;
419                      }
420                      oldoff += regions[i].oldlen;
421                      newoff += regions[i].newlen;
422                      i += 1;
423                  } else {
424                      uint8_t data;
425                      err = lfs_bd_read(lfs, oldpair[1], oldoff, &amp;data, 1);
426                      if (err) {
427                          return err;
428                      }
429                      lfs_crc(&amp;crc, &amp;data, 1);
430                      err = lfs_bd_prog(lfs, dir-&gt;pair[0], newoff, &amp;data, 1);
431                      if (err) {
432                          if (err == LFS_ERR_CORRUPT) {
433                              goto relocate;
434                          }
435                          return err;
436                      }
437                      oldoff += 1;
438                      newoff += 1;
439                  }
440              }
441              crc = lfs_tole32(crc);
442              err = lfs_bd_prog(lfs, dir-&gt;pair[0], newoff, &amp;crc, 4);
443              crc = lfs_fromle32(crc);
444              if (err) {
445                  if (err == LFS_ERR_CORRUPT) {
446                      goto relocate;
447                  }
448                  return err;
449              }
450              err = lfs_bd_sync(lfs);
451              if (err) {
452                  if (err == LFS_ERR_CORRUPT) {
453                      goto relocate;
454                  }
455                  return err;
456              }
457              uint32_t ncrc = 0xffffffff;
458              err = lfs_bd_crc(lfs, dir-&gt;pair[0], 0,
459                      (0x7fffffff &amp; dir-&gt;d.size)-4, &amp;ncrc);
460              if (err) {
461                  return err;
462              }
463              if (ncrc != crc) {
464                  goto relocate;
465              }
466          }
467          break;
468  relocate:
469          LFS_DEBUG(&quot;Bad block at %&quot; PRIu32, dir-&gt;pair[0]);
470          relocated = true;
471          lfs_cache_drop(lfs, &amp;lfs-&gt;pcache);
472          if (lfs_paircmp(oldpair, (const lfs_block_t[2]){0, 1}) == 0) {
473              LFS_WARN(&quot;Superblock %&quot; PRIu32 &quot; has become unwritable&quot;,
474                      oldpair[0]);
475              return LFS_ERR_CORRUPT;
476          }
477          int err = lfs_alloc(lfs, &amp;dir-&gt;pair[0]);
478          if (err) {
479              return err;
480          }
481      }
482      if (relocated) {
483          LFS_DEBUG(&quot;Relocating %&quot; PRIu32 &quot; %&quot; PRIu32 &quot; to %&quot; PRIu32 &quot; %&quot; PRIu32,
484                  oldpair[0], oldpair[1], dir-&gt;pair[0], dir-&gt;pair[1]);
485          int err = lfs_relocate(lfs, oldpair, dir-&gt;pair);
486          if (err) {
487              return err;
488          }
489      }
490      for (lfs_dir_t *d = lfs-&gt;dirs; d; d = d-&gt;next) {
491          if (lfs_paircmp(d-&gt;pair, dir-&gt;pair) == 0) {
492              d-&gt;pair[0] = dir-&gt;pair[0];
493              d-&gt;pair[1] = dir-&gt;pair[1];
494          }
495      }
496      return 0;
497  }
498  static int lfs_dir_update(lfs_t *lfs, lfs_dir_t *dir,
499          lfs_entry_t *entry, const void *data) {
500      lfs_entry_tole32(&amp;entry-&gt;d);
501      int err = lfs_dir_commit(lfs, dir, (struct lfs_region[]){
502              {entry-&gt;off, sizeof(entry-&gt;d), &amp;entry-&gt;d, sizeof(entry-&gt;d)},
503              {entry-&gt;off+sizeof(entry-&gt;d), entry-&gt;d.nlen, data, entry-&gt;d.nlen}
504          }, data ? 2 : 1);
505      lfs_entry_fromle32(&amp;entry-&gt;d);
506      return err;
507  }
508  static int lfs_dir_append(lfs_t *lfs, lfs_dir_t *dir,
509          lfs_entry_t *entry, const void *data) {
510      while (true) {
511          if (dir-&gt;d.size + lfs_entry_size(entry) &lt;= lfs-&gt;cfg-&gt;block_size) {
<span onclick='openModal()' class='match'>512              entry-&gt;off = dir-&gt;d.size - 4;
513              lfs_entry_tole32(&amp;entry-&gt;d);
514              int err = lfs_dir_commit(lfs, dir, (struct lfs_region[]){
</span>515                      {entry-&gt;off, 0, &amp;entry-&gt;d, sizeof(entry-&gt;d)},
516                      {entry-&gt;off, 0, data, entry-&gt;d.nlen}
517                  }, 2);
518              lfs_entry_fromle32(&amp;entry-&gt;d);
519              return err;
520          }
521          if (!(0x80000000 &amp; dir-&gt;d.size)) {
522              lfs_dir_t olddir = *dir;
523              int err = lfs_dir_alloc(lfs, dir);
524              if (err) {
525                  return err;
526              }
527              dir-&gt;d.tail[0] = olddir.d.tail[0];
528              dir-&gt;d.tail[1] = olddir.d.tail[1];
529              entry-&gt;off = dir-&gt;d.size - 4;
530              lfs_entry_tole32(&amp;entry-&gt;d);
531              err = lfs_dir_commit(lfs, dir, (struct lfs_region[]){
532                      {entry-&gt;off, 0, &amp;entry-&gt;d, sizeof(entry-&gt;d)},
533                      {entry-&gt;off, 0, data, entry-&gt;d.nlen}
534                  }, 2);
535              lfs_entry_fromle32(&amp;entry-&gt;d);
536              if (err) {
537                  return err;
538              }
539              olddir.d.size |= 0x80000000;
540              olddir.d.tail[0] = dir-&gt;pair[0];
541              olddir.d.tail[1] = dir-&gt;pair[1];
542              return lfs_dir_commit(lfs, &amp;olddir, NULL, 0);
543          }
544          int err = lfs_dir_fetch(lfs, dir, dir-&gt;d.tail);
545          if (err) {
546              return err;
547          }
548      }
549  }
550  static int lfs_dir_remove(lfs_t *lfs, lfs_dir_t *dir, lfs_entry_t *entry) {
551      if ((dir-&gt;d.size &amp; 0x7fffffff) == sizeof(dir-&gt;d)+4
552              + lfs_entry_size(entry)) {
553          lfs_dir_t pdir;
554          int res = lfs_pred(lfs, dir-&gt;pair, &amp;pdir);
555          if (res &lt; 0) {
556              return res;
557          }
558          if (pdir.d.size &amp; 0x80000000) {
559              pdir.d.size &amp;= dir-&gt;d.size | 0x7fffffff;
560              pdir.d.tail[0] = dir-&gt;d.tail[0];
561              pdir.d.tail[1] = dir-&gt;d.tail[1];
562              return lfs_dir_commit(lfs, &amp;pdir, NULL, 0);
563          }
564      }
565      int err = lfs_dir_commit(lfs, dir, (struct lfs_region[]){
566              {entry-&gt;off, lfs_entry_size(entry), NULL, 0},
567          }, 1);
568      if (err) {
569          return err;
570      }
571      for (lfs_file_t *f = lfs-&gt;files; f; f = f-&gt;next) {
572          if (lfs_paircmp(f-&gt;pair, dir-&gt;pair) == 0) {
573              if (f-&gt;poff == entry-&gt;off) {
574                  f-&gt;pair[0] = 0xffffffff;
575                  f-&gt;pair[1] = 0xffffffff;
576              } else if (f-&gt;poff &gt; entry-&gt;off) {
577                  f-&gt;poff -= lfs_entry_size(entry);
578              }
579          }
580      }
581      for (lfs_dir_t *d = lfs-&gt;dirs; d; d = d-&gt;next) {
582          if (lfs_paircmp(d-&gt;pair, dir-&gt;pair) == 0) {
583              if (d-&gt;off &gt; entry-&gt;off) {
584                  d-&gt;off -= lfs_entry_size(entry);
585                  d-&gt;pos -= lfs_entry_size(entry);
586              }
587          }
588      }
589      return 0;
590  }
591  static int lfs_dir_next(lfs_t *lfs, lfs_dir_t *dir, lfs_entry_t *entry) {
592      while (dir-&gt;off + sizeof(entry-&gt;d) &gt; (0x7fffffff &amp; dir-&gt;d.size)-4) {
593          if (!(0x80000000 &amp; dir-&gt;d.size)) {
594              entry-&gt;off = dir-&gt;off;
595              return LFS_ERR_NOENT;
596          }
597          int err = lfs_dir_fetch(lfs, dir, dir-&gt;d.tail);
598          if (err) {
599              return err;
600          }
601          dir-&gt;off = sizeof(dir-&gt;d);
602          dir-&gt;pos += sizeof(dir-&gt;d) + 4;
603      }
604      int err = lfs_bd_read(lfs, dir-&gt;pair[0], dir-&gt;off,
605              &amp;entry-&gt;d, sizeof(entry-&gt;d));
606      lfs_entry_fromle32(&amp;entry-&gt;d);
607      if (err) {
608          return err;
609      }
610      entry-&gt;off = dir-&gt;off;
611      dir-&gt;off += lfs_entry_size(entry);
612      dir-&gt;pos += lfs_entry_size(entry);
613      return 0;
614  }
615  static int lfs_dir_find(lfs_t *lfs, lfs_dir_t *dir,
616          lfs_entry_t *entry, const char **path) {
617      const char *pathname = *path;
618      size_t pathlen;
619      entry-&gt;d.type = LFS_TYPE_DIR;
620      entry-&gt;d.elen = sizeof(entry-&gt;d) - 4;
621      entry-&gt;d.alen = 0;
622      entry-&gt;d.nlen = 0;
623      entry-&gt;d.u.dir[0] = lfs-&gt;root[0];
624      entry-&gt;d.u.dir[1] = lfs-&gt;root[1];
625      while (true) {
626  nextname:
627          pathname += strspn(pathname, &quot;/&quot;);
628          pathlen = strcspn(pathname, &quot;/&quot;);
629          if ((pathlen == 1 &amp;&amp; memcmp(pathname, &quot;.&quot;, 1) == 0) ||
630              (pathlen == 2 &amp;&amp; memcmp(pathname, &quot;..&quot;, 2) == 0)) {
631              pathname += pathlen;
632              goto nextname;
633          }
634          const char *suffix = pathname + pathlen;
635          size_t sufflen;
636          int depth = 1;
637          while (true) {
638              suffix += strspn(suffix, &quot;/&quot;);
639              sufflen = strcspn(suffix, &quot;/&quot;);
640              if (sufflen == 0) {
641                  break;
642              }
643              if (sufflen == 2 &amp;&amp; memcmp(suffix, &quot;..&quot;, 2) == 0) {
644                  depth -= 1;
645                  if (depth == 0) {
646                      pathname = suffix + sufflen;
647                      goto nextname;
648                  }
649              } else {
650                  depth += 1;
651              }
652              suffix += sufflen;
653          }
654          if (pathname[0] == &#x27;\0&#x27;) {
655              return 0;
656          }
657          *path = pathname;
658          if (entry-&gt;d.type != LFS_TYPE_DIR) {
659              return LFS_ERR_NOTDIR;
660          }
661          int err = lfs_dir_fetch(lfs, dir, entry-&gt;d.u.dir);
662          if (err) {
663              return err;
664          }
665          while (true) {
666              err = lfs_dir_next(lfs, dir, entry);
667              if (err) {
668                  return err;
669              }
670              if (((0x7f &amp; entry-&gt;d.type) != LFS_TYPE_REG &amp;&amp;
671                   (0x7f &amp; entry-&gt;d.type) != LFS_TYPE_DIR) ||
672                  entry-&gt;d.nlen != pathlen) {
673                  continue;
674              }
675              int res = lfs_bd_cmp(lfs, dir-&gt;pair[0],
676                      entry-&gt;off + 4+entry-&gt;d.elen+entry-&gt;d.alen,
677                      pathname, pathlen);
678              if (res &lt; 0) {
679                  return res;
680              }
681              if (res) {
682                  break;
683              }
684          }
685          if (entry-&gt;d.type &amp; 0x80) {
686              int moved = lfs_moved(lfs, &amp;entry-&gt;d.u);
687              if (moved &lt; 0 || moved) {
688                  return (moved &lt; 0) ? moved : LFS_ERR_NOENT;
689              }
690              entry-&gt;d.type &amp;= ~0x80;
691          }
692          pathname += pathlen;
693      }
694  }
695  int lfs_mkdir(lfs_t *lfs, const char *path) {
696      if (!lfs-&gt;deorphaned) {
697          int err = lfs_deorphan(lfs);
698          if (err) {
699              return err;
700          }
701      }
702      lfs_dir_t cwd;
703      lfs_entry_t entry;
704      int err = lfs_dir_find(lfs, &amp;cwd, &amp;entry, &amp;path);
705      if (err != LFS_ERR_NOENT || strchr(path, &#x27;/&#x27;) != NULL) {
706          return err ? err : LFS_ERR_EXIST;
707      }
708      lfs_alloc_ack(lfs);
709      lfs_dir_t dir;
710      err = lfs_dir_alloc(lfs, &amp;dir);
711      if (err) {
712          return err;
713      }
714      dir.d.tail[0] = cwd.d.tail[0];
715      dir.d.tail[1] = cwd.d.tail[1];
716      err = lfs_dir_commit(lfs, &amp;dir, NULL, 0);
717      if (err) {
718          return err;
719      }
720      entry.d.type = LFS_TYPE_DIR;
721      entry.d.elen = sizeof(entry.d) - 4;
722      entry.d.alen = 0;
723      entry.d.nlen = strlen(path);
724      entry.d.u.dir[0] = dir.pair[0];
725      entry.d.u.dir[1] = dir.pair[1];
726      cwd.d.tail[0] = dir.pair[0];
727      cwd.d.tail[1] = dir.pair[1];
728      err = lfs_dir_append(lfs, &amp;cwd, &amp;entry, path);
729      if (err) {
730          return err;
731      }
732      lfs_alloc_ack(lfs);
733      return 0;
734  }
735  int lfs_dir_open(lfs_t *lfs, lfs_dir_t *dir, const char *path) {
736      dir-&gt;pair[0] = lfs-&gt;root[0];
737      dir-&gt;pair[1] = lfs-&gt;root[1];
738      lfs_entry_t entry;
739      int err = lfs_dir_find(lfs, dir, &amp;entry, &amp;path);
740      if (err) {
741          return err;
742      } else if (entry.d.type != LFS_TYPE_DIR) {
743          return LFS_ERR_NOTDIR;
744      }
745      err = lfs_dir_fetch(lfs, dir, entry.d.u.dir);
746      if (err) {
747          return err;
748      }
749      dir-&gt;head[0] = dir-&gt;pair[0];
750      dir-&gt;head[1] = dir-&gt;pair[1];
751      dir-&gt;pos = sizeof(dir-&gt;d) - 2;
752      dir-&gt;off = sizeof(dir-&gt;d);
753      dir-&gt;next = lfs-&gt;dirs;
754      lfs-&gt;dirs = dir;
755      return 0;
756  }
757  int lfs_dir_close(lfs_t *lfs, lfs_dir_t *dir) {
758      for (lfs_dir_t **p = &amp;lfs-&gt;dirs; *p; p = &amp;(*p)-&gt;next) {
759          if (*p == dir) {
760              *p = dir-&gt;next;
761              break;
762          }
763      }
764      return 0;
765  }
766  int lfs_dir_read(lfs_t *lfs, lfs_dir_t *dir, struct lfs_info *info) {
767      memset(info, 0, sizeof(*info));
768      if (dir-&gt;pos == sizeof(dir-&gt;d) - 2) {
769          info-&gt;type = LFS_TYPE_DIR;
770          strcpy(info-&gt;name, &quot;.&quot;);
771          dir-&gt;pos += 1;
772          return 1;
773      } else if (dir-&gt;pos == sizeof(dir-&gt;d) - 1) {
774          info-&gt;type = LFS_TYPE_DIR;
775          strcpy(info-&gt;name, &quot;..&quot;);
776          dir-&gt;pos += 1;
777          return 1;
778      }
779      lfs_entry_t entry;
780      while (true) {
781          int err = lfs_dir_next(lfs, dir, &amp;entry);
782          if (err) {
783              return (err == LFS_ERR_NOENT) ? 0 : err;
784          }
785          if ((0x7f &amp; entry.d.type) != LFS_TYPE_REG &amp;&amp;
786              (0x7f &amp; entry.d.type) != LFS_TYPE_DIR) {
787              continue;
788          }
789          if (entry.d.type &amp; 0x80) {
790              int moved = lfs_moved(lfs, &amp;entry.d.u);
791              if (moved &lt; 0) {
792                  return moved;
793              }
794              if (moved) {
795                  continue;
796              }
797              entry.d.type &amp;= ~0x80;
798          }
799          break;
800      }
801      info-&gt;type = entry.d.type;
802      if (info-&gt;type == LFS_TYPE_REG) {
803          info-&gt;size = entry.d.u.file.size;
804      }
805      int err = lfs_bd_read(lfs, dir-&gt;pair[0],
806              entry.off + 4+entry.d.elen+entry.d.alen,
807              info-&gt;name, entry.d.nlen);
808      if (err) {
809          return err;
810      }
811      return 1;
812  }
813  int lfs_dir_seek(lfs_t *lfs, lfs_dir_t *dir, lfs_off_t off) {
814      int err = lfs_dir_rewind(lfs, dir);
815      if (err) {
816          return err;
817      }
818      dir-&gt;pos = off;
819      while (off &gt; (0x7fffffff &amp; dir-&gt;d.size)) {
820          off -= 0x7fffffff &amp; dir-&gt;d.size;
821          if (!(0x80000000 &amp; dir-&gt;d.size)) {
822              return LFS_ERR_INVAL;
823          }
824          err = lfs_dir_fetch(lfs, dir, dir-&gt;d.tail);
825          if (err) {
826              return err;
827          }
828      }
829      dir-&gt;off = off;
830      return 0;
831  }
832  lfs_soff_t lfs_dir_tell(lfs_t *lfs, lfs_dir_t *dir) {
833      (void)lfs;
834      return dir-&gt;pos;
835  }
836  int lfs_dir_rewind(lfs_t *lfs, lfs_dir_t *dir) {
837      int err = lfs_dir_fetch(lfs, dir, dir-&gt;head);
838      if (err) {
839          return err;
840      }
841      dir-&gt;pair[0] = dir-&gt;head[0];
842      dir-&gt;pair[1] = dir-&gt;head[1];
843      dir-&gt;pos = sizeof(dir-&gt;d) - 2;
844      dir-&gt;off = sizeof(dir-&gt;d);
845      return 0;
846  }
847  static int lfs_ctz_index(lfs_t *lfs, lfs_off_t *off) {
848      lfs_off_t size = *off;
849      lfs_off_t b = lfs-&gt;cfg-&gt;block_size - 2*4;
850      lfs_off_t i = size / b;
851      if (i == 0) {
852          return 0;
853      }
854      i = (size - 4*(lfs_popc(i-1)+2)) / b;
855      *off = size - b*i - 4*lfs_popc(i);
856      return i;
857  }
858  static int lfs_ctz_find(lfs_t *lfs,
859          lfs_cache_t *rcache, const lfs_cache_t *pcache,
860          lfs_block_t head, lfs_size_t size,
861          lfs_size_t pos, lfs_block_t *block, lfs_off_t *off) {
862      if (size == 0) {
863          *block = 0xffffffff;
864          *off = 0;
865          return 0;
866      }
867      lfs_off_t current = lfs_ctz_index(lfs, &amp;(lfs_off_t){size-1});
868      lfs_off_t target = lfs_ctz_index(lfs, &amp;pos);
869      while (current &gt; target) {
870          lfs_size_t skip = lfs_min(
871                  lfs_npw2(current-target+1) - 1,
872                  lfs_ctz(current));
873          int err = lfs_cache_read(lfs, rcache, pcache, head, 4*skip, &amp;head, 4);
874          head = lfs_fromle32(head);
875          if (err) {
876              return err;
877          }
878          LFS_ASSERT(head &gt;= 2 &amp;&amp; head &lt;= lfs-&gt;cfg-&gt;block_count);
879          current -= 1 &lt;&lt; skip;
880      }
881      *block = head;
882      *off = pos;
883      return 0;
884  }
885  static int lfs_ctz_extend(lfs_t *lfs,
886          lfs_cache_t *rcache, lfs_cache_t *pcache,
887          lfs_block_t head, lfs_size_t size,
888          lfs_block_t *block, lfs_off_t *off) {
889      while (true) {
890          lfs_block_t nblock;
891          int err = lfs_alloc(lfs, &amp;nblock);
892          if (err) {
893              return err;
894          }
895          LFS_ASSERT(nblock &gt;= 2 &amp;&amp; nblock &lt;= lfs-&gt;cfg-&gt;block_count);
896          if (true) {
897              err = lfs_bd_erase(lfs, nblock);
898              if (err) {
899                  if (err == LFS_ERR_CORRUPT) {
900                      goto relocate;
901                  }
902                  return err;
903              }
904              if (size == 0) {
905                  *block = nblock;
906                  *off = 0;
907                  return 0;
908              }
909              size -= 1;
910              lfs_off_t index = lfs_ctz_index(lfs, &amp;size);
911              size += 1;
912              if (size != lfs-&gt;cfg-&gt;block_size) {
913                  for (lfs_off_t i = 0; i &lt; size; i++) {
914                      uint8_t data;
915                      err = lfs_cache_read(lfs, rcache, NULL,
916                              head, i, &amp;data, 1);
917                      if (err) {
918                          return err;
919                      }
920                      err = lfs_cache_prog(lfs, pcache, rcache,
921                              nblock, i, &amp;data, 1);
922                      if (err) {
923                          if (err == LFS_ERR_CORRUPT) {
924                              goto relocate;
925                          }
926                          return err;
927                      }
928                  }
929                  *block = nblock;
930                  *off = size;
931                  return 0;
932              }
933              index += 1;
934              lfs_size_t skips = lfs_ctz(index) + 1;
935              for (lfs_off_t i = 0; i &lt; skips; i++) {
936                  head = lfs_tole32(head);
937                  err = lfs_cache_prog(lfs, pcache, rcache,
938                          nblock, 4*i, &amp;head, 4);
939                  head = lfs_fromle32(head);
940                  if (err) {
941                      if (err == LFS_ERR_CORRUPT) {
942                          goto relocate;
943                      }
944                      return err;
945                  }
946                  if (i != skips-1) {
947                      err = lfs_cache_read(lfs, rcache, NULL,
948                              head, 4*i, &amp;head, 4);
949                      head = lfs_fromle32(head);
950                      if (err) {
951                          return err;
952                      }
953                  }
954                  LFS_ASSERT(head &gt;= 2 &amp;&amp; head &lt;= lfs-&gt;cfg-&gt;block_count);
955              }
956              *block = nblock;
957              *off = 4*skips;
958              return 0;
959          }
960  relocate:
961          LFS_DEBUG(&quot;Bad block at %&quot; PRIu32, nblock);
962          lfs_cache_drop(lfs, &amp;lfs-&gt;pcache);
963      }
964  }
965  static int lfs_ctz_traverse(lfs_t *lfs,
966          lfs_cache_t *rcache, const lfs_cache_t *pcache,
967          lfs_block_t head, lfs_size_t size,
968          int (*cb)(void*, lfs_block_t), void *data) {
969      if (size == 0) {
970          return 0;
971      }
972      lfs_off_t index = lfs_ctz_index(lfs, &amp;(lfs_off_t){size-1});
973      while (true) {
974          int err = cb(data, head);
975          if (err) {
976              return err;
977          }
978          if (index == 0) {
979              return 0;
980          }
981          lfs_block_t heads[2];
982          int count = 2 - (index &amp; 1);
983          err = lfs_cache_read(lfs, rcache, pcache, head, 0, &amp;heads, count*4);
984          heads[0] = lfs_fromle32(heads[0]);
985          heads[1] = lfs_fromle32(heads[1]);
986          if (err) {
987              return err;
988          }
989          for (int i = 0; i &lt; count-1; i++) {
990              err = cb(data, heads[i]);
991              if (err) {
992                  return err;
993              }
994          }
995          head = heads[count-1];
996          index -= count;
997      }
998  }
999  int lfs_file_opencfg(lfs_t *lfs, lfs_file_t *file,
1000          const char *path, int flags,
1001          const struct lfs_file_config *cfg) {
1002      if ((flags &amp; 3) != LFS_O_RDONLY &amp;&amp; !lfs-&gt;deorphaned) {
1003          int err = lfs_deorphan(lfs);
1004          if (err) {
1005              return err;
1006          }
1007      }
1008      lfs_dir_t cwd;
1009      lfs_entry_t entry;
1010      int err = lfs_dir_find(lfs, &amp;cwd, &amp;entry, &amp;path);
1011      if (err &amp;&amp; (err != LFS_ERR_NOENT || strchr(path, &#x27;/&#x27;) != NULL)) {
1012          return err;
1013      }
1014      if (err == LFS_ERR_NOENT) {
1015          if (!(flags &amp; LFS_O_CREAT)) {
1016              return LFS_ERR_NOENT;
1017          }
1018          entry.d.type = LFS_TYPE_REG;
1019          entry.d.elen = sizeof(entry.d) - 4;
1020          entry.d.alen = 0;
1021          entry.d.nlen = strlen(path);
1022          entry.d.u.file.head = 0xffffffff;
1023          entry.d.u.file.size = 0;
1024          err = lfs_dir_append(lfs, &amp;cwd, &amp;entry, path);
1025          if (err) {
1026              return err;
1027          }
1028      } else if (entry.d.type == LFS_TYPE_DIR) {
1029          return LFS_ERR_ISDIR;
1030      } else if (flags &amp; LFS_O_EXCL) {
1031          return LFS_ERR_EXIST;
1032      }
1033      file-&gt;cfg = cfg;
1034      file-&gt;pair[0] = cwd.pair[0];
1035      file-&gt;pair[1] = cwd.pair[1];
1036      file-&gt;poff = entry.off;
1037      file-&gt;head = entry.d.u.file.head;
1038      file-&gt;size = entry.d.u.file.size;
1039      file-&gt;flags = flags;
1040      file-&gt;pos = 0;
1041      if (flags &amp; LFS_O_TRUNC) {
1042          if (file-&gt;size != 0) {
1043              file-&gt;flags |= LFS_F_DIRTY;
1044          }
1045          file-&gt;head = 0xffffffff;
1046          file-&gt;size = 0;
1047      }
1048      file-&gt;cache.block = 0xffffffff;
1049      if (file-&gt;cfg &amp;&amp; file-&gt;cfg-&gt;buffer) {
1050          file-&gt;cache.buffer = file-&gt;cfg-&gt;buffer;
1051      } else if (lfs-&gt;cfg-&gt;file_buffer) {
1052          if (lfs-&gt;files) {
1053              return LFS_ERR_NOMEM;
1054          }
1055          file-&gt;cache.buffer = lfs-&gt;cfg-&gt;file_buffer;
1056      } else if ((file-&gt;flags &amp; 3) == LFS_O_RDONLY) {
1057          file-&gt;cache.buffer = lfs_malloc(lfs-&gt;cfg-&gt;read_size);
1058          if (!file-&gt;cache.buffer) {
1059              return LFS_ERR_NOMEM;
1060          }
1061      } else {
1062          file-&gt;cache.buffer = lfs_malloc(lfs-&gt;cfg-&gt;prog_size);
1063          if (!file-&gt;cache.buffer) {
1064              return LFS_ERR_NOMEM;
1065          }
1066      }
1067      lfs_cache_drop(lfs, &amp;file-&gt;cache);
1068      if ((file-&gt;flags &amp; 3) != LFS_O_RDONLY) {
1069          lfs_cache_zero(lfs, &amp;file-&gt;cache);
1070      }
1071      file-&gt;next = lfs-&gt;files;
1072      lfs-&gt;files = file;
1073      return 0;
1074  }
1075  int lfs_file_open(lfs_t *lfs, lfs_file_t *file,
1076          const char *path, int flags) {
1077      return lfs_file_opencfg(lfs, file, path, flags, NULL);
1078  }
1079  int lfs_file_close(lfs_t *lfs, lfs_file_t *file) {
1080      int err = lfs_file_sync(lfs, file);
1081      for (lfs_file_t **p = &amp;lfs-&gt;files; *p; p = &amp;(*p)-&gt;next) {
1082          if (*p == file) {
1083              *p = file-&gt;next;
1084              break;
1085          }
1086      }
1087      if (!(file-&gt;cfg &amp;&amp; file-&gt;cfg-&gt;buffer) &amp;&amp; !lfs-&gt;cfg-&gt;file_buffer) {
1088          lfs_free(file-&gt;cache.buffer);
1089      }
1090      return err;
1091  }
1092  static int lfs_file_relocate(lfs_t *lfs, lfs_file_t *file) {
1093  relocate:
1094      LFS_DEBUG(&quot;Bad block at %&quot; PRIu32, file-&gt;block);
1095      lfs_block_t nblock;
1096      int err = lfs_alloc(lfs, &amp;nblock);
1097      if (err) {
1098          return err;
1099      }
1100      err = lfs_bd_erase(lfs, nblock);
1101      if (err) {
1102          if (err == LFS_ERR_CORRUPT) {
1103              goto relocate;
1104          }
1105          return err;
1106      }
1107      for (lfs_off_t i = 0; i &lt; file-&gt;off; i++) {
1108          uint8_t data;
1109          err = lfs_cache_read(lfs, &amp;lfs-&gt;rcache, &amp;file-&gt;cache,
1110                  file-&gt;block, i, &amp;data, 1);
1111          if (err) {
1112              return err;
1113          }
1114          err = lfs_cache_prog(lfs, &amp;lfs-&gt;pcache, &amp;lfs-&gt;rcache,
1115                  nblock, i, &amp;data, 1);
1116          if (err) {
1117              if (err == LFS_ERR_CORRUPT) {
1118                  goto relocate;
1119              }
1120              return err;
1121          }
1122      }
1123      memcpy(file-&gt;cache.buffer, lfs-&gt;pcache.buffer, lfs-&gt;cfg-&gt;prog_size);
1124      file-&gt;cache.block = lfs-&gt;pcache.block;
1125      file-&gt;cache.off = lfs-&gt;pcache.off;
1126      lfs_cache_zero(lfs, &amp;lfs-&gt;pcache);
1127      file-&gt;block = nblock;
1128      return 0;
1129  }
1130  static int lfs_file_flush(lfs_t *lfs, lfs_file_t *file) {
1131      if (file-&gt;flags &amp; LFS_F_READING) {
1132          lfs_cache_drop(lfs, &amp;file-&gt;cache);
1133          file-&gt;flags &amp;= ~LFS_F_READING;
1134      }
1135      if (file-&gt;flags &amp; LFS_F_WRITING) {
1136          lfs_off_t pos = file-&gt;pos;
1137          lfs_file_t orig = {
1138              .head = file-&gt;head,
1139              .size = file-&gt;size,
1140              .flags = LFS_O_RDONLY,
1141              .pos = file-&gt;pos,
1142              .cache = lfs-&gt;rcache,
1143          };
1144          lfs_cache_drop(lfs, &amp;lfs-&gt;rcache);
1145          while (file-&gt;pos &lt; file-&gt;size) {
1146              uint8_t data;
1147              lfs_ssize_t res = lfs_file_read(lfs, &amp;orig, &amp;data, 1);
1148              if (res &lt; 0) {
1149                  return res;
1150              }
1151              res = lfs_file_write(lfs, file, &amp;data, 1);
1152              if (res &lt; 0) {
1153                  return res;
1154              }
1155              if (lfs-&gt;rcache.block != 0xffffffff) {
1156                  lfs_cache_drop(lfs, &amp;orig.cache);
1157                  lfs_cache_drop(lfs, &amp;lfs-&gt;rcache);
1158              }
1159          }
1160          while (true) {
1161              int err = lfs_cache_flush(lfs, &amp;file-&gt;cache, &amp;lfs-&gt;rcache);
1162              if (err) {
1163                  if (err == LFS_ERR_CORRUPT) {
1164                      goto relocate;
1165                  }
1166                  return err;
1167              }
1168              break;
1169  relocate:
1170              err = lfs_file_relocate(lfs, file);
1171              if (err) {
1172                  return err;
1173              }
1174          }
1175          file-&gt;head = file-&gt;block;
1176          file-&gt;size = file-&gt;pos;
1177          file-&gt;flags &amp;= ~LFS_F_WRITING;
1178          file-&gt;flags |= LFS_F_DIRTY;
1179          file-&gt;pos = pos;
1180      }
1181      return 0;
1182  }
1183  int lfs_file_sync(lfs_t *lfs, lfs_file_t *file) {
1184      int err = lfs_file_flush(lfs, file);
1185      if (err) {
1186          return err;
1187      }
1188      if ((file-&gt;flags &amp; LFS_F_DIRTY) &amp;&amp;
1189              !(file-&gt;flags &amp; LFS_F_ERRED) &amp;&amp;
1190              !lfs_pairisnull(file-&gt;pair)) {
1191          lfs_dir_t cwd;
1192          err = lfs_dir_fetch(lfs, &amp;cwd, file-&gt;pair);
1193          if (err) {
1194              return err;
1195          }
1196          lfs_entry_t entry = {.off = file-&gt;poff};
1197          err = lfs_bd_read(lfs, cwd.pair[0], entry.off,
1198                  &amp;entry.d, sizeof(entry.d));
1199          lfs_entry_fromle32(&amp;entry.d);
1200          if (err) {
1201              return err;
1202          }
1203          LFS_ASSERT(entry.d.type == LFS_TYPE_REG);
1204          entry.d.u.file.head = file-&gt;head;
1205          entry.d.u.file.size = file-&gt;size;
1206          err = lfs_dir_update(lfs, &amp;cwd, &amp;entry, NULL);
1207          if (err) {
1208              return err;
1209          }
1210          file-&gt;flags &amp;= ~LFS_F_DIRTY;
1211      }
1212      return 0;
1213  }
1214  lfs_ssize_t lfs_file_read(lfs_t *lfs, lfs_file_t *file,
1215          void *buffer, lfs_size_t size) {
1216      uint8_t *data = buffer;
1217      lfs_size_t nsize = size;
1218      if ((file-&gt;flags &amp; 3) == LFS_O_WRONLY) {
1219          return LFS_ERR_BADF;
1220      }
1221      if (file-&gt;flags &amp; LFS_F_WRITING) {
1222          int err = lfs_file_flush(lfs, file);
1223          if (err) {
1224              return err;
1225          }
1226      }
1227      if (file-&gt;pos &gt;= file-&gt;size) {
1228          return 0;
1229      }
1230      size = lfs_min(size, file-&gt;size - file-&gt;pos);
1231      nsize = size;
1232      while (nsize &gt; 0) {
1233          if (!(file-&gt;flags &amp; LFS_F_READING) ||
1234                  file-&gt;off == lfs-&gt;cfg-&gt;block_size) {
1235              int err = lfs_ctz_find(lfs, &amp;file-&gt;cache, NULL,
1236                      file-&gt;head, file-&gt;size,
1237                      file-&gt;pos, &amp;file-&gt;block, &amp;file-&gt;off);
1238              if (err) {
1239                  return err;
1240              }
1241              file-&gt;flags |= LFS_F_READING;
1242          }
1243          lfs_size_t diff = lfs_min(nsize, lfs-&gt;cfg-&gt;block_size - file-&gt;off);
1244          int err = lfs_cache_read(lfs, &amp;file-&gt;cache, NULL,
1245                  file-&gt;block, file-&gt;off, data, diff);
1246          if (err) {
1247              return err;
1248          }
1249          file-&gt;pos += diff;
1250          file-&gt;off += diff;
1251          data += diff;
1252          nsize -= diff;
1253      }
1254      return size;
1255  }
1256  lfs_ssize_t lfs_file_write(lfs_t *lfs, lfs_file_t *file,
1257          const void *buffer, lfs_size_t size) {
1258      const uint8_t *data = buffer;
1259      lfs_size_t nsize = size;
1260      if ((file-&gt;flags &amp; 3) == LFS_O_RDONLY) {
1261          return LFS_ERR_BADF;
1262      }
1263      if (file-&gt;flags &amp; LFS_F_READING) {
1264          int err = lfs_file_flush(lfs, file);
1265          if (err) {
1266              return err;
1267          }
1268      }
1269      if ((file-&gt;flags &amp; LFS_O_APPEND) &amp;&amp; file-&gt;pos &lt; file-&gt;size) {
1270          file-&gt;pos = file-&gt;size;
1271      }
1272      if (!(file-&gt;flags &amp; LFS_F_WRITING) &amp;&amp; file-&gt;pos &gt; file-&gt;size) {
1273          lfs_off_t pos = file-&gt;pos;
1274          file-&gt;pos = file-&gt;size;
1275          while (file-&gt;pos &lt; pos) {
1276              lfs_ssize_t res = lfs_file_write(lfs, file, &amp;(uint8_t){0}, 1);
1277              if (res &lt; 0) {
1278                  return res;
1279              }
1280          }
1281      }
1282      while (nsize &gt; 0) {
1283          if (!(file-&gt;flags &amp; LFS_F_WRITING) ||
1284                  file-&gt;off == lfs-&gt;cfg-&gt;block_size) {
1285              if (!(file-&gt;flags &amp; LFS_F_WRITING) &amp;&amp; file-&gt;pos &gt; 0) {
1286                  int err = lfs_ctz_find(lfs, &amp;file-&gt;cache, NULL,
1287                          file-&gt;head, file-&gt;size,
1288                          file-&gt;pos-1, &amp;file-&gt;block, &amp;file-&gt;off);
1289                  if (err) {
1290                      file-&gt;flags |= LFS_F_ERRED;
1291                      return err;
1292                  }
1293                  lfs_cache_zero(lfs, &amp;file-&gt;cache);
1294              }
1295              lfs_alloc_ack(lfs);
1296              int err = lfs_ctz_extend(lfs, &amp;lfs-&gt;rcache, &amp;file-&gt;cache,
1297                      file-&gt;block, file-&gt;pos,
1298                      &amp;file-&gt;block, &amp;file-&gt;off);
1299              if (err) {
1300                  file-&gt;flags |= LFS_F_ERRED;
1301                  return err;
1302              }
1303              file-&gt;flags |= LFS_F_WRITING;
1304          }
1305          lfs_size_t diff = lfs_min(nsize, lfs-&gt;cfg-&gt;block_size - file-&gt;off);
1306          while (true) {
1307              int err = lfs_cache_prog(lfs, &amp;file-&gt;cache, &amp;lfs-&gt;rcache,
1308                      file-&gt;block, file-&gt;off, data, diff);
1309              if (err) {
1310                  if (err == LFS_ERR_CORRUPT) {
1311                      goto relocate;
1312                  }
1313                  file-&gt;flags |= LFS_F_ERRED;
1314                  return err;
1315              }
1316              break;
1317  relocate:
1318              err = lfs_file_relocate(lfs, file);
1319              if (err) {
1320                  file-&gt;flags |= LFS_F_ERRED;
1321                  return err;
1322              }
1323          }
1324          file-&gt;pos += diff;
1325          file-&gt;off += diff;
1326          data += diff;
1327          nsize -= diff;
1328          lfs_alloc_ack(lfs);
1329      }
1330      file-&gt;flags &amp;= ~LFS_F_ERRED;
1331      return size;
1332  }
1333  lfs_soff_t lfs_file_seek(lfs_t *lfs, lfs_file_t *file,
1334          lfs_soff_t off, int whence) {
1335      int err = lfs_file_flush(lfs, file);
1336      if (err) {
1337          return err;
1338      }
1339      if (whence == LFS_SEEK_SET) {
1340          file-&gt;pos = off;
1341      } else if (whence == LFS_SEEK_CUR) {
1342          if (off &lt; 0 &amp;&amp; (lfs_off_t)-off &gt; file-&gt;pos) {
1343              return LFS_ERR_INVAL;
1344          }
1345          file-&gt;pos = file-&gt;pos + off;
1346      } else if (whence == LFS_SEEK_END) {
1347          if (off &lt; 0 &amp;&amp; (lfs_off_t)-off &gt; file-&gt;size) {
1348              return LFS_ERR_INVAL;
1349          }
1350          file-&gt;pos = file-&gt;size + off;
1351      }
1352      return file-&gt;pos;
1353  }
1354  int lfs_file_truncate(lfs_t *lfs, lfs_file_t *file, lfs_off_t size) {
1355      if ((file-&gt;flags &amp; 3) == LFS_O_RDONLY) {
1356          return LFS_ERR_BADF;
1357      }
1358      lfs_off_t oldsize = lfs_file_size(lfs, file);
1359      if (size &lt; oldsize) {
1360          int err = lfs_file_flush(lfs, file);
1361          if (err) {
1362              return err;
1363          }
1364          err = lfs_ctz_find(lfs, &amp;file-&gt;cache, NULL,
1365                  file-&gt;head, file-&gt;size,
1366                  size, &amp;file-&gt;head, &amp;(lfs_off_t){0});
1367          if (err) {
1368              return err;
1369          }
1370          file-&gt;size = size;
1371          file-&gt;flags |= LFS_F_DIRTY;
1372      } else if (size &gt; oldsize) {
1373          lfs_off_t pos = file-&gt;pos;
1374          if (file-&gt;pos != oldsize) {
1375              int err = lfs_file_seek(lfs, file, 0, LFS_SEEK_END);
1376              if (err &lt; 0) {
1377                  return err;
1378              }
1379          }
1380          while (file-&gt;pos &lt; size) {
1381              lfs_ssize_t res = lfs_file_write(lfs, file, &amp;(uint8_t){0}, 1);
1382              if (res &lt; 0) {
1383                  return res;
1384              }
1385          }
1386          int err = lfs_file_seek(lfs, file, pos, LFS_SEEK_SET);
1387          if (err &lt; 0) {
1388              return err;
1389          }
1390      }
1391      return 0;
1392  }
1393  lfs_soff_t lfs_file_tell(lfs_t *lfs, lfs_file_t *file) {
1394      (void)lfs;
1395      return file-&gt;pos;
1396  }
1397  int lfs_file_rewind(lfs_t *lfs, lfs_file_t *file) {
1398      lfs_soff_t res = lfs_file_seek(lfs, file, 0, LFS_SEEK_SET);
1399      if (res &lt; 0) {
1400          return res;
1401      }
1402      return 0;
1403  }
1404  lfs_soff_t lfs_file_size(lfs_t *lfs, lfs_file_t *file) {
1405      (void)lfs;
1406      if (file-&gt;flags &amp; LFS_F_WRITING) {
1407          return lfs_max(file-&gt;pos, file-&gt;size);
1408      } else {
1409          return file-&gt;size;
1410      }
1411  }
1412  int lfs_stat(lfs_t *lfs, const char *path, struct lfs_info *info) {
1413      lfs_dir_t cwd;
1414      lfs_entry_t entry;
1415      int err = lfs_dir_find(lfs, &amp;cwd, &amp;entry, &amp;path);
1416      if (err) {
1417          return err;
1418      }
1419      memset(info, 0, sizeof(*info));
1420      info-&gt;type = entry.d.type;
1421      if (info-&gt;type == LFS_TYPE_REG) {
1422          info-&gt;size = entry.d.u.file.size;
1423      }
1424      if (lfs_paircmp(entry.d.u.dir, lfs-&gt;root) == 0) {
1425          strcpy(info-&gt;name, &quot;/&quot;);
1426      } else {
1427          err = lfs_bd_read(lfs, cwd.pair[0],
1428                  entry.off + 4+entry.d.elen+entry.d.alen,
1429                  info-&gt;name, entry.d.nlen);
1430          if (err) {
1431              return err;
1432          }
1433      }
1434      return 0;
1435  }
1436  int lfs_remove(lfs_t *lfs, const char *path) {
1437      if (!lfs-&gt;deorphaned) {
1438          int err = lfs_deorphan(lfs);
1439          if (err) {
1440              return err;
1441          }
1442      }
1443      lfs_dir_t cwd;
1444      lfs_entry_t entry;
1445      int err = lfs_dir_find(lfs, &amp;cwd, &amp;entry, &amp;path);
1446      if (err) {
1447          return err;
1448      }
1449      lfs_dir_t dir;
1450      if (entry.d.type == LFS_TYPE_DIR) {
1451          err = lfs_dir_fetch(lfs, &amp;dir, entry.d.u.dir);
1452          if (err) {
1453              return err;
1454          } &amp;bsol;* else if (dir.d.size != sizeof(dir.d)+4) {
1455              return LFS_ERR_NOTEMPTY;
1456          }  adafruit: allow to remove non-empty folder,
1457             According to below issue, comment these 2 line won&#x27;t corrupt filesystem
1458             https:&amp;bsol;&amp;bsol;github.com/ARMmbed/littlefs/issues/43 */
1459      }
1460      err = lfs_dir_remove(lfs, &amp;cwd, &amp;entry);
1461      if (err) {
1462          return err;
1463      }
1464      if (entry.d.type == LFS_TYPE_DIR) {
1465          int res = lfs_pred(lfs, dir.pair, &amp;cwd);
1466          if (res &lt; 0) {
1467              return res;
1468          }
1469          LFS_ASSERT(res); 
1470          cwd.d.tail[0] = dir.d.tail[0];
1471          cwd.d.tail[1] = dir.d.tail[1];
1472          err = lfs_dir_commit(lfs, &amp;cwd, NULL, 0);
1473          if (err) {
1474              return err;
1475          }
1476      }
1477      return 0;
1478  }
1479  int lfs_rename(lfs_t *lfs, const char *oldpath, const char *newpath) {
1480      if (!lfs-&gt;deorphaned) {
1481          int err = lfs_deorphan(lfs);
1482          if (err) {
1483              return err;
1484          }
1485      }
1486      lfs_dir_t oldcwd;
1487      lfs_entry_t oldentry;
1488      int err = lfs_dir_find(lfs, &amp;oldcwd, &amp;oldentry, &amp;oldpath);
1489      if (err) {
1490          return err;
1491      }
1492      lfs_dir_t newcwd;
1493      lfs_entry_t preventry;
1494      err = lfs_dir_find(lfs, &amp;newcwd, &amp;preventry, &amp;newpath);
1495      if (err &amp;&amp; (err != LFS_ERR_NOENT || strchr(newpath, &#x27;/&#x27;) != NULL)) {
1496          return err;
1497      }
1498      bool prevexists = (err != LFS_ERR_NOENT);
1499      bool samepair = (lfs_paircmp(oldcwd.pair, newcwd.pair) == 0);
1500      if (prevexists &amp;&amp; preventry.d.type != oldentry.d.type) {
1501          return LFS_ERR_ISDIR;
1502      }
1503      lfs_dir_t dir;
1504      if (prevexists &amp;&amp; preventry.d.type == LFS_TYPE_DIR) {
1505          err = lfs_dir_fetch(lfs, &amp;dir, preventry.d.u.dir);
1506          if (err) {
1507              return err;
1508          } else if (dir.d.size != sizeof(dir.d)+4) {
1509              return LFS_ERR_NOTEMPTY;
1510          }
1511      }
1512      oldentry.d.type |= 0x80;
1513      err = lfs_dir_update(lfs, &amp;oldcwd, &amp;oldentry, NULL);
1514      if (err) {
1515          return err;
1516      }
1517      if (samepair) {
1518          newcwd = oldcwd;
1519      }
1520      lfs_entry_t newentry = preventry;
1521      newentry.d = oldentry.d;
1522      newentry.d.type &amp;= ~0x80;
1523      newentry.d.nlen = strlen(newpath);
1524      if (prevexists) {
1525          err = lfs_dir_update(lfs, &amp;newcwd, &amp;newentry, newpath);
1526          if (err) {
1527              return err;
1528          }
1529      } else {
1530          err = lfs_dir_append(lfs, &amp;newcwd, &amp;newentry, newpath);
1531          if (err) {
1532              return err;
1533          }
1534      }
1535      if (samepair) {
1536          oldcwd = newcwd;
1537      }
1538      err = lfs_dir_remove(lfs, &amp;oldcwd, &amp;oldentry);
1539      if (err) {
1540          return err;
1541      }
1542      if (prevexists &amp;&amp; preventry.d.type == LFS_TYPE_DIR) {
1543          int res = lfs_pred(lfs, dir.pair, &amp;newcwd);
1544          if (res &lt; 0) {
1545              return res;
1546          }
1547          LFS_ASSERT(res); 
1548          newcwd.d.tail[0] = dir.d.tail[0];
1549          newcwd.d.tail[1] = dir.d.tail[1];
1550          err = lfs_dir_commit(lfs, &amp;newcwd, NULL, 0);
1551          if (err) {
1552              return err;
1553          }
1554      }
1555      return 0;
1556  }
1557  static void lfs_deinit(lfs_t *lfs) {
1558      if (!lfs-&gt;cfg-&gt;read_buffer) {
1559          lfs_free(lfs-&gt;rcache.buffer);
1560      }
1561      if (!lfs-&gt;cfg-&gt;prog_buffer) {
1562          lfs_free(lfs-&gt;pcache.buffer);
1563      }
1564      if (!lfs-&gt;cfg-&gt;lookahead_buffer) {
1565          lfs_free(lfs-&gt;free.buffer);
1566      }
1567  }
1568  static int lfs_init(lfs_t *lfs, const struct lfs_config *cfg) {
1569      lfs-&gt;cfg = cfg;
1570      if (lfs-&gt;cfg-&gt;read_buffer) {
1571          lfs-&gt;rcache.buffer = lfs-&gt;cfg-&gt;read_buffer;
1572      } else {
1573          lfs-&gt;rcache.buffer = lfs_malloc(lfs-&gt;cfg-&gt;read_size);
1574          if (!lfs-&gt;rcache.buffer) {
1575              goto cleanup;
1576          }
1577      }
1578      if (lfs-&gt;cfg-&gt;prog_buffer) {
1579          lfs-&gt;pcache.buffer = lfs-&gt;cfg-&gt;prog_buffer;
1580      } else {
1581          lfs-&gt;pcache.buffer = lfs_malloc(lfs-&gt;cfg-&gt;prog_size);
1582          if (!lfs-&gt;pcache.buffer) {
1583              goto cleanup;
1584          }
1585      }
1586      lfs_cache_zero(lfs, &amp;lfs-&gt;pcache);
1587      lfs_cache_drop(lfs, &amp;lfs-&gt;rcache);
1588      LFS_ASSERT(lfs-&gt;cfg-&gt;lookahead % 32 == 0);
1589      LFS_ASSERT(lfs-&gt;cfg-&gt;lookahead &gt; 0);
1590      if (lfs-&gt;cfg-&gt;lookahead_buffer) {
1591          lfs-&gt;free.buffer = lfs-&gt;cfg-&gt;lookahead_buffer;
1592      } else {
1593          lfs-&gt;free.buffer = lfs_malloc(lfs-&gt;cfg-&gt;lookahead/8);
1594          if (!lfs-&gt;free.buffer) {
1595              goto cleanup;
1596          }
1597      }
1598      LFS_ASSERT(lfs-&gt;cfg-&gt;prog_size % lfs-&gt;cfg-&gt;read_size == 0);
1599      LFS_ASSERT(lfs-&gt;cfg-&gt;block_size % lfs-&gt;cfg-&gt;prog_size == 0);
1600      LFS_ASSERT(4*lfs_npw2(0xffffffff / (lfs-&gt;cfg-&gt;block_size-2*4))
1601              &lt;= lfs-&gt;cfg-&gt;block_size);
1602      lfs-&gt;root[0] = 0xffffffff;
1603      lfs-&gt;root[1] = 0xffffffff;
1604      lfs-&gt;files = NULL;
1605      lfs-&gt;dirs = NULL;
1606      lfs-&gt;deorphaned = false;
1607      return 0;
1608  cleanup:
1609      lfs_deinit(lfs);
1610      return LFS_ERR_NOMEM;
1611  }
1612  int lfs_format(lfs_t *lfs, const struct lfs_config *cfg) {
1613      int err = 0;
1614      if (true) {
1615          err = lfs_init(lfs, cfg);
1616          if (err) {
1617              return err;
1618          }
1619          memset(lfs-&gt;free.buffer, 0, lfs-&gt;cfg-&gt;lookahead/8);
1620          lfs-&gt;free.off = 0;
1621          lfs-&gt;free.size = lfs_min(lfs-&gt;cfg-&gt;lookahead, lfs-&gt;cfg-&gt;block_count);
1622          lfs-&gt;free.i = 0;
1623          lfs_alloc_ack(lfs);
1624          lfs_dir_t superdir;
1625          err = lfs_dir_alloc(lfs, &amp;superdir);
1626          if (err) {
1627              goto cleanup;
1628          }
1629          lfs_dir_t root;
1630          err = lfs_dir_alloc(lfs, &amp;root);
1631          if (err) {
1632              goto cleanup;
1633          }
1634          err = lfs_dir_commit(lfs, &amp;root, NULL, 0);
1635          if (err) {
1636              goto cleanup;
1637          }
1638          lfs-&gt;root[0] = root.pair[0];
1639          lfs-&gt;root[1] = root.pair[1];
1640          lfs_superblock_t superblock = {
1641              .off = sizeof(superdir.d),
1642              .d.type = LFS_TYPE_SUPERBLOCK,
1643              .d.elen = sizeof(superblock.d) - sizeof(superblock.d.magic) - 4,
1644              .d.nlen = sizeof(superblock.d.magic),
1645              .d.version = LFS_DISK_VERSION,
1646              .d.magic = {&quot;littlefs&quot;},
1647              .d.block_size  = lfs-&gt;cfg-&gt;block_size,
1648              .d.block_count = lfs-&gt;cfg-&gt;block_count,
1649              .d.root = {lfs-&gt;root[0], lfs-&gt;root[1]},
1650          };
1651          superdir.d.tail[0] = root.pair[0];
1652          superdir.d.tail[1] = root.pair[1];
1653          superdir.d.size = sizeof(superdir.d) + sizeof(superblock.d) + 4;
1654          lfs_superblock_tole32(&amp;superblock.d);
1655          bool valid = false;
1656          for (int i = 0; i &lt; 2; i++) {
1657              err = lfs_dir_commit(lfs, &amp;superdir, (struct lfs_region[]){
1658                      {sizeof(superdir.d), sizeof(superblock.d),
1659                       &amp;superblock.d, sizeof(superblock.d)}
1660                  }, 1);
1661              if (err &amp;&amp; err != LFS_ERR_CORRUPT) {
1662                  goto cleanup;
1663              }
1664              valid = valid || !err;
1665          }
1666          if (!valid) {
1667              err = LFS_ERR_CORRUPT;
1668              goto cleanup;
1669          }
1670          err = lfs_dir_fetch(lfs, &amp;superdir, (const lfs_block_t[2]){0, 1});
1671          if (err) {
1672              goto cleanup;
1673          }
1674          lfs_alloc_ack(lfs);
1675      }
1676  cleanup:
1677      lfs_deinit(lfs);
1678      return err;
1679  }
1680  int lfs_mount(lfs_t *lfs, const struct lfs_config *cfg) {
1681      int err = 0;
1682      if (true) {
1683          err = lfs_init(lfs, cfg);
1684          if (err) {
1685              return err;
1686          }
1687          lfs-&gt;free.off = 0;
1688          lfs-&gt;free.size = 0;
1689          lfs-&gt;free.i = 0;
1690          lfs_alloc_ack(lfs);
1691          lfs_dir_t dir;
1692          lfs_superblock_t superblock;
1693          err = lfs_dir_fetch(lfs, &amp;dir, (const lfs_block_t[2]){0, 1});
1694          if (err &amp;&amp; err != LFS_ERR_CORRUPT) {
1695              goto cleanup;
1696          }
1697          if (!err) {
1698              err = lfs_bd_read(lfs, dir.pair[0], sizeof(dir.d),
1699                      &amp;superblock.d, sizeof(superblock.d));
1700              lfs_superblock_fromle32(&amp;superblock.d);
1701              if (err) {
1702                  goto cleanup;
1703              }
1704              lfs-&gt;root[0] = superblock.d.root[0];
1705              lfs-&gt;root[1] = superblock.d.root[1];
1706          }
1707          if (err || memcmp(superblock.d.magic, &quot;littlefs&quot;, 8) != 0) {
1708              LFS_ERROR(&quot;Invalid superblock at %d %d&quot;, 0, 1);
1709              err = LFS_ERR_CORRUPT;
1710              goto cleanup;
1711          }
1712          uint16_t major_version = (0xffff &amp; (superblock.d.version &gt;&gt; 16));
1713          uint16_t minor_version = (0xffff &amp; (superblock.d.version &gt;&gt;  0));
1714          if ((major_version != LFS_DISK_VERSION_MAJOR ||
1715               minor_version &gt; LFS_DISK_VERSION_MINOR)) {
1716              LFS_ERROR(&quot;Invalid version %d.%d&quot;, major_version, minor_version);
1717              err = LFS_ERR_INVAL;
1718              goto cleanup;
1719          }
1720          return 0;
1721      }
1722  cleanup:
1723      lfs_deinit(lfs);
1724      return err;
1725  }
1726  int lfs_unmount(lfs_t *lfs) {
1727      lfs_deinit(lfs);
1728      return 0;
1729  }
1730  int lfs_traverse(lfs_t *lfs, int (*cb)(void*, lfs_block_t), void *data) {
1731      if (lfs_pairisnull(lfs-&gt;root)) {
1732          return 0;
1733      }
1734      lfs_dir_t dir;
1735      lfs_entry_t entry;
1736      lfs_block_t cwd[2] = {0, 1};
1737      while (true) {
1738          for (int i = 0; i &lt; 2; i++) {
1739              int err = cb(data, cwd[i]);
1740              if (err) {
1741                  return err;
1742              }
1743          }
1744          int err = lfs_dir_fetch(lfs, &amp;dir, cwd);
1745          if (err) {
1746              return err;
1747          }
1748          while (dir.off + sizeof(entry.d) &lt;= (0x7fffffff &amp; dir.d.size)-4) {
1749              err = lfs_bd_read(lfs, dir.pair[0], dir.off,
1750                      &amp;entry.d, sizeof(entry.d));
1751              lfs_entry_fromle32(&amp;entry.d);
1752              if (err) {
1753                  return err;
1754              }
1755              dir.off += lfs_entry_size(&amp;entry);
1756              if ((0x70 &amp; entry.d.type) == (0x70 &amp; LFS_TYPE_REG)) {
1757                  err = lfs_ctz_traverse(lfs, &amp;lfs-&gt;rcache, NULL,
1758                          entry.d.u.file.head, entry.d.u.file.size, cb, data);
1759                  if (err) {
1760                      return err;
1761                  }
1762              }
1763          }
1764          cwd[0] = dir.d.tail[0];
1765          cwd[1] = dir.d.tail[1];
1766          if (lfs_pairisnull(cwd)) {
1767              break;
1768          }
1769      }
1770      for (lfs_file_t *f = lfs-&gt;files; f; f = f-&gt;next) {
1771          if (f-&gt;flags &amp; LFS_F_DIRTY) {
1772              int err = lfs_ctz_traverse(lfs, &amp;lfs-&gt;rcache, &amp;f-&gt;cache,
1773                      f-&gt;head, f-&gt;size, cb, data);
1774              if (err) {
1775                  return err;
1776              }
1777          }
1778          if (f-&gt;flags &amp; LFS_F_WRITING) {
1779              int err = lfs_ctz_traverse(lfs, &amp;lfs-&gt;rcache, &amp;f-&gt;cache,
1780                      f-&gt;block, f-&gt;pos, cb, data);
1781              if (err) {
1782                  return err;
1783              }
1784          }
1785      }
1786      return 0;
1787  }
1788  static int lfs_pred(lfs_t *lfs, const lfs_block_t dir[2], lfs_dir_t *pdir) {
1789      if (lfs_pairisnull(lfs-&gt;root)) {
1790          return 0;
1791      }
1792      int err = lfs_dir_fetch(lfs, pdir, (const lfs_block_t[2]){0, 1});
1793      if (err) {
1794          return err;
1795      }
1796      while (!lfs_pairisnull(pdir-&gt;d.tail)) {
1797          if (lfs_paircmp(pdir-&gt;d.tail, dir) == 0) {
1798              return true;
1799          }
1800          err = lfs_dir_fetch(lfs, pdir, pdir-&gt;d.tail);
1801          if (err) {
1802              return err;
1803          }
1804      }
1805      return false;
1806  }
1807  static int lfs_parent(lfs_t *lfs, const lfs_block_t dir[2],
1808          lfs_dir_t *parent, lfs_entry_t *entry) {
1809      if (lfs_pairisnull(lfs-&gt;root)) {
1810          return 0;
1811      }
1812      parent-&gt;d.tail[0] = 0;
1813      parent-&gt;d.tail[1] = 1;
1814      while (!lfs_pairisnull(parent-&gt;d.tail)) {
1815          int err = lfs_dir_fetch(lfs, parent, parent-&gt;d.tail);
1816          if (err) {
1817              return err;
1818          }
1819          while (true) {
1820              err = lfs_dir_next(lfs, parent, entry);
1821              if (err &amp;&amp; err != LFS_ERR_NOENT) {
1822                  return err;
1823              }
1824              if (err == LFS_ERR_NOENT) {
1825                  break;
1826              }
1827              if (((0x70 &amp; entry-&gt;d.type) == (0x70 &amp; LFS_TYPE_DIR)) &amp;&amp;
1828                   lfs_paircmp(entry-&gt;d.u.dir, dir) == 0) {
1829                  return true;
1830              }
1831          }
1832      }
1833      return false;
1834  }
1835  static int lfs_moved(lfs_t *lfs, const void *e) {
1836      if (lfs_pairisnull(lfs-&gt;root)) {
1837          return 0;
1838      }
1839      lfs_dir_t cwd;
1840      int err = lfs_dir_fetch(lfs, &amp;cwd, (const lfs_block_t[2]){0, 1});
1841      if (err) {
1842          return err;
1843      }
1844      lfs_entry_t entry;
1845      while (!lfs_pairisnull(cwd.d.tail)) {
1846          err = lfs_dir_fetch(lfs, &amp;cwd, cwd.d.tail);
1847          if (err) {
1848              return err;
1849          }
1850          while (true) {
1851              err = lfs_dir_next(lfs, &amp;cwd, &amp;entry);
1852              if (err &amp;&amp; err != LFS_ERR_NOENT) {
1853                  return err;
1854              }
1855              if (err == LFS_ERR_NOENT) {
1856                  break;
1857              }
1858              if (!(0x80 &amp; entry.d.type) &amp;&amp;
1859                   memcmp(&amp;entry.d.u, e, sizeof(entry.d.u)) == 0) {
1860                  return true;
1861              }
1862          }
1863      }
1864      return false;
1865  }
1866  static int lfs_relocate(lfs_t *lfs,
1867          const lfs_block_t oldpair[2], const lfs_block_t newpair[2]) {
1868      lfs_dir_t parent;
1869      lfs_entry_t entry;
1870      int res = lfs_parent(lfs, oldpair, &amp;parent, &amp;entry);
1871      if (res &lt; 0) {
1872          return res;
1873      }
1874      if (res) {
1875          entry.d.u.dir[0] = newpair[0];
1876          entry.d.u.dir[1] = newpair[1];
1877          int err = lfs_dir_update(lfs, &amp;parent, &amp;entry, NULL);
1878          if (err) {
1879              return err;
1880          }
1881          if (lfs_paircmp(oldpair, lfs-&gt;root) == 0) {
1882              LFS_DEBUG(&quot;Relocating root %&quot; PRIu32 &quot; %&quot; PRIu32,
1883                      newpair[0], newpair[1]);
1884              lfs-&gt;root[0] = newpair[0];
1885              lfs-&gt;root[1] = newpair[1];
1886          }
1887          return lfs_deorphan(lfs);
1888      }
1889      res = lfs_pred(lfs, oldpair, &amp;parent);
1890      if (res &lt; 0) {
1891          return res;
1892      }
1893      if (res) {
1894          parent.d.tail[0] = newpair[0];
1895          parent.d.tail[1] = newpair[1];
1896          return lfs_dir_commit(lfs, &amp;parent, NULL, 0);
1897      }
1898      return 0;
1899  }
1900  int lfs_deorphan(lfs_t *lfs) {
1901      lfs-&gt;deorphaned = true;
1902      if (lfs_pairisnull(lfs-&gt;root)) {
1903          return 0;
1904      }
1905      lfs_dir_t pdir = {.d.size = 0x80000000};
1906      lfs_dir_t cwd = {.d.tail[0] = 0, .d.tail[1] = 1};
1907      for (lfs_size_t i = 0; i &lt; lfs-&gt;cfg-&gt;block_count; i++) {
1908          if (lfs_pairisnull(cwd.d.tail)) {
1909              return 0;
1910          }
1911          int err = lfs_dir_fetch(lfs, &amp;cwd, cwd.d.tail);
1912          if (err) {
1913              return err;
1914          }
1915          if (!(0x80000000 &amp; pdir.d.size)) {
1916              lfs_dir_t parent;
1917              lfs_entry_t entry;
1918              int res = lfs_parent(lfs, pdir.d.tail, &amp;parent, &amp;entry);
1919              if (res &lt; 0) {
1920                  return res;
1921              }
1922              if (!res) {
1923                  LFS_DEBUG(&quot;Found orphan %&quot; PRIu32 &quot; %&quot; PRIu32,
1924                          pdir.d.tail[0], pdir.d.tail[1]);
1925                  pdir.d.tail[0] = cwd.d.tail[0];
1926                  pdir.d.tail[1] = cwd.d.tail[1];
1927                  err = lfs_dir_commit(lfs, &amp;pdir, NULL, 0);
1928                  if (err) {
1929                      return err;
1930                  }
1931                  return 0;
1932              }
1933              if (!lfs_pairsync(entry.d.u.dir, pdir.d.tail)) {
1934                  LFS_DEBUG(&quot;Found desync %&quot; PRIu32 &quot; %&quot; PRIu32,
1935                          entry.d.u.dir[0], entry.d.u.dir[1]);
1936                  pdir.d.tail[0] = entry.d.u.dir[0];
1937                  pdir.d.tail[1] = entry.d.u.dir[1];
1938                  err = lfs_dir_commit(lfs, &amp;pdir, NULL, 0);
1939                  if (err) {
1940                      return err;
1941                  }
1942                  return 0;
1943              }
1944          }
1945          lfs_entry_t entry;
1946          while (true) {
1947              err = lfs_dir_next(lfs, &amp;cwd, &amp;entry);
1948              if (err &amp;&amp; err != LFS_ERR_NOENT) {
1949                  return err;
1950              }
1951              if (err == LFS_ERR_NOENT) {
1952                  break;
1953              }
1954              if (entry.d.type &amp; 0x80) {
1955                  int moved = lfs_moved(lfs, &amp;entry.d.u);
1956                  if (moved &lt; 0) {
1957                      return moved;
1958                  }
1959                  if (moved) {
1960                      LFS_DEBUG(&quot;Found move %&quot; PRIu32 &quot; %&quot; PRIu32,
1961                              entry.d.u.dir[0], entry.d.u.dir[1]);
1962                      err = lfs_dir_remove(lfs, &amp;cwd, &amp;entry);
1963                      if (err) {
1964                          return err;
1965                      }
1966                  } else {
1967                      LFS_DEBUG(&quot;Found partial move %&quot; PRIu32 &quot; %&quot; PRIu32,
1968                              entry.d.u.dir[0], entry.d.u.dir[1]);
1969                      entry.d.type &amp;= ~0x80;
1970                      err = lfs_dir_update(lfs, &amp;cwd, &amp;entry, NULL);
1971                      if (err) {
1972                          return err;
1973                      }
1974                  }
1975              }
1976          }
1977          memcpy(&amp;pdir, &amp;cwd, sizeof(pdir));
1978      }
1979      return LFS_ERR_CORRUPT;
1980  }
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-lfs.c</h3>
            <pre><code>1  #include &quot;lfs.h&quot;
2  #include &quot;lfs_util.h&quot;
3  #include &lt;inttypes.h&gt;
4  static int lfs_cache_read(lfs_t *lfs, lfs_cache_t *rcache,
5          const lfs_cache_t *pcache, lfs_block_t block,
6          lfs_off_t off, void *buffer, lfs_size_t size) {
7      uint8_t *data = buffer;
8      LFS_ASSERT(block &lt; lfs-&gt;cfg-&gt;block_count);
9      while (size &gt; 0) {
10          if (pcache &amp;&amp; block == pcache-&gt;block &amp;&amp; off &gt;= pcache-&gt;off &amp;&amp;
11                  off &lt; pcache-&gt;off + lfs-&gt;cfg-&gt;prog_size) {
12              lfs_size_t diff = lfs_min(size,
13                      lfs-&gt;cfg-&gt;prog_size - (off-pcache-&gt;off));
14              memcpy(data, &amp;pcache-&gt;buffer[off-pcache-&gt;off], diff);
15              data += diff;
16              off += diff;
17              size -= diff;
18              continue;
19          }
20          if (block == rcache-&gt;block &amp;&amp; off &gt;= rcache-&gt;off &amp;&amp;
21                  off &lt; rcache-&gt;off + lfs-&gt;cfg-&gt;read_size) {
22              lfs_size_t diff = lfs_min(size,
23                      lfs-&gt;cfg-&gt;read_size - (off-rcache-&gt;off));
24              memcpy(data, &amp;rcache-&gt;buffer[off-rcache-&gt;off], diff);
25              data += diff;
26              off += diff;
27              size -= diff;
28              continue;
29          }
30          if (off % lfs-&gt;cfg-&gt;read_size == 0 &amp;&amp; size &gt;= lfs-&gt;cfg-&gt;read_size) {
31              lfs_size_t diff = size - (size % lfs-&gt;cfg-&gt;read_size);
32              int err = lfs-&gt;cfg-&gt;read(lfs-&gt;cfg, block, off, data, diff);
33              if (err) {
34                  return err;
35              }
36              data += diff;
37              off += diff;
38              size -= diff;
39              continue;
40          }
41          rcache-&gt;block = block;
42          rcache-&gt;off = off - (off % lfs-&gt;cfg-&gt;read_size);
43          int err = lfs-&gt;cfg-&gt;read(lfs-&gt;cfg, rcache-&gt;block,
44                  rcache-&gt;off, rcache-&gt;buffer, lfs-&gt;cfg-&gt;read_size);
45          if (err) {
46              return err;
47          }
48      }
49      return 0;
50  }
51  static int lfs_cache_cmp(lfs_t *lfs, lfs_cache_t *rcache,
52          const lfs_cache_t *pcache, lfs_block_t block,
53          lfs_off_t off, const void *buffer, lfs_size_t size) {
54      const uint8_t *data = buffer;
55      for (lfs_off_t i = 0; i &lt; size; i++) {
56          uint8_t c;
57          int err = lfs_cache_read(lfs, rcache, pcache,
58                  block, off+i, &amp;c, 1);
59          if (err) {
60              return err;
61          }
62          if (c != data[i]) {
63              return false;
64          }
65      }
66      return true;
67  }
68  static int lfs_cache_crc(lfs_t *lfs, lfs_cache_t *rcache,
69          const lfs_cache_t *pcache, lfs_block_t block,
70          lfs_off_t off, lfs_size_t size, uint32_t *crc) {
71      for (lfs_off_t i = 0; i &lt; size; i++) {
72          uint8_t c;
73          int err = lfs_cache_read(lfs, rcache, pcache,
74                  block, off+i, &amp;c, 1);
75          if (err) {
76              return err;
77          }
78          lfs_crc(crc, &amp;c, 1);
79      }
80      return 0;
81  }
82  static inline void lfs_cache_drop(lfs_t *lfs, lfs_cache_t *rcache) {
83      (void)lfs;
84      rcache-&gt;block = 0xffffffff;
85  }
86  static inline void lfs_cache_zero(lfs_t *lfs, lfs_cache_t *pcache) {
87      memset(pcache-&gt;buffer, 0xff, lfs-&gt;cfg-&gt;prog_size);
88      pcache-&gt;block = 0xffffffff;
89  }
90  static int lfs_cache_flush(lfs_t *lfs,
91          lfs_cache_t *pcache, lfs_cache_t *rcache) {
92      if (pcache-&gt;block != 0xffffffff) {
93          int err = lfs-&gt;cfg-&gt;prog(lfs-&gt;cfg, pcache-&gt;block,
94                  pcache-&gt;off, pcache-&gt;buffer, lfs-&gt;cfg-&gt;prog_size);
95          if (err) {
96              return err;
97          }
98          if (rcache) {
99              int res = lfs_cache_cmp(lfs, rcache, NULL, pcache-&gt;block,
100                      pcache-&gt;off, pcache-&gt;buffer, lfs-&gt;cfg-&gt;prog_size);
101              if (res &lt; 0) {
102                  return res;
103              }
104              if (!res) {
105                  return LFS_ERR_CORRUPT;
106              }
107          }
108          lfs_cache_zero(lfs, pcache);
109      }
110      return 0;
111  }
112  static int lfs_cache_prog(lfs_t *lfs, lfs_cache_t *pcache,
113          lfs_cache_t *rcache, lfs_block_t block,
114          lfs_off_t off, const void *buffer, lfs_size_t size) {
115      const uint8_t *data = buffer;
116      LFS_ASSERT(block &lt; lfs-&gt;cfg-&gt;block_count);
117      while (size &gt; 0) {
118          if (block == pcache-&gt;block &amp;&amp; off &gt;= pcache-&gt;off &amp;&amp;
119                  off &lt; pcache-&gt;off + lfs-&gt;cfg-&gt;prog_size) {
120              lfs_size_t diff = lfs_min(size,
121                      lfs-&gt;cfg-&gt;prog_size - (off-pcache-&gt;off));
122              memcpy(&amp;pcache-&gt;buffer[off-pcache-&gt;off], data, diff);
123              data += diff;
124              off += diff;
125              size -= diff;
126              if (off % lfs-&gt;cfg-&gt;prog_size == 0) {
127                  int err = lfs_cache_flush(lfs, pcache, rcache);
128                  if (err) {
129                      return err;
130                  }
131              }
132              continue;
133          }
134          LFS_ASSERT(pcache-&gt;block == 0xffffffff);
135          if (off % lfs-&gt;cfg-&gt;prog_size == 0 &amp;&amp;
136                  size &gt;= lfs-&gt;cfg-&gt;prog_size) {
137              lfs_size_t diff = size - (size % lfs-&gt;cfg-&gt;prog_size);
138              int err = lfs-&gt;cfg-&gt;prog(lfs-&gt;cfg, block, off, data, diff);
139              if (err) {
140                  return err;
141              }
142              if (rcache) {
143                  int res = lfs_cache_cmp(lfs, rcache, NULL,
144                          block, off, data, diff);
145                  if (res &lt; 0) {
146                      return res;
147                  }
148                  if (!res) {
149                      return LFS_ERR_CORRUPT;
150                  }
151              }
152              data += diff;
153              off += diff;
154              size -= diff;
155              continue;
156          }
157          pcache-&gt;block = block;
158          pcache-&gt;off = off - (off % lfs-&gt;cfg-&gt;prog_size);
159      }
160      return 0;
161  }
162  static int lfs_bd_read(lfs_t *lfs, lfs_block_t block,
163          lfs_off_t off, void *buffer, lfs_size_t size) {
164      return lfs_cache_read(lfs, &amp;lfs-&gt;rcache, NULL,
165              block, off, buffer, size);
166  }
167  static int lfs_bd_prog(lfs_t *lfs, lfs_block_t block,
168          lfs_off_t off, const void *buffer, lfs_size_t size) {
169      return lfs_cache_prog(lfs, &amp;lfs-&gt;pcache, NULL,
170              block, off, buffer, size);
171  }
172  static int lfs_bd_cmp(lfs_t *lfs, lfs_block_t block,
173          lfs_off_t off, const void *buffer, lfs_size_t size) {
174      return lfs_cache_cmp(lfs, &amp;lfs-&gt;rcache, NULL, block, off, buffer, size);
175  }
176  static int lfs_bd_crc(lfs_t *lfs, lfs_block_t block,
177          lfs_off_t off, lfs_size_t size, uint32_t *crc) {
178      return lfs_cache_crc(lfs, &amp;lfs-&gt;rcache, NULL, block, off, size, crc);
179  }
180  static int lfs_bd_erase(lfs_t *lfs, lfs_block_t block) {
181      return lfs-&gt;cfg-&gt;erase(lfs-&gt;cfg, block);
182  }
183  static int lfs_bd_sync(lfs_t *lfs) {
184      lfs_cache_drop(lfs, &amp;lfs-&gt;rcache);
185      int err = lfs_cache_flush(lfs, &amp;lfs-&gt;pcache, NULL);
186      if (err) {
187          return err;
188      }
189      return lfs-&gt;cfg-&gt;sync(lfs-&gt;cfg);
190  }
191  int lfs_traverse(lfs_t *lfs, int (*cb)(void*, lfs_block_t), void *data);
192  static int lfs_pred(lfs_t *lfs, const lfs_block_t dir[2], lfs_dir_t *pdir);
193  static int lfs_parent(lfs_t *lfs, const lfs_block_t dir[2],
194          lfs_dir_t *parent, lfs_entry_t *entry);
195  static int lfs_moved(lfs_t *lfs, const void *e);
196  static int lfs_relocate(lfs_t *lfs,
197          const lfs_block_t oldpair[2], const lfs_block_t newpair[2]);
198  int lfs_deorphan(lfs_t *lfs);
199  static int lfs_alloc_lookahead(void *p, lfs_block_t block) {
200      lfs_t *lfs = p;
201      lfs_block_t off = ((block - lfs-&gt;free.off)
202              + lfs-&gt;cfg-&gt;block_count) % lfs-&gt;cfg-&gt;block_count;
203      if (off &lt; lfs-&gt;free.size) {
204          lfs-&gt;free.buffer[off / 32] |= 1U &lt;&lt; (off % 32);
205      }
206      return 0;
207  }
208  static int lfs_alloc(lfs_t *lfs, lfs_block_t *block) {
209      while (true) {
210          while (lfs-&gt;free.i != lfs-&gt;free.size) {
211              lfs_block_t off = lfs-&gt;free.i;
212              lfs-&gt;free.i += 1;
213              lfs-&gt;free.ack -= 1;
214              if (!(lfs-&gt;free.buffer[off / 32] &amp; (1U &lt;&lt; (off % 32)))) {
215                  *block = (lfs-&gt;free.off + off) % lfs-&gt;cfg-&gt;block_count;
216                  while (lfs-&gt;free.i != lfs-&gt;free.size &amp;&amp;
217                          (lfs-&gt;free.buffer[lfs-&gt;free.i / 32]
218                              &amp; (1U &lt;&lt; (lfs-&gt;free.i % 32)))) {
219                      lfs-&gt;free.i += 1;
220                      lfs-&gt;free.ack -= 1;
221                  }
222                  return 0;
223              }
224          }
225          if (lfs-&gt;free.ack == 0) {
226              LFS_WARN(&quot;No more free space %&quot; PRIu32,
227                      lfs-&gt;free.i + lfs-&gt;free.off);
228              return LFS_ERR_NOSPC;
229          }
230          lfs-&gt;free.off = (lfs-&gt;free.off + lfs-&gt;free.size)
231                  % lfs-&gt;cfg-&gt;block_count;
232          lfs-&gt;free.size = lfs_min(lfs-&gt;cfg-&gt;lookahead, lfs-&gt;free.ack);
233          lfs-&gt;free.i = 0;
234          memset(lfs-&gt;free.buffer, 0, lfs-&gt;cfg-&gt;lookahead/8);
235          int err = lfs_traverse(lfs, lfs_alloc_lookahead, lfs);
236          if (err) {
237              return err;
238          }
239      }
240  }
241  static void lfs_alloc_ack(lfs_t *lfs) {
242      lfs-&gt;free.ack = lfs-&gt;cfg-&gt;block_count;
243  }
244  static void lfs_dir_fromle32(struct lfs_disk_dir *d) {
245      d-&gt;rev     = lfs_fromle32(d-&gt;rev);
246      d-&gt;size    = lfs_fromle32(d-&gt;size);
247      d-&gt;tail[0] = lfs_fromle32(d-&gt;tail[0]);
248      d-&gt;tail[1] = lfs_fromle32(d-&gt;tail[1]);
249  }
250  static void lfs_dir_tole32(struct lfs_disk_dir *d) {
251      d-&gt;rev     = lfs_tole32(d-&gt;rev);
252      d-&gt;size    = lfs_tole32(d-&gt;size);
253      d-&gt;tail[0] = lfs_tole32(d-&gt;tail[0]);
254      d-&gt;tail[1] = lfs_tole32(d-&gt;tail[1]);
255  }
256  static void lfs_entry_fromle32(struct lfs_disk_entry *d) {
257      d-&gt;u.dir[0] = lfs_fromle32(d-&gt;u.dir[0]);
258      d-&gt;u.dir[1] = lfs_fromle32(d-&gt;u.dir[1]);
259  }
260  static void lfs_entry_tole32(struct lfs_disk_entry *d) {
261      d-&gt;u.dir[0] = lfs_tole32(d-&gt;u.dir[0]);
262      d-&gt;u.dir[1] = lfs_tole32(d-&gt;u.dir[1]);
263  }
264  static void lfs_superblock_fromle32(struct lfs_disk_superblock *d) {
265      d-&gt;root[0]     = lfs_fromle32(d-&gt;root[0]);
266      d-&gt;root[1]     = lfs_fromle32(d-&gt;root[1]);
267      d-&gt;block_size  = lfs_fromle32(d-&gt;block_size);
268      d-&gt;block_count = lfs_fromle32(d-&gt;block_count);
269      d-&gt;version     = lfs_fromle32(d-&gt;version);
270  }
271  static void lfs_superblock_tole32(struct lfs_disk_superblock *d) {
272      d-&gt;root[0]     = lfs_tole32(d-&gt;root[0]);
273      d-&gt;root[1]     = lfs_tole32(d-&gt;root[1]);
274      d-&gt;block_size  = lfs_tole32(d-&gt;block_size);
275      d-&gt;block_count = lfs_tole32(d-&gt;block_count);
276      d-&gt;version     = lfs_tole32(d-&gt;version);
277  }
278  static inline void lfs_pairswap(lfs_block_t pair[2]) {
279      lfs_block_t t = pair[0];
280      pair[0] = pair[1];
281      pair[1] = t;
282  }
283  static inline bool lfs_pairisnull(const lfs_block_t pair[2]) {
284      return pair[0] == 0xffffffff || pair[1] == 0xffffffff;
285  }
286  static inline int lfs_paircmp(
287          const lfs_block_t paira[2],
288          const lfs_block_t pairb[2]) {
289      return !(paira[0] == pairb[0] || paira[1] == pairb[1] ||
290               paira[0] == pairb[1] || paira[1] == pairb[0]);
291  }
292  static inline bool lfs_pairsync(
293          const lfs_block_t paira[2],
294          const lfs_block_t pairb[2]) {
295      return (paira[0] == pairb[0] &amp;&amp; paira[1] == pairb[1]) ||
296             (paira[0] == pairb[1] &amp;&amp; paira[1] == pairb[0]);
297  }
298  static inline lfs_size_t lfs_entry_size(const lfs_entry_t *entry) {
299      return 4 + entry-&gt;d.elen + entry-&gt;d.alen + entry-&gt;d.nlen;
300  }
301  static int lfs_dir_alloc(lfs_t *lfs, lfs_dir_t *dir) {
302      for (int i = 0; i &lt; 2; i++) {
303          int err = lfs_alloc(lfs, &amp;dir-&gt;pair[i]);
304          if (err) {
305              return err;
306          }
307      }
308      int err = lfs_bd_read(lfs, dir-&gt;pair[0], 0, &amp;dir-&gt;d.rev, 4);
309      if (err &amp;&amp; err != LFS_ERR_CORRUPT) {
310          return err;
311      }
312      if (err != LFS_ERR_CORRUPT) {
313          dir-&gt;d.rev = lfs_fromle32(dir-&gt;d.rev);
314      }
315      dir-&gt;d.rev += 1;
316      dir-&gt;d.size = sizeof(dir-&gt;d)+4;
317      dir-&gt;d.tail[0] = 0xffffffff;
318      dir-&gt;d.tail[1] = 0xffffffff;
319      dir-&gt;off = sizeof(dir-&gt;d);
320      return 0;
321  }
322  static int lfs_dir_fetch(lfs_t *lfs,
323          lfs_dir_t *dir, const lfs_block_t pair[2]) {
324      const lfs_block_t tpair[2] = {pair[0], pair[1]};
325      bool valid = false;
326      for (int i = 0; i &lt; 2; i++) {
327          struct lfs_disk_dir test;
328          int err = lfs_bd_read(lfs, tpair[i], 0, &amp;test, sizeof(test));
329          lfs_dir_fromle32(&amp;test);
330          if (err) {
331              if (err == LFS_ERR_CORRUPT) {
332                  continue;
333              }
334              return err;
335          }
336          if (valid &amp;&amp; lfs_scmp(test.rev, dir-&gt;d.rev) &lt; 0) {
337              continue;
338          }
339          if ((0x7fffffff &amp; test.size) &lt; sizeof(test)+4 ||
340              (0x7fffffff &amp; test.size) &gt; lfs-&gt;cfg-&gt;block_size) {
341              continue;
342          }
343          uint32_t crc = 0xffffffff;
344          lfs_dir_tole32(&amp;test);
345          lfs_crc(&amp;crc, &amp;test, sizeof(test));
346          lfs_dir_fromle32(&amp;test);
347          err = lfs_bd_crc(lfs, tpair[i], sizeof(test),
348                  (0x7fffffff &amp; test.size) - sizeof(test), &amp;crc);
349          if (err) {
350              if (err == LFS_ERR_CORRUPT) {
351                  continue;
352              }
353              return err;
354          }
355          if (crc != 0) {
356              continue;
357          }
358          valid = true;
359          dir-&gt;pair[0] = tpair[(i+0) % 2];
360          dir-&gt;pair[1] = tpair[(i+1) % 2];
361          dir-&gt;off = sizeof(dir-&gt;d);
362          dir-&gt;d = test;
363      }
364      if (!valid) {
365          LFS_ERROR(&quot;Corrupted dir pair at %&quot; PRIu32 &quot; %&quot; PRIu32 ,
366                  tpair[0], tpair[1]);
367          return LFS_ERR_CORRUPT;
368      }
369      return 0;
370  }
371  struct lfs_region {
372      lfs_off_t oldoff;
373      lfs_size_t oldlen;
374      const void *newdata;
375      lfs_size_t newlen;
376  };
377  static int lfs_dir_commit(lfs_t *lfs, lfs_dir_t *dir,
378          const struct lfs_region *regions, int count) {
379      dir-&gt;d.rev += 1;
380      lfs_pairswap(dir-&gt;pair);
381      for (int i = 0; i &lt; count; i++) {
382          dir-&gt;d.size += regions[i].newlen - regions[i].oldlen;
383      }
384      const lfs_block_t oldpair[2] = {dir-&gt;pair[0], dir-&gt;pair[1]};
385      bool relocated = false;
386      while (true) {
387          if (true) {
388              int err = lfs_bd_erase(lfs, dir-&gt;pair[0]);
389              if (err) {
390                  if (err == LFS_ERR_CORRUPT) {
391                      goto relocate;
392                  }
393                  return err;
394              }
395              uint32_t crc = 0xffffffff;
396              lfs_dir_tole32(&amp;dir-&gt;d);
397              lfs_crc(&amp;crc, &amp;dir-&gt;d, sizeof(dir-&gt;d));
398              err = lfs_bd_prog(lfs, dir-&gt;pair[0], 0, &amp;dir-&gt;d, sizeof(dir-&gt;d));
399              lfs_dir_fromle32(&amp;dir-&gt;d);
400              if (err) {
401                  if (err == LFS_ERR_CORRUPT) {
402                      goto relocate;
403                  }
404                  return err;
405              }
406              int i = 0;
407              lfs_off_t oldoff = sizeof(dir-&gt;d);
408              lfs_off_t newoff = sizeof(dir-&gt;d);
409              while (newoff &lt; (0x7fffffff &amp; dir-&gt;d.size)-4) {
410                  if (i &lt; count &amp;&amp; regions[i].oldoff == oldoff) {
411                      lfs_crc(&amp;crc, regions[i].newdata, regions[i].newlen);
412                      err = lfs_bd_prog(lfs, dir-&gt;pair[0],
413                              newoff, regions[i].newdata, regions[i].newlen);
414                      if (err) {
415                          if (err == LFS_ERR_CORRUPT) {
416                              goto relocate;
417                          }
418                          return err;
419                      }
420                      oldoff += regions[i].oldlen;
421                      newoff += regions[i].newlen;
422                      i += 1;
423                  } else {
424                      uint8_t data;
425                      err = lfs_bd_read(lfs, oldpair[1], oldoff, &amp;data, 1);
426                      if (err) {
427                          return err;
428                      }
429                      lfs_crc(&amp;crc, &amp;data, 1);
430                      err = lfs_bd_prog(lfs, dir-&gt;pair[0], newoff, &amp;data, 1);
431                      if (err) {
432                          if (err == LFS_ERR_CORRUPT) {
433                              goto relocate;
434                          }
435                          return err;
436                      }
437                      oldoff += 1;
438                      newoff += 1;
439                  }
440              }
441              crc = lfs_tole32(crc);
442              err = lfs_bd_prog(lfs, dir-&gt;pair[0], newoff, &amp;crc, 4);
443              crc = lfs_fromle32(crc);
444              if (err) {
445                  if (err == LFS_ERR_CORRUPT) {
446                      goto relocate;
447                  }
448                  return err;
449              }
450              err = lfs_bd_sync(lfs);
451              if (err) {
452                  if (err == LFS_ERR_CORRUPT) {
453                      goto relocate;
454                  }
455                  return err;
456              }
457              uint32_t ncrc = 0xffffffff;
458              err = lfs_bd_crc(lfs, dir-&gt;pair[0], 0,
459                      (0x7fffffff &amp; dir-&gt;d.size)-4, &amp;ncrc);
460              if (err) {
461                  return err;
462              }
463              if (ncrc != crc) {
464                  goto relocate;
465              }
466          }
467          break;
468  relocate:
469          LFS_DEBUG(&quot;Bad block at %&quot; PRIu32, dir-&gt;pair[0]);
470          relocated = true;
471          lfs_cache_drop(lfs, &amp;lfs-&gt;pcache);
472          if (lfs_paircmp(oldpair, (const lfs_block_t[2]){0, 1}) == 0) {
473              LFS_WARN(&quot;Superblock %&quot; PRIu32 &quot; has become unwritable&quot;,
474                      oldpair[0]);
475              return LFS_ERR_CORRUPT;
476          }
477          int err = lfs_alloc(lfs, &amp;dir-&gt;pair[0]);
478          if (err) {
479              return err;
480          }
481      }
482      if (relocated) {
483          LFS_DEBUG(&quot;Relocating %&quot; PRIu32 &quot; %&quot; PRIu32 &quot; to %&quot; PRIu32 &quot; %&quot; PRIu32,
484                  oldpair[0], oldpair[1], dir-&gt;pair[0], dir-&gt;pair[1]);
485          int err = lfs_relocate(lfs, oldpair, dir-&gt;pair);
486          if (err) {
487              return err;
488          }
489      }
490      for (lfs_dir_t *d = lfs-&gt;dirs; d; d = d-&gt;next) {
491          if (lfs_paircmp(d-&gt;pair, dir-&gt;pair) == 0) {
492              d-&gt;pair[0] = dir-&gt;pair[0];
493              d-&gt;pair[1] = dir-&gt;pair[1];
494          }
495      }
496      return 0;
497  }
498  static int lfs_dir_update(lfs_t *lfs, lfs_dir_t *dir,
499          lfs_entry_t *entry, const void *data) {
500      lfs_entry_tole32(&amp;entry-&gt;d);
501      int err = lfs_dir_commit(lfs, dir, (struct lfs_region[]){
502              {entry-&gt;off, sizeof(entry-&gt;d), &amp;entry-&gt;d, sizeof(entry-&gt;d)},
503              {entry-&gt;off+sizeof(entry-&gt;d), entry-&gt;d.nlen, data, entry-&gt;d.nlen}
504          }, data ? 2 : 1);
505      lfs_entry_fromle32(&amp;entry-&gt;d);
506      return err;
507  }
508  static int lfs_dir_append(lfs_t *lfs, lfs_dir_t *dir,
509          lfs_entry_t *entry, const void *data) {
510      while (true) {
511          if (dir-&gt;d.size + lfs_entry_size(entry) &lt;= lfs-&gt;cfg-&gt;block_size) {
512              entry-&gt;off = dir-&gt;d.size - 4;
513              lfs_entry_tole32(&amp;entry-&gt;d);
514              int err = lfs_dir_commit(lfs, dir, (struct lfs_region[]){
515                      {entry-&gt;off, 0, &amp;entry-&gt;d, sizeof(entry-&gt;d)},
516                      {entry-&gt;off, 0, data, entry-&gt;d.nlen}
517                  }, 2);
518              lfs_entry_fromle32(&amp;entry-&gt;d);
519              return err;
520          }
521          if (!(0x80000000 &amp; dir-&gt;d.size)) {
522              lfs_dir_t olddir = *dir;
523              int err = lfs_dir_alloc(lfs, dir);
524              if (err) {
525                  return err;
526              }
527              dir-&gt;d.tail[0] = olddir.d.tail[0];
528              dir-&gt;d.tail[1] = olddir.d.tail[1];
<span onclick='openModal()' class='match'>529              entry-&gt;off = dir-&gt;d.size - 4;
530              lfs_entry_tole32(&amp;entry-&gt;d);
531              err = lfs_dir_commit(lfs, dir, (struct lfs_region[]){
</span>532                      {entry-&gt;off, 0, &amp;entry-&gt;d, sizeof(entry-&gt;d)},
533                      {entry-&gt;off, 0, data, entry-&gt;d.nlen}
534                  }, 2);
535              lfs_entry_fromle32(&amp;entry-&gt;d);
536              if (err) {
537                  return err;
538              }
539              olddir.d.size |= 0x80000000;
540              olddir.d.tail[0] = dir-&gt;pair[0];
541              olddir.d.tail[1] = dir-&gt;pair[1];
542              return lfs_dir_commit(lfs, &amp;olddir, NULL, 0);
543          }
544          int err = lfs_dir_fetch(lfs, dir, dir-&gt;d.tail);
545          if (err) {
546              return err;
547          }
548      }
549  }
550  static int lfs_dir_remove(lfs_t *lfs, lfs_dir_t *dir, lfs_entry_t *entry) {
551      if ((dir-&gt;d.size &amp; 0x7fffffff) == sizeof(dir-&gt;d)+4
552              + lfs_entry_size(entry)) {
553          lfs_dir_t pdir;
554          int res = lfs_pred(lfs, dir-&gt;pair, &amp;pdir);
555          if (res &lt; 0) {
556              return res;
557          }
558          if (pdir.d.size &amp; 0x80000000) {
559              pdir.d.size &amp;= dir-&gt;d.size | 0x7fffffff;
560              pdir.d.tail[0] = dir-&gt;d.tail[0];
561              pdir.d.tail[1] = dir-&gt;d.tail[1];
562              return lfs_dir_commit(lfs, &amp;pdir, NULL, 0);
563          }
564      }
565      int err = lfs_dir_commit(lfs, dir, (struct lfs_region[]){
566              {entry-&gt;off, lfs_entry_size(entry), NULL, 0},
567          }, 1);
568      if (err) {
569          return err;
570      }
571      for (lfs_file_t *f = lfs-&gt;files; f; f = f-&gt;next) {
572          if (lfs_paircmp(f-&gt;pair, dir-&gt;pair) == 0) {
573              if (f-&gt;poff == entry-&gt;off) {
574                  f-&gt;pair[0] = 0xffffffff;
575                  f-&gt;pair[1] = 0xffffffff;
576              } else if (f-&gt;poff &gt; entry-&gt;off) {
577                  f-&gt;poff -= lfs_entry_size(entry);
578              }
579          }
580      }
581      for (lfs_dir_t *d = lfs-&gt;dirs; d; d = d-&gt;next) {
582          if (lfs_paircmp(d-&gt;pair, dir-&gt;pair) == 0) {
583              if (d-&gt;off &gt; entry-&gt;off) {
584                  d-&gt;off -= lfs_entry_size(entry);
585                  d-&gt;pos -= lfs_entry_size(entry);
586              }
587          }
588      }
589      return 0;
590  }
591  static int lfs_dir_next(lfs_t *lfs, lfs_dir_t *dir, lfs_entry_t *entry) {
592      while (dir-&gt;off + sizeof(entry-&gt;d) &gt; (0x7fffffff &amp; dir-&gt;d.size)-4) {
593          if (!(0x80000000 &amp; dir-&gt;d.size)) {
594              entry-&gt;off = dir-&gt;off;
595              return LFS_ERR_NOENT;
596          }
597          int err = lfs_dir_fetch(lfs, dir, dir-&gt;d.tail);
598          if (err) {
599              return err;
600          }
601          dir-&gt;off = sizeof(dir-&gt;d);
602          dir-&gt;pos += sizeof(dir-&gt;d) + 4;
603      }
604      int err = lfs_bd_read(lfs, dir-&gt;pair[0], dir-&gt;off,
605              &amp;entry-&gt;d, sizeof(entry-&gt;d));
606      lfs_entry_fromle32(&amp;entry-&gt;d);
607      if (err) {
608          return err;
609      }
610      entry-&gt;off = dir-&gt;off;
611      dir-&gt;off += lfs_entry_size(entry);
612      dir-&gt;pos += lfs_entry_size(entry);
613      return 0;
614  }
615  static int lfs_dir_find(lfs_t *lfs, lfs_dir_t *dir,
616          lfs_entry_t *entry, const char **path) {
617      const char *pathname = *path;
618      size_t pathlen;
619      entry-&gt;d.type = LFS_TYPE_DIR;
620      entry-&gt;d.elen = sizeof(entry-&gt;d) - 4;
621      entry-&gt;d.alen = 0;
622      entry-&gt;d.nlen = 0;
623      entry-&gt;d.u.dir[0] = lfs-&gt;root[0];
624      entry-&gt;d.u.dir[1] = lfs-&gt;root[1];
625      while (true) {
626  nextname:
627          pathname += strspn(pathname, &quot;/&quot;);
628          pathlen = strcspn(pathname, &quot;/&quot;);
629          if ((pathlen == 1 &amp;&amp; memcmp(pathname, &quot;.&quot;, 1) == 0) ||
630              (pathlen == 2 &amp;&amp; memcmp(pathname, &quot;..&quot;, 2) == 0)) {
631              pathname += pathlen;
632              goto nextname;
633          }
634          const char *suffix = pathname + pathlen;
635          size_t sufflen;
636          int depth = 1;
637          while (true) {
638              suffix += strspn(suffix, &quot;/&quot;);
639              sufflen = strcspn(suffix, &quot;/&quot;);
640              if (sufflen == 0) {
641                  break;
642              }
643              if (sufflen == 2 &amp;&amp; memcmp(suffix, &quot;..&quot;, 2) == 0) {
644                  depth -= 1;
645                  if (depth == 0) {
646                      pathname = suffix + sufflen;
647                      goto nextname;
648                  }
649              } else {
650                  depth += 1;
651              }
652              suffix += sufflen;
653          }
654          if (pathname[0] == &#x27;\0&#x27;) {
655              return 0;
656          }
657          *path = pathname;
658          if (entry-&gt;d.type != LFS_TYPE_DIR) {
659              return LFS_ERR_NOTDIR;
660          }
661          int err = lfs_dir_fetch(lfs, dir, entry-&gt;d.u.dir);
662          if (err) {
663              return err;
664          }
665          while (true) {
666              err = lfs_dir_next(lfs, dir, entry);
667              if (err) {
668                  return err;
669              }
670              if (((0x7f &amp; entry-&gt;d.type) != LFS_TYPE_REG &amp;&amp;
671                   (0x7f &amp; entry-&gt;d.type) != LFS_TYPE_DIR) ||
672                  entry-&gt;d.nlen != pathlen) {
673                  continue;
674              }
675              int res = lfs_bd_cmp(lfs, dir-&gt;pair[0],
676                      entry-&gt;off + 4+entry-&gt;d.elen+entry-&gt;d.alen,
677                      pathname, pathlen);
678              if (res &lt; 0) {
679                  return res;
680              }
681              if (res) {
682                  break;
683              }
684          }
685          if (entry-&gt;d.type &amp; 0x80) {
686              int moved = lfs_moved(lfs, &amp;entry-&gt;d.u);
687              if (moved &lt; 0 || moved) {
688                  return (moved &lt; 0) ? moved : LFS_ERR_NOENT;
689              }
690              entry-&gt;d.type &amp;= ~0x80;
691          }
692          pathname += pathlen;
693      }
694  }
695  int lfs_mkdir(lfs_t *lfs, const char *path) {
696      if (!lfs-&gt;deorphaned) {
697          int err = lfs_deorphan(lfs);
698          if (err) {
699              return err;
700          }
701      }
702      lfs_dir_t cwd;
703      lfs_entry_t entry;
704      int err = lfs_dir_find(lfs, &amp;cwd, &amp;entry, &amp;path);
705      if (err != LFS_ERR_NOENT || strchr(path, &#x27;/&#x27;) != NULL) {
706          return err ? err : LFS_ERR_EXIST;
707      }
708      lfs_alloc_ack(lfs);
709      lfs_dir_t dir;
710      err = lfs_dir_alloc(lfs, &amp;dir);
711      if (err) {
712          return err;
713      }
714      dir.d.tail[0] = cwd.d.tail[0];
715      dir.d.tail[1] = cwd.d.tail[1];
716      err = lfs_dir_commit(lfs, &amp;dir, NULL, 0);
717      if (err) {
718          return err;
719      }
720      entry.d.type = LFS_TYPE_DIR;
721      entry.d.elen = sizeof(entry.d) - 4;
722      entry.d.alen = 0;
723      entry.d.nlen = strlen(path);
724      entry.d.u.dir[0] = dir.pair[0];
725      entry.d.u.dir[1] = dir.pair[1];
726      cwd.d.tail[0] = dir.pair[0];
727      cwd.d.tail[1] = dir.pair[1];
728      err = lfs_dir_append(lfs, &amp;cwd, &amp;entry, path);
729      if (err) {
730          return err;
731      }
732      lfs_alloc_ack(lfs);
733      return 0;
734  }
735  int lfs_dir_open(lfs_t *lfs, lfs_dir_t *dir, const char *path) {
736      dir-&gt;pair[0] = lfs-&gt;root[0];
737      dir-&gt;pair[1] = lfs-&gt;root[1];
738      lfs_entry_t entry;
739      int err = lfs_dir_find(lfs, dir, &amp;entry, &amp;path);
740      if (err) {
741          return err;
742      } else if (entry.d.type != LFS_TYPE_DIR) {
743          return LFS_ERR_NOTDIR;
744      }
745      err = lfs_dir_fetch(lfs, dir, entry.d.u.dir);
746      if (err) {
747          return err;
748      }
749      dir-&gt;head[0] = dir-&gt;pair[0];
750      dir-&gt;head[1] = dir-&gt;pair[1];
751      dir-&gt;pos = sizeof(dir-&gt;d) - 2;
752      dir-&gt;off = sizeof(dir-&gt;d);
753      dir-&gt;next = lfs-&gt;dirs;
754      lfs-&gt;dirs = dir;
755      return 0;
756  }
757  int lfs_dir_close(lfs_t *lfs, lfs_dir_t *dir) {
758      for (lfs_dir_t **p = &amp;lfs-&gt;dirs; *p; p = &amp;(*p)-&gt;next) {
759          if (*p == dir) {
760              *p = dir-&gt;next;
761              break;
762          }
763      }
764      return 0;
765  }
766  int lfs_dir_read(lfs_t *lfs, lfs_dir_t *dir, struct lfs_info *info) {
767      memset(info, 0, sizeof(*info));
768      if (dir-&gt;pos == sizeof(dir-&gt;d) - 2) {
769          info-&gt;type = LFS_TYPE_DIR;
770          strcpy(info-&gt;name, &quot;.&quot;);
771          dir-&gt;pos += 1;
772          return 1;
773      } else if (dir-&gt;pos == sizeof(dir-&gt;d) - 1) {
774          info-&gt;type = LFS_TYPE_DIR;
775          strcpy(info-&gt;name, &quot;..&quot;);
776          dir-&gt;pos += 1;
777          return 1;
778      }
779      lfs_entry_t entry;
780      while (true) {
781          int err = lfs_dir_next(lfs, dir, &amp;entry);
782          if (err) {
783              return (err == LFS_ERR_NOENT) ? 0 : err;
784          }
785          if ((0x7f &amp; entry.d.type) != LFS_TYPE_REG &amp;&amp;
786              (0x7f &amp; entry.d.type) != LFS_TYPE_DIR) {
787              continue;
788          }
789          if (entry.d.type &amp; 0x80) {
790              int moved = lfs_moved(lfs, &amp;entry.d.u);
791              if (moved &lt; 0) {
792                  return moved;
793              }
794              if (moved) {
795                  continue;
796              }
797              entry.d.type &amp;= ~0x80;
798          }
799          break;
800      }
801      info-&gt;type = entry.d.type;
802      if (info-&gt;type == LFS_TYPE_REG) {
803          info-&gt;size = entry.d.u.file.size;
804      }
805      int err = lfs_bd_read(lfs, dir-&gt;pair[0],
806              entry.off + 4+entry.d.elen+entry.d.alen,
807              info-&gt;name, entry.d.nlen);
808      if (err) {
809          return err;
810      }
811      return 1;
812  }
813  int lfs_dir_seek(lfs_t *lfs, lfs_dir_t *dir, lfs_off_t off) {
814      int err = lfs_dir_rewind(lfs, dir);
815      if (err) {
816          return err;
817      }
818      dir-&gt;pos = off;
819      while (off &gt; (0x7fffffff &amp; dir-&gt;d.size)) {
820          off -= 0x7fffffff &amp; dir-&gt;d.size;
821          if (!(0x80000000 &amp; dir-&gt;d.size)) {
822              return LFS_ERR_INVAL;
823          }
824          err = lfs_dir_fetch(lfs, dir, dir-&gt;d.tail);
825          if (err) {
826              return err;
827          }
828      }
829      dir-&gt;off = off;
830      return 0;
831  }
832  lfs_soff_t lfs_dir_tell(lfs_t *lfs, lfs_dir_t *dir) {
833      (void)lfs;
834      return dir-&gt;pos;
835  }
836  int lfs_dir_rewind(lfs_t *lfs, lfs_dir_t *dir) {
837      int err = lfs_dir_fetch(lfs, dir, dir-&gt;head);
838      if (err) {
839          return err;
840      }
841      dir-&gt;pair[0] = dir-&gt;head[0];
842      dir-&gt;pair[1] = dir-&gt;head[1];
843      dir-&gt;pos = sizeof(dir-&gt;d) - 2;
844      dir-&gt;off = sizeof(dir-&gt;d);
845      return 0;
846  }
847  static int lfs_ctz_index(lfs_t *lfs, lfs_off_t *off) {
848      lfs_off_t size = *off;
849      lfs_off_t b = lfs-&gt;cfg-&gt;block_size - 2*4;
850      lfs_off_t i = size / b;
851      if (i == 0) {
852          return 0;
853      }
854      i = (size - 4*(lfs_popc(i-1)+2)) / b;
855      *off = size - b*i - 4*lfs_popc(i);
856      return i;
857  }
858  static int lfs_ctz_find(lfs_t *lfs,
859          lfs_cache_t *rcache, const lfs_cache_t *pcache,
860          lfs_block_t head, lfs_size_t size,
861          lfs_size_t pos, lfs_block_t *block, lfs_off_t *off) {
862      if (size == 0) {
863          *block = 0xffffffff;
864          *off = 0;
865          return 0;
866      }
867      lfs_off_t current = lfs_ctz_index(lfs, &amp;(lfs_off_t){size-1});
868      lfs_off_t target = lfs_ctz_index(lfs, &amp;pos);
869      while (current &gt; target) {
870          lfs_size_t skip = lfs_min(
871                  lfs_npw2(current-target+1) - 1,
872                  lfs_ctz(current));
873          int err = lfs_cache_read(lfs, rcache, pcache, head, 4*skip, &amp;head, 4);
874          head = lfs_fromle32(head);
875          if (err) {
876              return err;
877          }
878          LFS_ASSERT(head &gt;= 2 &amp;&amp; head &lt;= lfs-&gt;cfg-&gt;block_count);
879          current -= 1 &lt;&lt; skip;
880      }
881      *block = head;
882      *off = pos;
883      return 0;
884  }
885  static int lfs_ctz_extend(lfs_t *lfs,
886          lfs_cache_t *rcache, lfs_cache_t *pcache,
887          lfs_block_t head, lfs_size_t size,
888          lfs_block_t *block, lfs_off_t *off) {
889      while (true) {
890          lfs_block_t nblock;
891          int err = lfs_alloc(lfs, &amp;nblock);
892          if (err) {
893              return err;
894          }
895          LFS_ASSERT(nblock &gt;= 2 &amp;&amp; nblock &lt;= lfs-&gt;cfg-&gt;block_count);
896          if (true) {
897              err = lfs_bd_erase(lfs, nblock);
898              if (err) {
899                  if (err == LFS_ERR_CORRUPT) {
900                      goto relocate;
901                  }
902                  return err;
903              }
904              if (size == 0) {
905                  *block = nblock;
906                  *off = 0;
907                  return 0;
908              }
909              size -= 1;
910              lfs_off_t index = lfs_ctz_index(lfs, &amp;size);
911              size += 1;
912              if (size != lfs-&gt;cfg-&gt;block_size) {
913                  for (lfs_off_t i = 0; i &lt; size; i++) {
914                      uint8_t data;
915                      err = lfs_cache_read(lfs, rcache, NULL,
916                              head, i, &amp;data, 1);
917                      if (err) {
918                          return err;
919                      }
920                      err = lfs_cache_prog(lfs, pcache, rcache,
921                              nblock, i, &amp;data, 1);
922                      if (err) {
923                          if (err == LFS_ERR_CORRUPT) {
924                              goto relocate;
925                          }
926                          return err;
927                      }
928                  }
929                  *block = nblock;
930                  *off = size;
931                  return 0;
932              }
933              index += 1;
934              lfs_size_t skips = lfs_ctz(index) + 1;
935              for (lfs_off_t i = 0; i &lt; skips; i++) {
936                  head = lfs_tole32(head);
937                  err = lfs_cache_prog(lfs, pcache, rcache,
938                          nblock, 4*i, &amp;head, 4);
939                  head = lfs_fromle32(head);
940                  if (err) {
941                      if (err == LFS_ERR_CORRUPT) {
942                          goto relocate;
943                      }
944                      return err;
945                  }
946                  if (i != skips-1) {
947                      err = lfs_cache_read(lfs, rcache, NULL,
948                              head, 4*i, &amp;head, 4);
949                      head = lfs_fromle32(head);
950                      if (err) {
951                          return err;
952                      }
953                  }
954                  LFS_ASSERT(head &gt;= 2 &amp;&amp; head &lt;= lfs-&gt;cfg-&gt;block_count);
955              }
956              *block = nblock;
957              *off = 4*skips;
958              return 0;
959          }
960  relocate:
961          LFS_DEBUG(&quot;Bad block at %&quot; PRIu32, nblock);
962          lfs_cache_drop(lfs, &amp;lfs-&gt;pcache);
963      }
964  }
965  static int lfs_ctz_traverse(lfs_t *lfs,
966          lfs_cache_t *rcache, const lfs_cache_t *pcache,
967          lfs_block_t head, lfs_size_t size,
968          int (*cb)(void*, lfs_block_t), void *data) {
969      if (size == 0) {
970          return 0;
971      }
972      lfs_off_t index = lfs_ctz_index(lfs, &amp;(lfs_off_t){size-1});
973      while (true) {
974          int err = cb(data, head);
975          if (err) {
976              return err;
977          }
978          if (index == 0) {
979              return 0;
980          }
981          lfs_block_t heads[2];
982          int count = 2 - (index &amp; 1);
983          err = lfs_cache_read(lfs, rcache, pcache, head, 0, &amp;heads, count*4);
984          heads[0] = lfs_fromle32(heads[0]);
985          heads[1] = lfs_fromle32(heads[1]);
986          if (err) {
987              return err;
988          }
989          for (int i = 0; i &lt; count-1; i++) {
990              err = cb(data, heads[i]);
991              if (err) {
992                  return err;
993              }
994          }
995          head = heads[count-1];
996          index -= count;
997      }
998  }
999  int lfs_file_opencfg(lfs_t *lfs, lfs_file_t *file,
1000          const char *path, int flags,
1001          const struct lfs_file_config *cfg) {
1002      if ((flags &amp; 3) != LFS_O_RDONLY &amp;&amp; !lfs-&gt;deorphaned) {
1003          int err = lfs_deorphan(lfs);
1004          if (err) {
1005              return err;
1006          }
1007      }
1008      lfs_dir_t cwd;
1009      lfs_entry_t entry;
1010      int err = lfs_dir_find(lfs, &amp;cwd, &amp;entry, &amp;path);
1011      if (err &amp;&amp; (err != LFS_ERR_NOENT || strchr(path, &#x27;/&#x27;) != NULL)) {
1012          return err;
1013      }
1014      if (err == LFS_ERR_NOENT) {
1015          if (!(flags &amp; LFS_O_CREAT)) {
1016              return LFS_ERR_NOENT;
1017          }
1018          entry.d.type = LFS_TYPE_REG;
1019          entry.d.elen = sizeof(entry.d) - 4;
1020          entry.d.alen = 0;
1021          entry.d.nlen = strlen(path);
1022          entry.d.u.file.head = 0xffffffff;
1023          entry.d.u.file.size = 0;
1024          err = lfs_dir_append(lfs, &amp;cwd, &amp;entry, path);
1025          if (err) {
1026              return err;
1027          }
1028      } else if (entry.d.type == LFS_TYPE_DIR) {
1029          return LFS_ERR_ISDIR;
1030      } else if (flags &amp; LFS_O_EXCL) {
1031          return LFS_ERR_EXIST;
1032      }
1033      file-&gt;cfg = cfg;
1034      file-&gt;pair[0] = cwd.pair[0];
1035      file-&gt;pair[1] = cwd.pair[1];
1036      file-&gt;poff = entry.off;
1037      file-&gt;head = entry.d.u.file.head;
1038      file-&gt;size = entry.d.u.file.size;
1039      file-&gt;flags = flags;
1040      file-&gt;pos = 0;
1041      if (flags &amp; LFS_O_TRUNC) {
1042          if (file-&gt;size != 0) {
1043              file-&gt;flags |= LFS_F_DIRTY;
1044          }
1045          file-&gt;head = 0xffffffff;
1046          file-&gt;size = 0;
1047      }
1048      file-&gt;cache.block = 0xffffffff;
1049      if (file-&gt;cfg &amp;&amp; file-&gt;cfg-&gt;buffer) {
1050          file-&gt;cache.buffer = file-&gt;cfg-&gt;buffer;
1051      } else if (lfs-&gt;cfg-&gt;file_buffer) {
1052          if (lfs-&gt;files) {
1053              return LFS_ERR_NOMEM;
1054          }
1055          file-&gt;cache.buffer = lfs-&gt;cfg-&gt;file_buffer;
1056      } else if ((file-&gt;flags &amp; 3) == LFS_O_RDONLY) {
1057          file-&gt;cache.buffer = lfs_malloc(lfs-&gt;cfg-&gt;read_size);
1058          if (!file-&gt;cache.buffer) {
1059              return LFS_ERR_NOMEM;
1060          }
1061      } else {
1062          file-&gt;cache.buffer = lfs_malloc(lfs-&gt;cfg-&gt;prog_size);
1063          if (!file-&gt;cache.buffer) {
1064              return LFS_ERR_NOMEM;
1065          }
1066      }
1067      lfs_cache_drop(lfs, &amp;file-&gt;cache);
1068      if ((file-&gt;flags &amp; 3) != LFS_O_RDONLY) {
1069          lfs_cache_zero(lfs, &amp;file-&gt;cache);
1070      }
1071      file-&gt;next = lfs-&gt;files;
1072      lfs-&gt;files = file;
1073      return 0;
1074  }
1075  int lfs_file_open(lfs_t *lfs, lfs_file_t *file,
1076          const char *path, int flags) {
1077      return lfs_file_opencfg(lfs, file, path, flags, NULL);
1078  }
1079  int lfs_file_close(lfs_t *lfs, lfs_file_t *file) {
1080      int err = lfs_file_sync(lfs, file);
1081      for (lfs_file_t **p = &amp;lfs-&gt;files; *p; p = &amp;(*p)-&gt;next) {
1082          if (*p == file) {
1083              *p = file-&gt;next;
1084              break;
1085          }
1086      }
1087      if (!(file-&gt;cfg &amp;&amp; file-&gt;cfg-&gt;buffer) &amp;&amp; !lfs-&gt;cfg-&gt;file_buffer) {
1088          lfs_free(file-&gt;cache.buffer);
1089      }
1090      return err;
1091  }
1092  static int lfs_file_relocate(lfs_t *lfs, lfs_file_t *file) {
1093  relocate:
1094      LFS_DEBUG(&quot;Bad block at %&quot; PRIu32, file-&gt;block);
1095      lfs_block_t nblock;
1096      int err = lfs_alloc(lfs, &amp;nblock);
1097      if (err) {
1098          return err;
1099      }
1100      err = lfs_bd_erase(lfs, nblock);
1101      if (err) {
1102          if (err == LFS_ERR_CORRUPT) {
1103              goto relocate;
1104          }
1105          return err;
1106      }
1107      for (lfs_off_t i = 0; i &lt; file-&gt;off; i++) {
1108          uint8_t data;
1109          err = lfs_cache_read(lfs, &amp;lfs-&gt;rcache, &amp;file-&gt;cache,
1110                  file-&gt;block, i, &amp;data, 1);
1111          if (err) {
1112              return err;
1113          }
1114          err = lfs_cache_prog(lfs, &amp;lfs-&gt;pcache, &amp;lfs-&gt;rcache,
1115                  nblock, i, &amp;data, 1);
1116          if (err) {
1117              if (err == LFS_ERR_CORRUPT) {
1118                  goto relocate;
1119              }
1120              return err;
1121          }
1122      }
1123      memcpy(file-&gt;cache.buffer, lfs-&gt;pcache.buffer, lfs-&gt;cfg-&gt;prog_size);
1124      file-&gt;cache.block = lfs-&gt;pcache.block;
1125      file-&gt;cache.off = lfs-&gt;pcache.off;
1126      lfs_cache_zero(lfs, &amp;lfs-&gt;pcache);
1127      file-&gt;block = nblock;
1128      return 0;
1129  }
1130  static int lfs_file_flush(lfs_t *lfs, lfs_file_t *file) {
1131      if (file-&gt;flags &amp; LFS_F_READING) {
1132          lfs_cache_drop(lfs, &amp;file-&gt;cache);
1133          file-&gt;flags &amp;= ~LFS_F_READING;
1134      }
1135      if (file-&gt;flags &amp; LFS_F_WRITING) {
1136          lfs_off_t pos = file-&gt;pos;
1137          lfs_file_t orig = {
1138              .head = file-&gt;head,
1139              .size = file-&gt;size,
1140              .flags = LFS_O_RDONLY,
1141              .pos = file-&gt;pos,
1142              .cache = lfs-&gt;rcache,
1143          };
1144          lfs_cache_drop(lfs, &amp;lfs-&gt;rcache);
1145          while (file-&gt;pos &lt; file-&gt;size) {
1146              uint8_t data;
1147              lfs_ssize_t res = lfs_file_read(lfs, &amp;orig, &amp;data, 1);
1148              if (res &lt; 0) {
1149                  return res;
1150              }
1151              res = lfs_file_write(lfs, file, &amp;data, 1);
1152              if (res &lt; 0) {
1153                  return res;
1154              }
1155              if (lfs-&gt;rcache.block != 0xffffffff) {
1156                  lfs_cache_drop(lfs, &amp;orig.cache);
1157                  lfs_cache_drop(lfs, &amp;lfs-&gt;rcache);
1158              }
1159          }
1160          while (true) {
1161              int err = lfs_cache_flush(lfs, &amp;file-&gt;cache, &amp;lfs-&gt;rcache);
1162              if (err) {
1163                  if (err == LFS_ERR_CORRUPT) {
1164                      goto relocate;
1165                  }
1166                  return err;
1167              }
1168              break;
1169  relocate:
1170              err = lfs_file_relocate(lfs, file);
1171              if (err) {
1172                  return err;
1173              }
1174          }
1175          file-&gt;head = file-&gt;block;
1176          file-&gt;size = file-&gt;pos;
1177          file-&gt;flags &amp;= ~LFS_F_WRITING;
1178          file-&gt;flags |= LFS_F_DIRTY;
1179          file-&gt;pos = pos;
1180      }
1181      return 0;
1182  }
1183  int lfs_file_sync(lfs_t *lfs, lfs_file_t *file) {
1184      int err = lfs_file_flush(lfs, file);
1185      if (err) {
1186          return err;
1187      }
1188      if ((file-&gt;flags &amp; LFS_F_DIRTY) &amp;&amp;
1189              !(file-&gt;flags &amp; LFS_F_ERRED) &amp;&amp;
1190              !lfs_pairisnull(file-&gt;pair)) {
1191          lfs_dir_t cwd;
1192          err = lfs_dir_fetch(lfs, &amp;cwd, file-&gt;pair);
1193          if (err) {
1194              return err;
1195          }
1196          lfs_entry_t entry = {.off = file-&gt;poff};
1197          err = lfs_bd_read(lfs, cwd.pair[0], entry.off,
1198                  &amp;entry.d, sizeof(entry.d));
1199          lfs_entry_fromle32(&amp;entry.d);
1200          if (err) {
1201              return err;
1202          }
1203          LFS_ASSERT(entry.d.type == LFS_TYPE_REG);
1204          entry.d.u.file.head = file-&gt;head;
1205          entry.d.u.file.size = file-&gt;size;
1206          err = lfs_dir_update(lfs, &amp;cwd, &amp;entry, NULL);
1207          if (err) {
1208              return err;
1209          }
1210          file-&gt;flags &amp;= ~LFS_F_DIRTY;
1211      }
1212      return 0;
1213  }
1214  lfs_ssize_t lfs_file_read(lfs_t *lfs, lfs_file_t *file,
1215          void *buffer, lfs_size_t size) {
1216      uint8_t *data = buffer;
1217      lfs_size_t nsize = size;
1218      if ((file-&gt;flags &amp; 3) == LFS_O_WRONLY) {
1219          return LFS_ERR_BADF;
1220      }
1221      if (file-&gt;flags &amp; LFS_F_WRITING) {
1222          int err = lfs_file_flush(lfs, file);
1223          if (err) {
1224              return err;
1225          }
1226      }
1227      if (file-&gt;pos &gt;= file-&gt;size) {
1228          return 0;
1229      }
1230      size = lfs_min(size, file-&gt;size - file-&gt;pos);
1231      nsize = size;
1232      while (nsize &gt; 0) {
1233          if (!(file-&gt;flags &amp; LFS_F_READING) ||
1234                  file-&gt;off == lfs-&gt;cfg-&gt;block_size) {
1235              int err = lfs_ctz_find(lfs, &amp;file-&gt;cache, NULL,
1236                      file-&gt;head, file-&gt;size,
1237                      file-&gt;pos, &amp;file-&gt;block, &amp;file-&gt;off);
1238              if (err) {
1239                  return err;
1240              }
1241              file-&gt;flags |= LFS_F_READING;
1242          }
1243          lfs_size_t diff = lfs_min(nsize, lfs-&gt;cfg-&gt;block_size - file-&gt;off);
1244          int err = lfs_cache_read(lfs, &amp;file-&gt;cache, NULL,
1245                  file-&gt;block, file-&gt;off, data, diff);
1246          if (err) {
1247              return err;
1248          }
1249          file-&gt;pos += diff;
1250          file-&gt;off += diff;
1251          data += diff;
1252          nsize -= diff;
1253      }
1254      return size;
1255  }
1256  lfs_ssize_t lfs_file_write(lfs_t *lfs, lfs_file_t *file,
1257          const void *buffer, lfs_size_t size) {
1258      const uint8_t *data = buffer;
1259      lfs_size_t nsize = size;
1260      if ((file-&gt;flags &amp; 3) == LFS_O_RDONLY) {
1261          return LFS_ERR_BADF;
1262      }
1263      if (file-&gt;flags &amp; LFS_F_READING) {
1264          int err = lfs_file_flush(lfs, file);
1265          if (err) {
1266              return err;
1267          }
1268      }
1269      if ((file-&gt;flags &amp; LFS_O_APPEND) &amp;&amp; file-&gt;pos &lt; file-&gt;size) {
1270          file-&gt;pos = file-&gt;size;
1271      }
1272      if (!(file-&gt;flags &amp; LFS_F_WRITING) &amp;&amp; file-&gt;pos &gt; file-&gt;size) {
1273          lfs_off_t pos = file-&gt;pos;
1274          file-&gt;pos = file-&gt;size;
1275          while (file-&gt;pos &lt; pos) {
1276              lfs_ssize_t res = lfs_file_write(lfs, file, &amp;(uint8_t){0}, 1);
1277              if (res &lt; 0) {
1278                  return res;
1279              }
1280          }
1281      }
1282      while (nsize &gt; 0) {
1283          if (!(file-&gt;flags &amp; LFS_F_WRITING) ||
1284                  file-&gt;off == lfs-&gt;cfg-&gt;block_size) {
1285              if (!(file-&gt;flags &amp; LFS_F_WRITING) &amp;&amp; file-&gt;pos &gt; 0) {
1286                  int err = lfs_ctz_find(lfs, &amp;file-&gt;cache, NULL,
1287                          file-&gt;head, file-&gt;size,
1288                          file-&gt;pos-1, &amp;file-&gt;block, &amp;file-&gt;off);
1289                  if (err) {
1290                      file-&gt;flags |= LFS_F_ERRED;
1291                      return err;
1292                  }
1293                  lfs_cache_zero(lfs, &amp;file-&gt;cache);
1294              }
1295              lfs_alloc_ack(lfs);
1296              int err = lfs_ctz_extend(lfs, &amp;lfs-&gt;rcache, &amp;file-&gt;cache,
1297                      file-&gt;block, file-&gt;pos,
1298                      &amp;file-&gt;block, &amp;file-&gt;off);
1299              if (err) {
1300                  file-&gt;flags |= LFS_F_ERRED;
1301                  return err;
1302              }
1303              file-&gt;flags |= LFS_F_WRITING;
1304          }
1305          lfs_size_t diff = lfs_min(nsize, lfs-&gt;cfg-&gt;block_size - file-&gt;off);
1306          while (true) {
1307              int err = lfs_cache_prog(lfs, &amp;file-&gt;cache, &amp;lfs-&gt;rcache,
1308                      file-&gt;block, file-&gt;off, data, diff);
1309              if (err) {
1310                  if (err == LFS_ERR_CORRUPT) {
1311                      goto relocate;
1312                  }
1313                  file-&gt;flags |= LFS_F_ERRED;
1314                  return err;
1315              }
1316              break;
1317  relocate:
1318              err = lfs_file_relocate(lfs, file);
1319              if (err) {
1320                  file-&gt;flags |= LFS_F_ERRED;
1321                  return err;
1322              }
1323          }
1324          file-&gt;pos += diff;
1325          file-&gt;off += diff;
1326          data += diff;
1327          nsize -= diff;
1328          lfs_alloc_ack(lfs);
1329      }
1330      file-&gt;flags &amp;= ~LFS_F_ERRED;
1331      return size;
1332  }
1333  lfs_soff_t lfs_file_seek(lfs_t *lfs, lfs_file_t *file,
1334          lfs_soff_t off, int whence) {
1335      int err = lfs_file_flush(lfs, file);
1336      if (err) {
1337          return err;
1338      }
1339      if (whence == LFS_SEEK_SET) {
1340          file-&gt;pos = off;
1341      } else if (whence == LFS_SEEK_CUR) {
1342          if (off &lt; 0 &amp;&amp; (lfs_off_t)-off &gt; file-&gt;pos) {
1343              return LFS_ERR_INVAL;
1344          }
1345          file-&gt;pos = file-&gt;pos + off;
1346      } else if (whence == LFS_SEEK_END) {
1347          if (off &lt; 0 &amp;&amp; (lfs_off_t)-off &gt; file-&gt;size) {
1348              return LFS_ERR_INVAL;
1349          }
1350          file-&gt;pos = file-&gt;size + off;
1351      }
1352      return file-&gt;pos;
1353  }
1354  int lfs_file_truncate(lfs_t *lfs, lfs_file_t *file, lfs_off_t size) {
1355      if ((file-&gt;flags &amp; 3) == LFS_O_RDONLY) {
1356          return LFS_ERR_BADF;
1357      }
1358      lfs_off_t oldsize = lfs_file_size(lfs, file);
1359      if (size &lt; oldsize) {
1360          int err = lfs_file_flush(lfs, file);
1361          if (err) {
1362              return err;
1363          }
1364          err = lfs_ctz_find(lfs, &amp;file-&gt;cache, NULL,
1365                  file-&gt;head, file-&gt;size,
1366                  size, &amp;file-&gt;head, &amp;(lfs_off_t){0});
1367          if (err) {
1368              return err;
1369          }
1370          file-&gt;size = size;
1371          file-&gt;flags |= LFS_F_DIRTY;
1372      } else if (size &gt; oldsize) {
1373          lfs_off_t pos = file-&gt;pos;
1374          if (file-&gt;pos != oldsize) {
1375              int err = lfs_file_seek(lfs, file, 0, LFS_SEEK_END);
1376              if (err &lt; 0) {
1377                  return err;
1378              }
1379          }
1380          while (file-&gt;pos &lt; size) {
1381              lfs_ssize_t res = lfs_file_write(lfs, file, &amp;(uint8_t){0}, 1);
1382              if (res &lt; 0) {
1383                  return res;
1384              }
1385          }
1386          int err = lfs_file_seek(lfs, file, pos, LFS_SEEK_SET);
1387          if (err &lt; 0) {
1388              return err;
1389          }
1390      }
1391      return 0;
1392  }
1393  lfs_soff_t lfs_file_tell(lfs_t *lfs, lfs_file_t *file) {
1394      (void)lfs;
1395      return file-&gt;pos;
1396  }
1397  int lfs_file_rewind(lfs_t *lfs, lfs_file_t *file) {
1398      lfs_soff_t res = lfs_file_seek(lfs, file, 0, LFS_SEEK_SET);
1399      if (res &lt; 0) {
1400          return res;
1401      }
1402      return 0;
1403  }
1404  lfs_soff_t lfs_file_size(lfs_t *lfs, lfs_file_t *file) {
1405      (void)lfs;
1406      if (file-&gt;flags &amp; LFS_F_WRITING) {
1407          return lfs_max(file-&gt;pos, file-&gt;size);
1408      } else {
1409          return file-&gt;size;
1410      }
1411  }
1412  int lfs_stat(lfs_t *lfs, const char *path, struct lfs_info *info) {
1413      lfs_dir_t cwd;
1414      lfs_entry_t entry;
1415      int err = lfs_dir_find(lfs, &amp;cwd, &amp;entry, &amp;path);
1416      if (err) {
1417          return err;
1418      }
1419      memset(info, 0, sizeof(*info));
1420      info-&gt;type = entry.d.type;
1421      if (info-&gt;type == LFS_TYPE_REG) {
1422          info-&gt;size = entry.d.u.file.size;
1423      }
1424      if (lfs_paircmp(entry.d.u.dir, lfs-&gt;root) == 0) {
1425          strcpy(info-&gt;name, &quot;/&quot;);
1426      } else {
1427          err = lfs_bd_read(lfs, cwd.pair[0],
1428                  entry.off + 4+entry.d.elen+entry.d.alen,
1429                  info-&gt;name, entry.d.nlen);
1430          if (err) {
1431              return err;
1432          }
1433      }
1434      return 0;
1435  }
1436  int lfs_remove(lfs_t *lfs, const char *path) {
1437      if (!lfs-&gt;deorphaned) {
1438          int err = lfs_deorphan(lfs);
1439          if (err) {
1440              return err;
1441          }
1442      }
1443      lfs_dir_t cwd;
1444      lfs_entry_t entry;
1445      int err = lfs_dir_find(lfs, &amp;cwd, &amp;entry, &amp;path);
1446      if (err) {
1447          return err;
1448      }
1449      lfs_dir_t dir;
1450      if (entry.d.type == LFS_TYPE_DIR) {
1451          err = lfs_dir_fetch(lfs, &amp;dir, entry.d.u.dir);
1452          if (err) {
1453              return err;
1454          } &amp;bsol;* else if (dir.d.size != sizeof(dir.d)+4) {
1455              return LFS_ERR_NOTEMPTY;
1456          }  adafruit: allow to remove non-empty folder,
1457             According to below issue, comment these 2 line won&#x27;t corrupt filesystem
1458             https:&amp;bsol;&amp;bsol;github.com/ARMmbed/littlefs/issues/43 */
1459      }
1460      err = lfs_dir_remove(lfs, &amp;cwd, &amp;entry);
1461      if (err) {
1462          return err;
1463      }
1464      if (entry.d.type == LFS_TYPE_DIR) {
1465          int res = lfs_pred(lfs, dir.pair, &amp;cwd);
1466          if (res &lt; 0) {
1467              return res;
1468          }
1469          LFS_ASSERT(res); 
1470          cwd.d.tail[0] = dir.d.tail[0];
1471          cwd.d.tail[1] = dir.d.tail[1];
1472          err = lfs_dir_commit(lfs, &amp;cwd, NULL, 0);
1473          if (err) {
1474              return err;
1475          }
1476      }
1477      return 0;
1478  }
1479  int lfs_rename(lfs_t *lfs, const char *oldpath, const char *newpath) {
1480      if (!lfs-&gt;deorphaned) {
1481          int err = lfs_deorphan(lfs);
1482          if (err) {
1483              return err;
1484          }
1485      }
1486      lfs_dir_t oldcwd;
1487      lfs_entry_t oldentry;
1488      int err = lfs_dir_find(lfs, &amp;oldcwd, &amp;oldentry, &amp;oldpath);
1489      if (err) {
1490          return err;
1491      }
1492      lfs_dir_t newcwd;
1493      lfs_entry_t preventry;
1494      err = lfs_dir_find(lfs, &amp;newcwd, &amp;preventry, &amp;newpath);
1495      if (err &amp;&amp; (err != LFS_ERR_NOENT || strchr(newpath, &#x27;/&#x27;) != NULL)) {
1496          return err;
1497      }
1498      bool prevexists = (err != LFS_ERR_NOENT);
1499      bool samepair = (lfs_paircmp(oldcwd.pair, newcwd.pair) == 0);
1500      if (prevexists &amp;&amp; preventry.d.type != oldentry.d.type) {
1501          return LFS_ERR_ISDIR;
1502      }
1503      lfs_dir_t dir;
1504      if (prevexists &amp;&amp; preventry.d.type == LFS_TYPE_DIR) {
1505          err = lfs_dir_fetch(lfs, &amp;dir, preventry.d.u.dir);
1506          if (err) {
1507              return err;
1508          } else if (dir.d.size != sizeof(dir.d)+4) {
1509              return LFS_ERR_NOTEMPTY;
1510          }
1511      }
1512      oldentry.d.type |= 0x80;
1513      err = lfs_dir_update(lfs, &amp;oldcwd, &amp;oldentry, NULL);
1514      if (err) {
1515          return err;
1516      }
1517      if (samepair) {
1518          newcwd = oldcwd;
1519      }
1520      lfs_entry_t newentry = preventry;
1521      newentry.d = oldentry.d;
1522      newentry.d.type &amp;= ~0x80;
1523      newentry.d.nlen = strlen(newpath);
1524      if (prevexists) {
1525          err = lfs_dir_update(lfs, &amp;newcwd, &amp;newentry, newpath);
1526          if (err) {
1527              return err;
1528          }
1529      } else {
1530          err = lfs_dir_append(lfs, &amp;newcwd, &amp;newentry, newpath);
1531          if (err) {
1532              return err;
1533          }
1534      }
1535      if (samepair) {
1536          oldcwd = newcwd;
1537      }
1538      err = lfs_dir_remove(lfs, &amp;oldcwd, &amp;oldentry);
1539      if (err) {
1540          return err;
1541      }
1542      if (prevexists &amp;&amp; preventry.d.type == LFS_TYPE_DIR) {
1543          int res = lfs_pred(lfs, dir.pair, &amp;newcwd);
1544          if (res &lt; 0) {
1545              return res;
1546          }
1547          LFS_ASSERT(res); 
1548          newcwd.d.tail[0] = dir.d.tail[0];
1549          newcwd.d.tail[1] = dir.d.tail[1];
1550          err = lfs_dir_commit(lfs, &amp;newcwd, NULL, 0);
1551          if (err) {
1552              return err;
1553          }
1554      }
1555      return 0;
1556  }
1557  static void lfs_deinit(lfs_t *lfs) {
1558      if (!lfs-&gt;cfg-&gt;read_buffer) {
1559          lfs_free(lfs-&gt;rcache.buffer);
1560      }
1561      if (!lfs-&gt;cfg-&gt;prog_buffer) {
1562          lfs_free(lfs-&gt;pcache.buffer);
1563      }
1564      if (!lfs-&gt;cfg-&gt;lookahead_buffer) {
1565          lfs_free(lfs-&gt;free.buffer);
1566      }
1567  }
1568  static int lfs_init(lfs_t *lfs, const struct lfs_config *cfg) {
1569      lfs-&gt;cfg = cfg;
1570      if (lfs-&gt;cfg-&gt;read_buffer) {
1571          lfs-&gt;rcache.buffer = lfs-&gt;cfg-&gt;read_buffer;
1572      } else {
1573          lfs-&gt;rcache.buffer = lfs_malloc(lfs-&gt;cfg-&gt;read_size);
1574          if (!lfs-&gt;rcache.buffer) {
1575              goto cleanup;
1576          }
1577      }
1578      if (lfs-&gt;cfg-&gt;prog_buffer) {
1579          lfs-&gt;pcache.buffer = lfs-&gt;cfg-&gt;prog_buffer;
1580      } else {
1581          lfs-&gt;pcache.buffer = lfs_malloc(lfs-&gt;cfg-&gt;prog_size);
1582          if (!lfs-&gt;pcache.buffer) {
1583              goto cleanup;
1584          }
1585      }
1586      lfs_cache_zero(lfs, &amp;lfs-&gt;pcache);
1587      lfs_cache_drop(lfs, &amp;lfs-&gt;rcache);
1588      LFS_ASSERT(lfs-&gt;cfg-&gt;lookahead % 32 == 0);
1589      LFS_ASSERT(lfs-&gt;cfg-&gt;lookahead &gt; 0);
1590      if (lfs-&gt;cfg-&gt;lookahead_buffer) {
1591          lfs-&gt;free.buffer = lfs-&gt;cfg-&gt;lookahead_buffer;
1592      } else {
1593          lfs-&gt;free.buffer = lfs_malloc(lfs-&gt;cfg-&gt;lookahead/8);
1594          if (!lfs-&gt;free.buffer) {
1595              goto cleanup;
1596          }
1597      }
1598      LFS_ASSERT(lfs-&gt;cfg-&gt;prog_size % lfs-&gt;cfg-&gt;read_size == 0);
1599      LFS_ASSERT(lfs-&gt;cfg-&gt;block_size % lfs-&gt;cfg-&gt;prog_size == 0);
1600      LFS_ASSERT(4*lfs_npw2(0xffffffff / (lfs-&gt;cfg-&gt;block_size-2*4))
1601              &lt;= lfs-&gt;cfg-&gt;block_size);
1602      lfs-&gt;root[0] = 0xffffffff;
1603      lfs-&gt;root[1] = 0xffffffff;
1604      lfs-&gt;files = NULL;
1605      lfs-&gt;dirs = NULL;
1606      lfs-&gt;deorphaned = false;
1607      return 0;
1608  cleanup:
1609      lfs_deinit(lfs);
1610      return LFS_ERR_NOMEM;
1611  }
1612  int lfs_format(lfs_t *lfs, const struct lfs_config *cfg) {
1613      int err = 0;
1614      if (true) {
1615          err = lfs_init(lfs, cfg);
1616          if (err) {
1617              return err;
1618          }
1619          memset(lfs-&gt;free.buffer, 0, lfs-&gt;cfg-&gt;lookahead/8);
1620          lfs-&gt;free.off = 0;
1621          lfs-&gt;free.size = lfs_min(lfs-&gt;cfg-&gt;lookahead, lfs-&gt;cfg-&gt;block_count);
1622          lfs-&gt;free.i = 0;
1623          lfs_alloc_ack(lfs);
1624          lfs_dir_t superdir;
1625          err = lfs_dir_alloc(lfs, &amp;superdir);
1626          if (err) {
1627              goto cleanup;
1628          }
1629          lfs_dir_t root;
1630          err = lfs_dir_alloc(lfs, &amp;root);
1631          if (err) {
1632              goto cleanup;
1633          }
1634          err = lfs_dir_commit(lfs, &amp;root, NULL, 0);
1635          if (err) {
1636              goto cleanup;
1637          }
1638          lfs-&gt;root[0] = root.pair[0];
1639          lfs-&gt;root[1] = root.pair[1];
1640          lfs_superblock_t superblock = {
1641              .off = sizeof(superdir.d),
1642              .d.type = LFS_TYPE_SUPERBLOCK,
1643              .d.elen = sizeof(superblock.d) - sizeof(superblock.d.magic) - 4,
1644              .d.nlen = sizeof(superblock.d.magic),
1645              .d.version = LFS_DISK_VERSION,
1646              .d.magic = {&quot;littlefs&quot;},
1647              .d.block_size  = lfs-&gt;cfg-&gt;block_size,
1648              .d.block_count = lfs-&gt;cfg-&gt;block_count,
1649              .d.root = {lfs-&gt;root[0], lfs-&gt;root[1]},
1650          };
1651          superdir.d.tail[0] = root.pair[0];
1652          superdir.d.tail[1] = root.pair[1];
1653          superdir.d.size = sizeof(superdir.d) + sizeof(superblock.d) + 4;
1654          lfs_superblock_tole32(&amp;superblock.d);
1655          bool valid = false;
1656          for (int i = 0; i &lt; 2; i++) {
1657              err = lfs_dir_commit(lfs, &amp;superdir, (struct lfs_region[]){
1658                      {sizeof(superdir.d), sizeof(superblock.d),
1659                       &amp;superblock.d, sizeof(superblock.d)}
1660                  }, 1);
1661              if (err &amp;&amp; err != LFS_ERR_CORRUPT) {
1662                  goto cleanup;
1663              }
1664              valid = valid || !err;
1665          }
1666          if (!valid) {
1667              err = LFS_ERR_CORRUPT;
1668              goto cleanup;
1669          }
1670          err = lfs_dir_fetch(lfs, &amp;superdir, (const lfs_block_t[2]){0, 1});
1671          if (err) {
1672              goto cleanup;
1673          }
1674          lfs_alloc_ack(lfs);
1675      }
1676  cleanup:
1677      lfs_deinit(lfs);
1678      return err;
1679  }
1680  int lfs_mount(lfs_t *lfs, const struct lfs_config *cfg) {
1681      int err = 0;
1682      if (true) {
1683          err = lfs_init(lfs, cfg);
1684          if (err) {
1685              return err;
1686          }
1687          lfs-&gt;free.off = 0;
1688          lfs-&gt;free.size = 0;
1689          lfs-&gt;free.i = 0;
1690          lfs_alloc_ack(lfs);
1691          lfs_dir_t dir;
1692          lfs_superblock_t superblock;
1693          err = lfs_dir_fetch(lfs, &amp;dir, (const lfs_block_t[2]){0, 1});
1694          if (err &amp;&amp; err != LFS_ERR_CORRUPT) {
1695              goto cleanup;
1696          }
1697          if (!err) {
1698              err = lfs_bd_read(lfs, dir.pair[0], sizeof(dir.d),
1699                      &amp;superblock.d, sizeof(superblock.d));
1700              lfs_superblock_fromle32(&amp;superblock.d);
1701              if (err) {
1702                  goto cleanup;
1703              }
1704              lfs-&gt;root[0] = superblock.d.root[0];
1705              lfs-&gt;root[1] = superblock.d.root[1];
1706          }
1707          if (err || memcmp(superblock.d.magic, &quot;littlefs&quot;, 8) != 0) {
1708              LFS_ERROR(&quot;Invalid superblock at %d %d&quot;, 0, 1);
1709              err = LFS_ERR_CORRUPT;
1710              goto cleanup;
1711          }
1712          uint16_t major_version = (0xffff &amp; (superblock.d.version &gt;&gt; 16));
1713          uint16_t minor_version = (0xffff &amp; (superblock.d.version &gt;&gt;  0));
1714          if ((major_version != LFS_DISK_VERSION_MAJOR ||
1715               minor_version &gt; LFS_DISK_VERSION_MINOR)) {
1716              LFS_ERROR(&quot;Invalid version %d.%d&quot;, major_version, minor_version);
1717              err = LFS_ERR_INVAL;
1718              goto cleanup;
1719          }
1720          return 0;
1721      }
1722  cleanup:
1723      lfs_deinit(lfs);
1724      return err;
1725  }
1726  int lfs_unmount(lfs_t *lfs) {
1727      lfs_deinit(lfs);
1728      return 0;
1729  }
1730  int lfs_traverse(lfs_t *lfs, int (*cb)(void*, lfs_block_t), void *data) {
1731      if (lfs_pairisnull(lfs-&gt;root)) {
1732          return 0;
1733      }
1734      lfs_dir_t dir;
1735      lfs_entry_t entry;
1736      lfs_block_t cwd[2] = {0, 1};
1737      while (true) {
1738          for (int i = 0; i &lt; 2; i++) {
1739              int err = cb(data, cwd[i]);
1740              if (err) {
1741                  return err;
1742              }
1743          }
1744          int err = lfs_dir_fetch(lfs, &amp;dir, cwd);
1745          if (err) {
1746              return err;
1747          }
1748          while (dir.off + sizeof(entry.d) &lt;= (0x7fffffff &amp; dir.d.size)-4) {
1749              err = lfs_bd_read(lfs, dir.pair[0], dir.off,
1750                      &amp;entry.d, sizeof(entry.d));
1751              lfs_entry_fromle32(&amp;entry.d);
1752              if (err) {
1753                  return err;
1754              }
1755              dir.off += lfs_entry_size(&amp;entry);
1756              if ((0x70 &amp; entry.d.type) == (0x70 &amp; LFS_TYPE_REG)) {
1757                  err = lfs_ctz_traverse(lfs, &amp;lfs-&gt;rcache, NULL,
1758                          entry.d.u.file.head, entry.d.u.file.size, cb, data);
1759                  if (err) {
1760                      return err;
1761                  }
1762              }
1763          }
1764          cwd[0] = dir.d.tail[0];
1765          cwd[1] = dir.d.tail[1];
1766          if (lfs_pairisnull(cwd)) {
1767              break;
1768          }
1769      }
1770      for (lfs_file_t *f = lfs-&gt;files; f; f = f-&gt;next) {
1771          if (f-&gt;flags &amp; LFS_F_DIRTY) {
1772              int err = lfs_ctz_traverse(lfs, &amp;lfs-&gt;rcache, &amp;f-&gt;cache,
1773                      f-&gt;head, f-&gt;size, cb, data);
1774              if (err) {
1775                  return err;
1776              }
1777          }
1778          if (f-&gt;flags &amp; LFS_F_WRITING) {
1779              int err = lfs_ctz_traverse(lfs, &amp;lfs-&gt;rcache, &amp;f-&gt;cache,
1780                      f-&gt;block, f-&gt;pos, cb, data);
1781              if (err) {
1782                  return err;
1783              }
1784          }
1785      }
1786      return 0;
1787  }
1788  static int lfs_pred(lfs_t *lfs, const lfs_block_t dir[2], lfs_dir_t *pdir) {
1789      if (lfs_pairisnull(lfs-&gt;root)) {
1790          return 0;
1791      }
1792      int err = lfs_dir_fetch(lfs, pdir, (const lfs_block_t[2]){0, 1});
1793      if (err) {
1794          return err;
1795      }
1796      while (!lfs_pairisnull(pdir-&gt;d.tail)) {
1797          if (lfs_paircmp(pdir-&gt;d.tail, dir) == 0) {
1798              return true;
1799          }
1800          err = lfs_dir_fetch(lfs, pdir, pdir-&gt;d.tail);
1801          if (err) {
1802              return err;
1803          }
1804      }
1805      return false;
1806  }
1807  static int lfs_parent(lfs_t *lfs, const lfs_block_t dir[2],
1808          lfs_dir_t *parent, lfs_entry_t *entry) {
1809      if (lfs_pairisnull(lfs-&gt;root)) {
1810          return 0;
1811      }
1812      parent-&gt;d.tail[0] = 0;
1813      parent-&gt;d.tail[1] = 1;
1814      while (!lfs_pairisnull(parent-&gt;d.tail)) {
1815          int err = lfs_dir_fetch(lfs, parent, parent-&gt;d.tail);
1816          if (err) {
1817              return err;
1818          }
1819          while (true) {
1820              err = lfs_dir_next(lfs, parent, entry);
1821              if (err &amp;&amp; err != LFS_ERR_NOENT) {
1822                  return err;
1823              }
1824              if (err == LFS_ERR_NOENT) {
1825                  break;
1826              }
1827              if (((0x70 &amp; entry-&gt;d.type) == (0x70 &amp; LFS_TYPE_DIR)) &amp;&amp;
1828                   lfs_paircmp(entry-&gt;d.u.dir, dir) == 0) {
1829                  return true;
1830              }
1831          }
1832      }
1833      return false;
1834  }
1835  static int lfs_moved(lfs_t *lfs, const void *e) {
1836      if (lfs_pairisnull(lfs-&gt;root)) {
1837          return 0;
1838      }
1839      lfs_dir_t cwd;
1840      int err = lfs_dir_fetch(lfs, &amp;cwd, (const lfs_block_t[2]){0, 1});
1841      if (err) {
1842          return err;
1843      }
1844      lfs_entry_t entry;
1845      while (!lfs_pairisnull(cwd.d.tail)) {
1846          err = lfs_dir_fetch(lfs, &amp;cwd, cwd.d.tail);
1847          if (err) {
1848              return err;
1849          }
1850          while (true) {
1851              err = lfs_dir_next(lfs, &amp;cwd, &amp;entry);
1852              if (err &amp;&amp; err != LFS_ERR_NOENT) {
1853                  return err;
1854              }
1855              if (err == LFS_ERR_NOENT) {
1856                  break;
1857              }
1858              if (!(0x80 &amp; entry.d.type) &amp;&amp;
1859                   memcmp(&amp;entry.d.u, e, sizeof(entry.d.u)) == 0) {
1860                  return true;
1861              }
1862          }
1863      }
1864      return false;
1865  }
1866  static int lfs_relocate(lfs_t *lfs,
1867          const lfs_block_t oldpair[2], const lfs_block_t newpair[2]) {
1868      lfs_dir_t parent;
1869      lfs_entry_t entry;
1870      int res = lfs_parent(lfs, oldpair, &amp;parent, &amp;entry);
1871      if (res &lt; 0) {
1872          return res;
1873      }
1874      if (res) {
1875          entry.d.u.dir[0] = newpair[0];
1876          entry.d.u.dir[1] = newpair[1];
1877          int err = lfs_dir_update(lfs, &amp;parent, &amp;entry, NULL);
1878          if (err) {
1879              return err;
1880          }
1881          if (lfs_paircmp(oldpair, lfs-&gt;root) == 0) {
1882              LFS_DEBUG(&quot;Relocating root %&quot; PRIu32 &quot; %&quot; PRIu32,
1883                      newpair[0], newpair[1]);
1884              lfs-&gt;root[0] = newpair[0];
1885              lfs-&gt;root[1] = newpair[1];
1886          }
1887          return lfs_deorphan(lfs);
1888      }
1889      res = lfs_pred(lfs, oldpair, &amp;parent);
1890      if (res &lt; 0) {
1891          return res;
1892      }
1893      if (res) {
1894          parent.d.tail[0] = newpair[0];
1895          parent.d.tail[1] = newpair[1];
1896          return lfs_dir_commit(lfs, &amp;parent, NULL, 0);
1897      }
1898      return 0;
1899  }
1900  int lfs_deorphan(lfs_t *lfs) {
1901      lfs-&gt;deorphaned = true;
1902      if (lfs_pairisnull(lfs-&gt;root)) {
1903          return 0;
1904      }
1905      lfs_dir_t pdir = {.d.size = 0x80000000};
1906      lfs_dir_t cwd = {.d.tail[0] = 0, .d.tail[1] = 1};
1907      for (lfs_size_t i = 0; i &lt; lfs-&gt;cfg-&gt;block_count; i++) {
1908          if (lfs_pairisnull(cwd.d.tail)) {
1909              return 0;
1910          }
1911          int err = lfs_dir_fetch(lfs, &amp;cwd, cwd.d.tail);
1912          if (err) {
1913              return err;
1914          }
1915          if (!(0x80000000 &amp; pdir.d.size)) {
1916              lfs_dir_t parent;
1917              lfs_entry_t entry;
1918              int res = lfs_parent(lfs, pdir.d.tail, &amp;parent, &amp;entry);
1919              if (res &lt; 0) {
1920                  return res;
1921              }
1922              if (!res) {
1923                  LFS_DEBUG(&quot;Found orphan %&quot; PRIu32 &quot; %&quot; PRIu32,
1924                          pdir.d.tail[0], pdir.d.tail[1]);
1925                  pdir.d.tail[0] = cwd.d.tail[0];
1926                  pdir.d.tail[1] = cwd.d.tail[1];
1927                  err = lfs_dir_commit(lfs, &amp;pdir, NULL, 0);
1928                  if (err) {
1929                      return err;
1930                  }
1931                  return 0;
1932              }
1933              if (!lfs_pairsync(entry.d.u.dir, pdir.d.tail)) {
1934                  LFS_DEBUG(&quot;Found desync %&quot; PRIu32 &quot; %&quot; PRIu32,
1935                          entry.d.u.dir[0], entry.d.u.dir[1]);
1936                  pdir.d.tail[0] = entry.d.u.dir[0];
1937                  pdir.d.tail[1] = entry.d.u.dir[1];
1938                  err = lfs_dir_commit(lfs, &amp;pdir, NULL, 0);
1939                  if (err) {
1940                      return err;
1941                  }
1942                  return 0;
1943              }
1944          }
1945          lfs_entry_t entry;
1946          while (true) {
1947              err = lfs_dir_next(lfs, &amp;cwd, &amp;entry);
1948              if (err &amp;&amp; err != LFS_ERR_NOENT) {
1949                  return err;
1950              }
1951              if (err == LFS_ERR_NOENT) {
1952                  break;
1953              }
1954              if (entry.d.type &amp; 0x80) {
1955                  int moved = lfs_moved(lfs, &amp;entry.d.u);
1956                  if (moved &lt; 0) {
1957                      return moved;
1958                  }
1959                  if (moved) {
1960                      LFS_DEBUG(&quot;Found move %&quot; PRIu32 &quot; %&quot; PRIu32,
1961                              entry.d.u.dir[0], entry.d.u.dir[1]);
1962                      err = lfs_dir_remove(lfs, &amp;cwd, &amp;entry);
1963                      if (err) {
1964                          return err;
1965                      }
1966                  } else {
1967                      LFS_DEBUG(&quot;Found partial move %&quot; PRIu32 &quot; %&quot; PRIu32,
1968                              entry.d.u.dir[0], entry.d.u.dir[1]);
1969                      entry.d.type &amp;= ~0x80;
1970                      err = lfs_dir_update(lfs, &amp;cwd, &amp;entry, NULL);
1971                      if (err) {
1972                          return err;
1973                      }
1974                  }
1975              }
1976          }
1977          memcpy(&amp;pdir, &amp;cwd, sizeof(pdir));
1978      }
1979      return LFS_ERR_CORRUPT;
1980  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-lfs.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-lfs.c</div>
                </div>
                <div class="column column_space"><pre><code>512              entry-&gt;off = dir-&gt;d.size - 4;
513              lfs_entry_tole32(&amp;entry-&gt;d);
514              int err = lfs_dir_commit(lfs, dir, (struct lfs_region[]){
</pre></code></div>
                <div class="column column_space"><pre><code>529              entry-&gt;off = dir-&gt;d.size - 4;
530              lfs_entry_tole32(&amp;entry-&gt;d);
531              err = lfs_dir_commit(lfs, dir, (struct lfs_region[]){
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    