
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-bignum.c</h3>
            <pre><code>1  #if !defined(POLARSSL_CONFIG_FILE)
2  #include "config.h"
3  #else
4  #include POLARSSL_CONFIG_FILE
5  #endif
6  #if defined(POLARSSL_BIGNUM_C)
7  #include "bignum.h"
8  #include "bn_mul.h"
9  #include <string.h>
10  #if defined(POLARSSL_PLATFORM_C)
11  #include "platform.h"
12  #else
13  #include <stdio.h>
14  #include <stdlib.h>
15  #define polarssl_printf     printf
16  #define polarssl_malloc     malloc
17  #define polarssl_free       free
18  #endif
19  static void polarssl_zeroize( void *v, size_t n ) {
20      volatile unsigned char *p = v; while( n-- ) *p++ = 0;
21  }
22  #define ciL    (sizeof(t_uint))         &bsol;* chars in limb  */
23  #define biL    (ciL << 3)               &bsol;* bits  in limb  */
24  #define biH    (ciL << 2)               &bsol;* half limb size */
25  #define BITS_TO_LIMBS(i)  (((i) + biL - 1) / biL)
26  #define CHARS_TO_LIMBS(i) (((i) + ciL - 1) / ciL)
27  void mpi_init( mpi *X )
28  {
29      if( X == NULL )
30          return;
31      X->s = 1;
32      X->n = 0;
33      X->p = NULL;
34  }
35  void mpi_free( mpi *X )
36  {
37      if( X == NULL )
38          return;
39      if( X->p != NULL )
40      {
41          polarssl_zeroize( X->p, X->n * ciL );
42          polarssl_free( X->p );
43      }
44      X->s = 1;
45      X->n = 0;
46      X->p = NULL;
47  }
48  int mpi_grow( mpi *X, size_t nblimbs )
49  {
50      t_uint *p;
51      if( nblimbs > POLARSSL_MPI_MAX_LIMBS )
52          return( POLARSSL_ERR_MPI_MALLOC_FAILED );
53      if( X->n < nblimbs )
54      {
55          if( ( p = polarssl_malloc( nblimbs * ciL ) ) == NULL )
56              return( POLARSSL_ERR_MPI_MALLOC_FAILED );
57          memset( p, 0, nblimbs * ciL );
58          if( X->p != NULL )
59          {
60              memcpy( p, X->p, X->n * ciL );
61              polarssl_zeroize( X->p, X->n * ciL );
62              polarssl_free( X->p );
63          }
64          X->n = nblimbs;
65          X->p = p;
66      }
67      return( 0 );
68  }
69  int mpi_shrink( mpi *X, size_t nblimbs )
70  {
71      t_uint *p;
72      size_t i;
73      if( X->n <= nblimbs )
74          return( mpi_grow( X, nblimbs ) );
75      for( i = X->n - 1; i > 0; i-- )
76          if( X->p[i] != 0 )
77              break;
78      i++;
79      if( i < nblimbs )
80          i = nblimbs;
81      if( ( p = polarssl_malloc( i * ciL ) ) == NULL )
82          return( POLARSSL_ERR_MPI_MALLOC_FAILED );
83      memset( p, 0, i * ciL );
84      if( X->p != NULL )
85      {
86          memcpy( p, X->p, i * ciL );
87          polarssl_zeroize( X->p, X->n * ciL );
88          polarssl_free( X->p );
89      }
90      X->n = i;
91      X->p = p;
92      return( 0 );
93  }
94  int mpi_copy( mpi *X, const mpi *Y )
95  {
96      int ret;
97      size_t i;
98      if( X == Y )
99          return( 0 );
100      if( Y->p == NULL )
101      {
102          mpi_free( X );
103          return( 0 );
104      }
105      for( i = Y->n - 1; i > 0; i-- )
106          if( Y->p[i] != 0 )
107              break;
108      i++;
109      X->s = Y->s;
110      MPI_CHK( mpi_grow( X, i ) );
111      memset( X->p, 0, X->n * ciL );
112      memcpy( X->p, Y->p, i * ciL );
113  cleanup:
114      return( ret );
115  }
116  void mpi_swap( mpi *X, mpi *Y )
117  {
118      mpi T;
119      memcpy( &T,  X, sizeof( mpi ) );
120      memcpy(  X,  Y, sizeof( mpi ) );
121      memcpy(  Y, &T, sizeof( mpi ) );
122  }
123  int mpi_safe_cond_assign( mpi *X, const mpi *Y, unsigned char assign )
124  {
125      int ret = 0;
126      size_t i;
127      assign = (assign | (unsigned char)-assign) >> 7;
128      MPI_CHK( mpi_grow( X, Y->n ) );
129      X->s = X->s * ( 1 - assign ) + Y->s * assign;
130      for( i = 0; i < Y->n; i++ )
131          X->p[i] = X->p[i] * ( 1 - assign ) + Y->p[i] * assign;
132      for( ; i < X->n; i++ )
133          X->p[i] *= ( 1 - assign );
134  cleanup:
135      return( ret );
136  }
137  int mpi_safe_cond_swap( mpi *X, mpi *Y, unsigned char swap )
138  {
139      int ret, s;
140      size_t i;
141      t_uint tmp;
142      if( X == Y )
143          return( 0 );
144      swap = (swap | (unsigned char)-swap) >> 7;
145      MPI_CHK( mpi_grow( X, Y->n ) );
146      MPI_CHK( mpi_grow( Y, X->n ) );
147      s = X->s;
148      X->s = X->s * ( 1 - swap ) + Y->s * swap;
149      Y->s = Y->s * ( 1 - swap ) +    s * swap;
150      for( i = 0; i < X->n; i++ )
151      {
152          tmp = X->p[i];
153          X->p[i] = X->p[i] * ( 1 - swap ) + Y->p[i] * swap;
154          Y->p[i] = Y->p[i] * ( 1 - swap ) +     tmp * swap;
155      }
156  cleanup:
157      return( ret );
158  }
159  int mpi_lset( mpi *X, t_sint z )
160  {
161      int ret;
162      MPI_CHK( mpi_grow( X, 1 ) );
163      memset( X->p, 0, X->n * ciL );
164      X->p[0] = ( z < 0 ) ? -z : z;
165      X->s    = ( z < 0 ) ? -1 : 1;
166  cleanup:
167      return( ret );
168  }
169  int mpi_get_bit( const mpi *X, size_t pos )
170  {
171      if( X->n * biL <= pos )
172          return( 0 );
173      return( ( X->p[pos / biL] >> ( pos % biL ) ) & 0x01 );
174  }
175  int mpi_set_bit( mpi *X, size_t pos, unsigned char val )
176  {
177      int ret = 0;
178      size_t off = pos / biL;
179      size_t idx = pos % biL;
180      if( val != 0 && val != 1 )
181          return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );
182      if( X->n * biL <= pos )
183      {
184          if( val == 0 )
185              return( 0 );
186          MPI_CHK( mpi_grow( X, off + 1 ) );
187      }
188      X->p[off] &= ~( (t_uint) 0x01 << idx );
189      X->p[off] |= (t_uint) val << idx;
190  cleanup:
191      return( ret );
192  }
193  size_t mpi_lsb( const mpi *X )
194  {
195      size_t i, j, count = 0;
196      for( i = 0; i < X->n; i++ )
197          for( j = 0; j < biL; j++, count++ )
198              if( ( ( X->p[i] >> j ) & 1 ) != 0 )
199                  return( count );
200      return( 0 );
201  }
202  size_t mpi_msb( const mpi *X )
203  {
204      size_t i, j;
205      if( X->n == 0 )
206          return( 0 );
207      for( i = X->n - 1; i > 0; i-- )
208          if( X->p[i] != 0 )
209              break;
210      for( j = biL; j > 0; j-- )
211          if( ( ( X->p[i] >> ( j - 1 ) ) & 1 ) != 0 )
212              break;
213      return( ( i * biL ) + j );
214  }
215  size_t mpi_size( const mpi *X )
216  {
217      return( ( mpi_msb( X ) + 7 ) >> 3 );
218  }
219  #if 0
220  static int mpi_get_digit( t_uint *d, int radix, char c )
221  {
222      *d = 255;
223      if( c >= 0x30 && c <= 0x39 ) *d = c - 0x30;
224      if( c >= 0x41 && c <= 0x46 ) *d = c - 0x37;
225      if( c >= 0x61 && c <= 0x66 ) *d = c - 0x57;
226      if( *d >= (t_uint) radix )
227          return( POLARSSL_ERR_MPI_INVALID_CHARACTER );
228      return( 0 );
229  }
230  int mpi_read_string( mpi *X, int radix, const char *s )
231  {
232      int ret;
233      size_t i, j, slen, n;
234      t_uint d;
235      mpi T;
236      if( radix < 2 || radix > 16 )
237          return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );
238      mpi_init( &T );
239      slen = strlen( s );
240      if( radix == 16 )
241      {
242          n = BITS_TO_LIMBS( slen << 2 );
243          MPI_CHK( mpi_grow( X, n ) );
244          MPI_CHK( mpi_lset( X, 0 ) );
245          for( i = slen, j = 0; i > 0; i--, j++ )
246          {
247              if( i == 1 && s[i - 1] == '-' )
248              {
249                  X->s = -1;
250                  break;
251              }
252              MPI_CHK( mpi_get_digit( &d, radix, s[i - 1] ) );
253              X->p[j / ( 2 * ciL )] |= d << ( ( j % ( 2 * ciL ) ) << 2 );
254          }
255      }
256      else
257      {
258          MPI_CHK( mpi_lset( X, 0 ) );
259          for( i = 0; i < slen; i++ )
260          {
261              if( i == 0 && s[i] == '-' )
262              {
263                  X->s = -1;
264                  continue;
265              }
266              MPI_CHK( mpi_get_digit( &d, radix, s[i] ) );
267              MPI_CHK( mpi_mul_int( &T, X, radix ) );
268              if( X->s == 1 )
269              {
270                  MPI_CHK( mpi_add_int( X, &T, d ) );
271              }
272              else
273              {
274                  MPI_CHK( mpi_sub_int( X, &T, d ) );
275              }
276          }
277      }
278  cleanup:
279      mpi_free( &T );
280      return( ret );
281  }
282  static int mpi_write_hlp( mpi *X, int radix, char **p )
283  {
284      int ret;
285      t_uint r;
286      if( radix < 2 || radix > 16 )
287          return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );
288      MPI_CHK( mpi_mod_int( &r, X, radix ) );
289      MPI_CHK( mpi_div_int( X, NULL, X, radix ) );
290      if( mpi_cmp_int( X, 0 ) != 0 )
291          MPI_CHK( mpi_write_hlp( X, radix, p ) );
292      if( r < 10 )
293          *(*p)++ = (char)( r + 0x30 );
294      else
295          *(*p)++ = (char)( r + 0x37 );
296  cleanup:
297      return( ret );
298  }
299  int mpi_write_string( const mpi *X, int radix, char *s, size_t *slen )
300  {
301      int ret = 0;
302      size_t n;
303      char *p;
304      mpi T;
305      if( radix < 2 || radix > 16 )
306          return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );
307      n = mpi_msb( X );
308      if( radix >=  4 ) n >>= 1;
309      if( radix >= 16 ) n >>= 1;
310      n += 3;
311      if( *slen < n )
312      {
313          *slen = n;
314          return( POLARSSL_ERR_MPI_BUFFER_TOO_SMALL );
315      }
316      p = s;
317      mpi_init( &T );
318      if( X->s == -1 )
319          *p++ = '-';
320      if( radix == 16 )
321      {
322          int c;
323          size_t i, j, k;
324          for( i = X->n, k = 0; i > 0; i-- )
325          {
326              for( j = ciL; j > 0; j-- )
327              {
328                  c = ( X->p[i - 1] >> ( ( j - 1 ) << 3) ) & 0xFF;
329                  if( c == 0 && k == 0 && ( i + j ) != 2 )
330                      continue;
331                  *(p++) = "0123456789ABCDEF" [c / 16];
332                  *(p++) = "0123456789ABCDEF" [c % 16];
333                  k = 1;
334              }
335          }
336      }
337      else
338      {
339          MPI_CHK( mpi_copy( &T, X ) );
340          if( T.s == -1 )
341              T.s = 1;
342          MPI_CHK( mpi_write_hlp( &T, radix, &p ) );
343      }
344      *p++ = '\0';
345      *slen = p - s;
346  cleanup:
347      mpi_free( &T );
348      return( ret );
349  }
350  #endif
351  #if defined(POLARSSL_FS_IO)
352  int mpi_read_file( mpi *X, int radix, FILE *fin )
353  {
354      t_uint d;
355      size_t slen;
356      char *p;
357      char s[ POLARSSL_MPI_RW_BUFFER_SIZE ];
358      memset( s, 0, sizeof( s ) );
359      if( fgets( s, sizeof( s ) - 1, fin ) == NULL )
360          return( POLARSSL_ERR_MPI_FILE_IO_ERROR );
361      slen = strlen( s );
362      if( slen == sizeof( s ) - 2 )
363          return( POLARSSL_ERR_MPI_BUFFER_TOO_SMALL );
364      if( s[slen - 1] == '\n' ) { slen--; s[slen] = '\0'; }
365      if( s[slen - 1] == '\r' ) { slen--; s[slen] = '\0'; }
366      p = s + slen;
367      while( --p >= s )
368          if( mpi_get_digit( &d, radix, *p ) != 0 )
369              break;
370      return( mpi_read_string( X, radix, p + 1 ) );
371  }
372  int mpi_write_file( const char *p, const mpi *X, int radix, FILE *fout )
373  {
374      int ret;
375      size_t n, slen, plen;
376      char s[ POLARSSL_MPI_RW_BUFFER_SIZE ];
377      n = sizeof( s );
378      memset( s, 0, n );
379      n -= 2;
380      MPI_CHK( mpi_write_string( X, radix, s, (size_t *) &n ) );
381      if( p == NULL ) p = "";
382      plen = strlen( p );
383      slen = strlen( s );
384      s[slen++] = '\r';
385      s[slen++] = '\n';
386      if( fout != NULL )
387      {
388          if( fwrite( p, 1, plen, fout ) != plen ||
389              fwrite( s, 1, slen, fout ) != slen )
390              return( POLARSSL_ERR_MPI_FILE_IO_ERROR );
391      }
392      else
393          polarssl_printf( "%s%s", p, s );
394  cleanup:
395      return( ret );
396  }
397  #endif &bsol;* POLARSSL_FS_IO */
398  int mpi_read_binary( mpi *X, const unsigned char *buf, size_t buflen )
399  {
400      int ret;
401      size_t i, j, n;
402      for( n = 0; n < buflen; n++ )
403          if( buf[n] != 0 )
404              break;
405      MPI_CHK( mpi_grow( X, CHARS_TO_LIMBS( buflen - n ) ) );
406      MPI_CHK( mpi_lset( X, 0 ) );
407      for( i = buflen, j = 0; i > n; i--, j++ )
408          X->p[j / ciL] |= ((t_uint) buf[i - 1]) << ((j % ciL) << 3);
409  cleanup:
410      return( ret );
411  }
412  int mpi_write_binary( const mpi *X, unsigned char *buf, size_t buflen )
413  {
414      size_t i, j, n;
415      n = mpi_size( X );
416      if( buflen < n )
417          return( POLARSSL_ERR_MPI_BUFFER_TOO_SMALL );
418      memset( buf, 0, buflen );
419      for( i = buflen - 1, j = 0; n > 0; i--, j++, n-- )
420          buf[i] = (unsigned char)( X->p[j / ciL] >> ((j % ciL) << 3) );
421      return( 0 );
422  }
423  int mpi_shift_l( mpi *X, size_t count )
424  {
425      int ret;
426      size_t i, v0, t1;
427      t_uint r0 = 0, r1;
428      v0 = count / (biL    );
429      t1 = count & (biL - 1);
430      i = mpi_msb( X ) + count;
431      if( X->n * biL < i )
432          MPI_CHK( mpi_grow( X, BITS_TO_LIMBS( i ) ) );
433      ret = 0;
434      if( v0 > 0 )
435      {
436          for( i = X->n; i > v0; i-- )
437              X->p[i - 1] = X->p[i - v0 - 1];
438          for( ; i > 0; i-- )
439              X->p[i - 1] = 0;
440      }
441      if( t1 > 0 )
442      {
443          for( i = v0; i < X->n; i++ )
444          {
445              r1 = X->p[i] >> (biL - t1);
446              X->p[i] <<= t1;
447              X->p[i] |= r0;
448              r0 = r1;
449          }
450      }
451  cleanup:
452      return( ret );
453  }
454  int mpi_shift_r( mpi *X, size_t count )
455  {
456      size_t i, v0, v1;
457      t_uint r0 = 0, r1;
458      v0 = count /  biL;
459      v1 = count & (biL - 1);
460      if( v0 > X->n || ( v0 == X->n && v1 > 0 ) )
461          return mpi_lset( X, 0 );
462      if( v0 > 0 )
463      {
464          for( i = 0; i < X->n - v0; i++ )
465              X->p[i] = X->p[i + v0];
466          for( ; i < X->n; i++ )
467              X->p[i] = 0;
468      }
469      if( v1 > 0 )
470      {
471          for( i = X->n; i > 0; i-- )
472          {
473              r1 = X->p[i - 1] << (biL - v1);
474              X->p[i - 1] >>= v1;
475              X->p[i - 1] |= r0;
476              r0 = r1;
477          }
478      }
479      return( 0 );
480  }
481  int mpi_cmp_abs( const mpi *X, const mpi *Y )
482  {
483      size_t i, j;
484      for( i = X->n; i > 0; i-- )
485          if( X->p[i - 1] != 0 )
486              break;
487      for( j = Y->n; j > 0; j-- )
488          if( Y->p[j - 1] != 0 )
489              break;
490      if( i == 0 && j == 0 )
491          return( 0 );
492      if( i > j ) return(  1 );
493      if( j > i ) return( -1 );
494      for( ; i > 0; i-- )
495      {
496          if( X->p[i - 1] > Y->p[i - 1] ) return(  1 );
497          if( X->p[i - 1] < Y->p[i - 1] ) return( -1 );
498      }
499      return( 0 );
500  }
501  int mpi_cmp_mpi( const mpi *X, const mpi *Y )
502  {
503      size_t i, j;
504      for( i = X->n; i > 0; i-- )
505          if( X->p[i - 1] != 0 )
506              break;
507      for( j = Y->n; j > 0; j-- )
508          if( Y->p[j - 1] != 0 )
509              break;
510      if( i == 0 && j == 0 )
511          return( 0 );
512      if( i > j ) return(  X->s );
513      if( j > i ) return( -Y->s );
514      if( X->s > 0 && Y->s < 0 ) return(  1 );
515      if( Y->s > 0 && X->s < 0 ) return( -1 );
516      for( ; i > 0; i-- )
517      {
518          if( X->p[i - 1] > Y->p[i - 1] ) return(  X->s );
519          if( X->p[i - 1] < Y->p[i - 1] ) return( -X->s );
520      }
521      return( 0 );
522  }
523  int mpi_cmp_int( const mpi *X, t_sint z )
524  {
525      mpi Y;
526      t_uint p[1];
527      *p  = ( z < 0 ) ? -z : z;
528      Y.s = ( z < 0 ) ? -1 : 1;
529      Y.n = 1;
530      Y.p = p;
531      return( mpi_cmp_mpi( X, &Y ) );
532  }
533  int mpi_add_abs( mpi *X, const mpi *A, const mpi *B )
534  {
535      int ret;
536      size_t i, j;
537      t_uint *o, *p, c;
538      if( X == B )
539      {
540          const mpi *T = A; A = X; B = T;
541      }
542      if( X != A )
543          MPI_CHK( mpi_copy( X, A ) );
544      X->s = 1;
545      for( j = B->n; j > 0; j-- )
546          if( B->p[j - 1] != 0 )
547              break;
548      MPI_CHK( mpi_grow( X, j ) );
549      o = B->p; p = X->p; c = 0;
550      for( i = 0; i < j; i++, o++, p++ )
551      {
552          *p +=  c; c  = ( *p <  c );
553          *p += *o; c += ( *p < *o );
554      }
555      while( c != 0 )
556      {
557          if( i >= X->n )
558          {
559              MPI_CHK( mpi_grow( X, i + 1 ) );
560              p = X->p + i;
561          }
562          *p += c; c = ( *p < c ); i++; p++;
563      }
564  cleanup:
565      return( ret );
566  }
567  static void mpi_sub_hlp( size_t n, t_uint *s, t_uint *d )
568  {
569      size_t i;
570      t_uint c, z;
571      for( i = c = 0; i < n; i++, s++, d++ )
572      {
573          z = ( *d <  c );     *d -=  c;
574          c = ( *d < *s ) + z; *d -= *s;
575      }
576      while( c != 0 )
577      {
578          z = ( *d < c ); *d -= c;
579          c = z; i++; d++;
580      }
581  }
582  int mpi_sub_abs( mpi *X, const mpi *A, const mpi *B )
583  {
584      mpi TB;
585      int ret;
586      size_t n;
587      if( mpi_cmp_abs( A, B ) < 0 )
588          return( POLARSSL_ERR_MPI_NEGATIVE_VALUE );
589      mpi_init( &TB );
590      if( X == B )
591      {
592          MPI_CHK( mpi_copy( &TB, B ) );
593          B = &TB;
594      }
595      if( X != A )
596          MPI_CHK( mpi_copy( X, A ) );
597      X->s = 1;
598      ret = 0;
599      for( n = B->n; n > 0; n-- )
600          if( B->p[n - 1] != 0 )
601              break;
602      mpi_sub_hlp( n, B->p, X->p );
603  cleanup:
604      mpi_free( &TB );
605      return( ret );
606  }
607  int mpi_add_mpi( mpi *X, const mpi *A, const mpi *B )
608  {
609      int ret, s = A->s;
610      if( A->s * B->s < 0 )
611      {
612          if( mpi_cmp_abs( A, B ) >= 0 )
613          {
614              MPI_CHK( mpi_sub_abs( X, A, B ) );
615              X->s =  s;
616          }
617          else
618          {
619              MPI_CHK( mpi_sub_abs( X, B, A ) );
620              X->s = -s;
621          }
622      }
623      else
624      {
625          MPI_CHK( mpi_add_abs( X, A, B ) );
626          X->s = s;
627      }
628  cleanup:
629      return( ret );
630  }
631  int mpi_sub_mpi( mpi *X, const mpi *A, const mpi *B )
632  {
633      int ret, s = A->s;
634      if( A->s * B->s > 0 )
635      {
636          if( mpi_cmp_abs( A, B ) >= 0 )
637          {
638              MPI_CHK( mpi_sub_abs( X, A, B ) );
639              X->s =  s;
640          }
641          else
642          {
643              MPI_CHK( mpi_sub_abs( X, B, A ) );
644              X->s = -s;
645          }
646      }
647      else
648      {
649          MPI_CHK( mpi_add_abs( X, A, B ) );
650          X->s = s;
651      }
652  cleanup:
653      return( ret );
654  }
655  #if 0
656  int mpi_add_int( mpi *X, const mpi *A, t_sint b )
657  {
658      mpi _B;
659      t_uint p[1];
660      p[0] = ( b < 0 ) ? -b : b;
661      _B.s = ( b < 0 ) ? -1 : 1;
662      _B.n = 1;
663      _B.p = p;
664      return( mpi_add_mpi( X, A, &_B ) );
665  }
666  int mpi_sub_int( mpi *X, const mpi *A, t_sint b )
667  {
668      mpi _B;
669      t_uint p[1];
670      p[0] = ( b < 0 ) ? -b : b;
671      _B.s = ( b < 0 ) ? -1 : 1;
672      _B.n = 1;
673      _B.p = p;
674      return( mpi_sub_mpi( X, A, &_B ) );
675  }
676  #endif
677  static
678  #if defined(__APPLE__) && defined(__arm__)
679  __attribute__ ((noinline))
680  #endif
681  void mpi_mul_hlp( size_t i, t_uint *s, t_uint *d, t_uint b )
682  {
683      t_uint c = 0, t = 0;
684  #if defined(MULADDC_HUIT)
685      for( ; i >= 8; i -= 8 )
686      {
687          MULADDC_INIT
688          MULADDC_HUIT
689          MULADDC_STOP
690      }
691      for( ; i > 0; i-- )
692      {
693          MULADDC_INIT
694          MULADDC_CORE
695          MULADDC_STOP
696      }
697  #else &bsol;* MULADDC_HUIT */
698      for( ; i >= 16; i -= 16 )
699      {
700          MULADDC_INIT
701          MULADDC_CORE   MULADDC_CORE
702          MULADDC_CORE   MULADDC_CORE
703          MULADDC_CORE   MULADDC_CORE
704          MULADDC_CORE   MULADDC_CORE
705          MULADDC_CORE   MULADDC_CORE
706          MULADDC_CORE   MULADDC_CORE
707          MULADDC_CORE   MULADDC_CORE
708          MULADDC_CORE   MULADDC_CORE
709          MULADDC_STOP
710      }
711      for( ; i >= 8; i -= 8 )
712      {
713          MULADDC_INIT
714          MULADDC_CORE   MULADDC_CORE
715          MULADDC_CORE   MULADDC_CORE
716          MULADDC_CORE   MULADDC_CORE
717          MULADDC_CORE   MULADDC_CORE
718          MULADDC_STOP
719      }
720      for( ; i > 0; i-- )
721      {
722          MULADDC_INIT
723          MULADDC_CORE
724          MULADDC_STOP
725      }
726  #endif &bsol;* MULADDC_HUIT */
727      t++;
728      do {
729          *d += c; c = ( *d < c ); d++;
730      }
731      while( c != 0 );
732  }
733  int mpi_mul_mpi( mpi *X, const mpi *A, const mpi *B )
734  {
735      int ret;
736      size_t i, j;
737      mpi TA, TB;
738      mpi_init( &TA ); mpi_init( &TB );
739      if( X == A ) { MPI_CHK( mpi_copy( &TA, A ) ); A = &TA; }
740      if( X == B ) { MPI_CHK( mpi_copy( &TB, B ) ); B = &TB; }
741      for( i = A->n; i > 0; i-- )
742          if( A->p[i - 1] != 0 )
743              break;
744      for( j = B->n; j > 0; j-- )
745          if( B->p[j - 1] != 0 )
746              break;
747      MPI_CHK( mpi_grow( X, i + j ) );
748      MPI_CHK( mpi_lset( X, 0 ) );
749      for( i++; j > 0; j-- )
750          mpi_mul_hlp( i - 1, A->p, X->p + j - 1, B->p[j - 1] );
751      X->s = A->s * B->s;
752  cleanup:
753      mpi_free( &TB ); mpi_free( &TA );
754      return( ret );
755  }
756  int mpi_mul_int( mpi *X, const mpi *A, t_sint b )
757  {
758      mpi _B;
759      t_uint p[1];
760      _B.s = 1;
761      _B.n = 1;
762      _B.p = p;
763      p[0] = b;
764      return( mpi_mul_mpi( X, A, &_B ) );
765  }
766  int mpi_div_mpi( mpi *Q, mpi *R, const mpi *A, const mpi *B )
767  {
768      int ret;
769      size_t i, n, t, k;
770      mpi X, Y, Z, T1, T2;
771      if( mpi_cmp_int( B, 0 ) == 0 )
772          return( POLARSSL_ERR_MPI_DIVISION_BY_ZERO );
773      mpi_init( &X ); mpi_init( &Y ); mpi_init( &Z );
774      mpi_init( &T1 ); mpi_init( &T2 );
775      if( mpi_cmp_abs( A, B ) < 0 )
776      {
777          if( Q != NULL ) MPI_CHK( mpi_lset( Q, 0 ) );
778          if( R != NULL ) MPI_CHK( mpi_copy( R, A ) );
779          return( 0 );
780      }
781      MPI_CHK( mpi_copy( &X, A ) );
782      MPI_CHK( mpi_copy( &Y, B ) );
783      X.s = Y.s = 1;
784      MPI_CHK( mpi_grow( &Z, A->n + 2 ) );
785      MPI_CHK( mpi_lset( &Z,  0 ) );
786      MPI_CHK( mpi_grow( &T1, 2 ) );
787      MPI_CHK( mpi_grow( &T2, 3 ) );
788      k = mpi_msb( &Y ) % biL;
789      if( k < biL - 1 )
790      {
791          k = biL - 1 - k;
792          MPI_CHK( mpi_shift_l( &X, k ) );
793          MPI_CHK( mpi_shift_l( &Y, k ) );
794      }
795      else k = 0;
796      n = X.n - 1;
797      t = Y.n - 1;
798      MPI_CHK( mpi_shift_l( &Y, biL * ( n - t ) ) );
799      while( mpi_cmp_mpi( &X, &Y ) >= 0 )
800      {
801          Z.p[n - t]++;
802          MPI_CHK( mpi_sub_mpi( &X, &X, &Y ) );
803      }
804      MPI_CHK( mpi_shift_r( &Y, biL * ( n - t ) ) );
805      for( i = n; i > t ; i-- )
806      {
807          if( X.p[i] >= Y.p[t] )
808              Z.p[i - t - 1] = ~0;
809          else
810          {
811  #if defined(POLARSSL_HAVE_UDBL)
812              t_udbl r;
813              r  = (t_udbl) X.p[i] << biL;
814              r |= (t_udbl) X.p[i - 1];
815              r /= Y.p[t];
816              if( r > ( (t_udbl) 1 << biL ) - 1 )
817                  r = ( (t_udbl) 1 << biL ) - 1;
818              Z.p[i - t - 1] = (t_uint) r;
819  #else
820              t_uint q0, q1, r0, r1;
821              t_uint d0, d1, d, m;
822              d  = Y.p[t];
823              d0 = ( d << biH ) >> biH;
824              d1 = ( d >> biH );
825              q1 = X.p[i] / d1;
826              r1 = X.p[i] - d1 * q1;
827              r1 <<= biH;
828              r1 |= ( X.p[i - 1] >> biH );
829              m = q1 * d0;
830              if( r1 < m )
831              {
832                  q1--, r1 += d;
833                  while( r1 >= d && r1 < m )
834                      q1--, r1 += d;
835              }
836              r1 -= m;
837              q0 = r1 / d1;
838              r0 = r1 - d1 * q0;
839              r0 <<= biH;
840              r0 |= ( X.p[i - 1] << biH ) >> biH;
841              m = q0 * d0;
842              if( r0 < m )
843              {
844                  q0--, r0 += d;
845                  while( r0 >= d && r0 < m )
846                      q0--, r0 += d;
847              }
848              r0 -= m;
849              Z.p[i - t - 1] = ( q1 << biH ) | q0;
850  #endif &bsol;* POLARSSL_HAVE_UDBL && !64-bit Apple with Clang 5.0 */
851          }
852          Z.p[i - t - 1]++;
853          do
854          {
855              Z.p[i - t - 1]--;
856              MPI_CHK( mpi_lset( &T1, 0 ) );
857              T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
858              T1.p[1] = Y.p[t];
859              MPI_CHK( mpi_mul_int( &T1, &T1, Z.p[i - t - 1] ) );
860              MPI_CHK( mpi_lset( &T2, 0 ) );
861              T2.p[0] = ( i < 2 ) ? 0 : X.p[i - 2];
862              T2.p[1] = ( i < 1 ) ? 0 : X.p[i - 1];
863              T2.p[2] = X.p[i];
864          }
865          while( mpi_cmp_mpi( &T1, &T2 ) > 0 );
866          MPI_CHK( mpi_mul_int( &T1, &Y, Z.p[i - t - 1] ) );
867          MPI_CHK( mpi_shift_l( &T1,  biL * ( i - t - 1 ) ) );
868          MPI_CHK( mpi_sub_mpi( &X, &X, &T1 ) );
869          if( mpi_cmp_int( &X, 0 ) < 0 )
870          {
871              MPI_CHK( mpi_copy( &T1, &Y ) );
872              MPI_CHK( mpi_shift_l( &T1, biL * ( i - t - 1 ) ) );
873              MPI_CHK( mpi_add_mpi( &X, &X, &T1 ) );
874              Z.p[i - t - 1]--;
875          }
876      }
877      if( Q != NULL )
878      {
879          MPI_CHK( mpi_copy( Q, &Z ) );
880          Q->s = A->s * B->s;
881      }
882      if( R != NULL )
883      {
884          MPI_CHK( mpi_shift_r( &X, k ) );
885          X.s = A->s;
886          MPI_CHK( mpi_copy( R, &X ) );
887          if( mpi_cmp_int( R, 0 ) == 0 )
888              R->s = 1;
889      }
890  cleanup:
891      mpi_free( &X ); mpi_free( &Y ); mpi_free( &Z );
892      mpi_free( &T1 ); mpi_free( &T2 );
893      return( ret );
894  }
895  #if 0
896  int mpi_div_int( mpi *Q, mpi *R, const mpi *A, t_sint b )
897  {
898      mpi _B;
899      t_uint p[1];
900      p[0] = ( b < 0 ) ? -b : b;
901      _B.s = ( b < 0 ) ? -1 : 1;
902      _B.n = 1;
903      _B.p = p;
904      return( mpi_div_mpi( Q, R, A, &_B ) );
905  }
906  #endif
907  int mpi_mod_mpi( mpi *R, const mpi *A, const mpi *B )
908  {
909      int ret;
910      if( mpi_cmp_int( B, 0 ) < 0 )
911          return( POLARSSL_ERR_MPI_NEGATIVE_VALUE );
912      MPI_CHK( mpi_div_mpi( NULL, R, A, B ) );
913      while( mpi_cmp_int( R, 0 ) < 0 )
914        MPI_CHK( mpi_add_mpi( R, R, B ) );
915      while( mpi_cmp_mpi( R, B ) >= 0 )
916        MPI_CHK( mpi_sub_mpi( R, R, B ) );
917  cleanup:
918      return( ret );
919  }
920  #if 0
921  int mpi_mod_int( t_uint *r, const mpi *A, t_sint b )
922  {
923      size_t i;
924      t_uint x, y, z;
925      if( b == 0 )
926          return( POLARSSL_ERR_MPI_DIVISION_BY_ZERO );
927      if( b < 0 )
928          return( POLARSSL_ERR_MPI_NEGATIVE_VALUE );
929      if( b == 1 )
930      {
931          *r = 0;
932          return( 0 );
933      }
934      if( b == 2 )
935      {
936          *r = A->p[0] & 1;
937          return( 0 );
938      }
939      for( i = A->n, y = 0; i > 0; i-- )
940      {
941          x  = A->p[i - 1];
942          y  = ( y << biH ) | ( x >> biH );
943          z  = y / b;
944          y -= z * b;
945          x <<= biH;
946          y  = ( y << biH ) | ( x >> biH );
947          z  = y / b;
948          y -= z * b;
949      }
950      if( A->s < 0 && y != 0 )
951          y = b - y;
952      *r = y;
953      return( 0 );
954  }
955  #endif
956  static void mpi_montg_init( t_uint *mm, const mpi *N )
957  {
958      t_uint x, m0 = N->p[0];
959      unsigned int i;
960      x  = m0;
961      x += ( ( m0 + 2 ) & 4 ) << 1;
962      for( i = biL; i >= 8; i /= 2 )
963          x *= ( 2 - ( m0 * x ) );
964      *mm = ~x + 1;
965  }
966  static void mpi_montmul( mpi *A, const mpi *B, const mpi *N, t_uint mm,
967                           const mpi *T )
968  {
969      size_t i, n, m;
970      t_uint u0, u1, *d;
971      memset( T->p, 0, T->n * ciL );
972      d = T->p;
973      n = N->n;
974      m = ( B->n < n ) ? B->n : n;
975      for( i = 0; i < n; i++ )
976      {
977          u0 = A->p[i];
978          u1 = ( d[0] + u0 * B->p[0] ) * mm;
979          mpi_mul_hlp( m, B->p, d, u0 );
980          mpi_mul_hlp( n, N->p, d, u1 );
981          *d++ = u0; d[n + 1] = 0;
982      }
983      memcpy( A->p, d, ( n + 1 ) * ciL );
984      if( mpi_cmp_abs( A, N ) >= 0 )
985          mpi_sub_hlp( n, N->p, A->p );
986      else
987          mpi_sub_hlp( n, A->p, T->p );
988  }
989  static void mpi_montred( mpi *A, const mpi *N, t_uint mm, const mpi *T )
990  {
991      t_uint z = 1;
992      mpi U;
993      U.n = U.s = (int) z;
994      U.p = &z;
995      mpi_montmul( A, &U, N, mm, T );
996  }
997  int mpi_exp_mod( mpi *X, const mpi *A, const mpi *E, const mpi *N, mpi *_RR )
998  {
999      int ret;
1000      size_t wbits, wsize, one = 1;
1001      size_t i, j, nblimbs;
1002      size_t bufsize, nbits;
1003      t_uint ei, mm, state;
1004      mpi RR, T, W[ 2 << POLARSSL_MPI_WINDOW_SIZE ], Apos;
1005      int neg;
1006      if( mpi_cmp_int( N, 0 ) < 0 || ( N->p[0] & 1 ) == 0 )
1007          return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );
1008      if( mpi_cmp_int( E, 0 ) < 0 )
1009          return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );
1010      mpi_montg_init( &mm, N );
1011      mpi_init( &RR ); mpi_init( &T );
1012      mpi_init( &Apos );
1013      memset( W, 0, sizeof( W ) );
1014      i = mpi_msb( E );
1015      wsize = ( i > 671 ) ? 6 : ( i > 239 ) ? 5 :
1016              ( i >  79 ) ? 4 : ( i >  23 ) ? 3 : 1;
1017      if( wsize > POLARSSL_MPI_WINDOW_SIZE )
1018          wsize = POLARSSL_MPI_WINDOW_SIZE;
1019      j = N->n + 1;
1020      MPI_CHK( mpi_grow( X, j ) );
1021      MPI_CHK( mpi_grow( &W[1],  j ) );
1022      MPI_CHK( mpi_grow( &T, j * 2 ) );
1023      neg = ( A->s == -1 );
1024      if( neg )
1025      {
1026          MPI_CHK( mpi_copy( &Apos, A ) );
1027          Apos.s = 1;
1028          A = &Apos;
1029      }
1030      if( _RR == NULL || _RR->p == NULL )
1031      {
1032          MPI_CHK( mpi_lset( &RR, 1 ) );
1033          MPI_CHK( mpi_shift_l( &RR, N->n * 2 * biL ) );
1034          MPI_CHK( mpi_mod_mpi( &RR, &RR, N ) );
1035          if( _RR != NULL )
1036              memcpy( _RR, &RR, sizeof( mpi ) );
1037      }
1038      else
1039          memcpy( &RR, _RR, sizeof( mpi ) );
1040      if( mpi_cmp_mpi( A, N ) >= 0 )
1041          MPI_CHK( mpi_mod_mpi( &W[1], A, N ) );
1042      else
1043          MPI_CHK( mpi_copy( &W[1], A ) );
1044      mpi_montmul( &W[1], &RR, N, mm, &T );
1045      MPI_CHK( mpi_copy( X, &RR ) );
1046      mpi_montred( X, N, mm, &T );
1047      if( wsize > 1 )
1048      {
1049          j =  one << ( wsize - 1 );
1050          MPI_CHK( mpi_grow( &W[j], N->n + 1 ) );
1051          MPI_CHK( mpi_copy( &W[j], &W[1]    ) );
1052          for( i = 0; i < wsize - 1; i++ )
1053              mpi_montmul( &W[j], &W[j], N, mm, &T );
1054          for( i = j + 1; i < ( one << wsize ); i++ )
1055          {
1056              MPI_CHK( mpi_grow( &W[i], N->n + 1 ) );
1057              MPI_CHK( mpi_copy( &W[i], &W[i - 1] ) );
1058              mpi_montmul( &W[i], &W[1], N, mm, &T );
1059          }
1060      }
1061      nblimbs = E->n;
1062      bufsize = 0;
1063      nbits   = 0;
1064      wbits   = 0;
1065      state   = 0;
1066      while( 1 )
1067      {
1068          if( bufsize == 0 )
1069          {
1070              if( nblimbs == 0 )
1071                  break;
1072              nblimbs--;
1073              bufsize = sizeof( t_uint ) << 3;
1074          }
1075          bufsize--;
1076          ei = (E->p[nblimbs] >> bufsize) & 1;
1077          if( ei == 0 && state == 0 )
1078              continue;
1079          if( ei == 0 && state == 1 )
1080          {
1081              mpi_montmul( X, X, N, mm, &T );
1082              continue;
1083          }
1084          state = 2;
1085          nbits++;
1086          wbits |= ( ei << ( wsize - nbits ) );
1087          if( nbits == wsize )
1088          {
1089              for( i = 0; i < wsize; i++ )
1090                  mpi_montmul( X, X, N, mm, &T );
1091              mpi_montmul( X, &W[wbits], N, mm, &T );
1092              state--;
1093              nbits = 0;
1094              wbits = 0;
1095          }
1096      }
1097      for( i = 0; i < nbits; i++ )
1098      {
1099          mpi_montmul( X, X, N, mm, &T );
1100          wbits <<= 1;
1101          if( ( wbits & ( one << wsize ) ) != 0 )
1102              mpi_montmul( X, &W[1], N, mm, &T );
1103      }
1104      mpi_montred( X, N, mm, &T );
1105      if( neg )
1106      {
1107          X->s = -1;
1108          MPI_CHK( mpi_add_mpi( X, N, X ) );
1109      }
1110  cleanup:
1111      for( i = ( one << ( wsize - 1 ) ); i < ( one << wsize ); i++ )
1112          mpi_free( &W[i] );
1113      mpi_free( &W[1] ); mpi_free( &T ); mpi_free( &Apos );
1114      if( _RR == NULL || _RR->p == NULL )
1115          mpi_free( &RR );
1116      return( ret );
1117  }
1118  #if 0
1119  int mpi_gcd( mpi *G, const mpi *A, const mpi *B )
1120  {
1121      int ret;
1122      size_t lz, lzt;
1123      mpi TG, TA, TB;
1124      mpi_init( &TG ); mpi_init( &TA ); mpi_init( &TB );
1125      MPI_CHK( mpi_copy( &TA, A ) );
1126      MPI_CHK( mpi_copy( &TB, B ) );
1127      lz = mpi_lsb( &TA );
1128      lzt = mpi_lsb( &TB );
1129      if( lzt < lz )
1130          lz = lzt;
1131      MPI_CHK( mpi_shift_r( &TA, lz ) );
1132      MPI_CHK( mpi_shift_r( &TB, lz ) );
1133      TA.s = TB.s = 1;
1134      while( mpi_cmp_int( &TA, 0 ) != 0 )
1135      {
1136          MPI_CHK( mpi_shift_r( &TA, mpi_lsb( &TA ) ) );
1137          MPI_CHK( mpi_shift_r( &TB, mpi_lsb( &TB ) ) );
1138          if( mpi_cmp_mpi( &TA, &TB ) >= 0 )
1139          {
1140              MPI_CHK( mpi_sub_abs( &TA, &TA, &TB ) );
1141              MPI_CHK( mpi_shift_r( &TA, 1 ) );
1142          }
1143          else
1144          {
1145              MPI_CHK( mpi_sub_abs( &TB, &TB, &TA ) );
1146              MPI_CHK( mpi_shift_r( &TB, 1 ) );
1147          }
1148      }
1149      MPI_CHK( mpi_shift_l( &TB, lz ) );
1150      MPI_CHK( mpi_copy( G, &TB ) );
1151  cleanup:
1152      mpi_free( &TG ); mpi_free( &TA ); mpi_free( &TB );
1153      return( ret );
1154  }
1155  int mpi_fill_random( mpi *X, size_t size,
1156                       int (*f_rng)(void *, unsigned char *, size_t),
1157                       void *p_rng )
1158  {
1159      int ret;
1160      unsigned char buf[POLARSSL_MPI_MAX_SIZE];
1161      if( size > POLARSSL_MPI_MAX_SIZE )
1162          return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );
1163      MPI_CHK( f_rng( p_rng, buf, size ) );
1164      MPI_CHK( mpi_read_binary( X, buf, size ) );
1165  cleanup:
1166      return( ret );
1167  }
1168  int mpi_inv_mod( mpi *X, const mpi *A, const mpi *N )
1169  {
1170      int ret;
1171      mpi G, TA, TU, U1, U2, TB, TV, V1, V2;
1172      if( mpi_cmp_int( N, 0 ) <= 0 )
1173          return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );
1174      mpi_init( &TA ); mpi_init( &TU ); mpi_init( &U1 ); mpi_init( &U2 );
1175      mpi_init( &G ); mpi_init( &TB ); mpi_init( &TV );
1176      mpi_init( &V1 ); mpi_init( &V2 );
1177      MPI_CHK( mpi_gcd( &G, A, N ) );
1178      if( mpi_cmp_int( &G, 1 ) != 0 )
1179      {
1180          ret = POLARSSL_ERR_MPI_NOT_ACCEPTABLE;
1181          goto cleanup;
1182      }
1183      MPI_CHK( mpi_mod_mpi( &TA, A, N ) );
1184      MPI_CHK( mpi_copy( &TU, &TA ) );
1185      MPI_CHK( mpi_copy( &TB, N ) );
1186      MPI_CHK( mpi_copy( &TV, N ) );
1187      MPI_CHK( mpi_lset( &U1, 1 ) );
1188      MPI_CHK( mpi_lset( &U2, 0 ) );
1189      MPI_CHK( mpi_lset( &V1, 0 ) );
1190      MPI_CHK( mpi_lset( &V2, 1 ) );
1191      do
1192      {
1193          while( ( TU.p[0] & 1 ) == 0 )
1194          {
1195              MPI_CHK( mpi_shift_r( &TU, 1 ) );
1196              if( ( U1.p[0] & 1 ) != 0 || ( U2.p[0] & 1 ) != 0 )
1197              {
1198                  MPI_CHK( mpi_add_mpi( &U1, &U1, &TB ) );
1199                  MPI_CHK( mpi_sub_mpi( &U2, &U2, &TA ) );
1200              }
1201              MPI_CHK( mpi_shift_r( &U1, 1 ) );
1202              MPI_CHK( mpi_shift_r( &U2, 1 ) );
1203          }
1204          while( ( TV.p[0] & 1 ) == 0 )
1205          {
1206              MPI_CHK( mpi_shift_r( &TV, 1 ) );
1207              if( ( V1.p[0] & 1 ) != 0 || ( V2.p[0] & 1 ) != 0 )
1208              {
1209                  MPI_CHK( mpi_add_mpi( &V1, &V1, &TB ) );
1210                  MPI_CHK( mpi_sub_mpi( &V2, &V2, &TA ) );
1211              }
1212              MPI_CHK( mpi_shift_r( &V1, 1 ) );
1213              MPI_CHK( mpi_shift_r( &V2, 1 ) );
1214          }
1215          if( mpi_cmp_mpi( &TU, &TV ) >= 0 )
1216          {
1217              MPI_CHK( mpi_sub_mpi( &TU, &TU, &TV ) );
1218              MPI_CHK( mpi_sub_mpi( &U1, &U1, &V1 ) );
1219              MPI_CHK( mpi_sub_mpi( &U2, &U2, &V2 ) );
1220          }
1221          else
1222          {
1223              MPI_CHK( mpi_sub_mpi( &TV, &TV, &TU ) );
1224              MPI_CHK( mpi_sub_mpi( &V1, &V1, &U1 ) );
1225              MPI_CHK( mpi_sub_mpi( &V2, &V2, &U2 ) );
1226          }
1227      }
1228      while( mpi_cmp_int( &TU, 0 ) != 0 );
1229      while( mpi_cmp_int( &V1, 0 ) < 0 )
1230          MPI_CHK( mpi_add_mpi( &V1, &V1, N ) );
1231      while( mpi_cmp_mpi( &V1, N ) >= 0 )
1232          MPI_CHK( mpi_sub_mpi( &V1, &V1, N ) );
1233      MPI_CHK( mpi_copy( X, &V1 ) );
1234  cleanup:
1235      mpi_free( &TA ); mpi_free( &TU ); mpi_free( &U1 ); mpi_free( &U2 );
1236      mpi_free( &G ); mpi_free( &TB ); mpi_free( &TV );
1237      mpi_free( &V1 ); mpi_free( &V2 );
1238      return( ret );
1239  }
1240  #endif
1241  #if defined(POLARSSL_GENPRIME)
1242  static const int small_prime[] =
1243  {
1244          3,    5,    7,   11,   13,   17,   19,   23,
1245         29,   31,   37,   41,   43,   47,   53,   59,
1246         61,   67,   71,   73,   79,   83,   89,   97,
1247        101,  103,  107,  109,  113,  127,  131,  137,
1248        139,  149,  151,  157,  163,  167,  173,  179,
1249        181,  191,  193,  197,  199,  211,  223,  227,
1250        229,  233,  239,  241,  251,  257,  263,  269,
1251        271,  277,  281,  283,  293,  307,  311,  313,
1252        317,  331,  337,  347,  349,  353,  359,  367,
1253        373,  379,  383,  389,  397,  401,  409,  419,
1254        421,  431,  433,  439,  443,  449,  457,  461,
1255        463,  467,  479,  487,  491,  499,  503,  509,
1256        521,  523,  541,  547,  557,  563,  569,  571,
1257        577,  587,  593,  599,  601,  607,  613,  617,
1258        619,  631,  641,  643,  647,  653,  659,  661,
1259        673,  677,  683,  691,  701,  709,  719,  727,
1260        733,  739,  743,  751,  757,  761,  769,  773,
1261        787,  797,  809,  811,  821,  823,  827,  829,
1262        839,  853,  857,  859,  863,  877,  881,  883,
1263        887,  907,  911,  919,  929,  937,  941,  947,
1264        953,  967,  971,  977,  983,  991,  997, -103
1265  };
1266  static int mpi_check_small_factors( const mpi *X )
1267  {
1268      int ret = 0;
1269      size_t i;
1270      t_uint r;
1271      if( ( X->p[0] & 1 ) == 0 )
1272          return( POLARSSL_ERR_MPI_NOT_ACCEPTABLE );
1273      for( i = 0; small_prime[i] > 0; i++ )
1274      {
1275          if( mpi_cmp_int( X, small_prime[i] ) <= 0 )
1276              return( 1 );
1277          MPI_CHK( mpi_mod_int( &r, X, small_prime[i] ) );
1278          if( r == 0 )
1279              return( POLARSSL_ERR_MPI_NOT_ACCEPTABLE );
1280      }
1281  cleanup:
1282      return( ret );
1283  }
1284  static int mpi_miller_rabin( const mpi *X,
1285                               int (*f_rng)(void *, unsigned char *, size_t),
1286                               void *p_rng )
1287  {
1288      int ret, count;
1289      size_t i, j, k, n, s;
1290      mpi W, R, T, A, RR;
1291      mpi_init( &W ); mpi_init( &R ); mpi_init( &T ); mpi_init( &A );
1292      mpi_init( &RR );
1293      MPI_CHK( mpi_sub_int( &W, X, 1 ) );
1294      s = mpi_lsb( &W );
1295      MPI_CHK( mpi_copy( &R, &W ) );
1296      MPI_CHK( mpi_shift_r( &R, s ) );
1297      i = mpi_msb( X );
1298      n = ( ( i >= 1300 ) ?  2 : ( i >=  850 ) ?  3 :
1299            ( i >=  650 ) ?  4 : ( i >=  350 ) ?  8 :
1300            ( i >=  250 ) ? 12 : ( i >=  150 ) ? 18 : 27 );
1301      for( i = 0; i < n; i++ )
1302      {
1303          count = 0;
1304          do {
1305              MPI_CHK( mpi_fill_random( &A, X->n * ciL, f_rng, p_rng ) );
1306              j = mpi_msb( &A );
1307              k = mpi_msb( &W );
1308              if (j > k) {
1309                  MPI_CHK( mpi_shift_r( &A, j - k ) );
1310              }
1311              if (count++ > 30) {
1312                  return POLARSSL_ERR_MPI_NOT_ACCEPTABLE;
1313              }
1314          } while ( (mpi_cmp_mpi( &A, &W ) >= 0) ||
1315                    (mpi_cmp_int( &A, 1 )  <= 0)    );
1316          MPI_CHK( mpi_exp_mod( &A, &A, &R, X, &RR ) );
1317          if( mpi_cmp_mpi( &A, &W ) == 0 ||
1318              mpi_cmp_int( &A,  1 ) == 0 )
1319              continue;
1320          j = 1;
1321          while( j < s && mpi_cmp_mpi( &A, &W ) != 0 )
1322          {
1323              MPI_CHK( mpi_mul_mpi( &T, &A, &A ) );
1324              MPI_CHK( mpi_mod_mpi( &A, &T, X  ) );
1325              if( mpi_cmp_int( &A, 1 ) == 0 )
1326                  break;
1327              j++;
1328          }
1329          if( mpi_cmp_mpi( &A, &W ) != 0 ||
1330              mpi_cmp_int( &A,  1 ) == 0 )
1331          {
1332              ret = POLARSSL_ERR_MPI_NOT_ACCEPTABLE;
1333              break;
1334          }
1335      }
1336  cleanup:
1337      mpi_free( &W ); mpi_free( &R ); mpi_free( &T ); mpi_free( &A );
1338      mpi_free( &RR );
1339      return( ret );
1340  }
1341  int mpi_is_prime( mpi *X,
1342                    int (*f_rng)(void *, unsigned char *, size_t),
1343                    void *p_rng )
1344  {
1345      int ret;
1346      mpi XX;
1347      XX.s = 1;
1348      XX.n = X->n;
1349      XX.p = X->p;
1350      if( mpi_cmp_int( &XX, 0 ) == 0 ||
1351          mpi_cmp_int( &XX, 1 ) == 0 )
1352          return( POLARSSL_ERR_MPI_NOT_ACCEPTABLE );
1353      if( mpi_cmp_int( &XX, 2 ) == 0 )
1354          return( 0 );
1355      if( ( ret = mpi_check_small_factors( &XX ) ) != 0 )
1356      {
1357          if( ret == 1 )
1358              return( 0 );
1359          return( ret );
1360      }
1361      return( mpi_miller_rabin( &XX, f_rng, p_rng ) );
1362  }
1363  int mpi_gen_prime( mpi *X, size_t nbits, int dh_flag,
1364                     int (*f_rng)(void *, unsigned char *, size_t),
1365                     void *p_rng )
1366  {
1367      int ret;
1368      size_t k, n;
1369      t_uint r;
1370      mpi Y;
1371      if( nbits < 3 || nbits > POLARSSL_MPI_MAX_BITS )
1372          return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );
1373      mpi_init( &Y );
1374      n = BITS_TO_LIMBS( nbits );
1375      MPI_CHK( mpi_fill_random( X, n * ciL, f_rng, p_rng ) );
1376      k = mpi_msb( X );
1377      if( k > nbits ) MPI_CHK( mpi_shift_r( X, k - nbits + 1 ) );
1378      mpi_set_bit( X, nbits-1, 1 );
1379      X->p[0] |= 1;
1380      if( dh_flag == 0 )
1381      {
1382          while( ( ret = mpi_is_prime( X, f_rng, p_rng ) ) != 0 )
1383          {
1384              if( ret != POLARSSL_ERR_MPI_NOT_ACCEPTABLE )
1385                  goto cleanup;
1386              MPI_CHK( mpi_add_int( X, X, 2 ) );
1387          }
1388      }
1389      else
1390      {
1391          X->p[0] |= 2;
1392          MPI_CHK( mpi_mod_int( &r, X, 3 ) );
1393          if( r == 0 )
1394              MPI_CHK( mpi_add_int( X, X, 8 ) );
1395          else if( r == 1 )
1396              MPI_CHK( mpi_add_int( X, X, 4 ) );
1397          MPI_CHK( mpi_copy( &Y, X ) );
1398          MPI_CHK( mpi_shift_r( &Y, 1 ) );
1399          while( 1 )
1400          {
1401              if( ( ret = mpi_check_small_factors(  X         ) ) == 0 &&
1402                  ( ret = mpi_check_small_factors( &Y         ) ) == 0 &&
1403                  ( ret = mpi_miller_rabin(  X, f_rng, p_rng  ) ) == 0 &&
1404                  ( ret = mpi_miller_rabin( &Y, f_rng, p_rng  ) ) == 0 )
1405              {
1406                  break;
1407              }
1408              if( ret != POLARSSL_ERR_MPI_NOT_ACCEPTABLE )
1409                  goto cleanup;
1410              MPI_CHK( mpi_add_int(  X,  X, 12 ) );
1411              MPI_CHK( mpi_add_int( &Y, &Y, 6  ) );
1412          }
1413      }
1414  cleanup:
1415      mpi_free( &Y );
1416      return( ret );
1417  }
1418  #endif &bsol;* POLARSSL_GENPRIME */
1419  #if defined(POLARSSL_SELF_TEST)
1420  #define GCD_PAIR_COUNT  3
1421  static const int gcd_pairs[GCD_PAIR_COUNT][3] =
1422  {
1423      { 693, 609, 21 },
1424      { 1764, 868, 28 },
1425      { 768454923, 542167814, 1 }
1426  };
1427  int mpi_self_test( int verbose )
1428  {
1429      int ret, i;
1430      mpi A, E, N, X, Y, U, V;
1431      mpi_init( &A ); mpi_init( &E ); mpi_init( &N ); mpi_init( &X );
1432      mpi_init( &Y ); mpi_init( &U ); mpi_init( &V );
1433      MPI_CHK( mpi_read_string( &A, 16,
1434          "EFE021C2645FD1DC586E69184AF4A31E" \
1435          "D5F53E93B5F123FA41680867BA110131" \
1436          "944FE7952E2517337780CB0DB80E61AA" \
1437          "E7C8DDC6C5C6AADEB34EB38A2F40D5E6" ) );
1438      MPI_CHK( mpi_read_string( &E, 16,
1439          "B2E7EFD37075B9F03FF989C7C5051C20" \
1440          "34D2A323810251127E7BF8625A4F49A5" \
1441          "F3E27F4DA8BD59C47D6DAABA4C8127BD" \
1442          "5B5C25763222FEFCCFC38B832366C29E" ) );
1443      MPI_CHK( mpi_read_string( &N, 16,
1444          "0066A198186C18C10B2F5ED9B522752A" \
1445          "9830B69916E535C8F047518A889A43A5" \
1446          "94B6BED27A168D31D4A52F88925AA8F5" ) );
1447      MPI_CHK( mpi_mul_mpi( &X, &A, &N ) );
1448      MPI_CHK( mpi_read_string( &U, 16,
1449          "602AB7ECA597A3D6B56FF9829A5E8B85" \
1450          "9E857EA95A03512E2BAE7391688D264A" \
1451          "A5663B0341DB9CCFD2C4C5F421FEC814" \
1452          "8001B72E848A38CAE1C65F78E56ABDEF" \
1453          "E12D3C039B8A02D6BE593F0BBBDA56F1" \
1454          "ECF677152EF804370C1A305CAF3B5BF1" \
<span onclick='openModal()' class='match'>1455          "30879B56C61DE584A0F53A2447A51E" ) );
1456      if( verbose != 0 )
1457          polarssl_printf( "  MPI test #1 (mul_mpi): " );
1458      if( mpi_cmp_mpi( &X, &U ) != 0 )
</span>1459      {
1460          if( verbose != 0 )
1461              polarssl_printf( "failed\n" );
1462          ret = 1;
1463          goto cleanup;
1464      }
1465      if( verbose != 0 )
1466          polarssl_printf( "passed\n" );
1467      MPI_CHK( mpi_div_mpi( &X, &Y, &A, &N ) );
1468      MPI_CHK( mpi_read_string( &U, 16,
1469          "256567336059E52CAE22925474705F39A94" ) );
1470      MPI_CHK( mpi_read_string( &V, 16,
1471          "6613F26162223DF488E9CD48CC132C7A" \
1472          "0AC93C701B001B092E4E5B9F73BCD27B" \
1473          "9EE50D0657C77F374E903CDFA4C642" ) );
1474      if( verbose != 0 )
1475          polarssl_printf( "  MPI test #2 (div_mpi): " );
1476      if( mpi_cmp_mpi( &X, &U ) != 0 ||
1477          mpi_cmp_mpi( &Y, &V ) != 0 )
1478      {
1479          if( verbose != 0 )
1480              polarssl_printf( "failed\n" );
1481          ret = 1;
1482          goto cleanup;
1483      }
1484      if( verbose != 0 )
1485          polarssl_printf( "passed\n" );
1486      MPI_CHK( mpi_exp_mod( &X, &A, &E, &N, NULL ) );
1487      MPI_CHK( mpi_read_string( &U, 16,
1488          "36E139AEA55215609D2816998ED020BB" \
1489          "BD96C37890F65171D948E9BC7CBAA4D9" \
1490          "325D24D6A3C12710F10A09FA08AB87" ) );
1491      if( verbose != 0 )
1492          polarssl_printf( "  MPI test #3 (exp_mod): " );
1493      if( mpi_cmp_mpi( &X, &U ) != 0 )
1494      {
1495          if( verbose != 0 )
1496              polarssl_printf( "failed\n" );
1497          ret = 1;
1498          goto cleanup;
1499      }
1500      if( verbose != 0 )
1501          polarssl_printf( "passed\n" );
1502      MPI_CHK( mpi_inv_mod( &X, &A, &N ) );
1503      MPI_CHK( mpi_read_string( &U, 16,
1504          "003A0AAEDD7E784FC07D8F9EC6E3BFD5" \
1505          "C3DBA76456363A10869622EAC2DD84EC" \
1506          "C5B8A74DAC4D09E03B5E0BE779F2DF61" ) );
1507      if( verbose != 0 )
1508          polarssl_printf( "  MPI test #4 (inv_mod): " );
1509      if( mpi_cmp_mpi( &X, &U ) != 0 )
1510      {
1511          if( verbose != 0 )
1512              polarssl_printf( "failed\n" );
1513          ret = 1;
1514          goto cleanup;
1515      }
1516      if( verbose != 0 )
1517          polarssl_printf( "passed\n" );
1518      if( verbose != 0 )
1519          polarssl_printf( "  MPI test #5 (simple gcd): " );
1520      for( i = 0; i < GCD_PAIR_COUNT; i++ )
1521      {
1522          MPI_CHK( mpi_lset( &X, gcd_pairs[i][0] ) );
1523          MPI_CHK( mpi_lset( &Y, gcd_pairs[i][1] ) );
1524          MPI_CHK( mpi_gcd( &A, &X, &Y ) );
1525          if( mpi_cmp_int( &A, gcd_pairs[i][2] ) != 0 )
1526          {
1527              if( verbose != 0 )
1528                  polarssl_printf( "failed at %d\n", i );
1529              ret = 1;
1530              goto cleanup;
1531          }
1532      }
1533      if( verbose != 0 )
1534          polarssl_printf( "passed\n" );
1535  cleanup:
1536      if( ret != 0 && verbose != 0 )
1537          polarssl_printf( "Unexpected error, return code = %08X\n", ret );
1538      mpi_free( &A ); mpi_free( &E ); mpi_free( &N ); mpi_free( &X );
1539      mpi_free( &Y ); mpi_free( &U ); mpi_free( &V );
1540      if( verbose != 0 )
1541          polarssl_printf( "\n" );
1542      return( ret );
1543  }
1544  #endif &bsol;* POLARSSL_SELF_TEST */
1545  #endif &bsol;* POLARSSL_BIGNUM_C */
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-bignum.c</h3>
            <pre><code>1  #if !defined(POLARSSL_CONFIG_FILE)
2  #include "config.h"
3  #else
4  #include POLARSSL_CONFIG_FILE
5  #endif
6  #if defined(POLARSSL_BIGNUM_C)
7  #include "bignum.h"
8  #include "bn_mul.h"
9  #include <string.h>
10  #if defined(POLARSSL_PLATFORM_C)
11  #include "platform.h"
12  #else
13  #include <stdio.h>
14  #include <stdlib.h>
15  #define polarssl_printf     printf
16  #define polarssl_malloc     malloc
17  #define polarssl_free       free
18  #endif
19  static void polarssl_zeroize( void *v, size_t n ) {
20      volatile unsigned char *p = v; while( n-- ) *p++ = 0;
21  }
22  #define ciL    (sizeof(t_uint))         &bsol;* chars in limb  */
23  #define biL    (ciL << 3)               &bsol;* bits  in limb  */
24  #define biH    (ciL << 2)               &bsol;* half limb size */
25  #define BITS_TO_LIMBS(i)  (((i) + biL - 1) / biL)
26  #define CHARS_TO_LIMBS(i) (((i) + ciL - 1) / ciL)
27  void mpi_init( mpi *X )
28  {
29      if( X == NULL )
30          return;
31      X->s = 1;
32      X->n = 0;
33      X->p = NULL;
34  }
35  void mpi_free( mpi *X )
36  {
37      if( X == NULL )
38          return;
39      if( X->p != NULL )
40      {
41          polarssl_zeroize( X->p, X->n * ciL );
42          polarssl_free( X->p );
43      }
44      X->s = 1;
45      X->n = 0;
46      X->p = NULL;
47  }
48  int mpi_grow( mpi *X, size_t nblimbs )
49  {
50      t_uint *p;
51      if( nblimbs > POLARSSL_MPI_MAX_LIMBS )
52          return( POLARSSL_ERR_MPI_MALLOC_FAILED );
53      if( X->n < nblimbs )
54      {
55          if( ( p = polarssl_malloc( nblimbs * ciL ) ) == NULL )
56              return( POLARSSL_ERR_MPI_MALLOC_FAILED );
57          memset( p, 0, nblimbs * ciL );
58          if( X->p != NULL )
59          {
60              memcpy( p, X->p, X->n * ciL );
61              polarssl_zeroize( X->p, X->n * ciL );
62              polarssl_free( X->p );
63          }
64          X->n = nblimbs;
65          X->p = p;
66      }
67      return( 0 );
68  }
69  int mpi_shrink( mpi *X, size_t nblimbs )
70  {
71      t_uint *p;
72      size_t i;
73      if( X->n <= nblimbs )
74          return( mpi_grow( X, nblimbs ) );
75      for( i = X->n - 1; i > 0; i-- )
76          if( X->p[i] != 0 )
77              break;
78      i++;
79      if( i < nblimbs )
80          i = nblimbs;
81      if( ( p = polarssl_malloc( i * ciL ) ) == NULL )
82          return( POLARSSL_ERR_MPI_MALLOC_FAILED );
83      memset( p, 0, i * ciL );
84      if( X->p != NULL )
85      {
86          memcpy( p, X->p, i * ciL );
87          polarssl_zeroize( X->p, X->n * ciL );
88          polarssl_free( X->p );
89      }
90      X->n = i;
91      X->p = p;
92      return( 0 );
93  }
94  int mpi_copy( mpi *X, const mpi *Y )
95  {
96      int ret;
97      size_t i;
98      if( X == Y )
99          return( 0 );
100      if( Y->p == NULL )
101      {
102          mpi_free( X );
103          return( 0 );
104      }
105      for( i = Y->n - 1; i > 0; i-- )
106          if( Y->p[i] != 0 )
107              break;
108      i++;
109      X->s = Y->s;
110      MPI_CHK( mpi_grow( X, i ) );
111      memset( X->p, 0, X->n * ciL );
112      memcpy( X->p, Y->p, i * ciL );
113  cleanup:
114      return( ret );
115  }
116  void mpi_swap( mpi *X, mpi *Y )
117  {
118      mpi T;
119      memcpy( &T,  X, sizeof( mpi ) );
120      memcpy(  X,  Y, sizeof( mpi ) );
121      memcpy(  Y, &T, sizeof( mpi ) );
122  }
123  int mpi_safe_cond_assign( mpi *X, const mpi *Y, unsigned char assign )
124  {
125      int ret = 0;
126      size_t i;
127      assign = (assign | (unsigned char)-assign) >> 7;
128      MPI_CHK( mpi_grow( X, Y->n ) );
129      X->s = X->s * ( 1 - assign ) + Y->s * assign;
130      for( i = 0; i < Y->n; i++ )
131          X->p[i] = X->p[i] * ( 1 - assign ) + Y->p[i] * assign;
132      for( ; i < X->n; i++ )
133          X->p[i] *= ( 1 - assign );
134  cleanup:
135      return( ret );
136  }
137  int mpi_safe_cond_swap( mpi *X, mpi *Y, unsigned char swap )
138  {
139      int ret, s;
140      size_t i;
141      t_uint tmp;
142      if( X == Y )
143          return( 0 );
144      swap = (swap | (unsigned char)-swap) >> 7;
145      MPI_CHK( mpi_grow( X, Y->n ) );
146      MPI_CHK( mpi_grow( Y, X->n ) );
147      s = X->s;
148      X->s = X->s * ( 1 - swap ) + Y->s * swap;
149      Y->s = Y->s * ( 1 - swap ) +    s * swap;
150      for( i = 0; i < X->n; i++ )
151      {
152          tmp = X->p[i];
153          X->p[i] = X->p[i] * ( 1 - swap ) + Y->p[i] * swap;
154          Y->p[i] = Y->p[i] * ( 1 - swap ) +     tmp * swap;
155      }
156  cleanup:
157      return( ret );
158  }
159  int mpi_lset( mpi *X, t_sint z )
160  {
161      int ret;
162      MPI_CHK( mpi_grow( X, 1 ) );
163      memset( X->p, 0, X->n * ciL );
164      X->p[0] = ( z < 0 ) ? -z : z;
165      X->s    = ( z < 0 ) ? -1 : 1;
166  cleanup:
167      return( ret );
168  }
169  int mpi_get_bit( const mpi *X, size_t pos )
170  {
171      if( X->n * biL <= pos )
172          return( 0 );
173      return( ( X->p[pos / biL] >> ( pos % biL ) ) & 0x01 );
174  }
175  int mpi_set_bit( mpi *X, size_t pos, unsigned char val )
176  {
177      int ret = 0;
178      size_t off = pos / biL;
179      size_t idx = pos % biL;
180      if( val != 0 && val != 1 )
181          return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );
182      if( X->n * biL <= pos )
183      {
184          if( val == 0 )
185              return( 0 );
186          MPI_CHK( mpi_grow( X, off + 1 ) );
187      }
188      X->p[off] &= ~( (t_uint) 0x01 << idx );
189      X->p[off] |= (t_uint) val << idx;
190  cleanup:
191      return( ret );
192  }
193  size_t mpi_lsb( const mpi *X )
194  {
195      size_t i, j, count = 0;
196      for( i = 0; i < X->n; i++ )
197          for( j = 0; j < biL; j++, count++ )
198              if( ( ( X->p[i] >> j ) & 1 ) != 0 )
199                  return( count );
200      return( 0 );
201  }
202  size_t mpi_msb( const mpi *X )
203  {
204      size_t i, j;
205      if( X->n == 0 )
206          return( 0 );
207      for( i = X->n - 1; i > 0; i-- )
208          if( X->p[i] != 0 )
209              break;
210      for( j = biL; j > 0; j-- )
211          if( ( ( X->p[i] >> ( j - 1 ) ) & 1 ) != 0 )
212              break;
213      return( ( i * biL ) + j );
214  }
215  size_t mpi_size( const mpi *X )
216  {
217      return( ( mpi_msb( X ) + 7 ) >> 3 );
218  }
219  #if 0
220  static int mpi_get_digit( t_uint *d, int radix, char c )
221  {
222      *d = 255;
223      if( c >= 0x30 && c <= 0x39 ) *d = c - 0x30;
224      if( c >= 0x41 && c <= 0x46 ) *d = c - 0x37;
225      if( c >= 0x61 && c <= 0x66 ) *d = c - 0x57;
226      if( *d >= (t_uint) radix )
227          return( POLARSSL_ERR_MPI_INVALID_CHARACTER );
228      return( 0 );
229  }
230  int mpi_read_string( mpi *X, int radix, const char *s )
231  {
232      int ret;
233      size_t i, j, slen, n;
234      t_uint d;
235      mpi T;
236      if( radix < 2 || radix > 16 )
237          return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );
238      mpi_init( &T );
239      slen = strlen( s );
240      if( radix == 16 )
241      {
242          n = BITS_TO_LIMBS( slen << 2 );
243          MPI_CHK( mpi_grow( X, n ) );
244          MPI_CHK( mpi_lset( X, 0 ) );
245          for( i = slen, j = 0; i > 0; i--, j++ )
246          {
247              if( i == 1 && s[i - 1] == '-' )
248              {
249                  X->s = -1;
250                  break;
251              }
252              MPI_CHK( mpi_get_digit( &d, radix, s[i - 1] ) );
253              X->p[j / ( 2 * ciL )] |= d << ( ( j % ( 2 * ciL ) ) << 2 );
254          }
255      }
256      else
257      {
258          MPI_CHK( mpi_lset( X, 0 ) );
259          for( i = 0; i < slen; i++ )
260          {
261              if( i == 0 && s[i] == '-' )
262              {
263                  X->s = -1;
264                  continue;
265              }
266              MPI_CHK( mpi_get_digit( &d, radix, s[i] ) );
267              MPI_CHK( mpi_mul_int( &T, X, radix ) );
268              if( X->s == 1 )
269              {
270                  MPI_CHK( mpi_add_int( X, &T, d ) );
271              }
272              else
273              {
274                  MPI_CHK( mpi_sub_int( X, &T, d ) );
275              }
276          }
277      }
278  cleanup:
279      mpi_free( &T );
280      return( ret );
281  }
282  static int mpi_write_hlp( mpi *X, int radix, char **p )
283  {
284      int ret;
285      t_uint r;
286      if( radix < 2 || radix > 16 )
287          return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );
288      MPI_CHK( mpi_mod_int( &r, X, radix ) );
289      MPI_CHK( mpi_div_int( X, NULL, X, radix ) );
290      if( mpi_cmp_int( X, 0 ) != 0 )
291          MPI_CHK( mpi_write_hlp( X, radix, p ) );
292      if( r < 10 )
293          *(*p)++ = (char)( r + 0x30 );
294      else
295          *(*p)++ = (char)( r + 0x37 );
296  cleanup:
297      return( ret );
298  }
299  int mpi_write_string( const mpi *X, int radix, char *s, size_t *slen )
300  {
301      int ret = 0;
302      size_t n;
303      char *p;
304      mpi T;
305      if( radix < 2 || radix > 16 )
306          return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );
307      n = mpi_msb( X );
308      if( radix >=  4 ) n >>= 1;
309      if( radix >= 16 ) n >>= 1;
310      n += 3;
311      if( *slen < n )
312      {
313          *slen = n;
314          return( POLARSSL_ERR_MPI_BUFFER_TOO_SMALL );
315      }
316      p = s;
317      mpi_init( &T );
318      if( X->s == -1 )
319          *p++ = '-';
320      if( radix == 16 )
321      {
322          int c;
323          size_t i, j, k;
324          for( i = X->n, k = 0; i > 0; i-- )
325          {
326              for( j = ciL; j > 0; j-- )
327              {
328                  c = ( X->p[i - 1] >> ( ( j - 1 ) << 3) ) & 0xFF;
329                  if( c == 0 && k == 0 && ( i + j ) != 2 )
330                      continue;
331                  *(p++) = "0123456789ABCDEF" [c / 16];
332                  *(p++) = "0123456789ABCDEF" [c % 16];
333                  k = 1;
334              }
335          }
336      }
337      else
338      {
339          MPI_CHK( mpi_copy( &T, X ) );
340          if( T.s == -1 )
341              T.s = 1;
342          MPI_CHK( mpi_write_hlp( &T, radix, &p ) );
343      }
344      *p++ = '\0';
345      *slen = p - s;
346  cleanup:
347      mpi_free( &T );
348      return( ret );
349  }
350  #endif
351  #if defined(POLARSSL_FS_IO)
352  int mpi_read_file( mpi *X, int radix, FILE *fin )
353  {
354      t_uint d;
355      size_t slen;
356      char *p;
357      char s[ POLARSSL_MPI_RW_BUFFER_SIZE ];
358      memset( s, 0, sizeof( s ) );
359      if( fgets( s, sizeof( s ) - 1, fin ) == NULL )
360          return( POLARSSL_ERR_MPI_FILE_IO_ERROR );
361      slen = strlen( s );
362      if( slen == sizeof( s ) - 2 )
363          return( POLARSSL_ERR_MPI_BUFFER_TOO_SMALL );
364      if( s[slen - 1] == '\n' ) { slen--; s[slen] = '\0'; }
365      if( s[slen - 1] == '\r' ) { slen--; s[slen] = '\0'; }
366      p = s + slen;
367      while( --p >= s )
368          if( mpi_get_digit( &d, radix, *p ) != 0 )
369              break;
370      return( mpi_read_string( X, radix, p + 1 ) );
371  }
372  int mpi_write_file( const char *p, const mpi *X, int radix, FILE *fout )
373  {
374      int ret;
375      size_t n, slen, plen;
376      char s[ POLARSSL_MPI_RW_BUFFER_SIZE ];
377      n = sizeof( s );
378      memset( s, 0, n );
379      n -= 2;
380      MPI_CHK( mpi_write_string( X, radix, s, (size_t *) &n ) );
381      if( p == NULL ) p = "";
382      plen = strlen( p );
383      slen = strlen( s );
384      s[slen++] = '\r';
385      s[slen++] = '\n';
386      if( fout != NULL )
387      {
388          if( fwrite( p, 1, plen, fout ) != plen ||
389              fwrite( s, 1, slen, fout ) != slen )
390              return( POLARSSL_ERR_MPI_FILE_IO_ERROR );
391      }
392      else
393          polarssl_printf( "%s%s", p, s );
394  cleanup:
395      return( ret );
396  }
397  #endif &bsol;* POLARSSL_FS_IO */
398  int mpi_read_binary( mpi *X, const unsigned char *buf, size_t buflen )
399  {
400      int ret;
401      size_t i, j, n;
402      for( n = 0; n < buflen; n++ )
403          if( buf[n] != 0 )
404              break;
405      MPI_CHK( mpi_grow( X, CHARS_TO_LIMBS( buflen - n ) ) );
406      MPI_CHK( mpi_lset( X, 0 ) );
407      for( i = buflen, j = 0; i > n; i--, j++ )
408          X->p[j / ciL] |= ((t_uint) buf[i - 1]) << ((j % ciL) << 3);
409  cleanup:
410      return( ret );
411  }
412  int mpi_write_binary( const mpi *X, unsigned char *buf, size_t buflen )
413  {
414      size_t i, j, n;
415      n = mpi_size( X );
416      if( buflen < n )
417          return( POLARSSL_ERR_MPI_BUFFER_TOO_SMALL );
418      memset( buf, 0, buflen );
419      for( i = buflen - 1, j = 0; n > 0; i--, j++, n-- )
420          buf[i] = (unsigned char)( X->p[j / ciL] >> ((j % ciL) << 3) );
421      return( 0 );
422  }
423  int mpi_shift_l( mpi *X, size_t count )
424  {
425      int ret;
426      size_t i, v0, t1;
427      t_uint r0 = 0, r1;
428      v0 = count / (biL    );
429      t1 = count & (biL - 1);
430      i = mpi_msb( X ) + count;
431      if( X->n * biL < i )
432          MPI_CHK( mpi_grow( X, BITS_TO_LIMBS( i ) ) );
433      ret = 0;
434      if( v0 > 0 )
435      {
436          for( i = X->n; i > v0; i-- )
437              X->p[i - 1] = X->p[i - v0 - 1];
438          for( ; i > 0; i-- )
439              X->p[i - 1] = 0;
440      }
441      if( t1 > 0 )
442      {
443          for( i = v0; i < X->n; i++ )
444          {
445              r1 = X->p[i] >> (biL - t1);
446              X->p[i] <<= t1;
447              X->p[i] |= r0;
448              r0 = r1;
449          }
450      }
451  cleanup:
452      return( ret );
453  }
454  int mpi_shift_r( mpi *X, size_t count )
455  {
456      size_t i, v0, v1;
457      t_uint r0 = 0, r1;
458      v0 = count /  biL;
459      v1 = count & (biL - 1);
460      if( v0 > X->n || ( v0 == X->n && v1 > 0 ) )
461          return mpi_lset( X, 0 );
462      if( v0 > 0 )
463      {
464          for( i = 0; i < X->n - v0; i++ )
465              X->p[i] = X->p[i + v0];
466          for( ; i < X->n; i++ )
467              X->p[i] = 0;
468      }
469      if( v1 > 0 )
470      {
471          for( i = X->n; i > 0; i-- )
472          {
473              r1 = X->p[i - 1] << (biL - v1);
474              X->p[i - 1] >>= v1;
475              X->p[i - 1] |= r0;
476              r0 = r1;
477          }
478      }
479      return( 0 );
480  }
481  int mpi_cmp_abs( const mpi *X, const mpi *Y )
482  {
483      size_t i, j;
484      for( i = X->n; i > 0; i-- )
485          if( X->p[i - 1] != 0 )
486              break;
487      for( j = Y->n; j > 0; j-- )
488          if( Y->p[j - 1] != 0 )
489              break;
490      if( i == 0 && j == 0 )
491          return( 0 );
492      if( i > j ) return(  1 );
493      if( j > i ) return( -1 );
494      for( ; i > 0; i-- )
495      {
496          if( X->p[i - 1] > Y->p[i - 1] ) return(  1 );
497          if( X->p[i - 1] < Y->p[i - 1] ) return( -1 );
498      }
499      return( 0 );
500  }
501  int mpi_cmp_mpi( const mpi *X, const mpi *Y )
502  {
503      size_t i, j;
504      for( i = X->n; i > 0; i-- )
505          if( X->p[i - 1] != 0 )
506              break;
507      for( j = Y->n; j > 0; j-- )
508          if( Y->p[j - 1] != 0 )
509              break;
510      if( i == 0 && j == 0 )
511          return( 0 );
512      if( i > j ) return(  X->s );
513      if( j > i ) return( -Y->s );
514      if( X->s > 0 && Y->s < 0 ) return(  1 );
515      if( Y->s > 0 && X->s < 0 ) return( -1 );
516      for( ; i > 0; i-- )
517      {
518          if( X->p[i - 1] > Y->p[i - 1] ) return(  X->s );
519          if( X->p[i - 1] < Y->p[i - 1] ) return( -X->s );
520      }
521      return( 0 );
522  }
523  int mpi_cmp_int( const mpi *X, t_sint z )
524  {
525      mpi Y;
526      t_uint p[1];
527      *p  = ( z < 0 ) ? -z : z;
528      Y.s = ( z < 0 ) ? -1 : 1;
529      Y.n = 1;
530      Y.p = p;
531      return( mpi_cmp_mpi( X, &Y ) );
532  }
533  int mpi_add_abs( mpi *X, const mpi *A, const mpi *B )
534  {
535      int ret;
536      size_t i, j;
537      t_uint *o, *p, c;
538      if( X == B )
539      {
540          const mpi *T = A; A = X; B = T;
541      }
542      if( X != A )
543          MPI_CHK( mpi_copy( X, A ) );
544      X->s = 1;
545      for( j = B->n; j > 0; j-- )
546          if( B->p[j - 1] != 0 )
547              break;
548      MPI_CHK( mpi_grow( X, j ) );
549      o = B->p; p = X->p; c = 0;
550      for( i = 0; i < j; i++, o++, p++ )
551      {
552          *p +=  c; c  = ( *p <  c );
553          *p += *o; c += ( *p < *o );
554      }
555      while( c != 0 )
556      {
557          if( i >= X->n )
558          {
559              MPI_CHK( mpi_grow( X, i + 1 ) );
560              p = X->p + i;
561          }
562          *p += c; c = ( *p < c ); i++; p++;
563      }
564  cleanup:
565      return( ret );
566  }
567  static void mpi_sub_hlp( size_t n, t_uint *s, t_uint *d )
568  {
569      size_t i;
570      t_uint c, z;
571      for( i = c = 0; i < n; i++, s++, d++ )
572      {
573          z = ( *d <  c );     *d -=  c;
574          c = ( *d < *s ) + z; *d -= *s;
575      }
576      while( c != 0 )
577      {
578          z = ( *d < c ); *d -= c;
579          c = z; i++; d++;
580      }
581  }
582  int mpi_sub_abs( mpi *X, const mpi *A, const mpi *B )
583  {
584      mpi TB;
585      int ret;
586      size_t n;
587      if( mpi_cmp_abs( A, B ) < 0 )
588          return( POLARSSL_ERR_MPI_NEGATIVE_VALUE );
589      mpi_init( &TB );
590      if( X == B )
591      {
592          MPI_CHK( mpi_copy( &TB, B ) );
593          B = &TB;
594      }
595      if( X != A )
596          MPI_CHK( mpi_copy( X, A ) );
597      X->s = 1;
598      ret = 0;
599      for( n = B->n; n > 0; n-- )
600          if( B->p[n - 1] != 0 )
601              break;
602      mpi_sub_hlp( n, B->p, X->p );
603  cleanup:
604      mpi_free( &TB );
605      return( ret );
606  }
607  int mpi_add_mpi( mpi *X, const mpi *A, const mpi *B )
608  {
609      int ret, s = A->s;
610      if( A->s * B->s < 0 )
611      {
612          if( mpi_cmp_abs( A, B ) >= 0 )
613          {
614              MPI_CHK( mpi_sub_abs( X, A, B ) );
615              X->s =  s;
616          }
617          else
618          {
619              MPI_CHK( mpi_sub_abs( X, B, A ) );
620              X->s = -s;
621          }
622      }
623      else
624      {
625          MPI_CHK( mpi_add_abs( X, A, B ) );
626          X->s = s;
627      }
628  cleanup:
629      return( ret );
630  }
631  int mpi_sub_mpi( mpi *X, const mpi *A, const mpi *B )
632  {
633      int ret, s = A->s;
634      if( A->s * B->s > 0 )
635      {
636          if( mpi_cmp_abs( A, B ) >= 0 )
637          {
638              MPI_CHK( mpi_sub_abs( X, A, B ) );
639              X->s =  s;
640          }
641          else
642          {
643              MPI_CHK( mpi_sub_abs( X, B, A ) );
644              X->s = -s;
645          }
646      }
647      else
648      {
649          MPI_CHK( mpi_add_abs( X, A, B ) );
650          X->s = s;
651      }
652  cleanup:
653      return( ret );
654  }
655  #if 0
656  int mpi_add_int( mpi *X, const mpi *A, t_sint b )
657  {
658      mpi _B;
659      t_uint p[1];
660      p[0] = ( b < 0 ) ? -b : b;
661      _B.s = ( b < 0 ) ? -1 : 1;
662      _B.n = 1;
663      _B.p = p;
664      return( mpi_add_mpi( X, A, &_B ) );
665  }
666  int mpi_sub_int( mpi *X, const mpi *A, t_sint b )
667  {
668      mpi _B;
669      t_uint p[1];
670      p[0] = ( b < 0 ) ? -b : b;
671      _B.s = ( b < 0 ) ? -1 : 1;
672      _B.n = 1;
673      _B.p = p;
674      return( mpi_sub_mpi( X, A, &_B ) );
675  }
676  #endif
677  static
678  #if defined(__APPLE__) && defined(__arm__)
679  __attribute__ ((noinline))
680  #endif
681  void mpi_mul_hlp( size_t i, t_uint *s, t_uint *d, t_uint b )
682  {
683      t_uint c = 0, t = 0;
684  #if defined(MULADDC_HUIT)
685      for( ; i >= 8; i -= 8 )
686      {
687          MULADDC_INIT
688          MULADDC_HUIT
689          MULADDC_STOP
690      }
691      for( ; i > 0; i-- )
692      {
693          MULADDC_INIT
694          MULADDC_CORE
695          MULADDC_STOP
696      }
697  #else &bsol;* MULADDC_HUIT */
698      for( ; i >= 16; i -= 16 )
699      {
700          MULADDC_INIT
701          MULADDC_CORE   MULADDC_CORE
702          MULADDC_CORE   MULADDC_CORE
703          MULADDC_CORE   MULADDC_CORE
704          MULADDC_CORE   MULADDC_CORE
705          MULADDC_CORE   MULADDC_CORE
706          MULADDC_CORE   MULADDC_CORE
707          MULADDC_CORE   MULADDC_CORE
708          MULADDC_CORE   MULADDC_CORE
709          MULADDC_STOP
710      }
711      for( ; i >= 8; i -= 8 )
712      {
713          MULADDC_INIT
714          MULADDC_CORE   MULADDC_CORE
715          MULADDC_CORE   MULADDC_CORE
716          MULADDC_CORE   MULADDC_CORE
717          MULADDC_CORE   MULADDC_CORE
718          MULADDC_STOP
719      }
720      for( ; i > 0; i-- )
721      {
722          MULADDC_INIT
723          MULADDC_CORE
724          MULADDC_STOP
725      }
726  #endif &bsol;* MULADDC_HUIT */
727      t++;
728      do {
729          *d += c; c = ( *d < c ); d++;
730      }
731      while( c != 0 );
732  }
733  int mpi_mul_mpi( mpi *X, const mpi *A, const mpi *B )
734  {
735      int ret;
736      size_t i, j;
737      mpi TA, TB;
738      mpi_init( &TA ); mpi_init( &TB );
739      if( X == A ) { MPI_CHK( mpi_copy( &TA, A ) ); A = &TA; }
740      if( X == B ) { MPI_CHK( mpi_copy( &TB, B ) ); B = &TB; }
741      for( i = A->n; i > 0; i-- )
742          if( A->p[i - 1] != 0 )
743              break;
744      for( j = B->n; j > 0; j-- )
745          if( B->p[j - 1] != 0 )
746              break;
747      MPI_CHK( mpi_grow( X, i + j ) );
748      MPI_CHK( mpi_lset( X, 0 ) );
749      for( i++; j > 0; j-- )
750          mpi_mul_hlp( i - 1, A->p, X->p + j - 1, B->p[j - 1] );
751      X->s = A->s * B->s;
752  cleanup:
753      mpi_free( &TB ); mpi_free( &TA );
754      return( ret );
755  }
756  int mpi_mul_int( mpi *X, const mpi *A, t_sint b )
757  {
758      mpi _B;
759      t_uint p[1];
760      _B.s = 1;
761      _B.n = 1;
762      _B.p = p;
763      p[0] = b;
764      return( mpi_mul_mpi( X, A, &_B ) );
765  }
766  int mpi_div_mpi( mpi *Q, mpi *R, const mpi *A, const mpi *B )
767  {
768      int ret;
769      size_t i, n, t, k;
770      mpi X, Y, Z, T1, T2;
771      if( mpi_cmp_int( B, 0 ) == 0 )
772          return( POLARSSL_ERR_MPI_DIVISION_BY_ZERO );
773      mpi_init( &X ); mpi_init( &Y ); mpi_init( &Z );
774      mpi_init( &T1 ); mpi_init( &T2 );
775      if( mpi_cmp_abs( A, B ) < 0 )
776      {
777          if( Q != NULL ) MPI_CHK( mpi_lset( Q, 0 ) );
778          if( R != NULL ) MPI_CHK( mpi_copy( R, A ) );
779          return( 0 );
780      }
781      MPI_CHK( mpi_copy( &X, A ) );
782      MPI_CHK( mpi_copy( &Y, B ) );
783      X.s = Y.s = 1;
784      MPI_CHK( mpi_grow( &Z, A->n + 2 ) );
785      MPI_CHK( mpi_lset( &Z,  0 ) );
786      MPI_CHK( mpi_grow( &T1, 2 ) );
787      MPI_CHK( mpi_grow( &T2, 3 ) );
788      k = mpi_msb( &Y ) % biL;
789      if( k < biL - 1 )
790      {
791          k = biL - 1 - k;
792          MPI_CHK( mpi_shift_l( &X, k ) );
793          MPI_CHK( mpi_shift_l( &Y, k ) );
794      }
795      else k = 0;
796      n = X.n - 1;
797      t = Y.n - 1;
798      MPI_CHK( mpi_shift_l( &Y, biL * ( n - t ) ) );
799      while( mpi_cmp_mpi( &X, &Y ) >= 0 )
800      {
801          Z.p[n - t]++;
802          MPI_CHK( mpi_sub_mpi( &X, &X, &Y ) );
803      }
804      MPI_CHK( mpi_shift_r( &Y, biL * ( n - t ) ) );
805      for( i = n; i > t ; i-- )
806      {
807          if( X.p[i] >= Y.p[t] )
808              Z.p[i - t - 1] = ~0;
809          else
810          {
811  #if defined(POLARSSL_HAVE_UDBL)
812              t_udbl r;
813              r  = (t_udbl) X.p[i] << biL;
814              r |= (t_udbl) X.p[i - 1];
815              r /= Y.p[t];
816              if( r > ( (t_udbl) 1 << biL ) - 1 )
817                  r = ( (t_udbl) 1 << biL ) - 1;
818              Z.p[i - t - 1] = (t_uint) r;
819  #else
820              t_uint q0, q1, r0, r1;
821              t_uint d0, d1, d, m;
822              d  = Y.p[t];
823              d0 = ( d << biH ) >> biH;
824              d1 = ( d >> biH );
825              q1 = X.p[i] / d1;
826              r1 = X.p[i] - d1 * q1;
827              r1 <<= biH;
828              r1 |= ( X.p[i - 1] >> biH );
829              m = q1 * d0;
830              if( r1 < m )
831              {
832                  q1--, r1 += d;
833                  while( r1 >= d && r1 < m )
834                      q1--, r1 += d;
835              }
836              r1 -= m;
837              q0 = r1 / d1;
838              r0 = r1 - d1 * q0;
839              r0 <<= biH;
840              r0 |= ( X.p[i - 1] << biH ) >> biH;
841              m = q0 * d0;
842              if( r0 < m )
843              {
844                  q0--, r0 += d;
845                  while( r0 >= d && r0 < m )
846                      q0--, r0 += d;
847              }
848              r0 -= m;
849              Z.p[i - t - 1] = ( q1 << biH ) | q0;
850  #endif &bsol;* POLARSSL_HAVE_UDBL && !64-bit Apple with Clang 5.0 */
851          }
852          Z.p[i - t - 1]++;
853          do
854          {
855              Z.p[i - t - 1]--;
856              MPI_CHK( mpi_lset( &T1, 0 ) );
857              T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
858              T1.p[1] = Y.p[t];
859              MPI_CHK( mpi_mul_int( &T1, &T1, Z.p[i - t - 1] ) );
860              MPI_CHK( mpi_lset( &T2, 0 ) );
861              T2.p[0] = ( i < 2 ) ? 0 : X.p[i - 2];
862              T2.p[1] = ( i < 1 ) ? 0 : X.p[i - 1];
863              T2.p[2] = X.p[i];
864          }
865          while( mpi_cmp_mpi( &T1, &T2 ) > 0 );
866          MPI_CHK( mpi_mul_int( &T1, &Y, Z.p[i - t - 1] ) );
867          MPI_CHK( mpi_shift_l( &T1,  biL * ( i - t - 1 ) ) );
868          MPI_CHK( mpi_sub_mpi( &X, &X, &T1 ) );
869          if( mpi_cmp_int( &X, 0 ) < 0 )
870          {
871              MPI_CHK( mpi_copy( &T1, &Y ) );
872              MPI_CHK( mpi_shift_l( &T1, biL * ( i - t - 1 ) ) );
873              MPI_CHK( mpi_add_mpi( &X, &X, &T1 ) );
874              Z.p[i - t - 1]--;
875          }
876      }
877      if( Q != NULL )
878      {
879          MPI_CHK( mpi_copy( Q, &Z ) );
880          Q->s = A->s * B->s;
881      }
882      if( R != NULL )
883      {
884          MPI_CHK( mpi_shift_r( &X, k ) );
885          X.s = A->s;
886          MPI_CHK( mpi_copy( R, &X ) );
887          if( mpi_cmp_int( R, 0 ) == 0 )
888              R->s = 1;
889      }
890  cleanup:
891      mpi_free( &X ); mpi_free( &Y ); mpi_free( &Z );
892      mpi_free( &T1 ); mpi_free( &T2 );
893      return( ret );
894  }
895  #if 0
896  int mpi_div_int( mpi *Q, mpi *R, const mpi *A, t_sint b )
897  {
898      mpi _B;
899      t_uint p[1];
900      p[0] = ( b < 0 ) ? -b : b;
901      _B.s = ( b < 0 ) ? -1 : 1;
902      _B.n = 1;
903      _B.p = p;
904      return( mpi_div_mpi( Q, R, A, &_B ) );
905  }
906  #endif
907  int mpi_mod_mpi( mpi *R, const mpi *A, const mpi *B )
908  {
909      int ret;
910      if( mpi_cmp_int( B, 0 ) < 0 )
911          return( POLARSSL_ERR_MPI_NEGATIVE_VALUE );
912      MPI_CHK( mpi_div_mpi( NULL, R, A, B ) );
913      while( mpi_cmp_int( R, 0 ) < 0 )
914        MPI_CHK( mpi_add_mpi( R, R, B ) );
915      while( mpi_cmp_mpi( R, B ) >= 0 )
916        MPI_CHK( mpi_sub_mpi( R, R, B ) );
917  cleanup:
918      return( ret );
919  }
920  #if 0
921  int mpi_mod_int( t_uint *r, const mpi *A, t_sint b )
922  {
923      size_t i;
924      t_uint x, y, z;
925      if( b == 0 )
926          return( POLARSSL_ERR_MPI_DIVISION_BY_ZERO );
927      if( b < 0 )
928          return( POLARSSL_ERR_MPI_NEGATIVE_VALUE );
929      if( b == 1 )
930      {
931          *r = 0;
932          return( 0 );
933      }
934      if( b == 2 )
935      {
936          *r = A->p[0] & 1;
937          return( 0 );
938      }
939      for( i = A->n, y = 0; i > 0; i-- )
940      {
941          x  = A->p[i - 1];
942          y  = ( y << biH ) | ( x >> biH );
943          z  = y / b;
944          y -= z * b;
945          x <<= biH;
946          y  = ( y << biH ) | ( x >> biH );
947          z  = y / b;
948          y -= z * b;
949      }
950      if( A->s < 0 && y != 0 )
951          y = b - y;
952      *r = y;
953      return( 0 );
954  }
955  #endif
956  static void mpi_montg_init( t_uint *mm, const mpi *N )
957  {
958      t_uint x, m0 = N->p[0];
959      unsigned int i;
960      x  = m0;
961      x += ( ( m0 + 2 ) & 4 ) << 1;
962      for( i = biL; i >= 8; i /= 2 )
963          x *= ( 2 - ( m0 * x ) );
964      *mm = ~x + 1;
965  }
966  static void mpi_montmul( mpi *A, const mpi *B, const mpi *N, t_uint mm,
967                           const mpi *T )
968  {
969      size_t i, n, m;
970      t_uint u0, u1, *d;
971      memset( T->p, 0, T->n * ciL );
972      d = T->p;
973      n = N->n;
974      m = ( B->n < n ) ? B->n : n;
975      for( i = 0; i < n; i++ )
976      {
977          u0 = A->p[i];
978          u1 = ( d[0] + u0 * B->p[0] ) * mm;
979          mpi_mul_hlp( m, B->p, d, u0 );
980          mpi_mul_hlp( n, N->p, d, u1 );
981          *d++ = u0; d[n + 1] = 0;
982      }
983      memcpy( A->p, d, ( n + 1 ) * ciL );
984      if( mpi_cmp_abs( A, N ) >= 0 )
985          mpi_sub_hlp( n, N->p, A->p );
986      else
987          mpi_sub_hlp( n, A->p, T->p );
988  }
989  static void mpi_montred( mpi *A, const mpi *N, t_uint mm, const mpi *T )
990  {
991      t_uint z = 1;
992      mpi U;
993      U.n = U.s = (int) z;
994      U.p = &z;
995      mpi_montmul( A, &U, N, mm, T );
996  }
997  int mpi_exp_mod( mpi *X, const mpi *A, const mpi *E, const mpi *N, mpi *_RR )
998  {
999      int ret;
1000      size_t wbits, wsize, one = 1;
1001      size_t i, j, nblimbs;
1002      size_t bufsize, nbits;
1003      t_uint ei, mm, state;
1004      mpi RR, T, W[ 2 << POLARSSL_MPI_WINDOW_SIZE ], Apos;
1005      int neg;
1006      if( mpi_cmp_int( N, 0 ) < 0 || ( N->p[0] & 1 ) == 0 )
1007          return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );
1008      if( mpi_cmp_int( E, 0 ) < 0 )
1009          return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );
1010      mpi_montg_init( &mm, N );
1011      mpi_init( &RR ); mpi_init( &T );
1012      mpi_init( &Apos );
1013      memset( W, 0, sizeof( W ) );
1014      i = mpi_msb( E );
1015      wsize = ( i > 671 ) ? 6 : ( i > 239 ) ? 5 :
1016              ( i >  79 ) ? 4 : ( i >  23 ) ? 3 : 1;
1017      if( wsize > POLARSSL_MPI_WINDOW_SIZE )
1018          wsize = POLARSSL_MPI_WINDOW_SIZE;
1019      j = N->n + 1;
1020      MPI_CHK( mpi_grow( X, j ) );
1021      MPI_CHK( mpi_grow( &W[1],  j ) );
1022      MPI_CHK( mpi_grow( &T, j * 2 ) );
1023      neg = ( A->s == -1 );
1024      if( neg )
1025      {
1026          MPI_CHK( mpi_copy( &Apos, A ) );
1027          Apos.s = 1;
1028          A = &Apos;
1029      }
1030      if( _RR == NULL || _RR->p == NULL )
1031      {
1032          MPI_CHK( mpi_lset( &RR, 1 ) );
1033          MPI_CHK( mpi_shift_l( &RR, N->n * 2 * biL ) );
1034          MPI_CHK( mpi_mod_mpi( &RR, &RR, N ) );
1035          if( _RR != NULL )
1036              memcpy( _RR, &RR, sizeof( mpi ) );
1037      }
1038      else
1039          memcpy( &RR, _RR, sizeof( mpi ) );
1040      if( mpi_cmp_mpi( A, N ) >= 0 )
1041          MPI_CHK( mpi_mod_mpi( &W[1], A, N ) );
1042      else
1043          MPI_CHK( mpi_copy( &W[1], A ) );
1044      mpi_montmul( &W[1], &RR, N, mm, &T );
1045      MPI_CHK( mpi_copy( X, &RR ) );
1046      mpi_montred( X, N, mm, &T );
1047      if( wsize > 1 )
1048      {
1049          j =  one << ( wsize - 1 );
1050          MPI_CHK( mpi_grow( &W[j], N->n + 1 ) );
1051          MPI_CHK( mpi_copy( &W[j], &W[1]    ) );
1052          for( i = 0; i < wsize - 1; i++ )
1053              mpi_montmul( &W[j], &W[j], N, mm, &T );
1054          for( i = j + 1; i < ( one << wsize ); i++ )
1055          {
1056              MPI_CHK( mpi_grow( &W[i], N->n + 1 ) );
1057              MPI_CHK( mpi_copy( &W[i], &W[i - 1] ) );
1058              mpi_montmul( &W[i], &W[1], N, mm, &T );
1059          }
1060      }
1061      nblimbs = E->n;
1062      bufsize = 0;
1063      nbits   = 0;
1064      wbits   = 0;
1065      state   = 0;
1066      while( 1 )
1067      {
1068          if( bufsize == 0 )
1069          {
1070              if( nblimbs == 0 )
1071                  break;
1072              nblimbs--;
1073              bufsize = sizeof( t_uint ) << 3;
1074          }
1075          bufsize--;
1076          ei = (E->p[nblimbs] >> bufsize) & 1;
1077          if( ei == 0 && state == 0 )
1078              continue;
1079          if( ei == 0 && state == 1 )
1080          {
1081              mpi_montmul( X, X, N, mm, &T );
1082              continue;
1083          }
1084          state = 2;
1085          nbits++;
1086          wbits |= ( ei << ( wsize - nbits ) );
1087          if( nbits == wsize )
1088          {
1089              for( i = 0; i < wsize; i++ )
1090                  mpi_montmul( X, X, N, mm, &T );
1091              mpi_montmul( X, &W[wbits], N, mm, &T );
1092              state--;
1093              nbits = 0;
1094              wbits = 0;
1095          }
1096      }
1097      for( i = 0; i < nbits; i++ )
1098      {
1099          mpi_montmul( X, X, N, mm, &T );
1100          wbits <<= 1;
1101          if( ( wbits & ( one << wsize ) ) != 0 )
1102              mpi_montmul( X, &W[1], N, mm, &T );
1103      }
1104      mpi_montred( X, N, mm, &T );
1105      if( neg )
1106      {
1107          X->s = -1;
1108          MPI_CHK( mpi_add_mpi( X, N, X ) );
1109      }
1110  cleanup:
1111      for( i = ( one << ( wsize - 1 ) ); i < ( one << wsize ); i++ )
1112          mpi_free( &W[i] );
1113      mpi_free( &W[1] ); mpi_free( &T ); mpi_free( &Apos );
1114      if( _RR == NULL || _RR->p == NULL )
1115          mpi_free( &RR );
1116      return( ret );
1117  }
1118  #if 0
1119  int mpi_gcd( mpi *G, const mpi *A, const mpi *B )
1120  {
1121      int ret;
1122      size_t lz, lzt;
1123      mpi TG, TA, TB;
1124      mpi_init( &TG ); mpi_init( &TA ); mpi_init( &TB );
1125      MPI_CHK( mpi_copy( &TA, A ) );
1126      MPI_CHK( mpi_copy( &TB, B ) );
1127      lz = mpi_lsb( &TA );
1128      lzt = mpi_lsb( &TB );
1129      if( lzt < lz )
1130          lz = lzt;
1131      MPI_CHK( mpi_shift_r( &TA, lz ) );
1132      MPI_CHK( mpi_shift_r( &TB, lz ) );
1133      TA.s = TB.s = 1;
1134      while( mpi_cmp_int( &TA, 0 ) != 0 )
1135      {
1136          MPI_CHK( mpi_shift_r( &TA, mpi_lsb( &TA ) ) );
1137          MPI_CHK( mpi_shift_r( &TB, mpi_lsb( &TB ) ) );
1138          if( mpi_cmp_mpi( &TA, &TB ) >= 0 )
1139          {
1140              MPI_CHK( mpi_sub_abs( &TA, &TA, &TB ) );
1141              MPI_CHK( mpi_shift_r( &TA, 1 ) );
1142          }
1143          else
1144          {
1145              MPI_CHK( mpi_sub_abs( &TB, &TB, &TA ) );
1146              MPI_CHK( mpi_shift_r( &TB, 1 ) );
1147          }
1148      }
1149      MPI_CHK( mpi_shift_l( &TB, lz ) );
1150      MPI_CHK( mpi_copy( G, &TB ) );
1151  cleanup:
1152      mpi_free( &TG ); mpi_free( &TA ); mpi_free( &TB );
1153      return( ret );
1154  }
1155  int mpi_fill_random( mpi *X, size_t size,
1156                       int (*f_rng)(void *, unsigned char *, size_t),
1157                       void *p_rng )
1158  {
1159      int ret;
1160      unsigned char buf[POLARSSL_MPI_MAX_SIZE];
1161      if( size > POLARSSL_MPI_MAX_SIZE )
1162          return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );
1163      MPI_CHK( f_rng( p_rng, buf, size ) );
1164      MPI_CHK( mpi_read_binary( X, buf, size ) );
1165  cleanup:
1166      return( ret );
1167  }
1168  int mpi_inv_mod( mpi *X, const mpi *A, const mpi *N )
1169  {
1170      int ret;
1171      mpi G, TA, TU, U1, U2, TB, TV, V1, V2;
1172      if( mpi_cmp_int( N, 0 ) <= 0 )
1173          return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );
1174      mpi_init( &TA ); mpi_init( &TU ); mpi_init( &U1 ); mpi_init( &U2 );
1175      mpi_init( &G ); mpi_init( &TB ); mpi_init( &TV );
1176      mpi_init( &V1 ); mpi_init( &V2 );
1177      MPI_CHK( mpi_gcd( &G, A, N ) );
1178      if( mpi_cmp_int( &G, 1 ) != 0 )
1179      {
1180          ret = POLARSSL_ERR_MPI_NOT_ACCEPTABLE;
1181          goto cleanup;
1182      }
1183      MPI_CHK( mpi_mod_mpi( &TA, A, N ) );
1184      MPI_CHK( mpi_copy( &TU, &TA ) );
1185      MPI_CHK( mpi_copy( &TB, N ) );
1186      MPI_CHK( mpi_copy( &TV, N ) );
1187      MPI_CHK( mpi_lset( &U1, 1 ) );
1188      MPI_CHK( mpi_lset( &U2, 0 ) );
1189      MPI_CHK( mpi_lset( &V1, 0 ) );
1190      MPI_CHK( mpi_lset( &V2, 1 ) );
1191      do
1192      {
1193          while( ( TU.p[0] & 1 ) == 0 )
1194          {
1195              MPI_CHK( mpi_shift_r( &TU, 1 ) );
1196              if( ( U1.p[0] & 1 ) != 0 || ( U2.p[0] & 1 ) != 0 )
1197              {
1198                  MPI_CHK( mpi_add_mpi( &U1, &U1, &TB ) );
1199                  MPI_CHK( mpi_sub_mpi( &U2, &U2, &TA ) );
1200              }
1201              MPI_CHK( mpi_shift_r( &U1, 1 ) );
1202              MPI_CHK( mpi_shift_r( &U2, 1 ) );
1203          }
1204          while( ( TV.p[0] & 1 ) == 0 )
1205          {
1206              MPI_CHK( mpi_shift_r( &TV, 1 ) );
1207              if( ( V1.p[0] & 1 ) != 0 || ( V2.p[0] & 1 ) != 0 )
1208              {
1209                  MPI_CHK( mpi_add_mpi( &V1, &V1, &TB ) );
1210                  MPI_CHK( mpi_sub_mpi( &V2, &V2, &TA ) );
1211              }
1212              MPI_CHK( mpi_shift_r( &V1, 1 ) );
1213              MPI_CHK( mpi_shift_r( &V2, 1 ) );
1214          }
1215          if( mpi_cmp_mpi( &TU, &TV ) >= 0 )
1216          {
1217              MPI_CHK( mpi_sub_mpi( &TU, &TU, &TV ) );
1218              MPI_CHK( mpi_sub_mpi( &U1, &U1, &V1 ) );
1219              MPI_CHK( mpi_sub_mpi( &U2, &U2, &V2 ) );
1220          }
1221          else
1222          {
1223              MPI_CHK( mpi_sub_mpi( &TV, &TV, &TU ) );
1224              MPI_CHK( mpi_sub_mpi( &V1, &V1, &U1 ) );
1225              MPI_CHK( mpi_sub_mpi( &V2, &V2, &U2 ) );
1226          }
1227      }
1228      while( mpi_cmp_int( &TU, 0 ) != 0 );
1229      while( mpi_cmp_int( &V1, 0 ) < 0 )
1230          MPI_CHK( mpi_add_mpi( &V1, &V1, N ) );
1231      while( mpi_cmp_mpi( &V1, N ) >= 0 )
1232          MPI_CHK( mpi_sub_mpi( &V1, &V1, N ) );
1233      MPI_CHK( mpi_copy( X, &V1 ) );
1234  cleanup:
1235      mpi_free( &TA ); mpi_free( &TU ); mpi_free( &U1 ); mpi_free( &U2 );
1236      mpi_free( &G ); mpi_free( &TB ); mpi_free( &TV );
1237      mpi_free( &V1 ); mpi_free( &V2 );
1238      return( ret );
1239  }
1240  #endif
1241  #if defined(POLARSSL_GENPRIME)
1242  static const int small_prime[] =
1243  {
1244          3,    5,    7,   11,   13,   17,   19,   23,
1245         29,   31,   37,   41,   43,   47,   53,   59,
1246         61,   67,   71,   73,   79,   83,   89,   97,
1247        101,  103,  107,  109,  113,  127,  131,  137,
1248        139,  149,  151,  157,  163,  167,  173,  179,
1249        181,  191,  193,  197,  199,  211,  223,  227,
1250        229,  233,  239,  241,  251,  257,  263,  269,
1251        271,  277,  281,  283,  293,  307,  311,  313,
1252        317,  331,  337,  347,  349,  353,  359,  367,
1253        373,  379,  383,  389,  397,  401,  409,  419,
1254        421,  431,  433,  439,  443,  449,  457,  461,
1255        463,  467,  479,  487,  491,  499,  503,  509,
1256        521,  523,  541,  547,  557,  563,  569,  571,
1257        577,  587,  593,  599,  601,  607,  613,  617,
1258        619,  631,  641,  643,  647,  653,  659,  661,
1259        673,  677,  683,  691,  701,  709,  719,  727,
1260        733,  739,  743,  751,  757,  761,  769,  773,
1261        787,  797,  809,  811,  821,  823,  827,  829,
1262        839,  853,  857,  859,  863,  877,  881,  883,
1263        887,  907,  911,  919,  929,  937,  941,  947,
1264        953,  967,  971,  977,  983,  991,  997, -103
1265  };
1266  static int mpi_check_small_factors( const mpi *X )
1267  {
1268      int ret = 0;
1269      size_t i;
1270      t_uint r;
1271      if( ( X->p[0] & 1 ) == 0 )
1272          return( POLARSSL_ERR_MPI_NOT_ACCEPTABLE );
1273      for( i = 0; small_prime[i] > 0; i++ )
1274      {
1275          if( mpi_cmp_int( X, small_prime[i] ) <= 0 )
1276              return( 1 );
1277          MPI_CHK( mpi_mod_int( &r, X, small_prime[i] ) );
1278          if( r == 0 )
1279              return( POLARSSL_ERR_MPI_NOT_ACCEPTABLE );
1280      }
1281  cleanup:
1282      return( ret );
1283  }
1284  static int mpi_miller_rabin( const mpi *X,
1285                               int (*f_rng)(void *, unsigned char *, size_t),
1286                               void *p_rng )
1287  {
1288      int ret, count;
1289      size_t i, j, k, n, s;
1290      mpi W, R, T, A, RR;
1291      mpi_init( &W ); mpi_init( &R ); mpi_init( &T ); mpi_init( &A );
1292      mpi_init( &RR );
1293      MPI_CHK( mpi_sub_int( &W, X, 1 ) );
1294      s = mpi_lsb( &W );
1295      MPI_CHK( mpi_copy( &R, &W ) );
1296      MPI_CHK( mpi_shift_r( &R, s ) );
1297      i = mpi_msb( X );
1298      n = ( ( i >= 1300 ) ?  2 : ( i >=  850 ) ?  3 :
1299            ( i >=  650 ) ?  4 : ( i >=  350 ) ?  8 :
1300            ( i >=  250 ) ? 12 : ( i >=  150 ) ? 18 : 27 );
1301      for( i = 0; i < n; i++ )
1302      {
1303          count = 0;
1304          do {
1305              MPI_CHK( mpi_fill_random( &A, X->n * ciL, f_rng, p_rng ) );
1306              j = mpi_msb( &A );
1307              k = mpi_msb( &W );
1308              if (j > k) {
1309                  MPI_CHK( mpi_shift_r( &A, j - k ) );
1310              }
1311              if (count++ > 30) {
1312                  return POLARSSL_ERR_MPI_NOT_ACCEPTABLE;
1313              }
1314          } while ( (mpi_cmp_mpi( &A, &W ) >= 0) ||
1315                    (mpi_cmp_int( &A, 1 )  <= 0)    );
1316          MPI_CHK( mpi_exp_mod( &A, &A, &R, X, &RR ) );
1317          if( mpi_cmp_mpi( &A, &W ) == 0 ||
1318              mpi_cmp_int( &A,  1 ) == 0 )
1319              continue;
1320          j = 1;
1321          while( j < s && mpi_cmp_mpi( &A, &W ) != 0 )
1322          {
1323              MPI_CHK( mpi_mul_mpi( &T, &A, &A ) );
1324              MPI_CHK( mpi_mod_mpi( &A, &T, X  ) );
1325              if( mpi_cmp_int( &A, 1 ) == 0 )
1326                  break;
1327              j++;
1328          }
1329          if( mpi_cmp_mpi( &A, &W ) != 0 ||
1330              mpi_cmp_int( &A,  1 ) == 0 )
1331          {
1332              ret = POLARSSL_ERR_MPI_NOT_ACCEPTABLE;
1333              break;
1334          }
1335      }
1336  cleanup:
1337      mpi_free( &W ); mpi_free( &R ); mpi_free( &T ); mpi_free( &A );
1338      mpi_free( &RR );
1339      return( ret );
1340  }
1341  int mpi_is_prime( mpi *X,
1342                    int (*f_rng)(void *, unsigned char *, size_t),
1343                    void *p_rng )
1344  {
1345      int ret;
1346      mpi XX;
1347      XX.s = 1;
1348      XX.n = X->n;
1349      XX.p = X->p;
1350      if( mpi_cmp_int( &XX, 0 ) == 0 ||
1351          mpi_cmp_int( &XX, 1 ) == 0 )
1352          return( POLARSSL_ERR_MPI_NOT_ACCEPTABLE );
1353      if( mpi_cmp_int( &XX, 2 ) == 0 )
1354          return( 0 );
1355      if( ( ret = mpi_check_small_factors( &XX ) ) != 0 )
1356      {
1357          if( ret == 1 )
1358              return( 0 );
1359          return( ret );
1360      }
1361      return( mpi_miller_rabin( &XX, f_rng, p_rng ) );
1362  }
1363  int mpi_gen_prime( mpi *X, size_t nbits, int dh_flag,
1364                     int (*f_rng)(void *, unsigned char *, size_t),
1365                     void *p_rng )
1366  {
1367      int ret;
1368      size_t k, n;
1369      t_uint r;
1370      mpi Y;
1371      if( nbits < 3 || nbits > POLARSSL_MPI_MAX_BITS )
1372          return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );
1373      mpi_init( &Y );
1374      n = BITS_TO_LIMBS( nbits );
1375      MPI_CHK( mpi_fill_random( X, n * ciL, f_rng, p_rng ) );
1376      k = mpi_msb( X );
1377      if( k > nbits ) MPI_CHK( mpi_shift_r( X, k - nbits + 1 ) );
1378      mpi_set_bit( X, nbits-1, 1 );
1379      X->p[0] |= 1;
1380      if( dh_flag == 0 )
1381      {
1382          while( ( ret = mpi_is_prime( X, f_rng, p_rng ) ) != 0 )
1383          {
1384              if( ret != POLARSSL_ERR_MPI_NOT_ACCEPTABLE )
1385                  goto cleanup;
1386              MPI_CHK( mpi_add_int( X, X, 2 ) );
1387          }
1388      }
1389      else
1390      {
1391          X->p[0] |= 2;
1392          MPI_CHK( mpi_mod_int( &r, X, 3 ) );
1393          if( r == 0 )
1394              MPI_CHK( mpi_add_int( X, X, 8 ) );
1395          else if( r == 1 )
1396              MPI_CHK( mpi_add_int( X, X, 4 ) );
1397          MPI_CHK( mpi_copy( &Y, X ) );
1398          MPI_CHK( mpi_shift_r( &Y, 1 ) );
1399          while( 1 )
1400          {
1401              if( ( ret = mpi_check_small_factors(  X         ) ) == 0 &&
1402                  ( ret = mpi_check_small_factors( &Y         ) ) == 0 &&
1403                  ( ret = mpi_miller_rabin(  X, f_rng, p_rng  ) ) == 0 &&
1404                  ( ret = mpi_miller_rabin( &Y, f_rng, p_rng  ) ) == 0 )
1405              {
1406                  break;
1407              }
1408              if( ret != POLARSSL_ERR_MPI_NOT_ACCEPTABLE )
1409                  goto cleanup;
1410              MPI_CHK( mpi_add_int(  X,  X, 12 ) );
1411              MPI_CHK( mpi_add_int( &Y, &Y, 6  ) );
1412          }
1413      }
1414  cleanup:
1415      mpi_free( &Y );
1416      return( ret );
1417  }
1418  #endif &bsol;* POLARSSL_GENPRIME */
1419  #if defined(POLARSSL_SELF_TEST)
1420  #define GCD_PAIR_COUNT  3
1421  static const int gcd_pairs[GCD_PAIR_COUNT][3] =
1422  {
1423      { 693, 609, 21 },
1424      { 1764, 868, 28 },
1425      { 768454923, 542167814, 1 }
1426  };
1427  int mpi_self_test( int verbose )
1428  {
1429      int ret, i;
1430      mpi A, E, N, X, Y, U, V;
1431      mpi_init( &A ); mpi_init( &E ); mpi_init( &N ); mpi_init( &X );
1432      mpi_init( &Y ); mpi_init( &U ); mpi_init( &V );
1433      MPI_CHK( mpi_read_string( &A, 16,
1434          "EFE021C2645FD1DC586E69184AF4A31E" \
1435          "D5F53E93B5F123FA41680867BA110131" \
1436          "944FE7952E2517337780CB0DB80E61AA" \
1437          "E7C8DDC6C5C6AADEB34EB38A2F40D5E6" ) );
1438      MPI_CHK( mpi_read_string( &E, 16,
1439          "B2E7EFD37075B9F03FF989C7C5051C20" \
1440          "34D2A323810251127E7BF8625A4F49A5" \
1441          "F3E27F4DA8BD59C47D6DAABA4C8127BD" \
1442          "5B5C25763222FEFCCFC38B832366C29E" ) );
1443      MPI_CHK( mpi_read_string( &N, 16,
1444          "0066A198186C18C10B2F5ED9B522752A" \
1445          "9830B69916E535C8F047518A889A43A5" \
1446          "94B6BED27A168D31D4A52F88925AA8F5" ) );
1447      MPI_CHK( mpi_mul_mpi( &X, &A, &N ) );
1448      MPI_CHK( mpi_read_string( &U, 16,
1449          "602AB7ECA597A3D6B56FF9829A5E8B85" \
1450          "9E857EA95A03512E2BAE7391688D264A" \
1451          "A5663B0341DB9CCFD2C4C5F421FEC814" \
1452          "8001B72E848A38CAE1C65F78E56ABDEF" \
1453          "E12D3C039B8A02D6BE593F0BBBDA56F1" \
1454          "ECF677152EF804370C1A305CAF3B5BF1" \
<span onclick='openModal()' class='match'>1455          "30879B56C61DE584A0F53A2447A51E" ) );
1456      if( verbose != 0 )
1457          polarssl_printf( "  MPI test #1 (mul_mpi): " );
1458      if( mpi_cmp_mpi( &X, &U ) != 0 )
</span>1459      {
1460          if( verbose != 0 )
1461              polarssl_printf( "failed\n" );
1462          ret = 1;
1463          goto cleanup;
1464      }
1465      if( verbose != 0 )
1466          polarssl_printf( "passed\n" );
1467      MPI_CHK( mpi_div_mpi( &X, &Y, &A, &N ) );
1468      MPI_CHK( mpi_read_string( &U, 16,
1469          "256567336059E52CAE22925474705F39A94" ) );
1470      MPI_CHK( mpi_read_string( &V, 16,
1471          "6613F26162223DF488E9CD48CC132C7A" \
1472          "0AC93C701B001B092E4E5B9F73BCD27B" \
1473          "9EE50D0657C77F374E903CDFA4C642" ) );
1474      if( verbose != 0 )
1475          polarssl_printf( "  MPI test #2 (div_mpi): " );
1476      if( mpi_cmp_mpi( &X, &U ) != 0 ||
1477          mpi_cmp_mpi( &Y, &V ) != 0 )
1478      {
1479          if( verbose != 0 )
1480              polarssl_printf( "failed\n" );
1481          ret = 1;
1482          goto cleanup;
1483      }
1484      if( verbose != 0 )
1485          polarssl_printf( "passed\n" );
1486      MPI_CHK( mpi_exp_mod( &X, &A, &E, &N, NULL ) );
1487      MPI_CHK( mpi_read_string( &U, 16,
1488          "36E139AEA55215609D2816998ED020BB" \
1489          "BD96C37890F65171D948E9BC7CBAA4D9" \
1490          "325D24D6A3C12710F10A09FA08AB87" ) );
1491      if( verbose != 0 )
1492          polarssl_printf( "  MPI test #3 (exp_mod): " );
1493      if( mpi_cmp_mpi( &X, &U ) != 0 )
1494      {
1495          if( verbose != 0 )
1496              polarssl_printf( "failed\n" );
1497          ret = 1;
1498          goto cleanup;
1499      }
1500      if( verbose != 0 )
1501          polarssl_printf( "passed\n" );
1502      MPI_CHK( mpi_inv_mod( &X, &A, &N ) );
1503      MPI_CHK( mpi_read_string( &U, 16,
1504          "003A0AAEDD7E784FC07D8F9EC6E3BFD5" \
1505          "C3DBA76456363A10869622EAC2DD84EC" \
1506          "C5B8A74DAC4D09E03B5E0BE779F2DF61" ) );
1507      if( verbose != 0 )
1508          polarssl_printf( "  MPI test #4 (inv_mod): " );
1509      if( mpi_cmp_mpi( &X, &U ) != 0 )
1510      {
1511          if( verbose != 0 )
1512              polarssl_printf( "failed\n" );
1513          ret = 1;
1514          goto cleanup;
1515      }
1516      if( verbose != 0 )
1517          polarssl_printf( "passed\n" );
1518      if( verbose != 0 )
1519          polarssl_printf( "  MPI test #5 (simple gcd): " );
1520      for( i = 0; i < GCD_PAIR_COUNT; i++ )
1521      {
1522          MPI_CHK( mpi_lset( &X, gcd_pairs[i][0] ) );
1523          MPI_CHK( mpi_lset( &Y, gcd_pairs[i][1] ) );
1524          MPI_CHK( mpi_gcd( &A, &X, &Y ) );
1525          if( mpi_cmp_int( &A, gcd_pairs[i][2] ) != 0 )
1526          {
1527              if( verbose != 0 )
1528                  polarssl_printf( "failed at %d\n", i );
1529              ret = 1;
1530              goto cleanup;
1531          }
1532      }
1533      if( verbose != 0 )
1534          polarssl_printf( "passed\n" );
1535  cleanup:
1536      if( ret != 0 && verbose != 0 )
1537          polarssl_printf( "Unexpected error, return code = %08X\n", ret );
1538      mpi_free( &A ); mpi_free( &E ); mpi_free( &N ); mpi_free( &X );
1539      mpi_free( &Y ); mpi_free( &U ); mpi_free( &V );
1540      if( verbose != 0 )
1541          polarssl_printf( "\n" );
1542      return( ret );
1543  }
1544  #endif &bsol;* POLARSSL_SELF_TEST */
1545  #endif &bsol;* POLARSSL_BIGNUM_C */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-bignum.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-bignum.c</div>
                </div>
                <div class="column column_space"><pre><code>1455          "30879B56C61DE584A0F53A2447A51E" ) );
1456      if( verbose != 0 )
1457          polarssl_printf( "  MPI test #1 (mul_mpi): " );
1458      if( mpi_cmp_mpi( &X, &U ) != 0 )
</pre></code></div>
                <div class="column column_space"><pre><code>1455          "30879B56C61DE584A0F53A2447A51E" ) );
1456      if( verbose != 0 )
1457          polarssl_printf( "  MPI test #1 (mul_mpi): " );
1458      if( mpi_cmp_mpi( &X, &U ) != 0 )
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    