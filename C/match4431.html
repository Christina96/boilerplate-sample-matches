<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for tiffsave.c &amp; dzsave.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for tiffsave.c &amp; dzsave.c
      </h3>
<h1 align="center">
        19.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>tiffsave.c (66.06335%)<th>dzsave.c (11.119574%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(424-487)<td><a href="#" name="0">(2635-2682)</a><td align="center"><font color="#ff0000">33</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(550-761)<td><a href="#" name="1">(2754-2923)</a><td align="center"><font color="#ef0000">31</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(518-549)<td><a href="#" name="2">(2718-2748)</a><td align="center"><font color="#aa0000">22</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(383-410)<td><a href="#" name="3">(2569-2599)</a><td align="center"><font color="#aa0000">22</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(190-210)<td><a href="#" name="4">(2410-2430)</a><td align="center"><font color="#a20000">21</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(235-340)<td><a href="#" name="5">(2434-2542)</a><td align="center"><font color="#830000">17</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>tiffsave.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/internal.h&gt;
9 #include "pforeign.h"
10 #ifdef HAVE_TIFF
11 #include "tiff.h"
12 typedef struct _VipsForeignSaveTiff {
13 	VipsForeignSave parent_object;
14 	VipsForeignTiffCompression compression;
15 	int Q;
16 	VipsForeignTiffPredictor predictor;
17 	char *profile; 
18 	gboolean tile;
19 	int tile_width;
20 	int tile_height;
21 	gboolean pyramid;
22 	gboolean squash;
23 	int bitdepth;
24 	gboolean miniswhite;
25 	VipsForeignTiffResunit resunit;
26 	double xres;
27 	double yres;
28 	gboolean bigtiff;
29 	gboolean rgbjpeg;
30 	gboolean properties;
31 	VipsRegionShrink region_shrink;
32 	int level;
33 	gboolean lossless;
34 	VipsForeignDzDepth depth;
35 	gboolean subifd;
36 	gboolean premultiply;
37 } VipsForeignSaveTiff;
38 typedef VipsForeignSaveClass VipsForeignSaveTiffClass;
39 G_DEFINE_ABSTRACT_TYPE( VipsForeignSaveTiff, vips_foreign_save_tiff, 
40 	VIPS_TYPE_FOREIGN_SAVE );
41 #define UC VIPS_FORMAT_UCHAR
42 static int bandfmt_jpeg[10] = {
43    UC, UC, UC, UC, UC, UC, UC, UC, UC, UC
44 };
45 static int
46 vips_foreign_save_tiff_build( VipsObject *object )
47 {
48 	VipsForeignSaveClass *class = VIPS_FOREIGN_SAVE_GET_CLASS( object );
49 	VipsForeignSave *save = (VipsForeignSave *) object;
50 	VipsForeignSaveTiff *tiff = (VipsForeignSaveTiff *) object;
51 	const char *p;
52 	if( save-&gt;in &amp;&amp;
53 		tiff-&gt;compression == VIPS_FOREIGN_TIFF_COMPRESSION_JPEG ) {
54 		VipsImage *x;
55 		if( vips__foreign_convert_saveable( save-&gt;in, &amp;x,
56 			VIPS_SAVEABLE_RGB_CMYK, bandfmt_jpeg, class-&gt;coding,
57 			save-&gt;background ) )
58 			return( -1 );
59 		g_object_set( object, "in", x, NULL );
60 		g_object_unref( x );
61 	}
62 	if( VIPS_OBJECT_CLASS( vips_foreign_save_tiff_parent_class )-&gt;
63 		build( object ) )
64 		return( -1 );
65 	if( !vips_object_argument_isset( object, "xres" ) )
66 		tiff-&gt;xres = save-&gt;ready-&gt;Xres;
67 	if( !vips_object_argument_isset( object, "yres" ) )
68 		tiff-&gt;yres = save-&gt;ready-&gt;Yres;
69 	tiff-&gt;xres *= 10.0;
70 	tiff-&gt;yres *= 10.0;
71 	if( !vips_object_argument_isset( object, "resunit" ) &amp;&amp;
72 		vips_image_get_typeof( save-&gt;ready, 
73 			VIPS_META_RESOLUTION_UNIT ) &amp;&amp;
74 		!vips_image_get_string( save-&gt;ready, 
75 			VIPS_META_RESOLUTION_UNIT, &amp;p ) &amp;&amp;
76 		vips_isprefix( "in", p ) ) 
77 		tiff-&gt;resunit = VIPS_FOREIGN_TIFF_RESUNIT_INCH;
78 	if( tiff-&gt;resunit == VIPS_FOREIGN_TIFF_RESUNIT_INCH ) {
79 		tiff-&gt;xres *= 2.54;
80 		tiff-&gt;yres *= 2.54;
81 <a name="4"></a>	}
82 	return( 0 );
83 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
84 static void
85 vips_foreign_save_tiff_class_init( VipsForeignSaveTiffClass *class )
86 {
87 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
88 	VipsObjectClass *object_class = (VipsObjectClass *) class;
89 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
90 	VipsForeignSaveClass *save_class = (VipsForeignSaveClass *) class;
91 	gobject_class-&gt;set_property = vips_object_set_property;
92 	gobject_class-&gt;get_property = vips_object_get_property;
93 	object_class-&gt;nickname = "tiffsave_base";
94 	object_class-&gt;description = _( "save image to tiff file" );
95 	object_class-&gt;build = vips_foreign_save_tiff_build;
96 	foreign_class-&gt;suffs = vips__foreign_tiff_suffs;
97 	save_class-&gt;saveable = VIPS_SAVEABLE_ANY;
98 	save_class-&gt;coding[VIPS_CODING_LABQ] = TRUE;</b></font>
99 	VIPS_ARG_ENUM( class, "compression", 6, 
100 		_( "Compression" ), 
101 		_( "Compression for this file" ),
102 		VIPS_ARGUMENT_OPTIONAL_INPUT,
103 		G_STRUCT_OFFSET( VipsForeignSaveTiff, compression ),
104 		VIPS_TYPE_FOREIGN_TIFF_COMPRESSION, 
105 			VIPS_FOREIGN_TIFF_COMPRESSION_NONE ); 
106 	VIPS_ARG_INT( class, "Q", 7, 
107 		_( "Q" ), 
108 		_( "Q factor" ),
109 		VIPS_ARGUMENT_OPTIONAL_INPUT,
110 		G_STRUCT_OFFSET( VipsForeignSaveTiff, Q ),
111 		1, 100, 75 );
112 	VIPS_ARG_ENUM( class, "predictor", 8, 
113 		_( "predictor" ), 
114 		_( "Compression prediction" ),
115 		VIPS_ARGUMENT_OPTIONAL_INPUT,
116 		G_STRUCT_OFFSET( VipsForeignSaveTiff, predictor ),
117 <a name="5"></a>		VIPS_TYPE_FOREIGN_TIFF_PREDICTOR, 
118 			VIPS_FOREIGN_TIFF_PREDICTOR_HORIZONTAL ); 
119 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	VIPS_ARG_STRING( class, "profile", 9, 
120 		_( "profile" ), 
121 		_( "ICC profile to embed" ),
122 		VIPS_ARGUMENT_OPTIONAL_INPUT,
123 		G_STRUCT_OFFSET( VipsForeignSaveTiff, profile ),
124 		NULL );
125 	VIPS_ARG_BOOL( class, "tile", 10, 
126 		_( "Tile" ), 
127 		_( "Write a tiled tiff" ),
128 		VIPS_ARGUMENT_OPTIONAL_INPUT,
129 		G_STRUCT_OFFSET( VipsForeignSaveTiff, tile ),
130 		FALSE );
131 	VIPS_ARG_INT( class, "tile_width", 11, 
132 		_( "Tile width" ), 
133 		_( "Tile width in pixels" ),
134 		VIPS_ARGUMENT_OPTIONAL_INPUT,
135 		G_STRUCT_OFFSET( VipsForeignSaveTiff, tile_width ),
136 		1, 32768, 128 );
137 	VIPS_ARG_INT( class, "tile_height", 12, 
138 		_( "Tile height" ), 
139 		_( "Tile height in pixels" ),
140 		VIPS_ARGUMENT_OPTIONAL_INPUT,
141 		G_STRUCT_OFFSET( VipsForeignSaveTiff, tile_height ),
142 		1, 32768, 128 );
143 	VIPS_ARG_BOOL( class, "pyramid", 13, 
144 		_( "Pyramid" ), 
145 		_( "Write a pyramidal tiff" ),
146 		VIPS_ARGUMENT_OPTIONAL_INPUT,
147 		G_STRUCT_OFFSET( VipsForeignSaveTiff, pyramid ),
148 		FALSE );
149 	VIPS_ARG_BOOL( class, "miniswhite", 14, 
150 		_( "Miniswhite" ), 
151 		_( "Use 0 for white in 1-bit images" ),
152 		VIPS_ARGUMENT_OPTIONAL_INPUT,
153 		G_STRUCT_OFFSET( VipsForeignSaveTiff, miniswhite ),
154 		FALSE );
155 	VIPS_ARG_INT( class, "bitdepth", 15,
156 		_( "bitdepth" ),
157 		_( "Write as a 1, 2, 4 or 8 bit image" ),
158 		VIPS_ARGUMENT_OPTIONAL_INPUT,
159 		G_STRUCT_OFFSET( VipsForeignSaveTiff, bitdepth ),
160 		0, 8, 0 );
161 	VIPS_ARG_ENUM( class, "resunit", 16, 
162 		_( "Resolution unit" ), 
163 		_( "Resolution unit" ),
164 		VIPS_ARGUMENT_OPTIONAL_INPUT,
165 		G_STRUCT_OFFSET( VipsForeignSaveTiff, resunit ),
166 		VIPS_TYPE_FOREIGN_TIFF_RESUNIT, VIPS_FOREIGN_TIFF_RESUNIT_CM ); 
167 	VIPS_ARG_DOUBLE( class, "xres", 17, 
168 		_( "Xres" ), 
169 		_( "Horizontal resolution in pixels/mm" ),
170 		VIPS_ARGUMENT_OPTIONAL_INPUT,
171 		G_STRUCT_OFFSET( VipsForeignSaveTiff, xres ),
172 		0.001, 1000000, 1 );
173 	VIPS_ARG_DOUBLE( class, "yres", 18, 
174 		_( "Yres" ), 
175 		_( "Vertical resolution in pixels/mm" ),
176 		VIPS_ARGUMENT_OPTIONAL_INPUT,
177 		G_STRUCT_OFFSET( VipsForeignSaveTiff, yres ),
178 		0.001, 1000000, 1 );
179 	VIPS_ARG_BOOL( class, "bigtiff", 19, 
180 		_( "Bigtiff" ), 
181 		_( "Write a bigtiff image" ),
182 		VIPS_ARGUMENT_OPTIONAL_INPUT,
183 		G_STRUCT_OFFSET( VipsForeignSaveTiff, bigtiff ),
184 		FALSE );
185 	VIPS_ARG_BOOL( class, "properties", 21, 
186 		_( "Properties" ), 
187 		_( "Write a properties document to IMAGEDESCRIPTION" ),
188 		VIPS_ARGUMENT_OPTIONAL_INPUT,
189 		G_STRUCT_OFFSET( VipsForeignSaveTiff, properties ),
190 		FALSE );
191 	VIPS_ARG_ENUM( class, "region_shrink", 22,
192 		_( "Region shrink" ),
193 		_( "Method to shrink regions" ),
194 		VIPS_ARGUMENT_OPTIONAL_INPUT,
195 		G_STRUCT_OFFSET( VipsForeignSaveTiff, region_shrink ),
196 		VIPS_TYPE_REGION_SHRINK, VIPS_REGION_SHRINK_MEAN ); 
197 	VIPS_ARG_INT( class, "level", 23,
198 		_( "Level" ),
199 		_( "ZSTD compression level" ),
200 		VIPS_ARGUMENT_OPTIONAL_INPUT,
201 		G_STRUCT_OFFSET( VipsForeignSaveTiff, level ),
202 		1, 22, 10 );
203 	VIPS_ARG_BOOL( class, "lossless", 24, 
204 		_( "Lossless" ), 
205 		_( "Enable WEBP lossless mode" ),
206 		VIPS_ARGUMENT_OPTIONAL_INPUT,
207 		G_STRUCT_OFFSET( VipsForeignSaveTiff, lossless ),
208 		FALSE );
209 	VIPS_ARG_ENUM( class, "depth", 25, </b></font>
210 		_( "Depth" ), 
211 		_( "Pyramid depth" ),
212 		VIPS_ARGUMENT_OPTIONAL_INPUT,
213 		G_STRUCT_OFFSET( VipsForeignSaveTiff, depth ),
214 		VIPS_TYPE_FOREIGN_DZ_DEPTH, VIPS_FOREIGN_DZ_DEPTH_ONETILE ); 
215 	VIPS_ARG_BOOL( class, "subifd", 26, 
216 		_( "Sub-IFD" ), 
217 		_( "Save pyr layers as sub-IFDs" ),
218 		VIPS_ARGUMENT_OPTIONAL_INPUT,
219 		G_STRUCT_OFFSET( VipsForeignSaveTiff, subifd ),
220 		FALSE );
221 	VIPS_ARG_BOOL( class, "premultiply", 27, 
222 		_( "Premultiply" ), 
223 		_( "Save with premultiplied alpha" ),
224 		VIPS_ARGUMENT_OPTIONAL_INPUT,
225 		G_STRUCT_OFFSET( VipsForeignSaveTiff, premultiply ),
226 		FALSE );
227 	VIPS_ARG_BOOL( class, "rgbjpeg", 20, 
228 		_( "RGB JPEG" ),
229 		_( "Output RGB JPEG rather than YCbCr" ),
230 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED, 
231 		G_STRUCT_OFFSET( VipsForeignSaveTiff, rgbjpeg ),
232 		FALSE );
233 	VIPS_ARG_BOOL( class, "squash", 14, 
234 		_( "Squash" ), 
235 		_( "Squash images down to 1 bit" ),
236 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
237 		G_STRUCT_OFFSET( VipsForeignSaveTiff, squash ),
238 		FALSE );
239 }
240 static void
241 vips_foreign_save_tiff_init( VipsForeignSaveTiff *tiff )
242 {
243 <a name="3"></a>	tiff-&gt;compression = VIPS_FOREIGN_TIFF_COMPRESSION_NONE;
244 	tiff-&gt;Q = 75;
245 	tiff-&gt;predictor = VIPS_FOREIGN_TIFF_PREDICTOR_HORIZONTAL;
246 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	tiff-&gt;tile_width = 128;
247 	tiff-&gt;tile_height = 128;
248 	tiff-&gt;resunit = VIPS_FOREIGN_TIFF_RESUNIT_CM;
249 	tiff-&gt;xres = 1.0;
250 	tiff-&gt;yres = 1.0;
251 	tiff-&gt;region_shrink = VIPS_REGION_SHRINK_MEAN;
252 	tiff-&gt;level = 10;
253 	tiff-&gt;lossless = FALSE;
254 	tiff-&gt;depth = VIPS_FOREIGN_DZ_DEPTH_ONETILE; 
255 	tiff-&gt;bitdepth = 0;
256 }
257 typedef struct _VipsForeignSaveTiffFile {
258 	VipsForeignSaveTiff parent_object;
259 	char *filename; 
260 } VipsForeignSaveTiffFile;
261 typedef VipsForeignSaveTiffClass VipsForeignSaveTiffFileClass;
262 G_DEFINE_TYPE( VipsForeignSaveTiffFile, vips_foreign_save_tiff_file, 
263 	vips_foreign_save_tiff_get_type() );
264 static int
265 vips_foreign_save_tiff_file_build( VipsObject *object )
266 {
267 	VipsForeignSave *save = (VipsForeignSave *) object;
268 	VipsForeignSaveTiff *tiff = (VipsForeignSaveTiff *) object;</b></font>
269 	VipsForeignSaveTiffFile *file = (VipsForeignSaveTiffFile *) object;
270 	if( VIPS_OBJECT_CLASS( vips_foreign_save_tiff_file_parent_class )-&gt;
271 		build( object ) )
272 		return( -1 );
273         if( tiff-&gt;squash )
274 		tiff-&gt;bitdepth = 1;
275 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if( vips__tiff_write( save-&gt;ready, file-&gt;filename,
276 		tiff-&gt;compression, tiff-&gt;Q, tiff-&gt;predictor,
277 		tiff-&gt;profile,
278 		tiff-&gt;tile, tiff-&gt;tile_width, tiff-&gt;tile_height,
279 		tiff-&gt;pyramid,
280 		tiff-&gt;bitdepth,
281 		tiff-&gt;miniswhite,
282 		tiff-&gt;resunit, tiff-&gt;xres, tiff-&gt;yres,
283 		tiff-&gt;bigtiff,
284 		tiff-&gt;rgbjpeg,
285 		tiff-&gt;properties,
286 		save-&gt;strip,
287 		tiff-&gt;region_shrink,
288 		tiff-&gt;level,
289 		tiff-&gt;lossless,
290 		tiff-&gt;depth,
291 		tiff-&gt;subifd,
292 		tiff-&gt;premultiply ) )
293 		return( -1 );
294 	return( 0 );
295 }
296 static void
297 vips_foreign_save_tiff_file_class_init( VipsForeignSaveTiffFileClass *class )
298 {
299 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
300 	VipsObjectClass *object_class = (VipsObjectClass *) class;
301 	gobject_class-&gt;set_property = vips_object_set_property;
302 	gobject_class-&gt;get_property = vips_object_get_property;
303 	object_class-&gt;nickname = "tiffsave";
304 	object_class-&gt;description = _( "save image to tiff file" );
305 	object_class-&gt;build = vips_foreign_save_tiff_file_build;
306 	VIPS_ARG_STRING( class, "filename", 1, 
307 		_( "Filename" ),
308 		_( "Filename to save to" ),
309 		VIPS_ARGUMENT_REQUIRED_INPUT, 
310 		G_STRUCT_OFFSET( VipsForeignSaveTiffFile, filename ),
311 		NULL );
312 }
313 static void
314 vips_foreign_save_tiff_file_init( VipsForeignSaveTiffFile *file )
315 {
316 }
317 typedef struct _VipsForeignSaveTiffBuffer {
318 	VipsForeignSaveTiff parent_object;
319 	VipsArea *buf;
320 } VipsForeignSaveTiffBuffer;
321 typedef VipsForeignSaveTiffClass VipsForeignSaveTiffBufferClass;
322 G_DEFINE_TYPE( VipsForeignSaveTiffBuffer, vips_foreign_save_tiff_buffer, 
323 	vips_foreign_save_tiff_get_type() );
324 static int
325 vips_foreign_save_tiff_buffer_build( VipsObject *object )
326 {
327 	VipsForeignSave *save = (VipsForeignSave *) object;</b></font>
328 	VipsForeignSaveTiff *tiff = (VipsForeignSaveTiff *) object;
329 	void *obuf;
330 	size_t olen;
331 	VipsBlob *blob;
332 	if( VIPS_OBJECT_CLASS( vips_foreign_save_tiff_buffer_parent_class )-&gt;
333 		build( object ) )
334 		return( -1 );
335 	if( vips__tiff_write_buf( save-&gt;ready, &amp;obuf, &amp;olen,
336 		tiff-&gt;compression, tiff-&gt;Q, tiff-&gt;predictor,
337 		tiff-&gt;profile,
338 		tiff-&gt;tile, tiff-&gt;tile_width, tiff-&gt;tile_height,
339 		tiff-&gt;pyramid,
340 		tiff-&gt;bitdepth,
341 		tiff-&gt;miniswhite,
342 		tiff-&gt;resunit, tiff-&gt;xres, tiff-&gt;yres,
343 		tiff-&gt;bigtiff,
344 		tiff-&gt;rgbjpeg,
345 		tiff-&gt;properties,
346 		save-&gt;strip,
347 		tiff-&gt;region_shrink,
348 		tiff-&gt;level,
349 		tiff-&gt;lossless, 
350 		tiff-&gt;depth,
351 		tiff-&gt;subifd,
352 <a name="2"></a>		tiff-&gt;premultiply ) )
353 		return( -1 );
354 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	blob = vips_blob_new( (VipsCallbackFn) vips_area_free_cb, obuf, olen );
355 	g_object_set( object, "buffer", blob, NULL );
356 	vips_area_unref( VIPS_AREA( blob ) );
357 	return( 0 );
358 }
359 static void
360 vips_foreign_save_tiff_buffer_class_init( 
361 	VipsForeignSaveTiffBufferClass *class )
362 {
363 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
364 	VipsObjectClass *object_class = (VipsObjectClass *) class;
365 	gobject_class-&gt;set_property = vips_object_set_property;
366 	gobject_class-&gt;get_property = vips_object_get_property;
367 	object_class-&gt;nickname = "tiffsave_buffer";
368 	object_class-&gt;description = _( "save image to tiff buffer" );
369 	object_class-&gt;build = vips_foreign_save_tiff_buffer_build;
370 	VIPS_ARG_BOXED( class, "buffer", 1, 
371 		_( "Buffer" ),
372 		_( "Buffer to save to" ),
373 		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
374 		G_STRUCT_OFFSET( VipsForeignSaveTiffBuffer, buf ),
375 		VIPS_TYPE_BLOB );
376 }
377 <a name="1"></a>static void
378 vips_foreign_save_tiff_buffer_init( VipsForeignSaveTiffBuffer *buffer )
379 {</b></font>
380 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
381 int
382 vips_tiffsave( VipsImage *in, const char *filename, ... )
383 {
384 	va_list ap;
385 	int result;
386 	va_start( ap, filename );
387 	result = vips_call_split( "tiffsave", ap, in, filename );
388 	va_end( ap );
389 	return( result );
390 }
391 int
392 vips_tiffsave_buffer( VipsImage *in, void **buf, size_t *len, ... )
393 {
394 	va_list ap;
395 	VipsArea *area;
396 	int result;
397 	area = NULL; 
398 	va_start( ap, len );
399 	result = vips_call_split( "tiffsave_buffer", ap, in, &amp;area );
400 	va_end( ap );
401 	if( !result &amp;&amp;
402 		area ) { 
403 		if( buf ) {
404 			*buf = area-&gt;data;
405 			area-&gt;free_fn = NULL;
406 		}
407 		if( len ) 
408 			*len = area-&gt;length;
409 		vips_area_unref( area );
410 	}
411 	return( result );
412 }</b></font>
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>dzsave.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/internal.h&gt;
9 #ifdef HAVE_GSF
10 #pragma GCC diagnostic push
11 #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
12 #include &lt;gsf/gsf.h&gt;
13 #pragma GCC diagnostic pop
14 typedef struct _VipsGsfDirectory { 
15 	struct _VipsGsfDirectory *parent;
16 	char *name;
17 	GSList *children;
18 	GsfOutput *out;
19         GsfOutput *container;
20 	size_t file_count;
21 	size_t filename_lengths;
22 	gint deflate_level;
23 } VipsGsfDirectory; 
24 static void *vips_gsf_tree_close( VipsGsfDirectory *tree );
25 static void *
26 vips_gsf_tree_close_cb( void *item, void *a, void *b )
27 {
28 	VipsGsfDirectory *tree = (VipsGsfDirectory *) item;
29 	return( vips_gsf_tree_close( tree ) );
30 }
31 static void *
32 vips_gsf_tree_close( VipsGsfDirectory *tree )
33 {
34 	vips_slist_map2( tree-&gt;children, vips_gsf_tree_close_cb, NULL, NULL );
35 	if( tree-&gt;out ) {
36 		if( !gsf_output_is_closed( tree-&gt;out ) &amp;&amp;
37 			!gsf_output_close( tree-&gt;out ) ) {
38 			vips_error( "vips_gsf", 
39 				"%s", _( "unable to close stream" ) ); 
40 			return( tree );
41 		}
42 		VIPS_UNREF( tree-&gt;out );
43 	}
44 	if( tree-&gt;container ) { 
45 		if( !gsf_output_is_closed( tree-&gt;container ) &amp;&amp; 
46 			!gsf_output_close( tree-&gt;container ) ) {
47 			vips_error( "vips_gsf", 
48 				"%s", _( "unable to close stream" ) ); 
49 			return( tree );
50 		}
51 		VIPS_UNREF( tree-&gt;container );
52 	}
53 	VIPS_FREEF( g_slist_free, tree-&gt;children );
54 	VIPS_FREE( tree-&gt;name );
55 	VIPS_FREE( tree );
56 	return( NULL ); 
57 }
58 static VipsGsfDirectory *
59 vips_gsf_tree_new( GsfOutput *out, gint deflate_level )
60 {
61 	VipsGsfDirectory *tree = g_new( VipsGsfDirectory, 1 );
62 	tree-&gt;parent = NULL;
63 	tree-&gt;name = NULL;
64 	tree-&gt;children = NULL;
65 	tree-&gt;out = out;
66 	tree-&gt;container = NULL;
67 	tree-&gt;file_count = 0;
68 	tree-&gt;filename_lengths = 0;
69 	tree-&gt;deflate_level = deflate_level;
70 	return( tree ); 
71 }
72 static void *
73 vips_gsf_child_by_name_sub( VipsGsfDirectory *dir, const char *name, void *b )
74 {
75 	if( strcmp( dir-&gt;name, name ) == 0 )
76 		return( dir );
77 	return( NULL ); 
78 }
79 static VipsGsfDirectory *
80 vips_gsf_child_by_name( VipsGsfDirectory *dir, const char *name )
81 {
82 	return( vips_slist_map2( dir-&gt;children, 
83 		(VipsSListMap2Fn) vips_gsf_child_by_name_sub, 
84 		(char *) name, NULL ) );
85 }
86 static VipsGsfDirectory *
87 vips_gsf_dir_new( VipsGsfDirectory *parent, const char *name )
88 {
89 	VipsGsfDirectory *dir = g_new( VipsGsfDirectory, 1 );
90 	g_assert( !vips_gsf_child_by_name( parent, name ) ); 
91 	dir-&gt;parent = parent;
92 	dir-&gt;name = g_strdup( name );
93 	dir-&gt;children = NULL;
94 	dir-&gt;container = NULL;
95 	dir-&gt;file_count = 0;
96 	dir-&gt;filename_lengths = 0;
97 	dir-&gt;deflate_level = parent-&gt;deflate_level;
98 	if( GSF_IS_OUTFILE_ZIP( parent-&gt;out ) )
99 		dir-&gt;out = gsf_outfile_new_child_full( 
100 			(GsfOutfile *) parent-&gt;out, 
101 			name, TRUE,
102 			"compression-level", GSF_ZIP_STORED,
103 			NULL );
104 	else
105 		dir-&gt;out = gsf_outfile_new_child( 
106 			(GsfOutfile *) parent-&gt;out, 
107 			name, TRUE ); 
108 	g_assert( dir-&gt;out ); 
109 	parent-&gt;children = g_slist_prepend( parent-&gt;children, dir ); 
110 	return( dir ); 
111 }
112 static GsfOutput *
113 vips_gsf_path( VipsGsfDirectory *tree, const char *name, ... )
114 {
115 	va_list ap;
116 	VipsGsfDirectory *dir;
117 	VipsGsfDirectory *child;
118 	char *dir_name;
119 	GsfOutput *obj;
120 	tree-&gt;file_count += 1;
121 	tree-&gt;filename_lengths += 
122 		strlen( tree-&gt;out-&gt;name ) + strlen( name ) + 1;
123 	dir = tree; 
124 	va_start( ap, name );
125 	while( (dir_name = va_arg( ap, char * )) ) {
126 		if( (child = vips_gsf_child_by_name( dir, dir_name )) )
127 			dir = child;
128 		else 
129 			dir = vips_gsf_dir_new( dir, dir_name );
130 		tree-&gt;filename_lengths += strlen( dir_name ) + 1;
131 	}
132 	va_end( ap );
133 	if( GSF_IS_OUTFILE_ZIP( dir-&gt;out ) ) {
134 		if( dir-&gt;deflate_level == 0 )
135 			obj = gsf_outfile_new_child_full(
136 				(GsfOutfile *) dir-&gt;out,
137 				name, FALSE,
138 				"compression-level", GSF_ZIP_STORED,
139 				NULL );
140 		else if( dir-&gt;deflate_level == -1 )
141 			obj = gsf_outfile_new_child_full(
142 				(GsfOutfile *) dir-&gt;out,
143 				name, FALSE,
144 				"compression-level", GSF_ZIP_DEFLATED,
145 				NULL );
146 		else
147 			obj = gsf_outfile_new_child_full(
148 				(GsfOutfile *) dir-&gt;out,
149 				name, FALSE,
150 				"compression-level", GSF_ZIP_DEFLATED,
151 				"deflate-level", dir-&gt;deflate_level,
152 				NULL );
153 	}
154 	else
155 		obj = gsf_outfile_new_child( (GsfOutfile *) dir-&gt;out,
156 			name, FALSE ); 
157 	return( obj ); 
158 }
159 typedef struct _VipsForeignSaveDz VipsForeignSaveDz;
160 typedef struct _Layer Layer;
161 struct _Layer {
162 	VipsForeignSaveDz *dz;
163 	int width;
164 	int height;
165 	int tiles_across;
166 	int tiles_down;
167 	VipsRect real_pixels; 
168 	VipsImage *image;
169 	int y;
170 	int write_y;
171 	VipsRegion *strip;			VipsRegion *copy;		
172 	int sub;				int n;				
173 	Layer *below;				Layer *above;			};
174 struct _VipsForeignSaveDz {
175 	VipsForeignSave parent_object;
176 	char *suffix;
177 	int overlap;
178 	int tile_size;
179 	VipsForeignDzLayout layout;
180 	VipsForeignDzDepth depth;
181 	gboolean centre;
182 	gboolean properties;
183 	VipsAngle angle;
184 	VipsForeignDzContainer container; 
185 	int compression;
186 	VipsRegionShrink region_shrink;
187 	int skip_blanks;
188 	gboolean no_strip;
189 	char *id;
190 	int tile_margin;
191 	int tile_step;
192 	Layer *layer;			
193 	int tile_count;
194 	VipsGsfDirectory *tree;
195 	GsfOutput *out;
196 	char *basename; 
197 	char *dirname; 
198 	char *tempdir;
199 	char *root_name; 
200 	char *file_suffix;
201 	size_t bytes_written;
202 	VipsPel *ink;
203 };
204 typedef VipsForeignSaveClass VipsForeignSaveDzClass;
205 G_DEFINE_ABSTRACT_TYPE( VipsForeignSaveDz, vips_foreign_save_dz, 
206 	VIPS_TYPE_FOREIGN_SAVE );
207 static gboolean
208 iszip( VipsForeignDzContainer container )
209 {
210 	switch( container ) {
211 	case VIPS_FOREIGN_DZ_CONTAINER_ZIP:
212 	case VIPS_FOREIGN_DZ_CONTAINER_SZI:
213 		return( TRUE );
214 	default:
215 		return( FALSE );
216 	}
217 }
218 #define VIPS_ZIP_FIXED_LH_SIZE (30 + 29)
219 #define VIPS_ZIP_FIXED_CD_SIZE (46 + 9)
220 #define VIPS_ZIP_EOCD_SIZE 22
221 #ifndef HAVE_GSF_ZIP64
222 static size_t
223 estimate_zip_size( VipsForeignSaveDz *dz )
224 {
225 	size_t estimated_zip_size = dz-&gt;bytes_written +
226 		dz-&gt;tree-&gt;file_count * VIPS_ZIP_FIXED_LH_SIZE +
227 		dz-&gt;tree-&gt;filename_lengths +
228 		dz-&gt;tree-&gt;file_count * VIPS_ZIP_FIXED_CD_SIZE +
229 		dz-&gt;tree-&gt;filename_lengths +
230 		VIPS_ZIP_EOCD_SIZE;
231 #ifdef DEBUG_VERBOSE
232 	printf( "estimate_zip_size: %zd\n", estimated_zip_size );
233 	return( estimated_zip_size );
234 }
235 static int
236 write_image( VipsForeignSaveDz *dz,
237 	GsfOutput *out, VipsImage *image, const char *format )
238 {
239 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( dz );
240 	VipsImage *t;
241 	void *buf;
242 	size_t len;
243 	if( vips_copy( image, &amp;t, NULL ) ) 
244 		return( -1 );
245 	vips_image_set_int( t, "hide-progress", 1 );
246 	if( vips_image_write_to_buffer( t, format, &amp;buf, &amp;len,
247 		"strip", !dz-&gt;no_strip,
248 		NULL ) ) {
249 		VIPS_UNREF( t );
250 		return( -1 );
251 	}
252 	VIPS_UNREF( t );
253 	g_mutex_lock( vips__global_lock );
254 	if( !gsf_output_write( out, len, buf ) ) {
255 		gsf_output_close( out );
256 		g_mutex_unlock( vips__global_lock );
257 		g_free( buf );
258 		vips_error( class-&gt;nickname,
259 			"%s", gsf_output_error( out )-&gt;message );
260 		return( -1 );
261 	}
262 	dz-&gt;bytes_written += len;
263 	gsf_output_close( out );
264 #ifndef HAVE_GSF_ZIP64
265 	if( iszip( dz-&gt;container ) ) {
266 		if( dz-&gt;tree-&gt;file_count + 3 &gt;= (unsigned int) USHRT_MAX ) {
267 			g_mutex_unlock( vips__global_lock );
268 			vips_error( class-&gt;nickname,
269 				"%s", _( "too many files in zip" ) );
270 			return( -1 );
271 		}
272 		if( estimate_zip_size( dz ) &gt; (size_t) UINT_MAX - 16384) {
273 			g_mutex_unlock( vips__global_lock );
274 			vips_error( class-&gt;nickname,
275 				"%s", _( "output file too large" ) ); 
276 			return( -1 ); 
277 		}
278 	}
279 	g_mutex_unlock( vips__global_lock );
280 	g_free( buf );
281 	return( 0 );
282 }
283 static void
284 layer_free( Layer *layer )
285 {
286 	VIPS_FREEF( g_object_unref, layer-&gt;strip );
287 	VIPS_FREEF( g_object_unref, layer-&gt;copy );
288 	VIPS_FREEF( g_object_unref, layer-&gt;image );
289 	VIPS_FREEF( layer_free, layer-&gt;below ); 
290 }
291 static void
292 vips_foreign_save_dz_dispose( GObject *gobject )
293 {
294 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) gobject;
295 	VIPS_FREEF( layer_free, dz-&gt;layer );
296 	VIPS_FREEF( vips_gsf_tree_close,  dz-&gt;tree );
297 	VIPS_FREEF( g_object_unref, dz-&gt;out );
298 	VIPS_FREE( dz-&gt;basename );
299 	VIPS_FREE( dz-&gt;dirname );
300 	VIPS_FREE( dz-&gt;tempdir );
301 	VIPS_FREE( dz-&gt;root_name );
302 	VIPS_FREE( dz-&gt;file_suffix );
303 	G_OBJECT_CLASS( vips_foreign_save_dz_parent_class )-&gt;
304 		dispose( gobject );
305 }
306 static Layer *
307 pyramid_build( VipsForeignSaveDz *dz, Layer *above, 
308 	int width, int height, VipsRect *real_pixels )
309 {
310 	VipsForeignSave *save = VIPS_FOREIGN_SAVE( dz );
311 	Layer *layer = VIPS_NEW( dz, Layer );
312 	VipsRect strip;
313 	int limit; 
314 	layer-&gt;dz = dz;
315 	layer-&gt;width = width;
316 	layer-&gt;height = height;
317 	layer-&gt;tiles_across = VIPS_ROUND_UP( width, dz-&gt;tile_step ) / 
318 		dz-&gt;tile_step;
319 	layer-&gt;tiles_down = VIPS_ROUND_UP( height, dz-&gt;tile_step ) / 
320 		dz-&gt;tile_step;
321 	layer-&gt;real_pixels = *real_pixels; 
322 	layer-&gt;image = NULL;
323 	layer-&gt;strip = NULL;
324 	layer-&gt;copy = NULL;
325 	if( !above )
326 		layer-&gt;sub = 1;	
327 	else
328 		layer-&gt;sub = above-&gt;sub * 2;
329 	layer-&gt;below = NULL;
330 	layer-&gt;above = above;
331 	layer-&gt;image = vips_image_new();
332 	if( vips_image_pipelinev( layer-&gt;image, 
333 		VIPS_DEMAND_STYLE_ANY, save-&gt;ready, NULL ) ) {
334 		layer_free( layer );
335 		return( NULL );
336 	}
337 	layer-&gt;image-&gt;Xsize = width + (width &amp; 1);
338 	layer-&gt;image-&gt;Ysize = height + (height &amp; 1);
339 	layer-&gt;strip = vips_region_new( layer-&gt;image );
340 	layer-&gt;copy = vips_region_new( layer-&gt;image );
341 	vips__region_no_ownership( layer-&gt;strip );
342 	vips__region_no_ownership( layer-&gt;copy );
343 	layer-&gt;y = 0;
344 	layer-&gt;write_y = 0;
345 	strip.left = 0;
346 	strip.top = 0;
347 	strip.width = layer-&gt;image-&gt;Xsize;
348 	strip.height = dz-&gt;tile_size + dz-&gt;tile_margin;
349 	if( (strip.height &amp; 1) == 1 )
350 		strip.height += 1;
351 	if( vips_region_buffer( layer-&gt;strip, &amp;strip ) ) {
352 		layer_free( layer );
353 		return( NULL );
354 	}
355 	switch( dz-&gt;depth ) {
356 	case VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL:
357 		limit = 1;
358 		break;
359 	case VIPS_FOREIGN_DZ_DEPTH_ONETILE:
360 		limit = dz-&gt;tile_size;
361 		break;
362 	case VIPS_FOREIGN_DZ_DEPTH_ONE:
363 		limit = VIPS_MAX( width, height );
364 		break;
365 	default:
366 		g_assert_not_reached();
367 		limit = 1;
368 	}
369 	if( width &gt; limit || 
370 		height &gt; limit ) {
371 		VipsRect halfrect;
372 		halfrect.left = real_pixels-&gt;left / 2;
373 		halfrect.top = real_pixels-&gt;top / 2;
374 		halfrect.width = (VIPS_RECT_RIGHT( real_pixels ) + 1) / 2 - 
375 			halfrect.left;
376 		halfrect.height = (VIPS_RECT_BOTTOM( real_pixels ) + 1) / 2 - 
377 			halfrect.top;
378 		if( !(layer-&gt;below = pyramid_build( dz, layer, 
379 			(width + 1) / 2, (height + 1) / 2,
380 			&amp;halfrect )) ) { 
381 			layer_free( layer );
382 			return( NULL );
383 		}
384 		layer-&gt;n = layer-&gt;below-&gt;n + 1;
385 	}
386 	else
387 		layer-&gt;n = 0;
388 #ifdef DEBUG
389 	printf( "pyramid_build:\n" );
390 	printf( "\tn = %d\n", layer-&gt;n );
391 	printf( "\twidth = %d, height = %d\n", width, height );
392 	printf( "\tXsize = %d, Ysize = %d\n", 
393 		layer-&gt;image-&gt;Xsize, layer-&gt;image-&gt;Ysize );
394 	printf( "\ttiles_across = %d, tiles_down = %d\n", 
395 		layer-&gt;tiles_across, layer-&gt;tiles_down ); 
396 	printf( "\treal_pixels.left = %d, real_pixels.top = %d\n", 
397 		real_pixels-&gt;left, real_pixels-&gt;top ); 
398 	printf( "\treal_pixels.width = %d, real_pixels.height = %d\n", 
399 		real_pixels-&gt;width, real_pixels-&gt;height ); 
400 	return( layer );
401 }
402 static int
403 write_dzi( VipsForeignSaveDz *dz )
404 {
405 	GsfOutput *out;
406 	char buf[VIPS_PATH_MAX];
407 	char *p;
408 	vips_snprintf( buf, VIPS_PATH_MAX, "%s.dzi", dz-&gt;basename );
409 	out = vips_gsf_path( dz-&gt;tree, buf, NULL ); 
410 	vips_snprintf( buf, VIPS_PATH_MAX, "%s", dz-&gt;suffix + 1 );
411 	if( (p = (char *) vips__find_rightmost_brackets( buf )) )
412 		*p = '\0';
413 	gsf_output_printf( out, "&lt;?xml "
414 		"version=\"1.0\" encoding=\"UTF-8\"?&gt;\n" ); 
415 	gsf_output_printf( out, "&lt;Image "
416 		"xmlns=\"http://schemas.microsoft.com/deepzoom/2008\"\n" );
417 	gsf_output_printf( out, "  Format=\"%s\"\n", buf );
418 	gsf_output_printf( out, "  Overlap=\"%d\"\n", dz-&gt;overlap );
419 	gsf_output_printf( out, "  TileSize=\"%d\"\n", dz-&gt;tile_size );
420 	gsf_output_printf( out, "  &gt;\n" ); 
421 	gsf_output_printf( out, "  &lt;Size \n" );
422 	gsf_output_printf( out, "    Height=\"%d\"\n", dz-&gt;layer-&gt;height );
423 	gsf_output_printf( out, "    Width=\"%d\"\n", dz-&gt;layer-&gt;width );
424 	gsf_output_printf( out, "  /&gt;\n" ); 
425 	gsf_output_printf( out, "&lt;/Image&gt;\n" );
426 	(void) gsf_output_close( out );
427 	g_object_unref( out );
428 	return( 0 );
429 }
430 static int
431 write_properties( VipsForeignSaveDz *dz )
432 {
433 	GsfOutput *out;
434 	out = vips_gsf_path( dz-&gt;tree, "ImageProperties.xml", NULL ); 
435 	gsf_output_printf( out, "&lt;IMAGE_PROPERTIES "
436 		"WIDTH=\"%d\" HEIGHT=\"%d\" NUMTILES=\"%d\" "
437 		"NUMIMAGES=\"1\" VERSION=\"1.8\" TILESIZE=\"%d\" /&gt;\n",
438 		dz-&gt;layer-&gt;width,
439 		dz-&gt;layer-&gt;height,
440 		dz-&gt;tile_count,
441 		dz-&gt;tile_size );
442 	(void) gsf_output_close( out );
443 	g_object_unref( out );
444 	return( 0 );
445 }
446 static int
447 write_blank( VipsForeignSaveDz *dz )
448 {
449 	VipsForeignSave *save = (VipsForeignSave *) dz;
450 	VipsImage *x, *t;
451 	int n;
452 	VipsArea *ones;
453 	double *d;
454 	double *bg;
455 	int i;
456 	GsfOutput *out; 
457 	bg = (double *) vips_area_get_data( VIPS_AREA( save-&gt;background ), 
458 		NULL, &amp;n, NULL, NULL );
459 	if( vips_black( &amp;x, dz-&gt;tile_size, dz-&gt;tile_size, "bands", n, NULL ) ) 
460 		return( -1 );
461 	ones = vips_area_new_array( G_TYPE_DOUBLE, sizeof( double ), n );
462 	d = (double *) vips_area_get_data( ones, NULL, NULL, NULL, NULL );
463 	for( i = 0; i &lt; n; i++ )
464 		d[i] = 1.0; 
465 	if( vips_linear( x, &amp;t, d, bg, n, NULL ) ) {
466 		vips_area_unref( ones );
467 		g_object_unref( x );
468 		return( -1 );
469 	}
470 	vips_area_unref( ones );
471 	g_object_unref( x );
472 	x = t;
473 	out = vips_gsf_path( dz-&gt;tree, "blank.png", NULL ); 
474 	if( write_image( dz, out, x, ".png" ) ) {
475 		g_object_unref( out );
476 		g_object_unref( x );
477 		return( -1 );
478 	}
479 	g_object_unref( out );
480 	g_object_unref( x );
481 	return( 0 );
482 }
483 static int
484 write_json( VipsForeignSaveDz *dz )
485 {
486 	const char *name = dz-&gt;basename ? dz-&gt;basename : "untitled";
487 	const char *suffix = dz-&gt;file_suffix[0] == '.' ? 
488 		dz-&gt;file_suffix + 1 : dz-&gt;file_suffix;
489 	GsfOutput *out;
490 	int i;
491 	out = vips_gsf_path( dz-&gt;tree, "info.json", NULL ); 
492 	gsf_output_printf( out, 
493 		"{\n"
494 		"  \"@context\": \"http://iiif.io/api/image/2/context.json\",\n"
495 		"  \"@id\": \"%s/%s\",\n" 
496 		"  \"profile\": [\n"
497 		"    \"http://iiif.io/api/image/2/level0.json\",\n"
498 		"    {\n" 
499 		"      \"formats\": [\n"
500 		"        \"%s\"\n"
501 		"      ],\n"
502 		"      \"qualities\": [\n"
503 		"        \"default\"\n"
504 		"      ]\n"
505 		"    }\n"
506 		"  ],\n"
507 		"  \"protocol\": \"http://iiif.io/api/image\",\n", 
508 		dz-&gt;id ? dz-&gt;id : "https://example.com/iiif",
509 		name, 
510 		suffix );
511 	gsf_output_printf( out, 
512 		"  \"tiles\": [\n"
513 		"    {\n"
514 		"      \"scaleFactors\": [\n" );
515 	for( i = 0; i &lt; dz-&gt;layer-&gt;n; i++ ) {
516 		gsf_output_printf( out, 
517 			"        %d",
518 				1 &lt;&lt; i );
519 		if( i != dz-&gt;layer-&gt;n - 1 )
520 			gsf_output_printf( out, "," );
521 		gsf_output_printf( out, "\n" );
522 	}
523 	gsf_output_printf( out, 
524 		"      ],\n"
525 		"      \"width\": %d\n"
526 		"    }\n"
527 		"  ],\n", dz-&gt;tile_size );
528 	gsf_output_printf( out, 
529 		"  \"width\": %d,\n"
530 		"  \"height\": %d\n", 
531 			dz-&gt;layer-&gt;width,
532 			dz-&gt;layer-&gt;height );
533 	gsf_output_printf( out, 
534 		"}\n" );
535 	(void) gsf_output_close( out );
536 	g_object_unref( out );
537 	return( 0 );
538 }
539 static int
540 write_vips_meta( VipsForeignSaveDz *dz )
541 {
542 	VipsForeignSave *save = (VipsForeignSave *) dz;
543 	char *dump;
544 	GsfOutput *out;
545 	if( !(dump = vips__xml_properties( save-&gt;ready )) )
546                 return( -1 );
547 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ )
548 		out = vips_gsf_path( dz-&gt;tree, 
549 			"vips-properties.xml", dz-&gt;root_name, NULL );
550 	else
551 		out = vips_gsf_path( dz-&gt;tree, "vips-properties.xml", NULL );
552 	gsf_output_write( out, strlen( dump ), (guchar *) dump ); 
553 	(void) gsf_output_close( out );
554 	g_object_unref( out );
555 	g_free( dump );
556 	return( 0 );
557 }
558 static void
559 build_scan_property( VipsDbuf *dbuf, VipsImage *image, 
560 	const char *vips_name, const char *szi_name )
561 {
562 	const char *str;
563 	GValue value = { 0 };
564 	GValue save_value = { 0 };
565 	GType type;
566 	if( !vips_image_get_typeof( image, vips_name ) )
567 		return;
568 	if( vips_image_get( image, vips_name, &amp;value ) )
569 		return;
570 	type = G_VALUE_TYPE( &amp;value );
571 	if( !g_value_type_transformable( type, VIPS_TYPE_SAVE_STRING ) ) {
572 		g_value_unset( &amp;value );
573 		return;
574 	}
575 	g_value_init( &amp;save_value, VIPS_TYPE_SAVE_STRING );
576 	if( !g_value_transform( &amp;value, &amp;save_value ) ) {
577 		g_value_unset( &amp;value );
578 		return;
579 	}
580 	g_value_unset( &amp;value );
581 	if( !(str = vips_value_get_save_string( &amp;save_value )) ) {
582 		g_value_unset( &amp;save_value );
583 		return;
584 	}
585 	if( !g_utf8_validate( str, -1, NULL ) ) {
586 		g_value_unset( &amp;save_value );
587 		return;
588 	}
589 	vips_dbuf_writef( dbuf, "    &lt;property&gt;\n" );
590 	vips_dbuf_writef( dbuf, "      &lt;name&gt;" );
591 	vips_dbuf_write_amp( dbuf, szi_name );
592 	vips_dbuf_writef( dbuf, "&lt;/name&gt;\n" );
593 	vips_dbuf_writef( dbuf, "      &lt;value type=\"%s\"&gt;",
594 		g_type_name( type )  );
595 	vips_dbuf_write_amp( dbuf, str );
596 	vips_dbuf_writef( dbuf, "&lt;/value&gt;\n" );
597 	vips_dbuf_writef( dbuf, "    &lt;/property&gt;\n" );
598 	g_value_unset( &amp;save_value );
599 }
600 static char *scan_property_names[][2] = {
601 	{ "openslide.vendor", "Vendor" },
602 	{ "openslide.objective-power", "ObjectiveMagnification" },
603 	{ "openslide.mpp-x", "MicronsPerPixelX" },
604 	{ "openslide.mpp-y", "MicronsPerPixelY" },
605 	{ "width", "ImageWidth" },
606 	{ "height", "ImageHeight" }
607 };
608 char *
609 build_scan_properties( VipsImage *image )
610 {
611 	VipsDbuf dbuf;
612 	char *date;
613 	int i;
614 	date = vips__get_iso8601();
615 	vips_dbuf_init( &amp;dbuf );
616 	vips_dbuf_writef( &amp;dbuf, "&lt;?xml version=\"1.0\"?&gt;\n" ); 
617 	vips_dbuf_writef( &amp;dbuf, "&lt;image xmlns=\"http://www.pathozoom.com/szi\""
618 		" date=\"%s\" version=\"1.0\"&gt;\n", date );
619 	vips_dbuf_writef( &amp;dbuf, "  &lt;properties&gt;\n" );  
620 	g_free( date ); 
621 	for( i = 0; i &lt; VIPS_NUMBER( scan_property_names ); i++ )
622 		build_scan_property( &amp;dbuf, image,
623 			scan_property_names[i][0],
624 			scan_property_names[i][1] );
625 	vips_dbuf_writef( &amp;dbuf, "  &lt;/properties&gt;\n" );
626 	vips_dbuf_writef( &amp;dbuf, "&lt;/image&gt;\n" );
627 	return( (char *) vips_dbuf_steal( &amp;dbuf, NULL ) ); 
628 }
629 static int
630 write_scan_properties( VipsForeignSaveDz *dz )
631 {
632 	VipsForeignSave *save = (VipsForeignSave *) dz;
633 	char *dump;
634 	GsfOutput *out;
635 	if( !(dump = build_scan_properties( save-&gt;ready )) )
636                 return( -1 );
637 	out = vips_gsf_path( dz-&gt;tree, "scan-properties.xml", NULL );
638 	gsf_output_write( out, strlen( dump ), (guchar *) dump );
639 	(void) gsf_output_close( out );
640 	g_object_unref( out );
641 	g_free( dump );
642 	return( 0 );
643 }
644 static void *
645 write_associated_images( VipsImage *image,
646 	const char *field, GValue *value, void *a )
647 {
648 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) a;
649 	if( vips_isprefix( "openslide.associated.", field ) ) {
650 		VipsImage *associated;
651 		const char *p;
652 		const char *q;
653 		GsfOutput *out;
654 		char buf[VIPS_PATH_MAX];
655 		p = field + strlen( "openslide.associated." );
656 		if( (q = strrchr( p, '/' )) )
657 			p = q + 1;
658 		if( vips_image_get_image( image, field, &amp;associated ) )
659 			return( image );
660 		vips_snprintf( buf, VIPS_PATH_MAX, "%s.jpg", p );
661 		out = vips_gsf_path( dz-&gt;tree, buf, "associated_images", NULL );
662 		if( write_image( dz, out, associated, ".jpg" ) ) {
663 			g_object_unref( out );
664 			g_object_unref( associated );
665 			return( image );
666 		}
667 		g_object_unref( out );
668 		g_object_unref( associated );
669 	}
670 	return( NULL );
671 }
672 static int
673 write_associated( VipsForeignSaveDz *dz )
674 {
675 	VipsForeignSave *save = (VipsForeignSave *) dz;
676 	if( vips_image_map( save-&gt;ready, write_associated_images, dz ) )
677 		return( -1 );
678 	return( 0 );
679 }
680 typedef struct _Strip {
681 	Layer *layer; 
682 	VipsImage *image;
683 	int x;
684 } Strip;
685 static void
686 strip_free( Strip *strip )
687 {
688 	g_object_unref( strip-&gt;image );
689 }
690 static void
691 strip_init( Strip *strip, Layer *layer )
692 {
693 	VipsForeignSaveDz *dz = layer-&gt;dz;
694 	VipsRect line, image;
695 	strip-&gt;layer = layer;
696 	strip-&gt;image = NULL;
697 	strip-&gt;x = 0;
698 	image.left = 0;
699 	image.top = 0;
700 	image.width = layer-&gt;image-&gt;Xsize;
701 	image.height = layer-&gt;height;
702 	line.left = 0;
703 	line.top = layer-&gt;y;
704 	line.width = image.width;
705 	line.height = dz-&gt;tile_size;
706 	vips_rect_marginadjust( &amp;line, dz-&gt;tile_margin );
707 	vips_rect_intersectrect( &amp;image, &amp;line, &amp;line );
708 	if( !(strip-&gt;image = vips_image_new_from_memory( 
709 		VIPS_REGION_ADDR( layer-&gt;strip, 0, line.top ),
710 		VIPS_IMAGE_SIZEOF_LINE( layer-&gt;image ) * line.height,
711 		line.width, line.height, 
712 		layer-&gt;image-&gt;Bands, layer-&gt;image-&gt;BandFmt )) ) {
713 		strip_free( strip );
714 		return;
715 	}
716 	if( vips__image_meta_copy( strip-&gt;image, layer-&gt;image ) ) {
717 		strip_free( strip );
718 		return;
719 	}
720 	strip-&gt;image-&gt;Type = layer-&gt;image-&gt;Type;
721 }
722 static int
723 strip_allocate( VipsThreadState *state, void *a, gboolean *stop )
724 {
725 	Strip *strip = (Strip *) a;
726 	Layer *layer = strip-&gt;layer;
727 	VipsForeignSaveDz *dz = layer-&gt;dz;
728 	VipsRect image;
729 #ifdef DEBUG_VERBOSE
730 	printf( "strip_allocate\n" );
731 	if( strip-&gt;x / dz-&gt;tile_step &gt;= layer-&gt;tiles_across ) {
732 		*stop = TRUE;
733 #ifdef DEBUG_VERBOSE
734 		printf( "strip_allocate: done\n" );
735 		return( 0 );
736 	}
737 	image.left = 0;
738 	image.top = 0;
739 	image.width = layer-&gt;width;
740 	image.height = layer-&gt;height;
741 	state-&gt;pos.left = strip-&gt;x;
742 	state-&gt;pos.top = layer-&gt;y;
743 	state-&gt;pos.width = dz-&gt;tile_size;
744 	state-&gt;pos.height = dz-&gt;tile_size;
745 	vips_rect_marginadjust( &amp;state-&gt;pos, dz-&gt;tile_margin );
746 	vips_rect_intersectrect( &amp;image, &amp;state-&gt;pos, &amp;state-&gt;pos );
747 	state-&gt;x = strip-&gt;x;
748 	state-&gt;y = layer-&gt;y;
749 	strip-&gt;x += dz-&gt;tile_step;
750 	return( 0 );
751 }
752 static GsfOutput *
753 tile_name( Layer *layer, int x, int y )
754 {
755 	VipsForeignSaveDz *dz = layer-&gt;dz;
756 	VipsForeignSave *save = (VipsForeignSave *) dz;
757 	GsfOutput *out; 
758 	char name[VIPS_PATH_MAX];
759 	char dirname[VIPS_PATH_MAX];
760 	char dirname2[VIPS_PATH_MAX];
761 	Layer *p;
762 	int n;
763 	switch( dz-&gt;layout ) {
764 	case VIPS_FOREIGN_DZ_LAYOUT_DZ:
765 		vips_snprintf( dirname, VIPS_PATH_MAX, "%d", layer-&gt;n );
766 		vips_snprintf( name, VIPS_PATH_MAX, 
767 			"%d_%d%s", x, y, dz-&gt;file_suffix );
768 		out = vips_gsf_path( dz-&gt;tree, name, 
769 			dz-&gt;root_name, dirname, NULL );
770 		break;
771 	case VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY:
772 		n = 0;
773 		for( p = layer-&gt;below; p; p = p-&gt;below )
774 			n += p-&gt;tiles_across * p-&gt;tiles_down;
775 		n += y * layer-&gt;tiles_across + x;
776 		vips_snprintf( dirname, VIPS_PATH_MAX, "TileGroup%d", n / 256 );
777 		vips_snprintf( name, VIPS_PATH_MAX, 
778 			"%d-%d-%d%s", layer-&gt;n, x, y, dz-&gt;file_suffix );
779 		dz-&gt;tile_count += 1;
780 		out = vips_gsf_path( dz-&gt;tree, name, dirname, NULL );
781 		break;
782 	case VIPS_FOREIGN_DZ_LAYOUT_GOOGLE:
783 		vips_snprintf( dirname, VIPS_PATH_MAX, "%d", layer-&gt;n );
784 		vips_snprintf( dirname2, VIPS_PATH_MAX, "%d", y );
785 		vips_snprintf( name, VIPS_PATH_MAX, 
786 			"%d%s", x, dz-&gt;file_suffix );
787 		out = vips_gsf_path( dz-&gt;tree, name, dirname, dirname2, NULL );
788 		break;
789 	case VIPS_FOREIGN_DZ_LAYOUT_IIIF:
790 {
791 		int left = x * dz-&gt;tile_size * layer-&gt;sub;
792 		int top = y * dz-&gt;tile_size * layer-&gt;sub;
793 		int width = VIPS_MIN( dz-&gt;tile_size * layer-&gt;sub, 
794 			save-&gt;ready-&gt;Xsize - left );
795 		int height = VIPS_MIN( dz-&gt;tile_size * layer-&gt;sub, 
796 			save-&gt;ready-&gt;Ysize - top );
797 		int size = VIPS_MIN( dz-&gt;tile_size, 
798 			layer-&gt;width - x * dz-&gt;tile_size );
799 		vips_snprintf( dirname, VIPS_PATH_MAX, "%d,%d,%d,%d",
800 			left, top, width, height );
801 		vips_snprintf( dirname2, VIPS_PATH_MAX, "%d,", size );
802 		vips_snprintf( name, VIPS_PATH_MAX, "default%s", 
803 			dz-&gt;file_suffix );
804 		out = vips_gsf_path( dz-&gt;tree, 
805 			name, dirname, dirname2, "0", NULL );
806 }
807 		break;
808 	default:
809 		g_assert_not_reached();
810 		out = NULL;
811 	}
812 #ifdef DEBUG_VERBOSE
813 	printf( "tile_name: writing to %s\n", name );
814 	return( out );
815 }
816 static gboolean
817 tile_equal( VipsImage *image, int threshold, VipsPel * restrict ink )
818 {
819 	const int bytes = VIPS_IMAGE_SIZEOF_PEL( image );
820 	VipsRect rect;
821 	VipsRegion *region;
822 	int x, y, b;
823 	region = vips_region_new( image ); 
824 	rect.left = 0;
825 	rect.top = 0;
826 	rect.width = image-&gt;Xsize;
827 	rect.height = image-&gt;Ysize;
828 	if( vips_region_prepare( region, &amp;rect ) ) {
829 		g_object_unref( region );
830 		return( FALSE ); 
831 	}
832 	for( y = 0; y &lt; image-&gt;Ysize; y++ ) {
833 		VipsPel * restrict p = VIPS_REGION_ADDR( region, 0, y ); 
834 		for( x = 0; x &lt; image-&gt;Xsize; x++ ) {
835 			for( b = 0; b &lt; bytes; b++ ) 
836 				if( VIPS_ABS( p[b] - ink[b] ) &gt; threshold ) {
837 					g_object_unref( region );
838 					return( FALSE ); 
839 				}
840 			p += bytes;
841 		}
842 	}
843 	g_object_unref( region );
844 	return( TRUE );
845 }
846 static int
847 strip_work( VipsThreadState *state, void *a )
848 {
849 	Strip *strip = (Strip *) a;
850 	Layer *layer = strip-&gt;layer;
851 	VipsForeignSaveDz *dz = layer-&gt;dz;
852 	VipsForeignSave *save = (VipsForeignSave *) dz;
853 	VipsImage *x;
854 	VipsImage *t;
855 	GsfOutput *out; 
856 #ifdef DEBUG_VERBOSE
857 	printf( "strip_work\n" );
858 	if( dz-&gt;centre ) {
859 		VipsRect tile; 
860 		tile.left = state-&gt;x;
861 		tile.top = state-&gt;y;
862 		tile.width = dz-&gt;tile_size;
863 		tile.height = dz-&gt;tile_size;
864 		if( !vips_rect_overlapsrect( &amp;tile, &amp;layer-&gt;real_pixels ) ) {
865 #ifdef DEBUG_VERBOSE
866 			printf( "strip_work: skipping tile %d x %d\n", 
867 				state-&gt;x / dz-&gt;tile_size, 
868 				state-&gt;y / dz-&gt;tile_size ); 
869 			return( 0 ); 
870 		}
871 	}
872 	g_assert( vips_object_sanity( VIPS_OBJECT( strip-&gt;image ) ) );
873 	if( vips_extract_area( strip-&gt;image, &amp;x, 
874 		state-&gt;pos.left, 0, 
875 		state-&gt;pos.width, state-&gt;pos.height, NULL ) ) 
876 		return( -1 );
877 	if( dz-&gt;skip_blanks &gt;= 0 &amp;&amp;
878 		tile_equal( x, dz-&gt;skip_blanks, dz-&gt;ink ) ) { 
879 		g_object_unref( x );
880 #ifdef DEBUG_VERBOSE
881 		printf( "strip_work: skipping blank tile %d x %d\n", 
882 			state-&gt;x / dz-&gt;tile_size, 
883 			state-&gt;y / dz-&gt;tile_size ); 
884 		return( 0 ); 
885 	}
886 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE ) {
887 		if( vips_embed( x, &amp;t, 0, 0, dz-&gt;tile_size, dz-&gt;tile_size,
888 			"background", save-&gt;background,
889 			NULL ) ) {
890 			g_object_unref( x );
891 			return( -1 );
892 		}
893 		g_object_unref( x );
894 		x = t;
895 	}
896 	g_mutex_lock( vips__global_lock );
897 	out = tile_name( layer, 
898 		state-&gt;x / dz-&gt;tile_step, state-&gt;y / dz-&gt;tile_step );
899 	g_mutex_unlock( vips__global_lock );
900 	if( write_image( dz, out, x, dz-&gt;suffix ) ) {
901 		g_object_unref( out );
902 		g_object_unref( x );
903 		return( -1 );
904 	}
905 	g_object_unref( out );
906 	g_object_unref( x );
907 #ifdef DEBUG_VERBOSE
908 	printf( "strip_work: success\n" );
909 	return( 0 );
910 }
911 static int
912 strip_save( Layer *layer )
913 {
914 	Strip strip;
915 #ifdef DEBUG
916 	printf( "strip_save: n = %d, y = %d\n", layer-&gt;n, layer-&gt;y );
917 	strip_init( &amp;strip, layer );
918 	if( vips_threadpool_run( strip.image, 
919 		vips_thread_state_new, strip_allocate, strip_work, NULL, 
920 		&amp;strip ) ) {
921 		strip_free( &amp;strip );
922 		return( -1 );
923 	}
924 	strip_free( &amp;strip );
925 #ifdef DEBUG
926 	printf( "strip_save: success\n" ); 
927 	return( 0 );
928 }
929 static void
930 layer_generate_extras( Layer *layer )
931 {
932 	VipsRegion *strip = layer-&gt;strip;
933 	g_assert( strip-&gt;valid.width == layer-&gt;image-&gt;Xsize );
934 	if( layer-&gt;width &lt; layer-&gt;image-&gt;Xsize ) {
935 		int ps = VIPS_IMAGE_SIZEOF_PEL( strip-&gt;im );
936 		int b, y;
937 		for( y = 0; y &lt; strip-&gt;valid.height; y++ ) {
938 			VipsPel *p = VIPS_REGION_ADDR( strip, 
939 				layer-&gt;width - 1, strip-&gt;valid.top + y );
940 			VipsPel *q = p + ps;
941 			for( b = 0; b &lt; ps; b++ )
942 				q[b] = p[b];
943 		}
944 	}
945 	if( layer-&gt;height &lt; layer-&gt;image-&gt;Ysize ) {
946 		VipsRect last;
947 		last.left = 0;
948 		last.top = layer-&gt;image-&gt;Ysize - 2;
949 		last.width = layer-&gt;image-&gt;Xsize;
950 		last.height = 2;
951 		vips_rect_intersectrect( &amp;last, &amp;strip-&gt;valid, &amp;last );
952 		if( last.height == 2 ) {
953 			last.height = 1;
954 			vips_region_copy( strip, strip, &amp;last, 
955 				0, last.top + 1 );
956 		}
957 	}
958 }
959 static int strip_arrived( Layer *layer );
960 static int
961 strip_shrink( Layer *layer )
962 {
963 	Layer *below = layer-&gt;below;
964 	VipsRegion *from = layer-&gt;strip;
965 	VipsRegion *to = below-&gt;strip;
966 	VipsForeignSaveDz *dz = layer-&gt;dz;
967 	VipsRegionShrink region_shrink = dz-&gt;region_shrink;
968 	VipsRect target;
969 	VipsRect source;
970 #ifdef DEBUG
971 	printf( "strip_shrink: %d lines in layer %d to layer %d\n", 
972 		from-&gt;valid.height, layer-&gt;n, below-&gt;n ); 
973 	layer_generate_extras( layer );
974 	for(;;) {
975 		target.left = 0;
976 		target.top = below-&gt;write_y;
977 		target.width = below-&gt;image-&gt;Xsize;
978 		target.height = to-&gt;valid.height;
979 		vips_rect_intersectrect( &amp;target, &amp;to-&gt;valid, &amp;target );
980 		source.left = target.left * 2;
981 		source.top = target.top * 2;
982 		source.width = target.width * 2;
983 		source.height = target.height * 2;
984 		vips_rect_intersectrect( &amp;source, &amp;from-&gt;valid, &amp;source );
985 		target.left = source.left / 2;
986 		target.top = source.top / 2;
987 		target.width = source.width / 2;
988 		target.height = source.height / 2;
989 		if( vips_rect_isempty( &amp;target ) )
990 			break;
991 		(void) vips_region_shrink_method( from, to, 
992 			&amp;target, region_shrink );
993 		below-&gt;write_y += target.height;
994 		if( below-&gt;write_y == VIPS_RECT_BOTTOM( &amp;to-&gt;valid ) ||
995 			below-&gt;write_y == below-&gt;height ) {
996 			if( strip_arrived( below ) )
997 				return( -1 );
998 		}
999 	}
1000 	return( 0 );
1001 }
1002 static int
1003 strip_arrived( Layer *layer )
1004 {
1005 	VipsForeignSaveDz *dz = layer-&gt;dz;
1006 	VipsRect new_strip;
1007 	VipsRect overlap;
1008 	VipsRect image_area;
1009 #ifdef DEBUG
1010 	printf( "strip_arrived: layer %d, strip at %d, height %d\n", 
1011 		layer-&gt;n, layer-&gt;y, layer-&gt;strip-&gt;valid.height ); 
1012 	if( strip_save( layer ) )
1013 		return( -1 );
1014 	if( layer-&gt;below &amp;&amp;
1015 		strip_shrink( layer ) )
1016 		return( -1 );
1017 	layer-&gt;y += dz-&gt;tile_step;
1018 	new_strip.left = 0;
1019 	new_strip.top = layer-&gt;y - dz-&gt;tile_margin;
1020 	new_strip.width = layer-&gt;image-&gt;Xsize;
1021 	new_strip.height = dz-&gt;tile_size + 2 * dz-&gt;tile_margin;
1022 	image_area.left = 0;
1023 	image_area.top = 0;
1024 	image_area.width = layer-&gt;image-&gt;Xsize;
1025 	image_area.height = layer-&gt;image-&gt;Ysize;
1026 	vips_rect_intersectrect( &amp;new_strip, &amp;image_area, &amp;new_strip ); 
1027 	if( (new_strip.height &amp; 1) == 1 )
1028 		new_strip.height += 1;
1029 	if( VIPS_RECT_BOTTOM( &amp;new_strip ) == layer-&gt;height )
1030 		new_strip.height = layer-&gt;image-&gt;Ysize - new_strip.top;
1031 	vips_rect_intersectrect( &amp;new_strip, &amp;layer-&gt;strip-&gt;valid, &amp;overlap );
1032 	if( !vips_rect_isempty( &amp;overlap ) ) {
1033 		if( vips_region_buffer( layer-&gt;copy, &amp;overlap ) )
1034 			return( -1 );
1035 		vips_region_copy( layer-&gt;strip, layer-&gt;copy, 
1036 			&amp;overlap, overlap.left, overlap.top );
1037 	}
1038 	if( !vips_rect_isempty( &amp;new_strip ) ) {
1039 		if( vips_region_buffer( layer-&gt;strip, &amp;new_strip ) )
1040 			return( -1 );
1041 		if( !vips_rect_isempty( &amp;overlap ) ) 
1042 			vips_region_copy( layer-&gt;copy, layer-&gt;strip, 
1043 				&amp;overlap, overlap.left, overlap.top );
1044 	}
1045 	return( 0 );
1046 }
1047 static int
1048 strip_flush( Layer *layer )
1049 {
1050 	if( layer-&gt;y &lt; layer-&gt;height )
1051 		if( strip_save( layer ) )
1052 			return( -1 );
1053 	if( layer-&gt;below )
1054 		if( strip_flush( layer-&gt;below ) )
1055 			return( -1 );
1056 	return( 0 );
1057 }
1058 static int
1059 pyramid_strip( VipsRegion *region, VipsRect *area, void *a )
1060 {
1061 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) a;
1062 	Layer *layer = dz-&gt;layer;
1063 #ifdef DEBUG
1064 	printf( "pyramid_strip: strip at %d, height %d\n", 
1065 		area-&gt;top, area-&gt;height );
1066 	for(;;) {
1067 		VipsRect *to = &amp;layer-&gt;strip-&gt;valid;
1068 		VipsRect target;
1069 		target.left = 0;
1070 		target.top = layer-&gt;write_y;
1071 		target.width = layer-&gt;image-&gt;Xsize;
1072 		target.height = to-&gt;height;
1073 		vips_rect_intersectrect( &amp;target, to, &amp;target );
1074 		vips_rect_intersectrect( &amp;target, area, &amp;target );
1075 		if( vips_rect_isempty( &amp;target ) ) 
1076 			break;
1077 		vips_region_copy( region, layer-&gt;strip, 
1078 			&amp;target, target.left, target.top );
1079 		layer-&gt;write_y += target.height;
1080 		if( layer-&gt;write_y == VIPS_RECT_BOTTOM( to ) ||
1081 			layer-&gt;write_y == layer-&gt;height ) {
1082 			if( strip_arrived( layer ) ) 
1083 				return( -1 );
1084 		}
1085 	}
1086 	if( layer-&gt;write_y == layer-&gt;height ) {
1087 #ifdef DEBUG
1088 		printf( "pyramid_strip: flushing ..\n" ); 
1089 		if( strip_flush( layer ) )
1090 			return( -1 );
1091 	}
1092 	return( 0 );
1093 }
1094 static int
1095 vips_foreign_save_dz_build( VipsObject *object )
1096 {
1097 	VipsForeignSave *save = (VipsForeignSave *) object;
1098 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) object;
1099 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( dz ); 
1100 	VipsRect real_pixels; 
1101 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY ||
1102 		dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE ||
1103 		dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_IIIF ) {
1104 		if( !vips_object_argument_isset( object, "overlap" ) )
1105 			dz-&gt;overlap = 0;
1106 		if( !vips_object_argument_isset( object, "suffix" ) )
1107 			VIPS_SETSTR( dz-&gt;suffix, ".jpg" );
1108 	}
1109 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY ||
1110 		dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE ) {
1111 		if( !vips_object_argument_isset( object, "tile_size" ) )
1112 			dz-&gt;tile_size = 256;
1113 	}
1114 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_IIIF ) {
1115 		if( !vips_object_argument_isset( object, "tile_size" ) )
1116 			dz-&gt;tile_size = 512;
1117 	}
1118 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE &amp;&amp;
1119 		!vips_object_argument_isset( object, "skip_blanks" ) )
1120 		dz-&gt;skip_blanks = 5;
1121 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ ) { 
1122 		dz-&gt;tile_margin = dz-&gt;overlap;
1123 		dz-&gt;tile_step = dz-&gt;tile_size; 
1124 	}
1125 	else {
1126 		dz-&gt;tile_margin = 0;
1127 		dz-&gt;tile_step = dz-&gt;tile_size - dz-&gt;overlap;
1128 	}
1129 	if( dz-&gt;tile_step &lt;= 0 ) {
1130 		vips_error( "dzsave", "%s", _( "overlap too large" ) );
1131 		return( -1 );
1132 	}
1133 	if( !vips_object_argument_isset( object, "background" ) ) {
1134 		VipsArrayDouble *background; 
1135 		background = vips_array_double_newv( 1, 255.0 );
1136 		g_object_set( object, "background", background, NULL );
1137 		vips_area_unref( VIPS_AREA( background ) ); 
1138 	}
1139 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ ) {
1140 		if( !vips_object_argument_isset( object, "depth" ) )
1141 			dz-&gt;depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL;
1142 	}
1143 	else
1144 		if( !vips_object_argument_isset( object, "depth" ) )
1145 			dz-&gt;depth = VIPS_FOREIGN_DZ_DEPTH_ONETILE;
1146 	if( VIPS_OBJECT_CLASS( vips_foreign_save_dz_parent_class )-&gt;
1147 		build( object ) )
1148 		return( -1 );
1149 {
1150 	VipsImage *z;
1151 	if( vips_rot( save-&gt;ready, &amp;z, dz-&gt;angle, NULL ) )
1152 		return( -1 );
1153 	VIPS_UNREF( save-&gt;ready );
1154 	save-&gt;ready = z;
1155 }
1156 	if( dz-&gt;skip_blanks &gt;= 0 ) {
1157 		if( !(dz-&gt;ink = vips__vector_to_ink( 
1158 			class-&gt;nickname, save-&gt;ready,
1159 			VIPS_AREA( save-&gt;background )-&gt;data, NULL, 
1160 			VIPS_AREA( save-&gt;background )-&gt;n )) )
1161 			return( -1 );
1162 	}
1163 	real_pixels.left = 0;
1164 	real_pixels.top = 0;
1165 	real_pixels.width = save-&gt;ready-&gt;Xsize;
1166 	real_pixels.height = save-&gt;ready-&gt;Ysize;
1167 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE &amp;&amp;
1168 		dz-&gt;centre ) {
1169 		VipsImage *z;
1170 		Layer *layer;
1171 		int n_layers;
1172 		int size;
1173 		if( !(layer = pyramid_build( dz, NULL, 
1174 			save-&gt;ready-&gt;Xsize, save-&gt;ready-&gt;Ysize,
1175 			&amp;real_pixels )) )
1176 			return( -1 );
1177 		n_layers = layer-&gt;n;
1178 		g_assert( n_layers &lt; 30 );
1179 		layer_free( layer );
1180 		size = dz-&gt;tile_size * (1 &lt;&lt; n_layers);
1181 		real_pixels.left = (size - save-&gt;ready-&gt;Xsize) / 2;
1182 		real_pixels.top = (size - save-&gt;ready-&gt;Ysize) / 2;
1183 		if( vips_embed( save-&gt;ready, &amp;z, 
1184 			real_pixels.left, real_pixels.top,
1185 			size, size,
1186 			"background", save-&gt;background,
1187 			NULL ) ) 
1188 			return( -1 );
1189 		VIPS_UNREF( save-&gt;ready );
1190 		save-&gt;ready = z;
1191 #ifdef DEBUG
1192 		printf( "centre: centring within a %d x %d image\n", 
1193 			size, size );
1194 	}
1195 #ifdef DEBUG
1196 	printf( "vips_foreign_save_dz_build: tile_size == %d\n", 
1197 		dz-&gt;tile_size );
1198 	printf( "vips_foreign_save_dz_build: overlap == %d\n", 
1199 		dz-&gt;overlap );
1200 	printf( "vips_foreign_save_dz_build: tile_margin == %d\n", 
1201 		dz-&gt;tile_margin );
1202 	printf( "vips_foreign_save_dz_build: tile_step == %d\n", 
1203 		dz-&gt;tile_step );
1204 	if( !(dz-&gt;layer = pyramid_build( dz, NULL, 
1205 		save-&gt;ready-&gt;Xsize, save-&gt;ready-&gt;Ysize, &amp;real_pixels )) )
1206 		return( -1 );
1207 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ )
1208 		dz-&gt;root_name = g_strdup_printf( "%s_files", dz-&gt;basename );
1209 	else
1210 		dz-&gt;root_name = g_strdup( dz-&gt;basename );
1211 {
1212 	char filename[VIPS_PATH_MAX];
1213 	char option_string[VIPS_PATH_MAX];
1214 	vips__filename_split8( dz-&gt;suffix, filename, option_string );
1215 	dz-&gt;file_suffix = g_strdup( filename ); 
1216 }
1217 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ &amp;&amp;
1218 		dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_FS &amp;&amp;
1219 		dz-&gt;dirname &amp;&amp;
1220 		vips_existsf( "%s/%s_files", dz-&gt;dirname, dz-&gt;basename ) ) {
1221 		vips_error( "dzsave", 
1222 			_( "output directory %s/%s_files exists" ),
1223 			dz-&gt;dirname, dz-&gt;basename );
1224 		return( -1 ); 
1225 	}
1226 	switch( dz-&gt;container ) {
1227 	case VIPS_FOREIGN_DZ_CONTAINER_FS:
1228 		if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ ) {
1229 			char name[VIPS_PATH_MAX];
1230 			int fd;
1231 			GsfOutput *out;
1232 			GError *error = NULL;
1233 			vips_snprintf( name, VIPS_PATH_MAX, "%s-XXXXXX", 
1234 				dz-&gt;basename ); 
1235 			dz-&gt;tempdir = g_build_filename( dz-&gt;dirname, 
1236 				name, NULL );
1237 			if( (fd = g_mkstemp( dz-&gt;tempdir )) == -1 ) {
1238 				vips_error(  class-&gt;nickname,
1239 					_( "unable to make temporary file %s" ),
1240 					dz-&gt;tempdir );
1241 				return( -1 );
1242 			}
1243 			close( fd );
1244 			g_unlink( dz-&gt;tempdir );
1245 			if( !(out = (GsfOutput *) 
1246 				gsf_outfile_stdio_new( dz-&gt;tempdir, 
1247 					&amp;error )) ) {
1248 				vips_g_error( &amp;error );
1249 				return( -1 );
1250 			}
1251 			dz-&gt;tree = vips_gsf_tree_new( out, 0 );
1252 		}
1253 		else { 
1254 			GsfOutput *out;
1255 			GError *error = NULL;
1256 			char name[VIPS_PATH_MAX];
1257 			vips_snprintf( name, VIPS_PATH_MAX, "%s/%s", 
1258 				dz-&gt;dirname, dz-&gt;basename ); 
1259 			if( !(out = (GsfOutput *) 
1260 				gsf_outfile_stdio_new( name, &amp;error )) ) {
1261 				vips_g_error( &amp;error );
1262 				return( -1 );
1263 			}
1264 			dz-&gt;tree = vips_gsf_tree_new( out, 0 );
1265 		}
1266 		break;
1267 	case VIPS_FOREIGN_DZ_CONTAINER_ZIP:
1268 	case VIPS_FOREIGN_DZ_CONTAINER_SZI:
1269 {
1270 		GsfOutput *zip;
1271 		GsfOutput *out2;
1272 		GError *error = NULL;
1273 		char name[VIPS_PATH_MAX];
1274 		if( dz-&gt;dirname ) { 
1275 			const char *suffix =
1276 				dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_SZI ?
1277 					"szi" : "zip";
1278 			vips_snprintf( name, VIPS_PATH_MAX, "%s/%s.%s",
1279 				dz-&gt;dirname, dz-&gt;basename, suffix );
1280 			if( !(dz-&gt;out =
1281 				gsf_output_stdio_new( name, &amp;error )) ) {
1282 				vips_g_error( &amp;error );
1283 				return( -1 );
1284 			}
1285 		}
1286 		else
1287 			dz-&gt;out = gsf_output_memory_new();
1288 		if( !(zip = (GsfOutput *) 
1289 			gsf_outfile_zip_new( dz-&gt;out, &amp;error )) ) {
1290 			vips_g_error( &amp;error );
1291 			return( -1 );
1292 		}
1293 		out2 = gsf_outfile_new_child_full( (GsfOutfile *) zip, 
1294 			dz-&gt;basename, TRUE,
1295 			"compression-level", GSF_ZIP_STORED, 
1296 			NULL );
1297 #ifndef HAVE_GSF_DEFLATE_LEVEL
1298 		if( dz-&gt;compression &gt; 0 ) {
1299 			g_warning( "%s", 
1300 				_( "deflate-level not supported by libgsf, "
1301 				"using default compression" ) ); 
1302 			dz-&gt;compression = -1;
1303 		}
1304 		dz-&gt;tree = vips_gsf_tree_new( out2, dz-&gt;compression );
1305 		dz-&gt;tree-&gt;container = zip; 
1306 }
1307 		break;
1308 	default:
1309 		g_assert_not_reached();
1310 	}
1311 	if( vips_sink_disc( save-&gt;ready, pyramid_strip, dz ) )
1312 		return( -1 );
1313 	switch( dz-&gt;layout ) {
1314 	case VIPS_FOREIGN_DZ_LAYOUT_DZ:
1315 		if( write_dzi( dz ) )
1316 			return( -1 );
1317 		break;
1318 	case VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY:
1319 		if( write_properties( dz ) )
1320 			return( -1 );
1321 		break;
1322 	case VIPS_FOREIGN_DZ_LAYOUT_GOOGLE:
1323 		if( write_blank( dz ) )
1324 			return( -1 );
1325 		break;
1326 	case VIPS_FOREIGN_DZ_LAYOUT_IIIF:
1327 		if( write_json( dz ) )
1328 			return( -1 );
1329 		break;
1330 	default:
1331 		g_assert_not_reached();
1332 	}
1333 	if( dz-&gt;properties &amp;&amp;
1334 		write_vips_meta( dz ) )
1335 		return( -1 );
1336 	if( dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_SZI &amp;&amp;
1337 		write_scan_properties( dz ) )
1338 		return( -1 );
1339 	if( dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_SZI &amp;&amp;
1340 		write_associated( dz ) )
1341 		return( -1 );
1342 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ &amp;&amp;
1343 		dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_FS ) { 
1344 		char old_name[VIPS_PATH_MAX];
1345 		char new_name[VIPS_PATH_MAX];
1346 		vips_snprintf( old_name, VIPS_PATH_MAX, "%s/%s.dzi", 
1347 			dz-&gt;tempdir, dz-&gt;basename );
1348 		vips_snprintf( new_name, VIPS_PATH_MAX, "%s/%s.dzi", 
1349 			dz-&gt;dirname, dz-&gt;basename );
1350 		if( vips_rename( old_name, new_name ) )
1351 			return( -1 ); 
1352 		vips_snprintf( old_name, VIPS_PATH_MAX, "%s/%s_files", 
1353 			dz-&gt;tempdir, dz-&gt;basename );
1354 		vips_snprintf( new_name, VIPS_PATH_MAX, "%s/%s_files", 
1355 			dz-&gt;dirname, dz-&gt;basename );
1356 		if( vips_rename( old_name, new_name ) )
1357 			return( -1 ); 
1358 		if( vips_rmdirf( "%s", dz-&gt;tempdir ) )
1359 			return( -1 ); 
1360 	}
1361 	if( vips_gsf_tree_close( dz-&gt;tree ) )
1362 		return( -1 ); 
1363 	dz-&gt;tree = NULL; 
1364 	if( iszip( dz-&gt;container ) &amp;&amp;
1365 		dz-&gt;dirname != NULL ) 
1366 		VIPS_FREEF( g_object_unref, dz-&gt;out );
1367 	return( 0 );
1368 }
1369 #define UC VIPS_FORMAT_UCHAR
1370 #define C VIPS_FORMAT_CHAR
1371 #define US VIPS_FORMAT_USHORT
1372 #define S VIPS_FORMAT_SHORT
1373 #define UI VIPS_FORMAT_UINT
1374 #define I VIPS_FORMAT_INT
1375 #define F VIPS_FORMAT_FLOAT
1376 #define X VIPS_FORMAT_COMPLEX
1377 #define D VIPS_FORMAT_DOUBLE
1378 #define DX VIPS_FORMAT_DPCOMPLEX
1379 static int bandfmt_dz[10] = {
1380 <a name="4"></a>   UC, C,  US, S,  UI, I,  F,  F,  D,  D
1381 };
1382 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static const char *dz_suffs[] = { ".dz", NULL };
1383 static void
1384 vips_foreign_save_dz_class_init( VipsForeignSaveDzClass *class )
1385 {
1386 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
1387 	VipsObjectClass *object_class = (VipsObjectClass *) class;
1388 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
1389 	VipsForeignSaveClass *save_class = (VipsForeignSaveClass *) class;
1390 	gobject_class-&gt;dispose = vips_foreign_save_dz_dispose;
1391 	gobject_class-&gt;set_property = vips_object_set_property;
1392 	gobject_class-&gt;get_property = vips_object_get_property;
1393 	object_class-&gt;nickname = "dzsave_base";
1394 	object_class-&gt;description = _( "save image to deep zoom format" );
1395 	object_class-&gt;build = vips_foreign_save_dz_build;
1396 	foreign_class-&gt;suffs = dz_suffs;
1397 	save_class-&gt;saveable = VIPS_SAVEABLE_ANY;</b></font>
1398 <a name="5"></a>	save_class-&gt;format_table = bandfmt_dz;
1399 	save_class-&gt;coding[VIPS_CODING_LABQ] = TRUE;
1400 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	VIPS_ARG_STRING( class, "basename", 2, 
1401 		_( "Base name" ),
1402 		_( "Base name to save to" ),
1403 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1404 		G_STRUCT_OFFSET( VipsForeignSaveDz, basename ),
1405 		NULL );
1406 	VIPS_ARG_ENUM( class, "layout", 8, 
1407 		_( "Layout" ), 
1408 		_( "Directory layout" ),
1409 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1410 		G_STRUCT_OFFSET( VipsForeignSaveDz, layout ),
1411 		VIPS_TYPE_FOREIGN_DZ_LAYOUT, VIPS_FOREIGN_DZ_LAYOUT_DZ ); 
1412 	VIPS_ARG_STRING( class, "suffix", 9, 
1413 		_( "suffix" ), 
1414 		_( "Filename suffix for tiles" ),
1415 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1416 		G_STRUCT_OFFSET( VipsForeignSaveDz, suffix ),
1417 		".jpeg" );
1418 	VIPS_ARG_INT( class, "overlap", 10, 
1419 		_( "Overlap" ), 
1420 		_( "Tile overlap in pixels" ),
1421 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1422 		G_STRUCT_OFFSET( VipsForeignSaveDz, overlap ),
1423 		0, 8192, 1 );
1424 	VIPS_ARG_INT( class, "tile_size", 11, 
1425 		_( "Tile size" ), 
1426 		_( "Tile size in pixels" ),
1427 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1428 		G_STRUCT_OFFSET( VipsForeignSaveDz, tile_size ),
1429 		1, 8192, 254 );
1430 	VIPS_ARG_ENUM( class, "depth", 13, 
1431 		_( "Depth" ), 
1432 		_( "Pyramid depth" ),
1433 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1434 		G_STRUCT_OFFSET( VipsForeignSaveDz, depth ),
1435 		VIPS_TYPE_FOREIGN_DZ_DEPTH, VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL ); 
1436 	VIPS_ARG_BOOL( class, "centre", 13, 
1437 		_( "Center" ), 
1438 		_( "Center image in tile" ),
1439 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1440 		G_STRUCT_OFFSET( VipsForeignSaveDz, centre ),
1441 		FALSE );
1442 	VIPS_ARG_ENUM( class, "angle", 14, 
1443 		_( "Angle" ), 
1444 		_( "Rotate image during save" ),
1445 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1446 		G_STRUCT_OFFSET( VipsForeignSaveDz, angle ),
1447 		VIPS_TYPE_ANGLE, VIPS_ANGLE_D0 ); 
1448 	VIPS_ARG_ENUM( class, "container", 15, 
1449 		_( "Container" ), 
1450 		_( "Pyramid container type" ),
1451 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1452 		G_STRUCT_OFFSET( VipsForeignSaveDz, container ),
1453 		VIPS_TYPE_FOREIGN_DZ_CONTAINER, VIPS_FOREIGN_DZ_CONTAINER_FS ); 
1454 	VIPS_ARG_BOOL( class, "properties", 16, 
1455 		_( "Properties" ), 
1456 		_( "Write a properties file to the output directory" ),
1457 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1458 		G_STRUCT_OFFSET( VipsForeignSaveDz, properties ),
1459 		FALSE );
1460 	VIPS_ARG_INT( class, "compression", 17, 
1461 		_( "Compression" ), 
1462 		_( "ZIP deflate compression level" ),
1463 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1464 		G_STRUCT_OFFSET( VipsForeignSaveDz, compression ),
1465 		-1, 9, 0 );
1466 	VIPS_ARG_ENUM( class, "region_shrink", 18, 
1467 		_( "Region shrink" ), 
1468 		_( "Method to shrink regions" ),
1469 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1470 		G_STRUCT_OFFSET( VipsForeignSaveDz, region_shrink ),
1471 		VIPS_TYPE_REGION_SHRINK, VIPS_REGION_SHRINK_MEAN ); 
1472 	VIPS_ARG_INT( class, "skip_blanks", 19, 
1473 		_( "Skip blanks" ), 
1474 		_( "Skip tiles which are nearly equal to the background" ),
1475 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1476 		G_STRUCT_OFFSET( VipsForeignSaveDz, skip_blanks ),
1477 		-1, 65535, -1 );
1478 	VIPS_ARG_BOOL( class, "no_strip", 20, 
1479 		_( "No strip" ), 
1480 		_( "Don't strip tile metadata" ),
1481 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1482 		G_STRUCT_OFFSET( VipsForeignSaveDz, no_strip ),
1483 		FALSE );
1484 	VIPS_ARG_STRING( class, "id", 21, 
1485 		_( "id" ), 
1486 		_( "Resource ID" ),
1487 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1488 		G_STRUCT_OFFSET( VipsForeignSaveDz, id ),
1489 		"https://example.com/iiif" );
1490 	VIPS_ARG_STRING( class, "dirname", 1, </b></font>
1491 		_( "Directory name" ),
1492 		_( "Directory name to save to" ),
1493 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
1494 		G_STRUCT_OFFSET( VipsForeignSaveDz, dirname ),
1495 		NULL );
1496 	VIPS_ARG_INT( class, "tile_width", 12, 
1497 		_( "Tile width" ), 
1498 		_( "Tile width in pixels" ),
1499 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
1500 		G_STRUCT_OFFSET( VipsForeignSaveDz, tile_size ),
1501 		1, 8192, 254 );
1502 	VIPS_ARG_INT( class, "tile_height", 12, 
1503 		_( "Tile height" ), 
1504 		_( "Tile height in pixels" ),
1505 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
1506 		G_STRUCT_OFFSET( VipsForeignSaveDz, tile_size ),
1507 		1, 8192, 254 );
1508 }
1509 static void
1510 <a name="3"></a>vips_foreign_save_dz_init( VipsForeignSaveDz *dz )
1511 {
1512 	VIPS_SETSTR( dz-&gt;suffix, ".jpeg" );
1513 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	dz-&gt;layout = VIPS_FOREIGN_DZ_LAYOUT_DZ; 
1514 	dz-&gt;overlap = 1;
1515 	dz-&gt;tile_size = 254;
1516 	dz-&gt;tile_count = 0;
1517 	dz-&gt;depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL; 
1518 	dz-&gt;angle = VIPS_ANGLE_D0; 
1519 	dz-&gt;container = VIPS_FOREIGN_DZ_CONTAINER_FS; 
1520 	dz-&gt;compression = 0;
1521 	dz-&gt;region_shrink = VIPS_REGION_SHRINK_MEAN;
1522 	dz-&gt;skip_blanks = -1;
1523 }
1524 typedef struct _VipsForeignSaveDzFile {
1525 	VipsForeignSaveDz parent_object;
1526 	char *filename; 
1527 } VipsForeignSaveDzFile;
1528 typedef VipsForeignSaveDzClass VipsForeignSaveDzFileClass;
1529 G_DEFINE_TYPE( VipsForeignSaveDzFile, vips_foreign_save_dz_file, 
1530 	vips_foreign_save_dz_get_type() );
1531 static int
1532 vips_foreign_save_dz_file_build( VipsObject *object )
1533 {
1534 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) object;
1535 	VipsForeignSaveDzFile *file = (VipsForeignSaveDzFile *) object;</b></font>
1536 	char *p;
1537 	if( !vips_object_argument_isset( object, "basename" ) ) 
1538 		dz-&gt;basename = g_path_get_basename( file-&gt;filename ); 
1539 	if( !vips_object_argument_isset( object, "dirname" ) ) 
1540 		dz-&gt;dirname = g_path_get_dirname( file-&gt;filename ); 
1541 	if( (p = (char *) vips__find_rightmost_brackets( dz-&gt;basename )) )
1542 		*p = '\0';
1543 	if( (p = strrchr( dz-&gt;basename, '.' )) ) {
1544 		if( !vips_object_argument_isset( object, "container" ) ) {
1545 			if( strcasecmp( p + 1, "zip" ) == 0 )
1546 				dz-&gt;container = VIPS_FOREIGN_DZ_CONTAINER_ZIP;
1547 			if( strcasecmp( p + 1, "szi" ) == 0 ) 
1548 				dz-&gt;container = VIPS_FOREIGN_DZ_CONTAINER_SZI;
1549 		}
1550 		if( g_ascii_strcasecmp( p + 1, "zip" ) == 0 ||
1551 			g_ascii_strcasecmp( p + 1, "szi" ) == 0 || 
1552 			g_ascii_strcasecmp( p + 1, "dz" ) == 0 )
1553 <a name="0"></a>			*p = '\0';
1554 	}
1555 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if( VIPS_OBJECT_CLASS( vips_foreign_save_dz_file_parent_class )-&gt;
1556 		build( object ) )
1557 		return( -1 );
1558 	return( 0 );
1559 }
1560 static void
1561 vips_foreign_save_dz_file_class_init( VipsForeignSaveDzFileClass *class )
1562 {
1563 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
1564 	VipsObjectClass *object_class = (VipsObjectClass *) class;
1565 	gobject_class-&gt;set_property = vips_object_set_property;
1566 	gobject_class-&gt;get_property = vips_object_get_property;
1567 	object_class-&gt;nickname = "dzsave";
1568 	object_class-&gt;description = _( "save image to deepzoom file" );
1569 	object_class-&gt;build = vips_foreign_save_dz_file_build;
1570 	VIPS_ARG_STRING( class, "filename", 1, 
1571 		_( "Filename" ),
1572 		_( "Filename to save to" ),
1573 		VIPS_ARGUMENT_REQUIRED_INPUT, 
1574 		G_STRUCT_OFFSET( VipsForeignSaveDzFile, filename ),
1575 		NULL );
1576 }
1577 static void
1578 vips_foreign_save_dz_file_init( VipsForeignSaveDzFile *file )
1579 {
1580 }
1581 typedef struct _VipsForeignSaveDzBuffer {
1582 	VipsForeignSaveDz parent_object;
1583 	VipsArea *buf;
1584 } VipsForeignSaveDzBuffer;
1585 typedef VipsForeignSaveDzClass VipsForeignSaveDzBufferClass;
1586 G_DEFINE_TYPE( VipsForeignSaveDzBuffer, vips_foreign_save_dz_buffer, 
1587 	vips_foreign_save_dz_get_type() );
1588 static int
1589 vips_foreign_save_dz_buffer_build( VipsObject *object )
1590 {
1591 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) object;</b></font>
1592 	void *obuf;
1593 	size_t olen;
1594 	VipsBlob *blob;
1595 	if( !vips_object_argument_isset( object, "basename" ) ) 
1596 		dz-&gt;basename = g_strdup( "untitled" ); 
1597 	if( VIPS_OBJECT_CLASS( vips_foreign_save_dz_buffer_parent_class )-&gt;
1598 		build( object ) )
1599 		return( -1 );
1600 	g_assert( GSF_IS_OUTPUT_MEMORY( dz-&gt;out ) );
1601 	olen = gsf_output_size( GSF_OUTPUT( dz-&gt;out ) ); 
1602 	if( !(obuf = g_try_malloc( olen )) ) {
1603 		vips_error( "vips_tracked", 
1604 			_( "out of memory --- size == %dMB" ), 
1605 			(int) (olen / (1024.0 * 1024.0))  );
1606 		return( -1 );
1607 	}
1608 	memcpy( obuf, 
1609 <a name="2"></a>		gsf_output_memory_get_bytes( GSF_OUTPUT_MEMORY( dz-&gt;out ) ),
1610 		olen ); 
1611 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	blob = vips_blob_new( (VipsCallbackFn) vips_area_free_cb, obuf, olen );
1612 	g_object_set( object, "buffer", blob, NULL );
1613 	vips_area_unref( VIPS_AREA( blob ) );
1614 	return( 0 );
1615 }
1616 static void
1617 vips_foreign_save_dz_buffer_class_init( VipsForeignSaveDzBufferClass *class )
1618 {
1619 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
1620 	VipsObjectClass *object_class = (VipsObjectClass *) class;
1621 	gobject_class-&gt;set_property = vips_object_set_property;
1622 	gobject_class-&gt;get_property = vips_object_get_property;
1623 	object_class-&gt;nickname = "dzsave_buffer";
1624 	object_class-&gt;description = _( "save image to dz buffer" );
1625 	object_class-&gt;build = vips_foreign_save_dz_buffer_build;
1626 	VIPS_ARG_BOXED( class, "buffer", 1, 
1627 		_( "Buffer" ),
1628 		_( "Buffer to save to" ),
1629 		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
1630 		G_STRUCT_OFFSET( VipsForeignSaveDzBuffer, buf ),
1631 		VIPS_TYPE_BLOB );
1632 }
1633 static void
1634 vips_foreign_save_dz_buffer_init( VipsForeignSaveDzBuffer *buffer )
1635 {</b></font>
1636 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) buffer;
1637 	dz-&gt;container = VIPS_FOREIGN_DZ_CONTAINER_ZIP;
1638 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
1639 int
1640 vips_dzsave( VipsImage *in, const char *name, ... )
1641 {
1642 	va_list ap;
1643 	int result;
1644 	va_start( ap, name );
1645 	result = vips_call_split( "dzsave", ap, in, name ); 
1646 	va_end( ap );
1647 	return( result );
1648 }
1649 int
1650 vips_dzsave_buffer( VipsImage *in, void **buf, size_t *len, ... )
1651 {
1652 	va_list ap;
1653 	VipsArea *area;
1654 	int result;
1655 	area = NULL; 
1656 	va_start( ap, len );
1657 	result = vips_call_split( "dzsave_buffer", ap, in, &amp;area );
1658 	va_end( ap );
1659 	if( !result &amp;&amp;
1660 		area ) { 
1661 		if( buf ) {
1662 			*buf = area-&gt;data;
1663 			area-&gt;free_fn = NULL;
1664 		}
1665 		if( len ) 
1666 			*len = area-&gt;length;
1667 		vips_area_unref( area );
1668 	}
1669 	return( result );
1670 }</b></font>
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
