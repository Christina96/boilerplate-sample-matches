
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.6981132075471699%, Tokens: 9</h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ecb_encrypt.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_ECB_MODE
3  int ecb_encrypt(const unsigned char *pt, unsigned char *ct, unsigned long len, symmetric_ECB *ecb)
4  {
5     int err;
6     LTC_ARGCHK(pt != NULL);
7     LTC_ARGCHK(ct != NULL);
8     LTC_ARGCHK(ecb != NULL);
<span onclick='openModal()' class='match'>9     if ((err = cipher_is_valid(ecb->cipher)) != CRYPT_OK) {
10         return err;
11     }
12     if (len % cipher_descriptor[ecb->cipher].block_length) {
13        return CRYPT_INVALID_ARG;
14     }
15     if (cipher_descriptor[ecb->cipher].accel_ecb_encrypt != NULL) {
</span>16        return cipher_descriptor[ecb->cipher].accel_ecb_encrypt(pt, ct, len / cipher_descriptor[ecb->cipher].block_length, &ecb->key);
17     }
18     while (len) {
19        if ((err = cipher_descriptor[ecb->cipher].ecb_encrypt(pt, ct, &ecb->key)) != CRYPT_OK) {
20           return err;
21        }
22        pt  += cipher_descriptor[ecb->cipher].block_length;
23        ct  += cipher_descriptor[ecb->cipher].block_length;
24        len -= cipher_descriptor[ecb->cipher].block_length;
25     }
26     return CRYPT_OK;
27  }
28  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-dag.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include <sys/param.h>			&bsol;* optionally get BSD define */
5  #include <stdlib.h>
6  #include <string.h>
7  #include <errno.h>
8  #include "pcap-int.h"
9  #include <netinet/in.h>
10  #include <sys/mman.h>
11  #include <sys/socket.h>
12  #include <sys/types.h>
13  #include <unistd.h>
14  struct mbuf;		&bsol;* Squelch compiler warnings on some platforms for */
15  struct rtentry;		&bsol;* declarations in <net/if.h> */
16  #include <net/if.h>
17  #include "dagnew.h"
18  #include "dagapi.h"
19  #include "dagpci.h"
20  #include "dag_config_api.h"
21  #include "pcap-dag.h"
22  #ifndef DAG_MAX_BOARDS
23  #define DAG_MAX_BOARDS 32
24  #endif
25  #ifndef ERF_TYPE_AAL5
26  #define ERF_TYPE_AAL5               4
27  #endif
28  #ifndef ERF_TYPE_MC_HDLC
29  #define ERF_TYPE_MC_HDLC            5
30  #endif
31  #ifndef ERF_TYPE_MC_RAW
32  #define ERF_TYPE_MC_RAW             6
33  #endif
34  #ifndef ERF_TYPE_MC_ATM
35  #define ERF_TYPE_MC_ATM             7
36  #endif
37  #ifndef ERF_TYPE_MC_RAW_CHANNEL
38  #define ERF_TYPE_MC_RAW_CHANNEL     8
39  #endif
40  #ifndef ERF_TYPE_MC_AAL5
41  #define ERF_TYPE_MC_AAL5            9
42  #endif
43  #ifndef ERF_TYPE_COLOR_HDLC_POS
44  #define ERF_TYPE_COLOR_HDLC_POS     10
45  #endif
46  #ifndef ERF_TYPE_COLOR_ETH
47  #define ERF_TYPE_COLOR_ETH          11
48  #endif
49  #ifndef ERF_TYPE_MC_AAL2
50  #define ERF_TYPE_MC_AAL2            12
51  #endif
52  #ifndef ERF_TYPE_IP_COUNTER
53  #define ERF_TYPE_IP_COUNTER         13
54  #endif
55  #ifndef ERF_TYPE_TCP_FLOW_COUNTER
56  #define ERF_TYPE_TCP_FLOW_COUNTER   14
57  #endif
58  #ifndef ERF_TYPE_DSM_COLOR_HDLC_POS
59  #define ERF_TYPE_DSM_COLOR_HDLC_POS 15
60  #endif
61  #ifndef ERF_TYPE_DSM_COLOR_ETH
62  #define ERF_TYPE_DSM_COLOR_ETH      16
63  #endif
64  #ifndef ERF_TYPE_COLOR_MC_HDLC_POS
65  #define ERF_TYPE_COLOR_MC_HDLC_POS  17
66  #endif
67  #ifndef ERF_TYPE_AAL2
68  #define ERF_TYPE_AAL2               18
69  #endif
70  #ifndef ERF_TYPE_COLOR_HASH_POS
71  #define ERF_TYPE_COLOR_HASH_POS     19
72  #endif
73  #ifndef ERF_TYPE_COLOR_HASH_ETH
74  #define ERF_TYPE_COLOR_HASH_ETH     20
75  #endif
76  #ifndef ERF_TYPE_INFINIBAND
77  #define ERF_TYPE_INFINIBAND         21
78  #endif
79  #ifndef ERF_TYPE_IPV4
80  #define ERF_TYPE_IPV4               22
81  #endif
82  #ifndef ERF_TYPE_IPV6
83  #define ERF_TYPE_IPV6               23
84  #endif
85  #ifndef ERF_TYPE_RAW_LINK
86  #define ERF_TYPE_RAW_LINK           24
87  #endif
88  #ifndef ERF_TYPE_INFINIBAND_LINK
89  #define ERF_TYPE_INFINIBAND_LINK    25
90  #endif
91  #ifndef ERF_TYPE_META
92  #define ERF_TYPE_META               27
93  #endif
94  #ifndef ERF_TYPE_PAD
95  #define ERF_TYPE_PAD                48
96  #endif
97  #define ATM_CELL_SIZE		52
98  #define ATM_HDR_SIZE		4
99  #define MTP2_SENT_OFFSET		0	&bsol;* 1 byte */
100  #define MTP2_ANNEX_A_USED_OFFSET	1	&bsol;* 1 byte */
101  #define MTP2_LINK_NUMBER_OFFSET		2	&bsol;* 2 bytes */
102  #define MTP2_HDR_LEN			4	&bsol;* length of the header */
103  #define MTP2_ANNEX_A_NOT_USED      0
104  #define MTP2_ANNEX_A_USED          1
105  #define MTP2_ANNEX_A_USED_UNKNOWN  2
106  struct sunatm_hdr {
107  	unsigned char	flags;		&bsol;* destination and traffic type */
108  	unsigned char	vpi;		&bsol;* VPI */
109  	unsigned short	vci;		&bsol;* VCI */
110  };
111  struct pcap_dag {
112  	struct pcap_stat stat;
113  	u_char	*dag_mem_bottom;	&bsol;* DAG card current memory bottom pointer */
114  	u_char	*dag_mem_top;	&bsol;* DAG card current memory top pointer */
115  	int	dag_fcs_bits;	&bsol;* Number of checksum bits from link layer */
116  	int	dag_flags;	&bsol;* Flags */
117  	int	dag_stream;	&bsol;* DAG stream number */
118  	int	dag_timeout;	&bsol;* timeout specified to pcap_open_live.
119  				 * Same as in linux above, introduce
120  				 * generally? */
121  	dag_card_ref_t dag_ref; &bsol;* DAG Configuration/Status API card reference */
122  	dag_component_t dag_root;	&bsol;* DAG CSAPI Root component */
123  	attr_uuid_t drop_attr;  &bsol;* DAG Stream Drop Attribute handle, if available */
124  	struct timeval required_select_timeout;
125  };
126  typedef struct pcap_dag_node {
127  	struct pcap_dag_node *next;
128  	pcap_t *p;
129  	pid_t pid;
130  } pcap_dag_node_t;
131  static pcap_dag_node_t *pcap_dags = NULL;
132  static int atexit_handler_installed = 0;
133  static const unsigned short endian_test_word = 0x0100;
134  #define IS_BIGENDIAN() (*((unsigned char *)&endian_test_word))
135  #define MAX_DAG_PACKET 65536
136  static unsigned char TempPkt[MAX_DAG_PACKET];
137  #ifndef HAVE_DAG_LARGE_STREAMS_API
138  #define dag_attach_stream64(a, b, c, d) dag_attach_stream(a, b, c, d)
139  #define dag_get_stream_poll64(a, b, c, d, e) dag_get_stream_poll(a, b, c, d, e)
140  #define dag_set_stream_poll64(a, b, c, d, e) dag_set_stream_poll(a, b, c, d, e)
141  #define dag_size_t uint32_t
142  #endif
143  static int dag_stats(pcap_t *p, struct pcap_stat *ps);
144  static int dag_set_datalink(pcap_t *p, int dlt);
145  static int dag_get_datalink(pcap_t *p);
146  static int dag_setnonblock(pcap_t *p, int nonblock);
147  static void
148  delete_pcap_dag(const pcap_t *p)
149  {
150  	pcap_dag_node_t *curr = NULL, *prev = NULL;
151  	for (prev = NULL, curr = pcap_dags; curr != NULL && curr->p != p; prev = curr, curr = curr->next) {
152  	}
153  	if (curr != NULL && curr->p == p) {
154  		if (prev != NULL) {
155  			prev->next = curr->next;
156  		} else {
157  			pcap_dags = curr->next;
158  		}
159  	}
160  }
161  static void
162  dag_platform_cleanup(pcap_t *p)
163  {
164  	struct pcap_dag *pd = p->priv;
165  	if(dag_stop_stream(p->fd, pd->dag_stream) < 0)
166  		fprintf(stderr,"dag_stop_stream: %s\n", strerror(errno));
167  	if(dag_detach_stream(p->fd, pd->dag_stream) < 0)
168  		fprintf(stderr,"dag_detach_stream: %s\n", strerror(errno));
169  	if(pd->dag_ref != NULL) {
170  		dag_config_dispose(pd->dag_ref);
171  		p->fd = -1;
172  		pd->dag_ref = NULL;
173  	}
174  	delete_pcap_dag(p);
175  	pcap_cleanup_live_common(p);
176  }
177  static void
178  atexit_handler(void)
179  {
180  	while (pcap_dags != NULL) {
181  		if (pcap_dags->pid == getpid()) {
182  			if (pcap_dags->p != NULL)
183  				dag_platform_cleanup(pcap_dags->p);
184  		} else {
185  			delete_pcap_dag(pcap_dags->p);
186  		}
187  	}
188  }
189  static int
190  new_pcap_dag(pcap_t *p)
191  {
192  	pcap_dag_node_t *node = NULL;
193  	if ((node = malloc(sizeof(pcap_dag_node_t))) == NULL) {
194  		return -1;
195  	}
196  	if (!atexit_handler_installed) {
197  		atexit(atexit_handler);
198  		atexit_handler_installed = 1;
199  	}
200  	node->next = pcap_dags;
201  	node->p = p;
202  	node->pid = getpid();
203  	pcap_dags = node;
204  	return 0;
205  }
206  static unsigned int
207  dag_erf_ext_header_count(const uint8_t *erf, size_t len)
208  {
209  	uint32_t hdr_num = 0;
210  	uint8_t  hdr_type;
211  	if ( erf == NULL )
212  		return 0;
213  	if ( len < 16 )
214  		return 0;
215  	if ( (erf[8] & 0x80) == 0x00 )
216  		return 0;
217  	do {
218  		if ( len < (24 + (hdr_num * 8)) )
219  			return hdr_num;
220  		hdr_type = erf[(16 + (hdr_num * 8))];
221  		hdr_num++;
222  	} while ( hdr_type & 0x80 );
223  	return hdr_num;
224  }
225  static int
226  dag_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
227  {
228  	struct pcap_dag *pd = p->priv;
229  	unsigned int processed = 0;
230  	unsigned int nonblocking = pd->dag_flags & DAGF_NONBLOCK;
231  	unsigned int num_ext_hdr = 0;
232  	unsigned int ticks_per_second;
233  	while (pd->dag_mem_top - pd->dag_mem_bottom < dag_record_size) {
234  		if (p->break_loop) {
235  			p->break_loop = 0;
236  			return -2;
237  		}
<span onclick='openModal()' class='match'>238  		if ( NULL == (pd->dag_mem_top = dag_advance_stream(p->fd, pd->dag_stream, &(pd->dag_mem_bottom))) ) {
239  		     return -1;
240  		}
241  		if (nonblocking && (pd->dag_mem_top - pd->dag_mem_bottom < dag_record_size))
242  		{
243  			return 0;
244  		}
245  		if(!nonblocking &&
</span>246  		   pd->dag_timeout &&
247  		   (pd->dag_mem_top - pd->dag_mem_bottom < dag_record_size))
248  		{
249  			return 0;
250  		}
251  	}
252  	while (pd->dag_mem_top - pd->dag_mem_bottom >= dag_record_size) {
253  		unsigned short packet_len = 0;
254  		int caplen = 0;
255  		struct pcap_pkthdr	pcap_header;
256  		dag_record_t *header = (dag_record_t *)(pd->dag_mem_bottom);
257  		u_char *dp = ((u_char *)header); &bsol;* + dag_record_size; */
258  		unsigned short rlen;
259  		if (p->break_loop) {
260  			p->break_loop = 0;
261  			return -2;
262  		}
263  		rlen = ntohs(header->rlen);
264  		if (rlen < dag_record_size)
265  		{
266  			pcap_strlcpy(p->errbuf, "dag_read: record too small",
267  			    PCAP_ERRBUF_SIZE);
268  			return -1;
269  		}
270  		pd->dag_mem_bottom += rlen;
271  		switch((header->type & 0x7f)) {
272  		case ERF_TYPE_COLOR_HDLC_POS:
273  		case ERF_TYPE_COLOR_ETH:
274  		case ERF_TYPE_DSM_COLOR_HDLC_POS:
275  		case ERF_TYPE_DSM_COLOR_ETH:
276  		case ERF_TYPE_COLOR_MC_HDLC_POS:
277  		case ERF_TYPE_COLOR_HASH_ETH:
278  		case ERF_TYPE_COLOR_HASH_POS:
279  			break;
280  		default:
281  			if ( (pd->drop_attr == kNullAttributeUuid) && (header->lctr) ) {
282  				pd->stat.ps_drop += ntohs(header->lctr);
283  			}
284  		}
285  		if ((header->type & 0x7f) == ERF_TYPE_PAD) {
286  			continue;
287  		}
288  		num_ext_hdr = dag_erf_ext_header_count(dp, rlen);
289  		if (p->linktype == DLT_ERF) {
290  			packet_len = ntohs(header->wlen) + dag_record_size;
291  			caplen = rlen;
292  			switch ((header->type & 0x7f)) {
293  			case ERF_TYPE_MC_AAL5:
294  			case ERF_TYPE_MC_ATM:
295  			case ERF_TYPE_MC_HDLC:
296  			case ERF_TYPE_MC_RAW_CHANNEL:
297  			case ERF_TYPE_MC_RAW:
298  			case ERF_TYPE_MC_AAL2:
299  			case ERF_TYPE_COLOR_MC_HDLC_POS:
300  				packet_len += 4; &bsol;* MC header */
301  				break;
302  			case ERF_TYPE_COLOR_HASH_ETH:
303  			case ERF_TYPE_DSM_COLOR_ETH:
304  			case ERF_TYPE_COLOR_ETH:
305  			case ERF_TYPE_ETH:
306  				packet_len += 2; &bsol;* ETH header */
307  				break;
308  			} &bsol;* switch type */
309  			packet_len += (8 * num_ext_hdr);
310  			if (caplen > packet_len) {
311  				caplen = packet_len;
312  			}
313  		} else {
314  			dp += dag_record_size;
315  			dp += 8 * num_ext_hdr;
316  			switch((header->type & 0x7f)) {
317  			case ERF_TYPE_ATM:
318  			case ERF_TYPE_AAL5:
319  				if ((header->type & 0x7f) == ERF_TYPE_AAL5) {
320  					packet_len = ntohs(header->wlen);
321  					caplen = rlen - dag_record_size;
322  				}
323  			case ERF_TYPE_MC_ATM:
324  				if ((header->type & 0x7f) == ERF_TYPE_MC_ATM) {
325  					caplen = packet_len = ATM_CELL_SIZE;
326  					dp+=4;
327  				}
328  			case ERF_TYPE_MC_AAL5:
329  				if ((header->type & 0x7f) == ERF_TYPE_MC_AAL5) {
330  					packet_len = ntohs(header->wlen);
331  					caplen = rlen - dag_record_size - 4;
332  					dp+=4;
333  				}
334  				caplen -= (8 * num_ext_hdr);
335  				if ((header->type & 0x7f) == ERF_TYPE_ATM) {
336  					caplen = packet_len = ATM_CELL_SIZE;
337  				}
338  				if (p->linktype == DLT_SUNATM) {
339  					struct sunatm_hdr *sunatm = (struct sunatm_hdr *)dp;
340  					unsigned long rawatm;
341  					rawatm = ntohl(*((unsigned long *)dp));
342  					sunatm->vci = htons((rawatm >>  4) & 0xffff);
343  					sunatm->vpi = (rawatm >> 20) & 0x00ff;
344  					sunatm->flags = ((header->flags.iface & 1) ? 0x80 : 0x00) |
345  						((sunatm->vpi == 0 && sunatm->vci == htons(5)) ? 6 :
346  						 ((sunatm->vpi == 0 && sunatm->vci == htons(16)) ? 5 :
347  						  ((dp[ATM_HDR_SIZE] == 0xaa &&
348  						    dp[ATM_HDR_SIZE+1] == 0xaa &&
349  						    dp[ATM_HDR_SIZE+2] == 0x03) ? 2 : 1)));
350  				} else if (p->linktype == DLT_ATM_RFC1483) {
351  					packet_len -= ATM_HDR_SIZE;
352  					caplen -= ATM_HDR_SIZE;
353  					dp += ATM_HDR_SIZE;
354  				} else
355  					continue;
356  				break;
357  			case ERF_TYPE_COLOR_HASH_ETH:
358  			case ERF_TYPE_DSM_COLOR_ETH:
359  			case ERF_TYPE_COLOR_ETH:
360  			case ERF_TYPE_ETH:
361  				if ((p->linktype != DLT_EN10MB) &&
362  				    (p->linktype != DLT_DOCSIS))
363  					continue;
364  				packet_len = ntohs(header->wlen);
365  				packet_len -= (pd->dag_fcs_bits >> 3);
366  				caplen = rlen - dag_record_size - 2;
367  				caplen -= (8 * num_ext_hdr);
368  				if (caplen > packet_len) {
369  					caplen = packet_len;
370  				}
371  				dp += 2;
372  				break;
373  			case ERF_TYPE_COLOR_HASH_POS:
374  			case ERF_TYPE_DSM_COLOR_HDLC_POS:
375  			case ERF_TYPE_COLOR_HDLC_POS:
376  			case ERF_TYPE_HDLC_POS:
377  				if ((p->linktype != DLT_CHDLC) &&
378  				    (p->linktype != DLT_PPP_SERIAL) &&
379  				    (p->linktype != DLT_FRELAY))
380  					continue;
381  				packet_len = ntohs(header->wlen);
382  				packet_len -= (pd->dag_fcs_bits >> 3);
383  				caplen = rlen - dag_record_size;
384  				caplen -= (8 * num_ext_hdr);
385  				if (caplen > packet_len) {
386  					caplen = packet_len;
387  				}
388  				break;
389  			case ERF_TYPE_COLOR_MC_HDLC_POS:
390  			case ERF_TYPE_MC_HDLC:
391  				if ((p->linktype != DLT_CHDLC) &&
392  				    (p->linktype != DLT_PPP_SERIAL) &&
393  				    (p->linktype != DLT_FRELAY) &&
394  				    (p->linktype != DLT_MTP2) &&
395  				    (p->linktype != DLT_MTP2_WITH_PHDR) &&
396  				    (p->linktype != DLT_LAPD))
397  					continue;
398  				packet_len = ntohs(header->wlen);
399  				packet_len -= (pd->dag_fcs_bits >> 3);
400  				caplen = rlen - dag_record_size - 4;
401  				caplen -= (8 * num_ext_hdr);
402  				if (caplen > packet_len) {
403  					caplen = packet_len;
404  				}
405  				dp += 4;
406  #ifdef DLT_MTP2_WITH_PHDR
407  				if (p->linktype == DLT_MTP2_WITH_PHDR) {
408  					caplen += MTP2_HDR_LEN;
409  					packet_len += MTP2_HDR_LEN;
410  					TempPkt[MTP2_SENT_OFFSET] = 0;
411  					TempPkt[MTP2_ANNEX_A_USED_OFFSET] = MTP2_ANNEX_A_USED_UNKNOWN;
412  					*(TempPkt+MTP2_LINK_NUMBER_OFFSET) = ((header->rec.mc_hdlc.mc_header>>16)&0x01);
413  					*(TempPkt+MTP2_LINK_NUMBER_OFFSET+1) = ((header->rec.mc_hdlc.mc_header>>24)&0xff);
414  					memcpy(TempPkt+MTP2_HDR_LEN, dp, caplen);
415  					dp = TempPkt;
416  				}
417  #endif
418  				break;
419  			case ERF_TYPE_IPV4:
420  				if ((p->linktype != DLT_RAW) &&
421  				    (p->linktype != DLT_IPV4))
422  					continue;
423  				packet_len = ntohs(header->wlen);
424  				caplen = rlen - dag_record_size;
425  				caplen -= (8 * num_ext_hdr);
426  				if (caplen > packet_len) {
427  					caplen = packet_len;
428  				}
429  				break;
430  			case ERF_TYPE_IPV6:
431  				if ((p->linktype != DLT_RAW) &&
432  				    (p->linktype != DLT_IPV6))
433  					continue;
434  				packet_len = ntohs(header->wlen);
435  				caplen = rlen - dag_record_size;
436  				caplen -= (8 * num_ext_hdr);
437  				if (caplen > packet_len) {
438  					caplen = packet_len;
439  				}
440  				break;
441  			case ERF_TYPE_MC_RAW:
442  			case ERF_TYPE_MC_RAW_CHANNEL:
443  			case ERF_TYPE_IP_COUNTER:
444  			case ERF_TYPE_TCP_FLOW_COUNTER:
445  			case ERF_TYPE_INFINIBAND:
446  			case ERF_TYPE_RAW_LINK:
447  			case ERF_TYPE_INFINIBAND_LINK:
448  			default:
449  				continue;
450  			} &bsol;* switch type */
451  		} &bsol;* ERF encapsulation */
452  		if (caplen > p->snapshot)
453  			caplen = p->snapshot;
454  		if ((p->fcode.bf_insns == NULL) || pcap_filter(p->fcode.bf_insns, dp, packet_len, caplen)) {
455  			register unsigned long long ts;
456  			if (IS_BIGENDIAN()) {
457  				ts = SWAPLL(header->ts);
458  			} else {
459  				ts = header->ts;
460  			}
461  			switch (p->opt.tstamp_precision) {
462  			case PCAP_TSTAMP_PRECISION_NANO:
463  				ticks_per_second = 1000000000;
464  				break;
465  			case PCAP_TSTAMP_PRECISION_MICRO:
466  			default:
467  				ticks_per_second = 1000000;
468  				break;
469  			}
470  			pcap_header.ts.tv_sec = ts >> 32;
471  			ts = (ts & 0xffffffffULL) * ticks_per_second;
472  			ts += 0x80000000; &bsol;* rounding */
473  			pcap_header.ts.tv_usec = ts >> 32;
474  			if (pcap_header.ts.tv_usec >= ticks_per_second) {
475  				pcap_header.ts.tv_usec -= ticks_per_second;
476  				pcap_header.ts.tv_sec++;
477  			}
478  			pcap_header.caplen = caplen;
479  			pcap_header.len = packet_len;
480  			pd->stat.ps_recv++;
481  			callback(user, &pcap_header, dp);
482  			processed++;
483  			if (processed == cnt && !PACKET_COUNT_IS_UNLIMITED(cnt))
484  			{
485  				return cnt;
486  			}
487  		}
488  	}
489  	return processed;
490  }
491  static int
492  dag_inject(pcap_t *p, const void *buf _U_, int size _U_)
493  {
494  	pcap_strlcpy(p->errbuf, "Sending packets isn't supported on DAG cards",
495  	    PCAP_ERRBUF_SIZE);
496  	return (-1);
497  }
498  static int dag_activate(pcap_t* p)
499  {
500  	struct pcap_dag *pd = p->priv;
501  	char *s;
502  	int n;
503  	daginf_t* daginf;
504  	char * newDev = NULL;
505  	char * device = p->opt.device;
506  	int ret;
507  	dag_size_t mindata;
508  	struct timeval maxwait;
509  	struct timeval poll;
510  	if (device == NULL) {
511  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "device is NULL");
512  		return PCAP_ERROR;
513  	}
514  	newDev = (char *)malloc(strlen(device) + 16);
515  	if (newDev == NULL) {
516  		ret = PCAP_ERROR;
517  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
518  		    errno, "Can't allocate string for device name");
519  		goto fail;
520  	}
521  	if (dag_parse_name(device, newDev, strlen(device) + 16, &pd->dag_stream) < 0) {
522  		ret = PCAP_ERROR;
523  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
524  		    errno, "dag_parse_name");
525  		goto fail;
526  	}
527  	device = newDev;
528  	if (pd->dag_stream%2) {
529  		ret = PCAP_ERROR;
530  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "dag_parse_name: tx (even numbered) streams not supported for capture");
531  		goto fail;
532  	}
533  	if((pd->dag_ref = dag_config_init((char *)device)) == NULL) {
534  		if (errno == ENOENT) {
535  			ret = PCAP_ERROR_NO_SUCH_DEVICE;
536  			p->errbuf[0] = '\0';
537  		} else if (errno == EPERM || errno == EACCES) {
538  			ret = PCAP_ERROR_PERM_DENIED;
539  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
540  			    "Attempt to open %s failed with %s - additional privileges may be required",
541  			    device, (errno == EPERM) ? "EPERM" : "EACCES");
542  		} else {
543  			ret = PCAP_ERROR;
544  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
545  			    errno, "dag_config_init %s", device);
546  		}
547  		goto fail;
548  	}
549  	if((p->fd = dag_config_get_card_fd(pd->dag_ref)) < 0) {
550  		ret = PCAP_ERROR;
551  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
552  		    errno, "dag_config_get_card_fd %s", device);
553  		goto failclose;
554  	}
555  	if (dag_attach_stream64(p->fd, pd->dag_stream, 0, 0) < 0) {
556  		ret = PCAP_ERROR;
557  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
558  		    errno, "dag_attach_stream");
559  		goto failclose;
560  	}
561  	pd->drop_attr = kNullAttributeUuid;
562  	pd->dag_root = dag_config_get_root_component(pd->dag_ref);
563  	if ( dag_component_get_subcomponent(pd->dag_root, kComponentStreamFeatures, 0) )
564  	{
565  		pd->drop_attr = dag_config_get_indexed_attribute_uuid(pd->dag_ref, kUint32AttributeStreamDropCount, pd->dag_stream/2);
566  	}
567  	if (dag_get_stream_poll64(p->fd, pd->dag_stream,
568  				&mindata, &maxwait, &poll) < 0) {
569  		ret = PCAP_ERROR;
570  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
571  		    errno, "dag_get_stream_poll");
572  		goto faildetach;
573  	}
574  	pd->required_select_timeout = poll;
575  	p->required_select_timeout = &pd->required_select_timeout;
576  	if (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)
577  		p->snapshot = MAXIMUM_SNAPLEN;
578  	if (p->opt.immediate) {
579  		mindata = 0;
580  	} else {
581  		mindata = 65536;
582  	}
583  	maxwait.tv_sec = p->opt.timeout/1000;
584  	maxwait.tv_usec = (p->opt.timeout%1000) * 1000;
585  	if (dag_set_stream_poll64(p->fd, pd->dag_stream,
586  				mindata, &maxwait, &poll) < 0) {
587  		ret = PCAP_ERROR;
588  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
589  		    errno, "dag_set_stream_poll");
590  		goto faildetach;
591  	}
592  #if 0
593  	if (p->snapshot == 0 || p->snapshot > MAX_DAG_SNAPLEN) {
594  		p->snapshot = MAX_DAG_SNAPLEN;
595  	} else if (snaplen < MIN_DAG_SNAPLEN) {
596  		p->snapshot = MIN_DAG_SNAPLEN;
597  	}
598  #endif
599  	if(dag_start_stream(p->fd, pd->dag_stream) < 0) {
600  		ret = PCAP_ERROR;
601  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
602  		    errno, "dag_start_stream %s", device);
603  		goto faildetach;
604  	}
605  	pd->dag_mem_bottom = 0;
606  	pd->dag_mem_top = 0;
607  	daginf = dag_info(p->fd);
608  	if ((0x4200 == daginf->device_code) || (0x4230 == daginf->device_code))	{
609  		pd->dag_fcs_bits = 0;
610  		p->linktype_ext = LT_FCS_DATALINK_EXT(0);
611  	} else {
612  		pd->dag_fcs_bits = 32;
613  		if ((s = getenv("ERF_FCS_BITS")) != NULL) {
614  			if ((n = atoi(s)) == 0 || n == 16 || n == 32) {
615  				pd->dag_fcs_bits = n;
616  			} else {
617  				ret = PCAP_ERROR;
618  				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
619  					"pcap_activate %s: bad ERF_FCS_BITS value (%d) in environment", device, n);
620  				goto failstop;
621  			}
622  		}
623  		if ((s = getenv("ERF_DONT_STRIP_FCS")) != NULL) {
624  			p->linktype_ext = LT_FCS_DATALINK_EXT(pd->dag_fcs_bits/16);
625  			pd->dag_fcs_bits = 0;
626  		}
627  	}
628  	pd->dag_timeout	= p->opt.timeout;
629  	p->linktype = -1;
630  	if (dag_get_datalink(p) < 0) {
631  		ret = PCAP_ERROR;
632  		goto failstop;
633  	}
634  	p->bufsize = 0;
635  	if (new_pcap_dag(p) < 0) {
636  		ret = PCAP_ERROR;
637  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
638  		    errno, "new_pcap_dag %s", device);
639  		goto failstop;
640  	}
641  	p->selectable_fd = -1;
642  	if (newDev != NULL) {
643  		free((char *)newDev);
644  	}
645  	p->read_op = dag_read;
646  	p->inject_op = dag_inject;
647  	p->setfilter_op = pcap_install_bpf_program;
648  	p->setdirection_op = NULL; &bsol;* Not implemented.*/
649  	p->set_datalink_op = dag_set_datalink;
650  	p->getnonblock_op = pcap_getnonblock_fd;
651  	p->setnonblock_op = dag_setnonblock;
652  	p->stats_op = dag_stats;
653  	p->cleanup_op = dag_platform_cleanup;
654  	pd->stat.ps_drop = 0;
655  	pd->stat.ps_recv = 0;
656  	pd->stat.ps_ifdrop = 0;
657  	return 0;
658  failstop:
659  	if (dag_stop_stream(p->fd, pd->dag_stream) < 0) {
660  		fprintf(stderr,"dag_stop_stream: %s\n", strerror(errno));
661  	}
662  faildetach:
663  	if (dag_detach_stream(p->fd, pd->dag_stream) < 0)
664  		fprintf(stderr,"dag_detach_stream: %s\n", strerror(errno));
665  failclose:
666  	dag_config_dispose(pd->dag_ref);
667  	p->fd = -1;
668  	pd->dag_ref = NULL;
669  	delete_pcap_dag(p);
670  fail:
671  	pcap_cleanup_live_common(p);
672  	if (newDev != NULL) {
673  		free((char *)newDev);
674  	}
675  	return ret;
676  }
677  pcap_t *dag_create(const char *device, char *ebuf, int *is_ours)
678  {
679  	const char *cp;
680  	char *cpend;
681  	long devnum;
682  	pcap_t *p;
683  	long stream = 0;
684  	cp = strrchr(device, '/');
685  	if (cp == NULL)
686  		cp = device;
687  	if (strncmp(cp, "dag", 3) != 0) {
688  		*is_ours = 0;
689  		return NULL;
690  	}
691  	cp += 3;
692  	devnum = strtol(cp, &cpend, 10);
693  	if (*cpend == ':') {
694  		stream = strtol(++cpend, &cpend, 10);
695  	}
696  	if (cpend == cp || *cpend != '\0') {
697  		*is_ours = 0;
698  		return NULL;
699  	}
700  	if (devnum < 0 || devnum >= DAG_MAX_BOARDS) {
701  		*is_ours = 0;
702  		return NULL;
703  	}
704  	if (stream <0 || stream >= DAG_STREAM_MAX) {
705  		*is_ours = 0;
706  		return NULL;
707  	}
708  	*is_ours = 1;
709  	p = PCAP_CREATE_COMMON(ebuf, struct pcap_dag);
710  	if (p == NULL)
711  		return NULL;
712  	p->activate_op = dag_activate;
713  	p->tstamp_precision_list = malloc(2 * sizeof(u_int));
714  	if (p->tstamp_precision_list == NULL) {
715  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
716  		    errno, "malloc");
717  		pcap_close(p);
718  		return NULL;
719  	}
720  	p->tstamp_precision_list[0] = PCAP_TSTAMP_PRECISION_MICRO;
721  	p->tstamp_precision_list[1] = PCAP_TSTAMP_PRECISION_NANO;
722  	p->tstamp_precision_count = 2;
723  	return p;
724  }
725  static int
726  dag_stats(pcap_t *p, struct pcap_stat *ps) {
727  	struct pcap_dag *pd = p->priv;
728  	uint32_t stream_drop;
729  	dag_err_t dag_error;
730  	if(pd->drop_attr != kNullAttributeUuid) {
731  		if ((dag_error = dag_config_get_uint32_attribute_ex(pd->dag_ref, pd->drop_attr, &stream_drop)) == kDagErrNone) {
732  			pd->stat.ps_drop = stream_drop;
733  		} else {
734  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "reading stream drop attribute: %s",
735  				 dag_config_strerror(dag_error));
736  			return -1;
737  		}
738  	}
739  	*ps = pd->stat;
740  	return 0;
741  }
742  int
743  dag_findalldevs(pcap_if_list_t *devlistp, char *errbuf)
744  {
745  	char name[12];	&bsol;* XXX - pick a size */
746  	int c;
747  	char dagname[DAGNAME_BUFSIZE];
748  	int dagstream;
749  	int dagfd;
750  	dag_card_inf_t *inf;
751  	char *description;
752  	int stream, rxstreams;
753  	for (c = 0; c < DAG_MAX_BOARDS; c++) {
754  		snprintf(name, 12, "dag%d", c);
755  		if (-1 == dag_parse_name(name, dagname, DAGNAME_BUFSIZE, &dagstream))
756  		{
757  			(void) snprintf(errbuf, PCAP_ERRBUF_SIZE,
758  			    "dag: device name %s can't be parsed", name);
759  			return (-1);
760  		}
761  		if ( (dagfd = dag_open(dagname)) >= 0 ) {
762  			description = NULL;
763  			if ((inf = dag_pciinfo(dagfd)))
764  				description = dag_device_name(inf->device_code, 1);
765  			if (pcap_add_dev(devlistp, name, 0, description, errbuf) == NULL) {
766  				return (-1);
767  			}
768  			rxstreams = dag_rx_get_stream_count(dagfd);
769  			for(stream=0;stream<DAG_STREAM_MAX;stream+=2) {
770  				if (0 == dag_attach_stream64(dagfd, stream, 0, 0)) {
771  					dag_detach_stream(dagfd, stream);
772  					snprintf(name,  10, "dag%d:%d", c, stream);
773  					if (pcap_add_dev(devlistp, name, 0, description, errbuf) == NULL) {
774  						return (-1);
775  					}
776  					rxstreams--;
777  					if(rxstreams <= 0) {
778  						break;
779  					}
780  				}
781  			}
782  			dag_close(dagfd);
783  		}
784  	}
785  	return (0);
786  }
787  static int
788  dag_set_datalink(pcap_t *p, int dlt)
789  {
790  	p->linktype = dlt;
791  	return (0);
792  }
793  static int
794  dag_setnonblock(pcap_t *p, int nonblock)
795  {
796  	struct pcap_dag *pd = p->priv;
797  	dag_size_t mindata;
798  	struct timeval maxwait;
799  	struct timeval poll;
800  	if (pcap_setnonblock_fd(p, nonblock) < 0)
801  		return (-1);
802  	if (dag_get_stream_poll64(p->fd, pd->dag_stream,
803  				&mindata, &maxwait, &poll) < 0) {
804  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
805  		    errno, "dag_get_stream_poll");
806  		return -1;
807  	}
808  	if(nonblock)
809  		mindata = 0;
810  	else
811  		mindata = 65536;
812  	if (dag_set_stream_poll64(p->fd, pd->dag_stream,
813  				mindata, &maxwait, &poll) < 0) {
814  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
815  		    errno, "dag_set_stream_poll");
816  		return -1;
817  	}
818  	if (nonblock) {
819  		pd->dag_flags |= DAGF_NONBLOCK;
820  	} else {
821  		pd->dag_flags &= ~DAGF_NONBLOCK;
822  	}
823  	return (0);
824  }
825  static int
826  dag_get_datalink(pcap_t *p)
827  {
828  	struct pcap_dag *pd = p->priv;
829  	int index=0, dlt_index=0;
830  	uint8_t types[255];
831  	memset(types, 0, 255);
832  	if (p->dlt_list == NULL && (p->dlt_list = malloc(255*sizeof(*(p->dlt_list)))) == NULL) {
833  		pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
834  		    errno, "malloc");
835  		return (-1);
836  	}
837  	p->linktype = 0;
838  #ifdef HAVE_DAG_GET_STREAM_ERF_TYPES
839  	if (dag_get_stream_erf_types(p->fd, pd->dag_stream, types, 255) < 0) {
840  		pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
841  		    errno, "dag_get_stream_erf_types");
842  		return (-1);
843  	}
844  	while (types[index]) {
845  #elif defined HAVE_DAG_GET_ERF_TYPES
846  	if (dag_get_erf_types(p->fd, types, 255) < 0) {
847  		pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
848  		    errno, "dag_get_erf_types");
849  		return (-1);
850  	}
851  	while (types[index]) {
852  #else
853  	types[index] = dag_linktype(p->fd);
854  	{
855  #endif
856  		switch((types[index] & 0x7f)) {
857  		case ERF_TYPE_HDLC_POS:
858  		case ERF_TYPE_COLOR_HDLC_POS:
859  		case ERF_TYPE_DSM_COLOR_HDLC_POS:
860  		case ERF_TYPE_COLOR_HASH_POS:
861  			if (p->dlt_list != NULL) {
862  				p->dlt_list[dlt_index++] = DLT_CHDLC;
863  				p->dlt_list[dlt_index++] = DLT_PPP_SERIAL;
864  				p->dlt_list[dlt_index++] = DLT_FRELAY;
865  			}
866  			if(!p->linktype)
867  				p->linktype = DLT_CHDLC;
868  			break;
869  		case ERF_TYPE_ETH:
870  		case ERF_TYPE_COLOR_ETH:
871  		case ERF_TYPE_DSM_COLOR_ETH:
872  		case ERF_TYPE_COLOR_HASH_ETH:
873  			if (p->dlt_list != NULL) {
874  				p->dlt_list[dlt_index++] = DLT_EN10MB;
875  				p->dlt_list[dlt_index++] = DLT_DOCSIS;
876  			}
877  			if(!p->linktype)
878  				p->linktype = DLT_EN10MB;
879  			break;
880  		case ERF_TYPE_ATM:
881  		case ERF_TYPE_AAL5:
882  		case ERF_TYPE_MC_ATM:
883  		case ERF_TYPE_MC_AAL5:
884  			if (p->dlt_list != NULL) {
885  				p->dlt_list[dlt_index++] = DLT_ATM_RFC1483;
886  				p->dlt_list[dlt_index++] = DLT_SUNATM;
887  			}
888  			if(!p->linktype)
889  				p->linktype = DLT_ATM_RFC1483;
890  			break;
891  		case ERF_TYPE_COLOR_MC_HDLC_POS:
892  		case ERF_TYPE_MC_HDLC:
893  			if (p->dlt_list != NULL) {
894  				p->dlt_list[dlt_index++] = DLT_CHDLC;
895  				p->dlt_list[dlt_index++] = DLT_PPP_SERIAL;
896  				p->dlt_list[dlt_index++] = DLT_FRELAY;
897  				p->dlt_list[dlt_index++] = DLT_MTP2;
898  				p->dlt_list[dlt_index++] = DLT_MTP2_WITH_PHDR;
899  				p->dlt_list[dlt_index++] = DLT_LAPD;
900  			}
901  			if(!p->linktype)
902  				p->linktype = DLT_CHDLC;
903  			break;
904  		case ERF_TYPE_IPV4:
905  			if (p->dlt_list != NULL) {
906  				p->dlt_list[dlt_index++] = DLT_RAW;
907  				p->dlt_list[dlt_index++] = DLT_IPV4;
908  			}
909  			if(!p->linktype)
910  				p->linktype = DLT_RAW;
911  			break;
912  		case ERF_TYPE_IPV6:
913  			if (p->dlt_list != NULL) {
914  				p->dlt_list[dlt_index++] = DLT_RAW;
915  				p->dlt_list[dlt_index++] = DLT_IPV6;
916  			}
917  			if(!p->linktype)
918  				p->linktype = DLT_RAW;
919  			break;
920  		case ERF_TYPE_LEGACY:
921  		case ERF_TYPE_MC_RAW:
922  		case ERF_TYPE_MC_RAW_CHANNEL:
923  		case ERF_TYPE_IP_COUNTER:
924  		case ERF_TYPE_TCP_FLOW_COUNTER:
925  		case ERF_TYPE_INFINIBAND:
926  		case ERF_TYPE_RAW_LINK:
927  		case ERF_TYPE_INFINIBAND_LINK:
928  		case ERF_TYPE_META:
929  		default:
930  			break;
931  		} &bsol;* switch */
932  		index++;
933  	}
934  	p->dlt_list[dlt_index++] = DLT_ERF;
935  	p->dlt_count = dlt_index;
936  	if(!p->linktype)
937  		p->linktype = DLT_ERF;
938  	return p->linktype;
939  }
940  #ifdef DAG_ONLY
941  int
942  pcap_platform_finddevs(pcap_if_list_t *devlistp _U_, char *errbuf)
943  {
944  	return (0);
945  }
946  pcap_t *
947  pcap_create_interface(const char *device, char *errbuf)
948  {
949  	snprintf(errbuf, PCAP_ERRBUF_SIZE,
950  	    "This version of libpcap only supports DAG cards");
951  	return NULL;
952  }
953  const char *
954  pcap_lib_version(void)
955  {
956  	return (PCAP_VERSION_STRING " (DAG-only)");
957  }
958  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ecb_encrypt.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-dag.c</div>
                <div class="column column_space"><pre><code>9     if ((err = cipher_is_valid(ecb->cipher)) != CRYPT_OK) {
10         return err;
11     }
12     if (len % cipher_descriptor[ecb->cipher].block_length) {
13        return CRYPT_INVALID_ARG;
14     }
15     if (cipher_descriptor[ecb->cipher].accel_ecb_encrypt != NULL) {
</pre></code></div>
                <div class="column column_space"><pre><code>238  		if ( NULL == (pd->dag_mem_top = dag_advance_stream(p->fd, pd->dag_stream, &(pd->dag_mem_bottom))) ) {
239  		     return -1;
240  		}
241  		if (nonblocking && (pd->dag_mem_top - pd->dag_mem_bottom < dag_record_size))
242  		{
243  			return 0;
244  		}
245  		if(!nonblocking &&
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    