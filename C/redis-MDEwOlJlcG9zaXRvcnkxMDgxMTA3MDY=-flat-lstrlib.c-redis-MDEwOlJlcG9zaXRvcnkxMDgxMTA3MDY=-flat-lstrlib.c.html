
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lstrlib.c</h3>
            <pre><code>1  #include <ctype.h>
2  #include <stddef.h>
3  #include <stdio.h>
4  #include <stdlib.h>
5  #include <string.h>
6  #define lstrlib_c
7  #define LUA_LIB
8  #include "lua.h"
9  #include "lauxlib.h"
10  #include "lualib.h"
11  #define uchar(c)        ((unsigned char)(c))
12  static int str_len (lua_State *L) {
13    size_t l;
14    luaL_checklstring(L, 1, &l);
15    lua_pushinteger(L, l);
16    return 1;
17  }
18  static ptrdiff_t posrelat (ptrdiff_t pos, size_t len) {
19    if (pos < 0) pos += (ptrdiff_t)len + 1;
20    return (pos >= 0) ? pos : 0;
21  }
22  static int str_sub (lua_State *L) {
23    size_t l;
24    const char *s = luaL_checklstring(L, 1, &l);
25    ptrdiff_t start = posrelat(luaL_checkinteger(L, 2), l);
26    ptrdiff_t end = posrelat(luaL_optinteger(L, 3, -1), l);
27    if (start < 1) start = 1;
28    if (end > (ptrdiff_t)l) end = (ptrdiff_t)l;
29    if (start <= end)
30      lua_pushlstring(L, s+start-1, end-start+1);
31    else lua_pushliteral(L, "");
32    return 1;
33  }
34  static int str_reverse (lua_State *L) {
35    size_t l;
36    luaL_Buffer b;
37    const char *s = luaL_checklstring(L, 1, &l);
38    luaL_buffinit(L, &b);
39    while (l--) luaL_addchar(&b, s[l]);
40    luaL_pushresult(&b);
41    return 1;
42  }
43  static int str_lower (lua_State *L) {
44    size_t l;
45    size_t i;
46    luaL_Buffer b;
47    const char *s = luaL_checklstring(L, 1, &l);
48    luaL_buffinit(L, &b);
49    for (i=0; i<l; i++)
50      luaL_addchar(&b, tolower(uchar(s[i])));
51    luaL_pushresult(&b);
52    return 1;
53  }
54  static int str_upper (lua_State *L) {
55    size_t l;
56    size_t i;
57    luaL_Buffer b;
58    const char *s = luaL_checklstring(L, 1, &l);
59    luaL_buffinit(L, &b);
60    for (i=0; i<l; i++)
61      luaL_addchar(&b, toupper(uchar(s[i])));
62    luaL_pushresult(&b);
63    return 1;
64  }
65  static int str_rep (lua_State *L) {
66    size_t l;
67    luaL_Buffer b;
68    const char *s = luaL_checklstring(L, 1, &l);
69    int n = luaL_checkint(L, 2);
70    luaL_buffinit(L, &b);
71    while (n-- > 0)
72      luaL_addlstring(&b, s, l);
73    luaL_pushresult(&b);
74    return 1;
75  }
76  static int str_byte (lua_State *L) {
77    size_t l;
78    const char *s = luaL_checklstring(L, 1, &l);
79    ptrdiff_t posi = posrelat(luaL_optinteger(L, 2, 1), l);
80    ptrdiff_t pose = posrelat(luaL_optinteger(L, 3, posi), l);
81    int n, i;
82    if (posi <= 0) posi = 1;
83    if ((size_t)pose > l) pose = l;
84    if (posi > pose) return 0;  &bsol;* empty interval; return no values */
85    n = (int)(pose -  posi + 1);
86    if (posi + n <= pose)  &bsol;* overflow? */
87      luaL_error(L, "string slice too long");
88    luaL_checkstack(L, n, "string slice too long");
89    for (i=0; i<n; i++)
90      lua_pushinteger(L, uchar(s[posi+i-1]));
91    return n;
92  }
93  static int str_char (lua_State *L) {
94    int n = lua_gettop(L);  &bsol;* number of arguments */
95    int i;
96    luaL_Buffer b;
97    luaL_buffinit(L, &b);
98    for (i=1; i<=n; i++) {
99      int c = luaL_checkint(L, i);
100      luaL_argcheck(L, uchar(c) == c, i, "invalid value");
101      luaL_addchar(&b, uchar(c));
102    }
103    luaL_pushresult(&b);
104    return 1;
105  }
106  static int writer (lua_State *L, const void* b, size_t size, void* B) {
107    (void)L;
108    luaL_addlstring((luaL_Buffer*) B, (const char *)b, size);
109    return 0;
110  }
111  static int str_dump (lua_State *L) {
112    luaL_Buffer b;
113    luaL_checktype(L, 1, LUA_TFUNCTION);
114    lua_settop(L, 1);
115    luaL_buffinit(L,&b);
116    if (lua_dump(L, writer, &b) != 0)
117      luaL_error(L, "unable to dump given function");
118    luaL_pushresult(&b);
119    return 1;
120  }
121  #define CAP_UNFINISHED	(-1)
122  #define CAP_POSITION	(-2)
123  typedef struct MatchState {
124    const char *src_init;  &bsol;* init of source string */
125    const char *src_end;  &bsol;* end (`\0') of source string */
126    lua_State *L;
127    int level;  &bsol;* total number of captures (finished or unfinished) */
128    struct {
129      const char *init;
130      ptrdiff_t len;
131    } capture[LUA_MAXCAPTURES];
132  } MatchState;
133  #define L_ESC		'%'
134  #define SPECIALS	"^$*+?.([%-"
135  static int check_capture (MatchState *ms, int l) {
136    l -= '1';
137    if (l < 0 || l >= ms->level || ms->capture[l].len == CAP_UNFINISHED)
138      return luaL_error(ms->L, "invalid capture index");
139    return l;
140  }
141  static int capture_to_close (MatchState *ms) {
142    int level = ms->level;
143    for (level--; level>=0; level--)
144      if (ms->capture[level].len == CAP_UNFINISHED) return level;
145    return luaL_error(ms->L, "invalid pattern capture");
146  }
147  static const char *classend (MatchState *ms, const char *p) {
148    switch (*p++) {
149      case L_ESC: {
150        if (*p == '\0')
151          luaL_error(ms->L, "malformed pattern (ends with " LUA_QL("%%") ")");
152        return p+1;
153      }
154      case '[': {
155        if (*p == '^') p++;
156        do {  &bsol;* look for a `]' */
157          if (*p == '\0')
158            luaL_error(ms->L, "malformed pattern (missing " LUA_QL("]") ")");
159          if (*(p++) == L_ESC && *p != '\0')
160            p++;  &bsol;* skip escapes (e.g. `%]') */
161        } while (*p != ']');
162        return p+1;
163      }
164      default: {
165        return p;
166      }
167    }
168  }
169  static int match_class (int c, int cl) {
170    int res;
171    switch (tolower(cl)) {
172      case 'a' : res = isalpha(c); break;
173      case 'c' : res = iscntrl(c); break;
174      case 'd' : res = isdigit(c); break;
175      case 'l' : res = islower(c); break;
176      case 'p' : res = ispunct(c); break;
177      case 's' : res = isspace(c); break;
178      case 'u' : res = isupper(c); break;
179      case 'w' : res = isalnum(c); break;
180      case 'x' : res = isxdigit(c); break;
181      case 'z' : res = (c == 0); break;
182      default: return (cl == c);
183    }
184    return (islower(cl) ? res : !res);
185  }
186  static int matchbracketclass (int c, const char *p, const char *ec) {
187    int sig = 1;
188    if (*(p+1) == '^') {
189      sig = 0;
190      p++;  &bsol;* skip the `^' */
191    }
192    while (++p < ec) {
193      if (*p == L_ESC) {
194        p++;
195        if (match_class(c, uchar(*p)))
196          return sig;
197      }
198      else if ((*(p+1) == '-') && (p+2 < ec)) {
199        p+=2;
200        if (uchar(*(p-2)) <= c && c <= uchar(*p))
201          return sig;
202      }
203      else if (uchar(*p) == c) return sig;
204    }
205    return !sig;
206  }
207  static int singlematch (int c, const char *p, const char *ep) {
208    switch (*p) {
209      case '.': return 1;  &bsol;* matches any char */
210      case L_ESC: return match_class(c, uchar(*(p+1)));
211      case '[': return matchbracketclass(c, p, ep-1);
212      default:  return (uchar(*p) == c);
213    }
214  }
215  static const char *match (MatchState *ms, const char *s, const char *p);
216  static const char *matchbalance (MatchState *ms, const char *s,
217                                     const char *p) {
218    if (*p == 0 || *(p+1) == 0)
219      luaL_error(ms->L, "unbalanced pattern");
220    if (*s != *p) return NULL;
221    else {
222      int b = *p;
223      int e = *(p+1);
224      int cont = 1;
225      while (++s < ms->src_end) {
226        if (*s == e) {
227          if (--cont == 0) return s+1;
228        }
229        else if (*s == b) cont++;
230      }
231    }
232    return NULL;  &bsol;* string ends out of balance */
233  }
234  static const char *max_expand (MatchState *ms, const char *s,
235                                   const char *p, const char *ep) {
236    ptrdiff_t i = 0;  &bsol;* counts maximum expand for item */
237    while ((s+i)<ms->src_end && singlematch(uchar(*(s+i)), p, ep))
238      i++;
239    while (i>=0) {
240      const char *res = match(ms, (s+i), ep+1);
241      if (res) return res;
242      i--;  &bsol;* else didn't match; reduce 1 repetition to try again */
243    }
244    return NULL;
245  }
246  static const char *min_expand (MatchState *ms, const char *s,
247                                   const char *p, const char *ep) {
248    for (;;) {
249      const char *res = match(ms, s, ep+1);
250      if (res != NULL)
251        return res;
252      else if (s<ms->src_end && singlematch(uchar(*s), p, ep))
253        s++;  &bsol;* try with one more repetition */
254      else return NULL;
255    }
256  }
257  static const char *start_capture (MatchState *ms, const char *s,
258                                      const char *p, int what) {
259    const char *res;
260    int level = ms->level;
261    if (level >= LUA_MAXCAPTURES) luaL_error(ms->L, "too many captures");
262    ms->capture[level].init = s;
263    ms->capture[level].len = what;
264    ms->level = level+1;
265    if ((res=match(ms, s, p)) == NULL)  &bsol;* match failed? */
266      ms->level--;  &bsol;* undo capture */
267    return res;
268  }
269  static const char *end_capture (MatchState *ms, const char *s,
270                                    const char *p) {
271    int l = capture_to_close(ms);
272    const char *res;
273    ms->capture[l].len = s - ms->capture[l].init;  &bsol;* close capture */
274    if ((res = match(ms, s, p)) == NULL)  &bsol;* match failed? */
275      ms->capture[l].len = CAP_UNFINISHED;  &bsol;* undo capture */
276    return res;
277  }
278  static const char *match_capture (MatchState *ms, const char *s, int l) {
279    size_t len;
280    l = check_capture(ms, l);
281    len = ms->capture[l].len;
282    if ((size_t)(ms->src_end-s) >= len &&
283        memcmp(ms->capture[l].init, s, len) == 0)
284      return s+len;
285    else return NULL;
286  }
287  static const char *match (MatchState *ms, const char *s, const char *p) {
288    init: &bsol;* using goto's to optimize tail recursion */
289    switch (*p) {
290      case '(': {  &bsol;* start capture */
291        if (*(p+1) == ')')  &bsol;* position capture? */
292          return start_capture(ms, s, p+2, CAP_POSITION);
293        else
294          return start_capture(ms, s, p+1, CAP_UNFINISHED);
295      }
296      case ')': {  &bsol;* end capture */
297        return end_capture(ms, s, p+1);
298      }
299      case L_ESC: {
300        switch (*(p+1)) {
301          case 'b': {  &bsol;* balanced string? */
302            s = matchbalance(ms, s, p+2);
303            if (s == NULL) return NULL;
304            p+=4; goto init;  &bsol;* else return match(ms, s, p+4); */
305          }
306          case 'f': {  &bsol;* frontier? */
307            const char *ep; char previous;
308            p += 2;
309            if (*p != '[')
310              luaL_error(ms->L, "missing " LUA_QL("[") " after "
311                                 LUA_QL("%%f") " in pattern");
312            ep = classend(ms, p);  &bsol;* points to what is next */
313            previous = (s == ms->src_init) ? '\0' : *(s-1);
314            if (matchbracketclass(uchar(previous), p, ep-1) ||
315               !matchbracketclass(uchar(*s), p, ep-1)) return NULL;
316            p=ep; goto init;  &bsol;* else return match(ms, s, ep); */
317          }
318          default: {
319            if (isdigit(uchar(*(p+1)))) {  &bsol;* capture results (%0-%9)? */
320              s = match_capture(ms, s, uchar(*(p+1)));
321              if (s == NULL) return NULL;
322              p+=2; goto init;  &bsol;* else return match(ms, s, p+2) */
323            }
324            goto dflt;  &bsol;* case default */
325          }
326        }
327      }
328      case '\0': {  &bsol;* end of pattern */
329        return s;  &bsol;* match succeeded */
330      }
331      case '$': {
332        if (*(p+1) == '\0')  &bsol;* is the `$' the last char in pattern? */
333          return (s == ms->src_end) ? s : NULL;  &bsol;* check end of string */
334        else goto dflt;
335      }
336      default: dflt: {  &bsol;* it is a pattern item */
337        const char *ep = classend(ms, p);  &bsol;* points to what is next */
338        int m = s<ms->src_end && singlematch(uchar(*s), p, ep);
339        switch (*ep) {
340          case '?': {  &bsol;* optional */
341            const char *res;
342            if (m && ((res=match(ms, s+1, ep+1)) != NULL))
343              return res;
344            p=ep+1; goto init;  &bsol;* else return match(ms, s, ep+1); */
345          }
346          case '*': {  &bsol;* 0 or more repetitions */
347            return max_expand(ms, s, p, ep);
348          }
349          case '+': {  &bsol;* 1 or more repetitions */
350            return (m ? max_expand(ms, s+1, p, ep) : NULL);
351          }
352          case '-': {  &bsol;* 0 or more repetitions (minimum) */
353            return min_expand(ms, s, p, ep);
354          }
355          default: {
356            if (!m) return NULL;
357            s++; p=ep; goto init;  &bsol;* else return match(ms, s+1, ep); */
358          }
359        }
360      }
361    }
362  }
363  static const char *lmemfind (const char *s1, size_t l1,
364                                 const char *s2, size_t l2) {
365    if (l2 == 0) return s1;  &bsol;* empty strings are everywhere */
366    else if (l2 > l1) return NULL;  &bsol;* avoids a negative `l1' */
367    else {
368      const char *init;  &bsol;* to search for a `*s2' inside `s1' */
369      l2--;  &bsol;* 1st char will be checked by `memchr' */
370      l1 = l1-l2;  &bsol;* `s2' cannot be found after that */
371      while (l1 > 0 && (init = (const char *)memchr(s1, *s2, l1)) != NULL) {
372        init++;   &bsol;* 1st char is already checked */
373        if (memcmp(init, s2+1, l2) == 0)
374          return init-1;
375        else {  &bsol;* correct `l1' and `s1' to try again */
376          l1 -= init-s1;
377          s1 = init;
378        }
379      }
380      return NULL;  &bsol;* not found */
381    }
382  }
383  static void push_onecapture (MatchState *ms, int i, const char *s,
384                                                      const char *e) {
385    if (i >= ms->level) {
386      if (i == 0)  &bsol;* ms->level == 0, too */
387        lua_pushlstring(ms->L, s, e - s);  &bsol;* add whole match */
388      else
389        luaL_error(ms->L, "invalid capture index");
390    }
391    else {
392      ptrdiff_t l = ms->capture[i].len;
393      if (l == CAP_UNFINISHED) luaL_error(ms->L, "unfinished capture");
394      if (l == CAP_POSITION)
395        lua_pushinteger(ms->L, ms->capture[i].init - ms->src_init + 1);
396      else
397        lua_pushlstring(ms->L, ms->capture[i].init, l);
398    }
399  }
400  static int push_captures (MatchState *ms, const char *s, const char *e) {
401    int i;
402    int nlevels = (ms->level == 0 && s) ? 1 : ms->level;
403    luaL_checkstack(ms->L, nlevels, "too many captures");
404    for (i = 0; i < nlevels; i++)
405      push_onecapture(ms, i, s, e);
406    return nlevels;  &bsol;* number of strings pushed */
407  }
408  static int str_find_aux (lua_State *L, int find) {
409    size_t l1, l2;
410    const char *s = luaL_checklstring(L, 1, &l1);
411    const char *p = luaL_checklstring(L, 2, &l2);
412    ptrdiff_t init = posrelat(luaL_optinteger(L, 3, 1), l1) - 1;
413    if (init < 0) init = 0;
414    else if ((size_t)(init) > l1) init = (ptrdiff_t)l1;
415    if (find && (lua_toboolean(L, 4) ||  &bsol;* explicit request? */
416        strpbrk(p, SPECIALS) == NULL)) {  &bsol;* or no special characters? */
417      const char *s2 = lmemfind(s+init, l1-init, p, l2);
418      if (s2) {
419        lua_pushinteger(L, s2-s+1);
420        lua_pushinteger(L, s2-s+l2);
421        return 2;
422      }
423    }
424    else {
425      MatchState ms;
<span onclick='openModal()' class='match'>426      int anchor = (*p == '^') ? (p++, 1) : 0;
427      const char *s1=s+init;
</span>428      ms.L = L;
429      ms.src_init = s;
430      ms.src_end = s+l1;
431      do {
432        const char *res;
433        ms.level = 0;
434        if ((res=match(&ms, s1, p)) != NULL) {
435          if (find) {
436            lua_pushinteger(L, s1-s+1);  &bsol;* start */
437            lua_pushinteger(L, res-s);   &bsol;* end */
438            return push_captures(&ms, NULL, 0) + 2;
439          }
440          else
441            return push_captures(&ms, s1, res);
442        }
443      } while (s1++ < ms.src_end && !anchor);
444    }
445    lua_pushnil(L);  &bsol;* not found */
446    return 1;
447  }
448  static int str_find (lua_State *L) {
449    return str_find_aux(L, 1);
450  }
451  static int str_match (lua_State *L) {
452    return str_find_aux(L, 0);
453  }
454  static int gmatch_aux (lua_State *L) {
455    MatchState ms;
456    size_t ls;
457    const char *s = lua_tolstring(L, lua_upvalueindex(1), &ls);
458    const char *p = lua_tostring(L, lua_upvalueindex(2));
459    const char *src;
460    ms.L = L;
461    ms.src_init = s;
462    ms.src_end = s+ls;
463    for (src = s + (size_t)lua_tointeger(L, lua_upvalueindex(3));
464         src <= ms.src_end;
465         src++) {
466      const char *e;
467      ms.level = 0;
468      if ((e = match(&ms, src, p)) != NULL) {
469        lua_Integer newstart = e-s;
470        if (e == src) newstart++;  &bsol;* empty match? go at least one position */
471        lua_pushinteger(L, newstart);
472        lua_replace(L, lua_upvalueindex(3));
473        return push_captures(&ms, src, e);
474      }
475    }
476    return 0;  &bsol;* not found */
477  }
478  static int gmatch (lua_State *L) {
479    luaL_checkstring(L, 1);
480    luaL_checkstring(L, 2);
481    lua_settop(L, 2);
482    lua_pushinteger(L, 0);
483    lua_pushcclosure(L, gmatch_aux, 3);
484    return 1;
485  }
486  static int gfind_nodef (lua_State *L) {
487    return luaL_error(L, LUA_QL("string.gfind") " was renamed to "
488                         LUA_QL("string.gmatch"));
489  }
490  static void add_s (MatchState *ms, luaL_Buffer *b, const char *s,
491                                                     const char *e) {
492    size_t l, i;
493    const char *news = lua_tolstring(ms->L, 3, &l);
494    for (i = 0; i < l; i++) {
495      if (news[i] != L_ESC)
496        luaL_addchar(b, news[i]);
497      else {
498        i++;  &bsol;* skip ESC */
499        if (!isdigit(uchar(news[i])))
500          luaL_addchar(b, news[i]);
501        else if (news[i] == '0')
502            luaL_addlstring(b, s, e - s);
503        else {
504          push_onecapture(ms, news[i] - '1', s, e);
505          luaL_addvalue(b);  &bsol;* add capture to accumulated result */
506        }
507      }
508    }
509  }
510  static void add_value (MatchState *ms, luaL_Buffer *b, const char *s,
511                                                         const char *e) {
512    lua_State *L = ms->L;
513    switch (lua_type(L, 3)) {
514      case LUA_TNUMBER:
515      case LUA_TSTRING: {
516        add_s(ms, b, s, e);
517        return;
518      }
519      case LUA_TFUNCTION: {
520        int n;
521        lua_pushvalue(L, 3);
522        n = push_captures(ms, s, e);
523        lua_call(L, n, 1);
524        break;
525      }
526      case LUA_TTABLE: {
527        push_onecapture(ms, 0, s, e);
528        lua_gettable(L, 3);
529        break;
530      }
531    }
532    if (!lua_toboolean(L, -1)) {  &bsol;* nil or false? */
533      lua_pop(L, 1);
534      lua_pushlstring(L, s, e - s);  &bsol;* keep original text */
535    }
536    else if (!lua_isstring(L, -1))
537      luaL_error(L, "invalid replacement value (a %s)", luaL_typename(L, -1)); 
538    luaL_addvalue(b);  &bsol;* add result to accumulator */
539  }
540  static int str_gsub (lua_State *L) {
541    size_t srcl;
542    const char *src = luaL_checklstring(L, 1, &srcl);
543    const char *p = luaL_checkstring(L, 2);
544    int  tr = lua_type(L, 3);
545    int max_s = luaL_optint(L, 4, srcl+1);
546    int anchor = (*p == '^') ? (p++, 1) : 0;
547    int n = 0;
548    MatchState ms;
549    luaL_Buffer b;
550    luaL_argcheck(L, tr == LUA_TNUMBER || tr == LUA_TSTRING ||
551                     tr == LUA_TFUNCTION || tr == LUA_TTABLE, 3,
552                        "string/function/table expected");
553    luaL_buffinit(L, &b);
554    ms.L = L;
555    ms.src_init = src;
556    ms.src_end = src+srcl;
557    while (n < max_s) {
558      const char *e;
559      ms.level = 0;
560      e = match(&ms, src, p);
561      if (e) {
562        n++;
563        add_value(&ms, &b, src, e);
564      }
565      if (e && e>src) &bsol;* non empty match? */
566        src = e;  &bsol;* skip it */
567      else if (src < ms.src_end)
568        luaL_addchar(&b, *src++);
569      else break;
570      if (anchor) break;
571    }
572    luaL_addlstring(&b, src, ms.src_end-src);
573    luaL_pushresult(&b);
574    lua_pushinteger(L, n);  &bsol;* number of substitutions */
575    return 2;
576  }
577  #define MAX_ITEM	512
578  #define FLAGS	"-+ #0"
579  #define MAX_FORMAT	(sizeof(FLAGS) + sizeof(LUA_INTFRMLEN) + 10)
580  static void addquoted (lua_State *L, luaL_Buffer *b, int arg) {
581    size_t l;
582    const char *s = luaL_checklstring(L, arg, &l);
583    luaL_addchar(b, '"');
584    while (l--) {
585      switch (*s) {
586        case '"': case '\\': case '\n': {
587          luaL_addchar(b, '\\');
588          luaL_addchar(b, *s);
589          break;
590        }
591        case '\r': {
592          luaL_addlstring(b, "\\r", 2);
593          break;
594        }
595        case '\0': {
596          luaL_addlstring(b, "\\000", 4);
597          break;
598        }
599        default: {
600          luaL_addchar(b, *s);
601          break;
602        }
603      }
604      s++;
605    }
606    luaL_addchar(b, '"');
607  }
608  static const char *scanformat (lua_State *L, const char *strfrmt, char *form) {
609    const char *p = strfrmt;
610    while (*p != '\0' && strchr(FLAGS, *p) != NULL) p++;  &bsol;* skip flags */
611    if ((size_t)(p - strfrmt) >= sizeof(FLAGS))
612      luaL_error(L, "invalid format (repeated flags)");
613    if (isdigit(uchar(*p))) p++;  &bsol;* skip width */
614    if (isdigit(uchar(*p))) p++;  &bsol;* (2 digits at most) */
615    if (*p == '.') {
616      p++;
617      if (isdigit(uchar(*p))) p++;  &bsol;* skip precision */
618      if (isdigit(uchar(*p))) p++;  &bsol;* (2 digits at most) */
619    }
620    if (isdigit(uchar(*p)))
621      luaL_error(L, "invalid format (width or precision too long)");
622    *(form++) = '%';
623    strncpy(form, strfrmt, p - strfrmt + 1);
624    form += p - strfrmt + 1;
625    *form = '\0';
626    return p;
627  }
628  static void addintlen (char *form) {
629    size_t l = strlen(form);
630    char spec = form[l - 1];
631    strcpy(form + l - 1, LUA_INTFRMLEN);
632    form[l + sizeof(LUA_INTFRMLEN) - 2] = spec;
633    form[l + sizeof(LUA_INTFRMLEN) - 1] = '\0';
634  }
635  static int str_format (lua_State *L) {
636    int top = lua_gettop(L);
637    int arg = 1;
638    size_t sfl;
639    const char *strfrmt = luaL_checklstring(L, arg, &sfl);
640    const char *strfrmt_end = strfrmt+sfl;
641    luaL_Buffer b;
642    luaL_buffinit(L, &b);
643    while (strfrmt < strfrmt_end) {
644      if (*strfrmt != L_ESC)
645        luaL_addchar(&b, *strfrmt++);
646      else if (*++strfrmt == L_ESC)
647        luaL_addchar(&b, *strfrmt++);  &bsol;* %% */
648      else { &bsol;* format item */
649        char form[MAX_FORMAT];  &bsol;* to store the format (`%...') */
650        char buff[MAX_ITEM];  &bsol;* to store the formatted item */
651        if (++arg > top)
652          luaL_argerror(L, arg, "no value");
653        strfrmt = scanformat(L, strfrmt, form);
654        switch (*strfrmt++) {
655          case 'c': {
656            sprintf(buff, form, (int)luaL_checknumber(L, arg));
657            break;
658          }
659          case 'd':  case 'i': {
660            addintlen(form);
661            sprintf(buff, form, (LUA_INTFRM_T)luaL_checknumber(L, arg));
662            break;
663          }
664          case 'o':  case 'u':  case 'x':  case 'X': {
665            addintlen(form);
666            sprintf(buff, form, (unsigned LUA_INTFRM_T)luaL_checknumber(L, arg));
667            break;
668          }
669          case 'e':  case 'E': case 'f':
670          case 'g': case 'G': {
671            sprintf(buff, form, (double)luaL_checknumber(L, arg));
672            break;
673          }
674          case 'q': {
675            addquoted(L, &b, arg);
676            continue;  &bsol;* skip the 'addsize' at the end */
677          }
678          case 's': {
679            size_t l;
680            const char *s = luaL_checklstring(L, arg, &l);
681            if (!strchr(form, '.') && l >= 100) {
682              lua_pushvalue(L, arg);
683              luaL_addvalue(&b);
684              continue;  &bsol;* skip the `addsize' at the end */
685            }
686            else {
687              sprintf(buff, form, s);
688              break;
689            }
690          }
691          default: {  &bsol;* also treat cases `pnLlh' */
692            return luaL_error(L, "invalid option " LUA_QL("%%%c") " to "
693                                 LUA_QL("format"), *(strfrmt - 1));
694          }
695        }
696        luaL_addlstring(&b, buff, strlen(buff));
697      }
698    }
699    luaL_pushresult(&b);
700    return 1;
701  }
702  static const luaL_Reg strlib[] = {
703    {"byte", str_byte},
704    {"char", str_char},
705    {"dump", str_dump},
706    {"find", str_find},
707    {"format", str_format},
708    {"gfind", gfind_nodef},
709    {"gmatch", gmatch},
710    {"gsub", str_gsub},
711    {"len", str_len},
712    {"lower", str_lower},
713    {"match", str_match},
714    {"rep", str_rep},
715    {"reverse", str_reverse},
716    {"sub", str_sub},
717    {"upper", str_upper},
718    {NULL, NULL}
719  };
720  static void createmetatable (lua_State *L) {
721    lua_createtable(L, 0, 1);  &bsol;* create metatable for strings */
722    lua_pushliteral(L, "");  &bsol;* dummy string */
723    lua_pushvalue(L, -2);
724    lua_setmetatable(L, -2);  &bsol;* set string metatable */
725    lua_pop(L, 1);  &bsol;* pop dummy string */
726    lua_pushvalue(L, -2);  &bsol;* string library... */
727    lua_setfield(L, -2, "__index");  &bsol;* ...is the __index metamethod */
728    lua_pop(L, 1);  &bsol;* pop metatable */
729  }
730  LUALIB_API int luaopen_string (lua_State *L) {
731    luaL_register(L, LUA_STRLIBNAME, strlib);
732  #if defined(LUA_COMPAT_GFIND)
733    lua_getfield(L, -1, "gmatch");
734    lua_setfield(L, -2, "gfind");
735  #endif
736    createmetatable(L);
737    return 1;
738  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lstrlib.c</h3>
            <pre><code>1  #include <ctype.h>
2  #include <stddef.h>
3  #include <stdio.h>
4  #include <stdlib.h>
5  #include <string.h>
6  #define lstrlib_c
7  #define LUA_LIB
8  #include "lua.h"
9  #include "lauxlib.h"
10  #include "lualib.h"
11  #define uchar(c)        ((unsigned char)(c))
12  static int str_len (lua_State *L) {
13    size_t l;
14    luaL_checklstring(L, 1, &l);
15    lua_pushinteger(L, l);
16    return 1;
17  }
18  static ptrdiff_t posrelat (ptrdiff_t pos, size_t len) {
19    if (pos < 0) pos += (ptrdiff_t)len + 1;
20    return (pos >= 0) ? pos : 0;
21  }
22  static int str_sub (lua_State *L) {
23    size_t l;
24    const char *s = luaL_checklstring(L, 1, &l);
25    ptrdiff_t start = posrelat(luaL_checkinteger(L, 2), l);
26    ptrdiff_t end = posrelat(luaL_optinteger(L, 3, -1), l);
27    if (start < 1) start = 1;
28    if (end > (ptrdiff_t)l) end = (ptrdiff_t)l;
29    if (start <= end)
30      lua_pushlstring(L, s+start-1, end-start+1);
31    else lua_pushliteral(L, "");
32    return 1;
33  }
34  static int str_reverse (lua_State *L) {
35    size_t l;
36    luaL_Buffer b;
37    const char *s = luaL_checklstring(L, 1, &l);
38    luaL_buffinit(L, &b);
39    while (l--) luaL_addchar(&b, s[l]);
40    luaL_pushresult(&b);
41    return 1;
42  }
43  static int str_lower (lua_State *L) {
44    size_t l;
45    size_t i;
46    luaL_Buffer b;
47    const char *s = luaL_checklstring(L, 1, &l);
48    luaL_buffinit(L, &b);
49    for (i=0; i<l; i++)
50      luaL_addchar(&b, tolower(uchar(s[i])));
51    luaL_pushresult(&b);
52    return 1;
53  }
54  static int str_upper (lua_State *L) {
55    size_t l;
56    size_t i;
57    luaL_Buffer b;
58    const char *s = luaL_checklstring(L, 1, &l);
59    luaL_buffinit(L, &b);
60    for (i=0; i<l; i++)
61      luaL_addchar(&b, toupper(uchar(s[i])));
62    luaL_pushresult(&b);
63    return 1;
64  }
65  static int str_rep (lua_State *L) {
66    size_t l;
67    luaL_Buffer b;
68    const char *s = luaL_checklstring(L, 1, &l);
69    int n = luaL_checkint(L, 2);
70    luaL_buffinit(L, &b);
71    while (n-- > 0)
72      luaL_addlstring(&b, s, l);
73    luaL_pushresult(&b);
74    return 1;
75  }
76  static int str_byte (lua_State *L) {
77    size_t l;
78    const char *s = luaL_checklstring(L, 1, &l);
79    ptrdiff_t posi = posrelat(luaL_optinteger(L, 2, 1), l);
80    ptrdiff_t pose = posrelat(luaL_optinteger(L, 3, posi), l);
81    int n, i;
82    if (posi <= 0) posi = 1;
83    if ((size_t)pose > l) pose = l;
84    if (posi > pose) return 0;  &bsol;* empty interval; return no values */
85    n = (int)(pose -  posi + 1);
86    if (posi + n <= pose)  &bsol;* overflow? */
87      luaL_error(L, "string slice too long");
88    luaL_checkstack(L, n, "string slice too long");
89    for (i=0; i<n; i++)
90      lua_pushinteger(L, uchar(s[posi+i-1]));
91    return n;
92  }
93  static int str_char (lua_State *L) {
94    int n = lua_gettop(L);  &bsol;* number of arguments */
95    int i;
96    luaL_Buffer b;
97    luaL_buffinit(L, &b);
98    for (i=1; i<=n; i++) {
99      int c = luaL_checkint(L, i);
100      luaL_argcheck(L, uchar(c) == c, i, "invalid value");
101      luaL_addchar(&b, uchar(c));
102    }
103    luaL_pushresult(&b);
104    return 1;
105  }
106  static int writer (lua_State *L, const void* b, size_t size, void* B) {
107    (void)L;
108    luaL_addlstring((luaL_Buffer*) B, (const char *)b, size);
109    return 0;
110  }
111  static int str_dump (lua_State *L) {
112    luaL_Buffer b;
113    luaL_checktype(L, 1, LUA_TFUNCTION);
114    lua_settop(L, 1);
115    luaL_buffinit(L,&b);
116    if (lua_dump(L, writer, &b) != 0)
117      luaL_error(L, "unable to dump given function");
118    luaL_pushresult(&b);
119    return 1;
120  }
121  #define CAP_UNFINISHED	(-1)
122  #define CAP_POSITION	(-2)
123  typedef struct MatchState {
124    const char *src_init;  &bsol;* init of source string */
125    const char *src_end;  &bsol;* end (`\0') of source string */
126    lua_State *L;
127    int level;  &bsol;* total number of captures (finished or unfinished) */
128    struct {
129      const char *init;
130      ptrdiff_t len;
131    } capture[LUA_MAXCAPTURES];
132  } MatchState;
133  #define L_ESC		'%'
134  #define SPECIALS	"^$*+?.([%-"
135  static int check_capture (MatchState *ms, int l) {
136    l -= '1';
137    if (l < 0 || l >= ms->level || ms->capture[l].len == CAP_UNFINISHED)
138      return luaL_error(ms->L, "invalid capture index");
139    return l;
140  }
141  static int capture_to_close (MatchState *ms) {
142    int level = ms->level;
143    for (level--; level>=0; level--)
144      if (ms->capture[level].len == CAP_UNFINISHED) return level;
145    return luaL_error(ms->L, "invalid pattern capture");
146  }
147  static const char *classend (MatchState *ms, const char *p) {
148    switch (*p++) {
149      case L_ESC: {
150        if (*p == '\0')
151          luaL_error(ms->L, "malformed pattern (ends with " LUA_QL("%%") ")");
152        return p+1;
153      }
154      case '[': {
155        if (*p == '^') p++;
156        do {  &bsol;* look for a `]' */
157          if (*p == '\0')
158            luaL_error(ms->L, "malformed pattern (missing " LUA_QL("]") ")");
159          if (*(p++) == L_ESC && *p != '\0')
160            p++;  &bsol;* skip escapes (e.g. `%]') */
161        } while (*p != ']');
162        return p+1;
163      }
164      default: {
165        return p;
166      }
167    }
168  }
169  static int match_class (int c, int cl) {
170    int res;
171    switch (tolower(cl)) {
172      case 'a' : res = isalpha(c); break;
173      case 'c' : res = iscntrl(c); break;
174      case 'd' : res = isdigit(c); break;
175      case 'l' : res = islower(c); break;
176      case 'p' : res = ispunct(c); break;
177      case 's' : res = isspace(c); break;
178      case 'u' : res = isupper(c); break;
179      case 'w' : res = isalnum(c); break;
180      case 'x' : res = isxdigit(c); break;
181      case 'z' : res = (c == 0); break;
182      default: return (cl == c);
183    }
184    return (islower(cl) ? res : !res);
185  }
186  static int matchbracketclass (int c, const char *p, const char *ec) {
187    int sig = 1;
188    if (*(p+1) == '^') {
189      sig = 0;
190      p++;  &bsol;* skip the `^' */
191    }
192    while (++p < ec) {
193      if (*p == L_ESC) {
194        p++;
195        if (match_class(c, uchar(*p)))
196          return sig;
197      }
198      else if ((*(p+1) == '-') && (p+2 < ec)) {
199        p+=2;
200        if (uchar(*(p-2)) <= c && c <= uchar(*p))
201          return sig;
202      }
203      else if (uchar(*p) == c) return sig;
204    }
205    return !sig;
206  }
207  static int singlematch (int c, const char *p, const char *ep) {
208    switch (*p) {
209      case '.': return 1;  &bsol;* matches any char */
210      case L_ESC: return match_class(c, uchar(*(p+1)));
211      case '[': return matchbracketclass(c, p, ep-1);
212      default:  return (uchar(*p) == c);
213    }
214  }
215  static const char *match (MatchState *ms, const char *s, const char *p);
216  static const char *matchbalance (MatchState *ms, const char *s,
217                                     const char *p) {
218    if (*p == 0 || *(p+1) == 0)
219      luaL_error(ms->L, "unbalanced pattern");
220    if (*s != *p) return NULL;
221    else {
222      int b = *p;
223      int e = *(p+1);
224      int cont = 1;
225      while (++s < ms->src_end) {
226        if (*s == e) {
227          if (--cont == 0) return s+1;
228        }
229        else if (*s == b) cont++;
230      }
231    }
232    return NULL;  &bsol;* string ends out of balance */
233  }
234  static const char *max_expand (MatchState *ms, const char *s,
235                                   const char *p, const char *ep) {
236    ptrdiff_t i = 0;  &bsol;* counts maximum expand for item */
237    while ((s+i)<ms->src_end && singlematch(uchar(*(s+i)), p, ep))
238      i++;
239    while (i>=0) {
240      const char *res = match(ms, (s+i), ep+1);
241      if (res) return res;
242      i--;  &bsol;* else didn't match; reduce 1 repetition to try again */
243    }
244    return NULL;
245  }
246  static const char *min_expand (MatchState *ms, const char *s,
247                                   const char *p, const char *ep) {
248    for (;;) {
249      const char *res = match(ms, s, ep+1);
250      if (res != NULL)
251        return res;
252      else if (s<ms->src_end && singlematch(uchar(*s), p, ep))
253        s++;  &bsol;* try with one more repetition */
254      else return NULL;
255    }
256  }
257  static const char *start_capture (MatchState *ms, const char *s,
258                                      const char *p, int what) {
259    const char *res;
260    int level = ms->level;
261    if (level >= LUA_MAXCAPTURES) luaL_error(ms->L, "too many captures");
262    ms->capture[level].init = s;
263    ms->capture[level].len = what;
264    ms->level = level+1;
265    if ((res=match(ms, s, p)) == NULL)  &bsol;* match failed? */
266      ms->level--;  &bsol;* undo capture */
267    return res;
268  }
269  static const char *end_capture (MatchState *ms, const char *s,
270                                    const char *p) {
271    int l = capture_to_close(ms);
272    const char *res;
273    ms->capture[l].len = s - ms->capture[l].init;  &bsol;* close capture */
274    if ((res = match(ms, s, p)) == NULL)  &bsol;* match failed? */
275      ms->capture[l].len = CAP_UNFINISHED;  &bsol;* undo capture */
276    return res;
277  }
278  static const char *match_capture (MatchState *ms, const char *s, int l) {
279    size_t len;
280    l = check_capture(ms, l);
281    len = ms->capture[l].len;
282    if ((size_t)(ms->src_end-s) >= len &&
283        memcmp(ms->capture[l].init, s, len) == 0)
284      return s+len;
285    else return NULL;
286  }
287  static const char *match (MatchState *ms, const char *s, const char *p) {
288    init: &bsol;* using goto's to optimize tail recursion */
289    switch (*p) {
290      case '(': {  &bsol;* start capture */
291        if (*(p+1) == ')')  &bsol;* position capture? */
292          return start_capture(ms, s, p+2, CAP_POSITION);
293        else
294          return start_capture(ms, s, p+1, CAP_UNFINISHED);
295      }
296      case ')': {  &bsol;* end capture */
297        return end_capture(ms, s, p+1);
298      }
299      case L_ESC: {
300        switch (*(p+1)) {
301          case 'b': {  &bsol;* balanced string? */
302            s = matchbalance(ms, s, p+2);
303            if (s == NULL) return NULL;
304            p+=4; goto init;  &bsol;* else return match(ms, s, p+4); */
305          }
306          case 'f': {  &bsol;* frontier? */
307            const char *ep; char previous;
308            p += 2;
309            if (*p != '[')
310              luaL_error(ms->L, "missing " LUA_QL("[") " after "
311                                 LUA_QL("%%f") " in pattern");
312            ep = classend(ms, p);  &bsol;* points to what is next */
313            previous = (s == ms->src_init) ? '\0' : *(s-1);
314            if (matchbracketclass(uchar(previous), p, ep-1) ||
315               !matchbracketclass(uchar(*s), p, ep-1)) return NULL;
316            p=ep; goto init;  &bsol;* else return match(ms, s, ep); */
317          }
318          default: {
319            if (isdigit(uchar(*(p+1)))) {  &bsol;* capture results (%0-%9)? */
320              s = match_capture(ms, s, uchar(*(p+1)));
321              if (s == NULL) return NULL;
322              p+=2; goto init;  &bsol;* else return match(ms, s, p+2) */
323            }
324            goto dflt;  &bsol;* case default */
325          }
326        }
327      }
328      case '\0': {  &bsol;* end of pattern */
329        return s;  &bsol;* match succeeded */
330      }
331      case '$': {
332        if (*(p+1) == '\0')  &bsol;* is the `$' the last char in pattern? */
333          return (s == ms->src_end) ? s : NULL;  &bsol;* check end of string */
334        else goto dflt;
335      }
336      default: dflt: {  &bsol;* it is a pattern item */
337        const char *ep = classend(ms, p);  &bsol;* points to what is next */
338        int m = s<ms->src_end && singlematch(uchar(*s), p, ep);
339        switch (*ep) {
340          case '?': {  &bsol;* optional */
341            const char *res;
342            if (m && ((res=match(ms, s+1, ep+1)) != NULL))
343              return res;
344            p=ep+1; goto init;  &bsol;* else return match(ms, s, ep+1); */
345          }
346          case '*': {  &bsol;* 0 or more repetitions */
347            return max_expand(ms, s, p, ep);
348          }
349          case '+': {  &bsol;* 1 or more repetitions */
350            return (m ? max_expand(ms, s+1, p, ep) : NULL);
351          }
352          case '-': {  &bsol;* 0 or more repetitions (minimum) */
353            return min_expand(ms, s, p, ep);
354          }
355          default: {
356            if (!m) return NULL;
357            s++; p=ep; goto init;  &bsol;* else return match(ms, s+1, ep); */
358          }
359        }
360      }
361    }
362  }
363  static const char *lmemfind (const char *s1, size_t l1,
364                                 const char *s2, size_t l2) {
365    if (l2 == 0) return s1;  &bsol;* empty strings are everywhere */
366    else if (l2 > l1) return NULL;  &bsol;* avoids a negative `l1' */
367    else {
368      const char *init;  &bsol;* to search for a `*s2' inside `s1' */
369      l2--;  &bsol;* 1st char will be checked by `memchr' */
370      l1 = l1-l2;  &bsol;* `s2' cannot be found after that */
371      while (l1 > 0 && (init = (const char *)memchr(s1, *s2, l1)) != NULL) {
372        init++;   &bsol;* 1st char is already checked */
373        if (memcmp(init, s2+1, l2) == 0)
374          return init-1;
375        else {  &bsol;* correct `l1' and `s1' to try again */
376          l1 -= init-s1;
377          s1 = init;
378        }
379      }
380      return NULL;  &bsol;* not found */
381    }
382  }
383  static void push_onecapture (MatchState *ms, int i, const char *s,
384                                                      const char *e) {
385    if (i >= ms->level) {
386      if (i == 0)  &bsol;* ms->level == 0, too */
387        lua_pushlstring(ms->L, s, e - s);  &bsol;* add whole match */
388      else
389        luaL_error(ms->L, "invalid capture index");
390    }
391    else {
392      ptrdiff_t l = ms->capture[i].len;
393      if (l == CAP_UNFINISHED) luaL_error(ms->L, "unfinished capture");
394      if (l == CAP_POSITION)
395        lua_pushinteger(ms->L, ms->capture[i].init - ms->src_init + 1);
396      else
397        lua_pushlstring(ms->L, ms->capture[i].init, l);
398    }
399  }
400  static int push_captures (MatchState *ms, const char *s, const char *e) {
401    int i;
402    int nlevels = (ms->level == 0 && s) ? 1 : ms->level;
403    luaL_checkstack(ms->L, nlevels, "too many captures");
404    for (i = 0; i < nlevels; i++)
405      push_onecapture(ms, i, s, e);
406    return nlevels;  &bsol;* number of strings pushed */
407  }
408  static int str_find_aux (lua_State *L, int find) {
409    size_t l1, l2;
410    const char *s = luaL_checklstring(L, 1, &l1);
411    const char *p = luaL_checklstring(L, 2, &l2);
412    ptrdiff_t init = posrelat(luaL_optinteger(L, 3, 1), l1) - 1;
413    if (init < 0) init = 0;
414    else if ((size_t)(init) > l1) init = (ptrdiff_t)l1;
415    if (find && (lua_toboolean(L, 4) ||  &bsol;* explicit request? */
416        strpbrk(p, SPECIALS) == NULL)) {  &bsol;* or no special characters? */
417      const char *s2 = lmemfind(s+init, l1-init, p, l2);
418      if (s2) {
419        lua_pushinteger(L, s2-s+1);
420        lua_pushinteger(L, s2-s+l2);
421        return 2;
422      }
423    }
424    else {
425      MatchState ms;
426      int anchor = (*p == '^') ? (p++, 1) : 0;
427      const char *s1=s+init;
428      ms.L = L;
429      ms.src_init = s;
430      ms.src_end = s+l1;
431      do {
432        const char *res;
433        ms.level = 0;
434        if ((res=match(&ms, s1, p)) != NULL) {
435          if (find) {
436            lua_pushinteger(L, s1-s+1);  &bsol;* start */
437            lua_pushinteger(L, res-s);   &bsol;* end */
438            return push_captures(&ms, NULL, 0) + 2;
439          }
440          else
441            return push_captures(&ms, s1, res);
442        }
443      } while (s1++ < ms.src_end && !anchor);
444    }
445    lua_pushnil(L);  &bsol;* not found */
446    return 1;
447  }
448  static int str_find (lua_State *L) {
449    return str_find_aux(L, 1);
450  }
451  static int str_match (lua_State *L) {
452    return str_find_aux(L, 0);
453  }
454  static int gmatch_aux (lua_State *L) {
455    MatchState ms;
456    size_t ls;
457    const char *s = lua_tolstring(L, lua_upvalueindex(1), &ls);
458    const char *p = lua_tostring(L, lua_upvalueindex(2));
459    const char *src;
460    ms.L = L;
461    ms.src_init = s;
462    ms.src_end = s+ls;
463    for (src = s + (size_t)lua_tointeger(L, lua_upvalueindex(3));
464         src <= ms.src_end;
465         src++) {
466      const char *e;
467      ms.level = 0;
468      if ((e = match(&ms, src, p)) != NULL) {
469        lua_Integer newstart = e-s;
470        if (e == src) newstart++;  &bsol;* empty match? go at least one position */
471        lua_pushinteger(L, newstart);
472        lua_replace(L, lua_upvalueindex(3));
473        return push_captures(&ms, src, e);
474      }
475    }
476    return 0;  &bsol;* not found */
477  }
478  static int gmatch (lua_State *L) {
479    luaL_checkstring(L, 1);
480    luaL_checkstring(L, 2);
481    lua_settop(L, 2);
482    lua_pushinteger(L, 0);
483    lua_pushcclosure(L, gmatch_aux, 3);
484    return 1;
485  }
486  static int gfind_nodef (lua_State *L) {
487    return luaL_error(L, LUA_QL("string.gfind") " was renamed to "
488                         LUA_QL("string.gmatch"));
489  }
490  static void add_s (MatchState *ms, luaL_Buffer *b, const char *s,
491                                                     const char *e) {
492    size_t l, i;
493    const char *news = lua_tolstring(ms->L, 3, &l);
494    for (i = 0; i < l; i++) {
495      if (news[i] != L_ESC)
496        luaL_addchar(b, news[i]);
497      else {
498        i++;  &bsol;* skip ESC */
499        if (!isdigit(uchar(news[i])))
500          luaL_addchar(b, news[i]);
501        else if (news[i] == '0')
502            luaL_addlstring(b, s, e - s);
503        else {
504          push_onecapture(ms, news[i] - '1', s, e);
505          luaL_addvalue(b);  &bsol;* add capture to accumulated result */
506        }
507      }
508    }
509  }
510  static void add_value (MatchState *ms, luaL_Buffer *b, const char *s,
511                                                         const char *e) {
512    lua_State *L = ms->L;
513    switch (lua_type(L, 3)) {
514      case LUA_TNUMBER:
515      case LUA_TSTRING: {
516        add_s(ms, b, s, e);
517        return;
518      }
519      case LUA_TFUNCTION: {
520        int n;
521        lua_pushvalue(L, 3);
522        n = push_captures(ms, s, e);
523        lua_call(L, n, 1);
524        break;
525      }
526      case LUA_TTABLE: {
527        push_onecapture(ms, 0, s, e);
528        lua_gettable(L, 3);
529        break;
530      }
531    }
532    if (!lua_toboolean(L, -1)) {  &bsol;* nil or false? */
533      lua_pop(L, 1);
534      lua_pushlstring(L, s, e - s);  &bsol;* keep original text */
535    }
536    else if (!lua_isstring(L, -1))
537      luaL_error(L, "invalid replacement value (a %s)", luaL_typename(L, -1)); 
538    luaL_addvalue(b);  &bsol;* add result to accumulator */
539  }
540  static int str_gsub (lua_State *L) {
541    size_t srcl;
542    const char *src = luaL_checklstring(L, 1, &srcl);
543    const char *p = luaL_checkstring(L, 2);
544    int  tr = lua_type(L, 3);
545    int max_s = luaL_optint(L, 4, srcl+1);
<span onclick='openModal()' class='match'>546    int anchor = (*p == '^') ? (p++, 1) : 0;
547    int n = 0;
</span>548    MatchState ms;
549    luaL_Buffer b;
550    luaL_argcheck(L, tr == LUA_TNUMBER || tr == LUA_TSTRING ||
551                     tr == LUA_TFUNCTION || tr == LUA_TTABLE, 3,
552                        "string/function/table expected");
553    luaL_buffinit(L, &b);
554    ms.L = L;
555    ms.src_init = src;
556    ms.src_end = src+srcl;
557    while (n < max_s) {
558      const char *e;
559      ms.level = 0;
560      e = match(&ms, src, p);
561      if (e) {
562        n++;
563        add_value(&ms, &b, src, e);
564      }
565      if (e && e>src) &bsol;* non empty match? */
566        src = e;  &bsol;* skip it */
567      else if (src < ms.src_end)
568        luaL_addchar(&b, *src++);
569      else break;
570      if (anchor) break;
571    }
572    luaL_addlstring(&b, src, ms.src_end-src);
573    luaL_pushresult(&b);
574    lua_pushinteger(L, n);  &bsol;* number of substitutions */
575    return 2;
576  }
577  #define MAX_ITEM	512
578  #define FLAGS	"-+ #0"
579  #define MAX_FORMAT	(sizeof(FLAGS) + sizeof(LUA_INTFRMLEN) + 10)
580  static void addquoted (lua_State *L, luaL_Buffer *b, int arg) {
581    size_t l;
582    const char *s = luaL_checklstring(L, arg, &l);
583    luaL_addchar(b, '"');
584    while (l--) {
585      switch (*s) {
586        case '"': case '\\': case '\n': {
587          luaL_addchar(b, '\\');
588          luaL_addchar(b, *s);
589          break;
590        }
591        case '\r': {
592          luaL_addlstring(b, "\\r", 2);
593          break;
594        }
595        case '\0': {
596          luaL_addlstring(b, "\\000", 4);
597          break;
598        }
599        default: {
600          luaL_addchar(b, *s);
601          break;
602        }
603      }
604      s++;
605    }
606    luaL_addchar(b, '"');
607  }
608  static const char *scanformat (lua_State *L, const char *strfrmt, char *form) {
609    const char *p = strfrmt;
610    while (*p != '\0' && strchr(FLAGS, *p) != NULL) p++;  &bsol;* skip flags */
611    if ((size_t)(p - strfrmt) >= sizeof(FLAGS))
612      luaL_error(L, "invalid format (repeated flags)");
613    if (isdigit(uchar(*p))) p++;  &bsol;* skip width */
614    if (isdigit(uchar(*p))) p++;  &bsol;* (2 digits at most) */
615    if (*p == '.') {
616      p++;
617      if (isdigit(uchar(*p))) p++;  &bsol;* skip precision */
618      if (isdigit(uchar(*p))) p++;  &bsol;* (2 digits at most) */
619    }
620    if (isdigit(uchar(*p)))
621      luaL_error(L, "invalid format (width or precision too long)");
622    *(form++) = '%';
623    strncpy(form, strfrmt, p - strfrmt + 1);
624    form += p - strfrmt + 1;
625    *form = '\0';
626    return p;
627  }
628  static void addintlen (char *form) {
629    size_t l = strlen(form);
630    char spec = form[l - 1];
631    strcpy(form + l - 1, LUA_INTFRMLEN);
632    form[l + sizeof(LUA_INTFRMLEN) - 2] = spec;
633    form[l + sizeof(LUA_INTFRMLEN) - 1] = '\0';
634  }
635  static int str_format (lua_State *L) {
636    int top = lua_gettop(L);
637    int arg = 1;
638    size_t sfl;
639    const char *strfrmt = luaL_checklstring(L, arg, &sfl);
640    const char *strfrmt_end = strfrmt+sfl;
641    luaL_Buffer b;
642    luaL_buffinit(L, &b);
643    while (strfrmt < strfrmt_end) {
644      if (*strfrmt != L_ESC)
645        luaL_addchar(&b, *strfrmt++);
646      else if (*++strfrmt == L_ESC)
647        luaL_addchar(&b, *strfrmt++);  &bsol;* %% */
648      else { &bsol;* format item */
649        char form[MAX_FORMAT];  &bsol;* to store the format (`%...') */
650        char buff[MAX_ITEM];  &bsol;* to store the formatted item */
651        if (++arg > top)
652          luaL_argerror(L, arg, "no value");
653        strfrmt = scanformat(L, strfrmt, form);
654        switch (*strfrmt++) {
655          case 'c': {
656            sprintf(buff, form, (int)luaL_checknumber(L, arg));
657            break;
658          }
659          case 'd':  case 'i': {
660            addintlen(form);
661            sprintf(buff, form, (LUA_INTFRM_T)luaL_checknumber(L, arg));
662            break;
663          }
664          case 'o':  case 'u':  case 'x':  case 'X': {
665            addintlen(form);
666            sprintf(buff, form, (unsigned LUA_INTFRM_T)luaL_checknumber(L, arg));
667            break;
668          }
669          case 'e':  case 'E': case 'f':
670          case 'g': case 'G': {
671            sprintf(buff, form, (double)luaL_checknumber(L, arg));
672            break;
673          }
674          case 'q': {
675            addquoted(L, &b, arg);
676            continue;  &bsol;* skip the 'addsize' at the end */
677          }
678          case 's': {
679            size_t l;
680            const char *s = luaL_checklstring(L, arg, &l);
681            if (!strchr(form, '.') && l >= 100) {
682              lua_pushvalue(L, arg);
683              luaL_addvalue(&b);
684              continue;  &bsol;* skip the `addsize' at the end */
685            }
686            else {
687              sprintf(buff, form, s);
688              break;
689            }
690          }
691          default: {  &bsol;* also treat cases `pnLlh' */
692            return luaL_error(L, "invalid option " LUA_QL("%%%c") " to "
693                                 LUA_QL("format"), *(strfrmt - 1));
694          }
695        }
696        luaL_addlstring(&b, buff, strlen(buff));
697      }
698    }
699    luaL_pushresult(&b);
700    return 1;
701  }
702  static const luaL_Reg strlib[] = {
703    {"byte", str_byte},
704    {"char", str_char},
705    {"dump", str_dump},
706    {"find", str_find},
707    {"format", str_format},
708    {"gfind", gfind_nodef},
709    {"gmatch", gmatch},
710    {"gsub", str_gsub},
711    {"len", str_len},
712    {"lower", str_lower},
713    {"match", str_match},
714    {"rep", str_rep},
715    {"reverse", str_reverse},
716    {"sub", str_sub},
717    {"upper", str_upper},
718    {NULL, NULL}
719  };
720  static void createmetatable (lua_State *L) {
721    lua_createtable(L, 0, 1);  &bsol;* create metatable for strings */
722    lua_pushliteral(L, "");  &bsol;* dummy string */
723    lua_pushvalue(L, -2);
724    lua_setmetatable(L, -2);  &bsol;* set string metatable */
725    lua_pop(L, 1);  &bsol;* pop dummy string */
726    lua_pushvalue(L, -2);  &bsol;* string library... */
727    lua_setfield(L, -2, "__index");  &bsol;* ...is the __index metamethod */
728    lua_pop(L, 1);  &bsol;* pop metatable */
729  }
730  LUALIB_API int luaopen_string (lua_State *L) {
731    luaL_register(L, LUA_STRLIBNAME, strlib);
732  #if defined(LUA_COMPAT_GFIND)
733    lua_getfield(L, -1, "gmatch");
734    lua_setfield(L, -2, "gfind");
735  #endif
736    createmetatable(L);
737    return 1;
738  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lstrlib.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lstrlib.c</div>
                </div>
                <div class="column column_space"><pre><code>426      int anchor = (*p == '^') ? (p++, 1) : 0;
427      const char *s1=s+init;
</pre></code></div>
                <div class="column column_space"><pre><code>546    int anchor = (*p == '^') ? (p++, 1) : 0;
547    int n = 0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    