
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.6143790849673203%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-tsd_win.h</h3>
            <pre><code>1  #ifdef JEMALLOC_INTERNAL_TSD_WIN_H
2  #error This file should be included only once, by tsd.h.
3  #endif
4  #define JEMALLOC_INTERNAL_TSD_WIN_H
5  typedef struct {
6  	bool initialized;
7  	tsd_t val;
8  } tsd_wrapper_t;
9  extern DWORD tsd_tsd;
10  extern tsd_wrapper_t tsd_boot_wrapper;
11  extern bool tsd_booted;
12  JEMALLOC_ALWAYS_INLINE bool
13  tsd_cleanup_wrapper(void) {
14  	DWORD error = GetLastError();
15  	tsd_wrapper_t *wrapper = (tsd_wrapper_t *)TlsGetValue(tsd_tsd);
16  	SetLastError(error);
17  	if (wrapper == NULL) {
18  		return false;
19  	}
20  	if (wrapper->initialized) {
21  		wrapper->initialized = false;
22  		tsd_cleanup(&wrapper->val);
23  		if (wrapper->initialized) {
24  			return true;
25  		}
26  	}
27  	malloc_tsd_dalloc(wrapper);
28  	return false;
29  }
30  JEMALLOC_ALWAYS_INLINE void
31  tsd_wrapper_set(tsd_wrapper_t *wrapper) {
32  	if (!TlsSetValue(tsd_tsd, (void *)wrapper)) {
33  		malloc_write("<jemalloc>: Error setting TSD\n");
34  		abort();
35  	}
36  }
37  JEMALLOC_ALWAYS_INLINE tsd_wrapper_t *
38  tsd_wrapper_get(bool init) {
39  	DWORD error = GetLastError();
40  	tsd_wrapper_t *wrapper = (tsd_wrapper_t *) TlsGetValue(tsd_tsd);
41  	SetLastError(error);
42  	if (init && unlikely(wrapper == NULL)) {
43  		wrapper = (tsd_wrapper_t *)
44  		    malloc_tsd_malloc(sizeof(tsd_wrapper_t));
45  		if (wrapper == NULL) {
46  			malloc_write("<jemalloc>: Error allocating TSD\n");
47  			abort();
48  		} else {
49  			wrapper->initialized = false;
50  			tsd_t tsd_initializer = TSD_INITIALIZER;
51  			wrapper->val = tsd_initializer;
52  		}
53  		tsd_wrapper_set(wrapper);
54  	}
55  	return wrapper;
56  }
57  JEMALLOC_ALWAYS_INLINE bool
58  tsd_boot0(void) {
<span onclick='openModal()' class='match'>59  	tsd_tsd = TlsAlloc();
60  	if (tsd_tsd == TLS_OUT_OF_INDEXES) {
61  		return true;
62  	}
63  	malloc_tsd_cleanup_register(&tsd_cleanup_wrapper);
64  	tsd_wrapper_set(&tsd_boot_wrapper);
65  	tsd_booted = true;
66  	return false;
67  }
</span>68  JEMALLOC_ALWAYS_INLINE void
69  tsd_boot1(void) {
70  	tsd_wrapper_t *wrapper;
71  	wrapper = (tsd_wrapper_t *)
72  	    malloc_tsd_malloc(sizeof(tsd_wrapper_t));
73  	if (wrapper == NULL) {
74  		malloc_write("<jemalloc>: Error allocating TSD\n");
75  		abort();
76  	}
77  	tsd_boot_wrapper.initialized = false;
78  	tsd_cleanup(&tsd_boot_wrapper.val);
79  	wrapper->initialized = false;
80  	tsd_t initializer = TSD_INITIALIZER;
81  	wrapper->val = initializer;
82  	tsd_wrapper_set(wrapper);
83  }
84  JEMALLOC_ALWAYS_INLINE bool
85  tsd_boot(void) {
86  	if (tsd_boot0()) {
87  		return true;
88  	}
89  	tsd_boot1();
90  	return false;
91  }
92  JEMALLOC_ALWAYS_INLINE bool
93  tsd_booted_get(void) {
94  	return tsd_booted;
95  }
96  JEMALLOC_ALWAYS_INLINE bool
97  tsd_get_allocates(void) {
98  	return true;
99  }
100  JEMALLOC_ALWAYS_INLINE tsd_t *
101  tsd_get(bool init) {
102  	tsd_wrapper_t *wrapper;
103  	assert(tsd_booted);
104  	wrapper = tsd_wrapper_get(init);
105  	if (tsd_get_allocates() && !init && wrapper == NULL) {
106  		return NULL;
107  	}
108  	return &wrapper->val;
109  }
110  JEMALLOC_ALWAYS_INLINE void
111  tsd_set(tsd_t *val) {
112  	tsd_wrapper_t *wrapper;
113  	assert(tsd_booted);
114  	wrapper = tsd_wrapper_get(true);
115  	if (likely(&wrapper->val != val)) {
116  		wrapper->val = *(val);
117  	}
118  	wrapper->initialized = true;
119  }
</code></pre>
        </div>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-fuse_opt.c</h3>
            <pre><code>1  #include "fuse_config.h"
2  #include "fuse_i.h"
3  #include "fuse_opt.h"
4  #include "fuse_misc.h"
5  #include <stdio.h>
6  #include <stdlib.h>
7  #include <string.h>
8  #include <assert.h>
9  struct fuse_opt_context {
10  	void *data;
11  	const struct fuse_opt *opt;
12  	fuse_opt_proc_t proc;
13  	int argctr;
14  	int argc;
15  	char **argv;
16  	struct fuse_args outargs;
17  	char *opts;
18  	int nonopt;
19  };
20  void fuse_opt_free_args(struct fuse_args *args)
21  {
22  	if (args) {
23  		if (args->argv && args->allocated) {
24  			int i;
25  			for (i = 0; i < args->argc; i++)
26  				free(args->argv[i]);
27  			free(args->argv);
28  		}
29  		args->argc = 0;
30  		args->argv = NULL;
31  		args->allocated = 0;
32  	}
33  }
34  static int alloc_failed(void)
35  {
36  	fuse_log(FUSE_LOG_ERR, "fuse: memory allocation failed\n");
37  	return -1;
38  }
39  int fuse_opt_add_arg(struct fuse_args *args, const char *arg)
40  {
41  	char **newargv;
42  	char *newarg;
43  	assert(!args->argv || args->allocated);
44  	newarg = strdup(arg);
45  	if (!newarg)
46  		return alloc_failed();
47  	newargv = realloc(args->argv, (args->argc + 2) * sizeof(char *));
48  	if (!newargv) {
49  		free(newarg);
50  		return alloc_failed();
51  	}
52  	args->argv = newargv;
53  	args->allocated = 1;
54  	args->argv[args->argc++] = newarg;
55  	args->argv[args->argc] = NULL;
56  	return 0;
57  }
58  static int fuse_opt_insert_arg_common(struct fuse_args *args, int pos,
59  				      const char *arg)
60  {
61  	assert(pos <= args->argc);
62  	if (fuse_opt_add_arg(args, arg) == -1)
63  		return -1;
64  	if (pos != args->argc - 1) {
65  		char *newarg = args->argv[args->argc - 1];
66  		memmove(&args->argv[pos + 1], &args->argv[pos],
67  			sizeof(char *) * (args->argc - pos - 1));
68  		args->argv[pos] = newarg;
69  	}
70  	return 0;
71  }
72  int fuse_opt_insert_arg(struct fuse_args *args, int pos, const char *arg)
73  {
74  	return fuse_opt_insert_arg_common(args, pos, arg);
75  }
76  static int next_arg(struct fuse_opt_context *ctx, const char *opt)
77  {
78  	if (ctx->argctr + 1 >= ctx->argc) {
79  		fuse_log(FUSE_LOG_ERR, "fuse: missing argument after `%s'\n", opt);
80  		return -1;
81  	}
82  	ctx->argctr++;
83  	return 0;
84  }
85  static int add_arg(struct fuse_opt_context *ctx, const char *arg)
86  {
87  	return fuse_opt_add_arg(&ctx->outargs, arg);
88  }
89  static int add_opt_common(char **opts, const char *opt, int esc)
90  {
91  	unsigned oldlen = *opts ? strlen(*opts) : 0;
92  	char *d = realloc(*opts, oldlen + 1 + strlen(opt) * 2 + 1);
93  	if (!d)
94  		return alloc_failed();
95  	*opts = d;
96  	if (oldlen) {
97  		d += oldlen;
98  		*d++ = ',';
99  	}
100  	for (; *opt; opt++) {
101  		if (esc && (*opt == ',' || *opt == '\\'))
102  			*d++ = '\\';
103  		*d++ = *opt;
104  	}
105  	*d = '\0';
106  	return 0;
107  }
108  int fuse_opt_add_opt(char **opts, const char *opt)
109  {
110  	return add_opt_common(opts, opt, 0);
111  }
112  int fuse_opt_add_opt_escaped(char **opts, const char *opt)
113  {
114  	return add_opt_common(opts, opt, 1);
115  }
116  static int add_opt(struct fuse_opt_context *ctx, const char *opt)
117  {
118  	return add_opt_common(&ctx->opts, opt, 1);
119  }
120  static int call_proc(struct fuse_opt_context *ctx, const char *arg, int key,
121  		     int iso)
122  {
123  	if (key == FUSE_OPT_KEY_DISCARD)
124  		return 0;
125  	if (key != FUSE_OPT_KEY_KEEP && ctx->proc) {
126  		int res = ctx->proc(ctx->data, arg, key, &ctx->outargs);
127  		if (res == -1 || !res)
128  			return res;
129  	}
130  	if (iso)
131  		return add_opt(ctx, arg);
132  	else
133  		return add_arg(ctx, arg);
134  }
135  static int match_template(const char *t, const char *arg, unsigned *sepp)
136  {
137  	int arglen = strlen(arg);
138  	const char *sep = strchr(t, '=');
139  	sep = sep ? sep : strchr(t, ' ');
140  	if (sep && (!sep[1] || sep[1] == '%')) {
141  		int tlen = sep - t;
142  		if (sep[0] == '=')
143  			tlen ++;
144  		if (arglen >= tlen && strncmp(arg, t, tlen) == 0) {
145  			*sepp = sep - t;
146  			return 1;
147  		}
148  	}
149  	if (strcmp(t, arg) == 0) {
150  		*sepp = 0;
151  		return 1;
152  	}
153  	return 0;
154  }
155  static const struct fuse_opt *find_opt(const struct fuse_opt *opt,
156  				       const char *arg, unsigned *sepp)
157  {
158  	for (; opt && opt->templ; opt++)
159  		if (match_template(opt->templ, arg, sepp))
160  			return opt;
161  	return NULL;
162  }
163  int fuse_opt_match(const struct fuse_opt *opts, const char *opt)
164  {
165  	unsigned dummy;
166  	return find_opt(opts, opt, &dummy) ? 1 : 0;
167  }
168  static int process_opt_param(void *var, const char *format, const char *param,
169  			     const char *arg)
170  {
171  	assert(format[0] == '%');
172  	if (format[1] == 's') {
173  		char **s = var;
174  		char *copy = strdup(param);
175  		if (!copy)
176  			return alloc_failed();
177  		free(*s);
178  		*s = copy;
179  	} else {
180  		if (sscanf(param, format, var) != 1) {
181  			fuse_log(FUSE_LOG_ERR, "fuse: invalid parameter in option `%s'\n", arg);
182  			return -1;
183  		}
184  	}
185  	return 0;
186  }
187  static int process_opt(struct fuse_opt_context *ctx,
188  		       const struct fuse_opt *opt, unsigned sep,
189  		       const char *arg, int iso)
190  {
191  	if (opt->offset == -1U) {
192  		if (call_proc(ctx, arg, opt->value, iso) == -1)
193  			return -1;
194  	} else {
195  		void *var = (char *)ctx->data + opt->offset;
196  		if (sep && opt->templ[sep + 1]) {
197  			const char *param = arg + sep;
198  			if (opt->templ[sep] == '=')
199  				param ++;
200  			if (process_opt_param(var, opt->templ + sep + 1,
201  					      param, arg) == -1)
202  				return -1;
203  		} else
204  			*(int *)var = opt->value;
205  	}
206  	return 0;
207  }
208  static int process_opt_sep_arg(struct fuse_opt_context *ctx,
209  			       const struct fuse_opt *opt, unsigned sep,
210  			       const char *arg, int iso)
211  {
212  	int res;
213  	char *newarg;
214  	char *param;
215  	if (next_arg(ctx, arg) == -1)
216  		return -1;
217  	param = ctx->argv[ctx->argctr];
218  	newarg = malloc(sep + strlen(param) + 1);
219  	if (!newarg)
220  		return alloc_failed();
221  	memcpy(newarg, arg, sep);
222  	strcpy(newarg + sep, param);
223  	res = process_opt(ctx, opt, sep, newarg, iso);
224  	free(newarg);
225  	return res;
226  }
227  static int process_gopt(struct fuse_opt_context *ctx, const char *arg, int iso)
228  {
229  	unsigned sep;
230  	const struct fuse_opt *opt = find_opt(ctx->opt, arg, &sep);
231  	if (opt) {
232  		for (; opt; opt = find_opt(opt + 1, arg, &sep)) {
233  			int res;
234  			if (sep && opt->templ[sep] == ' ' && !arg[sep])
235  				res = process_opt_sep_arg(ctx, opt, sep, arg,
236  							  iso);
237  			else
238  				res = process_opt(ctx, opt, sep, arg, iso);
239  			if (res == -1)
240  				return -1;
241  		}
242  		return 0;
243  	} else
244  		return call_proc(ctx, arg, FUSE_OPT_KEY_OPT, iso);
245  }
246  static int process_real_option_group(struct fuse_opt_context *ctx, char *opts)
247  {
248  	char *s = opts;
249  	char *d = s;
250  	int end = 0;
251  	while (!end) {
252  		if (*s == '\0')
253  			end = 1;
254  		if (*s == ',' || end) {
255  			int res;
256  			*d = '\0';
257  			res = process_gopt(ctx, opts, 1);
258  			if (res == -1)
259  				return -1;
260  			d = opts;
261  		} else {
262  			if (s[0] == '\\' && s[1] != '\0') {
263  				s++;
264  				if (s[0] >= '0' && s[0] <= '3' &&
265  				    s[1] >= '0' && s[1] <= '7' &&
266  				    s[2] >= '0' && s[2] <= '7') {
267  					*d++ = (s[0] - '0') * 0100 +
268  						(s[1] - '0') * 0010 +
269  						(s[2] - '0');
270  					s += 2;
271  				} else {
272  					*d++ = *s;
273  				}
274  			} else {
275  				*d++ = *s;
276  			}
277  		}
278  		s++;
279  	}
280  	return 0;
281  }
282  static int process_option_group(struct fuse_opt_context *ctx, const char *opts)
283  {
284  	int res;
<span onclick='openModal()' class='match'>285  	char *copy = strdup(opts);
286  	if (!copy) {
287  		fuse_log(FUSE_LOG_ERR, "fuse: memory allocation failed\n");
288  		return -1;
289  	}
290  	res = process_real_option_group(ctx, copy);
291  	free(copy);
292  	return res;
293  }
</span>294  static int process_one(struct fuse_opt_context *ctx, const char *arg)
295  {
296  	if (ctx->nonopt || arg[0] != '-')
297  		return call_proc(ctx, arg, FUSE_OPT_KEY_NONOPT, 0);
298  	else if (arg[1] == 'o') {
299  		if (arg[2])
300  			return process_option_group(ctx, arg + 2);
301  		else {
302  			if (next_arg(ctx, arg) == -1)
303  				return -1;
304  			return process_option_group(ctx,
305  						    ctx->argv[ctx->argctr]);
306  		}
307  	} else if (arg[1] == '-' && !arg[2]) {
308  		if (add_arg(ctx, arg) == -1)
309  			return -1;
310  		ctx->nonopt = ctx->outargs.argc;
311  		return 0;
312  	} else
313  		return process_gopt(ctx, arg, 0);
314  }
315  static int opt_parse(struct fuse_opt_context *ctx)
316  {
317  	if (ctx->argc) {
318  		if (add_arg(ctx, ctx->argv[0]) == -1)
319  			return -1;
320  	}
321  	for (ctx->argctr = 1; ctx->argctr < ctx->argc; ctx->argctr++)
322  		if (process_one(ctx, ctx->argv[ctx->argctr]) == -1)
323  			return -1;
324  	if (ctx->opts) {
325  		if (fuse_opt_insert_arg(&ctx->outargs, 1, "-o") == -1 ||
326  		    fuse_opt_insert_arg(&ctx->outargs, 2, ctx->opts) == -1)
327  			return -1;
328  	}
329  	if (ctx->nonopt && ctx->nonopt == ctx->outargs.argc &&
330  	    strcmp(ctx->outargs.argv[ctx->outargs.argc - 1], "--") == 0) {
331  		free(ctx->outargs.argv[ctx->outargs.argc - 1]);
332  		ctx->outargs.argv[--ctx->outargs.argc] = NULL;
333  	}
334  	return 0;
335  }
336  int fuse_opt_parse(struct fuse_args *args, void *data,
337  		   const struct fuse_opt opts[], fuse_opt_proc_t proc)
338  {
339  	int res;
340  	struct fuse_opt_context ctx = {
341  		.data = data,
342  		.opt = opts,
343  		.proc = proc,
344  	};
345  	if (!args || !args->argv || !args->argc)
346  		return 0;
347  	ctx.argc = args->argc;
348  	ctx.argv = args->argv;
349  	res = opt_parse(&ctx);
350  	if (res != -1) {
351  		struct fuse_args tmp = *args;
352  		*args = ctx.outargs;
353  		ctx.outargs = tmp;
354  	}
355  	free(ctx.opts);
356  	fuse_opt_free_args(&ctx.outargs);
357  	return res;
358  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-tsd_win.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-fuse_opt.c</div>
                </div>
                <div class="column column_space"><pre><code>59  	tsd_tsd = TlsAlloc();
60  	if (tsd_tsd == TLS_OUT_OF_INDEXES) {
61  		return true;
62  	}
63  	malloc_tsd_cleanup_register(&tsd_cleanup_wrapper);
64  	tsd_wrapper_set(&tsd_boot_wrapper);
65  	tsd_booted = true;
66  	return false;
67  }
</pre></code></div>
                <div class="column column_space"><pre><code>285  	char *copy = strdup(opts);
286  	if (!copy) {
287  		fuse_log(FUSE_LOG_ERR, "fuse: memory allocation failed\n");
288  		return -1;
289  	}
290  	res = process_real_option_group(ctx, copy);
291  	free(copy);
292  	return res;
293  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    