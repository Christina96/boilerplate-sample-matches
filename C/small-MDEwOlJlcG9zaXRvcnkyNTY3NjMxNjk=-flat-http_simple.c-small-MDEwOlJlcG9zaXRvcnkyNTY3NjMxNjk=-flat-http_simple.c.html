
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 120, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-http_simple.c</h3>
            <pre><code>1  #include "http_simple.h"
2  static char* g_useragent[] = {
3      "Mozilla/5.0 (Windows NT 6.3; WOW64; rv:40.0) Gecko/20100101 Firefox/40.0",
4      "Mozilla/5.0 (Windows NT 6.3; WOW64; rv:40.0) Gecko/20100101 Firefox/44.0",
5      "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36",
6      "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.11 (KHTML, like Gecko) Ubuntu/11.10 Chromium/27.0.1453.93 Chrome/27.0.1453.93 Safari/537.36",
7      "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:35.0) Gecko/20100101 Firefox/35.0",
8      "Mozilla/5.0 (compatible; WOW64; MSIE 10.0; Windows NT 6.2)",
9      "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/533.20.25 (KHTML, like Gecko) Version/5.0.4 Safari/533.20.27",
10      "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.3; Trident/7.0; .NET4.0E; .NET4.0C)",
11      "Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko",
12      "Mozilla/5.0 (Linux; Android 4.4; Nexus 5 Build/BuildID) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/30.0.0.0 Mobile Safari/537.36",
13      "Mozilla/5.0 (iPad; CPU OS 5_0 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9A334 Safari/7534.48.3",
14      "Mozilla/5.0 (iPhone; CPU iPhone OS 5_0 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9A334 Safari/7534.48.3",
15  };
16  static int g_useragent_index = -1;
17  typedef struct http_simple_local_data {
18      int has_sent_header;
19      int has_recv_header;
20      char *encode_buffer;
21      int host_matched;
22      char *recv_buffer;
23      int recv_buffer_size;
24  }http_simple_local_data;
25  void http_simple_local_data_init(http_simple_local_data* local) {
26      local->has_sent_header = 0;
27      local->has_recv_header = 0;
28      local->encode_buffer = NULL;
29      local->recv_buffer = malloc(0);
30      local->recv_buffer_size = 0;
31      local->host_matched = 0;
32      if (g_useragent_index == -1) {
33          g_useragent_index = xorshift128plus() % (sizeof(g_useragent) / sizeof(*g_useragent));
34      }
35  }
36  obfs * http_simple_new_obfs() {
37      obfs * self = new_obfs();
38      self->l_data = malloc(sizeof(http_simple_local_data));
39      http_simple_local_data_init((http_simple_local_data*)self->l_data);
40      return self;
41  }
42  void http_simple_dispose(obfs *self) {
43      http_simple_local_data *local = (http_simple_local_data*)self->l_data;
44      if (local->encode_buffer != NULL) {
45          free(local->encode_buffer);
46          local->encode_buffer = NULL;
47      }
48      free(local);
49      dispose_obfs(self);
50  }
51  char http_simple_hex(char c) {
52      if (c < 10) return c + '0';
53      return c - 10 + 'a';
54  }
55  int get_data_from_http_header(char *data, char **outdata) {
56      char *delim = "\r\n";
57      char *delim_hex = "%";
58      int outlength = 0;
59      char *buf = *outdata;
60      char *p_line;
61      p_line = strtok(data, delim);
62      {
63          char *p_hex;
64          p_hex = strtok(p_line, delim_hex);
65          while((p_hex = strtok(NULL, delim_hex)))
66          {
67              char hex = 0;
68              if(strlen(p_hex) <= 0)
69              {
70                  continue;
71              }
72              if(strlen(p_hex) > 2)
73              {
74                  char *c_hex = (char*)malloc(2);
75                  memcpy(c_hex, p_hex, 2);
76                  hex = (char)strtol(c_hex, NULL, 16);
77                  free(c_hex);
78              }
79              else
80              {
81                  hex = (char)strtol(p_hex, NULL, 16);
82              }
83              outlength += 1;
84              buf = (char*)realloc(buf, outlength);
85              buf[outlength - 1] = hex;
86          }
87      }
88      *outdata = buf;
89      return outlength;
90  }
91  void get_host_from_http_header(char *data, char **host) {
92      char* data_begin = strstr(data, "Host: ");
93      if(data_begin == NULL)
94      {
95          return;
96      }
97      data_begin += 6;
98      char* data_end = strstr(data_begin, "\r\n");
99      char* data_end_port = strstr(data_begin, ":");
100      int host_length = 0;
101      if(data_end_port != NULL)
102      {
103          host_length = data_end_port - data_begin;
104      }
105      else
106      {
107          host_length = data_end - data_begin;
108      }
109      if(host_length <= 0)
110      {
111          return;
112      }
113      memset(*host, 0x00, 1024);
114      memcpy(*host, data_begin, host_length);
115  }
116  void http_simple_encode_head(http_simple_local_data *local, char *data, int datalength) {
117      if (local->encode_buffer == NULL) {
118          local->encode_buffer = (char*)malloc(datalength * 3 + 1);
119      }
120      int pos = 0;
121      for (; pos < datalength; ++pos) {
122          local->encode_buffer[pos * 3] = '%';
123          local->encode_buffer[pos * 3 + 1] = http_simple_hex(((unsigned char)data[pos] >> 4));
124          local->encode_buffer[pos * 3 + 2] = http_simple_hex(data[pos] & 0xF);
125      }
126      local->encode_buffer[pos * 3] = 0;
127  }
128  int http_simple_client_encode(obfs *self, char **pencryptdata, int datalength, size_t* capacity) {
129      char *encryptdata = *pencryptdata;
130      http_simple_local_data *local = (http_simple_local_data*)self->l_data;
131      if (local->has_sent_header) {
132          return datalength;
133      }
134      char hosts[1024];
135      char * phost[128];
136      int host_num = 0;
137      int pos;
138      char hostport[128];
139      int head_size = self->server.head_len + (xorshift128plus() & 0x3F);
140      int outlength;
141      char * out_buffer = (char*)malloc(datalength + 2048);
142      char * body_buffer = NULL;
143      if (head_size > datalength)
144          head_size = datalength;
145      http_simple_encode_head(local, encryptdata, head_size);
146      if (self->server.param && strlen(self->server.param) == 0)
147          self->server.param = NULL;
148      strncpy(hosts, self->server.param ? self->server.param : self->server.host, sizeof hosts);
149      phost[host_num++] = hosts;
150      for (pos = 0; hosts[pos]; ++pos) {
151          if (hosts[pos] == ',') {
152              phost[host_num++] = &hosts[pos + 1];
153              hosts[pos] = 0;
154          } else if (hosts[pos] == '#') {
155              char * body_pointer = &hosts[pos + 1];
156              char * p;
157              int trans_char = 0;
158              p = body_buffer = (char*)malloc(2048);
159              for ( ; *body_pointer; ++body_pointer) {
160                  if (*body_pointer == '\\') {
161                      trans_char = 1;
162                      continue;
163                  } else if (*body_pointer == '\n') {
164                      *p = '\r';
165                      *++p = '\n';
166                      continue;
167                  }
168                  if (trans_char) {
169                      if (*body_pointer == '\\' ) {
170                          *p = '\\';
171                      } else if (*body_pointer == 'n' ) {
172                          *p = '\r';
173                          *++p = '\n';
174                      } else {
175                          *p = '\\';
176                          *p = *body_pointer;
177                      }
178                      trans_char = 0;
179                  } else {
180                      *p = *body_pointer;
181                  }
182                  ++p;
183              }
184              *p = 0;
185              hosts[pos] = 0;
186              break;
187          }
188      }
189      host_num = xorshift128plus() % host_num;
190      if (self->server.port == 80)
191          sprintf(hostport, "%s", phost[host_num]);
192      else
193          sprintf(hostport, "%s:%d", phost[host_num], self->server.port);
194      if (body_buffer) {
195          sprintf(out_buffer,
196              "GET /%s HTTP/1.1\r\n"
197              "Host: %s\r\n"
198              "%s\r\n\r\n",
199              local->encode_buffer,
200              hostport,
201              body_buffer);
202      } else {
203          sprintf(out_buffer,
204              "GET /%s HTTP/1.1\r\n"
205              "Host: %s\r\n"
206              "User-Agent: %s\r\n"
207              "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*&bsol;*;q=0.8\r\n"
208              "Accept-Language: en-US,en;q=0.8\r\n"
209              "Accept-Encoding: gzip, deflate\r\n"
210              "DNT: 1\r\n"
211              "Connection: keep-alive\r\n"
212              "\r\n",
213              local->encode_buffer,
214              hostport,
215              g_useragent[g_useragent_index]
216              );
217      }
<span onclick='openModal()' class='match'>218      outlength = strlen(out_buffer);
219      memmove(out_buffer + outlength, encryptdata + head_size, datalength - head_size);
220      outlength += datalength - head_size;
221      local->has_sent_header = 1;
222      if (*capacity < outlength) {
223          *pencryptdata = (char*)realloc(*pencryptdata, *capacity = outlength * 2);
224          encryptdata = *pencryptdata;
225      }
226      memmove(encryptdata, out_buffer, outlength);
227      free(out_buffer);
228      if (body_buffer != NULL)
229          free(body_buffer);
230      if (local->encode_buffer != NULL) {
231          free(local->encode_buffer);
232          local->encode_buffer = NULL;
233      }
234      return outlength;
235  }
236  int http_simple_server_encode(obfs *self, char **pencryptdata, int datalength, size_t* capacity) {
</span>237      char *encryptdata = *pencryptdata;
238      http_simple_local_data *local = (http_simple_local_data*)self->l_data;
239      if (local->has_sent_header) {
240          return datalength;
241      }
242      int outlength;
243      char * out_buffer = (char*)malloc(datalength + 2048);
244      time_t now;
245      struct tm *tm_now;
246      char    datetime[200];
247      time(&now);
248      tm_now = localtime(&now);
249      strftime(datetime, 200, "%a, %d %b %Y %H:%M:%S GMT", tm_now);
250      sprintf(out_buffer,
251          "HTTP/1.1 200 OK\r\nConnection: keep-alive\r\nContent-Encoding: gzip\r\nContent-Type: text/html\r\nDate: "
252          "%s"
253          "\r\nServer: nginx\r\nVary: Accept-Encoding\r\n\r\n",
254          datetime);
255      outlength = strlen(out_buffer);
256      memmove(out_buffer + outlength, encryptdata, datalength);
257      outlength += datalength;
258      local->has_sent_header = 1;
259      if (*capacity < outlength) {
260          *pencryptdata = (char*)realloc(*pencryptdata, *capacity = outlength * 2);
261          encryptdata = *pencryptdata;
262      }
263      memmove(encryptdata, out_buffer, outlength);
264      free(out_buffer);
265      return outlength;
266  }
267  int http_simple_client_decode(obfs *self, char **pencryptdata, int datalength, size_t* capacity, int *needsendback) {
268      char *encryptdata = *pencryptdata;
269      http_simple_local_data *local = (http_simple_local_data*)self->l_data;
270      *needsendback = 0;
271      if (local->has_recv_header) {
272          return datalength;
273      }
274      char* data_begin = strstr(encryptdata, "\r\n\r\n");
275      if (data_begin) {
276          int outlength;
277          data_begin += 4;
278          local->has_recv_header = 1;
279          outlength = datalength - (data_begin - encryptdata);
280          memmove(encryptdata, data_begin, outlength);
281          return outlength;
282      } else {
283          return 0;
284      }
285  }
286  int http_simple_server_decode(obfs *self, char **pencryptdata, int datalength, size_t* capacity, int *needsendback) {
287      char *encryptdata = *pencryptdata;
288      http_simple_local_data *local = (http_simple_local_data*)self->l_data;
289      *needsendback = 0;
290      if (local->has_recv_header) {
291          return datalength;
292      }
293      if(datalength != 0)
294      {
295          local->recv_buffer = (char*)realloc(local->recv_buffer, local->recv_buffer_size + datalength);
296          memmove(local->recv_buffer + local->recv_buffer_size, encryptdata, datalength);
297          local->recv_buffer_size += datalength;
298          int outlength = local->recv_buffer_size;
299          if (*capacity < outlength) {
300              *pencryptdata = (char*)realloc(*pencryptdata, *capacity = outlength * 2);
301              encryptdata = *pencryptdata;
302          }
303          memcpy(encryptdata, local->recv_buffer, local->recv_buffer_size);
304      }
305      if(local->recv_buffer_size > 10)
306      {
307          if(strstr(local->recv_buffer, "GET /") == local->recv_buffer || strstr(local->recv_buffer, "POST /") == local->recv_buffer)
308          {
309              if(local->recv_buffer_size > 65536)
310              {
311                  free(local->recv_buffer);
312                  local->recv_buffer = malloc(0);
313                  local->recv_buffer_size = 0;
314                  local->has_sent_header = 1;
315                  local->has_recv_header = 1;
316                  LOGE("http_simple: over size");
317                  return -1;
318              }
319          }
320          else
321          {
322              free(local->recv_buffer);
323              local->recv_buffer = malloc(0);
324              local->recv_buffer_size = 0;
325              local->has_sent_header = 1;
326              local->has_recv_header = 1;
327              LOGE("http_simple: not match begin");
328              return -1;
329          }
330      }
331      else
332      {
333          LOGE("http_simple: too short");
334          local->has_sent_header = 1;
335          local->has_recv_header = 1;
336          return -1;
337      }
338      char* data_begin = strstr(encryptdata, "\r\n\r\n");
339      if (data_begin) {
340          int outlength;
341          char *ret_buf = (char*)malloc(*capacity);
342          memset(ret_buf, 0x00, *capacity);
343          int ret_buf_len = 0;
344          ret_buf_len = get_data_from_http_header(encryptdata, &ret_buf);
345          if (self->server.param && strlen(self->server.param) == 0)
346          {
347              self->server.param = NULL;
348          }
349          else
350          {
351              if(local->host_matched == 0)
352              {
353                  char *host = (char*)malloc(1024);
354                  get_host_from_http_header(local->recv_buffer, &host);
355                  char hosts[1024];
356                  char * phost[128];
357                  int host_num = 0;
358                  int pos = 0;
359                  int is_match = 0;
360                  char * body_buffer = NULL;
361                  strncpy(hosts, self->server.param, sizeof hosts);
362                  phost[host_num++] = hosts;
363                  for (pos = 0; hosts[pos]; ++pos) {
364                      if (hosts[pos] == ',') {
365                          phost[host_num++] = &hosts[pos + 1];
366                          hosts[pos] = 0;
367                      } else if (hosts[pos] == '#') {
368                          char * body_pointer = &hosts[pos + 1];
369                          char * p;
370                          int trans_char = 0;
371                          p = body_buffer = (char*)malloc(2048);
372                          for ( ; *body_pointer; ++body_pointer) {
373                              if (*body_pointer == '\\') {
374                                  trans_char = 1;
375                                  continue;
376                              } else if (*body_pointer == '\n') {
377                                  *p = '\r';
378                                  *++p = '\n';
379                                  continue;
380                              }
381                              if (trans_char) {
382                                  if (*body_pointer == '\\' ) {
383                                      *p = '\\';
384                                  } else if (*body_pointer == 'n' ) {
385                                      *p = '\r';
386                                      *++p = '\n';
387                                  } else {
388                                      *p = '\\';
389                                      *p = *body_pointer;
390                                  }
391                                  trans_char = 0;
392                              } else {
393                                  *p = *body_pointer;
394                              }
395                              ++p;
396                          }
397                          *p = 0;
398                          hosts[pos] = 0;
399                          break;
400                      }
401                  }
402                  for(pos = 0; pos < host_num; pos++)
403                  {
404                      if(strcmp(phost[pos], host) == 0)
405                      {
406                          is_match = 1;
407                          local->host_matched = 1;
408                      }
409                  }
410                  if(is_match == 0)
411                  {
412                      free(local->recv_buffer);
413                      local->recv_buffer = malloc(0);
414                      local->recv_buffer_size = 0;
415                      local->has_sent_header = 1;
416                      local->has_recv_header = 1;
417                      LOGE("http_simple: not match host, host: %s", host);
418                      return -1;
419                  }
420                  free(host);
421              }
422          }
423          if(ret_buf_len <= 0)
424          {
425              return -1;
426          }
427          data_begin += 4;
428          local->has_recv_header = 1;
429          ret_buf = (char*)realloc(ret_buf, ret_buf_len + datalength - (data_begin - encryptdata));
430          outlength = ret_buf_len + datalength - (data_begin - encryptdata);
431          memcpy(ret_buf + ret_buf_len, data_begin, datalength - (data_begin - encryptdata));
432          if (*capacity < outlength) {
433              *pencryptdata = (char*)realloc(*pencryptdata, *capacity = outlength * 2);
434              encryptdata = *pencryptdata;
435          }
436          memcpy(encryptdata, ret_buf, outlength);
437          free(ret_buf);
438          return outlength;
439      } else {
440          return 0;
441      }
442  }
443  void boundary(char result[])
444  {
445      char *str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
446      int i,lstr;
447      char ss[3] = {0};
448      lstr = strlen(str);
449      srand((unsigned int)time((time_t *)NULL));
450      for(i = 0; i < 32; ++i)
451      {
452          sprintf(ss, "%c", str[(rand()%lstr)]);
453          strcat(result, ss);
454      }
455  }
456  int http_post_client_encode(obfs *self, char **pencryptdata, int datalength, size_t* capacity) {
457      char *encryptdata = *pencryptdata;
458      http_simple_local_data *local = (http_simple_local_data*)self->l_data;
459      if (local->has_sent_header) {
460          return datalength;
461      }
462      char hosts[1024];
463      char * phost[128];
464      int host_num = 0;
465      int pos;
466      char hostport[128];
467      int head_size = self->server.head_len + (xorshift128plus() & 0x3F);
468      int outlength;
469      char * out_buffer = (char*)malloc(datalength + 2048);
470      char * body_buffer = NULL;
471      if (head_size > datalength)
472          head_size = datalength;
473      http_simple_encode_head(local, encryptdata, head_size);
474      if (self->server.param && strlen(self->server.param) == 0)
475          self->server.param = NULL;
476      strncpy(hosts, self->server.param ? self->server.param : self->server.host, sizeof hosts);
477      phost[host_num++] = hosts;
478      for (pos = 0; hosts[pos]; ++pos) {
479          if (hosts[pos] == ',') {
480              phost[host_num++] = &hosts[pos + 1];
481              hosts[pos] = 0;
482          } else if (hosts[pos] == '#') {
483              char * body_pointer = &hosts[pos + 1];
484              char * p;
485              int trans_char = 0;
486              p = body_buffer = (char*)malloc(2048);
487              for ( ; *body_pointer; ++body_pointer) {
488                  if (*body_pointer == '\\') {
489                      trans_char = 1;
490                      continue;
491                  } else if (*body_pointer == '\n') {
492                      *p = '\r';
493                      *++p = '\n';
494                      continue;
495                  }
496                  if (trans_char) {
497                      if (*body_pointer == '\\' ) {
498                          *p = '\\';
499                      } else if (*body_pointer == 'n' ) {
500                          *p = '\r';
501                          *++p = '\n';
502                      } else {
503                          *p = '\\';
504                          *p = *body_pointer;
505                      }
506                      trans_char = 0;
507                  } else {
508                      *p = *body_pointer;
509                  }
510                  ++p;
511              }
512              *p = 0;
513              hosts[pos] = 0;
514              break;
515          }
516      }
517      host_num = xorshift128plus() % host_num;
518      if (self->server.port == 80)
519          sprintf(hostport, "%s", phost[host_num]);
520      else
521          sprintf(hostport, "%s:%d", phost[host_num], self->server.port);
522      if (body_buffer) {
523          sprintf(out_buffer,
524              "POST /%s HTTP/1.1\r\n"
525              "Host: %s\r\n"
526              "%s\r\n\r\n",
527              local->encode_buffer,
528              hostport,
529              body_buffer);
530      } else {
531          char result[33] = {0};
532          boundary(result);
533          sprintf(out_buffer,
534              "POST /%s HTTP/1.1\r\n"
535              "Host: %s\r\n"
536              "User-Agent: %s\r\n"
537              "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*&bsol;*;q=0.8\r\n"
538              "Accept-Language: en-US,en;q=0.8\r\n"
539              "Accept-Encoding: gzip, deflate\r\n"
540              "Content-Type: multipart/form-data; boundary=%s\r\n"
541              "DNT: 1\r\n"
542              "Connection: keep-alive\r\n"
543              "\r\n",
544              local->encode_buffer,
545              hostport,
546              g_useragent[g_useragent_index],
547              result
548              );
549      }
550      outlength = strlen(out_buffer);
551      memmove(out_buffer + outlength, encryptdata + head_size, datalength - head_size);
552      outlength += datalength - head_size;
553      local->has_sent_header = 1;
554      if (*capacity < outlength) {
555          *pencryptdata = (char*)realloc(*pencryptdata, *capacity = outlength * 2);
556          encryptdata = *pencryptdata;
557      }
558      memmove(encryptdata, out_buffer, outlength);
559      free(out_buffer);
560      if (body_buffer != NULL)
561          free(body_buffer);
562      if (local->encode_buffer != NULL) {
563          free(local->encode_buffer);
564          local->encode_buffer = NULL;
565      }
566      return outlength;
567  }
</code></pre>
        </div>
        <div class="column">
            <h3>small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-http_simple.c</h3>
            <pre><code>1  #include "http_simple.h"
2  static char* g_useragent[] = {
3      "Mozilla/5.0 (Windows NT 6.3; WOW64; rv:40.0) Gecko/20100101 Firefox/40.0",
4      "Mozilla/5.0 (Windows NT 6.3; WOW64; rv:40.0) Gecko/20100101 Firefox/44.0",
5      "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36",
6      "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.11 (KHTML, like Gecko) Ubuntu/11.10 Chromium/27.0.1453.93 Chrome/27.0.1453.93 Safari/537.36",
7      "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:35.0) Gecko/20100101 Firefox/35.0",
8      "Mozilla/5.0 (compatible; WOW64; MSIE 10.0; Windows NT 6.2)",
9      "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/533.20.25 (KHTML, like Gecko) Version/5.0.4 Safari/533.20.27",
10      "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.3; Trident/7.0; .NET4.0E; .NET4.0C)",
11      "Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko",
12      "Mozilla/5.0 (Linux; Android 4.4; Nexus 5 Build/BuildID) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/30.0.0.0 Mobile Safari/537.36",
13      "Mozilla/5.0 (iPad; CPU OS 5_0 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9A334 Safari/7534.48.3",
14      "Mozilla/5.0 (iPhone; CPU iPhone OS 5_0 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9A334 Safari/7534.48.3",
15  };
16  static int g_useragent_index = -1;
17  typedef struct http_simple_local_data {
18      int has_sent_header;
19      int has_recv_header;
20      char *encode_buffer;
21      int host_matched;
22      char *recv_buffer;
23      int recv_buffer_size;
24  }http_simple_local_data;
25  void http_simple_local_data_init(http_simple_local_data* local) {
26      local->has_sent_header = 0;
27      local->has_recv_header = 0;
28      local->encode_buffer = NULL;
29      local->recv_buffer = malloc(0);
30      local->recv_buffer_size = 0;
31      local->host_matched = 0;
32      if (g_useragent_index == -1) {
33          g_useragent_index = xorshift128plus() % (sizeof(g_useragent) / sizeof(*g_useragent));
34      }
35  }
36  obfs * http_simple_new_obfs() {
37      obfs * self = new_obfs();
38      self->l_data = malloc(sizeof(http_simple_local_data));
39      http_simple_local_data_init((http_simple_local_data*)self->l_data);
40      return self;
41  }
42  void http_simple_dispose(obfs *self) {
43      http_simple_local_data *local = (http_simple_local_data*)self->l_data;
44      if (local->encode_buffer != NULL) {
45          free(local->encode_buffer);
46          local->encode_buffer = NULL;
47      }
48      free(local);
49      dispose_obfs(self);
50  }
51  char http_simple_hex(char c) {
52      if (c < 10) return c + '0';
53      return c - 10 + 'a';
54  }
55  int get_data_from_http_header(char *data, char **outdata) {
56      char *delim = "\r\n";
57      char *delim_hex = "%";
58      int outlength = 0;
59      char *buf = *outdata;
60      char *p_line;
61      p_line = strtok(data, delim);
62      {
63          char *p_hex;
64          p_hex = strtok(p_line, delim_hex);
65          while((p_hex = strtok(NULL, delim_hex)))
66          {
67              char hex = 0;
68              if(strlen(p_hex) <= 0)
69              {
70                  continue;
71              }
72              if(strlen(p_hex) > 2)
73              {
74                  char *c_hex = (char*)malloc(2);
75                  memcpy(c_hex, p_hex, 2);
76                  hex = (char)strtol(c_hex, NULL, 16);
77                  free(c_hex);
78              }
79              else
80              {
81                  hex = (char)strtol(p_hex, NULL, 16);
82              }
83              outlength += 1;
84              buf = (char*)realloc(buf, outlength);
85              buf[outlength - 1] = hex;
86          }
87      }
88      *outdata = buf;
89      return outlength;
90  }
91  void get_host_from_http_header(char *data, char **host) {
92      char* data_begin = strstr(data, "Host: ");
93      if(data_begin == NULL)
94      {
95          return;
96      }
97      data_begin += 6;
98      char* data_end = strstr(data_begin, "\r\n");
99      char* data_end_port = strstr(data_begin, ":");
100      int host_length = 0;
101      if(data_end_port != NULL)
102      {
103          host_length = data_end_port - data_begin;
104      }
105      else
106      {
107          host_length = data_end - data_begin;
108      }
109      if(host_length <= 0)
110      {
111          return;
112      }
113      memset(*host, 0x00, 1024);
114      memcpy(*host, data_begin, host_length);
115  }
116  void http_simple_encode_head(http_simple_local_data *local, char *data, int datalength) {
117      if (local->encode_buffer == NULL) {
118          local->encode_buffer = (char*)malloc(datalength * 3 + 1);
119      }
120      int pos = 0;
121      for (; pos < datalength; ++pos) {
122          local->encode_buffer[pos * 3] = '%';
123          local->encode_buffer[pos * 3 + 1] = http_simple_hex(((unsigned char)data[pos] >> 4));
124          local->encode_buffer[pos * 3 + 2] = http_simple_hex(data[pos] & 0xF);
125      }
126      local->encode_buffer[pos * 3] = 0;
127  }
128  int http_simple_client_encode(obfs *self, char **pencryptdata, int datalength, size_t* capacity) {
129      char *encryptdata = *pencryptdata;
130      http_simple_local_data *local = (http_simple_local_data*)self->l_data;
131      if (local->has_sent_header) {
132          return datalength;
133      }
134      char hosts[1024];
135      char * phost[128];
136      int host_num = 0;
137      int pos;
138      char hostport[128];
139      int head_size = self->server.head_len + (xorshift128plus() & 0x3F);
140      int outlength;
141      char * out_buffer = (char*)malloc(datalength + 2048);
142      char * body_buffer = NULL;
143      if (head_size > datalength)
144          head_size = datalength;
145      http_simple_encode_head(local, encryptdata, head_size);
146      if (self->server.param && strlen(self->server.param) == 0)
147          self->server.param = NULL;
148      strncpy(hosts, self->server.param ? self->server.param : self->server.host, sizeof hosts);
149      phost[host_num++] = hosts;
150      for (pos = 0; hosts[pos]; ++pos) {
151          if (hosts[pos] == ',') {
152              phost[host_num++] = &hosts[pos + 1];
153              hosts[pos] = 0;
154          } else if (hosts[pos] == '#') {
155              char * body_pointer = &hosts[pos + 1];
156              char * p;
157              int trans_char = 0;
158              p = body_buffer = (char*)malloc(2048);
159              for ( ; *body_pointer; ++body_pointer) {
160                  if (*body_pointer == '\\') {
161                      trans_char = 1;
162                      continue;
163                  } else if (*body_pointer == '\n') {
164                      *p = '\r';
165                      *++p = '\n';
166                      continue;
167                  }
168                  if (trans_char) {
169                      if (*body_pointer == '\\' ) {
170                          *p = '\\';
171                      } else if (*body_pointer == 'n' ) {
172                          *p = '\r';
173                          *++p = '\n';
174                      } else {
175                          *p = '\\';
176                          *p = *body_pointer;
177                      }
178                      trans_char = 0;
179                  } else {
180                      *p = *body_pointer;
181                  }
182                  ++p;
183              }
184              *p = 0;
185              hosts[pos] = 0;
186              break;
187          }
188      }
189      host_num = xorshift128plus() % host_num;
190      if (self->server.port == 80)
191          sprintf(hostport, "%s", phost[host_num]);
192      else
193          sprintf(hostport, "%s:%d", phost[host_num], self->server.port);
194      if (body_buffer) {
195          sprintf(out_buffer,
196              "GET /%s HTTP/1.1\r\n"
197              "Host: %s\r\n"
198              "%s\r\n\r\n",
199              local->encode_buffer,
200              hostport,
201              body_buffer);
202      } else {
203          sprintf(out_buffer,
204              "GET /%s HTTP/1.1\r\n"
205              "Host: %s\r\n"
206              "User-Agent: %s\r\n"
207              "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*&bsol;*;q=0.8\r\n"
208              "Accept-Language: en-US,en;q=0.8\r\n"
209              "Accept-Encoding: gzip, deflate\r\n"
210              "DNT: 1\r\n"
211              "Connection: keep-alive\r\n"
212              "\r\n",
213              local->encode_buffer,
214              hostport,
215              g_useragent[g_useragent_index]
216              );
217      }
218      outlength = strlen(out_buffer);
219      memmove(out_buffer + outlength, encryptdata + head_size, datalength - head_size);
220      outlength += datalength - head_size;
221      local->has_sent_header = 1;
222      if (*capacity < outlength) {
223          *pencryptdata = (char*)realloc(*pencryptdata, *capacity = outlength * 2);
224          encryptdata = *pencryptdata;
225      }
226      memmove(encryptdata, out_buffer, outlength);
227      free(out_buffer);
228      if (body_buffer != NULL)
229          free(body_buffer);
230      if (local->encode_buffer != NULL) {
231          free(local->encode_buffer);
232          local->encode_buffer = NULL;
233      }
234      return outlength;
235  }
236  int http_simple_server_encode(obfs *self, char **pencryptdata, int datalength, size_t* capacity) {
237      char *encryptdata = *pencryptdata;
238      http_simple_local_data *local = (http_simple_local_data*)self->l_data;
239      if (local->has_sent_header) {
240          return datalength;
241      }
242      int outlength;
243      char * out_buffer = (char*)malloc(datalength + 2048);
244      time_t now;
245      struct tm *tm_now;
246      char    datetime[200];
247      time(&now);
248      tm_now = localtime(&now);
249      strftime(datetime, 200, "%a, %d %b %Y %H:%M:%S GMT", tm_now);
250      sprintf(out_buffer,
251          "HTTP/1.1 200 OK\r\nConnection: keep-alive\r\nContent-Encoding: gzip\r\nContent-Type: text/html\r\nDate: "
252          "%s"
253          "\r\nServer: nginx\r\nVary: Accept-Encoding\r\n\r\n",
254          datetime);
255      outlength = strlen(out_buffer);
256      memmove(out_buffer + outlength, encryptdata, datalength);
257      outlength += datalength;
258      local->has_sent_header = 1;
259      if (*capacity < outlength) {
260          *pencryptdata = (char*)realloc(*pencryptdata, *capacity = outlength * 2);
261          encryptdata = *pencryptdata;
262      }
263      memmove(encryptdata, out_buffer, outlength);
264      free(out_buffer);
265      return outlength;
266  }
267  int http_simple_client_decode(obfs *self, char **pencryptdata, int datalength, size_t* capacity, int *needsendback) {
268      char *encryptdata = *pencryptdata;
269      http_simple_local_data *local = (http_simple_local_data*)self->l_data;
270      *needsendback = 0;
271      if (local->has_recv_header) {
272          return datalength;
273      }
274      char* data_begin = strstr(encryptdata, "\r\n\r\n");
275      if (data_begin) {
276          int outlength;
277          data_begin += 4;
278          local->has_recv_header = 1;
279          outlength = datalength - (data_begin - encryptdata);
280          memmove(encryptdata, data_begin, outlength);
281          return outlength;
282      } else {
283          return 0;
284      }
285  }
286  int http_simple_server_decode(obfs *self, char **pencryptdata, int datalength, size_t* capacity, int *needsendback) {
287      char *encryptdata = *pencryptdata;
288      http_simple_local_data *local = (http_simple_local_data*)self->l_data;
289      *needsendback = 0;
290      if (local->has_recv_header) {
291          return datalength;
292      }
293      if(datalength != 0)
294      {
295          local->recv_buffer = (char*)realloc(local->recv_buffer, local->recv_buffer_size + datalength);
296          memmove(local->recv_buffer + local->recv_buffer_size, encryptdata, datalength);
297          local->recv_buffer_size += datalength;
298          int outlength = local->recv_buffer_size;
299          if (*capacity < outlength) {
300              *pencryptdata = (char*)realloc(*pencryptdata, *capacity = outlength * 2);
301              encryptdata = *pencryptdata;
302          }
303          memcpy(encryptdata, local->recv_buffer, local->recv_buffer_size);
304      }
305      if(local->recv_buffer_size > 10)
306      {
307          if(strstr(local->recv_buffer, "GET /") == local->recv_buffer || strstr(local->recv_buffer, "POST /") == local->recv_buffer)
308          {
309              if(local->recv_buffer_size > 65536)
310              {
311                  free(local->recv_buffer);
312                  local->recv_buffer = malloc(0);
313                  local->recv_buffer_size = 0;
314                  local->has_sent_header = 1;
315                  local->has_recv_header = 1;
316                  LOGE("http_simple: over size");
317                  return -1;
318              }
319          }
320          else
321          {
322              free(local->recv_buffer);
323              local->recv_buffer = malloc(0);
324              local->recv_buffer_size = 0;
325              local->has_sent_header = 1;
326              local->has_recv_header = 1;
327              LOGE("http_simple: not match begin");
328              return -1;
329          }
330      }
331      else
332      {
333          LOGE("http_simple: too short");
334          local->has_sent_header = 1;
335          local->has_recv_header = 1;
336          return -1;
337      }
338      char* data_begin = strstr(encryptdata, "\r\n\r\n");
339      if (data_begin) {
340          int outlength;
341          char *ret_buf = (char*)malloc(*capacity);
342          memset(ret_buf, 0x00, *capacity);
343          int ret_buf_len = 0;
344          ret_buf_len = get_data_from_http_header(encryptdata, &ret_buf);
345          if (self->server.param && strlen(self->server.param) == 0)
346          {
347              self->server.param = NULL;
348          }
349          else
350          {
351              if(local->host_matched == 0)
352              {
353                  char *host = (char*)malloc(1024);
354                  get_host_from_http_header(local->recv_buffer, &host);
355                  char hosts[1024];
356                  char * phost[128];
357                  int host_num = 0;
358                  int pos = 0;
359                  int is_match = 0;
360                  char * body_buffer = NULL;
361                  strncpy(hosts, self->server.param, sizeof hosts);
362                  phost[host_num++] = hosts;
363                  for (pos = 0; hosts[pos]; ++pos) {
364                      if (hosts[pos] == ',') {
365                          phost[host_num++] = &hosts[pos + 1];
366                          hosts[pos] = 0;
367                      } else if (hosts[pos] == '#') {
368                          char * body_pointer = &hosts[pos + 1];
369                          char * p;
370                          int trans_char = 0;
371                          p = body_buffer = (char*)malloc(2048);
372                          for ( ; *body_pointer; ++body_pointer) {
373                              if (*body_pointer == '\\') {
374                                  trans_char = 1;
375                                  continue;
376                              } else if (*body_pointer == '\n') {
377                                  *p = '\r';
378                                  *++p = '\n';
379                                  continue;
380                              }
381                              if (trans_char) {
382                                  if (*body_pointer == '\\' ) {
383                                      *p = '\\';
384                                  } else if (*body_pointer == 'n' ) {
385                                      *p = '\r';
386                                      *++p = '\n';
387                                  } else {
388                                      *p = '\\';
389                                      *p = *body_pointer;
390                                  }
391                                  trans_char = 0;
392                              } else {
393                                  *p = *body_pointer;
394                              }
395                              ++p;
396                          }
397                          *p = 0;
398                          hosts[pos] = 0;
399                          break;
400                      }
401                  }
402                  for(pos = 0; pos < host_num; pos++)
403                  {
404                      if(strcmp(phost[pos], host) == 0)
405                      {
406                          is_match = 1;
407                          local->host_matched = 1;
408                      }
409                  }
410                  if(is_match == 0)
411                  {
412                      free(local->recv_buffer);
413                      local->recv_buffer = malloc(0);
414                      local->recv_buffer_size = 0;
415                      local->has_sent_header = 1;
416                      local->has_recv_header = 1;
417                      LOGE("http_simple: not match host, host: %s", host);
418                      return -1;
419                  }
420                  free(host);
421              }
422          }
423          if(ret_buf_len <= 0)
424          {
425              return -1;
426          }
427          data_begin += 4;
428          local->has_recv_header = 1;
429          ret_buf = (char*)realloc(ret_buf, ret_buf_len + datalength - (data_begin - encryptdata));
430          outlength = ret_buf_len + datalength - (data_begin - encryptdata);
431          memcpy(ret_buf + ret_buf_len, data_begin, datalength - (data_begin - encryptdata));
432          if (*capacity < outlength) {
433              *pencryptdata = (char*)realloc(*pencryptdata, *capacity = outlength * 2);
434              encryptdata = *pencryptdata;
435          }
436          memcpy(encryptdata, ret_buf, outlength);
437          free(ret_buf);
438          return outlength;
439      } else {
440          return 0;
441      }
442  }
443  void boundary(char result[])
444  {
445      char *str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
446      int i,lstr;
447      char ss[3] = {0};
448      lstr = strlen(str);
449      srand((unsigned int)time((time_t *)NULL));
450      for(i = 0; i < 32; ++i)
451      {
452          sprintf(ss, "%c", str[(rand()%lstr)]);
453          strcat(result, ss);
454      }
455  }
456  int http_post_client_encode(obfs *self, char **pencryptdata, int datalength, size_t* capacity) {
457      char *encryptdata = *pencryptdata;
458      http_simple_local_data *local = (http_simple_local_data*)self->l_data;
459      if (local->has_sent_header) {
460          return datalength;
461      }
462      char hosts[1024];
463      char * phost[128];
464      int host_num = 0;
465      int pos;
466      char hostport[128];
467      int head_size = self->server.head_len + (xorshift128plus() & 0x3F);
468      int outlength;
469      char * out_buffer = (char*)malloc(datalength + 2048);
470      char * body_buffer = NULL;
471      if (head_size > datalength)
472          head_size = datalength;
473      http_simple_encode_head(local, encryptdata, head_size);
474      if (self->server.param && strlen(self->server.param) == 0)
475          self->server.param = NULL;
476      strncpy(hosts, self->server.param ? self->server.param : self->server.host, sizeof hosts);
477      phost[host_num++] = hosts;
478      for (pos = 0; hosts[pos]; ++pos) {
479          if (hosts[pos] == ',') {
480              phost[host_num++] = &hosts[pos + 1];
481              hosts[pos] = 0;
482          } else if (hosts[pos] == '#') {
483              char * body_pointer = &hosts[pos + 1];
484              char * p;
485              int trans_char = 0;
486              p = body_buffer = (char*)malloc(2048);
487              for ( ; *body_pointer; ++body_pointer) {
488                  if (*body_pointer == '\\') {
489                      trans_char = 1;
490                      continue;
491                  } else if (*body_pointer == '\n') {
492                      *p = '\r';
493                      *++p = '\n';
494                      continue;
495                  }
496                  if (trans_char) {
497                      if (*body_pointer == '\\' ) {
498                          *p = '\\';
499                      } else if (*body_pointer == 'n' ) {
500                          *p = '\r';
501                          *++p = '\n';
502                      } else {
503                          *p = '\\';
504                          *p = *body_pointer;
505                      }
506                      trans_char = 0;
507                  } else {
508                      *p = *body_pointer;
509                  }
510                  ++p;
511              }
512              *p = 0;
513              hosts[pos] = 0;
514              break;
515          }
516      }
517      host_num = xorshift128plus() % host_num;
518      if (self->server.port == 80)
519          sprintf(hostport, "%s", phost[host_num]);
520      else
521          sprintf(hostport, "%s:%d", phost[host_num], self->server.port);
522      if (body_buffer) {
523          sprintf(out_buffer,
524              "POST /%s HTTP/1.1\r\n"
525              "Host: %s\r\n"
526              "%s\r\n\r\n",
527              local->encode_buffer,
528              hostport,
529              body_buffer);
530      } else {
531          char result[33] = {0};
532          boundary(result);
533          sprintf(out_buffer,
534              "POST /%s HTTP/1.1\r\n"
535              "Host: %s\r\n"
536              "User-Agent: %s\r\n"
537              "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*&bsol;*;q=0.8\r\n"
538              "Accept-Language: en-US,en;q=0.8\r\n"
539              "Accept-Encoding: gzip, deflate\r\n"
540              "Content-Type: multipart/form-data; boundary=%s\r\n"
541              "DNT: 1\r\n"
542              "Connection: keep-alive\r\n"
543              "\r\n",
544              local->encode_buffer,
545              hostport,
546              g_useragent[g_useragent_index],
547              result
548              );
549      }
<span onclick='openModal()' class='match'>550      outlength = strlen(out_buffer);
551      memmove(out_buffer + outlength, encryptdata + head_size, datalength - head_size);
552      outlength += datalength - head_size;
553      local->has_sent_header = 1;
554      if (*capacity < outlength) {
555          *pencryptdata = (char*)realloc(*pencryptdata, *capacity = outlength * 2);
556          encryptdata = *pencryptdata;
557      }
558      memmove(encryptdata, out_buffer, outlength);
559      free(out_buffer);
560      if (body_buffer != NULL)
561          free(body_buffer);
562      if (local->encode_buffer != NULL) {
563          free(local->encode_buffer);
564          local->encode_buffer = NULL;
565      }
566      return outlength;
567  }
</span></code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-http_simple.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-http_simple.c</div>
                </div>
                <div class="column column_space"><pre><code>218      outlength = strlen(out_buffer);
219      memmove(out_buffer + outlength, encryptdata + head_size, datalength - head_size);
220      outlength += datalength - head_size;
221      local->has_sent_header = 1;
222      if (*capacity < outlength) {
223          *pencryptdata = (char*)realloc(*pencryptdata, *capacity = outlength * 2);
224          encryptdata = *pencryptdata;
225      }
226      memmove(encryptdata, out_buffer, outlength);
227      free(out_buffer);
228      if (body_buffer != NULL)
229          free(body_buffer);
230      if (local->encode_buffer != NULL) {
231          free(local->encode_buffer);
232          local->encode_buffer = NULL;
233      }
234      return outlength;
235  }
236  int http_simple_server_encode(obfs *self, char **pencryptdata, int datalength, size_t* capacity) {
</pre></code></div>
                <div class="column column_space"><pre><code>550      outlength = strlen(out_buffer);
551      memmove(out_buffer + outlength, encryptdata + head_size, datalength - head_size);
552      outlength += datalength - head_size;
553      local->has_sent_header = 1;
554      if (*capacity < outlength) {
555          *pencryptdata = (char*)realloc(*pencryptdata, *capacity = outlength * 2);
556          encryptdata = *pencryptdata;
557      }
558      memmove(encryptdata, out_buffer, outlength);
559      free(out_buffer);
560      if (body_buffer != NULL)
561          free(body_buffer);
562      if (local->encode_buffer != NULL) {
563          free(local->encode_buffer);
564          local->encode_buffer = NULL;
565      }
566      return outlength;
567  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    