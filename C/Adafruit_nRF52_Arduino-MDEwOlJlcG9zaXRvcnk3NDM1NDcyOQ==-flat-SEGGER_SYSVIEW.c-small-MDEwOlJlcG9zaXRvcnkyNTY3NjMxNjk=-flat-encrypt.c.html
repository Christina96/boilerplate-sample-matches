
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.3984575835475574%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-SEGGER_SYSVIEW.c</h3>
            <pre><code>1  #include "SEGGER_SYSVIEW_Int.h"
2  #include "SEGGER_RTT.h"
3  #include <string.h>
4  #include <stdlib.h>
5  #include <stdarg.h>
6  #if SEGGER_SYSVIEW_ID_SHIFT
7    #define SHRINK_ID(Id)   (((Id) - _SYSVIEW_Globals.RAMBaseAddress) >> SEGGER_SYSVIEW_ID_SHIFT)
8  #else
9    #define SHRINK_ID(Id)   ((Id) - _SYSVIEW_Globals.RAMBaseAddress)
10  #endif
11  #if SEGGER_SYSVIEW_RTT_CHANNEL > 0
12    #define CHANNEL_ID_UP   SEGGER_SYSVIEW_RTT_CHANNEL
13    #define CHANNEL_ID_DOWN SEGGER_SYSVIEW_RTT_CHANNEL
14  #else
15    #define CHANNEL_ID_UP   _SYSVIEW_Globals.UpChannel
16    #define CHANNEL_ID_DOWN _SYSVIEW_Globals.DownChannel
17  #endif
18  #if SEGGER_SYSVIEW_TIMESTAMP_BITS < 32  
19    #define MAKE_DELTA_32BIT(Delta) Delta <<= 32 - SEGGER_SYSVIEW_TIMESTAMP_BITS; \
20                                    Delta >>= 32 - SEGGER_SYSVIEW_TIMESTAMP_BITS;
21  #else
22    #define MAKE_DELTA_32BIT(Delta)
23  #endif
24  #define ENABLE_STATE_OFF        0
25  #define ENABLE_STATE_ON         1
26  #define ENABLE_STATE_DROPPING   2
27  #define FORMAT_FLAG_LEFT_JUSTIFY   (1u << 0)
28  #define FORMAT_FLAG_PAD_ZERO       (1u << 1)
29  #define FORMAT_FLAG_PRINT_SIGN     (1u << 2)
30  #define FORMAT_FLAG_ALTERNATE      (1u << 3)
31  #define MODULE_EVENT_OFFSET        (512)
32  typedef struct {
33    U8*       pBuffer;
34    U8*       pPayload;
35    U8*       pPayloadStart;
36    U32       Options;
37    unsigned  Cnt;
38  } SEGGER_SYSVIEW_PRINTF_DESC;
39  typedef struct {
40          U8                      EnableState;   
41          U8                      UpChannel;
42          U8                      RecursionCnt;
43          U32                     SysFreq;
44          U32                     CPUFreq;
45          U32                     LastTxTimeStamp;
46          U32                     RAMBaseAddress;
47  #if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
48          U32                     PacketCount;
49  #else
50          U32                     DropCount;
51          U8                      DownChannel;
52  #endif
53          U32                     DisabledEvents;
54    const SEGGER_SYSVIEW_OS_API*  pOSAPI;
55          SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC*   pfSendSysDesc;
56  } SEGGER_SYSVIEW_GLOBALS;
57  static void _SendPacket(U8* pStartPacket, U8* pEndPacket, unsigned int EventId);
58  static const U8 _abSync[10] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
59  #ifdef SEGGER_SYSVIEW_SECTION
60    #if (defined __GNUC__)
61      __attribute__ ((section (SEGGER_SYSVIEW_SECTION))) static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
62      #if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
63      __attribute__ ((section (SEGGER_SYSVIEW_SECTION))) static char _DownBuffer[8];  
64      #endif
65    #elif (defined __ICCARM__) || (defined __ICCRX__)
66      #pragma location=SEGGER_SYSVIEW_SECTION
67      static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
68      #pragma location=SEGGER_SYSVIEW_SECTION
69      static char _DownBuffer[8];  
70    #elif (defined __CC_ARM)
71      __attribute__ ((section (SEGGER_SYSVIEW_SECTION), zero_init)) static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
72      #if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
73      __attribute__ ((section (SEGGER_SYSVIEW_SECTION), zero_init)) static char _DownBuffer[8];  
74      #endif
75    #else
76      static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
77      #if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
78      static char _DownBuffer[8];  
79      #endif
80    #endif
81  #else
82      static char _UpBuffer  [SEGGER_SYSVIEW_RTT_BUFFER_SIZE];
83      #if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
84      static char _DownBuffer[8];  
85      #endif
86  #endif
87  static SEGGER_SYSVIEW_GLOBALS _SYSVIEW_Globals;
88  static SEGGER_SYSVIEW_MODULE* _pFirstModule;
89  static U8                     _NumModules;
90  #define ENCODE_U32(pDest, Value) {                                                  \
91                                     U8* pSysviewPointer;                             \
92                                     U32 SysViewData;                                 \
93                                     pSysviewPointer = pDest;                         \
94                                     SysViewData = Value;                             \
95                                     while(SysViewData > 0x7F) {                      \
96                                       *pSysviewPointer++ = (U8)(SysViewData | 0x80); \
97                                       SysViewData >>= 7;                             \
98                                     };                                               \
99                                     *pSysviewPointer++ = (U8)SysViewData;            \
100                                     pDest = pSysviewPointer;                         \
101                                   };
102  #if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 1)
103  static U8 _aPacket[SEGGER_SYSVIEW_MAX_PACKET_SIZE];
104  #define RECORD_START(PacketSize)  SEGGER_SYSVIEW_LOCK();                            \
105                                    pPayloadStart = _PreparePacket(_aPacket);
106  #define RECORD_END()              SEGGER_SYSVIEW_UNLOCK()
107  #else
108  #define RECORD_START(PacketSize)  U8 aPacket[(PacketSize)];                         \
109                                    pPayloadStart = _PreparePacket(aPacket);          \
110  
111  #define RECORD_END()
112  #endif
113  static U8* _EncodeData(U8* pPayload, const char* pSrc, unsigned int NumBytes) {
114    unsigned int n;
115    n = 0;
116    *pPayload++ = NumBytes;
117    while (n < NumBytes) {
118      *pPayload++ = *pSrc++;
119      n++;
120    }
121    return pPayload;
122  }
123  static U8 *_EncodeStr(U8 *pPayload, const char *pText, unsigned int Limit) {
124    unsigned int n;
125    unsigned int Len;
126    Len = 0;
127    while(*(pText + Len) != 0) {
128      Len++;
129    }
130    if (Len > Limit) {
131      Len = Limit;
132    }
133    if (Len < 255)  {
134      *pPayload++ = Len; 
135    } else {
136      *pPayload++ = 255;
137      *pPayload++ = (Len & 255);
138      *pPayload++ = ((Len >> 8) & 255);
139    }
140    n = 0;
141    while (n < Len) {
142      *pPayload++ = *pText++;
143      n++;
144    }
145    return pPayload;
146  }
147  static U8* _PreparePacket(U8* pPacket) {
148    return pPacket + 4;
149  }
150  #if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
151  static void _HandleIncomingPacket(void) {
152    U8  Cmd;
153    int Status;
154    Status = SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
155    if (Status > 0) {
156      switch (Cmd) {
157      case SEGGER_SYSVIEW_COMMAND_ID_START:
158        SEGGER_SYSVIEW_Start();
159        break;
160      case SEGGER_SYSVIEW_COMMAND_ID_STOP:
161        SEGGER_SYSVIEW_Stop();
162        break;
163      case SEGGER_SYSVIEW_COMMAND_ID_GET_SYSTIME:
164        SEGGER_SYSVIEW_RecordSystime();
165        break;
166      case SEGGER_SYSVIEW_COMMAND_ID_GET_TASKLIST:
167        SEGGER_SYSVIEW_SendTaskList();
168        break;
169      case SEGGER_SYSVIEW_COMMAND_ID_GET_SYSDESC:
170        SEGGER_SYSVIEW_GetSysDesc();
171        break;
172      case SEGGER_SYSVIEW_COMMAND_ID_GET_NUMMODULES:
173        SEGGER_SYSVIEW_SendNumModules();
174        break;
175      case SEGGER_SYSVIEW_COMMAND_ID_GET_MODULEDESC:
176        SEGGER_SYSVIEW_SendModuleDescription();
177        break;
178      case SEGGER_SYSVIEW_COMMAND_ID_GET_MODULE:
179        Status = SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
180        if (Status > 0) {
181          SEGGER_SYSVIEW_SendModule(Cmd);
182        }
183        break;
184      default:
185        if (Cmd >= 128) { 
186          SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
187        }
188        break;
189      }
190    }
191  }
192  #endif 
193  #if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
194  static int _TrySendOverflowPacket(void) {
195    U32 TimeStamp;
196    I32 Delta;
197    int Status;
198    U8  aPacket[11];
199    U8* pPayload;
200    aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      
201    pPayload   = &aPacket[1];
202    ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
203    TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
204    Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
205    MAKE_DELTA_32BIT(Delta);
206    ENCODE_U32(pPayload, Delta);
207    Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
208    SEGGER_SYSVIEW_ON_EVENT_RECORDED(pPayload - aPacket);
209    if (Status) {
210      _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
211      _SYSVIEW_Globals.EnableState--; 
212    } else {
213      _SYSVIEW_Globals.DropCount++;
214    }
215    return Status;
216  }
217  #endif  
218  #if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
219  static void _SendSyncInfo(void) {
220    SEGGER_RTT_WriteWithOverwriteNoLock(CHANNEL_ID_UP, _abSync, 10);
221    SEGGER_SYSVIEW_ON_EVENT_RECORDED(10);
222    SEGGER_SYSVIEW_RecordVoid(SYSVIEW_EVTID_TRACE_START);
223    {
224      U8* pPayload;
225      U8* pPayloadStart;
226      RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
227      pPayload = pPayloadStart;
228      ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
229      ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
230      ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
231      ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
232      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
233      RECORD_END();
234    }
235    if (_SYSVIEW_Globals.pfSendSysDesc) {
236      _SYSVIEW_Globals.pfSendSysDesc();
237    }
238    SEGGER_SYSVIEW_RecordSystime();
239    SEGGER_SYSVIEW_SendTaskList();
240    if (_NumModules > 0) {
241      int n;
242      SEGGER_SYSVIEW_SendNumModules();
243      for (n = 0; n < _NumModules; n++) {
244        SEGGER_SYSVIEW_SendModule(n);
245      }
246      SEGGER_SYSVIEW_SendModuleDescription();
247    }
248  }
249  #endif  
250  static void _SendPacket(U8* pStartPacket, U8* pEndPacket, unsigned int EventId) {
251    unsigned int  NumBytes;
252    U32           TimeStamp;
253    U32           Delta;
254  #if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
255    int           Status;
256  #endif
257  #if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0)
258    SEGGER_SYSVIEW_LOCK();
259  #endif
260  #if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
261    if (_SYSVIEW_Globals.EnableState == 0) {
262      goto SendDone;
263    }
264  #else
265    if (_SYSVIEW_Globals.EnableState == 1) {  
266      goto Send;
267    }
268    if (_SYSVIEW_Globals.EnableState == 0) {
269      goto SendDone;
270    }
271    if (_SYSVIEW_Globals.EnableState == 2) {
272      _TrySendOverflowPacket();
273      if (_SYSVIEW_Globals.EnableState != 1) {
274        goto SendDone;
275      }
276    }
277  Send:
278  #endif
279    if (EventId < 32) {
280      if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
281        goto SendDone;
282      }
283    }
284    if (EventId < 24) {
285      *--pStartPacket = EventId;
286    } else {
287      NumBytes = pEndPacket - pStartPacket;
288      if (NumBytes > 127) {
289        *--pStartPacket = (NumBytes >> 7);
290        *--pStartPacket = NumBytes | 0x80;
291      } else {
292        *--pStartPacket = NumBytes;
293      }
294      if (EventId > 127) {
295        *--pStartPacket = (EventId >> 7);
296        *--pStartPacket = EventId | 0x80;
297      } else {
298        *--pStartPacket = EventId;
299      }
300    }
301    TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
302    Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
303    MAKE_DELTA_32BIT(Delta);
304    ENCODE_U32(pEndPacket, Delta);
305  #if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
306    SEGGER_RTT_WriteWithOverwriteNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
307    SEGGER_SYSVIEW_ON_EVENT_RECORDED(pEndPacket - pStartPacket);
308    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
309  #else
310    Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
311    SEGGER_SYSVIEW_ON_EVENT_RECORDED(pEndPacket - pStartPacket);
312    if (Status) {
313      _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
314    } else {
315      _SYSVIEW_Globals.EnableState++; 
316    }
317  #endif
318  #if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
319    if (_SYSVIEW_Globals.RecursionCnt == 0) {   
320      _SYSVIEW_Globals.RecursionCnt = 1;
321      if (_SYSVIEW_Globals.PacketCount++ & (1 << SEGGER_SYSVIEW_SYNC_PERIOD_SHIFT)) {
322        _SendSyncInfo();
323        _SYSVIEW_Globals.PacketCount = 0;
324      }
325      _SYSVIEW_Globals.RecursionCnt = 0;
326    }
327  SendDone:
328    ; 
329  #else
330  SendDone:
331    if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
332      if (_SYSVIEW_Globals.RecursionCnt == 0) {   
333        _SYSVIEW_Globals.RecursionCnt = 1;
334        _HandleIncomingPacket();
335        _SYSVIEW_Globals.RecursionCnt = 0;
336      }
337    }
338  #endif
339  #if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0)
340    SEGGER_SYSVIEW_UNLOCK();  
341  #endif
342  }
343  #ifndef SEGGER_SYSVIEW_EXCLUDE_PRINTF 
344  static int _VPrintHost(const char* s, U32 Options, va_list* pParamList) {
345    U32         aParas[SEGGER_SYSVIEW_MAX_ARGUMENTS];
346    U32*        pParas;
347    U32         NumArguments;
348    const char* p;
349    char        c;
350    U8*         pPayload;
351    U8*         pPayloadStart;
352  #if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
353    U8 HasNonScalar;
354    HasNonScalar = 0;
355  #endif  
356    p = s;
357    NumArguments = 0;
358    for (;;) {
359      c = *p++;
360      if (c == 0) {
361        break;
362      }
363      if (c == '%') {
364        c = *p;
365  #if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT == 0
366        aParas[NumArguments++] = va_arg(*pParamList, int);
367        if (NumArguments == SEGGER_SYSVIEW_MAX_ARGUMENTS) {
368          break;
369        }
370  #else
371        if (c == 's') {
372          HasNonScalar = 1;
373          break;
374        } else {
375          aParas[NumArguments++] = va_arg(*pParamList, int);
376          if (NumArguments == SEGGER_SYSVIEW_MAX_ARGUMENTS) {
377            break;
378          }
379        }
380  #endif
381      }
382    }
383  #if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
384    if (HasNonScalar) {
385      return -1;
386    }
387  #endif
388    {
389      RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_MAX_STRING_LEN + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_ARGUMENTS * SEGGER_SYSVIEW_QUANTA_U32);
390      pPayload = _EncodeStr(pPayloadStart, s, SEGGER_SYSVIEW_MAX_STRING_LEN);
391      ENCODE_U32(pPayload, Options);
392      ENCODE_U32(pPayload, NumArguments);
393      pParas = aParas;
394      while (NumArguments--) {
395        ENCODE_U32(pPayload, (*pParas));
396        pParas++;
397      }
398      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
399      RECORD_END();
400    }
401    return 0;
402  }
403  static void _StoreChar(SEGGER_SYSVIEW_PRINTF_DESC * p, char c) {
404    unsigned int  Cnt;
405    U8*           pPayload;
406    U32           Options;
407    Cnt = p->Cnt;
408    if ((Cnt + 1u) <= SEGGER_SYSVIEW_MAX_STRING_LEN) {
409      *(p->pPayload++) = c;
410      p->Cnt = Cnt + 1u;
411    }
412    if (p->Cnt == SEGGER_SYSVIEW_MAX_STRING_LEN) {
413      *(p->pPayloadStart) = p->Cnt;
414      pPayload = p->pPayload;
415      Options = p->Options;
416      ENCODE_U32(pPayload, Options);
417      ENCODE_U32(pPayload, 0);
418      _SendPacket(p->pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
419      p->pPayloadStart = _PreparePacket(p->pBuffer);
420      p->pPayload = p->pPayloadStart + 1u;
421      p->Cnt = 0u;
422    }
423  }
424  static void _PrintUnsigned(SEGGER_SYSVIEW_PRINTF_DESC * pBufferDesc, unsigned int v, unsigned int Base, unsigned int NumDigits, unsigned int FieldWidth, unsigned int FormatFlags) {
425    static const char _aV2C[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
426    unsigned int      Div;
427    unsigned int      Digit;
428    unsigned int      Number;
429    unsigned int      Width;
430    char              c;
431    Number = v;
432    Digit = 1u;
433    Width = 1u;
434    while (Number >= Base) {
435      Number = (Number / Base);
436      Width++;
437    }
438    if (NumDigits > Width) {
439      Width = NumDigits;
440    }
441    if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) {
442      if (FieldWidth != 0u) {
443        if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && (NumDigits == 0u)) {
444          c = '0';
445        } else {
446          c = ' ';
447        }
448        while ((FieldWidth != 0u) && (Width < FieldWidth)) {
449          FieldWidth--;
450          _StoreChar(pBufferDesc, c);
451        }
452      }
453    }
454    while (1) {
455      if (NumDigits > 1u) {       
456        NumDigits--;
457      } else {
458        Div = v / Digit;
459        if (Div < Base) {        
460          break;
461        }
462      }
463      Digit *= Base;
464    }
465    do {
466      Div = v / Digit;
467      v -= Div * Digit;
468      _StoreChar(pBufferDesc, _aV2C[Div]);
469      Digit /= Base;
470    } while (Digit);
471    if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == FORMAT_FLAG_LEFT_JUSTIFY) {
472      if (FieldWidth != 0u) {
473        while ((FieldWidth != 0u) && (Width < FieldWidth)) {
474          FieldWidth--;
475          _StoreChar(pBufferDesc, ' ');
476        }
477      }
478    }
479  }
480  static void _PrintInt(SEGGER_SYSVIEW_PRINTF_DESC * pBufferDesc, int v, unsigned int Base, unsigned int NumDigits, unsigned int FieldWidth, unsigned int FormatFlags) {
481    unsigned int  Width;
482    int           Number;
483    Number = (v < 0) ? -v : v;
484    Width = 1u;
485    while (Number >= (int)Base) {
486      Number = (Number / (int)Base);
487      Width++;
488    }
489    if (NumDigits > Width) {
490      Width = NumDigits;
491    }
492    if ((FieldWidth > 0u) && ((v < 0) || ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN))) {
493      FieldWidth--;
494    }
495    if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
496      if (FieldWidth != 0u) {
497        while ((FieldWidth != 0u) && (Width < FieldWidth)) {
498          FieldWidth--;
499          _StoreChar(pBufferDesc, ' ');
500        }
501      }
502    }
503    if (v < 0) {
504      v = -v;
505      _StoreChar(pBufferDesc, '-');
506    } else if ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN) {
507      _StoreChar(pBufferDesc, '+');
508    } else {
509    }
510    if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) && (NumDigits == 0u)) {
511      if (FieldWidth != 0u) {
512        while ((FieldWidth != 0u) && (Width < FieldWidth)) {
513          FieldWidth--;
514          _StoreChar(pBufferDesc, '0');
515        }
516      }
517    }
518    _PrintUnsigned(pBufferDesc, (unsigned int)v, Base, NumDigits, FieldWidth, FormatFlags);
519  }
520  static void _VPrintTarget(const char* sFormat, U32 Options, va_list* pParamList) {
521    SEGGER_SYSVIEW_PRINTF_DESC BufferDesc;
522    char          c;
523    int           v;
524    unsigned int  NumDigits;
525    unsigned int  FormatFlags;
526    unsigned int  FieldWidth;
527    U8*           pPayloadStart;
528  #if SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0
529    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_MAX_STRING_LEN + 1 + 2 * SEGGER_SYSVIEW_QUANTA_U32);
530    SEGGER_SYSVIEW_LOCK();
531  #else
532    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_MAX_STRING_LEN + 1 + 2 * SEGGER_SYSVIEW_QUANTA_U32);
533  #endif
534  #if SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0
535    BufferDesc.pBuffer        = aPacket;
536  #else
537    BufferDesc.pBuffer        = _aPacket;
538  #endif
539    BufferDesc.Cnt            = 0u;
540    BufferDesc.pPayloadStart  = pPayloadStart;
541    BufferDesc.pPayload       = BufferDesc.pPayloadStart + 1u;
542    BufferDesc.Options        =  Options;
543    do {
544      c = *sFormat;
545      sFormat++;
546      if (c == 0u) {
547        break;
548      }
549      if (c == '%') {
550        FormatFlags = 0u;
551        v = 1;
552        do {
553          c = *sFormat;
554          switch (c) {
555          case '-': FormatFlags |= FORMAT_FLAG_LEFT_JUSTIFY; sFormat++; break;
556          case '0': FormatFlags |= FORMAT_FLAG_PAD_ZERO;     sFormat++; break;
557          case '+': FormatFlags |= FORMAT_FLAG_PRINT_SIGN;   sFormat++; break;
558          case '#': FormatFlags |= FORMAT_FLAG_ALTERNATE;    sFormat++; break;
559          default:  v = 0; break;
560          }
561        } while (v);
562        FieldWidth = 0u;
563        do {
564          c = *sFormat;
565          if ((c < '0') || (c > '9')) {
566            break;
567          }
568          sFormat++;
569          FieldWidth = (FieldWidth * 10u) + ((unsigned int)c - '0');
570        } while (1);
571        NumDigits = 0u;
572        c = *sFormat;
573        if (c == '.') {
574          sFormat++;
575          do {
576            c = *sFormat;
577            if ((c < '0') || (c > '9')) {
578              break;
579            }
580            sFormat++;
581            NumDigits = NumDigits * 10u + ((unsigned int)c - '0');
582          } while (1);
583        }
584        c = *sFormat;
585        do {
586          if ((c == 'l') || (c == 'h')) {
587            c = *sFormat;
588            sFormat++;
589          } else {
590            break;
591          }
592        } while (1);
593        switch (c) {
594        case 'c': {
595          char c0;
596          v = va_arg(*pParamList, int);
597          c0 = (char)v;
598          _StoreChar(&BufferDesc, c0);
599          break;
600        }
601        case 'd':
602          v = va_arg(*pParamList, int);
603          _PrintInt(&BufferDesc, v, 10u, NumDigits, FieldWidth, FormatFlags);
604          break;
605        case 'u':
606          v = va_arg(*pParamList, int);
607          _PrintUnsigned(&BufferDesc, (unsigned int)v, 10u, NumDigits, FieldWidth, FormatFlags);
608          break;
609        case 'x':
610        case 'X':
611          v = va_arg(*pParamList, int);
612          _PrintUnsigned(&BufferDesc, (unsigned int)v, 16u, NumDigits, FieldWidth, FormatFlags);
613          break;
614        case 'p':
615          v = va_arg(*pParamList, int);
616          _PrintUnsigned(&BufferDesc, (unsigned int)v, 16u, 8u, 8u, 0u);
617          break;
618        case '%':
619          _StoreChar(&BufferDesc, '%');
620          break;
621        default:
622          break;
623        }
624        sFormat++;
625      } else {
626        _StoreChar(&BufferDesc, c);
627      }
628    } while (*sFormat);
629    if (BufferDesc.Cnt != 0u) {
630      *(BufferDesc.pPayloadStart) = BufferDesc.Cnt;
631      ENCODE_U32(BufferDesc.pPayload, BufferDesc.Options);
632      ENCODE_U32(BufferDesc.pPayload, 0);
633      _SendPacket(BufferDesc.pPayloadStart, BufferDesc.pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
634    }
635  #if SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0
636    SEGGER_SYSVIEW_UNLOCK();
637    RECORD_END();
638  #else
639    RECORD_END();
640  #endif
641  }
642  #endif 
643  void SEGGER_SYSVIEW_Init(U32 SysFreq, U32 CPUFreq, const SEGGER_SYSVIEW_OS_API *pOSAPI, SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC pfSendSysDesc) {
644  #ifdef SEGGER_RTT_SECTION
645    SEGGER_RTT_Init();
646  #endif
647  #if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
648  #if SEGGER_SYSVIEW_RTT_CHANNEL > 0
649    SEGGER_RTT_ConfigUpBuffer(SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
650  #else
651    _SYSVIEW_Globals.UpChannel = SEGGER_RTT_AllocUpBuffer  ("SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
652  #endif
653    _SYSVIEW_Globals.RAMBaseAddress   = SEGGER_SYSVIEW_ID_BASE;
654    _SYSVIEW_Globals.LastTxTimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
655    _SYSVIEW_Globals.pOSAPI           = pOSAPI;
656    _SYSVIEW_Globals.SysFreq          = SysFreq;
657    _SYSVIEW_Globals.CPUFreq          = CPUFreq;
658    _SYSVIEW_Globals.pfSendSysDesc    = pfSendSysDesc;
659    _SYSVIEW_Globals.EnableState      = 0;
660    _SYSVIEW_Globals.PacketCount      = 0;
661  #else 
662  #if SEGGER_SYSVIEW_RTT_CHANNEL > 0
663    SEGGER_RTT_ConfigUpBuffer   (SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
664    SEGGER_RTT_ConfigDownBuffer (SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_DownBuffer[0], sizeof(_DownBuffer), SEGGER_RTT_MODE_NO_BLOCK_SKIP);
665  #else
666    _SYSVIEW_Globals.UpChannel = SEGGER_RTT_AllocUpBuffer  ("SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
667    _SYSVIEW_Globals.DownChannel = _SYSVIEW_Globals.UpChannel;
668    SEGGER_RTT_ConfigDownBuffer (_SYSVIEW_Globals.DownChannel, "SysView", &_DownBuffer[0], sizeof(_DownBuffer), SEGGER_RTT_MODE_NO_BLOCK_SKIP);
669  #endif
670    _SYSVIEW_Globals.RAMBaseAddress   = SEGGER_SYSVIEW_ID_BASE;
671    _SYSVIEW_Globals.LastTxTimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
672    _SYSVIEW_Globals.pOSAPI           = pOSAPI;
673    _SYSVIEW_Globals.SysFreq          = SysFreq;
674    _SYSVIEW_Globals.CPUFreq          = CPUFreq;
675    _SYSVIEW_Globals.pfSendSysDesc    = pfSendSysDesc;
676    _SYSVIEW_Globals.EnableState      = 0;
677  #endif  
678  }
679  void SEGGER_SYSVIEW_SetRAMBase(U32 RAMBaseAddress) {
680    _SYSVIEW_Globals.RAMBaseAddress = RAMBaseAddress;
681  }
682  void SEGGER_SYSVIEW_RecordVoid(unsigned int EventID) {
683    U8* pPayloadStart;
684    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
685    _SendPacket(pPayloadStart, pPayloadStart, EventID);
686    RECORD_END();
687  }
688  void SEGGER_SYSVIEW_RecordU32(unsigned int EventID, U32 Value) {
689    U8* pPayload;
690    U8* pPayloadStart;
691    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
692    pPayload = pPayloadStart;
693    ENCODE_U32(pPayload, Value);
694    _SendPacket(pPayloadStart, pPayload, EventID);
695    RECORD_END();
696  }
697  void SEGGER_SYSVIEW_RecordU32x2(unsigned int EventID, U32 Para0, U32 Para1) {
698    U8* pPayload;
699    U8* pPayloadStart;
700    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
701    pPayload = pPayloadStart;
702    ENCODE_U32(pPayload, Para0);
703    ENCODE_U32(pPayload, Para1);
704    _SendPacket(pPayloadStart, pPayload, EventID);
705    RECORD_END();
706  }
707  void SEGGER_SYSVIEW_RecordU32x3(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2) {
708    U8* pPayload;
709    U8* pPayloadStart;
710    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 3 * SEGGER_SYSVIEW_QUANTA_U32);
711    pPayload = pPayloadStart;
712    ENCODE_U32(pPayload, Para0);
713    ENCODE_U32(pPayload, Para1);
714    ENCODE_U32(pPayload, Para2);
715    _SendPacket(pPayloadStart, pPayload, EventID);
716    RECORD_END();
717  }
718  void SEGGER_SYSVIEW_RecordU32x4(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3) {
719    U8* pPayload;
720    U8* pPayloadStart;
721    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
722    pPayload = pPayloadStart;
723    ENCODE_U32(pPayload, Para0);
724    ENCODE_U32(pPayload, Para1);
725    ENCODE_U32(pPayload, Para2);
726    ENCODE_U32(pPayload, Para3);
727    _SendPacket(pPayloadStart, pPayload, EventID);
728    RECORD_END();
729  }
730  void SEGGER_SYSVIEW_RecordU32x5(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4) {
731    U8* pPayload;
732    U8* pPayloadStart;
733    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 5 * SEGGER_SYSVIEW_QUANTA_U32);
734    pPayload = pPayloadStart;
735    ENCODE_U32(pPayload, Para0);
736    ENCODE_U32(pPayload, Para1);
737    ENCODE_U32(pPayload, Para2);
738    ENCODE_U32(pPayload, Para3);
739    ENCODE_U32(pPayload, Para4);
740    _SendPacket(pPayloadStart, pPayload, EventID);
741    RECORD_END();
742  }
743  void SEGGER_SYSVIEW_RecordU32x6(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5) {
744    U8* pPayload;
745    U8* pPayloadStart;
746    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 6 * SEGGER_SYSVIEW_QUANTA_U32);
747    pPayload = pPayloadStart;
748    ENCODE_U32(pPayload, Para0);
749    ENCODE_U32(pPayload, Para1);
750    ENCODE_U32(pPayload, Para2);
751    ENCODE_U32(pPayload, Para3);
752    ENCODE_U32(pPayload, Para4);
753    ENCODE_U32(pPayload, Para5);
754    _SendPacket(pPayloadStart, pPayload, EventID);
755    RECORD_END();
756  }
757  void SEGGER_SYSVIEW_RecordU32x7(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6) {
758    U8* pPayload;
759    U8* pPayloadStart;
760    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 7 * SEGGER_SYSVIEW_QUANTA_U32);
761    pPayload = pPayloadStart;
762    ENCODE_U32(pPayload, Para0);
763    ENCODE_U32(pPayload, Para1);
764    ENCODE_U32(pPayload, Para2);
765    ENCODE_U32(pPayload, Para3);
766    ENCODE_U32(pPayload, Para4);
767    ENCODE_U32(pPayload, Para5);
768    ENCODE_U32(pPayload, Para6);
769    _SendPacket(pPayloadStart, pPayload, EventID);
770    RECORD_END();
771  }
772  void SEGGER_SYSVIEW_RecordU32x8(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7) {
773    U8* pPayload;
774    U8* pPayloadStart;
775    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 8 * SEGGER_SYSVIEW_QUANTA_U32);
776    pPayload = pPayloadStart;
777    ENCODE_U32(pPayload, Para0);
778    ENCODE_U32(pPayload, Para1);
779    ENCODE_U32(pPayload, Para2);
780    ENCODE_U32(pPayload, Para3);
781    ENCODE_U32(pPayload, Para4);
782    ENCODE_U32(pPayload, Para5);
783    ENCODE_U32(pPayload, Para6);
784    ENCODE_U32(pPayload, Para7);
785    _SendPacket(pPayloadStart, pPayload, EventID);
786    RECORD_END();
787  }
788  void SEGGER_SYSVIEW_RecordU32x9(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7, U32 Para8) {
789    U8* pPayload;
790    U8* pPayloadStart;
791    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 9 * SEGGER_SYSVIEW_QUANTA_U32);
792    pPayload = pPayloadStart;
793    ENCODE_U32(pPayload, Para0);
794    ENCODE_U32(pPayload, Para1);
795    ENCODE_U32(pPayload, Para2);
796    ENCODE_U32(pPayload, Para3);
797    ENCODE_U32(pPayload, Para4);
798    ENCODE_U32(pPayload, Para5);
799    ENCODE_U32(pPayload, Para6);
800    ENCODE_U32(pPayload, Para7);
801    ENCODE_U32(pPayload, Para8);
802    _SendPacket(pPayloadStart, pPayload, EventID);
803    RECORD_END();
804  }
805  void SEGGER_SYSVIEW_RecordU32x10(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2, U32 Para3, U32 Para4, U32 Para5, U32 Para6, U32 Para7, U32 Para8, U32 Para9) {
806    U8* pPayload;
807    U8* pPayloadStart;
808    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 10 * SEGGER_SYSVIEW_QUANTA_U32);
809    pPayload = pPayloadStart;
810    ENCODE_U32(pPayload, Para0);
811    ENCODE_U32(pPayload, Para1);
812    ENCODE_U32(pPayload, Para2);
813    ENCODE_U32(pPayload, Para3);
814    ENCODE_U32(pPayload, Para4);
815    ENCODE_U32(pPayload, Para5);
816    ENCODE_U32(pPayload, Para6);
817    ENCODE_U32(pPayload, Para7);
818    ENCODE_U32(pPayload, Para8);
819    ENCODE_U32(pPayload, Para9);
820    _SendPacket(pPayloadStart, pPayload, EventID);
821    RECORD_END();
822  }
823  void SEGGER_SYSVIEW_RecordString(unsigned int EventID, const char* pString) {
824    U8* pPayload;
825    U8* pPayloadStart;
826    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
827    pPayload = _EncodeStr(pPayloadStart, pString, SEGGER_SYSVIEW_MAX_STRING_LEN);
828    _SendPacket(pPayloadStart, pPayload, EventID);
829    RECORD_END();
830  }
831  void SEGGER_SYSVIEW_Start(void) {
832  #if (SEGGER_SYSVIEW_CAN_RESTART == 0)
833    if (_SYSVIEW_Globals.EnableState == 0) {
834  #endif
835      _SYSVIEW_Globals.EnableState = 1;
836  #if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
837      _SendSyncInfo();
838  #else
839      SEGGER_SYSVIEW_LOCK();
840      SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, _abSync, 10);
841      SEGGER_SYSVIEW_UNLOCK();
842      SEGGER_SYSVIEW_ON_EVENT_RECORDED(10);
843      SEGGER_SYSVIEW_RecordVoid(SYSVIEW_EVTID_TRACE_START);
844      {
845        U8* pPayload;
846        U8* pPayloadStart;
847        RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
848        pPayload = pPayloadStart;
849        ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
850        ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
851        ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
852        ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
853        _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
854        RECORD_END();
855      }
856      if (_SYSVIEW_Globals.pfSendSysDesc) {
857        _SYSVIEW_Globals.pfSendSysDesc();
858      }
859      SEGGER_SYSVIEW_RecordSystime();
860      SEGGER_SYSVIEW_SendTaskList();
861      SEGGER_SYSVIEW_SendNumModules();
862  #endif
863  #if (SEGGER_SYSVIEW_CAN_RESTART == 0)
864    }
865  #endif
866  }
867  void SEGGER_SYSVIEW_Stop(void) {
868    U8* pPayloadStart;
869    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
870    if (_SYSVIEW_Globals.EnableState) {
871      _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_TRACE_STOP);
872      _SYSVIEW_Globals.EnableState = 0;
873    }
874    RECORD_END();
875  }
876  int SEGGER_SYSVIEW_GetChannelID(void) {
877    return CHANNEL_ID_UP;
878  }
879  void SEGGER_SYSVIEW_GetSysDesc(void) {
880    U8* pPayload;
881    U8* pPayloadStart;
882    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
883    pPayload = pPayloadStart;
884    ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
885    ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
886    ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
887    ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
888    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
889    RECORD_END();
890    if (_SYSVIEW_Globals.pfSendSysDesc) {
891      _SYSVIEW_Globals.pfSendSysDesc();
892    }
893  }
894  void SEGGER_SYSVIEW_SendTaskInfo(const SEGGER_SYSVIEW_TASKINFO *pInfo) {
895    U8* pPayload;
896    U8* pPayloadStart;
897    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32 + 1 + 32);
898    pPayload = pPayloadStart;
899    ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
900    ENCODE_U32(pPayload, pInfo->Prio);
901    pPayload = _EncodeStr(pPayload, pInfo->sName, 32);
902    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_INFO);
903    pPayload = pPayloadStart;
904    ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
905    ENCODE_U32(pPayload, pInfo->StackBase);
906    ENCODE_U32(pPayload, pInfo->StackSize);
907    ENCODE_U32(pPayload, 0); 
908    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_STACK_INFO);
909    RECORD_END();
910  }
911  void SEGGER_SYSVIEW_SendTaskList(void) {
912    if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfSendTaskList) {
913      _SYSVIEW_Globals.pOSAPI->pfSendTaskList();
914    }
915  }
916  void SEGGER_SYSVIEW_SendSysDesc(const char *sSysDesc) {
917    U8* pPayload;
918    U8* pPayloadStart;
919    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
920    pPayload = _EncodeStr(pPayloadStart, sSysDesc, SEGGER_SYSVIEW_MAX_STRING_LEN);
921    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_SYSDESC);
922    RECORD_END();
923  }
924  void SEGGER_SYSVIEW_RecordSystime(void) {
925    U64 Systime;
926    if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfGetTime) {
927      Systime = _SYSVIEW_Globals.pOSAPI->pfGetTime();
928      SEGGER_SYSVIEW_RecordU32x2(SYSVIEW_EVTID_SYSTIME_US,
929                                 (U32)(Systime),
930                                 (U32)(Systime >> 32));
931    } else {
932      SEGGER_SYSVIEW_RecordU32(SYSVIEW_EVTID_SYSTIME_CYCLES, SEGGER_SYSVIEW_GET_TIMESTAMP());
933    }
934  }
935  void SEGGER_SYSVIEW_RecordEnterISR(void) {
936    unsigned v;
937    U8* pPayload;
938    U8* pPayloadStart;
939    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
940    pPayload = pPayloadStart;
941    v = SEGGER_SYSVIEW_GET_INTERRUPT_ID();
942    ENCODE_U32(pPayload, v);
943    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_ISR_ENTER);
944    RECORD_END();
945  }
946  void SEGGER_SYSVIEW_RecordExitISR(void) {
947    U8* pPayloadStart;
948    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
949    _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_ISR_EXIT);
950    RECORD_END();
951  }
952  void SEGGER_SYSVIEW_RecordExitISRToScheduler(void) {
953    U8* pPayloadStart;
954    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
955    _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_ISR_TO_SCHEDULER);
956    RECORD_END();
957  }
958  void SEGGER_SYSVIEW_RecordEnterTimer(U32 TimerId) {
959    U8* pPayload;
960    U8* pPayloadStart;
961    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
962    pPayload = pPayloadStart;
963    ENCODE_U32(pPayload, SHRINK_ID(TimerId));
964    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TIMER_ENTER);
965    RECORD_END();
966  }
967  void SEGGER_SYSVIEW_RecordExitTimer(void) {
968    U8* pPayloadStart;
969    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
970    _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_TIMER_EXIT);
971    RECORD_END();
972  }
973  void SEGGER_SYSVIEW_RecordEndCall(unsigned int EventID) {
974    U8* pPayload;
975    U8* pPayloadStart;
976    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
977    pPayload = pPayloadStart;
978    ENCODE_U32(pPayload, EventID);
979    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_END_CALL);
980    RECORD_END();
981  }
982  void SEGGER_SYSVIEW_RecordEndCallU32(unsigned int EventID, U32 Para0) {
983    U8* pPayload;
984    U8* pPayloadStart;
985    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
986    pPayload = pPayloadStart;
987    ENCODE_U32(pPayload, EventID);
988    ENCODE_U32(pPayload, Para0);
989    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_END_CALL);
990    RECORD_END();
991  }
992  void SEGGER_SYSVIEW_OnIdle(void) {
993    U8* pPayloadStart;
994    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
995    _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_IDLE);
996    RECORD_END();
997  }
998  void SEGGER_SYSVIEW_OnTaskCreate(U32 TaskId) {
999    U8* pPayload;
1000    U8* pPayloadStart;
1001    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
1002    pPayload = pPayloadStart;
1003    TaskId = SHRINK_ID(TaskId);
1004    ENCODE_U32(pPayload, TaskId);
1005    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_CREATE);
1006    RECORD_END();
1007  }
1008  void SEGGER_SYSVIEW_OnTaskTerminate(U32 TaskId) {
1009    U8* pPayload;
1010    U8* pPayloadStart;
1011    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
1012    pPayload = pPayloadStart;
1013    TaskId = SHRINK_ID(TaskId);
1014    ENCODE_U32(pPayload, TaskId);
1015    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_TERMINATE);
1016    RECORD_END();
1017  }
1018  void SEGGER_SYSVIEW_OnTaskStartExec(U32 TaskId) {
1019    U8* pPayload;
1020    U8* pPayloadStart;
1021    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
1022    pPayload = pPayloadStart;
1023    TaskId = SHRINK_ID(TaskId);
1024    ENCODE_U32(pPayload, TaskId);
1025    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_START_EXEC);
1026    RECORD_END();
1027  }
1028  void SEGGER_SYSVIEW_OnTaskStopExec(void) {
1029    U8* pPayloadStart;
1030    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
1031    _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_TASK_STOP_EXEC);
1032    RECORD_END();
1033  }
1034  void SEGGER_SYSVIEW_OnTaskStartReady(U32 TaskId) {
1035    U8* pPayload;
1036    U8* pPayloadStart;
1037    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
1038    pPayload = pPayloadStart;
1039    TaskId = SHRINK_ID(TaskId);
1040    ENCODE_U32(pPayload, TaskId);
1041    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_START_READY);
1042    RECORD_END();
1043  }
1044  void SEGGER_SYSVIEW_OnTaskStopReady(U32 TaskId, unsigned int Cause) {
1045    U8* pPayload;
1046    U8* pPayloadStart;
1047    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
1048    pPayload = pPayloadStart;
1049    TaskId = SHRINK_ID(TaskId);
1050    ENCODE_U32(pPayload, TaskId);
1051    ENCODE_U32(pPayload, Cause);
1052    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_STOP_READY);
1053    RECORD_END();
1054  }
1055  void SEGGER_SYSVIEW_MarkStart(unsigned MarkerId) {
1056    U8* pPayload;
1057    U8* pPayloadStart;
1058    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
1059    pPayload = pPayloadStart;
1060    ENCODE_U32(pPayload, MarkerId);
1061    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_MARK_START);
1062    RECORD_END();
1063  }
1064  void SEGGER_SYSVIEW_MarkStop(unsigned MarkerId) {
1065    U8 * pPayload;
1066    U8 * pPayloadStart;
1067    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
1068    pPayload = pPayloadStart;
1069    ENCODE_U32(pPayload, MarkerId);
1070    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_MARK_STOP);
1071    RECORD_END();
1072  }
1073  void SEGGER_SYSVIEW_Mark(unsigned int MarkerId) {
1074    U8* pPayload;
1075    U8* pPayloadStart;
1076    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
1077    pPayload = pPayloadStart;
1078    ENCODE_U32(pPayload, SYSVIEW_EVTID_EX_MARK);
1079    ENCODE_U32(pPayload, MarkerId);
1080    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_EX);
1081    RECORD_END();
1082  }
1083  void SEGGER_SYSVIEW_NameMarker(unsigned int MarkerId, const char* sName) {
1084    U8* pPayload;
1085    U8* pPayloadStart;
1086    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
1087    pPayload = pPayloadStart;
1088    ENCODE_U32(pPayload, SYSVIEW_EVTID_EX_NAME_MARKER);
1089    ENCODE_U32(pPayload, MarkerId);
1090    pPayload = _EncodeStr(pPayload, sName, SEGGER_SYSVIEW_MAX_STRING_LEN);
1091    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_EX);
1092    RECORD_END();
1093  }
1094  void SEGGER_SYSVIEW_NameResource(U32 ResourceId, const char* sName) {
1095    U8* pPayload;
1096    U8* pPayloadStart;
1097    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
1098    pPayload = pPayloadStart;
1099    ENCODE_U32(pPayload, SHRINK_ID(ResourceId));
1100    pPayload = _EncodeStr(pPayload, sName, SEGGER_SYSVIEW_MAX_STRING_LEN);
1101    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NAME_RESOURCE);
1102    RECORD_END();
1103  }
1104  int SEGGER_SYSVIEW_SendPacket(U8* pPacket, U8* pPayloadEnd, unsigned int EventId) {
1105  #if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 1)
1106    SEGGER_SYSVIEW_LOCK();
1107  #endif
1108    _SendPacket(pPacket + 4, pPayloadEnd, EventId);
1109  #if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 1)
1110    SEGGER_SYSVIEW_UNLOCK();
1111  #endif
1112    return 0;
1113  }
1114  U8* SEGGER_SYSVIEW_EncodeU32(U8* pPayload, U32 Value) {
1115    ENCODE_U32(pPayload, Value);
1116    return pPayload;
1117  }
1118  U8* SEGGER_SYSVIEW_EncodeString(U8* pPayload, const char* s, unsigned int MaxLen) {
1119    return _EncodeStr(pPayload, s, MaxLen);
1120  }
1121  U8* SEGGER_SYSVIEW_EncodeData(U8 *pPayload, const char* pSrc, unsigned int NumBytes) {
1122    return _EncodeData(pPayload, pSrc, NumBytes);
1123  }
1124  U8* SEGGER_SYSVIEW_EncodeId(U8* pPayload, U32 Id) {
1125    Id = SHRINK_ID(Id);
1126    ENCODE_U32(pPayload, Id);
1127    return pPayload;
1128  }
1129  U32 SEGGER_SYSVIEW_ShrinkId(U32 Id) {
1130    return SHRINK_ID(Id);
1131  }
1132  void SEGGER_SYSVIEW_RegisterModule(SEGGER_SYSVIEW_MODULE* pModule) {
1133    SEGGER_SYSVIEW_LOCK();
1134    if (_pFirstModule == 0) {
1135      pModule->EventOffset = MODULE_EVENT_OFFSET;
<span onclick='openModal()' class='match'>1136      pModule->pNext = 0;
1137      _pFirstModule = pModule;
1138      _NumModules = 1;
1139    } else {
1140      pModule->EventOffset = _pFirstModule->EventOffset + _pFirstModule->NumEvents;
1141      pModule->pNext = _pFirstModule;
1142      _pFirstModule = pModule;
</span>1143      _NumModules++;
1144    }
1145    SEGGER_SYSVIEW_SendModule(0);
1146    if (pModule->pfSendModuleDesc) {
1147      pModule->pfSendModuleDesc();
1148    }
1149    SEGGER_SYSVIEW_UNLOCK();
1150  }
1151  void SEGGER_SYSVIEW_RecordModuleDescription(const SEGGER_SYSVIEW_MODULE* pModule, const char* sDescription) {
1152    U8  ModuleId;
1153    SEGGER_SYSVIEW_MODULE* p;
1154    p = _pFirstModule;
1155    ModuleId = 0;
1156    do {
1157      if (p == pModule) {
1158        break;
1159      }
1160      ModuleId++;
1161      p = p->pNext;
1162    } while (p);
1163    {
1164      U8* pPayload;
1165      U8* pPayloadStart;
1166      RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
1167      pPayload = pPayloadStart;
1168      ENCODE_U32(pPayload, ModuleId);
1169      ENCODE_U32(pPayload, (pModule->EventOffset));
1170      pPayload = _EncodeStr(pPayload, sDescription, SEGGER_SYSVIEW_MAX_STRING_LEN);
1171      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_MODULEDESC);
1172      RECORD_END();
1173    }
1174  }
1175  void SEGGER_SYSVIEW_SendModule(U8 ModuleId) {
1176    SEGGER_SYSVIEW_MODULE* pModule;
1177    U32 n;
1178    if (_pFirstModule != 0) {
1179      pModule = _pFirstModule;
1180      for (n = 0; n < ModuleId; n++) {
1181        pModule = pModule->pNext;
1182        if (pModule == 0) {
1183          break;
1184        }
1185      }
1186      if (pModule != 0) {
1187        U8* pPayload;
1188        U8* pPayloadStart;
1189        RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
1190        pPayload = pPayloadStart;
1191        ENCODE_U32(pPayload, ModuleId);
1192        ENCODE_U32(pPayload, (pModule->EventOffset));
1193        pPayload = _EncodeStr(pPayload, pModule->sModule, SEGGER_SYSVIEW_MAX_STRING_LEN);
1194        _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_MODULEDESC);
1195        RECORD_END();
1196      }
1197    }
1198  }
1199  void SEGGER_SYSVIEW_SendModuleDescription(void) {
1200    SEGGER_SYSVIEW_MODULE* pModule;
1201    if (_pFirstModule != 0) {
1202      pModule = _pFirstModule;
1203      do {
1204        if (pModule->pfSendModuleDesc) {
1205          pModule->pfSendModuleDesc();
1206        }
1207        pModule = pModule->pNext;
1208      } while (pModule);
1209    }
1210  }
1211  void SEGGER_SYSVIEW_SendNumModules(void) {
1212    U8* pPayload;
1213    U8* pPayloadStart;
1214    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2*SEGGER_SYSVIEW_QUANTA_U32);
1215    pPayload = pPayloadStart;
1216    ENCODE_U32(pPayload, _NumModules);
1217    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NUMMODULES);
1218    RECORD_END();
1219  }
1220  #ifndef SEGGER_SYSVIEW_EXCLUDE_PRINTF 
1221  void SEGGER_SYSVIEW_PrintfHostEx(const char* s, U32 Options, ...) {
1222    va_list ParamList;
1223  #if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
1224    int r;
1225    va_start(ParamList, Options);
1226    r = _VPrintHost(s, Options, &ParamList);
1227    va_end(ParamList);
1228    if (r == -1) {
1229      va_start(ParamList, Options);
1230      _VPrintTarget(s, Options, &ParamList);
1231      va_end(ParamList);
1232    }
1233  #else
1234    va_start(ParamList, Options);
1235    _VPrintHost(s, Options, &ParamList);
1236    va_end(ParamList);
1237  #endif
1238  }
1239  void SEGGER_SYSVIEW_PrintfHost(const char* s, ...) {
1240    va_list ParamList;
1241  #if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
1242    int r;
1243    va_start(ParamList, s);
1244    r = _VPrintHost(s, SEGGER_SYSVIEW_LOG, &ParamList);
1245    va_end(ParamList);
1246    if (r == -1) {
1247      va_start(ParamList, s);
1248      _VPrintTarget(s, SEGGER_SYSVIEW_LOG, &ParamList);
1249      va_end(ParamList);
1250    }
1251  #else
1252    va_start(ParamList, s);
1253    _VPrintHost(s, SEGGER_SYSVIEW_LOG, &ParamList);
1254    va_end(ParamList);
1255  #endif
1256  }
1257  void SEGGER_SYSVIEW_WarnfHost(const char* s, ...) {
1258    va_list ParamList;
1259  #if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
1260    int r;
1261    va_start(ParamList, s);
1262    r = _VPrintHost(s, SEGGER_SYSVIEW_WARNING, &ParamList);
1263    va_end(ParamList);
1264    if (r == -1) {
1265      va_start(ParamList, s);
1266      _VPrintTarget(s, SEGGER_SYSVIEW_WARNING, &ParamList);
1267      va_end(ParamList);
1268    }
1269  #else
1270    va_start(ParamList, s);
1271    _VPrintHost(s, SEGGER_SYSVIEW_WARNING, &ParamList);
1272    va_end(ParamList);
1273  #endif
1274  }
1275  void SEGGER_SYSVIEW_ErrorfHost(const char* s, ...) {
1276    va_list ParamList;
1277  #if SEGGER_SYSVIEW_PRINTF_IMPLICIT_FORMAT
1278    int r;
1279    va_start(ParamList, s);
1280    r = _VPrintHost(s, SEGGER_SYSVIEW_ERROR, &ParamList);
1281    va_end(ParamList);
1282    if (r == -1) {
1283      va_start(ParamList, s);
1284      _VPrintTarget(s, SEGGER_SYSVIEW_ERROR, &ParamList);
1285      va_end(ParamList);
1286    }
1287  #else
1288    va_start(ParamList, s);
1289    _VPrintHost(s, SEGGER_SYSVIEW_ERROR, &ParamList);
1290    va_end(ParamList);
1291  #endif
1292  }
1293  void SEGGER_SYSVIEW_PrintfTargetEx(const char* s, U32 Options, ...) {
1294    va_list ParamList;
1295    va_start(ParamList, Options);
1296    _VPrintTarget(s, Options, &ParamList);
1297    va_end(ParamList);
1298  }
1299  void SEGGER_SYSVIEW_PrintfTarget(const char* s, ...) {
1300    va_list ParamList;
1301    va_start(ParamList, s);
1302    _VPrintTarget(s, SEGGER_SYSVIEW_LOG, &ParamList);
1303    va_end(ParamList);
1304  }
1305  void SEGGER_SYSVIEW_WarnfTarget(const char* s, ...) {
1306    va_list ParamList;
1307    va_start(ParamList, s);
1308    _VPrintTarget(s, SEGGER_SYSVIEW_WARNING, &ParamList);
1309    va_end(ParamList);
1310  }
1311  void SEGGER_SYSVIEW_ErrorfTarget(const char* s, ...) {
1312    va_list ParamList;
1313    va_start(ParamList, s);
1314    _VPrintTarget(s, SEGGER_SYSVIEW_ERROR, &ParamList);
1315    va_end(ParamList);
1316  }
1317  #endif 
1318  void SEGGER_SYSVIEW_Print(const char* s) {
1319    U8* pPayload;
1320    U8* pPayloadStart;
1321    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_STRING_LEN);
1322    pPayload = _EncodeStr(pPayloadStart, s, SEGGER_SYSVIEW_MAX_STRING_LEN);
1323    ENCODE_U32(pPayload, SEGGER_SYSVIEW_LOG);
1324    ENCODE_U32(pPayload, 0);
1325    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
1326    RECORD_END();
1327  }
1328  void SEGGER_SYSVIEW_Warn(const char* s) {
1329    U8* pPayload;
1330    U8* pPayloadStart;
1331    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_STRING_LEN);
1332    pPayload = _EncodeStr(pPayloadStart, s, SEGGER_SYSVIEW_MAX_STRING_LEN);
1333    ENCODE_U32(pPayload, SEGGER_SYSVIEW_WARNING);
1334    ENCODE_U32(pPayload, 0);
1335    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
1336    RECORD_END();
1337  }
1338  void SEGGER_SYSVIEW_Error(const char* s) {
1339    U8* pPayload;
1340    U8* pPayloadStart;
1341    RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_STRING_LEN);
1342    pPayload = _EncodeStr(pPayloadStart, s, SEGGER_SYSVIEW_MAX_STRING_LEN);
1343    ENCODE_U32(pPayload, SEGGER_SYSVIEW_ERROR);
1344    ENCODE_U32(pPayload, 0);
1345    _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
1346    RECORD_END();
1347  }
1348  void SEGGER_SYSVIEW_EnableEvents(U32 EnableMask) {
1349    _SYSVIEW_Globals.DisabledEvents &= ~EnableMask;
1350  }
1351  void SEGGER_SYSVIEW_DisableEvents(U32 DisableMask) {
1352    _SYSVIEW_Globals.DisabledEvents |= DisableMask;
1353  }
1354  int SEGGER_SYSVIEW_IsStarted(void) {
1355  #if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
1356    if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
1357      if (_SYSVIEW_Globals.RecursionCnt == 0) {   
1358        _SYSVIEW_Globals.RecursionCnt = 1;
1359        _HandleIncomingPacket();
1360        _SYSVIEW_Globals.RecursionCnt = 0;
1361      }
1362    }
1363  #endif
1364    return _SYSVIEW_Globals.EnableState;
1365  }
</code></pre>
        </div>
        <div class="column">
            <h3>small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-encrypt.c</h3>
            <pre><code>1  #include <stdint.h>
2  #ifdef HAVE_CONFIG_H
3  #include "config.h"
4  #endif
5  #if defined(USE_CRYPTO_OPENSSL)
6  #include <openssl/md5.h>
7  #include <openssl/rand.h>
8  #include <openssl/hmac.h>
9  #include <openssl/aes.h>
10  #elif defined(USE_CRYPTO_POLARSSL)
11  #include <polarssl/md5.h>
12  #include <polarssl/sha1.h>
13  #include <polarssl/aes.h>
14  #include <polarssl/entropy.h>
15  #include <polarssl/ctr_drbg.h>
16  #include <polarssl/version.h>
17  #define CIPHER_UNSUPPORTED "unsupported"
18  #include <time.h>
19  #ifdef _WIN32
20  #include <windows.h>
21  #include <wincrypt.h>
22  #else
23  #include <stdio.h>
24  #endif
25  #elif defined(USE_CRYPTO_MBEDTLS)
26  #include <mbedtls/md5.h>
27  #include <mbedtls/entropy.h>
28  #include <mbedtls/ctr_drbg.h>
29  #include <mbedtls/version.h>
30  #include <mbedtls/aes.h>
31  #define CIPHER_UNSUPPORTED "unsupported"
32  #include <time.h>
33  #ifdef _WIN32
34  #include <windows.h>
35  #include <wincrypt.h>
36  #else
37  #include <stdio.h>
38  #endif
39  #endif
40  #include <sodium.h>
41  #ifndef __MINGW32__
42  #include <arpa/inet.h>
43  #endif
44  #include "cache.h"
45  #include "encrypt.h"
46  #include "utils.h"
47  #define OFFSET_ROL(p, o) ((uint64_t)(*(p + o)) << (8 * o))
48  static uint8_t *enc_table;
49  static uint8_t *dec_table;
50  static uint8_t enc_key[MAX_KEY_LENGTH];
51  static int enc_key_len;
52  static int enc_iv_len;
53  static int enc_method;
54  static struct cache *iv_cache;
55  #ifdef DEBUG
56  static void
57  dump(char *tag, char *text, int len)
58  {
59      int i;
60      printf("%s: ", tag);
61      for (i = 0; i < len; i++)
62          printf("0x%02x ", (uint8_t)text[i]);
63      printf("\n");
64  }
65  #endif
66  static const char *supported_ciphers[CIPHER_NUM] = {
67      "table",
68      "rc4",
69      "rc4-md5-6",
70      "rc4-md5",
71      "aes-128-cfb",
72      "aes-192-cfb",
73      "aes-256-cfb",
74      "aes-128-ctr",
75      "aes-192-ctr",
76      "aes-256-ctr",
77      "bf-cfb",
78      "camellia-128-cfb",
79      "camellia-192-cfb",
80      "camellia-256-cfb",
81      "cast5-cfb",
82      "des-cfb",
83      "idea-cfb",
84      "rc2-cfb",
85      "seed-cfb",
86      "salsa20",
87      "chacha20",
88      "chacha20-ietf"
89  };
90  #ifdef USE_CRYPTO_POLARSSL
91  static const char *supported_ciphers_polarssl[CIPHER_NUM] = {
92      "table",
93      "ARC4-128",
94      "ARC4-128",
95      "ARC4-128",
96      "AES-128-CFB128",
97      "AES-192-CFB128",
98      "AES-256-CFB128",
99      "AES-128-CTR",
100      "AES-192-CTR",
101      "AES-256-CTR",
102      "BLOWFISH-CFB64",
103      "CAMELLIA-128-CFB128",
104      "CAMELLIA-192-CFB128",
105      "CAMELLIA-256-CFB128",
106      CIPHER_UNSUPPORTED,
107      CIPHER_UNSUPPORTED,
108      CIPHER_UNSUPPORTED,
109      CIPHER_UNSUPPORTED,
110      CIPHER_UNSUPPORTED,
111      "salsa20",
112      "chacha20",
113      "chacha20-ietf"
114  };
115  #endif
116  #ifdef USE_CRYPTO_MBEDTLS
117  static const char *supported_ciphers_mbedtls[CIPHER_NUM] = {
118      "table",
119      "ARC4-128",
120      "ARC4-128",
121      "ARC4-128",
122      "AES-128-CFB128",
123      "AES-192-CFB128",
124      "AES-256-CFB128",
125      "AES-128-CTR",
126      "AES-192-CTR",
127      "AES-256-CTR",
128      "BLOWFISH-CFB64",
129      "CAMELLIA-128-CFB128",
130      "CAMELLIA-192-CFB128",
131      "CAMELLIA-256-CFB128",
132      CIPHER_UNSUPPORTED,
133      CIPHER_UNSUPPORTED,
134      CIPHER_UNSUPPORTED,
135      CIPHER_UNSUPPORTED,
136      CIPHER_UNSUPPORTED,
137      "salsa20",
138      "chacha20",
139      "chacha20-ietf"
140  };
141  #endif
142  #ifdef USE_CRYPTO_APPLECC
143  static const CCAlgorithm supported_ciphers_applecc[CIPHER_NUM] = {
144      kCCAlgorithmInvalid,
145      kCCAlgorithmRC4,
146      kCCAlgorithmRC4,
147      kCCAlgorithmRC4,
148      kCCAlgorithmAES,
149      kCCAlgorithmAES,
150      kCCAlgorithmAES,
151      kCCAlgorithmAES,
152      kCCAlgorithmAES,
153      kCCAlgorithmAES,
154      kCCAlgorithmBlowfish,
155      kCCAlgorithmInvalid,
156      kCCAlgorithmInvalid,
157      kCCAlgorithmInvalid,
158      kCCAlgorithmCAST,
159      kCCAlgorithmDES,
160      kCCAlgorithmInvalid,
161      kCCAlgorithmRC2,
162      kCCAlgorithmInvalid,
163      kCCAlgorithmInvalid,
164      kCCAlgorithmInvalid,
165      kCCAlgorithmInvalid
166  };
167  static const CCMode supported_modes_applecc[CIPHER_NUM] = {
168      kCCAlgorithmInvalid,
169      kCCAlgorithmInvalid,
170      kCCModeRC4,
171      kCCModeRC4,
172      kCCModeCFB,
173      kCCModeCFB,
174      kCCModeCFB,
175      kCCModeCTR,
176      kCCModeCTR,
177      kCCModeCTR,
178      kCCModeCFB,
179      kCCAlgorithmInvalid,
180      kCCAlgorithmInvalid,
181      kCCAlgorithmInvalid,
182      kCCModeCFB,
183      kCCModeCFB,
184      kCCModeCFB,
185      kCCModeCFB,
186      kCCAlgorithmInvalid,
187      kCCAlgorithmInvalid,
188      kCCAlgorithmInvalid,
189      kCCAlgorithmInvalid
190  };
191  #endif
192  static const int supported_ciphers_iv_size[CIPHER_NUM] = {
193      0,  0,  6, 16, 16, 16, 16, 16, 16, 16,  8, 16, 16, 16,  8,  8,  8,  8, 16,  8,  8, 12
194  };
195  static const int supported_ciphers_key_size[CIPHER_NUM] = {
196      0, 16, 16, 16, 16, 24, 32, 16, 24, 32, 16, 16, 24, 32, 16,  8, 16, 16, 16, 32, 32, 32
197  };
198  static int
199  safe_memcmp(const void *s1, const void *s2, size_t n)
200  {
201      const unsigned char *_s1 = (const unsigned char *)s1;
202      const unsigned char *_s2 = (const unsigned char *)s2;
203      int ret                  = 0;
204      size_t i;
205      for (i = 0; i < n; i++)
206          ret |= _s1[i] ^ _s2[i];
207      return !!ret;
208  }
209  int
210  balloc(buffer_t *ptr, size_t capacity)
211  {
212      sodium_memzero(ptr, sizeof(buffer_t));
213      ptr->array    = ss_malloc(capacity);
214      ptr->capacity = capacity;
215      return capacity;
216  }
217  int
218  brealloc(buffer_t *ptr, size_t len, size_t capacity)
219  {
220      if (ptr == NULL)
221          return -1;
222      size_t real_capacity = max(len, capacity);
223      if (ptr->capacity < real_capacity) {
224          ptr->array    = ss_realloc(ptr->array, real_capacity);
225          ptr->capacity = real_capacity;
226      }
227      return real_capacity;
228  }
229  void
230  bfree(buffer_t *ptr)
231  {
232      if (ptr == NULL)
233          return;
234      ptr->idx      = 0;
235      ptr->len      = 0;
236      ptr->capacity = 0;
237      if (ptr->array != NULL) {
238          ss_free(ptr->array);
239      }
240  }
241  static int
242  crypto_stream_xor_ic(uint8_t *c, const uint8_t *m, uint64_t mlen,
243                       const uint8_t *n, uint64_t ic, const uint8_t *k,
244                       int method)
245  {
246      switch (method) {
247      case SALSA20:
248          return crypto_stream_salsa20_xor_ic(c, m, mlen, n, ic, k);
249      case CHACHA20:
250          return crypto_stream_chacha20_xor_ic(c, m, mlen, n, ic, k);
251      case CHACHA20IETF:
252          return crypto_stream_chacha20_ietf_xor_ic(c, m, mlen, n, (uint32_t)ic, k);
253      }
254      return 0;
255  }
256  static int
257  random_compare(const void *_x, const void *_y, uint32_t i,
258                 uint64_t a)
259  {
260      uint8_t x = *((uint8_t *)_x);
261      uint8_t y = *((uint8_t *)_y);
262      return a % (x + i) - a % (y + i);
263  }
264  static void
265  merge(uint8_t *left, int llength, uint8_t *right,
266        int rlength, uint32_t salt, uint64_t key)
267  {
268      uint8_t *ltmp = (uint8_t *)malloc(llength * sizeof(uint8_t));
269      uint8_t *rtmp = (uint8_t *)malloc(rlength * sizeof(uint8_t));
270      uint8_t *ll = ltmp;
271      uint8_t *rr = rtmp;
272      uint8_t *result = left;
273      memcpy(ltmp, left, llength * sizeof(uint8_t));
274      memcpy(rtmp, right, rlength * sizeof(uint8_t));
275      while (llength > 0 && rlength > 0) {
276          if (random_compare(ll, rr, salt, key) <= 0) {
<span onclick='openModal()' class='match'>277              *result = *ll;
278              ++ll;
279              --llength;
280          } else {
281              *result = *rr;
282              ++rr;
283              --rlength;
</span>284          }
285          ++result;
286      }
287      if (llength > 0) {
288          while (llength > 0) {
289              *result = *ll;
290              ++result;
291              ++ll;
292              --llength;
293          }
294      } else {
295          while (rlength > 0) {
296              *result = *rr;
297              ++result;
298              ++rr;
299              --rlength;
300          }
301      }
302      ss_free(ltmp);
303      ss_free(rtmp);
304  }
305  static void
306  merge_sort(uint8_t array[], int length,
307             uint32_t salt, uint64_t key)
308  {
309      uint8_t middle;
310      uint8_t *left, *right;
311      int llength;
312      if (length <= 1) {
313          return;
314      }
315      middle = length / 2;
316      llength = length - middle;
317      left  = array;
318      right = array + llength;
319      merge_sort(left, llength, salt, key);
320      merge_sort(right, middle, salt, key);
321      merge(left, llength, right, middle, salt, key);
322  }
323  int
324  enc_get_iv_len()
325  {
326      return enc_iv_len;
327  }
328  uint8_t* enc_get_key()
329  {
330      return enc_key;
331  }
332  int enc_get_key_len()
333  {
334      return enc_key_len;
335  }
336  unsigned char *enc_md5(const unsigned char *d, size_t n, unsigned char *md)
337  {
338  #if defined(USE_CRYPTO_OPENSSL)
339      return MD5(d, n, md);
340  #elif defined(USE_CRYPTO_POLARSSL)
341      static unsigned char m[16];
342      if (md == NULL) {
343          md = m;
344      }
345      md5(d, n, md);
346      return md;
347  #elif defined(USE_CRYPTO_MBEDTLS)
348      static unsigned char m[16];
349      if (md == NULL) {
350          md = m;
351      }
352      mbedtls_md5(d, n, md);
353      return md;
354  #endif
355  }
356  void
357  enc_table_init(const char *pass)
358  {
359      uint32_t i;
360      uint64_t key = 0;
361      uint8_t *digest;
362      enc_table = ss_malloc(256);
363      dec_table = ss_malloc(256);
364      digest = enc_md5((const uint8_t *)pass, strlen(pass), NULL);
365      for (i = 0; i < 8; i++)
366          key += OFFSET_ROL(digest, i);
367      for (i = 0; i < 256; ++i)
368          enc_table[i] = i;
369      for (i = 1; i < 1024; ++i)
370          merge_sort(enc_table, 256, i, key);
371      for (i = 0; i < 256; ++i)
372          dec_table[enc_table[i]] = i;
373  }
374  int
375  cipher_iv_size(const cipher_t *cipher)
376  {
377  #if defined(USE_CRYPTO_OPENSSL)
378      if (cipher->info == NULL)
379          return cipher->iv_len;
380      else
381          return EVP_CIPHER_iv_length(cipher->info);
382  #elif defined(USE_CRYPTO_POLARSSL) || defined(USE_CRYPTO_MBEDTLS)
383      if (cipher == NULL) {
384          return 0;
385      }
386      return cipher->info->iv_size;
387  #endif
388  }
389  int
390  cipher_key_size(const cipher_t *cipher)
391  {
392  #if defined(USE_CRYPTO_OPENSSL)
393      if (cipher->info == NULL)
394          return cipher->key_len;
395      else
396          return EVP_CIPHER_key_length(cipher->info);
397  #elif defined(USE_CRYPTO_POLARSSL)
398      if (cipher == NULL) {
399          return 0;
400      }
401      if (cipher->info->base != NULL && POLARSSL_CIPHER_ID_BLOWFISH ==
402          cipher->info->base->cipher) {
403          return 128 / 8;
404      }
405      return cipher->info->key_length / 8;
406  #elif defined(USE_CRYPTO_MBEDTLS)
407      if (cipher == NULL) {
408          return 0;
409      }
410      return cipher->info->key_bitlen / 8;
411  #endif
412  }
413  void
414  bytes_to_key_with_size(const char *pass, size_t len, uint8_t *md, size_t md_size)
415  {
416      uint8_t result[128];
417      enc_md5((const unsigned char *)pass, len, result);
418      memcpy(md, result, 16);
419      int i = 16;
420      for (; i < md_size; i += 16) {
421          memcpy(result + 16, pass, len);
422          enc_md5(result, 16 + len, result);
423          memcpy(md + i, result, 16);
424      }
425  }
426  int
427  bytes_to_key(const cipher_t *cipher, const digest_type_t *md,
428               const uint8_t *pass, uint8_t *key)
429  {
430      size_t datal;
431      datal = strlen((const char *)pass);
432  #if defined(USE_CRYPTO_OPENSSL)
433      MD5_CTX c;
434      unsigned char md_buf[MAX_MD_SIZE];
435      int nkey;
436      int addmd;
437      unsigned int i, j, mds;
438      mds  = 16;
439      nkey = cipher_key_size(cipher);
440      if (pass == NULL)
441          return nkey;
442      memset(&c, 0, sizeof(MD5_CTX));
443      for (j = 0, addmd = 0; j < nkey; addmd++) {
444          MD5_Init(&c);
445          if (addmd) {
446              MD5_Update(&c, md_buf, mds);
447          }
448          MD5_Update(&c, pass, datal);
449          MD5_Final(md_buf, &c);
450          for (i = 0; i < mds; i++, j++) {
451              if (j >= nkey)
452                  break;
453              key[j] = md_buf[i];
454          }
455      }
456      return nkey;
457  #elif defined(USE_CRYPTO_POLARSSL)
458      md_context_t c;
459      unsigned char md_buf[MAX_MD_SIZE];
460      int nkey;
461      int addmd;
462      unsigned int i, j, mds;
463      nkey = cipher_key_size(cipher);
464      mds  = md_get_size(md);
465      memset(&c, 0, sizeof(md_context_t));
466      if (pass == NULL)
467          return nkey;
468      if (md_init_ctx(&c, md))
469          return 0;
470      for (j = 0, addmd = 0; j < nkey; addmd++) {
471          md_starts(&c);
472          if (addmd) {
473              md_update(&c, md_buf, mds);
474          }
475          md_update(&c, pass, datal);
476          md_finish(&c, md_buf);
477          for (i = 0; i < mds; i++, j++) {
478              if (j >= nkey)
479                  break;
480              key[j] = md_buf[i];
481          }
482      }
483      md_free_ctx(&c);
484      return nkey;
485  #elif defined(USE_CRYPTO_MBEDTLS)
486      mbedtls_md_context_t c;
487      unsigned char md_buf[MAX_MD_SIZE];
488      int nkey;
489      int addmd;
490      unsigned int i, j, mds;
491      nkey = cipher_key_size(cipher);
492      mds  = mbedtls_md_get_size(md);
493      memset(&c, 0, sizeof(mbedtls_md_context_t));
494      if (pass == NULL)
495          return nkey;
496      if (mbedtls_md_setup(&c, md, 1))
497          return 0;
498      for (j = 0, addmd = 0; j < nkey; addmd++) {
499          mbedtls_md_starts(&c);
500          if (addmd) {
501              mbedtls_md_update(&c, md_buf, mds);
502          }
503          mbedtls_md_update(&c, pass, datal);
504          mbedtls_md_finish(&c, &(md_buf[0]));
505          for (i = 0; i < mds; i++, j++) {
506              if (j >= nkey)
507                  break;
508              key[j] = md_buf[i];
509          }
510      }
511      mbedtls_md_free(&c);
512      return nkey;
513  #endif
514  }
515  int
516  rand_bytes(uint8_t *output, int len)
517  {
518      randombytes_buf(output, len);
519      return 0;
520  }
521  const cipher_kt_t *
522  get_cipher_type(int method)
523  {
524      if (method <= TABLE || method >= CIPHER_NUM) {
525          LOGE("get_cipher_type(): Illegal method");
526          return NULL;
527      }
528      if (method == RC4_MD5 || method == RC4_MD5_6) {
529          method = RC4;
530      }
531      if (method >= SALSA20) {
532          return NULL;
533      }
534      const char *ciphername = supported_ciphers[method];
535  #if defined(USE_CRYPTO_OPENSSL)
536      return EVP_get_cipherbyname(ciphername);
537  #elif defined(USE_CRYPTO_POLARSSL)
538      const char *polarname = supported_ciphers_polarssl[method];
539      if (strcmp(polarname, CIPHER_UNSUPPORTED) == 0) {
540          LOGE("Cipher %s currently is not supported by PolarSSL library",
541               ciphername);
542          return NULL;
543      }
544      return cipher_info_from_string(polarname);
545  #elif defined(USE_CRYPTO_MBEDTLS)
546      const char *mbedtlsname = supported_ciphers_mbedtls[method];
547      if (strcmp(mbedtlsname, CIPHER_UNSUPPORTED) == 0) {
548          LOGE("Cipher %s currently is not supported by mbed TLS library",
549               ciphername);
550          return NULL;
551      }
552      return mbedtls_cipher_info_from_string(mbedtlsname);
553  #endif
554  }
555  const digest_type_t *
556  get_digest_type(const char *digest)
557  {
558      if (digest == NULL) {
559          LOGE("get_digest_type(): Digest name is null");
560          return NULL;
561      }
562  #if defined(USE_CRYPTO_OPENSSL)
563      return EVP_get_digestbyname(digest);
564  #elif defined(USE_CRYPTO_POLARSSL)
565      return md_info_from_string(digest);
566  #elif defined(USE_CRYPTO_MBEDTLS)
567      return mbedtls_md_info_from_string(digest);
568  #endif
569  }
570  void
571  cipher_context_init(cipher_ctx_t *ctx, int method, int enc)
572  {
573      if (method <= TABLE || method >= CIPHER_NUM) {
574          LOGE("cipher_context_init(): Illegal method");
575          return;
576      }
577      if (method >= SALSA20) {
578          enc_iv_len = supported_ciphers_iv_size[method];
579          return;
580      }
581      const char *ciphername = supported_ciphers[method];
582  #if defined(USE_CRYPTO_APPLECC)
583      cipher_cc_t *cc = &ctx->cc;
584      cc->cryptor = NULL;
585      cc->cipher  = supported_ciphers_applecc[method];
586      if (cc->cipher == kCCAlgorithmInvalid) {
587          cc->valid = kCCContextInvalid;
588      } else {
589          cc->valid = kCCContextValid;
590          if (cc->cipher == kCCAlgorithmRC4) {
591              cc->mode    = supported_modes_applecc[method];
592              cc->padding = ccNoPadding;
593          } else {
594              cc->mode = supported_modes_applecc[method];
595              if (cc->mode == kCCModeCTR) {
596                  cc->padding = ccNoPadding;
597              } else {
598                  cc->padding = ccPKCS7Padding;
599              }
600          }
601          return;
602      }
603  #endif
604      const cipher_kt_t *cipher = get_cipher_type(method);
605  #if defined(USE_CRYPTO_OPENSSL)
606      ctx->evp = EVP_CIPHER_CTX_new();
607      cipher_evp_t *evp = ctx->evp;
608      if (cipher == NULL) {
609          LOGE("Cipher %s not found in OpenSSL library", ciphername);
610          FATAL("Cannot initialize cipher");
611      }
612      if (!EVP_CipherInit_ex(evp, cipher, NULL, NULL, NULL, enc)) {
613          LOGE("Cannot initialize cipher %s", ciphername);
614          exit(EXIT_FAILURE);
615      }
616      if (!EVP_CIPHER_CTX_set_key_length(evp, enc_key_len)) {
617          EVP_CIPHER_CTX_cleanup(evp);
618          LOGE("Invalid key length: %d", enc_key_len);
619          exit(EXIT_FAILURE);
620      }
621      if (method > RC4_MD5) {
622          EVP_CIPHER_CTX_set_padding(evp, 1);
623      }
624  #elif defined(USE_CRYPTO_POLARSSL)
625      ctx->evp = (cipher_evp_t *)ss_malloc(sizeof(cipher_evp_t));
626      cipher_evp_t *evp = ctx->evp;
627      if (cipher == NULL) {
628          LOGE("Cipher %s not found in PolarSSL library", ciphername);
629          FATAL("Cannot initialize PolarSSL cipher");
630      }
631      if (cipher_init_ctx(evp, cipher) != 0) {
632          FATAL("Cannot initialize PolarSSL cipher context");
633      }
634  #elif defined(USE_CRYPTO_MBEDTLS)
635      ctx->evp = (cipher_evp_t *)ss_malloc(sizeof(cipher_evp_t));
636      cipher_evp_t *evp = ctx->evp;
637      if (cipher == NULL) {
638          LOGE("Cipher %s not found in mbed TLS library", ciphername);
639          FATAL("Cannot initialize mbed TLS cipher");
640      }
641      mbedtls_cipher_init(evp);
642      if (mbedtls_cipher_setup(evp, cipher) != 0) {
643          FATAL("Cannot initialize mbed TLS cipher context");
644      }
645  #endif
646  }
647  void
648  cipher_context_set_iv(cipher_ctx_t *ctx, uint8_t *iv, size_t iv_len,
649                        int enc)
650  {
651      const unsigned char *true_key;
652      if (iv == NULL) {
653          LOGE("cipher_context_set_iv(): IV is null");
654          return;
655      }
656      if (!enc) {
657          memcpy(ctx->iv, iv, iv_len);
658      }
659      if (enc_method >= SALSA20) {
660          return;
661      }
662      if (enc_method == RC4_MD5 || enc_method == RC4_MD5_6) {
663          unsigned char key_iv[32];
664          memcpy(key_iv, enc_key, 16);
665          memcpy(key_iv + 16, iv, iv_len);
666          true_key = enc_md5(key_iv, 16 + iv_len, NULL);
667          iv_len   = 0;
668      } else {
669          true_key = enc_key;
670      }
671  #ifdef USE_CRYPTO_APPLECC
672      cipher_cc_t *cc = &ctx->cc;
673      if (cc->valid == kCCContextValid) {
674          memcpy(cc->iv, iv, iv_len);
675          memcpy(cc->key, true_key, enc_key_len);
676          cc->iv_len  = iv_len;
677          cc->key_len = enc_key_len;
678          cc->encrypt = enc ? kCCEncrypt : kCCDecrypt;
679          if (cc->cryptor != NULL) {
680              CCCryptorRelease(cc->cryptor);
681              cc->cryptor = NULL;
682          }
683          CCCryptorStatus ret;
684          ret = CCCryptorCreateWithMode(
685              cc->encrypt,
686              cc->mode,
687              cc->cipher,
688              cc->padding,
689              cc->iv, cc->key, cc->key_len,
690              NULL, 0, 0, kCCModeOptionCTR_BE,
691              &cc->cryptor);
692          if (ret != kCCSuccess) {
693              if (cc->cryptor != NULL) {
694                  CCCryptorRelease(cc->cryptor);
695                  cc->cryptor = NULL;
696              }
697              FATAL("Cannot set CommonCrypto key and IV");
698          }
699          return;
700      }
701  #endif
702      cipher_evp_t *evp = ctx->evp;
703      if (evp == NULL) {
704          LOGE("cipher_context_set_iv(): Cipher context is null");
705          return;
706      }
707  #if defined(USE_CRYPTO_OPENSSL)
708      if (!EVP_CipherInit_ex(evp, NULL, NULL, true_key, iv, enc)) {
709          EVP_CIPHER_CTX_cleanup(evp);
710          FATAL("Cannot set key and IV");
711      }
712  #elif defined(USE_CRYPTO_POLARSSL)
713      if (cipher_setkey(evp, true_key, enc_key_len * 8, enc) != 0) {
714          cipher_free_ctx(evp);
715          FATAL("Cannot set PolarSSL cipher key");
716      }
717  #if POLARSSL_VERSION_NUMBER >= 0x01030000
718      if (cipher_set_iv(evp, iv, iv_len) != 0) {
719          cipher_free_ctx(evp);
720          FATAL("Cannot set PolarSSL cipher IV");
721      }
722      if (cipher_reset(evp) != 0) {
723          cipher_free_ctx(evp);
724          FATAL("Cannot finalize PolarSSL cipher context");
725      }
726  #else
727      if (cipher_reset(evp, iv) != 0) {
728          cipher_free_ctx(evp);
729          FATAL("Cannot set PolarSSL cipher IV");
730      }
731  #endif
732  #elif defined(USE_CRYPTO_MBEDTLS)
733      if (mbedtls_cipher_setkey(evp, true_key, enc_key_len * 8, enc) != 0) {
734          mbedtls_cipher_free(evp);
735          FATAL("Cannot set mbed TLS cipher key");
736      }
737      if (mbedtls_cipher_set_iv(evp, iv, iv_len) != 0) {
738          mbedtls_cipher_free(evp);
739          FATAL("Cannot set mbed TLS cipher IV");
740      }
741      if (mbedtls_cipher_reset(evp) != 0) {
742          mbedtls_cipher_free(evp);
743          FATAL("Cannot finalize mbed TLS cipher context");
744      }
745  #endif
746  #ifdef DEBUG
747      dump("IV", (char *)iv, iv_len);
748  #endif
749  }
750  void
751  cipher_context_release(cipher_ctx_t *ctx)
752  {
753      if (enc_method >= SALSA20) {
754          return;
755      }
756  #ifdef USE_CRYPTO_APPLECC
757      cipher_cc_t *cc = &ctx->cc;
758      if (cc->cryptor != NULL) {
759          CCCryptorRelease(cc->cryptor);
760          cc->cryptor = NULL;
761      }
762      if (cc->valid == kCCContextValid) {
763          return;
764      }
765  #endif
766  #if defined(USE_CRYPTO_OPENSSL)
767      EVP_CIPHER_CTX_free(ctx->evp);
768  #elif defined(USE_CRYPTO_POLARSSL)
769      cipher_free_ctx(ctx->evp);
770      ss_free(ctx->evp);
771  #elif defined(USE_CRYPTO_MBEDTLS)
772      mbedtls_cipher_free(ctx->evp);
773      ss_free(ctx->evp);
774  #endif
775  }
776  static int
777  cipher_context_update(cipher_ctx_t *ctx, uint8_t *output, size_t *olen,
778                        const uint8_t *input, size_t ilen)
779  {
780  #ifdef USE_CRYPTO_APPLECC
781      cipher_cc_t *cc = &ctx->cc;
782      if (cc->valid == kCCContextValid) {
783          CCCryptorStatus ret;
784          ret = CCCryptorUpdate(cc->cryptor, input, ilen, output,
785                                ilen, olen);
786          return (ret == kCCSuccess) ? 1 : 0;
787      }
788  #endif
789      cipher_evp_t *evp = ctx->evp;
790  #if defined(USE_CRYPTO_OPENSSL)
791      int err = 0, tlen = *olen;
792      err = EVP_CipherUpdate(evp, (uint8_t *)output, &tlen,
793                             (const uint8_t *)input, ilen);
794      *olen = tlen;
795      return err;
796  #elif defined(USE_CRYPTO_POLARSSL)
797      return !cipher_update(evp, (const uint8_t *)input, ilen,
798                            (uint8_t *)output, olen);
799  #elif defined(USE_CRYPTO_MBEDTLS)
800      return !mbedtls_cipher_update(evp, (const uint8_t *)input, ilen,
801                                    (uint8_t *)output, olen);
802  #endif
803  }
804  int ss_md5_hmac(char *auth, char *msg, int msg_len, uint8_t *iv)
805  {
806      uint8_t hash[MD5_BYTES];
807      uint8_t auth_key[MAX_IV_LENGTH + MAX_KEY_LENGTH];
808      memcpy(auth_key, iv, enc_iv_len);
809      memcpy(auth_key + enc_iv_len, enc_key, enc_key_len);
810  #if defined(USE_CRYPTO_OPENSSL)
811      HMAC(EVP_md5(), auth_key, enc_iv_len + enc_key_len, (uint8_t *)msg, msg_len, (uint8_t *)hash, NULL);
812  #elif defined(USE_CRYPTO_MBEDTLS)
813      mbedtls_md_hmac(mbedtls_md_info_from_type(MBEDTLS_MD_MD5), auth_key, enc_iv_len + enc_key_len, (uint8_t *)msg, msg_len, (uint8_t *)hash);
814  #else
815      md5_hmac(auth_key, enc_iv_len + enc_key_len, (uint8_t *)msg, msg_len, (uint8_t *)hash);
816  #endif
817      memcpy(auth, hash, MD5_BYTES);
818      return 0;
819  }
820  int ss_md5_hmac_with_key(char *auth, char *msg, int msg_len, uint8_t *auth_key, int key_len)
821  {
822      uint8_t hash[MD5_BYTES];
823  #if defined(USE_CRYPTO_OPENSSL)
824      HMAC(EVP_md5(), auth_key, key_len, (uint8_t *)msg, msg_len, (uint8_t *)hash, NULL);
825  #elif defined(USE_CRYPTO_MBEDTLS)
826      mbedtls_md_hmac(mbedtls_md_info_from_type(MBEDTLS_MD_MD5), auth_key, key_len, (uint8_t *)msg, msg_len, (uint8_t *)hash);
827  #else
828      md5_hmac(auth_key, key_len, (uint8_t *)msg, msg_len, (uint8_t *)hash);
829  #endif
830      memcpy(auth, hash, MD5_BYTES);
831      return 0;
832  }
833  int ss_md5_hash_func(char *auth, char *msg, int msg_len)
834  {
835      uint8_t hash[MD5_BYTES];
836  #if defined(USE_CRYPTO_OPENSSL)
837      MD5((uint8_t *)msg, msg_len, (uint8_t *)hash);
838  #elif defined(USE_CRYPTO_MBEDTLS)
839      mbedtls_md(mbedtls_md_info_from_type(MBEDTLS_MD_MD5), (uint8_t *)msg, msg_len, (uint8_t *)hash);
840  #else
841      md5((uint8_t *)msg, msg_len, (uint8_t *)hash);
842  #endif
843      memcpy(auth, hash, MD5_BYTES);
844      return 0;
845  }
846  int ss_sha1_hmac(char *auth, char *msg, int msg_len, uint8_t *iv)
847  {
848      uint8_t hash[SHA1_BYTES];
849      uint8_t auth_key[MAX_IV_LENGTH + MAX_KEY_LENGTH];
850      memcpy(auth_key, iv, enc_iv_len);
851      memcpy(auth_key + enc_iv_len, enc_key, enc_key_len);
852  #if defined(USE_CRYPTO_OPENSSL)
853      HMAC(EVP_sha1(), auth_key, enc_iv_len + enc_key_len, (uint8_t *)msg, msg_len, (uint8_t *)hash, NULL);
854  #elif defined(USE_CRYPTO_MBEDTLS)
855      mbedtls_md_hmac(mbedtls_md_info_from_type(MBEDTLS_MD_SHA1), auth_key, enc_iv_len + enc_key_len, (uint8_t *)msg, msg_len, (uint8_t *)hash);
856  #else
857      sha1_hmac(auth_key, enc_iv_len + enc_key_len, (uint8_t *)msg, msg_len, (uint8_t *)hash);
858  #endif
859      memcpy(auth, hash, SHA1_BYTES);
860      return 0;
861  }
862  int ss_sha1_hmac_with_key(char *auth, char *msg, int msg_len, uint8_t *auth_key, int key_len)
863  {
864      uint8_t hash[SHA1_BYTES];
865  #if defined(USE_CRYPTO_OPENSSL)
866      HMAC(EVP_sha1(), auth_key, key_len, (uint8_t *)msg, msg_len, (uint8_t *)hash, NULL);
867  #elif defined(USE_CRYPTO_MBEDTLS)
868      mbedtls_md_hmac(mbedtls_md_info_from_type(MBEDTLS_MD_SHA1), auth_key, key_len, (uint8_t *)msg, msg_len, (uint8_t *)hash);
869  #else
870      sha1_hmac(auth_key, key_len, (uint8_t *)msg, msg_len, (uint8_t *)hash);
871  #endif
872      memcpy(auth, hash, SHA1_BYTES);
873      return 0;
874  }
875  int ss_sha1_hash_func(char *auth, char *msg, int msg_len)
876  {
877      uint8_t hash[SHA1_BYTES];
878  #if defined(USE_CRYPTO_OPENSSL)
879      SHA1((uint8_t *)msg, msg_len, (uint8_t *)hash);
880  #elif defined(USE_CRYPTO_MBEDTLS)
881      mbedtls_md(mbedtls_md_info_from_type(MBEDTLS_MD_SHA1), (uint8_t *)msg, msg_len, (uint8_t *)hash);
882  #else
883      sha1((uint8_t *)msg, msg_len, (uint8_t *)hash);
884  #endif
885      memcpy(auth, hash, SHA1_BYTES);
886      return 0;
887  }
888  int ss_aes_128_cbc(char *encrypt, char *out_data, char *key)
889  {
890      unsigned char iv[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
891  #if defined(USE_CRYPTO_OPENSSL)
892      AES_KEY aes;
893      AES_set_encrypt_key((unsigned char*)key, 128, &aes);
894      AES_cbc_encrypt((const unsigned char *)encrypt, (unsigned char *)out_data, 16, &aes, iv, AES_ENCRYPT);
895  #elif defined(USE_CRYPTO_MBEDTLS)
896      mbedtls_aes_context aes;
897      unsigned char output[16];
898      mbedtls_aes_setkey_enc( &aes, (unsigned char *)key, 128 );
899      mbedtls_aes_crypt_cbc( &aes, MBEDTLS_AES_ENCRYPT, 16, iv, (unsigned char *)encrypt, output );
900      memcpy(out_data, output, 16);
901  #else
902      aes_context aes;
903      unsigned char output[16];
904      aes_setkey_enc( &aes, (unsigned char *)key, 128 );
905      aes_crypt_cbc( &aes, AES_ENCRYPT, 16, iv, (unsigned char *)encrypt, output );
906      memcpy(out_data, output, 16);
907  #endif
908      return 0;
909  }
910  int ss_onetimeauth(buffer_t *buf, uint8_t *iv, size_t capacity)
911  {
912      uint8_t hash[ONETIMEAUTH_BYTES * 2];
913      uint8_t auth_key[MAX_IV_LENGTH + MAX_KEY_LENGTH];
914      memcpy(auth_key, iv, enc_iv_len);
915      memcpy(auth_key + enc_iv_len, enc_key, enc_key_len);
916      brealloc(buf, ONETIMEAUTH_BYTES + buf->len, capacity);
917  #if defined(USE_CRYPTO_OPENSSL)
918      HMAC(EVP_sha1(), auth_key, enc_iv_len + enc_key_len, (uint8_t *)buf->array, buf->len, (uint8_t *)hash, NULL);
919  #elif defined(USE_CRYPTO_MBEDTLS)
920      mbedtls_md_hmac(mbedtls_md_info_from_type(
921                          MBEDTLS_MD_SHA1), auth_key, enc_iv_len + enc_key_len, (uint8_t *)buf->array, buf->len,
922                      (uint8_t *)hash);
923  #else
924      sha1_hmac(auth_key, enc_iv_len + enc_key_len, (uint8_t *)buf->array, buf->len, (uint8_t *)hash);
925  #endif
926      memcpy(buf->array + buf->len, hash, ONETIMEAUTH_BYTES);
927      buf->len += ONETIMEAUTH_BYTES;
928      return 0;
929  }
930  int
931  ss_onetimeauth_verify(buffer_t *buf, uint8_t *iv)
932  {
933      uint8_t hash[ONETIMEAUTH_BYTES * 2];
934      uint8_t auth_key[MAX_IV_LENGTH + MAX_KEY_LENGTH];
935      memcpy(auth_key, iv, enc_iv_len);
936      memcpy(auth_key + enc_iv_len, enc_key, enc_key_len);
937      size_t len = buf->len - ONETIMEAUTH_BYTES;
938  #if defined(USE_CRYPTO_OPENSSL)
939      HMAC(EVP_sha1(), auth_key, enc_iv_len + enc_key_len, (uint8_t *)buf->array, len, hash, NULL);
940  #elif defined(USE_CRYPTO_MBEDTLS)
941      mbedtls_md_hmac(mbedtls_md_info_from_type(
942                          MBEDTLS_MD_SHA1), auth_key, enc_iv_len + enc_key_len, (uint8_t *)buf->array, len, hash);
943  #else
944      sha1_hmac(auth_key, enc_iv_len + enc_key_len, (uint8_t *)buf->array, len, hash);
945  #endif
946      return safe_memcmp(buf->array + len, hash, ONETIMEAUTH_BYTES);
947  }
948  int
949  ss_encrypt_all(buffer_t *plain, int method, int auth, size_t capacity)
950  {
951      if (method > TABLE) {
952          cipher_ctx_t evp;
953          cipher_context_init(&evp, method, 1);
954          size_t iv_len = enc_iv_len;
955          int err       = 1;
956          static buffer_t tmp = { 0, 0, 0, NULL };
957          brealloc(&tmp, iv_len + plain->len, capacity);
958          buffer_t *cipher = &tmp;
959          cipher->len = plain->len;
960          uint8_t iv[MAX_IV_LENGTH];
961          rand_bytes(iv, iv_len);
962          cipher_context_set_iv(&evp, iv, iv_len, 1);
963          memcpy(cipher->array, iv, iv_len);
964          if (auth) {
965              ss_onetimeauth(plain, iv, capacity);
966              cipher->len = plain->len;
967          }
968          if (method >= SALSA20) {
969              crypto_stream_xor_ic((uint8_t *)(cipher->array + iv_len),
970                                   (const uint8_t *)plain->array, (uint64_t)(plain->len),
971                                   (const uint8_t *)iv,
972                                   0, enc_key, method);
973          } else {
974              err = cipher_context_update(&evp, (uint8_t *)(cipher->array + iv_len),
975                                          &cipher->len, (const uint8_t *)plain->array,
976                                          plain->len);
977          }
978          if (!err) {
979              bfree(plain);
980              cipher_context_release(&evp);
981              return -1;
982          }
983  #ifdef DEBUG
984          dump("PLAIN", plain->array, plain->len);
985          dump("CIPHER", cipher->array + iv_len, cipher->len);
986  #endif
987          cipher_context_release(&evp);
988          brealloc(plain, iv_len + cipher->len, capacity);
989          memcpy(plain->array, cipher->array, iv_len + cipher->len);
990          plain->len = iv_len + cipher->len;
991          return 0;
992      } else {
993          char *begin = plain->array;
994          char *ptr   = plain->array;
995          while (ptr < begin + plain->len) {
996              *ptr = (char)enc_table[(uint8_t)*ptr];
997              ptr++;
998          }
999          return 0;
1000      }
1001  }
1002  int
1003  ss_encrypt(buffer_t *plain, enc_ctx_t *ctx, size_t capacity)
1004  {
1005      if (ctx != NULL) {
1006          static buffer_t tmp = { 0, 0, 0, NULL };
1007          int err       = 1;
1008          size_t iv_len = 0;
1009          if (!ctx->init) {
1010              iv_len = enc_iv_len;
1011          }
1012          brealloc(&tmp, iv_len + plain->len, capacity);
1013          buffer_t *cipher = &tmp;
1014          cipher->len = plain->len;
1015          if (!ctx->init) {
1016              cipher_context_set_iv(&ctx->evp, ctx->evp.iv, iv_len, 1);
1017              memcpy(cipher->array, ctx->evp.iv, iv_len);
1018              ctx->counter = 0;
1019              ctx->init    = 1;
1020          }
1021          if (enc_method >= SALSA20) {
1022              int padding = ctx->counter % SODIUM_BLOCK_SIZE;
1023              brealloc(cipher, iv_len + (padding + cipher->len) * 2, capacity);
1024              if (padding) {
1025                  brealloc(plain, plain->len + padding, capacity);
1026                  memmove(plain->array + padding, plain->array, plain->len);
1027                  sodium_memzero(plain->array, padding);
1028              }
1029              crypto_stream_xor_ic((uint8_t *)(cipher->array + iv_len),
1030                                   (const uint8_t *)plain->array,
1031                                   (uint64_t)(plain->len + padding),
1032                                   (const uint8_t *)ctx->evp.iv,
1033                                   ctx->counter / SODIUM_BLOCK_SIZE, enc_key,
1034                                   enc_method);
1035              ctx->counter += plain->len;
1036              if (padding) {
1037                  memmove(cipher->array + iv_len,
1038                          cipher->array + iv_len + padding, cipher->len);
1039              }
1040          } else {
1041              err =
1042                  cipher_context_update(&ctx->evp,
1043                                        (uint8_t *)(cipher->array + iv_len),
1044                                        &cipher->len, (const uint8_t *)plain->array,
1045                                        plain->len);
1046              if (!err) {
1047                  return -1;
1048              }
1049          }
1050  #ifdef DEBUG
1051          dump("PLAIN", plain->array, plain->len);
1052          dump("CIPHER", cipher->array + iv_len, cipher->len);
1053  #endif
1054          brealloc(plain, iv_len + cipher->len, capacity);
1055          memcpy(plain->array, cipher->array, iv_len + cipher->len);
1056          plain->len = iv_len + cipher->len;
1057          return 0;
1058      } else {
1059          char *begin = plain->array;
1060          char *ptr   = plain->array;
1061          while (ptr < begin + plain->len) {
1062              *ptr = (char)enc_table[(uint8_t)*ptr];
1063              ptr++;
1064          }
1065          return 0;
1066      }
1067  }
1068  int
1069  ss_decrypt_all(buffer_t *cipher, int method, int auth, size_t capacity)
1070  {
1071      if (method > TABLE) {
1072          size_t iv_len = enc_iv_len;
1073          int ret       = 1;
1074          if (cipher->len <= iv_len) {
1075              return -1;
1076          }
1077          cipher_ctx_t evp;
1078          cipher_context_init(&evp, method, 0);
1079          static buffer_t tmp = { 0, 0, 0, NULL };
1080          brealloc(&tmp, cipher->len, capacity);
1081          buffer_t *plain = &tmp;
1082          plain->len = cipher->len - iv_len;
1083          uint8_t iv[MAX_IV_LENGTH];
1084          memcpy(iv, cipher->array, iv_len);
1085          cipher_context_set_iv(&evp, iv, iv_len, 0);
1086          if (method >= SALSA20) {
1087              crypto_stream_xor_ic((uint8_t *)plain->array,
1088                                   (const uint8_t *)(cipher->array + iv_len),
1089                                   (uint64_t)(cipher->len - iv_len),
1090                                   (const uint8_t *)iv, 0, enc_key, method);
1091          } else {
1092              ret = cipher_context_update(&evp, (uint8_t *)plain->array, &plain->len,
1093                                          (const uint8_t *)(cipher->array + iv_len),
1094                                          cipher->len - iv_len);
1095          }
1096          if (auth || (plain->array[0] & ONETIMEAUTH_FLAG)) {
1097              if (plain->len > ONETIMEAUTH_BYTES) {
1098                  ret = !ss_onetimeauth_verify(plain, iv);
1099                  if (ret) {
1100                      plain->len -= ONETIMEAUTH_BYTES;
1101                  }
1102              } else {
1103                  ret = 0;
1104              }
1105          }
1106          if (!ret) {
1107              bfree(cipher);
1108              cipher_context_release(&evp);
1109              return -1;
1110          }
1111  #ifdef DEBUG
1112          dump("PLAIN", plain->array, plain->len);
1113          dump("CIPHER", cipher->array + iv_len, cipher->len - iv_len);
1114  #endif
1115          cipher_context_release(&evp);
1116          brealloc(cipher, plain->len, capacity);
1117          memcpy(cipher->array, plain->array, plain->len);
1118          cipher->len = plain->len;
1119          return 0;
1120      } else {
1121          char *begin = cipher->array;
1122          char *ptr   = cipher->array;
1123          while (ptr < begin + cipher->len) {
1124              *ptr = (char)dec_table[(uint8_t)*ptr];
1125              ptr++;
1126          }
1127          return 0;
1128      }
1129  }
1130  int
1131  ss_decrypt(buffer_t *cipher, enc_ctx_t *ctx, size_t capacity)
1132  {
1133      if (ctx != NULL) {
1134          static buffer_t tmp = { 0, 0, 0, NULL };
1135          size_t iv_len = 0;
1136          int err       = 1;
1137          brealloc(&tmp, cipher->len, capacity);
1138          buffer_t *plain = &tmp;
1139          plain->len = cipher->len;
1140          if (!ctx->init) {
1141              uint8_t iv[MAX_IV_LENGTH];
1142              iv_len      = enc_iv_len;
1143              plain->len -= iv_len;
1144              memcpy(iv, cipher->array, iv_len);
1145              cipher_context_set_iv(&ctx->evp, iv, iv_len, 0);
1146              ctx->counter = 0;
1147              ctx->init    = 1;
1148              if (enc_method > RC4) {
1149                  if (cache_key_exist(iv_cache, (char *)iv, iv_len)) {
1150                      bfree(cipher);
1151                      return -1;
1152                  } else {
1153                      cache_insert(iv_cache, (char *)iv, iv_len, NULL);
1154                  }
1155              }
1156          }
1157          if (enc_method >= SALSA20) {
1158              int padding = ctx->counter % SODIUM_BLOCK_SIZE;
1159              brealloc(plain, (plain->len + padding) * 2, capacity);
1160              if (padding) {
1161                  brealloc(cipher, cipher->len + padding, capacity);
1162                  memmove(cipher->array + iv_len + padding, cipher->array + iv_len,
1163                          cipher->len - iv_len);
1164                  sodium_memzero(cipher->array + iv_len, padding);
1165              }
1166              crypto_stream_xor_ic((uint8_t *)plain->array,
1167                                   (const uint8_t *)(cipher->array + iv_len),
1168                                   (uint64_t)(cipher->len - iv_len + padding),
1169                                   (const uint8_t *)ctx->evp.iv,
1170                                   ctx->counter / SODIUM_BLOCK_SIZE, enc_key,
1171                                   enc_method);
1172              ctx->counter += cipher->len - iv_len;
1173              if (padding) {
1174                  memmove(plain->array, plain->array + padding, plain->len);
1175              }
1176          } else {
1177              err = cipher_context_update(&ctx->evp, (uint8_t *)plain->array, &plain->len,
1178                                          (const uint8_t *)(cipher->array + iv_len),
1179                                          cipher->len - iv_len);
1180          }
1181          if (!err) {
1182              bfree(cipher);
1183              return -1;
1184          }
1185  #ifdef DEBUG
1186          dump("PLAIN", plain->array, plain->len);
1187          dump("CIPHER", cipher->array + iv_len, cipher->len - iv_len);
1188  #endif
1189          brealloc(cipher, plain->len, capacity);
1190          memcpy(cipher->array, plain->array, plain->len);
1191          cipher->len = plain->len;
1192          return 0;
1193      } else {
1194          char *begin = cipher->array;
1195          char *ptr   = cipher->array;
1196          while (ptr < begin + cipher->len) {
1197              *ptr = (char)dec_table[(uint8_t)*ptr];
1198              ptr++;
1199          }
1200          return 0;
1201      }
1202  }
1203  void
1204  enc_ctx_init(int method, enc_ctx_t *ctx, int enc)
1205  {
1206      sodium_memzero(ctx, sizeof(enc_ctx_t));
1207      cipher_context_init(&ctx->evp, method, enc);
1208      if (enc) {
1209          rand_bytes(ctx->evp.iv, enc_iv_len);
1210      }
1211  }
1212  void
1213  enc_key_init(int method, const char *pass)
1214  {
1215      if (method <= TABLE || method >= CIPHER_NUM) {
1216          LOGE("enc_key_init(): Illegal method");
1217          return;
1218      }
1219      cache_create(&iv_cache, 256, NULL);
1220  #if defined(USE_CRYPTO_OPENSSL)
1221      OpenSSL_add_all_algorithms();
1222  #else
1223      cipher_kt_t cipher_info;
1224  #endif
1225      cipher_t cipher;
1226      memset(&cipher, 0, sizeof(cipher_t));
1227      if (sodium_init() == -1) {
1228          FATAL("Failed to initialize sodium");
1229      }
1230      if (method == SALSA20 || method == CHACHA20 || method == CHACHA20IETF) {
1231  #if defined(USE_CRYPTO_OPENSSL)
1232          cipher.info    = NULL;
1233          cipher.key_len = supported_ciphers_key_size[method];
1234          cipher.iv_len  = supported_ciphers_iv_size[method];
1235  #endif
1236  #if defined(USE_CRYPTO_POLARSSL)
1237          cipher.info             = &cipher_info;
1238          cipher.info->base       = NULL;
1239          cipher.info->key_length = supported_ciphers_key_size[method] * 8;
1240          cipher.info->iv_size    = supported_ciphers_iv_size[method];
1241  #endif
1242  #if defined(USE_CRYPTO_MBEDTLS)
1243          cipher.info             = &cipher_info;
1244          cipher.info->base       = NULL;
1245          cipher.info->key_bitlen = supported_ciphers_key_size[method] * 8;
1246          cipher.info->iv_size    = supported_ciphers_iv_size[method];
1247  #endif
1248      } else {
1249          cipher.info = (cipher_kt_t *)get_cipher_type(method);
1250      }
1251      if (cipher.info == NULL && cipher.key_len == 0) {
1252          do {
1253  #if defined(USE_CRYPTO_POLARSSL) && defined(USE_CRYPTO_APPLECC)
1254              if (supported_ciphers_applecc[method] != kCCAlgorithmInvalid) {
1255                  cipher_info.base       = NULL;
1256                  cipher_info.key_length = supported_ciphers_key_size[method] * 8;
1257                  cipher_info.iv_size    = supported_ciphers_iv_size[method];
1258                  cipher.info            = (cipher_kt_t *)&cipher_info;
1259                  break;
1260              }
1261  #endif
1262  #if defined(USE_CRYPTO_MBEDTLS) && defined(USE_CRYPTO_APPLECC)
1263              if (supported_ciphers_applecc[method] != kCCAlgorithmInvalid) {
1264                  cipher_info.base       = NULL;
1265                  cipher_info.key_bitlen = supported_ciphers_key_size[method] * 8;
1266                  cipher_info.iv_size    = supported_ciphers_iv_size[method];
1267                  cipher.info            = (cipher_kt_t *)&cipher_info;
1268                  break;
1269              }
1270  #endif
1271              LOGE("Cipher %s not found in crypto library", supported_ciphers[method]);
1272              FATAL("Cannot initialize cipher");
1273          } while (0);
1274      }
1275      const digest_type_t *md = get_digest_type("MD5");
1276      if (md == NULL) {
1277          FATAL("MD5 Digest not found in crypto library");
1278      }
1279      enc_key_len = bytes_to_key(&cipher, md, (const uint8_t *)pass, enc_key);
1280      if (enc_key_len == 0) {
1281          FATAL("Cannot generate key and IV");
1282      }
1283      if (method == RC4_MD5 || method == RC4_MD5_6) {
1284          enc_iv_len = supported_ciphers_iv_size[method];
1285      } else {
1286          enc_iv_len = cipher_iv_size(&cipher);
1287      }
1288      enc_method = method;
1289  }
1290  int
1291  enc_init(const char *pass, const char *method)
1292  {
1293      int m = TABLE;
1294      if (method != NULL) {
1295          for (m = TABLE; m < CIPHER_NUM; m++)
1296              if (strcmp(method, supported_ciphers[m]) == 0) {
1297                  break;
1298              }
1299          if (m >= CIPHER_NUM) {
1300              LOGE("Invalid cipher name: %s, use rc4-md5 instead", method);
1301              m = RC4_MD5;
1302          }
1303      }
1304      if (m == TABLE) {
1305          enc_table_init(pass);
1306      } else {
1307          enc_key_init(m, pass);
1308      }
1309      return m;
1310  }
1311  int
1312  ss_check_hash(buffer_t *buf, chunk_t *chunk, enc_ctx_t *ctx, size_t capacity)
1313  {
1314      int i, j, k;
1315      ssize_t blen  = buf->len;
1316      uint32_t cidx = chunk->idx;
1317      brealloc(chunk->buf, chunk->len + blen, capacity);
1318      brealloc(buf, chunk->len + blen, capacity);
1319      for (i = 0, j = 0, k = 0; i < blen; i++) {
1320          chunk->buf->array[cidx++] = buf->array[k++];
1321          if (cidx == CLEN_BYTES) {
1322              uint16_t clen = ntohs(*((uint16_t *)chunk->buf->array));
1323              brealloc(chunk->buf, clen + AUTH_BYTES, capacity);
1324              chunk->len = clen;
1325          }
1326          if (cidx == chunk->len + AUTH_BYTES) {
1327              uint8_t hash[ONETIMEAUTH_BYTES * 2];
1328              uint8_t key[MAX_IV_LENGTH + sizeof(uint32_t)];
1329              uint32_t c = htonl(chunk->counter);
1330              memcpy(key, ctx->evp.iv, enc_iv_len);
1331              memcpy(key + enc_iv_len, &c, sizeof(uint32_t));
1332  #if defined(USE_CRYPTO_OPENSSL)
1333              HMAC(EVP_sha1(), key, enc_iv_len + sizeof(uint32_t),
1334                   (uint8_t *)chunk->buf->array + AUTH_BYTES, chunk->len, hash, NULL);
1335  #elif defined(USE_CRYPTO_MBEDTLS)
1336              mbedtls_md_hmac(mbedtls_md_info_from_type(MBEDTLS_MD_SHA1), key, enc_iv_len + sizeof(uint32_t),
1337                              (uint8_t *)chunk->buf->array + AUTH_BYTES, chunk->len, hash);
1338  #else
1339              sha1_hmac(key, enc_iv_len + sizeof(uint32_t),
1340                        (uint8_t *)chunk->buf->array + AUTH_BYTES, chunk->len, hash);
1341  #endif
1342              if (safe_memcmp(hash, chunk->buf->array + CLEN_BYTES, ONETIMEAUTH_BYTES) != 0) {
1343                  return 0;
1344              }
1345              memmove(buf->array + j + chunk->len, buf->array + k, blen - i - 1);
1346              memcpy(buf->array + j, chunk->buf->array + AUTH_BYTES, chunk->len);
1347              j   += chunk->len;
1348              k    = j;
1349              cidx = 0;
1350              chunk->counter++;
1351          }
1352      }
1353      buf->len   = j;
1354      chunk->idx = cidx;
1355      return 1;
1356  }
1357  int
1358  ss_gen_hash(buffer_t *buf, uint32_t *counter, enc_ctx_t *ctx, size_t capacity)
1359  {
1360      ssize_t blen       = buf->len;
1361      uint16_t chunk_len = htons((uint16_t)blen);
1362      uint8_t hash[ONETIMEAUTH_BYTES * 2];
1363      uint8_t key[MAX_IV_LENGTH + sizeof(uint32_t)];
1364      uint32_t c = htonl(*counter);
1365      brealloc(buf, AUTH_BYTES + blen, capacity);
1366      memcpy(key, ctx->evp.iv, enc_iv_len);
1367      memcpy(key + enc_iv_len, &c, sizeof(uint32_t));
1368  #if defined(USE_CRYPTO_OPENSSL)
1369      HMAC(EVP_sha1(), key, enc_iv_len + sizeof(uint32_t), (uint8_t *)buf->array, blen, hash, NULL);
1370  #elif defined(USE_CRYPTO_MBEDTLS)
1371      mbedtls_md_hmac(mbedtls_md_info_from_type(
1372                          MBEDTLS_MD_SHA1), key, enc_iv_len + sizeof(uint32_t), (uint8_t *)buf->array, blen, hash);
1373  #else
1374      sha1_hmac(key, enc_iv_len + sizeof(uint32_t), (uint8_t *)buf->array, blen, hash);
1375  #endif
1376      memmove(buf->array + AUTH_BYTES, buf->array, blen);
1377      memcpy(buf->array + CLEN_BYTES, hash, ONETIMEAUTH_BYTES);
1378      memcpy(buf->array, &chunk_len, CLEN_BYTES);
1379      *counter = *counter + 1;
1380      buf->len = blen + AUTH_BYTES;
1381      return 0;
1382  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-SEGGER_SYSVIEW.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-encrypt.c</div>
                </div>
                <div class="column column_space"><pre><code>1136      pModule->pNext = 0;
1137      _pFirstModule = pModule;
1138      _NumModules = 1;
1139    } else {
1140      pModule->EventOffset = _pFirstModule->EventOffset + _pFirstModule->NumEvents;
1141      pModule->pNext = _pFirstModule;
1142      _pFirstModule = pModule;
</pre></code></div>
                <div class="column column_space"><pre><code>277              *result = *ll;
278              ++ll;
279              --llength;
280          } else {
281              *result = *rr;
282              ++rr;
283              --rlength;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    