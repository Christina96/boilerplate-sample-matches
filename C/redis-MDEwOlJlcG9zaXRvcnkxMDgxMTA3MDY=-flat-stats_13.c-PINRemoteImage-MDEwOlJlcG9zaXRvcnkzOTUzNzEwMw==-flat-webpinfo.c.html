
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.103545301069218%, Tokens: 8</h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-stats_13.c</h3>
            <pre><code>1  #define JEMALLOC_STATS_C_
2  #include "jemalloc/internal/jemalloc_preamble.h"
3  #include "jemalloc/internal/jemalloc_internal_includes.h"
4  #include "jemalloc/internal/assert.h"
5  #include "jemalloc/internal/ctl.h"
6  #include "jemalloc/internal/emitter.h"
7  #include "jemalloc/internal/mutex.h"
8  #include "jemalloc/internal/mutex_prof.h"
9  const char *global_mutex_names[mutex_prof_num_global_mutexes] = {
10  #define OP(mtx) #mtx,
11  	MUTEX_PROF_GLOBAL_MUTEXES
12  #undef OP
13  };
14  const char *arena_mutex_names[mutex_prof_num_arena_mutexes] = {
15  #define OP(mtx) #mtx,
16  	MUTEX_PROF_ARENA_MUTEXES
17  #undef OP
18  };
19  #define CTL_GET(n, v, t) do {						\
20  	size_t sz = sizeof(t);						\
21  	xmallctl(n, (void *)v, &sz, NULL, 0);				\
22  } while (0)
23  #define CTL_M2_GET(n, i, v, t) do {					\
24  	size_t mib[CTL_MAX_DEPTH];					\
25  	size_t miblen = sizeof(mib) / sizeof(size_t);			\
26  	size_t sz = sizeof(t);						\
27  	xmallctlnametomib(n, mib, &miblen);				\
28  	mib[2] = (i);							\
29  	xmallctlbymib(mib, miblen, (void *)v, &sz, NULL, 0);		\
30  } while (0)
31  #define CTL_M2_M4_GET(n, i, j, v, t) do {				\
32  	size_t mib[CTL_MAX_DEPTH];					\
33  	size_t miblen = sizeof(mib) / sizeof(size_t);			\
34  	size_t sz = sizeof(t);						\
35  	xmallctlnametomib(n, mib, &miblen);				\
36  	mib[2] = (i);							\
37  	mib[4] = (j);							\
38  	xmallctlbymib(mib, miblen, (void *)v, &sz, NULL, 0);		\
39  } while (0)
40  bool opt_stats_print = false;
41  char opt_stats_print_opts[stats_print_tot_num_options+1] = "";
42  static uint64_t
43  rate_per_second(uint64_t value, uint64_t uptime_ns) {
44  	uint64_t billion = 1000000000;
45  	if (uptime_ns == 0 || value == 0) {
46  		return 0;
47  	}
48  	if (uptime_ns < billion) {
49  		return value;
50  	} else {
51  		uint64_t uptime_s = uptime_ns / billion;
52  		return value / uptime_s;
53  	}
54  }
55  static bool
<span onclick='openModal()' class='match'>56  get_rate_str(uint64_t dividend, uint64_t divisor, char str[6]) {
57  	if (divisor == 0 || dividend > divisor) {
58  		return true;
59  	}
60  	if (dividend > 0) {
61  		assert(UINT64_MAX / dividend >= 1000);
62  	}
</span>63  	unsigned n = (unsigned)((dividend * 1000) / divisor);
64  	if (n < 10) {
65  		malloc_snprintf(str, 6, "0.00%u", n);
66  	} else if (n < 100) {
67  		malloc_snprintf(str, 6, "0.0%u", n);
68  	} else if (n < 1000) {
69  		malloc_snprintf(str, 6, "0.%u", n);
70  	} else {
71  		malloc_snprintf(str, 6, "1");
72  	}
73  	return false;
74  }
75  #define MUTEX_CTL_STR_MAX_LENGTH 128
76  static void
77  gen_mutex_ctl_str(char *str, size_t buf_len, const char *prefix,
78      const char *mutex, const char *counter) {
79  	malloc_snprintf(str, buf_len, "stats.%s.%s.%s", prefix, mutex, counter);
80  }
81  static void
82  mutex_stats_init_cols(emitter_row_t *row, const char *table_name,
83      emitter_col_t *name,
84      emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
85      emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters]) {
86  	mutex_prof_uint64_t_counter_ind_t k_uint64_t = 0;
87  	mutex_prof_uint32_t_counter_ind_t k_uint32_t = 0;
88  	emitter_col_t *col;
89  	if (name != NULL) {
90  		emitter_col_init(name, row);
91  		name->justify = emitter_justify_left;
92  		name->width = 21;
93  		name->type = emitter_type_title;
94  		name->str_val = table_name;
95  	}
96  #define WIDTH_uint32_t 12
97  #define WIDTH_uint64_t 16
98  #define OP(counter, counter_type, human, derived, base_counter)	\
99  	col = &col_##counter_type[k_##counter_type];			\
100  	++k_##counter_type;						\
101  	emitter_col_init(col, row);					\
102  	col->justify = emitter_justify_right;				\
103  	col->width = derived ? 8 : WIDTH_##counter_type;		\
104  	col->type = emitter_type_title;					\
105  	col->str_val = human;
106  	MUTEX_PROF_COUNTERS
107  #undef OP
108  #undef WIDTH_uint32_t
109  #undef WIDTH_uint64_t
110  	col_uint64_t[mutex_counter_total_wait_time_ps].width = 10;
111  }
112  static void
113  mutex_stats_read_global(const char *name, emitter_col_t *col_name,
114      emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
115      emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters],
116      uint64_t uptime) {
117  	char cmd[MUTEX_CTL_STR_MAX_LENGTH];
118  	col_name->str_val = name;
119  	emitter_col_t *dst;
120  #define EMITTER_TYPE_uint32_t emitter_type_uint32
121  #define EMITTER_TYPE_uint64_t emitter_type_uint64
122  #define OP(counter, counter_type, human, derived, base_counter)	\
123  	dst = &col_##counter_type[mutex_counter_##counter];		\
124  	dst->type = EMITTER_TYPE_##counter_type;			\
125  	if (!derived) {							\
126  		gen_mutex_ctl_str(cmd, MUTEX_CTL_STR_MAX_LENGTH,	\
127  		    "mutexes", name, #counter);				\
128  		CTL_GET(cmd, (counter_type *)&dst->bool_val, counter_type);	\
129  	} else { \
130  	    emitter_col_t *base = &col_##counter_type[mutex_counter_##base_counter];	\
131  	    dst->counter_type##_val = rate_per_second(base->counter_type##_val, uptime); \
132  	}
133  	MUTEX_PROF_COUNTERS
134  #undef OP
135  #undef EMITTER_TYPE_uint32_t
136  #undef EMITTER_TYPE_uint64_t
137  }
138  static void
139  mutex_stats_read_arena(unsigned arena_ind, mutex_prof_arena_ind_t mutex_ind,
140      const char *name, emitter_col_t *col_name,
141      emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
142      emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters],
143      uint64_t uptime) {
144  	char cmd[MUTEX_CTL_STR_MAX_LENGTH];
145  	col_name->str_val = name;
146  	emitter_col_t *dst;
147  #define EMITTER_TYPE_uint32_t emitter_type_uint32
148  #define EMITTER_TYPE_uint64_t emitter_type_uint64
149  #define OP(counter, counter_type, human, derived, base_counter)	\
150  	dst = &col_##counter_type[mutex_counter_##counter];		\
151  	dst->type = EMITTER_TYPE_##counter_type;			\
152  	if (!derived) {                                   \
153  		gen_mutex_ctl_str(cmd, MUTEX_CTL_STR_MAX_LENGTH,        \
154  		    "arenas.0.mutexes", arena_mutex_names[mutex_ind], #counter);\
155  		CTL_M2_GET(cmd, arena_ind, (counter_type *)&dst->bool_val, counter_type); \
156  	} else {                      \
157  		emitter_col_t *base = &col_##counter_type[mutex_counter_##base_counter];	\
158  		dst->counter_type##_val = rate_per_second(base->counter_type##_val, uptime); \
159  	}
160  	MUTEX_PROF_COUNTERS
161  #undef OP
162  #undef EMITTER_TYPE_uint32_t
163  #undef EMITTER_TYPE_uint64_t
164  }
165  static void
166  mutex_stats_read_arena_bin(unsigned arena_ind, unsigned bin_ind,
167      emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
168      emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters],
169      uint64_t uptime) {
170  	char cmd[MUTEX_CTL_STR_MAX_LENGTH];
171  	emitter_col_t *dst;
172  #define EMITTER_TYPE_uint32_t emitter_type_uint32
173  #define EMITTER_TYPE_uint64_t emitter_type_uint64
174  #define OP(counter, counter_type, human, derived, base_counter)	\
175  	dst = &col_##counter_type[mutex_counter_##counter];		\
176  	dst->type = EMITTER_TYPE_##counter_type;			\
177  	if (!derived) {                                   \
178  		gen_mutex_ctl_str(cmd, MUTEX_CTL_STR_MAX_LENGTH,        \
179  		    "arenas.0.bins.0","mutex", #counter);            \
180  		CTL_M2_M4_GET(cmd, arena_ind, bin_ind,                \
181  		    (counter_type *)&dst->bool_val, counter_type);  \
182  	} else {                      \
183  		emitter_col_t *base = &col_##counter_type[mutex_counter_##base_counter]; \
184  		dst->counter_type##_val = rate_per_second(base->counter_type##_val, uptime); \
185  	}
186  	MUTEX_PROF_COUNTERS
187  #undef OP
188  #undef EMITTER_TYPE_uint32_t
189  #undef EMITTER_TYPE_uint64_t
190  }
191  static void
192  mutex_stats_emit(emitter_t *emitter, emitter_row_t *row,
193      emitter_col_t col_uint64_t[mutex_prof_num_uint64_t_counters],
194      emitter_col_t col_uint32_t[mutex_prof_num_uint32_t_counters]) {
195  	if (row != NULL) {
196  		emitter_table_row(emitter, row);
197  	}
198  	mutex_prof_uint64_t_counter_ind_t k_uint64_t = 0;
199  	mutex_prof_uint32_t_counter_ind_t k_uint32_t = 0;
200  	emitter_col_t *col;
201  #define EMITTER_TYPE_uint32_t emitter_type_uint32
202  #define EMITTER_TYPE_uint64_t emitter_type_uint64
203  #define OP(counter, type, human, derived, base_counter)		\
204  	if (!derived) {                    \
205  		col = &col_##type[k_##type];                        \
206  		++k_##type;                            \
207  		emitter_json_kv(emitter, #counter, EMITTER_TYPE_##type,        \
208  		    (const void *)&col->bool_val); \
209  	}
210  	MUTEX_PROF_COUNTERS;
211  #undef OP
212  #undef EMITTER_TYPE_uint32_t
213  #undef EMITTER_TYPE_uint64_t
214  }
215  #define COL(row_name, column_name, left_or_right, col_width, etype)      \
216  	emitter_col_t col_##column_name;                                     \
217  	emitter_col_init(&col_##column_name, &row_name);                     \
218  	col_##column_name.justify = emitter_justify_##left_or_right;         \
219  	col_##column_name.width = col_width;                                 \
220  	col_##column_name.type = emitter_type_##etype;
221  #define COL_HDR(row_name, column_name, human, left_or_right, col_width, etype)  \
222  	COL(row_name, column_name, left_or_right, col_width, etype)	         \
223  	emitter_col_t header_##column_name;                                  \
224  	emitter_col_init(&header_##column_name, &header_##row_name);         \
225  	header_##column_name.justify = emitter_justify_##left_or_right;      \
226  	header_##column_name.width = col_width;                              \
227  	header_##column_name.type = emitter_type_title;                      \
228  	header_##column_name.str_val = human ? human : #column_name;
229  static void
230  stats_arena_bins_print(emitter_t *emitter, bool mutex, unsigned i, uint64_t uptime) {
231  	size_t page;
232  	bool in_gap, in_gap_prev;
233  	unsigned nbins, j;
234  	CTL_GET("arenas.page", &page, size_t);
235  	CTL_GET("arenas.nbins", &nbins, unsigned);
236  	emitter_row_t header_row;
237  	emitter_row_init(&header_row);
238  	emitter_row_t row;
239  	emitter_row_init(&row);
240  	COL_HDR(row, size, NULL, right, 20, size)
241  	COL_HDR(row, ind, NULL, right, 4, unsigned)
242  	COL_HDR(row, allocated, NULL, right, 13, uint64)
243  	COL_HDR(row, nmalloc, NULL, right, 13, uint64)
244  	COL_HDR(row, nmalloc_ps, "(#/sec)", right, 8, uint64)
245  	COL_HDR(row, ndalloc, NULL, right, 13, uint64)
246  	COL_HDR(row, ndalloc_ps, "(#/sec)", right, 8, uint64)
247  	COL_HDR(row, nrequests, NULL, right, 13, uint64)
248  	COL_HDR(row, nrequests_ps, "(#/sec)", right, 10, uint64)
249  	COL_HDR(row, nshards, NULL, right, 9, unsigned)
250  	COL_HDR(row, curregs, NULL, right, 13, size)
251  	COL_HDR(row, curslabs, NULL, right, 13, size)
252  	COL_HDR(row, nonfull_slabs, NULL, right, 15, size)
253  	COL_HDR(row, regs, NULL, right, 5, unsigned)
254  	COL_HDR(row, pgs, NULL, right, 4, size)
255  	COL_HDR(row, justify_spacer, NULL, right, 1, title)
256  	COL_HDR(row, util, NULL, right, 6, title)
257  	COL_HDR(row, nfills, NULL, right, 13, uint64)
258  	COL_HDR(row, nfills_ps, "(#/sec)", right, 8, uint64)
259  	COL_HDR(row, nflushes, NULL, right, 13, uint64)
260  	COL_HDR(row, nflushes_ps, "(#/sec)", right, 8, uint64)
261  	COL_HDR(row, nslabs, NULL, right, 13, uint64)
262  	COL_HDR(row, nreslabs, NULL, right, 13, uint64)
263  	COL_HDR(row, nreslabs_ps, "(#/sec)", right, 8, uint64)
264  	header_justify_spacer.str_val = " ";
265  	col_justify_spacer.str_val = " ";
266  	emitter_col_t col_mutex64[mutex_prof_num_uint64_t_counters];
267  	emitter_col_t col_mutex32[mutex_prof_num_uint32_t_counters];
268  	emitter_col_t header_mutex64[mutex_prof_num_uint64_t_counters];
269  	emitter_col_t header_mutex32[mutex_prof_num_uint32_t_counters];
270  	if (mutex) {
271  		mutex_stats_init_cols(&row, NULL, NULL, col_mutex64,
272  		    col_mutex32);
273  		mutex_stats_init_cols(&header_row, NULL, NULL, header_mutex64,
274  		    header_mutex32);
275  	}
276  	header_size.width -=5;
277  	emitter_table_printf(emitter, "bins:");
278  	emitter_table_row(emitter, &header_row);
279  	emitter_json_array_kv_begin(emitter, "bins");
280  	for (j = 0, in_gap = false; j < nbins; j++) {
281  		uint64_t nslabs;
282  		size_t reg_size, slab_size, curregs;
283  		size_t curslabs;
284  		size_t nonfull_slabs;
285  		uint32_t nregs, nshards;
286  		uint64_t nmalloc, ndalloc, nrequests, nfills, nflushes;
287  		uint64_t nreslabs;
288  		CTL_M2_M4_GET("stats.arenas.0.bins.0.nslabs", i, j, &nslabs,
289  		    uint64_t);
290  		in_gap_prev = in_gap;
291  		in_gap = (nslabs == 0);
292  		if (in_gap_prev && !in_gap) {
293  			emitter_table_printf(emitter,
294  			    "                     ---\n");
295  		}
296  		CTL_M2_GET("arenas.bin.0.size", j, &reg_size, size_t);
297  		CTL_M2_GET("arenas.bin.0.nregs", j, &nregs, uint32_t);
298  		CTL_M2_GET("arenas.bin.0.slab_size", j, &slab_size, size_t);
299  		CTL_M2_GET("arenas.bin.0.nshards", j, &nshards, uint32_t);
300  		CTL_M2_M4_GET("stats.arenas.0.bins.0.nmalloc", i, j, &nmalloc,
301  		    uint64_t);
302  		CTL_M2_M4_GET("stats.arenas.0.bins.0.ndalloc", i, j, &ndalloc,
303  		    uint64_t);
304  		CTL_M2_M4_GET("stats.arenas.0.bins.0.curregs", i, j, &curregs,
305  		    size_t);
306  		CTL_M2_M4_GET("stats.arenas.0.bins.0.nrequests", i, j,
307  		    &nrequests, uint64_t);
308  		CTL_M2_M4_GET("stats.arenas.0.bins.0.nfills", i, j, &nfills,
309  		    uint64_t);
310  		CTL_M2_M4_GET("stats.arenas.0.bins.0.nflushes", i, j, &nflushes,
311  		    uint64_t);
312  		CTL_M2_M4_GET("stats.arenas.0.bins.0.nreslabs", i, j, &nreslabs,
313  		    uint64_t);
314  		CTL_M2_M4_GET("stats.arenas.0.bins.0.curslabs", i, j, &curslabs,
315  		    size_t);
316  		CTL_M2_M4_GET("stats.arenas.0.bins.0.nonfull_slabs", i, j, &nonfull_slabs,
317  		    size_t);
318  		if (mutex) {
319  			mutex_stats_read_arena_bin(i, j, col_mutex64,
320  			    col_mutex32, uptime);
321  		}
322  		emitter_json_object_begin(emitter);
323  		emitter_json_kv(emitter, "nmalloc", emitter_type_uint64,
324  		    &nmalloc);
325  		emitter_json_kv(emitter, "ndalloc", emitter_type_uint64,
326  		    &ndalloc);
327  		emitter_json_kv(emitter, "curregs", emitter_type_size,
328  		    &curregs);
329  		emitter_json_kv(emitter, "nrequests", emitter_type_uint64,
330  		    &nrequests);
331  		emitter_json_kv(emitter, "nfills", emitter_type_uint64,
332  		    &nfills);
333  		emitter_json_kv(emitter, "nflushes", emitter_type_uint64,
334  		    &nflushes);
335  		emitter_json_kv(emitter, "nreslabs", emitter_type_uint64,
336  		    &nreslabs);
337  		emitter_json_kv(emitter, "curslabs", emitter_type_size,
338  		    &curslabs);
339  		emitter_json_kv(emitter, "nonfull_slabs", emitter_type_size,
340  		    &nonfull_slabs);
341  		if (mutex) {
342  			emitter_json_object_kv_begin(emitter, "mutex");
343  			mutex_stats_emit(emitter, NULL, col_mutex64,
344  			    col_mutex32);
345  			emitter_json_object_end(emitter);
346  		}
347  		emitter_json_object_end(emitter);
348  		size_t availregs = nregs * curslabs;
349  		char util[6];
350  		if (get_rate_str((uint64_t)curregs, (uint64_t)availregs, util))
351  		{
352  			if (availregs == 0) {
353  				malloc_snprintf(util, sizeof(util), "1");
354  			} else if (curregs > availregs) {
355  				malloc_snprintf(util, sizeof(util), " race");
356  			} else {
357  				not_reached();
358  			}
359  		}
360  		col_size.size_val = reg_size;
361  		col_ind.unsigned_val = j;
362  		col_allocated.size_val = curregs * reg_size;
363  		col_nmalloc.uint64_val = nmalloc;
364  		col_nmalloc_ps.uint64_val = rate_per_second(nmalloc, uptime);
365  		col_ndalloc.uint64_val = ndalloc;
366  		col_ndalloc_ps.uint64_val = rate_per_second(ndalloc, uptime);
367  		col_nrequests.uint64_val = nrequests;
368  		col_nrequests_ps.uint64_val = rate_per_second(nrequests, uptime);
369  		col_nshards.unsigned_val = nshards;
370  		col_curregs.size_val = curregs;
371  		col_curslabs.size_val = curslabs;
372  		col_nonfull_slabs.size_val = nonfull_slabs;
373  		col_regs.unsigned_val = nregs;
374  		col_pgs.size_val = slab_size / page;
375  		col_util.str_val = util;
376  		col_nfills.uint64_val = nfills;
377  		col_nfills_ps.uint64_val = rate_per_second(nfills, uptime);
378  		col_nflushes.uint64_val = nflushes;
379  		col_nflushes_ps.uint64_val = rate_per_second(nflushes, uptime);
380  		col_nslabs.uint64_val = nslabs;
381  		col_nreslabs.uint64_val = nreslabs;
382  		col_nreslabs_ps.uint64_val = rate_per_second(nreslabs, uptime);
383  		emitter_table_row(emitter, &row);
384  	}
385  	emitter_json_array_end(emitter); &bsol;* Close "bins". */
386  	if (in_gap) {
387  		emitter_table_printf(emitter, "                     ---\n");
388  	}
389  }
390  static void
391  stats_arena_lextents_print(emitter_t *emitter, unsigned i, uint64_t uptime) {
392  	unsigned nbins, nlextents, j;
393  	bool in_gap, in_gap_prev;
394  	CTL_GET("arenas.nbins", &nbins, unsigned);
395  	CTL_GET("arenas.nlextents", &nlextents, unsigned);
396  	emitter_row_t header_row;
397  	emitter_row_init(&header_row);
398  	emitter_row_t row;
399  	emitter_row_init(&row);
400  	COL_HDR(row, size, NULL, right, 20, size)
401  	COL_HDR(row, ind, NULL, right, 4, unsigned)
402  	COL_HDR(row, allocated, NULL, right, 13, size)
403  	COL_HDR(row, nmalloc, NULL, right, 13, uint64)
404  	COL_HDR(row, nmalloc_ps, "(#/sec)", right, 8, uint64)
405  	COL_HDR(row, ndalloc, NULL, right, 13, uint64)
406  	COL_HDR(row, ndalloc_ps, "(#/sec)", right, 8, uint64)
407  	COL_HDR(row, nrequests, NULL, right, 13, uint64)
408  	COL_HDR(row, nrequests_ps, "(#/sec)", right, 8, uint64)
409  	COL_HDR(row, curlextents, NULL, right, 13, size)
410  	header_size.width -= 6;
411  	emitter_table_printf(emitter, "large:");
412  	emitter_table_row(emitter, &header_row);
413  	emitter_json_array_kv_begin(emitter, "lextents");
414  	for (j = 0, in_gap = false; j < nlextents; j++) {
415  		uint64_t nmalloc, ndalloc, nrequests;
416  		size_t lextent_size, curlextents;
417  		CTL_M2_M4_GET("stats.arenas.0.lextents.0.nmalloc", i, j,
418  		    &nmalloc, uint64_t);
419  		CTL_M2_M4_GET("stats.arenas.0.lextents.0.ndalloc", i, j,
420  		    &ndalloc, uint64_t);
421  		CTL_M2_M4_GET("stats.arenas.0.lextents.0.nrequests", i, j,
422  		    &nrequests, uint64_t);
423  		in_gap_prev = in_gap;
424  		in_gap = (nrequests == 0);
425  		if (in_gap_prev && !in_gap) {
426  			emitter_table_printf(emitter,
427  			    "                     ---\n");
428  		}
429  		CTL_M2_GET("arenas.lextent.0.size", j, &lextent_size, size_t);
430  		CTL_M2_M4_GET("stats.arenas.0.lextents.0.curlextents", i, j,
431  		    &curlextents, size_t);
432  		emitter_json_object_begin(emitter);
433  		emitter_json_kv(emitter, "curlextents", emitter_type_size,
434  		    &curlextents);
435  		emitter_json_object_end(emitter);
436  		col_size.size_val = lextent_size;
437  		col_ind.unsigned_val = nbins + j;
438  		col_allocated.size_val = curlextents * lextent_size;
439  		col_nmalloc.uint64_val = nmalloc;
440  		col_nmalloc_ps.uint64_val = rate_per_second(nmalloc, uptime);
441  		col_ndalloc.uint64_val = ndalloc;
442  		col_ndalloc_ps.uint64_val = rate_per_second(ndalloc, uptime);
443  		col_nrequests.uint64_val = nrequests;
444  		col_nrequests_ps.uint64_val = rate_per_second(nrequests, uptime);
445  		col_curlextents.size_val = curlextents;
446  		if (!in_gap) {
447  			emitter_table_row(emitter, &row);
448  		}
449  	}
450  	emitter_json_array_end(emitter); &bsol;* Close "lextents". */
451  	if (in_gap) {
452  		emitter_table_printf(emitter, "                     ---\n");
453  	}
454  }
455  static void
456  stats_arena_extents_print(emitter_t *emitter, unsigned i) {
457  	unsigned j;
458  	bool in_gap, in_gap_prev;
459  	emitter_row_t header_row;
460  	emitter_row_init(&header_row);
461  	emitter_row_t row;
462  	emitter_row_init(&row);
463  	COL_HDR(row, size, NULL, right, 20, size)
464  	COL_HDR(row, ind, NULL, right, 4, unsigned)
465  	COL_HDR(row, ndirty, NULL, right, 13, size)
466  	COL_HDR(row, dirty, NULL, right, 13, size)
467  	COL_HDR(row, nmuzzy, NULL, right, 13, size)
468  	COL_HDR(row, muzzy, NULL, right, 13, size)
469  	COL_HDR(row, nretained, NULL, right, 13, size)
470  	COL_HDR(row, retained, NULL, right, 13, size)
471  	COL_HDR(row, ntotal, NULL, right, 13, size)
472  	COL_HDR(row, total, NULL, right, 13, size)
473  	header_size.width -= 8;
474  	emitter_table_printf(emitter, "extents:");
475  	emitter_table_row(emitter, &header_row);
476  	emitter_json_array_kv_begin(emitter, "extents");
477  	in_gap = false;
478  	for (j = 0; j < SC_NPSIZES; j++) {
479  		size_t ndirty, nmuzzy, nretained, total, dirty_bytes,
480  		    muzzy_bytes, retained_bytes, total_bytes;
481  		CTL_M2_M4_GET("stats.arenas.0.extents.0.ndirty", i, j,
482  		    &ndirty, size_t);
483  		CTL_M2_M4_GET("stats.arenas.0.extents.0.nmuzzy", i, j,
484  		    &nmuzzy, size_t);
485  		CTL_M2_M4_GET("stats.arenas.0.extents.0.nretained", i, j,
486  		    &nretained, size_t);
487  		CTL_M2_M4_GET("stats.arenas.0.extents.0.dirty_bytes", i, j,
488  		    &dirty_bytes, size_t);
489  		CTL_M2_M4_GET("stats.arenas.0.extents.0.muzzy_bytes", i, j,
490  		    &muzzy_bytes, size_t);
491  		CTL_M2_M4_GET("stats.arenas.0.extents.0.retained_bytes", i, j,
492  		    &retained_bytes, size_t);
493  		total = ndirty + nmuzzy + nretained;
494  		total_bytes = dirty_bytes + muzzy_bytes + retained_bytes;
495  		in_gap_prev = in_gap;
496  		in_gap = (total == 0);
497  		if (in_gap_prev && !in_gap) {
498  			emitter_table_printf(emitter,
499  			    "                     ---\n");
500  		}
501  		emitter_json_object_begin(emitter);
502  		emitter_json_kv(emitter, "ndirty", emitter_type_size, &ndirty);
503  		emitter_json_kv(emitter, "nmuzzy", emitter_type_size, &nmuzzy);
504  		emitter_json_kv(emitter, "nretained", emitter_type_size,
505  		    &nretained);
506  		emitter_json_kv(emitter, "dirty_bytes", emitter_type_size,
507  		    &dirty_bytes);
508  		emitter_json_kv(emitter, "muzzy_bytes", emitter_type_size,
509  		    &muzzy_bytes);
510  		emitter_json_kv(emitter, "retained_bytes", emitter_type_size,
511  		    &retained_bytes);
512  		emitter_json_object_end(emitter);
513  		col_size.size_val = sz_pind2sz(j);
514  		col_ind.size_val = j;
515  		col_ndirty.size_val = ndirty;
516  		col_dirty.size_val = dirty_bytes;
517  		col_nmuzzy.size_val = nmuzzy;
518  		col_muzzy.size_val = muzzy_bytes;
519  		col_nretained.size_val = nretained;
520  		col_retained.size_val = retained_bytes;
521  		col_ntotal.size_val = total;
522  		col_total.size_val = total_bytes;
523  		if (!in_gap) {
524  			emitter_table_row(emitter, &row);
525  		}
526  	}
527  	emitter_json_array_end(emitter); &bsol;* Close "extents". */
528  	if (in_gap) {
529  		emitter_table_printf(emitter, "                     ---\n");
530  	}
531  }
532  static void
533  stats_arena_mutexes_print(emitter_t *emitter, unsigned arena_ind, uint64_t uptime) {
534  	emitter_row_t row;
535  	emitter_col_t col_name;
536  	emitter_col_t col64[mutex_prof_num_uint64_t_counters];
537  	emitter_col_t col32[mutex_prof_num_uint32_t_counters];
538  	emitter_row_init(&row);
539  	mutex_stats_init_cols(&row, "", &col_name, col64, col32);
540  	emitter_json_object_kv_begin(emitter, "mutexes");
541  	emitter_table_row(emitter, &row);
542  	for (mutex_prof_arena_ind_t i = 0; i < mutex_prof_num_arena_mutexes;
543  	    i++) {
544  		const char *name = arena_mutex_names[i];
545  		emitter_json_object_kv_begin(emitter, name);
546  		mutex_stats_read_arena(arena_ind, i, name, &col_name, col64,
547  		    col32, uptime);
548  		mutex_stats_emit(emitter, &row, col64, col32);
549  		emitter_json_object_end(emitter); &bsol;* Close the mutex dict. */
550  	}
551  	emitter_json_object_end(emitter); &bsol;* End "mutexes". */
552  }
553  static void
554  stats_arena_print(emitter_t *emitter, unsigned i, bool bins, bool large,
555      bool mutex, bool extents) {
556  	unsigned nthreads;
557  	const char *dss;
558  	ssize_t dirty_decay_ms, muzzy_decay_ms;
559  	size_t page, pactive, pdirty, pmuzzy, mapped, retained;
560  	size_t base, internal, resident, metadata_thp, extent_avail;
561  	uint64_t dirty_npurge, dirty_nmadvise, dirty_purged;
562  	uint64_t muzzy_npurge, muzzy_nmadvise, muzzy_purged;
563  	size_t small_allocated;
564  	uint64_t small_nmalloc, small_ndalloc, small_nrequests, small_nfills,
565  	    small_nflushes;
566  	size_t large_allocated;
567  	uint64_t large_nmalloc, large_ndalloc, large_nrequests, large_nfills,
568  	    large_nflushes;
569  	size_t tcache_bytes, abandoned_vm;
570  	uint64_t uptime;
571  	CTL_GET("arenas.page", &page, size_t);
572  	CTL_M2_GET("stats.arenas.0.nthreads", i, &nthreads, unsigned);
573  	emitter_kv(emitter, "nthreads", "assigned threads",
574  	    emitter_type_unsigned, &nthreads);
575  	CTL_M2_GET("stats.arenas.0.uptime", i, &uptime, uint64_t);
576  	emitter_kv(emitter, "uptime_ns", "uptime", emitter_type_uint64,
577  	    &uptime);
578  	CTL_M2_GET("stats.arenas.0.dss", i, &dss, const char *);
579  	emitter_kv(emitter, "dss", "dss allocation precedence",
580  	    emitter_type_string, &dss);
581  	CTL_M2_GET("stats.arenas.0.dirty_decay_ms", i, &dirty_decay_ms,
582  	    ssize_t);
583  	CTL_M2_GET("stats.arenas.0.muzzy_decay_ms", i, &muzzy_decay_ms,
584  	    ssize_t);
585  	CTL_M2_GET("stats.arenas.0.pactive", i, &pactive, size_t);
586  	CTL_M2_GET("stats.arenas.0.pdirty", i, &pdirty, size_t);
587  	CTL_M2_GET("stats.arenas.0.pmuzzy", i, &pmuzzy, size_t);
588  	CTL_M2_GET("stats.arenas.0.dirty_npurge", i, &dirty_npurge, uint64_t);
589  	CTL_M2_GET("stats.arenas.0.dirty_nmadvise", i, &dirty_nmadvise,
590  	    uint64_t);
591  	CTL_M2_GET("stats.arenas.0.dirty_purged", i, &dirty_purged, uint64_t);
592  	CTL_M2_GET("stats.arenas.0.muzzy_npurge", i, &muzzy_npurge, uint64_t);
593  	CTL_M2_GET("stats.arenas.0.muzzy_nmadvise", i, &muzzy_nmadvise,
594  	    uint64_t);
595  	CTL_M2_GET("stats.arenas.0.muzzy_purged", i, &muzzy_purged, uint64_t);
596  	emitter_row_t decay_row;
597  	emitter_row_init(&decay_row);
598  	emitter_json_kv(emitter, "dirty_decay_ms", emitter_type_ssize,
599  	    &dirty_decay_ms);
600  	emitter_json_kv(emitter, "muzzy_decay_ms", emitter_type_ssize,
601  	    &muzzy_decay_ms);
602  	emitter_json_kv(emitter, "pactive", emitter_type_size, &pactive);
603  	emitter_json_kv(emitter, "pdirty", emitter_type_size, &pdirty);
604  	emitter_json_kv(emitter, "pmuzzy", emitter_type_size, &pmuzzy);
605  	emitter_json_kv(emitter, "dirty_npurge", emitter_type_uint64,
606  	    &dirty_npurge);
607  	emitter_json_kv(emitter, "dirty_nmadvise", emitter_type_uint64,
608  	    &dirty_nmadvise);
609  	emitter_json_kv(emitter, "dirty_purged", emitter_type_uint64,
610  	    &dirty_purged);
611  	emitter_json_kv(emitter, "muzzy_npurge", emitter_type_uint64,
612  	    &muzzy_npurge);
613  	emitter_json_kv(emitter, "muzzy_nmadvise", emitter_type_uint64,
614  	    &muzzy_nmadvise);
615  	emitter_json_kv(emitter, "muzzy_purged", emitter_type_uint64,
616  	    &muzzy_purged);
617  	COL(decay_row, decay_type, right, 9, title);
618  	col_decay_type.str_val = "decaying:";
619  	COL(decay_row, decay_time, right, 6, title);
620  	col_decay_time.str_val = "time";
621  	COL(decay_row, decay_npages, right, 13, title);
622  	col_decay_npages.str_val = "npages";
623  	COL(decay_row, decay_sweeps, right, 13, title);
624  	col_decay_sweeps.str_val = "sweeps";
625  	COL(decay_row, decay_madvises, right, 13, title);
626  	col_decay_madvises.str_val = "madvises";
627  	COL(decay_row, decay_purged, right, 13, title);
628  	col_decay_purged.str_val = "purged";
629  	emitter_table_row(emitter, &decay_row);
630  	col_decay_type.str_val = "dirty:";
631  	if (dirty_decay_ms >= 0) {
632  		col_decay_time.type = emitter_type_ssize;
633  		col_decay_time.ssize_val = dirty_decay_ms;
634  	} else {
635  		col_decay_time.type = emitter_type_title;
636  		col_decay_time.str_val = "N/A";
637  	}
638  	col_decay_npages.type = emitter_type_size;
639  	col_decay_npages.size_val = pdirty;
640  	col_decay_sweeps.type = emitter_type_uint64;
641  	col_decay_sweeps.uint64_val = dirty_npurge;
642  	col_decay_madvises.type = emitter_type_uint64;
643  	col_decay_madvises.uint64_val = dirty_nmadvise;
644  	col_decay_purged.type = emitter_type_uint64;
645  	col_decay_purged.uint64_val = dirty_purged;
646  	emitter_table_row(emitter, &decay_row);
647  	col_decay_type.str_val = "muzzy:";
648  	if (muzzy_decay_ms >= 0) {
649  		col_decay_time.type = emitter_type_ssize;
650  		col_decay_time.ssize_val = muzzy_decay_ms;
651  	} else {
652  		col_decay_time.type = emitter_type_title;
653  		col_decay_time.str_val = "N/A";
654  	}
655  	col_decay_npages.type = emitter_type_size;
656  	col_decay_npages.size_val = pmuzzy;
657  	col_decay_sweeps.type = emitter_type_uint64;
658  	col_decay_sweeps.uint64_val = muzzy_npurge;
659  	col_decay_madvises.type = emitter_type_uint64;
660  	col_decay_madvises.uint64_val = muzzy_nmadvise;
661  	col_decay_purged.type = emitter_type_uint64;
662  	col_decay_purged.uint64_val = muzzy_purged;
663  	emitter_table_row(emitter, &decay_row);
664  	emitter_row_t alloc_count_row;
665  	emitter_row_init(&alloc_count_row);
666  	COL(alloc_count_row, count_title, left, 21, title);
667  	col_count_title.str_val = "";
668  	COL(alloc_count_row, count_allocated, right, 16, title);
669  	col_count_allocated.str_val = "allocated";
670  	COL(alloc_count_row, count_nmalloc, right, 16, title);
671  	col_count_nmalloc.str_val = "nmalloc";
672  	COL(alloc_count_row, count_nmalloc_ps, right, 8, title);
673  	col_count_nmalloc_ps.str_val = "(#/sec)";
674  	COL(alloc_count_row, count_ndalloc, right, 16, title);
675  	col_count_ndalloc.str_val = "ndalloc";
676  	COL(alloc_count_row, count_ndalloc_ps, right, 8, title);
677  	col_count_ndalloc_ps.str_val = "(#/sec)";
678  	COL(alloc_count_row, count_nrequests, right, 16, title);
679  	col_count_nrequests.str_val = "nrequests";
680  	COL(alloc_count_row, count_nrequests_ps, right, 10, title);
681  	col_count_nrequests_ps.str_val = "(#/sec)";
682  	COL(alloc_count_row, count_nfills, right, 16, title);
683  	col_count_nfills.str_val = "nfill";
684  	COL(alloc_count_row, count_nfills_ps, right, 10, title);
685  	col_count_nfills_ps.str_val = "(#/sec)";
686  	COL(alloc_count_row, count_nflushes, right, 16, title);
687  	col_count_nflushes.str_val = "nflush";
688  	COL(alloc_count_row, count_nflushes_ps, right, 10, title);
689  	col_count_nflushes_ps.str_val = "(#/sec)";
690  	emitter_table_row(emitter, &alloc_count_row);
691  	col_count_nmalloc_ps.type = emitter_type_uint64;
692  	col_count_ndalloc_ps.type = emitter_type_uint64;
693  	col_count_nrequests_ps.type = emitter_type_uint64;
694  	col_count_nfills_ps.type = emitter_type_uint64;
695  	col_count_nflushes_ps.type = emitter_type_uint64;
696  #define GET_AND_EMIT_ALLOC_STAT(small_or_large, name, valtype)		\
697  	CTL_M2_GET("stats.arenas.0." #small_or_large "." #name, i,	\
698  	    &small_or_large##_##name, valtype##_t);			\
699  	emitter_json_kv(emitter, #name, emitter_type_##valtype,		\
700  	    &small_or_large##_##name);					\
701  	col_count_##name.type = emitter_type_##valtype;		\
702  	col_count_##name.valtype##_val = small_or_large##_##name;
703  	emitter_json_object_kv_begin(emitter, "small");
704  	col_count_title.str_val = "small:";
705  	GET_AND_EMIT_ALLOC_STAT(small, allocated, size)
706  	GET_AND_EMIT_ALLOC_STAT(small, nmalloc, uint64)
707  	col_count_nmalloc_ps.uint64_val =
708  	    rate_per_second(col_count_nmalloc.uint64_val, uptime);
709  	GET_AND_EMIT_ALLOC_STAT(small, ndalloc, uint64)
710  	col_count_ndalloc_ps.uint64_val =
711  	    rate_per_second(col_count_ndalloc.uint64_val, uptime);
712  	GET_AND_EMIT_ALLOC_STAT(small, nrequests, uint64)
713  	col_count_nrequests_ps.uint64_val =
714  	    rate_per_second(col_count_nrequests.uint64_val, uptime);
715  	GET_AND_EMIT_ALLOC_STAT(small, nfills, uint64)
716  	col_count_nfills_ps.uint64_val =
717  	    rate_per_second(col_count_nfills.uint64_val, uptime);
718  	GET_AND_EMIT_ALLOC_STAT(small, nflushes, uint64)
719  	col_count_nflushes_ps.uint64_val =
720  	    rate_per_second(col_count_nflushes.uint64_val, uptime);
721  	emitter_table_row(emitter, &alloc_count_row);
722  	emitter_json_object_end(emitter); &bsol;* Close "small". */
723  	emitter_json_object_kv_begin(emitter, "large");
724  	col_count_title.str_val = "large:";
725  	GET_AND_EMIT_ALLOC_STAT(large, allocated, size)
726  	GET_AND_EMIT_ALLOC_STAT(large, nmalloc, uint64)
727  	col_count_nmalloc_ps.uint64_val =
728  	    rate_per_second(col_count_nmalloc.uint64_val, uptime);
729  	GET_AND_EMIT_ALLOC_STAT(large, ndalloc, uint64)
730  	col_count_ndalloc_ps.uint64_val =
731  	    rate_per_second(col_count_ndalloc.uint64_val, uptime);
732  	GET_AND_EMIT_ALLOC_STAT(large, nrequests, uint64)
733  	col_count_nrequests_ps.uint64_val =
734  	    rate_per_second(col_count_nrequests.uint64_val, uptime);
735  	GET_AND_EMIT_ALLOC_STAT(large, nfills, uint64)
736  	col_count_nfills_ps.uint64_val =
737  	    rate_per_second(col_count_nfills.uint64_val, uptime);
738  	GET_AND_EMIT_ALLOC_STAT(large, nflushes, uint64)
739  	col_count_nflushes_ps.uint64_val =
740  	    rate_per_second(col_count_nflushes.uint64_val, uptime);
741  	emitter_table_row(emitter, &alloc_count_row);
742  	emitter_json_object_end(emitter); &bsol;* Close "large". */
743  #undef GET_AND_EMIT_ALLOC_STAT
744  	col_count_title.str_val = "total:";
745  	col_count_allocated.size_val = small_allocated + large_allocated;
746  	col_count_nmalloc.uint64_val = small_nmalloc + large_nmalloc;
747  	col_count_ndalloc.uint64_val = small_ndalloc + large_ndalloc;
748  	col_count_nrequests.uint64_val = small_nrequests + large_nrequests;
749  	col_count_nfills.uint64_val = small_nfills + large_nfills;
750  	col_count_nflushes.uint64_val = small_nflushes + large_nflushes;
751  	col_count_nmalloc_ps.uint64_val =
752  	    rate_per_second(col_count_nmalloc.uint64_val, uptime);
753  	col_count_ndalloc_ps.uint64_val =
754  	    rate_per_second(col_count_ndalloc.uint64_val, uptime);
755  	col_count_nrequests_ps.uint64_val =
756  	    rate_per_second(col_count_nrequests.uint64_val, uptime);
757  	col_count_nfills_ps.uint64_val =
758  	    rate_per_second(col_count_nfills.uint64_val, uptime);
759  	col_count_nflushes_ps.uint64_val =
760  	    rate_per_second(col_count_nflushes.uint64_val, uptime);
761  	emitter_table_row(emitter, &alloc_count_row);
762  	emitter_row_t mem_count_row;
763  	emitter_row_init(&mem_count_row);
764  	emitter_col_t mem_count_title;
765  	emitter_col_init(&mem_count_title, &mem_count_row);
766  	mem_count_title.justify = emitter_justify_left;
767  	mem_count_title.width = 21;
768  	mem_count_title.type = emitter_type_title;
769  	mem_count_title.str_val = "";
770  	emitter_col_t mem_count_val;
771  	emitter_col_init(&mem_count_val, &mem_count_row);
772  	mem_count_val.justify = emitter_justify_right;
773  	mem_count_val.width = 16;
774  	mem_count_val.type = emitter_type_title;
775  	mem_count_val.str_val = "";
776  	emitter_table_row(emitter, &mem_count_row);
777  	mem_count_val.type = emitter_type_size;
778  	mem_count_title.str_val = "active:";
779  	mem_count_val.size_val = pactive * page;
780  	emitter_table_row(emitter, &mem_count_row);
781  #define GET_AND_EMIT_MEM_STAT(stat)					\
782  	CTL_M2_GET("stats.arenas.0."#stat, i, &stat, size_t);		\
783  	emitter_json_kv(emitter, #stat, emitter_type_size, &stat);	\
784  	mem_count_title.str_val = #stat":";				\
785  	mem_count_val.size_val = stat;					\
786  	emitter_table_row(emitter, &mem_count_row);
787  	GET_AND_EMIT_MEM_STAT(mapped)
788  	GET_AND_EMIT_MEM_STAT(retained)
789  	GET_AND_EMIT_MEM_STAT(base)
790  	GET_AND_EMIT_MEM_STAT(internal)
791  	GET_AND_EMIT_MEM_STAT(metadata_thp)
792  	GET_AND_EMIT_MEM_STAT(tcache_bytes)
793  	GET_AND_EMIT_MEM_STAT(resident)
794  	GET_AND_EMIT_MEM_STAT(abandoned_vm)
795  	GET_AND_EMIT_MEM_STAT(extent_avail)
796  #undef GET_AND_EMIT_MEM_STAT
797  	if (mutex) {
798  		stats_arena_mutexes_print(emitter, i, uptime);
799  	}
800  	if (bins) {
801  		stats_arena_bins_print(emitter, mutex, i, uptime);
802  	}
803  	if (large) {
804  		stats_arena_lextents_print(emitter, i, uptime);
805  	}
806  	if (extents) {
807  		stats_arena_extents_print(emitter, i);
808  	}
809  }
810  static void
811  stats_general_print(emitter_t *emitter) {
812  	const char *cpv;
813  	bool bv, bv2;
814  	unsigned uv;
815  	uint32_t u32v;
816  	uint64_t u64v;
817  	ssize_t ssv, ssv2;
818  	size_t sv, bsz, usz, ssz, sssz, cpsz;
819  	bsz = sizeof(bool);
820  	usz = sizeof(unsigned);
821  	ssz = sizeof(size_t);
822  	sssz = sizeof(ssize_t);
823  	cpsz = sizeof(const char *);
824  	CTL_GET("version", &cpv, const char *);
825  	emitter_kv(emitter, "version", "Version", emitter_type_string, &cpv);
826  	emitter_dict_begin(emitter, "config", "Build-time option settings");
827  #define CONFIG_WRITE_BOOL(name)						\
828  	do {								\
829  		CTL_GET("config."#name, &bv, bool);			\
830  		emitter_kv(emitter, #name, "config."#name,		\
831  		    emitter_type_bool, &bv);				\
832  	} while (0)
833  	CONFIG_WRITE_BOOL(cache_oblivious);
834  	CONFIG_WRITE_BOOL(debug);
835  	CONFIG_WRITE_BOOL(fill);
836  	CONFIG_WRITE_BOOL(lazy_lock);
837  	emitter_kv(emitter, "malloc_conf", "config.malloc_conf",
838  	    emitter_type_string, &config_malloc_conf);
839  	CONFIG_WRITE_BOOL(opt_safety_checks);
840  	CONFIG_WRITE_BOOL(prof);
841  	CONFIG_WRITE_BOOL(prof_libgcc);
842  	CONFIG_WRITE_BOOL(prof_libunwind);
843  	CONFIG_WRITE_BOOL(stats);
844  	CONFIG_WRITE_BOOL(utrace);
845  	CONFIG_WRITE_BOOL(xmalloc);
846  #undef CONFIG_WRITE_BOOL
847  	emitter_dict_end(emitter); &bsol;* Close "config" dict. */
848  #define OPT_WRITE(name, var, size, emitter_type)			\
849  	if (je_mallctl("opt."name, (void *)&var, &size, NULL, 0) ==	\
850  	    0) {							\
851  		emitter_kv(emitter, name, "opt."name, emitter_type,	\
852  		    &var);						\
853  	}
854  #define OPT_WRITE_MUTABLE(name, var1, var2, size, emitter_type,		\
855      altname)								\
856  	if (je_mallctl("opt."name, (void *)&var1, &size, NULL, 0) ==	\
857  	    0 && je_mallctl(altname, (void *)&var2, &size, NULL, 0)	\
858  	    == 0) {							\
859  		emitter_kv_note(emitter, name, "opt."name,		\
860  		    emitter_type, &var1, altname, emitter_type,		\
861  		    &var2);						\
862  	}
863  #define OPT_WRITE_BOOL(name) OPT_WRITE(name, bv, bsz, emitter_type_bool)
864  #define OPT_WRITE_BOOL_MUTABLE(name, altname)				\
865  	OPT_WRITE_MUTABLE(name, bv, bv2, bsz, emitter_type_bool, altname)
866  #define OPT_WRITE_UNSIGNED(name)					\
867  	OPT_WRITE(name, uv, usz, emitter_type_unsigned)
868  #define OPT_WRITE_SIZE_T(name)						\
869  	OPT_WRITE(name, sv, ssz, emitter_type_size)
870  #define OPT_WRITE_SSIZE_T(name)						\
871  	OPT_WRITE(name, ssv, sssz, emitter_type_ssize)
872  #define OPT_WRITE_SSIZE_T_MUTABLE(name, altname)			\
873  	OPT_WRITE_MUTABLE(name, ssv, ssv2, sssz, emitter_type_ssize,	\
874  	    altname)
875  #define OPT_WRITE_CHAR_P(name)						\
876  	OPT_WRITE(name, cpv, cpsz, emitter_type_string)
877  	emitter_dict_begin(emitter, "opt", "Run-time option settings");
878  	OPT_WRITE_BOOL("abort")
879  	OPT_WRITE_BOOL("abort_conf")
880  	OPT_WRITE_BOOL("confirm_conf")
881  	OPT_WRITE_BOOL("retain")
882  	OPT_WRITE_CHAR_P("dss")
883  	OPT_WRITE_UNSIGNED("narenas")
884  	OPT_WRITE_CHAR_P("percpu_arena")
885  	OPT_WRITE_SIZE_T("oversize_threshold")
886  	OPT_WRITE_CHAR_P("metadata_thp")
887  	OPT_WRITE_BOOL_MUTABLE("background_thread", "background_thread")
888  	OPT_WRITE_SSIZE_T_MUTABLE("dirty_decay_ms", "arenas.dirty_decay_ms")
889  	OPT_WRITE_SSIZE_T_MUTABLE("muzzy_decay_ms", "arenas.muzzy_decay_ms")
890  	OPT_WRITE_SIZE_T("lg_extent_max_active_fit")
891  	OPT_WRITE_CHAR_P("junk")
892  	OPT_WRITE_BOOL("zero")
893  	OPT_WRITE_BOOL("utrace")
894  	OPT_WRITE_BOOL("xmalloc")
895  	OPT_WRITE_BOOL("tcache")
896  	OPT_WRITE_SSIZE_T("lg_tcache_max")
897  	OPT_WRITE_CHAR_P("thp")
898  	OPT_WRITE_BOOL("prof")
899  	OPT_WRITE_CHAR_P("prof_prefix")
900  	OPT_WRITE_BOOL_MUTABLE("prof_active", "prof.active")
901  	OPT_WRITE_BOOL_MUTABLE("prof_thread_active_init",
902  	    "prof.thread_active_init")
903  	OPT_WRITE_SSIZE_T_MUTABLE("lg_prof_sample", "prof.lg_sample")
904  	OPT_WRITE_BOOL("prof_accum")
905  	OPT_WRITE_SSIZE_T("lg_prof_interval")
906  	OPT_WRITE_BOOL("prof_gdump")
907  	OPT_WRITE_BOOL("prof_final")
908  	OPT_WRITE_BOOL("prof_leak")
909  	OPT_WRITE_BOOL("stats_print")
910  	OPT_WRITE_CHAR_P("stats_print_opts")
911  	emitter_dict_end(emitter);
912  #undef OPT_WRITE
913  #undef OPT_WRITE_MUTABLE
914  #undef OPT_WRITE_BOOL
915  #undef OPT_WRITE_BOOL_MUTABLE
916  #undef OPT_WRITE_UNSIGNED
917  #undef OPT_WRITE_SSIZE_T
918  #undef OPT_WRITE_SSIZE_T_MUTABLE
919  #undef OPT_WRITE_CHAR_P
920  	if (config_prof) {
921  		emitter_dict_begin(emitter, "prof", "Profiling settings");
922  		CTL_GET("prof.thread_active_init", &bv, bool);
923  		emitter_kv(emitter, "thread_active_init",
924  		    "prof.thread_active_init", emitter_type_bool, &bv);
925  		CTL_GET("prof.active", &bv, bool);
926  		emitter_kv(emitter, "active", "prof.active", emitter_type_bool,
927  		    &bv);
928  		CTL_GET("prof.gdump", &bv, bool);
929  		emitter_kv(emitter, "gdump", "prof.gdump", emitter_type_bool,
930  		    &bv);
931  		CTL_GET("prof.interval", &u64v, uint64_t);
932  		emitter_kv(emitter, "interval", "prof.interval",
933  		    emitter_type_uint64, &u64v);
934  		CTL_GET("prof.lg_sample", &ssv, ssize_t);
935  		emitter_kv(emitter, "lg_sample", "prof.lg_sample",
936  		    emitter_type_ssize, &ssv);
937  		emitter_dict_end(emitter); &bsol;* Close "prof". */
938  	}
939  	emitter_json_object_kv_begin(emitter, "arenas");
940  	CTL_GET("arenas.narenas", &uv, unsigned);
941  	emitter_kv(emitter, "narenas", "Arenas", emitter_type_unsigned, &uv);
942  	CTL_GET("arenas.dirty_decay_ms", &ssv, ssize_t);
943  	emitter_json_kv(emitter, "dirty_decay_ms", emitter_type_ssize, &ssv);
944  	CTL_GET("arenas.muzzy_decay_ms", &ssv, ssize_t);
945  	emitter_json_kv(emitter, "muzzy_decay_ms", emitter_type_ssize, &ssv);
946  	CTL_GET("arenas.quantum", &sv, size_t);
947  	emitter_kv(emitter, "quantum", "Quantum size", emitter_type_size, &sv);
948  	CTL_GET("arenas.page", &sv, size_t);
949  	emitter_kv(emitter, "page", "Page size", emitter_type_size, &sv);
950  	if (je_mallctl("arenas.tcache_max", (void *)&sv, &ssz, NULL, 0) == 0) {
951  		emitter_kv(emitter, "tcache_max",
952  		    "Maximum thread-cached size class", emitter_type_size, &sv);
953  	}
954  	unsigned nbins;
955  	CTL_GET("arenas.nbins", &nbins, unsigned);
956  	emitter_kv(emitter, "nbins", "Number of bin size classes",
957  	    emitter_type_unsigned, &nbins);
958  	unsigned nhbins;
959  	CTL_GET("arenas.nhbins", &nhbins, unsigned);
960  	emitter_kv(emitter, "nhbins", "Number of thread-cache bin size classes",
961  	    emitter_type_unsigned, &nhbins);
962  	if (emitter->output == emitter_output_json) {
963  		emitter_json_array_kv_begin(emitter, "bin");
964  		for (unsigned i = 0; i < nbins; i++) {
965  			emitter_json_object_begin(emitter);
966  			CTL_M2_GET("arenas.bin.0.size", i, &sv, size_t);
967  			emitter_json_kv(emitter, "size", emitter_type_size,
968  			    &sv);
969  			CTL_M2_GET("arenas.bin.0.nregs", i, &u32v, uint32_t);
970  			emitter_json_kv(emitter, "nregs", emitter_type_uint32,
971  			    &u32v);
972  			CTL_M2_GET("arenas.bin.0.slab_size", i, &sv, size_t);
973  			emitter_json_kv(emitter, "slab_size", emitter_type_size,
974  			    &sv);
975  			CTL_M2_GET("arenas.bin.0.nshards", i, &u32v, uint32_t);
976  			emitter_json_kv(emitter, "nshards", emitter_type_uint32,
977  			    &u32v);
978  			emitter_json_object_end(emitter);
979  		}
980  		emitter_json_array_end(emitter); &bsol;* Close "bin". */
981  	}
982  	unsigned nlextents;
983  	CTL_GET("arenas.nlextents", &nlextents, unsigned);
984  	emitter_kv(emitter, "nlextents", "Number of large size classes",
985  	    emitter_type_unsigned, &nlextents);
986  	if (emitter->output == emitter_output_json) {
987  		emitter_json_array_kv_begin(emitter, "lextent");
988  		for (unsigned i = 0; i < nlextents; i++) {
989  			emitter_json_object_begin(emitter);
990  			CTL_M2_GET("arenas.lextent.0.size", i, &sv, size_t);
991  			emitter_json_kv(emitter, "size", emitter_type_size,
992  			    &sv);
993  			emitter_json_object_end(emitter);
994  		}
995  		emitter_json_array_end(emitter); &bsol;* Close "lextent". */
996  	}
997  	emitter_json_object_end(emitter); &bsol;* Close "arenas" */
998  }
999  static void
1000  stats_print_helper(emitter_t *emitter, bool merged, bool destroyed,
1001      bool unmerged, bool bins, bool large, bool mutex, bool extents) {
1002  	size_t allocated, active, metadata, metadata_thp, resident, mapped,
1003  	    retained;
1004  	size_t num_background_threads;
1005  	uint64_t background_thread_num_runs, background_thread_run_interval;
1006  	CTL_GET("stats.allocated", &allocated, size_t);
1007  	CTL_GET("stats.active", &active, size_t);
1008  	CTL_GET("stats.metadata", &metadata, size_t);
1009  	CTL_GET("stats.metadata_thp", &metadata_thp, size_t);
1010  	CTL_GET("stats.resident", &resident, size_t);
1011  	CTL_GET("stats.mapped", &mapped, size_t);
1012  	CTL_GET("stats.retained", &retained, size_t);
1013  	if (have_background_thread) {
1014  		CTL_GET("stats.background_thread.num_threads",
1015  		    &num_background_threads, size_t);
1016  		CTL_GET("stats.background_thread.num_runs",
1017  		    &background_thread_num_runs, uint64_t);
1018  		CTL_GET("stats.background_thread.run_interval",
1019  		    &background_thread_run_interval, uint64_t);
1020  	} else {
1021  		num_background_threads = 0;
1022  		background_thread_num_runs = 0;
1023  		background_thread_run_interval = 0;
1024  	}
1025  	emitter_json_object_kv_begin(emitter, "stats");
1026  	emitter_json_kv(emitter, "allocated", emitter_type_size, &allocated);
1027  	emitter_json_kv(emitter, "active", emitter_type_size, &active);
1028  	emitter_json_kv(emitter, "metadata", emitter_type_size, &metadata);
1029  	emitter_json_kv(emitter, "metadata_thp", emitter_type_size,
1030  	    &metadata_thp);
1031  	emitter_json_kv(emitter, "resident", emitter_type_size, &resident);
1032  	emitter_json_kv(emitter, "mapped", emitter_type_size, &mapped);
1033  	emitter_json_kv(emitter, "retained", emitter_type_size, &retained);
1034  	emitter_table_printf(emitter, "Allocated: %zu, active: %zu, "
1035  	    "metadata: %zu (n_thp %zu), resident: %zu, mapped: %zu, "
1036  	    "retained: %zu\n", allocated, active, metadata, metadata_thp,
1037  	    resident, mapped, retained);
1038  	emitter_json_object_kv_begin(emitter, "background_thread");
1039  	emitter_json_kv(emitter, "num_threads", emitter_type_size,
1040  	    &num_background_threads);
1041  	emitter_json_kv(emitter, "num_runs", emitter_type_uint64,
1042  	    &background_thread_num_runs);
1043  	emitter_json_kv(emitter, "run_interval", emitter_type_uint64,
1044  	    &background_thread_run_interval);
1045  	emitter_json_object_end(emitter); &bsol;* Close "background_thread". */
1046  	emitter_table_printf(emitter, "Background threads: %zu, "
1047  	    "num_runs: %"FMTu64", run_interval: %"FMTu64" ns\n",
1048  	    num_background_threads, background_thread_num_runs,
1049  	    background_thread_run_interval);
1050  	if (mutex) {
1051  		emitter_row_t row;
1052  		emitter_col_t name;
1053  		emitter_col_t col64[mutex_prof_num_uint64_t_counters];
1054  		emitter_col_t col32[mutex_prof_num_uint32_t_counters];
1055  		uint64_t uptime;
1056  		emitter_row_init(&row);
1057  		mutex_stats_init_cols(&row, "", &name, col64, col32);
1058  		emitter_table_row(emitter, &row);
1059  		emitter_json_object_kv_begin(emitter, "mutexes");
1060  		CTL_M2_GET("stats.arenas.0.uptime", 0, &uptime, uint64_t);
1061  		for (int i = 0; i < mutex_prof_num_global_mutexes; i++) {
1062  			mutex_stats_read_global(global_mutex_names[i], &name,
1063  			    col64, col32, uptime);
1064  			emitter_json_object_kv_begin(emitter, global_mutex_names[i]);
1065  			mutex_stats_emit(emitter, &row, col64, col32);
1066  			emitter_json_object_end(emitter);
1067  		}
1068  		emitter_json_object_end(emitter); &bsol;* Close "mutexes". */
1069  	}
1070  	emitter_json_object_end(emitter); &bsol;* Close "stats". */
1071  	if (merged || destroyed || unmerged) {
1072  		unsigned narenas;
1073  		emitter_json_object_kv_begin(emitter, "stats.arenas");
1074  		CTL_GET("arenas.narenas", &narenas, unsigned);
1075  		size_t mib[3];
1076  		size_t miblen = sizeof(mib) / sizeof(size_t);
1077  		size_t sz;
1078  		VARIABLE_ARRAY(bool, initialized, narenas);
1079  		bool destroyed_initialized;
1080  		unsigned i, j, ninitialized;
1081  		xmallctlnametomib("arena.0.initialized", mib, &miblen);
1082  		for (i = ninitialized = 0; i < narenas; i++) {
1083  			mib[1] = i;
1084  			sz = sizeof(bool);
1085  			xmallctlbymib(mib, miblen, &initialized[i], &sz,
1086  			    NULL, 0);
1087  			if (initialized[i]) {
1088  				ninitialized++;
1089  			}
1090  		}
1091  		mib[1] = MALLCTL_ARENAS_DESTROYED;
1092  		sz = sizeof(bool);
1093  		xmallctlbymib(mib, miblen, &destroyed_initialized, &sz,
1094  		    NULL, 0);
1095  		if (merged && (ninitialized > 1 || !unmerged)) {
1096  			emitter_table_printf(emitter, "Merged arenas stats:\n");
1097  			emitter_json_object_kv_begin(emitter, "merged");
1098  			stats_arena_print(emitter, MALLCTL_ARENAS_ALL, bins,
1099  			    large, mutex, extents);
1100  			emitter_json_object_end(emitter); &bsol;* Close "merged". */
1101  		}
1102  		if (destroyed_initialized && destroyed) {
1103  			emitter_table_printf(emitter,
1104  			    "Destroyed arenas stats:\n");
1105  			emitter_json_object_kv_begin(emitter, "destroyed");
1106  			stats_arena_print(emitter, MALLCTL_ARENAS_DESTROYED,
1107  			    bins, large, mutex, extents);
1108  			emitter_json_object_end(emitter); &bsol;* Close "destroyed". */
1109  		}
1110  		if (unmerged) {
1111  			for (i = j = 0; i < narenas; i++) {
1112  				if (initialized[i]) {
1113  					char arena_ind_str[20];
1114  					malloc_snprintf(arena_ind_str,
1115  					    sizeof(arena_ind_str), "%u", i);
1116  					emitter_json_object_kv_begin(emitter,
1117  					    arena_ind_str);
1118  					emitter_table_printf(emitter,
1119  					    "arenas[%s]:\n", arena_ind_str);
1120  					stats_arena_print(emitter, i, bins,
1121  					    large, mutex, extents);
1122  					emitter_json_object_end(emitter);
1123  				}
1124  			}
1125  		}
1126  		emitter_json_object_end(emitter); &bsol;* Close "stats.arenas". */
1127  	}
1128  }
1129  void
1130  stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
1131      const char *opts) {
1132  	int err;
1133  	uint64_t epoch;
1134  	size_t u64sz;
1135  #define OPTION(o, v, d, s) bool v = d;
1136  	STATS_PRINT_OPTIONS
1137  #undef OPTION
1138  	epoch = 1;
1139  	u64sz = sizeof(uint64_t);
1140  	err = je_mallctl("epoch", (void *)&epoch, &u64sz, (void *)&epoch,
1141  	    sizeof(uint64_t));
1142  	if (err != 0) {
1143  		if (err == EAGAIN) {
1144  			malloc_write("<jemalloc>: Memory allocation failure in "
1145  			    "mallctl(\"epoch\", ...)\n");
1146  			return;
1147  		}
1148  		malloc_write("<jemalloc>: Failure in mallctl(\"epoch\", "
1149  		    "...)\n");
1150  		abort();
1151  	}
1152  	if (opts != NULL) {
1153  		for (unsigned i = 0; opts[i] != '\0'; i++) {
1154  			switch (opts[i]) {
1155  #define OPTION(o, v, d, s) case o: v = s; break;
1156  				STATS_PRINT_OPTIONS
1157  #undef OPTION
1158  			default:;
1159  			}
1160  		}
1161  	}
1162  	emitter_t emitter;
1163  	emitter_init(&emitter,
1164  	    json ? emitter_output_json : emitter_output_table, write_cb,
1165  	    cbopaque);
1166  	emitter_begin(&emitter);
1167  	emitter_table_printf(&emitter, "___ Begin jemalloc statistics ___\n");
1168  	emitter_json_object_kv_begin(&emitter, "jemalloc");
1169  	if (general) {
1170  		stats_general_print(&emitter);
1171  	}
1172  	if (config_stats) {
1173  		stats_print_helper(&emitter, merged, destroyed, unmerged,
1174  		    bins, large, mutex, extents);
1175  	}
1176  	emitter_json_object_end(&emitter); &bsol;* Closes the "jemalloc" dict. */
1177  	emitter_table_printf(&emitter, "--- End jemalloc statistics ---\n");
1178  	emitter_end(&emitter);
1179  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-webpinfo.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdio.h>
3  #ifdef HAVE_CONFIG_H
4  #include "webp/config.h"
5  #endif
6  #include "../imageio/imageio_util.h"
7  #include "./unicode.h"
8  #include "webp/decode.h"
9  #include "webp/format_constants.h"
10  #include "webp/mux_types.h"
11  #if defined(_MSC_VER) && _MSC_VER < 1900
12  #define snprintf _snprintf
13  #endif
14  #define LOG_ERROR(MESSAGE)                     \
15    do {                                         \
16      if (webp_info->show_diagnosis_) {          \
17        fprintf(stderr, "Error: %s\n", MESSAGE); \
18      }                                          \
19    } while (0)
20  #define LOG_WARN(MESSAGE)                        \
21    do {                                           \
22      if (webp_info->show_diagnosis_) {            \
23        fprintf(stderr, "Warning: %s\n", MESSAGE); \
24      }                                            \
25    } while (0)
26  static const char* const kFormats[3] = {
27    "Unknown",
28    "Lossy",
29    "Lossless"
30  };
31  static const char* const kLosslessTransforms[4] = {
32    "Predictor",
33    "Cross Color",
34    "Subtract Green",
35    "Color Indexing"
36  };
37  static const char* const kAlphaFilterMethods[4] = {
38    "None",
39    "Horizontal",
40    "Vertical",
41    "Gradient"
42  };
43  typedef enum {
44    WEBP_INFO_OK = 0,
45    WEBP_INFO_TRUNCATED_DATA,
46    WEBP_INFO_PARSE_ERROR,
47    WEBP_INFO_INVALID_PARAM,
48    WEBP_INFO_BITSTREAM_ERROR,
49    WEBP_INFO_MISSING_DATA,
50    WEBP_INFO_INVALID_COMMAND
51  } WebPInfoStatus;
52  typedef enum ChunkID {
53    CHUNK_VP8,
54    CHUNK_VP8L,
55    CHUNK_VP8X,
56    CHUNK_ALPHA,
57    CHUNK_ANIM,
58    CHUNK_ANMF,
59    CHUNK_ICCP,
60    CHUNK_EXIF,
61    CHUNK_XMP,
62    CHUNK_UNKNOWN,
63    CHUNK_TYPES = CHUNK_UNKNOWN
64  } ChunkID;
65  typedef struct {
66    size_t start_;
67    size_t end_;
68    const uint8_t* buf_;
69  } MemBuffer;
70  typedef struct {
71    size_t offset_;
72    size_t size_;
73    const uint8_t* payload_;
74    ChunkID id_;
75  } ChunkData;
76  typedef struct WebPInfo {
77    int canvas_width_;
78    int canvas_height_;
79    int loop_count_;
80    int num_frames_;
81    int chunk_counts_[CHUNK_TYPES];
82    int anmf_subchunk_counts_[3];  
83    uint32_t bgcolor_;
84    int feature_flags_;
85    int has_alpha_;
86    int frame_width_, frame_height_;
87    size_t anim_frame_data_size_;
88    int is_processing_anim_frame_, seen_alpha_subchunk_, seen_image_subchunk_;
89    int quiet_, show_diagnosis_, show_summary_;
90    int parse_bitstream_;
91  } WebPInfo;
92  static void WebPInfoInit(WebPInfo* const webp_info) {
93    memset(webp_info, 0, sizeof(*webp_info));
94  }
95  static const char kWebPChunkTags[CHUNK_TYPES][4] = {
96    { 'V', 'P', '8', ' ' },
97    { 'V', 'P', '8', 'L' },
98    { 'V', 'P', '8', 'X' },
99    { 'A', 'L', 'P', 'H' },
100    { 'A', 'N', 'I', 'M' },
101    { 'A', 'N', 'M', 'F' },
102    { 'I', 'C', 'C', 'P' },
103    { 'E', 'X', 'I', 'F' },
104    { 'X', 'M', 'P', ' ' },
105  };
106  static int GetLE16(const uint8_t* const data) {
107    return (data[0] << 0) | (data[1] << 8);
108  }
109  static int GetLE24(const uint8_t* const data) {
110    return GetLE16(data) | (data[2] << 16);
111  }
112  static uint32_t GetLE32(const uint8_t* const data) {
113    return GetLE16(data) | ((uint32_t)GetLE16(data + 2) << 16);
114  }
115  static int ReadLE16(const uint8_t** data) {
116    const int val = GetLE16(*data);
117    *data += 2;
118    return val;
119  }
120  static int ReadLE24(const uint8_t** data) {
121    const int val = GetLE24(*data);
122    *data += 3;
123    return val;
124  }
125  static uint32_t ReadLE32(const uint8_t** data) {
126    const uint32_t val = GetLE32(*data);
127    *data += 4;
128    return val;
129  }
130  static int ReadFileToWebPData(const char* const filename,
131                                WebPData* const webp_data) {
132    const uint8_t* data;
133    size_t size;
134    if (!ImgIoUtilReadFile(filename, &data, &size)) return 0;
135    webp_data->bytes = data;
136    webp_data->size = size;
137    return 1;
138  }
139  static void InitMemBuffer(MemBuffer* const mem, const WebPData* webp_data) {
140    mem->buf_ = webp_data->bytes;
141    mem->start_ = 0;
142    mem->end_ = webp_data->size;
143  }
144  static size_t MemDataSize(const MemBuffer* const mem) {
145    return (mem->end_ - mem->start_);
146  }
147  static const uint8_t* GetBuffer(MemBuffer* const mem) {
148    return mem->buf_ + mem->start_;
149  }
150  static void Skip(MemBuffer* const mem, size_t size) {
151    mem->start_ += size;
152  }
153  static uint32_t ReadMemBufLE32(MemBuffer* const mem) {
154    const uint8_t* const data = mem->buf_ + mem->start_;
155    const uint32_t val = GetLE32(data);
156    assert(MemDataSize(mem) >= 4);
157    Skip(mem, 4);
158    return val;
159  }
160  static int GetBits(const uint8_t* const data, size_t data_size, size_t nb,
161                     int* val, uint64_t* const bit_pos) {
162    *val = 0;
163    while (nb-- > 0) {
164      const uint64_t p = (*bit_pos)++;
165      if ((p >> 3) >= data_size) {
166        return 0;
167      } else {
168        const int bit = !!(data[p >> 3] & (128 >> ((p & 7))));
169        *val = (*val << 1) | bit;
170      }
171    }
172    return 1;
173  }
174  static int GetSignedBits(const uint8_t* const data, size_t data_size, size_t nb,
175                           int* val, uint64_t* const bit_pos) {
176    int sign;
177    if (!GetBits(data, data_size, nb, val, bit_pos)) return 0;
178    if (!GetBits(data, data_size, 1, &sign, bit_pos)) return 0;
179    if (sign) *val = -(*val);
180    return 1;
181  }
182  #define GET_BITS(v, n)                                 \
183    do {                                                 \
184      if (!GetBits(data, data_size, n, &(v), bit_pos)) { \
185        LOG_ERROR("Truncated lossy bitstream.");         \
186        return WEBP_INFO_TRUNCATED_DATA;                 \
187      }                                                  \
188    } while (0)
189  #define GET_SIGNED_BITS(v, n)                                \
190    do {                                                       \
191      if (!GetSignedBits(data, data_size, n, &(v), bit_pos)) { \
192        LOG_ERROR("Truncated lossy bitstream.");               \
193        return WEBP_INFO_TRUNCATED_DATA;                       \
194      }                                                        \
195    } while (0)
196  static WebPInfoStatus ParseLossySegmentHeader(const WebPInfo* const webp_info,
197                                                const uint8_t* const data,
198                                                size_t data_size,
199                                                uint64_t* const bit_pos) {
200    int use_segment;
201    GET_BITS(use_segment, 1);
202    printf("  Use segment:      %d\n", use_segment);
203    if (use_segment) {
204      int update_map, update_data;
205      GET_BITS(update_map, 1);
206      GET_BITS(update_data, 1);
207      printf("  Update map:       %d\n"
208             "  Update data:      %d\n",
209             update_map, update_data);
210      if (update_data) {
211        int i, a_delta;
212        int quantizer[4] = {0, 0, 0, 0};
213        int filter_strength[4] = {0, 0, 0, 0};
214        GET_BITS(a_delta, 1);
215        printf("  Absolute delta:   %d\n", a_delta);
216        for (i = 0; i < 4; ++i) {
217          int bit;
218          GET_BITS(bit, 1);
219          if (bit) GET_SIGNED_BITS(quantizer[i], 7);
220        }
221        for (i = 0; i < 4; ++i) {
222          int bit;
223          GET_BITS(bit, 1);
224          if (bit) GET_SIGNED_BITS(filter_strength[i], 6);
225        }
226        printf("  Quantizer:        %d %d %d %d\n", quantizer[0], quantizer[1],
227               quantizer[2], quantizer[3]);
228        printf("  Filter strength:  %d %d %d %d\n", filter_strength[0],
229               filter_strength[1], filter_strength[2], filter_strength[3]);
230      }
231      if (update_map) {
232        int i;
233        int prob_segment[3] = {255, 255, 255};
234        for (i = 0; i < 3; ++i) {
235          int bit;
236          GET_BITS(bit, 1);
237          if (bit) GET_BITS(prob_segment[i], 8);
238        }
239        printf("  Prob segment:     %d %d %d\n",
240               prob_segment[0], prob_segment[1], prob_segment[2]);
241      }
242    }
243    return WEBP_INFO_OK;
244  }
245  static WebPInfoStatus ParseLossyFilterHeader(const WebPInfo* const webp_info,
246                                               const uint8_t* const data,
247                                               size_t data_size,
248                                               uint64_t* const bit_pos) {
249    int simple_filter, level, sharpness, use_lf_delta;
250    GET_BITS(simple_filter, 1);
251    GET_BITS(level, 6);
252    GET_BITS(sharpness, 3);
253    GET_BITS(use_lf_delta, 1);
254    printf("  Simple filter:    %d\n", simple_filter);
255    printf("  Level:            %d\n", level);
256    printf("  Sharpness:        %d\n", sharpness);
257    printf("  Use lf delta:     %d\n", use_lf_delta);
258    if (use_lf_delta) {
259      int update;
260      GET_BITS(update, 1);
261      printf("  Update lf delta:  %d\n", update);
262      if (update) {
263        int i;
264        for (i = 0; i < 4 + 4; ++i) {
265          int temp;
266          GET_BITS(temp, 1);
267          if (temp) GET_BITS(temp, 7);
268        }
269      }
270    }
271    return WEBP_INFO_OK;
272  }
273  static WebPInfoStatus ParseLossyHeader(const ChunkData* const chunk_data,
274                                         const WebPInfo* const webp_info) {
275    const uint8_t* data = chunk_data->payload_;
276    size_t data_size = chunk_data->size_ - CHUNK_HEADER_SIZE;
277    const uint32_t bits = (uint32_t)data[0] | (data[1] << 8) | (data[2] << 16);
278    const int key_frame = !(bits & 1);
279    const int profile = (bits >> 1) & 7;
280    const int display = (bits >> 4) & 1;
281    const uint32_t partition0_length = (bits >> 5);
282    WebPInfoStatus status = WEBP_INFO_OK;
283    uint64_t bit_position = 0;
284    uint64_t* const bit_pos = &bit_position;
285    int colorspace, clamp_type;
286    printf("  Parsing lossy bitstream...\n");
287    assert(chunk_data->size_ >= CHUNK_HEADER_SIZE + 10);
288    if (profile > 3) {
289      LOG_ERROR("Unknown profile.");
290      return WEBP_INFO_BITSTREAM_ERROR;
291    }
292    if (!display) {
293      LOG_ERROR("Frame is not displayable.");
294      return WEBP_INFO_BITSTREAM_ERROR;
295    }
296    data += 3;
297    data_size -= 3;
298    printf("  Key frame:        %s\n"
299           "  Profile:          %d\n"
300           "  Display:          %s\n"
301           "  Part. 0 length:   %d\n",
302           key_frame ? "Yes" : "No", profile,
303           display ? "Yes" : "No", partition0_length);
304    if (key_frame) {
305      if (!(data[0] == 0x9d && data[1] == 0x01 && data[2] == 0x2a)) {
306        LOG_ERROR("Invalid lossy bitstream signature.");
307        return WEBP_INFO_BITSTREAM_ERROR;
308      }
309      printf("  Width:            %d\n"
310             "  X scale:          %d\n"
311             "  Height:           %d\n"
312             "  Y scale:          %d\n",
313             ((data[4] << 8) | data[3]) & 0x3fff, data[4] >> 6,
314             ((data[6] << 8) | data[5]) & 0x3fff, data[6] >> 6);
315      data += 7;
316      data_size -= 7;
317    } else {
318      LOG_ERROR("Non-keyframe detected in lossy bitstream.");
319      return WEBP_INFO_BITSTREAM_ERROR;
320    }
321    if (partition0_length >= data_size) {
322      LOG_ERROR("Bad partition length.");
323      return WEBP_INFO_BITSTREAM_ERROR;
324    }
325    GET_BITS(colorspace, 1);
326    GET_BITS(clamp_type, 1);
327    printf("  Color space:      %d\n", colorspace);
328    printf("  Clamp type:       %d\n", clamp_type);
329    status = ParseLossySegmentHeader(webp_info, data, data_size, bit_pos);
330    if (status != WEBP_INFO_OK) return status;
331    status = ParseLossyFilterHeader(webp_info, data, data_size, bit_pos);
332    if (status != WEBP_INFO_OK) return status;
333    {  
334      const uint8_t* part_size = data + partition0_length;
335      int num_parts, i;
336      size_t part_data_size;
337      GET_BITS(num_parts, 2);
338      num_parts = 1 << num_parts;
339      if ((int)(data_size - partition0_length) < (num_parts - 1) * 3) {
340        LOG_ERROR("Truncated lossy bitstream.");
341        return WEBP_INFO_TRUNCATED_DATA;
342      }
343      part_data_size = data_size - partition0_length - (num_parts - 1) * 3;
344      printf("  Total partitions: %d\n", num_parts);
345      for (i = 1; i < num_parts; ++i) {
346        const size_t psize =
347            part_size[0] | (part_size[1] << 8) | (part_size[2] << 16);
348        if (psize > part_data_size) {
349          LOG_ERROR("Truncated partition.");
350          return WEBP_INFO_TRUNCATED_DATA;
351        }
352        printf("  Part. %d length:   %d\n", i, (int)psize);
353        part_data_size -= psize;
354        part_size += 3;
355      }
356    }
357    {
358      int base_q, bit;
359      int dq_y1_dc = 0, dq_y2_dc = 0, dq_y2_ac = 0, dq_uv_dc = 0, dq_uv_ac = 0;
360      GET_BITS(base_q, 7);
361      GET_BITS(bit, 1);
362      if (bit) GET_SIGNED_BITS(dq_y1_dc, 4);
363      GET_BITS(bit, 1);
364      if (bit) GET_SIGNED_BITS(dq_y2_dc, 4);
365      GET_BITS(bit, 1);
366      if (bit) GET_SIGNED_BITS(dq_y2_ac, 4);
367      GET_BITS(bit, 1);
368      if (bit) GET_SIGNED_BITS(dq_uv_dc, 4);
369      GET_BITS(bit, 1);
370      if (bit) GET_SIGNED_BITS(dq_uv_ac, 4);
371      printf("  Base Q:           %d\n", base_q);
372      printf("  DQ Y1 DC:         %d\n", dq_y1_dc);
373      printf("  DQ Y2 DC:         %d\n", dq_y2_dc);
374      printf("  DQ Y2 AC:         %d\n", dq_y2_ac);
375      printf("  DQ UV DC:         %d\n", dq_uv_dc);
376      printf("  DQ UV AC:         %d\n", dq_uv_ac);
377    }
378    if ((*bit_pos >> 3) >= partition0_length) {
379      LOG_ERROR("Truncated lossy bitstream.");
380      return WEBP_INFO_TRUNCATED_DATA;
381    }
382    return WEBP_INFO_OK;
383  }
384  static int LLGetBits(const uint8_t* const data, size_t data_size, size_t nb,
385                       int* val, uint64_t* const bit_pos) {
386    uint32_t i = 0;
387    *val = 0;
388    while (i < nb) {
389      const uint64_t p = (*bit_pos)++;
390      if ((p >> 3) >= data_size) {
391        return 0;
392      } else {
393        const int bit = !!(data[p >> 3] & (1 << ((p & 7))));
394        *val = *val | (bit << i);
395        ++i;
396      }
397    }
398    return 1;
399  }
400  #define LL_GET_BITS(v, n)                                \
401    do {                                                   \
402      if (!LLGetBits(data, data_size, n, &(v), bit_pos)) { \
403        LOG_ERROR("Truncated lossless bitstream.");        \
404        return WEBP_INFO_TRUNCATED_DATA;                   \
405      }                                                    \
406    } while (0)
407  static WebPInfoStatus ParseLosslessTransform(WebPInfo* const webp_info,
408                                               const uint8_t* const data,
409                                               size_t data_size,
410                                               uint64_t* const  bit_pos) {
411    int use_transform, block_size, n_colors;
412    LL_GET_BITS(use_transform, 1);
413    printf("  Use transform:    %s\n", use_transform ? "Yes" : "No");
414    if (use_transform) {
415      int type;
416      LL_GET_BITS(type, 2);
417      printf("  1st transform:    %s (%d)\n", kLosslessTransforms[type], type);
418      switch (type) {
419        case PREDICTOR_TRANSFORM:
420        case CROSS_COLOR_TRANSFORM:
421          LL_GET_BITS(block_size, 3);
422          block_size = 1 << (block_size + 2);
423          printf("  Tran. block size: %d\n", block_size);
424          break;
425        case COLOR_INDEXING_TRANSFORM:
426          LL_GET_BITS(n_colors, 8);
427          n_colors += 1;
428          printf("  No. of colors:    %d\n", n_colors);
429          break;
430        default: break;
431      }
432    }
433    return WEBP_INFO_OK;
434  }
435  static WebPInfoStatus ParseLosslessHeader(const ChunkData* const chunk_data,
436                                            WebPInfo* const webp_info) {
437    const uint8_t* data = chunk_data->payload_;
438    size_t data_size = chunk_data->size_ - CHUNK_HEADER_SIZE;
439    uint64_t bit_position = 0;
440    uint64_t* const bit_pos = &bit_position;
441    WebPInfoStatus status;
442    printf("  Parsing lossless bitstream...\n");
443    if (data_size < VP8L_FRAME_HEADER_SIZE) {
444      LOG_ERROR("Truncated lossless bitstream.");
445      return WEBP_INFO_TRUNCATED_DATA;
446    }
447    if (data[0] != VP8L_MAGIC_BYTE) {
448      LOG_ERROR("Invalid lossless bitstream signature.");
449      return WEBP_INFO_BITSTREAM_ERROR;
450    }
451    data += 1;
452    data_size -= 1;
453    {
454      int width, height, has_alpha, version;
455      LL_GET_BITS(width, 14);
456      LL_GET_BITS(height, 14);
457      LL_GET_BITS(has_alpha, 1);
458      LL_GET_BITS(version, 3);
459      width += 1;
460      height += 1;
461      printf("  Width:            %d\n", width);
462      printf("  Height:           %d\n", height);
463      printf("  Alpha:            %d\n", has_alpha);
464      printf("  Version:          %d\n", version);
465    }
466    status = ParseLosslessTransform(webp_info, data, data_size, bit_pos);
467    if (status != WEBP_INFO_OK) return status;
468    return WEBP_INFO_OK;
469  }
470  static WebPInfoStatus ParseAlphaHeader(const ChunkData* const chunk_data,
471                                         WebPInfo* const webp_info) {
472    const uint8_t* data = chunk_data->payload_;
473    size_t data_size = chunk_data->size_ - CHUNK_HEADER_SIZE;
474    if (data_size <= ALPHA_HEADER_LEN) {
475      LOG_ERROR("Truncated ALPH chunk.");
476      return WEBP_INFO_TRUNCATED_DATA;
477    }
478    printf("  Parsing ALPH chunk...\n");
479    {
480      const int compression_method = (data[0] >> 0) & 0x03;
481      const int filter = (data[0] >> 2) & 0x03;
482      const int pre_processing = (data[0] >> 4) & 0x03;
483      const int reserved_bits = (data[0] >> 6) & 0x03;
484      printf("  Compression:      %d\n", compression_method);
485      printf("  Filter:           %s (%d)\n",
486             kAlphaFilterMethods[filter], filter);
487      printf("  Pre-processing:   %d\n", pre_processing);
488      if (compression_method > ALPHA_LOSSLESS_COMPRESSION) {
489        LOG_ERROR("Invalid Alpha compression method.");
490        return WEBP_INFO_BITSTREAM_ERROR;
491      }
492      if (pre_processing > ALPHA_PREPROCESSED_LEVELS) {
493        LOG_ERROR("Invalid Alpha pre-processing method.");
494        return WEBP_INFO_BITSTREAM_ERROR;
495      }
496      if (reserved_bits != 0) {
497        LOG_WARN("Reserved bits in ALPH chunk header are not all 0.");
498      }
499      data += ALPHA_HEADER_LEN;
500      data_size -= ALPHA_HEADER_LEN;
501      if (compression_method == ALPHA_LOSSLESS_COMPRESSION) {
502        uint64_t bit_pos = 0;
503        WebPInfoStatus status =
504            ParseLosslessTransform(webp_info, data, data_size, &bit_pos);
505        if (status != WEBP_INFO_OK) return status;
506      }
507    }
508    return WEBP_INFO_OK;
509  }
510  static WebPInfoStatus ParseRIFFHeader(const WebPInfo* const webp_info,
511                                        MemBuffer* const mem) {
512    const size_t min_size = RIFF_HEADER_SIZE + CHUNK_HEADER_SIZE;
513    size_t riff_size;
514    if (MemDataSize(mem) < min_size) {
515      LOG_ERROR("Truncated data detected when parsing RIFF header.");
516      return WEBP_INFO_TRUNCATED_DATA;
517    }
518    if (memcmp(GetBuffer(mem), "RIFF", CHUNK_SIZE_BYTES) ||
519        memcmp(GetBuffer(mem) + CHUNK_HEADER_SIZE, "WEBP", CHUNK_SIZE_BYTES)) {
520      LOG_ERROR("Corrupted RIFF header.");
521      return WEBP_INFO_PARSE_ERROR;
522    }
523    riff_size = GetLE32(GetBuffer(mem) + TAG_SIZE);
524    if (riff_size < CHUNK_HEADER_SIZE) {
525      LOG_ERROR("RIFF size is too small.");
526      return WEBP_INFO_PARSE_ERROR;
527    }
528    if (riff_size > MAX_CHUNK_PAYLOAD) {
529      LOG_ERROR("RIFF size is over limit.");
530      return WEBP_INFO_PARSE_ERROR;
531    }
532    riff_size += CHUNK_HEADER_SIZE;
533    if (!webp_info->quiet_) {
534      printf("RIFF HEADER:\n");
535      printf("  File size: %6d\n", (int)riff_size);
536    }
537    if (riff_size < mem->end_) {
538      LOG_WARN("RIFF size is smaller than the file size.");
539      mem->end_ = riff_size;
540    } else if (riff_size > mem->end_) {
541      LOG_ERROR("Truncated data detected when parsing RIFF payload.");
542      return WEBP_INFO_TRUNCATED_DATA;
543    }
544    Skip(mem, RIFF_HEADER_SIZE);
545    return WEBP_INFO_OK;
546  }
547  static WebPInfoStatus ParseChunk(const WebPInfo* const webp_info,
548                                   MemBuffer* const mem,
549                                   ChunkData* const chunk_data) {
550    memset(chunk_data, 0, sizeof(*chunk_data));
551    if (MemDataSize(mem) < CHUNK_HEADER_SIZE) {
552      LOG_ERROR("Truncated data detected when parsing chunk header.");
553      return WEBP_INFO_TRUNCATED_DATA;
554    } else {
555      const size_t chunk_start_offset = mem->start_;
556      const uint32_t fourcc = ReadMemBufLE32(mem);
557      const uint32_t payload_size = ReadMemBufLE32(mem);
558      const uint32_t payload_size_padded = payload_size + (payload_size & 1);
559      const size_t chunk_size = CHUNK_HEADER_SIZE + payload_size_padded;
560      int i;
561      if (payload_size > MAX_CHUNK_PAYLOAD) {
562        LOG_ERROR("Size of chunk payload is over limit.");
563        return WEBP_INFO_INVALID_PARAM;
564      }
565      if (payload_size_padded > MemDataSize(mem)){
566        LOG_ERROR("Truncated data detected when parsing chunk payload.");
567        return WEBP_INFO_TRUNCATED_DATA;
568      }
569      for (i = 0; i < CHUNK_TYPES; ++i) {
570        if (!memcmp(kWebPChunkTags[i], &fourcc, TAG_SIZE)) break;
571      }
572      chunk_data->offset_ = chunk_start_offset;
573      chunk_data->size_ = chunk_size;
574      chunk_data->id_ = (ChunkID)i;
575      chunk_data->payload_ = GetBuffer(mem);
576      if (chunk_data->id_ == CHUNK_ANMF) {
577        if (payload_size != payload_size_padded) {
578          LOG_ERROR("ANMF chunk size should always be even.");
579          return WEBP_INFO_PARSE_ERROR;
580        }
581        Skip(mem, ANMF_CHUNK_SIZE);
582      } else {
583        Skip(mem, payload_size_padded);
584      }
585      return WEBP_INFO_OK;
586    }
587  }
588  static WebPInfoStatus ProcessVP8XChunk(const ChunkData* const chunk_data,
589                                         WebPInfo* const webp_info) {
590    const uint8_t* data = chunk_data->payload_;
591    if (webp_info->chunk_counts_[CHUNK_VP8] ||
592        webp_info->chunk_counts_[CHUNK_VP8L] ||
593        webp_info->chunk_counts_[CHUNK_VP8X]) {
594      LOG_ERROR("Already seen a VP8/VP8L/VP8X chunk when parsing VP8X chunk.");
595      return WEBP_INFO_PARSE_ERROR;
596    }
597    if (chunk_data->size_ != VP8X_CHUNK_SIZE + CHUNK_HEADER_SIZE) {
598      LOG_ERROR("Corrupted VP8X chunk.");
599      return WEBP_INFO_PARSE_ERROR;
600    }
601    ++webp_info->chunk_counts_[CHUNK_VP8X];
602    webp_info->feature_flags_ = *data;
603    data += 4;
604    webp_info->canvas_width_ = 1 + ReadLE24(&data);
605    webp_info->canvas_height_ = 1 + ReadLE24(&data);
606    if (!webp_info->quiet_) {
607      printf("  ICCP: %d\n  Alpha: %d\n  EXIF: %d\n  XMP: %d\n  Animation: %d\n",
608             (webp_info->feature_flags_ & ICCP_FLAG) != 0,
609             (webp_info->feature_flags_ & ALPHA_FLAG) != 0,
610             (webp_info->feature_flags_ & EXIF_FLAG) != 0,
611             (webp_info->feature_flags_ & XMP_FLAG) != 0,
612             (webp_info->feature_flags_ & ANIMATION_FLAG) != 0);
613      printf("  Canvas size %d x %d\n",
614             webp_info->canvas_width_, webp_info->canvas_height_);
615    }
616    if (webp_info->canvas_width_ > MAX_CANVAS_SIZE) {
617      LOG_WARN("Canvas width is out of range in VP8X chunk.");
618    }
619    if (webp_info->canvas_height_ > MAX_CANVAS_SIZE) {
620      LOG_WARN("Canvas height is out of range in VP8X chunk.");
621    }
622    if ((uint64_t)webp_info->canvas_width_ * webp_info->canvas_height_ >
623        MAX_IMAGE_AREA) {
624      LOG_WARN("Canvas area is out of range in VP8X chunk.");
625    }
626    return WEBP_INFO_OK;
627  }
628  static WebPInfoStatus ProcessANIMChunk(const ChunkData* const chunk_data,
629                                         WebPInfo* const webp_info) {
630    const uint8_t* data = chunk_data->payload_;
631    if (!webp_info->chunk_counts_[CHUNK_VP8X]) {
632      LOG_ERROR("ANIM chunk detected before VP8X chunk.");
633      return WEBP_INFO_PARSE_ERROR;
634    }
635    if (chunk_data->size_ != ANIM_CHUNK_SIZE + CHUNK_HEADER_SIZE) {
636      LOG_ERROR("Corrupted ANIM chunk.");
637      return WEBP_INFO_PARSE_ERROR;
638    }
639    webp_info->bgcolor_ = ReadLE32(&data);
640    webp_info->loop_count_ = ReadLE16(&data);
641    ++webp_info->chunk_counts_[CHUNK_ANIM];
642    if (!webp_info->quiet_) {
643      printf("  Background color:(ARGB) %02x %02x %02x %02x\n",
644             (webp_info->bgcolor_ >> 24) & 0xff,
645             (webp_info->bgcolor_ >> 16) & 0xff,
646             (webp_info->bgcolor_ >> 8) & 0xff,
647             webp_info->bgcolor_ & 0xff);
648      printf("  Loop count      : %d\n", webp_info->loop_count_);
649    }
650    if (webp_info->loop_count_ > MAX_LOOP_COUNT) {
651      LOG_WARN("Loop count is out of range in ANIM chunk.");
652    }
653    return WEBP_INFO_OK;
654  }
655  static WebPInfoStatus ProcessANMFChunk(const ChunkData* const chunk_data,
656                                         WebPInfo* const webp_info) {
657    const uint8_t* data = chunk_data->payload_;
658    int offset_x, offset_y, width, height, duration, blend, dispose, temp;
659    if (webp_info->is_processing_anim_frame_) {
660      LOG_ERROR("ANMF chunk detected within another ANMF chunk.");
661      return WEBP_INFO_PARSE_ERROR;
662    }
663    if (!webp_info->chunk_counts_[CHUNK_ANIM]) {
664      LOG_ERROR("ANMF chunk detected before ANIM chunk.");
665      return WEBP_INFO_PARSE_ERROR;
666    }
667    if (chunk_data->size_ <= CHUNK_HEADER_SIZE + ANMF_CHUNK_SIZE) {
668      LOG_ERROR("Truncated data detected when parsing ANMF chunk.");
669      return WEBP_INFO_TRUNCATED_DATA;
670    }
671    offset_x = 2 * ReadLE24(&data);
672    offset_y = 2 * ReadLE24(&data);
673    width = 1 + ReadLE24(&data);
674    height = 1 + ReadLE24(&data);
675    duration = ReadLE24(&data);
676    temp = *data;
677    dispose = temp & 1;
678    blend = (temp >> 1) & 1;
679    ++webp_info->chunk_counts_[CHUNK_ANMF];
680    if (!webp_info->quiet_) {
681      printf("  Offset_X: %d\n  Offset_Y: %d\n  Width: %d\n  Height: %d\n"
682             "  Duration: %d\n  Dispose: %d\n  Blend: %d\n",
683             offset_x, offset_y, width, height, duration, dispose, blend);
684    }
685    if (duration > MAX_DURATION) {
686      LOG_ERROR("Invalid duration parameter in ANMF chunk.");
687      return WEBP_INFO_INVALID_PARAM;
688    }
689    if (offset_x > MAX_POSITION_OFFSET || offset_y > MAX_POSITION_OFFSET) {
690      LOG_ERROR("Invalid offset parameters in ANMF chunk.");
691      return WEBP_INFO_INVALID_PARAM;
692    }
693    if ((uint64_t)offset_x + width > (uint64_t)webp_info->canvas_width_ ||
694        (uint64_t)offset_y + height > (uint64_t)webp_info->canvas_height_) {
695      LOG_ERROR("Frame exceeds canvas in ANMF chunk.");
696      return WEBP_INFO_INVALID_PARAM;
697    }
698    webp_info->is_processing_anim_frame_ = 1;
699    webp_info->seen_alpha_subchunk_ = 0;
700    webp_info->seen_image_subchunk_ = 0;
701    webp_info->frame_width_ = width;
702    webp_info->frame_height_ = height;
703    webp_info->anim_frame_data_size_ =
704        chunk_data->size_ - CHUNK_HEADER_SIZE - ANMF_CHUNK_SIZE;
705    return WEBP_INFO_OK;
706  }
707  static WebPInfoStatus ProcessImageChunk(const ChunkData* const chunk_data,
708                                          WebPInfo* const webp_info) {
709    const uint8_t* data = chunk_data->payload_ - CHUNK_HEADER_SIZE;
710    WebPBitstreamFeatures features;
711    const VP8StatusCode vp8_status =
712        WebPGetFeatures(data, chunk_data->size_, &features);
713    if (vp8_status != VP8_STATUS_OK) {
714      LOG_ERROR("VP8/VP8L bitstream error.");
715      return WEBP_INFO_BITSTREAM_ERROR;
716    }
717    if (!webp_info->quiet_) {
718      assert(features.format >= 0 && features.format <= 2);
719      printf("  Width: %d\n  Height: %d\n  Alpha: %d\n  Animation: %d\n"
720             "  Format: %s (%d)\n",
721             features.width, features.height, features.has_alpha,
722             features.has_animation, kFormats[features.format], features.format);
723    }
724    if (webp_info->is_processing_anim_frame_) {
725      ++webp_info->anmf_subchunk_counts_[chunk_data->id_ == CHUNK_VP8 ? 0 : 1];
726      if (chunk_data->id_ == CHUNK_VP8L && webp_info->seen_alpha_subchunk_) {
727        LOG_ERROR("Both VP8L and ALPH sub-chunks are present in an ANMF chunk.");
728        return WEBP_INFO_PARSE_ERROR;
729      }
730      if (webp_info->frame_width_ != features.width ||
731          webp_info->frame_height_ != features.height) {
732        LOG_ERROR("Frame size in VP8/VP8L sub-chunk differs from ANMF header.");
733        return WEBP_INFO_PARSE_ERROR;
734      }
735      if (webp_info->seen_image_subchunk_) {
736        LOG_ERROR("Consecutive VP8/VP8L sub-chunks in an ANMF chunk.");
737        return WEBP_INFO_PARSE_ERROR;
738      }
739      webp_info->seen_image_subchunk_ = 1;
<span onclick='openModal()' class='match'>740    } else {
741      if (webp_info->chunk_counts_[CHUNK_VP8] ||
742          webp_info->chunk_counts_[CHUNK_VP8L]) {
743        LOG_ERROR("Multiple VP8/VP8L chunks detected.");
744        return WEBP_INFO_PARSE_ERROR;
745      }
746      if (chunk_data->id_ == CHUNK_VP8L &&
747          webp_info->chunk_counts_[CHUNK_ALPHA]) {
748        LOG_WARN("Both VP8L and ALPH chunks are detected.");
749      }
</span>750      if (webp_info->chunk_counts_[CHUNK_ANIM] ||
751          webp_info->chunk_counts_[CHUNK_ANMF]) {
752        LOG_ERROR("VP8/VP8L chunk and ANIM/ANMF chunk are both detected.");
753        return WEBP_INFO_PARSE_ERROR;
754      }
755      if (webp_info->chunk_counts_[CHUNK_VP8X]) {
756        if (webp_info->canvas_width_ != features.width ||
757            webp_info->canvas_height_ != features.height) {
758          LOG_ERROR("Image size in VP8/VP8L chunk differs from VP8X chunk.");
759          return WEBP_INFO_PARSE_ERROR;
760        }
761      } else {
762        webp_info->canvas_width_ = features.width;
763        webp_info->canvas_height_ = features.height;
764        if (webp_info->canvas_width_ < 1 || webp_info->canvas_height_ < 1 ||
765            webp_info->canvas_width_ > MAX_CANVAS_SIZE ||
766            webp_info->canvas_height_ > MAX_CANVAS_SIZE ||
767            (uint64_t)webp_info->canvas_width_ * webp_info->canvas_height_ >
768                MAX_IMAGE_AREA) {
769          LOG_WARN("Invalid parameters in VP8/VP8L chunk.");
770        }
771      }
772      ++webp_info->chunk_counts_[chunk_data->id_];
773    }
774    ++webp_info->num_frames_;
775    webp_info->has_alpha_ |= features.has_alpha;
776    if (webp_info->parse_bitstream_) {
777      const int is_lossy = (chunk_data->id_ == CHUNK_VP8);
778      const WebPInfoStatus status =
779          is_lossy ? ParseLossyHeader(chunk_data, webp_info)
780                   : ParseLosslessHeader(chunk_data, webp_info);
781      if (status != WEBP_INFO_OK) return status;
782    }
783    return WEBP_INFO_OK;
784  }
785  static WebPInfoStatus ProcessALPHChunk(const ChunkData* const chunk_data,
786                                         WebPInfo* const webp_info) {
787    if (webp_info->is_processing_anim_frame_) {
788      ++webp_info->anmf_subchunk_counts_[2];
789      if (webp_info->seen_alpha_subchunk_) {
790        LOG_ERROR("Consecutive ALPH sub-chunks in an ANMF chunk.");
791        return WEBP_INFO_PARSE_ERROR;
792      }
793      webp_info->seen_alpha_subchunk_ = 1;
794      if (webp_info->seen_image_subchunk_) {
795        LOG_ERROR("ALPHA sub-chunk detected after VP8 sub-chunk "
796                  "in an ANMF chunk.");
797        return WEBP_INFO_PARSE_ERROR;
798      }
799    } else {
800      if (webp_info->chunk_counts_[CHUNK_ANIM] ||
801          webp_info->chunk_counts_[CHUNK_ANMF]) {
802        LOG_ERROR("ALPHA chunk and ANIM/ANMF chunk are both detected.");
803        return WEBP_INFO_PARSE_ERROR;
804      }
805      if (!webp_info->chunk_counts_[CHUNK_VP8X]) {
806        LOG_ERROR("ALPHA chunk detected before VP8X chunk.");
807        return WEBP_INFO_PARSE_ERROR;
808      }
809      if (webp_info->chunk_counts_[CHUNK_VP8]) {
810        LOG_ERROR("ALPHA chunk detected after VP8 chunk.");
811        return WEBP_INFO_PARSE_ERROR;
812      }
813      if (webp_info->chunk_counts_[CHUNK_ALPHA]) {
814        LOG_ERROR("Multiple ALPHA chunks detected.");
815        return WEBP_INFO_PARSE_ERROR;
816      }
817      ++webp_info->chunk_counts_[CHUNK_ALPHA];
818    }
819    webp_info->has_alpha_ = 1;
820    if (webp_info->parse_bitstream_) {
821      const WebPInfoStatus status = ParseAlphaHeader(chunk_data, webp_info);
822      if (status != WEBP_INFO_OK) return status;
823    }
824    return WEBP_INFO_OK;
825  }
826  static WebPInfoStatus ProcessICCPChunk(const ChunkData* const chunk_data,
827                                         WebPInfo* const webp_info) {
828    (void)chunk_data;
829    if (!webp_info->chunk_counts_[CHUNK_VP8X]) {
830      LOG_ERROR("ICCP chunk detected before VP8X chunk.");
831      return WEBP_INFO_PARSE_ERROR;
832    }
833    if (webp_info->chunk_counts_[CHUNK_VP8] ||
834        webp_info->chunk_counts_[CHUNK_VP8L] ||
835        webp_info->chunk_counts_[CHUNK_ANIM]) {
836      LOG_ERROR("ICCP chunk detected after image data.");
837      return WEBP_INFO_PARSE_ERROR;
838    }
839    ++webp_info->chunk_counts_[CHUNK_ICCP];
840    return WEBP_INFO_OK;
841  }
842  static WebPInfoStatus ProcessChunk(const ChunkData* const chunk_data,
843                                     WebPInfo* const webp_info) {
844    WebPInfoStatus status = WEBP_INFO_OK;
845    ChunkID id = chunk_data->id_;
846    if (chunk_data->id_ == CHUNK_UNKNOWN) {
847      char error_message[50];
848      snprintf(error_message, 50, "Unknown chunk at offset %6d, length %6d",
849              (int)chunk_data->offset_, (int)chunk_data->size_);
850      LOG_WARN(error_message);
851    } else {
852      if (!webp_info->quiet_) {
853        const char* tag = kWebPChunkTags[chunk_data->id_];
854        printf("Chunk %c%c%c%c at offset %6d, length %6d\n",
855               tag[0], tag[1], tag[2], tag[3], (int)chunk_data->offset_,
856               (int)chunk_data->size_);
857      }
858    }
859    switch (id) {
860      case CHUNK_VP8:
861      case CHUNK_VP8L:
862        status = ProcessImageChunk(chunk_data, webp_info);
863        break;
864      case CHUNK_VP8X:
865        status = ProcessVP8XChunk(chunk_data, webp_info);
866        break;
867      case CHUNK_ALPHA:
868        status = ProcessALPHChunk(chunk_data, webp_info);
869        break;
870      case CHUNK_ANIM:
871        status = ProcessANIMChunk(chunk_data, webp_info);
872        break;
873      case CHUNK_ANMF:
874        status = ProcessANMFChunk(chunk_data, webp_info);
875        break;
876      case CHUNK_ICCP:
877        status = ProcessICCPChunk(chunk_data, webp_info);
878        break;
879      case CHUNK_EXIF:
880      case CHUNK_XMP:
881        ++webp_info->chunk_counts_[id];
882        break;
883      case CHUNK_UNKNOWN:
884      default:
885        break;
886    }
887    if (webp_info->is_processing_anim_frame_ && id != CHUNK_ANMF) {
888      if (webp_info->anim_frame_data_size_ == chunk_data->size_) {
889        if (!webp_info->seen_image_subchunk_) {
890          LOG_ERROR("No VP8/VP8L chunk detected in an ANMF chunk.");
891          return WEBP_INFO_PARSE_ERROR;
892        }
893        webp_info->is_processing_anim_frame_ = 0;
894      } else if (webp_info->anim_frame_data_size_ > chunk_data->size_) {
895        webp_info->anim_frame_data_size_ -= chunk_data->size_;
896      } else {
897        LOG_ERROR("Truncated data detected when parsing ANMF chunk.");
898        return WEBP_INFO_TRUNCATED_DATA;
899      }
900    }
901    return status;
902  }
903  static WebPInfoStatus Validate(const WebPInfo* const webp_info) {
904    if (webp_info->num_frames_ < 1) {
905      LOG_ERROR("No image/frame detected.");
906      return WEBP_INFO_MISSING_DATA;
907    }
908    if (webp_info->chunk_counts_[CHUNK_VP8X]) {
909      const int iccp = !!(webp_info->feature_flags_ & ICCP_FLAG);
910      const int exif = !!(webp_info->feature_flags_ & EXIF_FLAG);
911      const int xmp = !!(webp_info->feature_flags_ & XMP_FLAG);
912      const int animation = !!(webp_info->feature_flags_ & ANIMATION_FLAG);
913      const int alpha = !!(webp_info->feature_flags_ & ALPHA_FLAG);
914      if (!alpha && webp_info->has_alpha_) {
915        LOG_ERROR("Unexpected alpha data detected.");
916        return WEBP_INFO_PARSE_ERROR;
917      }
918      if (alpha && !webp_info->has_alpha_) {
919        LOG_WARN("Alpha flag is set with no alpha data present.");
920      }
921      if (iccp && !webp_info->chunk_counts_[CHUNK_ICCP]) {
922        LOG_ERROR("Missing ICCP chunk.");
923        return WEBP_INFO_MISSING_DATA;
924      }
925      if (exif && !webp_info->chunk_counts_[CHUNK_EXIF]) {
926        LOG_ERROR("Missing EXIF chunk.");
927        return WEBP_INFO_MISSING_DATA;
928      }
929      if (xmp && !webp_info->chunk_counts_[CHUNK_XMP]) {
930        LOG_ERROR("Missing XMP chunk.");
931        return WEBP_INFO_MISSING_DATA;
932      }
933      if (!iccp && webp_info->chunk_counts_[CHUNK_ICCP]) {
934        LOG_ERROR("Unexpected ICCP chunk detected.");
935        return WEBP_INFO_PARSE_ERROR;
936      }
937      if (!exif && webp_info->chunk_counts_[CHUNK_EXIF]) {
938        LOG_ERROR("Unexpected EXIF chunk detected.");
939        return WEBP_INFO_PARSE_ERROR;
940      }
941      if (!xmp && webp_info->chunk_counts_[CHUNK_XMP]) {
942        LOG_ERROR("Unexpected XMP chunk detected.");
943        return WEBP_INFO_PARSE_ERROR;
944      }
945      if (webp_info->is_processing_anim_frame_) return WEBP_INFO_MISSING_DATA;
946      if (!animation && webp_info->num_frames_ > 1) {
947        LOG_ERROR("More than 1 frame detected in non-animation file.");
948        return WEBP_INFO_PARSE_ERROR;
949      }
950      if (animation && (!webp_info->chunk_counts_[CHUNK_ANIM] ||
951          !webp_info->chunk_counts_[CHUNK_ANMF])) {
952        LOG_ERROR("No ANIM/ANMF chunk detected in animation file.");
953        return WEBP_INFO_PARSE_ERROR;
954      }
955    }
956    return WEBP_INFO_OK;
957  }
958  static void ShowSummary(const WebPInfo* const webp_info) {
959    int i;
960    printf("Summary:\n");
961    printf("Number of frames: %d\n", webp_info->num_frames_);
962    printf("Chunk type  :  VP8 VP8L VP8X ALPH ANIM ANMF(VP8 /VP8L/ALPH) ICCP "
963        "EXIF  XMP\n");
964    printf("Chunk counts: ");
965    for (i = 0; i < CHUNK_TYPES; ++i) {
966      printf("%4d ", webp_info->chunk_counts_[i]);
967      if (i == CHUNK_ANMF) {
968        printf("%4d %4d %4d  ",
969               webp_info->anmf_subchunk_counts_[0],
970               webp_info->anmf_subchunk_counts_[1],
971               webp_info->anmf_subchunk_counts_[2]);
972      }
973    }
974    printf("\n");
975  }
976  static WebPInfoStatus AnalyzeWebP(WebPInfo* const webp_info,
977                                    const WebPData* webp_data) {
978    ChunkData chunk_data;
979    MemBuffer mem_buffer;
980    WebPInfoStatus webp_info_status = WEBP_INFO_OK;
981    InitMemBuffer(&mem_buffer, webp_data);
982    webp_info_status = ParseRIFFHeader(webp_info, &mem_buffer);
983    if (webp_info_status != WEBP_INFO_OK) goto Error;
984    while (webp_info_status == WEBP_INFO_OK && MemDataSize(&mem_buffer) > 0) {
985      webp_info_status = ParseChunk(webp_info, &mem_buffer, &chunk_data);
986      if (webp_info_status != WEBP_INFO_OK) goto Error;
987      webp_info_status = ProcessChunk(&chunk_data, webp_info);
988    }
989    if (webp_info_status != WEBP_INFO_OK) goto Error;
990    if (webp_info->show_summary_) ShowSummary(webp_info);
991    webp_info_status = Validate(webp_info);
992   Error:
993    if (!webp_info->quiet_) {
994      if (webp_info_status == WEBP_INFO_OK) {
995        printf("No error detected.\n");
996      } else {
997        printf("Errors detected.\n");
998      }
999    }
1000    return webp_info_status;
1001  }
1002  static void HelpShort(void) {
1003    printf("Usage: webpinfo [options] in_files\n"
1004           "Try -longhelp for an exhaustive list of options.\n");
1005  }
1006  static void HelpLong(void) {
1007    printf("Usage: webpinfo [options] in_files\n"
1008           "Note: there could be multiple input files;\n"
1009           "      options must come before input files.\n"
1010           "Options:\n"
1011           "  -version ........... Print version number and exit.\n"
1012           "  -quiet ............. Do not show chunk parsing information.\n"
1013           "  -diag .............. Show parsing error diagnosis.\n"
1014           "  -summary ........... Show chunk stats summary.\n"
1015           "  -bitstream_info .... Parse bitstream header.\n");
1016  }
1017  int main(int argc, const char* argv[]) {
1018    int c, quiet = 0, show_diag = 0, show_summary = 0;
1019    int parse_bitstream = 0;
1020    WebPInfoStatus webp_info_status = WEBP_INFO_OK;
1021    WebPInfo webp_info;
1022    INIT_WARGV(argc, argv);
1023    if (argc == 1) {
1024      HelpShort();
1025      FREE_WARGV_AND_RETURN(WEBP_INFO_OK);
1026    }
1027    for (c = 1; c < argc; ++c) {
1028      if (!strcmp(argv[c], "-h") || !strcmp(argv[c], "-help")) {
1029        HelpShort();
1030        FREE_WARGV_AND_RETURN(WEBP_INFO_OK);
1031      } else if (!strcmp(argv[c], "-H") || !strcmp(argv[c], "-longhelp")) {
1032        HelpLong();
1033        FREE_WARGV_AND_RETURN(WEBP_INFO_OK);
1034      } else if (!strcmp(argv[c], "-quiet")) {
1035        quiet = 1;
1036      } else if (!strcmp(argv[c], "-diag")) {
1037        show_diag = 1;
1038      } else if (!strcmp(argv[c], "-summary")) {
1039        show_summary = 1;
1040      } else if (!strcmp(argv[c], "-bitstream_info")) {
1041        parse_bitstream = 1;
1042      } else if (!strcmp(argv[c], "-version")) {
1043        const int version = WebPGetDecoderVersion();
1044        printf("WebP Decoder version: %d.%d.%d\n",
1045               (version >> 16) & 0xff, (version >> 8) & 0xff, version & 0xff);
1046        FREE_WARGV_AND_RETURN(0);
1047      } else {  
1048        break;
1049      }
1050    }
1051    if (c == argc) {
1052      HelpShort();
1053      FREE_WARGV_AND_RETURN(WEBP_INFO_INVALID_COMMAND);
1054    }
1055    for (; c < argc; ++c) {
1056      WebPData webp_data;
1057      const W_CHAR* in_file = NULL;
1058      WebPInfoInit(&webp_info);
1059      webp_info.quiet_ = quiet;
1060      webp_info.show_diagnosis_ = show_diag;
1061      webp_info.show_summary_ = show_summary;
1062      webp_info.parse_bitstream_ = parse_bitstream;
1063      in_file = GET_WARGV(argv, c);
1064      if (in_file == NULL ||
1065          !ReadFileToWebPData((const char*)in_file, &webp_data)) {
1066        webp_info_status = WEBP_INFO_INVALID_COMMAND;
1067        WFPRINTF(stderr, "Failed to open input file %s.\n", in_file);
1068        continue;
1069      }
1070      if (!webp_info.quiet_) WPRINTF("File: %s\n", in_file);
1071      webp_info_status = AnalyzeWebP(&webp_info, &webp_data);
1072      WebPDataClear(&webp_data);
1073    }
1074    FREE_WARGV_AND_RETURN(webp_info_status);
1075  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-stats_13.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-webpinfo.c</div>
                <div class="column column_space"><pre><code>56  get_rate_str(uint64_t dividend, uint64_t divisor, char str[6]) {
57  	if (divisor == 0 || dividend > divisor) {
58  		return true;
59  	}
60  	if (dividend > 0) {
61  		assert(UINT64_MAX / dividend >= 1000);
62  	}
</pre></code></div>
                <div class="column column_space"><pre><code>740    } else {
741      if (webp_info->chunk_counts_[CHUNK_VP8] ||
742          webp_info->chunk_counts_[CHUNK_VP8L]) {
743        LOG_ERROR("Multiple VP8/VP8L chunks detected.");
744        return WEBP_INFO_PARSE_ERROR;
745      }
746      if (chunk_data->id_ == CHUNK_VP8L &&
747          webp_info->chunk_counts_[CHUNK_ALPHA]) {
748        LOG_WARN("Both VP8L and ALPH chunks are detected.");
749      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    