
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-ble_gatt.h</h3>
            <pre><code>1  #ifndef BLE_GATT_H__
2  #define BLE_GATT_H__
3  #include <stdint.h>
4  #include "nrf_svc.h"
5  #include "nrf_error.h"
6  #include "ble_hci.h"
7  #include "ble_ranges.h"
8  #include "ble_types.h"
9  #include "ble_err.h"
10  #ifdef __cplusplus
11  extern "C" {
12  #endif
13  #define BLE_GATT_ATT_MTU_DEFAULT          23
14  #define BLE_GATT_HANDLE_INVALID            0x0000
15  #define BLE_GATT_HANDLE_START              0x0001
16  #define BLE_GATT_HANDLE_END                0xFFFF
17  #define BLE_GATT_TIMEOUT_SRC_PROTOCOL      0x00  &bsol;**< ATT Protocol timeout. */
18  #define BLE_GATT_OP_INVALID                0x00  &bsol;**< Invalid Operation. */
19  #define BLE_GATT_OP_WRITE_REQ              0x01  &bsol;**< Write Request. */
20  #define BLE_GATT_OP_WRITE_CMD              0x02  &bsol;**< Write Command. */
21  #define BLE_GATT_OP_SIGN_WRITE_CMD         0x03  &bsol;**< Signed Write Command. */
22  #define BLE_GATT_OP_PREP_WRITE_REQ         0x04  &bsol;**< Prepare Write Request. */
23  #define BLE_GATT_OP_EXEC_WRITE_REQ         0x05  &bsol;**< Execute Write Request. */
24  #define BLE_GATT_EXEC_WRITE_FLAG_PREPARED_CANCEL 0x00   &bsol;**< Cancel prepared write. */
25  #define BLE_GATT_EXEC_WRITE_FLAG_PREPARED_WRITE  0x01   &bsol;**< Execute prepared write. */
26  #define BLE_GATT_HVX_INVALID               0x00  &bsol;**< Invalid Operation. */
27  #define BLE_GATT_HVX_NOTIFICATION          0x01  &bsol;**< Handle Value Notification. */
28  #define BLE_GATT_HVX_INDICATION            0x02  &bsol;**< Handle Value Indication. */
29  #define BLE_GATT_STATUS_SUCCESS                           0x0000  &bsol;**< Success. */
30  #define BLE_GATT_STATUS_UNKNOWN                           0x0001  &bsol;**< Unknown or not applicable status. */
31  #define BLE_GATT_STATUS_ATTERR_INVALID                    0x0100  &bsol;**< ATT Error: Invalid Error Code. */
32  #define BLE_GATT_STATUS_ATTERR_INVALID_HANDLE             0x0101  &bsol;**< ATT Error: Invalid Attribute Handle. */
33  #define BLE_GATT_STATUS_ATTERR_READ_NOT_PERMITTED         0x0102  &bsol;**< ATT Error: Read not permitted. */
34  #define BLE_GATT_STATUS_ATTERR_WRITE_NOT_PERMITTED        0x0103  &bsol;**< ATT Error: Write not permitted. */
35  #define BLE_GATT_STATUS_ATTERR_INVALID_PDU                0x0104  &bsol;**< ATT Error: Used in ATT as Invalid PDU. */
36  #define BLE_GATT_STATUS_ATTERR_INSUF_AUTHENTICATION       0x0105  &bsol;**< ATT Error: Authenticated link required. */
37  #define BLE_GATT_STATUS_ATTERR_REQUEST_NOT_SUPPORTED      0x0106  &bsol;**< ATT Error: Used in ATT as Request Not Supported. */
38  #define BLE_GATT_STATUS_ATTERR_INVALID_OFFSET             0x0107  &bsol;**< ATT Error: Offset specified was past the end of the attribute. */
39  #define BLE_GATT_STATUS_ATTERR_INSUF_AUTHORIZATION        0x0108  &bsol;**< ATT Error: Used in ATT as Insufficient Authorization. */
40  #define BLE_GATT_STATUS_ATTERR_PREPARE_QUEUE_FULL         0x0109  &bsol;**< ATT Error: Used in ATT as Prepare Queue Full. */
41  #define BLE_GATT_STATUS_ATTERR_ATTRIBUTE_NOT_FOUND        0x010A  &bsol;**< ATT Error: Used in ATT as Attribute not found. */
42  #define BLE_GATT_STATUS_ATTERR_ATTRIBUTE_NOT_LONG         0x010B  &bsol;**< ATT Error: Attribute cannot be read or written using read/write blob requests. */
43  #define BLE_GATT_STATUS_ATTERR_INSUF_ENC_KEY_SIZE         0x010C  &bsol;**< ATT Error: Encryption key size used is insufficient. */
44  #define BLE_GATT_STATUS_ATTERR_INVALID_ATT_VAL_LENGTH     0x010D  &bsol;**< ATT Error: Invalid value size. */
45  #define BLE_GATT_STATUS_ATTERR_UNLIKELY_ERROR             0x010E  &bsol;**< ATT Error: Very unlikely error. */
46  #define BLE_GATT_STATUS_ATTERR_INSUF_ENCRYPTION           0x010F  &bsol;**< ATT Error: Encrypted link required. */
47  #define BLE_GATT_STATUS_ATTERR_UNSUPPORTED_GROUP_TYPE     0x0110  &bsol;**< ATT Error: Attribute type is not a supported grouping attribute. */
48  #define BLE_GATT_STATUS_ATTERR_INSUF_RESOURCES            0x0111  &bsol;**< ATT Error: Encrypted link required. */
49  #define BLE_GATT_STATUS_ATTERR_RFU_RANGE1_BEGIN           0x0112  &bsol;**< ATT Error: Reserved for Future Use range #1 begin. */
50  #define BLE_GATT_STATUS_ATTERR_RFU_RANGE1_END             0x017F  &bsol;**< ATT Error: Reserved for Future Use range #1 end. */
51  #define BLE_GATT_STATUS_ATTERR_APP_BEGIN                  0x0180  &bsol;**< ATT Error: Application range begin. */
52  #define BLE_GATT_STATUS_ATTERR_APP_END                    0x019F  &bsol;**< ATT Error: Application range end. */
53  #define BLE_GATT_STATUS_ATTERR_RFU_RANGE2_BEGIN           0x01A0  &bsol;**< ATT Error: Reserved for Future Use range #2 begin. */
54  #define BLE_GATT_STATUS_ATTERR_RFU_RANGE2_END             0x01DF  &bsol;**< ATT Error: Reserved for Future Use range #2 end. */
55  #define BLE_GATT_STATUS_ATTERR_RFU_RANGE3_BEGIN           0x01E0  &bsol;**< ATT Error: Reserved for Future Use range #3 begin. */
56  #define BLE_GATT_STATUS_ATTERR_RFU_RANGE3_END             0x01FC  &bsol;**< ATT Error: Reserved for Future Use range #3 end. */
57  #define BLE_GATT_STATUS_ATTERR_CPS_WRITE_REQ_REJECTED     0x01FC  &bsol;**< ATT Common Profile and Service Error: Write request rejected. */
58  #define BLE_GATT_STATUS_ATTERR_CPS_CCCD_CONFIG_ERROR      0x01FD  &bsol;**< ATT Common Profile and Service Error: Client Characteristic Configuration Descriptor improperly configured. */
59  #define BLE_GATT_STATUS_ATTERR_CPS_PROC_ALR_IN_PROG       0x01FE  &bsol;**< ATT Common Profile and Service Error: Procedure Already in Progress. */
60  #define BLE_GATT_STATUS_ATTERR_CPS_OUT_OF_RANGE           0x01FF  &bsol;**< ATT Common Profile and Service Error: Out Of Range. */
61  #define BLE_GATT_CPF_FORMAT_RFU                 0x00 &bsol;**< Reserved For Future Use. */
62  #define BLE_GATT_CPF_FORMAT_BOOLEAN             0x01 &bsol;**< Boolean. */
63  #define BLE_GATT_CPF_FORMAT_2BIT                0x02 &bsol;**< Unsigned 2-bit integer. */
64  #define BLE_GATT_CPF_FORMAT_NIBBLE              0x03 &bsol;**< Unsigned 4-bit integer. */
65  #define BLE_GATT_CPF_FORMAT_UINT8               0x04 &bsol;**< Unsigned 8-bit integer. */
66  #define BLE_GATT_CPF_FORMAT_UINT12              0x05 &bsol;**< Unsigned 12-bit integer. */
67  #define BLE_GATT_CPF_FORMAT_UINT16              0x06 &bsol;**< Unsigned 16-bit integer. */
68  #define BLE_GATT_CPF_FORMAT_UINT24              0x07 &bsol;**< Unsigned 24-bit integer. */
69  #define BLE_GATT_CPF_FORMAT_UINT32              0x08 &bsol;**< Unsigned 32-bit integer. */
70  #define BLE_GATT_CPF_FORMAT_UINT48              0x09 &bsol;**< Unsigned 48-bit integer. */
71  #define BLE_GATT_CPF_FORMAT_UINT64              0x0A &bsol;**< Unsigned 64-bit integer. */
72  #define BLE_GATT_CPF_FORMAT_UINT128             0x0B &bsol;**< Unsigned 128-bit integer. */
73  #define BLE_GATT_CPF_FORMAT_SINT8               0x0C &bsol;**< Signed 2-bit integer. */
74  #define BLE_GATT_CPF_FORMAT_SINT12              0x0D &bsol;**< Signed 12-bit integer. */
75  #define BLE_GATT_CPF_FORMAT_SINT16              0x0E &bsol;**< Signed 16-bit integer. */
76  #define BLE_GATT_CPF_FORMAT_SINT24              0x0F &bsol;**< Signed 24-bit integer. */
77  #define BLE_GATT_CPF_FORMAT_SINT32              0x10 &bsol;**< Signed 32-bit integer. */
78  #define BLE_GATT_CPF_FORMAT_SINT48              0x11 &bsol;**< Signed 48-bit integer. */
79  #define BLE_GATT_CPF_FORMAT_SINT64              0x12 &bsol;**< Signed 64-bit integer. */
80  #define BLE_GATT_CPF_FORMAT_SINT128             0x13 &bsol;**< Signed 128-bit integer. */
81  #define BLE_GATT_CPF_FORMAT_FLOAT32             0x14 &bsol;**< IEEE-754 32-bit floating point. */
82  #define BLE_GATT_CPF_FORMAT_FLOAT64             0x15 &bsol;**< IEEE-754 64-bit floating point. */
83  #define BLE_GATT_CPF_FORMAT_SFLOAT              0x16 &bsol;**< IEEE-11073 16-bit SFLOAT. */
84  #define BLE_GATT_CPF_FORMAT_FLOAT               0x17 &bsol;**< IEEE-11073 32-bit FLOAT. */
85  #define BLE_GATT_CPF_FORMAT_DUINT16             0x18 &bsol;**< IEEE-20601 format. */
86  #define BLE_GATT_CPF_FORMAT_UTF8S               0x19 &bsol;**< UTF-8 string. */
87  #define BLE_GATT_CPF_FORMAT_UTF16S              0x1A &bsol;**< UTF-16 string. */
88  #define BLE_GATT_CPF_FORMAT_STRUCT              0x1B &bsol;**< Opaque Structure. */
89  #define BLE_GATT_CPF_NAMESPACE_BTSIG            0x01 &bsol;**< Bluetooth SIG defined Namespace. */
90  #define BLE_GATT_CPF_NAMESPACE_DESCRIPTION_UNKNOWN 0x0000 &bsol;**< Namespace Description Unknown. */
91  typedef struct
92  {
93    uint16_t  att_mtu;          &bsol;**< Maximum size of ATT packet the SoftDevice can send or receive.
94                                     The default and minimum value is @ref BLE_GATT_ATT_MTU_DEFAULT.
95                                     @mscs
96                                     @mmsc{@ref BLE_GATTC_MTU_EXCHANGE}
97                                     @mmsc{@ref BLE_GATTS_MTU_EXCHANGE}
98                                     @endmscs
99                                */
100  } ble_gatt_conn_cfg_t;
101  typedef struct
102  {
103    uint8_t broadcast       :1; &bsol;**< Broadcasting of the value permitted. */
104    uint8_t read            :1; &bsol;**< Reading the value permitted. */
105    uint8_t write_wo_resp   :1; &bsol;**< Writing the value with Write Command permitted. */
106    uint8_t write           :1; &bsol;**< Writing the value with Write Request permitted. */
<span onclick='openModal()' class='match'>107    uint8_t notify          :1; &bsol;**< Notification of the value permitted. */
108    uint8_t indicate        :1; &bsol;**< Indications of the value permitted. */
</span>109    uint8_t auth_signed_wr  :1; &bsol;**< Writing the value with Signed Write Command permitted. */
110  } ble_gatt_char_props_t;
111  typedef struct
112  {
113    uint8_t reliable_wr     :1; &bsol;**< Writing the value with Queued Write operations permitted. */
114    uint8_t wr_aux          :1; &bsol;**< Writing the Characteristic User Description descriptor permitted. */
115  } ble_gatt_char_ext_props_t;
116  #ifdef __cplusplus
117  }
118  #endif
119  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-ble_gap.h</h3>
            <pre><code>1  #ifndef BLE_GAP_H__
2  #define BLE_GAP_H__
3  #include <stdint.h>
4  #include "nrf_svc.h"
5  #include "nrf_error.h"
6  #include "ble_hci.h"
7  #include "ble_ranges.h"
8  #include "ble_types.h"
9  #include "ble_err.h"
10  #ifdef __cplusplus
11  extern "C" {
12  #endif
13  enum BLE_GAP_SVCS
14  {
15    SD_BLE_GAP_ADDR_SET              = BLE_GAP_SVC_BASE,       &bsol;**< Set own Bluetooth Address. */
16    SD_BLE_GAP_ADDR_GET              = BLE_GAP_SVC_BASE + 1,   &bsol;**< Get own Bluetooth Address. */
17    SD_BLE_GAP_WHITELIST_SET         = BLE_GAP_SVC_BASE + 2,   &bsol;**< Set active whitelist. */
18    SD_BLE_GAP_DEVICE_IDENTITIES_SET = BLE_GAP_SVC_BASE + 3,   &bsol;**< Set device identity list. */
19    SD_BLE_GAP_PRIVACY_SET           = BLE_GAP_SVC_BASE + 4,   &bsol;**< Set Privacy settings*/
20    SD_BLE_GAP_PRIVACY_GET           = BLE_GAP_SVC_BASE + 5,   &bsol;**< Get Privacy settings*/
21    SD_BLE_GAP_ADV_SET_CONFIGURE     = BLE_GAP_SVC_BASE + 6,   &bsol;**< Configure an advertising set. */
22    SD_BLE_GAP_ADV_START             = BLE_GAP_SVC_BASE + 7,   &bsol;**< Start Advertising. */
23    SD_BLE_GAP_ADV_STOP              = BLE_GAP_SVC_BASE + 8,   &bsol;**< Stop Advertising. */
24    SD_BLE_GAP_CONN_PARAM_UPDATE     = BLE_GAP_SVC_BASE + 9,   &bsol;**< Connection Parameter Update. */
25    SD_BLE_GAP_DISCONNECT            = BLE_GAP_SVC_BASE + 10,  &bsol;**< Disconnect. */
26    SD_BLE_GAP_TX_POWER_SET          = BLE_GAP_SVC_BASE + 11,  &bsol;**< Set TX Power. */
27    SD_BLE_GAP_APPEARANCE_SET        = BLE_GAP_SVC_BASE + 12,  &bsol;**< Set Appearance. */
28    SD_BLE_GAP_APPEARANCE_GET        = BLE_GAP_SVC_BASE + 13,  &bsol;**< Get Appearance. */
29    SD_BLE_GAP_PPCP_SET              = BLE_GAP_SVC_BASE + 14,  &bsol;**< Set PPCP. */
30    SD_BLE_GAP_PPCP_GET              = BLE_GAP_SVC_BASE + 15,  &bsol;**< Get PPCP. */
31    SD_BLE_GAP_DEVICE_NAME_SET       = BLE_GAP_SVC_BASE + 16,  &bsol;**< Set Device Name. */
32    SD_BLE_GAP_DEVICE_NAME_GET       = BLE_GAP_SVC_BASE + 17,  &bsol;**< Get Device Name. */
33    SD_BLE_GAP_AUTHENTICATE          = BLE_GAP_SVC_BASE + 18,  &bsol;**< Initiate Pairing/Bonding. */
34    SD_BLE_GAP_SEC_PARAMS_REPLY      = BLE_GAP_SVC_BASE + 19,  &bsol;**< Reply with Security Parameters. */
35    SD_BLE_GAP_AUTH_KEY_REPLY        = BLE_GAP_SVC_BASE + 20,  &bsol;**< Reply with an authentication key. */
36    SD_BLE_GAP_LESC_DHKEY_REPLY      = BLE_GAP_SVC_BASE + 21,  &bsol;**< Reply with an LE Secure Connections DHKey. */
37    SD_BLE_GAP_KEYPRESS_NOTIFY       = BLE_GAP_SVC_BASE + 22,  &bsol;**< Notify of a keypress during an authentication procedure. */
38    SD_BLE_GAP_LESC_OOB_DATA_GET     = BLE_GAP_SVC_BASE + 23,  &bsol;**< Get the local LE Secure Connections OOB data. */
39    SD_BLE_GAP_LESC_OOB_DATA_SET     = BLE_GAP_SVC_BASE + 24,  &bsol;**< Set the remote LE Secure Connections OOB data. */
40    SD_BLE_GAP_ENCRYPT               = BLE_GAP_SVC_BASE + 25,  &bsol;**< Initiate encryption procedure. */
41    SD_BLE_GAP_SEC_INFO_REPLY        = BLE_GAP_SVC_BASE + 26,  &bsol;**< Reply with Security Information. */
42    SD_BLE_GAP_CONN_SEC_GET          = BLE_GAP_SVC_BASE + 27,  &bsol;**< Obtain connection security level. */
43    SD_BLE_GAP_RSSI_START            = BLE_GAP_SVC_BASE + 28,  &bsol;**< Start reporting of changes in RSSI. */
44    SD_BLE_GAP_RSSI_STOP             = BLE_GAP_SVC_BASE + 29,  &bsol;**< Stop reporting of changes in RSSI. */
45    SD_BLE_GAP_SCAN_START            = BLE_GAP_SVC_BASE + 30,  &bsol;**< Start Scanning. */
46    SD_BLE_GAP_SCAN_STOP             = BLE_GAP_SVC_BASE + 31,  &bsol;**< Stop Scanning. */
47    SD_BLE_GAP_CONNECT               = BLE_GAP_SVC_BASE + 32,  &bsol;**< Connect. */
48    SD_BLE_GAP_CONNECT_CANCEL        = BLE_GAP_SVC_BASE + 33,  &bsol;**< Cancel ongoing connection procedure. */
49    SD_BLE_GAP_RSSI_GET              = BLE_GAP_SVC_BASE + 34,  &bsol;**< Get the last RSSI sample. */
50    SD_BLE_GAP_PHY_UPDATE            = BLE_GAP_SVC_BASE + 35,  &bsol;**< Initiate or respond to a PHY Update Procedure. */
51    SD_BLE_GAP_DATA_LENGTH_UPDATE    = BLE_GAP_SVC_BASE + 36,  &bsol;**< Initiate or respond to a Data Length Update Procedure. */
52    SD_BLE_GAP_QOS_CHANNEL_SURVEY_START  = BLE_GAP_SVC_BASE + 37, &bsol;**< Start Quality of Service (QoS) channel survey module. */
53    SD_BLE_GAP_QOS_CHANNEL_SURVEY_STOP   = BLE_GAP_SVC_BASE + 38, &bsol;**< Stop Quality of Service (QoS) channel survey module. */
54    SD_BLE_GAP_ADV_ADDR_GET          = BLE_GAP_SVC_BASE + 39, &bsol;**< Get the Address used on air while Advertising. */
55  };
56  enum BLE_GAP_EVTS
57  {
58    BLE_GAP_EVT_CONNECTED                   = BLE_GAP_EVT_BASE,       &bsol;**< Connected to peer.                              \n See @ref ble_gap_evt_connected_t             */
59    BLE_GAP_EVT_DISCONNECTED                = BLE_GAP_EVT_BASE + 1,   &bsol;**< Disconnected from peer.                         \n See @ref ble_gap_evt_disconnected_t.         */
60    BLE_GAP_EVT_CONN_PARAM_UPDATE           = BLE_GAP_EVT_BASE + 2,   &bsol;**< Connection Parameters updated.                  \n See @ref ble_gap_evt_conn_param_update_t.    */
61    BLE_GAP_EVT_SEC_PARAMS_REQUEST          = BLE_GAP_EVT_BASE + 3,   &bsol;**< Request to provide security parameters.         \n Reply with @ref sd_ble_gap_sec_params_reply.  \n See @ref ble_gap_evt_sec_params_request_t. */
62    BLE_GAP_EVT_SEC_INFO_REQUEST            = BLE_GAP_EVT_BASE + 4,   &bsol;**< Request to provide security information.        \n Reply with @ref sd_ble_gap_sec_info_reply.    \n See @ref ble_gap_evt_sec_info_request_t.   */
63    BLE_GAP_EVT_PASSKEY_DISPLAY             = BLE_GAP_EVT_BASE + 5,   &bsol;**< Request to display a passkey to the user.       \n In LESC Numeric Comparison, reply with @ref sd_ble_gap_auth_key_reply. \n See @ref ble_gap_evt_passkey_display_t. */
64    BLE_GAP_EVT_KEY_PRESSED                 = BLE_GAP_EVT_BASE + 6,   &bsol;**< Notification of a keypress on the remote device.\n See @ref ble_gap_evt_key_pressed_t           */
65    BLE_GAP_EVT_AUTH_KEY_REQUEST            = BLE_GAP_EVT_BASE + 7,   &bsol;**< Request to provide an authentication key.       \n Reply with @ref sd_ble_gap_auth_key_reply.    \n See @ref ble_gap_evt_auth_key_request_t.   */
66    BLE_GAP_EVT_LESC_DHKEY_REQUEST          = BLE_GAP_EVT_BASE + 8,   &bsol;**< Request to calculate an LE Secure Connections DHKey. \n Reply with @ref sd_ble_gap_lesc_dhkey_reply.  \n See @ref ble_gap_evt_lesc_dhkey_request_t */
67    BLE_GAP_EVT_AUTH_STATUS                 = BLE_GAP_EVT_BASE + 9,   &bsol;**< Authentication procedure completed with status. \n See @ref ble_gap_evt_auth_status_t.          */
68    BLE_GAP_EVT_CONN_SEC_UPDATE             = BLE_GAP_EVT_BASE + 10,  &bsol;**< Connection security updated.                    \n See @ref ble_gap_evt_conn_sec_update_t.      */
69    BLE_GAP_EVT_TIMEOUT                     = BLE_GAP_EVT_BASE + 11,  &bsol;**< Timeout expired.                                \n See @ref ble_gap_evt_timeout_t.              */
70    BLE_GAP_EVT_RSSI_CHANGED                = BLE_GAP_EVT_BASE + 12,  &bsol;**< RSSI report.                                    \n See @ref ble_gap_evt_rssi_changed_t.         */
71    BLE_GAP_EVT_ADV_REPORT                  = BLE_GAP_EVT_BASE + 13,  &bsol;**< Advertising report.                             \n See @ref ble_gap_evt_adv_report_t.           */
72    BLE_GAP_EVT_SEC_REQUEST                 = BLE_GAP_EVT_BASE + 14,  &bsol;**< Security Request.                               \n See @ref ble_gap_evt_sec_request_t.          */
73    BLE_GAP_EVT_CONN_PARAM_UPDATE_REQUEST   = BLE_GAP_EVT_BASE + 15,  &bsol;**< Connection Parameter Update Request.            \n Reply with @ref sd_ble_gap_conn_param_update. \n See @ref ble_gap_evt_conn_param_update_request_t. */
74    BLE_GAP_EVT_SCAN_REQ_REPORT             = BLE_GAP_EVT_BASE + 16,  &bsol;**< Scan request report.                            \n See @ref ble_gap_evt_scan_req_report_t. */
75    BLE_GAP_EVT_PHY_UPDATE_REQUEST          = BLE_GAP_EVT_BASE + 17,  &bsol;**< PHY Update Request.                             \n Reply with @ref sd_ble_gap_phy_update. \n See @ref ble_gap_evt_phy_update_request_t. */
76    BLE_GAP_EVT_PHY_UPDATE                  = BLE_GAP_EVT_BASE + 18,  &bsol;**< PHY Update Procedure is complete.               \n See @ref ble_gap_evt_phy_update_t.           */
77    BLE_GAP_EVT_DATA_LENGTH_UPDATE_REQUEST = BLE_GAP_EVT_BASE + 19,   &bsol;**< Data Length Update Request.                     \n Reply with @ref sd_ble_gap_data_length_update.\n See @ref ble_gap_evt_data_length_update_request_t. */
78    BLE_GAP_EVT_DATA_LENGTH_UPDATE         = BLE_GAP_EVT_BASE + 20,   &bsol;**< LL Data Channel PDU payload length updated.     \n See @ref ble_gap_evt_data_length_update_t. */
79    BLE_GAP_EVT_QOS_CHANNEL_SURVEY_REPORT  = BLE_GAP_EVT_BASE + 21,   &bsol;**< Channel survey report.                          \n See @ref ble_gap_evt_qos_channel_survey_report_t. */
80    BLE_GAP_EVT_ADV_SET_TERMINATED         = BLE_GAP_EVT_BASE + 22,   &bsol;**< Advertising set terminated.                     \n See @ref ble_gap_evt_adv_set_terminated_t. */
81  };
82  enum BLE_GAP_OPTS
83  {
84    BLE_GAP_OPT_CH_MAP                 = BLE_GAP_OPT_BASE,       &bsol;**< Channel Map. @ref ble_gap_opt_ch_map_t  */
85    BLE_GAP_OPT_LOCAL_CONN_LATENCY     = BLE_GAP_OPT_BASE + 1,   &bsol;**< Local connection latency. @ref ble_gap_opt_local_conn_latency_t */
86    BLE_GAP_OPT_PASSKEY                = BLE_GAP_OPT_BASE + 2,   &bsol;**< Set passkey. @ref ble_gap_opt_passkey_t */
87    BLE_GAP_OPT_COMPAT_MODE_1          = BLE_GAP_OPT_BASE + 3,   &bsol;**< Compatibility mode. @ref ble_gap_opt_compat_mode_1_t */
88    BLE_GAP_OPT_AUTH_PAYLOAD_TIMEOUT   = BLE_GAP_OPT_BASE + 4,   &bsol;**< Set Authenticated payload timeout. @ref ble_gap_opt_auth_payload_timeout_t */
89    BLE_GAP_OPT_SLAVE_LATENCY_DISABLE  = BLE_GAP_OPT_BASE + 5,   &bsol;**< Disable slave latency. @ref ble_gap_opt_slave_latency_disable_t */
90  };
91  enum BLE_GAP_CFGS
92  {
93    BLE_GAP_CFG_ROLE_COUNT    = BLE_GAP_CFG_BASE,     &bsol;**< Role count configuration.  */
94    BLE_GAP_CFG_DEVICE_NAME   = BLE_GAP_CFG_BASE + 1, &bsol;**< Device name configuration. */
95  };
96  enum BLE_GAP_TX_POWER_ROLES
97  {
98    BLE_GAP_TX_POWER_ROLE_ADV       = 1,           &bsol;**< Advertiser role. */
99    BLE_GAP_TX_POWER_ROLE_SCAN_INIT = 2,           &bsol;**< Scanner and initiator role. */
100    BLE_GAP_TX_POWER_ROLE_CONN      = 3,           &bsol;**< Connection role. */
101  };
102  #define BLE_ERROR_GAP_UUID_LIST_MISMATCH            (NRF_GAP_ERR_BASE + 0x000)  &bsol;**< UUID list does not contain an integral number of UUIDs. */
103  #define BLE_ERROR_GAP_DISCOVERABLE_WITH_WHITELIST   (NRF_GAP_ERR_BASE + 0x001)  &bsol;**< Use of Whitelist not permitted with discoverable advertising. */
104  #define BLE_ERROR_GAP_INVALID_BLE_ADDR              (NRF_GAP_ERR_BASE + 0x002)  &bsol;**< The upper two bits of the address do not correspond to the specified address type. */
105  #define BLE_ERROR_GAP_WHITELIST_IN_USE              (NRF_GAP_ERR_BASE + 0x003)  &bsol;**< Attempt to modify the whitelist while already in use by another operation. */
106  #define BLE_ERROR_GAP_DEVICE_IDENTITIES_IN_USE      (NRF_GAP_ERR_BASE + 0x004)  &bsol;**< Attempt to modify the device identity list while already in use by another operation. */
107  #define BLE_ERROR_GAP_DEVICE_IDENTITIES_DUPLICATE   (NRF_GAP_ERR_BASE + 0x005)  &bsol;**< The device identity list contains entries with duplicate identity addresses. */
108  #define BLE_GAP_ROLE_INVALID     0x0            &bsol;**< Invalid Role. */
109  #define BLE_GAP_ROLE_PERIPH      0x1            &bsol;**< Peripheral Role. */
110  #define BLE_GAP_ROLE_CENTRAL     0x2            &bsol;**< Central Role. */
111  #define BLE_GAP_TIMEOUT_SRC_SCAN                       0x01 &bsol;**< Scanning timeout. */
112  #define BLE_GAP_TIMEOUT_SRC_CONN                       0x02 &bsol;**< Connection timeout. */
113  #define BLE_GAP_TIMEOUT_SRC_AUTH_PAYLOAD               0x03 &bsol;**< Authenticated payload timeout. */
114  #define BLE_GAP_ADDR_TYPE_PUBLIC                        0x00 &bsol;**< Public (identity) address.*/
115  #define BLE_GAP_ADDR_TYPE_RANDOM_STATIC                 0x01 &bsol;**< Random static (identity) address. */
116  #define BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE     0x02 &bsol;**< Random private resolvable address. */
117  #define BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE 0x03 &bsol;**< Random private non-resolvable address. */
118  #define BLE_GAP_ADDR_TYPE_ANONYMOUS                     0x7F &bsol;**< An advertiser may advertise without its address.
119                                                                    This type of advertising is called anonymous. */
120  #define BLE_GAP_DEFAULT_PRIVATE_ADDR_CYCLE_INTERVAL_S (900) &bsol;* 15 minutes. */
121  #define BLE_GAP_MAX_PRIVATE_ADDR_CYCLE_INTERVAL_S     (41400) &bsol;* 11 hours 30 minutes. */
122  #define BLE_GAP_ADDR_LEN (6)
123  #define BLE_GAP_PRIVACY_MODE_OFF                       0x00 &bsol;**< Device will send and accept its identity address for its own address. */
124  #define BLE_GAP_PRIVACY_MODE_DEVICE_PRIVACY            0x01 &bsol;**< Device will send and accept only private addresses for its own address. */
125  #define BLE_GAP_PRIVACY_MODE_NETWORK_PRIVACY           0x02 &bsol;**< Device will send and accept only private addresses for its own address,
126                                                                   and will not accept a peer using identity address as sender address when
127                                                                   the peer IRK is exchanged, non-zero and added to the identity list. */
128  #define BLE_GAP_POWER_LEVEL_INVALID     127
129  #define BLE_GAP_ADV_SET_HANDLE_NOT_SET (0xFF)
130  #define BLE_GAP_ADV_SET_COUNT_DEFAULT   (1)
131  #define BLE_GAP_ADV_SET_COUNT_MAX       (1)
132  #define BLE_GAP_ADV_SET_DATA_SIZE_MAX                    (31)   &bsol;**< Maximum data length for an advertising set.
133                                                                       If more advertising data is required, use extended advertising instead. */
134  #define BLE_GAP_ADV_SET_DATA_SIZE_EXTENDED_MAX_SUPPORTED (255)  &bsol;**< Maximum supported data length for an extended advertising set. */
135  #define BLE_GAP_ADV_SET_DATA_SIZE_EXTENDED_CONNECTABLE_MAX_SUPPORTED (238) &bsol;**< Maximum supported data length for an extended connectable advertising set. */
136  #define BLE_GAP_ADV_REPORT_SET_ID_NOT_AVAILABLE                    0xFF
137  #define BLE_GAP_EVT_ADV_SET_TERMINATED_REASON_TIMEOUT              0x01  &bsol;**< Timeout value reached. */
138  #define BLE_GAP_EVT_ADV_SET_TERMINATED_REASON_LIMIT_REACHED        0x02  &bsol;**< @ref ble_gap_adv_params_t::max_adv_evts was reached. */
139  #define BLE_GAP_AD_TYPE_FLAGS                               0x01 &bsol;**< Flags for discoverability. */
140  #define BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_MORE_AVAILABLE   0x02 &bsol;**< Partial list of 16 bit service UUIDs. */
141  #define BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE         0x03 &bsol;**< Complete list of 16 bit service UUIDs. */
142  #define BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_MORE_AVAILABLE   0x04 &bsol;**< Partial list of 32 bit service UUIDs. */
143  #define BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_COMPLETE         0x05 &bsol;**< Complete list of 32 bit service UUIDs. */
144  #define BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_MORE_AVAILABLE  0x06 &bsol;**< Partial list of 128 bit service UUIDs. */
145  #define BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_COMPLETE        0x07 &bsol;**< Complete list of 128 bit service UUIDs. */
146  #define BLE_GAP_AD_TYPE_SHORT_LOCAL_NAME                    0x08 &bsol;**< Short local device name. */
147  #define BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME                 0x09 &bsol;**< Complete local device name. */
148  #define BLE_GAP_AD_TYPE_TX_POWER_LEVEL                      0x0A &bsol;**< Transmit power level. */
149  #define BLE_GAP_AD_TYPE_CLASS_OF_DEVICE                     0x0D &bsol;**< Class of device. */
150  #define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_HASH_C               0x0E &bsol;**< Simple Pairing Hash C. */
151  #define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_RANDOMIZER_R         0x0F &bsol;**< Simple Pairing Randomizer R. */
152  #define BLE_GAP_AD_TYPE_SECURITY_MANAGER_TK_VALUE           0x10 &bsol;**< Security Manager TK Value. */
153  #define BLE_GAP_AD_TYPE_SECURITY_MANAGER_OOB_FLAGS          0x11 &bsol;**< Security Manager Out Of Band Flags. */
154  #define BLE_GAP_AD_TYPE_SLAVE_CONNECTION_INTERVAL_RANGE     0x12 &bsol;**< Slave Connection Interval Range. */
155  #define BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_16BIT       0x14 &bsol;**< List of 16-bit Service Solicitation UUIDs. */
156  #define BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_128BIT      0x15 &bsol;**< List of 128-bit Service Solicitation UUIDs. */
157  #define BLE_GAP_AD_TYPE_SERVICE_DATA                        0x16 &bsol;**< Service Data - 16-bit UUID. */
158  #define BLE_GAP_AD_TYPE_PUBLIC_TARGET_ADDRESS               0x17 &bsol;**< Public Target Address. */
159  #define BLE_GAP_AD_TYPE_RANDOM_TARGET_ADDRESS               0x18 &bsol;**< Random Target Address. */
160  #define BLE_GAP_AD_TYPE_APPEARANCE                          0x19 &bsol;**< Appearance. */
161  #define BLE_GAP_AD_TYPE_ADVERTISING_INTERVAL                0x1A &bsol;**< Advertising Interval. */
162  #define BLE_GAP_AD_TYPE_LE_BLUETOOTH_DEVICE_ADDRESS         0x1B &bsol;**< LE Bluetooth Device Address. */
163  #define BLE_GAP_AD_TYPE_LE_ROLE                             0x1C &bsol;**< LE Role. */
164  #define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_HASH_C256            0x1D &bsol;**< Simple Pairing Hash C-256. */
165  #define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_RANDOMIZER_R256      0x1E &bsol;**< Simple Pairing Randomizer R-256. */
166  #define BLE_GAP_AD_TYPE_SERVICE_DATA_32BIT_UUID             0x20 &bsol;**< Service Data - 32-bit UUID. */
167  #define BLE_GAP_AD_TYPE_SERVICE_DATA_128BIT_UUID            0x21 &bsol;**< Service Data - 128-bit UUID. */
168  #define BLE_GAP_AD_TYPE_LESC_CONFIRMATION_VALUE             0x22 &bsol;**< LE Secure Connections Confirmation Value */
169  #define BLE_GAP_AD_TYPE_LESC_RANDOM_VALUE                   0x23 &bsol;**< LE Secure Connections Random Value */
170  #define BLE_GAP_AD_TYPE_URI                                 0x24 &bsol;**< URI */
171  #define BLE_GAP_AD_TYPE_3D_INFORMATION_DATA                 0x3D &bsol;**< 3D Information Data. */
172  #define BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA          0xFF &bsol;**< Manufacturer Specific Data. */
173  #define BLE_GAP_ADV_FLAG_LE_LIMITED_DISC_MODE         (0x01)   &bsol;**< LE Limited Discoverable Mode. */
174  #define BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE         (0x02)   &bsol;**< LE General Discoverable Mode. */
175  #define BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED         (0x04)   &bsol;**< BR/EDR not supported. */
176  #define BLE_GAP_ADV_FLAG_LE_BR_EDR_CONTROLLER         (0x08)   &bsol;**< Simultaneous LE and BR/EDR, Controller. */
177  #define BLE_GAP_ADV_FLAG_LE_BR_EDR_HOST               (0x10)   &bsol;**< Simultaneous LE and BR/EDR, Host. */
178  #define BLE_GAP_ADV_FLAGS_LE_ONLY_LIMITED_DISC_MODE   (BLE_GAP_ADV_FLAG_LE_LIMITED_DISC_MODE | BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED)   &bsol;**< LE Limited Discoverable Mode, BR/EDR not supported. */
179  #define BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE   (BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE | BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED)   &bsol;**< LE General Discoverable Mode, BR/EDR not supported. */
180  #define BLE_GAP_ADV_INTERVAL_MIN        0x000020 &bsol;**< Minimum Advertising interval in 625 us units, i.e. 20 ms. */
181  #define BLE_GAP_ADV_INTERVAL_MAX        0x004000 &bsol;**< Maximum Advertising interval in 625 us units, i.e. 10.24 s. */
182  #define BLE_GAP_SCAN_INTERVAL_MIN       0x0004 &bsol;**< Minimum Scan interval in 625 us units, i.e. 2.5 ms. */
183  #define BLE_GAP_SCAN_INTERVAL_MAX       0xFFFF &bsol;**< Maximum Scan interval in 625 us units, i.e. 40,959.375 s. */
184  #define BLE_GAP_SCAN_WINDOW_MIN         0x0004 &bsol;**< Minimum Scan window in 625 us units, i.e. 2.5 ms. */
185  #define BLE_GAP_SCAN_WINDOW_MAX         0xFFFF &bsol;**< Maximum Scan window in 625 us units, i.e. 40,959.375 s. */
186  #define BLE_GAP_SCAN_TIMEOUT_MIN        0x0001 &bsol;**< Minimum Scan timeout in 10 ms units, i.e 10 ms. */
187  #define BLE_GAP_SCAN_TIMEOUT_UNLIMITED  0x0000 &bsol;**< Continue to scan forever. */
188  #define BLE_GAP_SCAN_BUFFER_MIN                    (31)                             &bsol;**< Minimum data length for an
189                                                                                           advertising set. */
190  #define BLE_GAP_SCAN_BUFFER_MAX                    (31)                             &bsol;**< Maximum data length for an
191                                                                                           advertising set. */
192  #define BLE_GAP_SCAN_BUFFER_EXTENDED_MIN           (255)                            &bsol;**< Minimum data length for an
193                                                                                           extended advertising set. */
194  #define BLE_GAP_SCAN_BUFFER_EXTENDED_MAX           (1650)                           &bsol;**< Maximum data length for an
195                                                                                           extended advertising set. */
196  #define BLE_GAP_SCAN_BUFFER_EXTENDED_MAX_SUPPORTED (255)                            &bsol;**< Maximum supported data length for
197                                                                                           an extended advertising set. */
198  #define BLE_GAP_ADV_TYPE_CONNECTABLE_SCANNABLE_UNDIRECTED                   0x01   &bsol;**< Connectable and scannable undirected
199                                                                                          advertising events. */
200  #define BLE_GAP_ADV_TYPE_CONNECTABLE_NONSCANNABLE_DIRECTED_HIGH_DUTY_CYCLE  0x02   &bsol;**< Connectable non-scannable directed advertising
201                                                                                          events. Advertising interval is less that 3.75 ms.
202                                                                                          Use this type for fast reconnections.
203                                                                                          @note Advertising data is not supported. */
204  #define BLE_GAP_ADV_TYPE_CONNECTABLE_NONSCANNABLE_DIRECTED                  0x03   &bsol;**< Connectable non-scannable directed advertising
205                                                                                          events.
206                                                                                          @note Advertising data is not supported. */
207  #define BLE_GAP_ADV_TYPE_NONCONNECTABLE_SCANNABLE_UNDIRECTED                0x04   &bsol;**< Non-connectable scannable undirected
208                                                                                          advertising events. */
209  #define BLE_GAP_ADV_TYPE_NONCONNECTABLE_NONSCANNABLE_UNDIRECTED             0x05   &bsol;**< Non-connectable non-scannable undirected
210                                                                                          advertising events. */
211  #define BLE_GAP_ADV_TYPE_EXTENDED_CONNECTABLE_NONSCANNABLE_UNDIRECTED       0x06   &bsol;**< Connectable non-scannable undirected advertising
212                                                                                          events using extended advertising PDUs. */
213  #define BLE_GAP_ADV_TYPE_EXTENDED_CONNECTABLE_NONSCANNABLE_DIRECTED         0x07   &bsol;**< Connectable non-scannable directed advertising
214                                                                                          events using extended advertising PDUs. */
215  #define BLE_GAP_ADV_TYPE_EXTENDED_NONCONNECTABLE_SCANNABLE_UNDIRECTED       0x08   &bsol;**< Non-connectable scannable undirected advertising
216                                                                                          events using extended advertising PDUs.
217                                                                                          @note Only scan response data is supported. */
218  #define BLE_GAP_ADV_TYPE_EXTENDED_NONCONNECTABLE_SCANNABLE_DIRECTED         0x09   &bsol;**< Non-connectable scannable directed advertising
219                                                                                          events using extended advertising PDUs.
220                                                                                          @note Only scan response data is supported. */
221  #define BLE_GAP_ADV_TYPE_EXTENDED_NONCONNECTABLE_NONSCANNABLE_UNDIRECTED    0x0A   &bsol;**< Non-connectable non-scannable undirected advertising
222                                                                                          events using extended advertising PDUs. */
223  #define BLE_GAP_ADV_TYPE_EXTENDED_NONCONNECTABLE_NONSCANNABLE_DIRECTED      0x0B   &bsol;**< Non-connectable non-scannable directed advertising
224                                                                                          events using extended advertising PDUs. */
225  #define BLE_GAP_ADV_FP_ANY                0x00   &bsol;**< Allow scan requests and connect requests from any device. */
226  #define BLE_GAP_ADV_FP_FILTER_SCANREQ     0x01   &bsol;**< Filter scan requests with whitelist. */
227  #define BLE_GAP_ADV_FP_FILTER_CONNREQ     0x02   &bsol;**< Filter connect requests with whitelist. */
228  #define BLE_GAP_ADV_FP_FILTER_BOTH        0x03   &bsol;**< Filter both scan and connect requests with whitelist. */
229  #define BLE_GAP_ADV_DATA_STATUS_COMPLETE             0x00 &bsol;**< All data in the advertising event have been received. */
230  #define BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_MORE_DATA 0x01 &bsol;**< More data to be received.
231                                                                 @note This value will only be used if
232                                                                 @ref ble_gap_scan_params_t::report_incomplete_evts and
233                                                                 @ref ble_gap_adv_report_type_t::extended_pdu are set to true. */
234  #define BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_TRUNCATED 0x02 &bsol;**< Incomplete data. Buffer size insufficient to receive more.
235                                                                 @note This value will only be used if
236                                                                 @ref ble_gap_adv_report_type_t::extended_pdu is set to true. */
237  #define BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_MISSED    0x03 &bsol;**< Failed to receive the remaining data.
238                                                                 @note This value will only be used if
239                                                                 @ref ble_gap_adv_report_type_t::extended_pdu is set to true. */
240  #define BLE_GAP_SCAN_FP_ACCEPT_ALL                      0x00  &bsol;**< Accept all advertising packets except directed advertising packets
241                                                                     not addressed to this device. */
242  #define BLE_GAP_SCAN_FP_WHITELIST                       0x01  &bsol;**< Accept advertising packets from devices in the whitelist except directed
243                                                                     packets not addressed to this device. */
244  #define BLE_GAP_SCAN_FP_ALL_NOT_RESOLVED_DIRECTED       0x02  &bsol;**< Accept all advertising packets specified in @ref BLE_GAP_SCAN_FP_ACCEPT_ALL.
245                                                                     In addition, accept directed advertising packets, where the advertiser's
246                                                                     address is a resolvable private address that cannot be resolved. */
247  #define BLE_GAP_SCAN_FP_WHITELIST_NOT_RESOLVED_DIRECTED 0x03  &bsol;**< Accept all advertising packets specified in @ref BLE_GAP_SCAN_FP_WHITELIST.
248                                                                     In addition, accept directed advertising packets, where the advertiser's
249                                                                     address is a resolvable private address that cannot be resolved. */
250  #define BLE_GAP_ADV_TIMEOUT_HIGH_DUTY_MAX     (128)   &bsol;**< Maximum high duty advertising time in 10 ms units. Corresponds to 1.28 s. */
251  #define BLE_GAP_ADV_TIMEOUT_LIMITED_MAX       (18000) &bsol;**< Maximum advertising time in 10 ms units corresponding to TGAP(lim_adv_timeout) = 180 s in limited discoverable mode. */
252  #define BLE_GAP_ADV_TIMEOUT_GENERAL_UNLIMITED (0)     &bsol;**< Unlimited advertising in general discoverable mode.
253                                                             For high duty cycle advertising, this corresponds to @ref BLE_GAP_ADV_TIMEOUT_HIGH_DUTY_MAX. */
254  #define BLE_GAP_DISC_MODE_NOT_DISCOVERABLE  0x00   &bsol;**< Not discoverable discovery Mode. */
255  #define BLE_GAP_DISC_MODE_LIMITED           0x01   &bsol;**< Limited Discovery Mode. */
256  #define BLE_GAP_DISC_MODE_GENERAL           0x02   &bsol;**< General Discovery Mode. */
257  #define BLE_GAP_IO_CAPS_DISPLAY_ONLY      0x00   &bsol;**< Display Only. */
258  #define BLE_GAP_IO_CAPS_DISPLAY_YESNO     0x01   &bsol;**< Display and Yes/No entry. */
259  #define BLE_GAP_IO_CAPS_KEYBOARD_ONLY     0x02   &bsol;**< Keyboard Only. */
260  #define BLE_GAP_IO_CAPS_NONE              0x03   &bsol;**< No I/O capabilities. */
261  #define BLE_GAP_IO_CAPS_KEYBOARD_DISPLAY  0x04   &bsol;**< Keyboard and Display. */
262  #define BLE_GAP_AUTH_KEY_TYPE_NONE        0x00   &bsol;**< No key (may be used to reject). */
263  #define BLE_GAP_AUTH_KEY_TYPE_PASSKEY     0x01   &bsol;**< 6-digit Passkey. */
264  #define BLE_GAP_AUTH_KEY_TYPE_OOB         0x02   &bsol;**< Out Of Band data. */
265  #define BLE_GAP_KP_NOT_TYPE_PASSKEY_START       0x00   &bsol;**< Passkey entry started. */
266  #define BLE_GAP_KP_NOT_TYPE_PASSKEY_DIGIT_IN    0x01   &bsol;**< Passkey digit entered. */
267  #define BLE_GAP_KP_NOT_TYPE_PASSKEY_DIGIT_OUT   0x02   &bsol;**< Passkey digit erased. */
268  #define BLE_GAP_KP_NOT_TYPE_PASSKEY_CLEAR       0x03   &bsol;**< Passkey cleared. */
269  #define BLE_GAP_KP_NOT_TYPE_PASSKEY_END         0x04   &bsol;**< Passkey entry completed. */
270  #define BLE_GAP_SEC_STATUS_SUCCESS                0x00  &bsol;**< Procedure completed with success. */
271  #define BLE_GAP_SEC_STATUS_TIMEOUT                0x01  &bsol;**< Procedure timed out. */
272  #define BLE_GAP_SEC_STATUS_PDU_INVALID            0x02  &bsol;**< Invalid PDU received. */
273  #define BLE_GAP_SEC_STATUS_RFU_RANGE1_BEGIN       0x03  &bsol;**< Reserved for Future Use range #1 begin. */
274  #define BLE_GAP_SEC_STATUS_RFU_RANGE1_END         0x80  &bsol;**< Reserved for Future Use range #1 end. */
275  #define BLE_GAP_SEC_STATUS_PASSKEY_ENTRY_FAILED   0x81  &bsol;**< Passkey entry failed (user canceled or other). */
276  #define BLE_GAP_SEC_STATUS_OOB_NOT_AVAILABLE      0x82  &bsol;**< Out of Band Key not available. */
277  #define BLE_GAP_SEC_STATUS_AUTH_REQ               0x83  &bsol;**< Authentication requirements not met. */
278  #define BLE_GAP_SEC_STATUS_CONFIRM_VALUE          0x84  &bsol;**< Confirm value failed. */
279  #define BLE_GAP_SEC_STATUS_PAIRING_NOT_SUPP       0x85  &bsol;**< Pairing not supported.  */
280  #define BLE_GAP_SEC_STATUS_ENC_KEY_SIZE           0x86  &bsol;**< Encryption key size. */
281  #define BLE_GAP_SEC_STATUS_SMP_CMD_UNSUPPORTED    0x87  &bsol;**< Unsupported SMP command. */
282  #define BLE_GAP_SEC_STATUS_UNSPECIFIED            0x88  &bsol;**< Unspecified reason. */
283  #define BLE_GAP_SEC_STATUS_REPEATED_ATTEMPTS      0x89  &bsol;**< Too little time elapsed since last attempt. */
284  #define BLE_GAP_SEC_STATUS_INVALID_PARAMS         0x8A  &bsol;**< Invalid parameters. */
285  #define BLE_GAP_SEC_STATUS_DHKEY_FAILURE          0x8B  &bsol;**< DHKey check failure. */
286  #define BLE_GAP_SEC_STATUS_NUM_COMP_FAILURE       0x8C  &bsol;**< Numeric Comparison failure. */
287  #define BLE_GAP_SEC_STATUS_BR_EDR_IN_PROG         0x8D  &bsol;**< BR/EDR pairing in progress. */
288  #define BLE_GAP_SEC_STATUS_X_TRANS_KEY_DISALLOWED 0x8E  &bsol;**< BR/EDR Link Key cannot be used for LE keys. */
289  #define BLE_GAP_SEC_STATUS_RFU_RANGE2_BEGIN       0x8F  &bsol;**< Reserved for Future Use range #2 begin. */
290  #define BLE_GAP_SEC_STATUS_RFU_RANGE2_END         0xFF  &bsol;**< Reserved for Future Use range #2 end. */
291  #define BLE_GAP_SEC_STATUS_SOURCE_LOCAL           0x00  &bsol;**< Local failure. */
292  #define BLE_GAP_SEC_STATUS_SOURCE_REMOTE          0x01  &bsol;**< Remote failure. */
293  #define BLE_GAP_CP_MIN_CONN_INTVL_NONE           0xFFFF  &bsol;**< No new minimum connection interval specified in connect parameters. */
294  #define BLE_GAP_CP_MIN_CONN_INTVL_MIN            0x0006  &bsol;**< Lowest minimum connection interval permitted, in units of 1.25 ms, i.e. 7.5 ms. */
295  #define BLE_GAP_CP_MIN_CONN_INTVL_MAX            0x0C80  &bsol;**< Highest minimum connection interval permitted, in units of 1.25 ms, i.e. 4 s. */
296  #define BLE_GAP_CP_MAX_CONN_INTVL_NONE           0xFFFF  &bsol;**< No new maximum connection interval specified in connect parameters. */
297  #define BLE_GAP_CP_MAX_CONN_INTVL_MIN            0x0006  &bsol;**< Lowest maximum connection interval permitted, in units of 1.25 ms, i.e. 7.5 ms. */
298  #define BLE_GAP_CP_MAX_CONN_INTVL_MAX            0x0C80  &bsol;**< Highest maximum connection interval permitted, in units of 1.25 ms, i.e. 4 s. */
299  #define BLE_GAP_CP_SLAVE_LATENCY_MAX             0x01F3  &bsol;**< Highest slave latency permitted, in connection events. */
300  #define BLE_GAP_CP_CONN_SUP_TIMEOUT_NONE         0xFFFF  &bsol;**< No new supervision timeout specified in connect parameters. */
301  #define BLE_GAP_CP_CONN_SUP_TIMEOUT_MIN          0x000A  &bsol;**< Lowest supervision timeout permitted, in units of 10 ms, i.e. 100 ms. */
302  #define BLE_GAP_CP_CONN_SUP_TIMEOUT_MAX          0x0C80  &bsol;**< Highest supervision timeout permitted, in units of 10 ms, i.e. 32 s. */
303  #define BLE_GAP_DEVNAME_DEFAULT                  "nRF5x" &bsol;**< Default device name value. */
304  #define BLE_GAP_DEVNAME_DEFAULT_LEN              31      &bsol;**< Default number of octets in device name. */
305  #define BLE_GAP_DEVNAME_MAX_LEN                  248     &bsol;**< Maximum number of octets in device name. */
306  #define BLE_GAP_RSSI_THRESHOLD_INVALID 0xFF
307  #define BLE_GAP_PHY_AUTO                         0x00    &bsol;**< Automatic PHY selection. Refer @ref sd_ble_gap_phy_update for more information.*/
308  #define BLE_GAP_PHY_1MBPS                        0x01    &bsol;**< 1 Mbps PHY. */
309  #define BLE_GAP_PHY_2MBPS                        0x02    &bsol;**< 2 Mbps PHY. */
310  #define BLE_GAP_PHY_CODED                        0x04    &bsol;**< Coded PHY. */
311  #define BLE_GAP_PHY_NOT_SET                      0xFF    &bsol;**< PHY is not configured. */
312  #define BLE_GAP_PHYS_SUPPORTED  (BLE_GAP_PHY_1MBPS | BLE_GAP_PHY_2MBPS) &bsol;**< All PHYs except @ref BLE_GAP_PHY_CODED are supported. */
313  #define BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(ptr)          do {(ptr)->sm = 0; (ptr)->lv = 0;} while(0)
314  #define BLE_GAP_CONN_SEC_MODE_SET_OPEN(ptr)               do {(ptr)->sm = 1; (ptr)->lv = 1;} while(0)
315  #define BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(ptr)        do {(ptr)->sm = 1; (ptr)->lv = 2;} while(0)
316  #define BLE_GAP_CONN_SEC_MODE_SET_ENC_WITH_MITM(ptr)      do {(ptr)->sm = 1; (ptr)->lv = 3;} while(0)
317  #define BLE_GAP_CONN_SEC_MODE_SET_LESC_ENC_WITH_MITM(ptr) do {(ptr)->sm = 1; (ptr)->lv = 4;} while(0)
318  #define BLE_GAP_CONN_SEC_MODE_SET_SIGNED_NO_MITM(ptr)     do {(ptr)->sm = 2; (ptr)->lv = 1;} while(0)
319  #define BLE_GAP_CONN_SEC_MODE_SET_SIGNED_WITH_MITM(ptr)   do {(ptr)->sm = 2; (ptr)->lv = 2;} while(0)
320  #define BLE_GAP_SEC_RAND_LEN 8
321  #define BLE_GAP_SEC_KEY_LEN 16
322  #define BLE_GAP_LESC_P256_PK_LEN 64
323  #define BLE_GAP_LESC_DHKEY_LEN   32
324  #define BLE_GAP_PASSKEY_LEN 6
325  #define BLE_GAP_WHITELIST_ADDR_MAX_COUNT (8)
326  #define BLE_GAP_DEVICE_IDENTITIES_MAX_COUNT (8)
327  #define BLE_GAP_CONN_COUNT_DEFAULT (1)
328  #define BLE_GAP_EVENT_LENGTH_MIN            (2)  &bsol;**< Minimum event length, in 1.25 ms units. */
329  #define BLE_GAP_EVENT_LENGTH_DEFAULT        (3)  &bsol;**< Default event length, in 1.25 ms units. */
330  #define BLE_GAP_ROLE_COUNT_PERIPH_DEFAULT      (1)   &bsol;**< Default maximum number of connections concurrently acting as peripherals. */
331  #define BLE_GAP_ROLE_COUNT_CENTRAL_DEFAULT     (3)   &bsol;**< Default maximum number of connections concurrently acting as centrals. */
332  #define BLE_GAP_ROLE_COUNT_CENTRAL_SEC_DEFAULT (1)   &bsol;**< Default number of SMP instances shared between all connections acting as centrals. */
333  #define BLE_GAP_ROLE_COUNT_COMBINED_MAX        (20)  &bsol;**< Maximum supported number of concurrent connections in the peripheral and central roles combined. */
334  #define BLE_GAP_DATA_LENGTH_AUTO 0
335  #define BLE_GAP_AUTH_PAYLOAD_TIMEOUT_MAX (48000) &bsol;**< Maximum authenticated payload timeout in 10 ms units, i.e. 8 minutes. */
336  #define BLE_GAP_AUTH_PAYLOAD_TIMEOUT_MIN (1)     &bsol;**< Minimum authenticated payload timeout in 10 ms units, i.e. 10 ms. */
337  #define BLE_GAP_SEC_MODE 0x00 &bsol;**< No key (may be used to reject). */
338  #define BLE_GAP_CHANNEL_COUNT      (40)
339  #define BLE_GAP_QOS_CHANNEL_SURVEY_INTERVAL_CONTINUOUS  (0)       &bsol;**< Continuous channel survey. */
340  #define BLE_GAP_QOS_CHANNEL_SURVEY_INTERVAL_MIN_US      (7500)    &bsol;**< Minimum channel survey interval in microseconds (7.5 ms). */
341  #define BLE_GAP_QOS_CHANNEL_SURVEY_INTERVAL_MAX_US      (4000000) &bsol;**< Maximum channel survey interval in microseconds (4 s). */
342  typedef struct
343  {
344    uint8_t type;                 &bsol;**< Advertising type. See @ref BLE_GAP_ADV_TYPES. */
345    uint8_t anonymous        : 1; &bsol;**< Omit advertiser's address from all PDUs.
346                                       @note Anonymous advertising is only available for
347                                       @ref BLE_GAP_ADV_TYPE_EXTENDED_NONCONNECTABLE_NONSCANNABLE_UNDIRECTED and
348                                       @ref BLE_GAP_ADV_TYPE_EXTENDED_NONCONNECTABLE_NONSCANNABLE_DIRECTED. */
349    uint8_t include_tx_power : 1; &bsol;**< This feature is not supported on this SoftDevice. */
350  } ble_gap_adv_properties_t;
351  typedef struct
352  {
353    uint16_t connectable   : 1; &bsol;**< Connectable advertising event type. */
354    uint16_t scannable     : 1; &bsol;**< Scannable advertising event type. */
355    uint16_t directed      : 1; &bsol;**< Directed advertising event type. */
356    uint16_t scan_response : 1; &bsol;**< Received a scan response. */
357    uint16_t extended_pdu  : 1; &bsol;**< Received an extended advertising set. */
358    uint16_t status        : 2; &bsol;**< Data status. See @ref BLE_GAP_ADV_DATA_STATUS. */
359    uint16_t reserved      : 9; &bsol;**< Reserved for future use. */
360  } ble_gap_adv_report_type_t;
361  typedef struct
362  {
363    uint16_t  aux_offset;   &bsol;**< Time offset from the beginning of advertising packet to the auxiliary packet in 100 us units. */
364    uint8_t   aux_phy;      &bsol;**< Indicates the PHY on which the auxiliary advertising packet is sent. See @ref BLE_GAP_PHYS. */
365  } ble_gap_aux_pointer_t;
366  typedef struct
367  {
368    uint8_t addr_id_peer : 1;       &bsol;**< Only valid for peer addresses.
369                                         This bit is set by the SoftDevice to indicate whether the address has been resolved from
370                                         a Resolvable Private Address (when the peer is using privacy).
371                                         If set to 1, @ref addr and @ref addr_type refer to the identity address of the resolved address.
372                                         This bit is ignored when a variable of type @ref ble_gap_addr_t is used as input to API functions. */
373    uint8_t addr_type    : 7;       &bsol;**< See @ref BLE_GAP_ADDR_TYPES. */
374    uint8_t addr[BLE_GAP_ADDR_LEN]; &bsol;**< 48-bit address, LSB format.
375                                         @ref addr is not used if @ref addr_type is @ref BLE_GAP_ADDR_TYPE_ANONYMOUS. */
376  } ble_gap_addr_t;
377  typedef struct
378  {
379    uint16_t min_conn_interval;         &bsol;**< Minimum Connection Interval in 1.25 ms units, see @ref BLE_GAP_CP_LIMITS.*/
380    uint16_t max_conn_interval;         &bsol;**< Maximum Connection Interval in 1.25 ms units, see @ref BLE_GAP_CP_LIMITS.*/
381    uint16_t slave_latency;             &bsol;**< Slave Latency in number of connection events, see @ref BLE_GAP_CP_LIMITS.*/
382    uint16_t conn_sup_timeout;          &bsol;**< Connection Supervision Timeout in 10 ms units, see @ref BLE_GAP_CP_LIMITS.*/
383  } ble_gap_conn_params_t;
384  typedef struct
385  {
386    uint8_t sm : 4;                     &bsol;**< Security Mode (1 or 2), 0 for no permissions at all. */
387    uint8_t lv : 4;                     &bsol;**< Level (1, 2, 3 or 4), 0 for no permissions at all. */
388  } ble_gap_conn_sec_mode_t;
389  typedef struct
390  {
391    ble_gap_conn_sec_mode_t sec_mode;           &bsol;**< Currently active security mode for this connection.*/
392    uint8_t                 encr_key_size;      &bsol;**< Length of currently active encryption key, 7 to 16 octets (only applicable for bonding procedures). */
393  } ble_gap_conn_sec_t;
394  typedef struct
395  {
396    uint8_t irk[BLE_GAP_SEC_KEY_LEN];   &bsol;**< Array containing IRK. */
397  } ble_gap_irk_t;
398  typedef uint8_t ble_gap_ch_mask_t[5];
399  typedef struct
400  {
401    ble_gap_adv_properties_t properties;              &bsol;**< The properties of the advertising events. */
402    ble_gap_addr_t const    *p_peer_addr;             &bsol;**< Address of a known peer.
403                                                           @note ble_gap_addr_t::addr_type cannot be
404                                                                 @ref BLE_GAP_ADDR_TYPE_ANONYMOUS.
405                                                           - When privacy is enabled and the local device uses
406                                                             @ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE addresses,
407                                                             the device identity list is searched for a matching entry. If
408                                                             the local IRK for that device identity is set, the local IRK
409                                                             for that device will be used to generate the advertiser address
410                                                             field in the advertising packet.
411                                                           - If @ref ble_gap_adv_properties_t::type is directed, this must be
412                                                             set to the targeted scanner or initiator. If the peer address is
413                                                             in the device identity list, the peer IRK for that device will be
414                                                             used to generate @ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE
415                                                             target addresses used in the advertising event PDUs. */
416    uint32_t                 interval;                &bsol;**< Advertising interval in 625 us units. @sa BLE_GAP_ADV_INTERVALS.
417                                                           @note If @ref ble_gap_adv_properties_t::type is set to
418                                                                 @ref BLE_GAP_ADV_TYPE_CONNECTABLE_NONSCANNABLE_DIRECTED_HIGH_DUTY_CYCLE
419                                                                 advertising, this parameter is ignored. */
420    uint16_t                 duration;                &bsol;**< Advertising duration in 10 ms units. When timeout is reached,
421                                                           an event of type @ref BLE_GAP_EVT_ADV_SET_TERMINATED is raised.
422                                                           @sa BLE_GAP_ADV_TIMEOUT_VALUES.
423                                                           @note The SoftDevice will always complete at least one advertising
424                                                                 event even if the duration is set too low. */
425    uint8_t                  max_adv_evts;            &bsol;**< Maximum advertising events that shall be sent prior to disabling
426                                                           advertising. Setting the value to 0 disables the limitation. When
427                                                           the count of advertising events specified by this parameter
428                                                           (if not 0) is reached, advertising will be automatically stopped
429                                                           and an event of type @ref BLE_GAP_EVT_ADV_SET_TERMINATED is raised
430                                                           @note If @ref ble_gap_adv_properties_t::type is set to
431                                                                 @ref BLE_GAP_ADV_TYPE_CONNECTABLE_NONSCANNABLE_DIRECTED_HIGH_DUTY_CYCLE,
432                                                                 this parameter is ignored. */
433    ble_gap_ch_mask_t        channel_mask;            &bsol;**< Channel mask for primary and secondary advertising channels.
434                                                           At least one of the primary channels, that is channel index 37-39, must be used.
435                                                           Masking away secondary advertising channels is not supported. */
436    uint8_t                  filter_policy;           &bsol;**< Filter Policy. @sa BLE_GAP_ADV_FILTER_POLICIES. */
437    uint8_t                  primary_phy;             &bsol;**< Indicates the PHY on which the primary advertising channel packets
438                                                           are transmitted. If set to @ref BLE_GAP_PHY_AUTO, @ref BLE_GAP_PHY_1MBPS
439                                                           will be used.
440                                                           The only supported value by this SoftDevice is @ref BLE_GAP_PHY_1MBPS. */
441    uint8_t                  secondary_phy;           &bsol;**< Indicates the PHY on which the secondary advertising channel packets
442                                                           are transmitted.
443                                                           If set to @ref BLE_GAP_PHY_AUTO, @ref BLE_GAP_PHY_1MBPS will be used.
444                                                           Valid values are
445                                                           @ref BLE_GAP_PHY_1MBPS and @ref BLE_GAP_PHY_2MBPS. @ref BLE_GAP_PHY_CODED
446                                                           is not supported by this SoftDevice.
447                                                           If @ref ble_gap_adv_properties_t::type is an extended advertising type
448                                                           and connectable, this is the PHY that will be used to establish a
449                                                           connection and send AUX_ADV_IND packets on.
450                                                           @note This parameter will be ignored when
451                                                                 @ref ble_gap_adv_properties_t::type is not an extended advertising type. */
452    uint8_t                  set_id:4;                &bsol;**< The advertising set identifier distinguishes this advertising set from other
453                                                           advertising sets transmitted by this and other devices.
454                                                           @note This parameter will be ignored when
455                                                                 @ref ble_gap_adv_properties_t::type is not an extended advertising type. */
456    uint8_t                  scan_req_notification:1; &bsol;**< Enable scan request notifications for this advertising set. When a
457                                                           scan request is received and the scanner address is allowed
458                                                           by the filter policy, @ref BLE_GAP_EVT_SCAN_REQ_REPORT is raised.
459                                                           @note This parameter will be ignored when
460                                                                 @ref ble_gap_adv_properties_t::type is a non-scannable
461                                                                 advertising type. */
462  } ble_gap_adv_params_t;
463  typedef struct
464  {
465    ble_data_t       adv_data;                     &bsol;**< Advertising data.
466                                                        @note
467                                                        Advertising data can only be specified for a @ref ble_gap_adv_properties_t::type
468                                                        that is allowed to contain advertising data. */
469    ble_data_t       scan_rsp_data;                &bsol;**< Scan response data.
470                                                        @note
471                                                        Scan response data can only be specified for a @ref ble_gap_adv_properties_t::type
472                                                        that is scannable. */
473  } ble_gap_adv_data_t;
474  typedef struct
475  {
476    uint8_t               extended               : 1; &bsol;**< If 1, the scanner will accept extended advertising packets.
477                                                           If set to 0, the scanner will not receive advertising packets
478                                                           on secondary advertising channels, and will not be able
479                                                           to receive long advertising PDUs. */
480    uint8_t               report_incomplete_evts : 1; &bsol;**< If 1, events of type @ref ble_gap_evt_adv_report_t may have
481                                                           @ref ble_gap_adv_report_type_t::status set to
482                                                           @ref BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_MORE_DATA.
483                                                           This parameter is ignored when used with @ref sd_ble_gap_connect
484                                                           @note This may be used to abort receiving more packets from an extended
485                                                                 advertising event, and is only available for extended
486                                                                 scanning, see @ref sd_ble_gap_scan_start.
487                                                           @note This feature is not supported by this SoftDevice. */
488    uint8_t               active                 : 1; &bsol;**< If 1, perform active scanning by sending scan requests.
489                                                           This parameter is ignored when used with @ref sd_ble_gap_connect. */
490    uint8_t               filter_policy          : 2; &bsol;**< Scanning filter policy. @sa BLE_GAP_SCAN_FILTER_POLICIES.
491                                                           @note Only @ref BLE_GAP_SCAN_FP_ACCEPT_ALL and
492                                                                 @ref BLE_GAP_SCAN_FP_WHITELIST are valid when used with
493                                                                 @ref sd_ble_gap_connect */
494    uint8_t               scan_phys;                  &bsol;**< Bitfield of PHYs to scan on. If set to @ref BLE_GAP_PHY_AUTO,
495                                                           scan_phys will default to @ref BLE_GAP_PHY_1MBPS.
496                                                           - If @ref ble_gap_scan_params_t::extended is set to 0, the only
497                                                             supported PHY is @ref BLE_GAP_PHY_1MBPS.
498                                                           - When used with @ref sd_ble_gap_scan_start,
499                                                             the bitfield indicates the PHYs the scanner will use for scanning
500                                                             on primary advertising channels. The scanner will accept
501                                                             @ref BLE_GAP_PHYS_SUPPORTED as secondary advertising channel PHYs.
502                                                           - When used with @ref sd_ble_gap_connect, the bitfield indicates
503                                                             the PHYs the initiator will use for scanning on primary advertising
504                                                             channels. The initiator will accept connections initiated on either
505                                                             of the @ref BLE_GAP_PHYS_SUPPORTED PHYs.
506                                                             If scan_phys contains @ref BLE_GAP_PHY_1MBPS and/or @ref BLE_GAP_PHY_2MBPS,
507                                                             the primary scan PHY is @ref BLE_GAP_PHY_1MBPS. */
508    uint16_t              interval;                   &bsol;**< Scan interval in 625 us units. @sa BLE_GAP_SCAN_INTERVALS. */
509    uint16_t              window;                     &bsol;**< Scan window in 625 us units. @sa BLE_GAP_SCAN_WINDOW. */
510    uint16_t              timeout;                    &bsol;**< Scan timeout in 10 ms units. @sa BLE_GAP_SCAN_TIMEOUT. */
511    ble_gap_ch_mask_t     channel_mask;               &bsol;**< Channel mask for primary and secondary advertising channels.
512                                                           At least one of the primary channels, that is channel index 37-39, must be
513                                                           set to 0.
514                                                           Masking away secondary channels is not supported. */
515  } ble_gap_scan_params_t;
516  typedef struct
517  {
518    uint8_t        privacy_mode;         &bsol;**< Privacy mode, see @ref BLE_GAP_PRIVACY_MODES. Default is @ref BLE_GAP_PRIVACY_MODE_OFF. */
519    uint8_t        private_addr_type;    &bsol;**< The private address type must be either @ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE or @ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE. */
520    uint16_t       private_addr_cycle_s; &bsol;**< Private address cycle interval in seconds. Providing an address cycle value of 0 will use the default value defined by @ref BLE_GAP_DEFAULT_PRIVATE_ADDR_CYCLE_INTERVAL_S. */
521    ble_gap_irk_t *p_device_irk;         &bsol;**< When used as input, pointer to IRK structure that will be used as the default IRK. If NULL, the device default IRK will be used.
522                                              When used as output, pointer to IRK structure where the current default IRK will be written to. If NULL, this argument is ignored.
523                                              By default, the default IRK is used to generate random private resolvable addresses for the local device unless instructed otherwise. */
524  } ble_gap_privacy_params_t;
525  typedef struct
526  {
527    uint8_t tx_phys;     &bsol;**< Preferred transmit PHYs, see @ref BLE_GAP_PHYS. */
528    uint8_t rx_phys;     &bsol;**< Preferred receive PHYs, see @ref BLE_GAP_PHYS. */
529  } ble_gap_phys_t;
530  typedef struct
531  {
532    uint8_t enc     : 1;                        &bsol;**< Long Term Key and Master Identification. */
533    uint8_t id      : 1;                        &bsol;**< Identity Resolving Key and Identity Address Information. */
534    uint8_t sign    : 1;                        &bsol;**< Connection Signature Resolving Key. */
535    uint8_t link    : 1;                        &bsol;**< Derive the Link Key from the LTK. */
536  } ble_gap_sec_kdist_t;
537  typedef struct
538  {
539    uint8_t               bond      : 1;             &bsol;**< Perform bonding. */
540    uint8_t               mitm      : 1;             &bsol;**< Enable Man In The Middle protection. */
541    uint8_t               lesc      : 1;             &bsol;**< Enable LE Secure Connection pairing. */
542    uint8_t               keypress  : 1;             &bsol;**< Enable generation of keypress notifications. */
543    uint8_t               io_caps   : 3;             &bsol;**< IO capabilities, see @ref BLE_GAP_IO_CAPS. */
544    uint8_t               oob       : 1;             &bsol;**< The OOB data flag.
545                                                          - In LE legacy pairing, this flag is set if a device has out of band authentication data.
546                                                            The OOB method is used if both of the devices have out of band authentication data.
547                                                          - In LE Secure Connections pairing, this flag is set if a device has the peer device's out of band authentication data.
548                                                            The OOB method is used if at least one device has the peer device's OOB data available. */
549    uint8_t               min_key_size;              &bsol;**< Minimum encryption key size in octets between 7 and 16. If 0 then not applicable in this instance. */
550    uint8_t               max_key_size;              &bsol;**< Maximum encryption key size in octets between min_key_size and 16. */
551    ble_gap_sec_kdist_t   kdist_own;                 &bsol;**< Key distribution bitmap: keys that the local device will distribute. */
552    ble_gap_sec_kdist_t   kdist_peer;                &bsol;**< Key distribution bitmap: keys that the remote device will distribute. */
553  } ble_gap_sec_params_t;
554  typedef struct
555  {
556    uint8_t   ltk[BLE_GAP_SEC_KEY_LEN];   &bsol;**< Long Term Key. */
557    uint8_t   lesc : 1;                   &bsol;**< Key generated using LE Secure Connections. */
558    uint8_t   auth : 1;                   &bsol;**< Authenticated Key. */
559    uint8_t   ltk_len : 6;                &bsol;**< LTK length in octets. */
560  } ble_gap_enc_info_t;
561  typedef struct
562  {
563    uint16_t  ediv;                       &bsol;**< Encrypted Diversifier. */
564    uint8_t   rand[BLE_GAP_SEC_RAND_LEN]; &bsol;**< Random Number. */
565  } ble_gap_master_id_t;
566  typedef struct
567  {
568    uint8_t   csrk[BLE_GAP_SEC_KEY_LEN];        &bsol;**< Connection Signature Resolving Key. */
569  } ble_gap_sign_info_t;
570  typedef struct
571  {
572    uint8_t   pk[BLE_GAP_LESC_P256_PK_LEN];        &bsol;**< LE Secure Connections Elliptic Curve Diffie-Hellman P-256 Public Key. Stored in the standard SMP protocol format: {X,Y} both in little-endian. */
573  } ble_gap_lesc_p256_pk_t;
574  typedef struct
575  {
576    uint8_t   key[BLE_GAP_LESC_DHKEY_LEN];        &bsol;**< LE Secure Connections Elliptic Curve Diffie-Hellman Key. Stored in little-endian. */
577  } ble_gap_lesc_dhkey_t;
578  typedef struct
579  {
580    ble_gap_addr_t  addr;                          &bsol;**< Bluetooth address of the device. */
581    uint8_t         r[BLE_GAP_SEC_KEY_LEN];        &bsol;**< Random Number. */
582    uint8_t         c[BLE_GAP_SEC_KEY_LEN];        &bsol;**< Confirm Value. */
583  } ble_gap_lesc_oob_data_t;
584  typedef struct
585  {
586    ble_gap_addr_t        peer_addr;              &bsol;**< Bluetooth address of the peer device. If the peer_addr resolved: @ref ble_gap_addr_t::addr_id_peer is set to 1
587                                                       and the address is the device's identity address. */
588    uint8_t               role;                   &bsol;**< BLE role for this connection, see @ref BLE_GAP_ROLES */
589    ble_gap_conn_params_t conn_params;            &bsol;**< GAP Connection Parameters. */
590    uint8_t               adv_handle;             &bsol;**< Advertising handle in which advertising has ended.
591                                                       This variable is only set if role is set to @ref BLE_GAP_ROLE_PERIPH. */
592    ble_gap_adv_data_t    adv_data;               &bsol;**< Advertising buffers corresponding to the terminated
593                                                       advertising set. The advertising buffers provided in
594                                                       @ref sd_ble_gap_adv_set_configure are now released.
595                                                       This variable is only set if role is set to @ref BLE_GAP_ROLE_PERIPH. */
596  } ble_gap_evt_connected_t;
597  typedef struct
598  {
599    uint8_t reason;                               &bsol;**< HCI error code, see @ref BLE_HCI_STATUS_CODES. */
600  } ble_gap_evt_disconnected_t;
601  typedef struct
602  {
603    ble_gap_conn_params_t conn_params;            &bsol;**<  GAP Connection Parameters. */
604  } ble_gap_evt_conn_param_update_t;
605  typedef struct
606  {
607    ble_gap_phys_t peer_preferred_phys;            &bsol;**< The PHYs the peer prefers to use. */
608  } ble_gap_evt_phy_update_request_t;
609  typedef struct
610  {
611    uint8_t status;                               &bsol;**< Status of the procedure, see @ref BLE_HCI_STATUS_CODES.*/
612    uint8_t tx_phy;                               &bsol;**< TX PHY for this connection, see @ref BLE_GAP_PHYS. */
613    uint8_t rx_phy;                               &bsol;**< RX PHY for this connection, see @ref BLE_GAP_PHYS. */
614  } ble_gap_evt_phy_update_t;
615  typedef struct
616  {
617    ble_gap_sec_params_t peer_params;             &bsol;**< Initiator Security Parameters. */
618  } ble_gap_evt_sec_params_request_t;
619  typedef struct
620  {
621    ble_gap_addr_t      peer_addr;                     &bsol;**< Bluetooth address of the peer device. */
622    ble_gap_master_id_t master_id;                     &bsol;**< Master Identification for LTK lookup. */
623    uint8_t             enc_info  : 1;                 &bsol;**< If 1, Encryption Information required. */
624    uint8_t             id_info   : 1;                 &bsol;**< If 1, Identity Information required. */
625    uint8_t             sign_info : 1;                 &bsol;**< If 1, Signing Information required. */
626  } ble_gap_evt_sec_info_request_t;
627  typedef struct
628  {
629    uint8_t passkey[BLE_GAP_PASSKEY_LEN];         &bsol;**< 6-digit passkey in ASCII ('0'-'9' digits only). */
630    uint8_t match_request : 1;                    &bsol;**< If 1 requires the application to report the match using @ref sd_ble_gap_auth_key_reply
631                                                       with either @ref BLE_GAP_AUTH_KEY_TYPE_NONE if there is no match or
632                                                       @ref BLE_GAP_AUTH_KEY_TYPE_PASSKEY if there is a match. */
633  } ble_gap_evt_passkey_display_t;
634  typedef struct
635  {
636    uint8_t kp_not;         &bsol;**< Keypress notification type, see @ref BLE_GAP_KP_NOT_TYPES. */
637  } ble_gap_evt_key_pressed_t;
638  typedef struct
639  {
640    uint8_t key_type;                             &bsol;**< See @ref BLE_GAP_AUTH_KEY_TYPES. */
641  } ble_gap_evt_auth_key_request_t;
642  typedef struct
643  {
644    ble_gap_lesc_p256_pk_t *p_pk_peer;  &bsol;**< LE Secure Connections remote P-256 Public Key. This will point to the application-supplied memory
645                                             inside the keyset during the call to @ref sd_ble_gap_sec_params_reply. */
646    uint8_t oobd_req       :1;          &bsol;**< LESC OOB data required. A call to @ref sd_ble_gap_lesc_oob_data_set is required to complete the procedure. */
647  } ble_gap_evt_lesc_dhkey_request_t;
648  typedef struct
649  {
650    uint8_t lv1 : 1;                              &bsol;**< If 1: Level 1 is supported. */
651    uint8_t lv2 : 1;                              &bsol;**< If 1: Level 2 is supported. */
652    uint8_t lv3 : 1;                              &bsol;**< If 1: Level 3 is supported. */
653    uint8_t lv4 : 1;                              &bsol;**< If 1: Level 4 is supported. */
654  } ble_gap_sec_levels_t;
655  typedef struct
656  {
657    ble_gap_enc_info_t    enc_info;             &bsol;**< Encryption Information. */
658    ble_gap_master_id_t   master_id;            &bsol;**< Master Identification. */
659  } ble_gap_enc_key_t;
660  typedef struct
661  {
662    ble_gap_irk_t         id_info;              &bsol;**< Identity Resolving Key. */
663    ble_gap_addr_t        id_addr_info;         &bsol;**< Identity Address. */
664  } ble_gap_id_key_t;
665  typedef struct
666  {
667    ble_gap_enc_key_t      *p_enc_key;           &bsol;**< Encryption Key, or NULL. */
668    ble_gap_id_key_t       *p_id_key;            &bsol;**< Identity Key, or NULL. */
669    ble_gap_sign_info_t    *p_sign_key;          &bsol;**< Signing Key, or NULL. */
670    ble_gap_lesc_p256_pk_t *p_pk;                &bsol;**< LE Secure Connections P-256 Public Key. When in debug mode the application must use the value defined
671                                                      in the Core Bluetooth Specification v4.2 Vol.3, Part H, Section 2.3.5.6.1 */
672  } ble_gap_sec_keys_t;
673  typedef struct
674  {
675    ble_gap_sec_keys_t            keys_own;     &bsol;**< Keys distributed by the local device. For LE Secure Connections the encryption key will be generated locally and will always be stored if bonding. */
676    ble_gap_sec_keys_t            keys_peer;    &bsol;**< Keys distributed by the remote device. For LE Secure Connections, p_enc_key must always be NULL. */
677  } ble_gap_sec_keyset_t;
678  typedef struct
679  {
680    uint16_t max_tx_octets;   &bsol;**< Maximum number of payload octets that a Controller supports for transmission of a single Link Layer Data Channel PDU. */
681    uint16_t max_rx_octets;   &bsol;**< Maximum number of payload octets that a Controller supports for reception of a single Link Layer Data Channel PDU. */
682    uint16_t max_tx_time_us;  &bsol;**< Maximum time, in microseconds, that a Controller supports for transmission of a single Link Layer Data Channel PDU. */
683    uint16_t max_rx_time_us;  &bsol;**< Maximum time, in microseconds, that a Controller supports for reception of a single Link Layer Data Channel PDU. */
684  } ble_gap_data_length_params_t;
685  typedef struct
686  {
687    uint16_t tx_payload_limited_octets; &bsol;**< If > 0, the requested TX packet length is too long by this many octets. */
688    uint16_t rx_payload_limited_octets; &bsol;**< If > 0, the requested RX packet length is too long by this many octets. */
689    uint16_t tx_rx_time_limited_us;     &bsol;**< If > 0, the requested combination of TX and RX packet lengths is too long by this many microseconds. */
690  } ble_gap_data_length_limitation_t;
691  typedef struct
692  {
693    uint8_t               auth_status;            &bsol;**< Authentication status, see @ref BLE_GAP_SEC_STATUS. */
694    uint8_t               error_src : 2;          &bsol;**< On error, source that caused the failure, see @ref BLE_GAP_SEC_STATUS_SOURCES. */
<span onclick='openModal()' class='match'>695    uint8_t               bonded : 1;             &bsol;**< Procedure resulted in a bond. */
696    uint8_t               lesc : 1;               &bsol;**< Procedure resulted in a LE Secure Connection. */
</span>697    ble_gap_sec_levels_t  sm1_levels;             &bsol;**< Levels supported in Security Mode 1. */
698    ble_gap_sec_levels_t  sm2_levels;             &bsol;**< Levels supported in Security Mode 2. */
699    ble_gap_sec_kdist_t   kdist_own;              &bsol;**< Bitmap stating which keys were exchanged (distributed) by the local device. If bonding with LE Secure Connections, the enc bit will be always set. */
700    ble_gap_sec_kdist_t   kdist_peer;             &bsol;**< Bitmap stating which keys were exchanged (distributed) by the remote device. If bonding with LE Secure Connections, the enc bit will never be set. */
701  } ble_gap_evt_auth_status_t;
702  typedef struct
703  {
704    ble_gap_conn_sec_t conn_sec;                  &bsol;**< Connection security level. */
705  } ble_gap_evt_conn_sec_update_t;
706  typedef struct
707  {
708    uint8_t src;                                  &bsol;**< Source of timeout event, see @ref BLE_GAP_TIMEOUT_SOURCES. */
709    union
710    {
711      ble_data_t adv_report_buffer;               &bsol;**< If source is set to @ref BLE_GAP_TIMEOUT_SRC_SCAN, the released
712                                                       scan buffer is contained in this field. */
713    } params;                                     &bsol;**< Event Parameters. */
714  } ble_gap_evt_timeout_t;
715  typedef struct
716  {
717    int8_t  rssi;                                 &bsol;**< Received Signal Strength Indication in dBm. */
718    uint8_t ch_index;                             &bsol;**< Data Channel Index on which the Signal Strength is measured (0-36). */
719  } ble_gap_evt_rssi_changed_t;
720  typedef struct
721  {
722    uint8_t             reason;                         &bsol;**< Reason for why the advertising set terminated. See
723                                                             @ref BLE_GAP_EVT_ADV_SET_TERMINATED_REASON. */
724    uint8_t             adv_handle;                     &bsol;**< Advertising handle in which advertising has ended. */
725    uint8_t             num_completed_adv_events;       &bsol;**< If @ref ble_gap_adv_params_t::max_adv_evts was not set to 0,
726                                                             this field indicates the number of completed advertising events. */
727    ble_gap_adv_data_t  adv_data;                       &bsol;**< Advertising buffers corresponding to the terminated
728                                                             advertising set. The advertising buffers provided in
729                                                             @ref sd_ble_gap_adv_set_configure are now released. */
730  } ble_gap_evt_adv_set_terminated_t;
731  typedef struct
732  {
733    ble_gap_adv_report_type_t type;                  &bsol;**< Advertising report type. See @ref ble_gap_adv_report_type_t. */
734    ble_gap_addr_t            peer_addr;             &bsol;**< Bluetooth address of the peer device. If the peer_addr is resolved:
735                                                          @ref ble_gap_addr_t::addr_id_peer is set to 1 and the address is the
736                                                          peer's identity address. */
737    ble_gap_addr_t            direct_addr;           &bsol;**< Contains the target address of the advertising event if
738                                                          @ref ble_gap_adv_report_type_t::directed is set to 1. If the
739                                                          SoftDevice was able to resolve the address,
740                                                          @ref ble_gap_addr_t::addr_id_peer is set to 1 and the direct_addr
741                                                          contains the local identity address. If the target address of the
742                                                          advertising event is @ref BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE,
743                                                          and the SoftDevice was unable to resolve it, the application may try
744                                                          to resolve this address to find out if the advertising event was
745                                                          directed to us. */
746    uint8_t                   primary_phy;           &bsol;**< Indicates the PHY on which the primary advertising packet was received.
747                                                          See @ref BLE_GAP_PHYS. */
748    uint8_t                   secondary_phy;         &bsol;**< Indicates the PHY on which the secondary advertising packet was received.
749                                                          See @ref BLE_GAP_PHYS. This field is set to @ref BLE_GAP_PHY_NOT_SET if no packets
750                                                          were received on a secondary advertising channel. */
751    int8_t                    tx_power;              &bsol;**< TX Power reported by the advertiser in the last packet header received.
752                                                          This field is set to @ref BLE_GAP_POWER_LEVEL_INVALID if the
753                                                          last received packet did not contain the Tx Power field.
754                                                          @note TX Power is only included in extended advertising packets. */
755    int8_t                    rssi;                  &bsol;**< Received Signal Strength Indication in dBm of the last packet received. */
756    uint8_t                   ch_index;              &bsol;**< Channel Index on which the last advertising packet is received (0-39). */
757    uint8_t                   set_id;                &bsol;**< Set ID of the received advertising data. Set ID is not present
758                                                          if set to @ref BLE_GAP_ADV_REPORT_SET_ID_NOT_AVAILABLE. */
759    uint16_t                  data_id:12;            &bsol;**< The advertising data ID of the received advertising data. Data ID
760                                                          is not present if @ref ble_gap_evt_adv_report_t::set_id is set to
761                                                          @ref BLE_GAP_ADV_REPORT_SET_ID_NOT_AVAILABLE. */
762    ble_data_t                data;                  &bsol;**< Received advertising or scan response data. If
763                                                          @ref ble_gap_adv_report_type_t::status is not set to
764                                                          @ref BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_MORE_DATA, the data buffer provided
765                                                          in @ref sd_ble_gap_scan_start is now released. */
766    ble_gap_aux_pointer_t     aux_pointer;           &bsol;**< The offset and PHY of the next advertising packet in this extended advertising
767                                                          event. @note This field is only set if @ref ble_gap_adv_report_type_t::status
768                                                          is set to @ref BLE_GAP_ADV_DATA_STATUS_INCOMPLETE_MORE_DATA. */
769  } ble_gap_evt_adv_report_t;
770  typedef struct
771  {
772    uint8_t    bond       : 1;                       &bsol;**< Perform bonding. */
773    uint8_t    mitm       : 1;                       &bsol;**< Man In The Middle protection requested. */
774    uint8_t    lesc       : 1;                       &bsol;**< LE Secure Connections requested. */
775    uint8_t    keypress   : 1;                       &bsol;**< Generation of keypress notifications requested. */
776  } ble_gap_evt_sec_request_t;
777  typedef struct
778  {
779    ble_gap_conn_params_t conn_params;            &bsol;**<  GAP Connection Parameters. */
780  } ble_gap_evt_conn_param_update_request_t;
781  typedef struct
782  {
783    uint8_t                 adv_handle;        &bsol;**< Advertising handle for the advertising set which received the Scan Request */
784    int8_t                  rssi;              &bsol;**< Received Signal Strength Indication in dBm. */
785    ble_gap_addr_t          peer_addr;         &bsol;**< Bluetooth address of the peer device. If the peer_addr resolved: @ref ble_gap_addr_t::addr_id_peer is set to 1
786                                                    and the address is the device's identity address. */
787  } ble_gap_evt_scan_req_report_t;
788  typedef struct
789  {
790    ble_gap_data_length_params_t peer_params; &bsol;**< Peer data length parameters. */
791  } ble_gap_evt_data_length_update_request_t;
792  typedef struct
793  {
794    ble_gap_data_length_params_t effective_params;  &bsol;**< The effective data length parameters. */
795  } ble_gap_evt_data_length_update_t;
796  typedef struct
797  {
798    int8_t channel_energy[BLE_GAP_CHANNEL_COUNT]; &bsol;**< The measured energy on the Bluetooth Low Energy
799                                                       channels, in dBm, indexed by Channel Index.
800                                                       If no measurement is available for the given channel, channel_energy is set to
801                                                       @ref BLE_GAP_POWER_LEVEL_INVALID. */
802  } ble_gap_evt_qos_channel_survey_report_t;
803  typedef struct
804  {
805    uint16_t conn_handle;                                     &bsol;**< Connection Handle on which event occurred. */
806    union                                                     &bsol;**< union alternative identified by evt_id in enclosing struct. */
807    {
808      ble_gap_evt_connected_t                   connected;                    &bsol;**< Connected Event Parameters. */
809      ble_gap_evt_disconnected_t                disconnected;                 &bsol;**< Disconnected Event Parameters. */
810      ble_gap_evt_conn_param_update_t           conn_param_update;            &bsol;**< Connection Parameter Update Parameters. */
811      ble_gap_evt_sec_params_request_t          sec_params_request;           &bsol;**< Security Parameters Request Event Parameters. */
812      ble_gap_evt_sec_info_request_t            sec_info_request;             &bsol;**< Security Information Request Event Parameters. */
813      ble_gap_evt_passkey_display_t             passkey_display;              &bsol;**< Passkey Display Event Parameters. */
814      ble_gap_evt_key_pressed_t                 key_pressed;                  &bsol;**< Key Pressed Event Parameters. */
815      ble_gap_evt_auth_key_request_t            auth_key_request;             &bsol;**< Authentication Key Request Event Parameters. */
816      ble_gap_evt_lesc_dhkey_request_t          lesc_dhkey_request;           &bsol;**< LE Secure Connections DHKey calculation request. */
817      ble_gap_evt_auth_status_t                 auth_status;                  &bsol;**< Authentication Status Event Parameters. */
818      ble_gap_evt_conn_sec_update_t             conn_sec_update;              &bsol;**< Connection Security Update Event Parameters. */
819      ble_gap_evt_timeout_t                     timeout;                      &bsol;**< Timeout Event Parameters. */
820      ble_gap_evt_rssi_changed_t                rssi_changed;                 &bsol;**< RSSI Event Parameters. */
821      ble_gap_evt_adv_report_t                  adv_report;                   &bsol;**< Advertising Report Event Parameters. */
822      ble_gap_evt_adv_set_terminated_t          adv_set_terminated;           &bsol;**< Advertising Set Terminated Event Parameters. */
823      ble_gap_evt_sec_request_t                 sec_request;                  &bsol;**< Security Request Event Parameters. */
824      ble_gap_evt_conn_param_update_request_t   conn_param_update_request;    &bsol;**< Connection Parameter Update Parameters. */
825      ble_gap_evt_scan_req_report_t             scan_req_report;              &bsol;**< Scan Request Report Parameters. */
826      ble_gap_evt_phy_update_request_t          phy_update_request;           &bsol;**< PHY Update Request Event Parameters. */
827      ble_gap_evt_phy_update_t                  phy_update;                   &bsol;**< PHY Update Parameters. */
828      ble_gap_evt_data_length_update_request_t  data_length_update_request;   &bsol;**< Data Length Update Request Event Parameters. */
829      ble_gap_evt_data_length_update_t          data_length_update;           &bsol;**< Data Length Update Event Parameters. */
830      ble_gap_evt_qos_channel_survey_report_t   qos_channel_survey_report;    &bsol;**< Quality of Service (QoS) Channel Survey Report Parameters. */
831    } params;                                                                 &bsol;**< Event Parameters. */
832  } ble_gap_evt_t;
833  typedef struct
834  {
835    uint8_t  conn_count;     &bsol;**< The number of concurrent connections the application can create with this configuration.
836                                  The default and minimum value is @ref BLE_GAP_CONN_COUNT_DEFAULT. */
837    uint16_t event_length;   &bsol;**< The time set aside for this connection on every connection interval in 1.25 ms units.
838                                  The default value is @ref BLE_GAP_EVENT_LENGTH_DEFAULT, the minimum value is @ref BLE_GAP_EVENT_LENGTH_MIN.
839                                  The event length and the connection interval are the primary parameters
840                                  for setting the throughput of a connection.
841                                  See the SoftDevice Specification for details on throughput. */
842  } ble_gap_conn_cfg_t;
843  typedef struct
844  {
845    uint8_t adv_set_count;      &bsol;**< Maximum number of advertising sets. Default value is @ref BLE_GAP_ADV_SET_COUNT_DEFAULT. */
846    uint8_t periph_role_count;  &bsol;**< Maximum number of connections concurrently acting as a peripheral. Default value is @ref BLE_GAP_ROLE_COUNT_PERIPH_DEFAULT. */
847    uint8_t central_role_count; &bsol;**< Maximum number of connections concurrently acting as a central. Default value is @ref BLE_GAP_ROLE_COUNT_CENTRAL_DEFAULT. */
848    uint8_t central_sec_count;  &bsol;**< Number of SMP instances shared between all connections acting as a central. Default value is @ref BLE_GAP_ROLE_COUNT_CENTRAL_SEC_DEFAULT. */
849    uint8_t qos_channel_survey_role_available:1; &bsol;**< If set, the Quality of Service (QoS) channel survey module is available to the
850                                                      application using @ref sd_ble_gap_qos_channel_survey_start. */
851  } ble_gap_cfg_role_count_t;
852  typedef struct
853  {
854    ble_gap_conn_sec_mode_t  write_perm;   &bsol;**< Write permissions. */
855    uint8_t                  vloc:2;       &bsol;**< Value location, see @ref BLE_GATTS_VLOCS.*/
856    uint8_t                 *p_value;      &bsol;**< Pointer to where the value (device name) is stored or will be stored. */
857    uint16_t                 current_len;  &bsol;**< Current length in bytes of the memory pointed to by p_value.*/
858    uint16_t                 max_len;      &bsol;**< Maximum length in bytes of the memory pointed to by p_value.*/
859  } ble_gap_cfg_device_name_t;
860  typedef union
861  {
862    ble_gap_cfg_role_count_t  role_count_cfg;  &bsol;**< Role count configuration, cfg_id is @ref BLE_GAP_CFG_ROLE_COUNT. */
863    ble_gap_cfg_device_name_t device_name_cfg; &bsol;**< Device name configuration, cfg_id is @ref BLE_GAP_CFG_DEVICE_NAME. */
864  } ble_gap_cfg_t;
865  typedef struct
866  {
867    uint16_t conn_handle;                   &bsol;**< Connection Handle (only applicable for get) */
868    uint8_t ch_map[5];                      &bsol;**< Channel Map (37-bit). */
869  } ble_gap_opt_ch_map_t;
870  typedef struct
871  {
872    uint16_t   conn_handle;                       &bsol;**< Connection Handle */
873    uint16_t   requested_latency;                 &bsol;**< Requested local connection latency. */
874    uint16_t * p_actual_latency;                  &bsol;**< Pointer to storage for the actual local connection latency (can be set to NULL to skip return value). */
875  } ble_gap_opt_local_conn_latency_t;
876  typedef struct
877  {
878    uint16_t   conn_handle;    &bsol;**< Connection Handle */
879    uint8_t    disable : 1;    &bsol;**< Set to 1 to disable slave latency. Set to 0 enable it again.*/
880  } ble_gap_opt_slave_latency_disable_t;
881  typedef struct
882  {
883    uint8_t const * p_passkey;                    &bsol;**< Pointer to 6-digit ASCII string (digit 0..9 only, no NULL termination) passkey to be used during pairing. If this is NULL, the SoftDevice will generate a random passkey if required.*/
884  } ble_gap_opt_passkey_t;
885  typedef struct
886  {
887     uint8_t enable : 1;                           &bsol;**< Enable compatibility mode 1.*/
888  } ble_gap_opt_compat_mode_1_t;
889  typedef struct
890  {
891    uint16_t   conn_handle;                       &bsol;**< Connection Handle */
892    uint16_t   auth_payload_timeout;              &bsol;**< Requested timeout in 10 ms unit, see @ref BLE_GAP_AUTH_PAYLOAD_TIMEOUT. */
893  } ble_gap_opt_auth_payload_timeout_t;
894  typedef union
895  {
896    ble_gap_opt_ch_map_t                  ch_map;                    &bsol;**< Parameters for the Channel Map option. */
897    ble_gap_opt_local_conn_latency_t      local_conn_latency;        &bsol;**< Parameters for the Local connection latency option */
898    ble_gap_opt_passkey_t                 passkey;                   &bsol;**< Parameters for the Passkey option.*/
899    ble_gap_opt_compat_mode_1_t           compat_mode_1;             &bsol;**< Parameters for the compatibility mode 1 option.*/
900    ble_gap_opt_auth_payload_timeout_t    auth_payload_timeout;      &bsol;**< Parameters for the authenticated payload timeout option.*/
901    ble_gap_opt_slave_latency_disable_t   slave_latency_disable;     &bsol;**< Parameters for the Disable slave latency option */
902  } ble_gap_opt_t;
903  SVCALL(SD_BLE_GAP_ADDR_SET, uint32_t, sd_ble_gap_addr_set(ble_gap_addr_t const *p_addr));
904  SVCALL(SD_BLE_GAP_ADDR_GET, uint32_t, sd_ble_gap_addr_get(ble_gap_addr_t *p_addr));
905  SVCALL(SD_BLE_GAP_ADV_ADDR_GET, uint32_t, sd_ble_gap_adv_addr_get(uint8_t adv_handle, ble_gap_addr_t *p_addr));
906  SVCALL(SD_BLE_GAP_WHITELIST_SET, uint32_t, sd_ble_gap_whitelist_set(ble_gap_addr_t const * const * pp_wl_addrs, uint8_t len));
907  SVCALL(SD_BLE_GAP_DEVICE_IDENTITIES_SET, uint32_t, sd_ble_gap_device_identities_set(ble_gap_id_key_t const * const * pp_id_keys, ble_gap_irk_t const * const * pp_local_irks, uint8_t len));
908  SVCALL(SD_BLE_GAP_PRIVACY_SET, uint32_t, sd_ble_gap_privacy_set(ble_gap_privacy_params_t const *p_privacy_params));
909  SVCALL(SD_BLE_GAP_PRIVACY_GET, uint32_t, sd_ble_gap_privacy_get(ble_gap_privacy_params_t *p_privacy_params));
910  SVCALL(SD_BLE_GAP_ADV_SET_CONFIGURE, uint32_t, sd_ble_gap_adv_set_configure(uint8_t *p_adv_handle, ble_gap_adv_data_t const *p_adv_data, ble_gap_adv_params_t const *p_adv_params));
911  SVCALL(SD_BLE_GAP_ADV_START, uint32_t, sd_ble_gap_adv_start(uint8_t adv_handle, uint8_t conn_cfg_tag));
912  SVCALL(SD_BLE_GAP_ADV_STOP, uint32_t, sd_ble_gap_adv_stop(uint8_t adv_handle));
913  SVCALL(SD_BLE_GAP_CONN_PARAM_UPDATE, uint32_t, sd_ble_gap_conn_param_update(uint16_t conn_handle, ble_gap_conn_params_t const *p_conn_params));
914  SVCALL(SD_BLE_GAP_DISCONNECT, uint32_t, sd_ble_gap_disconnect(uint16_t conn_handle, uint8_t hci_status_code));
915  SVCALL(SD_BLE_GAP_TX_POWER_SET, uint32_t, sd_ble_gap_tx_power_set(uint8_t role, uint16_t handle, int8_t tx_power));
916  SVCALL(SD_BLE_GAP_APPEARANCE_SET, uint32_t, sd_ble_gap_appearance_set(uint16_t appearance));
917  SVCALL(SD_BLE_GAP_APPEARANCE_GET, uint32_t, sd_ble_gap_appearance_get(uint16_t *p_appearance));
918  SVCALL(SD_BLE_GAP_PPCP_SET, uint32_t, sd_ble_gap_ppcp_set(ble_gap_conn_params_t const *p_conn_params));
919  SVCALL(SD_BLE_GAP_PPCP_GET, uint32_t, sd_ble_gap_ppcp_get(ble_gap_conn_params_t *p_conn_params));
920  SVCALL(SD_BLE_GAP_DEVICE_NAME_SET, uint32_t, sd_ble_gap_device_name_set(ble_gap_conn_sec_mode_t const *p_write_perm, uint8_t const *p_dev_name, uint16_t len));
921  SVCALL(SD_BLE_GAP_DEVICE_NAME_GET, uint32_t, sd_ble_gap_device_name_get(uint8_t *p_dev_name, uint16_t *p_len));
922  SVCALL(SD_BLE_GAP_AUTHENTICATE, uint32_t, sd_ble_gap_authenticate(uint16_t conn_handle, ble_gap_sec_params_t const *p_sec_params));
923  SVCALL(SD_BLE_GAP_SEC_PARAMS_REPLY, uint32_t, sd_ble_gap_sec_params_reply(uint16_t conn_handle, uint8_t sec_status, ble_gap_sec_params_t const *p_sec_params, ble_gap_sec_keyset_t const *p_sec_keyset));
924  SVCALL(SD_BLE_GAP_AUTH_KEY_REPLY, uint32_t, sd_ble_gap_auth_key_reply(uint16_t conn_handle, uint8_t key_type, uint8_t const *p_key));
925  SVCALL(SD_BLE_GAP_LESC_DHKEY_REPLY, uint32_t, sd_ble_gap_lesc_dhkey_reply(uint16_t conn_handle, ble_gap_lesc_dhkey_t const *p_dhkey));
926  SVCALL(SD_BLE_GAP_KEYPRESS_NOTIFY, uint32_t, sd_ble_gap_keypress_notify(uint16_t conn_handle, uint8_t kp_not));
927  SVCALL(SD_BLE_GAP_LESC_OOB_DATA_GET, uint32_t, sd_ble_gap_lesc_oob_data_get(uint16_t conn_handle, ble_gap_lesc_p256_pk_t const *p_pk_own, ble_gap_lesc_oob_data_t *p_oobd_own));
928  SVCALL(SD_BLE_GAP_LESC_OOB_DATA_SET, uint32_t, sd_ble_gap_lesc_oob_data_set(uint16_t conn_handle, ble_gap_lesc_oob_data_t const *p_oobd_own, ble_gap_lesc_oob_data_t const *p_oobd_peer));
929  SVCALL(SD_BLE_GAP_ENCRYPT, uint32_t, sd_ble_gap_encrypt(uint16_t conn_handle, ble_gap_master_id_t const *p_master_id, ble_gap_enc_info_t const *p_enc_info));
930  SVCALL(SD_BLE_GAP_SEC_INFO_REPLY, uint32_t, sd_ble_gap_sec_info_reply(uint16_t conn_handle, ble_gap_enc_info_t const *p_enc_info, ble_gap_irk_t const *p_id_info, ble_gap_sign_info_t const *p_sign_info));
931  SVCALL(SD_BLE_GAP_CONN_SEC_GET, uint32_t, sd_ble_gap_conn_sec_get(uint16_t conn_handle, ble_gap_conn_sec_t *p_conn_sec));
932  SVCALL(SD_BLE_GAP_RSSI_START, uint32_t, sd_ble_gap_rssi_start(uint16_t conn_handle, uint8_t threshold_dbm, uint8_t skip_count));
933  SVCALL(SD_BLE_GAP_RSSI_STOP, uint32_t, sd_ble_gap_rssi_stop(uint16_t conn_handle));
934  SVCALL(SD_BLE_GAP_RSSI_GET, uint32_t, sd_ble_gap_rssi_get(uint16_t conn_handle, int8_t *p_rssi, uint8_t *p_ch_index));
935  SVCALL(SD_BLE_GAP_SCAN_START, uint32_t, sd_ble_gap_scan_start(ble_gap_scan_params_t const *p_scan_params, ble_data_t const * p_adv_report_buffer));
936  SVCALL(SD_BLE_GAP_SCAN_STOP, uint32_t, sd_ble_gap_scan_stop(void));
937  SVCALL(SD_BLE_GAP_CONNECT, uint32_t, sd_ble_gap_connect(ble_gap_addr_t const *p_peer_addr, ble_gap_scan_params_t const *p_scan_params, ble_gap_conn_params_t const *p_conn_params, uint8_t conn_cfg_tag));
938  SVCALL(SD_BLE_GAP_CONNECT_CANCEL, uint32_t, sd_ble_gap_connect_cancel(void));
939  SVCALL(SD_BLE_GAP_PHY_UPDATE, uint32_t, sd_ble_gap_phy_update(uint16_t conn_handle, ble_gap_phys_t const *p_gap_phys));
940  SVCALL(SD_BLE_GAP_DATA_LENGTH_UPDATE, uint32_t, sd_ble_gap_data_length_update(uint16_t conn_handle, ble_gap_data_length_params_t const *p_dl_params, ble_gap_data_length_limitation_t *p_dl_limitation));
941  SVCALL(SD_BLE_GAP_QOS_CHANNEL_SURVEY_START, uint32_t, sd_ble_gap_qos_channel_survey_start(uint32_t interval_us));
942  SVCALL(SD_BLE_GAP_QOS_CHANNEL_SURVEY_STOP, uint32_t, sd_ble_gap_qos_channel_survey_stop(void));
943  #ifdef __cplusplus
944  }
945  #endif
946  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-ble_gatt.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-ble_gap.h</div>
                </div>
                <div class="column column_space"><pre><code>107    uint8_t notify          :1; &bsol;**< Notification of the value permitted. */
108    uint8_t indicate        :1; &bsol;**< Indications of the value permitted. */
</pre></code></div>
                <div class="column column_space"><pre><code>695    uint8_t               bonded : 1;             &bsol;**< Procedure resulted in a bond. */
696    uint8_t               lesc : 1;               &bsol;**< Procedure resulted in a LE Secure Connection. */
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    