<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for imdocker.c & omprog.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for imdocker.c & omprog.c
      </h3>
      <h1 align="center">
        8.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>imdocker.c (7.271468%)<TH>omprog.c (11.615045%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1144-0.html#0',2,'match1144-1.html#0',3)" NAME="0">(262-281)<TD><A HREF="javascript:ZweiFrames('match1144-0.html#0',2,'match1144-1.html#0',3)" NAME="0">(132-153)</A><TD ALIGN=center><FONT COLOR="#ff0000">32</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1144-0.html#1',2,'match1144-1.html#1',3)" NAME="1">(858-865)<TD><A HREF="javascript:ZweiFrames('match1144-0.html#1',2,'match1144-1.html#1',3)" NAME="1">(1117-1124)</A><TD ALIGN=center><FONT COLOR="#bf0000">24</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match1144-0.html#2',2,'match1144-1.html#2',3)" NAME="2">(978-995)<TD><A HREF="javascript:ZweiFrames('match1144-0.html#2',2,'match1144-1.html#2',3)" NAME="2">(952-981)</A><TD ALIGN=center><FONT COLOR="#8f0000">18</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match1144-0.html#3',2,'match1144-1.html#3',3)" NAME="3">(905-910)<TD><A HREF="javascript:ZweiFrames('match1144-0.html#3',2,'match1144-1.html#3',3)" NAME="3">(1125-1130)</A><TD ALIGN=center><FONT COLOR="#870000">17</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match1144-0.html#4',2,'match1144-1.html#4',3)" NAME="4">(1487-1506)<TD><A HREF="javascript:ZweiFrames('match1144-0.html#4',2,'match1144-1.html#4',3)" NAME="4">(439-445)</A><TD ALIGN=center><FONT COLOR="#6f0000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>imdocker.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* imdocker.c
 * This is an implementation of the docker container log input module. It uses the
 * Docker API in order to stream all container logs available on a host. Will also
 * update relevant container metadata.
 *
 * Copyright (C) 2018, 2019 the rsyslog project.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifdef __sun
#define _XPG4_2
#endif
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;curl/curl.h&gt;
#include &lt;json.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdbool.h&gt;
#include &quot;cfsysline.h&quot;  /* access to config file objects */
#include &quot;unicode-helper.h&quot;
#include &quot;module-template.h&quot;
#include &quot;srUtils.h&quot;    /* some utility functions */
#include &quot;errmsg.h&quot;
#include &quot;net.h&quot;
#include &quot;glbl.h&quot;
#include &quot;msg.h&quot;
#include &quot;parser.h&quot;
#include &quot;prop.h&quot;
#include &quot;debug.h&quot;
#include &quot;statsobj.h&quot;
#include &quot;datetime.h&quot;
#include &quot;ratelimit.h&quot;
#include &quot;hashtable.h&quot;
#include &quot;hashtable_itr.h&quot;

#if !defined(_AIX)
#pragma GCC diagnostic ignored &quot;-Wswitch-enum&quot;
#endif

MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;imdocker&quot;)

extern int Debug;

#define USE_MULTI_LINE
#undef ENABLE_DEBUG_BYTE_BUFFER

/* defines */
#define DOCKER_TAG_NAME                     &quot;docker:&quot;

#define DOCKER_CONTAINER_ID_PARSE_NAME      &quot;Id&quot;
#define DOCKER_CONTAINER_NAMES_PARSE_NAME   &quot;Names&quot;
#define DOCKER_CONTAINER_IMAGEID_PARSE_NAME &quot;ImageID&quot;
#define DOCKER_CONTAINER_CREATED_PARSE_NAME &quot;Created&quot;
#define DOCKER_CONTAINER_LABELS_PARSE_NAME  &quot;Labels&quot;

/* label defines */
#define DOCKER_CONTAINER_LABEL_KEY_STARTREGEX &quot;imdocker.startregex&quot;

/* DEFAULT VALUES */
#define DFLT_pollingInterval   60      /* polling interval in seconds */
#define DFLT_retrieveNewLogsFromStart 1/* Process newly found containers logs from start */
#define DFLT_containersLimit   25      /* maximum number of containers */
#define DFLT_trimLineOverBytes 4194304 /* limit log lines to the value - 4MB default */
#define DFLT_bEscapeLF         1       /* whether line feeds should be escaped */

#define DFLT_SEVERITY pri2sev(LOG_INFO)
#define DFLT_FACILITY pri2fac(LOG_USER)

enum {
	dst_invalid = -1,
	dst_stdin,
	dst_stdout,
	dst_stderr,
	dst_stream_type_count
} docker_stream_type_t;

/* imdocker specific structs */
typedef struct imdocker_buf_s {
	uchar  *data;
	size_t len;
	size_t data_size;
} imdocker_buf_t;

typedef struct docker_cont_logs_buf_s {
	imdocker_buf_t *buf;
	int8_t         stream_type;
	size_t         bytes_remaining;
} docker_cont_logs_buf_t;

struct docker_cont_logs_inst_s;
typedef rsRetVal (*submitmsg_funcptr) (struct docker_cont_logs_inst_s *pInst, docker_cont_logs_buf_t *pBufdata,
		const uchar* pszTag);
typedef submitmsg_funcptr SubmitMsgFuncPtr;

/* curl request instance */
typedef struct docker_cont_logs_req_s {
	CURL     *curl;
	docker_cont_logs_buf_t* data_bufs[dst_stream_type_count];
	SubmitMsgFuncPtr submitMsg;
} docker_cont_logs_req_t;

typedef struct imdocker_req_s {
	CURL           *curl;
	imdocker_buf_t *buf;
} imdocker_req_t;

typedef struct docker_container_info_s {
	uchar *name;
	uchar *image_id;
	uint64_t created;
	/* json string container labels */
	uchar *json_str_labels;
} docker_container_info_t;

typedef struct docker_cont_logs_inst_s {
	char *id;
	char short_id[12];
	docker_container_info_t *container_info;
	docker_cont_logs_req_t  *logsReq;
	uchar *start_regex;
	regex_t start_preg;  /* compiled version of start_regex */
	uint32_t prevSegEnd;
} docker_cont_logs_inst_t;

typedef struct docker_cont_log_instances_s {
	struct hashtable* ht_container_log_insts;
	pthread_mutex_t mut;
	CURLM         *curlm;
	/* track the latest created container */
	uint64_t last_container_created;
	uchar   *last_container_id;
	time_t  time_started;
} docker_cont_log_instances_t;

/* FORWARD DEFINITIONS */

/* imdocker_buf_t */
static rsRetVal imdockerBufNew(imdocker_buf_t **ppThis);
static void imdockerBufDestruct(imdocker_buf_t *pThis);

/* docker_cont_logs_buf_t */
static rsRetVal dockerContLogsBufNew(docker_cont_logs_buf_t **ppThis);
static void dockerContLogsBufDestruct(docker_cont_logs_buf_t *pThis);
static rsRetVal dockerContLogsBufWrite(docker_cont_logs_buf_t *pThis, const uchar *pdata,
		size_t write_size);

/* imdocker_req_t */
static rsRetVal imdockerReqNew(imdocker_req_t **ppThis);
static void imdockerReqDestruct(imdocker_req_t *pThis);

/* docker_cont_logs_req_t */
static rsRetVal dockerContLogsReqNew(docker_cont_logs_req_t **ppThis, SubmitMsgFuncPtr submitMsg);
static void dockerContLogsReqDestruct(docker_cont_logs_req_t *pThis);

/* docker_cont_logs_inst_t */
static rsRetVal
dockerContLogsInstNew(docker_cont_logs_inst_t **ppThis, const char* id,
		docker_container_info_t *container_info, SubmitMsgFuncPtr submitMsg);

static void dockerContLogsInstDestruct(docker_cont_logs_inst_t *pThis);
static rsRetVal dockerContLogsInstSetUrlById (sbool isInit, docker_cont_logs_inst_t *pThis,
		CURLM *curlm, const char* containerId);

/* docker_cont_log_instances_t */
static rsRetVal dockerContLogReqsNew(docker_cont_log_instances_t **ppThis);
static rsRetVal dockerContLogReqsDestruct(docker_cont_log_instances_t *pThis);
static rsRetVal dockerContLogReqsGet(docker_cont_log_instances_t *pThis,
		docker_cont_logs_inst_t** ppContLogsInst, const char *id);
static rsRetVal dockerContLogReqsPrint(docker_cont_log_instances_t *pThis);
static rsRetVal dockerContLogReqsAdd(docker_cont_log_instances_t *pThis,
		docker_cont_logs_inst_t *pContLogsReqInst);
static rsRetVal dockerContLogReqsRemove(docker_cont_log_instances_t *pThis, const char *id);

/* docker_container_info_t */
static rsRetVal dockerContainerInfoNew(docker_container_info_t **pThis);
static void dockerContainerInfoDestruct(docker_container_info_t *pThis);

/* utility functions */
static CURLcode docker_get(imdocker_req_t *req, const char* url);
static char* dupDockerContainerName(const char* pname);
static rsRetVal SubmitMsg(docker_cont_logs_inst_t *pInst, docker_cont_logs_buf_t *pBufData,
		const uchar* pszTag);
/* support multi-line */
static rsRetVal
SubmitMsg2(docker_cont_logs_inst_t *pInst, docker_cont_logs_buf_t *pBufData, const uchar* pszTag);
static size_t imdocker_container_list_curlCB(void *data, size_t size, size_t nmemb, void *buffer);
static size_t imdocker_container_logs_curlCB(void *data, size_t size, size_t nmemb, void *buffer);
static sbool get_stream_info(const uchar* data, size_t size, int8_t *stream_type, size_t *payload_size);
static int8_t is_valid_stream_type(int8_t stream_type);

/* Module static data */
DEF_IMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(prop)
DEFobjCurrIf(parser)
DEFobjCurrIf(datetime)
DEFobjCurrIf(statsobj)

statsobj_t *modStats;
STATSCOUNTER_DEF(ctrSubmit, mutCtrSubmit)
STATSCOUNTER_DEF(ctrLostRatelimit, mutCtrLostRatelimit)
STATSCOUNTER_DEF(ctrCurlError, mutCtrCurlError)

const char* DFLT_dockerAPIUnixSockAddr  = &quot;/var/run/docker.sock&quot;;
const char* DFLT_dockerAPIAdd           = &quot;http://localhost:2375&quot;;
const char* DFLT_apiVersionStr          = &quot;v1.27&quot;;
const char* DFLT_listContainersOptions  = &quot;&quot;;
const char* DFLT_getContainerLogOptions = &quot;timestamps=0&amp;follow=1&amp;stdout=1&amp;stderr=1&amp;tail=1&quot;;
const char* DFLT_getContainerLogOptionsWithoutTail = &quot;timestamps=0&amp;follow=1&amp;stdout=1&amp;stderr=1&quot;;

/* Overall module configuration structure here. */
struct modConfData_s {
	rsconf_t *pConf;  /* our overall config object */
	uchar    *apiVersionStr;
	uchar    *listContainersOptions;
	uchar    *getContainerLogOptions;
	uchar    *getContainerLogOptionsWithoutTail;
	int      iPollInterval;  /* in seconds */
	uchar    *dockerApiUnixSockAddr;
	uchar    *dockerApiAddr;
	sbool    retrieveNewLogsFromStart;
	int      containersLimit;
	int      trimLineOverBytes;
	int      iDfltSeverity;
	int      iDfltFacility;
	sbool    bEscapeLf;
};

static modConfData_t *loadModConf = NULL;
static modConfData_t *runModConf = NULL;

static prop_t *pInputName = NULL;   /* our inputName currently is always &quot;imdocker&quot;, and this will hold it */
static prop_t *pLocalHostIP = NULL; /* a pseudo-constant propterty for 127.0.0.1 */

static ratelimit_t *ratelimiter = NULL;
<A NAME="0"></A>
/* module-global parameters */
static struct cnfparamdescr modpdescr[] = {
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1144-1.html#0',3,'match1144-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	{ &quot;apiversionstr&quot;, eCmdHdlrString, 0 },
	{ &quot;dockerapiunixsockaddr&quot;, eCmdHdlrString, 0 },
	{ &quot;dockerapiaddr&quot;, eCmdHdlrString, 0 },
	{ &quot;listcontainersoptions&quot;, eCmdHdlrString, 0 },
	{ &quot;getcontainerlogoptions&quot;, eCmdHdlrString, 0 },
	{ &quot;pollinginterval&quot;, eCmdHdlrPositiveInt, 0 },
	{ &quot;retrievenewlogsfromstart&quot;, eCmdHdlrBinary, 0 },
	{ &quot;trimlineoverbytes&quot;, eCmdHdlrPositiveInt, 0 },
	{ &quot;defaultseverity&quot;, eCmdHdlrSeverity, 0 },
	{ &quot;defaultfacility&quot;, eCmdHdlrFacility, 0 },
	{ &quot;escapelf&quot;, eCmdHdlrBinary, 0 },
};

static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
		sizeof(modpdescr)/sizeof(struct cnfparamdescr),
		modpdescr
	};

static int bLegacyCnfModGlobalsPermitted; /* are legacy module-global config parameters permitted? */</B></FONT>

/* imdocker specific functions */
static rsRetVal
imdockerBufNew(imdocker_buf_t **ppThis) {
	DEFiRet;

	imdocker_buf_t *pThis = (imdocker_buf_t*) calloc(1, sizeof(imdocker_buf_t));
	if (!pThis) { return RS_RET_OUT_OF_MEMORY; }
	*ppThis = pThis;

	RETiRet;
}

static void
imdockerBufDestruct(imdocker_buf_t *pThis) {
	if (pThis) {
		if (pThis-&gt;data) {
			free(pThis-&gt;data);
			pThis-&gt;data = NULL;
		}
		free(pThis);
	}
}

static rsRetVal
dockerContLogsBufNew(docker_cont_logs_buf_t **ppThis) {
	DEFiRet;

	docker_cont_logs_buf_t *pThis = (docker_cont_logs_buf_t*) calloc(1, sizeof(docker_cont_logs_buf_t));
	if (pThis &amp;&amp; (iRet = imdockerBufNew(&amp;pThis-&gt;buf)) == RS_RET_OK) {
		pThis-&gt;stream_type = dst_invalid;
		pThis-&gt;bytes_remaining = 0;
		*ppThis = pThis;
	} else {
		dockerContLogsBufDestruct(pThis);
	}

	RETiRet;
}

static void
dockerContLogsBufDestruct(docker_cont_logs_buf_t *pThis) {
	if (pThis) {
		if (pThis-&gt;buf) {
			imdockerBufDestruct(pThis-&gt;buf);
		}
		free(pThis);
	}
}

static rsRetVal
dockerContLogsBufWrite(docker_cont_logs_buf_t *const pThis, const uchar *const pdata, const size_t write_size) {
	DEFiRet;

	imdocker_buf_t *const mem = pThis-&gt;buf;
	if (mem-&gt;len + write_size + 1 &gt; mem-&gt;data_size) {
		uchar *const pbuf = realloc(mem-&gt;data, mem-&gt;len + write_size + 1);
		if(pbuf == NULL) {
			LogError(errno, RS_RET_ERR, &quot;%s() - realloc failed!\n&quot;, __FUNCTION__);
			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
		}
		mem-&gt;data = pbuf;
		mem-&gt;data_size = mem-&gt;len+ write_size + 1;
	}
	/* copy the bytes, and advance pdata */
	memcpy(&amp;(mem-&gt;data[mem-&gt;len]), pdata, write_size);
	mem-&gt;len += write_size;
	mem-&gt;data[mem-&gt;len] = '\0';

	if (write_size &gt; pThis-&gt;bytes_remaining) {
		pThis-&gt;bytes_remaining = 0;
	} else {
		pThis-&gt;bytes_remaining -= write_size;
	}

finalize_it:
	RETiRet;
}

rsRetVal imdockerReqNew(imdocker_req_t **ppThis) {
	DEFiRet;

	imdocker_req_t *pThis = (imdocker_req_t*) calloc(1, sizeof(imdocker_req_t));
	CHKmalloc(pThis);
	pThis-&gt;curl = curl_easy_init();
	if (!pThis-&gt;curl) {
		ABORT_FINALIZE(RS_RET_ERR);
	}

	CHKiRet(imdockerBufNew(&amp;(pThis-&gt;buf)));
	*ppThis = pThis;

finalize_it:
	if (iRet != RS_RET_OK &amp;&amp; pThis) {
		imdockerReqDestruct(pThis);
	}
	RETiRet;
}

void imdockerReqDestruct(imdocker_req_t *pThis) {
	if (pThis) {
		if (pThis-&gt;buf) {
			imdockerBufDestruct(pThis-&gt;buf);
		}

		if (pThis-&gt;curl) {
			curl_easy_cleanup(pThis-&gt;curl);
			pThis-&gt;curl = NULL;
		}
		free(pThis);
	}
}

static rsRetVal
dockerContLogsReqNew(docker_cont_logs_req_t **ppThis, SubmitMsgFuncPtr submitMsg) {
	DEFiRet;

	docker_cont_logs_req_t *pThis = (docker_cont_logs_req_t*) calloc(1, sizeof(docker_cont_logs_req_t));
	CHKmalloc(pThis);
	pThis-&gt;submitMsg = submitMsg;
	pThis-&gt;curl = curl_easy_init();
	if (!pThis-&gt;curl) {
		ABORT_FINALIZE(RS_RET_ERR);
	}

	for (int i = 0; i &lt; dst_stream_type_count; i ++) {
		CHKiRet(dockerContLogsBufNew(&amp;pThis-&gt;data_bufs[i]));
	}

	*ppThis = pThis;

finalize_it:
	if (iRet != RS_RET_OK) {
		if (pThis) {
			dockerContLogsReqDestruct(pThis);
		}
	}
	RETiRet;
}

static void
dockerContLogsReqDestruct(docker_cont_logs_req_t *pThis) {
	if (pThis) {
		for (int i = 0; i &lt; dst_stream_type_count; i++) {
			dockerContLogsBufDestruct(pThis-&gt;data_bufs[i]);
		}

		if (pThis-&gt;curl) {
			curl_easy_cleanup(pThis-&gt;curl);
			pThis-&gt;curl=NULL;
		}

		free(pThis);
	}
}

/**
 * debugging aide
 */
static rsRetVal
dockerContLogsInstPrint(docker_cont_logs_inst_t * pThis) {
	DEFiRet;
	DBGPRINTF(&quot;\t container id: %s\n&quot;, pThis-&gt;id);
	char* pUrl = NULL;
	curl_easy_getinfo(pThis-&gt;logsReq-&gt;curl, CURLINFO_EFFECTIVE_URL, &amp;pUrl);
	DBGPRINTF(&quot;\t container url: %s\n&quot;, pUrl);

	RETiRet;
}

static void
dockerContLogsInstDestruct(docker_cont_logs_inst_t *pThis) {
	if (pThis) {
		if (pThis-&gt;id) {
			free((void*)pThis-&gt;id);
		}
		if (pThis-&gt;container_info) {
			dockerContainerInfoDestruct(pThis-&gt;container_info);
		}
		if (pThis-&gt;logsReq) {
			dockerContLogsReqDestruct(pThis-&gt;logsReq);
		}
		if (pThis-&gt;start_regex) {
			free(pThis-&gt;start_regex);
			regfree(&amp;pThis-&gt;start_preg);
		}
		free(pThis);
	}
}

static rsRetVal
parseLabels(docker_cont_logs_inst_t *inst, const uchar* json) {
	DEFiRet;

	/* parse out if we need to do special handling for mult-line */
	DBGPRINTF(&quot;%s() - parsing json=%s\n&quot;, __FUNCTION__, json);

	struct fjson_object *json_obj = fjson_tokener_parse((const char*)json);
	struct fjson_object_iterator it = fjson_object_iter_begin(json_obj);
	struct fjson_object_iterator itEnd = fjson_object_iter_end(json_obj);
	while (!fjson_object_iter_equal(&amp;it, &amp;itEnd)) {
		if (Debug) {
			DBGPRINTF(&quot;%s - \t%s: '%s'\n&quot;,
					__FUNCTION__,
					fjson_object_iter_peek_name(&amp;it),
					fjson_object_get_string(fjson_object_iter_peek_value(&amp;it)));
		}

		if (strcmp(fjson_object_iter_peek_name(&amp;it), DOCKER_CONTAINER_LABEL_KEY_STARTREGEX) == 0) {
			inst-&gt;start_regex = (uchar*)strdup(fjson_object_get_string(fjson_object_iter_peek_value(&amp;it)));
			// compile the regex for future use.
			int err = regcomp(&amp;inst-&gt;start_preg, fjson_object_get_string(fjson_object_iter_peek_value(&amp;it)),
					REG_EXTENDED);
			if (err != 0) {
				char errbuf[512];
				regerror(err, &amp;inst-&gt;start_preg, errbuf, sizeof(errbuf));
				LogError(0, err, &quot;%s() - error in startregex compile: %s&quot;, __FUNCTION__, errbuf);
				ABORT_FINALIZE(RS_RET_ERR);
			}
		}
		fjson_object_iter_next(&amp;it);
	}

finalize_it:
	if (json_obj) {
		json_object_put(json_obj);
	}
	RETiRet;
}

static rsRetVal
dockerContLogsInstNew(docker_cont_logs_inst_t **ppThis, const char* id,
		docker_container_info_t *container_info, SubmitMsgFuncPtr submitMsg) {
	DEFiRet;

	docker_cont_logs_inst_t *pThis = NULL;
	CHKmalloc(pThis = calloc(1, sizeof(docker_cont_logs_inst_t)));

	pThis-&gt;id = strdup((char*)id);
	strncpy((char*) pThis-&gt;short_id, id, sizeof(pThis-&gt;short_id)-1);
	CHKiRet(dockerContLogsReqNew(&amp;pThis-&gt;logsReq, submitMsg));
	/* make a copy */
	if (container_info) {
		CHKiRet(dockerContainerInfoNew(&amp;pThis-&gt;container_info));
		if (container_info-&gt;image_id) {
			pThis-&gt;container_info-&gt;image_id = (uchar*)strdup((char*)container_info-&gt;image_id);
		}
		if (container_info-&gt;name) {
			const char *pname = (const char*)container_info-&gt;name;
			/* removes un-needed characters */
			pThis-&gt;container_info-&gt;name = (uchar*)dupDockerContainerName(pname);
		}
		if (container_info-&gt;json_str_labels) {
			pThis-&gt;container_info-&gt;json_str_labels =
				(uchar*)strdup((char*)container_info-&gt;json_str_labels);
		}
		pThis-&gt;container_info-&gt;created = container_info-&gt;created;
	}
	pThis-&gt;start_regex = NULL;
	pThis-&gt;prevSegEnd = 0;
	/* initialize based on labels found */
	if (pThis-&gt;container_info &amp;&amp; pThis-&gt;container_info-&gt;json_str_labels) {
		parseLabels(pThis, pThis-&gt;container_info-&gt;json_str_labels);
	}

	*ppThis = pThis;

finalize_it:
	if (iRet != RS_RET_OK) {
		if (pThis) {
			dockerContLogsInstDestruct(pThis);
		}
	}
	RETiRet;
}

static rsRetVal
dockerContLogsInstSetUrl(docker_cont_logs_inst_t *pThis, CURLM *curlm, const char* pUrl) {
	DEFiRet;
	CURLcode ccode = CURLE_OK;
	CURLMcode mcode = CURLM_OK;

	if (curlm) {
		docker_cont_logs_req_t *req = pThis-&gt;logsReq;
		if (!runModConf-&gt;dockerApiAddr) {
			ccode = curl_easy_setopt(req-&gt;curl, CURLOPT_UNIX_SOCKET_PATH,
					runModConf-&gt;dockerApiUnixSockAddr);
			if (ccode != CURLE_OK) {
				LogError(0, RS_RET_ERR,
						&quot;imdocker: curl_easy_setopt(CURLOPT_UNIX_SOCKET_PATH) error - %d:%s\n&quot;,
						ccode, curl_easy_strerror(ccode));
				ABORT_FINALIZE(RS_RET_ERR);
			}
		}
		ccode = curl_easy_setopt(req-&gt;curl, CURLOPT_WRITEFUNCTION, imdocker_container_logs_curlCB);
		if (ccode != CURLE_OK) {
				LogError(0, RS_RET_ERR,
						&quot;imdocker: curl_easy_setopt(CURLOPT_WRITEFUNCTION) error - %d:%s\n&quot;,
						ccode, curl_easy_strerror(ccode));
				ABORT_FINALIZE(RS_RET_ERR);
		}

		ccode = curl_easy_setopt(req-&gt;curl, CURLOPT_WRITEDATA, pThis);
		if (ccode != CURLE_OK) {
				LogError(0, RS_RET_ERR, &quot;imdocker: curl_easy_setopt(CURLOPT_WRITEDATA) error - %d:%s\n&quot;,
						ccode, curl_easy_strerror(ccode));
				ABORT_FINALIZE(RS_RET_ERR);
		}

		ccode = curl_easy_setopt(pThis-&gt;logsReq-&gt;curl, CURLOPT_URL, pUrl);
		if (ccode != CURLE_OK) {
			LogError(0, RS_RET_ERR, &quot;imdocker: could not set url - %d:%s\n&quot;,
					ccode, curl_easy_strerror(ccode));
			ABORT_FINALIZE(RS_RET_ERR);
		}

		ccode = curl_easy_setopt(pThis-&gt;logsReq-&gt;curl, CURLOPT_PRIVATE, pThis-&gt;id);
		if (ccode != CURLE_OK) {
			LogError(0, RS_RET_ERR, &quot;imdocker: could not set private data - %d:%s\n&quot;,
					ccode, curl_easy_strerror(ccode));
			ABORT_FINALIZE(RS_RET_ERR);
		}

		mcode = curl_multi_add_handle(curlm, pThis-&gt;logsReq-&gt;curl);
		if (mcode != CURLM_OK) {
			LogError(0, RS_RET_ERR, &quot;imdocker: error curl_multi_add_handle ret- %d:%s\n&quot;,
					mcode, curl_multi_strerror(mcode));
			ABORT_FINALIZE(RS_RET_ERR);
		}
	}

finalize_it:
	if (ccode != CURLE_OK) {
		STATSCOUNTER_INC(ctrCurlError, mutCtrCurlError);
	}
	RETiRet;
}

static rsRetVal
dockerContLogsInstSetUrlById (sbool isInit, docker_cont_logs_inst_t *pThis, CURLM *curlm,
		const char* containerId) {
	char url[256];
	const uchar* container_log_options = runModConf-&gt;getContainerLogOptionsWithoutTail;

	if (isInit || !runModConf-&gt;retrieveNewLogsFromStart) {
		container_log_options = runModConf-&gt;getContainerLogOptions;
	}

	const uchar* pApiAddr = (uchar*)&quot;http:&quot;;
	if (runModConf-&gt;dockerApiAddr) {
		pApiAddr = runModConf-&gt;dockerApiAddr;
	}

	snprintf(url, sizeof(url), &quot;%s/%s/containers/%s/logs?%s&quot;,
			pApiAddr, runModConf-&gt;apiVersionStr, containerId, container_log_options);
	DBGPRINTF(&quot;%s() - url: %s\n&quot;, __FUNCTION__, url);

	return dockerContLogsInstSetUrl(pThis, curlm, url);
}

/* special destructor for hashtable object. */
static void
dockerContLogReqsDestructForHashtable(void *pData) {
	docker_cont_logs_inst_t *pThis = (docker_cont_logs_inst_t *) pData;
	dockerContLogsInstDestruct(pThis);
}

static rsRetVal
dockerContLogReqsNew(docker_cont_log_instances_t **ppThis) {
	DEFiRet;

	docker_cont_log_instances_t *pThis = calloc(1, sizeof(docker_cont_log_instances_t));
	CHKmalloc(pThis);
	CHKmalloc(pThis-&gt;ht_container_log_insts =
			create_hashtable(7, hash_from_string, key_equals_string,
				dockerContLogReqsDestructForHashtable));

	CHKiConcCtrl(pthread_mutex_init(&amp;pThis-&gt;mut, NULL));

	pThis-&gt;curlm = curl_multi_init();
	if (!pThis-&gt;curlm) {
		ABORT_FINALIZE(RS_RET_ERR);
	}

	*ppThis = pThis;

finalize_it:
	if (iRet != RS_RET_OK) {
		if (pThis) {
			dockerContLogReqsDestruct(pThis);
		}
	}
	RETiRet;
}

static rsRetVal
dockerContLogReqsDestruct(docker_cont_log_instances_t *pThis) {
	DEFiRet;

	if (pThis) {
		if (pThis-&gt;ht_container_log_insts) {
			pthread_mutex_lock(&amp;pThis-&gt;mut);
			hashtable_destroy(pThis-&gt;ht_container_log_insts, 1);
			pthread_mutex_unlock(&amp;pThis-&gt;mut);
		}
		if (pThis-&gt;last_container_id) {
			free(pThis-&gt;last_container_id);
		}
		curl_multi_cleanup(pThis-&gt;curlm);
		pthread_mutex_destroy(&amp;pThis-&gt;mut);
		free(pThis);
	}

	RETiRet;
}

/* NOTE: not thread safe - used internally to update container log requests */
static rsRetVal
dockerContLogReqsGet(docker_cont_log_instances_t *pThis,
		docker_cont_logs_inst_t** ppContLogsInst, const char *id) {
	DEFiRet;

	if (ppContLogsInst &amp;&amp; id) {
		docker_cont_logs_inst_t *pSearchObj = hashtable_search(pThis-&gt;ht_container_log_insts, (void*)id);
		if (!pSearchObj) {
			return RS_RET_NOT_FOUND;
		}
		*ppContLogsInst = pSearchObj;
	}

	RETiRet;
}

/* debug print
 *
 * NOTE: not thread safe
 *
 */
static rsRetVal
dockerContLogReqsPrint(docker_cont_log_instances_t *pThis) {
	DEFiRet;
	int count = 0;

	count = hashtable_count(pThis-&gt;ht_container_log_insts);
	if (count) {
		int ret = 0;
		struct hashtable_itr *itr = hashtable_iterator(pThis-&gt;ht_container_log_insts);

		DBGPRINTF(&quot;%s() - All container instances, count=%d...\n&quot;, __FUNCTION__, count);
		do {
			docker_cont_logs_inst_t *pObj = hashtable_iterator_value(itr);
			dockerContLogsInstPrint(pObj);
			ret = hashtable_iterator_advance(itr);
		} while (ret);
		free (itr);
		DBGPRINTF(&quot;End of container instances.\n&quot;);
	}

	RETiRet;
}

/* NOTE: not thread safe */
static rsRetVal
dockerContLogReqsAdd(docker_cont_log_instances_t *pThis,
		docker_cont_logs_inst_t *pContLogsReqInst)
{
	DEFiRet;
	if (!pContLogsReqInst) {
		return RS_RET_ERR;
	}

	uchar *keyName = (uchar*)strdup((char*)pContLogsReqInst-&gt;id);

	if (keyName) {
		docker_cont_logs_inst_t *pFind;
		if (RS_RET_NOT_FOUND == dockerContLogReqsGet(pThis, &amp;pFind, (void*)keyName)) {
			if (!hashtable_insert(pThis-&gt;ht_container_log_insts, keyName, pContLogsReqInst)) {
				ABORT_FINALIZE(RS_RET_ERR);
			}
			keyName = NULL;
		}
	}
finalize_it:
	free(keyName);
	RETiRet;
}

static rsRetVal
dockerContLogReqsRemove(docker_cont_log_instances_t *pThis, const char *id) {
	DEFiRet;

	if (pThis &amp;&amp; id) {
		CHKiConcCtrl(pthread_mutex_lock(&amp;pThis-&gt;mut));
		docker_cont_logs_inst_t *pRemoved =
			hashtable_remove(pThis-&gt;ht_container_log_insts, (void*)id);
		pthread_mutex_unlock(&amp;pThis-&gt;mut);
		if (pRemoved) {
			dockerContLogsInstDestruct(pRemoved);
		} else {
			iRet = RS_RET_NOT_FOUND;
		}
	}
finalize_it:
	RETiRet;
}

static rsRetVal
dockerContainerInfoNew(docker_container_info_t **ppThis) {
	DEFiRet;
	docker_container_info_t* pThis = calloc(1, sizeof(docker_container_info_t));
	CHKmalloc(pThis);
	*ppThis = pThis;

finalize_it:
	RETiRet;
}

static void
dockerContainerInfoDestruct(docker_container_info_t *pThis) {
	if (pThis) {
		if (pThis-&gt;image_id) { free(pThis-&gt;image_id); }
		if (pThis-&gt;name) { free(pThis-&gt;name); }
		if (pThis-&gt;json_str_labels) { free(pThis-&gt;json_str_labels); }
		free(pThis);
	}
}

BEGINbeginCnfLoad
CODESTARTbeginCnfLoad

	dbgprintf(&quot;imdocker: beginCnfLoad\n&quot;);

	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;

	/* init our settings */
	loadModConf-&gt;iPollInterval     = DFLT_pollingInterval; /* in seconds */
	loadModConf-&gt;retrieveNewLogsFromStart  = DFLT_retrieveNewLogsFromStart;
	loadModConf-&gt;containersLimit   = DFLT_containersLimit;
	loadModConf-&gt;trimLineOverBytes = DFLT_trimLineOverBytes;
	loadModConf-&gt;bEscapeLf         = DFLT_bEscapeLF;

	/* Use the default url */
	loadModConf-&gt;apiVersionStr          = NULL;
	loadModConf-&gt;dockerApiUnixSockAddr  = NULL;
	loadModConf-&gt;dockerApiAddr          = NULL;
	loadModConf-&gt;listContainersOptions  = NULL;
	loadModConf-&gt;getContainerLogOptions = NULL;
	loadModConf-&gt;getContainerLogOptionsWithoutTail = NULL;
	loadModConf-&gt;iDfltFacility = DFLT_FACILITY;
	loadModConf-&gt;iDfltSeverity = DFLT_SEVERITY;
ENDbeginCnfLoad

BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;error processing module &quot;
				&quot;config parameters [module(...)]&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if (Debug) {
		dbgprintf(&quot;module (global) param blk for imdocker:\n&quot;);
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		dbgprintf(&quot;%s() - iteration %d\n&quot;, __FUNCTION__,i);
		dbgprintf(&quot;%s() - modpblk descr: %s\n&quot;, __FUNCTION__, modpblk.descr[i].name);
		if(!pvals[i].bUsed)
<A NAME="1"></A>			continue;
		if(!strcmp(modpblk.descr[i].name, &quot;pollinginterval&quot;)) {
			loadModConf-&gt;iPollInterval = (int) pvals[i].val.d.n;
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1144-1.html#1',3,'match1144-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		} else if(!strcmp(modpblk.descr[i].name, &quot;containterlimit&quot;)) {
			loadModConf-&gt;containersLimit = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;trimlineoverbytes&quot;)) {
			loadModConf-&gt;trimLineOverBytes = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;listcontainersoptions&quot;)) {
			loadModConf-&gt;listContainersOptions = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, &quot;getcontainerlogoptions&quot;)) {
			loadModConf-&gt;getContainerLogOptions = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
			/* also intialize the non-tail version */
			size_t offset = 0;
			char buf[256];
			size_t buf_size = sizeof(buf);
			strncpy(buf, (char*)loadModConf-&gt;getContainerLogOptions, buf_size-1);
			size_t option_str_len = strlen((char*)loadModConf-&gt;getContainerLogOptions);
			uchar *option_str = calloc(1, option_str_len);
			CHKmalloc(option_str);

			const char *search_str = &quot;tail=&quot;;
			size_t search_str_len = strlen(search_str);
			char *token = strtok(buf, &quot;&amp;&quot;);

			while (token != NULL) {
				if (strncmp(token, search_str, search_str_len) == 0) {
					token = strtok(NULL, &quot;&amp;&quot;);
					continue;
				}
				int len = strlen(token);
				if (offset + len + 1 &gt;= option_str_len) {
					break;
				}
				int bytes = snprintf((char*)option_str + offset,
						(option_str_len - offset), &quot;%s&amp;&quot;, token);
				if (bytes &lt;= 0) {
					break;
				}
				offset += bytes;
				token = strtok(NULL, &quot;&amp;&quot;);
			}
			loadModConf-&gt;getContainerLogOptionsWithoutTail = option_str;
		} else if(!strcmp(modpblk.descr[i].name, &quot;dockerapiunixsockaddr&quot;)) {
			loadModConf-&gt;dockerApiUnixSockAddr = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, &quot;dockerapiaddr&quot;)) {
			loadModConf-&gt;dockerApiAddr = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, &quot;apiversionstr&quot;)) {
<A NAME="3"></A>			loadModConf-&gt;apiVersionStr = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, &quot;retrievenewlogsfromstart&quot;)) {
			loadModConf-&gt;retrieveNewLogsFromStart = (sbool) pvals[i].val.d.n;
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match1144-1.html#3',3,'match1144-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		} else if (!strcmp(modpblk.descr[i].name, &quot;defaultseverity&quot;)) {
			loadModConf-&gt;iDfltSeverity = (int) pvals[i].val.d.n;
		} else if (!strcmp(modpblk.descr[i].name, &quot;defaultfacility&quot;)) {
			loadModConf-&gt;iDfltFacility = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;escapelf&quot;)) {
			loadModConf-&gt;bEscapeLf = (sbool) pvals[i].val.d.n;</B></FONT>
		} else {
			LogError(0, RS_RET_INVALID_PARAMS,
					&quot;imdocker: program error, non-handled &quot;
					&quot;param '%s' in setModCnf\n&quot;, modpblk.descr[i].name);
		}
	}

	/* disable legacy module-global config directives */
	bLegacyCnfModGlobalsPermitted = 0;

finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf

BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
	if (!loadModConf-&gt;dockerApiUnixSockAddr) {
		loadModConf-&gt;dockerApiUnixSockAddr = (uchar*) strdup(DFLT_dockerAPIUnixSockAddr);
	}
	if (!loadModConf-&gt;apiVersionStr) {
		loadModConf-&gt;apiVersionStr = (uchar*) strdup(DFLT_apiVersionStr);
	}
	if (!loadModConf-&gt;listContainersOptions) {
		loadModConf-&gt;listContainersOptions = (uchar*) strdup(DFLT_listContainersOptions);
	}
	if (!loadModConf-&gt;getContainerLogOptions) {
		loadModConf-&gt;getContainerLogOptions = (uchar*) strdup(DFLT_getContainerLogOptions);
	}
if (!loadModConf-&gt;getContainerLogOptionsWithoutTail) {
		loadModConf-&gt;getContainerLogOptionsWithoutTail =
			(uchar*) strdup(DFLT_getContainerLogOptionsWithoutTail);
	}
	runModConf = loadModConf;

	/* support statistics gathering */
	CHKiRet(statsobj.Construct(&amp;modStats));
	CHKiRet(statsobj.SetName(modStats, UCHAR_CONSTANT(&quot;imdocker&quot;)));
	CHKiRet(statsobj.SetOrigin(modStats, UCHAR_CONSTANT(&quot;imdocker&quot;)));

	STATSCOUNTER_INIT(ctrSubmit, mutCtrSubmit);
	CHKiRet(statsobj.AddCounter(modStats, UCHAR_CONSTANT(&quot;submitted&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrSubmit));

	STATSCOUNTER_INIT(ctrLostRatelimit, mutCtrLostRatelimit);
	CHKiRet(statsobj.AddCounter(modStats, UCHAR_CONSTANT(&quot;ratelimit.discarded&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrLostRatelimit));

	STATSCOUNTER_INIT(ctrCurlError, mutCtrCurlError);
	CHKiRet(statsobj.AddCounter(modStats, UCHAR_CONSTANT(&quot;curl.errors&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrCurlError));

	CHKiRet(statsobj.ConstructFinalize(modStats));
	/* end stats */
finalize_it:
ENDactivateCnf
<A NAME="2"></A>
BEGINfreeCnf
CODESTARTfreeCnf
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match1144-1.html#2',3,'match1144-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	if (loadModConf-&gt;dockerApiUnixSockAddr) {
		free(loadModConf-&gt;dockerApiUnixSockAddr);
	}
	if (loadModConf-&gt;dockerApiAddr) {
		free(loadModConf-&gt;dockerApiAddr);
	}
	if (loadModConf-&gt;apiVersionStr) {
		free(loadModConf-&gt;apiVersionStr);
	}
	if (loadModConf-&gt;getContainerLogOptions) {
		free(loadModConf-&gt;getContainerLogOptions);
	}
	if (loadModConf-&gt;getContainerLogOptionsWithoutTail) {
		free(loadModConf-&gt;getContainerLogOptionsWithoutTail);
	}
	if (loadModConf-&gt;listContainersOptions) {
		free(loadModConf-&gt;listContainersOptions);
	}</B></FONT>
	statsobj.Destruct(&amp;modStats);
ENDfreeCnf

static rsRetVal
addDockerMetaData(const uchar* container_id, docker_container_info_t* pinfo, smsg_t *pMsg) {
	const uchar *names[4] = {
		(const uchar*) DOCKER_CONTAINER_ID_PARSE_NAME,
		(const uchar*) DOCKER_CONTAINER_NAMES_PARSE_NAME,
		(const uchar*) DOCKER_CONTAINER_IMAGEID_PARSE_NAME,
		(const uchar*) DOCKER_CONTAINER_LABELS_PARSE_NAME
	};

	const uchar * empty_str= (const uchar*) &quot;&quot;;
	const uchar *id = container_id ? container_id : empty_str;
	const uchar *name = pinfo-&gt;name ? pinfo-&gt;name : empty_str;
	const uchar *image_id = pinfo-&gt;image_id ? pinfo-&gt;image_id : empty_str;
	const uchar *json_str_labels = pinfo-&gt;json_str_labels ? pinfo-&gt;json_str_labels : empty_str;

	const uchar *values[4] = {
		id,
		name,
		image_id,
		json_str_labels
	};

	return msgAddMultiMetadata(pMsg, names, values, 4);
}

static rsRetVal
enqMsg(docker_cont_logs_inst_t *pInst, uchar *msg, size_t len, const uchar *pszTag,
		int facility, int severity, struct timeval *tp)
{
	struct syslogTime st;
	smsg_t *pMsg;
	DEFiRet;

	if (!msg) {
		return RS_RET_ERR;
	}

	if (tp == NULL) {
		CHKiRet(msgConstruct(&amp;pMsg));
	} else {
		datetime.timeval2syslogTime(tp, &amp;st, TIME_IN_LOCALTIME);
		CHKiRet(msgConstructWithTime(&amp;pMsg, &amp;st, tp-&gt;tv_sec));
	}
	MsgSetFlowControlType(pMsg, eFLOWCTL_LIGHT_DELAY);
	MsgSetInputName(pMsg, pInputName);
	MsgSetRawMsg(pMsg, (char*)msg, len);

	if (loadModConf-&gt;bEscapeLf) {
		parser.SanitizeMsg(pMsg);
	} else {
		/* Perform some of the SanitizeMsg operations here - specifically:
		 * - remove NULL character at end of message.
		 * - drop trailing LFs.
		 * See SanitizeMsg() for more info.
		 */
		size_t lenMsg = pMsg-&gt;iLenRawMsg;
		uchar *pszMsg = pMsg-&gt;pszRawMsg;

		if(pszMsg[lenMsg-1] == '\0') {
			DBGPRINTF(&quot;dropped NULL at very end of message\n&quot;);
			lenMsg--;
		}

		if(glbl.GetParserDropTrailingLFOnReception(loadModConf-&gt;pConf)
				&amp;&amp; lenMsg &gt; 0 &amp;&amp; pszMsg[lenMsg-1] == '\n') {
			DBGPRINTF(&quot;dropped LF at very end of message (DropTrailingLF is set)\n&quot;);
			lenMsg--;
			pszMsg[lenMsg] = '\0';
		}
		pMsg-&gt;iLenRawMsg = lenMsg;
	}

	MsgSetMSGoffs(pMsg, 0);  /* we do not have a header... */
	MsgSetRcvFrom(pMsg, glbl.GetLocalHostNameProp());
	if (pLocalHostIP) { MsgSetRcvFromIP(pMsg, pLocalHostIP); }
	MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
	MsgSetTAG(pMsg, pszTag, ustrlen(pszTag));
	pMsg-&gt;iFacility = facility;
	pMsg-&gt;iSeverity = severity;

	/* docker container metadata */
	addDockerMetaData((const uchar*)pInst-&gt;short_id, pInst-&gt;container_info, pMsg);

	const char *name = (const char*)pInst-&gt;container_info-&gt;name;
	DBGPRINTF(&quot;imdocker: %s - %s:%s\n&quot;, __FUNCTION__, name, msg);
	CHKiRet(ratelimitAddMsg(ratelimiter, NULL, pMsg));
	STATSCOUNTER_INC(ctrSubmit, mutCtrSubmit);

finalize_it:
	if (iRet == RS_RET_DISCARDMSG)
		STATSCOUNTER_INC(ctrLostRatelimit, mutCtrLostRatelimit)

	RETiRet;
}

static int8_t
is_valid_stream_type(int8_t stream_type) {
	return (dst_invalid &lt; stream_type &amp;&amp; stream_type &lt; dst_stream_type_count);
}

/* For use to get docker specific stream information */
static sbool
get_stream_info(const uchar* data, size_t size, int8_t *stream_type, size_t *payload_size) {
	if (size &lt; 8 || !data || !stream_type || !payload_size) {
		return 0;
	}
	const uchar* pdata = data;
	*stream_type = pdata[0];
	pdata += 4;
	uint32_t len = 0;
	memcpy(&amp;len, pdata, sizeof(len));
	*payload_size = ntohl(len);
	return 1;
}
#ifdef ENABLE_DEBUG_BYTE_BUFFER
static void debug_byte_buffer(const uchar* data, size_t size) {
	if (Debug) {
		DBGPRINTF(&quot;%s() - ENTER, size=%lu\n&quot;, __FUNCTION__, size);
		for (size_t i = 0; i &lt; size; i++) {
			DBGPRINTF(&quot;0x%02x,&quot;, data[i]);
		}
		DBGPRINTF(&quot;\n&quot;);
	}
}
#endif

/**
 * imdocker_container_list_curlCB
 *
 * Callback function for CURLOPT_WRITEFUNCTION to get
 * the results of a docker api call to list all containers.
 *
 */
static size_t
imdocker_container_list_curlCB(void *data, size_t size, size_t nmemb, void *buffer) {
	DEFiRet;

	size_t realsize = size*nmemb;
	uchar		*pbuf=NULL;
	imdocker_buf_t *mem = (imdocker_buf_t*)buffer;

	if ((pbuf = realloc(mem-&gt;data, mem-&gt;len + realsize + 1)) == NULL) {
		LogError(errno, RS_RET_ERR, &quot;%s() - realloc failed!\n&quot;, __FUNCTION__);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	mem-&gt;data = pbuf;
	mem-&gt;data_size = mem-&gt;len + realsize + 1;

	memcpy(&amp;(mem-&gt;data[mem-&gt;len]), data, realsize);
	mem-&gt;len += realsize;
	mem-&gt;data[mem-&gt;len] = 0;

#ifdef ENABLE_DEBUG_BYTE_BUFFER
	debug_byte_buffer((const uchar*) data, realsize);
#endif
finalize_it:
	if (iRet != RS_RET_OK) {
		return 0;
	}
	return realsize;
}

static rsRetVal
SubmitMultiLineMsg(docker_cont_logs_inst_t *pInst, docker_cont_logs_buf_t *pBufData,
		const uchar* pszTag, size_t len) {
	DEFiRet;

	imdocker_buf_t *mem = (imdocker_buf_t*)pBufData-&gt;buf;
	DBGPRINTF(&quot;%s() {type=%d, len=%u} %s\n&quot;,
			__FUNCTION__, pBufData-&gt;stream_type, (unsigned int)mem-&gt;len, mem-&gt;data);

	uchar* message = (uchar*)mem-&gt;data;
	int facility = loadModConf-&gt;iDfltFacility;
	int severity = pBufData-&gt;stream_type == dst_stderr ? LOG_ERR : loadModConf-&gt;iDfltSeverity;
	enqMsg(pInst, message, len, (const uchar*)pszTag, facility, severity, NULL);

	size_t size = mem-&gt;len - pInst-&gt;prevSegEnd;
	memmove(mem-&gt;data, mem-&gt;data+pInst-&gt;prevSegEnd, size);
	mem-&gt;data[len] = '\0';
	mem-&gt;len = size;
	pBufData-&gt;bytes_remaining = 0;

	RETiRet;
}

static rsRetVal
SubmitMsgWithStartRegex(docker_cont_logs_inst_t *pInst, docker_cont_logs_buf_t *pBufData, const uchar* pszTag) {
	imdocker_buf_t *mem = (imdocker_buf_t*)pBufData-&gt;buf;
	/* must be null terminated string */
	assert(mem-&gt;data[mem-&gt;len] == 0 || mem-&gt;data[mem-&gt;len] == '\0');
	const char* thisLine = (const char*) mem-&gt;data;

	if (pInst-&gt;prevSegEnd) {
		thisLine = (const char*) mem-&gt;data+pInst-&gt;prevSegEnd;
	}
	DBGPRINTF(&quot;prevSeg: %d, thisLine: '%s'\n&quot;, pInst-&gt;prevSegEnd, thisLine);
	DBGPRINTF(&quot;line(s) so far: '%s'\n&quot;, mem-&gt;data);

	/* check if this line is a start of multi-line message */
	regex_t *start_preg = (pInst-&gt;start_regex == NULL) ? NULL : &amp;pInst-&gt;start_preg;
	const int isStartMatch = start_preg ?
		!regexec(start_preg, (char*)thisLine, 0, NULL, 0) : 0;

	if (isStartMatch &amp;&amp; pInst-&gt;prevSegEnd != 0) {
		SubmitMultiLineMsg(pInst, pBufData, pszTag, pInst-&gt;prevSegEnd);
		pInst-&gt;prevSegEnd = 0;
		FINALIZE;
	} else {
		/* just continue parsing using same buffer */
		pInst-&gt;prevSegEnd = mem-&gt;len;
	}

finalize_it:
	return RS_RET_OK;
}

static rsRetVal
SubmitMsg2(docker_cont_logs_inst_t *pInst, docker_cont_logs_buf_t *pBufData, const uchar* pszTag) {
	imdocker_buf_t *mem = (imdocker_buf_t*)pBufData-&gt;buf;
	DBGPRINTF(&quot;%s() - {type=%d, len=%u} %s\n&quot;,
			__FUNCTION__, pBufData-&gt;stream_type, (unsigned int)mem-&gt;len, mem-&gt;data);

	if (pInst-&gt;start_regex) {
		SubmitMsgWithStartRegex(pInst, pBufData, pszTag);
	} else {
		SubmitMsg(pInst, pBufData, pszTag);
	}
	return RS_RET_OK;
}

static rsRetVal
SubmitMsg(docker_cont_logs_inst_t *pInst, docker_cont_logs_buf_t *pBufData, const uchar* pszTag) {
	imdocker_buf_t *mem = (imdocker_buf_t*)pBufData-&gt;buf;
	DBGPRINTF(&quot;%s() - {type=%d, len=%u} %s\n&quot;,
			__FUNCTION__, pBufData-&gt;stream_type, (unsigned int)mem-&gt;len, mem-&gt;data);

	uchar* message = mem-&gt;data;
	int facility = loadModConf-&gt;iDfltFacility;
	int severity = pBufData-&gt;stream_type == dst_stderr ? LOG_ERR : loadModConf-&gt;iDfltSeverity;
	enqMsg(pInst, message, mem-&gt;len, (const uchar*)pszTag, facility, severity, NULL);

	/* clear existing buffer. */
	mem-&gt;len = 0;
	memset(mem-&gt;data, 0, mem-&gt;data_size);
	pBufData-&gt;bytes_remaining = 0;

	return RS_RET_OK;
}

/** imdocker_container_logs_curlCB
 *
 * Callback function for CURLOPT_WRITEFUNCTION, gets container logs
 *
 * The main container log stream handler. This function is registerred with curl to
 * as callback to handle container log streaming. It follows the docker stream protocol
 * as described in the docker container logs api. As per docker's api documentation,
 * Docker Stream format:
 * When the TTY setting is disabled in POST /containers/create, the stream over the
 * hijacked connected is multiplexed to separate out stdout and stderr. The stream
 * consists of a series of frames, each containing a header and a payload.
 *
 * The header contains the information which the stream writes (stdout or stderr). It also
 * contains the size of the associated frame encoded in the last four bytes (uint32).
 *
 * It is encoded on the first eight bytes like this:
 *
 * header := [8]byte{STREAM_TYPE, 0, 0, 0, SIZE1, SIZE2, SIZE3, SIZE4}
 * STREAM_TYPE can be:
 * 0: stdin (is written on stdout)
 * 1: stdout
 * 2: stderr
 *
 * Docker sends out data in 16KB sized frames, however with the addition of a header
 * of 8 bytes, a frame may be split into 2 chunks by curl. The 2nd chunk will only
 * contain enough data to complete the frame (8 leftever bytes). Including the header,
 * this amounts to 16 bytes; 8 bytes for the header, and 8 bytes for the remaining frame
 * data.
 *
 */
static size_t
imdocker_container_logs_curlCB(void *data, size_t size, size_t nmemb, void *buffer) {
	DEFiRet;

	const uint8_t frame_size = 8;
	const char imdocker_eol_char = '\n';
	int8_t stream_type = dst_invalid;

	docker_cont_logs_inst_t* pInst = (docker_cont_logs_inst_t*) buffer;
	docker_cont_logs_req_t* req = pInst-&gt;logsReq;

	size_t realsize = size*nmemb;
	const uchar* pdata = data;
	size_t write_size = 0;

#ifdef ENABLE_DEBUG_BYTE_BUFFER
	debug_byte_buffer((const uchar*) data, realsize);
#endif

	if (req-&gt;data_bufs[dst_stdout]-&gt;bytes_remaining || req-&gt;data_bufs[dst_stderr]-&gt;bytes_remaining) {
		/* on continuation, stream types should matches with previous */
		if (req-&gt;data_bufs[dst_stdout]-&gt;bytes_remaining) {
			if (req-&gt;data_bufs[dst_stderr]-&gt;bytes_remaining != 0) {
				ABORT_FINALIZE(RS_RET_ERR);
			}
		} else if (req-&gt;data_bufs[dst_stderr]-&gt;bytes_remaining) {
			if (req-&gt;data_bufs[dst_stdout]-&gt;bytes_remaining != 0) {
				ABORT_FINALIZE(RS_RET_ERR);
			}
		}

		stream_type = req-&gt;data_bufs[dst_stdout]-&gt;bytes_remaining ? dst_stdout : dst_stderr;
		docker_cont_logs_buf_t *pDataBuf = req-&gt;data_bufs[stream_type];

		/* read off the remaining bytes */
		DBGPRINTF(&quot;Chunk continuation, remaining bytes: type: %d, &quot;
				&quot;bytes remaining: %u, realsize: %u, data pos: %u\n&quot;,
				stream_type, (unsigned int)pDataBuf-&gt;bytes_remaining,
				(unsigned int)realsize, (unsigned int)pDataBuf-&gt;buf-&gt;len);

		write_size = MIN(pDataBuf-&gt;bytes_remaining, realsize);
		CHKiRet(dockerContLogsBufWrite(pDataBuf, pdata, write_size));

		/* submit it */
		if (pDataBuf-&gt;bytes_remaining == 0) {
			imdocker_buf_t *mem = pDataBuf-&gt;buf;
			if (mem-&gt;data[mem-&gt;len-1] == imdocker_eol_char) {
				const char* szContainerId = NULL;
				CURLcode ccode;
				if(CURLE_OK != (ccode = curl_easy_getinfo(req-&gt;curl,
								CURLINFO_PRIVATE,
								&amp;szContainerId))) {
					LogError(0, RS_RET_ERR,
							&quot;imdocker: could not get private data req[%p] - %d:%s\n&quot;,
							req-&gt;curl, ccode, curl_easy_strerror(ccode));
					ABORT_FINALIZE(RS_RET_ERR);
				}
				req-&gt;submitMsg(pInst, pDataBuf, (const uchar*)DOCKER_TAG_NAME);
			}
		}

		pdata += write_size;
	}

	/* not enough room left */
	if ((size_t)(pdata - (const uchar*)data) &gt;= realsize) {
		return (pdata - (const uchar*)data);
	}

	size_t payload_size = 0;
	const uchar* pread = pdata + frame_size;
	docker_cont_logs_buf_t* pDataBuf = NULL;

	if (get_stream_info(pdata, realsize, &amp;stream_type, &amp;payload_size)
				&amp;&amp; is_valid_stream_type(stream_type)) {
		pDataBuf = req-&gt;data_bufs[stream_type];
		pDataBuf-&gt;stream_type = stream_type;
		pDataBuf-&gt;bytes_remaining = payload_size;
		write_size = MIN(payload_size, realsize - frame_size);
	} else {
		/* copy all the data and submit to prevent data loss */
		stream_type = req-&gt;data_bufs[dst_stderr]-&gt;bytes_remaining ? dst_stderr : dst_stdout;

		pDataBuf = req-&gt;data_bufs[stream_type];
		pDataBuf-&gt;stream_type = stream_type;

		/* just write everything out */
		pDataBuf-&gt;bytes_remaining = 0;
		write_size = realsize;
		pread = pdata;
	}

	/* allocate the expected payload size */
	CHKiRet(dockerContLogsBufWrite(pDataBuf, pread, write_size));
	if (pDataBuf-&gt;bytes_remaining == 0) {
		DBGPRINTF(&quot;%s() - write size is same as payload_size\n&quot;, __FUNCTION__);
		req-&gt;submitMsg(pInst, pDataBuf, (const uchar*)DOCKER_TAG_NAME);
	}

finalize_it:
	if (iRet != RS_RET_OK) {
		return 0;
	}
	return realsize;
}

CURLcode docker_get(imdocker_req_t *req, const char* url) {
	CURLcode ccode;

	if (!runModConf-&gt;dockerApiAddr) {
		if ((ccode = curl_easy_setopt(req-&gt;curl, CURLOPT_UNIX_SOCKET_PATH, runModConf-&gt;dockerApiUnixSockAddr))
				!= CURLE_OK) {
			STATSCOUNTER_INC(ctrCurlError, mutCtrCurlError);
			LogError(0, RS_RET_ERR, &quot;imdocker: curl_easy_setopt(CURLOPT_UNIX_SOCKET_PATH) error - %d:%s\n&quot;,
					ccode, curl_easy_strerror(ccode));
			return ccode;
		}
	}
	if ((ccode = curl_easy_setopt(req-&gt;curl, CURLOPT_WRITEFUNCTION, imdocker_container_list_curlCB)) != CURLE_OK) {
		STATSCOUNTER_INC(ctrCurlError, mutCtrCurlError);
		LogError(0, RS_RET_ERR, &quot;imdocker: curl_easy_setopt(CURLOPT_WRITEFUNCTION) error - %d:%s\n&quot;,
				ccode, curl_easy_strerror(ccode));
		return ccode;
	}
	if ((ccode = curl_easy_setopt(req-&gt;curl, CURLOPT_WRITEDATA, req-&gt;buf)) != CURLE_OK) {
		STATSCOUNTER_INC(ctrCurlError, mutCtrCurlError);
		LogError(0, RS_RET_ERR, &quot;imdocker: curl_easy_setopt(CURLOPT_WRITEDATA) error - %d:%s\n&quot;,
				ccode, curl_easy_strerror(ccode));
		return ccode;
	}

	if ((ccode = curl_easy_setopt(req-&gt;curl, CURLOPT_URL, url)) != CURLE_OK) {
		STATSCOUNTER_INC(ctrCurlError, mutCtrCurlError);
		LogError(0, RS_RET_ERR, &quot;imdocker: curl_easy_setopt(CURLOPT_URL) error - %d:%s\n&quot;,
				ccode, curl_easy_strerror(ccode));
		return ccode;
	}
	CURLcode response = curl_easy_perform(req-&gt;curl);

	return response;
}

static char*
dupDockerContainerName(const char* pname) {
	int len = strlen(pname);
	if (len &gt;= 2 &amp;&amp; *pname == '/') {
		/* skip '/' character */
		return strdup(pname+1);
	} else {
		return strdup(pname);
	}
}

static rsRetVal
process_json(sbool isInit, const char* json, docker_cont_log_instances_t *pInstances) {
	DEFiRet;
	struct fjson_object *json_obj = NULL;
	int mut_locked = 0;
	DBGPRINTF(&quot;%s() - parsing json=%s\n&quot;, __FUNCTION__, json);

	if (!pInstances) {
		ABORT_FINALIZE(RS_RET_OK);
	}

	json_obj = fjson_tokener_parse(json);
	if (!json_obj || !fjson_object_is_type(json_obj, fjson_type_array)) {
		ABORT_FINALIZE(RS_RET_OK);
	}

	int length = fjson_object_array_length(json_obj);
	/* LOCK the update process. */
	CHKiConcCtrl(pthread_mutex_lock(&amp;pInstances-&gt;mut));
	mut_locked = 1;

	for (int i = 0; i &lt; length; i++) {
		fjson_object* p_json_elm = json_object_array_get_idx(json_obj, i);

		DBGPRINTF(&quot;element: %d...\n&quot;, i);
		if (p_json_elm) {
			const char *containerId=NULL;
			docker_container_info_t containerInfo = {
				.name=NULL,
				.image_id=NULL,
				.created=0,
				.json_str_labels=NULL
			};

			struct fjson_object_iterator it = fjson_object_iter_begin(p_json_elm);
			struct fjson_object_iterator itEnd = fjson_object_iter_end(p_json_elm);
			while (!fjson_object_iter_equal(&amp;it, &amp;itEnd)) {
				if (Debug) {
					DBGPRINTF(&quot;\t%s: '%s'\n&quot;,
							fjson_object_iter_peek_name(&amp;it),
							fjson_object_get_string(fjson_object_iter_peek_value(&amp;it)));
				}

				if (strcmp(fjson_object_iter_peek_name(&amp;it), DOCKER_CONTAINER_ID_PARSE_NAME) == 0) {
					containerId =
						fjson_object_get_string(fjson_object_iter_peek_value(&amp;it));
				} else if (strcmp(fjson_object_iter_peek_name(&amp;it),
							DOCKER_CONTAINER_NAMES_PARSE_NAME) == 0) {
					int names_array_length =
						fjson_object_array_length(fjson_object_iter_peek_value(&amp;it));
					if (names_array_length) {
						fjson_object* names_elm =
<A NAME="4"></A>							json_object_array_get_idx(fjson_object_iter_peek_value(&amp;it), 0);
						containerInfo.name = (uchar*)fjson_object_get_string(names_elm);
					}
<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match1144-1.html#4',3,'match1144-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>				} else if (strcmp(fjson_object_iter_peek_name(&amp;it),
							DOCKER_CONTAINER_IMAGEID_PARSE_NAME) == 0) {
					containerInfo.image_id =
						(uchar*)fjson_object_get_string(
									fjson_object_iter_peek_value(&amp;it)
									);
				} else if (strcmp(fjson_object_iter_peek_name(&amp;it),
							DOCKER_CONTAINER_CREATED_PARSE_NAME) == 0) {
					containerInfo.created =
						fjson_object_get_int64(
									fjson_object_iter_peek_value(&amp;it)
									);
				} else if (strcmp(fjson_object_iter_peek_name(&amp;it),
							DOCKER_CONTAINER_LABELS_PARSE_NAME) == 0) {
					containerInfo.json_str_labels =
						(uchar*) fjson_object_get_string(
									fjson_object_iter_peek_value(&amp;it)
									);
					DBGPRINTF(&quot;labels: %s\n&quot;, containerInfo.json_str_labels);
				}</B></FONT>
				fjson_object_iter_next(&amp;it);
			}

			if (containerId) {
				docker_cont_logs_inst_t *pInst = NULL;
				iRet = dockerContLogReqsGet(pInstances, &amp;pInst, containerId);
				if (iRet == RS_RET_NOT_FOUND) {
#ifdef USE_MULTI_LINE
					if (dockerContLogsInstNew(&amp;pInst, containerId, &amp;containerInfo, SubmitMsg2)
#else
					if (dockerContLogsInstNew(&amp;pInst, containerId, &amp;containerInfo, SubmitMsg)
#endif
							== RS_RET_OK) {
						if (pInstances-&gt;last_container_created &lt; containerInfo.created) {
							pInstances-&gt;last_container_created = containerInfo.created;
							if (pInstances-&gt;last_container_id) {
								free(pInstances-&gt;last_container_id);
							}
							pInstances-&gt;last_container_id = (uchar*)strdup(containerId);
							DBGPRINTF(&quot;last_container_id updated: ('%s', %u)\n&quot;,
									pInstances-&gt;last_container_id,
									(unsigned)pInstances-&gt;last_container_created);
						}
						CHKiRet(dockerContLogsInstSetUrlById(isInit, pInst,
									pInstances-&gt;curlm, containerId));
						CHKiRet(dockerContLogReqsAdd(pInstances, pInst));
					}
				}
			}
		}
	}

finalize_it:
	if (mut_locked) {
		pthread_mutex_unlock(&amp;pInstances-&gt;mut);
	}
	if (json_obj) {
		json_object_put(json_obj);
	}
	RETiRet;
}

static rsRetVal
getContainerIds(sbool isInit, docker_cont_log_instances_t *pInstances, const char* url) {
	DEFiRet;
	imdocker_req_t *req=NULL;

	CHKiRet(imdockerReqNew(&amp;req));

	CURLcode response = docker_get(req, url);
	if (response != CURLE_OK) {
		DBGPRINTF(&quot;%s() - curl response: %d\n&quot;, __FUNCTION__, response);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	CHKiRet(process_json(isInit, (const char*)req-&gt;buf-&gt;data, pInstances));

finalize_it:
	if (req) {
		imdockerReqDestruct(req);
	}
	RETiRet;
}

static rsRetVal
getContainerIdsAndAppend(sbool isInit, docker_cont_log_instances_t *pInstances) {
	DEFiRet;

	char url[256];
	const uchar* pApiAddr = (uchar*)&quot;http:&quot;;

	if (runModConf-&gt;dockerApiAddr) {
		pApiAddr = runModConf-&gt;dockerApiAddr;
	}

	/*
	 * TODO: consider if we really need 'isInit' parameter. I suspect we don't need it
	 * and i'm almost certain Travis CI will complain its not used.
	 */
	if (pInstances-&gt;last_container_id) {
		snprintf(url, sizeof(url), &quot;%s/%s/containers/json?%s&amp;filters={\&quot;since\&quot;:[\&quot;%s\&quot;]}&quot;,
				pApiAddr, runModConf-&gt;apiVersionStr, runModConf-&gt;listContainersOptions,
				pInstances-&gt;last_container_id);
	} else {
		snprintf(url, sizeof(url), &quot;%s/%s/containers/json?%s&quot;,
			pApiAddr, runModConf-&gt;apiVersionStr, runModConf-&gt;listContainersOptions);
	}
	DBGPRINTF(&quot;listcontainers url: %s\n&quot;, url);

	CHKiRet(getContainerIds(isInit, pInstances, (const char*)url));
	if (Debug) { dockerContLogReqsPrint(pInstances); }

finalize_it:
	RETiRet;
}

static void
cleanupCompletedContainerRequests(docker_cont_log_instances_t *pInstances) {
	// clean up
	int rc=0, msgs_left=0;
	CURLMsg *msg=NULL;
	CURL *pCurl;

	while ((msg = curl_multi_info_read(pInstances-&gt;curlm, &amp;msgs_left))) {
		if (msg-&gt;msg == CURLMSG_DONE) {
			pCurl = msg-&gt;easy_handle;
			rc = msg-&gt;data.result;
			if (rc != CURLE_OK) {
				STATSCOUNTER_INC(ctrCurlError, mutCtrCurlError);
				LogError(0, RS_RET_ERR, &quot;imdocker: %s() - curl error code: %d:%s\n&quot;,
						__FUNCTION__, rc, curl_multi_strerror(rc));
				continue;
			}

			CURLcode ccode;
			if (Debug) {
				long http_status=0;
				curl_easy_getinfo(pCurl, CURLINFO_RESPONSE_CODE, &amp;http_status);
				DBGPRINTF(&quot;http status: %lu\n&quot;, http_status);
			}
			curl_multi_remove_handle(pInstances-&gt;curlm, pCurl);

			const char* szContainerId = NULL;
			if ((ccode = curl_easy_getinfo(pCurl, CURLINFO_PRIVATE, &amp;szContainerId)) == CURLE_OK) {
				DBGPRINTF(&quot;container disconnected: %s\n&quot;, szContainerId);
				dockerContLogReqsRemove(pInstances, szContainerId);
				DBGPRINTF(&quot;container removed...\n&quot;);
			} else {
				LogError(0, RS_RET_ERR, &quot;imdocker: private data not found &quot;
						&quot;curl_easy_setopt(CURLINFO_PRIVATE) error - %d:%s\n&quot;,
						ccode, curl_easy_strerror(ccode));
				STATSCOUNTER_INC(ctrCurlError, mutCtrCurlError);
			}
		}
	}
}

static rsRetVal
processAndPollContainerLogs(docker_cont_log_instances_t *pInstances) {
	DEFiRet;
	int count=0;

	count = hashtable_count(pInstances-&gt;ht_container_log_insts);
	DBGPRINTF(&quot;%s() - container instances: %d\n&quot;, __FUNCTION__, count);

	int still_running=0;

	curl_multi_perform(pInstances-&gt;curlm, &amp;still_running);
	do {
		int numfds = 0;

		int res = curl_multi_wait(pInstances-&gt;curlm, NULL, 0, 1000, &amp;numfds);
		if (res != CURLM_OK) {
			LogError(0, RS_RET_ERR, &quot;error: curl_multi_wait() numfds=%d, res=%d:%s\n&quot;,
					numfds, res, curl_multi_strerror(res));
			return res;
		}

		int prev_still_running = still_running;
		curl_multi_perform(pInstances-&gt;curlm, &amp;still_running);

		if (prev_still_running &gt; still_running) {
			cleanupCompletedContainerRequests(pInstances);
		}

	} while (still_running &amp;&amp; glbl.GetGlobalInputTermState() == 0);

	cleanupCompletedContainerRequests(pInstances);

	RETiRet;
}

static void*
getContainersTask(void *pdata) {
	docker_cont_log_instances_t *pInstances = (docker_cont_log_instances_t*) pdata;

	while(glbl.GetGlobalInputTermState() == 0) {
		srSleep(runModConf-&gt;iPollInterval, 10);
		getContainerIdsAndAppend(false, pInstances);
	}
	return pdata;
}

/* This function is called to gather input. */
BEGINrunInput
	rsRetVal localRet = RS_RET_OK;
	docker_cont_log_instances_t *pInstances=NULL;
	pthread_t thrd_id; /* the worker's thread ID */
	pthread_attr_t thrd_attr;
	int get_containers_thread_initialized = 0;
	time_t now;
CODESTARTrunInput
	datetime.GetTime(&amp;now);

	CHKiRet(ratelimitNew(&amp;ratelimiter, &quot;imdocker&quot;, NULL));
	curl_global_init(CURL_GLOBAL_ALL);
	localRet = dockerContLogReqsNew(&amp;pInstances);
	if (localRet != RS_RET_OK) {
		return localRet;
	}
	pInstances-&gt;time_started = now;

	/* get all current containers now */
	CHKiRet(getContainerIdsAndAppend(true, pInstances));

	/* using default stacksize */
	CHKiConcCtrl(pthread_attr_init(&amp;thrd_attr));
	CHKiConcCtrl(pthread_create(&amp;thrd_id, &amp;thrd_attr, getContainersTask, pInstances));
	get_containers_thread_initialized = 1;

	while(glbl.GetGlobalInputTermState() == 0) {
		CHKiRet(processAndPollContainerLogs(pInstances));
		if (glbl.GetGlobalInputTermState() == 0) {
			/* exited from processAndPollContainerLogs, sleep before retrying */
			srSleep(1, 10);
		}
	}

finalize_it:
	if (get_containers_thread_initialized) {
		pthread_kill(thrd_id, SIGTTIN);
		pthread_join(thrd_id, NULL);
		pthread_attr_destroy(&amp;thrd_attr);
	}
	if (pInstances) {
		dockerContLogReqsDestruct(pInstances);
	}
	if (ratelimiter) {
		ratelimitDestruct(ratelimiter);
	}
ENDrunInput

BEGINwillRun
CODESTARTwillRun
ENDwillRun

BEGINafterRun
CODESTARTafterRun
ENDafterRun

BEGINmodExit
CODESTARTmodExit
	if(pInputName != NULL)
		prop.Destruct(&amp;pInputName);

	if(pLocalHostIP != NULL)
		prop.Destruct(&amp;pLocalHostIP);

	objRelease(parser, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
	objRelease(statsobj, CORE_COMPONENT);
	objRelease(datetime, CORE_COMPONENT);
ENDmodExit

BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature

BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt

BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr

	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	CHKiRet(objUse(parser, CORE_COMPONENT));

	DBGPRINTF(&quot;imdocker version %s initializing\n&quot;, VERSION);

	/* we need to create the inputName property (only once during our lifetime) */
	CHKiRet(prop.Construct(&amp;pInputName));
	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT(&quot;imdocker&quot;), sizeof(&quot;imdocker&quot;) - 1));
	CHKiRet(prop.ConstructFinalize(pInputName));

ENDmodInit
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>omprog.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* omprog.c
 * This output plugin enables rsyslog to execute a program and
 * feed it the message stream as standard input.
 *
 * NOTE: read comments in module-template.h for more specifics!
 *
 * File begun on 2009-04-01 by RGerhards
 *
 * Copyright 2009-2020 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &lt;stdio.h&gt;
#include &lt;syslog.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;pthread.h&gt;
#include &lt;poll.h&gt;

#include &quot;rsyslog.h&quot;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;template.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;glbl.h&quot;
#include &quot;rsconf.h&quot;

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;omprog&quot;)

extern char **environ; /* POSIX environment ptr, by std not in a header... (see man 7 environ) */

/* internal structures
 */
DEF_OMOD_STATIC_DATA

#define NO_HUP_FORWARD -1	/* indicates that HUP should NOT be forwarded */
#define DEFAULT_CONFIRM_TIMEOUT_MS 10000
#define DEFAULT_CLOSE_TIMEOUT_MS 5000
#define RESPONSE_LINE_BUFFER_SIZE 4096
#define OUTPUT_CAPTURE_BUFFER_SIZE 4096
#define MAX_FD_TO_CLOSE 65535

typedef struct childProcessCtx {
	int bIsRunning;		/* is the program running? (if 0, next fields are uninitialized) */
	pid_t pid;			/* pid of currently running child process */
	int fdPipeOut;		/* fd for sending messages to the program */
	int fdPipeIn;		/* fd for receiving status messages from the program, or -1 */
} childProcessCtx_t;

typedef struct outputCaptureCtx {
	uchar *szFileName;		/* name of file to write the program output to, or NULL */
	mode_t fCreateMode;		/* output file creation permissions */
	pthread_mutex_t mutStart;	/* mutex for starting the output-capture thread */
	pthread_mutex_t mutWrite;	/* mutex for reopening the output file on HUP while being written */
	pthread_mutex_t mutTerm;	/* mutex for signaling the termination of the thread */
	pthread_cond_t condTerm;	/* condition for signaling the termination of the thread */
	int bIsRunning;			/* is the thread running? (if 0, next fields are uninitialized) */
	pthread_t thrdID;		/* ID of the output-capture thread */
	int fdPipe[2];			/* pipe for capturing the output of the child processes */
	int fdFile;				/* fd of the output file (-1 if it could not be opened) */
	int bFileErr;			/* file open error occurred? (to avoid reporting too many errors) */
	int bReadErr;			/* read error occurred? (to avoid reporting too many errors) */
	int bWriteErr;			/* write error occurred? (to avoid reporting too many errors) */
} outputCaptureCtx_t;

typedef struct _instanceData {
	uchar *szBinary;		/* name of external program to call */
	char **aParams;			/* optional parameters to pass to external program */
	int iParams;			/* holds the count of parameters if set */
	uchar *szTemplateName;	/* assigned output template */
	int bConfirmMessages;	/* does the program provide feedback via stdout? */
	long lConfirmTimeout;	/* how long to wait for feedback from the program (ms) */
	int bReportFailures;	/* report failures returned by the program as warning logs? */
	int bUseTransactions;	/* send begin/end transaction marks to program? */
	uchar *szBeginTransactionMark;	/* mark message for begin transaction */
	uchar *szCommitTransactionMark;	/* mark message for commit transaction */
	int iHUPForward;		/* signal to forward on HUP (or NO_HUP_FORWARD) */
	int bSignalOnClose;		/* should send SIGTERM to program before closing pipe? */
	long lCloseTimeout;		/* how long to wait for program to terminate after closing pipe (ms) */
	int bKillUnresponsive;	/* should send SIGKILL if closeTimeout is reached? */
	int bForceSingleInst;	/* start only one instance of program, even with multiple workers? */
	childProcessCtx_t *pSingleChildCtx;		/* child process context when bForceSingleInst=true */
	pthread_mutex_t *pSingleChildMut;		/* mutex for interacting with single child process */
	outputCaptureCtx_t *pOutputCaptureCtx;	/* settings and state for the output capture thread */
	time_t block_if_err;			/* time until which interface error is not to be shown */
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
	childProcessCtx_t *pChildCtx;	/* child process context (can be equal to pSingleChildCtx) */
} wrkrInstanceData_t;

typedef struct configSettings_s {
	uchar *szBinary;	/* name of external program to call */
} configSettings_t;
static configSettings_t cs;

/* tables for interfacing with the v6 config system */
/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
	{ &quot;binary&quot;, eCmdHdlrString, CNFPARAM_REQUIRED },
<A NAME="0"></A>	{ &quot;confirmMessages&quot;, eCmdHdlrBinary, 0 },
	{ &quot;confirmTimeout&quot;, eCmdHdlrInt, 0 },
	{ &quot;reportFailures&quot;, eCmdHdlrBinary, 0 },
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1144-0.html#0',2,'match1144-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	{ &quot;useTransactions&quot;, eCmdHdlrBinary, 0 },
	{ &quot;beginTransactionMark&quot;, eCmdHdlrString, 0 },
	{ &quot;commitTransactionMark&quot;, eCmdHdlrString, 0 },
	{ &quot;forceSingleInstance&quot;, eCmdHdlrBinary, 0 },
	{ &quot;hup.signal&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;template&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;signalOnClose&quot;, eCmdHdlrBinary, 0 },
	{ &quot;closeTimeout&quot;, eCmdHdlrInt, 0 },
	{ &quot;killUnresponsive&quot;, eCmdHdlrBinary, 0 },
	{ &quot;output&quot;, eCmdHdlrString, 0 },
	{ &quot;fileCreateMode&quot;, eCmdHdlrFileCreateMode, 0 }
};

static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};

/* execute the external program (must be called in child context after fork).
 */
static __attribute__((noreturn)) void</B></FONT>
execBinary(const instanceData *pData, int fdStdin, int fdStdout)
{
	int fdOutput, maxFd, fd, sigNum;
	struct sigaction sigAct;
	sigset_t sigSet;
	char errStr[1024];

	if(dup2(fdStdin, STDIN_FILENO) == -1) {
		goto failed;
	}

	if(pData-&gt;pOutputCaptureCtx != NULL) {
		fdOutput = pData-&gt;pOutputCaptureCtx-&gt;fdPipe[1];
	} else {
		fdOutput = open(&quot;/dev/null&quot;, O_WRONLY);
		if(fdOutput == -1) {
			goto failed;
		}
	}

	if(fdStdout != -1) {
		/* confirmMessages enabled: redirect stdout to parent via pipe. After
		 * this point, anything written to the child's stdout will be treated
		 * by omprog as initialization feedback (see startChild). This
		 * includes debug messages (DBGPRINTF) when in debug mode. So we
		 * cannot use DBGPRINTF from this point on, except for error cases.
		 */
		if(dup2(fdStdout, STDOUT_FILENO) == -1) {
			goto failed;
		}
	} else {
		/* confirmMessages disabled: redirect stdout to file or /dev/null */
		if(dup2(fdOutput, STDOUT_FILENO) == -1) {
			goto failed;
		}
	}

	/* redirect stderr to file or /dev/null */
	if(dup2(fdOutput, STDERR_FILENO) == -1) {
		goto failed;
	}

	/* close the file handles the child process doesn't need (all above STDERR).
	 * The following way is simple and portable, though not perfect.
	 * See https://stackoverflow.com/a/918469 for alternatives.
	 */
	maxFd = sysconf(_SC_OPEN_MAX);
	if(maxFd &lt; 0 || maxFd &gt; MAX_FD_TO_CLOSE) {
		maxFd = MAX_FD_TO_CLOSE;
	}
#	ifdef VALGRIND
	else {  /* don't close valgrind reserved fds, to avoid warnings */
		maxFd -= 10;
	}
#	endif
	for(fd = STDERR_FILENO + 1 ; fd &lt;= maxFd ; ++fd) {
		close(fd);
	}

	/* reset signal handlers to default */
	memset(&amp;sigAct, 0, sizeof(sigAct));
	sigemptyset(&amp;sigAct.sa_mask);
	sigAct.sa_handler = SIG_DFL;
	for(sigNum = 1 ; sigNum &lt; NSIG ; ++sigNum) {
		sigaction(sigNum, &amp;sigAct, NULL);
	}

	/* we need to block SIGINT, otherwise our program is cancelled when we are
	 * stopped in debug mode.
	 */
	sigAct.sa_handler = SIG_IGN;
	sigaction(SIGINT, &amp;sigAct, NULL);
	sigemptyset(&amp;sigSet);
	sigprocmask(SIG_SETMASK, &amp;sigSet, NULL);

	alarm(0);

	/* finally exec program */
	execve((char*)pData-&gt;szBinary, pData-&gt;aParams, environ);

failed:
	/* an error occurred: log it and exit the child process. We use the
	 * 'syslog' system call to log the error (we cannot use LogMsg/LogError,
	 * since these functions add directly to the rsyslog input queue).
	 */
	rs_strerror_r(errno, errStr, sizeof(errStr));
	DBGPRINTF(&quot;omprog: failed to execute program '%s': %s\n&quot;,
			pData-&gt;szBinary, errStr);
	openlog(&quot;rsyslogd&quot;, 0, LOG_SYSLOG);
	syslog(LOG_ERR, &quot;omprog: failed to execute program '%s': %s\n&quot;,
			pData-&gt;szBinary, errStr);
	exit(1);
}

/* creates a pipe and starts program, uses pipe as stdin for program.
 * rgerhards, 2009-04-01
 */
static rsRetVal
openPipe(instanceData *pData, childProcessCtx_t *pChildCtx)
{
	int pipeStdin[2] = { -1, -1 };
	int pipeStdout[2] = { -1, -1 };
	pid_t cpid;
	DEFiRet;

	/* open a pipe to send messages to the program */
	if(pipe(pipeStdin) == -1) {
		ABORT_FINALIZE(RS_RET_ERR_CREAT_PIPE);
	}

	/* if the 'confirmMessages' setting is enabled, open a pipe to receive
	   message confirmations from the program */
	if(pData-&gt;bConfirmMessages &amp;&amp; pipe(pipeStdout) == -1) {
		ABORT_FINALIZE(RS_RET_ERR_CREAT_PIPE);
	}

	DBGPRINTF(&quot;omprog: executing program '%s' with '%d' parameters\n&quot;, pData-&gt;szBinary,
			pData-&gt;iParams);

	cpid = fork();
	if(cpid == -1) {
		ABORT_FINALIZE(RS_RET_ERR_FORK);
	}

	if(cpid == 0) {  /* we are now the child process: execute the program */
		/* close the pipe ends that the child doesn't need */
		close(pipeStdin[1]);
		if(pipeStdout[0] != -1) {
			close(pipeStdout[0]);
		}

		execBinary(pData, pipeStdin[0], pipeStdout[1]);
		/* NO CODE HERE - WILL NEVER BE REACHED! */
	}

	DBGPRINTF(&quot;omprog: child has pid %d\n&quot;, (int) cpid);

	/* close the pipe ends that the parent doesn't need */
	close(pipeStdin[0]);
	if(pipeStdout[1] != -1) {
		close(pipeStdout[1]);
	}

	pChildCtx-&gt;fdPipeOut = pipeStdin[1];  /* we'll send messages to the program via this fd */
	pChildCtx-&gt;fdPipeIn = pipeStdout[0];  /* we'll receive message confirmations via this fd */
	pChildCtx-&gt;pid = cpid;
	pChildCtx-&gt;bIsRunning = 1;

finalize_it:
	if(iRet != RS_RET_OK) {
		if(pipeStdin[0] != -1) {
			close(pipeStdin[0]);
			close(pipeStdin[1]);
		}
		if(pipeStdout[0] != -1) {
			close(pipeStdout[0]);
			close(pipeStdout[1]);
		}
	}
	RETiRet;
}

static void
waitForChild(instanceData *pData, childProcessCtx_t *pChildCtx)
{
	int status;
	int ret;
	long counter;

	counter = pData-&gt;lCloseTimeout / 10;
	while ((ret = waitpid(pChildCtx-&gt;pid, &amp;status, WNOHANG)) == 0 &amp;&amp; counter &gt; 0) {
		srSleep(0, 10000);  /* 0 seconds, 10 milliseconds */
		--counter;
	}

	if (ret == 0) {  /* timeout reached */
		if (!pData-&gt;bKillUnresponsive) {
			LogMsg(0, NO_ERRCODE, LOG_WARNING, &quot;omprog: program '%s' (pid %ld) did not terminate &quot;
					&quot;within timeout (%ld ms); ignoring it&quot;, pData-&gt;szBinary,
					(long) pChildCtx-&gt;pid, pData-&gt;lCloseTimeout);
			return;
		}

		LogMsg(0, NO_ERRCODE, LOG_WARNING, &quot;omprog: program '%s' (pid %ld) did not terminate &quot;
				&quot;within timeout (%ld ms); killing it&quot;, pData-&gt;szBinary, (long) pChildCtx-&gt;pid,
				pData-&gt;lCloseTimeout);
		if (kill(pChildCtx-&gt;pid, SIGKILL) == -1) {
			LogError(errno, RS_RET_SYS_ERR, &quot;omprog: could not send SIGKILL to child process&quot;);
			return;
		}

		ret = waitpid(pChildCtx-&gt;pid, &amp;status, 0);
	}

	/* waitpid will fail with errno == ECHILD if the child process has already
	   been reaped by the rsyslogd main loop (see rsyslogd.c) */
	if(ret == pChildCtx-&gt;pid) {
		glblReportChildProcessExit(runConf, pData-&gt;szBinary, pChildCtx-&gt;pid, status);
	}
}

/* close pipe and wait for child to terminate
 */
static void
cleanupChild(instanceData *pData, childProcessCtx_t *pChildCtx)
{
	assert(pChildCtx-&gt;bIsRunning);

	if(pChildCtx-&gt;fdPipeIn != -1) {
		close(pChildCtx-&gt;fdPipeIn);
		pChildCtx-&gt;fdPipeIn = -1;
	}
	if(pChildCtx-&gt;fdPipeOut != -1) {
		close(pChildCtx-&gt;fdPipeOut);
		pChildCtx-&gt;fdPipeOut = -1;
	}

	/* wait for the child AFTER closing the pipe, so it receives EOF */
	waitForChild(pData, pChildCtx);

	pChildCtx-&gt;bIsRunning = 0;
}

/* Send SIGTERM to child process if configured to do so, close pipe
 * and wait for child to terminate.
 */
static void
terminateChild(instanceData *pData, childProcessCtx_t *pChildCtx)
{
	assert(pChildCtx-&gt;bIsRunning);

	if (pData-&gt;bSignalOnClose) {
		kill(pChildCtx-&gt;pid, SIGTERM);
	}

	cleanupChild(pData, pChildCtx);
}

/* write message to pipe
 * note that we do not try to run block-free. If the user fears something
 * may block (and this is not acceptable), the action should be run on its
 * own action queue.
 */
static rsRetVal
sendMessage(instanceData *pData, childProcessCtx_t *pChildCtx, const uchar *szMsg)
{
	ssize_t written;
	size_t offset = 0;
	DEFiRet;

	const size_t len = strlen((char*)szMsg);

	do {
		written = write(pChildCtx-&gt;fdPipeOut, ((char*)szMsg) + offset, len - offset);
		if(written == -1) {
			if(errno == EINTR) {
				continue;  /* call interrupted: retry write */
			}
			if(errno == EPIPE) {
				LogMsg(0, RS_RET_ERR_WRITE_PIPE, LOG_WARNING,
						&quot;omprog: program '%s' (pid %ld) terminated; will be restarted&quot;,
						pData-&gt;szBinary, (long) pChildCtx-&gt;pid);
				cleanupChild(pData, pChildCtx);  /* force restart in tryResume() */
				ABORT_FINALIZE(RS_RET_SUSPENDED);
			}
			LogError(errno, RS_RET_ERR_WRITE_PIPE, &quot;omprog: error sending message to program&quot;);
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
		offset += written;
	} while(offset &lt; len);

finalize_it:
	RETiRet;
}

static rsRetVal
lineToStatusCode(instanceData *pData, const char* line)
{
	DEFiRet;

	/* strip leading dots (.) from the line, so the program can use them as a keep-alive mechanism */
	while(line[0] == '.') {
<A NAME="4"></A>		++line;
	}

<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1144-0.html#4',2,'match1144-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	if(strcmp(line, &quot;OK&quot;) == 0) {
		iRet = RS_RET_OK;
	} else if(strcmp(line, &quot;DEFER_COMMIT&quot;) == 0) {
		iRet = RS_RET_DEFER_COMMIT;
	} else if(strcmp(line, &quot;PREVIOUS_COMMITTED&quot;) == 0) {
		iRet = RS_RET_PREVIOUS_COMMITTED;
	} else {</B></FONT>
		/* anything else is considered a recoverable error */
		DBGPRINTF(&quot;omprog: program '%s' returned: %s\n&quot;, pData-&gt;szBinary, line);
		if(pData-&gt;bReportFailures) {
			LogMsg(0, NO_ERRCODE, LOG_WARNING, &quot;omprog: program '%s' returned: %s&quot;,
					pData-&gt;szBinary, line);
		}
		iRet = RS_RET_SUSPENDED;
	}
	RETiRet;
}

static rsRetVal
readStatus(instanceData *pData, childProcessCtx_t *pChildCtx)
{
	struct pollfd fdToPoll[1];
	int numReady;
	char lineBuf[RESPONSE_LINE_BUFFER_SIZE];
	ssize_t lenRead;
	size_t offset = 0;
	int lineEnded = 0;
	DEFiRet;

	fdToPoll[0].fd = pChildCtx-&gt;fdPipeIn;
	fdToPoll[0].events = POLLIN;

	do {
		numReady = poll(fdToPoll, 1, pData-&gt;lConfirmTimeout);
		if(numReady == -1) {
			if(errno == EINTR) {
				continue;  /* call interrupted: retry poll */
			}
			LogError(errno, RS_RET_SYS_ERR, &quot;omprog: error polling for response from program&quot;);
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}

		if(numReady == 0) {  /* timeout reached */
			LogMsg(0, RS_RET_TIMED_OUT, LOG_WARNING, &quot;omprog: program '%s' (pid %ld) did not respond &quot;
					&quot;within timeout (%ld ms); will be restarted&quot;, pData-&gt;szBinary,
					(long) pChildCtx-&gt;pid, pData-&gt;lConfirmTimeout);
			terminateChild(pData, pChildCtx);
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}

		lenRead = read(pChildCtx-&gt;fdPipeIn, lineBuf + offset, sizeof(lineBuf) - offset - 1);
		if(lenRead == -1) {
			if(errno == EINTR) {
				continue;  /* call interrupted: retry poll + read */
			}
			LogError(errno, RS_RET_READ_ERR, &quot;omprog: error reading response from program&quot;);
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}

		if(lenRead == 0) {
			LogMsg(0, RS_RET_READ_ERR, LOG_WARNING, &quot;omprog: program '%s' (pid %ld) terminated; &quot;
					&quot;will be restarted&quot;, pData-&gt;szBinary, (long) pChildCtx-&gt;pid);
			cleanupChild(pData, pChildCtx);
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}

		offset += lenRead;
		lineBuf[offset] = '\0';
		lineEnded = (lineBuf[offset-1] == '\n');

		/* check that the program has not returned multiple lines. This should not occur if
		 * the program honors the specified interface. Otherwise, we force a restart of the
		 * program, since we have probably lost synchronism with it.
		 */
		if(!lineEnded &amp;&amp; strchr(lineBuf + offset - lenRead, '\n') != NULL) {
			DBGPRINTF(&quot;omprog: program '%s' returned: %s\n&quot;, pData-&gt;szBinary, lineBuf);
			LogMsg(0, NO_ERRCODE, LOG_WARNING, &quot;omprog: program '%s' returned a multiline response; &quot;
					&quot;will be restarted&quot;, pData-&gt;szBinary);
			if(pData-&gt;bReportFailures) {
				LogMsg(0, NO_ERRCODE, LOG_WARNING, &quot;omprog: program '%s' returned: %s&quot;,
						pData-&gt;szBinary, lineBuf);
			}
			terminateChild(pData, pChildCtx);
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
	} while(!lineEnded &amp;&amp; offset &lt; sizeof(lineBuf) - 1);

	if(!lineEnded) {
		DBGPRINTF(&quot;omprog: program '%s' returned: %s\n&quot;, pData-&gt;szBinary, lineBuf);
		LogMsg(0, NO_ERRCODE, LOG_WARNING, &quot;omprog: program '%s' returned a too long response; &quot;
				&quot;will be restarted&quot;, pData-&gt;szBinary);
		if(pData-&gt;bReportFailures) {
			LogMsg(0, NO_ERRCODE, LOG_WARNING, &quot;omprog: program '%s' returned: %s&quot;,
					pData-&gt;szBinary, lineBuf);
		}
		terminateChild(pData, pChildCtx);
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}

	lineBuf[offset-1] = '\0';  /* strip newline char */

	/* NOTE: coverity does not like CHKiRet() if it is the last thing before finalize_it.
	 * Reason is that the if() inside that macro than does not lead to different code paths.
	 */
	iRet = lineToStatusCode(pData, lineBuf);

finalize_it:
	RETiRet;
}

static rsRetVal
allocChildCtx(childProcessCtx_t **ppChildCtx)
{
	childProcessCtx_t *pChildCtx;
	DEFiRet;

	CHKmalloc(pChildCtx = calloc(1, sizeof(childProcessCtx_t)));
	*ppChildCtx = pChildCtx;

	pChildCtx-&gt;bIsRunning = 0;
	pChildCtx-&gt;pid = -1;
	pChildCtx-&gt;fdPipeOut = -1;
	pChildCtx-&gt;fdPipeIn = -1;

finalize_it:
	RETiRet;
}

static rsRetVal
startChild(instanceData *pData, childProcessCtx_t *pChildCtx)
{
	DEFiRet;

	assert(!pChildCtx-&gt;bIsRunning);

	CHKiRet(openPipe(pData, pChildCtx));

	if(pData-&gt;bConfirmMessages) {
		/* wait for program to confirm successful initialization */
		CHKiRet(readStatus(pData, pChildCtx));
	}

finalize_it:
	if(iRet != RS_RET_OK &amp;&amp; pChildCtx-&gt;bIsRunning) {
		/* if initialization has failed, terminate program */
		terminateChild(pData, pChildCtx);
	}
	RETiRet;
}

static rsRetVal
startSingleChildOnce(instanceData *pData)
{
	DEFiRet;

	assert(pData-&gt;bForceSingleInst);
	CHKiConcCtrl(pthread_mutex_lock(pData-&gt;pSingleChildMut));

	if(pData-&gt;pSingleChildCtx-&gt;bIsRunning)
		goto finalize_it;  /* child process already started: nothing to do */

	iRet = startChild(pData, pData-&gt;pSingleChildCtx);

finalize_it:
	pthread_mutex_unlock(pData-&gt;pSingleChildMut);
	RETiRet;
}

static void
writeOutputToFile(outputCaptureCtx_t *pCtx, char *buf, ssize_t len)
{
	ssize_t written;
	ssize_t offset = 0;

	assert(pCtx-&gt;bIsRunning);
	pthread_mutex_lock(&amp;pCtx-&gt;mutWrite);

	if(pCtx-&gt;fdFile == -1) {
		if(pCtx-&gt;bFileErr) {  /* discarding output because file couldn't be opened */
			goto done;
		}

		pCtx-&gt;fdFile = open((char*)pCtx-&gt;szFileName, O_WRONLY | O_APPEND | O_CREAT,
				pCtx-&gt;fCreateMode);
		if(pCtx-&gt;fdFile == -1) {
			LogError(errno, RS_RET_NO_FILE_ACCESS, &quot;omprog: error opening output file %s; &quot;
					&quot;output from program will be discarded&quot;, pCtx-&gt;szFileName);
			pCtx-&gt;bFileErr = 1;  /* avoid reporting too many errors */
			goto done;
		}
	}

	do {
		written = write(pCtx-&gt;fdFile, buf + offset, len - offset);
		if(written == -1) {
			if(errno == EINTR) {
				continue;  /* call interrupted: retry write */
			}

			if(!pCtx-&gt;bWriteErr) {
				LogError(errno, RS_RET_SYS_ERR, &quot;omprog: error writing to output file &quot;
						&quot;(subsequent errors will not be reported)&quot;);
				pCtx-&gt;bWriteErr = 1;  /* avoid reporting too many errors */
			}
			break;
		}

		if(pCtx-&gt;bWriteErr) {
			LogMsg(0, NO_ERRCODE, LOG_WARNING, &quot;omprog: resumed writing to output file&quot;);
			pCtx-&gt;bWriteErr = 0;
		}

		offset += written;
	} while(offset &lt; len);

done:
	pthread_mutex_unlock(&amp;pCtx-&gt;mutWrite);
}

static void
closeOutputFile(outputCaptureCtx_t *pCtx)
{
	DBGPRINTF(&quot;omprog: reopening output file upon reception of HUP signal\n&quot;);
	pthread_mutex_lock(&amp;pCtx-&gt;mutWrite);

	if(pCtx-&gt;fdFile != -1) {
		close(pCtx-&gt;fdFile);
		pCtx-&gt;fdFile = -1;
	}
	pCtx-&gt;bFileErr = 0;  /* if there was an error opening the file, we'll retry */

	pthread_mutex_unlock(&amp;pCtx-&gt;mutWrite);
}

/* This code runs in a dedicated thread. Captures the output of the child processes
 * through a shared pipe (one reader and multiple writers), and writes the output
 * to a file. The lines concurrently emmitted to stdout/stderr by the child processes
 * will not appear intermingled in the output file if 1) the lines are short enough
 * (less than PIPE_BUF bytes long: 4KB on Linux, and 512 bytes or more on other
 * POSIX systems), and 2) the program outputs each line using a single 'write'
 * syscall (line buffering mode). When a HUP signal is received, the output file is
 * reopened (this provides support for external rotation of the file).
 */
static void *
captureOutput(void *_pCtx) {
	outputCaptureCtx_t *pCtx = (outputCaptureCtx_t *)_pCtx;
	sigset_t sigSet;
	char readBuf[OUTPUT_CAPTURE_BUFFER_SIZE];
	ssize_t lenRead;

	DBGPRINTF(&quot;omprog: starting output capture thread\n&quot;);

	/* block signals for this thread (otherwise shutdown hangs on FreeBSD) */
	sigfillset(&amp;sigSet);
	pthread_sigmask(SIG_SETMASK, &amp;sigSet, NULL);

	for(;;) {
		lenRead = read(pCtx-&gt;fdPipe[0], readBuf, sizeof(readBuf));
		if(lenRead == -1) {
			if(errno == EINTR) {
				continue;  /* call interrupted: retry read */
			}

			if(!pCtx-&gt;bReadErr) {
				LogError(errno, RS_RET_SYS_ERR, &quot;omprog: error capturing output from program &quot;
						&quot;(subsequent errors will not be reported)&quot;);
				pCtx-&gt;bReadErr = 1;  /* avoid reporting too many errors */
			}
			continue;  /* continue with next line */
		}

		if(lenRead == 0) {
			break;  /* all write ends of pipe closed: exit loop and terminate thread */
		}

		if(pCtx-&gt;bReadErr) {
			LogMsg(0, NO_ERRCODE, LOG_WARNING, &quot;omprog: resumed capturing output from program&quot;);
			pCtx-&gt;bReadErr = 0;
		}

		writeOutputToFile(pCtx, readBuf, lenRead);
	}

	DBGPRINTF(&quot;omprog: all output-capture pipe ends closed, terminating output capture thread\n&quot;);
	pthread_mutex_lock(&amp;pCtx-&gt;mutTerm);
	pCtx-&gt;bIsRunning = 0;
	pthread_cond_signal(&amp;pCtx-&gt;condTerm);
	pthread_mutex_unlock(&amp;pCtx-&gt;mutTerm);
	return NULL;
}

static rsRetVal
allocOutputCaptureCtx(outputCaptureCtx_t **ppCtx)
{
	outputCaptureCtx_t *pCtx;
	DEFiRet;

	CHKmalloc(pCtx = calloc(1, sizeof(outputCaptureCtx_t)));
	*ppCtx = pCtx;

	pCtx-&gt;szFileName = NULL;
	pCtx-&gt;fCreateMode = 0600;
	pCtx-&gt;bIsRunning = 0;

	CHKiConcCtrl(pthread_mutex_init(&amp;pCtx-&gt;mutStart, NULL));
	CHKiConcCtrl(pthread_mutex_init(&amp;pCtx-&gt;mutWrite, NULL));
	CHKiConcCtrl(pthread_mutex_init(&amp;pCtx-&gt;mutTerm, NULL));
	CHKiConcCtrl(pthread_cond_init(&amp;pCtx-&gt;condTerm, NULL));

finalize_it:
	RETiRet;
}

static void
freeOutputCaptureCtx(outputCaptureCtx_t *pCtx) {
	if(pCtx-&gt;szFileName != NULL) {
		free(pCtx-&gt;szFileName);
	}

	pthread_cond_destroy(&amp;pCtx-&gt;condTerm);
	pthread_mutex_destroy(&amp;pCtx-&gt;mutTerm);
	pthread_mutex_destroy(&amp;pCtx-&gt;mutWrite);
	pthread_mutex_destroy(&amp;pCtx-&gt;mutStart);

	free(pCtx);
}

static rsRetVal
startOutputCaptureOnce(outputCaptureCtx_t *pCtx)
{
	int pip[2] = { -1, -1 };
	DEFiRet;

	CHKiConcCtrl(pthread_mutex_lock(&amp;pCtx-&gt;mutStart));

	if(pCtx-&gt;bIsRunning)
		goto finalize_it;  /* output capture thread already started: nothing to do */

	/* open a (single) pipe to capture output from (all) child processes */
	if(pipe(pip) == -1) {
		ABORT_FINALIZE(RS_RET_ERR_CREAT_PIPE);
	}

	pCtx-&gt;fdPipe[0] = pip[0];
	pCtx-&gt;fdPipe[1] = pip[1];
	pCtx-&gt;fdFile = -1;
	pCtx-&gt;bFileErr = 0;
	pCtx-&gt;bReadErr = 0;
	pCtx-&gt;bWriteErr = 0;

	/* start a thread to read lines from the pipe and write them to the output file */
	CHKiConcCtrl(pthread_create(&amp;pCtx-&gt;thrdID, NULL, captureOutput, (void *)pCtx));

	pCtx-&gt;bIsRunning = 1;

finalize_it:
	if(iRet != RS_RET_OK &amp;&amp; pip[0] != -1) {
		close(pip[0]);
		close(pip[1]);
	}
	pthread_mutex_unlock(&amp;pCtx-&gt;mutStart);
	RETiRet;
}

static void
endOutputCapture(outputCaptureCtx_t *pCtx, long timeoutMs)
{
	struct timespec ts;
	int bTimedOut;

	assert(pCtx-&gt;bIsRunning);

	/* close our write end of the output-capture pipe */
	close(pCtx-&gt;fdPipe[1]);

	/* the output capture thread will now terminate because there are no more
	 * writers attached to the output-capture pipe. However, if a child becomes
	 * unresponsive without closing its pipe end (assuming killUnresponsive=off),
	 * we would wait forever. To avoid this, we wait for the thread to terminate
	 * during a maximum timeout (we reuse the 'closeTimeout' setting for this).
	 */
	timeoutComp(&amp;ts, timeoutMs);
	pthread_mutex_lock(&amp;pCtx-&gt;mutTerm);
	bTimedOut = 0;
	while(pCtx-&gt;bIsRunning &amp;&amp; !bTimedOut) {
		if(pthread_cond_timedwait(&amp;pCtx-&gt;condTerm, &amp;pCtx-&gt;mutTerm, &amp;ts) == ETIMEDOUT) {
			bTimedOut = 1;
		}
	}
	pthread_mutex_unlock(&amp;pCtx-&gt;mutTerm);

	if(bTimedOut) {
		LogMsg(0, NO_ERRCODE, LOG_WARNING, &quot;omprog: forcing termination of output capture &quot;
				&quot;thread because of unresponsive child process&quot;);
		pthread_cancel(pCtx-&gt;thrdID);
		pCtx-&gt;bIsRunning = 0;
	}

	pthread_join(pCtx-&gt;thrdID, NULL);

	/* close the read end of the output-capture pipe */
	close(pCtx-&gt;fdPipe[0]);

	/* close the output file (if it could be opened) */
	if(pCtx-&gt;fdFile != -1) {
		close(pCtx-&gt;fdFile);
	}
}


BEGINinitConfVars		/* (re)set config variables to default values */
CODESTARTinitConfVars
	cs.szBinary = NULL;	/* name of binary to call */
ENDinitConfVars


BEGINcreateInstance
CODESTARTcreateInstance
	pData-&gt;szBinary = NULL;
	pData-&gt;szTemplateName = NULL;
	pData-&gt;aParams = NULL;
	pData-&gt;iParams = 0;
	pData-&gt;bConfirmMessages = 0;
	pData-&gt;block_if_err = 0;
	pData-&gt;lConfirmTimeout = DEFAULT_CONFIRM_TIMEOUT_MS;
	pData-&gt;bReportFailures = 0;
	pData-&gt;bUseTransactions = 0;
	pData-&gt;szBeginTransactionMark = NULL;
	pData-&gt;szCommitTransactionMark = NULL;
	pData-&gt;iHUPForward = NO_HUP_FORWARD;
	pData-&gt;bSignalOnClose = 0;
	pData-&gt;lCloseTimeout = DEFAULT_CLOSE_TIMEOUT_MS;
	pData-&gt;bKillUnresponsive = -1;
	pData-&gt;bForceSingleInst = 0;
	pData-&gt;pSingleChildCtx = NULL;
	pData-&gt;pSingleChildMut = NULL;
	pData-&gt;pOutputCaptureCtx = NULL;
ENDcreateInstance


static rsRetVal
postInitInstance(instanceData *pData)
{
	DEFiRet;

	if(pData-&gt;bUseTransactions &amp;&amp; pData-&gt;szBeginTransactionMark == NULL) {
		pData-&gt;szBeginTransactionMark = (uchar*)strdup(&quot;BEGIN TRANSACTION&quot;);
	}
	if(pData-&gt;bUseTransactions &amp;&amp; pData-&gt;szCommitTransactionMark == NULL) {
		pData-&gt;szCommitTransactionMark = (uchar*)strdup(&quot;COMMIT TRANSACTION&quot;);
	}
	if(pData-&gt;bKillUnresponsive == -1) {  /* default value: bSignalOnClose */
		pData-&gt;bKillUnresponsive = pData-&gt;bSignalOnClose;
	}

	if(pData-&gt;pOutputCaptureCtx != NULL &amp;&amp; pData-&gt;pOutputCaptureCtx-&gt;szFileName == NULL) {
		LogError(0, RS_RET_CONF_PARAM_INVLD, &quot;omprog: the 'fileCreateMode' parameter requires &quot;
				&quot;specifying the 'output' parameter also&quot;);
		ABORT_FINALIZE(RS_RET_CONF_PARAM_INVLD);
	}

	if(pData-&gt;bForceSingleInst) {
		CHKmalloc(pData-&gt;pSingleChildMut = calloc(1, sizeof(pthread_mutex_t)));
		CHKiConcCtrl(pthread_mutex_init(pData-&gt;pSingleChildMut, NULL));
		CHKiRet(allocChildCtx(&amp;pData-&gt;pSingleChildCtx));
		/* do not start the child here. The config is still being parsed, and the daemon
		   has not been forked yet. When the daemon is forked, all fds will be closed! */
	}

finalize_it:
	/* no cleanup needed on error: newActInst() will call freeInstance() */
	RETiRet;
}


BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	pWrkrData-&gt;pChildCtx = NULL;

	if(pWrkrData-&gt;pData-&gt;pOutputCaptureCtx != NULL) {
		CHKiRet(startOutputCaptureOnce(pWrkrData-&gt;pData-&gt;pOutputCaptureCtx));
	}

	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
		CHKiRet(startSingleChildOnce(pWrkrData-&gt;pData));
		pWrkrData-&gt;pChildCtx = pData-&gt;pSingleChildCtx;
	} else {
		CHKiRet(allocChildCtx(&amp;pWrkrData-&gt;pChildCtx));
		CHKiRet(startChild(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx));
	}

finalize_it:
	if(iRet != RS_RET_OK &amp;&amp; !pWrkrData-&gt;pData-&gt;bForceSingleInst) {
		free(pWrkrData-&gt;pChildCtx);
	}
ENDcreateWrkrInstance


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction) {
		iRet = RS_RET_OK;
	}
ENDisCompatibleWithFeature


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
ENDdbgPrintInstInfo

<A NAME="2"></A>
BEGINtryResume
CODESTARTtryResume
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1144-0.html#2',2,'match1144-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
		CHKiConcCtrl(pthread_mutex_lock(pWrkrData-&gt;pData-&gt;pSingleChildMut));
	}
	if(!pWrkrData-&gt;pChildCtx-&gt;bIsRunning) {
		CHKiRet(startChild(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx));
	}

finalize_it:
	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
		pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;pSingleChildMut);
	}
ENDtryResume


BEGINbeginTransaction
CODESTARTbeginTransaction
	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
		CHKiConcCtrl(pthread_mutex_lock(pWrkrData-&gt;pData-&gt;pSingleChildMut));
	}
	if(!pWrkrData-&gt;pData-&gt;bUseTransactions) {
		FINALIZE;
	}

	CHKiRet(sendMessage(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx,
			pWrkrData-&gt;pData-&gt;szBeginTransactionMark));
	CHKiRet(sendMessage(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx, (uchar*) &quot;\n&quot;));

	if(pWrkrData-&gt;pData-&gt;bConfirmMessages) {
		CHKiRet(readStatus(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx));
	}</B></FONT>

finalize_it:
	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
		pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;pSingleChildMut);
	}
ENDbeginTransaction


BEGINdoAction
CODESTARTdoAction
	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
		CHKiConcCtrl(pthread_mutex_lock(pWrkrData-&gt;pData-&gt;pSingleChildMut));
	}
	if(!pWrkrData-&gt;pChildCtx-&gt;bIsRunning) {  /* should not occur */
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}

	const uchar *const szMsg = ppString[0];
	const size_t len = strlen((char*)szMsg);
	CHKiRet(sendMessage(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx, szMsg));
	if(szMsg[len-1] != '\n') {
		const time_t tt = time(NULL);
		if(tt &gt; pWrkrData-&gt;pData-&gt;block_if_err) {
			LogMsg(0, NO_ERRCODE, LOG_WARNING, &quot;omprog: messages must be terminated with \\n &quot;
				&quot;at end of message, but this message is not: '%s'\n&quot;, ppString[0]);
			pWrkrData-&gt;pData-&gt;block_if_err = tt + 30;
		}
		CHKiRet(sendMessage(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx, (uchar*) &quot;\n&quot;));
	}

	if(pWrkrData-&gt;pData-&gt;bConfirmMessages) {
		CHKiRet(readStatus(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx));
	} else if(pWrkrData-&gt;pData-&gt;bUseTransactions) {
		/* ensure endTransaction will be called */
		iRet = RS_RET_DEFER_COMMIT;
	}

finalize_it:
	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
		pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;pSingleChildMut);
	}
ENDdoAction


BEGINendTransaction
CODESTARTendTransaction
	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
		CHKiConcCtrl(pthread_mutex_lock(pWrkrData-&gt;pData-&gt;pSingleChildMut));
	}
	if(!pWrkrData-&gt;pData-&gt;bUseTransactions) {
		FINALIZE;
	}

	CHKiRet(sendMessage(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx,
			pWrkrData-&gt;pData-&gt;szCommitTransactionMark));
	CHKiRet(sendMessage(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx, (uchar*) &quot;\n&quot;));

	if(pWrkrData-&gt;pData-&gt;bConfirmMessages) {
		CHKiRet(readStatus(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx));
	}

finalize_it:
	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
		pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;pSingleChildMut);
	}
ENDendTransaction


BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	if(!pWrkrData-&gt;pData-&gt;bForceSingleInst) {
		if(pWrkrData-&gt;pChildCtx-&gt;bIsRunning) {
			terminateChild(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx);
		}
		free(pWrkrData-&gt;pChildCtx);
	}
ENDfreeWrkrInstance


BEGINfreeInstance
	int i;
CODESTARTfreeInstance
	if(pData-&gt;pSingleChildCtx != NULL) {
		if(pData-&gt;pSingleChildCtx-&gt;bIsRunning) {
			terminateChild(pData, pData-&gt;pSingleChildCtx);
		}
		free(pData-&gt;pSingleChildCtx);
	}

	if(pData-&gt;pSingleChildMut != NULL) {
		pthread_mutex_destroy(pData-&gt;pSingleChildMut);
		free(pData-&gt;pSingleChildMut);
	}

	if(pData-&gt;pOutputCaptureCtx != NULL) {
		if(pData-&gt;pOutputCaptureCtx-&gt;bIsRunning) {
			endOutputCapture(pData-&gt;pOutputCaptureCtx, pData-&gt;lCloseTimeout);
		}
		freeOutputCaptureCtx(pData-&gt;pOutputCaptureCtx);
	}

	free(pData-&gt;szBinary);
	free(pData-&gt;szTemplateName);
	free(pData-&gt;szBeginTransactionMark);
	free(pData-&gt;szCommitTransactionMark);

	if(pData-&gt;aParams != NULL) {
		for (i = 0; i &lt; pData-&gt;iParams; i++) {
			free(pData-&gt;aParams[i]);
		}
		free(pData-&gt;aParams);
	}
ENDfreeInstance


BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
CODESTARTnewActInst
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CHKiRet(createInstance(&amp;pData));

	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, &quot;binary&quot;)) {
			CHKiRet(split_binary_parameters(&amp;pData-&gt;szBinary, &amp;pData-&gt;aParams, &amp;pData-&gt;iParams,
				pvals[i].val.d.estr));
		} else if(!strcmp(actpblk.descr[i].name, &quot;confirmMessages&quot;)) {
<A NAME="1"></A>			pData-&gt;bConfirmMessages = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;confirmTimeout&quot;)) {
			pData-&gt;lConfirmTimeout = (long) pvals[i].val.d.n;
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1144-0.html#1',2,'match1144-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		} else if(!strcmp(actpblk.descr[i].name, &quot;reportFailures&quot;)) {
			pData-&gt;bReportFailures = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;useTransactions&quot;)) {
			pData-&gt;bUseTransactions = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;beginTransactionMark&quot;)) {
<A NAME="3"></A>			pData-&gt;szBeginTransactionMark = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;commitTransactionMark&quot;)) {
			pData-&gt;szCommitTransactionMark = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1144-0.html#3',2,'match1144-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		} else if(!strcmp(actpblk.descr[i].name, &quot;forceSingleInstance&quot;)) {
			pData-&gt;bForceSingleInst = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;signalOnClose&quot;)) {
			pData-&gt;bSignalOnClose = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;closeTimeout&quot;)) {
			pData-&gt;lCloseTimeout = (long) pvals[i].val.d.n;</B></FONT>
		} else if(!strcmp(actpblk.descr[i].name, &quot;killUnresponsive&quot;)) {
			pData-&gt;bKillUnresponsive = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;hup.signal&quot;)) {
			const char *const sig = es_str2cstr(pvals[i].val.d.estr, NULL);
			if(!strcmp(sig, &quot;HUP&quot;))
				pData-&gt;iHUPForward = SIGHUP;
			else if(!strcmp(sig, &quot;USR1&quot;))
				pData-&gt;iHUPForward = SIGUSR1;
			else if(!strcmp(sig, &quot;USR2&quot;))
				pData-&gt;iHUPForward = SIGUSR2;
			else if(!strcmp(sig, &quot;INT&quot;))
				pData-&gt;iHUPForward = SIGINT;
			else if(!strcmp(sig, &quot;TERM&quot;))
				pData-&gt;iHUPForward = SIGTERM;
			else {
				LogError(0, RS_RET_CONF_PARAM_INVLD,
					&quot;omprog: hup.signal '%s' in hup.signal parameter&quot;, sig);
				ABORT_FINALIZE(RS_RET_CONF_PARAM_INVLD);
			}
			free((void*)sig);
		} else if(!strcmp(actpblk.descr[i].name, &quot;template&quot;)) {
			pData-&gt;szTemplateName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;output&quot;)) {
			if(pData-&gt;pOutputCaptureCtx == NULL) {
				CHKiRet(allocOutputCaptureCtx(&amp;pData-&gt;pOutputCaptureCtx));
			}
			pData-&gt;pOutputCaptureCtx-&gt;szFileName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;fileCreateMode&quot;)) {
			if(pData-&gt;pOutputCaptureCtx == NULL) {
				CHKiRet(allocOutputCaptureCtx(&amp;pData-&gt;pOutputCaptureCtx));
			}
			pData-&gt;pOutputCaptureCtx-&gt;fCreateMode = (mode_t) pvals[i].val.d.n;
		} else {
			DBGPRINTF(&quot;omprog: program error, non-handled param '%s'\n&quot;, actpblk.descr[i].name);
		}
	}

	CODE_STD_STRING_REQUESTnewActInst(1)
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)strdup(pData-&gt;szTemplateName == NULL ?
			&quot;RSYSLOG_FileFormat&quot; : (char*)pData-&gt;szTemplateName), OMSR_NO_RQD_TPL_OPTS));

	iRet = postInitInstance(pData);

CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst


BEGINparseSelectorAct
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	/* first check if this config line is actually for us */
	if(strncmp((char*) p, &quot;:omprog:&quot;, sizeof(&quot;:omprog:&quot;) - 1)) {
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
	}

	/* ok, if we reach this point, we have something for us */
	p += sizeof(&quot;:omprog:&quot;) - 1; /* eat indicator sequence  (-1 because of '\0'!) */
	if(cs.szBinary == NULL) {
		LogError(0, RS_RET_CONF_RQRD_PARAM_MISSING, &quot;no binary to execute specified&quot;);
		ABORT_FINALIZE(RS_RET_CONF_RQRD_PARAM_MISSING);
	}

	CHKiRet(createInstance(&amp;pData));
	CHKmalloc(pData-&gt;szBinary = (uchar*) strdup((char*)cs.szBinary));

	/* check if a non-standard template is to be applied */
	if(*(p-1) == ';')
		--p;
	CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, 0, (uchar*) &quot;RSYSLOG_FileFormat&quot;));

	iRet = postInitInstance(pData);

CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct


BEGINdoHUP
CODESTARTdoHUP
	if(pData-&gt;bForceSingleInst &amp;&amp; pData-&gt;iHUPForward != NO_HUP_FORWARD &amp;&amp;
			pData-&gt;pSingleChildCtx-&gt;bIsRunning) {
		DBGPRINTF(&quot;omprog: forwarding HUP to program '%s' (pid %ld) as signal %d\n&quot;,
				pData-&gt;szBinary, (long) pData-&gt;pSingleChildCtx-&gt;pid, pData-&gt;iHUPForward);
		kill(pData-&gt;pSingleChildCtx-&gt;pid, pData-&gt;iHUPForward);
	}

	if(pData-&gt;pOutputCaptureCtx != NULL &amp;&amp; pData-&gt;pOutputCaptureCtx-&gt;bIsRunning) {
		closeOutputFile(pData-&gt;pOutputCaptureCtx);
	}
ENDdoHUP


BEGINdoHUPWrkr
CODESTARTdoHUPWrkr
	if(!pWrkrData-&gt;pData-&gt;bForceSingleInst &amp;&amp; pWrkrData-&gt;pData-&gt;iHUPForward != NO_HUP_FORWARD &amp;&amp;
	 		pWrkrData-&gt;pChildCtx-&gt;bIsRunning) {
		DBGPRINTF(&quot;omprog: forwarding HUP to program '%s' (pid %ld) as signal %d\n&quot;,
				pWrkrData-&gt;pData-&gt;szBinary, (long) pWrkrData-&gt;pChildCtx-&gt;pid,
				pWrkrData-&gt;pData-&gt;iHUPForward);
		kill(pWrkrData-&gt;pChildCtx-&gt;pid, pWrkrData-&gt;pData-&gt;iHUPForward);
	}
ENDdoHUPWrkr


BEGINmodExit
CODESTARTmodExit
	free(cs.szBinary);
	cs.szBinary = NULL;
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_TXIF_OMOD_QUERIES /* we support the transactional interface */
CODEqueryEtryPt_doHUP
CODEqueryEtryPt_doHUPWrkr
ENDqueryEtryPt


/* Reset legacy config variables for this module to default values.
 */
static rsRetVal
resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	DEFiRet;
	free(cs.szBinary);
	cs.szBinary = NULL;
	RETiRet;
}

BEGINmodInit()
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	/* tell engine which objects we need */

	/* check that rsyslog core supports transactional plugins */
	INITChkCoreFeature(bCoreSupportsBatching, CORE_FEATURE_BATCHING);
	if (!bCoreSupportsBatching) {
		LogError(0, NO_ERRCODE, &quot;omprog: rsyslog core too old (does not support batching)&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;actionomprogbinary&quot;, 0, eCmdHdlrGetWord, NULL, &amp;cs.szBinary,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;resetconfigvariables&quot;, 1, eCmdHdlrCustomHandler, resetConfigVariables,
		NULL, STD_LOADABLE_MODULE_ID));
CODEmodInit_QueryRegCFSLineHdlr
ENDmodInit
</PRE>
</div>
  </div>
</body>
</html>
