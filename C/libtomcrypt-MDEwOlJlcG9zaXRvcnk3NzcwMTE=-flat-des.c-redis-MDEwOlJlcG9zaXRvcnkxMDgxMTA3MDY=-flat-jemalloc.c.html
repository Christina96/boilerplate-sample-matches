
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.345848757271286%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-des.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_DES
3  #define EN0 0
4  #define DE1 1
5  const struct ltc_cipher_descriptor des_desc =
6  {
7      "des",
8      13,
9      8, 8, 8, 16,
10      &des_setup,
11      &des_ecb_encrypt,
12      &des_ecb_decrypt,
13      &des_test,
14      &des_done,
15      &des_keysize,
16      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
17  };
18  const struct ltc_cipher_descriptor des3_desc =
19  {
20      "3des",
21      14,
22      16, 24, 8, 16,
23      &des3_setup,
24      &des3_ecb_encrypt,
25      &des3_ecb_decrypt,
26      &des3_test,
27      &des3_done,
28      &des3_keysize,
29      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
30  };
31  static const ulong32 bytebit[8] =
32  {
33      0200, 0100, 040, 020, 010, 04, 02, 01
34  };
35  static const ulong32 bigbyte[24] =
36  {
37      0x800000UL,  0x400000UL,  0x200000UL,  0x100000UL,
38      0x80000UL,   0x40000UL,   0x20000UL,   0x10000UL,
39      0x8000UL,    0x4000UL,    0x2000UL,    0x1000UL,
40      0x800UL,     0x400UL,     0x200UL,     0x100UL,
41      0x80UL,      0x40UL,      0x20UL,      0x10UL,
42      0x8UL,       0x4UL,       0x2UL,       0x1L
43  };
44  static const unsigned char pc1[56] = {
45      56, 48, 40, 32, 24, 16,  8,  0, 57, 49, 41, 33, 25, 17,
46       9,  1, 58, 50, 42, 34, 26, 18, 10,  2, 59, 51, 43, 35,
47      62, 54, 46, 38, 30, 22, 14,  6, 61, 53, 45, 37, 29, 21,
48      13,  5, 60, 52, 44, 36, 28, 20, 12,  4, 27, 19, 11,  3
49  };
50  static const unsigned char totrot[16] = {
51      1,   2,  4,  6,
52      8,  10, 12, 14,
53      15, 17, 19, 21,
54      23, 25, 27, 28
55  };
56  static const unsigned char pc2[48] = {
57      13, 16, 10, 23,  0,  4,      2, 27, 14,  5, 20,  9,
58      22, 18, 11,  3, 25,  7,     15,  6, 26, 19, 12,  1,
59      40, 51, 30, 36, 46, 54,     29, 39, 50, 44, 32, 47,
60      43, 48, 38, 55, 33, 52,     45, 41, 49, 35, 28, 31
61  };
62  static const ulong32 SP1[64] =
63  {
64      0x01010400UL, 0x00000000UL, 0x00010000UL, 0x01010404UL,
65      0x01010004UL, 0x00010404UL, 0x00000004UL, 0x00010000UL,
66      0x00000400UL, 0x01010400UL, 0x01010404UL, 0x00000400UL,
67      0x01000404UL, 0x01010004UL, 0x01000000UL, 0x00000004UL,
68      0x00000404UL, 0x01000400UL, 0x01000400UL, 0x00010400UL,
69      0x00010400UL, 0x01010000UL, 0x01010000UL, 0x01000404UL,
70      0x00010004UL, 0x01000004UL, 0x01000004UL, 0x00010004UL,
71      0x00000000UL, 0x00000404UL, 0x00010404UL, 0x01000000UL,
72      0x00010000UL, 0x01010404UL, 0x00000004UL, 0x01010000UL,
73      0x01010400UL, 0x01000000UL, 0x01000000UL, 0x00000400UL,
74      0x01010004UL, 0x00010000UL, 0x00010400UL, 0x01000004UL,
75      0x00000400UL, 0x00000004UL, 0x01000404UL, 0x00010404UL,
76      0x01010404UL, 0x00010004UL, 0x01010000UL, 0x01000404UL,
77      0x01000004UL, 0x00000404UL, 0x00010404UL, 0x01010400UL,
78      0x00000404UL, 0x01000400UL, 0x01000400UL, 0x00000000UL,
79      0x00010004UL, 0x00010400UL, 0x00000000UL, 0x01010004UL
80  };
81  static const ulong32 SP2[64] =
82  {
83      0x80108020UL, 0x80008000UL, 0x00008000UL, 0x00108020UL,
84      0x00100000UL, 0x00000020UL, 0x80100020UL, 0x80008020UL,
85      0x80000020UL, 0x80108020UL, 0x80108000UL, 0x80000000UL,
86      0x80008000UL, 0x00100000UL, 0x00000020UL, 0x80100020UL,
87      0x00108000UL, 0x00100020UL, 0x80008020UL, 0x00000000UL,
88      0x80000000UL, 0x00008000UL, 0x00108020UL, 0x80100000UL,
89      0x00100020UL, 0x80000020UL, 0x00000000UL, 0x00108000UL,
90      0x00008020UL, 0x80108000UL, 0x80100000UL, 0x00008020UL,
91      0x00000000UL, 0x00108020UL, 0x80100020UL, 0x00100000UL,
92      0x80008020UL, 0x80100000UL, 0x80108000UL, 0x00008000UL,
93      0x80100000UL, 0x80008000UL, 0x00000020UL, 0x80108020UL,
94      0x00108020UL, 0x00000020UL, 0x00008000UL, 0x80000000UL,
95      0x00008020UL, 0x80108000UL, 0x00100000UL, 0x80000020UL,
96      0x00100020UL, 0x80008020UL, 0x80000020UL, 0x00100020UL,
97      0x00108000UL, 0x00000000UL, 0x80008000UL, 0x00008020UL,
98      0x80000000UL, 0x80100020UL, 0x80108020UL, 0x00108000UL
99  };
100  static const ulong32 SP3[64] =
101  {
102      0x00000208UL, 0x08020200UL, 0x00000000UL, 0x08020008UL,
103      0x08000200UL, 0x00000000UL, 0x00020208UL, 0x08000200UL,
104      0x00020008UL, 0x08000008UL, 0x08000008UL, 0x00020000UL,
105      0x08020208UL, 0x00020008UL, 0x08020000UL, 0x00000208UL,
106      0x08000000UL, 0x00000008UL, 0x08020200UL, 0x00000200UL,
107      0x00020200UL, 0x08020000UL, 0x08020008UL, 0x00020208UL,
108      0x08000208UL, 0x00020200UL, 0x00020000UL, 0x08000208UL,
109      0x00000008UL, 0x08020208UL, 0x00000200UL, 0x08000000UL,
110      0x08020200UL, 0x08000000UL, 0x00020008UL, 0x00000208UL,
111      0x00020000UL, 0x08020200UL, 0x08000200UL, 0x00000000UL,
112      0x00000200UL, 0x00020008UL, 0x08020208UL, 0x08000200UL,
113      0x08000008UL, 0x00000200UL, 0x00000000UL, 0x08020008UL,
114      0x08000208UL, 0x00020000UL, 0x08000000UL, 0x08020208UL,
115      0x00000008UL, 0x00020208UL, 0x00020200UL, 0x08000008UL,
116      0x08020000UL, 0x08000208UL, 0x00000208UL, 0x08020000UL,
117      0x00020208UL, 0x00000008UL, 0x08020008UL, 0x00020200UL
118  };
119  static const ulong32 SP4[64] =
120  {
121      0x00802001UL, 0x00002081UL, 0x00002081UL, 0x00000080UL,
122      0x00802080UL, 0x00800081UL, 0x00800001UL, 0x00002001UL,
123      0x00000000UL, 0x00802000UL, 0x00802000UL, 0x00802081UL,
124      0x00000081UL, 0x00000000UL, 0x00800080UL, 0x00800001UL,
125      0x00000001UL, 0x00002000UL, 0x00800000UL, 0x00802001UL,
126      0x00000080UL, 0x00800000UL, 0x00002001UL, 0x00002080UL,
127      0x00800081UL, 0x00000001UL, 0x00002080UL, 0x00800080UL,
128      0x00002000UL, 0x00802080UL, 0x00802081UL, 0x00000081UL,
129      0x00800080UL, 0x00800001UL, 0x00802000UL, 0x00802081UL,
130      0x00000081UL, 0x00000000UL, 0x00000000UL, 0x00802000UL,
131      0x00002080UL, 0x00800080UL, 0x00800081UL, 0x00000001UL,
132      0x00802001UL, 0x00002081UL, 0x00002081UL, 0x00000080UL,
133      0x00802081UL, 0x00000081UL, 0x00000001UL, 0x00002000UL,
134      0x00800001UL, 0x00002001UL, 0x00802080UL, 0x00800081UL,
135      0x00002001UL, 0x00002080UL, 0x00800000UL, 0x00802001UL,
136      0x00000080UL, 0x00800000UL, 0x00002000UL, 0x00802080UL
137  };
138  static const ulong32 SP5[64] =
139  {
140      0x00000100UL, 0x02080100UL, 0x02080000UL, 0x42000100UL,
141      0x00080000UL, 0x00000100UL, 0x40000000UL, 0x02080000UL,
142      0x40080100UL, 0x00080000UL, 0x02000100UL, 0x40080100UL,
143      0x42000100UL, 0x42080000UL, 0x00080100UL, 0x40000000UL,
144      0x02000000UL, 0x40080000UL, 0x40080000UL, 0x00000000UL,
145      0x40000100UL, 0x42080100UL, 0x42080100UL, 0x02000100UL,
146      0x42080000UL, 0x40000100UL, 0x00000000UL, 0x42000000UL,
147      0x02080100UL, 0x02000000UL, 0x42000000UL, 0x00080100UL,
148      0x00080000UL, 0x42000100UL, 0x00000100UL, 0x02000000UL,
149      0x40000000UL, 0x02080000UL, 0x42000100UL, 0x40080100UL,
150      0x02000100UL, 0x40000000UL, 0x42080000UL, 0x02080100UL,
151      0x40080100UL, 0x00000100UL, 0x02000000UL, 0x42080000UL,
152      0x42080100UL, 0x00080100UL, 0x42000000UL, 0x42080100UL,
153      0x02080000UL, 0x00000000UL, 0x40080000UL, 0x42000000UL,
154      0x00080100UL, 0x02000100UL, 0x40000100UL, 0x00080000UL,
155      0x00000000UL, 0x40080000UL, 0x02080100UL, 0x40000100UL
156  };
157  static const ulong32 SP6[64] =
158  {
159      0x20000010UL, 0x20400000UL, 0x00004000UL, 0x20404010UL,
160      0x20400000UL, 0x00000010UL, 0x20404010UL, 0x00400000UL,
161      0x20004000UL, 0x00404010UL, 0x00400000UL, 0x20000010UL,
162      0x00400010UL, 0x20004000UL, 0x20000000UL, 0x00004010UL,
163      0x00000000UL, 0x00400010UL, 0x20004010UL, 0x00004000UL,
164      0x00404000UL, 0x20004010UL, 0x00000010UL, 0x20400010UL,
165      0x20400010UL, 0x00000000UL, 0x00404010UL, 0x20404000UL,
166      0x00004010UL, 0x00404000UL, 0x20404000UL, 0x20000000UL,
167      0x20004000UL, 0x00000010UL, 0x20400010UL, 0x00404000UL,
168      0x20404010UL, 0x00400000UL, 0x00004010UL, 0x20000010UL,
169      0x00400000UL, 0x20004000UL, 0x20000000UL, 0x00004010UL,
170      0x20000010UL, 0x20404010UL, 0x00404000UL, 0x20400000UL,
171      0x00404010UL, 0x20404000UL, 0x00000000UL, 0x20400010UL,
172      0x00000010UL, 0x00004000UL, 0x20400000UL, 0x00404010UL,
173      0x00004000UL, 0x00400010UL, 0x20004010UL, 0x00000000UL,
174      0x20404000UL, 0x20000000UL, 0x00400010UL, 0x20004010UL
175  };
176  static const ulong32 SP7[64] =
177  {
178      0x00200000UL, 0x04200002UL, 0x04000802UL, 0x00000000UL,
179      0x00000800UL, 0x04000802UL, 0x00200802UL, 0x04200800UL,
180      0x04200802UL, 0x00200000UL, 0x00000000UL, 0x04000002UL,
181      0x00000002UL, 0x04000000UL, 0x04200002UL, 0x00000802UL,
182      0x04000800UL, 0x00200802UL, 0x00200002UL, 0x04000800UL,
183      0x04000002UL, 0x04200000UL, 0x04200800UL, 0x00200002UL,
184      0x04200000UL, 0x00000800UL, 0x00000802UL, 0x04200802UL,
185      0x00200800UL, 0x00000002UL, 0x04000000UL, 0x00200800UL,
186      0x04000000UL, 0x00200800UL, 0x00200000UL, 0x04000802UL,
187      0x04000802UL, 0x04200002UL, 0x04200002UL, 0x00000002UL,
188      0x00200002UL, 0x04000000UL, 0x04000800UL, 0x00200000UL,
189      0x04200800UL, 0x00000802UL, 0x00200802UL, 0x04200800UL,
190      0x00000802UL, 0x04000002UL, 0x04200802UL, 0x04200000UL,
191      0x00200800UL, 0x00000000UL, 0x00000002UL, 0x04200802UL,
192      0x00000000UL, 0x00200802UL, 0x04200000UL, 0x00000800UL,
193      0x04000002UL, 0x04000800UL, 0x00000800UL, 0x00200002UL
194  };
195  static const ulong32 SP8[64] =
196  {
197      0x10001040UL, 0x00001000UL, 0x00040000UL, 0x10041040UL,
198      0x10000000UL, 0x10001040UL, 0x00000040UL, 0x10000000UL,
199      0x00040040UL, 0x10040000UL, 0x10041040UL, 0x00041000UL,
200      0x10041000UL, 0x00041040UL, 0x00001000UL, 0x00000040UL,
201      0x10040000UL, 0x10000040UL, 0x10001000UL, 0x00001040UL,
202      0x00041000UL, 0x00040040UL, 0x10040040UL, 0x10041000UL,
203      0x00001040UL, 0x00000000UL, 0x00000000UL, 0x10040040UL,
204      0x10000040UL, 0x10001000UL, 0x00041040UL, 0x00040000UL,
205      0x00041040UL, 0x00040000UL, 0x10041000UL, 0x00001000UL,
206      0x00000040UL, 0x10040040UL, 0x00001000UL, 0x00041040UL,
207      0x10001000UL, 0x00000040UL, 0x10000040UL, 0x10040000UL,
208      0x10040040UL, 0x10000000UL, 0x00040000UL, 0x10001040UL,
209      0x00000000UL, 0x10041040UL, 0x00040040UL, 0x10000040UL,
210      0x10040000UL, 0x10001000UL, 0x10001040UL, 0x00000000UL,
211      0x10041040UL, 0x00041000UL, 0x00041000UL, 0x00001040UL,
212      0x00001040UL, 0x00040040UL, 0x10000000UL, 0x10041000UL
213  };
214  #ifndef LTC_SMALL_CODE
215  static const ulong64 des_ip[8][256] = {
216  { CONST64(0x0000000000000000), CONST64(0x0000001000000000), CONST64(0x0000000000000010), CONST64(0x0000001000000010),
217    CONST64(0x0000100000000000), CONST64(0x0000101000000000), CONST64(0x0000100000000010), CONST64(0x0000101000000010),
218    CONST64(0x0000000000001000), CONST64(0x0000001000001000), CONST64(0x0000000000001010), CONST64(0x0000001000001010),
219    CONST64(0x0000100000001000), CONST64(0x0000101000001000), CONST64(0x0000100000001010), CONST64(0x0000101000001010),
220    CONST64(0x0010000000000000), CONST64(0x0010001000000000), CONST64(0x0010000000000010), CONST64(0x0010001000000010),
221    CONST64(0x0010100000000000), CONST64(0x0010101000000000), CONST64(0x0010100000000010), CONST64(0x0010101000000010),
222    CONST64(0x0010000000001000), CONST64(0x0010001000001000), CONST64(0x0010000000001010), CONST64(0x0010001000001010),
223    CONST64(0x0010100000001000), CONST64(0x0010101000001000), CONST64(0x0010100000001010), CONST64(0x0010101000001010),
224    CONST64(0x0000000000100000), CONST64(0x0000001000100000), CONST64(0x0000000000100010), CONST64(0x0000001000100010),
225    CONST64(0x0000100000100000), CONST64(0x0000101000100000), CONST64(0x0000100000100010), CONST64(0x0000101000100010),
226    CONST64(0x0000000000101000), CONST64(0x0000001000101000), CONST64(0x0000000000101010), CONST64(0x0000001000101010),
227    CONST64(0x0000100000101000), CONST64(0x0000101000101000), CONST64(0x0000100000101010), CONST64(0x0000101000101010),
228    CONST64(0x0010000000100000), CONST64(0x0010001000100000), CONST64(0x0010000000100010), CONST64(0x0010001000100010),
229    CONST64(0x0010100000100000), CONST64(0x0010101000100000), CONST64(0x0010100000100010), CONST64(0x0010101000100010),
230    CONST64(0x0010000000101000), CONST64(0x0010001000101000), CONST64(0x0010000000101010), CONST64(0x0010001000101010),
231    CONST64(0x0010100000101000), CONST64(0x0010101000101000), CONST64(0x0010100000101010), CONST64(0x0010101000101010),
232    CONST64(0x1000000000000000), CONST64(0x1000001000000000), CONST64(0x1000000000000010), CONST64(0x1000001000000010),
233    CONST64(0x1000100000000000), CONST64(0x1000101000000000), CONST64(0x1000100000000010), CONST64(0x1000101000000010),
234    CONST64(0x1000000000001000), CONST64(0x1000001000001000), CONST64(0x1000000000001010), CONST64(0x1000001000001010),
235    CONST64(0x1000100000001000), CONST64(0x1000101000001000), CONST64(0x1000100000001010), CONST64(0x1000101000001010),
236    CONST64(0x1010000000000000), CONST64(0x1010001000000000), CONST64(0x1010000000000010), CONST64(0x1010001000000010),
237    CONST64(0x1010100000000000), CONST64(0x1010101000000000), CONST64(0x1010100000000010), CONST64(0x1010101000000010),
238    CONST64(0x1010000000001000), CONST64(0x1010001000001000), CONST64(0x1010000000001010), CONST64(0x1010001000001010),
239    CONST64(0x1010100000001000), CONST64(0x1010101000001000), CONST64(0x1010100000001010), CONST64(0x1010101000001010),
240    CONST64(0x1000000000100000), CONST64(0x1000001000100000), CONST64(0x1000000000100010), CONST64(0x1000001000100010),
241    CONST64(0x1000100000100000), CONST64(0x1000101000100000), CONST64(0x1000100000100010), CONST64(0x1000101000100010),
242    CONST64(0x1000000000101000), CONST64(0x1000001000101000), CONST64(0x1000000000101010), CONST64(0x1000001000101010),
243    CONST64(0x1000100000101000), CONST64(0x1000101000101000), CONST64(0x1000100000101010), CONST64(0x1000101000101010),
244    CONST64(0x1010000000100000), CONST64(0x1010001000100000), CONST64(0x1010000000100010), CONST64(0x1010001000100010),
245    CONST64(0x1010100000100000), CONST64(0x1010101000100000), CONST64(0x1010100000100010), CONST64(0x1010101000100010),
246    CONST64(0x1010000000101000), CONST64(0x1010001000101000), CONST64(0x1010000000101010), CONST64(0x1010001000101010),
247    CONST64(0x1010100000101000), CONST64(0x1010101000101000), CONST64(0x1010100000101010), CONST64(0x1010101000101010),
248    CONST64(0x0000000010000000), CONST64(0x0000001010000000), CONST64(0x0000000010000010), CONST64(0x0000001010000010),
249    CONST64(0x0000100010000000), CONST64(0x0000101010000000), CONST64(0x0000100010000010), CONST64(0x0000101010000010),
250    CONST64(0x0000000010001000), CONST64(0x0000001010001000), CONST64(0x0000000010001010), CONST64(0x0000001010001010),
251    CONST64(0x0000100010001000), CONST64(0x0000101010001000), CONST64(0x0000100010001010), CONST64(0x0000101010001010),
252    CONST64(0x0010000010000000), CONST64(0x0010001010000000), CONST64(0x0010000010000010), CONST64(0x0010001010000010),
253    CONST64(0x0010100010000000), CONST64(0x0010101010000000), CONST64(0x0010100010000010), CONST64(0x0010101010000010),
254    CONST64(0x0010000010001000), CONST64(0x0010001010001000), CONST64(0x0010000010001010), CONST64(0x0010001010001010),
255    CONST64(0x0010100010001000), CONST64(0x0010101010001000), CONST64(0x0010100010001010), CONST64(0x0010101010001010),
256    CONST64(0x0000000010100000), CONST64(0x0000001010100000), CONST64(0x0000000010100010), CONST64(0x0000001010100010),
257    CONST64(0x0000100010100000), CONST64(0x0000101010100000), CONST64(0x0000100010100010), CONST64(0x0000101010100010),
258    CONST64(0x0000000010101000), CONST64(0x0000001010101000), CONST64(0x0000000010101010), CONST64(0x0000001010101010),
259    CONST64(0x0000100010101000), CONST64(0x0000101010101000), CONST64(0x0000100010101010), CONST64(0x0000101010101010),
260    CONST64(0x0010000010100000), CONST64(0x0010001010100000), CONST64(0x0010000010100010), CONST64(0x0010001010100010),
261    CONST64(0x0010100010100000), CONST64(0x0010101010100000), CONST64(0x0010100010100010), CONST64(0x0010101010100010),
262    CONST64(0x0010000010101000), CONST64(0x0010001010101000), CONST64(0x0010000010101010), CONST64(0x0010001010101010),
263    CONST64(0x0010100010101000), CONST64(0x0010101010101000), CONST64(0x0010100010101010), CONST64(0x0010101010101010),
264    CONST64(0x1000000010000000), CONST64(0x1000001010000000), CONST64(0x1000000010000010), CONST64(0x1000001010000010),
265    CONST64(0x1000100010000000), CONST64(0x1000101010000000), CONST64(0x1000100010000010), CONST64(0x1000101010000010),
266    CONST64(0x1000000010001000), CONST64(0x1000001010001000), CONST64(0x1000000010001010), CONST64(0x1000001010001010),
267    CONST64(0x1000100010001000), CONST64(0x1000101010001000), CONST64(0x1000100010001010), CONST64(0x1000101010001010),
268    CONST64(0x1010000010000000), CONST64(0x1010001010000000), CONST64(0x1010000010000010), CONST64(0x1010001010000010),
269    CONST64(0x1010100010000000), CONST64(0x1010101010000000), CONST64(0x1010100010000010), CONST64(0x1010101010000010),
270    CONST64(0x1010000010001000), CONST64(0x1010001010001000), CONST64(0x1010000010001010), CONST64(0x1010001010001010),
271    CONST64(0x1010100010001000), CONST64(0x1010101010001000), CONST64(0x1010100010001010), CONST64(0x1010101010001010),
272    CONST64(0x1000000010100000), CONST64(0x1000001010100000), CONST64(0x1000000010100010), CONST64(0x1000001010100010),
273    CONST64(0x1000100010100000), CONST64(0x1000101010100000), CONST64(0x1000100010100010), CONST64(0x1000101010100010),
274    CONST64(0x1000000010101000), CONST64(0x1000001010101000), CONST64(0x1000000010101010), CONST64(0x1000001010101010),
275    CONST64(0x1000100010101000), CONST64(0x1000101010101000), CONST64(0x1000100010101010), CONST64(0x1000101010101010),
276    CONST64(0x1010000010100000), CONST64(0x1010001010100000), CONST64(0x1010000010100010), CONST64(0x1010001010100010),
277    CONST64(0x1010100010100000), CONST64(0x1010101010100000), CONST64(0x1010100010100010), CONST64(0x1010101010100010),
278    CONST64(0x1010000010101000), CONST64(0x1010001010101000), CONST64(0x1010000010101010), CONST64(0x1010001010101010),
279    CONST64(0x1010100010101000), CONST64(0x1010101010101000), CONST64(0x1010100010101010), CONST64(0x1010101010101010)
280    },
281  { CONST64(0x0000000000000000), CONST64(0x0000000800000000), CONST64(0x0000000000000008), CONST64(0x0000000800000008),
282    CONST64(0x0000080000000000), CONST64(0x0000080800000000), CONST64(0x0000080000000008), CONST64(0x0000080800000008),
283    CONST64(0x0000000000000800), CONST64(0x0000000800000800), CONST64(0x0000000000000808), CONST64(0x0000000800000808),
284    CONST64(0x0000080000000800), CONST64(0x0000080800000800), CONST64(0x0000080000000808), CONST64(0x0000080800000808),
285    CONST64(0x0008000000000000), CONST64(0x0008000800000000), CONST64(0x0008000000000008), CONST64(0x0008000800000008),
286    CONST64(0x0008080000000000), CONST64(0x0008080800000000), CONST64(0x0008080000000008), CONST64(0x0008080800000008),
287    CONST64(0x0008000000000800), CONST64(0x0008000800000800), CONST64(0x0008000000000808), CONST64(0x0008000800000808),
288    CONST64(0x0008080000000800), CONST64(0x0008080800000800), CONST64(0x0008080000000808), CONST64(0x0008080800000808),
289    CONST64(0x0000000000080000), CONST64(0x0000000800080000), CONST64(0x0000000000080008), CONST64(0x0000000800080008),
290    CONST64(0x0000080000080000), CONST64(0x0000080800080000), CONST64(0x0000080000080008), CONST64(0x0000080800080008),
291    CONST64(0x0000000000080800), CONST64(0x0000000800080800), CONST64(0x0000000000080808), CONST64(0x0000000800080808),
292    CONST64(0x0000080000080800), CONST64(0x0000080800080800), CONST64(0x0000080000080808), CONST64(0x0000080800080808),
293    CONST64(0x0008000000080000), CONST64(0x0008000800080000), CONST64(0x0008000000080008), CONST64(0x0008000800080008),
294    CONST64(0x0008080000080000), CONST64(0x0008080800080000), CONST64(0x0008080000080008), CONST64(0x0008080800080008),
295    CONST64(0x0008000000080800), CONST64(0x0008000800080800), CONST64(0x0008000000080808), CONST64(0x0008000800080808),
296    CONST64(0x0008080000080800), CONST64(0x0008080800080800), CONST64(0x0008080000080808), CONST64(0x0008080800080808),
297    CONST64(0x0800000000000000), CONST64(0x0800000800000000), CONST64(0x0800000000000008), CONST64(0x0800000800000008),
298    CONST64(0x0800080000000000), CONST64(0x0800080800000000), CONST64(0x0800080000000008), CONST64(0x0800080800000008),
299    CONST64(0x0800000000000800), CONST64(0x0800000800000800), CONST64(0x0800000000000808), CONST64(0x0800000800000808),
300    CONST64(0x0800080000000800), CONST64(0x0800080800000800), CONST64(0x0800080000000808), CONST64(0x0800080800000808),
301    CONST64(0x0808000000000000), CONST64(0x0808000800000000), CONST64(0x0808000000000008), CONST64(0x0808000800000008),
302    CONST64(0x0808080000000000), CONST64(0x0808080800000000), CONST64(0x0808080000000008), CONST64(0x0808080800000008),
303    CONST64(0x0808000000000800), CONST64(0x0808000800000800), CONST64(0x0808000000000808), CONST64(0x0808000800000808),
304    CONST64(0x0808080000000800), CONST64(0x0808080800000800), CONST64(0x0808080000000808), CONST64(0x0808080800000808),
305    CONST64(0x0800000000080000), CONST64(0x0800000800080000), CONST64(0x0800000000080008), CONST64(0x0800000800080008),
306    CONST64(0x0800080000080000), CONST64(0x0800080800080000), CONST64(0x0800080000080008), CONST64(0x0800080800080008),
307    CONST64(0x0800000000080800), CONST64(0x0800000800080800), CONST64(0x0800000000080808), CONST64(0x0800000800080808),
308    CONST64(0x0800080000080800), CONST64(0x0800080800080800), CONST64(0x0800080000080808), CONST64(0x0800080800080808),
309    CONST64(0x0808000000080000), CONST64(0x0808000800080000), CONST64(0x0808000000080008), CONST64(0x0808000800080008),
310    CONST64(0x0808080000080000), CONST64(0x0808080800080000), CONST64(0x0808080000080008), CONST64(0x0808080800080008),
311    CONST64(0x0808000000080800), CONST64(0x0808000800080800), CONST64(0x0808000000080808), CONST64(0x0808000800080808),
312    CONST64(0x0808080000080800), CONST64(0x0808080800080800), CONST64(0x0808080000080808), CONST64(0x0808080800080808),
313    CONST64(0x0000000008000000), CONST64(0x0000000808000000), CONST64(0x0000000008000008), CONST64(0x0000000808000008),
314    CONST64(0x0000080008000000), CONST64(0x0000080808000000), CONST64(0x0000080008000008), CONST64(0x0000080808000008),
315    CONST64(0x0000000008000800), CONST64(0x0000000808000800), CONST64(0x0000000008000808), CONST64(0x0000000808000808),
316    CONST64(0x0000080008000800), CONST64(0x0000080808000800), CONST64(0x0000080008000808), CONST64(0x0000080808000808),
317    CONST64(0x0008000008000000), CONST64(0x0008000808000000), CONST64(0x0008000008000008), CONST64(0x0008000808000008),
318    CONST64(0x0008080008000000), CONST64(0x0008080808000000), CONST64(0x0008080008000008), CONST64(0x0008080808000008),
319    CONST64(0x0008000008000800), CONST64(0x0008000808000800), CONST64(0x0008000008000808), CONST64(0x0008000808000808),
320    CONST64(0x0008080008000800), CONST64(0x0008080808000800), CONST64(0x0008080008000808), CONST64(0x0008080808000808),
321    CONST64(0x0000000008080000), CONST64(0x0000000808080000), CONST64(0x0000000008080008), CONST64(0x0000000808080008),
322    CONST64(0x0000080008080000), CONST64(0x0000080808080000), CONST64(0x0000080008080008), CONST64(0x0000080808080008),
323    CONST64(0x0000000008080800), CONST64(0x0000000808080800), CONST64(0x0000000008080808), CONST64(0x0000000808080808),
324    CONST64(0x0000080008080800), CONST64(0x0000080808080800), CONST64(0x0000080008080808), CONST64(0x0000080808080808),
325    CONST64(0x0008000008080000), CONST64(0x0008000808080000), CONST64(0x0008000008080008), CONST64(0x0008000808080008),
326    CONST64(0x0008080008080000), CONST64(0x0008080808080000), CONST64(0x0008080008080008), CONST64(0x0008080808080008),
327    CONST64(0x0008000008080800), CONST64(0x0008000808080800), CONST64(0x0008000008080808), CONST64(0x0008000808080808),
328    CONST64(0x0008080008080800), CONST64(0x0008080808080800), CONST64(0x0008080008080808), CONST64(0x0008080808080808),
329    CONST64(0x0800000008000000), CONST64(0x0800000808000000), CONST64(0x0800000008000008), CONST64(0x0800000808000008),
330    CONST64(0x0800080008000000), CONST64(0x0800080808000000), CONST64(0x0800080008000008), CONST64(0x0800080808000008),
331    CONST64(0x0800000008000800), CONST64(0x0800000808000800), CONST64(0x0800000008000808), CONST64(0x0800000808000808),
332    CONST64(0x0800080008000800), CONST64(0x0800080808000800), CONST64(0x0800080008000808), CONST64(0x0800080808000808),
333    CONST64(0x0808000008000000), CONST64(0x0808000808000000), CONST64(0x0808000008000008), CONST64(0x0808000808000008),
334    CONST64(0x0808080008000000), CONST64(0x0808080808000000), CONST64(0x0808080008000008), CONST64(0x0808080808000008),
335    CONST64(0x0808000008000800), CONST64(0x0808000808000800), CONST64(0x0808000008000808), CONST64(0x0808000808000808),
336    CONST64(0x0808080008000800), CONST64(0x0808080808000800), CONST64(0x0808080008000808), CONST64(0x0808080808000808),
337    CONST64(0x0800000008080000), CONST64(0x0800000808080000), CONST64(0x0800000008080008), CONST64(0x0800000808080008),
338    CONST64(0x0800080008080000), CONST64(0x0800080808080000), CONST64(0x0800080008080008), CONST64(0x0800080808080008),
339    CONST64(0x0800000008080800), CONST64(0x0800000808080800), CONST64(0x0800000008080808), CONST64(0x0800000808080808),
340    CONST64(0x0800080008080800), CONST64(0x0800080808080800), CONST64(0x0800080008080808), CONST64(0x0800080808080808),
341    CONST64(0x0808000008080000), CONST64(0x0808000808080000), CONST64(0x0808000008080008), CONST64(0x0808000808080008),
342    CONST64(0x0808080008080000), CONST64(0x0808080808080000), CONST64(0x0808080008080008), CONST64(0x0808080808080008),
343    CONST64(0x0808000008080800), CONST64(0x0808000808080800), CONST64(0x0808000008080808), CONST64(0x0808000808080808),
344    CONST64(0x0808080008080800), CONST64(0x0808080808080800), CONST64(0x0808080008080808), CONST64(0x0808080808080808)
345    },
346  { CONST64(0x0000000000000000), CONST64(0x0000000400000000), CONST64(0x0000000000000004), CONST64(0x0000000400000004),
347    CONST64(0x0000040000000000), CONST64(0x0000040400000000), CONST64(0x0000040000000004), CONST64(0x0000040400000004),
348    CONST64(0x0000000000000400), CONST64(0x0000000400000400), CONST64(0x0000000000000404), CONST64(0x0000000400000404),
349    CONST64(0x0000040000000400), CONST64(0x0000040400000400), CONST64(0x0000040000000404), CONST64(0x0000040400000404),
350    CONST64(0x0004000000000000), CONST64(0x0004000400000000), CONST64(0x0004000000000004), CONST64(0x0004000400000004),
351    CONST64(0x0004040000000000), CONST64(0x0004040400000000), CONST64(0x0004040000000004), CONST64(0x0004040400000004),
352    CONST64(0x0004000000000400), CONST64(0x0004000400000400), CONST64(0x0004000000000404), CONST64(0x0004000400000404),
353    CONST64(0x0004040000000400), CONST64(0x0004040400000400), CONST64(0x0004040000000404), CONST64(0x0004040400000404),
354    CONST64(0x0000000000040000), CONST64(0x0000000400040000), CONST64(0x0000000000040004), CONST64(0x0000000400040004),
355    CONST64(0x0000040000040000), CONST64(0x0000040400040000), CONST64(0x0000040000040004), CONST64(0x0000040400040004),
356    CONST64(0x0000000000040400), CONST64(0x0000000400040400), CONST64(0x0000000000040404), CONST64(0x0000000400040404),
357    CONST64(0x0000040000040400), CONST64(0x0000040400040400), CONST64(0x0000040000040404), CONST64(0x0000040400040404),
358    CONST64(0x0004000000040000), CONST64(0x0004000400040000), CONST64(0x0004000000040004), CONST64(0x0004000400040004),
359    CONST64(0x0004040000040000), CONST64(0x0004040400040000), CONST64(0x0004040000040004), CONST64(0x0004040400040004),
360    CONST64(0x0004000000040400), CONST64(0x0004000400040400), CONST64(0x0004000000040404), CONST64(0x0004000400040404),
361    CONST64(0x0004040000040400), CONST64(0x0004040400040400), CONST64(0x0004040000040404), CONST64(0x0004040400040404),
362    CONST64(0x0400000000000000), CONST64(0x0400000400000000), CONST64(0x0400000000000004), CONST64(0x0400000400000004),
363    CONST64(0x0400040000000000), CONST64(0x0400040400000000), CONST64(0x0400040000000004), CONST64(0x0400040400000004),
364    CONST64(0x0400000000000400), CONST64(0x0400000400000400), CONST64(0x0400000000000404), CONST64(0x0400000400000404),
365    CONST64(0x0400040000000400), CONST64(0x0400040400000400), CONST64(0x0400040000000404), CONST64(0x0400040400000404),
366    CONST64(0x0404000000000000), CONST64(0x0404000400000000), CONST64(0x0404000000000004), CONST64(0x0404000400000004),
367    CONST64(0x0404040000000000), CONST64(0x0404040400000000), CONST64(0x0404040000000004), CONST64(0x0404040400000004),
368    CONST64(0x0404000000000400), CONST64(0x0404000400000400), CONST64(0x0404000000000404), CONST64(0x0404000400000404),
369    CONST64(0x0404040000000400), CONST64(0x0404040400000400), CONST64(0x0404040000000404), CONST64(0x0404040400000404),
370    CONST64(0x0400000000040000), CONST64(0x0400000400040000), CONST64(0x0400000000040004), CONST64(0x0400000400040004),
371    CONST64(0x0400040000040000), CONST64(0x0400040400040000), CONST64(0x0400040000040004), CONST64(0x0400040400040004),
372    CONST64(0x0400000000040400), CONST64(0x0400000400040400), CONST64(0x0400000000040404), CONST64(0x0400000400040404),
373    CONST64(0x0400040000040400), CONST64(0x0400040400040400), CONST64(0x0400040000040404), CONST64(0x0400040400040404),
374    CONST64(0x0404000000040000), CONST64(0x0404000400040000), CONST64(0x0404000000040004), CONST64(0x0404000400040004),
375    CONST64(0x0404040000040000), CONST64(0x0404040400040000), CONST64(0x0404040000040004), CONST64(0x0404040400040004),
376    CONST64(0x0404000000040400), CONST64(0x0404000400040400), CONST64(0x0404000000040404), CONST64(0x0404000400040404),
377    CONST64(0x0404040000040400), CONST64(0x0404040400040400), CONST64(0x0404040000040404), CONST64(0x0404040400040404),
378    CONST64(0x0000000004000000), CONST64(0x0000000404000000), CONST64(0x0000000004000004), CONST64(0x0000000404000004),
379    CONST64(0x0000040004000000), CONST64(0x0000040404000000), CONST64(0x0000040004000004), CONST64(0x0000040404000004),
380    CONST64(0x0000000004000400), CONST64(0x0000000404000400), CONST64(0x0000000004000404), CONST64(0x0000000404000404),
381    CONST64(0x0000040004000400), CONST64(0x0000040404000400), CONST64(0x0000040004000404), CONST64(0x0000040404000404),
382    CONST64(0x0004000004000000), CONST64(0x0004000404000000), CONST64(0x0004000004000004), CONST64(0x0004000404000004),
383    CONST64(0x0004040004000000), CONST64(0x0004040404000000), CONST64(0x0004040004000004), CONST64(0x0004040404000004),
384    CONST64(0x0004000004000400), CONST64(0x0004000404000400), CONST64(0x0004000004000404), CONST64(0x0004000404000404),
385    CONST64(0x0004040004000400), CONST64(0x0004040404000400), CONST64(0x0004040004000404), CONST64(0x0004040404000404),
386    CONST64(0x0000000004040000), CONST64(0x0000000404040000), CONST64(0x0000000004040004), CONST64(0x0000000404040004),
387    CONST64(0x0000040004040000), CONST64(0x0000040404040000), CONST64(0x0000040004040004), CONST64(0x0000040404040004),
388    CONST64(0x0000000004040400), CONST64(0x0000000404040400), CONST64(0x0000000004040404), CONST64(0x0000000404040404),
389    CONST64(0x0000040004040400), CONST64(0x0000040404040400), CONST64(0x0000040004040404), CONST64(0x0000040404040404),
390    CONST64(0x0004000004040000), CONST64(0x0004000404040000), CONST64(0x0004000004040004), CONST64(0x0004000404040004),
391    CONST64(0x0004040004040000), CONST64(0x0004040404040000), CONST64(0x0004040004040004), CONST64(0x0004040404040004),
392    CONST64(0x0004000004040400), CONST64(0x0004000404040400), CONST64(0x0004000004040404), CONST64(0x0004000404040404),
393    CONST64(0x0004040004040400), CONST64(0x0004040404040400), CONST64(0x0004040004040404), CONST64(0x0004040404040404),
394    CONST64(0x0400000004000000), CONST64(0x0400000404000000), CONST64(0x0400000004000004), CONST64(0x0400000404000004),
395    CONST64(0x0400040004000000), CONST64(0x0400040404000000), CONST64(0x0400040004000004), CONST64(0x0400040404000004),
396    CONST64(0x0400000004000400), CONST64(0x0400000404000400), CONST64(0x0400000004000404), CONST64(0x0400000404000404),
397    CONST64(0x0400040004000400), CONST64(0x0400040404000400), CONST64(0x0400040004000404), CONST64(0x0400040404000404),
398    CONST64(0x0404000004000000), CONST64(0x0404000404000000), CONST64(0x0404000004000004), CONST64(0x0404000404000004),
399    CONST64(0x0404040004000000), CONST64(0x0404040404000000), CONST64(0x0404040004000004), CONST64(0x0404040404000004),
400    CONST64(0x0404000004000400), CONST64(0x0404000404000400), CONST64(0x0404000004000404), CONST64(0x0404000404000404),
401    CONST64(0x0404040004000400), CONST64(0x0404040404000400), CONST64(0x0404040004000404), CONST64(0x0404040404000404),
402    CONST64(0x0400000004040000), CONST64(0x0400000404040000), CONST64(0x0400000004040004), CONST64(0x0400000404040004),
403    CONST64(0x0400040004040000), CONST64(0x0400040404040000), CONST64(0x0400040004040004), CONST64(0x0400040404040004),
404    CONST64(0x0400000004040400), CONST64(0x0400000404040400), CONST64(0x0400000004040404), CONST64(0x0400000404040404),
405    CONST64(0x0400040004040400), CONST64(0x0400040404040400), CONST64(0x0400040004040404), CONST64(0x0400040404040404),
406    CONST64(0x0404000004040000), CONST64(0x0404000404040000), CONST64(0x0404000004040004), CONST64(0x0404000404040004),
407    CONST64(0x0404040004040000), CONST64(0x0404040404040000), CONST64(0x0404040004040004), CONST64(0x0404040404040004),
408    CONST64(0x0404000004040400), CONST64(0x0404000404040400), CONST64(0x0404000004040404), CONST64(0x0404000404040404),
409    CONST64(0x0404040004040400), CONST64(0x0404040404040400), CONST64(0x0404040004040404), CONST64(0x0404040404040404)
410    },
411  { CONST64(0x0000000000000000), CONST64(0x0000000200000000), CONST64(0x0000000000000002), CONST64(0x0000000200000002),
412    CONST64(0x0000020000000000), CONST64(0x0000020200000000), CONST64(0x0000020000000002), CONST64(0x0000020200000002),
413    CONST64(0x0000000000000200), CONST64(0x0000000200000200), CONST64(0x0000000000000202), CONST64(0x0000000200000202),
414    CONST64(0x0000020000000200), CONST64(0x0000020200000200), CONST64(0x0000020000000202), CONST64(0x0000020200000202),
415    CONST64(0x0002000000000000), CONST64(0x0002000200000000), CONST64(0x0002000000000002), CONST64(0x0002000200000002),
416    CONST64(0x0002020000000000), CONST64(0x0002020200000000), CONST64(0x0002020000000002), CONST64(0x0002020200000002),
417    CONST64(0x0002000000000200), CONST64(0x0002000200000200), CONST64(0x0002000000000202), CONST64(0x0002000200000202),
418    CONST64(0x0002020000000200), CONST64(0x0002020200000200), CONST64(0x0002020000000202), CONST64(0x0002020200000202),
419    CONST64(0x0000000000020000), CONST64(0x0000000200020000), CONST64(0x0000000000020002), CONST64(0x0000000200020002),
420    CONST64(0x0000020000020000), CONST64(0x0000020200020000), CONST64(0x0000020000020002), CONST64(0x0000020200020002),
421    CONST64(0x0000000000020200), CONST64(0x0000000200020200), CONST64(0x0000000000020202), CONST64(0x0000000200020202),
422    CONST64(0x0000020000020200), CONST64(0x0000020200020200), CONST64(0x0000020000020202), CONST64(0x0000020200020202),
423    CONST64(0x0002000000020000), CONST64(0x0002000200020000), CONST64(0x0002000000020002), CONST64(0x0002000200020002),
424    CONST64(0x0002020000020000), CONST64(0x0002020200020000), CONST64(0x0002020000020002), CONST64(0x0002020200020002),
425    CONST64(0x0002000000020200), CONST64(0x0002000200020200), CONST64(0x0002000000020202), CONST64(0x0002000200020202),
426    CONST64(0x0002020000020200), CONST64(0x0002020200020200), CONST64(0x0002020000020202), CONST64(0x0002020200020202),
427    CONST64(0x0200000000000000), CONST64(0x0200000200000000), CONST64(0x0200000000000002), CONST64(0x0200000200000002),
428    CONST64(0x0200020000000000), CONST64(0x0200020200000000), CONST64(0x0200020000000002), CONST64(0x0200020200000002),
429    CONST64(0x0200000000000200), CONST64(0x0200000200000200), CONST64(0x0200000000000202), CONST64(0x0200000200000202),
430    CONST64(0x0200020000000200), CONST64(0x0200020200000200), CONST64(0x0200020000000202), CONST64(0x0200020200000202),
431    CONST64(0x0202000000000000), CONST64(0x0202000200000000), CONST64(0x0202000000000002), CONST64(0x0202000200000002),
432    CONST64(0x0202020000000000), CONST64(0x0202020200000000), CONST64(0x0202020000000002), CONST64(0x0202020200000002),
433    CONST64(0x0202000000000200), CONST64(0x0202000200000200), CONST64(0x0202000000000202), CONST64(0x0202000200000202),
434    CONST64(0x0202020000000200), CONST64(0x0202020200000200), CONST64(0x0202020000000202), CONST64(0x0202020200000202),
435    CONST64(0x0200000000020000), CONST64(0x0200000200020000), CONST64(0x0200000000020002), CONST64(0x0200000200020002),
436    CONST64(0x0200020000020000), CONST64(0x0200020200020000), CONST64(0x0200020000020002), CONST64(0x0200020200020002),
437    CONST64(0x0200000000020200), CONST64(0x0200000200020200), CONST64(0x0200000000020202), CONST64(0x0200000200020202),
438    CONST64(0x0200020000020200), CONST64(0x0200020200020200), CONST64(0x0200020000020202), CONST64(0x0200020200020202),
439    CONST64(0x0202000000020000), CONST64(0x0202000200020000), CONST64(0x0202000000020002), CONST64(0x0202000200020002),
440    CONST64(0x0202020000020000), CONST64(0x0202020200020000), CONST64(0x0202020000020002), CONST64(0x0202020200020002),
441    CONST64(0x0202000000020200), CONST64(0x0202000200020200), CONST64(0x0202000000020202), CONST64(0x0202000200020202),
442    CONST64(0x0202020000020200), CONST64(0x0202020200020200), CONST64(0x0202020000020202), CONST64(0x0202020200020202),
443    CONST64(0x0000000002000000), CONST64(0x0000000202000000), CONST64(0x0000000002000002), CONST64(0x0000000202000002),
444    CONST64(0x0000020002000000), CONST64(0x0000020202000000), CONST64(0x0000020002000002), CONST64(0x0000020202000002),
445    CONST64(0x0000000002000200), CONST64(0x0000000202000200), CONST64(0x0000000002000202), CONST64(0x0000000202000202),
446    CONST64(0x0000020002000200), CONST64(0x0000020202000200), CONST64(0x0000020002000202), CONST64(0x0000020202000202),
447    CONST64(0x0002000002000000), CONST64(0x0002000202000000), CONST64(0x0002000002000002), CONST64(0x0002000202000002),
448    CONST64(0x0002020002000000), CONST64(0x0002020202000000), CONST64(0x0002020002000002), CONST64(0x0002020202000002),
449    CONST64(0x0002000002000200), CONST64(0x0002000202000200), CONST64(0x0002000002000202), CONST64(0x0002000202000202),
450    CONST64(0x0002020002000200), CONST64(0x0002020202000200), CONST64(0x0002020002000202), CONST64(0x0002020202000202),
451    CONST64(0x0000000002020000), CONST64(0x0000000202020000), CONST64(0x0000000002020002), CONST64(0x0000000202020002),
452    CONST64(0x0000020002020000), CONST64(0x0000020202020000), CONST64(0x0000020002020002), CONST64(0x0000020202020002),
453    CONST64(0x0000000002020200), CONST64(0x0000000202020200), CONST64(0x0000000002020202), CONST64(0x0000000202020202),
454    CONST64(0x0000020002020200), CONST64(0x0000020202020200), CONST64(0x0000020002020202), CONST64(0x0000020202020202),
455    CONST64(0x0002000002020000), CONST64(0x0002000202020000), CONST64(0x0002000002020002), CONST64(0x0002000202020002),
456    CONST64(0x0002020002020000), CONST64(0x0002020202020000), CONST64(0x0002020002020002), CONST64(0x0002020202020002),
457    CONST64(0x0002000002020200), CONST64(0x0002000202020200), CONST64(0x0002000002020202), CONST64(0x0002000202020202),
458    CONST64(0x0002020002020200), CONST64(0x0002020202020200), CONST64(0x0002020002020202), CONST64(0x0002020202020202),
459    CONST64(0x0200000002000000), CONST64(0x0200000202000000), CONST64(0x0200000002000002), CONST64(0x0200000202000002),
460    CONST64(0x0200020002000000), CONST64(0x0200020202000000), CONST64(0x0200020002000002), CONST64(0x0200020202000002),
461    CONST64(0x0200000002000200), CONST64(0x0200000202000200), CONST64(0x0200000002000202), CONST64(0x0200000202000202),
462    CONST64(0x0200020002000200), CONST64(0x0200020202000200), CONST64(0x0200020002000202), CONST64(0x0200020202000202),
463    CONST64(0x0202000002000000), CONST64(0x0202000202000000), CONST64(0x0202000002000002), CONST64(0x0202000202000002),
464    CONST64(0x0202020002000000), CONST64(0x0202020202000000), CONST64(0x0202020002000002), CONST64(0x0202020202000002),
465    CONST64(0x0202000002000200), CONST64(0x0202000202000200), CONST64(0x0202000002000202), CONST64(0x0202000202000202),
466    CONST64(0x0202020002000200), CONST64(0x0202020202000200), CONST64(0x0202020002000202), CONST64(0x0202020202000202),
467    CONST64(0x0200000002020000), CONST64(0x0200000202020000), CONST64(0x0200000002020002), CONST64(0x0200000202020002),
468    CONST64(0x0200020002020000), CONST64(0x0200020202020000), CONST64(0x0200020002020002), CONST64(0x0200020202020002),
469    CONST64(0x0200000002020200), CONST64(0x0200000202020200), CONST64(0x0200000002020202), CONST64(0x0200000202020202),
470    CONST64(0x0200020002020200), CONST64(0x0200020202020200), CONST64(0x0200020002020202), CONST64(0x0200020202020202),
471    CONST64(0x0202000002020000), CONST64(0x0202000202020000), CONST64(0x0202000002020002), CONST64(0x0202000202020002),
472    CONST64(0x0202020002020000), CONST64(0x0202020202020000), CONST64(0x0202020002020002), CONST64(0x0202020202020002),
473    CONST64(0x0202000002020200), CONST64(0x0202000202020200), CONST64(0x0202000002020202), CONST64(0x0202000202020202),
474    CONST64(0x0202020002020200), CONST64(0x0202020202020200), CONST64(0x0202020002020202), CONST64(0x0202020202020202)
475    },
476  { CONST64(0x0000000000000000), CONST64(0x0000010000000000), CONST64(0x0000000000000100), CONST64(0x0000010000000100),
477    CONST64(0x0001000000000000), CONST64(0x0001010000000000), CONST64(0x0001000000000100), CONST64(0x0001010000000100),
478    CONST64(0x0000000000010000), CONST64(0x0000010000010000), CONST64(0x0000000000010100), CONST64(0x0000010000010100),
479    CONST64(0x0001000000010000), CONST64(0x0001010000010000), CONST64(0x0001000000010100), CONST64(0x0001010000010100),
480    CONST64(0x0100000000000000), CONST64(0x0100010000000000), CONST64(0x0100000000000100), CONST64(0x0100010000000100),
481    CONST64(0x0101000000000000), CONST64(0x0101010000000000), CONST64(0x0101000000000100), CONST64(0x0101010000000100),
482    CONST64(0x0100000000010000), CONST64(0x0100010000010000), CONST64(0x0100000000010100), CONST64(0x0100010000010100),
483    CONST64(0x0101000000010000), CONST64(0x0101010000010000), CONST64(0x0101000000010100), CONST64(0x0101010000010100),
484    CONST64(0x0000000001000000), CONST64(0x0000010001000000), CONST64(0x0000000001000100), CONST64(0x0000010001000100),
485    CONST64(0x0001000001000000), CONST64(0x0001010001000000), CONST64(0x0001000001000100), CONST64(0x0001010001000100),
486    CONST64(0x0000000001010000), CONST64(0x0000010001010000), CONST64(0x0000000001010100), CONST64(0x0000010001010100),
487    CONST64(0x0001000001010000), CONST64(0x0001010001010000), CONST64(0x0001000001010100), CONST64(0x0001010001010100),
488    CONST64(0x0100000001000000), CONST64(0x0100010001000000), CONST64(0x0100000001000100), CONST64(0x0100010001000100),
489    CONST64(0x0101000001000000), CONST64(0x0101010001000000), CONST64(0x0101000001000100), CONST64(0x0101010001000100),
490    CONST64(0x0100000001010000), CONST64(0x0100010001010000), CONST64(0x0100000001010100), CONST64(0x0100010001010100),
491    CONST64(0x0101000001010000), CONST64(0x0101010001010000), CONST64(0x0101000001010100), CONST64(0x0101010001010100),
492    CONST64(0x0000000100000000), CONST64(0x0000010100000000), CONST64(0x0000000100000100), CONST64(0x0000010100000100),
493    CONST64(0x0001000100000000), CONST64(0x0001010100000000), CONST64(0x0001000100000100), CONST64(0x0001010100000100),
494    CONST64(0x0000000100010000), CONST64(0x0000010100010000), CONST64(0x0000000100010100), CONST64(0x0000010100010100),
495    CONST64(0x0001000100010000), CONST64(0x0001010100010000), CONST64(0x0001000100010100), CONST64(0x0001010100010100),
496    CONST64(0x0100000100000000), CONST64(0x0100010100000000), CONST64(0x0100000100000100), CONST64(0x0100010100000100),
497    CONST64(0x0101000100000000), CONST64(0x0101010100000000), CONST64(0x0101000100000100), CONST64(0x0101010100000100),
498    CONST64(0x0100000100010000), CONST64(0x0100010100010000), CONST64(0x0100000100010100), CONST64(0x0100010100010100),
499    CONST64(0x0101000100010000), CONST64(0x0101010100010000), CONST64(0x0101000100010100), CONST64(0x0101010100010100),
500    CONST64(0x0000000101000000), CONST64(0x0000010101000000), CONST64(0x0000000101000100), CONST64(0x0000010101000100),
501    CONST64(0x0001000101000000), CONST64(0x0001010101000000), CONST64(0x0001000101000100), CONST64(0x0001010101000100),
502    CONST64(0x0000000101010000), CONST64(0x0000010101010000), CONST64(0x0000000101010100), CONST64(0x0000010101010100),
503    CONST64(0x0001000101010000), CONST64(0x0001010101010000), CONST64(0x0001000101010100), CONST64(0x0001010101010100),
504    CONST64(0x0100000101000000), CONST64(0x0100010101000000), CONST64(0x0100000101000100), CONST64(0x0100010101000100),
505    CONST64(0x0101000101000000), CONST64(0x0101010101000000), CONST64(0x0101000101000100), CONST64(0x0101010101000100),
506    CONST64(0x0100000101010000), CONST64(0x0100010101010000), CONST64(0x0100000101010100), CONST64(0x0100010101010100),
507    CONST64(0x0101000101010000), CONST64(0x0101010101010000), CONST64(0x0101000101010100), CONST64(0x0101010101010100),
508    CONST64(0x0000000000000001), CONST64(0x0000010000000001), CONST64(0x0000000000000101), CONST64(0x0000010000000101),
509    CONST64(0x0001000000000001), CONST64(0x0001010000000001), CONST64(0x0001000000000101), CONST64(0x0001010000000101),
510    CONST64(0x0000000000010001), CONST64(0x0000010000010001), CONST64(0x0000000000010101), CONST64(0x0000010000010101),
511    CONST64(0x0001000000010001), CONST64(0x0001010000010001), CONST64(0x0001000000010101), CONST64(0x0001010000010101),
512    CONST64(0x0100000000000001), CONST64(0x0100010000000001), CONST64(0x0100000000000101), CONST64(0x0100010000000101),
513    CONST64(0x0101000000000001), CONST64(0x0101010000000001), CONST64(0x0101000000000101), CONST64(0x0101010000000101),
514    CONST64(0x0100000000010001), CONST64(0x0100010000010001), CONST64(0x0100000000010101), CONST64(0x0100010000010101),
515    CONST64(0x0101000000010001), CONST64(0x0101010000010001), CONST64(0x0101000000010101), CONST64(0x0101010000010101),
516    CONST64(0x0000000001000001), CONST64(0x0000010001000001), CONST64(0x0000000001000101), CONST64(0x0000010001000101),
517    CONST64(0x0001000001000001), CONST64(0x0001010001000001), CONST64(0x0001000001000101), CONST64(0x0001010001000101),
518    CONST64(0x0000000001010001), CONST64(0x0000010001010001), CONST64(0x0000000001010101), CONST64(0x0000010001010101),
519    CONST64(0x0001000001010001), CONST64(0x0001010001010001), CONST64(0x0001000001010101), CONST64(0x0001010001010101),
520    CONST64(0x0100000001000001), CONST64(0x0100010001000001), CONST64(0x0100000001000101), CONST64(0x0100010001000101),
521    CONST64(0x0101000001000001), CONST64(0x0101010001000001), CONST64(0x0101000001000101), CONST64(0x0101010001000101),
522    CONST64(0x0100000001010001), CONST64(0x0100010001010001), CONST64(0x0100000001010101), CONST64(0x0100010001010101),
523    CONST64(0x0101000001010001), CONST64(0x0101010001010001), CONST64(0x0101000001010101), CONST64(0x0101010001010101),
524    CONST64(0x0000000100000001), CONST64(0x0000010100000001), CONST64(0x0000000100000101), CONST64(0x0000010100000101),
525    CONST64(0x0001000100000001), CONST64(0x0001010100000001), CONST64(0x0001000100000101), CONST64(0x0001010100000101),
526    CONST64(0x0000000100010001), CONST64(0x0000010100010001), CONST64(0x0000000100010101), CONST64(0x0000010100010101),
527    CONST64(0x0001000100010001), CONST64(0x0001010100010001), CONST64(0x0001000100010101), CONST64(0x0001010100010101),
528    CONST64(0x0100000100000001), CONST64(0x0100010100000001), CONST64(0x0100000100000101), CONST64(0x0100010100000101),
529    CONST64(0x0101000100000001), CONST64(0x0101010100000001), CONST64(0x0101000100000101), CONST64(0x0101010100000101),
530    CONST64(0x0100000100010001), CONST64(0x0100010100010001), CONST64(0x0100000100010101), CONST64(0x0100010100010101),
531    CONST64(0x0101000100010001), CONST64(0x0101010100010001), CONST64(0x0101000100010101), CONST64(0x0101010100010101),
532    CONST64(0x0000000101000001), CONST64(0x0000010101000001), CONST64(0x0000000101000101), CONST64(0x0000010101000101),
533    CONST64(0x0001000101000001), CONST64(0x0001010101000001), CONST64(0x0001000101000101), CONST64(0x0001010101000101),
534    CONST64(0x0000000101010001), CONST64(0x0000010101010001), CONST64(0x0000000101010101), CONST64(0x0000010101010101),
535    CONST64(0x0001000101010001), CONST64(0x0001010101010001), CONST64(0x0001000101010101), CONST64(0x0001010101010101),
536    CONST64(0x0100000101000001), CONST64(0x0100010101000001), CONST64(0x0100000101000101), CONST64(0x0100010101000101),
537    CONST64(0x0101000101000001), CONST64(0x0101010101000001), CONST64(0x0101000101000101), CONST64(0x0101010101000101),
538    CONST64(0x0100000101010001), CONST64(0x0100010101010001), CONST64(0x0100000101010101), CONST64(0x0100010101010101),
539    CONST64(0x0101000101010001), CONST64(0x0101010101010001), CONST64(0x0101000101010101), CONST64(0x0101010101010101)
540    },
541  { CONST64(0x0000000000000000), CONST64(0x0000008000000000), CONST64(0x0000000000000080), CONST64(0x0000008000000080),
542    CONST64(0x0000800000000000), CONST64(0x0000808000000000), CONST64(0x0000800000000080), CONST64(0x0000808000000080),
543    CONST64(0x0000000000008000), CONST64(0x0000008000008000), CONST64(0x0000000000008080), CONST64(0x0000008000008080),
544    CONST64(0x0000800000008000), CONST64(0x0000808000008000), CONST64(0x0000800000008080), CONST64(0x0000808000008080),
545    CONST64(0x0080000000000000), CONST64(0x0080008000000000), CONST64(0x0080000000000080), CONST64(0x0080008000000080),
546    CONST64(0x0080800000000000), CONST64(0x0080808000000000), CONST64(0x0080800000000080), CONST64(0x0080808000000080),
547    CONST64(0x0080000000008000), CONST64(0x0080008000008000), CONST64(0x0080000000008080), CONST64(0x0080008000008080),
548    CONST64(0x0080800000008000), CONST64(0x0080808000008000), CONST64(0x0080800000008080), CONST64(0x0080808000008080),
549    CONST64(0x0000000000800000), CONST64(0x0000008000800000), CONST64(0x0000000000800080), CONST64(0x0000008000800080),
550    CONST64(0x0000800000800000), CONST64(0x0000808000800000), CONST64(0x0000800000800080), CONST64(0x0000808000800080),
551    CONST64(0x0000000000808000), CONST64(0x0000008000808000), CONST64(0x0000000000808080), CONST64(0x0000008000808080),
552    CONST64(0x0000800000808000), CONST64(0x0000808000808000), CONST64(0x0000800000808080), CONST64(0x0000808000808080),
553    CONST64(0x0080000000800000), CONST64(0x0080008000800000), CONST64(0x0080000000800080), CONST64(0x0080008000800080),
554    CONST64(0x0080800000800000), CONST64(0x0080808000800000), CONST64(0x0080800000800080), CONST64(0x0080808000800080),
555    CONST64(0x0080000000808000), CONST64(0x0080008000808000), CONST64(0x0080000000808080), CONST64(0x0080008000808080),
556    CONST64(0x0080800000808000), CONST64(0x0080808000808000), CONST64(0x0080800000808080), CONST64(0x0080808000808080),
557    CONST64(0x8000000000000000), CONST64(0x8000008000000000), CONST64(0x8000000000000080), CONST64(0x8000008000000080),
558    CONST64(0x8000800000000000), CONST64(0x8000808000000000), CONST64(0x8000800000000080), CONST64(0x8000808000000080),
559    CONST64(0x8000000000008000), CONST64(0x8000008000008000), CONST64(0x8000000000008080), CONST64(0x8000008000008080),
560    CONST64(0x8000800000008000), CONST64(0x8000808000008000), CONST64(0x8000800000008080), CONST64(0x8000808000008080),
561    CONST64(0x8080000000000000), CONST64(0x8080008000000000), CONST64(0x8080000000000080), CONST64(0x8080008000000080),
562    CONST64(0x8080800000000000), CONST64(0x8080808000000000), CONST64(0x8080800000000080), CONST64(0x8080808000000080),
563    CONST64(0x8080000000008000), CONST64(0x8080008000008000), CONST64(0x8080000000008080), CONST64(0x8080008000008080),
564    CONST64(0x8080800000008000), CONST64(0x8080808000008000), CONST64(0x8080800000008080), CONST64(0x8080808000008080),
565    CONST64(0x8000000000800000), CONST64(0x8000008000800000), CONST64(0x8000000000800080), CONST64(0x8000008000800080),
566    CONST64(0x8000800000800000), CONST64(0x8000808000800000), CONST64(0x8000800000800080), CONST64(0x8000808000800080),
567    CONST64(0x8000000000808000), CONST64(0x8000008000808000), CONST64(0x8000000000808080), CONST64(0x8000008000808080),
568    CONST64(0x8000800000808000), CONST64(0x8000808000808000), CONST64(0x8000800000808080), CONST64(0x8000808000808080),
569    CONST64(0x8080000000800000), CONST64(0x8080008000800000), CONST64(0x8080000000800080), CONST64(0x8080008000800080),
570    CONST64(0x8080800000800000), CONST64(0x8080808000800000), CONST64(0x8080800000800080), CONST64(0x8080808000800080),
571    CONST64(0x8080000000808000), CONST64(0x8080008000808000), CONST64(0x8080000000808080), CONST64(0x8080008000808080),
572    CONST64(0x8080800000808000), CONST64(0x8080808000808000), CONST64(0x8080800000808080), CONST64(0x8080808000808080),
573    CONST64(0x0000000080000000), CONST64(0x0000008080000000), CONST64(0x0000000080000080), CONST64(0x0000008080000080),
574    CONST64(0x0000800080000000), CONST64(0x0000808080000000), CONST64(0x0000800080000080), CONST64(0x0000808080000080),
575    CONST64(0x0000000080008000), CONST64(0x0000008080008000), CONST64(0x0000000080008080), CONST64(0x0000008080008080),
576    CONST64(0x0000800080008000), CONST64(0x0000808080008000), CONST64(0x0000800080008080), CONST64(0x0000808080008080),
577    CONST64(0x0080000080000000), CONST64(0x0080008080000000), CONST64(0x0080000080000080), CONST64(0x0080008080000080),
578    CONST64(0x0080800080000000), CONST64(0x0080808080000000), CONST64(0x0080800080000080), CONST64(0x0080808080000080),
579    CONST64(0x0080000080008000), CONST64(0x0080008080008000), CONST64(0x0080000080008080), CONST64(0x0080008080008080),
580    CONST64(0x0080800080008000), CONST64(0x0080808080008000), CONST64(0x0080800080008080), CONST64(0x0080808080008080),
581    CONST64(0x0000000080800000), CONST64(0x0000008080800000), CONST64(0x0000000080800080), CONST64(0x0000008080800080),
582    CONST64(0x0000800080800000), CONST64(0x0000808080800000), CONST64(0x0000800080800080), CONST64(0x0000808080800080),
583    CONST64(0x0000000080808000), CONST64(0x0000008080808000), CONST64(0x0000000080808080), CONST64(0x0000008080808080),
584    CONST64(0x0000800080808000), CONST64(0x0000808080808000), CONST64(0x0000800080808080), CONST64(0x0000808080808080),
585    CONST64(0x0080000080800000), CONST64(0x0080008080800000), CONST64(0x0080000080800080), CONST64(0x0080008080800080),
586    CONST64(0x0080800080800000), CONST64(0x0080808080800000), CONST64(0x0080800080800080), CONST64(0x0080808080800080),
587    CONST64(0x0080000080808000), CONST64(0x0080008080808000), CONST64(0x0080000080808080), CONST64(0x0080008080808080),
588    CONST64(0x0080800080808000), CONST64(0x0080808080808000), CONST64(0x0080800080808080), CONST64(0x0080808080808080),
589    CONST64(0x8000000080000000), CONST64(0x8000008080000000), CONST64(0x8000000080000080), CONST64(0x8000008080000080),
590    CONST64(0x8000800080000000), CONST64(0x8000808080000000), CONST64(0x8000800080000080), CONST64(0x8000808080000080),
591    CONST64(0x8000000080008000), CONST64(0x8000008080008000), CONST64(0x8000000080008080), CONST64(0x8000008080008080),
592    CONST64(0x8000800080008000), CONST64(0x8000808080008000), CONST64(0x8000800080008080), CONST64(0x8000808080008080),
593    CONST64(0x8080000080000000), CONST64(0x8080008080000000), CONST64(0x8080000080000080), CONST64(0x8080008080000080),
594    CONST64(0x8080800080000000), CONST64(0x8080808080000000), CONST64(0x8080800080000080), CONST64(0x8080808080000080),
595    CONST64(0x8080000080008000), CONST64(0x8080008080008000), CONST64(0x8080000080008080), CONST64(0x8080008080008080),
596    CONST64(0x8080800080008000), CONST64(0x8080808080008000), CONST64(0x8080800080008080), CONST64(0x8080808080008080),
597    CONST64(0x8000000080800000), CONST64(0x8000008080800000), CONST64(0x8000000080800080), CONST64(0x8000008080800080),
598    CONST64(0x8000800080800000), CONST64(0x8000808080800000), CONST64(0x8000800080800080), CONST64(0x8000808080800080),
599    CONST64(0x8000000080808000), CONST64(0x8000008080808000), CONST64(0x8000000080808080), CONST64(0x8000008080808080),
600    CONST64(0x8000800080808000), CONST64(0x8000808080808000), CONST64(0x8000800080808080), CONST64(0x8000808080808080),
601    CONST64(0x8080000080800000), CONST64(0x8080008080800000), CONST64(0x8080000080800080), CONST64(0x8080008080800080),
602    CONST64(0x8080800080800000), CONST64(0x8080808080800000), CONST64(0x8080800080800080), CONST64(0x8080808080800080),
603    CONST64(0x8080000080808000), CONST64(0x8080008080808000), CONST64(0x8080000080808080), CONST64(0x8080008080808080),
604    CONST64(0x8080800080808000), CONST64(0x8080808080808000), CONST64(0x8080800080808080), CONST64(0x8080808080808080)
605    },
606  { CONST64(0x0000000000000000), CONST64(0x0000004000000000), CONST64(0x0000000000000040), CONST64(0x0000004000000040),
607    CONST64(0x0000400000000000), CONST64(0x0000404000000000), CONST64(0x0000400000000040), CONST64(0x0000404000000040),
608    CONST64(0x0000000000004000), CONST64(0x0000004000004000), CONST64(0x0000000000004040), CONST64(0x0000004000004040),
609    CONST64(0x0000400000004000), CONST64(0x0000404000004000), CONST64(0x0000400000004040), CONST64(0x0000404000004040),
610    CONST64(0x0040000000000000), CONST64(0x0040004000000000), CONST64(0x0040000000000040), CONST64(0x0040004000000040),
611    CONST64(0x0040400000000000), CONST64(0x0040404000000000), CONST64(0x0040400000000040), CONST64(0x0040404000000040),
612    CONST64(0x0040000000004000), CONST64(0x0040004000004000), CONST64(0x0040000000004040), CONST64(0x0040004000004040),
613    CONST64(0x0040400000004000), CONST64(0x0040404000004000), CONST64(0x0040400000004040), CONST64(0x0040404000004040),
614    CONST64(0x0000000000400000), CONST64(0x0000004000400000), CONST64(0x0000000000400040), CONST64(0x0000004000400040),
615    CONST64(0x0000400000400000), CONST64(0x0000404000400000), CONST64(0x0000400000400040), CONST64(0x0000404000400040),
616    CONST64(0x0000000000404000), CONST64(0x0000004000404000), CONST64(0x0000000000404040), CONST64(0x0000004000404040),
617    CONST64(0x0000400000404000), CONST64(0x0000404000404000), CONST64(0x0000400000404040), CONST64(0x0000404000404040),
618    CONST64(0x0040000000400000), CONST64(0x0040004000400000), CONST64(0x0040000000400040), CONST64(0x0040004000400040),
619    CONST64(0x0040400000400000), CONST64(0x0040404000400000), CONST64(0x0040400000400040), CONST64(0x0040404000400040),
620    CONST64(0x0040000000404000), CONST64(0x0040004000404000), CONST64(0x0040000000404040), CONST64(0x0040004000404040),
621    CONST64(0x0040400000404000), CONST64(0x0040404000404000), CONST64(0x0040400000404040), CONST64(0x0040404000404040),
622    CONST64(0x4000000000000000), CONST64(0x4000004000000000), CONST64(0x4000000000000040), CONST64(0x4000004000000040),
623    CONST64(0x4000400000000000), CONST64(0x4000404000000000), CONST64(0x4000400000000040), CONST64(0x4000404000000040),
624    CONST64(0x4000000000004000), CONST64(0x4000004000004000), CONST64(0x4000000000004040), CONST64(0x4000004000004040),
625    CONST64(0x4000400000004000), CONST64(0x4000404000004000), CONST64(0x4000400000004040), CONST64(0x4000404000004040),
626    CONST64(0x4040000000000000), CONST64(0x4040004000000000), CONST64(0x4040000000000040), CONST64(0x4040004000000040),
627    CONST64(0x4040400000000000), CONST64(0x4040404000000000), CONST64(0x4040400000000040), CONST64(0x4040404000000040),
628    CONST64(0x4040000000004000), CONST64(0x4040004000004000), CONST64(0x4040000000004040), CONST64(0x4040004000004040),
629    CONST64(0x4040400000004000), CONST64(0x4040404000004000), CONST64(0x4040400000004040), CONST64(0x4040404000004040),
630    CONST64(0x4000000000400000), CONST64(0x4000004000400000), CONST64(0x4000000000400040), CONST64(0x4000004000400040),
631    CONST64(0x4000400000400000), CONST64(0x4000404000400000), CONST64(0x4000400000400040), CONST64(0x4000404000400040),
632    CONST64(0x4000000000404000), CONST64(0x4000004000404000), CONST64(0x4000000000404040), CONST64(0x4000004000404040),
633    CONST64(0x4000400000404000), CONST64(0x4000404000404000), CONST64(0x4000400000404040), CONST64(0x4000404000404040),
634    CONST64(0x4040000000400000), CONST64(0x4040004000400000), CONST64(0x4040000000400040), CONST64(0x4040004000400040),
635    CONST64(0x4040400000400000), CONST64(0x4040404000400000), CONST64(0x4040400000400040), CONST64(0x4040404000400040),
636    CONST64(0x4040000000404000), CONST64(0x4040004000404000), CONST64(0x4040000000404040), CONST64(0x4040004000404040),
637    CONST64(0x4040400000404000), CONST64(0x4040404000404000), CONST64(0x4040400000404040), CONST64(0x4040404000404040),
638    CONST64(0x0000000040000000), CONST64(0x0000004040000000), CONST64(0x0000000040000040), CONST64(0x0000004040000040),
639    CONST64(0x0000400040000000), CONST64(0x0000404040000000), CONST64(0x0000400040000040), CONST64(0x0000404040000040),
640    CONST64(0x0000000040004000), CONST64(0x0000004040004000), CONST64(0x0000000040004040), CONST64(0x0000004040004040),
641    CONST64(0x0000400040004000), CONST64(0x0000404040004000), CONST64(0x0000400040004040), CONST64(0x0000404040004040),
642    CONST64(0x0040000040000000), CONST64(0x0040004040000000), CONST64(0x0040000040000040), CONST64(0x0040004040000040),
643    CONST64(0x0040400040000000), CONST64(0x0040404040000000), CONST64(0x0040400040000040), CONST64(0x0040404040000040),
644    CONST64(0x0040000040004000), CONST64(0x0040004040004000), CONST64(0x0040000040004040), CONST64(0x0040004040004040),
645    CONST64(0x0040400040004000), CONST64(0x0040404040004000), CONST64(0x0040400040004040), CONST64(0x0040404040004040),
646    CONST64(0x0000000040400000), CONST64(0x0000004040400000), CONST64(0x0000000040400040), CONST64(0x0000004040400040),
647    CONST64(0x0000400040400000), CONST64(0x0000404040400000), CONST64(0x0000400040400040), CONST64(0x0000404040400040),
648    CONST64(0x0000000040404000), CONST64(0x0000004040404000), CONST64(0x0000000040404040), CONST64(0x0000004040404040),
649    CONST64(0x0000400040404000), CONST64(0x0000404040404000), CONST64(0x0000400040404040), CONST64(0x0000404040404040),
650    CONST64(0x0040000040400000), CONST64(0x0040004040400000), CONST64(0x0040000040400040), CONST64(0x0040004040400040),
651    CONST64(0x0040400040400000), CONST64(0x0040404040400000), CONST64(0x0040400040400040), CONST64(0x0040404040400040),
652    CONST64(0x0040000040404000), CONST64(0x0040004040404000), CONST64(0x0040000040404040), CONST64(0x0040004040404040),
653    CONST64(0x0040400040404000), CONST64(0x0040404040404000), CONST64(0x0040400040404040), CONST64(0x0040404040404040),
654    CONST64(0x4000000040000000), CONST64(0x4000004040000000), CONST64(0x4000000040000040), CONST64(0x4000004040000040),
655    CONST64(0x4000400040000000), CONST64(0x4000404040000000), CONST64(0x4000400040000040), CONST64(0x4000404040000040),
656    CONST64(0x4000000040004000), CONST64(0x4000004040004000), CONST64(0x4000000040004040), CONST64(0x4000004040004040),
657    CONST64(0x4000400040004000), CONST64(0x4000404040004000), CONST64(0x4000400040004040), CONST64(0x4000404040004040),
658    CONST64(0x4040000040000000), CONST64(0x4040004040000000), CONST64(0x4040000040000040), CONST64(0x4040004040000040),
659    CONST64(0x4040400040000000), CONST64(0x4040404040000000), CONST64(0x4040400040000040), CONST64(0x4040404040000040),
660    CONST64(0x4040000040004000), CONST64(0x4040004040004000), CONST64(0x4040000040004040), CONST64(0x4040004040004040),
661    CONST64(0x4040400040004000), CONST64(0x4040404040004000), CONST64(0x4040400040004040), CONST64(0x4040404040004040),
662    CONST64(0x4000000040400000), CONST64(0x4000004040400000), CONST64(0x4000000040400040), CONST64(0x4000004040400040),
663    CONST64(0x4000400040400000), CONST64(0x4000404040400000), CONST64(0x4000400040400040), CONST64(0x4000404040400040),
664    CONST64(0x4000000040404000), CONST64(0x4000004040404000), CONST64(0x4000000040404040), CONST64(0x4000004040404040),
665    CONST64(0x4000400040404000), CONST64(0x4000404040404000), CONST64(0x4000400040404040), CONST64(0x4000404040404040),
666    CONST64(0x4040000040400000), CONST64(0x4040004040400000), CONST64(0x4040000040400040), CONST64(0x4040004040400040),
667    CONST64(0x4040400040400000), CONST64(0x4040404040400000), CONST64(0x4040400040400040), CONST64(0x4040404040400040),
668    CONST64(0x4040000040404000), CONST64(0x4040004040404000), CONST64(0x4040000040404040), CONST64(0x4040004040404040),
669    CONST64(0x4040400040404000), CONST64(0x4040404040404000), CONST64(0x4040400040404040), CONST64(0x4040404040404040)
670    },
671  { CONST64(0x0000000000000000), CONST64(0x0000002000000000), CONST64(0x0000000000000020), CONST64(0x0000002000000020),
672    CONST64(0x0000200000000000), CONST64(0x0000202000000000), CONST64(0x0000200000000020), CONST64(0x0000202000000020),
673    CONST64(0x0000000000002000), CONST64(0x0000002000002000), CONST64(0x0000000000002020), CONST64(0x0000002000002020),
674    CONST64(0x0000200000002000), CONST64(0x0000202000002000), CONST64(0x0000200000002020), CONST64(0x0000202000002020),
675    CONST64(0x0020000000000000), CONST64(0x0020002000000000), CONST64(0x0020000000000020), CONST64(0x0020002000000020),
676    CONST64(0x0020200000000000), CONST64(0x0020202000000000), CONST64(0x0020200000000020), CONST64(0x0020202000000020),
677    CONST64(0x0020000000002000), CONST64(0x0020002000002000), CONST64(0x0020000000002020), CONST64(0x0020002000002020),
678    CONST64(0x0020200000002000), CONST64(0x0020202000002000), CONST64(0x0020200000002020), CONST64(0x0020202000002020),
679    CONST64(0x0000000000200000), CONST64(0x0000002000200000), CONST64(0x0000000000200020), CONST64(0x0000002000200020),
680    CONST64(0x0000200000200000), CONST64(0x0000202000200000), CONST64(0x0000200000200020), CONST64(0x0000202000200020),
681    CONST64(0x0000000000202000), CONST64(0x0000002000202000), CONST64(0x0000000000202020), CONST64(0x0000002000202020),
682    CONST64(0x0000200000202000), CONST64(0x0000202000202000), CONST64(0x0000200000202020), CONST64(0x0000202000202020),
683    CONST64(0x0020000000200000), CONST64(0x0020002000200000), CONST64(0x0020000000200020), CONST64(0x0020002000200020),
684    CONST64(0x0020200000200000), CONST64(0x0020202000200000), CONST64(0x0020200000200020), CONST64(0x0020202000200020),
685    CONST64(0x0020000000202000), CONST64(0x0020002000202000), CONST64(0x0020000000202020), CONST64(0x0020002000202020),
686    CONST64(0x0020200000202000), CONST64(0x0020202000202000), CONST64(0x0020200000202020), CONST64(0x0020202000202020),
687    CONST64(0x2000000000000000), CONST64(0x2000002000000000), CONST64(0x2000000000000020), CONST64(0x2000002000000020),
688    CONST64(0x2000200000000000), CONST64(0x2000202000000000), CONST64(0x2000200000000020), CONST64(0x2000202000000020),
689    CONST64(0x2000000000002000), CONST64(0x2000002000002000), CONST64(0x2000000000002020), CONST64(0x2000002000002020),
690    CONST64(0x2000200000002000), CONST64(0x2000202000002000), CONST64(0x2000200000002020), CONST64(0x2000202000002020),
691    CONST64(0x2020000000000000), CONST64(0x2020002000000000), CONST64(0x2020000000000020), CONST64(0x2020002000000020),
692    CONST64(0x2020200000000000), CONST64(0x2020202000000000), CONST64(0x2020200000000020), CONST64(0x2020202000000020),
693    CONST64(0x2020000000002000), CONST64(0x2020002000002000), CONST64(0x2020000000002020), CONST64(0x2020002000002020),
694    CONST64(0x2020200000002000), CONST64(0x2020202000002000), CONST64(0x2020200000002020), CONST64(0x2020202000002020),
695    CONST64(0x2000000000200000), CONST64(0x2000002000200000), CONST64(0x2000000000200020), CONST64(0x2000002000200020),
696    CONST64(0x2000200000200000), CONST64(0x2000202000200000), CONST64(0x2000200000200020), CONST64(0x2000202000200020),
697    CONST64(0x2000000000202000), CONST64(0x2000002000202000), CONST64(0x2000000000202020), CONST64(0x2000002000202020),
698    CONST64(0x2000200000202000), CONST64(0x2000202000202000), CONST64(0x2000200000202020), CONST64(0x2000202000202020),
699    CONST64(0x2020000000200000), CONST64(0x2020002000200000), CONST64(0x2020000000200020), CONST64(0x2020002000200020),
700    CONST64(0x2020200000200000), CONST64(0x2020202000200000), CONST64(0x2020200000200020), CONST64(0x2020202000200020),
701    CONST64(0x2020000000202000), CONST64(0x2020002000202000), CONST64(0x2020000000202020), CONST64(0x2020002000202020),
702    CONST64(0x2020200000202000), CONST64(0x2020202000202000), CONST64(0x2020200000202020), CONST64(0x2020202000202020),
703    CONST64(0x0000000020000000), CONST64(0x0000002020000000), CONST64(0x0000000020000020), CONST64(0x0000002020000020),
704    CONST64(0x0000200020000000), CONST64(0x0000202020000000), CONST64(0x0000200020000020), CONST64(0x0000202020000020),
705    CONST64(0x0000000020002000), CONST64(0x0000002020002000), CONST64(0x0000000020002020), CONST64(0x0000002020002020),
706    CONST64(0x0000200020002000), CONST64(0x0000202020002000), CONST64(0x0000200020002020), CONST64(0x0000202020002020),
707    CONST64(0x0020000020000000), CONST64(0x0020002020000000), CONST64(0x0020000020000020), CONST64(0x0020002020000020),
708    CONST64(0x0020200020000000), CONST64(0x0020202020000000), CONST64(0x0020200020000020), CONST64(0x0020202020000020),
709    CONST64(0x0020000020002000), CONST64(0x0020002020002000), CONST64(0x0020000020002020), CONST64(0x0020002020002020),
710    CONST64(0x0020200020002000), CONST64(0x0020202020002000), CONST64(0x0020200020002020), CONST64(0x0020202020002020),
711    CONST64(0x0000000020200000), CONST64(0x0000002020200000), CONST64(0x0000000020200020), CONST64(0x0000002020200020),
712    CONST64(0x0000200020200000), CONST64(0x0000202020200000), CONST64(0x0000200020200020), CONST64(0x0000202020200020),
713    CONST64(0x0000000020202000), CONST64(0x0000002020202000), CONST64(0x0000000020202020), CONST64(0x0000002020202020),
714    CONST64(0x0000200020202000), CONST64(0x0000202020202000), CONST64(0x0000200020202020), CONST64(0x0000202020202020),
715    CONST64(0x0020000020200000), CONST64(0x0020002020200000), CONST64(0x0020000020200020), CONST64(0x0020002020200020),
716    CONST64(0x0020200020200000), CONST64(0x0020202020200000), CONST64(0x0020200020200020), CONST64(0x0020202020200020),
717    CONST64(0x0020000020202000), CONST64(0x0020002020202000), CONST64(0x0020000020202020), CONST64(0x0020002020202020),
718    CONST64(0x0020200020202000), CONST64(0x0020202020202000), CONST64(0x0020200020202020), CONST64(0x0020202020202020),
719    CONST64(0x2000000020000000), CONST64(0x2000002020000000), CONST64(0x2000000020000020), CONST64(0x2000002020000020),
720    CONST64(0x2000200020000000), CONST64(0x2000202020000000), CONST64(0x2000200020000020), CONST64(0x2000202020000020),
721    CONST64(0x2000000020002000), CONST64(0x2000002020002000), CONST64(0x2000000020002020), CONST64(0x2000002020002020),
722    CONST64(0x2000200020002000), CONST64(0x2000202020002000), CONST64(0x2000200020002020), CONST64(0x2000202020002020),
723    CONST64(0x2020000020000000), CONST64(0x2020002020000000), CONST64(0x2020000020000020), CONST64(0x2020002020000020),
724    CONST64(0x2020200020000000), CONST64(0x2020202020000000), CONST64(0x2020200020000020), CONST64(0x2020202020000020),
725    CONST64(0x2020000020002000), CONST64(0x2020002020002000), CONST64(0x2020000020002020), CONST64(0x2020002020002020),
726    CONST64(0x2020200020002000), CONST64(0x2020202020002000), CONST64(0x2020200020002020), CONST64(0x2020202020002020),
727    CONST64(0x2000000020200000), CONST64(0x2000002020200000), CONST64(0x2000000020200020), CONST64(0x2000002020200020),
728    CONST64(0x2000200020200000), CONST64(0x2000202020200000), CONST64(0x2000200020200020), CONST64(0x2000202020200020),
729    CONST64(0x2000000020202000), CONST64(0x2000002020202000), CONST64(0x2000000020202020), CONST64(0x2000002020202020),
730    CONST64(0x2000200020202000), CONST64(0x2000202020202000), CONST64(0x2000200020202020), CONST64(0x2000202020202020),
731    CONST64(0x2020000020200000), CONST64(0x2020002020200000), CONST64(0x2020000020200020), CONST64(0x2020002020200020),
732    CONST64(0x2020200020200000), CONST64(0x2020202020200000), CONST64(0x2020200020200020), CONST64(0x2020202020200020),
733    CONST64(0x2020000020202000), CONST64(0x2020002020202000), CONST64(0x2020000020202020), CONST64(0x2020002020202020),
734    CONST64(0x2020200020202000), CONST64(0x2020202020202000), CONST64(0x2020200020202020), CONST64(0x2020202020202020)
735    }};
736  static const ulong64 des_fp[8][256] = {
737  { CONST64(0x0000000000000000), CONST64(0x0000008000000000), CONST64(0x0000000002000000), CONST64(0x0000008002000000),
738    CONST64(0x0000000000020000), CONST64(0x0000008000020000), CONST64(0x0000000002020000), CONST64(0x0000008002020000),
739    CONST64(0x0000000000000200), CONST64(0x0000008000000200), CONST64(0x0000000002000200), CONST64(0x0000008002000200),
740    CONST64(0x0000000000020200), CONST64(0x0000008000020200), CONST64(0x0000000002020200), CONST64(0x0000008002020200),
741    CONST64(0x0000000000000002), CONST64(0x0000008000000002), CONST64(0x0000000002000002), CONST64(0x0000008002000002),
742    CONST64(0x0000000000020002), CONST64(0x0000008000020002), CONST64(0x0000000002020002), CONST64(0x0000008002020002),
743    CONST64(0x0000000000000202), CONST64(0x0000008000000202), CONST64(0x0000000002000202), CONST64(0x0000008002000202),
744    CONST64(0x0000000000020202), CONST64(0x0000008000020202), CONST64(0x0000000002020202), CONST64(0x0000008002020202),
745    CONST64(0x0200000000000000), CONST64(0x0200008000000000), CONST64(0x0200000002000000), CONST64(0x0200008002000000),
746    CONST64(0x0200000000020000), CONST64(0x0200008000020000), CONST64(0x0200000002020000), CONST64(0x0200008002020000),
747    CONST64(0x0200000000000200), CONST64(0x0200008000000200), CONST64(0x0200000002000200), CONST64(0x0200008002000200),
748    CONST64(0x0200000000020200), CONST64(0x0200008000020200), CONST64(0x0200000002020200), CONST64(0x0200008002020200),
749    CONST64(0x0200000000000002), CONST64(0x0200008000000002), CONST64(0x0200000002000002), CONST64(0x0200008002000002),
750    CONST64(0x0200000000020002), CONST64(0x0200008000020002), CONST64(0x0200000002020002), CONST64(0x0200008002020002),
751    CONST64(0x0200000000000202), CONST64(0x0200008000000202), CONST64(0x0200000002000202), CONST64(0x0200008002000202),
752    CONST64(0x0200000000020202), CONST64(0x0200008000020202), CONST64(0x0200000002020202), CONST64(0x0200008002020202),
753    CONST64(0x0002000000000000), CONST64(0x0002008000000000), CONST64(0x0002000002000000), CONST64(0x0002008002000000),
754    CONST64(0x0002000000020000), CONST64(0x0002008000020000), CONST64(0x0002000002020000), CONST64(0x0002008002020000),
755    CONST64(0x0002000000000200), CONST64(0x0002008000000200), CONST64(0x0002000002000200), CONST64(0x0002008002000200),
756    CONST64(0x0002000000020200), CONST64(0x0002008000020200), CONST64(0x0002000002020200), CONST64(0x0002008002020200),
757    CONST64(0x0002000000000002), CONST64(0x0002008000000002), CONST64(0x0002000002000002), CONST64(0x0002008002000002),
758    CONST64(0x0002000000020002), CONST64(0x0002008000020002), CONST64(0x0002000002020002), CONST64(0x0002008002020002),
759    CONST64(0x0002000000000202), CONST64(0x0002008000000202), CONST64(0x0002000002000202), CONST64(0x0002008002000202),
760    CONST64(0x0002000000020202), CONST64(0x0002008000020202), CONST64(0x0002000002020202), CONST64(0x0002008002020202),
761    CONST64(0x0202000000000000), CONST64(0x0202008000000000), CONST64(0x0202000002000000), CONST64(0x0202008002000000),
762    CONST64(0x0202000000020000), CONST64(0x0202008000020000), CONST64(0x0202000002020000), CONST64(0x0202008002020000),
763    CONST64(0x0202000000000200), CONST64(0x0202008000000200), CONST64(0x0202000002000200), CONST64(0x0202008002000200),
764    CONST64(0x0202000000020200), CONST64(0x0202008000020200), CONST64(0x0202000002020200), CONST64(0x0202008002020200),
765    CONST64(0x0202000000000002), CONST64(0x0202008000000002), CONST64(0x0202000002000002), CONST64(0x0202008002000002),
766    CONST64(0x0202000000020002), CONST64(0x0202008000020002), CONST64(0x0202000002020002), CONST64(0x0202008002020002),
767    CONST64(0x0202000000000202), CONST64(0x0202008000000202), CONST64(0x0202000002000202), CONST64(0x0202008002000202),
768    CONST64(0x0202000000020202), CONST64(0x0202008000020202), CONST64(0x0202000002020202), CONST64(0x0202008002020202),
769    CONST64(0x0000020000000000), CONST64(0x0000028000000000), CONST64(0x0000020002000000), CONST64(0x0000028002000000),
770    CONST64(0x0000020000020000), CONST64(0x0000028000020000), CONST64(0x0000020002020000), CONST64(0x0000028002020000),
771    CONST64(0x0000020000000200), CONST64(0x0000028000000200), CONST64(0x0000020002000200), CONST64(0x0000028002000200),
772    CONST64(0x0000020000020200), CONST64(0x0000028000020200), CONST64(0x0000020002020200), CONST64(0x0000028002020200),
773    CONST64(0x0000020000000002), CONST64(0x0000028000000002), CONST64(0x0000020002000002), CONST64(0x0000028002000002),
774    CONST64(0x0000020000020002), CONST64(0x0000028000020002), CONST64(0x0000020002020002), CONST64(0x0000028002020002),
775    CONST64(0x0000020000000202), CONST64(0x0000028000000202), CONST64(0x0000020002000202), CONST64(0x0000028002000202),
776    CONST64(0x0000020000020202), CONST64(0x0000028000020202), CONST64(0x0000020002020202), CONST64(0x0000028002020202),
777    CONST64(0x0200020000000000), CONST64(0x0200028000000000), CONST64(0x0200020002000000), CONST64(0x0200028002000000),
778    CONST64(0x0200020000020000), CONST64(0x0200028000020000), CONST64(0x0200020002020000), CONST64(0x0200028002020000),
779    CONST64(0x0200020000000200), CONST64(0x0200028000000200), CONST64(0x0200020002000200), CONST64(0x0200028002000200),
780    CONST64(0x0200020000020200), CONST64(0x0200028000020200), CONST64(0x0200020002020200), CONST64(0x0200028002020200),
781    CONST64(0x0200020000000002), CONST64(0x0200028000000002), CONST64(0x0200020002000002), CONST64(0x0200028002000002),
782    CONST64(0x0200020000020002), CONST64(0x0200028000020002), CONST64(0x0200020002020002), CONST64(0x0200028002020002),
783    CONST64(0x0200020000000202), CONST64(0x0200028000000202), CONST64(0x0200020002000202), CONST64(0x0200028002000202),
784    CONST64(0x0200020000020202), CONST64(0x0200028000020202), CONST64(0x0200020002020202), CONST64(0x0200028002020202),
785    CONST64(0x0002020000000000), CONST64(0x0002028000000000), CONST64(0x0002020002000000), CONST64(0x0002028002000000),
786    CONST64(0x0002020000020000), CONST64(0x0002028000020000), CONST64(0x0002020002020000), CONST64(0x0002028002020000),
787    CONST64(0x0002020000000200), CONST64(0x0002028000000200), CONST64(0x0002020002000200), CONST64(0x0002028002000200),
788    CONST64(0x0002020000020200), CONST64(0x0002028000020200), CONST64(0x0002020002020200), CONST64(0x0002028002020200),
789    CONST64(0x0002020000000002), CONST64(0x0002028000000002), CONST64(0x0002020002000002), CONST64(0x0002028002000002),
790    CONST64(0x0002020000020002), CONST64(0x0002028000020002), CONST64(0x0002020002020002), CONST64(0x0002028002020002),
791    CONST64(0x0002020000000202), CONST64(0x0002028000000202), CONST64(0x0002020002000202), CONST64(0x0002028002000202),
792    CONST64(0x0002020000020202), CONST64(0x0002028000020202), CONST64(0x0002020002020202), CONST64(0x0002028002020202),
793    CONST64(0x0202020000000000), CONST64(0x0202028000000000), CONST64(0x0202020002000000), CONST64(0x0202028002000000),
794    CONST64(0x0202020000020000), CONST64(0x0202028000020000), CONST64(0x0202020002020000), CONST64(0x0202028002020000),
795    CONST64(0x0202020000000200), CONST64(0x0202028000000200), CONST64(0x0202020002000200), CONST64(0x0202028002000200),
796    CONST64(0x0202020000020200), CONST64(0x0202028000020200), CONST64(0x0202020002020200), CONST64(0x0202028002020200),
797    CONST64(0x0202020000000002), CONST64(0x0202028000000002), CONST64(0x0202020002000002), CONST64(0x0202028002000002),
798    CONST64(0x0202020000020002), CONST64(0x0202028000020002), CONST64(0x0202020002020002), CONST64(0x0202028002020002),
799    CONST64(0x0202020000000202), CONST64(0x0202028000000202), CONST64(0x0202020002000202), CONST64(0x0202028002000202),
800    CONST64(0x0202020000020202), CONST64(0x0202028000020202), CONST64(0x0202020002020202), CONST64(0x0202028002020202)
801    },
802  { CONST64(0x0000000000000000), CONST64(0x0000000200000000), CONST64(0x0000000008000000), CONST64(0x0000000208000000),
803    CONST64(0x0000000000080000), CONST64(0x0000000200080000), CONST64(0x0000000008080000), CONST64(0x0000000208080000),
804    CONST64(0x0000000000000800), CONST64(0x0000000200000800), CONST64(0x0000000008000800), CONST64(0x0000000208000800),
805    CONST64(0x0000000000080800), CONST64(0x0000000200080800), CONST64(0x0000000008080800), CONST64(0x0000000208080800),
806    CONST64(0x0000000000000008), CONST64(0x0000000200000008), CONST64(0x0000000008000008), CONST64(0x0000000208000008),
807    CONST64(0x0000000000080008), CONST64(0x0000000200080008), CONST64(0x0000000008080008), CONST64(0x0000000208080008),
808    CONST64(0x0000000000000808), CONST64(0x0000000200000808), CONST64(0x0000000008000808), CONST64(0x0000000208000808),
809    CONST64(0x0000000000080808), CONST64(0x0000000200080808), CONST64(0x0000000008080808), CONST64(0x0000000208080808),
810    CONST64(0x0800000000000000), CONST64(0x0800000200000000), CONST64(0x0800000008000000), CONST64(0x0800000208000000),
811    CONST64(0x0800000000080000), CONST64(0x0800000200080000), CONST64(0x0800000008080000), CONST64(0x0800000208080000),
812    CONST64(0x0800000000000800), CONST64(0x0800000200000800), CONST64(0x0800000008000800), CONST64(0x0800000208000800),
813    CONST64(0x0800000000080800), CONST64(0x0800000200080800), CONST64(0x0800000008080800), CONST64(0x0800000208080800),
814    CONST64(0x0800000000000008), CONST64(0x0800000200000008), CONST64(0x0800000008000008), CONST64(0x0800000208000008),
815    CONST64(0x0800000000080008), CONST64(0x0800000200080008), CONST64(0x0800000008080008), CONST64(0x0800000208080008),
816    CONST64(0x0800000000000808), CONST64(0x0800000200000808), CONST64(0x0800000008000808), CONST64(0x0800000208000808),
817    CONST64(0x0800000000080808), CONST64(0x0800000200080808), CONST64(0x0800000008080808), CONST64(0x0800000208080808),
818    CONST64(0x0008000000000000), CONST64(0x0008000200000000), CONST64(0x0008000008000000), CONST64(0x0008000208000000),
819    CONST64(0x0008000000080000), CONST64(0x0008000200080000), CONST64(0x0008000008080000), CONST64(0x0008000208080000),
820    CONST64(0x0008000000000800), CONST64(0x0008000200000800), CONST64(0x0008000008000800), CONST64(0x0008000208000800),
821    CONST64(0x0008000000080800), CONST64(0x0008000200080800), CONST64(0x0008000008080800), CONST64(0x0008000208080800),
822    CONST64(0x0008000000000008), CONST64(0x0008000200000008), CONST64(0x0008000008000008), CONST64(0x0008000208000008),
823    CONST64(0x0008000000080008), CONST64(0x0008000200080008), CONST64(0x0008000008080008), CONST64(0x0008000208080008),
824    CONST64(0x0008000000000808), CONST64(0x0008000200000808), CONST64(0x0008000008000808), CONST64(0x0008000208000808),
825    CONST64(0x0008000000080808), CONST64(0x0008000200080808), CONST64(0x0008000008080808), CONST64(0x0008000208080808),
826    CONST64(0x0808000000000000), CONST64(0x0808000200000000), CONST64(0x0808000008000000), CONST64(0x0808000208000000),
827    CONST64(0x0808000000080000), CONST64(0x0808000200080000), CONST64(0x0808000008080000), CONST64(0x0808000208080000),
828    CONST64(0x0808000000000800), CONST64(0x0808000200000800), CONST64(0x0808000008000800), CONST64(0x0808000208000800),
829    CONST64(0x0808000000080800), CONST64(0x0808000200080800), CONST64(0x0808000008080800), CONST64(0x0808000208080800),
830    CONST64(0x0808000000000008), CONST64(0x0808000200000008), CONST64(0x0808000008000008), CONST64(0x0808000208000008),
831    CONST64(0x0808000000080008), CONST64(0x0808000200080008), CONST64(0x0808000008080008), CONST64(0x0808000208080008),
832    CONST64(0x0808000000000808), CONST64(0x0808000200000808), CONST64(0x0808000008000808), CONST64(0x0808000208000808),
833    CONST64(0x0808000000080808), CONST64(0x0808000200080808), CONST64(0x0808000008080808), CONST64(0x0808000208080808),
834    CONST64(0x0000080000000000), CONST64(0x0000080200000000), CONST64(0x0000080008000000), CONST64(0x0000080208000000),
835    CONST64(0x0000080000080000), CONST64(0x0000080200080000), CONST64(0x0000080008080000), CONST64(0x0000080208080000),
836    CONST64(0x0000080000000800), CONST64(0x0000080200000800), CONST64(0x0000080008000800), CONST64(0x0000080208000800),
837    CONST64(0x0000080000080800), CONST64(0x0000080200080800), CONST64(0x0000080008080800), CONST64(0x0000080208080800),
838    CONST64(0x0000080000000008), CONST64(0x0000080200000008), CONST64(0x0000080008000008), CONST64(0x0000080208000008),
839    CONST64(0x0000080000080008), CONST64(0x0000080200080008), CONST64(0x0000080008080008), CONST64(0x0000080208080008),
840    CONST64(0x0000080000000808), CONST64(0x0000080200000808), CONST64(0x0000080008000808), CONST64(0x0000080208000808),
841    CONST64(0x0000080000080808), CONST64(0x0000080200080808), CONST64(0x0000080008080808), CONST64(0x0000080208080808),
842    CONST64(0x0800080000000000), CONST64(0x0800080200000000), CONST64(0x0800080008000000), CONST64(0x0800080208000000),
843    CONST64(0x0800080000080000), CONST64(0x0800080200080000), CONST64(0x0800080008080000), CONST64(0x0800080208080000),
844    CONST64(0x0800080000000800), CONST64(0x0800080200000800), CONST64(0x0800080008000800), CONST64(0x0800080208000800),
845    CONST64(0x0800080000080800), CONST64(0x0800080200080800), CONST64(0x0800080008080800), CONST64(0x0800080208080800),
846    CONST64(0x0800080000000008), CONST64(0x0800080200000008), CONST64(0x0800080008000008), CONST64(0x0800080208000008),
847    CONST64(0x0800080000080008), CONST64(0x0800080200080008), CONST64(0x0800080008080008), CONST64(0x0800080208080008),
848    CONST64(0x0800080000000808), CONST64(0x0800080200000808), CONST64(0x0800080008000808), CONST64(0x0800080208000808),
849    CONST64(0x0800080000080808), CONST64(0x0800080200080808), CONST64(0x0800080008080808), CONST64(0x0800080208080808),
850    CONST64(0x0008080000000000), CONST64(0x0008080200000000), CONST64(0x0008080008000000), CONST64(0x0008080208000000),
851    CONST64(0x0008080000080000), CONST64(0x0008080200080000), CONST64(0x0008080008080000), CONST64(0x0008080208080000),
852    CONST64(0x0008080000000800), CONST64(0x0008080200000800), CONST64(0x0008080008000800), CONST64(0x0008080208000800),
853    CONST64(0x0008080000080800), CONST64(0x0008080200080800), CONST64(0x0008080008080800), CONST64(0x0008080208080800),
854    CONST64(0x0008080000000008), CONST64(0x0008080200000008), CONST64(0x0008080008000008), CONST64(0x0008080208000008),
855    CONST64(0x0008080000080008), CONST64(0x0008080200080008), CONST64(0x0008080008080008), CONST64(0x0008080208080008),
856    CONST64(0x0008080000000808), CONST64(0x0008080200000808), CONST64(0x0008080008000808), CONST64(0x0008080208000808),
857    CONST64(0x0008080000080808), CONST64(0x0008080200080808), CONST64(0x0008080008080808), CONST64(0x0008080208080808),
858    CONST64(0x0808080000000000), CONST64(0x0808080200000000), CONST64(0x0808080008000000), CONST64(0x0808080208000000),
859    CONST64(0x0808080000080000), CONST64(0x0808080200080000), CONST64(0x0808080008080000), CONST64(0x0808080208080000),
860    CONST64(0x0808080000000800), CONST64(0x0808080200000800), CONST64(0x0808080008000800), CONST64(0x0808080208000800),
861    CONST64(0x0808080000080800), CONST64(0x0808080200080800), CONST64(0x0808080008080800), CONST64(0x0808080208080800),
862    CONST64(0x0808080000000008), CONST64(0x0808080200000008), CONST64(0x0808080008000008), CONST64(0x0808080208000008),
863    CONST64(0x0808080000080008), CONST64(0x0808080200080008), CONST64(0x0808080008080008), CONST64(0x0808080208080008),
864    CONST64(0x0808080000000808), CONST64(0x0808080200000808), CONST64(0x0808080008000808), CONST64(0x0808080208000808),
865    CONST64(0x0808080000080808), CONST64(0x0808080200080808), CONST64(0x0808080008080808), CONST64(0x0808080208080808)
866    },
867  { CONST64(0x0000000000000000), CONST64(0x0000000800000000), CONST64(0x0000000020000000), CONST64(0x0000000820000000),
868    CONST64(0x0000000000200000), CONST64(0x0000000800200000), CONST64(0x0000000020200000), CONST64(0x0000000820200000),
869    CONST64(0x0000000000002000), CONST64(0x0000000800002000), CONST64(0x0000000020002000), CONST64(0x0000000820002000),
870    CONST64(0x0000000000202000), CONST64(0x0000000800202000), CONST64(0x0000000020202000), CONST64(0x0000000820202000),
871    CONST64(0x0000000000000020), CONST64(0x0000000800000020), CONST64(0x0000000020000020), CONST64(0x0000000820000020),
872    CONST64(0x0000000000200020), CONST64(0x0000000800200020), CONST64(0x0000000020200020), CONST64(0x0000000820200020),
873    CONST64(0x0000000000002020), CONST64(0x0000000800002020), CONST64(0x0000000020002020), CONST64(0x0000000820002020),
874    CONST64(0x0000000000202020), CONST64(0x0000000800202020), CONST64(0x0000000020202020), CONST64(0x0000000820202020),
875    CONST64(0x2000000000000000), CONST64(0x2000000800000000), CONST64(0x2000000020000000), CONST64(0x2000000820000000),
876    CONST64(0x2000000000200000), CONST64(0x2000000800200000), CONST64(0x2000000020200000), CONST64(0x2000000820200000),
877    CONST64(0x2000000000002000), CONST64(0x2000000800002000), CONST64(0x2000000020002000), CONST64(0x2000000820002000),
878    CONST64(0x2000000000202000), CONST64(0x2000000800202000), CONST64(0x2000000020202000), CONST64(0x2000000820202000),
879    CONST64(0x2000000000000020), CONST64(0x2000000800000020), CONST64(0x2000000020000020), CONST64(0x2000000820000020),
880    CONST64(0x2000000000200020), CONST64(0x2000000800200020), CONST64(0x2000000020200020), CONST64(0x2000000820200020),
881    CONST64(0x2000000000002020), CONST64(0x2000000800002020), CONST64(0x2000000020002020), CONST64(0x2000000820002020),
882    CONST64(0x2000000000202020), CONST64(0x2000000800202020), CONST64(0x2000000020202020), CONST64(0x2000000820202020),
883    CONST64(0x0020000000000000), CONST64(0x0020000800000000), CONST64(0x0020000020000000), CONST64(0x0020000820000000),
884    CONST64(0x0020000000200000), CONST64(0x0020000800200000), CONST64(0x0020000020200000), CONST64(0x0020000820200000),
885    CONST64(0x0020000000002000), CONST64(0x0020000800002000), CONST64(0x0020000020002000), CONST64(0x0020000820002000),
886    CONST64(0x0020000000202000), CONST64(0x0020000800202000), CONST64(0x0020000020202000), CONST64(0x0020000820202000),
887    CONST64(0x0020000000000020), CONST64(0x0020000800000020), CONST64(0x0020000020000020), CONST64(0x0020000820000020),
888    CONST64(0x0020000000200020), CONST64(0x0020000800200020), CONST64(0x0020000020200020), CONST64(0x0020000820200020),
889    CONST64(0x0020000000002020), CONST64(0x0020000800002020), CONST64(0x0020000020002020), CONST64(0x0020000820002020),
890    CONST64(0x0020000000202020), CONST64(0x0020000800202020), CONST64(0x0020000020202020), CONST64(0x0020000820202020),
891    CONST64(0x2020000000000000), CONST64(0x2020000800000000), CONST64(0x2020000020000000), CONST64(0x2020000820000000),
892    CONST64(0x2020000000200000), CONST64(0x2020000800200000), CONST64(0x2020000020200000), CONST64(0x2020000820200000),
893    CONST64(0x2020000000002000), CONST64(0x2020000800002000), CONST64(0x2020000020002000), CONST64(0x2020000820002000),
894    CONST64(0x2020000000202000), CONST64(0x2020000800202000), CONST64(0x2020000020202000), CONST64(0x2020000820202000),
895    CONST64(0x2020000000000020), CONST64(0x2020000800000020), CONST64(0x2020000020000020), CONST64(0x2020000820000020),
896    CONST64(0x2020000000200020), CONST64(0x2020000800200020), CONST64(0x2020000020200020), CONST64(0x2020000820200020),
897    CONST64(0x2020000000002020), CONST64(0x2020000800002020), CONST64(0x2020000020002020), CONST64(0x2020000820002020),
898    CONST64(0x2020000000202020), CONST64(0x2020000800202020), CONST64(0x2020000020202020), CONST64(0x2020000820202020),
899    CONST64(0x0000200000000000), CONST64(0x0000200800000000), CONST64(0x0000200020000000), CONST64(0x0000200820000000),
900    CONST64(0x0000200000200000), CONST64(0x0000200800200000), CONST64(0x0000200020200000), CONST64(0x0000200820200000),
901    CONST64(0x0000200000002000), CONST64(0x0000200800002000), CONST64(0x0000200020002000), CONST64(0x0000200820002000),
902    CONST64(0x0000200000202000), CONST64(0x0000200800202000), CONST64(0x0000200020202000), CONST64(0x0000200820202000),
903    CONST64(0x0000200000000020), CONST64(0x0000200800000020), CONST64(0x0000200020000020), CONST64(0x0000200820000020),
904    CONST64(0x0000200000200020), CONST64(0x0000200800200020), CONST64(0x0000200020200020), CONST64(0x0000200820200020),
905    CONST64(0x0000200000002020), CONST64(0x0000200800002020), CONST64(0x0000200020002020), CONST64(0x0000200820002020),
906    CONST64(0x0000200000202020), CONST64(0x0000200800202020), CONST64(0x0000200020202020), CONST64(0x0000200820202020),
907    CONST64(0x2000200000000000), CONST64(0x2000200800000000), CONST64(0x2000200020000000), CONST64(0x2000200820000000),
908    CONST64(0x2000200000200000), CONST64(0x2000200800200000), CONST64(0x2000200020200000), CONST64(0x2000200820200000),
909    CONST64(0x2000200000002000), CONST64(0x2000200800002000), CONST64(0x2000200020002000), CONST64(0x2000200820002000),
910    CONST64(0x2000200000202000), CONST64(0x2000200800202000), CONST64(0x2000200020202000), CONST64(0x2000200820202000),
911    CONST64(0x2000200000000020), CONST64(0x2000200800000020), CONST64(0x2000200020000020), CONST64(0x2000200820000020),
912    CONST64(0x2000200000200020), CONST64(0x2000200800200020), CONST64(0x2000200020200020), CONST64(0x2000200820200020),
913    CONST64(0x2000200000002020), CONST64(0x2000200800002020), CONST64(0x2000200020002020), CONST64(0x2000200820002020),
914    CONST64(0x2000200000202020), CONST64(0x2000200800202020), CONST64(0x2000200020202020), CONST64(0x2000200820202020),
915    CONST64(0x0020200000000000), CONST64(0x0020200800000000), CONST64(0x0020200020000000), CONST64(0x0020200820000000),
916    CONST64(0x0020200000200000), CONST64(0x0020200800200000), CONST64(0x0020200020200000), CONST64(0x0020200820200000),
917    CONST64(0x0020200000002000), CONST64(0x0020200800002000), CONST64(0x0020200020002000), CONST64(0x0020200820002000),
918    CONST64(0x0020200000202000), CONST64(0x0020200800202000), CONST64(0x0020200020202000), CONST64(0x0020200820202000),
919    CONST64(0x0020200000000020), CONST64(0x0020200800000020), CONST64(0x0020200020000020), CONST64(0x0020200820000020),
920    CONST64(0x0020200000200020), CONST64(0x0020200800200020), CONST64(0x0020200020200020), CONST64(0x0020200820200020),
921    CONST64(0x0020200000002020), CONST64(0x0020200800002020), CONST64(0x0020200020002020), CONST64(0x0020200820002020),
922    CONST64(0x0020200000202020), CONST64(0x0020200800202020), CONST64(0x0020200020202020), CONST64(0x0020200820202020),
923    CONST64(0x2020200000000000), CONST64(0x2020200800000000), CONST64(0x2020200020000000), CONST64(0x2020200820000000),
924    CONST64(0x2020200000200000), CONST64(0x2020200800200000), CONST64(0x2020200020200000), CONST64(0x2020200820200000),
925    CONST64(0x2020200000002000), CONST64(0x2020200800002000), CONST64(0x2020200020002000), CONST64(0x2020200820002000),
926    CONST64(0x2020200000202000), CONST64(0x2020200800202000), CONST64(0x2020200020202000), CONST64(0x2020200820202000),
927    CONST64(0x2020200000000020), CONST64(0x2020200800000020), CONST64(0x2020200020000020), CONST64(0x2020200820000020),
928    CONST64(0x2020200000200020), CONST64(0x2020200800200020), CONST64(0x2020200020200020), CONST64(0x2020200820200020),
929    CONST64(0x2020200000002020), CONST64(0x2020200800002020), CONST64(0x2020200020002020), CONST64(0x2020200820002020),
930    CONST64(0x2020200000202020), CONST64(0x2020200800202020), CONST64(0x2020200020202020), CONST64(0x2020200820202020)
931    },
932  { CONST64(0x0000000000000000), CONST64(0x0000002000000000), CONST64(0x0000000080000000), CONST64(0x0000002080000000),
933    CONST64(0x0000000000800000), CONST64(0x0000002000800000), CONST64(0x0000000080800000), CONST64(0x0000002080800000),
934    CONST64(0x0000000000008000), CONST64(0x0000002000008000), CONST64(0x0000000080008000), CONST64(0x0000002080008000),
935    CONST64(0x0000000000808000), CONST64(0x0000002000808000), CONST64(0x0000000080808000), CONST64(0x0000002080808000),
936    CONST64(0x0000000000000080), CONST64(0x0000002000000080), CONST64(0x0000000080000080), CONST64(0x0000002080000080),
937    CONST64(0x0000000000800080), CONST64(0x0000002000800080), CONST64(0x0000000080800080), CONST64(0x0000002080800080),
938    CONST64(0x0000000000008080), CONST64(0x0000002000008080), CONST64(0x0000000080008080), CONST64(0x0000002080008080),
939    CONST64(0x0000000000808080), CONST64(0x0000002000808080), CONST64(0x0000000080808080), CONST64(0x0000002080808080),
940    CONST64(0x8000000000000000), CONST64(0x8000002000000000), CONST64(0x8000000080000000), CONST64(0x8000002080000000),
941    CONST64(0x8000000000800000), CONST64(0x8000002000800000), CONST64(0x8000000080800000), CONST64(0x8000002080800000),
942    CONST64(0x8000000000008000), CONST64(0x8000002000008000), CONST64(0x8000000080008000), CONST64(0x8000002080008000),
943    CONST64(0x8000000000808000), CONST64(0x8000002000808000), CONST64(0x8000000080808000), CONST64(0x8000002080808000),
944    CONST64(0x8000000000000080), CONST64(0x8000002000000080), CONST64(0x8000000080000080), CONST64(0x8000002080000080),
945    CONST64(0x8000000000800080), CONST64(0x8000002000800080), CONST64(0x8000000080800080), CONST64(0x8000002080800080),
946    CONST64(0x8000000000008080), CONST64(0x8000002000008080), CONST64(0x8000000080008080), CONST64(0x8000002080008080),
947    CONST64(0x8000000000808080), CONST64(0x8000002000808080), CONST64(0x8000000080808080), CONST64(0x8000002080808080),
948    CONST64(0x0080000000000000), CONST64(0x0080002000000000), CONST64(0x0080000080000000), CONST64(0x0080002080000000),
949    CONST64(0x0080000000800000), CONST64(0x0080002000800000), CONST64(0x0080000080800000), CONST64(0x0080002080800000),
950    CONST64(0x0080000000008000), CONST64(0x0080002000008000), CONST64(0x0080000080008000), CONST64(0x0080002080008000),
951    CONST64(0x0080000000808000), CONST64(0x0080002000808000), CONST64(0x0080000080808000), CONST64(0x0080002080808000),
952    CONST64(0x0080000000000080), CONST64(0x0080002000000080), CONST64(0x0080000080000080), CONST64(0x0080002080000080),
953    CONST64(0x0080000000800080), CONST64(0x0080002000800080), CONST64(0x0080000080800080), CONST64(0x0080002080800080),
954    CONST64(0x0080000000008080), CONST64(0x0080002000008080), CONST64(0x0080000080008080), CONST64(0x0080002080008080),
955    CONST64(0x0080000000808080), CONST64(0x0080002000808080), CONST64(0x0080000080808080), CONST64(0x0080002080808080),
956    CONST64(0x8080000000000000), CONST64(0x8080002000000000), CONST64(0x8080000080000000), CONST64(0x8080002080000000),
957    CONST64(0x8080000000800000), CONST64(0x8080002000800000), CONST64(0x8080000080800000), CONST64(0x8080002080800000),
958    CONST64(0x8080000000008000), CONST64(0x8080002000008000), CONST64(0x8080000080008000), CONST64(0x8080002080008000),
959    CONST64(0x8080000000808000), CONST64(0x8080002000808000), CONST64(0x8080000080808000), CONST64(0x8080002080808000),
960    CONST64(0x8080000000000080), CONST64(0x8080002000000080), CONST64(0x8080000080000080), CONST64(0x8080002080000080),
961    CONST64(0x8080000000800080), CONST64(0x8080002000800080), CONST64(0x8080000080800080), CONST64(0x8080002080800080),
962    CONST64(0x8080000000008080), CONST64(0x8080002000008080), CONST64(0x8080000080008080), CONST64(0x8080002080008080),
963    CONST64(0x8080000000808080), CONST64(0x8080002000808080), CONST64(0x8080000080808080), CONST64(0x8080002080808080),
964    CONST64(0x0000800000000000), CONST64(0x0000802000000000), CONST64(0x0000800080000000), CONST64(0x0000802080000000),
965    CONST64(0x0000800000800000), CONST64(0x0000802000800000), CONST64(0x0000800080800000), CONST64(0x0000802080800000),
966    CONST64(0x0000800000008000), CONST64(0x0000802000008000), CONST64(0x0000800080008000), CONST64(0x0000802080008000),
967    CONST64(0x0000800000808000), CONST64(0x0000802000808000), CONST64(0x0000800080808000), CONST64(0x0000802080808000),
968    CONST64(0x0000800000000080), CONST64(0x0000802000000080), CONST64(0x0000800080000080), CONST64(0x0000802080000080),
969    CONST64(0x0000800000800080), CONST64(0x0000802000800080), CONST64(0x0000800080800080), CONST64(0x0000802080800080),
970    CONST64(0x0000800000008080), CONST64(0x0000802000008080), CONST64(0x0000800080008080), CONST64(0x0000802080008080),
971    CONST64(0x0000800000808080), CONST64(0x0000802000808080), CONST64(0x0000800080808080), CONST64(0x0000802080808080),
972    CONST64(0x8000800000000000), CONST64(0x8000802000000000), CONST64(0x8000800080000000), CONST64(0x8000802080000000),
973    CONST64(0x8000800000800000), CONST64(0x8000802000800000), CONST64(0x8000800080800000), CONST64(0x8000802080800000),
974    CONST64(0x8000800000008000), CONST64(0x8000802000008000), CONST64(0x8000800080008000), CONST64(0x8000802080008000),
975    CONST64(0x8000800000808000), CONST64(0x8000802000808000), CONST64(0x8000800080808000), CONST64(0x8000802080808000),
976    CONST64(0x8000800000000080), CONST64(0x8000802000000080), CONST64(0x8000800080000080), CONST64(0x8000802080000080),
977    CONST64(0x8000800000800080), CONST64(0x8000802000800080), CONST64(0x8000800080800080), CONST64(0x8000802080800080),
978    CONST64(0x8000800000008080), CONST64(0x8000802000008080), CONST64(0x8000800080008080), CONST64(0x8000802080008080),
979    CONST64(0x8000800000808080), CONST64(0x8000802000808080), CONST64(0x8000800080808080), CONST64(0x8000802080808080),
980    CONST64(0x0080800000000000), CONST64(0x0080802000000000), CONST64(0x0080800080000000), CONST64(0x0080802080000000),
981    CONST64(0x0080800000800000), CONST64(0x0080802000800000), CONST64(0x0080800080800000), CONST64(0x0080802080800000),
982    CONST64(0x0080800000008000), CONST64(0x0080802000008000), CONST64(0x0080800080008000), CONST64(0x0080802080008000),
983    CONST64(0x0080800000808000), CONST64(0x0080802000808000), CONST64(0x0080800080808000), CONST64(0x0080802080808000),
984    CONST64(0x0080800000000080), CONST64(0x0080802000000080), CONST64(0x0080800080000080), CONST64(0x0080802080000080),
985    CONST64(0x0080800000800080), CONST64(0x0080802000800080), CONST64(0x0080800080800080), CONST64(0x0080802080800080),
986    CONST64(0x0080800000008080), CONST64(0x0080802000008080), CONST64(0x0080800080008080), CONST64(0x0080802080008080),
987    CONST64(0x0080800000808080), CONST64(0x0080802000808080), CONST64(0x0080800080808080), CONST64(0x0080802080808080),
988    CONST64(0x8080800000000000), CONST64(0x8080802000000000), CONST64(0x8080800080000000), CONST64(0x8080802080000000),
989    CONST64(0x8080800000800000), CONST64(0x8080802000800000), CONST64(0x8080800080800000), CONST64(0x8080802080800000),
990    CONST64(0x8080800000008000), CONST64(0x8080802000008000), CONST64(0x8080800080008000), CONST64(0x8080802080008000),
991    CONST64(0x8080800000808000), CONST64(0x8080802000808000), CONST64(0x8080800080808000), CONST64(0x8080802080808000),
992    CONST64(0x8080800000000080), CONST64(0x8080802000000080), CONST64(0x8080800080000080), CONST64(0x8080802080000080),
993    CONST64(0x8080800000800080), CONST64(0x8080802000800080), CONST64(0x8080800080800080), CONST64(0x8080802080800080),
994    CONST64(0x8080800000008080), CONST64(0x8080802000008080), CONST64(0x8080800080008080), CONST64(0x8080802080008080),
995    CONST64(0x8080800000808080), CONST64(0x8080802000808080), CONST64(0x8080800080808080), CONST64(0x8080802080808080)
996    },
997  { CONST64(0x0000000000000000), CONST64(0x0000004000000000), CONST64(0x0000000001000000), CONST64(0x0000004001000000),
998    CONST64(0x0000000000010000), CONST64(0x0000004000010000), CONST64(0x0000000001010000), CONST64(0x0000004001010000),
999    CONST64(0x0000000000000100), CONST64(0x0000004000000100), CONST64(0x0000000001000100), CONST64(0x0000004001000100),
1000    CONST64(0x0000000000010100), CONST64(0x0000004000010100), CONST64(0x0000000001010100), CONST64(0x0000004001010100),
1001    CONST64(0x0000000000000001), CONST64(0x0000004000000001), CONST64(0x0000000001000001), CONST64(0x0000004001000001),
1002    CONST64(0x0000000000010001), CONST64(0x0000004000010001), CONST64(0x0000000001010001), CONST64(0x0000004001010001),
1003    CONST64(0x0000000000000101), CONST64(0x0000004000000101), CONST64(0x0000000001000101), CONST64(0x0000004001000101),
1004    CONST64(0x0000000000010101), CONST64(0x0000004000010101), CONST64(0x0000000001010101), CONST64(0x0000004001010101),
1005    CONST64(0x0100000000000000), CONST64(0x0100004000000000), CONST64(0x0100000001000000), CONST64(0x0100004001000000),
1006    CONST64(0x0100000000010000), CONST64(0x0100004000010000), CONST64(0x0100000001010000), CONST64(0x0100004001010000),
1007    CONST64(0x0100000000000100), CONST64(0x0100004000000100), CONST64(0x0100000001000100), CONST64(0x0100004001000100),
1008    CONST64(0x0100000000010100), CONST64(0x0100004000010100), CONST64(0x0100000001010100), CONST64(0x0100004001010100),
1009    CONST64(0x0100000000000001), CONST64(0x0100004000000001), CONST64(0x0100000001000001), CONST64(0x0100004001000001),
1010    CONST64(0x0100000000010001), CONST64(0x0100004000010001), CONST64(0x0100000001010001), CONST64(0x0100004001010001),
1011    CONST64(0x0100000000000101), CONST64(0x0100004000000101), CONST64(0x0100000001000101), CONST64(0x0100004001000101),
1012    CONST64(0x0100000000010101), CONST64(0x0100004000010101), CONST64(0x0100000001010101), CONST64(0x0100004001010101),
1013    CONST64(0x0001000000000000), CONST64(0x0001004000000000), CONST64(0x0001000001000000), CONST64(0x0001004001000000),
1014    CONST64(0x0001000000010000), CONST64(0x0001004000010000), CONST64(0x0001000001010000), CONST64(0x0001004001010000),
1015    CONST64(0x0001000000000100), CONST64(0x0001004000000100), CONST64(0x0001000001000100), CONST64(0x0001004001000100),
1016    CONST64(0x0001000000010100), CONST64(0x0001004000010100), CONST64(0x0001000001010100), CONST64(0x0001004001010100),
1017    CONST64(0x0001000000000001), CONST64(0x0001004000000001), CONST64(0x0001000001000001), CONST64(0x0001004001000001),
1018    CONST64(0x0001000000010001), CONST64(0x0001004000010001), CONST64(0x0001000001010001), CONST64(0x0001004001010001),
1019    CONST64(0x0001000000000101), CONST64(0x0001004000000101), CONST64(0x0001000001000101), CONST64(0x0001004001000101),
1020    CONST64(0x0001000000010101), CONST64(0x0001004000010101), CONST64(0x0001000001010101), CONST64(0x0001004001010101),
1021    CONST64(0x0101000000000000), CONST64(0x0101004000000000), CONST64(0x0101000001000000), CONST64(0x0101004001000000),
1022    CONST64(0x0101000000010000), CONST64(0x0101004000010000), CONST64(0x0101000001010000), CONST64(0x0101004001010000),
1023    CONST64(0x0101000000000100), CONST64(0x0101004000000100), CONST64(0x0101000001000100), CONST64(0x0101004001000100),
1024    CONST64(0x0101000000010100), CONST64(0x0101004000010100), CONST64(0x0101000001010100), CONST64(0x0101004001010100),
1025    CONST64(0x0101000000000001), CONST64(0x0101004000000001), CONST64(0x0101000001000001), CONST64(0x0101004001000001),
1026    CONST64(0x0101000000010001), CONST64(0x0101004000010001), CONST64(0x0101000001010001), CONST64(0x0101004001010001),
1027    CONST64(0x0101000000000101), CONST64(0x0101004000000101), CONST64(0x0101000001000101), CONST64(0x0101004001000101),
1028    CONST64(0x0101000000010101), CONST64(0x0101004000010101), CONST64(0x0101000001010101), CONST64(0x0101004001010101),
1029    CONST64(0x0000010000000000), CONST64(0x0000014000000000), CONST64(0x0000010001000000), CONST64(0x0000014001000000),
1030    CONST64(0x0000010000010000), CONST64(0x0000014000010000), CONST64(0x0000010001010000), CONST64(0x0000014001010000),
1031    CONST64(0x0000010000000100), CONST64(0x0000014000000100), CONST64(0x0000010001000100), CONST64(0x0000014001000100),
1032    CONST64(0x0000010000010100), CONST64(0x0000014000010100), CONST64(0x0000010001010100), CONST64(0x0000014001010100),
1033    CONST64(0x0000010000000001), CONST64(0x0000014000000001), CONST64(0x0000010001000001), CONST64(0x0000014001000001),
1034    CONST64(0x0000010000010001), CONST64(0x0000014000010001), CONST64(0x0000010001010001), CONST64(0x0000014001010001),
1035    CONST64(0x0000010000000101), CONST64(0x0000014000000101), CONST64(0x0000010001000101), CONST64(0x0000014001000101),
1036    CONST64(0x0000010000010101), CONST64(0x0000014000010101), CONST64(0x0000010001010101), CONST64(0x0000014001010101),
1037    CONST64(0x0100010000000000), CONST64(0x0100014000000000), CONST64(0x0100010001000000), CONST64(0x0100014001000000),
1038    CONST64(0x0100010000010000), CONST64(0x0100014000010000), CONST64(0x0100010001010000), CONST64(0x0100014001010000),
1039    CONST64(0x0100010000000100), CONST64(0x0100014000000100), CONST64(0x0100010001000100), CONST64(0x0100014001000100),
1040    CONST64(0x0100010000010100), CONST64(0x0100014000010100), CONST64(0x0100010001010100), CONST64(0x0100014001010100),
1041    CONST64(0x0100010000000001), CONST64(0x0100014000000001), CONST64(0x0100010001000001), CONST64(0x0100014001000001),
1042    CONST64(0x0100010000010001), CONST64(0x0100014000010001), CONST64(0x0100010001010001), CONST64(0x0100014001010001),
1043    CONST64(0x0100010000000101), CONST64(0x0100014000000101), CONST64(0x0100010001000101), CONST64(0x0100014001000101),
1044    CONST64(0x0100010000010101), CONST64(0x0100014000010101), CONST64(0x0100010001010101), CONST64(0x0100014001010101),
1045    CONST64(0x0001010000000000), CONST64(0x0001014000000000), CONST64(0x0001010001000000), CONST64(0x0001014001000000),
1046    CONST64(0x0001010000010000), CONST64(0x0001014000010000), CONST64(0x0001010001010000), CONST64(0x0001014001010000),
1047    CONST64(0x0001010000000100), CONST64(0x0001014000000100), CONST64(0x0001010001000100), CONST64(0x0001014001000100),
1048    CONST64(0x0001010000010100), CONST64(0x0001014000010100), CONST64(0x0001010001010100), CONST64(0x0001014001010100),
1049    CONST64(0x0001010000000001), CONST64(0x0001014000000001), CONST64(0x0001010001000001), CONST64(0x0001014001000001),
1050    CONST64(0x0001010000010001), CONST64(0x0001014000010001), CONST64(0x0001010001010001), CONST64(0x0001014001010001),
1051    CONST64(0x0001010000000101), CONST64(0x0001014000000101), CONST64(0x0001010001000101), CONST64(0x0001014001000101),
1052    CONST64(0x0001010000010101), CONST64(0x0001014000010101), CONST64(0x0001010001010101), CONST64(0x0001014001010101),
1053    CONST64(0x0101010000000000), CONST64(0x0101014000000000), CONST64(0x0101010001000000), CONST64(0x0101014001000000),
1054    CONST64(0x0101010000010000), CONST64(0x0101014000010000), CONST64(0x0101010001010000), CONST64(0x0101014001010000),
1055    CONST64(0x0101010000000100), CONST64(0x0101014000000100), CONST64(0x0101010001000100), CONST64(0x0101014001000100),
1056    CONST64(0x0101010000010100), CONST64(0x0101014000010100), CONST64(0x0101010001010100), CONST64(0x0101014001010100),
1057    CONST64(0x0101010000000001), CONST64(0x0101014000000001), CONST64(0x0101010001000001), CONST64(0x0101014001000001),
1058    CONST64(0x0101010000010001), CONST64(0x0101014000010001), CONST64(0x0101010001010001), CONST64(0x0101014001010001),
1059    CONST64(0x0101010000000101), CONST64(0x0101014000000101), CONST64(0x0101010001000101), CONST64(0x0101014001000101),
1060    CONST64(0x0101010000010101), CONST64(0x0101014000010101), CONST64(0x0101010001010101), CONST64(0x0101014001010101)
1061    },
1062  { CONST64(0x0000000000000000), CONST64(0x0000000100000000), CONST64(0x0000000004000000), CONST64(0x0000000104000000),
1063    CONST64(0x0000000000040000), CONST64(0x0000000100040000), CONST64(0x0000000004040000), CONST64(0x0000000104040000),
1064    CONST64(0x0000000000000400), CONST64(0x0000000100000400), CONST64(0x0000000004000400), CONST64(0x0000000104000400),
1065    CONST64(0x0000000000040400), CONST64(0x0000000100040400), CONST64(0x0000000004040400), CONST64(0x0000000104040400),
1066    CONST64(0x0000000000000004), CONST64(0x0000000100000004), CONST64(0x0000000004000004), CONST64(0x0000000104000004),
1067    CONST64(0x0000000000040004), CONST64(0x0000000100040004), CONST64(0x0000000004040004), CONST64(0x0000000104040004),
1068    CONST64(0x0000000000000404), CONST64(0x0000000100000404), CONST64(0x0000000004000404), CONST64(0x0000000104000404),
1069    CONST64(0x0000000000040404), CONST64(0x0000000100040404), CONST64(0x0000000004040404), CONST64(0x0000000104040404),
1070    CONST64(0x0400000000000000), CONST64(0x0400000100000000), CONST64(0x0400000004000000), CONST64(0x0400000104000000),
1071    CONST64(0x0400000000040000), CONST64(0x0400000100040000), CONST64(0x0400000004040000), CONST64(0x0400000104040000),
1072    CONST64(0x0400000000000400), CONST64(0x0400000100000400), CONST64(0x0400000004000400), CONST64(0x0400000104000400),
1073    CONST64(0x0400000000040400), CONST64(0x0400000100040400), CONST64(0x0400000004040400), CONST64(0x0400000104040400),
1074    CONST64(0x0400000000000004), CONST64(0x0400000100000004), CONST64(0x0400000004000004), CONST64(0x0400000104000004),
1075    CONST64(0x0400000000040004), CONST64(0x0400000100040004), CONST64(0x0400000004040004), CONST64(0x0400000104040004),
1076    CONST64(0x0400000000000404), CONST64(0x0400000100000404), CONST64(0x0400000004000404), CONST64(0x0400000104000404),
1077    CONST64(0x0400000000040404), CONST64(0x0400000100040404), CONST64(0x0400000004040404), CONST64(0x0400000104040404),
1078    CONST64(0x0004000000000000), CONST64(0x0004000100000000), CONST64(0x0004000004000000), CONST64(0x0004000104000000),
1079    CONST64(0x0004000000040000), CONST64(0x0004000100040000), CONST64(0x0004000004040000), CONST64(0x0004000104040000),
1080    CONST64(0x0004000000000400), CONST64(0x0004000100000400), CONST64(0x0004000004000400), CONST64(0x0004000104000400),
1081    CONST64(0x0004000000040400), CONST64(0x0004000100040400), CONST64(0x0004000004040400), CONST64(0x0004000104040400),
1082    CONST64(0x0004000000000004), CONST64(0x0004000100000004), CONST64(0x0004000004000004), CONST64(0x0004000104000004),
1083    CONST64(0x0004000000040004), CONST64(0x0004000100040004), CONST64(0x0004000004040004), CONST64(0x0004000104040004),
1084    CONST64(0x0004000000000404), CONST64(0x0004000100000404), CONST64(0x0004000004000404), CONST64(0x0004000104000404),
1085    CONST64(0x0004000000040404), CONST64(0x0004000100040404), CONST64(0x0004000004040404), CONST64(0x0004000104040404),
1086    CONST64(0x0404000000000000), CONST64(0x0404000100000000), CONST64(0x0404000004000000), CONST64(0x0404000104000000),
1087    CONST64(0x0404000000040000), CONST64(0x0404000100040000), CONST64(0x0404000004040000), CONST64(0x0404000104040000),
1088    CONST64(0x0404000000000400), CONST64(0x0404000100000400), CONST64(0x0404000004000400), CONST64(0x0404000104000400),
1089    CONST64(0x0404000000040400), CONST64(0x0404000100040400), CONST64(0x0404000004040400), CONST64(0x0404000104040400),
1090    CONST64(0x0404000000000004), CONST64(0x0404000100000004), CONST64(0x0404000004000004), CONST64(0x0404000104000004),
1091    CONST64(0x0404000000040004), CONST64(0x0404000100040004), CONST64(0x0404000004040004), CONST64(0x0404000104040004),
1092    CONST64(0x0404000000000404), CONST64(0x0404000100000404), CONST64(0x0404000004000404), CONST64(0x0404000104000404),
1093    CONST64(0x0404000000040404), CONST64(0x0404000100040404), CONST64(0x0404000004040404), CONST64(0x0404000104040404),
1094    CONST64(0x0000040000000000), CONST64(0x0000040100000000), CONST64(0x0000040004000000), CONST64(0x0000040104000000),
1095    CONST64(0x0000040000040000), CONST64(0x0000040100040000), CONST64(0x0000040004040000), CONST64(0x0000040104040000),
1096    CONST64(0x0000040000000400), CONST64(0x0000040100000400), CONST64(0x0000040004000400), CONST64(0x0000040104000400),
1097    CONST64(0x0000040000040400), CONST64(0x0000040100040400), CONST64(0x0000040004040400), CONST64(0x0000040104040400),
1098    CONST64(0x0000040000000004), CONST64(0x0000040100000004), CONST64(0x0000040004000004), CONST64(0x0000040104000004),
1099    CONST64(0x0000040000040004), CONST64(0x0000040100040004), CONST64(0x0000040004040004), CONST64(0x0000040104040004),
1100    CONST64(0x0000040000000404), CONST64(0x0000040100000404), CONST64(0x0000040004000404), CONST64(0x0000040104000404),
1101    CONST64(0x0000040000040404), CONST64(0x0000040100040404), CONST64(0x0000040004040404), CONST64(0x0000040104040404),
1102    CONST64(0x0400040000000000), CONST64(0x0400040100000000), CONST64(0x0400040004000000), CONST64(0x0400040104000000),
1103    CONST64(0x0400040000040000), CONST64(0x0400040100040000), CONST64(0x0400040004040000), CONST64(0x0400040104040000),
1104    CONST64(0x0400040000000400), CONST64(0x0400040100000400), CONST64(0x0400040004000400), CONST64(0x0400040104000400),
1105    CONST64(0x0400040000040400), CONST64(0x0400040100040400), CONST64(0x0400040004040400), CONST64(0x0400040104040400),
1106    CONST64(0x0400040000000004), CONST64(0x0400040100000004), CONST64(0x0400040004000004), CONST64(0x0400040104000004),
1107    CONST64(0x0400040000040004), CONST64(0x0400040100040004), CONST64(0x0400040004040004), CONST64(0x0400040104040004),
1108    CONST64(0x0400040000000404), CONST64(0x0400040100000404), CONST64(0x0400040004000404), CONST64(0x0400040104000404),
1109    CONST64(0x0400040000040404), CONST64(0x0400040100040404), CONST64(0x0400040004040404), CONST64(0x0400040104040404),
1110    CONST64(0x0004040000000000), CONST64(0x0004040100000000), CONST64(0x0004040004000000), CONST64(0x0004040104000000),
1111    CONST64(0x0004040000040000), CONST64(0x0004040100040000), CONST64(0x0004040004040000), CONST64(0x0004040104040000),
1112    CONST64(0x0004040000000400), CONST64(0x0004040100000400), CONST64(0x0004040004000400), CONST64(0x0004040104000400),
1113    CONST64(0x0004040000040400), CONST64(0x0004040100040400), CONST64(0x0004040004040400), CONST64(0x0004040104040400),
1114    CONST64(0x0004040000000004), CONST64(0x0004040100000004), CONST64(0x0004040004000004), CONST64(0x0004040104000004),
1115    CONST64(0x0004040000040004), CONST64(0x0004040100040004), CONST64(0x0004040004040004), CONST64(0x0004040104040004),
1116    CONST64(0x0004040000000404), CONST64(0x0004040100000404), CONST64(0x0004040004000404), CONST64(0x0004040104000404),
1117    CONST64(0x0004040000040404), CONST64(0x0004040100040404), CONST64(0x0004040004040404), CONST64(0x0004040104040404),
1118    CONST64(0x0404040000000000), CONST64(0x0404040100000000), CONST64(0x0404040004000000), CONST64(0x0404040104000000),
1119    CONST64(0x0404040000040000), CONST64(0x0404040100040000), CONST64(0x0404040004040000), CONST64(0x0404040104040000),
1120    CONST64(0x0404040000000400), CONST64(0x0404040100000400), CONST64(0x0404040004000400), CONST64(0x0404040104000400),
1121    CONST64(0x0404040000040400), CONST64(0x0404040100040400), CONST64(0x0404040004040400), CONST64(0x0404040104040400),
1122    CONST64(0x0404040000000004), CONST64(0x0404040100000004), CONST64(0x0404040004000004), CONST64(0x0404040104000004),
1123    CONST64(0x0404040000040004), CONST64(0x0404040100040004), CONST64(0x0404040004040004), CONST64(0x0404040104040004),
1124    CONST64(0x0404040000000404), CONST64(0x0404040100000404), CONST64(0x0404040004000404), CONST64(0x0404040104000404),
1125    CONST64(0x0404040000040404), CONST64(0x0404040100040404), CONST64(0x0404040004040404), CONST64(0x0404040104040404)
1126    },
1127  { CONST64(0x0000000000000000), CONST64(0x0000000400000000), CONST64(0x0000000010000000), CONST64(0x0000000410000000),
1128    CONST64(0x0000000000100000), CONST64(0x0000000400100000), CONST64(0x0000000010100000), CONST64(0x0000000410100000),
1129    CONST64(0x0000000000001000), CONST64(0x0000000400001000), CONST64(0x0000000010001000), CONST64(0x0000000410001000),
1130    CONST64(0x0000000000101000), CONST64(0x0000000400101000), CONST64(0x0000000010101000), CONST64(0x0000000410101000),
1131    CONST64(0x0000000000000010), CONST64(0x0000000400000010), CONST64(0x0000000010000010), CONST64(0x0000000410000010),
1132    CONST64(0x0000000000100010), CONST64(0x0000000400100010), CONST64(0x0000000010100010), CONST64(0x0000000410100010),
1133    CONST64(0x0000000000001010), CONST64(0x0000000400001010), CONST64(0x0000000010001010), CONST64(0x0000000410001010),
1134    CONST64(0x0000000000101010), CONST64(0x0000000400101010), CONST64(0x0000000010101010), CONST64(0x0000000410101010),
1135    CONST64(0x1000000000000000), CONST64(0x1000000400000000), CONST64(0x1000000010000000), CONST64(0x1000000410000000),
1136    CONST64(0x1000000000100000), CONST64(0x1000000400100000), CONST64(0x1000000010100000), CONST64(0x1000000410100000),
1137    CONST64(0x1000000000001000), CONST64(0x1000000400001000), CONST64(0x1000000010001000), CONST64(0x1000000410001000),
1138    CONST64(0x1000000000101000), CONST64(0x1000000400101000), CONST64(0x1000000010101000), CONST64(0x1000000410101000),
1139    CONST64(0x1000000000000010), CONST64(0x1000000400000010), CONST64(0x1000000010000010), CONST64(0x1000000410000010),
1140    CONST64(0x1000000000100010), CONST64(0x1000000400100010), CONST64(0x1000000010100010), CONST64(0x1000000410100010),
1141    CONST64(0x1000000000001010), CONST64(0x1000000400001010), CONST64(0x1000000010001010), CONST64(0x1000000410001010),
1142    CONST64(0x1000000000101010), CONST64(0x1000000400101010), CONST64(0x1000000010101010), CONST64(0x1000000410101010),
1143    CONST64(0x0010000000000000), CONST64(0x0010000400000000), CONST64(0x0010000010000000), CONST64(0x0010000410000000),
1144    CONST64(0x0010000000100000), CONST64(0x0010000400100000), CONST64(0x0010000010100000), CONST64(0x0010000410100000),
1145    CONST64(0x0010000000001000), CONST64(0x0010000400001000), CONST64(0x0010000010001000), CONST64(0x0010000410001000),
1146    CONST64(0x0010000000101000), CONST64(0x0010000400101000), CONST64(0x0010000010101000), CONST64(0x0010000410101000),
1147    CONST64(0x0010000000000010), CONST64(0x0010000400000010), CONST64(0x0010000010000010), CONST64(0x0010000410000010),
1148    CONST64(0x0010000000100010), CONST64(0x0010000400100010), CONST64(0x0010000010100010), CONST64(0x0010000410100010),
1149    CONST64(0x0010000000001010), CONST64(0x0010000400001010), CONST64(0x0010000010001010), CONST64(0x0010000410001010),
1150    CONST64(0x0010000000101010), CONST64(0x0010000400101010), CONST64(0x0010000010101010), CONST64(0x0010000410101010),
1151    CONST64(0x1010000000000000), CONST64(0x1010000400000000), CONST64(0x1010000010000000), CONST64(0x1010000410000000),
1152    CONST64(0x1010000000100000), CONST64(0x1010000400100000), CONST64(0x1010000010100000), CONST64(0x1010000410100000),
1153    CONST64(0x1010000000001000), CONST64(0x1010000400001000), CONST64(0x1010000010001000), CONST64(0x1010000410001000),
1154    CONST64(0x1010000000101000), CONST64(0x1010000400101000), CONST64(0x1010000010101000), CONST64(0x1010000410101000),
1155    CONST64(0x1010000000000010), CONST64(0x1010000400000010), CONST64(0x1010000010000010), CONST64(0x1010000410000010),
1156    CONST64(0x1010000000100010), CONST64(0x1010000400100010), CONST64(0x1010000010100010), CONST64(0x1010000410100010),
1157    CONST64(0x1010000000001010), CONST64(0x1010000400001010), CONST64(0x1010000010001010), CONST64(0x1010000410001010),
1158    CONST64(0x1010000000101010), CONST64(0x1010000400101010), CONST64(0x1010000010101010), CONST64(0x1010000410101010),
1159    CONST64(0x0000100000000000), CONST64(0x0000100400000000), CONST64(0x0000100010000000), CONST64(0x0000100410000000),
1160    CONST64(0x0000100000100000), CONST64(0x0000100400100000), CONST64(0x0000100010100000), CONST64(0x0000100410100000),
1161    CONST64(0x0000100000001000), CONST64(0x0000100400001000), CONST64(0x0000100010001000), CONST64(0x0000100410001000),
1162    CONST64(0x0000100000101000), CONST64(0x0000100400101000), CONST64(0x0000100010101000), CONST64(0x0000100410101000),
1163    CONST64(0x0000100000000010), CONST64(0x0000100400000010), CONST64(0x0000100010000010), CONST64(0x0000100410000010),
1164    CONST64(0x0000100000100010), CONST64(0x0000100400100010), CONST64(0x0000100010100010), CONST64(0x0000100410100010),
1165    CONST64(0x0000100000001010), CONST64(0x0000100400001010), CONST64(0x0000100010001010), CONST64(0x0000100410001010),
1166    CONST64(0x0000100000101010), CONST64(0x0000100400101010), CONST64(0x0000100010101010), CONST64(0x0000100410101010),
1167    CONST64(0x1000100000000000), CONST64(0x1000100400000000), CONST64(0x1000100010000000), CONST64(0x1000100410000000),
1168    CONST64(0x1000100000100000), CONST64(0x1000100400100000), CONST64(0x1000100010100000), CONST64(0x1000100410100000),
1169    CONST64(0x1000100000001000), CONST64(0x1000100400001000), CONST64(0x1000100010001000), CONST64(0x1000100410001000),
1170    CONST64(0x1000100000101000), CONST64(0x1000100400101000), CONST64(0x1000100010101000), CONST64(0x1000100410101000),
1171    CONST64(0x1000100000000010), CONST64(0x1000100400000010), CONST64(0x1000100010000010), CONST64(0x1000100410000010),
1172    CONST64(0x1000100000100010), CONST64(0x1000100400100010), CONST64(0x1000100010100010), CONST64(0x1000100410100010),
1173    CONST64(0x1000100000001010), CONST64(0x1000100400001010), CONST64(0x1000100010001010), CONST64(0x1000100410001010),
1174    CONST64(0x1000100000101010), CONST64(0x1000100400101010), CONST64(0x1000100010101010), CONST64(0x1000100410101010),
1175    CONST64(0x0010100000000000), CONST64(0x0010100400000000), CONST64(0x0010100010000000), CONST64(0x0010100410000000),
1176    CONST64(0x0010100000100000), CONST64(0x0010100400100000), CONST64(0x0010100010100000), CONST64(0x0010100410100000),
1177    CONST64(0x0010100000001000), CONST64(0x0010100400001000), CONST64(0x0010100010001000), CONST64(0x0010100410001000),
1178    CONST64(0x0010100000101000), CONST64(0x0010100400101000), CONST64(0x0010100010101000), CONST64(0x0010100410101000),
1179    CONST64(0x0010100000000010), CONST64(0x0010100400000010), CONST64(0x0010100010000010), CONST64(0x0010100410000010),
1180    CONST64(0x0010100000100010), CONST64(0x0010100400100010), CONST64(0x0010100010100010), CONST64(0x0010100410100010),
1181    CONST64(0x0010100000001010), CONST64(0x0010100400001010), CONST64(0x0010100010001010), CONST64(0x0010100410001010),
1182    CONST64(0x0010100000101010), CONST64(0x0010100400101010), CONST64(0x0010100010101010), CONST64(0x0010100410101010),
1183    CONST64(0x1010100000000000), CONST64(0x1010100400000000), CONST64(0x1010100010000000), CONST64(0x1010100410000000),
1184    CONST64(0x1010100000100000), CONST64(0x1010100400100000), CONST64(0x1010100010100000), CONST64(0x1010100410100000),
1185    CONST64(0x1010100000001000), CONST64(0x1010100400001000), CONST64(0x1010100010001000), CONST64(0x1010100410001000),
1186    CONST64(0x1010100000101000), CONST64(0x1010100400101000), CONST64(0x1010100010101000), CONST64(0x1010100410101000),
1187    CONST64(0x1010100000000010), CONST64(0x1010100400000010), CONST64(0x1010100010000010), CONST64(0x1010100410000010),
1188    CONST64(0x1010100000100010), CONST64(0x1010100400100010), CONST64(0x1010100010100010), CONST64(0x1010100410100010),
1189    CONST64(0x1010100000001010), CONST64(0x1010100400001010), CONST64(0x1010100010001010), CONST64(0x1010100410001010),
1190    CONST64(0x1010100000101010), CONST64(0x1010100400101010), CONST64(0x1010100010101010), CONST64(0x1010100410101010)
1191    },
1192  { CONST64(0x0000000000000000), CONST64(0x0000001000000000), CONST64(0x0000000040000000), CONST64(0x0000001040000000),
1193    CONST64(0x0000000000400000), CONST64(0x0000001000400000), CONST64(0x0000000040400000), CONST64(0x0000001040400000),
1194    CONST64(0x0000000000004000), CONST64(0x0000001000004000), CONST64(0x0000000040004000), CONST64(0x0000001040004000),
1195    CONST64(0x0000000000404000), CONST64(0x0000001000404000), CONST64(0x0000000040404000), CONST64(0x0000001040404000),
1196    CONST64(0x0000000000000040), CONST64(0x0000001000000040), CONST64(0x0000000040000040), CONST64(0x0000001040000040),
1197    CONST64(0x0000000000400040), CONST64(0x0000001000400040), CONST64(0x0000000040400040), CONST64(0x0000001040400040),
1198    CONST64(0x0000000000004040), CONST64(0x0000001000004040), CONST64(0x0000000040004040), CONST64(0x0000001040004040),
1199    CONST64(0x0000000000404040), CONST64(0x0000001000404040), CONST64(0x0000000040404040), CONST64(0x0000001040404040),
1200    CONST64(0x4000000000000000), CONST64(0x4000001000000000), CONST64(0x4000000040000000), CONST64(0x4000001040000000),
1201    CONST64(0x4000000000400000), CONST64(0x4000001000400000), CONST64(0x4000000040400000), CONST64(0x4000001040400000),
1202    CONST64(0x4000000000004000), CONST64(0x4000001000004000), CONST64(0x4000000040004000), CONST64(0x4000001040004000),
1203    CONST64(0x4000000000404000), CONST64(0x4000001000404000), CONST64(0x4000000040404000), CONST64(0x4000001040404000),
1204    CONST64(0x4000000000000040), CONST64(0x4000001000000040), CONST64(0x4000000040000040), CONST64(0x4000001040000040),
1205    CONST64(0x4000000000400040), CONST64(0x4000001000400040), CONST64(0x4000000040400040), CONST64(0x4000001040400040),
1206    CONST64(0x4000000000004040), CONST64(0x4000001000004040), CONST64(0x4000000040004040), CONST64(0x4000001040004040),
1207    CONST64(0x4000000000404040), CONST64(0x4000001000404040), CONST64(0x4000000040404040), CONST64(0x4000001040404040),
1208    CONST64(0x0040000000000000), CONST64(0x0040001000000000), CONST64(0x0040000040000000), CONST64(0x0040001040000000),
1209    CONST64(0x0040000000400000), CONST64(0x0040001000400000), CONST64(0x0040000040400000), CONST64(0x0040001040400000),
1210    CONST64(0x0040000000004000), CONST64(0x0040001000004000), CONST64(0x0040000040004000), CONST64(0x0040001040004000),
1211    CONST64(0x0040000000404000), CONST64(0x0040001000404000), CONST64(0x0040000040404000), CONST64(0x0040001040404000),
1212    CONST64(0x0040000000000040), CONST64(0x0040001000000040), CONST64(0x0040000040000040), CONST64(0x0040001040000040),
1213    CONST64(0x0040000000400040), CONST64(0x0040001000400040), CONST64(0x0040000040400040), CONST64(0x0040001040400040),
1214    CONST64(0x0040000000004040), CONST64(0x0040001000004040), CONST64(0x0040000040004040), CONST64(0x0040001040004040),
1215    CONST64(0x0040000000404040), CONST64(0x0040001000404040), CONST64(0x0040000040404040), CONST64(0x0040001040404040),
1216    CONST64(0x4040000000000000), CONST64(0x4040001000000000), CONST64(0x4040000040000000), CONST64(0x4040001040000000),
1217    CONST64(0x4040000000400000), CONST64(0x4040001000400000), CONST64(0x4040000040400000), CONST64(0x4040001040400000),
1218    CONST64(0x4040000000004000), CONST64(0x4040001000004000), CONST64(0x4040000040004000), CONST64(0x4040001040004000),
1219    CONST64(0x4040000000404000), CONST64(0x4040001000404000), CONST64(0x4040000040404000), CONST64(0x4040001040404000),
1220    CONST64(0x4040000000000040), CONST64(0x4040001000000040), CONST64(0x4040000040000040), CONST64(0x4040001040000040),
1221    CONST64(0x4040000000400040), CONST64(0x4040001000400040), CONST64(0x4040000040400040), CONST64(0x4040001040400040),
1222    CONST64(0x4040000000004040), CONST64(0x4040001000004040), CONST64(0x4040000040004040), CONST64(0x4040001040004040),
1223    CONST64(0x4040000000404040), CONST64(0x4040001000404040), CONST64(0x4040000040404040), CONST64(0x4040001040404040),
1224    CONST64(0x0000400000000000), CONST64(0x0000401000000000), CONST64(0x0000400040000000), CONST64(0x0000401040000000),
1225    CONST64(0x0000400000400000), CONST64(0x0000401000400000), CONST64(0x0000400040400000), CONST64(0x0000401040400000),
1226    CONST64(0x0000400000004000), CONST64(0x0000401000004000), CONST64(0x0000400040004000), CONST64(0x0000401040004000),
1227    CONST64(0x0000400000404000), CONST64(0x0000401000404000), CONST64(0x0000400040404000), CONST64(0x0000401040404000),
1228    CONST64(0x0000400000000040), CONST64(0x0000401000000040), CONST64(0x0000400040000040), CONST64(0x0000401040000040),
1229    CONST64(0x0000400000400040), CONST64(0x0000401000400040), CONST64(0x0000400040400040), CONST64(0x0000401040400040),
1230    CONST64(0x0000400000004040), CONST64(0x0000401000004040), CONST64(0x0000400040004040), CONST64(0x0000401040004040),
1231    CONST64(0x0000400000404040), CONST64(0x0000401000404040), CONST64(0x0000400040404040), CONST64(0x0000401040404040),
1232    CONST64(0x4000400000000000), CONST64(0x4000401000000000), CONST64(0x4000400040000000), CONST64(0x4000401040000000),
1233    CONST64(0x4000400000400000), CONST64(0x4000401000400000), CONST64(0x4000400040400000), CONST64(0x4000401040400000),
1234    CONST64(0x4000400000004000), CONST64(0x4000401000004000), CONST64(0x4000400040004000), CONST64(0x4000401040004000),
1235    CONST64(0x4000400000404000), CONST64(0x4000401000404000), CONST64(0x4000400040404000), CONST64(0x4000401040404000),
1236    CONST64(0x4000400000000040), CONST64(0x4000401000000040), CONST64(0x4000400040000040), CONST64(0x4000401040000040),
1237    CONST64(0x4000400000400040), CONST64(0x4000401000400040), CONST64(0x4000400040400040), CONST64(0x4000401040400040),
1238    CONST64(0x4000400000004040), CONST64(0x4000401000004040), CONST64(0x4000400040004040), CONST64(0x4000401040004040),
1239    CONST64(0x4000400000404040), CONST64(0x4000401000404040), CONST64(0x4000400040404040), CONST64(0x4000401040404040),
1240    CONST64(0x0040400000000000), CONST64(0x0040401000000000), CONST64(0x0040400040000000), CONST64(0x0040401040000000),
1241    CONST64(0x0040400000400000), CONST64(0x0040401000400000), CONST64(0x0040400040400000), CONST64(0x0040401040400000),
1242    CONST64(0x0040400000004000), CONST64(0x0040401000004000), CONST64(0x0040400040004000), CONST64(0x0040401040004000),
1243    CONST64(0x0040400000404000), CONST64(0x0040401000404000), CONST64(0x0040400040404000), CONST64(0x0040401040404000),
1244    CONST64(0x0040400000000040), CONST64(0x0040401000000040), CONST64(0x0040400040000040), CONST64(0x0040401040000040),
1245    CONST64(0x0040400000400040), CONST64(0x0040401000400040), CONST64(0x0040400040400040), CONST64(0x0040401040400040),
1246    CONST64(0x0040400000004040), CONST64(0x0040401000004040), CONST64(0x0040400040004040), CONST64(0x0040401040004040),
1247    CONST64(0x0040400000404040), CONST64(0x0040401000404040), CONST64(0x0040400040404040), CONST64(0x0040401040404040),
1248    CONST64(0x4040400000000000), CONST64(0x4040401000000000), CONST64(0x4040400040000000), CONST64(0x4040401040000000),
1249    CONST64(0x4040400000400000), CONST64(0x4040401000400000), CONST64(0x4040400040400000), CONST64(0x4040401040400000),
1250    CONST64(0x4040400000004000), CONST64(0x4040401000004000), CONST64(0x4040400040004000), CONST64(0x4040401040004000),
1251    CONST64(0x4040400000404000), CONST64(0x4040401000404000), CONST64(0x4040400040404000), CONST64(0x4040401040404000),
1252    CONST64(0x4040400000000040), CONST64(0x4040401000000040), CONST64(0x4040400040000040), CONST64(0x4040401040000040),
1253    CONST64(0x4040400000400040), CONST64(0x4040401000400040), CONST64(0x4040400040400040), CONST64(0x4040401040400040),
1254    CONST64(0x4040400000004040), CONST64(0x4040401000004040), CONST64(0x4040400040004040), CONST64(0x4040401040004040),
1255    CONST64(0x4040400000404040), CONST64(0x4040401000404040), CONST64(0x4040400040404040), CONST64(0x4040401040404040)
1256    }};
1257  #endif
1258  static void cookey(const ulong32 *raw1, ulong32 *keyout);
1259  #ifdef LTC_CLEAN_STACK
1260  static void s_deskey(const unsigned char *key, short edf, ulong32 *keyout)
1261  #else
1262  static void deskey(const unsigned char *key, short edf, ulong32 *keyout)
1263  #endif
1264  {
1265      ulong32 i, j, l, m, n, kn[32];
1266      unsigned char pc1m[56], pcr[56];
1267      for (j=0; j < 56; j++) {
1268          l = (ulong32)pc1[j];
1269          m = l & 7;
1270          pc1m[j] = (unsigned char)((key[l >> 3U] & bytebit[m]) == bytebit[m] ? 1 : 0);
1271      }
1272      for (i=0; i < 16; i++) {
1273          if (edf == DE1) {
1274             m = (15 - i) << 1;
1275          } else {
1276             m = i << 1;
1277          }
1278          n = m + 1;
1279          kn[m] = kn[n] = 0L;
1280          for (j=0; j < 28; j++) {
1281              l = j + (ulong32)totrot[i];
1282              if (l < 28) {
1283                 pcr[j] = pc1m[l];
1284              } else {
1285                 pcr[j] = pc1m[l - 28];
1286              }
1287          }
1288          for (&bsol;*j = 28*/; j < 56; j++) {
1289              l = j + (ulong32)totrot[i];
1290              if (l < 56) {
1291                 pcr[j] = pc1m[l];
1292              } else {
1293                 pcr[j] = pc1m[l - 28];
1294              }
1295          }
1296          for (j=0; j < 24; j++)  {
1297              if ((int)pcr[(int)pc2[j]] != 0) {
1298                 kn[m] |= bigbyte[j];
1299              }
1300              if ((int)pcr[(int)pc2[j+24]] != 0) {
1301                 kn[n] |= bigbyte[j];
1302              }
1303          }
1304      }
1305      cookey(kn, keyout);
1306  }
1307  #ifdef LTC_CLEAN_STACK
1308  static void deskey(const unsigned char *key, short edf, ulong32 *keyout)
1309  {
1310     s_deskey(key, edf, keyout);
1311     burn_stack(sizeof(int)*5 + sizeof(ulong32)*32 + sizeof(unsigned char)*112);
1312  }
1313  #endif
1314  #ifdef LTC_CLEAN_STACK
1315  static void s_cookey(const ulong32 *raw1, ulong32 *keyout)
1316  #else
1317  static void cookey(const ulong32 *raw1, ulong32 *keyout)
1318  #endif
1319  {
1320      ulong32 *cook;
1321      const ulong32 *raw0;
1322      ulong32 dough[32];
1323      int i;
1324      cook = dough;
1325      for(i=0; i < 16; i++, raw1++)
1326      {
1327          raw0 = raw1++;
1328          *cook    = (*raw0 & 0x00fc0000L) << 6;
1329          *cook   |= (*raw0 & 0x00000fc0L) << 10;
1330          *cook   |= (*raw1 & 0x00fc0000L) >> 10;
1331          *cook++ |= (*raw1 & 0x00000fc0L) >> 6;
1332          *cook    = (*raw0 & 0x0003f000L) << 12;
1333          *cook   |= (*raw0 & 0x0000003fL) << 16;
1334          *cook   |= (*raw1 & 0x0003f000L) >> 4;
1335          *cook++ |= (*raw1 & 0x0000003fL);
1336      }
1337      XMEMCPY(keyout, dough, sizeof(dough));
1338  }
1339  #ifdef LTC_CLEAN_STACK
1340  static void cookey(const ulong32 *raw1, ulong32 *keyout)
1341  {
1342     s_cookey(raw1, keyout);
1343     burn_stack(sizeof(ulong32 *) * 2 + sizeof(ulong32)*32 + sizeof(int));
1344  }
1345  #endif
1346  #ifndef LTC_CLEAN_STACK
1347  static void desfunc(ulong32 *block, const ulong32 *keys)
1348  #else
1349  static void s_desfunc(ulong32 *block, const ulong32 *keys)
1350  #endif
1351  {
1352      ulong32 work, right, leftt;
<span onclick='openModal()' class='match'>1353      int cur_round;
1354      leftt = block[0];
1355      right = block[1];
1356  #ifdef LTC_SMALL_CODE
1357      work = ((leftt >> 4)  ^ right) & 0x0f0f0f0fL;
1358      right ^= work;
1359      leftt ^= (work << 4);
1360      work = ((leftt >> 16) ^ right) & 0x0000ffffL;
1361      right ^= work;
</span>1362      leftt ^= (work << 16);
1363      work = ((right >> 2)  ^ leftt) & 0x33333333L;
1364      leftt ^= work;
1365      right ^= (work << 2);
1366      work = ((right >> 8)  ^ leftt) & 0x00ff00ffL;
1367      leftt ^= work;
1368      right ^= (work << 8);
1369      right = ROLc(right, 1);
1370      work = (leftt ^ right) & 0xaaaaaaaaL;
1371      leftt ^= work;
1372      right ^= work;
1373      leftt = ROLc(leftt, 1);
1374  #else
1375     {
1376        ulong64 tmp;
1377        tmp = des_ip[0][LTC_BYTE(leftt, 0)] ^
1378              des_ip[1][LTC_BYTE(leftt, 1)] ^
1379              des_ip[2][LTC_BYTE(leftt, 2)] ^
1380              des_ip[3][LTC_BYTE(leftt, 3)] ^
1381              des_ip[4][LTC_BYTE(right, 0)] ^
1382              des_ip[5][LTC_BYTE(right, 1)] ^
1383              des_ip[6][LTC_BYTE(right, 2)] ^
1384              des_ip[7][LTC_BYTE(right, 3)];
1385        leftt = (ulong32)(tmp >> 32);
1386        right = (ulong32)(tmp & 0xFFFFFFFFUL);
1387     }
1388  #endif
1389      for (cur_round = 0; cur_round < 8; cur_round++) {
1390          work  = RORc(right, 4) ^ *keys++;
1391          leftt ^= SP7[work        & 0x3fL]
1392                ^  SP5[(work >>  8) & 0x3fL]
1393                ^  SP3[(work >> 16) & 0x3fL]
1394                ^  SP1[(work >> 24) & 0x3fL];
1395          work  = right ^ *keys++;
1396          leftt ^= SP8[ work        & 0x3fL]
1397                ^  SP6[(work >>  8) & 0x3fL]
1398                ^  SP4[(work >> 16) & 0x3fL]
1399                ^  SP2[(work >> 24) & 0x3fL];
1400          work = RORc(leftt, 4) ^ *keys++;
1401          right ^= SP7[ work        & 0x3fL]
1402                ^  SP5[(work >>  8) & 0x3fL]
1403                ^  SP3[(work >> 16) & 0x3fL]
1404                ^  SP1[(work >> 24) & 0x3fL];
1405          work  = leftt ^ *keys++;
1406          right ^= SP8[ work        & 0x3fL]
1407                ^  SP6[(work >>  8) & 0x3fL]
1408                ^  SP4[(work >> 16) & 0x3fL]
1409                ^  SP2[(work >> 24) & 0x3fL];
1410      }
1411  #ifdef LTC_SMALL_CODE
1412      right = RORc(right, 1);
1413      work = (leftt ^ right) & 0xaaaaaaaaL;
1414      leftt ^= work;
1415      right ^= work;
1416      leftt = RORc(leftt, 1);
1417      work = ((leftt >> 8) ^ right) & 0x00ff00ffL;
1418      right ^= work;
1419      leftt ^= (work << 8);
1420      work = ((leftt >> 2) ^ right) & 0x33333333L;
1421      right ^= work;
1422      leftt ^= (work << 2);
1423      work = ((right >> 16) ^ leftt) & 0x0000ffffL;
1424      leftt ^= work;
1425      right ^= (work << 16);
1426      work = ((right >> 4) ^ leftt) & 0x0f0f0f0fL;
1427      leftt ^= work;
1428      right ^= (work << 4);
1429  #else
1430     {
1431        ulong64 tmp;
1432        tmp = des_fp[0][LTC_BYTE(leftt, 0)] ^
1433              des_fp[1][LTC_BYTE(leftt, 1)] ^
1434              des_fp[2][LTC_BYTE(leftt, 2)] ^
1435              des_fp[3][LTC_BYTE(leftt, 3)] ^
1436              des_fp[4][LTC_BYTE(right, 0)] ^
1437              des_fp[5][LTC_BYTE(right, 1)] ^
1438              des_fp[6][LTC_BYTE(right, 2)] ^
1439              des_fp[7][LTC_BYTE(right, 3)];
1440        leftt = (ulong32)(tmp >> 32);
1441        right = (ulong32)(tmp & 0xFFFFFFFFUL);
1442     }
1443  #endif
1444      block[0] = right;
1445      block[1] = leftt;
1446  }
1447  #ifdef LTC_CLEAN_STACK
1448  static void desfunc(ulong32 *block, const ulong32 *keys)
1449  {
1450     s_desfunc(block, keys);
1451     burn_stack(sizeof(ulong32) * 4 + sizeof(int));
1452  }
1453  #endif
1454  int des_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
1455  {
1456      LTC_ARGCHK(key != NULL);
1457      LTC_ARGCHK(skey != NULL);
1458      if (num_rounds != 0 && num_rounds != 16) {
1459          return CRYPT_INVALID_ROUNDS;
1460      }
1461      if (keylen != 8) {
1462          return CRYPT_INVALID_KEYSIZE;
1463      }
1464      deskey(key, EN0, skey->des.ek);
1465      deskey(key, DE1, skey->des.dk);
1466      return CRYPT_OK;
1467  }
1468  int des3_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
1469  {
1470      LTC_ARGCHK(key != NULL);
1471      LTC_ARGCHK(skey != NULL);
1472      if(num_rounds != 0 && num_rounds != 16) {
1473          return CRYPT_INVALID_ROUNDS;
1474      }
1475      if (keylen != 24 && keylen != 16) {
1476          return CRYPT_INVALID_KEYSIZE;
1477      }
1478      deskey(key,    EN0, skey->des3.ek[0]);
1479      deskey(key+8,  DE1, skey->des3.ek[1]);
1480      if (keylen == 24) {
1481          deskey(key+16, EN0, skey->des3.ek[2]);
1482      } else {
1483          deskey(key, EN0, skey->des3.ek[2]);
1484      }
1485      deskey(key,    DE1, skey->des3.dk[2]);
1486      deskey(key+8,  EN0, skey->des3.dk[1]);
1487      if (keylen == 24) {
1488          deskey(key+16, DE1, skey->des3.dk[0]);
1489      } else {
1490          deskey(key, DE1, skey->des3.dk[0]);
1491      }
1492      return CRYPT_OK;
1493  }
1494  int des_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
1495  {
1496      ulong32 work[2];
1497      LTC_ARGCHK(pt   != NULL);
1498      LTC_ARGCHK(ct   != NULL);
1499      LTC_ARGCHK(skey != NULL);
1500      LOAD32H(work[0], pt+0);
1501      LOAD32H(work[1], pt+4);
1502      desfunc(work, skey->des.ek);
1503      STORE32H(work[0],ct+0);
1504      STORE32H(work[1],ct+4);
1505      return CRYPT_OK;
1506  }
1507  int des_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
1508  {
1509      ulong32 work[2];
1510      LTC_ARGCHK(pt   != NULL);
1511      LTC_ARGCHK(ct   != NULL);
1512      LTC_ARGCHK(skey != NULL);
1513      LOAD32H(work[0], ct+0);
1514      LOAD32H(work[1], ct+4);
1515      desfunc(work, skey->des.dk);
1516      STORE32H(work[0],pt+0);
1517      STORE32H(work[1],pt+4);
1518      return CRYPT_OK;
1519  }
1520  int des3_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
1521  {
1522      ulong32 work[2];
1523      LTC_ARGCHK(pt   != NULL);
1524      LTC_ARGCHK(ct   != NULL);
1525      LTC_ARGCHK(skey != NULL);
1526      LOAD32H(work[0], pt+0);
1527      LOAD32H(work[1], pt+4);
1528      desfunc(work, skey->des3.ek[0]);
1529      desfunc(work, skey->des3.ek[1]);
1530      desfunc(work, skey->des3.ek[2]);
1531      STORE32H(work[0],ct+0);
1532      STORE32H(work[1],ct+4);
1533      return CRYPT_OK;
1534  }
1535  int des3_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
1536  {
1537      ulong32 work[2];
1538      LTC_ARGCHK(pt   != NULL);
1539      LTC_ARGCHK(ct   != NULL);
1540      LTC_ARGCHK(skey != NULL);
1541      LOAD32H(work[0], ct+0);
1542      LOAD32H(work[1], ct+4);
1543      desfunc(work, skey->des3.dk[0]);
1544      desfunc(work, skey->des3.dk[1]);
1545      desfunc(work, skey->des3.dk[2]);
1546      STORE32H(work[0],pt+0);
1547      STORE32H(work[1],pt+4);
1548      return CRYPT_OK;
1549  }
1550  int des_test(void)
1551  {
1552   #ifndef LTC_TEST
1553      return CRYPT_NOP;
1554   #else
1555      static const struct des_test_case {
1556          unsigned char key[8], txt[8], out[8];
1557      } cases[] = {
1558          { { 0x10, 0x31, 0x6E, 0x02, 0x8C, 0x8F, 0x3B, 0x4A },
1559            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1560            { 0x82, 0xDC, 0xBA, 0xFB, 0xDE, 0xAB, 0x66, 0x02 } },
1561          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
1562            { 0x95, 0xF8, 0xA5, 0xE5, 0xDD, 0x31, 0xD9, 0x00 },
1563            { 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
1564          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
1565            { 0xDD, 0x7F, 0x12, 0x1C, 0xA5, 0x01, 0x56, 0x19 },
1566            { 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
1567          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
1568            { 0x2E, 0x86, 0x53, 0x10, 0x4F, 0x38, 0x34, 0xEA },
1569            { 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
1570          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
1571            { 0x4B, 0xD3, 0x88, 0xFF, 0x6C, 0xD8, 0x1D, 0x4F },
1572            { 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
1573          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
1574            { 0x20, 0xB9, 0xE7, 0x67, 0xB2, 0xFB, 0x14, 0x56 },
1575            { 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
1576          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
1577            { 0x55, 0x57, 0x93, 0x80, 0xD7, 0x71, 0x38, 0xEF },
1578            { 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
1579          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
1580            { 0x6C, 0xC5, 0xDE, 0xFA, 0xAF, 0x04, 0x51, 0x2F },
1581            { 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
1582          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
1583            { 0x0D, 0x9F, 0x27, 0x9B, 0xA5, 0xD8, 0x72, 0x60 },
1584            { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
1585          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
1586            { 0xD9, 0x03, 0x1B, 0x02, 0x71, 0xBD, 0x5A, 0x0A },
1587            { 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
1588          { { 0x80, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
1589            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1590            { 0x95, 0xA8, 0xD7, 0x28, 0x13, 0xDA, 0xA9, 0x4D } },
1591          { { 0x40, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
1592            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1593            { 0x0E, 0xEC, 0x14, 0x87, 0xDD, 0x8C, 0x26, 0xD5 } },
1594          { { 0x20, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
1595            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1596            { 0x7A, 0xD1, 0x6F, 0xFB, 0x79, 0xC4, 0x59, 0x26 } },
1597          { { 0x10, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
1598            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1599            { 0xD3, 0x74, 0x62, 0x94, 0xCA, 0x6A, 0x6C, 0xF3 } },
1600          { { 0x08, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
1601            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1602            { 0x80, 0x9F, 0x5F, 0x87, 0x3C, 0x1F, 0xD7, 0x61 } },
1603          { { 0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
1604            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1605            { 0xC0, 0x2F, 0xAF, 0xFE, 0xC9, 0x89, 0xD1, 0xFC } },
1606          { { 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
1607            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1608            { 0x46, 0x15, 0xAA, 0x1D, 0x33, 0xE7, 0x2F, 0x10 } },
1609          { { 0x01, 0x80, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
1610            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1611            { 0x20, 0x55, 0x12, 0x33, 0x50, 0xC0, 0x08, 0x58 } },
1612          { { 0x01, 0x40, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
1613            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1614            { 0xDF, 0x3B, 0x99, 0xD6, 0x57, 0x73, 0x97, 0xC8 } },
1615          { { 0x01, 0x20, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
1616            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1617            { 0x31, 0xFE, 0x17, 0x36, 0x9B, 0x52, 0x88, 0xC9 } },
1618          { { 0x01, 0x10, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
1619            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1620            { 0xDF, 0xDD, 0x3C, 0xC6, 0x4D, 0xAE, 0x16, 0x42 } },
1621          { { 0x01, 0x08, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
1622            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1623            { 0x17, 0x8C, 0x83, 0xCE, 0x2B, 0x39, 0x9D, 0x94 } },
1624          { { 0x01, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
1625            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1626            { 0x50, 0xF6, 0x36, 0x32, 0x4A, 0x9B, 0x7F, 0x80 } },
1627          { { 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 },
1628            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1629            { 0xA8, 0x46, 0x8E, 0xE3, 0xBC, 0x18, 0xF0, 0x6D } },
1630          { { 0x01, 0x01, 0x80, 0x01, 0x01, 0x01, 0x01, 0x01 },
1631            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1632            { 0xA2, 0xDC, 0x9E, 0x92, 0xFD, 0x3C, 0xDE, 0x92 } },
1633          { { 0x01, 0x01, 0x40, 0x01, 0x01, 0x01, 0x01, 0x01 },
1634            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1635            { 0xCA, 0xC0, 0x9F, 0x79, 0x7D, 0x03, 0x12, 0x87 } },
1636          { { 0x01, 0x01, 0x20, 0x01, 0x01, 0x01, 0x01, 0x01 },
1637            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1638            { 0x90, 0xBA, 0x68, 0x0B, 0x22, 0xAE, 0xB5, 0x25 } },
1639          { { 0x01, 0x01, 0x10, 0x01, 0x01, 0x01, 0x01, 0x01 },
1640            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1641            { 0xCE, 0x7A, 0x24, 0xF3, 0x50, 0xE2, 0x80, 0xB6 } },
1642          { { 0x01, 0x01, 0x08, 0x01, 0x01, 0x01, 0x01, 0x01 },
1643            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1644            { 0x88, 0x2B, 0xFF, 0x0A, 0xA0, 0x1A, 0x0B, 0x87 } },
1645          { { 0x01, 0x01, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01 },
1646            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1647            { 0x25, 0x61, 0x02, 0x88, 0x92, 0x45, 0x11, 0xC2 } },
1648          { { 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01 },
1649            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1650            { 0xC7, 0x15, 0x16, 0xC2, 0x9C, 0x75, 0xD1, 0x70 } },
1651          { { 0x01, 0x01, 0x01, 0x80, 0x01, 0x01, 0x01, 0x01 },
1652            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1653            { 0x51, 0x99, 0xC2, 0x9A, 0x52, 0xC9, 0xF0, 0x59 } },
1654          { { 0x01, 0x01, 0x01, 0x40, 0x01, 0x01, 0x01, 0x01 },
1655            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1656            { 0xC2, 0x2F, 0x0A, 0x29, 0x4A, 0x71, 0xF2, 0x9F } },
1657          { { 0x01, 0x01, 0x01, 0x20, 0x01, 0x01, 0x01, 0x01 },
1658            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1659            { 0xEE, 0x37, 0x14, 0x83, 0x71, 0x4C, 0x02, 0xEA } },
1660          { { 0x01, 0x01, 0x01, 0x10, 0x01, 0x01, 0x01, 0x01 },
1661            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1662            { 0xA8, 0x1F, 0xBD, 0x44, 0x8F, 0x9E, 0x52, 0x2F } },
1663          { { 0x01, 0x01, 0x01, 0x08, 0x01, 0x01, 0x01, 0x01 },
1664            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1665            { 0x4F, 0x64, 0x4C, 0x92, 0xE1, 0x92, 0xDF, 0xED } },
1666          { { 0x01, 0x01, 0x01, 0x04, 0x01, 0x01, 0x01, 0x01 },
1667            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1668            { 0x1A, 0xFA, 0x9A, 0x66, 0xA6, 0xDF, 0x92, 0xAE } },
1669          { { 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01 },
1670            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1671            { 0xB3, 0xC1, 0xCC, 0x71, 0x5C, 0xB8, 0x79, 0xD8 } },
1672          { { 0x01, 0x01, 0x01, 0x01, 0x80, 0x01, 0x01, 0x01 },
1673            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1674            { 0x19, 0xD0, 0x32, 0xE6, 0x4A, 0xB0, 0xBD, 0x8B } },
1675          { { 0x01, 0x01, 0x01, 0x01, 0x40, 0x01, 0x01, 0x01 },
1676            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1677            { 0x3C, 0xFA, 0xA7, 0xA7, 0xDC, 0x87, 0x20, 0xDC } },
1678          { { 0x01, 0x01, 0x01, 0x01, 0x20, 0x01, 0x01, 0x01 },
1679            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1680            { 0xB7, 0x26, 0x5F, 0x7F, 0x44, 0x7A, 0xC6, 0xF3 } },
1681          { { 0x01, 0x01, 0x01, 0x01, 0x10, 0x01, 0x01, 0x01 },
1682            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1683            { 0x9D, 0xB7, 0x3B, 0x3C, 0x0D, 0x16, 0x3F, 0x54 } },
1684          { { 0x01, 0x01, 0x01, 0x01, 0x08, 0x01, 0x01, 0x01 },
1685            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1686            { 0x81, 0x81, 0xB6, 0x5B, 0xAB, 0xF4, 0xA9, 0x75 } },
1687          { { 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x01, 0x01 },
1688            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1689            { 0x93, 0xC9, 0xB6, 0x40, 0x42, 0xEA, 0xA2, 0x40 } },
1690          { { 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01 },
1691            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1692            { 0x55, 0x70, 0x53, 0x08, 0x29, 0x70, 0x55, 0x92 } },
1693          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x80, 0x01, 0x01 },
1694            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1695            { 0x86, 0x38, 0x80, 0x9E, 0x87, 0x87, 0x87, 0xA0 } },
1696          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x40, 0x01, 0x01 },
1697            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1698            { 0x41, 0xB9, 0xA7, 0x9A, 0xF7, 0x9A, 0xC2, 0x08 } },
1699          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x20, 0x01, 0x01 },
1700            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1701            { 0x7A, 0x9B, 0xE4, 0x2F, 0x20, 0x09, 0xA8, 0x92 } },
1702          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x10, 0x01, 0x01 },
1703            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1704            { 0x29, 0x03, 0x8D, 0x56, 0xBA, 0x6D, 0x27, 0x45 } },
1705          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x08, 0x01, 0x01 },
1706            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1707            { 0x54, 0x95, 0xC6, 0xAB, 0xF1, 0xE5, 0xDF, 0x51 } },
1708          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x01 },
1709            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1710            { 0xAE, 0x13, 0xDB, 0xD5, 0x61, 0x48, 0x89, 0x33 } },
1711          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01 },
1712            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1713            { 0x02, 0x4D, 0x1F, 0xFA, 0x89, 0x04, 0xE3, 0x89 } },
1714          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x80, 0x01 },
1715            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1716            { 0xD1, 0x39, 0x97, 0x12, 0xF9, 0x9B, 0xF0, 0x2E } },
1717          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x40, 0x01 },
1718            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1719            { 0x14, 0xC1, 0xD7, 0xC1, 0xCF, 0xFE, 0xC7, 0x9E } },
1720          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x20, 0x01 },
1721            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1722            { 0x1D, 0xE5, 0x27, 0x9D, 0xAE, 0x3B, 0xED, 0x6F } },
1723          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x10, 0x01 },
1724            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1725            { 0xE9, 0x41, 0xA3, 0x3F, 0x85, 0x50, 0x13, 0x03 } },
1726          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x08, 0x01 },
1727            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1728            { 0xDA, 0x99, 0xDB, 0xBC, 0x9A, 0x03, 0xF3, 0x79 } },
1729          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01 },
1730            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1731            { 0xB7, 0xFC, 0x92, 0xF9, 0x1D, 0x8E, 0x92, 0xE9 } },
1732          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01 },
1733            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1734            { 0xAE, 0x8E, 0x5C, 0xAA, 0x3C, 0xA0, 0x4E, 0x85 } },
1735          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x80 },
1736            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1737            { 0x9C, 0xC6, 0x2D, 0xF4, 0x3B, 0x6E, 0xED, 0x74 } },
1738          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x40 },
1739            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1740            { 0xD8, 0x63, 0xDB, 0xB5, 0xC5, 0x9A, 0x91, 0xA0 } },
1741          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x20 },
1742            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1743            { 0xA1, 0xAB, 0x21, 0x90, 0x54, 0x5B, 0x91, 0xD7 } },
1744          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x10 },
1745            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1746            { 0x08, 0x75, 0x04, 0x1E, 0x64, 0xC5, 0x70, 0xF7 } },
1747          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x08 },
1748            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1749            { 0x5A, 0x59, 0x45, 0x28, 0xBE, 0xBE, 0xF1, 0xCC } },
1750          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04 },
1751            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1752            { 0xFC, 0xDB, 0x32, 0x91, 0xDE, 0x21, 0xF0, 0xC0 } },
1753          { { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02 },
1754            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1755            { 0x86, 0x9E, 0xFD, 0x7F, 0x9F, 0x26, 0x5A, 0x09 } },
1756      };
1757      unsigned char key[8], pt[8], ct[8], tmp[8];
1758      symmetric_key skey;
1759      int i, err;
1760      for (i = 0; i < (int)(sizeof(cases)/sizeof(cases[0])); i++)
1761      {
1762          if ((err = des_setup(cases[i].key, 8, 0, &skey)) != CRYPT_OK) {
1763              return err;
1764          }
1765          des_ecb_encrypt(cases[i].txt, ct, &skey);
1766          if (compare_testvector(ct, sizeof(ct), cases[i].out, 8, "DES Encrypt", i) != 0) {
1767              return CRYPT_FAIL_TESTVECTOR;
1768          }
1769          des_ecb_decrypt(ct, pt, &skey);
1770          if (compare_testvector(pt, sizeof(pt), cases[i].txt, 8, "DES Decrypt", i) != 0) {
1771              return CRYPT_FAIL_TESTVECTOR;
1772          }
1773      }
1774      for (i = 0; i < 8; i++) key[i] = i;
1775      if ((err = des_setup(key, 8, 0, &skey)) != CRYPT_OK) {
1776          return err;
1777      }
1778      for (i = 0; i < 8; i++) pt[i] = tmp[i] = 0;
1779      for (i = 0; i < 1000; i++) des_ecb_encrypt(tmp, tmp, &skey);
1780      for (i = 0; i < 1000; i++) des_ecb_decrypt(tmp, tmp, &skey);
1781      if (compare_testvector(tmp, 8, pt, 8, "DES", 0) != 0) {
1782          return CRYPT_FAIL_TESTVECTOR;
1783      }
1784      return CRYPT_OK;
1785    #endif
1786  }
1787  int des3_test(void)
1788  {
1789   #ifndef LTC_TEST
1790      return CRYPT_NOP;
1791   #else
1792      static const struct des3_test_case {
1793          unsigned char key[16], txt[8], out[8];
1794      } cases[] = {
1795          { { 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1796            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1797            { 0xFA, 0xFD, 0x50, 0x84, 0x37, 0x4F, 0xCE, 0x34 } },
1798          { { 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1799            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1800            { 0x60, 0xCC, 0x37, 0xB7, 0xB5, 0x37, 0xA1, 0xDC } },
1801          { { 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1802            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
1803            { 0xBE, 0x3E, 0x73, 0x04, 0xFE, 0x92, 0xC2, 0xBC } },
1804          { { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00 },
1805            { 0xE5, 0xA9, 0xE3, 0x80, 0x03, 0xA5, 0xA0, 0xFD },
1806            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } },
1807          { { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F },
1808            { 0xE4, 0xFC, 0x19, 0xD6, 0x94, 0x63, 0xB7, 0x83 },
1809            { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77 } },
1810      };
1811      unsigned char key[24], pt[8], ct[8], tmp[8];
1812      symmetric_key skey;
1813      int i, err;
1814      if ((err = des_test()) != CRYPT_OK) {
1815          return err;
1816      }
1817      for (i = 0; i < (int)(sizeof(cases)/sizeof(cases[0])); i++)
1818      {
1819          if ((err = des3_setup(cases[i].key, 16, 0, &skey)) != CRYPT_OK) {
1820              return err;
1821          }
1822          des3_ecb_encrypt(cases[i].txt, ct, &skey);
1823          if (compare_testvector(ct, sizeof(ct), cases[i].out, 8, "3DES Encrypt", i) != 0) {
1824              return CRYPT_FAIL_TESTVECTOR;
1825          }
1826          des3_ecb_decrypt(ct, pt, &skey);
1827          if (compare_testvector(pt, sizeof(pt), cases[i].txt, 8, "3DES Decrypt", i) != 0) {
1828              return CRYPT_FAIL_TESTVECTOR;
1829          }
1830      }
1831      for (i = 0; i < 24; i++) key[i] = i;
1832      if ((err = des3_setup(key, 24, 0, &skey)) != CRYPT_OK) {
1833          return err;
1834      }
1835      for (i = 0; i < 8; i++) pt[i] = tmp[i] = 0;
1836      for (i = 0; i < 1000; i++) des3_ecb_encrypt(tmp, tmp, &skey);
1837      for (i = 0; i < 1000; i++) des3_ecb_decrypt(tmp, tmp, &skey);
1838      if (compare_testvector(tmp, 8, pt, 8, "3DES", 0) != 0) {
1839          return CRYPT_FAIL_TESTVECTOR;
1840      }
1841      return CRYPT_OK;
1842   #endif
1843  }
1844  void des_done(symmetric_key *skey)
1845  {
1846    LTC_UNUSED_PARAM(skey);
1847  }
1848  void des3_done(symmetric_key *skey)
1849  {
1850    LTC_UNUSED_PARAM(skey);
1851  }
1852  int des_keysize(int *keysize)
1853  {
1854      LTC_ARGCHK(keysize != NULL);
1855      if(*keysize < 8) {
1856          return CRYPT_INVALID_KEYSIZE;
1857      }
1858      *keysize = 8;
1859      return CRYPT_OK;
1860  }
1861  int des3_keysize(int *keysize)
1862  {
1863      LTC_ARGCHK(keysize != NULL);
1864      if (*keysize < 16) {
1865         return CRYPT_INVALID_KEYSIZE;
1866      }
1867      if (*keysize < 24) {
1868         *keysize = 16;
1869         return CRYPT_OK;
1870      }
1871      *keysize = 24;
1872      return CRYPT_OK;
1873  }
1874  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-jemalloc.c</h3>
            <pre><code>1  #define JEMALLOC_C_
2  #include "jemalloc/internal/jemalloc_preamble.h"
3  #include "jemalloc/internal/jemalloc_internal_includes.h"
4  #include "jemalloc/internal/assert.h"
5  #include "jemalloc/internal/atomic.h"
6  #include "jemalloc/internal/ctl.h"
7  #include "jemalloc/internal/extent_dss.h"
8  #include "jemalloc/internal/extent_mmap.h"
9  #include "jemalloc/internal/hook.h"
10  #include "jemalloc/internal/jemalloc_internal_types.h"
11  #include "jemalloc/internal/log.h"
12  #include "jemalloc/internal/malloc_io.h"
13  #include "jemalloc/internal/mutex.h"
14  #include "jemalloc/internal/rtree.h"
15  #include "jemalloc/internal/safety_check.h"
16  #include "jemalloc/internal/sc.h"
17  #include "jemalloc/internal/spin.h"
18  #include "jemalloc/internal/sz.h"
19  #include "jemalloc/internal/ticker.h"
20  #include "jemalloc/internal/util.h"
21  const char	*je_malloc_conf
22  #ifndef _WIN32
23      JEMALLOC_ATTR(weak)
24  #endif
25      ;
26  bool	opt_abort =
27  #ifdef JEMALLOC_DEBUG
28      true
29  #else
30      false
31  #endif
32      ;
33  bool	opt_abort_conf =
34  #ifdef JEMALLOC_DEBUG
35      true
36  #else
37      false
38  #endif
39      ;
40  bool	opt_confirm_conf = false;
41  const char	*opt_junk =
42  #if (defined(JEMALLOC_DEBUG) && defined(JEMALLOC_FILL))
43      "true"
44  #else
45      "false"
46  #endif
47      ;
48  bool	opt_junk_alloc =
49  #if (defined(JEMALLOC_DEBUG) && defined(JEMALLOC_FILL))
50      true
51  #else
52      false
53  #endif
54      ;
55  bool	opt_junk_free =
56  #if (defined(JEMALLOC_DEBUG) && defined(JEMALLOC_FILL))
57      true
58  #else
59      false
60  #endif
61      ;
62  bool	opt_utrace = false;
63  bool	opt_xmalloc = false;
64  bool	opt_zero = false;
65  unsigned	opt_narenas = 0;
66  unsigned	ncpus;
67  malloc_mutex_t arenas_lock;
68  JEMALLOC_ALIGNED(CACHELINE)
69  atomic_p_t		arenas[MALLOCX_ARENA_LIMIT];
70  static atomic_u_t	narenas_total; &bsol;* Use narenas_total_*(). */
71  static arena_t		*a0; &bsol;* arenas[0]. */
72  unsigned		narenas_auto;
73  unsigned		manual_arena_base;
74  typedef enum {
75  	malloc_init_uninitialized	= 3,
76  	malloc_init_a0_initialized	= 2,
77  	malloc_init_recursible		= 1,
78  	malloc_init_initialized		= 0 &bsol;* Common case --> jnz. */
79  } malloc_init_t;
80  static malloc_init_t	malloc_init_state = malloc_init_uninitialized;
81  bool			malloc_slow = true;
82  enum {
83  	flag_opt_junk_alloc	= (1U),
84  	flag_opt_junk_free	= (1U << 1),
85  	flag_opt_zero		= (1U << 2),
86  	flag_opt_utrace		= (1U << 3),
87  	flag_opt_xmalloc	= (1U << 4)
88  };
89  static uint8_t	malloc_slow_flags;
90  #ifdef JEMALLOC_THREADED_INIT
91  #  define NO_INITIALIZER	((unsigned long)0)
92  #  define INITIALIZER		pthread_self()
93  #  define IS_INITIALIZER	(malloc_initializer == pthread_self())
94  static pthread_t		malloc_initializer = NO_INITIALIZER;
95  #else
96  #  define NO_INITIALIZER	false
97  #  define INITIALIZER		true
98  #  define IS_INITIALIZER	malloc_initializer
99  static bool			malloc_initializer = NO_INITIALIZER;
100  #endif
101  #ifdef _WIN32
102  #if _WIN32_WINNT >= 0x0600
103  static malloc_mutex_t	init_lock = SRWLOCK_INIT;
104  #else
105  static malloc_mutex_t	init_lock;
106  static bool init_lock_initialized = false;
107  JEMALLOC_ATTR(constructor)
108  static void WINAPI
109  _init_init_lock(void) {
110  	if (!init_lock_initialized) {
111  		malloc_mutex_init(&init_lock, "init", WITNESS_RANK_INIT,
112  		    malloc_mutex_rank_exclusive);
113  	}
114  	init_lock_initialized = true;
115  }
116  #ifdef _MSC_VER
117  #  pragma section(".CRT$XCU", read)
118  JEMALLOC_SECTION(".CRT$XCU") JEMALLOC_ATTR(used)
119  static const void (WINAPI *init_init_lock)(void) = _init_init_lock;
120  #endif
121  #endif
122  #else
123  static malloc_mutex_t	init_lock = MALLOC_MUTEX_INITIALIZER;
124  #endif
125  typedef struct {
126  	void	*p;	&bsol;* Input pointer (as in realloc(p, s)). */
127  	size_t	s;	&bsol;* Request size. */
128  	void	*r;	&bsol;* Result pointer. */
129  } malloc_utrace_t;
130  #ifdef JEMALLOC_UTRACE
131  #  define UTRACE(a, b, c) do {						\
132  	if (unlikely(opt_utrace)) {					\
133  		int utrace_serrno = errno;				\
134  		malloc_utrace_t ut;					\
135  		ut.p = (a);						\
136  		ut.s = (b);						\
137  		ut.r = (c);						\
138  		utrace(&ut, sizeof(ut));				\
139  		errno = utrace_serrno;					\
140  	}								\
141  } while (0)
142  #else
143  #  define UTRACE(a, b, c)
144  #endif
145  static bool had_conf_error = false;
146  static bool	malloc_init_hard_a0(void);
147  static bool	malloc_init_hard(void);
148  bool
149  malloc_initialized(void) {
150  	return (malloc_init_state == malloc_init_initialized);
151  }
152  JEMALLOC_ALWAYS_INLINE bool
153  malloc_init_a0(void) {
154  	if (unlikely(malloc_init_state == malloc_init_uninitialized)) {
155  		return malloc_init_hard_a0();
156  	}
157  	return false;
158  }
159  JEMALLOC_ALWAYS_INLINE bool
160  malloc_init(void) {
161  	if (unlikely(!malloc_initialized()) && malloc_init_hard()) {
162  		return true;
163  	}
164  	return false;
165  }
166  static void *
167  a0ialloc(size_t size, bool zero, bool is_internal) {
168  	if (unlikely(malloc_init_a0())) {
169  		return NULL;
170  	}
171  	return iallocztm(TSDN_NULL, size, sz_size2index(size), zero, NULL,
172  	    is_internal, arena_get(TSDN_NULL, 0, true), true);
173  }
174  static void
175  a0idalloc(void *ptr, bool is_internal) {
176  	idalloctm(TSDN_NULL, ptr, NULL, NULL, is_internal, true);
177  }
178  void *
179  a0malloc(size_t size) {
180  	return a0ialloc(size, false, true);
181  }
182  void
183  a0dalloc(void *ptr) {
184  	a0idalloc(ptr, true);
185  }
186  void *
187  bootstrap_malloc(size_t size) {
188  	if (unlikely(size == 0)) {
189  		size = 1;
190  	}
191  	return a0ialloc(size, false, false);
192  }
193  void *
194  bootstrap_calloc(size_t num, size_t size) {
195  	size_t num_size;
196  	num_size = num * size;
197  	if (unlikely(num_size == 0)) {
198  		assert(num == 0 || size == 0);
199  		num_size = 1;
200  	}
201  	return a0ialloc(num_size, true, false);
202  }
203  void
204  bootstrap_free(void *ptr) {
205  	if (unlikely(ptr == NULL)) {
206  		return;
207  	}
208  	a0idalloc(ptr, false);
209  }
210  void
211  arena_set(unsigned ind, arena_t *arena) {
212  	atomic_store_p(&arenas[ind], arena, ATOMIC_RELEASE);
213  }
214  static void
215  narenas_total_set(unsigned narenas) {
216  	atomic_store_u(&narenas_total, narenas, ATOMIC_RELEASE);
217  }
218  static void
219  narenas_total_inc(void) {
220  	atomic_fetch_add_u(&narenas_total, 1, ATOMIC_RELEASE);
221  }
222  unsigned
223  narenas_total_get(void) {
224  	return atomic_load_u(&narenas_total, ATOMIC_ACQUIRE);
225  }
226  static arena_t *
227  arena_init_locked(tsdn_t *tsdn, unsigned ind, extent_hooks_t *extent_hooks) {
228  	arena_t *arena;
229  	assert(ind <= narenas_total_get());
230  	if (ind >= MALLOCX_ARENA_LIMIT) {
231  		return NULL;
232  	}
233  	if (ind == narenas_total_get()) {
234  		narenas_total_inc();
235  	}
236  	arena = arena_get(tsdn, ind, false);
237  	if (arena != NULL) {
238  		assert(arena_is_auto(arena));
239  		return arena;
240  	}
241  	arena = arena_new(tsdn, ind, extent_hooks);
242  	return arena;
243  }
244  static void
245  arena_new_create_background_thread(tsdn_t *tsdn, unsigned ind) {
246  	if (ind == 0) {
247  		return;
248  	}
249  	if (have_background_thread && !arena_is_huge(ind)) {
250  		if (background_thread_create(tsdn_tsd(tsdn), ind)) {
251  			malloc_printf("<jemalloc>: error in background thread "
252  				      "creation for arena %u. Abort.\n", ind);
253  			abort();
254  		}
255  	}
256  }
257  arena_t *
258  arena_init(tsdn_t *tsdn, unsigned ind, extent_hooks_t *extent_hooks) {
259  	arena_t *arena;
260  	malloc_mutex_lock(tsdn, &arenas_lock);
261  	arena = arena_init_locked(tsdn, ind, extent_hooks);
262  	malloc_mutex_unlock(tsdn, &arenas_lock);
263  	arena_new_create_background_thread(tsdn, ind);
264  	return arena;
265  }
266  static void
267  arena_bind(tsd_t *tsd, unsigned ind, bool internal) {
268  	arena_t *arena = arena_get(tsd_tsdn(tsd), ind, false);
269  	arena_nthreads_inc(arena, internal);
270  	if (internal) {
271  		tsd_iarena_set(tsd, arena);
272  	} else {
273  		tsd_arena_set(tsd, arena);
274  		unsigned shard = atomic_fetch_add_u(&arena->binshard_next, 1,
275  		    ATOMIC_RELAXED);
276  		tsd_binshards_t *bins = tsd_binshardsp_get(tsd);
277  		for (unsigned i = 0; i < SC_NBINS; i++) {
278  			assert(bin_infos[i].n_shards > 0 &&
279  			    bin_infos[i].n_shards <= BIN_SHARDS_MAX);
280  			bins->binshard[i] = shard % bin_infos[i].n_shards;
281  		}
282  	}
283  }
284  void
285  arena_migrate(tsd_t *tsd, unsigned oldind, unsigned newind) {
286  	arena_t *oldarena, *newarena;
287  	oldarena = arena_get(tsd_tsdn(tsd), oldind, false);
288  	newarena = arena_get(tsd_tsdn(tsd), newind, false);
289  	arena_nthreads_dec(oldarena, false);
290  	arena_nthreads_inc(newarena, false);
291  	tsd_arena_set(tsd, newarena);
292  }
293  static void
294  arena_unbind(tsd_t *tsd, unsigned ind, bool internal) {
295  	arena_t *arena;
296  	arena = arena_get(tsd_tsdn(tsd), ind, false);
297  	arena_nthreads_dec(arena, internal);
298  	if (internal) {
299  		tsd_iarena_set(tsd, NULL);
300  	} else {
301  		tsd_arena_set(tsd, NULL);
302  	}
303  }
304  arena_tdata_t *
305  arena_tdata_get_hard(tsd_t *tsd, unsigned ind) {
306  	arena_tdata_t *tdata, *arenas_tdata_old;
307  	arena_tdata_t *arenas_tdata = tsd_arenas_tdata_get(tsd);
308  	unsigned narenas_tdata_old, i;
309  	unsigned narenas_tdata = tsd_narenas_tdata_get(tsd);
310  	unsigned narenas_actual = narenas_total_get();
311  	if (arenas_tdata != NULL && narenas_tdata < narenas_actual) {
312  		arenas_tdata_old = arenas_tdata;
313  		narenas_tdata_old = narenas_tdata;
314  		arenas_tdata = NULL;
315  		narenas_tdata = 0;
316  		tsd_arenas_tdata_set(tsd, arenas_tdata);
317  		tsd_narenas_tdata_set(tsd, narenas_tdata);
318  	} else {
319  		arenas_tdata_old = NULL;
320  		narenas_tdata_old = 0;
321  	}
322  	if (arenas_tdata == NULL) {
323  		bool *arenas_tdata_bypassp = tsd_arenas_tdata_bypassp_get(tsd);
324  		narenas_tdata = (ind < narenas_actual) ? narenas_actual : ind+1;
325  		if (tsd_nominal(tsd) && !*arenas_tdata_bypassp) {
326  			*arenas_tdata_bypassp = true;
327  			arenas_tdata = (arena_tdata_t *)a0malloc(
328  			    sizeof(arena_tdata_t) * narenas_tdata);
329  			*arenas_tdata_bypassp = false;
330  		}
331  		if (arenas_tdata == NULL) {
332  			tdata = NULL;
333  			goto label_return;
334  		}
335  		assert(tsd_nominal(tsd) && !*arenas_tdata_bypassp);
336  		tsd_arenas_tdata_set(tsd, arenas_tdata);
337  		tsd_narenas_tdata_set(tsd, narenas_tdata);
338  	}
339  	for (i = 0; i < narenas_actual; i++) {
340  		if (i < narenas_tdata_old) {
341  			ticker_copy(&arenas_tdata[i].decay_ticker,
342  			    &arenas_tdata_old[i].decay_ticker);
343  		} else {
344  			ticker_init(&arenas_tdata[i].decay_ticker,
345  			    DECAY_NTICKS_PER_UPDATE);
346  		}
347  	}
348  	if (narenas_tdata > narenas_actual) {
349  		memset(&arenas_tdata[narenas_actual], 0, sizeof(arena_tdata_t)
350  		    * (narenas_tdata - narenas_actual));
351  	}
352  	tdata = &arenas_tdata[ind];
353  label_return:
354  	if (arenas_tdata_old != NULL) {
355  		a0dalloc(arenas_tdata_old);
356  	}
357  	return tdata;
358  }
359  arena_t *
360  arena_choose_hard(tsd_t *tsd, bool internal) {
361  	arena_t *ret JEMALLOC_CC_SILENCE_INIT(NULL);
362  	if (have_percpu_arena && PERCPU_ARENA_ENABLED(opt_percpu_arena)) {
363  		unsigned choose = percpu_arena_choose();
364  		ret = arena_get(tsd_tsdn(tsd), choose, true);
365  		assert(ret != NULL);
366  		arena_bind(tsd, arena_ind_get(ret), false);
367  		arena_bind(tsd, arena_ind_get(ret), true);
368  		return ret;
369  	}
370  	if (narenas_auto > 1) {
371  		unsigned i, j, choose[2], first_null;
372  		bool is_new_arena[2];
373  		for (j = 0; j < 2; j++) {
374  			choose[j] = 0;
375  			is_new_arena[j] = false;
376  		}
377  		first_null = narenas_auto;
378  		malloc_mutex_lock(tsd_tsdn(tsd), &arenas_lock);
379  		assert(arena_get(tsd_tsdn(tsd), 0, false) != NULL);
380  		for (i = 1; i < narenas_auto; i++) {
381  			if (arena_get(tsd_tsdn(tsd), i, false) != NULL) {
382  				for (j = 0; j < 2; j++) {
383  					if (arena_nthreads_get(arena_get(
384  					    tsd_tsdn(tsd), i, false), !!j) <
385  					    arena_nthreads_get(arena_get(
386  					    tsd_tsdn(tsd), choose[j], false),
387  					    !!j)) {
388  						choose[j] = i;
389  					}
390  				}
391  			} else if (first_null == narenas_auto) {
392  				first_null = i;
393  			}
394  		}
395  		for (j = 0; j < 2; j++) {
396  			if (arena_nthreads_get(arena_get(tsd_tsdn(tsd),
397  			    choose[j], false), !!j) == 0 || first_null ==
398  			    narenas_auto) {
399  				if (!!j == internal) {
400  					ret = arena_get(tsd_tsdn(tsd),
401  					    choose[j], false);
402  				}
403  			} else {
404  				arena_t *arena;
405  				choose[j] = first_null;
406  				arena = arena_init_locked(tsd_tsdn(tsd),
407  				    choose[j],
408  				    (extent_hooks_t *)&extent_hooks_default);
409  				if (arena == NULL) {
410  					malloc_mutex_unlock(tsd_tsdn(tsd),
411  					    &arenas_lock);
412  					return NULL;
413  				}
414  				is_new_arena[j] = true;
415  				if (!!j == internal) {
416  					ret = arena;
417  				}
418  			}
419  			arena_bind(tsd, choose[j], !!j);
420  		}
421  		malloc_mutex_unlock(tsd_tsdn(tsd), &arenas_lock);
422  		for (j = 0; j < 2; j++) {
423  			if (is_new_arena[j]) {
424  				assert(choose[j] > 0);
425  				arena_new_create_background_thread(
426  				    tsd_tsdn(tsd), choose[j]);
427  			}
428  		}
429  	} else {
430  		ret = arena_get(tsd_tsdn(tsd), 0, false);
431  		arena_bind(tsd, 0, false);
432  		arena_bind(tsd, 0, true);
433  	}
434  	return ret;
435  }
436  void
437  iarena_cleanup(tsd_t *tsd) {
438  	arena_t *iarena;
439  	iarena = tsd_iarena_get(tsd);
440  	if (iarena != NULL) {
441  		arena_unbind(tsd, arena_ind_get(iarena), true);
442  	}
443  }
444  void
445  arena_cleanup(tsd_t *tsd) {
446  	arena_t *arena;
447  	arena = tsd_arena_get(tsd);
448  	if (arena != NULL) {
449  		arena_unbind(tsd, arena_ind_get(arena), false);
450  	}
451  }
452  void
453  arenas_tdata_cleanup(tsd_t *tsd) {
454  	arena_tdata_t *arenas_tdata;
455  	*tsd_arenas_tdata_bypassp_get(tsd) = true;
456  	arenas_tdata = tsd_arenas_tdata_get(tsd);
457  	if (arenas_tdata != NULL) {
458  		tsd_arenas_tdata_set(tsd, NULL);
459  		a0dalloc(arenas_tdata);
460  	}
461  }
462  static void
463  stats_print_atexit(void) {
464  	if (config_stats) {
465  		tsdn_t *tsdn;
466  		unsigned narenas, i;
467  		tsdn = tsdn_fetch();
468  		for (i = 0, narenas = narenas_total_get(); i < narenas; i++) {
469  			arena_t *arena = arena_get(tsdn, i, false);
470  			if (arena != NULL) {
471  				tcache_t *tcache;
472  				malloc_mutex_lock(tsdn, &arena->tcache_ql_mtx);
473  				ql_foreach(tcache, &arena->tcache_ql, link) {
474  					tcache_stats_merge(tsdn, tcache, arena);
475  				}
476  				malloc_mutex_unlock(tsdn,
477  				    &arena->tcache_ql_mtx);
478  			}
479  		}
480  	}
481  	je_malloc_stats_print(NULL, NULL, opt_stats_print_opts);
482  }
483  JEMALLOC_ALWAYS_INLINE void
484  check_entry_exit_locking(tsdn_t *tsdn) {
485  	if (!config_debug) {
486  		return;
487  	}
488  	if (tsdn_null(tsdn)) {
489  		return;
490  	}
491  	tsd_t *tsd = tsdn_tsd(tsdn);
492  	int8_t reentrancy_level = tsd_reentrancy_level_get(tsd);
493  	if (reentrancy_level != 0) {
494  		return;
495  	}
496  	witness_assert_lockless(tsdn_witness_tsdp_get(tsdn));
497  }
498  static char *
499  jemalloc_secure_getenv(const char *name) {
500  #ifdef JEMALLOC_HAVE_SECURE_GETENV
501  	return secure_getenv(name);
502  #else
503  #  ifdef JEMALLOC_HAVE_ISSETUGID
504  	if (issetugid() != 0) {
505  		return NULL;
506  	}
507  #  endif
508  	return getenv(name);
509  #endif
510  }
511  static unsigned
512  malloc_ncpus(void) {
513  	long result;
514  #ifdef _WIN32
515  	SYSTEM_INFO si;
516  	GetSystemInfo(&si);
517  	result = si.dwNumberOfProcessors;
518  #elif defined(JEMALLOC_GLIBC_MALLOC_HOOK) && defined(CPU_COUNT)
519  	{
520  		cpu_set_t set;
521  		pthread_getaffinity_np(pthread_self(), sizeof(set), &set);
522  		result = CPU_COUNT(&set);
523  	}
524  #else
525  	result = sysconf(_SC_NPROCESSORS_ONLN);
526  #endif
527  	return ((result == -1) ? 1 : (unsigned)result);
528  }
529  static void
530  init_opt_stats_print_opts(const char *v, size_t vlen) {
531  	size_t opts_len = strlen(opt_stats_print_opts);
532  	assert(opts_len <= stats_print_tot_num_options);
533  	for (size_t i = 0; i < vlen; i++) {
534  		switch (v[i]) {
535  #define OPTION(o, v, d, s) case o: break;
536  			STATS_PRINT_OPTIONS
537  #undef OPTION
538  		default: continue;
539  		}
540  		if (strchr(opt_stats_print_opts, v[i]) != NULL) {
541  			continue;
542  		}
543  		opt_stats_print_opts[opts_len++] = v[i];
544  		opt_stats_print_opts[opts_len] = '\0';
545  		assert(opts_len <= stats_print_tot_num_options);
546  	}
547  	assert(opts_len == strlen(opt_stats_print_opts));
548  }
549  static bool
550  malloc_conf_multi_sizes_next(const char **slab_size_segment_cur,
551      size_t *vlen_left, size_t *slab_start, size_t *slab_end, size_t *new_size) {
552  	const char *cur = *slab_size_segment_cur;
553  	char *end;
554  	uintmax_t um;
555  	set_errno(0);
556  	um = malloc_strtoumax(cur, &end, 0);
557  	if (get_errno() != 0 || *end != '-') {
558  		return true;
559  	}
560  	*slab_start = (size_t)um;
561  	cur = end + 1;
562  	um = malloc_strtoumax(cur, &end, 0);
563  	if (get_errno() != 0 || *end != ':') {
564  		return true;
565  	}
566  	*slab_end = (size_t)um;
567  	cur = end + 1;
568  	um = malloc_strtoumax(cur, &end, 0);
569  	if (get_errno() != 0) {
570  		return true;
571  	}
572  	*new_size = (size_t)um;
573  	if (*end == '|') {
574  		end++;
575  	}
576  	*vlen_left -= end - *slab_size_segment_cur;
577  	*slab_size_segment_cur = end;
578  	return false;
579  }
580  static bool
581  malloc_conf_next(char const **opts_p, char const **k_p, size_t *klen_p,
582      char const **v_p, size_t *vlen_p) {
583  	bool accept;
584  	const char *opts = *opts_p;
585  	*k_p = opts;
586  	for (accept = false; !accept;) {
587  		switch (*opts) {
588  		case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
589  		case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':
590  		case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':
591  		case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':
592  		case 'Y': case 'Z':
593  		case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
594  		case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':
595  		case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':
596  		case 's': case 't': case 'u': case 'v': case 'w': case 'x':
597  		case 'y': case 'z':
598  		case '0': case '1': case '2': case '3': case '4': case '5':
599  		case '6': case '7': case '8': case '9':
600  		case '_':
601  			opts++;
602  			break;
603  		case ':':
604  			opts++;
605  			*klen_p = (uintptr_t)opts - 1 - (uintptr_t)*k_p;
606  			*v_p = opts;
607  			accept = true;
608  			break;
609  		case '\0':
610  			if (opts != *opts_p) {
611  				malloc_write("<jemalloc>: Conf string ends "
612  				    "with key\n");
613  			}
614  			return true;
615  		default:
616  			malloc_write("<jemalloc>: Malformed conf string\n");
617  			return true;
618  		}
619  	}
620  	for (accept = false; !accept;) {
621  		switch (*opts) {
622  		case ',':
623  			opts++;
624  			if (*opts == '\0') {
625  				malloc_write("<jemalloc>: Conf string ends "
626  				    "with comma\n");
627  			}
628  			*vlen_p = (uintptr_t)opts - 1 - (uintptr_t)*v_p;
629  			accept = true;
630  			break;
631  		case '\0':
632  			*vlen_p = (uintptr_t)opts - (uintptr_t)*v_p;
633  			accept = true;
634  			break;
635  		default:
636  			opts++;
637  			break;
638  		}
639  	}
640  	*opts_p = opts;
641  	return false;
642  }
643  static void
644  malloc_abort_invalid_conf(void) {
645  	assert(opt_abort_conf);
646  	malloc_printf("<jemalloc>: Abort (abort_conf:true) on invalid conf "
647  	    "value (see above).\n");
648  	abort();
649  }
650  static void
651  malloc_conf_error(const char *msg, const char *k, size_t klen, const char *v,
652      size_t vlen) {
653  	malloc_printf("<jemalloc>: %s: %.*s:%.*s\n", msg, (int)klen, k,
654  	    (int)vlen, v);
655  	const char *experimental = "experimental_";
656  	if (strncmp(k, experimental, strlen(experimental)) == 0) {
657  		return;
658  	}
659  	had_conf_error = true;
660  }
661  static void
662  malloc_slow_flag_init(void) {
663  	malloc_slow_flags |= (opt_junk_alloc ? flag_opt_junk_alloc : 0)
664  	    | (opt_junk_free ? flag_opt_junk_free : 0)
665  	    | (opt_zero ? flag_opt_zero : 0)
666  	    | (opt_utrace ? flag_opt_utrace : 0)
667  	    | (opt_xmalloc ? flag_opt_xmalloc : 0);
668  	malloc_slow = (malloc_slow_flags != 0);
669  }
670  #define MALLOC_CONF_NSOURCES 4
671  static const char *
672  obtain_malloc_conf(unsigned which_source, char buf[PATH_MAX + 1]) {
673  	if (config_debug) {
674  		static unsigned read_source = 0;
675  		assert(read_source++ == which_source);
676  	}
677  	assert(which_source < MALLOC_CONF_NSOURCES);
678  	const char *ret;
679  	switch (which_source) {
680  	case 0:
681  		ret = config_malloc_conf;
682  		break;
683  	case 1:
684  		if (je_malloc_conf != NULL) {
685  			ret = je_malloc_conf;
686  		} else {
687  			ret = NULL;
688  		}
689  		break;
690  	case 2: {
691  		ssize_t linklen = 0;
692  #ifndef _WIN32
693  		int saved_errno = errno;
694  		const char *linkname =
695  #  ifdef JEMALLOC_PREFIX
696  		    "/etc/"JEMALLOC_PREFIX"malloc.conf"
697  #  else
698  		    "/etc/malloc.conf"
699  #  endif
700  		    ;
701  #ifndef JEMALLOC_READLINKAT
702  		linklen = readlink(linkname, buf, PATH_MAX);
703  #else
704  		linklen = readlinkat(AT_FDCWD, linkname, buf, PATH_MAX);
705  #endif
706  		if (linklen == -1) {
707  			linklen = 0;
708  			set_errno(saved_errno);
709  		}
710  #endif
711  		buf[linklen] = '\0';
712  		ret = buf;
713  		break;
714  	} case 3: {
715  		const char *envname =
716  #ifdef JEMALLOC_PREFIX
717  		    JEMALLOC_CPREFIX"MALLOC_CONF"
718  #else
719  		    "MALLOC_CONF"
720  #endif
721  		    ;
722  		if ((ret = jemalloc_secure_getenv(envname)) != NULL) {
723  		} else {
724  			ret = NULL;
725  		}
726  		break;
727  	} default:
728  		not_reached();
729  		ret = NULL;
730  	}
731  	return ret;
732  }
733  static void
734  malloc_conf_init_helper(sc_data_t *sc_data, unsigned bin_shard_sizes[SC_NBINS],
735      bool initial_call, const char *opts_cache[MALLOC_CONF_NSOURCES],
736      char buf[PATH_MAX + 1]) {
737  	static const char *opts_explain[MALLOC_CONF_NSOURCES] = {
738  		"string specified via --with-malloc-conf",
739  		"string pointed to by the global variable malloc_conf",
740  		"\"name\" of the file referenced by the symbolic link named "
741  		    "/etc/malloc.conf",
742  		"value of the environment variable MALLOC_CONF"
743  	};
744  	unsigned i;
745  	const char *opts, *k, *v;
746  	size_t klen, vlen;
747  	for (i = 0; i < MALLOC_CONF_NSOURCES; i++) {
748  		if (initial_call) {
749  			opts_cache[i] = obtain_malloc_conf(i, buf);
750  		}
751  		opts = opts_cache[i];
752  		if (!initial_call && opt_confirm_conf) {
753  			malloc_printf(
754  			    "<jemalloc>: malloc_conf #%u (%s): \"%s\"\n",
755  			    i + 1, opts_explain[i], opts != NULL ? opts : "");
756  		}
757  		if (opts == NULL) {
758  			continue;
759  		}
760  		while (*opts != '\0' && !malloc_conf_next(&opts, &k, &klen, &v,
761  		    &vlen)) {
762  #define CONF_ERROR(msg, k, klen, v, vlen)				\
763  			if (!initial_call) {				\
764  				malloc_conf_error(			\
765  				    msg, k, klen, v, vlen);		\
766  				cur_opt_valid = false;			\
767  			}
768  #define CONF_CONTINUE	{						\
769  				if (!initial_call && opt_confirm_conf	\
770  				    && cur_opt_valid) {			\
771  					malloc_printf("<jemalloc>: -- "	\
772  					    "Set conf value: %.*s:%.*s"	\
773  					    "\n", (int)klen, k,		\
774  					    (int)vlen, v);		\
775  				}					\
776  				continue;				\
777  			}
778  #define CONF_MATCH(n)							\
779  	(sizeof(n)-1 == klen && strncmp(n, k, klen) == 0)
780  #define CONF_MATCH_VALUE(n)						\
781  	(sizeof(n)-1 == vlen && strncmp(n, v, vlen) == 0)
782  #define CONF_HANDLE_BOOL(o, n)						\
783  			if (CONF_MATCH(n)) {				\
784  				if (CONF_MATCH_VALUE("true")) {		\
785  					o = true;			\
786  				} else if (CONF_MATCH_VALUE("false")) {	\
787  					o = false;			\
788  				} else {				\
789  					CONF_ERROR("Invalid conf value",\
790  					    k, klen, v, vlen);		\
791  				}					\
792  				CONF_CONTINUE;				\
793  			}
794        JEMALLOC_DIAGNOSTIC_PUSH
795        JEMALLOC_DIAGNOSTIC_IGNORE_TYPE_LIMITS
796  #define CONF_DONT_CHECK_MIN(um, min)	false
797  #define CONF_CHECK_MIN(um, min)	((um) < (min))
798  #define CONF_DONT_CHECK_MAX(um, max)	false
799  #define CONF_CHECK_MAX(um, max)	((um) > (max))
800  #define CONF_HANDLE_T_U(t, o, n, min, max, check_min, check_max, clip)	\
801  			if (CONF_MATCH(n)) {				\
802  				uintmax_t um;				\
803  				char *end;				\
804  									\
805  				set_errno(0);				\
806  				um = malloc_strtoumax(v, &end, 0);	\
807  				if (get_errno() != 0 || (uintptr_t)end -\
808  				    (uintptr_t)v != vlen) {		\
809  					CONF_ERROR("Invalid conf value",\
810  					    k, klen, v, vlen);		\
811  				} else if (clip) {			\
812  					if (check_min(um, (t)(min))) {	\
813  						o = (t)(min);		\
814  					} else if (			\
815  					    check_max(um, (t)(max))) {	\
816  						o = (t)(max);		\
817  					} else {			\
818  						o = (t)um;		\
819  					}				\
820  				} else {				\
821  					if (check_min(um, (t)(min)) ||	\
822  					    check_max(um, (t)(max))) {	\
823  						CONF_ERROR(		\
824  						    "Out-of-range "	\
825  						    "conf value",	\
826  						    k, klen, v, vlen);	\
827  					} else {			\
828  						o = (t)um;		\
829  					}				\
830  				}					\
831  				CONF_CONTINUE;				\
832  			}
833  #define CONF_HANDLE_UNSIGNED(o, n, min, max, check_min, check_max,	\
834      clip)								\
835  			CONF_HANDLE_T_U(unsigned, o, n, min, max,	\
836  			    check_min, check_max, clip)
837  #define CONF_HANDLE_SIZE_T(o, n, min, max, check_min, check_max, clip)	\
838  			CONF_HANDLE_T_U(size_t, o, n, min, max,		\
839  			    check_min, check_max, clip)
840  #define CONF_HANDLE_SSIZE_T(o, n, min, max)				\
841  			if (CONF_MATCH(n)) {				\
842  				long l;					\
843  				char *end;				\
844  									\
845  				set_errno(0);				\
846  				l = strtol(v, &end, 0);			\
847  				if (get_errno() != 0 || (uintptr_t)end -\
848  				    (uintptr_t)v != vlen) {		\
849  					CONF_ERROR("Invalid conf value",\
850  					    k, klen, v, vlen);		\
851  				} else if (l < (ssize_t)(min) || l >	\
852  				    (ssize_t)(max)) {			\
853  					CONF_ERROR(			\
854  					    "Out-of-range conf value",	\
855  					    k, klen, v, vlen);		\
856  				} else {				\
857  					o = l;				\
858  				}					\
859  				CONF_CONTINUE;				\
860  			}
861  #define CONF_HANDLE_CHAR_P(o, n, d)					\
862  			if (CONF_MATCH(n)) {				\
863  				size_t cpylen = (vlen <=		\
864  				    sizeof(o)-1) ? vlen :		\
865  				    sizeof(o)-1;			\
866  				strncpy(o, v, cpylen);			\
867  				o[cpylen] = '\0';			\
868  				CONF_CONTINUE;				\
869  			}
870  			bool cur_opt_valid = true;
871  			CONF_HANDLE_BOOL(opt_confirm_conf, "confirm_conf")
872  			if (initial_call) {
873  				continue;
874  			}
875  			CONF_HANDLE_BOOL(opt_abort, "abort")
876  			CONF_HANDLE_BOOL(opt_abort_conf, "abort_conf")
877  			if (strncmp("metadata_thp", k, klen) == 0) {
878  				int i;
879  				bool match = false;
880  				for (i = 0; i < metadata_thp_mode_limit; i++) {
881  					if (strncmp(metadata_thp_mode_names[i],
882  					    v, vlen) == 0) {
883  						opt_metadata_thp = i;
884  						match = true;
885  						break;
886  					}
887  				}
888  				if (!match) {
889  					CONF_ERROR("Invalid conf value",
890  					    k, klen, v, vlen);
891  				}
892  				CONF_CONTINUE;
893  			}
894  			CONF_HANDLE_BOOL(opt_retain, "retain")
895  			if (strncmp("dss", k, klen) == 0) {
896  				int i;
897  				bool match = false;
898  				for (i = 0; i < dss_prec_limit; i++) {
899  					if (strncmp(dss_prec_names[i], v, vlen)
900  					    == 0) {
901  						if (extent_dss_prec_set(i)) {
902  							CONF_ERROR(
903  							    "Error setting dss",
904  							    k, klen, v, vlen);
905  						} else {
906  							opt_dss =
907  							    dss_prec_names[i];
908  							match = true;
909  							break;
910  						}
911  					}
912  				}
913  				if (!match) {
914  					CONF_ERROR("Invalid conf value",
915  					    k, klen, v, vlen);
916  				}
917  				CONF_CONTINUE;
918  			}
919  			CONF_HANDLE_UNSIGNED(opt_narenas, "narenas", 1,
920  			    UINT_MAX, CONF_CHECK_MIN, CONF_DONT_CHECK_MAX,
921  			    false)
922  			if (CONF_MATCH("bin_shards")) {
923  				const char *bin_shards_segment_cur = v;
924  				size_t vlen_left = vlen;
925  				do {
926  					size_t size_start;
927  					size_t size_end;
928  					size_t nshards;
929  					bool err = malloc_conf_multi_sizes_next(
930  					    &bin_shards_segment_cur, &vlen_left,
931  					    &size_start, &size_end, &nshards);
932  					if (err || bin_update_shard_size(
933  					    bin_shard_sizes, size_start,
934  					    size_end, nshards)) {
935  						CONF_ERROR(
936  						    "Invalid settings for "
937  						    "bin_shards", k, klen, v,
938  						    vlen);
939  						break;
940  					}
941  				} while (vlen_left > 0);
942  				CONF_CONTINUE;
943  			}
944  			CONF_HANDLE_SSIZE_T(opt_dirty_decay_ms,
945  			    "dirty_decay_ms", -1, NSTIME_SEC_MAX * KQU(1000) <
946  			    QU(SSIZE_MAX) ? NSTIME_SEC_MAX * KQU(1000) :
947  			    SSIZE_MAX);
948  			CONF_HANDLE_SSIZE_T(opt_muzzy_decay_ms,
949  			    "muzzy_decay_ms", -1, NSTIME_SEC_MAX * KQU(1000) <
950  			    QU(SSIZE_MAX) ? NSTIME_SEC_MAX * KQU(1000) :
951  			    SSIZE_MAX);
952  			CONF_HANDLE_BOOL(opt_stats_print, "stats_print")
953  			if (CONF_MATCH("stats_print_opts")) {
954  				init_opt_stats_print_opts(v, vlen);
955  				CONF_CONTINUE;
956  			}
957  			if (config_fill) {
958  				if (CONF_MATCH("junk")) {
959  					if (CONF_MATCH_VALUE("true")) {
960  						opt_junk = "true";
961  						opt_junk_alloc = opt_junk_free =
962  						    true;
963  					} else if (CONF_MATCH_VALUE("false")) {
964  						opt_junk = "false";
965  						opt_junk_alloc = opt_junk_free =
966  						    false;
967  					} else if (CONF_MATCH_VALUE("alloc")) {
968  						opt_junk = "alloc";
969  						opt_junk_alloc = true;
970  						opt_junk_free = false;
971  					} else if (CONF_MATCH_VALUE("free")) {
972  						opt_junk = "free";
973  						opt_junk_alloc = false;
974  						opt_junk_free = true;
975  					} else {
976  						CONF_ERROR(
977  						    "Invalid conf value",
978  						    k, klen, v, vlen);
979  					}
980  					CONF_CONTINUE;
981  				}
982  				CONF_HANDLE_BOOL(opt_zero, "zero")
983  			}
984  			if (config_utrace) {
985  				CONF_HANDLE_BOOL(opt_utrace, "utrace")
986  			}
987  			if (config_xmalloc) {
988  				CONF_HANDLE_BOOL(opt_xmalloc, "xmalloc")
989  			}
990  			CONF_HANDLE_BOOL(opt_tcache, "tcache")
991  			CONF_HANDLE_SSIZE_T(opt_lg_tcache_max, "lg_tcache_max",
992  			    -1, (sizeof(size_t) << 3) - 1)
993  			CONF_HANDLE_SIZE_T(opt_oversize_threshold,
994  			    "oversize_threshold", 0, SC_LARGE_MAXCLASS,
995  			    CONF_DONT_CHECK_MIN, CONF_CHECK_MAX, false)
996  			CONF_HANDLE_SIZE_T(opt_lg_extent_max_active_fit,
997  			    "lg_extent_max_active_fit", 0,
998  			    (sizeof(size_t) << 3), CONF_DONT_CHECK_MIN,
999  			    CONF_CHECK_MAX, false)
1000  			if (strncmp("percpu_arena", k, klen) == 0) {
1001  				bool match = false;
1002  				for (int i = percpu_arena_mode_names_base; i <
1003  				    percpu_arena_mode_names_limit; i++) {
1004  					if (strncmp(percpu_arena_mode_names[i],
1005  					    v, vlen) == 0) {
1006  						if (!have_percpu_arena) {
1007  							CONF_ERROR(
1008  							    "No getcpu support",
1009  							    k, klen, v, vlen);
1010  						}
1011  						opt_percpu_arena = i;
1012  						match = true;
1013  						break;
1014  					}
1015  				}
1016  				if (!match) {
1017  					CONF_ERROR("Invalid conf value",
1018  					    k, klen, v, vlen);
1019  				}
1020  				CONF_CONTINUE;
1021  			}
1022  			CONF_HANDLE_BOOL(opt_background_thread,
1023  			    "background_thread");
1024  			CONF_HANDLE_SIZE_T(opt_max_background_threads,
1025  					   "max_background_threads", 1,
1026  					   opt_max_background_threads,
1027  					   CONF_CHECK_MIN, CONF_CHECK_MAX,
1028  					   true);
1029  			if (CONF_MATCH("slab_sizes")) {
1030  				bool err;
1031  				const char *slab_size_segment_cur = v;
1032  				size_t vlen_left = vlen;
1033  				do {
1034  					size_t slab_start;
1035  					size_t slab_end;
1036  					size_t pgs;
1037  					err = malloc_conf_multi_sizes_next(
1038  					    &slab_size_segment_cur,
1039  					    &vlen_left, &slab_start, &slab_end,
1040  					    &pgs);
1041  					if (!err) {
1042  						sc_data_update_slab_size(
1043  						    sc_data, slab_start,
1044  						    slab_end, (int)pgs);
1045  					} else {
1046  						CONF_ERROR("Invalid settings "
1047  						    "for slab_sizes",
1048  						    k, klen, v, vlen);
1049  					}
1050  				} while (!err && vlen_left > 0);
1051  				CONF_CONTINUE;
1052  			}
1053  			if (config_prof) {
1054  				CONF_HANDLE_BOOL(opt_prof, "prof")
1055  				CONF_HANDLE_CHAR_P(opt_prof_prefix,
1056  				    "prof_prefix", "jeprof")
1057  				CONF_HANDLE_BOOL(opt_prof_active, "prof_active")
1058  				CONF_HANDLE_BOOL(opt_prof_thread_active_init,
1059  				    "prof_thread_active_init")
1060  				CONF_HANDLE_SIZE_T(opt_lg_prof_sample,
1061  				    "lg_prof_sample", 0, (sizeof(uint64_t) << 3)
1062  				    - 1, CONF_DONT_CHECK_MIN, CONF_CHECK_MAX,
1063  				    true)
1064  				CONF_HANDLE_BOOL(opt_prof_accum, "prof_accum")
1065  				CONF_HANDLE_SSIZE_T(opt_lg_prof_interval,
1066  				    "lg_prof_interval", -1,
1067  				    (sizeof(uint64_t) << 3) - 1)
1068  				CONF_HANDLE_BOOL(opt_prof_gdump, "prof_gdump")
1069  				CONF_HANDLE_BOOL(opt_prof_final, "prof_final")
1070  				CONF_HANDLE_BOOL(opt_prof_leak, "prof_leak")
1071  				CONF_HANDLE_BOOL(opt_prof_log, "prof_log")
1072  			}
1073  			if (config_log) {
1074  				if (CONF_MATCH("log")) {
1075  					size_t cpylen = (
1076  					    vlen <= sizeof(log_var_names) ?
1077  					    vlen : sizeof(log_var_names) - 1);
1078  					strncpy(log_var_names, v, cpylen);
1079  					log_var_names[cpylen] = '\0';
1080  					CONF_CONTINUE;
1081  				}
1082  			}
1083  			if (CONF_MATCH("thp")) {
1084  				bool match = false;
1085  				for (int i = 0; i < thp_mode_names_limit; i++) {
1086  					if (strncmp(thp_mode_names[i],v, vlen)
1087  					    == 0) {
1088  						if (!have_madvise_huge) {
1089  							CONF_ERROR(
1090  							    "No THP support",
1091  							    k, klen, v, vlen);
1092  						}
1093  						opt_thp = i;
1094  						match = true;
1095  						break;
1096  					}
1097  				}
1098  				if (!match) {
1099  					CONF_ERROR("Invalid conf value",
1100  					    k, klen, v, vlen);
1101  				}
1102  				CONF_CONTINUE;
1103  			}
1104  			CONF_ERROR("Invalid conf pair", k, klen, v, vlen);
1105  #undef CONF_ERROR
1106  #undef CONF_CONTINUE
1107  #undef CONF_MATCH
1108  #undef CONF_MATCH_VALUE
1109  #undef CONF_HANDLE_BOOL
1110  #undef CONF_DONT_CHECK_MIN
1111  #undef CONF_CHECK_MIN
1112  #undef CONF_DONT_CHECK_MAX
1113  #undef CONF_CHECK_MAX
1114  #undef CONF_HANDLE_T_U
1115  #undef CONF_HANDLE_UNSIGNED
1116  #undef CONF_HANDLE_SIZE_T
1117  #undef CONF_HANDLE_SSIZE_T
1118  #undef CONF_HANDLE_CHAR_P
1119      JEMALLOC_DIAGNOSTIC_POP
1120  		}
1121  		if (opt_abort_conf && had_conf_error) {
1122  			malloc_abort_invalid_conf();
1123  		}
1124  	}
1125  	atomic_store_b(&log_init_done, true, ATOMIC_RELEASE);
1126  }
1127  static void
1128  malloc_conf_init(sc_data_t *sc_data, unsigned bin_shard_sizes[SC_NBINS]) {
1129  	const char *opts_cache[MALLOC_CONF_NSOURCES] = {NULL, NULL, NULL, NULL};
1130  	char buf[PATH_MAX + 1];
1131  	malloc_conf_init_helper(NULL, NULL, true, opts_cache, buf);
1132  	malloc_conf_init_helper(sc_data, bin_shard_sizes, false, opts_cache,
1133  	    NULL);
1134  }
1135  #undef MALLOC_CONF_NSOURCES
1136  static bool
1137  malloc_init_hard_needed(void) {
1138  	if (malloc_initialized() || (IS_INITIALIZER && malloc_init_state ==
1139  	    malloc_init_recursible)) {
1140  		return false;
1141  	}
1142  #ifdef JEMALLOC_THREADED_INIT
1143  	if (malloc_initializer != NO_INITIALIZER && !IS_INITIALIZER) {
1144  		spin_t spinner = SPIN_INITIALIZER;
1145  		do {
1146  			malloc_mutex_unlock(TSDN_NULL, &init_lock);
1147  			spin_adaptive(&spinner);
1148  			malloc_mutex_lock(TSDN_NULL, &init_lock);
1149  		} while (!malloc_initialized());
1150  		return false;
1151  	}
1152  #endif
1153  	return true;
1154  }
1155  static bool
1156  malloc_init_hard_a0_locked() {
1157  	malloc_initializer = INITIALIZER;
1158  	JEMALLOC_DIAGNOSTIC_PUSH
1159  	JEMALLOC_DIAGNOSTIC_IGNORE_MISSING_STRUCT_FIELD_INITIALIZERS
1160  	sc_data_t sc_data = {0};
1161  	JEMALLOC_DIAGNOSTIC_POP
1162  	sc_boot(&sc_data);
1163  	unsigned bin_shard_sizes[SC_NBINS];
1164  	bin_shard_sizes_boot(bin_shard_sizes);
1165  	if (config_prof) {
1166  		prof_boot0();
1167  	}
1168  	malloc_conf_init(&sc_data, bin_shard_sizes);
1169  	sz_boot(&sc_data);
1170  	bin_boot(&sc_data, bin_shard_sizes);
1171  	if (opt_stats_print) {
1172  		if (atexit(stats_print_atexit) != 0) {
1173  			malloc_write("<jemalloc>: Error in atexit()\n");
1174  			if (opt_abort) {
1175  				abort();
1176  			}
1177  		}
1178  	}
1179  	if (pages_boot()) {
1180  		return true;
1181  	}
1182  	if (base_boot(TSDN_NULL)) {
1183  		return true;
1184  	}
1185  	if (extent_boot()) {
1186  		return true;
1187  	}
1188  	if (ctl_boot()) {
1189  		return true;
1190  	}
1191  	if (config_prof) {
1192  		prof_boot1();
1193  	}
1194  	arena_boot(&sc_data);
1195  	if (tcache_boot(TSDN_NULL)) {
1196  		return true;
1197  	}
1198  	if (malloc_mutex_init(&arenas_lock, "arenas", WITNESS_RANK_ARENAS,
1199  	    malloc_mutex_rank_exclusive)) {
1200  		return true;
1201  	}
1202  	hook_boot();
1203  	narenas_auto = 1;
1204  	manual_arena_base = narenas_auto + 1;
1205  	memset(arenas, 0, sizeof(arena_t *) * narenas_auto);
1206  	if (arena_init(TSDN_NULL, 0, (extent_hooks_t *)&extent_hooks_default)
1207  	    == NULL) {
1208  		return true;
1209  	}
1210  	a0 = arena_get(TSDN_NULL, 0, false);
1211  	malloc_init_state = malloc_init_a0_initialized;
1212  	return false;
1213  }
1214  static bool
1215  malloc_init_hard_a0(void) {
1216  	bool ret;
1217  	malloc_mutex_lock(TSDN_NULL, &init_lock);
1218  	ret = malloc_init_hard_a0_locked();
1219  	malloc_mutex_unlock(TSDN_NULL, &init_lock);
1220  	return ret;
1221  }
1222  static bool
1223  malloc_init_hard_recursible(void) {
1224  	malloc_init_state = malloc_init_recursible;
1225  	ncpus = malloc_ncpus();
1226  #if (defined(JEMALLOC_HAVE_PTHREAD_ATFORK) && !defined(JEMALLOC_MUTEX_INIT_CB) \
1227      && !defined(JEMALLOC_ZONE) && !defined(_WIN32) && \
1228      !defined(__native_client__))
1229  	if (pthread_atfork(jemalloc_prefork, jemalloc_postfork_parent,
1230  	    jemalloc_postfork_child) != 0) {
1231  		malloc_write("<jemalloc>: Error in pthread_atfork()\n");
1232  		if (opt_abort) {
1233  			abort();
1234  		}
1235  		return true;
1236  	}
1237  #endif
1238  	if (background_thread_boot0()) {
1239  		return true;
1240  	}
1241  	return false;
1242  }
1243  static unsigned
1244  malloc_narenas_default(void) {
1245  	assert(ncpus > 0);
1246  	if (ncpus > 1) {
1247  		return ncpus << 2;
1248  	} else {
1249  		return 1;
1250  	}
1251  }
1252  static percpu_arena_mode_t
1253  percpu_arena_as_initialized(percpu_arena_mode_t mode) {
1254  	assert(!malloc_initialized());
1255  	assert(mode <= percpu_arena_disabled);
1256  	if (mode != percpu_arena_disabled) {
1257  		mode += percpu_arena_mode_enabled_base;
1258  	}
1259  	return mode;
1260  }
1261  static bool
1262  malloc_init_narenas(void) {
1263  	assert(ncpus > 0);
1264  	if (opt_percpu_arena != percpu_arena_disabled) {
1265  		if (!have_percpu_arena || malloc_getcpu() < 0) {
1266  			opt_percpu_arena = percpu_arena_disabled;
1267  			malloc_printf("<jemalloc>: perCPU arena getcpu() not "
1268  			    "available. Setting narenas to %u.\n", opt_narenas ?
1269  			    opt_narenas : malloc_narenas_default());
1270  			if (opt_abort) {
1271  				abort();
1272  			}
1273  		} else {
1274  			if (ncpus >= MALLOCX_ARENA_LIMIT) {
1275  				malloc_printf("<jemalloc>: narenas w/ percpu"
1276  				    "arena beyond limit (%d)\n", ncpus);
1277  				if (opt_abort) {
1278  					abort();
1279  				}
1280  				return true;
1281  			}
1282  			if (percpu_arena_as_initialized(opt_percpu_arena) ==
1283  			    per_phycpu_arena && ncpus % 2 != 0) {
1284  				malloc_printf("<jemalloc>: invalid "
1285  				    "configuration -- per physical CPU arena "
1286  				    "with odd number (%u) of CPUs (no hyper "
1287  				    "threading?).\n", ncpus);
1288  				if (opt_abort)
1289  					abort();
1290  			}
1291  			unsigned n = percpu_arena_ind_limit(
1292  			    percpu_arena_as_initialized(opt_percpu_arena));
1293  			if (opt_narenas < n) {
1294  				opt_narenas = n;
1295  			}
1296  		}
1297  	}
1298  	if (opt_narenas == 0) {
1299  		opt_narenas = malloc_narenas_default();
1300  	}
1301  	assert(opt_narenas > 0);
1302  	narenas_auto = opt_narenas;
1303  	if (narenas_auto >= MALLOCX_ARENA_LIMIT) {
1304  		narenas_auto = MALLOCX_ARENA_LIMIT - 1;
1305  		malloc_printf("<jemalloc>: Reducing narenas to limit (%d)\n",
1306  		    narenas_auto);
1307  	}
1308  	narenas_total_set(narenas_auto);
1309  	if (arena_init_huge()) {
1310  		narenas_total_inc();
1311  	}
1312  	manual_arena_base = narenas_total_get();
1313  	return false;
1314  }
1315  static void
1316  malloc_init_percpu(void) {
1317  	opt_percpu_arena = percpu_arena_as_initialized(opt_percpu_arena);
1318  }
1319  static bool
1320  malloc_init_hard_finish(void) {
1321  	if (malloc_mutex_boot()) {
1322  		return true;
1323  	}
1324  	malloc_init_state = malloc_init_initialized;
1325  	malloc_slow_flag_init();
1326  	return false;
1327  }
1328  static void
1329  malloc_init_hard_cleanup(tsdn_t *tsdn, bool reentrancy_set) {
1330  	malloc_mutex_assert_owner(tsdn, &init_lock);
1331  	malloc_mutex_unlock(tsdn, &init_lock);
1332  	if (reentrancy_set) {
1333  		assert(!tsdn_null(tsdn));
1334  		tsd_t *tsd = tsdn_tsd(tsdn);
1335  		assert(tsd_reentrancy_level_get(tsd) > 0);
1336  		post_reentrancy(tsd);
1337  	}
1338  }
1339  static bool
1340  malloc_init_hard(void) {
1341  	tsd_t *tsd;
1342  #if defined(_WIN32) && _WIN32_WINNT < 0x0600
1343  	_init_init_lock();
1344  #endif
1345  	malloc_mutex_lock(TSDN_NULL, &init_lock);
1346  #define UNLOCK_RETURN(tsdn, ret, reentrancy)		\
1347  	malloc_init_hard_cleanup(tsdn, reentrancy);	\
1348  	return ret;
1349  	if (!malloc_init_hard_needed()) {
1350  		UNLOCK_RETURN(TSDN_NULL, false, false)
1351  	}
1352  	if (malloc_init_state != malloc_init_a0_initialized &&
1353  	    malloc_init_hard_a0_locked()) {
1354  		UNLOCK_RETURN(TSDN_NULL, true, false)
1355  	}
1356  	malloc_mutex_unlock(TSDN_NULL, &init_lock);
1357  	tsd = malloc_tsd_boot0();
1358  	if (tsd == NULL) {
1359  		return true;
1360  	}
1361  	if (malloc_init_hard_recursible()) {
1362  		return true;
1363  	}
1364  	malloc_mutex_lock(tsd_tsdn(tsd), &init_lock);
1365  	pre_reentrancy(tsd, NULL);
1366  	if (malloc_init_narenas() || background_thread_boot1(tsd_tsdn(tsd))) {
1367  		UNLOCK_RETURN(tsd_tsdn(tsd), true, true)
1368  	}
1369  	if (config_prof && prof_boot2(tsd)) {
1370  		UNLOCK_RETURN(tsd_tsdn(tsd), true, true)
1371  	}
1372  	malloc_init_percpu();
1373  	if (malloc_init_hard_finish()) {
1374  		UNLOCK_RETURN(tsd_tsdn(tsd), true, true)
1375  	}
1376  	post_reentrancy(tsd);
1377  	malloc_mutex_unlock(tsd_tsdn(tsd), &init_lock);
1378  	witness_assert_lockless(witness_tsd_tsdn(
1379  	    tsd_witness_tsdp_get_unsafe(tsd)));
1380  	malloc_tsd_boot1();
1381  	tsd = tsd_fetch();
1382  	if (opt_background_thread) {
1383  		assert(have_background_thread);
1384  		background_thread_ctl_init(tsd_tsdn(tsd));
1385  		if (background_thread_create(tsd, 0)) {
1386  			return true;
1387  		}
1388  	}
1389  #undef UNLOCK_RETURN
1390  	return false;
1391  }
1392  typedef struct static_opts_s static_opts_t;
1393  struct static_opts_s {
1394  	bool may_overflow;
1395  	bool bump_empty_aligned_alloc;
1396  	bool assert_nonempty_alloc;
1397  	bool null_out_result_on_error;
1398  	bool set_errno_on_error;
1399  	size_t min_alignment;
1400  	const char *oom_string;
1401  	const char *invalid_alignment_string;
1402  	bool slow;
1403  	bool usize;
1404  };
1405  JEMALLOC_ALWAYS_INLINE void
1406  static_opts_init(static_opts_t *static_opts) {
1407  	static_opts->may_overflow = false;
1408  	static_opts->bump_empty_aligned_alloc = false;
1409  	static_opts->assert_nonempty_alloc = false;
1410  	static_opts->null_out_result_on_error = false;
1411  	static_opts->set_errno_on_error = false;
1412  	static_opts->min_alignment = 0;
1413  	static_opts->oom_string = "";
1414  	static_opts->invalid_alignment_string = "";
1415  	static_opts->slow = false;
1416  	static_opts->usize = false;
1417  }
1418  #define TCACHE_IND_NONE ((unsigned)-1)
1419  #define TCACHE_IND_AUTOMATIC ((unsigned)-2)
1420  #define ARENA_IND_AUTOMATIC ((unsigned)-1)
1421  typedef struct dynamic_opts_s dynamic_opts_t;
1422  struct dynamic_opts_s {
1423  	void **result;
1424  	size_t usize;
1425  	size_t num_items;
1426  	size_t item_size;
1427  	size_t alignment;
1428  	bool zero;
1429  	unsigned tcache_ind;
1430  	unsigned arena_ind;
1431  };
1432  JEMALLOC_ALWAYS_INLINE void
1433  dynamic_opts_init(dynamic_opts_t *dynamic_opts) {
<span onclick='openModal()' class='match'>1434  	dynamic_opts->result = NULL;
1435  	dynamic_opts->usize = 0;
1436  	dynamic_opts->num_items = 0;
1437  	dynamic_opts->item_size = 0;
1438  	dynamic_opts->alignment = 0;
1439  	dynamic_opts->zero = false;
1440  	dynamic_opts->tcache_ind = TCACHE_IND_AUTOMATIC;
1441  	dynamic_opts->arena_ind = ARENA_IND_AUTOMATIC;
</span>1442  }
1443  JEMALLOC_ALWAYS_INLINE void *
1444  imalloc_no_sample(static_opts_t *sopts, dynamic_opts_t *dopts, tsd_t *tsd,
1445      size_t size, size_t usize, szind_t ind) {
1446  	tcache_t *tcache;
1447  	arena_t *arena;
1448  	if (dopts->tcache_ind == TCACHE_IND_AUTOMATIC) {
1449  		if (likely(!sopts->slow)) {
1450  			tcache = tsd_tcachep_get(tsd);
1451  			assert(tcache == tcache_get(tsd));
1452  		} else {
1453  			tcache = tcache_get(tsd);
1454  		}
1455  	} else if (dopts->tcache_ind == TCACHE_IND_NONE) {
1456  		tcache = NULL;
1457  	} else {
1458  		tcache = tcaches_get(tsd, dopts->tcache_ind);
1459  	}
1460  	if (dopts->arena_ind == ARENA_IND_AUTOMATIC) {
1461  		arena = NULL;
1462  	} else {
1463  		arena = arena_get(tsd_tsdn(tsd), dopts->arena_ind, true);
1464  	}
1465  	if (unlikely(dopts->alignment != 0)) {
1466  		return ipalloct(tsd_tsdn(tsd), usize, dopts->alignment,
1467  		    dopts->zero, tcache, arena);
1468  	}
1469  	return iallocztm(tsd_tsdn(tsd), size, ind, dopts->zero, tcache, false,
1470  	    arena, sopts->slow);
1471  }
1472  JEMALLOC_ALWAYS_INLINE void *
1473  imalloc_sample(static_opts_t *sopts, dynamic_opts_t *dopts, tsd_t *tsd,
1474      size_t usize, szind_t ind) {
1475  	void *ret;
1476  	szind_t ind_large;
1477  	size_t bumped_usize = usize;
1478  	if (usize <= SC_SMALL_MAXCLASS) {
1479  		assert(((dopts->alignment == 0) ?
1480  		    sz_s2u(SC_LARGE_MINCLASS) :
1481  		    sz_sa2u(SC_LARGE_MINCLASS, dopts->alignment))
1482  			== SC_LARGE_MINCLASS);
1483  		ind_large = sz_size2index(SC_LARGE_MINCLASS);
1484  		bumped_usize = sz_s2u(SC_LARGE_MINCLASS);
1485  		ret = imalloc_no_sample(sopts, dopts, tsd, bumped_usize,
1486  		    bumped_usize, ind_large);
1487  		if (unlikely(ret == NULL)) {
1488  			return NULL;
1489  		}
1490  		arena_prof_promote(tsd_tsdn(tsd), ret, usize);
1491  	} else {
1492  		ret = imalloc_no_sample(sopts, dopts, tsd, usize, usize, ind);
1493  	}
1494  	return ret;
1495  }
1496  JEMALLOC_ALWAYS_INLINE bool
1497  compute_size_with_overflow(bool may_overflow, dynamic_opts_t *dopts,
1498      size_t *size) {
1499  	if (!may_overflow) {
1500  		assert(dopts->num_items == 1);
1501  		*size = dopts->item_size;
1502  		return false;
1503  	}
1504  	static const size_t high_bits = SIZE_T_MAX << (sizeof(size_t) * 8 / 2);
1505  	*size = dopts->item_size * dopts->num_items;
1506  	if (unlikely(*size == 0)) {
1507  		return (dopts->num_items != 0 && dopts->item_size != 0);
1508  	}
1509  	if (likely((high_bits & (dopts->num_items | dopts->item_size)) == 0)) {
1510  		return false;
1511  	}
1512  	if (likely(*size / dopts->item_size == dopts->num_items)) {
1513  		return false;
1514  	}
1515  	return true;
1516  }
1517  JEMALLOC_ALWAYS_INLINE int
1518  imalloc_body(static_opts_t *sopts, dynamic_opts_t *dopts, tsd_t *tsd) {
1519  	void *allocation = NULL;
1520  	size_t size = 0;
1521  	szind_t ind = 0;
1522  	size_t usize = 0;
1523  	int8_t reentrancy_level;
1524  	if (unlikely(compute_size_with_overflow(sopts->may_overflow, dopts,
1525  	    &size))) {
1526  		goto label_oom;
1527  	}
1528  	if (unlikely(dopts->alignment < sopts->min_alignment
1529  	    || (dopts->alignment & (dopts->alignment - 1)) != 0)) {
1530  		goto label_invalid_alignment;
1531  	}
1532  	if (dopts->alignment == 0) {
1533  		ind = sz_size2index(size);
1534  		if (unlikely(ind >= SC_NSIZES)) {
1535  			goto label_oom;
1536  		}
1537  		if (config_stats || (config_prof && opt_prof) || sopts->usize) {
1538  			usize = sz_index2size(ind);
1539  			dopts->usize = usize;
1540  			assert(usize > 0 && usize
1541  			    <= SC_LARGE_MAXCLASS);
1542  		}
1543  	} else {
1544  		if (sopts->bump_empty_aligned_alloc) {
1545  			if (unlikely(size == 0)) {
1546  				size = 1;
1547  			}
1548  		}
1549  		usize = sz_sa2u(size, dopts->alignment);
1550  		dopts->usize = usize;
1551  		if (unlikely(usize == 0
1552  		    || usize > SC_LARGE_MAXCLASS)) {
1553  			goto label_oom;
1554  		}
1555  	}
1556  	if (sopts->assert_nonempty_alloc) {
1557  		assert (size != 0);
1558  	}
1559  	check_entry_exit_locking(tsd_tsdn(tsd));
1560  	reentrancy_level = tsd_reentrancy_level_get(tsd);
1561  	if (sopts->slow && unlikely(reentrancy_level > 0)) {
1562  		assert(dopts->tcache_ind == TCACHE_IND_AUTOMATIC ||
1563  		    dopts->tcache_ind == TCACHE_IND_NONE);
1564  		assert(dopts->arena_ind == ARENA_IND_AUTOMATIC);
1565  		dopts->tcache_ind = TCACHE_IND_NONE;
1566  		dopts->arena_ind = 0;
1567  	}
1568  	if (config_prof && opt_prof) {
1569  		prof_tctx_t *tctx = prof_alloc_prep(
1570  		    tsd, usize, prof_active_get_unlocked(), true);
1571  		alloc_ctx_t alloc_ctx;
1572  		if (likely((uintptr_t)tctx == (uintptr_t)1U)) {
1573  			alloc_ctx.slab = (usize
1574  			    <= SC_SMALL_MAXCLASS);
1575  			allocation = imalloc_no_sample(
1576  			    sopts, dopts, tsd, usize, usize, ind);
1577  		} else if ((uintptr_t)tctx > (uintptr_t)1U) {
1578  			allocation = imalloc_sample(
1579  			    sopts, dopts, tsd, usize, ind);
1580  			alloc_ctx.slab = false;
1581  		} else {
1582  			allocation = NULL;
1583  		}
1584  		if (unlikely(allocation == NULL)) {
1585  			prof_alloc_rollback(tsd, tctx, true);
1586  			goto label_oom;
1587  		}
1588  		prof_malloc(tsd_tsdn(tsd), allocation, usize, &alloc_ctx, tctx);
1589  	} else {
1590  		allocation = imalloc_no_sample(sopts, dopts, tsd, size, usize,
1591  		    ind);
1592  		if (unlikely(allocation == NULL)) {
1593  			goto label_oom;
1594  		}
1595  	}
1596  	assert(dopts->alignment == 0
1597  	    || ((uintptr_t)allocation & (dopts->alignment - 1)) == ZU(0));
1598  	if (config_stats) {
1599  		assert(usize == isalloc(tsd_tsdn(tsd), allocation));
1600  		*tsd_thread_allocatedp_get(tsd) += usize;
1601  	}
1602  	if (sopts->slow) {
1603  		UTRACE(0, size, allocation);
1604  	}
1605  	check_entry_exit_locking(tsd_tsdn(tsd));
1606  	*dopts->result = allocation;
1607  	return 0;
1608  label_oom:
1609  	if (unlikely(sopts->slow) && config_xmalloc && unlikely(opt_xmalloc)) {
1610  		malloc_write(sopts->oom_string);
1611  		abort();
1612  	}
1613  	if (sopts->slow) {
1614  		UTRACE(NULL, size, NULL);
1615  	}
1616  	check_entry_exit_locking(tsd_tsdn(tsd));
1617  	if (sopts->set_errno_on_error) {
1618  		set_errno(ENOMEM);
1619  	}
1620  	if (sopts->null_out_result_on_error) {
1621  		*dopts->result = NULL;
1622  	}
1623  	return ENOMEM;
1624  label_invalid_alignment:
1625  	if (config_xmalloc && unlikely(opt_xmalloc)) {
1626  		malloc_write(sopts->invalid_alignment_string);
1627  		abort();
1628  	}
1629  	if (sopts->set_errno_on_error) {
1630  		set_errno(EINVAL);
1631  	}
1632  	if (sopts->slow) {
1633  		UTRACE(NULL, size, NULL);
1634  	}
1635  	check_entry_exit_locking(tsd_tsdn(tsd));
1636  	if (sopts->null_out_result_on_error) {
1637  		*dopts->result = NULL;
1638  	}
1639  	return EINVAL;
1640  }
1641  JEMALLOC_ALWAYS_INLINE bool
1642  imalloc_init_check(static_opts_t *sopts, dynamic_opts_t *dopts) {
1643  	if (unlikely(!malloc_initialized()) && unlikely(malloc_init())) {
1644  		if (config_xmalloc && unlikely(opt_xmalloc)) {
1645  			malloc_write(sopts->oom_string);
1646  			abort();
1647  		}
1648  		UTRACE(NULL, dopts->num_items * dopts->item_size, NULL);
1649  		set_errno(ENOMEM);
1650  		*dopts->result = NULL;
1651  		return false;
1652  	}
1653  	return true;
1654  }
1655  JEMALLOC_ALWAYS_INLINE int
1656  imalloc(static_opts_t *sopts, dynamic_opts_t *dopts) {
1657  	if (tsd_get_allocates() && !imalloc_init_check(sopts, dopts)) {
1658  		return ENOMEM;
1659  	}
1660  	tsd_t *tsd = tsd_fetch();
1661  	assert(tsd);
1662  	if (likely(tsd_fast(tsd))) {
1663  		tsd_assert_fast(tsd);
1664  		sopts->slow = false;
1665  		return imalloc_body(sopts, dopts, tsd);
1666  	} else {
1667  		if (!tsd_get_allocates() && !imalloc_init_check(sopts, dopts)) {
1668  			return ENOMEM;
1669  		}
1670  		sopts->slow = true;
1671  		return imalloc_body(sopts, dopts, tsd);
1672  	}
1673  }
1674  JEMALLOC_NOINLINE
1675  void *
1676  malloc_default(size_t size) {
1677  	void *ret;
1678  	static_opts_t sopts;
1679  	dynamic_opts_t dopts;
1680  	LOG("core.malloc.entry", "size: %zu", size);
1681  	static_opts_init(&sopts);
1682  	dynamic_opts_init(&dopts);
1683  	sopts.null_out_result_on_error = true;
1684  	sopts.set_errno_on_error = true;
1685  	sopts.oom_string = "<jemalloc>: Error in malloc(): out of memory\n";
1686  	dopts.result = &ret;
1687  	dopts.num_items = 1;
1688  	dopts.item_size = size;
1689  	imalloc(&sopts, &dopts);
1690  	if (sopts.slow) {
1691  		uintptr_t args[3] = {size};
1692  		hook_invoke_alloc(hook_alloc_malloc, ret, (uintptr_t)ret, args);
1693  	}
1694  	LOG("core.malloc.exit", "result: %p", ret);
1695  	return ret;
1696  }
1697  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
1698  void JEMALLOC_NOTHROW *
1699  JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(1)
1700  je_malloc(size_t size) {
1701  	LOG("core.malloc.entry", "size: %zu", size);
1702  	if (tsd_get_allocates() && unlikely(!malloc_initialized())) {
1703  		return malloc_default(size);
1704  	}
1705  	tsd_t *tsd = tsd_get(false);
1706  	if (unlikely(!tsd || !tsd_fast(tsd) || (size > SC_LOOKUP_MAXCLASS))) {
1707  		return malloc_default(size);
1708  	}
1709  	tcache_t *tcache = tsd_tcachep_get(tsd);
1710  	if (unlikely(ticker_trytick(&tcache->gc_ticker))) {
1711  		return malloc_default(size);
1712  	}
1713  	szind_t ind = sz_size2index_lookup(size);
1714  	size_t usize;
1715  	if (config_stats || config_prof) {
1716  		usize = sz_index2size(ind);
1717  	}
1718  	assert(ind < SC_NBINS);
1719  	assert(size <= SC_SMALL_MAXCLASS);
1720  	if (config_prof) {
1721  		int64_t bytes_until_sample = tsd_bytes_until_sample_get(tsd);
1722  		bytes_until_sample -= usize;
1723  		tsd_bytes_until_sample_set(tsd, bytes_until_sample);
1724  		if (unlikely(bytes_until_sample < 0)) {
1725  			if (!prof_active) {
1726  				tsd_bytes_until_sample_set(tsd, SSIZE_MAX);
1727  			}
1728  			return malloc_default(size);
1729  		}
1730  	}
1731  	cache_bin_t *bin = tcache_small_bin_get(tcache, ind);
1732  	bool tcache_success;
1733  	void* ret = cache_bin_alloc_easy(bin, &tcache_success);
1734  	if (tcache_success) {
1735  		if (config_stats) {
1736  			*tsd_thread_allocatedp_get(tsd) += usize;
1737  			bin->tstats.nrequests++;
1738  		}
1739  		if (config_prof) {
1740  			tcache->prof_accumbytes += usize;
1741  		}
1742  		LOG("core.malloc.exit", "result: %p", ret);
1743  		return ret;
1744  	}
1745  	return malloc_default(size);
1746  }
1747  JEMALLOC_EXPORT int JEMALLOC_NOTHROW
1748  JEMALLOC_ATTR(nonnull(1))
1749  je_posix_memalign(void **memptr, size_t alignment, size_t size) {
1750  	int ret;
1751  	static_opts_t sopts;
1752  	dynamic_opts_t dopts;
1753  	LOG("core.posix_memalign.entry", "mem ptr: %p, alignment: %zu, "
1754  	    "size: %zu", memptr, alignment, size);
1755  	static_opts_init(&sopts);
1756  	dynamic_opts_init(&dopts);
1757  	sopts.bump_empty_aligned_alloc = true;
1758  	sopts.min_alignment = sizeof(void *);
1759  	sopts.oom_string =
1760  	    "<jemalloc>: Error allocating aligned memory: out of memory\n";
1761  	sopts.invalid_alignment_string =
1762  	    "<jemalloc>: Error allocating aligned memory: invalid alignment\n";
1763  	dopts.result = memptr;
1764  	dopts.num_items = 1;
1765  	dopts.item_size = size;
1766  	dopts.alignment = alignment;
1767  	ret = imalloc(&sopts, &dopts);
1768  	if (sopts.slow) {
1769  		uintptr_t args[3] = {(uintptr_t)memptr, (uintptr_t)alignment,
1770  			(uintptr_t)size};
1771  		hook_invoke_alloc(hook_alloc_posix_memalign, *memptr,
1772  		    (uintptr_t)ret, args);
1773  	}
1774  	LOG("core.posix_memalign.exit", "result: %d, alloc ptr: %p", ret,
1775  	    *memptr);
1776  	return ret;
1777  }
1778  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
1779  void JEMALLOC_NOTHROW *
1780  JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(2)
1781  je_aligned_alloc(size_t alignment, size_t size) {
1782  	void *ret;
1783  	static_opts_t sopts;
1784  	dynamic_opts_t dopts;
1785  	LOG("core.aligned_alloc.entry", "alignment: %zu, size: %zu\n",
1786  	    alignment, size);
1787  	static_opts_init(&sopts);
1788  	dynamic_opts_init(&dopts);
1789  	sopts.bump_empty_aligned_alloc = true;
1790  	sopts.null_out_result_on_error = true;
1791  	sopts.set_errno_on_error = true;
1792  	sopts.min_alignment = 1;
1793  	sopts.oom_string =
1794  	    "<jemalloc>: Error allocating aligned memory: out of memory\n";
1795  	sopts.invalid_alignment_string =
1796  	    "<jemalloc>: Error allocating aligned memory: invalid alignment\n";
1797  	dopts.result = &ret;
1798  	dopts.num_items = 1;
1799  	dopts.item_size = size;
1800  	dopts.alignment = alignment;
1801  	imalloc(&sopts, &dopts);
1802  	if (sopts.slow) {
1803  		uintptr_t args[3] = {(uintptr_t)alignment, (uintptr_t)size};
1804  		hook_invoke_alloc(hook_alloc_aligned_alloc, ret,
1805  		    (uintptr_t)ret, args);
1806  	}
1807  	LOG("core.aligned_alloc.exit", "result: %p", ret);
1808  	return ret;
1809  }
1810  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
1811  void JEMALLOC_NOTHROW *
1812  JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE2(1, 2)
1813  je_calloc(size_t num, size_t size) {
1814  	void *ret;
1815  	static_opts_t sopts;
1816  	dynamic_opts_t dopts;
1817  	LOG("core.calloc.entry", "num: %zu, size: %zu\n", num, size);
1818  	static_opts_init(&sopts);
1819  	dynamic_opts_init(&dopts);
1820  	sopts.may_overflow = true;
1821  	sopts.null_out_result_on_error = true;
1822  	sopts.set_errno_on_error = true;
1823  	sopts.oom_string = "<jemalloc>: Error in calloc(): out of memory\n";
1824  	dopts.result = &ret;
1825  	dopts.num_items = num;
1826  	dopts.item_size = size;
1827  	dopts.zero = true;
1828  	imalloc(&sopts, &dopts);
1829  	if (sopts.slow) {
1830  		uintptr_t args[3] = {(uintptr_t)num, (uintptr_t)size};
1831  		hook_invoke_alloc(hook_alloc_calloc, ret, (uintptr_t)ret, args);
1832  	}
1833  	LOG("core.calloc.exit", "result: %p", ret);
1834  	return ret;
1835  }
1836  static void *
1837  irealloc_prof_sample(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t usize,
1838      prof_tctx_t *tctx, hook_ralloc_args_t *hook_args) {
1839  	void *p;
1840  	if (tctx == NULL) {
1841  		return NULL;
1842  	}
1843  	if (usize <= SC_SMALL_MAXCLASS) {
1844  		p = iralloc(tsd, old_ptr, old_usize,
1845  		    SC_LARGE_MINCLASS, 0, false, hook_args);
1846  		if (p == NULL) {
1847  			return NULL;
1848  		}
1849  		arena_prof_promote(tsd_tsdn(tsd), p, usize);
1850  	} else {
1851  		p = iralloc(tsd, old_ptr, old_usize, usize, 0, false,
1852  		    hook_args);
1853  	}
1854  	return p;
1855  }
1856  JEMALLOC_ALWAYS_INLINE void *
1857  irealloc_prof(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t usize,
1858     alloc_ctx_t *alloc_ctx, hook_ralloc_args_t *hook_args) {
1859  	void *p;
1860  	bool prof_active;
1861  	prof_tctx_t *old_tctx, *tctx;
1862  	prof_active = prof_active_get_unlocked();
1863  	old_tctx = prof_tctx_get(tsd_tsdn(tsd), old_ptr, alloc_ctx);
1864  	tctx = prof_alloc_prep(tsd, usize, prof_active, true);
1865  	if (unlikely((uintptr_t)tctx != (uintptr_t)1U)) {
1866  		p = irealloc_prof_sample(tsd, old_ptr, old_usize, usize, tctx,
1867  		    hook_args);
1868  	} else {
1869  		p = iralloc(tsd, old_ptr, old_usize, usize, 0, false,
1870  		    hook_args);
1871  	}
1872  	if (unlikely(p == NULL)) {
1873  		prof_alloc_rollback(tsd, tctx, true);
1874  		return NULL;
1875  	}
1876  	prof_realloc(tsd, p, usize, tctx, prof_active, true, old_ptr, old_usize,
1877  	    old_tctx);
1878  	return p;
1879  }
1880  JEMALLOC_ALWAYS_INLINE void
1881  ifree(tsd_t *tsd, void *ptr, tcache_t *tcache, bool slow_path) {
1882  	if (!slow_path) {
1883  		tsd_assert_fast(tsd);
1884  	}
1885  	check_entry_exit_locking(tsd_tsdn(tsd));
1886  	if (tsd_reentrancy_level_get(tsd) != 0) {
1887  		assert(slow_path);
1888  	}
1889  	assert(ptr != NULL);
1890  	assert(malloc_initialized() || IS_INITIALIZER);
1891  	alloc_ctx_t alloc_ctx;
1892  	rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);
1893  	rtree_szind_slab_read(tsd_tsdn(tsd), &extents_rtree, rtree_ctx,
1894  	    (uintptr_t)ptr, true, &alloc_ctx.szind, &alloc_ctx.slab);
1895  	assert(alloc_ctx.szind != SC_NSIZES);
1896  	size_t usize;
1897  	if (config_prof && opt_prof) {
1898  		usize = sz_index2size(alloc_ctx.szind);
1899  		prof_free(tsd, ptr, usize, &alloc_ctx);
1900  	} else if (config_stats) {
1901  		usize = sz_index2size(alloc_ctx.szind);
1902  	}
1903  	if (config_stats) {
1904  		*tsd_thread_deallocatedp_get(tsd) += usize;
1905  	}
1906  	if (likely(!slow_path)) {
1907  		idalloctm(tsd_tsdn(tsd), ptr, tcache, &alloc_ctx, false,
1908  		    false);
1909  	} else {
1910  		idalloctm(tsd_tsdn(tsd), ptr, tcache, &alloc_ctx, false,
1911  		    true);
1912  	}
1913  }
1914  JEMALLOC_ALWAYS_INLINE void
1915  isfree(tsd_t *tsd, void *ptr, size_t usize, tcache_t *tcache, bool slow_path) {
1916  	if (!slow_path) {
1917  		tsd_assert_fast(tsd);
1918  	}
1919  	check_entry_exit_locking(tsd_tsdn(tsd));
1920  	if (tsd_reentrancy_level_get(tsd) != 0) {
1921  		assert(slow_path);
1922  	}
1923  	assert(ptr != NULL);
1924  	assert(malloc_initialized() || IS_INITIALIZER);
1925  	alloc_ctx_t alloc_ctx, *ctx;
1926  	if (!config_cache_oblivious && ((uintptr_t)ptr & PAGE_MASK) != 0) {
1927  		alloc_ctx.szind = sz_size2index(usize);
1928  		alloc_ctx.slab = true;
1929  		ctx = &alloc_ctx;
1930  		if (config_debug) {
1931  			alloc_ctx_t dbg_ctx;
1932  			rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);
1933  			rtree_szind_slab_read(tsd_tsdn(tsd), &extents_rtree,
1934  			    rtree_ctx, (uintptr_t)ptr, true, &dbg_ctx.szind,
1935  			    &dbg_ctx.slab);
1936  			assert(dbg_ctx.szind == alloc_ctx.szind);
1937  			assert(dbg_ctx.slab == alloc_ctx.slab);
1938  		}
1939  	} else if (config_prof && opt_prof) {
1940  		rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);
1941  		rtree_szind_slab_read(tsd_tsdn(tsd), &extents_rtree, rtree_ctx,
1942  		    (uintptr_t)ptr, true, &alloc_ctx.szind, &alloc_ctx.slab);
1943  		assert(alloc_ctx.szind == sz_size2index(usize));
1944  		ctx = &alloc_ctx;
1945  	} else {
1946  		ctx = NULL;
1947  	}
1948  	if (config_prof && opt_prof) {
1949  		prof_free(tsd, ptr, usize, ctx);
1950  	}
1951  	if (config_stats) {
1952  		*tsd_thread_deallocatedp_get(tsd) += usize;
1953  	}
1954  	if (likely(!slow_path)) {
1955  		isdalloct(tsd_tsdn(tsd), ptr, usize, tcache, ctx, false);
1956  	} else {
1957  		isdalloct(tsd_tsdn(tsd), ptr, usize, tcache, ctx, true);
1958  	}
1959  }
1960  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
1961  void JEMALLOC_NOTHROW *
1962  JEMALLOC_ALLOC_SIZE(2)
1963  je_realloc(void *ptr, size_t arg_size) {
1964  	void *ret;
1965  	tsdn_t *tsdn JEMALLOC_CC_SILENCE_INIT(NULL);
1966  	size_t usize JEMALLOC_CC_SILENCE_INIT(0);
1967  	size_t old_usize = 0;
1968  	size_t size = arg_size;
1969  	LOG("core.realloc.entry", "ptr: %p, size: %zu\n", ptr, size);
1970  	if (unlikely(size == 0)) {
1971  		if (ptr != NULL) {
1972  			UTRACE(ptr, 0, 0);
1973  			tcache_t *tcache;
1974  			tsd_t *tsd = tsd_fetch();
1975  			if (tsd_reentrancy_level_get(tsd) == 0) {
1976  				tcache = tcache_get(tsd);
1977  			} else {
1978  				tcache = NULL;
1979  			}
1980  			uintptr_t args[3] = {(uintptr_t)ptr, size};
1981  			hook_invoke_dalloc(hook_dalloc_realloc, ptr, args);
1982  			ifree(tsd, ptr, tcache, true);
1983  			LOG("core.realloc.exit", "result: %p", NULL);
1984  			return NULL;
1985  		}
1986  		size = 1;
1987  	}
1988  	if (likely(ptr != NULL)) {
1989  		assert(malloc_initialized() || IS_INITIALIZER);
1990  		tsd_t *tsd = tsd_fetch();
1991  		check_entry_exit_locking(tsd_tsdn(tsd));
1992  		hook_ralloc_args_t hook_args = {true, {(uintptr_t)ptr,
1993  			(uintptr_t)arg_size, 0, 0}};
1994  		alloc_ctx_t alloc_ctx;
1995  		rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);
1996  		rtree_szind_slab_read(tsd_tsdn(tsd), &extents_rtree, rtree_ctx,
1997  		    (uintptr_t)ptr, true, &alloc_ctx.szind, &alloc_ctx.slab);
1998  		assert(alloc_ctx.szind != SC_NSIZES);
1999  		old_usize = sz_index2size(alloc_ctx.szind);
2000  		assert(old_usize == isalloc(tsd_tsdn(tsd), ptr));
2001  		if (config_prof && opt_prof) {
2002  			usize = sz_s2u(size);
2003  			if (unlikely(usize == 0
2004  			    || usize > SC_LARGE_MAXCLASS)) {
2005  				ret = NULL;
2006  			} else {
2007  				ret = irealloc_prof(tsd, ptr, old_usize, usize,
2008  				    &alloc_ctx, &hook_args);
2009  			}
2010  		} else {
2011  			if (config_stats) {
2012  				usize = sz_s2u(size);
2013  			}
2014  			ret = iralloc(tsd, ptr, old_usize, size, 0, false,
2015  			    &hook_args);
2016  		}
2017  		tsdn = tsd_tsdn(tsd);
2018  	} else {
2019  		static_opts_t sopts;
2020  		dynamic_opts_t dopts;
2021  		static_opts_init(&sopts);
2022  		dynamic_opts_init(&dopts);
2023  		sopts.null_out_result_on_error = true;
2024  		sopts.set_errno_on_error = true;
2025  		sopts.oom_string =
2026  		    "<jemalloc>: Error in realloc(): out of memory\n";
2027  		dopts.result = &ret;
2028  		dopts.num_items = 1;
2029  		dopts.item_size = size;
2030  		imalloc(&sopts, &dopts);
2031  		if (sopts.slow) {
2032  			uintptr_t args[3] = {(uintptr_t)ptr, arg_size};
2033  			hook_invoke_alloc(hook_alloc_realloc, ret,
2034  			    (uintptr_t)ret, args);
2035  		}
2036  		return ret;
2037  	}
2038  	if (unlikely(ret == NULL)) {
2039  		if (config_xmalloc && unlikely(opt_xmalloc)) {
2040  			malloc_write("<jemalloc>: Error in realloc(): "
2041  			    "out of memory\n");
2042  			abort();
2043  		}
2044  		set_errno(ENOMEM);
2045  	}
2046  	if (config_stats && likely(ret != NULL)) {
2047  		tsd_t *tsd;
2048  		assert(usize == isalloc(tsdn, ret));
2049  		tsd = tsdn_tsd(tsdn);
2050  		*tsd_thread_allocatedp_get(tsd) += usize;
2051  		*tsd_thread_deallocatedp_get(tsd) += old_usize;
2052  	}
2053  	UTRACE(ptr, size, ret);
2054  	check_entry_exit_locking(tsdn);
2055  	LOG("core.realloc.exit", "result: %p", ret);
2056  	return ret;
2057  }
2058  JEMALLOC_NOINLINE
2059  void
2060  free_default(void *ptr) {
2061  	UTRACE(ptr, 0, 0);
2062  	if (likely(ptr != NULL)) {
2063  		tsd_t *tsd = tsd_fetch_min();
2064  		check_entry_exit_locking(tsd_tsdn(tsd));
2065  		tcache_t *tcache;
2066  		if (likely(tsd_fast(tsd))) {
2067  			tsd_assert_fast(tsd);
2068  			tcache = tsd_tcachep_get(tsd);
2069  			ifree(tsd, ptr, tcache, false);
2070  		} else {
2071  			if (likely(tsd_reentrancy_level_get(tsd) == 0)) {
2072  				tcache = tcache_get(tsd);
2073  			} else {
2074  				tcache = NULL;
2075  			}
2076  			uintptr_t args_raw[3] = {(uintptr_t)ptr};
2077  			hook_invoke_dalloc(hook_dalloc_free, ptr, args_raw);
2078  			ifree(tsd, ptr, tcache, true);
2079  		}
2080  		check_entry_exit_locking(tsd_tsdn(tsd));
2081  	}
2082  }
2083  JEMALLOC_ALWAYS_INLINE
2084  bool free_fastpath(void *ptr, size_t size, bool size_hint) {
2085  	tsd_t *tsd = tsd_get(false);
2086  	if (unlikely(!tsd || !tsd_fast(tsd))) {
2087  		return false;
2088  	}
2089  	tcache_t *tcache = tsd_tcachep_get(tsd);
2090  	alloc_ctx_t alloc_ctx;
2091  	if (!size_hint || config_cache_oblivious) {
2092  		rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);
2093  		bool res = rtree_szind_slab_read_fast(tsd_tsdn(tsd), &extents_rtree,
2094  						      rtree_ctx, (uintptr_t)ptr,
2095  						      &alloc_ctx.szind, &alloc_ctx.slab);
2096  		if (!res || !alloc_ctx.slab) {
2097  			return false;
2098  		}
2099  		assert(alloc_ctx.szind != SC_NSIZES);
2100  	} else {
2101  		if (size > SC_LOOKUP_MAXCLASS || (((uintptr_t)ptr & PAGE_MASK) == 0)) {
2102  			return false;
2103  		}
2104  		alloc_ctx.szind = sz_size2index_lookup(size);
2105  	}
2106  	if (unlikely(ticker_trytick(&tcache->gc_ticker))) {
2107  		return false;
2108  	}
2109  	cache_bin_t *bin = tcache_small_bin_get(tcache, alloc_ctx.szind);
2110  	cache_bin_info_t *bin_info = &tcache_bin_info[alloc_ctx.szind];
2111  	if (!cache_bin_dalloc_easy(bin, bin_info, ptr)) {
2112  		return false;
2113  	}
2114  	if (config_stats) {
2115  		size_t usize = sz_index2size(alloc_ctx.szind);
2116  		*tsd_thread_deallocatedp_get(tsd) += usize;
2117  	}
2118  	return true;
2119  }
2120  JEMALLOC_EXPORT void JEMALLOC_NOTHROW
2121  je_free(void *ptr) {
2122  	LOG("core.free.entry", "ptr: %p", ptr);
2123  	if (!free_fastpath(ptr, 0, false)) {
2124  		free_default(ptr);
2125  	}
2126  	LOG("core.free.exit", "");
2127  }
2128  #ifdef JEMALLOC_OVERRIDE_MEMALIGN
2129  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
2130  void JEMALLOC_NOTHROW *
2131  JEMALLOC_ATTR(malloc)
2132  je_memalign(size_t alignment, size_t size) {
2133  	void *ret;
2134  	static_opts_t sopts;
2135  	dynamic_opts_t dopts;
2136  	LOG("core.memalign.entry", "alignment: %zu, size: %zu\n", alignment,
2137  	    size);
2138  	static_opts_init(&sopts);
2139  	dynamic_opts_init(&dopts);
2140  	sopts.min_alignment = 1;
2141  	sopts.oom_string =
2142  	    "<jemalloc>: Error allocating aligned memory: out of memory\n";
2143  	sopts.invalid_alignment_string =
2144  	    "<jemalloc>: Error allocating aligned memory: invalid alignment\n";
2145  	sopts.null_out_result_on_error = true;
2146  	dopts.result = &ret;
2147  	dopts.num_items = 1;
2148  	dopts.item_size = size;
2149  	dopts.alignment = alignment;
2150  	imalloc(&sopts, &dopts);
2151  	if (sopts.slow) {
2152  		uintptr_t args[3] = {alignment, size};
2153  		hook_invoke_alloc(hook_alloc_memalign, ret, (uintptr_t)ret,
2154  		    args);
2155  	}
2156  	LOG("core.memalign.exit", "result: %p", ret);
2157  	return ret;
2158  }
2159  #endif
2160  #ifdef JEMALLOC_OVERRIDE_VALLOC
2161  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
2162  void JEMALLOC_NOTHROW *
2163  JEMALLOC_ATTR(malloc)
2164  je_valloc(size_t size) {
2165  	void *ret;
2166  	static_opts_t sopts;
2167  	dynamic_opts_t dopts;
2168  	LOG("core.valloc.entry", "size: %zu\n", size);
2169  	static_opts_init(&sopts);
2170  	dynamic_opts_init(&dopts);
2171  	sopts.null_out_result_on_error = true;
2172  	sopts.min_alignment = PAGE;
2173  	sopts.oom_string =
2174  	    "<jemalloc>: Error allocating aligned memory: out of memory\n";
2175  	sopts.invalid_alignment_string =
2176  	    "<jemalloc>: Error allocating aligned memory: invalid alignment\n";
2177  	dopts.result = &ret;
2178  	dopts.num_items = 1;
2179  	dopts.item_size = size;
2180  	dopts.alignment = PAGE;
2181  	imalloc(&sopts, &dopts);
2182  	if (sopts.slow) {
2183  		uintptr_t args[3] = {size};
2184  		hook_invoke_alloc(hook_alloc_valloc, ret, (uintptr_t)ret, args);
2185  	}
2186  	LOG("core.valloc.exit", "result: %p\n", ret);
2187  	return ret;
2188  }
2189  #endif
2190  #if defined(JEMALLOC_IS_MALLOC) && defined(JEMALLOC_GLIBC_MALLOC_HOOK)
2191  JEMALLOC_EXPORT void (*__free_hook)(void *ptr) = je_free;
2192  JEMALLOC_EXPORT void *(*__malloc_hook)(size_t size) = je_malloc;
2193  JEMALLOC_EXPORT void *(*__realloc_hook)(void *ptr, size_t size) = je_realloc;
2194  #  ifdef JEMALLOC_GLIBC_MEMALIGN_HOOK
2195  JEMALLOC_EXPORT void *(*__memalign_hook)(size_t alignment, size_t size) =
2196      je_memalign;
2197  #  endif
2198  #  ifdef CPU_COUNT
2199  #    define ALIAS(je_fn)	__attribute__((alias (#je_fn), used))
2200  #    define PREALIAS(je_fn)	ALIAS(je_fn)
2201  #    ifdef JEMALLOC_OVERRIDE___LIBC_CALLOC
2202  void *__libc_calloc(size_t n, size_t size) PREALIAS(je_calloc);
2203  #    endif
2204  #    ifdef JEMALLOC_OVERRIDE___LIBC_FREE
2205  void __libc_free(void* ptr) PREALIAS(je_free);
2206  #    endif
2207  #    ifdef JEMALLOC_OVERRIDE___LIBC_MALLOC
2208  void *__libc_malloc(size_t size) PREALIAS(je_malloc);
2209  #    endif
2210  #    ifdef JEMALLOC_OVERRIDE___LIBC_MEMALIGN
2211  void *__libc_memalign(size_t align, size_t s) PREALIAS(je_memalign);
2212  #    endif
2213  #    ifdef JEMALLOC_OVERRIDE___LIBC_REALLOC
2214  void *__libc_realloc(void* ptr, size_t size) PREALIAS(je_realloc);
2215  #    endif
2216  #    ifdef JEMALLOC_OVERRIDE___LIBC_VALLOC
2217  void *__libc_valloc(size_t size) PREALIAS(je_valloc);
2218  #    endif
2219  #    ifdef JEMALLOC_OVERRIDE___POSIX_MEMALIGN
2220  int __posix_memalign(void** r, size_t a, size_t s) PREALIAS(je_posix_memalign);
2221  #    endif
2222  #    undef PREALIAS
2223  #    undef ALIAS
2224  #  endif
2225  #endif
2226  #ifdef JEMALLOC_EXPERIMENTAL_SMALLOCX_API
2227  #define JEMALLOC_SMALLOCX_CONCAT_HELPER(x, y) x ## y
2228  #define JEMALLOC_SMALLOCX_CONCAT_HELPER2(x, y)  \
2229    JEMALLOC_SMALLOCX_CONCAT_HELPER(x, y)
2230  typedef struct {
2231  	void *ptr;
2232  	size_t size;
2233  } smallocx_return_t;
2234  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
2235  smallocx_return_t JEMALLOC_NOTHROW
2236  JEMALLOC_SMALLOCX_CONCAT_HELPER2(je_smallocx_, JEMALLOC_VERSION_GID_IDENT)
2237    (size_t size, int flags) {
2238  	smallocx_return_t ret;
2239  	static_opts_t sopts;
2240  	dynamic_opts_t dopts;
2241  	LOG("core.smallocx.entry", "size: %zu, flags: %d", size, flags);
2242  	static_opts_init(&sopts);
2243  	dynamic_opts_init(&dopts);
2244  	sopts.assert_nonempty_alloc = true;
2245  	sopts.null_out_result_on_error = true;
2246  	sopts.oom_string = "<jemalloc>: Error in mallocx(): out of memory\n";
2247  	sopts.usize = true;
2248  	dopts.result = &ret.ptr;
2249  	dopts.num_items = 1;
2250  	dopts.item_size = size;
2251  	if (unlikely(flags != 0)) {
2252  		if ((flags & MALLOCX_LG_ALIGN_MASK) != 0) {
2253  			dopts.alignment = MALLOCX_ALIGN_GET_SPECIFIED(flags);
2254  		}
2255  		dopts.zero = MALLOCX_ZERO_GET(flags);
2256  		if ((flags & MALLOCX_TCACHE_MASK) != 0) {
2257  			if ((flags & MALLOCX_TCACHE_MASK)
2258  			    == MALLOCX_TCACHE_NONE) {
2259  				dopts.tcache_ind = TCACHE_IND_NONE;
2260  			} else {
2261  				dopts.tcache_ind = MALLOCX_TCACHE_GET(flags);
2262  			}
2263  		} else {
2264  			dopts.tcache_ind = TCACHE_IND_AUTOMATIC;
2265  		}
2266  		if ((flags & MALLOCX_ARENA_MASK) != 0)
2267  			dopts.arena_ind = MALLOCX_ARENA_GET(flags);
2268  	}
2269  	imalloc(&sopts, &dopts);
2270  	assert(dopts.usize == je_nallocx(size, flags));
2271  	ret.size = dopts.usize;
2272  	LOG("core.smallocx.exit", "result: %p, size: %zu", ret.ptr, ret.size);
2273  	return ret;
2274  }
2275  #undef JEMALLOC_SMALLOCX_CONCAT_HELPER
2276  #undef JEMALLOC_SMALLOCX_CONCAT_HELPER2
2277  #endif
2278  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
2279  void JEMALLOC_NOTHROW *
2280  JEMALLOC_ATTR(malloc) JEMALLOC_ALLOC_SIZE(1)
2281  je_mallocx(size_t size, int flags) {
2282  	void *ret;
2283  	static_opts_t sopts;
2284  	dynamic_opts_t dopts;
2285  	LOG("core.mallocx.entry", "size: %zu, flags: %d", size, flags);
2286  	static_opts_init(&sopts);
2287  	dynamic_opts_init(&dopts);
2288  	sopts.assert_nonempty_alloc = true;
2289  	sopts.null_out_result_on_error = true;
2290  	sopts.oom_string = "<jemalloc>: Error in mallocx(): out of memory\n";
2291  	dopts.result = &ret;
2292  	dopts.num_items = 1;
2293  	dopts.item_size = size;
2294  	if (unlikely(flags != 0)) {
2295  		if ((flags & MALLOCX_LG_ALIGN_MASK) != 0) {
2296  			dopts.alignment = MALLOCX_ALIGN_GET_SPECIFIED(flags);
2297  		}
2298  		dopts.zero = MALLOCX_ZERO_GET(flags);
2299  		if ((flags & MALLOCX_TCACHE_MASK) != 0) {
2300  			if ((flags & MALLOCX_TCACHE_MASK)
2301  			    == MALLOCX_TCACHE_NONE) {
2302  				dopts.tcache_ind = TCACHE_IND_NONE;
2303  			} else {
2304  				dopts.tcache_ind = MALLOCX_TCACHE_GET(flags);
2305  			}
2306  		} else {
2307  			dopts.tcache_ind = TCACHE_IND_AUTOMATIC;
2308  		}
2309  		if ((flags & MALLOCX_ARENA_MASK) != 0)
2310  			dopts.arena_ind = MALLOCX_ARENA_GET(flags);
2311  	}
2312  	imalloc(&sopts, &dopts);
2313  	if (sopts.slow) {
2314  		uintptr_t args[3] = {size, flags};
2315  		hook_invoke_alloc(hook_alloc_mallocx, ret, (uintptr_t)ret,
2316  		    args);
2317  	}
2318  	LOG("core.mallocx.exit", "result: %p", ret);
2319  	return ret;
2320  }
2321  static void *
2322  irallocx_prof_sample(tsdn_t *tsdn, void *old_ptr, size_t old_usize,
2323      size_t usize, size_t alignment, bool zero, tcache_t *tcache, arena_t *arena,
2324      prof_tctx_t *tctx, hook_ralloc_args_t *hook_args) {
2325  	void *p;
2326  	if (tctx == NULL) {
2327  		return NULL;
2328  	}
2329  	if (usize <= SC_SMALL_MAXCLASS) {
2330  		p = iralloct(tsdn, old_ptr, old_usize,
2331  		    SC_LARGE_MINCLASS, alignment, zero, tcache,
2332  		    arena, hook_args);
2333  		if (p == NULL) {
2334  			return NULL;
2335  		}
2336  		arena_prof_promote(tsdn, p, usize);
2337  	} else {
2338  		p = iralloct(tsdn, old_ptr, old_usize, usize, alignment, zero,
2339  		    tcache, arena, hook_args);
2340  	}
2341  	return p;
2342  }
2343  JEMALLOC_ALWAYS_INLINE void *
2344  irallocx_prof(tsd_t *tsd, void *old_ptr, size_t old_usize, size_t size,
2345      size_t alignment, size_t *usize, bool zero, tcache_t *tcache,
2346      arena_t *arena, alloc_ctx_t *alloc_ctx, hook_ralloc_args_t *hook_args) {
2347  	void *p;
2348  	bool prof_active;
2349  	prof_tctx_t *old_tctx, *tctx;
2350  	prof_active = prof_active_get_unlocked();
2351  	old_tctx = prof_tctx_get(tsd_tsdn(tsd), old_ptr, alloc_ctx);
2352  	tctx = prof_alloc_prep(tsd, *usize, prof_active, false);
2353  	if (unlikely((uintptr_t)tctx != (uintptr_t)1U)) {
2354  		p = irallocx_prof_sample(tsd_tsdn(tsd), old_ptr, old_usize,
2355  		    *usize, alignment, zero, tcache, arena, tctx, hook_args);
2356  	} else {
2357  		p = iralloct(tsd_tsdn(tsd), old_ptr, old_usize, size, alignment,
2358  		    zero, tcache, arena, hook_args);
2359  	}
2360  	if (unlikely(p == NULL)) {
2361  		prof_alloc_rollback(tsd, tctx, false);
2362  		return NULL;
2363  	}
2364  	if (p == old_ptr && alignment != 0) {
2365  		*usize = isalloc(tsd_tsdn(tsd), p);
2366  	}
2367  	prof_realloc(tsd, p, *usize, tctx, prof_active, false, old_ptr,
2368  	    old_usize, old_tctx);
2369  	return p;
2370  }
2371  JEMALLOC_EXPORT JEMALLOC_ALLOCATOR JEMALLOC_RESTRICT_RETURN
2372  void JEMALLOC_NOTHROW *
2373  JEMALLOC_ALLOC_SIZE(2)
2374  je_rallocx(void *ptr, size_t size, int flags) {
2375  	void *p;
2376  	tsd_t *tsd;
2377  	size_t usize;
2378  	size_t old_usize;
2379  	size_t alignment = MALLOCX_ALIGN_GET(flags);
2380  	bool zero = flags & MALLOCX_ZERO;
2381  	arena_t *arena;
2382  	tcache_t *tcache;
2383  	LOG("core.rallocx.entry", "ptr: %p, size: %zu, flags: %d", ptr,
2384  	    size, flags);
2385  	assert(ptr != NULL);
2386  	assert(size != 0);
2387  	assert(malloc_initialized() || IS_INITIALIZER);
2388  	tsd = tsd_fetch();
2389  	check_entry_exit_locking(tsd_tsdn(tsd));
2390  	if (unlikely((flags & MALLOCX_ARENA_MASK) != 0)) {
2391  		unsigned arena_ind = MALLOCX_ARENA_GET(flags);
2392  		arena = arena_get(tsd_tsdn(tsd), arena_ind, true);
2393  		if (unlikely(arena == NULL)) {
2394  			goto label_oom;
2395  		}
2396  	} else {
2397  		arena = NULL;
2398  	}
2399  	if (unlikely((flags & MALLOCX_TCACHE_MASK) != 0)) {
2400  		if ((flags & MALLOCX_TCACHE_MASK) == MALLOCX_TCACHE_NONE) {
2401  			tcache = NULL;
2402  		} else {
2403  			tcache = tcaches_get(tsd, MALLOCX_TCACHE_GET(flags));
2404  		}
2405  	} else {
2406  		tcache = tcache_get(tsd);
2407  	}
2408  	alloc_ctx_t alloc_ctx;
2409  	rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);
2410  	rtree_szind_slab_read(tsd_tsdn(tsd), &extents_rtree, rtree_ctx,
2411  	    (uintptr_t)ptr, true, &alloc_ctx.szind, &alloc_ctx.slab);
2412  	assert(alloc_ctx.szind != SC_NSIZES);
2413  	old_usize = sz_index2size(alloc_ctx.szind);
2414  	assert(old_usize == isalloc(tsd_tsdn(tsd), ptr));
2415  	hook_ralloc_args_t hook_args = {false, {(uintptr_t)ptr, size, flags,
2416  		0}};
2417  	if (config_prof && opt_prof) {
2418  		usize = (alignment == 0) ?
2419  		    sz_s2u(size) : sz_sa2u(size, alignment);
2420  		if (unlikely(usize == 0
2421  		    || usize > SC_LARGE_MAXCLASS)) {
2422  			goto label_oom;
2423  		}
2424  		p = irallocx_prof(tsd, ptr, old_usize, size, alignment, &usize,
2425  		    zero, tcache, arena, &alloc_ctx, &hook_args);
2426  		if (unlikely(p == NULL)) {
2427  			goto label_oom;
2428  		}
2429  	} else {
2430  		p = iralloct(tsd_tsdn(tsd), ptr, old_usize, size, alignment,
2431  		    zero, tcache, arena, &hook_args);
2432  		if (unlikely(p == NULL)) {
2433  			goto label_oom;
2434  		}
2435  		if (config_stats) {
2436  			usize = isalloc(tsd_tsdn(tsd), p);
2437  		}
2438  	}
2439  	assert(alignment == 0 || ((uintptr_t)p & (alignment - 1)) == ZU(0));
2440  	if (config_stats) {
2441  		*tsd_thread_allocatedp_get(tsd) += usize;
2442  		*tsd_thread_deallocatedp_get(tsd) += old_usize;
2443  	}
2444  	UTRACE(ptr, size, p);
2445  	check_entry_exit_locking(tsd_tsdn(tsd));
2446  	LOG("core.rallocx.exit", "result: %p", p);
2447  	return p;
2448  label_oom:
2449  	if (config_xmalloc && unlikely(opt_xmalloc)) {
2450  		malloc_write("<jemalloc>: Error in rallocx(): out of memory\n");
2451  		abort();
2452  	}
2453  	UTRACE(ptr, size, 0);
2454  	check_entry_exit_locking(tsd_tsdn(tsd));
2455  	LOG("core.rallocx.exit", "result: %p", NULL);
2456  	return NULL;
2457  }
2458  JEMALLOC_ALWAYS_INLINE size_t
2459  ixallocx_helper(tsdn_t *tsdn, void *ptr, size_t old_usize, size_t size,
2460      size_t extra, size_t alignment, bool zero) {
2461  	size_t newsize;
2462  	if (ixalloc(tsdn, ptr, old_usize, size, extra, alignment, zero,
2463  	    &newsize)) {
2464  		return old_usize;
2465  	}
2466  	return newsize;
2467  }
2468  static size_t
2469  ixallocx_prof_sample(tsdn_t *tsdn, void *ptr, size_t old_usize, size_t size,
2470      size_t extra, size_t alignment, bool zero, prof_tctx_t *tctx) {
2471  	size_t usize;
2472  	if (tctx == NULL) {
2473  		return old_usize;
2474  	}
2475  	usize = ixallocx_helper(tsdn, ptr, old_usize, size, extra, alignment,
2476  	    zero);
2477  	return usize;
2478  }
2479  JEMALLOC_ALWAYS_INLINE size_t
2480  ixallocx_prof(tsd_t *tsd, void *ptr, size_t old_usize, size_t size,
2481      size_t extra, size_t alignment, bool zero, alloc_ctx_t *alloc_ctx) {
2482  	size_t usize_max, usize;
2483  	bool prof_active;
2484  	prof_tctx_t *old_tctx, *tctx;
2485  	prof_active = prof_active_get_unlocked();
2486  	old_tctx = prof_tctx_get(tsd_tsdn(tsd), ptr, alloc_ctx);
2487  	if (alignment == 0) {
2488  		usize_max = sz_s2u(size+extra);
2489  		assert(usize_max > 0
2490  		    && usize_max <= SC_LARGE_MAXCLASS);
2491  	} else {
2492  		usize_max = sz_sa2u(size+extra, alignment);
2493  		if (unlikely(usize_max == 0
2494  		    || usize_max > SC_LARGE_MAXCLASS)) {
2495  			usize_max = SC_LARGE_MAXCLASS;
2496  		}
2497  	}
2498  	tctx = prof_alloc_prep(tsd, usize_max, prof_active, false);
2499  	if (unlikely((uintptr_t)tctx != (uintptr_t)1U)) {
2500  		usize = ixallocx_prof_sample(tsd_tsdn(tsd), ptr, old_usize,
2501  		    size, extra, alignment, zero, tctx);
2502  	} else {
2503  		usize = ixallocx_helper(tsd_tsdn(tsd), ptr, old_usize, size,
2504  		    extra, alignment, zero);
2505  	}
2506  	if (usize == old_usize) {
2507  		prof_alloc_rollback(tsd, tctx, false);
2508  		return usize;
2509  	}
2510  	prof_realloc(tsd, ptr, usize, tctx, prof_active, false, ptr, old_usize,
2511  	    old_tctx);
2512  	return usize;
2513  }
2514  JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW
2515  je_xallocx(void *ptr, size_t size, size_t extra, int flags) {
2516  	tsd_t *tsd;
2517  	size_t usize, old_usize;
2518  	size_t alignment = MALLOCX_ALIGN_GET(flags);
2519  	bool zero = flags & MALLOCX_ZERO;
2520  	LOG("core.xallocx.entry", "ptr: %p, size: %zu, extra: %zu, "
2521  	    "flags: %d", ptr, size, extra, flags);
2522  	assert(ptr != NULL);
2523  	assert(size != 0);
2524  	assert(SIZE_T_MAX - size >= extra);
2525  	assert(malloc_initialized() || IS_INITIALIZER);
2526  	tsd = tsd_fetch();
2527  	check_entry_exit_locking(tsd_tsdn(tsd));
2528  	alloc_ctx_t alloc_ctx;
2529  	rtree_ctx_t *rtree_ctx = tsd_rtree_ctx(tsd);
2530  	rtree_szind_slab_read(tsd_tsdn(tsd), &extents_rtree, rtree_ctx,
2531  	    (uintptr_t)ptr, true, &alloc_ctx.szind, &alloc_ctx.slab);
2532  	assert(alloc_ctx.szind != SC_NSIZES);
2533  	old_usize = sz_index2size(alloc_ctx.szind);
2534  	assert(old_usize == isalloc(tsd_tsdn(tsd), ptr));
2535  	if (unlikely(size > SC_LARGE_MAXCLASS)) {
2536  		usize = old_usize;
2537  		goto label_not_resized;
2538  	}
2539  	if (unlikely(SC_LARGE_MAXCLASS - size < extra)) {
2540  		extra = SC_LARGE_MAXCLASS - size;
2541  	}
2542  	if (config_prof && opt_prof) {
2543  		usize = ixallocx_prof(tsd, ptr, old_usize, size, extra,
2544  		    alignment, zero, &alloc_ctx);
2545  	} else {
2546  		usize = ixallocx_helper(tsd_tsdn(tsd), ptr, old_usize, size,
2547  		    extra, alignment, zero);
2548  	}
2549  	if (unlikely(usize == old_usize)) {
2550  		goto label_not_resized;
2551  	}
2552  	if (config_stats) {
2553  		*tsd_thread_allocatedp_get(tsd) += usize;
2554  		*tsd_thread_deallocatedp_get(tsd) += old_usize;
2555  	}
2556  label_not_resized:
2557  	if (unlikely(!tsd_fast(tsd))) {
2558  		uintptr_t args[4] = {(uintptr_t)ptr, size, extra, flags};
2559  		hook_invoke_expand(hook_expand_xallocx, ptr, old_usize,
2560  		    usize, (uintptr_t)usize, args);
2561  	}
2562  	UTRACE(ptr, size, ptr);
2563  	check_entry_exit_locking(tsd_tsdn(tsd));
2564  	LOG("core.xallocx.exit", "result: %zu", usize);
2565  	return usize;
2566  }
2567  JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW
2568  JEMALLOC_ATTR(pure)
2569  je_sallocx(const void *ptr, int flags) {
2570  	size_t usize;
2571  	tsdn_t *tsdn;
2572  	LOG("core.sallocx.entry", "ptr: %p, flags: %d", ptr, flags);
2573  	assert(malloc_initialized() || IS_INITIALIZER);
2574  	assert(ptr != NULL);
2575  	tsdn = tsdn_fetch();
2576  	check_entry_exit_locking(tsdn);
2577  	if (config_debug || force_ivsalloc) {
2578  		usize = ivsalloc(tsdn, ptr);
2579  		assert(force_ivsalloc || usize != 0);
2580  	} else {
2581  		usize = isalloc(tsdn, ptr);
2582  	}
2583  	check_entry_exit_locking(tsdn);
2584  	LOG("core.sallocx.exit", "result: %zu", usize);
2585  	return usize;
2586  }
2587  JEMALLOC_EXPORT void JEMALLOC_NOTHROW
2588  je_dallocx(void *ptr, int flags) {
2589  	LOG("core.dallocx.entry", "ptr: %p, flags: %d", ptr, flags);
2590  	assert(ptr != NULL);
2591  	assert(malloc_initialized() || IS_INITIALIZER);
2592  	tsd_t *tsd = tsd_fetch();
2593  	bool fast = tsd_fast(tsd);
2594  	check_entry_exit_locking(tsd_tsdn(tsd));
2595  	tcache_t *tcache;
2596  	if (unlikely((flags & MALLOCX_TCACHE_MASK) != 0)) {
2597  		assert(tsd_reentrancy_level_get(tsd) == 0);
2598  		if ((flags & MALLOCX_TCACHE_MASK) == MALLOCX_TCACHE_NONE) {
2599  			tcache = NULL;
2600  		} else {
2601  			tcache = tcaches_get(tsd, MALLOCX_TCACHE_GET(flags));
2602  		}
2603  	} else {
2604  		if (likely(fast)) {
2605  			tcache = tsd_tcachep_get(tsd);
2606  			assert(tcache == tcache_get(tsd));
2607  		} else {
2608  			if (likely(tsd_reentrancy_level_get(tsd) == 0)) {
2609  				tcache = tcache_get(tsd);
2610  			}  else {
2611  				tcache = NULL;
2612  			}
2613  		}
2614  	}
2615  	UTRACE(ptr, 0, 0);
2616  	if (likely(fast)) {
2617  		tsd_assert_fast(tsd);
2618  		ifree(tsd, ptr, tcache, false);
2619  	} else {
2620  		uintptr_t args_raw[3] = {(uintptr_t)ptr, flags};
2621  		hook_invoke_dalloc(hook_dalloc_dallocx, ptr, args_raw);
2622  		ifree(tsd, ptr, tcache, true);
2623  	}
2624  	check_entry_exit_locking(tsd_tsdn(tsd));
2625  	LOG("core.dallocx.exit", "");
2626  }
2627  JEMALLOC_ALWAYS_INLINE size_t
2628  inallocx(tsdn_t *tsdn, size_t size, int flags) {
2629  	check_entry_exit_locking(tsdn);
2630  	size_t usize;
2631  	if (likely((flags & MALLOCX_LG_ALIGN_MASK) == 0)) {
2632  		usize = sz_s2u(size);
2633  	} else {
2634  		usize = sz_sa2u(size, MALLOCX_ALIGN_GET_SPECIFIED(flags));
2635  	}
2636  	check_entry_exit_locking(tsdn);
2637  	return usize;
2638  }
2639  JEMALLOC_NOINLINE void
2640  sdallocx_default(void *ptr, size_t size, int flags) {
2641  	assert(ptr != NULL);
2642  	assert(malloc_initialized() || IS_INITIALIZER);
2643  	tsd_t *tsd = tsd_fetch();
2644  	bool fast = tsd_fast(tsd);
2645  	size_t usize = inallocx(tsd_tsdn(tsd), size, flags);
2646  	assert(usize == isalloc(tsd_tsdn(tsd), ptr));
2647  	check_entry_exit_locking(tsd_tsdn(tsd));
2648  	tcache_t *tcache;
2649  	if (unlikely((flags & MALLOCX_TCACHE_MASK) != 0)) {
2650  		assert(tsd_reentrancy_level_get(tsd) == 0);
2651  		if ((flags & MALLOCX_TCACHE_MASK) == MALLOCX_TCACHE_NONE) {
2652  			tcache = NULL;
2653  		} else {
2654  			tcache = tcaches_get(tsd, MALLOCX_TCACHE_GET(flags));
2655  		}
2656  	} else {
2657  		if (likely(fast)) {
2658  			tcache = tsd_tcachep_get(tsd);
2659  			assert(tcache == tcache_get(tsd));
2660  		} else {
2661  			if (likely(tsd_reentrancy_level_get(tsd) == 0)) {
2662  				tcache = tcache_get(tsd);
2663  			} else {
2664  				tcache = NULL;
2665  			}
2666  		}
2667  	}
2668  	UTRACE(ptr, 0, 0);
2669  	if (likely(fast)) {
2670  		tsd_assert_fast(tsd);
2671  		isfree(tsd, ptr, usize, tcache, false);
2672  	} else {
2673  		uintptr_t args_raw[3] = {(uintptr_t)ptr, size, flags};
2674  		hook_invoke_dalloc(hook_dalloc_sdallocx, ptr, args_raw);
2675  		isfree(tsd, ptr, usize, tcache, true);
2676  	}
2677  	check_entry_exit_locking(tsd_tsdn(tsd));
2678  }
2679  JEMALLOC_EXPORT void JEMALLOC_NOTHROW
2680  je_sdallocx(void *ptr, size_t size, int flags) {
2681  	LOG("core.sdallocx.entry", "ptr: %p, size: %zu, flags: %d", ptr,
2682  		size, flags);
2683  	if (flags !=0 || !free_fastpath(ptr, size, true)) {
2684  		sdallocx_default(ptr, size, flags);
2685  	}
2686  	LOG("core.sdallocx.exit", "");
2687  }
2688  void JEMALLOC_NOTHROW
2689  je_sdallocx_noflags(void *ptr, size_t size) {
2690  	LOG("core.sdallocx.entry", "ptr: %p, size: %zu, flags: 0", ptr,
2691  		size);
2692  	if (!free_fastpath(ptr, size, true)) {
2693  		sdallocx_default(ptr, size, 0);
2694  	}
2695  	LOG("core.sdallocx.exit", "");
2696  }
2697  JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW
2698  JEMALLOC_ATTR(pure)
2699  je_nallocx(size_t size, int flags) {
2700  	size_t usize;
2701  	tsdn_t *tsdn;
2702  	assert(size != 0);
2703  	if (unlikely(malloc_init())) {
2704  		LOG("core.nallocx.exit", "result: %zu", ZU(0));
2705  		return 0;
2706  	}
2707  	tsdn = tsdn_fetch();
2708  	check_entry_exit_locking(tsdn);
2709  	usize = inallocx(tsdn, size, flags);
2710  	if (unlikely(usize > SC_LARGE_MAXCLASS)) {
2711  		LOG("core.nallocx.exit", "result: %zu", ZU(0));
2712  		return 0;
2713  	}
2714  	check_entry_exit_locking(tsdn);
2715  	LOG("core.nallocx.exit", "result: %zu", usize);
2716  	return usize;
2717  }
2718  JEMALLOC_EXPORT int JEMALLOC_NOTHROW
2719  je_mallctl(const char *name, void *oldp, size_t *oldlenp, void *newp,
2720      size_t newlen) {
2721  	int ret;
2722  	tsd_t *tsd;
2723  	LOG("core.mallctl.entry", "name: %s", name);
2724  	if (unlikely(malloc_init())) {
2725  		LOG("core.mallctl.exit", "result: %d", EAGAIN);
2726  		return EAGAIN;
2727  	}
2728  	tsd = tsd_fetch();
2729  	check_entry_exit_locking(tsd_tsdn(tsd));
2730  	ret = ctl_byname(tsd, name, oldp, oldlenp, newp, newlen);
2731  	check_entry_exit_locking(tsd_tsdn(tsd));
2732  	LOG("core.mallctl.exit", "result: %d", ret);
2733  	return ret;
2734  }
2735  JEMALLOC_EXPORT int JEMALLOC_NOTHROW
2736  je_mallctlnametomib(const char *name, size_t *mibp, size_t *miblenp) {
2737  	int ret;
2738  	LOG("core.mallctlnametomib.entry", "name: %s", name);
2739  	if (unlikely(malloc_init())) {
2740  		LOG("core.mallctlnametomib.exit", "result: %d", EAGAIN);
2741  		return EAGAIN;
2742  	}
2743  	tsd_t *tsd = tsd_fetch();
2744  	check_entry_exit_locking(tsd_tsdn(tsd));
2745  	ret = ctl_nametomib(tsd, name, mibp, miblenp);
2746  	check_entry_exit_locking(tsd_tsdn(tsd));
2747  	LOG("core.mallctlnametomib.exit", "result: %d", ret);
2748  	return ret;
2749  }
2750  JEMALLOC_EXPORT int JEMALLOC_NOTHROW
2751  je_mallctlbymib(const size_t *mib, size_t miblen, void *oldp, size_t *oldlenp,
2752    void *newp, size_t newlen) {
2753  	int ret;
2754  	tsd_t *tsd;
2755  	LOG("core.mallctlbymib.entry", "");
2756  	if (unlikely(malloc_init())) {
2757  		LOG("core.mallctlbymib.exit", "result: %d", EAGAIN);
2758  		return EAGAIN;
2759  	}
2760  	tsd = tsd_fetch();
2761  	check_entry_exit_locking(tsd_tsdn(tsd));
2762  	ret = ctl_bymib(tsd, mib, miblen, oldp, oldlenp, newp, newlen);
2763  	check_entry_exit_locking(tsd_tsdn(tsd));
2764  	LOG("core.mallctlbymib.exit", "result: %d", ret);
2765  	return ret;
2766  }
2767  JEMALLOC_EXPORT void JEMALLOC_NOTHROW
2768  je_malloc_stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
2769      const char *opts) {
2770  	tsdn_t *tsdn;
2771  	LOG("core.malloc_stats_print.entry", "");
2772  	tsdn = tsdn_fetch();
2773  	check_entry_exit_locking(tsdn);
2774  	stats_print(write_cb, cbopaque, opts);
2775  	check_entry_exit_locking(tsdn);
2776  	LOG("core.malloc_stats_print.exit", "");
2777  }
2778  JEMALLOC_EXPORT size_t JEMALLOC_NOTHROW
2779  je_malloc_usable_size(JEMALLOC_USABLE_SIZE_CONST void *ptr) {
2780  	size_t ret;
2781  	tsdn_t *tsdn;
2782  	LOG("core.malloc_usable_size.entry", "ptr: %p", ptr);
2783  	assert(malloc_initialized() || IS_INITIALIZER);
2784  	tsdn = tsdn_fetch();
2785  	check_entry_exit_locking(tsdn);
2786  	if (unlikely(ptr == NULL)) {
2787  		ret = 0;
2788  	} else {
2789  		if (config_debug || force_ivsalloc) {
2790  			ret = ivsalloc(tsdn, ptr);
2791  			assert(force_ivsalloc || ret != 0);
2792  		} else {
2793  			ret = isalloc(tsdn, ptr);
2794  		}
2795  	}
2796  	check_entry_exit_locking(tsdn);
2797  	LOG("core.malloc_usable_size.exit", "result: %zu", ret);
2798  	return ret;
2799  }
2800  #ifndef JEMALLOC_JET
2801  JEMALLOC_ATTR(constructor)
2802  static void
2803  jemalloc_constructor(void) {
2804  	malloc_init();
2805  }
2806  #endif
2807  #ifndef JEMALLOC_MUTEX_INIT_CB
2808  void
2809  jemalloc_prefork(void)
2810  #else
2811  JEMALLOC_EXPORT void
2812  _malloc_prefork(void)
2813  #endif
2814  {
2815  	tsd_t *tsd;
2816  	unsigned i, j, narenas;
2817  	arena_t *arena;
2818  #ifdef JEMALLOC_MUTEX_INIT_CB
2819  	if (!malloc_initialized()) {
2820  		return;
2821  	}
2822  #endif
2823  	assert(malloc_initialized());
2824  	tsd = tsd_fetch();
2825  	narenas = narenas_total_get();
2826  	witness_prefork(tsd_witness_tsdp_get(tsd));
2827  	ctl_prefork(tsd_tsdn(tsd));
2828  	tcache_prefork(tsd_tsdn(tsd));
2829  	malloc_mutex_prefork(tsd_tsdn(tsd), &arenas_lock);
2830  	if (have_background_thread) {
2831  		background_thread_prefork0(tsd_tsdn(tsd));
2832  	}
2833  	prof_prefork0(tsd_tsdn(tsd));
2834  	if (have_background_thread) {
2835  		background_thread_prefork1(tsd_tsdn(tsd));
2836  	}
2837  	for (i = 0; i < 8; i++) {
2838  		for (j = 0; j < narenas; j++) {
2839  			if ((arena = arena_get(tsd_tsdn(tsd), j, false)) !=
2840  			    NULL) {
2841  				switch (i) {
2842  				case 0:
2843  					arena_prefork0(tsd_tsdn(tsd), arena);
2844  					break;
2845  				case 1:
2846  					arena_prefork1(tsd_tsdn(tsd), arena);
2847  					break;
2848  				case 2:
2849  					arena_prefork2(tsd_tsdn(tsd), arena);
2850  					break;
2851  				case 3:
2852  					arena_prefork3(tsd_tsdn(tsd), arena);
2853  					break;
2854  				case 4:
2855  					arena_prefork4(tsd_tsdn(tsd), arena);
2856  					break;
2857  				case 5:
2858  					arena_prefork5(tsd_tsdn(tsd), arena);
2859  					break;
2860  				case 6:
2861  					arena_prefork6(tsd_tsdn(tsd), arena);
2862  					break;
2863  				case 7:
2864  					arena_prefork7(tsd_tsdn(tsd), arena);
2865  					break;
2866  				default: not_reached();
2867  				}
2868  			}
2869  		}
2870  	}
2871  	prof_prefork1(tsd_tsdn(tsd));
2872  	tsd_prefork(tsd);
2873  }
2874  #ifndef JEMALLOC_MUTEX_INIT_CB
2875  void
2876  jemalloc_postfork_parent(void)
2877  #else
2878  JEMALLOC_EXPORT void
2879  _malloc_postfork(void)
2880  #endif
2881  {
2882  	tsd_t *tsd;
2883  	unsigned i, narenas;
2884  #ifdef JEMALLOC_MUTEX_INIT_CB
2885  	if (!malloc_initialized()) {
2886  		return;
2887  	}
2888  #endif
2889  	assert(malloc_initialized());
2890  	tsd = tsd_fetch();
2891  	tsd_postfork_parent(tsd);
2892  	witness_postfork_parent(tsd_witness_tsdp_get(tsd));
2893  	for (i = 0, narenas = narenas_total_get(); i < narenas; i++) {
2894  		arena_t *arena;
2895  		if ((arena = arena_get(tsd_tsdn(tsd), i, false)) != NULL) {
2896  			arena_postfork_parent(tsd_tsdn(tsd), arena);
2897  		}
2898  	}
2899  	prof_postfork_parent(tsd_tsdn(tsd));
2900  	if (have_background_thread) {
2901  		background_thread_postfork_parent(tsd_tsdn(tsd));
2902  	}
2903  	malloc_mutex_postfork_parent(tsd_tsdn(tsd), &arenas_lock);
2904  	tcache_postfork_parent(tsd_tsdn(tsd));
2905  	ctl_postfork_parent(tsd_tsdn(tsd));
2906  }
2907  void
2908  jemalloc_postfork_child(void) {
2909  	tsd_t *tsd;
2910  	unsigned i, narenas;
2911  	assert(malloc_initialized());
2912  	tsd = tsd_fetch();
2913  	tsd_postfork_child(tsd);
2914  	witness_postfork_child(tsd_witness_tsdp_get(tsd));
2915  	for (i = 0, narenas = narenas_total_get(); i < narenas; i++) {
2916  		arena_t *arena;
2917  		if ((arena = arena_get(tsd_tsdn(tsd), i, false)) != NULL) {
2918  			arena_postfork_child(tsd_tsdn(tsd), arena);
2919  		}
2920  	}
2921  	prof_postfork_child(tsd_tsdn(tsd));
2922  	if (have_background_thread) {
2923  		background_thread_postfork_child(tsd_tsdn(tsd));
2924  	}
2925  	malloc_mutex_postfork_child(tsd_tsdn(tsd), &arenas_lock);
2926  	tcache_postfork_child(tsd_tsdn(tsd));
2927  	ctl_postfork_child(tsd_tsdn(tsd));
2928  }
2929  JEMALLOC_EXPORT int JEMALLOC_NOTHROW
2930  je_get_defrag_hint(void* ptr, int *bin_util, int *run_util) {
2931  	assert(ptr != NULL);
2932  	return iget_defrag_hint(TSDN_NULL, ptr, bin_util, run_util);
2933  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-des.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-jemalloc.c</div>
                </div>
                <div class="column column_space"><pre><code>1353      int cur_round;
1354      leftt = block[0];
1355      right = block[1];
1356  #ifdef LTC_SMALL_CODE
1357      work = ((leftt >> 4)  ^ right) & 0x0f0f0f0fL;
1358      right ^= work;
1359      leftt ^= (work << 4);
1360      work = ((leftt >> 16) ^ right) & 0x0000ffffL;
1361      right ^= work;
</pre></code></div>
                <div class="column column_space"><pre><code>1434  	dynamic_opts->result = NULL;
1435  	dynamic_opts->usize = 0;
1436  	dynamic_opts->num_items = 0;
1437  	dynamic_opts->item_size = 0;
1438  	dynamic_opts->alignment = 0;
1439  	dynamic_opts->zero = false;
1440  	dynamic_opts->tcache_ind = TCACHE_IND_AUTOMATIC;
1441  	dynamic_opts->arena_ind = ARENA_IND_AUTOMATIC;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    