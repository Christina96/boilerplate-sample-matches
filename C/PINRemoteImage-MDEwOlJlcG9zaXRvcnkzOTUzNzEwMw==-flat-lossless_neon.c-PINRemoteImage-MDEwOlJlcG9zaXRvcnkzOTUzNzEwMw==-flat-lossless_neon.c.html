
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 28, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_neon.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_NEON)
3  #include <arm_neon.h>
4  #include "src/dsp/lossless.h"
5  #include "src/dsp/neon.h"
6  #if !defined(WORK_AROUND_GCC)
7  static void ConvertBGRAToRGBA_NEON(const uint32_t* src,
8                                     int num_pixels, uint8_t* dst) {
9    const uint32_t* const end = src + (num_pixels & ~15);
10    for (; src < end; src += 16) {
11      uint8x16x4_t pixel = vld4q_u8((uint8_t*)src);
12      const uint8x16_t tmp = pixel.val[0];
13      pixel.val[0] = pixel.val[2];
14      pixel.val[2] = tmp;
15      vst4q_u8(dst, pixel);
16      dst += 64;
17    }
18    VP8LConvertBGRAToRGBA_C(src, num_pixels & 15, dst);  
19  }
20  static void ConvertBGRAToBGR_NEON(const uint32_t* src,
21                                    int num_pixels, uint8_t* dst) {
22    const uint32_t* const end = src + (num_pixels & ~15);
23    for (; src < end; src += 16) {
24      const uint8x16x4_t pixel = vld4q_u8((uint8_t*)src);
25      const uint8x16x3_t tmp = { { pixel.val[0], pixel.val[1], pixel.val[2] } };
26      vst3q_u8(dst, tmp);
27      dst += 48;
28    }
29    VP8LConvertBGRAToBGR_C(src, num_pixels & 15, dst);  
30  }
31  static void ConvertBGRAToRGB_NEON(const uint32_t* src,
32                                    int num_pixels, uint8_t* dst) {
33    const uint32_t* const end = src + (num_pixels & ~15);
34    for (; src < end; src += 16) {
35      const uint8x16x4_t pixel = vld4q_u8((uint8_t*)src);
36      const uint8x16x3_t tmp = { { pixel.val[2], pixel.val[1], pixel.val[0] } };
37      vst3q_u8(dst, tmp);
38      dst += 48;
39    }
40    VP8LConvertBGRAToRGB_C(src, num_pixels & 15, dst);  
41  }
42  #else  
43  static const uint8_t kRGBAShuffle[8] = { 2, 1, 0, 3, 6, 5, 4, 7 };
44  static void ConvertBGRAToRGBA_NEON(const uint32_t* src,
45                                     int num_pixels, uint8_t* dst) {
46    const uint32_t* const end = src + (num_pixels & ~1);
47    const uint8x8_t shuffle = vld1_u8(kRGBAShuffle);
48    for (; src < end; src += 2) {
49      const uint8x8_t pixels = vld1_u8((uint8_t*)src);
50      vst1_u8(dst, vtbl1_u8(pixels, shuffle));
51      dst += 8;
52    }
53    VP8LConvertBGRAToRGBA_C(src, num_pixels & 1, dst);  
54  }
55  static const uint8_t kBGRShuffle[3][8] = {
56    {  0,  1,  2,  4,  5,  6,  8,  9 },
57    { 10, 12, 13, 14, 16, 17, 18, 20 },
58    { 21, 22, 24, 25, 26, 28, 29, 30 }
59  };
60  static void ConvertBGRAToBGR_NEON(const uint32_t* src,
61                                    int num_pixels, uint8_t* dst) {
62    const uint32_t* const end = src + (num_pixels & ~7);
63    const uint8x8_t shuffle0 = vld1_u8(kBGRShuffle[0]);
64    const uint8x8_t shuffle1 = vld1_u8(kBGRShuffle[1]);
65    const uint8x8_t shuffle2 = vld1_u8(kBGRShuffle[2]);
66    for (; src < end; src += 8) {
67      uint8x8x4_t pixels;
68      INIT_VECTOR4(pixels,
69                   vld1_u8((const uint8_t*)(src + 0)),
70                   vld1_u8((const uint8_t*)(src + 2)),
71                   vld1_u8((const uint8_t*)(src + 4)),
72                   vld1_u8((const uint8_t*)(src + 6)));
73      vst1_u8(dst +  0, vtbl4_u8(pixels, shuffle0));
74      vst1_u8(dst +  8, vtbl4_u8(pixels, shuffle1));
75      vst1_u8(dst + 16, vtbl4_u8(pixels, shuffle2));
76      dst += 8 * 3;
77    }
78    VP8LConvertBGRAToBGR_C(src, num_pixels & 7, dst);  
79  }
80  static const uint8_t kRGBShuffle[3][8] = {
81    {  2,  1,  0,  6,  5,  4, 10,  9 },
82    {  8, 14, 13, 12, 18, 17, 16, 22 },
83    { 21, 20, 26, 25, 24, 30, 29, 28 }
84  };
85  static void ConvertBGRAToRGB_NEON(const uint32_t* src,
86                                    int num_pixels, uint8_t* dst) {
87    const uint32_t* const end = src + (num_pixels & ~7);
88    const uint8x8_t shuffle0 = vld1_u8(kRGBShuffle[0]);
89    const uint8x8_t shuffle1 = vld1_u8(kRGBShuffle[1]);
90    const uint8x8_t shuffle2 = vld1_u8(kRGBShuffle[2]);
91    for (; src < end; src += 8) {
92      uint8x8x4_t pixels;
93      INIT_VECTOR4(pixels,
94                   vld1_u8((const uint8_t*)(src + 0)),
95                   vld1_u8((const uint8_t*)(src + 2)),
96                   vld1_u8((const uint8_t*)(src + 4)),
97                   vld1_u8((const uint8_t*)(src + 6)));
<span onclick='openModal()' class='match'>98      vst1_u8(dst +  0, vtbl4_u8(pixels, shuffle0));
99      vst1_u8(dst +  8, vtbl4_u8(pixels, shuffle1));
100      vst1_u8(dst + 16, vtbl4_u8(pixels, shuffle2));
</span>101      dst += 8 * 3;
102    }
103    VP8LConvertBGRAToRGB_C(src, num_pixels & 7, dst);  
104  }
105  #endif   
106  #define LOAD_U32_AS_U8(IN) vreinterpret_u8_u32(vdup_n_u32((IN)))
107  #define LOAD_U32P_AS_U8(IN) vreinterpret_u8_u32(vld1_u32((IN)))
108  #define LOADQ_U32_AS_U8(IN) vreinterpretq_u8_u32(vdupq_n_u32((IN)))
109  #define LOADQ_U32P_AS_U8(IN) vreinterpretq_u8_u32(vld1q_u32((IN)))
110  #define GET_U8_AS_U32(IN) vget_lane_u32(vreinterpret_u32_u8((IN)), 0);
111  #define GETQ_U8_AS_U32(IN) vgetq_lane_u32(vreinterpretq_u32_u8((IN)), 0);
112  #define STOREQ_U8_AS_U32P(OUT, IN) vst1q_u32((OUT), vreinterpretq_u32_u8((IN)));
113  #define ROTATE32_LEFT(L) vextq_u8((L), (L), 12)    
114  static WEBP_INLINE uint8x8_t Average2_u8_NEON(uint32_t a0, uint32_t a1) {
115    const uint8x8_t A0 = LOAD_U32_AS_U8(a0);
116    const uint8x8_t A1 = LOAD_U32_AS_U8(a1);
117    return vhadd_u8(A0, A1);
118  }
119  static WEBP_INLINE uint32_t ClampedAddSubtractHalf_NEON(uint32_t c0,
120                                                          uint32_t c1,
121                                                          uint32_t c2) {
122    const uint8x8_t avg = Average2_u8_NEON(c0, c1);
123    const uint8x8_t C2 = LOAD_U32_AS_U8(c2);
124    const uint8x8_t cmp = vcgt_u8(C2, avg);
125    const uint8x8_t C2_1 = vadd_u8(C2, cmp);
126    const int8x8_t diff_avg = vreinterpret_s8_u8(vhsub_u8(avg, C2_1));
127    const int16x8_t avg_16 = vreinterpretq_s16_u16(vmovl_u8(avg));
128    const uint8x8_t res = vqmovun_s16(vaddw_s8(avg_16, diff_avg));
129    const uint32_t output = GET_U8_AS_U32(res);
130    return output;
131  }
132  static WEBP_INLINE uint32_t Average2_NEON(uint32_t a0, uint32_t a1) {
133    const uint8x8_t avg_u8x8 = Average2_u8_NEON(a0, a1);
134    const uint32_t avg = GET_U8_AS_U32(avg_u8x8);
135    return avg;
136  }
137  static WEBP_INLINE uint32_t Average3_NEON(uint32_t a0, uint32_t a1,
138                                            uint32_t a2) {
139    const uint8x8_t avg0 = Average2_u8_NEON(a0, a2);
140    const uint8x8_t A1 = LOAD_U32_AS_U8(a1);
141    const uint32_t avg = GET_U8_AS_U32(vhadd_u8(avg0, A1));
142    return avg;
143  }
144  static uint32_t Predictor5_NEON(uint32_t left, const uint32_t* const top) {
145    return Average3_NEON(left, top[0], top[1]);
146  }
147  static uint32_t Predictor6_NEON(uint32_t left, const uint32_t* const top) {
148    return Average2_NEON(left, top[-1]);
149  }
150  static uint32_t Predictor7_NEON(uint32_t left, const uint32_t* const top) {
151    return Average2_NEON(left, top[0]);
152  }
153  static uint32_t Predictor13_NEON(uint32_t left, const uint32_t* const top) {
154    return ClampedAddSubtractHalf_NEON(left, top[0], top[-1]);
155  }
156  static void PredictorAdd0_NEON(const uint32_t* in, const uint32_t* upper,
157                                 int num_pixels, uint32_t* out) {
158    int i;
159    const uint8x16_t black = vreinterpretq_u8_u32(vdupq_n_u32(ARGB_BLACK));
160    for (i = 0; i + 4 <= num_pixels; i += 4) {
161      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
162      const uint8x16_t res = vaddq_u8(src, black);
163      STOREQ_U8_AS_U32P(&out[i], res);
164    }
165    VP8LPredictorsAdd_C[0](in + i, upper + i, num_pixels - i, out + i);
166  }
167  static void PredictorAdd1_NEON(const uint32_t* in, const uint32_t* upper,
168                                 int num_pixels, uint32_t* out) {
169    int i;
170    const uint8x16_t zero = LOADQ_U32_AS_U8(0);
171    for (i = 0; i + 4 <= num_pixels; i += 4) {
172      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
173      const uint8x16_t shift0 = vextq_u8(zero, src, 12);
174      const uint8x16_t sum0 = vaddq_u8(src, shift0);
175      const uint8x16_t shift1 = vextq_u8(zero, sum0, 8);
176      const uint8x16_t sum1 = vaddq_u8(sum0, shift1);
177      const uint8x16_t prev = LOADQ_U32_AS_U8(out[i - 1]);
178      const uint8x16_t res = vaddq_u8(sum1, prev);
179      STOREQ_U8_AS_U32P(&out[i], res);
180    }
181    VP8LPredictorsAdd_C[1](in + i, upper + i, num_pixels - i, out + i);
182  }
183  #define GENERATE_PREDICTOR_1(X, IN)                                       \
184  static void PredictorAdd##X##_NEON(const uint32_t* in,                    \
185                                     const uint32_t* upper, int num_pixels, \
186                                     uint32_t* out) {                       \
187    int i;                                                                  \
188    for (i = 0; i + 4 <= num_pixels; i += 4) {                              \
189      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);                      \
190      const uint8x16_t other = LOADQ_U32P_AS_U8(&(IN));                     \
191      const uint8x16_t res = vaddq_u8(src, other);                          \
192      STOREQ_U8_AS_U32P(&out[i], res);                                      \
193    }                                                                       \
194    VP8LPredictorsAdd_C[(X)](in + i, upper + i, num_pixels - i, out + i);   \
195  }
196  GENERATE_PREDICTOR_1(2, upper[i])
197  GENERATE_PREDICTOR_1(3, upper[i + 1])
198  GENERATE_PREDICTOR_1(4, upper[i - 1])
199  #undef GENERATE_PREDICTOR_1
200  #define DO_PRED5(LANE) do {                                              \
201    const uint8x16_t avgLTR = vhaddq_u8(L, TR);                            \
202    const uint8x16_t avg = vhaddq_u8(avgLTR, T);                           \
203    const uint8x16_t res = vaddq_u8(avg, src);                             \
204    vst1q_lane_u32(&out[i + (LANE)], vreinterpretq_u32_u8(res), (LANE));   \
205    L = ROTATE32_LEFT(res);                                                \
206  } while (0)
207  static void PredictorAdd5_NEON(const uint32_t* in, const uint32_t* upper,
208                                 int num_pixels, uint32_t* out) {
209    int i;
210    uint8x16_t L = LOADQ_U32_AS_U8(out[-1]);
211    for (i = 0; i + 4 <= num_pixels; i += 4) {
212      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
213      const uint8x16_t T = LOADQ_U32P_AS_U8(&upper[i + 0]);
214      const uint8x16_t TR = LOADQ_U32P_AS_U8(&upper[i + 1]);
215      DO_PRED5(0);
216      DO_PRED5(1);
217      DO_PRED5(2);
218      DO_PRED5(3);
219    }
220    VP8LPredictorsAdd_C[5](in + i, upper + i, num_pixels - i, out + i);
221  }
222  #undef DO_PRED5
223  #define DO_PRED67(LANE) do {                                             \
224    const uint8x16_t avg = vhaddq_u8(L, top);                              \
225    const uint8x16_t res = vaddq_u8(avg, src);                             \
226    vst1q_lane_u32(&out[i + (LANE)], vreinterpretq_u32_u8(res), (LANE));   \
227    L = ROTATE32_LEFT(res);                                                \
228  } while (0)
229  static void PredictorAdd6_NEON(const uint32_t* in, const uint32_t* upper,
230                                 int num_pixels, uint32_t* out) {
231    int i;
232    uint8x16_t L = LOADQ_U32_AS_U8(out[-1]);
233    for (i = 0; i + 4 <= num_pixels; i += 4) {
234      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
235      const uint8x16_t top = LOADQ_U32P_AS_U8(&upper[i - 1]);
236      DO_PRED67(0);
237      DO_PRED67(1);
238      DO_PRED67(2);
239      DO_PRED67(3);
240    }
241    VP8LPredictorsAdd_C[6](in + i, upper + i, num_pixels - i, out + i);
242  }
243  static void PredictorAdd7_NEON(const uint32_t* in, const uint32_t* upper,
244                                 int num_pixels, uint32_t* out) {
245    int i;
246    uint8x16_t L = LOADQ_U32_AS_U8(out[-1]);
247    for (i = 0; i + 4 <= num_pixels; i += 4) {
248      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
249      const uint8x16_t top = LOADQ_U32P_AS_U8(&upper[i]);
250      DO_PRED67(0);
251      DO_PRED67(1);
252      DO_PRED67(2);
253      DO_PRED67(3);
254    }
255    VP8LPredictorsAdd_C[7](in + i, upper + i, num_pixels - i, out + i);
256  }
257  #undef DO_PRED67
258  #define GENERATE_PREDICTOR_2(X, IN)                                       \
259  static void PredictorAdd##X##_NEON(const uint32_t* in,                    \
260                                     const uint32_t* upper, int num_pixels, \
261                                     uint32_t* out) {                       \
262    int i;                                                                  \
263    for (i = 0; i + 4 <= num_pixels; i += 4) {                              \
264      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);                      \
265      const uint8x16_t Tother = LOADQ_U32P_AS_U8(&(IN));                    \
266      const uint8x16_t T = LOADQ_U32P_AS_U8(&upper[i]);                     \
267      const uint8x16_t avg = vhaddq_u8(T, Tother);                          \
268      const uint8x16_t res = vaddq_u8(avg, src);                            \
269      STOREQ_U8_AS_U32P(&out[i], res);                                      \
270    }                                                                       \
271    VP8LPredictorsAdd_C[(X)](in + i, upper + i, num_pixels - i, out + i);   \
272  }
273  GENERATE_PREDICTOR_2(8, upper[i - 1])
274  GENERATE_PREDICTOR_2(9, upper[i + 1])
275  #undef GENERATE_PREDICTOR_2
276  #define DO_PRED10(LANE) do {                                             \
277    const uint8x16_t avgLTL = vhaddq_u8(L, TL);                            \
278    const uint8x16_t avg = vhaddq_u8(avgTTR, avgLTL);                      \
279    const uint8x16_t res = vaddq_u8(avg, src);                             \
280    vst1q_lane_u32(&out[i + (LANE)], vreinterpretq_u32_u8(res), (LANE));   \
281    L = ROTATE32_LEFT(res);                                                \
282  } while (0)
283  static void PredictorAdd10_NEON(const uint32_t* in, const uint32_t* upper,
284                                  int num_pixels, uint32_t* out) {
285    int i;
286    uint8x16_t L = LOADQ_U32_AS_U8(out[-1]);
287    for (i = 0; i + 4 <= num_pixels; i += 4) {
288      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
289      const uint8x16_t TL = LOADQ_U32P_AS_U8(&upper[i - 1]);
290      const uint8x16_t T = LOADQ_U32P_AS_U8(&upper[i]);
291      const uint8x16_t TR = LOADQ_U32P_AS_U8(&upper[i + 1]);
292      const uint8x16_t avgTTR = vhaddq_u8(T, TR);
293      DO_PRED10(0);
294      DO_PRED10(1);
295      DO_PRED10(2);
296      DO_PRED10(3);
297    }
298    VP8LPredictorsAdd_C[10](in + i, upper + i, num_pixels - i, out + i);
299  }
300  #undef DO_PRED10
301  #define DO_PRED11(LANE) do {                                                   \
302    const uint8x16_t sumLin = vaddq_u8(L, src);  &bsol;* in + L */                    \
303    const uint8x16_t pLTL = vabdq_u8(L, TL);  &bsol;* |L - TL| */                     \
304    const uint16x8_t sum_LTL = vpaddlq_u8(pLTL);                                 \
305    const uint32x4_t pa = vpaddlq_u16(sum_LTL);                                  \
306    const uint32x4_t mask = vcleq_u32(pa, pb);                                   \
307    const uint8x16_t res = vbslq_u8(vreinterpretq_u8_u32(mask), sumTin, sumLin); \
308    vst1q_lane_u32(&out[i + (LANE)], vreinterpretq_u32_u8(res), (LANE));         \
309    L = ROTATE32_LEFT(res);                                                      \
310  } while (0)
311  static void PredictorAdd11_NEON(const uint32_t* in, const uint32_t* upper,
312                                  int num_pixels, uint32_t* out) {
313    int i;
314    uint8x16_t L = LOADQ_U32_AS_U8(out[-1]);
315    for (i = 0; i + 4 <= num_pixels; i += 4) {
316      const uint8x16_t T = LOADQ_U32P_AS_U8(&upper[i]);
317      const uint8x16_t TL = LOADQ_U32P_AS_U8(&upper[i - 1]);
318      const uint8x16_t pTTL = vabdq_u8(T, TL);   
319      const uint16x8_t sum_TTL = vpaddlq_u8(pTTL);
320      const uint32x4_t pb = vpaddlq_u16(sum_TTL);
321      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
322      const uint8x16_t sumTin = vaddq_u8(T, src);   
323      DO_PRED11(0);
324      DO_PRED11(1);
325      DO_PRED11(2);
326      DO_PRED11(3);
327    }
328    VP8LPredictorsAdd_C[11](in + i, upper + i, num_pixels - i, out + i);
329  }
330  #undef DO_PRED11
331  #define DO_PRED12(DIFF, LANE) do {                                       \
332    const uint8x8_t pred =                                                 \
333        vqmovun_s16(vaddq_s16(vreinterpretq_s16_u16(L), (DIFF)));          \
334    const uint8x8_t res =                                                  \
335        vadd_u8(pred, (LANE <= 1) ? vget_low_u8(src) : vget_high_u8(src)); \
336    const uint16x8_t res16 = vmovl_u8(res);                                \
337    vst1_lane_u32(&out[i + (LANE)], vreinterpret_u32_u8(res), (LANE) & 1); \
338                      \
339    L = vextq_u16(res16, res16, 4);                                        \
340  } while (0)
341  static void PredictorAdd12_NEON(const uint32_t* in, const uint32_t* upper,
342                                  int num_pixels, uint32_t* out) {
343    int i;
344    uint16x8_t L = vmovl_u8(LOAD_U32_AS_U8(out[-1]));
345    for (i = 0; i + 4 <= num_pixels; i += 4) {
346      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
347      const uint8x16_t TL = LOADQ_U32P_AS_U8(&upper[i - 1]);
348      const uint8x16_t T = LOADQ_U32P_AS_U8(&upper[i]);
349      const int16x8_t diff_lo =
350          vreinterpretq_s16_u16(vsubl_u8(vget_low_u8(T), vget_low_u8(TL)));
351      const int16x8_t diff_hi =
352          vreinterpretq_s16_u16(vsubl_u8(vget_high_u8(T), vget_high_u8(TL)));
353      DO_PRED12(diff_lo, 0);
354      DO_PRED12(diff_lo, 1);
355      DO_PRED12(diff_hi, 2);
356      DO_PRED12(diff_hi, 3);
357    }
358    VP8LPredictorsAdd_C[12](in + i, upper + i, num_pixels - i, out + i);
359  }
360  #undef DO_PRED12
361  #define DO_PRED13(LANE, LOW_OR_HI) do {                                        \
362    const uint8x16_t avg = vhaddq_u8(L, T);                                      \
363    const uint8x16_t cmp = vcgtq_u8(TL, avg);                                    \
364    const uint8x16_t TL_1 = vaddq_u8(TL, cmp);                                   \
365                        \
366    const int8x8_t diff_avg =                                                    \
367        vreinterpret_s8_u8(LOW_OR_HI(vhsubq_u8(avg, TL_1)));                     \
368                                     \
369    const int16x8_t avg_16 = vreinterpretq_s16_u16(vmovl_u8(LOW_OR_HI(avg)));    \
370    const uint8x8_t delta = vqmovun_s16(vaddw_s8(avg_16, diff_avg));             \
371    const uint8x8_t res = vadd_u8(LOW_OR_HI(src), delta);                        \
372    const uint8x16_t res2 = vcombine_u8(res, res);                               \
373    vst1_lane_u32(&out[i + (LANE)], vreinterpret_u32_u8(res), (LANE) & 1);       \
374    L = ROTATE32_LEFT(res2);                                                     \
375  } while (0)
376  static void PredictorAdd13_NEON(const uint32_t* in, const uint32_t* upper,
377                                  int num_pixels, uint32_t* out) {
378    int i;
379    uint8x16_t L = LOADQ_U32_AS_U8(out[-1]);
380    for (i = 0; i + 4 <= num_pixels; i += 4) {
381      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
382      const uint8x16_t T = LOADQ_U32P_AS_U8(&upper[i]);
383      const uint8x16_t TL = LOADQ_U32P_AS_U8(&upper[i - 1]);
384      DO_PRED13(0, vget_low_u8);
385      DO_PRED13(1, vget_low_u8);
386      DO_PRED13(2, vget_high_u8);
387      DO_PRED13(3, vget_high_u8);
388    }
389    VP8LPredictorsAdd_C[13](in + i, upper + i, num_pixels - i, out + i);
390  }
391  #undef DO_PRED13
392  #undef LOAD_U32_AS_U8
393  #undef LOAD_U32P_AS_U8
394  #undef LOADQ_U32_AS_U8
395  #undef LOADQ_U32P_AS_U8
396  #undef GET_U8_AS_U32
397  #undef GETQ_U8_AS_U32
398  #undef STOREQ_U8_AS_U32P
399  #undef ROTATE32_LEFT
400  #if defined(__APPLE__) && defined(__aarch64__) && \
401      defined(__apple_build_version__) && (__apple_build_version__< 6020037)
402  #define USE_VTBLQ
403  #endif
404  #ifdef USE_VTBLQ
405  static const uint8_t kGreenShuffle[16] = {
406    1, 255, 1, 255, 5, 255, 5, 255, 9, 255, 9, 255, 13, 255, 13, 255
407  };
408  static WEBP_INLINE uint8x16_t DoGreenShuffle_NEON(const uint8x16_t argb,
409                                                    const uint8x16_t shuffle) {
410    return vcombine_u8(vtbl1q_u8(argb, vget_low_u8(shuffle)),
411                       vtbl1q_u8(argb, vget_high_u8(shuffle)));
412  }
413  #else  
414  static const uint8_t kGreenShuffle[8] = { 1, 255, 1, 255, 5, 255, 5, 255  };
415  static WEBP_INLINE uint8x16_t DoGreenShuffle_NEON(const uint8x16_t argb,
416                                                    const uint8x8_t shuffle) {
417    return vcombine_u8(vtbl1_u8(vget_low_u8(argb), shuffle),
418                       vtbl1_u8(vget_high_u8(argb), shuffle));
419  }
420  #endif  
421  static void AddGreenToBlueAndRed_NEON(const uint32_t* src, int num_pixels,
422                                        uint32_t* dst) {
423    const uint32_t* const end = src + (num_pixels & ~3);
424  #ifdef USE_VTBLQ
425    const uint8x16_t shuffle = vld1q_u8(kGreenShuffle);
426  #else
427    const uint8x8_t shuffle = vld1_u8(kGreenShuffle);
428  #endif
429    for (; src < end; src += 4, dst += 4) {
430      const uint8x16_t argb = vld1q_u8((const uint8_t*)src);
431      const uint8x16_t greens = DoGreenShuffle_NEON(argb, shuffle);
432      vst1q_u8((uint8_t*)dst, vaddq_u8(argb, greens));
433    }
434    VP8LAddGreenToBlueAndRed_C(src, num_pixels & 3, dst);
435  }
436  static void TransformColorInverse_NEON(const VP8LMultipliers* const m,
437                                         const uint32_t* const src,
438                                         int num_pixels, uint32_t* dst) {
439  #define CST(X)  (((int16_t)(m->X << 8)) >> 6)
440    const int16_t rb[8] = {
441      CST(green_to_blue_), CST(green_to_red_),
442      CST(green_to_blue_), CST(green_to_red_),
443      CST(green_to_blue_), CST(green_to_red_),
444      CST(green_to_blue_), CST(green_to_red_)
445    };
446    const int16x8_t mults_rb = vld1q_s16(rb);
447    const int16_t b2[8] = {
448      0, CST(red_to_blue_), 0, CST(red_to_blue_),
449      0, CST(red_to_blue_), 0, CST(red_to_blue_),
450    };
451    const int16x8_t mults_b2 = vld1q_s16(b2);
452  #undef CST
453  #ifdef USE_VTBLQ
454    static const uint8_t kg0g0[16] = {
455      255, 1, 255, 1, 255, 5, 255, 5, 255, 9, 255, 9, 255, 13, 255, 13
456    };
457    const uint8x16_t shuffle = vld1q_u8(kg0g0);
458  #else
459    static const uint8_t k0g0g[8] = { 255, 1, 255, 1, 255, 5, 255, 5 };
460    const uint8x8_t shuffle = vld1_u8(k0g0g);
461  #endif
462    const uint32x4_t mask_ag = vdupq_n_u32(0xff00ff00u);
463    int i;
464    for (i = 0; i + 4 <= num_pixels; i += 4) {
465      const uint8x16_t in = vld1q_u8((const uint8_t*)(src + i));
466      const uint32x4_t a0g0 = vandq_u32(vreinterpretq_u32_u8(in), mask_ag);
467      const uint8x16_t greens = DoGreenShuffle_NEON(in, shuffle);
468      const int16x8_t A = vqdmulhq_s16(vreinterpretq_s16_u8(greens), mults_rb);
469      const int8x16_t B = vaddq_s8(vreinterpretq_s8_u8(in),
470                                   vreinterpretq_s8_s16(A));
471      const int16x8_t C = vshlq_n_s16(vreinterpretq_s16_s8(B), 8);
472      const int16x8_t D = vqdmulhq_s16(C, mults_b2);
473      const uint32x4_t E = vshrq_n_u32(vreinterpretq_u32_s16(D), 8);
474      const int8x16_t F = vaddq_s8(vreinterpretq_s8_u32(E),
475                                   vreinterpretq_s8_s16(C));
476      const uint16x8_t G = vshrq_n_u16(vreinterpretq_u16_s8(F), 8);
477      const uint32x4_t out = vorrq_u32(vreinterpretq_u32_u16(G), a0g0);
478      vst1q_u32(dst + i, out);
479    }
480    VP8LTransformColorInverse_C(m, src + i, num_pixels - i, dst + i);
481  }
482  #undef USE_VTBLQ
483  extern void VP8LDspInitNEON(void);
484  WEBP_TSAN_IGNORE_FUNCTION void VP8LDspInitNEON(void) {
485    VP8LPredictors[5] = Predictor5_NEON;
486    VP8LPredictors[6] = Predictor6_NEON;
487    VP8LPredictors[7] = Predictor7_NEON;
488    VP8LPredictors[13] = Predictor13_NEON;
489    VP8LPredictorsAdd[0] = PredictorAdd0_NEON;
490    VP8LPredictorsAdd[1] = PredictorAdd1_NEON;
491    VP8LPredictorsAdd[2] = PredictorAdd2_NEON;
492    VP8LPredictorsAdd[3] = PredictorAdd3_NEON;
493    VP8LPredictorsAdd[4] = PredictorAdd4_NEON;
494    VP8LPredictorsAdd[5] = PredictorAdd5_NEON;
495    VP8LPredictorsAdd[6] = PredictorAdd6_NEON;
496    VP8LPredictorsAdd[7] = PredictorAdd7_NEON;
497    VP8LPredictorsAdd[8] = PredictorAdd8_NEON;
498    VP8LPredictorsAdd[9] = PredictorAdd9_NEON;
499    VP8LPredictorsAdd[10] = PredictorAdd10_NEON;
500    VP8LPredictorsAdd[11] = PredictorAdd11_NEON;
501    VP8LPredictorsAdd[12] = PredictorAdd12_NEON;
502    VP8LPredictorsAdd[13] = PredictorAdd13_NEON;
503    VP8LConvertBGRAToRGBA = ConvertBGRAToRGBA_NEON;
504    VP8LConvertBGRAToBGR = ConvertBGRAToBGR_NEON;
505    VP8LConvertBGRAToRGB = ConvertBGRAToRGB_NEON;
506    VP8LAddGreenToBlueAndRed = AddGreenToBlueAndRed_NEON;
507    VP8LTransformColorInverse = TransformColorInverse_NEON;
508  }
509  #else  
510  WEBP_DSP_INIT_STUB(VP8LDspInitNEON)
511  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_neon.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_NEON)
3  #include <arm_neon.h>
4  #include "src/dsp/lossless.h"
5  #include "src/dsp/neon.h"
6  #if !defined(WORK_AROUND_GCC)
7  static void ConvertBGRAToRGBA_NEON(const uint32_t* src,
8                                     int num_pixels, uint8_t* dst) {
9    const uint32_t* const end = src + (num_pixels & ~15);
10    for (; src < end; src += 16) {
11      uint8x16x4_t pixel = vld4q_u8((uint8_t*)src);
12      const uint8x16_t tmp = pixel.val[0];
13      pixel.val[0] = pixel.val[2];
14      pixel.val[2] = tmp;
15      vst4q_u8(dst, pixel);
16      dst += 64;
17    }
18    VP8LConvertBGRAToRGBA_C(src, num_pixels & 15, dst);  
19  }
20  static void ConvertBGRAToBGR_NEON(const uint32_t* src,
21                                    int num_pixels, uint8_t* dst) {
22    const uint32_t* const end = src + (num_pixels & ~15);
23    for (; src < end; src += 16) {
24      const uint8x16x4_t pixel = vld4q_u8((uint8_t*)src);
25      const uint8x16x3_t tmp = { { pixel.val[0], pixel.val[1], pixel.val[2] } };
26      vst3q_u8(dst, tmp);
27      dst += 48;
28    }
29    VP8LConvertBGRAToBGR_C(src, num_pixels & 15, dst);  
30  }
31  static void ConvertBGRAToRGB_NEON(const uint32_t* src,
32                                    int num_pixels, uint8_t* dst) {
33    const uint32_t* const end = src + (num_pixels & ~15);
34    for (; src < end; src += 16) {
35      const uint8x16x4_t pixel = vld4q_u8((uint8_t*)src);
36      const uint8x16x3_t tmp = { { pixel.val[2], pixel.val[1], pixel.val[0] } };
37      vst3q_u8(dst, tmp);
38      dst += 48;
39    }
40    VP8LConvertBGRAToRGB_C(src, num_pixels & 15, dst);  
41  }
42  #else  
43  static const uint8_t kRGBAShuffle[8] = { 2, 1, 0, 3, 6, 5, 4, 7 };
44  static void ConvertBGRAToRGBA_NEON(const uint32_t* src,
45                                     int num_pixels, uint8_t* dst) {
46    const uint32_t* const end = src + (num_pixels & ~1);
47    const uint8x8_t shuffle = vld1_u8(kRGBAShuffle);
48    for (; src < end; src += 2) {
49      const uint8x8_t pixels = vld1_u8((uint8_t*)src);
50      vst1_u8(dst, vtbl1_u8(pixels, shuffle));
51      dst += 8;
52    }
53    VP8LConvertBGRAToRGBA_C(src, num_pixels & 1, dst);  
54  }
55  static const uint8_t kBGRShuffle[3][8] = {
56    {  0,  1,  2,  4,  5,  6,  8,  9 },
57    { 10, 12, 13, 14, 16, 17, 18, 20 },
58    { 21, 22, 24, 25, 26, 28, 29, 30 }
59  };
60  static void ConvertBGRAToBGR_NEON(const uint32_t* src,
61                                    int num_pixels, uint8_t* dst) {
62    const uint32_t* const end = src + (num_pixels & ~7);
63    const uint8x8_t shuffle0 = vld1_u8(kBGRShuffle[0]);
64    const uint8x8_t shuffle1 = vld1_u8(kBGRShuffle[1]);
65    const uint8x8_t shuffle2 = vld1_u8(kBGRShuffle[2]);
66    for (; src < end; src += 8) {
67      uint8x8x4_t pixels;
68      INIT_VECTOR4(pixels,
69                   vld1_u8((const uint8_t*)(src + 0)),
70                   vld1_u8((const uint8_t*)(src + 2)),
71                   vld1_u8((const uint8_t*)(src + 4)),
72                   vld1_u8((const uint8_t*)(src + 6)));
73      vst1_u8(dst +  0, vtbl4_u8(pixels, shuffle0));
74      vst1_u8(dst +  8, vtbl4_u8(pixels, shuffle1));
75      vst1_u8(dst + 16, vtbl4_u8(pixels, shuffle2));
76      dst += 8 * 3;
77    }
78    VP8LConvertBGRAToBGR_C(src, num_pixels & 7, dst);  
79  }
80  static const uint8_t kRGBShuffle[3][8] = {
81    {  2,  1,  0,  6,  5,  4, 10,  9 },
82    {  8, 14, 13, 12, 18, 17, 16, 22 },
83    { 21, 20, 26, 25, 24, 30, 29, 28 }
84  };
85  static void ConvertBGRAToRGB_NEON(const uint32_t* src,
86                                    int num_pixels, uint8_t* dst) {
87    const uint32_t* const end = src + (num_pixels & ~7);
88    const uint8x8_t shuffle0 = vld1_u8(kRGBShuffle[0]);
89    const uint8x8_t shuffle1 = vld1_u8(kRGBShuffle[1]);
90    const uint8x8_t shuffle2 = vld1_u8(kRGBShuffle[2]);
91    for (; src < end; src += 8) {
92      uint8x8x4_t pixels;
93      INIT_VECTOR4(pixels,
94                   vld1_u8((const uint8_t*)(src + 0)),
95                   vld1_u8((const uint8_t*)(src + 2)),
96                   vld1_u8((const uint8_t*)(src + 4)),
97                   vld1_u8((const uint8_t*)(src + 6)));
<span onclick='openModal()' class='match'>98      vst1_u8(dst +  0, vtbl4_u8(pixels, shuffle0));
99      vst1_u8(dst +  8, vtbl4_u8(pixels, shuffle1));
100      vst1_u8(dst + 16, vtbl4_u8(pixels, shuffle2));
</span>101      dst += 8 * 3;
102    }
103    VP8LConvertBGRAToRGB_C(src, num_pixels & 7, dst);  
104  }
105  #endif   
106  #define LOAD_U32_AS_U8(IN) vreinterpret_u8_u32(vdup_n_u32((IN)))
107  #define LOAD_U32P_AS_U8(IN) vreinterpret_u8_u32(vld1_u32((IN)))
108  #define LOADQ_U32_AS_U8(IN) vreinterpretq_u8_u32(vdupq_n_u32((IN)))
109  #define LOADQ_U32P_AS_U8(IN) vreinterpretq_u8_u32(vld1q_u32((IN)))
110  #define GET_U8_AS_U32(IN) vget_lane_u32(vreinterpret_u32_u8((IN)), 0);
111  #define GETQ_U8_AS_U32(IN) vgetq_lane_u32(vreinterpretq_u32_u8((IN)), 0);
112  #define STOREQ_U8_AS_U32P(OUT, IN) vst1q_u32((OUT), vreinterpretq_u32_u8((IN)));
113  #define ROTATE32_LEFT(L) vextq_u8((L), (L), 12)    
114  static WEBP_INLINE uint8x8_t Average2_u8_NEON(uint32_t a0, uint32_t a1) {
115    const uint8x8_t A0 = LOAD_U32_AS_U8(a0);
116    const uint8x8_t A1 = LOAD_U32_AS_U8(a1);
117    return vhadd_u8(A0, A1);
118  }
119  static WEBP_INLINE uint32_t ClampedAddSubtractHalf_NEON(uint32_t c0,
120                                                          uint32_t c1,
121                                                          uint32_t c2) {
122    const uint8x8_t avg = Average2_u8_NEON(c0, c1);
123    const uint8x8_t C2 = LOAD_U32_AS_U8(c2);
124    const uint8x8_t cmp = vcgt_u8(C2, avg);
125    const uint8x8_t C2_1 = vadd_u8(C2, cmp);
126    const int8x8_t diff_avg = vreinterpret_s8_u8(vhsub_u8(avg, C2_1));
127    const int16x8_t avg_16 = vreinterpretq_s16_u16(vmovl_u8(avg));
128    const uint8x8_t res = vqmovun_s16(vaddw_s8(avg_16, diff_avg));
129    const uint32_t output = GET_U8_AS_U32(res);
130    return output;
131  }
132  static WEBP_INLINE uint32_t Average2_NEON(uint32_t a0, uint32_t a1) {
133    const uint8x8_t avg_u8x8 = Average2_u8_NEON(a0, a1);
134    const uint32_t avg = GET_U8_AS_U32(avg_u8x8);
135    return avg;
136  }
137  static WEBP_INLINE uint32_t Average3_NEON(uint32_t a0, uint32_t a1,
138                                            uint32_t a2) {
139    const uint8x8_t avg0 = Average2_u8_NEON(a0, a2);
140    const uint8x8_t A1 = LOAD_U32_AS_U8(a1);
141    const uint32_t avg = GET_U8_AS_U32(vhadd_u8(avg0, A1));
142    return avg;
143  }
144  static uint32_t Predictor5_NEON(uint32_t left, const uint32_t* const top) {
145    return Average3_NEON(left, top[0], top[1]);
146  }
147  static uint32_t Predictor6_NEON(uint32_t left, const uint32_t* const top) {
148    return Average2_NEON(left, top[-1]);
149  }
150  static uint32_t Predictor7_NEON(uint32_t left, const uint32_t* const top) {
151    return Average2_NEON(left, top[0]);
152  }
153  static uint32_t Predictor13_NEON(uint32_t left, const uint32_t* const top) {
154    return ClampedAddSubtractHalf_NEON(left, top[0], top[-1]);
155  }
156  static void PredictorAdd0_NEON(const uint32_t* in, const uint32_t* upper,
157                                 int num_pixels, uint32_t* out) {
158    int i;
159    const uint8x16_t black = vreinterpretq_u8_u32(vdupq_n_u32(ARGB_BLACK));
160    for (i = 0; i + 4 <= num_pixels; i += 4) {
161      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
162      const uint8x16_t res = vaddq_u8(src, black);
163      STOREQ_U8_AS_U32P(&out[i], res);
164    }
165    VP8LPredictorsAdd_C[0](in + i, upper + i, num_pixels - i, out + i);
166  }
167  static void PredictorAdd1_NEON(const uint32_t* in, const uint32_t* upper,
168                                 int num_pixels, uint32_t* out) {
169    int i;
170    const uint8x16_t zero = LOADQ_U32_AS_U8(0);
171    for (i = 0; i + 4 <= num_pixels; i += 4) {
172      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
173      const uint8x16_t shift0 = vextq_u8(zero, src, 12);
174      const uint8x16_t sum0 = vaddq_u8(src, shift0);
175      const uint8x16_t shift1 = vextq_u8(zero, sum0, 8);
176      const uint8x16_t sum1 = vaddq_u8(sum0, shift1);
177      const uint8x16_t prev = LOADQ_U32_AS_U8(out[i - 1]);
178      const uint8x16_t res = vaddq_u8(sum1, prev);
179      STOREQ_U8_AS_U32P(&out[i], res);
180    }
181    VP8LPredictorsAdd_C[1](in + i, upper + i, num_pixels - i, out + i);
182  }
183  #define GENERATE_PREDICTOR_1(X, IN)                                       \
184  static void PredictorAdd##X##_NEON(const uint32_t* in,                    \
185                                     const uint32_t* upper, int num_pixels, \
186                                     uint32_t* out) {                       \
187    int i;                                                                  \
188    for (i = 0; i + 4 <= num_pixels; i += 4) {                              \
189      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);                      \
190      const uint8x16_t other = LOADQ_U32P_AS_U8(&(IN));                     \
191      const uint8x16_t res = vaddq_u8(src, other);                          \
192      STOREQ_U8_AS_U32P(&out[i], res);                                      \
193    }                                                                       \
194    VP8LPredictorsAdd_C[(X)](in + i, upper + i, num_pixels - i, out + i);   \
195  }
196  GENERATE_PREDICTOR_1(2, upper[i])
197  GENERATE_PREDICTOR_1(3, upper[i + 1])
198  GENERATE_PREDICTOR_1(4, upper[i - 1])
199  #undef GENERATE_PREDICTOR_1
200  #define DO_PRED5(LANE) do {                                              \
201    const uint8x16_t avgLTR = vhaddq_u8(L, TR);                            \
202    const uint8x16_t avg = vhaddq_u8(avgLTR, T);                           \
203    const uint8x16_t res = vaddq_u8(avg, src);                             \
204    vst1q_lane_u32(&out[i + (LANE)], vreinterpretq_u32_u8(res), (LANE));   \
205    L = ROTATE32_LEFT(res);                                                \
206  } while (0)
207  static void PredictorAdd5_NEON(const uint32_t* in, const uint32_t* upper,
208                                 int num_pixels, uint32_t* out) {
209    int i;
210    uint8x16_t L = LOADQ_U32_AS_U8(out[-1]);
211    for (i = 0; i + 4 <= num_pixels; i += 4) {
212      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
213      const uint8x16_t T = LOADQ_U32P_AS_U8(&upper[i + 0]);
214      const uint8x16_t TR = LOADQ_U32P_AS_U8(&upper[i + 1]);
215      DO_PRED5(0);
216      DO_PRED5(1);
217      DO_PRED5(2);
218      DO_PRED5(3);
219    }
220    VP8LPredictorsAdd_C[5](in + i, upper + i, num_pixels - i, out + i);
221  }
222  #undef DO_PRED5
223  #define DO_PRED67(LANE) do {                                             \
224    const uint8x16_t avg = vhaddq_u8(L, top);                              \
225    const uint8x16_t res = vaddq_u8(avg, src);                             \
226    vst1q_lane_u32(&out[i + (LANE)], vreinterpretq_u32_u8(res), (LANE));   \
227    L = ROTATE32_LEFT(res);                                                \
228  } while (0)
229  static void PredictorAdd6_NEON(const uint32_t* in, const uint32_t* upper,
230                                 int num_pixels, uint32_t* out) {
231    int i;
232    uint8x16_t L = LOADQ_U32_AS_U8(out[-1]);
233    for (i = 0; i + 4 <= num_pixels; i += 4) {
234      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
235      const uint8x16_t top = LOADQ_U32P_AS_U8(&upper[i - 1]);
236      DO_PRED67(0);
237      DO_PRED67(1);
238      DO_PRED67(2);
239      DO_PRED67(3);
240    }
241    VP8LPredictorsAdd_C[6](in + i, upper + i, num_pixels - i, out + i);
242  }
243  static void PredictorAdd7_NEON(const uint32_t* in, const uint32_t* upper,
244                                 int num_pixels, uint32_t* out) {
245    int i;
246    uint8x16_t L = LOADQ_U32_AS_U8(out[-1]);
247    for (i = 0; i + 4 <= num_pixels; i += 4) {
248      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
249      const uint8x16_t top = LOADQ_U32P_AS_U8(&upper[i]);
250      DO_PRED67(0);
251      DO_PRED67(1);
252      DO_PRED67(2);
253      DO_PRED67(3);
254    }
255    VP8LPredictorsAdd_C[7](in + i, upper + i, num_pixels - i, out + i);
256  }
257  #undef DO_PRED67
258  #define GENERATE_PREDICTOR_2(X, IN)                                       \
259  static void PredictorAdd##X##_NEON(const uint32_t* in,                    \
260                                     const uint32_t* upper, int num_pixels, \
261                                     uint32_t* out) {                       \
262    int i;                                                                  \
263    for (i = 0; i + 4 <= num_pixels; i += 4) {                              \
264      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);                      \
265      const uint8x16_t Tother = LOADQ_U32P_AS_U8(&(IN));                    \
266      const uint8x16_t T = LOADQ_U32P_AS_U8(&upper[i]);                     \
267      const uint8x16_t avg = vhaddq_u8(T, Tother);                          \
268      const uint8x16_t res = vaddq_u8(avg, src);                            \
269      STOREQ_U8_AS_U32P(&out[i], res);                                      \
270    }                                                                       \
271    VP8LPredictorsAdd_C[(X)](in + i, upper + i, num_pixels - i, out + i);   \
272  }
273  GENERATE_PREDICTOR_2(8, upper[i - 1])
274  GENERATE_PREDICTOR_2(9, upper[i + 1])
275  #undef GENERATE_PREDICTOR_2
276  #define DO_PRED10(LANE) do {                                             \
277    const uint8x16_t avgLTL = vhaddq_u8(L, TL);                            \
278    const uint8x16_t avg = vhaddq_u8(avgTTR, avgLTL);                      \
279    const uint8x16_t res = vaddq_u8(avg, src);                             \
280    vst1q_lane_u32(&out[i + (LANE)], vreinterpretq_u32_u8(res), (LANE));   \
281    L = ROTATE32_LEFT(res);                                                \
282  } while (0)
283  static void PredictorAdd10_NEON(const uint32_t* in, const uint32_t* upper,
284                                  int num_pixels, uint32_t* out) {
285    int i;
286    uint8x16_t L = LOADQ_U32_AS_U8(out[-1]);
287    for (i = 0; i + 4 <= num_pixels; i += 4) {
288      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
289      const uint8x16_t TL = LOADQ_U32P_AS_U8(&upper[i - 1]);
290      const uint8x16_t T = LOADQ_U32P_AS_U8(&upper[i]);
291      const uint8x16_t TR = LOADQ_U32P_AS_U8(&upper[i + 1]);
292      const uint8x16_t avgTTR = vhaddq_u8(T, TR);
293      DO_PRED10(0);
294      DO_PRED10(1);
295      DO_PRED10(2);
296      DO_PRED10(3);
297    }
298    VP8LPredictorsAdd_C[10](in + i, upper + i, num_pixels - i, out + i);
299  }
300  #undef DO_PRED10
301  #define DO_PRED11(LANE) do {                                                   \
302    const uint8x16_t sumLin = vaddq_u8(L, src);  &bsol;* in + L */                    \
303    const uint8x16_t pLTL = vabdq_u8(L, TL);  &bsol;* |L - TL| */                     \
304    const uint16x8_t sum_LTL = vpaddlq_u8(pLTL);                                 \
305    const uint32x4_t pa = vpaddlq_u16(sum_LTL);                                  \
306    const uint32x4_t mask = vcleq_u32(pa, pb);                                   \
307    const uint8x16_t res = vbslq_u8(vreinterpretq_u8_u32(mask), sumTin, sumLin); \
308    vst1q_lane_u32(&out[i + (LANE)], vreinterpretq_u32_u8(res), (LANE));         \
309    L = ROTATE32_LEFT(res);                                                      \
310  } while (0)
311  static void PredictorAdd11_NEON(const uint32_t* in, const uint32_t* upper,
312                                  int num_pixels, uint32_t* out) {
313    int i;
314    uint8x16_t L = LOADQ_U32_AS_U8(out[-1]);
315    for (i = 0; i + 4 <= num_pixels; i += 4) {
316      const uint8x16_t T = LOADQ_U32P_AS_U8(&upper[i]);
317      const uint8x16_t TL = LOADQ_U32P_AS_U8(&upper[i - 1]);
318      const uint8x16_t pTTL = vabdq_u8(T, TL);   
319      const uint16x8_t sum_TTL = vpaddlq_u8(pTTL);
320      const uint32x4_t pb = vpaddlq_u16(sum_TTL);
321      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
322      const uint8x16_t sumTin = vaddq_u8(T, src);   
323      DO_PRED11(0);
324      DO_PRED11(1);
325      DO_PRED11(2);
326      DO_PRED11(3);
327    }
328    VP8LPredictorsAdd_C[11](in + i, upper + i, num_pixels - i, out + i);
329  }
330  #undef DO_PRED11
331  #define DO_PRED12(DIFF, LANE) do {                                       \
332    const uint8x8_t pred =                                                 \
333        vqmovun_s16(vaddq_s16(vreinterpretq_s16_u16(L), (DIFF)));          \
334    const uint8x8_t res =                                                  \
335        vadd_u8(pred, (LANE <= 1) ? vget_low_u8(src) : vget_high_u8(src)); \
336    const uint16x8_t res16 = vmovl_u8(res);                                \
337    vst1_lane_u32(&out[i + (LANE)], vreinterpret_u32_u8(res), (LANE) & 1); \
338                      \
339    L = vextq_u16(res16, res16, 4);                                        \
340  } while (0)
341  static void PredictorAdd12_NEON(const uint32_t* in, const uint32_t* upper,
342                                  int num_pixels, uint32_t* out) {
343    int i;
344    uint16x8_t L = vmovl_u8(LOAD_U32_AS_U8(out[-1]));
345    for (i = 0; i + 4 <= num_pixels; i += 4) {
346      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
347      const uint8x16_t TL = LOADQ_U32P_AS_U8(&upper[i - 1]);
348      const uint8x16_t T = LOADQ_U32P_AS_U8(&upper[i]);
349      const int16x8_t diff_lo =
350          vreinterpretq_s16_u16(vsubl_u8(vget_low_u8(T), vget_low_u8(TL)));
351      const int16x8_t diff_hi =
352          vreinterpretq_s16_u16(vsubl_u8(vget_high_u8(T), vget_high_u8(TL)));
353      DO_PRED12(diff_lo, 0);
354      DO_PRED12(diff_lo, 1);
355      DO_PRED12(diff_hi, 2);
356      DO_PRED12(diff_hi, 3);
357    }
358    VP8LPredictorsAdd_C[12](in + i, upper + i, num_pixels - i, out + i);
359  }
360  #undef DO_PRED12
361  #define DO_PRED13(LANE, LOW_OR_HI) do {                                        \
362    const uint8x16_t avg = vhaddq_u8(L, T);                                      \
363    const uint8x16_t cmp = vcgtq_u8(TL, avg);                                    \
364    const uint8x16_t TL_1 = vaddq_u8(TL, cmp);                                   \
365                        \
366    const int8x8_t diff_avg =                                                    \
367        vreinterpret_s8_u8(LOW_OR_HI(vhsubq_u8(avg, TL_1)));                     \
368                                     \
369    const int16x8_t avg_16 = vreinterpretq_s16_u16(vmovl_u8(LOW_OR_HI(avg)));    \
370    const uint8x8_t delta = vqmovun_s16(vaddw_s8(avg_16, diff_avg));             \
371    const uint8x8_t res = vadd_u8(LOW_OR_HI(src), delta);                        \
372    const uint8x16_t res2 = vcombine_u8(res, res);                               \
373    vst1_lane_u32(&out[i + (LANE)], vreinterpret_u32_u8(res), (LANE) & 1);       \
374    L = ROTATE32_LEFT(res2);                                                     \
375  } while (0)
376  static void PredictorAdd13_NEON(const uint32_t* in, const uint32_t* upper,
377                                  int num_pixels, uint32_t* out) {
378    int i;
379    uint8x16_t L = LOADQ_U32_AS_U8(out[-1]);
380    for (i = 0; i + 4 <= num_pixels; i += 4) {
381      const uint8x16_t src = LOADQ_U32P_AS_U8(&in[i]);
382      const uint8x16_t T = LOADQ_U32P_AS_U8(&upper[i]);
383      const uint8x16_t TL = LOADQ_U32P_AS_U8(&upper[i - 1]);
384      DO_PRED13(0, vget_low_u8);
385      DO_PRED13(1, vget_low_u8);
386      DO_PRED13(2, vget_high_u8);
387      DO_PRED13(3, vget_high_u8);
388    }
389    VP8LPredictorsAdd_C[13](in + i, upper + i, num_pixels - i, out + i);
390  }
391  #undef DO_PRED13
392  #undef LOAD_U32_AS_U8
393  #undef LOAD_U32P_AS_U8
394  #undef LOADQ_U32_AS_U8
395  #undef LOADQ_U32P_AS_U8
396  #undef GET_U8_AS_U32
397  #undef GETQ_U8_AS_U32
398  #undef STOREQ_U8_AS_U32P
399  #undef ROTATE32_LEFT
400  #if defined(__APPLE__) && defined(__aarch64__) && \
401      defined(__apple_build_version__) && (__apple_build_version__< 6020037)
402  #define USE_VTBLQ
403  #endif
404  #ifdef USE_VTBLQ
405  static const uint8_t kGreenShuffle[16] = {
406    1, 255, 1, 255, 5, 255, 5, 255, 9, 255, 9, 255, 13, 255, 13, 255
407  };
408  static WEBP_INLINE uint8x16_t DoGreenShuffle_NEON(const uint8x16_t argb,
409                                                    const uint8x16_t shuffle) {
410    return vcombine_u8(vtbl1q_u8(argb, vget_low_u8(shuffle)),
411                       vtbl1q_u8(argb, vget_high_u8(shuffle)));
412  }
413  #else  
414  static const uint8_t kGreenShuffle[8] = { 1, 255, 1, 255, 5, 255, 5, 255  };
415  static WEBP_INLINE uint8x16_t DoGreenShuffle_NEON(const uint8x16_t argb,
416                                                    const uint8x8_t shuffle) {
417    return vcombine_u8(vtbl1_u8(vget_low_u8(argb), shuffle),
418                       vtbl1_u8(vget_high_u8(argb), shuffle));
419  }
420  #endif  
421  static void AddGreenToBlueAndRed_NEON(const uint32_t* src, int num_pixels,
422                                        uint32_t* dst) {
423    const uint32_t* const end = src + (num_pixels & ~3);
424  #ifdef USE_VTBLQ
425    const uint8x16_t shuffle = vld1q_u8(kGreenShuffle);
426  #else
427    const uint8x8_t shuffle = vld1_u8(kGreenShuffle);
428  #endif
429    for (; src < end; src += 4, dst += 4) {
430      const uint8x16_t argb = vld1q_u8((const uint8_t*)src);
431      const uint8x16_t greens = DoGreenShuffle_NEON(argb, shuffle);
432      vst1q_u8((uint8_t*)dst, vaddq_u8(argb, greens));
433    }
434    VP8LAddGreenToBlueAndRed_C(src, num_pixels & 3, dst);
435  }
436  static void TransformColorInverse_NEON(const VP8LMultipliers* const m,
437                                         const uint32_t* const src,
438                                         int num_pixels, uint32_t* dst) {
439  #define CST(X)  (((int16_t)(m->X << 8)) >> 6)
440    const int16_t rb[8] = {
441      CST(green_to_blue_), CST(green_to_red_),
442      CST(green_to_blue_), CST(green_to_red_),
443      CST(green_to_blue_), CST(green_to_red_),
444      CST(green_to_blue_), CST(green_to_red_)
445    };
446    const int16x8_t mults_rb = vld1q_s16(rb);
447    const int16_t b2[8] = {
448      0, CST(red_to_blue_), 0, CST(red_to_blue_),
449      0, CST(red_to_blue_), 0, CST(red_to_blue_),
450    };
451    const int16x8_t mults_b2 = vld1q_s16(b2);
452  #undef CST
453  #ifdef USE_VTBLQ
454    static const uint8_t kg0g0[16] = {
455      255, 1, 255, 1, 255, 5, 255, 5, 255, 9, 255, 9, 255, 13, 255, 13
456    };
457    const uint8x16_t shuffle = vld1q_u8(kg0g0);
458  #else
459    static const uint8_t k0g0g[8] = { 255, 1, 255, 1, 255, 5, 255, 5 };
460    const uint8x8_t shuffle = vld1_u8(k0g0g);
461  #endif
462    const uint32x4_t mask_ag = vdupq_n_u32(0xff00ff00u);
463    int i;
464    for (i = 0; i + 4 <= num_pixels; i += 4) {
465      const uint8x16_t in = vld1q_u8((const uint8_t*)(src + i));
466      const uint32x4_t a0g0 = vandq_u32(vreinterpretq_u32_u8(in), mask_ag);
467      const uint8x16_t greens = DoGreenShuffle_NEON(in, shuffle);
468      const int16x8_t A = vqdmulhq_s16(vreinterpretq_s16_u8(greens), mults_rb);
469      const int8x16_t B = vaddq_s8(vreinterpretq_s8_u8(in),
470                                   vreinterpretq_s8_s16(A));
471      const int16x8_t C = vshlq_n_s16(vreinterpretq_s16_s8(B), 8);
472      const int16x8_t D = vqdmulhq_s16(C, mults_b2);
473      const uint32x4_t E = vshrq_n_u32(vreinterpretq_u32_s16(D), 8);
474      const int8x16_t F = vaddq_s8(vreinterpretq_s8_u32(E),
475                                   vreinterpretq_s8_s16(C));
476      const uint16x8_t G = vshrq_n_u16(vreinterpretq_u16_s8(F), 8);
477      const uint32x4_t out = vorrq_u32(vreinterpretq_u32_u16(G), a0g0);
478      vst1q_u32(dst + i, out);
479    }
480    VP8LTransformColorInverse_C(m, src + i, num_pixels - i, dst + i);
481  }
482  #undef USE_VTBLQ
483  extern void VP8LDspInitNEON(void);
484  WEBP_TSAN_IGNORE_FUNCTION void VP8LDspInitNEON(void) {
485    VP8LPredictors[5] = Predictor5_NEON;
486    VP8LPredictors[6] = Predictor6_NEON;
487    VP8LPredictors[7] = Predictor7_NEON;
488    VP8LPredictors[13] = Predictor13_NEON;
489    VP8LPredictorsAdd[0] = PredictorAdd0_NEON;
490    VP8LPredictorsAdd[1] = PredictorAdd1_NEON;
491    VP8LPredictorsAdd[2] = PredictorAdd2_NEON;
492    VP8LPredictorsAdd[3] = PredictorAdd3_NEON;
493    VP8LPredictorsAdd[4] = PredictorAdd4_NEON;
494    VP8LPredictorsAdd[5] = PredictorAdd5_NEON;
495    VP8LPredictorsAdd[6] = PredictorAdd6_NEON;
496    VP8LPredictorsAdd[7] = PredictorAdd7_NEON;
497    VP8LPredictorsAdd[8] = PredictorAdd8_NEON;
498    VP8LPredictorsAdd[9] = PredictorAdd9_NEON;
499    VP8LPredictorsAdd[10] = PredictorAdd10_NEON;
500    VP8LPredictorsAdd[11] = PredictorAdd11_NEON;
501    VP8LPredictorsAdd[12] = PredictorAdd12_NEON;
502    VP8LPredictorsAdd[13] = PredictorAdd13_NEON;
503    VP8LConvertBGRAToRGBA = ConvertBGRAToRGBA_NEON;
504    VP8LConvertBGRAToBGR = ConvertBGRAToBGR_NEON;
505    VP8LConvertBGRAToRGB = ConvertBGRAToRGB_NEON;
506    VP8LAddGreenToBlueAndRed = AddGreenToBlueAndRed_NEON;
507    VP8LTransformColorInverse = TransformColorInverse_NEON;
508  }
509  #else  
510  WEBP_DSP_INIT_STUB(VP8LDspInitNEON)
511  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_neon.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_neon.c</div>
                </div>
                <div class="column column_space"><pre><code>98      vst1_u8(dst +  0, vtbl4_u8(pixels, shuffle0));
99      vst1_u8(dst +  8, vtbl4_u8(pixels, shuffle1));
100      vst1_u8(dst + 16, vtbl4_u8(pixels, shuffle2));
</pre></code></div>
                <div class="column column_space"><pre><code>98      vst1_u8(dst +  0, vtbl4_u8(pixels, shuffle0));
99      vst1_u8(dst +  8, vtbl4_u8(pixels, shuffle1));
100      vst1_u8(dst + 16, vtbl4_u8(pixels, shuffle2));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    