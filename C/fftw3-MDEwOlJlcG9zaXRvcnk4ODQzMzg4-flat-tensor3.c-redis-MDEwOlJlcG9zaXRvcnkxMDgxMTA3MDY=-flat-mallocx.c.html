
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.048458149779736%, Tokens: 8</h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-tensor3.c</h3>
            <pre><code>1  #include "kernel/ifftw.h"
2  tensor *X(mktensor_4d)(INT n0, INT is0, INT os0,
3  		       INT n1, INT is1, INT os1,
4  		       INT n2, INT is2, INT os2,
5  		       INT n3, INT is3, INT os3)
<span onclick='openModal()' class='match'>6  {
7       tensor *x = X(mktensor)(4);
8       x->dims[0].n = n0;
9       x->dims[0].is = is0;
10       x->dims[0].os = os0;
11       x->dims[1].n = n1;
12       x->dims[1].is = is1;
13       x->dims[1].os = os1;
</span>14       x->dims[2].n = n2;
15       x->dims[2].is = is2;
16       x->dims[2].os = os2;
17       x->dims[3].n = n3;
18       x->dims[3].is = is3;
19       x->dims[3].os = os3;
20       return x;
21  }
22  tensor *X(mktensor_5d)(INT n0, INT is0, INT os0,
23  		       INT n1, INT is1, INT os1,
24  		       INT n2, INT is2, INT os2,
25  		       INT n3, INT is3, INT os3,
26  		       INT n4, INT is4, INT os4)
27  {
28       tensor *x = X(mktensor)(5);
29       x->dims[0].n = n0;
30       x->dims[0].is = is0;
31       x->dims[0].os = os0;
32       x->dims[1].n = n1;
33       x->dims[1].is = is1;
34       x->dims[1].os = os1;
35       x->dims[2].n = n2;
36       x->dims[2].is = is2;
37       x->dims[2].os = os2;
38       x->dims[3].n = n3;
39       x->dims[3].is = is3;
40       x->dims[3].os = os3;
41       x->dims[4].n = n4;
42       x->dims[4].is = is4;
43       x->dims[4].os = os4;
44       return x;
45  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-mallocx.c</h3>
            <pre><code>1  #include "test/jemalloc_test.h"
2  static unsigned
3  get_nsizes_impl(const char *cmd) {
4  	unsigned ret;
5  	size_t z;
6  	z = sizeof(unsigned);
7  	assert_d_eq(mallctl(cmd, (void *)&ret, &z, NULL, 0), 0,
8  	    "Unexpected mallctl(\"%s\", ...) failure", cmd);
9  	return ret;
10  }
11  static unsigned
12  get_nlarge(void) {
13  	return get_nsizes_impl("arenas.nlextents");
14  }
15  static size_t
16  get_size_impl(const char *cmd, size_t ind) {
17  	size_t ret;
18  	size_t z;
19  	size_t mib[4];
20  	size_t miblen = 4;
21  	z = sizeof(size_t);
22  	assert_d_eq(mallctlnametomib(cmd, mib, &miblen),
23  	    0, "Unexpected mallctlnametomib(\"%s\", ...) failure", cmd);
24  	mib[2] = ind;
25  	z = sizeof(size_t);
26  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&ret, &z, NULL, 0),
27  	    0, "Unexpected mallctlbymib([\"%s\", %zu], ...) failure", cmd, ind);
28  	return ret;
29  }
30  static size_t
31  get_large_size(size_t ind) {
32  	return get_size_impl("arenas.lextent.0.size", ind);
33  }
34  static void
35  purge(void) {
36  	assert_d_eq(mallctl("arena.0.purge", NULL, NULL, NULL, 0), 0,
37  	    "Unexpected mallctl error");
38  }
39  JEMALLOC_DIAGNOSTIC_PUSH
40  JEMALLOC_DIAGNOSTIC_IGNORE_ALLOC_SIZE_LARGER_THAN
41  TEST_BEGIN(test_overflow) {
42  	size_t largemax;
43  	largemax = get_large_size(get_nlarge()-1);
44  	assert_ptr_null(mallocx(largemax+1, 0),
45  	    "Expected OOM for mallocx(size=%#zx, 0)", largemax+1);
46  	assert_ptr_null(mallocx(ZU(PTRDIFF_MAX)+1, 0),
47  	    "Expected OOM for mallocx(size=%#zx, 0)", ZU(PTRDIFF_MAX)+1);
48  	assert_ptr_null(mallocx(SIZE_T_MAX, 0),
49  	    "Expected OOM for mallocx(size=%#zx, 0)", SIZE_T_MAX);
50  	assert_ptr_null(mallocx(1, MALLOCX_ALIGN(ZU(PTRDIFF_MAX)+1)),
51  	    "Expected OOM for mallocx(size=1, MALLOCX_ALIGN(%#zx))",
52  	    ZU(PTRDIFF_MAX)+1);
53  }
54  TEST_END
55  static void *
56  remote_alloc(void *arg) {
57  	unsigned arena;
58  	size_t sz = sizeof(unsigned);
59  	assert_d_eq(mallctl("arenas.create", (void *)&arena, &sz, NULL, 0), 0,
60  	    "Unexpected mallctl() failure");
61  	size_t large_sz;
62  	sz = sizeof(size_t);
63  	assert_d_eq(mallctl("arenas.lextent.0.size", (void *)&large_sz, &sz,
64  	    NULL, 0), 0, "Unexpected mallctl failure");
65  	void *ptr = mallocx(large_sz, MALLOCX_ARENA(arena)
66  	    | MALLOCX_TCACHE_NONE);
67  	void **ret = (void **)arg;
68  	*ret = ptr;
69  	return NULL;
70  }
71  TEST_BEGIN(test_remote_free) {
72  	thd_t thd;
73  	void *ret;
74  	thd_create(&thd, remote_alloc, (void *)&ret);
75  	thd_join(thd, NULL);
76  	assert_ptr_not_null(ret, "Unexpected mallocx failure");
77  	dallocx(ret, 0);
78  	mallctl("thread.tcache.flush", NULL, NULL, NULL, 0);
79  }
80  TEST_END
81  TEST_BEGIN(test_oom) {
82  	size_t largemax;
83  	bool oom;
84  	void *ptrs[3];
85  	unsigned i;
86  	largemax = get_large_size(get_nlarge()-1);
87  	oom = false;
88  	for (i = 0; i < sizeof(ptrs) / sizeof(void *); i++) {
89  		ptrs[i] = mallocx(largemax, MALLOCX_ARENA(0));
90  		if (ptrs[i] == NULL) {
91  			oom = true;
92  		}
93  	}
94  	assert_true(oom,
95  	    "Expected OOM during series of calls to mallocx(size=%zu, 0)",
96  	    largemax);
97  	for (i = 0; i < sizeof(ptrs) / sizeof(void *); i++) {
98  		if (ptrs[i] != NULL) {
99  			dallocx(ptrs[i], 0);
100  		}
101  	}
102  	purge();
103  #if LG_SIZEOF_PTR == 3
104  	assert_ptr_null(mallocx(0x8000000000000000ULL,
105  	    MALLOCX_ALIGN(0x8000000000000000ULL)),
106  	    "Expected OOM for mallocx()");
107  	assert_ptr_null(mallocx(0x8000000000000000ULL,
108  	    MALLOCX_ALIGN(0x80000000)),
109  	    "Expected OOM for mallocx()");
110  #else
111  	assert_ptr_null(mallocx(0x80000000UL, MALLOCX_ALIGN(0x80000000UL)),
112  	    "Expected OOM for mallocx()");
113  #endif
114  }
115  TEST_END
116  JEMALLOC_DIAGNOSTIC_POP
117  TEST_BEGIN(test_basic) {
118  #define MAXSZ (((size_t)1) << 23)
119  	size_t sz;
<span onclick='openModal()' class='match'>120  	for (sz = 1; sz < MAXSZ; sz = nallocx(sz, 0) + 1) {
121  		size_t nsz, rsz;
122  		void *p;
123  		nsz = nallocx(sz, 0);
124  		assert_zu_ne(nsz, 0, "Unexpected nallocx() error");
125  		p = mallocx(sz, 0);
126  		assert_ptr_not_null(p,
127  		    "Unexpected mallocx(size=%zx, flags=0) error", sz);
128  		rsz = sallocx(p, 0);
129  		assert_zu_ge(rsz, sz, "Real size smaller than expected");
130  		assert_zu_eq(nsz, rsz, "nallocx()/sallocx() size mismatch");
131  		dallocx(p, 0);
132  		p = mallocx(sz, 0);
133  		assert_ptr_not_null(p,
134  		    "Unexpected mallocx(size=%zx, flags=0) error", sz);
135  		dallocx(p, 0);
136  		nsz = nallocx(sz, MALLOCX_ZERO);
137  		assert_zu_ne(nsz, 0, "Unexpected nallocx() error");
138  		p = mallocx(sz, MALLOCX_ZERO);
139  		assert_ptr_not_null(p,
140  		    "Unexpected mallocx(size=%zx, flags=MALLOCX_ZERO) error",
141  		    nsz);
142  		rsz = sallocx(p, 0);
</span>143  		assert_zu_eq(nsz, rsz, "nallocx()/sallocx() rsize mismatch");
144  		dallocx(p, 0);
145  		purge();
146  	}
147  #undef MAXSZ
148  }
149  TEST_END
150  TEST_BEGIN(test_alignment_and_size) {
151  	const char *percpu_arena;
152  	size_t sz = sizeof(percpu_arena);
153  	if(mallctl("opt.percpu_arena", (void *)&percpu_arena, &sz, NULL, 0) ||
154  	    strcmp(percpu_arena, "disabled") != 0) {
155  		test_skip("test_alignment_and_size skipped: "
156  		    "not working with percpu arena.");
157  	};
158  #define MAXALIGN (((size_t)1) << 23)
159  #define NITER 4
160  	size_t nsz, rsz, alignment, total;
161  	unsigned i;
162  	void *ps[NITER];
163  	for (i = 0; i < NITER; i++) {
164  		ps[i] = NULL;
165  	}
166  	for (alignment = 8;
167  	    alignment <= MAXALIGN;
168  	    alignment <<= 1) {
169  		total = 0;
170  		for (sz = 1;
171  		    sz < 3 * alignment && sz < (1U << 31);
172  		    sz += (alignment >> (LG_SIZEOF_PTR-1)) - 1) {
173  			for (i = 0; i < NITER; i++) {
174  				nsz = nallocx(sz, MALLOCX_ALIGN(alignment) |
175  				    MALLOCX_ZERO | MALLOCX_ARENA(0));
176  				assert_zu_ne(nsz, 0,
177  				    "nallocx() error for alignment=%zu, "
178  				    "size=%zu (%#zx)", alignment, sz, sz);
179  				ps[i] = mallocx(sz, MALLOCX_ALIGN(alignment) |
180  				    MALLOCX_ZERO | MALLOCX_ARENA(0));
181  				assert_ptr_not_null(ps[i],
182  				    "mallocx() error for alignment=%zu, "
183  				    "size=%zu (%#zx)", alignment, sz, sz);
184  				rsz = sallocx(ps[i], 0);
185  				assert_zu_ge(rsz, sz,
186  				    "Real size smaller than expected for "
187  				    "alignment=%zu, size=%zu", alignment, sz);
188  				assert_zu_eq(nsz, rsz,
189  				    "nallocx()/sallocx() size mismatch for "
190  				    "alignment=%zu, size=%zu", alignment, sz);
191  				assert_ptr_null(
192  				    (void *)((uintptr_t)ps[i] & (alignment-1)),
193  				    "%p inadequately aligned for"
194  				    " alignment=%zu, size=%zu", ps[i],
195  				    alignment, sz);
196  				total += rsz;
197  				if (total >= (MAXALIGN << 1)) {
198  					break;
199  				}
200  			}
201  			for (i = 0; i < NITER; i++) {
202  				if (ps[i] != NULL) {
203  					dallocx(ps[i], 0);
204  					ps[i] = NULL;
205  				}
206  			}
207  		}
208  		purge();
209  	}
210  #undef MAXALIGN
211  #undef NITER
212  }
213  TEST_END
214  int
215  main(void) {
216  	return test(
217  	    test_overflow,
218  	    test_oom,
219  	    test_remote_free,
220  	    test_basic,
221  	    test_alignment_and_size);
222  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-tensor3.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-mallocx.c</div>
                <div class="column column_space"><pre><code>6  {
7       tensor *x = X(mktensor)(4);
8       x->dims[0].n = n0;
9       x->dims[0].is = is0;
10       x->dims[0].os = os0;
11       x->dims[1].n = n1;
12       x->dims[1].is = is1;
13       x->dims[1].os = os1;
</pre></code></div>
                <div class="column column_space"><pre><code>120  	for (sz = 1; sz < MAXSZ; sz = nallocx(sz, 0) + 1) {
121  		size_t nsz, rsz;
122  		void *p;
123  		nsz = nallocx(sz, 0);
124  		assert_zu_ne(nsz, 0, "Unexpected nallocx() error");
125  		p = mallocx(sz, 0);
126  		assert_ptr_not_null(p,
127  		    "Unexpected mallocx(size=%zx, flags=0) error", sz);
128  		rsz = sallocx(p, 0);
129  		assert_zu_ge(rsz, sz, "Real size smaller than expected");
130  		assert_zu_eq(nsz, rsz, "nallocx()/sallocx() size mismatch");
131  		dallocx(p, 0);
132  		p = mallocx(sz, 0);
133  		assert_ptr_not_null(p,
134  		    "Unexpected mallocx(size=%zx, flags=0) error", sz);
135  		dallocx(p, 0);
136  		nsz = nallocx(sz, MALLOCX_ZERO);
137  		assert_zu_ne(nsz, 0, "Unexpected nallocx() error");
138  		p = mallocx(sz, MALLOCX_ZERO);
139  		assert_ptr_not_null(p,
140  		    "Unexpected mallocx(size=%zx, flags=MALLOCX_ZERO) error",
141  		    nsz);
142  		rsz = sallocx(p, 0);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    