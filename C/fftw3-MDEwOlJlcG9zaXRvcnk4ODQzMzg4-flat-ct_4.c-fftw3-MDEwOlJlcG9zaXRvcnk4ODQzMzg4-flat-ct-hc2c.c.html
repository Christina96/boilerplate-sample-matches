
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-ct_4.c</h3>
            <pre><code>1  #include "dft/ct.h"
2  ct_solver *(*X(mksolver_ct_hook))(size_t, INT, int, 
3  				  ct_mkinferior, ct_force_vrecursion) = 0;
4  typedef struct {
5       plan_dft super;
6       plan *cld;
7       plan *cldw;
8       INT r;
9  } P;
10  static void apply_dit(const plan *ego_, R *ri, R *ii, R *ro, R *io)
11  {
12       const P *ego = (const P *) ego_;
13       plan_dft *cld;
14       plan_dftw *cldw;
15       cld = (plan_dft *) ego->cld;
16       cld->apply(ego->cld, ri, ii, ro, io);
17       cldw = (plan_dftw *) ego->cldw;
18       cldw->apply(ego->cldw, ro, io);
19  }
20  static void apply_dif(const plan *ego_, R *ri, R *ii, R *ro, R *io)
21  {
22       const P *ego = (const P *) ego_;
23       plan_dft *cld;
24       plan_dftw *cldw;
25       cldw = (plan_dftw *) ego->cldw;
26       cldw->apply(ego->cldw, ri, ii);
27       cld = (plan_dft *) ego->cld;
28       cld->apply(ego->cld, ri, ii, ro, io);
29  }
30  static void awake(plan *ego_, enum wakefulness wakefulness)
31  {
32       P *ego = (P *) ego_;
33       X(plan_awake)(ego->cld, wakefulness);
34       X(plan_awake)(ego->cldw, wakefulness);
35  }
36  static void destroy(plan *ego_)
37  {
38       P *ego = (P *) ego_;
39       X(plan_destroy_internal)(ego->cldw);
40       X(plan_destroy_internal)(ego->cld);
41  }
42  static void print(const plan *ego_, printer *p)
43  {
44       const P *ego = (const P *) ego_;
45       p->print(p, "(dft-ct-%s/%D%(%p%)%(%p%))",
46  	      ego->super.apply == apply_dit ? "dit" : "dif",
47  	      ego->r, ego->cldw, ego->cld);
48  }
49  static int applicable0(const ct_solver *ego, const problem *p_, planner *plnr)
50  {
51       const problem_dft *p = (const problem_dft *) p_;
52       INT r;
53       return (1
54  	     && p->sz->rnk == 1
55  	     && p->vecsz->rnk <= 1
56  	     && (ego->dec == DECDIT ||
57  		 p->ri == p->ro ||
58  		 !NO_DESTROY_INPUTP(plnr))
59  	     && ((r = X(choose_radix)(ego->r, p->sz->dims[0].n)) > 1)
60  	     && p->sz->dims[0].n > r);
61  }
62  int X(ct_applicable)(const ct_solver *ego, const problem *p_, planner *plnr)
63  {
64       const problem_dft *p;
65       if (!applicable0(ego, p_, plnr))
66            return 0;
67       p = (const problem_dft *) p_;
68       return (0
69  	     || ego->dec == DECDIF+TRANSPOSE
70  	     || p->vecsz->rnk == 0
71  	     || !NO_VRECURSEP(plnr)
72  	     || (ego->force_vrecursionp && ego->force_vrecursionp(ego, p))
73  	  );
74  }
75  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
76  {
77       const ct_solver *ego = (const ct_solver *) ego_;
78       const problem_dft *p;
79       P *pln = 0;
80       plan *cld = 0, *cldw = 0;
81       INT n, r, m, v, ivs, ovs;
82       iodim *d;
83       static const plan_adt padt = {
84  	  X(dft_solve), awake, print, destroy
85       };
86       if ((NO_NONTHREADEDP(plnr)) || !X(ct_applicable)(ego, p_, plnr))
87            return (plan *) 0;
88       p = (const problem_dft *) p_;
89       d = p->sz->dims;
90       n = d[0].n;
91       r = X(choose_radix)(ego->r, n);
92       m = n / r;
93       X(tensor_tornk1)(p->vecsz, &v, &ivs, &ovs);
94       switch (ego->dec) {
95  	 case DECDIT:
96  	 {
97  	      cldw = ego->mkcldw(ego,
98  				 r, m * d[0].os, m * d[0].os,
99  				 m, d[0].os,
100  				 v, ovs, ovs,
101  				 0, m,
102  				 p->ro, p->io, plnr);
103  	      if (!cldw) goto nada;
104  	      cld = X(mkplan_d)(plnr,
105  				X(mkproblem_dft_d)(
106  				     X(mktensor_1d)(m, r * d[0].is, d[0].os),
107  				     X(mktensor_2d)(r, d[0].is, m * d[0].os,
108  						    v, ivs, ovs),
109  				     p->ri, p->ii, p->ro, p->io)
110  		   );
111  	      if (!cld) goto nada;
<span onclick='openModal()' class='match'>112  	      pln = MKPLAN_DFT(P, &padt, apply_dit);
113  	      break;
114  	 }
115  	 case DECDIF:
</span>116  	 case DECDIF+TRANSPOSE:
117  	 {
118  	      INT cors, covs; &bsol;* cldw ors, ovs */
119  	      if (ego->dec == DECDIF+TRANSPOSE) {
120  		   cors = ivs;
121  		   covs = m * d[0].is;
122  		   if (!(1
123  			 && r == v
124  			 && d[0].is == r * cors))
125  			goto nada;
126  		   if (!(1
127  			 && p->ri == p->ro
128  			 && d[0].is == r * d[0].os
129  			 && cors == d[0].os
130  			 && covs == ovs
131  			    ))
132  			goto nada;
133  	      } else {
134  		   cors = m * d[0].is;
135  		   covs = ivs;
136  	      }
137  	      cldw = ego->mkcldw(ego,
138  				 r, m * d[0].is, cors,
139  				 m, d[0].is,
140  				 v, ivs, covs,
141  				 0, m,
142  				 p->ri, p->ii, plnr);
143  	      if (!cldw) goto nada;
144  	      cld = X(mkplan_d)(plnr,
145  				X(mkproblem_dft_d)(
146  				     X(mktensor_1d)(m, d[0].is, r * d[0].os),
147  				     X(mktensor_2d)(r, cors, d[0].os,
148  						    v, covs, ovs),
149  				     p->ri, p->ii, p->ro, p->io)
150  		   );
151  	      if (!cld) goto nada;
152  	      pln = MKPLAN_DFT(P, &padt, apply_dif);
153  	      break;
154  	 }
155  	 default: A(0);
156       }
157       pln->cld = cld;
158       pln->cldw = cldw;
159       pln->r = r;
160       X(ops_add)(&cld->ops, &cldw->ops, &pln->super.super.ops);
161       pln->super.super.could_prune_now_p = cldw->could_prune_now_p;
162       return &(pln->super.super);
163   nada:
164       X(plan_destroy_internal)(cldw);
165       X(plan_destroy_internal)(cld);
166       return (plan *) 0;
167  }
168  ct_solver *X(mksolver_ct)(size_t size, INT r, int dec, 
169  			  ct_mkinferior mkcldw,
170  			  ct_force_vrecursion force_vrecursionp)
171  {
172       static const solver_adt sadt = { PROBLEM_DFT, mkplan, 0 };
173       ct_solver *slv = (ct_solver *)X(mksolver)(size, &sadt);
174       slv->r = r;
175       slv->dec = dec;
176       slv->mkcldw = mkcldw;
177       slv->force_vrecursionp = force_vrecursionp;
178       return slv;
179  }
180  plan *X(mkplan_dftw)(size_t size, const plan_adt *adt, dftwapply apply)
181  {
182       plan_dftw *ego;
183       ego = (plan_dftw *) X(mkplan)(size, adt);
184       ego->apply = apply;
185       return &(ego->super);
186  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-ct-hc2c.c</h3>
            <pre><code>1  #include "ct-hc2c.h"
2  #include "dft/dft.h"
3  typedef struct {
4       plan_rdft2 super;
5       plan *cld;
6       plan *cldw;
7       INT r;
8  } P;
9  static void apply_dit(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
10  {
11       const P *ego = (const P *) ego_;
12       plan_rdft *cld;
13       plan_hc2c *cldw;
14       UNUSED(r1);
15       cld = (plan_rdft *) ego->cld;
16       cld->apply(ego->cld, r0, cr);
17       cldw = (plan_hc2c *) ego->cldw;
18       cldw->apply(ego->cldw, cr, ci);
19  }
20  static void apply_dif(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
21  {
22       const P *ego = (const P *) ego_;
23       plan_rdft *cld;
24       plan_hc2c *cldw;
25       UNUSED(r1);
26       cldw = (plan_hc2c *) ego->cldw;
27       cldw->apply(ego->cldw, cr, ci);
28       cld = (plan_rdft *) ego->cld;
29       cld->apply(ego->cld, cr, r0);
30  }
31  static void apply_dit_dft(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
32  {
33       const P *ego = (const P *) ego_;
34       plan_dft *cld;
35       plan_hc2c *cldw;
36       cld = (plan_dft *) ego->cld;
37       cld->apply(ego->cld, r0, r1, cr, ci);
38       cldw = (plan_hc2c *) ego->cldw;
39       cldw->apply(ego->cldw, cr, ci);
40  }
41  static void apply_dif_dft(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
42  {
43       const P *ego = (const P *) ego_;
44       plan_dft *cld;
45       plan_hc2c *cldw;
46       cldw = (plan_hc2c *) ego->cldw;
47       cldw->apply(ego->cldw, cr, ci);
48       cld = (plan_dft *) ego->cld;
49       cld->apply(ego->cld, ci, cr, r1, r0);
50  }
51  static void awake(plan *ego_, enum wakefulness wakefulness)
52  {
53       P *ego = (P *) ego_;
54       X(plan_awake)(ego->cld, wakefulness);
55       X(plan_awake)(ego->cldw, wakefulness);
56  }
57  static void destroy(plan *ego_)
58  {
59       P *ego = (P *) ego_;
60       X(plan_destroy_internal)(ego->cldw);
61       X(plan_destroy_internal)(ego->cld);
62  }
63  static void print(const plan *ego_, printer *p)
64  {
65       const P *ego = (const P *) ego_;
66       p->print(p, "(rdft2-ct-%s/%D%(%p%)%(%p%))",
67  	      (ego->super.apply == apply_dit || 
68  	       ego->super.apply == apply_dit_dft)
69  	      ? "dit" : "dif",
70  	      ego->r, ego->cldw, ego->cld);
71  }
72  static int applicable0(const hc2c_solver *ego, const problem *p_, planner *plnr)
73  {
74       const problem_rdft2 *p = (const problem_rdft2 *) p_;
75       INT r;
76       return (1
77  	     && p->sz->rnk == 1
78  	     && p->vecsz->rnk <= 1 
79  	     && (&bsol;* either the problem is R2HC, which is solved by DIT */
80  		  (p->kind == R2HC)
81  		  ||
82  		  (p->kind == HC2R && 
83  		   (p->r0 == p->cr || !NO_DESTROY_INPUTP(plnr))))
84  	     && ((r = X(choose_radix)(ego->r, p->sz->dims[0].n)) > 0)
85  	     && p->sz->dims[0].n > r);
86  }
87  static int hc2c_applicable(const hc2c_solver *ego, const problem *p_,
88                             planner *plnr)
89  {
90       const problem_rdft2 *p;
91       if (!applicable0(ego, p_, plnr))
92            return 0;
93       p = (const problem_rdft2 *) p_;
94       return (0
95  	     || p->vecsz->rnk == 0
96  	     || !NO_VRECURSEP(plnr)
97  	  );
98  }
99  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
100  {
101       const hc2c_solver *ego = (const hc2c_solver *) ego_;
102       const problem_rdft2 *p;
103       P *pln = 0;
104       plan *cld = 0, *cldw = 0;
105       INT n, r, m, v, ivs, ovs;
106       iodim *d;
107       static const plan_adt padt = {
108  	  X(rdft2_solve), awake, print, destroy
109       };
110       if (!hc2c_applicable(ego, p_, plnr))
111            return (plan *) 0;
112       p = (const problem_rdft2 *) p_;
113       d = p->sz->dims;
114       n = d[0].n;
115       r = X(choose_radix)(ego->r, n);
116       A((r % 2) == 0);
117       m = n / r;
118       X(tensor_tornk1)(p->vecsz, &v, &ivs, &ovs);
119       switch (p->kind) {
120  	 case R2HC:
121  	      cldw = ego->mkcldw(ego, R2HC, 
122  				 r, m * d[0].os, 
123  				 m, d[0].os,
124  				 v, ovs,
125  				 p->cr, p->ci, plnr);
126  	      if (!cldw) goto nada;
127  	      switch (ego->hc2ckind) {
128  		  case HC2C_VIA_RDFT:
129  		       cld = X(mkplan_d)(
130  			    plnr, 
131  			    X(mkproblem_rdft_1_d)(
132  				 X(mktensor_1d)(m, (r/2)*d[0].is, d[0].os),
133  				 X(mktensor_3d)(
134  				      2, p->r1 - p->r0, p->ci - p->cr,
135  				      r / 2, d[0].is, m * d[0].os,
136  				      v, ivs, ovs),
137  				 p->r0, p->cr, R2HC) 
138  			    );
139  		       if (!cld) goto nada;
140  		       pln = MKPLAN_RDFT2(P, &padt, apply_dit);
141  		       break;
142  		  case HC2C_VIA_DFT:
143  		       cld = X(mkplan_d)(
144  			    plnr, 
145  			    X(mkproblem_dft_d)(
146  				 X(mktensor_1d)(m, (r/2)*d[0].is, d[0].os),
147  				 X(mktensor_2d)(
148  				      r / 2, d[0].is, m * d[0].os,
149  				      v, ivs, ovs),
150  				 p->r0, p->r1, p->cr, p->ci) 
151  			    );
152  		       if (!cld) goto nada;
<span onclick='openModal()' class='match'>153  		       pln = MKPLAN_RDFT2(P, &padt, apply_dit_dft);
154  		       break;
155  	      }
156  	      break;
</span>157  	 case HC2R:
158  	      cldw = ego->mkcldw(ego, HC2R, 
159  				 r, m * d[0].is, 
160  				 m, d[0].is,
161  				 v, ivs,
162  				 p->cr, p->ci, plnr);
163  	      if (!cldw) goto nada;
164  	      switch (ego->hc2ckind) {
165  		  case HC2C_VIA_RDFT:
166  		       cld = X(mkplan_d)(
167  			    plnr, 
168  			    X(mkproblem_rdft_1_d)(
169  				 X(mktensor_1d)(m, d[0].is, (r/2)*d[0].os),
170  				 X(mktensor_3d)(
171  				      2, p->ci - p->cr, p->r1 - p->r0, 
172  				      r / 2, m * d[0].is, d[0].os,
173  				      v, ivs, ovs),
174  				 p->cr, p->r0, HC2R) 
175  			    );
176  		       if (!cld) goto nada;
177  		       pln = MKPLAN_RDFT2(P, &padt, apply_dif);
178  		       break;
179  		  case HC2C_VIA_DFT:
180  		       cld = X(mkplan_d)(
181  			    plnr, 
182  			    X(mkproblem_dft_d)(
183  				 X(mktensor_1d)(m, d[0].is, (r/2)*d[0].os),
184  				 X(mktensor_2d)(
185  				      r / 2, m * d[0].is, d[0].os,
186  				      v, ivs, ovs),
187  				 p->ci, p->cr, p->r1, p->r0) 
188  			    );
189  		       if (!cld) goto nada;
190  		       pln = MKPLAN_RDFT2(P, &padt, apply_dif_dft);
191  		       break;
192  	      }
193  	      break;
194  	 default: 
195  	      A(0);
196       }
197       pln->cld = cld;
198       pln->cldw = cldw;
199       pln->r = r;
200       X(ops_add)(&cld->ops, &cldw->ops, &pln->super.super.ops);
201       pln->super.super.could_prune_now_p = cldw->could_prune_now_p;
202       return &(pln->super.super);
203   nada:
204       X(plan_destroy_internal)(cldw);
205       X(plan_destroy_internal)(cld);
206       return (plan *) 0;
207  }
208  hc2c_solver *X(mksolver_hc2c)(size_t size, INT r, 
209  			      hc2c_kind hc2ckind,
210  			      hc2c_mkinferior mkcldw)
211  {
212       static const solver_adt sadt = { PROBLEM_RDFT2, mkplan, 0 };
213       hc2c_solver *slv = (hc2c_solver *)X(mksolver)(size, &sadt);
214       slv->r = r;
215       slv->hc2ckind = hc2ckind;
216       slv->mkcldw = mkcldw;
217       return slv;
218  }
219  plan *X(mkplan_hc2c)(size_t size, const plan_adt *adt, hc2capply apply)
220  {
221       plan_hc2c *ego;
222       ego = (plan_hc2c *) X(mkplan)(size, adt);
223       ego->apply = apply;
224       return &(ego->super);
225  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-ct_4.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-ct-hc2c.c</div>
                </div>
                <div class="column column_space"><pre><code>112  	      pln = MKPLAN_DFT(P, &padt, apply_dit);
113  	      break;
114  	 }
115  	 case DECDIF:
</pre></code></div>
                <div class="column column_space"><pre><code>153  		       pln = MKPLAN_RDFT2(P, &padt, apply_dit_dft);
154  		       break;
155  	      }
156  	      break;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    