
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 23, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-schema.h</h3>
            <pre><code>1  #ifndef RAPIDJSON_SCHEMA_H_
2  #define RAPIDJSON_SCHEMA_H_
3  #include "document.h"
4  #include "pointer.h"
5  #include "stringbuffer.h"
6  #include "error/en.h"
7  #include "uri.h"
8  #include <cmath> 
9  #if !defined(RAPIDJSON_SCHEMA_USE_INTERNALREGEX)
10  #define RAPIDJSON_SCHEMA_USE_INTERNALREGEX 1
11  #else
12  #define RAPIDJSON_SCHEMA_USE_INTERNALREGEX 0
13  #endif
14  #if !RAPIDJSON_SCHEMA_USE_INTERNALREGEX && defined(RAPIDJSON_SCHEMA_USE_STDREGEX) && (__cplusplus >=201103L || (defined(_MSC_VER) && _MSC_VER >= 1800))
15  #define RAPIDJSON_SCHEMA_USE_STDREGEX 1
16  #else
17  #define RAPIDJSON_SCHEMA_USE_STDREGEX 0
18  #endif
19  #if RAPIDJSON_SCHEMA_USE_INTERNALREGEX
20  #include "internal/regex.h"
21  #elif RAPIDJSON_SCHEMA_USE_STDREGEX
22  #include <regex>
23  #endif
24  #if RAPIDJSON_SCHEMA_USE_INTERNALREGEX || RAPIDJSON_SCHEMA_USE_STDREGEX
25  #define RAPIDJSON_SCHEMA_HAS_REGEX 1
26  #else
27  #define RAPIDJSON_SCHEMA_HAS_REGEX 0
28  #endif
29  #ifndef RAPIDJSON_SCHEMA_VERBOSE
30  #define RAPIDJSON_SCHEMA_VERBOSE 0
31  #endif
32  #if RAPIDJSON_SCHEMA_VERBOSE
33  #include "stringbuffer.h"
34  #endif
35  RAPIDJSON_DIAG_PUSH
36  #if defined(__GNUC__)
37  RAPIDJSON_DIAG_OFF(effc++)
38  #endif
39  #ifdef __clang__
40  RAPIDJSON_DIAG_OFF(weak-vtables)
41  RAPIDJSON_DIAG_OFF(exit-time-destructors)
42  RAPIDJSON_DIAG_OFF(c++98-compat-pedantic)
43  RAPIDJSON_DIAG_OFF(variadic-macros)
44  #elif defined(_MSC_VER)
45  RAPIDJSON_DIAG_OFF(4512) 
46  #endif
47  RAPIDJSON_NAMESPACE_BEGIN
48  #if RAPIDJSON_SCHEMA_VERBOSE
49  namespace internal {
50  inline void PrintInvalidKeyword(const char* keyword) {
51      printf("Fail keyword: %s\n", keyword);
52  }
53  inline void PrintInvalidKeyword(const wchar_t* keyword) {
54      wprintf(L"Fail keyword: %ls\n", keyword);
55  }
56  inline void PrintInvalidDocument(const char* document) {
57      printf("Fail document: %s\n\n", document);
58  }
59  inline void PrintInvalidDocument(const wchar_t* document) {
60      wprintf(L"Fail document: %ls\n\n", document);
61  }
62  inline void PrintValidatorPointers(unsigned depth, const char* s, const char* d) {
63      printf("S: %*s%s\nD: %*s%s\n\n", depth * 4, " ", s, depth * 4, " ", d);
64  }
65  inline void PrintValidatorPointers(unsigned depth, const wchar_t* s, const wchar_t* d) {
66      wprintf(L"S: %*ls%ls\nD: %*ls%ls\n\n", depth * 4, L" ", s, depth * 4, L" ", d);
67  }
68  } 
69  #endif 
70  #if RAPIDJSON_SCHEMA_VERBOSE
71  #define RAPIDJSON_INVALID_KEYWORD_VERBOSE(keyword) internal::PrintInvalidKeyword(keyword)
72  #else
73  #define RAPIDJSON_INVALID_KEYWORD_VERBOSE(keyword)
74  #endif
75  #define RAPIDJSON_INVALID_KEYWORD_RETURN(code)\
76  RAPIDJSON_MULTILINEMACRO_BEGIN\
77      context.invalidCode = code;\
78      context.invalidKeyword = SchemaType::GetValidateErrorKeyword(code).GetString();\
79      RAPIDJSON_INVALID_KEYWORD_VERBOSE(context.invalidKeyword);\
80      return false;\
81  RAPIDJSON_MULTILINEMACRO_END
82  #ifndef RAPIDJSON_VALIDATE_DEFAULT_FLAGS
83  #define RAPIDJSON_VALIDATE_DEFAULT_FLAGS kValidateNoFlags
84  #endif
85  enum ValidateFlag {
86      kValidateNoFlags = 0,                                       
87      kValidateContinueOnErrorFlag = 1,                           
88      kValidateDefaultFlags = RAPIDJSON_VALIDATE_DEFAULT_FLAGS    
89  };
90  template <typename ValueType, typename Allocator>
91  class GenericSchemaDocument;
92  namespace internal {
93  template <typename SchemaDocumentType>
94  class Schema;
95  class ISchemaValidator {
96  public:
97      virtual ~ISchemaValidator() {}
98      virtual bool IsValid() const = 0;
99      virtual void SetValidateFlags(unsigned flags) = 0;
100      virtual unsigned GetValidateFlags() const = 0;
101  };
102  template <typename SchemaType>
103  class ISchemaStateFactory {
104  public:
105      virtual ~ISchemaStateFactory() {}
106      virtual ISchemaValidator* CreateSchemaValidator(const SchemaType&, const bool inheritContinueOnErrors) = 0;
107      virtual void DestroySchemaValidator(ISchemaValidator* validator) = 0;
108      virtual void* CreateHasher() = 0;
109      virtual uint64_t GetHashCode(void* hasher) = 0;
110      virtual void DestroryHasher(void* hasher) = 0;
111      virtual void* MallocState(size_t size) = 0;
112      virtual void FreeState(void* p) = 0;
113  };
114  template <typename SchemaType>
115  class IValidationErrorHandler {
116  public:
117      typedef typename SchemaType::Ch Ch;
118      typedef typename SchemaType::SValue SValue;
119      virtual ~IValidationErrorHandler() {}
120      virtual void NotMultipleOf(int64_t actual, const SValue& expected) = 0;
121      virtual void NotMultipleOf(uint64_t actual, const SValue& expected) = 0;
122      virtual void NotMultipleOf(double actual, const SValue& expected) = 0;
123      virtual void AboveMaximum(int64_t actual, const SValue& expected, bool exclusive) = 0;
124      virtual void AboveMaximum(uint64_t actual, const SValue& expected, bool exclusive) = 0;
125      virtual void AboveMaximum(double actual, const SValue& expected, bool exclusive) = 0;
126      virtual void BelowMinimum(int64_t actual, const SValue& expected, bool exclusive) = 0;
127      virtual void BelowMinimum(uint64_t actual, const SValue& expected, bool exclusive) = 0;
128      virtual void BelowMinimum(double actual, const SValue& expected, bool exclusive) = 0;
129      virtual void TooLong(const Ch* str, SizeType length, SizeType expected) = 0;
130      virtual void TooShort(const Ch* str, SizeType length, SizeType expected) = 0;
131      virtual void DoesNotMatch(const Ch* str, SizeType length) = 0;
132      virtual void DisallowedItem(SizeType index) = 0;
133      virtual void TooFewItems(SizeType actualCount, SizeType expectedCount) = 0;
134      virtual void TooManyItems(SizeType actualCount, SizeType expectedCount) = 0;
135      virtual void DuplicateItems(SizeType index1, SizeType index2) = 0;
136      virtual void TooManyProperties(SizeType actualCount, SizeType expectedCount) = 0;
137      virtual void TooFewProperties(SizeType actualCount, SizeType expectedCount) = 0;
138      virtual void StartMissingProperties() = 0;
139      virtual void AddMissingProperty(const SValue& name) = 0;
140      virtual bool EndMissingProperties() = 0;
141      virtual void PropertyViolations(ISchemaValidator** subvalidators, SizeType count) = 0;
142      virtual void DisallowedProperty(const Ch* name, SizeType length) = 0;
143      virtual void StartDependencyErrors() = 0;
144      virtual void StartMissingDependentProperties() = 0;
145      virtual void AddMissingDependentProperty(const SValue& targetName) = 0;
146      virtual void EndMissingDependentProperties(const SValue& sourceName) = 0;
147      virtual void AddDependencySchemaError(const SValue& souceName, ISchemaValidator* subvalidator) = 0;
148      virtual bool EndDependencyErrors() = 0;
149      virtual void DisallowedValue(const ValidateErrorCode code) = 0;
150      virtual void StartDisallowedType() = 0;
151      virtual void AddExpectedType(const typename SchemaType::ValueType& expectedType) = 0;
152      virtual void EndDisallowedType(const typename SchemaType::ValueType& actualType) = 0;
153      virtual void NotAllOf(ISchemaValidator** subvalidators, SizeType count) = 0;
154      virtual void NoneOf(ISchemaValidator** subvalidators, SizeType count) = 0;
155      virtual void NotOneOf(ISchemaValidator** subvalidators, SizeType count, bool matched) = 0;
156      virtual void Disallowed() = 0;
157  };
158  template<typename Encoding, typename Allocator>
159  class Hasher {
160  public:
161      typedef typename Encoding::Ch Ch;
162      Hasher(Allocator* allocator = 0, size_t stackCapacity = kDefaultSize) : stack_(allocator, stackCapacity) {}
163      bool Null() { return WriteType(kNullType); }
164      bool Bool(bool b) { return WriteType(b ? kTrueType : kFalseType); }
165      bool Int(int i) { Number n; n.u.i = i; n.d = static_cast<double>(i); return WriteNumber(n); }
166      bool Uint(unsigned u) { Number n; n.u.u = u; n.d = static_cast<double>(u); return WriteNumber(n); }
167      bool Int64(int64_t i) { Number n; n.u.i = i; n.d = static_cast<double>(i); return WriteNumber(n); }
168      bool Uint64(uint64_t u) { Number n; n.u.u = u; n.d = static_cast<double>(u); return WriteNumber(n); }
169      bool Double(double d) {
170          Number n;
171          if (d < 0) n.u.i = static_cast<int64_t>(d);
172          else       n.u.u = static_cast<uint64_t>(d);
173          n.d = d;
174          return WriteNumber(n);
175      }
176      bool RawNumber(const Ch* str, SizeType len, bool) {
177          WriteBuffer(kNumberType, str, len * sizeof(Ch));
178          return true;
179      }
180      bool String(const Ch* str, SizeType len, bool) {
181          WriteBuffer(kStringType, str, len * sizeof(Ch));
182          return true;
183      }
184      bool StartObject() { return true; }
185      bool Key(const Ch* str, SizeType len, bool copy) { return String(str, len, copy); }
186      bool EndObject(SizeType memberCount) {
187          uint64_t h = Hash(0, kObjectType);
188          uint64_t* kv = stack_.template Pop<uint64_t>(memberCount * 2);
189          for (SizeType i = 0; i < memberCount; i++)
190              h ^= Hash(kv[i * 2], kv[i * 2 + 1]);  
191          *stack_.template Push<uint64_t>() = h;
192          return true;
193      }
194      bool StartArray() { return true; }
195      bool EndArray(SizeType elementCount) {
196          uint64_t h = Hash(0, kArrayType);
197          uint64_t* e = stack_.template Pop<uint64_t>(elementCount);
198          for (SizeType i = 0; i < elementCount; i++)
199              h = Hash(h, e[i]); 
200          *stack_.template Push<uint64_t>() = h;
201          return true;
202      }
203      bool IsValid() const { return stack_.GetSize() == sizeof(uint64_t); }
204      uint64_t GetHashCode() const {
205          RAPIDJSON_ASSERT(IsValid());
206          return *stack_.template Top<uint64_t>();
207      }
208  private:
209      static const size_t kDefaultSize = 256;
210      struct Number {
211          union U {
212              uint64_t u;
213              int64_t i;
214          }u;
215          double d;
216      };
217      bool WriteType(Type type) { return WriteBuffer(type, 0, 0); }
218      bool WriteNumber(const Number& n) { return WriteBuffer(kNumberType, &n, sizeof(n)); }
219      bool WriteBuffer(Type type, const void* data, size_t len) {
220          uint64_t h = Hash(RAPIDJSON_UINT64_C2(0x84222325, 0xcbf29ce4), type);
221          const unsigned char* d = static_cast<const unsigned char*>(data);
222          for (size_t i = 0; i < len; i++)
223              h = Hash(h, d[i]);
224          *stack_.template Push<uint64_t>() = h;
225          return true;
226      }
227      static uint64_t Hash(uint64_t h, uint64_t d) {
228          static const uint64_t kPrime = RAPIDJSON_UINT64_C2(0x00000100, 0x000001b3);
229          h ^= d;
230          h *= kPrime;
231          return h;
232      }
233      Stack<Allocator> stack_;
234  };
235  template <typename SchemaDocumentType>
236  struct SchemaValidationContext {
237      typedef Schema<SchemaDocumentType> SchemaType;
238      typedef ISchemaStateFactory<SchemaType> SchemaValidatorFactoryType;
239      typedef IValidationErrorHandler<SchemaType> ErrorHandlerType;
240      typedef typename SchemaType::ValueType ValueType;
241      typedef typename ValueType::Ch Ch;
242      enum PatternValidatorType {
243          kPatternValidatorOnly,
244          kPatternValidatorWithProperty,
245          kPatternValidatorWithAdditionalProperty
246      };
247      SchemaValidationContext(SchemaValidatorFactoryType& f, ErrorHandlerType& eh, const SchemaType* s) :
248          factory(f),
249          error_handler(eh),
250          schema(s),
251          valueSchema(),
252          invalidKeyword(),
253          invalidCode(),
254          hasher(),
255          arrayElementHashCodes(),
256          validators(),
257          validatorCount(),
258          patternPropertiesValidators(),
259          patternPropertiesValidatorCount(),
260          patternPropertiesSchemas(),
261          patternPropertiesSchemaCount(),
262          valuePatternValidatorType(kPatternValidatorOnly),
263          propertyExist(),
264          inArray(false),
265          valueUniqueness(false),
266          arrayUniqueness(false)
267      {
268      }
269      ~SchemaValidationContext() {
270          if (hasher)
271              factory.DestroryHasher(hasher);
272          if (validators) {
273              for (SizeType i = 0; i < validatorCount; i++)
274                  factory.DestroySchemaValidator(validators[i]);
275              factory.FreeState(validators);
276          }
277          if (patternPropertiesValidators) {
278              for (SizeType i = 0; i < patternPropertiesValidatorCount; i++)
279                  factory.DestroySchemaValidator(patternPropertiesValidators[i]);
280              factory.FreeState(patternPropertiesValidators);
281          }
282          if (patternPropertiesSchemas)
283              factory.FreeState(patternPropertiesSchemas);
284          if (propertyExist)
285              factory.FreeState(propertyExist);
286      }
287      SchemaValidatorFactoryType& factory;
288      ErrorHandlerType& error_handler;
289      const SchemaType* schema;
290      const SchemaType* valueSchema;
291      const Ch* invalidKeyword;
292      ValidateErrorCode invalidCode;
293      void* hasher; 
294      void* arrayElementHashCodes; 
295      ISchemaValidator** validators;
296      SizeType validatorCount;
297      ISchemaValidator** patternPropertiesValidators;
298      SizeType patternPropertiesValidatorCount;
299      const SchemaType** patternPropertiesSchemas;
300      SizeType patternPropertiesSchemaCount;
301      PatternValidatorType valuePatternValidatorType;
302      PatternValidatorType objectPatternValidatorType;
303      SizeType arrayElementIndex;
304      bool* propertyExist;
305      bool inArray;
306      bool valueUniqueness;
307      bool arrayUniqueness;
308  };
309  template <typename SchemaDocumentType>
310  class Schema {
311  public:
312      typedef typename SchemaDocumentType::ValueType ValueType;
313      typedef typename SchemaDocumentType::AllocatorType AllocatorType;
314      typedef typename SchemaDocumentType::PointerType PointerType;
315      typedef typename ValueType::EncodingType EncodingType;
316      typedef typename EncodingType::Ch Ch;
317      typedef SchemaValidationContext<SchemaDocumentType> Context;
318      typedef Schema<SchemaDocumentType> SchemaType;
319      typedef GenericValue<EncodingType, AllocatorType> SValue;
320      typedef IValidationErrorHandler<Schema> ErrorHandler;
321      typedef GenericUri<ValueType, AllocatorType> UriType;
322      friend class GenericSchemaDocument<ValueType, AllocatorType>;
323      Schema(SchemaDocumentType* schemaDocument, const PointerType& p, const ValueType& value, const ValueType& document, AllocatorType* allocator, const UriType& id = UriType()) :
324          allocator_(allocator),
325          uri_(schemaDocument->GetURI(), *allocator),
326          id_(id),
327          pointer_(p, allocator),
328          typeless_(schemaDocument->GetTypeless()),
329          enum_(),
330          enumCount_(),
331          not_(),
332          type_((1 << kTotalSchemaType) - 1), 
333          validatorCount_(),
334          notValidatorIndex_(),
335          properties_(),
336          additionalPropertiesSchema_(),
337          patternProperties_(),
338          patternPropertyCount_(),
339          propertyCount_(),
340          minProperties_(),
341          maxProperties_(SizeType(~0)),
342          additionalProperties_(true),
343          hasDependencies_(),
344          hasRequired_(),
345          hasSchemaDependencies_(),
346          additionalItemsSchema_(),
347          itemsList_(),
348          itemsTuple_(),
349          itemsTupleCount_(),
350          minItems_(),
351          maxItems_(SizeType(~0)),
352          additionalItems_(true),
353          uniqueItems_(false),
354          pattern_(),
355          minLength_(0),
356          maxLength_(~SizeType(0)),
357          exclusiveMinimum_(false),
358          exclusiveMaximum_(false),
359          defaultValueLength_(0)
360      {
361          typedef typename ValueType::ConstValueIterator ConstValueIterator;
362          typedef typename ValueType::ConstMemberIterator ConstMemberIterator;
363          if (this != typeless_) {
364            typedef typename SchemaDocumentType::SchemaEntry SchemaEntry;
365            SchemaEntry *entry = schemaDocument->schemaMap_.template Push<SchemaEntry>();
366            new (entry) SchemaEntry(pointer_, this, true, allocator_);
367            schemaDocument->AddSchemaRefs(this);
368          }
369          if (!value.IsObject())
370              return;
371          if (const ValueType* v = GetMember(value, GetIdString())) {
372              if (v->IsString()) {
373                  UriType local(*v, allocator);
374                  id_ = local.Resolve(id_, allocator);
375              }
376          }
377          if (const ValueType* v = GetMember(value, GetTypeString())) {
378              type_ = 0;
379              if (v->IsString())
380                  AddType(*v);
381              else if (v->IsArray())
382                  for (ConstValueIterator itr = v->Begin(); itr != v->End(); ++itr)
383                      AddType(*itr);
384          }
385          if (const ValueType* v = GetMember(value, GetEnumString())) {
386              if (v->IsArray() && v->Size() > 0) {
387                  enum_ = static_cast<uint64_t*>(allocator_->Malloc(sizeof(uint64_t) * v->Size()));
388                  for (ConstValueIterator itr = v->Begin(); itr != v->End(); ++itr) {
389                      typedef Hasher<EncodingType, MemoryPoolAllocator<> > EnumHasherType;
390                      char buffer[256u + 24];
391                      MemoryPoolAllocator<> hasherAllocator(buffer, sizeof(buffer));
392                      EnumHasherType h(&hasherAllocator, 256);
393                      itr->Accept(h);
394                      enum_[enumCount_++] = h.GetHashCode();
395                  }
396              }
397          }
398          if (schemaDocument) {
399              AssignIfExist(allOf_, *schemaDocument, p, value, GetAllOfString(), document);
400              AssignIfExist(anyOf_, *schemaDocument, p, value, GetAnyOfString(), document);
401              AssignIfExist(oneOf_, *schemaDocument, p, value, GetOneOfString(), document);
402              if (const ValueType* v = GetMember(value, GetNotString())) {
403                  schemaDocument->CreateSchema(&not_, p.Append(GetNotString(), allocator_), *v, document, id_);
404                  notValidatorIndex_ = validatorCount_;
405                  validatorCount_++;
406              }
407          }
408          const ValueType* properties = GetMember(value, GetPropertiesString());
409          const ValueType* required = GetMember(value, GetRequiredString());
410          const ValueType* dependencies = GetMember(value, GetDependenciesString());
411          {
412              SValue allProperties(kArrayType);
413              if (properties && properties->IsObject())
414                  for (ConstMemberIterator itr = properties->MemberBegin(); itr != properties->MemberEnd(); ++itr)
415                      AddUniqueElement(allProperties, itr->name);
416              if (required && required->IsArray())
417                  for (ConstValueIterator itr = required->Begin(); itr != required->End(); ++itr)
418                      if (itr->IsString())
419                          AddUniqueElement(allProperties, *itr);
420              if (dependencies && dependencies->IsObject())
421                  for (ConstMemberIterator itr = dependencies->MemberBegin(); itr != dependencies->MemberEnd(); ++itr) {
422                      AddUniqueElement(allProperties, itr->name);
423                      if (itr->value.IsArray())
424                          for (ConstValueIterator i = itr->value.Begin(); i != itr->value.End(); ++i)
425                              if (i->IsString())
426                                  AddUniqueElement(allProperties, *i);
427                  }
428              if (allProperties.Size() > 0) {
429                  propertyCount_ = allProperties.Size();
430                  properties_ = static_cast<Property*>(allocator_->Malloc(sizeof(Property) * propertyCount_));
431                  for (SizeType i = 0; i < propertyCount_; i++) {
432                      new (&properties_[i]) Property();
433                      properties_[i].name = allProperties[i];
434                      properties_[i].schema = typeless_;
435                  }
436              }
437          }
438          if (properties && properties->IsObject()) {
439              PointerType q = p.Append(GetPropertiesString(), allocator_);
440              for (ConstMemberIterator itr = properties->MemberBegin(); itr != properties->MemberEnd(); ++itr) {
441                  SizeType index;
442                  if (FindPropertyIndex(itr->name, &index))
443                      schemaDocument->CreateSchema(&properties_[index].schema, q.Append(itr->name, allocator_), itr->value, document, id_);
444              }
445          }
446          if (const ValueType* v = GetMember(value, GetPatternPropertiesString())) {
447              PointerType q = p.Append(GetPatternPropertiesString(), allocator_);
448              patternProperties_ = static_cast<PatternProperty*>(allocator_->Malloc(sizeof(PatternProperty) * v->MemberCount()));
449              patternPropertyCount_ = 0;
450              for (ConstMemberIterator itr = v->MemberBegin(); itr != v->MemberEnd(); ++itr) {
451                  new (&patternProperties_[patternPropertyCount_]) PatternProperty();
452                  patternProperties_[patternPropertyCount_].pattern = CreatePattern(itr->name);
453                  schemaDocument->CreateSchema(&patternProperties_[patternPropertyCount_].schema, q.Append(itr->name, allocator_), itr->value, document, id_);
454                  patternPropertyCount_++;
455              }
456          }
457          if (required && required->IsArray())
458              for (ConstValueIterator itr = required->Begin(); itr != required->End(); ++itr)
459                  if (itr->IsString()) {
460                      SizeType index;
461                      if (FindPropertyIndex(*itr, &index)) {
462                          properties_[index].required = true;
463                          hasRequired_ = true;
464                      }
465                  }
466          if (dependencies && dependencies->IsObject()) {
467              PointerType q = p.Append(GetDependenciesString(), allocator_);
468              hasDependencies_ = true;
469              for (ConstMemberIterator itr = dependencies->MemberBegin(); itr != dependencies->MemberEnd(); ++itr) {
470                  SizeType sourceIndex;
471                  if (FindPropertyIndex(itr->name, &sourceIndex)) {
472                      if (itr->value.IsArray()) {
473                          properties_[sourceIndex].dependencies = static_cast<bool*>(allocator_->Malloc(sizeof(bool) * propertyCount_));
474                          std::memset(properties_[sourceIndex].dependencies, 0, sizeof(bool)* propertyCount_);
475                          for (ConstValueIterator targetItr = itr->value.Begin(); targetItr != itr->value.End(); ++targetItr) {
476                              SizeType targetIndex;
477                              if (FindPropertyIndex(*targetItr, &targetIndex))
478                                  properties_[sourceIndex].dependencies[targetIndex] = true;
479                          }
480                      }
481                      else if (itr->value.IsObject()) {
482                          hasSchemaDependencies_ = true;
483                          schemaDocument->CreateSchema(&properties_[sourceIndex].dependenciesSchema, q.Append(itr->name, allocator_), itr->value, document, id_);
484                          properties_[sourceIndex].dependenciesValidatorIndex = validatorCount_;
485                          validatorCount_++;
486                      }
487                  }
488              }
489          }
490          if (const ValueType* v = GetMember(value, GetAdditionalPropertiesString())) {
491              if (v->IsBool())
492                  additionalProperties_ = v->GetBool();
493              else if (v->IsObject())
494                  schemaDocument->CreateSchema(&additionalPropertiesSchema_, p.Append(GetAdditionalPropertiesString(), allocator_), *v, document, id_);
495          }
496          AssignIfExist(minProperties_, value, GetMinPropertiesString());
497          AssignIfExist(maxProperties_, value, GetMaxPropertiesString());
498          if (const ValueType* v = GetMember(value, GetItemsString())) {
499              PointerType q = p.Append(GetItemsString(), allocator_);
500              if (v->IsObject()) 
501                  schemaDocument->CreateSchema(&itemsList_, q, *v, document, id_);
502              else if (v->IsArray()) { 
503                  itemsTuple_ = static_cast<const Schema**>(allocator_->Malloc(sizeof(const Schema*) * v->Size()));
504                  SizeType index = 0;
505                  for (ConstValueIterator itr = v->Begin(); itr != v->End(); ++itr, index++)
506                      schemaDocument->CreateSchema(&itemsTuple_[itemsTupleCount_++], q.Append(index, allocator_), *itr, document, id_);
507              }
508          }
509          AssignIfExist(minItems_, value, GetMinItemsString());
510          AssignIfExist(maxItems_, value, GetMaxItemsString());
511          if (const ValueType* v = GetMember(value, GetAdditionalItemsString())) {
512              if (v->IsBool())
513                  additionalItems_ = v->GetBool();
514              else if (v->IsObject())
515                  schemaDocument->CreateSchema(&additionalItemsSchema_, p.Append(GetAdditionalItemsString(), allocator_), *v, document, id_);
516          }
517          AssignIfExist(uniqueItems_, value, GetUniqueItemsString());
518          AssignIfExist(minLength_, value, GetMinLengthString());
519          AssignIfExist(maxLength_, value, GetMaxLengthString());
520          if (const ValueType* v = GetMember(value, GetPatternString()))
521              pattern_ = CreatePattern(*v);
522          if (const ValueType* v = GetMember(value, GetMinimumString()))
523              if (v->IsNumber())
524                  minimum_.CopyFrom(*v, *allocator_);
525          if (const ValueType* v = GetMember(value, GetMaximumString()))
526              if (v->IsNumber())
527                  maximum_.CopyFrom(*v, *allocator_);
528          AssignIfExist(exclusiveMinimum_, value, GetExclusiveMinimumString());
529          AssignIfExist(exclusiveMaximum_, value, GetExclusiveMaximumString());
530          if (const ValueType* v = GetMember(value, GetMultipleOfString()))
531              if (v->IsNumber() && v->GetDouble() > 0.0)
532                  multipleOf_.CopyFrom(*v, *allocator_);
533          if (const ValueType* v = GetMember(value, GetDefaultValueString()))
534              if (v->IsString())
535                  defaultValueLength_ = v->GetStringLength();
536      }
537      ~Schema() {
538          AllocatorType::Free(enum_);
539          if (properties_) {
540              for (SizeType i = 0; i < propertyCount_; i++)
541                  properties_[i].~Property();
542              AllocatorType::Free(properties_);
543          }
544          if (patternProperties_) {
545              for (SizeType i = 0; i < patternPropertyCount_; i++)
546                  patternProperties_[i].~PatternProperty();
547              AllocatorType::Free(patternProperties_);
548          }
549          AllocatorType::Free(itemsTuple_);
550  #if RAPIDJSON_SCHEMA_HAS_REGEX
551          if (pattern_) {
552              pattern_->~RegexType();
553              AllocatorType::Free(pattern_);
554          }
555  #endif
556      }
557      const SValue& GetURI() const {
558          return uri_;
559      }
560      const UriType& GetId() const {
561          return id_;
562      }
563      const PointerType& GetPointer() const {
564          return pointer_;
565      }
566      bool BeginValue(Context& context) const {
567          if (context.inArray) {
568              if (uniqueItems_)
569                  context.valueUniqueness = true;
570              if (itemsList_)
571                  context.valueSchema = itemsList_;
572              else if (itemsTuple_) {
573                  if (context.arrayElementIndex < itemsTupleCount_)
574                      context.valueSchema = itemsTuple_[context.arrayElementIndex];
575                  else if (additionalItemsSchema_)
576                      context.valueSchema = additionalItemsSchema_;
577                  else if (additionalItems_)
578                      context.valueSchema = typeless_;
579                  else {
580                      context.error_handler.DisallowedItem(context.arrayElementIndex);
581                      context.valueSchema = typeless_;
582                      context.arrayElementIndex++;
583                      RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorAdditionalItems);
584                  }
585              }
586              else
587                  context.valueSchema = typeless_;
588              context.arrayElementIndex++;
589          }
590          return true;
591      }
592      RAPIDJSON_FORCEINLINE bool EndValue(Context& context) const {
593          if (context.patternPropertiesValidatorCount > 0) {
594              bool otherValid = false;
595              SizeType count = context.patternPropertiesValidatorCount;
596              if (context.objectPatternValidatorType != Context::kPatternValidatorOnly)
597                  otherValid = context.patternPropertiesValidators[--count]->IsValid();
598              bool patternValid = true;
599              for (SizeType i = 0; i < count; i++)
600                  if (!context.patternPropertiesValidators[i]->IsValid()) {
601                      patternValid = false;
602                      break;
603                  }
604              if (context.objectPatternValidatorType == Context::kPatternValidatorOnly) {
605                  if (!patternValid) {
606                      context.error_handler.PropertyViolations(context.patternPropertiesValidators, count);
607                      RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorPatternProperties);
608                  }
609              }
610              else if (context.objectPatternValidatorType == Context::kPatternValidatorWithProperty) {
611                  if (!patternValid || !otherValid) {
612                      context.error_handler.PropertyViolations(context.patternPropertiesValidators, count + 1);
613                      RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorPatternProperties);
614                  }
615              }
616              else if (!patternValid && !otherValid) { 
617                  context.error_handler.PropertyViolations(context.patternPropertiesValidators, count + 1);
618                  RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorPatternProperties);
619              }
620          }
621          if (enum_ && context.hasher) {
622              const uint64_t h = context.factory.GetHashCode(context.hasher);
623              for (SizeType i = 0; i < enumCount_; i++)
624                  if (enum_[i] == h)
625                      goto foundEnum;
626              context.error_handler.DisallowedValue(kValidateErrorEnum);
627              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorEnum);
628              foundEnum:;
629          }
630          if (context.validatorCount > 0) {
631              if (allOf_.schemas)
632                  for (SizeType i = allOf_.begin; i < allOf_.begin + allOf_.count; i++)
633                      if (!context.validators[i]->IsValid()) {
634                          context.error_handler.NotAllOf(&context.validators[allOf_.begin], allOf_.count);
635                          RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorAllOf);
636                      }
637              if (anyOf_.schemas) {
638                  for (SizeType i = anyOf_.begin; i < anyOf_.begin + anyOf_.count; i++)
639                      if (context.validators[i]->IsValid())
640                          goto foundAny;
641                  context.error_handler.NoneOf(&context.validators[anyOf_.begin], anyOf_.count);
642                  RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorAnyOf);
643                  foundAny:;
644              }
645              if (oneOf_.schemas) {
646                  bool oneValid = false;
647                  for (SizeType i = oneOf_.begin; i < oneOf_.begin + oneOf_.count; i++)
648                      if (context.validators[i]->IsValid()) {
649                          if (oneValid) {
650                              context.error_handler.NotOneOf(&context.validators[oneOf_.begin], oneOf_.count, true);
651                              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorOneOfMatch);
652                          } else
653                              oneValid = true;
654                      }
655                  if (!oneValid) {
656                      context.error_handler.NotOneOf(&context.validators[oneOf_.begin], oneOf_.count, false);
657                      RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorOneOf);
658                  }
659              }
660              if (not_ && context.validators[notValidatorIndex_]->IsValid()) {
661                  context.error_handler.Disallowed();
662                  RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorNot);
663              }
664          }
665          return true;
666      }
667      bool Null(Context& context) const {
668          if (!(type_ & (1 << kNullSchemaType))) {
669              DisallowedType(context, GetNullString());
670              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorType);
671          }
672          return CreateParallelValidator(context);
673      }
674      bool Bool(Context& context, bool) const {
675          if (!(type_ & (1 << kBooleanSchemaType))) {
676              DisallowedType(context, GetBooleanString());
677              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorType);
678          }
679          return CreateParallelValidator(context);
680      }
681      bool Int(Context& context, int i) const {
682          if (!CheckInt(context, i))
683              return false;
684          return CreateParallelValidator(context);
685      }
686      bool Uint(Context& context, unsigned u) const {
687          if (!CheckUint(context, u))
688              return false;
689          return CreateParallelValidator(context);
690      }
691      bool Int64(Context& context, int64_t i) const {
692          if (!CheckInt(context, i))
693              return false;
694          return CreateParallelValidator(context);
695      }
696      bool Uint64(Context& context, uint64_t u) const {
697          if (!CheckUint(context, u))
698              return false;
699          return CreateParallelValidator(context);
700      }
701      bool Double(Context& context, double d) const {
702          if (!(type_ & (1 << kNumberSchemaType))) {
703              DisallowedType(context, GetNumberString());
704              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorType);
705          }
706          if (!minimum_.IsNull() && !CheckDoubleMinimum(context, d))
707              return false;
708          if (!maximum_.IsNull() && !CheckDoubleMaximum(context, d))
709              return false;
710          if (!multipleOf_.IsNull() && !CheckDoubleMultipleOf(context, d))
711              return false;
712          return CreateParallelValidator(context);
713      }
714      bool String(Context& context, const Ch* str, SizeType length, bool) const {
715          if (!(type_ & (1 << kStringSchemaType))) {
716              DisallowedType(context, GetStringString());
717              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorType);
718          }
719          if (minLength_ != 0 || maxLength_ != SizeType(~0)) {
720              SizeType count;
721              if (internal::CountStringCodePoint<EncodingType>(str, length, &count)) {
722                  if (count < minLength_) {
723                      context.error_handler.TooShort(str, length, minLength_);
724                      RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorMinLength);
725                  }
726                  if (count > maxLength_) {
727                      context.error_handler.TooLong(str, length, maxLength_);
728                      RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorMaxLength);
729                  }
730              }
731          }
732          if (pattern_ && !IsPatternMatch(pattern_, str, length)) {
733              context.error_handler.DoesNotMatch(str, length);
734              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorPattern);
735          }
736          return CreateParallelValidator(context);
737      }
738      bool StartObject(Context& context) const {
739          if (!(type_ & (1 << kObjectSchemaType))) {
740              DisallowedType(context, GetObjectString());
741              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorType);
742          }
743          if (hasDependencies_ || hasRequired_) {
744              context.propertyExist = static_cast<bool*>(context.factory.MallocState(sizeof(bool) * propertyCount_));
745              std::memset(context.propertyExist, 0, sizeof(bool) * propertyCount_);
746          }
747          if (patternProperties_) { 
748              SizeType count = patternPropertyCount_ + 1; 
749              context.patternPropertiesSchemas = static_cast<const SchemaType**>(context.factory.MallocState(sizeof(const SchemaType*) * count));
750              context.patternPropertiesSchemaCount = 0;
751              std::memset(context.patternPropertiesSchemas, 0, sizeof(SchemaType*) * count);
752          }
753          return CreateParallelValidator(context);
754      }
755      bool Key(Context& context, const Ch* str, SizeType len, bool) const {
756          if (patternProperties_) {
757              context.patternPropertiesSchemaCount = 0;
758              for (SizeType i = 0; i < patternPropertyCount_; i++)
759                  if (patternProperties_[i].pattern && IsPatternMatch(patternProperties_[i].pattern, str, len)) {
760                      context.patternPropertiesSchemas[context.patternPropertiesSchemaCount++] = patternProperties_[i].schema;
761                      context.valueSchema = typeless_;
762                  }
763          }
764          SizeType index  = 0;
765          if (FindPropertyIndex(ValueType(str, len).Move(), &index)) {
766              if (context.patternPropertiesSchemaCount > 0) {
767                  context.patternPropertiesSchemas[context.patternPropertiesSchemaCount++] = properties_[index].schema;
768                  context.valueSchema = typeless_;
769                  context.valuePatternValidatorType = Context::kPatternValidatorWithProperty;
770              }
771              else
772                  context.valueSchema = properties_[index].schema;
773              if (context.propertyExist)
774                  context.propertyExist[index] = true;
775              return true;
776          }
777          if (additionalPropertiesSchema_) {
778              if (context.patternPropertiesSchemaCount > 0) {
779                  context.patternPropertiesSchemas[context.patternPropertiesSchemaCount++] = additionalPropertiesSchema_;
780                  context.valueSchema = typeless_;
781                  context.valuePatternValidatorType = Context::kPatternValidatorWithAdditionalProperty;
782              }
783              else
784                  context.valueSchema = additionalPropertiesSchema_;
785              return true;
786          }
787          else if (additionalProperties_) {
788              context.valueSchema = typeless_;
789              return true;
790          }
791          if (context.patternPropertiesSchemaCount == 0) { 
792              context.valueSchema = typeless_;
793              context.error_handler.DisallowedProperty(str, len);
794              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorAdditionalProperties);
795          }
796          return true;
797      }
798      bool EndObject(Context& context, SizeType memberCount) const {
799          if (hasRequired_) {
800              context.error_handler.StartMissingProperties();
801              for (SizeType index = 0; index < propertyCount_; index++)
802                  if (properties_[index].required && !context.propertyExist[index])
803                      if (properties_[index].schema->defaultValueLength_ == 0 )
804                          context.error_handler.AddMissingProperty(properties_[index].name);
805              if (context.error_handler.EndMissingProperties())
806                  RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorRequired);
807          }
808          if (memberCount < minProperties_) {
809              context.error_handler.TooFewProperties(memberCount, minProperties_);
810              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorMinProperties);
811          }
812          if (memberCount > maxProperties_) {
813              context.error_handler.TooManyProperties(memberCount, maxProperties_);
814              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorMaxProperties);
815          }
816          if (hasDependencies_) {
817              context.error_handler.StartDependencyErrors();
818              for (SizeType sourceIndex = 0; sourceIndex < propertyCount_; sourceIndex++) {
819                  const Property& source = properties_[sourceIndex];
820                  if (context.propertyExist[sourceIndex]) {
821                      if (source.dependencies) {
822                          context.error_handler.StartMissingDependentProperties();
823                          for (SizeType targetIndex = 0; targetIndex < propertyCount_; targetIndex++)
824                              if (source.dependencies[targetIndex] && !context.propertyExist[targetIndex])
825                                  context.error_handler.AddMissingDependentProperty(properties_[targetIndex].name);
826                          context.error_handler.EndMissingDependentProperties(source.name);
827                      }
828                      else if (source.dependenciesSchema) {
829                          ISchemaValidator* dependenciesValidator = context.validators[source.dependenciesValidatorIndex];
830                          if (!dependenciesValidator->IsValid())
831                              context.error_handler.AddDependencySchemaError(source.name, dependenciesValidator);
832                      }
833                  }
834              }
835              if (context.error_handler.EndDependencyErrors())
836                  RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorDependencies);
837          }
838          return true;
839      }
840      bool StartArray(Context& context) const {
841          context.arrayElementIndex = 0;
842          context.inArray = true;  
843          if (!(type_ & (1 << kArraySchemaType))) {
844              DisallowedType(context, GetArrayString());
845              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorType);
846          }
847          return CreateParallelValidator(context);
848      }
849      bool EndArray(Context& context, SizeType elementCount) const {
850          context.inArray = false;
851          if (elementCount < minItems_) {
852              context.error_handler.TooFewItems(elementCount, minItems_);
853              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorMinItems);
854          }
855          if (elementCount > maxItems_) {
856              context.error_handler.TooManyItems(elementCount, maxItems_);
857              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorMaxItems);
858          }
859          return true;
860      }
861      static const ValueType& GetValidateErrorKeyword(ValidateErrorCode validateErrorCode) {
862          switch (validateErrorCode) {
863              case kValidateErrorMultipleOf:              return GetMultipleOfString();
864              case kValidateErrorMaximum:                 return GetMaximumString();
865              case kValidateErrorExclusiveMaximum:        return GetMaximumString(); 
866              case kValidateErrorMinimum:                 return GetMinimumString();
867              case kValidateErrorExclusiveMinimum:        return GetMinimumString(); 
868              case kValidateErrorMaxLength:               return GetMaxLengthString();
869              case kValidateErrorMinLength:               return GetMinLengthString();
870              case kValidateErrorPattern:                 return GetPatternString();
871              case kValidateErrorMaxItems:                return GetMaxItemsString();
872              case kValidateErrorMinItems:                return GetMinItemsString();
873              case kValidateErrorUniqueItems:             return GetUniqueItemsString();
874              case kValidateErrorAdditionalItems:         return GetAdditionalItemsString();
875              case kValidateErrorMaxProperties:           return GetMaxPropertiesString();
876              case kValidateErrorMinProperties:           return GetMinPropertiesString();
877              case kValidateErrorRequired:                return GetRequiredString();
878              case kValidateErrorAdditionalProperties:    return GetAdditionalPropertiesString();
879              case kValidateErrorPatternProperties:       return GetPatternPropertiesString();
880              case kValidateErrorDependencies:            return GetDependenciesString();
881              case kValidateErrorEnum:                    return GetEnumString();
882              case kValidateErrorType:                    return GetTypeString();
883              case kValidateErrorOneOf:                   return GetOneOfString();
884              case kValidateErrorOneOfMatch:              return GetOneOfString(); 
885              case kValidateErrorAllOf:                   return GetAllOfString();
886              case kValidateErrorAnyOf:                   return GetAnyOfString();
887              case kValidateErrorNot:                     return GetNotString();
888              default:                                    return GetNullString();
889          }
890      }
891  #define RAPIDJSON_STRING_(name, ...) \
892      static const ValueType& Get##name##String() {\
893          static const Ch s[] = { __VA_ARGS__, '\0' };\
894          static const ValueType v(s, static_cast<SizeType>(sizeof(s) / sizeof(Ch) - 1));\
895          return v;\
896      }
897      RAPIDJSON_STRING_(Null, 'n', 'u', 'l', 'l')
898      RAPIDJSON_STRING_(Boolean, 'b', 'o', 'o', 'l', 'e', 'a', 'n')
899      RAPIDJSON_STRING_(Object, 'o', 'b', 'j', 'e', 'c', 't')
900      RAPIDJSON_STRING_(Array, 'a', 'r', 'r', 'a', 'y')
901      RAPIDJSON_STRING_(String, 's', 't', 'r', 'i', 'n', 'g')
902      RAPIDJSON_STRING_(Number, 'n', 'u', 'm', 'b', 'e', 'r')
903      RAPIDJSON_STRING_(Integer, 'i', 'n', 't', 'e', 'g', 'e', 'r')
904      RAPIDJSON_STRING_(Type, 't', 'y', 'p', 'e')
905      RAPIDJSON_STRING_(Enum, 'e', 'n', 'u', 'm')
906      RAPIDJSON_STRING_(AllOf, 'a', 'l', 'l', 'O', 'f')
907      RAPIDJSON_STRING_(AnyOf, 'a', 'n', 'y', 'O', 'f')
908      RAPIDJSON_STRING_(OneOf, 'o', 'n', 'e', 'O', 'f')
909      RAPIDJSON_STRING_(Not, 'n', 'o', 't')
910      RAPIDJSON_STRING_(Properties, 'p', 'r', 'o', 'p', 'e', 'r', 't', 'i', 'e', 's')
911      RAPIDJSON_STRING_(Required, 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd')
912      RAPIDJSON_STRING_(Dependencies, 'd', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c', 'i', 'e', 's')
913      RAPIDJSON_STRING_(PatternProperties, 'p', 'a', 't', 't', 'e', 'r', 'n', 'P', 'r', 'o', 'p', 'e', 'r', 't', 'i', 'e', 's')
914      RAPIDJSON_STRING_(AdditionalProperties, 'a', 'd', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'P', 'r', 'o', 'p', 'e', 'r', 't', 'i', 'e', 's')
915      RAPIDJSON_STRING_(MinProperties, 'm', 'i', 'n', 'P', 'r', 'o', 'p', 'e', 'r', 't', 'i', 'e', 's')
916      RAPIDJSON_STRING_(MaxProperties, 'm', 'a', 'x', 'P', 'r', 'o', 'p', 'e', 'r', 't', 'i', 'e', 's')
917      RAPIDJSON_STRING_(Items, 'i', 't', 'e', 'm', 's')
918      RAPIDJSON_STRING_(MinItems, 'm', 'i', 'n', 'I', 't', 'e', 'm', 's')
919      RAPIDJSON_STRING_(MaxItems, 'm', 'a', 'x', 'I', 't', 'e', 'm', 's')
920      RAPIDJSON_STRING_(AdditionalItems, 'a', 'd', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'I', 't', 'e', 'm', 's')
921      RAPIDJSON_STRING_(UniqueItems, 'u', 'n', 'i', 'q', 'u', 'e', 'I', 't', 'e', 'm', 's')
922      RAPIDJSON_STRING_(MinLength, 'm', 'i', 'n', 'L', 'e', 'n', 'g', 't', 'h')
923      RAPIDJSON_STRING_(MaxLength, 'm', 'a', 'x', 'L', 'e', 'n', 'g', 't', 'h')
924      RAPIDJSON_STRING_(Pattern, 'p', 'a', 't', 't', 'e', 'r', 'n')
925      RAPIDJSON_STRING_(Minimum, 'm', 'i', 'n', 'i', 'm', 'u', 'm')
926      RAPIDJSON_STRING_(Maximum, 'm', 'a', 'x', 'i', 'm', 'u', 'm')
927      RAPIDJSON_STRING_(ExclusiveMinimum, 'e', 'x', 'c', 'l', 'u', 's', 'i', 'v', 'e', 'M', 'i', 'n', 'i', 'm', 'u', 'm')
928      RAPIDJSON_STRING_(ExclusiveMaximum, 'e', 'x', 'c', 'l', 'u', 's', 'i', 'v', 'e', 'M', 'a', 'x', 'i', 'm', 'u', 'm')
929      RAPIDJSON_STRING_(MultipleOf, 'm', 'u', 'l', 't', 'i', 'p', 'l', 'e', 'O', 'f')
930      RAPIDJSON_STRING_(DefaultValue, 'd', 'e', 'f', 'a', 'u', 'l', 't')
931      RAPIDJSON_STRING_(Ref, '$', 'r', 'e', 'f')
932      RAPIDJSON_STRING_(Id, 'i', 'd')
933      RAPIDJSON_STRING_(SchemeEnd, ':')
934      RAPIDJSON_STRING_(AuthStart, '/', '/')
935      RAPIDJSON_STRING_(QueryStart, '?')
936      RAPIDJSON_STRING_(FragStart, '#')
937      RAPIDJSON_STRING_(Slash, '/')
938      RAPIDJSON_STRING_(Dot, '.')
939  #undef RAPIDJSON_STRING_
940  private:
941      enum SchemaValueType {
942          kNullSchemaType,
943          kBooleanSchemaType,
944          kObjectSchemaType,
945          kArraySchemaType,
946          kStringSchemaType,
947          kNumberSchemaType,
948          kIntegerSchemaType,
949          kTotalSchemaType
950      };
951  #if RAPIDJSON_SCHEMA_USE_INTERNALREGEX
952          typedef internal::GenericRegex<EncodingType, AllocatorType> RegexType;
953  #elif RAPIDJSON_SCHEMA_USE_STDREGEX
954          typedef std::basic_regex<Ch> RegexType;
955  #else
956          typedef char RegexType;
957  #endif
958      struct SchemaArray {
959          SchemaArray() : schemas(), count() {}
960          ~SchemaArray() { AllocatorType::Free(schemas); }
961          const SchemaType** schemas;
962          SizeType begin; 
963          SizeType count;
964      };
965      template <typename V1, typename V2>
966      void AddUniqueElement(V1& a, const V2& v) {
967          for (typename V1::ConstValueIterator itr = a.Begin(); itr != a.End(); ++itr)
968              if (*itr == v)
969                  return;
970          V1 c(v, *allocator_);
971          a.PushBack(c, *allocator_);
972      }
973      static const ValueType* GetMember(const ValueType& value, const ValueType& name) {
974          typename ValueType::ConstMemberIterator itr = value.FindMember(name);
975          return itr != value.MemberEnd() ? &(itr->value) : 0;
976      }
977      static void AssignIfExist(bool& out, const ValueType& value, const ValueType& name) {
978          if (const ValueType* v = GetMember(value, name))
979              if (v->IsBool())
980                  out = v->GetBool();
981      }
982      static void AssignIfExist(SizeType& out, const ValueType& value, const ValueType& name) {
983          if (const ValueType* v = GetMember(value, name))
984              if (v->IsUint64() && v->GetUint64() <= SizeType(~0))
985                  out = static_cast<SizeType>(v->GetUint64());
986      }
987      void AssignIfExist(SchemaArray& out, SchemaDocumentType& schemaDocument, const PointerType& p, const ValueType& value, const ValueType& name, const ValueType& document) {
988          if (const ValueType* v = GetMember(value, name)) {
989              if (v->IsArray() && v->Size() > 0) {
990                  PointerType q = p.Append(name, allocator_);
991                  out.count = v->Size();
992                  out.schemas = static_cast<const Schema**>(allocator_->Malloc(out.count * sizeof(const Schema*)));
993                  memset(out.schemas, 0, sizeof(Schema*)* out.count);
994                  for (SizeType i = 0; i < out.count; i++)
995                      schemaDocument.CreateSchema(&out.schemas[i], q.Append(i, allocator_), (*v)[i], document, id_);
996                  out.begin = validatorCount_;
997                  validatorCount_ += out.count;
998              }
999          }
1000      }
1001  #if RAPIDJSON_SCHEMA_USE_INTERNALREGEX
1002      template <typename ValueType>
1003      RegexType* CreatePattern(const ValueType& value) {
1004          if (value.IsString()) {
1005              RegexType* r = new (allocator_->Malloc(sizeof(RegexType))) RegexType(value.GetString(), allocator_);
1006              if (!r->IsValid()) {
1007                  r->~RegexType();
1008                  AllocatorType::Free(r);
1009                  r = 0;
1010              }
1011              return r;
1012          }
1013          return 0;
1014      }
1015      static bool IsPatternMatch(const RegexType* pattern, const Ch *str, SizeType) {
1016          GenericRegexSearch<RegexType> rs(*pattern);
1017          return rs.Search(str);
1018      }
1019  #elif RAPIDJSON_SCHEMA_USE_STDREGEX
1020      template <typename ValueType>
1021      RegexType* CreatePattern(const ValueType& value) {
1022          if (value.IsString()) {
1023              RegexType *r = static_cast<RegexType*>(allocator_->Malloc(sizeof(RegexType)));
1024              try {
1025                  return new (r) RegexType(value.GetString(), std::size_t(value.GetStringLength()), std::regex_constants::ECMAScript);
1026              }
1027              catch (const std::regex_error&) {
1028                  AllocatorType::Free(r);
1029              }
1030          }
1031          return 0;
1032      }
1033      static bool IsPatternMatch(const RegexType* pattern, const Ch *str, SizeType length) {
1034          std::match_results<const Ch*> r;
1035          return std::regex_search(str, str + length, r, *pattern);
1036      }
1037  #else
1038      template <typename ValueType>
1039      RegexType* CreatePattern(const ValueType&) { return 0; }
1040      static bool IsPatternMatch(const RegexType*, const Ch *, SizeType) { return true; }
1041  #endif 
1042      void AddType(const ValueType& type) {
1043          if      (type == GetNullString()   ) type_ |= 1 << kNullSchemaType;
1044          else if (type == GetBooleanString()) type_ |= 1 << kBooleanSchemaType;
1045          else if (type == GetObjectString() ) type_ |= 1 << kObjectSchemaType;
1046          else if (type == GetArrayString()  ) type_ |= 1 << kArraySchemaType;
1047          else if (type == GetStringString() ) type_ |= 1 << kStringSchemaType;
1048          else if (type == GetIntegerString()) type_ |= 1 << kIntegerSchemaType;
1049          else if (type == GetNumberString() ) type_ |= (1 << kNumberSchemaType) | (1 << kIntegerSchemaType);
1050      }
1051      bool CreateParallelValidator(Context& context) const {
1052          if (enum_ || context.arrayUniqueness)
1053              context.hasher = context.factory.CreateHasher();
1054          if (validatorCount_) {
1055              RAPIDJSON_ASSERT(context.validators == 0);
1056              context.validators = static_cast<ISchemaValidator**>(context.factory.MallocState(sizeof(ISchemaValidator*) * validatorCount_));
1057              context.validatorCount = validatorCount_;
1058              if (allOf_.schemas)
1059                  CreateSchemaValidators(context, allOf_, false);
1060              if (anyOf_.schemas)
1061                  CreateSchemaValidators(context, anyOf_, false);
1062              if (oneOf_.schemas)
1063                  CreateSchemaValidators(context, oneOf_, false);
1064              if (not_)
1065                  context.validators[notValidatorIndex_] = context.factory.CreateSchemaValidator(*not_, false);
1066              if (hasSchemaDependencies_) {
1067                  for (SizeType i = 0; i < propertyCount_; i++)
1068                      if (properties_[i].dependenciesSchema)
1069                          context.validators[properties_[i].dependenciesValidatorIndex] = context.factory.CreateSchemaValidator(*properties_[i].dependenciesSchema, false);
1070              }
1071          }
1072          return true;
1073      }
1074      void CreateSchemaValidators(Context& context, const SchemaArray& schemas, const bool inheritContinueOnErrors) const {
1075          for (SizeType i = 0; i < schemas.count; i++)
1076              context.validators[schemas.begin + i] = context.factory.CreateSchemaValidator(*schemas.schemas[i], inheritContinueOnErrors);
1077      }
1078      bool FindPropertyIndex(const ValueType& name, SizeType* outIndex) const {
1079          SizeType len = name.GetStringLength();
1080          const Ch* str = name.GetString();
1081          for (SizeType index = 0; index < propertyCount_; index++)
1082              if (properties_[index].name.GetStringLength() == len &&
1083                  (std::memcmp(properties_[index].name.GetString(), str, sizeof(Ch) * len) == 0))
1084              {
1085                  *outIndex = index;
1086                  return true;
1087              }
1088          return false;
1089      }
1090      bool CheckInt(Context& context, int64_t i) const {
1091          if (!(type_ & ((1 << kIntegerSchemaType) | (1 << kNumberSchemaType)))) {
1092              DisallowedType(context, GetIntegerString());
1093              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorType);
1094          }
1095          if (!minimum_.IsNull()) {
1096              if (minimum_.IsInt64()) {
1097                  if (exclusiveMinimum_ ? i <= minimum_.GetInt64() : i < minimum_.GetInt64()) {
1098                      context.error_handler.BelowMinimum(i, minimum_, exclusiveMinimum_);
1099                      RAPIDJSON_INVALID_KEYWORD_RETURN(exclusiveMinimum_ ? kValidateErrorExclusiveMinimum : kValidateErrorMinimum);
1100                  }
1101              }
1102              else if (minimum_.IsUint64()) {
1103                  context.error_handler.BelowMinimum(i, minimum_, exclusiveMinimum_);
1104                  RAPIDJSON_INVALID_KEYWORD_RETURN(exclusiveMinimum_ ? kValidateErrorExclusiveMinimum : kValidateErrorMinimum); 
1105              }
1106              else if (!CheckDoubleMinimum(context, static_cast<double>(i)))
1107                  return false;
1108          }
1109          if (!maximum_.IsNull()) {
1110              if (maximum_.IsInt64()) {
1111                  if (exclusiveMaximum_ ? i >= maximum_.GetInt64() : i > maximum_.GetInt64()) {
1112                      context.error_handler.AboveMaximum(i, maximum_, exclusiveMaximum_);
1113                      RAPIDJSON_INVALID_KEYWORD_RETURN(exclusiveMaximum_ ? kValidateErrorExclusiveMaximum : kValidateErrorMaximum);
1114                  }
1115              }
1116              else if (maximum_.IsUint64()) { }
1117              else if (!CheckDoubleMaximum(context, static_cast<double>(i)))
1118                  return false;
1119          }
1120          if (!multipleOf_.IsNull()) {
1121              if (multipleOf_.IsUint64()) {
1122                  if (static_cast<uint64_t>(i >= 0 ? i : -i) % multipleOf_.GetUint64() != 0) {
1123                      context.error_handler.NotMultipleOf(i, multipleOf_);
1124                      RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorMultipleOf);
1125                  }
1126              }
1127              else if (!CheckDoubleMultipleOf(context, static_cast<double>(i)))
1128                  return false;
1129          }
1130          return true;
1131      }
1132      bool CheckUint(Context& context, uint64_t i) const {
1133          if (!(type_ & ((1 << kIntegerSchemaType) | (1 << kNumberSchemaType)))) {
1134              DisallowedType(context, GetIntegerString());
1135              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorType);
1136          }
1137          if (!minimum_.IsNull()) {
1138              if (minimum_.IsUint64()) {
1139                  if (exclusiveMinimum_ ? i <= minimum_.GetUint64() : i < minimum_.GetUint64()) {
1140                      context.error_handler.BelowMinimum(i, minimum_, exclusiveMinimum_);
1141                      RAPIDJSON_INVALID_KEYWORD_RETURN(exclusiveMinimum_ ? kValidateErrorExclusiveMinimum : kValidateErrorMinimum);
1142                  }
1143              }
1144              else if (minimum_.IsInt64())
1145                  ; 
1146              else if (!CheckDoubleMinimum(context, static_cast<double>(i)))
1147                  return false;
1148          }
1149          if (!maximum_.IsNull()) {
1150              if (maximum_.IsUint64()) {
1151                  if (exclusiveMaximum_ ? i >= maximum_.GetUint64() : i > maximum_.GetUint64()) {
1152                      context.error_handler.AboveMaximum(i, maximum_, exclusiveMaximum_);
1153                      RAPIDJSON_INVALID_KEYWORD_RETURN(exclusiveMaximum_ ? kValidateErrorExclusiveMaximum : kValidateErrorMaximum);
1154                  }
1155              }
1156              else if (maximum_.IsInt64()) {
1157                  context.error_handler.AboveMaximum(i, maximum_, exclusiveMaximum_);
1158                  RAPIDJSON_INVALID_KEYWORD_RETURN(exclusiveMaximum_ ? kValidateErrorExclusiveMaximum : kValidateErrorMaximum); 
1159              }
1160              else if (!CheckDoubleMaximum(context, static_cast<double>(i)))
1161                  return false;
1162          }
1163          if (!multipleOf_.IsNull()) {
1164              if (multipleOf_.IsUint64()) {
1165                  if (i % multipleOf_.GetUint64() != 0) {
1166                      context.error_handler.NotMultipleOf(i, multipleOf_);
1167                      RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorMultipleOf);
1168                  }
1169              }
1170              else if (!CheckDoubleMultipleOf(context, static_cast<double>(i)))
1171                  return false;
1172          }
1173          return true;
1174      }
1175      bool CheckDoubleMinimum(Context& context, double d) const {
1176          if (exclusiveMinimum_ ? d <= minimum_.GetDouble() : d < minimum_.GetDouble()) {
1177              context.error_handler.BelowMinimum(d, minimum_, exclusiveMinimum_);
1178              RAPIDJSON_INVALID_KEYWORD_RETURN(exclusiveMinimum_ ? kValidateErrorExclusiveMinimum : kValidateErrorMinimum);
1179          }
1180          return true;
1181      }
1182      bool CheckDoubleMaximum(Context& context, double d) const {
1183          if (exclusiveMaximum_ ? d >= maximum_.GetDouble() : d > maximum_.GetDouble()) {
1184              context.error_handler.AboveMaximum(d, maximum_, exclusiveMaximum_);
1185              RAPIDJSON_INVALID_KEYWORD_RETURN(exclusiveMaximum_ ? kValidateErrorExclusiveMaximum : kValidateErrorMaximum);
1186          }
1187          return true;
1188      }
1189      bool CheckDoubleMultipleOf(Context& context, double d) const {
1190          double a = std::abs(d), b = std::abs(multipleOf_.GetDouble());
1191          double q = std::floor(a / b);
1192          double r = a - q * b;
1193          if (r > 0.0) {
1194              context.error_handler.NotMultipleOf(d, multipleOf_);
1195              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorMultipleOf);
1196          }
1197          return true;
1198      }
1199      void DisallowedType(Context& context, const ValueType& actualType) const {
1200          ErrorHandler& eh = context.error_handler;
1201          eh.StartDisallowedType();
1202          if (type_ & (1 << kNullSchemaType)) eh.AddExpectedType(GetNullString());
1203          if (type_ & (1 << kBooleanSchemaType)) eh.AddExpectedType(GetBooleanString());
1204          if (type_ & (1 << kObjectSchemaType)) eh.AddExpectedType(GetObjectString());
1205          if (type_ & (1 << kArraySchemaType)) eh.AddExpectedType(GetArrayString());
1206          if (type_ & (1 << kStringSchemaType)) eh.AddExpectedType(GetStringString());
1207          if (type_ & (1 << kNumberSchemaType)) eh.AddExpectedType(GetNumberString());
1208          else if (type_ & (1 << kIntegerSchemaType)) eh.AddExpectedType(GetIntegerString());
1209          eh.EndDisallowedType(actualType);
1210      }
1211      struct Property {
1212          Property() : schema(), dependenciesSchema(), dependenciesValidatorIndex(), dependencies(), required(false) {}
1213          ~Property() { AllocatorType::Free(dependencies); }
1214          SValue name;
1215          const SchemaType* schema;
1216          const SchemaType* dependenciesSchema;
1217          SizeType dependenciesValidatorIndex;
1218          bool* dependencies;
1219          bool required;
1220      };
1221      struct PatternProperty {
1222          PatternProperty() : schema(), pattern() {}
1223          ~PatternProperty() {
1224              if (pattern) {
1225                  pattern->~RegexType();
1226                  AllocatorType::Free(pattern);
1227              }
1228          }
1229          const SchemaType* schema;
1230          RegexType* pattern;
1231      };
1232      AllocatorType* allocator_;
1233      SValue uri_;
1234      UriType id_;
1235      PointerType pointer_;
1236      const SchemaType* typeless_;
1237      uint64_t* enum_;
1238      SizeType enumCount_;
1239      SchemaArray allOf_;
1240      SchemaArray anyOf_;
1241      SchemaArray oneOf_;
1242      const SchemaType* not_;
1243      unsigned type_; 
1244      SizeType validatorCount_;
1245      SizeType notValidatorIndex_;
1246      Property* properties_;
1247      const SchemaType* additionalPropertiesSchema_;
1248      PatternProperty* patternProperties_;
1249      SizeType patternPropertyCount_;
1250      SizeType propertyCount_;
1251      SizeType minProperties_;
1252      SizeType maxProperties_;
1253      bool additionalProperties_;
1254      bool hasDependencies_;
1255      bool hasRequired_;
1256      bool hasSchemaDependencies_;
1257      const SchemaType* additionalItemsSchema_;
1258      const SchemaType* itemsList_;
1259      const SchemaType** itemsTuple_;
1260      SizeType itemsTupleCount_;
1261      SizeType minItems_;
1262      SizeType maxItems_;
1263      bool additionalItems_;
1264      bool uniqueItems_;
1265      RegexType* pattern_;
1266      SizeType minLength_;
1267      SizeType maxLength_;
1268      SValue minimum_;
1269      SValue maximum_;
1270      SValue multipleOf_;
1271      bool exclusiveMinimum_;
1272      bool exclusiveMaximum_;
1273      SizeType defaultValueLength_;
1274  };
1275  template<typename Stack, typename Ch>
1276  struct TokenHelper {
1277      RAPIDJSON_FORCEINLINE static void AppendIndexToken(Stack& documentStack, SizeType index) {
1278          *documentStack.template Push<Ch>() = '/';
1279          char buffer[21];
1280          size_t length = static_cast<size_t>((sizeof(SizeType) == 4 ? u32toa(index, buffer) : u64toa(index, buffer)) - buffer);
1281          for (size_t i = 0; i < length; i++)
1282              *documentStack.template Push<Ch>() = static_cast<Ch>(buffer[i]);
1283      }
1284  };
1285  template <typename Stack>
1286  struct TokenHelper<Stack, char> {
1287      RAPIDJSON_FORCEINLINE static void AppendIndexToken(Stack& documentStack, SizeType index) {
1288          if (sizeof(SizeType) == 4) {
1289              char *buffer = documentStack.template Push<char>(1 + 10); 
1290              *buffer++ = '/';
1291              const char* end = internal::u32toa(index, buffer);
1292               documentStack.template Pop<char>(static_cast<size_t>(10 - (end - buffer)));
1293          }
1294          else {
1295              char *buffer = documentStack.template Push<char>(1 + 20); 
1296              *buffer++ = '/';
1297              const char* end = internal::u64toa(index, buffer);
1298              documentStack.template Pop<char>(static_cast<size_t>(20 - (end - buffer)));
1299          }
1300      }
1301  };
1302  } 
1303  template <typename SchemaDocumentType>
1304  class IGenericRemoteSchemaDocumentProvider {
1305  public:
1306      typedef typename SchemaDocumentType::Ch Ch;
1307      typedef typename SchemaDocumentType::ValueType ValueType;
1308      typedef typename SchemaDocumentType::AllocatorType AllocatorType;
1309      virtual ~IGenericRemoteSchemaDocumentProvider() {}
1310      virtual const SchemaDocumentType* GetRemoteDocument(const Ch* uri, SizeType length) = 0;
1311      virtual const SchemaDocumentType* GetRemoteDocument(GenericUri<ValueType, AllocatorType> uri) { return GetRemoteDocument(uri.GetBaseString(), uri.GetBaseStringLength()); }
1312  };
1313  template <typename ValueT, typename Allocator = CrtAllocator>
1314  class GenericSchemaDocument {
1315  public:
1316      typedef ValueT ValueType;
1317      typedef IGenericRemoteSchemaDocumentProvider<GenericSchemaDocument> IRemoteSchemaDocumentProviderType;
1318      typedef Allocator AllocatorType;
1319      typedef typename ValueType::EncodingType EncodingType;
1320      typedef typename EncodingType::Ch Ch;
1321      typedef internal::Schema<GenericSchemaDocument> SchemaType;
1322      typedef GenericPointer<ValueType, Allocator> PointerType;
1323      typedef GenericValue<EncodingType, AllocatorType> SValue;
1324      typedef GenericUri<ValueType, Allocator> UriType;
1325      friend class internal::Schema<GenericSchemaDocument>;
1326      template <typename, typename, typename>
1327      friend class GenericSchemaValidator;
1328      explicit GenericSchemaDocument(const ValueType& document, const Ch* uri = 0, SizeType uriLength = 0,
1329          IRemoteSchemaDocumentProviderType* remoteProvider = 0, Allocator* allocator = 0,
1330          const PointerType& pointer = PointerType()) :  
1331          remoteProvider_(remoteProvider),
1332          allocator_(allocator),
1333          ownAllocator_(),
1334          root_(),
1335          typeless_(),
1336          schemaMap_(allocator, kInitialSchemaMapSize),
1337          schemaRef_(allocator, kInitialSchemaRefSize)
1338      {
1339          if (!allocator_)
1340              ownAllocator_ = allocator_ = RAPIDJSON_NEW(Allocator)();
1341          Ch noUri[1] = {0};
1342          uri_.SetString(uri ? uri : noUri, uriLength, *allocator_);
1343          docId_ = UriType(uri_, allocator_);
1344          typeless_ = static_cast<SchemaType*>(allocator_->Malloc(sizeof(SchemaType)));
1345          new (typeless_) SchemaType(this, PointerType(), ValueType(kObjectType).Move(), ValueType(kObjectType).Move(), allocator_, docId_);
1346          root_ = typeless_;
1347          if (pointer.GetTokenCount() == 0) {
1348              CreateSchemaRecursive(&root_, pointer, document, document, docId_);
1349          }
1350          else if (const ValueType* v = pointer.Get(document)) {
1351              CreateSchema(&root_, pointer, *v, document, docId_);
1352          }
1353          RAPIDJSON_ASSERT(root_ != 0);
1354          schemaRef_.ShrinkToFit(); 
1355      }
1356  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
1357      GenericSchemaDocument(GenericSchemaDocument&& rhs) RAPIDJSON_NOEXCEPT :
1358          remoteProvider_(rhs.remoteProvider_),
1359          allocator_(rhs.allocator_),
1360          ownAllocator_(rhs.ownAllocator_),
1361          root_(rhs.root_),
1362          typeless_(rhs.typeless_),
1363          schemaMap_(std::move(rhs.schemaMap_)),
1364          schemaRef_(std::move(rhs.schemaRef_)),
1365          uri_(std::move(rhs.uri_)),
1366          docId_(rhs.docId_)
1367      {
1368          rhs.remoteProvider_ = 0;
1369          rhs.allocator_ = 0;
1370          rhs.ownAllocator_ = 0;
1371          rhs.typeless_ = 0;
1372      }
1373  #endif
1374      ~GenericSchemaDocument() {
1375          while (!schemaMap_.Empty())
1376              schemaMap_.template Pop<SchemaEntry>(1)->~SchemaEntry();
1377          if (typeless_) {
1378              typeless_->~SchemaType();
1379              Allocator::Free(typeless_);
1380          }
1381          RAPIDJSON_DELETE(ownAllocator_);
1382      }
1383      const SValue& GetURI() const { return uri_; }
1384      const SchemaType& GetRoot() const { return *root_; }
1385  private:
1386      GenericSchemaDocument(const GenericSchemaDocument&);
1387      GenericSchemaDocument& operator=(const GenericSchemaDocument&);
1388      typedef const PointerType* SchemaRefPtr; 
1389      struct SchemaEntry {
1390          SchemaEntry(const PointerType& p, SchemaType* s, bool o, Allocator* allocator) : pointer(p, allocator), schema(s), owned(o) {}
1391          ~SchemaEntry() {
1392              if (owned) {
1393                  schema->~SchemaType();
1394                  Allocator::Free(schema);
1395              }
1396          }
1397          PointerType pointer;
1398          SchemaType* schema;
1399          bool owned;
1400      };
1401      void CreateSchemaRecursive(const SchemaType** schema, const PointerType& pointer, const ValueType& v, const ValueType& document, const UriType& id) {
1402          if (v.GetType() == kObjectType) {
1403              UriType newid = UriType(CreateSchema(schema, pointer, v, document, id), allocator_);
1404              for (typename ValueType::ConstMemberIterator itr = v.MemberBegin(); itr != v.MemberEnd(); ++itr)
1405                  CreateSchemaRecursive(0, pointer.Append(itr->name, allocator_), itr->value, document, newid);
1406          }
1407          else if (v.GetType() == kArrayType)
1408              for (SizeType i = 0; i < v.Size(); i++)
1409                  CreateSchemaRecursive(0, pointer.Append(i, allocator_), v[i], document, id);
1410      }
1411      const UriType& CreateSchema(const SchemaType** schema, const PointerType& pointer, const ValueType& v, const ValueType& document, const UriType& id) {
1412          RAPIDJSON_ASSERT(pointer.IsValid());
1413          if (v.IsObject()) {
1414              if (const SchemaType* sc = GetSchema(pointer)) {
1415                  if (schema)
1416                      *schema = sc;
1417                  AddSchemaRefs(const_cast<SchemaType*>(sc));
1418              }
1419              else if (!HandleRefSchema(pointer, schema, v, document, id)) {
1420                  SchemaType* s = new (allocator_->Malloc(sizeof(SchemaType))) SchemaType(this, pointer, v, document, allocator_, id);
1421                  if (schema)
1422                      *schema = s;
1423                  return s->GetId();
1424              }
1425          }
1426          else {
1427              if (schema)
1428                  *schema = typeless_;
1429              AddSchemaRefs(typeless_);
1430          }
1431          return id;
1432      }
1433      bool HandleRefSchema(const PointerType& source, const SchemaType** schema, const ValueType& v, const ValueType& document, const UriType& id) {
1434          typename ValueType::ConstMemberIterator itr = v.FindMember(SchemaType::GetRefString());
1435          if (itr == v.MemberEnd())
1436              return false;
1437          new (schemaRef_.template Push<SchemaRefPtr>()) SchemaRefPtr(&source);
1438          if (itr->value.IsString()) {
1439              SizeType len = itr->value.GetStringLength();
1440              if (len > 0) {
1441                  UriType scopeId = UriType(id, allocator_);
1442                  UriType ref = UriType(itr->value, allocator_).Resolve(scopeId, allocator_);
1443                  PointerType basePointer = PointerType();
1444                  const ValueType *base = FindId(document, ref, basePointer, docId_, false);
1445                  if (!base) {
1446                      if (remoteProvider_) {
1447                          if (const GenericSchemaDocument* remoteDocument = remoteProvider_->GetRemoteDocument(ref)) {
1448                              const Ch* s = ref.GetFragString();
1449                              len = ref.GetFragStringLength();
1450                              if (len <= 1 || s[1] == '/') {
1451                                  const PointerType pointer(s, len, allocator_);
1452                                  if (pointer.IsValid()) {
1453                                      if (const SchemaType *sc = remoteDocument->GetSchema(pointer)) {
1454                                          if (schema)
1455                                              *schema = sc;
1456                                          AddSchemaRefs(const_cast<SchemaType *>(sc));
1457                                          return true;
1458                                      }
1459                                  }
1460                            } else {
1461                            }
1462                          }
1463                      }
1464                  }
1465                  else { 
1466                      const Ch* s = ref.GetFragString();
1467                      len = ref.GetFragStringLength();
1468                      if (len <= 1 || s[1] == '/') {
1469                          const PointerType relPointer(s, len, allocator_);
1470                          if (relPointer.IsValid()) {
1471                              if (const ValueType *pv = relPointer.Get(*base)) {
1472                                  PointerType pointer(basePointer);
1473                                  for (SizeType i = 0; i < relPointer.GetTokenCount(); i++)
1474                                      pointer = pointer.Append(relPointer.GetTokens()[i], allocator_);
1475                                  if (pointer.IsValid() && !IsCyclicRef(pointer)) {
1476                                      size_t unresolvedTokenIndex;
1477                                      scopeId = pointer.GetUri(document, docId_, &unresolvedTokenIndex, allocator_);
1478                                      CreateSchema(schema, pointer, *pv, document, scopeId);
1479                                      return true;
1480                                  }
1481                              }
1482                          }
1483                      } else {
1484                          PointerType pointer = PointerType();
1485                          if (const ValueType *pv = FindId(*base, ref, pointer, UriType(ref.GetBaseString(), ref.GetBaseStringLength(), allocator_), true, basePointer)) {
1486                              if (!IsCyclicRef(pointer)) {
1487                                  size_t unresolvedTokenIndex;
1488                                  scopeId = pointer.GetUri(document, docId_, &unresolvedTokenIndex, allocator_);
1489                                  CreateSchema(schema, pointer, *pv, document, scopeId);
1490                                  return true;
1491                              }
1492                          }
1493                      }
1494                  }
1495              }
1496          }
1497          if (schema)
1498              *schema = typeless_;
1499          AddSchemaRefs(typeless_);
1500          return true;
1501      }
1502      ValueType* FindId(const ValueType& doc, const UriType& finduri, PointerType& resptr, const UriType& baseuri, bool full, const PointerType& here = PointerType()) const {
1503          SizeType i = 0;
1504          ValueType* resval = 0;
1505          UriType tempuri = UriType(finduri, allocator_);
1506          UriType localuri = UriType(baseuri, allocator_);
1507          if (doc.GetType() == kObjectType) {
1508              typename ValueType::ConstMemberIterator m = doc.FindMember(SchemaType::GetIdString());
1509              if (m != doc.MemberEnd() && m->value.GetType() == kStringType) {
1510                  localuri = UriType(m->value, allocator_).Resolve(baseuri, allocator_);
1511              }
1512              if (localuri.Match(finduri, full)) {
1513                  resval = const_cast<ValueType *>(&doc);
1514                  resptr = here;
1515                  return resval;
1516              }
1517              for (m = doc.MemberBegin(); m != doc.MemberEnd(); ++m) {
1518                  if (m->value.GetType() == kObjectType || m->value.GetType() == kArrayType) {
1519                      resval = FindId(m->value, finduri, resptr, localuri, full, here.Append(m->name.GetString(), m->name.GetStringLength(), allocator_));
1520                  }
1521                  if (resval) break;
1522              }
1523          } else if (doc.GetType() == kArrayType) {
1524              for (typename ValueType::ConstValueIterator v = doc.Begin(); v != doc.End(); ++v) {
1525                  if (v->GetType() == kObjectType || v->GetType() == kArrayType) {
1526                      resval = FindId(*v, finduri, resptr, localuri, full, here.Append(i, allocator_));
1527                  }
1528                  if (resval) break;
1529                  i++;
1530              }
1531          }
1532          return resval;
1533      }
1534      void AddSchemaRefs(SchemaType* schema) {
1535          while (!schemaRef_.Empty()) {
1536              SchemaRefPtr *ref = schemaRef_.template Pop<SchemaRefPtr>(1);
1537              SchemaEntry *entry = schemaMap_.template Push<SchemaEntry>();
1538              new (entry) SchemaEntry(**ref, schema, false, allocator_);
1539          }
1540      }
1541      bool IsCyclicRef(const PointerType& pointer) const {
1542          for (const SchemaRefPtr* ref = schemaRef_.template Bottom<SchemaRefPtr>(); ref != schemaRef_.template End<SchemaRefPtr>(); ++ref)
1543              if (pointer == **ref)
1544                  return true;
1545          return false;
1546      }
1547      const SchemaType* GetSchema(const PointerType& pointer) const {
1548          for (const SchemaEntry* target = schemaMap_.template Bottom<SchemaEntry>(); target != schemaMap_.template End<SchemaEntry>(); ++target)
1549              if (pointer == target->pointer)
1550                  return target->schema;
1551          return 0;
1552      }
1553      PointerType GetPointer(const SchemaType* schema) const {
1554          for (const SchemaEntry* target = schemaMap_.template Bottom<SchemaEntry>(); target != schemaMap_.template End<SchemaEntry>(); ++target)
1555              if (schema == target->schema)
1556                  return target->pointer;
1557          return PointerType();
1558      }
1559      const SchemaType* GetTypeless() const { return typeless_; }
1560      static const size_t kInitialSchemaMapSize = 64;
1561      static const size_t kInitialSchemaRefSize = 64;
1562      IRemoteSchemaDocumentProviderType* remoteProvider_;
1563      Allocator *allocator_;
1564      Allocator *ownAllocator_;
1565      const SchemaType* root_;                
1566      SchemaType* typeless_;
1567      internal::Stack<Allocator> schemaMap_;  
1568      internal::Stack<Allocator> schemaRef_;  
1569      SValue uri_;                            
1570      UriType docId_;
1571  };
1572  typedef GenericSchemaDocument<Value> SchemaDocument;
1573  typedef IGenericRemoteSchemaDocumentProvider<SchemaDocument> IRemoteSchemaDocumentProvider;
1574  template <
1575      typename SchemaDocumentType,
1576      typename OutputHandler = BaseReaderHandler<typename SchemaDocumentType::SchemaType::EncodingType>,
1577      typename StateAllocator = CrtAllocator>
1578  class GenericSchemaValidator :
1579      public internal::ISchemaStateFactory<typename SchemaDocumentType::SchemaType>,
1580      public internal::ISchemaValidator,
1581      public internal::IValidationErrorHandler<typename SchemaDocumentType::SchemaType> {
1582  public:
1583      typedef typename SchemaDocumentType::SchemaType SchemaType;
1584      typedef typename SchemaDocumentType::PointerType PointerType;
1585      typedef typename SchemaType::EncodingType EncodingType;
1586      typedef typename SchemaType::SValue SValue;
1587      typedef typename EncodingType::Ch Ch;
1588      typedef GenericStringRef<Ch> StringRefType;
1589      typedef GenericValue<EncodingType, StateAllocator> ValueType;
1590      GenericSchemaValidator(
1591          const SchemaDocumentType& schemaDocument,
1592          StateAllocator* allocator = 0,
1593          size_t schemaStackCapacity = kDefaultSchemaStackCapacity,
1594          size_t documentStackCapacity = kDefaultDocumentStackCapacity)
1595          :
1596          schemaDocument_(&schemaDocument),
1597          root_(schemaDocument.GetRoot()),
1598          stateAllocator_(allocator),
1599          ownStateAllocator_(0),
1600          schemaStack_(allocator, schemaStackCapacity),
1601          documentStack_(allocator, documentStackCapacity),
1602          outputHandler_(0),
1603          error_(kObjectType),
1604          currentError_(),
1605          missingDependents_(),
1606          valid_(true),
1607          flags_(kValidateDefaultFlags)
1608  #if RAPIDJSON_SCHEMA_VERBOSE
1609          , depth_(0)
1610  #endif
1611      {
1612      }
1613      GenericSchemaValidator(
1614          const SchemaDocumentType& schemaDocument,
1615          OutputHandler& outputHandler,
1616          StateAllocator* allocator = 0,
1617          size_t schemaStackCapacity = kDefaultSchemaStackCapacity,
1618          size_t documentStackCapacity = kDefaultDocumentStackCapacity)
1619          :
1620          schemaDocument_(&schemaDocument),
1621          root_(schemaDocument.GetRoot()),
1622          stateAllocator_(allocator),
1623          ownStateAllocator_(0),
1624          schemaStack_(allocator, schemaStackCapacity),
1625          documentStack_(allocator, documentStackCapacity),
1626          outputHandler_(&outputHandler),
1627          error_(kObjectType),
1628          currentError_(),
1629          missingDependents_(),
1630          valid_(true),
1631          flags_(kValidateDefaultFlags)
1632  #if RAPIDJSON_SCHEMA_VERBOSE
1633          , depth_(0)
1634  #endif
1635      {
1636      }
1637      ~GenericSchemaValidator() {
1638          Reset();
1639          RAPIDJSON_DELETE(ownStateAllocator_);
1640      }
1641      void Reset() {
1642          while (!schemaStack_.Empty())
1643              PopSchema();
1644          documentStack_.Clear();
1645          ResetError();
1646      }
1647      void ResetError() {
1648          error_.SetObject();
1649          currentError_.SetNull();
1650          missingDependents_.SetNull();
1651          valid_ = true;
1652      }
1653      void SetValidateFlags(unsigned flags) {
1654          flags_ = flags;
1655      }
1656      virtual unsigned GetValidateFlags() const {
1657          return flags_;
1658      }
1659      virtual bool IsValid() const {
1660          if (!valid_) return false;
1661          if (GetContinueOnErrors() && !error_.ObjectEmpty()) return false;
1662          return true;
1663      }
1664      ValueType& GetError() { return error_; }
1665      const ValueType& GetError() const { return error_; }
1666      PointerType GetInvalidSchemaPointer() const {
1667          return schemaStack_.Empty() ? PointerType() : CurrentSchema().GetPointer();
1668      }
1669      const Ch* GetInvalidSchemaKeyword() const {
1670          if (!schemaStack_.Empty()) return CurrentContext().invalidKeyword;
1671          if (GetContinueOnErrors() && !error_.ObjectEmpty()) return (const Ch*)GetErrorsString();
1672          return 0;
1673      }
1674      ValidateErrorCode GetInvalidSchemaCode() const {
1675          if (!schemaStack_.Empty()) return CurrentContext().invalidCode;
1676          if (GetContinueOnErrors() && !error_.ObjectEmpty()) return kValidateErrors;
1677          return kValidateErrorNone;
1678      }
1679      PointerType GetInvalidDocumentPointer() const {
1680          if (documentStack_.Empty()) {
1681              return PointerType();
1682          }
1683          else {
1684              return PointerType(documentStack_.template Bottom<Ch>(), documentStack_.GetSize() / sizeof(Ch));
1685          }
1686      }
1687      void NotMultipleOf(int64_t actual, const SValue& expected) {
1688          AddNumberError(kValidateErrorMultipleOf, ValueType(actual).Move(), expected);
1689      }
1690      void NotMultipleOf(uint64_t actual, const SValue& expected) {
1691          AddNumberError(kValidateErrorMultipleOf, ValueType(actual).Move(), expected);
1692      }
1693      void NotMultipleOf(double actual, const SValue& expected) {
1694          AddNumberError(kValidateErrorMultipleOf, ValueType(actual).Move(), expected);
1695      }
1696      void AboveMaximum(int64_t actual, const SValue& expected, bool exclusive) {
1697          AddNumberError(exclusive ? kValidateErrorExclusiveMaximum : kValidateErrorMaximum, ValueType(actual).Move(), expected,
1698              exclusive ? &SchemaType::GetExclusiveMaximumString : 0);
1699      }
1700      void AboveMaximum(uint64_t actual, const SValue& expected, bool exclusive) {
1701          AddNumberError(exclusive ? kValidateErrorExclusiveMaximum : kValidateErrorMaximum, ValueType(actual).Move(), expected,
1702              exclusive ? &SchemaType::GetExclusiveMaximumString : 0);
1703      }
1704      void AboveMaximum(double actual, const SValue& expected, bool exclusive) {
1705          AddNumberError(exclusive ? kValidateErrorExclusiveMaximum : kValidateErrorMaximum, ValueType(actual).Move(), expected,
1706              exclusive ? &SchemaType::GetExclusiveMaximumString : 0);
1707      }
1708      void BelowMinimum(int64_t actual, const SValue& expected, bool exclusive) {
1709          AddNumberError(exclusive ? kValidateErrorExclusiveMinimum : kValidateErrorMinimum, ValueType(actual).Move(), expected,
1710              exclusive ? &SchemaType::GetExclusiveMinimumString : 0);
1711      }
1712      void BelowMinimum(uint64_t actual, const SValue& expected, bool exclusive) {
1713          AddNumberError(exclusive ? kValidateErrorExclusiveMinimum : kValidateErrorMinimum, ValueType(actual).Move(), expected,
1714              exclusive ? &SchemaType::GetExclusiveMinimumString : 0);
1715      }
1716      void BelowMinimum(double actual, const SValue& expected, bool exclusive) {
1717          AddNumberError(exclusive ? kValidateErrorExclusiveMinimum : kValidateErrorMinimum, ValueType(actual).Move(), expected,
1718              exclusive ? &SchemaType::GetExclusiveMinimumString : 0);
1719      }
1720      void TooLong(const Ch* str, SizeType length, SizeType expected) {
1721          AddNumberError(kValidateErrorMaxLength,
1722              ValueType(str, length, GetStateAllocator()).Move(), SValue(expected).Move());
1723      }
1724      void TooShort(const Ch* str, SizeType length, SizeType expected) {
1725          AddNumberError(kValidateErrorMinLength,
1726              ValueType(str, length, GetStateAllocator()).Move(), SValue(expected).Move());
1727      }
1728      void DoesNotMatch(const Ch* str, SizeType length) {
1729          currentError_.SetObject();
1730          currentError_.AddMember(GetActualString(), ValueType(str, length, GetStateAllocator()).Move(), GetStateAllocator());
1731          AddCurrentError(kValidateErrorPattern);
1732      }
1733      void DisallowedItem(SizeType index) {
1734          currentError_.SetObject();
1735          currentError_.AddMember(GetDisallowedString(), ValueType(index).Move(), GetStateAllocator());
1736          AddCurrentError(kValidateErrorAdditionalItems, true);
1737      }
1738      void TooFewItems(SizeType actualCount, SizeType expectedCount) {
1739          AddNumberError(kValidateErrorMinItems,
1740              ValueType(actualCount).Move(), SValue(expectedCount).Move());
1741      }
1742      void TooManyItems(SizeType actualCount, SizeType expectedCount) {
1743          AddNumberError(kValidateErrorMaxItems,
1744              ValueType(actualCount).Move(), SValue(expectedCount).Move());
1745      }
1746      void DuplicateItems(SizeType index1, SizeType index2) {
1747          ValueType duplicates(kArrayType);
1748          duplicates.PushBack(index1, GetStateAllocator());
1749          duplicates.PushBack(index2, GetStateAllocator());
1750          currentError_.SetObject();
1751          currentError_.AddMember(GetDuplicatesString(), duplicates, GetStateAllocator());
1752          AddCurrentError(kValidateErrorUniqueItems, true);
1753      }
1754      void TooManyProperties(SizeType actualCount, SizeType expectedCount) {
1755          AddNumberError(kValidateErrorMaxProperties,
1756              ValueType(actualCount).Move(), SValue(expectedCount).Move());
1757      }
1758      void TooFewProperties(SizeType actualCount, SizeType expectedCount) {
1759          AddNumberError(kValidateErrorMinProperties,
1760              ValueType(actualCount).Move(), SValue(expectedCount).Move());
1761      }
1762      void StartMissingProperties() {
1763          currentError_.SetArray();
1764      }
1765      void AddMissingProperty(const SValue& name) {
<span onclick='openModal()' class='match'>1766          currentError_.PushBack(ValueType(name, GetStateAllocator()).Move(), GetStateAllocator());
1767      }
1768      bool EndMissingProperties() {
</span>1769          if (currentError_.Empty())
1770              return false;
1771          ValueType error(kObjectType);
1772          error.AddMember(GetMissingString(), currentError_, GetStateAllocator());
1773          currentError_ = error;
1774          AddCurrentError(kValidateErrorRequired);
1775          return true;
1776      }
1777      void PropertyViolations(ISchemaValidator** subvalidators, SizeType count) {
1778          for (SizeType i = 0; i < count; ++i)
1779              MergeError(static_cast<GenericSchemaValidator*>(subvalidators[i])->GetError());
1780      }
1781      void DisallowedProperty(const Ch* name, SizeType length) {
1782          currentError_.SetObject();
1783          currentError_.AddMember(GetDisallowedString(), ValueType(name, length, GetStateAllocator()).Move(), GetStateAllocator());
1784          AddCurrentError(kValidateErrorAdditionalProperties, true);
1785      }
1786      void StartDependencyErrors() {
1787          currentError_.SetObject();
1788      }
1789      void StartMissingDependentProperties() {
1790          missingDependents_.SetArray();
1791      }
1792      void AddMissingDependentProperty(const SValue& targetName) {
1793          missingDependents_.PushBack(ValueType(targetName, GetStateAllocator()).Move(), GetStateAllocator());
1794      }
1795      void EndMissingDependentProperties(const SValue& sourceName) {
1796          if (!missingDependents_.Empty()) {
1797              ValueType error(kObjectType);
1798              ValidateErrorCode code = kValidateErrorRequired;
1799              error.AddMember(GetMissingString(), missingDependents_.Move(), GetStateAllocator());
1800              AddErrorCode(error, code);
1801              AddErrorInstanceLocation(error, false);
1802              PointerType schemaRef = GetInvalidSchemaPointer().Append(SchemaType::GetValidateErrorKeyword(kValidateErrorDependencies), &GetInvalidSchemaPointer().GetAllocator());
1803              AddErrorSchemaLocation(error, schemaRef.Append(sourceName.GetString(), sourceName.GetStringLength(), &GetInvalidSchemaPointer().GetAllocator()));
1804              ValueType wrapper(kObjectType);
1805              wrapper.AddMember(ValueType(SchemaType::GetValidateErrorKeyword(code), GetStateAllocator()).Move(), error, GetStateAllocator());
1806              currentError_.AddMember(ValueType(sourceName, GetStateAllocator()).Move(), wrapper, GetStateAllocator());
1807          }
1808      }
1809      void AddDependencySchemaError(const SValue& sourceName, ISchemaValidator* subvalidator) {
1810          currentError_.AddMember(ValueType(sourceName, GetStateAllocator()).Move(),
1811              static_cast<GenericSchemaValidator*>(subvalidator)->GetError(), GetStateAllocator());
1812      }
1813      bool EndDependencyErrors() {
1814          if (currentError_.ObjectEmpty())
1815              return false;
1816          ValueType error(kObjectType);
1817          error.AddMember(GetErrorsString(), currentError_, GetStateAllocator());
1818          currentError_ = error;
1819          AddCurrentError(kValidateErrorDependencies);
1820          return true;
1821      }
1822      void DisallowedValue(const ValidateErrorCode code = kValidateErrorEnum) {
1823          currentError_.SetObject();
1824          AddCurrentError(code);
1825      }
1826      void StartDisallowedType() {
1827          currentError_.SetArray();
1828      }
1829      void AddExpectedType(const typename SchemaType::ValueType& expectedType) {
1830          currentError_.PushBack(ValueType(expectedType, GetStateAllocator()).Move(), GetStateAllocator());
1831      }
1832      void EndDisallowedType(const typename SchemaType::ValueType& actualType) {
1833          ValueType error(kObjectType);
1834          error.AddMember(GetExpectedString(), currentError_, GetStateAllocator());
1835          error.AddMember(GetActualString(), ValueType(actualType, GetStateAllocator()).Move(), GetStateAllocator());
1836          currentError_ = error;
1837          AddCurrentError(kValidateErrorType);
1838      }
1839      void NotAllOf(ISchemaValidator** subvalidators, SizeType count) {
1840          AddErrorArray(kValidateErrorAllOf, subvalidators, count);
1841      }
1842      void NoneOf(ISchemaValidator** subvalidators, SizeType count) {
1843          AddErrorArray(kValidateErrorAnyOf, subvalidators, count);
1844      }
1845      void NotOneOf(ISchemaValidator** subvalidators, SizeType count, bool matched = false) {
1846          AddErrorArray(matched ? kValidateErrorOneOfMatch : kValidateErrorOneOf, subvalidators, count);
1847      }
1848      void Disallowed() {
1849          currentError_.SetObject();
1850          AddCurrentError(kValidateErrorNot);
1851      }
1852  #define RAPIDJSON_STRING_(name, ...) \
1853      static const StringRefType& Get##name##String() {\
1854          static const Ch s[] = { __VA_ARGS__, '\0' };\
1855          static const StringRefType v(s, static_cast<SizeType>(sizeof(s) / sizeof(Ch) - 1)); \
1856          return v;\
1857      }
1858      RAPIDJSON_STRING_(InstanceRef, 'i', 'n', 's', 't', 'a', 'n', 'c', 'e', 'R', 'e', 'f')
1859      RAPIDJSON_STRING_(SchemaRef, 's', 'c', 'h', 'e', 'm', 'a', 'R', 'e', 'f')
1860      RAPIDJSON_STRING_(Expected, 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd')
1861      RAPIDJSON_STRING_(Actual, 'a', 'c', 't', 'u', 'a', 'l')
1862      RAPIDJSON_STRING_(Disallowed, 'd', 'i', 's', 'a', 'l', 'l', 'o', 'w', 'e', 'd')
1863      RAPIDJSON_STRING_(Missing, 'm', 'i', 's', 's', 'i', 'n', 'g')
1864      RAPIDJSON_STRING_(Errors, 'e', 'r', 'r', 'o', 'r', 's')
1865      RAPIDJSON_STRING_(ErrorCode, 'e', 'r', 'r', 'o', 'r', 'C', 'o', 'd', 'e')
1866      RAPIDJSON_STRING_(ErrorMessage, 'e', 'r', 'r', 'o', 'r', 'M', 'e', 's', 's', 'a', 'g', 'e')
1867      RAPIDJSON_STRING_(Duplicates, 'd', 'u', 'p', 'l', 'i', 'c', 'a', 't', 'e', 's')
1868  #undef RAPIDJSON_STRING_
1869  #if RAPIDJSON_SCHEMA_VERBOSE
1870  #define RAPIDJSON_SCHEMA_HANDLE_BEGIN_VERBOSE_() \
1871  RAPIDJSON_MULTILINEMACRO_BEGIN\
1872      *documentStack_.template Push<Ch>() = '\0';\
1873      documentStack_.template Pop<Ch>(1);\
1874      internal::PrintInvalidDocument(documentStack_.template Bottom<Ch>());\
1875  RAPIDJSON_MULTILINEMACRO_END
1876  #else
1877  #define RAPIDJSON_SCHEMA_HANDLE_BEGIN_VERBOSE_()
1878  #endif
1879  #define RAPIDJSON_SCHEMA_HANDLE_BEGIN_(method, arg1)\
1880      if (!valid_) return false; \
1881      if ((!BeginValue() && !GetContinueOnErrors()) || (!CurrentSchema().method arg1 && !GetContinueOnErrors())) {\
1882          RAPIDJSON_SCHEMA_HANDLE_BEGIN_VERBOSE_();\
1883          return valid_ = false;\
1884      }
1885  #define RAPIDJSON_SCHEMA_HANDLE_PARALLEL_(method, arg2)\
1886      for (Context* context = schemaStack_.template Bottom<Context>(); context != schemaStack_.template End<Context>(); context++) {\
1887          if (context->hasher)\
1888              static_cast<HasherType*>(context->hasher)->method arg2;\
1889          if (context->validators)\
1890              for (SizeType i_ = 0; i_ < context->validatorCount; i_++)\
1891                  static_cast<GenericSchemaValidator*>(context->validators[i_])->method arg2;\
1892          if (context->patternPropertiesValidators)\
1893              for (SizeType i_ = 0; i_ < context->patternPropertiesValidatorCount; i_++)\
1894                  static_cast<GenericSchemaValidator*>(context->patternPropertiesValidators[i_])->method arg2;\
1895      }
1896  #define RAPIDJSON_SCHEMA_HANDLE_END_(method, arg2)\
1897      valid_ = (EndValue() || GetContinueOnErrors()) && (!outputHandler_ || outputHandler_->method arg2);\
1898      return valid_;
1899  #define RAPIDJSON_SCHEMA_HANDLE_VALUE_(method, arg1, arg2) \
1900      RAPIDJSON_SCHEMA_HANDLE_BEGIN_   (method, arg1);\
1901      RAPIDJSON_SCHEMA_HANDLE_PARALLEL_(method, arg2);\
1902      RAPIDJSON_SCHEMA_HANDLE_END_     (method, arg2)
1903      bool Null()             { RAPIDJSON_SCHEMA_HANDLE_VALUE_(Null,   (CurrentContext()), ( )); }
1904      bool Bool(bool b)       { RAPIDJSON_SCHEMA_HANDLE_VALUE_(Bool,   (CurrentContext(), b), (b)); }
1905      bool Int(int i)         { RAPIDJSON_SCHEMA_HANDLE_VALUE_(Int,    (CurrentContext(), i), (i)); }
1906      bool Uint(unsigned u)   { RAPIDJSON_SCHEMA_HANDLE_VALUE_(Uint,   (CurrentContext(), u), (u)); }
1907      bool Int64(int64_t i)   { RAPIDJSON_SCHEMA_HANDLE_VALUE_(Int64,  (CurrentContext(), i), (i)); }
1908      bool Uint64(uint64_t u) { RAPIDJSON_SCHEMA_HANDLE_VALUE_(Uint64, (CurrentContext(), u), (u)); }
1909      bool Double(double d)   { RAPIDJSON_SCHEMA_HANDLE_VALUE_(Double, (CurrentContext(), d), (d)); }
1910      bool RawNumber(const Ch* str, SizeType length, bool copy)
1911                                      { RAPIDJSON_SCHEMA_HANDLE_VALUE_(String, (CurrentContext(), str, length, copy), (str, length, copy)); }
1912      bool String(const Ch* str, SizeType length, bool copy)
1913                                      { RAPIDJSON_SCHEMA_HANDLE_VALUE_(String, (CurrentContext(), str, length, copy), (str, length, copy)); }
1914      bool StartObject() {
1915          RAPIDJSON_SCHEMA_HANDLE_BEGIN_(StartObject, (CurrentContext()));
1916          RAPIDJSON_SCHEMA_HANDLE_PARALLEL_(StartObject, ());
1917          return valid_ = !outputHandler_ || outputHandler_->StartObject();
1918      }
1919      bool Key(const Ch* str, SizeType len, bool copy) {
1920          if (!valid_) return false;
1921          AppendToken(str, len);
1922          if (!CurrentSchema().Key(CurrentContext(), str, len, copy) && !GetContinueOnErrors()) return valid_ = false;
1923          RAPIDJSON_SCHEMA_HANDLE_PARALLEL_(Key, (str, len, copy));
1924          return valid_ = !outputHandler_ || outputHandler_->Key(str, len, copy);
1925      }
1926      bool EndObject(SizeType memberCount) {
1927          if (!valid_) return false;
1928          RAPIDJSON_SCHEMA_HANDLE_PARALLEL_(EndObject, (memberCount));
1929          if (!CurrentSchema().EndObject(CurrentContext(), memberCount) && !GetContinueOnErrors()) return valid_ = false;
1930          RAPIDJSON_SCHEMA_HANDLE_END_(EndObject, (memberCount));
1931      }
1932      bool StartArray() {
1933          RAPIDJSON_SCHEMA_HANDLE_BEGIN_(StartArray, (CurrentContext()));
1934          RAPIDJSON_SCHEMA_HANDLE_PARALLEL_(StartArray, ());
1935          return valid_ = !outputHandler_ || outputHandler_->StartArray();
1936      }
1937      bool EndArray(SizeType elementCount) {
1938          if (!valid_) return false;
1939          RAPIDJSON_SCHEMA_HANDLE_PARALLEL_(EndArray, (elementCount));
1940          if (!CurrentSchema().EndArray(CurrentContext(), elementCount) && !GetContinueOnErrors()) return valid_ = false;
1941          RAPIDJSON_SCHEMA_HANDLE_END_(EndArray, (elementCount));
1942      }
1943  #undef RAPIDJSON_SCHEMA_HANDLE_BEGIN_VERBOSE_
1944  #undef RAPIDJSON_SCHEMA_HANDLE_BEGIN_
1945  #undef RAPIDJSON_SCHEMA_HANDLE_PARALLEL_
1946  #undef RAPIDJSON_SCHEMA_HANDLE_VALUE_
1947      virtual ISchemaValidator* CreateSchemaValidator(const SchemaType& root, const bool inheritContinueOnErrors) {
1948          ISchemaValidator* sv = new (GetStateAllocator().Malloc(sizeof(GenericSchemaValidator))) GenericSchemaValidator(*schemaDocument_, root, documentStack_.template Bottom<char>(), documentStack_.GetSize(),
1949  #if RAPIDJSON_SCHEMA_VERBOSE
1950          depth_ + 1,
1951  #endif
1952          &GetStateAllocator());
1953          sv->SetValidateFlags(inheritContinueOnErrors ? GetValidateFlags() : GetValidateFlags() & ~(unsigned)kValidateContinueOnErrorFlag);
1954          return sv;
1955      }
1956      virtual void DestroySchemaValidator(ISchemaValidator* validator) {
1957          GenericSchemaValidator* v = static_cast<GenericSchemaValidator*>(validator);
1958          v->~GenericSchemaValidator();
1959          StateAllocator::Free(v);
1960      }
1961      virtual void* CreateHasher() {
1962          return new (GetStateAllocator().Malloc(sizeof(HasherType))) HasherType(&GetStateAllocator());
1963      }
1964      virtual uint64_t GetHashCode(void* hasher) {
1965          return static_cast<HasherType*>(hasher)->GetHashCode();
1966      }
1967      virtual void DestroryHasher(void* hasher) {
1968          HasherType* h = static_cast<HasherType*>(hasher);
1969          h->~HasherType();
1970          StateAllocator::Free(h);
1971      }
1972      virtual void* MallocState(size_t size) {
1973          return GetStateAllocator().Malloc(size);
1974      }
1975      virtual void FreeState(void* p) {
1976          StateAllocator::Free(p);
1977      }
1978  private:
1979      typedef typename SchemaType::Context Context;
1980      typedef GenericValue<UTF8<>, StateAllocator> HashCodeArray;
1981      typedef internal::Hasher<EncodingType, StateAllocator> HasherType;
1982      GenericSchemaValidator(
1983          const SchemaDocumentType& schemaDocument,
1984          const SchemaType& root,
1985          const char* basePath, size_t basePathSize,
1986  #if RAPIDJSON_SCHEMA_VERBOSE
1987          unsigned depth,
1988  #endif
1989          StateAllocator* allocator = 0,
1990          size_t schemaStackCapacity = kDefaultSchemaStackCapacity,
1991          size_t documentStackCapacity = kDefaultDocumentStackCapacity)
1992          :
1993          schemaDocument_(&schemaDocument),
1994          root_(root),
1995          stateAllocator_(allocator),
1996          ownStateAllocator_(0),
1997          schemaStack_(allocator, schemaStackCapacity),
1998          documentStack_(allocator, documentStackCapacity),
1999          outputHandler_(0),
2000          error_(kObjectType),
2001          currentError_(),
2002          missingDependents_(),
2003          valid_(true),
2004          flags_(kValidateDefaultFlags)
2005  #if RAPIDJSON_SCHEMA_VERBOSE
2006          , depth_(depth)
2007  #endif
2008      {
2009          if (basePath && basePathSize)
2010              memcpy(documentStack_.template Push<char>(basePathSize), basePath, basePathSize);
2011      }
2012      StateAllocator& GetStateAllocator() {
2013          if (!stateAllocator_)
2014              stateAllocator_ = ownStateAllocator_ = RAPIDJSON_NEW(StateAllocator)();
2015          return *stateAllocator_;
2016      }
2017      bool GetContinueOnErrors() const {
2018          return flags_ & kValidateContinueOnErrorFlag;
2019      }
2020      bool BeginValue() {
2021          if (schemaStack_.Empty())
2022              PushSchema(root_);
2023          else {
2024              if (CurrentContext().inArray)
2025                  internal::TokenHelper<internal::Stack<StateAllocator>, Ch>::AppendIndexToken(documentStack_, CurrentContext().arrayElementIndex);
2026              if (!CurrentSchema().BeginValue(CurrentContext()) && !GetContinueOnErrors())
2027                  return false;
2028              SizeType count = CurrentContext().patternPropertiesSchemaCount;
2029              const SchemaType** sa = CurrentContext().patternPropertiesSchemas;
2030              typename Context::PatternValidatorType patternValidatorType = CurrentContext().valuePatternValidatorType;
2031              bool valueUniqueness = CurrentContext().valueUniqueness;
2032              RAPIDJSON_ASSERT(CurrentContext().valueSchema);
2033              PushSchema(*CurrentContext().valueSchema);
2034              if (count > 0) {
2035                  CurrentContext().objectPatternValidatorType = patternValidatorType;
2036                  ISchemaValidator**& va = CurrentContext().patternPropertiesValidators;
2037                  SizeType& validatorCount = CurrentContext().patternPropertiesValidatorCount;
2038                  va = static_cast<ISchemaValidator**>(MallocState(sizeof(ISchemaValidator*) * count));
2039                  for (SizeType i = 0; i < count; i++)
2040                      va[validatorCount++] = CreateSchemaValidator(*sa[i], true);  
2041              }
2042              CurrentContext().arrayUniqueness = valueUniqueness;
2043          }
2044          return true;
2045      }
2046      bool EndValue() {
2047          if (!CurrentSchema().EndValue(CurrentContext()) && !GetContinueOnErrors())
2048              return false;
2049  #if RAPIDJSON_SCHEMA_VERBOSE
2050          GenericStringBuffer<EncodingType> sb;
2051          schemaDocument_->GetPointer(&CurrentSchema()).Stringify(sb);
2052          *documentStack_.template Push<Ch>() = '\0';
2053          documentStack_.template Pop<Ch>(1);
2054          internal::PrintValidatorPointers(depth_, sb.GetString(), documentStack_.template Bottom<Ch>());
2055  #endif
2056          void* hasher = CurrentContext().hasher;
2057          uint64_t h = hasher && CurrentContext().arrayUniqueness ? static_cast<HasherType*>(hasher)->GetHashCode() : 0;
2058          PopSchema();
2059          if (!schemaStack_.Empty()) {
2060              Context& context = CurrentContext();
2061              if (hasher && context.valueUniqueness) {
2062                  HashCodeArray* a = static_cast<HashCodeArray*>(context.arrayElementHashCodes);
2063                  if (!a)
2064                      CurrentContext().arrayElementHashCodes = a = new (GetStateAllocator().Malloc(sizeof(HashCodeArray))) HashCodeArray(kArrayType);
2065                  for (typename HashCodeArray::ConstValueIterator itr = a->Begin(); itr != a->End(); ++itr)
2066                      if (itr->GetUint64() == h) {
2067                          DuplicateItems(static_cast<SizeType>(itr - a->Begin()), a->Size());
2068                          if (GetContinueOnErrors()) {
2069                              a->PushBack(h, GetStateAllocator());
2070                              while (!documentStack_.Empty() && *documentStack_.template Pop<Ch>(1) != '/');
2071                          }
2072                          RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorUniqueItems);
2073                      }
2074                  a->PushBack(h, GetStateAllocator());
2075              }
2076          }
2077          while (!documentStack_.Empty() && *documentStack_.template Pop<Ch>(1) != '/')
2078              ;
2079          return true;
2080      }
2081      void AppendToken(const Ch* str, SizeType len) {
2082          documentStack_.template Reserve<Ch>(1 + len * 2); 
2083          *documentStack_.template PushUnsafe<Ch>() = '/';
2084          for (SizeType i = 0; i < len; i++) {
2085              if (str[i] == '~') {
2086                  *documentStack_.template PushUnsafe<Ch>() = '~';
2087                  *documentStack_.template PushUnsafe<Ch>() = '0';
2088              }
2089              else if (str[i] == '/') {
2090                  *documentStack_.template PushUnsafe<Ch>() = '~';
2091                  *documentStack_.template PushUnsafe<Ch>() = '1';
2092              }
2093              else
2094                  *documentStack_.template PushUnsafe<Ch>() = str[i];
2095          }
2096      }
2097      RAPIDJSON_FORCEINLINE void PushSchema(const SchemaType& schema) { new (schemaStack_.template Push<Context>()) Context(*this, *this, &schema); }
2098      RAPIDJSON_FORCEINLINE void PopSchema() {
2099          Context* c = schemaStack_.template Pop<Context>(1);
2100          if (HashCodeArray* a = static_cast<HashCodeArray*>(c->arrayElementHashCodes)) {
2101              a->~HashCodeArray();
2102              StateAllocator::Free(a);
2103          }
2104          c->~Context();
2105      }
2106      void AddErrorInstanceLocation(ValueType& result, bool parent) {
2107          GenericStringBuffer<EncodingType> sb;
2108          PointerType instancePointer = GetInvalidDocumentPointer();
2109          ((parent && instancePointer.GetTokenCount() > 0)
2110           ? PointerType(instancePointer.GetTokens(), instancePointer.GetTokenCount() - 1)
2111           : instancePointer).StringifyUriFragment(sb);
2112          ValueType instanceRef(sb.GetString(), static_cast<SizeType>(sb.GetSize() / sizeof(Ch)),
2113                                GetStateAllocator());
2114          result.AddMember(GetInstanceRefString(), instanceRef, GetStateAllocator());
2115      }
2116      void AddErrorSchemaLocation(ValueType& result, PointerType schema = PointerType()) {
2117          GenericStringBuffer<EncodingType> sb;
2118          SizeType len = CurrentSchema().GetURI().GetStringLength();
2119          if (len) memcpy(sb.Push(len), CurrentSchema().GetURI().GetString(), len * sizeof(Ch));
2120          if (schema.GetTokenCount()) schema.StringifyUriFragment(sb);
2121          else GetInvalidSchemaPointer().StringifyUriFragment(sb);
2122          ValueType schemaRef(sb.GetString(), static_cast<SizeType>(sb.GetSize() / sizeof(Ch)),
2123              GetStateAllocator());
2124          result.AddMember(GetSchemaRefString(), schemaRef, GetStateAllocator());
2125      }
2126      void AddErrorCode(ValueType& result, const ValidateErrorCode code) {
2127          result.AddMember(GetErrorCodeString(), code, GetStateAllocator());
2128      }
2129      void AddError(ValueType& keyword, ValueType& error) {
2130          typename ValueType::MemberIterator member = error_.FindMember(keyword);
2131          if (member == error_.MemberEnd())
2132              error_.AddMember(keyword, error, GetStateAllocator());
2133          else {
2134              if (member->value.IsObject()) {
2135                  ValueType errors(kArrayType);
2136                  errors.PushBack(member->value, GetStateAllocator());
2137                  member->value = errors;
2138              }
2139              member->value.PushBack(error, GetStateAllocator());
2140          }
2141      }
2142      void AddCurrentError(const ValidateErrorCode code, bool parent = false) {
2143          AddErrorCode(currentError_, code);
2144          AddErrorInstanceLocation(currentError_, parent);
2145          AddErrorSchemaLocation(currentError_);
2146          AddError(ValueType(SchemaType::GetValidateErrorKeyword(code), GetStateAllocator(), false).Move(), currentError_);
2147      }
2148      void MergeError(ValueType& other) {
2149          for (typename ValueType::MemberIterator it = other.MemberBegin(), end = other.MemberEnd(); it != end; ++it) {
2150              AddError(it->name, it->value);
2151          }
2152      }
2153      void AddNumberError(const ValidateErrorCode code, ValueType& actual, const SValue& expected,
2154          const typename SchemaType::ValueType& (*exclusive)() = 0) {
2155          currentError_.SetObject();
2156          currentError_.AddMember(GetActualString(), actual, GetStateAllocator());
2157          currentError_.AddMember(GetExpectedString(), ValueType(expected, GetStateAllocator()).Move(), GetStateAllocator());
2158          if (exclusive)
2159              currentError_.AddMember(ValueType(exclusive(), GetStateAllocator()).Move(), true, GetStateAllocator());
2160          AddCurrentError(code);
2161      }
2162      void AddErrorArray(const ValidateErrorCode code,
2163          ISchemaValidator** subvalidators, SizeType count) {
2164          ValueType errors(kArrayType);
2165          for (SizeType i = 0; i < count; ++i)
2166              errors.PushBack(static_cast<GenericSchemaValidator*>(subvalidators[i])->GetError(), GetStateAllocator());
2167          currentError_.SetObject();
2168          currentError_.AddMember(GetErrorsString(), errors, GetStateAllocator());
2169          AddCurrentError(code);
2170      }
2171      const SchemaType& CurrentSchema() const { return *schemaStack_.template Top<Context>()->schema; }
2172      Context& CurrentContext() { return *schemaStack_.template Top<Context>(); }
2173      const Context& CurrentContext() const { return *schemaStack_.template Top<Context>(); }
2174      static const size_t kDefaultSchemaStackCapacity = 1024;
2175      static const size_t kDefaultDocumentStackCapacity = 256;
2176      const SchemaDocumentType* schemaDocument_;
2177      const SchemaType& root_;
2178      StateAllocator* stateAllocator_;
2179      StateAllocator* ownStateAllocator_;
2180      internal::Stack<StateAllocator> schemaStack_;    
2181      internal::Stack<StateAllocator> documentStack_;  
2182      OutputHandler* outputHandler_;
2183      ValueType error_;
2184      ValueType currentError_;
2185      ValueType missingDependents_;
2186      bool valid_;
2187      unsigned flags_;
2188  #if RAPIDJSON_SCHEMA_VERBOSE
2189      unsigned depth_;
2190  #endif
2191  };
2192  typedef GenericSchemaValidator<SchemaDocument> SchemaValidator;
2193  template <
2194      unsigned parseFlags,
2195      typename InputStream,
2196      typename SourceEncoding,
2197      typename SchemaDocumentType = SchemaDocument,
2198      typename StackAllocator = CrtAllocator>
2199  class SchemaValidatingReader {
2200  public:
2201      typedef typename SchemaDocumentType::PointerType PointerType;
2202      typedef typename InputStream::Ch Ch;
2203      typedef GenericValue<SourceEncoding, StackAllocator> ValueType;
2204      SchemaValidatingReader(InputStream& is, const SchemaDocumentType& sd) : is_(is), sd_(sd), invalidSchemaKeyword_(), invalidSchemaCode_(kValidateErrorNone), error_(kObjectType), isValid_(true) {}
2205      template <typename Handler>
2206      bool operator()(Handler& handler) {
2207          GenericReader<SourceEncoding, typename SchemaDocumentType::EncodingType, StackAllocator> reader;
2208          GenericSchemaValidator<SchemaDocumentType, Handler> validator(sd_, handler);
2209          parseResult_ = reader.template Parse<parseFlags>(is_, validator);
2210          isValid_ = validator.IsValid();
2211          if (isValid_) {
2212              invalidSchemaPointer_ = PointerType();
2213              invalidSchemaKeyword_ = 0;
2214              invalidDocumentPointer_ = PointerType();
2215              error_.SetObject();
2216          }
2217          else {
2218              invalidSchemaPointer_ = validator.GetInvalidSchemaPointer();
2219              invalidSchemaKeyword_ = validator.GetInvalidSchemaKeyword();
2220              invalidSchemaCode_ = validator.GetInvalidSchemaCode();
2221              invalidDocumentPointer_ = validator.GetInvalidDocumentPointer();
2222              error_.CopyFrom(validator.GetError(), allocator_);
2223          }
2224          return parseResult_;
2225      }
2226      const ParseResult& GetParseResult() const { return parseResult_; }
2227      bool IsValid() const { return isValid_; }
2228      const PointerType& GetInvalidSchemaPointer() const { return invalidSchemaPointer_; }
2229      const Ch* GetInvalidSchemaKeyword() const { return invalidSchemaKeyword_; }
2230      const PointerType& GetInvalidDocumentPointer() const { return invalidDocumentPointer_; }
2231      const ValueType& GetError() const { return error_; }
2232      ValidateErrorCode GetInvalidSchemaCode() const { return invalidSchemaCode_; }
2233  private:
2234      InputStream& is_;
2235      const SchemaDocumentType& sd_;
2236      ParseResult parseResult_;
2237      PointerType invalidSchemaPointer_;
2238      const Ch* invalidSchemaKeyword_;
2239      PointerType invalidDocumentPointer_;
2240      ValidateErrorCode invalidSchemaCode_;
2241      StackAllocator allocator_;
2242      ValueType error_;
2243      bool isValid_;
2244  };
2245  RAPIDJSON_NAMESPACE_END
2246  RAPIDJSON_DIAG_POP
2247  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-schema.h</h3>
            <pre><code>1  #ifndef RAPIDJSON_SCHEMA_H_
2  #define RAPIDJSON_SCHEMA_H_
3  #include "document.h"
4  #include "pointer.h"
5  #include "stringbuffer.h"
6  #include "error/en.h"
7  #include "uri.h"
8  #include <cmath> 
9  #if !defined(RAPIDJSON_SCHEMA_USE_INTERNALREGEX)
10  #define RAPIDJSON_SCHEMA_USE_INTERNALREGEX 1
11  #else
12  #define RAPIDJSON_SCHEMA_USE_INTERNALREGEX 0
13  #endif
14  #if !RAPIDJSON_SCHEMA_USE_INTERNALREGEX && defined(RAPIDJSON_SCHEMA_USE_STDREGEX) && (__cplusplus >=201103L || (defined(_MSC_VER) && _MSC_VER >= 1800))
15  #define RAPIDJSON_SCHEMA_USE_STDREGEX 1
16  #else
17  #define RAPIDJSON_SCHEMA_USE_STDREGEX 0
18  #endif
19  #if RAPIDJSON_SCHEMA_USE_INTERNALREGEX
20  #include "internal/regex.h"
21  #elif RAPIDJSON_SCHEMA_USE_STDREGEX
22  #include <regex>
23  #endif
24  #if RAPIDJSON_SCHEMA_USE_INTERNALREGEX || RAPIDJSON_SCHEMA_USE_STDREGEX
25  #define RAPIDJSON_SCHEMA_HAS_REGEX 1
26  #else
27  #define RAPIDJSON_SCHEMA_HAS_REGEX 0
28  #endif
29  #ifndef RAPIDJSON_SCHEMA_VERBOSE
30  #define RAPIDJSON_SCHEMA_VERBOSE 0
31  #endif
32  #if RAPIDJSON_SCHEMA_VERBOSE
33  #include "stringbuffer.h"
34  #endif
35  RAPIDJSON_DIAG_PUSH
36  #if defined(__GNUC__)
37  RAPIDJSON_DIAG_OFF(effc++)
38  #endif
39  #ifdef __clang__
40  RAPIDJSON_DIAG_OFF(weak-vtables)
41  RAPIDJSON_DIAG_OFF(exit-time-destructors)
42  RAPIDJSON_DIAG_OFF(c++98-compat-pedantic)
43  RAPIDJSON_DIAG_OFF(variadic-macros)
44  #elif defined(_MSC_VER)
45  RAPIDJSON_DIAG_OFF(4512) 
46  #endif
47  RAPIDJSON_NAMESPACE_BEGIN
48  #if RAPIDJSON_SCHEMA_VERBOSE
49  namespace internal {
50  inline void PrintInvalidKeyword(const char* keyword) {
51      printf("Fail keyword: %s\n", keyword);
52  }
53  inline void PrintInvalidKeyword(const wchar_t* keyword) {
54      wprintf(L"Fail keyword: %ls\n", keyword);
55  }
56  inline void PrintInvalidDocument(const char* document) {
57      printf("Fail document: %s\n\n", document);
58  }
59  inline void PrintInvalidDocument(const wchar_t* document) {
60      wprintf(L"Fail document: %ls\n\n", document);
61  }
62  inline void PrintValidatorPointers(unsigned depth, const char* s, const char* d) {
63      printf("S: %*s%s\nD: %*s%s\n\n", depth * 4, " ", s, depth * 4, " ", d);
64  }
65  inline void PrintValidatorPointers(unsigned depth, const wchar_t* s, const wchar_t* d) {
66      wprintf(L"S: %*ls%ls\nD: %*ls%ls\n\n", depth * 4, L" ", s, depth * 4, L" ", d);
67  }
68  } 
69  #endif 
70  #if RAPIDJSON_SCHEMA_VERBOSE
71  #define RAPIDJSON_INVALID_KEYWORD_VERBOSE(keyword) internal::PrintInvalidKeyword(keyword)
72  #else
73  #define RAPIDJSON_INVALID_KEYWORD_VERBOSE(keyword)
74  #endif
75  #define RAPIDJSON_INVALID_KEYWORD_RETURN(code)\
76  RAPIDJSON_MULTILINEMACRO_BEGIN\
77      context.invalidCode = code;\
78      context.invalidKeyword = SchemaType::GetValidateErrorKeyword(code).GetString();\
79      RAPIDJSON_INVALID_KEYWORD_VERBOSE(context.invalidKeyword);\
80      return false;\
81  RAPIDJSON_MULTILINEMACRO_END
82  #ifndef RAPIDJSON_VALIDATE_DEFAULT_FLAGS
83  #define RAPIDJSON_VALIDATE_DEFAULT_FLAGS kValidateNoFlags
84  #endif
85  enum ValidateFlag {
86      kValidateNoFlags = 0,                                       
87      kValidateContinueOnErrorFlag = 1,                           
88      kValidateDefaultFlags = RAPIDJSON_VALIDATE_DEFAULT_FLAGS    
89  };
90  template <typename ValueType, typename Allocator>
91  class GenericSchemaDocument;
92  namespace internal {
93  template <typename SchemaDocumentType>
94  class Schema;
95  class ISchemaValidator {
96  public:
97      virtual ~ISchemaValidator() {}
98      virtual bool IsValid() const = 0;
99      virtual void SetValidateFlags(unsigned flags) = 0;
100      virtual unsigned GetValidateFlags() const = 0;
101  };
102  template <typename SchemaType>
103  class ISchemaStateFactory {
104  public:
105      virtual ~ISchemaStateFactory() {}
106      virtual ISchemaValidator* CreateSchemaValidator(const SchemaType&, const bool inheritContinueOnErrors) = 0;
107      virtual void DestroySchemaValidator(ISchemaValidator* validator) = 0;
108      virtual void* CreateHasher() = 0;
109      virtual uint64_t GetHashCode(void* hasher) = 0;
110      virtual void DestroryHasher(void* hasher) = 0;
111      virtual void* MallocState(size_t size) = 0;
112      virtual void FreeState(void* p) = 0;
113  };
114  template <typename SchemaType>
115  class IValidationErrorHandler {
116  public:
117      typedef typename SchemaType::Ch Ch;
118      typedef typename SchemaType::SValue SValue;
119      virtual ~IValidationErrorHandler() {}
120      virtual void NotMultipleOf(int64_t actual, const SValue& expected) = 0;
121      virtual void NotMultipleOf(uint64_t actual, const SValue& expected) = 0;
122      virtual void NotMultipleOf(double actual, const SValue& expected) = 0;
123      virtual void AboveMaximum(int64_t actual, const SValue& expected, bool exclusive) = 0;
124      virtual void AboveMaximum(uint64_t actual, const SValue& expected, bool exclusive) = 0;
125      virtual void AboveMaximum(double actual, const SValue& expected, bool exclusive) = 0;
126      virtual void BelowMinimum(int64_t actual, const SValue& expected, bool exclusive) = 0;
127      virtual void BelowMinimum(uint64_t actual, const SValue& expected, bool exclusive) = 0;
128      virtual void BelowMinimum(double actual, const SValue& expected, bool exclusive) = 0;
129      virtual void TooLong(const Ch* str, SizeType length, SizeType expected) = 0;
130      virtual void TooShort(const Ch* str, SizeType length, SizeType expected) = 0;
131      virtual void DoesNotMatch(const Ch* str, SizeType length) = 0;
132      virtual void DisallowedItem(SizeType index) = 0;
133      virtual void TooFewItems(SizeType actualCount, SizeType expectedCount) = 0;
134      virtual void TooManyItems(SizeType actualCount, SizeType expectedCount) = 0;
135      virtual void DuplicateItems(SizeType index1, SizeType index2) = 0;
136      virtual void TooManyProperties(SizeType actualCount, SizeType expectedCount) = 0;
137      virtual void TooFewProperties(SizeType actualCount, SizeType expectedCount) = 0;
138      virtual void StartMissingProperties() = 0;
139      virtual void AddMissingProperty(const SValue& name) = 0;
140      virtual bool EndMissingProperties() = 0;
141      virtual void PropertyViolations(ISchemaValidator** subvalidators, SizeType count) = 0;
142      virtual void DisallowedProperty(const Ch* name, SizeType length) = 0;
143      virtual void StartDependencyErrors() = 0;
144      virtual void StartMissingDependentProperties() = 0;
145      virtual void AddMissingDependentProperty(const SValue& targetName) = 0;
146      virtual void EndMissingDependentProperties(const SValue& sourceName) = 0;
147      virtual void AddDependencySchemaError(const SValue& souceName, ISchemaValidator* subvalidator) = 0;
148      virtual bool EndDependencyErrors() = 0;
149      virtual void DisallowedValue(const ValidateErrorCode code) = 0;
150      virtual void StartDisallowedType() = 0;
151      virtual void AddExpectedType(const typename SchemaType::ValueType& expectedType) = 0;
152      virtual void EndDisallowedType(const typename SchemaType::ValueType& actualType) = 0;
153      virtual void NotAllOf(ISchemaValidator** subvalidators, SizeType count) = 0;
154      virtual void NoneOf(ISchemaValidator** subvalidators, SizeType count) = 0;
155      virtual void NotOneOf(ISchemaValidator** subvalidators, SizeType count, bool matched) = 0;
156      virtual void Disallowed() = 0;
157  };
158  template<typename Encoding, typename Allocator>
159  class Hasher {
160  public:
161      typedef typename Encoding::Ch Ch;
162      Hasher(Allocator* allocator = 0, size_t stackCapacity = kDefaultSize) : stack_(allocator, stackCapacity) {}
163      bool Null() { return WriteType(kNullType); }
164      bool Bool(bool b) { return WriteType(b ? kTrueType : kFalseType); }
165      bool Int(int i) { Number n; n.u.i = i; n.d = static_cast<double>(i); return WriteNumber(n); }
166      bool Uint(unsigned u) { Number n; n.u.u = u; n.d = static_cast<double>(u); return WriteNumber(n); }
167      bool Int64(int64_t i) { Number n; n.u.i = i; n.d = static_cast<double>(i); return WriteNumber(n); }
168      bool Uint64(uint64_t u) { Number n; n.u.u = u; n.d = static_cast<double>(u); return WriteNumber(n); }
169      bool Double(double d) {
170          Number n;
171          if (d < 0) n.u.i = static_cast<int64_t>(d);
172          else       n.u.u = static_cast<uint64_t>(d);
173          n.d = d;
174          return WriteNumber(n);
175      }
176      bool RawNumber(const Ch* str, SizeType len, bool) {
177          WriteBuffer(kNumberType, str, len * sizeof(Ch));
178          return true;
179      }
180      bool String(const Ch* str, SizeType len, bool) {
181          WriteBuffer(kStringType, str, len * sizeof(Ch));
182          return true;
183      }
184      bool StartObject() { return true; }
185      bool Key(const Ch* str, SizeType len, bool copy) { return String(str, len, copy); }
186      bool EndObject(SizeType memberCount) {
187          uint64_t h = Hash(0, kObjectType);
188          uint64_t* kv = stack_.template Pop<uint64_t>(memberCount * 2);
189          for (SizeType i = 0; i < memberCount; i++)
190              h ^= Hash(kv[i * 2], kv[i * 2 + 1]);  
191          *stack_.template Push<uint64_t>() = h;
192          return true;
193      }
194      bool StartArray() { return true; }
195      bool EndArray(SizeType elementCount) {
196          uint64_t h = Hash(0, kArrayType);
197          uint64_t* e = stack_.template Pop<uint64_t>(elementCount);
198          for (SizeType i = 0; i < elementCount; i++)
199              h = Hash(h, e[i]); 
200          *stack_.template Push<uint64_t>() = h;
201          return true;
202      }
203      bool IsValid() const { return stack_.GetSize() == sizeof(uint64_t); }
204      uint64_t GetHashCode() const {
205          RAPIDJSON_ASSERT(IsValid());
206          return *stack_.template Top<uint64_t>();
207      }
208  private:
209      static const size_t kDefaultSize = 256;
210      struct Number {
211          union U {
212              uint64_t u;
213              int64_t i;
214          }u;
215          double d;
216      };
217      bool WriteType(Type type) { return WriteBuffer(type, 0, 0); }
218      bool WriteNumber(const Number& n) { return WriteBuffer(kNumberType, &n, sizeof(n)); }
219      bool WriteBuffer(Type type, const void* data, size_t len) {
220          uint64_t h = Hash(RAPIDJSON_UINT64_C2(0x84222325, 0xcbf29ce4), type);
221          const unsigned char* d = static_cast<const unsigned char*>(data);
222          for (size_t i = 0; i < len; i++)
223              h = Hash(h, d[i]);
224          *stack_.template Push<uint64_t>() = h;
225          return true;
226      }
227      static uint64_t Hash(uint64_t h, uint64_t d) {
228          static const uint64_t kPrime = RAPIDJSON_UINT64_C2(0x00000100, 0x000001b3);
229          h ^= d;
230          h *= kPrime;
231          return h;
232      }
233      Stack<Allocator> stack_;
234  };
235  template <typename SchemaDocumentType>
236  struct SchemaValidationContext {
237      typedef Schema<SchemaDocumentType> SchemaType;
238      typedef ISchemaStateFactory<SchemaType> SchemaValidatorFactoryType;
239      typedef IValidationErrorHandler<SchemaType> ErrorHandlerType;
240      typedef typename SchemaType::ValueType ValueType;
241      typedef typename ValueType::Ch Ch;
242      enum PatternValidatorType {
243          kPatternValidatorOnly,
244          kPatternValidatorWithProperty,
245          kPatternValidatorWithAdditionalProperty
246      };
247      SchemaValidationContext(SchemaValidatorFactoryType& f, ErrorHandlerType& eh, const SchemaType* s) :
248          factory(f),
249          error_handler(eh),
250          schema(s),
251          valueSchema(),
252          invalidKeyword(),
253          invalidCode(),
254          hasher(),
255          arrayElementHashCodes(),
256          validators(),
257          validatorCount(),
258          patternPropertiesValidators(),
259          patternPropertiesValidatorCount(),
260          patternPropertiesSchemas(),
261          patternPropertiesSchemaCount(),
262          valuePatternValidatorType(kPatternValidatorOnly),
263          propertyExist(),
264          inArray(false),
265          valueUniqueness(false),
266          arrayUniqueness(false)
267      {
268      }
269      ~SchemaValidationContext() {
270          if (hasher)
271              factory.DestroryHasher(hasher);
272          if (validators) {
273              for (SizeType i = 0; i < validatorCount; i++)
274                  factory.DestroySchemaValidator(validators[i]);
275              factory.FreeState(validators);
276          }
277          if (patternPropertiesValidators) {
278              for (SizeType i = 0; i < patternPropertiesValidatorCount; i++)
279                  factory.DestroySchemaValidator(patternPropertiesValidators[i]);
280              factory.FreeState(patternPropertiesValidators);
281          }
282          if (patternPropertiesSchemas)
283              factory.FreeState(patternPropertiesSchemas);
284          if (propertyExist)
285              factory.FreeState(propertyExist);
286      }
287      SchemaValidatorFactoryType& factory;
288      ErrorHandlerType& error_handler;
289      const SchemaType* schema;
290      const SchemaType* valueSchema;
291      const Ch* invalidKeyword;
292      ValidateErrorCode invalidCode;
293      void* hasher; 
294      void* arrayElementHashCodes; 
295      ISchemaValidator** validators;
296      SizeType validatorCount;
297      ISchemaValidator** patternPropertiesValidators;
298      SizeType patternPropertiesValidatorCount;
299      const SchemaType** patternPropertiesSchemas;
300      SizeType patternPropertiesSchemaCount;
301      PatternValidatorType valuePatternValidatorType;
302      PatternValidatorType objectPatternValidatorType;
303      SizeType arrayElementIndex;
304      bool* propertyExist;
305      bool inArray;
306      bool valueUniqueness;
307      bool arrayUniqueness;
308  };
309  template <typename SchemaDocumentType>
310  class Schema {
311  public:
312      typedef typename SchemaDocumentType::ValueType ValueType;
313      typedef typename SchemaDocumentType::AllocatorType AllocatorType;
314      typedef typename SchemaDocumentType::PointerType PointerType;
315      typedef typename ValueType::EncodingType EncodingType;
316      typedef typename EncodingType::Ch Ch;
317      typedef SchemaValidationContext<SchemaDocumentType> Context;
318      typedef Schema<SchemaDocumentType> SchemaType;
319      typedef GenericValue<EncodingType, AllocatorType> SValue;
320      typedef IValidationErrorHandler<Schema> ErrorHandler;
321      typedef GenericUri<ValueType, AllocatorType> UriType;
322      friend class GenericSchemaDocument<ValueType, AllocatorType>;
323      Schema(SchemaDocumentType* schemaDocument, const PointerType& p, const ValueType& value, const ValueType& document, AllocatorType* allocator, const UriType& id = UriType()) :
324          allocator_(allocator),
325          uri_(schemaDocument->GetURI(), *allocator),
326          id_(id),
327          pointer_(p, allocator),
328          typeless_(schemaDocument->GetTypeless()),
329          enum_(),
330          enumCount_(),
331          not_(),
332          type_((1 << kTotalSchemaType) - 1), 
333          validatorCount_(),
334          notValidatorIndex_(),
335          properties_(),
336          additionalPropertiesSchema_(),
337          patternProperties_(),
338          patternPropertyCount_(),
339          propertyCount_(),
340          minProperties_(),
341          maxProperties_(SizeType(~0)),
342          additionalProperties_(true),
343          hasDependencies_(),
344          hasRequired_(),
345          hasSchemaDependencies_(),
346          additionalItemsSchema_(),
347          itemsList_(),
348          itemsTuple_(),
349          itemsTupleCount_(),
350          minItems_(),
351          maxItems_(SizeType(~0)),
352          additionalItems_(true),
353          uniqueItems_(false),
354          pattern_(),
355          minLength_(0),
356          maxLength_(~SizeType(0)),
357          exclusiveMinimum_(false),
358          exclusiveMaximum_(false),
359          defaultValueLength_(0)
360      {
361          typedef typename ValueType::ConstValueIterator ConstValueIterator;
362          typedef typename ValueType::ConstMemberIterator ConstMemberIterator;
363          if (this != typeless_) {
364            typedef typename SchemaDocumentType::SchemaEntry SchemaEntry;
365            SchemaEntry *entry = schemaDocument->schemaMap_.template Push<SchemaEntry>();
366            new (entry) SchemaEntry(pointer_, this, true, allocator_);
367            schemaDocument->AddSchemaRefs(this);
368          }
369          if (!value.IsObject())
370              return;
371          if (const ValueType* v = GetMember(value, GetIdString())) {
372              if (v->IsString()) {
373                  UriType local(*v, allocator);
374                  id_ = local.Resolve(id_, allocator);
375              }
376          }
377          if (const ValueType* v = GetMember(value, GetTypeString())) {
378              type_ = 0;
379              if (v->IsString())
380                  AddType(*v);
381              else if (v->IsArray())
382                  for (ConstValueIterator itr = v->Begin(); itr != v->End(); ++itr)
383                      AddType(*itr);
384          }
385          if (const ValueType* v = GetMember(value, GetEnumString())) {
386              if (v->IsArray() && v->Size() > 0) {
387                  enum_ = static_cast<uint64_t*>(allocator_->Malloc(sizeof(uint64_t) * v->Size()));
388                  for (ConstValueIterator itr = v->Begin(); itr != v->End(); ++itr) {
389                      typedef Hasher<EncodingType, MemoryPoolAllocator<> > EnumHasherType;
390                      char buffer[256u + 24];
391                      MemoryPoolAllocator<> hasherAllocator(buffer, sizeof(buffer));
392                      EnumHasherType h(&hasherAllocator, 256);
393                      itr->Accept(h);
394                      enum_[enumCount_++] = h.GetHashCode();
395                  }
396              }
397          }
398          if (schemaDocument) {
399              AssignIfExist(allOf_, *schemaDocument, p, value, GetAllOfString(), document);
400              AssignIfExist(anyOf_, *schemaDocument, p, value, GetAnyOfString(), document);
401              AssignIfExist(oneOf_, *schemaDocument, p, value, GetOneOfString(), document);
402              if (const ValueType* v = GetMember(value, GetNotString())) {
403                  schemaDocument->CreateSchema(&not_, p.Append(GetNotString(), allocator_), *v, document, id_);
404                  notValidatorIndex_ = validatorCount_;
405                  validatorCount_++;
406              }
407          }
408          const ValueType* properties = GetMember(value, GetPropertiesString());
409          const ValueType* required = GetMember(value, GetRequiredString());
410          const ValueType* dependencies = GetMember(value, GetDependenciesString());
411          {
412              SValue allProperties(kArrayType);
413              if (properties && properties->IsObject())
414                  for (ConstMemberIterator itr = properties->MemberBegin(); itr != properties->MemberEnd(); ++itr)
415                      AddUniqueElement(allProperties, itr->name);
416              if (required && required->IsArray())
417                  for (ConstValueIterator itr = required->Begin(); itr != required->End(); ++itr)
418                      if (itr->IsString())
419                          AddUniqueElement(allProperties, *itr);
420              if (dependencies && dependencies->IsObject())
421                  for (ConstMemberIterator itr = dependencies->MemberBegin(); itr != dependencies->MemberEnd(); ++itr) {
422                      AddUniqueElement(allProperties, itr->name);
423                      if (itr->value.IsArray())
424                          for (ConstValueIterator i = itr->value.Begin(); i != itr->value.End(); ++i)
425                              if (i->IsString())
426                                  AddUniqueElement(allProperties, *i);
427                  }
428              if (allProperties.Size() > 0) {
429                  propertyCount_ = allProperties.Size();
430                  properties_ = static_cast<Property*>(allocator_->Malloc(sizeof(Property) * propertyCount_));
431                  for (SizeType i = 0; i < propertyCount_; i++) {
432                      new (&properties_[i]) Property();
433                      properties_[i].name = allProperties[i];
434                      properties_[i].schema = typeless_;
435                  }
436              }
437          }
438          if (properties && properties->IsObject()) {
439              PointerType q = p.Append(GetPropertiesString(), allocator_);
440              for (ConstMemberIterator itr = properties->MemberBegin(); itr != properties->MemberEnd(); ++itr) {
441                  SizeType index;
442                  if (FindPropertyIndex(itr->name, &index))
443                      schemaDocument->CreateSchema(&properties_[index].schema, q.Append(itr->name, allocator_), itr->value, document, id_);
444              }
445          }
446          if (const ValueType* v = GetMember(value, GetPatternPropertiesString())) {
447              PointerType q = p.Append(GetPatternPropertiesString(), allocator_);
448              patternProperties_ = static_cast<PatternProperty*>(allocator_->Malloc(sizeof(PatternProperty) * v->MemberCount()));
449              patternPropertyCount_ = 0;
450              for (ConstMemberIterator itr = v->MemberBegin(); itr != v->MemberEnd(); ++itr) {
451                  new (&patternProperties_[patternPropertyCount_]) PatternProperty();
452                  patternProperties_[patternPropertyCount_].pattern = CreatePattern(itr->name);
453                  schemaDocument->CreateSchema(&patternProperties_[patternPropertyCount_].schema, q.Append(itr->name, allocator_), itr->value, document, id_);
454                  patternPropertyCount_++;
455              }
456          }
457          if (required && required->IsArray())
458              for (ConstValueIterator itr = required->Begin(); itr != required->End(); ++itr)
459                  if (itr->IsString()) {
460                      SizeType index;
461                      if (FindPropertyIndex(*itr, &index)) {
462                          properties_[index].required = true;
463                          hasRequired_ = true;
464                      }
465                  }
466          if (dependencies && dependencies->IsObject()) {
467              PointerType q = p.Append(GetDependenciesString(), allocator_);
468              hasDependencies_ = true;
469              for (ConstMemberIterator itr = dependencies->MemberBegin(); itr != dependencies->MemberEnd(); ++itr) {
470                  SizeType sourceIndex;
471                  if (FindPropertyIndex(itr->name, &sourceIndex)) {
472                      if (itr->value.IsArray()) {
473                          properties_[sourceIndex].dependencies = static_cast<bool*>(allocator_->Malloc(sizeof(bool) * propertyCount_));
474                          std::memset(properties_[sourceIndex].dependencies, 0, sizeof(bool)* propertyCount_);
475                          for (ConstValueIterator targetItr = itr->value.Begin(); targetItr != itr->value.End(); ++targetItr) {
476                              SizeType targetIndex;
477                              if (FindPropertyIndex(*targetItr, &targetIndex))
478                                  properties_[sourceIndex].dependencies[targetIndex] = true;
479                          }
480                      }
481                      else if (itr->value.IsObject()) {
482                          hasSchemaDependencies_ = true;
483                          schemaDocument->CreateSchema(&properties_[sourceIndex].dependenciesSchema, q.Append(itr->name, allocator_), itr->value, document, id_);
484                          properties_[sourceIndex].dependenciesValidatorIndex = validatorCount_;
485                          validatorCount_++;
486                      }
487                  }
488              }
489          }
490          if (const ValueType* v = GetMember(value, GetAdditionalPropertiesString())) {
491              if (v->IsBool())
492                  additionalProperties_ = v->GetBool();
493              else if (v->IsObject())
494                  schemaDocument->CreateSchema(&additionalPropertiesSchema_, p.Append(GetAdditionalPropertiesString(), allocator_), *v, document, id_);
495          }
496          AssignIfExist(minProperties_, value, GetMinPropertiesString());
497          AssignIfExist(maxProperties_, value, GetMaxPropertiesString());
498          if (const ValueType* v = GetMember(value, GetItemsString())) {
499              PointerType q = p.Append(GetItemsString(), allocator_);
500              if (v->IsObject()) 
501                  schemaDocument->CreateSchema(&itemsList_, q, *v, document, id_);
502              else if (v->IsArray()) { 
503                  itemsTuple_ = static_cast<const Schema**>(allocator_->Malloc(sizeof(const Schema*) * v->Size()));
504                  SizeType index = 0;
505                  for (ConstValueIterator itr = v->Begin(); itr != v->End(); ++itr, index++)
506                      schemaDocument->CreateSchema(&itemsTuple_[itemsTupleCount_++], q.Append(index, allocator_), *itr, document, id_);
507              }
508          }
509          AssignIfExist(minItems_, value, GetMinItemsString());
510          AssignIfExist(maxItems_, value, GetMaxItemsString());
511          if (const ValueType* v = GetMember(value, GetAdditionalItemsString())) {
512              if (v->IsBool())
513                  additionalItems_ = v->GetBool();
514              else if (v->IsObject())
515                  schemaDocument->CreateSchema(&additionalItemsSchema_, p.Append(GetAdditionalItemsString(), allocator_), *v, document, id_);
516          }
517          AssignIfExist(uniqueItems_, value, GetUniqueItemsString());
518          AssignIfExist(minLength_, value, GetMinLengthString());
519          AssignIfExist(maxLength_, value, GetMaxLengthString());
520          if (const ValueType* v = GetMember(value, GetPatternString()))
521              pattern_ = CreatePattern(*v);
522          if (const ValueType* v = GetMember(value, GetMinimumString()))
523              if (v->IsNumber())
524                  minimum_.CopyFrom(*v, *allocator_);
525          if (const ValueType* v = GetMember(value, GetMaximumString()))
526              if (v->IsNumber())
527                  maximum_.CopyFrom(*v, *allocator_);
528          AssignIfExist(exclusiveMinimum_, value, GetExclusiveMinimumString());
529          AssignIfExist(exclusiveMaximum_, value, GetExclusiveMaximumString());
530          if (const ValueType* v = GetMember(value, GetMultipleOfString()))
531              if (v->IsNumber() && v->GetDouble() > 0.0)
532                  multipleOf_.CopyFrom(*v, *allocator_);
533          if (const ValueType* v = GetMember(value, GetDefaultValueString()))
534              if (v->IsString())
535                  defaultValueLength_ = v->GetStringLength();
536      }
537      ~Schema() {
538          AllocatorType::Free(enum_);
539          if (properties_) {
540              for (SizeType i = 0; i < propertyCount_; i++)
541                  properties_[i].~Property();
542              AllocatorType::Free(properties_);
543          }
544          if (patternProperties_) {
545              for (SizeType i = 0; i < patternPropertyCount_; i++)
546                  patternProperties_[i].~PatternProperty();
547              AllocatorType::Free(patternProperties_);
548          }
549          AllocatorType::Free(itemsTuple_);
550  #if RAPIDJSON_SCHEMA_HAS_REGEX
551          if (pattern_) {
552              pattern_->~RegexType();
553              AllocatorType::Free(pattern_);
554          }
555  #endif
556      }
557      const SValue& GetURI() const {
558          return uri_;
559      }
560      const UriType& GetId() const {
561          return id_;
562      }
563      const PointerType& GetPointer() const {
564          return pointer_;
565      }
566      bool BeginValue(Context& context) const {
567          if (context.inArray) {
568              if (uniqueItems_)
569                  context.valueUniqueness = true;
570              if (itemsList_)
571                  context.valueSchema = itemsList_;
572              else if (itemsTuple_) {
573                  if (context.arrayElementIndex < itemsTupleCount_)
574                      context.valueSchema = itemsTuple_[context.arrayElementIndex];
575                  else if (additionalItemsSchema_)
576                      context.valueSchema = additionalItemsSchema_;
577                  else if (additionalItems_)
578                      context.valueSchema = typeless_;
579                  else {
580                      context.error_handler.DisallowedItem(context.arrayElementIndex);
581                      context.valueSchema = typeless_;
582                      context.arrayElementIndex++;
583                      RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorAdditionalItems);
584                  }
585              }
586              else
587                  context.valueSchema = typeless_;
588              context.arrayElementIndex++;
589          }
590          return true;
591      }
592      RAPIDJSON_FORCEINLINE bool EndValue(Context& context) const {
593          if (context.patternPropertiesValidatorCount > 0) {
594              bool otherValid = false;
595              SizeType count = context.patternPropertiesValidatorCount;
596              if (context.objectPatternValidatorType != Context::kPatternValidatorOnly)
597                  otherValid = context.patternPropertiesValidators[--count]->IsValid();
598              bool patternValid = true;
599              for (SizeType i = 0; i < count; i++)
600                  if (!context.patternPropertiesValidators[i]->IsValid()) {
601                      patternValid = false;
602                      break;
603                  }
604              if (context.objectPatternValidatorType == Context::kPatternValidatorOnly) {
605                  if (!patternValid) {
606                      context.error_handler.PropertyViolations(context.patternPropertiesValidators, count);
607                      RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorPatternProperties);
608                  }
609              }
610              else if (context.objectPatternValidatorType == Context::kPatternValidatorWithProperty) {
611                  if (!patternValid || !otherValid) {
612                      context.error_handler.PropertyViolations(context.patternPropertiesValidators, count + 1);
613                      RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorPatternProperties);
614                  }
615              }
616              else if (!patternValid && !otherValid) { 
617                  context.error_handler.PropertyViolations(context.patternPropertiesValidators, count + 1);
618                  RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorPatternProperties);
619              }
620          }
621          if (enum_ && context.hasher) {
622              const uint64_t h = context.factory.GetHashCode(context.hasher);
623              for (SizeType i = 0; i < enumCount_; i++)
624                  if (enum_[i] == h)
625                      goto foundEnum;
626              context.error_handler.DisallowedValue(kValidateErrorEnum);
627              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorEnum);
628              foundEnum:;
629          }
630          if (context.validatorCount > 0) {
631              if (allOf_.schemas)
632                  for (SizeType i = allOf_.begin; i < allOf_.begin + allOf_.count; i++)
633                      if (!context.validators[i]->IsValid()) {
634                          context.error_handler.NotAllOf(&context.validators[allOf_.begin], allOf_.count);
635                          RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorAllOf);
636                      }
637              if (anyOf_.schemas) {
638                  for (SizeType i = anyOf_.begin; i < anyOf_.begin + anyOf_.count; i++)
639                      if (context.validators[i]->IsValid())
640                          goto foundAny;
641                  context.error_handler.NoneOf(&context.validators[anyOf_.begin], anyOf_.count);
642                  RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorAnyOf);
643                  foundAny:;
644              }
645              if (oneOf_.schemas) {
646                  bool oneValid = false;
647                  for (SizeType i = oneOf_.begin; i < oneOf_.begin + oneOf_.count; i++)
648                      if (context.validators[i]->IsValid()) {
649                          if (oneValid) {
650                              context.error_handler.NotOneOf(&context.validators[oneOf_.begin], oneOf_.count, true);
651                              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorOneOfMatch);
652                          } else
653                              oneValid = true;
654                      }
655                  if (!oneValid) {
656                      context.error_handler.NotOneOf(&context.validators[oneOf_.begin], oneOf_.count, false);
657                      RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorOneOf);
658                  }
659              }
660              if (not_ && context.validators[notValidatorIndex_]->IsValid()) {
661                  context.error_handler.Disallowed();
662                  RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorNot);
663              }
664          }
665          return true;
666      }
667      bool Null(Context& context) const {
668          if (!(type_ & (1 << kNullSchemaType))) {
669              DisallowedType(context, GetNullString());
670              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorType);
671          }
672          return CreateParallelValidator(context);
673      }
674      bool Bool(Context& context, bool) const {
675          if (!(type_ & (1 << kBooleanSchemaType))) {
676              DisallowedType(context, GetBooleanString());
677              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorType);
678          }
679          return CreateParallelValidator(context);
680      }
681      bool Int(Context& context, int i) const {
682          if (!CheckInt(context, i))
683              return false;
684          return CreateParallelValidator(context);
685      }
686      bool Uint(Context& context, unsigned u) const {
687          if (!CheckUint(context, u))
688              return false;
689          return CreateParallelValidator(context);
690      }
691      bool Int64(Context& context, int64_t i) const {
692          if (!CheckInt(context, i))
693              return false;
694          return CreateParallelValidator(context);
695      }
696      bool Uint64(Context& context, uint64_t u) const {
697          if (!CheckUint(context, u))
698              return false;
699          return CreateParallelValidator(context);
700      }
701      bool Double(Context& context, double d) const {
702          if (!(type_ & (1 << kNumberSchemaType))) {
703              DisallowedType(context, GetNumberString());
704              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorType);
705          }
706          if (!minimum_.IsNull() && !CheckDoubleMinimum(context, d))
707              return false;
708          if (!maximum_.IsNull() && !CheckDoubleMaximum(context, d))
709              return false;
710          if (!multipleOf_.IsNull() && !CheckDoubleMultipleOf(context, d))
711              return false;
712          return CreateParallelValidator(context);
713      }
714      bool String(Context& context, const Ch* str, SizeType length, bool) const {
715          if (!(type_ & (1 << kStringSchemaType))) {
716              DisallowedType(context, GetStringString());
717              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorType);
718          }
719          if (minLength_ != 0 || maxLength_ != SizeType(~0)) {
720              SizeType count;
721              if (internal::CountStringCodePoint<EncodingType>(str, length, &count)) {
722                  if (count < minLength_) {
723                      context.error_handler.TooShort(str, length, minLength_);
724                      RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorMinLength);
725                  }
726                  if (count > maxLength_) {
727                      context.error_handler.TooLong(str, length, maxLength_);
728                      RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorMaxLength);
729                  }
730              }
731          }
732          if (pattern_ && !IsPatternMatch(pattern_, str, length)) {
733              context.error_handler.DoesNotMatch(str, length);
734              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorPattern);
735          }
736          return CreateParallelValidator(context);
737      }
738      bool StartObject(Context& context) const {
739          if (!(type_ & (1 << kObjectSchemaType))) {
740              DisallowedType(context, GetObjectString());
741              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorType);
742          }
743          if (hasDependencies_ || hasRequired_) {
744              context.propertyExist = static_cast<bool*>(context.factory.MallocState(sizeof(bool) * propertyCount_));
745              std::memset(context.propertyExist, 0, sizeof(bool) * propertyCount_);
746          }
747          if (patternProperties_) { 
748              SizeType count = patternPropertyCount_ + 1; 
749              context.patternPropertiesSchemas = static_cast<const SchemaType**>(context.factory.MallocState(sizeof(const SchemaType*) * count));
750              context.patternPropertiesSchemaCount = 0;
751              std::memset(context.patternPropertiesSchemas, 0, sizeof(SchemaType*) * count);
752          }
753          return CreateParallelValidator(context);
754      }
755      bool Key(Context& context, const Ch* str, SizeType len, bool) const {
756          if (patternProperties_) {
757              context.patternPropertiesSchemaCount = 0;
758              for (SizeType i = 0; i < patternPropertyCount_; i++)
759                  if (patternProperties_[i].pattern && IsPatternMatch(patternProperties_[i].pattern, str, len)) {
760                      context.patternPropertiesSchemas[context.patternPropertiesSchemaCount++] = patternProperties_[i].schema;
761                      context.valueSchema = typeless_;
762                  }
763          }
764          SizeType index  = 0;
765          if (FindPropertyIndex(ValueType(str, len).Move(), &index)) {
766              if (context.patternPropertiesSchemaCount > 0) {
767                  context.patternPropertiesSchemas[context.patternPropertiesSchemaCount++] = properties_[index].schema;
768                  context.valueSchema = typeless_;
769                  context.valuePatternValidatorType = Context::kPatternValidatorWithProperty;
770              }
771              else
772                  context.valueSchema = properties_[index].schema;
773              if (context.propertyExist)
774                  context.propertyExist[index] = true;
775              return true;
776          }
777          if (additionalPropertiesSchema_) {
778              if (context.patternPropertiesSchemaCount > 0) {
779                  context.patternPropertiesSchemas[context.patternPropertiesSchemaCount++] = additionalPropertiesSchema_;
780                  context.valueSchema = typeless_;
781                  context.valuePatternValidatorType = Context::kPatternValidatorWithAdditionalProperty;
782              }
783              else
784                  context.valueSchema = additionalPropertiesSchema_;
785              return true;
786          }
787          else if (additionalProperties_) {
788              context.valueSchema = typeless_;
789              return true;
790          }
791          if (context.patternPropertiesSchemaCount == 0) { 
792              context.valueSchema = typeless_;
793              context.error_handler.DisallowedProperty(str, len);
794              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorAdditionalProperties);
795          }
796          return true;
797      }
798      bool EndObject(Context& context, SizeType memberCount) const {
799          if (hasRequired_) {
800              context.error_handler.StartMissingProperties();
801              for (SizeType index = 0; index < propertyCount_; index++)
802                  if (properties_[index].required && !context.propertyExist[index])
803                      if (properties_[index].schema->defaultValueLength_ == 0 )
804                          context.error_handler.AddMissingProperty(properties_[index].name);
805              if (context.error_handler.EndMissingProperties())
806                  RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorRequired);
807          }
808          if (memberCount < minProperties_) {
809              context.error_handler.TooFewProperties(memberCount, minProperties_);
810              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorMinProperties);
811          }
812          if (memberCount > maxProperties_) {
813              context.error_handler.TooManyProperties(memberCount, maxProperties_);
814              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorMaxProperties);
815          }
816          if (hasDependencies_) {
817              context.error_handler.StartDependencyErrors();
818              for (SizeType sourceIndex = 0; sourceIndex < propertyCount_; sourceIndex++) {
819                  const Property& source = properties_[sourceIndex];
820                  if (context.propertyExist[sourceIndex]) {
821                      if (source.dependencies) {
822                          context.error_handler.StartMissingDependentProperties();
823                          for (SizeType targetIndex = 0; targetIndex < propertyCount_; targetIndex++)
824                              if (source.dependencies[targetIndex] && !context.propertyExist[targetIndex])
825                                  context.error_handler.AddMissingDependentProperty(properties_[targetIndex].name);
826                          context.error_handler.EndMissingDependentProperties(source.name);
827                      }
828                      else if (source.dependenciesSchema) {
829                          ISchemaValidator* dependenciesValidator = context.validators[source.dependenciesValidatorIndex];
830                          if (!dependenciesValidator->IsValid())
831                              context.error_handler.AddDependencySchemaError(source.name, dependenciesValidator);
832                      }
833                  }
834              }
835              if (context.error_handler.EndDependencyErrors())
836                  RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorDependencies);
837          }
838          return true;
839      }
840      bool StartArray(Context& context) const {
841          context.arrayElementIndex = 0;
842          context.inArray = true;  
843          if (!(type_ & (1 << kArraySchemaType))) {
844              DisallowedType(context, GetArrayString());
845              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorType);
846          }
847          return CreateParallelValidator(context);
848      }
849      bool EndArray(Context& context, SizeType elementCount) const {
850          context.inArray = false;
851          if (elementCount < minItems_) {
852              context.error_handler.TooFewItems(elementCount, minItems_);
853              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorMinItems);
854          }
855          if (elementCount > maxItems_) {
856              context.error_handler.TooManyItems(elementCount, maxItems_);
857              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorMaxItems);
858          }
859          return true;
860      }
861      static const ValueType& GetValidateErrorKeyword(ValidateErrorCode validateErrorCode) {
862          switch (validateErrorCode) {
863              case kValidateErrorMultipleOf:              return GetMultipleOfString();
864              case kValidateErrorMaximum:                 return GetMaximumString();
865              case kValidateErrorExclusiveMaximum:        return GetMaximumString(); 
866              case kValidateErrorMinimum:                 return GetMinimumString();
867              case kValidateErrorExclusiveMinimum:        return GetMinimumString(); 
868              case kValidateErrorMaxLength:               return GetMaxLengthString();
869              case kValidateErrorMinLength:               return GetMinLengthString();
870              case kValidateErrorPattern:                 return GetPatternString();
871              case kValidateErrorMaxItems:                return GetMaxItemsString();
872              case kValidateErrorMinItems:                return GetMinItemsString();
873              case kValidateErrorUniqueItems:             return GetUniqueItemsString();
874              case kValidateErrorAdditionalItems:         return GetAdditionalItemsString();
875              case kValidateErrorMaxProperties:           return GetMaxPropertiesString();
876              case kValidateErrorMinProperties:           return GetMinPropertiesString();
877              case kValidateErrorRequired:                return GetRequiredString();
878              case kValidateErrorAdditionalProperties:    return GetAdditionalPropertiesString();
879              case kValidateErrorPatternProperties:       return GetPatternPropertiesString();
880              case kValidateErrorDependencies:            return GetDependenciesString();
881              case kValidateErrorEnum:                    return GetEnumString();
882              case kValidateErrorType:                    return GetTypeString();
883              case kValidateErrorOneOf:                   return GetOneOfString();
884              case kValidateErrorOneOfMatch:              return GetOneOfString(); 
885              case kValidateErrorAllOf:                   return GetAllOfString();
886              case kValidateErrorAnyOf:                   return GetAnyOfString();
887              case kValidateErrorNot:                     return GetNotString();
888              default:                                    return GetNullString();
889          }
890      }
891  #define RAPIDJSON_STRING_(name, ...) \
892      static const ValueType& Get##name##String() {\
893          static const Ch s[] = { __VA_ARGS__, '\0' };\
894          static const ValueType v(s, static_cast<SizeType>(sizeof(s) / sizeof(Ch) - 1));\
895          return v;\
896      }
897      RAPIDJSON_STRING_(Null, 'n', 'u', 'l', 'l')
898      RAPIDJSON_STRING_(Boolean, 'b', 'o', 'o', 'l', 'e', 'a', 'n')
899      RAPIDJSON_STRING_(Object, 'o', 'b', 'j', 'e', 'c', 't')
900      RAPIDJSON_STRING_(Array, 'a', 'r', 'r', 'a', 'y')
901      RAPIDJSON_STRING_(String, 's', 't', 'r', 'i', 'n', 'g')
902      RAPIDJSON_STRING_(Number, 'n', 'u', 'm', 'b', 'e', 'r')
903      RAPIDJSON_STRING_(Integer, 'i', 'n', 't', 'e', 'g', 'e', 'r')
904      RAPIDJSON_STRING_(Type, 't', 'y', 'p', 'e')
905      RAPIDJSON_STRING_(Enum, 'e', 'n', 'u', 'm')
906      RAPIDJSON_STRING_(AllOf, 'a', 'l', 'l', 'O', 'f')
907      RAPIDJSON_STRING_(AnyOf, 'a', 'n', 'y', 'O', 'f')
908      RAPIDJSON_STRING_(OneOf, 'o', 'n', 'e', 'O', 'f')
909      RAPIDJSON_STRING_(Not, 'n', 'o', 't')
910      RAPIDJSON_STRING_(Properties, 'p', 'r', 'o', 'p', 'e', 'r', 't', 'i', 'e', 's')
911      RAPIDJSON_STRING_(Required, 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd')
912      RAPIDJSON_STRING_(Dependencies, 'd', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c', 'i', 'e', 's')
913      RAPIDJSON_STRING_(PatternProperties, 'p', 'a', 't', 't', 'e', 'r', 'n', 'P', 'r', 'o', 'p', 'e', 'r', 't', 'i', 'e', 's')
914      RAPIDJSON_STRING_(AdditionalProperties, 'a', 'd', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'P', 'r', 'o', 'p', 'e', 'r', 't', 'i', 'e', 's')
915      RAPIDJSON_STRING_(MinProperties, 'm', 'i', 'n', 'P', 'r', 'o', 'p', 'e', 'r', 't', 'i', 'e', 's')
916      RAPIDJSON_STRING_(MaxProperties, 'm', 'a', 'x', 'P', 'r', 'o', 'p', 'e', 'r', 't', 'i', 'e', 's')
917      RAPIDJSON_STRING_(Items, 'i', 't', 'e', 'm', 's')
918      RAPIDJSON_STRING_(MinItems, 'm', 'i', 'n', 'I', 't', 'e', 'm', 's')
919      RAPIDJSON_STRING_(MaxItems, 'm', 'a', 'x', 'I', 't', 'e', 'm', 's')
920      RAPIDJSON_STRING_(AdditionalItems, 'a', 'd', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'I', 't', 'e', 'm', 's')
921      RAPIDJSON_STRING_(UniqueItems, 'u', 'n', 'i', 'q', 'u', 'e', 'I', 't', 'e', 'm', 's')
922      RAPIDJSON_STRING_(MinLength, 'm', 'i', 'n', 'L', 'e', 'n', 'g', 't', 'h')
923      RAPIDJSON_STRING_(MaxLength, 'm', 'a', 'x', 'L', 'e', 'n', 'g', 't', 'h')
924      RAPIDJSON_STRING_(Pattern, 'p', 'a', 't', 't', 'e', 'r', 'n')
925      RAPIDJSON_STRING_(Minimum, 'm', 'i', 'n', 'i', 'm', 'u', 'm')
926      RAPIDJSON_STRING_(Maximum, 'm', 'a', 'x', 'i', 'm', 'u', 'm')
927      RAPIDJSON_STRING_(ExclusiveMinimum, 'e', 'x', 'c', 'l', 'u', 's', 'i', 'v', 'e', 'M', 'i', 'n', 'i', 'm', 'u', 'm')
928      RAPIDJSON_STRING_(ExclusiveMaximum, 'e', 'x', 'c', 'l', 'u', 's', 'i', 'v', 'e', 'M', 'a', 'x', 'i', 'm', 'u', 'm')
929      RAPIDJSON_STRING_(MultipleOf, 'm', 'u', 'l', 't', 'i', 'p', 'l', 'e', 'O', 'f')
930      RAPIDJSON_STRING_(DefaultValue, 'd', 'e', 'f', 'a', 'u', 'l', 't')
931      RAPIDJSON_STRING_(Ref, '$', 'r', 'e', 'f')
932      RAPIDJSON_STRING_(Id, 'i', 'd')
933      RAPIDJSON_STRING_(SchemeEnd, ':')
934      RAPIDJSON_STRING_(AuthStart, '/', '/')
935      RAPIDJSON_STRING_(QueryStart, '?')
936      RAPIDJSON_STRING_(FragStart, '#')
937      RAPIDJSON_STRING_(Slash, '/')
938      RAPIDJSON_STRING_(Dot, '.')
939  #undef RAPIDJSON_STRING_
940  private:
941      enum SchemaValueType {
942          kNullSchemaType,
943          kBooleanSchemaType,
944          kObjectSchemaType,
945          kArraySchemaType,
946          kStringSchemaType,
947          kNumberSchemaType,
948          kIntegerSchemaType,
949          kTotalSchemaType
950      };
951  #if RAPIDJSON_SCHEMA_USE_INTERNALREGEX
952          typedef internal::GenericRegex<EncodingType, AllocatorType> RegexType;
953  #elif RAPIDJSON_SCHEMA_USE_STDREGEX
954          typedef std::basic_regex<Ch> RegexType;
955  #else
956          typedef char RegexType;
957  #endif
958      struct SchemaArray {
959          SchemaArray() : schemas(), count() {}
960          ~SchemaArray() { AllocatorType::Free(schemas); }
961          const SchemaType** schemas;
962          SizeType begin; 
963          SizeType count;
964      };
965      template <typename V1, typename V2>
966      void AddUniqueElement(V1& a, const V2& v) {
967          for (typename V1::ConstValueIterator itr = a.Begin(); itr != a.End(); ++itr)
968              if (*itr == v)
969                  return;
970          V1 c(v, *allocator_);
971          a.PushBack(c, *allocator_);
972      }
973      static const ValueType* GetMember(const ValueType& value, const ValueType& name) {
974          typename ValueType::ConstMemberIterator itr = value.FindMember(name);
975          return itr != value.MemberEnd() ? &(itr->value) : 0;
976      }
977      static void AssignIfExist(bool& out, const ValueType& value, const ValueType& name) {
978          if (const ValueType* v = GetMember(value, name))
979              if (v->IsBool())
980                  out = v->GetBool();
981      }
982      static void AssignIfExist(SizeType& out, const ValueType& value, const ValueType& name) {
983          if (const ValueType* v = GetMember(value, name))
984              if (v->IsUint64() && v->GetUint64() <= SizeType(~0))
985                  out = static_cast<SizeType>(v->GetUint64());
986      }
987      void AssignIfExist(SchemaArray& out, SchemaDocumentType& schemaDocument, const PointerType& p, const ValueType& value, const ValueType& name, const ValueType& document) {
988          if (const ValueType* v = GetMember(value, name)) {
989              if (v->IsArray() && v->Size() > 0) {
990                  PointerType q = p.Append(name, allocator_);
991                  out.count = v->Size();
992                  out.schemas = static_cast<const Schema**>(allocator_->Malloc(out.count * sizeof(const Schema*)));
993                  memset(out.schemas, 0, sizeof(Schema*)* out.count);
994                  for (SizeType i = 0; i < out.count; i++)
995                      schemaDocument.CreateSchema(&out.schemas[i], q.Append(i, allocator_), (*v)[i], document, id_);
996                  out.begin = validatorCount_;
997                  validatorCount_ += out.count;
998              }
999          }
1000      }
1001  #if RAPIDJSON_SCHEMA_USE_INTERNALREGEX
1002      template <typename ValueType>
1003      RegexType* CreatePattern(const ValueType& value) {
1004          if (value.IsString()) {
1005              RegexType* r = new (allocator_->Malloc(sizeof(RegexType))) RegexType(value.GetString(), allocator_);
1006              if (!r->IsValid()) {
1007                  r->~RegexType();
1008                  AllocatorType::Free(r);
1009                  r = 0;
1010              }
1011              return r;
1012          }
1013          return 0;
1014      }
1015      static bool IsPatternMatch(const RegexType* pattern, const Ch *str, SizeType) {
1016          GenericRegexSearch<RegexType> rs(*pattern);
1017          return rs.Search(str);
1018      }
1019  #elif RAPIDJSON_SCHEMA_USE_STDREGEX
1020      template <typename ValueType>
1021      RegexType* CreatePattern(const ValueType& value) {
1022          if (value.IsString()) {
1023              RegexType *r = static_cast<RegexType*>(allocator_->Malloc(sizeof(RegexType)));
1024              try {
1025                  return new (r) RegexType(value.GetString(), std::size_t(value.GetStringLength()), std::regex_constants::ECMAScript);
1026              }
1027              catch (const std::regex_error&) {
1028                  AllocatorType::Free(r);
1029              }
1030          }
1031          return 0;
1032      }
1033      static bool IsPatternMatch(const RegexType* pattern, const Ch *str, SizeType length) {
1034          std::match_results<const Ch*> r;
1035          return std::regex_search(str, str + length, r, *pattern);
1036      }
1037  #else
1038      template <typename ValueType>
1039      RegexType* CreatePattern(const ValueType&) { return 0; }
1040      static bool IsPatternMatch(const RegexType*, const Ch *, SizeType) { return true; }
1041  #endif 
1042      void AddType(const ValueType& type) {
1043          if      (type == GetNullString()   ) type_ |= 1 << kNullSchemaType;
1044          else if (type == GetBooleanString()) type_ |= 1 << kBooleanSchemaType;
1045          else if (type == GetObjectString() ) type_ |= 1 << kObjectSchemaType;
1046          else if (type == GetArrayString()  ) type_ |= 1 << kArraySchemaType;
1047          else if (type == GetStringString() ) type_ |= 1 << kStringSchemaType;
1048          else if (type == GetIntegerString()) type_ |= 1 << kIntegerSchemaType;
1049          else if (type == GetNumberString() ) type_ |= (1 << kNumberSchemaType) | (1 << kIntegerSchemaType);
1050      }
1051      bool CreateParallelValidator(Context& context) const {
1052          if (enum_ || context.arrayUniqueness)
1053              context.hasher = context.factory.CreateHasher();
1054          if (validatorCount_) {
1055              RAPIDJSON_ASSERT(context.validators == 0);
1056              context.validators = static_cast<ISchemaValidator**>(context.factory.MallocState(sizeof(ISchemaValidator*) * validatorCount_));
1057              context.validatorCount = validatorCount_;
1058              if (allOf_.schemas)
1059                  CreateSchemaValidators(context, allOf_, false);
1060              if (anyOf_.schemas)
1061                  CreateSchemaValidators(context, anyOf_, false);
1062              if (oneOf_.schemas)
1063                  CreateSchemaValidators(context, oneOf_, false);
1064              if (not_)
1065                  context.validators[notValidatorIndex_] = context.factory.CreateSchemaValidator(*not_, false);
1066              if (hasSchemaDependencies_) {
1067                  for (SizeType i = 0; i < propertyCount_; i++)
1068                      if (properties_[i].dependenciesSchema)
1069                          context.validators[properties_[i].dependenciesValidatorIndex] = context.factory.CreateSchemaValidator(*properties_[i].dependenciesSchema, false);
1070              }
1071          }
1072          return true;
1073      }
1074      void CreateSchemaValidators(Context& context, const SchemaArray& schemas, const bool inheritContinueOnErrors) const {
1075          for (SizeType i = 0; i < schemas.count; i++)
1076              context.validators[schemas.begin + i] = context.factory.CreateSchemaValidator(*schemas.schemas[i], inheritContinueOnErrors);
1077      }
1078      bool FindPropertyIndex(const ValueType& name, SizeType* outIndex) const {
1079          SizeType len = name.GetStringLength();
1080          const Ch* str = name.GetString();
1081          for (SizeType index = 0; index < propertyCount_; index++)
1082              if (properties_[index].name.GetStringLength() == len &&
1083                  (std::memcmp(properties_[index].name.GetString(), str, sizeof(Ch) * len) == 0))
1084              {
1085                  *outIndex = index;
1086                  return true;
1087              }
1088          return false;
1089      }
1090      bool CheckInt(Context& context, int64_t i) const {
1091          if (!(type_ & ((1 << kIntegerSchemaType) | (1 << kNumberSchemaType)))) {
1092              DisallowedType(context, GetIntegerString());
1093              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorType);
1094          }
1095          if (!minimum_.IsNull()) {
1096              if (minimum_.IsInt64()) {
1097                  if (exclusiveMinimum_ ? i <= minimum_.GetInt64() : i < minimum_.GetInt64()) {
1098                      context.error_handler.BelowMinimum(i, minimum_, exclusiveMinimum_);
1099                      RAPIDJSON_INVALID_KEYWORD_RETURN(exclusiveMinimum_ ? kValidateErrorExclusiveMinimum : kValidateErrorMinimum);
1100                  }
1101              }
1102              else if (minimum_.IsUint64()) {
1103                  context.error_handler.BelowMinimum(i, minimum_, exclusiveMinimum_);
1104                  RAPIDJSON_INVALID_KEYWORD_RETURN(exclusiveMinimum_ ? kValidateErrorExclusiveMinimum : kValidateErrorMinimum); 
1105              }
1106              else if (!CheckDoubleMinimum(context, static_cast<double>(i)))
1107                  return false;
1108          }
1109          if (!maximum_.IsNull()) {
1110              if (maximum_.IsInt64()) {
1111                  if (exclusiveMaximum_ ? i >= maximum_.GetInt64() : i > maximum_.GetInt64()) {
1112                      context.error_handler.AboveMaximum(i, maximum_, exclusiveMaximum_);
1113                      RAPIDJSON_INVALID_KEYWORD_RETURN(exclusiveMaximum_ ? kValidateErrorExclusiveMaximum : kValidateErrorMaximum);
1114                  }
1115              }
1116              else if (maximum_.IsUint64()) { }
1117              else if (!CheckDoubleMaximum(context, static_cast<double>(i)))
1118                  return false;
1119          }
1120          if (!multipleOf_.IsNull()) {
1121              if (multipleOf_.IsUint64()) {
1122                  if (static_cast<uint64_t>(i >= 0 ? i : -i) % multipleOf_.GetUint64() != 0) {
1123                      context.error_handler.NotMultipleOf(i, multipleOf_);
1124                      RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorMultipleOf);
1125                  }
1126              }
1127              else if (!CheckDoubleMultipleOf(context, static_cast<double>(i)))
1128                  return false;
1129          }
1130          return true;
1131      }
1132      bool CheckUint(Context& context, uint64_t i) const {
1133          if (!(type_ & ((1 << kIntegerSchemaType) | (1 << kNumberSchemaType)))) {
1134              DisallowedType(context, GetIntegerString());
1135              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorType);
1136          }
1137          if (!minimum_.IsNull()) {
1138              if (minimum_.IsUint64()) {
1139                  if (exclusiveMinimum_ ? i <= minimum_.GetUint64() : i < minimum_.GetUint64()) {
1140                      context.error_handler.BelowMinimum(i, minimum_, exclusiveMinimum_);
1141                      RAPIDJSON_INVALID_KEYWORD_RETURN(exclusiveMinimum_ ? kValidateErrorExclusiveMinimum : kValidateErrorMinimum);
1142                  }
1143              }
1144              else if (minimum_.IsInt64())
1145                  ; 
1146              else if (!CheckDoubleMinimum(context, static_cast<double>(i)))
1147                  return false;
1148          }
1149          if (!maximum_.IsNull()) {
1150              if (maximum_.IsUint64()) {
1151                  if (exclusiveMaximum_ ? i >= maximum_.GetUint64() : i > maximum_.GetUint64()) {
1152                      context.error_handler.AboveMaximum(i, maximum_, exclusiveMaximum_);
1153                      RAPIDJSON_INVALID_KEYWORD_RETURN(exclusiveMaximum_ ? kValidateErrorExclusiveMaximum : kValidateErrorMaximum);
1154                  }
1155              }
1156              else if (maximum_.IsInt64()) {
1157                  context.error_handler.AboveMaximum(i, maximum_, exclusiveMaximum_);
1158                  RAPIDJSON_INVALID_KEYWORD_RETURN(exclusiveMaximum_ ? kValidateErrorExclusiveMaximum : kValidateErrorMaximum); 
1159              }
1160              else if (!CheckDoubleMaximum(context, static_cast<double>(i)))
1161                  return false;
1162          }
1163          if (!multipleOf_.IsNull()) {
1164              if (multipleOf_.IsUint64()) {
1165                  if (i % multipleOf_.GetUint64() != 0) {
1166                      context.error_handler.NotMultipleOf(i, multipleOf_);
1167                      RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorMultipleOf);
1168                  }
1169              }
1170              else if (!CheckDoubleMultipleOf(context, static_cast<double>(i)))
1171                  return false;
1172          }
1173          return true;
1174      }
1175      bool CheckDoubleMinimum(Context& context, double d) const {
1176          if (exclusiveMinimum_ ? d <= minimum_.GetDouble() : d < minimum_.GetDouble()) {
1177              context.error_handler.BelowMinimum(d, minimum_, exclusiveMinimum_);
1178              RAPIDJSON_INVALID_KEYWORD_RETURN(exclusiveMinimum_ ? kValidateErrorExclusiveMinimum : kValidateErrorMinimum);
1179          }
1180          return true;
1181      }
1182      bool CheckDoubleMaximum(Context& context, double d) const {
1183          if (exclusiveMaximum_ ? d >= maximum_.GetDouble() : d > maximum_.GetDouble()) {
1184              context.error_handler.AboveMaximum(d, maximum_, exclusiveMaximum_);
1185              RAPIDJSON_INVALID_KEYWORD_RETURN(exclusiveMaximum_ ? kValidateErrorExclusiveMaximum : kValidateErrorMaximum);
1186          }
1187          return true;
1188      }
1189      bool CheckDoubleMultipleOf(Context& context, double d) const {
1190          double a = std::abs(d), b = std::abs(multipleOf_.GetDouble());
1191          double q = std::floor(a / b);
1192          double r = a - q * b;
1193          if (r > 0.0) {
1194              context.error_handler.NotMultipleOf(d, multipleOf_);
1195              RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorMultipleOf);
1196          }
1197          return true;
1198      }
1199      void DisallowedType(Context& context, const ValueType& actualType) const {
1200          ErrorHandler& eh = context.error_handler;
1201          eh.StartDisallowedType();
1202          if (type_ & (1 << kNullSchemaType)) eh.AddExpectedType(GetNullString());
1203          if (type_ & (1 << kBooleanSchemaType)) eh.AddExpectedType(GetBooleanString());
1204          if (type_ & (1 << kObjectSchemaType)) eh.AddExpectedType(GetObjectString());
1205          if (type_ & (1 << kArraySchemaType)) eh.AddExpectedType(GetArrayString());
1206          if (type_ & (1 << kStringSchemaType)) eh.AddExpectedType(GetStringString());
1207          if (type_ & (1 << kNumberSchemaType)) eh.AddExpectedType(GetNumberString());
1208          else if (type_ & (1 << kIntegerSchemaType)) eh.AddExpectedType(GetIntegerString());
1209          eh.EndDisallowedType(actualType);
1210      }
1211      struct Property {
1212          Property() : schema(), dependenciesSchema(), dependenciesValidatorIndex(), dependencies(), required(false) {}
1213          ~Property() { AllocatorType::Free(dependencies); }
1214          SValue name;
1215          const SchemaType* schema;
1216          const SchemaType* dependenciesSchema;
1217          SizeType dependenciesValidatorIndex;
1218          bool* dependencies;
1219          bool required;
1220      };
1221      struct PatternProperty {
1222          PatternProperty() : schema(), pattern() {}
1223          ~PatternProperty() {
1224              if (pattern) {
1225                  pattern->~RegexType();
1226                  AllocatorType::Free(pattern);
1227              }
1228          }
1229          const SchemaType* schema;
1230          RegexType* pattern;
1231      };
1232      AllocatorType* allocator_;
1233      SValue uri_;
1234      UriType id_;
1235      PointerType pointer_;
1236      const SchemaType* typeless_;
1237      uint64_t* enum_;
1238      SizeType enumCount_;
1239      SchemaArray allOf_;
1240      SchemaArray anyOf_;
1241      SchemaArray oneOf_;
1242      const SchemaType* not_;
1243      unsigned type_; 
1244      SizeType validatorCount_;
1245      SizeType notValidatorIndex_;
1246      Property* properties_;
1247      const SchemaType* additionalPropertiesSchema_;
1248      PatternProperty* patternProperties_;
1249      SizeType patternPropertyCount_;
1250      SizeType propertyCount_;
1251      SizeType minProperties_;
1252      SizeType maxProperties_;
1253      bool additionalProperties_;
1254      bool hasDependencies_;
1255      bool hasRequired_;
1256      bool hasSchemaDependencies_;
1257      const SchemaType* additionalItemsSchema_;
1258      const SchemaType* itemsList_;
1259      const SchemaType** itemsTuple_;
1260      SizeType itemsTupleCount_;
1261      SizeType minItems_;
1262      SizeType maxItems_;
1263      bool additionalItems_;
1264      bool uniqueItems_;
1265      RegexType* pattern_;
1266      SizeType minLength_;
1267      SizeType maxLength_;
1268      SValue minimum_;
1269      SValue maximum_;
1270      SValue multipleOf_;
1271      bool exclusiveMinimum_;
1272      bool exclusiveMaximum_;
1273      SizeType defaultValueLength_;
1274  };
1275  template<typename Stack, typename Ch>
1276  struct TokenHelper {
1277      RAPIDJSON_FORCEINLINE static void AppendIndexToken(Stack& documentStack, SizeType index) {
1278          *documentStack.template Push<Ch>() = '/';
1279          char buffer[21];
1280          size_t length = static_cast<size_t>((sizeof(SizeType) == 4 ? u32toa(index, buffer) : u64toa(index, buffer)) - buffer);
1281          for (size_t i = 0; i < length; i++)
1282              *documentStack.template Push<Ch>() = static_cast<Ch>(buffer[i]);
1283      }
1284  };
1285  template <typename Stack>
1286  struct TokenHelper<Stack, char> {
1287      RAPIDJSON_FORCEINLINE static void AppendIndexToken(Stack& documentStack, SizeType index) {
1288          if (sizeof(SizeType) == 4) {
1289              char *buffer = documentStack.template Push<char>(1 + 10); 
1290              *buffer++ = '/';
1291              const char* end = internal::u32toa(index, buffer);
1292               documentStack.template Pop<char>(static_cast<size_t>(10 - (end - buffer)));
1293          }
1294          else {
1295              char *buffer = documentStack.template Push<char>(1 + 20); 
1296              *buffer++ = '/';
1297              const char* end = internal::u64toa(index, buffer);
1298              documentStack.template Pop<char>(static_cast<size_t>(20 - (end - buffer)));
1299          }
1300      }
1301  };
1302  } 
1303  template <typename SchemaDocumentType>
1304  class IGenericRemoteSchemaDocumentProvider {
1305  public:
1306      typedef typename SchemaDocumentType::Ch Ch;
1307      typedef typename SchemaDocumentType::ValueType ValueType;
1308      typedef typename SchemaDocumentType::AllocatorType AllocatorType;
1309      virtual ~IGenericRemoteSchemaDocumentProvider() {}
1310      virtual const SchemaDocumentType* GetRemoteDocument(const Ch* uri, SizeType length) = 0;
1311      virtual const SchemaDocumentType* GetRemoteDocument(GenericUri<ValueType, AllocatorType> uri) { return GetRemoteDocument(uri.GetBaseString(), uri.GetBaseStringLength()); }
1312  };
1313  template <typename ValueT, typename Allocator = CrtAllocator>
1314  class GenericSchemaDocument {
1315  public:
1316      typedef ValueT ValueType;
1317      typedef IGenericRemoteSchemaDocumentProvider<GenericSchemaDocument> IRemoteSchemaDocumentProviderType;
1318      typedef Allocator AllocatorType;
1319      typedef typename ValueType::EncodingType EncodingType;
1320      typedef typename EncodingType::Ch Ch;
1321      typedef internal::Schema<GenericSchemaDocument> SchemaType;
1322      typedef GenericPointer<ValueType, Allocator> PointerType;
1323      typedef GenericValue<EncodingType, AllocatorType> SValue;
1324      typedef GenericUri<ValueType, Allocator> UriType;
1325      friend class internal::Schema<GenericSchemaDocument>;
1326      template <typename, typename, typename>
1327      friend class GenericSchemaValidator;
1328      explicit GenericSchemaDocument(const ValueType& document, const Ch* uri = 0, SizeType uriLength = 0,
1329          IRemoteSchemaDocumentProviderType* remoteProvider = 0, Allocator* allocator = 0,
1330          const PointerType& pointer = PointerType()) :  
1331          remoteProvider_(remoteProvider),
1332          allocator_(allocator),
1333          ownAllocator_(),
1334          root_(),
1335          typeless_(),
1336          schemaMap_(allocator, kInitialSchemaMapSize),
1337          schemaRef_(allocator, kInitialSchemaRefSize)
1338      {
1339          if (!allocator_)
1340              ownAllocator_ = allocator_ = RAPIDJSON_NEW(Allocator)();
1341          Ch noUri[1] = {0};
1342          uri_.SetString(uri ? uri : noUri, uriLength, *allocator_);
1343          docId_ = UriType(uri_, allocator_);
1344          typeless_ = static_cast<SchemaType*>(allocator_->Malloc(sizeof(SchemaType)));
1345          new (typeless_) SchemaType(this, PointerType(), ValueType(kObjectType).Move(), ValueType(kObjectType).Move(), allocator_, docId_);
1346          root_ = typeless_;
1347          if (pointer.GetTokenCount() == 0) {
1348              CreateSchemaRecursive(&root_, pointer, document, document, docId_);
1349          }
1350          else if (const ValueType* v = pointer.Get(document)) {
1351              CreateSchema(&root_, pointer, *v, document, docId_);
1352          }
1353          RAPIDJSON_ASSERT(root_ != 0);
1354          schemaRef_.ShrinkToFit(); 
1355      }
1356  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
1357      GenericSchemaDocument(GenericSchemaDocument&& rhs) RAPIDJSON_NOEXCEPT :
1358          remoteProvider_(rhs.remoteProvider_),
1359          allocator_(rhs.allocator_),
1360          ownAllocator_(rhs.ownAllocator_),
1361          root_(rhs.root_),
1362          typeless_(rhs.typeless_),
1363          schemaMap_(std::move(rhs.schemaMap_)),
1364          schemaRef_(std::move(rhs.schemaRef_)),
1365          uri_(std::move(rhs.uri_)),
1366          docId_(rhs.docId_)
1367      {
1368          rhs.remoteProvider_ = 0;
1369          rhs.allocator_ = 0;
1370          rhs.ownAllocator_ = 0;
1371          rhs.typeless_ = 0;
1372      }
1373  #endif
1374      ~GenericSchemaDocument() {
1375          while (!schemaMap_.Empty())
1376              schemaMap_.template Pop<SchemaEntry>(1)->~SchemaEntry();
1377          if (typeless_) {
1378              typeless_->~SchemaType();
1379              Allocator::Free(typeless_);
1380          }
1381          RAPIDJSON_DELETE(ownAllocator_);
1382      }
1383      const SValue& GetURI() const { return uri_; }
1384      const SchemaType& GetRoot() const { return *root_; }
1385  private:
1386      GenericSchemaDocument(const GenericSchemaDocument&);
1387      GenericSchemaDocument& operator=(const GenericSchemaDocument&);
1388      typedef const PointerType* SchemaRefPtr; 
1389      struct SchemaEntry {
1390          SchemaEntry(const PointerType& p, SchemaType* s, bool o, Allocator* allocator) : pointer(p, allocator), schema(s), owned(o) {}
1391          ~SchemaEntry() {
1392              if (owned) {
1393                  schema->~SchemaType();
1394                  Allocator::Free(schema);
1395              }
1396          }
1397          PointerType pointer;
1398          SchemaType* schema;
1399          bool owned;
1400      };
1401      void CreateSchemaRecursive(const SchemaType** schema, const PointerType& pointer, const ValueType& v, const ValueType& document, const UriType& id) {
1402          if (v.GetType() == kObjectType) {
1403              UriType newid = UriType(CreateSchema(schema, pointer, v, document, id), allocator_);
1404              for (typename ValueType::ConstMemberIterator itr = v.MemberBegin(); itr != v.MemberEnd(); ++itr)
1405                  CreateSchemaRecursive(0, pointer.Append(itr->name, allocator_), itr->value, document, newid);
1406          }
1407          else if (v.GetType() == kArrayType)
1408              for (SizeType i = 0; i < v.Size(); i++)
1409                  CreateSchemaRecursive(0, pointer.Append(i, allocator_), v[i], document, id);
1410      }
1411      const UriType& CreateSchema(const SchemaType** schema, const PointerType& pointer, const ValueType& v, const ValueType& document, const UriType& id) {
1412          RAPIDJSON_ASSERT(pointer.IsValid());
1413          if (v.IsObject()) {
1414              if (const SchemaType* sc = GetSchema(pointer)) {
1415                  if (schema)
1416                      *schema = sc;
1417                  AddSchemaRefs(const_cast<SchemaType*>(sc));
1418              }
1419              else if (!HandleRefSchema(pointer, schema, v, document, id)) {
1420                  SchemaType* s = new (allocator_->Malloc(sizeof(SchemaType))) SchemaType(this, pointer, v, document, allocator_, id);
1421                  if (schema)
1422                      *schema = s;
1423                  return s->GetId();
1424              }
1425          }
1426          else {
1427              if (schema)
1428                  *schema = typeless_;
1429              AddSchemaRefs(typeless_);
1430          }
1431          return id;
1432      }
1433      bool HandleRefSchema(const PointerType& source, const SchemaType** schema, const ValueType& v, const ValueType& document, const UriType& id) {
1434          typename ValueType::ConstMemberIterator itr = v.FindMember(SchemaType::GetRefString());
1435          if (itr == v.MemberEnd())
1436              return false;
1437          new (schemaRef_.template Push<SchemaRefPtr>()) SchemaRefPtr(&source);
1438          if (itr->value.IsString()) {
1439              SizeType len = itr->value.GetStringLength();
1440              if (len > 0) {
1441                  UriType scopeId = UriType(id, allocator_);
1442                  UriType ref = UriType(itr->value, allocator_).Resolve(scopeId, allocator_);
1443                  PointerType basePointer = PointerType();
1444                  const ValueType *base = FindId(document, ref, basePointer, docId_, false);
1445                  if (!base) {
1446                      if (remoteProvider_) {
1447                          if (const GenericSchemaDocument* remoteDocument = remoteProvider_->GetRemoteDocument(ref)) {
1448                              const Ch* s = ref.GetFragString();
1449                              len = ref.GetFragStringLength();
1450                              if (len <= 1 || s[1] == '/') {
1451                                  const PointerType pointer(s, len, allocator_);
1452                                  if (pointer.IsValid()) {
1453                                      if (const SchemaType *sc = remoteDocument->GetSchema(pointer)) {
1454                                          if (schema)
1455                                              *schema = sc;
1456                                          AddSchemaRefs(const_cast<SchemaType *>(sc));
1457                                          return true;
1458                                      }
1459                                  }
1460                            } else {
1461                            }
1462                          }
1463                      }
1464                  }
1465                  else { 
1466                      const Ch* s = ref.GetFragString();
1467                      len = ref.GetFragStringLength();
1468                      if (len <= 1 || s[1] == '/') {
1469                          const PointerType relPointer(s, len, allocator_);
1470                          if (relPointer.IsValid()) {
1471                              if (const ValueType *pv = relPointer.Get(*base)) {
1472                                  PointerType pointer(basePointer);
1473                                  for (SizeType i = 0; i < relPointer.GetTokenCount(); i++)
1474                                      pointer = pointer.Append(relPointer.GetTokens()[i], allocator_);
1475                                  if (pointer.IsValid() && !IsCyclicRef(pointer)) {
1476                                      size_t unresolvedTokenIndex;
1477                                      scopeId = pointer.GetUri(document, docId_, &unresolvedTokenIndex, allocator_);
1478                                      CreateSchema(schema, pointer, *pv, document, scopeId);
1479                                      return true;
1480                                  }
1481                              }
1482                          }
1483                      } else {
1484                          PointerType pointer = PointerType();
1485                          if (const ValueType *pv = FindId(*base, ref, pointer, UriType(ref.GetBaseString(), ref.GetBaseStringLength(), allocator_), true, basePointer)) {
1486                              if (!IsCyclicRef(pointer)) {
1487                                  size_t unresolvedTokenIndex;
1488                                  scopeId = pointer.GetUri(document, docId_, &unresolvedTokenIndex, allocator_);
1489                                  CreateSchema(schema, pointer, *pv, document, scopeId);
1490                                  return true;
1491                              }
1492                          }
1493                      }
1494                  }
1495              }
1496          }
1497          if (schema)
1498              *schema = typeless_;
1499          AddSchemaRefs(typeless_);
1500          return true;
1501      }
1502      ValueType* FindId(const ValueType& doc, const UriType& finduri, PointerType& resptr, const UriType& baseuri, bool full, const PointerType& here = PointerType()) const {
1503          SizeType i = 0;
1504          ValueType* resval = 0;
1505          UriType tempuri = UriType(finduri, allocator_);
1506          UriType localuri = UriType(baseuri, allocator_);
1507          if (doc.GetType() == kObjectType) {
1508              typename ValueType::ConstMemberIterator m = doc.FindMember(SchemaType::GetIdString());
1509              if (m != doc.MemberEnd() && m->value.GetType() == kStringType) {
1510                  localuri = UriType(m->value, allocator_).Resolve(baseuri, allocator_);
1511              }
1512              if (localuri.Match(finduri, full)) {
1513                  resval = const_cast<ValueType *>(&doc);
1514                  resptr = here;
1515                  return resval;
1516              }
1517              for (m = doc.MemberBegin(); m != doc.MemberEnd(); ++m) {
1518                  if (m->value.GetType() == kObjectType || m->value.GetType() == kArrayType) {
1519                      resval = FindId(m->value, finduri, resptr, localuri, full, here.Append(m->name.GetString(), m->name.GetStringLength(), allocator_));
1520                  }
1521                  if (resval) break;
1522              }
1523          } else if (doc.GetType() == kArrayType) {
1524              for (typename ValueType::ConstValueIterator v = doc.Begin(); v != doc.End(); ++v) {
1525                  if (v->GetType() == kObjectType || v->GetType() == kArrayType) {
1526                      resval = FindId(*v, finduri, resptr, localuri, full, here.Append(i, allocator_));
1527                  }
1528                  if (resval) break;
1529                  i++;
1530              }
1531          }
1532          return resval;
1533      }
1534      void AddSchemaRefs(SchemaType* schema) {
1535          while (!schemaRef_.Empty()) {
1536              SchemaRefPtr *ref = schemaRef_.template Pop<SchemaRefPtr>(1);
1537              SchemaEntry *entry = schemaMap_.template Push<SchemaEntry>();
1538              new (entry) SchemaEntry(**ref, schema, false, allocator_);
1539          }
1540      }
1541      bool IsCyclicRef(const PointerType& pointer) const {
1542          for (const SchemaRefPtr* ref = schemaRef_.template Bottom<SchemaRefPtr>(); ref != schemaRef_.template End<SchemaRefPtr>(); ++ref)
1543              if (pointer == **ref)
1544                  return true;
1545          return false;
1546      }
1547      const SchemaType* GetSchema(const PointerType& pointer) const {
1548          for (const SchemaEntry* target = schemaMap_.template Bottom<SchemaEntry>(); target != schemaMap_.template End<SchemaEntry>(); ++target)
1549              if (pointer == target->pointer)
1550                  return target->schema;
1551          return 0;
1552      }
1553      PointerType GetPointer(const SchemaType* schema) const {
1554          for (const SchemaEntry* target = schemaMap_.template Bottom<SchemaEntry>(); target != schemaMap_.template End<SchemaEntry>(); ++target)
1555              if (schema == target->schema)
1556                  return target->pointer;
1557          return PointerType();
1558      }
1559      const SchemaType* GetTypeless() const { return typeless_; }
1560      static const size_t kInitialSchemaMapSize = 64;
1561      static const size_t kInitialSchemaRefSize = 64;
1562      IRemoteSchemaDocumentProviderType* remoteProvider_;
1563      Allocator *allocator_;
1564      Allocator *ownAllocator_;
1565      const SchemaType* root_;                
1566      SchemaType* typeless_;
1567      internal::Stack<Allocator> schemaMap_;  
1568      internal::Stack<Allocator> schemaRef_;  
1569      SValue uri_;                            
1570      UriType docId_;
1571  };
1572  typedef GenericSchemaDocument<Value> SchemaDocument;
1573  typedef IGenericRemoteSchemaDocumentProvider<SchemaDocument> IRemoteSchemaDocumentProvider;
1574  template <
1575      typename SchemaDocumentType,
1576      typename OutputHandler = BaseReaderHandler<typename SchemaDocumentType::SchemaType::EncodingType>,
1577      typename StateAllocator = CrtAllocator>
1578  class GenericSchemaValidator :
1579      public internal::ISchemaStateFactory<typename SchemaDocumentType::SchemaType>,
1580      public internal::ISchemaValidator,
1581      public internal::IValidationErrorHandler<typename SchemaDocumentType::SchemaType> {
1582  public:
1583      typedef typename SchemaDocumentType::SchemaType SchemaType;
1584      typedef typename SchemaDocumentType::PointerType PointerType;
1585      typedef typename SchemaType::EncodingType EncodingType;
1586      typedef typename SchemaType::SValue SValue;
1587      typedef typename EncodingType::Ch Ch;
1588      typedef GenericStringRef<Ch> StringRefType;
1589      typedef GenericValue<EncodingType, StateAllocator> ValueType;
1590      GenericSchemaValidator(
1591          const SchemaDocumentType& schemaDocument,
1592          StateAllocator* allocator = 0,
1593          size_t schemaStackCapacity = kDefaultSchemaStackCapacity,
1594          size_t documentStackCapacity = kDefaultDocumentStackCapacity)
1595          :
1596          schemaDocument_(&schemaDocument),
1597          root_(schemaDocument.GetRoot()),
1598          stateAllocator_(allocator),
1599          ownStateAllocator_(0),
1600          schemaStack_(allocator, schemaStackCapacity),
1601          documentStack_(allocator, documentStackCapacity),
1602          outputHandler_(0),
1603          error_(kObjectType),
1604          currentError_(),
1605          missingDependents_(),
1606          valid_(true),
1607          flags_(kValidateDefaultFlags)
1608  #if RAPIDJSON_SCHEMA_VERBOSE
1609          , depth_(0)
1610  #endif
1611      {
1612      }
1613      GenericSchemaValidator(
1614          const SchemaDocumentType& schemaDocument,
1615          OutputHandler& outputHandler,
1616          StateAllocator* allocator = 0,
1617          size_t schemaStackCapacity = kDefaultSchemaStackCapacity,
1618          size_t documentStackCapacity = kDefaultDocumentStackCapacity)
1619          :
1620          schemaDocument_(&schemaDocument),
1621          root_(schemaDocument.GetRoot()),
1622          stateAllocator_(allocator),
1623          ownStateAllocator_(0),
1624          schemaStack_(allocator, schemaStackCapacity),
1625          documentStack_(allocator, documentStackCapacity),
1626          outputHandler_(&outputHandler),
1627          error_(kObjectType),
1628          currentError_(),
1629          missingDependents_(),
1630          valid_(true),
1631          flags_(kValidateDefaultFlags)
1632  #if RAPIDJSON_SCHEMA_VERBOSE
1633          , depth_(0)
1634  #endif
1635      {
1636      }
1637      ~GenericSchemaValidator() {
1638          Reset();
1639          RAPIDJSON_DELETE(ownStateAllocator_);
1640      }
1641      void Reset() {
1642          while (!schemaStack_.Empty())
1643              PopSchema();
1644          documentStack_.Clear();
1645          ResetError();
1646      }
1647      void ResetError() {
1648          error_.SetObject();
1649          currentError_.SetNull();
1650          missingDependents_.SetNull();
1651          valid_ = true;
1652      }
1653      void SetValidateFlags(unsigned flags) {
1654          flags_ = flags;
1655      }
1656      virtual unsigned GetValidateFlags() const {
1657          return flags_;
1658      }
1659      virtual bool IsValid() const {
1660          if (!valid_) return false;
1661          if (GetContinueOnErrors() && !error_.ObjectEmpty()) return false;
1662          return true;
1663      }
1664      ValueType& GetError() { return error_; }
1665      const ValueType& GetError() const { return error_; }
1666      PointerType GetInvalidSchemaPointer() const {
1667          return schemaStack_.Empty() ? PointerType() : CurrentSchema().GetPointer();
1668      }
1669      const Ch* GetInvalidSchemaKeyword() const {
1670          if (!schemaStack_.Empty()) return CurrentContext().invalidKeyword;
1671          if (GetContinueOnErrors() && !error_.ObjectEmpty()) return (const Ch*)GetErrorsString();
1672          return 0;
1673      }
1674      ValidateErrorCode GetInvalidSchemaCode() const {
1675          if (!schemaStack_.Empty()) return CurrentContext().invalidCode;
1676          if (GetContinueOnErrors() && !error_.ObjectEmpty()) return kValidateErrors;
1677          return kValidateErrorNone;
1678      }
1679      PointerType GetInvalidDocumentPointer() const {
1680          if (documentStack_.Empty()) {
1681              return PointerType();
1682          }
1683          else {
1684              return PointerType(documentStack_.template Bottom<Ch>(), documentStack_.GetSize() / sizeof(Ch));
1685          }
1686      }
1687      void NotMultipleOf(int64_t actual, const SValue& expected) {
1688          AddNumberError(kValidateErrorMultipleOf, ValueType(actual).Move(), expected);
1689      }
1690      void NotMultipleOf(uint64_t actual, const SValue& expected) {
1691          AddNumberError(kValidateErrorMultipleOf, ValueType(actual).Move(), expected);
1692      }
1693      void NotMultipleOf(double actual, const SValue& expected) {
1694          AddNumberError(kValidateErrorMultipleOf, ValueType(actual).Move(), expected);
1695      }
1696      void AboveMaximum(int64_t actual, const SValue& expected, bool exclusive) {
1697          AddNumberError(exclusive ? kValidateErrorExclusiveMaximum : kValidateErrorMaximum, ValueType(actual).Move(), expected,
1698              exclusive ? &SchemaType::GetExclusiveMaximumString : 0);
1699      }
1700      void AboveMaximum(uint64_t actual, const SValue& expected, bool exclusive) {
1701          AddNumberError(exclusive ? kValidateErrorExclusiveMaximum : kValidateErrorMaximum, ValueType(actual).Move(), expected,
1702              exclusive ? &SchemaType::GetExclusiveMaximumString : 0);
1703      }
1704      void AboveMaximum(double actual, const SValue& expected, bool exclusive) {
1705          AddNumberError(exclusive ? kValidateErrorExclusiveMaximum : kValidateErrorMaximum, ValueType(actual).Move(), expected,
1706              exclusive ? &SchemaType::GetExclusiveMaximumString : 0);
1707      }
1708      void BelowMinimum(int64_t actual, const SValue& expected, bool exclusive) {
1709          AddNumberError(exclusive ? kValidateErrorExclusiveMinimum : kValidateErrorMinimum, ValueType(actual).Move(), expected,
1710              exclusive ? &SchemaType::GetExclusiveMinimumString : 0);
1711      }
1712      void BelowMinimum(uint64_t actual, const SValue& expected, bool exclusive) {
1713          AddNumberError(exclusive ? kValidateErrorExclusiveMinimum : kValidateErrorMinimum, ValueType(actual).Move(), expected,
1714              exclusive ? &SchemaType::GetExclusiveMinimumString : 0);
1715      }
1716      void BelowMinimum(double actual, const SValue& expected, bool exclusive) {
1717          AddNumberError(exclusive ? kValidateErrorExclusiveMinimum : kValidateErrorMinimum, ValueType(actual).Move(), expected,
1718              exclusive ? &SchemaType::GetExclusiveMinimumString : 0);
1719      }
1720      void TooLong(const Ch* str, SizeType length, SizeType expected) {
1721          AddNumberError(kValidateErrorMaxLength,
1722              ValueType(str, length, GetStateAllocator()).Move(), SValue(expected).Move());
1723      }
1724      void TooShort(const Ch* str, SizeType length, SizeType expected) {
1725          AddNumberError(kValidateErrorMinLength,
1726              ValueType(str, length, GetStateAllocator()).Move(), SValue(expected).Move());
1727      }
1728      void DoesNotMatch(const Ch* str, SizeType length) {
1729          currentError_.SetObject();
1730          currentError_.AddMember(GetActualString(), ValueType(str, length, GetStateAllocator()).Move(), GetStateAllocator());
1731          AddCurrentError(kValidateErrorPattern);
1732      }
1733      void DisallowedItem(SizeType index) {
1734          currentError_.SetObject();
1735          currentError_.AddMember(GetDisallowedString(), ValueType(index).Move(), GetStateAllocator());
1736          AddCurrentError(kValidateErrorAdditionalItems, true);
1737      }
1738      void TooFewItems(SizeType actualCount, SizeType expectedCount) {
1739          AddNumberError(kValidateErrorMinItems,
1740              ValueType(actualCount).Move(), SValue(expectedCount).Move());
1741      }
1742      void TooManyItems(SizeType actualCount, SizeType expectedCount) {
1743          AddNumberError(kValidateErrorMaxItems,
1744              ValueType(actualCount).Move(), SValue(expectedCount).Move());
1745      }
1746      void DuplicateItems(SizeType index1, SizeType index2) {
1747          ValueType duplicates(kArrayType);
1748          duplicates.PushBack(index1, GetStateAllocator());
1749          duplicates.PushBack(index2, GetStateAllocator());
1750          currentError_.SetObject();
1751          currentError_.AddMember(GetDuplicatesString(), duplicates, GetStateAllocator());
1752          AddCurrentError(kValidateErrorUniqueItems, true);
1753      }
1754      void TooManyProperties(SizeType actualCount, SizeType expectedCount) {
1755          AddNumberError(kValidateErrorMaxProperties,
1756              ValueType(actualCount).Move(), SValue(expectedCount).Move());
1757      }
1758      void TooFewProperties(SizeType actualCount, SizeType expectedCount) {
1759          AddNumberError(kValidateErrorMinProperties,
1760              ValueType(actualCount).Move(), SValue(expectedCount).Move());
1761      }
1762      void StartMissingProperties() {
1763          currentError_.SetArray();
1764      }
1765      void AddMissingProperty(const SValue& name) {
<span onclick='openModal()' class='match'>1766          currentError_.PushBack(ValueType(name, GetStateAllocator()).Move(), GetStateAllocator());
1767      }
1768      bool EndMissingProperties() {
</span>1769          if (currentError_.Empty())
1770              return false;
1771          ValueType error(kObjectType);
1772          error.AddMember(GetMissingString(), currentError_, GetStateAllocator());
1773          currentError_ = error;
1774          AddCurrentError(kValidateErrorRequired);
1775          return true;
1776      }
1777      void PropertyViolations(ISchemaValidator** subvalidators, SizeType count) {
1778          for (SizeType i = 0; i < count; ++i)
1779              MergeError(static_cast<GenericSchemaValidator*>(subvalidators[i])->GetError());
1780      }
1781      void DisallowedProperty(const Ch* name, SizeType length) {
1782          currentError_.SetObject();
1783          currentError_.AddMember(GetDisallowedString(), ValueType(name, length, GetStateAllocator()).Move(), GetStateAllocator());
1784          AddCurrentError(kValidateErrorAdditionalProperties, true);
1785      }
1786      void StartDependencyErrors() {
1787          currentError_.SetObject();
1788      }
1789      void StartMissingDependentProperties() {
1790          missingDependents_.SetArray();
1791      }
1792      void AddMissingDependentProperty(const SValue& targetName) {
1793          missingDependents_.PushBack(ValueType(targetName, GetStateAllocator()).Move(), GetStateAllocator());
1794      }
1795      void EndMissingDependentProperties(const SValue& sourceName) {
1796          if (!missingDependents_.Empty()) {
1797              ValueType error(kObjectType);
1798              ValidateErrorCode code = kValidateErrorRequired;
1799              error.AddMember(GetMissingString(), missingDependents_.Move(), GetStateAllocator());
1800              AddErrorCode(error, code);
1801              AddErrorInstanceLocation(error, false);
1802              PointerType schemaRef = GetInvalidSchemaPointer().Append(SchemaType::GetValidateErrorKeyword(kValidateErrorDependencies), &GetInvalidSchemaPointer().GetAllocator());
1803              AddErrorSchemaLocation(error, schemaRef.Append(sourceName.GetString(), sourceName.GetStringLength(), &GetInvalidSchemaPointer().GetAllocator()));
1804              ValueType wrapper(kObjectType);
1805              wrapper.AddMember(ValueType(SchemaType::GetValidateErrorKeyword(code), GetStateAllocator()).Move(), error, GetStateAllocator());
1806              currentError_.AddMember(ValueType(sourceName, GetStateAllocator()).Move(), wrapper, GetStateAllocator());
1807          }
1808      }
1809      void AddDependencySchemaError(const SValue& sourceName, ISchemaValidator* subvalidator) {
1810          currentError_.AddMember(ValueType(sourceName, GetStateAllocator()).Move(),
1811              static_cast<GenericSchemaValidator*>(subvalidator)->GetError(), GetStateAllocator());
1812      }
1813      bool EndDependencyErrors() {
1814          if (currentError_.ObjectEmpty())
1815              return false;
1816          ValueType error(kObjectType);
1817          error.AddMember(GetErrorsString(), currentError_, GetStateAllocator());
1818          currentError_ = error;
1819          AddCurrentError(kValidateErrorDependencies);
1820          return true;
1821      }
1822      void DisallowedValue(const ValidateErrorCode code = kValidateErrorEnum) {
1823          currentError_.SetObject();
1824          AddCurrentError(code);
1825      }
1826      void StartDisallowedType() {
1827          currentError_.SetArray();
1828      }
1829      void AddExpectedType(const typename SchemaType::ValueType& expectedType) {
1830          currentError_.PushBack(ValueType(expectedType, GetStateAllocator()).Move(), GetStateAllocator());
1831      }
1832      void EndDisallowedType(const typename SchemaType::ValueType& actualType) {
1833          ValueType error(kObjectType);
1834          error.AddMember(GetExpectedString(), currentError_, GetStateAllocator());
1835          error.AddMember(GetActualString(), ValueType(actualType, GetStateAllocator()).Move(), GetStateAllocator());
1836          currentError_ = error;
1837          AddCurrentError(kValidateErrorType);
1838      }
1839      void NotAllOf(ISchemaValidator** subvalidators, SizeType count) {
1840          AddErrorArray(kValidateErrorAllOf, subvalidators, count);
1841      }
1842      void NoneOf(ISchemaValidator** subvalidators, SizeType count) {
1843          AddErrorArray(kValidateErrorAnyOf, subvalidators, count);
1844      }
1845      void NotOneOf(ISchemaValidator** subvalidators, SizeType count, bool matched = false) {
1846          AddErrorArray(matched ? kValidateErrorOneOfMatch : kValidateErrorOneOf, subvalidators, count);
1847      }
1848      void Disallowed() {
1849          currentError_.SetObject();
1850          AddCurrentError(kValidateErrorNot);
1851      }
1852  #define RAPIDJSON_STRING_(name, ...) \
1853      static const StringRefType& Get##name##String() {\
1854          static const Ch s[] = { __VA_ARGS__, '\0' };\
1855          static const StringRefType v(s, static_cast<SizeType>(sizeof(s) / sizeof(Ch) - 1)); \
1856          return v;\
1857      }
1858      RAPIDJSON_STRING_(InstanceRef, 'i', 'n', 's', 't', 'a', 'n', 'c', 'e', 'R', 'e', 'f')
1859      RAPIDJSON_STRING_(SchemaRef, 's', 'c', 'h', 'e', 'm', 'a', 'R', 'e', 'f')
1860      RAPIDJSON_STRING_(Expected, 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd')
1861      RAPIDJSON_STRING_(Actual, 'a', 'c', 't', 'u', 'a', 'l')
1862      RAPIDJSON_STRING_(Disallowed, 'd', 'i', 's', 'a', 'l', 'l', 'o', 'w', 'e', 'd')
1863      RAPIDJSON_STRING_(Missing, 'm', 'i', 's', 's', 'i', 'n', 'g')
1864      RAPIDJSON_STRING_(Errors, 'e', 'r', 'r', 'o', 'r', 's')
1865      RAPIDJSON_STRING_(ErrorCode, 'e', 'r', 'r', 'o', 'r', 'C', 'o', 'd', 'e')
1866      RAPIDJSON_STRING_(ErrorMessage, 'e', 'r', 'r', 'o', 'r', 'M', 'e', 's', 's', 'a', 'g', 'e')
1867      RAPIDJSON_STRING_(Duplicates, 'd', 'u', 'p', 'l', 'i', 'c', 'a', 't', 'e', 's')
1868  #undef RAPIDJSON_STRING_
1869  #if RAPIDJSON_SCHEMA_VERBOSE
1870  #define RAPIDJSON_SCHEMA_HANDLE_BEGIN_VERBOSE_() \
1871  RAPIDJSON_MULTILINEMACRO_BEGIN\
1872      *documentStack_.template Push<Ch>() = '\0';\
1873      documentStack_.template Pop<Ch>(1);\
1874      internal::PrintInvalidDocument(documentStack_.template Bottom<Ch>());\
1875  RAPIDJSON_MULTILINEMACRO_END
1876  #else
1877  #define RAPIDJSON_SCHEMA_HANDLE_BEGIN_VERBOSE_()
1878  #endif
1879  #define RAPIDJSON_SCHEMA_HANDLE_BEGIN_(method, arg1)\
1880      if (!valid_) return false; \
1881      if ((!BeginValue() && !GetContinueOnErrors()) || (!CurrentSchema().method arg1 && !GetContinueOnErrors())) {\
1882          RAPIDJSON_SCHEMA_HANDLE_BEGIN_VERBOSE_();\
1883          return valid_ = false;\
1884      }
1885  #define RAPIDJSON_SCHEMA_HANDLE_PARALLEL_(method, arg2)\
1886      for (Context* context = schemaStack_.template Bottom<Context>(); context != schemaStack_.template End<Context>(); context++) {\
1887          if (context->hasher)\
1888              static_cast<HasherType*>(context->hasher)->method arg2;\
1889          if (context->validators)\
1890              for (SizeType i_ = 0; i_ < context->validatorCount; i_++)\
1891                  static_cast<GenericSchemaValidator*>(context->validators[i_])->method arg2;\
1892          if (context->patternPropertiesValidators)\
1893              for (SizeType i_ = 0; i_ < context->patternPropertiesValidatorCount; i_++)\
1894                  static_cast<GenericSchemaValidator*>(context->patternPropertiesValidators[i_])->method arg2;\
1895      }
1896  #define RAPIDJSON_SCHEMA_HANDLE_END_(method, arg2)\
1897      valid_ = (EndValue() || GetContinueOnErrors()) && (!outputHandler_ || outputHandler_->method arg2);\
1898      return valid_;
1899  #define RAPIDJSON_SCHEMA_HANDLE_VALUE_(method, arg1, arg2) \
1900      RAPIDJSON_SCHEMA_HANDLE_BEGIN_   (method, arg1);\
1901      RAPIDJSON_SCHEMA_HANDLE_PARALLEL_(method, arg2);\
1902      RAPIDJSON_SCHEMA_HANDLE_END_     (method, arg2)
1903      bool Null()             { RAPIDJSON_SCHEMA_HANDLE_VALUE_(Null,   (CurrentContext()), ( )); }
1904      bool Bool(bool b)       { RAPIDJSON_SCHEMA_HANDLE_VALUE_(Bool,   (CurrentContext(), b), (b)); }
1905      bool Int(int i)         { RAPIDJSON_SCHEMA_HANDLE_VALUE_(Int,    (CurrentContext(), i), (i)); }
1906      bool Uint(unsigned u)   { RAPIDJSON_SCHEMA_HANDLE_VALUE_(Uint,   (CurrentContext(), u), (u)); }
1907      bool Int64(int64_t i)   { RAPIDJSON_SCHEMA_HANDLE_VALUE_(Int64,  (CurrentContext(), i), (i)); }
1908      bool Uint64(uint64_t u) { RAPIDJSON_SCHEMA_HANDLE_VALUE_(Uint64, (CurrentContext(), u), (u)); }
1909      bool Double(double d)   { RAPIDJSON_SCHEMA_HANDLE_VALUE_(Double, (CurrentContext(), d), (d)); }
1910      bool RawNumber(const Ch* str, SizeType length, bool copy)
1911                                      { RAPIDJSON_SCHEMA_HANDLE_VALUE_(String, (CurrentContext(), str, length, copy), (str, length, copy)); }
1912      bool String(const Ch* str, SizeType length, bool copy)
1913                                      { RAPIDJSON_SCHEMA_HANDLE_VALUE_(String, (CurrentContext(), str, length, copy), (str, length, copy)); }
1914      bool StartObject() {
1915          RAPIDJSON_SCHEMA_HANDLE_BEGIN_(StartObject, (CurrentContext()));
1916          RAPIDJSON_SCHEMA_HANDLE_PARALLEL_(StartObject, ());
1917          return valid_ = !outputHandler_ || outputHandler_->StartObject();
1918      }
1919      bool Key(const Ch* str, SizeType len, bool copy) {
1920          if (!valid_) return false;
1921          AppendToken(str, len);
1922          if (!CurrentSchema().Key(CurrentContext(), str, len, copy) && !GetContinueOnErrors()) return valid_ = false;
1923          RAPIDJSON_SCHEMA_HANDLE_PARALLEL_(Key, (str, len, copy));
1924          return valid_ = !outputHandler_ || outputHandler_->Key(str, len, copy);
1925      }
1926      bool EndObject(SizeType memberCount) {
1927          if (!valid_) return false;
1928          RAPIDJSON_SCHEMA_HANDLE_PARALLEL_(EndObject, (memberCount));
1929          if (!CurrentSchema().EndObject(CurrentContext(), memberCount) && !GetContinueOnErrors()) return valid_ = false;
1930          RAPIDJSON_SCHEMA_HANDLE_END_(EndObject, (memberCount));
1931      }
1932      bool StartArray() {
1933          RAPIDJSON_SCHEMA_HANDLE_BEGIN_(StartArray, (CurrentContext()));
1934          RAPIDJSON_SCHEMA_HANDLE_PARALLEL_(StartArray, ());
1935          return valid_ = !outputHandler_ || outputHandler_->StartArray();
1936      }
1937      bool EndArray(SizeType elementCount) {
1938          if (!valid_) return false;
1939          RAPIDJSON_SCHEMA_HANDLE_PARALLEL_(EndArray, (elementCount));
1940          if (!CurrentSchema().EndArray(CurrentContext(), elementCount) && !GetContinueOnErrors()) return valid_ = false;
1941          RAPIDJSON_SCHEMA_HANDLE_END_(EndArray, (elementCount));
1942      }
1943  #undef RAPIDJSON_SCHEMA_HANDLE_BEGIN_VERBOSE_
1944  #undef RAPIDJSON_SCHEMA_HANDLE_BEGIN_
1945  #undef RAPIDJSON_SCHEMA_HANDLE_PARALLEL_
1946  #undef RAPIDJSON_SCHEMA_HANDLE_VALUE_
1947      virtual ISchemaValidator* CreateSchemaValidator(const SchemaType& root, const bool inheritContinueOnErrors) {
1948          ISchemaValidator* sv = new (GetStateAllocator().Malloc(sizeof(GenericSchemaValidator))) GenericSchemaValidator(*schemaDocument_, root, documentStack_.template Bottom<char>(), documentStack_.GetSize(),
1949  #if RAPIDJSON_SCHEMA_VERBOSE
1950          depth_ + 1,
1951  #endif
1952          &GetStateAllocator());
1953          sv->SetValidateFlags(inheritContinueOnErrors ? GetValidateFlags() : GetValidateFlags() & ~(unsigned)kValidateContinueOnErrorFlag);
1954          return sv;
1955      }
1956      virtual void DestroySchemaValidator(ISchemaValidator* validator) {
1957          GenericSchemaValidator* v = static_cast<GenericSchemaValidator*>(validator);
1958          v->~GenericSchemaValidator();
1959          StateAllocator::Free(v);
1960      }
1961      virtual void* CreateHasher() {
1962          return new (GetStateAllocator().Malloc(sizeof(HasherType))) HasherType(&GetStateAllocator());
1963      }
1964      virtual uint64_t GetHashCode(void* hasher) {
1965          return static_cast<HasherType*>(hasher)->GetHashCode();
1966      }
1967      virtual void DestroryHasher(void* hasher) {
1968          HasherType* h = static_cast<HasherType*>(hasher);
1969          h->~HasherType();
1970          StateAllocator::Free(h);
1971      }
1972      virtual void* MallocState(size_t size) {
1973          return GetStateAllocator().Malloc(size);
1974      }
1975      virtual void FreeState(void* p) {
1976          StateAllocator::Free(p);
1977      }
1978  private:
1979      typedef typename SchemaType::Context Context;
1980      typedef GenericValue<UTF8<>, StateAllocator> HashCodeArray;
1981      typedef internal::Hasher<EncodingType, StateAllocator> HasherType;
1982      GenericSchemaValidator(
1983          const SchemaDocumentType& schemaDocument,
1984          const SchemaType& root,
1985          const char* basePath, size_t basePathSize,
1986  #if RAPIDJSON_SCHEMA_VERBOSE
1987          unsigned depth,
1988  #endif
1989          StateAllocator* allocator = 0,
1990          size_t schemaStackCapacity = kDefaultSchemaStackCapacity,
1991          size_t documentStackCapacity = kDefaultDocumentStackCapacity)
1992          :
1993          schemaDocument_(&schemaDocument),
1994          root_(root),
1995          stateAllocator_(allocator),
1996          ownStateAllocator_(0),
1997          schemaStack_(allocator, schemaStackCapacity),
1998          documentStack_(allocator, documentStackCapacity),
1999          outputHandler_(0),
2000          error_(kObjectType),
2001          currentError_(),
2002          missingDependents_(),
2003          valid_(true),
2004          flags_(kValidateDefaultFlags)
2005  #if RAPIDJSON_SCHEMA_VERBOSE
2006          , depth_(depth)
2007  #endif
2008      {
2009          if (basePath && basePathSize)
2010              memcpy(documentStack_.template Push<char>(basePathSize), basePath, basePathSize);
2011      }
2012      StateAllocator& GetStateAllocator() {
2013          if (!stateAllocator_)
2014              stateAllocator_ = ownStateAllocator_ = RAPIDJSON_NEW(StateAllocator)();
2015          return *stateAllocator_;
2016      }
2017      bool GetContinueOnErrors() const {
2018          return flags_ & kValidateContinueOnErrorFlag;
2019      }
2020      bool BeginValue() {
2021          if (schemaStack_.Empty())
2022              PushSchema(root_);
2023          else {
2024              if (CurrentContext().inArray)
2025                  internal::TokenHelper<internal::Stack<StateAllocator>, Ch>::AppendIndexToken(documentStack_, CurrentContext().arrayElementIndex);
2026              if (!CurrentSchema().BeginValue(CurrentContext()) && !GetContinueOnErrors())
2027                  return false;
2028              SizeType count = CurrentContext().patternPropertiesSchemaCount;
2029              const SchemaType** sa = CurrentContext().patternPropertiesSchemas;
2030              typename Context::PatternValidatorType patternValidatorType = CurrentContext().valuePatternValidatorType;
2031              bool valueUniqueness = CurrentContext().valueUniqueness;
2032              RAPIDJSON_ASSERT(CurrentContext().valueSchema);
2033              PushSchema(*CurrentContext().valueSchema);
2034              if (count > 0) {
2035                  CurrentContext().objectPatternValidatorType = patternValidatorType;
2036                  ISchemaValidator**& va = CurrentContext().patternPropertiesValidators;
2037                  SizeType& validatorCount = CurrentContext().patternPropertiesValidatorCount;
2038                  va = static_cast<ISchemaValidator**>(MallocState(sizeof(ISchemaValidator*) * count));
2039                  for (SizeType i = 0; i < count; i++)
2040                      va[validatorCount++] = CreateSchemaValidator(*sa[i], true);  
2041              }
2042              CurrentContext().arrayUniqueness = valueUniqueness;
2043          }
2044          return true;
2045      }
2046      bool EndValue() {
2047          if (!CurrentSchema().EndValue(CurrentContext()) && !GetContinueOnErrors())
2048              return false;
2049  #if RAPIDJSON_SCHEMA_VERBOSE
2050          GenericStringBuffer<EncodingType> sb;
2051          schemaDocument_->GetPointer(&CurrentSchema()).Stringify(sb);
2052          *documentStack_.template Push<Ch>() = '\0';
2053          documentStack_.template Pop<Ch>(1);
2054          internal::PrintValidatorPointers(depth_, sb.GetString(), documentStack_.template Bottom<Ch>());
2055  #endif
2056          void* hasher = CurrentContext().hasher;
2057          uint64_t h = hasher && CurrentContext().arrayUniqueness ? static_cast<HasherType*>(hasher)->GetHashCode() : 0;
2058          PopSchema();
2059          if (!schemaStack_.Empty()) {
2060              Context& context = CurrentContext();
2061              if (hasher && context.valueUniqueness) {
2062                  HashCodeArray* a = static_cast<HashCodeArray*>(context.arrayElementHashCodes);
2063                  if (!a)
2064                      CurrentContext().arrayElementHashCodes = a = new (GetStateAllocator().Malloc(sizeof(HashCodeArray))) HashCodeArray(kArrayType);
2065                  for (typename HashCodeArray::ConstValueIterator itr = a->Begin(); itr != a->End(); ++itr)
2066                      if (itr->GetUint64() == h) {
2067                          DuplicateItems(static_cast<SizeType>(itr - a->Begin()), a->Size());
2068                          if (GetContinueOnErrors()) {
2069                              a->PushBack(h, GetStateAllocator());
2070                              while (!documentStack_.Empty() && *documentStack_.template Pop<Ch>(1) != '/');
2071                          }
2072                          RAPIDJSON_INVALID_KEYWORD_RETURN(kValidateErrorUniqueItems);
2073                      }
2074                  a->PushBack(h, GetStateAllocator());
2075              }
2076          }
2077          while (!documentStack_.Empty() && *documentStack_.template Pop<Ch>(1) != '/')
2078              ;
2079          return true;
2080      }
2081      void AppendToken(const Ch* str, SizeType len) {
2082          documentStack_.template Reserve<Ch>(1 + len * 2); 
2083          *documentStack_.template PushUnsafe<Ch>() = '/';
2084          for (SizeType i = 0; i < len; i++) {
2085              if (str[i] == '~') {
2086                  *documentStack_.template PushUnsafe<Ch>() = '~';
2087                  *documentStack_.template PushUnsafe<Ch>() = '0';
2088              }
2089              else if (str[i] == '/') {
2090                  *documentStack_.template PushUnsafe<Ch>() = '~';
2091                  *documentStack_.template PushUnsafe<Ch>() = '1';
2092              }
2093              else
2094                  *documentStack_.template PushUnsafe<Ch>() = str[i];
2095          }
2096      }
2097      RAPIDJSON_FORCEINLINE void PushSchema(const SchemaType& schema) { new (schemaStack_.template Push<Context>()) Context(*this, *this, &schema); }
2098      RAPIDJSON_FORCEINLINE void PopSchema() {
2099          Context* c = schemaStack_.template Pop<Context>(1);
2100          if (HashCodeArray* a = static_cast<HashCodeArray*>(c->arrayElementHashCodes)) {
2101              a->~HashCodeArray();
2102              StateAllocator::Free(a);
2103          }
2104          c->~Context();
2105      }
2106      void AddErrorInstanceLocation(ValueType& result, bool parent) {
2107          GenericStringBuffer<EncodingType> sb;
2108          PointerType instancePointer = GetInvalidDocumentPointer();
2109          ((parent && instancePointer.GetTokenCount() > 0)
2110           ? PointerType(instancePointer.GetTokens(), instancePointer.GetTokenCount() - 1)
2111           : instancePointer).StringifyUriFragment(sb);
2112          ValueType instanceRef(sb.GetString(), static_cast<SizeType>(sb.GetSize() / sizeof(Ch)),
2113                                GetStateAllocator());
2114          result.AddMember(GetInstanceRefString(), instanceRef, GetStateAllocator());
2115      }
2116      void AddErrorSchemaLocation(ValueType& result, PointerType schema = PointerType()) {
2117          GenericStringBuffer<EncodingType> sb;
2118          SizeType len = CurrentSchema().GetURI().GetStringLength();
2119          if (len) memcpy(sb.Push(len), CurrentSchema().GetURI().GetString(), len * sizeof(Ch));
2120          if (schema.GetTokenCount()) schema.StringifyUriFragment(sb);
2121          else GetInvalidSchemaPointer().StringifyUriFragment(sb);
2122          ValueType schemaRef(sb.GetString(), static_cast<SizeType>(sb.GetSize() / sizeof(Ch)),
2123              GetStateAllocator());
2124          result.AddMember(GetSchemaRefString(), schemaRef, GetStateAllocator());
2125      }
2126      void AddErrorCode(ValueType& result, const ValidateErrorCode code) {
2127          result.AddMember(GetErrorCodeString(), code, GetStateAllocator());
2128      }
2129      void AddError(ValueType& keyword, ValueType& error) {
2130          typename ValueType::MemberIterator member = error_.FindMember(keyword);
2131          if (member == error_.MemberEnd())
2132              error_.AddMember(keyword, error, GetStateAllocator());
2133          else {
2134              if (member->value.IsObject()) {
2135                  ValueType errors(kArrayType);
2136                  errors.PushBack(member->value, GetStateAllocator());
2137                  member->value = errors;
2138              }
2139              member->value.PushBack(error, GetStateAllocator());
2140          }
2141      }
2142      void AddCurrentError(const ValidateErrorCode code, bool parent = false) {
2143          AddErrorCode(currentError_, code);
2144          AddErrorInstanceLocation(currentError_, parent);
2145          AddErrorSchemaLocation(currentError_);
2146          AddError(ValueType(SchemaType::GetValidateErrorKeyword(code), GetStateAllocator(), false).Move(), currentError_);
2147      }
2148      void MergeError(ValueType& other) {
2149          for (typename ValueType::MemberIterator it = other.MemberBegin(), end = other.MemberEnd(); it != end; ++it) {
2150              AddError(it->name, it->value);
2151          }
2152      }
2153      void AddNumberError(const ValidateErrorCode code, ValueType& actual, const SValue& expected,
2154          const typename SchemaType::ValueType& (*exclusive)() = 0) {
2155          currentError_.SetObject();
2156          currentError_.AddMember(GetActualString(), actual, GetStateAllocator());
2157          currentError_.AddMember(GetExpectedString(), ValueType(expected, GetStateAllocator()).Move(), GetStateAllocator());
2158          if (exclusive)
2159              currentError_.AddMember(ValueType(exclusive(), GetStateAllocator()).Move(), true, GetStateAllocator());
2160          AddCurrentError(code);
2161      }
2162      void AddErrorArray(const ValidateErrorCode code,
2163          ISchemaValidator** subvalidators, SizeType count) {
2164          ValueType errors(kArrayType);
2165          for (SizeType i = 0; i < count; ++i)
2166              errors.PushBack(static_cast<GenericSchemaValidator*>(subvalidators[i])->GetError(), GetStateAllocator());
2167          currentError_.SetObject();
2168          currentError_.AddMember(GetErrorsString(), errors, GetStateAllocator());
2169          AddCurrentError(code);
2170      }
2171      const SchemaType& CurrentSchema() const { return *schemaStack_.template Top<Context>()->schema; }
2172      Context& CurrentContext() { return *schemaStack_.template Top<Context>(); }
2173      const Context& CurrentContext() const { return *schemaStack_.template Top<Context>(); }
2174      static const size_t kDefaultSchemaStackCapacity = 1024;
2175      static const size_t kDefaultDocumentStackCapacity = 256;
2176      const SchemaDocumentType* schemaDocument_;
2177      const SchemaType& root_;
2178      StateAllocator* stateAllocator_;
2179      StateAllocator* ownStateAllocator_;
2180      internal::Stack<StateAllocator> schemaStack_;    
2181      internal::Stack<StateAllocator> documentStack_;  
2182      OutputHandler* outputHandler_;
2183      ValueType error_;
2184      ValueType currentError_;
2185      ValueType missingDependents_;
2186      bool valid_;
2187      unsigned flags_;
2188  #if RAPIDJSON_SCHEMA_VERBOSE
2189      unsigned depth_;
2190  #endif
2191  };
2192  typedef GenericSchemaValidator<SchemaDocument> SchemaValidator;
2193  template <
2194      unsigned parseFlags,
2195      typename InputStream,
2196      typename SourceEncoding,
2197      typename SchemaDocumentType = SchemaDocument,
2198      typename StackAllocator = CrtAllocator>
2199  class SchemaValidatingReader {
2200  public:
2201      typedef typename SchemaDocumentType::PointerType PointerType;
2202      typedef typename InputStream::Ch Ch;
2203      typedef GenericValue<SourceEncoding, StackAllocator> ValueType;
2204      SchemaValidatingReader(InputStream& is, const SchemaDocumentType& sd) : is_(is), sd_(sd), invalidSchemaKeyword_(), invalidSchemaCode_(kValidateErrorNone), error_(kObjectType), isValid_(true) {}
2205      template <typename Handler>
2206      bool operator()(Handler& handler) {
2207          GenericReader<SourceEncoding, typename SchemaDocumentType::EncodingType, StackAllocator> reader;
2208          GenericSchemaValidator<SchemaDocumentType, Handler> validator(sd_, handler);
2209          parseResult_ = reader.template Parse<parseFlags>(is_, validator);
2210          isValid_ = validator.IsValid();
2211          if (isValid_) {
2212              invalidSchemaPointer_ = PointerType();
2213              invalidSchemaKeyword_ = 0;
2214              invalidDocumentPointer_ = PointerType();
2215              error_.SetObject();
2216          }
2217          else {
2218              invalidSchemaPointer_ = validator.GetInvalidSchemaPointer();
2219              invalidSchemaKeyword_ = validator.GetInvalidSchemaKeyword();
2220              invalidSchemaCode_ = validator.GetInvalidSchemaCode();
2221              invalidDocumentPointer_ = validator.GetInvalidDocumentPointer();
2222              error_.CopyFrom(validator.GetError(), allocator_);
2223          }
2224          return parseResult_;
2225      }
2226      const ParseResult& GetParseResult() const { return parseResult_; }
2227      bool IsValid() const { return isValid_; }
2228      const PointerType& GetInvalidSchemaPointer() const { return invalidSchemaPointer_; }
2229      const Ch* GetInvalidSchemaKeyword() const { return invalidSchemaKeyword_; }
2230      const PointerType& GetInvalidDocumentPointer() const { return invalidDocumentPointer_; }
2231      const ValueType& GetError() const { return error_; }
2232      ValidateErrorCode GetInvalidSchemaCode() const { return invalidSchemaCode_; }
2233  private:
2234      InputStream& is_;
2235      const SchemaDocumentType& sd_;
2236      ParseResult parseResult_;
2237      PointerType invalidSchemaPointer_;
2238      const Ch* invalidSchemaKeyword_;
2239      PointerType invalidDocumentPointer_;
2240      ValidateErrorCode invalidSchemaCode_;
2241      StackAllocator allocator_;
2242      ValueType error_;
2243      bool isValid_;
2244  };
2245  RAPIDJSON_NAMESPACE_END
2246  RAPIDJSON_DIAG_POP
2247  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-schema.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-schema.h</div>
                </div>
                <div class="column column_space"><pre><code>1766          currentError_.PushBack(ValueType(name, GetStateAllocator()).Move(), GetStateAllocator());
1767      }
1768      bool EndMissingProperties() {
</pre></code></div>
                <div class="column column_space"><pre><code>1766          currentError_.PushBack(ValueType(name, GetStateAllocator()).Move(), GetStateAllocator());
1767      }
1768      bool EndMissingProperties() {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    