
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-memattrs.c</h3>
            <pre><code>1  #include "private/autogen/config.h"
2  #include "hwloc.h"
3  #include "private/private.h"
4  #include "private/debug.h"
5  static __hwloc_inline
6  hwloc_uint64_t hwloc__memattr_get_convenience_value(hwloc_memattr_id_t id,
7                                                      hwloc_obj_t node)
8  {
9    if (id == HWLOC_MEMATTR_ID_CAPACITY)
10      return node->attr->numanode.local_memory;
11    else if (id == HWLOC_MEMATTR_ID_LOCALITY)
12      return hwloc_bitmap_weight(node->cpuset);
13    else
14      assert(0);
15    return 0; &bsol;* shut up the compiler */
<span onclick='openModal()' class='match'>16  }
17  void
18  hwloc_internal_memattrs_init(struct hwloc_topology *topology)
19  {
20    topology->nr_memattrs = 0;
21    topology->memattrs = NULL;
</span>22  }
23  static void
24  hwloc__setup_memattr(struct hwloc_internal_memattr_s *imattr,
25                       char *name,
26                       unsigned long flags,
27                       unsigned long iflags)
28  {
29    imattr->name = name;
30    imattr->flags = flags;
31    imattr->iflags = iflags;
32    imattr->nr_targets = 0;
33    imattr->targets = NULL;
34  }
35  void
36  hwloc_internal_memattrs_prepare(struct hwloc_topology *topology)
37  {
38    topology->memattrs = malloc(HWLOC_MEMATTR_ID_MAX * sizeof(*topology->memattrs));
39    if (!topology->memattrs)
40      return;
41    hwloc__setup_memattr(&topology->memattrs[HWLOC_MEMATTR_ID_CAPACITY],
42                         (char *) "Capacity",
43                         HWLOC_MEMATTR_FLAG_HIGHER_FIRST,
44                         HWLOC_IMATTR_FLAG_STATIC_NAME|HWLOC_IMATTR_FLAG_CONVENIENCE);
45    hwloc__setup_memattr(&topology->memattrs[HWLOC_MEMATTR_ID_LOCALITY],
46                         (char *) "Locality",
47                         HWLOC_MEMATTR_FLAG_LOWER_FIRST,
48                         HWLOC_IMATTR_FLAG_STATIC_NAME|HWLOC_IMATTR_FLAG_CONVENIENCE);
49    hwloc__setup_memattr(&topology->memattrs[HWLOC_MEMATTR_ID_BANDWIDTH],
50                         (char *) "Bandwidth",
51                         HWLOC_MEMATTR_FLAG_HIGHER_FIRST|HWLOC_MEMATTR_FLAG_NEED_INITIATOR,
52                         HWLOC_IMATTR_FLAG_STATIC_NAME);
53    hwloc__setup_memattr(&topology->memattrs[HWLOC_MEMATTR_ID_READ_BANDWIDTH],
54                         (char *) "ReadBandwidth",
55                         HWLOC_MEMATTR_FLAG_HIGHER_FIRST|HWLOC_MEMATTR_FLAG_NEED_INITIATOR,
56                         HWLOC_IMATTR_FLAG_STATIC_NAME);
57    hwloc__setup_memattr(&topology->memattrs[HWLOC_MEMATTR_ID_WRITE_BANDWIDTH],
58                         (char *) "WriteBandwidth",
59                         HWLOC_MEMATTR_FLAG_HIGHER_FIRST|HWLOC_MEMATTR_FLAG_NEED_INITIATOR,
60                         HWLOC_IMATTR_FLAG_STATIC_NAME);
61    hwloc__setup_memattr(&topology->memattrs[HWLOC_MEMATTR_ID_LATENCY],
62                         (char *) "Latency",
63                         HWLOC_MEMATTR_FLAG_LOWER_FIRST|HWLOC_MEMATTR_FLAG_NEED_INITIATOR,
64                         HWLOC_IMATTR_FLAG_STATIC_NAME);
65    hwloc__setup_memattr(&topology->memattrs[HWLOC_MEMATTR_ID_READ_LATENCY],
66                         (char *) "ReadLatency",
67                         HWLOC_MEMATTR_FLAG_LOWER_FIRST|HWLOC_MEMATTR_FLAG_NEED_INITIATOR,
68                         HWLOC_IMATTR_FLAG_STATIC_NAME);
69    hwloc__setup_memattr(&topology->memattrs[HWLOC_MEMATTR_ID_WRITE_LATENCY],
70                         (char *) "WriteLatency",
71                         HWLOC_MEMATTR_FLAG_LOWER_FIRST|HWLOC_MEMATTR_FLAG_NEED_INITIATOR,
72                         HWLOC_IMATTR_FLAG_STATIC_NAME);
73    topology->nr_memattrs = HWLOC_MEMATTR_ID_MAX;
74  }
75  static void
76  hwloc__imi_destroy(struct hwloc_internal_memattr_initiator_s *imi)
77  {
78    if (imi->initiator.type == HWLOC_LOCATION_TYPE_CPUSET)
79      hwloc_bitmap_free(imi->initiator.location.cpuset);
80  }
81  static void
82  hwloc__imtg_destroy(struct hwloc_internal_memattr_s *imattr,
83                      struct hwloc_internal_memattr_target_s *imtg)
84  {
85    if (imattr->flags & HWLOC_MEMATTR_FLAG_NEED_INITIATOR) {
86      unsigned k;
87      for(k=0; k<imtg->nr_initiators; k++)
88        hwloc__imi_destroy(&imtg->initiators[k]);
89    }
90    free(imtg->initiators);
91  }
92  void
93  hwloc_internal_memattrs_destroy(struct hwloc_topology *topology)
94  {
95    unsigned id;
96    for(id=0; id<topology->nr_memattrs; id++) {
97      struct hwloc_internal_memattr_s *imattr = &topology->memattrs[id];
98      unsigned j;
99      for(j=0; j<imattr->nr_targets; j++)
100        hwloc__imtg_destroy(imattr, &imattr->targets[j]);
101      free(imattr->targets);
102      if (!(imattr->iflags & HWLOC_IMATTR_FLAG_STATIC_NAME))
103        free(imattr->name);
104    }
105    free(topology->memattrs);
106    topology->memattrs = NULL;
107    topology->nr_memattrs = 0;
108  }
109  int
110  hwloc_internal_memattrs_dup(struct hwloc_topology *new, struct hwloc_topology *old)
111  {
112    struct hwloc_tma *tma = new->tma;
113    struct hwloc_internal_memattr_s *imattrs;
114    hwloc_memattr_id_t id;
115    imattrs = hwloc_tma_malloc(tma, old->nr_memattrs * sizeof(*imattrs));
116    if (!imattrs)
117      return -1;
118    new->memattrs = imattrs;
119    new->nr_memattrs = old->nr_memattrs;
120    memcpy(imattrs, old->memattrs, old->nr_memattrs * sizeof(*imattrs));
121    for(id=0; id<old->nr_memattrs; id++) {
122      struct hwloc_internal_memattr_s *oimattr = &old->memattrs[id];
123      struct hwloc_internal_memattr_s *nimattr = &imattrs[id];
124      unsigned j;
125      assert(oimattr->name);
126      nimattr->name = hwloc_tma_strdup(tma, oimattr->name);
127      if (!nimattr->name) {
128        assert(!tma || !tma->dontfree); &bsol;* this tma cannot fail to allocate */
129        new->nr_memattrs = id;
130        goto failed;
131      }
132      nimattr->iflags &= ~HWLOC_IMATTR_FLAG_STATIC_NAME;
133      nimattr->iflags &= ~HWLOC_IMATTR_FLAG_CACHE_VALID; &bsol;* cache will need refresh */
134      if (!oimattr->nr_targets)
135        continue;
136      nimattr->targets = hwloc_tma_malloc(tma, oimattr->nr_targets * sizeof(*nimattr->targets));
137      if (!nimattr->targets) {
138        free(nimattr->name);
139        new->nr_memattrs = id;
140        goto failed;
141      }
142      memcpy(nimattr->targets, oimattr->targets, oimattr->nr_targets * sizeof(*nimattr->targets));
143      for(j=0; j<oimattr->nr_targets; j++) {
144        struct hwloc_internal_memattr_target_s *oimtg = &oimattr->targets[j];
145        struct hwloc_internal_memattr_target_s *nimtg = &nimattr->targets[j];
146        unsigned k;
147        nimtg->obj = NULL; &bsol;* cache will need refresh */
148        if (!oimtg->nr_initiators)
149          continue;
150        nimtg->initiators = hwloc_tma_malloc(tma, oimtg->nr_initiators * sizeof(*nimtg->initiators));
151        if (!nimtg->initiators) {
152          nimattr->nr_targets = j;
153          new->nr_memattrs = id+1;
154          goto failed;
155        }
156        memcpy(nimtg->initiators, oimtg->initiators, oimtg->nr_initiators * sizeof(*nimtg->initiators));
157        for(k=0; k<oimtg->nr_initiators; k++) {
158          struct hwloc_internal_memattr_initiator_s *oimi = &oimtg->initiators[k];
159          struct hwloc_internal_memattr_initiator_s *nimi = &nimtg->initiators[k];
160          if (oimi->initiator.type == HWLOC_LOCATION_TYPE_CPUSET) {
161            nimi->initiator.location.cpuset = hwloc_bitmap_tma_dup(tma, oimi->initiator.location.cpuset);
162            if (!nimi->initiator.location.cpuset) {
163              nimtg->nr_initiators = k;
164              nimattr->nr_targets = j+1;
165              new->nr_memattrs = id+1;
166              goto failed;
167            }
168          } else if (oimi->initiator.type == HWLOC_LOCATION_TYPE_OBJECT) {
169            nimi->initiator.location.object.obj = NULL; &bsol;* cache will need refresh */
170          }
171        }
172      }
173    }
174    return 0;
175   failed:
176    hwloc_internal_memattrs_destroy(new);
177    return -1;
178  }
179  int
180  hwloc_memattr_get_by_name(hwloc_topology_t topology,
181                            const char *name,
182                            hwloc_memattr_id_t *idp)
183  {
184    unsigned id;
185    for(id=0; id<topology->nr_memattrs; id++) {
186      if (!strcmp(topology->memattrs[id].name, name)) {
187        *idp = id;
188        return 0;
189      }
190    }
191    errno = EINVAL;
192    return -1;
193  }
194  int
195  hwloc_memattr_get_name(hwloc_topology_t topology,
196                         hwloc_memattr_id_t id,
197                         const char **namep)
198  {
199    if (id >= topology->nr_memattrs) {
200      errno = EINVAL;
201      return -1;
202    }
203    *namep = topology->memattrs[id].name;
204    return 0;
205  }
206  int
207  hwloc_memattr_get_flags(hwloc_topology_t topology,
208                          hwloc_memattr_id_t id,
209                          unsigned long *flagsp)
210  {
211    if (id >= topology->nr_memattrs) {
212      errno = EINVAL;
213      return -1;
214    }
215    *flagsp = topology->memattrs[id].flags;
216    return 0;
217  }
218  int
219  hwloc_memattr_register(hwloc_topology_t topology,
220                         const char *_name,
221                         unsigned long flags,
222                         hwloc_memattr_id_t *id)
223  {
224    struct hwloc_internal_memattr_s *newattrs;
225    char *name;
226    unsigned i;
227    if (flags & ~(HWLOC_MEMATTR_FLAG_NEED_INITIATOR|HWLOC_MEMATTR_FLAG_LOWER_FIRST|HWLOC_MEMATTR_FLAG_HIGHER_FIRST)) {
228      errno = EINVAL;
229      return -1;
230    }
231    if (!(flags & (HWLOC_MEMATTR_FLAG_LOWER_FIRST|HWLOC_MEMATTR_FLAG_HIGHER_FIRST))) {
232      errno = EINVAL;
233      return -1;
234    }
235    if ((flags & (HWLOC_MEMATTR_FLAG_LOWER_FIRST|HWLOC_MEMATTR_FLAG_HIGHER_FIRST))
236        == (HWLOC_MEMATTR_FLAG_LOWER_FIRST|HWLOC_MEMATTR_FLAG_HIGHER_FIRST)) {
237      errno = EINVAL;
238      return -1;
239    }
240    if (!_name) {
241      errno = EINVAL;
242      return -1;
243    }
244    for(i=0; i<topology->nr_memattrs; i++) {
245      if (!strcmp(_name, topology->memattrs[i].name)) {
246        errno = EBUSY;
247        return -1;
248      }
249    }
250    name = strdup(_name);
251    if (!name)
252      return -1;
253    newattrs = realloc(topology->memattrs, (topology->nr_memattrs + 1) * sizeof(*topology->memattrs));
254    if (!newattrs) {
255      free(name);
256      return -1;
257    }
258    hwloc__setup_memattr(&newattrs[topology->nr_memattrs],
259                         name, flags, 0);
260    newattrs[topology->nr_memattrs].iflags |= HWLOC_IMATTR_FLAG_CACHE_VALID;
261    *id = topology->nr_memattrs;
262    topology->nr_memattrs++;
263    topology->memattrs = newattrs;
264    return 0;
265  }
266  static int
267  match_internal_location(struct hwloc_internal_location_s *iloc,
268                          struct hwloc_internal_memattr_initiator_s *imi)
269  {
270    if (iloc->type != imi->initiator.type)
271      return 0;
272    switch (iloc->type) {
273    case HWLOC_LOCATION_TYPE_CPUSET:
274      return hwloc_bitmap_isincluded(iloc->location.cpuset, imi->initiator.location.cpuset);
275    case HWLOC_LOCATION_TYPE_OBJECT:
276      return iloc->location.object.type == imi->initiator.location.object.type
277        && iloc->location.object.gp_index == imi->initiator.location.object.gp_index;
278    default:
279      return 0;
280    }
281  }
282  static int
283  to_internal_location(struct hwloc_internal_location_s *iloc,
284                       struct hwloc_location *location)
285  {
286    iloc->type = location->type;
287    switch (location->type) {
288    case HWLOC_LOCATION_TYPE_CPUSET:
289      if (!location->location.cpuset || hwloc_bitmap_iszero(location->location.cpuset)) {
290        errno = EINVAL;
291        return -1;
292      }
293      iloc->location.cpuset = location->location.cpuset;
294      return 0;
295    case HWLOC_LOCATION_TYPE_OBJECT:
296      if (!location->location.object) {
297        errno = EINVAL;
298        return -1;
299      }
300      iloc->location.object.gp_index = location->location.object->gp_index;
301      iloc->location.object.type = location->location.object->type;
302      return 0;
303    default:
304      errno = EINVAL;
305      return -1;
306    }
307  }
308  static int
309  from_internal_location(struct hwloc_internal_location_s *iloc,
310                         struct hwloc_location *location)
311  {
312    location->type = iloc->type;
313    switch (iloc->type) {
314    case HWLOC_LOCATION_TYPE_CPUSET:
315      location->location.cpuset = iloc->location.cpuset;
316      return 0;
317    case HWLOC_LOCATION_TYPE_OBJECT:
318      location->location.object = iloc->location.object.obj;
319      if (!location->location.object)
320        return -1;
321      return 0;
322    default:
323      errno = EINVAL;
324      return -1;
325    }
326  }
327  static int
328  hwloc__imi_refresh(struct hwloc_topology *topology,
329                     struct hwloc_internal_memattr_initiator_s *imi)
330  {
331    switch (imi->initiator.type) {
332    case HWLOC_LOCATION_TYPE_CPUSET: {
333      hwloc_bitmap_and(imi->initiator.location.cpuset, imi->initiator.location.cpuset, topology->levels[0][0]->cpuset);
334      if (hwloc_bitmap_iszero(imi->initiator.location.cpuset)) {
335        hwloc__imi_destroy(imi);
336        return -1;
337      }
338      return 0;
339    }
340    case HWLOC_LOCATION_TYPE_OBJECT: {
341      hwloc_obj_t obj = hwloc_get_obj_by_type_and_gp_index(topology,
342                                                           imi->initiator.location.object.type,
343                                                           imi->initiator.location.object.gp_index);
344      if (!obj) {
345        hwloc__imi_destroy(imi);
346        return -1;
347      }
348      imi->initiator.location.object.obj = obj;
349      return 0;
350    }
351    default:
352      assert(0);
353    }
354    return -1;
355  }
356  static int
357  hwloc__imtg_refresh(struct hwloc_topology *topology,
358                      struct hwloc_internal_memattr_s *imattr,
359                      struct hwloc_internal_memattr_target_s *imtg)
360  {
361    hwloc_obj_t node;
362    assert(!(imattr->iflags & HWLOC_IMATTR_FLAG_CONVENIENCE));
363    if (imtg->gp_index == (hwloc_uint64_t) -1) {
364      if (imtg->type == HWLOC_OBJ_NUMANODE)
365        node = hwloc_get_numanode_obj_by_os_index(topology, imtg->os_index);
366      else if (imtg->type == HWLOC_OBJ_PU)
367        node = hwloc_get_pu_obj_by_os_index(topology, imtg->os_index);
368      else
369        node = NULL;
370    } else {
371      node = hwloc_get_obj_by_type_and_gp_index(topology, imtg->type, imtg->gp_index);
372    }
373    if (!node) {
374      hwloc__imtg_destroy(imattr, imtg);
375      return -1;
376    }
377    imtg->gp_index = node->gp_index;
378    imtg->obj = node;
379    if (imattr->flags & HWLOC_MEMATTR_FLAG_NEED_INITIATOR) {
380      unsigned k, l;
381      for(k=0, l=0; k<imtg->nr_initiators; k++) {
382        int err = hwloc__imi_refresh(topology, &imtg->initiators[k]);
383        if (err < 0)
384          continue;
385        if (k != l)
386          memcpy(&imtg->initiators[l], &imtg->initiators[k], sizeof(*imtg->initiators));
387        l++;
388      }
389      imtg->nr_initiators = l;
390      if (!imtg->nr_initiators) {
391        hwloc__imtg_destroy(imattr, imtg);
392        return -1;
393      }
394    }
395    return 0;
396  }
397  static void
398  hwloc__imattr_refresh(struct hwloc_topology *topology,
399                        struct hwloc_internal_memattr_s *imattr)
400  {
401    unsigned j, k;
402    for(j=0, k=0; j<imattr->nr_targets; j++) {
403      int ret = hwloc__imtg_refresh(topology, imattr, &imattr->targets[j]);
404      if (!ret) {
405        if (j != k)
406          memcpy(&imattr->targets[k], &imattr->targets[j], sizeof(*imattr->targets));
407        k++;
408      }
409    }
410    imattr->nr_targets = k;
411    imattr->iflags |= HWLOC_IMATTR_FLAG_CACHE_VALID;
412  }
413  void
414  hwloc_internal_memattrs_refresh(struct hwloc_topology *topology)
415  {
416    unsigned id;
417    for(id=0; id<topology->nr_memattrs; id++) {
418      struct hwloc_internal_memattr_s *imattr = &topology->memattrs[id];
419      if (imattr->iflags & HWLOC_IMATTR_FLAG_CACHE_VALID)
420        continue;
421      hwloc__imattr_refresh(topology, imattr);
422    }
423  }
424  void
425  hwloc_internal_memattrs_need_refresh(struct hwloc_topology *topology)
426  {
427    unsigned id;
428    for(id=0; id<topology->nr_memattrs; id++) {
429      struct hwloc_internal_memattr_s *imattr = &topology->memattrs[id];
430      if (imattr->iflags & HWLOC_IMATTR_FLAG_CONVENIENCE)
431        continue;
432      imattr->iflags &= ~HWLOC_IMATTR_FLAG_CACHE_VALID;
433    }
434  }
435  static struct hwloc_internal_memattr_target_s *
436  hwloc__memattr_get_target(struct hwloc_internal_memattr_s *imattr,
437                            hwloc_obj_type_t target_type,
438                            hwloc_uint64_t target_gp_index,
439                            unsigned target_os_index,
440                            int create)
441  {
442    struct hwloc_internal_memattr_target_s *news, *new;
443    unsigned j;
444    for(j=0; j<imattr->nr_targets; j++) {
445      if (target_type == imattr->targets[j].type)
446        if ((target_gp_index != (hwloc_uint64_t)-1 && target_gp_index == imattr->targets[j].gp_index)
447            || (target_os_index != (unsigned)-1 && target_os_index == imattr->targets[j].os_index))
448          return &imattr->targets[j];
449    }
450    if (!create)
451      return NULL;
452    news = realloc(imattr->targets, (imattr->nr_targets+1)*sizeof(*imattr->targets));
453    if (!news)
454      return NULL;
455    imattr->targets = news;
456    new = &news[imattr->nr_targets];
457    new->type = target_type;
458    new->gp_index = target_gp_index;
459    new->os_index = target_os_index;
460    new->obj = NULL;
461    imattr->iflags &= ~HWLOC_IMATTR_FLAG_CACHE_VALID;
462    new->nr_initiators = 0;
463    new->initiators = NULL;
464    new->noinitiator_value = 0;
465    imattr->nr_targets++;
466    return new;
467  }
468  static struct hwloc_internal_memattr_initiator_s *
469  hwloc__memattr_get_initiator_from_location(struct hwloc_internal_memattr_s *imattr,
470                                             struct hwloc_internal_memattr_target_s *imtg,
471                                             struct hwloc_location *location);
472  int
473  hwloc_memattr_get_targets(hwloc_topology_t topology,
474                            hwloc_memattr_id_t id,
475                            struct hwloc_location *initiator,
476                            unsigned long flags,
477                            unsigned *nrp, hwloc_obj_t *targets, hwloc_uint64_t *values)
478  {
479    struct hwloc_internal_memattr_s *imattr;
480    unsigned i, found = 0, max;
481    if (flags) {
482      errno = EINVAL;
483      return -1;
484    }
485    if (!nrp || (*nrp && !targets)) {
486      errno = EINVAL;
487      return -1;
488    }
489    max = *nrp;
490    if (id >= topology->nr_memattrs) {
491      errno = EINVAL;
492      return -1;
493    }
494    imattr = &topology->memattrs[id];
495    if (imattr->iflags & HWLOC_IMATTR_FLAG_CONVENIENCE) {
496      for(i=0; ; i++) {
497        hwloc_obj_t node = hwloc_get_obj_by_type(topology, HWLOC_OBJ_NUMANODE, i);
498        if (!node)
499          break;
500        if (found<max) {
501          targets[found] = node;
502          if (values)
503            values[found] = hwloc__memattr_get_convenience_value(id, node);
504        }
505        found++;
506      }
507      goto done;
508    }
509    if (!(imattr->iflags & HWLOC_IMATTR_FLAG_CACHE_VALID))
510      hwloc__imattr_refresh(topology, imattr);
511    for(i=0; i<imattr->nr_targets; i++) {
512      struct hwloc_internal_memattr_target_s *imtg = &imattr->targets[i];
513      hwloc_uint64_t value = 0;
514      if (imattr->flags & HWLOC_MEMATTR_FLAG_NEED_INITIATOR) {
515        if (initiator) {
516          struct hwloc_internal_memattr_initiator_s *imi = hwloc__memattr_get_initiator_from_location(imattr, imtg, initiator);
517          if (!imi)
518            continue;
519          value = imi->value;
520        }
521      } else {
522        value = imtg->noinitiator_value;
523      }
524      if (found<max) {
525        targets[found] = imtg->obj;
526        if (values)
527          values[found] = value;
528      }
529      found++;
530    }
531   done:
532    *nrp = found;
533    return 0;
534  }
535  static struct hwloc_internal_memattr_initiator_s *
536  hwloc__memattr_target_get_initiator(struct hwloc_internal_memattr_target_s *imtg,
537                                      struct hwloc_internal_location_s *iloc,
538                                      int create)
539  {
540    struct hwloc_internal_memattr_initiator_s *news, *new;
541    unsigned k;
542    for(k=0; k<imtg->nr_initiators; k++) {
543      struct hwloc_internal_memattr_initiator_s *imi = &imtg->initiators[k];
544      if (match_internal_location(iloc, imi)) {
545        return imi;
546      }
547    }
548    if (!create)
549      return NULL;
550    news = realloc(imtg->initiators, (imtg->nr_initiators+1)*sizeof(*imtg->initiators));
551    if (!news)
552      return NULL;
553    new = &news[imtg->nr_initiators];
554    new->initiator = *iloc;
555    if (iloc->type == HWLOC_LOCATION_TYPE_CPUSET) {
556      new->initiator.location.cpuset = hwloc_bitmap_dup(iloc->location.cpuset);
557      if (!new->initiator.location.cpuset)
558        goto out_with_realloc;
559    }
560    imtg->nr_initiators++;
561    imtg->initiators = news;
562    return new;
563   out_with_realloc:
564    imtg->initiators = news;
565    return NULL;
566  }
567  static struct hwloc_internal_memattr_initiator_s *
568  hwloc__memattr_get_initiator_from_location(struct hwloc_internal_memattr_s *imattr,
569                                             struct hwloc_internal_memattr_target_s *imtg,
570                                             struct hwloc_location *location)
571  {
572    struct hwloc_internal_memattr_initiator_s *imi;
573    struct hwloc_internal_location_s iloc;
574    assert(imattr->flags & HWLOC_MEMATTR_FLAG_NEED_INITIATOR);
575    if (!location) {
576      errno = EINVAL;
577      return NULL;
578    }
579    if (to_internal_location(&iloc, location) < 0) {
580      errno = EINVAL;
581      return NULL;
582    }
583    imi = hwloc__memattr_target_get_initiator(imtg, &iloc, 0);
584    if (!imi) {
585      errno = EINVAL;
586      return NULL;
587    }
588    return imi;
589  }
590  int
591  hwloc_memattr_get_initiators(hwloc_topology_t topology,
592                               hwloc_memattr_id_t id,
593                               hwloc_obj_t target_node,
594                               unsigned long flags,
595                               unsigned *nrp, struct hwloc_location *initiators, hwloc_uint64_t *values)
596  {
597    struct hwloc_internal_memattr_s *imattr;
598    struct hwloc_internal_memattr_target_s *imtg;
599    unsigned i, max;
600    if (flags) {
601      errno = EINVAL;
602      return -1;
603    }
604    if (!nrp || (*nrp && !initiators)) {
605      errno = EINVAL;
606      return -1;
607    }
608    max = *nrp;
609    if (id >= topology->nr_memattrs) {
610      errno = EINVAL;
611      return -1;
612    }
613    imattr = &topology->memattrs[id];
614    if (!(imattr->flags & HWLOC_MEMATTR_FLAG_NEED_INITIATOR)) {
615      *nrp = 0;
616      return 0;
617    }
618    assert(!(imattr->iflags & HWLOC_IMATTR_FLAG_CONVENIENCE));
619    if (!(imattr->iflags & HWLOC_IMATTR_FLAG_CACHE_VALID))
620      hwloc__imattr_refresh(topology, imattr);
621    imtg = hwloc__memattr_get_target(imattr, target_node->type, target_node->gp_index, target_node->os_index, 0);
622    if (!imtg) {
623      errno = EINVAL;
624      return -1;
625    }
626    for(i=0; i<imtg->nr_initiators && i<max; i++) {
627      struct hwloc_internal_memattr_initiator_s *imi = &imtg->initiators[i];
628      int err = from_internal_location(&imi->initiator, &initiators[i]);
629      assert(!err);
630      if (values)
631        values[i] = imi->value;
632    }
633    *nrp = imtg->nr_initiators;
634    return 0;
635  }
636  int
637  hwloc_memattr_get_value(hwloc_topology_t topology,
638                          hwloc_memattr_id_t id,
639                          hwloc_obj_t target_node,
640                          struct hwloc_location *initiator,
641                          unsigned long flags,
642                          hwloc_uint64_t *valuep)
643  {
644    struct hwloc_internal_memattr_s *imattr;
645    struct hwloc_internal_memattr_target_s *imtg;
646    if (flags) {
647      errno = EINVAL;
648      return -1;
649    }
650    if (id >= topology->nr_memattrs) {
651      errno = EINVAL;
652      return -1;
653    }
654    imattr = &topology->memattrs[id];
655    if (imattr->iflags & HWLOC_IMATTR_FLAG_CONVENIENCE) {
656      *valuep = hwloc__memattr_get_convenience_value(id, target_node);
657      return 0;
658    }
659    if (!(imattr->iflags & HWLOC_IMATTR_FLAG_CACHE_VALID))
660      hwloc__imattr_refresh(topology, imattr);
661    imtg = hwloc__memattr_get_target(imattr, target_node->type, target_node->gp_index, target_node->os_index, 0);
662    if (!imtg) {
663      errno = EINVAL;
664      return -1;
665    }
666    if (imattr->flags & HWLOC_MEMATTR_FLAG_NEED_INITIATOR) {
667      struct hwloc_internal_memattr_initiator_s *imi = hwloc__memattr_get_initiator_from_location(imattr, imtg, initiator);
668      if (!imi)
669        return -1;
670      *valuep = imi->value;
671    } else {
672      *valuep = imtg->noinitiator_value;
673    }
674    return 0;
675  }
676  static int
677  hwloc__internal_memattr_set_value(hwloc_topology_t topology,
678                                    hwloc_memattr_id_t id,
679                                    hwloc_obj_type_t target_type,
680                                    hwloc_uint64_t target_gp_index,
681                                    unsigned target_os_index,
682                                    struct hwloc_internal_location_s *initiator,
683                                    hwloc_uint64_t value)
684  {
685    struct hwloc_internal_memattr_s *imattr;
686    struct hwloc_internal_memattr_target_s *imtg;
687    if (id >= topology->nr_memattrs) {
688      errno = EINVAL;
689      return -1;
690    }
691    imattr = &topology->memattrs[id];
692    if (imattr->flags & HWLOC_MEMATTR_FLAG_NEED_INITIATOR) {
693      if (!initiator) {
694        errno = EINVAL;
695        return -1;
696      }
697    }
698    if (imattr->iflags & HWLOC_IMATTR_FLAG_CONVENIENCE) {
699      errno = EINVAL;
700      return -1;
701    }
702    if (topology->is_loaded && !(imattr->iflags & HWLOC_IMATTR_FLAG_CACHE_VALID))
703      hwloc__imattr_refresh(topology, imattr);
704    imtg = hwloc__memattr_get_target(imattr, target_type, target_gp_index, target_os_index, 1);
705    if (!imtg)
706      return -1;
707    if (imattr->flags & HWLOC_MEMATTR_FLAG_NEED_INITIATOR) {
708      struct hwloc_internal_memattr_initiator_s *imi = hwloc__memattr_target_get_initiator(imtg, initiator, 1);
709      if (!imi)
710        return -1;
711      imi->value = value;
712    } else {
713      imtg->noinitiator_value = value;
714    }
715    return 0;
716  }
717  int
718  hwloc_internal_memattr_set_value(hwloc_topology_t topology,
719                                   hwloc_memattr_id_t id,
720                                   hwloc_obj_type_t target_type,
721                                   hwloc_uint64_t target_gp_index,
722                                   unsigned target_os_index,
723                                   struct hwloc_internal_location_s *initiator,
724                                   hwloc_uint64_t value)
725  {
726    assert(id != HWLOC_MEMATTR_ID_CAPACITY);
727    assert(id != HWLOC_MEMATTR_ID_LOCALITY);
728    return hwloc__internal_memattr_set_value(topology, id, target_type, target_gp_index, target_os_index, initiator, value);
729  }
730  int
731  hwloc_memattr_set_value(hwloc_topology_t topology,
732                          hwloc_memattr_id_t id,
733                          hwloc_obj_t target_node,
734                          struct hwloc_location *initiator,
735                          unsigned long flags,
736                          hwloc_uint64_t value)
737  {
738    struct hwloc_internal_location_s iloc, *ilocp;
739    if (flags) {
740      errno = EINVAL;
741      return -1;
742    }
743    if (initiator) {
744      if (to_internal_location(&iloc, initiator) < 0) {
745        errno = EINVAL;
746        return -1;
747      }
748      ilocp = &iloc;
749    } else {
750      ilocp = NULL;
751    }
752    return hwloc__internal_memattr_set_value(topology, id, target_node->type, target_node->gp_index, target_node->os_index, ilocp, value);
753  }
754  static void
755  hwloc__update_best_target(hwloc_obj_t *best_obj, hwloc_uint64_t *best_value, int *found,
756                            hwloc_obj_t new_obj, hwloc_uint64_t new_value,
757                            int keep_highest)
758  {
759    if (*found) {
760      if (keep_highest) {
761        if (new_value <= *best_value)
762          return;
763      } else {
764        if (new_value >= *best_value)
765          return;
766      }
767    }
768    *best_obj = new_obj;
769    *best_value = new_value;
770    *found = 1;
771  }
772  int
773  hwloc_memattr_get_best_target(hwloc_topology_t topology,
774                                hwloc_memattr_id_t id,
775                                struct hwloc_location *initiator,
776                                unsigned long flags,
777                                hwloc_obj_t *bestp, hwloc_uint64_t *valuep)
778  {
779    struct hwloc_internal_memattr_s *imattr;
780    hwloc_uint64_t best_value = 0; &bsol;* shutup the compiler */
781    hwloc_obj_t best = NULL;
782    int found = 0;
783    unsigned j;
784    if (flags) {
785      errno = EINVAL;
786      return -1;
787    }
788    if (id >= topology->nr_memattrs) {
789      errno = EINVAL;
790      return -1;
791    }
792    imattr = &topology->memattrs[id];
793    if (imattr->iflags & HWLOC_IMATTR_FLAG_CONVENIENCE) {
794      for(j=0; ; j++) {
795        hwloc_obj_t node = hwloc_get_obj_by_type(topology, HWLOC_OBJ_NUMANODE, j);
796        hwloc_uint64_t value;
797        if (!node)
798          break;
799        value = hwloc__memattr_get_convenience_value(id, node);
800        hwloc__update_best_target(&best, &best_value, &found,
801                                  node, value,
802                                  imattr->flags & HWLOC_MEMATTR_FLAG_HIGHER_FIRST);
803      }
804      goto done;
805    }
806    if (!(imattr->iflags & HWLOC_IMATTR_FLAG_CACHE_VALID))
807      hwloc__imattr_refresh(topology, imattr);
808    for(j=0; j<imattr->nr_targets; j++) {
809      struct hwloc_internal_memattr_target_s *imtg = &imattr->targets[j];
810      hwloc_uint64_t value;
811      if (imattr->flags & HWLOC_MEMATTR_FLAG_NEED_INITIATOR) {
812        struct hwloc_internal_memattr_initiator_s *imi = hwloc__memattr_get_initiator_from_location(imattr, imtg, initiator);
813        if (!imi)
814          continue;
815        value = imi->value;
816      } else {
817        value = imtg->noinitiator_value;
818      }
819      hwloc__update_best_target(&best, &best_value, &found,
820                                imtg->obj, value,
821                                imattr->flags & HWLOC_MEMATTR_FLAG_HIGHER_FIRST);
822    }
823   done:
824    if (found) {
825      assert(best);
826      *bestp = best;
827      if (valuep)
828        *valuep = best_value;
829      return 0;
830    } else {
831      errno = ENOENT;
832      return -1;
833    }
834  }
835  static void
836  hwloc__update_best_initiator(struct hwloc_internal_location_s *best_initiator, hwloc_uint64_t *best_value, int *found,
837                               struct hwloc_internal_location_s *new_initiator, hwloc_uint64_t new_value,
838                               int keep_highest)
839  {
840    if (*found) {
841      if (keep_highest) {
842        if (new_value <= *best_value)
843          return;
844      } else {
845        if (new_value >= *best_value)
846          return;
847      }
848    }
849    *best_initiator = *new_initiator;
850    *best_value = new_value;
851    *found = 1;
852  }
853  int
854  hwloc_memattr_get_best_initiator(hwloc_topology_t topology,
855                                   hwloc_memattr_id_t id,
856                                   hwloc_obj_t target_node,
857                                   unsigned long flags,
858                                   struct hwloc_location *bestp, hwloc_uint64_t *valuep)
859  {
860    struct hwloc_internal_memattr_s *imattr;
861    struct hwloc_internal_memattr_target_s *imtg;
862    struct hwloc_internal_location_s best_initiator;
863    hwloc_uint64_t best_value;
864    int found;
865    unsigned i;
866    if (flags) {
867      errno = EINVAL;
868      return -1;
869    }
870    if (id >= topology->nr_memattrs) {
871      errno = EINVAL;
872      return -1;
873    }
874    imattr = &topology->memattrs[id];
875    if (!(imattr->flags & HWLOC_MEMATTR_FLAG_NEED_INITIATOR)) {
876      errno = EINVAL;
877      return -1;
878    }
879    if (!(imattr->iflags & HWLOC_IMATTR_FLAG_CACHE_VALID))
880      hwloc__imattr_refresh(topology, imattr);
881    imtg = hwloc__memattr_get_target(imattr, target_node->type, target_node->gp_index, target_node->os_index, 0);
882    if (!imtg) {
883      errno = EINVAL;
884      return -1;
885    }
886    found = 0;
887    for(i=0; i<imtg->nr_initiators; i++) {
888      struct hwloc_internal_memattr_initiator_s *imi = &imtg->initiators[i];
889      hwloc__update_best_initiator(&best_initiator, &best_value, &found,
890                                   &imi->initiator, imi->value,
891                                   imattr->flags & HWLOC_MEMATTR_FLAG_HIGHER_FIRST);
892    }
893    if (found) {
894      if (valuep)
895        *valuep = best_value;
896      return from_internal_location(&best_initiator, bestp);
897    } else {
898      errno = ENOENT;
899      return -1;
900    }
901  }
902  static __hwloc_inline int
903  match_local_obj_cpuset(hwloc_obj_t node, hwloc_cpuset_t cpuset, unsigned long flags)
904  {
905    if (flags & HWLOC_LOCAL_NUMANODE_FLAG_ALL)
906      return 1;
907    if ((flags & HWLOC_LOCAL_NUMANODE_FLAG_LARGER_LOCALITY)
908        && hwloc_bitmap_isincluded(cpuset, node->cpuset))
909      return 1;
910    if ((flags & HWLOC_LOCAL_NUMANODE_FLAG_SMALLER_LOCALITY)
911        && hwloc_bitmap_isincluded(node->cpuset, cpuset))
912      return 1;
913    return hwloc_bitmap_isequal(node->cpuset, cpuset);
914  }
915  int
916  hwloc_get_local_numanode_objs(hwloc_topology_t topology,
917                                struct hwloc_location *location,
918                                unsigned *nrp,
919                                hwloc_obj_t *nodes,
920                                unsigned long flags)
921  {
922    hwloc_cpuset_t cpuset;
923    hwloc_obj_t node;
924    unsigned i;
925    if (flags & ~(HWLOC_LOCAL_NUMANODE_FLAG_SMALLER_LOCALITY
926                  |HWLOC_LOCAL_NUMANODE_FLAG_LARGER_LOCALITY
927                  | HWLOC_LOCAL_NUMANODE_FLAG_ALL)) {
928      errno = EINVAL;
929      return -1;
930    }
931    if (!nrp || (*nrp && !nodes)) {
932      errno = EINVAL;
933      return -1;
934    }
935    if (!location) {
936      if (!(flags & HWLOC_LOCAL_NUMANODE_FLAG_ALL)) {
937        errno = EINVAL;
938        return -1;
939      }
940      cpuset = NULL; &bsol;* unused */
941    } else {
942      if (location->type == HWLOC_LOCATION_TYPE_CPUSET) {
943        cpuset = location->location.cpuset;
944      } else if (location->type == HWLOC_LOCATION_TYPE_OBJECT) {
945        hwloc_obj_t obj = location->location.object;
946        while (!obj->cpuset)
947          obj = obj->parent;
948        cpuset = obj->cpuset;
949      } else {
950        errno = EINVAL;
951        return -1;
952      }
953    }
954    i = 0;
955    for(node = hwloc_get_obj_by_type(topology, HWLOC_OBJ_NUMANODE, 0);
956        node;
957        node = node->next_cousin) {
958      if (!match_local_obj_cpuset(node, cpuset, flags))
959        continue;
960      if (i < *nrp)
961        nodes[i] = node;
962      i++;
963    }
964    *nrp = i;
965    return 0;
966  }
967  struct hwloc_memory_tier_s {
968    hwloc_obj_t node;
969    uint64_t local_bw;
970    enum hwloc_memory_tier_type_e {
971      HWLOC_MEMORY_TIER_UNKNOWN,
972      HWLOC_MEMORY_TIER_DRAM,
973      HWLOC_MEMORY_TIER_HBM,
974      HWLOC_MEMORY_TIER_SPM, &bsol;* Specific-Purpose Memory is usually HBM, we'll use BW to confirm */
975      HWLOC_MEMORY_TIER_NVM,
976      HWLOC_MEMORY_TIER_GPU,
977    } type;
978  };
979  static int compare_tiers(const void *_a, const void *_b)
980  {
981    const struct hwloc_memory_tier_s *a = _a, *b = _b;
982    if (a->type != b->type)
983      return a->type - b->type;
984    if (a->local_bw > b->local_bw)
985      return -1;
986    else if (a->local_bw < b->local_bw)
987      return 1;
988    return 0;
989  }
990  int
991  hwloc_internal_memattrs_guess_memory_tiers(hwloc_topology_t topology)
992  {
993    struct hwloc_internal_memattr_s *imattr;
994    struct hwloc_memory_tier_s *tiers;
995    unsigned i, j, n;
996    const char *env;
997    int spm_is_hbm = -1; &bsol;* -1 will guess from BW, 0 no, 1 forced */
998    int mark_dram = 1;
999    unsigned first_spm, first_nvm;
1000    hwloc_uint64_t max_unknown_bw, min_spm_bw;
1001    env = getenv("HWLOC_MEMTIERS_GUESS");
1002    if (env) {
1003      if (!strcmp(env, "none")) {
1004        return 0;
1005      } else if (!strcmp(env, "default")) {
1006      } else if (!strcmp(env, "spm_is_hbm")) {
1007        hwloc_debug("Assuming SPM-tier is HBM, ignore bandwidth\n");
1008        spm_is_hbm = 1;
1009      } else if (HWLOC_SHOW_CRITICAL_ERRORS()) {
1010        fprintf(stderr, "hwloc: Failed to recognize HWLOC_MEMTIERS_GUESS value %s\n", env);
1011      }
1012    }
1013    imattr = &topology->memattrs[HWLOC_MEMATTR_ID_BANDWIDTH];
1014    if (!(imattr->iflags & HWLOC_IMATTR_FLAG_CACHE_VALID))
1015      hwloc__imattr_refresh(topology, imattr);
1016    n = hwloc_get_nbobjs_by_depth(topology, HWLOC_TYPE_DEPTH_NUMANODE);
1017    assert(n);
1018    tiers = malloc(n * sizeof(*tiers));
1019    if (!tiers)
1020      return -1;
1021    for(i=0; i<n; i++) {
1022      hwloc_obj_t node;
1023      const char *daxtype;
1024      struct hwloc_internal_location_s iloc;
1025      struct hwloc_internal_memattr_target_s *imtg = NULL;
1026      struct hwloc_internal_memattr_initiator_s *imi;
1027      node = hwloc_get_obj_by_depth(topology, HWLOC_TYPE_DEPTH_NUMANODE, i);
1028      assert(node);
1029      tiers[i].node = node;
1030      tiers[i].type = HWLOC_MEMORY_TIER_UNKNOWN;
1031      tiers[i].local_bw = 0; &bsol;* unknown */
1032      daxtype = hwloc_obj_get_info_by_name(node, "DAXType");
1033      if (daxtype && !strcmp(daxtype, "NVM"))
1034        tiers[i].type = HWLOC_MEMORY_TIER_NVM;
1035      if (daxtype && !strcmp(daxtype, "SPM"))
1036        tiers[i].type = HWLOC_MEMORY_TIER_SPM;
1037      if (node->subtype && !strcmp(node->subtype, "GPUMemory"))
1038        tiers[i].type = HWLOC_MEMORY_TIER_GPU;
1039      if (spm_is_hbm == -1) {
1040        for(j=0; j<imattr->nr_targets; j++)
1041          if (imattr->targets[j].obj == node) {
1042            imtg = &imattr->targets[j];
1043            break;
1044          }
1045        if (imtg && !hwloc_bitmap_iszero(node->cpuset)) {
1046          iloc.type = HWLOC_LOCATION_TYPE_CPUSET;
1047          iloc.location.cpuset = node->cpuset;
1048          imi = hwloc__memattr_target_get_initiator(imtg, &iloc, 0);
1049          if (imi)
1050            tiers[i].local_bw = imi->value;
1051        }
1052      }
1053    }
1054    qsort(tiers, n, sizeof(*tiers), compare_tiers);
1055    hwloc_debug("Sorting memory tiers...\n");
1056    for(i=0; i<n; i++)
1057      hwloc_debug("  tier %u = node L#%u P#%u with tier type %d and local BW #%llu\n",
1058                  i,
1059                  tiers[i].node->logical_index, tiers[i].node->os_index,
1060                  tiers[i].type, (unsigned long long) tiers[i].local_bw);
1061    for(i=0; i<n; i++) {
1062      if (tiers[i].type > HWLOC_MEMORY_TIER_UNKNOWN)
1063        break;
1064    }
1065    first_spm = i;
1066    if (first_spm > 0)
1067      max_unknown_bw = tiers[0].local_bw;
1068    else
1069      max_unknown_bw = 0;
1070    for(i=first_spm; i<n; i++) {
1071      if (tiers[i].type > HWLOC_MEMORY_TIER_SPM)
1072        break;
1073    }
1074    first_nvm = i;
1075    if (first_nvm > first_spm)
1076      min_spm_bw = tiers[first_nvm-1].local_bw;
1077    else
1078      min_spm_bw = 0;
1079    if (spm_is_hbm == -1) {
1080      hwloc_debug("UNKNOWN-memory-tier max bandwidth %llu\n", (unsigned long long) max_unknown_bw);
1081      hwloc_debug("SPM-memory-tier min bandwidth %llu\n", (unsigned long long) min_spm_bw);
1082      if (max_unknown_bw > 0 && min_spm_bw > 0 && max_unknown_bw*2 < min_spm_bw) {
1083        hwloc_debug("assuming SPM means HBM and !SPM means DRAM since bandwidths are very different\n");
1084        spm_is_hbm = 1;
1085      } else {
1086        hwloc_debug("cannot assume SPM means HBM\n");
1087        spm_is_hbm = 0;
1088      }
1089    }
1090    if (spm_is_hbm) {
1091      for(i=0; i<first_spm; i++)
1092        tiers[i].type = HWLOC_MEMORY_TIER_DRAM;
1093      for(i=first_spm; i<first_nvm; i++)
1094        tiers[i].type = HWLOC_MEMORY_TIER_HBM;
1095    }
1096    if (first_spm == n)
1097      mark_dram = 0;
1098    for(i=0; i<n; i++) {
1099      const char *type = NULL;
1100      if (tiers[i].node->subtype) &bsol;* don't overwrite the existing subtype */
1101        continue;
1102      switch (tiers[i].type) {
1103      case HWLOC_MEMORY_TIER_DRAM:
1104        if (mark_dram)
1105          type = "DRAM";
1106        break;
1107      case HWLOC_MEMORY_TIER_HBM:
1108        type = "HBM";
1109        break;
1110      case HWLOC_MEMORY_TIER_SPM:
1111        type = "SPM";
1112        break;
1113      case HWLOC_MEMORY_TIER_NVM:
1114        type = "NVM";
1115        break;
1116      default:
1117        break;
1118      }
1119      if (type) {
1120        hwloc_debug("Marking node L#%u P#%u as %s\n", tiers[i].node->logical_index, tiers[i].node->os_index, type);
1121        tiers[i].node->subtype = strdup(type);
1122      }
1123    }
1124    free(tiers);
1125    return 0;
1126  }
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-components.c</h3>
            <pre><code>1  #include "private/autogen/config.h"
2  #include "hwloc.h"
3  #include "private/private.h"
4  #include "private/xml.h"
5  #include "private/misc.h"
6  #define HWLOC_COMPONENT_STOP_NAME "stop"
7  #define HWLOC_COMPONENT_EXCLUDE_CHAR '-'
8  #define HWLOC_COMPONENT_SEPS ","
9  #define HWLOC_COMPONENT_PHASESEP_CHAR ':'
10  static struct hwloc_disc_component * hwloc_disc_components = NULL;
11  static unsigned hwloc_components_users = 0; &bsol;* first one initializes, last ones destroys */
12  static int hwloc_components_verbose = 0;
13  #ifdef HWLOC_HAVE_PLUGINS
14  static int hwloc_plugins_verbose = 0;
15  static const char * hwloc_plugins_blacklist = NULL;
16  #endif
17  #ifdef HWLOC_WIN_SYS
18  #include <windows.h>
19  static LONG hwloc_components_mutex = 0;
20  #define HWLOC_COMPONENTS_LOCK() do {						\
21    while (InterlockedCompareExchange(&hwloc_components_mutex, 1, 0) != 0)	\
22      SwitchToThread();								\
23  } while (0)
24  #define HWLOC_COMPONENTS_UNLOCK() do {						\
25    assert(hwloc_components_mutex == 1);						\
26    hwloc_components_mutex = 0;							\
27  } while (0)
28  #elif defined HWLOC_HAVE_PTHREAD_MUTEX
29  #include <pthread.h>
30  static pthread_mutex_t hwloc_components_mutex = PTHREAD_MUTEX_INITIALIZER;
31  #define HWLOC_COMPONENTS_LOCK() pthread_mutex_lock(&hwloc_components_mutex)
32  #define HWLOC_COMPONENTS_UNLOCK() pthread_mutex_unlock(&hwloc_components_mutex)
33  #else &bsol;* HWLOC_WIN_SYS || HWLOC_HAVE_PTHREAD_MUTEX */
34  #error No mutex implementation available
35  #endif
36  #ifdef HWLOC_HAVE_PLUGINS
37  #ifdef HWLOC_HAVE_LTDL
38  #include <ltdl.h>
39  typedef lt_dlhandle hwloc_dlhandle;
40  #define hwloc_dlinit lt_dlinit
41  #define hwloc_dlexit lt_dlexit
42  #define hwloc_dlopenext lt_dlopenext
43  #define hwloc_dlclose lt_dlclose
44  #define hwloc_dlerror lt_dlerror
45  #define hwloc_dlsym lt_dlsym
46  #define hwloc_dlforeachfile lt_dlforeachfile
47  #else &bsol;* !HWLOC_HAVE_LTDL */
48  #include <dlfcn.h>
49  typedef void * hwloc_dlhandle;
50  static __hwloc_inline int hwloc_dlinit(void) { return 0; }
51  static __hwloc_inline int hwloc_dlexit(void) { return 0; }
52  #define hwloc_dlclose dlclose
53  #define hwloc_dlerror dlerror
54  #define hwloc_dlsym dlsym
55  #include <sys/stat.h>
56  #include <sys/types.h>
57  #include <dirent.h>
58  #include <unistd.h>
59  static hwloc_dlhandle hwloc_dlopenext(const char *_filename)
60  {
61    hwloc_dlhandle handle;
62    char *filename = NULL;
63    (void) asprintf(&filename, "%s.so", _filename);
64    if (!filename)
65      return NULL;
66    handle = dlopen(filename, RTLD_NOW|RTLD_LOCAL);
67    free(filename);
68    return handle;
69  }
70  static int
71  hwloc_dlforeachfile(const char *_paths,
72  		    int (*func)(const char *filename, void *data),
73  		    void *data)
74  {
75    char *paths = NULL, *path;
76    paths = strdup(_paths);
77    if (!paths)
78      return -1;
79    path = paths;
80    while (*path) {
81      char *colon;
82      DIR *dir;
83      struct dirent *dirent;
84      colon = strchr(path, ':');
85      if (colon)
86        *colon = '\0';
87      if (hwloc_plugins_verbose)
88        fprintf(stderr, "hwloc:  Looking under %s\n", path);
89      dir = opendir(path);
90      if (!dir)
91        goto next;
92      while ((dirent = readdir(dir)) != NULL) {
93        char *abs_name, *suffix;
94        struct stat stbuf;
95        int err;
96        err = asprintf(&abs_name, "%s/%s", path, dirent->d_name);
97        if (err < 0)
98  	continue;
99        err = stat(abs_name, &stbuf);
100        if (err < 0) {
101  	free(abs_name);
102          continue;
103        }
104        if (!S_ISREG(stbuf.st_mode)) {
105  	free(abs_name);
106  	continue;
107        }
108        suffix = strrchr(abs_name, '.');
109        if (!suffix || strcmp(suffix, ".so")) {
110  	free(abs_name);
111  	continue;
112        }
113        *suffix = '\0';
114        err = func(abs_name, data);
115        if (err) {
116  	free(abs_name);
117  	continue;
118        }
119        free(abs_name);
120      }
121      closedir(dir);
122    next:
123      if (!colon)
124        break;
125      path = colon+1;
126    }
127    free(paths);
128    return 0;
129  }
130  #endif &bsol;* !HWLOC_HAVE_LTDL */
131  static struct hwloc__plugin_desc {
132    char *name;
133    struct hwloc_component *component;
134    char *filename;
135    hwloc_dlhandle handle;
136    struct hwloc__plugin_desc *next;
137  } *hwloc_plugins = NULL;
138  static int
139  hwloc__dlforeach_cb(const char *filename, void *_data __hwloc_attribute_unused)
140  {
141    const char *basename;
142    hwloc_dlhandle handle;
143    struct hwloc_component *component;
144    struct hwloc__plugin_desc *desc, **prevdesc;
145    char *componentsymbolname;
146    if (hwloc_plugins_verbose)
147      fprintf(stderr, "hwloc: Plugin dlforeach found `%s'\n", filename);
148    basename = strrchr(filename, '/');
149    if (!basename)
150      basename = filename;
151    else
152      basename++;
153    if (hwloc_plugins_blacklist && strstr(hwloc_plugins_blacklist, basename)) {
154      if (hwloc_plugins_verbose)
155        fprintf(stderr, "hwloc: Plugin `%s' is blacklisted in the environment\n", basename);
156      goto out;
157    }
158    handle = hwloc_dlopenext(filename);
159    if (!handle) {
160      if (hwloc_plugins_verbose)
161        fprintf(stderr, "hwloc: Failed to load plugin: %s\n", hwloc_dlerror());
162      goto out;
163    }
164    componentsymbolname = malloc(strlen(basename)+10+1);
165    if (!componentsymbolname) {
166      if (hwloc_plugins_verbose)
167        fprintf(stderr, "hwloc: Failed to allocation component `%s' symbol\n",
168  	      basename);
169      goto out_with_handle;
170    }
171    sprintf(componentsymbolname, "%s_component", basename);
172    component = hwloc_dlsym(handle, componentsymbolname);
173    if (!component) {
174      if (hwloc_plugins_verbose)
175        fprintf(stderr, "hwloc: Failed to find component symbol `%s'\n",
176  	      componentsymbolname);
177      free(componentsymbolname);
178      goto out_with_handle;
179    }
180    if (component->abi != HWLOC_COMPONENT_ABI) {
181      if (hwloc_plugins_verbose)
182        fprintf(stderr, "hwloc: Plugin symbol ABI %u instead of %d\n",
183  	      component->abi, HWLOC_COMPONENT_ABI);
184      free(componentsymbolname);
185      goto out_with_handle;
186    }
187    if (hwloc_plugins_verbose)
188      fprintf(stderr, "hwloc: Plugin contains expected symbol `%s'\n",
189  	    componentsymbolname);
190    free(componentsymbolname);
191    if (HWLOC_COMPONENT_TYPE_DISC == component->type) {
192      if (strncmp(basename, "hwloc_", 6)) {
193        if (hwloc_plugins_verbose)
194  	fprintf(stderr, "hwloc: Plugin name `%s' doesn't match its type DISCOVERY\n", basename);
195        goto out_with_handle;
196      }
197    } else if (HWLOC_COMPONENT_TYPE_XML == component->type) {
198      if (strncmp(basename, "hwloc_xml_", 10)) {
199        if (hwloc_plugins_verbose)
200  	fprintf(stderr, "hwloc: Plugin name `%s' doesn't match its type XML\n", basename);
201        goto out_with_handle;
202      }
203    } else {
204      if (hwloc_plugins_verbose)
205        fprintf(stderr, "hwloc: Plugin name `%s' has invalid type %u\n",
206  	      basename, (unsigned) component->type);
207      goto out_with_handle;
208    }
209    desc = malloc(sizeof(*desc));
210    if (!desc)
211      goto out_with_handle;
212    desc->name = strdup(basename);
213    desc->filename = strdup(filename);
214    desc->component = component;
215    desc->handle = handle;
216    desc->next = NULL;
217    if (hwloc_plugins_verbose)
218      fprintf(stderr, "hwloc: Plugin descriptor `%s' ready\n", basename);
219    prevdesc = &hwloc_plugins;
220    while (*prevdesc)
221      prevdesc = &((*prevdesc)->next);
222    *prevdesc = desc;
223    if (hwloc_plugins_verbose)
224      fprintf(stderr, "hwloc: Plugin descriptor `%s' queued\n", basename);
225    return 0;
226   out_with_handle:
227    hwloc_dlclose(handle);
228   out:
229    return 0;
230  }
231  static void
232  hwloc_plugins_exit(void)
233  {
234    struct hwloc__plugin_desc *desc, *next;
235    if (hwloc_plugins_verbose)
236      fprintf(stderr, "hwloc: Closing all plugins\n");
237    desc = hwloc_plugins;
238    while (desc) {
239      next = desc->next;
240      hwloc_dlclose(desc->handle);
241      free(desc->name);
242      free(desc->filename);
243      free(desc);
244      desc = next;
245    }
246    hwloc_plugins = NULL;
247    hwloc_dlexit();
248  }
249  static int
250  hwloc_plugins_init(void)
251  {
252    const char *verboseenv;
253    const char *path = HWLOC_PLUGINS_PATH;
254    const char *env;
255    int err;
256    verboseenv = getenv("HWLOC_PLUGINS_VERBOSE");
257    hwloc_plugins_verbose = verboseenv ? atoi(verboseenv) : 0;
258    hwloc_plugins_blacklist = getenv("HWLOC_PLUGINS_BLACKLIST");
259    err = hwloc_dlinit();
260    if (err)
261      goto out;
262    env = getenv("HWLOC_PLUGINS_PATH");
263    if (env)
264      path = env;
265    hwloc_plugins = NULL;
266    if (hwloc_plugins_verbose)
267      fprintf(stderr, "hwloc: Starting plugin dlforeach in %s\n", path);
268    err = hwloc_dlforeachfile(path, hwloc__dlforeach_cb, NULL);
269    if (err)
270      goto out_with_init;
271    return 0;
272   out_with_init:
273    hwloc_plugins_exit();
274   out:
275    return -1;
276  }
277  #endif &bsol;* HWLOC_HAVE_PLUGINS */
278  static int
279  hwloc_disc_component_register(struct hwloc_disc_component *component,
280  			      const char *filename)
281  {
282    struct hwloc_disc_component **prev;
283    if (!strcmp(component->name, HWLOC_COMPONENT_STOP_NAME)) {
284      if (hwloc_components_verbose)
285        fprintf(stderr, "hwloc: Cannot register discovery component with reserved name `" HWLOC_COMPONENT_STOP_NAME "'\n");
286      return -1;
287    }
288    if (strchr(component->name, HWLOC_COMPONENT_EXCLUDE_CHAR)
289        || strchr(component->name, HWLOC_COMPONENT_PHASESEP_CHAR)
290        || strcspn(component->name, HWLOC_COMPONENT_SEPS) != strlen(component->name)) {
291      if (hwloc_components_verbose)
292        fprintf(stderr, "hwloc: Cannot register discovery component with name `%s' containing reserved characters `%c" HWLOC_COMPONENT_SEPS "'\n",
293  	      component->name, HWLOC_COMPONENT_EXCLUDE_CHAR);
294      return -1;
295    }
296    if (!component->phases
297        || (component->phases != HWLOC_DISC_PHASE_GLOBAL
298  	  && component->phases & ~(HWLOC_DISC_PHASE_CPU
299  				   |HWLOC_DISC_PHASE_MEMORY
300  				   |HWLOC_DISC_PHASE_PCI
301  				   |HWLOC_DISC_PHASE_IO
302  				   |HWLOC_DISC_PHASE_MISC
303  				   |HWLOC_DISC_PHASE_ANNOTATE
304  				   |HWLOC_DISC_PHASE_TWEAK))) {
305      if (HWLOC_SHOW_CRITICAL_ERRORS())
306        fprintf(stderr, "hwloc: Cannot register discovery component `%s' with invalid phases 0x%x\n",
307                component->name, component->phases);
308      return -1;
309    }
310    prev = &hwloc_disc_components;
311    while (NULL != *prev) {
312      if (!strcmp((*prev)->name, component->name)) {
313        if ((*prev)->priority < component->priority) {
314  	if (hwloc_components_verbose)
315  	  fprintf(stderr, "hwloc: Dropping previously registered discovery component `%s', priority %u lower than new one %u\n",
316  		  (*prev)->name, (*prev)->priority, component->priority);
317  	*prev = (*prev)->next;
318        } else {
319  	if (hwloc_components_verbose)
320  	  fprintf(stderr, "hwloc: Ignoring new discovery component `%s', priority %u lower than previously registered one %u\n",
321  		  component->name, component->priority, (*prev)->priority);
322  	return -1;
323        }
324      }
325      prev = &((*prev)->next);
326    }
327    if (hwloc_components_verbose)
328      fprintf(stderr, "hwloc: Registered discovery component `%s' phases 0x%x with priority %u (%s%s)\n",
329  	    component->name, component->phases, component->priority,
330  	    filename ? "from plugin " : "statically build", filename ? filename : "");
331    prev = &hwloc_disc_components;
332    while (NULL != *prev) {
333      if ((*prev)->priority < component->priority)
334        break;
335      prev = &((*prev)->next);
336    }
337    component->next = *prev;
338    *prev = component;
339    return 0;
340  }
341  #include "static-components.h"
342  static void (**hwloc_component_finalize_cbs)(unsigned long);
343  static unsigned hwloc_component_finalize_cb_count;
344  void
345  hwloc_components_init(void)
346  {
347  #ifdef HWLOC_HAVE_PLUGINS
348    struct hwloc__plugin_desc *desc;
349  #endif
350    const char *verboseenv;
351    unsigned i;
352    HWLOC_COMPONENTS_LOCK();
353    assert((unsigned) -1 != hwloc_components_users);
354    if (0 != hwloc_components_users++) {
355      HWLOC_COMPONENTS_UNLOCK();
356      return;
357    }
358    verboseenv = getenv("HWLOC_COMPONENTS_VERBOSE");
359    hwloc_components_verbose = verboseenv ? atoi(verboseenv) : 0;
360  #ifdef HWLOC_HAVE_PLUGINS
361    hwloc_plugins_init();
362  #endif
363    hwloc_component_finalize_cbs = NULL;
364    hwloc_component_finalize_cb_count = 0;
365    for(i=0; NULL != hwloc_static_components[i]; i++)
366      hwloc_component_finalize_cb_count++;
367  #ifdef HWLOC_HAVE_PLUGINS
368    for(desc = hwloc_plugins; NULL != desc; desc = desc->next)
369      hwloc_component_finalize_cb_count++;
370  #endif
371    if (hwloc_component_finalize_cb_count) {
372      hwloc_component_finalize_cbs = calloc(hwloc_component_finalize_cb_count,
373  					  sizeof(*hwloc_component_finalize_cbs));
374      assert(hwloc_component_finalize_cbs);
375      hwloc_component_finalize_cb_count = 0;
376    }
377    for(i=0; NULL != hwloc_static_components[i]; i++) {
378      if (hwloc_static_components[i]->flags) {
379        if (HWLOC_SHOW_CRITICAL_ERRORS())
380          fprintf(stderr, "hwloc: Ignoring static component with invalid flags %lx\n",
381                  hwloc_static_components[i]->flags);
382        continue;
383      }
384      if (hwloc_static_components[i]->init && hwloc_static_components[i]->init(0) < 0) {
385        if (hwloc_components_verbose)
386  	fprintf(stderr, "hwloc: Ignoring static component, failed to initialize\n");
387        continue;
388      }
389      if (hwloc_static_components[i]->finalize)
390        hwloc_component_finalize_cbs[hwloc_component_finalize_cb_count++] = hwloc_static_components[i]->finalize;
391      if (HWLOC_COMPONENT_TYPE_DISC == hwloc_static_components[i]->type)
392        hwloc_disc_component_register(hwloc_static_components[i]->data, NULL);
393      else if (HWLOC_COMPONENT_TYPE_XML == hwloc_static_components[i]->type)
394        hwloc_xml_callbacks_register(hwloc_static_components[i]->data);
395      else
396        assert(0);
397    }
398  #ifdef HWLOC_HAVE_PLUGINS
399    for(desc = hwloc_plugins; NULL != desc; desc = desc->next) {
400      if (desc->component->flags) {
401        if (HWLOC_SHOW_CRITICAL_ERRORS())
402          fprintf(stderr, "hwloc: Ignoring plugin `%s' component with invalid flags %lx\n",
403                  desc->name, desc->component->flags);
404        continue;
405      }
406      if (desc->component->init && desc->component->init(0) < 0) {
407        if (hwloc_components_verbose)
408  	fprintf(stderr, "hwloc: Ignoring plugin `%s', failed to initialize\n", desc->name);
409        continue;
410      }
411      if (desc->component->finalize)
412        hwloc_component_finalize_cbs[hwloc_component_finalize_cb_count++] = desc->component->finalize;
413      if (HWLOC_COMPONENT_TYPE_DISC == desc->component->type)
414        hwloc_disc_component_register(desc->component->data, desc->filename);
415      else if (HWLOC_COMPONENT_TYPE_XML == desc->component->type)
416        hwloc_xml_callbacks_register(desc->component->data);
417      else
418        assert(0);
419    }
420  #endif
421    HWLOC_COMPONENTS_UNLOCK();
<span onclick='openModal()' class='match'>422  }
423  void
424  hwloc_topology_components_init(struct hwloc_topology *topology)
425  {
426    topology->nr_blacklisted_components = 0;
427    topology->blacklisted_components = NULL;
</span>428    topology->backends = NULL;
429    topology->backend_phases = 0;
430    topology->backend_excluded_phases = 0;
431  }
432  static struct hwloc_disc_component *
433  hwloc_disc_component_find(const char *name, const char **endp)
434  {
435    struct hwloc_disc_component *comp;
436    size_t length;
437    const char *end = strchr(name, HWLOC_COMPONENT_PHASESEP_CHAR);
438    if (end) {
439      length = end-name;
440      if (endp)
441        *endp = end+1;
442    } else {
443      length = strlen(name);
444      if (endp)
445        *endp = NULL;
446    }
447    comp = hwloc_disc_components;
448    while (NULL != comp) {
449      if (!strncmp(name, comp->name, length))
450        return comp;
451      comp = comp->next;
452    }
453    return NULL;
454  }
455  static unsigned
456  hwloc_phases_from_string(const char *s)
457  {
458    if (!s)
459      return ~0U;
460    if (s[0]<'0' || s[0]>'9') {
461      if (!strcasecmp(s, "global"))
462        return HWLOC_DISC_PHASE_GLOBAL;
463      else if (!strcasecmp(s, "cpu"))
464        return HWLOC_DISC_PHASE_CPU;
465      if (!strcasecmp(s, "memory"))
466        return HWLOC_DISC_PHASE_MEMORY;
467      if (!strcasecmp(s, "pci"))
468        return HWLOC_DISC_PHASE_PCI;
469      if (!strcasecmp(s, "io"))
470        return HWLOC_DISC_PHASE_IO;
471      if (!strcasecmp(s, "misc"))
472        return HWLOC_DISC_PHASE_MISC;
473      if (!strcasecmp(s, "annotate"))
474        return HWLOC_DISC_PHASE_ANNOTATE;
475      if (!strcasecmp(s, "tweak"))
476        return HWLOC_DISC_PHASE_TWEAK;
477      return 0;
478    }
479    return (unsigned) strtoul(s, NULL, 0);
480  }
481  static int
482  hwloc_disc_component_blacklist_one(struct hwloc_topology *topology,
483  				   const char *name)
484  {
485    struct hwloc_topology_forced_component_s *blacklisted;
486    struct hwloc_disc_component *comp;
487    unsigned phases;
488    unsigned i;
489    if (!strcmp(name, "linuxpci") || !strcmp(name, "linuxio")) {
490      if (hwloc_components_verbose)
491        fprintf(stderr, "hwloc: Replacing deprecated component `%s' with `linux' IO phases in blacklisting\n", name);
492      comp = hwloc_disc_component_find("linux", NULL);
493      phases = HWLOC_DISC_PHASE_PCI | HWLOC_DISC_PHASE_IO | HWLOC_DISC_PHASE_MISC | HWLOC_DISC_PHASE_ANNOTATE;
494    } else {
495      const char *end;
496      comp = hwloc_disc_component_find(name, &end);
497      phases = hwloc_phases_from_string(end);
498    }
499    if (!comp) {
500      errno = EINVAL;
501      return -1;
502    }
503    if (hwloc_components_verbose)
504      fprintf(stderr, "hwloc: Blacklisting component `%s` phases 0x%x\n", comp->name, phases);
505    for(i=0; i<topology->nr_blacklisted_components; i++) {
506      if (topology->blacklisted_components[i].component == comp) {
507        topology->blacklisted_components[i].phases |= phases;
508        return 0;
509      }
510    }
511    blacklisted = realloc(topology->blacklisted_components, (topology->nr_blacklisted_components+1)*sizeof(*blacklisted));
512    if (!blacklisted)
513      return -1;
514    blacklisted[topology->nr_blacklisted_components].component = comp;
515    blacklisted[topology->nr_blacklisted_components].phases = phases;
516    topology->blacklisted_components = blacklisted;
517    topology->nr_blacklisted_components++;
518    return 0;
519  }
520  int
521  hwloc_topology_set_components(struct hwloc_topology *topology,
522  			      unsigned long flags,
523  			      const char *name)
524  {
525    if (topology->is_loaded) {
526      errno = EBUSY;
527      return -1;
528    }
529    if (flags & ~HWLOC_TOPOLOGY_COMPONENTS_FLAG_BLACKLIST) {
530      errno = EINVAL;
531      return -1;
532    }
533    if (flags != HWLOC_TOPOLOGY_COMPONENTS_FLAG_BLACKLIST) {
534      errno = EINVAL;
535      return -1;
536    }
537    if (!strncmp(name, "all", 3) && name[3] == HWLOC_COMPONENT_PHASESEP_CHAR) {
538      topology->backend_excluded_phases = hwloc_phases_from_string(name+4);
539      return 0;
540    }
541    return hwloc_disc_component_blacklist_one(topology, name);
542  }
543  int
544  hwloc_disc_component_force_enable(struct hwloc_topology *topology,
545  				  int envvar_forced,
546  				  const char *name,
547  				  const void *data1, const void *data2, const void *data3)
548  {
549    struct hwloc_disc_component *comp;
550    struct hwloc_backend *backend;
551    if (topology->is_loaded) {
552      errno = EBUSY;
553      return -1;
554    }
555    comp = hwloc_disc_component_find(name, NULL);
556    if (!comp) {
557      errno = ENOSYS;
558      return -1;
559    }
560    backend = comp->instantiate(topology, comp, 0U &bsol;* force-enabled don't get any phase blacklisting */,
561  			      data1, data2, data3);
562    if (backend) {
563      int err;
564      backend->envvar_forced = envvar_forced;
565      if (topology->backends)
566        hwloc_backends_disable_all(topology);
567      err = hwloc_backend_enable(backend);
568      if (comp->phases == HWLOC_DISC_PHASE_GLOBAL) {
569        char *env = getenv("HWLOC_ANNOTATE_GLOBAL_COMPONENTS");
570        if (env && atoi(env))
571  	topology->backend_excluded_phases &= ~HWLOC_DISC_PHASE_ANNOTATE;
572      }
573      return err;
574    } else
575      return -1;
576  }
577  static int
578  hwloc_disc_component_try_enable(struct hwloc_topology *topology,
579  				struct hwloc_disc_component *comp,
580  				int envvar_forced,
581  				unsigned blacklisted_phases)
582  {
583    struct hwloc_backend *backend;
584    if (!(comp->phases & ~(topology->backend_excluded_phases | blacklisted_phases))) {
585      if (hwloc_components_verbose)
586        fprintf(stderr, "hwloc: Excluding discovery component `%s' phases 0x%x, conflicts with excludes 0x%x\n",
587  	      comp->name, comp->phases, topology->backend_excluded_phases);
588      return -1;
589    }
590    backend = comp->instantiate(topology, comp, topology->backend_excluded_phases | blacklisted_phases,
591  			      NULL, NULL, NULL);
592    if (!backend) {
593      if (hwloc_components_verbose || (envvar_forced && HWLOC_SHOW_CRITICAL_ERRORS()))
594        fprintf(stderr, "hwloc: Failed to instantiate discovery component `%s'\n", comp->name);
595      return -1;
596    }
597    backend->phases &= ~blacklisted_phases;
598    backend->envvar_forced = envvar_forced;
599    return hwloc_backend_enable(backend);
600  }
601  void
602  hwloc_disc_components_enable_others(struct hwloc_topology *topology)
603  {
604    struct hwloc_disc_component *comp;
605    struct hwloc_backend *backend;
606    int tryall = 1;
607    const char *_env;
608    char *env; &bsol;* we'll to modify the env value, so duplicate it */
609    unsigned i;
610    _env = getenv("HWLOC_COMPONENTS");
611    env = _env ? strdup(_env) : NULL;
612    if (env) {
613      char *curenv = env;
614      size_t s;
615      while (*curenv) {
616        s = strcspn(curenv, HWLOC_COMPONENT_SEPS);
617        if (s) {
618  	char c;
619  	if (curenv[0] != HWLOC_COMPONENT_EXCLUDE_CHAR)
620  	  goto nextname;
621  	c = curenv[s];
622  	curenv[s] = '\0';
623  	hwloc_disc_component_blacklist_one(topology, curenv+1);
624  	for(i=0; i<s; i++)
625  	  curenv[i] = *HWLOC_COMPONENT_SEPS;
626  	curenv[s] = c;
627        }
628      nextname:
629        curenv += s;
630        if (*curenv)
631  	curenv++;
632      }
633    }
634    if (env) {
635      char *curenv = env;
636      size_t s;
637      while (*curenv) {
638        s = strcspn(curenv, HWLOC_COMPONENT_SEPS);
639        if (s) {
640  	char c;
641  	const char *name;
642  	if (!strncmp(curenv, HWLOC_COMPONENT_STOP_NAME, s)) {
643  	  tryall = 0;
644  	  break;
645  	}
646  	c = curenv[s];
647  	curenv[s] = '\0';
648  	name = curenv;
649  	if (!strcmp(name, "linuxpci") || !strcmp(name, "linuxio")) {
650  	  if (hwloc_components_verbose)
651  	    fprintf(stderr, "hwloc: Replacing deprecated component `%s' with `linux' in envvar forcing\n", name);
652  	  name = "linux";
653  	}
654  	comp = hwloc_disc_component_find(name, NULL &bsol;* we enable the entire component, phases must be blacklisted separately */);
655  	if (comp) {
656  	  unsigned blacklisted_phases = 0U;
657  	  for(i=0; i<topology->nr_blacklisted_components; i++)
658  	    if (comp == topology->blacklisted_components[i].component) {
659  	      blacklisted_phases = topology->blacklisted_components[i].phases;
660  	      break;
661  	    }
662  	  if (comp->phases & ~blacklisted_phases)
663  	    hwloc_disc_component_try_enable(topology, comp, 1 &bsol;* envvar forced */, blacklisted_phases);
664  	} else {
665            if (HWLOC_SHOW_CRITICAL_ERRORS())
666              fprintf(stderr, "hwloc: Cannot find discovery component `%s'\n", name);
667  	}
668  	curenv[s] = c;
669        }
670        curenv += s;
671        if (*curenv)
672  	curenv++;
673      }
674    }
675    if (tryall) {
676      comp = hwloc_disc_components;
677      while (NULL != comp) {
678        unsigned blacklisted_phases = 0U;
679        if (!comp->enabled_by_default)
680  	goto nextcomp;
681        for(i=0; i<topology->nr_blacklisted_components; i++)
682  	if (comp == topology->blacklisted_components[i].component) {
683  	  blacklisted_phases = topology->blacklisted_components[i].phases;
684  	  break;
685  	}
686        if (!(comp->phases & ~blacklisted_phases)) {
687  	if (hwloc_components_verbose)
688  	  fprintf(stderr, "hwloc: Excluding blacklisted discovery component `%s' phases 0x%x\n",
689  		  comp->name, comp->phases);
690  	goto nextcomp;
691        }
692        hwloc_disc_component_try_enable(topology, comp, 0 &bsol;* defaults, not envvar forced */, blacklisted_phases);
693  nextcomp:
694        comp = comp->next;
695      }
696    }
697    if (hwloc_components_verbose) {
698      int first = 1;
699      backend = topology->backends;
700      fprintf(stderr, "hwloc: Final list of enabled discovery components: ");
701      while (backend != NULL) {
702        fprintf(stderr, "%s%s(0x%x)", first ? "" : ",", backend->component->name, backend->phases);
703        backend = backend->next;
704        first = 0;
705      }
706      fprintf(stderr, "\n");
707    }
708    free(env);
709  }
710  void
711  hwloc_components_fini(void)
712  {
713    unsigned i;
714    HWLOC_COMPONENTS_LOCK();
715    assert(0 != hwloc_components_users);
716    if (0 != --hwloc_components_users) {
717      HWLOC_COMPONENTS_UNLOCK();
718      return;
719    }
720    for(i=0; i<hwloc_component_finalize_cb_count; i++)
721      hwloc_component_finalize_cbs[hwloc_component_finalize_cb_count-i-1](0);
722    free(hwloc_component_finalize_cbs);
723    hwloc_component_finalize_cbs = NULL;
724    hwloc_component_finalize_cb_count = 0;
725    hwloc_disc_components = NULL;
726    hwloc_xml_callbacks_reset();
727  #ifdef HWLOC_HAVE_PLUGINS
728    hwloc_plugins_exit();
729  #endif
730    HWLOC_COMPONENTS_UNLOCK();
731  }
732  struct hwloc_backend *
733  hwloc_backend_alloc(struct hwloc_topology *topology,
734  		    struct hwloc_disc_component *component)
735  {
736    struct hwloc_backend * backend = malloc(sizeof(*backend));
737    if (!backend) {
738      errno = ENOMEM;
739      return NULL;
740    }
741    backend->component = component;
742    backend->topology = topology;
743    backend->phases = component->phases & ~topology->backend_excluded_phases;
744    if (backend->phases != component->phases && hwloc_components_verbose)
745      fprintf(stderr, "hwloc: Trying discovery component `%s' with phases 0x%x instead of 0x%x\n",
746  	    component->name, backend->phases, component->phases);
747    backend->flags = 0;
748    backend->discover = NULL;
749    backend->get_pci_busid_cpuset = NULL;
750    backend->disable = NULL;
751    backend->is_thissystem = -1;
752    backend->next = NULL;
753    backend->envvar_forced = 0;
754    return backend;
755  }
756  static void
757  hwloc_backend_disable(struct hwloc_backend *backend)
758  {
759    if (backend->disable)
760      backend->disable(backend);
761    free(backend);
762  }
763  int
764  hwloc_backend_enable(struct hwloc_backend *backend)
765  {
766    struct hwloc_topology *topology = backend->topology;
767    struct hwloc_backend **pprev;
768    if (backend->flags) {
769      if (HWLOC_SHOW_CRITICAL_ERRORS())
770        fprintf(stderr, "hwloc: Cannot enable discovery component `%s' phases 0x%x with unknown flags %lx\n",
771                backend->component->name, backend->component->phases, backend->flags);
772      return -1;
773    }
774    pprev = &topology->backends;
775    while (NULL != *pprev) {
776      if ((*pprev)->component == backend->component) {
777        if (hwloc_components_verbose)
778  	fprintf(stderr, "hwloc: Cannot enable  discovery component `%s' phases 0x%x twice\n",
779  		backend->component->name, backend->component->phases);
780        hwloc_backend_disable(backend);
781        errno = EBUSY;
782        return -1;
783      }
784      pprev = &((*pprev)->next);
785    }
786    if (hwloc_components_verbose)
787      fprintf(stderr, "hwloc: Enabling discovery component `%s' with phases 0x%x (among 0x%x)\n",
788  	    backend->component->name, backend->phases, backend->component->phases);
789    pprev = &topology->backends;
790    while (NULL != *pprev)
791      pprev = &((*pprev)->next);
792    backend->next = *pprev;
793    *pprev = backend;
794    topology->backend_phases |= backend->component->phases;
795    topology->backend_excluded_phases |= backend->component->excluded_phases;
796    return 0;
797  }
798  void
799  hwloc_backends_is_thissystem(struct hwloc_topology *topology)
800  {
801    struct hwloc_backend *backend;
802    const char *local_env;
803    topology->is_thissystem = 1;
804    backend = topology->backends;
805    while (backend != NULL) {
806      if (backend->envvar_forced == 0 && backend->is_thissystem != -1) {
807        assert(backend->is_thissystem == 0);
808        topology->is_thissystem = 0;
809      }
810      backend = backend->next;
811    }
812    if (topology->flags & HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM)
813      topology->is_thissystem = 1;
814    backend = topology->backends;
815    while (backend != NULL) {
816      if (backend->envvar_forced == 1 && backend->is_thissystem != -1) {
817        assert(backend->is_thissystem == 0);
818        topology->is_thissystem = 0;
819      }
820      backend = backend->next;
821    }
822    local_env = getenv("HWLOC_THISSYSTEM");
823    if (local_env)
824      topology->is_thissystem = atoi(local_env);
825  }
826  void
827  hwloc_backends_find_callbacks(struct hwloc_topology *topology)
828  {
829    struct hwloc_backend *backend = topology->backends;
830    topology->get_pci_busid_cpuset_backend = NULL;
831    while (backend != NULL) {
832      if (backend->get_pci_busid_cpuset) {
833        topology->get_pci_busid_cpuset_backend = backend;
834        return;
835      }
836      backend = backend->next;
837    }
838    return;
839  }
840  void
841  hwloc_backends_disable_all(struct hwloc_topology *topology)
842  {
843    struct hwloc_backend *backend;
844    while (NULL != (backend = topology->backends)) {
845      struct hwloc_backend *next = backend->next;
846      if (hwloc_components_verbose)
847        fprintf(stderr, "hwloc: Disabling discovery component `%s'\n",
848  	      backend->component->name);
849      hwloc_backend_disable(backend);
850      topology->backends = next;
851    }
852    topology->backends = NULL;
853    topology->backend_excluded_phases = 0;
854  }
855  void
856  hwloc_topology_components_fini(struct hwloc_topology *topology)
857  {
858    assert(!topology->backends);
859    free(topology->blacklisted_components);
860  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-memattrs.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-components.c</div>
                </div>
                <div class="column column_space"><pre><code>16  }
17  void
18  hwloc_internal_memattrs_init(struct hwloc_topology *topology)
19  {
20    topology->nr_memattrs = 0;
21    topology->memattrs = NULL;
</pre></code></div>
                <div class="column column_space"><pre><code>422  }
423  void
424  hwloc_topology_components_init(struct hwloc_topology *topology)
425  {
426    topology->nr_blacklisted_components = 0;
427    topology->blacklisted_components = NULL;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    