
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-bench.c</h3>
            <pre><code>1  #include <math.h>
2  #include <stdio.h>
3  #include <string.h>
4  #include "tests/fftw-bench.h"
5  static const char *mkversion(void) { return FFTW(version); }
6  static const char *mkcc(void) { return FFTW(cc); }
7  static const char *mkcodelet_optim(void) { return FFTW(codelet_optim); }
8  BEGIN_BENCH_DOC
9  BENCH_DOC("name", "fftw3")
10  BENCH_DOCF("version", mkversion)
11  BENCH_DOCF("cc", mkcc)
12  BENCH_DOCF("codelet-optim", mkcodelet_optim)
13  END_BENCH_DOC 
14  static FFTW(iodim) *bench_tensor_to_fftw_iodim(bench_tensor *t)
15  {
16       FFTW(iodim) *d;
17       int i;
18       BENCH_ASSERT(t->rnk >= 0);
19       if (t->rnk == 0) return 0;
20       d = (FFTW(iodim) *)bench_malloc(sizeof(FFTW(iodim)) * t->rnk);
21       for (i = 0; i < t->rnk; ++i) {
22  	  d[i].n = t->dims[i].n;
23  	  d[i].is = t->dims[i].is;
24  	  d[i].os = t->dims[i].os;
25       }
26       return d;
27  }
28  static void extract_reim_split(int sign, int size, bench_real *p,
29  			       bench_real **r, bench_real **i)
30  {
31       if (sign == FFTW_FORWARD) {
32            *r = p + 0;
33            *i = p + size;
34       } else {
35            *r = p + size;
36            *i = p + 0;
37       }
38  }
39  static int sizeof_problem(bench_problem *p)
40  {
41       return tensor_sz(p->sz) * tensor_sz(p->vecsz);
42  }
43  static int expressible_as_api_many(bench_tensor *t)
44  {
45       int i;
46       BENCH_ASSERT(BENCH_FINITE_RNK(t->rnk));
47       i = t->rnk - 1;
48       while (--i >= 0) {
49  	  bench_iodim *d = t->dims + i;
50  	  if (d[0].is % d[1].is) return 0;
51  	  if (d[0].os % d[1].os) return 0;
52       }
53       return 1;
54  }
55  static int *mkn(bench_tensor *t)
56  {
57       int *n = (int *) bench_malloc(sizeof(int *) * t->rnk);
58       int i;
59       for (i = 0; i < t->rnk; ++i) 
60  	  n[i] = t->dims[i].n;
61       return n;
62  }
63  static void mknembed_many(bench_tensor *t, int **inembedp, int **onembedp)
64  {
65       int i;
66       bench_iodim *d;
67       int *inembed = (int *) bench_malloc(sizeof(int *) * t->rnk);
68       int *onembed = (int *) bench_malloc(sizeof(int *) * t->rnk);
69       BENCH_ASSERT(BENCH_FINITE_RNK(t->rnk));
70       *inembedp = inembed; *onembedp = onembed;
71       i = t->rnk - 1;
72       while (--i >= 0) {
73  	  d = t->dims + i;
74  	  inembed[i+1] = d[0].is / d[1].is;
75  	  onembed[i+1] = d[0].os / d[1].os;
76       }
77  }
78  static int imax(int a, int b) { return (a > b ? a : b); }
79  static int halfish_sizeof_problem(bench_problem *p)
80  {
81       int n2 = sizeof_problem(p);
82       if (BENCH_FINITE_RNK(p->sz->rnk) && p->sz->rnk > 0)
83            n2 = (n2 / imax(p->sz->dims[p->sz->rnk - 1].n, 1)) *
84                 (p->sz->dims[p->sz->rnk - 1].n / 2 + 1);
85       return n2;
86  }
87  static FFTW(plan) mkplan_real_split(bench_problem *p, unsigned flags)
88  {
89       FFTW(plan) pln;
90       bench_tensor *sz = p->sz, *vecsz = p->vecsz;
91       FFTW(iodim) *dims, *howmany_dims;
92       bench_real *ri, *ii, *ro, *io;
93       int n2 = halfish_sizeof_problem(p);
94       extract_reim_split(FFTW_FORWARD, n2, (bench_real *) p->in, &ri, &ii);
95       extract_reim_split(FFTW_FORWARD, n2, (bench_real *) p->out, &ro, &io);
96       dims = bench_tensor_to_fftw_iodim(sz);
97       howmany_dims = bench_tensor_to_fftw_iodim(vecsz);
98       if (p->sign < 0) {
99  	  if (verbose > 2) printf("using plan_guru_split_dft_r2c\n");
100  	  pln = FFTW(plan_guru_split_dft_r2c)(sz->rnk, dims,
101  					vecsz->rnk, howmany_dims,
102  					ri, ro, io, flags);
103       }
104       else {
105  	  if (verbose > 2) printf("using plan_guru_split_dft_c2r\n");
106  	  pln = FFTW(plan_guru_split_dft_c2r)(sz->rnk, dims,
107  					vecsz->rnk, howmany_dims,
108  					ri, ii, ro, flags);
109       }
110       bench_free(dims);
111       bench_free(howmany_dims);
112       return pln;
113  }
114  static FFTW(plan) mkplan_real_interleaved(bench_problem *p, unsigned flags)
115  {
116       FFTW(plan) pln;
117       bench_tensor *sz = p->sz, *vecsz = p->vecsz;
118       if (vecsz->rnk == 0 && tensor_unitstridep(sz) 
119  	 && tensor_real_rowmajorp(sz, p->sign, p->in_place)) 
120  	  goto api_simple;
121       if (vecsz->rnk == 1 && expressible_as_api_many(sz))
122  	  goto api_many;
123       goto api_guru;
124   api_simple:
125       switch (sz->rnk) {
126  	 case 1:
127  	      if (p->sign < 0) {
128  		   if (verbose > 2) printf("using plan_dft_r2c_1d\n");
129  		   return FFTW(plan_dft_r2c_1d)(sz->dims[0].n, 
130  						(bench_real *) p->in, 
131  						(bench_complex *) p->out,
132  						flags);
133  	      }
134  	      else {
135  		   if (verbose > 2) printf("using plan_dft_c2r_1d\n");
136  		   return FFTW(plan_dft_c2r_1d)(sz->dims[0].n, 
137  						(bench_complex *) p->in, 
138  						(bench_real *) p->out,
139  						flags);
140  	      }
141  	      break;
142  	 case 2:
143  	      if (p->sign < 0) {
144  		   if (verbose > 2) printf("using plan_dft_r2c_2d\n");
145  		   return FFTW(plan_dft_r2c_2d)(sz->dims[0].n, sz->dims[1].n,
146  						(bench_real *) p->in, 
147  						(bench_complex *) p->out,
148  						flags);
149  	      }
150  	      else {
151  		   if (verbose > 2) printf("using plan_dft_c2r_2d\n");
152  		   return FFTW(plan_dft_c2r_2d)(sz->dims[0].n, sz->dims[1].n,
153  						(bench_complex *) p->in, 
154  						(bench_real *) p->out,
155  						flags);
156  	      }
157  	      break;
158  	 case 3:
159  	      if (p->sign < 0) {
160  		   if (verbose > 2) printf("using plan_dft_r2c_3d\n");
161  		   return FFTW(plan_dft_r2c_3d)(
162  			sz->dims[0].n, sz->dims[1].n, sz->dims[2].n,
163  			(bench_real *) p->in, (bench_complex *) p->out,
164  			flags);
165  	      }
166  	      else {
167  		   if (verbose > 2) printf("using plan_dft_c2r_3d\n");
168  		   return FFTW(plan_dft_c2r_3d)(
169  			sz->dims[0].n, sz->dims[1].n, sz->dims[2].n,
170  			(bench_complex *) p->in, (bench_real *) p->out,
171  			flags);
172  	      }
173  	      break;
174  	 default: {
175  	      int *n = mkn(sz);
176  	      if (p->sign < 0) {
177  		   if (verbose > 2) printf("using plan_dft_r2c\n");
178  		   pln = FFTW(plan_dft_r2c)(sz->rnk, n,
179  					    (bench_real *) p->in, 
180  					    (bench_complex *) p->out,
181  					    flags);
182  	      }
183  	      else {
184  		   if (verbose > 2) printf("using plan_dft_c2r\n");
185  		   pln = FFTW(plan_dft_c2r)(sz->rnk, n,
186  					    (bench_complex *) p->in, 
187  					    (bench_real *) p->out,
188  					    flags);
189  	      }
190  	      bench_free(n);
191  	      return pln;
192  	 }
193       }
194   api_many:
195       {
196  	  int *n, *inembed, *onembed;
197  	  BENCH_ASSERT(vecsz->rnk == 1);
<span onclick='openModal()' class='match'>198  	  n = mkn(sz);
199  	  mknembed_many(sz, &inembed, &onembed);
200  	  if (p->sign < 0) {
</span>201  	       if (verbose > 2) printf("using plan_many_dft_r2c\n");
202  	       pln = FFTW(plan_many_dft_r2c)(
203  		    sz->rnk, n, vecsz->dims[0].n, 
204  		    (bench_real *) p->in, inembed,
205  		    sz->dims[sz->rnk - 1].is, vecsz->dims[0].is,
206  		    (bench_complex *) p->out, onembed,
207  		    sz->dims[sz->rnk - 1].os, vecsz->dims[0].os,
208  		    flags);
209  	  }
210  	  else {
211  	       if (verbose > 2) printf("using plan_many_dft_c2r\n");
212  	       pln = FFTW(plan_many_dft_c2r)(
213  		    sz->rnk, n, vecsz->dims[0].n, 
214  		    (bench_complex *) p->in, inembed,
215  		    sz->dims[sz->rnk - 1].is, vecsz->dims[0].is,
216  		    (bench_real *) p->out, onembed,
217  		    sz->dims[sz->rnk - 1].os, vecsz->dims[0].os,
218  		    flags);
219  	  }
220  	  bench_free(n); bench_free(inembed); bench_free(onembed);
221  	  return pln;
222       }
223   api_guru:
224       {
225  	  FFTW(iodim) *dims, *howmany_dims;
226  	  if (p->sign < 0) {
227  	       dims = bench_tensor_to_fftw_iodim(sz);
228  	       howmany_dims = bench_tensor_to_fftw_iodim(vecsz);
229  	       if (verbose > 2) printf("using plan_guru_dft_r2c\n");
230  	       pln = FFTW(plan_guru_dft_r2c)(sz->rnk, dims,
231  					     vecsz->rnk, howmany_dims,
232  					     (bench_real *) p->in,
233  					     (bench_complex *) p->out,
234  					     flags);
235  	  }
236  	  else {
237  	       dims = bench_tensor_to_fftw_iodim(sz);
238  	       howmany_dims = bench_tensor_to_fftw_iodim(vecsz);
239  	       if (verbose > 2) printf("using plan_guru_dft_c2r\n");
240  	       pln = FFTW(plan_guru_dft_c2r)(sz->rnk, dims,
241  					     vecsz->rnk, howmany_dims,
242  					     (bench_complex *) p->in,
243  					     (bench_real *) p->out,
244  					     flags);
245  	  }
246  	  bench_free(dims);
247  	  bench_free(howmany_dims);
248  	  return pln;
249       }
250  }
251  static FFTW(plan) mkplan_real(bench_problem *p, unsigned flags)
252  {
253       if (p->split)
254  	  return mkplan_real_split(p, flags);
255       else
256  	  return mkplan_real_interleaved(p, flags);
257  }
258  static FFTW(plan) mkplan_complex_split(bench_problem *p, unsigned flags)
259  {
260       FFTW(plan) pln;
261       bench_tensor *sz = p->sz, *vecsz = p->vecsz;
262       FFTW(iodim) *dims, *howmany_dims;
263       bench_real *ri, *ii, *ro, *io;
264       extract_reim_split(p->sign, p->iphyssz, (bench_real *) p->in, &ri, &ii);
265       extract_reim_split(p->sign, p->ophyssz, (bench_real *) p->out, &ro, &io);
266       dims = bench_tensor_to_fftw_iodim(sz);
267       howmany_dims = bench_tensor_to_fftw_iodim(vecsz);
268       if (verbose > 2) printf("using plan_guru_split_dft\n");
269       pln = FFTW(plan_guru_split_dft)(sz->rnk, dims,
270  			       vecsz->rnk, howmany_dims,
271  			       ri, ii, ro, io, flags);
272       bench_free(dims);
273       bench_free(howmany_dims);
274       return pln;
275  }
276  static FFTW(plan) mkplan_complex_interleaved(bench_problem *p, unsigned flags)
277  {
278       FFTW(plan) pln;
279       bench_tensor *sz = p->sz, *vecsz = p->vecsz;
280       if (vecsz->rnk == 0 && tensor_unitstridep(sz) && tensor_rowmajorp(sz)) 
281  	  goto api_simple;
282       if (vecsz->rnk == 1 && expressible_as_api_many(sz))
283  	  goto api_many;
284       goto api_guru;
285   api_simple:
286       switch (sz->rnk) {
287  	 case 1:
288  	      if (verbose > 2) printf("using plan_dft_1d\n");
289  	      return FFTW(plan_dft_1d)(sz->dims[0].n, 
290  				       (bench_complex *) p->in,
291  				       (bench_complex *) p->out, 
292  				       p->sign, flags);
293  	      break;
294  	 case 2:
295  	      if (verbose > 2) printf("using plan_dft_2d\n");
296  	      return FFTW(plan_dft_2d)(sz->dims[0].n, sz->dims[1].n,
297  				       (bench_complex *) p->in,
298  				       (bench_complex *) p->out, 
299  				       p->sign, flags);
300  	      break;
301  	 case 3:
302  	      if (verbose > 2) printf("using plan_dft_3d\n");
303  	      return FFTW(plan_dft_3d)(
304  		   sz->dims[0].n, sz->dims[1].n, sz->dims[2].n,
305  		   (bench_complex *) p->in, (bench_complex *) p->out, 
306  		   p->sign, flags);
307  	      break;
308  	 default: {
309  	      int *n = mkn(sz);
310  	      if (verbose > 2) printf("using plan_dft\n");
311  	      pln = FFTW(plan_dft)(sz->rnk, n, 
312  				   (bench_complex *) p->in, 
313  				   (bench_complex *) p->out, p->sign, flags);
314  	      bench_free(n);
315  	      return pln;
316  	 }
317       }
318   api_many:
319       {
320  	  int *n, *inembed, *onembed;
321  	  BENCH_ASSERT(vecsz->rnk == 1);
322  	  n = mkn(sz);
323  	  mknembed_many(sz, &inembed, &onembed);
324  	  if (verbose > 2) printf("using plan_many_dft\n");
325  	  pln = FFTW(plan_many_dft)(
326  	       sz->rnk, n, vecsz->dims[0].n, 
327  	       (bench_complex *) p->in, 
328  	       inembed, sz->dims[sz->rnk - 1].is, vecsz->dims[0].is,
329  	       (bench_complex *) p->out,
330  	       onembed, sz->dims[sz->rnk - 1].os, vecsz->dims[0].os,
331  	       p->sign, flags);
332  	  bench_free(n); bench_free(inembed); bench_free(onembed);
333  	  return pln;
334       }
335   api_guru:
336       {
337  	  FFTW(iodim) *dims, *howmany_dims;
338  	  dims = bench_tensor_to_fftw_iodim(sz);
339  	  howmany_dims = bench_tensor_to_fftw_iodim(vecsz);
340  	  if (verbose > 2) printf("using plan_guru_dft\n");
341  	  pln = FFTW(plan_guru_dft)(sz->rnk, dims,
342  				    vecsz->rnk, howmany_dims,
343  				    (bench_complex *) p->in,
344  				    (bench_complex *) p->out,
345  				    p->sign, flags);
346  	  bench_free(dims);
347  	  bench_free(howmany_dims);
348  	  return pln;
349       }
350  }
351  static FFTW(plan) mkplan_complex(bench_problem *p, unsigned flags)
352  {
353       if (p->split)
354  	  return mkplan_complex_split(p, flags);
355       else
356  	  return mkplan_complex_interleaved(p, flags);
357  }
358  static FFTW(plan) mkplan_r2r(bench_problem *p, unsigned flags)
359  {
360       FFTW(plan) pln;
361       bench_tensor *sz = p->sz, *vecsz = p->vecsz;
362       FFTW(r2r_kind) *k;
363       k = (FFTW(r2r_kind) *) bench_malloc(sizeof(FFTW(r2r_kind)) * sz->rnk);
364       {
365  	  int i;
366  	  for (i = 0; i < sz->rnk; ++i)
367  	       switch (p->k[i]) {
368  		   case R2R_R2HC: k[i] = FFTW_R2HC; break;
369  		   case R2R_HC2R: k[i] = FFTW_HC2R; break;
370  		   case R2R_DHT: k[i] = FFTW_DHT; break;
371  		   case R2R_REDFT00: k[i] = FFTW_REDFT00; break;
372  		   case R2R_REDFT01: k[i] = FFTW_REDFT01; break;
373  		   case R2R_REDFT10: k[i] = FFTW_REDFT10; break;
374  		   case R2R_REDFT11: k[i] = FFTW_REDFT11; break;
375  		   case R2R_RODFT00: k[i] = FFTW_RODFT00; break;
376  		   case R2R_RODFT01: k[i] = FFTW_RODFT01; break;
377  		   case R2R_RODFT10: k[i] = FFTW_RODFT10; break;
378  		   case R2R_RODFT11: k[i] = FFTW_RODFT11; break;
379  		   default: BENCH_ASSERT(0);
380  	       }
381       }
382       if (vecsz->rnk == 0 && tensor_unitstridep(sz) && tensor_rowmajorp(sz)) 
383  	  goto api_simple;
384       if (vecsz->rnk == 1 && expressible_as_api_many(sz))
385  	  goto api_many;
386       goto api_guru;
387   api_simple:
388       switch (sz->rnk) {
389  	 case 1:
390  	      if (verbose > 2) printf("using plan_r2r_1d\n");
391  	      pln = FFTW(plan_r2r_1d)(sz->dims[0].n, 
392  				      (bench_real *) p->in,
393  				      (bench_real *) p->out, 
394  				      k[0], flags);
395  	      goto done;
396  	 case 2:
397  	      if (verbose > 2) printf("using plan_r2r_2d\n");
398  	      pln = FFTW(plan_r2r_2d)(sz->dims[0].n, sz->dims[1].n,
399  				      (bench_real *) p->in,
400  				      (bench_real *) p->out, 
401  				      k[0], k[1], flags);
402  	      goto done;
403  	 case 3:
404  	      if (verbose > 2) printf("using plan_r2r_3d\n");
405  	      pln = FFTW(plan_r2r_3d)(
406  		   sz->dims[0].n, sz->dims[1].n, sz->dims[2].n,
407  		   (bench_real *) p->in, (bench_real *) p->out, 
408  		   k[0], k[1], k[2], flags);
409  	      goto done;
410  	 default: {
411  	      int *n = mkn(sz);
412  	      if (verbose > 2) printf("using plan_r2r\n");
413  	      pln = FFTW(plan_r2r)(sz->rnk, n,
414  				   (bench_real *) p->in, (bench_real *) p->out,
415  				   k, flags);
416  	      bench_free(n);
417  	      goto done;
418  	 }
419       }
420   api_many:
421       {
422  	  int *n, *inembed, *onembed;
423  	  BENCH_ASSERT(vecsz->rnk == 1);
424  	  n = mkn(sz);
425  	  mknembed_many(sz, &inembed, &onembed);
426  	  if (verbose > 2) printf("using plan_many_r2r\n");
427  	  pln = FFTW(plan_many_r2r)(
428  	       sz->rnk, n, vecsz->dims[0].n, 
429  	       (bench_real *) p->in,
430  	       inembed, sz->dims[sz->rnk - 1].is, vecsz->dims[0].is,
431  	       (bench_real *) p->out,
432  	       onembed, sz->dims[sz->rnk - 1].os, vecsz->dims[0].os,
433  	       k, flags);
434  	  bench_free(n); bench_free(inembed); bench_free(onembed);
435  	  goto done;
436       }
437   api_guru:
438       {
439  	  FFTW(iodim) *dims, *howmany_dims;
440  	  dims = bench_tensor_to_fftw_iodim(sz);
441  	  howmany_dims = bench_tensor_to_fftw_iodim(vecsz);
442  	  if (verbose > 2) printf("using plan_guru_r2r\n");
443  	  pln = FFTW(plan_guru_r2r)(sz->rnk, dims,
444  				    vecsz->rnk, howmany_dims,
445  				    (bench_real *) p->in, 
446  				    (bench_real *) p->out, k, flags);
447  	  bench_free(dims);
448  	  bench_free(howmany_dims);
449  	  goto done;
450       }
451   done:
452       bench_free(k);
453       return pln;
454  }
455  FFTW(plan) mkplan(bench_problem *p, unsigned flags)
456  {
457       switch (p->kind) {
458  	 case PROBLEM_COMPLEX:	  return mkplan_complex(p, flags);
459  	 case PROBLEM_REAL:	  return mkplan_real(p, flags);
460  	 case PROBLEM_R2R:        return mkplan_r2r(p, flags);
461  	 default: BENCH_ASSERT(0); return 0;
462       }
463  }
464  void main_init(int *argc, char ***argv)
465  {
466       UNUSED(argc);
467       UNUSED(argv);
468  }
469  void initial_cleanup(void)
470  {
471  }
472  void final_cleanup(void)
473  {
474  }
475  int import_wisdom(FILE *f)
476  {
477       return FFTW(import_wisdom_from_file)(f);
478  }
479  void export_wisdom(FILE *f)
480  {
481       FFTW(export_wisdom_to_file)(f);
482  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-arena_reset.c</h3>
            <pre><code>1  #ifndef ARENA_RESET_PROF_C_
2  #include "test/jemalloc_test.h"
3  #endif
4  #include "jemalloc/internal/extent_mmap.h"
5  #include "jemalloc/internal/rtree.h"
6  #include "test/extent_hooks.h"
7  static unsigned
8  get_nsizes_impl(const char *cmd) {
9  	unsigned ret;
10  	size_t z;
11  	z = sizeof(unsigned);
12  	assert_d_eq(mallctl(cmd, (void *)&ret, &z, NULL, 0), 0,
13  	    "Unexpected mallctl(\"%s\", ...) failure", cmd);
14  	return ret;
15  }
16  static unsigned
17  get_nsmall(void) {
18  	return get_nsizes_impl("arenas.nbins");
19  }
20  static unsigned
21  get_nlarge(void) {
22  	return get_nsizes_impl("arenas.nlextents");
23  }
24  static size_t
25  get_size_impl(const char *cmd, size_t ind) {
26  	size_t ret;
27  	size_t z;
28  	size_t mib[4];
29  	size_t miblen = 4;
30  	z = sizeof(size_t);
31  	assert_d_eq(mallctlnametomib(cmd, mib, &miblen),
32  	    0, "Unexpected mallctlnametomib(\"%s\", ...) failure", cmd);
33  	mib[2] = ind;
34  	z = sizeof(size_t);
35  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&ret, &z, NULL, 0),
36  	    0, "Unexpected mallctlbymib([\"%s\", %zu], ...) failure", cmd, ind);
37  	return ret;
38  }
39  static size_t
40  get_small_size(size_t ind) {
41  	return get_size_impl("arenas.bin.0.size", ind);
42  }
43  static size_t
44  get_large_size(size_t ind) {
45  	return get_size_impl("arenas.lextent.0.size", ind);
46  }
47  static size_t
48  vsalloc(tsdn_t *tsdn, const void *ptr) {
49  	rtree_ctx_t rtree_ctx_fallback;
50  	rtree_ctx_t *rtree_ctx = tsdn_rtree_ctx(tsdn, &rtree_ctx_fallback);
51  	extent_t *extent;
52  	szind_t szind;
53  	if (rtree_extent_szind_read(tsdn, &extents_rtree, rtree_ctx,
54  	    (uintptr_t)ptr, false, &extent, &szind)) {
55  		return 0;
56  	}
57  	if (extent == NULL) {
58  		return 0;
59  	}
60  	if (extent_state_get(extent) != extent_state_active) {
61  		return 0;
62  	}
63  	if (szind == SC_NSIZES) {
64  		return 0;
65  	}
66  	return sz_index2size(szind);
67  }
68  static unsigned
69  do_arena_create(extent_hooks_t *h) {
70  	unsigned arena_ind;
71  	size_t sz = sizeof(unsigned);
72  	assert_d_eq(mallctl("arenas.create", (void *)&arena_ind, &sz,
73  	    (void *)(h != NULL ? &h : NULL), (h != NULL ? sizeof(h) : 0)), 0,
74  	    "Unexpected mallctl() failure");
75  	return arena_ind;
76  }
77  static void
78  do_arena_reset_pre(unsigned arena_ind, void ***ptrs, unsigned *nptrs) {
79  #define NLARGE	32
80  	unsigned nsmall, nlarge, i;
81  	size_t sz;
82  	int flags;
83  	tsdn_t *tsdn;
84  	flags = MALLOCX_ARENA(arena_ind) | MALLOCX_TCACHE_NONE;
85  	nsmall = get_nsmall();
86  	nlarge = get_nlarge() > NLARGE ? NLARGE : get_nlarge();
87  	*nptrs = nsmall + nlarge;
88  	*ptrs = (void **)malloc(*nptrs * sizeof(void *));
89  	assert_ptr_not_null(*ptrs, "Unexpected malloc() failure");
90  	for (i = 0; i < nsmall; i++) {
91  		sz = get_small_size(i);
92  		(*ptrs)[i] = mallocx(sz, flags);
93  		assert_ptr_not_null((*ptrs)[i],
94  		    "Unexpected mallocx(%zu, %#x) failure", sz, flags);
95  	}
96  	for (i = 0; i < nlarge; i++) {
97  		sz = get_large_size(i);
98  		(*ptrs)[nsmall + i] = mallocx(sz, flags);
99  		assert_ptr_not_null((*ptrs)[i],
100  		    "Unexpected mallocx(%zu, %#x) failure", sz, flags);
101  	}
102  	tsdn = tsdn_fetch();
103  	for (i = 0; i < *nptrs; i++) {
104  		assert_zu_gt(ivsalloc(tsdn, (*ptrs)[i]), 0,
105  		    "Allocation should have queryable size");
106  	}
107  }
108  static void
109  do_arena_reset_post(void **ptrs, unsigned nptrs, unsigned arena_ind) {
110  	tsdn_t *tsdn;
111  	unsigned i;
112  	tsdn = tsdn_fetch();
113  	if (have_background_thread) {
114  		malloc_mutex_lock(tsdn,
115  		    &background_thread_info_get(arena_ind)->mtx);
116  	}
117  	for (i = 0; i < nptrs; i++) {
118  		assert_zu_eq(vsalloc(tsdn, ptrs[i]), 0,
119  		    "Allocation should no longer exist");
120  	}
121  	if (have_background_thread) {
122  		malloc_mutex_unlock(tsdn,
123  		    &background_thread_info_get(arena_ind)->mtx);
124  	}
125  	free(ptrs);
126  }
127  static void
128  do_arena_reset_destroy(const char *name, unsigned arena_ind) {
129  	size_t mib[3];
130  	size_t miblen;
131  	miblen = sizeof(mib)/sizeof(size_t);
132  	assert_d_eq(mallctlnametomib(name, mib, &miblen), 0,
133  	    "Unexpected mallctlnametomib() failure");
134  	mib[1] = (size_t)arena_ind;
135  	assert_d_eq(mallctlbymib(mib, miblen, NULL, NULL, NULL, 0), 0,
136  	    "Unexpected mallctlbymib() failure");
137  }
138  static void
139  do_arena_reset(unsigned arena_ind) {
140  	do_arena_reset_destroy("arena.0.reset", arena_ind);
141  }
142  static void
143  do_arena_destroy(unsigned arena_ind) {
144  	do_arena_reset_destroy("arena.0.destroy", arena_ind);
145  }
146  TEST_BEGIN(test_arena_reset) {
147  	unsigned arena_ind;
148  	void **ptrs;
149  	unsigned nptrs;
150  	arena_ind = do_arena_create(NULL);
151  	do_arena_reset_pre(arena_ind, &ptrs, &nptrs);
152  	do_arena_reset(arena_ind);
153  	do_arena_reset_post(ptrs, nptrs, arena_ind);
154  }
155  TEST_END
156  static bool
157  arena_i_initialized(unsigned arena_ind, bool refresh) {
158  	bool initialized;
159  	size_t mib[3];
160  	size_t miblen, sz;
161  	if (refresh) {
162  		uint64_t epoch = 1;
163  		assert_d_eq(mallctl("epoch", NULL, NULL, (void *)&epoch,
164  		    sizeof(epoch)), 0, "Unexpected mallctl() failure");
165  	}
166  	miblen = sizeof(mib)/sizeof(size_t);
167  	assert_d_eq(mallctlnametomib("arena.0.initialized", mib, &miblen), 0,
168  	    "Unexpected mallctlnametomib() failure");
169  	mib[1] = (size_t)arena_ind;
170  	sz = sizeof(initialized);
171  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&initialized, &sz, NULL,
172  	    0), 0, "Unexpected mallctlbymib() failure");
173  	return initialized;
174  }
175  TEST_BEGIN(test_arena_destroy_initial) {
176  	assert_false(arena_i_initialized(MALLCTL_ARENAS_DESTROYED, false),
177  	    "Destroyed arena stats should not be initialized");
178  }
179  TEST_END
180  TEST_BEGIN(test_arena_destroy_hooks_default) {
181  	unsigned arena_ind, arena_ind_another, arena_ind_prev;
182  	void **ptrs;
183  	unsigned nptrs;
184  	arena_ind = do_arena_create(NULL);
185  	do_arena_reset_pre(arena_ind, &ptrs, &nptrs);
186  	assert_false(arena_i_initialized(arena_ind, false),
187  	    "Arena stats should not be initialized");
188  	assert_true(arena_i_initialized(arena_ind, true),
189  	    "Arena stats should be initialized");
190  	arena_ind_another = do_arena_create(NULL);
191  	do_arena_destroy(arena_ind);
192  	assert_false(arena_i_initialized(arena_ind, true),
193  	    "Arena stats should not be initialized");
194  	assert_true(arena_i_initialized(MALLCTL_ARENAS_DESTROYED, false),
195  	    "Destroyed arena stats should be initialized");
196  	do_arena_reset_post(ptrs, nptrs, arena_ind);
197  	arena_ind_prev = arena_ind;
<span onclick='openModal()' class='match'>198  	arena_ind = do_arena_create(NULL);
199  	do_arena_reset_pre(arena_ind, &ptrs, &nptrs);
200  	assert_u_eq(arena_ind, arena_ind_prev,
</span>201  	    "Arena index should have been recycled");
202  	do_arena_destroy(arena_ind);
203  	do_arena_reset_post(ptrs, nptrs, arena_ind);
204  	do_arena_destroy(arena_ind_another);
205  }
206  TEST_END
207  static bool
208  extent_dalloc_unmap(extent_hooks_t *extent_hooks, void *addr, size_t size,
209      bool committed, unsigned arena_ind) {
210  	TRACE_HOOK("%s(extent_hooks=%p, addr=%p, size=%zu, committed=%s, "
211  	    "arena_ind=%u)\n", __func__, extent_hooks, addr, size, committed ?
212  	    "true" : "false", arena_ind);
213  	assert_ptr_eq(extent_hooks, &hooks,
214  	    "extent_hooks should be same as pointer used to set hooks");
215  	assert_ptr_eq(extent_hooks->dalloc, extent_dalloc_unmap,
216  	    "Wrong hook function");
217  	called_dalloc = true;
218  	if (!try_dalloc) {
219  		return true;
220  	}
221  	did_dalloc = true;
222  	if (!maps_coalesce && opt_retain) {
223  		return true;
224  	}
225  	pages_unmap(addr, size);
226  	return false;
227  }
228  static extent_hooks_t hooks_orig;
229  static extent_hooks_t hooks_unmap = {
230  	extent_alloc_hook,
231  	extent_dalloc_unmap, &bsol;* dalloc */
232  	extent_destroy_hook,
233  	extent_commit_hook,
234  	extent_decommit_hook,
235  	extent_purge_lazy_hook,
236  	extent_purge_forced_hook,
237  	extent_split_hook,
238  	extent_merge_hook
239  };
240  TEST_BEGIN(test_arena_destroy_hooks_unmap) {
241  	unsigned arena_ind;
242  	void **ptrs;
243  	unsigned nptrs;
244  	extent_hooks_prep();
245  	if (maps_coalesce) {
246  		try_decommit = false;
247  	}
248  	memcpy(&hooks_orig, &hooks, sizeof(extent_hooks_t));
249  	memcpy(&hooks, &hooks_unmap, sizeof(extent_hooks_t));
250  	did_alloc = false;
251  	arena_ind = do_arena_create(&hooks);
252  	do_arena_reset_pre(arena_ind, &ptrs, &nptrs);
253  	assert_true(did_alloc, "Expected alloc");
254  	assert_false(arena_i_initialized(arena_ind, false),
255  	    "Arena stats should not be initialized");
256  	assert_true(arena_i_initialized(arena_ind, true),
257  	    "Arena stats should be initialized");
258  	did_dalloc = false;
259  	do_arena_destroy(arena_ind);
260  	assert_true(did_dalloc, "Expected dalloc");
261  	assert_false(arena_i_initialized(arena_ind, true),
262  	    "Arena stats should not be initialized");
263  	assert_true(arena_i_initialized(MALLCTL_ARENAS_DESTROYED, false),
264  	    "Destroyed arena stats should be initialized");
265  	do_arena_reset_post(ptrs, nptrs, arena_ind);
266  	memcpy(&hooks, &hooks_orig, sizeof(extent_hooks_t));
267  }
268  TEST_END
269  int
270  main(void) {
271  	return test(
272  	    test_arena_reset,
273  	    test_arena_destroy_initial,
274  	    test_arena_destroy_hooks_default,
275  	    test_arena_destroy_hooks_unmap);
276  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-bench.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-arena_reset.c</div>
                </div>
                <div class="column column_space"><pre><code>198  	  n = mkn(sz);
199  	  mknembed_many(sz, &inembed, &onembed);
200  	  if (p->sign < 0) {
</pre></code></div>
                <div class="column column_space"><pre><code>198  	arena_ind = do_arena_create(NULL);
199  	do_arena_reset_pre(arena_ind, &ptrs, &nptrs);
200  	assert_u_eq(arena_ind, arena_ind_prev,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    