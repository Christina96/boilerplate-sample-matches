<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for imdocker.c &amp; mmkubernetes.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for imdocker.c &amp; mmkubernetes.c
      </h3>
<h1 align="center">
        6.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>imdocker.c (6.7867036%)<th>mmkubernetes.c (5.4384017%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(262-281)<td><a href="#" name="0">(231-253)</a><td align="center"><font color="#ff0000">32</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(897-904)<td><a href="#" name="1">(589-602)</a><td align="center"><font color="#b70000">23</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1486-1506)<td><a href="#" name="2">(712-724)</a><td align="center"><font color="#870000">17</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(978-990)<td><a href="#" name="3">(1748-1774)</a><td align="center"><font color="#670000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(862-867)<td><a href="#" name="4">(646-652)</a><td align="center"><font color="#670000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>imdocker.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef __sun
2 #define _XPG4_2
3 #endif
4 #include "config.h"
5 #include "rsyslog.h"
6 #include &lt;stdlib.h&gt;
7 #include &lt;stdio.h&gt;
8 #include &lt;ctype.h&gt;
9 #include &lt;string.h&gt;
10 #include &lt;errno.h&gt;
11 #include &lt;curl/curl.h&gt;
12 #include &lt;json.h&gt;
13 #include &lt;assert.h&gt;
14 #include &lt;signal.h&gt;
15 #include &lt;stdbool.h&gt;
16 #include "cfsysline.h"  #include "unicode-helper.h"
17 #include "module-template.h"
18 #include "srUtils.h"    #include "errmsg.h"
19 #include "net.h"
20 #include "glbl.h"
21 #include "msg.h"
22 #include "parser.h"
23 #include "prop.h"
24 #include "debug.h"
25 #include "statsobj.h"
26 #include "datetime.h"
27 #include "ratelimit.h"
28 #include "hashtable.h"
29 #include "hashtable_itr.h"
30 #if !defined(_AIX)
31 #pragma GCC diagnostic ignored "-Wswitch-enum"
32 #endif
33 MODULE_TYPE_INPUT
34 MODULE_TYPE_NOKEEP
35 MODULE_CNFNAME("imdocker")
36 extern int Debug;
37 #define USE_MULTI_LINE
38 #undef ENABLE_DEBUG_BYTE_BUFFER
39 #define DOCKER_TAG_NAME                     "docker:"
40 #define DOCKER_CONTAINER_ID_PARSE_NAME      "Id"
41 #define DOCKER_CONTAINER_NAMES_PARSE_NAME   "Names"
42 #define DOCKER_CONTAINER_IMAGEID_PARSE_NAME "ImageID"
43 #define DOCKER_CONTAINER_CREATED_PARSE_NAME "Created"
44 #define DOCKER_CONTAINER_LABELS_PARSE_NAME  "Labels"
45 #define DOCKER_CONTAINER_LABEL_KEY_STARTREGEX "imdocker.startregex"
46 #define DFLT_pollingInterval   60      #define DFLT_retrieveNewLogsFromStart 1#define DFLT_containersLimit   25      #define DFLT_trimLineOverBytes 4194304 #define DFLT_bEscapeLF         1       
47 #define DFLT_SEVERITY pri2sev(LOG_INFO)
48 #define DFLT_FACILITY pri2fac(LOG_USER)
49 enum {
50 	dst_invalid = -1,
51 	dst_stdin,
52 	dst_stdout,
53 	dst_stderr,
54 	dst_stream_type_count
55 } docker_stream_type_t;
56 typedef struct imdocker_buf_s {
57 	uchar  *data;
58 	size_t len;
59 	size_t data_size;
60 } imdocker_buf_t;
61 typedef struct docker_cont_logs_buf_s {
62 	imdocker_buf_t *buf;
63 	int8_t         stream_type;
64 	size_t         bytes_remaining;
65 } docker_cont_logs_buf_t;
66 struct docker_cont_logs_inst_s;
67 typedef rsRetVal (*submitmsg_funcptr) (struct docker_cont_logs_inst_s *pInst, docker_cont_logs_buf_t *pBufdata,
68 		const uchar* pszTag);
69 typedef submitmsg_funcptr SubmitMsgFuncPtr;
70 typedef struct docker_cont_logs_req_s {
71 	CURL     *curl;
72 	docker_cont_logs_buf_t* data_bufs[dst_stream_type_count];
73 	SubmitMsgFuncPtr submitMsg;
74 } docker_cont_logs_req_t;
75 typedef struct imdocker_req_s {
76 	CURL           *curl;
77 	imdocker_buf_t *buf;
78 } imdocker_req_t;
79 typedef struct docker_container_info_s {
80 	uchar *name;
81 	uchar *image_id;
82 	uint64_t created;
83 	uchar *json_str_labels;
84 } docker_container_info_t;
85 typedef struct docker_cont_logs_inst_s {
86 	char *id;
87 	char short_id[12];
88 	docker_container_info_t *container_info;
89 	docker_cont_logs_req_t  *logsReq;
90 	uchar *start_regex;
91 	regex_t start_preg;  	uint32_t prevSegEnd;
92 } docker_cont_logs_inst_t;
93 typedef struct docker_cont_log_instances_s {
94 	struct hashtable* ht_container_log_insts;
95 	pthread_mutex_t mut;
96 	CURLM         *curlm;
97 	uint64_t last_container_created;
98 	uchar   *last_container_id;
99 	time_t  time_started;
100 } docker_cont_log_instances_t;
101 static rsRetVal imdockerBufNew(imdocker_buf_t **ppThis);
102 static void imdockerBufDestruct(imdocker_buf_t *pThis);
103 static rsRetVal dockerContLogsBufNew(docker_cont_logs_buf_t **ppThis);
104 static void dockerContLogsBufDestruct(docker_cont_logs_buf_t *pThis);
105 static rsRetVal dockerContLogsBufWrite(docker_cont_logs_buf_t *pThis, const uchar *pdata,
106 		size_t write_size);
107 static rsRetVal imdockerReqNew(imdocker_req_t **ppThis);
108 static void imdockerReqDestruct(imdocker_req_t *pThis);
109 static rsRetVal dockerContLogsReqNew(docker_cont_logs_req_t **ppThis, SubmitMsgFuncPtr submitMsg);
110 static void dockerContLogsReqDestruct(docker_cont_logs_req_t *pThis);
111 static rsRetVal
112 dockerContLogsInstNew(docker_cont_logs_inst_t **ppThis, const char* id,
113 		docker_container_info_t *container_info, SubmitMsgFuncPtr submitMsg);
114 static void dockerContLogsInstDestruct(docker_cont_logs_inst_t *pThis);
115 static rsRetVal dockerContLogsInstSetUrlById (sbool isInit, docker_cont_logs_inst_t *pThis,
116 		CURLM *curlm, const char* containerId);
117 static rsRetVal dockerContLogReqsNew(docker_cont_log_instances_t **ppThis);
118 static rsRetVal dockerContLogReqsDestruct(docker_cont_log_instances_t *pThis);
119 static rsRetVal dockerContLogReqsGet(docker_cont_log_instances_t *pThis,
120 		docker_cont_logs_inst_t** ppContLogsInst, const char *id);
121 static rsRetVal dockerContLogReqsPrint(docker_cont_log_instances_t *pThis);
122 static rsRetVal dockerContLogReqsAdd(docker_cont_log_instances_t *pThis,
123 		docker_cont_logs_inst_t *pContLogsReqInst);
124 static rsRetVal dockerContLogReqsRemove(docker_cont_log_instances_t *pThis, const char *id);
125 static rsRetVal dockerContainerInfoNew(docker_container_info_t **pThis);
126 static void dockerContainerInfoDestruct(docker_container_info_t *pThis);
127 static CURLcode docker_get(imdocker_req_t *req, const char* url);
128 static char* dupDockerContainerName(const char* pname);
129 static rsRetVal SubmitMsg(docker_cont_logs_inst_t *pInst, docker_cont_logs_buf_t *pBufData,
130 		const uchar* pszTag);
131 static rsRetVal
132 SubmitMsg2(docker_cont_logs_inst_t *pInst, docker_cont_logs_buf_t *pBufData, const uchar* pszTag);
133 static size_t imdocker_container_list_curlCB(void *data, size_t size, size_t nmemb, void *buffer);
134 static size_t imdocker_container_logs_curlCB(void *data, size_t size, size_t nmemb, void *buffer);
135 static sbool get_stream_info(const uchar* data, size_t size, int8_t *stream_type, size_t *payload_size);
136 static int8_t is_valid_stream_type(int8_t stream_type);
137 DEF_IMOD_STATIC_DATA
138 DEFobjCurrIf(glbl)
139 DEFobjCurrIf(prop)
140 DEFobjCurrIf(parser)
141 DEFobjCurrIf(datetime)
142 DEFobjCurrIf(statsobj)
143 statsobj_t *modStats;
144 STATSCOUNTER_DEF(ctrSubmit, mutCtrSubmit)
145 STATSCOUNTER_DEF(ctrLostRatelimit, mutCtrLostRatelimit)
146 STATSCOUNTER_DEF(ctrCurlError, mutCtrCurlError)
147 const char* DFLT_dockerAPIUnixSockAddr  = "/var/run/docker.sock";
148 const char* DFLT_dockerAPIAdd           = "http://localhost:2375";
149 const char* DFLT_apiVersionStr          = "v1.27";
150 const char* DFLT_listContainersOptions  = "";
151 const char* DFLT_getContainerLogOptions = "timestamps=0&amp;follow=1&amp;stdout=1&amp;stderr=1&amp;tail=1";
152 const char* DFLT_getContainerLogOptionsWithoutTail = "timestamps=0&amp;follow=1&amp;stdout=1&amp;stderr=1";
153 struct modConfData_s {
154 	rsconf_t *pConf;  	uchar    *apiVersionStr;
155 	uchar    *listContainersOptions;
156 	uchar    *getContainerLogOptions;
157 	uchar    *getContainerLogOptionsWithoutTail;
158 	int      iPollInterval;  	uchar    *dockerApiUnixSockAddr;
159 	uchar    *dockerApiAddr;
160 	sbool    retrieveNewLogsFromStart;
161 	int      containersLimit;
162 	int      trimLineOverBytes;
163 	int      iDfltSeverity;
164 	int      iDfltFacility;
165 	sbool    bEscapeLf;
166 };
167 static modConfData_t *loadModConf = NULL;
168 static modConfData_t *runModConf = NULL;
169 static prop_t *pInputName = NULL;   static prop_t *pLocalHostIP = NULL; 
170 static ratelimit_t *ratelimiter = NULL;
171 <a name="0"></a>
172 static struct cnfparamdescr modpdescr[] = {
173 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "apiversionstr", eCmdHdlrString, 0 },
174 	{ "dockerapiunixsockaddr", eCmdHdlrString, 0 },
175 	{ "dockerapiaddr", eCmdHdlrString, 0 },
176 	{ "listcontainersoptions", eCmdHdlrString, 0 },
177 	{ "getcontainerlogoptions", eCmdHdlrString, 0 },
178 	{ "pollinginterval", eCmdHdlrPositiveInt, 0 },
179 	{ "retrievenewlogsfromstart", eCmdHdlrBinary, 0 },
180 	{ "trimlineoverbytes", eCmdHdlrPositiveInt, 0 },
181 	{ "defaultseverity", eCmdHdlrSeverity, 0 },
182 	{ "defaultfacility", eCmdHdlrFacility, 0 },
183 	{ "escapelf", eCmdHdlrBinary, 0 },
184 };
185 static struct cnfparamblk modpblk =
186 	{ CNFPARAMBLK_VERSION,
187 		sizeof(modpdescr)/sizeof(struct cnfparamdescr),
188 		modpdescr
189 	};
190 static int bLegacyCnfModGlobalsPermitted; 
191 static rsRetVal
192 imdockerBufNew(imdocker_buf_t **ppThis) {
193 	DEFiRet;
194 	imdocker_buf_t *pThis = (imdocker_buf_t*) calloc(1, sizeof(imdocker_buf_t));
195 	if (!pThis) { return RS_RET_OUT_OF_MEMORY; }
196 	*ppThis = pThis;
197 	RETiRet;
198 }
199 static void
200 imdockerBufDestruct(imdocker_buf_t *pThis) {
201 	if (pThis) {
202 		if (pThis-&gt;data) {
203 			free(pThis-&gt;data);
204 			pThis-&gt;data = NULL;
205 		}
206 		free(pThis);
207 	}
208 }
209 static rsRetVal
210 dockerContLogsBufNew(docker_cont_logs_buf_t **ppThis) {
211 	DEFiRet;
212 	docker_cont_logs_buf_t *pThis = (docker_cont_logs_buf_t*) calloc(1, sizeof(docker_cont_logs_buf_t));
213 	if (pThis &amp;&amp; (iRet = imdockerBufNew(&amp;pThis-&gt;buf)) == RS_RET_OK) {
214 		pThis-&gt;stream_type = dst_invalid;
215 		pThis-&gt;bytes_remaining = 0;
216 		*ppThis = pThis;
217 	} else {
218 		dockerContLogsBufDestruct(pThis);
219 	}
220 	RETiRet;
221 }
222 static void
223 dockerContLogsBufDestruct(docker_cont_logs_buf_t *pThis) {
224 	if (pThis) {
225 		if (pThis-&gt;buf) {
226 			imdockerBufDestruct(pThis-&gt;buf);
227 		}
228 		free(pThis);
229 	}
230 }
231 static rsRetVal
232 dockerContLogsBufWrite(docker_cont_logs_buf_t *const pThis, const uchar *const pdata, const size_t write_size) {
233 	DEFiRet;
234 	imdocker_buf_t *const mem = pThis-&gt;buf;
235 	if (mem-&gt;len + write_size + 1 &gt; mem-&gt;data_size) {
236 		uchar *const pbuf = realloc(mem-&gt;data, mem-&gt;len + write_size + 1);
237 		if(pbuf == NULL) {
238 			LogError(errno, RS_RET_ERR, "%s() - realloc failed!\n", __FUNCTION__);
239 			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
240 		}
241 		mem-&gt;data = pbuf;
242 		mem-&gt;data_size = mem-&gt;len+ write_size + 1;
243 	}
244 	memcpy(&amp;(mem-&gt;data[mem-&gt;len]), pdata, write_size);
245 	mem-&gt;len += write_size;
246 	mem-&gt;data[mem-&gt;len] = '\0';
247 	if (write_size &gt; pThis-&gt;bytes_remaining) {
248 		pThis-&gt;bytes_remaining = 0;
249 	} else {
250 		pThis-&gt;bytes_remaining -= write_size;
251 	}
252 finalize_it:
253 	RETiRet;
254 }
255 rsRetVal imdockerReqNew(imdocker_req_t **ppThis) {
256 	DEFiRet;
257 	imdocker_req_t *pThis = (imdocker_req_t*) calloc(1, sizeof(imdocker_req_t));
258 	CHKmalloc(pThis);
259 	pThis-&gt;curl = curl_easy_init();
260 	if (!pThis-&gt;curl) {
261 		ABORT_FINALIZE(RS_RET_ERR);
262 	}
263 	CHKiRet(imdockerBufNew(&amp;(pThis-&gt;buf)));
264 	*ppThis = pThis;
265 finalize_it:
266 	if (iRet != RS_RET_OK &amp;&amp; pThis) {
267 		imdockerReqDestruct(pThis);
268 	}
269 	RETiRet;
270 }
271 void imdockerReqDestruct(imdocker_req_t *pThis) {
272 	if (pThis) {
273 		if (pThis-&gt;buf) {
274 			imdockerBufDestruct(pThis-&gt;buf);
275 		}
276 		if (pThis-&gt;curl) {
277 			curl_easy_cleanup(pThis-&gt;curl);
278 			pThis-&gt;curl = NULL;
279 		}
280 		free(pThis);
281 	}
282 }
283 static rsRetVal
284 dockerContLogsReqNew(docker_cont_logs_req_t **ppThis, SubmitMsgFuncPtr submitMsg) {
285 	DEFiRet;
286 	docker_cont_logs_req_t *pThis = (docker_cont_logs_req_t*) calloc(1, sizeof(docker_cont_logs_req_t));
287 	CHKmalloc(pThis);
288 	pThis-&gt;submitMsg = submitMsg;
289 	pThis-&gt;curl = curl_easy_init();
290 	if (!pThis-&gt;curl) {
291 		ABORT_FINALIZE(RS_RET_ERR);
292 	}
293 	for (int i = 0; i &lt; dst_stream_type_count; i ++) {
294 		CHKiRet(dockerContLogsBufNew(&amp;pThis-&gt;data_bufs[i]));
295 	}
296 	*ppThis = pThis;
297 finalize_it:
298 	if (iRet != RS_RET_OK) {
299 		if (pThis) {
300 			dockerContLogsReqDestruct(pThis);
301 		}
302 	}
303 	RETiRet;
304 }
305 static void
306 dockerContLogsReqDestruct(docker_cont_logs_req_t *pThis) {
307 	if (pThis) {
308 		for (int i = 0; i &lt; dst_stream_type_count; i++) {
309 			dockerContLogsBufDestruct(pThis-&gt;data_bufs[i]);
310 		}
311 		if (pThis-&gt;curl) {
312 			curl_easy_cleanup(pThis-&gt;curl);
313 			pThis-&gt;curl=NULL;
314 		}
315 		free(pThis);
316 	}
317 }
318 static rsRetVal
319 dockerContLogsInstPrint(docker_cont_logs_inst_t * pThis) {
320 	DEFiRet;
321 	DBGPRINTF("\t container id: %s\n", pThis-&gt;id);
322 	char* pUrl = NULL;
323 	curl_easy_getinfo(pThis-&gt;logsReq-&gt;curl, CURLINFO_EFFECTIVE_URL, &amp;pUrl);
324 	DBGPRINTF("\t container url: %s\n", pUrl);
325 	RETiRet;
326 }
327 static void
328 dockerContLogsInstDestruct(docker_cont_logs_inst_t *pThis) {
329 	if (pThis) {
330 		if (pThis-&gt;id) {
331 			free((void*)pThis-&gt;id);
332 		}
333 		if (pThis-&gt;container_info) {
334 			dockerContainerInfoDestruct(pThis-&gt;container_info);
335 		}
336 		if (pThis-&gt;logsReq) {
337 			dockerContLogsReqDestruct(pThis-&gt;logsReq);
338 		}
339 		if (pThis-&gt;start_regex) {
340 			free(pThis-&gt;start_regex);
341 			regfree(&amp;pThis-&gt;start_preg);
342 		}
343 		free(pThis);
344 	}
345 }
346 static rsRetVal
347 parseLabels(docker_cont_logs_inst_t *inst, const uchar* json) {
348 	DEFiRet;
349 	DBGPRINTF("%s() - parsing json=%s\n", __FUNCTION__, json);
350 	struct fjson_object *json_obj = fjson_tokener_parse((const char*)json);
351 	struct fjson_object_iterator it = fjson_object_iter_begin(json_obj);
352 	struct fjson_object_iterator itEnd = fjson_object_iter_end(json_obj);
353 	while (!fjson_object_iter_equal(&amp;it, &amp;itEnd)) {
354 		if (Debug) {
355 			DBGPRINTF("%s - \t%s: '%s'\n",
356 					__FUNCTION__,
357 					fjson_object_iter_peek_name(&amp;it),
358 					fjson_object_get_string(fjson_object_iter_peek_value(&amp;it)));
359 		}
360 		if (strcmp(fjson_object_iter_peek_name(&amp;it), DOCKER_CONTAINER_LABEL_KEY_STARTREGEX) == 0) {
361 			inst-&gt;start_regex = (uchar*)strdup(fjson_object_get_string(fjson_object_iter_peek_value(&amp;it)));
362 			int err = regcomp(&amp;inst-&gt;start_preg, fjson_object_get_string(fjson_object_iter_peek_value(&amp;it)),
363 					REG_EXTENDED);
364 			if (err != 0) {
365 				char errbuf[512];
366 				regerror(err, &amp;inst-&gt;start_preg, errbuf, sizeof(errbuf));
367 				LogError(0, err, "%s() - error in startregex compile: %s", __FUNCTION__, errbuf);
368 				ABORT_FINALIZE(RS_RET_ERR);
369 			}
370 		}
371 		fjson_object_iter_next(&amp;it);
372 	}
373 finalize_it:
374 	if (json_obj) {
375 		json_object_put(json_obj);
376 	}
377 	RETiRet;
378 }
379 static rsRetVal
380 dockerContLogsInstNew(docker_cont_logs_inst_t **ppThis, const char* id,
381 		docker_container_info_t *container_info, SubmitMsgFuncPtr submitMsg) {
382 	DEFiRet;
383 	docker_cont_logs_inst_t *pThis = NULL;
384 	CHKmalloc(pThis = calloc(1, sizeof(docker_cont_logs_inst_t)));
385 	pThis-&gt;id = strdup((char*)id);
386 	strncpy((char*) pThis-&gt;short_id, id, sizeof(pThis-&gt;short_id)-1);
387 	CHKiRet(dockerContLogsReqNew(&amp;pThis-&gt;logsReq, submitMsg));
388 	if (container_info) {
389 		CHKiRet(dockerContainerInfoNew(&amp;pThis-&gt;container_info));
390 		if (container_info-&gt;image_id) {
391 			pThis-&gt;container_info-&gt;image_id = (uchar*)strdup((char*)container_info-&gt;image_id);
392 		}
393 		if (container_info-&gt;name) {
394 			const char *pname = (const char*)container_info-&gt;name;
395 			pThis-&gt;container_info-&gt;name = (uchar*)dupDockerContainerName(pname);
396 		}
397 		if (container_info-&gt;json_str_labels) {
398 			pThis-&gt;container_info-&gt;json_str_labels =
399 				(uchar*)strdup((char*)container_info-&gt;json_str_labels);
400 		}
401 		pThis-&gt;container_info-&gt;created = container_info-&gt;created;
402 	}
403 	pThis-&gt;start_regex = NULL;
404 	pThis-&gt;prevSegEnd = 0;
405 	if (pThis-&gt;container_info &amp;&amp; pThis-&gt;container_info-&gt;json_str_labels) {
406 		parseLabels(pThis, pThis-&gt;container_info-&gt;json_str_labels);
407 	}
408 	*ppThis = pThis;
409 finalize_it:
410 	if (iRet != RS_RET_OK) {
411 		if (pThis) {
412 			dockerContLogsInstDestruct(pThis);
413 		}
414 	}
415 	RETiRet;
416 }
417 static rsRetVal
418 dockerContLogsInstSetUrl(docker_cont_logs_inst_t *pThis, CURLM *curlm, const char* pUrl) {
419 	DEFiRet;
420 	CURLcode ccode = CURLE_OK;
421 	CURLMcode mcode = CURLM_OK;
422 	if (curlm) {
423 		docker_cont_logs_req_t *req = pThis-&gt;logsReq;
424 		if (!runModConf-&gt;dockerApiAddr) {
425 			ccode = curl_easy_setopt(req-&gt;curl, CURLOPT_UNIX_SOCKET_PATH,
426 					runModConf-&gt;dockerApiUnixSockAddr);
427 			if (ccode != CURLE_OK) {
428 				LogError(0, RS_RET_ERR,
429 						"imdocker: curl_easy_setopt(CURLOPT_UNIX_SOCKET_PATH) error - %d:%s\n",
430 						ccode, curl_easy_strerror(ccode));
431 				ABORT_FINALIZE(RS_RET_ERR);
432 			}
433 		}
434 		ccode = curl_easy_setopt(req-&gt;curl, CURLOPT_WRITEFUNCTION, imdocker_container_logs_curlCB);
435 		if (ccode != CURLE_OK) {
436 				LogError(0, RS_RET_ERR,
437 						"imdocker: curl_easy_setopt(CURLOPT_WRITEFUNCTION) error - %d:%s\n",
438 						ccode, curl_easy_strerror(ccode));
439 				ABORT_FINALIZE(RS_RET_ERR);
440 		}
441 		ccode = curl_easy_setopt(req-&gt;curl, CURLOPT_WRITEDATA, pThis);
442 		if (ccode != CURLE_OK) {
443 				LogError(0, RS_RET_ERR, "imdocker: curl_easy_setopt(CURLOPT_WRITEDATA) error - %d:%s\n",
444 						ccode, curl_easy_strerror(ccode));
445 				ABORT_FINALIZE(RS_RET_ERR);
446 		}
447 		ccode = curl_easy_setopt(pThis-&gt;logsReq-&gt;curl, CURLOPT_URL, pUrl);
448 		if (ccode != CURLE_OK) {
449 			LogError(0, RS_RET_ERR, "imdocker: could not set url - %d:%s\n",
450 					ccode, curl_easy_strerror(ccode));
451 			ABORT_FINALIZE(RS_RET_ERR);
452 		}
453 		ccode = curl_easy_setopt(pThis-&gt;logsReq-&gt;curl, CURLOPT_PRIVATE, pThis-&gt;id);
454 		if (ccode != CURLE_OK) {
455 			LogError(0, RS_RET_ERR, "imdocker: could not set private data - %d:%s\n",
456 					ccode, curl_easy_strerror(ccode));
457 			ABORT_FINALIZE(RS_RET_ERR);
458 		}
459 		mcode = curl_multi_add_handle(curlm, pThis-&gt;logsReq-&gt;curl);
460 		if (mcode != CURLM_OK) {
461 			LogError(0, RS_RET_ERR, "imdocker: error curl_multi_add_handle ret- %d:%s\n",
462 					mcode, curl_multi_strerror(mcode));
463 			ABORT_FINALIZE(RS_RET_ERR);
464 		}
465 	}
466 finalize_it:
467 	if (ccode != CURLE_OK) {
468 		STATSCOUNTER_INC(ctrCurlError, mutCtrCurlError);
469 	}
470 	RETiRet;
471 }
472 static rsRetVal
473 dockerContLogsInstSetUrlById (sbool isInit, docker_cont_logs_inst_t *pThis, CURLM *curlm,
474 		const char* containerId) {
475 	char url[256];
476 	const uchar* container_log_options = runModConf-&gt;getContainerLogOptionsWithoutTail;
477 	if (isInit || !runModConf-&gt;retrieveNewLogsFromStart) {
478 		container_log_options = runModConf-&gt;getContainerLogOptions;
479 	}
480 	const uchar* pApiAddr = (uchar*)"http:";
481 	if (runModConf-&gt;dockerApiAddr) {
482 		pApiAddr = runModConf-&gt;dockerApiAddr;
483 	}
484 	snprintf(url, sizeof(url), "%s/%s/containers/%s/logs?%s",
485 			pApiAddr, runModConf-&gt;apiVersionStr, containerId, container_log_options);
486 	DBGPRINTF("%s() - url: %s\n", __FUNCTION__, url);
487 	return dockerContLogsInstSetUrl(pThis, curlm, url);
488 }
489 static void
490 dockerContLogReqsDestructForHashtable(void *pData) {
491 	docker_cont_logs_inst_t *pThis = (docker_cont_logs_inst_t *) pData;
492 	dockerContLogsInstDestruct(pThis);
493 }
494 static rsRetVal
495 dockerContLogReqsNew(docker_cont_log_instances_t **ppThis) {
496 	DEFiRet;
497 	docker_cont_log_instances_t *pThis = calloc(1, sizeof(docker_cont_log_instances_t));
498 	CHKmalloc(pThis);
499 	CHKmalloc(pThis-&gt;ht_container_log_insts =
500 			create_hashtable(7, hash_from_string, key_equals_string,
501 				dockerContLogReqsDestructForHashtable));
502 	CHKiConcCtrl(pthread_mutex_init(&amp;pThis-&gt;mut, NULL));
503 	pThis-&gt;curlm = curl_multi_init();
504 	if (!pThis-&gt;curlm) {
505 		ABORT_FINALIZE(RS_RET_ERR);
506 	}
507 	*ppThis = pThis;
508 finalize_it:
509 	if (iRet != RS_RET_OK) {
510 		if (pThis) {
511 			dockerContLogReqsDestruct(pThis);
512 		}
513 	}
514 	RETiRet;
515 }
516 static rsRetVal
517 dockerContLogReqsDestruct(docker_cont_log_instances_t *pThis) {
518 	DEFiRet;
519 	if (pThis) {
520 		if (pThis-&gt;ht_container_log_insts) {
521 			pthread_mutex_lock(&amp;pThis-&gt;mut);
522 			hashtable_destroy(pThis-&gt;ht_container_log_insts, 1);
523 			pthread_mutex_unlock(&amp;pThis-&gt;mut);
524 		}
525 		if (pThis-&gt;last_container_id) {
526 			free(pThis-&gt;last_container_id);
527 		}
528 		curl_multi_cleanup(pThis-&gt;curlm);
529 		pthread_mutex_destroy(&amp;pThis-&gt;mut);
530 		free(pThis);
531 	}
532 	RETiRet;
533 }
534 static rsRetVal
535 dockerContLogReqsGet(docker_cont_log_instances_t *pThis,
536 		docker_cont_logs_inst_t** ppContLogsInst, const char *id) {
537 	DEFiRet;
538 	if (ppContLogsInst &amp;&amp; id) {
539 		docker_cont_logs_inst_t *pSearchObj = hashtable_search(pThis-&gt;ht_container_log_insts, (void*)id);
540 		if (!pSearchObj) {
541 			return RS_RET_NOT_FOUND;
542 		}
543 		*ppContLogsInst = pSearchObj;
544 	}
545 	RETiRet;
546 }
547 static rsRetVal
548 dockerContLogReqsPrint(docker_cont_log_instances_t *pThis) {
549 	DEFiRet;
550 	int count = 0;
551 	count = hashtable_count(pThis-&gt;ht_container_log_insts);
552 	if (count) {
553 		int ret = 0;
554 		struct hashtable_itr *itr = hashtable_iterator(pThis-&gt;ht_container_log_insts);
555 		DBGPRINTF("%s() - All container instances, count=%d...\n", __FUNCTION__, count);
556 		do {
557 			docker_cont_logs_inst_t *pObj = hashtable_iterator_value(itr);
558 			dockerContLogsInstPrint(pObj);
559 			ret = hashtable_iterator_advance(itr);
560 		} while (ret);
561 		free (itr);
562 		DBGPRINTF("End of container instances.\n");
563 	}
564 	RETiRet;
565 }
566 static rsRetVal
567 dockerContLogReqsAdd(docker_cont_log_instances_t *pThis,
568 		docker_cont_logs_inst_t *pContLogsReqInst)
569 {
570 	DEFiRet;
571 	if (!pContLogsReqInst) {
572 		return RS_RET_ERR;
573 	}
574 	uchar *keyName = (uchar*)strdup((char*)pContLogsReqInst-&gt;id);
575 	if (keyName) {
576 		docker_cont_logs_inst_t *pFind;
577 		if (RS_RET_NOT_FOUND == dockerContLogReqsGet(pThis, &amp;pFind, (void*)keyName)) {
578 			if (!hashtable_insert(pThis-&gt;ht_container_log_insts, keyName, pContLogsReqInst)) {
579 				ABORT_FINALIZE(RS_RET_ERR);
580 			}
581 			keyName = NULL;
582 		}
583 	}
584 finalize_it:
585 	free(keyName);
586 	RETiRet;
587 }
588 static rsRetVal
589 dockerContLogReqsRemove(docker_cont_log_instances_t *pThis, const char *id) {
590 	DEFiRet;
591 	if (pThis &amp;&amp; id) {
592 		CHKiConcCtrl(pthread_mutex_lock(&amp;pThis-&gt;mut));
593 		docker_cont_logs_inst_t *pRemoved =
594 			hashtable_remove(pThis-&gt;ht_container_log_insts, (void*)id);
595 		pthread_mutex_unlock(&amp;pThis-&gt;mut);
596 		if (pRemoved) {
597 			dockerContLogsInstDestruct(pRemoved);
598 		} else {
599 			iRet = RS_RET_NOT_FOUND;
600 		}
601 	}
602 finalize_it:
603 	RETiRet;
604 }
605 static rsRetVal
606 dockerContainerInfoNew(docker_container_info_t **ppThis) {
607 	DEFiRet;
608 	docker_container_info_t* pThis = calloc(1, sizeof(docker_container_info_t));
609 	CHKmalloc(pThis);
610 	*ppThis = pThis;
611 finalize_it:
612 	RETiRet;
613 }
614 static void
615 dockerContainerInfoDestruct(docker_container_info_t *pThis) {
616 	if (pThis) {
617 		if (pThis-&gt;image_id) { free(pThis-&gt;image_id); }
618 		if (pThis-&gt;name) { free(pThis-&gt;name); }
619 		if (pThis-&gt;json_str_labels) { free(pThis-&gt;json_str_labels); }
620 		free(pThis);
621 	}
622 }
623 BEGINbeginCnfLoad
624 CODESTARTbeginCnfLoad
625 	dbgprintf("imdocker: beginCnfLoad\n");
626 	loadModConf = pModConf;
627 	pModConf-&gt;pConf = pConf;
628 	loadModConf-&gt;iPollInterval     = DFLT_pollingInterval; 	loadModConf-&gt;retrieveNewLogsFromStart  = DFLT_retrieveNewLogsFromStart;
629 	loadModConf-&gt;containersLimit   = DFLT_containersLimit;
630 	loadModConf-&gt;trimLineOverBytes = DFLT_trimLineOverBytes;
631 	loadModConf-&gt;bEscapeLf         = DFLT_bEscapeLF;
632 	loadModConf-&gt;apiVersionStr          = NULL;
633 	loadModConf-&gt;dockerApiUnixSockAddr  = NULL;
634 	loadModConf-&gt;dockerApiAddr          = NULL;
635 	loadModConf-&gt;listContainersOptions  = NULL;
636 	loadModConf-&gt;getContainerLogOptions = NULL;
637 	loadModConf-&gt;getContainerLogOptionsWithoutTail = NULL;
638 	loadModConf-&gt;iDfltFacility = DFLT_FACILITY;
639 	loadModConf-&gt;iDfltSeverity = DFLT_SEVERITY;
640 ENDbeginCnfLoad
641 BEGINsetModCnf
642 	struct cnfparamvals *pvals = NULL;
643 	int i;
644 CODESTARTsetModCnf
645 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
646 	if(pvals == NULL) {
647 		LogError(0, RS_RET_MISSING_CNFPARAMS, "error processing module "
648 				"config parameters [module(...)]");
649 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
650 	}
651 	if (Debug) {
652 		dbgprintf("module (global) param blk for imdocker:\n");
653 		cnfparamsPrint(&amp;modpblk, pvals);
654 	}
655 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
656 		dbgprintf("%s() - iteration %d\n", __FUNCTION__,i);
657 		dbgprintf("%s() - modpblk descr: %s\n", __FUNCTION__, modpblk.descr[i].name);
658 		if(!pvals[i].bUsed)
659 			continue;
660 		if(!strcmp(modpblk.descr[i].name, "pollinginterval")) {
661 			loadModConf-&gt;iPollInterval = (int) pvals[i].val.d.n;
662 		} else if(!strcmp(modpblk.descr[i].name, "containterlimit")) {
663 <a name="4"></a>			loadModConf-&gt;containersLimit = (int) pvals[i].val.d.n;
664 		} else if(!strcmp(modpblk.descr[i].name, "trimlineoverbytes")) {
665 			loadModConf-&gt;trimLineOverBytes = (int) pvals[i].val.d.n;
666 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(modpblk.descr[i].name, "listcontainersoptions")) {
667 			loadModConf-&gt;listContainersOptions = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
668 		} else if(!strcmp(modpblk.descr[i].name, "getcontainerlogoptions")) {
669 			loadModConf-&gt;getContainerLogOptions = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
670 			size_t offset = 0;</b></font>
671 			char buf[256];
672 			size_t buf_size = sizeof(buf);
673 			strncpy(buf, (char*)loadModConf-&gt;getContainerLogOptions, buf_size-1);
674 			size_t option_str_len = strlen((char*)loadModConf-&gt;getContainerLogOptions);
675 			uchar *option_str = calloc(1, option_str_len);
676 			CHKmalloc(option_str);
677 			const char *search_str = "tail=";
678 			size_t search_str_len = strlen(search_str);
679 			char *token = strtok(buf, "&amp;");
680 			while (token != NULL) {
681 				if (strncmp(token, search_str, search_str_len) == 0) {
682 					token = strtok(NULL, "&amp;");
683 					continue;
684 				}
685 				int len = strlen(token);
686 				if (offset + len + 1 &gt;= option_str_len) {
687 					break;
688 				}
689 				int bytes = snprintf((char*)option_str + offset,
690 						(option_str_len - offset), "%s&amp;", token);
691 				if (bytes &lt;= 0) {
692 					break;
693 				}
694 				offset += bytes;
695 <a name="1"></a>				token = strtok(NULL, "&amp;");
696 			}
697 			loadModConf-&gt;getContainerLogOptionsWithoutTail = option_str;
698 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(modpblk.descr[i].name, "dockerapiunixsockaddr")) {
699 			loadModConf-&gt;dockerApiUnixSockAddr = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
700 		} else if(!strcmp(modpblk.descr[i].name, "dockerapiaddr")) {
701 			loadModConf-&gt;dockerApiAddr = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
702 		} else if(!strcmp(modpblk.descr[i].name, "apiversionstr")) {
703 			loadModConf-&gt;apiVersionStr = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
704 		} else if(!strcmp(modpblk.descr[i].name, "retrievenewlogsfromstart")) {
705 			loadModConf-&gt;retrieveNewLogsFromStart = (sbool) pvals[i].val.d.n;</b></font>
706 		} else if (!strcmp(modpblk.descr[i].name, "defaultseverity")) {
707 			loadModConf-&gt;iDfltSeverity = (int) pvals[i].val.d.n;
708 		} else if (!strcmp(modpblk.descr[i].name, "defaultfacility")) {
709 			loadModConf-&gt;iDfltFacility = (int) pvals[i].val.d.n;
710 		} else if(!strcmp(modpblk.descr[i].name, "escapelf")) {
711 			loadModConf-&gt;bEscapeLf = (sbool) pvals[i].val.d.n;
712 		} else {
713 			LogError(0, RS_RET_INVALID_PARAMS,
714 					"imdocker: program error, non-handled "
715 					"param '%s' in setModCnf\n", modpblk.descr[i].name);
716 		}
717 	}
718 	bLegacyCnfModGlobalsPermitted = 0;
719 finalize_it:
720 	if(pvals != NULL)
721 		cnfparamvalsDestruct(pvals, &amp;modpblk);
722 ENDsetModCnf
723 BEGINendCnfLoad
724 CODESTARTendCnfLoad
725 ENDendCnfLoad
726 BEGINcheckCnf
727 CODESTARTcheckCnf
728 ENDcheckCnf
729 BEGINactivateCnf
730 CODESTARTactivateCnf
731 	if (!loadModConf-&gt;dockerApiUnixSockAddr) {
732 		loadModConf-&gt;dockerApiUnixSockAddr = (uchar*) strdup(DFLT_dockerAPIUnixSockAddr);
733 	}
734 	if (!loadModConf-&gt;apiVersionStr) {
735 		loadModConf-&gt;apiVersionStr = (uchar*) strdup(DFLT_apiVersionStr);
736 	}
737 	if (!loadModConf-&gt;listContainersOptions) {
738 		loadModConf-&gt;listContainersOptions = (uchar*) strdup(DFLT_listContainersOptions);
739 	}
740 	if (!loadModConf-&gt;getContainerLogOptions) {
741 		loadModConf-&gt;getContainerLogOptions = (uchar*) strdup(DFLT_getContainerLogOptions);
742 	}
743 if (!loadModConf-&gt;getContainerLogOptionsWithoutTail) {
744 		loadModConf-&gt;getContainerLogOptionsWithoutTail =
745 			(uchar*) strdup(DFLT_getContainerLogOptionsWithoutTail);
746 	}
747 	runModConf = loadModConf;
748 	CHKiRet(statsobj.Construct(&amp;modStats));
749 	CHKiRet(statsobj.SetName(modStats, UCHAR_CONSTANT("imdocker")));
750 	CHKiRet(statsobj.SetOrigin(modStats, UCHAR_CONSTANT("imdocker")));
751 	STATSCOUNTER_INIT(ctrSubmit, mutCtrSubmit);
752 	CHKiRet(statsobj.AddCounter(modStats, UCHAR_CONSTANT("submitted"),
753 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrSubmit));
754 	STATSCOUNTER_INIT(ctrLostRatelimit, mutCtrLostRatelimit);
755 	CHKiRet(statsobj.AddCounter(modStats, UCHAR_CONSTANT("ratelimit.discarded"),
756 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrLostRatelimit));
757 	STATSCOUNTER_INIT(ctrCurlError, mutCtrCurlError);
758 	CHKiRet(statsobj.AddCounter(modStats, UCHAR_CONSTANT("curl.errors"),
759 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrCurlError));
760 	CHKiRet(statsobj.ConstructFinalize(modStats));
761 finalize_it:
762 ENDactivateCnf
763 <a name="3"></a>
764 BEGINfreeCnf
765 CODESTARTfreeCnf
766 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if (loadModConf-&gt;dockerApiUnixSockAddr) {
767 		free(loadModConf-&gt;dockerApiUnixSockAddr);
768 	}
769 	if (loadModConf-&gt;dockerApiAddr) {
770 		free(loadModConf-&gt;dockerApiAddr);
771 	}
772 	if (loadModConf-&gt;apiVersionStr) {
773 		free(loadModConf-&gt;apiVersionStr);
774 	}
775 	if (loadModConf-&gt;getContainerLogOptions) {
776 		free(loadModConf-&gt;getContainerLogOptions);
777 	}
778 	if (loadModConf-&gt;getContainerLogOptionsWithoutTail) {</b></font>
779 		free(loadModConf-&gt;getContainerLogOptionsWithoutTail);
780 	}
781 	if (loadModConf-&gt;listContainersOptions) {
782 		free(loadModConf-&gt;listContainersOptions);
783 	}
784 	statsobj.Destruct(&amp;modStats);
785 ENDfreeCnf
786 static rsRetVal
787 addDockerMetaData(const uchar* container_id, docker_container_info_t* pinfo, smsg_t *pMsg) {
788 	const uchar *names[4] = {
789 		(const uchar*) DOCKER_CONTAINER_ID_PARSE_NAME,
790 		(const uchar*) DOCKER_CONTAINER_NAMES_PARSE_NAME,
791 		(const uchar*) DOCKER_CONTAINER_IMAGEID_PARSE_NAME,
792 		(const uchar*) DOCKER_CONTAINER_LABELS_PARSE_NAME
793 	};
794 	const uchar * empty_str= (const uchar*) "";
795 	const uchar *id = container_id ? container_id : empty_str;
796 	const uchar *name = pinfo-&gt;name ? pinfo-&gt;name : empty_str;
797 	const uchar *image_id = pinfo-&gt;image_id ? pinfo-&gt;image_id : empty_str;
798 	const uchar *json_str_labels = pinfo-&gt;json_str_labels ? pinfo-&gt;json_str_labels : empty_str;
799 	const uchar *values[4] = {
800 		id,
801 		name,
802 		image_id,
803 		json_str_labels
804 	};
805 	return msgAddMultiMetadata(pMsg, names, values, 4);
806 }
807 static rsRetVal
808 enqMsg(docker_cont_logs_inst_t *pInst, uchar *msg, size_t len, const uchar *pszTag,
809 		int facility, int severity, struct timeval *tp)
810 {
811 	struct syslogTime st;
812 	smsg_t *pMsg;
813 	DEFiRet;
814 	if (!msg) {
815 		return RS_RET_ERR;
816 	}
817 	if (tp == NULL) {
818 		CHKiRet(msgConstruct(&amp;pMsg));
819 	} else {
820 		datetime.timeval2syslogTime(tp, &amp;st, TIME_IN_LOCALTIME);
821 		CHKiRet(msgConstructWithTime(&amp;pMsg, &amp;st, tp-&gt;tv_sec));
822 	}
823 	MsgSetFlowControlType(pMsg, eFLOWCTL_LIGHT_DELAY);
824 	MsgSetInputName(pMsg, pInputName);
825 	MsgSetRawMsg(pMsg, (char*)msg, len);
826 	if (loadModConf-&gt;bEscapeLf) {
827 		parser.SanitizeMsg(pMsg);
828 	} else {
829 		size_t lenMsg = pMsg-&gt;iLenRawMsg;
830 		uchar *pszMsg = pMsg-&gt;pszRawMsg;
831 		if(pszMsg[lenMsg-1] == '\0') {
832 			DBGPRINTF("dropped NULL at very end of message\n");
833 			lenMsg--;
834 		}
835 		if(glbl.GetParserDropTrailingLFOnReception(loadModConf-&gt;pConf)
836 				&amp;&amp; lenMsg &gt; 0 &amp;&amp; pszMsg[lenMsg-1] == '\n') {
837 			DBGPRINTF("dropped LF at very end of message (DropTrailingLF is set)\n");
838 			lenMsg--;
839 			pszMsg[lenMsg] = '\0';
840 		}
841 		pMsg-&gt;iLenRawMsg = lenMsg;
842 	}
843 	MsgSetMSGoffs(pMsg, 0);  	MsgSetRcvFrom(pMsg, glbl.GetLocalHostNameProp());
844 	if (pLocalHostIP) { MsgSetRcvFromIP(pMsg, pLocalHostIP); }
845 	MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
846 	MsgSetTAG(pMsg, pszTag, ustrlen(pszTag));
847 	pMsg-&gt;iFacility = facility;
848 	pMsg-&gt;iSeverity = severity;
849 	addDockerMetaData((const uchar*)pInst-&gt;short_id, pInst-&gt;container_info, pMsg);
850 	const char *name = (const char*)pInst-&gt;container_info-&gt;name;
851 	DBGPRINTF("imdocker: %s - %s:%s\n", __FUNCTION__, name, msg);
852 	CHKiRet(ratelimitAddMsg(ratelimiter, NULL, pMsg));
853 	STATSCOUNTER_INC(ctrSubmit, mutCtrSubmit);
854 finalize_it:
855 	if (iRet == RS_RET_DISCARDMSG)
856 		STATSCOUNTER_INC(ctrLostRatelimit, mutCtrLostRatelimit)
857 	RETiRet;
858 }
859 static int8_t
860 is_valid_stream_type(int8_t stream_type) {
861 	return (dst_invalid &lt; stream_type &amp;&amp; stream_type &lt; dst_stream_type_count);
862 }
863 static sbool
864 get_stream_info(const uchar* data, size_t size, int8_t *stream_type, size_t *payload_size) {
865 	if (size &lt; 8 || !data || !stream_type || !payload_size) {
866 		return 0;
867 	}
868 	const uchar* pdata = data;
869 	*stream_type = pdata[0];
870 	pdata += 4;
871 	uint32_t len = 0;
872 	memcpy(&amp;len, pdata, sizeof(len));
873 	*payload_size = ntohl(len);
874 	return 1;
875 }
876 #ifdef ENABLE_DEBUG_BYTE_BUFFER
877 static void debug_byte_buffer(const uchar* data, size_t size) {
878 	if (Debug) {
879 		DBGPRINTF("%s() - ENTER, size=%lu\n", __FUNCTION__, size);
880 		for (size_t i = 0; i &lt; size; i++) {
881 			DBGPRINTF("0x%02x,", data[i]);
882 		}
883 		DBGPRINTF("\n");
884 	}
885 }
886 #endif
887 static size_t
888 imdocker_container_list_curlCB(void *data, size_t size, size_t nmemb, void *buffer) {
889 	DEFiRet;
890 	size_t realsize = size*nmemb;
891 	uchar		*pbuf=NULL;
892 	imdocker_buf_t *mem = (imdocker_buf_t*)buffer;
893 	if ((pbuf = realloc(mem-&gt;data, mem-&gt;len + realsize + 1)) == NULL) {
894 		LogError(errno, RS_RET_ERR, "%s() - realloc failed!\n", __FUNCTION__);
895 		ABORT_FINALIZE(RS_RET_ERR);
896 	}
897 	mem-&gt;data = pbuf;
898 	mem-&gt;data_size = mem-&gt;len + realsize + 1;
899 	memcpy(&amp;(mem-&gt;data[mem-&gt;len]), data, realsize);
900 	mem-&gt;len += realsize;
901 	mem-&gt;data[mem-&gt;len] = 0;
902 #ifdef ENABLE_DEBUG_BYTE_BUFFER
903 	debug_byte_buffer((const uchar*) data, realsize);
904 #endif
905 finalize_it:
906 	if (iRet != RS_RET_OK) {
907 		return 0;
908 	}
909 	return realsize;
910 }
911 static rsRetVal
912 SubmitMultiLineMsg(docker_cont_logs_inst_t *pInst, docker_cont_logs_buf_t *pBufData,
913 		const uchar* pszTag, size_t len) {
914 	DEFiRet;
915 	imdocker_buf_t *mem = (imdocker_buf_t*)pBufData-&gt;buf;
916 	DBGPRINTF("%s() {type=%d, len=%u} %s\n",
917 			__FUNCTION__, pBufData-&gt;stream_type, (unsigned int)mem-&gt;len, mem-&gt;data);
918 	uchar* message = (uchar*)mem-&gt;data;
919 	int facility = loadModConf-&gt;iDfltFacility;
920 	int severity = pBufData-&gt;stream_type == dst_stderr ? LOG_ERR : loadModConf-&gt;iDfltSeverity;
921 	enqMsg(pInst, message, len, (const uchar*)pszTag, facility, severity, NULL);
922 	size_t size = mem-&gt;len - pInst-&gt;prevSegEnd;
923 	memmove(mem-&gt;data, mem-&gt;data+pInst-&gt;prevSegEnd, size);
924 	mem-&gt;data[len] = '\0';
925 	mem-&gt;len = size;
926 	pBufData-&gt;bytes_remaining = 0;
927 	RETiRet;
928 }
929 static rsRetVal
930 SubmitMsgWithStartRegex(docker_cont_logs_inst_t *pInst, docker_cont_logs_buf_t *pBufData, const uchar* pszTag) {
931 	imdocker_buf_t *mem = (imdocker_buf_t*)pBufData-&gt;buf;
932 	assert(mem-&gt;data[mem-&gt;len] == 0 || mem-&gt;data[mem-&gt;len] == '\0');
933 	const char* thisLine = (const char*) mem-&gt;data;
934 	if (pInst-&gt;prevSegEnd) {
935 		thisLine = (const char*) mem-&gt;data+pInst-&gt;prevSegEnd;
936 	}
937 	DBGPRINTF("prevSeg: %d, thisLine: '%s'\n", pInst-&gt;prevSegEnd, thisLine);
938 	DBGPRINTF("line(s) so far: '%s'\n", mem-&gt;data);
939 	regex_t *start_preg = (pInst-&gt;start_regex == NULL) ? NULL : &amp;pInst-&gt;start_preg;
940 	const int isStartMatch = start_preg ?
941 		!regexec(start_preg, (char*)thisLine, 0, NULL, 0) : 0;
942 	if (isStartMatch &amp;&amp; pInst-&gt;prevSegEnd != 0) {
943 		SubmitMultiLineMsg(pInst, pBufData, pszTag, pInst-&gt;prevSegEnd);
944 		pInst-&gt;prevSegEnd = 0;
945 		FINALIZE;
946 	} else {
947 		pInst-&gt;prevSegEnd = mem-&gt;len;
948 	}
949 finalize_it:
950 	return RS_RET_OK;
951 }
952 static rsRetVal
953 SubmitMsg2(docker_cont_logs_inst_t *pInst, docker_cont_logs_buf_t *pBufData, const uchar* pszTag) {
954 	imdocker_buf_t *mem = (imdocker_buf_t*)pBufData-&gt;buf;
955 	DBGPRINTF("%s() - {type=%d, len=%u} %s\n",
956 			__FUNCTION__, pBufData-&gt;stream_type, (unsigned int)mem-&gt;len, mem-&gt;data);
957 	if (pInst-&gt;start_regex) {
958 		SubmitMsgWithStartRegex(pInst, pBufData, pszTag);
959 	} else {
960 		SubmitMsg(pInst, pBufData, pszTag);
961 	}
962 	return RS_RET_OK;
963 }
964 static rsRetVal
965 SubmitMsg(docker_cont_logs_inst_t *pInst, docker_cont_logs_buf_t *pBufData, const uchar* pszTag) {
966 	imdocker_buf_t *mem = (imdocker_buf_t*)pBufData-&gt;buf;
967 	DBGPRINTF("%s() - {type=%d, len=%u} %s\n",
968 			__FUNCTION__, pBufData-&gt;stream_type, (unsigned int)mem-&gt;len, mem-&gt;data);
969 	uchar* message = mem-&gt;data;
970 	int facility = loadModConf-&gt;iDfltFacility;
971 	int severity = pBufData-&gt;stream_type == dst_stderr ? LOG_ERR : loadModConf-&gt;iDfltSeverity;
972 	enqMsg(pInst, message, mem-&gt;len, (const uchar*)pszTag, facility, severity, NULL);
973 	mem-&gt;len = 0;
974 	memset(mem-&gt;data, 0, mem-&gt;data_size);
975 	pBufData-&gt;bytes_remaining = 0;
976 	return RS_RET_OK;
977 }
978 static size_t
979 imdocker_container_logs_curlCB(void *data, size_t size, size_t nmemb, void *buffer) {
980 	DEFiRet;
981 	const uint8_t frame_size = 8;
982 	const char imdocker_eol_char = '\n';
983 	int8_t stream_type = dst_invalid;
984 	docker_cont_logs_inst_t* pInst = (docker_cont_logs_inst_t*) buffer;
985 	docker_cont_logs_req_t* req = pInst-&gt;logsReq;
986 	size_t realsize = size*nmemb;
987 	const uchar* pdata = data;
988 	size_t write_size = 0;
989 #ifdef ENABLE_DEBUG_BYTE_BUFFER
990 	debug_byte_buffer((const uchar*) data, realsize);
991 #endif
992 	if (req-&gt;data_bufs[dst_stdout]-&gt;bytes_remaining || req-&gt;data_bufs[dst_stderr]-&gt;bytes_remaining) {
993 		if (req-&gt;data_bufs[dst_stdout]-&gt;bytes_remaining) {
994 			if (req-&gt;data_bufs[dst_stderr]-&gt;bytes_remaining != 0) {
995 				ABORT_FINALIZE(RS_RET_ERR);
996 			}
997 		} else if (req-&gt;data_bufs[dst_stderr]-&gt;bytes_remaining) {
998 			if (req-&gt;data_bufs[dst_stdout]-&gt;bytes_remaining != 0) {
999 				ABORT_FINALIZE(RS_RET_ERR);
1000 			}
1001 		}
1002 		stream_type = req-&gt;data_bufs[dst_stdout]-&gt;bytes_remaining ? dst_stdout : dst_stderr;
1003 		docker_cont_logs_buf_t *pDataBuf = req-&gt;data_bufs[stream_type];
1004 		DBGPRINTF("Chunk continuation, remaining bytes: type: %d, "
1005 				"bytes remaining: %u, realsize: %u, data pos: %u\n",
1006 				stream_type, (unsigned int)pDataBuf-&gt;bytes_remaining,
1007 				(unsigned int)realsize, (unsigned int)pDataBuf-&gt;buf-&gt;len);
1008 		write_size = MIN(pDataBuf-&gt;bytes_remaining, realsize);
1009 		CHKiRet(dockerContLogsBufWrite(pDataBuf, pdata, write_size));
1010 		if (pDataBuf-&gt;bytes_remaining == 0) {
1011 			imdocker_buf_t *mem = pDataBuf-&gt;buf;
1012 			if (mem-&gt;data[mem-&gt;len-1] == imdocker_eol_char) {
1013 				const char* szContainerId = NULL;
1014 				CURLcode ccode;
1015 				if(CURLE_OK != (ccode = curl_easy_getinfo(req-&gt;curl,
1016 								CURLINFO_PRIVATE,
1017 								&amp;szContainerId))) {
1018 					LogError(0, RS_RET_ERR,
1019 							"imdocker: could not get private data req[%p] - %d:%s\n",
1020 							req-&gt;curl, ccode, curl_easy_strerror(ccode));
1021 					ABORT_FINALIZE(RS_RET_ERR);
1022 				}
1023 				req-&gt;submitMsg(pInst, pDataBuf, (const uchar*)DOCKER_TAG_NAME);
1024 			}
1025 		}
1026 		pdata += write_size;
1027 	}
1028 	if ((size_t)(pdata - (const uchar*)data) &gt;= realsize) {
1029 		return (pdata - (const uchar*)data);
1030 	}
1031 	size_t payload_size = 0;
1032 	const uchar* pread = pdata + frame_size;
1033 	docker_cont_logs_buf_t* pDataBuf = NULL;
1034 	if (get_stream_info(pdata, realsize, &amp;stream_type, &amp;payload_size)
1035 				&amp;&amp; is_valid_stream_type(stream_type)) {
1036 		pDataBuf = req-&gt;data_bufs[stream_type];
1037 		pDataBuf-&gt;stream_type = stream_type;
1038 		pDataBuf-&gt;bytes_remaining = payload_size;
1039 		write_size = MIN(payload_size, realsize - frame_size);
1040 	} else {
1041 		stream_type = req-&gt;data_bufs[dst_stderr]-&gt;bytes_remaining ? dst_stderr : dst_stdout;
1042 		pDataBuf = req-&gt;data_bufs[stream_type];
1043 		pDataBuf-&gt;stream_type = stream_type;
1044 		pDataBuf-&gt;bytes_remaining = 0;
1045 		write_size = realsize;
1046 		pread = pdata;
1047 	}
1048 	CHKiRet(dockerContLogsBufWrite(pDataBuf, pread, write_size));
1049 	if (pDataBuf-&gt;bytes_remaining == 0) {
1050 		DBGPRINTF("%s() - write size is same as payload_size\n", __FUNCTION__);
1051 		req-&gt;submitMsg(pInst, pDataBuf, (const uchar*)DOCKER_TAG_NAME);
1052 	}
1053 finalize_it:
1054 	if (iRet != RS_RET_OK) {
1055 		return 0;
1056 	}
1057 	return realsize;
1058 }
1059 CURLcode docker_get(imdocker_req_t *req, const char* url) {
1060 	CURLcode ccode;
1061 	if (!runModConf-&gt;dockerApiAddr) {
1062 		if ((ccode = curl_easy_setopt(req-&gt;curl, CURLOPT_UNIX_SOCKET_PATH, runModConf-&gt;dockerApiUnixSockAddr))
1063 				!= CURLE_OK) {
1064 			STATSCOUNTER_INC(ctrCurlError, mutCtrCurlError);
1065 			LogError(0, RS_RET_ERR, "imdocker: curl_easy_setopt(CURLOPT_UNIX_SOCKET_PATH) error - %d:%s\n",
1066 					ccode, curl_easy_strerror(ccode));
1067 			return ccode;
1068 		}
1069 	}
1070 	if ((ccode = curl_easy_setopt(req-&gt;curl, CURLOPT_WRITEFUNCTION, imdocker_container_list_curlCB)) != CURLE_OK) {
1071 		STATSCOUNTER_INC(ctrCurlError, mutCtrCurlError);
1072 		LogError(0, RS_RET_ERR, "imdocker: curl_easy_setopt(CURLOPT_WRITEFUNCTION) error - %d:%s\n",
1073 				ccode, curl_easy_strerror(ccode));
1074 		return ccode;
1075 	}
1076 	if ((ccode = curl_easy_setopt(req-&gt;curl, CURLOPT_WRITEDATA, req-&gt;buf)) != CURLE_OK) {
1077 		STATSCOUNTER_INC(ctrCurlError, mutCtrCurlError);
1078 		LogError(0, RS_RET_ERR, "imdocker: curl_easy_setopt(CURLOPT_WRITEDATA) error - %d:%s\n",
1079 				ccode, curl_easy_strerror(ccode));
1080 		return ccode;
1081 	}
1082 	if ((ccode = curl_easy_setopt(req-&gt;curl, CURLOPT_URL, url)) != CURLE_OK) {
1083 		STATSCOUNTER_INC(ctrCurlError, mutCtrCurlError);
1084 		LogError(0, RS_RET_ERR, "imdocker: curl_easy_setopt(CURLOPT_URL) error - %d:%s\n",
1085 				ccode, curl_easy_strerror(ccode));
1086 		return ccode;
1087 	}
1088 	CURLcode response = curl_easy_perform(req-&gt;curl);
1089 	return response;
1090 }
1091 static char*
1092 dupDockerContainerName(const char* pname) {
1093 	int len = strlen(pname);
1094 	if (len &gt;= 2 &amp;&amp; *pname == '/') {
1095 		return strdup(pname+1);
1096 	} else {
1097 		return strdup(pname);
1098 	}
1099 }
1100 static rsRetVal
1101 process_json(sbool isInit, const char* json, docker_cont_log_instances_t *pInstances) {
1102 	DEFiRet;
1103 	struct fjson_object *json_obj = NULL;
1104 	int mut_locked = 0;
1105 	DBGPRINTF("%s() - parsing json=%s\n", __FUNCTION__, json);
1106 	if (!pInstances) {
1107 		ABORT_FINALIZE(RS_RET_OK);
1108 	}
1109 	json_obj = fjson_tokener_parse(json);
1110 	if (!json_obj || !fjson_object_is_type(json_obj, fjson_type_array)) {
1111 		ABORT_FINALIZE(RS_RET_OK);
1112 	}
1113 	int length = fjson_object_array_length(json_obj);
1114 	CHKiConcCtrl(pthread_mutex_lock(&amp;pInstances-&gt;mut));
1115 	mut_locked = 1;
1116 	for (int i = 0; i &lt; length; i++) {
1117 		fjson_object* p_json_elm = json_object_array_get_idx(json_obj, i);
1118 		DBGPRINTF("element: %d...\n", i);
1119 		if (p_json_elm) {
1120 			const char *containerId=NULL;
1121 			docker_container_info_t containerInfo = {
1122 				.name=NULL,
1123 				.image_id=NULL,
1124 				.created=0,
1125 				.json_str_labels=NULL
1126 			};
1127 			struct fjson_object_iterator it = fjson_object_iter_begin(p_json_elm);
1128 			struct fjson_object_iterator itEnd = fjson_object_iter_end(p_json_elm);
1129 			while (!fjson_object_iter_equal(&amp;it, &amp;itEnd)) {
1130 				if (Debug) {
1131 					DBGPRINTF("\t%s: '%s'\n",
1132 							fjson_object_iter_peek_name(&amp;it),
1133 							fjson_object_get_string(fjson_object_iter_peek_value(&amp;it)));
1134 				}
1135 				if (strcmp(fjson_object_iter_peek_name(&amp;it), DOCKER_CONTAINER_ID_PARSE_NAME) == 0) {
1136 					containerId =
1137 						fjson_object_get_string(fjson_object_iter_peek_value(&amp;it));
1138 				} else if (strcmp(fjson_object_iter_peek_name(&amp;it),
1139 							DOCKER_CONTAINER_NAMES_PARSE_NAME) == 0) {
1140 					int names_array_length =
1141 						fjson_object_array_length(fjson_object_iter_peek_value(&amp;it));
1142 					if (names_array_length) {
1143 <a name="2"></a>						fjson_object* names_elm =
1144 							json_object_array_get_idx(fjson_object_iter_peek_value(&amp;it), 0);
1145 						containerInfo.name = (uchar*)fjson_object_get_string(names_elm);
1146 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>					}
1147 				} else if (strcmp(fjson_object_iter_peek_name(&amp;it),
1148 							DOCKER_CONTAINER_IMAGEID_PARSE_NAME) == 0) {
1149 					containerInfo.image_id =
1150 						(uchar*)fjson_object_get_string(
1151 									fjson_object_iter_peek_value(&amp;it)
1152 									);
1153 				} else if (strcmp(fjson_object_iter_peek_name(&amp;it),
1154 							DOCKER_CONTAINER_CREATED_PARSE_NAME) == 0) {
1155 					containerInfo.created =
1156 						fjson_object_get_int64(
1157 									fjson_object_iter_peek_value(&amp;it)
1158 									);
1159 				} else if (strcmp(fjson_object_iter_peek_name(&amp;it),
1160 							DOCKER_CONTAINER_LABELS_PARSE_NAME) == 0) {
1161 					containerInfo.json_str_labels =
1162 						(uchar*) fjson_object_get_string(
1163 									fjson_object_iter_peek_value(&amp;it)
1164 									);
1165 					DBGPRINTF("labels: %s\n", containerInfo.json_str_labels);
1166 				}</b></font>
1167 				fjson_object_iter_next(&amp;it);
1168 			}
1169 			if (containerId) {
1170 				docker_cont_logs_inst_t *pInst = NULL;
1171 				iRet = dockerContLogReqsGet(pInstances, &amp;pInst, containerId);
1172 				if (iRet == RS_RET_NOT_FOUND) {
1173 #ifdef USE_MULTI_LINE
1174 					if (dockerContLogsInstNew(&amp;pInst, containerId, &amp;containerInfo, SubmitMsg2)
1175 #else
1176 					if (dockerContLogsInstNew(&amp;pInst, containerId, &amp;containerInfo, SubmitMsg)
1177 #endif
1178 							== RS_RET_OK) {
1179 						if (pInstances-&gt;last_container_created &lt; containerInfo.created) {
1180 							pInstances-&gt;last_container_created = containerInfo.created;
1181 							if (pInstances-&gt;last_container_id) {
1182 								free(pInstances-&gt;last_container_id);
1183 							}
1184 							pInstances-&gt;last_container_id = (uchar*)strdup(containerId);
1185 							DBGPRINTF("last_container_id updated: ('%s', %u)\n",
1186 									pInstances-&gt;last_container_id,
1187 									(unsigned)pInstances-&gt;last_container_created);
1188 						}
1189 						CHKiRet(dockerContLogsInstSetUrlById(isInit, pInst,
1190 									pInstances-&gt;curlm, containerId));
1191 						CHKiRet(dockerContLogReqsAdd(pInstances, pInst));
1192 					}
1193 				}
1194 			}
1195 		}
1196 	}
1197 finalize_it:
1198 	if (mut_locked) {
1199 		pthread_mutex_unlock(&amp;pInstances-&gt;mut);
1200 	}
1201 	if (json_obj) {
1202 		json_object_put(json_obj);
1203 	}
1204 	RETiRet;
1205 }
1206 static rsRetVal
1207 getContainerIds(sbool isInit, docker_cont_log_instances_t *pInstances, const char* url) {
1208 	DEFiRet;
1209 	imdocker_req_t *req=NULL;
1210 	CHKiRet(imdockerReqNew(&amp;req));
1211 	CURLcode response = docker_get(req, url);
1212 	if (response != CURLE_OK) {
1213 		DBGPRINTF("%s() - curl response: %d\n", __FUNCTION__, response);
1214 		ABORT_FINALIZE(RS_RET_ERR);
1215 	}
1216 	CHKiRet(process_json(isInit, (const char*)req-&gt;buf-&gt;data, pInstances));
1217 finalize_it:
1218 	if (req) {
1219 		imdockerReqDestruct(req);
1220 	}
1221 	RETiRet;
1222 }
1223 static rsRetVal
1224 getContainerIdsAndAppend(sbool isInit, docker_cont_log_instances_t *pInstances) {
1225 	DEFiRet;
1226 	char url[256];
1227 	const uchar* pApiAddr = (uchar*)"http:";
1228 	if (runModConf-&gt;dockerApiAddr) {
1229 		pApiAddr = runModConf-&gt;dockerApiAddr;
1230 	}
1231 	if (pInstances-&gt;last_container_id) {
1232 		snprintf(url, sizeof(url), "%s/%s/containers/json?%s&amp;filters={\"since\":[\"%s\"]}",
1233 				pApiAddr, runModConf-&gt;apiVersionStr, runModConf-&gt;listContainersOptions,
1234 				pInstances-&gt;last_container_id);
1235 	} else {
1236 		snprintf(url, sizeof(url), "%s/%s/containers/json?%s",
1237 			pApiAddr, runModConf-&gt;apiVersionStr, runModConf-&gt;listContainersOptions);
1238 	}
1239 	DBGPRINTF("listcontainers url: %s\n", url);
1240 	CHKiRet(getContainerIds(isInit, pInstances, (const char*)url));
1241 	if (Debug) { dockerContLogReqsPrint(pInstances); }
1242 finalize_it:
1243 	RETiRet;
1244 }
1245 static void
1246 cleanupCompletedContainerRequests(docker_cont_log_instances_t *pInstances) {
1247 	int rc=0, msgs_left=0;
1248 	CURLMsg *msg=NULL;
1249 	CURL *pCurl;
1250 	while ((msg = curl_multi_info_read(pInstances-&gt;curlm, &amp;msgs_left))) {
1251 		if (msg-&gt;msg == CURLMSG_DONE) {
1252 			pCurl = msg-&gt;easy_handle;
1253 			rc = msg-&gt;data.result;
1254 			if (rc != CURLE_OK) {
1255 				STATSCOUNTER_INC(ctrCurlError, mutCtrCurlError);
1256 				LogError(0, RS_RET_ERR, "imdocker: %s() - curl error code: %d:%s\n",
1257 						__FUNCTION__, rc, curl_multi_strerror(rc));
1258 				continue;
1259 			}
1260 			CURLcode ccode;
1261 			if (Debug) {
1262 				long http_status=0;
1263 				curl_easy_getinfo(pCurl, CURLINFO_RESPONSE_CODE, &amp;http_status);
1264 				DBGPRINTF("http status: %lu\n", http_status);
1265 			}
1266 			curl_multi_remove_handle(pInstances-&gt;curlm, pCurl);
1267 			const char* szContainerId = NULL;
1268 			if ((ccode = curl_easy_getinfo(pCurl, CURLINFO_PRIVATE, &amp;szContainerId)) == CURLE_OK) {
1269 				DBGPRINTF("container disconnected: %s\n", szContainerId);
1270 				dockerContLogReqsRemove(pInstances, szContainerId);
1271 				DBGPRINTF("container removed...\n");
1272 			} else {
1273 				LogError(0, RS_RET_ERR, "imdocker: private data not found "
1274 						"curl_easy_setopt(CURLINFO_PRIVATE) error - %d:%s\n",
1275 						ccode, curl_easy_strerror(ccode));
1276 				STATSCOUNTER_INC(ctrCurlError, mutCtrCurlError);
1277 			}
1278 		}
1279 	}
1280 }
1281 static rsRetVal
1282 processAndPollContainerLogs(docker_cont_log_instances_t *pInstances) {
1283 	DEFiRet;
1284 	int count=0;
1285 	count = hashtable_count(pInstances-&gt;ht_container_log_insts);
1286 	DBGPRINTF("%s() - container instances: %d\n", __FUNCTION__, count);
1287 	int still_running=0;
1288 	curl_multi_perform(pInstances-&gt;curlm, &amp;still_running);
1289 	do {
1290 		int numfds = 0;
1291 		int res = curl_multi_wait(pInstances-&gt;curlm, NULL, 0, 1000, &amp;numfds);
1292 		if (res != CURLM_OK) {
1293 			LogError(0, RS_RET_ERR, "error: curl_multi_wait() numfds=%d, res=%d:%s\n",
1294 					numfds, res, curl_multi_strerror(res));
1295 			return res;
1296 		}
1297 		int prev_still_running = still_running;
1298 		curl_multi_perform(pInstances-&gt;curlm, &amp;still_running);
1299 		if (prev_still_running &gt; still_running) {
1300 			cleanupCompletedContainerRequests(pInstances);
1301 		}
1302 	} while (still_running &amp;&amp; glbl.GetGlobalInputTermState() == 0);
1303 	cleanupCompletedContainerRequests(pInstances);
1304 	RETiRet;
1305 }
1306 static void*
1307 getContainersTask(void *pdata) {
1308 	docker_cont_log_instances_t *pInstances = (docker_cont_log_instances_t*) pdata;
1309 	while(glbl.GetGlobalInputTermState() == 0) {
1310 		srSleep(runModConf-&gt;iPollInterval, 10);
1311 		getContainerIdsAndAppend(false, pInstances);
1312 	}
1313 	return pdata;
1314 }
1315 BEGINrunInput
1316 	rsRetVal localRet = RS_RET_OK;
1317 	docker_cont_log_instances_t *pInstances=NULL;
1318 	pthread_t thrd_id; 	pthread_attr_t thrd_attr;
1319 	int get_containers_thread_initialized = 0;
1320 	time_t now;
1321 CODESTARTrunInput
1322 	datetime.GetTime(&amp;now);
1323 	CHKiRet(ratelimitNew(&amp;ratelimiter, "imdocker", NULL));
1324 	curl_global_init(CURL_GLOBAL_ALL);
1325 	localRet = dockerContLogReqsNew(&amp;pInstances);
1326 	if (localRet != RS_RET_OK) {
1327 		return localRet;
1328 	}
1329 	pInstances-&gt;time_started = now;
1330 	CHKiRet(getContainerIdsAndAppend(true, pInstances));
1331 	CHKiConcCtrl(pthread_attr_init(&amp;thrd_attr));
1332 	CHKiConcCtrl(pthread_create(&amp;thrd_id, &amp;thrd_attr, getContainersTask, pInstances));
1333 	get_containers_thread_initialized = 1;
1334 	while(glbl.GetGlobalInputTermState() == 0) {
1335 		CHKiRet(processAndPollContainerLogs(pInstances));
1336 		if (glbl.GetGlobalInputTermState() == 0) {
1337 			srSleep(1, 10);
1338 		}
1339 	}
1340 finalize_it:
1341 	if (get_containers_thread_initialized) {
1342 		pthread_kill(thrd_id, SIGTTIN);
1343 		pthread_join(thrd_id, NULL);
1344 		pthread_attr_destroy(&amp;thrd_attr);
1345 	}
1346 	if (pInstances) {
1347 		dockerContLogReqsDestruct(pInstances);
1348 	}
1349 	if (ratelimiter) {
1350 		ratelimitDestruct(ratelimiter);
1351 	}
1352 ENDrunInput
1353 BEGINwillRun
1354 CODESTARTwillRun
1355 ENDwillRun
1356 BEGINafterRun
1357 CODESTARTafterRun
1358 ENDafterRun
1359 BEGINmodExit
1360 CODESTARTmodExit
1361 	if(pInputName != NULL)
1362 		prop.Destruct(&amp;pInputName);
1363 	if(pLocalHostIP != NULL)
1364 		prop.Destruct(&amp;pLocalHostIP);
1365 	objRelease(parser, CORE_COMPONENT);
1366 	objRelease(glbl, CORE_COMPONENT);
1367 	objRelease(prop, CORE_COMPONENT);
1368 	objRelease(statsobj, CORE_COMPONENT);
1369 	objRelease(datetime, CORE_COMPONENT);
1370 ENDmodExit
1371 BEGINisCompatibleWithFeature
1372 CODESTARTisCompatibleWithFeature
1373 	if(eFeat == sFEATURENonCancelInputTermination)
1374 		iRet = RS_RET_OK;
1375 ENDisCompatibleWithFeature
1376 BEGINqueryEtryPt
1377 CODESTARTqueryEtryPt
1378 CODEqueryEtryPt_STD_IMOD_QUERIES
1379 CODEqueryEtryPt_STD_CONF2_QUERIES
1380 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
1381 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
1382 ENDqueryEtryPt
1383 BEGINmodInit()
1384 CODESTARTmodInit
1385 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
1386 	CHKiRet(objUse(glbl, CORE_COMPONENT));
1387 	CHKiRet(objUse(prop, CORE_COMPONENT));
1388 	CHKiRet(objUse(statsobj, CORE_COMPONENT));
1389 	CHKiRet(objUse(datetime, CORE_COMPONENT));
1390 	CHKiRet(objUse(parser, CORE_COMPONENT));
1391 	DBGPRINTF("imdocker version %s initializing\n", VERSION);
1392 	CHKiRet(prop.Construct(&amp;pInputName));
1393 	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("imdocker"), sizeof("imdocker") - 1));
1394 	CHKiRet(prop.ConstructFinalize(pInputName));
1395 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmkubernetes.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef _GNU_SOURCE
2 #  define _GNU_SOURCE
3 #endif
4 #include "config.h"
5 #include "rsyslog.h"
6 #include &lt;stdio.h&gt;
7 #include &lt;stdarg.h&gt;
8 #include &lt;stdlib.h&gt;
9 #include &lt;string.h&gt;
10 #include &lt;assert.h&gt;
11 #include &lt;errno.h&gt;
12 #include &lt;unistd.h&gt;
13 #include &lt;sys/stat.h&gt;
14 #include &lt;libestr.h&gt;
15 #include &lt;liblognorm.h&gt;
16 #include &lt;json.h&gt;
17 #include &lt;curl/curl.h&gt;
18 #include &lt;curl/easy.h&gt;
19 #include &lt;pthread.h&gt;
20 #include "conf.h"
21 #include "syslogd-types.h"
22 #include "module-template.h"
23 #include "errmsg.h"
24 #include "statsobj.h"
25 #include "regexp.h"
26 #include "hashtable.h"
27 #include "hashtable_itr.h"
28 #include "srUtils.h"
29 #include "unicode-helper.h"
30 #include "datetime.h"
31 MODULE_TYPE_OUTPUT MODULE_TYPE_KEEP MODULE_CNFNAME("mmkubernetes")
32 DEF_OMOD_STATIC_DATA
33 DEFobjCurrIf(regexp)
34 DEFobjCurrIf(statsobj)
35 DEFobjCurrIf(datetime)
36 #define HAVE_LOADSAMPLESFROMSTRING 1
37 #if defined(NO_LOADSAMPLESFROMSTRING)
38 #undef HAVE_LOADSAMPLESFROMSTRING
39 #endif
40 #define DFLT_FILENAME_LNRULES "rule=:/var/log/containers/%pod_name:char-to:_%_"\
41 	"%namespace_name:char-to:_%_%container_name_and_id:char-to:.%.log"
42 #define DFLT_FILENAME_RULEBASE "/etc/rsyslog.d/k8s_filename.rulebase"
43 #define DFLT_CONTAINER_LNRULES "rule=:%k8s_prefix:char-to:_%_%container_name:char-to:.%."\
44 	"%container_hash:char-to:_%_"\
45 	"%pod_name:char-to:_%_%namespace_name:char-to:_%_%not_used_1:char-to:_%_%not_used_2:rest%\n"\
46 	"rule=:%k8s_prefix:char-to:_%_%container_name:char-to:_%_"\
47 	"%pod_name:char-to:_%_%namespace_name:char-to:_%_%not_used_1:char-to:_%_%not_used_2:rest%"
48 #define DFLT_CONTAINER_RULEBASE "/etc/rsyslog.d/k8s_container_name.rulebase"
49 #define DFLT_SRCMD_PATH "$!metadata!filename"
50 #define DFLT_DSTMD_PATH "$!"
51 #define DFLT_DE_DOT 1 #define DFLT_DE_DOT_SEPARATOR "_"
52 #define DFLT_CONTAINER_NAME "$!CONTAINER_NAME" #define DFLT_CONTAINER_ID_FULL "$!CONTAINER_ID_FULL" #define DFLT_KUBERNETES_URL "https://kubernetes.default.svc.cluster.local:443"
53 #if defined(ENABLE_OPENSSL) &amp;&amp; defined(X509_V_FLAG_PARTIAL_CHAIN)
54 #define SUPPORT_SSL_PARTIAL_CHAIN 1
55 #endif
56 struct cache_entry_s {
57 	time_t ttl; 	void *data; };
58 static struct cache_s {
59 	const uchar *kbUrl;
60 	struct hashtable *mdHt;
61 	struct hashtable *nsHt;
62 	pthread_mutex_t *cacheMtx;
63 	int lastBusyTime; 	time_t expirationTime; } **caches;
64 typedef struct {
65 	int nmemb;
66 	uchar **patterns;
67 	regex_t *regexps;
68 } annotation_match_t;
69 struct modConfData_s {
70 	rsconf_t *pConf;		uchar *kubernetesUrl;		uchar *srcMetadataPath;		uchar *dstMetadataPath;		uchar *caCertFile; 	uchar *myCertFile; 	uchar *myPrivKeyFile; 	sbool allowUnsignedCerts; 	sbool skipVerifyHost; 	uchar *token; 	uchar *tokenFile; 	sbool de_dot; 	uchar *de_dot_separator; 	size_t de_dot_separator_len; 	annotation_match_t annotation_match; 	char *fnRules; 	uchar *fnRulebase; 	char *contRules; 	uchar *contRulebase; 	int busyRetryInterval; 	sbool sslPartialChain; 	int cacheEntryTTL; 	int cacheExpireInterval; };
71 typedef struct _instanceData {
72 	msgPropDescr_t *contNameDescr; 	msgPropDescr_t *contIdFullDescr; 	struct cache_s *cache;
73 	int busyRetryInterval; 	sbool sslPartialChain; 	int cacheEntryTTL; 	int cacheExpireInterval; } instanceData;
74 typedef struct wrkrInstanceData {
75 	instanceData *pData;
76 	CURL *curlCtx;
77 	struct curl_slist *curlHdr;
78 	char *curlRply;
79 	size_t curlRplyLen;
80 	statsobj_t *stats; 	STATSCOUNTER_DEF(k8sRecordSeen, mutK8sRecordSeen);
81 	STATSCOUNTER_DEF(namespaceMetadataSuccess, mutNamespaceMetadataSuccess);
82 	STATSCOUNTER_DEF(namespaceMetadataNotFound, mutNamespaceMetadataNotFound);
83 	STATSCOUNTER_DEF(namespaceMetadataBusy, mutNamespaceMetadataBusy);
84 	STATSCOUNTER_DEF(namespaceMetadataError, mutNamespaceMetadataError);
85 	STATSCOUNTER_DEF(podMetadataSuccess, mutPodMetadataSuccess);
86 	STATSCOUNTER_DEF(podMetadataNotFound, mutPodMetadataNotFound);
87 	STATSCOUNTER_DEF(podMetadataBusy, mutPodMetadataBusy);
88 	STATSCOUNTER_DEF(podMetadataError, mutPodMetadataError);
89 	STATSCOUNTER_DEF(podCacheNumEntries, mutPodCacheNumEntries);
90 	STATSCOUNTER_DEF(namespaceCacheNumEntries, mutNamespaceCacheNumEntries);
91 	STATSCOUNTER_DEF(podCacheHits, mutPodCacheHits);
92 	STATSCOUNTER_DEF(namespaceCacheHits, mutNamespaceCacheHits);
93 	STATSCOUNTER_DEF(podCacheMisses, mutPodCacheMisses);
94 	STATSCOUNTER_DEF(namespaceCacheMisses, mutNamespaceCacheMisses);
95 } wrkrInstanceData_t;
96 static struct cnfparamdescr modpdescr[] = {
97 	{ "kubernetesurl", eCmdHdlrString, 0 },
98 	{ "srcmetadatapath", eCmdHdlrString, 0 },
99 	{ "dstmetadatapath", eCmdHdlrString, 0 },
100 	{ "tls.cacert", eCmdHdlrString, 0 },
101 	{ "tls.mycert", eCmdHdlrString, 0 },
102 	{ "tls.myprivkey", eCmdHdlrString, 0 },
103 	{ "allowunsignedcerts", eCmdHdlrBinary, 0 },
104 <a name="0"></a>	{ "skipverifyhost", eCmdHdlrBinary, 0 },
105 	{ "token", eCmdHdlrString, 0 },
106 	{ "tokenfile", eCmdHdlrString, 0 },
107 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "annotation_match", eCmdHdlrArray, 0 },
108 	{ "de_dot", eCmdHdlrBinary, 0 },
109 	{ "de_dot_separator", eCmdHdlrString, 0 },
110 	{ "filenamerulebase", eCmdHdlrString, 0 },
111 	{ "containerrulebase", eCmdHdlrString, 0 },
112 	{ "busyretryinterval", eCmdHdlrInt, 0 },
113 	{ "sslpartialchain", eCmdHdlrBinary, 0 },
114 	{ "cacheentryttl", eCmdHdlrInt, 0 },
115 	{ "cacheexpireinterval", eCmdHdlrInt, 0 }
116 #if HAVE_LOADSAMPLESFROMSTRING == 1
117 	,
118 	{ "filenamerules", eCmdHdlrArray, 0 },
119 	{ "containerrules", eCmdHdlrArray, 0 }
120 #endif
121 };
122 static struct cnfparamblk modpblk = {
123 	CNFPARAMBLK_VERSION,
124 	sizeof(modpdescr)/sizeof(struct cnfparamdescr),
125 	modpdescr
126 };
127 static struct cnfparamdescr actpdescr[] = {</b></font>
128 	{ "kubernetesurl", eCmdHdlrString, 0 },
129 	{ "srcmetadatapath", eCmdHdlrString, 0 },
130 	{ "dstmetadatapath", eCmdHdlrString, 0 },
131 	{ "tls.cacert", eCmdHdlrString, 0 },
132 	{ "tls.mycert", eCmdHdlrString, 0 },
133 	{ "tls.myprivkey", eCmdHdlrString, 0 },
134 	{ "allowunsignedcerts", eCmdHdlrBinary, 0 },
135 	{ "skipverifyhost", eCmdHdlrBinary, 0 },
136 	{ "token", eCmdHdlrString, 0 },
137 	{ "tokenfile", eCmdHdlrString, 0 },
138 	{ "annotation_match", eCmdHdlrArray, 0 },
139 	{ "de_dot", eCmdHdlrBinary, 0 },
140 	{ "de_dot_separator", eCmdHdlrString, 0 },
141 	{ "filenamerulebase", eCmdHdlrString, 0 },
142 	{ "containerrulebase", eCmdHdlrString, 0 },
143 	{ "busyretryinterval", eCmdHdlrInt, 0 },
144 	{ "sslpartialchain", eCmdHdlrBinary, 0 },
145 	{ "cacheentryttl", eCmdHdlrInt, 0 },
146 	{ "cacheexpireinterval", eCmdHdlrInt, 0 }
147 #if HAVE_LOADSAMPLESFROMSTRING == 1
148 	,
149 	{ "filenamerules", eCmdHdlrArray, 0 },
150 	{ "containerrules", eCmdHdlrArray, 0 }
151 #endif
152 };
153 static struct cnfparamblk actpblk =
154 	{ CNFPARAMBLK_VERSION,
155 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
156 	  actpdescr
157 	};
158 static modConfData_t *loadModConf = NULL;	static modConfData_t *runModConf = NULL;	
159 static void free_annotationmatch(annotation_match_t *match) {
160 	if (match) {
161 		for(int ii = 0 ; ii &lt; match-&gt;nmemb; ++ii) {
162 			if (match-&gt;patterns)
163 				free(match-&gt;patterns[ii]);
164 			if (match-&gt;regexps)
165 				regexp.regfree(&amp;match-&gt;regexps[ii]);
166 		}
167 		free(match-&gt;patterns);
168 		match-&gt;patterns = NULL;
169 		free(match-&gt;regexps);
170 		match-&gt;regexps = NULL;
171 		match-&gt;nmemb = 0;
172 	}
173 }
174 static int init_annotationmatch(annotation_match_t *match, struct cnfarray *ar) {
175 	DEFiRet;
176 	match-&gt;nmemb = ar-&gt;nmemb;
177 	CHKmalloc(match-&gt;patterns = calloc(sizeof(uchar*), match-&gt;nmemb));
178 	CHKmalloc(match-&gt;regexps = calloc(sizeof(regex_t), match-&gt;nmemb));
179 	for(int jj = 0; jj &lt; ar-&gt;nmemb; ++jj) {
180 		int rexret = 0;
181 		match-&gt;patterns[jj] = (uchar*)es_str2cstr(ar-&gt;arr[jj], NULL);
182 		rexret = regexp.regcomp(&amp;match-&gt;regexps[jj],
183 				(char *)match-&gt;patterns[jj], REG_EXTENDED|REG_NOSUB);
184 		if (0 != rexret) {
185 			char errMsg[512];
186 			regexp.regerror(rexret, &amp;match-&gt;regexps[jj], errMsg, sizeof(errMsg));
187 			iRet = RS_RET_CONFIG_ERROR;
188 			LogError(0, iRet,
189 					"error: could not compile annotation_match string [%s]"
190 					" into an extended regexp - %d: %s\n",
191 					match-&gt;patterns[jj], rexret, errMsg);
192 			break;
193 		}
194 	}
195 finalize_it:
196 	if (iRet)
197 		free_annotationmatch(match);
198 	RETiRet;
199 }
200 static int copy_annotationmatch(annotation_match_t *src, annotation_match_t *dest) {
201 	DEFiRet;
202 	dest-&gt;nmemb = src-&gt;nmemb;
203 	CHKmalloc(dest-&gt;patterns = malloc(sizeof(uchar*) * dest-&gt;nmemb));
204 	CHKmalloc(dest-&gt;regexps = calloc(sizeof(regex_t), dest-&gt;nmemb));
205 	for(int jj = 0 ; jj &lt; src-&gt;nmemb ; ++jj) {
206 		CHKmalloc(dest-&gt;patterns[jj] = (uchar*)strdup((char *)src-&gt;patterns[jj]));
207 		regexp.regcomp(&amp;dest-&gt;regexps[jj], (char *)dest-&gt;patterns[jj], REG_EXTENDED|REG_NOSUB);
208 	}
209 finalize_it:
210 	if (iRet)
211 	free_annotationmatch(dest);
212 	RETiRet;
213 }
214 static struct json_object *match_annotations(annotation_match_t *match,
215 		struct json_object *annotations) {
216 	struct json_object *ret = NULL;
217 	for (int jj = 0; jj &lt; match-&gt;nmemb; ++jj) {
218 		struct json_object_iterator it = json_object_iter_begin(annotations);
219 		struct json_object_iterator itEnd = json_object_iter_end(annotations);
220 		for (;!json_object_iter_equal(&amp;it, &amp;itEnd); json_object_iter_next(&amp;it)) {
221 			const char *const key = json_object_iter_peek_name(&amp;it);
222 			if (!ret || !fjson_object_object_get_ex(ret, key, NULL)) {
223 				if (!regexp.regexec(&amp;match-&gt;regexps[jj], key, 0, NULL, 0)) {
224 					if (!ret) {
225 						ret = json_object_new_object();
226 					}
227 					json_object_object_add(ret, key,
228 						json_object_get(json_object_iter_peek_value(&amp;it)));
229 				}
230 			}
231 		}
232 	}
233 	return ret;
234 }
235 static struct json_object *de_dot_json_object(struct json_object *jobj,
236 		const char *delim, size_t delim_len) {
237 	struct json_object *ret = NULL;
238 	struct json_object_iterator it = json_object_iter_begin(jobj);
239 	struct json_object_iterator itEnd = json_object_iter_end(jobj);
240 	es_str_t *new_es_key = NULL;
241 	DEFiRet;
242 	ret = json_object_new_object();
243 	while (!json_object_iter_equal(&amp;it, &amp;itEnd)) {
244 		const char *const key = json_object_iter_peek_name(&amp;it);
245 		const char *cc = strstr(key, ".");
246 		if (NULL == cc) {
247 			json_object_object_add(ret, key,
248 					json_object_get(json_object_iter_peek_value(&amp;it)));
249 		} else {
250 			char *new_key = NULL;
251 			const char *prevcc = key;
252 			new_es_key = es_newStrFromCStr(key, (es_size_t)(cc-prevcc));
253 			while (cc) {
254 				if (es_addBuf(&amp;new_es_key, (char *)delim, (es_size_t)delim_len))
255 					ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
256 				cc += 1; 				prevcc = cc; 				if ((cc = strstr(prevcc, ".")) || (cc = strchr(prevcc, '\0'))) {
257 					if (es_addBuf(&amp;new_es_key, (char *)prevcc, (es_size_t)(cc-prevcc)))
258 						ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
259 					if (!*cc)
260 						cc = NULL; 				}
261 			}
262 			new_key = es_str2cstr(new_es_key, NULL);
263 			es_deleteStr(new_es_key);
264 			new_es_key = NULL;
265 			json_object_object_add(ret, new_key,
266 					json_object_get(json_object_iter_peek_value(&amp;it)));
267 			free(new_key);
268 		}
269 		json_object_iter_next(&amp;it);
270 	}
271 finalize_it:
272 	if (iRet != RS_RET_OK) {
273 		json_object_put(ret);
274 		ret = NULL;
275 	}
276 	if (new_es_key)
277 		es_deleteStr(new_es_key);
278 	return ret;
279 }
280 static void parse_labels_annotations(struct json_object *jMetadata,
281 		annotation_match_t *match, sbool de_dot,
282 		const char *delim, size_t delim_len) {
283 	struct json_object *jo = NULL;
284 	if (fjson_object_object_get_ex(jMetadata, "annotations", &amp;jo)) {
285 		if ((jo = match_annotations(match, jo)))
286 			json_object_object_add(jMetadata, "annotations", jo);
287 		else
288 			json_object_object_del(jMetadata, "annotations");
289 	}
290 	if (de_dot) {
291 		struct json_object *jo2 = NULL;
292 		if (fjson_object_object_get_ex(jMetadata, "annotations", &amp;jo)) {
293 			if ((jo2 = de_dot_json_object(jo, delim, delim_len))) {
294 				json_object_object_add(jMetadata, "annotations", jo2);
295 			}
296 		}
297 		if (fjson_object_object_get_ex(jMetadata, "labels", &amp;jo)) {
298 			if ((jo2 = de_dot_json_object(jo, delim, delim_len))) {
299 				json_object_object_add(jMetadata, "labels", jo2);
300 			}
301 		}
302 	}
303 }
304 #if HAVE_LOADSAMPLESFROMSTRING == 1
305 static int array_to_rules(struct cnfarray *ar, char **rules) {
306 	DEFiRet;
307 	es_str_t *tmpstr = NULL;
308 	es_size_t size = 0;
309 	if (rules == NULL)
310 		FINALIZE;
311 	*rules = NULL;
312 	if (!ar-&gt;nmemb)
313 		FINALIZE;
314 	for (int jj = 0; jj &lt; ar-&gt;nmemb; jj++)
315 		size += es_strlen(ar-&gt;arr[jj]);
316 	if (!size)
317 		FINALIZE;
318 	CHKmalloc(tmpstr = es_newStr(size));
319 	CHKiRet((es_addStr(&amp;tmpstr, ar-&gt;arr[0])));
320 	CHKiRet((es_addBufConstcstr(&amp;tmpstr, "\n")));
321 	for(int jj=1; jj &lt; ar-&gt;nmemb; ++jj) {
322 		CHKiRet((es_addStr(&amp;tmpstr, ar-&gt;arr[jj])));
323 		CHKiRet((es_addBufConstcstr(&amp;tmpstr, "\n")));
324 	}
325 	CHKiRet((es_addBufConstcstr(&amp;tmpstr, "\0")));
326 	CHKmalloc(*rules = es_str2cstr(tmpstr, NULL));
327 finalize_it:
328 	if (tmpstr) {
329 		es_deleteStr(tmpstr);
330 	}
331 	if (iRet != RS_RET_OK) {
332 		free(*rules);
333 		*rules = NULL;
334 	}
335 	RETiRet;
336 }
337 #endif
338 static void
339 errCallBack(void __attribute__((unused)) *cookie, const char *msg,
340 	    size_t __attribute__((unused)) lenMsg)
341 {
342 	LogError(0, RS_RET_ERR_LIBLOGNORM, "liblognorm error: %s", msg);
343 }
344 static rsRetVal
345 set_lnctx(ln_ctx *ctxln, char *instRules, uchar *instRulebase, char *modRules, uchar *modRulebase)
346 {
347 	DEFiRet;
348 	if (ctxln == NULL)
349 		FINALIZE;
350 	CHKmalloc(*ctxln = ln_initCtx());
351 	ln_setErrMsgCB(*ctxln, errCallBack, NULL);
352 	if(instRules) {
353 #if HAVE_LOADSAMPLESFROMSTRING == 1
354 		if(ln_loadSamplesFromString(*ctxln, instRules) !=0) {
355 			LogError(0, RS_RET_NO_RULEBASE, "error: normalization rules '%s' "
356 					"could not be loaded", instRules);
357 			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
358 		}
359 #else
360 		(void)instRules;
361 #endif
362 	} else if(instRulebase) {
363 		if(ln_loadSamples(*ctxln, (char*) instRulebase) != 0) {
364 			LogError(0, RS_RET_NO_RULEBASE, "error: normalization rulebase '%s' "
365 					"could not be loaded", instRulebase);
366 			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
367 		}
368 	} else if(modRules) {
369 #if HAVE_LOADSAMPLESFROMSTRING == 1
370 		if(ln_loadSamplesFromString(*ctxln, modRules) !=0) {
371 			LogError(0, RS_RET_NO_RULEBASE, "error: normalization rules '%s' "
372 					"could not be loaded", modRules);
373 			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
374 		}
375 #else
376 		(void)modRules;
377 #endif
378 	} else if(modRulebase) {
379 		if(ln_loadSamples(*ctxln, (char*) modRulebase) != 0) {
380 			LogError(0, RS_RET_NO_RULEBASE, "error: normalization rulebase '%s' "
381 					"could not be loaded", modRulebase);
382 			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
383 		}
384 	}
385 finalize_it:
386 	if (iRet != RS_RET_OK){
387 		ln_exitCtx(*ctxln);
388 		*ctxln = NULL;
389 	}
390 	RETiRet;
391 }
392 BEGINbeginCnfLoad
393 CODESTARTbeginCnfLoad
394 	loadModConf = pModConf;
395 	pModConf-&gt;pConf = pConf;
396 ENDbeginCnfLoad
397 BEGINsetModCnf
398 	struct cnfparamvals *pvals = NULL;
399 	int i;
400 	FILE *fp = NULL;
401 	int ret;
402 	char errStr[1024];
403 CODESTARTsetModCnf
404 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
405 	if(pvals == NULL) {
406 		LogError(0, RS_RET_MISSING_CNFPARAMS, "mmkubernetes: "
407 			"error processing module config parameters [module(...)]");
408 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
409 	}
410 	if(Debug) {
411 		dbgprintf("module (global) param blk for mmkubernetes:\n");
412 		cnfparamsPrint(&amp;modpblk, pvals);
413 	}
414 	loadModConf-&gt;de_dot = DFLT_DE_DOT;
415 	loadModConf-&gt;busyRetryInterval = DFLT_BUSY_RETRY_INTERVAL;
416 	loadModConf-&gt;sslPartialChain = DFLT_SSL_PARTIAL_CHAIN;
417 	loadModConf-&gt;cacheEntryTTL = DFLT_CACHE_ENTRY_TTL;
418 	loadModConf-&gt;cacheExpireInterval = DFLT_CACHE_EXPIRE_INTERVAL;
419 <a name="1"></a>	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
420 		if(!pvals[i].bUsed) {
421 			continue;
422 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(modpblk.descr[i].name, "kubernetesurl")) {
423 			free(loadModConf-&gt;kubernetesUrl);
424 			loadModConf-&gt;kubernetesUrl = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
425 		} else if(!strcmp(modpblk.descr[i].name, "srcmetadatapath")) {
426 			free(loadModConf-&gt;srcMetadataPath);
427 			loadModConf-&gt;srcMetadataPath = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
428 		} else if(!strcmp(modpblk.descr[i].name, "dstmetadatapath")) {
429 			free(loadModConf-&gt;dstMetadataPath);
430 			loadModConf-&gt;dstMetadataPath = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
431 		} else if(!strcmp(modpblk.descr[i].name, "tls.cacert")) {
432 			free(loadModConf-&gt;caCertFile);
433 			loadModConf-&gt;caCertFile = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
434 			fp = fopen((const char*)loadModConf-&gt;caCertFile, "r");
435 			if(fp == NULL) {
436 				rs_strerror_r(errno, errStr, sizeof(errStr));
437 				iRet = RS_RET_NO_FILE_ACCESS;
438 				LogError(0, iRet,
439 						"error: 'tls.cacert' file %s couldn't be accessed: %s\n",
440 						loadModConf-&gt;caCertFile, errStr);
441 				ABORT_FINALIZE(iRet);
442 			} else {
443 				fclose(fp);
444 				fp = NULL;
445 			}
446 		} else if(!strcmp(modpblk.descr[i].name, "tls.mycert")) {
447 			free(loadModConf-&gt;myCertFile);
448 			loadModConf-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
449 			fp = fopen((const char*)loadModConf-&gt;myCertFile, "r");
450 			if(fp == NULL) {
451 				rs_strerror_r(errno, errStr, sizeof(errStr));
452 				iRet = RS_RET_NO_FILE_ACCESS;
453 				LogError(0, iRet,
454 						"error: 'tls.mycert' file %s couldn't be accessed: %s\n",
455 						loadModConf-&gt;myCertFile, errStr);
456 			} else {
457 				fclose(fp);
458 				fp = NULL;
459 			}
460 		} else if(!strcmp(modpblk.descr[i].name, "tls.myprivkey")) {
461 			loadModConf-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
462 			fp = fopen((const char*)loadModConf-&gt;myPrivKeyFile, "r");
463 			if(fp == NULL) {
464 				rs_strerror_r(errno, errStr, sizeof(errStr));
465 				iRet = RS_RET_NO_FILE_ACCESS;
466 				LogError(0, iRet,
467 						"error: 'tls.myprivkey' file %s couldn't be accessed: %s\n",
468 						loadModConf-&gt;myPrivKeyFile, errStr);
469 			} else {
470 				fclose(fp);
471 				fp = NULL;
472 			}
473 		} else if(!strcmp(modpblk.descr[i].name, "allowunsignedcerts")) {
474 <a name="4"></a>			loadModConf-&gt;allowUnsignedCerts = pvals[i].val.d.n;
475 		} else if(!strcmp(modpblk.descr[i].name, "skipverifyhost")) {
476 			loadModConf-&gt;skipVerifyHost = pvals[i].val.d.n;
477 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(modpblk.descr[i].name, "token")) {
478 			free(loadModConf-&gt;token);
479 			loadModConf-&gt;token = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
480 		} else if(!strcmp(modpblk.descr[i].name, "tokenfile")) {
481 			free(loadModConf-&gt;tokenFile);
482 			loadModConf-&gt;tokenFile = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
483 			fp = fopen((const char*)loadModConf-&gt;tokenFile, "r");</b></font>
484 			if(fp == NULL) {
485 				rs_strerror_r(errno, errStr, sizeof(errStr));
486 				iRet = RS_RET_NO_FILE_ACCESS;
487 				LogError(0, iRet,
488 						"error: token file %s couldn't be accessed: %s\n",
489 						loadModConf-&gt;tokenFile, errStr);
490 				ABORT_FINALIZE(iRet);
491 			} else {
492 				fclose(fp);
493 				fp = NULL;
494 			}
495 		} else if(!strcmp(modpblk.descr[i].name, "annotation_match")) {
496 			free_annotationmatch(&amp;loadModConf-&gt;annotation_match);
497 			if ((ret = init_annotationmatch(&amp;loadModConf-&gt;annotation_match, pvals[i].val.d.ar)))
498 				ABORT_FINALIZE(ret);
499 		} else if(!strcmp(modpblk.descr[i].name, "de_dot")) {
500 			loadModConf-&gt;de_dot = pvals[i].val.d.n;
501 		} else if(!strcmp(modpblk.descr[i].name, "de_dot_separator")) {
502 			free(loadModConf-&gt;de_dot_separator);
503 			loadModConf-&gt;de_dot_separator = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
504 #if HAVE_LOADSAMPLESFROMSTRING == 1
505 		} else if(!strcmp(modpblk.descr[i].name, "filenamerules")) {
506 			free(loadModConf-&gt;fnRules);
507 			CHKiRet((array_to_rules(pvals[i].val.d.ar, &amp;loadModConf-&gt;fnRules)));
508 #endif
509 		} else if(!strcmp(modpblk.descr[i].name, "filenamerulebase")) {
510 			free(loadModConf-&gt;fnRulebase);
511 			loadModConf-&gt;fnRulebase = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
512 			fp = fopen((const char*)loadModConf-&gt;fnRulebase, "r");
513 			if(fp == NULL) {
514 				rs_strerror_r(errno, errStr, sizeof(errStr));
515 				iRet = RS_RET_NO_FILE_ACCESS;
516 				LogError(0, iRet,
517 						"error: filenamerulebase file %s couldn't be accessed: %s\n",
518 						loadModConf-&gt;fnRulebase, errStr);
519 				ABORT_FINALIZE(iRet);
520 			} else {
521 				fclose(fp);
522 				fp = NULL;
523 			}
524 #if HAVE_LOADSAMPLESFROMSTRING == 1
525 		} else if(!strcmp(modpblk.descr[i].name, "containerrules")) {
526 			free(loadModConf-&gt;contRules);
527 			CHKiRet((array_to_rules(pvals[i].val.d.ar, &amp;loadModConf-&gt;contRules)));
528 #endif
529 		} else if(!strcmp(modpblk.descr[i].name, "containerrulebase")) {
530 			free(loadModConf-&gt;contRulebase);
531 			loadModConf-&gt;contRulebase = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
532 			fp = fopen((const char*)loadModConf-&gt;contRulebase, "r");
533 			if(fp == NULL) {
534 				rs_strerror_r(errno, errStr, sizeof(errStr));
535 				iRet = RS_RET_NO_FILE_ACCESS;
536 				LogError(0, iRet,
537 						"error: containerrulebase file %s couldn't be accessed: %s\n",
538 						loadModConf-&gt;contRulebase, errStr);
539 				ABORT_FINALIZE(iRet);
540 <a name="2"></a>			} else {
541 				fclose(fp);
542 				fp = NULL;
543 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>			}
544 		} else if(!strcmp(modpblk.descr[i].name, "busyretryinterval")) {
545 			loadModConf-&gt;busyRetryInterval = pvals[i].val.d.n;
546 		} else if(!strcmp(modpblk.descr[i].name, "sslpartialchain")) {
547 #if defined(SUPPORT_SSL_PARTIAL_CHAIN)
548 			loadModConf-&gt;sslPartialChain = pvals[i].val.d.n;
549 #else
550 			LogMsg(0, RS_RET_VALUE_NOT_IN_THIS_MODE, LOG_INFO,
551 					"sslpartialchain is only supported for OpenSSL\n");
552 #endif
553 		} else if(!strcmp(modpblk.descr[i].name, "cacheentryttl")) {
554 			loadModConf-&gt;cacheEntryTTL = pvals[i].val.d.n;
555 		} else if(!strcmp(modpblk.descr[i].name, "cacheexpireinterval")) {</b></font>
556 			loadModConf-&gt;cacheExpireInterval = pvals[i].val.d.n;
557 		} else {
558 			dbgprintf("mmkubernetes: program error, non-handled "
559 				"param '%s' in module() block\n", modpblk.descr[i].name);
560 		}
561 	}
562 #if HAVE_LOADSAMPLESFROMSTRING == 1
563 	if (loadModConf-&gt;fnRules &amp;&amp; loadModConf-&gt;fnRulebase) {
564 		LogError(0, RS_RET_CONFIG_ERROR,
565 				"mmkubernetes: only 1 of filenamerules or filenamerulebase may be used");
566 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
567 	}
568 	if (loadModConf-&gt;contRules &amp;&amp; loadModConf-&gt;contRulebase) {
569 		LogError(0, RS_RET_CONFIG_ERROR,
570 				"mmkubernetes: only 1 of containerrules or containerrulebase may be used");
571 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
572 	}
573 #endif
574 	if ((loadModConf-&gt;cacheExpireInterval &gt; -1)) {
575 		if ((loadModConf-&gt;cacheEntryTTL &lt; 0)) {
576 			LogError(0, RS_RET_CONFIG_ERROR,
577 					"mmkubernetes: cacheentryttl value [%d] is invalid - "
578 					"value must be 0 or greater",
579 					loadModConf-&gt;cacheEntryTTL);
580 			ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
581 		}
582 	}
583 	if(loadModConf-&gt;srcMetadataPath == NULL)
584 		loadModConf-&gt;srcMetadataPath = (uchar *) strdup(DFLT_SRCMD_PATH);
585 	if(loadModConf-&gt;dstMetadataPath == NULL)
586 		loadModConf-&gt;dstMetadataPath = (uchar *) strdup(DFLT_DSTMD_PATH);
587 	if(loadModConf-&gt;de_dot_separator == NULL)
588 		loadModConf-&gt;de_dot_separator = (uchar *) strdup(DFLT_DE_DOT_SEPARATOR);
589 	if(loadModConf-&gt;de_dot_separator)
590 		loadModConf-&gt;de_dot_separator_len = strlen((const char *)loadModConf-&gt;de_dot_separator);
591 #if HAVE_LOADSAMPLESFROMSTRING == 1
592 	if (loadModConf-&gt;fnRules == NULL &amp;&amp; loadModConf-&gt;fnRulebase == NULL)
593 		loadModConf-&gt;fnRules = strdup(DFLT_FILENAME_LNRULES);
594 	if (loadModConf-&gt;contRules == NULL &amp;&amp; loadModConf-&gt;contRulebase == NULL)
595 		loadModConf-&gt;contRules = strdup(DFLT_CONTAINER_LNRULES);
596 #else
597 	if (loadModConf-&gt;fnRulebase == NULL)
598 		loadModConf-&gt;fnRulebase = (uchar *)strdup(DFLT_FILENAME_RULEBASE);
599 	if (loadModConf-&gt;contRulebase == NULL)
600 		loadModConf-&gt;contRulebase = (uchar *)strdup(DFLT_CONTAINER_RULEBASE);
601 #endif
602 	caches = calloc(1, sizeof(struct cache_s *));
603 finalize_it:
604 	if (fp)
605 		fclose(fp);
606 	if(pvals != NULL)
607 		cnfparamvalsDestruct(pvals, &amp;modpblk);
608 ENDsetModCnf
609 BEGINcreateInstance
610 CODESTARTcreateInstance
611 ENDcreateInstance
612 BEGINfreeInstance
613 CODESTARTfreeInstance
614 	free(pData-&gt;kubernetesUrl);
615 	msgPropDescrDestruct(pData-&gt;srcMetadataDescr);
616 	free(pData-&gt;srcMetadataDescr);
617 	free(pData-&gt;dstMetadataPath);
618 	free(pData-&gt;caCertFile);
619 	free(pData-&gt;myCertFile);
620 	free(pData-&gt;myPrivKeyFile);
621 	free(pData-&gt;token);
622 	free(pData-&gt;tokenFile);
623 	free(pData-&gt;fnRules);
624 	free(pData-&gt;fnRulebase);
625 	ln_exitCtx(pData-&gt;fnCtxln);
626 	free(pData-&gt;contRules);
627 	free(pData-&gt;contRulebase);
628 	ln_exitCtx(pData-&gt;contCtxln);
629 	free_annotationmatch(&amp;pData-&gt;annotation_match);
630 	free(pData-&gt;de_dot_separator);
631 	msgPropDescrDestruct(pData-&gt;contNameDescr);
632 	free(pData-&gt;contNameDescr);
633 	msgPropDescrDestruct(pData-&gt;contIdFullDescr);
634 	free(pData-&gt;contIdFullDescr);
635 ENDfreeInstance
636 static size_t curlCB(char *data, size_t size, size_t nmemb, void *usrptr)
637 {
638 	DEFiRet;
639 	wrkrInstanceData_t *pWrkrData = (wrkrInstanceData_t *) usrptr;
640 	char * buf;
641 	size_t newlen;
642 	newlen = pWrkrData-&gt;curlRplyLen + size * nmemb;
643 	CHKmalloc(buf = realloc(pWrkrData-&gt;curlRply, newlen));
644 	memcpy(buf + pWrkrData-&gt;curlRplyLen, data, size * nmemb);
645 	pWrkrData-&gt;curlRply = buf;
646 	pWrkrData-&gt;curlRplyLen = newlen;
647 finalize_it:
648 	if (iRet != RS_RET_OK) {
649 		return 0;
650 	}
651 	return size * nmemb;
652 }
653 #if defined(SUPPORT_SSL_PARTIAL_CHAIN)
654 static CURLcode set_ssl_partial_chain(CURL *curl, void *ssl_ctx, void *userptr)
655 {
656 	(void)userptr; 	CURLcode rv = CURLE_ABORTED_BY_CALLBACK;
657 	X509_STORE *store = NULL;
658 	store = SSL_CTX_get_cert_store((SSL_CTX *)ssl_ctx);
659 	if(!store)
660 		goto finalize_it;
661 	if(!X509_STORE_set_flags(store, X509_V_FLAG_PARTIAL_CHAIN))
662 		goto finalize_it;
663 	rv = CURLE_OK;
664 finalize_it:
665 	return rv;
666 }
667 #endif
668 BEGINcreateWrkrInstance
669 CODESTARTcreateWrkrInstance
670 	CURL *ctx;
671 	struct curl_slist *hdr = NULL;
672 	char *tokenHdr = NULL;
673 	FILE *fp = NULL;
674 	char *token = NULL;
675 	char *statsName = NULL;
676 	CHKiRet(statsobj.Construct(&amp;(pWrkrData-&gt;stats)));
677 	if ((-1 == asprintf(&amp;statsName, "mmkubernetes(%s)", pWrkrData-&gt;pData-&gt;kubernetesUrl)) ||
678 		(!statsName)) {
679 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
680 	}
681 	CHKiRet(statsobj.SetName(pWrkrData-&gt;stats, (uchar *)statsName));
682 	free(statsName);
683 	statsName = NULL;
684 	CHKiRet(statsobj.SetOrigin(pWrkrData-&gt;stats, UCHAR_CONSTANT("mmkubernetes")));
685 	STATSCOUNTER_INIT(pWrkrData-&gt;k8sRecordSeen, pWrkrData-&gt;mutK8sRecordSeen);
686 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("recordseen"),
687 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;k8sRecordSeen)));
688 	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceMetadataSuccess, pWrkrData-&gt;mutNamespaceMetadataSuccess);
689 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacemetadatasuccess"),
690 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceMetadataSuccess)));
691 	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceMetadataNotFound, pWrkrData-&gt;mutNamespaceMetadataNotFound);
692 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacemetadatanotfound"),
693 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceMetadataNotFound)));
694 	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceMetadataBusy, pWrkrData-&gt;mutNamespaceMetadataBusy);
695 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacemetadatabusy"),
696 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceMetadataBusy)));
697 	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceMetadataError, pWrkrData-&gt;mutNamespaceMetadataError);
698 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacemetadataerror"),
699 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceMetadataError)));
700 	STATSCOUNTER_INIT(pWrkrData-&gt;podMetadataSuccess, pWrkrData-&gt;mutPodMetadataSuccess);
701 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podmetadatasuccess"),
702 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podMetadataSuccess)));
703 	STATSCOUNTER_INIT(pWrkrData-&gt;podMetadataNotFound, pWrkrData-&gt;mutPodMetadataNotFound);
704 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podmetadatanotfound"),
705 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podMetadataNotFound)));
706 	STATSCOUNTER_INIT(pWrkrData-&gt;podMetadataBusy, pWrkrData-&gt;mutPodMetadataBusy);
707 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podmetadatabusy"),
708 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podMetadataBusy)));
709 	STATSCOUNTER_INIT(pWrkrData-&gt;podMetadataError, pWrkrData-&gt;mutPodMetadataError);
710 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podmetadataerror"),
711 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podMetadataError)));
712 	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceCacheNumEntries, pWrkrData-&gt;mutNamespaceCacheNumEntries);
713 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacecachenumentries"),
714 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceCacheNumEntries)));
715 	STATSCOUNTER_INIT(pWrkrData-&gt;podCacheNumEntries, pWrkrData-&gt;mutPodCacheNumEntries);
716 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podcachenumentries"),
717 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podCacheNumEntries)));
718 	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceCacheHits, pWrkrData-&gt;mutNamespaceCacheHits);
719 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacecachehits"),
720 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceCacheHits)));
721 	STATSCOUNTER_INIT(pWrkrData-&gt;podCacheHits, pWrkrData-&gt;mutPodCacheHits);
722 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podcachehits"),
723 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podCacheHits)));
724 	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceCacheMisses, pWrkrData-&gt;mutNamespaceCacheMisses);
725 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacecachemisses"),
726 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceCacheMisses)));
727 	STATSCOUNTER_INIT(pWrkrData-&gt;podCacheMisses, pWrkrData-&gt;mutPodCacheMisses);
728 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podcachemisses"),
729 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podCacheMisses)));
730 	CHKiRet(statsobj.ConstructFinalize(pWrkrData-&gt;stats));
731 	hdr = curl_slist_append(hdr, "Content-Type: text/json; charset=utf-8");
732 	if (pWrkrData-&gt;pData-&gt;token) {
733 		if ((-1 == asprintf(&amp;tokenHdr, "Authorization: Bearer %s", pWrkrData-&gt;pData-&gt;token)) ||
734 			(!tokenHdr)) {
735 			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
736 		}
737 	} else if (pWrkrData-&gt;pData-&gt;tokenFile) {
738 		struct stat statbuf;
739 		fp = fopen((const char*)pWrkrData-&gt;pData-&gt;tokenFile, "r");
740 		if (fp &amp;&amp; !fstat(fileno(fp), &amp;statbuf)) {
741 			size_t bytesread;
742 			CHKmalloc(token = malloc((statbuf.st_size+1)*sizeof(char)));
743 			if (0 &lt; (bytesread = fread(token, sizeof(char), statbuf.st_size, fp))) {
744 				token[bytesread] = '\0';
745 				if ((-1 == asprintf(&amp;tokenHdr, "Authorization: Bearer %s", token)) ||
746 					(!tokenHdr)) {
747 					ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
748 				}
749 			}
750 			free(token);
751 			token = NULL;
752 		}
753 		if (fp) {
754 			fclose(fp);
755 			fp = NULL;
756 		}
757 	}
758 	if (tokenHdr) {
759 		hdr = curl_slist_append(hdr, tokenHdr);
760 		free(tokenHdr);
761 	}
762 	pWrkrData-&gt;curlHdr = hdr;
763 	ctx = curl_easy_init();
764 	curl_easy_setopt(ctx, CURLOPT_HTTPHEADER, hdr);
765 	curl_easy_setopt(ctx, CURLOPT_WRITEFUNCTION, curlCB);
766 	curl_easy_setopt(ctx, CURLOPT_WRITEDATA, pWrkrData);
767 	if(pWrkrData-&gt;pData-&gt;caCertFile)
768 		curl_easy_setopt(ctx, CURLOPT_CAINFO, pWrkrData-&gt;pData-&gt;caCertFile);
769 	if(pWrkrData-&gt;pData-&gt;myCertFile)
770 		curl_easy_setopt(ctx, CURLOPT_SSLCERT, pWrkrData-&gt;pData-&gt;myCertFile);
771 	if(pWrkrData-&gt;pData-&gt;myPrivKeyFile)
772 		curl_easy_setopt(ctx, CURLOPT_SSLKEY, pWrkrData-&gt;pData-&gt;myPrivKeyFile);
773 	if(pWrkrData-&gt;pData-&gt;allowUnsignedCerts)
774 		curl_easy_setopt(ctx, CURLOPT_SSL_VERIFYPEER, 0);
775 	if(pWrkrData-&gt;pData-&gt;skipVerifyHost)
776 		curl_easy_setopt(ctx, CURLOPT_SSL_VERIFYHOST, 0);
777 #if defined(SUPPORT_SSL_PARTIAL_CHAIN)
778 	if(pWrkrData-&gt;pData-&gt;sslPartialChain) {
779 		curl_easy_setopt(ctx, CURLOPT_SSL_CTX_FUNCTION, set_ssl_partial_chain);
780 		curl_easy_setopt(ctx, CURLOPT_SSL_CTX_DATA, NULL);
781 	}
782 #endif
783 	pWrkrData-&gt;curlCtx = ctx;
784 finalize_it:
785 	free(token);
786 	free(statsName);
787 	if ((iRet != RS_RET_OK) &amp;&amp; pWrkrData-&gt;stats) {
788 		statsobj.Destruct(&amp;(pWrkrData-&gt;stats));
789 	}
790 	if (fp) {
791 		fclose(fp);
792 	}
793 ENDcreateWrkrInstance
794 BEGINfreeWrkrInstance
795 CODESTARTfreeWrkrInstance
796 	curl_easy_cleanup(pWrkrData-&gt;curlCtx);
797 	curl_slist_free_all(pWrkrData-&gt;curlHdr);
798 	statsobj.Destruct(&amp;(pWrkrData-&gt;stats));
799 ENDfreeWrkrInstance
800 static void
801 hashtable_json_object_put(void *jso)
802 {
803 	json_object_put((struct fjson_object *)jso);
804 }
805 static void
806 cache_entry_free(struct cache_entry_s *cache_entry)
807 {
808 	if (NULL != cache_entry) {
809 		if (cache_entry-&gt;data) {
810 			hashtable_json_object_put(cache_entry-&gt;data);
811 			cache_entry-&gt;data = NULL;
812 		}
813 		free(cache_entry);
814 	}
815 }
816 static void
817 cache_entry_free_raw(void *cache_entry_void)
818 {
819 	cache_entry_free((struct cache_entry_s *)cache_entry_void);
820 }
821 static struct cache_s *
822 cacheNew(instanceData *pData)
823 {
824 	DEFiRet;
825 	struct cache_s *cache = NULL;
826 	time_t now;
827 	int need_mutex_destroy = 0;
828 	CHKmalloc(cache = (struct cache_s *)calloc(1, sizeof(struct cache_s)));
829 	CHKmalloc(cache-&gt;cacheMtx = (pthread_mutex_t *)malloc(sizeof(pthread_mutex_t)));
830 	CHKmalloc(cache-&gt;mdHt = create_hashtable(100, hash_from_string,
831 		key_equals_string, cache_entry_free_raw));
832 	CHKmalloc(cache-&gt;nsHt = create_hashtable(100, hash_from_string,
833 		key_equals_string, cache_entry_free_raw));
834 	CHKiConcCtrl(pthread_mutex_init(cache-&gt;cacheMtx, NULL));
835 	need_mutex_destroy = 1;
836 	datetime.GetTime(&amp;now);
837 	cache-&gt;kbUrl = pData-&gt;kubernetesUrl;
838 	cache-&gt;expirationTime = 0;
839 	if (pData-&gt;cacheExpireInterval &gt; -1)
840 		cache-&gt;expirationTime = pData-&gt;cacheExpireInterval + pData-&gt;cacheEntryTTL + now;
841 	cache-&gt;lastBusyTime = 0;
842 	dbgprintf("mmkubernetes: created cache mdht [%p] nsht [%p]\n",
843 			cache-&gt;mdHt, cache-&gt;nsHt);
844 finalize_it:
845 	if (iRet != RS_RET_OK) {
846 	        LogError(errno, iRet, "mmkubernetes: cacheNew: unable to create metadata cache for %s",
847 	                 pData-&gt;kubernetesUrl);
848 		if (cache) {
849 			if (cache-&gt;mdHt)
850 				hashtable_destroy(cache-&gt;mdHt, 1);
851 			if (cache-&gt;nsHt)
852 				hashtable_destroy(cache-&gt;nsHt, 1);
853 			if (cache-&gt;cacheMtx) {
854 				if (need_mutex_destroy)
855 					pthread_mutex_destroy(cache-&gt;cacheMtx);
856 				free(cache-&gt;cacheMtx);
857 			}
858 			free(cache);
859 			cache = NULL;
860 		}
861 	}
862 	return cache;
863 }
864 static void cacheFree(struct cache_s *cache)
865 {
866 	hashtable_destroy(cache-&gt;mdHt, 1);
867 	hashtable_destroy(cache-&gt;nsHt, 1);
868 	pthread_mutex_destroy(cache-&gt;cacheMtx);
869 	free(cache-&gt;cacheMtx);
870 	free(cache);
871 }
872 static struct cache_entry_s *cache_entry_new(time_t ttl, struct fjson_object *jso)
873 {
874 	DEFiRet;
875 	struct cache_entry_s *cache_entry = NULL;
876 	CHKmalloc(cache_entry = malloc(sizeof(struct cache_entry_s)));
877 	cache_entry-&gt;ttl = ttl;
878 	cache_entry-&gt;data = (void *)jso;
879 finalize_it:
880 	if (iRet) {
881 		free(cache_entry);
882 		cache_entry = NULL;
883 	}
884 	return cache_entry;
885 }
886 static int cache_delete_expired_entries(wrkrInstanceData_t *pWrkrData, int isnsmd, time_t now)
887 {
888 	struct hashtable *ht = isnsmd ? pWrkrData-&gt;pData-&gt;cache-&gt;nsHt : pWrkrData-&gt;pData-&gt;cache-&gt;mdHt;
889 	struct hashtable_itr *itr = NULL;
890 	int more;
891 	if ((pWrkrData-&gt;pData-&gt;cacheExpireInterval &lt; 0) || (now &lt; pWrkrData-&gt;pData-&gt;cache-&gt;expirationTime)) {
892 		return 0; 	}
893 	pWrkrData-&gt;pData-&gt;cache-&gt;expirationTime = now + pWrkrData-&gt;pData-&gt;cacheExpireInterval;
894 	if (hashtable_count(ht) &lt; 1)
895 		return 1; 
896 	itr = hashtable_iterator(ht);
897 	if (NULL == itr)
898 		return 1; 
899 	do {
900 		struct cache_entry_s *cache_entry = (struct cache_entry_s *)hashtable_iterator_value(itr);
901 		if (now &gt;= cache_entry-&gt;ttl) {
902 			cache_entry_free(cache_entry);
903 			if (isnsmd) {
904 				STATSCOUNTER_DEC(pWrkrData-&gt;namespaceCacheNumEntries,
905 						 pWrkrData-&gt;mutNamespaceCacheNumEntries);
906 			} else {
907 				STATSCOUNTER_DEC(pWrkrData-&gt;podCacheNumEntries,
908 						 pWrkrData-&gt;mutPodCacheNumEntries);
909 			}
910 			more = hashtable_iterator_remove(itr);
911 		} else {
912 			more = hashtable_iterator_advance(itr);
913 		}
914 	} while (more);
915 	free(itr);
916 	dbgprintf("mmkubernetes: cache_delete_expired_entries: cleaned [%s] cache - size is now [%llu]\n",
917 		  isnsmd ? "namespace" : "pod",
918 		  isnsmd ? pWrkrData-&gt;namespaceCacheNumEntries : pWrkrData-&gt;podCacheNumEntries);
919 	return 1;
920 }
921 static struct fjson_object *
922 cache_entry_get(wrkrInstanceData_t *pWrkrData,
923 		int isnsmd, const char *key, time_t now)
924 {
925 	struct fjson_object *jso = NULL;
926 	struct cache_entry_s *cache_entry = NULL;
927 	int checkttl = 1;
928 	struct hashtable *ht = isnsmd ? pWrkrData-&gt;pData-&gt;cache-&gt;nsHt : pWrkrData-&gt;pData-&gt;cache-&gt;mdHt;
929 	if (cache_delete_expired_entries(pWrkrData, isnsmd, now))
930 		checkttl = 0; 	cache_entry = (struct cache_entry_s *)hashtable_search(ht, (void *)key);
931 	if (cache_entry &amp;&amp; checkttl &amp;&amp; (now &gt;= cache_entry-&gt;ttl)) {
932 		cache_entry = (struct cache_entry_s *)hashtable_remove(ht, (void *)key);
933 		if (isnsmd) {
934 			STATSCOUNTER_DEC(pWrkrData-&gt;namespaceCacheNumEntries,
935 					 pWrkrData-&gt;mutNamespaceCacheNumEntries);
936 		} else {
937 			STATSCOUNTER_DEC(pWrkrData-&gt;podCacheNumEntries,
938 					 pWrkrData-&gt;mutPodCacheNumEntries);
939 		}
940 		cache_entry_free(cache_entry);
941 		cache_entry = NULL;
942 	}
943 	if (cache_entry) {
944 		jso = (struct fjson_object *)cache_entry-&gt;data;
945 		if (isnsmd) {
946 			STATSCOUNTER_INC(pWrkrData-&gt;namespaceCacheHits,
947 					 pWrkrData-&gt;mutNamespaceCacheHits);
948 		} else {
949 			STATSCOUNTER_INC(pWrkrData-&gt;podCacheHits,
950 					 pWrkrData-&gt;mutPodCacheHits);
951 		}
952 		dbgprintf("mmkubernetes: cache_entry_get: cache hit for [%s] cache key [%s] - hits is now [%llu]\n",
953 			  isnsmd ? "namespace" : "pod", key,
954 			  isnsmd ? pWrkrData-&gt;namespaceCacheHits : pWrkrData-&gt;podCacheHits);
955 	} else {
956 		if (isnsmd) {
957 			STATSCOUNTER_INC(pWrkrData-&gt;namespaceCacheMisses,
958 					 pWrkrData-&gt;mutNamespaceCacheMisses);
959 		} else {
960 			STATSCOUNTER_INC(pWrkrData-&gt;podCacheMisses,
961 					 pWrkrData-&gt;mutPodCacheMisses);
962 		}
963 		dbgprintf("mmkubernetes: cache_entry_get: cache miss for [%s] cache key [%s] - misses is now [%llu]\n",
964 			  isnsmd ? "namespace" : "pod", key,
965 			  isnsmd ? pWrkrData-&gt;namespaceCacheMisses : pWrkrData-&gt;podCacheMisses);
966 	}
967 	return jso;
968 }
969 static rsRetVal
970 cache_entry_add(wrkrInstanceData_t *pWrkrData,
971 		int isnsmd, const char *key, struct fjson_object *jso, time_t now, const int bDupKey)
972 {
973 	DEFiRet;
974 	struct cache_entry_s *cache_entry = NULL;
975 	struct hashtable *ht = isnsmd ? pWrkrData-&gt;pData-&gt;cache-&gt;nsHt : pWrkrData-&gt;pData-&gt;cache-&gt;mdHt;
976 	(void)cache_delete_expired_entries(pWrkrData, isnsmd, now);
977 	CHKmalloc(cache_entry = cache_entry_new(now + pWrkrData-&gt;pData-&gt;cacheEntryTTL, jso));
978 	if (cache_entry) {
979 		if (!hashtable_insert(ht, (void *)(bDupKey ? strdup(key) : key), cache_entry))
980 			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
981 		if (isnsmd) {
982 			STATSCOUNTER_INC(pWrkrData-&gt;namespaceCacheNumEntries,
983 					 pWrkrData-&gt;mutNamespaceCacheNumEntries);
984 		} else {
985 			STATSCOUNTER_INC(pWrkrData-&gt;podCacheNumEntries,
986 					 pWrkrData-&gt;mutPodCacheNumEntries);
987 		}
988 		cache_entry = NULL;
989 	}
990 finalize_it:
991 	if (cache_entry)
992 		cache_entry_free(cache_entry);
993 	return iRet;
994 }
995 static struct fjson_object *cache_entry_get_md(wrkrInstanceData_t *pWrkrData, const char *key, time_t now)
996 {
997 	return cache_entry_get(pWrkrData, 0, key, now);
998 }
999 static struct fjson_object *cache_entry_get_nsmd(wrkrInstanceData_t *pWrkrData, const char *key, time_t now)
1000 {
1001 	return cache_entry_get(pWrkrData, 1, key, now);
1002 }
1003 static rsRetVal cache_entry_add_md(wrkrInstanceData_t *pWrkrData, const char *key,
1004 				   struct fjson_object *jso, time_t now)
1005 {
1006 	return cache_entry_add(pWrkrData, 0, key, jso, now, 0);
1007 }
1008 static rsRetVal cache_entry_add_nsmd(wrkrInstanceData_t *pWrkrData, const char *key,
1009 				     struct fjson_object *jso, time_t now)
1010 {
1011 	return cache_entry_add(pWrkrData, 1, key, jso, now, 1);
1012 }
1013 BEGINnewActInst
1014 	struct cnfparamvals *pvals = NULL;
1015 	int i;
1016 	FILE *fp = NULL;
1017 	char *rxstr = NULL;
1018 	char *srcMetadataPath = NULL;
1019 	char errStr[1024];
1020 CODESTARTnewActInst
1021 	DBGPRINTF("newActInst (mmkubernetes)\n");
1022 	pvals = nvlstGetParams(lst, &amp;actpblk, NULL);
1023 	if(pvals == NULL) {
1024 		LogError(0, RS_RET_MISSING_CNFPARAMS, "mmkubernetes: "
1025 			"error processing config parameters [action(...)]");
1026 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
1027 	}
1028 	if(Debug) {
1029 		dbgprintf("action param blk in mmkubernetes:\n");
1030 		cnfparamsPrint(&amp;actpblk, pvals);
1031 	}
1032 	CODE_STD_STRING_REQUESTnewActInst(1)
1033 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
1034 	CHKiRet(createInstance(&amp;pData));
1035 	pData-&gt;de_dot = loadModConf-&gt;de_dot;
1036 	pData-&gt;allowUnsignedCerts = loadModConf-&gt;allowUnsignedCerts;
1037 	pData-&gt;skipVerifyHost = loadModConf-&gt;skipVerifyHost;
1038 	pData-&gt;busyRetryInterval = loadModConf-&gt;busyRetryInterval;
1039 	pData-&gt;sslPartialChain = loadModConf-&gt;sslPartialChain;
1040 	pData-&gt;cacheEntryTTL = loadModConf-&gt;cacheEntryTTL;
1041 	pData-&gt;cacheExpireInterval = loadModConf-&gt;cacheExpireInterval;
1042 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
1043 		if(!pvals[i].bUsed) {
1044 			continue;
1045 		} else if(!strcmp(actpblk.descr[i].name, "kubernetesurl")) {
1046 			free(pData-&gt;kubernetesUrl);
1047 			pData-&gt;kubernetesUrl = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
1048 		} else if(!strcmp(actpblk.descr[i].name, "srcmetadatapath")) {
1049 			msgPropDescrDestruct(pData-&gt;srcMetadataDescr);
1050 			free(pData-&gt;srcMetadataDescr);
1051 			CHKmalloc(pData-&gt;srcMetadataDescr = malloc(sizeof(msgPropDescr_t)));
1052 			srcMetadataPath = es_str2cstr(pvals[i].val.d.estr, NULL);
1053 			CHKiRet(msgPropDescrFill(pData-&gt;srcMetadataDescr, (uchar *)srcMetadataPath,
1054 				strlen(srcMetadataPath)));
1055 		} else if(!strcmp(actpblk.descr[i].name, "dstmetadatapath")) {
1056 			free(pData-&gt;dstMetadataPath);
1057 			pData-&gt;dstMetadataPath = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
1058 		} else if(!strcmp(actpblk.descr[i].name, "tls.cacert")) {
1059 			free(pData-&gt;caCertFile);
1060 			pData-&gt;caCertFile = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
1061 			fp = fopen((const char*)pData-&gt;caCertFile, "r");
1062 			if(fp == NULL) {
1063 				rs_strerror_r(errno, errStr, sizeof(errStr));
1064 				iRet = RS_RET_NO_FILE_ACCESS;
1065 				LogError(0, iRet,
1066 						"error: certificate file %s couldn't be accessed: %s\n",
1067 						pData-&gt;caCertFile, errStr);
1068 				ABORT_FINALIZE(iRet);
1069 			} else {
1070 				fclose(fp);
1071 				fp = NULL;
1072 			}
1073 		} else if(!strcmp(actpblk.descr[i].name, "tls.mycert")) {
1074 			pData-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1075 			fp = fopen((const char*)pData-&gt;myCertFile, "r");
1076 			if(fp == NULL) {
1077 				rs_strerror_r(errno, errStr, sizeof(errStr));
1078 				iRet = RS_RET_NO_FILE_ACCESS;
1079 				LogError(0, iRet,
1080 						"error: 'tls.mycert' file %s couldn't be accessed: %s\n",
1081 						pData-&gt;myCertFile, errStr);
1082 			} else {
1083 				fclose(fp);
1084 				fp = NULL;
1085 			}
1086 		} else if(!strcmp(actpblk.descr[i].name, "tls.myprivkey")) {
1087 			pData-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1088 			fp = fopen((const char*)pData-&gt;myPrivKeyFile, "r");
1089 			if(fp == NULL) {
1090 				rs_strerror_r(errno, errStr, sizeof(errStr));
1091 				iRet = RS_RET_NO_FILE_ACCESS;
1092 				LogError(0, iRet,
1093 						"error: 'tls.myprivkey' file %s couldn't be accessed: %s\n",
1094 						pData-&gt;myPrivKeyFile, errStr);
1095 			} else {
1096 				fclose(fp);
1097 				fp = NULL;
1098 			}
1099 		} else if(!strcmp(actpblk.descr[i].name, "allowunsignedcerts")) {
1100 			pData-&gt;allowUnsignedCerts = pvals[i].val.d.n;
1101 		} else if(!strcmp(actpblk.descr[i].name, "skipverifyhost")) {
1102 			pData-&gt;skipVerifyHost = pvals[i].val.d.n;
1103 		} else if(!strcmp(actpblk.descr[i].name, "token")) {
1104 			free(pData-&gt;token);
1105 			pData-&gt;token = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
1106 		} else if(!strcmp(actpblk.descr[i].name, "tokenfile")) {
1107 			free(pData-&gt;tokenFile);
1108 			pData-&gt;tokenFile = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
1109 			fp = fopen((const char*)pData-&gt;tokenFile, "r");
1110 			if(fp == NULL) {
1111 				rs_strerror_r(errno, errStr, sizeof(errStr));
1112 				iRet = RS_RET_NO_FILE_ACCESS;
1113 				LogError(0, iRet,
1114 						"error: token file %s couldn't be accessed: %s\n",
1115 						pData-&gt;tokenFile, errStr);
1116 				ABORT_FINALIZE(iRet);
1117 			} else {
1118 				fclose(fp);
1119 				fp = NULL;
1120 			}
1121 		} else if(!strcmp(actpblk.descr[i].name, "annotation_match")) {
1122 			free_annotationmatch(&amp;pData-&gt;annotation_match);
1123 			if (RS_RET_OK != (iRet = init_annotationmatch(&amp;pData-&gt;annotation_match, pvals[i].val.d.ar)))
1124 				ABORT_FINALIZE(iRet);
1125 		} else if(!strcmp(actpblk.descr[i].name, "de_dot")) {
1126 			pData-&gt;de_dot = pvals[i].val.d.n;
1127 		} else if(!strcmp(actpblk.descr[i].name, "de_dot_separator")) {
1128 			free(pData-&gt;de_dot_separator);
1129 			pData-&gt;de_dot_separator = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
1130 #if HAVE_LOADSAMPLESFROMSTRING == 1
1131 		} else if(!strcmp(modpblk.descr[i].name, "filenamerules")) {
1132 			free(pData-&gt;fnRules);
1133 			CHKiRet((array_to_rules(pvals[i].val.d.ar, &amp;pData-&gt;fnRules)));
1134 #endif
1135 		} else if(!strcmp(modpblk.descr[i].name, "filenamerulebase")) {
1136 			free(pData-&gt;fnRulebase);
1137 			pData-&gt;fnRulebase = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
1138 			fp = fopen((const char*)pData-&gt;fnRulebase, "r");
1139 			if(fp == NULL) {
1140 				rs_strerror_r(errno, errStr, sizeof(errStr));
1141 				iRet = RS_RET_NO_FILE_ACCESS;
1142 				LogError(0, iRet,
1143 						"error: filenamerulebase file %s couldn't be accessed: %s\n",
1144 						pData-&gt;fnRulebase, errStr);
1145 				ABORT_FINALIZE(iRet);
1146 			} else {
1147 				fclose(fp);
1148 				fp = NULL;
1149 			}
1150 #if HAVE_LOADSAMPLESFROMSTRING == 1
1151 		} else if(!strcmp(modpblk.descr[i].name, "containerrules")) {
1152 			free(pData-&gt;contRules);
1153 			CHKiRet((array_to_rules(pvals[i].val.d.ar, &amp;pData-&gt;contRules)));
1154 #endif
1155 		} else if(!strcmp(modpblk.descr[i].name, "containerrulebase")) {
1156 			free(pData-&gt;contRulebase);
1157 			pData-&gt;contRulebase = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
1158 			fp = fopen((const char*)pData-&gt;contRulebase, "r");
1159 			if(fp == NULL) {
1160 				rs_strerror_r(errno, errStr, sizeof(errStr));
1161 				iRet = RS_RET_NO_FILE_ACCESS;
1162 				LogError(0, iRet,
1163 						"error: containerrulebase file %s couldn't be accessed: %s\n",
1164 						pData-&gt;contRulebase, errStr);
1165 				ABORT_FINALIZE(iRet);
1166 			} else {
1167 				fclose(fp);
1168 				fp = NULL;
1169 			}
1170 		} else if(!strcmp(actpblk.descr[i].name, "busyretryinterval")) {
1171 			pData-&gt;busyRetryInterval = pvals[i].val.d.n;
1172 		} else if(!strcmp(actpblk.descr[i].name, "sslpartialchain")) {
1173 #if defined(SUPPORT_SSL_PARTIAL_CHAIN)
1174 			pData-&gt;sslPartialChain = pvals[i].val.d.n;
1175 #else
1176 			LogMsg(0, RS_RET_VALUE_NOT_IN_THIS_MODE, LOG_INFO,
1177 					"sslpartialchain is only supported for OpenSSL\n");
1178 #endif
1179 		} else if(!strcmp(actpblk.descr[i].name, "cacheentryttl")) {
1180 			pData-&gt;cacheEntryTTL = pvals[i].val.d.n;
1181 		} else if(!strcmp(actpblk.descr[i].name, "cacheexpireinterval")) {
1182 			pData-&gt;cacheExpireInterval = pvals[i].val.d.n;
1183 		} else {
1184 			dbgprintf("mmkubernetes: program error, non-handled "
1185 				"param '%s' in action() block\n", actpblk.descr[i].name);
1186 		}
1187 	}
1188 #if HAVE_LOADSAMPLESFROMSTRING == 1
1189 	if (pData-&gt;fnRules &amp;&amp; pData-&gt;fnRulebase) {
1190 		LogError(0, RS_RET_CONFIG_ERROR,
1191 		    "mmkubernetes: only 1 of filenamerules or filenamerulebase may be used");
1192 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
1193 	}
1194 	if (pData-&gt;contRules &amp;&amp; pData-&gt;contRulebase) {
1195 		LogError(0, RS_RET_CONFIG_ERROR,
1196 			"mmkubernetes: only 1 of containerrules or containerrulebase may be used");
1197 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
1198 	}
1199 #endif
1200 	CHKiRet(set_lnctx(&amp;pData-&gt;fnCtxln, pData-&gt;fnRules, pData-&gt;fnRulebase,
1201 			loadModConf-&gt;fnRules, loadModConf-&gt;fnRulebase));
1202 	CHKiRet(set_lnctx(&amp;pData-&gt;contCtxln, pData-&gt;contRules, pData-&gt;contRulebase,
1203 			loadModConf-&gt;contRules, loadModConf-&gt;contRulebase));
1204 	if ((pData-&gt;cacheExpireInterval &gt; -1)) {
1205 		if ((pData-&gt;cacheEntryTTL &lt; 0)) {
1206 			LogError(0, RS_RET_CONFIG_ERROR,
1207 					"mmkubernetes: cacheentryttl value [%d] is invalid - "
1208 					"value must be 0 or greater",
1209 					pData-&gt;cacheEntryTTL);
1210 			ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
1211 		}
1212 	}
1213 	if(pData-&gt;kubernetesUrl == NULL) {
1214 		if(loadModConf-&gt;kubernetesUrl == NULL) {
1215 			CHKmalloc(pData-&gt;kubernetesUrl = (uchar *) strdup(DFLT_KUBERNETES_URL));
1216 		} else {
1217 			CHKmalloc(pData-&gt;kubernetesUrl = (uchar *) strdup((char *) loadModConf-&gt;kubernetesUrl));
1218 		}
1219 	}
1220 	if(pData-&gt;srcMetadataDescr == NULL) {
1221 		CHKmalloc(pData-&gt;srcMetadataDescr = malloc(sizeof(msgPropDescr_t)));
1222 		CHKiRet(msgPropDescrFill(pData-&gt;srcMetadataDescr, loadModConf-&gt;srcMetadataPath,
1223 			strlen((char *)loadModConf-&gt;srcMetadataPath)));
1224 	}
1225 	if(pData-&gt;dstMetadataPath == NULL)
1226 		pData-&gt;dstMetadataPath = (uchar *) strdup((char *) loadModConf-&gt;dstMetadataPath);
1227 	if(pData-&gt;caCertFile == NULL &amp;&amp; loadModConf-&gt;caCertFile)
1228 		pData-&gt;caCertFile = (uchar *) strdup((char *) loadModConf-&gt;caCertFile);
1229 	if(pData-&gt;myCertFile == NULL &amp;&amp; loadModConf-&gt;myCertFile)
1230 		pData-&gt;myCertFile = (uchar *) strdup((char *) loadModConf-&gt;myCertFile);
1231 	if(pData-&gt;myPrivKeyFile == NULL &amp;&amp; loadModConf-&gt;myPrivKeyFile)
1232 		pData-&gt;myPrivKeyFile = (uchar *) strdup((char *) loadModConf-&gt;myPrivKeyFile);
1233 	if(pData-&gt;token == NULL &amp;&amp; loadModConf-&gt;token)
1234 		pData-&gt;token = (uchar *) strdup((char *) loadModConf-&gt;token);
1235 	if(pData-&gt;tokenFile == NULL &amp;&amp; loadModConf-&gt;tokenFile)
1236 		pData-&gt;tokenFile = (uchar *) strdup((char *) loadModConf-&gt;tokenFile);
1237 	if(pData-&gt;de_dot_separator == NULL &amp;&amp; loadModConf-&gt;de_dot_separator)
1238 		pData-&gt;de_dot_separator = (uchar *) strdup((char *) loadModConf-&gt;de_dot_separator);
1239 	if((pData-&gt;annotation_match.nmemb == 0) &amp;&amp; (loadModConf-&gt;annotation_match.nmemb &gt; 0))
1240 		copy_annotationmatch(&amp;loadModConf-&gt;annotation_match, &amp;pData-&gt;annotation_match);
1241 	if(pData-&gt;de_dot_separator)
1242 		pData-&gt;de_dot_separator_len = strlen((const char *)pData-&gt;de_dot_separator);
1243 	CHKmalloc(pData-&gt;contNameDescr = malloc(sizeof(msgPropDescr_t)));
1244 	CHKiRet(msgPropDescrFill(pData-&gt;contNameDescr, (uchar*) DFLT_CONTAINER_NAME,
1245 			strlen(DFLT_CONTAINER_NAME)));
1246 	CHKmalloc(pData-&gt;contIdFullDescr = malloc(sizeof(msgPropDescr_t)));
1247 	CHKiRet(msgPropDescrFill(pData-&gt;contIdFullDescr, (uchar*) DFLT_CONTAINER_ID_FULL,
1248 			strlen(DFLT_CONTAINER_NAME)));
1249 	for(i = 0; caches[i] != NULL; i++) {
1250 		if(!strcmp((char *) pData-&gt;kubernetesUrl, (char *) caches[i]-&gt;kbUrl))
1251 			break;
1252 	}
1253 	if(caches[i] != NULL) {
1254 		pData-&gt;cache = caches[i];
1255 	} else {
1256 		CHKmalloc(pData-&gt;cache = cacheNew(pData));
1257 		struct cache_s **new_caches = realloc(caches, (i + 2) * sizeof(struct cache_s *));
1258 		CHKmalloc(new_caches);
1259 		caches = new_caches;
1260 		caches[i] = pData-&gt;cache;
1261 		caches[i + 1] = NULL;
1262 	}
1263 CODE_STD_FINALIZERnewActInst
1264 	if(pvals != NULL)
1265 		cnfparamvalsDestruct(pvals, &amp;actpblk);
1266 	if(fp)
1267 		fclose(fp);
1268 	free(rxstr);
1269 	free(srcMetadataPath);
1270 ENDnewActInst
1271 BEGINparseSelectorAct
1272 CODESTARTparseSelectorAct
1273 CODE_STD_STRING_REQUESTparseSelectorAct(1)
1274 	if(strncmp((char *) p, ":mmkubernetes:", sizeof(":mmkubernetes:") - 1)) {
1275 		LogError(0, RS_RET_LEGA_ACT_NOT_SUPPORTED,
1276 			"mmkubernetes supports only v6+ config format, use: "
1277 			"action(type=\"mmkubernetes\" ...)");
1278 	}
1279 	ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
1280 CODE_STD_FINALIZERparseSelectorAct
1281 ENDparseSelectorAct
1282 BEGINendCnfLoad
1283 CODESTARTendCnfLoad
1284 ENDendCnfLoad
1285 BEGINcheckCnf
1286 CODESTARTcheckCnf
1287 ENDcheckCnf
1288 BEGINactivateCnf
1289 CODESTARTactivateCnf
1290 	runModConf = pModConf;
1291 ENDactivateCnf
1292 BEGINfreeCnf
1293 CODESTARTfreeCnf
1294 	int i;
1295 	free(pModConf-&gt;kubernetesUrl);
1296 	free(pModConf-&gt;srcMetadataPath);
1297 	free(pModConf-&gt;dstMetadataPath);
1298 	free(pModConf-&gt;caCertFile);
1299 	free(pModConf-&gt;myCertFile);
1300 	free(pModConf-&gt;myPrivKeyFile);
1301 	free(pModConf-&gt;token);
1302 	free(pModConf-&gt;tokenFile);
1303 	free(pModConf-&gt;de_dot_separator);
1304 	free(pModConf-&gt;fnRules);
1305 	free(pModConf-&gt;fnRulebase);
1306 	free(pModConf-&gt;contRules);
1307 	free(pModConf-&gt;contRulebase);
1308 	free_annotationmatch(&amp;pModConf-&gt;annotation_match);
1309 	for(i = 0; caches[i] != NULL; i++) {
1310 		dbgprintf("mmkubernetes: freeing cache [%d] mdht [%p] nsht [%p]\n",
1311 				i, caches[i]-&gt;mdHt, caches[i]-&gt;nsHt);
1312 		cacheFree(caches[i]);
1313 	}
1314 	free(caches);
1315 ENDfreeCnf
1316 BEGINdbgPrintInstInfo
1317 CODESTARTdbgPrintInstInfo
1318 	dbgprintf("mmkubernetes\n");
1319 	dbgprintf("\tkubernetesUrl='%s'\n", pData-&gt;kubernetesUrl);
1320 	dbgprintf("\tsrcMetadataPath='%s'\n", pData-&gt;srcMetadataDescr-&gt;name);
1321 	dbgprintf("\tdstMetadataPath='%s'\n", pData-&gt;dstMetadataPath);
1322 	dbgprintf("\ttls.cacert='%s'\n", pData-&gt;caCertFile);
1323 	dbgprintf("\ttls.mycert='%s'\n", pData-&gt;myCertFile);
1324 	dbgprintf("\ttls.myprivkey='%s'\n", pData-&gt;myPrivKeyFile);
1325 	dbgprintf("\tallowUnsignedCerts='%d'\n", pData-&gt;allowUnsignedCerts);
1326 	dbgprintf("\tskipVerifyHost='%d'\n", pData-&gt;skipVerifyHost);
1327 	dbgprintf("\ttoken='%s'\n", pData-&gt;token);
1328 	dbgprintf("\ttokenFile='%s'\n", pData-&gt;tokenFile);
1329 	dbgprintf("\tde_dot='%d'\n", pData-&gt;de_dot);
1330 	dbgprintf("\tde_dot_separator='%s'\n", pData-&gt;de_dot_separator);
1331 	dbgprintf("\tfilenamerulebase='%s'\n", pData-&gt;fnRulebase);
1332 	dbgprintf("\tcontainerrulebase='%s'\n", pData-&gt;contRulebase);
1333 #if HAVE_LOADSAMPLESFROMSTRING == 1
1334 	dbgprintf("\tfilenamerules='%s'\n", pData-&gt;fnRules);
1335 	dbgprintf("\tcontainerrules='%s'\n", pData-&gt;contRules);
1336 #endif
1337 	dbgprintf("\tbusyretryinterval='%d'\n", pData-&gt;busyRetryInterval);
1338 	dbgprintf("\tcacheentryttl='%d'\n", pData-&gt;cacheEntryTTL);
1339 	dbgprintf("\tcacheexpireinterval='%d'\n", pData-&gt;cacheExpireInterval);
1340 ENDdbgPrintInstInfo
1341 BEGINtryResume
1342 CODESTARTtryResume
1343 ENDtryResume
1344 static rsRetVal
1345 extractMsgMetadata(smsg_t *pMsg, instanceData *pData, struct json_object **json)
1346 {
1347 	DEFiRet;
1348 	uchar *filename = NULL, *container_name = NULL, *container_id_full = NULL;
1349 	rs_size_t fnLen, container_name_len, container_id_full_len;
1350 	unsigned short freeFn = 0, free_container_name = 0, free_container_id_full = 0;
1351 	int lnret;
1352 	struct json_object *cnid = NULL;
1353 	if (!json)
1354 		FINALIZE;
1355 	*json = NULL;
1356 	container_name = MsgGetProp(pMsg, NULL, pData-&gt;contNameDescr,
1357 				    &amp;container_name_len, &amp;free_container_name, NULL);
1358 	container_id_full = MsgGetProp(
1359 		pMsg, NULL, pData-&gt;contIdFullDescr, &amp;container_id_full_len, &amp;free_container_id_full, NULL);
1360 	if (container_name &amp;&amp; container_id_full &amp;&amp; container_name_len &amp;&amp; container_id_full_len) {
1361 		dbgprintf("mmkubernetes: CONTAINER_NAME: '%s'  CONTAINER_ID_FULL: '%s'.\n",
1362 			  container_name, container_id_full);
1363 		if ((lnret = ln_normalize(pData-&gt;contCtxln, (char*)container_name,
1364 					  container_name_len, json))) {
1365 			if (LN_WRONGPARSER != lnret) {
1366 				LogMsg(0, RS_RET_ERR, LOG_ERR,
1367 					"mmkubernetes: error parsing container_name [%s]: [%d]",
1368 					container_name, lnret);
1369 				ABORT_FINALIZE(RS_RET_ERR);
1370 			}
1371 		} else if (fjson_object_object_get_ex(*json, "pod_name", NULL) &amp;&amp;
1372 			fjson_object_object_get_ex(*json, "namespace_name", NULL) &amp;&amp;
1373 			fjson_object_object_get_ex(*json, "container_name", NULL)) {
1374 			json_object_object_add(*json, "container_id",
1375 				json_object_new_string_len((const char *)container_id_full,
1376 							   container_id_full_len));
1377 			ABORT_FINALIZE(RS_RET_OK);
1378 		}
1379 	}
1380 	filename = MsgGetProp(pMsg, NULL, pData-&gt;srcMetadataDescr, &amp;fnLen, &amp;freeFn, NULL);
1381 	if((filename == NULL) || (fnLen == 0))
1382 		ABORT_FINALIZE(RS_RET_NOT_FOUND);
1383 	dbgprintf("mmkubernetes: filename: '%s' len %d.\n", filename, fnLen);
1384 	if ((lnret = ln_normalize(pData-&gt;fnCtxln, (char*)filename, fnLen, json))) {
1385 		if (LN_WRONGPARSER != lnret) {
1386 			LogMsg(0, RS_RET_ERR, LOG_ERR,
1387 				"mmkubernetes: error parsing container_name [%s]: [%d]",
1388 				filename, lnret);
1389 			ABORT_FINALIZE(RS_RET_ERR);
1390 		} else {
1391 			ABORT_FINALIZE(RS_RET_NOT_FOUND);
1392 		}
1393 	}
1394 	if (fjson_object_object_get_ex(*json, "pod_name", NULL) &amp;&amp;
1395 		fjson_object_object_get_ex(*json, "namespace_name", NULL) &amp;&amp;
1396 		fjson_object_object_get_ex(*json, "container_name_and_id", &amp;cnid)) {
1397 		const char *container_name_and_id = json_object_get_string(cnid);
1398 		const char *last_dash = NULL;
1399 		if (container_name_and_id &amp;&amp; (last_dash = strrchr(container_name_and_id, '-')) &amp;&amp;
1400 			*(last_dash + 1) &amp;&amp; (last_dash != container_name_and_id)) {
1401 			json_object_object_add(*json, "container_name",
1402 				json_object_new_string_len(container_name_and_id,
1403 							   (int)(last_dash-container_name_and_id)));
1404 			json_object_object_add(*json, "container_id",
1405 					json_object_new_string(last_dash + 1));
1406 			ABORT_FINALIZE(RS_RET_OK);
1407 		}
1408 	}
1409 	ABORT_FINALIZE(RS_RET_NOT_FOUND);
1410 finalize_it:
1411 	if(freeFn)
1412 		free(filename);
1413 	if (free_container_name)
1414 		free(container_name);
1415 	if (free_container_id_full)
1416 		free(container_id_full);
1417 	if (iRet != RS_RET_OK) {
1418 		json_object_put(*json);
1419 		*json = NULL;
1420 	}
1421 	RETiRet;
1422 }
1423 static rsRetVal
1424 queryKB(wrkrInstanceData_t *pWrkrData, char *url, time_t now, struct json_object **rply)
1425 {
1426 	DEFiRet;
1427 	CURLcode ccode;
1428 	struct json_tokener *jt = NULL;
1429 	struct json_object *jo;
1430 	long resp_code = 400;
1431 	if (pWrkrData-&gt;pData-&gt;cache-&gt;lastBusyTime) {
1432 		now -= pWrkrData-&gt;pData-&gt;cache-&gt;lastBusyTime;
1433 		if (now &lt; pWrkrData-&gt;pData-&gt;busyRetryInterval) {
1434 			LogMsg(0, RS_RET_RETRY, LOG_DEBUG,
1435 				"mmkubernetes: Waited [%ld] of [%d] seconds for the requested url [%s]\n",
1436 				now, pWrkrData-&gt;pData-&gt;busyRetryInterval, url);
1437 			ABORT_FINALIZE(RS_RET_RETRY);
1438 		} else {
1439 			LogMsg(0, RS_RET_OK, LOG_DEBUG,
1440 				"mmkubernetes: Cleared busy status after [%d] seconds - "
1441 				"will retry the requested url [%s]\n",
1442 				pWrkrData-&gt;pData-&gt;busyRetryInterval, url);
1443 			pWrkrData-&gt;pData-&gt;cache-&gt;lastBusyTime = 0;
1444 		}
1445 	}
1446 	ccode = curl_easy_setopt(pWrkrData-&gt;curlCtx, CURLOPT_URL, url);
1447 	if(ccode != CURLE_OK)
1448 		ABORT_FINALIZE(RS_RET_ERR);
1449 	if(CURLE_OK != (ccode = curl_easy_perform(pWrkrData-&gt;curlCtx))) {
1450 		LogMsg(0, RS_RET_ERR, LOG_ERR,
1451 			      "mmkubernetes: failed to connect to [%s] - %d:%s\n",
1452 			      url, ccode, curl_easy_strerror(ccode));
1453 <a name="3"></a>		ABORT_FINALIZE(RS_RET_SUSPENDED);
1454 	}
1455 	if(CURLE_OK != (ccode = curl_easy_getinfo(pWrkrData-&gt;curlCtx,
1456 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>					CURLINFO_RESPONSE_CODE, &amp;resp_code))) {
1457 		LogMsg(0, RS_RET_ERR, LOG_ERR,
1458 			      "mmkubernetes: could not get response code from query to [%s] - %d:%s\n",
1459 			      url, ccode, curl_easy_strerror(ccode));
1460 		ABORT_FINALIZE(RS_RET_ERR);
1461 	}
1462 	if(resp_code == 401) {
1463 		LogMsg(0, RS_RET_ERR, LOG_ERR,
1464 			      "mmkubernetes: Unauthorized: not allowed to view url - "
1465 			      "check token/auth credentials [%s]\n",
1466 			      url);
1467 		ABORT_FINALIZE(RS_RET_ERR);
1468 	}
1469 	if(resp_code == 403) {
1470 		LogMsg(0, RS_RET_ERR, LOG_ERR,
1471 			      "mmkubernetes: Forbidden: no access - "
1472 			      "check permissions to view url [%s]\n",
1473 			      url);
1474 		ABORT_FINALIZE(RS_RET_ERR);
1475 	}
1476 	if(resp_code == 404) {
1477 		LogMsg(0, RS_RET_NOT_FOUND, LOG_INFO,
1478 			      "mmkubernetes: Not Found: the resource does not exist at url [%s]\n",
1479 			      url);
1480 		ABORT_FINALIZE(RS_RET_NOT_FOUND);
1481 	}
1482 	if(resp_code == 429) {</b></font>
1483 		if (pWrkrData-&gt;pData-&gt;busyRetryInterval) {
1484 			pWrkrData-&gt;pData-&gt;cache-&gt;lastBusyTime = now;
1485 		}
1486 		LogMsg(0, RS_RET_RETRY, LOG_INFO,
1487 			      "mmkubernetes: Too Many Requests: the server is too heavily loaded "
1488 			      "to provide the data for the requested url [%s]\n",
1489 			      url);
1490 		ABORT_FINALIZE(RS_RET_RETRY);
1491 	}
1492 	if(resp_code != 200) {
1493 		LogMsg(0, RS_RET_ERR, LOG_ERR,
1494 			      "mmkubernetes: server returned unexpected code [%ld] for url [%s]\n",
1495 			      resp_code, url);
1496 		ABORT_FINALIZE(RS_RET_ERR);
1497 	}
1498 	jt = json_tokener_new();
1499 	json_tokener_reset(jt);
1500 	jo = json_tokener_parse_ex(jt, pWrkrData-&gt;curlRply, pWrkrData-&gt;curlRplyLen);
1501 	json_tokener_free(jt);
1502 	if(!json_object_is_type(jo, json_type_object)) {
1503 		json_object_put(jo);
1504 		jo = NULL;
1505 		LogMsg(0, RS_RET_JSON_PARSE_ERR, LOG_INFO,
1506 			      "mmkubernetes: unable to parse string as JSON:[%.*s]\n",
1507 			      (int)pWrkrData-&gt;curlRplyLen, pWrkrData-&gt;curlRply);
1508 		ABORT_FINALIZE(RS_RET_JSON_PARSE_ERR);
1509 	}
1510 	dbgprintf("mmkubernetes: queryKB reply:\n%s\n",
1511 		json_object_to_json_string_ext(jo, JSON_C_TO_STRING_PRETTY));
1512 	*rply = jo;
1513 finalize_it:
1514 	if(pWrkrData-&gt;curlRply != NULL) {
1515 		free(pWrkrData-&gt;curlRply);
1516 		pWrkrData-&gt;curlRply = NULL;
1517 		pWrkrData-&gt;curlRplyLen = 0;
1518 	}
1519 	RETiRet;
1520 }
1521 #if defined(BEGINdoAction_NoStrings)
1522 BEGINdoAction_NoStrings
1523 	smsg_t **ppMsg = (smsg_t **) pMsgData;
1524 	smsg_t *pMsg = ppMsg[0];
1525 #else
1526 BEGINdoAction
1527 	smsg_t *pMsg = (smsg_t*) ppString[0];
1528 #endif
1529 	const char *podName = NULL, *ns = NULL, *containerName = NULL,
1530 		*containerID = NULL;
1531 	char *mdKey = NULL;
1532 	struct json_object *jMetadata = NULL, *jMetadataCopy = NULL, *jMsgMeta = NULL,
1533 			*jo = NULL;
1534 	int add_pod_metadata = 1;
1535 	time_t now;
1536 CODESTARTdoAction
1537 	CHKiRet_Hdlr(extractMsgMetadata(pMsg, pWrkrData-&gt;pData, &amp;jMsgMeta)) {
1538 		ABORT_FINALIZE((iRet == RS_RET_NOT_FOUND) ? RS_RET_OK : iRet);
1539 	}
1540 	datetime.GetTime(&amp;now);
1541 	STATSCOUNTER_INC(pWrkrData-&gt;k8sRecordSeen, pWrkrData-&gt;mutK8sRecordSeen);
1542 	if (fjson_object_object_get_ex(jMsgMeta, "pod_name", &amp;jo))
1543 		podName = json_object_get_string(jo);
1544 	if (fjson_object_object_get_ex(jMsgMeta, "namespace_name", &amp;jo))
1545 		ns = json_object_get_string(jo);
1546 	if (fjson_object_object_get_ex(jMsgMeta, "container_name", &amp;jo))
1547 		containerName = json_object_get_string(jo);
1548 	if (fjson_object_object_get_ex(jMsgMeta, "container_id", &amp;jo))
1549 		containerID = json_object_get_string(jo);
1550 	assert(podName != NULL);
1551 	assert(ns != NULL);
1552 	assert(containerName != NULL);
1553 	assert(containerID != NULL);
1554 	dbgprintf("mmkubernetes:\n  podName: '%s'\n  namespace: '%s'\n  containerName: '%s'\n"
1555 		"  containerID: '%s'\n", podName, ns, containerName, containerID);
1556 	if ((-1 == asprintf(&amp;mdKey, "%s_%s_%s", ns, podName, containerName)) ||
1557 		(!mdKey)) {
1558 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
1559 	}
1560 	pthread_mutex_lock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
1561 	jMetadata = cache_entry_get_md(pWrkrData, mdKey, now);
1562 	if(jMetadata == NULL) {
1563 		char *url = NULL;
1564 		struct json_object *jReply = NULL, *jo2 = NULL, *jNsMeta = NULL, *jPodData = NULL;
1565 		jNsMeta = cache_entry_get_nsmd(pWrkrData, (const char *)ns, now);
1566 		if(jNsMeta == NULL) {
1567 			if ((-1 == asprintf(&amp;url, "%s/api/v1/namespaces/%s",
1568 				 (char *) pWrkrData-&gt;pData-&gt;kubernetesUrl, ns)) ||
1569 				(!url)) {
1570 				pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
1571 				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
1572 			}
1573 			iRet = queryKB(pWrkrData, url, now, &amp;jReply);
1574 			free(url);
1575 			if (iRet == RS_RET_NOT_FOUND) {
1576 				jNsMeta = json_object_new_object();
1577 				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataNotFound,
1578 						 pWrkrData-&gt;mutNamespaceMetadataNotFound);
1579 			} else if (iRet == RS_RET_RETRY) {
1580 				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataBusy,
1581 						 pWrkrData-&gt;mutNamespaceMetadataBusy);
1582 				if (0 == pWrkrData-&gt;pData-&gt;busyRetryInterval) {
1583 					pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
1584 					ABORT_FINALIZE(RS_RET_ERR);
1585 				}
1586 				add_pod_metadata = 0; 			} else if (iRet != RS_RET_OK) {
1587 				jNsMeta = json_object_new_object();
1588 				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataError,
1589 						 pWrkrData-&gt;mutNamespaceMetadataError);
1590 			} else if (fjson_object_object_get_ex(jReply, "metadata", &amp;jNsMeta)) {
1591 				jNsMeta = json_object_get(jNsMeta);
1592 				parse_labels_annotations(jNsMeta, &amp;pWrkrData-&gt;pData-&gt;annotation_match,
1593 					pWrkrData-&gt;pData-&gt;de_dot,
1594 					(const char *)pWrkrData-&gt;pData-&gt;de_dot_separator,
1595 					pWrkrData-&gt;pData-&gt;de_dot_separator_len);
1596 				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataSuccess,
1597 						 pWrkrData-&gt;mutNamespaceMetadataSuccess);
1598 			} else {
1599 				LogMsg(0, RS_RET_ERR, LOG_INFO,
1600 					      "mmkubernetes: namespace [%s] has no metadata!\n", ns);
1601 				jNsMeta = json_object_new_object();
1602 				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataSuccess,
1603 						 pWrkrData-&gt;mutNamespaceMetadataSuccess);
1604 			}
1605 			if(jNsMeta) {
1606 				if ((iRet = cache_entry_add_nsmd(pWrkrData, ns, jNsMeta, now))) {
1607 					ABORT_FINALIZE(iRet);
1608 				}
1609 			}
1610 			json_object_put(jReply);
1611 			jReply = NULL;
1612 		}
1613 		if ((-1 == asprintf(&amp;url, "%s/api/v1/namespaces/%s/pods/%s",
1614 			 (char *) pWrkrData-&gt;pData-&gt;kubernetesUrl, ns, podName)) ||
1615 			(!url)) {
1616 			pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
1617 			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
1618 		}
1619 		iRet = queryKB(pWrkrData, url, now, &amp;jReply);
1620 		free(url);
1621 		if (iRet == RS_RET_NOT_FOUND) {
1622 			iRet = RS_RET_OK;
1623 			STATSCOUNTER_INC(pWrkrData-&gt;podMetadataNotFound, pWrkrData-&gt;mutPodMetadataNotFound);
1624 		} else if (iRet == RS_RET_RETRY) {
1625 			STATSCOUNTER_INC(pWrkrData-&gt;podMetadataBusy, pWrkrData-&gt;mutPodMetadataBusy);
1626 			if (0 == pWrkrData-&gt;pData-&gt;busyRetryInterval) {
1627 				pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
1628 				ABORT_FINALIZE(RS_RET_ERR);
1629 			}
1630 			add_pod_metadata = 0; 			iRet = RS_RET_OK;
1631 		} else if(iRet != RS_RET_OK) {
1632 			iRet = RS_RET_OK;
1633 			STATSCOUNTER_INC(pWrkrData-&gt;podMetadataError, pWrkrData-&gt;mutPodMetadataError);
1634 		} else {
1635 			STATSCOUNTER_INC(pWrkrData-&gt;podMetadataSuccess, pWrkrData-&gt;mutPodMetadataSuccess);
1636 		}
1637 		jo = json_object_new_object();
1638 		if(jNsMeta &amp;&amp; fjson_object_object_get_ex(jNsMeta, "uid", &amp;jo2))
1639 			json_object_object_add(jo, "namespace_id", json_object_get(jo2));
1640 		if(jNsMeta &amp;&amp; fjson_object_object_get_ex(jNsMeta, "labels", &amp;jo2))
1641 			json_object_object_add(jo, "namespace_labels", json_object_get(jo2));
1642 		if(jNsMeta &amp;&amp; fjson_object_object_get_ex(jNsMeta, "annotations", &amp;jo2))
1643 			json_object_object_add(jo, "namespace_annotations", json_object_get(jo2));
1644 		if(jNsMeta &amp;&amp; fjson_object_object_get_ex(jNsMeta, "creationTimestamp", &amp;jo2))
1645 			json_object_object_add(jo, "creation_timestamp", json_object_get(jo2));
1646 		if(fjson_object_object_get_ex(jReply, "metadata", &amp;jPodData)) {
1647 			if(fjson_object_object_get_ex(jPodData, "uid", &amp;jo2))
1648 				json_object_object_add(jo, "pod_id", json_object_get(jo2));
1649 			parse_labels_annotations(jPodData, &amp;pWrkrData-&gt;pData-&gt;annotation_match,
1650 				pWrkrData-&gt;pData-&gt;de_dot,
1651 				(const char *)pWrkrData-&gt;pData-&gt;de_dot_separator,
1652 				pWrkrData-&gt;pData-&gt;de_dot_separator_len);
1653 			if(fjson_object_object_get_ex(jPodData, "annotations", &amp;jo2))
1654 				json_object_object_add(jo, "annotations", json_object_get(jo2));
1655 			if(fjson_object_object_get_ex(jPodData, "labels", &amp;jo2))
1656 				json_object_object_add(jo, "labels", json_object_get(jo2));
1657 		}
1658 		if(fjson_object_object_get_ex(jReply, "spec", &amp;jPodData)) {
1659 			if(fjson_object_object_get_ex(jPodData, "nodeName", &amp;jo2)) {
1660 				json_object_object_add(jo, "host", json_object_get(jo2));
1661 			}
1662 		}
1663 		json_object_put(jReply);
1664 		jReply = NULL;
1665 		if (fjson_object_object_get_ex(jMsgMeta, "pod_name", &amp;jo2))
1666 			json_object_object_add(jo, "pod_name", json_object_get(jo2));
1667 		if (fjson_object_object_get_ex(jMsgMeta, "namespace_name", &amp;jo2))
1668 			json_object_object_add(jo, "namespace_name", json_object_get(jo2));
1669 		if (fjson_object_object_get_ex(jMsgMeta, "container_name", &amp;jo2))
1670 			json_object_object_add(jo, "container_name", json_object_get(jo2));
1671 		json_object_object_add(jo, "master_url",
1672 			json_object_new_string((const char *)pWrkrData-&gt;pData-&gt;kubernetesUrl));
1673 		jMetadata = json_object_new_object();
1674 		json_object_object_add(jMetadata, "kubernetes", jo);
1675 		jo = json_object_new_object();
1676 		if (fjson_object_object_get_ex(jMsgMeta, "container_id", &amp;jo2))
1677 			json_object_object_add(jo, "container_id", json_object_get(jo2));
1678 		json_object_object_add(jMetadata, "docker", jo);
1679 		if (add_pod_metadata) {
1680 			if ((iRet = cache_entry_add_md(pWrkrData, mdKey, jMetadata, now)))
1681 				ABORT_FINALIZE(iRet);
1682 			mdKey = NULL;
1683 		}
1684 	}
1685 	jMetadataCopy = json_tokener_parse(json_object_get_string(jMetadata));
1686 	if (!add_pod_metadata) {
1687 		json_object_put(jMetadata);
1688 		jMetadata = NULL;
1689 	}
1690 	pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
1691 	msgAddJSON(pMsg, (uchar *) pWrkrData-&gt;pData-&gt;dstMetadataPath + 1, jMetadataCopy, 0, 0);
1692 finalize_it:
1693 	json_object_put(jMsgMeta);
1694 	free(mdKey);
1695 ENDdoAction
1696 BEGINisCompatibleWithFeature
1697 CODESTARTisCompatibleWithFeature
1698 ENDisCompatibleWithFeature
1699 BEGINmodExit
1700 CODESTARTmodExit
1701 	curl_global_cleanup();
1702 	objRelease(datetime, CORE_COMPONENT);
1703 	objRelease(regexp, LM_REGEXP_FILENAME);
1704 	objRelease(statsobj, CORE_COMPONENT);
1705 ENDmodExit
1706 BEGINqueryEtryPt
1707 CODESTARTqueryEtryPt
1708 CODEqueryEtryPt_STD_OMOD_QUERIES
1709 CODEqueryEtryPt_STD_OMOD8_QUERIES
1710 CODEqueryEtryPt_STD_CONF2_QUERIES
1711 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
1712 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
1713 ENDqueryEtryPt
1714 BEGINmodInit()
1715 CODESTARTmodInit
1716 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
1717 	DBGPRINTF("mmkubernetes: module compiled with rsyslog version %s.\n", VERSION);
1718 	CHKiRet(objUse(statsobj, CORE_COMPONENT));
1719 	CHKiRet(objUse(regexp, LM_REGEXP_FILENAME));
1720 	CHKiRet(objUse(datetime, CORE_COMPONENT));
1721 	curl_global_init(CURL_GLOBAL_ALL);
1722 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
