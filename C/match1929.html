<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for imdocker.c & mmkubernetes.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for imdocker.c & mmkubernetes.c
      </h3>
      <h1 align="center">
        6.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>imdocker.c (6.7867036%)<TH>mmkubernetes.c (5.4384017%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1929-0.html#0',2,'match1929-1.html#0',3)" NAME="0">(262-281)<TD><A HREF="javascript:ZweiFrames('match1929-0.html#0',2,'match1929-1.html#0',3)" NAME="0">(231-253)</A><TD ALIGN=center><FONT COLOR="#ff0000">32</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1929-0.html#1',2,'match1929-1.html#1',3)" NAME="1">(897-904)<TD><A HREF="javascript:ZweiFrames('match1929-0.html#1',2,'match1929-1.html#1',3)" NAME="1">(589-602)</A><TD ALIGN=center><FONT COLOR="#b70000">23</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match1929-0.html#2',2,'match1929-1.html#2',3)" NAME="2">(1486-1506)<TD><A HREF="javascript:ZweiFrames('match1929-0.html#2',2,'match1929-1.html#2',3)" NAME="2">(712-724)</A><TD ALIGN=center><FONT COLOR="#870000">17</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match1929-0.html#3',2,'match1929-1.html#3',3)" NAME="3">(978-990)<TD><A HREF="javascript:ZweiFrames('match1929-0.html#3',2,'match1929-1.html#3',3)" NAME="3">(1748-1774)</A><TD ALIGN=center><FONT COLOR="#670000">13</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match1929-0.html#4',2,'match1929-1.html#4',3)" NAME="4">(862-867)<TD><A HREF="javascript:ZweiFrames('match1929-0.html#4',2,'match1929-1.html#4',3)" NAME="4">(646-652)</A><TD ALIGN=center><FONT COLOR="#670000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>imdocker.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* imdocker.c
 * This is an implementation of the docker container log input module. It uses the
 * Docker API in order to stream all container logs available on a host. Will also
 * update relevant container metadata.
 *
 * Copyright (C) 2018, 2019 the rsyslog project.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifdef __sun
#define _XPG4_2
#endif
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;curl/curl.h&gt;
#include &lt;json.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdbool.h&gt;
#include &quot;cfsysline.h&quot;  /* access to config file objects */
#include &quot;unicode-helper.h&quot;
#include &quot;module-template.h&quot;
#include &quot;srUtils.h&quot;    /* some utility functions */
#include &quot;errmsg.h&quot;
#include &quot;net.h&quot;
#include &quot;glbl.h&quot;
#include &quot;msg.h&quot;
#include &quot;parser.h&quot;
#include &quot;prop.h&quot;
#include &quot;debug.h&quot;
#include &quot;statsobj.h&quot;
#include &quot;datetime.h&quot;
#include &quot;ratelimit.h&quot;
#include &quot;hashtable.h&quot;
#include &quot;hashtable_itr.h&quot;

#if !defined(_AIX)
#pragma GCC diagnostic ignored &quot;-Wswitch-enum&quot;
#endif

MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;imdocker&quot;)

extern int Debug;

#define USE_MULTI_LINE
#undef ENABLE_DEBUG_BYTE_BUFFER

/* defines */
#define DOCKER_TAG_NAME                     &quot;docker:&quot;

#define DOCKER_CONTAINER_ID_PARSE_NAME      &quot;Id&quot;
#define DOCKER_CONTAINER_NAMES_PARSE_NAME   &quot;Names&quot;
#define DOCKER_CONTAINER_IMAGEID_PARSE_NAME &quot;ImageID&quot;
#define DOCKER_CONTAINER_CREATED_PARSE_NAME &quot;Created&quot;
#define DOCKER_CONTAINER_LABELS_PARSE_NAME  &quot;Labels&quot;

/* label defines */
#define DOCKER_CONTAINER_LABEL_KEY_STARTREGEX &quot;imdocker.startregex&quot;

/* DEFAULT VALUES */
#define DFLT_pollingInterval   60      /* polling interval in seconds */
#define DFLT_retrieveNewLogsFromStart 1/* Process newly found containers logs from start */
#define DFLT_containersLimit   25      /* maximum number of containers */
#define DFLT_trimLineOverBytes 4194304 /* limit log lines to the value - 4MB default */
#define DFLT_bEscapeLF         1       /* whether line feeds should be escaped */

#define DFLT_SEVERITY pri2sev(LOG_INFO)
#define DFLT_FACILITY pri2fac(LOG_USER)

enum {
	dst_invalid = -1,
	dst_stdin,
	dst_stdout,
	dst_stderr,
	dst_stream_type_count
} docker_stream_type_t;

/* imdocker specific structs */
typedef struct imdocker_buf_s {
	uchar  *data;
	size_t len;
	size_t data_size;
} imdocker_buf_t;

typedef struct docker_cont_logs_buf_s {
	imdocker_buf_t *buf;
	int8_t         stream_type;
	size_t         bytes_remaining;
} docker_cont_logs_buf_t;

struct docker_cont_logs_inst_s;
typedef rsRetVal (*submitmsg_funcptr) (struct docker_cont_logs_inst_s *pInst, docker_cont_logs_buf_t *pBufdata,
		const uchar* pszTag);
typedef submitmsg_funcptr SubmitMsgFuncPtr;

/* curl request instance */
typedef struct docker_cont_logs_req_s {
	CURL     *curl;
	docker_cont_logs_buf_t* data_bufs[dst_stream_type_count];
	SubmitMsgFuncPtr submitMsg;
} docker_cont_logs_req_t;

typedef struct imdocker_req_s {
	CURL           *curl;
	imdocker_buf_t *buf;
} imdocker_req_t;

typedef struct docker_container_info_s {
	uchar *name;
	uchar *image_id;
	uint64_t created;
	/* json string container labels */
	uchar *json_str_labels;
} docker_container_info_t;

typedef struct docker_cont_logs_inst_s {
	char *id;
	char short_id[12];
	docker_container_info_t *container_info;
	docker_cont_logs_req_t  *logsReq;
	uchar *start_regex;
	regex_t start_preg;  /* compiled version of start_regex */
	uint32_t prevSegEnd;
} docker_cont_logs_inst_t;

typedef struct docker_cont_log_instances_s {
	struct hashtable* ht_container_log_insts;
	pthread_mutex_t mut;
	CURLM         *curlm;
	/* track the latest created container */
	uint64_t last_container_created;
	uchar   *last_container_id;
	time_t  time_started;
} docker_cont_log_instances_t;

/* FORWARD DEFINITIONS */

/* imdocker_buf_t */
static rsRetVal imdockerBufNew(imdocker_buf_t **ppThis);
static void imdockerBufDestruct(imdocker_buf_t *pThis);

/* docker_cont_logs_buf_t */
static rsRetVal dockerContLogsBufNew(docker_cont_logs_buf_t **ppThis);
static void dockerContLogsBufDestruct(docker_cont_logs_buf_t *pThis);
static rsRetVal dockerContLogsBufWrite(docker_cont_logs_buf_t *pThis, const uchar *pdata,
		size_t write_size);

/* imdocker_req_t */
static rsRetVal imdockerReqNew(imdocker_req_t **ppThis);
static void imdockerReqDestruct(imdocker_req_t *pThis);

/* docker_cont_logs_req_t */
static rsRetVal dockerContLogsReqNew(docker_cont_logs_req_t **ppThis, SubmitMsgFuncPtr submitMsg);
static void dockerContLogsReqDestruct(docker_cont_logs_req_t *pThis);

/* docker_cont_logs_inst_t */
static rsRetVal
dockerContLogsInstNew(docker_cont_logs_inst_t **ppThis, const char* id,
		docker_container_info_t *container_info, SubmitMsgFuncPtr submitMsg);

static void dockerContLogsInstDestruct(docker_cont_logs_inst_t *pThis);
static rsRetVal dockerContLogsInstSetUrlById (sbool isInit, docker_cont_logs_inst_t *pThis,
		CURLM *curlm, const char* containerId);

/* docker_cont_log_instances_t */
static rsRetVal dockerContLogReqsNew(docker_cont_log_instances_t **ppThis);
static rsRetVal dockerContLogReqsDestruct(docker_cont_log_instances_t *pThis);
static rsRetVal dockerContLogReqsGet(docker_cont_log_instances_t *pThis,
		docker_cont_logs_inst_t** ppContLogsInst, const char *id);
static rsRetVal dockerContLogReqsPrint(docker_cont_log_instances_t *pThis);
static rsRetVal dockerContLogReqsAdd(docker_cont_log_instances_t *pThis,
		docker_cont_logs_inst_t *pContLogsReqInst);
static rsRetVal dockerContLogReqsRemove(docker_cont_log_instances_t *pThis, const char *id);

/* docker_container_info_t */
static rsRetVal dockerContainerInfoNew(docker_container_info_t **pThis);
static void dockerContainerInfoDestruct(docker_container_info_t *pThis);

/* utility functions */
static CURLcode docker_get(imdocker_req_t *req, const char* url);
static char* dupDockerContainerName(const char* pname);
static rsRetVal SubmitMsg(docker_cont_logs_inst_t *pInst, docker_cont_logs_buf_t *pBufData,
		const uchar* pszTag);
/* support multi-line */
static rsRetVal
SubmitMsg2(docker_cont_logs_inst_t *pInst, docker_cont_logs_buf_t *pBufData, const uchar* pszTag);
static size_t imdocker_container_list_curlCB(void *data, size_t size, size_t nmemb, void *buffer);
static size_t imdocker_container_logs_curlCB(void *data, size_t size, size_t nmemb, void *buffer);
static sbool get_stream_info(const uchar* data, size_t size, int8_t *stream_type, size_t *payload_size);
static int8_t is_valid_stream_type(int8_t stream_type);

/* Module static data */
DEF_IMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(prop)
DEFobjCurrIf(parser)
DEFobjCurrIf(datetime)
DEFobjCurrIf(statsobj)

statsobj_t *modStats;
STATSCOUNTER_DEF(ctrSubmit, mutCtrSubmit)
STATSCOUNTER_DEF(ctrLostRatelimit, mutCtrLostRatelimit)
STATSCOUNTER_DEF(ctrCurlError, mutCtrCurlError)

const char* DFLT_dockerAPIUnixSockAddr  = &quot;/var/run/docker.sock&quot;;
const char* DFLT_dockerAPIAdd           = &quot;http://localhost:2375&quot;;
const char* DFLT_apiVersionStr          = &quot;v1.27&quot;;
const char* DFLT_listContainersOptions  = &quot;&quot;;
const char* DFLT_getContainerLogOptions = &quot;timestamps=0&amp;follow=1&amp;stdout=1&amp;stderr=1&amp;tail=1&quot;;
const char* DFLT_getContainerLogOptionsWithoutTail = &quot;timestamps=0&amp;follow=1&amp;stdout=1&amp;stderr=1&quot;;

/* Overall module configuration structure here. */
struct modConfData_s {
	rsconf_t *pConf;  /* our overall config object */
	uchar    *apiVersionStr;
	uchar    *listContainersOptions;
	uchar    *getContainerLogOptions;
	uchar    *getContainerLogOptionsWithoutTail;
	int      iPollInterval;  /* in seconds */
	uchar    *dockerApiUnixSockAddr;
	uchar    *dockerApiAddr;
	sbool    retrieveNewLogsFromStart;
	int      containersLimit;
	int      trimLineOverBytes;
	int      iDfltSeverity;
	int      iDfltFacility;
	sbool    bEscapeLf;
};

static modConfData_t *loadModConf = NULL;
static modConfData_t *runModConf = NULL;

static prop_t *pInputName = NULL;   /* our inputName currently is always &quot;imdocker&quot;, and this will hold it */
static prop_t *pLocalHostIP = NULL; /* a pseudo-constant propterty for 127.0.0.1 */

static ratelimit_t *ratelimiter = NULL;
<A NAME="0"></A>
/* module-global parameters */
static struct cnfparamdescr modpdescr[] = {
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1929-1.html#0',3,'match1929-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	{ &quot;apiversionstr&quot;, eCmdHdlrString, 0 },
	{ &quot;dockerapiunixsockaddr&quot;, eCmdHdlrString, 0 },
	{ &quot;dockerapiaddr&quot;, eCmdHdlrString, 0 },
	{ &quot;listcontainersoptions&quot;, eCmdHdlrString, 0 },
	{ &quot;getcontainerlogoptions&quot;, eCmdHdlrString, 0 },
	{ &quot;pollinginterval&quot;, eCmdHdlrPositiveInt, 0 },
	{ &quot;retrievenewlogsfromstart&quot;, eCmdHdlrBinary, 0 },
	{ &quot;trimlineoverbytes&quot;, eCmdHdlrPositiveInt, 0 },
	{ &quot;defaultseverity&quot;, eCmdHdlrSeverity, 0 },
	{ &quot;defaultfacility&quot;, eCmdHdlrFacility, 0 },
	{ &quot;escapelf&quot;, eCmdHdlrBinary, 0 },
};

static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
		sizeof(modpdescr)/sizeof(struct cnfparamdescr),
		modpdescr
	};

static int bLegacyCnfModGlobalsPermitted; /* are legacy module-global config parameters permitted? */</B></FONT>

/* imdocker specific functions */
static rsRetVal
imdockerBufNew(imdocker_buf_t **ppThis) {
	DEFiRet;

	imdocker_buf_t *pThis = (imdocker_buf_t*) calloc(1, sizeof(imdocker_buf_t));
	if (!pThis) { return RS_RET_OUT_OF_MEMORY; }
	*ppThis = pThis;

	RETiRet;
}

static void
imdockerBufDestruct(imdocker_buf_t *pThis) {
	if (pThis) {
		if (pThis-&gt;data) {
			free(pThis-&gt;data);
			pThis-&gt;data = NULL;
		}
		free(pThis);
	}
}

static rsRetVal
dockerContLogsBufNew(docker_cont_logs_buf_t **ppThis) {
	DEFiRet;

	docker_cont_logs_buf_t *pThis = (docker_cont_logs_buf_t*) calloc(1, sizeof(docker_cont_logs_buf_t));
	if (pThis &amp;&amp; (iRet = imdockerBufNew(&amp;pThis-&gt;buf)) == RS_RET_OK) {
		pThis-&gt;stream_type = dst_invalid;
		pThis-&gt;bytes_remaining = 0;
		*ppThis = pThis;
	} else {
		dockerContLogsBufDestruct(pThis);
	}

	RETiRet;
}

static void
dockerContLogsBufDestruct(docker_cont_logs_buf_t *pThis) {
	if (pThis) {
		if (pThis-&gt;buf) {
			imdockerBufDestruct(pThis-&gt;buf);
		}
		free(pThis);
	}
}

static rsRetVal
dockerContLogsBufWrite(docker_cont_logs_buf_t *const pThis, const uchar *const pdata, const size_t write_size) {
	DEFiRet;

	imdocker_buf_t *const mem = pThis-&gt;buf;
	if (mem-&gt;len + write_size + 1 &gt; mem-&gt;data_size) {
		uchar *const pbuf = realloc(mem-&gt;data, mem-&gt;len + write_size + 1);
		if(pbuf == NULL) {
			LogError(errno, RS_RET_ERR, &quot;%s() - realloc failed!\n&quot;, __FUNCTION__);
			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
		}
		mem-&gt;data = pbuf;
		mem-&gt;data_size = mem-&gt;len+ write_size + 1;
	}
	/* copy the bytes, and advance pdata */
	memcpy(&amp;(mem-&gt;data[mem-&gt;len]), pdata, write_size);
	mem-&gt;len += write_size;
	mem-&gt;data[mem-&gt;len] = '\0';

	if (write_size &gt; pThis-&gt;bytes_remaining) {
		pThis-&gt;bytes_remaining = 0;
	} else {
		pThis-&gt;bytes_remaining -= write_size;
	}

finalize_it:
	RETiRet;
}

rsRetVal imdockerReqNew(imdocker_req_t **ppThis) {
	DEFiRet;

	imdocker_req_t *pThis = (imdocker_req_t*) calloc(1, sizeof(imdocker_req_t));
	CHKmalloc(pThis);
	pThis-&gt;curl = curl_easy_init();
	if (!pThis-&gt;curl) {
		ABORT_FINALIZE(RS_RET_ERR);
	}

	CHKiRet(imdockerBufNew(&amp;(pThis-&gt;buf)));
	*ppThis = pThis;

finalize_it:
	if (iRet != RS_RET_OK &amp;&amp; pThis) {
		imdockerReqDestruct(pThis);
	}
	RETiRet;
}

void imdockerReqDestruct(imdocker_req_t *pThis) {
	if (pThis) {
		if (pThis-&gt;buf) {
			imdockerBufDestruct(pThis-&gt;buf);
		}

		if (pThis-&gt;curl) {
			curl_easy_cleanup(pThis-&gt;curl);
			pThis-&gt;curl = NULL;
		}
		free(pThis);
	}
}

static rsRetVal
dockerContLogsReqNew(docker_cont_logs_req_t **ppThis, SubmitMsgFuncPtr submitMsg) {
	DEFiRet;

	docker_cont_logs_req_t *pThis = (docker_cont_logs_req_t*) calloc(1, sizeof(docker_cont_logs_req_t));
	CHKmalloc(pThis);
	pThis-&gt;submitMsg = submitMsg;
	pThis-&gt;curl = curl_easy_init();
	if (!pThis-&gt;curl) {
		ABORT_FINALIZE(RS_RET_ERR);
	}

	for (int i = 0; i &lt; dst_stream_type_count; i ++) {
		CHKiRet(dockerContLogsBufNew(&amp;pThis-&gt;data_bufs[i]));
	}

	*ppThis = pThis;

finalize_it:
	if (iRet != RS_RET_OK) {
		if (pThis) {
			dockerContLogsReqDestruct(pThis);
		}
	}
	RETiRet;
}

static void
dockerContLogsReqDestruct(docker_cont_logs_req_t *pThis) {
	if (pThis) {
		for (int i = 0; i &lt; dst_stream_type_count; i++) {
			dockerContLogsBufDestruct(pThis-&gt;data_bufs[i]);
		}

		if (pThis-&gt;curl) {
			curl_easy_cleanup(pThis-&gt;curl);
			pThis-&gt;curl=NULL;
		}

		free(pThis);
	}
}

/**
 * debugging aide
 */
static rsRetVal
dockerContLogsInstPrint(docker_cont_logs_inst_t * pThis) {
	DEFiRet;
	DBGPRINTF(&quot;\t container id: %s\n&quot;, pThis-&gt;id);
	char* pUrl = NULL;
	curl_easy_getinfo(pThis-&gt;logsReq-&gt;curl, CURLINFO_EFFECTIVE_URL, &amp;pUrl);
	DBGPRINTF(&quot;\t container url: %s\n&quot;, pUrl);

	RETiRet;
}

static void
dockerContLogsInstDestruct(docker_cont_logs_inst_t *pThis) {
	if (pThis) {
		if (pThis-&gt;id) {
			free((void*)pThis-&gt;id);
		}
		if (pThis-&gt;container_info) {
			dockerContainerInfoDestruct(pThis-&gt;container_info);
		}
		if (pThis-&gt;logsReq) {
			dockerContLogsReqDestruct(pThis-&gt;logsReq);
		}
		if (pThis-&gt;start_regex) {
			free(pThis-&gt;start_regex);
			regfree(&amp;pThis-&gt;start_preg);
		}
		free(pThis);
	}
}

static rsRetVal
parseLabels(docker_cont_logs_inst_t *inst, const uchar* json) {
	DEFiRet;

	/* parse out if we need to do special handling for mult-line */
	DBGPRINTF(&quot;%s() - parsing json=%s\n&quot;, __FUNCTION__, json);

	struct fjson_object *json_obj = fjson_tokener_parse((const char*)json);
	struct fjson_object_iterator it = fjson_object_iter_begin(json_obj);
	struct fjson_object_iterator itEnd = fjson_object_iter_end(json_obj);
	while (!fjson_object_iter_equal(&amp;it, &amp;itEnd)) {
		if (Debug) {
			DBGPRINTF(&quot;%s - \t%s: '%s'\n&quot;,
					__FUNCTION__,
					fjson_object_iter_peek_name(&amp;it),
					fjson_object_get_string(fjson_object_iter_peek_value(&amp;it)));
		}

		if (strcmp(fjson_object_iter_peek_name(&amp;it), DOCKER_CONTAINER_LABEL_KEY_STARTREGEX) == 0) {
			inst-&gt;start_regex = (uchar*)strdup(fjson_object_get_string(fjson_object_iter_peek_value(&amp;it)));
			// compile the regex for future use.
			int err = regcomp(&amp;inst-&gt;start_preg, fjson_object_get_string(fjson_object_iter_peek_value(&amp;it)),
					REG_EXTENDED);
			if (err != 0) {
				char errbuf[512];
				regerror(err, &amp;inst-&gt;start_preg, errbuf, sizeof(errbuf));
				LogError(0, err, &quot;%s() - error in startregex compile: %s&quot;, __FUNCTION__, errbuf);
				ABORT_FINALIZE(RS_RET_ERR);
			}
		}
		fjson_object_iter_next(&amp;it);
	}

finalize_it:
	if (json_obj) {
		json_object_put(json_obj);
	}
	RETiRet;
}

static rsRetVal
dockerContLogsInstNew(docker_cont_logs_inst_t **ppThis, const char* id,
		docker_container_info_t *container_info, SubmitMsgFuncPtr submitMsg) {
	DEFiRet;

	docker_cont_logs_inst_t *pThis = NULL;
	CHKmalloc(pThis = calloc(1, sizeof(docker_cont_logs_inst_t)));

	pThis-&gt;id = strdup((char*)id);
	strncpy((char*) pThis-&gt;short_id, id, sizeof(pThis-&gt;short_id)-1);
	CHKiRet(dockerContLogsReqNew(&amp;pThis-&gt;logsReq, submitMsg));
	/* make a copy */
	if (container_info) {
		CHKiRet(dockerContainerInfoNew(&amp;pThis-&gt;container_info));
		if (container_info-&gt;image_id) {
			pThis-&gt;container_info-&gt;image_id = (uchar*)strdup((char*)container_info-&gt;image_id);
		}
		if (container_info-&gt;name) {
			const char *pname = (const char*)container_info-&gt;name;
			/* removes un-needed characters */
			pThis-&gt;container_info-&gt;name = (uchar*)dupDockerContainerName(pname);
		}
		if (container_info-&gt;json_str_labels) {
			pThis-&gt;container_info-&gt;json_str_labels =
				(uchar*)strdup((char*)container_info-&gt;json_str_labels);
		}
		pThis-&gt;container_info-&gt;created = container_info-&gt;created;
	}
	pThis-&gt;start_regex = NULL;
	pThis-&gt;prevSegEnd = 0;
	/* initialize based on labels found */
	if (pThis-&gt;container_info &amp;&amp; pThis-&gt;container_info-&gt;json_str_labels) {
		parseLabels(pThis, pThis-&gt;container_info-&gt;json_str_labels);
	}

	*ppThis = pThis;

finalize_it:
	if (iRet != RS_RET_OK) {
		if (pThis) {
			dockerContLogsInstDestruct(pThis);
		}
	}
	RETiRet;
}

static rsRetVal
dockerContLogsInstSetUrl(docker_cont_logs_inst_t *pThis, CURLM *curlm, const char* pUrl) {
	DEFiRet;
	CURLcode ccode = CURLE_OK;
	CURLMcode mcode = CURLM_OK;

	if (curlm) {
		docker_cont_logs_req_t *req = pThis-&gt;logsReq;
		if (!runModConf-&gt;dockerApiAddr) {
			ccode = curl_easy_setopt(req-&gt;curl, CURLOPT_UNIX_SOCKET_PATH,
					runModConf-&gt;dockerApiUnixSockAddr);
			if (ccode != CURLE_OK) {
				LogError(0, RS_RET_ERR,
						&quot;imdocker: curl_easy_setopt(CURLOPT_UNIX_SOCKET_PATH) error - %d:%s\n&quot;,
						ccode, curl_easy_strerror(ccode));
				ABORT_FINALIZE(RS_RET_ERR);
			}
		}
		ccode = curl_easy_setopt(req-&gt;curl, CURLOPT_WRITEFUNCTION, imdocker_container_logs_curlCB);
		if (ccode != CURLE_OK) {
				LogError(0, RS_RET_ERR,
						&quot;imdocker: curl_easy_setopt(CURLOPT_WRITEFUNCTION) error - %d:%s\n&quot;,
						ccode, curl_easy_strerror(ccode));
				ABORT_FINALIZE(RS_RET_ERR);
		}

		ccode = curl_easy_setopt(req-&gt;curl, CURLOPT_WRITEDATA, pThis);
		if (ccode != CURLE_OK) {
				LogError(0, RS_RET_ERR, &quot;imdocker: curl_easy_setopt(CURLOPT_WRITEDATA) error - %d:%s\n&quot;,
						ccode, curl_easy_strerror(ccode));
				ABORT_FINALIZE(RS_RET_ERR);
		}

		ccode = curl_easy_setopt(pThis-&gt;logsReq-&gt;curl, CURLOPT_URL, pUrl);
		if (ccode != CURLE_OK) {
			LogError(0, RS_RET_ERR, &quot;imdocker: could not set url - %d:%s\n&quot;,
					ccode, curl_easy_strerror(ccode));
			ABORT_FINALIZE(RS_RET_ERR);
		}

		ccode = curl_easy_setopt(pThis-&gt;logsReq-&gt;curl, CURLOPT_PRIVATE, pThis-&gt;id);
		if (ccode != CURLE_OK) {
			LogError(0, RS_RET_ERR, &quot;imdocker: could not set private data - %d:%s\n&quot;,
					ccode, curl_easy_strerror(ccode));
			ABORT_FINALIZE(RS_RET_ERR);
		}

		mcode = curl_multi_add_handle(curlm, pThis-&gt;logsReq-&gt;curl);
		if (mcode != CURLM_OK) {
			LogError(0, RS_RET_ERR, &quot;imdocker: error curl_multi_add_handle ret- %d:%s\n&quot;,
					mcode, curl_multi_strerror(mcode));
			ABORT_FINALIZE(RS_RET_ERR);
		}
	}

finalize_it:
	if (ccode != CURLE_OK) {
		STATSCOUNTER_INC(ctrCurlError, mutCtrCurlError);
	}
	RETiRet;
}

static rsRetVal
dockerContLogsInstSetUrlById (sbool isInit, docker_cont_logs_inst_t *pThis, CURLM *curlm,
		const char* containerId) {
	char url[256];
	const uchar* container_log_options = runModConf-&gt;getContainerLogOptionsWithoutTail;

	if (isInit || !runModConf-&gt;retrieveNewLogsFromStart) {
		container_log_options = runModConf-&gt;getContainerLogOptions;
	}

	const uchar* pApiAddr = (uchar*)&quot;http:&quot;;
	if (runModConf-&gt;dockerApiAddr) {
		pApiAddr = runModConf-&gt;dockerApiAddr;
	}

	snprintf(url, sizeof(url), &quot;%s/%s/containers/%s/logs?%s&quot;,
			pApiAddr, runModConf-&gt;apiVersionStr, containerId, container_log_options);
	DBGPRINTF(&quot;%s() - url: %s\n&quot;, __FUNCTION__, url);

	return dockerContLogsInstSetUrl(pThis, curlm, url);
}

/* special destructor for hashtable object. */
static void
dockerContLogReqsDestructForHashtable(void *pData) {
	docker_cont_logs_inst_t *pThis = (docker_cont_logs_inst_t *) pData;
	dockerContLogsInstDestruct(pThis);
}

static rsRetVal
dockerContLogReqsNew(docker_cont_log_instances_t **ppThis) {
	DEFiRet;

	docker_cont_log_instances_t *pThis = calloc(1, sizeof(docker_cont_log_instances_t));
	CHKmalloc(pThis);
	CHKmalloc(pThis-&gt;ht_container_log_insts =
			create_hashtable(7, hash_from_string, key_equals_string,
				dockerContLogReqsDestructForHashtable));

	CHKiConcCtrl(pthread_mutex_init(&amp;pThis-&gt;mut, NULL));

	pThis-&gt;curlm = curl_multi_init();
	if (!pThis-&gt;curlm) {
		ABORT_FINALIZE(RS_RET_ERR);
	}

	*ppThis = pThis;

finalize_it:
	if (iRet != RS_RET_OK) {
		if (pThis) {
			dockerContLogReqsDestruct(pThis);
		}
	}
	RETiRet;
}

static rsRetVal
dockerContLogReqsDestruct(docker_cont_log_instances_t *pThis) {
	DEFiRet;

	if (pThis) {
		if (pThis-&gt;ht_container_log_insts) {
			pthread_mutex_lock(&amp;pThis-&gt;mut);
			hashtable_destroy(pThis-&gt;ht_container_log_insts, 1);
			pthread_mutex_unlock(&amp;pThis-&gt;mut);
		}
		if (pThis-&gt;last_container_id) {
			free(pThis-&gt;last_container_id);
		}
		curl_multi_cleanup(pThis-&gt;curlm);
		pthread_mutex_destroy(&amp;pThis-&gt;mut);
		free(pThis);
	}

	RETiRet;
}

/* NOTE: not thread safe - used internally to update container log requests */
static rsRetVal
dockerContLogReqsGet(docker_cont_log_instances_t *pThis,
		docker_cont_logs_inst_t** ppContLogsInst, const char *id) {
	DEFiRet;

	if (ppContLogsInst &amp;&amp; id) {
		docker_cont_logs_inst_t *pSearchObj = hashtable_search(pThis-&gt;ht_container_log_insts, (void*)id);
		if (!pSearchObj) {
			return RS_RET_NOT_FOUND;
		}
		*ppContLogsInst = pSearchObj;
	}

	RETiRet;
}

/* debug print
 *
 * NOTE: not thread safe
 *
 */
static rsRetVal
dockerContLogReqsPrint(docker_cont_log_instances_t *pThis) {
	DEFiRet;
	int count = 0;

	count = hashtable_count(pThis-&gt;ht_container_log_insts);
	if (count) {
		int ret = 0;
		struct hashtable_itr *itr = hashtable_iterator(pThis-&gt;ht_container_log_insts);

		DBGPRINTF(&quot;%s() - All container instances, count=%d...\n&quot;, __FUNCTION__, count);
		do {
			docker_cont_logs_inst_t *pObj = hashtable_iterator_value(itr);
			dockerContLogsInstPrint(pObj);
			ret = hashtable_iterator_advance(itr);
		} while (ret);
		free (itr);
		DBGPRINTF(&quot;End of container instances.\n&quot;);
	}

	RETiRet;
}

/* NOTE: not thread safe */
static rsRetVal
dockerContLogReqsAdd(docker_cont_log_instances_t *pThis,
		docker_cont_logs_inst_t *pContLogsReqInst)
{
	DEFiRet;
	if (!pContLogsReqInst) {
		return RS_RET_ERR;
	}

	uchar *keyName = (uchar*)strdup((char*)pContLogsReqInst-&gt;id);

	if (keyName) {
		docker_cont_logs_inst_t *pFind;
		if (RS_RET_NOT_FOUND == dockerContLogReqsGet(pThis, &amp;pFind, (void*)keyName)) {
			if (!hashtable_insert(pThis-&gt;ht_container_log_insts, keyName, pContLogsReqInst)) {
				ABORT_FINALIZE(RS_RET_ERR);
			}
			keyName = NULL;
		}
	}
finalize_it:
	free(keyName);
	RETiRet;
}

static rsRetVal
dockerContLogReqsRemove(docker_cont_log_instances_t *pThis, const char *id) {
	DEFiRet;

	if (pThis &amp;&amp; id) {
		CHKiConcCtrl(pthread_mutex_lock(&amp;pThis-&gt;mut));
		docker_cont_logs_inst_t *pRemoved =
			hashtable_remove(pThis-&gt;ht_container_log_insts, (void*)id);
		pthread_mutex_unlock(&amp;pThis-&gt;mut);
		if (pRemoved) {
			dockerContLogsInstDestruct(pRemoved);
		} else {
			iRet = RS_RET_NOT_FOUND;
		}
	}
finalize_it:
	RETiRet;
}

static rsRetVal
dockerContainerInfoNew(docker_container_info_t **ppThis) {
	DEFiRet;
	docker_container_info_t* pThis = calloc(1, sizeof(docker_container_info_t));
	CHKmalloc(pThis);
	*ppThis = pThis;

finalize_it:
	RETiRet;
}

static void
dockerContainerInfoDestruct(docker_container_info_t *pThis) {
	if (pThis) {
		if (pThis-&gt;image_id) { free(pThis-&gt;image_id); }
		if (pThis-&gt;name) { free(pThis-&gt;name); }
		if (pThis-&gt;json_str_labels) { free(pThis-&gt;json_str_labels); }
		free(pThis);
	}
}

BEGINbeginCnfLoad
CODESTARTbeginCnfLoad

	dbgprintf(&quot;imdocker: beginCnfLoad\n&quot;);

	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;

	/* init our settings */
	loadModConf-&gt;iPollInterval     = DFLT_pollingInterval; /* in seconds */
	loadModConf-&gt;retrieveNewLogsFromStart  = DFLT_retrieveNewLogsFromStart;
	loadModConf-&gt;containersLimit   = DFLT_containersLimit;
	loadModConf-&gt;trimLineOverBytes = DFLT_trimLineOverBytes;
	loadModConf-&gt;bEscapeLf         = DFLT_bEscapeLF;

	/* Use the default url */
	loadModConf-&gt;apiVersionStr          = NULL;
	loadModConf-&gt;dockerApiUnixSockAddr  = NULL;
	loadModConf-&gt;dockerApiAddr          = NULL;
	loadModConf-&gt;listContainersOptions  = NULL;
	loadModConf-&gt;getContainerLogOptions = NULL;
	loadModConf-&gt;getContainerLogOptionsWithoutTail = NULL;
	loadModConf-&gt;iDfltFacility = DFLT_FACILITY;
	loadModConf-&gt;iDfltSeverity = DFLT_SEVERITY;
ENDbeginCnfLoad

BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;error processing module &quot;
				&quot;config parameters [module(...)]&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if (Debug) {
		dbgprintf(&quot;module (global) param blk for imdocker:\n&quot;);
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		dbgprintf(&quot;%s() - iteration %d\n&quot;, __FUNCTION__,i);
		dbgprintf(&quot;%s() - modpblk descr: %s\n&quot;, __FUNCTION__, modpblk.descr[i].name);
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(modpblk.descr[i].name, &quot;pollinginterval&quot;)) {
			loadModConf-&gt;iPollInterval = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;containterlimit&quot;)) {
<A NAME="4"></A>			loadModConf-&gt;containersLimit = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;trimlineoverbytes&quot;)) {
			loadModConf-&gt;trimLineOverBytes = (int) pvals[i].val.d.n;
<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match1929-1.html#4',3,'match1929-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		} else if(!strcmp(modpblk.descr[i].name, &quot;listcontainersoptions&quot;)) {
			loadModConf-&gt;listContainersOptions = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, &quot;getcontainerlogoptions&quot;)) {
			loadModConf-&gt;getContainerLogOptions = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			/* also intialize the non-tail version */
			size_t offset = 0;</B></FONT>
			char buf[256];
			size_t buf_size = sizeof(buf);
			strncpy(buf, (char*)loadModConf-&gt;getContainerLogOptions, buf_size-1);
			size_t option_str_len = strlen((char*)loadModConf-&gt;getContainerLogOptions);
			uchar *option_str = calloc(1, option_str_len);
			CHKmalloc(option_str);

			const char *search_str = &quot;tail=&quot;;
			size_t search_str_len = strlen(search_str);
			char *token = strtok(buf, &quot;&amp;&quot;);

			while (token != NULL) {
				if (strncmp(token, search_str, search_str_len) == 0) {
					token = strtok(NULL, &quot;&amp;&quot;);
					continue;
				}
				int len = strlen(token);
				if (offset + len + 1 &gt;= option_str_len) {
					break;
				}
				int bytes = snprintf((char*)option_str + offset,
						(option_str_len - offset), &quot;%s&amp;&quot;, token);
				if (bytes &lt;= 0) {
					break;
				}
				offset += bytes;
<A NAME="1"></A>				token = strtok(NULL, &quot;&amp;&quot;);
			}
			loadModConf-&gt;getContainerLogOptionsWithoutTail = option_str;
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1929-1.html#1',3,'match1929-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		} else if(!strcmp(modpblk.descr[i].name, &quot;dockerapiunixsockaddr&quot;)) {
			loadModConf-&gt;dockerApiUnixSockAddr = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, &quot;dockerapiaddr&quot;)) {
			loadModConf-&gt;dockerApiAddr = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, &quot;apiversionstr&quot;)) {
			loadModConf-&gt;apiVersionStr = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, &quot;retrievenewlogsfromstart&quot;)) {
			loadModConf-&gt;retrieveNewLogsFromStart = (sbool) pvals[i].val.d.n;</B></FONT>
		} else if (!strcmp(modpblk.descr[i].name, &quot;defaultseverity&quot;)) {
			loadModConf-&gt;iDfltSeverity = (int) pvals[i].val.d.n;
		} else if (!strcmp(modpblk.descr[i].name, &quot;defaultfacility&quot;)) {
			loadModConf-&gt;iDfltFacility = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;escapelf&quot;)) {
			loadModConf-&gt;bEscapeLf = (sbool) pvals[i].val.d.n;
		} else {
			LogError(0, RS_RET_INVALID_PARAMS,
					&quot;imdocker: program error, non-handled &quot;
					&quot;param '%s' in setModCnf\n&quot;, modpblk.descr[i].name);
		}
	}

	/* disable legacy module-global config directives */
	bLegacyCnfModGlobalsPermitted = 0;

finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf

BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
	if (!loadModConf-&gt;dockerApiUnixSockAddr) {
		loadModConf-&gt;dockerApiUnixSockAddr = (uchar*) strdup(DFLT_dockerAPIUnixSockAddr);
	}
	if (!loadModConf-&gt;apiVersionStr) {
		loadModConf-&gt;apiVersionStr = (uchar*) strdup(DFLT_apiVersionStr);
	}
	if (!loadModConf-&gt;listContainersOptions) {
		loadModConf-&gt;listContainersOptions = (uchar*) strdup(DFLT_listContainersOptions);
	}
	if (!loadModConf-&gt;getContainerLogOptions) {
		loadModConf-&gt;getContainerLogOptions = (uchar*) strdup(DFLT_getContainerLogOptions);
	}
if (!loadModConf-&gt;getContainerLogOptionsWithoutTail) {
		loadModConf-&gt;getContainerLogOptionsWithoutTail =
			(uchar*) strdup(DFLT_getContainerLogOptionsWithoutTail);
	}
	runModConf = loadModConf;

	/* support statistics gathering */
	CHKiRet(statsobj.Construct(&amp;modStats));
	CHKiRet(statsobj.SetName(modStats, UCHAR_CONSTANT(&quot;imdocker&quot;)));
	CHKiRet(statsobj.SetOrigin(modStats, UCHAR_CONSTANT(&quot;imdocker&quot;)));

	STATSCOUNTER_INIT(ctrSubmit, mutCtrSubmit);
	CHKiRet(statsobj.AddCounter(modStats, UCHAR_CONSTANT(&quot;submitted&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrSubmit));

	STATSCOUNTER_INIT(ctrLostRatelimit, mutCtrLostRatelimit);
	CHKiRet(statsobj.AddCounter(modStats, UCHAR_CONSTANT(&quot;ratelimit.discarded&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrLostRatelimit));

	STATSCOUNTER_INIT(ctrCurlError, mutCtrCurlError);
	CHKiRet(statsobj.AddCounter(modStats, UCHAR_CONSTANT(&quot;curl.errors&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrCurlError));

	CHKiRet(statsobj.ConstructFinalize(modStats));
	/* end stats */
finalize_it:
ENDactivateCnf
<A NAME="3"></A>
BEGINfreeCnf
CODESTARTfreeCnf
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match1929-1.html#3',3,'match1929-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	if (loadModConf-&gt;dockerApiUnixSockAddr) {
		free(loadModConf-&gt;dockerApiUnixSockAddr);
	}
	if (loadModConf-&gt;dockerApiAddr) {
		free(loadModConf-&gt;dockerApiAddr);
	}
	if (loadModConf-&gt;apiVersionStr) {
		free(loadModConf-&gt;apiVersionStr);
	}
	if (loadModConf-&gt;getContainerLogOptions) {
		free(loadModConf-&gt;getContainerLogOptions);
	}
	if (loadModConf-&gt;getContainerLogOptionsWithoutTail) {</B></FONT>
		free(loadModConf-&gt;getContainerLogOptionsWithoutTail);
	}
	if (loadModConf-&gt;listContainersOptions) {
		free(loadModConf-&gt;listContainersOptions);
	}
	statsobj.Destruct(&amp;modStats);
ENDfreeCnf

static rsRetVal
addDockerMetaData(const uchar* container_id, docker_container_info_t* pinfo, smsg_t *pMsg) {
	const uchar *names[4] = {
		(const uchar*) DOCKER_CONTAINER_ID_PARSE_NAME,
		(const uchar*) DOCKER_CONTAINER_NAMES_PARSE_NAME,
		(const uchar*) DOCKER_CONTAINER_IMAGEID_PARSE_NAME,
		(const uchar*) DOCKER_CONTAINER_LABELS_PARSE_NAME
	};

	const uchar * empty_str= (const uchar*) &quot;&quot;;
	const uchar *id = container_id ? container_id : empty_str;
	const uchar *name = pinfo-&gt;name ? pinfo-&gt;name : empty_str;
	const uchar *image_id = pinfo-&gt;image_id ? pinfo-&gt;image_id : empty_str;
	const uchar *json_str_labels = pinfo-&gt;json_str_labels ? pinfo-&gt;json_str_labels : empty_str;

	const uchar *values[4] = {
		id,
		name,
		image_id,
		json_str_labels
	};

	return msgAddMultiMetadata(pMsg, names, values, 4);
}

static rsRetVal
enqMsg(docker_cont_logs_inst_t *pInst, uchar *msg, size_t len, const uchar *pszTag,
		int facility, int severity, struct timeval *tp)
{
	struct syslogTime st;
	smsg_t *pMsg;
	DEFiRet;

	if (!msg) {
		return RS_RET_ERR;
	}

	if (tp == NULL) {
		CHKiRet(msgConstruct(&amp;pMsg));
	} else {
		datetime.timeval2syslogTime(tp, &amp;st, TIME_IN_LOCALTIME);
		CHKiRet(msgConstructWithTime(&amp;pMsg, &amp;st, tp-&gt;tv_sec));
	}
	MsgSetFlowControlType(pMsg, eFLOWCTL_LIGHT_DELAY);
	MsgSetInputName(pMsg, pInputName);
	MsgSetRawMsg(pMsg, (char*)msg, len);

	if (loadModConf-&gt;bEscapeLf) {
		parser.SanitizeMsg(pMsg);
	} else {
		/* Perform some of the SanitizeMsg operations here - specifically:
		 * - remove NULL character at end of message.
		 * - drop trailing LFs.
		 * See SanitizeMsg() for more info.
		 */
		size_t lenMsg = pMsg-&gt;iLenRawMsg;
		uchar *pszMsg = pMsg-&gt;pszRawMsg;

		if(pszMsg[lenMsg-1] == '\0') {
			DBGPRINTF(&quot;dropped NULL at very end of message\n&quot;);
			lenMsg--;
		}

		if(glbl.GetParserDropTrailingLFOnReception(loadModConf-&gt;pConf)
				&amp;&amp; lenMsg &gt; 0 &amp;&amp; pszMsg[lenMsg-1] == '\n') {
			DBGPRINTF(&quot;dropped LF at very end of message (DropTrailingLF is set)\n&quot;);
			lenMsg--;
			pszMsg[lenMsg] = '\0';
		}
		pMsg-&gt;iLenRawMsg = lenMsg;
	}

	MsgSetMSGoffs(pMsg, 0);  /* we do not have a header... */
	MsgSetRcvFrom(pMsg, glbl.GetLocalHostNameProp());
	if (pLocalHostIP) { MsgSetRcvFromIP(pMsg, pLocalHostIP); }
	MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
	MsgSetTAG(pMsg, pszTag, ustrlen(pszTag));
	pMsg-&gt;iFacility = facility;
	pMsg-&gt;iSeverity = severity;

	/* docker container metadata */
	addDockerMetaData((const uchar*)pInst-&gt;short_id, pInst-&gt;container_info, pMsg);

	const char *name = (const char*)pInst-&gt;container_info-&gt;name;
	DBGPRINTF(&quot;imdocker: %s - %s:%s\n&quot;, __FUNCTION__, name, msg);
	CHKiRet(ratelimitAddMsg(ratelimiter, NULL, pMsg));
	STATSCOUNTER_INC(ctrSubmit, mutCtrSubmit);

finalize_it:
	if (iRet == RS_RET_DISCARDMSG)
		STATSCOUNTER_INC(ctrLostRatelimit, mutCtrLostRatelimit)

	RETiRet;
}

static int8_t
is_valid_stream_type(int8_t stream_type) {
	return (dst_invalid &lt; stream_type &amp;&amp; stream_type &lt; dst_stream_type_count);
}

/* For use to get docker specific stream information */
static sbool
get_stream_info(const uchar* data, size_t size, int8_t *stream_type, size_t *payload_size) {
	if (size &lt; 8 || !data || !stream_type || !payload_size) {
		return 0;
	}
	const uchar* pdata = data;
	*stream_type = pdata[0];
	pdata += 4;
	uint32_t len = 0;
	memcpy(&amp;len, pdata, sizeof(len));
	*payload_size = ntohl(len);
	return 1;
}
#ifdef ENABLE_DEBUG_BYTE_BUFFER
static void debug_byte_buffer(const uchar* data, size_t size) {
	if (Debug) {
		DBGPRINTF(&quot;%s() - ENTER, size=%lu\n&quot;, __FUNCTION__, size);
		for (size_t i = 0; i &lt; size; i++) {
			DBGPRINTF(&quot;0x%02x,&quot;, data[i]);
		}
		DBGPRINTF(&quot;\n&quot;);
	}
}
#endif

/**
 * imdocker_container_list_curlCB
 *
 * Callback function for CURLOPT_WRITEFUNCTION to get
 * the results of a docker api call to list all containers.
 *
 */
static size_t
imdocker_container_list_curlCB(void *data, size_t size, size_t nmemb, void *buffer) {
	DEFiRet;

	size_t realsize = size*nmemb;
	uchar		*pbuf=NULL;
	imdocker_buf_t *mem = (imdocker_buf_t*)buffer;

	if ((pbuf = realloc(mem-&gt;data, mem-&gt;len + realsize + 1)) == NULL) {
		LogError(errno, RS_RET_ERR, &quot;%s() - realloc failed!\n&quot;, __FUNCTION__);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	mem-&gt;data = pbuf;
	mem-&gt;data_size = mem-&gt;len + realsize + 1;

	memcpy(&amp;(mem-&gt;data[mem-&gt;len]), data, realsize);
	mem-&gt;len += realsize;
	mem-&gt;data[mem-&gt;len] = 0;

#ifdef ENABLE_DEBUG_BYTE_BUFFER
	debug_byte_buffer((const uchar*) data, realsize);
#endif
finalize_it:
	if (iRet != RS_RET_OK) {
		return 0;
	}
	return realsize;
}

static rsRetVal
SubmitMultiLineMsg(docker_cont_logs_inst_t *pInst, docker_cont_logs_buf_t *pBufData,
		const uchar* pszTag, size_t len) {
	DEFiRet;

	imdocker_buf_t *mem = (imdocker_buf_t*)pBufData-&gt;buf;
	DBGPRINTF(&quot;%s() {type=%d, len=%u} %s\n&quot;,
			__FUNCTION__, pBufData-&gt;stream_type, (unsigned int)mem-&gt;len, mem-&gt;data);

	uchar* message = (uchar*)mem-&gt;data;
	int facility = loadModConf-&gt;iDfltFacility;
	int severity = pBufData-&gt;stream_type == dst_stderr ? LOG_ERR : loadModConf-&gt;iDfltSeverity;
	enqMsg(pInst, message, len, (const uchar*)pszTag, facility, severity, NULL);

	size_t size = mem-&gt;len - pInst-&gt;prevSegEnd;
	memmove(mem-&gt;data, mem-&gt;data+pInst-&gt;prevSegEnd, size);
	mem-&gt;data[len] = '\0';
	mem-&gt;len = size;
	pBufData-&gt;bytes_remaining = 0;

	RETiRet;
}

static rsRetVal
SubmitMsgWithStartRegex(docker_cont_logs_inst_t *pInst, docker_cont_logs_buf_t *pBufData, const uchar* pszTag) {
	imdocker_buf_t *mem = (imdocker_buf_t*)pBufData-&gt;buf;
	/* must be null terminated string */
	assert(mem-&gt;data[mem-&gt;len] == 0 || mem-&gt;data[mem-&gt;len] == '\0');
	const char* thisLine = (const char*) mem-&gt;data;

	if (pInst-&gt;prevSegEnd) {
		thisLine = (const char*) mem-&gt;data+pInst-&gt;prevSegEnd;
	}
	DBGPRINTF(&quot;prevSeg: %d, thisLine: '%s'\n&quot;, pInst-&gt;prevSegEnd, thisLine);
	DBGPRINTF(&quot;line(s) so far: '%s'\n&quot;, mem-&gt;data);

	/* check if this line is a start of multi-line message */
	regex_t *start_preg = (pInst-&gt;start_regex == NULL) ? NULL : &amp;pInst-&gt;start_preg;
	const int isStartMatch = start_preg ?
		!regexec(start_preg, (char*)thisLine, 0, NULL, 0) : 0;

	if (isStartMatch &amp;&amp; pInst-&gt;prevSegEnd != 0) {
		SubmitMultiLineMsg(pInst, pBufData, pszTag, pInst-&gt;prevSegEnd);
		pInst-&gt;prevSegEnd = 0;
		FINALIZE;
	} else {
		/* just continue parsing using same buffer */
		pInst-&gt;prevSegEnd = mem-&gt;len;
	}

finalize_it:
	return RS_RET_OK;
}

static rsRetVal
SubmitMsg2(docker_cont_logs_inst_t *pInst, docker_cont_logs_buf_t *pBufData, const uchar* pszTag) {
	imdocker_buf_t *mem = (imdocker_buf_t*)pBufData-&gt;buf;
	DBGPRINTF(&quot;%s() - {type=%d, len=%u} %s\n&quot;,
			__FUNCTION__, pBufData-&gt;stream_type, (unsigned int)mem-&gt;len, mem-&gt;data);

	if (pInst-&gt;start_regex) {
		SubmitMsgWithStartRegex(pInst, pBufData, pszTag);
	} else {
		SubmitMsg(pInst, pBufData, pszTag);
	}
	return RS_RET_OK;
}

static rsRetVal
SubmitMsg(docker_cont_logs_inst_t *pInst, docker_cont_logs_buf_t *pBufData, const uchar* pszTag) {
	imdocker_buf_t *mem = (imdocker_buf_t*)pBufData-&gt;buf;
	DBGPRINTF(&quot;%s() - {type=%d, len=%u} %s\n&quot;,
			__FUNCTION__, pBufData-&gt;stream_type, (unsigned int)mem-&gt;len, mem-&gt;data);

	uchar* message = mem-&gt;data;
	int facility = loadModConf-&gt;iDfltFacility;
	int severity = pBufData-&gt;stream_type == dst_stderr ? LOG_ERR : loadModConf-&gt;iDfltSeverity;
	enqMsg(pInst, message, mem-&gt;len, (const uchar*)pszTag, facility, severity, NULL);

	/* clear existing buffer. */
	mem-&gt;len = 0;
	memset(mem-&gt;data, 0, mem-&gt;data_size);
	pBufData-&gt;bytes_remaining = 0;

	return RS_RET_OK;
}

/** imdocker_container_logs_curlCB
 *
 * Callback function for CURLOPT_WRITEFUNCTION, gets container logs
 *
 * The main container log stream handler. This function is registerred with curl to
 * as callback to handle container log streaming. It follows the docker stream protocol
 * as described in the docker container logs api. As per docker's api documentation,
 * Docker Stream format:
 * When the TTY setting is disabled in POST /containers/create, the stream over the
 * hijacked connected is multiplexed to separate out stdout and stderr. The stream
 * consists of a series of frames, each containing a header and a payload.
 *
 * The header contains the information which the stream writes (stdout or stderr). It also
 * contains the size of the associated frame encoded in the last four bytes (uint32).
 *
 * It is encoded on the first eight bytes like this:
 *
 * header := [8]byte{STREAM_TYPE, 0, 0, 0, SIZE1, SIZE2, SIZE3, SIZE4}
 * STREAM_TYPE can be:
 * 0: stdin (is written on stdout)
 * 1: stdout
 * 2: stderr
 *
 * Docker sends out data in 16KB sized frames, however with the addition of a header
 * of 8 bytes, a frame may be split into 2 chunks by curl. The 2nd chunk will only
 * contain enough data to complete the frame (8 leftever bytes). Including the header,
 * this amounts to 16 bytes; 8 bytes for the header, and 8 bytes for the remaining frame
 * data.
 *
 */
static size_t
imdocker_container_logs_curlCB(void *data, size_t size, size_t nmemb, void *buffer) {
	DEFiRet;

	const uint8_t frame_size = 8;
	const char imdocker_eol_char = '\n';
	int8_t stream_type = dst_invalid;

	docker_cont_logs_inst_t* pInst = (docker_cont_logs_inst_t*) buffer;
	docker_cont_logs_req_t* req = pInst-&gt;logsReq;

	size_t realsize = size*nmemb;
	const uchar* pdata = data;
	size_t write_size = 0;

#ifdef ENABLE_DEBUG_BYTE_BUFFER
	debug_byte_buffer((const uchar*) data, realsize);
#endif

	if (req-&gt;data_bufs[dst_stdout]-&gt;bytes_remaining || req-&gt;data_bufs[dst_stderr]-&gt;bytes_remaining) {
		/* on continuation, stream types should matches with previous */
		if (req-&gt;data_bufs[dst_stdout]-&gt;bytes_remaining) {
			if (req-&gt;data_bufs[dst_stderr]-&gt;bytes_remaining != 0) {
				ABORT_FINALIZE(RS_RET_ERR);
			}
		} else if (req-&gt;data_bufs[dst_stderr]-&gt;bytes_remaining) {
			if (req-&gt;data_bufs[dst_stdout]-&gt;bytes_remaining != 0) {
				ABORT_FINALIZE(RS_RET_ERR);
			}
		}

		stream_type = req-&gt;data_bufs[dst_stdout]-&gt;bytes_remaining ? dst_stdout : dst_stderr;
		docker_cont_logs_buf_t *pDataBuf = req-&gt;data_bufs[stream_type];

		/* read off the remaining bytes */
		DBGPRINTF(&quot;Chunk continuation, remaining bytes: type: %d, &quot;
				&quot;bytes remaining: %u, realsize: %u, data pos: %u\n&quot;,
				stream_type, (unsigned int)pDataBuf-&gt;bytes_remaining,
				(unsigned int)realsize, (unsigned int)pDataBuf-&gt;buf-&gt;len);

		write_size = MIN(pDataBuf-&gt;bytes_remaining, realsize);
		CHKiRet(dockerContLogsBufWrite(pDataBuf, pdata, write_size));

		/* submit it */
		if (pDataBuf-&gt;bytes_remaining == 0) {
			imdocker_buf_t *mem = pDataBuf-&gt;buf;
			if (mem-&gt;data[mem-&gt;len-1] == imdocker_eol_char) {
				const char* szContainerId = NULL;
				CURLcode ccode;
				if(CURLE_OK != (ccode = curl_easy_getinfo(req-&gt;curl,
								CURLINFO_PRIVATE,
								&amp;szContainerId))) {
					LogError(0, RS_RET_ERR,
							&quot;imdocker: could not get private data req[%p] - %d:%s\n&quot;,
							req-&gt;curl, ccode, curl_easy_strerror(ccode));
					ABORT_FINALIZE(RS_RET_ERR);
				}
				req-&gt;submitMsg(pInst, pDataBuf, (const uchar*)DOCKER_TAG_NAME);
			}
		}

		pdata += write_size;
	}

	/* not enough room left */
	if ((size_t)(pdata - (const uchar*)data) &gt;= realsize) {
		return (pdata - (const uchar*)data);
	}

	size_t payload_size = 0;
	const uchar* pread = pdata + frame_size;
	docker_cont_logs_buf_t* pDataBuf = NULL;

	if (get_stream_info(pdata, realsize, &amp;stream_type, &amp;payload_size)
				&amp;&amp; is_valid_stream_type(stream_type)) {
		pDataBuf = req-&gt;data_bufs[stream_type];
		pDataBuf-&gt;stream_type = stream_type;
		pDataBuf-&gt;bytes_remaining = payload_size;
		write_size = MIN(payload_size, realsize - frame_size);
	} else {
		/* copy all the data and submit to prevent data loss */
		stream_type = req-&gt;data_bufs[dst_stderr]-&gt;bytes_remaining ? dst_stderr : dst_stdout;

		pDataBuf = req-&gt;data_bufs[stream_type];
		pDataBuf-&gt;stream_type = stream_type;

		/* just write everything out */
		pDataBuf-&gt;bytes_remaining = 0;
		write_size = realsize;
		pread = pdata;
	}

	/* allocate the expected payload size */
	CHKiRet(dockerContLogsBufWrite(pDataBuf, pread, write_size));
	if (pDataBuf-&gt;bytes_remaining == 0) {
		DBGPRINTF(&quot;%s() - write size is same as payload_size\n&quot;, __FUNCTION__);
		req-&gt;submitMsg(pInst, pDataBuf, (const uchar*)DOCKER_TAG_NAME);
	}

finalize_it:
	if (iRet != RS_RET_OK) {
		return 0;
	}
	return realsize;
}

CURLcode docker_get(imdocker_req_t *req, const char* url) {
	CURLcode ccode;

	if (!runModConf-&gt;dockerApiAddr) {
		if ((ccode = curl_easy_setopt(req-&gt;curl, CURLOPT_UNIX_SOCKET_PATH, runModConf-&gt;dockerApiUnixSockAddr))
				!= CURLE_OK) {
			STATSCOUNTER_INC(ctrCurlError, mutCtrCurlError);
			LogError(0, RS_RET_ERR, &quot;imdocker: curl_easy_setopt(CURLOPT_UNIX_SOCKET_PATH) error - %d:%s\n&quot;,
					ccode, curl_easy_strerror(ccode));
			return ccode;
		}
	}
	if ((ccode = curl_easy_setopt(req-&gt;curl, CURLOPT_WRITEFUNCTION, imdocker_container_list_curlCB)) != CURLE_OK) {
		STATSCOUNTER_INC(ctrCurlError, mutCtrCurlError);
		LogError(0, RS_RET_ERR, &quot;imdocker: curl_easy_setopt(CURLOPT_WRITEFUNCTION) error - %d:%s\n&quot;,
				ccode, curl_easy_strerror(ccode));
		return ccode;
	}
	if ((ccode = curl_easy_setopt(req-&gt;curl, CURLOPT_WRITEDATA, req-&gt;buf)) != CURLE_OK) {
		STATSCOUNTER_INC(ctrCurlError, mutCtrCurlError);
		LogError(0, RS_RET_ERR, &quot;imdocker: curl_easy_setopt(CURLOPT_WRITEDATA) error - %d:%s\n&quot;,
				ccode, curl_easy_strerror(ccode));
		return ccode;
	}

	if ((ccode = curl_easy_setopt(req-&gt;curl, CURLOPT_URL, url)) != CURLE_OK) {
		STATSCOUNTER_INC(ctrCurlError, mutCtrCurlError);
		LogError(0, RS_RET_ERR, &quot;imdocker: curl_easy_setopt(CURLOPT_URL) error - %d:%s\n&quot;,
				ccode, curl_easy_strerror(ccode));
		return ccode;
	}
	CURLcode response = curl_easy_perform(req-&gt;curl);

	return response;
}

static char*
dupDockerContainerName(const char* pname) {
	int len = strlen(pname);
	if (len &gt;= 2 &amp;&amp; *pname == '/') {
		/* skip '/' character */
		return strdup(pname+1);
	} else {
		return strdup(pname);
	}
}

static rsRetVal
process_json(sbool isInit, const char* json, docker_cont_log_instances_t *pInstances) {
	DEFiRet;
	struct fjson_object *json_obj = NULL;
	int mut_locked = 0;
	DBGPRINTF(&quot;%s() - parsing json=%s\n&quot;, __FUNCTION__, json);

	if (!pInstances) {
		ABORT_FINALIZE(RS_RET_OK);
	}

	json_obj = fjson_tokener_parse(json);
	if (!json_obj || !fjson_object_is_type(json_obj, fjson_type_array)) {
		ABORT_FINALIZE(RS_RET_OK);
	}

	int length = fjson_object_array_length(json_obj);
	/* LOCK the update process. */
	CHKiConcCtrl(pthread_mutex_lock(&amp;pInstances-&gt;mut));
	mut_locked = 1;

	for (int i = 0; i &lt; length; i++) {
		fjson_object* p_json_elm = json_object_array_get_idx(json_obj, i);

		DBGPRINTF(&quot;element: %d...\n&quot;, i);
		if (p_json_elm) {
			const char *containerId=NULL;
			docker_container_info_t containerInfo = {
				.name=NULL,
				.image_id=NULL,
				.created=0,
				.json_str_labels=NULL
			};

			struct fjson_object_iterator it = fjson_object_iter_begin(p_json_elm);
			struct fjson_object_iterator itEnd = fjson_object_iter_end(p_json_elm);
			while (!fjson_object_iter_equal(&amp;it, &amp;itEnd)) {
				if (Debug) {
					DBGPRINTF(&quot;\t%s: '%s'\n&quot;,
							fjson_object_iter_peek_name(&amp;it),
							fjson_object_get_string(fjson_object_iter_peek_value(&amp;it)));
				}

				if (strcmp(fjson_object_iter_peek_name(&amp;it), DOCKER_CONTAINER_ID_PARSE_NAME) == 0) {
					containerId =
						fjson_object_get_string(fjson_object_iter_peek_value(&amp;it));
				} else if (strcmp(fjson_object_iter_peek_name(&amp;it),
							DOCKER_CONTAINER_NAMES_PARSE_NAME) == 0) {
					int names_array_length =
						fjson_object_array_length(fjson_object_iter_peek_value(&amp;it));
					if (names_array_length) {
<A NAME="2"></A>						fjson_object* names_elm =
							json_object_array_get_idx(fjson_object_iter_peek_value(&amp;it), 0);
						containerInfo.name = (uchar*)fjson_object_get_string(names_elm);
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match1929-1.html#2',3,'match1929-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>					}
				} else if (strcmp(fjson_object_iter_peek_name(&amp;it),
							DOCKER_CONTAINER_IMAGEID_PARSE_NAME) == 0) {
					containerInfo.image_id =
						(uchar*)fjson_object_get_string(
									fjson_object_iter_peek_value(&amp;it)
									);
				} else if (strcmp(fjson_object_iter_peek_name(&amp;it),
							DOCKER_CONTAINER_CREATED_PARSE_NAME) == 0) {
					containerInfo.created =
						fjson_object_get_int64(
									fjson_object_iter_peek_value(&amp;it)
									);
				} else if (strcmp(fjson_object_iter_peek_name(&amp;it),
							DOCKER_CONTAINER_LABELS_PARSE_NAME) == 0) {
					containerInfo.json_str_labels =
						(uchar*) fjson_object_get_string(
									fjson_object_iter_peek_value(&amp;it)
									);
					DBGPRINTF(&quot;labels: %s\n&quot;, containerInfo.json_str_labels);
				}</B></FONT>
				fjson_object_iter_next(&amp;it);
			}

			if (containerId) {
				docker_cont_logs_inst_t *pInst = NULL;
				iRet = dockerContLogReqsGet(pInstances, &amp;pInst, containerId);
				if (iRet == RS_RET_NOT_FOUND) {
#ifdef USE_MULTI_LINE
					if (dockerContLogsInstNew(&amp;pInst, containerId, &amp;containerInfo, SubmitMsg2)
#else
					if (dockerContLogsInstNew(&amp;pInst, containerId, &amp;containerInfo, SubmitMsg)
#endif
							== RS_RET_OK) {
						if (pInstances-&gt;last_container_created &lt; containerInfo.created) {
							pInstances-&gt;last_container_created = containerInfo.created;
							if (pInstances-&gt;last_container_id) {
								free(pInstances-&gt;last_container_id);
							}
							pInstances-&gt;last_container_id = (uchar*)strdup(containerId);
							DBGPRINTF(&quot;last_container_id updated: ('%s', %u)\n&quot;,
									pInstances-&gt;last_container_id,
									(unsigned)pInstances-&gt;last_container_created);
						}
						CHKiRet(dockerContLogsInstSetUrlById(isInit, pInst,
									pInstances-&gt;curlm, containerId));
						CHKiRet(dockerContLogReqsAdd(pInstances, pInst));
					}
				}
			}
		}
	}

finalize_it:
	if (mut_locked) {
		pthread_mutex_unlock(&amp;pInstances-&gt;mut);
	}
	if (json_obj) {
		json_object_put(json_obj);
	}
	RETiRet;
}

static rsRetVal
getContainerIds(sbool isInit, docker_cont_log_instances_t *pInstances, const char* url) {
	DEFiRet;
	imdocker_req_t *req=NULL;

	CHKiRet(imdockerReqNew(&amp;req));

	CURLcode response = docker_get(req, url);
	if (response != CURLE_OK) {
		DBGPRINTF(&quot;%s() - curl response: %d\n&quot;, __FUNCTION__, response);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	CHKiRet(process_json(isInit, (const char*)req-&gt;buf-&gt;data, pInstances));

finalize_it:
	if (req) {
		imdockerReqDestruct(req);
	}
	RETiRet;
}

static rsRetVal
getContainerIdsAndAppend(sbool isInit, docker_cont_log_instances_t *pInstances) {
	DEFiRet;

	char url[256];
	const uchar* pApiAddr = (uchar*)&quot;http:&quot;;

	if (runModConf-&gt;dockerApiAddr) {
		pApiAddr = runModConf-&gt;dockerApiAddr;
	}

	/*
	 * TODO: consider if we really need 'isInit' parameter. I suspect we don't need it
	 * and i'm almost certain Travis CI will complain its not used.
	 */
	if (pInstances-&gt;last_container_id) {
		snprintf(url, sizeof(url), &quot;%s/%s/containers/json?%s&amp;filters={\&quot;since\&quot;:[\&quot;%s\&quot;]}&quot;,
				pApiAddr, runModConf-&gt;apiVersionStr, runModConf-&gt;listContainersOptions,
				pInstances-&gt;last_container_id);
	} else {
		snprintf(url, sizeof(url), &quot;%s/%s/containers/json?%s&quot;,
			pApiAddr, runModConf-&gt;apiVersionStr, runModConf-&gt;listContainersOptions);
	}
	DBGPRINTF(&quot;listcontainers url: %s\n&quot;, url);

	CHKiRet(getContainerIds(isInit, pInstances, (const char*)url));
	if (Debug) { dockerContLogReqsPrint(pInstances); }

finalize_it:
	RETiRet;
}

static void
cleanupCompletedContainerRequests(docker_cont_log_instances_t *pInstances) {
	// clean up
	int rc=0, msgs_left=0;
	CURLMsg *msg=NULL;
	CURL *pCurl;

	while ((msg = curl_multi_info_read(pInstances-&gt;curlm, &amp;msgs_left))) {
		if (msg-&gt;msg == CURLMSG_DONE) {
			pCurl = msg-&gt;easy_handle;
			rc = msg-&gt;data.result;
			if (rc != CURLE_OK) {
				STATSCOUNTER_INC(ctrCurlError, mutCtrCurlError);
				LogError(0, RS_RET_ERR, &quot;imdocker: %s() - curl error code: %d:%s\n&quot;,
						__FUNCTION__, rc, curl_multi_strerror(rc));
				continue;
			}

			CURLcode ccode;
			if (Debug) {
				long http_status=0;
				curl_easy_getinfo(pCurl, CURLINFO_RESPONSE_CODE, &amp;http_status);
				DBGPRINTF(&quot;http status: %lu\n&quot;, http_status);
			}
			curl_multi_remove_handle(pInstances-&gt;curlm, pCurl);

			const char* szContainerId = NULL;
			if ((ccode = curl_easy_getinfo(pCurl, CURLINFO_PRIVATE, &amp;szContainerId)) == CURLE_OK) {
				DBGPRINTF(&quot;container disconnected: %s\n&quot;, szContainerId);
				dockerContLogReqsRemove(pInstances, szContainerId);
				DBGPRINTF(&quot;container removed...\n&quot;);
			} else {
				LogError(0, RS_RET_ERR, &quot;imdocker: private data not found &quot;
						&quot;curl_easy_setopt(CURLINFO_PRIVATE) error - %d:%s\n&quot;,
						ccode, curl_easy_strerror(ccode));
				STATSCOUNTER_INC(ctrCurlError, mutCtrCurlError);
			}
		}
	}
}

static rsRetVal
processAndPollContainerLogs(docker_cont_log_instances_t *pInstances) {
	DEFiRet;
	int count=0;

	count = hashtable_count(pInstances-&gt;ht_container_log_insts);
	DBGPRINTF(&quot;%s() - container instances: %d\n&quot;, __FUNCTION__, count);

	int still_running=0;

	curl_multi_perform(pInstances-&gt;curlm, &amp;still_running);
	do {
		int numfds = 0;

		int res = curl_multi_wait(pInstances-&gt;curlm, NULL, 0, 1000, &amp;numfds);
		if (res != CURLM_OK) {
			LogError(0, RS_RET_ERR, &quot;error: curl_multi_wait() numfds=%d, res=%d:%s\n&quot;,
					numfds, res, curl_multi_strerror(res));
			return res;
		}

		int prev_still_running = still_running;
		curl_multi_perform(pInstances-&gt;curlm, &amp;still_running);

		if (prev_still_running &gt; still_running) {
			cleanupCompletedContainerRequests(pInstances);
		}

	} while (still_running &amp;&amp; glbl.GetGlobalInputTermState() == 0);

	cleanupCompletedContainerRequests(pInstances);

	RETiRet;
}

static void*
getContainersTask(void *pdata) {
	docker_cont_log_instances_t *pInstances = (docker_cont_log_instances_t*) pdata;

	while(glbl.GetGlobalInputTermState() == 0) {
		srSleep(runModConf-&gt;iPollInterval, 10);
		getContainerIdsAndAppend(false, pInstances);
	}
	return pdata;
}

/* This function is called to gather input. */
BEGINrunInput
	rsRetVal localRet = RS_RET_OK;
	docker_cont_log_instances_t *pInstances=NULL;
	pthread_t thrd_id; /* the worker's thread ID */
	pthread_attr_t thrd_attr;
	int get_containers_thread_initialized = 0;
	time_t now;
CODESTARTrunInput
	datetime.GetTime(&amp;now);

	CHKiRet(ratelimitNew(&amp;ratelimiter, &quot;imdocker&quot;, NULL));
	curl_global_init(CURL_GLOBAL_ALL);
	localRet = dockerContLogReqsNew(&amp;pInstances);
	if (localRet != RS_RET_OK) {
		return localRet;
	}
	pInstances-&gt;time_started = now;

	/* get all current containers now */
	CHKiRet(getContainerIdsAndAppend(true, pInstances));

	/* using default stacksize */
	CHKiConcCtrl(pthread_attr_init(&amp;thrd_attr));
	CHKiConcCtrl(pthread_create(&amp;thrd_id, &amp;thrd_attr, getContainersTask, pInstances));
	get_containers_thread_initialized = 1;

	while(glbl.GetGlobalInputTermState() == 0) {
		CHKiRet(processAndPollContainerLogs(pInstances));
		if (glbl.GetGlobalInputTermState() == 0) {
			/* exited from processAndPollContainerLogs, sleep before retrying */
			srSleep(1, 10);
		}
	}

finalize_it:
	if (get_containers_thread_initialized) {
		pthread_kill(thrd_id, SIGTTIN);
		pthread_join(thrd_id, NULL);
		pthread_attr_destroy(&amp;thrd_attr);
	}
	if (pInstances) {
		dockerContLogReqsDestruct(pInstances);
	}
	if (ratelimiter) {
		ratelimitDestruct(ratelimiter);
	}
ENDrunInput

BEGINwillRun
CODESTARTwillRun
ENDwillRun

BEGINafterRun
CODESTARTafterRun
ENDafterRun

BEGINmodExit
CODESTARTmodExit
	if(pInputName != NULL)
		prop.Destruct(&amp;pInputName);

	if(pLocalHostIP != NULL)
		prop.Destruct(&amp;pLocalHostIP);

	objRelease(parser, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
	objRelease(statsobj, CORE_COMPONENT);
	objRelease(datetime, CORE_COMPONENT);
ENDmodExit

BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature

BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt

BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr

	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	CHKiRet(objUse(parser, CORE_COMPONENT));

	DBGPRINTF(&quot;imdocker version %s initializing\n&quot;, VERSION);

	/* we need to create the inputName property (only once during our lifetime) */
	CHKiRet(prop.Construct(&amp;pInputName));
	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT(&quot;imdocker&quot;), sizeof(&quot;imdocker&quot;) - 1));
	CHKiRet(prop.ConstructFinalize(pInputName));

ENDmodInit
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmkubernetes.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* mmkubernetes.c
 * This is a message modification module. It uses metadata obtained
 * from the message to query Kubernetes and obtain additional metadata
 * relating to the container instance.
 *
 * Inspired by:
 * https://github.com/fabric8io/fluent-plugin-kubernetes_metadata_filter
 *
 * NOTE: read comments in module-template.h for details on the calling interface!
 *
 * Copyright 2016 Red Hat Inc.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* needed for asprintf */
#ifndef _GNU_SOURCE
#  define _GNU_SOURCE
#endif

#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;libestr.h&gt;
#include &lt;liblognorm.h&gt;
#include &lt;json.h&gt;
#include &lt;curl/curl.h&gt;
#include &lt;curl/easy.h&gt;
#include &lt;pthread.h&gt;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;statsobj.h&quot;
#include &quot;regexp.h&quot;
#include &quot;hashtable.h&quot;
#include &quot;hashtable_itr.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;unicode-helper.h&quot;
#include &quot;datetime.h&quot;

/* static data */
MODULE_TYPE_OUTPUT /* this is technically an output plugin */
MODULE_TYPE_KEEP /* releasing the module would cause a leak through libcurl */
MODULE_CNFNAME(&quot;mmkubernetes&quot;)
DEF_OMOD_STATIC_DATA
DEFobjCurrIf(regexp)
DEFobjCurrIf(statsobj)
DEFobjCurrIf(datetime)

#define HAVE_LOADSAMPLESFROMSTRING 1
#if defined(NO_LOADSAMPLESFROMSTRING)
#undef HAVE_LOADSAMPLESFROMSTRING
#endif
/* original from fluentd plugin:
 * 'var\.log\.containers\.(?&lt;pod_name&gt;[a-z0-9]([-a-z0-9]*[a-z0-9])?\
 *   (\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*)_(?&lt;namespace&gt;[^_]+)_\
 *   (?&lt;container_name&gt;.+)-(?&lt;docker_id&gt;[a-z0-9]{64})\.log$'
 * this is for _tag_ match, not actual filename match - in_tail turns filename
 * into a fluentd tag
 */
#define DFLT_FILENAME_LNRULES &quot;rule=:/var/log/containers/%pod_name:char-to:_%_&quot;\
	&quot;%namespace_name:char-to:_%_%container_name_and_id:char-to:.%.log&quot;
#define DFLT_FILENAME_RULEBASE &quot;/etc/rsyslog.d/k8s_filename.rulebase&quot;
/* original from fluentd plugin:
 *   '^(?&lt;name_prefix&gt;[^_]+)_(?&lt;container_name&gt;[^\._]+)\
 *     (\.(?&lt;container_hash&gt;[^_]+))?_(?&lt;pod_name&gt;[^_]+)_\
 *     (?&lt;namespace&gt;[^_]+)_[^_]+_[^_]+$'
 */
#define DFLT_CONTAINER_LNRULES &quot;rule=:%k8s_prefix:char-to:_%_%container_name:char-to:.%.&quot;\
	&quot;%container_hash:char-to:_%_&quot;\
	&quot;%pod_name:char-to:_%_%namespace_name:char-to:_%_%not_used_1:char-to:_%_%not_used_2:rest%\n&quot;\
	&quot;rule=:%k8s_prefix:char-to:_%_%container_name:char-to:_%_&quot;\
	&quot;%pod_name:char-to:_%_%namespace_name:char-to:_%_%not_used_1:char-to:_%_%not_used_2:rest%&quot;
#define DFLT_CONTAINER_RULEBASE &quot;/etc/rsyslog.d/k8s_container_name.rulebase&quot;
#define DFLT_SRCMD_PATH &quot;$!metadata!filename&quot;
#define DFLT_DSTMD_PATH &quot;$!&quot;
#define DFLT_DE_DOT 1 /* true */
#define DFLT_DE_DOT_SEPARATOR &quot;_&quot;
#define DFLT_CONTAINER_NAME &quot;$!CONTAINER_NAME&quot; /* name of variable holding CONTAINER_NAME value */
#define DFLT_CONTAINER_ID_FULL &quot;$!CONTAINER_ID_FULL&quot; /* name of variable holding CONTAINER_ID_FULL value */
#define DFLT_KUBERNETES_URL &quot;https://kubernetes.default.svc.cluster.local:443&quot;
#define DFLT_BUSY_RETRY_INTERVAL 5 /* retry every 5 seconds */
#define DFLT_SSL_PARTIAL_CHAIN 0 /* disallow X509_V_FLAG_PARTIAL_CHAIN by default */
#define DFLT_CACHE_ENTRY_TTL 3600 /* delete entries from the cache older than 3600 seconds */
#define DFLT_CACHE_EXPIRE_INTERVAL -1 /* delete all expired entries from the cache every N seconds
					 -1 disables cache expiration/ttl checking
					 0 means - run cache expiration for every record */

/* only support setting the partial chain flag on openssl platforms that have the define */
#if defined(ENABLE_OPENSSL) &amp;&amp; defined(X509_V_FLAG_PARTIAL_CHAIN)
#define SUPPORT_SSL_PARTIAL_CHAIN 1
#endif

struct cache_entry_s {
	time_t ttl; /* when this entry should expire */
	void *data; /* the user data */
};

static struct cache_s {
	const uchar *kbUrl;
	struct hashtable *mdHt;
	struct hashtable *nsHt;
	pthread_mutex_t *cacheMtx;
	int lastBusyTime; /* when we got the last busy response from kubernetes */
	time_t expirationTime; /* if cache expiration checking is enable, time to check for expiration */
} **caches;

typedef struct {
	int nmemb;
	uchar **patterns;
	regex_t *regexps;
} annotation_match_t;

/* module configuration data */
struct modConfData_s {
	rsconf_t *pConf;	/* our overall config object */
	uchar *kubernetesUrl;	/* scheme, host, port, and optional path prefix for Kubernetes API lookups */
	uchar *srcMetadataPath;	/* where to get data for kubernetes queries */
	uchar *dstMetadataPath;	/* where to put metadata obtained from kubernetes */
	uchar *caCertFile; /* File holding the CA cert (+optional chain) of CA that issued the Kubernetes server cert */
	uchar *myCertFile; /* File holding cert corresponding to private key used for client cert auth */
	uchar *myPrivKeyFile; /* File holding private key corresponding to cert used for client cert auth */
	sbool allowUnsignedCerts; /* For testing/debugging - do not check for CA certs (CURLOPT_SSL_VERIFYPEER FALSE) */
	sbool skipVerifyHost; /* For testing/debugging - skip cert hostname verify (CURLOPT_SSL_VERIFYHOST FALSE) */
	uchar *token; /* The token value to use to authenticate to Kubernetes - takes precedence over tokenFile */
	uchar *tokenFile; /* The file whose contents is the token value to use to authenticate to Kubernetes */
	sbool de_dot; /* If true (default), convert '.' characters in labels &amp; annotations to de_dot_separator */
	uchar *de_dot_separator; /* separator character (default '_') to use for de_dotting */
	size_t de_dot_separator_len; /* length of separator character */
	annotation_match_t annotation_match; /* annotation keys must match these to be included in record */
	char *fnRules; /* lognorm rules for container log filename match */
	uchar *fnRulebase; /* lognorm rulebase filename for container log filename match */
	char *contRules; /* lognorm rules for CONTAINER_NAME value match */
	uchar *contRulebase; /* lognorm rulebase filename for CONTAINER_NAME value match */
	int busyRetryInterval; /* how to handle 429 response - 0 means error, non-zero means retry every N seconds */
	sbool sslPartialChain; /* if true, allow using intermediate certs without root certs */
	int cacheEntryTTL; /* delete entries from the cache if they are older than this many seconds */
	int cacheExpireInterval; /* delete all expired entries from the cache every this many seconds */
};

/* action (instance) configuration data */
typedef struct _instanceData {
	uchar *kubernetesUrl;	/* scheme, host, port, and optional path prefix for Kubernetes API lookups */
	msgPropDescr_t *srcMetadataDescr;	/* where to get data for kubernetes queries */
	uchar *dstMetadataPath;	/* where to put metadata obtained from kubernetes */
	uchar *caCertFile; /* File holding the CA cert (+optional chain) of CA that issued the Kubernetes server cert */
	uchar *myCertFile; /* File holding cert corresponding to private key used for client cert auth */
	uchar *myPrivKeyFile; /* File holding private key corresponding to cert used for client cert auth */
	sbool allowUnsignedCerts; /* For testing/debugging - do not check for CA certs (CURLOPT_SSL_VERIFYPEER FALSE) */
	sbool skipVerifyHost; /* For testing/debugging - skip cert hostname verify (CURLOPT_SSL_VERIFYHOST FALSE) */
	uchar *token; /* The token value to use to authenticate to Kubernetes - takes precedence over tokenFile */
	uchar *tokenFile; /* The file whose contents is the token value to use to authenticate to Kubernetes */
	sbool de_dot; /* If true (default), convert '.' characters in labels &amp; annotations to de_dot_separator */
	uchar *de_dot_separator; /* separator character (default '_') to use for de_dotting */
	size_t de_dot_separator_len; /* length of separator character */
	annotation_match_t annotation_match; /* annotation keys must match these to be included in record */
	char *fnRules; /* lognorm rules for container log filename match */
	uchar *fnRulebase; /* lognorm rulebase filename for container log filename match */
	ln_ctx fnCtxln;	/**&lt; context to be used for liblognorm */
	char *contRules; /* lognorm rules for CONTAINER_NAME value match */
	uchar *contRulebase; /* lognorm rulebase filename for CONTAINER_NAME value match */
	ln_ctx contCtxln;	/**&lt; context to be used for liblognorm */
	msgPropDescr_t *contNameDescr; /* CONTAINER_NAME field */
	msgPropDescr_t *contIdFullDescr; /* CONTAINER_ID_FULL field */
	struct cache_s *cache;
	int busyRetryInterval; /* how to handle 429 response - 0 means error, non-zero means retry every N seconds */
	sbool sslPartialChain; /* if true, allow using intermediate certs without root certs */
	int cacheEntryTTL; /* delete entries from the cache if they are older than this many seconds */
	int cacheExpireInterval; /* delete all expired entries from the cache every this many seconds */
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
	CURL *curlCtx;
	struct curl_slist *curlHdr;
	char *curlRply;
	size_t curlRplyLen;
	statsobj_t *stats; /* stats for this instance */
	STATSCOUNTER_DEF(k8sRecordSeen, mutK8sRecordSeen);
	STATSCOUNTER_DEF(namespaceMetadataSuccess, mutNamespaceMetadataSuccess);
	STATSCOUNTER_DEF(namespaceMetadataNotFound, mutNamespaceMetadataNotFound);
	STATSCOUNTER_DEF(namespaceMetadataBusy, mutNamespaceMetadataBusy);
	STATSCOUNTER_DEF(namespaceMetadataError, mutNamespaceMetadataError);
	STATSCOUNTER_DEF(podMetadataSuccess, mutPodMetadataSuccess);
	STATSCOUNTER_DEF(podMetadataNotFound, mutPodMetadataNotFound);
	STATSCOUNTER_DEF(podMetadataBusy, mutPodMetadataBusy);
	STATSCOUNTER_DEF(podMetadataError, mutPodMetadataError);
	STATSCOUNTER_DEF(podCacheNumEntries, mutPodCacheNumEntries);
	STATSCOUNTER_DEF(namespaceCacheNumEntries, mutNamespaceCacheNumEntries);
	STATSCOUNTER_DEF(podCacheHits, mutPodCacheHits);
	STATSCOUNTER_DEF(namespaceCacheHits, mutNamespaceCacheHits);
	/* cache misses should correspond to metadata success, busy, etc. k8s api calls */
	STATSCOUNTER_DEF(podCacheMisses, mutPodCacheMisses);
	STATSCOUNTER_DEF(namespaceCacheMisses, mutNamespaceCacheMisses);
} wrkrInstanceData_t;

/* module parameters (v6 config format) */
static struct cnfparamdescr modpdescr[] = {
	{ &quot;kubernetesurl&quot;, eCmdHdlrString, 0 },
	{ &quot;srcmetadatapath&quot;, eCmdHdlrString, 0 },
	{ &quot;dstmetadatapath&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.cacert&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.mycert&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.myprivkey&quot;, eCmdHdlrString, 0 },
	{ &quot;allowunsignedcerts&quot;, eCmdHdlrBinary, 0 },
<A NAME="0"></A>	{ &quot;skipverifyhost&quot;, eCmdHdlrBinary, 0 },
	{ &quot;token&quot;, eCmdHdlrString, 0 },
	{ &quot;tokenfile&quot;, eCmdHdlrString, 0 },
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1929-0.html#0',2,'match1929-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	{ &quot;annotation_match&quot;, eCmdHdlrArray, 0 },
	{ &quot;de_dot&quot;, eCmdHdlrBinary, 0 },
	{ &quot;de_dot_separator&quot;, eCmdHdlrString, 0 },
	{ &quot;filenamerulebase&quot;, eCmdHdlrString, 0 },
	{ &quot;containerrulebase&quot;, eCmdHdlrString, 0 },
	{ &quot;busyretryinterval&quot;, eCmdHdlrInt, 0 },
	{ &quot;sslpartialchain&quot;, eCmdHdlrBinary, 0 },
	{ &quot;cacheentryttl&quot;, eCmdHdlrInt, 0 },
	{ &quot;cacheexpireinterval&quot;, eCmdHdlrInt, 0 }
#if HAVE_LOADSAMPLESFROMSTRING == 1
	,
	{ &quot;filenamerules&quot;, eCmdHdlrArray, 0 },
	{ &quot;containerrules&quot;, eCmdHdlrArray, 0 }
#endif
};
static struct cnfparamblk modpblk = {
	CNFPARAMBLK_VERSION,
	sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	modpdescr
};

/* action (instance) parameters (v6 config format) */
static struct cnfparamdescr actpdescr[] = {</B></FONT>
	{ &quot;kubernetesurl&quot;, eCmdHdlrString, 0 },
	{ &quot;srcmetadatapath&quot;, eCmdHdlrString, 0 },
	{ &quot;dstmetadatapath&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.cacert&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.mycert&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.myprivkey&quot;, eCmdHdlrString, 0 },
	{ &quot;allowunsignedcerts&quot;, eCmdHdlrBinary, 0 },
	{ &quot;skipverifyhost&quot;, eCmdHdlrBinary, 0 },
	{ &quot;token&quot;, eCmdHdlrString, 0 },
	{ &quot;tokenfile&quot;, eCmdHdlrString, 0 },
	{ &quot;annotation_match&quot;, eCmdHdlrArray, 0 },
	{ &quot;de_dot&quot;, eCmdHdlrBinary, 0 },
	{ &quot;de_dot_separator&quot;, eCmdHdlrString, 0 },
	{ &quot;filenamerulebase&quot;, eCmdHdlrString, 0 },
	{ &quot;containerrulebase&quot;, eCmdHdlrString, 0 },
	{ &quot;busyretryinterval&quot;, eCmdHdlrInt, 0 },
	{ &quot;sslpartialchain&quot;, eCmdHdlrBinary, 0 },
	{ &quot;cacheentryttl&quot;, eCmdHdlrInt, 0 },
	{ &quot;cacheexpireinterval&quot;, eCmdHdlrInt, 0 }
#if HAVE_LOADSAMPLESFROMSTRING == 1
	,
	{ &quot;filenamerules&quot;, eCmdHdlrArray, 0 },
	{ &quot;containerrules&quot;, eCmdHdlrArray, 0 }
#endif
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};

static modConfData_t *loadModConf = NULL;	/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;	/* modConf ptr to use for the current exec process */

static void free_annotationmatch(annotation_match_t *match) {
	if (match) {
		for(int ii = 0 ; ii &lt; match-&gt;nmemb; ++ii) {
			if (match-&gt;patterns)
				free(match-&gt;patterns[ii]);
			if (match-&gt;regexps)
				regexp.regfree(&amp;match-&gt;regexps[ii]);
		}
		free(match-&gt;patterns);
		match-&gt;patterns = NULL;
		free(match-&gt;regexps);
		match-&gt;regexps = NULL;
		match-&gt;nmemb = 0;
	}
}

static int init_annotationmatch(annotation_match_t *match, struct cnfarray *ar) {
	DEFiRet;

	match-&gt;nmemb = ar-&gt;nmemb;
	CHKmalloc(match-&gt;patterns = calloc(sizeof(uchar*), match-&gt;nmemb));
	CHKmalloc(match-&gt;regexps = calloc(sizeof(regex_t), match-&gt;nmemb));
	for(int jj = 0; jj &lt; ar-&gt;nmemb; ++jj) {
		int rexret = 0;
		match-&gt;patterns[jj] = (uchar*)es_str2cstr(ar-&gt;arr[jj], NULL);
		rexret = regexp.regcomp(&amp;match-&gt;regexps[jj],
				(char *)match-&gt;patterns[jj], REG_EXTENDED|REG_NOSUB);
		if (0 != rexret) {
			char errMsg[512];
			regexp.regerror(rexret, &amp;match-&gt;regexps[jj], errMsg, sizeof(errMsg));
			iRet = RS_RET_CONFIG_ERROR;
			LogError(0, iRet,
					&quot;error: could not compile annotation_match string [%s]&quot;
					&quot; into an extended regexp - %d: %s\n&quot;,
					match-&gt;patterns[jj], rexret, errMsg);
			break;
		}
	}
finalize_it:
	if (iRet)
		free_annotationmatch(match);
	RETiRet;
}

static int copy_annotationmatch(annotation_match_t *src, annotation_match_t *dest) {
	DEFiRet;

	dest-&gt;nmemb = src-&gt;nmemb;
	CHKmalloc(dest-&gt;patterns = malloc(sizeof(uchar*) * dest-&gt;nmemb));
	CHKmalloc(dest-&gt;regexps = calloc(sizeof(regex_t), dest-&gt;nmemb));
	for(int jj = 0 ; jj &lt; src-&gt;nmemb ; ++jj) {
		CHKmalloc(dest-&gt;patterns[jj] = (uchar*)strdup((char *)src-&gt;patterns[jj]));
		/* assumes was already successfully compiled */
		regexp.regcomp(&amp;dest-&gt;regexps[jj], (char *)dest-&gt;patterns[jj], REG_EXTENDED|REG_NOSUB);
	}
finalize_it:
	if (iRet)
	free_annotationmatch(dest);
	RETiRet;
}

/* takes a hash of annotations and returns another json object hash containing only the
 * keys that match - this logic is taken directly from fluent-plugin-kubernetes_metadata_filter
 * except that we do not add the key multiple times to the object to be returned
 */
static struct json_object *match_annotations(annotation_match_t *match,
		struct json_object *annotations) {
	struct json_object *ret = NULL;

	for (int jj = 0; jj &lt; match-&gt;nmemb; ++jj) {
		struct json_object_iterator it = json_object_iter_begin(annotations);
		struct json_object_iterator itEnd = json_object_iter_end(annotations);
		for (;!json_object_iter_equal(&amp;it, &amp;itEnd); json_object_iter_next(&amp;it)) {
			const char *const key = json_object_iter_peek_name(&amp;it);
			if (!ret || !fjson_object_object_get_ex(ret, key, NULL)) {
				if (!regexp.regexec(&amp;match-&gt;regexps[jj], key, 0, NULL, 0)) {
					if (!ret) {
						ret = json_object_new_object();
					}
					json_object_object_add(ret, key,
						json_object_get(json_object_iter_peek_value(&amp;it)));
				}
			}
		}
	}
	return ret;
}

/* This will take a hash of labels or annotations and will de_dot the keys.
 * It will return a brand new hash.  AFAICT, there is no safe way to
 * iterate over the hash while modifying it in place.
 */
static struct json_object *de_dot_json_object(struct json_object *jobj,
		const char *delim, size_t delim_len) {
	struct json_object *ret = NULL;
	struct json_object_iterator it = json_object_iter_begin(jobj);
	struct json_object_iterator itEnd = json_object_iter_end(jobj);
	es_str_t *new_es_key = NULL;
	DEFiRet;

	ret = json_object_new_object();
	while (!json_object_iter_equal(&amp;it, &amp;itEnd)) {
		const char *const key = json_object_iter_peek_name(&amp;it);
		const char *cc = strstr(key, &quot;.&quot;);
		if (NULL == cc) {
			json_object_object_add(ret, key,
					json_object_get(json_object_iter_peek_value(&amp;it)));
		} else {
			char *new_key = NULL;
			const char *prevcc = key;
			new_es_key = es_newStrFromCStr(key, (es_size_t)(cc-prevcc));
			while (cc) {
				if (es_addBuf(&amp;new_es_key, (char *)delim, (es_size_t)delim_len))
					ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
				cc += 1; /* one past . */
				prevcc = cc; /* beginning of next substring */
				if ((cc = strstr(prevcc, &quot;.&quot;)) || (cc = strchr(prevcc, '\0'))) {
					if (es_addBuf(&amp;new_es_key, (char *)prevcc, (es_size_t)(cc-prevcc)))
						ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
					if (!*cc)
						cc = NULL; /* EOS - done */
				}
			}
			new_key = es_str2cstr(new_es_key, NULL);
			es_deleteStr(new_es_key);
			new_es_key = NULL;
			json_object_object_add(ret, new_key,
					json_object_get(json_object_iter_peek_value(&amp;it)));
			free(new_key);
		}
		json_object_iter_next(&amp;it);
	}
finalize_it:
	if (iRet != RS_RET_OK) {
		json_object_put(ret);
		ret = NULL;
	}
	if (new_es_key)
		es_deleteStr(new_es_key);
	return ret;
}

/* given a &quot;metadata&quot; object field, do
 * - make sure &quot;annotations&quot; field has only the matching keys
 * - de_dot the &quot;labels&quot; and &quot;annotations&quot; fields keys
 * This modifies the jMetadata object in place
 */
static void parse_labels_annotations(struct json_object *jMetadata,
		annotation_match_t *match, sbool de_dot,
		const char *delim, size_t delim_len) {
	struct json_object *jo = NULL;

	if (fjson_object_object_get_ex(jMetadata, &quot;annotations&quot;, &amp;jo)) {
		if ((jo = match_annotations(match, jo)))
			json_object_object_add(jMetadata, &quot;annotations&quot;, jo);
		else
			json_object_object_del(jMetadata, &quot;annotations&quot;);
	}
	/* dedot labels and annotations */
	if (de_dot) {
		struct json_object *jo2 = NULL;
		if (fjson_object_object_get_ex(jMetadata, &quot;annotations&quot;, &amp;jo)) {
			if ((jo2 = de_dot_json_object(jo, delim, delim_len))) {
				json_object_object_add(jMetadata, &quot;annotations&quot;, jo2);
			}
		}
		if (fjson_object_object_get_ex(jMetadata, &quot;labels&quot;, &amp;jo)) {
			if ((jo2 = de_dot_json_object(jo, delim, delim_len))) {
				json_object_object_add(jMetadata, &quot;labels&quot;, jo2);
			}
		}
	}
}

#if HAVE_LOADSAMPLESFROMSTRING == 1
static int array_to_rules(struct cnfarray *ar, char **rules) {
	DEFiRet;
	es_str_t *tmpstr = NULL;
	es_size_t size = 0;

	if (rules == NULL)
		FINALIZE;
	*rules = NULL;
	if (!ar-&gt;nmemb)
		FINALIZE;
	for (int jj = 0; jj &lt; ar-&gt;nmemb; jj++)
		size += es_strlen(ar-&gt;arr[jj]);
	if (!size)
		FINALIZE;
	CHKmalloc(tmpstr = es_newStr(size));
	CHKiRet((es_addStr(&amp;tmpstr, ar-&gt;arr[0])));
	CHKiRet((es_addBufConstcstr(&amp;tmpstr, &quot;\n&quot;)));
	for(int jj=1; jj &lt; ar-&gt;nmemb; ++jj) {
		CHKiRet((es_addStr(&amp;tmpstr, ar-&gt;arr[jj])));
		CHKiRet((es_addBufConstcstr(&amp;tmpstr, &quot;\n&quot;)));
	}
	CHKiRet((es_addBufConstcstr(&amp;tmpstr, &quot;\0&quot;)));
	CHKmalloc(*rules = es_str2cstr(tmpstr, NULL));
finalize_it:
	if (tmpstr) {
		es_deleteStr(tmpstr);
	}
	if (iRet != RS_RET_OK) {
		free(*rules);
		*rules = NULL;
	}
	RETiRet;
}
#endif

/* callback for liblognorm error messages */
static void
errCallBack(void __attribute__((unused)) *cookie, const char *msg,
	    size_t __attribute__((unused)) lenMsg)
{
	LogError(0, RS_RET_ERR_LIBLOGNORM, &quot;liblognorm error: %s&quot;, msg);
}

static rsRetVal
set_lnctx(ln_ctx *ctxln, char *instRules, uchar *instRulebase, char *modRules, uchar *modRulebase)
{
	DEFiRet;
	if (ctxln == NULL)
		FINALIZE;
	CHKmalloc(*ctxln = ln_initCtx());
	ln_setErrMsgCB(*ctxln, errCallBack, NULL);
	if(instRules) {
#if HAVE_LOADSAMPLESFROMSTRING == 1
		if(ln_loadSamplesFromString(*ctxln, instRules) !=0) {
			LogError(0, RS_RET_NO_RULEBASE, &quot;error: normalization rules '%s' &quot;
					&quot;could not be loaded&quot;, instRules);
			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
		}
#else
		(void)instRules;
#endif
	} else if(instRulebase) {
		if(ln_loadSamples(*ctxln, (char*) instRulebase) != 0) {
			LogError(0, RS_RET_NO_RULEBASE, &quot;error: normalization rulebase '%s' &quot;
					&quot;could not be loaded&quot;, instRulebase);
			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
		}
	} else if(modRules) {
#if HAVE_LOADSAMPLESFROMSTRING == 1
		if(ln_loadSamplesFromString(*ctxln, modRules) !=0) {
			LogError(0, RS_RET_NO_RULEBASE, &quot;error: normalization rules '%s' &quot;
					&quot;could not be loaded&quot;, modRules);
			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
		}
#else
		(void)modRules;
#endif
	} else if(modRulebase) {
		if(ln_loadSamples(*ctxln, (char*) modRulebase) != 0) {
			LogError(0, RS_RET_NO_RULEBASE, &quot;error: normalization rulebase '%s' &quot;
					&quot;could not be loaded&quot;, modRulebase);
			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
		}
	}
finalize_it:
	if (iRet != RS_RET_OK){
		ln_exitCtx(*ctxln);
		*ctxln = NULL;
	}
	RETiRet;
}

BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
ENDbeginCnfLoad


BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
	FILE *fp = NULL;
	int ret;
	char errStr[1024];
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;mmkubernetes: &quot;
			&quot;error processing module config parameters [module(...)]&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf(&quot;module (global) param blk for mmkubernetes:\n&quot;);
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	loadModConf-&gt;de_dot = DFLT_DE_DOT;
	loadModConf-&gt;busyRetryInterval = DFLT_BUSY_RETRY_INTERVAL;
	loadModConf-&gt;sslPartialChain = DFLT_SSL_PARTIAL_CHAIN;
	loadModConf-&gt;cacheEntryTTL = DFLT_CACHE_ENTRY_TTL;
	loadModConf-&gt;cacheExpireInterval = DFLT_CACHE_EXPIRE_INTERVAL;
<A NAME="1"></A>	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed) {
			continue;
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1929-0.html#1',2,'match1929-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		} else if(!strcmp(modpblk.descr[i].name, &quot;kubernetesurl&quot;)) {
			free(loadModConf-&gt;kubernetesUrl);
			loadModConf-&gt;kubernetesUrl = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, &quot;srcmetadatapath&quot;)) {
			free(loadModConf-&gt;srcMetadataPath);
			loadModConf-&gt;srcMetadataPath = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			/* todo: sanitize the path */
		} else if(!strcmp(modpblk.descr[i].name, &quot;dstmetadatapath&quot;)) {
			free(loadModConf-&gt;dstMetadataPath);
			loadModConf-&gt;dstMetadataPath = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			/* todo: sanitize the path */
		} else if(!strcmp(modpblk.descr[i].name, &quot;tls.cacert&quot;)) {
			free(loadModConf-&gt;caCertFile);
			loadModConf-&gt;caCertFile = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
			fp = fopen((const char*)loadModConf-&gt;caCertFile, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						&quot;error: 'tls.cacert' file %s couldn't be accessed: %s\n&quot;,
						loadModConf-&gt;caCertFile, errStr);
				ABORT_FINALIZE(iRet);
			} else {
				fclose(fp);
				fp = NULL;
			}
		} else if(!strcmp(modpblk.descr[i].name, &quot;tls.mycert&quot;)) {
			free(loadModConf-&gt;myCertFile);
			loadModConf-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)loadModConf-&gt;myCertFile, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						&quot;error: 'tls.mycert' file %s couldn't be accessed: %s\n&quot;,
						loadModConf-&gt;myCertFile, errStr);
			} else {
				fclose(fp);
				fp = NULL;
			}
		} else if(!strcmp(modpblk.descr[i].name, &quot;tls.myprivkey&quot;)) {
			loadModConf-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)loadModConf-&gt;myPrivKeyFile, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						&quot;error: 'tls.myprivkey' file %s couldn't be accessed: %s\n&quot;,
						loadModConf-&gt;myPrivKeyFile, errStr);
			} else {
				fclose(fp);
				fp = NULL;
			}
		} else if(!strcmp(modpblk.descr[i].name, &quot;allowunsignedcerts&quot;)) {
<A NAME="4"></A>			loadModConf-&gt;allowUnsignedCerts = pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;skipverifyhost&quot;)) {
			loadModConf-&gt;skipVerifyHost = pvals[i].val.d.n;
<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1929-0.html#4',2,'match1929-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		} else if(!strcmp(modpblk.descr[i].name, &quot;token&quot;)) {
			free(loadModConf-&gt;token);
			loadModConf-&gt;token = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, &quot;tokenfile&quot;)) {
			free(loadModConf-&gt;tokenFile);
			loadModConf-&gt;tokenFile = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)loadModConf-&gt;tokenFile, &quot;r&quot;);</B></FONT>
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						&quot;error: token file %s couldn't be accessed: %s\n&quot;,
						loadModConf-&gt;tokenFile, errStr);
				ABORT_FINALIZE(iRet);
			} else {
				fclose(fp);
				fp = NULL;
			}
		} else if(!strcmp(modpblk.descr[i].name, &quot;annotation_match&quot;)) {
			free_annotationmatch(&amp;loadModConf-&gt;annotation_match);
			if ((ret = init_annotationmatch(&amp;loadModConf-&gt;annotation_match, pvals[i].val.d.ar)))
				ABORT_FINALIZE(ret);
		} else if(!strcmp(modpblk.descr[i].name, &quot;de_dot&quot;)) {
			loadModConf-&gt;de_dot = pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;de_dot_separator&quot;)) {
			free(loadModConf-&gt;de_dot_separator);
			loadModConf-&gt;de_dot_separator = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
#if HAVE_LOADSAMPLESFROMSTRING == 1
		} else if(!strcmp(modpblk.descr[i].name, &quot;filenamerules&quot;)) {
			free(loadModConf-&gt;fnRules);
			CHKiRet((array_to_rules(pvals[i].val.d.ar, &amp;loadModConf-&gt;fnRules)));
#endif
		} else if(!strcmp(modpblk.descr[i].name, &quot;filenamerulebase&quot;)) {
			free(loadModConf-&gt;fnRulebase);
			loadModConf-&gt;fnRulebase = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)loadModConf-&gt;fnRulebase, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						&quot;error: filenamerulebase file %s couldn't be accessed: %s\n&quot;,
						loadModConf-&gt;fnRulebase, errStr);
				ABORT_FINALIZE(iRet);
			} else {
				fclose(fp);
				fp = NULL;
			}
#if HAVE_LOADSAMPLESFROMSTRING == 1
		} else if(!strcmp(modpblk.descr[i].name, &quot;containerrules&quot;)) {
			free(loadModConf-&gt;contRules);
			CHKiRet((array_to_rules(pvals[i].val.d.ar, &amp;loadModConf-&gt;contRules)));
#endif
		} else if(!strcmp(modpblk.descr[i].name, &quot;containerrulebase&quot;)) {
			free(loadModConf-&gt;contRulebase);
			loadModConf-&gt;contRulebase = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)loadModConf-&gt;contRulebase, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						&quot;error: containerrulebase file %s couldn't be accessed: %s\n&quot;,
						loadModConf-&gt;contRulebase, errStr);
				ABORT_FINALIZE(iRet);
<A NAME="2"></A>			} else {
				fclose(fp);
				fp = NULL;
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1929-0.html#2',2,'match1929-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>			}
		} else if(!strcmp(modpblk.descr[i].name, &quot;busyretryinterval&quot;)) {
			loadModConf-&gt;busyRetryInterval = pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;sslpartialchain&quot;)) {
#if defined(SUPPORT_SSL_PARTIAL_CHAIN)
			loadModConf-&gt;sslPartialChain = pvals[i].val.d.n;
#else
			LogMsg(0, RS_RET_VALUE_NOT_IN_THIS_MODE, LOG_INFO,
					&quot;sslpartialchain is only supported for OpenSSL\n&quot;);
#endif
		} else if(!strcmp(modpblk.descr[i].name, &quot;cacheentryttl&quot;)) {
			loadModConf-&gt;cacheEntryTTL = pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;cacheexpireinterval&quot;)) {</B></FONT>
			loadModConf-&gt;cacheExpireInterval = pvals[i].val.d.n;
		} else {
			dbgprintf(&quot;mmkubernetes: program error, non-handled &quot;
				&quot;param '%s' in module() block\n&quot;, modpblk.descr[i].name);
			/* todo: error message? */
		}
	}

#if HAVE_LOADSAMPLESFROMSTRING == 1
	if (loadModConf-&gt;fnRules &amp;&amp; loadModConf-&gt;fnRulebase) {
		LogError(0, RS_RET_CONFIG_ERROR,
				&quot;mmkubernetes: only 1 of filenamerules or filenamerulebase may be used&quot;);
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
	if (loadModConf-&gt;contRules &amp;&amp; loadModConf-&gt;contRulebase) {
		LogError(0, RS_RET_CONFIG_ERROR,
				&quot;mmkubernetes: only 1 of containerrules or containerrulebase may be used&quot;);
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
#endif

	if ((loadModConf-&gt;cacheExpireInterval &gt; -1)) {
		if ((loadModConf-&gt;cacheEntryTTL &lt; 0)) {
			LogError(0, RS_RET_CONFIG_ERROR,
					&quot;mmkubernetes: cacheentryttl value [%d] is invalid - &quot;
					&quot;value must be 0 or greater&quot;,
					loadModConf-&gt;cacheEntryTTL);
			ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
		}
	}

	/* set defaults */
	if(loadModConf-&gt;srcMetadataPath == NULL)
		loadModConf-&gt;srcMetadataPath = (uchar *) strdup(DFLT_SRCMD_PATH);
	if(loadModConf-&gt;dstMetadataPath == NULL)
		loadModConf-&gt;dstMetadataPath = (uchar *) strdup(DFLT_DSTMD_PATH);
	if(loadModConf-&gt;de_dot_separator == NULL)
		loadModConf-&gt;de_dot_separator = (uchar *) strdup(DFLT_DE_DOT_SEPARATOR);
	if(loadModConf-&gt;de_dot_separator)
		loadModConf-&gt;de_dot_separator_len = strlen((const char *)loadModConf-&gt;de_dot_separator);
#if HAVE_LOADSAMPLESFROMSTRING == 1
	if (loadModConf-&gt;fnRules == NULL &amp;&amp; loadModConf-&gt;fnRulebase == NULL)
		loadModConf-&gt;fnRules = strdup(DFLT_FILENAME_LNRULES);
	if (loadModConf-&gt;contRules == NULL &amp;&amp; loadModConf-&gt;contRulebase == NULL)
		loadModConf-&gt;contRules = strdup(DFLT_CONTAINER_LNRULES);
#else
	if (loadModConf-&gt;fnRulebase == NULL)
		loadModConf-&gt;fnRulebase = (uchar *)strdup(DFLT_FILENAME_RULEBASE);
	if (loadModConf-&gt;contRulebase == NULL)
		loadModConf-&gt;contRulebase = (uchar *)strdup(DFLT_CONTAINER_RULEBASE);
#endif
	caches = calloc(1, sizeof(struct cache_s *));

finalize_it:
	if (fp)
		fclose(fp);
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf


BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance


BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;kubernetesUrl);
	msgPropDescrDestruct(pData-&gt;srcMetadataDescr);
	free(pData-&gt;srcMetadataDescr);
	free(pData-&gt;dstMetadataPath);
	free(pData-&gt;caCertFile);
	free(pData-&gt;myCertFile);
	free(pData-&gt;myPrivKeyFile);
	free(pData-&gt;token);
	free(pData-&gt;tokenFile);
	free(pData-&gt;fnRules);
	free(pData-&gt;fnRulebase);
	ln_exitCtx(pData-&gt;fnCtxln);
	free(pData-&gt;contRules);
	free(pData-&gt;contRulebase);
	ln_exitCtx(pData-&gt;contCtxln);
	free_annotationmatch(&amp;pData-&gt;annotation_match);
	free(pData-&gt;de_dot_separator);
	msgPropDescrDestruct(pData-&gt;contNameDescr);
	free(pData-&gt;contNameDescr);
	msgPropDescrDestruct(pData-&gt;contIdFullDescr);
	free(pData-&gt;contIdFullDescr);
ENDfreeInstance

static size_t curlCB(char *data, size_t size, size_t nmemb, void *usrptr)
{
	DEFiRet;
	wrkrInstanceData_t *pWrkrData = (wrkrInstanceData_t *) usrptr;
	char * buf;
	size_t newlen;

	newlen = pWrkrData-&gt;curlRplyLen + size * nmemb;
	CHKmalloc(buf = realloc(pWrkrData-&gt;curlRply, newlen));
	memcpy(buf + pWrkrData-&gt;curlRplyLen, data, size * nmemb);
	pWrkrData-&gt;curlRply = buf;
	pWrkrData-&gt;curlRplyLen = newlen;

finalize_it:
	if (iRet != RS_RET_OK) {
		return 0;
	}
	return size * nmemb;
}

#if defined(SUPPORT_SSL_PARTIAL_CHAIN)
static CURLcode set_ssl_partial_chain(CURL *curl, void *ssl_ctx, void *userptr)
{
	(void)userptr; /* currently unused */
	CURLcode rv = CURLE_ABORTED_BY_CALLBACK;
	X509_STORE *store = NULL;

	store = SSL_CTX_get_cert_store((SSL_CTX *)ssl_ctx);
	if(!store)
		goto finalize_it;
	if(!X509_STORE_set_flags(store, X509_V_FLAG_PARTIAL_CHAIN))
		goto finalize_it;
	rv = CURLE_OK;
finalize_it:
	return rv;
}
#endif

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	CURL *ctx;
	struct curl_slist *hdr = NULL;
	char *tokenHdr = NULL;
	FILE *fp = NULL;
	char *token = NULL;
	char *statsName = NULL;

	CHKiRet(statsobj.Construct(&amp;(pWrkrData-&gt;stats)));
	if ((-1 == asprintf(&amp;statsName, &quot;mmkubernetes(%s)&quot;, pWrkrData-&gt;pData-&gt;kubernetesUrl)) ||
		(!statsName)) {
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}
	CHKiRet(statsobj.SetName(pWrkrData-&gt;stats, (uchar *)statsName));
	free(statsName);
	statsName = NULL;
	CHKiRet(statsobj.SetOrigin(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;mmkubernetes&quot;)));
	STATSCOUNTER_INIT(pWrkrData-&gt;k8sRecordSeen, pWrkrData-&gt;mutK8sRecordSeen);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;recordseen&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;k8sRecordSeen)));
	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceMetadataSuccess, pWrkrData-&gt;mutNamespaceMetadataSuccess);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;namespacemetadatasuccess&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceMetadataSuccess)));
	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceMetadataNotFound, pWrkrData-&gt;mutNamespaceMetadataNotFound);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;namespacemetadatanotfound&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceMetadataNotFound)));
	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceMetadataBusy, pWrkrData-&gt;mutNamespaceMetadataBusy);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;namespacemetadatabusy&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceMetadataBusy)));
	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceMetadataError, pWrkrData-&gt;mutNamespaceMetadataError);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;namespacemetadataerror&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceMetadataError)));
	STATSCOUNTER_INIT(pWrkrData-&gt;podMetadataSuccess, pWrkrData-&gt;mutPodMetadataSuccess);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;podmetadatasuccess&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podMetadataSuccess)));
	STATSCOUNTER_INIT(pWrkrData-&gt;podMetadataNotFound, pWrkrData-&gt;mutPodMetadataNotFound);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;podmetadatanotfound&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podMetadataNotFound)));
	STATSCOUNTER_INIT(pWrkrData-&gt;podMetadataBusy, pWrkrData-&gt;mutPodMetadataBusy);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;podmetadatabusy&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podMetadataBusy)));
	STATSCOUNTER_INIT(pWrkrData-&gt;podMetadataError, pWrkrData-&gt;mutPodMetadataError);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;podmetadataerror&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podMetadataError)));
	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceCacheNumEntries, pWrkrData-&gt;mutNamespaceCacheNumEntries);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;namespacecachenumentries&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceCacheNumEntries)));
	STATSCOUNTER_INIT(pWrkrData-&gt;podCacheNumEntries, pWrkrData-&gt;mutPodCacheNumEntries);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;podcachenumentries&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podCacheNumEntries)));
	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceCacheHits, pWrkrData-&gt;mutNamespaceCacheHits);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;namespacecachehits&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceCacheHits)));
	STATSCOUNTER_INIT(pWrkrData-&gt;podCacheHits, pWrkrData-&gt;mutPodCacheHits);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;podcachehits&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podCacheHits)));
	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceCacheMisses, pWrkrData-&gt;mutNamespaceCacheMisses);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;namespacecachemisses&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceCacheMisses)));
	STATSCOUNTER_INIT(pWrkrData-&gt;podCacheMisses, pWrkrData-&gt;mutPodCacheMisses);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT(&quot;podcachemisses&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podCacheMisses)));
	CHKiRet(statsobj.ConstructFinalize(pWrkrData-&gt;stats));

	hdr = curl_slist_append(hdr, &quot;Content-Type: text/json; charset=utf-8&quot;);
	if (pWrkrData-&gt;pData-&gt;token) {
		if ((-1 == asprintf(&amp;tokenHdr, &quot;Authorization: Bearer %s&quot;, pWrkrData-&gt;pData-&gt;token)) ||
			(!tokenHdr)) {
			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
		}
	} else if (pWrkrData-&gt;pData-&gt;tokenFile) {
		struct stat statbuf;
		fp = fopen((const char*)pWrkrData-&gt;pData-&gt;tokenFile, &quot;r&quot;);
		if (fp &amp;&amp; !fstat(fileno(fp), &amp;statbuf)) {
			size_t bytesread;
			CHKmalloc(token = malloc((statbuf.st_size+1)*sizeof(char)));
			if (0 &lt; (bytesread = fread(token, sizeof(char), statbuf.st_size, fp))) {
				token[bytesread] = '\0';
				if ((-1 == asprintf(&amp;tokenHdr, &quot;Authorization: Bearer %s&quot;, token)) ||
					(!tokenHdr)) {
					ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
				}
			}
			free(token);
			token = NULL;
		}
		if (fp) {
			fclose(fp);
			fp = NULL;
		}
	}
	if (tokenHdr) {
		hdr = curl_slist_append(hdr, tokenHdr);
		free(tokenHdr);
	}
	pWrkrData-&gt;curlHdr = hdr;
	ctx = curl_easy_init();
	curl_easy_setopt(ctx, CURLOPT_HTTPHEADER, hdr);
	curl_easy_setopt(ctx, CURLOPT_WRITEFUNCTION, curlCB);
	curl_easy_setopt(ctx, CURLOPT_WRITEDATA, pWrkrData);
	if(pWrkrData-&gt;pData-&gt;caCertFile)
		curl_easy_setopt(ctx, CURLOPT_CAINFO, pWrkrData-&gt;pData-&gt;caCertFile);
	if(pWrkrData-&gt;pData-&gt;myCertFile)
		curl_easy_setopt(ctx, CURLOPT_SSLCERT, pWrkrData-&gt;pData-&gt;myCertFile);
	if(pWrkrData-&gt;pData-&gt;myPrivKeyFile)
		curl_easy_setopt(ctx, CURLOPT_SSLKEY, pWrkrData-&gt;pData-&gt;myPrivKeyFile);
	if(pWrkrData-&gt;pData-&gt;allowUnsignedCerts)
		curl_easy_setopt(ctx, CURLOPT_SSL_VERIFYPEER, 0);
	if(pWrkrData-&gt;pData-&gt;skipVerifyHost)
		curl_easy_setopt(ctx, CURLOPT_SSL_VERIFYHOST, 0);
#if defined(SUPPORT_SSL_PARTIAL_CHAIN)
	if(pWrkrData-&gt;pData-&gt;sslPartialChain) {
		curl_easy_setopt(ctx, CURLOPT_SSL_CTX_FUNCTION, set_ssl_partial_chain);
		curl_easy_setopt(ctx, CURLOPT_SSL_CTX_DATA, NULL);
	}
#endif
	pWrkrData-&gt;curlCtx = ctx;
finalize_it:
	free(token);
	free(statsName);
	if ((iRet != RS_RET_OK) &amp;&amp; pWrkrData-&gt;stats) {
		statsobj.Destruct(&amp;(pWrkrData-&gt;stats));
	}
	if (fp) {
		fclose(fp);
	}
ENDcreateWrkrInstance


BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	curl_easy_cleanup(pWrkrData-&gt;curlCtx);
	curl_slist_free_all(pWrkrData-&gt;curlHdr);
	statsobj.Destruct(&amp;(pWrkrData-&gt;stats));
ENDfreeWrkrInstance


/* next function is work-around to avoid type-unsafe casts. It looks
 * like not really needed in practice, but gcc 8 complains and doing
 * it 100% correct for sure does not hurt ;-) -- rgerhards, 2018-07-19
 */
static void
hashtable_json_object_put(void *jso)
{
	json_object_put((struct fjson_object *)jso);
}

static void
cache_entry_free(struct cache_entry_s *cache_entry)
{
	if (NULL != cache_entry) {
		if (cache_entry-&gt;data) {
			hashtable_json_object_put(cache_entry-&gt;data);
			cache_entry-&gt;data = NULL;
		}
		free(cache_entry);
	}
}

static void
cache_entry_free_raw(void *cache_entry_void)
{
	cache_entry_free((struct cache_entry_s *)cache_entry_void);
}

static struct cache_s *
cacheNew(instanceData *pData)
{
	DEFiRet;
	struct cache_s *cache = NULL;
	time_t now;
	int need_mutex_destroy = 0;

	CHKmalloc(cache = (struct cache_s *)calloc(1, sizeof(struct cache_s)));
	CHKmalloc(cache-&gt;cacheMtx = (pthread_mutex_t *)malloc(sizeof(pthread_mutex_t)));
	CHKmalloc(cache-&gt;mdHt = create_hashtable(100, hash_from_string,
		key_equals_string, cache_entry_free_raw));
	CHKmalloc(cache-&gt;nsHt = create_hashtable(100, hash_from_string,
		key_equals_string, cache_entry_free_raw));
	CHKiConcCtrl(pthread_mutex_init(cache-&gt;cacheMtx, NULL));
	need_mutex_destroy = 1;
	datetime.GetTime(&amp;now);
	cache-&gt;kbUrl = pData-&gt;kubernetesUrl;
	cache-&gt;expirationTime = 0;
	if (pData-&gt;cacheExpireInterval &gt; -1)
		cache-&gt;expirationTime = pData-&gt;cacheExpireInterval + pData-&gt;cacheEntryTTL + now;
	cache-&gt;lastBusyTime = 0;
	dbgprintf(&quot;mmkubernetes: created cache mdht [%p] nsht [%p]\n&quot;,
			cache-&gt;mdHt, cache-&gt;nsHt);

finalize_it:
	if (iRet != RS_RET_OK) {
	        LogError(errno, iRet, &quot;mmkubernetes: cacheNew: unable to create metadata cache for %s&quot;,
	                 pData-&gt;kubernetesUrl);
		if (cache) {
			if (cache-&gt;mdHt)
				hashtable_destroy(cache-&gt;mdHt, 1);
			if (cache-&gt;nsHt)
				hashtable_destroy(cache-&gt;nsHt, 1);
			if (cache-&gt;cacheMtx) {
				if (need_mutex_destroy)
					pthread_mutex_destroy(cache-&gt;cacheMtx);
				free(cache-&gt;cacheMtx);
			}
			free(cache);
			cache = NULL;
		}
	}
	return cache;
}


static void cacheFree(struct cache_s *cache)
{
	hashtable_destroy(cache-&gt;mdHt, 1);
	hashtable_destroy(cache-&gt;nsHt, 1);
	pthread_mutex_destroy(cache-&gt;cacheMtx);
	free(cache-&gt;cacheMtx);
	free(cache);
}

/* must be called with cache-&gt;cacheMtx held */
/* assumes caller has reference to jso (json_object_get or is a new object) */
static struct cache_entry_s *cache_entry_new(time_t ttl, struct fjson_object *jso)
{
	DEFiRet;
	struct cache_entry_s *cache_entry = NULL;

	CHKmalloc(cache_entry = malloc(sizeof(struct cache_entry_s)));
	cache_entry-&gt;ttl = ttl;
	cache_entry-&gt;data = (void *)jso;
finalize_it:
	if (iRet) {
		free(cache_entry);
		cache_entry = NULL;
	}
	return cache_entry;
}

static int cache_delete_expired_entries(wrkrInstanceData_t *pWrkrData, int isnsmd, time_t now)
{
	struct hashtable *ht = isnsmd ? pWrkrData-&gt;pData-&gt;cache-&gt;nsHt : pWrkrData-&gt;pData-&gt;cache-&gt;mdHt;
	struct hashtable_itr *itr = NULL;
	int more;

	if ((pWrkrData-&gt;pData-&gt;cacheExpireInterval &lt; 0) || (now &lt; pWrkrData-&gt;pData-&gt;cache-&gt;expirationTime)) {
		return 0; /* not enabled or not time yet */
	}

	/* set next expiration time */
	pWrkrData-&gt;pData-&gt;cache-&gt;expirationTime = now + pWrkrData-&gt;pData-&gt;cacheExpireInterval;

	if (hashtable_count(ht) &lt; 1)
		return 1; /* expire interval hit but nothing to do */

	itr = hashtable_iterator(ht);
	if (NULL == itr)
		return 1; /* expire interval hit but nothing to do - err? */

	do {
		struct cache_entry_s *cache_entry = (struct cache_entry_s *)hashtable_iterator_value(itr);

		if (now &gt;= cache_entry-&gt;ttl) {
			cache_entry_free(cache_entry);
			if (isnsmd) {
				STATSCOUNTER_DEC(pWrkrData-&gt;namespaceCacheNumEntries,
						 pWrkrData-&gt;mutNamespaceCacheNumEntries);
			} else {
				STATSCOUNTER_DEC(pWrkrData-&gt;podCacheNumEntries,
						 pWrkrData-&gt;mutPodCacheNumEntries);
			}
			more = hashtable_iterator_remove(itr);
		} else {
			more = hashtable_iterator_advance(itr);
		}
	} while (more);
	free(itr);
	dbgprintf(&quot;mmkubernetes: cache_delete_expired_entries: cleaned [%s] cache - size is now [%llu]\n&quot;,
		  isnsmd ? &quot;namespace&quot; : &quot;pod&quot;,
		  isnsmd ? pWrkrData-&gt;namespaceCacheNumEntries : pWrkrData-&gt;podCacheNumEntries);
	return 1;
}

/* must be called with cache-&gt;cacheMtx held */
static struct fjson_object *
cache_entry_get(wrkrInstanceData_t *pWrkrData,
		int isnsmd, const char *key, time_t now)
{
	struct fjson_object *jso = NULL;
	struct cache_entry_s *cache_entry = NULL;
	int checkttl = 1;
	struct hashtable *ht = isnsmd ? pWrkrData-&gt;pData-&gt;cache-&gt;nsHt : pWrkrData-&gt;pData-&gt;cache-&gt;mdHt;

	/* see if it is time for a general cache expiration */
	if (cache_delete_expired_entries(pWrkrData, isnsmd, now))
		checkttl = 0; /* no need to check ttl now */
	cache_entry = (struct cache_entry_s *)hashtable_search(ht, (void *)key);
	if (cache_entry &amp;&amp; checkttl &amp;&amp; (now &gt;= cache_entry-&gt;ttl)) {
		cache_entry = (struct cache_entry_s *)hashtable_remove(ht, (void *)key);
		if (isnsmd) {
			STATSCOUNTER_DEC(pWrkrData-&gt;namespaceCacheNumEntries,
					 pWrkrData-&gt;mutNamespaceCacheNumEntries);
		} else {
			STATSCOUNTER_DEC(pWrkrData-&gt;podCacheNumEntries,
					 pWrkrData-&gt;mutPodCacheNumEntries);
		}
		cache_entry_free(cache_entry);
		cache_entry = NULL;
	}
	if (cache_entry) {
		jso = (struct fjson_object *)cache_entry-&gt;data;
		if (isnsmd) {
			STATSCOUNTER_INC(pWrkrData-&gt;namespaceCacheHits,
					 pWrkrData-&gt;mutNamespaceCacheHits);
		} else {
			STATSCOUNTER_INC(pWrkrData-&gt;podCacheHits,
					 pWrkrData-&gt;mutPodCacheHits);
		}
		dbgprintf(&quot;mmkubernetes: cache_entry_get: cache hit for [%s] cache key [%s] - hits is now [%llu]\n&quot;,
			  isnsmd ? &quot;namespace&quot; : &quot;pod&quot;, key,
			  isnsmd ? pWrkrData-&gt;namespaceCacheHits : pWrkrData-&gt;podCacheHits);
	} else {
		if (isnsmd) {
			STATSCOUNTER_INC(pWrkrData-&gt;namespaceCacheMisses,
					 pWrkrData-&gt;mutNamespaceCacheMisses);
		} else {
			STATSCOUNTER_INC(pWrkrData-&gt;podCacheMisses,
					 pWrkrData-&gt;mutPodCacheMisses);
		}
		dbgprintf(&quot;mmkubernetes: cache_entry_get: cache miss for [%s] cache key [%s] - misses is now [%llu]\n&quot;,
			  isnsmd ? &quot;namespace&quot; : &quot;pod&quot;, key,
			  isnsmd ? pWrkrData-&gt;namespaceCacheMisses : pWrkrData-&gt;podCacheMisses);
	}

	return jso;
}

/* must be called with cache-&gt;cacheMtx held */
/* key is passed in - caller must copy or otherwise ensure it is ok to pass off
 * ownership
 */
static rsRetVal
cache_entry_add(wrkrInstanceData_t *pWrkrData,
		int isnsmd, const char *key, struct fjson_object *jso, time_t now, const int bDupKey)
{
	DEFiRet;
	struct cache_entry_s *cache_entry = NULL;
	struct hashtable *ht = isnsmd ? pWrkrData-&gt;pData-&gt;cache-&gt;nsHt : pWrkrData-&gt;pData-&gt;cache-&gt;mdHt;

	/* see if it is time for a general cache expiration */
	(void)cache_delete_expired_entries(pWrkrData, isnsmd, now);
	CHKmalloc(cache_entry = cache_entry_new(now + pWrkrData-&gt;pData-&gt;cacheEntryTTL, jso));
	if (cache_entry) {
		if (!hashtable_insert(ht, (void *)(bDupKey ? strdup(key) : key), cache_entry))
			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);

		if (isnsmd) {
			STATSCOUNTER_INC(pWrkrData-&gt;namespaceCacheNumEntries,
					 pWrkrData-&gt;mutNamespaceCacheNumEntries);
		} else {
			STATSCOUNTER_INC(pWrkrData-&gt;podCacheNumEntries,
					 pWrkrData-&gt;mutPodCacheNumEntries);
		}
		cache_entry = NULL;
	}
finalize_it:
	if (cache_entry)
		cache_entry_free(cache_entry);
	return iRet;
}

/* must be called with cache-&gt;cacheMtx held */
static struct fjson_object *cache_entry_get_md(wrkrInstanceData_t *pWrkrData, const char *key, time_t now)
{
	return cache_entry_get(pWrkrData, 0, key, now);
}

/* must be called with cache-&gt;cacheMtx held */
static struct fjson_object *cache_entry_get_nsmd(wrkrInstanceData_t *pWrkrData, const char *key, time_t now)
{
	return cache_entry_get(pWrkrData, 1, key, now);
}

/* must be called with cache-&gt;cacheMtx held */
static rsRetVal cache_entry_add_md(wrkrInstanceData_t *pWrkrData, const char *key,
				   struct fjson_object *jso, time_t now)
{
	return cache_entry_add(pWrkrData, 0, key, jso, now, 0);
}

/* must be called with cache-&gt;cacheMtx held */
static rsRetVal cache_entry_add_nsmd(wrkrInstanceData_t *pWrkrData, const char *key,
				     struct fjson_object *jso, time_t now)
{
	return cache_entry_add(pWrkrData, 1, key, jso, now, 1);
}


BEGINnewActInst
	struct cnfparamvals *pvals = NULL;
	int i;
	FILE *fp = NULL;
	char *rxstr = NULL;
	char *srcMetadataPath = NULL;
	char errStr[1024];
CODESTARTnewActInst
	DBGPRINTF(&quot;newActInst (mmkubernetes)\n&quot;);

	pvals = nvlstGetParams(lst, &amp;actpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;mmkubernetes: &quot;
			&quot;error processing config parameters [action(...)]&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf(&quot;action param blk in mmkubernetes:\n&quot;);
		cnfparamsPrint(&amp;actpblk, pvals);
	}

	CODE_STD_STRING_REQUESTnewActInst(1)
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
	CHKiRet(createInstance(&amp;pData));

	pData-&gt;de_dot = loadModConf-&gt;de_dot;
	pData-&gt;allowUnsignedCerts = loadModConf-&gt;allowUnsignedCerts;
	pData-&gt;skipVerifyHost = loadModConf-&gt;skipVerifyHost;
	pData-&gt;busyRetryInterval = loadModConf-&gt;busyRetryInterval;
	pData-&gt;sslPartialChain = loadModConf-&gt;sslPartialChain;
	pData-&gt;cacheEntryTTL = loadModConf-&gt;cacheEntryTTL;
	pData-&gt;cacheExpireInterval = loadModConf-&gt;cacheExpireInterval;
	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed) {
			continue;
		} else if(!strcmp(actpblk.descr[i].name, &quot;kubernetesurl&quot;)) {
			free(pData-&gt;kubernetesUrl);
			pData-&gt;kubernetesUrl = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;srcmetadatapath&quot;)) {
			msgPropDescrDestruct(pData-&gt;srcMetadataDescr);
			free(pData-&gt;srcMetadataDescr);
			CHKmalloc(pData-&gt;srcMetadataDescr = malloc(sizeof(msgPropDescr_t)));
			srcMetadataPath = es_str2cstr(pvals[i].val.d.estr, NULL);
			CHKiRet(msgPropDescrFill(pData-&gt;srcMetadataDescr, (uchar *)srcMetadataPath,
				strlen(srcMetadataPath)));
			/* todo: sanitize the path */
		} else if(!strcmp(actpblk.descr[i].name, &quot;dstmetadatapath&quot;)) {
			free(pData-&gt;dstMetadataPath);
			pData-&gt;dstMetadataPath = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			/* todo: sanitize the path */
		} else if(!strcmp(actpblk.descr[i].name, &quot;tls.cacert&quot;)) {
			free(pData-&gt;caCertFile);
			pData-&gt;caCertFile = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;caCertFile, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						&quot;error: certificate file %s couldn't be accessed: %s\n&quot;,
						pData-&gt;caCertFile, errStr);
				ABORT_FINALIZE(iRet);
			} else {
				fclose(fp);
				fp = NULL;
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;tls.mycert&quot;)) {
			pData-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;myCertFile, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						&quot;error: 'tls.mycert' file %s couldn't be accessed: %s\n&quot;,
						pData-&gt;myCertFile, errStr);
			} else {
				fclose(fp);
				fp = NULL;
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;tls.myprivkey&quot;)) {
			pData-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;myPrivKeyFile, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						&quot;error: 'tls.myprivkey' file %s couldn't be accessed: %s\n&quot;,
						pData-&gt;myPrivKeyFile, errStr);
			} else {
				fclose(fp);
				fp = NULL;
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;allowunsignedcerts&quot;)) {
			pData-&gt;allowUnsignedCerts = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;skipverifyhost&quot;)) {
			pData-&gt;skipVerifyHost = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;token&quot;)) {
			free(pData-&gt;token);
			pData-&gt;token = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;tokenfile&quot;)) {
			free(pData-&gt;tokenFile);
			pData-&gt;tokenFile = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;tokenFile, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						&quot;error: token file %s couldn't be accessed: %s\n&quot;,
						pData-&gt;tokenFile, errStr);
				ABORT_FINALIZE(iRet);
			} else {
				fclose(fp);
				fp = NULL;
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;annotation_match&quot;)) {
			free_annotationmatch(&amp;pData-&gt;annotation_match);
			if (RS_RET_OK != (iRet = init_annotationmatch(&amp;pData-&gt;annotation_match, pvals[i].val.d.ar)))
				ABORT_FINALIZE(iRet);
		} else if(!strcmp(actpblk.descr[i].name, &quot;de_dot&quot;)) {
			pData-&gt;de_dot = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;de_dot_separator&quot;)) {
			free(pData-&gt;de_dot_separator);
			pData-&gt;de_dot_separator = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
#if HAVE_LOADSAMPLESFROMSTRING == 1
		} else if(!strcmp(modpblk.descr[i].name, &quot;filenamerules&quot;)) {
			free(pData-&gt;fnRules);
			CHKiRet((array_to_rules(pvals[i].val.d.ar, &amp;pData-&gt;fnRules)));
#endif
		} else if(!strcmp(modpblk.descr[i].name, &quot;filenamerulebase&quot;)) {
			free(pData-&gt;fnRulebase);
			pData-&gt;fnRulebase = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;fnRulebase, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						&quot;error: filenamerulebase file %s couldn't be accessed: %s\n&quot;,
						pData-&gt;fnRulebase, errStr);
				ABORT_FINALIZE(iRet);
			} else {
				fclose(fp);
				fp = NULL;
			}
#if HAVE_LOADSAMPLESFROMSTRING == 1
		} else if(!strcmp(modpblk.descr[i].name, &quot;containerrules&quot;)) {
			free(pData-&gt;contRules);
			CHKiRet((array_to_rules(pvals[i].val.d.ar, &amp;pData-&gt;contRules)));
#endif
		} else if(!strcmp(modpblk.descr[i].name, &quot;containerrulebase&quot;)) {
			free(pData-&gt;contRulebase);
			pData-&gt;contRulebase = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;contRulebase, &quot;r&quot;);
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						&quot;error: containerrulebase file %s couldn't be accessed: %s\n&quot;,
						pData-&gt;contRulebase, errStr);
				ABORT_FINALIZE(iRet);
			} else {
				fclose(fp);
				fp = NULL;
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;busyretryinterval&quot;)) {
			pData-&gt;busyRetryInterval = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;sslpartialchain&quot;)) {
#if defined(SUPPORT_SSL_PARTIAL_CHAIN)
			pData-&gt;sslPartialChain = pvals[i].val.d.n;
#else
			LogMsg(0, RS_RET_VALUE_NOT_IN_THIS_MODE, LOG_INFO,
					&quot;sslpartialchain is only supported for OpenSSL\n&quot;);
#endif
		} else if(!strcmp(actpblk.descr[i].name, &quot;cacheentryttl&quot;)) {
			pData-&gt;cacheEntryTTL = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;cacheexpireinterval&quot;)) {
			pData-&gt;cacheExpireInterval = pvals[i].val.d.n;
		} else {
			dbgprintf(&quot;mmkubernetes: program error, non-handled &quot;
				&quot;param '%s' in action() block\n&quot;, actpblk.descr[i].name);
			/* todo: error message? */
		}
	}

#if HAVE_LOADSAMPLESFROMSTRING == 1
	if (pData-&gt;fnRules &amp;&amp; pData-&gt;fnRulebase) {
		LogError(0, RS_RET_CONFIG_ERROR,
		    &quot;mmkubernetes: only 1 of filenamerules or filenamerulebase may be used&quot;);
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
	if (pData-&gt;contRules &amp;&amp; pData-&gt;contRulebase) {
		LogError(0, RS_RET_CONFIG_ERROR,
			&quot;mmkubernetes: only 1 of containerrules or containerrulebase may be used&quot;);
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
#endif
	CHKiRet(set_lnctx(&amp;pData-&gt;fnCtxln, pData-&gt;fnRules, pData-&gt;fnRulebase,
			loadModConf-&gt;fnRules, loadModConf-&gt;fnRulebase));
	CHKiRet(set_lnctx(&amp;pData-&gt;contCtxln, pData-&gt;contRules, pData-&gt;contRulebase,
			loadModConf-&gt;contRules, loadModConf-&gt;contRulebase));

	if ((pData-&gt;cacheExpireInterval &gt; -1)) {
		if ((pData-&gt;cacheEntryTTL &lt; 0)) {
			LogError(0, RS_RET_CONFIG_ERROR,
					&quot;mmkubernetes: cacheentryttl value [%d] is invalid - &quot;
					&quot;value must be 0 or greater&quot;,
					pData-&gt;cacheEntryTTL);
			ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
		}
	}

	if(pData-&gt;kubernetesUrl == NULL) {
		if(loadModConf-&gt;kubernetesUrl == NULL) {
			CHKmalloc(pData-&gt;kubernetesUrl = (uchar *) strdup(DFLT_KUBERNETES_URL));
		} else {
			CHKmalloc(pData-&gt;kubernetesUrl = (uchar *) strdup((char *) loadModConf-&gt;kubernetesUrl));
		}
	}
	if(pData-&gt;srcMetadataDescr == NULL) {
		CHKmalloc(pData-&gt;srcMetadataDescr = malloc(sizeof(msgPropDescr_t)));
		CHKiRet(msgPropDescrFill(pData-&gt;srcMetadataDescr, loadModConf-&gt;srcMetadataPath,
			strlen((char *)loadModConf-&gt;srcMetadataPath)));
	}
	if(pData-&gt;dstMetadataPath == NULL)
		pData-&gt;dstMetadataPath = (uchar *) strdup((char *) loadModConf-&gt;dstMetadataPath);
	if(pData-&gt;caCertFile == NULL &amp;&amp; loadModConf-&gt;caCertFile)
		pData-&gt;caCertFile = (uchar *) strdup((char *) loadModConf-&gt;caCertFile);
	if(pData-&gt;myCertFile == NULL &amp;&amp; loadModConf-&gt;myCertFile)
		pData-&gt;myCertFile = (uchar *) strdup((char *) loadModConf-&gt;myCertFile);
	if(pData-&gt;myPrivKeyFile == NULL &amp;&amp; loadModConf-&gt;myPrivKeyFile)
		pData-&gt;myPrivKeyFile = (uchar *) strdup((char *) loadModConf-&gt;myPrivKeyFile);
	if(pData-&gt;token == NULL &amp;&amp; loadModConf-&gt;token)
		pData-&gt;token = (uchar *) strdup((char *) loadModConf-&gt;token);
	if(pData-&gt;tokenFile == NULL &amp;&amp; loadModConf-&gt;tokenFile)
		pData-&gt;tokenFile = (uchar *) strdup((char *) loadModConf-&gt;tokenFile);
	if(pData-&gt;de_dot_separator == NULL &amp;&amp; loadModConf-&gt;de_dot_separator)
		pData-&gt;de_dot_separator = (uchar *) strdup((char *) loadModConf-&gt;de_dot_separator);
	if((pData-&gt;annotation_match.nmemb == 0) &amp;&amp; (loadModConf-&gt;annotation_match.nmemb &gt; 0))
		copy_annotationmatch(&amp;loadModConf-&gt;annotation_match, &amp;pData-&gt;annotation_match);

	if(pData-&gt;de_dot_separator)
		pData-&gt;de_dot_separator_len = strlen((const char *)pData-&gt;de_dot_separator);

	CHKmalloc(pData-&gt;contNameDescr = malloc(sizeof(msgPropDescr_t)));
	CHKiRet(msgPropDescrFill(pData-&gt;contNameDescr, (uchar*) DFLT_CONTAINER_NAME,
			strlen(DFLT_CONTAINER_NAME)));
	CHKmalloc(pData-&gt;contIdFullDescr = malloc(sizeof(msgPropDescr_t)));
	CHKiRet(msgPropDescrFill(pData-&gt;contIdFullDescr, (uchar*) DFLT_CONTAINER_ID_FULL,
			strlen(DFLT_CONTAINER_NAME)));

	/* get the cache for this url */
	for(i = 0; caches[i] != NULL; i++) {
		if(!strcmp((char *) pData-&gt;kubernetesUrl, (char *) caches[i]-&gt;kbUrl))
			break;
	}
	if(caches[i] != NULL) {
		pData-&gt;cache = caches[i];
	} else {
		CHKmalloc(pData-&gt;cache = cacheNew(pData));
		struct cache_s **new_caches = realloc(caches, (i + 2) * sizeof(struct cache_s *));
		CHKmalloc(new_caches);
		caches = new_caches;
		caches[i] = pData-&gt;cache;
		caches[i + 1] = NULL;
	}
CODE_STD_FINALIZERnewActInst
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;actpblk);
	if(fp)
		fclose(fp);
	free(rxstr);
	free(srcMetadataPath);
ENDnewActInst


/* legacy config format is not supported */
BEGINparseSelectorAct
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	if(strncmp((char *) p, &quot;:mmkubernetes:&quot;, sizeof(&quot;:mmkubernetes:&quot;) - 1)) {
		LogError(0, RS_RET_LEGA_ACT_NOT_SUPPORTED,
			&quot;mmkubernetes supports only v6+ config format, use: &quot;
			&quot;action(type=\&quot;mmkubernetes\&quot; ...)&quot;);
	}
	ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct


BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad


BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf


BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf


BEGINfreeCnf
CODESTARTfreeCnf
	int i;

	free(pModConf-&gt;kubernetesUrl);
	free(pModConf-&gt;srcMetadataPath);
	free(pModConf-&gt;dstMetadataPath);
	free(pModConf-&gt;caCertFile);
	free(pModConf-&gt;myCertFile);
	free(pModConf-&gt;myPrivKeyFile);
	free(pModConf-&gt;token);
	free(pModConf-&gt;tokenFile);
	free(pModConf-&gt;de_dot_separator);
	free(pModConf-&gt;fnRules);
	free(pModConf-&gt;fnRulebase);
	free(pModConf-&gt;contRules);
	free(pModConf-&gt;contRulebase);
	free_annotationmatch(&amp;pModConf-&gt;annotation_match);
	for(i = 0; caches[i] != NULL; i++) {
		dbgprintf(&quot;mmkubernetes: freeing cache [%d] mdht [%p] nsht [%p]\n&quot;,
				i, caches[i]-&gt;mdHt, caches[i]-&gt;nsHt);
		cacheFree(caches[i]);
	}
	free(caches);
ENDfreeCnf


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	dbgprintf(&quot;mmkubernetes\n&quot;);
	dbgprintf(&quot;\tkubernetesUrl='%s'\n&quot;, pData-&gt;kubernetesUrl);
	dbgprintf(&quot;\tsrcMetadataPath='%s'\n&quot;, pData-&gt;srcMetadataDescr-&gt;name);
	dbgprintf(&quot;\tdstMetadataPath='%s'\n&quot;, pData-&gt;dstMetadataPath);
	dbgprintf(&quot;\ttls.cacert='%s'\n&quot;, pData-&gt;caCertFile);
	dbgprintf(&quot;\ttls.mycert='%s'\n&quot;, pData-&gt;myCertFile);
	dbgprintf(&quot;\ttls.myprivkey='%s'\n&quot;, pData-&gt;myPrivKeyFile);
	dbgprintf(&quot;\tallowUnsignedCerts='%d'\n&quot;, pData-&gt;allowUnsignedCerts);
	dbgprintf(&quot;\tskipVerifyHost='%d'\n&quot;, pData-&gt;skipVerifyHost);
	dbgprintf(&quot;\ttoken='%s'\n&quot;, pData-&gt;token);
	dbgprintf(&quot;\ttokenFile='%s'\n&quot;, pData-&gt;tokenFile);
	dbgprintf(&quot;\tde_dot='%d'\n&quot;, pData-&gt;de_dot);
	dbgprintf(&quot;\tde_dot_separator='%s'\n&quot;, pData-&gt;de_dot_separator);
	dbgprintf(&quot;\tfilenamerulebase='%s'\n&quot;, pData-&gt;fnRulebase);
	dbgprintf(&quot;\tcontainerrulebase='%s'\n&quot;, pData-&gt;contRulebase);
#if HAVE_LOADSAMPLESFROMSTRING == 1
	dbgprintf(&quot;\tfilenamerules='%s'\n&quot;, pData-&gt;fnRules);
	dbgprintf(&quot;\tcontainerrules='%s'\n&quot;, pData-&gt;contRules);
#endif
	dbgprintf(&quot;\tbusyretryinterval='%d'\n&quot;, pData-&gt;busyRetryInterval);
	dbgprintf(&quot;\tcacheentryttl='%d'\n&quot;, pData-&gt;cacheEntryTTL);
	dbgprintf(&quot;\tcacheexpireinterval='%d'\n&quot;, pData-&gt;cacheExpireInterval);
ENDdbgPrintInstInfo


BEGINtryResume
CODESTARTtryResume
ENDtryResume

static rsRetVal
extractMsgMetadata(smsg_t *pMsg, instanceData *pData, struct json_object **json)
{
	DEFiRet;
	uchar *filename = NULL, *container_name = NULL, *container_id_full = NULL;
	rs_size_t fnLen, container_name_len, container_id_full_len;
	unsigned short freeFn = 0, free_container_name = 0, free_container_id_full = 0;
	int lnret;
	struct json_object *cnid = NULL;

	if (!json)
		FINALIZE;
	*json = NULL;
	/* extract metadata from the CONTAINER_NAME field and see if CONTAINER_ID_FULL is present */
	container_name = MsgGetProp(pMsg, NULL, pData-&gt;contNameDescr,
				    &amp;container_name_len, &amp;free_container_name, NULL);
	container_id_full = MsgGetProp(
		pMsg, NULL, pData-&gt;contIdFullDescr, &amp;container_id_full_len, &amp;free_container_id_full, NULL);

	if (container_name &amp;&amp; container_id_full &amp;&amp; container_name_len &amp;&amp; container_id_full_len) {
		dbgprintf(&quot;mmkubernetes: CONTAINER_NAME: '%s'  CONTAINER_ID_FULL: '%s'.\n&quot;,
			  container_name, container_id_full);
		if ((lnret = ln_normalize(pData-&gt;contCtxln, (char*)container_name,
					  container_name_len, json))) {
			if (LN_WRONGPARSER != lnret) {
				LogMsg(0, RS_RET_ERR, LOG_ERR,
					&quot;mmkubernetes: error parsing container_name [%s]: [%d]&quot;,
					container_name, lnret);

				ABORT_FINALIZE(RS_RET_ERR);
			}
			/* else assume parser didn't find a match and fall through */
		} else if (fjson_object_object_get_ex(*json, &quot;pod_name&quot;, NULL) &amp;&amp;
			fjson_object_object_get_ex(*json, &quot;namespace_name&quot;, NULL) &amp;&amp;
			fjson_object_object_get_ex(*json, &quot;container_name&quot;, NULL)) {
			/* if we have fields for pod name, namespace name, container name,
			 * and container id, we are good to go */
			/* add field for container id */
			json_object_object_add(*json, &quot;container_id&quot;,
				json_object_new_string_len((const char *)container_id_full,
							   container_id_full_len));
			ABORT_FINALIZE(RS_RET_OK);
		}
	}

	/* extract metadata from the file name */
	filename = MsgGetProp(pMsg, NULL, pData-&gt;srcMetadataDescr, &amp;fnLen, &amp;freeFn, NULL);
	if((filename == NULL) || (fnLen == 0))
		ABORT_FINALIZE(RS_RET_NOT_FOUND);

	dbgprintf(&quot;mmkubernetes: filename: '%s' len %d.\n&quot;, filename, fnLen);
	if ((lnret = ln_normalize(pData-&gt;fnCtxln, (char*)filename, fnLen, json))) {
		if (LN_WRONGPARSER != lnret) {
			LogMsg(0, RS_RET_ERR, LOG_ERR,
				&quot;mmkubernetes: error parsing container_name [%s]: [%d]&quot;,
				filename, lnret);

			ABORT_FINALIZE(RS_RET_ERR);
		} else {
			/* no match */
			ABORT_FINALIZE(RS_RET_NOT_FOUND);
		}
	}
	/* if we have fields for pod name, namespace name, container name,
	 * and container id, we are good to go */
	if (fjson_object_object_get_ex(*json, &quot;pod_name&quot;, NULL) &amp;&amp;
		fjson_object_object_get_ex(*json, &quot;namespace_name&quot;, NULL) &amp;&amp;
		fjson_object_object_get_ex(*json, &quot;container_name_and_id&quot;, &amp;cnid)) {
		/* parse container_name_and_id into container_name and container_id */
		const char *container_name_and_id = json_object_get_string(cnid);
		const char *last_dash = NULL;
		if (container_name_and_id &amp;&amp; (last_dash = strrchr(container_name_and_id, '-')) &amp;&amp;
			*(last_dash + 1) &amp;&amp; (last_dash != container_name_and_id)) {
			json_object_object_add(*json, &quot;container_name&quot;,
				json_object_new_string_len(container_name_and_id,
							   (int)(last_dash-container_name_and_id)));
			json_object_object_add(*json, &quot;container_id&quot;,
					json_object_new_string(last_dash + 1));
			ABORT_FINALIZE(RS_RET_OK);
		}
	}
	ABORT_FINALIZE(RS_RET_NOT_FOUND);
finalize_it:
	if(freeFn)
		free(filename);
	if (free_container_name)
		free(container_name);
	if (free_container_id_full)
		free(container_id_full);
	if (iRet != RS_RET_OK) {
		json_object_put(*json);
		*json = NULL;
	}
	RETiRet;
}


static rsRetVal
queryKB(wrkrInstanceData_t *pWrkrData, char *url, time_t now, struct json_object **rply)
{
	DEFiRet;
	CURLcode ccode;
	struct json_tokener *jt = NULL;
	struct json_object *jo;
	long resp_code = 400;

	if (pWrkrData-&gt;pData-&gt;cache-&gt;lastBusyTime) {
		now -= pWrkrData-&gt;pData-&gt;cache-&gt;lastBusyTime;
		if (now &lt; pWrkrData-&gt;pData-&gt;busyRetryInterval) {
			LogMsg(0, RS_RET_RETRY, LOG_DEBUG,
				&quot;mmkubernetes: Waited [%ld] of [%d] seconds for the requested url [%s]\n&quot;,
				now, pWrkrData-&gt;pData-&gt;busyRetryInterval, url);
			ABORT_FINALIZE(RS_RET_RETRY);
		} else {
			LogMsg(0, RS_RET_OK, LOG_DEBUG,
				&quot;mmkubernetes: Cleared busy status after [%d] seconds - &quot;
				&quot;will retry the requested url [%s]\n&quot;,
				pWrkrData-&gt;pData-&gt;busyRetryInterval, url);
			pWrkrData-&gt;pData-&gt;cache-&gt;lastBusyTime = 0;
		}
	}

	/* query kubernetes for pod info */
	ccode = curl_easy_setopt(pWrkrData-&gt;curlCtx, CURLOPT_URL, url);
	if(ccode != CURLE_OK)
		ABORT_FINALIZE(RS_RET_ERR);
	if(CURLE_OK != (ccode = curl_easy_perform(pWrkrData-&gt;curlCtx))) {
		LogMsg(0, RS_RET_ERR, LOG_ERR,
			      &quot;mmkubernetes: failed to connect to [%s] - %d:%s\n&quot;,
			      url, ccode, curl_easy_strerror(ccode));
<A NAME="3"></A>		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}
	if(CURLE_OK != (ccode = curl_easy_getinfo(pWrkrData-&gt;curlCtx,
<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1929-0.html#3',2,'match1929-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>					CURLINFO_RESPONSE_CODE, &amp;resp_code))) {
		LogMsg(0, RS_RET_ERR, LOG_ERR,
			      &quot;mmkubernetes: could not get response code from query to [%s] - %d:%s\n&quot;,
			      url, ccode, curl_easy_strerror(ccode));
		ABORT_FINALIZE(RS_RET_ERR);
	}
	if(resp_code == 401) {
		LogMsg(0, RS_RET_ERR, LOG_ERR,
			      &quot;mmkubernetes: Unauthorized: not allowed to view url - &quot;
			      &quot;check token/auth credentials [%s]\n&quot;,
			      url);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	if(resp_code == 403) {
		LogMsg(0, RS_RET_ERR, LOG_ERR,
			      &quot;mmkubernetes: Forbidden: no access - &quot;
			      &quot;check permissions to view url [%s]\n&quot;,
			      url);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	if(resp_code == 404) {
		LogMsg(0, RS_RET_NOT_FOUND, LOG_INFO,
			      &quot;mmkubernetes: Not Found: the resource does not exist at url [%s]\n&quot;,
			      url);
		ABORT_FINALIZE(RS_RET_NOT_FOUND);
	}
	if(resp_code == 429) {</B></FONT>
		if (pWrkrData-&gt;pData-&gt;busyRetryInterval) {
			pWrkrData-&gt;pData-&gt;cache-&gt;lastBusyTime = now;
		}

		LogMsg(0, RS_RET_RETRY, LOG_INFO,
			      &quot;mmkubernetes: Too Many Requests: the server is too heavily loaded &quot;
			      &quot;to provide the data for the requested url [%s]\n&quot;,
			      url);
		ABORT_FINALIZE(RS_RET_RETRY);
	}
	if(resp_code != 200) {
		LogMsg(0, RS_RET_ERR, LOG_ERR,
			      &quot;mmkubernetes: server returned unexpected code [%ld] for url [%s]\n&quot;,
			      resp_code, url);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	/* parse retrieved data */
	jt = json_tokener_new();
	json_tokener_reset(jt);
	jo = json_tokener_parse_ex(jt, pWrkrData-&gt;curlRply, pWrkrData-&gt;curlRplyLen);
	json_tokener_free(jt);
	if(!json_object_is_type(jo, json_type_object)) {
		json_object_put(jo);
		jo = NULL;
		LogMsg(0, RS_RET_JSON_PARSE_ERR, LOG_INFO,
			      &quot;mmkubernetes: unable to parse string as JSON:[%.*s]\n&quot;,
			      (int)pWrkrData-&gt;curlRplyLen, pWrkrData-&gt;curlRply);
		ABORT_FINALIZE(RS_RET_JSON_PARSE_ERR);
	}

	dbgprintf(&quot;mmkubernetes: queryKB reply:\n%s\n&quot;,
		json_object_to_json_string_ext(jo, JSON_C_TO_STRING_PRETTY));

	*rply = jo;

finalize_it:
	if(pWrkrData-&gt;curlRply != NULL) {
		free(pWrkrData-&gt;curlRply);
		pWrkrData-&gt;curlRply = NULL;
		pWrkrData-&gt;curlRplyLen = 0;
	}
	RETiRet;
}


/* versions &lt; 8.16.0 don't support BEGINdoAction_NoStrings */
#if defined(BEGINdoAction_NoStrings)
BEGINdoAction_NoStrings
	smsg_t **ppMsg = (smsg_t **) pMsgData;
	smsg_t *pMsg = ppMsg[0];
#else
BEGINdoAction
	smsg_t *pMsg = (smsg_t*) ppString[0];
#endif
	const char *podName = NULL, *ns = NULL, *containerName = NULL,
		*containerID = NULL;
	char *mdKey = NULL;
	struct json_object *jMetadata = NULL, *jMetadataCopy = NULL, *jMsgMeta = NULL,
			*jo = NULL;
	int add_pod_metadata = 1;
	time_t now;

CODESTARTdoAction
	CHKiRet_Hdlr(extractMsgMetadata(pMsg, pWrkrData-&gt;pData, &amp;jMsgMeta)) {
		ABORT_FINALIZE((iRet == RS_RET_NOT_FOUND) ? RS_RET_OK : iRet);
	}

	datetime.GetTime(&amp;now);
	STATSCOUNTER_INC(pWrkrData-&gt;k8sRecordSeen, pWrkrData-&gt;mutK8sRecordSeen);

	if (fjson_object_object_get_ex(jMsgMeta, &quot;pod_name&quot;, &amp;jo))
		podName = json_object_get_string(jo);
	if (fjson_object_object_get_ex(jMsgMeta, &quot;namespace_name&quot;, &amp;jo))
		ns = json_object_get_string(jo);
	if (fjson_object_object_get_ex(jMsgMeta, &quot;container_name&quot;, &amp;jo))
		containerName = json_object_get_string(jo);
	if (fjson_object_object_get_ex(jMsgMeta, &quot;container_id&quot;, &amp;jo))
		containerID = json_object_get_string(jo);
	assert(podName != NULL);
	assert(ns != NULL);
	assert(containerName != NULL);
	assert(containerID != NULL);

	dbgprintf(&quot;mmkubernetes:\n  podName: '%s'\n  namespace: '%s'\n  containerName: '%s'\n&quot;
		&quot;  containerID: '%s'\n&quot;, podName, ns, containerName, containerID);

	/* check cache for metadata */
	if ((-1 == asprintf(&amp;mdKey, &quot;%s_%s_%s&quot;, ns, podName, containerName)) ||
		(!mdKey)) {
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}
	pthread_mutex_lock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
	jMetadata = cache_entry_get_md(pWrkrData, mdKey, now);

	if(jMetadata == NULL) {
		char *url = NULL;
		struct json_object *jReply = NULL, *jo2 = NULL, *jNsMeta = NULL, *jPodData = NULL;

		/* check cache for namespace metadata */
		jNsMeta = cache_entry_get_nsmd(pWrkrData, (const char *)ns, now);

		if(jNsMeta == NULL) {
			/* query kubernetes for namespace info */
			/* todo: move url definitions elsewhere */
			if ((-1 == asprintf(&amp;url, &quot;%s/api/v1/namespaces/%s&quot;,
				 (char *) pWrkrData-&gt;pData-&gt;kubernetesUrl, ns)) ||
				(!url)) {
				pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
			}
			iRet = queryKB(pWrkrData, url, now, &amp;jReply);
			free(url);
			if (iRet == RS_RET_NOT_FOUND) {
				/* negative cache namespace - make a dummy empty namespace metadata object */
				jNsMeta = json_object_new_object();
				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataNotFound,
						 pWrkrData-&gt;mutNamespaceMetadataNotFound);
			} else if (iRet == RS_RET_RETRY) {
				/* server is busy - retry or error */
				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataBusy,
						 pWrkrData-&gt;mutNamespaceMetadataBusy);
				if (0 == pWrkrData-&gt;pData-&gt;busyRetryInterval) {
					pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
					ABORT_FINALIZE(RS_RET_ERR);
				}
				add_pod_metadata = 0; /* don't cache pod metadata either - retry both */
			} else if (iRet != RS_RET_OK) {
				/* one of many possible transient errors: apiserver error, network, config, auth.
				 * Instead of causing hard error and disabling this module, we can return
				 * basic namespace metadata that is extracted from container log file path.
				 * When transient error resolves, other metadata will become
				 * available. For a new a new pod whose metadata is not yet cached, this
				 * will allow 401, 403, 500, etc. return status from apiserver treated
				 * similar to 404 returns.
				 * */
				jNsMeta = json_object_new_object();
				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataError,
						 pWrkrData-&gt;mutNamespaceMetadataError);
			} else if (fjson_object_object_get_ex(jReply, &quot;metadata&quot;, &amp;jNsMeta)) {
				jNsMeta = json_object_get(jNsMeta);
				parse_labels_annotations(jNsMeta, &amp;pWrkrData-&gt;pData-&gt;annotation_match,
					pWrkrData-&gt;pData-&gt;de_dot,
					(const char *)pWrkrData-&gt;pData-&gt;de_dot_separator,
					pWrkrData-&gt;pData-&gt;de_dot_separator_len);
				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataSuccess,
						 pWrkrData-&gt;mutNamespaceMetadataSuccess);
			} else {
				/* namespace with no metadata??? */
				LogMsg(0, RS_RET_ERR, LOG_INFO,
					      &quot;mmkubernetes: namespace [%s] has no metadata!\n&quot;, ns);
				/* negative cache namespace - make a dummy empty namespace metadata object */
				jNsMeta = json_object_new_object();
				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataSuccess,
						 pWrkrData-&gt;mutNamespaceMetadataSuccess);
			}

			if(jNsMeta) {
				if ((iRet = cache_entry_add_nsmd(pWrkrData, ns, jNsMeta, now))) {
					ABORT_FINALIZE(iRet);
				}
			}
			json_object_put(jReply);
			jReply = NULL;
		}

		if ((-1 == asprintf(&amp;url, &quot;%s/api/v1/namespaces/%s/pods/%s&quot;,
			 (char *) pWrkrData-&gt;pData-&gt;kubernetesUrl, ns, podName)) ||
			(!url)) {
			pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
		}
		iRet = queryKB(pWrkrData, url, now, &amp;jReply);
		free(url);
		if (iRet == RS_RET_NOT_FOUND) {
			/* negative cache pod - make a dummy empty pod metadata object */
			iRet = RS_RET_OK;
			STATSCOUNTER_INC(pWrkrData-&gt;podMetadataNotFound, pWrkrData-&gt;mutPodMetadataNotFound);
		} else if (iRet == RS_RET_RETRY) {
			/* server is busy - retry or error */
			STATSCOUNTER_INC(pWrkrData-&gt;podMetadataBusy, pWrkrData-&gt;mutPodMetadataBusy);
			if (0 == pWrkrData-&gt;pData-&gt;busyRetryInterval) {
				pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
				ABORT_FINALIZE(RS_RET_ERR);
			}
			add_pod_metadata = 0; /* do not cache so that we can retry */
			iRet = RS_RET_OK;
		} else if(iRet != RS_RET_OK) {
			/* This is likely caused by transient apiserver errors: 401, 403, 500, etc.
			 * Treat it similar to 404 while returning file path based pod metadata.
			 * When transient error condition resolves, additional metadata will be
			 * available for events originating from a new pod whose metatadata is not
			 * yet cached.
			 * */
			iRet = RS_RET_OK;
			STATSCOUNTER_INC(pWrkrData-&gt;podMetadataError, pWrkrData-&gt;mutPodMetadataError);
		} else {
			STATSCOUNTER_INC(pWrkrData-&gt;podMetadataSuccess, pWrkrData-&gt;mutPodMetadataSuccess);
		}

		jo = json_object_new_object();
		if(jNsMeta &amp;&amp; fjson_object_object_get_ex(jNsMeta, &quot;uid&quot;, &amp;jo2))
			json_object_object_add(jo, &quot;namespace_id&quot;, json_object_get(jo2));
		if(jNsMeta &amp;&amp; fjson_object_object_get_ex(jNsMeta, &quot;labels&quot;, &amp;jo2))
			json_object_object_add(jo, &quot;namespace_labels&quot;, json_object_get(jo2));
		if(jNsMeta &amp;&amp; fjson_object_object_get_ex(jNsMeta, &quot;annotations&quot;, &amp;jo2))
			json_object_object_add(jo, &quot;namespace_annotations&quot;, json_object_get(jo2));
		if(jNsMeta &amp;&amp; fjson_object_object_get_ex(jNsMeta, &quot;creationTimestamp&quot;, &amp;jo2))
			json_object_object_add(jo, &quot;creation_timestamp&quot;, json_object_get(jo2));
		if(fjson_object_object_get_ex(jReply, &quot;metadata&quot;, &amp;jPodData)) {
			if(fjson_object_object_get_ex(jPodData, &quot;uid&quot;, &amp;jo2))
				json_object_object_add(jo, &quot;pod_id&quot;, json_object_get(jo2));
			parse_labels_annotations(jPodData, &amp;pWrkrData-&gt;pData-&gt;annotation_match,
				pWrkrData-&gt;pData-&gt;de_dot,
				(const char *)pWrkrData-&gt;pData-&gt;de_dot_separator,
				pWrkrData-&gt;pData-&gt;de_dot_separator_len);
			if(fjson_object_object_get_ex(jPodData, &quot;annotations&quot;, &amp;jo2))
				json_object_object_add(jo, &quot;annotations&quot;, json_object_get(jo2));
			if(fjson_object_object_get_ex(jPodData, &quot;labels&quot;, &amp;jo2))
				json_object_object_add(jo, &quot;labels&quot;, json_object_get(jo2));
		}
		if(fjson_object_object_get_ex(jReply, &quot;spec&quot;, &amp;jPodData)) {
			if(fjson_object_object_get_ex(jPodData, &quot;nodeName&quot;, &amp;jo2)) {
				json_object_object_add(jo, &quot;host&quot;, json_object_get(jo2));
			}
		}
		json_object_put(jReply);
		jReply = NULL;

		if (fjson_object_object_get_ex(jMsgMeta, &quot;pod_name&quot;, &amp;jo2))
			json_object_object_add(jo, &quot;pod_name&quot;, json_object_get(jo2));
		if (fjson_object_object_get_ex(jMsgMeta, &quot;namespace_name&quot;, &amp;jo2))
			json_object_object_add(jo, &quot;namespace_name&quot;, json_object_get(jo2));
		if (fjson_object_object_get_ex(jMsgMeta, &quot;container_name&quot;, &amp;jo2))
			json_object_object_add(jo, &quot;container_name&quot;, json_object_get(jo2));
		json_object_object_add(jo, &quot;master_url&quot;,
			json_object_new_string((const char *)pWrkrData-&gt;pData-&gt;kubernetesUrl));
		jMetadata = json_object_new_object();
		json_object_object_add(jMetadata, &quot;kubernetes&quot;, jo);
		jo = json_object_new_object();
		if (fjson_object_object_get_ex(jMsgMeta, &quot;container_id&quot;, &amp;jo2))
			json_object_object_add(jo, &quot;container_id&quot;, json_object_get(jo2));
		json_object_object_add(jMetadata, &quot;docker&quot;, jo);

		if (add_pod_metadata) {
			if ((iRet = cache_entry_add_md(pWrkrData, mdKey, jMetadata, now)))
				ABORT_FINALIZE(iRet);
			mdKey = NULL;
		}
	}

	/* make a copy of the metadata for the msg to own */
	/* todo: use json_object_deep_copy when implementation available in libfastjson */
	/* yes, this is expensive - but there is no other way to make this thread safe - we
	 * can't allow the msg to have a shared pointer to an element inside the cache,
	 * outside of the cache lock
	 */
	jMetadataCopy = json_tokener_parse(json_object_get_string(jMetadata));
	if (!add_pod_metadata) {
		/* jMetadata object was created from scratch and not cached */
		json_object_put(jMetadata);
		jMetadata = NULL;
	}
	pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
	/* the +1 is there to skip the leading '$' */
	msgAddJSON(pMsg, (uchar *) pWrkrData-&gt;pData-&gt;dstMetadataPath + 1, jMetadataCopy, 0, 0);

finalize_it:
	json_object_put(jMsgMeta);
	free(mdKey);
ENDdoAction


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
ENDisCompatibleWithFeature


/* all the macros bellow have to be in a specific order */
BEGINmodExit
CODESTARTmodExit
	curl_global_cleanup();

	objRelease(datetime, CORE_COMPONENT);
	objRelease(regexp, LM_REGEXP_FILENAME);
	objRelease(statsobj, CORE_COMPONENT);
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	DBGPRINTF(&quot;mmkubernetes: module compiled with rsyslog version %s.\n&quot;, VERSION);
	CHKiRet(objUse(statsobj, CORE_COMPONENT));
	CHKiRet(objUse(regexp, LM_REGEXP_FILENAME));
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	/* CURL_GLOBAL_ALL initializes more than is needed but the
	 * libcurl documentation discourages use of other values
	 */
	curl_global_init(CURL_GLOBAL_ALL);
ENDmodInit
</PRE>
</div>
  </div>
</body>
</html>
