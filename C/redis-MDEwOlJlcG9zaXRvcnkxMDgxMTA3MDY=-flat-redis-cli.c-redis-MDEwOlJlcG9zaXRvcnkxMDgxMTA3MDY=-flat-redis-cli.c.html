
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 26, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-redis-cli.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/Win32_Portability.h"
3  #include "Win32_Interop/win32_types.h"
4  #include "Win32_Interop/Win32_Time.h"
5  #include "Win32_Interop/win32fixes.h"
6  #include "Win32_Interop/Win32_PThread.h"
7  #include "Win32_Interop/Win32_Error.h"
8  #endif
9  #include "fmacros.h"
10  #include "version.h"
11  #include <stdio.h>
12  #include <string.h>
13  #include <stdlib.h>
14  #ifndef _WIN32
15  #include <signal.h>
16  #include <unistd.h>
17  #endif
18  #include <time.h>
19  #include <ctype.h>
20  #include <errno.h>
21  #include <sys/stat.h>
22  #ifndef _WIN32
23  #include <sys/time.h>
24  #endif
25  #include <assert.h>
26  #include <fcntl.h>
27  #include <limits.h>
28  #include <math.h>
29  #ifdef _WIN32
30  #ifndef STDIN_FILENO
31  #define STDIN_FILENO (_fileno(stdin))
32  #endif
33  #include "Win32_Interop/win32fixes.h"
34  #include "Win32_Interop/Win32_Signal_Process.h"
35  #include "Win32_Interop/Win32_ANSI.h"
36  #include <windows.h>
37  #define strcasecmp _stricmp
38  #define strncasecmp _strnicmp
39  #define strtoull _strtoui64
40  #endif
41  #include <hiredis.h>
42  #include <sds.h> &bsol;* use sds.h from hiredis, so that only one set of sds functions will be present in the binary */
43  #include "dict.h"
44  #include "adlist.h"
45  #include "zmalloc.h"
46  #include "linenoise.h"
47  #include "help.h"
48  #include "anet.h"
49  #include "ae.h"
50  #define UNUSED(V) ((void) V)
51  #define OUTPUT_STANDARD 0
52  #define OUTPUT_RAW 1
53  #define OUTPUT_CSV 2
54  #define REDIS_CLI_KEEPALIVE_INTERVAL 15 &bsol;* seconds */
55  #define REDIS_CLI_DEFAULT_PIPE_TIMEOUT 30 &bsol;* seconds */
56  #define REDIS_CLI_HISTFILE_ENV "REDISCLI_HISTFILE"
57  #define REDIS_CLI_HISTFILE_DEFAULT ".rediscli_history"
58  #define REDIS_CLI_RCFILE_ENV "REDISCLI_RCFILE"
59  #define REDIS_CLI_RCFILE_DEFAULT ".redisclirc"
60  #define REDIS_CLI_AUTH_ENV "REDISCLI_AUTH"
61  #define REDIS_CLI_CLUSTER_YES_ENV "REDISCLI_CLUSTER_YES"
62  #define CLUSTER_MANAGER_SLOTS               16384
63  #define CLUSTER_MANAGER_MIGRATE_TIMEOUT     60000
64  #define CLUSTER_MANAGER_MIGRATE_PIPELINE    10
65  #define CLUSTER_MANAGER_REBALANCE_THRESHOLD 2
66  #define CLUSTER_MANAGER_INVALID_HOST_ARG \
67      "[ERR] Invalid arguments: you need to pass either a valid " \
68      "address (ie. 120.0.0.1:7000) or space separated IP " \
69      "and port (ie. 120.0.0.1 7000)\n"
70  #define CLUSTER_MANAGER_MODE() (config.cluster_manager_command.name != NULL)
71  #define CLUSTER_MANAGER_MASTERS_COUNT(nodes, replicas) (nodes/(replicas + 1))
72  #define CLUSTER_MANAGER_COMMAND(n,...) \
73          (redisCommand(n->context, __VA_ARGS__))
74  #define CLUSTER_MANAGER_NODE_ARRAY_FREE(array) zfree(array->alloc)
75  #define CLUSTER_MANAGER_PRINT_REPLY_ERROR(n, err) \
76      clusterManagerLogErr("Node %s:%d replied with error:\n%s\n", \
77                           n->ip, n->port, err);
78  #define clusterManagerLogInfo(...) \
79      clusterManagerLog(CLUSTER_MANAGER_LOG_LVL_INFO,__VA_ARGS__)
80  #define clusterManagerLogErr(...) \
81      clusterManagerLog(CLUSTER_MANAGER_LOG_LVL_ERR,__VA_ARGS__)
82  #define clusterManagerLogWarn(...) \
83      clusterManagerLog(CLUSTER_MANAGER_LOG_LVL_WARN,__VA_ARGS__)
84  #define clusterManagerLogOk(...) \
85      clusterManagerLog(CLUSTER_MANAGER_LOG_LVL_SUCCESS,__VA_ARGS__)
86  #define CLUSTER_MANAGER_FLAG_MYSELF     1 << 0
87  #define CLUSTER_MANAGER_FLAG_SLAVE      1 << 1
88  #define CLUSTER_MANAGER_FLAG_FRIEND     1 << 2
89  #define CLUSTER_MANAGER_FLAG_NOADDR     1 << 3
90  #define CLUSTER_MANAGER_FLAG_DISCONNECT 1 << 4
91  #define CLUSTER_MANAGER_FLAG_FAIL       1 << 5
92  #define CLUSTER_MANAGER_CMD_FLAG_FIX            1 << 0
93  #define CLUSTER_MANAGER_CMD_FLAG_SLAVE          1 << 1
94  #define CLUSTER_MANAGER_CMD_FLAG_YES            1 << 2
95  #define CLUSTER_MANAGER_CMD_FLAG_AUTOWEIGHTS    1 << 3
96  #define CLUSTER_MANAGER_CMD_FLAG_EMPTYMASTER    1 << 4
97  #define CLUSTER_MANAGER_CMD_FLAG_SIMULATE       1 << 5
98  #define CLUSTER_MANAGER_CMD_FLAG_REPLACE        1 << 6
99  #define CLUSTER_MANAGER_CMD_FLAG_COPY           1 << 7
100  #define CLUSTER_MANAGER_CMD_FLAG_COLOR          1 << 8
101  #define CLUSTER_MANAGER_CMD_FLAG_CHECK_OWNERS   1 << 9
102  #define CLUSTER_MANAGER_OPT_GETFRIENDS  1 << 0
103  #define CLUSTER_MANAGER_OPT_COLD        1 << 1
104  #define CLUSTER_MANAGER_OPT_UPDATE      1 << 2
105  #define CLUSTER_MANAGER_OPT_QUIET       1 << 6
106  #define CLUSTER_MANAGER_OPT_VERBOSE     1 << 7
107  #define CLUSTER_MANAGER_LOG_LVL_INFO    1
108  #define CLUSTER_MANAGER_LOG_LVL_WARN    2
109  #define CLUSTER_MANAGER_LOG_LVL_ERR     3
110  #define CLUSTER_MANAGER_LOG_LVL_SUCCESS 4
111  #define LOG_COLOR_BOLD      "29;1m"
112  #define LOG_COLOR_RED       "31;1m"
113  #define LOG_COLOR_GREEN     "32;1m"
114  #define LOG_COLOR_YELLOW    "33;1m"
115  #define LOG_COLOR_RESET     "0m"
116  #define CC_FORCE (1<<0)         &bsol;* Re-connect if already connected. */
117  #define CC_QUIET (1<<1)         &bsol;* Don't log connecting errors. */
118  int spectrum_palette_color_size = 19;
119  int spectrum_palette_color[] = {0,233,234,235,237,239,241,243,245,247,144,143,142,184,226,214,208,202,196};
120  int spectrum_palette_mono_size = 13;
121  int spectrum_palette_mono[] = {0,233,234,235,237,239,241,243,245,247,249,251,253};
122  int *spectrum_palette;
123  int spectrum_palette_size;
124  static uint64_t dictSdsHash(const void *key);
125  static int dictSdsKeyCompare(void *privdata, const void *key1,
126      const void *key2);
127  static void dictSdsDestructor(void *privdata, void *val);
128  static void dictListDestructor(void *privdata, void *val);
129  typedef struct clusterManagerCommand {
130      char *name;
131      int argc;
132      char **argv;
133      int flags;
134      int replicas;
135      char *from;
136      char *to;
137      char **weight;
138      int weight_argc;
139      char *master_id;
140      int slots;
141      int timeout;
142      int pipeline;
143      float threshold;
144  } clusterManagerCommand;
145  static void createClusterManagerCommand(char *cmdname, int argc, char **argv);
146  static redisContext *context;
147  static struct config {
148      char *hostip;
149      int hostport;
150      char *hostsocket;
151      PORT_LONG repeat;
152      PORT_LONG interval;
153      int dbnum;
154      int interactive;
155      int shutdown;
156      int monitor_mode;
157      int pubsub_mode;
158      int latency_mode;
159      int latency_dist_mode;
160      int latency_history;
161      int lru_test_mode;
162      PORT_LONGLONG lru_test_sample_size;
163      int cluster_mode;
164      int cluster_reissue_command;
165      int slave_mode;
166      int pipe_mode;
167      int pipe_timeout;
168      int getrdb_mode;
169      int stat_mode;
170      int scan_mode;
171      int intrinsic_latency_mode;
172      int intrinsic_latency_duration;
173      char *pattern;
174      char *rdb_filename;
175      int bigkeys;
176      int memkeys;
177      unsigned memkeys_samples;
178      int hotkeys;
179      int stdinarg; &bsol;* get last arg from stdin. (-x option) */
180      char *auth;
181      int output; &bsol;* output mode, see OUTPUT_* defines */
182      sds mb_delim;
183      char prompt[128];
184      char *eval;
185      int eval_ldb;
186      int eval_ldb_sync;  &bsol;* Ask for synchronous mode of the Lua debugger. */
187      int eval_ldb_end;   &bsol;* Lua debugging session ended. */
188      int enable_ldb_on_eval; &bsol;* Handle manual SCRIPT DEBUG + EVAL commands. */
189      int last_cmd_type;
190      int verbose;
191      clusterManagerCommand cluster_manager_command;
192      int no_auth_warning;
193  } config;
194  static struct pref {
195      int hints;
196  } pref;
197  static volatile sig_atomic_t force_cancel_loop = 0;
198  static void usage(void);
199  static void slaveMode(void);
200  char *redisGitSHA1(void);
201  char *redisGitDirty(void);
202  static int cliConnect(int force);
203  static char *getInfoField(char *info, char *field);
204  static PORT_LONG getLongInfoField(char *info, char *field);
205  #ifdef _WIN32
206  extern pthread_mutex_t used_memory_mutex;
207  #endif
208  uint16_t crc16(const char *buf, int len);
209  static PORT_LONGLONG ustime(void) {
210  #ifdef _WIN32
211      return GetHighResRelativeTime(1000000);
212  #else
213      struct timeval tv;
214      PORT_LONGLONG ust;
215      gettimeofday(&tv, NULL);
216      ust = ((PORT_LONGLONG) tv.tv_sec) * 1000000;
217      ust += tv.tv_usec;
218      return ust;
219  #endif
220  }
221  static PORT_LONGLONG mstime(void) {
222      return ustime() / 1000;
223  }
224  static void cliRefreshPrompt(void) {
225      if (config.eval_ldb) return;
226      sds prompt = sdsempty();
227      if (config.hostsocket != NULL) {
228          prompt = sdscatfmt(prompt,"redis %s",config.hostsocket);
229      } else {
230          char addr[256];
231          anetFormatAddr(addr, sizeof(addr), config.hostip, config.hostport);
232          prompt = sdscatlen(prompt,addr,strlen(addr));
233      }
234      if (config.dbnum != 0)
235          prompt = sdscatfmt(prompt,"[%i]",config.dbnum);
236      prompt = sdscatlen(prompt,"> ",2);
237      snprintf(config.prompt,sizeof(config.prompt),"%s",prompt);
238      sdsfree(prompt);
239  }
240  static sds getDotfilePath(char *envoverride, char *dotfilename) {
241      char *path = NULL;
242      sds dotPath = NULL;
243      path = getenv(envoverride);
244      if (path != NULL && *path != '\0') {
245          if (!strcmp("/dev/null", path)) {
246              return NULL;
247          }
248          dotPath = sdsnew(path);
249      } else {
250  #ifdef _WIN32
251          char *homeDrive = getenv("HOMEDRIVE");
252          char *homePath = getenv("HOMEPATH");
253          if ((homeDrive != NULL) && (*homeDrive != '\0')
254              && (homePath != NULL) && (*homePath != '\0')) {
255              dotPath = sdscatprintf(sdsempty(), "%s%s\\%s", homeDrive, homePath, dotfilename);
256          }
257  #else
258          char *home = getenv("HOME");
259          if (home != NULL && *home != '\0') {
260              dotPath = sdscatprintf(sdsempty(), "%s/%s", home, dotfilename);
261          }
262  #endif
263      }
264      return dotPath;
265  }
266  #define isHexChar(c) (isdigit(c) || (c >= 'a' && c <= 'f'))
267  #define decodeHexChar(c) (isdigit(c) ? c - '0' : c - 'a' + 10)
268  #define decodeHex(h, l) ((decodeHexChar(h) << 4) + decodeHexChar(l))
269  static sds percentDecode(const char *pe, size_t len) {
270      const char *end = pe + len;
271      sds ret = sdsempty();
272      const char *curr = pe;
273      while (curr < end) {
274          if (*curr == '%') {
275              if ((end - curr) < 2) {
276                  fprintf(stderr, "Incomplete URI encoding\n");
277                  exit(1);
278              }
279              char h = tolower(*(++curr));
280              char l = tolower(*(++curr));
281              if (!isHexChar(h) || !isHexChar(l)) {
282                  fprintf(stderr, "Illegal character in URI encoding\n");
283                  exit(1);
284              }
285              char c = decodeHex(h, l);
286              ret = sdscatlen(ret, &c, 1);
287              curr++;
288          } else {
289              ret = sdscatlen(ret, curr++, 1);
290          }
291      }
292      return ret;
293  }
294  static void parseRedisUri(const char *uri) {
295      const char *scheme = "redis:&bsol;&bsol;";
296      const char *curr = uri;
297      const char *end = uri + strlen(uri);
298      const char *userinfo, *username, *port, *host, *path;
299      if (strncasecmp(scheme, curr, strlen(scheme))) {
300          fprintf(stderr,"Invalid URI scheme\n");
301          exit(1);
302      }
303      curr += strlen(scheme);
304      if (curr == end) return;
305      if ((userinfo = strchr(curr,'@'))) {
306          if ((username = strchr(curr, ':')) && username < userinfo) {
307              curr = username + 1;
308          }
309          config.auth = percentDecode(curr, userinfo - curr);
310          curr = userinfo + 1;
311      }
312      if (curr == end) return;
313      path = strchr(curr, '/');
314      if (*curr != '/') {
315          host = path ? path - 1 : end;
316          if ((port = strchr(curr, ':'))) {
317              config.hostport = atoi(port + 1);
318              host = port - 1;
319          }
320          config.hostip = sdsnewlen(curr, host - curr + 1);
321      }
322      curr = path ? path + 1 : end;
323      if (curr == end) return;
324      config.dbnum = atoi(curr);
325  }
326  static uint64_t dictSdsHash(const void *key) {
327      return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));
328  }
329  static int dictSdsKeyCompare(void *privdata, const void *key1,
330          const void *key2)
331  {
332      int l1,l2;
333      DICT_NOTUSED(privdata);
334      l1 = sdslen((sds)key1);
335      l2 = sdslen((sds)key2);
336      if (l1 != l2) return 0;
337      return memcmp(key1, key2, l1) == 0;
338  }
339  static void dictSdsDestructor(void *privdata, void *val)
340  {
341      DICT_NOTUSED(privdata);
342      sdsfree(val);
343  }
344  void dictListDestructor(void *privdata, void *val)
345  {
346      DICT_NOTUSED(privdata);
347      listRelease((list*)val);
348  }
349  void _serverAssert(const char *estr, const char *file, int line) {
350      fprintf(stderr, "=== ASSERTION FAILED ===");
351      fprintf(stderr, "==> %s:%d '%s' is not true",file,line,estr);
352      *((char*)-1) = 'x';
353  }
354  #define CLI_HELP_COMMAND 1
355  #define CLI_HELP_GROUP 2
356  typedef struct {
357      int type;
358      int argc;
359      sds *argv;
360      sds full;
361      struct commandHelp *org;
362  } helpEntry;
363  static helpEntry *helpEntries;
364  static int helpEntriesLen;
365  static sds cliVersion(void) {
366      sds version;
367      version = sdscatprintf(sdsempty(), "%s", REDIS_VERSION);
368      if (strtoll(redisGitSHA1(),NULL,16)) {
369          version = sdscatprintf(version, " (git:%s", redisGitSHA1());
370          if (strtoll(redisGitDirty(),NULL,10))
371              version = sdscatprintf(version, "-dirty");
372          version = sdscat(version, ")");
373      }
374      return version;
375  }
376  static void cliInitHelp(void) {
377      int commandslen = sizeof(commandHelp)/sizeof(struct commandHelp);
378      int groupslen = sizeof(commandGroups)/sizeof(char*);
379      int i, len, pos = 0;
380      helpEntry tmp;
381      helpEntriesLen = len = commandslen+groupslen;
382      helpEntries = zmalloc(sizeof(helpEntry)*len);
383      for (i = 0; i < groupslen; i++) {
384          tmp.argc = 1;
385          tmp.argv = zmalloc(sizeof(sds));
386          tmp.argv[0] = sdscatprintf(sdsempty(),"@%s",commandGroups[i]);
387          tmp.full = tmp.argv[0];
388          tmp.type = CLI_HELP_GROUP;
389          tmp.org = NULL;
390          helpEntries[pos++] = tmp;
391      }
392      for (i = 0; i < commandslen; i++) {
393          tmp.argv = sdssplitargs(commandHelp[i].name,&tmp.argc);
394          tmp.full = sdsnew(commandHelp[i].name);
395          tmp.type = CLI_HELP_COMMAND;
396          tmp.org = &commandHelp[i];
397          helpEntries[pos++] = tmp;
398      }
399  }
400  static void cliIntegrateHelp(void) {
401      if (cliConnect(CC_QUIET) == REDIS_ERR) return;
402      redisReply *reply = redisCommand(context, "COMMAND");
403      if(reply == NULL || reply->type != REDIS_REPLY_ARRAY) return;
404      for (size_t j = 0; j < reply->elements; j++) {
405          redisReply *entry = reply->element[j];
406          if (entry->type != REDIS_REPLY_ARRAY || entry->elements < 4 ||
407              entry->element[0]->type != REDIS_REPLY_STRING ||
408              entry->element[1]->type != REDIS_REPLY_INTEGER ||
409              entry->element[3]->type != REDIS_REPLY_INTEGER) return;
410          char *cmdname = entry->element[0]->str;
411          int i;
412          for (i = 0; i < helpEntriesLen; i++) {
413              helpEntry *he = helpEntries+i;
414              if (!strcasecmp(he->argv[0],cmdname))
415                  break;
416          }
417          if (i != helpEntriesLen) continue;
418          helpEntriesLen++;
419          helpEntries = zrealloc(helpEntries,sizeof(helpEntry)*helpEntriesLen);
420          helpEntry *new = helpEntries+(helpEntriesLen-1);
421          new->argc = 1;
422          new->argv = zmalloc(sizeof(sds));
423          new->argv[0] = sdsnew(cmdname);
424          new->full = new->argv[0];
425          new->type = CLI_HELP_COMMAND;
426          sdstoupper(new->argv[0]);
427          struct commandHelp *ch = zmalloc(sizeof(*ch));
428          ch->name = new->argv[0];
429          ch->params = sdsempty();
430          int args = llabs(entry->element[1]->integer);
431          args--; &bsol;* Remove the command name itself. */
432          if (entry->element[3]->integer == 1) {
433              ch->params = sdscat(ch->params,"key ");
434              args--;
435          }
436          while(args-- > 0) ch->params = sdscat(ch->params,"arg ");
437          if (entry->element[1]->integer < 0)
438              ch->params = sdscat(ch->params,"...options...");
439          ch->summary = "Help not available";
440          ch->group = 0;
441          ch->since = "not known";
442          new->org = ch;
443      }
444      freeReplyObject(reply);
445  }
446  static void cliOutputCommandHelp(struct commandHelp *help, int group) {
447      printf("\r\n  \x1b[1m%s\x1b[0m \x1b[90m%s\x1b[0m\r\n", help->name, help->params);
448      printf("  \x1b[33msummary:\x1b[0m %s\r\n", help->summary);
449      printf("  \x1b[33msince:\x1b[0m %s\r\n", help->since);
450      if (group) {
451          printf("  \x1b[33mgroup:\x1b[0m %s\r\n", commandGroups[help->group]);
452      }
453  }
454  static void cliOutputGenericHelp(void) {
455      sds version = cliVersion();
456      printf(
457          "redis-cli %s\n"
458          "To get help about Redis commands type:\n"
459          "      \"help @<group>\" to get a list of commands in <group>\n"
460          "      \"help <command>\" for help on <command>\n"
461          "      \"help <tab>\" to get a list of possible help topics\n"
462          "      \"quit\" to exit\n"
463          "\n"
464          "To set redis-cli preferences:\n"
465          "      \":set hints\" enable online hints\n"
466          "      \":set nohints\" disable online hints\n"
467          "Set your preferences in ~/.redisclirc\n",
468          version
469      );
470      sdsfree(version);
471  }
472  static void cliOutputHelp(int argc, char **argv) {
473      int i, j, len;
474      int group = -1;
475      helpEntry *entry;
476      struct commandHelp *help;
477      if (argc == 0) {
478          cliOutputGenericHelp();
479          return;
480      } else if (argc > 0 && argv[0][0] == '@') {
481          len = sizeof(commandGroups)/sizeof(char*);
482          for (i = 0; i < len; i++) {
483              if (strcasecmp(argv[0]+1,commandGroups[i]) == 0) {
484                  group = i;
485                  break;
486              }
487          }
488      }
489      assert(argc > 0);
490      for (i = 0; i < helpEntriesLen; i++) {
491          entry = &helpEntries[i];
492          if (entry->type != CLI_HELP_COMMAND) continue;
493          help = entry->org;
494          if (group == -1) {
495              if (argc == entry->argc) {
496                  for (j = 0; j < argc; j++) {
497                      if (strcasecmp(argv[j],entry->argv[j]) != 0) break;
498                  }
499                  if (j == argc) {
500                      cliOutputCommandHelp(help,1);
501                  }
502              }
503          } else {
504              if (group == help->group) {
505                  cliOutputCommandHelp(help,0);
506              }
507          }
508      }
509      printf("\r\n");
510  }
511  static void completionCallback(const char *buf, linenoiseCompletions *lc) {
512      size_t startpos = 0;
513      int mask;
514      int i;
515      size_t matchlen;
516      sds tmp;
517      if (strncasecmp(buf,"help ",5) == 0) {
518          startpos = 5;
519          while (isspace(buf[startpos])) startpos++;
520          mask = CLI_HELP_COMMAND | CLI_HELP_GROUP;
521      } else {
522          mask = CLI_HELP_COMMAND;
523      }
524      for (i = 0; i < helpEntriesLen; i++) {
525          if (!(helpEntries[i].type & mask)) continue;
526          matchlen = strlen(buf+startpos);
527          if (strncasecmp(buf+startpos,helpEntries[i].full,matchlen) == 0) {
528              tmp = sdsnewlen(buf,startpos);
529              tmp = sdscat(tmp,helpEntries[i].full);
530              linenoiseAddCompletion(lc,tmp);
531              sdsfree(tmp);
532          }
533      }
534  }
535  static char *hintsCallback(const char *buf, int *color, int *bold) {
536      if (!pref.hints) return NULL;
537      int i, argc, buflen = (int)strlen(buf);                                     WIN_PORT_FIX &bsol;* cast int */
538      sds *argv = sdssplitargs(buf,&argc);
539      int endspace = buflen && isspace(buf[buflen-1]);
540      if (argc == 0) {
541          sdsfreesplitres(argv,argc);
542          return NULL;
543      }
544      for (i = 0; i < helpEntriesLen; i++) {
545          if (!(helpEntries[i].type & CLI_HELP_COMMAND)) continue;
546          if (strcasecmp(argv[0],helpEntries[i].full) == 0)
547          {
548              *color = 90;
549              *bold = 0;
550              sds hint = sdsnew(helpEntries[i].org->params);
551              int toremove = argc-1;
552              while(toremove > 0 && sdslen(hint)) {
553                  if (hint[0] == '[') break;
554                  if (hint[0] == ' ') toremove--;
555                  sdsrange(hint,1,-1);
556              }
557              if (!endspace) {
558                  sds newhint = sdsnewlen(" ",1);
559                  newhint = sdscatsds(newhint,hint);
560                  sdsfree(hint);
561                  hint = newhint;
562              }
563              sdsfreesplitres(argv,argc);
564              return hint;
565          }
566      }
567      sdsfreesplitres(argv,argc);
568      return NULL;
569  }
570  static void freeHintsCallback(void *ptr) {
571      sdsfree(ptr);
572  }
573  static int cliAuth(void) {
574      redisReply *reply;
575      if (config.auth == NULL) return REDIS_OK;
576      reply = redisCommand(context,"AUTH %s",config.auth);
577      if (reply != NULL) {
578          freeReplyObject(reply);
579          return REDIS_OK;
580      }
581      return REDIS_ERR;
582  }
583  static int cliSelect(void) {
584      redisReply *reply;
585      if (config.dbnum == 0) return REDIS_OK;
586      reply = redisCommand(context,"SELECT %d",config.dbnum);
587      if (reply != NULL) {
588          int result = REDIS_OK;
589          if (reply->type == REDIS_REPLY_ERROR) result = REDIS_ERR;
590          freeReplyObject(reply);
591          return result;
592      }
593      return REDIS_ERR;
594  }
595  static int cliConnect(int flags) {
596      if (context == NULL || flags & CC_FORCE) {
597          if (context != NULL) {
598              redisFree(context);
599          }
600          if (config.hostsocket == NULL) {
601              context = redisConnect(config.hostip,config.hostport);
602          } else {
603              context = redisConnectUnix(config.hostsocket);
604          }
605          if (context->err) {
606              if (!(flags & CC_QUIET)) {
607                  fprintf(stderr,"Could not connect to Redis at ");
608                  if (config.hostsocket == NULL)
609                      fprintf(stderr,"%s:%d: %s\n",
610                          config.hostip,config.hostport,context->errstr);
611                  else
612                      fprintf(stderr,"%s: %s\n",
613                          config.hostsocket,context->errstr);
614              }
615              redisFree(context);
616              context = NULL;
617              return REDIS_ERR;
618          }
619          anetKeepAlive(NULL, context->fd, REDIS_CLI_KEEPALIVE_INTERVAL);
620          if (cliAuth() != REDIS_OK)
621              return REDIS_ERR;
622          if (cliSelect() != REDIS_OK)
623              return REDIS_ERR;
624      }
625      return REDIS_OK;
626  }
627  static void cliPrintContextError(void) {
628      if (context == NULL) return;
629      fprintf(stderr,"Error: %s\n",context->errstr);
630  }
631  static sds cliFormatReplyTTY(redisReply *r, char *prefix) {
632      sds out = sdsempty();
633      switch (r->type) {
634      case REDIS_REPLY_ERROR:
635          out = sdscatprintf(out,"(error) %s\n", r->str);
636      break;
637      case REDIS_REPLY_STATUS:
638          out = sdscat(out,r->str);
639          out = sdscat(out,"\n");
640      break;
641      case REDIS_REPLY_INTEGER:
642          out = sdscatprintf(out,"(integer) %lld\n",r->integer);
643      break;
644      case REDIS_REPLY_STRING:
645          out = sdscatrepr(out,r->str,r->len);
646          out = sdscat(out,"\n");
647      break;
648      case REDIS_REPLY_NIL:
649          out = sdscat(out,"(nil)\n");
650      break;
651      case REDIS_REPLY_ARRAY:
652          if (r->elements == 0) {
653              out = sdscat(out,"(empty list or set)\n");
654          } else {
655              unsigned int i, idxlen = 0;
656              char _prefixlen[16];
657              char _prefixfmt[16];
658              sds _prefix;
659              sds tmp;
660              i = r->elements;
661              do {
662                  idxlen++;
663                  i /= 10;
664              } while(i);
665              memset(_prefixlen,' ',idxlen+2);
666              _prefixlen[idxlen+2] = '\0';
667              _prefix = sdscat(sdsnew(prefix),_prefixlen);
668              snprintf(_prefixfmt,sizeof(_prefixfmt),"%%s%%%ud) ",idxlen);
669              for (i = 0; i < r->elements; i++) {
670                  out = sdscatprintf(out,_prefixfmt,i == 0 ? "" : prefix,i+1);
671                  tmp = cliFormatReplyTTY(r->element[i],_prefix);
672                  out = sdscatlen(out,tmp,sdslen(tmp));
673                  sdsfree(tmp);
674              }
675              sdsfree(_prefix);
676          }
677      break;
678      default:
679          fprintf(stderr,"Unknown reply type: %d\n", r->type);
680          exit(1);
681      }
682      return out;
683  }
684  int isColorTerm(void) {
685      char *t = getenv("TERM");
686      return t != NULL && strstr(t,"xterm") != NULL;
687  }
688  sds sdscatcolor(sds o, char *s, size_t len, char *color) {
689      if (!isColorTerm()) return sdscatlen(o,s,len);
690      int bold = strstr(color,"bold") != NULL;
691      int ccode = 37; &bsol;* Defaults to white. */
692      if (strstr(color,"red")) ccode = 31;
693      else if (strstr(color,"green")) ccode = 32;
694      else if (strstr(color,"yellow")) ccode = 33;
695      else if (strstr(color,"blue")) ccode = 34;
696      else if (strstr(color,"magenta")) ccode = 35;
697      else if (strstr(color,"cyan")) ccode = 36;
698      else if (strstr(color,"white")) ccode = 37;
699      o = sdscatfmt(o,"\033[%i;%i;49m",bold,ccode);
700      o = sdscatlen(o,s,len);
701      o = sdscat(o,"\033[0m");
702      return o;
703  }
704  sds sdsCatColorizedLdbReply(sds o, char *s, size_t len) {
705      char *color = "white";
706      if (strstr(s,"<debug>")) color = "bold";
707      if (strstr(s,"<redis>")) color = "green";
708      if (strstr(s,"<reply>")) color = "cyan";
709      if (strstr(s,"<error>")) color = "red";
710      if (strstr(s,"<hint>")) color = "bold";
711      if (strstr(s,"<value>") || strstr(s,"<retval>")) color = "magenta";
712      if (len > 4 && isdigit(s[3])) {
713          if (s[1] == '>') color = "yellow"; &bsol;* Current line. */
714          else if (s[2] == '#') color = "bold"; &bsol;* Break point. */
715      }
716      return sdscatcolor(o,s,len,color);
717  }
718  static sds cliFormatReplyRaw(redisReply *r) {
719      sds out = sdsempty(), tmp;
720      size_t i;
721      switch (r->type) {
722      case REDIS_REPLY_NIL:
723          break;
724      case REDIS_REPLY_ERROR:
725          out = sdscatlen(out,r->str,r->len);
726          out = sdscatlen(out,"\n",1);
727          break;
728      case REDIS_REPLY_STATUS:
729      case REDIS_REPLY_STRING:
730          if (r->type == REDIS_REPLY_STATUS && config.eval_ldb) {
731              if (strstr(r->str,"<endsession>") == r->str) {
732                  config.enable_ldb_on_eval = 0;
733                  config.eval_ldb = 0;
734                  config.eval_ldb_end = 1; &bsol;* Signal the caller session ended. */
735                  config.output = OUTPUT_STANDARD;
736                  cliRefreshPrompt();
737              } else {
738                  out = sdsCatColorizedLdbReply(out,r->str,r->len);
739              }
740          } else {
741              out = sdscatlen(out,r->str,r->len);
742          }
743          break;
744      case REDIS_REPLY_INTEGER:
745          out = sdscatprintf(out,"%I64d",r->integer);   WIN_PORT_FIX &bsol;* %lld -> %I64d */
746          break;
747      case REDIS_REPLY_ARRAY:
748          for (i = 0; i < r->elements; i++) {
749              if (i > 0) out = sdscat(out,config.mb_delim);
750              tmp = cliFormatReplyRaw(r->element[i]);
751              out = sdscatlen(out,tmp,sdslen(tmp));
752              sdsfree(tmp);
753          }
754          break;
755      default:
756          fprintf(stderr,"Unknown reply type: %d\n", r->type);
757          exit(1);
758      }
759      return out;
760  }
761  static sds cliFormatReplyCSV(redisReply *r) {
762      unsigned int i;
763      sds out = sdsempty();
764      switch (r->type) {
765      case REDIS_REPLY_ERROR:
766          out = sdscat(out,"ERROR,");
767          out = sdscatrepr(out,r->str,strlen(r->str));
768      break;
769      case REDIS_REPLY_STATUS:
770          out = sdscatrepr(out,r->str,r->len);
771      break;
772      case REDIS_REPLY_INTEGER:
773          out = sdscatprintf(out,"%I64d",r->integer);   WIN_PORT_FIX &bsol;* %lld -> %I64d */
774      break;
775      case REDIS_REPLY_STRING:
776          out = sdscatrepr(out,r->str,r->len);
777      break;
778      case REDIS_REPLY_NIL:
779          out = sdscat(out,"NIL");
780      break;
781      case REDIS_REPLY_ARRAY:
782          for (i = 0; i < r->elements; i++) {
783              sds tmp = cliFormatReplyCSV(r->element[i]);
784              out = sdscatlen(out,tmp,sdslen(tmp));
785              if (i != r->elements-1) out = sdscat(out,",");
786              sdsfree(tmp);
787          }
788      break;
789      default:
790          fprintf(stderr,"Unknown reply type: %d\n", r->type);
791          exit(1);
792      }
793      return out;
794  }
795  static int cliReadReply(int output_raw_strings) {
796      void *_reply;
797      redisReply *reply;
798      sds out = NULL;
799      int output = 1;
800      if (redisGetReply(context,&_reply) != REDIS_OK) {
801          if (config.shutdown) {
802              redisFree(context);
803              context = NULL;
804              return REDIS_OK;
805          }
806          if (config.interactive) {
807              if (context->err == REDIS_ERR_IO &&
808                  (errno == ECONNRESET || errno == EPIPE))
809                  return REDIS_ERR;
810              if (context->err == REDIS_ERR_EOF)
811                  return REDIS_ERR;
812          }
813          cliPrintContextError();
814          exit(1);
815          return REDIS_ERR; &bsol;* avoid compiler warning */
816      }
817      reply = (redisReply*)_reply;
818      config.last_cmd_type = reply->type;
819      if (config.cluster_mode && reply->type == REDIS_REPLY_ERROR &&
820          (!strncmp(reply->str,"MOVED",5) || !strcmp(reply->str,"ASK")))
821      {
822          char *p = reply->str, *s;
823          int slot;
824          output = 0;
825          s = strchr(p,' ');      &bsol;* MOVED[S]3999 127.0.0.1:6381 */
826          p = strchr(s+1,' ');    &bsol;* MOVED[S]3999[P]127.0.0.1:6381 */
827          *p = '\0';
828          slot = atoi(s+1);
829          s = strrchr(p+1,':');    &bsol;* MOVED 3999[P]127.0.0.1[S]6381 */
830          *s = '\0';
831          sdsfree(config.hostip);
832          config.hostip = sdsnew(p+1);
833          config.hostport = atoi(s+1);
834          if (config.interactive)
835              printf("-> Redirected to slot [%d] located at %s:%d\n",
836                  slot, config.hostip, config.hostport);
837          config.cluster_reissue_command = 1;
838          cliRefreshPrompt();
839      }
840      if (output) {
841          if (output_raw_strings) {
842              out = cliFormatReplyRaw(reply);
843          } else {
844              if (config.output == OUTPUT_RAW) {
845                  out = cliFormatReplyRaw(reply);
846                  out = sdscat(out,"\n");
847              } else if (config.output == OUTPUT_STANDARD) {
848                  out = cliFormatReplyTTY(reply,"");
849              } else if (config.output == OUTPUT_CSV) {
850                  out = cliFormatReplyCSV(reply);
851                  out = sdscat(out,"\n");
852              }
853          }
854  #ifdef _WIN32
855          fprintf(stdout, "%s", out);
856  #else
857          fwrite(out,sdslen(out),1,stdout);
858  #endif
859          sdsfree(out);
860      }
861      freeReplyObject(reply);
862      return REDIS_OK;
863  }
864  static int cliSendCommand(int argc, char **argv, PORT_LONG repeat) {
865      char *command = argv[0];
866      size_t *argvlen;
867      int j, output_raw;
868      if (!config.eval_ldb && &bsol;* In debugging mode, let's pass "help" to Redis. */
869          (!strcasecmp(command,"help") || !strcasecmp(command,"?"))) {
870          cliOutputHelp(--argc, ++argv);
871          return REDIS_OK;
872      }
873      if (context == NULL) return REDIS_ERR;
874      output_raw = 0;
875      if (!strcasecmp(command,"info") ||
876          !strcasecmp(command,"lolwut") ||
877          (argc >= 2 && !strcasecmp(command,"debug") &&
878                         !strcasecmp(argv[1],"htstats")) ||
879          (argc >= 2 && !strcasecmp(command,"debug") &&
880                         !strcasecmp(argv[1],"htstats-key")) ||
881          (argc >= 2 && !strcasecmp(command,"memory") &&
882                        (!strcasecmp(argv[1],"malloc-stats") ||
883                         !strcasecmp(argv[1],"doctor"))) ||
884          (argc == 2 && !strcasecmp(command,"cluster") &&
885                        (!strcasecmp(argv[1],"nodes") ||
886                         !strcasecmp(argv[1],"info"))) ||
887          (argc >= 2 && !strcasecmp(command,"client") &&
888                         !strcasecmp(argv[1],"list")) ||
889          (argc == 3 && !strcasecmp(command,"latency") &&
890                         !strcasecmp(argv[1],"graph")) ||
891          (argc == 2 && !strcasecmp(command,"latency") &&
892                         !strcasecmp(argv[1],"doctor")))
893      {
894          output_raw = 1;
895      }
896      if (!strcasecmp(command,"shutdown")) config.shutdown = 1;
897      if (!strcasecmp(command,"monitor")) config.monitor_mode = 1;
898      if (!strcasecmp(command,"subscribe") ||
899          !strcasecmp(command,"psubscribe")) config.pubsub_mode = 1;
900      if (!strcasecmp(command,"sync") ||
901          !strcasecmp(command,"psync")) config.slave_mode = 1;
902      if (argc == 3 && !strcasecmp(argv[0],"script") &&
903                       !strcasecmp(argv[1],"debug"))
904      {
905          if (!strcasecmp(argv[2],"yes") || !strcasecmp(argv[2],"sync")) {
906              config.enable_ldb_on_eval = 1;
907          } else {
908              config.enable_ldb_on_eval = 0;
909          }
910      }
911      if (!strcasecmp(command,"eval") && config.enable_ldb_on_eval) {
912          config.eval_ldb = 1;
913          config.output = OUTPUT_RAW;
914      }
915      argvlen = zmalloc(argc*sizeof(size_t));
916      for (j = 0; j < argc; j++)
917          argvlen[j] = sdslen(argv[j]);
918      while(repeat < 0 || repeat-- > 0) {
919          redisAppendCommandArgv(context,argc,(const char**)argv,argvlen);
920          while (config.monitor_mode) {
921              if (cliReadReply(output_raw) != REDIS_OK) exit(1);
922              fflush(stdout);
923          }
924          if (config.pubsub_mode) {
925              if (config.output != OUTPUT_RAW)
926                  printf("Reading messages... (press Ctrl-C to quit)\n");
927              while (1) {
928                  if (cliReadReply(output_raw) != REDIS_OK) exit(1);
929              }
930          }
931          if (config.slave_mode) {
932              printf("Entering replica output mode...  (press Ctrl-C to quit)\n");
933              slaveMode();
934              config.slave_mode = 0;
935              zfree(argvlen);
936              return REDIS_ERR;  &bsol;* Error = slaveMode lost connection to master */
937          }
938          if (cliReadReply(output_raw) != REDIS_OK) {
939              zfree(argvlen);
940              return REDIS_ERR;
941          } else {
942              if (!strcasecmp(command,"select") && argc == 2 && config.last_cmd_type != REDIS_REPLY_ERROR) {
943                  config.dbnum = atoi(argv[1]);
944                  cliRefreshPrompt();
945              } else if (!strcasecmp(command,"auth") && argc == 2) {
946                  cliSelect();
947              }
948          }
949          if (config.cluster_reissue_command){
950              break;
951          }
952          if (config.interval) usleep(config.interval);
953          fflush(stdout); &bsol;* Make it grep friendly */
954      }
955      zfree(argvlen);
956      return REDIS_OK;
957  }
958  static redisReply *reconnectingRedisCommand(redisContext *c, const char *fmt, ...) {
959      redisReply *reply = NULL;
960      int tries = 0;
961      va_list ap;
962      assert(!c->err);
963      while(reply == NULL) {
964          while (c->err & (REDIS_ERR_IO | REDIS_ERR_EOF)) {
965              printf("\r\x1b[0K"); &bsol;* Cursor to left edge + clear line. */
966              printf("Reconnecting... %d\r", ++tries);
967              fflush(stdout);
968              redisFree(c);
969              c = redisConnect(config.hostip,config.hostport);
970              usleep(1000000);
971          }
972          va_start(ap,fmt);
973          reply = redisvCommand(c,fmt,ap);
974          va_end(ap);
975          if (c->err && !(c->err & (REDIS_ERR_IO | REDIS_ERR_EOF))) {
976              fprintf(stderr, "Error: %s\n", c->errstr);
977              exit(1);
978          } else if (tries > 0) {
979              printf("\r\x1b[0K"); &bsol;* Cursor to left edge + clear line. */
980          }
981      }
982      context = c;
983      return reply;
984  }
985  static int parseOptions(int argc, char **argv) {
986      int i;
987      for (i = 1; i < argc; i++) {
988          int lastarg = i==argc-1;
989          if (!strcmp(argv[i],"-h") && !lastarg) {
990              sdsfree(config.hostip);
991              config.hostip = sdsnew(argv[++i]);
992          } else if (!strcmp(argv[i],"-h") && lastarg) {
993              usage();
994          } else if (!strcmp(argv[i],"--help")) {
995              usage();
996          } else if (!strcmp(argv[i],"-x")) {
997              config.stdinarg = 1;
998          } else if (!strcmp(argv[i],"-p") && !lastarg) {
999              config.hostport = atoi(argv[++i]);
1000          } else if (!strcmp(argv[i],"-s") && !lastarg) {
1001              config.hostsocket = argv[++i];
1002          } else if (!strcmp(argv[i],"-r") && !lastarg) {
1003              config.repeat = (PORT_LONG)strtoll(argv[++i],NULL,10);
1004          } else if (!strcmp(argv[i],"-i") && !lastarg) {
1005              double seconds = atof(argv[++i]);
1006              config.interval = (PORT_LONG)(seconds*1000000);
1007          } else if (!strcmp(argv[i],"-n") && !lastarg) {
1008              config.dbnum = atoi(argv[++i]);
1009          } else if (!strcmp(argv[i], "--no-auth-warning")) {
1010              config.no_auth_warning = 1;
1011          } else if (!strcmp(argv[i],"-a") && !lastarg) {
1012              config.auth = argv[++i];
1013          } else if (!strcmp(argv[i],"-u") && !lastarg) {
1014              parseRedisUri(argv[++i]);
1015          } else if (!strcmp(argv[i],"--raw")) {
1016              config.output = OUTPUT_RAW;
1017          } else if (!strcmp(argv[i],"--no-raw")) {
1018              config.output = OUTPUT_STANDARD;
1019          } else if (!strcmp(argv[i],"--csv")) {
1020              config.output = OUTPUT_CSV;
1021          } else if (!strcmp(argv[i],"--latency")) {
1022              config.latency_mode = 1;
1023          } else if (!strcmp(argv[i],"--latency-dist")) {
1024              config.latency_dist_mode = 1;
1025          } else if (!strcmp(argv[i],"--mono")) {
1026              spectrum_palette = spectrum_palette_mono;
1027              spectrum_palette_size = spectrum_palette_mono_size;
1028          } else if (!strcmp(argv[i],"--latency-history")) {
1029              config.latency_mode = 1;
1030              config.latency_history = 1;
1031          } else if (!strcmp(argv[i],"--lru-test") && !lastarg) {
1032              config.lru_test_mode = 1;
1033              config.lru_test_sample_size = strtoll(argv[++i],NULL,10);
1034          } else if (!strcmp(argv[i],"--slave")) {
1035              config.slave_mode = 1;
1036          } else if (!strcmp(argv[i],"--replica")) {
1037              config.slave_mode = 1;
1038          } else if (!strcmp(argv[i],"--stat")) {
1039              config.stat_mode = 1;
1040          } else if (!strcmp(argv[i],"--scan")) {
1041              config.scan_mode = 1;
1042          } else if (!strcmp(argv[i],"--pattern") && !lastarg) {
1043              config.pattern = argv[++i];
1044          } else if (!strcmp(argv[i],"--intrinsic-latency") && !lastarg) {
1045              config.intrinsic_latency_mode = 1;
1046              config.intrinsic_latency_duration = atoi(argv[++i]);
1047          } else if (!strcmp(argv[i],"--rdb") && !lastarg) {
1048              config.getrdb_mode = 1;
1049              config.rdb_filename = argv[++i];
1050          } else if (!strcmp(argv[i],"--pipe")) {
1051              config.pipe_mode = 1;
1052          } else if (!strcmp(argv[i],"--pipe-timeout") && !lastarg) {
1053              config.pipe_timeout = atoi(argv[++i]);
1054          } else if (!strcmp(argv[i],"--bigkeys")) {
1055              config.bigkeys = 1;
1056          } else if (!strcmp(argv[i],"--memkeys")) {
1057              config.memkeys = 1;
1058              config.memkeys_samples = 0; &bsol;* use redis default */
1059          } else if (!strcmp(argv[i],"--memkeys-samples")) {
1060              config.memkeys = 1;
1061              config.memkeys_samples = atoi(argv[++i]);
1062          } else if (!strcmp(argv[i],"--hotkeys")) {
1063              config.hotkeys = 1;
1064          } else if (!strcmp(argv[i],"--eval") && !lastarg) {
1065              config.eval = argv[++i];
1066          } else if (!strcmp(argv[i],"--ldb")) {
1067              config.eval_ldb = 1;
1068              config.output = OUTPUT_RAW;
1069          } else if (!strcmp(argv[i],"--ldb-sync-mode")) {
1070              config.eval_ldb = 1;
1071              config.eval_ldb_sync = 1;
1072              config.output = OUTPUT_RAW;
1073          } else if (!strcmp(argv[i],"-c")) {
1074              config.cluster_mode = 1;
1075          } else if (!strcmp(argv[i],"-d") && !lastarg) {
1076              sdsfree(config.mb_delim);
1077              config.mb_delim = sdsnew(argv[++i]);
1078          } else if (!strcmp(argv[i],"--verbose")) {
1079              config.verbose = 1;
1080          } else if (!strcmp(argv[i],"--cluster") && !lastarg) {
1081              if (CLUSTER_MANAGER_MODE()) usage();
1082              char *cmd = argv[++i];
1083              int j = i;
1084              while (j < argc && argv[j][0] != '-') j++;
1085              if (j > i) j--;
1086              createClusterManagerCommand(cmd, j - i, argv + i + 1);
1087              i = j;
1088          } else if (!strcmp(argv[i],"--cluster") && lastarg) {
1089              usage();
1090          } else if (!strcmp(argv[i],"--cluster-replicas") && !lastarg) {
1091              config.cluster_manager_command.replicas = atoi(argv[++i]);
1092          } else if (!strcmp(argv[i],"--cluster-master-id") && !lastarg) {
1093              config.cluster_manager_command.master_id = argv[++i];
1094          } else if (!strcmp(argv[i],"--cluster-from") && !lastarg) {
1095              config.cluster_manager_command.from = argv[++i];
1096          } else if (!strcmp(argv[i],"--cluster-to") && !lastarg) {
1097              config.cluster_manager_command.to = argv[++i];
1098          } else if (!strcmp(argv[i],"--cluster-weight") && !lastarg) {
1099              if (config.cluster_manager_command.weight != NULL) {
1100                  fprintf(stderr, "WARNING: you cannot use --cluster-weight "
1101                                  "more than once.\n"
1102                                  "You can set more weights by adding them "
1103                                  "as a space-separated list, ie:\n"
1104                                  "--cluster-weight n1=w n2=w\n");
1105                  exit(1);
1106              }
1107              int widx = i + 1;
1108              char **weight = argv + widx;
1109              int wargc = 0;
1110              for (; widx < argc; widx++) {
1111                  if (strstr(argv[widx], "--") == argv[widx]) break;
1112                  if (strchr(argv[widx], '=') == NULL) break;
1113                  wargc++;
1114              }
1115              if (wargc > 0) {
1116                  config.cluster_manager_command.weight = weight;
1117                  config.cluster_manager_command.weight_argc = wargc;
1118                  i += wargc;
1119              }
1120          } else if (!strcmp(argv[i],"--cluster-slots") && !lastarg) {
1121              config.cluster_manager_command.slots = atoi(argv[++i]);
1122          } else if (!strcmp(argv[i],"--cluster-timeout") && !lastarg) {
1123              config.cluster_manager_command.timeout = atoi(argv[++i]);
1124          } else if (!strcmp(argv[i],"--cluster-pipeline") && !lastarg) {
1125              config.cluster_manager_command.pipeline = atoi(argv[++i]);
1126          } else if (!strcmp(argv[i],"--cluster-threshold") && !lastarg) {
1127              config.cluster_manager_command.threshold = atof(argv[++i]);
1128          } else if (!strcmp(argv[i],"--cluster-yes")) {
1129              config.cluster_manager_command.flags |=
1130                  CLUSTER_MANAGER_CMD_FLAG_YES;
1131          } else if (!strcmp(argv[i],"--cluster-simulate")) {
1132              config.cluster_manager_command.flags |=
1133                  CLUSTER_MANAGER_CMD_FLAG_SIMULATE;
1134          } else if (!strcmp(argv[i],"--cluster-replace")) {
1135              config.cluster_manager_command.flags |=
1136                  CLUSTER_MANAGER_CMD_FLAG_REPLACE;
1137          } else if (!strcmp(argv[i],"--cluster-copy")) {
1138              config.cluster_manager_command.flags |=
1139                  CLUSTER_MANAGER_CMD_FLAG_COPY;
1140          } else if (!strcmp(argv[i],"--cluster-slave")) {
1141              config.cluster_manager_command.flags |=
1142                  CLUSTER_MANAGER_CMD_FLAG_SLAVE;
1143          } else if (!strcmp(argv[i],"--cluster-use-empty-masters")) {
1144              config.cluster_manager_command.flags |=
1145                  CLUSTER_MANAGER_CMD_FLAG_EMPTYMASTER;
1146          } else if (!strcmp(argv[i],"--cluster-search-multiple-owners")) {
1147              config.cluster_manager_command.flags |=
1148                  CLUSTER_MANAGER_CMD_FLAG_CHECK_OWNERS;
1149          } else if (!strcmp(argv[i],"-v") || !strcmp(argv[i], "--version")) {
1150              sds version = cliVersion();
1151              printf("redis-cli %s\n", version);
1152              sdsfree(version);
1153              exit(0);
1154          } else if (CLUSTER_MANAGER_MODE() && argv[i][0] != '-') {
1155              if (config.cluster_manager_command.argc == 0) {
1156                  int j = i + 1;
1157                  while (j < argc && argv[j][0] != '-') j++;
1158                  int cmd_argc = j - i;
1159                  config.cluster_manager_command.argc = cmd_argc;
1160                  config.cluster_manager_command.argv = argv + i;
1161                  if (cmd_argc > 1) i = j - 1;
1162              }
1163          } else {
1164              if (argv[i][0] == '-') {
1165                  fprintf(stderr,
1166                      "Unrecognized option or bad number of args for: '%s'\n",
1167                      argv[i]);
1168                  exit(1);
1169              } else {
1170                  break;
1171              }
1172          }
1173      }
1174      if (config.eval_ldb && config.eval == NULL) {
1175          fprintf(stderr,"Options --ldb and --ldb-sync-mode require --eval.\n");
1176          fprintf(stderr,"Try %s --help for more information.\n", argv[0]);
1177          exit(1);
1178      }
1179      if (!config.no_auth_warning && config.auth != NULL) {
1180          fputs("Warning: Using a password with '-a' or '-u' option on the command"
1181                " line interface may not be safe.\n", stderr);
1182      }
1183      return i;
1184  }
1185  static void parseEnv() {
1186      char *auth = getenv(REDIS_CLI_AUTH_ENV);
1187      if (auth != NULL && config.auth == NULL) {
1188          config.auth = auth;
1189      }
1190      char *cluster_yes = getenv(REDIS_CLI_CLUSTER_YES_ENV);
1191      if (cluster_yes != NULL && !strcmp(cluster_yes, "1")) {
1192          config.cluster_manager_command.flags |= CLUSTER_MANAGER_CMD_FLAG_YES;
1193      }
1194  }
1195  static sds readArgFromStdin(void) {
1196      char buf[1024];
1197      sds arg = sdsempty();
1198      while(1) {
1199          int nread = (int)read(fileno(stdin),buf,1024);                          WIN_PORT_FIX &bsol;* cast (int) */
1200          if (nread == 0) break;
1201          else if (nread == -1) {
1202              perror("Reading from standard input");
1203              exit(1);
1204          }
1205          arg = sdscatlen(arg,buf,nread);
1206      }
1207      return arg;
1208  }
1209  static void usage(void) {
1210      sds version = cliVersion();
1211      fprintf(stderr,
1212  "redis-cli %s\n"
1213  "\n"
1214  "Usage: redis-cli [OPTIONS] [cmd [arg [arg ...]]]\n"
1215  "  -h <hostname>      Server hostname (default: 127.0.0.1).\n"
1216  "  -p <port>          Server port (default: 6379).\n"
1217  "  -s <socket>        Server socket (overrides hostname and port).\n"
1218  "  -a <password>      Password to use when connecting to the server.\n"
1219  "                     You can also use the " REDIS_CLI_AUTH_ENV " environment\n"
1220  "                     variable to pass this password more safely\n"
1221  "                     (if both are used, this argument takes predecence).\n"
1222  "  -u <uri>           Server URI.\n"
1223  "  -r <repeat>        Execute specified command N times.\n"
1224  "  -i <interval>      When -r is used, waits <interval> seconds per command.\n"
1225  "                     It is possible to specify sub-second times like -i 0.1.\n"
1226  "  -n <db>            Database number.\n"
1227  "  -x                 Read last argument from STDIN.\n"
1228  "  -d <delimiter>     Multi-bulk delimiter in for raw formatting (default: \\n).\n"
1229  "  -c                 Enable cluster mode (follow -ASK and -MOVED redirections).\n"
1230  "  --raw              Use raw formatting for replies (default when STDOUT is\n"
1231  "                     not a tty).\n"
1232  "  --no-raw           Force formatted output even when STDOUT is not a tty.\n"
1233  "  --csv              Output in CSV format.\n"
1234  "  --stat             Print rolling stats about server: mem, clients, ...\n"
1235  "  --latency          Enter a special mode continuously sampling latency.\n"
1236  "                     If you use this mode in an interactive session it runs\n"
1237  "                     forever displaying real-time stats. Otherwise if --raw or\n"
1238  "                     --csv is specified, or if you redirect the output to a non\n"
1239  "                     TTY, it samples the latency for 1 second (you can use\n"
1240  "                     -i to change the interval), then produces a single output\n"
1241  "                     and exits.\n"
1242  "  --latency-history  Like --latency but tracking latency changes over time.\n"
1243  "                     Default time interval is 15 sec. Change it using -i.\n"
1244  "  --latency-dist     Shows latency as a spectrum, requires xterm 256 colors.\n"
1245  "                     Default time interval is 1 sec. Change it using -i.\n"
1246  "  --lru-test <keys>  Simulate a cache workload with an 80-20 distribution.\n"
1247  "  --replica          Simulate a replica showing commands received from the master.\n"
1248  "  --rdb <filename>   Transfer an RDB dump from remote server to local file.\n"
1249  "  --pipe             Transfer raw Redis protocol from stdin to server.\n"
1250  "  --pipe-timeout <n> In --pipe mode, abort with error if after sending all data.\n"
1251  "                     no reply is received within <n> seconds.\n"
1252  "                     Default timeout: %d. Use 0 to wait forever.\n"
1253  "  --bigkeys          Sample Redis keys looking for keys with many elements (complexity).\n"
1254  "  --memkeys          Sample Redis keys looking for keys consuming a lot of memory.\n"
1255  "  --memkeys-samples <n> Sample Redis keys looking for keys consuming a lot of memory.\n"
1256  "                     And define number of key elements to sample\n"
1257  "  --hotkeys          Sample Redis keys looking for hot keys.\n"
1258  "                     only works when maxmemory-policy is *lfu.\n"
1259  "  --scan             List all keys using the SCAN command.\n"
1260  "  --pattern <pat>    Useful with --scan to specify a SCAN pattern.\n"
1261  "  --intrinsic-latency <sec> Run a test to measure intrinsic system latency.\n"
1262  "                     The test will run for the specified amount of seconds.\n"
1263  "  --eval <file>      Send an EVAL command using the Lua script at <file>.\n"
1264  "  --ldb              Used with --eval enable the Redis Lua debugger.\n"
1265  "  --ldb-sync-mode    Like --ldb but uses the synchronous Lua debugger, in\n"
1266  "                     this mode the server is blocked and script changes are\n"
1267  "                     not rolled back from the server memory.\n"
1268  "  --cluster <command> [args...] [opts...]\n"
1269  "                     Cluster Manager command and arguments (see below).\n"
1270  "  --verbose          Verbose mode.\n"
1271  "  --no-auth-warning  Don't show warning message when using password on command\n"
1272  "                     line interface.\n"
1273  "  --help             Output this help and exit.\n"
1274  "  --version          Output version and exit.\n"
1275  "\n",
1276      version, REDIS_CLI_DEFAULT_PIPE_TIMEOUT);
1277      fprintf(stderr,
1278  "Cluster Manager Commands:\n"
1279  "  Use --cluster help to list all available cluster manager commands.\n"
1280  "\n"
1281  "Examples:\n"
1282  "  cat /etc/passwd | redis-cli -x set mypasswd\n"
1283  "  redis-cli get mypasswd\n"
1284  "  redis-cli -r 100 lpush mylist x\n"
1285  "  redis-cli -r 100 -i 1 info | grep used_memory_human:\n"
1286  "  redis-cli --eval myscript.lua key1 key2 , arg1 arg2 arg3\n"
1287  "  redis-cli --scan --pattern '*:12345*'\n"
1288  "\n"
1289  "  (Note: when using --eval the comma separates KEYS[] from ARGV[] items)\n"
1290  "\n"
1291  "When no command is given, redis-cli starts in interactive mode.\n"
1292  "Type \"help\" in interactive mode for information on available commands\n"
1293  "and settings.\n"
1294  "\n");
1295      sdsfree(version);
1296      exit(1);
1297  }
1298  static int confirmWithYes(char *msg) {
1299      if (config.cluster_manager_command.flags & CLUSTER_MANAGER_CMD_FLAG_YES) {
1300          return 1;
1301      }
1302      printf("%s (type 'yes' to accept): ", msg);
1303      fflush(stdout);
1304      char buf[4];
1305      int nread = read(fileno(stdin),buf,4);
1306      buf[3] = '\0';
1307      return (nread != 0 && !strcmp("yes", buf));
1308  }
1309  static char **convertToSds(int count, char** args) {
1310    int j;
1311    char **sds = zmalloc(sizeof(char*)*count);
1312    for(j = 0; j < count; j++)
1313      sds[j] = sdsnew(args[j]);
1314    return sds;
1315  }
1316  static int issueCommandRepeat(int argc, char **argv, PORT_LONG repeat) {
1317      while (1) {
1318          config.cluster_reissue_command = 0;
1319          if (cliSendCommand(argc,argv,(int)repeat) != REDIS_OK) { WIN_PORT_FIX &bsol;* cast (int) */
1320              cliConnect(CC_FORCE);
1321              if (cliSendCommand(argc,argv,(int)repeat) != REDIS_OK) { WIN_PORT_FIX &bsol;* cast (int) */
1322                  cliPrintContextError();
1323                  return REDIS_ERR;
1324              }
1325           }
1326           if (config.cluster_mode && config.cluster_reissue_command) {
1327              cliConnect(CC_FORCE);
1328           } else {
1329               break;
1330          }
1331      }
1332      return REDIS_OK;
1333  }
1334  static int issueCommand(int argc, char **argv) {
1335      return issueCommandRepeat(argc, argv, config.repeat);
1336  }
1337  static sds *cliSplitArgs(char *line, int *argc) {
1338      if (config.eval_ldb && (strstr(line,"eval ") == line ||
1339                              strstr(line,"e ") == line))
1340      {
1341          sds *argv = sds_malloc(sizeof(sds)*2);
1342          *argc = 2;
1343          int len = (int) strlen(line);                                            WIN_PORT_FIX &bsol;* cast int */
1344          int elen = line[1] == ' ' ? 2 : 5; &bsol;* "e " or "eval "? */
1345          argv[0] = sdsnewlen(line,elen-1);
1346          argv[1] = sdsnewlen(line+elen,len-elen);
1347          return argv;
1348      } else {
1349          return sdssplitargs(line,argc);
1350      }
1351  }
1352  void cliSetPreferences(char **argv, int argc, int interactive) {
1353      if (!strcasecmp(argv[0],":set") && argc >= 2) {
1354          if (!strcasecmp(argv[1],"hints")) pref.hints = 1;
1355          else if (!strcasecmp(argv[1],"nohints")) pref.hints = 0;
1356          else {
1357              printf("%sunknown redis-cli preference '%s'\n",
1358                  interactive ? "" : ".redisclirc: ",
1359                  argv[1]);
1360          }
1361      } else {
1362          printf("%sunknown redis-cli internal command '%s'\n",
1363              interactive ? "" : ".redisclirc: ",
1364              argv[0]);
1365      }
1366  }
1367  void cliLoadPreferences(void) {
1368      sds rcfile = getDotfilePath(REDIS_CLI_RCFILE_ENV,REDIS_CLI_RCFILE_DEFAULT);
1369      if (rcfile == NULL) return;
1370      FILE *fp = fopen(rcfile,"r");
1371      char buf[1024];
1372      if (fp) {
1373          while(fgets(buf,sizeof(buf),fp) != NULL) {
1374              sds *argv;
1375              int argc;
1376              argv = sdssplitargs(buf,&argc);
1377              if (argc > 0) cliSetPreferences(argv,argc,0);
1378              sdsfreesplitres(argv,argc);
1379          }
1380          fclose(fp);
1381      }
1382      sdsfree(rcfile);
1383  }
1384  static void repl(void) {
1385      sds historyfile = NULL;
1386      int history = 0;
1387      char *line;
1388      int argc;
1389      sds *argv;
1390      cliInitHelp();
1391      cliIntegrateHelp();
1392      config.interactive = 1;
1393      linenoiseSetMultiLine(1);
1394      linenoiseSetCompletionCallback(completionCallback);
1395      linenoiseSetHintsCallback(hintsCallback);
1396      linenoiseSetFreeHintsCallback(freeHintsCallback);
1397      if (isatty(fileno(stdin))) {
1398          historyfile = getDotfilePath(REDIS_CLI_HISTFILE_ENV,REDIS_CLI_HISTFILE_DEFAULT);
1399          history = 1;
1400          if (historyfile != NULL) {
1401              linenoiseHistoryLoad(historyfile);
1402          }
1403          cliLoadPreferences();
1404      }
1405      cliRefreshPrompt();
1406      while((line = linenoise(context ? config.prompt : "not connected> ")) != NULL) {
1407          if (line[0] != '\0') {
1408              PORT_LONG repeat = 1;
1409              int skipargs = 0;
1410              char *endptr = NULL;
1411              argv = cliSplitArgs(line,&argc);
1412              if (argv && argc > 0) {
1413                  errno = 0;
1414                  repeat = strtol(argv[0], &endptr, 10);
1415                  if (argc > 1 && *endptr == '\0') {
1416                      if (errno == ERANGE || errno == EINVAL || repeat <= 0) {
1417                          fputs("Invalid redis-cli repeat command option value.\n", stdout);
1418                          sdsfreesplitres(argv, argc);
1419                          linenoiseFree(line);
1420                          continue;
1421                      }
1422                      skipargs = 1;
1423                  } else {
1424                      repeat = 1;
1425                  }
1426              }
1427              if (!(argv && argc > 0 && !strcasecmp(argv[0+skipargs], "auth"))) {
1428                  if (history) linenoiseHistoryAdd(line);
1429                  if (historyfile) linenoiseHistorySave(historyfile);
1430              }
1431              if (argv == NULL) {
1432                  printf("Invalid argument(s)\n");
1433                  linenoiseFree(line);
1434                  continue;
1435              } else if (argc > 0) {
1436                  if (strcasecmp(argv[0],"quit") == 0 ||
1437                      strcasecmp(argv[0],"exit") == 0)
1438                  {
1439                      exit(0);
1440                  } else if (argv[0][0] == ':') {
1441                      cliSetPreferences(argv,argc,1);
1442                      sdsfreesplitres(argv,argc);
1443                      linenoiseFree(line);
1444                      continue;
1445                  } else if (strcasecmp(argv[0],"restart") == 0) {
1446                      if (config.eval) {
1447                          config.eval_ldb = 1;
1448                          config.output = OUTPUT_RAW;
1449                          return; &bsol;* Return to evalMode to restart the session. */
1450                      } else {
1451                          printf("Use 'restart' only in Lua debugging mode.");
1452                      }
1453                  } else if (argc == 3 && !strcasecmp(argv[0],"connect")) {
1454                      sdsfree(config.hostip);
1455                      config.hostip = sdsnew(argv[1]);
1456                      config.hostport = atoi(argv[2]);
1457                      cliRefreshPrompt();
1458                      cliConnect(CC_FORCE);
1459                  } else if (argc == 1 && !strcasecmp(argv[0],"clear")) {
1460                      linenoiseClearScreen();
1461                  } else {
1462                      PORT_LONGLONG start_time = mstime(), elapsed;
1463                      issueCommandRepeat(argc-skipargs, argv+skipargs, repeat);
1464                      if (config.eval_ldb_end) {
1465                          config.eval_ldb_end = 0;
1466                          cliReadReply(0);
1467                          printf("\n(Lua debugging session ended%s)\n\n",
1468                              config.eval_ldb_sync ? "" :
1469                              " -- dataset changes rolled back");
1470                      }
1471                      elapsed = mstime()-start_time;
1472                      if (elapsed >= 500 &&
1473                          config.output == OUTPUT_STANDARD)
1474                      {
1475                          printf("(%.2fs)\n",(double)elapsed/1000);
1476                      }
1477                  }
1478              }
1479              sdsfreesplitres(argv,argc);
1480          }
1481          linenoiseFree(line);
1482      }
1483      exit(0);
1484  }
1485  static int noninteractive(int argc, char **argv) {
1486      int retval = 0;
1487      if (config.stdinarg) {
1488          argv = zrealloc(argv, (argc+1)*sizeof(char*));
1489          argv[argc] = readArgFromStdin();
1490          retval = issueCommand(argc+1, argv);
1491      } else {
1492          retval = issueCommand(argc, argv);
1493      }
1494      return retval;
1495  }
1496  static int evalMode(int argc, char **argv) {
1497      sds script = NULL;
1498      FILE *fp;
1499      char buf[1024];
1500      size_t nread;
1501      char **argv2;
1502      int j, got_comma, keys;
1503      int retval = REDIS_OK;
1504      while(1) {
1505          if (config.eval_ldb) {
1506              printf(
1507              "Lua debugging session started, please use:\n"
1508              "quit    -- End the session.\n"
1509              "restart -- Restart the script in debug mode again.\n"
1510              "help    -- Show Lua script debugging commands.\n\n"
1511              );
1512          }
1513          sdsfree(script);
1514          script = sdsempty();
1515          got_comma = 0;
1516          keys = 0;
1517          fp = fopen(config.eval,"r");
1518          if (!fp) {
1519              fprintf(stderr,
1520                  "Can't open file '%s': %s\n", config.eval, strerror(errno));
1521              exit(1);
1522          }
1523          while((nread = fread(buf,1,sizeof(buf),fp)) != 0) {
1524              script = sdscatlen(script,buf,nread);
1525          }
1526          fclose(fp);
1527          if (config.eval_ldb) {
1528              redisReply *reply = redisCommand(context,
1529                      config.eval_ldb_sync ?
1530                      "SCRIPT DEBUG sync": "SCRIPT DEBUG yes");
1531              if (reply) freeReplyObject(reply);
1532          }
1533          argv2 = zmalloc(sizeof(sds)*(argc+3));
1534          argv2[0] = sdsnew("EVAL");
1535          argv2[1] = script;
1536          for (j = 0; j < argc; j++) {
1537              if (!got_comma && argv[j][0] == ',' && argv[j][1] == 0) {
1538                  got_comma = 1;
1539                  continue;
1540              }
1541              argv2[j+3-got_comma] = sdsnew(argv[j]);
1542              if (!got_comma) keys++;
1543          }
1544          argv2[2] = sdscatprintf(sdsempty(),"%d",keys);
1545          int eval_ldb = config.eval_ldb; &bsol;* Save it, may be reverteed. */
1546          retval = issueCommand(argc+3-got_comma, argv2);
1547          if (eval_ldb) {
1548              if (!config.eval_ldb) {
1549                  printf("Eval debugging session can't start:\n");
1550                  cliReadReply(0);
1551                  break; &bsol;* Return to the caller. */
1552              } else {
1553                  strncpy(config.prompt,"lua debugger> ",sizeof(config.prompt));
1554                  repl();
1555                  cliConnect(CC_FORCE);
1556                  printf("\n");
1557              }
1558          } else {
1559              break; &bsol;* Return to the caller. */
1560          }
1561      }
1562      return retval;
1563  }
1564  static struct clusterManager {
1565      list *nodes;    &bsol;* List of nodes in the configuration. */
1566      list *errors;
1567  } cluster_manager;
1568  dict *clusterManagerUncoveredSlots = NULL;
1569  typedef struct clusterManagerNode {
1570      redisContext *context;
1571      sds name;
1572      char *ip;
1573      int port;
1574      uint64_t current_epoch;
1575      time_t ping_sent;
1576      time_t ping_recv;
1577      int flags;
1578      list *flags_str; &bsol;* Flags string representations */
1579      sds replicate;  &bsol;* Master ID if node is a slave */
1580      int dirty;      &bsol;* Node has changes that can be flushed */
1581      uint8_t slots[CLUSTER_MANAGER_SLOTS];
1582      int slots_count;
1583      int replicas_count;
1584      list *friends;
1585      sds *migrating; &bsol;* An array of sds where even strings are slots and odd
1586                       * strings are the destination node IDs. */
1587      sds *importing; &bsol;* An array of sds where even strings are slots and odd
1588                       * strings are the source node IDs. */
1589      int migrating_count; &bsol;* Length of the migrating array (migrating slots*2) */
1590      int importing_count; &bsol;* Length of the importing array (importing slots*2) */
1591      float weight;   &bsol;* Weight used by rebalance */
1592      int balance;    &bsol;* Used by rebalance */
1593  } clusterManagerNode;
1594  typedef struct clusterManagerNodeArray {
1595      clusterManagerNode **nodes; &bsol;* Actual nodes array */
1596      clusterManagerNode **alloc; &bsol;* Pointer to the allocated memory */
1597      int len;                    &bsol;* Actual length of the array */
1598      int count;                  &bsol;* Non-NULL nodes count */
1599  } clusterManagerNodeArray;
1600  typedef struct clusterManagerReshardTableItem {
1601      clusterManagerNode *source;
1602      int slot;
1603  } clusterManagerReshardTableItem;
1604  static dictType clusterManagerDictType = {
1605      dictSdsHash,               &bsol;* hash function */
1606      NULL,                      &bsol;* key dup */
1607      NULL,                      &bsol;* val dup */
1608      dictSdsKeyCompare,         &bsol;* key compare */
1609      NULL,                      &bsol;* key destructor */
1610      dictSdsDestructor          &bsol;* val destructor */
1611  };
1612  typedef int clusterManagerCommandProc(int argc, char **argv);
1613  typedef int (*clusterManagerOnReplyError)(redisReply *reply, int bulk_idx);
1614  static clusterManagerNode *clusterManagerNewNode(char *ip, int port);
1615  static clusterManagerNode *clusterManagerNodeByName(const char *name);
1616  static clusterManagerNode *clusterManagerNodeByAbbreviatedName(const char *n);
1617  static void clusterManagerNodeResetSlots(clusterManagerNode *node);
1618  static int clusterManagerNodeIsCluster(clusterManagerNode *node, char **err);
1619  static void clusterManagerPrintNotClusterNodeError(clusterManagerNode *node,
1620                                                     char *err);
1621  static int clusterManagerNodeLoadInfo(clusterManagerNode *node, int opts,
1622                                        char **err);
1623  static int clusterManagerLoadInfoFromNode(clusterManagerNode *node, int opts);
1624  static int clusterManagerNodeIsEmpty(clusterManagerNode *node, char **err);
1625  static int clusterManagerGetAntiAffinityScore(clusterManagerNodeArray *ipnodes,
1626      int ip_count, clusterManagerNode ***offending, int *offending_len);
1627  static void clusterManagerOptimizeAntiAffinity(clusterManagerNodeArray *ipnodes,
1628      int ip_count);
1629  static sds clusterManagerNodeInfo(clusterManagerNode *node, int indent);
1630  static void clusterManagerShowNodes(void);
1631  static void clusterManagerShowClusterInfo(void);
1632  static int clusterManagerFlushNodeConfig(clusterManagerNode *node, char **err);
1633  static void clusterManagerWaitForClusterJoin(void);
1634  static int clusterManagerCheckCluster(int quiet);
1635  static void clusterManagerLog(int level, const char* fmt, ...);
1636  static int clusterManagerIsConfigConsistent(void);
1637  static void clusterManagerOnError(sds err);
1638  static void clusterManagerNodeArrayInit(clusterManagerNodeArray *array,
1639                                          int len);
1640  static void clusterManagerNodeArrayReset(clusterManagerNodeArray *array);
1641  static void clusterManagerNodeArrayShift(clusterManagerNodeArray *array,
1642                                           clusterManagerNode **nodeptr);
1643  static void clusterManagerNodeArrayAdd(clusterManagerNodeArray *array,
1644                                         clusterManagerNode *node);
1645  static int clusterManagerCommandCreate(int argc, char **argv);
1646  static int clusterManagerCommandAddNode(int argc, char **argv);
1647  static int clusterManagerCommandDeleteNode(int argc, char **argv);
1648  static int clusterManagerCommandInfo(int argc, char **argv);
1649  static int clusterManagerCommandCheck(int argc, char **argv);
1650  static int clusterManagerCommandFix(int argc, char **argv);
1651  static int clusterManagerCommandReshard(int argc, char **argv);
1652  static int clusterManagerCommandRebalance(int argc, char **argv);
1653  static int clusterManagerCommandSetTimeout(int argc, char **argv);
1654  static int clusterManagerCommandImport(int argc, char **argv);
1655  static int clusterManagerCommandCall(int argc, char **argv);
1656  static int clusterManagerCommandHelp(int argc, char **argv);
1657  typedef struct clusterManagerCommandDef {
1658      char *name;
1659      clusterManagerCommandProc *proc;
1660      int arity;
1661      char *args;
1662      char *options;
1663  } clusterManagerCommandDef;
1664  clusterManagerCommandDef clusterManagerCommands[] = {
1665      {"create", clusterManagerCommandCreate, -2, "host1:port1 ... hostN:portN",
1666       "replicas <arg>"},
1667      {"check", clusterManagerCommandCheck, -1, "host:port",
1668       "search-multiple-owners"},
1669      {"info", clusterManagerCommandInfo, -1, "host:port", NULL},
1670      {"fix", clusterManagerCommandFix, -1, "host:port",
1671       "search-multiple-owners"},
1672      {"reshard", clusterManagerCommandReshard, -1, "host:port",
1673       "from <arg>,to <arg>,slots <arg>,yes,timeout <arg>,pipeline <arg>,"
1674       "replace"},
1675      {"rebalance", clusterManagerCommandRebalance, -1, "host:port",
1676       "weight <node1=w1...nodeN=wN>,use-empty-masters,"
1677       "timeout <arg>,simulate,pipeline <arg>,threshold <arg>,replace"},
1678      {"add-node", clusterManagerCommandAddNode, 2,
1679       "new_host:new_port existing_host:existing_port", "slave,master-id <arg>"},
1680      {"del-node", clusterManagerCommandDeleteNode, 2, "host:port node_id",NULL},
1681      {"call", clusterManagerCommandCall, -2,
1682          "host:port command arg arg .. arg", NULL},
1683      {"set-timeout", clusterManagerCommandSetTimeout, 2,
1684       "host:port milliseconds", NULL},
1685      {"import", clusterManagerCommandImport, 1, "host:port",
1686       "from <arg>,copy,replace"},
1687      {"help", clusterManagerCommandHelp, 0, NULL, NULL}
1688  };
1689  static void createClusterManagerCommand(char *cmdname, int argc, char **argv) {
1690      clusterManagerCommand *cmd = &config.cluster_manager_command;
1691      cmd->name = cmdname;
1692      cmd->argc = argc;
1693      cmd->argv = argc ? argv : NULL;
1694      if (isColorTerm()) cmd->flags |= CLUSTER_MANAGER_CMD_FLAG_COLOR;
1695  }
1696  static clusterManagerCommandProc *validateClusterManagerCommand(void) {
1697      int i, commands_count = sizeof(clusterManagerCommands) /
1698                              sizeof(clusterManagerCommandDef);
1699      clusterManagerCommandProc *proc = NULL;
1700      char *cmdname = config.cluster_manager_command.name;
1701      int argc = config.cluster_manager_command.argc;
1702      for (i = 0; i < commands_count; i++) {
1703          clusterManagerCommandDef cmddef = clusterManagerCommands[i];
1704          if (!strcmp(cmddef.name, cmdname)) {
1705              if ((cmddef.arity > 0 && argc != cmddef.arity) ||
1706                  (cmddef.arity < 0 && argc < (cmddef.arity * -1))) {
1707                  fprintf(stderr, "[ERR] Wrong number of arguments for "
1708                                  "specified --cluster sub command\n");
1709                  return NULL;
1710              }
1711              proc = cmddef.proc;
1712          }
1713      }
1714      if (!proc) fprintf(stderr, "Unknown --cluster subcommand\n");
1715      return proc;
1716  }
1717  static int getClusterHostFromCmdArgs(int argc, char **argv,
1718                                       char **ip_ptr, int *port_ptr) {
1719      int port = 0;
1720      char *ip = NULL;
1721      if (argc == 1) {
1722          char *addr = argv[0];
1723          char *c = strrchr(addr, '@');
1724          if (c != NULL) *c = '\0';
1725          c = strrchr(addr, ':');
1726          if (c != NULL) {
1727              *c = '\0';
1728              ip = addr;
1729              port = atoi(++c);
1730          } else return 0;
1731      } else {
1732          ip = argv[0];
1733          port = atoi(argv[1]);
1734      }
1735      if (!ip || !port) return 0;
1736      else {
1737          *ip_ptr = ip;
1738          *port_ptr = port;
1739      }
1740      return 1;
1741  }
1742  static void freeClusterManagerNodeFlags(list *flags) {
1743      listIter li;
1744      listNode *ln;
1745      listRewind(flags, &li);
1746      while ((ln = listNext(&li)) != NULL) {
1747          sds flag = ln->value;
1748          sdsfree(flag);
1749      }
1750      listRelease(flags);
1751  }
1752  static void freeClusterManagerNode(clusterManagerNode *node) {
1753      if (node->context != NULL) redisFree(node->context);
1754      if (node->friends != NULL) {
1755          listIter li;
1756          listNode *ln;
1757          listRewind(node->friends,&li);
1758          while ((ln = listNext(&li)) != NULL) {
1759              clusterManagerNode *fn = ln->value;
1760              freeClusterManagerNode(fn);
1761          }
1762          listRelease(node->friends);
1763          node->friends = NULL;
1764      }
1765      if (node->name != NULL) sdsfree(node->name);
1766      if (node->replicate != NULL) sdsfree(node->replicate);
1767      if ((node->flags & CLUSTER_MANAGER_FLAG_FRIEND) && node->ip)
1768          sdsfree(node->ip);
1769      int i;
1770      if (node->migrating != NULL) {
1771          for (i = 0; i < node->migrating_count; i++) sdsfree(node->migrating[i]);
1772          zfree(node->migrating);
1773      }
1774      if (node->importing != NULL) {
1775          for (i = 0; i < node->importing_count; i++) sdsfree(node->importing[i]);
1776          zfree(node->importing);
1777      }
1778      if (node->flags_str != NULL) {
1779          freeClusterManagerNodeFlags(node->flags_str);
1780          node->flags_str = NULL;
1781      }
1782      zfree(node);
1783  }
1784  static void freeClusterManager(void) {
<span onclick='openModal()' class='match'>1785      listIter li;
1786      listNode *ln;
1787      if (cluster_manager.nodes != NULL) {
1788          listRewind(cluster_manager.nodes,&li);
1789          while ((ln = listNext(&li)) != NULL) {
</span>1790              clusterManagerNode *n = ln->value;
1791              freeClusterManagerNode(n);
1792          }
1793          listRelease(cluster_manager.nodes);
1794          cluster_manager.nodes = NULL;
1795      }
1796      if (cluster_manager.errors != NULL) {
1797          listRewind(cluster_manager.errors,&li);
1798          while ((ln = listNext(&li)) != NULL) {
1799              sds err = ln->value;
1800              sdsfree(err);
1801          }
1802          listRelease(cluster_manager.errors);
1803          cluster_manager.errors = NULL;
1804      }
1805      if (clusterManagerUncoveredSlots != NULL)
1806          dictRelease(clusterManagerUncoveredSlots);
1807  }
1808  static clusterManagerNode *clusterManagerNewNode(char *ip, int port) {
1809      clusterManagerNode *node = zmalloc(sizeof(*node));
1810      node->context = NULL;
1811      node->name = NULL;
1812      node->ip = ip;
1813      node->port = port;
1814      node->current_epoch = 0;
1815      node->ping_sent = 0;
1816      node->ping_recv = 0;
1817      node->flags = 0;
1818      node->flags_str = NULL;
1819      node->replicate = NULL;
1820      node->dirty = 0;
1821      node->friends = NULL;
1822      node->migrating = NULL;
1823      node->importing = NULL;
1824      node->migrating_count = 0;
1825      node->importing_count = 0;
1826      node->replicas_count = 0;
1827      node->weight = 1.0f;
1828      node->balance = 0;
1829      clusterManagerNodeResetSlots(node);
1830      return node;
1831  }
1832  static int clusterManagerCheckRedisReply(clusterManagerNode *n,
1833                                           redisReply *r, char **err)
1834  {
1835      int is_err = 0;
1836      if (!r || (is_err = (r->type == REDIS_REPLY_ERROR))) {
1837          if (is_err) {
1838              if (err != NULL) {
1839                  *err = zmalloc((r->len + 1) * sizeof(char));
1840                  strcpy(*err, r->str);
1841              } else CLUSTER_MANAGER_PRINT_REPLY_ERROR(n, r->str);
1842          }
1843          return 0;
1844      }
1845      return 1;
1846  }
1847  static int clusterManagerStartTransaction(clusterManagerNode *node) {
1848      redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "MULTI");
1849      int success = clusterManagerCheckRedisReply(node, reply, NULL);
1850      if (reply) freeReplyObject(reply);
1851      return success;
1852  }
1853  static int clusterManagerExecTransaction(clusterManagerNode *node,
1854                                           clusterManagerOnReplyError onerror)
1855  {
1856      redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "EXEC");
1857      int success = clusterManagerCheckRedisReply(node, reply, NULL);
1858      if (success) {
1859          if (reply->type != REDIS_REPLY_ARRAY) {
1860              success = 0;
1861              goto cleanup;
1862          }
1863          size_t i;
1864          for (i = 0; i < reply->elements; i++) {
1865              redisReply *r = reply->element[i];
1866              char *err = NULL;
1867              success = clusterManagerCheckRedisReply(node, r, &err);
1868              if (!success && onerror) success = onerror(r, i);
1869              if (err) {
1870                  if (!success)
1871                      CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
1872                  zfree(err);
1873              }
1874              if (!success) break;
1875          }
1876      }
1877  cleanup:
1878      if (reply) freeReplyObject(reply);
1879      return success;
1880  }
1881  static int clusterManagerNodeConnect(clusterManagerNode *node) {
1882      if (node->context) redisFree(node->context);
1883      node->context = redisConnect(node->ip, node->port);
1884      if (node->context->err) {
1885          fprintf(stderr,"Could not connect to Redis at ");
1886          fprintf(stderr,"%s:%d: %s\n", node->ip, node->port,
1887                  node->context->errstr);
1888          redisFree(node->context);
1889          node->context = NULL;
1890          return 0;
1891      }
1892      anetKeepAlive(NULL, node->context->fd, REDIS_CLI_KEEPALIVE_INTERVAL);
1893      if (config.auth) {
1894          redisReply *reply = redisCommand(node->context,"AUTH %s",config.auth);
1895          int ok = clusterManagerCheckRedisReply(node, reply, NULL);
1896          if (reply != NULL) freeReplyObject(reply);
1897          if (!ok) return 0;
1898      }
1899      return 1;
1900  }
1901  static void clusterManagerRemoveNodeFromList(list *nodelist,
1902                                               clusterManagerNode *node) {
1903      listIter li;
1904      listNode *ln;
1905      listRewind(nodelist, &li);
1906      while ((ln = listNext(&li)) != NULL) {
1907          if (node == ln->value) {
1908              listDelNode(nodelist, ln);
1909              break;
1910          }
1911      }
1912  }
1913  static clusterManagerNode *clusterManagerNodeByName(const char *name) {
1914      if (cluster_manager.nodes == NULL) return NULL;
1915      clusterManagerNode *found = NULL;
1916      sds lcname = sdsempty();
1917      lcname = sdscpy(lcname, name);
1918      sdstolower(lcname);
1919      listIter li;
1920      listNode *ln;
1921      listRewind(cluster_manager.nodes, &li);
1922      while ((ln = listNext(&li)) != NULL) {
1923          clusterManagerNode *n = ln->value;
1924          if (n->name && !sdscmp(n->name, lcname)) {
1925              found = n;
1926              break;
1927          }
1928      }
1929      sdsfree(lcname);
1930      return found;
1931  }
1932  static clusterManagerNode *clusterManagerNodeByAbbreviatedName(const char*name)
1933  {
1934      if (cluster_manager.nodes == NULL) return NULL;
1935      clusterManagerNode *found = NULL;
1936      sds lcname = sdsempty();
1937      lcname = sdscpy(lcname, name);
1938      sdstolower(lcname);
1939      listIter li;
1940      listNode *ln;
1941      listRewind(cluster_manager.nodes, &li);
1942      while ((ln = listNext(&li)) != NULL) {
1943          clusterManagerNode *n = ln->value;
1944          if (n->name &&
1945              strstr(n->name, lcname) == n->name) {
1946              found = n;
1947              break;
1948          }
1949      }
1950      sdsfree(lcname);
1951      return found;
1952  }
1953  static void clusterManagerNodeResetSlots(clusterManagerNode *node) {
1954      memset(node->slots, 0, sizeof(node->slots));
1955      node->slots_count = 0;
1956  }
1957  static redisReply *clusterManagerGetNodeRedisInfo(clusterManagerNode *node,
1958                                                    char **err)
1959  {
1960      redisReply *info = CLUSTER_MANAGER_COMMAND(node, "INFO");
1961      if (err != NULL) *err = NULL;
1962      if (info == NULL) return NULL;
1963      if (info->type == REDIS_REPLY_ERROR) {
1964          if (err != NULL) {
1965              *err = zmalloc((info->len + 1) * sizeof(char));
1966              strcpy(*err, info->str);
1967          }
1968          freeReplyObject(info);
1969          return  NULL;
1970      }
1971      return info;
1972  }
1973  static int clusterManagerNodeIsCluster(clusterManagerNode *node, char **err) {
1974      redisReply *info = clusterManagerGetNodeRedisInfo(node, err);
1975      if (info == NULL) return 0;
1976      int is_cluster = (int) getLongInfoField(info->str, "cluster_enabled");
1977      freeReplyObject(info);
1978      return is_cluster;
1979  }
1980  static int clusterManagerNodeIsEmpty(clusterManagerNode *node, char **err) {
1981      redisReply *info = clusterManagerGetNodeRedisInfo(node, err);
1982      int is_empty = 1;
1983      if (info == NULL) return 0;
1984      if (strstr(info->str, "db0:") != NULL) {
1985          is_empty = 0;
1986          goto result;
1987      }
1988      freeReplyObject(info);
1989      info = CLUSTER_MANAGER_COMMAND(node, "CLUSTER INFO");
1990      if (err != NULL) *err = NULL;
1991      if (!clusterManagerCheckRedisReply(node, info, err)) {
1992          is_empty = 0;
1993          goto result;
1994      }
1995      PORT_LONG known_nodes = getLongInfoField(info->str, "cluster_known_nodes");
1996      is_empty = (known_nodes == 1);
1997  result:
1998      freeReplyObject(info);
1999      return is_empty;
2000  }
2001  static int clusterManagerGetAntiAffinityScore(clusterManagerNodeArray *ipnodes,
2002      int ip_count, clusterManagerNode ***offending, int *offending_len)
2003  {
2004      int score = 0, i, j;
2005      int node_len = cluster_manager.nodes->len;
2006      clusterManagerNode **offending_p = NULL;
2007      if (offending != NULL) {
2008          *offending = zcalloc(node_len * sizeof(clusterManagerNode*));
2009          offending_p = *offending;
2010      }
2011      for (i = 0; i < ip_count; i++) {
2012          clusterManagerNodeArray *node_array = &(ipnodes[i]);
2013          dict *related = dictCreate(&clusterManagerDictType, NULL);
2014          char *ip = NULL;
2015          for (j = 0; j < node_array->len; j++) {
2016              clusterManagerNode *node = node_array->nodes[j];
2017              if (node == NULL) continue;
2018              if (!ip) ip = node->ip;
2019              sds types;
2020              sds key = (!node->replicate ? node->name : node->replicate);
2021              assert(key != NULL);
2022              dictEntry *entry = dictFind(related, key);
2023              if (entry) types = sdsdup((sds) dictGetVal(entry));
2024              else types = sdsempty();
2025              if (!node->replicate) types = sdscatprintf(types, "m%s", types);
2026              else types = sdscat(types, "s");
2027              dictReplace(related, key, types);
2028          }
2029          dictIterator *iter = dictGetIterator(related);
2030          dictEntry *entry;
2031          while ((entry = dictNext(iter)) != NULL) {
2032              sds types = (sds) dictGetVal(entry);
2033              sds name = (sds) dictGetKey(entry);
2034              int typeslen = sdslen(types);
2035              if (typeslen < 2) continue;
2036              if (types[0] == 'm') score += (10000 * (typeslen - 1));
2037              else score += (1 * typeslen);
2038              if (offending == NULL) continue;
2039              listIter li;
2040              listNode *ln;
2041              listRewind(cluster_manager.nodes, &li);
2042              while ((ln = listNext(&li)) != NULL) {
2043                  clusterManagerNode *n = ln->value;
2044                  if (n->replicate == NULL) continue;
2045                  if (!strcmp(n->replicate, name) && !strcmp(n->ip, ip)) {
2046                      *(offending_p++) = n;
2047                      if (offending_len != NULL) (*offending_len)++;
2048                      break;
2049                  }
2050              }
2051          }
2052          dictReleaseIterator(iter);
2053          dictRelease(related);
2054      }
2055      return score;
2056  }
2057  static void clusterManagerOptimizeAntiAffinity(clusterManagerNodeArray *ipnodes,
2058      int ip_count)
2059  {
2060      clusterManagerNode **offenders = NULL;
2061      int score = clusterManagerGetAntiAffinityScore(ipnodes, ip_count,
2062                                                     NULL, NULL);
2063      if (score == 0) goto cleanup;
2064      clusterManagerLogInfo(">>> Trying to optimize slaves allocation "
2065                            "for anti-affinity\n");
2066      int node_len = cluster_manager.nodes->len;
2067      int maxiter = 500 * node_len; 
2068      srand(time(NULL));
2069      while (maxiter > 0) {
2070          int offending_len = 0;
2071          if (offenders != NULL) {
2072              zfree(offenders);
2073              offenders = NULL;
2074          }
2075          score = clusterManagerGetAntiAffinityScore(ipnodes,
2076                                                     ip_count,
2077                                                     &offenders,
2078                                                     &offending_len);
2079          if (score == 0) break; 
2080          int rand_idx = rand() % offending_len;
2081          clusterManagerNode *first = offenders[rand_idx],
2082                             *second = NULL;
2083          clusterManagerNode **other_replicas = zcalloc((node_len - 1) *
2084                                                        sizeof(*other_replicas));
2085          int other_replicas_count = 0;
2086          listIter li;
2087          listNode *ln;
2088          listRewind(cluster_manager.nodes, &li);
2089          while ((ln = listNext(&li)) != NULL) {
2090              clusterManagerNode *n = ln->value;
2091              if (n != first && n->replicate != NULL)
2092                  other_replicas[other_replicas_count++] = n;
2093          }
2094          if (other_replicas_count == 0) {
2095              zfree(other_replicas);
2096              break;
2097          }
2098          rand_idx = rand() % other_replicas_count;
2099          second = other_replicas[rand_idx];
2100          char *first_master = first->replicate,
2101               *second_master = second->replicate;
2102          first->replicate = second_master, first->dirty = 1;
2103          second->replicate = first_master, second->dirty = 1;
2104          int new_score = clusterManagerGetAntiAffinityScore(ipnodes,
2105                                                             ip_count,
2106                                                             NULL, NULL);
2107          if (new_score > score) {
2108              first->replicate = first_master;
2109              second->replicate = second_master;
2110          }
2111          zfree(other_replicas);
2112          maxiter--;
2113      }
2114      score = clusterManagerGetAntiAffinityScore(ipnodes, ip_count, NULL, NULL);
2115      char *msg;
2116      int perfect = (score == 0);
2117      int log_level = (perfect ? CLUSTER_MANAGER_LOG_LVL_SUCCESS :
2118                                 CLUSTER_MANAGER_LOG_LVL_WARN);
2119      if (perfect) msg = "[OK] Perfect anti-affinity obtained!";
2120      else if (score >= 10000)
2121          msg = ("[WARNING] Some slaves are in the same host as their master");
2122      else
2123          msg=("[WARNING] Some slaves of the same master are in the same host");
2124      clusterManagerLog(log_level, "%s\n", msg);
2125  cleanup:
2126      zfree(offenders);
2127  }
2128  static sds clusterManagerNodeFlagString(clusterManagerNode *node) {
2129      sds flags = sdsempty();
2130      if (!node->flags_str) return flags;
2131      int empty = 1;
2132      listIter li;
2133      listNode *ln;
2134      listRewind(node->flags_str, &li);
2135      while ((ln = listNext(&li)) != NULL) {
2136          sds flag = ln->value;
2137          if (strcmp(flag, "myself") == 0) continue;
2138          if (!empty) flags = sdscat(flags, ",");
2139          flags = sdscatfmt(flags, "%S", flag);
2140          empty = 0;
2141      }
2142      return flags;
2143  }
2144  static sds clusterManagerNodeSlotsString(clusterManagerNode *node) {
2145      sds slots = sdsempty();
2146      int first_range_idx = -1, last_slot_idx = -1, i;
2147      for (i = 0; i < CLUSTER_MANAGER_SLOTS; i++) {
2148          int has_slot = node->slots[i];
2149          if (has_slot) {
2150              if (first_range_idx == -1) {
2151                  if (sdslen(slots)) slots = sdscat(slots, ",");
2152                  first_range_idx = i;
2153                  slots = sdscatfmt(slots, "[%u", i);
2154              }
2155              last_slot_idx = i;
2156          } else {
2157              if (last_slot_idx >= 0) {
2158                  if (first_range_idx == last_slot_idx)
2159                      slots = sdscat(slots, "]");
2160                  else slots = sdscatfmt(slots, "-%u]", last_slot_idx);
2161              }
2162              last_slot_idx = -1;
2163              first_range_idx = -1;
2164          }
2165      }
2166      if (last_slot_idx >= 0) {
2167          if (first_range_idx == last_slot_idx) slots = sdscat(slots, "]");
2168          else slots = sdscatfmt(slots, "-%u]", last_slot_idx);
2169      }
2170      return slots;
2171  }
2172  static unsigned int clusterManagerKeyHashSlot(char *key, int keylen) {
2173      int s, e; &bsol;* start-end indexes of { and } */
2174      for (s = 0; s < keylen; s++)
2175          if (key[s] == '{') break;
2176      if (s == keylen) return crc16(key,keylen) & 0x3FFF;
2177      for (e = s+1; e < keylen; e++)
2178          if (key[e] == '}') break;
2179      if (e == keylen || e == s+1) return crc16(key,keylen) & 0x3FFF;
2180      return crc16(key+s+1,e-s-1) & 0x3FFF;
2181  }
2182  static sds clusterManagerNodeInfo(clusterManagerNode *node, int indent) {
2183      sds info = sdsempty();
2184      sds spaces = sdsempty();
2185      int i;
2186      for (i = 0; i < indent; i++) spaces = sdscat(spaces, " ");
2187      if (indent) info = sdscat(info, spaces);
2188      int is_master = !(node->flags & CLUSTER_MANAGER_FLAG_SLAVE);
2189      char *role = (is_master ? "M" : "S");
2190      sds slots = NULL;
2191      if (node->dirty && node->replicate != NULL)
2192          info = sdscatfmt(info, "S: %S %s:%u", node->name, node->ip, node->port);
2193      else {
2194          slots = clusterManagerNodeSlotsString(node);
2195          sds flags = clusterManagerNodeFlagString(node);
2196          info = sdscatfmt(info, "%s: %S %s:%u\n"
2197                                 "%s   slots:%S (%u slots) "
2198                                 "%S",
2199                                 role, node->name, node->ip, node->port, spaces,
2200                                 slots, node->slots_count, flags);
2201          sdsfree(slots);
2202          sdsfree(flags);
2203      }
2204      if (node->replicate != NULL)
2205          info = sdscatfmt(info, "\n%s   replicates %S", spaces, node->replicate);
2206      else if (node->replicas_count)
2207          info = sdscatfmt(info, "\n%s   %U additional replica(s)",
2208                           spaces, node->replicas_count);
2209      sdsfree(spaces);
2210      return info;
2211  }
2212  static void clusterManagerShowNodes(void) {
2213      listIter li;
2214      listNode *ln;
2215      listRewind(cluster_manager.nodes, &li);
2216      while ((ln = listNext(&li)) != NULL) {
2217          clusterManagerNode *node = ln->value;
2218          sds info = clusterManagerNodeInfo(node, 0);
2219          printf("%s\n", (char *) info);
2220          sdsfree(info);
2221      }
2222  }
2223  static void clusterManagerShowClusterInfo(void) {
2224      int masters = 0;
2225      int keys = 0;
2226      listIter li;
2227      listNode *ln;
2228      listRewind(cluster_manager.nodes, &li);
2229      while ((ln = listNext(&li)) != NULL) {
2230          clusterManagerNode *node = ln->value;
2231          if (!(node->flags & CLUSTER_MANAGER_FLAG_SLAVE)) {
2232              if (!node->name) continue;
2233              int replicas = 0;
2234              int dbsize = -1;
2235              char name[9];
2236              memcpy(name, node->name, 8);
2237              name[8] = '\0';
2238              listIter ri;
2239              listNode *rn;
2240              listRewind(cluster_manager.nodes, &ri);
2241              while ((rn = listNext(&ri)) != NULL) {
2242                  clusterManagerNode *n = rn->value;
2243                  if (n == node || !(n->flags & CLUSTER_MANAGER_FLAG_SLAVE))
2244                      continue;
2245                  if (n->replicate && !strcmp(n->replicate, node->name))
2246                      replicas++;
2247              }
2248              redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "DBSIZE");
2249              if (reply != NULL || reply->type == REDIS_REPLY_INTEGER)
2250                  dbsize = reply->integer;
2251              if (dbsize < 0) {
2252                  char *err = "";
2253                  if (reply != NULL && reply->type == REDIS_REPLY_ERROR)
2254                      err = reply->str;
2255                  CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
2256                  if (reply != NULL) freeReplyObject(reply);
2257                  return;
2258              };
2259              if (reply != NULL) freeReplyObject(reply);
2260              printf("%s:%d (%s...) -> %d keys | %d slots | %d slaves.\n",
2261                     node->ip, node->port, name, dbsize,
2262                     node->slots_count, replicas);
2263              masters++;
2264              keys += dbsize;
2265          }
2266      }
2267      clusterManagerLogOk("[OK] %d keys in %d masters.\n", keys, masters);
2268      float keys_per_slot = keys / (float) CLUSTER_MANAGER_SLOTS;
2269      printf("%.2f keys per slot on average.\n", keys_per_slot);
2270  }
2271  static int clusterManagerAddSlots(clusterManagerNode *node, char**err)
2272  {
2273      redisReply *reply = NULL;
2274      void *_reply = NULL;
2275      int success = 1;
2276      int argc = node->slots_count + 2;
2277      sds *argv = zmalloc(argc * sizeof(*argv));
2278      size_t *argvlen = zmalloc(argc * sizeof(*argvlen));
2279      argv[0] = "CLUSTER";
2280      argv[1] = "ADDSLOTS";
2281      argvlen[0] = 7;
2282      argvlen[1] = 8;
2283      *err = NULL;
2284      int i, argv_idx = 2;
2285      for (i = 0; i < CLUSTER_MANAGER_SLOTS; i++) {
2286          if (argv_idx >= argc) break;
2287          if (node->slots[i]) {
2288              argv[argv_idx] = sdsfromlonglong((PORT_LONGLONG) i);
2289              argvlen[argv_idx] = sdslen(argv[argv_idx]);
2290              argv_idx++;
2291          }
2292      }
2293      if (!argv_idx) {
2294          success = 0;
2295          goto cleanup;
2296      }
2297      redisAppendCommandArgv(node->context,argc,(const char**)argv,argvlen);
2298      if (redisGetReply(node->context, &_reply) != REDIS_OK) {
2299          success = 0;
2300          goto cleanup;
2301      }
2302      reply = (redisReply*) _reply;
2303      success = clusterManagerCheckRedisReply(node, reply, err);
2304  cleanup:
2305      zfree(argvlen);
2306      if (argv != NULL) {
2307          for (i = 2; i < argc; i++) sdsfree(argv[i]);
2308          zfree(argv);
2309      }
2310      if (reply != NULL) freeReplyObject(reply);
2311      return success;
2312  }
2313  static int clusterManagerSetSlot(clusterManagerNode *node1,
2314                                   clusterManagerNode *node2,
2315                                   int slot, const char *status, char **err) {
2316      redisReply *reply = CLUSTER_MANAGER_COMMAND(node1, "CLUSTER "
2317                                                  "SETSLOT %d %s %s",
2318                                                  slot, status,
2319                                                  (char *) node2->name);
2320      if (err != NULL) *err = NULL;
2321      if (!reply) return 0;
2322      int success = 1;
2323      if (reply->type == REDIS_REPLY_ERROR) {
2324          success = 0;
2325          if (err != NULL) {
2326              *err = zmalloc((reply->len + 1) * sizeof(char));
2327              strcpy(*err, reply->str);
2328          } else CLUSTER_MANAGER_PRINT_REPLY_ERROR(node1, reply->str);
2329          goto cleanup;
2330      }
2331  cleanup:
2332      freeReplyObject(reply);
2333      return success;
2334  }
2335  static int clusterManagerClearSlotStatus(clusterManagerNode *node, int slot) {
2336      redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
2337          "CLUSTER SETSLOT %d %s", slot, "STABLE");
2338      int success = clusterManagerCheckRedisReply(node, reply, NULL);
2339      if (reply) freeReplyObject(reply);
2340      return success;
2341  }
2342  static int clusterManagerDelSlot(clusterManagerNode *node, int slot,
2343                                   int ignore_unassigned_err)
2344  {
2345      redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
2346          "CLUSTER DELSLOTS %d", slot);
2347      char *err = NULL;
2348      int success = clusterManagerCheckRedisReply(node, reply, &err);
2349      if (!success && reply && reply->type == REDIS_REPLY_ERROR &&
2350          ignore_unassigned_err &&
2351          strstr(reply->str, "already unassigned") != NULL) success = 1;
2352      if (!success && err != NULL) {
2353          CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
2354          zfree(err);
2355      }
2356      if (reply) freeReplyObject(reply);
2357      return success;
2358  }
2359  static int clusterManagerAddSlot(clusterManagerNode *node, int slot) {
2360      redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
2361          "CLUSTER ADDSLOTS %d", slot);
2362      int success = clusterManagerCheckRedisReply(node, reply, NULL);
2363      if (reply) freeReplyObject(reply);
2364      return success;
2365  }
2366  static signed int clusterManagerCountKeysInSlot(clusterManagerNode *node,
2367                                                  int slot)
2368  {
2369      redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
2370          "CLUSTER COUNTKEYSINSLOT %d", slot);
2371      int count = -1;
2372      int success = clusterManagerCheckRedisReply(node, reply, NULL);
2373      if (success && reply->type == REDIS_REPLY_INTEGER) count = reply->integer;
2374      if (reply) freeReplyObject(reply);
2375      return count;
2376  }
2377  static int clusterManagerBumpEpoch(clusterManagerNode *node) {
2378      redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "CLUSTER BUMPEPOCH");
2379      int success = clusterManagerCheckRedisReply(node, reply, NULL);
2380      if (reply) freeReplyObject(reply);
2381      return success;
2382  }
2383  static int clusterManagerIgnoreUnassignedErr(redisReply *reply, int bulk_idx) {
2384      if (bulk_idx == 0 && reply) {
2385          if (reply->type == REDIS_REPLY_ERROR)
2386              return strstr(reply->str, "already unassigned") != NULL;
2387      }
2388      return 0;
2389  }
2390  static int clusterManagerSetSlotOwner(clusterManagerNode *owner,
2391                                        int slot,
2392                                        int do_clear)
2393  {
2394      int success = clusterManagerStartTransaction(owner);
2395      if (!success) return 0;
2396      clusterManagerDelSlot(owner, slot, 1);
2397      clusterManagerAddSlot(owner, slot);
2398      if (do_clear) clusterManagerClearSlotStatus(owner, slot);
2399      clusterManagerBumpEpoch(owner);
2400      success = clusterManagerExecTransaction(owner,
2401          clusterManagerIgnoreUnassignedErr);
2402      return success;
2403  }
2404  static redisReply *clusterManagerMigrateKeysInReply(clusterManagerNode *source,
2405                                                      clusterManagerNode *target,
2406                                                      redisReply *reply,
2407                                                      int replace, int timeout,
2408                                                      char *dots)
2409  {
2410      redisReply *migrate_reply = NULL;
2411      char **argv = NULL;
2412      size_t *argv_len = NULL;
2413      int c = (replace ? 8 : 7);
2414      if (config.auth) c += 2;
2415      size_t argc = c + reply->elements;
2416      size_t i, offset = 6; 
2417      argv = zcalloc(argc * sizeof(char *));
2418      argv_len = zcalloc(argc * sizeof(size_t));
2419      char portstr[255];
2420      char timeoutstr[255];
2421      snprintf(portstr, 10, "%d", target->port);
2422      snprintf(timeoutstr, 10, "%d", timeout);
2423      argv[0] = "MIGRATE";
2424      argv_len[0] = 7;
2425      argv[1] = target->ip;
2426      argv_len[1] = strlen(target->ip);
2427      argv[2] = portstr;
2428      argv_len[2] = strlen(portstr);
2429      argv[3] = "";
2430      argv_len[3] = 0;
2431      argv[4] = "0";
2432      argv_len[4] = 1;
2433      argv[5] = timeoutstr;
2434      argv_len[5] = strlen(timeoutstr);
2435      if (replace) {
2436          argv[offset] = "REPLACE";
2437          argv_len[offset] = 7;
2438          offset++;
2439      }
2440      if (config.auth) {
2441          argv[offset] = "AUTH";
2442          argv_len[offset] = 4;
2443          offset++;
2444          argv[offset] = config.auth;
2445          argv_len[offset] = strlen(config.auth);
2446          offset++;
2447      }
2448      argv[offset] = "KEYS";
2449      argv_len[offset] = 4;
2450      offset++;
2451      for (i = 0; i < reply->elements; i++) {
2452          redisReply *entry = reply->element[i];
2453          size_t idx = i + offset;
2454          assert(entry->type == REDIS_REPLY_STRING);
2455          argv[idx] = (char *) sdsnew(entry->str);
2456          argv_len[idx] = entry->len;
2457          if (dots) dots[i] = '.';
2458      }
2459      if (dots) dots[reply->elements] = '\0';
2460      void *_reply = NULL;
2461      redisAppendCommandArgv(source->context,argc,
2462                             (const char**)argv,argv_len);
2463      int success = (redisGetReply(source->context, &_reply) == REDIS_OK);
2464      for (i = 0; i < reply->elements; i++) sdsfree(argv[i + offset]);
2465      if (!success) goto cleanup;
2466      migrate_reply = (redisReply *) _reply;
2467  cleanup:
2468      zfree(argv);
2469      zfree(argv_len);
2470      return migrate_reply;
2471  }
2472  static int clusterManagerMigrateKeysInSlot(clusterManagerNode *source,
2473                                             clusterManagerNode *target,
2474                                             int slot, int timeout,
2475                                             int pipeline, int verbose,
2476                                             char **err)
2477  {
2478      int success = 1;
2479      int replace_existing_keys = (config.cluster_manager_command.flags &
2480              (CLUSTER_MANAGER_CMD_FLAG_FIX | CLUSTER_MANAGER_CMD_FLAG_REPLACE));
2481      while (1) {
2482          char *dots = NULL;
2483          redisReply *reply = NULL, *migrate_reply = NULL;
2484          reply = CLUSTER_MANAGER_COMMAND(source, "CLUSTER "
2485                                          "GETKEYSINSLOT %d %d", slot,
2486                                          pipeline);
2487          success = (reply != NULL);
2488          if (!success) return 0;
2489          if (reply->type == REDIS_REPLY_ERROR) {
2490              success = 0;
2491              if (err != NULL) {
2492                  *err = zmalloc((reply->len + 1) * sizeof(char));
2493                  strcpy(*err, reply->str);
2494                  CLUSTER_MANAGER_PRINT_REPLY_ERROR(source, *err);
2495              }
2496              goto next;
2497          }
2498          assert(reply->type == REDIS_REPLY_ARRAY);
2499          size_t count = reply->elements;
2500          if (count == 0) {
2501              freeReplyObject(reply);
2502              break;
2503          }
2504          if (verbose) dots = zmalloc((count+1) * sizeof(char));
2505          migrate_reply = clusterManagerMigrateKeysInReply(source, target,
2506                                                           reply, 0, timeout,
2507                                                           dots);
2508          if (migrate_reply == NULL) goto next;
2509          if (migrate_reply->type == REDIS_REPLY_ERROR) {
2510              int is_busy = strstr(migrate_reply->str, "BUSYKEY") != NULL;
2511              int not_served = strstr(migrate_reply->str, "slot not served") != NULL;
2512              if (replace_existing_keys && (is_busy || not_served)) {
2513                  if (not_served)
2514                      clusterManagerSetSlot(source, target, slot, "node", NULL);
2515                  clusterManagerLogWarn("*** Target key exists. "
2516                                        "Replacing it for FIX.\n");
2517                  freeReplyObject(migrate_reply);
2518                  migrate_reply = clusterManagerMigrateKeysInReply(source,
2519                                                                   target,
2520                                                                   reply,
2521                                                                   is_busy,
2522                                                                   timeout,
2523                                                                   NULL);
2524                  success = (migrate_reply != NULL &&
2525                             migrate_reply->type != REDIS_REPLY_ERROR);
2526              } else success = 0;
2527              if (!success) {
2528                  if (migrate_reply != NULL) {
2529                      if (err) {
2530                          *err = zmalloc((migrate_reply->len + 1) * sizeof(char));
2531                          strcpy(*err, migrate_reply->str);
2532                      }
2533                      printf("\n");
2534                      CLUSTER_MANAGER_PRINT_REPLY_ERROR(source,
2535                                                        migrate_reply->str);
2536                  }
2537                  goto next;
2538              }
2539          }
2540          if (verbose) {
2541              printf("%s", dots);
2542              fflush(stdout);
2543          }
2544  next:
2545          if (reply != NULL) freeReplyObject(reply);
2546          if (migrate_reply != NULL) freeReplyObject(migrate_reply);
2547          if (dots) zfree(dots);
2548          if (!success) break;
2549      }
2550      return success;
2551  }
2552  static int clusterManagerMoveSlot(clusterManagerNode *source,
2553                                    clusterManagerNode *target,
2554                                    int slot, int opts,  char**err)
2555  {
2556      if (!(opts & CLUSTER_MANAGER_OPT_QUIET)) {
2557          printf("Moving slot %d from %s:%d to %s:%d: ", slot, source->ip,
2558                 source->port, target->ip, target->port);
2559          fflush(stdout);
2560      }
2561      if (err != NULL) *err = NULL;
2562      int pipeline = config.cluster_manager_command.pipeline,
2563          timeout = config.cluster_manager_command.timeout,
2564          print_dots = (opts & CLUSTER_MANAGER_OPT_VERBOSE),
2565          option_cold = (opts & CLUSTER_MANAGER_OPT_COLD),
2566          success = 1;
2567      if (!option_cold) {
2568          success = clusterManagerSetSlot(target, source, slot,
2569                                          "importing", err);
2570          if (!success) return 0;
2571          success = clusterManagerSetSlot(source, target, slot,
2572                                          "migrating", err);
2573          if (!success) return 0;
2574      }
2575      success = clusterManagerMigrateKeysInSlot(source, target, slot, timeout,
2576                                                pipeline, print_dots, err);
2577      if (!(opts & CLUSTER_MANAGER_OPT_QUIET)) printf("\n");
2578      if (!success) return 0;
2579      if (!option_cold) {
2580          listIter li;
2581          listNode *ln;
2582          listRewind(cluster_manager.nodes, &li);
2583          while ((ln = listNext(&li)) != NULL) {
2584              clusterManagerNode *n = ln->value;
2585              if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
2586              redisReply *r = CLUSTER_MANAGER_COMMAND(n, "CLUSTER "
2587                                                      "SETSLOT %d %s %s",
2588                                                      slot, "node",
2589                                                      target->name);
2590              success = (r != NULL);
2591              if (!success) return 0;
2592              if (r->type == REDIS_REPLY_ERROR) {
2593                  success = 0;
2594                  if (err != NULL) {
2595                      *err = zmalloc((r->len + 1) * sizeof(char));
2596                      strcpy(*err, r->str);
2597                      CLUSTER_MANAGER_PRINT_REPLY_ERROR(n, *err);
2598                  }
2599              }
2600              freeReplyObject(r);
2601              if (!success) return 0;
2602          }
2603      }
2604      if (opts & CLUSTER_MANAGER_OPT_UPDATE) {
2605          source->slots[slot] = 0;
2606          target->slots[slot] = 1;
2607      }
2608      return 1;
2609  }
2610  static int clusterManagerFlushNodeConfig(clusterManagerNode *node, char **err) {
2611      if (!node->dirty) return 0;
2612      redisReply *reply = NULL;
2613      int is_err = 0, success = 1;
2614      if (err != NULL) *err = NULL;
2615      if (node->replicate != NULL) {
2616          reply = CLUSTER_MANAGER_COMMAND(node, "CLUSTER REPLICATE %s",
2617                                          node->replicate);
2618          if (reply == NULL || (is_err = (reply->type == REDIS_REPLY_ERROR))) {
2619              if (is_err && err != NULL) {
2620                  *err = zmalloc((reply->len + 1) * sizeof(char));
2621                  strcpy(*err, reply->str);
2622              }
2623              success = 0;
2624              goto cleanup;
2625          }
2626      } else {
2627          int added = clusterManagerAddSlots(node, err);
2628          if (!added || *err != NULL) success = 0;
2629      }
2630      node->dirty = 0;
2631  cleanup:
2632      if (reply != NULL) freeReplyObject(reply);
2633      return success;
2634  }
2635  static void clusterManagerWaitForClusterJoin(void) {
2636      printf("Waiting for the cluster to join\n");
2637      while(!clusterManagerIsConfigConsistent()) {
2638          printf(".");
2639          fflush(stdout);
2640          sleep(1);
2641      }
2642      printf("\n");
2643  }
2644  static int clusterManagerNodeLoadInfo(clusterManagerNode *node, int opts,
2645                                        char **err)
2646  {
2647      redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "CLUSTER NODES");
2648      int success = 1;
2649      *err = NULL;
2650      if (!clusterManagerCheckRedisReply(node, reply, err)) {
2651          success = 0;
2652          goto cleanup;
2653      }
2654      int getfriends = (opts & CLUSTER_MANAGER_OPT_GETFRIENDS);
2655      char *lines = reply->str, *p, *line;
2656      while ((p = strstr(lines, "\n")) != NULL) {
2657          *p = '\0';
2658          line = lines;
2659          lines = p + 1;
2660          char *name = NULL, *addr = NULL, *flags = NULL, *master_id = NULL,
2661               *ping_sent = NULL, *ping_recv = NULL, *config_epoch = NULL,
2662               *link_status = NULL;
2663          UNUSED(link_status);
2664          int i = 0;
2665          while ((p = strchr(line, ' ')) != NULL) {
2666              *p = '\0';
2667              char *token = line;
2668              line = p + 1;
2669              switch(i++){
2670              case 0: name = token; break;
2671              case 1: addr = token; break;
2672              case 2: flags = token; break;
2673              case 3: master_id = token; break;
2674              case 4: ping_sent = token; break;
2675              case 5: ping_recv = token; break;
2676              case 6: config_epoch = token; break;
2677              case 7: link_status = token; break;
2678              }
2679              if (i == 8) break; 
2680          }
2681          if (!flags) {
2682              success = 0;
2683              goto cleanup;
2684          }
2685          int myself = (strstr(flags, "myself") != NULL);
2686          clusterManagerNode *currentNode = NULL;
2687          if (myself) {
2688              node->flags |= CLUSTER_MANAGER_FLAG_MYSELF;
2689              currentNode = node;
2690              clusterManagerNodeResetSlots(node);
2691              if (i == 8) {
2692                  int remaining = strlen(line);
2693                  while (remaining > 0) {
2694                      p = strchr(line, ' ');
2695                      if (p == NULL) p = line + remaining;
2696                      remaining -= (p - line);
2697                      char *slotsdef = line;
2698                      *p = '\0';
2699                      if (remaining) {
2700                          line = p + 1;
2701                          remaining--;
2702                      } else line = p;
2703                      char *dash = NULL;
2704                      if (slotsdef[0] == '[') {
2705                          slotsdef++;
2706                          if ((p = strstr(slotsdef, "->-"))) { 
2707                              *p = '\0';
2708                              p += 3;
2709                              char *closing_bracket = strchr(p, ']');
2710                              if (closing_bracket) *closing_bracket = '\0';
2711                              sds slot = sdsnew(slotsdef);
2712                              sds dst = sdsnew(p);
2713                              node->migrating_count += 2;
2714                              node->migrating = zrealloc(node->migrating,
2715                                  (node->migrating_count * sizeof(sds)));
2716                              node->migrating[node->migrating_count - 2] =
2717                                  slot;
2718                              node->migrating[node->migrating_count - 1] =
2719                                  dst;
2720                          }  else if ((p = strstr(slotsdef, "-<-"))) {
2721                              *p = '\0';
2722                              p += 3;
2723                              char *closing_bracket = strchr(p, ']');
2724                              if (closing_bracket) *closing_bracket = '\0';
2725                              sds slot = sdsnew(slotsdef);
2726                              sds src = sdsnew(p);
2727                              node->importing_count += 2;
2728                              node->importing = zrealloc(node->importing,
2729                                  (node->importing_count * sizeof(sds)));
2730                              node->importing[node->importing_count - 2] =
2731                                  slot;
2732                              node->importing[node->importing_count - 1] =
2733                                  src;
2734                          }
2735                      } else if ((dash = strchr(slotsdef, '-')) != NULL) {
2736                          p = dash;
2737                          int start, stop;
2738                          *p = '\0';
2739                          start = atoi(slotsdef);
2740                          stop = atoi(p + 1);
2741                          node->slots_count += (stop - (start - 1));
2742                          while (start <= stop) node->slots[start++] = 1;
2743                      } else if (p > slotsdef) {
2744                          node->slots[atoi(slotsdef)] = 1;
2745                          node->slots_count++;
2746                      }
2747                  }
2748              }
2749              node->dirty = 0;
2750          } else if (!getfriends) {
2751              if (!(node->flags & CLUSTER_MANAGER_FLAG_MYSELF)) continue;
2752              else break;
2753          } else {
2754              if (addr == NULL) {
2755                  fprintf(stderr, "Error: invalid CLUSTER NODES reply\n");
2756                  success = 0;
2757                  goto cleanup;
2758              }
2759              char *c = strrchr(addr, '@');
2760              if (c != NULL) *c = '\0';
2761              c = strrchr(addr, ':');
2762              if (c == NULL) {
2763                  fprintf(stderr, "Error: invalid CLUSTER NODES reply\n");
2764                  success = 0;
2765                  goto cleanup;
2766              }
2767              *c = '\0';
2768              int port = atoi(++c);
2769              currentNode = clusterManagerNewNode(sdsnew(addr), port);
2770              currentNode->flags |= CLUSTER_MANAGER_FLAG_FRIEND;
2771              if (node->friends == NULL) node->friends = listCreate();
2772              listAddNodeTail(node->friends, currentNode);
2773          }
2774          if (name != NULL) {
2775              if (currentNode->name) sdsfree(currentNode->name);
2776              currentNode->name = sdsnew(name);
2777          }
2778          if (currentNode->flags_str != NULL)
2779              freeClusterManagerNodeFlags(currentNode->flags_str);
2780          currentNode->flags_str = listCreate();
2781          int flag_len;
2782          while ((flag_len = strlen(flags)) > 0) {
2783              sds flag = NULL;
2784              char *fp = strchr(flags, ',');
2785              if (fp) {
2786                  *fp = '\0';
2787                  flag = sdsnew(flags);
2788                  flags = fp + 1;
2789              } else {
2790                  flag = sdsnew(flags);
2791                  flags += flag_len;
2792              }
2793              if (strcmp(flag, "noaddr") == 0)
2794                  currentNode->flags |= CLUSTER_MANAGER_FLAG_NOADDR;
2795              else if (strcmp(flag, "disconnected") == 0)
2796                  currentNode->flags |= CLUSTER_MANAGER_FLAG_DISCONNECT;
2797              else if (strcmp(flag, "fail") == 0)
2798                  currentNode->flags |= CLUSTER_MANAGER_FLAG_FAIL;
2799              else if (strcmp(flag, "slave") == 0) {
2800                  currentNode->flags |= CLUSTER_MANAGER_FLAG_SLAVE;
2801                  if (master_id != NULL) {
2802                      if (currentNode->replicate) sdsfree(currentNode->replicate);
2803                      currentNode->replicate = sdsnew(master_id);
2804                  }
2805              }
2806              listAddNodeTail(currentNode->flags_str, flag);
2807          }
2808          if (config_epoch != NULL)
2809              currentNode->current_epoch = atoll(config_epoch);
2810          if (ping_sent != NULL) currentNode->ping_sent = atoll(ping_sent);
2811          if (ping_recv != NULL) currentNode->ping_recv = atoll(ping_recv);
2812          if (!getfriends && myself) break;
2813      }
2814  cleanup:
2815      if (reply) freeReplyObject(reply);
2816      return success;
2817  }
2818  static int clusterManagerLoadInfoFromNode(clusterManagerNode *node, int opts) {
2819      if (node->context == NULL && !clusterManagerNodeConnect(node)) {
2820          freeClusterManagerNode(node);
2821          return 0;
2822      }
2823      opts |= CLUSTER_MANAGER_OPT_GETFRIENDS;
2824      char *e = NULL;
2825      if (!clusterManagerNodeIsCluster(node, &e)) {
2826          clusterManagerPrintNotClusterNodeError(node, e);
2827          if (e) zfree(e);
2828          freeClusterManagerNode(node);
2829          return 0;
2830      }
2831      e = NULL;
2832      if (!clusterManagerNodeLoadInfo(node, opts, &e)) {
2833          if (e) {
2834              CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, e);
2835              zfree(e);
2836          }
2837          freeClusterManagerNode(node);
2838          return 0;
2839      }
2840      listIter li;
2841      listNode *ln;
2842      if (cluster_manager.nodes != NULL) {
2843          listRewind(cluster_manager.nodes, &li);
2844          while ((ln = listNext(&li)) != NULL)
2845              freeClusterManagerNode((clusterManagerNode *) ln->value);
2846          listRelease(cluster_manager.nodes);
2847      }
2848      cluster_manager.nodes = listCreate();
2849      listAddNodeTail(cluster_manager.nodes, node);
2850      if (node->friends != NULL) {
2851          listRewind(node->friends, &li);
2852          while ((ln = listNext(&li)) != NULL) {
2853              clusterManagerNode *friend = ln->value;
2854              if (!friend->ip || !friend->port) goto invalid_friend;
2855              if (!friend->context && !clusterManagerNodeConnect(friend))
2856                  goto invalid_friend;
2857              e = NULL;
2858              if (clusterManagerNodeLoadInfo(friend, 0, &e)) {
2859                  if (friend->flags & (CLUSTER_MANAGER_FLAG_NOADDR |
2860                                       CLUSTER_MANAGER_FLAG_DISCONNECT |
2861                                       CLUSTER_MANAGER_FLAG_FAIL))
2862                      goto invalid_friend;
2863                  listAddNodeTail(cluster_manager.nodes, friend);
2864              } else {
2865                  clusterManagerLogErr("[ERR] Unable to load info for "
2866                                       "node %s:%d\n",
2867                                       friend->ip, friend->port);
2868                  goto invalid_friend;
2869              }
2870              continue;
2871  invalid_friend:
2872              freeClusterManagerNode(friend);
2873          }
2874          listRelease(node->friends);
2875          node->friends = NULL;
2876      }
2877      listRewind(cluster_manager.nodes, &li);
2878      while ((ln = listNext(&li)) != NULL) {
2879          clusterManagerNode *n = ln->value;
2880          if (n->replicate != NULL) {
2881              clusterManagerNode *master = clusterManagerNodeByName(n->replicate);
2882              if (master == NULL) {
2883                  clusterManagerLogWarn("*** WARNING: %s:%d claims to be "
2884                                        "slave of unknown node ID %s.\n",
2885                                        n->ip, n->port, n->replicate);
2886              } else master->replicas_count++;
2887          }
2888      }
2889      return 1;
2890  }
2891  int clusterManagerSlotCompare(const void *slot1, const void *slot2) {
2892      const char **i1 = (const char **)slot1;
2893      const char **i2 = (const char **)slot2;
2894      return strcmp(*i1, *i2);
2895  }
2896  int clusterManagerSlotCountCompareDesc(const void *n1, const void *n2) {
2897      clusterManagerNode *node1 = *((clusterManagerNode **) n1);
2898      clusterManagerNode *node2 = *((clusterManagerNode **) n2);
2899      return node2->slots_count - node1->slots_count;
2900  }
2901  int clusterManagerCompareNodeBalance(const void *n1, const void *n2) {
2902      clusterManagerNode *node1 = *((clusterManagerNode **) n1);
2903      clusterManagerNode *node2 = *((clusterManagerNode **) n2);
2904      return node1->balance - node2->balance;
2905  }
2906  static sds clusterManagerGetConfigSignature(clusterManagerNode *node) {
2907      sds signature = NULL;
2908      int node_count = 0, i = 0, name_len = 0;
2909      char **node_configs = NULL;
2910      redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "CLUSTER NODES");
2911      if (reply == NULL || reply->type == REDIS_REPLY_ERROR)
2912          goto cleanup;
2913      char *lines = reply->str, *p, *line;
2914      while ((p = strstr(lines, "\n")) != NULL) {
2915          i = 0;
2916          *p = '\0';
2917          line = lines;
2918          lines = p + 1;
2919          char *nodename = NULL;
2920          int tot_size = 0;
2921          while ((p = strchr(line, ' ')) != NULL) {
2922              *p = '\0';
2923              char *token = line;
2924              line = p + 1;
2925              if (i == 0) {
2926                  nodename = token;
2927                  tot_size = (p - token);
2928                  name_len = tot_size++; 
2929              }
2930              if (++i == 8) break;
2931          }
2932          if (i != 8) continue;
2933          if (nodename == NULL) continue;
2934          int remaining = strlen(line);
2935          if (remaining == 0) continue;
2936          char **slots = NULL;
2937          int c = 0;
2938          while (remaining > 0) {
2939              p = strchr(line, ' ');
2940              if (p == NULL) p = line + remaining;
2941              int size = (p - line);
2942              remaining -= size;
2943              tot_size += size;
2944              char *slotsdef = line;
2945              *p = '\0';
2946              if (remaining) {
2947                  line = p + 1;
2948                  remaining--;
2949              } else line = p;
2950              if (slotsdef[0] != '[') {
2951                  c++;
2952                  slots = zrealloc(slots, (c * sizeof(char *)));
2953                  slots[c - 1] = slotsdef;
2954              }
2955          }
2956          if (c > 0) {
2957              if (c > 1)
2958                  qsort(slots, c, sizeof(char *), clusterManagerSlotCompare);
2959              node_count++;
2960              node_configs =
2961                  zrealloc(node_configs, (node_count * sizeof(char *)));
2962              tot_size += (sizeof(char) * (c - 1));
2963              char *cfg = zmalloc((sizeof(char) * tot_size) + 1);
2964              memcpy(cfg, nodename, name_len);
2965              char *sp = cfg + name_len;
2966              *(sp++) = ':';
2967              for (i = 0; i < c; i++) {
2968                  if (i > 0) *(sp++) = ',';
2969                  int slen = strlen(slots[i]);
2970                  memcpy(sp, slots[i], slen);
2971                  sp += slen;
2972              }
2973              *(sp++) = '\0';
2974              node_configs[node_count - 1] = cfg;
2975          }
2976          zfree(slots);
2977      }
2978      if (node_count > 0) {
2979          if (node_count > 1) {
2980              qsort(node_configs, node_count, sizeof(char *),
2981                    clusterManagerSlotCompare);
2982          }
2983          signature = sdsempty();
2984          for (i = 0; i < node_count; i++) {
2985              if (i > 0) signature = sdscatprintf(signature, "%c", '|');
2986              signature = sdscatfmt(signature, "%s", node_configs[i]);
2987          }
2988      }
2989  cleanup:
2990      if (reply != NULL) freeReplyObject(reply);
2991      if (node_configs != NULL) {
2992          for (i = 0; i < node_count; i++) zfree(node_configs[i]);
2993          zfree(node_configs);
2994      }
2995      return signature;
2996  }
2997  static int clusterManagerIsConfigConsistent(void) {
2998      if (cluster_manager.nodes == NULL) return 0;
2999      int consistent = (listLength(cluster_manager.nodes) <= 1);
3000      if (consistent) return 1;
3001      sds first_cfg = NULL;
3002      listIter li;
3003      listNode *ln;
3004      listRewind(cluster_manager.nodes, &li);
3005      while ((ln = listNext(&li)) != NULL) {
3006          clusterManagerNode *node = ln->value;
3007          sds cfg = clusterManagerGetConfigSignature(node);
3008          if (cfg == NULL) {
3009              consistent = 0;
3010              break;
3011          }
3012          if (first_cfg == NULL) first_cfg = cfg;
3013          else {
3014              consistent = !sdscmp(first_cfg, cfg);
3015              sdsfree(cfg);
3016              if (!consistent) break;
3017          }
3018      }
3019      if (first_cfg != NULL) sdsfree(first_cfg);
3020      return consistent;
3021  }
3022  static void clusterManagerOnError(sds err) {
3023      if (cluster_manager.errors == NULL)
3024          cluster_manager.errors = listCreate();
3025      listAddNodeTail(cluster_manager.errors, err);
3026      clusterManagerLogErr("%s\n", (char *) err);
3027  }
3028  static int clusterManagerGetCoveredSlots(char *all_slots) {
3029      if (cluster_manager.nodes == NULL) return 0;
3030      listIter li;
3031      listNode *ln;
3032      listRewind(cluster_manager.nodes, &li);
3033      int totslots = 0, i;
3034      while ((ln = listNext(&li)) != NULL) {
3035          clusterManagerNode *node = ln->value;
3036          for (i = 0; i < CLUSTER_MANAGER_SLOTS; i++) {
3037              if (node->slots[i] && !all_slots[i]) {
3038                  all_slots[i] = 1;
3039                  totslots++;
3040              }
3041          }
3042      }
3043      return totslots;
3044  }
3045  static void clusterManagerPrintSlotsList(list *slots) {
3046      listIter li;
3047      listNode *ln;
3048      listRewind(slots, &li);
3049      sds first = NULL;
3050      while ((ln = listNext(&li)) != NULL) {
3051          sds slot = ln->value;
3052          if (!first) first = slot;
3053          else printf(", ");
3054          printf("%s", slot);
3055      }
3056      printf("\n");
3057  }
3058  static clusterManagerNode * clusterManagerGetNodeWithMostKeysInSlot(list *nodes,
3059                                                                      int slot,
3060                                                                      char **err)
3061  {
3062      clusterManagerNode *node = NULL;
3063      int numkeys = 0;
3064      listIter li;
3065      listNode *ln;
3066      listRewind(nodes, &li);
3067      if (err) *err = NULL;
3068      while ((ln = listNext(&li)) != NULL) {
3069          clusterManagerNode *n = ln->value;
3070          if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE || n->replicate)
3071              continue;
3072          redisReply *r =
3073              CLUSTER_MANAGER_COMMAND(n, "CLUSTER COUNTKEYSINSLOT %d", slot);
3074          int success = clusterManagerCheckRedisReply(n, r, err);
3075          if (success) {
3076              if (r->integer > numkeys || node == NULL) {
3077                  numkeys = r->integer;
3078                  node = n;
3079              }
3080          }
3081          if (r != NULL) freeReplyObject(r);
3082          if (!success) {
3083              if (err != NULL && *err != NULL)
3084                  CLUSTER_MANAGER_PRINT_REPLY_ERROR(n, err);
3085              node = NULL;
3086              break;
3087          }
3088      }
3089      return node;
3090  }
3091  static clusterManagerNode *clusterManagerNodeWithLeastReplicas() {
3092      clusterManagerNode *node = NULL;
3093      int lowest_count = 0;
3094      listIter li;
3095      listNode *ln;
3096      listRewind(cluster_manager.nodes, &li);
3097      while ((ln = listNext(&li)) != NULL) {
3098          clusterManagerNode *n = ln->value;
3099          if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
3100          if (node == NULL || n->replicas_count < lowest_count) {
3101              node = n;
3102              lowest_count = n->replicas_count;
3103          }
3104      }
3105      return node;
3106  }
3107  static clusterManagerNode *clusterManagerNodeMasterRandom() {
3108      int master_count = 0;
3109      int idx;
3110      listIter li;
3111      listNode *ln;
3112      listRewind(cluster_manager.nodes, &li);
3113      while ((ln = listNext(&li)) != NULL) {
3114          clusterManagerNode *n = ln->value;
3115          if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
3116          master_count++;
3117      }
3118      srand(time(NULL));
3119      idx = rand() % master_count;
3120      listRewind(cluster_manager.nodes, &li);
3121      while ((ln = listNext(&li)) != NULL) {
3122          clusterManagerNode *n = ln->value;
3123          if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
3124          if (!idx--) {
3125              return n;
3126          }
3127      }
3128      return NULL;
3129  }
3130  static int clusterManagerFixSlotsCoverage(char *all_slots) {
3131      int i, fixed = 0;
3132      list *none = NULL, *single = NULL, *multi = NULL;
3133      clusterManagerLogInfo(">>> Fixing slots coverage...\n");
3134      printf("List of not covered slots: \n");
3135      int uncovered_count = 0;
3136      sds log = sdsempty();
3137      for (i = 0; i < CLUSTER_MANAGER_SLOTS; i++) {
3138          int covered = all_slots[i];
3139          if (!covered) {
3140              sds key = sdsfromlonglong((PORT_LONGLONG) i);
3141              if (uncovered_count++ > 0) printf(",");
3142              printf("%s", (char *) key);
3143              list *slot_nodes = listCreate();
3144              sds slot_nodes_str = sdsempty();
3145              listIter li;
3146              listNode *ln;
3147              listRewind(cluster_manager.nodes, &li);
3148              while ((ln = listNext(&li)) != NULL) {
3149                  clusterManagerNode *n = ln->value;
3150                  if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE || n->replicate)
3151                      continue;
3152                  redisReply *reply = CLUSTER_MANAGER_COMMAND(n,
3153                      "CLUSTER GETKEYSINSLOT %d %d", i, 1);
3154                  if (!clusterManagerCheckRedisReply(n, reply, NULL)) {
3155                      fixed = -1;
3156                      if (reply) freeReplyObject(reply);
3157                      goto cleanup;
3158                  }
3159                  assert(reply->type == REDIS_REPLY_ARRAY);
3160                  if (reply->elements > 0) {
3161                      listAddNodeTail(slot_nodes, n);
3162                      if (listLength(slot_nodes) > 1)
3163                          slot_nodes_str = sdscat(slot_nodes_str, ", ");
3164                      slot_nodes_str = sdscatfmt(slot_nodes_str,
3165                                                 "%s:%u", n->ip, n->port);
3166                  }
3167                  freeReplyObject(reply);
3168              }
3169              log = sdscatfmt(log, "\nSlot %S has keys in %u nodes: %S",
3170                              key, listLength(slot_nodes), slot_nodes_str);
3171              sdsfree(slot_nodes_str);
3172              dictAdd(clusterManagerUncoveredSlots, key, slot_nodes);
3173          }
3174      }
3175      printf("\n%s\n", log);
3176      none = listCreate();
3177      single = listCreate();
3178      multi = listCreate();
3179      dictIterator *iter = dictGetIterator(clusterManagerUncoveredSlots);
3180      dictEntry *entry;
3181      while ((entry = dictNext(iter)) != NULL) {
3182          sds slot = (sds) dictGetKey(entry);
3183          list *nodes = (list *) dictGetVal(entry);
3184          switch (listLength(nodes)){
3185          case 0: listAddNodeTail(none, slot); break;
3186          case 1: listAddNodeTail(single, slot); break;
3187          default: listAddNodeTail(multi, slot); break;
3188          }
3189      }
3190      dictReleaseIterator(iter);
3191      if (listLength(none) > 0) {
3192          printf("The following uncovered slots have no keys "
3193                 "across the cluster:\n");
3194          clusterManagerPrintSlotsList(none);
3195          if (confirmWithYes("Fix these slots by covering with a random node?")){
3196              listIter li;
3197              listNode *ln;
3198              listRewind(none, &li);
3199              while ((ln = listNext(&li)) != NULL) {
3200                  sds slot = ln->value;
3201                  int s = atoi(slot);
3202                  clusterManagerNode *n = clusterManagerNodeMasterRandom();
3203                  clusterManagerLogInfo(">>> Covering slot %s with %s:%d\n",
3204                                        slot, n->ip, n->port);
3205                  if (!clusterManagerSetSlotOwner(n, s, 0)) {
3206                      fixed = -1;
3207                      goto cleanup;
3208                  }
3209                  n->slots[s] = 1;
3210                  fixed++;
3211              }
3212          }
3213      }
3214      if (listLength(single) > 0) {
3215          printf("The following uncovered slots have keys in just one node:\n");
3216          clusterManagerPrintSlotsList(single);
3217          if (confirmWithYes("Fix these slots by covering with those nodes?")){
3218              listIter li;
3219              listNode *ln;
3220              listRewind(single, &li);
3221              while ((ln = listNext(&li)) != NULL) {
3222                  sds slot = ln->value;
3223                  int s = atoi(slot);
3224                  dictEntry *entry = dictFind(clusterManagerUncoveredSlots, slot);
3225                  assert(entry != NULL);
3226                  list *nodes = (list *) dictGetVal(entry);
3227                  listNode *fn = listFirst(nodes);
3228                  assert(fn != NULL);
3229                  clusterManagerNode *n = fn->value;
3230                  clusterManagerLogInfo(">>> Covering slot %s with %s:%d\n",
3231                                        slot, n->ip, n->port);
3232                  if (!clusterManagerSetSlotOwner(n, s, 0)) {
3233                      fixed = -1;
3234                      goto cleanup;
3235                  }
3236                  n->slots[atoi(slot)] = 1;
3237                  fixed++;
3238              }
3239          }
3240      }
3241      if (listLength(multi) > 0) {
3242          printf("The following uncovered slots have keys in multiple nodes:\n");
3243          clusterManagerPrintSlotsList(multi);
3244          if (confirmWithYes("Fix these slots by moving keys "
3245                             "into a single node?")) {
3246              listIter li;
3247              listNode *ln;
3248              listRewind(multi, &li);
3249              while ((ln = listNext(&li)) != NULL) {
3250                  sds slot = ln->value;
3251                  dictEntry *entry = dictFind(clusterManagerUncoveredSlots, slot);
3252                  assert(entry != NULL);
3253                  list *nodes = (list *) dictGetVal(entry);
3254                  int s = atoi(slot);
3255                  clusterManagerNode *target =
3256                      clusterManagerGetNodeWithMostKeysInSlot(nodes, s, NULL);
3257                  if (target == NULL) {
3258                      fixed = -1;
3259                      goto cleanup;
3260                  }
3261                  clusterManagerLogInfo(">>> Covering slot %s moving keys "
3262                                        "to %s:%d\n", slot,
3263                                        target->ip, target->port);
3264                  if (!clusterManagerSetSlotOwner(target, s, 1)) {
3265                      fixed = -1;
3266                      goto cleanup;
3267                  }
3268                  target->slots[atoi(slot)] = 1;
3269                  listIter nli;
3270                  listNode *nln;
3271                  listRewind(nodes, &nli);
3272                  while ((nln = listNext(&nli)) != NULL) {
3273                      clusterManagerNode *src = nln->value;
3274                      if (src == target) continue;
3275                      if (!clusterManagerSetSlot(src, target, s, "NODE", NULL))
3276                          fixed = -1;
3277                      if (fixed < 0) goto cleanup;
3278                      if (!clusterManagerSetSlot(src, target, s,
3279                                                 "IMPORTING", NULL)) fixed = -1;
3280                      if (fixed < 0) goto cleanup;
3281                      int opts = CLUSTER_MANAGER_OPT_VERBOSE |
3282                                 CLUSTER_MANAGER_OPT_COLD;
3283                      if (!clusterManagerMoveSlot(src, target, s, opts, NULL)) {
3284                          fixed = -1;
3285                          goto cleanup;
3286                      }
3287                      if (!clusterManagerClearSlotStatus(src, s))
3288                          fixed = -1;
3289                      if (fixed < 0) goto cleanup;
3290                  }
3291                  fixed++;
3292              }
3293          }
3294      }
3295  cleanup:
3296      sdsfree(log);
3297      if (none) listRelease(none);
3298      if (single) listRelease(single);
3299      if (multi) listRelease(multi);
3300      return fixed;
3301  }
3302  static int clusterManagerFixOpenSlot(int slot) {
3303      clusterManagerLogInfo(">>> Fixing open slot %d\n", slot);
3304      int success = 1;
3305      list *owners = listCreate();
3306      list *migrating = listCreate();
3307      list *importing = listCreate();
3308      sds migrating_str = sdsempty();
3309      sds importing_str = sdsempty();
3310      clusterManagerNode *owner = NULL;
3311      listIter li;
3312      listNode *ln;
3313      listRewind(cluster_manager.nodes, &li);
3314      while ((ln = listNext(&li)) != NULL) {
3315          clusterManagerNode *n = ln->value;
3316          if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
3317          if (n->slots[slot]) listAddNodeTail(owners, n);
3318          else {
3319              redisReply *r = CLUSTER_MANAGER_COMMAND(n,
3320                  "CLUSTER COUNTKEYSINSLOT %d", slot);
3321              success = clusterManagerCheckRedisReply(n, r, NULL);
3322              if (success && r->integer > 0) {
3323                  clusterManagerLogWarn("*** Found keys about slot %d "
3324                                        "in non-owner node %s:%d!\n", slot,
3325                                        n->ip, n->port);
3326                  listAddNodeTail(owners, n);
3327              }
3328              if (r) freeReplyObject(r);
3329              if (!success) goto cleanup;
3330          }
3331      }
3332      if (listLength(owners) == 1) owner = listFirst(owners)->value;
3333      listRewind(cluster_manager.nodes, &li);
3334      while ((ln = listNext(&li)) != NULL) {
3335          clusterManagerNode *n = ln->value;
3336          if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
3337          int is_migrating = 0, is_importing = 0;
3338          if (n->migrating) {
3339              for (int i = 0; i < n->migrating_count; i += 2) {
3340                  sds migrating_slot = n->migrating[i];
3341                  if (atoi(migrating_slot) == slot) {
3342                      char *sep = (listLength(migrating) == 0 ? "" : ",");
3343                      migrating_str = sdscatfmt(migrating_str, "%s%s:%u",
3344                                                sep, n->ip, n->port);
3345                      listAddNodeTail(migrating, n);
3346                      is_migrating = 1;
3347                      break;
3348                  }
3349              }
3350          }
3351          if (!is_migrating && n->importing) {
3352              for (int i = 0; i < n->importing_count; i += 2) {
3353                  sds importing_slot = n->importing[i];
3354                  if (atoi(importing_slot) == slot) {
3355                      char *sep = (listLength(importing) == 0 ? "" : ",");
3356                      importing_str = sdscatfmt(importing_str, "%s%s:%u",
3357                                                sep, n->ip, n->port);
3358                      listAddNodeTail(importing, n);
3359                      is_importing = 1;
3360                      break;
3361                  }
3362              }
3363          }
3364          if (!is_migrating && !is_importing && n != owner) {
3365              redisReply *r = CLUSTER_MANAGER_COMMAND(n,
3366                  "CLUSTER COUNTKEYSINSLOT %d", slot);
3367              success = clusterManagerCheckRedisReply(n, r, NULL);
3368              if (success && r->integer > 0) {
3369                  clusterManagerLogWarn("*** Found keys about slot %d "
3370                                        "in node %s:%d!\n", slot, n->ip,
3371                                        n->port);
3372                  char *sep = (listLength(importing) == 0 ? "" : ",");
3373                  importing_str = sdscatfmt(importing_str, "%s%S:%u",
3374                                            sep, n->ip, n->port);
3375                  listAddNodeTail(importing, n);
3376              }
3377              if (r) freeReplyObject(r);
3378              if (!success) goto cleanup;
3379          }
3380      }
3381      if (sdslen(migrating_str) > 0)
3382          printf("Set as migrating in: %s\n", migrating_str);
3383      if (sdslen(importing_str) > 0)
3384          printf("Set as importing in: %s\n", importing_str);
3385      if (owner == NULL) {
3386          clusterManagerLogInfo(">>> Nobody claims ownership, "
3387                                "selecting an owner...\n");
3388          owner = clusterManagerGetNodeWithMostKeysInSlot(cluster_manager.nodes,
3389                                                          slot, NULL);
3390          if (owner == NULL) {
3391              clusterManagerLogErr("[ERR] Can't select a slot owner. "
3392                                   "Impossible to fix.\n");
3393              success = 0;
3394              goto cleanup;
3395          }
3396          clusterManagerLogWarn("*** Configuring %s:%d as the slot owner\n",
3397                                owner->ip, owner->port);
3398          success = clusterManagerClearSlotStatus(owner, slot);
3399          if (!success) goto cleanup;
3400          success = clusterManagerSetSlotOwner(owner, slot, 0);
3401          if (!success) goto cleanup;
3402          owner->slots[slot] = 1;
3403          success = clusterManagerBumpEpoch(owner);
3404          if (!success) goto cleanup;
3405          clusterManagerRemoveNodeFromList(migrating, owner);
3406          clusterManagerRemoveNodeFromList(importing, owner);
3407      }
3408      if (listLength(owners) > 1) {
3409          assert(owner != NULL);
3410          listRewind(owners, &li);
3411          while ((ln = listNext(&li)) != NULL) {
3412              clusterManagerNode *n = ln->value;
3413              if (n == owner) continue;
3414              success = clusterManagerDelSlot(n, slot, 1);
3415              if (!success) goto cleanup;
3416              n->slots[slot] = 0;
3417              success = clusterManagerSetSlot(n, owner, slot, "node", NULL);
3418              if (!success) goto cleanup;
3419              success = clusterManagerSetSlot(n, owner, slot, "importing", NULL);
3420              if (!success) goto cleanup;
3421              clusterManagerRemoveNodeFromList(importing, n);
3422              listAddNodeTail(importing, n);
3423              clusterManagerRemoveNodeFromList(migrating, n);
3424          }
3425      }
3426      int move_opts = CLUSTER_MANAGER_OPT_VERBOSE;
3427      if (listLength(migrating) == 1 && listLength(importing) == 1) {
3428          clusterManagerNode *src = listFirst(migrating)->value;
3429          clusterManagerNode *dst = listFirst(importing)->value;
3430          clusterManagerLogInfo(">>> Case 1: Moving slot %d from "
3431                                "%s:%d to %s:%d\n", slot,
3432                                src->ip, src->port, dst->ip, dst->port);
3433          move_opts |= CLUSTER_MANAGER_OPT_UPDATE;
3434          success = clusterManagerMoveSlot(src, dst, slot, move_opts, NULL);
3435      }
3436      else if (listLength(migrating) == 0 && listLength(importing) > 0) {
3437          clusterManagerLogInfo(">>> Case 2: Moving all the %d slot keys to its "
3438                                "owner %s:%d\n", slot, owner->ip, owner->port);
3439          move_opts |= CLUSTER_MANAGER_OPT_COLD;
3440          listRewind(importing, &li);
3441          while ((ln = listNext(&li)) != NULL) {
3442              clusterManagerNode *n = ln->value;
3443              if (n == owner) continue;
3444              success = clusterManagerMoveSlot(n, owner, slot, move_opts, NULL);
3445              if (!success) goto cleanup;
3446              clusterManagerLogInfo(">>> Setting %d as STABLE in "
3447                                    "%s:%d\n", slot, n->ip, n->port);
3448              success = clusterManagerClearSlotStatus(n, slot);
3449              if (!success) goto cleanup;
3450          }
3451          listRewind(cluster_manager.nodes, &li);
3452          while ((ln = listNext(&li)) != NULL) {
3453              clusterManagerNode *n = ln->value;
3454              if (n == owner) continue;
3455              if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
3456              success = clusterManagerSetSlot(n, owner, slot, "NODE", NULL);
3457              if (!success) goto cleanup;
3458          }
3459      }
3460      else if (listLength(migrating) == 1 && listLength(importing) > 1) {
3461          int try_to_fix = 1;
3462          clusterManagerNode *src = listFirst(migrating)->value;
3463          clusterManagerNode *dst = NULL;
3464          sds target_id = NULL;
3465          for (int i = 0; i < src->migrating_count; i += 2) {
3466              sds migrating_slot = src->migrating[i];
3467              if (atoi(migrating_slot) == slot) {
3468                  target_id = src->migrating[i + 1];
3469                  break;
3470              }
3471          }
3472          assert(target_id != NULL);
3473          listIter li;
3474          listNode *ln;
3475          listRewind(importing, &li);
3476          while ((ln = listNext(&li)) != NULL) {
3477              clusterManagerNode *n = ln->value;
3478              int count = clusterManagerCountKeysInSlot(n, slot);
3479              if (count > 0) {
3480                  try_to_fix = 0;
3481                  break;
3482              }
3483              if (strcmp(n->name, target_id) == 0) dst = n;
3484          }
3485          if (!try_to_fix) goto unhandled_case;
3486          if (dst != NULL) {
3487              clusterManagerLogInfo(">>> Case 3: Moving slot %d from %s:%d to "
3488                                    "%s:%d and closing it on all the other "
3489                                    "importing nodes.\n",
3490                                    slot, src->ip, src->port,
3491                                    dst->ip, dst->port);
3492              success = clusterManagerMoveSlot(src, dst, slot, move_opts, NULL);
3493              if (!success) goto cleanup;
3494              listRewind(importing, &li);
3495              while ((ln = listNext(&li)) != NULL) {
3496                  clusterManagerNode *n = ln->value;
3497                  if (dst == n) continue;
3498                  success = clusterManagerClearSlotStatus(n, slot);
3499                  if (!success) goto cleanup;
3500              }
3501          } else {
3502              clusterManagerLogInfo(">>> Case 3: Closing slot %d on both "
3503                                    "migrating and importing nodes.\n", slot);
3504              success = clusterManagerClearSlotStatus(src, slot);
3505              if (!success) goto cleanup;
3506              listRewind(importing, &li);
3507              while ((ln = listNext(&li)) != NULL) {
3508                  clusterManagerNode *n = ln->value;
3509                  success = clusterManagerClearSlotStatus(n, slot);
3510                  if (!success) goto cleanup;
3511              }
3512          }
3513      } else {
3514          int try_to_close_slot = (listLength(importing) == 0 &&
3515                                   listLength(migrating) == 1);
3516          if (try_to_close_slot) {
3517              clusterManagerNode *n = listFirst(migrating)->value;
3518              if (!owner || owner != n) {
3519                  redisReply *r = CLUSTER_MANAGER_COMMAND(n,
3520                      "CLUSTER GETKEYSINSLOT %d %d", slot, 10);
3521                  success = clusterManagerCheckRedisReply(n, r, NULL);
3522                  if (r) {
3523                      if (success) try_to_close_slot = (r->elements == 0);
3524                      freeReplyObject(r);
3525                  }
3526                  if (!success) goto cleanup;
3527              }
3528          }
3529          if (try_to_close_slot) {
3530              clusterManagerNode *n = listFirst(migrating)->value;
3531              clusterManagerLogInfo(">>> Case 4: Closing slot %d on %s:%d\n",
3532                                    slot, n->ip, n->port);
3533              redisReply *r = CLUSTER_MANAGER_COMMAND(n, "CLUSTER SETSLOT %d %s",
3534                                                      slot, "STABLE");
3535              success = clusterManagerCheckRedisReply(n, r, NULL);
3536              if (r) freeReplyObject(r);
3537              if (!success) goto cleanup;
3538          } else {
3539  unhandled_case:
3540              success = 0;
3541              clusterManagerLogErr("[ERR] Sorry, redis-cli can't fix this slot "
3542                                   "yet (work in progress). Slot is set as "
3543                                   "migrating in %s, as importing in %s, "
3544                                   "owner is %s:%d\n", migrating_str,
3545                                   importing_str, owner->ip, owner->port);
3546          }
3547      }
3548  cleanup:
3549      listRelease(owners);
3550      listRelease(migrating);
3551      listRelease(importing);
3552      sdsfree(migrating_str);
3553      sdsfree(importing_str);
3554      return success;
3555  }
3556  static int clusterManagerFixMultipleSlotOwners(int slot, list *owners) {
3557      clusterManagerLogInfo(">>> Fixing multiple owners for slot %d...\n", slot);
3558      int success = 0;
3559      assert(listLength(owners) > 1);
3560      clusterManagerNode *owner = clusterManagerGetNodeWithMostKeysInSlot(owners,
3561                                                                          slot,
3562                                                                          NULL);
3563      if (!owner) owner = listFirst(owners)->value;
3564      clusterManagerLogInfo(">>> Setting slot %d owner: %s:%d\n",
3565                            slot, owner->ip, owner->port);
3566      if (!clusterManagerSetSlotOwner(owner, slot, 0)) return 0;
3567      listIter li;
3568      listNode *ln;
3569      listRewind(cluster_manager.nodes, &li);
3570      while ((ln = listNext(&li)) != NULL) {
3571          clusterManagerNode *n = ln->value;
3572          if (n == owner) continue;
3573          if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
3574          int count = clusterManagerCountKeysInSlot(n, slot);
3575          success = (count >= 0);
3576          if (!success) break;
3577          clusterManagerDelSlot(n, slot, 1);
3578          if (!clusterManagerSetSlot(n, owner, slot, "node", NULL)) return 0;
3579          if (count > 0) {
3580              int opts = CLUSTER_MANAGER_OPT_VERBOSE |
3581                         CLUSTER_MANAGER_OPT_COLD;
3582              success = clusterManagerMoveSlot(n, owner, slot, opts, NULL);
3583              if (!success) break;
3584          }
3585      }
3586      return success;
3587  }
3588  static int clusterManagerCheckCluster(int quiet) {
3589      listNode *ln = listFirst(cluster_manager.nodes);
3590      if (!ln) return 0;
3591      clusterManagerNode *node = ln->value;
3592      clusterManagerLogInfo(">>> Performing Cluster Check (using node %s:%d)\n",
3593                            node->ip, node->port);
3594      int result = 1, consistent = 0;
3595      int do_fix = config.cluster_manager_command.flags &
3596                   CLUSTER_MANAGER_CMD_FLAG_FIX;
3597      if (!quiet) clusterManagerShowNodes();
3598      consistent = clusterManagerIsConfigConsistent();
3599      if (!consistent) {
3600          sds err = sdsnew("[ERR] Nodes don't agree about configuration!");
3601          clusterManagerOnError(err);
3602          result = 0;
3603      } else {
3604          clusterManagerLogOk("[OK] All nodes agree about slots "
3605                              "configuration.\n");
3606      }
3607      clusterManagerLogInfo(">>> Check for open slots...\n");
3608      listIter li;
3609      listRewind(cluster_manager.nodes, &li);
3610      int i;
3611      dict *open_slots = NULL;
3612      while ((ln = listNext(&li)) != NULL) {
3613          clusterManagerNode *n = ln->value;
3614          if (n->migrating != NULL) {
3615              if (open_slots == NULL)
3616                  open_slots = dictCreate(&clusterManagerDictType, NULL);
3617              sds errstr = sdsempty();
3618              errstr = sdscatprintf(errstr,
3619                                  "[WARNING] Node %s:%d has slots in "
3620                                  "migrating state ",
3621                                  n->ip,
3622                                  n->port);
3623              for (i = 0; i < n->migrating_count; i += 2) {
3624                  sds slot = n->migrating[i];
3625                  dictAdd(open_slots, slot, sdsdup(n->migrating[i + 1]));
3626                  char *fmt = (i > 0 ? ",%S" : "%S");
3627                  errstr = sdscatfmt(errstr, fmt, slot);
3628              }
3629              errstr = sdscat(errstr, ".");
3630              clusterManagerOnError(errstr);
3631          }
3632          if (n->importing != NULL) {
3633              if (open_slots == NULL)
3634                  open_slots = dictCreate(&clusterManagerDictType, NULL);
3635              sds errstr = sdsempty();
3636              errstr = sdscatprintf(errstr,
3637                                  "[WARNING] Node %s:%d has slots in "
3638                                  "importing state ",
3639                                  n->ip,
3640                                  n->port);
3641              for (i = 0; i < n->importing_count; i += 2) {
3642                  sds slot = n->importing[i];
3643                  dictAdd(open_slots, slot, sdsdup(n->importing[i + 1]));
3644                  char *fmt = (i > 0 ? ",%S" : "%S");
3645                  errstr = sdscatfmt(errstr, fmt, slot);
3646              }
3647              errstr = sdscat(errstr, ".");
3648              clusterManagerOnError(errstr);
3649          }
3650      }
3651      if (open_slots != NULL) {
3652          result = 0;
3653          dictIterator *iter = dictGetIterator(open_slots);
3654          dictEntry *entry;
3655          sds errstr = sdsnew("[WARNING] The following slots are open: ");
3656          i = 0;
3657          while ((entry = dictNext(iter)) != NULL) {
3658              sds slot = (sds) dictGetKey(entry);
3659              char *fmt = (i++ > 0 ? ",%S" : "%S");
3660              errstr = sdscatfmt(errstr, fmt, slot);
3661          }
3662          clusterManagerLogErr("%s.\n", (char *) errstr);
3663          sdsfree(errstr);
3664          if (do_fix) {
3665              dictReleaseIterator(iter);
3666              iter = dictGetIterator(open_slots);
3667              while ((entry = dictNext(iter)) != NULL) {
3668                  sds slot = (sds) dictGetKey(entry);
3669                  result = clusterManagerFixOpenSlot(atoi(slot));
3670                  if (!result) break;
3671              }
3672          }
3673          dictReleaseIterator(iter);
3674          dictRelease(open_slots);
3675      }
3676      clusterManagerLogInfo(">>> Check slots coverage...\n");
3677      char slots[CLUSTER_MANAGER_SLOTS];
3678      memset(slots, 0, CLUSTER_MANAGER_SLOTS);
3679      int coverage = clusterManagerGetCoveredSlots(slots);
3680      if (coverage == CLUSTER_MANAGER_SLOTS) {
3681          clusterManagerLogOk("[OK] All %d slots covered.\n",
3682                              CLUSTER_MANAGER_SLOTS);
3683      } else {
3684          sds err = sdsempty();
3685          err = sdscatprintf(err, "[ERR] Not all %d slots are "
3686                                  "covered by nodes.\n",
3687                                  CLUSTER_MANAGER_SLOTS);
3688          clusterManagerOnError(err);
3689          result = 0;
3690          if (do_fix&bsol;* && result*/) {
3691              dictType dtype = clusterManagerDictType;
3692              dtype.keyDestructor = dictSdsDestructor;
3693              dtype.valDestructor = dictListDestructor;
3694              clusterManagerUncoveredSlots = dictCreate(&dtype, NULL);
3695              int fixed = clusterManagerFixSlotsCoverage(slots);
3696              if (fixed > 0) result = 1;
3697          }
3698      }
3699      int search_multiple_owners = config.cluster_manager_command.flags &
3700                                   CLUSTER_MANAGER_CMD_FLAG_CHECK_OWNERS;
3701      if (search_multiple_owners) {
3702          clusterManagerLogInfo(">>> Check for multiple slot owners...\n");
3703          int slot = 0;
3704          for (; slot < CLUSTER_MANAGER_SLOTS; slot++) {
3705              listIter li;
3706              listNode *ln;
3707              listRewind(cluster_manager.nodes, &li);
3708              list *owners = listCreate();
3709              while ((ln = listNext(&li)) != NULL) {
3710                  clusterManagerNode *n = ln->value;
3711                  if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
3712                  if (n->slots[slot]) listAddNodeTail(owners, n);
3713                  else {
3714                      int count = clusterManagerCountKeysInSlot(n, slot);
3715                      if (count > 0) listAddNodeTail(owners, n);
3716                  }
3717              }
3718              if (listLength(owners) > 1) {
3719                  result = 0;
3720                  clusterManagerLogErr("[WARNING] Slot %d has %d owners:\n",
3721                                       slot, listLength(owners));
3722                  listRewind(owners, &li);
3723                  while ((ln = listNext(&li)) != NULL) {
3724                      clusterManagerNode *n = ln->value;
3725                      clusterManagerLogErr("    %s:%d\n", n->ip, n->port);
3726                  }
3727                  if (do_fix) {
3728                      result = clusterManagerFixMultipleSlotOwners(slot, owners);
3729                      if (!result) {
3730                          clusterManagerLogErr("Failed to fix multiple owners "
3731                                               "for slot %d\n", slot);
3732                          listRelease(owners);
3733                          break;
3734                      }
3735                  }
3736              }
3737              listRelease(owners);
3738          }
3739      }
3740      return result;
3741  }
3742  static clusterManagerNode *clusterNodeForResharding(char *id,
3743                                                      clusterManagerNode *target,
3744                                                      int *raise_err)
3745  {
3746      clusterManagerNode *node = NULL;
3747      const char *invalid_node_msg = "*** The specified node (%s) is not known "
3748                                     "or not a master, please retry.\n";
3749      node = clusterManagerNodeByName(id);
3750      *raise_err = 0;
3751      if (!node || node->flags & CLUSTER_MANAGER_FLAG_SLAVE) {
3752          clusterManagerLogErr(invalid_node_msg, id);
3753          *raise_err = 1;
3754          return NULL;
3755      } else if (node != NULL && target != NULL) {
3756          if (!strcmp(node->name, target->name)) {
3757              clusterManagerLogErr( "*** It is not possible to use "
3758                                    "the target node as "
3759                                    "source node.\n");
3760              return NULL;
3761          }
3762      }
3763      return node;
3764  }
3765  static list *clusterManagerComputeReshardTable(list *sources, int numslots) {
3766      list *moved = listCreate();
3767      int src_count = listLength(sources), i = 0, tot_slots = 0, j;
3768      clusterManagerNode **sorted = zmalloc(src_count * sizeof(*sorted));
3769      listIter li;
3770      listNode *ln;
3771      listRewind(sources, &li);
3772      while ((ln = listNext(&li)) != NULL) {
3773          clusterManagerNode *node = ln->value;
3774          tot_slots += node->slots_count;
3775          sorted[i++] = node;
3776      }
3777      qsort(sorted, src_count, sizeof(clusterManagerNode *),
3778            clusterManagerSlotCountCompareDesc);
3779      for (i = 0; i < src_count; i++) {
3780          clusterManagerNode *node = sorted[i];
3781          float n = ((float) numslots / tot_slots * node->slots_count);
3782          if (i == 0) n = ceil(n);
3783          else n = floor(n);
3784          int max = (int) n, count = 0;
3785          for (j = 0; j < CLUSTER_MANAGER_SLOTS; j++) {
3786              int slot = node->slots[j];
3787              if (!slot) continue;
3788              if (count >= max || (int)listLength(moved) >= numslots) break;
3789              clusterManagerReshardTableItem *item = zmalloc(sizeof(*item));
3790              item->source = node;
3791              item->slot = j;
3792              listAddNodeTail(moved, item);
3793              count++;
3794          }
3795      }
3796      zfree(sorted);
3797      return moved;
3798  }
3799  static void clusterManagerShowReshardTable(list *table) {
3800      listIter li;
3801      listNode *ln;
3802      listRewind(table, &li);
3803      while ((ln = listNext(&li)) != NULL) {
3804          clusterManagerReshardTableItem *item = ln->value;
3805          clusterManagerNode *n = item->source;
3806          printf("    Moving slot %d from %s\n", item->slot, (char *) n->name);
3807      }
3808  }
3809  static void clusterManagerReleaseReshardTable(list *table) {
3810      if (table != NULL) {
3811          listIter li;
3812          listNode *ln;
3813          listRewind(table, &li);
3814          while ((ln = listNext(&li)) != NULL) {
3815              clusterManagerReshardTableItem *item = ln->value;
3816              zfree(item);
3817          }
3818          listRelease(table);
3819      }
3820  }
3821  static void clusterManagerLog(int level, const char* fmt, ...) {
3822      int use_colors =
3823          (config.cluster_manager_command.flags & CLUSTER_MANAGER_CMD_FLAG_COLOR);
3824      if (use_colors) {
3825          printf("\033[");
3826          switch (level) {
3827          case CLUSTER_MANAGER_LOG_LVL_INFO: printf(LOG_COLOR_BOLD); break;
3828          case CLUSTER_MANAGER_LOG_LVL_WARN: printf(LOG_COLOR_YELLOW); break;
3829          case CLUSTER_MANAGER_LOG_LVL_ERR: printf(LOG_COLOR_RED); break;
3830          case CLUSTER_MANAGER_LOG_LVL_SUCCESS: printf(LOG_COLOR_GREEN); break;
3831          default: printf(LOG_COLOR_RESET); break;
3832          }
3833      }
3834      va_list ap;
3835      va_start(ap, fmt);
3836      vprintf(fmt, ap);
3837      va_end(ap);
3838      if (use_colors) printf("\033[" LOG_COLOR_RESET);
3839  }
3840  static void clusterManagerNodeArrayInit(clusterManagerNodeArray *array,
3841                                          int alloc_len)
3842  {
3843      array->nodes = zcalloc(alloc_len * sizeof(clusterManagerNode*));
3844      array->alloc = array->nodes;
3845      array->len = alloc_len;
3846      array->count = 0;
3847  }
3848  static void clusterManagerNodeArrayReset(clusterManagerNodeArray *array) {
3849      if (array->nodes > array->alloc) {
3850          array->len = array->nodes - array->alloc;
3851          array->nodes = array->alloc;
3852          array->count = 0;
3853          int i = 0;
3854          for(; i < array->len; i++) {
3855              if (array->nodes[i] != NULL) array->count++;
3856          }
3857      }
3858  }
3859  static void clusterManagerNodeArrayShift(clusterManagerNodeArray *array,
3860                                           clusterManagerNode **nodeptr)
3861  {
3862      assert(array->nodes < (array->nodes + array->len));
3863      if (*array->nodes != NULL) array->count--;
3864      *nodeptr = *array->nodes;
3865      array->nodes++;
3866      array->len--;
3867  }
3868  static void clusterManagerNodeArrayAdd(clusterManagerNodeArray *array,
3869                                         clusterManagerNode *node)
3870  {
3871      assert(array->nodes < (array->nodes + array->len));
3872      assert(node != NULL);
3873      assert(array->count < array->len);
3874      array->nodes[array->count++] = node;
3875  }
3876  static void clusterManagerPrintNotEmptyNodeError(clusterManagerNode *node,
3877                                                   char *err)
3878  {
3879      char *msg;
3880      if (err) msg = err;
3881      else {
3882          msg = "is not empty. Either the node already knows other "
3883                "nodes (check with CLUSTER NODES) or contains some "
3884                "key in database 0.";
3885      }
3886      clusterManagerLogErr("[ERR] Node %s:%d %s\n", node->ip, node->port, msg);
3887  }
3888  static void clusterManagerPrintNotClusterNodeError(clusterManagerNode *node,
3889                                                     char *err)
3890  {
3891      char *msg = (err ? err : "is not configured as a cluster node.");
3892      clusterManagerLogErr("[ERR] Node %s:%d %s\n", node->ip, node->port, msg);
3893  }
3894  static void clusterManagerMode(clusterManagerCommandProc *proc) {
3895      int argc = config.cluster_manager_command.argc;
3896      char **argv = config.cluster_manager_command.argv;
3897      cluster_manager.nodes = NULL;
3898      if (!proc(argc, argv)) goto cluster_manager_err;
3899      freeClusterManager();
3900      exit(0);
3901  cluster_manager_err:
3902      freeClusterManager();
3903      sdsfree(config.hostip);
3904      sdsfree(config.mb_delim);
3905      exit(1);
3906  }
3907  static int clusterManagerCommandCreate(int argc, char **argv) {
3908      int i, j, success = 1;
3909      cluster_manager.nodes = listCreate();
3910      for (i = 0; i < argc; i++) {
3911          char *addr = argv[i];
3912          char *c = strrchr(addr, '@');
3913          if (c != NULL) *c = '\0';
3914          c = strrchr(addr, ':');
3915          if (c == NULL) {
3916              fprintf(stderr, "Invalid address format: %s\n", addr);
3917              return 0;
3918          }
3919          *c = '\0';
3920          char *ip = addr;
3921          int port = atoi(++c);
3922          clusterManagerNode *node = clusterManagerNewNode(ip, port);
3923          if (!clusterManagerNodeConnect(node)) {
3924              freeClusterManagerNode(node);
3925              return 0;
3926          }
3927          char *err = NULL;
3928          if (!clusterManagerNodeIsCluster(node, &err)) {
3929              clusterManagerPrintNotClusterNodeError(node, err);
3930              if (err) zfree(err);
3931              freeClusterManagerNode(node);
3932              return 0;
3933          }
3934          err = NULL;
3935          if (!clusterManagerNodeLoadInfo(node, 0, &err)) {
3936              if (err) {
3937                  CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
3938                  zfree(err);
3939              }
3940              freeClusterManagerNode(node);
3941              return 0;
3942          }
3943          err = NULL;
3944          if (!clusterManagerNodeIsEmpty(node, &err)) {
3945              clusterManagerPrintNotEmptyNodeError(node, err);
3946              if (err) zfree(err);
3947              freeClusterManagerNode(node);
3948              return 0;
3949          }
3950          listAddNodeTail(cluster_manager.nodes, node);
3951      }
3952      int node_len = cluster_manager.nodes->len;
3953      int replicas = config.cluster_manager_command.replicas;
3954      int masters_count = CLUSTER_MANAGER_MASTERS_COUNT(node_len, replicas);
3955      if (masters_count < 3) {
3956          clusterManagerLogErr(
3957              "*** ERROR: Invalid configuration for cluster creation.\n"
3958              "*** Redis Cluster requires at least 3 master nodes.\n"
3959              "*** This is not possible with %d nodes and %d replicas per node.",
3960              node_len, replicas);
3961          clusterManagerLogErr("\n*** At least %d nodes are required.\n",
3962                               3 * (replicas + 1));
3963          return 0;
3964      }
3965      clusterManagerLogInfo(">>> Performing hash slots allocation "
3966                            "on %d nodes...\n", node_len);
3967      int interleaved_len = 0, ip_count = 0;
3968      clusterManagerNode **interleaved = zcalloc(node_len*sizeof(**interleaved));
3969      char **ips = zcalloc(node_len * sizeof(char*));
3970      clusterManagerNodeArray *ip_nodes = zcalloc(node_len * sizeof(*ip_nodes));
3971      listIter li;
3972      listNode *ln;
3973      listRewind(cluster_manager.nodes, &li);
3974      while ((ln = listNext(&li)) != NULL) {
3975          clusterManagerNode *n = ln->value;
3976          int found = 0;
3977          for (i = 0; i < ip_count; i++) {
3978              char *ip = ips[i];
3979              if (!strcmp(ip, n->ip)) {
3980                  found = 1;
3981                  break;
3982              }
3983          }
3984          if (!found) {
3985              ips[ip_count++] = n->ip;
3986          }
3987          clusterManagerNodeArray *node_array = &(ip_nodes[i]);
3988          if (node_array->nodes == NULL)
3989              clusterManagerNodeArrayInit(node_array, node_len);
3990          clusterManagerNodeArrayAdd(node_array, n);
3991      }
3992      while (interleaved_len < node_len) {
3993          for (i = 0; i < ip_count; i++) {
3994              clusterManagerNodeArray *node_array = &(ip_nodes[i]);
3995              if (node_array->count > 0) {
3996                  clusterManagerNode *n = NULL;
3997                  clusterManagerNodeArrayShift(node_array, &n);
3998                  interleaved[interleaved_len++] = n;
3999              }
4000          }
4001      }
4002      clusterManagerNode **masters = interleaved;
4003      interleaved += masters_count;
4004      interleaved_len -= masters_count;
4005      float slots_per_node = CLUSTER_MANAGER_SLOTS / (float) masters_count;
4006      PORT_LONG first = 0;
4007      float cursor = 0.0f;
4008      for (i = 0; i < masters_count; i++) {
4009          clusterManagerNode *master = masters[i];
4010          PORT_LONG last = lround(cursor + slots_per_node - 1);
4011          if (last > CLUSTER_MANAGER_SLOTS || i == (masters_count - 1))
4012              last = CLUSTER_MANAGER_SLOTS - 1;
4013          if (last < first) last = first;
4014          printf("Master[%d] -> Slots %lu - %lu\n", i, first, last);
4015          master->slots_count = 0;
4016          for (j = first; j <= last; j++) {
4017              master->slots[j] = 1;
4018              master->slots_count++;
4019          }
4020          master->dirty = 1;
4021          first = last + 1;
4022          cursor += slots_per_node;
4023      }
4024      clusterManagerNode *first_node = interleaved[0];
4025      for (i = 0; i < (interleaved_len - 1); i++)
4026          interleaved[i] = interleaved[i + 1];
4027      interleaved[interleaved_len - 1] = first_node;
4028      int assign_unused = 0, available_count = interleaved_len;
4029  assign_replicas:
4030      for (i = 0; i < masters_count; i++) {
4031          clusterManagerNode *master = masters[i];
4032          int assigned_replicas = 0;
4033          while (assigned_replicas < replicas) {
4034              if (available_count == 0) break;
4035              clusterManagerNode *found = NULL, *slave = NULL;
4036              int firstNodeIdx = -1;
4037              for (j = 0; j < interleaved_len; j++) {
4038                  clusterManagerNode *n = interleaved[j];
4039                  if (n == NULL) continue;
4040                  if (strcmp(n->ip, master->ip)) {
4041                      found = n;
4042                      interleaved[j] = NULL;
4043                      break;
4044                  }
4045                  if (firstNodeIdx < 0) firstNodeIdx = j;
4046              }
4047              if (found) slave = found;
4048              else if (firstNodeIdx >= 0) {
4049                  slave = interleaved[firstNodeIdx];
4050                  interleaved_len -= (interleaved - (interleaved + firstNodeIdx));
4051                  interleaved += (firstNodeIdx + 1);
4052              }
4053              if (slave != NULL) {
4054                  assigned_replicas++;
4055                  available_count--;
4056                  if (slave->replicate) sdsfree(slave->replicate);
4057                  slave->replicate = sdsnew(master->name);
4058                  slave->dirty = 1;
4059              } else break;
4060              printf("Adding replica %s:%d to %s:%d\n", slave->ip, slave->port,
4061                     master->ip, master->port);
4062              if (assign_unused) break;
4063          }
4064      }
4065      if (!assign_unused && available_count > 0) {
4066          assign_unused = 1;
4067          printf("Adding extra replicas...\n");
4068          goto assign_replicas;
4069      }
4070      for (i = 0; i < ip_count; i++) {
4071          clusterManagerNodeArray *node_array = ip_nodes + i;
4072          clusterManagerNodeArrayReset(node_array);
4073      }
4074      clusterManagerOptimizeAntiAffinity(ip_nodes, ip_count);
4075      clusterManagerShowNodes();
4076      if (confirmWithYes("Can I set the above configuration?")) {
4077          listRewind(cluster_manager.nodes, &li);
4078          while ((ln = listNext(&li)) != NULL) {
4079              clusterManagerNode *node = ln->value;
4080              char *err = NULL;
4081              int flushed = clusterManagerFlushNodeConfig(node, &err);
4082              if (!flushed && node->dirty && !node->replicate) {
4083                  if (err != NULL) {
4084                      CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
4085                      zfree(err);
4086                  }
4087                  success = 0;
4088                  goto cleanup;
4089              } else if (err != NULL) zfree(err);
4090          }
4091          clusterManagerLogInfo(">>> Nodes configuration updated\n");
4092          clusterManagerLogInfo(">>> Assign a different config epoch to "
4093                                "each node\n");
4094          int config_epoch = 1;
4095          listRewind(cluster_manager.nodes, &li);
4096          while ((ln = listNext(&li)) != NULL) {
4097              clusterManagerNode *node = ln->value;
4098              redisReply *reply = NULL;
4099              reply = CLUSTER_MANAGER_COMMAND(node,
4100                                              "cluster set-config-epoch %d",
4101                                              config_epoch++);
4102              if (reply != NULL) freeReplyObject(reply);
4103          }
4104          clusterManagerLogInfo(">>> Sending CLUSTER MEET messages to join "
4105                                "the cluster\n");
4106          clusterManagerNode *first = NULL;
4107          listRewind(cluster_manager.nodes, &li);
4108          while ((ln = listNext(&li)) != NULL) {
4109              clusterManagerNode *node = ln->value;
4110              if (first == NULL) {
4111                  first = node;
4112                  continue;
4113              }
4114              redisReply *reply = NULL;
4115              reply = CLUSTER_MANAGER_COMMAND(node, "cluster meet %s %d",
4116                                              first->ip, first->port);
4117              int is_err = 0;
4118              if (reply != NULL) {
4119                  if ((is_err = reply->type == REDIS_REPLY_ERROR))
4120                      CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, reply->str);
4121                  freeReplyObject(reply);
4122              } else {
4123                  is_err = 1;
4124                  fprintf(stderr, "Failed to send CLUSTER MEET command.\n");
4125              }
4126              if (is_err) {
4127                  success = 0;
4128                  goto cleanup;
4129              }
4130          }
4131          sleep(1);
4132          clusterManagerWaitForClusterJoin();
4133          listRewind(cluster_manager.nodes, &li);
4134          while ((ln = listNext(&li)) != NULL) {
4135              clusterManagerNode *node = ln->value;
4136              if (!node->dirty) continue;
4137              char *err = NULL;
4138              int flushed = clusterManagerFlushNodeConfig(node, &err);
4139              if (!flushed && !node->replicate) {
4140                  if (err != NULL) {
4141                      CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
4142                      zfree(err);
4143                  }
4144                  success = 0;
4145                  goto cleanup;
4146              }
4147          }
4148          listRewind(cluster_manager.nodes, &li);
4149          clusterManagerNode *first_node = NULL;
4150          while ((ln = listNext(&li)) != NULL) {
4151              clusterManagerNode *node = ln->value;
4152              if (!first_node) first_node = node;
4153              else freeClusterManagerNode(node);
4154          }
4155          listEmpty(cluster_manager.nodes);
4156          if (!clusterManagerLoadInfoFromNode(first_node, 0)) {
4157              success = 0;
4158              goto cleanup;
4159          }
4160          clusterManagerCheckCluster(0);
4161      }
4162  cleanup:
4163      zfree(masters);
4164      zfree(ips);
4165      for (i = 0; i < node_len; i++) {
4166          clusterManagerNodeArray *node_array = ip_nodes + i;
4167          CLUSTER_MANAGER_NODE_ARRAY_FREE(node_array);
4168      }
4169      zfree(ip_nodes);
4170      return success;
4171  }
4172  static int clusterManagerCommandAddNode(int argc, char **argv) {
4173      int success = 1;
4174      redisReply *reply = NULL;
4175      char *ref_ip = NULL, *ip = NULL;
4176      int ref_port = 0, port = 0;
4177      if (!getClusterHostFromCmdArgs(argc - 1, argv + 1, &ref_ip, &ref_port))
4178          goto invalid_args;
4179      if (!getClusterHostFromCmdArgs(1, argv, &ip, &port))
4180          goto invalid_args;
4181      clusterManagerLogInfo(">>> Adding node %s:%d to cluster %s:%d\n", ip, port,
4182                            ref_ip, ref_port);
4183      clusterManagerNode *refnode = clusterManagerNewNode(ref_ip, ref_port);
4184      if (!clusterManagerLoadInfoFromNode(refnode, 0)) return 0;
4185      if (!clusterManagerCheckCluster(0)) return 0;
4186      clusterManagerNode *master_node = NULL;
4187      if (config.cluster_manager_command.flags & CLUSTER_MANAGER_CMD_FLAG_SLAVE) {
4188          char *master_id = config.cluster_manager_command.master_id;
4189          if (master_id != NULL) {
4190              master_node = clusterManagerNodeByName(master_id);
4191              if (master_node == NULL) {
4192                  clusterManagerLogErr("[ERR] No such master ID %s\n", master_id);
4193                  return 0;
4194              }
4195          } else {
4196              master_node = clusterManagerNodeWithLeastReplicas();
4197              assert(master_node != NULL);
4198              printf("Automatically selected master %s:%d\n", master_node->ip,
4199                     master_node->port);
4200          }
4201      }
4202      clusterManagerNode *new_node = clusterManagerNewNode(ip, port);
4203      int added = 0;
4204      if (!clusterManagerNodeConnect(new_node)) {
4205          clusterManagerLogErr("[ERR] Sorry, can't connect to node %s:%d\n",
4206                               ip, port);
4207          success = 0;
4208          goto cleanup;
4209      }
4210      char *err = NULL;
4211      if (!(success = clusterManagerNodeIsCluster(new_node, &err))) {
4212          clusterManagerPrintNotClusterNodeError(new_node, err);
4213          if (err) zfree(err);
4214          goto cleanup;
4215      }
4216      if (!clusterManagerNodeLoadInfo(new_node, 0, &err)) {
4217          if (err) {
4218              CLUSTER_MANAGER_PRINT_REPLY_ERROR(new_node, err);
4219              zfree(err);
4220          }
4221          success = 0;
4222          goto cleanup;
4223      }
4224      if (!(success = clusterManagerNodeIsEmpty(new_node, &err))) {
4225          clusterManagerPrintNotEmptyNodeError(new_node, err);
4226          if (err) zfree(err);
4227          goto cleanup;
4228      }
4229      clusterManagerNode *first = listFirst(cluster_manager.nodes)->value;
4230      listAddNodeTail(cluster_manager.nodes, new_node);
4231      added = 1;
4232      clusterManagerLogInfo(">>> Send CLUSTER MEET to node %s:%d to make it "
4233                            "join the cluster.\n", ip, port);
4234      reply = CLUSTER_MANAGER_COMMAND(new_node, "CLUSTER MEET %s %d",
4235                                      first->ip, first->port);
4236      if (!(success = clusterManagerCheckRedisReply(new_node, reply, NULL)))
4237          goto cleanup;
4238      if (master_node) {
4239          sleep(1);
4240          clusterManagerWaitForClusterJoin();
4241          clusterManagerLogInfo(">>> Configure node as replica of %s:%d.\n",
4242                                master_node->ip, master_node->port);
4243          freeReplyObject(reply);
4244          reply = CLUSTER_MANAGER_COMMAND(new_node, "CLUSTER REPLICATE %s",
4245                                          master_node->name);
4246          if (!(success = clusterManagerCheckRedisReply(new_node, reply, NULL)))
4247              goto cleanup;
4248      }
4249      clusterManagerLogOk("[OK] New node added correctly.\n");
4250  cleanup:
4251      if (!added && new_node) freeClusterManagerNode(new_node);
4252      if (reply) freeReplyObject(reply);
4253      return success;
4254  invalid_args:
4255      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4256      return 0;
4257  }
4258  static int clusterManagerCommandDeleteNode(int argc, char **argv) {
4259      UNUSED(argc);
4260      int success = 1;
4261      int port = 0;
4262      char *ip = NULL;
4263      if (!getClusterHostFromCmdArgs(1, argv, &ip, &port)) goto invalid_args;
4264      char *node_id = argv[1];
4265      clusterManagerLogInfo(">>> Removing node %s from cluster %s:%d\n",
4266                            node_id, ip, port);
4267      clusterManagerNode *ref_node = clusterManagerNewNode(ip, port);
4268      clusterManagerNode *node = NULL;
4269      if (!clusterManagerLoadInfoFromNode(ref_node, 0)) return 0;
4270      node = clusterManagerNodeByName(node_id);
4271      if (node == NULL) {
4272          clusterManagerLogErr("[ERR] No such node ID %s\n", node_id);
4273          return 0;
4274      }
4275      if (node->slots_count != 0) {
4276          clusterManagerLogErr("[ERR] Node %s:%d is not empty! Reshard data "
4277                               "away and try again.\n", node->ip, node->port);
4278          return 0;
4279      }
4280      clusterManagerLogInfo(">>> Sending CLUSTER FORGET messages to the "
4281                            "cluster...\n");
4282      listIter li;
4283      listNode *ln;
4284      listRewind(cluster_manager.nodes, &li);
4285      while ((ln = listNext(&li)) != NULL) {
4286          clusterManagerNode *n = ln->value;
4287          if (n == node) continue;
4288          if (n->replicate && !strcasecmp(n->replicate, node_id)) {
4289              clusterManagerNode *master = clusterManagerNodeWithLeastReplicas();
4290              assert(master != NULL);
4291              clusterManagerLogInfo(">>> %s:%d as replica of %s:%d\n",
4292                                    n->ip, n->port, master->ip, master->port);
4293              redisReply *r = CLUSTER_MANAGER_COMMAND(n, "CLUSTER REPLICATE %s",
4294                                                      master->name);
4295              success = clusterManagerCheckRedisReply(n, r, NULL);
4296              if (r) freeReplyObject(r);
4297              if (!success) return 0;
4298          }
4299          redisReply *r = CLUSTER_MANAGER_COMMAND(n, "CLUSTER FORGET %s",
4300                                                  node_id);
4301          success = clusterManagerCheckRedisReply(n, r, NULL);
4302          if (r) freeReplyObject(r);
4303          if (!success) return 0;
4304      }
4305      clusterManagerLogInfo(">>> SHUTDOWN the node.\n");
4306      redisReply *r = redisCommand(node->context, "SHUTDOWN");
4307      success = clusterManagerCheckRedisReply(node, r, NULL);
4308      if (r) freeReplyObject(r);
4309      return success;
4310  invalid_args:
4311      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4312      return 0;
4313  }
4314  static int clusterManagerCommandInfo(int argc, char **argv) {
4315      int port = 0;
4316      char *ip = NULL;
4317      if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) goto invalid_args;
4318      clusterManagerNode *node = clusterManagerNewNode(ip, port);
4319      if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
4320      clusterManagerShowClusterInfo();
4321      return 1;
4322  invalid_args:
4323      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4324      return 0;
4325  }
4326  static int clusterManagerCommandCheck(int argc, char **argv) {
4327      int port = 0;
4328      char *ip = NULL;
4329      if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) goto invalid_args;
4330      clusterManagerNode *node = clusterManagerNewNode(ip, port);
4331      if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
4332      clusterManagerShowClusterInfo();
4333      return clusterManagerCheckCluster(0);
4334  invalid_args:
4335      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4336      return 0;
4337  }
4338  static int clusterManagerCommandFix(int argc, char **argv) {
4339      config.cluster_manager_command.flags |= CLUSTER_MANAGER_CMD_FLAG_FIX;
4340      return clusterManagerCommandCheck(argc, argv);
4341  }
4342  static int clusterManagerCommandReshard(int argc, char **argv) {
4343      int port = 0;
4344      char *ip = NULL;
4345      if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) goto invalid_args;
4346      clusterManagerNode *node = clusterManagerNewNode(ip, port);
4347      if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
4348      clusterManagerCheckCluster(0);
4349      if (cluster_manager.errors && listLength(cluster_manager.errors) > 0) {
4350          fflush(stdout);
4351          fprintf(stderr,
4352                  "*** Please fix your cluster problems before resharding\n");
4353          return 0;
4354      }
4355      int slots = config.cluster_manager_command.slots;
4356      if (!slots) {
4357          while (slots <= 0 || slots > CLUSTER_MANAGER_SLOTS) {
4358              printf("How many slots do you want to move (from 1 to %d)? ",
4359                     CLUSTER_MANAGER_SLOTS);
4360              fflush(stdout);
4361              char buf[6];
4362              int nread = read(fileno(stdin),buf,6);
4363              if (nread <= 0) continue;
4364              int last_idx = nread - 1;
4365              if (buf[last_idx] != '\n') {
4366                  int ch;
4367                  while ((ch = getchar()) != '\n' && ch != EOF) {}
4368              }
4369              buf[last_idx] = '\0';
4370              slots = atoi(buf);
4371          }
4372      }
4373      char buf[255];
4374      char *to = config.cluster_manager_command.to,
4375           *from = config.cluster_manager_command.from;
4376      while (to == NULL) {
4377          printf("What is the receiving node ID? ");
4378          fflush(stdout);
4379          int nread = read(fileno(stdin),buf,255);
4380          if (nread <= 0) continue;
4381          int last_idx = nread - 1;
4382          if (buf[last_idx] != '\n') {
4383              int ch;
4384              while ((ch = getchar()) != '\n' && ch != EOF) {}
4385          }
4386          buf[last_idx] = '\0';
4387          if (strlen(buf) > 0) to = buf;
4388      }
4389      int raise_err = 0;
4390      clusterManagerNode *target = clusterNodeForResharding(to, NULL, &raise_err);
4391      if (target == NULL) return 0;
4392      list *sources = listCreate();
4393      list *table = NULL;
4394      int all = 0, result = 1;
4395      if (from == NULL) {
4396          printf("Please enter all the source node IDs.\n");
4397          printf("  Type 'all' to use all the nodes as source nodes for "
4398                 "the hash slots.\n");
4399          printf("  Type 'done' once you entered all the source nodes IDs.\n");
4400          while (1) {
4401              printf("Source node #%lu: ", listLength(sources) + 1);
4402              fflush(stdout);
4403              int nread = read(fileno(stdin),buf,255);
4404              if (nread <= 0) continue;
4405              int last_idx = nread - 1;
4406              if (buf[last_idx] != '\n') {
4407                  int ch;
4408                  while ((ch = getchar()) != '\n' && ch != EOF) {}
4409              }
4410              buf[last_idx] = '\0';
4411              if (!strcmp(buf, "done")) break;
4412              else if (!strcmp(buf, "all")) {
4413                  all = 1;
4414                  break;
4415              } else {
4416                  clusterManagerNode *src =
4417                      clusterNodeForResharding(buf, target, &raise_err);
4418                  if (src != NULL) listAddNodeTail(sources, src);
4419                  else if (raise_err) {
4420                      result = 0;
4421                      goto cleanup;
4422                  }
4423              }
4424          }
4425      } else {
4426          char *p;
4427          while((p = strchr(from, ',')) != NULL) {
4428              *p = '\0';
4429              if (!strcmp(from, "all")) {
4430                  all = 1;
4431                  break;
4432              } else {
4433                  clusterManagerNode *src =
4434                      clusterNodeForResharding(from, target, &raise_err);
4435                  if (src != NULL) listAddNodeTail(sources, src);
4436                  else if (raise_err) {
4437                      result = 0;
4438                      goto cleanup;
4439                  }
4440              }
4441              from = p + 1;
4442          }
4443          if (!all && strlen(from) > 0) {
4444              if (!strcmp(from, "all")) all = 1;
4445              if (!all) {
4446                  clusterManagerNode *src =
4447                      clusterNodeForResharding(from, target, &raise_err);
4448                  if (src != NULL) listAddNodeTail(sources, src);
4449                  else if (raise_err) {
4450                      result = 0;
4451                      goto cleanup;
4452                  }
4453              }
4454          }
4455      }
4456      listIter li;
4457      listNode *ln;
4458      if (all) {
4459          listEmpty(sources);
4460          listRewind(cluster_manager.nodes, &li);
4461          while ((ln = listNext(&li)) != NULL) {
4462              clusterManagerNode *n = ln->value;
4463              if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE || n->replicate)
4464                  continue;
4465              if (!sdscmp(n->name, target->name)) continue;
4466              listAddNodeTail(sources, n);
4467          }
4468      }
4469      if (listLength(sources) == 0) {
4470          fprintf(stderr, "*** No source nodes given, operation aborted.\n");
4471          result = 0;
4472          goto cleanup;
4473      }
4474      printf("\nReady to move %d slots.\n", slots);
4475      printf("  Source nodes:\n");
4476      listRewind(sources, &li);
4477      while ((ln = listNext(&li)) != NULL) {
4478          clusterManagerNode *src = ln->value;
4479          sds info = clusterManagerNodeInfo(src, 4);
4480          printf("%s\n", info);
4481          sdsfree(info);
4482      }
4483      printf("  Destination node:\n");
4484      sds info = clusterManagerNodeInfo(target, 4);
4485      printf("%s\n", info);
4486      sdsfree(info);
4487      table = clusterManagerComputeReshardTable(sources, slots);
4488      printf("  Resharding plan:\n");
4489      clusterManagerShowReshardTable(table);
4490      if (!(config.cluster_manager_command.flags &
4491            CLUSTER_MANAGER_CMD_FLAG_YES))
4492      {
4493          printf("Do you want to proceed with the proposed "
4494                 "reshard plan (yes/no)? ");
4495          fflush(stdout);
4496          char buf[4];
4497          int nread = read(fileno(stdin),buf,4);
4498          buf[3] = '\0';
4499          if (nread <= 0 || strcmp("yes", buf) != 0) {
4500              result = 0;
4501              goto cleanup;
4502          }
4503      }
4504      int opts = CLUSTER_MANAGER_OPT_VERBOSE;
4505      listRewind(table, &li);
4506      while ((ln = listNext(&li)) != NULL) {
4507          clusterManagerReshardTableItem *item = ln->value;
4508          char *err = NULL;
4509          result = clusterManagerMoveSlot(item->source, target, item->slot,
4510                                          opts, &err);
4511          if (!result) {
4512              if (err != NULL) {
4513                  zfree(err);
4514              }
4515              goto cleanup;
4516          }
4517      }
4518  cleanup:
4519      listRelease(sources);
4520      clusterManagerReleaseReshardTable(table);
4521      return result;
4522  invalid_args:
4523      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4524      return 0;
4525  }
4526  static int clusterManagerCommandRebalance(int argc, char **argv) {
4527      int port = 0;
4528      char *ip = NULL;
4529      clusterManagerNode **weightedNodes = NULL;
4530      list *involved = NULL;
4531      if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) goto invalid_args;
4532      clusterManagerNode *node = clusterManagerNewNode(ip, port);
4533      if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
4534      int result = 1, i;
4535      if (config.cluster_manager_command.weight != NULL) {
4536          for (i = 0; i < config.cluster_manager_command.weight_argc; i++) {
4537              char *name = config.cluster_manager_command.weight[i];
4538              char *p = strchr(name, '=');
4539              if (p == NULL) {
4540                  result = 0;
4541                  goto cleanup;
4542              }
4543              *p = '\0';
4544              float w = atof(++p);
4545              clusterManagerNode *n = clusterManagerNodeByAbbreviatedName(name);
4546              if (n == NULL) {
4547                  clusterManagerLogErr("*** No such master node %s\n", name);
4548                  result = 0;
4549                  goto cleanup;
4550              }
4551              n->weight = w;
4552          }
4553      }
4554      float total_weight = 0;
4555      int nodes_involved = 0;
4556      int use_empty = config.cluster_manager_command.flags &
4557                      CLUSTER_MANAGER_CMD_FLAG_EMPTYMASTER;
4558      involved = listCreate();
4559      listIter li;
4560      listNode *ln;
4561      listRewind(cluster_manager.nodes, &li);
4562      while ((ln = listNext(&li)) != NULL) {
4563          clusterManagerNode *n = ln->value;
4564          if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE || n->replicate)
4565              continue;
4566          if (!use_empty && n->slots_count == 0) {
4567              n->weight = 0;
4568              continue;
4569          }
4570          total_weight += n->weight;
4571          nodes_involved++;
4572          listAddNodeTail(involved, n);
4573      }
4574      weightedNodes = zmalloc(nodes_involved * sizeof(clusterManagerNode *));
4575      if (weightedNodes == NULL) goto cleanup;
4576      clusterManagerCheckCluster(1);
4577      if (cluster_manager.errors && listLength(cluster_manager.errors) > 0) {
4578          clusterManagerLogErr("*** Please fix your cluster problems "
4579                               "before rebalancing\n");
4580          result = 0;
4581          goto cleanup;
4582      }
4583      int threshold_reached = 0, total_balance = 0;
4584      float threshold = config.cluster_manager_command.threshold;
4585      i = 0;
4586      listRewind(involved, &li);
4587      while ((ln = listNext(&li)) != NULL) {
4588          clusterManagerNode *n = ln->value;
4589          weightedNodes[i++] = n;
4590          int expected = (int) (((float)CLUSTER_MANAGER_SLOTS / total_weight) *
4591                          n->weight);
4592          n->balance = n->slots_count - expected;
4593          total_balance += n->balance;
4594          int over_threshold = 0;
4595          if (threshold > 0) {
4596              if (n->slots_count > 0) {
4597                  float err_perc = fabs((100-(100.0*expected/n->slots_count)));
4598                  if (err_perc > threshold) over_threshold = 1;
4599              } else if (expected > 1) {
4600                  over_threshold = 1;
4601              }
4602          }
4603          if (over_threshold) threshold_reached = 1;
4604      }
4605      if (!threshold_reached) {
4606          clusterManagerLogWarn("*** No rebalancing needed! "
4607                               "All nodes are within the %.2f%% threshold.\n",
4608                               config.cluster_manager_command.threshold);
4609          goto cleanup;
4610      }
4611      while (total_balance > 0) {
4612          listRewind(involved, &li);
4613          while ((ln = listNext(&li)) != NULL) {
4614              clusterManagerNode *n = ln->value;
4615              if (n->balance <= 0 && total_balance > 0) {
4616                  n->balance--;
4617                  total_balance--;
4618              }
4619          }
4620      }
4621      qsort(weightedNodes, nodes_involved, sizeof(clusterManagerNode *),
4622            clusterManagerCompareNodeBalance);
4623      clusterManagerLogInfo(">>> Rebalancing across %d nodes. "
4624                            "Total weight = %.2f\n",
4625                            nodes_involved, total_weight);
4626      if (config.verbose) {
4627          for (i = 0; i < nodes_involved; i++) {
4628              clusterManagerNode *n = weightedNodes[i];
4629              printf("%s:%d balance is %d slots\n", n->ip, n->port, n->balance);
4630          }
4631      }
4632      int dst_idx = 0;
4633      int src_idx = nodes_involved - 1;
4634      int simulate = config.cluster_manager_command.flags &
4635                     CLUSTER_MANAGER_CMD_FLAG_SIMULATE;
4636      while (dst_idx < src_idx) {
4637          clusterManagerNode *dst = weightedNodes[dst_idx];
4638          clusterManagerNode *src = weightedNodes[src_idx];
4639          int db = abs(dst->balance);
4640          int sb = abs(src->balance);
4641          int numslots = (db < sb ? db : sb);
4642          if (numslots > 0) {
4643              printf("Moving %d slots from %s:%d to %s:%d\n", numslots,
4644                                                              src->ip,
4645                                                              src->port,
4646                                                              dst->ip,
4647                                                              dst->port);
4648              list *lsrc = listCreate(), *table = NULL;
4649              listAddNodeTail(lsrc, src);
4650              table = clusterManagerComputeReshardTable(lsrc, numslots);
4651              listRelease(lsrc);
4652              int table_len = (int) listLength(table);
4653              if (!table || table_len != numslots) {
4654                  clusterManagerLogErr("*** Assertion failed: Reshard table "
4655                                       "!= number of slots");
4656                  result = 0;
4657                  goto end_move;
4658              }
4659              if (simulate) {
4660                  for (i = 0; i < table_len; i++) printf("#");
4661              } else {
4662                  int opts = CLUSTER_MANAGER_OPT_QUIET |
4663                             CLUSTER_MANAGER_OPT_UPDATE;
4664                  listRewind(table, &li);
4665                  while ((ln = listNext(&li)) != NULL) {
4666                      clusterManagerReshardTableItem *item = ln->value;
4667                      result = clusterManagerMoveSlot(item->source,
4668                                                      dst,
4669                                                      item->slot,
4670                                                      opts, NULL);
4671                      if (!result) goto end_move;
4672                      printf("#");
4673                      fflush(stdout);
4674                  }
4675              }
4676              printf("\n");
4677  end_move:
4678              clusterManagerReleaseReshardTable(table);
4679              if (!result) goto cleanup;
4680          }
4681          dst->balance += numslots;
4682          src->balance -= numslots;
4683          if (dst->balance == 0) dst_idx++;
4684          if (src->balance == 0) src_idx --;
4685      }
4686  cleanup:
4687      if (involved != NULL) listRelease(involved);
4688      if (weightedNodes != NULL) zfree(weightedNodes);
4689      return result;
4690  invalid_args:
4691      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4692      return 0;
4693  }
4694  static int clusterManagerCommandSetTimeout(int argc, char **argv) {
4695      UNUSED(argc);
4696      int port = 0;
4697      char *ip = NULL;
4698      if (!getClusterHostFromCmdArgs(1, argv, &ip, &port)) goto invalid_args;
4699      int timeout = atoi(argv[1]);
4700      if (timeout < 100) {
4701          fprintf(stderr, "Setting a node timeout of less than 100 "
4702                  "milliseconds is a bad idea.\n");
4703          return 0;
4704      }
4705      clusterManagerNode *node = clusterManagerNewNode(ip, port);
4706      if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
4707      int ok_count = 0, err_count = 0;
4708      clusterManagerLogInfo(">>> Reconfiguring node timeout in every "
4709                            "cluster node...\n");
4710      listIter li;
4711      listNode *ln;
4712      listRewind(cluster_manager.nodes, &li);
4713      while ((ln = listNext(&li)) != NULL) {
4714          clusterManagerNode *n = ln->value;
4715          char *err = NULL;
4716          redisReply *reply = CLUSTER_MANAGER_COMMAND(n, "CONFIG %s %s %d",
4717                                                      "SET",
4718                                                      "cluster-node-timeout",
4719                                                      timeout);
4720          if (reply == NULL) goto reply_err;
4721          int ok = clusterManagerCheckRedisReply(n, reply, &err);
4722          freeReplyObject(reply);
4723          if (!ok) goto reply_err;
4724          reply = CLUSTER_MANAGER_COMMAND(n, "CONFIG %s", "REWRITE");
4725          if (reply == NULL) goto reply_err;
4726          ok = clusterManagerCheckRedisReply(n, reply, &err);
4727          freeReplyObject(reply);
4728          if (!ok) goto reply_err;
4729          clusterManagerLogWarn("*** New timeout set for %s:%d\n", n->ip,
4730                                n->port);
4731          ok_count++;
4732          continue;
4733  reply_err:;
4734          int need_free = 0;
4735          if (err == NULL) err = "";
4736          else need_free = 1;
4737          clusterManagerLogErr("ERR setting node-timeot for %s:%d: %s\n", n->ip,
4738                               n->port, err);
4739          if (need_free) zfree(err);
4740          err_count++;
4741      }
4742      clusterManagerLogInfo(">>> New node timeout set. %d OK, %d ERR.\n",
4743                            ok_count, err_count);
4744      return 1;
4745  invalid_args:
4746      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4747      return 0;
4748  }
4749  static int clusterManagerCommandImport(int argc, char **argv) {
4750      int success = 1;
4751      int port = 0, src_port = 0;
4752      char *ip = NULL, *src_ip = NULL;
4753      char *invalid_args_msg = NULL;
4754      if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) {
4755          invalid_args_msg = CLUSTER_MANAGER_INVALID_HOST_ARG;
4756          goto invalid_args;
4757      }
4758      if (config.cluster_manager_command.from == NULL) {
4759          invalid_args_msg = "[ERR] Option '--cluster-from' is required for "
4760                             "subcommand 'import'.\n";
4761          goto invalid_args;
4762      }
4763      char *src_host[] = {config.cluster_manager_command.from};
4764      if (!getClusterHostFromCmdArgs(1, src_host, &src_ip, &src_port)) {
4765          invalid_args_msg = "[ERR] Invalid --cluster-from host. You need to "
4766                             "pass a valid address (ie. 120.0.0.1:7000).\n";
4767          goto invalid_args;
4768      }
4769      clusterManagerLogInfo(">>> Importing data from %s:%d to cluster %s:%d\n",
4770                            src_ip, src_port, ip, port);
4771      clusterManagerNode *refnode = clusterManagerNewNode(ip, port);
4772      if (!clusterManagerLoadInfoFromNode(refnode, 0)) return 0;
4773      if (!clusterManagerCheckCluster(0)) return 0;
4774      char *reply_err = NULL;
4775      redisReply *src_reply = NULL;
4776      redisContext *src_ctx = redisConnect(src_ip, src_port);
4777      if (src_ctx->err) {
4778          success = 0;
4779          fprintf(stderr,"Could not connect to Redis at %s:%d: %s.\n", src_ip,
4780                  src_port, src_ctx->errstr);
4781          goto cleanup;
4782      }
4783      src_reply = reconnectingRedisCommand(src_ctx, "INFO");
4784      if (!src_reply || src_reply->type == REDIS_REPLY_ERROR) {
4785          if (src_reply && src_reply->str) reply_err = src_reply->str;
4786          success = 0;
4787          goto cleanup;
4788      }
4789      if (getLongInfoField(src_reply->str, "cluster_enabled")) {
4790          clusterManagerLogErr("[ERR] The source node should not be a "
4791                               "cluster node.\n");
4792          success = 0;
4793          goto cleanup;
4794      }
4795      freeReplyObject(src_reply);
4796      src_reply = reconnectingRedisCommand(src_ctx, "DBSIZE");
4797      if (!src_reply || src_reply->type == REDIS_REPLY_ERROR) {
4798          if (src_reply && src_reply->str) reply_err = src_reply->str;
4799          success = 0;
4800          goto cleanup;
4801      }
4802      int size = src_reply->integer, i;
4803      clusterManagerLogWarn("*** Importing %d keys from DB 0\n", size);
4804      clusterManagerNode  *slots_map[CLUSTER_MANAGER_SLOTS];
4805      memset(slots_map, 0, sizeof(slots_map));
4806      listIter li;
4807      listNode *ln;
4808      for (i = 0; i < CLUSTER_MANAGER_SLOTS; i++) {
4809          listRewind(cluster_manager.nodes, &li);
4810          while ((ln = listNext(&li)) != NULL) {
4811              clusterManagerNode *n = ln->value;
4812              if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
4813              if (n->slots_count == 0) continue;
4814              if (n->slots[i]) {
4815                  slots_map[i] = n;
4816                  break;
4817              }
4818          }
4819      }
4820      char cmdfmt[50] = "MIGRATE %s %d %s %d %d";
4821      if (config.cluster_manager_command.flags & CLUSTER_MANAGER_CMD_FLAG_COPY)
4822          strcat(cmdfmt, " %s");
4823      if (config.cluster_manager_command.flags & CLUSTER_MANAGER_CMD_FLAG_REPLACE)
4824          strcat(cmdfmt, " %s");
4825      int cursor = -999, timeout = config.cluster_manager_command.timeout;
4826      while (cursor != 0) {
4827          if (cursor < 0) cursor = 0;
4828          freeReplyObject(src_reply);
4829          src_reply = reconnectingRedisCommand(src_ctx, "SCAN %d COUNT %d",
4830                                               cursor, 1000);
4831          if (!src_reply || src_reply->type == REDIS_REPLY_ERROR) {
4832              if (src_reply && src_reply->str) reply_err = src_reply->str;
4833              success = 0;
4834              goto cleanup;
4835          }
4836          assert(src_reply->type == REDIS_REPLY_ARRAY);
4837          assert(src_reply->elements >= 2);
4838          assert(src_reply->element[1]->type == REDIS_REPLY_ARRAY);
4839          if (src_reply->element[0]->type == REDIS_REPLY_STRING)
4840              cursor = atoi(src_reply->element[0]->str);
4841          else if (src_reply->element[0]->type == REDIS_REPLY_INTEGER)
4842              cursor = src_reply->element[0]->integer;
4843          int keycount = src_reply->element[1]->elements;
4844          for (i = 0; i < keycount; i++) {
4845              redisReply *kr = src_reply->element[1]->element[i];
4846              assert(kr->type == REDIS_REPLY_STRING);
4847              char *key = kr->str;
4848              uint16_t slot = clusterManagerKeyHashSlot(key, kr->len);
4849              clusterManagerNode *target = slots_map[slot];
4850              printf("Migrating %s to %s:%d: ", key, target->ip, target->port);
4851              redisReply *r = reconnectingRedisCommand(src_ctx, cmdfmt,
4852                                                       target->ip, target->port,
4853                                                       key, 0, timeout,
4854                                                       "COPY", "REPLACE");
4855              if (!r || r->type == REDIS_REPLY_ERROR) {
4856                  if (r && r->str) {
4857                      clusterManagerLogErr("Source %s:%d replied with "
4858                                           "error:\n%s\n", src_ip, src_port,
4859                                           r->str);
4860                  }
4861                  success = 0;
4862              }
4863              freeReplyObject(r);
4864              if (!success) goto cleanup;
4865              clusterManagerLogOk("OK\n");
4866          }
4867      }
4868  cleanup:
4869      if (reply_err)
4870          clusterManagerLogErr("Source %s:%d replied with error:\n%s\n",
4871                               src_ip, src_port, reply_err);
4872      if (src_ctx) redisFree(src_ctx);
4873      if (src_reply) freeReplyObject(src_reply);
4874      return success;
4875  invalid_args:
4876      fprintf(stderr, "%s", invalid_args_msg);
4877      return 0;
4878  }
4879  static int clusterManagerCommandCall(int argc, char **argv) {
4880      int port = 0, i;
4881      char *ip = NULL;
4882      if (!getClusterHostFromCmdArgs(1, argv, &ip, &port)) goto invalid_args;
4883      clusterManagerNode *refnode = clusterManagerNewNode(ip, port);
4884      if (!clusterManagerLoadInfoFromNode(refnode, 0)) return 0;
4885      argc--;
4886      argv++;
4887      size_t *argvlen = zmalloc(argc*sizeof(size_t));
4888      clusterManagerLogInfo(">>> Calling");
4889      for (i = 0; i < argc; i++) {
4890          argvlen[i] = strlen(argv[i]);
4891          printf(" %s", argv[i]);
4892      }
4893      printf("\n");
4894      listIter li;
4895      listNode *ln;
4896      listRewind(cluster_manager.nodes, &li);
4897      while ((ln = listNext(&li)) != NULL) {
4898          clusterManagerNode *n = ln->value;
4899          if (!n->context && !clusterManagerNodeConnect(n)) continue;
4900          redisReply *reply = NULL;
4901          redisAppendCommandArgv(n->context, argc, (const char **) argv, argvlen);
4902          int status = redisGetReply(n->context, (void **)(&reply));
4903          if (status != REDIS_OK || reply == NULL )
4904              printf("%s:%d: Failed!\n", n->ip, n->port);
4905          else {
4906              sds formatted_reply = cliFormatReplyRaw(reply);
4907              printf("%s:%d: %s\n", n->ip, n->port, (char *) formatted_reply);
4908              sdsfree(formatted_reply);
4909          }
4910          if (reply != NULL) freeReplyObject(reply);
4911      }
4912      zfree(argvlen);
4913      return 1;
4914  invalid_args:
4915      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4916      return 0;
4917  }
4918  static int clusterManagerCommandHelp(int argc, char **argv) {
4919      UNUSED(argc);
4920      UNUSED(argv);
4921      int commands_count = sizeof(clusterManagerCommands) /
4922                           sizeof(clusterManagerCommandDef);
4923      int i = 0, j;
4924      fprintf(stderr, "Cluster Manager Commands:\n");
4925      int padding = 15;
4926      for (; i < commands_count; i++) {
4927          clusterManagerCommandDef *def = &(clusterManagerCommands[i]);
4928          int namelen = strlen(def->name), padlen = padding - namelen;
4929          fprintf(stderr, "  %s", def->name);
4930          for (j = 0; j < padlen; j++) fprintf(stderr, " ");
4931          fprintf(stderr, "%s\n", (def->args ? def->args : ""));
4932          if (def->options != NULL) {
4933              int optslen = strlen(def->options);
4934              char *p = def->options, *eos = p + optslen;
4935              char *comma = NULL;
4936              while ((comma = strchr(p, ',')) != NULL) {
4937                  int deflen = (int)(comma - p);
4938                  char buf[255];
4939                  memcpy(buf, p, deflen);
4940                  buf[deflen] = '\0';
4941                  for (j = 0; j < padding; j++) fprintf(stderr, " ");
4942                  fprintf(stderr, "  --cluster-%s\n", buf);
4943                  p = comma + 1;
4944                  if (p >= eos) break;
4945              }
4946              if (p < eos) {
4947                  for (j = 0; j < padding; j++) fprintf(stderr, " ");
4948                  fprintf(stderr, "  --cluster-%s\n", p);
4949              }
4950          }
4951      }
4952      fprintf(stderr, "\nFor check, fix, reshard, del-node, set-timeout you "
4953                      "can specify the host and port of any working node in "
4954                      "the cluster.\n\n");
4955      return 0;
4956  }
4957  static void latencyModePrint(PORT_LONGLONG min, PORT_LONGLONG max, double avg, PORT_LONGLONG count) {
4958      if (config.output == OUTPUT_STANDARD) {
4959          printf("min: %lld, max: %lld, avg: %.2f (%lld samples)",
4960                  min, max, avg, count);
4961          fflush(stdout);
4962      } else if (config.output == OUTPUT_CSV) {
4963          printf("%lld,%lld,%.2f,%lld\n", min, max, avg, count);
4964      } else if (config.output == OUTPUT_RAW) {
4965          printf("%lld %lld %.2f %lld\n", min, max, avg, count);
4966      }
4967  }
4968  #define LATENCY_SAMPLE_RATE 10 &bsol;* milliseconds. */
4969  #define LATENCY_HISTORY_DEFAULT_INTERVAL 15000 &bsol;* milliseconds. */
4970  static void latencyMode(void) {
4971      redisReply *reply;
4972      PORT_LONGLONG start, latency, min = 0, max = 0, tot = 0, count = 0;
4973      PORT_LONGLONG history_interval =
4974          config.interval ? config.interval/1000 :
4975                            LATENCY_HISTORY_DEFAULT_INTERVAL;
4976      double avg;
4977      PORT_LONGLONG history_start = mstime();
4978      if (config.interval == 0) {
4979          config.interval = 1000;
4980      } else {
4981          config.interval /= 1000; &bsol;* We need to convert to milliseconds. */
4982      }
4983      if (!context) exit(1);
4984      while(1) {
4985          start = mstime();
4986          reply = reconnectingRedisCommand(context,"PING");
4987          if (reply == NULL) {
4988              fprintf(stderr,"\nI/O error\n");
4989              exit(1);
4990          }
4991          latency = mstime()-start;
4992          freeReplyObject(reply);
4993          count++;
4994          if (count == 1) {
4995              min = max = tot = latency;
4996              avg = (double) latency;
4997          } else {
4998              if (latency < min) min = latency;
4999              if (latency > max) max = latency;
5000              tot += latency;
5001              avg = (double) tot/count;
5002          }
5003          if (config.output == OUTPUT_STANDARD) {
5004              printf("\x1b[0G\x1b[2K"); &bsol;* Clear the line. */
5005              latencyModePrint(min,max,avg,count);
5006          } else {
5007              if (config.latency_history) {
5008                  latencyModePrint(min,max,avg,count);
5009              } else if (mstime()-history_start > config.interval) {
5010                  latencyModePrint(min,max,avg,count);
5011                  exit(0);
5012              }
5013          }
5014          if (config.latency_history && mstime()-history_start > history_interval)
5015          {
5016              printf(" -- %.2f seconds range\n", (float)(mstime()-history_start)/1000);
5017              history_start = mstime();
5018              min = max = tot = count = 0;
5019          }
5020          usleep(LATENCY_SAMPLE_RATE * 1000);
5021      }
5022  }
5023  #define LATENCY_DIST_DEFAULT_INTERVAL 1000 &bsol;* milliseconds. */
5024  struct distsamples {
5025      PORT_LONGLONG max;   &bsol;* Max latency to fit into this interval (usec). */
5026      PORT_LONGLONG count; &bsol;* Number of samples in this interval. */
5027      int character;   &bsol;* Associated character in visualization. */
5028  };
5029  void showLatencyDistSamples(struct distsamples *samples, PORT_LONGLONG tot) {
5030      int j;
5031      printf("\033[38;5;0m"); &bsol;* Set foreground color to black. */
5032      for (j = 0; ; j++) {
5033          int coloridx =
5034              (int) ceil((float) samples[j].count / tot * (spectrum_palette_size-1));  WIN_PORT_FIX &bsol;* cast (int) */
5035          int color = spectrum_palette[coloridx];
5036          printf("\033[48;5;%dm%c", (int)color, samples[j].character);
5037          samples[j].count = 0;
5038          if (samples[j].max == 0) break; &bsol;* Last sample. */
5039      }
5040      printf("\033[0m\n");
5041      fflush(stdout);
5042  }
5043  void showLatencyDistLegend(void) {
5044      int j;
5045      printf("---------------------------------------------\n");
5046      printf(". - * #          .01 .125 .25 .5 milliseconds\n");
5047      printf("1,2,3,...,9      from 1 to 9     milliseconds\n");
5048      printf("A,B,C,D,E        10,20,30,40,50  milliseconds\n");
5049      printf("F,G,H,I,J        .1,.2,.3,.4,.5       seconds\n");
5050      printf("K,L,M,N,O,P,Q,?  1,2,4,8,16,30,60,>60 seconds\n");
5051      printf("From 0 to 100%%: ");
5052      for (j = 0; j < spectrum_palette_size; j++) {
5053          printf("\033[48;5;%dm ", spectrum_palette[j]);
5054      }
5055      printf("\033[0m\n");
5056      printf("---------------------------------------------\n");
5057  }
5058  static void latencyDistMode(void) {
5059      redisReply *reply;
5060      PORT_LONGLONG start, latency, count = 0;
5061      PORT_LONGLONG history_interval =
5062          config.interval ? config.interval/1000 :
5063                            LATENCY_DIST_DEFAULT_INTERVAL;
5064      PORT_LONGLONG history_start = ustime();
5065      int j, outputs = 0;
5066      struct distsamples samples[] = {
5067          {10,0,'.'},         &bsol;* 0.01 ms */
5068          {125,0,'-'},        &bsol;* 0.125 ms */
5069          {250,0,'*'},        &bsol;* 0.25 ms */
5070          {500,0,'#'},        &bsol;* 0.5 ms */
5071          {1000,0,'1'},       &bsol;* 1 ms */
5072          {2000,0,'2'},       &bsol;* 2 ms */
5073          {3000,0,'3'},       &bsol;* 3 ms */
5074          {4000,0,'4'},       &bsol;* 4 ms */
5075          {5000,0,'5'},       &bsol;* 5 ms */
5076          {6000,0,'6'},       &bsol;* 6 ms */
5077          {7000,0,'7'},       &bsol;* 7 ms */
5078          {8000,0,'8'},       &bsol;* 8 ms */
5079          {9000,0,'9'},       &bsol;* 9 ms */
5080          {10000,0,'A'},      &bsol;* 10 ms */
5081          {20000,0,'B'},      &bsol;* 20 ms */
5082          {30000,0,'C'},      &bsol;* 30 ms */
5083          {40000,0,'D'},      &bsol;* 40 ms */
5084          {50000,0,'E'},      &bsol;* 50 ms */
5085          {100000,0,'F'},     &bsol;* 0.1 s */
5086          {200000,0,'G'},     &bsol;* 0.2 s */
5087          {300000,0,'H'},     &bsol;* 0.3 s */
5088          {400000,0,'I'},     &bsol;* 0.4 s */
5089          {500000,0,'J'},     &bsol;* 0.5 s */
5090          {1000000,0,'K'},    &bsol;* 1 s */
5091          {2000000,0,'L'},    &bsol;* 2 s */
5092          {4000000,0,'M'},    &bsol;* 4 s */
5093          {8000000,0,'N'},    &bsol;* 8 s */
5094          {16000000,0,'O'},   &bsol;* 16 s */
5095          {30000000,0,'P'},   &bsol;* 30 s */
5096          {60000000,0,'Q'},   &bsol;* 1 minute */
5097          {0,0,'?'},          &bsol;* > 1 minute */
5098      };
5099      if (!context) exit(1);
5100      while(1) {
5101          start = ustime();
5102          reply = reconnectingRedisCommand(context,"PING");
5103          if (reply == NULL) {
5104              fprintf(stderr,"\nI/O error\n");
5105              exit(1);
5106          }
5107          latency = ustime()-start;
5108          freeReplyObject(reply);
5109          count++;
5110          for (j = 0; ; j++) {
5111              if (samples[j].max == 0 || latency <= samples[j].max) {
5112                  samples[j].count++;
5113                  break;
5114              }
5115          }
5116          if (count && (ustime()-history_start)/1000 > history_interval) {
5117              if ((outputs++ % 20) == 0)
5118                  showLatencyDistLegend();
5119              showLatencyDistSamples(samples,count);
5120              history_start = ustime();
5121              count = 0;
5122          }
5123          usleep(LATENCY_SAMPLE_RATE * 1000);
5124      }
5125  }
5126  PORT_ULONGLONG sendSync(int fd) {
5127      char buf[4096], *p;
5128      ssize_t nread;
5129      if (write(fd,"SYNC\r\n",6) != 6) {
5130          fprintf(stderr,"Error writing to master\n");
5131          exit(1);
5132      }
5133      p = buf;
5134      while(1) {
5135          nread = read(fd,p,1);
5136          if (nread <= 0) {
5137              fprintf(stderr,"Error reading bulk length while SYNCing\n");
5138              exit(1);
5139          }
5140          if (*p == '\n' && p != buf) break;
5141          if (*p != '\n') p++;
5142      }
5143      *p = '\0';
5144      if (buf[0] == '-') {
5145          printf("SYNC with master failed: %s\n", buf);
5146          exit(1);
5147      }
5148      return strtoull(buf+1,NULL,10);
5149  }
5150  static void slaveMode(void) {
5151      int fd = context->fd;
5152      PORT_ULONGLONG payload = sendSync(fd);
5153      char buf[1024];
5154      int original_output = config.output;
5155      fprintf(stderr,"SYNC with master, discarding %llu "
5156                     "bytes of bulk transfer...\n", payload);
5157      while(payload) {
5158          ssize_t nread;
5159          nread = read(fd,buf,(payload > sizeof(buf)) ? sizeof(buf) : payload);
5160          if (nread <= 0) {
5161              fprintf(stderr,"Error reading RDB payload while SYNCing\n");
5162              exit(1);
5163          }
5164          payload -= nread;
5165      }
5166      fprintf(stderr,"SYNC done. Logging commands from master.\n");
5167      config.output = OUTPUT_CSV;
5168      while (cliReadReply(0) == REDIS_OK);
5169      config.output = original_output;
5170  }
5171  static void getRDB(void) {
5172      int s = context->fd;
5173      int fd;
5174      PORT_ULONGLONG payload = sendSync(s);
5175      char buf[4096];
5176      fprintf(stderr,"SYNC sent to master, writing %llu bytes to '%s'\n",
5177          payload, config.rdb_filename);
5178      if (!strcmp(config.rdb_filename,"-")) {
5179          fd = STDOUT_FILENO;
5180      } else {
5181          fd = open(config.rdb_filename, O_CREAT|O_WRONLY, 0644);
5182          if (fd == -1) {
5183              fprintf(stderr, "Error opening '%s': %s\n", config.rdb_filename,
5184                  strerror(errno));
5185              exit(1);
5186          }
5187      }
5188      while(payload) {
5189          ssize_t nread, nwritten;
5190          nread = read(s,buf,(payload > sizeof(buf)) ? sizeof(buf) : payload);
5191          if (nread <= 0) {
5192              fprintf(stderr,"I/O Error reading RDB payload from socket\n");
5193              exit(1);
5194          }
5195          nwritten = write(fd, buf, nread);
5196          if (nwritten != nread) {
5197              fprintf(stderr,"Error writing data to file: %s\n",
5198                  (nwritten == -1) ? IF_WIN32(wsa_strerror(errno), strerror(errno)) : "short write");
5199              exit(1);
5200          }
5201          payload -= nread;
5202      }
5203      close(s); &bsol;* Close the file descriptor ASAP as fsync() may take time. */
5204      fsync(fd);
5205      close(fd);
5206      fprintf(stderr,"Transfer finished with success.\n");
5207      exit(0);
5208  }
5209  #define PIPEMODE_WRITE_LOOP_MAX_BYTES (128*1024)
5210  static void pipeMode(void) {
5211      int fd = (int)context->fd;
5212      PORT_LONGLONG errors = 0, replies = 0, obuf_len = 0, obuf_pos = 0;
5213      char ibuf[1024*16], obuf[1024*16]; &bsol;* Input and output buffers */
5214      char aneterr[ANET_ERR_LEN];
5215      redisReader *reader = redisReaderCreate();
5216      redisReply *reply;
5217      int eof = 0; &bsol;* True once we consumed all the standard input. */
5218      int done = 0;
5219      char magic[20]; &bsol;* Special reply we recognize. */
5220      time_t last_read_time = time(NULL);
5221  #ifdef _WIN32
5222      setmode(STDIN_FILENO, _O_BINARY);
5223  #endif
5224      srand((unsigned int) time(NULL));                                            WIN_PORT_FIX &bsol;* cast unsigned int */
5225      if (anetNonBlock(aneterr,fd) == ANET_ERR) {
5226          fprintf(stderr, "Can't set the socket in non blocking mode: %s\n",
5227              aneterr);
5228          exit(1);
5229      }
5230      while(!done) {
5231          int mask = AE_READABLE;
5232          if (!eof || obuf_len != 0) mask |= AE_WRITABLE;
5233          mask = aeWait(fd,mask,1000);
5234          if (mask & AE_READABLE) {
5235              ssize_t nread;
5236              int read_error = 0;
5237              do {
5238                  nread = read(fd,ibuf,sizeof(ibuf));
5239                  if (nread == -1 && errno != EAGAIN && errno != EINTR) {
5240                      fprintf(stderr, "Error reading from the server: %s\n",
5241                          strerror(errno));
5242                      read_error = 1;
5243                      break;
5244                  }
5245                  if (nread > 0) {
5246                      redisReaderFeed(reader,ibuf,nread);
5247                      last_read_time = time(NULL);
5248                  }
5249              } while(nread > 0);
5250              do {
5251                  if (redisReaderGetReply(reader,(void**)&reply) == REDIS_ERR) {
5252                      fprintf(stderr, "Error reading replies from server\n");
5253                      exit(1);
5254                  }
5255                  if (reply) {
5256                      if (reply->type == REDIS_REPLY_ERROR) {
5257                          fprintf(stderr,"%s\n", reply->str);
5258                          errors++;
5259                      } else if (eof && reply->type == REDIS_REPLY_STRING &&
5260                                        reply->len == 20) {
5261                          if (memcmp(reply->str,magic,20) == 0) {
5262                              printf("Last reply received from server.\n");
5263                              done = 1;
5264                              replies--;
5265                          }
5266                      }
5267                      replies++;
5268                      freeReplyObject(reply);
5269                  }
5270              } while(reply);
5271              if (read_error) exit(1);
5272          }
5273          if (mask & AE_WRITABLE) {
5274              ssize_t loop_nwritten = 0;
5275              while(1) {
5276                  if (obuf_len != 0) {
5277                      ssize_t nwritten = write(fd,obuf+obuf_pos,obuf_len);
5278                      if (nwritten == -1) {
5279                          if (errno != EAGAIN && errno != EINTR) {
5280                              fprintf(stderr, "Error writing to the server: %s\n",
5281                                  strerror(errno));
5282                              exit(1);
5283                          } else {
5284                              nwritten = 0;
5285                          }
5286                      }
5287                      obuf_len -= nwritten;
5288                      obuf_pos += nwritten;
5289                      loop_nwritten += nwritten;
5290                      if (obuf_len != 0) break; &bsol;* Can't accept more data. */
5291                  }
5292                  if (obuf_len == 0 && !eof) {
5293                      ssize_t nread = read(STDIN_FILENO,obuf,sizeof(obuf));
5294                      if (nread == 0) {
5295                          char echo[] =
5296                          "\r\n*2\r\n$4\r\nECHO\r\n$20\r\n01234567890123456789\r\n";
5297                          int j;
5298                          eof = 1;
5299                          for (j = 0; j < 20; j++)
5300                              magic[j] = rand() & 0xff;
5301                          memcpy(echo+21,magic,20);
5302                          memcpy(obuf,echo,sizeof(echo)-1);
5303                          obuf_len = sizeof(echo)-1;
5304                          obuf_pos = 0;
5305                          printf("All data transferred. Waiting for the last reply...\n");
5306                      } else if (nread == -1) {
5307                          fprintf(stderr, "Error reading from stdin: %s\n",
5308                              strerror(errno));
5309                          exit(1);
5310                      } else {
5311                          obuf_len = nread;
5312                          obuf_pos = 0;
5313                      }
5314                  }
5315                  if ((obuf_len == 0 && eof) ||
5316                      loop_nwritten > PIPEMODE_WRITE_LOOP_MAX_BYTES) break;
5317              }
5318          }
5319          if (eof && config.pipe_timeout > 0 &&
5320              time(NULL)-last_read_time > config.pipe_timeout)
5321          {
5322              fprintf(stderr,"No replies for %d seconds: exiting.\n",
5323                  config.pipe_timeout);
5324              errors++;
5325              break;
5326          }
5327      }
5328      redisReaderFree(reader);
5329      printf("errors: %lld, replies: %lld\n", errors, replies);
5330      if (errors)
5331          exit(1);
5332      else
5333          exit(0);
5334  }
5335  static redisReply *sendScan(PORT_ULONGLONG *it) {
5336      redisReply *reply = redisCommand(context, "SCAN %llu", *it);
5337      if(reply == NULL) {
5338          fprintf(stderr, "\nI/O error\n");
5339          exit(1);
5340      } else if(reply->type == REDIS_REPLY_ERROR) {
5341          fprintf(stderr, "SCAN error: %s\n", reply->str);
5342          exit(1);
5343      } else if(reply->type != REDIS_REPLY_ARRAY) {
5344          fprintf(stderr, "Non ARRAY response from SCAN!\n");
5345          exit(1);
5346      } else if(reply->elements != 2) {
5347          fprintf(stderr, "Invalid element count from SCAN!\n");
5348          exit(1);
5349      }
5350      assert(reply->element[0]->type == REDIS_REPLY_STRING);
5351      assert(reply->element[1]->type == REDIS_REPLY_ARRAY);
5352      *it = strtoull(reply->element[0]->str, NULL, 10);
5353      return reply;
5354  }
5355  static int getDbSize(void) {
5356      redisReply *reply;
5357      int size;
5358      reply = redisCommand(context, "DBSIZE");
5359      if(reply == NULL || reply->type != REDIS_REPLY_INTEGER) {
5360          fprintf(stderr, "Couldn't determine DBSIZE!\n");
5361          exit(1);
5362      }
5363      size = reply->integer;
5364      freeReplyObject(reply);
5365      return size;
5366  }
5367  typedef struct {
5368      char *name;
5369      char *sizecmd;
5370      char *sizeunit;
5371      PORT_ULONGLONG biggest;
5372      PORT_ULONGLONG count;
5373      PORT_ULONGLONG totalsize;
5374      sds biggest_key;
5375  } typeinfo;
5376  typeinfo type_string = { "string", "STRLEN", "bytes" };
5377  typeinfo type_list = { "list", "LLEN", "items" };
5378  typeinfo type_set = { "set", "SCARD", "members" };
5379  typeinfo type_hash = { "hash", "HLEN", "fields" };
5380  typeinfo type_zset = { "zset", "ZCARD", "members" };
5381  typeinfo type_stream = { "stream", "XLEN", "entries" };
5382  typeinfo type_other = { "other", NULL, "?" };
5383  static typeinfo* typeinfo_add(dict *types, char* name, typeinfo* type_template) {
5384      typeinfo *info = zmalloc(sizeof(typeinfo));
5385      *info = *type_template;
5386      info->name = sdsnew(name);
5387      dictAdd(types, info->name, info);
5388      return info;
5389  }
5390  void type_free(void* priv_data, void* val) {
5391      typeinfo *info = val;
5392      UNUSED(priv_data);
5393      if (info->biggest_key)
5394          sdsfree(info->biggest_key);
5395      sdsfree(info->name);
5396      zfree(info);
5397  }
5398  static dictType typeinfoDictType = {
5399      dictSdsHash,               &bsol;* hash function */
5400      NULL,                      &bsol;* key dup */
5401      NULL,                      &bsol;* val dup */
5402      dictSdsKeyCompare,         &bsol;* key compare */
5403      NULL,                      &bsol;* key destructor (owned by the value)*/
5404      type_free                  &bsol;* val destructor */
5405  };
5406  static void getKeyTypes(dict *types_dict, redisReply *keys, typeinfo **types) {
5407      redisReply *reply;
5408      unsigned int i;
5409      for(i=0;i<keys->elements;i++) {
5410          redisAppendCommand(context, "TYPE %s", keys->element[i]->str);
5411      }
5412      for(i=0;i<keys->elements;i++) {
5413          if(redisGetReply(context, (void**)&reply)!=REDIS_OK) {
5414              fprintf(stderr, "Error getting type for key '%s' (%d: %s)\n",
5415                  keys->element[i]->str, context->err, context->errstr);
5416              exit(1);
5417          } else if(reply->type != REDIS_REPLY_STATUS) {
5418              if(reply->type == REDIS_REPLY_ERROR) {
5419                  fprintf(stderr, "TYPE returned an error: %s\n", reply->str);
5420              } else {
5421                  fprintf(stderr,
5422                      "Invalid reply type (%d) for TYPE on key '%s'!\n",
5423                      reply->type, keys->element[i]->str);
5424              }
5425              exit(1);
5426          }
5427          sds typereply = sdsnew(reply->str);
5428          dictEntry *de = dictFind(types_dict, typereply);
5429          sdsfree(typereply);
5430          typeinfo *type = NULL;
5431          if (de)
5432              type = dictGetVal(de);
5433          else if (strcmp(reply->str, "none")) &bsol;* create new types for modules, (but not for deleted keys) */
5434              type = typeinfo_add(types_dict, reply->str, &type_other);
5435          types[i] = type;
5436          freeReplyObject(reply);
5437      }
5438  }
5439  static void getKeySizes(redisReply *keys, typeinfo **types,
5440                          PORT_ULONGLONG *sizes, int memkeys,
5441                          unsigned memkeys_samples)
5442  {
5443      redisReply *reply;
5444      unsigned int i;
5445      for(i=0;i<keys->elements;i++) {
5446          if(!types[i] || (!types[i]->sizecmd && !memkeys))
5447              continue;
5448          if (!memkeys)
5449              redisAppendCommand(context, "%s %s",
5450                  types[i]->sizecmd, keys->element[i]->str);
5451          else if (memkeys_samples==0)
5452              redisAppendCommand(context, "%s %s %s",
5453                  "MEMORY", "USAGE", keys->element[i]->str);
5454          else
5455              redisAppendCommand(context, "%s %s %s SAMPLES %u",
5456                  "MEMORY", "USAGE", keys->element[i]->str, memkeys_samples);
5457      }
5458      for(i=0;i<keys->elements;i++) {
5459          if(!types[i] || (!types[i]->sizecmd && !memkeys)) {
5460              sizes[i] = 0;
5461              continue;
5462          }
5463          if(redisGetReply(context, (void**)&reply)!=REDIS_OK) {
5464              fprintf(stderr, "Error getting size for key '%s' (%d: %s)\n",
5465                  keys->element[i]->str, context->err, context->errstr);
5466              exit(1);
5467          } else if(reply->type != REDIS_REPLY_INTEGER) {
5468              fprintf(stderr,
5469                  "Warning:  %s on '%s' failed (may have changed type)\n",
5470                  !memkeys? types[i]->sizecmd: "MEMORY USAGE",
5471                  keys->element[i]->str);
5472              sizes[i] = 0;
5473          } else {
5474              sizes[i] = reply->integer;
5475          }
5476          freeReplyObject(reply);
5477      }
5478  }
5479  static void findBigKeys(int memkeys, unsigned memkeys_samples) {
5480      PORT_ULONGLONG sampled = 0, total_keys, totlen=0, *sizes=NULL, it=0;
5481      redisReply *reply, *keys;
5482      unsigned int arrsize=0, i;
5483      dictIterator *di;
5484      dictEntry *de;
5485      typeinfo **types = NULL;
5486      double pct;
5487      dict *types_dict = dictCreate(&typeinfoDictType, NULL);
5488      typeinfo_add(types_dict, "string", &type_string);
5489      typeinfo_add(types_dict, "list", &type_list);
5490      typeinfo_add(types_dict, "set", &type_set);
5491      typeinfo_add(types_dict, "hash", &type_hash);
5492      typeinfo_add(types_dict, "zset", &type_zset);
5493      typeinfo_add(types_dict, "stream", &type_stream);
5494      total_keys = getDbSize();
5495      printf("\n# Scanning the entire keyspace to find biggest keys as well as\n");
5496      printf("# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\n");
5497      printf("# per 100 SCAN commands (not usually needed).\n\n");
5498      do {
5499          pct = 100 * (double)sampled/total_keys;
5500          reply = sendScan(&it);
5501          keys  = reply->element[1];
5502          if(keys->elements > arrsize) {
5503              types = zrealloc(types, sizeof(typeinfo*)*keys->elements);
5504              sizes = zrealloc(sizes, sizeof(PORT_ULONGLONG)*keys->elements);
5505              if(!types || !sizes) {
5506                  fprintf(stderr, "Failed to allocate storage for keys!\n");
5507                  exit(1);
5508              }
5509              arrsize = keys->elements;
5510          }
5511          getKeyTypes(types_dict, keys, types);
5512          getKeySizes(keys, types, sizes, memkeys, memkeys_samples);
5513          for(i=0;i<keys->elements;i++) {
5514              typeinfo *type = types[i];
5515              if(!type)
5516                  continue;
5517              type->totalsize += sizes[i];
5518              type->count++;
5519              totlen += keys->element[i]->len;
5520              sampled++;
5521              if(type->biggest<sizes[i]) {
5522                  printf(
5523                     "[%05.2f%%] Biggest %-6s found so far '%s' with %llu %s\n",
5524                     pct, type->name, keys->element[i]->str, sizes[i],
5525                     !memkeys? type->sizeunit: "bytes");
5526                  if (type->biggest_key)
5527                      sdsfree(type->biggest_key);
5528                  type->biggest_key = sdsnew(keys->element[i]->str);
5529                  if(!type->biggest_key) {
5530                      fprintf(stderr, "Failed to allocate memory for key!\n");
5531                      exit(1);
5532                  }
5533                  type->biggest = sizes[i];
5534              }
5535              if(sampled % 1000000 == 0) {
5536                  printf("[%05.2f%%] Sampled %llu keys so far\n", pct, sampled);
5537              }
5538          }
5539          if(sampled && (sampled %100) == 0 && config.interval) {
5540              usleep(config.interval);
5541          }
5542          freeReplyObject(reply);
5543      } while(it != 0);
5544      if(types) zfree(types);
5545      if(sizes) zfree(sizes);
5546      printf("\n-------- summary -------\n\n");
5547      printf("Sampled %llu keys in the keyspace!\n", sampled);
5548      printf("Total key length in bytes is %llu (avg len %.2f)\n\n",
5549         totlen, totlen ? (double)totlen/sampled : 0);
5550      di = dictGetIterator(types_dict);
5551      while ((de = dictNext(di))) {
5552          typeinfo *type = dictGetVal(de);
5553          if(type->biggest_key) {
5554              printf("Biggest %6s found '%s' has %llu %s\n", type->name, type->biggest_key,
5555                 type->biggest, !memkeys? type->sizeunit: "bytes");
5556          }
5557      }
5558      dictReleaseIterator(di);
5559      printf("\n");
5560      di = dictGetIterator(types_dict);
5561      while ((de = dictNext(di))) {
5562          typeinfo *type = dictGetVal(de);
5563          printf("%llu %ss with %llu %s (%05.2f%% of keys, avg size %.2f)\n",
5564             type->count, type->name, type->totalsize, !memkeys? type->sizeunit: "bytes",
5565             sampled ? 100 * (double)type->count/sampled : 0,
5566             type->count ? (double)type->totalsize/type->count : 0);
5567      }
5568      dictReleaseIterator(di);
5569      dictRelease(types_dict);
5570      exit(0);
5571  }
5572  static void getKeyFreqs(redisReply *keys, PORT_ULONGLONG *freqs) {
5573      redisReply *reply;
5574      unsigned int i;
5575      for(i=0;i<keys->elements;i++) {
5576          redisAppendCommand(context, "OBJECT freq %s", keys->element[i]->str);
5577      }
5578      for(i=0;i<keys->elements;i++) {
5579          if(redisGetReply(context, (void**)&reply)!=REDIS_OK) {
5580              fprintf(stderr, "Error getting freq for key '%s' (%d: %s)\n",
5581                  keys->element[i]->str, context->err, context->errstr);
5582              exit(1);
5583          } else if(reply->type != REDIS_REPLY_INTEGER) {
5584              if(reply->type == REDIS_REPLY_ERROR) {
5585                  fprintf(stderr, "Error: %s\n", reply->str);
5586                  exit(1);
5587              } else {
5588                  fprintf(stderr, "Warning: OBJECT freq on '%s' failed (may have been deleted)\n", keys->element[i]->str);
5589                  freqs[i] = 0;
5590              }
5591          } else {
5592              freqs[i] = reply->integer;
5593          }
5594          freeReplyObject(reply);
5595      }
5596  }
5597  #define HOTKEYS_SAMPLE 16
5598  static void findHotKeys(void) {
5599      redisReply *keys, *reply;
5600      PORT_ULONGLONG counters[HOTKEYS_SAMPLE] = {0};
5601      sds hotkeys[HOTKEYS_SAMPLE] = {NULL};
5602      PORT_ULONGLONG sampled = 0, total_keys, *freqs = NULL, it = 0;
5603      unsigned int arrsize = 0, i, k;
5604      double pct;
5605      total_keys = getDbSize();
5606      printf("\n# Scanning the entire keyspace to find hot keys as well as\n");
5607      printf("# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\n");
5608      printf("# per 100 SCAN commands (not usually needed).\n\n");
5609      do {
5610          pct = 100 * (double)sampled/total_keys;
5611          reply = sendScan(&it);
5612          keys  = reply->element[1];
5613          if(keys->elements > arrsize) {
5614              freqs = zrealloc(freqs, sizeof(PORT_ULONGLONG)*keys->elements);
5615              if(!freqs) {
5616                  fprintf(stderr, "Failed to allocate storage for keys!\n");
5617                  exit(1);
5618              }
5619              arrsize = keys->elements;
5620          }
5621          getKeyFreqs(keys, freqs);
5622          for(i=0;i<keys->elements;i++) {
5623              sampled++;
5624              if(sampled % 1000000 == 0) {
5625                  printf("[%05.2f%%] Sampled %llu keys so far\n", pct, sampled);
5626              }
5627              k = 0;
5628              while (k < HOTKEYS_SAMPLE && freqs[i] > counters[k]) k++;
5629              if (k == 0) continue;
5630              k--;
5631              if (k == 0 || counters[k] == 0) {
5632                  sdsfree(hotkeys[k]);
5633              } else {
5634                  sdsfree(hotkeys[0]);
5635                  memmove(counters,counters+1,sizeof(counters[0])*k);
5636                  memmove(hotkeys,hotkeys+1,sizeof(hotkeys[0])*k);
5637              }
5638              counters[k] = freqs[i];
5639              hotkeys[k] = sdsnew(keys->element[i]->str);
5640              printf(
5641                 "[%05.2f%%] Hot key '%s' found so far with counter %llu\n",
5642                 pct, keys->element[i]->str, freqs[i]);
5643          }
5644          if(sampled && (sampled %100) == 0 && config.interval) {
5645              usleep(config.interval);
5646          }
5647          freeReplyObject(reply);
5648      } while(it != 0);
5649      if (freqs) zfree(freqs);
5650      printf("\n-------- summary -------\n\n");
5651      printf("Sampled %llu keys in the keyspace!\n", sampled);
5652      for (i=1; i<= HOTKEYS_SAMPLE; i++) {
5653          k = HOTKEYS_SAMPLE - i;
5654          if(counters[k]>0) {
5655              printf("hot key found with counter: %llu\tkeyname: %s\n", counters[k], hotkeys[k]);
5656              sdsfree(hotkeys[k]);
5657          }
5658      }
5659      exit(0);
5660  }
5661  static char *getInfoField(char *info, char *field) {
5662      char *p = strstr(info,field);
5663      char *n1, *n2;
5664      char *result;
5665      if (!p) return NULL;
5666      p += strlen(field)+1;
5667      n1 = strchr(p,'\r');
5668      n2 = strchr(p,',');
5669      if (n2 && n2 < n1) n1 = n2;
5670      result = zmalloc(sizeof(char)*(n1-p)+1);
5671      memcpy(result,p,(n1-p));
5672      result[n1-p] = '\0';
5673      return result;
5674  }
5675  static PORT_LONG getLongInfoField(char *info, char *field) {
5676      char *value = getInfoField(info,field);
5677      PORT_LONG l;
5678      if (!value) return PORT_LONG_MIN;
5679      l = strtol(value,NULL,10);
5680      zfree(value);
5681      return l;
5682  }
5683  void bytesToHuman(char *s, PORT_LONGLONG n) {
5684      double d;
5685      if (n < 0) {
5686          *s = '-';
5687          s++;
5688          n = -n;
5689      }
5690      if (n < 1024) {
5691          sprintf(s,"%lldB",n);
5692          return;
5693      } else if (n < (1024*1024)) {
5694          d = (double)n/(1024);
5695          sprintf(s,"%.2fK",d);
5696      } else if (n < (1024LL*1024*1024)) {
5697          d = (double)n/((double)1024*1024);
5698          sprintf(s,"%.2fM",d);
5699      } else if (n < (1024LL*1024*1024*1024)) {
5700          d = (double)n/(1024LL*1024*1024);
5701          sprintf(s,"%.2fG",d);
5702      }
5703  }
5704  static void statMode(void) {
5705      redisReply *reply;
5706      PORT_LONG aux, requests = 0;
5707      int i = 0;
5708      while(1) {
5709          char buf[64];
5710          int j;
5711          reply = reconnectingRedisCommand(context,"INFO");
5712          if (reply->type == REDIS_REPLY_ERROR) {
5713              printf("ERROR: %s\n", reply->str);
5714              exit(1);
5715          }
5716          if ((i++ % 20) == 0) {
5717              printf(
5718  "------- data ------ --------------------- load -------------------- - child -\n"
5719  "keys       mem      clients blocked requests            connections          \n");
5720          }
5721          aux = 0;
5722          for (j = 0; j < 20; j++) {
5723              PORT_LONG k;
5724              sprintf(buf,"db%d:keys",j);
5725              k = getLongInfoField(reply->str,buf);
5726              if (k == PORT_LONG_MIN) continue;
5727              aux += k;
5728          }
5729          sprintf(buf,"%Id",aux);                                      WIN_PORT_FIX &bsol;* %ld -> %Id */
5730          printf("%-11s",buf);
5731          aux = getLongInfoField(reply->str,"used_memory");
5732          bytesToHuman(buf,aux);
5733          printf("%-8s",buf);
5734          aux = getLongInfoField(reply->str,"connected_clients");
5735          sprintf(buf,"%Id",aux);                                      WIN_PORT_FIX &bsol;* %ld -> %Id */
5736          printf(" %-8s",buf);
5737          aux = getLongInfoField(reply->str,"blocked_clients");
5738          sprintf(buf,"%Id",aux);                                      WIN_PORT_FIX &bsol;* %ld -> %Id */
5739          printf("%-8s",buf);
5740          aux = getLongInfoField(reply->str,"total_commands_processed");
5741          sprintf(buf,"%Id (+%Id)",aux,requests == 0 ? 0 : aux-requests);  WIN_PORT_FIX &bsol;* %ld -> %Id */
5742          printf("%-19s",buf);
5743          requests = aux;
5744          aux = getLongInfoField(reply->str,"total_connections_received");
5745          sprintf(buf,"%Id",aux);                                       WIN_PORT_FIX &bsol;* %ld -> %Id */
5746          printf(" %-12s",buf);
5747          aux = getLongInfoField(reply->str,"bgsave_in_progress");
5748          aux |= getLongInfoField(reply->str,"aof_rewrite_in_progress") << 1;
5749          aux |= getLongInfoField(reply->str,"loading") << 2;
5750          switch(aux) {
5751          case 0: break;
5752          case 1:
5753              printf("SAVE");
5754              break;
5755          case 2:
5756              printf("AOF");
5757              break;
5758          case 3:
5759              printf("SAVE+AOF");
5760              break;
5761          case 4:
5762              printf("LOAD");
5763              break;
5764          }
5765          printf("\n");
5766          freeReplyObject(reply);
5767          usleep(config.interval);
5768      }
5769  }
5770  static void scanMode(void) {
5771      redisReply *reply;
5772      PORT_ULONGLONG cur = 0;
5773      do {
5774          if (config.pattern)
5775              reply = redisCommand(context,"SCAN %llu MATCH %s",
5776                  cur,config.pattern);
5777          else
5778              reply = redisCommand(context,"SCAN %llu",cur);
5779          if (reply == NULL) {
5780              printf("I/O error\n");
5781              exit(1);
5782          } else if (reply->type == REDIS_REPLY_ERROR) {
5783              printf("ERROR: %s\n", reply->str);
5784              exit(1);
5785          } else {
5786              unsigned int j;
5787              cur = strtoull(reply->element[0]->str,NULL,10);
5788              for (j = 0; j < reply->element[1]->elements; j++)
5789                  printf("%s\n", reply->element[1]->element[j]->str);
5790          }
5791          freeReplyObject(reply);
5792      } while(cur != 0);
5793      exit(0);
5794  }
5795  PORT_LONGLONG powerLawRand(PORT_LONGLONG min, PORT_LONGLONG max, double alpha) {
5796      double pl, r;
5797      max += 1;
5798      r = ((double)rand()) / RAND_MAX;
5799      pl = pow(
5800          ((pow((double)max,alpha+1) - pow((double)min,alpha+1))*r + pow((double)min,alpha+1)), WIN_PORT_FIX &bsol;* cast (double) */
5801          (1.0/(alpha+1)));
5802      return (max-1-(PORT_LONGLONG)pl)+min;
5803  }
5804  void LRUTestGenKey(char *buf, size_t buflen) {
5805      snprintf(buf, buflen, "lru:%lld",
5806          powerLawRand(1, config.lru_test_sample_size, 6.2));
5807  }
5808  #define LRU_CYCLE_PERIOD 1000 &bsol;* 1000 milliseconds. */
5809  #define LRU_CYCLE_PIPELINE_SIZE 250
5810  static void LRUTestMode(void) {
5811      redisReply *reply;
5812      char key[128];
5813      PORT_LONGLONG start_cycle;
5814      int j;
5815      srand((unsigned int)(time(NULL)^getpid()));                                   WIN_PORT_FIX &bsol;* cast (unsigned int) */
5816      while(1) {
5817          start_cycle = mstime();
5818          PORT_LONGLONG hits = 0, misses = 0;
5819          while(mstime() - start_cycle < 1000) {
5820              for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++) {
5821                  char val[6];
5822                  val[5] = '\0';
5823                  for (int i = 0; i < 5; i++) val[i] = 'A'+rand()%('z'-'A');
5824                  LRUTestGenKey(key,sizeof(key));
5825                  redisAppendCommand(context, "SET %s %s",key,val);
5826              }
5827              for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++)
5828                  redisGetReply(context, (void**)&reply);
5829              for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++) {
5830                  LRUTestGenKey(key,sizeof(key));
5831                  redisAppendCommand(context, "GET %s",key);
5832              }
5833              for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++) {
5834                  if (redisGetReply(context, (void**)&reply) == REDIS_OK) {
5835                      switch(reply->type) {
5836                          case REDIS_REPLY_ERROR:
5837                              printf("%s\n", reply->str);
5838                              break;
5839                          case REDIS_REPLY_NIL:
5840                              misses++;
5841                              break;
5842                          default:
5843                              hits++;
5844                              break;
5845                      }
5846                  }
5847              }
5848              if (context->err) {
5849                  fprintf(stderr,"I/O error during LRU test\n");
5850                  exit(1);
5851              }
5852          }
5853          printf(
5854              "%lld Gets/sec | Hits: %lld (%.2f%%) | Misses: %lld (%.2f%%)\n",
5855              hits+misses,
5856              hits, (double)hits/(hits+misses)*100,
5857              misses, (double)misses/(hits+misses)*100);
5858      }
5859      exit(0);
5860  }
5861  PORT_ULONG compute_something_fast(void) {
5862      unsigned char s[256], i, j, t;
5863      int count = 1000, k;
5864      PORT_ULONG output = 0;
5865      for (k = 0; k < 256; k++) s[k] = k;
5866      i = 0;
5867      j = 0;
5868      while(count--) {
5869          i++;
5870          j = j + s[i];
5871          t = s[i];
5872          s[i] = s[j];
5873          s[j] = t;
5874          output += s[(s[i]+s[j])&255];
5875      }
5876      return output;
5877  }
5878  static void intrinsicLatencyModeStop(int s) {
5879      UNUSED(s);
5880      force_cancel_loop = 1;
5881  }
5882  static void intrinsicLatencyMode(void) {
5883      PORT_LONGLONG test_end, run_time, max_latency = 0, runs = 0;
5884      run_time = ((PORT_LONGLONG)config.intrinsic_latency_duration)*1000000;
5885      test_end = ustime() + run_time;
5886      signal(SIGINT, intrinsicLatencyModeStop);
5887      while(1) {
5888          PORT_LONGLONG start, end, latency;
5889          start = ustime();
5890          compute_something_fast();
5891          end = ustime();
5892          latency = end-start;
5893          runs++;
5894          if (latency <= 0) continue;
5895          if (latency > max_latency) {
5896              max_latency = latency;
5897              printf("Max latency so far: %lld microseconds.\n", max_latency);
5898          }
5899          double avg_us = (double)run_time/runs;
5900          double avg_ns = avg_us * 1e3;
5901          if (force_cancel_loop || end > test_end) {
5902              printf("\n%lld total runs "
5903                  "(avg latency: "
5904                  "%.4f microseconds / %.2f nanoseconds per run).\n",
5905                  runs, avg_us, avg_ns);
5906              printf("Worst run took %.0fx longer than the average latency.\n",
5907                  max_latency / avg_us);
5908              exit(0);
5909          }
5910      }
5911  }
5912  int main(int argc, char **argv) {
5913      int firstarg;
5914  #ifdef _WIN32
5915      pthread_mutex_init(&used_memory_mutex, NULL);
5916  #endif
5917      config.hostip = sdsnew("127.0.0.1");
5918      config.hostport = 6379;
5919      config.hostsocket = NULL;
5920      config.repeat = 1;
5921      config.interval = 0;
5922      config.dbnum = 0;
5923      config.interactive = 0;
5924      config.shutdown = 0;
5925      config.monitor_mode = 0;
5926      config.pubsub_mode = 0;
5927      config.latency_mode = 0;
5928      config.latency_dist_mode = 0;
5929      config.latency_history = 0;
5930      config.lru_test_mode = 0;
5931      config.lru_test_sample_size = 0;
5932      config.cluster_mode = 0;
5933      config.slave_mode = 0;
5934      config.getrdb_mode = 0;
5935      config.stat_mode = 0;
5936      config.scan_mode = 0;
5937      config.intrinsic_latency_mode = 0;
5938      config.pattern = NULL;
5939      config.rdb_filename = NULL;
5940      config.pipe_mode = 0;
5941      config.pipe_timeout = REDIS_CLI_DEFAULT_PIPE_TIMEOUT;
5942      config.bigkeys = 0;
5943      config.hotkeys = 0;
5944      config.stdinarg = 0;
5945      config.auth = NULL;
5946      config.eval = NULL;
5947      config.eval_ldb = 0;
5948      config.eval_ldb_end = 0;
5949      config.eval_ldb_sync = 0;
5950      config.enable_ldb_on_eval = 0;
5951      config.last_cmd_type = -1;
5952      config.verbose = 0;
5953      config.no_auth_warning = 0;
5954      config.cluster_manager_command.name = NULL;
5955      config.cluster_manager_command.argc = 0;
5956      config.cluster_manager_command.argv = NULL;
5957      config.cluster_manager_command.flags = 0;
5958      config.cluster_manager_command.replicas = 0;
5959      config.cluster_manager_command.from = NULL;
5960      config.cluster_manager_command.to = NULL;
5961      config.cluster_manager_command.weight = NULL;
5962      config.cluster_manager_command.weight_argc = 0;
5963      config.cluster_manager_command.slots = 0;
5964      config.cluster_manager_command.timeout = CLUSTER_MANAGER_MIGRATE_TIMEOUT;
5965      config.cluster_manager_command.pipeline = CLUSTER_MANAGER_MIGRATE_PIPELINE;
5966      config.cluster_manager_command.threshold =
5967          CLUSTER_MANAGER_REBALANCE_THRESHOLD;
5968      pref.hints = 1;
5969      spectrum_palette = spectrum_palette_color;
5970      spectrum_palette_size = spectrum_palette_color_size;
5971      if (!isatty(fileno(stdout)) && (getenv("FAKETTY") == NULL))
5972          config.output = OUTPUT_RAW;
5973      else
5974          config.output = OUTPUT_STANDARD;
5975      config.mb_delim = sdsnew("\n");
5976      firstarg = parseOptions(argc,argv);
5977      argc -= firstarg;
5978      argv += firstarg;
5979      parseEnv();
5980      if (CLUSTER_MANAGER_MODE()) {
5981          clusterManagerCommandProc *proc = validateClusterManagerCommand();
5982          if (!proc) {
5983              sdsfree(config.hostip);
5984              sdsfree(config.mb_delim);
5985              exit(1);
5986          }
5987          clusterManagerMode(proc);
5988      }
5989      if (config.latency_mode) {
5990          if (cliConnect(0) == REDIS_ERR) exit(1);
5991          latencyMode();
5992      }
5993      if (config.latency_dist_mode) {
5994          if (cliConnect(0) == REDIS_ERR) exit(1);
5995          latencyDistMode();
5996      }
5997      if (config.slave_mode) {
5998          if (cliConnect(0) == REDIS_ERR) exit(1);
5999          slaveMode();
6000      }
6001      if (config.getrdb_mode) {
6002          if (cliConnect(0) == REDIS_ERR) exit(1);
6003          getRDB();
6004      }
6005      if (config.pipe_mode) {
6006          if (cliConnect(0) == REDIS_ERR) exit(1);
6007          pipeMode();
6008      }
6009      if (config.bigkeys) {
6010          if (cliConnect(0) == REDIS_ERR) exit(1);
6011          findBigKeys(0, 0);
6012      }
6013      if (config.memkeys) {
6014          if (cliConnect(0) == REDIS_ERR) exit(1);
6015          findBigKeys(1, config.memkeys_samples);
6016      }
6017      if (config.hotkeys) {
6018          if (cliConnect(0) == REDIS_ERR) exit(1);
6019          findHotKeys();
6020      }
6021      if (config.stat_mode) {
6022          if (cliConnect(0) == REDIS_ERR) exit(1);
6023          if (config.interval == 0) config.interval = 1000000;
6024          statMode();
6025      }
6026      if (config.scan_mode) {
6027          if (cliConnect(0) == REDIS_ERR) exit(1);
6028          scanMode();
6029      }
6030      if (config.lru_test_mode) {
6031          if (cliConnect(0) == REDIS_ERR) exit(1);
6032          LRUTestMode();
6033      }
6034      if (config.intrinsic_latency_mode) intrinsicLatencyMode();
6035      if (argc == 0 && !config.eval) {
6036          signal(SIGPIPE, SIG_IGN);
6037          cliConnect(0);
6038          repl();
6039      }
6040      if (cliConnect(0) != REDIS_OK) exit(1);
6041      if (config.eval) {
6042          return evalMode(argc,argv);
6043      } else {
6044          return noninteractive(argc,convertToSds(argc,argv));
6045      }
6046  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-redis-cli.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/Win32_Portability.h"
3  #include "Win32_Interop/win32_types.h"
4  #include "Win32_Interop/Win32_Time.h"
5  #include "Win32_Interop/win32fixes.h"
6  #include "Win32_Interop/Win32_PThread.h"
7  #include "Win32_Interop/Win32_Error.h"
8  #endif
9  #include "fmacros.h"
10  #include "version.h"
11  #include <stdio.h>
12  #include <string.h>
13  #include <stdlib.h>
14  #ifndef _WIN32
15  #include <signal.h>
16  #include <unistd.h>
17  #endif
18  #include <time.h>
19  #include <ctype.h>
20  #include <errno.h>
21  #include <sys/stat.h>
22  #ifndef _WIN32
23  #include <sys/time.h>
24  #endif
25  #include <assert.h>
26  #include <fcntl.h>
27  #include <limits.h>
28  #include <math.h>
29  #ifdef _WIN32
30  #ifndef STDIN_FILENO
31  #define STDIN_FILENO (_fileno(stdin))
32  #endif
33  #include "Win32_Interop/win32fixes.h"
34  #include "Win32_Interop/Win32_Signal_Process.h"
35  #include "Win32_Interop/Win32_ANSI.h"
36  #include <windows.h>
37  #define strcasecmp _stricmp
38  #define strncasecmp _strnicmp
39  #define strtoull _strtoui64
40  #endif
41  #include <hiredis.h>
42  #include <sds.h> &bsol;* use sds.h from hiredis, so that only one set of sds functions will be present in the binary */
43  #include "dict.h"
44  #include "adlist.h"
45  #include "zmalloc.h"
46  #include "linenoise.h"
47  #include "help.h"
48  #include "anet.h"
49  #include "ae.h"
50  #define UNUSED(V) ((void) V)
51  #define OUTPUT_STANDARD 0
52  #define OUTPUT_RAW 1
53  #define OUTPUT_CSV 2
54  #define REDIS_CLI_KEEPALIVE_INTERVAL 15 &bsol;* seconds */
55  #define REDIS_CLI_DEFAULT_PIPE_TIMEOUT 30 &bsol;* seconds */
56  #define REDIS_CLI_HISTFILE_ENV "REDISCLI_HISTFILE"
57  #define REDIS_CLI_HISTFILE_DEFAULT ".rediscli_history"
58  #define REDIS_CLI_RCFILE_ENV "REDISCLI_RCFILE"
59  #define REDIS_CLI_RCFILE_DEFAULT ".redisclirc"
60  #define REDIS_CLI_AUTH_ENV "REDISCLI_AUTH"
61  #define REDIS_CLI_CLUSTER_YES_ENV "REDISCLI_CLUSTER_YES"
62  #define CLUSTER_MANAGER_SLOTS               16384
63  #define CLUSTER_MANAGER_MIGRATE_TIMEOUT     60000
64  #define CLUSTER_MANAGER_MIGRATE_PIPELINE    10
65  #define CLUSTER_MANAGER_REBALANCE_THRESHOLD 2
66  #define CLUSTER_MANAGER_INVALID_HOST_ARG \
67      "[ERR] Invalid arguments: you need to pass either a valid " \
68      "address (ie. 120.0.0.1:7000) or space separated IP " \
69      "and port (ie. 120.0.0.1 7000)\n"
70  #define CLUSTER_MANAGER_MODE() (config.cluster_manager_command.name != NULL)
71  #define CLUSTER_MANAGER_MASTERS_COUNT(nodes, replicas) (nodes/(replicas + 1))
72  #define CLUSTER_MANAGER_COMMAND(n,...) \
73          (redisCommand(n->context, __VA_ARGS__))
74  #define CLUSTER_MANAGER_NODE_ARRAY_FREE(array) zfree(array->alloc)
75  #define CLUSTER_MANAGER_PRINT_REPLY_ERROR(n, err) \
76      clusterManagerLogErr("Node %s:%d replied with error:\n%s\n", \
77                           n->ip, n->port, err);
78  #define clusterManagerLogInfo(...) \
79      clusterManagerLog(CLUSTER_MANAGER_LOG_LVL_INFO,__VA_ARGS__)
80  #define clusterManagerLogErr(...) \
81      clusterManagerLog(CLUSTER_MANAGER_LOG_LVL_ERR,__VA_ARGS__)
82  #define clusterManagerLogWarn(...) \
83      clusterManagerLog(CLUSTER_MANAGER_LOG_LVL_WARN,__VA_ARGS__)
84  #define clusterManagerLogOk(...) \
85      clusterManagerLog(CLUSTER_MANAGER_LOG_LVL_SUCCESS,__VA_ARGS__)
86  #define CLUSTER_MANAGER_FLAG_MYSELF     1 << 0
87  #define CLUSTER_MANAGER_FLAG_SLAVE      1 << 1
88  #define CLUSTER_MANAGER_FLAG_FRIEND     1 << 2
89  #define CLUSTER_MANAGER_FLAG_NOADDR     1 << 3
90  #define CLUSTER_MANAGER_FLAG_DISCONNECT 1 << 4
91  #define CLUSTER_MANAGER_FLAG_FAIL       1 << 5
92  #define CLUSTER_MANAGER_CMD_FLAG_FIX            1 << 0
93  #define CLUSTER_MANAGER_CMD_FLAG_SLAVE          1 << 1
94  #define CLUSTER_MANAGER_CMD_FLAG_YES            1 << 2
95  #define CLUSTER_MANAGER_CMD_FLAG_AUTOWEIGHTS    1 << 3
96  #define CLUSTER_MANAGER_CMD_FLAG_EMPTYMASTER    1 << 4
97  #define CLUSTER_MANAGER_CMD_FLAG_SIMULATE       1 << 5
98  #define CLUSTER_MANAGER_CMD_FLAG_REPLACE        1 << 6
99  #define CLUSTER_MANAGER_CMD_FLAG_COPY           1 << 7
100  #define CLUSTER_MANAGER_CMD_FLAG_COLOR          1 << 8
101  #define CLUSTER_MANAGER_CMD_FLAG_CHECK_OWNERS   1 << 9
102  #define CLUSTER_MANAGER_OPT_GETFRIENDS  1 << 0
103  #define CLUSTER_MANAGER_OPT_COLD        1 << 1
104  #define CLUSTER_MANAGER_OPT_UPDATE      1 << 2
105  #define CLUSTER_MANAGER_OPT_QUIET       1 << 6
106  #define CLUSTER_MANAGER_OPT_VERBOSE     1 << 7
107  #define CLUSTER_MANAGER_LOG_LVL_INFO    1
108  #define CLUSTER_MANAGER_LOG_LVL_WARN    2
109  #define CLUSTER_MANAGER_LOG_LVL_ERR     3
110  #define CLUSTER_MANAGER_LOG_LVL_SUCCESS 4
111  #define LOG_COLOR_BOLD      "29;1m"
112  #define LOG_COLOR_RED       "31;1m"
113  #define LOG_COLOR_GREEN     "32;1m"
114  #define LOG_COLOR_YELLOW    "33;1m"
115  #define LOG_COLOR_RESET     "0m"
116  #define CC_FORCE (1<<0)         &bsol;* Re-connect if already connected. */
117  #define CC_QUIET (1<<1)         &bsol;* Don't log connecting errors. */
118  int spectrum_palette_color_size = 19;
119  int spectrum_palette_color[] = {0,233,234,235,237,239,241,243,245,247,144,143,142,184,226,214,208,202,196};
120  int spectrum_palette_mono_size = 13;
121  int spectrum_palette_mono[] = {0,233,234,235,237,239,241,243,245,247,249,251,253};
122  int *spectrum_palette;
123  int spectrum_palette_size;
124  static uint64_t dictSdsHash(const void *key);
125  static int dictSdsKeyCompare(void *privdata, const void *key1,
126      const void *key2);
127  static void dictSdsDestructor(void *privdata, void *val);
128  static void dictListDestructor(void *privdata, void *val);
129  typedef struct clusterManagerCommand {
130      char *name;
131      int argc;
132      char **argv;
133      int flags;
134      int replicas;
135      char *from;
136      char *to;
137      char **weight;
138      int weight_argc;
139      char *master_id;
140      int slots;
141      int timeout;
142      int pipeline;
143      float threshold;
144  } clusterManagerCommand;
145  static void createClusterManagerCommand(char *cmdname, int argc, char **argv);
146  static redisContext *context;
147  static struct config {
148      char *hostip;
149      int hostport;
150      char *hostsocket;
151      PORT_LONG repeat;
152      PORT_LONG interval;
153      int dbnum;
154      int interactive;
155      int shutdown;
156      int monitor_mode;
157      int pubsub_mode;
158      int latency_mode;
159      int latency_dist_mode;
160      int latency_history;
161      int lru_test_mode;
162      PORT_LONGLONG lru_test_sample_size;
163      int cluster_mode;
164      int cluster_reissue_command;
165      int slave_mode;
166      int pipe_mode;
167      int pipe_timeout;
168      int getrdb_mode;
169      int stat_mode;
170      int scan_mode;
171      int intrinsic_latency_mode;
172      int intrinsic_latency_duration;
173      char *pattern;
174      char *rdb_filename;
175      int bigkeys;
176      int memkeys;
177      unsigned memkeys_samples;
178      int hotkeys;
179      int stdinarg; &bsol;* get last arg from stdin. (-x option) */
180      char *auth;
181      int output; &bsol;* output mode, see OUTPUT_* defines */
182      sds mb_delim;
183      char prompt[128];
184      char *eval;
185      int eval_ldb;
186      int eval_ldb_sync;  &bsol;* Ask for synchronous mode of the Lua debugger. */
187      int eval_ldb_end;   &bsol;* Lua debugging session ended. */
188      int enable_ldb_on_eval; &bsol;* Handle manual SCRIPT DEBUG + EVAL commands. */
189      int last_cmd_type;
190      int verbose;
191      clusterManagerCommand cluster_manager_command;
192      int no_auth_warning;
193  } config;
194  static struct pref {
195      int hints;
196  } pref;
197  static volatile sig_atomic_t force_cancel_loop = 0;
198  static void usage(void);
199  static void slaveMode(void);
200  char *redisGitSHA1(void);
201  char *redisGitDirty(void);
202  static int cliConnect(int force);
203  static char *getInfoField(char *info, char *field);
204  static PORT_LONG getLongInfoField(char *info, char *field);
205  #ifdef _WIN32
206  extern pthread_mutex_t used_memory_mutex;
207  #endif
208  uint16_t crc16(const char *buf, int len);
209  static PORT_LONGLONG ustime(void) {
210  #ifdef _WIN32
211      return GetHighResRelativeTime(1000000);
212  #else
213      struct timeval tv;
214      PORT_LONGLONG ust;
215      gettimeofday(&tv, NULL);
216      ust = ((PORT_LONGLONG) tv.tv_sec) * 1000000;
217      ust += tv.tv_usec;
218      return ust;
219  #endif
220  }
221  static PORT_LONGLONG mstime(void) {
222      return ustime() / 1000;
223  }
224  static void cliRefreshPrompt(void) {
225      if (config.eval_ldb) return;
226      sds prompt = sdsempty();
227      if (config.hostsocket != NULL) {
228          prompt = sdscatfmt(prompt,"redis %s",config.hostsocket);
229      } else {
230          char addr[256];
231          anetFormatAddr(addr, sizeof(addr), config.hostip, config.hostport);
232          prompt = sdscatlen(prompt,addr,strlen(addr));
233      }
234      if (config.dbnum != 0)
235          prompt = sdscatfmt(prompt,"[%i]",config.dbnum);
236      prompt = sdscatlen(prompt,"> ",2);
237      snprintf(config.prompt,sizeof(config.prompt),"%s",prompt);
238      sdsfree(prompt);
239  }
240  static sds getDotfilePath(char *envoverride, char *dotfilename) {
241      char *path = NULL;
242      sds dotPath = NULL;
243      path = getenv(envoverride);
244      if (path != NULL && *path != '\0') {
245          if (!strcmp("/dev/null", path)) {
246              return NULL;
247          }
248          dotPath = sdsnew(path);
249      } else {
250  #ifdef _WIN32
251          char *homeDrive = getenv("HOMEDRIVE");
252          char *homePath = getenv("HOMEPATH");
253          if ((homeDrive != NULL) && (*homeDrive != '\0')
254              && (homePath != NULL) && (*homePath != '\0')) {
255              dotPath = sdscatprintf(sdsempty(), "%s%s\\%s", homeDrive, homePath, dotfilename);
256          }
257  #else
258          char *home = getenv("HOME");
259          if (home != NULL && *home != '\0') {
260              dotPath = sdscatprintf(sdsempty(), "%s/%s", home, dotfilename);
261          }
262  #endif
263      }
264      return dotPath;
265  }
266  #define isHexChar(c) (isdigit(c) || (c >= 'a' && c <= 'f'))
267  #define decodeHexChar(c) (isdigit(c) ? c - '0' : c - 'a' + 10)
268  #define decodeHex(h, l) ((decodeHexChar(h) << 4) + decodeHexChar(l))
269  static sds percentDecode(const char *pe, size_t len) {
270      const char *end = pe + len;
271      sds ret = sdsempty();
272      const char *curr = pe;
273      while (curr < end) {
274          if (*curr == '%') {
275              if ((end - curr) < 2) {
276                  fprintf(stderr, "Incomplete URI encoding\n");
277                  exit(1);
278              }
279              char h = tolower(*(++curr));
280              char l = tolower(*(++curr));
281              if (!isHexChar(h) || !isHexChar(l)) {
282                  fprintf(stderr, "Illegal character in URI encoding\n");
283                  exit(1);
284              }
285              char c = decodeHex(h, l);
286              ret = sdscatlen(ret, &c, 1);
287              curr++;
288          } else {
289              ret = sdscatlen(ret, curr++, 1);
290          }
291      }
292      return ret;
293  }
294  static void parseRedisUri(const char *uri) {
295      const char *scheme = "redis:&bsol;&bsol;";
296      const char *curr = uri;
297      const char *end = uri + strlen(uri);
298      const char *userinfo, *username, *port, *host, *path;
299      if (strncasecmp(scheme, curr, strlen(scheme))) {
300          fprintf(stderr,"Invalid URI scheme\n");
301          exit(1);
302      }
303      curr += strlen(scheme);
304      if (curr == end) return;
305      if ((userinfo = strchr(curr,'@'))) {
306          if ((username = strchr(curr, ':')) && username < userinfo) {
307              curr = username + 1;
308          }
309          config.auth = percentDecode(curr, userinfo - curr);
310          curr = userinfo + 1;
311      }
312      if (curr == end) return;
313      path = strchr(curr, '/');
314      if (*curr != '/') {
315          host = path ? path - 1 : end;
316          if ((port = strchr(curr, ':'))) {
317              config.hostport = atoi(port + 1);
318              host = port - 1;
319          }
320          config.hostip = sdsnewlen(curr, host - curr + 1);
321      }
322      curr = path ? path + 1 : end;
323      if (curr == end) return;
324      config.dbnum = atoi(curr);
325  }
326  static uint64_t dictSdsHash(const void *key) {
327      return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));
328  }
329  static int dictSdsKeyCompare(void *privdata, const void *key1,
330          const void *key2)
331  {
332      int l1,l2;
333      DICT_NOTUSED(privdata);
334      l1 = sdslen((sds)key1);
335      l2 = sdslen((sds)key2);
336      if (l1 != l2) return 0;
337      return memcmp(key1, key2, l1) == 0;
338  }
339  static void dictSdsDestructor(void *privdata, void *val)
340  {
341      DICT_NOTUSED(privdata);
342      sdsfree(val);
343  }
344  void dictListDestructor(void *privdata, void *val)
345  {
346      DICT_NOTUSED(privdata);
347      listRelease((list*)val);
348  }
349  void _serverAssert(const char *estr, const char *file, int line) {
350      fprintf(stderr, "=== ASSERTION FAILED ===");
351      fprintf(stderr, "==> %s:%d '%s' is not true",file,line,estr);
352      *((char*)-1) = 'x';
353  }
354  #define CLI_HELP_COMMAND 1
355  #define CLI_HELP_GROUP 2
356  typedef struct {
357      int type;
358      int argc;
359      sds *argv;
360      sds full;
361      struct commandHelp *org;
362  } helpEntry;
363  static helpEntry *helpEntries;
364  static int helpEntriesLen;
365  static sds cliVersion(void) {
366      sds version;
367      version = sdscatprintf(sdsempty(), "%s", REDIS_VERSION);
368      if (strtoll(redisGitSHA1(),NULL,16)) {
369          version = sdscatprintf(version, " (git:%s", redisGitSHA1());
370          if (strtoll(redisGitDirty(),NULL,10))
371              version = sdscatprintf(version, "-dirty");
372          version = sdscat(version, ")");
373      }
374      return version;
375  }
376  static void cliInitHelp(void) {
377      int commandslen = sizeof(commandHelp)/sizeof(struct commandHelp);
378      int groupslen = sizeof(commandGroups)/sizeof(char*);
379      int i, len, pos = 0;
380      helpEntry tmp;
381      helpEntriesLen = len = commandslen+groupslen;
382      helpEntries = zmalloc(sizeof(helpEntry)*len);
383      for (i = 0; i < groupslen; i++) {
384          tmp.argc = 1;
385          tmp.argv = zmalloc(sizeof(sds));
386          tmp.argv[0] = sdscatprintf(sdsempty(),"@%s",commandGroups[i]);
387          tmp.full = tmp.argv[0];
388          tmp.type = CLI_HELP_GROUP;
389          tmp.org = NULL;
390          helpEntries[pos++] = tmp;
391      }
392      for (i = 0; i < commandslen; i++) {
393          tmp.argv = sdssplitargs(commandHelp[i].name,&tmp.argc);
394          tmp.full = sdsnew(commandHelp[i].name);
395          tmp.type = CLI_HELP_COMMAND;
396          tmp.org = &commandHelp[i];
397          helpEntries[pos++] = tmp;
398      }
399  }
400  static void cliIntegrateHelp(void) {
401      if (cliConnect(CC_QUIET) == REDIS_ERR) return;
402      redisReply *reply = redisCommand(context, "COMMAND");
403      if(reply == NULL || reply->type != REDIS_REPLY_ARRAY) return;
404      for (size_t j = 0; j < reply->elements; j++) {
405          redisReply *entry = reply->element[j];
406          if (entry->type != REDIS_REPLY_ARRAY || entry->elements < 4 ||
407              entry->element[0]->type != REDIS_REPLY_STRING ||
408              entry->element[1]->type != REDIS_REPLY_INTEGER ||
409              entry->element[3]->type != REDIS_REPLY_INTEGER) return;
410          char *cmdname = entry->element[0]->str;
411          int i;
412          for (i = 0; i < helpEntriesLen; i++) {
413              helpEntry *he = helpEntries+i;
414              if (!strcasecmp(he->argv[0],cmdname))
415                  break;
416          }
417          if (i != helpEntriesLen) continue;
418          helpEntriesLen++;
419          helpEntries = zrealloc(helpEntries,sizeof(helpEntry)*helpEntriesLen);
420          helpEntry *new = helpEntries+(helpEntriesLen-1);
421          new->argc = 1;
422          new->argv = zmalloc(sizeof(sds));
423          new->argv[0] = sdsnew(cmdname);
424          new->full = new->argv[0];
425          new->type = CLI_HELP_COMMAND;
426          sdstoupper(new->argv[0]);
427          struct commandHelp *ch = zmalloc(sizeof(*ch));
428          ch->name = new->argv[0];
429          ch->params = sdsempty();
430          int args = llabs(entry->element[1]->integer);
431          args--; &bsol;* Remove the command name itself. */
432          if (entry->element[3]->integer == 1) {
433              ch->params = sdscat(ch->params,"key ");
434              args--;
435          }
436          while(args-- > 0) ch->params = sdscat(ch->params,"arg ");
437          if (entry->element[1]->integer < 0)
438              ch->params = sdscat(ch->params,"...options...");
439          ch->summary = "Help not available";
440          ch->group = 0;
441          ch->since = "not known";
442          new->org = ch;
443      }
444      freeReplyObject(reply);
445  }
446  static void cliOutputCommandHelp(struct commandHelp *help, int group) {
447      printf("\r\n  \x1b[1m%s\x1b[0m \x1b[90m%s\x1b[0m\r\n", help->name, help->params);
448      printf("  \x1b[33msummary:\x1b[0m %s\r\n", help->summary);
449      printf("  \x1b[33msince:\x1b[0m %s\r\n", help->since);
450      if (group) {
451          printf("  \x1b[33mgroup:\x1b[0m %s\r\n", commandGroups[help->group]);
452      }
453  }
454  static void cliOutputGenericHelp(void) {
455      sds version = cliVersion();
456      printf(
457          "redis-cli %s\n"
458          "To get help about Redis commands type:\n"
459          "      \"help @<group>\" to get a list of commands in <group>\n"
460          "      \"help <command>\" for help on <command>\n"
461          "      \"help <tab>\" to get a list of possible help topics\n"
462          "      \"quit\" to exit\n"
463          "\n"
464          "To set redis-cli preferences:\n"
465          "      \":set hints\" enable online hints\n"
466          "      \":set nohints\" disable online hints\n"
467          "Set your preferences in ~/.redisclirc\n",
468          version
469      );
470      sdsfree(version);
471  }
472  static void cliOutputHelp(int argc, char **argv) {
473      int i, j, len;
474      int group = -1;
475      helpEntry *entry;
476      struct commandHelp *help;
477      if (argc == 0) {
478          cliOutputGenericHelp();
479          return;
480      } else if (argc > 0 && argv[0][0] == '@') {
481          len = sizeof(commandGroups)/sizeof(char*);
482          for (i = 0; i < len; i++) {
483              if (strcasecmp(argv[0]+1,commandGroups[i]) == 0) {
484                  group = i;
485                  break;
486              }
487          }
488      }
489      assert(argc > 0);
490      for (i = 0; i < helpEntriesLen; i++) {
491          entry = &helpEntries[i];
492          if (entry->type != CLI_HELP_COMMAND) continue;
493          help = entry->org;
494          if (group == -1) {
495              if (argc == entry->argc) {
496                  for (j = 0; j < argc; j++) {
497                      if (strcasecmp(argv[j],entry->argv[j]) != 0) break;
498                  }
499                  if (j == argc) {
500                      cliOutputCommandHelp(help,1);
501                  }
502              }
503          } else {
504              if (group == help->group) {
505                  cliOutputCommandHelp(help,0);
506              }
507          }
508      }
509      printf("\r\n");
510  }
511  static void completionCallback(const char *buf, linenoiseCompletions *lc) {
512      size_t startpos = 0;
513      int mask;
514      int i;
515      size_t matchlen;
516      sds tmp;
517      if (strncasecmp(buf,"help ",5) == 0) {
518          startpos = 5;
519          while (isspace(buf[startpos])) startpos++;
520          mask = CLI_HELP_COMMAND | CLI_HELP_GROUP;
521      } else {
522          mask = CLI_HELP_COMMAND;
523      }
524      for (i = 0; i < helpEntriesLen; i++) {
525          if (!(helpEntries[i].type & mask)) continue;
526          matchlen = strlen(buf+startpos);
527          if (strncasecmp(buf+startpos,helpEntries[i].full,matchlen) == 0) {
528              tmp = sdsnewlen(buf,startpos);
529              tmp = sdscat(tmp,helpEntries[i].full);
530              linenoiseAddCompletion(lc,tmp);
531              sdsfree(tmp);
532          }
533      }
534  }
535  static char *hintsCallback(const char *buf, int *color, int *bold) {
536      if (!pref.hints) return NULL;
537      int i, argc, buflen = (int)strlen(buf);                                     WIN_PORT_FIX &bsol;* cast int */
538      sds *argv = sdssplitargs(buf,&argc);
539      int endspace = buflen && isspace(buf[buflen-1]);
540      if (argc == 0) {
541          sdsfreesplitres(argv,argc);
542          return NULL;
543      }
544      for (i = 0; i < helpEntriesLen; i++) {
545          if (!(helpEntries[i].type & CLI_HELP_COMMAND)) continue;
546          if (strcasecmp(argv[0],helpEntries[i].full) == 0)
547          {
548              *color = 90;
549              *bold = 0;
550              sds hint = sdsnew(helpEntries[i].org->params);
551              int toremove = argc-1;
552              while(toremove > 0 && sdslen(hint)) {
553                  if (hint[0] == '[') break;
554                  if (hint[0] == ' ') toremove--;
555                  sdsrange(hint,1,-1);
556              }
557              if (!endspace) {
558                  sds newhint = sdsnewlen(" ",1);
559                  newhint = sdscatsds(newhint,hint);
560                  sdsfree(hint);
561                  hint = newhint;
562              }
563              sdsfreesplitres(argv,argc);
564              return hint;
565          }
566      }
567      sdsfreesplitres(argv,argc);
568      return NULL;
569  }
570  static void freeHintsCallback(void *ptr) {
571      sdsfree(ptr);
572  }
573  static int cliAuth(void) {
574      redisReply *reply;
575      if (config.auth == NULL) return REDIS_OK;
576      reply = redisCommand(context,"AUTH %s",config.auth);
577      if (reply != NULL) {
578          freeReplyObject(reply);
579          return REDIS_OK;
580      }
581      return REDIS_ERR;
582  }
583  static int cliSelect(void) {
584      redisReply *reply;
585      if (config.dbnum == 0) return REDIS_OK;
586      reply = redisCommand(context,"SELECT %d",config.dbnum);
587      if (reply != NULL) {
588          int result = REDIS_OK;
589          if (reply->type == REDIS_REPLY_ERROR) result = REDIS_ERR;
590          freeReplyObject(reply);
591          return result;
592      }
593      return REDIS_ERR;
594  }
595  static int cliConnect(int flags) {
596      if (context == NULL || flags & CC_FORCE) {
597          if (context != NULL) {
598              redisFree(context);
599          }
600          if (config.hostsocket == NULL) {
601              context = redisConnect(config.hostip,config.hostport);
602          } else {
603              context = redisConnectUnix(config.hostsocket);
604          }
605          if (context->err) {
606              if (!(flags & CC_QUIET)) {
607                  fprintf(stderr,"Could not connect to Redis at ");
608                  if (config.hostsocket == NULL)
609                      fprintf(stderr,"%s:%d: %s\n",
610                          config.hostip,config.hostport,context->errstr);
611                  else
612                      fprintf(stderr,"%s: %s\n",
613                          config.hostsocket,context->errstr);
614              }
615              redisFree(context);
616              context = NULL;
617              return REDIS_ERR;
618          }
619          anetKeepAlive(NULL, context->fd, REDIS_CLI_KEEPALIVE_INTERVAL);
620          if (cliAuth() != REDIS_OK)
621              return REDIS_ERR;
622          if (cliSelect() != REDIS_OK)
623              return REDIS_ERR;
624      }
625      return REDIS_OK;
626  }
627  static void cliPrintContextError(void) {
628      if (context == NULL) return;
629      fprintf(stderr,"Error: %s\n",context->errstr);
630  }
631  static sds cliFormatReplyTTY(redisReply *r, char *prefix) {
632      sds out = sdsempty();
633      switch (r->type) {
634      case REDIS_REPLY_ERROR:
635          out = sdscatprintf(out,"(error) %s\n", r->str);
636      break;
637      case REDIS_REPLY_STATUS:
638          out = sdscat(out,r->str);
639          out = sdscat(out,"\n");
640      break;
641      case REDIS_REPLY_INTEGER:
642          out = sdscatprintf(out,"(integer) %lld\n",r->integer);
643      break;
644      case REDIS_REPLY_STRING:
645          out = sdscatrepr(out,r->str,r->len);
646          out = sdscat(out,"\n");
647      break;
648      case REDIS_REPLY_NIL:
649          out = sdscat(out,"(nil)\n");
650      break;
651      case REDIS_REPLY_ARRAY:
652          if (r->elements == 0) {
653              out = sdscat(out,"(empty list or set)\n");
654          } else {
655              unsigned int i, idxlen = 0;
656              char _prefixlen[16];
657              char _prefixfmt[16];
658              sds _prefix;
659              sds tmp;
660              i = r->elements;
661              do {
662                  idxlen++;
663                  i /= 10;
664              } while(i);
665              memset(_prefixlen,' ',idxlen+2);
666              _prefixlen[idxlen+2] = '\0';
667              _prefix = sdscat(sdsnew(prefix),_prefixlen);
668              snprintf(_prefixfmt,sizeof(_prefixfmt),"%%s%%%ud) ",idxlen);
669              for (i = 0; i < r->elements; i++) {
670                  out = sdscatprintf(out,_prefixfmt,i == 0 ? "" : prefix,i+1);
671                  tmp = cliFormatReplyTTY(r->element[i],_prefix);
672                  out = sdscatlen(out,tmp,sdslen(tmp));
673                  sdsfree(tmp);
674              }
675              sdsfree(_prefix);
676          }
677      break;
678      default:
679          fprintf(stderr,"Unknown reply type: %d\n", r->type);
680          exit(1);
681      }
682      return out;
683  }
684  int isColorTerm(void) {
685      char *t = getenv("TERM");
686      return t != NULL && strstr(t,"xterm") != NULL;
687  }
688  sds sdscatcolor(sds o, char *s, size_t len, char *color) {
689      if (!isColorTerm()) return sdscatlen(o,s,len);
690      int bold = strstr(color,"bold") != NULL;
691      int ccode = 37; &bsol;* Defaults to white. */
692      if (strstr(color,"red")) ccode = 31;
693      else if (strstr(color,"green")) ccode = 32;
694      else if (strstr(color,"yellow")) ccode = 33;
695      else if (strstr(color,"blue")) ccode = 34;
696      else if (strstr(color,"magenta")) ccode = 35;
697      else if (strstr(color,"cyan")) ccode = 36;
698      else if (strstr(color,"white")) ccode = 37;
699      o = sdscatfmt(o,"\033[%i;%i;49m",bold,ccode);
700      o = sdscatlen(o,s,len);
701      o = sdscat(o,"\033[0m");
702      return o;
703  }
704  sds sdsCatColorizedLdbReply(sds o, char *s, size_t len) {
705      char *color = "white";
706      if (strstr(s,"<debug>")) color = "bold";
707      if (strstr(s,"<redis>")) color = "green";
708      if (strstr(s,"<reply>")) color = "cyan";
709      if (strstr(s,"<error>")) color = "red";
710      if (strstr(s,"<hint>")) color = "bold";
711      if (strstr(s,"<value>") || strstr(s,"<retval>")) color = "magenta";
712      if (len > 4 && isdigit(s[3])) {
713          if (s[1] == '>') color = "yellow"; &bsol;* Current line. */
714          else if (s[2] == '#') color = "bold"; &bsol;* Break point. */
715      }
716      return sdscatcolor(o,s,len,color);
717  }
718  static sds cliFormatReplyRaw(redisReply *r) {
719      sds out = sdsempty(), tmp;
720      size_t i;
721      switch (r->type) {
722      case REDIS_REPLY_NIL:
723          break;
724      case REDIS_REPLY_ERROR:
725          out = sdscatlen(out,r->str,r->len);
726          out = sdscatlen(out,"\n",1);
727          break;
728      case REDIS_REPLY_STATUS:
729      case REDIS_REPLY_STRING:
730          if (r->type == REDIS_REPLY_STATUS && config.eval_ldb) {
731              if (strstr(r->str,"<endsession>") == r->str) {
732                  config.enable_ldb_on_eval = 0;
733                  config.eval_ldb = 0;
734                  config.eval_ldb_end = 1; &bsol;* Signal the caller session ended. */
735                  config.output = OUTPUT_STANDARD;
736                  cliRefreshPrompt();
737              } else {
738                  out = sdsCatColorizedLdbReply(out,r->str,r->len);
739              }
740          } else {
741              out = sdscatlen(out,r->str,r->len);
742          }
743          break;
744      case REDIS_REPLY_INTEGER:
745          out = sdscatprintf(out,"%I64d",r->integer);   WIN_PORT_FIX &bsol;* %lld -> %I64d */
746          break;
747      case REDIS_REPLY_ARRAY:
748          for (i = 0; i < r->elements; i++) {
749              if (i > 0) out = sdscat(out,config.mb_delim);
750              tmp = cliFormatReplyRaw(r->element[i]);
751              out = sdscatlen(out,tmp,sdslen(tmp));
752              sdsfree(tmp);
753          }
754          break;
755      default:
756          fprintf(stderr,"Unknown reply type: %d\n", r->type);
757          exit(1);
758      }
759      return out;
760  }
761  static sds cliFormatReplyCSV(redisReply *r) {
762      unsigned int i;
763      sds out = sdsempty();
764      switch (r->type) {
765      case REDIS_REPLY_ERROR:
766          out = sdscat(out,"ERROR,");
767          out = sdscatrepr(out,r->str,strlen(r->str));
768      break;
769      case REDIS_REPLY_STATUS:
770          out = sdscatrepr(out,r->str,r->len);
771      break;
772      case REDIS_REPLY_INTEGER:
773          out = sdscatprintf(out,"%I64d",r->integer);   WIN_PORT_FIX &bsol;* %lld -> %I64d */
774      break;
775      case REDIS_REPLY_STRING:
776          out = sdscatrepr(out,r->str,r->len);
777      break;
778      case REDIS_REPLY_NIL:
779          out = sdscat(out,"NIL");
780      break;
781      case REDIS_REPLY_ARRAY:
782          for (i = 0; i < r->elements; i++) {
783              sds tmp = cliFormatReplyCSV(r->element[i]);
784              out = sdscatlen(out,tmp,sdslen(tmp));
785              if (i != r->elements-1) out = sdscat(out,",");
786              sdsfree(tmp);
787          }
788      break;
789      default:
790          fprintf(stderr,"Unknown reply type: %d\n", r->type);
791          exit(1);
792      }
793      return out;
794  }
795  static int cliReadReply(int output_raw_strings) {
796      void *_reply;
797      redisReply *reply;
798      sds out = NULL;
799      int output = 1;
800      if (redisGetReply(context,&_reply) != REDIS_OK) {
801          if (config.shutdown) {
802              redisFree(context);
803              context = NULL;
804              return REDIS_OK;
805          }
806          if (config.interactive) {
807              if (context->err == REDIS_ERR_IO &&
808                  (errno == ECONNRESET || errno == EPIPE))
809                  return REDIS_ERR;
810              if (context->err == REDIS_ERR_EOF)
811                  return REDIS_ERR;
812          }
813          cliPrintContextError();
814          exit(1);
815          return REDIS_ERR; &bsol;* avoid compiler warning */
816      }
817      reply = (redisReply*)_reply;
818      config.last_cmd_type = reply->type;
819      if (config.cluster_mode && reply->type == REDIS_REPLY_ERROR &&
820          (!strncmp(reply->str,"MOVED",5) || !strcmp(reply->str,"ASK")))
821      {
822          char *p = reply->str, *s;
823          int slot;
824          output = 0;
825          s = strchr(p,' ');      &bsol;* MOVED[S]3999 127.0.0.1:6381 */
826          p = strchr(s+1,' ');    &bsol;* MOVED[S]3999[P]127.0.0.1:6381 */
827          *p = '\0';
828          slot = atoi(s+1);
829          s = strrchr(p+1,':');    &bsol;* MOVED 3999[P]127.0.0.1[S]6381 */
830          *s = '\0';
831          sdsfree(config.hostip);
832          config.hostip = sdsnew(p+1);
833          config.hostport = atoi(s+1);
834          if (config.interactive)
835              printf("-> Redirected to slot [%d] located at %s:%d\n",
836                  slot, config.hostip, config.hostport);
837          config.cluster_reissue_command = 1;
838          cliRefreshPrompt();
839      }
840      if (output) {
841          if (output_raw_strings) {
842              out = cliFormatReplyRaw(reply);
843          } else {
844              if (config.output == OUTPUT_RAW) {
845                  out = cliFormatReplyRaw(reply);
846                  out = sdscat(out,"\n");
847              } else if (config.output == OUTPUT_STANDARD) {
848                  out = cliFormatReplyTTY(reply,"");
849              } else if (config.output == OUTPUT_CSV) {
850                  out = cliFormatReplyCSV(reply);
851                  out = sdscat(out,"\n");
852              }
853          }
854  #ifdef _WIN32
855          fprintf(stdout, "%s", out);
856  #else
857          fwrite(out,sdslen(out),1,stdout);
858  #endif
859          sdsfree(out);
860      }
861      freeReplyObject(reply);
862      return REDIS_OK;
863  }
864  static int cliSendCommand(int argc, char **argv, PORT_LONG repeat) {
865      char *command = argv[0];
866      size_t *argvlen;
867      int j, output_raw;
868      if (!config.eval_ldb && &bsol;* In debugging mode, let's pass "help" to Redis. */
869          (!strcasecmp(command,"help") || !strcasecmp(command,"?"))) {
870          cliOutputHelp(--argc, ++argv);
871          return REDIS_OK;
872      }
873      if (context == NULL) return REDIS_ERR;
874      output_raw = 0;
875      if (!strcasecmp(command,"info") ||
876          !strcasecmp(command,"lolwut") ||
877          (argc >= 2 && !strcasecmp(command,"debug") &&
878                         !strcasecmp(argv[1],"htstats")) ||
879          (argc >= 2 && !strcasecmp(command,"debug") &&
880                         !strcasecmp(argv[1],"htstats-key")) ||
881          (argc >= 2 && !strcasecmp(command,"memory") &&
882                        (!strcasecmp(argv[1],"malloc-stats") ||
883                         !strcasecmp(argv[1],"doctor"))) ||
884          (argc == 2 && !strcasecmp(command,"cluster") &&
885                        (!strcasecmp(argv[1],"nodes") ||
886                         !strcasecmp(argv[1],"info"))) ||
887          (argc >= 2 && !strcasecmp(command,"client") &&
888                         !strcasecmp(argv[1],"list")) ||
889          (argc == 3 && !strcasecmp(command,"latency") &&
890                         !strcasecmp(argv[1],"graph")) ||
891          (argc == 2 && !strcasecmp(command,"latency") &&
892                         !strcasecmp(argv[1],"doctor")))
893      {
894          output_raw = 1;
895      }
896      if (!strcasecmp(command,"shutdown")) config.shutdown = 1;
897      if (!strcasecmp(command,"monitor")) config.monitor_mode = 1;
898      if (!strcasecmp(command,"subscribe") ||
899          !strcasecmp(command,"psubscribe")) config.pubsub_mode = 1;
900      if (!strcasecmp(command,"sync") ||
901          !strcasecmp(command,"psync")) config.slave_mode = 1;
902      if (argc == 3 && !strcasecmp(argv[0],"script") &&
903                       !strcasecmp(argv[1],"debug"))
904      {
905          if (!strcasecmp(argv[2],"yes") || !strcasecmp(argv[2],"sync")) {
906              config.enable_ldb_on_eval = 1;
907          } else {
908              config.enable_ldb_on_eval = 0;
909          }
910      }
911      if (!strcasecmp(command,"eval") && config.enable_ldb_on_eval) {
912          config.eval_ldb = 1;
913          config.output = OUTPUT_RAW;
914      }
915      argvlen = zmalloc(argc*sizeof(size_t));
916      for (j = 0; j < argc; j++)
917          argvlen[j] = sdslen(argv[j]);
918      while(repeat < 0 || repeat-- > 0) {
919          redisAppendCommandArgv(context,argc,(const char**)argv,argvlen);
920          while (config.monitor_mode) {
921              if (cliReadReply(output_raw) != REDIS_OK) exit(1);
922              fflush(stdout);
923          }
924          if (config.pubsub_mode) {
925              if (config.output != OUTPUT_RAW)
926                  printf("Reading messages... (press Ctrl-C to quit)\n");
927              while (1) {
928                  if (cliReadReply(output_raw) != REDIS_OK) exit(1);
929              }
930          }
931          if (config.slave_mode) {
932              printf("Entering replica output mode...  (press Ctrl-C to quit)\n");
933              slaveMode();
934              config.slave_mode = 0;
935              zfree(argvlen);
936              return REDIS_ERR;  &bsol;* Error = slaveMode lost connection to master */
937          }
938          if (cliReadReply(output_raw) != REDIS_OK) {
939              zfree(argvlen);
940              return REDIS_ERR;
941          } else {
942              if (!strcasecmp(command,"select") && argc == 2 && config.last_cmd_type != REDIS_REPLY_ERROR) {
943                  config.dbnum = atoi(argv[1]);
944                  cliRefreshPrompt();
945              } else if (!strcasecmp(command,"auth") && argc == 2) {
946                  cliSelect();
947              }
948          }
949          if (config.cluster_reissue_command){
950              break;
951          }
952          if (config.interval) usleep(config.interval);
953          fflush(stdout); &bsol;* Make it grep friendly */
954      }
955      zfree(argvlen);
956      return REDIS_OK;
957  }
958  static redisReply *reconnectingRedisCommand(redisContext *c, const char *fmt, ...) {
959      redisReply *reply = NULL;
960      int tries = 0;
961      va_list ap;
962      assert(!c->err);
963      while(reply == NULL) {
964          while (c->err & (REDIS_ERR_IO | REDIS_ERR_EOF)) {
965              printf("\r\x1b[0K"); &bsol;* Cursor to left edge + clear line. */
966              printf("Reconnecting... %d\r", ++tries);
967              fflush(stdout);
968              redisFree(c);
969              c = redisConnect(config.hostip,config.hostport);
970              usleep(1000000);
971          }
972          va_start(ap,fmt);
973          reply = redisvCommand(c,fmt,ap);
974          va_end(ap);
975          if (c->err && !(c->err & (REDIS_ERR_IO | REDIS_ERR_EOF))) {
976              fprintf(stderr, "Error: %s\n", c->errstr);
977              exit(1);
978          } else if (tries > 0) {
979              printf("\r\x1b[0K"); &bsol;* Cursor to left edge + clear line. */
980          }
981      }
982      context = c;
983      return reply;
984  }
985  static int parseOptions(int argc, char **argv) {
986      int i;
987      for (i = 1; i < argc; i++) {
988          int lastarg = i==argc-1;
989          if (!strcmp(argv[i],"-h") && !lastarg) {
990              sdsfree(config.hostip);
991              config.hostip = sdsnew(argv[++i]);
992          } else if (!strcmp(argv[i],"-h") && lastarg) {
993              usage();
994          } else if (!strcmp(argv[i],"--help")) {
995              usage();
996          } else if (!strcmp(argv[i],"-x")) {
997              config.stdinarg = 1;
998          } else if (!strcmp(argv[i],"-p") && !lastarg) {
999              config.hostport = atoi(argv[++i]);
1000          } else if (!strcmp(argv[i],"-s") && !lastarg) {
1001              config.hostsocket = argv[++i];
1002          } else if (!strcmp(argv[i],"-r") && !lastarg) {
1003              config.repeat = (PORT_LONG)strtoll(argv[++i],NULL,10);
1004          } else if (!strcmp(argv[i],"-i") && !lastarg) {
1005              double seconds = atof(argv[++i]);
1006              config.interval = (PORT_LONG)(seconds*1000000);
1007          } else if (!strcmp(argv[i],"-n") && !lastarg) {
1008              config.dbnum = atoi(argv[++i]);
1009          } else if (!strcmp(argv[i], "--no-auth-warning")) {
1010              config.no_auth_warning = 1;
1011          } else if (!strcmp(argv[i],"-a") && !lastarg) {
1012              config.auth = argv[++i];
1013          } else if (!strcmp(argv[i],"-u") && !lastarg) {
1014              parseRedisUri(argv[++i]);
1015          } else if (!strcmp(argv[i],"--raw")) {
1016              config.output = OUTPUT_RAW;
1017          } else if (!strcmp(argv[i],"--no-raw")) {
1018              config.output = OUTPUT_STANDARD;
1019          } else if (!strcmp(argv[i],"--csv")) {
1020              config.output = OUTPUT_CSV;
1021          } else if (!strcmp(argv[i],"--latency")) {
1022              config.latency_mode = 1;
1023          } else if (!strcmp(argv[i],"--latency-dist")) {
1024              config.latency_dist_mode = 1;
1025          } else if (!strcmp(argv[i],"--mono")) {
1026              spectrum_palette = spectrum_palette_mono;
1027              spectrum_palette_size = spectrum_palette_mono_size;
1028          } else if (!strcmp(argv[i],"--latency-history")) {
1029              config.latency_mode = 1;
1030              config.latency_history = 1;
1031          } else if (!strcmp(argv[i],"--lru-test") && !lastarg) {
1032              config.lru_test_mode = 1;
1033              config.lru_test_sample_size = strtoll(argv[++i],NULL,10);
1034          } else if (!strcmp(argv[i],"--slave")) {
1035              config.slave_mode = 1;
1036          } else if (!strcmp(argv[i],"--replica")) {
1037              config.slave_mode = 1;
1038          } else if (!strcmp(argv[i],"--stat")) {
1039              config.stat_mode = 1;
1040          } else if (!strcmp(argv[i],"--scan")) {
1041              config.scan_mode = 1;
1042          } else if (!strcmp(argv[i],"--pattern") && !lastarg) {
1043              config.pattern = argv[++i];
1044          } else if (!strcmp(argv[i],"--intrinsic-latency") && !lastarg) {
1045              config.intrinsic_latency_mode = 1;
1046              config.intrinsic_latency_duration = atoi(argv[++i]);
1047          } else if (!strcmp(argv[i],"--rdb") && !lastarg) {
1048              config.getrdb_mode = 1;
1049              config.rdb_filename = argv[++i];
1050          } else if (!strcmp(argv[i],"--pipe")) {
1051              config.pipe_mode = 1;
1052          } else if (!strcmp(argv[i],"--pipe-timeout") && !lastarg) {
1053              config.pipe_timeout = atoi(argv[++i]);
1054          } else if (!strcmp(argv[i],"--bigkeys")) {
1055              config.bigkeys = 1;
1056          } else if (!strcmp(argv[i],"--memkeys")) {
1057              config.memkeys = 1;
1058              config.memkeys_samples = 0; &bsol;* use redis default */
1059          } else if (!strcmp(argv[i],"--memkeys-samples")) {
1060              config.memkeys = 1;
1061              config.memkeys_samples = atoi(argv[++i]);
1062          } else if (!strcmp(argv[i],"--hotkeys")) {
1063              config.hotkeys = 1;
1064          } else if (!strcmp(argv[i],"--eval") && !lastarg) {
1065              config.eval = argv[++i];
1066          } else if (!strcmp(argv[i],"--ldb")) {
1067              config.eval_ldb = 1;
1068              config.output = OUTPUT_RAW;
1069          } else if (!strcmp(argv[i],"--ldb-sync-mode")) {
1070              config.eval_ldb = 1;
1071              config.eval_ldb_sync = 1;
1072              config.output = OUTPUT_RAW;
1073          } else if (!strcmp(argv[i],"-c")) {
1074              config.cluster_mode = 1;
1075          } else if (!strcmp(argv[i],"-d") && !lastarg) {
1076              sdsfree(config.mb_delim);
1077              config.mb_delim = sdsnew(argv[++i]);
1078          } else if (!strcmp(argv[i],"--verbose")) {
1079              config.verbose = 1;
1080          } else if (!strcmp(argv[i],"--cluster") && !lastarg) {
1081              if (CLUSTER_MANAGER_MODE()) usage();
1082              char *cmd = argv[++i];
1083              int j = i;
1084              while (j < argc && argv[j][0] != '-') j++;
1085              if (j > i) j--;
1086              createClusterManagerCommand(cmd, j - i, argv + i + 1);
1087              i = j;
1088          } else if (!strcmp(argv[i],"--cluster") && lastarg) {
1089              usage();
1090          } else if (!strcmp(argv[i],"--cluster-replicas") && !lastarg) {
1091              config.cluster_manager_command.replicas = atoi(argv[++i]);
1092          } else if (!strcmp(argv[i],"--cluster-master-id") && !lastarg) {
1093              config.cluster_manager_command.master_id = argv[++i];
1094          } else if (!strcmp(argv[i],"--cluster-from") && !lastarg) {
1095              config.cluster_manager_command.from = argv[++i];
1096          } else if (!strcmp(argv[i],"--cluster-to") && !lastarg) {
1097              config.cluster_manager_command.to = argv[++i];
1098          } else if (!strcmp(argv[i],"--cluster-weight") && !lastarg) {
1099              if (config.cluster_manager_command.weight != NULL) {
1100                  fprintf(stderr, "WARNING: you cannot use --cluster-weight "
1101                                  "more than once.\n"
1102                                  "You can set more weights by adding them "
1103                                  "as a space-separated list, ie:\n"
1104                                  "--cluster-weight n1=w n2=w\n");
1105                  exit(1);
1106              }
1107              int widx = i + 1;
1108              char **weight = argv + widx;
1109              int wargc = 0;
1110              for (; widx < argc; widx++) {
1111                  if (strstr(argv[widx], "--") == argv[widx]) break;
1112                  if (strchr(argv[widx], '=') == NULL) break;
1113                  wargc++;
1114              }
1115              if (wargc > 0) {
1116                  config.cluster_manager_command.weight = weight;
1117                  config.cluster_manager_command.weight_argc = wargc;
1118                  i += wargc;
1119              }
1120          } else if (!strcmp(argv[i],"--cluster-slots") && !lastarg) {
1121              config.cluster_manager_command.slots = atoi(argv[++i]);
1122          } else if (!strcmp(argv[i],"--cluster-timeout") && !lastarg) {
1123              config.cluster_manager_command.timeout = atoi(argv[++i]);
1124          } else if (!strcmp(argv[i],"--cluster-pipeline") && !lastarg) {
1125              config.cluster_manager_command.pipeline = atoi(argv[++i]);
1126          } else if (!strcmp(argv[i],"--cluster-threshold") && !lastarg) {
1127              config.cluster_manager_command.threshold = atof(argv[++i]);
1128          } else if (!strcmp(argv[i],"--cluster-yes")) {
1129              config.cluster_manager_command.flags |=
1130                  CLUSTER_MANAGER_CMD_FLAG_YES;
1131          } else if (!strcmp(argv[i],"--cluster-simulate")) {
1132              config.cluster_manager_command.flags |=
1133                  CLUSTER_MANAGER_CMD_FLAG_SIMULATE;
1134          } else if (!strcmp(argv[i],"--cluster-replace")) {
1135              config.cluster_manager_command.flags |=
1136                  CLUSTER_MANAGER_CMD_FLAG_REPLACE;
1137          } else if (!strcmp(argv[i],"--cluster-copy")) {
1138              config.cluster_manager_command.flags |=
1139                  CLUSTER_MANAGER_CMD_FLAG_COPY;
1140          } else if (!strcmp(argv[i],"--cluster-slave")) {
1141              config.cluster_manager_command.flags |=
1142                  CLUSTER_MANAGER_CMD_FLAG_SLAVE;
1143          } else if (!strcmp(argv[i],"--cluster-use-empty-masters")) {
1144              config.cluster_manager_command.flags |=
1145                  CLUSTER_MANAGER_CMD_FLAG_EMPTYMASTER;
1146          } else if (!strcmp(argv[i],"--cluster-search-multiple-owners")) {
1147              config.cluster_manager_command.flags |=
1148                  CLUSTER_MANAGER_CMD_FLAG_CHECK_OWNERS;
1149          } else if (!strcmp(argv[i],"-v") || !strcmp(argv[i], "--version")) {
1150              sds version = cliVersion();
1151              printf("redis-cli %s\n", version);
1152              sdsfree(version);
1153              exit(0);
1154          } else if (CLUSTER_MANAGER_MODE() && argv[i][0] != '-') {
1155              if (config.cluster_manager_command.argc == 0) {
1156                  int j = i + 1;
1157                  while (j < argc && argv[j][0] != '-') j++;
1158                  int cmd_argc = j - i;
1159                  config.cluster_manager_command.argc = cmd_argc;
1160                  config.cluster_manager_command.argv = argv + i;
1161                  if (cmd_argc > 1) i = j - 1;
1162              }
1163          } else {
1164              if (argv[i][0] == '-') {
1165                  fprintf(stderr,
1166                      "Unrecognized option or bad number of args for: '%s'\n",
1167                      argv[i]);
1168                  exit(1);
1169              } else {
1170                  break;
1171              }
1172          }
1173      }
1174      if (config.eval_ldb && config.eval == NULL) {
1175          fprintf(stderr,"Options --ldb and --ldb-sync-mode require --eval.\n");
1176          fprintf(stderr,"Try %s --help for more information.\n", argv[0]);
1177          exit(1);
1178      }
1179      if (!config.no_auth_warning && config.auth != NULL) {
1180          fputs("Warning: Using a password with '-a' or '-u' option on the command"
1181                " line interface may not be safe.\n", stderr);
1182      }
1183      return i;
1184  }
1185  static void parseEnv() {
1186      char *auth = getenv(REDIS_CLI_AUTH_ENV);
1187      if (auth != NULL && config.auth == NULL) {
1188          config.auth = auth;
1189      }
1190      char *cluster_yes = getenv(REDIS_CLI_CLUSTER_YES_ENV);
1191      if (cluster_yes != NULL && !strcmp(cluster_yes, "1")) {
1192          config.cluster_manager_command.flags |= CLUSTER_MANAGER_CMD_FLAG_YES;
1193      }
1194  }
1195  static sds readArgFromStdin(void) {
1196      char buf[1024];
1197      sds arg = sdsempty();
1198      while(1) {
1199          int nread = (int)read(fileno(stdin),buf,1024);                          WIN_PORT_FIX &bsol;* cast (int) */
1200          if (nread == 0) break;
1201          else if (nread == -1) {
1202              perror("Reading from standard input");
1203              exit(1);
1204          }
1205          arg = sdscatlen(arg,buf,nread);
1206      }
1207      return arg;
1208  }
1209  static void usage(void) {
1210      sds version = cliVersion();
1211      fprintf(stderr,
1212  "redis-cli %s\n"
1213  "\n"
1214  "Usage: redis-cli [OPTIONS] [cmd [arg [arg ...]]]\n"
1215  "  -h <hostname>      Server hostname (default: 127.0.0.1).\n"
1216  "  -p <port>          Server port (default: 6379).\n"
1217  "  -s <socket>        Server socket (overrides hostname and port).\n"
1218  "  -a <password>      Password to use when connecting to the server.\n"
1219  "                     You can also use the " REDIS_CLI_AUTH_ENV " environment\n"
1220  "                     variable to pass this password more safely\n"
1221  "                     (if both are used, this argument takes predecence).\n"
1222  "  -u <uri>           Server URI.\n"
1223  "  -r <repeat>        Execute specified command N times.\n"
1224  "  -i <interval>      When -r is used, waits <interval> seconds per command.\n"
1225  "                     It is possible to specify sub-second times like -i 0.1.\n"
1226  "  -n <db>            Database number.\n"
1227  "  -x                 Read last argument from STDIN.\n"
1228  "  -d <delimiter>     Multi-bulk delimiter in for raw formatting (default: \\n).\n"
1229  "  -c                 Enable cluster mode (follow -ASK and -MOVED redirections).\n"
1230  "  --raw              Use raw formatting for replies (default when STDOUT is\n"
1231  "                     not a tty).\n"
1232  "  --no-raw           Force formatted output even when STDOUT is not a tty.\n"
1233  "  --csv              Output in CSV format.\n"
1234  "  --stat             Print rolling stats about server: mem, clients, ...\n"
1235  "  --latency          Enter a special mode continuously sampling latency.\n"
1236  "                     If you use this mode in an interactive session it runs\n"
1237  "                     forever displaying real-time stats. Otherwise if --raw or\n"
1238  "                     --csv is specified, or if you redirect the output to a non\n"
1239  "                     TTY, it samples the latency for 1 second (you can use\n"
1240  "                     -i to change the interval), then produces a single output\n"
1241  "                     and exits.\n"
1242  "  --latency-history  Like --latency but tracking latency changes over time.\n"
1243  "                     Default time interval is 15 sec. Change it using -i.\n"
1244  "  --latency-dist     Shows latency as a spectrum, requires xterm 256 colors.\n"
1245  "                     Default time interval is 1 sec. Change it using -i.\n"
1246  "  --lru-test <keys>  Simulate a cache workload with an 80-20 distribution.\n"
1247  "  --replica          Simulate a replica showing commands received from the master.\n"
1248  "  --rdb <filename>   Transfer an RDB dump from remote server to local file.\n"
1249  "  --pipe             Transfer raw Redis protocol from stdin to server.\n"
1250  "  --pipe-timeout <n> In --pipe mode, abort with error if after sending all data.\n"
1251  "                     no reply is received within <n> seconds.\n"
1252  "                     Default timeout: %d. Use 0 to wait forever.\n"
1253  "  --bigkeys          Sample Redis keys looking for keys with many elements (complexity).\n"
1254  "  --memkeys          Sample Redis keys looking for keys consuming a lot of memory.\n"
1255  "  --memkeys-samples <n> Sample Redis keys looking for keys consuming a lot of memory.\n"
1256  "                     And define number of key elements to sample\n"
1257  "  --hotkeys          Sample Redis keys looking for hot keys.\n"
1258  "                     only works when maxmemory-policy is *lfu.\n"
1259  "  --scan             List all keys using the SCAN command.\n"
1260  "  --pattern <pat>    Useful with --scan to specify a SCAN pattern.\n"
1261  "  --intrinsic-latency <sec> Run a test to measure intrinsic system latency.\n"
1262  "                     The test will run for the specified amount of seconds.\n"
1263  "  --eval <file>      Send an EVAL command using the Lua script at <file>.\n"
1264  "  --ldb              Used with --eval enable the Redis Lua debugger.\n"
1265  "  --ldb-sync-mode    Like --ldb but uses the synchronous Lua debugger, in\n"
1266  "                     this mode the server is blocked and script changes are\n"
1267  "                     not rolled back from the server memory.\n"
1268  "  --cluster <command> [args...] [opts...]\n"
1269  "                     Cluster Manager command and arguments (see below).\n"
1270  "  --verbose          Verbose mode.\n"
1271  "  --no-auth-warning  Don't show warning message when using password on command\n"
1272  "                     line interface.\n"
1273  "  --help             Output this help and exit.\n"
1274  "  --version          Output version and exit.\n"
1275  "\n",
1276      version, REDIS_CLI_DEFAULT_PIPE_TIMEOUT);
1277      fprintf(stderr,
1278  "Cluster Manager Commands:\n"
1279  "  Use --cluster help to list all available cluster manager commands.\n"
1280  "\n"
1281  "Examples:\n"
1282  "  cat /etc/passwd | redis-cli -x set mypasswd\n"
1283  "  redis-cli get mypasswd\n"
1284  "  redis-cli -r 100 lpush mylist x\n"
1285  "  redis-cli -r 100 -i 1 info | grep used_memory_human:\n"
1286  "  redis-cli --eval myscript.lua key1 key2 , arg1 arg2 arg3\n"
1287  "  redis-cli --scan --pattern '*:12345*'\n"
1288  "\n"
1289  "  (Note: when using --eval the comma separates KEYS[] from ARGV[] items)\n"
1290  "\n"
1291  "When no command is given, redis-cli starts in interactive mode.\n"
1292  "Type \"help\" in interactive mode for information on available commands\n"
1293  "and settings.\n"
1294  "\n");
1295      sdsfree(version);
1296      exit(1);
1297  }
1298  static int confirmWithYes(char *msg) {
1299      if (config.cluster_manager_command.flags & CLUSTER_MANAGER_CMD_FLAG_YES) {
1300          return 1;
1301      }
1302      printf("%s (type 'yes' to accept): ", msg);
1303      fflush(stdout);
1304      char buf[4];
1305      int nread = read(fileno(stdin),buf,4);
1306      buf[3] = '\0';
1307      return (nread != 0 && !strcmp("yes", buf));
1308  }
1309  static char **convertToSds(int count, char** args) {
1310    int j;
1311    char **sds = zmalloc(sizeof(char*)*count);
1312    for(j = 0; j < count; j++)
1313      sds[j] = sdsnew(args[j]);
1314    return sds;
1315  }
1316  static int issueCommandRepeat(int argc, char **argv, PORT_LONG repeat) {
1317      while (1) {
1318          config.cluster_reissue_command = 0;
1319          if (cliSendCommand(argc,argv,(int)repeat) != REDIS_OK) { WIN_PORT_FIX &bsol;* cast (int) */
1320              cliConnect(CC_FORCE);
1321              if (cliSendCommand(argc,argv,(int)repeat) != REDIS_OK) { WIN_PORT_FIX &bsol;* cast (int) */
1322                  cliPrintContextError();
1323                  return REDIS_ERR;
1324              }
1325           }
1326           if (config.cluster_mode && config.cluster_reissue_command) {
1327              cliConnect(CC_FORCE);
1328           } else {
1329               break;
1330          }
1331      }
1332      return REDIS_OK;
1333  }
1334  static int issueCommand(int argc, char **argv) {
1335      return issueCommandRepeat(argc, argv, config.repeat);
1336  }
1337  static sds *cliSplitArgs(char *line, int *argc) {
1338      if (config.eval_ldb && (strstr(line,"eval ") == line ||
1339                              strstr(line,"e ") == line))
1340      {
1341          sds *argv = sds_malloc(sizeof(sds)*2);
1342          *argc = 2;
1343          int len = (int) strlen(line);                                            WIN_PORT_FIX &bsol;* cast int */
1344          int elen = line[1] == ' ' ? 2 : 5; &bsol;* "e " or "eval "? */
1345          argv[0] = sdsnewlen(line,elen-1);
1346          argv[1] = sdsnewlen(line+elen,len-elen);
1347          return argv;
1348      } else {
1349          return sdssplitargs(line,argc);
1350      }
1351  }
1352  void cliSetPreferences(char **argv, int argc, int interactive) {
1353      if (!strcasecmp(argv[0],":set") && argc >= 2) {
1354          if (!strcasecmp(argv[1],"hints")) pref.hints = 1;
1355          else if (!strcasecmp(argv[1],"nohints")) pref.hints = 0;
1356          else {
1357              printf("%sunknown redis-cli preference '%s'\n",
1358                  interactive ? "" : ".redisclirc: ",
1359                  argv[1]);
1360          }
1361      } else {
1362          printf("%sunknown redis-cli internal command '%s'\n",
1363              interactive ? "" : ".redisclirc: ",
1364              argv[0]);
1365      }
1366  }
1367  void cliLoadPreferences(void) {
1368      sds rcfile = getDotfilePath(REDIS_CLI_RCFILE_ENV,REDIS_CLI_RCFILE_DEFAULT);
1369      if (rcfile == NULL) return;
1370      FILE *fp = fopen(rcfile,"r");
1371      char buf[1024];
1372      if (fp) {
1373          while(fgets(buf,sizeof(buf),fp) != NULL) {
1374              sds *argv;
1375              int argc;
1376              argv = sdssplitargs(buf,&argc);
1377              if (argc > 0) cliSetPreferences(argv,argc,0);
1378              sdsfreesplitres(argv,argc);
1379          }
1380          fclose(fp);
1381      }
1382      sdsfree(rcfile);
1383  }
1384  static void repl(void) {
1385      sds historyfile = NULL;
1386      int history = 0;
1387      char *line;
1388      int argc;
1389      sds *argv;
1390      cliInitHelp();
1391      cliIntegrateHelp();
1392      config.interactive = 1;
1393      linenoiseSetMultiLine(1);
1394      linenoiseSetCompletionCallback(completionCallback);
1395      linenoiseSetHintsCallback(hintsCallback);
1396      linenoiseSetFreeHintsCallback(freeHintsCallback);
1397      if (isatty(fileno(stdin))) {
1398          historyfile = getDotfilePath(REDIS_CLI_HISTFILE_ENV,REDIS_CLI_HISTFILE_DEFAULT);
1399          history = 1;
1400          if (historyfile != NULL) {
1401              linenoiseHistoryLoad(historyfile);
1402          }
1403          cliLoadPreferences();
1404      }
1405      cliRefreshPrompt();
1406      while((line = linenoise(context ? config.prompt : "not connected> ")) != NULL) {
1407          if (line[0] != '\0') {
1408              PORT_LONG repeat = 1;
1409              int skipargs = 0;
1410              char *endptr = NULL;
1411              argv = cliSplitArgs(line,&argc);
1412              if (argv && argc > 0) {
1413                  errno = 0;
1414                  repeat = strtol(argv[0], &endptr, 10);
1415                  if (argc > 1 && *endptr == '\0') {
1416                      if (errno == ERANGE || errno == EINVAL || repeat <= 0) {
1417                          fputs("Invalid redis-cli repeat command option value.\n", stdout);
1418                          sdsfreesplitres(argv, argc);
1419                          linenoiseFree(line);
1420                          continue;
1421                      }
1422                      skipargs = 1;
1423                  } else {
1424                      repeat = 1;
1425                  }
1426              }
1427              if (!(argv && argc > 0 && !strcasecmp(argv[0+skipargs], "auth"))) {
1428                  if (history) linenoiseHistoryAdd(line);
1429                  if (historyfile) linenoiseHistorySave(historyfile);
1430              }
1431              if (argv == NULL) {
1432                  printf("Invalid argument(s)\n");
1433                  linenoiseFree(line);
1434                  continue;
1435              } else if (argc > 0) {
1436                  if (strcasecmp(argv[0],"quit") == 0 ||
1437                      strcasecmp(argv[0],"exit") == 0)
1438                  {
1439                      exit(0);
1440                  } else if (argv[0][0] == ':') {
1441                      cliSetPreferences(argv,argc,1);
1442                      sdsfreesplitres(argv,argc);
1443                      linenoiseFree(line);
1444                      continue;
1445                  } else if (strcasecmp(argv[0],"restart") == 0) {
1446                      if (config.eval) {
1447                          config.eval_ldb = 1;
1448                          config.output = OUTPUT_RAW;
1449                          return; &bsol;* Return to evalMode to restart the session. */
1450                      } else {
1451                          printf("Use 'restart' only in Lua debugging mode.");
1452                      }
1453                  } else if (argc == 3 && !strcasecmp(argv[0],"connect")) {
1454                      sdsfree(config.hostip);
1455                      config.hostip = sdsnew(argv[1]);
1456                      config.hostport = atoi(argv[2]);
1457                      cliRefreshPrompt();
1458                      cliConnect(CC_FORCE);
1459                  } else if (argc == 1 && !strcasecmp(argv[0],"clear")) {
1460                      linenoiseClearScreen();
1461                  } else {
1462                      PORT_LONGLONG start_time = mstime(), elapsed;
1463                      issueCommandRepeat(argc-skipargs, argv+skipargs, repeat);
1464                      if (config.eval_ldb_end) {
1465                          config.eval_ldb_end = 0;
1466                          cliReadReply(0);
1467                          printf("\n(Lua debugging session ended%s)\n\n",
1468                              config.eval_ldb_sync ? "" :
1469                              " -- dataset changes rolled back");
1470                      }
1471                      elapsed = mstime()-start_time;
1472                      if (elapsed >= 500 &&
1473                          config.output == OUTPUT_STANDARD)
1474                      {
1475                          printf("(%.2fs)\n",(double)elapsed/1000);
1476                      }
1477                  }
1478              }
1479              sdsfreesplitres(argv,argc);
1480          }
1481          linenoiseFree(line);
1482      }
1483      exit(0);
1484  }
1485  static int noninteractive(int argc, char **argv) {
1486      int retval = 0;
1487      if (config.stdinarg) {
1488          argv = zrealloc(argv, (argc+1)*sizeof(char*));
1489          argv[argc] = readArgFromStdin();
1490          retval = issueCommand(argc+1, argv);
1491      } else {
1492          retval = issueCommand(argc, argv);
1493      }
1494      return retval;
1495  }
1496  static int evalMode(int argc, char **argv) {
1497      sds script = NULL;
1498      FILE *fp;
1499      char buf[1024];
1500      size_t nread;
1501      char **argv2;
1502      int j, got_comma, keys;
1503      int retval = REDIS_OK;
1504      while(1) {
1505          if (config.eval_ldb) {
1506              printf(
1507              "Lua debugging session started, please use:\n"
1508              "quit    -- End the session.\n"
1509              "restart -- Restart the script in debug mode again.\n"
1510              "help    -- Show Lua script debugging commands.\n\n"
1511              );
1512          }
1513          sdsfree(script);
1514          script = sdsempty();
1515          got_comma = 0;
1516          keys = 0;
1517          fp = fopen(config.eval,"r");
1518          if (!fp) {
1519              fprintf(stderr,
1520                  "Can't open file '%s': %s\n", config.eval, strerror(errno));
1521              exit(1);
1522          }
1523          while((nread = fread(buf,1,sizeof(buf),fp)) != 0) {
1524              script = sdscatlen(script,buf,nread);
1525          }
1526          fclose(fp);
1527          if (config.eval_ldb) {
1528              redisReply *reply = redisCommand(context,
1529                      config.eval_ldb_sync ?
1530                      "SCRIPT DEBUG sync": "SCRIPT DEBUG yes");
1531              if (reply) freeReplyObject(reply);
1532          }
1533          argv2 = zmalloc(sizeof(sds)*(argc+3));
1534          argv2[0] = sdsnew("EVAL");
1535          argv2[1] = script;
1536          for (j = 0; j < argc; j++) {
1537              if (!got_comma && argv[j][0] == ',' && argv[j][1] == 0) {
1538                  got_comma = 1;
1539                  continue;
1540              }
1541              argv2[j+3-got_comma] = sdsnew(argv[j]);
1542              if (!got_comma) keys++;
1543          }
1544          argv2[2] = sdscatprintf(sdsempty(),"%d",keys);
1545          int eval_ldb = config.eval_ldb; &bsol;* Save it, may be reverteed. */
1546          retval = issueCommand(argc+3-got_comma, argv2);
1547          if (eval_ldb) {
1548              if (!config.eval_ldb) {
1549                  printf("Eval debugging session can't start:\n");
1550                  cliReadReply(0);
1551                  break; &bsol;* Return to the caller. */
1552              } else {
1553                  strncpy(config.prompt,"lua debugger> ",sizeof(config.prompt));
1554                  repl();
1555                  cliConnect(CC_FORCE);
1556                  printf("\n");
1557              }
1558          } else {
1559              break; &bsol;* Return to the caller. */
1560          }
1561      }
1562      return retval;
1563  }
1564  static struct clusterManager {
1565      list *nodes;    &bsol;* List of nodes in the configuration. */
1566      list *errors;
1567  } cluster_manager;
1568  dict *clusterManagerUncoveredSlots = NULL;
1569  typedef struct clusterManagerNode {
1570      redisContext *context;
1571      sds name;
1572      char *ip;
1573      int port;
1574      uint64_t current_epoch;
1575      time_t ping_sent;
1576      time_t ping_recv;
1577      int flags;
1578      list *flags_str; &bsol;* Flags string representations */
1579      sds replicate;  &bsol;* Master ID if node is a slave */
1580      int dirty;      &bsol;* Node has changes that can be flushed */
1581      uint8_t slots[CLUSTER_MANAGER_SLOTS];
1582      int slots_count;
1583      int replicas_count;
1584      list *friends;
1585      sds *migrating; &bsol;* An array of sds where even strings are slots and odd
1586                       * strings are the destination node IDs. */
1587      sds *importing; &bsol;* An array of sds where even strings are slots and odd
1588                       * strings are the source node IDs. */
1589      int migrating_count; &bsol;* Length of the migrating array (migrating slots*2) */
1590      int importing_count; &bsol;* Length of the importing array (importing slots*2) */
1591      float weight;   &bsol;* Weight used by rebalance */
1592      int balance;    &bsol;* Used by rebalance */
1593  } clusterManagerNode;
1594  typedef struct clusterManagerNodeArray {
1595      clusterManagerNode **nodes; &bsol;* Actual nodes array */
1596      clusterManagerNode **alloc; &bsol;* Pointer to the allocated memory */
1597      int len;                    &bsol;* Actual length of the array */
1598      int count;                  &bsol;* Non-NULL nodes count */
1599  } clusterManagerNodeArray;
1600  typedef struct clusterManagerReshardTableItem {
1601      clusterManagerNode *source;
1602      int slot;
1603  } clusterManagerReshardTableItem;
1604  static dictType clusterManagerDictType = {
1605      dictSdsHash,               &bsol;* hash function */
1606      NULL,                      &bsol;* key dup */
1607      NULL,                      &bsol;* val dup */
1608      dictSdsKeyCompare,         &bsol;* key compare */
1609      NULL,                      &bsol;* key destructor */
1610      dictSdsDestructor          &bsol;* val destructor */
1611  };
1612  typedef int clusterManagerCommandProc(int argc, char **argv);
1613  typedef int (*clusterManagerOnReplyError)(redisReply *reply, int bulk_idx);
1614  static clusterManagerNode *clusterManagerNewNode(char *ip, int port);
1615  static clusterManagerNode *clusterManagerNodeByName(const char *name);
1616  static clusterManagerNode *clusterManagerNodeByAbbreviatedName(const char *n);
1617  static void clusterManagerNodeResetSlots(clusterManagerNode *node);
1618  static int clusterManagerNodeIsCluster(clusterManagerNode *node, char **err);
1619  static void clusterManagerPrintNotClusterNodeError(clusterManagerNode *node,
1620                                                     char *err);
1621  static int clusterManagerNodeLoadInfo(clusterManagerNode *node, int opts,
1622                                        char **err);
1623  static int clusterManagerLoadInfoFromNode(clusterManagerNode *node, int opts);
1624  static int clusterManagerNodeIsEmpty(clusterManagerNode *node, char **err);
1625  static int clusterManagerGetAntiAffinityScore(clusterManagerNodeArray *ipnodes,
1626      int ip_count, clusterManagerNode ***offending, int *offending_len);
1627  static void clusterManagerOptimizeAntiAffinity(clusterManagerNodeArray *ipnodes,
1628      int ip_count);
1629  static sds clusterManagerNodeInfo(clusterManagerNode *node, int indent);
1630  static void clusterManagerShowNodes(void);
1631  static void clusterManagerShowClusterInfo(void);
1632  static int clusterManagerFlushNodeConfig(clusterManagerNode *node, char **err);
1633  static void clusterManagerWaitForClusterJoin(void);
1634  static int clusterManagerCheckCluster(int quiet);
1635  static void clusterManagerLog(int level, const char* fmt, ...);
1636  static int clusterManagerIsConfigConsistent(void);
1637  static void clusterManagerOnError(sds err);
1638  static void clusterManagerNodeArrayInit(clusterManagerNodeArray *array,
1639                                          int len);
1640  static void clusterManagerNodeArrayReset(clusterManagerNodeArray *array);
1641  static void clusterManagerNodeArrayShift(clusterManagerNodeArray *array,
1642                                           clusterManagerNode **nodeptr);
1643  static void clusterManagerNodeArrayAdd(clusterManagerNodeArray *array,
1644                                         clusterManagerNode *node);
1645  static int clusterManagerCommandCreate(int argc, char **argv);
1646  static int clusterManagerCommandAddNode(int argc, char **argv);
1647  static int clusterManagerCommandDeleteNode(int argc, char **argv);
1648  static int clusterManagerCommandInfo(int argc, char **argv);
1649  static int clusterManagerCommandCheck(int argc, char **argv);
1650  static int clusterManagerCommandFix(int argc, char **argv);
1651  static int clusterManagerCommandReshard(int argc, char **argv);
1652  static int clusterManagerCommandRebalance(int argc, char **argv);
1653  static int clusterManagerCommandSetTimeout(int argc, char **argv);
1654  static int clusterManagerCommandImport(int argc, char **argv);
1655  static int clusterManagerCommandCall(int argc, char **argv);
1656  static int clusterManagerCommandHelp(int argc, char **argv);
1657  typedef struct clusterManagerCommandDef {
1658      char *name;
1659      clusterManagerCommandProc *proc;
1660      int arity;
1661      char *args;
1662      char *options;
1663  } clusterManagerCommandDef;
1664  clusterManagerCommandDef clusterManagerCommands[] = {
1665      {"create", clusterManagerCommandCreate, -2, "host1:port1 ... hostN:portN",
1666       "replicas <arg>"},
1667      {"check", clusterManagerCommandCheck, -1, "host:port",
1668       "search-multiple-owners"},
1669      {"info", clusterManagerCommandInfo, -1, "host:port", NULL},
1670      {"fix", clusterManagerCommandFix, -1, "host:port",
1671       "search-multiple-owners"},
1672      {"reshard", clusterManagerCommandReshard, -1, "host:port",
1673       "from <arg>,to <arg>,slots <arg>,yes,timeout <arg>,pipeline <arg>,"
1674       "replace"},
1675      {"rebalance", clusterManagerCommandRebalance, -1, "host:port",
1676       "weight <node1=w1...nodeN=wN>,use-empty-masters,"
1677       "timeout <arg>,simulate,pipeline <arg>,threshold <arg>,replace"},
1678      {"add-node", clusterManagerCommandAddNode, 2,
1679       "new_host:new_port existing_host:existing_port", "slave,master-id <arg>"},
1680      {"del-node", clusterManagerCommandDeleteNode, 2, "host:port node_id",NULL},
1681      {"call", clusterManagerCommandCall, -2,
1682          "host:port command arg arg .. arg", NULL},
1683      {"set-timeout", clusterManagerCommandSetTimeout, 2,
1684       "host:port milliseconds", NULL},
1685      {"import", clusterManagerCommandImport, 1, "host:port",
1686       "from <arg>,copy,replace"},
1687      {"help", clusterManagerCommandHelp, 0, NULL, NULL}
1688  };
1689  static void createClusterManagerCommand(char *cmdname, int argc, char **argv) {
1690      clusterManagerCommand *cmd = &config.cluster_manager_command;
1691      cmd->name = cmdname;
1692      cmd->argc = argc;
1693      cmd->argv = argc ? argv : NULL;
1694      if (isColorTerm()) cmd->flags |= CLUSTER_MANAGER_CMD_FLAG_COLOR;
1695  }
1696  static clusterManagerCommandProc *validateClusterManagerCommand(void) {
1697      int i, commands_count = sizeof(clusterManagerCommands) /
1698                              sizeof(clusterManagerCommandDef);
1699      clusterManagerCommandProc *proc = NULL;
1700      char *cmdname = config.cluster_manager_command.name;
1701      int argc = config.cluster_manager_command.argc;
1702      for (i = 0; i < commands_count; i++) {
1703          clusterManagerCommandDef cmddef = clusterManagerCommands[i];
1704          if (!strcmp(cmddef.name, cmdname)) {
1705              if ((cmddef.arity > 0 && argc != cmddef.arity) ||
1706                  (cmddef.arity < 0 && argc < (cmddef.arity * -1))) {
1707                  fprintf(stderr, "[ERR] Wrong number of arguments for "
1708                                  "specified --cluster sub command\n");
1709                  return NULL;
1710              }
1711              proc = cmddef.proc;
1712          }
1713      }
1714      if (!proc) fprintf(stderr, "Unknown --cluster subcommand\n");
1715      return proc;
1716  }
1717  static int getClusterHostFromCmdArgs(int argc, char **argv,
1718                                       char **ip_ptr, int *port_ptr) {
1719      int port = 0;
1720      char *ip = NULL;
1721      if (argc == 1) {
1722          char *addr = argv[0];
1723          char *c = strrchr(addr, '@');
1724          if (c != NULL) *c = '\0';
1725          c = strrchr(addr, ':');
1726          if (c != NULL) {
1727              *c = '\0';
1728              ip = addr;
1729              port = atoi(++c);
1730          } else return 0;
1731      } else {
1732          ip = argv[0];
1733          port = atoi(argv[1]);
1734      }
1735      if (!ip || !port) return 0;
1736      else {
1737          *ip_ptr = ip;
1738          *port_ptr = port;
1739      }
1740      return 1;
1741  }
1742  static void freeClusterManagerNodeFlags(list *flags) {
1743      listIter li;
1744      listNode *ln;
1745      listRewind(flags, &li);
1746      while ((ln = listNext(&li)) != NULL) {
1747          sds flag = ln->value;
1748          sdsfree(flag);
1749      }
1750      listRelease(flags);
1751  }
1752  static void freeClusterManagerNode(clusterManagerNode *node) {
1753      if (node->context != NULL) redisFree(node->context);
1754      if (node->friends != NULL) {
1755          listIter li;
1756          listNode *ln;
1757          listRewind(node->friends,&li);
1758          while ((ln = listNext(&li)) != NULL) {
1759              clusterManagerNode *fn = ln->value;
1760              freeClusterManagerNode(fn);
1761          }
1762          listRelease(node->friends);
1763          node->friends = NULL;
1764      }
1765      if (node->name != NULL) sdsfree(node->name);
1766      if (node->replicate != NULL) sdsfree(node->replicate);
1767      if ((node->flags & CLUSTER_MANAGER_FLAG_FRIEND) && node->ip)
1768          sdsfree(node->ip);
1769      int i;
1770      if (node->migrating != NULL) {
1771          for (i = 0; i < node->migrating_count; i++) sdsfree(node->migrating[i]);
1772          zfree(node->migrating);
1773      }
1774      if (node->importing != NULL) {
1775          for (i = 0; i < node->importing_count; i++) sdsfree(node->importing[i]);
1776          zfree(node->importing);
1777      }
1778      if (node->flags_str != NULL) {
1779          freeClusterManagerNodeFlags(node->flags_str);
1780          node->flags_str = NULL;
1781      }
1782      zfree(node);
1783  }
1784  static void freeClusterManager(void) {
1785      listIter li;
1786      listNode *ln;
1787      if (cluster_manager.nodes != NULL) {
1788          listRewind(cluster_manager.nodes,&li);
1789          while ((ln = listNext(&li)) != NULL) {
1790              clusterManagerNode *n = ln->value;
1791              freeClusterManagerNode(n);
1792          }
1793          listRelease(cluster_manager.nodes);
1794          cluster_manager.nodes = NULL;
1795      }
1796      if (cluster_manager.errors != NULL) {
1797          listRewind(cluster_manager.errors,&li);
1798          while ((ln = listNext(&li)) != NULL) {
1799              sds err = ln->value;
1800              sdsfree(err);
1801          }
1802          listRelease(cluster_manager.errors);
1803          cluster_manager.errors = NULL;
1804      }
1805      if (clusterManagerUncoveredSlots != NULL)
1806          dictRelease(clusterManagerUncoveredSlots);
1807  }
1808  static clusterManagerNode *clusterManagerNewNode(char *ip, int port) {
1809      clusterManagerNode *node = zmalloc(sizeof(*node));
1810      node->context = NULL;
1811      node->name = NULL;
1812      node->ip = ip;
1813      node->port = port;
1814      node->current_epoch = 0;
1815      node->ping_sent = 0;
1816      node->ping_recv = 0;
1817      node->flags = 0;
1818      node->flags_str = NULL;
1819      node->replicate = NULL;
1820      node->dirty = 0;
1821      node->friends = NULL;
1822      node->migrating = NULL;
1823      node->importing = NULL;
1824      node->migrating_count = 0;
1825      node->importing_count = 0;
1826      node->replicas_count = 0;
1827      node->weight = 1.0f;
1828      node->balance = 0;
1829      clusterManagerNodeResetSlots(node);
1830      return node;
1831  }
1832  static int clusterManagerCheckRedisReply(clusterManagerNode *n,
1833                                           redisReply *r, char **err)
1834  {
1835      int is_err = 0;
1836      if (!r || (is_err = (r->type == REDIS_REPLY_ERROR))) {
1837          if (is_err) {
1838              if (err != NULL) {
1839                  *err = zmalloc((r->len + 1) * sizeof(char));
1840                  strcpy(*err, r->str);
1841              } else CLUSTER_MANAGER_PRINT_REPLY_ERROR(n, r->str);
1842          }
1843          return 0;
1844      }
1845      return 1;
1846  }
1847  static int clusterManagerStartTransaction(clusterManagerNode *node) {
1848      redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "MULTI");
1849      int success = clusterManagerCheckRedisReply(node, reply, NULL);
1850      if (reply) freeReplyObject(reply);
1851      return success;
1852  }
1853  static int clusterManagerExecTransaction(clusterManagerNode *node,
1854                                           clusterManagerOnReplyError onerror)
1855  {
1856      redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "EXEC");
1857      int success = clusterManagerCheckRedisReply(node, reply, NULL);
1858      if (success) {
1859          if (reply->type != REDIS_REPLY_ARRAY) {
1860              success = 0;
1861              goto cleanup;
1862          }
1863          size_t i;
1864          for (i = 0; i < reply->elements; i++) {
1865              redisReply *r = reply->element[i];
1866              char *err = NULL;
1867              success = clusterManagerCheckRedisReply(node, r, &err);
1868              if (!success && onerror) success = onerror(r, i);
1869              if (err) {
1870                  if (!success)
1871                      CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
1872                  zfree(err);
1873              }
1874              if (!success) break;
1875          }
1876      }
1877  cleanup:
1878      if (reply) freeReplyObject(reply);
1879      return success;
1880  }
1881  static int clusterManagerNodeConnect(clusterManagerNode *node) {
1882      if (node->context) redisFree(node->context);
1883      node->context = redisConnect(node->ip, node->port);
1884      if (node->context->err) {
1885          fprintf(stderr,"Could not connect to Redis at ");
1886          fprintf(stderr,"%s:%d: %s\n", node->ip, node->port,
1887                  node->context->errstr);
1888          redisFree(node->context);
1889          node->context = NULL;
1890          return 0;
1891      }
1892      anetKeepAlive(NULL, node->context->fd, REDIS_CLI_KEEPALIVE_INTERVAL);
1893      if (config.auth) {
1894          redisReply *reply = redisCommand(node->context,"AUTH %s",config.auth);
1895          int ok = clusterManagerCheckRedisReply(node, reply, NULL);
1896          if (reply != NULL) freeReplyObject(reply);
1897          if (!ok) return 0;
1898      }
1899      return 1;
1900  }
1901  static void clusterManagerRemoveNodeFromList(list *nodelist,
1902                                               clusterManagerNode *node) {
1903      listIter li;
1904      listNode *ln;
1905      listRewind(nodelist, &li);
1906      while ((ln = listNext(&li)) != NULL) {
1907          if (node == ln->value) {
1908              listDelNode(nodelist, ln);
1909              break;
1910          }
1911      }
1912  }
1913  static clusterManagerNode *clusterManagerNodeByName(const char *name) {
1914      if (cluster_manager.nodes == NULL) return NULL;
1915      clusterManagerNode *found = NULL;
1916      sds lcname = sdsempty();
1917      lcname = sdscpy(lcname, name);
1918      sdstolower(lcname);
1919      listIter li;
1920      listNode *ln;
1921      listRewind(cluster_manager.nodes, &li);
1922      while ((ln = listNext(&li)) != NULL) {
1923          clusterManagerNode *n = ln->value;
1924          if (n->name && !sdscmp(n->name, lcname)) {
1925              found = n;
1926              break;
1927          }
1928      }
1929      sdsfree(lcname);
1930      return found;
1931  }
1932  static clusterManagerNode *clusterManagerNodeByAbbreviatedName(const char*name)
1933  {
1934      if (cluster_manager.nodes == NULL) return NULL;
1935      clusterManagerNode *found = NULL;
1936      sds lcname = sdsempty();
1937      lcname = sdscpy(lcname, name);
1938      sdstolower(lcname);
1939      listIter li;
1940      listNode *ln;
1941      listRewind(cluster_manager.nodes, &li);
1942      while ((ln = listNext(&li)) != NULL) {
1943          clusterManagerNode *n = ln->value;
1944          if (n->name &&
1945              strstr(n->name, lcname) == n->name) {
1946              found = n;
1947              break;
1948          }
1949      }
1950      sdsfree(lcname);
1951      return found;
1952  }
1953  static void clusterManagerNodeResetSlots(clusterManagerNode *node) {
1954      memset(node->slots, 0, sizeof(node->slots));
1955      node->slots_count = 0;
1956  }
1957  static redisReply *clusterManagerGetNodeRedisInfo(clusterManagerNode *node,
1958                                                    char **err)
1959  {
1960      redisReply *info = CLUSTER_MANAGER_COMMAND(node, "INFO");
1961      if (err != NULL) *err = NULL;
1962      if (info == NULL) return NULL;
1963      if (info->type == REDIS_REPLY_ERROR) {
1964          if (err != NULL) {
1965              *err = zmalloc((info->len + 1) * sizeof(char));
1966              strcpy(*err, info->str);
1967          }
1968          freeReplyObject(info);
1969          return  NULL;
1970      }
1971      return info;
1972  }
1973  static int clusterManagerNodeIsCluster(clusterManagerNode *node, char **err) {
1974      redisReply *info = clusterManagerGetNodeRedisInfo(node, err);
1975      if (info == NULL) return 0;
1976      int is_cluster = (int) getLongInfoField(info->str, "cluster_enabled");
1977      freeReplyObject(info);
1978      return is_cluster;
1979  }
1980  static int clusterManagerNodeIsEmpty(clusterManagerNode *node, char **err) {
1981      redisReply *info = clusterManagerGetNodeRedisInfo(node, err);
1982      int is_empty = 1;
1983      if (info == NULL) return 0;
1984      if (strstr(info->str, "db0:") != NULL) {
1985          is_empty = 0;
1986          goto result;
1987      }
1988      freeReplyObject(info);
1989      info = CLUSTER_MANAGER_COMMAND(node, "CLUSTER INFO");
1990      if (err != NULL) *err = NULL;
1991      if (!clusterManagerCheckRedisReply(node, info, err)) {
1992          is_empty = 0;
1993          goto result;
1994      }
1995      PORT_LONG known_nodes = getLongInfoField(info->str, "cluster_known_nodes");
1996      is_empty = (known_nodes == 1);
1997  result:
1998      freeReplyObject(info);
1999      return is_empty;
2000  }
2001  static int clusterManagerGetAntiAffinityScore(clusterManagerNodeArray *ipnodes,
2002      int ip_count, clusterManagerNode ***offending, int *offending_len)
2003  {
2004      int score = 0, i, j;
2005      int node_len = cluster_manager.nodes->len;
2006      clusterManagerNode **offending_p = NULL;
2007      if (offending != NULL) {
2008          *offending = zcalloc(node_len * sizeof(clusterManagerNode*));
2009          offending_p = *offending;
2010      }
2011      for (i = 0; i < ip_count; i++) {
2012          clusterManagerNodeArray *node_array = &(ipnodes[i]);
2013          dict *related = dictCreate(&clusterManagerDictType, NULL);
2014          char *ip = NULL;
2015          for (j = 0; j < node_array->len; j++) {
2016              clusterManagerNode *node = node_array->nodes[j];
2017              if (node == NULL) continue;
2018              if (!ip) ip = node->ip;
2019              sds types;
2020              sds key = (!node->replicate ? node->name : node->replicate);
2021              assert(key != NULL);
2022              dictEntry *entry = dictFind(related, key);
2023              if (entry) types = sdsdup((sds) dictGetVal(entry));
2024              else types = sdsempty();
2025              if (!node->replicate) types = sdscatprintf(types, "m%s", types);
2026              else types = sdscat(types, "s");
2027              dictReplace(related, key, types);
2028          }
2029          dictIterator *iter = dictGetIterator(related);
2030          dictEntry *entry;
2031          while ((entry = dictNext(iter)) != NULL) {
2032              sds types = (sds) dictGetVal(entry);
2033              sds name = (sds) dictGetKey(entry);
2034              int typeslen = sdslen(types);
2035              if (typeslen < 2) continue;
2036              if (types[0] == 'm') score += (10000 * (typeslen - 1));
2037              else score += (1 * typeslen);
2038              if (offending == NULL) continue;
2039              listIter li;
2040              listNode *ln;
2041              listRewind(cluster_manager.nodes, &li);
2042              while ((ln = listNext(&li)) != NULL) {
2043                  clusterManagerNode *n = ln->value;
2044                  if (n->replicate == NULL) continue;
2045                  if (!strcmp(n->replicate, name) && !strcmp(n->ip, ip)) {
2046                      *(offending_p++) = n;
2047                      if (offending_len != NULL) (*offending_len)++;
2048                      break;
2049                  }
2050              }
2051          }
2052          dictReleaseIterator(iter);
2053          dictRelease(related);
2054      }
2055      return score;
2056  }
2057  static void clusterManagerOptimizeAntiAffinity(clusterManagerNodeArray *ipnodes,
2058      int ip_count)
2059  {
2060      clusterManagerNode **offenders = NULL;
2061      int score = clusterManagerGetAntiAffinityScore(ipnodes, ip_count,
2062                                                     NULL, NULL);
2063      if (score == 0) goto cleanup;
2064      clusterManagerLogInfo(">>> Trying to optimize slaves allocation "
2065                            "for anti-affinity\n");
2066      int node_len = cluster_manager.nodes->len;
2067      int maxiter = 500 * node_len; 
2068      srand(time(NULL));
2069      while (maxiter > 0) {
2070          int offending_len = 0;
2071          if (offenders != NULL) {
2072              zfree(offenders);
2073              offenders = NULL;
2074          }
2075          score = clusterManagerGetAntiAffinityScore(ipnodes,
2076                                                     ip_count,
2077                                                     &offenders,
2078                                                     &offending_len);
2079          if (score == 0) break; 
2080          int rand_idx = rand() % offending_len;
2081          clusterManagerNode *first = offenders[rand_idx],
2082                             *second = NULL;
2083          clusterManagerNode **other_replicas = zcalloc((node_len - 1) *
2084                                                        sizeof(*other_replicas));
2085          int other_replicas_count = 0;
2086          listIter li;
2087          listNode *ln;
2088          listRewind(cluster_manager.nodes, &li);
2089          while ((ln = listNext(&li)) != NULL) {
2090              clusterManagerNode *n = ln->value;
2091              if (n != first && n->replicate != NULL)
2092                  other_replicas[other_replicas_count++] = n;
2093          }
2094          if (other_replicas_count == 0) {
2095              zfree(other_replicas);
2096              break;
2097          }
2098          rand_idx = rand() % other_replicas_count;
2099          second = other_replicas[rand_idx];
2100          char *first_master = first->replicate,
2101               *second_master = second->replicate;
2102          first->replicate = second_master, first->dirty = 1;
2103          second->replicate = first_master, second->dirty = 1;
2104          int new_score = clusterManagerGetAntiAffinityScore(ipnodes,
2105                                                             ip_count,
2106                                                             NULL, NULL);
2107          if (new_score > score) {
2108              first->replicate = first_master;
2109              second->replicate = second_master;
2110          }
2111          zfree(other_replicas);
2112          maxiter--;
2113      }
2114      score = clusterManagerGetAntiAffinityScore(ipnodes, ip_count, NULL, NULL);
2115      char *msg;
2116      int perfect = (score == 0);
2117      int log_level = (perfect ? CLUSTER_MANAGER_LOG_LVL_SUCCESS :
2118                                 CLUSTER_MANAGER_LOG_LVL_WARN);
2119      if (perfect) msg = "[OK] Perfect anti-affinity obtained!";
2120      else if (score >= 10000)
2121          msg = ("[WARNING] Some slaves are in the same host as their master");
2122      else
2123          msg=("[WARNING] Some slaves of the same master are in the same host");
2124      clusterManagerLog(log_level, "%s\n", msg);
2125  cleanup:
2126      zfree(offenders);
2127  }
2128  static sds clusterManagerNodeFlagString(clusterManagerNode *node) {
2129      sds flags = sdsempty();
2130      if (!node->flags_str) return flags;
2131      int empty = 1;
2132      listIter li;
2133      listNode *ln;
2134      listRewind(node->flags_str, &li);
2135      while ((ln = listNext(&li)) != NULL) {
2136          sds flag = ln->value;
2137          if (strcmp(flag, "myself") == 0) continue;
2138          if (!empty) flags = sdscat(flags, ",");
2139          flags = sdscatfmt(flags, "%S", flag);
2140          empty = 0;
2141      }
2142      return flags;
2143  }
2144  static sds clusterManagerNodeSlotsString(clusterManagerNode *node) {
2145      sds slots = sdsempty();
2146      int first_range_idx = -1, last_slot_idx = -1, i;
2147      for (i = 0; i < CLUSTER_MANAGER_SLOTS; i++) {
2148          int has_slot = node->slots[i];
2149          if (has_slot) {
2150              if (first_range_idx == -1) {
2151                  if (sdslen(slots)) slots = sdscat(slots, ",");
2152                  first_range_idx = i;
2153                  slots = sdscatfmt(slots, "[%u", i);
2154              }
2155              last_slot_idx = i;
2156          } else {
2157              if (last_slot_idx >= 0) {
2158                  if (first_range_idx == last_slot_idx)
2159                      slots = sdscat(slots, "]");
2160                  else slots = sdscatfmt(slots, "-%u]", last_slot_idx);
2161              }
2162              last_slot_idx = -1;
2163              first_range_idx = -1;
2164          }
2165      }
2166      if (last_slot_idx >= 0) {
2167          if (first_range_idx == last_slot_idx) slots = sdscat(slots, "]");
2168          else slots = sdscatfmt(slots, "-%u]", last_slot_idx);
2169      }
2170      return slots;
2171  }
2172  static unsigned int clusterManagerKeyHashSlot(char *key, int keylen) {
2173      int s, e; &bsol;* start-end indexes of { and } */
2174      for (s = 0; s < keylen; s++)
2175          if (key[s] == '{') break;
2176      if (s == keylen) return crc16(key,keylen) & 0x3FFF;
2177      for (e = s+1; e < keylen; e++)
2178          if (key[e] == '}') break;
2179      if (e == keylen || e == s+1) return crc16(key,keylen) & 0x3FFF;
2180      return crc16(key+s+1,e-s-1) & 0x3FFF;
2181  }
2182  static sds clusterManagerNodeInfo(clusterManagerNode *node, int indent) {
2183      sds info = sdsempty();
2184      sds spaces = sdsempty();
2185      int i;
2186      for (i = 0; i < indent; i++) spaces = sdscat(spaces, " ");
2187      if (indent) info = sdscat(info, spaces);
2188      int is_master = !(node->flags & CLUSTER_MANAGER_FLAG_SLAVE);
2189      char *role = (is_master ? "M" : "S");
2190      sds slots = NULL;
2191      if (node->dirty && node->replicate != NULL)
2192          info = sdscatfmt(info, "S: %S %s:%u", node->name, node->ip, node->port);
2193      else {
2194          slots = clusterManagerNodeSlotsString(node);
2195          sds flags = clusterManagerNodeFlagString(node);
2196          info = sdscatfmt(info, "%s: %S %s:%u\n"
2197                                 "%s   slots:%S (%u slots) "
2198                                 "%S",
2199                                 role, node->name, node->ip, node->port, spaces,
2200                                 slots, node->slots_count, flags);
2201          sdsfree(slots);
2202          sdsfree(flags);
2203      }
2204      if (node->replicate != NULL)
2205          info = sdscatfmt(info, "\n%s   replicates %S", spaces, node->replicate);
2206      else if (node->replicas_count)
2207          info = sdscatfmt(info, "\n%s   %U additional replica(s)",
2208                           spaces, node->replicas_count);
2209      sdsfree(spaces);
2210      return info;
2211  }
2212  static void clusterManagerShowNodes(void) {
2213      listIter li;
2214      listNode *ln;
2215      listRewind(cluster_manager.nodes, &li);
2216      while ((ln = listNext(&li)) != NULL) {
2217          clusterManagerNode *node = ln->value;
2218          sds info = clusterManagerNodeInfo(node, 0);
2219          printf("%s\n", (char *) info);
2220          sdsfree(info);
2221      }
2222  }
2223  static void clusterManagerShowClusterInfo(void) {
2224      int masters = 0;
2225      int keys = 0;
2226      listIter li;
2227      listNode *ln;
2228      listRewind(cluster_manager.nodes, &li);
2229      while ((ln = listNext(&li)) != NULL) {
2230          clusterManagerNode *node = ln->value;
2231          if (!(node->flags & CLUSTER_MANAGER_FLAG_SLAVE)) {
2232              if (!node->name) continue;
2233              int replicas = 0;
2234              int dbsize = -1;
2235              char name[9];
2236              memcpy(name, node->name, 8);
2237              name[8] = '\0';
2238              listIter ri;
2239              listNode *rn;
2240              listRewind(cluster_manager.nodes, &ri);
2241              while ((rn = listNext(&ri)) != NULL) {
2242                  clusterManagerNode *n = rn->value;
2243                  if (n == node || !(n->flags & CLUSTER_MANAGER_FLAG_SLAVE))
2244                      continue;
2245                  if (n->replicate && !strcmp(n->replicate, node->name))
2246                      replicas++;
2247              }
2248              redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "DBSIZE");
2249              if (reply != NULL || reply->type == REDIS_REPLY_INTEGER)
2250                  dbsize = reply->integer;
2251              if (dbsize < 0) {
2252                  char *err = "";
2253                  if (reply != NULL && reply->type == REDIS_REPLY_ERROR)
2254                      err = reply->str;
2255                  CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
2256                  if (reply != NULL) freeReplyObject(reply);
2257                  return;
2258              };
2259              if (reply != NULL) freeReplyObject(reply);
2260              printf("%s:%d (%s...) -> %d keys | %d slots | %d slaves.\n",
2261                     node->ip, node->port, name, dbsize,
2262                     node->slots_count, replicas);
2263              masters++;
2264              keys += dbsize;
2265          }
2266      }
2267      clusterManagerLogOk("[OK] %d keys in %d masters.\n", keys, masters);
2268      float keys_per_slot = keys / (float) CLUSTER_MANAGER_SLOTS;
2269      printf("%.2f keys per slot on average.\n", keys_per_slot);
2270  }
2271  static int clusterManagerAddSlots(clusterManagerNode *node, char**err)
2272  {
2273      redisReply *reply = NULL;
2274      void *_reply = NULL;
2275      int success = 1;
2276      int argc = node->slots_count + 2;
2277      sds *argv = zmalloc(argc * sizeof(*argv));
2278      size_t *argvlen = zmalloc(argc * sizeof(*argvlen));
2279      argv[0] = "CLUSTER";
2280      argv[1] = "ADDSLOTS";
2281      argvlen[0] = 7;
2282      argvlen[1] = 8;
2283      *err = NULL;
2284      int i, argv_idx = 2;
2285      for (i = 0; i < CLUSTER_MANAGER_SLOTS; i++) {
2286          if (argv_idx >= argc) break;
2287          if (node->slots[i]) {
2288              argv[argv_idx] = sdsfromlonglong((PORT_LONGLONG) i);
2289              argvlen[argv_idx] = sdslen(argv[argv_idx]);
2290              argv_idx++;
2291          }
2292      }
2293      if (!argv_idx) {
2294          success = 0;
2295          goto cleanup;
2296      }
2297      redisAppendCommandArgv(node->context,argc,(const char**)argv,argvlen);
2298      if (redisGetReply(node->context, &_reply) != REDIS_OK) {
2299          success = 0;
2300          goto cleanup;
2301      }
2302      reply = (redisReply*) _reply;
2303      success = clusterManagerCheckRedisReply(node, reply, err);
2304  cleanup:
2305      zfree(argvlen);
2306      if (argv != NULL) {
2307          for (i = 2; i < argc; i++) sdsfree(argv[i]);
2308          zfree(argv);
2309      }
2310      if (reply != NULL) freeReplyObject(reply);
2311      return success;
2312  }
2313  static int clusterManagerSetSlot(clusterManagerNode *node1,
2314                                   clusterManagerNode *node2,
2315                                   int slot, const char *status, char **err) {
2316      redisReply *reply = CLUSTER_MANAGER_COMMAND(node1, "CLUSTER "
2317                                                  "SETSLOT %d %s %s",
2318                                                  slot, status,
2319                                                  (char *) node2->name);
2320      if (err != NULL) *err = NULL;
2321      if (!reply) return 0;
2322      int success = 1;
2323      if (reply->type == REDIS_REPLY_ERROR) {
2324          success = 0;
2325          if (err != NULL) {
2326              *err = zmalloc((reply->len + 1) * sizeof(char));
2327              strcpy(*err, reply->str);
2328          } else CLUSTER_MANAGER_PRINT_REPLY_ERROR(node1, reply->str);
2329          goto cleanup;
2330      }
2331  cleanup:
2332      freeReplyObject(reply);
2333      return success;
2334  }
2335  static int clusterManagerClearSlotStatus(clusterManagerNode *node, int slot) {
2336      redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
2337          "CLUSTER SETSLOT %d %s", slot, "STABLE");
2338      int success = clusterManagerCheckRedisReply(node, reply, NULL);
2339      if (reply) freeReplyObject(reply);
2340      return success;
2341  }
2342  static int clusterManagerDelSlot(clusterManagerNode *node, int slot,
2343                                   int ignore_unassigned_err)
2344  {
2345      redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
2346          "CLUSTER DELSLOTS %d", slot);
2347      char *err = NULL;
2348      int success = clusterManagerCheckRedisReply(node, reply, &err);
2349      if (!success && reply && reply->type == REDIS_REPLY_ERROR &&
2350          ignore_unassigned_err &&
2351          strstr(reply->str, "already unassigned") != NULL) success = 1;
2352      if (!success && err != NULL) {
2353          CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
2354          zfree(err);
2355      }
2356      if (reply) freeReplyObject(reply);
2357      return success;
2358  }
2359  static int clusterManagerAddSlot(clusterManagerNode *node, int slot) {
2360      redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
2361          "CLUSTER ADDSLOTS %d", slot);
2362      int success = clusterManagerCheckRedisReply(node, reply, NULL);
2363      if (reply) freeReplyObject(reply);
2364      return success;
2365  }
2366  static signed int clusterManagerCountKeysInSlot(clusterManagerNode *node,
2367                                                  int slot)
2368  {
2369      redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
2370          "CLUSTER COUNTKEYSINSLOT %d", slot);
2371      int count = -1;
2372      int success = clusterManagerCheckRedisReply(node, reply, NULL);
2373      if (success && reply->type == REDIS_REPLY_INTEGER) count = reply->integer;
2374      if (reply) freeReplyObject(reply);
2375      return count;
2376  }
2377  static int clusterManagerBumpEpoch(clusterManagerNode *node) {
2378      redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "CLUSTER BUMPEPOCH");
2379      int success = clusterManagerCheckRedisReply(node, reply, NULL);
2380      if (reply) freeReplyObject(reply);
2381      return success;
2382  }
2383  static int clusterManagerIgnoreUnassignedErr(redisReply *reply, int bulk_idx) {
2384      if (bulk_idx == 0 && reply) {
2385          if (reply->type == REDIS_REPLY_ERROR)
2386              return strstr(reply->str, "already unassigned") != NULL;
2387      }
2388      return 0;
2389  }
2390  static int clusterManagerSetSlotOwner(clusterManagerNode *owner,
2391                                        int slot,
2392                                        int do_clear)
2393  {
2394      int success = clusterManagerStartTransaction(owner);
2395      if (!success) return 0;
2396      clusterManagerDelSlot(owner, slot, 1);
2397      clusterManagerAddSlot(owner, slot);
2398      if (do_clear) clusterManagerClearSlotStatus(owner, slot);
2399      clusterManagerBumpEpoch(owner);
2400      success = clusterManagerExecTransaction(owner,
2401          clusterManagerIgnoreUnassignedErr);
2402      return success;
2403  }
2404  static redisReply *clusterManagerMigrateKeysInReply(clusterManagerNode *source,
2405                                                      clusterManagerNode *target,
2406                                                      redisReply *reply,
2407                                                      int replace, int timeout,
2408                                                      char *dots)
2409  {
2410      redisReply *migrate_reply = NULL;
2411      char **argv = NULL;
2412      size_t *argv_len = NULL;
2413      int c = (replace ? 8 : 7);
2414      if (config.auth) c += 2;
2415      size_t argc = c + reply->elements;
2416      size_t i, offset = 6; 
2417      argv = zcalloc(argc * sizeof(char *));
2418      argv_len = zcalloc(argc * sizeof(size_t));
2419      char portstr[255];
2420      char timeoutstr[255];
2421      snprintf(portstr, 10, "%d", target->port);
2422      snprintf(timeoutstr, 10, "%d", timeout);
2423      argv[0] = "MIGRATE";
2424      argv_len[0] = 7;
2425      argv[1] = target->ip;
2426      argv_len[1] = strlen(target->ip);
2427      argv[2] = portstr;
2428      argv_len[2] = strlen(portstr);
2429      argv[3] = "";
2430      argv_len[3] = 0;
2431      argv[4] = "0";
2432      argv_len[4] = 1;
2433      argv[5] = timeoutstr;
2434      argv_len[5] = strlen(timeoutstr);
2435      if (replace) {
2436          argv[offset] = "REPLACE";
2437          argv_len[offset] = 7;
2438          offset++;
2439      }
2440      if (config.auth) {
2441          argv[offset] = "AUTH";
2442          argv_len[offset] = 4;
2443          offset++;
2444          argv[offset] = config.auth;
2445          argv_len[offset] = strlen(config.auth);
2446          offset++;
2447      }
2448      argv[offset] = "KEYS";
2449      argv_len[offset] = 4;
2450      offset++;
2451      for (i = 0; i < reply->elements; i++) {
2452          redisReply *entry = reply->element[i];
2453          size_t idx = i + offset;
2454          assert(entry->type == REDIS_REPLY_STRING);
2455          argv[idx] = (char *) sdsnew(entry->str);
2456          argv_len[idx] = entry->len;
2457          if (dots) dots[i] = '.';
2458      }
2459      if (dots) dots[reply->elements] = '\0';
2460      void *_reply = NULL;
2461      redisAppendCommandArgv(source->context,argc,
2462                             (const char**)argv,argv_len);
2463      int success = (redisGetReply(source->context, &_reply) == REDIS_OK);
2464      for (i = 0; i < reply->elements; i++) sdsfree(argv[i + offset]);
2465      if (!success) goto cleanup;
2466      migrate_reply = (redisReply *) _reply;
2467  cleanup:
2468      zfree(argv);
2469      zfree(argv_len);
2470      return migrate_reply;
2471  }
2472  static int clusterManagerMigrateKeysInSlot(clusterManagerNode *source,
2473                                             clusterManagerNode *target,
2474                                             int slot, int timeout,
2475                                             int pipeline, int verbose,
2476                                             char **err)
2477  {
2478      int success = 1;
2479      int replace_existing_keys = (config.cluster_manager_command.flags &
2480              (CLUSTER_MANAGER_CMD_FLAG_FIX | CLUSTER_MANAGER_CMD_FLAG_REPLACE));
2481      while (1) {
2482          char *dots = NULL;
2483          redisReply *reply = NULL, *migrate_reply = NULL;
2484          reply = CLUSTER_MANAGER_COMMAND(source, "CLUSTER "
2485                                          "GETKEYSINSLOT %d %d", slot,
2486                                          pipeline);
2487          success = (reply != NULL);
2488          if (!success) return 0;
2489          if (reply->type == REDIS_REPLY_ERROR) {
2490              success = 0;
2491              if (err != NULL) {
2492                  *err = zmalloc((reply->len + 1) * sizeof(char));
2493                  strcpy(*err, reply->str);
2494                  CLUSTER_MANAGER_PRINT_REPLY_ERROR(source, *err);
2495              }
2496              goto next;
2497          }
2498          assert(reply->type == REDIS_REPLY_ARRAY);
2499          size_t count = reply->elements;
2500          if (count == 0) {
2501              freeReplyObject(reply);
2502              break;
2503          }
2504          if (verbose) dots = zmalloc((count+1) * sizeof(char));
2505          migrate_reply = clusterManagerMigrateKeysInReply(source, target,
2506                                                           reply, 0, timeout,
2507                                                           dots);
2508          if (migrate_reply == NULL) goto next;
2509          if (migrate_reply->type == REDIS_REPLY_ERROR) {
2510              int is_busy = strstr(migrate_reply->str, "BUSYKEY") != NULL;
2511              int not_served = strstr(migrate_reply->str, "slot not served") != NULL;
2512              if (replace_existing_keys && (is_busy || not_served)) {
2513                  if (not_served)
2514                      clusterManagerSetSlot(source, target, slot, "node", NULL);
2515                  clusterManagerLogWarn("*** Target key exists. "
2516                                        "Replacing it for FIX.\n");
2517                  freeReplyObject(migrate_reply);
2518                  migrate_reply = clusterManagerMigrateKeysInReply(source,
2519                                                                   target,
2520                                                                   reply,
2521                                                                   is_busy,
2522                                                                   timeout,
2523                                                                   NULL);
2524                  success = (migrate_reply != NULL &&
2525                             migrate_reply->type != REDIS_REPLY_ERROR);
2526              } else success = 0;
2527              if (!success) {
2528                  if (migrate_reply != NULL) {
2529                      if (err) {
2530                          *err = zmalloc((migrate_reply->len + 1) * sizeof(char));
2531                          strcpy(*err, migrate_reply->str);
2532                      }
2533                      printf("\n");
2534                      CLUSTER_MANAGER_PRINT_REPLY_ERROR(source,
2535                                                        migrate_reply->str);
2536                  }
2537                  goto next;
2538              }
2539          }
2540          if (verbose) {
2541              printf("%s", dots);
2542              fflush(stdout);
2543          }
2544  next:
2545          if (reply != NULL) freeReplyObject(reply);
2546          if (migrate_reply != NULL) freeReplyObject(migrate_reply);
2547          if (dots) zfree(dots);
2548          if (!success) break;
2549      }
2550      return success;
2551  }
2552  static int clusterManagerMoveSlot(clusterManagerNode *source,
2553                                    clusterManagerNode *target,
2554                                    int slot, int opts,  char**err)
2555  {
2556      if (!(opts & CLUSTER_MANAGER_OPT_QUIET)) {
2557          printf("Moving slot %d from %s:%d to %s:%d: ", slot, source->ip,
2558                 source->port, target->ip, target->port);
2559          fflush(stdout);
2560      }
2561      if (err != NULL) *err = NULL;
2562      int pipeline = config.cluster_manager_command.pipeline,
2563          timeout = config.cluster_manager_command.timeout,
2564          print_dots = (opts & CLUSTER_MANAGER_OPT_VERBOSE),
2565          option_cold = (opts & CLUSTER_MANAGER_OPT_COLD),
2566          success = 1;
2567      if (!option_cold) {
2568          success = clusterManagerSetSlot(target, source, slot,
2569                                          "importing", err);
2570          if (!success) return 0;
2571          success = clusterManagerSetSlot(source, target, slot,
2572                                          "migrating", err);
2573          if (!success) return 0;
2574      }
2575      success = clusterManagerMigrateKeysInSlot(source, target, slot, timeout,
2576                                                pipeline, print_dots, err);
2577      if (!(opts & CLUSTER_MANAGER_OPT_QUIET)) printf("\n");
2578      if (!success) return 0;
2579      if (!option_cold) {
2580          listIter li;
2581          listNode *ln;
2582          listRewind(cluster_manager.nodes, &li);
2583          while ((ln = listNext(&li)) != NULL) {
2584              clusterManagerNode *n = ln->value;
2585              if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
2586              redisReply *r = CLUSTER_MANAGER_COMMAND(n, "CLUSTER "
2587                                                      "SETSLOT %d %s %s",
2588                                                      slot, "node",
2589                                                      target->name);
2590              success = (r != NULL);
2591              if (!success) return 0;
2592              if (r->type == REDIS_REPLY_ERROR) {
2593                  success = 0;
2594                  if (err != NULL) {
2595                      *err = zmalloc((r->len + 1) * sizeof(char));
2596                      strcpy(*err, r->str);
2597                      CLUSTER_MANAGER_PRINT_REPLY_ERROR(n, *err);
2598                  }
2599              }
2600              freeReplyObject(r);
2601              if (!success) return 0;
2602          }
2603      }
2604      if (opts & CLUSTER_MANAGER_OPT_UPDATE) {
2605          source->slots[slot] = 0;
2606          target->slots[slot] = 1;
2607      }
2608      return 1;
2609  }
2610  static int clusterManagerFlushNodeConfig(clusterManagerNode *node, char **err) {
2611      if (!node->dirty) return 0;
2612      redisReply *reply = NULL;
2613      int is_err = 0, success = 1;
2614      if (err != NULL) *err = NULL;
2615      if (node->replicate != NULL) {
2616          reply = CLUSTER_MANAGER_COMMAND(node, "CLUSTER REPLICATE %s",
2617                                          node->replicate);
2618          if (reply == NULL || (is_err = (reply->type == REDIS_REPLY_ERROR))) {
2619              if (is_err && err != NULL) {
2620                  *err = zmalloc((reply->len + 1) * sizeof(char));
2621                  strcpy(*err, reply->str);
2622              }
2623              success = 0;
2624              goto cleanup;
2625          }
2626      } else {
2627          int added = clusterManagerAddSlots(node, err);
2628          if (!added || *err != NULL) success = 0;
2629      }
2630      node->dirty = 0;
2631  cleanup:
2632      if (reply != NULL) freeReplyObject(reply);
2633      return success;
2634  }
2635  static void clusterManagerWaitForClusterJoin(void) {
2636      printf("Waiting for the cluster to join\n");
2637      while(!clusterManagerIsConfigConsistent()) {
2638          printf(".");
2639          fflush(stdout);
2640          sleep(1);
2641      }
2642      printf("\n");
2643  }
2644  static int clusterManagerNodeLoadInfo(clusterManagerNode *node, int opts,
2645                                        char **err)
2646  {
2647      redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "CLUSTER NODES");
2648      int success = 1;
2649      *err = NULL;
2650      if (!clusterManagerCheckRedisReply(node, reply, err)) {
2651          success = 0;
2652          goto cleanup;
2653      }
2654      int getfriends = (opts & CLUSTER_MANAGER_OPT_GETFRIENDS);
2655      char *lines = reply->str, *p, *line;
2656      while ((p = strstr(lines, "\n")) != NULL) {
2657          *p = '\0';
2658          line = lines;
2659          lines = p + 1;
2660          char *name = NULL, *addr = NULL, *flags = NULL, *master_id = NULL,
2661               *ping_sent = NULL, *ping_recv = NULL, *config_epoch = NULL,
2662               *link_status = NULL;
2663          UNUSED(link_status);
2664          int i = 0;
2665          while ((p = strchr(line, ' ')) != NULL) {
2666              *p = '\0';
2667              char *token = line;
2668              line = p + 1;
2669              switch(i++){
2670              case 0: name = token; break;
2671              case 1: addr = token; break;
2672              case 2: flags = token; break;
2673              case 3: master_id = token; break;
2674              case 4: ping_sent = token; break;
2675              case 5: ping_recv = token; break;
2676              case 6: config_epoch = token; break;
2677              case 7: link_status = token; break;
2678              }
2679              if (i == 8) break; 
2680          }
2681          if (!flags) {
2682              success = 0;
2683              goto cleanup;
2684          }
2685          int myself = (strstr(flags, "myself") != NULL);
2686          clusterManagerNode *currentNode = NULL;
2687          if (myself) {
2688              node->flags |= CLUSTER_MANAGER_FLAG_MYSELF;
2689              currentNode = node;
2690              clusterManagerNodeResetSlots(node);
2691              if (i == 8) {
2692                  int remaining = strlen(line);
2693                  while (remaining > 0) {
2694                      p = strchr(line, ' ');
2695                      if (p == NULL) p = line + remaining;
2696                      remaining -= (p - line);
2697                      char *slotsdef = line;
2698                      *p = '\0';
2699                      if (remaining) {
2700                          line = p + 1;
2701                          remaining--;
2702                      } else line = p;
2703                      char *dash = NULL;
2704                      if (slotsdef[0] == '[') {
2705                          slotsdef++;
2706                          if ((p = strstr(slotsdef, "->-"))) { 
2707                              *p = '\0';
2708                              p += 3;
2709                              char *closing_bracket = strchr(p, ']');
2710                              if (closing_bracket) *closing_bracket = '\0';
2711                              sds slot = sdsnew(slotsdef);
2712                              sds dst = sdsnew(p);
2713                              node->migrating_count += 2;
2714                              node->migrating = zrealloc(node->migrating,
2715                                  (node->migrating_count * sizeof(sds)));
2716                              node->migrating[node->migrating_count - 2] =
2717                                  slot;
2718                              node->migrating[node->migrating_count - 1] =
2719                                  dst;
2720                          }  else if ((p = strstr(slotsdef, "-<-"))) {
2721                              *p = '\0';
2722                              p += 3;
2723                              char *closing_bracket = strchr(p, ']');
2724                              if (closing_bracket) *closing_bracket = '\0';
2725                              sds slot = sdsnew(slotsdef);
2726                              sds src = sdsnew(p);
2727                              node->importing_count += 2;
2728                              node->importing = zrealloc(node->importing,
2729                                  (node->importing_count * sizeof(sds)));
2730                              node->importing[node->importing_count - 2] =
2731                                  slot;
2732                              node->importing[node->importing_count - 1] =
2733                                  src;
2734                          }
2735                      } else if ((dash = strchr(slotsdef, '-')) != NULL) {
2736                          p = dash;
2737                          int start, stop;
2738                          *p = '\0';
2739                          start = atoi(slotsdef);
2740                          stop = atoi(p + 1);
2741                          node->slots_count += (stop - (start - 1));
2742                          while (start <= stop) node->slots[start++] = 1;
2743                      } else if (p > slotsdef) {
2744                          node->slots[atoi(slotsdef)] = 1;
2745                          node->slots_count++;
2746                      }
2747                  }
2748              }
2749              node->dirty = 0;
2750          } else if (!getfriends) {
2751              if (!(node->flags & CLUSTER_MANAGER_FLAG_MYSELF)) continue;
2752              else break;
2753          } else {
2754              if (addr == NULL) {
2755                  fprintf(stderr, "Error: invalid CLUSTER NODES reply\n");
2756                  success = 0;
2757                  goto cleanup;
2758              }
2759              char *c = strrchr(addr, '@');
2760              if (c != NULL) *c = '\0';
2761              c = strrchr(addr, ':');
2762              if (c == NULL) {
2763                  fprintf(stderr, "Error: invalid CLUSTER NODES reply\n");
2764                  success = 0;
2765                  goto cleanup;
2766              }
2767              *c = '\0';
2768              int port = atoi(++c);
2769              currentNode = clusterManagerNewNode(sdsnew(addr), port);
2770              currentNode->flags |= CLUSTER_MANAGER_FLAG_FRIEND;
2771              if (node->friends == NULL) node->friends = listCreate();
2772              listAddNodeTail(node->friends, currentNode);
2773          }
2774          if (name != NULL) {
2775              if (currentNode->name) sdsfree(currentNode->name);
2776              currentNode->name = sdsnew(name);
2777          }
2778          if (currentNode->flags_str != NULL)
2779              freeClusterManagerNodeFlags(currentNode->flags_str);
2780          currentNode->flags_str = listCreate();
2781          int flag_len;
2782          while ((flag_len = strlen(flags)) > 0) {
2783              sds flag = NULL;
2784              char *fp = strchr(flags, ',');
2785              if (fp) {
2786                  *fp = '\0';
2787                  flag = sdsnew(flags);
2788                  flags = fp + 1;
2789              } else {
2790                  flag = sdsnew(flags);
2791                  flags += flag_len;
2792              }
2793              if (strcmp(flag, "noaddr") == 0)
2794                  currentNode->flags |= CLUSTER_MANAGER_FLAG_NOADDR;
2795              else if (strcmp(flag, "disconnected") == 0)
2796                  currentNode->flags |= CLUSTER_MANAGER_FLAG_DISCONNECT;
2797              else if (strcmp(flag, "fail") == 0)
2798                  currentNode->flags |= CLUSTER_MANAGER_FLAG_FAIL;
2799              else if (strcmp(flag, "slave") == 0) {
2800                  currentNode->flags |= CLUSTER_MANAGER_FLAG_SLAVE;
2801                  if (master_id != NULL) {
2802                      if (currentNode->replicate) sdsfree(currentNode->replicate);
2803                      currentNode->replicate = sdsnew(master_id);
2804                  }
2805              }
2806              listAddNodeTail(currentNode->flags_str, flag);
2807          }
2808          if (config_epoch != NULL)
2809              currentNode->current_epoch = atoll(config_epoch);
2810          if (ping_sent != NULL) currentNode->ping_sent = atoll(ping_sent);
2811          if (ping_recv != NULL) currentNode->ping_recv = atoll(ping_recv);
2812          if (!getfriends && myself) break;
2813      }
2814  cleanup:
2815      if (reply) freeReplyObject(reply);
2816      return success;
2817  }
2818  static int clusterManagerLoadInfoFromNode(clusterManagerNode *node, int opts) {
2819      if (node->context == NULL && !clusterManagerNodeConnect(node)) {
2820          freeClusterManagerNode(node);
2821          return 0;
2822      }
2823      opts |= CLUSTER_MANAGER_OPT_GETFRIENDS;
2824      char *e = NULL;
2825      if (!clusterManagerNodeIsCluster(node, &e)) {
2826          clusterManagerPrintNotClusterNodeError(node, e);
2827          if (e) zfree(e);
2828          freeClusterManagerNode(node);
2829          return 0;
2830      }
2831      e = NULL;
2832      if (!clusterManagerNodeLoadInfo(node, opts, &e)) {
2833          if (e) {
2834              CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, e);
2835              zfree(e);
2836          }
2837          freeClusterManagerNode(node);
2838          return 0;
2839      }
<span onclick='openModal()' class='match'>2840      listIter li;
2841      listNode *ln;
2842      if (cluster_manager.nodes != NULL) {
2843          listRewind(cluster_manager.nodes, &li);
2844          while ((ln = listNext(&li)) != NULL)
2845              freeClusterManagerNode((clusterManagerNode *) ln->value);
</span>2846          listRelease(cluster_manager.nodes);
2847      }
2848      cluster_manager.nodes = listCreate();
2849      listAddNodeTail(cluster_manager.nodes, node);
2850      if (node->friends != NULL) {
2851          listRewind(node->friends, &li);
2852          while ((ln = listNext(&li)) != NULL) {
2853              clusterManagerNode *friend = ln->value;
2854              if (!friend->ip || !friend->port) goto invalid_friend;
2855              if (!friend->context && !clusterManagerNodeConnect(friend))
2856                  goto invalid_friend;
2857              e = NULL;
2858              if (clusterManagerNodeLoadInfo(friend, 0, &e)) {
2859                  if (friend->flags & (CLUSTER_MANAGER_FLAG_NOADDR |
2860                                       CLUSTER_MANAGER_FLAG_DISCONNECT |
2861                                       CLUSTER_MANAGER_FLAG_FAIL))
2862                      goto invalid_friend;
2863                  listAddNodeTail(cluster_manager.nodes, friend);
2864              } else {
2865                  clusterManagerLogErr("[ERR] Unable to load info for "
2866                                       "node %s:%d\n",
2867                                       friend->ip, friend->port);
2868                  goto invalid_friend;
2869              }
2870              continue;
2871  invalid_friend:
2872              freeClusterManagerNode(friend);
2873          }
2874          listRelease(node->friends);
2875          node->friends = NULL;
2876      }
2877      listRewind(cluster_manager.nodes, &li);
2878      while ((ln = listNext(&li)) != NULL) {
2879          clusterManagerNode *n = ln->value;
2880          if (n->replicate != NULL) {
2881              clusterManagerNode *master = clusterManagerNodeByName(n->replicate);
2882              if (master == NULL) {
2883                  clusterManagerLogWarn("*** WARNING: %s:%d claims to be "
2884                                        "slave of unknown node ID %s.\n",
2885                                        n->ip, n->port, n->replicate);
2886              } else master->replicas_count++;
2887          }
2888      }
2889      return 1;
2890  }
2891  int clusterManagerSlotCompare(const void *slot1, const void *slot2) {
2892      const char **i1 = (const char **)slot1;
2893      const char **i2 = (const char **)slot2;
2894      return strcmp(*i1, *i2);
2895  }
2896  int clusterManagerSlotCountCompareDesc(const void *n1, const void *n2) {
2897      clusterManagerNode *node1 = *((clusterManagerNode **) n1);
2898      clusterManagerNode *node2 = *((clusterManagerNode **) n2);
2899      return node2->slots_count - node1->slots_count;
2900  }
2901  int clusterManagerCompareNodeBalance(const void *n1, const void *n2) {
2902      clusterManagerNode *node1 = *((clusterManagerNode **) n1);
2903      clusterManagerNode *node2 = *((clusterManagerNode **) n2);
2904      return node1->balance - node2->balance;
2905  }
2906  static sds clusterManagerGetConfigSignature(clusterManagerNode *node) {
2907      sds signature = NULL;
2908      int node_count = 0, i = 0, name_len = 0;
2909      char **node_configs = NULL;
2910      redisReply *reply = CLUSTER_MANAGER_COMMAND(node, "CLUSTER NODES");
2911      if (reply == NULL || reply->type == REDIS_REPLY_ERROR)
2912          goto cleanup;
2913      char *lines = reply->str, *p, *line;
2914      while ((p = strstr(lines, "\n")) != NULL) {
2915          i = 0;
2916          *p = '\0';
2917          line = lines;
2918          lines = p + 1;
2919          char *nodename = NULL;
2920          int tot_size = 0;
2921          while ((p = strchr(line, ' ')) != NULL) {
2922              *p = '\0';
2923              char *token = line;
2924              line = p + 1;
2925              if (i == 0) {
2926                  nodename = token;
2927                  tot_size = (p - token);
2928                  name_len = tot_size++; 
2929              }
2930              if (++i == 8) break;
2931          }
2932          if (i != 8) continue;
2933          if (nodename == NULL) continue;
2934          int remaining = strlen(line);
2935          if (remaining == 0) continue;
2936          char **slots = NULL;
2937          int c = 0;
2938          while (remaining > 0) {
2939              p = strchr(line, ' ');
2940              if (p == NULL) p = line + remaining;
2941              int size = (p - line);
2942              remaining -= size;
2943              tot_size += size;
2944              char *slotsdef = line;
2945              *p = '\0';
2946              if (remaining) {
2947                  line = p + 1;
2948                  remaining--;
2949              } else line = p;
2950              if (slotsdef[0] != '[') {
2951                  c++;
2952                  slots = zrealloc(slots, (c * sizeof(char *)));
2953                  slots[c - 1] = slotsdef;
2954              }
2955          }
2956          if (c > 0) {
2957              if (c > 1)
2958                  qsort(slots, c, sizeof(char *), clusterManagerSlotCompare);
2959              node_count++;
2960              node_configs =
2961                  zrealloc(node_configs, (node_count * sizeof(char *)));
2962              tot_size += (sizeof(char) * (c - 1));
2963              char *cfg = zmalloc((sizeof(char) * tot_size) + 1);
2964              memcpy(cfg, nodename, name_len);
2965              char *sp = cfg + name_len;
2966              *(sp++) = ':';
2967              for (i = 0; i < c; i++) {
2968                  if (i > 0) *(sp++) = ',';
2969                  int slen = strlen(slots[i]);
2970                  memcpy(sp, slots[i], slen);
2971                  sp += slen;
2972              }
2973              *(sp++) = '\0';
2974              node_configs[node_count - 1] = cfg;
2975          }
2976          zfree(slots);
2977      }
2978      if (node_count > 0) {
2979          if (node_count > 1) {
2980              qsort(node_configs, node_count, sizeof(char *),
2981                    clusterManagerSlotCompare);
2982          }
2983          signature = sdsempty();
2984          for (i = 0; i < node_count; i++) {
2985              if (i > 0) signature = sdscatprintf(signature, "%c", '|');
2986              signature = sdscatfmt(signature, "%s", node_configs[i]);
2987          }
2988      }
2989  cleanup:
2990      if (reply != NULL) freeReplyObject(reply);
2991      if (node_configs != NULL) {
2992          for (i = 0; i < node_count; i++) zfree(node_configs[i]);
2993          zfree(node_configs);
2994      }
2995      return signature;
2996  }
2997  static int clusterManagerIsConfigConsistent(void) {
2998      if (cluster_manager.nodes == NULL) return 0;
2999      int consistent = (listLength(cluster_manager.nodes) <= 1);
3000      if (consistent) return 1;
3001      sds first_cfg = NULL;
3002      listIter li;
3003      listNode *ln;
3004      listRewind(cluster_manager.nodes, &li);
3005      while ((ln = listNext(&li)) != NULL) {
3006          clusterManagerNode *node = ln->value;
3007          sds cfg = clusterManagerGetConfigSignature(node);
3008          if (cfg == NULL) {
3009              consistent = 0;
3010              break;
3011          }
3012          if (first_cfg == NULL) first_cfg = cfg;
3013          else {
3014              consistent = !sdscmp(first_cfg, cfg);
3015              sdsfree(cfg);
3016              if (!consistent) break;
3017          }
3018      }
3019      if (first_cfg != NULL) sdsfree(first_cfg);
3020      return consistent;
3021  }
3022  static void clusterManagerOnError(sds err) {
3023      if (cluster_manager.errors == NULL)
3024          cluster_manager.errors = listCreate();
3025      listAddNodeTail(cluster_manager.errors, err);
3026      clusterManagerLogErr("%s\n", (char *) err);
3027  }
3028  static int clusterManagerGetCoveredSlots(char *all_slots) {
3029      if (cluster_manager.nodes == NULL) return 0;
3030      listIter li;
3031      listNode *ln;
3032      listRewind(cluster_manager.nodes, &li);
3033      int totslots = 0, i;
3034      while ((ln = listNext(&li)) != NULL) {
3035          clusterManagerNode *node = ln->value;
3036          for (i = 0; i < CLUSTER_MANAGER_SLOTS; i++) {
3037              if (node->slots[i] && !all_slots[i]) {
3038                  all_slots[i] = 1;
3039                  totslots++;
3040              }
3041          }
3042      }
3043      return totslots;
3044  }
3045  static void clusterManagerPrintSlotsList(list *slots) {
3046      listIter li;
3047      listNode *ln;
3048      listRewind(slots, &li);
3049      sds first = NULL;
3050      while ((ln = listNext(&li)) != NULL) {
3051          sds slot = ln->value;
3052          if (!first) first = slot;
3053          else printf(", ");
3054          printf("%s", slot);
3055      }
3056      printf("\n");
3057  }
3058  static clusterManagerNode * clusterManagerGetNodeWithMostKeysInSlot(list *nodes,
3059                                                                      int slot,
3060                                                                      char **err)
3061  {
3062      clusterManagerNode *node = NULL;
3063      int numkeys = 0;
3064      listIter li;
3065      listNode *ln;
3066      listRewind(nodes, &li);
3067      if (err) *err = NULL;
3068      while ((ln = listNext(&li)) != NULL) {
3069          clusterManagerNode *n = ln->value;
3070          if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE || n->replicate)
3071              continue;
3072          redisReply *r =
3073              CLUSTER_MANAGER_COMMAND(n, "CLUSTER COUNTKEYSINSLOT %d", slot);
3074          int success = clusterManagerCheckRedisReply(n, r, err);
3075          if (success) {
3076              if (r->integer > numkeys || node == NULL) {
3077                  numkeys = r->integer;
3078                  node = n;
3079              }
3080          }
3081          if (r != NULL) freeReplyObject(r);
3082          if (!success) {
3083              if (err != NULL && *err != NULL)
3084                  CLUSTER_MANAGER_PRINT_REPLY_ERROR(n, err);
3085              node = NULL;
3086              break;
3087          }
3088      }
3089      return node;
3090  }
3091  static clusterManagerNode *clusterManagerNodeWithLeastReplicas() {
3092      clusterManagerNode *node = NULL;
3093      int lowest_count = 0;
3094      listIter li;
3095      listNode *ln;
3096      listRewind(cluster_manager.nodes, &li);
3097      while ((ln = listNext(&li)) != NULL) {
3098          clusterManagerNode *n = ln->value;
3099          if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
3100          if (node == NULL || n->replicas_count < lowest_count) {
3101              node = n;
3102              lowest_count = n->replicas_count;
3103          }
3104      }
3105      return node;
3106  }
3107  static clusterManagerNode *clusterManagerNodeMasterRandom() {
3108      int master_count = 0;
3109      int idx;
3110      listIter li;
3111      listNode *ln;
3112      listRewind(cluster_manager.nodes, &li);
3113      while ((ln = listNext(&li)) != NULL) {
3114          clusterManagerNode *n = ln->value;
3115          if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
3116          master_count++;
3117      }
3118      srand(time(NULL));
3119      idx = rand() % master_count;
3120      listRewind(cluster_manager.nodes, &li);
3121      while ((ln = listNext(&li)) != NULL) {
3122          clusterManagerNode *n = ln->value;
3123          if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
3124          if (!idx--) {
3125              return n;
3126          }
3127      }
3128      return NULL;
3129  }
3130  static int clusterManagerFixSlotsCoverage(char *all_slots) {
3131      int i, fixed = 0;
3132      list *none = NULL, *single = NULL, *multi = NULL;
3133      clusterManagerLogInfo(">>> Fixing slots coverage...\n");
3134      printf("List of not covered slots: \n");
3135      int uncovered_count = 0;
3136      sds log = sdsempty();
3137      for (i = 0; i < CLUSTER_MANAGER_SLOTS; i++) {
3138          int covered = all_slots[i];
3139          if (!covered) {
3140              sds key = sdsfromlonglong((PORT_LONGLONG) i);
3141              if (uncovered_count++ > 0) printf(",");
3142              printf("%s", (char *) key);
3143              list *slot_nodes = listCreate();
3144              sds slot_nodes_str = sdsempty();
3145              listIter li;
3146              listNode *ln;
3147              listRewind(cluster_manager.nodes, &li);
3148              while ((ln = listNext(&li)) != NULL) {
3149                  clusterManagerNode *n = ln->value;
3150                  if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE || n->replicate)
3151                      continue;
3152                  redisReply *reply = CLUSTER_MANAGER_COMMAND(n,
3153                      "CLUSTER GETKEYSINSLOT %d %d", i, 1);
3154                  if (!clusterManagerCheckRedisReply(n, reply, NULL)) {
3155                      fixed = -1;
3156                      if (reply) freeReplyObject(reply);
3157                      goto cleanup;
3158                  }
3159                  assert(reply->type == REDIS_REPLY_ARRAY);
3160                  if (reply->elements > 0) {
3161                      listAddNodeTail(slot_nodes, n);
3162                      if (listLength(slot_nodes) > 1)
3163                          slot_nodes_str = sdscat(slot_nodes_str, ", ");
3164                      slot_nodes_str = sdscatfmt(slot_nodes_str,
3165                                                 "%s:%u", n->ip, n->port);
3166                  }
3167                  freeReplyObject(reply);
3168              }
3169              log = sdscatfmt(log, "\nSlot %S has keys in %u nodes: %S",
3170                              key, listLength(slot_nodes), slot_nodes_str);
3171              sdsfree(slot_nodes_str);
3172              dictAdd(clusterManagerUncoveredSlots, key, slot_nodes);
3173          }
3174      }
3175      printf("\n%s\n", log);
3176      none = listCreate();
3177      single = listCreate();
3178      multi = listCreate();
3179      dictIterator *iter = dictGetIterator(clusterManagerUncoveredSlots);
3180      dictEntry *entry;
3181      while ((entry = dictNext(iter)) != NULL) {
3182          sds slot = (sds) dictGetKey(entry);
3183          list *nodes = (list *) dictGetVal(entry);
3184          switch (listLength(nodes)){
3185          case 0: listAddNodeTail(none, slot); break;
3186          case 1: listAddNodeTail(single, slot); break;
3187          default: listAddNodeTail(multi, slot); break;
3188          }
3189      }
3190      dictReleaseIterator(iter);
3191      if (listLength(none) > 0) {
3192          printf("The following uncovered slots have no keys "
3193                 "across the cluster:\n");
3194          clusterManagerPrintSlotsList(none);
3195          if (confirmWithYes("Fix these slots by covering with a random node?")){
3196              listIter li;
3197              listNode *ln;
3198              listRewind(none, &li);
3199              while ((ln = listNext(&li)) != NULL) {
3200                  sds slot = ln->value;
3201                  int s = atoi(slot);
3202                  clusterManagerNode *n = clusterManagerNodeMasterRandom();
3203                  clusterManagerLogInfo(">>> Covering slot %s with %s:%d\n",
3204                                        slot, n->ip, n->port);
3205                  if (!clusterManagerSetSlotOwner(n, s, 0)) {
3206                      fixed = -1;
3207                      goto cleanup;
3208                  }
3209                  n->slots[s] = 1;
3210                  fixed++;
3211              }
3212          }
3213      }
3214      if (listLength(single) > 0) {
3215          printf("The following uncovered slots have keys in just one node:\n");
3216          clusterManagerPrintSlotsList(single);
3217          if (confirmWithYes("Fix these slots by covering with those nodes?")){
3218              listIter li;
3219              listNode *ln;
3220              listRewind(single, &li);
3221              while ((ln = listNext(&li)) != NULL) {
3222                  sds slot = ln->value;
3223                  int s = atoi(slot);
3224                  dictEntry *entry = dictFind(clusterManagerUncoveredSlots, slot);
3225                  assert(entry != NULL);
3226                  list *nodes = (list *) dictGetVal(entry);
3227                  listNode *fn = listFirst(nodes);
3228                  assert(fn != NULL);
3229                  clusterManagerNode *n = fn->value;
3230                  clusterManagerLogInfo(">>> Covering slot %s with %s:%d\n",
3231                                        slot, n->ip, n->port);
3232                  if (!clusterManagerSetSlotOwner(n, s, 0)) {
3233                      fixed = -1;
3234                      goto cleanup;
3235                  }
3236                  n->slots[atoi(slot)] = 1;
3237                  fixed++;
3238              }
3239          }
3240      }
3241      if (listLength(multi) > 0) {
3242          printf("The following uncovered slots have keys in multiple nodes:\n");
3243          clusterManagerPrintSlotsList(multi);
3244          if (confirmWithYes("Fix these slots by moving keys "
3245                             "into a single node?")) {
3246              listIter li;
3247              listNode *ln;
3248              listRewind(multi, &li);
3249              while ((ln = listNext(&li)) != NULL) {
3250                  sds slot = ln->value;
3251                  dictEntry *entry = dictFind(clusterManagerUncoveredSlots, slot);
3252                  assert(entry != NULL);
3253                  list *nodes = (list *) dictGetVal(entry);
3254                  int s = atoi(slot);
3255                  clusterManagerNode *target =
3256                      clusterManagerGetNodeWithMostKeysInSlot(nodes, s, NULL);
3257                  if (target == NULL) {
3258                      fixed = -1;
3259                      goto cleanup;
3260                  }
3261                  clusterManagerLogInfo(">>> Covering slot %s moving keys "
3262                                        "to %s:%d\n", slot,
3263                                        target->ip, target->port);
3264                  if (!clusterManagerSetSlotOwner(target, s, 1)) {
3265                      fixed = -1;
3266                      goto cleanup;
3267                  }
3268                  target->slots[atoi(slot)] = 1;
3269                  listIter nli;
3270                  listNode *nln;
3271                  listRewind(nodes, &nli);
3272                  while ((nln = listNext(&nli)) != NULL) {
3273                      clusterManagerNode *src = nln->value;
3274                      if (src == target) continue;
3275                      if (!clusterManagerSetSlot(src, target, s, "NODE", NULL))
3276                          fixed = -1;
3277                      if (fixed < 0) goto cleanup;
3278                      if (!clusterManagerSetSlot(src, target, s,
3279                                                 "IMPORTING", NULL)) fixed = -1;
3280                      if (fixed < 0) goto cleanup;
3281                      int opts = CLUSTER_MANAGER_OPT_VERBOSE |
3282                                 CLUSTER_MANAGER_OPT_COLD;
3283                      if (!clusterManagerMoveSlot(src, target, s, opts, NULL)) {
3284                          fixed = -1;
3285                          goto cleanup;
3286                      }
3287                      if (!clusterManagerClearSlotStatus(src, s))
3288                          fixed = -1;
3289                      if (fixed < 0) goto cleanup;
3290                  }
3291                  fixed++;
3292              }
3293          }
3294      }
3295  cleanup:
3296      sdsfree(log);
3297      if (none) listRelease(none);
3298      if (single) listRelease(single);
3299      if (multi) listRelease(multi);
3300      return fixed;
3301  }
3302  static int clusterManagerFixOpenSlot(int slot) {
3303      clusterManagerLogInfo(">>> Fixing open slot %d\n", slot);
3304      int success = 1;
3305      list *owners = listCreate();
3306      list *migrating = listCreate();
3307      list *importing = listCreate();
3308      sds migrating_str = sdsempty();
3309      sds importing_str = sdsempty();
3310      clusterManagerNode *owner = NULL;
3311      listIter li;
3312      listNode *ln;
3313      listRewind(cluster_manager.nodes, &li);
3314      while ((ln = listNext(&li)) != NULL) {
3315          clusterManagerNode *n = ln->value;
3316          if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
3317          if (n->slots[slot]) listAddNodeTail(owners, n);
3318          else {
3319              redisReply *r = CLUSTER_MANAGER_COMMAND(n,
3320                  "CLUSTER COUNTKEYSINSLOT %d", slot);
3321              success = clusterManagerCheckRedisReply(n, r, NULL);
3322              if (success && r->integer > 0) {
3323                  clusterManagerLogWarn("*** Found keys about slot %d "
3324                                        "in non-owner node %s:%d!\n", slot,
3325                                        n->ip, n->port);
3326                  listAddNodeTail(owners, n);
3327              }
3328              if (r) freeReplyObject(r);
3329              if (!success) goto cleanup;
3330          }
3331      }
3332      if (listLength(owners) == 1) owner = listFirst(owners)->value;
3333      listRewind(cluster_manager.nodes, &li);
3334      while ((ln = listNext(&li)) != NULL) {
3335          clusterManagerNode *n = ln->value;
3336          if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
3337          int is_migrating = 0, is_importing = 0;
3338          if (n->migrating) {
3339              for (int i = 0; i < n->migrating_count; i += 2) {
3340                  sds migrating_slot = n->migrating[i];
3341                  if (atoi(migrating_slot) == slot) {
3342                      char *sep = (listLength(migrating) == 0 ? "" : ",");
3343                      migrating_str = sdscatfmt(migrating_str, "%s%s:%u",
3344                                                sep, n->ip, n->port);
3345                      listAddNodeTail(migrating, n);
3346                      is_migrating = 1;
3347                      break;
3348                  }
3349              }
3350          }
3351          if (!is_migrating && n->importing) {
3352              for (int i = 0; i < n->importing_count; i += 2) {
3353                  sds importing_slot = n->importing[i];
3354                  if (atoi(importing_slot) == slot) {
3355                      char *sep = (listLength(importing) == 0 ? "" : ",");
3356                      importing_str = sdscatfmt(importing_str, "%s%s:%u",
3357                                                sep, n->ip, n->port);
3358                      listAddNodeTail(importing, n);
3359                      is_importing = 1;
3360                      break;
3361                  }
3362              }
3363          }
3364          if (!is_migrating && !is_importing && n != owner) {
3365              redisReply *r = CLUSTER_MANAGER_COMMAND(n,
3366                  "CLUSTER COUNTKEYSINSLOT %d", slot);
3367              success = clusterManagerCheckRedisReply(n, r, NULL);
3368              if (success && r->integer > 0) {
3369                  clusterManagerLogWarn("*** Found keys about slot %d "
3370                                        "in node %s:%d!\n", slot, n->ip,
3371                                        n->port);
3372                  char *sep = (listLength(importing) == 0 ? "" : ",");
3373                  importing_str = sdscatfmt(importing_str, "%s%S:%u",
3374                                            sep, n->ip, n->port);
3375                  listAddNodeTail(importing, n);
3376              }
3377              if (r) freeReplyObject(r);
3378              if (!success) goto cleanup;
3379          }
3380      }
3381      if (sdslen(migrating_str) > 0)
3382          printf("Set as migrating in: %s\n", migrating_str);
3383      if (sdslen(importing_str) > 0)
3384          printf("Set as importing in: %s\n", importing_str);
3385      if (owner == NULL) {
3386          clusterManagerLogInfo(">>> Nobody claims ownership, "
3387                                "selecting an owner...\n");
3388          owner = clusterManagerGetNodeWithMostKeysInSlot(cluster_manager.nodes,
3389                                                          slot, NULL);
3390          if (owner == NULL) {
3391              clusterManagerLogErr("[ERR] Can't select a slot owner. "
3392                                   "Impossible to fix.\n");
3393              success = 0;
3394              goto cleanup;
3395          }
3396          clusterManagerLogWarn("*** Configuring %s:%d as the slot owner\n",
3397                                owner->ip, owner->port);
3398          success = clusterManagerClearSlotStatus(owner, slot);
3399          if (!success) goto cleanup;
3400          success = clusterManagerSetSlotOwner(owner, slot, 0);
3401          if (!success) goto cleanup;
3402          owner->slots[slot] = 1;
3403          success = clusterManagerBumpEpoch(owner);
3404          if (!success) goto cleanup;
3405          clusterManagerRemoveNodeFromList(migrating, owner);
3406          clusterManagerRemoveNodeFromList(importing, owner);
3407      }
3408      if (listLength(owners) > 1) {
3409          assert(owner != NULL);
3410          listRewind(owners, &li);
3411          while ((ln = listNext(&li)) != NULL) {
3412              clusterManagerNode *n = ln->value;
3413              if (n == owner) continue;
3414              success = clusterManagerDelSlot(n, slot, 1);
3415              if (!success) goto cleanup;
3416              n->slots[slot] = 0;
3417              success = clusterManagerSetSlot(n, owner, slot, "node", NULL);
3418              if (!success) goto cleanup;
3419              success = clusterManagerSetSlot(n, owner, slot, "importing", NULL);
3420              if (!success) goto cleanup;
3421              clusterManagerRemoveNodeFromList(importing, n);
3422              listAddNodeTail(importing, n);
3423              clusterManagerRemoveNodeFromList(migrating, n);
3424          }
3425      }
3426      int move_opts = CLUSTER_MANAGER_OPT_VERBOSE;
3427      if (listLength(migrating) == 1 && listLength(importing) == 1) {
3428          clusterManagerNode *src = listFirst(migrating)->value;
3429          clusterManagerNode *dst = listFirst(importing)->value;
3430          clusterManagerLogInfo(">>> Case 1: Moving slot %d from "
3431                                "%s:%d to %s:%d\n", slot,
3432                                src->ip, src->port, dst->ip, dst->port);
3433          move_opts |= CLUSTER_MANAGER_OPT_UPDATE;
3434          success = clusterManagerMoveSlot(src, dst, slot, move_opts, NULL);
3435      }
3436      else if (listLength(migrating) == 0 && listLength(importing) > 0) {
3437          clusterManagerLogInfo(">>> Case 2: Moving all the %d slot keys to its "
3438                                "owner %s:%d\n", slot, owner->ip, owner->port);
3439          move_opts |= CLUSTER_MANAGER_OPT_COLD;
3440          listRewind(importing, &li);
3441          while ((ln = listNext(&li)) != NULL) {
3442              clusterManagerNode *n = ln->value;
3443              if (n == owner) continue;
3444              success = clusterManagerMoveSlot(n, owner, slot, move_opts, NULL);
3445              if (!success) goto cleanup;
3446              clusterManagerLogInfo(">>> Setting %d as STABLE in "
3447                                    "%s:%d\n", slot, n->ip, n->port);
3448              success = clusterManagerClearSlotStatus(n, slot);
3449              if (!success) goto cleanup;
3450          }
3451          listRewind(cluster_manager.nodes, &li);
3452          while ((ln = listNext(&li)) != NULL) {
3453              clusterManagerNode *n = ln->value;
3454              if (n == owner) continue;
3455              if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
3456              success = clusterManagerSetSlot(n, owner, slot, "NODE", NULL);
3457              if (!success) goto cleanup;
3458          }
3459      }
3460      else if (listLength(migrating) == 1 && listLength(importing) > 1) {
3461          int try_to_fix = 1;
3462          clusterManagerNode *src = listFirst(migrating)->value;
3463          clusterManagerNode *dst = NULL;
3464          sds target_id = NULL;
3465          for (int i = 0; i < src->migrating_count; i += 2) {
3466              sds migrating_slot = src->migrating[i];
3467              if (atoi(migrating_slot) == slot) {
3468                  target_id = src->migrating[i + 1];
3469                  break;
3470              }
3471          }
3472          assert(target_id != NULL);
3473          listIter li;
3474          listNode *ln;
3475          listRewind(importing, &li);
3476          while ((ln = listNext(&li)) != NULL) {
3477              clusterManagerNode *n = ln->value;
3478              int count = clusterManagerCountKeysInSlot(n, slot);
3479              if (count > 0) {
3480                  try_to_fix = 0;
3481                  break;
3482              }
3483              if (strcmp(n->name, target_id) == 0) dst = n;
3484          }
3485          if (!try_to_fix) goto unhandled_case;
3486          if (dst != NULL) {
3487              clusterManagerLogInfo(">>> Case 3: Moving slot %d from %s:%d to "
3488                                    "%s:%d and closing it on all the other "
3489                                    "importing nodes.\n",
3490                                    slot, src->ip, src->port,
3491                                    dst->ip, dst->port);
3492              success = clusterManagerMoveSlot(src, dst, slot, move_opts, NULL);
3493              if (!success) goto cleanup;
3494              listRewind(importing, &li);
3495              while ((ln = listNext(&li)) != NULL) {
3496                  clusterManagerNode *n = ln->value;
3497                  if (dst == n) continue;
3498                  success = clusterManagerClearSlotStatus(n, slot);
3499                  if (!success) goto cleanup;
3500              }
3501          } else {
3502              clusterManagerLogInfo(">>> Case 3: Closing slot %d on both "
3503                                    "migrating and importing nodes.\n", slot);
3504              success = clusterManagerClearSlotStatus(src, slot);
3505              if (!success) goto cleanup;
3506              listRewind(importing, &li);
3507              while ((ln = listNext(&li)) != NULL) {
3508                  clusterManagerNode *n = ln->value;
3509                  success = clusterManagerClearSlotStatus(n, slot);
3510                  if (!success) goto cleanup;
3511              }
3512          }
3513      } else {
3514          int try_to_close_slot = (listLength(importing) == 0 &&
3515                                   listLength(migrating) == 1);
3516          if (try_to_close_slot) {
3517              clusterManagerNode *n = listFirst(migrating)->value;
3518              if (!owner || owner != n) {
3519                  redisReply *r = CLUSTER_MANAGER_COMMAND(n,
3520                      "CLUSTER GETKEYSINSLOT %d %d", slot, 10);
3521                  success = clusterManagerCheckRedisReply(n, r, NULL);
3522                  if (r) {
3523                      if (success) try_to_close_slot = (r->elements == 0);
3524                      freeReplyObject(r);
3525                  }
3526                  if (!success) goto cleanup;
3527              }
3528          }
3529          if (try_to_close_slot) {
3530              clusterManagerNode *n = listFirst(migrating)->value;
3531              clusterManagerLogInfo(">>> Case 4: Closing slot %d on %s:%d\n",
3532                                    slot, n->ip, n->port);
3533              redisReply *r = CLUSTER_MANAGER_COMMAND(n, "CLUSTER SETSLOT %d %s",
3534                                                      slot, "STABLE");
3535              success = clusterManagerCheckRedisReply(n, r, NULL);
3536              if (r) freeReplyObject(r);
3537              if (!success) goto cleanup;
3538          } else {
3539  unhandled_case:
3540              success = 0;
3541              clusterManagerLogErr("[ERR] Sorry, redis-cli can't fix this slot "
3542                                   "yet (work in progress). Slot is set as "
3543                                   "migrating in %s, as importing in %s, "
3544                                   "owner is %s:%d\n", migrating_str,
3545                                   importing_str, owner->ip, owner->port);
3546          }
3547      }
3548  cleanup:
3549      listRelease(owners);
3550      listRelease(migrating);
3551      listRelease(importing);
3552      sdsfree(migrating_str);
3553      sdsfree(importing_str);
3554      return success;
3555  }
3556  static int clusterManagerFixMultipleSlotOwners(int slot, list *owners) {
3557      clusterManagerLogInfo(">>> Fixing multiple owners for slot %d...\n", slot);
3558      int success = 0;
3559      assert(listLength(owners) > 1);
3560      clusterManagerNode *owner = clusterManagerGetNodeWithMostKeysInSlot(owners,
3561                                                                          slot,
3562                                                                          NULL);
3563      if (!owner) owner = listFirst(owners)->value;
3564      clusterManagerLogInfo(">>> Setting slot %d owner: %s:%d\n",
3565                            slot, owner->ip, owner->port);
3566      if (!clusterManagerSetSlotOwner(owner, slot, 0)) return 0;
3567      listIter li;
3568      listNode *ln;
3569      listRewind(cluster_manager.nodes, &li);
3570      while ((ln = listNext(&li)) != NULL) {
3571          clusterManagerNode *n = ln->value;
3572          if (n == owner) continue;
3573          if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
3574          int count = clusterManagerCountKeysInSlot(n, slot);
3575          success = (count >= 0);
3576          if (!success) break;
3577          clusterManagerDelSlot(n, slot, 1);
3578          if (!clusterManagerSetSlot(n, owner, slot, "node", NULL)) return 0;
3579          if (count > 0) {
3580              int opts = CLUSTER_MANAGER_OPT_VERBOSE |
3581                         CLUSTER_MANAGER_OPT_COLD;
3582              success = clusterManagerMoveSlot(n, owner, slot, opts, NULL);
3583              if (!success) break;
3584          }
3585      }
3586      return success;
3587  }
3588  static int clusterManagerCheckCluster(int quiet) {
3589      listNode *ln = listFirst(cluster_manager.nodes);
3590      if (!ln) return 0;
3591      clusterManagerNode *node = ln->value;
3592      clusterManagerLogInfo(">>> Performing Cluster Check (using node %s:%d)\n",
3593                            node->ip, node->port);
3594      int result = 1, consistent = 0;
3595      int do_fix = config.cluster_manager_command.flags &
3596                   CLUSTER_MANAGER_CMD_FLAG_FIX;
3597      if (!quiet) clusterManagerShowNodes();
3598      consistent = clusterManagerIsConfigConsistent();
3599      if (!consistent) {
3600          sds err = sdsnew("[ERR] Nodes don't agree about configuration!");
3601          clusterManagerOnError(err);
3602          result = 0;
3603      } else {
3604          clusterManagerLogOk("[OK] All nodes agree about slots "
3605                              "configuration.\n");
3606      }
3607      clusterManagerLogInfo(">>> Check for open slots...\n");
3608      listIter li;
3609      listRewind(cluster_manager.nodes, &li);
3610      int i;
3611      dict *open_slots = NULL;
3612      while ((ln = listNext(&li)) != NULL) {
3613          clusterManagerNode *n = ln->value;
3614          if (n->migrating != NULL) {
3615              if (open_slots == NULL)
3616                  open_slots = dictCreate(&clusterManagerDictType, NULL);
3617              sds errstr = sdsempty();
3618              errstr = sdscatprintf(errstr,
3619                                  "[WARNING] Node %s:%d has slots in "
3620                                  "migrating state ",
3621                                  n->ip,
3622                                  n->port);
3623              for (i = 0; i < n->migrating_count; i += 2) {
3624                  sds slot = n->migrating[i];
3625                  dictAdd(open_slots, slot, sdsdup(n->migrating[i + 1]));
3626                  char *fmt = (i > 0 ? ",%S" : "%S");
3627                  errstr = sdscatfmt(errstr, fmt, slot);
3628              }
3629              errstr = sdscat(errstr, ".");
3630              clusterManagerOnError(errstr);
3631          }
3632          if (n->importing != NULL) {
3633              if (open_slots == NULL)
3634                  open_slots = dictCreate(&clusterManagerDictType, NULL);
3635              sds errstr = sdsempty();
3636              errstr = sdscatprintf(errstr,
3637                                  "[WARNING] Node %s:%d has slots in "
3638                                  "importing state ",
3639                                  n->ip,
3640                                  n->port);
3641              for (i = 0; i < n->importing_count; i += 2) {
3642                  sds slot = n->importing[i];
3643                  dictAdd(open_slots, slot, sdsdup(n->importing[i + 1]));
3644                  char *fmt = (i > 0 ? ",%S" : "%S");
3645                  errstr = sdscatfmt(errstr, fmt, slot);
3646              }
3647              errstr = sdscat(errstr, ".");
3648              clusterManagerOnError(errstr);
3649          }
3650      }
3651      if (open_slots != NULL) {
3652          result = 0;
3653          dictIterator *iter = dictGetIterator(open_slots);
3654          dictEntry *entry;
3655          sds errstr = sdsnew("[WARNING] The following slots are open: ");
3656          i = 0;
3657          while ((entry = dictNext(iter)) != NULL) {
3658              sds slot = (sds) dictGetKey(entry);
3659              char *fmt = (i++ > 0 ? ",%S" : "%S");
3660              errstr = sdscatfmt(errstr, fmt, slot);
3661          }
3662          clusterManagerLogErr("%s.\n", (char *) errstr);
3663          sdsfree(errstr);
3664          if (do_fix) {
3665              dictReleaseIterator(iter);
3666              iter = dictGetIterator(open_slots);
3667              while ((entry = dictNext(iter)) != NULL) {
3668                  sds slot = (sds) dictGetKey(entry);
3669                  result = clusterManagerFixOpenSlot(atoi(slot));
3670                  if (!result) break;
3671              }
3672          }
3673          dictReleaseIterator(iter);
3674          dictRelease(open_slots);
3675      }
3676      clusterManagerLogInfo(">>> Check slots coverage...\n");
3677      char slots[CLUSTER_MANAGER_SLOTS];
3678      memset(slots, 0, CLUSTER_MANAGER_SLOTS);
3679      int coverage = clusterManagerGetCoveredSlots(slots);
3680      if (coverage == CLUSTER_MANAGER_SLOTS) {
3681          clusterManagerLogOk("[OK] All %d slots covered.\n",
3682                              CLUSTER_MANAGER_SLOTS);
3683      } else {
3684          sds err = sdsempty();
3685          err = sdscatprintf(err, "[ERR] Not all %d slots are "
3686                                  "covered by nodes.\n",
3687                                  CLUSTER_MANAGER_SLOTS);
3688          clusterManagerOnError(err);
3689          result = 0;
3690          if (do_fix&bsol;* && result*/) {
3691              dictType dtype = clusterManagerDictType;
3692              dtype.keyDestructor = dictSdsDestructor;
3693              dtype.valDestructor = dictListDestructor;
3694              clusterManagerUncoveredSlots = dictCreate(&dtype, NULL);
3695              int fixed = clusterManagerFixSlotsCoverage(slots);
3696              if (fixed > 0) result = 1;
3697          }
3698      }
3699      int search_multiple_owners = config.cluster_manager_command.flags &
3700                                   CLUSTER_MANAGER_CMD_FLAG_CHECK_OWNERS;
3701      if (search_multiple_owners) {
3702          clusterManagerLogInfo(">>> Check for multiple slot owners...\n");
3703          int slot = 0;
3704          for (; slot < CLUSTER_MANAGER_SLOTS; slot++) {
3705              listIter li;
3706              listNode *ln;
3707              listRewind(cluster_manager.nodes, &li);
3708              list *owners = listCreate();
3709              while ((ln = listNext(&li)) != NULL) {
3710                  clusterManagerNode *n = ln->value;
3711                  if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
3712                  if (n->slots[slot]) listAddNodeTail(owners, n);
3713                  else {
3714                      int count = clusterManagerCountKeysInSlot(n, slot);
3715                      if (count > 0) listAddNodeTail(owners, n);
3716                  }
3717              }
3718              if (listLength(owners) > 1) {
3719                  result = 0;
3720                  clusterManagerLogErr("[WARNING] Slot %d has %d owners:\n",
3721                                       slot, listLength(owners));
3722                  listRewind(owners, &li);
3723                  while ((ln = listNext(&li)) != NULL) {
3724                      clusterManagerNode *n = ln->value;
3725                      clusterManagerLogErr("    %s:%d\n", n->ip, n->port);
3726                  }
3727                  if (do_fix) {
3728                      result = clusterManagerFixMultipleSlotOwners(slot, owners);
3729                      if (!result) {
3730                          clusterManagerLogErr("Failed to fix multiple owners "
3731                                               "for slot %d\n", slot);
3732                          listRelease(owners);
3733                          break;
3734                      }
3735                  }
3736              }
3737              listRelease(owners);
3738          }
3739      }
3740      return result;
3741  }
3742  static clusterManagerNode *clusterNodeForResharding(char *id,
3743                                                      clusterManagerNode *target,
3744                                                      int *raise_err)
3745  {
3746      clusterManagerNode *node = NULL;
3747      const char *invalid_node_msg = "*** The specified node (%s) is not known "
3748                                     "or not a master, please retry.\n";
3749      node = clusterManagerNodeByName(id);
3750      *raise_err = 0;
3751      if (!node || node->flags & CLUSTER_MANAGER_FLAG_SLAVE) {
3752          clusterManagerLogErr(invalid_node_msg, id);
3753          *raise_err = 1;
3754          return NULL;
3755      } else if (node != NULL && target != NULL) {
3756          if (!strcmp(node->name, target->name)) {
3757              clusterManagerLogErr( "*** It is not possible to use "
3758                                    "the target node as "
3759                                    "source node.\n");
3760              return NULL;
3761          }
3762      }
3763      return node;
3764  }
3765  static list *clusterManagerComputeReshardTable(list *sources, int numslots) {
3766      list *moved = listCreate();
3767      int src_count = listLength(sources), i = 0, tot_slots = 0, j;
3768      clusterManagerNode **sorted = zmalloc(src_count * sizeof(*sorted));
3769      listIter li;
3770      listNode *ln;
3771      listRewind(sources, &li);
3772      while ((ln = listNext(&li)) != NULL) {
3773          clusterManagerNode *node = ln->value;
3774          tot_slots += node->slots_count;
3775          sorted[i++] = node;
3776      }
3777      qsort(sorted, src_count, sizeof(clusterManagerNode *),
3778            clusterManagerSlotCountCompareDesc);
3779      for (i = 0; i < src_count; i++) {
3780          clusterManagerNode *node = sorted[i];
3781          float n = ((float) numslots / tot_slots * node->slots_count);
3782          if (i == 0) n = ceil(n);
3783          else n = floor(n);
3784          int max = (int) n, count = 0;
3785          for (j = 0; j < CLUSTER_MANAGER_SLOTS; j++) {
3786              int slot = node->slots[j];
3787              if (!slot) continue;
3788              if (count >= max || (int)listLength(moved) >= numslots) break;
3789              clusterManagerReshardTableItem *item = zmalloc(sizeof(*item));
3790              item->source = node;
3791              item->slot = j;
3792              listAddNodeTail(moved, item);
3793              count++;
3794          }
3795      }
3796      zfree(sorted);
3797      return moved;
3798  }
3799  static void clusterManagerShowReshardTable(list *table) {
3800      listIter li;
3801      listNode *ln;
3802      listRewind(table, &li);
3803      while ((ln = listNext(&li)) != NULL) {
3804          clusterManagerReshardTableItem *item = ln->value;
3805          clusterManagerNode *n = item->source;
3806          printf("    Moving slot %d from %s\n", item->slot, (char *) n->name);
3807      }
3808  }
3809  static void clusterManagerReleaseReshardTable(list *table) {
3810      if (table != NULL) {
3811          listIter li;
3812          listNode *ln;
3813          listRewind(table, &li);
3814          while ((ln = listNext(&li)) != NULL) {
3815              clusterManagerReshardTableItem *item = ln->value;
3816              zfree(item);
3817          }
3818          listRelease(table);
3819      }
3820  }
3821  static void clusterManagerLog(int level, const char* fmt, ...) {
3822      int use_colors =
3823          (config.cluster_manager_command.flags & CLUSTER_MANAGER_CMD_FLAG_COLOR);
3824      if (use_colors) {
3825          printf("\033[");
3826          switch (level) {
3827          case CLUSTER_MANAGER_LOG_LVL_INFO: printf(LOG_COLOR_BOLD); break;
3828          case CLUSTER_MANAGER_LOG_LVL_WARN: printf(LOG_COLOR_YELLOW); break;
3829          case CLUSTER_MANAGER_LOG_LVL_ERR: printf(LOG_COLOR_RED); break;
3830          case CLUSTER_MANAGER_LOG_LVL_SUCCESS: printf(LOG_COLOR_GREEN); break;
3831          default: printf(LOG_COLOR_RESET); break;
3832          }
3833      }
3834      va_list ap;
3835      va_start(ap, fmt);
3836      vprintf(fmt, ap);
3837      va_end(ap);
3838      if (use_colors) printf("\033[" LOG_COLOR_RESET);
3839  }
3840  static void clusterManagerNodeArrayInit(clusterManagerNodeArray *array,
3841                                          int alloc_len)
3842  {
3843      array->nodes = zcalloc(alloc_len * sizeof(clusterManagerNode*));
3844      array->alloc = array->nodes;
3845      array->len = alloc_len;
3846      array->count = 0;
3847  }
3848  static void clusterManagerNodeArrayReset(clusterManagerNodeArray *array) {
3849      if (array->nodes > array->alloc) {
3850          array->len = array->nodes - array->alloc;
3851          array->nodes = array->alloc;
3852          array->count = 0;
3853          int i = 0;
3854          for(; i < array->len; i++) {
3855              if (array->nodes[i] != NULL) array->count++;
3856          }
3857      }
3858  }
3859  static void clusterManagerNodeArrayShift(clusterManagerNodeArray *array,
3860                                           clusterManagerNode **nodeptr)
3861  {
3862      assert(array->nodes < (array->nodes + array->len));
3863      if (*array->nodes != NULL) array->count--;
3864      *nodeptr = *array->nodes;
3865      array->nodes++;
3866      array->len--;
3867  }
3868  static void clusterManagerNodeArrayAdd(clusterManagerNodeArray *array,
3869                                         clusterManagerNode *node)
3870  {
3871      assert(array->nodes < (array->nodes + array->len));
3872      assert(node != NULL);
3873      assert(array->count < array->len);
3874      array->nodes[array->count++] = node;
3875  }
3876  static void clusterManagerPrintNotEmptyNodeError(clusterManagerNode *node,
3877                                                   char *err)
3878  {
3879      char *msg;
3880      if (err) msg = err;
3881      else {
3882          msg = "is not empty. Either the node already knows other "
3883                "nodes (check with CLUSTER NODES) or contains some "
3884                "key in database 0.";
3885      }
3886      clusterManagerLogErr("[ERR] Node %s:%d %s\n", node->ip, node->port, msg);
3887  }
3888  static void clusterManagerPrintNotClusterNodeError(clusterManagerNode *node,
3889                                                     char *err)
3890  {
3891      char *msg = (err ? err : "is not configured as a cluster node.");
3892      clusterManagerLogErr("[ERR] Node %s:%d %s\n", node->ip, node->port, msg);
3893  }
3894  static void clusterManagerMode(clusterManagerCommandProc *proc) {
3895      int argc = config.cluster_manager_command.argc;
3896      char **argv = config.cluster_manager_command.argv;
3897      cluster_manager.nodes = NULL;
3898      if (!proc(argc, argv)) goto cluster_manager_err;
3899      freeClusterManager();
3900      exit(0);
3901  cluster_manager_err:
3902      freeClusterManager();
3903      sdsfree(config.hostip);
3904      sdsfree(config.mb_delim);
3905      exit(1);
3906  }
3907  static int clusterManagerCommandCreate(int argc, char **argv) {
3908      int i, j, success = 1;
3909      cluster_manager.nodes = listCreate();
3910      for (i = 0; i < argc; i++) {
3911          char *addr = argv[i];
3912          char *c = strrchr(addr, '@');
3913          if (c != NULL) *c = '\0';
3914          c = strrchr(addr, ':');
3915          if (c == NULL) {
3916              fprintf(stderr, "Invalid address format: %s\n", addr);
3917              return 0;
3918          }
3919          *c = '\0';
3920          char *ip = addr;
3921          int port = atoi(++c);
3922          clusterManagerNode *node = clusterManagerNewNode(ip, port);
3923          if (!clusterManagerNodeConnect(node)) {
3924              freeClusterManagerNode(node);
3925              return 0;
3926          }
3927          char *err = NULL;
3928          if (!clusterManagerNodeIsCluster(node, &err)) {
3929              clusterManagerPrintNotClusterNodeError(node, err);
3930              if (err) zfree(err);
3931              freeClusterManagerNode(node);
3932              return 0;
3933          }
3934          err = NULL;
3935          if (!clusterManagerNodeLoadInfo(node, 0, &err)) {
3936              if (err) {
3937                  CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
3938                  zfree(err);
3939              }
3940              freeClusterManagerNode(node);
3941              return 0;
3942          }
3943          err = NULL;
3944          if (!clusterManagerNodeIsEmpty(node, &err)) {
3945              clusterManagerPrintNotEmptyNodeError(node, err);
3946              if (err) zfree(err);
3947              freeClusterManagerNode(node);
3948              return 0;
3949          }
3950          listAddNodeTail(cluster_manager.nodes, node);
3951      }
3952      int node_len = cluster_manager.nodes->len;
3953      int replicas = config.cluster_manager_command.replicas;
3954      int masters_count = CLUSTER_MANAGER_MASTERS_COUNT(node_len, replicas);
3955      if (masters_count < 3) {
3956          clusterManagerLogErr(
3957              "*** ERROR: Invalid configuration for cluster creation.\n"
3958              "*** Redis Cluster requires at least 3 master nodes.\n"
3959              "*** This is not possible with %d nodes and %d replicas per node.",
3960              node_len, replicas);
3961          clusterManagerLogErr("\n*** At least %d nodes are required.\n",
3962                               3 * (replicas + 1));
3963          return 0;
3964      }
3965      clusterManagerLogInfo(">>> Performing hash slots allocation "
3966                            "on %d nodes...\n", node_len);
3967      int interleaved_len = 0, ip_count = 0;
3968      clusterManagerNode **interleaved = zcalloc(node_len*sizeof(**interleaved));
3969      char **ips = zcalloc(node_len * sizeof(char*));
3970      clusterManagerNodeArray *ip_nodes = zcalloc(node_len * sizeof(*ip_nodes));
3971      listIter li;
3972      listNode *ln;
3973      listRewind(cluster_manager.nodes, &li);
3974      while ((ln = listNext(&li)) != NULL) {
3975          clusterManagerNode *n = ln->value;
3976          int found = 0;
3977          for (i = 0; i < ip_count; i++) {
3978              char *ip = ips[i];
3979              if (!strcmp(ip, n->ip)) {
3980                  found = 1;
3981                  break;
3982              }
3983          }
3984          if (!found) {
3985              ips[ip_count++] = n->ip;
3986          }
3987          clusterManagerNodeArray *node_array = &(ip_nodes[i]);
3988          if (node_array->nodes == NULL)
3989              clusterManagerNodeArrayInit(node_array, node_len);
3990          clusterManagerNodeArrayAdd(node_array, n);
3991      }
3992      while (interleaved_len < node_len) {
3993          for (i = 0; i < ip_count; i++) {
3994              clusterManagerNodeArray *node_array = &(ip_nodes[i]);
3995              if (node_array->count > 0) {
3996                  clusterManagerNode *n = NULL;
3997                  clusterManagerNodeArrayShift(node_array, &n);
3998                  interleaved[interleaved_len++] = n;
3999              }
4000          }
4001      }
4002      clusterManagerNode **masters = interleaved;
4003      interleaved += masters_count;
4004      interleaved_len -= masters_count;
4005      float slots_per_node = CLUSTER_MANAGER_SLOTS / (float) masters_count;
4006      PORT_LONG first = 0;
4007      float cursor = 0.0f;
4008      for (i = 0; i < masters_count; i++) {
4009          clusterManagerNode *master = masters[i];
4010          PORT_LONG last = lround(cursor + slots_per_node - 1);
4011          if (last > CLUSTER_MANAGER_SLOTS || i == (masters_count - 1))
4012              last = CLUSTER_MANAGER_SLOTS - 1;
4013          if (last < first) last = first;
4014          printf("Master[%d] -> Slots %lu - %lu\n", i, first, last);
4015          master->slots_count = 0;
4016          for (j = first; j <= last; j++) {
4017              master->slots[j] = 1;
4018              master->slots_count++;
4019          }
4020          master->dirty = 1;
4021          first = last + 1;
4022          cursor += slots_per_node;
4023      }
4024      clusterManagerNode *first_node = interleaved[0];
4025      for (i = 0; i < (interleaved_len - 1); i++)
4026          interleaved[i] = interleaved[i + 1];
4027      interleaved[interleaved_len - 1] = first_node;
4028      int assign_unused = 0, available_count = interleaved_len;
4029  assign_replicas:
4030      for (i = 0; i < masters_count; i++) {
4031          clusterManagerNode *master = masters[i];
4032          int assigned_replicas = 0;
4033          while (assigned_replicas < replicas) {
4034              if (available_count == 0) break;
4035              clusterManagerNode *found = NULL, *slave = NULL;
4036              int firstNodeIdx = -1;
4037              for (j = 0; j < interleaved_len; j++) {
4038                  clusterManagerNode *n = interleaved[j];
4039                  if (n == NULL) continue;
4040                  if (strcmp(n->ip, master->ip)) {
4041                      found = n;
4042                      interleaved[j] = NULL;
4043                      break;
4044                  }
4045                  if (firstNodeIdx < 0) firstNodeIdx = j;
4046              }
4047              if (found) slave = found;
4048              else if (firstNodeIdx >= 0) {
4049                  slave = interleaved[firstNodeIdx];
4050                  interleaved_len -= (interleaved - (interleaved + firstNodeIdx));
4051                  interleaved += (firstNodeIdx + 1);
4052              }
4053              if (slave != NULL) {
4054                  assigned_replicas++;
4055                  available_count--;
4056                  if (slave->replicate) sdsfree(slave->replicate);
4057                  slave->replicate = sdsnew(master->name);
4058                  slave->dirty = 1;
4059              } else break;
4060              printf("Adding replica %s:%d to %s:%d\n", slave->ip, slave->port,
4061                     master->ip, master->port);
4062              if (assign_unused) break;
4063          }
4064      }
4065      if (!assign_unused && available_count > 0) {
4066          assign_unused = 1;
4067          printf("Adding extra replicas...\n");
4068          goto assign_replicas;
4069      }
4070      for (i = 0; i < ip_count; i++) {
4071          clusterManagerNodeArray *node_array = ip_nodes + i;
4072          clusterManagerNodeArrayReset(node_array);
4073      }
4074      clusterManagerOptimizeAntiAffinity(ip_nodes, ip_count);
4075      clusterManagerShowNodes();
4076      if (confirmWithYes("Can I set the above configuration?")) {
4077          listRewind(cluster_manager.nodes, &li);
4078          while ((ln = listNext(&li)) != NULL) {
4079              clusterManagerNode *node = ln->value;
4080              char *err = NULL;
4081              int flushed = clusterManagerFlushNodeConfig(node, &err);
4082              if (!flushed && node->dirty && !node->replicate) {
4083                  if (err != NULL) {
4084                      CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
4085                      zfree(err);
4086                  }
4087                  success = 0;
4088                  goto cleanup;
4089              } else if (err != NULL) zfree(err);
4090          }
4091          clusterManagerLogInfo(">>> Nodes configuration updated\n");
4092          clusterManagerLogInfo(">>> Assign a different config epoch to "
4093                                "each node\n");
4094          int config_epoch = 1;
4095          listRewind(cluster_manager.nodes, &li);
4096          while ((ln = listNext(&li)) != NULL) {
4097              clusterManagerNode *node = ln->value;
4098              redisReply *reply = NULL;
4099              reply = CLUSTER_MANAGER_COMMAND(node,
4100                                              "cluster set-config-epoch %d",
4101                                              config_epoch++);
4102              if (reply != NULL) freeReplyObject(reply);
4103          }
4104          clusterManagerLogInfo(">>> Sending CLUSTER MEET messages to join "
4105                                "the cluster\n");
4106          clusterManagerNode *first = NULL;
4107          listRewind(cluster_manager.nodes, &li);
4108          while ((ln = listNext(&li)) != NULL) {
4109              clusterManagerNode *node = ln->value;
4110              if (first == NULL) {
4111                  first = node;
4112                  continue;
4113              }
4114              redisReply *reply = NULL;
4115              reply = CLUSTER_MANAGER_COMMAND(node, "cluster meet %s %d",
4116                                              first->ip, first->port);
4117              int is_err = 0;
4118              if (reply != NULL) {
4119                  if ((is_err = reply->type == REDIS_REPLY_ERROR))
4120                      CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, reply->str);
4121                  freeReplyObject(reply);
4122              } else {
4123                  is_err = 1;
4124                  fprintf(stderr, "Failed to send CLUSTER MEET command.\n");
4125              }
4126              if (is_err) {
4127                  success = 0;
4128                  goto cleanup;
4129              }
4130          }
4131          sleep(1);
4132          clusterManagerWaitForClusterJoin();
4133          listRewind(cluster_manager.nodes, &li);
4134          while ((ln = listNext(&li)) != NULL) {
4135              clusterManagerNode *node = ln->value;
4136              if (!node->dirty) continue;
4137              char *err = NULL;
4138              int flushed = clusterManagerFlushNodeConfig(node, &err);
4139              if (!flushed && !node->replicate) {
4140                  if (err != NULL) {
4141                      CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
4142                      zfree(err);
4143                  }
4144                  success = 0;
4145                  goto cleanup;
4146              }
4147          }
4148          listRewind(cluster_manager.nodes, &li);
4149          clusterManagerNode *first_node = NULL;
4150          while ((ln = listNext(&li)) != NULL) {
4151              clusterManagerNode *node = ln->value;
4152              if (!first_node) first_node = node;
4153              else freeClusterManagerNode(node);
4154          }
4155          listEmpty(cluster_manager.nodes);
4156          if (!clusterManagerLoadInfoFromNode(first_node, 0)) {
4157              success = 0;
4158              goto cleanup;
4159          }
4160          clusterManagerCheckCluster(0);
4161      }
4162  cleanup:
4163      zfree(masters);
4164      zfree(ips);
4165      for (i = 0; i < node_len; i++) {
4166          clusterManagerNodeArray *node_array = ip_nodes + i;
4167          CLUSTER_MANAGER_NODE_ARRAY_FREE(node_array);
4168      }
4169      zfree(ip_nodes);
4170      return success;
4171  }
4172  static int clusterManagerCommandAddNode(int argc, char **argv) {
4173      int success = 1;
4174      redisReply *reply = NULL;
4175      char *ref_ip = NULL, *ip = NULL;
4176      int ref_port = 0, port = 0;
4177      if (!getClusterHostFromCmdArgs(argc - 1, argv + 1, &ref_ip, &ref_port))
4178          goto invalid_args;
4179      if (!getClusterHostFromCmdArgs(1, argv, &ip, &port))
4180          goto invalid_args;
4181      clusterManagerLogInfo(">>> Adding node %s:%d to cluster %s:%d\n", ip, port,
4182                            ref_ip, ref_port);
4183      clusterManagerNode *refnode = clusterManagerNewNode(ref_ip, ref_port);
4184      if (!clusterManagerLoadInfoFromNode(refnode, 0)) return 0;
4185      if (!clusterManagerCheckCluster(0)) return 0;
4186      clusterManagerNode *master_node = NULL;
4187      if (config.cluster_manager_command.flags & CLUSTER_MANAGER_CMD_FLAG_SLAVE) {
4188          char *master_id = config.cluster_manager_command.master_id;
4189          if (master_id != NULL) {
4190              master_node = clusterManagerNodeByName(master_id);
4191              if (master_node == NULL) {
4192                  clusterManagerLogErr("[ERR] No such master ID %s\n", master_id);
4193                  return 0;
4194              }
4195          } else {
4196              master_node = clusterManagerNodeWithLeastReplicas();
4197              assert(master_node != NULL);
4198              printf("Automatically selected master %s:%d\n", master_node->ip,
4199                     master_node->port);
4200          }
4201      }
4202      clusterManagerNode *new_node = clusterManagerNewNode(ip, port);
4203      int added = 0;
4204      if (!clusterManagerNodeConnect(new_node)) {
4205          clusterManagerLogErr("[ERR] Sorry, can't connect to node %s:%d\n",
4206                               ip, port);
4207          success = 0;
4208          goto cleanup;
4209      }
4210      char *err = NULL;
4211      if (!(success = clusterManagerNodeIsCluster(new_node, &err))) {
4212          clusterManagerPrintNotClusterNodeError(new_node, err);
4213          if (err) zfree(err);
4214          goto cleanup;
4215      }
4216      if (!clusterManagerNodeLoadInfo(new_node, 0, &err)) {
4217          if (err) {
4218              CLUSTER_MANAGER_PRINT_REPLY_ERROR(new_node, err);
4219              zfree(err);
4220          }
4221          success = 0;
4222          goto cleanup;
4223      }
4224      if (!(success = clusterManagerNodeIsEmpty(new_node, &err))) {
4225          clusterManagerPrintNotEmptyNodeError(new_node, err);
4226          if (err) zfree(err);
4227          goto cleanup;
4228      }
4229      clusterManagerNode *first = listFirst(cluster_manager.nodes)->value;
4230      listAddNodeTail(cluster_manager.nodes, new_node);
4231      added = 1;
4232      clusterManagerLogInfo(">>> Send CLUSTER MEET to node %s:%d to make it "
4233                            "join the cluster.\n", ip, port);
4234      reply = CLUSTER_MANAGER_COMMAND(new_node, "CLUSTER MEET %s %d",
4235                                      first->ip, first->port);
4236      if (!(success = clusterManagerCheckRedisReply(new_node, reply, NULL)))
4237          goto cleanup;
4238      if (master_node) {
4239          sleep(1);
4240          clusterManagerWaitForClusterJoin();
4241          clusterManagerLogInfo(">>> Configure node as replica of %s:%d.\n",
4242                                master_node->ip, master_node->port);
4243          freeReplyObject(reply);
4244          reply = CLUSTER_MANAGER_COMMAND(new_node, "CLUSTER REPLICATE %s",
4245                                          master_node->name);
4246          if (!(success = clusterManagerCheckRedisReply(new_node, reply, NULL)))
4247              goto cleanup;
4248      }
4249      clusterManagerLogOk("[OK] New node added correctly.\n");
4250  cleanup:
4251      if (!added && new_node) freeClusterManagerNode(new_node);
4252      if (reply) freeReplyObject(reply);
4253      return success;
4254  invalid_args:
4255      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4256      return 0;
4257  }
4258  static int clusterManagerCommandDeleteNode(int argc, char **argv) {
4259      UNUSED(argc);
4260      int success = 1;
4261      int port = 0;
4262      char *ip = NULL;
4263      if (!getClusterHostFromCmdArgs(1, argv, &ip, &port)) goto invalid_args;
4264      char *node_id = argv[1];
4265      clusterManagerLogInfo(">>> Removing node %s from cluster %s:%d\n",
4266                            node_id, ip, port);
4267      clusterManagerNode *ref_node = clusterManagerNewNode(ip, port);
4268      clusterManagerNode *node = NULL;
4269      if (!clusterManagerLoadInfoFromNode(ref_node, 0)) return 0;
4270      node = clusterManagerNodeByName(node_id);
4271      if (node == NULL) {
4272          clusterManagerLogErr("[ERR] No such node ID %s\n", node_id);
4273          return 0;
4274      }
4275      if (node->slots_count != 0) {
4276          clusterManagerLogErr("[ERR] Node %s:%d is not empty! Reshard data "
4277                               "away and try again.\n", node->ip, node->port);
4278          return 0;
4279      }
4280      clusterManagerLogInfo(">>> Sending CLUSTER FORGET messages to the "
4281                            "cluster...\n");
4282      listIter li;
4283      listNode *ln;
4284      listRewind(cluster_manager.nodes, &li);
4285      while ((ln = listNext(&li)) != NULL) {
4286          clusterManagerNode *n = ln->value;
4287          if (n == node) continue;
4288          if (n->replicate && !strcasecmp(n->replicate, node_id)) {
4289              clusterManagerNode *master = clusterManagerNodeWithLeastReplicas();
4290              assert(master != NULL);
4291              clusterManagerLogInfo(">>> %s:%d as replica of %s:%d\n",
4292                                    n->ip, n->port, master->ip, master->port);
4293              redisReply *r = CLUSTER_MANAGER_COMMAND(n, "CLUSTER REPLICATE %s",
4294                                                      master->name);
4295              success = clusterManagerCheckRedisReply(n, r, NULL);
4296              if (r) freeReplyObject(r);
4297              if (!success) return 0;
4298          }
4299          redisReply *r = CLUSTER_MANAGER_COMMAND(n, "CLUSTER FORGET %s",
4300                                                  node_id);
4301          success = clusterManagerCheckRedisReply(n, r, NULL);
4302          if (r) freeReplyObject(r);
4303          if (!success) return 0;
4304      }
4305      clusterManagerLogInfo(">>> SHUTDOWN the node.\n");
4306      redisReply *r = redisCommand(node->context, "SHUTDOWN");
4307      success = clusterManagerCheckRedisReply(node, r, NULL);
4308      if (r) freeReplyObject(r);
4309      return success;
4310  invalid_args:
4311      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4312      return 0;
4313  }
4314  static int clusterManagerCommandInfo(int argc, char **argv) {
4315      int port = 0;
4316      char *ip = NULL;
4317      if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) goto invalid_args;
4318      clusterManagerNode *node = clusterManagerNewNode(ip, port);
4319      if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
4320      clusterManagerShowClusterInfo();
4321      return 1;
4322  invalid_args:
4323      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4324      return 0;
4325  }
4326  static int clusterManagerCommandCheck(int argc, char **argv) {
4327      int port = 0;
4328      char *ip = NULL;
4329      if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) goto invalid_args;
4330      clusterManagerNode *node = clusterManagerNewNode(ip, port);
4331      if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
4332      clusterManagerShowClusterInfo();
4333      return clusterManagerCheckCluster(0);
4334  invalid_args:
4335      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4336      return 0;
4337  }
4338  static int clusterManagerCommandFix(int argc, char **argv) {
4339      config.cluster_manager_command.flags |= CLUSTER_MANAGER_CMD_FLAG_FIX;
4340      return clusterManagerCommandCheck(argc, argv);
4341  }
4342  static int clusterManagerCommandReshard(int argc, char **argv) {
4343      int port = 0;
4344      char *ip = NULL;
4345      if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) goto invalid_args;
4346      clusterManagerNode *node = clusterManagerNewNode(ip, port);
4347      if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
4348      clusterManagerCheckCluster(0);
4349      if (cluster_manager.errors && listLength(cluster_manager.errors) > 0) {
4350          fflush(stdout);
4351          fprintf(stderr,
4352                  "*** Please fix your cluster problems before resharding\n");
4353          return 0;
4354      }
4355      int slots = config.cluster_manager_command.slots;
4356      if (!slots) {
4357          while (slots <= 0 || slots > CLUSTER_MANAGER_SLOTS) {
4358              printf("How many slots do you want to move (from 1 to %d)? ",
4359                     CLUSTER_MANAGER_SLOTS);
4360              fflush(stdout);
4361              char buf[6];
4362              int nread = read(fileno(stdin),buf,6);
4363              if (nread <= 0) continue;
4364              int last_idx = nread - 1;
4365              if (buf[last_idx] != '\n') {
4366                  int ch;
4367                  while ((ch = getchar()) != '\n' && ch != EOF) {}
4368              }
4369              buf[last_idx] = '\0';
4370              slots = atoi(buf);
4371          }
4372      }
4373      char buf[255];
4374      char *to = config.cluster_manager_command.to,
4375           *from = config.cluster_manager_command.from;
4376      while (to == NULL) {
4377          printf("What is the receiving node ID? ");
4378          fflush(stdout);
4379          int nread = read(fileno(stdin),buf,255);
4380          if (nread <= 0) continue;
4381          int last_idx = nread - 1;
4382          if (buf[last_idx] != '\n') {
4383              int ch;
4384              while ((ch = getchar()) != '\n' && ch != EOF) {}
4385          }
4386          buf[last_idx] = '\0';
4387          if (strlen(buf) > 0) to = buf;
4388      }
4389      int raise_err = 0;
4390      clusterManagerNode *target = clusterNodeForResharding(to, NULL, &raise_err);
4391      if (target == NULL) return 0;
4392      list *sources = listCreate();
4393      list *table = NULL;
4394      int all = 0, result = 1;
4395      if (from == NULL) {
4396          printf("Please enter all the source node IDs.\n");
4397          printf("  Type 'all' to use all the nodes as source nodes for "
4398                 "the hash slots.\n");
4399          printf("  Type 'done' once you entered all the source nodes IDs.\n");
4400          while (1) {
4401              printf("Source node #%lu: ", listLength(sources) + 1);
4402              fflush(stdout);
4403              int nread = read(fileno(stdin),buf,255);
4404              if (nread <= 0) continue;
4405              int last_idx = nread - 1;
4406              if (buf[last_idx] != '\n') {
4407                  int ch;
4408                  while ((ch = getchar()) != '\n' && ch != EOF) {}
4409              }
4410              buf[last_idx] = '\0';
4411              if (!strcmp(buf, "done")) break;
4412              else if (!strcmp(buf, "all")) {
4413                  all = 1;
4414                  break;
4415              } else {
4416                  clusterManagerNode *src =
4417                      clusterNodeForResharding(buf, target, &raise_err);
4418                  if (src != NULL) listAddNodeTail(sources, src);
4419                  else if (raise_err) {
4420                      result = 0;
4421                      goto cleanup;
4422                  }
4423              }
4424          }
4425      } else {
4426          char *p;
4427          while((p = strchr(from, ',')) != NULL) {
4428              *p = '\0';
4429              if (!strcmp(from, "all")) {
4430                  all = 1;
4431                  break;
4432              } else {
4433                  clusterManagerNode *src =
4434                      clusterNodeForResharding(from, target, &raise_err);
4435                  if (src != NULL) listAddNodeTail(sources, src);
4436                  else if (raise_err) {
4437                      result = 0;
4438                      goto cleanup;
4439                  }
4440              }
4441              from = p + 1;
4442          }
4443          if (!all && strlen(from) > 0) {
4444              if (!strcmp(from, "all")) all = 1;
4445              if (!all) {
4446                  clusterManagerNode *src =
4447                      clusterNodeForResharding(from, target, &raise_err);
4448                  if (src != NULL) listAddNodeTail(sources, src);
4449                  else if (raise_err) {
4450                      result = 0;
4451                      goto cleanup;
4452                  }
4453              }
4454          }
4455      }
4456      listIter li;
4457      listNode *ln;
4458      if (all) {
4459          listEmpty(sources);
4460          listRewind(cluster_manager.nodes, &li);
4461          while ((ln = listNext(&li)) != NULL) {
4462              clusterManagerNode *n = ln->value;
4463              if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE || n->replicate)
4464                  continue;
4465              if (!sdscmp(n->name, target->name)) continue;
4466              listAddNodeTail(sources, n);
4467          }
4468      }
4469      if (listLength(sources) == 0) {
4470          fprintf(stderr, "*** No source nodes given, operation aborted.\n");
4471          result = 0;
4472          goto cleanup;
4473      }
4474      printf("\nReady to move %d slots.\n", slots);
4475      printf("  Source nodes:\n");
4476      listRewind(sources, &li);
4477      while ((ln = listNext(&li)) != NULL) {
4478          clusterManagerNode *src = ln->value;
4479          sds info = clusterManagerNodeInfo(src, 4);
4480          printf("%s\n", info);
4481          sdsfree(info);
4482      }
4483      printf("  Destination node:\n");
4484      sds info = clusterManagerNodeInfo(target, 4);
4485      printf("%s\n", info);
4486      sdsfree(info);
4487      table = clusterManagerComputeReshardTable(sources, slots);
4488      printf("  Resharding plan:\n");
4489      clusterManagerShowReshardTable(table);
4490      if (!(config.cluster_manager_command.flags &
4491            CLUSTER_MANAGER_CMD_FLAG_YES))
4492      {
4493          printf("Do you want to proceed with the proposed "
4494                 "reshard plan (yes/no)? ");
4495          fflush(stdout);
4496          char buf[4];
4497          int nread = read(fileno(stdin),buf,4);
4498          buf[3] = '\0';
4499          if (nread <= 0 || strcmp("yes", buf) != 0) {
4500              result = 0;
4501              goto cleanup;
4502          }
4503      }
4504      int opts = CLUSTER_MANAGER_OPT_VERBOSE;
4505      listRewind(table, &li);
4506      while ((ln = listNext(&li)) != NULL) {
4507          clusterManagerReshardTableItem *item = ln->value;
4508          char *err = NULL;
4509          result = clusterManagerMoveSlot(item->source, target, item->slot,
4510                                          opts, &err);
4511          if (!result) {
4512              if (err != NULL) {
4513                  zfree(err);
4514              }
4515              goto cleanup;
4516          }
4517      }
4518  cleanup:
4519      listRelease(sources);
4520      clusterManagerReleaseReshardTable(table);
4521      return result;
4522  invalid_args:
4523      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4524      return 0;
4525  }
4526  static int clusterManagerCommandRebalance(int argc, char **argv) {
4527      int port = 0;
4528      char *ip = NULL;
4529      clusterManagerNode **weightedNodes = NULL;
4530      list *involved = NULL;
4531      if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) goto invalid_args;
4532      clusterManagerNode *node = clusterManagerNewNode(ip, port);
4533      if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
4534      int result = 1, i;
4535      if (config.cluster_manager_command.weight != NULL) {
4536          for (i = 0; i < config.cluster_manager_command.weight_argc; i++) {
4537              char *name = config.cluster_manager_command.weight[i];
4538              char *p = strchr(name, '=');
4539              if (p == NULL) {
4540                  result = 0;
4541                  goto cleanup;
4542              }
4543              *p = '\0';
4544              float w = atof(++p);
4545              clusterManagerNode *n = clusterManagerNodeByAbbreviatedName(name);
4546              if (n == NULL) {
4547                  clusterManagerLogErr("*** No such master node %s\n", name);
4548                  result = 0;
4549                  goto cleanup;
4550              }
4551              n->weight = w;
4552          }
4553      }
4554      float total_weight = 0;
4555      int nodes_involved = 0;
4556      int use_empty = config.cluster_manager_command.flags &
4557                      CLUSTER_MANAGER_CMD_FLAG_EMPTYMASTER;
4558      involved = listCreate();
4559      listIter li;
4560      listNode *ln;
4561      listRewind(cluster_manager.nodes, &li);
4562      while ((ln = listNext(&li)) != NULL) {
4563          clusterManagerNode *n = ln->value;
4564          if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE || n->replicate)
4565              continue;
4566          if (!use_empty && n->slots_count == 0) {
4567              n->weight = 0;
4568              continue;
4569          }
4570          total_weight += n->weight;
4571          nodes_involved++;
4572          listAddNodeTail(involved, n);
4573      }
4574      weightedNodes = zmalloc(nodes_involved * sizeof(clusterManagerNode *));
4575      if (weightedNodes == NULL) goto cleanup;
4576      clusterManagerCheckCluster(1);
4577      if (cluster_manager.errors && listLength(cluster_manager.errors) > 0) {
4578          clusterManagerLogErr("*** Please fix your cluster problems "
4579                               "before rebalancing\n");
4580          result = 0;
4581          goto cleanup;
4582      }
4583      int threshold_reached = 0, total_balance = 0;
4584      float threshold = config.cluster_manager_command.threshold;
4585      i = 0;
4586      listRewind(involved, &li);
4587      while ((ln = listNext(&li)) != NULL) {
4588          clusterManagerNode *n = ln->value;
4589          weightedNodes[i++] = n;
4590          int expected = (int) (((float)CLUSTER_MANAGER_SLOTS / total_weight) *
4591                          n->weight);
4592          n->balance = n->slots_count - expected;
4593          total_balance += n->balance;
4594          int over_threshold = 0;
4595          if (threshold > 0) {
4596              if (n->slots_count > 0) {
4597                  float err_perc = fabs((100-(100.0*expected/n->slots_count)));
4598                  if (err_perc > threshold) over_threshold = 1;
4599              } else if (expected > 1) {
4600                  over_threshold = 1;
4601              }
4602          }
4603          if (over_threshold) threshold_reached = 1;
4604      }
4605      if (!threshold_reached) {
4606          clusterManagerLogWarn("*** No rebalancing needed! "
4607                               "All nodes are within the %.2f%% threshold.\n",
4608                               config.cluster_manager_command.threshold);
4609          goto cleanup;
4610      }
4611      while (total_balance > 0) {
4612          listRewind(involved, &li);
4613          while ((ln = listNext(&li)) != NULL) {
4614              clusterManagerNode *n = ln->value;
4615              if (n->balance <= 0 && total_balance > 0) {
4616                  n->balance--;
4617                  total_balance--;
4618              }
4619          }
4620      }
4621      qsort(weightedNodes, nodes_involved, sizeof(clusterManagerNode *),
4622            clusterManagerCompareNodeBalance);
4623      clusterManagerLogInfo(">>> Rebalancing across %d nodes. "
4624                            "Total weight = %.2f\n",
4625                            nodes_involved, total_weight);
4626      if (config.verbose) {
4627          for (i = 0; i < nodes_involved; i++) {
4628              clusterManagerNode *n = weightedNodes[i];
4629              printf("%s:%d balance is %d slots\n", n->ip, n->port, n->balance);
4630          }
4631      }
4632      int dst_idx = 0;
4633      int src_idx = nodes_involved - 1;
4634      int simulate = config.cluster_manager_command.flags &
4635                     CLUSTER_MANAGER_CMD_FLAG_SIMULATE;
4636      while (dst_idx < src_idx) {
4637          clusterManagerNode *dst = weightedNodes[dst_idx];
4638          clusterManagerNode *src = weightedNodes[src_idx];
4639          int db = abs(dst->balance);
4640          int sb = abs(src->balance);
4641          int numslots = (db < sb ? db : sb);
4642          if (numslots > 0) {
4643              printf("Moving %d slots from %s:%d to %s:%d\n", numslots,
4644                                                              src->ip,
4645                                                              src->port,
4646                                                              dst->ip,
4647                                                              dst->port);
4648              list *lsrc = listCreate(), *table = NULL;
4649              listAddNodeTail(lsrc, src);
4650              table = clusterManagerComputeReshardTable(lsrc, numslots);
4651              listRelease(lsrc);
4652              int table_len = (int) listLength(table);
4653              if (!table || table_len != numslots) {
4654                  clusterManagerLogErr("*** Assertion failed: Reshard table "
4655                                       "!= number of slots");
4656                  result = 0;
4657                  goto end_move;
4658              }
4659              if (simulate) {
4660                  for (i = 0; i < table_len; i++) printf("#");
4661              } else {
4662                  int opts = CLUSTER_MANAGER_OPT_QUIET |
4663                             CLUSTER_MANAGER_OPT_UPDATE;
4664                  listRewind(table, &li);
4665                  while ((ln = listNext(&li)) != NULL) {
4666                      clusterManagerReshardTableItem *item = ln->value;
4667                      result = clusterManagerMoveSlot(item->source,
4668                                                      dst,
4669                                                      item->slot,
4670                                                      opts, NULL);
4671                      if (!result) goto end_move;
4672                      printf("#");
4673                      fflush(stdout);
4674                  }
4675              }
4676              printf("\n");
4677  end_move:
4678              clusterManagerReleaseReshardTable(table);
4679              if (!result) goto cleanup;
4680          }
4681          dst->balance += numslots;
4682          src->balance -= numslots;
4683          if (dst->balance == 0) dst_idx++;
4684          if (src->balance == 0) src_idx --;
4685      }
4686  cleanup:
4687      if (involved != NULL) listRelease(involved);
4688      if (weightedNodes != NULL) zfree(weightedNodes);
4689      return result;
4690  invalid_args:
4691      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4692      return 0;
4693  }
4694  static int clusterManagerCommandSetTimeout(int argc, char **argv) {
4695      UNUSED(argc);
4696      int port = 0;
4697      char *ip = NULL;
4698      if (!getClusterHostFromCmdArgs(1, argv, &ip, &port)) goto invalid_args;
4699      int timeout = atoi(argv[1]);
4700      if (timeout < 100) {
4701          fprintf(stderr, "Setting a node timeout of less than 100 "
4702                  "milliseconds is a bad idea.\n");
4703          return 0;
4704      }
4705      clusterManagerNode *node = clusterManagerNewNode(ip, port);
4706      if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
4707      int ok_count = 0, err_count = 0;
4708      clusterManagerLogInfo(">>> Reconfiguring node timeout in every "
4709                            "cluster node...\n");
4710      listIter li;
4711      listNode *ln;
4712      listRewind(cluster_manager.nodes, &li);
4713      while ((ln = listNext(&li)) != NULL) {
4714          clusterManagerNode *n = ln->value;
4715          char *err = NULL;
4716          redisReply *reply = CLUSTER_MANAGER_COMMAND(n, "CONFIG %s %s %d",
4717                                                      "SET",
4718                                                      "cluster-node-timeout",
4719                                                      timeout);
4720          if (reply == NULL) goto reply_err;
4721          int ok = clusterManagerCheckRedisReply(n, reply, &err);
4722          freeReplyObject(reply);
4723          if (!ok) goto reply_err;
4724          reply = CLUSTER_MANAGER_COMMAND(n, "CONFIG %s", "REWRITE");
4725          if (reply == NULL) goto reply_err;
4726          ok = clusterManagerCheckRedisReply(n, reply, &err);
4727          freeReplyObject(reply);
4728          if (!ok) goto reply_err;
4729          clusterManagerLogWarn("*** New timeout set for %s:%d\n", n->ip,
4730                                n->port);
4731          ok_count++;
4732          continue;
4733  reply_err:;
4734          int need_free = 0;
4735          if (err == NULL) err = "";
4736          else need_free = 1;
4737          clusterManagerLogErr("ERR setting node-timeot for %s:%d: %s\n", n->ip,
4738                               n->port, err);
4739          if (need_free) zfree(err);
4740          err_count++;
4741      }
4742      clusterManagerLogInfo(">>> New node timeout set. %d OK, %d ERR.\n",
4743                            ok_count, err_count);
4744      return 1;
4745  invalid_args:
4746      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4747      return 0;
4748  }
4749  static int clusterManagerCommandImport(int argc, char **argv) {
4750      int success = 1;
4751      int port = 0, src_port = 0;
4752      char *ip = NULL, *src_ip = NULL;
4753      char *invalid_args_msg = NULL;
4754      if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) {
4755          invalid_args_msg = CLUSTER_MANAGER_INVALID_HOST_ARG;
4756          goto invalid_args;
4757      }
4758      if (config.cluster_manager_command.from == NULL) {
4759          invalid_args_msg = "[ERR] Option '--cluster-from' is required for "
4760                             "subcommand 'import'.\n";
4761          goto invalid_args;
4762      }
4763      char *src_host[] = {config.cluster_manager_command.from};
4764      if (!getClusterHostFromCmdArgs(1, src_host, &src_ip, &src_port)) {
4765          invalid_args_msg = "[ERR] Invalid --cluster-from host. You need to "
4766                             "pass a valid address (ie. 120.0.0.1:7000).\n";
4767          goto invalid_args;
4768      }
4769      clusterManagerLogInfo(">>> Importing data from %s:%d to cluster %s:%d\n",
4770                            src_ip, src_port, ip, port);
4771      clusterManagerNode *refnode = clusterManagerNewNode(ip, port);
4772      if (!clusterManagerLoadInfoFromNode(refnode, 0)) return 0;
4773      if (!clusterManagerCheckCluster(0)) return 0;
4774      char *reply_err = NULL;
4775      redisReply *src_reply = NULL;
4776      redisContext *src_ctx = redisConnect(src_ip, src_port);
4777      if (src_ctx->err) {
4778          success = 0;
4779          fprintf(stderr,"Could not connect to Redis at %s:%d: %s.\n", src_ip,
4780                  src_port, src_ctx->errstr);
4781          goto cleanup;
4782      }
4783      src_reply = reconnectingRedisCommand(src_ctx, "INFO");
4784      if (!src_reply || src_reply->type == REDIS_REPLY_ERROR) {
4785          if (src_reply && src_reply->str) reply_err = src_reply->str;
4786          success = 0;
4787          goto cleanup;
4788      }
4789      if (getLongInfoField(src_reply->str, "cluster_enabled")) {
4790          clusterManagerLogErr("[ERR] The source node should not be a "
4791                               "cluster node.\n");
4792          success = 0;
4793          goto cleanup;
4794      }
4795      freeReplyObject(src_reply);
4796      src_reply = reconnectingRedisCommand(src_ctx, "DBSIZE");
4797      if (!src_reply || src_reply->type == REDIS_REPLY_ERROR) {
4798          if (src_reply && src_reply->str) reply_err = src_reply->str;
4799          success = 0;
4800          goto cleanup;
4801      }
4802      int size = src_reply->integer, i;
4803      clusterManagerLogWarn("*** Importing %d keys from DB 0\n", size);
4804      clusterManagerNode  *slots_map[CLUSTER_MANAGER_SLOTS];
4805      memset(slots_map, 0, sizeof(slots_map));
4806      listIter li;
4807      listNode *ln;
4808      for (i = 0; i < CLUSTER_MANAGER_SLOTS; i++) {
4809          listRewind(cluster_manager.nodes, &li);
4810          while ((ln = listNext(&li)) != NULL) {
4811              clusterManagerNode *n = ln->value;
4812              if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
4813              if (n->slots_count == 0) continue;
4814              if (n->slots[i]) {
4815                  slots_map[i] = n;
4816                  break;
4817              }
4818          }
4819      }
4820      char cmdfmt[50] = "MIGRATE %s %d %s %d %d";
4821      if (config.cluster_manager_command.flags & CLUSTER_MANAGER_CMD_FLAG_COPY)
4822          strcat(cmdfmt, " %s");
4823      if (config.cluster_manager_command.flags & CLUSTER_MANAGER_CMD_FLAG_REPLACE)
4824          strcat(cmdfmt, " %s");
4825      int cursor = -999, timeout = config.cluster_manager_command.timeout;
4826      while (cursor != 0) {
4827          if (cursor < 0) cursor = 0;
4828          freeReplyObject(src_reply);
4829          src_reply = reconnectingRedisCommand(src_ctx, "SCAN %d COUNT %d",
4830                                               cursor, 1000);
4831          if (!src_reply || src_reply->type == REDIS_REPLY_ERROR) {
4832              if (src_reply && src_reply->str) reply_err = src_reply->str;
4833              success = 0;
4834              goto cleanup;
4835          }
4836          assert(src_reply->type == REDIS_REPLY_ARRAY);
4837          assert(src_reply->elements >= 2);
4838          assert(src_reply->element[1]->type == REDIS_REPLY_ARRAY);
4839          if (src_reply->element[0]->type == REDIS_REPLY_STRING)
4840              cursor = atoi(src_reply->element[0]->str);
4841          else if (src_reply->element[0]->type == REDIS_REPLY_INTEGER)
4842              cursor = src_reply->element[0]->integer;
4843          int keycount = src_reply->element[1]->elements;
4844          for (i = 0; i < keycount; i++) {
4845              redisReply *kr = src_reply->element[1]->element[i];
4846              assert(kr->type == REDIS_REPLY_STRING);
4847              char *key = kr->str;
4848              uint16_t slot = clusterManagerKeyHashSlot(key, kr->len);
4849              clusterManagerNode *target = slots_map[slot];
4850              printf("Migrating %s to %s:%d: ", key, target->ip, target->port);
4851              redisReply *r = reconnectingRedisCommand(src_ctx, cmdfmt,
4852                                                       target->ip, target->port,
4853                                                       key, 0, timeout,
4854                                                       "COPY", "REPLACE");
4855              if (!r || r->type == REDIS_REPLY_ERROR) {
4856                  if (r && r->str) {
4857                      clusterManagerLogErr("Source %s:%d replied with "
4858                                           "error:\n%s\n", src_ip, src_port,
4859                                           r->str);
4860                  }
4861                  success = 0;
4862              }
4863              freeReplyObject(r);
4864              if (!success) goto cleanup;
4865              clusterManagerLogOk("OK\n");
4866          }
4867      }
4868  cleanup:
4869      if (reply_err)
4870          clusterManagerLogErr("Source %s:%d replied with error:\n%s\n",
4871                               src_ip, src_port, reply_err);
4872      if (src_ctx) redisFree(src_ctx);
4873      if (src_reply) freeReplyObject(src_reply);
4874      return success;
4875  invalid_args:
4876      fprintf(stderr, "%s", invalid_args_msg);
4877      return 0;
4878  }
4879  static int clusterManagerCommandCall(int argc, char **argv) {
4880      int port = 0, i;
4881      char *ip = NULL;
4882      if (!getClusterHostFromCmdArgs(1, argv, &ip, &port)) goto invalid_args;
4883      clusterManagerNode *refnode = clusterManagerNewNode(ip, port);
4884      if (!clusterManagerLoadInfoFromNode(refnode, 0)) return 0;
4885      argc--;
4886      argv++;
4887      size_t *argvlen = zmalloc(argc*sizeof(size_t));
4888      clusterManagerLogInfo(">>> Calling");
4889      for (i = 0; i < argc; i++) {
4890          argvlen[i] = strlen(argv[i]);
4891          printf(" %s", argv[i]);
4892      }
4893      printf("\n");
4894      listIter li;
4895      listNode *ln;
4896      listRewind(cluster_manager.nodes, &li);
4897      while ((ln = listNext(&li)) != NULL) {
4898          clusterManagerNode *n = ln->value;
4899          if (!n->context && !clusterManagerNodeConnect(n)) continue;
4900          redisReply *reply = NULL;
4901          redisAppendCommandArgv(n->context, argc, (const char **) argv, argvlen);
4902          int status = redisGetReply(n->context, (void **)(&reply));
4903          if (status != REDIS_OK || reply == NULL )
4904              printf("%s:%d: Failed!\n", n->ip, n->port);
4905          else {
4906              sds formatted_reply = cliFormatReplyRaw(reply);
4907              printf("%s:%d: %s\n", n->ip, n->port, (char *) formatted_reply);
4908              sdsfree(formatted_reply);
4909          }
4910          if (reply != NULL) freeReplyObject(reply);
4911      }
4912      zfree(argvlen);
4913      return 1;
4914  invalid_args:
4915      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4916      return 0;
4917  }
4918  static int clusterManagerCommandHelp(int argc, char **argv) {
4919      UNUSED(argc);
4920      UNUSED(argv);
4921      int commands_count = sizeof(clusterManagerCommands) /
4922                           sizeof(clusterManagerCommandDef);
4923      int i = 0, j;
4924      fprintf(stderr, "Cluster Manager Commands:\n");
4925      int padding = 15;
4926      for (; i < commands_count; i++) {
4927          clusterManagerCommandDef *def = &(clusterManagerCommands[i]);
4928          int namelen = strlen(def->name), padlen = padding - namelen;
4929          fprintf(stderr, "  %s", def->name);
4930          for (j = 0; j < padlen; j++) fprintf(stderr, " ");
4931          fprintf(stderr, "%s\n", (def->args ? def->args : ""));
4932          if (def->options != NULL) {
4933              int optslen = strlen(def->options);
4934              char *p = def->options, *eos = p + optslen;
4935              char *comma = NULL;
4936              while ((comma = strchr(p, ',')) != NULL) {
4937                  int deflen = (int)(comma - p);
4938                  char buf[255];
4939                  memcpy(buf, p, deflen);
4940                  buf[deflen] = '\0';
4941                  for (j = 0; j < padding; j++) fprintf(stderr, " ");
4942                  fprintf(stderr, "  --cluster-%s\n", buf);
4943                  p = comma + 1;
4944                  if (p >= eos) break;
4945              }
4946              if (p < eos) {
4947                  for (j = 0; j < padding; j++) fprintf(stderr, " ");
4948                  fprintf(stderr, "  --cluster-%s\n", p);
4949              }
4950          }
4951      }
4952      fprintf(stderr, "\nFor check, fix, reshard, del-node, set-timeout you "
4953                      "can specify the host and port of any working node in "
4954                      "the cluster.\n\n");
4955      return 0;
4956  }
4957  static void latencyModePrint(PORT_LONGLONG min, PORT_LONGLONG max, double avg, PORT_LONGLONG count) {
4958      if (config.output == OUTPUT_STANDARD) {
4959          printf("min: %lld, max: %lld, avg: %.2f (%lld samples)",
4960                  min, max, avg, count);
4961          fflush(stdout);
4962      } else if (config.output == OUTPUT_CSV) {
4963          printf("%lld,%lld,%.2f,%lld\n", min, max, avg, count);
4964      } else if (config.output == OUTPUT_RAW) {
4965          printf("%lld %lld %.2f %lld\n", min, max, avg, count);
4966      }
4967  }
4968  #define LATENCY_SAMPLE_RATE 10 &bsol;* milliseconds. */
4969  #define LATENCY_HISTORY_DEFAULT_INTERVAL 15000 &bsol;* milliseconds. */
4970  static void latencyMode(void) {
4971      redisReply *reply;
4972      PORT_LONGLONG start, latency, min = 0, max = 0, tot = 0, count = 0;
4973      PORT_LONGLONG history_interval =
4974          config.interval ? config.interval/1000 :
4975                            LATENCY_HISTORY_DEFAULT_INTERVAL;
4976      double avg;
4977      PORT_LONGLONG history_start = mstime();
4978      if (config.interval == 0) {
4979          config.interval = 1000;
4980      } else {
4981          config.interval /= 1000; &bsol;* We need to convert to milliseconds. */
4982      }
4983      if (!context) exit(1);
4984      while(1) {
4985          start = mstime();
4986          reply = reconnectingRedisCommand(context,"PING");
4987          if (reply == NULL) {
4988              fprintf(stderr,"\nI/O error\n");
4989              exit(1);
4990          }
4991          latency = mstime()-start;
4992          freeReplyObject(reply);
4993          count++;
4994          if (count == 1) {
4995              min = max = tot = latency;
4996              avg = (double) latency;
4997          } else {
4998              if (latency < min) min = latency;
4999              if (latency > max) max = latency;
5000              tot += latency;
5001              avg = (double) tot/count;
5002          }
5003          if (config.output == OUTPUT_STANDARD) {
5004              printf("\x1b[0G\x1b[2K"); &bsol;* Clear the line. */
5005              latencyModePrint(min,max,avg,count);
5006          } else {
5007              if (config.latency_history) {
5008                  latencyModePrint(min,max,avg,count);
5009              } else if (mstime()-history_start > config.interval) {
5010                  latencyModePrint(min,max,avg,count);
5011                  exit(0);
5012              }
5013          }
5014          if (config.latency_history && mstime()-history_start > history_interval)
5015          {
5016              printf(" -- %.2f seconds range\n", (float)(mstime()-history_start)/1000);
5017              history_start = mstime();
5018              min = max = tot = count = 0;
5019          }
5020          usleep(LATENCY_SAMPLE_RATE * 1000);
5021      }
5022  }
5023  #define LATENCY_DIST_DEFAULT_INTERVAL 1000 &bsol;* milliseconds. */
5024  struct distsamples {
5025      PORT_LONGLONG max;   &bsol;* Max latency to fit into this interval (usec). */
5026      PORT_LONGLONG count; &bsol;* Number of samples in this interval. */
5027      int character;   &bsol;* Associated character in visualization. */
5028  };
5029  void showLatencyDistSamples(struct distsamples *samples, PORT_LONGLONG tot) {
5030      int j;
5031      printf("\033[38;5;0m"); &bsol;* Set foreground color to black. */
5032      for (j = 0; ; j++) {
5033          int coloridx =
5034              (int) ceil((float) samples[j].count / tot * (spectrum_palette_size-1));  WIN_PORT_FIX &bsol;* cast (int) */
5035          int color = spectrum_palette[coloridx];
5036          printf("\033[48;5;%dm%c", (int)color, samples[j].character);
5037          samples[j].count = 0;
5038          if (samples[j].max == 0) break; &bsol;* Last sample. */
5039      }
5040      printf("\033[0m\n");
5041      fflush(stdout);
5042  }
5043  void showLatencyDistLegend(void) {
5044      int j;
5045      printf("---------------------------------------------\n");
5046      printf(". - * #          .01 .125 .25 .5 milliseconds\n");
5047      printf("1,2,3,...,9      from 1 to 9     milliseconds\n");
5048      printf("A,B,C,D,E        10,20,30,40,50  milliseconds\n");
5049      printf("F,G,H,I,J        .1,.2,.3,.4,.5       seconds\n");
5050      printf("K,L,M,N,O,P,Q,?  1,2,4,8,16,30,60,>60 seconds\n");
5051      printf("From 0 to 100%%: ");
5052      for (j = 0; j < spectrum_palette_size; j++) {
5053          printf("\033[48;5;%dm ", spectrum_palette[j]);
5054      }
5055      printf("\033[0m\n");
5056      printf("---------------------------------------------\n");
5057  }
5058  static void latencyDistMode(void) {
5059      redisReply *reply;
5060      PORT_LONGLONG start, latency, count = 0;
5061      PORT_LONGLONG history_interval =
5062          config.interval ? config.interval/1000 :
5063                            LATENCY_DIST_DEFAULT_INTERVAL;
5064      PORT_LONGLONG history_start = ustime();
5065      int j, outputs = 0;
5066      struct distsamples samples[] = {
5067          {10,0,'.'},         &bsol;* 0.01 ms */
5068          {125,0,'-'},        &bsol;* 0.125 ms */
5069          {250,0,'*'},        &bsol;* 0.25 ms */
5070          {500,0,'#'},        &bsol;* 0.5 ms */
5071          {1000,0,'1'},       &bsol;* 1 ms */
5072          {2000,0,'2'},       &bsol;* 2 ms */
5073          {3000,0,'3'},       &bsol;* 3 ms */
5074          {4000,0,'4'},       &bsol;* 4 ms */
5075          {5000,0,'5'},       &bsol;* 5 ms */
5076          {6000,0,'6'},       &bsol;* 6 ms */
5077          {7000,0,'7'},       &bsol;* 7 ms */
5078          {8000,0,'8'},       &bsol;* 8 ms */
5079          {9000,0,'9'},       &bsol;* 9 ms */
5080          {10000,0,'A'},      &bsol;* 10 ms */
5081          {20000,0,'B'},      &bsol;* 20 ms */
5082          {30000,0,'C'},      &bsol;* 30 ms */
5083          {40000,0,'D'},      &bsol;* 40 ms */
5084          {50000,0,'E'},      &bsol;* 50 ms */
5085          {100000,0,'F'},     &bsol;* 0.1 s */
5086          {200000,0,'G'},     &bsol;* 0.2 s */
5087          {300000,0,'H'},     &bsol;* 0.3 s */
5088          {400000,0,'I'},     &bsol;* 0.4 s */
5089          {500000,0,'J'},     &bsol;* 0.5 s */
5090          {1000000,0,'K'},    &bsol;* 1 s */
5091          {2000000,0,'L'},    &bsol;* 2 s */
5092          {4000000,0,'M'},    &bsol;* 4 s */
5093          {8000000,0,'N'},    &bsol;* 8 s */
5094          {16000000,0,'O'},   &bsol;* 16 s */
5095          {30000000,0,'P'},   &bsol;* 30 s */
5096          {60000000,0,'Q'},   &bsol;* 1 minute */
5097          {0,0,'?'},          &bsol;* > 1 minute */
5098      };
5099      if (!context) exit(1);
5100      while(1) {
5101          start = ustime();
5102          reply = reconnectingRedisCommand(context,"PING");
5103          if (reply == NULL) {
5104              fprintf(stderr,"\nI/O error\n");
5105              exit(1);
5106          }
5107          latency = ustime()-start;
5108          freeReplyObject(reply);
5109          count++;
5110          for (j = 0; ; j++) {
5111              if (samples[j].max == 0 || latency <= samples[j].max) {
5112                  samples[j].count++;
5113                  break;
5114              }
5115          }
5116          if (count && (ustime()-history_start)/1000 > history_interval) {
5117              if ((outputs++ % 20) == 0)
5118                  showLatencyDistLegend();
5119              showLatencyDistSamples(samples,count);
5120              history_start = ustime();
5121              count = 0;
5122          }
5123          usleep(LATENCY_SAMPLE_RATE * 1000);
5124      }
5125  }
5126  PORT_ULONGLONG sendSync(int fd) {
5127      char buf[4096], *p;
5128      ssize_t nread;
5129      if (write(fd,"SYNC\r\n",6) != 6) {
5130          fprintf(stderr,"Error writing to master\n");
5131          exit(1);
5132      }
5133      p = buf;
5134      while(1) {
5135          nread = read(fd,p,1);
5136          if (nread <= 0) {
5137              fprintf(stderr,"Error reading bulk length while SYNCing\n");
5138              exit(1);
5139          }
5140          if (*p == '\n' && p != buf) break;
5141          if (*p != '\n') p++;
5142      }
5143      *p = '\0';
5144      if (buf[0] == '-') {
5145          printf("SYNC with master failed: %s\n", buf);
5146          exit(1);
5147      }
5148      return strtoull(buf+1,NULL,10);
5149  }
5150  static void slaveMode(void) {
5151      int fd = context->fd;
5152      PORT_ULONGLONG payload = sendSync(fd);
5153      char buf[1024];
5154      int original_output = config.output;
5155      fprintf(stderr,"SYNC with master, discarding %llu "
5156                     "bytes of bulk transfer...\n", payload);
5157      while(payload) {
5158          ssize_t nread;
5159          nread = read(fd,buf,(payload > sizeof(buf)) ? sizeof(buf) : payload);
5160          if (nread <= 0) {
5161              fprintf(stderr,"Error reading RDB payload while SYNCing\n");
5162              exit(1);
5163          }
5164          payload -= nread;
5165      }
5166      fprintf(stderr,"SYNC done. Logging commands from master.\n");
5167      config.output = OUTPUT_CSV;
5168      while (cliReadReply(0) == REDIS_OK);
5169      config.output = original_output;
5170  }
5171  static void getRDB(void) {
5172      int s = context->fd;
5173      int fd;
5174      PORT_ULONGLONG payload = sendSync(s);
5175      char buf[4096];
5176      fprintf(stderr,"SYNC sent to master, writing %llu bytes to '%s'\n",
5177          payload, config.rdb_filename);
5178      if (!strcmp(config.rdb_filename,"-")) {
5179          fd = STDOUT_FILENO;
5180      } else {
5181          fd = open(config.rdb_filename, O_CREAT|O_WRONLY, 0644);
5182          if (fd == -1) {
5183              fprintf(stderr, "Error opening '%s': %s\n", config.rdb_filename,
5184                  strerror(errno));
5185              exit(1);
5186          }
5187      }
5188      while(payload) {
5189          ssize_t nread, nwritten;
5190          nread = read(s,buf,(payload > sizeof(buf)) ? sizeof(buf) : payload);
5191          if (nread <= 0) {
5192              fprintf(stderr,"I/O Error reading RDB payload from socket\n");
5193              exit(1);
5194          }
5195          nwritten = write(fd, buf, nread);
5196          if (nwritten != nread) {
5197              fprintf(stderr,"Error writing data to file: %s\n",
5198                  (nwritten == -1) ? IF_WIN32(wsa_strerror(errno), strerror(errno)) : "short write");
5199              exit(1);
5200          }
5201          payload -= nread;
5202      }
5203      close(s); &bsol;* Close the file descriptor ASAP as fsync() may take time. */
5204      fsync(fd);
5205      close(fd);
5206      fprintf(stderr,"Transfer finished with success.\n");
5207      exit(0);
5208  }
5209  #define PIPEMODE_WRITE_LOOP_MAX_BYTES (128*1024)
5210  static void pipeMode(void) {
5211      int fd = (int)context->fd;
5212      PORT_LONGLONG errors = 0, replies = 0, obuf_len = 0, obuf_pos = 0;
5213      char ibuf[1024*16], obuf[1024*16]; &bsol;* Input and output buffers */
5214      char aneterr[ANET_ERR_LEN];
5215      redisReader *reader = redisReaderCreate();
5216      redisReply *reply;
5217      int eof = 0; &bsol;* True once we consumed all the standard input. */
5218      int done = 0;
5219      char magic[20]; &bsol;* Special reply we recognize. */
5220      time_t last_read_time = time(NULL);
5221  #ifdef _WIN32
5222      setmode(STDIN_FILENO, _O_BINARY);
5223  #endif
5224      srand((unsigned int) time(NULL));                                            WIN_PORT_FIX &bsol;* cast unsigned int */
5225      if (anetNonBlock(aneterr,fd) == ANET_ERR) {
5226          fprintf(stderr, "Can't set the socket in non blocking mode: %s\n",
5227              aneterr);
5228          exit(1);
5229      }
5230      while(!done) {
5231          int mask = AE_READABLE;
5232          if (!eof || obuf_len != 0) mask |= AE_WRITABLE;
5233          mask = aeWait(fd,mask,1000);
5234          if (mask & AE_READABLE) {
5235              ssize_t nread;
5236              int read_error = 0;
5237              do {
5238                  nread = read(fd,ibuf,sizeof(ibuf));
5239                  if (nread == -1 && errno != EAGAIN && errno != EINTR) {
5240                      fprintf(stderr, "Error reading from the server: %s\n",
5241                          strerror(errno));
5242                      read_error = 1;
5243                      break;
5244                  }
5245                  if (nread > 0) {
5246                      redisReaderFeed(reader,ibuf,nread);
5247                      last_read_time = time(NULL);
5248                  }
5249              } while(nread > 0);
5250              do {
5251                  if (redisReaderGetReply(reader,(void**)&reply) == REDIS_ERR) {
5252                      fprintf(stderr, "Error reading replies from server\n");
5253                      exit(1);
5254                  }
5255                  if (reply) {
5256                      if (reply->type == REDIS_REPLY_ERROR) {
5257                          fprintf(stderr,"%s\n", reply->str);
5258                          errors++;
5259                      } else if (eof && reply->type == REDIS_REPLY_STRING &&
5260                                        reply->len == 20) {
5261                          if (memcmp(reply->str,magic,20) == 0) {
5262                              printf("Last reply received from server.\n");
5263                              done = 1;
5264                              replies--;
5265                          }
5266                      }
5267                      replies++;
5268                      freeReplyObject(reply);
5269                  }
5270              } while(reply);
5271              if (read_error) exit(1);
5272          }
5273          if (mask & AE_WRITABLE) {
5274              ssize_t loop_nwritten = 0;
5275              while(1) {
5276                  if (obuf_len != 0) {
5277                      ssize_t nwritten = write(fd,obuf+obuf_pos,obuf_len);
5278                      if (nwritten == -1) {
5279                          if (errno != EAGAIN && errno != EINTR) {
5280                              fprintf(stderr, "Error writing to the server: %s\n",
5281                                  strerror(errno));
5282                              exit(1);
5283                          } else {
5284                              nwritten = 0;
5285                          }
5286                      }
5287                      obuf_len -= nwritten;
5288                      obuf_pos += nwritten;
5289                      loop_nwritten += nwritten;
5290                      if (obuf_len != 0) break; &bsol;* Can't accept more data. */
5291                  }
5292                  if (obuf_len == 0 && !eof) {
5293                      ssize_t nread = read(STDIN_FILENO,obuf,sizeof(obuf));
5294                      if (nread == 0) {
5295                          char echo[] =
5296                          "\r\n*2\r\n$4\r\nECHO\r\n$20\r\n01234567890123456789\r\n";
5297                          int j;
5298                          eof = 1;
5299                          for (j = 0; j < 20; j++)
5300                              magic[j] = rand() & 0xff;
5301                          memcpy(echo+21,magic,20);
5302                          memcpy(obuf,echo,sizeof(echo)-1);
5303                          obuf_len = sizeof(echo)-1;
5304                          obuf_pos = 0;
5305                          printf("All data transferred. Waiting for the last reply...\n");
5306                      } else if (nread == -1) {
5307                          fprintf(stderr, "Error reading from stdin: %s\n",
5308                              strerror(errno));
5309                          exit(1);
5310                      } else {
5311                          obuf_len = nread;
5312                          obuf_pos = 0;
5313                      }
5314                  }
5315                  if ((obuf_len == 0 && eof) ||
5316                      loop_nwritten > PIPEMODE_WRITE_LOOP_MAX_BYTES) break;
5317              }
5318          }
5319          if (eof && config.pipe_timeout > 0 &&
5320              time(NULL)-last_read_time > config.pipe_timeout)
5321          {
5322              fprintf(stderr,"No replies for %d seconds: exiting.\n",
5323                  config.pipe_timeout);
5324              errors++;
5325              break;
5326          }
5327      }
5328      redisReaderFree(reader);
5329      printf("errors: %lld, replies: %lld\n", errors, replies);
5330      if (errors)
5331          exit(1);
5332      else
5333          exit(0);
5334  }
5335  static redisReply *sendScan(PORT_ULONGLONG *it) {
5336      redisReply *reply = redisCommand(context, "SCAN %llu", *it);
5337      if(reply == NULL) {
5338          fprintf(stderr, "\nI/O error\n");
5339          exit(1);
5340      } else if(reply->type == REDIS_REPLY_ERROR) {
5341          fprintf(stderr, "SCAN error: %s\n", reply->str);
5342          exit(1);
5343      } else if(reply->type != REDIS_REPLY_ARRAY) {
5344          fprintf(stderr, "Non ARRAY response from SCAN!\n");
5345          exit(1);
5346      } else if(reply->elements != 2) {
5347          fprintf(stderr, "Invalid element count from SCAN!\n");
5348          exit(1);
5349      }
5350      assert(reply->element[0]->type == REDIS_REPLY_STRING);
5351      assert(reply->element[1]->type == REDIS_REPLY_ARRAY);
5352      *it = strtoull(reply->element[0]->str, NULL, 10);
5353      return reply;
5354  }
5355  static int getDbSize(void) {
5356      redisReply *reply;
5357      int size;
5358      reply = redisCommand(context, "DBSIZE");
5359      if(reply == NULL || reply->type != REDIS_REPLY_INTEGER) {
5360          fprintf(stderr, "Couldn't determine DBSIZE!\n");
5361          exit(1);
5362      }
5363      size = reply->integer;
5364      freeReplyObject(reply);
5365      return size;
5366  }
5367  typedef struct {
5368      char *name;
5369      char *sizecmd;
5370      char *sizeunit;
5371      PORT_ULONGLONG biggest;
5372      PORT_ULONGLONG count;
5373      PORT_ULONGLONG totalsize;
5374      sds biggest_key;
5375  } typeinfo;
5376  typeinfo type_string = { "string", "STRLEN", "bytes" };
5377  typeinfo type_list = { "list", "LLEN", "items" };
5378  typeinfo type_set = { "set", "SCARD", "members" };
5379  typeinfo type_hash = { "hash", "HLEN", "fields" };
5380  typeinfo type_zset = { "zset", "ZCARD", "members" };
5381  typeinfo type_stream = { "stream", "XLEN", "entries" };
5382  typeinfo type_other = { "other", NULL, "?" };
5383  static typeinfo* typeinfo_add(dict *types, char* name, typeinfo* type_template) {
5384      typeinfo *info = zmalloc(sizeof(typeinfo));
5385      *info = *type_template;
5386      info->name = sdsnew(name);
5387      dictAdd(types, info->name, info);
5388      return info;
5389  }
5390  void type_free(void* priv_data, void* val) {
5391      typeinfo *info = val;
5392      UNUSED(priv_data);
5393      if (info->biggest_key)
5394          sdsfree(info->biggest_key);
5395      sdsfree(info->name);
5396      zfree(info);
5397  }
5398  static dictType typeinfoDictType = {
5399      dictSdsHash,               &bsol;* hash function */
5400      NULL,                      &bsol;* key dup */
5401      NULL,                      &bsol;* val dup */
5402      dictSdsKeyCompare,         &bsol;* key compare */
5403      NULL,                      &bsol;* key destructor (owned by the value)*/
5404      type_free                  &bsol;* val destructor */
5405  };
5406  static void getKeyTypes(dict *types_dict, redisReply *keys, typeinfo **types) {
5407      redisReply *reply;
5408      unsigned int i;
5409      for(i=0;i<keys->elements;i++) {
5410          redisAppendCommand(context, "TYPE %s", keys->element[i]->str);
5411      }
5412      for(i=0;i<keys->elements;i++) {
5413          if(redisGetReply(context, (void**)&reply)!=REDIS_OK) {
5414              fprintf(stderr, "Error getting type for key '%s' (%d: %s)\n",
5415                  keys->element[i]->str, context->err, context->errstr);
5416              exit(1);
5417          } else if(reply->type != REDIS_REPLY_STATUS) {
5418              if(reply->type == REDIS_REPLY_ERROR) {
5419                  fprintf(stderr, "TYPE returned an error: %s\n", reply->str);
5420              } else {
5421                  fprintf(stderr,
5422                      "Invalid reply type (%d) for TYPE on key '%s'!\n",
5423                      reply->type, keys->element[i]->str);
5424              }
5425              exit(1);
5426          }
5427          sds typereply = sdsnew(reply->str);
5428          dictEntry *de = dictFind(types_dict, typereply);
5429          sdsfree(typereply);
5430          typeinfo *type = NULL;
5431          if (de)
5432              type = dictGetVal(de);
5433          else if (strcmp(reply->str, "none")) &bsol;* create new types for modules, (but not for deleted keys) */
5434              type = typeinfo_add(types_dict, reply->str, &type_other);
5435          types[i] = type;
5436          freeReplyObject(reply);
5437      }
5438  }
5439  static void getKeySizes(redisReply *keys, typeinfo **types,
5440                          PORT_ULONGLONG *sizes, int memkeys,
5441                          unsigned memkeys_samples)
5442  {
5443      redisReply *reply;
5444      unsigned int i;
5445      for(i=0;i<keys->elements;i++) {
5446          if(!types[i] || (!types[i]->sizecmd && !memkeys))
5447              continue;
5448          if (!memkeys)
5449              redisAppendCommand(context, "%s %s",
5450                  types[i]->sizecmd, keys->element[i]->str);
5451          else if (memkeys_samples==0)
5452              redisAppendCommand(context, "%s %s %s",
5453                  "MEMORY", "USAGE", keys->element[i]->str);
5454          else
5455              redisAppendCommand(context, "%s %s %s SAMPLES %u",
5456                  "MEMORY", "USAGE", keys->element[i]->str, memkeys_samples);
5457      }
5458      for(i=0;i<keys->elements;i++) {
5459          if(!types[i] || (!types[i]->sizecmd && !memkeys)) {
5460              sizes[i] = 0;
5461              continue;
5462          }
5463          if(redisGetReply(context, (void**)&reply)!=REDIS_OK) {
5464              fprintf(stderr, "Error getting size for key '%s' (%d: %s)\n",
5465                  keys->element[i]->str, context->err, context->errstr);
5466              exit(1);
5467          } else if(reply->type != REDIS_REPLY_INTEGER) {
5468              fprintf(stderr,
5469                  "Warning:  %s on '%s' failed (may have changed type)\n",
5470                  !memkeys? types[i]->sizecmd: "MEMORY USAGE",
5471                  keys->element[i]->str);
5472              sizes[i] = 0;
5473          } else {
5474              sizes[i] = reply->integer;
5475          }
5476          freeReplyObject(reply);
5477      }
5478  }
5479  static void findBigKeys(int memkeys, unsigned memkeys_samples) {
5480      PORT_ULONGLONG sampled = 0, total_keys, totlen=0, *sizes=NULL, it=0;
5481      redisReply *reply, *keys;
5482      unsigned int arrsize=0, i;
5483      dictIterator *di;
5484      dictEntry *de;
5485      typeinfo **types = NULL;
5486      double pct;
5487      dict *types_dict = dictCreate(&typeinfoDictType, NULL);
5488      typeinfo_add(types_dict, "string", &type_string);
5489      typeinfo_add(types_dict, "list", &type_list);
5490      typeinfo_add(types_dict, "set", &type_set);
5491      typeinfo_add(types_dict, "hash", &type_hash);
5492      typeinfo_add(types_dict, "zset", &type_zset);
5493      typeinfo_add(types_dict, "stream", &type_stream);
5494      total_keys = getDbSize();
5495      printf("\n# Scanning the entire keyspace to find biggest keys as well as\n");
5496      printf("# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\n");
5497      printf("# per 100 SCAN commands (not usually needed).\n\n");
5498      do {
5499          pct = 100 * (double)sampled/total_keys;
5500          reply = sendScan(&it);
5501          keys  = reply->element[1];
5502          if(keys->elements > arrsize) {
5503              types = zrealloc(types, sizeof(typeinfo*)*keys->elements);
5504              sizes = zrealloc(sizes, sizeof(PORT_ULONGLONG)*keys->elements);
5505              if(!types || !sizes) {
5506                  fprintf(stderr, "Failed to allocate storage for keys!\n");
5507                  exit(1);
5508              }
5509              arrsize = keys->elements;
5510          }
5511          getKeyTypes(types_dict, keys, types);
5512          getKeySizes(keys, types, sizes, memkeys, memkeys_samples);
5513          for(i=0;i<keys->elements;i++) {
5514              typeinfo *type = types[i];
5515              if(!type)
5516                  continue;
5517              type->totalsize += sizes[i];
5518              type->count++;
5519              totlen += keys->element[i]->len;
5520              sampled++;
5521              if(type->biggest<sizes[i]) {
5522                  printf(
5523                     "[%05.2f%%] Biggest %-6s found so far '%s' with %llu %s\n",
5524                     pct, type->name, keys->element[i]->str, sizes[i],
5525                     !memkeys? type->sizeunit: "bytes");
5526                  if (type->biggest_key)
5527                      sdsfree(type->biggest_key);
5528                  type->biggest_key = sdsnew(keys->element[i]->str);
5529                  if(!type->biggest_key) {
5530                      fprintf(stderr, "Failed to allocate memory for key!\n");
5531                      exit(1);
5532                  }
5533                  type->biggest = sizes[i];
5534              }
5535              if(sampled % 1000000 == 0) {
5536                  printf("[%05.2f%%] Sampled %llu keys so far\n", pct, sampled);
5537              }
5538          }
5539          if(sampled && (sampled %100) == 0 && config.interval) {
5540              usleep(config.interval);
5541          }
5542          freeReplyObject(reply);
5543      } while(it != 0);
5544      if(types) zfree(types);
5545      if(sizes) zfree(sizes);
5546      printf("\n-------- summary -------\n\n");
5547      printf("Sampled %llu keys in the keyspace!\n", sampled);
5548      printf("Total key length in bytes is %llu (avg len %.2f)\n\n",
5549         totlen, totlen ? (double)totlen/sampled : 0);
5550      di = dictGetIterator(types_dict);
5551      while ((de = dictNext(di))) {
5552          typeinfo *type = dictGetVal(de);
5553          if(type->biggest_key) {
5554              printf("Biggest %6s found '%s' has %llu %s\n", type->name, type->biggest_key,
5555                 type->biggest, !memkeys? type->sizeunit: "bytes");
5556          }
5557      }
5558      dictReleaseIterator(di);
5559      printf("\n");
5560      di = dictGetIterator(types_dict);
5561      while ((de = dictNext(di))) {
5562          typeinfo *type = dictGetVal(de);
5563          printf("%llu %ss with %llu %s (%05.2f%% of keys, avg size %.2f)\n",
5564             type->count, type->name, type->totalsize, !memkeys? type->sizeunit: "bytes",
5565             sampled ? 100 * (double)type->count/sampled : 0,
5566             type->count ? (double)type->totalsize/type->count : 0);
5567      }
5568      dictReleaseIterator(di);
5569      dictRelease(types_dict);
5570      exit(0);
5571  }
5572  static void getKeyFreqs(redisReply *keys, PORT_ULONGLONG *freqs) {
5573      redisReply *reply;
5574      unsigned int i;
5575      for(i=0;i<keys->elements;i++) {
5576          redisAppendCommand(context, "OBJECT freq %s", keys->element[i]->str);
5577      }
5578      for(i=0;i<keys->elements;i++) {
5579          if(redisGetReply(context, (void**)&reply)!=REDIS_OK) {
5580              fprintf(stderr, "Error getting freq for key '%s' (%d: %s)\n",
5581                  keys->element[i]->str, context->err, context->errstr);
5582              exit(1);
5583          } else if(reply->type != REDIS_REPLY_INTEGER) {
5584              if(reply->type == REDIS_REPLY_ERROR) {
5585                  fprintf(stderr, "Error: %s\n", reply->str);
5586                  exit(1);
5587              } else {
5588                  fprintf(stderr, "Warning: OBJECT freq on '%s' failed (may have been deleted)\n", keys->element[i]->str);
5589                  freqs[i] = 0;
5590              }
5591          } else {
5592              freqs[i] = reply->integer;
5593          }
5594          freeReplyObject(reply);
5595      }
5596  }
5597  #define HOTKEYS_SAMPLE 16
5598  static void findHotKeys(void) {
5599      redisReply *keys, *reply;
5600      PORT_ULONGLONG counters[HOTKEYS_SAMPLE] = {0};
5601      sds hotkeys[HOTKEYS_SAMPLE] = {NULL};
5602      PORT_ULONGLONG sampled = 0, total_keys, *freqs = NULL, it = 0;
5603      unsigned int arrsize = 0, i, k;
5604      double pct;
5605      total_keys = getDbSize();
5606      printf("\n# Scanning the entire keyspace to find hot keys as well as\n");
5607      printf("# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\n");
5608      printf("# per 100 SCAN commands (not usually needed).\n\n");
5609      do {
5610          pct = 100 * (double)sampled/total_keys;
5611          reply = sendScan(&it);
5612          keys  = reply->element[1];
5613          if(keys->elements > arrsize) {
5614              freqs = zrealloc(freqs, sizeof(PORT_ULONGLONG)*keys->elements);
5615              if(!freqs) {
5616                  fprintf(stderr, "Failed to allocate storage for keys!\n");
5617                  exit(1);
5618              }
5619              arrsize = keys->elements;
5620          }
5621          getKeyFreqs(keys, freqs);
5622          for(i=0;i<keys->elements;i++) {
5623              sampled++;
5624              if(sampled % 1000000 == 0) {
5625                  printf("[%05.2f%%] Sampled %llu keys so far\n", pct, sampled);
5626              }
5627              k = 0;
5628              while (k < HOTKEYS_SAMPLE && freqs[i] > counters[k]) k++;
5629              if (k == 0) continue;
5630              k--;
5631              if (k == 0 || counters[k] == 0) {
5632                  sdsfree(hotkeys[k]);
5633              } else {
5634                  sdsfree(hotkeys[0]);
5635                  memmove(counters,counters+1,sizeof(counters[0])*k);
5636                  memmove(hotkeys,hotkeys+1,sizeof(hotkeys[0])*k);
5637              }
5638              counters[k] = freqs[i];
5639              hotkeys[k] = sdsnew(keys->element[i]->str);
5640              printf(
5641                 "[%05.2f%%] Hot key '%s' found so far with counter %llu\n",
5642                 pct, keys->element[i]->str, freqs[i]);
5643          }
5644          if(sampled && (sampled %100) == 0 && config.interval) {
5645              usleep(config.interval);
5646          }
5647          freeReplyObject(reply);
5648      } while(it != 0);
5649      if (freqs) zfree(freqs);
5650      printf("\n-------- summary -------\n\n");
5651      printf("Sampled %llu keys in the keyspace!\n", sampled);
5652      for (i=1; i<= HOTKEYS_SAMPLE; i++) {
5653          k = HOTKEYS_SAMPLE - i;
5654          if(counters[k]>0) {
5655              printf("hot key found with counter: %llu\tkeyname: %s\n", counters[k], hotkeys[k]);
5656              sdsfree(hotkeys[k]);
5657          }
5658      }
5659      exit(0);
5660  }
5661  static char *getInfoField(char *info, char *field) {
5662      char *p = strstr(info,field);
5663      char *n1, *n2;
5664      char *result;
5665      if (!p) return NULL;
5666      p += strlen(field)+1;
5667      n1 = strchr(p,'\r');
5668      n2 = strchr(p,',');
5669      if (n2 && n2 < n1) n1 = n2;
5670      result = zmalloc(sizeof(char)*(n1-p)+1);
5671      memcpy(result,p,(n1-p));
5672      result[n1-p] = '\0';
5673      return result;
5674  }
5675  static PORT_LONG getLongInfoField(char *info, char *field) {
5676      char *value = getInfoField(info,field);
5677      PORT_LONG l;
5678      if (!value) return PORT_LONG_MIN;
5679      l = strtol(value,NULL,10);
5680      zfree(value);
5681      return l;
5682  }
5683  void bytesToHuman(char *s, PORT_LONGLONG n) {
5684      double d;
5685      if (n < 0) {
5686          *s = '-';
5687          s++;
5688          n = -n;
5689      }
5690      if (n < 1024) {
5691          sprintf(s,"%lldB",n);
5692          return;
5693      } else if (n < (1024*1024)) {
5694          d = (double)n/(1024);
5695          sprintf(s,"%.2fK",d);
5696      } else if (n < (1024LL*1024*1024)) {
5697          d = (double)n/((double)1024*1024);
5698          sprintf(s,"%.2fM",d);
5699      } else if (n < (1024LL*1024*1024*1024)) {
5700          d = (double)n/(1024LL*1024*1024);
5701          sprintf(s,"%.2fG",d);
5702      }
5703  }
5704  static void statMode(void) {
5705      redisReply *reply;
5706      PORT_LONG aux, requests = 0;
5707      int i = 0;
5708      while(1) {
5709          char buf[64];
5710          int j;
5711          reply = reconnectingRedisCommand(context,"INFO");
5712          if (reply->type == REDIS_REPLY_ERROR) {
5713              printf("ERROR: %s\n", reply->str);
5714              exit(1);
5715          }
5716          if ((i++ % 20) == 0) {
5717              printf(
5718  "------- data ------ --------------------- load -------------------- - child -\n"
5719  "keys       mem      clients blocked requests            connections          \n");
5720          }
5721          aux = 0;
5722          for (j = 0; j < 20; j++) {
5723              PORT_LONG k;
5724              sprintf(buf,"db%d:keys",j);
5725              k = getLongInfoField(reply->str,buf);
5726              if (k == PORT_LONG_MIN) continue;
5727              aux += k;
5728          }
5729          sprintf(buf,"%Id",aux);                                      WIN_PORT_FIX &bsol;* %ld -> %Id */
5730          printf("%-11s",buf);
5731          aux = getLongInfoField(reply->str,"used_memory");
5732          bytesToHuman(buf,aux);
5733          printf("%-8s",buf);
5734          aux = getLongInfoField(reply->str,"connected_clients");
5735          sprintf(buf,"%Id",aux);                                      WIN_PORT_FIX &bsol;* %ld -> %Id */
5736          printf(" %-8s",buf);
5737          aux = getLongInfoField(reply->str,"blocked_clients");
5738          sprintf(buf,"%Id",aux);                                      WIN_PORT_FIX &bsol;* %ld -> %Id */
5739          printf("%-8s",buf);
5740          aux = getLongInfoField(reply->str,"total_commands_processed");
5741          sprintf(buf,"%Id (+%Id)",aux,requests == 0 ? 0 : aux-requests);  WIN_PORT_FIX &bsol;* %ld -> %Id */
5742          printf("%-19s",buf);
5743          requests = aux;
5744          aux = getLongInfoField(reply->str,"total_connections_received");
5745          sprintf(buf,"%Id",aux);                                       WIN_PORT_FIX &bsol;* %ld -> %Id */
5746          printf(" %-12s",buf);
5747          aux = getLongInfoField(reply->str,"bgsave_in_progress");
5748          aux |= getLongInfoField(reply->str,"aof_rewrite_in_progress") << 1;
5749          aux |= getLongInfoField(reply->str,"loading") << 2;
5750          switch(aux) {
5751          case 0: break;
5752          case 1:
5753              printf("SAVE");
5754              break;
5755          case 2:
5756              printf("AOF");
5757              break;
5758          case 3:
5759              printf("SAVE+AOF");
5760              break;
5761          case 4:
5762              printf("LOAD");
5763              break;
5764          }
5765          printf("\n");
5766          freeReplyObject(reply);
5767          usleep(config.interval);
5768      }
5769  }
5770  static void scanMode(void) {
5771      redisReply *reply;
5772      PORT_ULONGLONG cur = 0;
5773      do {
5774          if (config.pattern)
5775              reply = redisCommand(context,"SCAN %llu MATCH %s",
5776                  cur,config.pattern);
5777          else
5778              reply = redisCommand(context,"SCAN %llu",cur);
5779          if (reply == NULL) {
5780              printf("I/O error\n");
5781              exit(1);
5782          } else if (reply->type == REDIS_REPLY_ERROR) {
5783              printf("ERROR: %s\n", reply->str);
5784              exit(1);
5785          } else {
5786              unsigned int j;
5787              cur = strtoull(reply->element[0]->str,NULL,10);
5788              for (j = 0; j < reply->element[1]->elements; j++)
5789                  printf("%s\n", reply->element[1]->element[j]->str);
5790          }
5791          freeReplyObject(reply);
5792      } while(cur != 0);
5793      exit(0);
5794  }
5795  PORT_LONGLONG powerLawRand(PORT_LONGLONG min, PORT_LONGLONG max, double alpha) {
5796      double pl, r;
5797      max += 1;
5798      r = ((double)rand()) / RAND_MAX;
5799      pl = pow(
5800          ((pow((double)max,alpha+1) - pow((double)min,alpha+1))*r + pow((double)min,alpha+1)), WIN_PORT_FIX &bsol;* cast (double) */
5801          (1.0/(alpha+1)));
5802      return (max-1-(PORT_LONGLONG)pl)+min;
5803  }
5804  void LRUTestGenKey(char *buf, size_t buflen) {
5805      snprintf(buf, buflen, "lru:%lld",
5806          powerLawRand(1, config.lru_test_sample_size, 6.2));
5807  }
5808  #define LRU_CYCLE_PERIOD 1000 &bsol;* 1000 milliseconds. */
5809  #define LRU_CYCLE_PIPELINE_SIZE 250
5810  static void LRUTestMode(void) {
5811      redisReply *reply;
5812      char key[128];
5813      PORT_LONGLONG start_cycle;
5814      int j;
5815      srand((unsigned int)(time(NULL)^getpid()));                                   WIN_PORT_FIX &bsol;* cast (unsigned int) */
5816      while(1) {
5817          start_cycle = mstime();
5818          PORT_LONGLONG hits = 0, misses = 0;
5819          while(mstime() - start_cycle < 1000) {
5820              for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++) {
5821                  char val[6];
5822                  val[5] = '\0';
5823                  for (int i = 0; i < 5; i++) val[i] = 'A'+rand()%('z'-'A');
5824                  LRUTestGenKey(key,sizeof(key));
5825                  redisAppendCommand(context, "SET %s %s",key,val);
5826              }
5827              for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++)
5828                  redisGetReply(context, (void**)&reply);
5829              for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++) {
5830                  LRUTestGenKey(key,sizeof(key));
5831                  redisAppendCommand(context, "GET %s",key);
5832              }
5833              for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++) {
5834                  if (redisGetReply(context, (void**)&reply) == REDIS_OK) {
5835                      switch(reply->type) {
5836                          case REDIS_REPLY_ERROR:
5837                              printf("%s\n", reply->str);
5838                              break;
5839                          case REDIS_REPLY_NIL:
5840                              misses++;
5841                              break;
5842                          default:
5843                              hits++;
5844                              break;
5845                      }
5846                  }
5847              }
5848              if (context->err) {
5849                  fprintf(stderr,"I/O error during LRU test\n");
5850                  exit(1);
5851              }
5852          }
5853          printf(
5854              "%lld Gets/sec | Hits: %lld (%.2f%%) | Misses: %lld (%.2f%%)\n",
5855              hits+misses,
5856              hits, (double)hits/(hits+misses)*100,
5857              misses, (double)misses/(hits+misses)*100);
5858      }
5859      exit(0);
5860  }
5861  PORT_ULONG compute_something_fast(void) {
5862      unsigned char s[256], i, j, t;
5863      int count = 1000, k;
5864      PORT_ULONG output = 0;
5865      for (k = 0; k < 256; k++) s[k] = k;
5866      i = 0;
5867      j = 0;
5868      while(count--) {
5869          i++;
5870          j = j + s[i];
5871          t = s[i];
5872          s[i] = s[j];
5873          s[j] = t;
5874          output += s[(s[i]+s[j])&255];
5875      }
5876      return output;
5877  }
5878  static void intrinsicLatencyModeStop(int s) {
5879      UNUSED(s);
5880      force_cancel_loop = 1;
5881  }
5882  static void intrinsicLatencyMode(void) {
5883      PORT_LONGLONG test_end, run_time, max_latency = 0, runs = 0;
5884      run_time = ((PORT_LONGLONG)config.intrinsic_latency_duration)*1000000;
5885      test_end = ustime() + run_time;
5886      signal(SIGINT, intrinsicLatencyModeStop);
5887      while(1) {
5888          PORT_LONGLONG start, end, latency;
5889          start = ustime();
5890          compute_something_fast();
5891          end = ustime();
5892          latency = end-start;
5893          runs++;
5894          if (latency <= 0) continue;
5895          if (latency > max_latency) {
5896              max_latency = latency;
5897              printf("Max latency so far: %lld microseconds.\n", max_latency);
5898          }
5899          double avg_us = (double)run_time/runs;
5900          double avg_ns = avg_us * 1e3;
5901          if (force_cancel_loop || end > test_end) {
5902              printf("\n%lld total runs "
5903                  "(avg latency: "
5904                  "%.4f microseconds / %.2f nanoseconds per run).\n",
5905                  runs, avg_us, avg_ns);
5906              printf("Worst run took %.0fx longer than the average latency.\n",
5907                  max_latency / avg_us);
5908              exit(0);
5909          }
5910      }
5911  }
5912  int main(int argc, char **argv) {
5913      int firstarg;
5914  #ifdef _WIN32
5915      pthread_mutex_init(&used_memory_mutex, NULL);
5916  #endif
5917      config.hostip = sdsnew("127.0.0.1");
5918      config.hostport = 6379;
5919      config.hostsocket = NULL;
5920      config.repeat = 1;
5921      config.interval = 0;
5922      config.dbnum = 0;
5923      config.interactive = 0;
5924      config.shutdown = 0;
5925      config.monitor_mode = 0;
5926      config.pubsub_mode = 0;
5927      config.latency_mode = 0;
5928      config.latency_dist_mode = 0;
5929      config.latency_history = 0;
5930      config.lru_test_mode = 0;
5931      config.lru_test_sample_size = 0;
5932      config.cluster_mode = 0;
5933      config.slave_mode = 0;
5934      config.getrdb_mode = 0;
5935      config.stat_mode = 0;
5936      config.scan_mode = 0;
5937      config.intrinsic_latency_mode = 0;
5938      config.pattern = NULL;
5939      config.rdb_filename = NULL;
5940      config.pipe_mode = 0;
5941      config.pipe_timeout = REDIS_CLI_DEFAULT_PIPE_TIMEOUT;
5942      config.bigkeys = 0;
5943      config.hotkeys = 0;
5944      config.stdinarg = 0;
5945      config.auth = NULL;
5946      config.eval = NULL;
5947      config.eval_ldb = 0;
5948      config.eval_ldb_end = 0;
5949      config.eval_ldb_sync = 0;
5950      config.enable_ldb_on_eval = 0;
5951      config.last_cmd_type = -1;
5952      config.verbose = 0;
5953      config.no_auth_warning = 0;
5954      config.cluster_manager_command.name = NULL;
5955      config.cluster_manager_command.argc = 0;
5956      config.cluster_manager_command.argv = NULL;
5957      config.cluster_manager_command.flags = 0;
5958      config.cluster_manager_command.replicas = 0;
5959      config.cluster_manager_command.from = NULL;
5960      config.cluster_manager_command.to = NULL;
5961      config.cluster_manager_command.weight = NULL;
5962      config.cluster_manager_command.weight_argc = 0;
5963      config.cluster_manager_command.slots = 0;
5964      config.cluster_manager_command.timeout = CLUSTER_MANAGER_MIGRATE_TIMEOUT;
5965      config.cluster_manager_command.pipeline = CLUSTER_MANAGER_MIGRATE_PIPELINE;
5966      config.cluster_manager_command.threshold =
5967          CLUSTER_MANAGER_REBALANCE_THRESHOLD;
5968      pref.hints = 1;
5969      spectrum_palette = spectrum_palette_color;
5970      spectrum_palette_size = spectrum_palette_color_size;
5971      if (!isatty(fileno(stdout)) && (getenv("FAKETTY") == NULL))
5972          config.output = OUTPUT_RAW;
5973      else
5974          config.output = OUTPUT_STANDARD;
5975      config.mb_delim = sdsnew("\n");
5976      firstarg = parseOptions(argc,argv);
5977      argc -= firstarg;
5978      argv += firstarg;
5979      parseEnv();
5980      if (CLUSTER_MANAGER_MODE()) {
5981          clusterManagerCommandProc *proc = validateClusterManagerCommand();
5982          if (!proc) {
5983              sdsfree(config.hostip);
5984              sdsfree(config.mb_delim);
5985              exit(1);
5986          }
5987          clusterManagerMode(proc);
5988      }
5989      if (config.latency_mode) {
5990          if (cliConnect(0) == REDIS_ERR) exit(1);
5991          latencyMode();
5992      }
5993      if (config.latency_dist_mode) {
5994          if (cliConnect(0) == REDIS_ERR) exit(1);
5995          latencyDistMode();
5996      }
5997      if (config.slave_mode) {
5998          if (cliConnect(0) == REDIS_ERR) exit(1);
5999          slaveMode();
6000      }
6001      if (config.getrdb_mode) {
6002          if (cliConnect(0) == REDIS_ERR) exit(1);
6003          getRDB();
6004      }
6005      if (config.pipe_mode) {
6006          if (cliConnect(0) == REDIS_ERR) exit(1);
6007          pipeMode();
6008      }
6009      if (config.bigkeys) {
6010          if (cliConnect(0) == REDIS_ERR) exit(1);
6011          findBigKeys(0, 0);
6012      }
6013      if (config.memkeys) {
6014          if (cliConnect(0) == REDIS_ERR) exit(1);
6015          findBigKeys(1, config.memkeys_samples);
6016      }
6017      if (config.hotkeys) {
6018          if (cliConnect(0) == REDIS_ERR) exit(1);
6019          findHotKeys();
6020      }
6021      if (config.stat_mode) {
6022          if (cliConnect(0) == REDIS_ERR) exit(1);
6023          if (config.interval == 0) config.interval = 1000000;
6024          statMode();
6025      }
6026      if (config.scan_mode) {
6027          if (cliConnect(0) == REDIS_ERR) exit(1);
6028          scanMode();
6029      }
6030      if (config.lru_test_mode) {
6031          if (cliConnect(0) == REDIS_ERR) exit(1);
6032          LRUTestMode();
6033      }
6034      if (config.intrinsic_latency_mode) intrinsicLatencyMode();
6035      if (argc == 0 && !config.eval) {
6036          signal(SIGPIPE, SIG_IGN);
6037          cliConnect(0);
6038          repl();
6039      }
6040      if (cliConnect(0) != REDIS_OK) exit(1);
6041      if (config.eval) {
6042          return evalMode(argc,argv);
6043      } else {
6044          return noninteractive(argc,convertToSds(argc,argv));
6045      }
6046  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-redis-cli.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-redis-cli.c</div>
                </div>
                <div class="column column_space"><pre><code>1785      listIter li;
1786      listNode *ln;
1787      if (cluster_manager.nodes != NULL) {
1788          listRewind(cluster_manager.nodes,&li);
1789          while ((ln = listNext(&li)) != NULL) {
</pre></code></div>
                <div class="column column_space"><pre><code>2840      listIter li;
2841      listNode *ln;
2842      if (cluster_manager.nodes != NULL) {
2843          listRewind(cluster_manager.nodes, &li);
2844          while ((ln = listNext(&li)) != NULL)
2845              freeClusterManagerNode((clusterManagerNode *) ln->value);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    