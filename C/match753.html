<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-text-gtk-viewport.c &amp; inf-text-session.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-text-gtk-viewport.c &amp; inf-text-session.c
      </h3>
<h1 align="center">
        13.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-text-gtk-viewport.c (20.408163%)<th>inf-text-session.c (9.815951%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(402-461)<td><a href="#" name="0">(694-759)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(802-825)<td><a href="#" name="1">(873-896)</a><td align="center"><font color="#df0000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(303-323)<td><a href="#" name="2">(425-446)</a><td align="center"><font color="#cf0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(44-71)<td><a href="#" name="3">(42-60)</a><td align="center"><font color="#cf0000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(670-725)<td><a href="#" name="4">(1211-1242)</a><td align="center"><font color="#bf0000">12</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(326-344)<td><a href="#" name="5">(448-468)</a><td align="center"><font color="#bf0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-gtk-viewport.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinftextgtk/inf-text-gtk-viewport.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
<a name="3"></a>
#include &lt;gtk/gtk.h&gt;
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>typedef struct _InfTextGtkViewportUser InfTextGtkViewportUser;
struct _InfTextGtkViewportUser {
  InfTextGtkViewport* viewport;
  InfTextUser* user;
  GdkRectangle rectangle;
};
typedef struct _InfTextGtkViewportPrivate InfTextGtkViewportPrivate;
struct _InfTextGtkViewportPrivate {
  GtkScrolledWindow* scroll;
  InfUserTable* user_table;
  InfTextUser* active_user;
  GSList* users;
  gboolean show_user_markers;
};
enum {
  PROP_0,
  PROP_SCROLLED_WINDOW,
  PROP_USER_TABLE,
  PROP_ACTIVE_USER,
  PROP_SHOW_USER_MARKERS
};</b></font>
#define INF_TEXT_GTK_VIEWPORT_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_GTK_TYPE_VIEWPORT, InfTextGtkViewportPrivate))
G_DEFINE_TYPE_WITH_CODE(InfTextGtkViewport, inf_text_gtk_viewport, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfTextGtkViewport))
static InfTextGtkViewportUser*
inf_text_gtk_viewport_find_user(InfTextGtkViewport* viewport,
                                InfTextUser* user)
{
  InfTextGtkViewportPrivate* priv;
  GSList* item;
  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
  for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
    if( ((InfTextGtkViewportUser*)item-&gt;data)-&gt;user == user)
      return (InfTextGtkViewportUser*)item-&gt;data;
  return NULL;
}
static void
inf_text_gtk_viewport_user_compute_user_area(InfTextGtkViewportUser* user)
{
  InfTextGtkViewportPrivate* priv;
  GtkWidget* textview;
  GtkWidget* scrollbar;
  GtkTextIter iter;
  GdkRectangle rect;
  gint y;
  gint end_y;
  gint scroll_height;
  gint slider_size;
  gint stepper_size;
  gint stepper_spacing;
  gint border;
  GdkRectangle allocation;
  gint scroll_ox;
  gint scroll_oy;
  gint dy;
  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(user-&gt;viewport);
  textview = gtk_bin_get_child(GTK_BIN(priv-&gt;scroll));
  scrollbar = gtk_scrolled_window_get_vscrollbar(priv-&gt;scroll);
  if(GTK_IS_TEXT_VIEW(textview) &amp;&amp; scrollbar != NULL &amp;&amp;
     gtk_widget_get_realized(textview))
  {
    gtk_text_buffer_get_iter_at_offset(
      gtk_text_view_get_buffer(GTK_TEXT_VIEW(textview)),
      &amp;iter,
      inf_text_user_get_caret_position(user-&gt;user)
    );
    gtk_text_view_get_iter_location(GTK_TEXT_VIEW(textview), &amp;iter, &amp;rect);
    y = rect.y;
    gtk_text_buffer_get_end_iter(
      gtk_text_view_get_buffer(GTK_TEXT_VIEW(textview)),
      &amp;iter
    );
    gtk_text_view_get_iter_location(GTK_TEXT_VIEW(textview), &amp;iter, &amp;rect);
    end_y = rect.y;
    g_assert(end_y &gt; 0 || y == 0);
    gtk_widget_style_get(
      scrollbar,
      "slider-width", &amp;slider_size,
      "stepper-size", &amp;stepper_size,
      "stepper-spacing", &amp;stepper_spacing,
      "trough-border", &amp;border,
      NULL
    );
    gtk_widget_get_allocation(scrollbar, &amp;allocation);
    scroll_ox = border;
    scroll_oy = border + stepper_size + stepper_spacing;
    scroll_height = allocation.height - 2*scroll_oy;
    if(end_y &gt; 0)
      y = y * scroll_height / end_y;
    user-&gt;rectangle.x = scroll_ox + allocation.x;
    user-&gt;rectangle.y = scroll_oy + allocation.y + y - slider_size/3;
    user-&gt;rectangle.width = slider_size;
    user-&gt;rectangle.height = slider_size*2/3;
    if(user-&gt;rectangle.y &lt; scroll_oy + allocation.y)
    {
      dy = scroll_oy + allocation.y - user-&gt;rectangle.y;
      user-&gt;rectangle.y += dy;
      user-&gt;rectangle.height -= dy;
    }
    if(user-&gt;rectangle.y + user-&gt;rectangle.height &gt;
       scroll_oy + allocation.y + scroll_height)
    {
      user-&gt;rectangle.height =
        scroll_oy + allocation.y + scroll_height - user-&gt;rectangle.y;
    }
  }
  else
  {
    user-&gt;rectangle.x = user-&gt;rectangle.y = 0;
    user-&gt;rectangle.width = user-&gt;rectangle.height = 0;
  }
}
static void
inf_text_gtk_viewport_user_invalidate_user_area(InfTextGtkViewportUser* user)
{
  InfTextGtkViewportPrivate* priv;
  GtkWidget* scrollbar;
  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(user-&gt;viewport);
  if(priv-&gt;show_user_markers &amp;&amp;
     user-&gt;rectangle.width &gt; 0 &amp;&amp; user-&gt;rectangle.height &gt; 0)
  {
    scrollbar = gtk_scrolled_window_get_vscrollbar(priv-&gt;scroll);
    if(scrollbar != NULL)
    {
      gtk_widget_queue_draw_area(
        scrollbar,
        user-&gt;rectangle.x,
        user-&gt;rectangle.y,
        user-&gt;rectangle.width,
        user-&gt;rectangle.height
      );
    }
  }
}
static gboolean
inf_text_gtk_viewport_scrollbar_draw_cb(GtkWidget* scrollbar,
                                        cairo_t* cr,
                                        gpointer user_data)
{
  InfTextGtkViewport* viewport;
  InfTextGtkViewportPrivate* priv;
  InfTextGtkViewportUser* viewport_user;
  GdkRectangle* rectangle;
  GtkStyleContext* style;
  GdkRGBA bg;
  double h,s,v;
  double r,g,b;
  GSList* item;
  double line_width;
  GdkRectangle clip_area;
  viewport = INF_TEXT_GTK_VIEWPORT(user_data);
  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
  if(!gtk_cairo_should_draw_window(cr, gtk_widget_get_window(scrollbar)))
    return FALSE;
  if(priv-&gt;show_user_markers)
  {
    style = gtk_widget_get_style_context(GTK_WIDGET(scrollbar));
    gtk_style_context_save(style);
    gtk_style_context_add_class(style, GTK_STYLE_CLASS_VIEW);
    gtk_style_context_get_background_color(style, GTK_STATE_FLAG_NORMAL, &amp;bg);
    gtk_style_context_restore(style);
    gtk_rgb_to_hsv(bg.red, bg.green, bg.blue, &amp;h, &amp;s, &amp;v);
    s = MIN(MAX(s, 0.5), 0.8);
    v = MAX(v, 0.5);
    gtk_cairo_transform_to_window(
      cr,
      GTK_WIDGET(scrollbar),
      gtk_widget_get_window(scrollbar)
    );
    gdk_cairo_get_clip_rectangle(cr, &amp;clip_area);
    line_width = cairo_get_line_width(cr);
    for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
    {
      viewport_user = (InfTextGtkViewportUser*)item-&gt;data;
      rectangle = &amp;viewport_user-&gt;rectangle;
      if(gdk_rectangle_intersect(&amp;clip_area, rectangle, NULL))
      {
        h = inf_text_user_get_hue(viewport_user-&gt;user);
        cairo_rectangle(
          cr,
          rectangle-&gt;x + line_width/2,
          rectangle-&gt;y + line_width/2,
          rectangle-&gt;width - line_width,
          rectangle-&gt;height - line_width
        );
        gtk_hsv_to_rgb(h, s, v/2.0, &amp;r, &amp;g, &amp;b);
        cairo_set_source_rgba(cr, r, g, b, 0.6);
        cairo_stroke_preserve(cr);
        gtk_hsv_to_rgb(h, s, v, &amp;r, &amp;g, &amp;b);
        cairo_set_source_rgba(cr, r, g, b, 0.6);
        cairo_fill(cr);
      }
    }
  }
  return FALSE;
}
static void
inf_text_gtk_viewport_scrollbar_size_allocate_cb(GtkWidget* scrollbar,
                                                 GtkAllocation* allocation,
                                                 gpointer user_data)
{
  InfTextGtkViewport* viewport;
  InfTextGtkViewportPrivate* priv;
  GSList* item;
<a name="2"></a>  InfTextGtkViewportUser* viewport_user;
  viewport = INF_TEXT_GTK_VIEWPORT(user_data);
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
  for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
  {
    viewport_user = (InfTextGtkViewportUser*)item-&gt;data;
    inf_text_gtk_viewport_user_invalidate_user_area(viewport_user);
    inf_text_gtk_viewport_user_compute_user_area(viewport_user);
    inf_text_gtk_viewport_user_invalidate_user_area(viewport_user);
  }
}
static void
inf_text_gtk_viewport_adjustment_changed_cb(GtkAdjustment* adjustment,
                                            gpointer user_data)
{
  InfTextGtkViewport* viewport;
  InfTextGtkViewportPrivate* priv;
  GSList* item;
  InfTextGtkViewportUser* viewport_user;
<a name="5"></a>  viewport = INF_TEXT_GTK_VIEWPORT(user_data);</b></font>
  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
  {
    viewport_user = (InfTextGtkViewportUser*)item-&gt;data;
    inf_text_gtk_viewport_user_invalidate_user_area(viewport_user);
    inf_text_gtk_viewport_user_compute_user_area(viewport_user);
    inf_text_gtk_viewport_user_invalidate_user_area(viewport_user);
  }
}
static void
inf_text_gtk_viewport_scrollbar_style_updated_cb(GtkWidget* scrollbar,
                                                 gpointer user_data)
{
  InfTextGtkViewport* viewport;
  InfTextGtkViewportPrivate* priv;
  GSList* item;
  InfTextGtkViewportUser* viewport_user;
  viewport = INF_TEXT_GTK_VIEWPORT(user_data);</b></font>
  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
  for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
  {
    viewport_user = (InfTextGtkViewportUser*)item-&gt;data;
    inf_text_gtk_viewport_user_invalidate_user_area(viewport_user);
    inf_text_gtk_viewport_user_compute_user_area(viewport_user);
    inf_text_gtk_viewport_user_invalidate_user_area(viewport_user);
  }
}
static void
inf_text_gtk_viewport_user_selection_changed_cb(InfTextUser* user,
                                                guint position,
                                                gint length,
                                                gboolean by_request,
                                                gpointer user_data)
{
  InfTextGtkViewportUser* viewport_user;
  InfTextGtkViewportPrivate* priv;
  viewport_user = (InfTextGtkViewportUser*)user_data;
  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport_user-&gt;viewport);
  inf_text_gtk_viewport_user_invalidate_user_area(viewport_user);
  inf_text_gtk_viewport_user_compute_user_area(viewport_user);
  inf_text_gtk_viewport_user_invalidate_user_area(viewport_user);
}
static void
inf_text_gtk_viewport_user_notify_hue_cb(GObject* object,
                                         GParamSpec* pspec,
                                         gpointer user_data)
{
  InfTextGtkViewportUser* viewport_user;
  InfTextGtkViewportPrivate* priv;
  viewport_user = (InfTextGtkViewportUser*)user_data;
  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport_user-&gt;viewport);
  inf_text_gtk_viewport_user_invalidate_user_area(viewport_user);
}
static void
inf_text_gtk_viewport_add_user(InfTextGtkViewport* viewport,
                              InfTextUser* user)
{
  InfTextGtkViewportPrivate* priv;
  InfTextGtkViewportUser* viewport_user;
<a name="0"></a>  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
  viewport_user = g_slice_new(InfTextGtkViewportUser);
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  viewport_user-&gt;viewport = viewport;
  viewport_user-&gt;user = INF_TEXT_USER(user);
  priv-&gt;users = g_slist_prepend(priv-&gt;users, viewport_user);
  inf_text_gtk_viewport_user_compute_user_area(viewport_user);
  g_signal_connect_after(
    user,
    "selection-changed",
    G_CALLBACK(inf_text_gtk_viewport_user_selection_changed_cb),
    viewport_user
  );
  g_signal_connect(
    user,
    "notify::hue",
    G_CALLBACK(inf_text_gtk_viewport_user_notify_hue_cb),
    viewport_user
  );
  inf_text_gtk_viewport_user_invalidate_user_area(viewport_user);
}
static void
inf_text_gtk_viewport_remove_user(InfTextGtkViewportUser* viewport_user)
{
  InfTextGtkViewportPrivate* priv;
  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport_user-&gt;viewport);
  inf_text_gtk_viewport_user_invalidate_user_area(viewport_user);
  inf_signal_handlers_disconnect_by_func(
    viewport_user-&gt;user,
    G_CALLBACK(inf_text_gtk_viewport_user_selection_changed_cb),
    viewport_user
  );
  inf_signal_handlers_disconnect_by_func(
    viewport_user-&gt;user,
    G_CALLBACK(inf_text_gtk_viewport_user_notify_hue_cb),
    viewport_user
  );
  priv-&gt;users = g_slist_remove(priv-&gt;users, viewport_user);
  g_slice_free(InfTextGtkViewportUser, viewport_user);
}
static void
inf_text_gtk_viewport_user_notify_status_cb(GObject* object,
                                            GParamSpec* pspec,
                                            gpointer user_data)
{
  InfTextGtkViewport* viewport;
  InfTextGtkViewportPrivate* priv;
  InfTextUser* user;
  InfTextGtkViewportUser* viewport_user;
  viewport = INF_TEXT_GTK_VIEWPORT(user_data);
  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
  user = INF_TEXT_USER(object);</b></font>
  g_assert(user != priv-&gt;active_user);
  viewport_user = inf_text_gtk_viewport_find_user(viewport, user);
  if(inf_user_get_status(INF_USER(user)) == INF_USER_ACTIVE)
  {
    if(!viewport_user)
      inf_text_gtk_viewport_add_user(viewport, user);
  }
  else
  {
    if(viewport_user)
      inf_text_gtk_viewport_remove_user(viewport_user);
  }
}
static void
inf_text_gtk_viewport_user_removed(InfTextGtkViewport* viewport,
                                   InfTextUser* user)
{
  InfTextGtkViewportPrivate* priv;
  InfTextGtkViewportUser* viewport_user;
  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
  if(user == priv-&gt;active_user)
  {
    priv-&gt;active_user = NULL;
    g_object_notify(G_OBJECT(viewport), "active-user");
  }
  else
  {
    inf_signal_handlers_disconnect_by_func(
      user,
      G_CALLBACK(inf_text_gtk_viewport_user_notify_status_cb),
      viewport
    );
    if(inf_user_get_status(INF_USER(user)) == INF_USER_ACTIVE)
    {
      viewport_user = inf_text_gtk_viewport_find_user(viewport, user);
      g_assert(viewport_user != NULL);
      inf_text_gtk_viewport_remove_user(viewport_user);
    }
  }
}
static void
inf_text_gtk_viewport_user_added(InfTextGtkViewport* viewport,
                                 InfTextUser* user)
{
  InfTextGtkViewportPrivate* priv;
  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
  g_assert(user != priv-&gt;active_user);
  g_signal_connect(
    user,
    "notify::status",
    G_CALLBACK(inf_text_gtk_viewport_user_notify_status_cb),
    viewport
  );
  if(inf_user_get_status(INF_USER(user)) == INF_USER_ACTIVE)
    inf_text_gtk_viewport_add_user(viewport, user);
}
static void
inf_text_gtk_viewport_add_user_cb(InfUserTable* user_table,
                                  InfUser* user,
                                  gpointer user_data)
{
  InfTextGtkViewport* viewport = INF_TEXT_GTK_VIEWPORT(user_data);
  g_assert(INF_TEXT_IS_USER(user));
  inf_text_gtk_viewport_user_added(viewport, INF_TEXT_USER(user));
}
static void
inf_text_gtk_viewport_remove_user_cb(InfUserTable* user_table,
                                     InfUser* user,
                                     gpointer user_data)
{
  InfTextGtkViewport* viewport = INF_TEXT_GTK_VIEWPORT(user_data);
  g_assert(INF_TEXT_IS_USER(user));
  inf_text_gtk_viewport_user_removed(viewport, INF_TEXT_USER(user));
}
static void
inf_text_gtk_viewport_set_user_table_foreach_new_user_func(InfUser* user,
                                                           gpointer user_data)
{
  InfTextGtkViewport* viewport = INF_TEXT_GTK_VIEWPORT(user_data);
  g_assert(INF_TEXT_IS_USER(user));
  inf_text_gtk_viewport_user_added(viewport, INF_TEXT_USER(user));
}
static void
inf_text_gtk_viewport_set_user_table_foreach_old_user_func(InfUser* user,
                                                           gpointer user_data)
{
  InfTextGtkViewport* viewport = INF_TEXT_GTK_VIEWPORT(user_data);
  g_assert(INF_TEXT_IS_USER(user));
  inf_text_gtk_viewport_user_removed(viewport, INF_TEXT_USER(user));
}
static void
inf_text_gtk_viewport_set_scrolled_window(InfTextGtkViewport* viewport,
                                          GtkScrolledWindow* scroll)
{
  InfTextGtkViewportPrivate* priv;
  GtkWidget* scrollbar;
  GtkAdjustment* adjustment;
  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
  if(priv-&gt;scroll != NULL)
  {
    scrollbar = gtk_scrolled_window_get_vscrollbar(priv-&gt;scroll);
    if(scrollbar != NULL)
    {
      adjustment = gtk_range_get_adjustment(GTK_RANGE(scrollbar));
      g_assert(adjustment != NULL);
      inf_signal_handlers_disconnect_by_func(
        G_OBJECT(adjustment),
        G_CALLBACK(inf_text_gtk_viewport_adjustment_changed_cb),
        viewport
      );
      inf_signal_handlers_disconnect_by_func(
        G_OBJECT(scrollbar),
        G_CALLBACK(inf_text_gtk_viewport_scrollbar_size_allocate_cb),
        viewport
      );
      inf_signal_handlers_disconnect_by_func(
        G_OBJECT(scrollbar),
        G_CALLBACK(inf_text_gtk_viewport_scrollbar_style_updated_cb),
        viewport
      );
      inf_signal_handlers_disconnect_by_func(
        G_OBJECT(scrollbar),
        G_CALLBACK(inf_text_gtk_viewport_scrollbar_draw_cb),
        viewport
      );
    }
    g_object_unref(priv-&gt;scroll);
  }
  priv-&gt;scroll = scroll;
  if(scroll != NULL)
  {
    scrollbar = gtk_scrolled_window_get_vscrollbar(priv-&gt;scroll);
    g_assert(scrollbar != NULL);
    adjustment = gtk_range_get_adjustment(GTK_RANGE(scrollbar));
    g_assert(adjustment != NULL);
    g_object_ref(scroll);
    g_signal_connect_after(
      G_OBJECT(adjustment),
      "changed",
      G_CALLBACK(inf_text_gtk_viewport_adjustment_changed_cb),
      viewport
    );
    g_signal_connect_after(
      G_OBJECT(scrollbar),
      "size-allocate",
      G_CALLBACK(inf_text_gtk_viewport_scrollbar_size_allocate_cb),
      viewport
    );
    g_signal_connect_after(
      G_OBJECT(scrollbar),
      "style-updated",
      G_CALLBACK(inf_text_gtk_viewport_scrollbar_style_updated_cb),
      viewport
    );
    g_signal_connect_after(
      G_OBJECT(scrollbar),
      "draw",
      G_CALLBACK(inf_text_gtk_viewport_scrollbar_draw_cb),
      viewport
    );
  }
  g_object_notify(G_OBJECT(viewport), "scrolled-window");
}
static void
inf_text_gtk_viewport_set_user_table(InfTextGtkViewport* viewport,
<a name="4"></a>                                     InfUserTable* user_table)
{
  InfTextGtkViewportPrivate* priv;
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
  if(priv-&gt;user_table != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;user_table),
      G_CALLBACK(inf_text_gtk_viewport_add_user_cb),
      viewport
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;user_table),
      G_CALLBACK(inf_text_gtk_viewport_remove_user_cb),
      viewport
    );
    inf_user_table_foreach_user(
      priv-&gt;user_table,
      inf_text_gtk_viewport_set_user_table_foreach_old_user_func,
      viewport
    );
    g_object_unref(priv-&gt;user_table);
  }
  priv-&gt;user_table = user_table;
  if(user_table != NULL)
  {
    g_object_ref(user_table);
    g_signal_connect(
      G_OBJECT(user_table),
      "add-user",
      G_CALLBACK(inf_text_gtk_viewport_add_user_cb),
      viewport
    );
    g_signal_connect(
      G_OBJECT(user_table),
      "remove-user",
      G_CALLBACK(inf_text_gtk_viewport_remove_user_cb),
      viewport
    );
    inf_user_table_foreach_user(
      user_table,
      inf_text_gtk_viewport_set_user_table_foreach_new_user_func,
      viewport
    );
  }
  g_object_notify(G_OBJECT(viewport), "user-table");
}
static void</b></font>
inf_text_gtk_viewport_init(InfTextGtkViewport* viewport)
{
  InfTextGtkViewportPrivate* priv;
  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
  priv-&gt;scroll = NULL;
  priv-&gt;user_table = NULL;
  priv-&gt;active_user = NULL;
  priv-&gt;users = NULL;
  priv-&gt;show_user_markers = TRUE;
}
static void
inf_text_gtk_viewport_dispose(GObject* object)
{
  InfTextGtkViewport* viewport;
  InfTextGtkViewportPrivate* priv;
  viewport = INF_TEXT_GTK_VIEWPORT(object);
  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
  inf_text_gtk_viewport_set_user_table(viewport, NULL);
  inf_text_gtk_viewport_set_scrolled_window(viewport, NULL);
  g_assert(priv-&gt;active_user == NULL);
  g_assert(priv-&gt;users == NULL);
  G_OBJECT_CLASS(inf_text_gtk_viewport_parent_class)-&gt;dispose(object);
}
static void
inf_text_gtk_viewport_set_property(GObject* object,
                                   guint prop_id,
                                   const GValue* value,
                                   GParamSpec* pspec)
{
  InfTextGtkViewport* viewport;
  InfTextGtkViewportPrivate* priv;
  viewport = INF_TEXT_GTK_VIEWPORT(object);
  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
  switch(prop_id)
  {
  case PROP_SCROLLED_WINDOW:
    g_assert(priv-&gt;scroll == NULL); 
    inf_text_gtk_viewport_set_scrolled_window(
      viewport,
      GTK_SCROLLED_WINDOW(g_value_get_object(value))
    );
    break;
  case PROP_USER_TABLE:
    g_assert(priv-&gt;user_table == NULL); 
    inf_text_gtk_viewport_set_user_table(
      viewport,
      INF_USER_TABLE(g_value_get_object(value))
    );
    break;
  case PROP_ACTIVE_USER:
    inf_text_gtk_viewport_set_active_user(
      viewport,
      INF_TEXT_USER(g_value_get_object(value))
    );
    break;
  case PROP_SHOW_USER_MARKERS:
    inf_text_gtk_viewport_set_show_user_markers(
      viewport,
<a name="1"></a>      g_value_get_boolean(value)
    );
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(value, prop_id, pspec);
    break;
  }
}
static void
inf_text_gtk_viewport_get_property(GObject* object,
                                   guint prop_id,
                                   GValue* value,
                                   GParamSpec* pspec)
{
  InfTextGtkViewport* viewport;
  InfTextGtkViewportPrivate* priv;
  viewport = INF_TEXT_GTK_VIEWPORT(object);
  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
  switch(prop_id)
  {
  case PROP_SCROLLED_WINDOW:
    g_value_set_object(value, G_OBJECT(priv-&gt;scroll));
    break;</b></font>
  case PROP_USER_TABLE:
    g_value_set_object(value, G_OBJECT(priv-&gt;user_table));
    break;
  case PROP_ACTIVE_USER:
    g_value_set_object(value, G_OBJECT(priv-&gt;active_user));
    break;
  case PROP_SHOW_USER_MARKERS:
    g_value_set_boolean(value, priv-&gt;show_user_markers);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_text_gtk_viewport_class_init(InfTextGtkViewportClass* viewport_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(viewport_class);
  object_class-&gt;dispose = inf_text_gtk_viewport_dispose;
  object_class-&gt;set_property = inf_text_gtk_viewport_set_property;
  object_class-&gt;get_property = inf_text_gtk_viewport_get_property;
  g_object_class_install_property(
    object_class,
    PROP_SCROLLED_WINDOW,
    g_param_spec_object(
      "scrolled-window",
      "Scrolled Window",
      "The underlying GtkScrolledWindow",
      GTK_TYPE_SCROLLED_WINDOW,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_USER_TABLE,
    g_param_spec_object(
      "user-table",
      "User table",
      "The user table containing the users of the session shown in the "
      "viewport",
      INF_TYPE_USER_TABLE,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_ACTIVE_USER,
    g_param_spec_object(
      "active-user",
      "Active user",
      "The user for which to show the viewport",
      INF_TEXT_TYPE_USER,
      G_PARAM_READWRITE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SHOW_USER_MARKERS,
    g_param_spec_boolean(
      "show-user-markers",
      "Show user markers",
      "Whether to indicate the position of non-local user's cursors in the "
      "scrollbar",
      TRUE,
      G_PARAM_READWRITE
    )
  );
}
InfTextGtkViewport*
inf_text_gtk_viewport_new(GtkScrolledWindow* scroll,
                          InfUserTable* user_table)
{
  GObject* object;
  g_return_val_if_fail(GTK_IS_SCROLLED_WINDOW(scroll), NULL);
  g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);
  object = g_object_new(
    INF_TEXT_GTK_TYPE_VIEWPORT,
    "scrolled-window", scroll,
    "user-table", user_table,
    NULL
  );
  return INF_TEXT_GTK_VIEWPORT(object);
}
GtkScrolledWindow*
inf_text_gtk_viewport_get_scrolled_window(InfTextGtkViewport* viewport)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_VIEWPORT(viewport), NULL);
  return INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport)-&gt;scroll;
}
InfUserTable*
inf_text_gtk_viewport_get_user_table(InfTextGtkViewport* viewport)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_VIEWPORT(viewport), NULL);
  return INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport)-&gt;user_table;
}
void
inf_text_gtk_viewport_set_active_user(InfTextGtkViewport* viewport,
                                      InfTextUser* user)
{
  InfTextGtkViewportPrivate* priv;
  InfTextUser* active_user;
  g_return_if_fail(INF_TEXT_GTK_IS_VIEWPORT(viewport));
  g_return_if_fail(user == NULL || INF_TEXT_IS_USER(user));
  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
  g_return_if_fail(
    user == NULL ||
    inf_user_table_lookup_user_by_id(
      priv-&gt;user_table,
      inf_user_get_id(INF_USER(user))
    ) == INF_USER(user)
  );
  if(priv-&gt;active_user != NULL)
  {
    active_user = priv-&gt;active_user;
    priv-&gt;active_user = NULL;
    inf_text_gtk_viewport_user_added(viewport, active_user);
  }
  if(user != NULL)
  {
    inf_text_gtk_viewport_user_removed(viewport, user);
  }
  priv-&gt;active_user = user;
  g_object_notify(G_OBJECT(viewport), "active-user");
}
InfTextUser*
inf_text_gtk_viewport_get_active_user(InfTextGtkViewport* viewport)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_VIEWPORT(viewport), NULL);
  return INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport)-&gt;active_user;
}
void
inf_text_gtk_viewport_set_show_user_markers(InfTextGtkViewport* viewport,
                                            gboolean show)
{
  InfTextGtkViewportPrivate* priv;
  g_return_if_fail(INF_TEXT_GTK_IS_VIEWPORT(viewport));
  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
  if(priv-&gt;show_user_markers != show)
  {
    gtk_widget_queue_draw(gtk_scrolled_window_get_vscrollbar(priv-&gt;scroll));
    priv-&gt;show_user_markers = show;
    g_object_notify(G_OBJECT(viewport), "show-user-markers");
  }
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-session.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinftext/inf-text-session.h&gt;
#include &lt;libinftext/inf-text-default-insert-operation.h&gt;
#include &lt;libinftext/inf-text-default-delete-operation.h&gt;
#include &lt;libinftext/inf-text-remote-delete-operation.h&gt;
#include &lt;libinftext/inf-text-insert-operation.h&gt;
#include &lt;libinftext/inf-text-delete-operation.h&gt;
#include &lt;libinftext/inf-text-move-operation.h&gt;
#include &lt;libinftext/inf-text-chunk.h&gt;
#include &lt;libinftext/inf-text-user.h&gt;
#include &lt;libinfinity/adopted/inf-adopted-no-operation.h&gt;
#include &lt;libinfinity/common/inf-xml-util.h&gt;
#include &lt;libinfinity/common/inf-error.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
#include &lt;libxml/tree.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>typedef struct _InfTextSessionLocalUser InfTextSessionLocalUser;
struct _InfTextSessionLocalUser {
  InfTextSession* session;
  InfTextUser* user;
  GTimeVal last_caret_update;
  InfIoTimeout* caret_timeout;
};
typedef struct _InfTextSessionPrivate InfTextSessionPrivate;
struct _InfTextSessionPrivate {
  guint caret_update_interval;
  GSList* local_users;
};
enum {
  PROP_0,
  PROP_CARET_UPDATE_INTERVAL
};</b></font>
typedef struct _InfTextSessionInsertForeachData
  InfTextSessionInsertForeachData;
typedef struct _InfTextSessionEraseForeachData
  InfTextSessionEraseForeachData;
struct _InfTextSessionInsertForeachData {
  guint position;
  InfTextChunk* chunk;
  InfUser* user;
};
struct _InfTextSessionEraseForeachData {
  guint position;
  guint length;
  InfUser* user;
};
#define INF_TEXT_SESSION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_TYPE_SESSION, InfTextSessionPrivate))
static GQuark inf_text_session_error_quark;
G_DEFINE_TYPE_WITH_CODE(InfTextSession, inf_text_session, INF_ADOPTED_TYPE_SESSION,
  G_ADD_PRIVATE(InfTextSession))
static guint
inf_text_session_timeval_diff(GTimeVal* first,
                              GTimeVal* second)
{
  g_assert(first-&gt;tv_sec &gt; second-&gt;tv_sec ||
           (first-&gt;tv_sec == second-&gt;tv_sec &amp;&amp;
            first-&gt;tv_usec &gt;= second-&gt;tv_usec));
  return (first-&gt;tv_sec - second-&gt;tv_sec) * 1000 +
         (first-&gt;tv_usec+500)/1000 - (second-&gt;tv_usec+500)/1000;
}
static void
inf_text_session_segment_to_xml(GIConv* cd,
                                xmlNodePtr xml,
                                gconstpointer text,
                                gsize* bytes,                                 guint author)
{
  gchar utf8_text[1024];
  gsize result;
  gsize bytes_left;
  gchar* inbuf;
  gchar* outbuf;
  bytes_left = 1024;
  inbuf = *(gchar**)(gpointer)&amp;text;   outbuf = utf8_text;
  result = g_iconv(
    *cd,
    &amp;inbuf,
    bytes,
    &amp;outbuf,
    &amp;bytes_left
  );
  g_assert(result == 0 || errno == E2BIG);
  inf_xml_util_add_child_text(xml, utf8_text, 1024 - bytes_left);
  inf_xml_util_set_attribute_uint(xml, "author", author);
}
static gpointer
inf_text_session_segment_from_xml(GIConv* cd,
                                  xmlNodePtr xml,
                                  guint* length,
                                  gsize* bytes,
                                  guint* author,
                                  GError** error)
{
  gsize bytes_read;
  gchar* utf8_text;
  gpointer text;
  if(!inf_xml_util_get_attribute_uint_required(xml, "author", author, error))
    return NULL;
  utf8_text = inf_xml_util_get_child_text(xml, &amp;bytes_read, length, error);
  if(!utf8_text)
    return NULL;
  text = g_convert_with_iconv(
    utf8_text,
    bytes_read,
    *cd,
    NULL,
    bytes,
    error
  );
  g_free(utf8_text);
  return text;
}
static InfTextSessionLocalUser*
inf_text_session_find_local_user(InfTextSession* session,
                                 InfTextUser* user)
{
  InfTextSessionPrivate* priv;
  GSList* item;
  InfTextSessionLocalUser* local;
  priv = INF_TEXT_SESSION_PRIVATE(session);
  for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
  {
    local = (InfTextSessionLocalUser*)item-&gt;data;
    if(local-&gt;user == user)
      return local;
  }
  return NULL;
}
static void
inf_text_session_broadcast_caret_selection(InfTextSession* session,
                                           InfTextSessionLocalUser* local)
{
  InfAdoptedOperation* operation;
  InfAdoptedAlgorithm* algorithm;
  InfAdoptedRequest* request;
  guint buf_len;
  guint position;
  int sel;
  guint end;
  algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
  position = inf_text_user_get_caret_position(local-&gt;user);
  sel = inf_text_user_get_selection_length(local-&gt;user);
  end = position + sel;
  buf_len = inf_text_buffer_get_length(
    INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)))
  );
  if(position &gt; buf_len)
    position = buf_len;
  if(end &gt; buf_len)
    end = buf_len;
  if(end &gt;= position)
    sel = (int)(end - position);
  else
    sel = -(int)(position - end);
  operation = INF_ADOPTED_OPERATION(
    inf_text_move_operation_new(position, sel)
  );
  request = inf_adopted_algorithm_generate_request(
    algorithm,
    INF_ADOPTED_REQUEST_DO,
    INF_ADOPTED_USER(local-&gt;user),
    operation
  );
  inf_adopted_algorithm_execute_request(algorithm, request, FALSE, NULL);
  g_object_unref(operation);
  inf_adopted_session_broadcast_request(
    INF_ADOPTED_SESSION(session),
    request
  );
  g_object_unref(request);
  g_get_current_time(&amp;local-&gt;last_caret_update);
  if(local-&gt;caret_timeout != NULL)
  {
    inf_io_remove_timeout(
      inf_adopted_session_get_io(INF_ADOPTED_SESSION(session)),
      local-&gt;caret_timeout
    );
    local-&gt;caret_timeout = NULL;
  }
}
static void
inf_text_session_caret_update_timeout_func(gpointer user_data)
{
  InfTextSessionLocalUser* local;
  local = (InfTextSessionLocalUser*)user_data;
  local-&gt;caret_timeout = NULL;
  inf_text_session_broadcast_caret_selection(local-&gt;session, local);
}
static void
inf_text_session_selection_changed_cb(InfTextUser* user,
                                      guint position,
                                      gint sel,
                                      gboolean by_request,
                                      gpointer user_data)
{
  InfTextSession* session;
  InfTextSessionPrivate* priv;
  InfAdoptedAlgorithm* algorithm;
  InfAdoptedRequest* execute_request;
  InfTextSessionLocalUser* local;
  GTimeVal current;
  guint diff;
  session = INF_TEXT_SESSION(user_data);
  priv = INF_TEXT_SESSION_PRIVATE(session);
  algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
  execute_request = inf_adopted_algorithm_get_execute_request(algorithm);
  g_assert( (execute_request != NULL &amp;&amp; by_request == FALSE) ||
            (execute_request == NULL &amp;&amp; by_request == TRUE));
  if(execute_request == NULL)
  {
    local = inf_text_session_find_local_user(session, user);
    g_assert(local != NULL);
    g_get_current_time(&amp;current);
    diff = inf_text_session_timeval_diff(&amp;current, &amp;local-&gt;last_caret_update);
    if(diff &lt; priv-&gt;caret_update_interval)
    {
      if(local-&gt;caret_timeout == NULL)
      {
        local-&gt;caret_timeout = inf_io_add_timeout(
          inf_adopted_session_get_io(INF_ADOPTED_SESSION(local-&gt;session)),
          priv-&gt;caret_update_interval - diff,
          inf_text_session_caret_update_timeout_func,
          local,
          NULL
        );
      }
    }
    else
    {
      inf_text_session_broadcast_caret_selection(session, local);
    }
  }
}
static void
inf_text_session_add_local_user(InfTextSession* session,
                                InfTextUser* user)
{
  InfTextSessionPrivate* priv;
  InfTextSessionLocalUser* local;
  priv = INF_TEXT_SESSION_PRIVATE(session);
  local = g_slice_new(InfTextSessionLocalUser);
  local-&gt;session = session;
  local-&gt;user = user;
  g_get_current_time(&amp;local-&gt;last_caret_update);
  local-&gt;caret_timeout = NULL;
  priv-&gt;local_users = g_slist_prepend(priv-&gt;local_users, local);
  g_signal_connect_after(
    G_OBJECT(user),
    "selection-changed",
    G_CALLBACK(inf_text_session_selection_changed_cb),
    session
  );
}
static void
inf_text_session_remove_local_user(InfTextSession* session,
                                   InfTextSessionLocalUser* local)
{
  InfTextSessionPrivate* priv;
  priv = INF_TEXT_SESSION_PRIVATE(session);
  if(local-&gt;caret_timeout != NULL)
  {
    inf_io_remove_timeout(
      inf_adopted_session_get_io(INF_ADOPTED_SESSION(session)),
      local-&gt;caret_timeout
    );
  }
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(local-&gt;user),
    G_CALLBACK(inf_text_session_selection_changed_cb),
    session
  );
  g_slice_free(InfTextSessionLocalUser, local);
  priv-&gt;local_users = g_slist_remove(priv-&gt;local_users, local);
}
static void
inf_text_session_local_user_added_cb(InfUserTable* user_table,
                                     InfUser* user,
                                     gpointer user_data)
{
  g_assert(INF_TEXT_IS_USER(user));
  inf_text_session_add_local_user(
    INF_TEXT_SESSION(user_data),
    INF_TEXT_USER(user)
  );
}
static void
inf_text_session_local_user_removed_cb(InfUserTable* user_table,
                                       InfUser* user,
                                       gpointer user_data)
{
  InfTextSession* session;
  InfTextSessionLocalUser* local;
  g_assert(INF_TEXT_IS_USER(user));
  session = INF_TEXT_SESSION(user_data);
  local = inf_text_session_find_local_user(session, INF_TEXT_USER(user));
  g_assert(local != NULL);
  inf_text_session_remove_local_user(session, local);
}
static void
inf_text_session_block_local_users_selection_changed(InfTextSession* session)
{
  InfTextSessionPrivate* priv;
<a name="2"></a>  GSList* item;
  InfTextSessionLocalUser* local;
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  priv = INF_TEXT_SESSION_PRIVATE(session);
  for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
  {
    local = (InfTextSessionLocalUser*)item-&gt;data;
    inf_signal_handlers_block_by_func(
      G_OBJECT(local-&gt;user),
      G_CALLBACK(inf_text_session_selection_changed_cb),
      session
    );
  }
}
static void
inf_text_session_unblock_local_users_selection_changed(InfTextSession* sess)
{
  InfTextSessionPrivate* priv;
  GSList* item;
  InfTextSessionLocalUser* local;
<a name="5"></a>
  priv = INF_TEXT_SESSION_PRIVATE(sess);</b></font>
<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
  {
    local = (InfTextSessionLocalUser*)item-&gt;data;
    inf_signal_handlers_unblock_by_func(
      G_OBJECT(local-&gt;user),
      G_CALLBACK(inf_text_session_selection_changed_cb),
      sess
    );
  }
}
static void
inf_text_session_buffer_text_inserted_cb_foreach_func(InfUser* user,
                                                      gpointer user_data)
{
  InfTextSessionInsertForeachData* data;
  guint position;
  gint length;
  data = (InfTextSessionInsertForeachData*)user_data;</b></font>
  if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
  {
    position = inf_text_user_get_caret_position(INF_TEXT_USER(user));
    length = inf_text_user_get_selection_length(INF_TEXT_USER(user));
    inf_text_move_operation_transform_insert(
      data-&gt;position,
      inf_text_chunk_get_length(data-&gt;chunk),
      &amp;position,
      &amp;length,
      user == data-&gt;user ? FALSE : TRUE
    );
    inf_text_user_set_selection(
      INF_TEXT_USER(user),
      position,
      length,
      user == data-&gt;user ? TRUE : FALSE
    );
  }
}
static void
inf_text_session_buffer_text_erased_cb_foreach_func(InfUser* user,
                                                    gpointer user_data)
{
  InfTextSessionEraseForeachData* data;
  guint position;
  gint length;
  data = (InfTextSessionEraseForeachData*)user_data;
  if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
  {
    position = inf_text_user_get_caret_position(INF_TEXT_USER(user));
    length = inf_text_user_get_selection_length(INF_TEXT_USER(user));
    inf_text_move_operation_transform_delete(
      data-&gt;position,
      data-&gt;length,
      &amp;position,
      &amp;length
    );
    inf_text_user_set_selection(
      INF_TEXT_USER(user),
      position,
      length,
      user == data-&gt;user ? TRUE : FALSE
    );
  }
}
static void
inf_text_session_buffer_text_inserted_cb(InfTextBuffer* buffer,
                                         guint pos,
                                         InfTextChunk* chunk,
                                         InfUser* user,
                                         gpointer user_data)
{
  InfTextSession* session;
  InfTextSessionPrivate* priv;
  InfUserTable* user_table;
  InfAdoptedAlgorithm* algorithm;
  InfAdoptedRequest* execute_request;
  InfAdoptedOperation* operation;
  InfAdoptedRequest* request;
  InfTextSessionInsertForeachData data;
  g_assert(INF_TEXT_IS_USER(user));
  session = INF_TEXT_SESSION(user_data);
  priv = INF_TEXT_SESSION_PRIVATE(session);
  user_table = inf_session_get_user_table(INF_SESSION(session));
  algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
  execute_request = inf_adopted_algorithm_get_execute_request(algorithm);
  if(execute_request == NULL)
  {
    operation = INF_ADOPTED_OPERATION(
      inf_text_default_insert_operation_new(pos, chunk)
    );
    request = inf_adopted_algorithm_generate_request(
      algorithm,
      INF_ADOPTED_REQUEST_DO,
      INF_ADOPTED_USER(user),
      operation
    );
    inf_adopted_algorithm_execute_request(algorithm, request, FALSE, NULL);
    inf_adopted_session_broadcast_request(
      INF_ADOPTED_SESSION(session),
      request
    );
    g_object_unref(request);
    g_object_unref(operation);
  }
  data.position = pos;
  data.chunk = chunk;
  data.user = user;
  inf_text_session_block_local_users_selection_changed(session);
  inf_user_table_foreach_user(
    user_table,
    inf_text_session_buffer_text_inserted_cb_foreach_func,
    &amp;data
  );
#if 0
  if(user != NULL)
  {
    inf_text_user_set_selection(
      INF_TEXT_USER(user),
      pos + inf_text_chunk_get_length(chunk),
      0,
      TRUE
    );
  }
#endif
  inf_text_session_unblock_local_users_selection_changed(session);
}
static void
inf_text_session_buffer_text_erased_cb(InfTextBuffer* buffer,
                                       guint pos,
                                       InfTextChunk* chunk,
                                       InfUser* user,
                                       gpointer user_data)
{
  InfTextSession* session;
  InfTextSessionPrivate* priv;
  InfUserTable* user_table;
  InfAdoptedAlgorithm* algorithm;
  InfAdoptedRequest* execute_request;
  InfAdoptedOperation* operation;
  InfAdoptedRequest* request;
  InfTextSessionEraseForeachData data;
  g_assert(INF_TEXT_IS_USER(user));
  session = INF_TEXT_SESSION(user_data);
  priv = INF_TEXT_SESSION_PRIVATE(session);
  user_table = inf_session_get_user_table(INF_SESSION(session));
  algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
  execute_request = inf_adopted_algorithm_get_execute_request(algorithm);
  if(execute_request == NULL)
  {
    operation = INF_ADOPTED_OPERATION(
      inf_text_default_delete_operation_new(pos, chunk)
    );
    request = inf_adopted_algorithm_generate_request(
      algorithm,
      INF_ADOPTED_REQUEST_DO,
      INF_ADOPTED_USER(user),
      operation
    );
    inf_adopted_algorithm_execute_request(algorithm, request, FALSE, NULL);
    inf_adopted_session_broadcast_request(
      INF_ADOPTED_SESSION(session),
      request
    );
    g_object_unref(request);
    g_object_unref(operation);
  }
  data.position = pos;
  data.length = inf_text_chunk_get_length(chunk);
  data.user = user;
  inf_text_session_block_local_users_selection_changed(session);
  inf_user_table_foreach_user(
    user_table,
    inf_text_session_buffer_text_erased_cb_foreach_func,
    &amp;data
  );
#if 0
  if(user != NULL)
    inf_text_user_set_selection(INF_TEXT_USER(user), pos, 0, TRUE);
#endif
  inf_text_session_unblock_local_users_selection_changed(session);
}
static void
inf_text_session_init_text_handlers_user_foreach_func(InfUser* user,
                                                      gpointer user_data)
{
  g_assert(INF_TEXT_IS_USER(user));
  inf_text_session_add_local_user(
    INF_TEXT_SESSION(user_data),
    INF_TEXT_USER(user)
  );
}
static void
inf_text_session_init_text_handlers(InfTextSession* session)
{
  InfTextBuffer* buffer;
<a name="0"></a>  InfAdoptedAlgorithm* algorithm;
  InfUserTable* user_table;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
  algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
  user_table = inf_session_get_user_table(INF_SESSION(session));
  g_signal_connect(
    G_OBJECT(buffer),
    "text-inserted",
    G_CALLBACK(inf_text_session_buffer_text_inserted_cb),
    session
  );
  g_signal_connect(
    G_OBJECT(buffer),
    "text-erased",
    G_CALLBACK(inf_text_session_buffer_text_erased_cb),
    session
  );
  g_signal_connect(
    G_OBJECT(user_table),
    "add-local-user",
    G_CALLBACK(inf_text_session_local_user_added_cb),
    session
  );
  g_signal_connect(
    G_OBJECT(user_table),
    "remove-local-user",
    G_CALLBACK(inf_text_session_local_user_removed_cb),
    session
  );
  inf_user_table_foreach_local_user(
    user_table,
    inf_text_session_init_text_handlers_user_foreach_func,
    session
  );
}
static void
inf_text_session_init(InfTextSession* session)
{
  InfTextSessionPrivate* priv;
  priv = INF_TEXT_SESSION_PRIVATE(session);
  priv-&gt;caret_update_interval = 500;
}
static void
inf_text_session_constructed(GObject* object)
{
  InfTextSession* session;
  InfTextSessionPrivate* priv;
  InfTextBuffer* buffer;
  InfSessionStatus status;
  G_OBJECT_CLASS(inf_text_session_parent_class)-&gt;constructed(object);
  session = INF_TEXT_SESSION(object);
  priv = INF_TEXT_SESSION_PRIVATE(session);
  buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));</b></font>
  g_object_get(G_OBJECT(session), "status", &amp;status, NULL);
  g_assert(
    status == INF_SESSION_RUNNING ||
    inf_text_buffer_get_length(buffer) == 0
  );
  if(status == INF_SESSION_RUNNING)
    inf_text_session_init_text_handlers(session);
}
static void
inf_text_session_dispose(GObject* object)
{
  InfTextSession* session;
  InfTextSessionPrivate* priv;
  InfTextBuffer* buffer;
  InfUserTable* user_table;
  InfAdoptedAlgorithm* algorithm;
  session = INF_TEXT_SESSION(object);
  priv = INF_TEXT_SESSION_PRIVATE(session);
  buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
  user_table = inf_session_get_user_table(INF_SESSION(session));
  algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
  while(priv-&gt;local_users != NULL)
  {
    inf_text_session_remove_local_user(
      session,
      (InfTextSessionLocalUser*)priv-&gt;local_users-&gt;data
    );
  }
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(buffer),
    G_CALLBACK(inf_text_session_buffer_text_inserted_cb),
    session
  );
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(buffer),
    G_CALLBACK(inf_text_session_buffer_text_erased_cb),
    session
  );
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(user_table),
    G_CALLBACK(inf_text_session_local_user_added_cb),
    session
  );
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(user_table),
    G_CALLBACK(inf_text_session_local_user_removed_cb),
    session
  );
  G_OBJECT_CLASS(inf_text_session_parent_class)-&gt;dispose(object);
}
static void
inf_text_session_finalize(GObject* object)
{
  InfTextSession* session;
  InfTextSessionPrivate* priv;
  session = INF_TEXT_SESSION(object);
  priv = INF_TEXT_SESSION_PRIVATE(session);
  G_OBJECT_CLASS(inf_text_session_parent_class)-&gt;finalize(object);
}
static void
inf_text_session_set_property(GObject* object,
                              guint prop_id,
                              const GValue* value,
                              GParamSpec* pspec)
{
  InfTextSession* session;
  InfTextSessionPrivate* priv;
  session = INF_TEXT_SESSION(object);
  priv = INF_TEXT_SESSION_PRIVATE(session);
  switch(prop_id)
<a name="1"></a>  {
  case PROP_CARET_UPDATE_INTERVAL:
    priv-&gt;caret_update_interval = g_value_get_uint(value);
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_text_session_get_property(GObject* object,
                              guint prop_id,
                              GValue* value,
                              GParamSpec* pspec)
{
  InfTextSession* session;
  InfTextSessionPrivate* priv;
  session = INF_TEXT_SESSION(object);
  priv = INF_TEXT_SESSION_PRIVATE(session);
  switch(prop_id)
  {
  case PROP_CARET_UPDATE_INTERVAL:
    g_value_set_uint(value, priv-&gt;caret_update_interval);
    break;</b></font>
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static InfCommunicationScope
inf_text_session_handle_user_color_change(InfTextSession* session,
                                          InfXmlConnection* connection,
                                          xmlNodePtr xml,
                                          GError** error)
{
  InfUserTable* user_table;
  guint user_id;
  InfUser* user;
  gdouble hue;
  user_table = inf_session_get_user_table(INF_SESSION(session));
  if(!inf_xml_util_get_attribute_uint_required(xml, "id", &amp;user_id, error))
    return INF_COMMUNICATION_SCOPE_PTP;
  if(!inf_xml_util_get_attribute_double_required(xml, "hue", &amp;hue, error))
    return INF_COMMUNICATION_SCOPE_PTP;
  user = inf_user_table_lookup_user_by_id(user_table, user_id);
  if(user == NULL)
  {
    g_set_error(
      error,
      inf_user_error_quark(),
      INF_USER_ERROR_NO_SUCH_USER,
      _("No such user with ID '%u'"),
      user_id
    );
    return INF_COMMUNICATION_SCOPE_PTP;
  }
  if(inf_user_get_status(user) == INF_USER_UNAVAILABLE ||
     inf_user_get_connection(user) != connection)
  {
    g_set_error_literal(
      error,
      inf_user_error_quark(),
      INF_USER_ERROR_NOT_JOINED,
      _("User did not join from this connection")
    );
    return INF_COMMUNICATION_SCOPE_PTP;
  }
  g_assert(INF_TEXT_IS_USER(user));
  if(hue &lt; 0.0 || hue &gt; 1.0)
  {
    g_set_error(
      error,
      inf_text_session_error_quark,
      INF_TEXT_SESSION_ERROR_INVALID_HUE,
      _("Invalid hue value: '%g'"),
      hue
    );
    return INF_COMMUNICATION_SCOPE_PTP;
  }
  g_object_set(G_OBJECT(user), "hue", hue, NULL);
  return INF_COMMUNICATION_SCOPE_GROUP;
}
static void
inf_text_session_to_xml_sync(InfSession* session,
                             xmlNodePtr parent)
{
  InfTextBuffer* buffer;
  InfTextBufferIter* iter;
  xmlNodePtr xml;
  gboolean result;
  gchar* text;
  gsize total_bytes;
  gsize bytes_left;
  GIConv cd;
  INF_SESSION_CLASS(inf_text_session_parent_class)-&gt;to_xml_sync(
    session,
    parent
  );
  buffer = INF_TEXT_BUFFER(inf_session_get_buffer(session));
  cd = g_iconv_open("UTF-8", inf_text_buffer_get_encoding(buffer));
  iter = inf_text_buffer_create_begin_iter(buffer);
  if(iter != NULL)
  {
    result = TRUE;
    while(result == TRUE)
    {
      text = inf_text_buffer_iter_get_text(buffer, iter);
      total_bytes = inf_text_buffer_iter_get_bytes(buffer, iter);
      bytes_left = total_bytes;
      while(bytes_left &gt; 0)
      {
        xml = xmlNewChild(parent, NULL, (const xmlChar*)"sync-segment", NULL);
        inf_text_session_segment_to_xml(
          &amp;cd,
          xml,
          text + total_bytes - bytes_left,
          &amp;bytes_left,
          inf_text_buffer_iter_get_author(buffer, iter)
        );
      }
      g_free(text);
      result = inf_text_buffer_iter_next(buffer, iter);
    }
    inf_text_buffer_destroy_iter(buffer, iter);
  }
  g_iconv_close(cd);
}
static gboolean
inf_text_session_process_xml_sync(InfSession* session,
                                  InfXmlConnection* connection,
                                  const xmlNodePtr xml,
                                  GError** error)
{
  InfTextBuffer* buffer;
  GIConv cd;
  gpointer text;
  gsize bytes;
  guint length;
  guint author;
  InfUser* user;
  if(strcmp((const char*)xml-&gt;name, "sync-segment") == 0)
  {
    buffer = INF_TEXT_BUFFER(inf_session_get_buffer(session));
    cd = g_iconv_open(inf_text_buffer_get_encoding(buffer), "UTF-8");
    text = inf_text_session_segment_from_xml(
      &amp;cd,
      xml,
      &amp;length,
      &amp;bytes,
      &amp;author,
      error
    );
    g_iconv_close(cd);
    if(text == NULL) return FALSE;
    if(author != 0)
    {
      user = inf_user_table_lookup_user_by_id(
        inf_session_get_user_table(session),
        author
      );
      if(user == NULL)
      {
        g_free(text);
        g_set_error(
          error,
          inf_user_error_quark(),
          INF_USER_ERROR_NO_SUCH_USER,
          _("No such user with ID '%u'"),
          author
        );
        return FALSE;
      }
    }
    else
    {
      user = NULL;
    }
    inf_text_buffer_insert_text(
      buffer,
      inf_text_buffer_get_length(buffer),
      text,
      bytes,
      length,
      user
    );
    g_free(text);
    return TRUE;
  }
  else
  {
    return INF_SESSION_CLASS(inf_text_session_parent_class)-&gt;process_xml_sync(
      session,
      connection,
      xml,
      error
    );
  }
}
static InfCommunicationScope
inf_text_session_process_xml_run(InfSession* session,
                                 InfXmlConnection* connection,
                                 const xmlNodePtr xml,
                                 GError** error)
{
  if(strcmp((const char*)xml-&gt;name, "user-color-change") == 0)
  {
    return inf_text_session_handle_user_color_change(
      INF_TEXT_SESSION(session),
      connection,
      xml,
      error
    );
  }
  else
  {
    return INF_SESSION_CLASS(inf_text_session_parent_class)-&gt;process_xml_run(
      session,
      connection,
      xml,
      error
    );
  }
}
static GArray*
inf_text_session_get_xml_user_props(InfSession* session,
                                    InfXmlConnection* connection,
                                    const xmlNodePtr xml)
{
  InfSessionClass* parent_class;
  GArray* array;
  GParameter* parameter;
  guint caret;
  gint selection;
  gdouble hue;
  parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
  array = parent_class-&gt;get_xml_user_props(session, connection, xml);
  if(inf_xml_util_get_attribute_uint(xml, "caret", &amp;caret, NULL))
  {
    parameter = inf_session_get_user_property(array, "caret-position");
    g_value_init(&amp;parameter-&gt;value, G_TYPE_UINT);
    g_value_set_uint(&amp;parameter-&gt;value, caret);
  }
  parameter = inf_session_get_user_property(array, "selection-length");
  g_value_init(&amp;parameter-&gt;value, G_TYPE_INT);
  if(inf_xml_util_get_attribute_int(xml, "selection", &amp;selection, NULL))
    g_value_set_int(&amp;parameter-&gt;value, selection);
  else
    g_value_set_int(&amp;parameter-&gt;value, 0);
  parameter = inf_session_get_user_property(array, "hue");
  g_value_init(&amp;parameter-&gt;value, G_TYPE_DOUBLE);
  if(inf_xml_util_get_attribute_double(xml, "hue", &amp;hue, NULL))
    g_value_set_double(&amp;parameter-&gt;value, hue);
  else
    g_value_set_double(&amp;parameter-&gt;value, g_random_double());
  return array;
}
static void
inf_text_session_set_xml_user_props(InfSession* session,
                                    const GParameter* params,
                                    guint n_params,
                                    xmlNodePtr xml)
{
  InfSessionClass* parent_class;
  const GParameter* param;
  parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
  parent_class-&gt;set_xml_user_props(session, params, n_params, xml);
  param = inf_session_lookup_user_property(
    params,
    n_params,
    "caret-position"
  );
  if(param != NULL)
  {
    inf_xml_util_set_attribute_uint(
      xml,
      "caret",
      g_value_get_uint(&amp;param-&gt;value)
<a name="4"></a>    );
  }
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  param = inf_session_lookup_user_property(
    params,
    n_params,
    "selection-length"
  );
  if(param != NULL)
  {
    inf_xml_util_set_attribute_int(
      xml,
      "selection",
      g_value_get_int(&amp;param-&gt;value)
    );
  }
  param = inf_session_lookup_user_property(
    params,
    n_params,
    "hue"
  );
  if(param != NULL)
  {
    inf_xml_util_set_attribute_double(
      xml,
      "hue",
      g_value_get_double(&amp;param-&gt;value)
    );
  }
}
static gboolean</b></font>
inf_text_session_validate_user_props(InfSession* session,
                                     const GParameter* params,
                                     guint n_params,
                                     InfUser* exclude,
                                     GError** error)
{
  InfSessionClass* parent_class;
  const GParameter* caret;
  gboolean result;
  parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
  result = parent_class-&gt;validate_user_props(
    session,
    params,
    n_params,
    exclude,
    error
  );
  if(result == FALSE) return FALSE;
  caret = inf_session_lookup_user_property(
    params,
    n_params,
    "caret-position"
  );
  if(caret == NULL)
  {
    g_set_error_literal(
      error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_NO_SUCH_ATTRIBUTE,
      _("\"caret\" attribute in user message is missing")
    );
    return FALSE;
  }
  return result;
}
static InfUser*
inf_text_session_user_new(InfSession* session,
                          GParameter* params,
                          guint n_params)
{
  GObject* object;
  object = g_object_newv(INF_TEXT_TYPE_USER, n_params, params);
  return INF_USER(object);
}
static void
inf_text_session_synchronization_complete(InfSession* session,
                                          InfXmlConnection* connection)
{
  InfSessionClass* parent_class;
  InfSessionStatus status;
  parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
  status = inf_session_get_status(session);
  parent_class-&gt;synchronization_complete(session, connection);
  if(status == INF_SESSION_SYNCHRONIZING)
    inf_text_session_init_text_handlers(INF_TEXT_SESSION(session));
}
static void
inf_text_session_request_to_xml(InfAdoptedSession* session,
                                xmlNodePtr xml,
                                InfAdoptedRequest* request,
                                InfAdoptedStateVector* diff_vec,
                                gboolean for_sync)
{
  InfTextChunk* chunk;
  InfTextChunkIter iter;
  gboolean result;
  xmlNodePtr op_xml;
  gchar* utf8_text;
  gsize bytes_read;
  gsize bytes_written;
  GIConv cd;
  xmlNodePtr child;
  const gchar* text;
  gsize total_bytes;
  gsize bytes_left;
  InfAdoptedOperation* operation;
  switch(inf_adopted_request_get_request_type(request))
  {
  case INF_ADOPTED_REQUEST_DO:
    operation = inf_adopted_request_get_operation(request);
    if(INF_TEXT_IS_INSERT_OPERATION(operation))
    {
      op_xml = xmlNewNode(NULL, (const xmlChar*)"insert-caret");
      inf_xml_util_set_attribute_uint(
        op_xml,
        "pos",
        inf_text_insert_operation_get_position(
          INF_TEXT_INSERT_OPERATION(operation)
        )
      );
      g_assert(INF_TEXT_IS_DEFAULT_INSERT_OPERATION(operation));
      chunk = inf_text_default_insert_operation_get_chunk(
        INF_TEXT_DEFAULT_INSERT_OPERATION(operation)
      );
      result = inf_text_chunk_iter_init_begin(chunk, &amp;iter);
      g_assert(result == TRUE);
      utf8_text = g_convert(
        inf_text_chunk_iter_get_text(&amp;iter),
        inf_text_chunk_iter_get_bytes(&amp;iter),
        "UTF-8",
        inf_text_chunk_get_encoding(chunk),
        &amp;bytes_read,
        &amp;bytes_written,
        NULL
      );
      g_assert(utf8_text != NULL);
      g_assert(bytes_read == inf_text_chunk_iter_get_bytes(&amp;iter));
      inf_xml_util_add_child_text(op_xml, utf8_text, bytes_written);
      g_free(utf8_text);
      g_assert(inf_text_chunk_iter_next(&amp;iter) == FALSE);
    }
    else if(INF_TEXT_IS_DELETE_OPERATION(operation))
    {
      op_xml = xmlNewNode(NULL, (const xmlChar*)"delete-caret");
      inf_xml_util_set_attribute_uint(
        op_xml,
        "pos",
        inf_text_delete_operation_get_position(
          INF_TEXT_DELETE_OPERATION(operation)
        )
      );
      if(for_sync == TRUE)
      {
        g_assert(INF_TEXT_IS_DEFAULT_DELETE_OPERATION(operation));
        chunk = inf_text_default_delete_operation_get_chunk(
          INF_TEXT_DEFAULT_DELETE_OPERATION(operation)
        );
        cd = g_iconv_open("UTF-8", inf_text_chunk_get_encoding(chunk));
        result = inf_text_chunk_iter_init_begin(chunk, &amp;iter);
        while(result == TRUE)
        {
          text = inf_text_chunk_iter_get_text(&amp;iter);
          total_bytes = inf_text_chunk_iter_get_bytes(&amp;iter);
          bytes_left = total_bytes;
          child = xmlNewChild(op_xml, NULL, (const xmlChar*)"segment", NULL);
          while(bytes_left &gt; 0)
          {
            inf_text_session_segment_to_xml(
              &amp;cd,
              child,
              text + total_bytes - bytes_left,
              &amp;bytes_left,
              inf_text_chunk_iter_get_author(&amp;iter)
            );
          }
          result = inf_text_chunk_iter_next(&amp;iter);
        }
        g_iconv_close(cd);
      }
      else
      {
        inf_xml_util_set_attribute_uint(
          op_xml,
          "len",
          inf_text_delete_operation_get_length(
            INF_TEXT_DELETE_OPERATION(operation)
          )
        );
      }
    }
    else if(for_sync == FALSE &amp;&amp; INF_TEXT_IS_MOVE_OPERATION(operation))
    {
      op_xml = xmlNewNode(NULL, (const xmlChar*)"move");
      inf_xml_util_set_attribute_uint(
        op_xml,
        "caret",
        inf_text_move_operation_get_position(
          INF_TEXT_MOVE_OPERATION(operation)
        )
      );
      inf_xml_util_set_attribute_int(
        op_xml,
        "selection",
        inf_text_move_operation_get_length(INF_TEXT_MOVE_OPERATION(operation))
      );
    }
    else if(for_sync == FALSE &amp;&amp; INF_ADOPTED_IS_NO_OPERATION(operation))
    {
      op_xml = xmlNewNode(NULL, (const xmlChar*)"no-op");
    }
    else
    {
      g_assert_not_reached();
    }
    break;
  case INF_ADOPTED_REQUEST_UNDO:
    op_xml = xmlNewNode(NULL, (const xmlChar*)"undo-caret");
    break;
  case INF_ADOPTED_REQUEST_REDO:
    op_xml = xmlNewNode(NULL, (const xmlChar*)"redo-caret");
    break;
  default:
    g_assert_not_reached();
    break;
  }
  g_assert(op_xml != NULL);
  inf_adopted_session_write_request_info(
    session,
    request,
    diff_vec,
    xml,
    op_xml
  );
}
static InfAdoptedRequest*
inf_text_session_xml_to_request(InfAdoptedSession* session,
                                xmlNodePtr xml,
                                InfAdoptedStateVector* diff_vec,
                                gboolean for_sync,
                                GError** error)
{
  InfTextBuffer* buffer;
  InfAdoptedUser* user;
  guint user_id;
  InfAdoptedStateVector* vector;
  xmlNodePtr op_xml;
  InfAdoptedOperation* operation;
  InfAdoptedRequestType type;
  InfAdoptedRequest* request;
  guint pos;
  gchar* text;
  gsize bytes;
  InfTextChunk* chunk;
  gchar* utf8_text;
  gsize in_bytes;
  guint length;
  xmlNodePtr child;
  GIConv cd;
  guint author;
  gboolean cmp;
  gint selection;
  buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
  cmp = inf_adopted_session_read_request_info(
    session,
    xml,
    diff_vec,
    &amp;user,
    &amp;vector,
    &amp;op_xml,
    error
  );
  if(cmp == FALSE) return FALSE;
  user_id = (user == NULL) ? 0 : inf_user_get_id(INF_USER(user));
  if(strcmp((const char*)op_xml-&gt;name, "insert") == 0 ||
     strcmp((const char*)op_xml-&gt;name, "insert-caret") == 0)
  {
    type = INF_ADOPTED_REQUEST_DO;
    if(!inf_xml_util_get_attribute_uint_required(op_xml, "pos", &amp;pos, error))
      goto fail;
    utf8_text = inf_xml_util_get_child_text(op_xml, &amp;in_bytes, &amp;length, error);
    if(!utf8_text)
      goto fail;
    text = g_convert(
      utf8_text,
      in_bytes,
      inf_text_buffer_get_encoding(buffer),
      "UTF-8",
      NULL,
      &amp;bytes,
      error
    );
    g_free(utf8_text);
    if(text == NULL) goto fail;
    chunk = inf_text_chunk_new(inf_text_buffer_get_encoding(buffer));
    inf_text_chunk_insert_text(chunk, 0, text, bytes, length, user_id);
    g_free(text);
    operation = INF_ADOPTED_OPERATION(
      inf_text_default_insert_operation_new(pos, chunk)
    );
    inf_text_chunk_free(chunk);
  }
  else if(strcmp((const char*)op_xml-&gt;name, "delete") == 0 ||
          strcmp((const char*)op_xml-&gt;name, "delete-caret") == 0)
  {
    type = INF_ADOPTED_REQUEST_DO;
    if(!inf_xml_util_get_attribute_uint_required(op_xml, "pos", &amp;pos, error))
      goto fail;
    if(for_sync == TRUE)
    {
      chunk = inf_text_chunk_new(inf_text_buffer_get_encoding(buffer));
      cd = g_iconv_open(inf_text_buffer_get_encoding(buffer), "UTF-8");
      g_assert(cd != (GIConv)(-1));
      for(child = op_xml-&gt;children; child != NULL; child = child-&gt;next)
      {
        if(strcmp((const char*)child-&gt;name, "segment") == 0)
        {
          text = inf_text_session_segment_from_xml(
            &amp;cd,
            child,
            &amp;length,
            &amp;bytes,
            &amp;author,
            error
          );
          if(text == NULL)
          {
            inf_text_chunk_free(chunk);
            g_iconv_close(cd);
            goto fail;
          }
          else
          {
            inf_text_chunk_insert_text(
              chunk,
              inf_text_chunk_get_length(chunk),
              text,
              bytes,
              length,
              author
            );
            g_free(text);
          }
        }
        else
        {
        }
      }
      g_iconv_close(cd);
      operation = INF_ADOPTED_OPERATION(
        inf_text_default_delete_operation_new(pos, chunk)
      );
      inf_text_chunk_free(chunk);
    }
    else
    {
      cmp = inf_xml_util_get_attribute_uint_required(
        op_xml,
        "len",
        &amp;length,
        error
      );
      if(cmp == FALSE) goto fail;
      operation = INF_ADOPTED_OPERATION(
        inf_text_remote_delete_operation_new(pos, length)
      );
    }
  }
  else if(strcmp((const char*)op_xml-&gt;name, "move") == 0)
  {
    type = INF_ADOPTED_REQUEST_DO;
    cmp = inf_xml_util_get_attribute_uint_required(
      op_xml,
      "caret",
      &amp;pos,
      error
    );
    if(cmp == FALSE) goto fail;
    cmp = inf_xml_util_get_attribute_int_required(
      op_xml,
      "selection",
      &amp;selection,
      error
    );
    if(cmp == FALSE) goto fail;
    operation = INF_ADOPTED_OPERATION(
      inf_text_move_operation_new(pos, selection)
    );
  }
  else if(strcmp((const char*)op_xml-&gt;name, "no-op") == 0)
  {
    type = INF_ADOPTED_REQUEST_DO;
    operation = INF_ADOPTED_OPERATION(inf_adopted_no_operation_new());
  }
  else if(strcmp((const char*)op_xml-&gt;name, "undo") == 0 ||
          strcmp((const char*)op_xml-&gt;name, "undo-caret") == 0)
  {
    type = INF_ADOPTED_REQUEST_UNDO;
  }
  else if(strcmp((const char*)op_xml-&gt;name, "redo") == 0 ||
          strcmp((const char*)op_xml-&gt;name, "redo-caret") == 0)
  {
    type = INF_ADOPTED_REQUEST_REDO;
  }
  else
  {
    goto fail;
  }
  switch(type)
  {
  case INF_ADOPTED_REQUEST_DO:
    g_assert(operation != NULL);
    request = inf_adopted_request_new_do(
      vector,
      user_id,
      operation,
      g_get_real_time()
    );
    g_object_unref(operation);
    break;
  case INF_ADOPTED_REQUEST_UNDO:
    request = inf_adopted_request_new_undo(
      vector,
      user_id,
      g_get_real_time()
    );
    break;
  case INF_ADOPTED_REQUEST_REDO:
    request = inf_adopted_request_new_redo(
      vector,
      user_id,
      g_get_real_time()
    );
    break;
  default:
    g_assert_not_reached();
    break;
  }
  inf_adopted_state_vector_free(vector);
  return request;
fail:
  inf_adopted_state_vector_free(vector);
  return NULL;
}
static void
inf_text_session_class_init(InfTextSessionClass* text_session_class)
{
  GObjectClass* object_class;
  InfSessionClass* session_class;
  InfAdoptedSessionClass* adopted_session_class;
  object_class = G_OBJECT_CLASS(text_session_class);
  session_class = INF_SESSION_CLASS(text_session_class);
  adopted_session_class = INF_ADOPTED_SESSION_CLASS(text_session_class);
  object_class-&gt;constructed = inf_text_session_constructed;
  object_class-&gt;dispose = inf_text_session_dispose;
  object_class-&gt;finalize = inf_text_session_finalize;
  object_class-&gt;set_property = inf_text_session_set_property;
  object_class-&gt;get_property = inf_text_session_get_property;
  session_class-&gt;to_xml_sync = inf_text_session_to_xml_sync;
  session_class-&gt;process_xml_sync = inf_text_session_process_xml_sync;
  session_class-&gt;process_xml_run = inf_text_session_process_xml_run;
  session_class-&gt;get_xml_user_props = inf_text_session_get_xml_user_props;
  session_class-&gt;set_xml_user_props = inf_text_session_set_xml_user_props;
  session_class-&gt;validate_user_props = inf_text_session_validate_user_props;
  session_class-&gt;user_new = inf_text_session_user_new;
  session_class-&gt;synchronization_complete =
    inf_text_session_synchronization_complete;
  adopted_session_class-&gt;xml_to_request = inf_text_session_xml_to_request;
  adopted_session_class-&gt;request_to_xml = inf_text_session_request_to_xml;
  inf_text_session_error_quark = g_quark_from_static_string(
    "INF_TEXT_SESSION_ERROR"
  );
  g_object_class_install_property(
    object_class,
    PROP_CARET_UPDATE_INTERVAL,
    g_param_spec_uint(
      "caret-update-interval",
      "Caret update interval",
      "Minimum number of milliseconds between caret update broadcasts",
      0,
      G_MAXUINT,
      500,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );
}
InfTextSession*
inf_text_session_new(InfCommunicationManager* manager,
                     InfTextBuffer* buffer,
                     InfIo* io,
                     InfSessionStatus status,
                     InfCommunicationGroup* sync_group,
                     InfXmlConnection* sync_connection)
{
  GObject* object;
  g_return_val_if_fail(INF_COMMUNICATION_IS_MANAGER(manager), NULL);
  g_return_val_if_fail(INF_TEXT_IS_BUFFER(buffer), NULL);
  g_return_val_if_fail(INF_IS_IO(io), NULL);
  g_return_val_if_fail(
    (status == INF_SESSION_RUNNING &amp;&amp;
     sync_group == NULL &amp;&amp; sync_connection == NULL) ||
    (status != INF_SESSION_RUNNING &amp;&amp;
     INF_COMMUNICATION_IS_GROUP(sync_group) &amp;&amp;
     INF_IS_XML_CONNECTION(sync_connection)),
    NULL
  );
  object = g_object_new(
    INF_TEXT_TYPE_SESSION,
    "communication-manager", manager,
    "buffer", buffer,
    "status", status,
    "sync-group", sync_group,
    "sync-connection", sync_connection,
    "io", io,
    NULL
  );
  return INF_TEXT_SESSION(object);
}
InfTextSession*
inf_text_session_new_with_user_table(InfCommunicationManager* manager,
                                     InfTextBuffer* buffer,
                                     InfIo* io,
                                     InfUserTable* user_table,
                                     InfSessionStatus status,
                                     InfCommunicationGroup* sync_group,
                                     InfXmlConnection* sync_connection)
{
  GObject* object;
  g_return_val_if_fail(INF_COMMUNICATION_IS_MANAGER(manager), NULL);
  g_return_val_if_fail(INF_TEXT_IS_BUFFER(buffer), NULL);
  g_return_val_if_fail(INF_IS_IO(io), NULL);
  g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);
  g_return_val_if_fail(
    (status == INF_SESSION_RUNNING &amp;&amp;
     sync_group == NULL &amp;&amp; sync_connection == NULL) ||
    (status != INF_SESSION_RUNNING &amp;&amp;
     INF_COMMUNICATION_IS_GROUP(sync_group) &amp;&amp;
     INF_IS_XML_CONNECTION(sync_connection)),
    NULL
  );
  object = g_object_new(
    INF_TEXT_TYPE_SESSION,
    "communication-manager", manager,
    "buffer", buffer,
    "user-table", user_table,
    "status", status,
    "sync-group", sync_group,
    "sync-connection", sync_connection,
    "io", io,
    NULL
  );
  return INF_TEXT_SESSION(object);
}
void
inf_text_session_set_user_color(InfTextSession* session,
                                InfTextUser* user,
                                gdouble hue)
{
  xmlNodePtr xml;
  g_return_if_fail(INF_TEXT_IS_SESSION(session));
  g_return_if_fail(INF_TEXT_IS_USER(user));
  g_return_if_fail(hue &gt;= 0.0 &amp;&amp; hue &lt;= 1.0);
  g_return_if_fail(
    inf_user_get_status(INF_USER(user)) != INF_USER_UNAVAILABLE
  );
  g_return_if_fail(
    (inf_user_get_flags(INF_USER(user)) &amp; INF_USER_LOCAL) != 0
  );
  xml = xmlNewNode(NULL, (const xmlChar*)"user-color-change");
  inf_xml_util_set_attribute_uint(xml, "id", inf_user_get_id(INF_USER(user)));
  inf_xml_util_set_attribute_double(xml, "hue", hue);
  inf_session_send_to_subscriptions(INF_SESSION(session), xml);
  g_object_set(G_OBJECT(user), "hue", hue, NULL);
}
void
inf_text_session_flush_requests_for_user(InfTextSession* session,
                                         InfTextUser* user)
{
  InfTextSessionLocalUser* local;
  g_return_if_fail(INF_TEXT_IS_SESSION(session));
  g_return_if_fail(INF_TEXT_IS_USER(user));
  local = inf_text_session_find_local_user(session, user);
  g_assert(local != NULL);
  if(local-&gt;caret_timeout != NULL)
  {
    inf_text_session_broadcast_caret_selection(session, local);
  }
}
InfRequest*
inf_text_session_join_user(InfSessionProxy* proxy,
                           const gchar* name,
                           InfUserStatus status,
                           gdouble hue,
                           guint caret_position,
                           int selection_length,
                           InfRequestFunc func,
                           gpointer user_data)
{
#define N_PARAMS 6u
  GParameter params[N_PARAMS] = {
    { "hue", { 0 } },
    { "vector", { 0 } },
    { "caret-position", { 0 } },
    { "selection-length", { 0 } },
    { "name", { 0 } },
    { "status", { 0 } }
  };
  InfSession* session;
  InfRequest* request;
  guint i;
  g_return_val_if_fail(INF_IS_SESSION_PROXY(proxy), NULL);
  g_object_get(G_OBJECT(proxy), "session", &amp;session, NULL);
  g_return_val_if_fail(INF_TEXT_IS_SESSION(session), NULL);
  g_value_init(&amp;params[0].value, G_TYPE_DOUBLE);
  g_value_set_double(&amp;params[0].value, hue);
  g_value_init(&amp;params[1].value, INF_ADOPTED_TYPE_STATE_VECTOR);
  g_value_set_boxed(
    &amp;params[1].value,
    inf_adopted_algorithm_get_current(
      inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session))
    )
  );
  g_value_init(&amp;params[2].value, G_TYPE_UINT);
  g_value_set_uint(&amp;params[2].value, caret_position);
  g_value_init(&amp;params[3].value, G_TYPE_INT);
  g_value_set_int(&amp;params[3].value, selection_length);
  g_value_init(&amp;params[4].value, G_TYPE_STRING);
  g_value_set_string(&amp;params[4].value, name); 
  g_value_init(&amp;params[5].value, INF_TYPE_USER_STATUS);
  g_value_set_enum(&amp;params[5].value, status);
  request = inf_session_proxy_join_user(
    proxy,
    N_PARAMS,
    params,
    func,
    user_data
  );
  for(i = 0; i &lt; N_PARAMS; ++i)
    g_value_unset(&amp;params[i].value);
#undef N_PARAMS
  g_object_unref(session);
  return request;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
