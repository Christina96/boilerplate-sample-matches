<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-text-gtk-viewport.c &amp; inf-text-session.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-text-gtk-viewport.c &amp; inf-text-session.c
      </h3>
<h1 align="center">
        13.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-text-gtk-viewport.c (20.408163%)<th>inf-text-session.c (9.815951%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(402-461)<td><a href="#" name="0">(694-759)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(802-825)<td><a href="#" name="1">(873-896)</a><td align="center"><font color="#df0000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(303-323)<td><a href="#" name="2">(425-446)</a><td align="center"><font color="#cf0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(44-71)<td><a href="#" name="3">(42-60)</a><td align="center"><font color="#cf0000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(670-725)<td><a href="#" name="4">(1211-1242)</a><td align="center"><font color="#bf0000">12</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(326-344)<td><a href="#" name="5">(448-468)</a><td align="center"><font color="#bf0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-gtk-viewport.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinftextgtk/inf-text-gtk-viewport.h&gt;
2 #include &lt;libinfinity/inf-signals.h&gt;
3 <a name="3"></a>
4 #include &lt;gtk/gtk.h&gt;
5 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>typedef struct _InfTextGtkViewportUser InfTextGtkViewportUser;
6 struct _InfTextGtkViewportUser {
7   InfTextGtkViewport* viewport;
8   InfTextUser* user;
9   GdkRectangle rectangle;
10 };
11 typedef struct _InfTextGtkViewportPrivate InfTextGtkViewportPrivate;
12 struct _InfTextGtkViewportPrivate {
13   GtkScrolledWindow* scroll;
14   InfUserTable* user_table;
15   InfTextUser* active_user;
16   GSList* users;
17   gboolean show_user_markers;
18 };
19 enum {
20   PROP_0,
21   PROP_SCROLLED_WINDOW,
22   PROP_USER_TABLE,
23   PROP_ACTIVE_USER,
24   PROP_SHOW_USER_MARKERS
25 };</b></font>
26 #define INF_TEXT_GTK_VIEWPORT_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_GTK_TYPE_VIEWPORT, InfTextGtkViewportPrivate))
27 G_DEFINE_TYPE_WITH_CODE(InfTextGtkViewport, inf_text_gtk_viewport, G_TYPE_OBJECT,
28   G_ADD_PRIVATE(InfTextGtkViewport))
29 static InfTextGtkViewportUser*
30 inf_text_gtk_viewport_find_user(InfTextGtkViewport* viewport,
31                                 InfTextUser* user)
32 {
33   InfTextGtkViewportPrivate* priv;
34   GSList* item;
35   priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
36   for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
37     if( ((InfTextGtkViewportUser*)item-&gt;data)-&gt;user == user)
38       return (InfTextGtkViewportUser*)item-&gt;data;
39   return NULL;
40 }
41 static void
42 inf_text_gtk_viewport_user_compute_user_area(InfTextGtkViewportUser* user)
43 {
44   InfTextGtkViewportPrivate* priv;
45   GtkWidget* textview;
46   GtkWidget* scrollbar;
47   GtkTextIter iter;
48   GdkRectangle rect;
49   gint y;
50   gint end_y;
51   gint scroll_height;
52   gint slider_size;
53   gint stepper_size;
54   gint stepper_spacing;
55   gint border;
56   GdkRectangle allocation;
57   gint scroll_ox;
58   gint scroll_oy;
59   gint dy;
60   priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(user-&gt;viewport);
61   textview = gtk_bin_get_child(GTK_BIN(priv-&gt;scroll));
62   scrollbar = gtk_scrolled_window_get_vscrollbar(priv-&gt;scroll);
63   if(GTK_IS_TEXT_VIEW(textview) &amp;&amp; scrollbar != NULL &amp;&amp;
64      gtk_widget_get_realized(textview))
65   {
66     gtk_text_buffer_get_iter_at_offset(
67       gtk_text_view_get_buffer(GTK_TEXT_VIEW(textview)),
68       &amp;iter,
69       inf_text_user_get_caret_position(user-&gt;user)
70     );
71     gtk_text_view_get_iter_location(GTK_TEXT_VIEW(textview), &amp;iter, &amp;rect);
72     y = rect.y;
73     gtk_text_buffer_get_end_iter(
74       gtk_text_view_get_buffer(GTK_TEXT_VIEW(textview)),
75       &amp;iter
76     );
77     gtk_text_view_get_iter_location(GTK_TEXT_VIEW(textview), &amp;iter, &amp;rect);
78     end_y = rect.y;
79     g_assert(end_y &gt; 0 || y == 0);
80     gtk_widget_style_get(
81       scrollbar,
82       "slider-width", &amp;slider_size,
83       "stepper-size", &amp;stepper_size,
84       "stepper-spacing", &amp;stepper_spacing,
85       "trough-border", &amp;border,
86       NULL
87     );
88     gtk_widget_get_allocation(scrollbar, &amp;allocation);
89     scroll_ox = border;
90     scroll_oy = border + stepper_size + stepper_spacing;
91     scroll_height = allocation.height - 2*scroll_oy;
92     if(end_y &gt; 0)
93       y = y * scroll_height / end_y;
94     user-&gt;rectangle.x = scroll_ox + allocation.x;
95     user-&gt;rectangle.y = scroll_oy + allocation.y + y - slider_size/3;
96     user-&gt;rectangle.width = slider_size;
97     user-&gt;rectangle.height = slider_size*2/3;
98     if(user-&gt;rectangle.y &lt; scroll_oy + allocation.y)
99     {
100       dy = scroll_oy + allocation.y - user-&gt;rectangle.y;
101       user-&gt;rectangle.y += dy;
102       user-&gt;rectangle.height -= dy;
103     }
104     if(user-&gt;rectangle.y + user-&gt;rectangle.height &gt;
105        scroll_oy + allocation.y + scroll_height)
106     {
107       user-&gt;rectangle.height =
108         scroll_oy + allocation.y + scroll_height - user-&gt;rectangle.y;
109     }
110   }
111   else
112   {
113     user-&gt;rectangle.x = user-&gt;rectangle.y = 0;
114     user-&gt;rectangle.width = user-&gt;rectangle.height = 0;
115   }
116 }
117 static void
118 inf_text_gtk_viewport_user_invalidate_user_area(InfTextGtkViewportUser* user)
119 {
120   InfTextGtkViewportPrivate* priv;
121   GtkWidget* scrollbar;
122   priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(user-&gt;viewport);
123   if(priv-&gt;show_user_markers &amp;&amp;
124      user-&gt;rectangle.width &gt; 0 &amp;&amp; user-&gt;rectangle.height &gt; 0)
125   {
126     scrollbar = gtk_scrolled_window_get_vscrollbar(priv-&gt;scroll);
127     if(scrollbar != NULL)
128     {
129       gtk_widget_queue_draw_area(
130         scrollbar,
131         user-&gt;rectangle.x,
132         user-&gt;rectangle.y,
133         user-&gt;rectangle.width,
134         user-&gt;rectangle.height
135       );
136     }
137   }
138 }
139 static gboolean
140 inf_text_gtk_viewport_scrollbar_draw_cb(GtkWidget* scrollbar,
141                                         cairo_t* cr,
142                                         gpointer user_data)
143 {
144   InfTextGtkViewport* viewport;
145   InfTextGtkViewportPrivate* priv;
146   InfTextGtkViewportUser* viewport_user;
147   GdkRectangle* rectangle;
148   GtkStyleContext* style;
149   GdkRGBA bg;
150   double h,s,v;
151   double r,g,b;
152   GSList* item;
153   double line_width;
154   GdkRectangle clip_area;
155   viewport = INF_TEXT_GTK_VIEWPORT(user_data);
156   priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
157   if(!gtk_cairo_should_draw_window(cr, gtk_widget_get_window(scrollbar)))
158     return FALSE;
159   if(priv-&gt;show_user_markers)
160   {
161     style = gtk_widget_get_style_context(GTK_WIDGET(scrollbar));
162     gtk_style_context_save(style);
163     gtk_style_context_add_class(style, GTK_STYLE_CLASS_VIEW);
164     gtk_style_context_get_background_color(style, GTK_STATE_FLAG_NORMAL, &amp;bg);
165     gtk_style_context_restore(style);
166     gtk_rgb_to_hsv(bg.red, bg.green, bg.blue, &amp;h, &amp;s, &amp;v);
167     s = MIN(MAX(s, 0.5), 0.8);
168     v = MAX(v, 0.5);
169     gtk_cairo_transform_to_window(
170       cr,
171       GTK_WIDGET(scrollbar),
172       gtk_widget_get_window(scrollbar)
173     );
174     gdk_cairo_get_clip_rectangle(cr, &amp;clip_area);
175     line_width = cairo_get_line_width(cr);
176     for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
177     {
178       viewport_user = (InfTextGtkViewportUser*)item-&gt;data;
179       rectangle = &amp;viewport_user-&gt;rectangle;
180       if(gdk_rectangle_intersect(&amp;clip_area, rectangle, NULL))
181       {
182         h = inf_text_user_get_hue(viewport_user-&gt;user);
183         cairo_rectangle(
184           cr,
185           rectangle-&gt;x + line_width/2,
186           rectangle-&gt;y + line_width/2,
187           rectangle-&gt;width - line_width,
188           rectangle-&gt;height - line_width
189         );
190         gtk_hsv_to_rgb(h, s, v/2.0, &amp;r, &amp;g, &amp;b);
191         cairo_set_source_rgba(cr, r, g, b, 0.6);
192         cairo_stroke_preserve(cr);
193         gtk_hsv_to_rgb(h, s, v, &amp;r, &amp;g, &amp;b);
194         cairo_set_source_rgba(cr, r, g, b, 0.6);
195         cairo_fill(cr);
196       }
197     }
198   }
199   return FALSE;
200 }
201 static void
202 inf_text_gtk_viewport_scrollbar_size_allocate_cb(GtkWidget* scrollbar,
203                                                  GtkAllocation* allocation,
204                                                  gpointer user_data)
205 {
206   InfTextGtkViewport* viewport;
207   InfTextGtkViewportPrivate* priv;
208   GSList* item;
209 <a name="2"></a>  InfTextGtkViewportUser* viewport_user;
210   viewport = INF_TEXT_GTK_VIEWPORT(user_data);
211 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
212   for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
213   {
214     viewport_user = (InfTextGtkViewportUser*)item-&gt;data;
215     inf_text_gtk_viewport_user_invalidate_user_area(viewport_user);
216     inf_text_gtk_viewport_user_compute_user_area(viewport_user);
217     inf_text_gtk_viewport_user_invalidate_user_area(viewport_user);
218   }
219 }
220 static void
221 inf_text_gtk_viewport_adjustment_changed_cb(GtkAdjustment* adjustment,
222                                             gpointer user_data)
223 {
224   InfTextGtkViewport* viewport;
225   InfTextGtkViewportPrivate* priv;
226   GSList* item;
227   InfTextGtkViewportUser* viewport_user;
228 <a name="5"></a>  viewport = INF_TEXT_GTK_VIEWPORT(user_data);</b></font>
229   priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
230 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
231   {
232     viewport_user = (InfTextGtkViewportUser*)item-&gt;data;
233     inf_text_gtk_viewport_user_invalidate_user_area(viewport_user);
234     inf_text_gtk_viewport_user_compute_user_area(viewport_user);
235     inf_text_gtk_viewport_user_invalidate_user_area(viewport_user);
236   }
237 }
238 static void
239 inf_text_gtk_viewport_scrollbar_style_updated_cb(GtkWidget* scrollbar,
240                                                  gpointer user_data)
241 {
242   InfTextGtkViewport* viewport;
243   InfTextGtkViewportPrivate* priv;
244   GSList* item;
245   InfTextGtkViewportUser* viewport_user;
246   viewport = INF_TEXT_GTK_VIEWPORT(user_data);</b></font>
247   priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
248   for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
249   {
250     viewport_user = (InfTextGtkViewportUser*)item-&gt;data;
251     inf_text_gtk_viewport_user_invalidate_user_area(viewport_user);
252     inf_text_gtk_viewport_user_compute_user_area(viewport_user);
253     inf_text_gtk_viewport_user_invalidate_user_area(viewport_user);
254   }
255 }
256 static void
257 inf_text_gtk_viewport_user_selection_changed_cb(InfTextUser* user,
258                                                 guint position,
259                                                 gint length,
260                                                 gboolean by_request,
261                                                 gpointer user_data)
262 {
263   InfTextGtkViewportUser* viewport_user;
264   InfTextGtkViewportPrivate* priv;
265   viewport_user = (InfTextGtkViewportUser*)user_data;
266   priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport_user-&gt;viewport);
267   inf_text_gtk_viewport_user_invalidate_user_area(viewport_user);
268   inf_text_gtk_viewport_user_compute_user_area(viewport_user);
269   inf_text_gtk_viewport_user_invalidate_user_area(viewport_user);
270 }
271 static void
272 inf_text_gtk_viewport_user_notify_hue_cb(GObject* object,
273                                          GParamSpec* pspec,
274                                          gpointer user_data)
275 {
276   InfTextGtkViewportUser* viewport_user;
277   InfTextGtkViewportPrivate* priv;
278   viewport_user = (InfTextGtkViewportUser*)user_data;
279   priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport_user-&gt;viewport);
280   inf_text_gtk_viewport_user_invalidate_user_area(viewport_user);
281 }
282 static void
283 inf_text_gtk_viewport_add_user(InfTextGtkViewport* viewport,
284                               InfTextUser* user)
285 {
286   InfTextGtkViewportPrivate* priv;
287   InfTextGtkViewportUser* viewport_user;
288 <a name="0"></a>  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
289   viewport_user = g_slice_new(InfTextGtkViewportUser);
290 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  viewport_user-&gt;viewport = viewport;
291   viewport_user-&gt;user = INF_TEXT_USER(user);
292   priv-&gt;users = g_slist_prepend(priv-&gt;users, viewport_user);
293   inf_text_gtk_viewport_user_compute_user_area(viewport_user);
294   g_signal_connect_after(
295     user,
296     "selection-changed",
297     G_CALLBACK(inf_text_gtk_viewport_user_selection_changed_cb),
298     viewport_user
299   );
300   g_signal_connect(
301     user,
302     "notify::hue",
303     G_CALLBACK(inf_text_gtk_viewport_user_notify_hue_cb),
304     viewport_user
305   );
306   inf_text_gtk_viewport_user_invalidate_user_area(viewport_user);
307 }
308 static void
309 inf_text_gtk_viewport_remove_user(InfTextGtkViewportUser* viewport_user)
310 {
311   InfTextGtkViewportPrivate* priv;
312   priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport_user-&gt;viewport);
313   inf_text_gtk_viewport_user_invalidate_user_area(viewport_user);
314   inf_signal_handlers_disconnect_by_func(
315     viewport_user-&gt;user,
316     G_CALLBACK(inf_text_gtk_viewport_user_selection_changed_cb),
317     viewport_user
318   );
319   inf_signal_handlers_disconnect_by_func(
320     viewport_user-&gt;user,
321     G_CALLBACK(inf_text_gtk_viewport_user_notify_hue_cb),
322     viewport_user
323   );
324   priv-&gt;users = g_slist_remove(priv-&gt;users, viewport_user);
325   g_slice_free(InfTextGtkViewportUser, viewport_user);
326 }
327 static void
328 inf_text_gtk_viewport_user_notify_status_cb(GObject* object,
329                                             GParamSpec* pspec,
330                                             gpointer user_data)
331 {
332   InfTextGtkViewport* viewport;
333   InfTextGtkViewportPrivate* priv;
334   InfTextUser* user;
335   InfTextGtkViewportUser* viewport_user;
336   viewport = INF_TEXT_GTK_VIEWPORT(user_data);
337   priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
338   user = INF_TEXT_USER(object);</b></font>
339   g_assert(user != priv-&gt;active_user);
340   viewport_user = inf_text_gtk_viewport_find_user(viewport, user);
341   if(inf_user_get_status(INF_USER(user)) == INF_USER_ACTIVE)
342   {
343     if(!viewport_user)
344       inf_text_gtk_viewport_add_user(viewport, user);
345   }
346   else
347   {
348     if(viewport_user)
349       inf_text_gtk_viewport_remove_user(viewport_user);
350   }
351 }
352 static void
353 inf_text_gtk_viewport_user_removed(InfTextGtkViewport* viewport,
354                                    InfTextUser* user)
355 {
356   InfTextGtkViewportPrivate* priv;
357   InfTextGtkViewportUser* viewport_user;
358   priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
359   if(user == priv-&gt;active_user)
360   {
361     priv-&gt;active_user = NULL;
362     g_object_notify(G_OBJECT(viewport), "active-user");
363   }
364   else
365   {
366     inf_signal_handlers_disconnect_by_func(
367       user,
368       G_CALLBACK(inf_text_gtk_viewport_user_notify_status_cb),
369       viewport
370     );
371     if(inf_user_get_status(INF_USER(user)) == INF_USER_ACTIVE)
372     {
373       viewport_user = inf_text_gtk_viewport_find_user(viewport, user);
374       g_assert(viewport_user != NULL);
375       inf_text_gtk_viewport_remove_user(viewport_user);
376     }
377   }
378 }
379 static void
380 inf_text_gtk_viewport_user_added(InfTextGtkViewport* viewport,
381                                  InfTextUser* user)
382 {
383   InfTextGtkViewportPrivate* priv;
384   priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
385   g_assert(user != priv-&gt;active_user);
386   g_signal_connect(
387     user,
388     "notify::status",
389     G_CALLBACK(inf_text_gtk_viewport_user_notify_status_cb),
390     viewport
391   );
392   if(inf_user_get_status(INF_USER(user)) == INF_USER_ACTIVE)
393     inf_text_gtk_viewport_add_user(viewport, user);
394 }
395 static void
396 inf_text_gtk_viewport_add_user_cb(InfUserTable* user_table,
397                                   InfUser* user,
398                                   gpointer user_data)
399 {
400   InfTextGtkViewport* viewport = INF_TEXT_GTK_VIEWPORT(user_data);
401   g_assert(INF_TEXT_IS_USER(user));
402   inf_text_gtk_viewport_user_added(viewport, INF_TEXT_USER(user));
403 }
404 static void
405 inf_text_gtk_viewport_remove_user_cb(InfUserTable* user_table,
406                                      InfUser* user,
407                                      gpointer user_data)
408 {
409   InfTextGtkViewport* viewport = INF_TEXT_GTK_VIEWPORT(user_data);
410   g_assert(INF_TEXT_IS_USER(user));
411   inf_text_gtk_viewport_user_removed(viewport, INF_TEXT_USER(user));
412 }
413 static void
414 inf_text_gtk_viewport_set_user_table_foreach_new_user_func(InfUser* user,
415                                                            gpointer user_data)
416 {
417   InfTextGtkViewport* viewport = INF_TEXT_GTK_VIEWPORT(user_data);
418   g_assert(INF_TEXT_IS_USER(user));
419   inf_text_gtk_viewport_user_added(viewport, INF_TEXT_USER(user));
420 }
421 static void
422 inf_text_gtk_viewport_set_user_table_foreach_old_user_func(InfUser* user,
423                                                            gpointer user_data)
424 {
425   InfTextGtkViewport* viewport = INF_TEXT_GTK_VIEWPORT(user_data);
426   g_assert(INF_TEXT_IS_USER(user));
427   inf_text_gtk_viewport_user_removed(viewport, INF_TEXT_USER(user));
428 }
429 static void
430 inf_text_gtk_viewport_set_scrolled_window(InfTextGtkViewport* viewport,
431                                           GtkScrolledWindow* scroll)
432 {
433   InfTextGtkViewportPrivate* priv;
434   GtkWidget* scrollbar;
435   GtkAdjustment* adjustment;
436   priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
437   if(priv-&gt;scroll != NULL)
438   {
439     scrollbar = gtk_scrolled_window_get_vscrollbar(priv-&gt;scroll);
440     if(scrollbar != NULL)
441     {
442       adjustment = gtk_range_get_adjustment(GTK_RANGE(scrollbar));
443       g_assert(adjustment != NULL);
444       inf_signal_handlers_disconnect_by_func(
445         G_OBJECT(adjustment),
446         G_CALLBACK(inf_text_gtk_viewport_adjustment_changed_cb),
447         viewport
448       );
449       inf_signal_handlers_disconnect_by_func(
450         G_OBJECT(scrollbar),
451         G_CALLBACK(inf_text_gtk_viewport_scrollbar_size_allocate_cb),
452         viewport
453       );
454       inf_signal_handlers_disconnect_by_func(
455         G_OBJECT(scrollbar),
456         G_CALLBACK(inf_text_gtk_viewport_scrollbar_style_updated_cb),
457         viewport
458       );
459       inf_signal_handlers_disconnect_by_func(
460         G_OBJECT(scrollbar),
461         G_CALLBACK(inf_text_gtk_viewport_scrollbar_draw_cb),
462         viewport
463       );
464     }
465     g_object_unref(priv-&gt;scroll);
466   }
467   priv-&gt;scroll = scroll;
468   if(scroll != NULL)
469   {
470     scrollbar = gtk_scrolled_window_get_vscrollbar(priv-&gt;scroll);
471     g_assert(scrollbar != NULL);
472     adjustment = gtk_range_get_adjustment(GTK_RANGE(scrollbar));
473     g_assert(adjustment != NULL);
474     g_object_ref(scroll);
475     g_signal_connect_after(
476       G_OBJECT(adjustment),
477       "changed",
478       G_CALLBACK(inf_text_gtk_viewport_adjustment_changed_cb),
479       viewport
480     );
481     g_signal_connect_after(
482       G_OBJECT(scrollbar),
483       "size-allocate",
484       G_CALLBACK(inf_text_gtk_viewport_scrollbar_size_allocate_cb),
485       viewport
486     );
487     g_signal_connect_after(
488       G_OBJECT(scrollbar),
489       "style-updated",
490       G_CALLBACK(inf_text_gtk_viewport_scrollbar_style_updated_cb),
491       viewport
492     );
493     g_signal_connect_after(
494       G_OBJECT(scrollbar),
495       "draw",
496       G_CALLBACK(inf_text_gtk_viewport_scrollbar_draw_cb),
497       viewport
498     );
499   }
500   g_object_notify(G_OBJECT(viewport), "scrolled-window");
501 }
502 static void
503 inf_text_gtk_viewport_set_user_table(InfTextGtkViewport* viewport,
504 <a name="4"></a>                                     InfUserTable* user_table)
505 {
506   InfTextGtkViewportPrivate* priv;
507 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
508   if(priv-&gt;user_table != NULL)
509   {
510     inf_signal_handlers_disconnect_by_func(
511       G_OBJECT(priv-&gt;user_table),
512       G_CALLBACK(inf_text_gtk_viewport_add_user_cb),
513       viewport
514     );
515     inf_signal_handlers_disconnect_by_func(
516       G_OBJECT(priv-&gt;user_table),
517       G_CALLBACK(inf_text_gtk_viewport_remove_user_cb),
518       viewport
519     );
520     inf_user_table_foreach_user(
521       priv-&gt;user_table,
522       inf_text_gtk_viewport_set_user_table_foreach_old_user_func,
523       viewport
524     );
525     g_object_unref(priv-&gt;user_table);
526   }
527   priv-&gt;user_table = user_table;
528   if(user_table != NULL)
529   {
530     g_object_ref(user_table);
531     g_signal_connect(
532       G_OBJECT(user_table),
533       "add-user",
534       G_CALLBACK(inf_text_gtk_viewport_add_user_cb),
535       viewport
536     );
537     g_signal_connect(
538       G_OBJECT(user_table),
539       "remove-user",
540       G_CALLBACK(inf_text_gtk_viewport_remove_user_cb),
541       viewport
542     );
543     inf_user_table_foreach_user(
544       user_table,
545       inf_text_gtk_viewport_set_user_table_foreach_new_user_func,
546       viewport
547     );
548   }
549   g_object_notify(G_OBJECT(viewport), "user-table");
550 }
551 static void</b></font>
552 inf_text_gtk_viewport_init(InfTextGtkViewport* viewport)
553 {
554   InfTextGtkViewportPrivate* priv;
555   priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
556   priv-&gt;scroll = NULL;
557   priv-&gt;user_table = NULL;
558   priv-&gt;active_user = NULL;
559   priv-&gt;users = NULL;
560   priv-&gt;show_user_markers = TRUE;
561 }
562 static void
563 inf_text_gtk_viewport_dispose(GObject* object)
564 {
565   InfTextGtkViewport* viewport;
566   InfTextGtkViewportPrivate* priv;
567   viewport = INF_TEXT_GTK_VIEWPORT(object);
568   priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
569   inf_text_gtk_viewport_set_user_table(viewport, NULL);
570   inf_text_gtk_viewport_set_scrolled_window(viewport, NULL);
571   g_assert(priv-&gt;active_user == NULL);
572   g_assert(priv-&gt;users == NULL);
573   G_OBJECT_CLASS(inf_text_gtk_viewport_parent_class)-&gt;dispose(object);
574 }
575 static void
576 inf_text_gtk_viewport_set_property(GObject* object,
577                                    guint prop_id,
578                                    const GValue* value,
579                                    GParamSpec* pspec)
580 {
581   InfTextGtkViewport* viewport;
582   InfTextGtkViewportPrivate* priv;
583   viewport = INF_TEXT_GTK_VIEWPORT(object);
584   priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
585   switch(prop_id)
586   {
587   case PROP_SCROLLED_WINDOW:
588     g_assert(priv-&gt;scroll == NULL); 
589     inf_text_gtk_viewport_set_scrolled_window(
590       viewport,
591       GTK_SCROLLED_WINDOW(g_value_get_object(value))
592     );
593     break;
594   case PROP_USER_TABLE:
595     g_assert(priv-&gt;user_table == NULL); 
596     inf_text_gtk_viewport_set_user_table(
597       viewport,
598       INF_USER_TABLE(g_value_get_object(value))
599     );
600     break;
601   case PROP_ACTIVE_USER:
602     inf_text_gtk_viewport_set_active_user(
603       viewport,
604       INF_TEXT_USER(g_value_get_object(value))
605     );
606     break;
607   case PROP_SHOW_USER_MARKERS:
608     inf_text_gtk_viewport_set_show_user_markers(
609       viewport,
610 <a name="1"></a>      g_value_get_boolean(value)
611     );
612 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
613   default:
614     G_OBJECT_WARN_INVALID_PROPERTY_ID(value, prop_id, pspec);
615     break;
616   }
617 }
618 static void
619 inf_text_gtk_viewport_get_property(GObject* object,
620                                    guint prop_id,
621                                    GValue* value,
622                                    GParamSpec* pspec)
623 {
624   InfTextGtkViewport* viewport;
625   InfTextGtkViewportPrivate* priv;
626   viewport = INF_TEXT_GTK_VIEWPORT(object);
627   priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
628   switch(prop_id)
629   {
630   case PROP_SCROLLED_WINDOW:
631     g_value_set_object(value, G_OBJECT(priv-&gt;scroll));
632     break;</b></font>
633   case PROP_USER_TABLE:
634     g_value_set_object(value, G_OBJECT(priv-&gt;user_table));
635     break;
636   case PROP_ACTIVE_USER:
637     g_value_set_object(value, G_OBJECT(priv-&gt;active_user));
638     break;
639   case PROP_SHOW_USER_MARKERS:
640     g_value_set_boolean(value, priv-&gt;show_user_markers);
641     break;
642   default:
643     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
644     break;
645   }
646 }
647 static void
648 inf_text_gtk_viewport_class_init(InfTextGtkViewportClass* viewport_class)
649 {
650   GObjectClass* object_class;
651   object_class = G_OBJECT_CLASS(viewport_class);
652   object_class-&gt;dispose = inf_text_gtk_viewport_dispose;
653   object_class-&gt;set_property = inf_text_gtk_viewport_set_property;
654   object_class-&gt;get_property = inf_text_gtk_viewport_get_property;
655   g_object_class_install_property(
656     object_class,
657     PROP_SCROLLED_WINDOW,
658     g_param_spec_object(
659       "scrolled-window",
660       "Scrolled Window",
661       "The underlying GtkScrolledWindow",
662       GTK_TYPE_SCROLLED_WINDOW,
663       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
664     )
665   );
666   g_object_class_install_property(
667     object_class,
668     PROP_USER_TABLE,
669     g_param_spec_object(
670       "user-table",
671       "User table",
672       "The user table containing the users of the session shown in the "
673       "viewport",
674       INF_TYPE_USER_TABLE,
675       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
676     )
677   );
678   g_object_class_install_property(
679     object_class,
680     PROP_ACTIVE_USER,
681     g_param_spec_object(
682       "active-user",
683       "Active user",
684       "The user for which to show the viewport",
685       INF_TEXT_TYPE_USER,
686       G_PARAM_READWRITE
687     )
688   );
689   g_object_class_install_property(
690     object_class,
691     PROP_SHOW_USER_MARKERS,
692     g_param_spec_boolean(
693       "show-user-markers",
694       "Show user markers",
695       "Whether to indicate the position of non-local user's cursors in the "
696       "scrollbar",
697       TRUE,
698       G_PARAM_READWRITE
699     )
700   );
701 }
702 InfTextGtkViewport*
703 inf_text_gtk_viewport_new(GtkScrolledWindow* scroll,
704                           InfUserTable* user_table)
705 {
706   GObject* object;
707   g_return_val_if_fail(GTK_IS_SCROLLED_WINDOW(scroll), NULL);
708   g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);
709   object = g_object_new(
710     INF_TEXT_GTK_TYPE_VIEWPORT,
711     "scrolled-window", scroll,
712     "user-table", user_table,
713     NULL
714   );
715   return INF_TEXT_GTK_VIEWPORT(object);
716 }
717 GtkScrolledWindow*
718 inf_text_gtk_viewport_get_scrolled_window(InfTextGtkViewport* viewport)
719 {
720   g_return_val_if_fail(INF_TEXT_GTK_IS_VIEWPORT(viewport), NULL);
721   return INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport)-&gt;scroll;
722 }
723 InfUserTable*
724 inf_text_gtk_viewport_get_user_table(InfTextGtkViewport* viewport)
725 {
726   g_return_val_if_fail(INF_TEXT_GTK_IS_VIEWPORT(viewport), NULL);
727   return INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport)-&gt;user_table;
728 }
729 void
730 inf_text_gtk_viewport_set_active_user(InfTextGtkViewport* viewport,
731                                       InfTextUser* user)
732 {
733   InfTextGtkViewportPrivate* priv;
734   InfTextUser* active_user;
735   g_return_if_fail(INF_TEXT_GTK_IS_VIEWPORT(viewport));
736   g_return_if_fail(user == NULL || INF_TEXT_IS_USER(user));
737   priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
738   g_return_if_fail(
739     user == NULL ||
740     inf_user_table_lookup_user_by_id(
741       priv-&gt;user_table,
742       inf_user_get_id(INF_USER(user))
743     ) == INF_USER(user)
744   );
745   if(priv-&gt;active_user != NULL)
746   {
747     active_user = priv-&gt;active_user;
748     priv-&gt;active_user = NULL;
749     inf_text_gtk_viewport_user_added(viewport, active_user);
750   }
751   if(user != NULL)
752   {
753     inf_text_gtk_viewport_user_removed(viewport, user);
754   }
755   priv-&gt;active_user = user;
756   g_object_notify(G_OBJECT(viewport), "active-user");
757 }
758 InfTextUser*
759 inf_text_gtk_viewport_get_active_user(InfTextGtkViewport* viewport)
760 {
761   g_return_val_if_fail(INF_TEXT_GTK_IS_VIEWPORT(viewport), NULL);
762   return INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport)-&gt;active_user;
763 }
764 void
765 inf_text_gtk_viewport_set_show_user_markers(InfTextGtkViewport* viewport,
766                                             gboolean show)
767 {
768   InfTextGtkViewportPrivate* priv;
769   g_return_if_fail(INF_TEXT_GTK_IS_VIEWPORT(viewport));
770   priv = INF_TEXT_GTK_VIEWPORT_PRIVATE(viewport);
771   if(priv-&gt;show_user_markers != show)
772   {
773     gtk_widget_queue_draw(gtk_scrolled_window_get_vscrollbar(priv-&gt;scroll));
774     priv-&gt;show_user_markers = show;
775     g_object_notify(G_OBJECT(viewport), "show-user-markers");
776   }
777 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-session.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinftext/inf-text-session.h&gt;
2 #include &lt;libinftext/inf-text-default-insert-operation.h&gt;
3 #include &lt;libinftext/inf-text-default-delete-operation.h&gt;
4 #include &lt;libinftext/inf-text-remote-delete-operation.h&gt;
5 #include &lt;libinftext/inf-text-insert-operation.h&gt;
6 #include &lt;libinftext/inf-text-delete-operation.h&gt;
7 #include &lt;libinftext/inf-text-move-operation.h&gt;
8 #include &lt;libinftext/inf-text-chunk.h&gt;
9 #include &lt;libinftext/inf-text-user.h&gt;
10 #include &lt;libinfinity/adopted/inf-adopted-no-operation.h&gt;
11 #include &lt;libinfinity/common/inf-xml-util.h&gt;
12 #include &lt;libinfinity/common/inf-error.h&gt;
13 #include &lt;libinfinity/inf-i18n.h&gt;
14 #include &lt;libinfinity/inf-signals.h&gt;
15 #include &lt;libxml/tree.h&gt;
16 #include &lt;string.h&gt;
17 #include &lt;errno.h&gt;
18 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>typedef struct _InfTextSessionLocalUser InfTextSessionLocalUser;
19 struct _InfTextSessionLocalUser {
20   InfTextSession* session;
21   InfTextUser* user;
22   GTimeVal last_caret_update;
23   InfIoTimeout* caret_timeout;
24 };
25 typedef struct _InfTextSessionPrivate InfTextSessionPrivate;
26 struct _InfTextSessionPrivate {
27   guint caret_update_interval;
28   GSList* local_users;
29 };
30 enum {
31   PROP_0,
32   PROP_CARET_UPDATE_INTERVAL
33 };</b></font>
34 typedef struct _InfTextSessionInsertForeachData
35   InfTextSessionInsertForeachData;
36 typedef struct _InfTextSessionEraseForeachData
37   InfTextSessionEraseForeachData;
38 struct _InfTextSessionInsertForeachData {
39   guint position;
40   InfTextChunk* chunk;
41   InfUser* user;
42 };
43 struct _InfTextSessionEraseForeachData {
44   guint position;
45   guint length;
46   InfUser* user;
47 };
48 #define INF_TEXT_SESSION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_TYPE_SESSION, InfTextSessionPrivate))
49 static GQuark inf_text_session_error_quark;
50 G_DEFINE_TYPE_WITH_CODE(InfTextSession, inf_text_session, INF_ADOPTED_TYPE_SESSION,
51   G_ADD_PRIVATE(InfTextSession))
52 static guint
53 inf_text_session_timeval_diff(GTimeVal* first,
54                               GTimeVal* second)
55 {
56   g_assert(first-&gt;tv_sec &gt; second-&gt;tv_sec ||
57            (first-&gt;tv_sec == second-&gt;tv_sec &amp;&amp;
58             first-&gt;tv_usec &gt;= second-&gt;tv_usec));
59   return (first-&gt;tv_sec - second-&gt;tv_sec) * 1000 +
60          (first-&gt;tv_usec+500)/1000 - (second-&gt;tv_usec+500)/1000;
61 }
62 static void
63 inf_text_session_segment_to_xml(GIConv* cd,
64                                 xmlNodePtr xml,
65                                 gconstpointer text,
66                                 gsize* bytes,                                 guint author)
67 {
68   gchar utf8_text[1024];
69   gsize result;
70   gsize bytes_left;
71   gchar* inbuf;
72   gchar* outbuf;
73   bytes_left = 1024;
74   inbuf = *(gchar**)(gpointer)&amp;text;   outbuf = utf8_text;
75   result = g_iconv(
76     *cd,
77     &amp;inbuf,
78     bytes,
79     &amp;outbuf,
80     &amp;bytes_left
81   );
82   g_assert(result == 0 || errno == E2BIG);
83   inf_xml_util_add_child_text(xml, utf8_text, 1024 - bytes_left);
84   inf_xml_util_set_attribute_uint(xml, "author", author);
85 }
86 static gpointer
87 inf_text_session_segment_from_xml(GIConv* cd,
88                                   xmlNodePtr xml,
89                                   guint* length,
90                                   gsize* bytes,
91                                   guint* author,
92                                   GError** error)
93 {
94   gsize bytes_read;
95   gchar* utf8_text;
96   gpointer text;
97   if(!inf_xml_util_get_attribute_uint_required(xml, "author", author, error))
98     return NULL;
99   utf8_text = inf_xml_util_get_child_text(xml, &amp;bytes_read, length, error);
100   if(!utf8_text)
101     return NULL;
102   text = g_convert_with_iconv(
103     utf8_text,
104     bytes_read,
105     *cd,
106     NULL,
107     bytes,
108     error
109   );
110   g_free(utf8_text);
111   return text;
112 }
113 static InfTextSessionLocalUser*
114 inf_text_session_find_local_user(InfTextSession* session,
115                                  InfTextUser* user)
116 {
117   InfTextSessionPrivate* priv;
118   GSList* item;
119   InfTextSessionLocalUser* local;
120   priv = INF_TEXT_SESSION_PRIVATE(session);
121   for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
122   {
123     local = (InfTextSessionLocalUser*)item-&gt;data;
124     if(local-&gt;user == user)
125       return local;
126   }
127   return NULL;
128 }
129 static void
130 inf_text_session_broadcast_caret_selection(InfTextSession* session,
131                                            InfTextSessionLocalUser* local)
132 {
133   InfAdoptedOperation* operation;
134   InfAdoptedAlgorithm* algorithm;
135   InfAdoptedRequest* request;
136   guint buf_len;
137   guint position;
138   int sel;
139   guint end;
140   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
141   position = inf_text_user_get_caret_position(local-&gt;user);
142   sel = inf_text_user_get_selection_length(local-&gt;user);
143   end = position + sel;
144   buf_len = inf_text_buffer_get_length(
145     INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)))
146   );
147   if(position &gt; buf_len)
148     position = buf_len;
149   if(end &gt; buf_len)
150     end = buf_len;
151   if(end &gt;= position)
152     sel = (int)(end - position);
153   else
154     sel = -(int)(position - end);
155   operation = INF_ADOPTED_OPERATION(
156     inf_text_move_operation_new(position, sel)
157   );
158   request = inf_adopted_algorithm_generate_request(
159     algorithm,
160     INF_ADOPTED_REQUEST_DO,
161     INF_ADOPTED_USER(local-&gt;user),
162     operation
163   );
164   inf_adopted_algorithm_execute_request(algorithm, request, FALSE, NULL);
165   g_object_unref(operation);
166   inf_adopted_session_broadcast_request(
167     INF_ADOPTED_SESSION(session),
168     request
169   );
170   g_object_unref(request);
171   g_get_current_time(&amp;local-&gt;last_caret_update);
172   if(local-&gt;caret_timeout != NULL)
173   {
174     inf_io_remove_timeout(
175       inf_adopted_session_get_io(INF_ADOPTED_SESSION(session)),
176       local-&gt;caret_timeout
177     );
178     local-&gt;caret_timeout = NULL;
179   }
180 }
181 static void
182 inf_text_session_caret_update_timeout_func(gpointer user_data)
183 {
184   InfTextSessionLocalUser* local;
185   local = (InfTextSessionLocalUser*)user_data;
186   local-&gt;caret_timeout = NULL;
187   inf_text_session_broadcast_caret_selection(local-&gt;session, local);
188 }
189 static void
190 inf_text_session_selection_changed_cb(InfTextUser* user,
191                                       guint position,
192                                       gint sel,
193                                       gboolean by_request,
194                                       gpointer user_data)
195 {
196   InfTextSession* session;
197   InfTextSessionPrivate* priv;
198   InfAdoptedAlgorithm* algorithm;
199   InfAdoptedRequest* execute_request;
200   InfTextSessionLocalUser* local;
201   GTimeVal current;
202   guint diff;
203   session = INF_TEXT_SESSION(user_data);
204   priv = INF_TEXT_SESSION_PRIVATE(session);
205   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
206   execute_request = inf_adopted_algorithm_get_execute_request(algorithm);
207   g_assert( (execute_request != NULL &amp;&amp; by_request == FALSE) ||
208             (execute_request == NULL &amp;&amp; by_request == TRUE));
209   if(execute_request == NULL)
210   {
211     local = inf_text_session_find_local_user(session, user);
212     g_assert(local != NULL);
213     g_get_current_time(&amp;current);
214     diff = inf_text_session_timeval_diff(&amp;current, &amp;local-&gt;last_caret_update);
215     if(diff &lt; priv-&gt;caret_update_interval)
216     {
217       if(local-&gt;caret_timeout == NULL)
218       {
219         local-&gt;caret_timeout = inf_io_add_timeout(
220           inf_adopted_session_get_io(INF_ADOPTED_SESSION(local-&gt;session)),
221           priv-&gt;caret_update_interval - diff,
222           inf_text_session_caret_update_timeout_func,
223           local,
224           NULL
225         );
226       }
227     }
228     else
229     {
230       inf_text_session_broadcast_caret_selection(session, local);
231     }
232   }
233 }
234 static void
235 inf_text_session_add_local_user(InfTextSession* session,
236                                 InfTextUser* user)
237 {
238   InfTextSessionPrivate* priv;
239   InfTextSessionLocalUser* local;
240   priv = INF_TEXT_SESSION_PRIVATE(session);
241   local = g_slice_new(InfTextSessionLocalUser);
242   local-&gt;session = session;
243   local-&gt;user = user;
244   g_get_current_time(&amp;local-&gt;last_caret_update);
245   local-&gt;caret_timeout = NULL;
246   priv-&gt;local_users = g_slist_prepend(priv-&gt;local_users, local);
247   g_signal_connect_after(
248     G_OBJECT(user),
249     "selection-changed",
250     G_CALLBACK(inf_text_session_selection_changed_cb),
251     session
252   );
253 }
254 static void
255 inf_text_session_remove_local_user(InfTextSession* session,
256                                    InfTextSessionLocalUser* local)
257 {
258   InfTextSessionPrivate* priv;
259   priv = INF_TEXT_SESSION_PRIVATE(session);
260   if(local-&gt;caret_timeout != NULL)
261   {
262     inf_io_remove_timeout(
263       inf_adopted_session_get_io(INF_ADOPTED_SESSION(session)),
264       local-&gt;caret_timeout
265     );
266   }
267   inf_signal_handlers_disconnect_by_func(
268     G_OBJECT(local-&gt;user),
269     G_CALLBACK(inf_text_session_selection_changed_cb),
270     session
271   );
272   g_slice_free(InfTextSessionLocalUser, local);
273   priv-&gt;local_users = g_slist_remove(priv-&gt;local_users, local);
274 }
275 static void
276 inf_text_session_local_user_added_cb(InfUserTable* user_table,
277                                      InfUser* user,
278                                      gpointer user_data)
279 {
280   g_assert(INF_TEXT_IS_USER(user));
281   inf_text_session_add_local_user(
282     INF_TEXT_SESSION(user_data),
283     INF_TEXT_USER(user)
284   );
285 }
286 static void
287 inf_text_session_local_user_removed_cb(InfUserTable* user_table,
288                                        InfUser* user,
289                                        gpointer user_data)
290 {
291   InfTextSession* session;
292   InfTextSessionLocalUser* local;
293   g_assert(INF_TEXT_IS_USER(user));
294   session = INF_TEXT_SESSION(user_data);
295   local = inf_text_session_find_local_user(session, INF_TEXT_USER(user));
296   g_assert(local != NULL);
297   inf_text_session_remove_local_user(session, local);
298 }
299 static void
300 inf_text_session_block_local_users_selection_changed(InfTextSession* session)
301 {
302   InfTextSessionPrivate* priv;
303 <a name="2"></a>  GSList* item;
304   InfTextSessionLocalUser* local;
305 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  priv = INF_TEXT_SESSION_PRIVATE(session);
306   for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
307   {
308     local = (InfTextSessionLocalUser*)item-&gt;data;
309     inf_signal_handlers_block_by_func(
310       G_OBJECT(local-&gt;user),
311       G_CALLBACK(inf_text_session_selection_changed_cb),
312       session
313     );
314   }
315 }
316 static void
317 inf_text_session_unblock_local_users_selection_changed(InfTextSession* sess)
318 {
319   InfTextSessionPrivate* priv;
320   GSList* item;
321   InfTextSessionLocalUser* local;
322 <a name="5"></a>
323   priv = INF_TEXT_SESSION_PRIVATE(sess);</b></font>
324 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
325   {
326     local = (InfTextSessionLocalUser*)item-&gt;data;
327     inf_signal_handlers_unblock_by_func(
328       G_OBJECT(local-&gt;user),
329       G_CALLBACK(inf_text_session_selection_changed_cb),
330       sess
331     );
332   }
333 }
334 static void
335 inf_text_session_buffer_text_inserted_cb_foreach_func(InfUser* user,
336                                                       gpointer user_data)
337 {
338   InfTextSessionInsertForeachData* data;
339   guint position;
340   gint length;
341   data = (InfTextSessionInsertForeachData*)user_data;</b></font>
342   if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
343   {
344     position = inf_text_user_get_caret_position(INF_TEXT_USER(user));
345     length = inf_text_user_get_selection_length(INF_TEXT_USER(user));
346     inf_text_move_operation_transform_insert(
347       data-&gt;position,
348       inf_text_chunk_get_length(data-&gt;chunk),
349       &amp;position,
350       &amp;length,
351       user == data-&gt;user ? FALSE : TRUE
352     );
353     inf_text_user_set_selection(
354       INF_TEXT_USER(user),
355       position,
356       length,
357       user == data-&gt;user ? TRUE : FALSE
358     );
359   }
360 }
361 static void
362 inf_text_session_buffer_text_erased_cb_foreach_func(InfUser* user,
363                                                     gpointer user_data)
364 {
365   InfTextSessionEraseForeachData* data;
366   guint position;
367   gint length;
368   data = (InfTextSessionEraseForeachData*)user_data;
369   if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
370   {
371     position = inf_text_user_get_caret_position(INF_TEXT_USER(user));
372     length = inf_text_user_get_selection_length(INF_TEXT_USER(user));
373     inf_text_move_operation_transform_delete(
374       data-&gt;position,
375       data-&gt;length,
376       &amp;position,
377       &amp;length
378     );
379     inf_text_user_set_selection(
380       INF_TEXT_USER(user),
381       position,
382       length,
383       user == data-&gt;user ? TRUE : FALSE
384     );
385   }
386 }
387 static void
388 inf_text_session_buffer_text_inserted_cb(InfTextBuffer* buffer,
389                                          guint pos,
390                                          InfTextChunk* chunk,
391                                          InfUser* user,
392                                          gpointer user_data)
393 {
394   InfTextSession* session;
395   InfTextSessionPrivate* priv;
396   InfUserTable* user_table;
397   InfAdoptedAlgorithm* algorithm;
398   InfAdoptedRequest* execute_request;
399   InfAdoptedOperation* operation;
400   InfAdoptedRequest* request;
401   InfTextSessionInsertForeachData data;
402   g_assert(INF_TEXT_IS_USER(user));
403   session = INF_TEXT_SESSION(user_data);
404   priv = INF_TEXT_SESSION_PRIVATE(session);
405   user_table = inf_session_get_user_table(INF_SESSION(session));
406   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
407   execute_request = inf_adopted_algorithm_get_execute_request(algorithm);
408   if(execute_request == NULL)
409   {
410     operation = INF_ADOPTED_OPERATION(
411       inf_text_default_insert_operation_new(pos, chunk)
412     );
413     request = inf_adopted_algorithm_generate_request(
414       algorithm,
415       INF_ADOPTED_REQUEST_DO,
416       INF_ADOPTED_USER(user),
417       operation
418     );
419     inf_adopted_algorithm_execute_request(algorithm, request, FALSE, NULL);
420     inf_adopted_session_broadcast_request(
421       INF_ADOPTED_SESSION(session),
422       request
423     );
424     g_object_unref(request);
425     g_object_unref(operation);
426   }
427   data.position = pos;
428   data.chunk = chunk;
429   data.user = user;
430   inf_text_session_block_local_users_selection_changed(session);
431   inf_user_table_foreach_user(
432     user_table,
433     inf_text_session_buffer_text_inserted_cb_foreach_func,
434     &amp;data
435   );
436 #if 0
437   if(user != NULL)
438   {
439     inf_text_user_set_selection(
440       INF_TEXT_USER(user),
441       pos + inf_text_chunk_get_length(chunk),
442       0,
443       TRUE
444     );
445   }
446 #endif
447   inf_text_session_unblock_local_users_selection_changed(session);
448 }
449 static void
450 inf_text_session_buffer_text_erased_cb(InfTextBuffer* buffer,
451                                        guint pos,
452                                        InfTextChunk* chunk,
453                                        InfUser* user,
454                                        gpointer user_data)
455 {
456   InfTextSession* session;
457   InfTextSessionPrivate* priv;
458   InfUserTable* user_table;
459   InfAdoptedAlgorithm* algorithm;
460   InfAdoptedRequest* execute_request;
461   InfAdoptedOperation* operation;
462   InfAdoptedRequest* request;
463   InfTextSessionEraseForeachData data;
464   g_assert(INF_TEXT_IS_USER(user));
465   session = INF_TEXT_SESSION(user_data);
466   priv = INF_TEXT_SESSION_PRIVATE(session);
467   user_table = inf_session_get_user_table(INF_SESSION(session));
468   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
469   execute_request = inf_adopted_algorithm_get_execute_request(algorithm);
470   if(execute_request == NULL)
471   {
472     operation = INF_ADOPTED_OPERATION(
473       inf_text_default_delete_operation_new(pos, chunk)
474     );
475     request = inf_adopted_algorithm_generate_request(
476       algorithm,
477       INF_ADOPTED_REQUEST_DO,
478       INF_ADOPTED_USER(user),
479       operation
480     );
481     inf_adopted_algorithm_execute_request(algorithm, request, FALSE, NULL);
482     inf_adopted_session_broadcast_request(
483       INF_ADOPTED_SESSION(session),
484       request
485     );
486     g_object_unref(request);
487     g_object_unref(operation);
488   }
489   data.position = pos;
490   data.length = inf_text_chunk_get_length(chunk);
491   data.user = user;
492   inf_text_session_block_local_users_selection_changed(session);
493   inf_user_table_foreach_user(
494     user_table,
495     inf_text_session_buffer_text_erased_cb_foreach_func,
496     &amp;data
497   );
498 #if 0
499   if(user != NULL)
500     inf_text_user_set_selection(INF_TEXT_USER(user), pos, 0, TRUE);
501 #endif
502   inf_text_session_unblock_local_users_selection_changed(session);
503 }
504 static void
505 inf_text_session_init_text_handlers_user_foreach_func(InfUser* user,
506                                                       gpointer user_data)
507 {
508   g_assert(INF_TEXT_IS_USER(user));
509   inf_text_session_add_local_user(
510     INF_TEXT_SESSION(user_data),
511     INF_TEXT_USER(user)
512   );
513 }
514 static void
515 inf_text_session_init_text_handlers(InfTextSession* session)
516 {
517   InfTextBuffer* buffer;
518 <a name="0"></a>  InfAdoptedAlgorithm* algorithm;
519   InfUserTable* user_table;
520 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
521   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
522   user_table = inf_session_get_user_table(INF_SESSION(session));
523   g_signal_connect(
524     G_OBJECT(buffer),
525     "text-inserted",
526     G_CALLBACK(inf_text_session_buffer_text_inserted_cb),
527     session
528   );
529   g_signal_connect(
530     G_OBJECT(buffer),
531     "text-erased",
532     G_CALLBACK(inf_text_session_buffer_text_erased_cb),
533     session
534   );
535   g_signal_connect(
536     G_OBJECT(user_table),
537     "add-local-user",
538     G_CALLBACK(inf_text_session_local_user_added_cb),
539     session
540   );
541   g_signal_connect(
542     G_OBJECT(user_table),
543     "remove-local-user",
544     G_CALLBACK(inf_text_session_local_user_removed_cb),
545     session
546   );
547   inf_user_table_foreach_local_user(
548     user_table,
549     inf_text_session_init_text_handlers_user_foreach_func,
550     session
551   );
552 }
553 static void
554 inf_text_session_init(InfTextSession* session)
555 {
556   InfTextSessionPrivate* priv;
557   priv = INF_TEXT_SESSION_PRIVATE(session);
558   priv-&gt;caret_update_interval = 500;
559 }
560 static void
561 inf_text_session_constructed(GObject* object)
562 {
563   InfTextSession* session;
564   InfTextSessionPrivate* priv;
565   InfTextBuffer* buffer;
566   InfSessionStatus status;
567   G_OBJECT_CLASS(inf_text_session_parent_class)-&gt;constructed(object);
568   session = INF_TEXT_SESSION(object);
569   priv = INF_TEXT_SESSION_PRIVATE(session);
570   buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));</b></font>
571   g_object_get(G_OBJECT(session), "status", &amp;status, NULL);
572   g_assert(
573     status == INF_SESSION_RUNNING ||
574     inf_text_buffer_get_length(buffer) == 0
575   );
576   if(status == INF_SESSION_RUNNING)
577     inf_text_session_init_text_handlers(session);
578 }
579 static void
580 inf_text_session_dispose(GObject* object)
581 {
582   InfTextSession* session;
583   InfTextSessionPrivate* priv;
584   InfTextBuffer* buffer;
585   InfUserTable* user_table;
586   InfAdoptedAlgorithm* algorithm;
587   session = INF_TEXT_SESSION(object);
588   priv = INF_TEXT_SESSION_PRIVATE(session);
589   buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
590   user_table = inf_session_get_user_table(INF_SESSION(session));
591   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
592   while(priv-&gt;local_users != NULL)
593   {
594     inf_text_session_remove_local_user(
595       session,
596       (InfTextSessionLocalUser*)priv-&gt;local_users-&gt;data
597     );
598   }
599   inf_signal_handlers_disconnect_by_func(
600     G_OBJECT(buffer),
601     G_CALLBACK(inf_text_session_buffer_text_inserted_cb),
602     session
603   );
604   inf_signal_handlers_disconnect_by_func(
605     G_OBJECT(buffer),
606     G_CALLBACK(inf_text_session_buffer_text_erased_cb),
607     session
608   );
609   inf_signal_handlers_disconnect_by_func(
610     G_OBJECT(user_table),
611     G_CALLBACK(inf_text_session_local_user_added_cb),
612     session
613   );
614   inf_signal_handlers_disconnect_by_func(
615     G_OBJECT(user_table),
616     G_CALLBACK(inf_text_session_local_user_removed_cb),
617     session
618   );
619   G_OBJECT_CLASS(inf_text_session_parent_class)-&gt;dispose(object);
620 }
621 static void
622 inf_text_session_finalize(GObject* object)
623 {
624   InfTextSession* session;
625   InfTextSessionPrivate* priv;
626   session = INF_TEXT_SESSION(object);
627   priv = INF_TEXT_SESSION_PRIVATE(session);
628   G_OBJECT_CLASS(inf_text_session_parent_class)-&gt;finalize(object);
629 }
630 static void
631 inf_text_session_set_property(GObject* object,
632                               guint prop_id,
633                               const GValue* value,
634                               GParamSpec* pspec)
635 {
636   InfTextSession* session;
637   InfTextSessionPrivate* priv;
638   session = INF_TEXT_SESSION(object);
639   priv = INF_TEXT_SESSION_PRIVATE(session);
640   switch(prop_id)
641 <a name="1"></a>  {
642   case PROP_CARET_UPDATE_INTERVAL:
643     priv-&gt;caret_update_interval = g_value_get_uint(value);
644 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
645   default:
646     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
647     break;
648   }
649 }
650 static void
651 inf_text_session_get_property(GObject* object,
652                               guint prop_id,
653                               GValue* value,
654                               GParamSpec* pspec)
655 {
656   InfTextSession* session;
657   InfTextSessionPrivate* priv;
658   session = INF_TEXT_SESSION(object);
659   priv = INF_TEXT_SESSION_PRIVATE(session);
660   switch(prop_id)
661   {
662   case PROP_CARET_UPDATE_INTERVAL:
663     g_value_set_uint(value, priv-&gt;caret_update_interval);
664     break;</b></font>
665   default:
666     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
667     break;
668   }
669 }
670 static InfCommunicationScope
671 inf_text_session_handle_user_color_change(InfTextSession* session,
672                                           InfXmlConnection* connection,
673                                           xmlNodePtr xml,
674                                           GError** error)
675 {
676   InfUserTable* user_table;
677   guint user_id;
678   InfUser* user;
679   gdouble hue;
680   user_table = inf_session_get_user_table(INF_SESSION(session));
681   if(!inf_xml_util_get_attribute_uint_required(xml, "id", &amp;user_id, error))
682     return INF_COMMUNICATION_SCOPE_PTP;
683   if(!inf_xml_util_get_attribute_double_required(xml, "hue", &amp;hue, error))
684     return INF_COMMUNICATION_SCOPE_PTP;
685   user = inf_user_table_lookup_user_by_id(user_table, user_id);
686   if(user == NULL)
687   {
688     g_set_error(
689       error,
690       inf_user_error_quark(),
691       INF_USER_ERROR_NO_SUCH_USER,
692       _("No such user with ID '%u'"),
693       user_id
694     );
695     return INF_COMMUNICATION_SCOPE_PTP;
696   }
697   if(inf_user_get_status(user) == INF_USER_UNAVAILABLE ||
698      inf_user_get_connection(user) != connection)
699   {
700     g_set_error_literal(
701       error,
702       inf_user_error_quark(),
703       INF_USER_ERROR_NOT_JOINED,
704       _("User did not join from this connection")
705     );
706     return INF_COMMUNICATION_SCOPE_PTP;
707   }
708   g_assert(INF_TEXT_IS_USER(user));
709   if(hue &lt; 0.0 || hue &gt; 1.0)
710   {
711     g_set_error(
712       error,
713       inf_text_session_error_quark,
714       INF_TEXT_SESSION_ERROR_INVALID_HUE,
715       _("Invalid hue value: '%g'"),
716       hue
717     );
718     return INF_COMMUNICATION_SCOPE_PTP;
719   }
720   g_object_set(G_OBJECT(user), "hue", hue, NULL);
721   return INF_COMMUNICATION_SCOPE_GROUP;
722 }
723 static void
724 inf_text_session_to_xml_sync(InfSession* session,
725                              xmlNodePtr parent)
726 {
727   InfTextBuffer* buffer;
728   InfTextBufferIter* iter;
729   xmlNodePtr xml;
730   gboolean result;
731   gchar* text;
732   gsize total_bytes;
733   gsize bytes_left;
734   GIConv cd;
735   INF_SESSION_CLASS(inf_text_session_parent_class)-&gt;to_xml_sync(
736     session,
737     parent
738   );
739   buffer = INF_TEXT_BUFFER(inf_session_get_buffer(session));
740   cd = g_iconv_open("UTF-8", inf_text_buffer_get_encoding(buffer));
741   iter = inf_text_buffer_create_begin_iter(buffer);
742   if(iter != NULL)
743   {
744     result = TRUE;
745     while(result == TRUE)
746     {
747       text = inf_text_buffer_iter_get_text(buffer, iter);
748       total_bytes = inf_text_buffer_iter_get_bytes(buffer, iter);
749       bytes_left = total_bytes;
750       while(bytes_left &gt; 0)
751       {
752         xml = xmlNewChild(parent, NULL, (const xmlChar*)"sync-segment", NULL);
753         inf_text_session_segment_to_xml(
754           &amp;cd,
755           xml,
756           text + total_bytes - bytes_left,
757           &amp;bytes_left,
758           inf_text_buffer_iter_get_author(buffer, iter)
759         );
760       }
761       g_free(text);
762       result = inf_text_buffer_iter_next(buffer, iter);
763     }
764     inf_text_buffer_destroy_iter(buffer, iter);
765   }
766   g_iconv_close(cd);
767 }
768 static gboolean
769 inf_text_session_process_xml_sync(InfSession* session,
770                                   InfXmlConnection* connection,
771                                   const xmlNodePtr xml,
772                                   GError** error)
773 {
774   InfTextBuffer* buffer;
775   GIConv cd;
776   gpointer text;
777   gsize bytes;
778   guint length;
779   guint author;
780   InfUser* user;
781   if(strcmp((const char*)xml-&gt;name, "sync-segment") == 0)
782   {
783     buffer = INF_TEXT_BUFFER(inf_session_get_buffer(session));
784     cd = g_iconv_open(inf_text_buffer_get_encoding(buffer), "UTF-8");
785     text = inf_text_session_segment_from_xml(
786       &amp;cd,
787       xml,
788       &amp;length,
789       &amp;bytes,
790       &amp;author,
791       error
792     );
793     g_iconv_close(cd);
794     if(text == NULL) return FALSE;
795     if(author != 0)
796     {
797       user = inf_user_table_lookup_user_by_id(
798         inf_session_get_user_table(session),
799         author
800       );
801       if(user == NULL)
802       {
803         g_free(text);
804         g_set_error(
805           error,
806           inf_user_error_quark(),
807           INF_USER_ERROR_NO_SUCH_USER,
808           _("No such user with ID '%u'"),
809           author
810         );
811         return FALSE;
812       }
813     }
814     else
815     {
816       user = NULL;
817     }
818     inf_text_buffer_insert_text(
819       buffer,
820       inf_text_buffer_get_length(buffer),
821       text,
822       bytes,
823       length,
824       user
825     );
826     g_free(text);
827     return TRUE;
828   }
829   else
830   {
831     return INF_SESSION_CLASS(inf_text_session_parent_class)-&gt;process_xml_sync(
832       session,
833       connection,
834       xml,
835       error
836     );
837   }
838 }
839 static InfCommunicationScope
840 inf_text_session_process_xml_run(InfSession* session,
841                                  InfXmlConnection* connection,
842                                  const xmlNodePtr xml,
843                                  GError** error)
844 {
845   if(strcmp((const char*)xml-&gt;name, "user-color-change") == 0)
846   {
847     return inf_text_session_handle_user_color_change(
848       INF_TEXT_SESSION(session),
849       connection,
850       xml,
851       error
852     );
853   }
854   else
855   {
856     return INF_SESSION_CLASS(inf_text_session_parent_class)-&gt;process_xml_run(
857       session,
858       connection,
859       xml,
860       error
861     );
862   }
863 }
864 static GArray*
865 inf_text_session_get_xml_user_props(InfSession* session,
866                                     InfXmlConnection* connection,
867                                     const xmlNodePtr xml)
868 {
869   InfSessionClass* parent_class;
870   GArray* array;
871   GParameter* parameter;
872   guint caret;
873   gint selection;
874   gdouble hue;
875   parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
876   array = parent_class-&gt;get_xml_user_props(session, connection, xml);
877   if(inf_xml_util_get_attribute_uint(xml, "caret", &amp;caret, NULL))
878   {
879     parameter = inf_session_get_user_property(array, "caret-position");
880     g_value_init(&amp;parameter-&gt;value, G_TYPE_UINT);
881     g_value_set_uint(&amp;parameter-&gt;value, caret);
882   }
883   parameter = inf_session_get_user_property(array, "selection-length");
884   g_value_init(&amp;parameter-&gt;value, G_TYPE_INT);
885   if(inf_xml_util_get_attribute_int(xml, "selection", &amp;selection, NULL))
886     g_value_set_int(&amp;parameter-&gt;value, selection);
887   else
888     g_value_set_int(&amp;parameter-&gt;value, 0);
889   parameter = inf_session_get_user_property(array, "hue");
890   g_value_init(&amp;parameter-&gt;value, G_TYPE_DOUBLE);
891   if(inf_xml_util_get_attribute_double(xml, "hue", &amp;hue, NULL))
892     g_value_set_double(&amp;parameter-&gt;value, hue);
893   else
894     g_value_set_double(&amp;parameter-&gt;value, g_random_double());
895   return array;
896 }
897 static void
898 inf_text_session_set_xml_user_props(InfSession* session,
899                                     const GParameter* params,
900                                     guint n_params,
901                                     xmlNodePtr xml)
902 {
903   InfSessionClass* parent_class;
904   const GParameter* param;
905   parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
906   parent_class-&gt;set_xml_user_props(session, params, n_params, xml);
907   param = inf_session_lookup_user_property(
908     params,
909     n_params,
910     "caret-position"
911   );
912   if(param != NULL)
913   {
914     inf_xml_util_set_attribute_uint(
915       xml,
916       "caret",
917       g_value_get_uint(&amp;param-&gt;value)
918 <a name="4"></a>    );
919   }
920 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  param = inf_session_lookup_user_property(
921     params,
922     n_params,
923     "selection-length"
924   );
925   if(param != NULL)
926   {
927     inf_xml_util_set_attribute_int(
928       xml,
929       "selection",
930       g_value_get_int(&amp;param-&gt;value)
931     );
932   }
933   param = inf_session_lookup_user_property(
934     params,
935     n_params,
936     "hue"
937   );
938   if(param != NULL)
939   {
940     inf_xml_util_set_attribute_double(
941       xml,
942       "hue",
943       g_value_get_double(&amp;param-&gt;value)
944     );
945   }
946 }
947 static gboolean</b></font>
948 inf_text_session_validate_user_props(InfSession* session,
949                                      const GParameter* params,
950                                      guint n_params,
951                                      InfUser* exclude,
952                                      GError** error)
953 {
954   InfSessionClass* parent_class;
955   const GParameter* caret;
956   gboolean result;
957   parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
958   result = parent_class-&gt;validate_user_props(
959     session,
960     params,
961     n_params,
962     exclude,
963     error
964   );
965   if(result == FALSE) return FALSE;
966   caret = inf_session_lookup_user_property(
967     params,
968     n_params,
969     "caret-position"
970   );
971   if(caret == NULL)
972   {
973     g_set_error_literal(
974       error,
975       inf_request_error_quark(),
976       INF_REQUEST_ERROR_NO_SUCH_ATTRIBUTE,
977       _("\"caret\" attribute in user message is missing")
978     );
979     return FALSE;
980   }
981   return result;
982 }
983 static InfUser*
984 inf_text_session_user_new(InfSession* session,
985                           GParameter* params,
986                           guint n_params)
987 {
988   GObject* object;
989   object = g_object_newv(INF_TEXT_TYPE_USER, n_params, params);
990   return INF_USER(object);
991 }
992 static void
993 inf_text_session_synchronization_complete(InfSession* session,
994                                           InfXmlConnection* connection)
995 {
996   InfSessionClass* parent_class;
997   InfSessionStatus status;
998   parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
999   status = inf_session_get_status(session);
1000   parent_class-&gt;synchronization_complete(session, connection);
1001   if(status == INF_SESSION_SYNCHRONIZING)
1002     inf_text_session_init_text_handlers(INF_TEXT_SESSION(session));
1003 }
1004 static void
1005 inf_text_session_request_to_xml(InfAdoptedSession* session,
1006                                 xmlNodePtr xml,
1007                                 InfAdoptedRequest* request,
1008                                 InfAdoptedStateVector* diff_vec,
1009                                 gboolean for_sync)
1010 {
1011   InfTextChunk* chunk;
1012   InfTextChunkIter iter;
1013   gboolean result;
1014   xmlNodePtr op_xml;
1015   gchar* utf8_text;
1016   gsize bytes_read;
1017   gsize bytes_written;
1018   GIConv cd;
1019   xmlNodePtr child;
1020   const gchar* text;
1021   gsize total_bytes;
1022   gsize bytes_left;
1023   InfAdoptedOperation* operation;
1024   switch(inf_adopted_request_get_request_type(request))
1025   {
1026   case INF_ADOPTED_REQUEST_DO:
1027     operation = inf_adopted_request_get_operation(request);
1028     if(INF_TEXT_IS_INSERT_OPERATION(operation))
1029     {
1030       op_xml = xmlNewNode(NULL, (const xmlChar*)"insert-caret");
1031       inf_xml_util_set_attribute_uint(
1032         op_xml,
1033         "pos",
1034         inf_text_insert_operation_get_position(
1035           INF_TEXT_INSERT_OPERATION(operation)
1036         )
1037       );
1038       g_assert(INF_TEXT_IS_DEFAULT_INSERT_OPERATION(operation));
1039       chunk = inf_text_default_insert_operation_get_chunk(
1040         INF_TEXT_DEFAULT_INSERT_OPERATION(operation)
1041       );
1042       result = inf_text_chunk_iter_init_begin(chunk, &amp;iter);
1043       g_assert(result == TRUE);
1044       utf8_text = g_convert(
1045         inf_text_chunk_iter_get_text(&amp;iter),
1046         inf_text_chunk_iter_get_bytes(&amp;iter),
1047         "UTF-8",
1048         inf_text_chunk_get_encoding(chunk),
1049         &amp;bytes_read,
1050         &amp;bytes_written,
1051         NULL
1052       );
1053       g_assert(utf8_text != NULL);
1054       g_assert(bytes_read == inf_text_chunk_iter_get_bytes(&amp;iter));
1055       inf_xml_util_add_child_text(op_xml, utf8_text, bytes_written);
1056       g_free(utf8_text);
1057       g_assert(inf_text_chunk_iter_next(&amp;iter) == FALSE);
1058     }
1059     else if(INF_TEXT_IS_DELETE_OPERATION(operation))
1060     {
1061       op_xml = xmlNewNode(NULL, (const xmlChar*)"delete-caret");
1062       inf_xml_util_set_attribute_uint(
1063         op_xml,
1064         "pos",
1065         inf_text_delete_operation_get_position(
1066           INF_TEXT_DELETE_OPERATION(operation)
1067         )
1068       );
1069       if(for_sync == TRUE)
1070       {
1071         g_assert(INF_TEXT_IS_DEFAULT_DELETE_OPERATION(operation));
1072         chunk = inf_text_default_delete_operation_get_chunk(
1073           INF_TEXT_DEFAULT_DELETE_OPERATION(operation)
1074         );
1075         cd = g_iconv_open("UTF-8", inf_text_chunk_get_encoding(chunk));
1076         result = inf_text_chunk_iter_init_begin(chunk, &amp;iter);
1077         while(result == TRUE)
1078         {
1079           text = inf_text_chunk_iter_get_text(&amp;iter);
1080           total_bytes = inf_text_chunk_iter_get_bytes(&amp;iter);
1081           bytes_left = total_bytes;
1082           child = xmlNewChild(op_xml, NULL, (const xmlChar*)"segment", NULL);
1083           while(bytes_left &gt; 0)
1084           {
1085             inf_text_session_segment_to_xml(
1086               &amp;cd,
1087               child,
1088               text + total_bytes - bytes_left,
1089               &amp;bytes_left,
1090               inf_text_chunk_iter_get_author(&amp;iter)
1091             );
1092           }
1093           result = inf_text_chunk_iter_next(&amp;iter);
1094         }
1095         g_iconv_close(cd);
1096       }
1097       else
1098       {
1099         inf_xml_util_set_attribute_uint(
1100           op_xml,
1101           "len",
1102           inf_text_delete_operation_get_length(
1103             INF_TEXT_DELETE_OPERATION(operation)
1104           )
1105         );
1106       }
1107     }
1108     else if(for_sync == FALSE &amp;&amp; INF_TEXT_IS_MOVE_OPERATION(operation))
1109     {
1110       op_xml = xmlNewNode(NULL, (const xmlChar*)"move");
1111       inf_xml_util_set_attribute_uint(
1112         op_xml,
1113         "caret",
1114         inf_text_move_operation_get_position(
1115           INF_TEXT_MOVE_OPERATION(operation)
1116         )
1117       );
1118       inf_xml_util_set_attribute_int(
1119         op_xml,
1120         "selection",
1121         inf_text_move_operation_get_length(INF_TEXT_MOVE_OPERATION(operation))
1122       );
1123     }
1124     else if(for_sync == FALSE &amp;&amp; INF_ADOPTED_IS_NO_OPERATION(operation))
1125     {
1126       op_xml = xmlNewNode(NULL, (const xmlChar*)"no-op");
1127     }
1128     else
1129     {
1130       g_assert_not_reached();
1131     }
1132     break;
1133   case INF_ADOPTED_REQUEST_UNDO:
1134     op_xml = xmlNewNode(NULL, (const xmlChar*)"undo-caret");
1135     break;
1136   case INF_ADOPTED_REQUEST_REDO:
1137     op_xml = xmlNewNode(NULL, (const xmlChar*)"redo-caret");
1138     break;
1139   default:
1140     g_assert_not_reached();
1141     break;
1142   }
1143   g_assert(op_xml != NULL);
1144   inf_adopted_session_write_request_info(
1145     session,
1146     request,
1147     diff_vec,
1148     xml,
1149     op_xml
1150   );
1151 }
1152 static InfAdoptedRequest*
1153 inf_text_session_xml_to_request(InfAdoptedSession* session,
1154                                 xmlNodePtr xml,
1155                                 InfAdoptedStateVector* diff_vec,
1156                                 gboolean for_sync,
1157                                 GError** error)
1158 {
1159   InfTextBuffer* buffer;
1160   InfAdoptedUser* user;
1161   guint user_id;
1162   InfAdoptedStateVector* vector;
1163   xmlNodePtr op_xml;
1164   InfAdoptedOperation* operation;
1165   InfAdoptedRequestType type;
1166   InfAdoptedRequest* request;
1167   guint pos;
1168   gchar* text;
1169   gsize bytes;
1170   InfTextChunk* chunk;
1171   gchar* utf8_text;
1172   gsize in_bytes;
1173   guint length;
1174   xmlNodePtr child;
1175   GIConv cd;
1176   guint author;
1177   gboolean cmp;
1178   gint selection;
1179   buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
1180   cmp = inf_adopted_session_read_request_info(
1181     session,
1182     xml,
1183     diff_vec,
1184     &amp;user,
1185     &amp;vector,
1186     &amp;op_xml,
1187     error
1188   );
1189   if(cmp == FALSE) return FALSE;
1190   user_id = (user == NULL) ? 0 : inf_user_get_id(INF_USER(user));
1191   if(strcmp((const char*)op_xml-&gt;name, "insert") == 0 ||
1192      strcmp((const char*)op_xml-&gt;name, "insert-caret") == 0)
1193   {
1194     type = INF_ADOPTED_REQUEST_DO;
1195     if(!inf_xml_util_get_attribute_uint_required(op_xml, "pos", &amp;pos, error))
1196       goto fail;
1197     utf8_text = inf_xml_util_get_child_text(op_xml, &amp;in_bytes, &amp;length, error);
1198     if(!utf8_text)
1199       goto fail;
1200     text = g_convert(
1201       utf8_text,
1202       in_bytes,
1203       inf_text_buffer_get_encoding(buffer),
1204       "UTF-8",
1205       NULL,
1206       &amp;bytes,
1207       error
1208     );
1209     g_free(utf8_text);
1210     if(text == NULL) goto fail;
1211     chunk = inf_text_chunk_new(inf_text_buffer_get_encoding(buffer));
1212     inf_text_chunk_insert_text(chunk, 0, text, bytes, length, user_id);
1213     g_free(text);
1214     operation = INF_ADOPTED_OPERATION(
1215       inf_text_default_insert_operation_new(pos, chunk)
1216     );
1217     inf_text_chunk_free(chunk);
1218   }
1219   else if(strcmp((const char*)op_xml-&gt;name, "delete") == 0 ||
1220           strcmp((const char*)op_xml-&gt;name, "delete-caret") == 0)
1221   {
1222     type = INF_ADOPTED_REQUEST_DO;
1223     if(!inf_xml_util_get_attribute_uint_required(op_xml, "pos", &amp;pos, error))
1224       goto fail;
1225     if(for_sync == TRUE)
1226     {
1227       chunk = inf_text_chunk_new(inf_text_buffer_get_encoding(buffer));
1228       cd = g_iconv_open(inf_text_buffer_get_encoding(buffer), "UTF-8");
1229       g_assert(cd != (GIConv)(-1));
1230       for(child = op_xml-&gt;children; child != NULL; child = child-&gt;next)
1231       {
1232         if(strcmp((const char*)child-&gt;name, "segment") == 0)
1233         {
1234           text = inf_text_session_segment_from_xml(
1235             &amp;cd,
1236             child,
1237             &amp;length,
1238             &amp;bytes,
1239             &amp;author,
1240             error
1241           );
1242           if(text == NULL)
1243           {
1244             inf_text_chunk_free(chunk);
1245             g_iconv_close(cd);
1246             goto fail;
1247           }
1248           else
1249           {
1250             inf_text_chunk_insert_text(
1251               chunk,
1252               inf_text_chunk_get_length(chunk),
1253               text,
1254               bytes,
1255               length,
1256               author
1257             );
1258             g_free(text);
1259           }
1260         }
1261         else
1262         {
1263         }
1264       }
1265       g_iconv_close(cd);
1266       operation = INF_ADOPTED_OPERATION(
1267         inf_text_default_delete_operation_new(pos, chunk)
1268       );
1269       inf_text_chunk_free(chunk);
1270     }
1271     else
1272     {
1273       cmp = inf_xml_util_get_attribute_uint_required(
1274         op_xml,
1275         "len",
1276         &amp;length,
1277         error
1278       );
1279       if(cmp == FALSE) goto fail;
1280       operation = INF_ADOPTED_OPERATION(
1281         inf_text_remote_delete_operation_new(pos, length)
1282       );
1283     }
1284   }
1285   else if(strcmp((const char*)op_xml-&gt;name, "move") == 0)
1286   {
1287     type = INF_ADOPTED_REQUEST_DO;
1288     cmp = inf_xml_util_get_attribute_uint_required(
1289       op_xml,
1290       "caret",
1291       &amp;pos,
1292       error
1293     );
1294     if(cmp == FALSE) goto fail;
1295     cmp = inf_xml_util_get_attribute_int_required(
1296       op_xml,
1297       "selection",
1298       &amp;selection,
1299       error
1300     );
1301     if(cmp == FALSE) goto fail;
1302     operation = INF_ADOPTED_OPERATION(
1303       inf_text_move_operation_new(pos, selection)
1304     );
1305   }
1306   else if(strcmp((const char*)op_xml-&gt;name, "no-op") == 0)
1307   {
1308     type = INF_ADOPTED_REQUEST_DO;
1309     operation = INF_ADOPTED_OPERATION(inf_adopted_no_operation_new());
1310   }
1311   else if(strcmp((const char*)op_xml-&gt;name, "undo") == 0 ||
1312           strcmp((const char*)op_xml-&gt;name, "undo-caret") == 0)
1313   {
1314     type = INF_ADOPTED_REQUEST_UNDO;
1315   }
1316   else if(strcmp((const char*)op_xml-&gt;name, "redo") == 0 ||
1317           strcmp((const char*)op_xml-&gt;name, "redo-caret") == 0)
1318   {
1319     type = INF_ADOPTED_REQUEST_REDO;
1320   }
1321   else
1322   {
1323     goto fail;
1324   }
1325   switch(type)
1326   {
1327   case INF_ADOPTED_REQUEST_DO:
1328     g_assert(operation != NULL);
1329     request = inf_adopted_request_new_do(
1330       vector,
1331       user_id,
1332       operation,
1333       g_get_real_time()
1334     );
1335     g_object_unref(operation);
1336     break;
1337   case INF_ADOPTED_REQUEST_UNDO:
1338     request = inf_adopted_request_new_undo(
1339       vector,
1340       user_id,
1341       g_get_real_time()
1342     );
1343     break;
1344   case INF_ADOPTED_REQUEST_REDO:
1345     request = inf_adopted_request_new_redo(
1346       vector,
1347       user_id,
1348       g_get_real_time()
1349     );
1350     break;
1351   default:
1352     g_assert_not_reached();
1353     break;
1354   }
1355   inf_adopted_state_vector_free(vector);
1356   return request;
1357 fail:
1358   inf_adopted_state_vector_free(vector);
1359   return NULL;
1360 }
1361 static void
1362 inf_text_session_class_init(InfTextSessionClass* text_session_class)
1363 {
1364   GObjectClass* object_class;
1365   InfSessionClass* session_class;
1366   InfAdoptedSessionClass* adopted_session_class;
1367   object_class = G_OBJECT_CLASS(text_session_class);
1368   session_class = INF_SESSION_CLASS(text_session_class);
1369   adopted_session_class = INF_ADOPTED_SESSION_CLASS(text_session_class);
1370   object_class-&gt;constructed = inf_text_session_constructed;
1371   object_class-&gt;dispose = inf_text_session_dispose;
1372   object_class-&gt;finalize = inf_text_session_finalize;
1373   object_class-&gt;set_property = inf_text_session_set_property;
1374   object_class-&gt;get_property = inf_text_session_get_property;
1375   session_class-&gt;to_xml_sync = inf_text_session_to_xml_sync;
1376   session_class-&gt;process_xml_sync = inf_text_session_process_xml_sync;
1377   session_class-&gt;process_xml_run = inf_text_session_process_xml_run;
1378   session_class-&gt;get_xml_user_props = inf_text_session_get_xml_user_props;
1379   session_class-&gt;set_xml_user_props = inf_text_session_set_xml_user_props;
1380   session_class-&gt;validate_user_props = inf_text_session_validate_user_props;
1381   session_class-&gt;user_new = inf_text_session_user_new;
1382   session_class-&gt;synchronization_complete =
1383     inf_text_session_synchronization_complete;
1384   adopted_session_class-&gt;xml_to_request = inf_text_session_xml_to_request;
1385   adopted_session_class-&gt;request_to_xml = inf_text_session_request_to_xml;
1386   inf_text_session_error_quark = g_quark_from_static_string(
1387     "INF_TEXT_SESSION_ERROR"
1388   );
1389   g_object_class_install_property(
1390     object_class,
1391     PROP_CARET_UPDATE_INTERVAL,
1392     g_param_spec_uint(
1393       "caret-update-interval",
1394       "Caret update interval",
1395       "Minimum number of milliseconds between caret update broadcasts",
1396       0,
1397       G_MAXUINT,
1398       500,
1399       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
1400     )
1401   );
1402 }
1403 InfTextSession*
1404 inf_text_session_new(InfCommunicationManager* manager,
1405                      InfTextBuffer* buffer,
1406                      InfIo* io,
1407                      InfSessionStatus status,
1408                      InfCommunicationGroup* sync_group,
1409                      InfXmlConnection* sync_connection)
1410 {
1411   GObject* object;
1412   g_return_val_if_fail(INF_COMMUNICATION_IS_MANAGER(manager), NULL);
1413   g_return_val_if_fail(INF_TEXT_IS_BUFFER(buffer), NULL);
1414   g_return_val_if_fail(INF_IS_IO(io), NULL);
1415   g_return_val_if_fail(
1416     (status == INF_SESSION_RUNNING &amp;&amp;
1417      sync_group == NULL &amp;&amp; sync_connection == NULL) ||
1418     (status != INF_SESSION_RUNNING &amp;&amp;
1419      INF_COMMUNICATION_IS_GROUP(sync_group) &amp;&amp;
1420      INF_IS_XML_CONNECTION(sync_connection)),
1421     NULL
1422   );
1423   object = g_object_new(
1424     INF_TEXT_TYPE_SESSION,
1425     "communication-manager", manager,
1426     "buffer", buffer,
1427     "status", status,
1428     "sync-group", sync_group,
1429     "sync-connection", sync_connection,
1430     "io", io,
1431     NULL
1432   );
1433   return INF_TEXT_SESSION(object);
1434 }
1435 InfTextSession*
1436 inf_text_session_new_with_user_table(InfCommunicationManager* manager,
1437                                      InfTextBuffer* buffer,
1438                                      InfIo* io,
1439                                      InfUserTable* user_table,
1440                                      InfSessionStatus status,
1441                                      InfCommunicationGroup* sync_group,
1442                                      InfXmlConnection* sync_connection)
1443 {
1444   GObject* object;
1445   g_return_val_if_fail(INF_COMMUNICATION_IS_MANAGER(manager), NULL);
1446   g_return_val_if_fail(INF_TEXT_IS_BUFFER(buffer), NULL);
1447   g_return_val_if_fail(INF_IS_IO(io), NULL);
1448   g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);
1449   g_return_val_if_fail(
1450     (status == INF_SESSION_RUNNING &amp;&amp;
1451      sync_group == NULL &amp;&amp; sync_connection == NULL) ||
1452     (status != INF_SESSION_RUNNING &amp;&amp;
1453      INF_COMMUNICATION_IS_GROUP(sync_group) &amp;&amp;
1454      INF_IS_XML_CONNECTION(sync_connection)),
1455     NULL
1456   );
1457   object = g_object_new(
1458     INF_TEXT_TYPE_SESSION,
1459     "communication-manager", manager,
1460     "buffer", buffer,
1461     "user-table", user_table,
1462     "status", status,
1463     "sync-group", sync_group,
1464     "sync-connection", sync_connection,
1465     "io", io,
1466     NULL
1467   );
1468   return INF_TEXT_SESSION(object);
1469 }
1470 void
1471 inf_text_session_set_user_color(InfTextSession* session,
1472                                 InfTextUser* user,
1473                                 gdouble hue)
1474 {
1475   xmlNodePtr xml;
1476   g_return_if_fail(INF_TEXT_IS_SESSION(session));
1477   g_return_if_fail(INF_TEXT_IS_USER(user));
1478   g_return_if_fail(hue &gt;= 0.0 &amp;&amp; hue &lt;= 1.0);
1479   g_return_if_fail(
1480     inf_user_get_status(INF_USER(user)) != INF_USER_UNAVAILABLE
1481   );
1482   g_return_if_fail(
1483     (inf_user_get_flags(INF_USER(user)) &amp; INF_USER_LOCAL) != 0
1484   );
1485   xml = xmlNewNode(NULL, (const xmlChar*)"user-color-change");
1486   inf_xml_util_set_attribute_uint(xml, "id", inf_user_get_id(INF_USER(user)));
1487   inf_xml_util_set_attribute_double(xml, "hue", hue);
1488   inf_session_send_to_subscriptions(INF_SESSION(session), xml);
1489   g_object_set(G_OBJECT(user), "hue", hue, NULL);
1490 }
1491 void
1492 inf_text_session_flush_requests_for_user(InfTextSession* session,
1493                                          InfTextUser* user)
1494 {
1495   InfTextSessionLocalUser* local;
1496   g_return_if_fail(INF_TEXT_IS_SESSION(session));
1497   g_return_if_fail(INF_TEXT_IS_USER(user));
1498   local = inf_text_session_find_local_user(session, user);
1499   g_assert(local != NULL);
1500   if(local-&gt;caret_timeout != NULL)
1501   {
1502     inf_text_session_broadcast_caret_selection(session, local);
1503   }
1504 }
1505 InfRequest*
1506 inf_text_session_join_user(InfSessionProxy* proxy,
1507                            const gchar* name,
1508                            InfUserStatus status,
1509                            gdouble hue,
1510                            guint caret_position,
1511                            int selection_length,
1512                            InfRequestFunc func,
1513                            gpointer user_data)
1514 {
1515 #define N_PARAMS 6u
1516   GParameter params[N_PARAMS] = {
1517     { "hue", { 0 } },
1518     { "vector", { 0 } },
1519     { "caret-position", { 0 } },
1520     { "selection-length", { 0 } },
1521     { "name", { 0 } },
1522     { "status", { 0 } }
1523   };
1524   InfSession* session;
1525   InfRequest* request;
1526   guint i;
1527   g_return_val_if_fail(INF_IS_SESSION_PROXY(proxy), NULL);
1528   g_object_get(G_OBJECT(proxy), "session", &amp;session, NULL);
1529   g_return_val_if_fail(INF_TEXT_IS_SESSION(session), NULL);
1530   g_value_init(&amp;params[0].value, G_TYPE_DOUBLE);
1531   g_value_set_double(&amp;params[0].value, hue);
1532   g_value_init(&amp;params[1].value, INF_ADOPTED_TYPE_STATE_VECTOR);
1533   g_value_set_boxed(
1534     &amp;params[1].value,
1535     inf_adopted_algorithm_get_current(
1536       inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session))
1537     )
1538   );
1539   g_value_init(&amp;params[2].value, G_TYPE_UINT);
1540   g_value_set_uint(&amp;params[2].value, caret_position);
1541   g_value_init(&amp;params[3].value, G_TYPE_INT);
1542   g_value_set_int(&amp;params[3].value, selection_length);
1543   g_value_init(&amp;params[4].value, G_TYPE_STRING);
1544   g_value_set_string(&amp;params[4].value, name); 
1545   g_value_init(&amp;params[5].value, INF_TYPE_USER_STATUS);
1546   g_value_set_enum(&amp;params[5].value, status);
1547   request = inf_session_proxy_join_user(
1548     proxy,
1549     N_PARAMS,
1550     params,
1551     func,
1552     user_data
1553   );
1554   for(i = 0; i &lt; N_PARAMS; ++i)
1555     g_value_unset(&amp;params[i].value);
1556 #undef N_PARAMS
1557   g_object_unref(session);
1558   return request;
1559 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
