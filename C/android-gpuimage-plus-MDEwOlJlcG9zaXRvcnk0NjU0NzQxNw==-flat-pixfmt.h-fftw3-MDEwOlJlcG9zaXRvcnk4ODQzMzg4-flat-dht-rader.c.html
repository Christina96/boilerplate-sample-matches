
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 14.325068870523417%, Tokens: 11</h2>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-pixfmt.h</h3>
            <pre><code>1  #ifndef AVUTIL_PIXFMT_H
2  #define AVUTIL_PIXFMT_H
3  #include "libavutil/avconfig.h"
4  #include "version.h"
5  #define AVPALETTE_SIZE 1024
6  #define AVPALETTE_COUNT 256
7  enum AVPixelFormat {
8      AV_PIX_FMT_NONE = -1,
9      AV_PIX_FMT_YUV420P,   
10      AV_PIX_FMT_YUYV422,   
11      AV_PIX_FMT_RGB24,     
12      AV_PIX_FMT_BGR24,     
13      AV_PIX_FMT_YUV422P,   
14      AV_PIX_FMT_YUV444P,   
15      AV_PIX_FMT_YUV410P,   
16      AV_PIX_FMT_YUV411P,   
17      AV_PIX_FMT_GRAY8,     
18      AV_PIX_FMT_MONOWHITE, 
19      AV_PIX_FMT_MONOBLACK, 
20      AV_PIX_FMT_PAL8,      
21      AV_PIX_FMT_YUVJ420P,  
22      AV_PIX_FMT_YUVJ422P,  
23      AV_PIX_FMT_YUVJ444P,  
24  #if FF_API_XVMC
25      AV_PIX_FMT_XVMC_MPEG2_MC,
26      AV_PIX_FMT_XVMC_MPEG2_IDCT,
27      AV_PIX_FMT_XVMC = AV_PIX_FMT_XVMC_MPEG2_IDCT,
28  #endif &bsol;* FF_API_XVMC */
29      AV_PIX_FMT_UYVY422,   
30      AV_PIX_FMT_UYYVYY411, 
31      AV_PIX_FMT_BGR8,      
32      AV_PIX_FMT_BGR4,      
33      AV_PIX_FMT_BGR4_BYTE, 
34      AV_PIX_FMT_RGB8,      
35      AV_PIX_FMT_RGB4,      
36      AV_PIX_FMT_RGB4_BYTE, 
37      AV_PIX_FMT_NV12,      
38      AV_PIX_FMT_NV21,      
39      AV_PIX_FMT_ARGB,      
40      AV_PIX_FMT_RGBA,      
41      AV_PIX_FMT_ABGR,      
42      AV_PIX_FMT_BGRA,      
43      AV_PIX_FMT_GRAY16BE,  
44      AV_PIX_FMT_GRAY16LE,  
45      AV_PIX_FMT_YUV440P,   
46      AV_PIX_FMT_YUVJ440P,  
47      AV_PIX_FMT_YUVA420P,  
48  #if FF_API_VDPAU
49      AV_PIX_FMT_VDPAU_H264,
50      AV_PIX_FMT_VDPAU_MPEG1,
51      AV_PIX_FMT_VDPAU_MPEG2,
52      AV_PIX_FMT_VDPAU_WMV3,
53      AV_PIX_FMT_VDPAU_VC1, 
54  #endif
55      AV_PIX_FMT_RGB48BE,   
56      AV_PIX_FMT_RGB48LE,   
57      AV_PIX_FMT_RGB565BE,  
58      AV_PIX_FMT_RGB565LE,  
59      AV_PIX_FMT_RGB555BE,  
60      AV_PIX_FMT_RGB555LE,  
61      AV_PIX_FMT_BGR565BE,  
62      AV_PIX_FMT_BGR565LE,  
63      AV_PIX_FMT_BGR555BE,  
64      AV_PIX_FMT_BGR555LE,  
65  #if FF_API_VAAPI
66      AV_PIX_FMT_VAAPI_MOCO, 
67      AV_PIX_FMT_VAAPI_IDCT, 
68      AV_PIX_FMT_VAAPI_VLD,  
69      AV_PIX_FMT_VAAPI = AV_PIX_FMT_VAAPI_VLD,
70  #else
71      AV_PIX_FMT_VAAPI,
72  #endif
73      AV_PIX_FMT_YUV420P16LE,  
74      AV_PIX_FMT_YUV420P16BE,  
75      AV_PIX_FMT_YUV422P16LE,  
76      AV_PIX_FMT_YUV422P16BE,  
77      AV_PIX_FMT_YUV444P16LE,  
78      AV_PIX_FMT_YUV444P16BE,  
79  #if FF_API_VDPAU
80      AV_PIX_FMT_VDPAU_MPEG4,  
81  #endif
82      AV_PIX_FMT_DXVA2_VLD,    
83      AV_PIX_FMT_RGB444LE,  
84      AV_PIX_FMT_RGB444BE,  
85      AV_PIX_FMT_BGR444LE,  
86      AV_PIX_FMT_BGR444BE,  
87      AV_PIX_FMT_YA8,       
88      AV_PIX_FMT_Y400A = AV_PIX_FMT_YA8, 
89      AV_PIX_FMT_GRAY8A= AV_PIX_FMT_YA8, 
90      AV_PIX_FMT_BGR48BE,   
91      AV_PIX_FMT_BGR48LE,   
92      AV_PIX_FMT_YUV420P9BE, 
93      AV_PIX_FMT_YUV420P9LE, 
94      AV_PIX_FMT_YUV420P10BE,
95      AV_PIX_FMT_YUV420P10LE,
96      AV_PIX_FMT_YUV422P10BE,
97      AV_PIX_FMT_YUV422P10LE,
98      AV_PIX_FMT_YUV444P9BE, 
99      AV_PIX_FMT_YUV444P9LE, 
100      AV_PIX_FMT_YUV444P10BE,
101      AV_PIX_FMT_YUV444P10LE,
102      AV_PIX_FMT_YUV422P9BE, 
103      AV_PIX_FMT_YUV422P9LE, 
104      AV_PIX_FMT_VDA_VLD,    
105      AV_PIX_FMT_GBRP,      
106      AV_PIX_FMT_GBR24P = AV_PIX_FMT_GBRP, 
107      AV_PIX_FMT_GBRP9BE,   
108      AV_PIX_FMT_GBRP9LE,   
109      AV_PIX_FMT_GBRP10BE,  
110      AV_PIX_FMT_GBRP10LE,  
111      AV_PIX_FMT_GBRP16BE,  
112      AV_PIX_FMT_GBRP16LE,  
113      AV_PIX_FMT_YUVA422P,  
114      AV_PIX_FMT_YUVA444P,  
115      AV_PIX_FMT_YUVA420P9BE,  
116      AV_PIX_FMT_YUVA420P9LE,  
117      AV_PIX_FMT_YUVA422P9BE,  
118      AV_PIX_FMT_YUVA422P9LE,  
119      AV_PIX_FMT_YUVA444P9BE,  
120      AV_PIX_FMT_YUVA444P9LE,  
121      AV_PIX_FMT_YUVA420P10BE, 
122      AV_PIX_FMT_YUVA420P10LE, 
123      AV_PIX_FMT_YUVA422P10BE, 
124      AV_PIX_FMT_YUVA422P10LE, 
125      AV_PIX_FMT_YUVA444P10BE, 
126      AV_PIX_FMT_YUVA444P10LE, 
127      AV_PIX_FMT_YUVA420P16BE, 
128      AV_PIX_FMT_YUVA420P16LE, 
129      AV_PIX_FMT_YUVA422P16BE, 
130      AV_PIX_FMT_YUVA422P16LE, 
131      AV_PIX_FMT_YUVA444P16BE, 
132      AV_PIX_FMT_YUVA444P16LE, 
133      AV_PIX_FMT_VDPAU,     
134      AV_PIX_FMT_XYZ12LE,      
135      AV_PIX_FMT_XYZ12BE,      
136      AV_PIX_FMT_NV16,         
137      AV_PIX_FMT_NV20LE,       
138      AV_PIX_FMT_NV20BE,       
139      AV_PIX_FMT_RGBA64BE,     
140      AV_PIX_FMT_RGBA64LE,     
141      AV_PIX_FMT_BGRA64BE,     
142      AV_PIX_FMT_BGRA64LE,     
143      AV_PIX_FMT_YVYU422,   
144      AV_PIX_FMT_VDA,          
145      AV_PIX_FMT_YA16BE,       
146      AV_PIX_FMT_YA16LE,       
147      AV_PIX_FMT_GBRAP,        
148      AV_PIX_FMT_GBRAP16BE,    
149      AV_PIX_FMT_GBRAP16LE,    
150      AV_PIX_FMT_QSV,
151      AV_PIX_FMT_MMAL,
152      AV_PIX_FMT_D3D11VA_VLD,  
153      AV_PIX_FMT_CUDA,
154      AV_PIX_FMT_0RGB=0x123+4,
155      AV_PIX_FMT_RGB0,        
156      AV_PIX_FMT_0BGR,        
157      AV_PIX_FMT_BGR0,        
158      AV_PIX_FMT_YUV420P12BE, 
159      AV_PIX_FMT_YUV420P12LE, 
160      AV_PIX_FMT_YUV420P14BE, 
161      AV_PIX_FMT_YUV420P14LE, 
162      AV_PIX_FMT_YUV422P12BE, 
163      AV_PIX_FMT_YUV422P12LE, 
164      AV_PIX_FMT_YUV422P14BE, 
165      AV_PIX_FMT_YUV422P14LE, 
166      AV_PIX_FMT_YUV444P12BE, 
167      AV_PIX_FMT_YUV444P12LE, 
168      AV_PIX_FMT_YUV444P14BE, 
169      AV_PIX_FMT_YUV444P14LE, 
170      AV_PIX_FMT_GBRP12BE,    
171      AV_PIX_FMT_GBRP12LE,    
172      AV_PIX_FMT_GBRP14BE,    
173      AV_PIX_FMT_GBRP14LE,    
174      AV_PIX_FMT_YUVJ411P,    
175      AV_PIX_FMT_BAYER_BGGR8,    
176      AV_PIX_FMT_BAYER_RGGB8,    
177      AV_PIX_FMT_BAYER_GBRG8,    
178      AV_PIX_FMT_BAYER_GRBG8,    
179      AV_PIX_FMT_BAYER_BGGR16LE, 
180      AV_PIX_FMT_BAYER_BGGR16BE, 
181      AV_PIX_FMT_BAYER_RGGB16LE, 
182      AV_PIX_FMT_BAYER_RGGB16BE, 
183      AV_PIX_FMT_BAYER_GBRG16LE, 
184      AV_PIX_FMT_BAYER_GBRG16BE, 
185      AV_PIX_FMT_BAYER_GRBG16LE, 
186      AV_PIX_FMT_BAYER_GRBG16BE, 
187  #if !FF_API_XVMC
188      AV_PIX_FMT_XVMC,
189  #endif &bsol;* !FF_API_XVMC */
190      AV_PIX_FMT_YUV440P10LE, 
191      AV_PIX_FMT_YUV440P10BE, 
192      AV_PIX_FMT_YUV440P12LE, 
193      AV_PIX_FMT_YUV440P12BE, 
194      AV_PIX_FMT_AYUV64LE,    
195      AV_PIX_FMT_AYUV64BE,    
196      AV_PIX_FMT_VIDEOTOOLBOX, 
197      AV_PIX_FMT_P010LE, 
198      AV_PIX_FMT_P010BE, 
199      AV_PIX_FMT_GBRAP12BE,  
200      AV_PIX_FMT_GBRAP12LE,  
201      AV_PIX_FMT_GBRAP10BE,  
202      AV_PIX_FMT_GBRAP10LE,  
203      AV_PIX_FMT_MEDIACODEC, 
204      AV_PIX_FMT_GRAY12BE,   
205      AV_PIX_FMT_GRAY12LE,   
206      AV_PIX_FMT_GRAY10BE,   
207      AV_PIX_FMT_GRAY10LE,   
208      AV_PIX_FMT_P016LE, 
209      AV_PIX_FMT_P016BE, 
210      AV_PIX_FMT_D3D11,
211      AV_PIX_FMT_GRAY9BE,   
212      AV_PIX_FMT_GRAY9LE,   
213      AV_PIX_FMT_GBRPF32BE,  
214      AV_PIX_FMT_GBRPF32LE,  
215      AV_PIX_FMT_GBRAPF32BE, 
216      AV_PIX_FMT_GBRAPF32LE, 
217      AV_PIX_FMT_DRM_PRIME,
218      AV_PIX_FMT_NB         
219  };
220  #if AV_HAVE_BIGENDIAN
221  #   define AV_PIX_FMT_NE(be, le) AV_PIX_FMT_##be
222  #else
223  #   define AV_PIX_FMT_NE(be, le) AV_PIX_FMT_##le
224  #endif
225  #define AV_PIX_FMT_RGB32   AV_PIX_FMT_NE(ARGB, BGRA)
226  #define AV_PIX_FMT_RGB32_1 AV_PIX_FMT_NE(RGBA, ABGR)
227  #define AV_PIX_FMT_BGR32   AV_PIX_FMT_NE(ABGR, RGBA)
228  #define AV_PIX_FMT_BGR32_1 AV_PIX_FMT_NE(BGRA, ARGB)
229  #define AV_PIX_FMT_0RGB32  AV_PIX_FMT_NE(0RGB, BGR0)
230  #define AV_PIX_FMT_0BGR32  AV_PIX_FMT_NE(0BGR, RGB0)
231  #define AV_PIX_FMT_GRAY9  AV_PIX_FMT_NE(GRAY9BE,  GRAY9LE)
232  #define AV_PIX_FMT_GRAY10 AV_PIX_FMT_NE(GRAY10BE, GRAY10LE)
233  #define AV_PIX_FMT_GRAY12 AV_PIX_FMT_NE(GRAY12BE, GRAY12LE)
234  #define AV_PIX_FMT_GRAY16 AV_PIX_FMT_NE(GRAY16BE, GRAY16LE)
235  #define AV_PIX_FMT_YA16   AV_PIX_FMT_NE(YA16BE,   YA16LE)
236  #define AV_PIX_FMT_RGB48  AV_PIX_FMT_NE(RGB48BE,  RGB48LE)
237  #define AV_PIX_FMT_RGB565 AV_PIX_FMT_NE(RGB565BE, RGB565LE)
238  #define AV_PIX_FMT_RGB555 AV_PIX_FMT_NE(RGB555BE, RGB555LE)
239  #define AV_PIX_FMT_RGB444 AV_PIX_FMT_NE(RGB444BE, RGB444LE)
240  #define AV_PIX_FMT_RGBA64 AV_PIX_FMT_NE(RGBA64BE, RGBA64LE)
241  #define AV_PIX_FMT_BGR48  AV_PIX_FMT_NE(BGR48BE,  BGR48LE)
242  #define AV_PIX_FMT_BGR565 AV_PIX_FMT_NE(BGR565BE, BGR565LE)
243  #define AV_PIX_FMT_BGR555 AV_PIX_FMT_NE(BGR555BE, BGR555LE)
244  #define AV_PIX_FMT_BGR444 AV_PIX_FMT_NE(BGR444BE, BGR444LE)
245  #define AV_PIX_FMT_BGRA64 AV_PIX_FMT_NE(BGRA64BE, BGRA64LE)
246  #define AV_PIX_FMT_YUV420P9  AV_PIX_FMT_NE(YUV420P9BE , YUV420P9LE)
247  #define AV_PIX_FMT_YUV422P9  AV_PIX_FMT_NE(YUV422P9BE , YUV422P9LE)
248  #define AV_PIX_FMT_YUV444P9  AV_PIX_FMT_NE(YUV444P9BE , YUV444P9LE)
249  #define AV_PIX_FMT_YUV420P10 AV_PIX_FMT_NE(YUV420P10BE, YUV420P10LE)
250  #define AV_PIX_FMT_YUV422P10 AV_PIX_FMT_NE(YUV422P10BE, YUV422P10LE)
251  #define AV_PIX_FMT_YUV440P10 AV_PIX_FMT_NE(YUV440P10BE, YUV440P10LE)
252  #define AV_PIX_FMT_YUV444P10 AV_PIX_FMT_NE(YUV444P10BE, YUV444P10LE)
253  #define AV_PIX_FMT_YUV420P12 AV_PIX_FMT_NE(YUV420P12BE, YUV420P12LE)
254  #define AV_PIX_FMT_YUV422P12 AV_PIX_FMT_NE(YUV422P12BE, YUV422P12LE)
255  #define AV_PIX_FMT_YUV440P12 AV_PIX_FMT_NE(YUV440P12BE, YUV440P12LE)
256  #define AV_PIX_FMT_YUV444P12 AV_PIX_FMT_NE(YUV444P12BE, YUV444P12LE)
257  #define AV_PIX_FMT_YUV420P14 AV_PIX_FMT_NE(YUV420P14BE, YUV420P14LE)
258  #define AV_PIX_FMT_YUV422P14 AV_PIX_FMT_NE(YUV422P14BE, YUV422P14LE)
259  #define AV_PIX_FMT_YUV444P14 AV_PIX_FMT_NE(YUV444P14BE, YUV444P14LE)
260  #define AV_PIX_FMT_YUV420P16 AV_PIX_FMT_NE(YUV420P16BE, YUV420P16LE)
261  #define AV_PIX_FMT_YUV422P16 AV_PIX_FMT_NE(YUV422P16BE, YUV422P16LE)
262  #define AV_PIX_FMT_YUV444P16 AV_PIX_FMT_NE(YUV444P16BE, YUV444P16LE)
263  #define AV_PIX_FMT_GBRP9     AV_PIX_FMT_NE(GBRP9BE ,    GBRP9LE)
264  #define AV_PIX_FMT_GBRP10    AV_PIX_FMT_NE(GBRP10BE,    GBRP10LE)
265  #define AV_PIX_FMT_GBRP12    AV_PIX_FMT_NE(GBRP12BE,    GBRP12LE)
266  #define AV_PIX_FMT_GBRP14    AV_PIX_FMT_NE(GBRP14BE,    GBRP14LE)
267  #define AV_PIX_FMT_GBRP16    AV_PIX_FMT_NE(GBRP16BE,    GBRP16LE)
268  #define AV_PIX_FMT_GBRAP10   AV_PIX_FMT_NE(GBRAP10BE,   GBRAP10LE)
269  #define AV_PIX_FMT_GBRAP12   AV_PIX_FMT_NE(GBRAP12BE,   GBRAP12LE)
270  #define AV_PIX_FMT_GBRAP16   AV_PIX_FMT_NE(GBRAP16BE,   GBRAP16LE)
271  #define AV_PIX_FMT_BAYER_BGGR16 AV_PIX_FMT_NE(BAYER_BGGR16BE,    BAYER_BGGR16LE)
272  #define AV_PIX_FMT_BAYER_RGGB16 AV_PIX_FMT_NE(BAYER_RGGB16BE,    BAYER_RGGB16LE)
273  #define AV_PIX_FMT_BAYER_GBRG16 AV_PIX_FMT_NE(BAYER_GBRG16BE,    BAYER_GBRG16LE)
274  #define AV_PIX_FMT_BAYER_GRBG16 AV_PIX_FMT_NE(BAYER_GRBG16BE,    BAYER_GRBG16LE)
275  #define AV_PIX_FMT_GBRPF32    AV_PIX_FMT_NE(GBRPF32BE,  GBRPF32LE)
276  #define AV_PIX_FMT_GBRAPF32   AV_PIX_FMT_NE(GBRAPF32BE, GBRAPF32LE)
277  #define AV_PIX_FMT_YUVA420P9  AV_PIX_FMT_NE(YUVA420P9BE , YUVA420P9LE)
278  #define AV_PIX_FMT_YUVA422P9  AV_PIX_FMT_NE(YUVA422P9BE , YUVA422P9LE)
279  #define AV_PIX_FMT_YUVA444P9  AV_PIX_FMT_NE(YUVA444P9BE , YUVA444P9LE)
280  #define AV_PIX_FMT_YUVA420P10 AV_PIX_FMT_NE(YUVA420P10BE, YUVA420P10LE)
281  #define AV_PIX_FMT_YUVA422P10 AV_PIX_FMT_NE(YUVA422P10BE, YUVA422P10LE)
282  #define AV_PIX_FMT_YUVA444P10 AV_PIX_FMT_NE(YUVA444P10BE, YUVA444P10LE)
283  #define AV_PIX_FMT_YUVA420P16 AV_PIX_FMT_NE(YUVA420P16BE, YUVA420P16LE)
284  #define AV_PIX_FMT_YUVA422P16 AV_PIX_FMT_NE(YUVA422P16BE, YUVA422P16LE)
285  #define AV_PIX_FMT_YUVA444P16 AV_PIX_FMT_NE(YUVA444P16BE, YUVA444P16LE)
286  #define AV_PIX_FMT_XYZ12      AV_PIX_FMT_NE(XYZ12BE, XYZ12LE)
287  #define AV_PIX_FMT_NV20       AV_PIX_FMT_NE(NV20BE,  NV20LE)
288  #define AV_PIX_FMT_AYUV64     AV_PIX_FMT_NE(AYUV64BE, AYUV64LE)
289  #define AV_PIX_FMT_P010       AV_PIX_FMT_NE(P010BE,  P010LE)
290  #define AV_PIX_FMT_P016       AV_PIX_FMT_NE(P016BE,  P016LE)
291  enum AVColorPrimaries {
292      AVCOL_PRI_RESERVED0   = 0,
293      AVCOL_PRI_BT709       = 1,  
294      AVCOL_PRI_UNSPECIFIED = 2,
295      AVCOL_PRI_RESERVED    = 3,
296      AVCOL_PRI_BT470M      = 4,  
297      AVCOL_PRI_BT470BG     = 5,  
298      AVCOL_PRI_SMPTE170M   = 6,  
299      AVCOL_PRI_SMPTE240M   = 7,  
300      AVCOL_PRI_FILM        = 8,  
301      AVCOL_PRI_BT2020      = 9,  
302      AVCOL_PRI_SMPTE428    = 10, 
303      AVCOL_PRI_SMPTEST428_1 = AVCOL_PRI_SMPTE428,
304      AVCOL_PRI_SMPTE431    = 11, 
305      AVCOL_PRI_SMPTE432    = 12, 
306      AVCOL_PRI_JEDEC_P22   = 22, 
307      AVCOL_PRI_NB                
308  };
<span onclick='openModal()' class='match'>309  enum AVColorTransferCharacteristic {
310      AVCOL_TRC_RESERVED0    = 0,
311      AVCOL_TRC_BT709        = 1,  
312      AVCOL_TRC_UNSPECIFIED  = 2,
313      AVCOL_TRC_RESERVED     = 3,
314      AVCOL_TRC_GAMMA22      = 4,  
315      AVCOL_TRC_GAMMA28      = 5,  
316      AVCOL_TRC_SMPTE170M    = 6,  
317      AVCOL_TRC_SMPTE240M    = 7,
318      AVCOL_TRC_LINEAR       = 8,  
319      AVCOL_TRC_LOG          = 9,  
</span>320      AVCOL_TRC_LOG_SQRT     = 10, 
321      AVCOL_TRC_IEC61966_2_4 = 11, 
322      AVCOL_TRC_BT1361_ECG   = 12, 
323      AVCOL_TRC_IEC61966_2_1 = 13, 
324      AVCOL_TRC_BT2020_10    = 14, 
325      AVCOL_TRC_BT2020_12    = 15, 
326      AVCOL_TRC_SMPTE2084    = 16, 
327      AVCOL_TRC_SMPTEST2084  = AVCOL_TRC_SMPTE2084,
328      AVCOL_TRC_SMPTE428     = 17, 
329      AVCOL_TRC_SMPTEST428_1 = AVCOL_TRC_SMPTE428,
330      AVCOL_TRC_ARIB_STD_B67 = 18, 
331      AVCOL_TRC_NB                 
332  };
333  enum AVColorSpace {
334      AVCOL_SPC_RGB         = 0,  
335      AVCOL_SPC_BT709       = 1,  
336      AVCOL_SPC_UNSPECIFIED = 2,
337      AVCOL_SPC_RESERVED    = 3,
338      AVCOL_SPC_FCC         = 4,  
339      AVCOL_SPC_BT470BG     = 5,  
340      AVCOL_SPC_SMPTE170M   = 6,  
341      AVCOL_SPC_SMPTE240M   = 7,  
342      AVCOL_SPC_YCGCO       = 8,  
343      AVCOL_SPC_YCOCG       = AVCOL_SPC_YCGCO,
344      AVCOL_SPC_BT2020_NCL  = 9,  
345      AVCOL_SPC_BT2020_CL   = 10, 
346      AVCOL_SPC_SMPTE2085   = 11, 
347      AVCOL_SPC_CHROMA_DERIVED_NCL = 12, 
348      AVCOL_SPC_CHROMA_DERIVED_CL = 13, 
349      AVCOL_SPC_ICTCP       = 14, 
350      AVCOL_SPC_NB                
351  };
352  enum AVColorRange {
353      AVCOL_RANGE_UNSPECIFIED = 0,
354      AVCOL_RANGE_MPEG        = 1, 
355      AVCOL_RANGE_JPEG        = 2, 
356      AVCOL_RANGE_NB               
357  };
358  enum AVChromaLocation {
359      AVCHROMA_LOC_UNSPECIFIED = 0,
360      AVCHROMA_LOC_LEFT        = 1, 
361      AVCHROMA_LOC_CENTER      = 2, 
362      AVCHROMA_LOC_TOPLEFT     = 3, 
363      AVCHROMA_LOC_TOP         = 4,
364      AVCHROMA_LOC_BOTTOMLEFT  = 5,
365      AVCHROMA_LOC_BOTTOM      = 6,
366      AVCHROMA_LOC_NB               
367  };
368  #endif &bsol;* AVUTIL_PIXFMT_H */
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dht-rader.c</h3>
            <pre><code>1  #include "rdft/rdft.h"
2  typedef struct {
3       solver super;
4       int pad;
5  } S;
6  typedef struct {
7       plan_rdft super;
8       plan *cld1, *cld2;
9       R *omega;
10       INT n, npad, g, ginv;
11       INT is, os;
12       plan *cld_omega;
13  } P;
14  static rader_tl *omegas = 0;
15  #define R2HC_ONLY_CONV 1
16  static void apply(const plan *ego_, R *I, R *O)
17  {
18       const P *ego = (const P *) ego_;
19       INT n = ego->n; &bsol;* prime */
20       INT npad = ego->npad; &bsol;* == n - 1 for unpadded Rader; always even */
21       INT is = ego->is, os;
22       INT k, gpower, g;
23       R *buf, *omega;
24       R r0;
25       buf = (R *) MALLOC(sizeof(R) * npad, BUFFERS);
26       g = ego->g; 
27       for (gpower = 1, k = 0; k < n - 1; ++k, gpower = MULMOD(gpower, g, n)) {
28  	  buf[k] = I[gpower * is];
29       }
30       ;
31       A(n - 1 <= npad);
32       for (k = n - 1; k < npad; ++k) &bsol;* optionally, zero-pad convolution */
33  	  buf[k] = 0;
34       os = ego->os;
35       {
36  	    plan_rdft *cld = (plan_rdft *) ego->cld1;
37  	    cld->apply((plan *) cld, buf, buf);
38       }
39       O[0] = (r0 = I[0]) + buf[0];
40       omega = ego->omega;
41       buf[0] *= omega[0];
<span onclick='openModal()' class='match'>42       for (k = 1; k < npad/2; ++k) {
43  	  E rB, iB, rW, iW, a, b;
44  	  rW = omega[k];
45  	  iW = omega[npad - k];
46  	  rB = buf[k];
47  	  iB = buf[npad - k];
48  	  a = rW * rB - iW * iB;
49  	  b = rW * iB + iW * rB;
50  #if R2HC_ONLY_CONV
51  	  buf[k] = a + b;
52  	  buf[npad - k] = a - b;
53  #else
54  	  buf[k] = a;
55  	  buf[npad - k] = b;
</span>56  #endif
57       }
58       A(k + k == npad); &bsol;* since npad is even */
59       buf[k] *= omega[k];
60       buf[0] += r0;
61       {
62  	    plan_rdft *cld = (plan_rdft *) ego->cld2;
63  	    cld->apply((plan *) cld, buf, buf);
64       }
65       A(gpower == 1);
66  #if R2HC_ONLY_CONV
67       O[os] = buf[0];
68       gpower = g = ego->ginv;
69       A(npad == n - 1 || npad/2 >= n - 1);
70       if (npad == n - 1) {
71  	  for (k = 1; k < npad/2; ++k, gpower = MULMOD(gpower, g, n)) {
72  	       O[gpower * os] = buf[k] + buf[npad - k];
73  	  }
74  	  O[gpower * os] = buf[k];
75  	  ++k, gpower = MULMOD(gpower, g, n);
76  	  for (; k < npad; ++k, gpower = MULMOD(gpower, g, n)) {
77  	       O[gpower * os] = buf[npad - k] - buf[k];
78  	  }
79       }
80       else {
81  	  for (k = 1; k < n - 1; ++k, gpower = MULMOD(gpower, g, n)) {
82  	       O[gpower * os] = buf[k] + buf[npad - k];
83  	  }
84       }
85  #else
86       g = ego->ginv;
87       for (k = 0; k < n - 1; ++k, gpower = MULMOD(gpower, g, n)) {
88  	  O[gpower * os] = buf[k];
89       }
90  #endif
91       A(gpower == 1);
92       X(ifree)(buf);
93  }
94  static R *mkomega(enum wakefulness wakefulness,
95  		  plan *p_, INT n, INT npad, INT ginv)
96  {
97       plan_rdft *p = (plan_rdft *) p_;
98       R *omega;
99       INT i, gpower;
100       trigreal scale;
101       triggen *t;
102       if ((omega = X(rader_tl_find)(n, npad + 1, ginv, omegas))) 
103  	  return omega;
104       omega = (R *)MALLOC(sizeof(R) * npad, TWIDDLES);
105       scale = npad; &bsol;* normalization for convolution */
106       t = X(mktriggen)(wakefulness, n);
107       for (i = 0, gpower = 1; i < n-1; ++i, gpower = MULMOD(gpower, ginv, n)) {
108  	  trigreal w[2];
109  	  t->cexpl(t, gpower, w);
110  	  omega[i] = (w[0] + w[1]) / scale;
111       }
112       X(triggen_destroy)(t);
113       A(gpower == 1);
114       A(npad == n - 1 || npad >= 2*(n - 1) - 1);
115       for (; i < npad; ++i)
116  	  omega[i] = K(0.0);
117       if (npad > n - 1)
118  	  for (i = 1; i < n-1; ++i)
119  	       omega[npad - i] = omega[n - 1 - i];
120       p->apply(p_, omega, omega);
121       X(rader_tl_insert)(n, npad + 1, ginv, omega, &omegas);
122       return omega;
123  }
124  static void free_omega(R *omega)
125  {
126       X(rader_tl_delete)(omega, &omegas);
127  }
128  static void awake(plan *ego_, enum wakefulness wakefulness)
129  {
130       P *ego = (P *) ego_;
131       X(plan_awake)(ego->cld1, wakefulness);
132       X(plan_awake)(ego->cld2, wakefulness);
133       X(plan_awake)(ego->cld_omega, wakefulness);
134       switch (wakefulness) {
135  	 case SLEEPY:
136  	      free_omega(ego->omega);
137  	      ego->omega = 0;
138  	      break;
139  	 default:
140  	      ego->g = X(find_generator)(ego->n);
141  	      ego->ginv = X(power_mod)(ego->g, ego->n - 2, ego->n);
142  	      A(MULMOD(ego->g, ego->ginv, ego->n) == 1);
143  	      A(!ego->omega);
144  	      ego->omega = mkomega(wakefulness, 
145  				   ego->cld_omega,ego->n,ego->npad,ego->ginv);
146  	      break;
147       }
148  }
149  static void destroy(plan *ego_)
150  {
151       P *ego = (P *) ego_;
152       X(plan_destroy_internal)(ego->cld_omega);
153       X(plan_destroy_internal)(ego->cld2);
154       X(plan_destroy_internal)(ego->cld1);
155  }
156  static void print(const plan *ego_, printer *p)
157  {
158       const P *ego = (const P *) ego_;
159       p->print(p, "(dht-rader-%D/%D%ois=%oos=%(%p%)",
160                ego->n, ego->npad, ego->is, ego->os, ego->cld1);
161       if (ego->cld2 != ego->cld1)
162            p->print(p, "%(%p%)", ego->cld2);
163       if (ego->cld_omega != ego->cld1 && ego->cld_omega != ego->cld2)
164            p->print(p, "%(%p%)", ego->cld_omega);
165       p->putchr(p, ')');
166  }
167  static int applicable(const solver *ego, const problem *p_, const planner *plnr)
168  {
169       const problem_rdft *p = (const problem_rdft *) p_;
170       UNUSED(ego);
171       return (1
172  	     && p->sz->rnk == 1
173  	     && p->vecsz->rnk == 0
174  	     && p->kind[0] == DHT
175  	     && X(is_prime)(p->sz->dims[0].n)
176  	     && p->sz->dims[0].n > 2
177  	     && CIMPLIES(NO_SLOWP(plnr), p->sz->dims[0].n > RADER_MAX_SLOW)
178  	     && CIMPLIES(NO_SLOWP(plnr), X(factors_into_small_primes)(p->sz->dims[0].n - 1))
179  	  );
180  }
181  static INT choose_transform_size(INT minsz)
182  {
183       static const INT primes[] = { 2, 3, 5, 0 };
184       while (!X(factors_into)(minsz, primes) || minsz % 2)
185  	  ++minsz;
186       return minsz;
187  }
188  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
189  {
190       const S *ego = (const S *) ego_;
191       const problem_rdft *p = (const problem_rdft *) p_;
192       P *pln;
193       INT n, npad;
194       INT is, os;
195       plan *cld1 = (plan *) 0;
196       plan *cld2 = (plan *) 0;
197       plan *cld_omega = (plan *) 0;
198       R *buf = (R *) 0;
199       problem *cldp;
200       static const plan_adt padt = {
201  	  X(rdft_solve), awake, print, destroy
202       };
203       if (!applicable(ego_, p_, plnr))
204  	  return (plan *) 0;
205       n = p->sz->dims[0].n;
206       is = p->sz->dims[0].is;
207       os = p->sz->dims[0].os;
208       if (ego->pad)
209  	  npad = choose_transform_size(2 * (n - 1) - 1);
210       else
211  	  npad = n - 1;
212       buf = (R *) MALLOC(sizeof(R) * npad, BUFFERS);
213       cld1 = X(mkplan_f_d)(plnr, 
214  			  X(mkproblem_rdft_1_d)(X(mktensor_1d)(npad, 1, 1),
215  						X(mktensor_1d)(1, 0, 0),
216  						buf, buf,
217  						R2HC),
218  			  NO_SLOW, 0, 0);
219       if (!cld1) goto nada;
220       cldp =
221            X(mkproblem_rdft_1_d)(
222                 X(mktensor_1d)(npad, 1, 1),
223                 X(mktensor_1d)(1, 0, 0),
224  	       buf, buf, 
225  #if R2HC_ONLY_CONV
226  	       R2HC
227  #else
228  	       HC2R
229  #endif
230  	       );
231       if (!(cld2 = X(mkplan_f_d)(plnr, cldp, NO_SLOW, 0, 0)))
232  	  goto nada;
233       cld_omega = X(mkplan_f_d)(plnr, 
234  			       X(mkproblem_rdft_1_d)(
235  				    X(mktensor_1d)(npad, 1, 1),
236  				    X(mktensor_1d)(1, 0, 0),
237  				    buf, buf, R2HC),
238  			       NO_SLOW, ESTIMATE, 0);
239       if (!cld_omega) goto nada;
240       X(ifree)(buf);
241       buf = 0;
242       pln = MKPLAN_RDFT(P, &padt, apply);
243       pln->cld1 = cld1;
244       pln->cld2 = cld2;
245       pln->cld_omega = cld_omega;
246       pln->omega = 0;
247       pln->n = n;
248       pln->npad = npad;
249       pln->is = is;
250       pln->os = os;
251       X(ops_add)(&cld1->ops, &cld2->ops, &pln->super.super.ops);
252       pln->super.super.ops.other += (npad/2-1)*6 + npad + n + (n-1) * ego->pad;
253       pln->super.super.ops.add += (npad/2-1)*2 + 2 + (n-1) * ego->pad;
254       pln->super.super.ops.mul += (npad/2-1)*4 + 2 + ego->pad;
255  #if R2HC_ONLY_CONV
256       pln->super.super.ops.other += n-2 - ego->pad;
257       pln->super.super.ops.add += (npad/2-1)*2 + (n-2) - ego->pad;
258  #endif
259       return &(pln->super.super);
260   nada:
261       X(ifree0)(buf);
262       X(plan_destroy_internal)(cld_omega);
263       X(plan_destroy_internal)(cld2);
264       X(plan_destroy_internal)(cld1);
265       return 0;
266  }
267  static solver *mksolver(int pad)
268  {
269       static const solver_adt sadt = { PROBLEM_RDFT, mkplan, 0 };
270       S *slv = MKSOLVER(S, &sadt);
271       slv->pad = pad;
272       return &(slv->super);
273  }
274  void X(dht_rader_register)(planner *p)
275  {
276       REGISTER_SOLVER(p, mksolver(0));
277       REGISTER_SOLVER(p, mksolver(1));
278  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-pixfmt.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dht-rader.c</div>
                <div class="column column_space"><pre><code>309  enum AVColorTransferCharacteristic {
310      AVCOL_TRC_RESERVED0    = 0,
311      AVCOL_TRC_BT709        = 1,  
312      AVCOL_TRC_UNSPECIFIED  = 2,
313      AVCOL_TRC_RESERVED     = 3,
314      AVCOL_TRC_GAMMA22      = 4,  
315      AVCOL_TRC_GAMMA28      = 5,  
316      AVCOL_TRC_SMPTE170M    = 6,  
317      AVCOL_TRC_SMPTE240M    = 7,
318      AVCOL_TRC_LINEAR       = 8,  
319      AVCOL_TRC_LOG          = 9,  
</pre></code></div>
                <div class="column column_space"><pre><code>42       for (k = 1; k < npad/2; ++k) {
43  	  E rB, iB, rW, iW, a, b;
44  	  rW = omega[k];
45  	  iW = omega[npad - k];
46  	  rB = buf[k];
47  	  iB = buf[npad - k];
48  	  a = rW * rB - iW * iB;
49  	  b = rW * iB + iW * rB;
50  #if R2HC_ONLY_CONV
51  	  buf[k] = a + b;
52  	  buf[npad - k] = a - b;
53  #else
54  	  buf[k] = a;
55  	  buf[npad - k] = b;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    