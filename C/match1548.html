<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for infd-xmpp-server.c &amp; inf-text-gtk-buffer.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for infd-xmpp-server.c &amp; inf-text-gtk-buffer.c
      </h3>
<h1 align="center">
        7.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>infd-xmpp-server.c (14.705882%)<th>inf-text-gtk-buffer.c (4.6487603%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(505-528)<td><a href="#" name="0">(1416-1452)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(396-427)<td><a href="#" name="1">(1362-1392)</a><td align="center"><font color="#f00000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(461-481)<td><a href="#" name="2">(1123-1146)</a><td align="center"><font color="#b40000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>infd-xmpp-server.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/server/infd-xmpp-server.h&gt;
2 #include &lt;libinfinity/server/infd-tcp-server.h&gt;
3 #include &lt;libinfinity/server/infd-xml-server.h&gt;
4 #include &lt;libinfinity/common/inf-xmpp-connection.h&gt;
5 #include &lt;libinfinity/inf-signals.h&gt;
6 #ifdef G_OS_WIN32
7 # ifdef ERROR
8 #  undef ERROR
9 # endif
10 #endif
11 typedef enum InfdXmppServerStatus_ {
12   INFD_XMPP_SERVER_CLOSED,
13   INFD_XMPP_SERVER_OPEN
14 } InfdXmppServerStatus;
15 typedef struct _InfdXmppServerPrivate InfdXmppServerPrivate;
16 struct _InfdXmppServerPrivate {
17   InfdTcpServer* tcp;
18   InfdXmppServerStatus status;
19   gchar* local_hostname;
20   InfXmppConnectionSecurityPolicy security_policy;
21   InfCertificateCredentials* tls_creds;
22   InfSaslContext* sasl_context;
23   InfSaslContext* sasl_own_context;
24   gchar* sasl_mechanisms;
25 };
26 enum {
27   PROP_0,
28   PROP_TCP,
29   PROP_LOCAL_HOSTNAME,
30   PROP_CREDENTIALS,
31   PROP_SASL_CONTEXT,
32   PROP_SASL_MECHANISMS,
33   PROP_SECURITY_POLICY,
34   PROP_STATUS
35 };
36 enum {
37   ERROR,
38   LAST_SIGNAL
39 };
40 #define INFD_XMPP_SERVER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFD_TYPE_XMPP_SERVER, InfdXmppServerPrivate))
41 static guint xmpp_server_signals[LAST_SIGNAL];
42 static void infd_xmpp_server_xml_server_iface_init(InfdXmlServerInterface* iface);
43 G_DEFINE_TYPE_WITH_CODE(InfdXmppServer, infd_xmpp_server, G_TYPE_OBJECT,
44   G_ADD_PRIVATE(InfdXmppServer)
45   G_IMPLEMENT_INTERFACE(INFD_TYPE_XML_SERVER, infd_xmpp_server_xml_server_iface_init))
46 static void
47 infd_xmpp_server_new_connection_cb(InfdTcpServer* tcp_server,
48                                    InfTcpConnection* tcp_connection,
49                                    gpointer user_data)
50 {
51   InfdXmppServer* xmpp_server;
52   InfdXmppServerPrivate* priv;
53   InfXmppConnection* xmpp_connection;
54   InfIpAddress* addr;
55   gchar* addr_str;
56   xmpp_server = INFD_XMPP_SERVER(user_data);
57   priv = INFD_XMPP_SERVER_PRIVATE(xmpp_server);
58   g_object_get(G_OBJECT(tcp_connection), "remote-address", &amp;addr, NULL);
59   addr_str = inf_ip_address_to_string(addr);
60   inf_ip_address_free(addr);
61   xmpp_connection = inf_xmpp_connection_new(
62     tcp_connection,
63     INF_XMPP_CONNECTION_SERVER,
64     priv-&gt;local_hostname,
65     addr_str,
66     priv-&gt;security_policy,
67     priv-&gt;tls_creds,
68     priv-&gt;sasl_context,
69     priv-&gt;sasl_own_context != NULL ? "ANONYMOUS" : priv-&gt;sasl_mechanisms
70   );
71   g_free(addr_str);
72   infd_xml_server_new_connection(
73     INFD_XML_SERVER(xmpp_server),
74     INF_XML_CONNECTION(xmpp_connection)
75   );
76   g_object_unref(G_OBJECT(xmpp_connection));
77 }
78 static void
79 infd_xmpp_server_error_cb(InfdTcpServer* tcp_server,
80                           GError* error,
81                           gpointer user_data)
82 {
83   g_signal_emit(
84     G_OBJECT(user_data),
85     xmpp_server_signals[ERROR],
86     0,
87     error
88   );
89 }
90 static void
91 infd_xmpp_server_notify_status_cb(InfdTcpServer* tcp_server,
92                                   GParamSpec* pspec,
93                                   gpointer user_data)
94 {
95   InfdXmppServer* xmpp;
96   InfdXmppServerPrivate* priv;
97   InfdTcpServerStatus status;
98   xmpp = INFD_XMPP_SERVER(user_data);
99   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
100   g_object_get(G_OBJECT(tcp_server), "status", &amp;status, NULL);
101   switch(status)
102   {
103   case INFD_TCP_SERVER_CLOSED:
104   case INFD_TCP_SERVER_BOUND:
105     if(priv-&gt;status != INFD_XMPP_SERVER_CLOSED)
106     {
107       priv-&gt;status = INFD_XMPP_SERVER_CLOSED;
108       g_object_notify(G_OBJECT(xmpp), "status");
109     }
110     break;
111   case INFD_TCP_SERVER_OPEN:
112     if(priv-&gt;status != INFD_XMPP_SERVER_OPEN)
113     {
114       priv-&gt;status = INFD_XMPP_SERVER_OPEN;
115       g_object_notify(G_OBJECT(xmpp), "status");
116     }
117     break;
118   default:
119     g_assert_not_reached();
120     break;
121   }
122 }
123 static void
124 infd_xmpp_server_sasl_cb(InfSaslContextSession* session,
125                          Gsasl_property property,
126                          gpointer session_data,
127                          gpointer user_data)
128 {
129   InfdXmppServer* xmpp;
130   InfdXmppServerPrivate* priv;
131   xmpp = INFD_XMPP_SERVER(user_data);
132   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
133   switch(property)
134   {
135   case GSASL_ANONYMOUS_TOKEN:
136     inf_sasl_context_session_set_property(
137       session,
138       GSASL_ANONYMOUS_TOKEN,
139       priv-&gt;local_hostname
140     );
141     inf_sasl_context_session_continue(session, GSASL_OK);
142     break;
143   case GSASL_VALIDATE_ANONYMOUS:
144     inf_sasl_context_session_continue(session, GSASL_OK);
145     break;
146   default:
147     g_assert_not_reached();
148     inf_sasl_context_session_continue(session, GSASL_NO_CALLBACK);
149     break;
150   }
151 }
152 static void
153 infd_xmpp_server_setup_own_sasl_context(InfdXmppServer* xmpp)
154 {
155   InfdXmppServerPrivate* priv;
156   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
157   g_assert(priv-&gt;sasl_own_context == NULL);
158   if(priv-&gt;sasl_context == NULL &amp;&amp; priv-&gt;tcp != NULL)
159   {
160     priv-&gt;sasl_own_context = inf_sasl_context_new(NULL);
161     if(priv-&gt;sasl_own_context != NULL)
162     {
163       priv-&gt;sasl_context = priv-&gt;sasl_own_context;
164       inf_sasl_context_ref(priv-&gt;sasl_context);
165       inf_sasl_context_set_callback(
166         priv-&gt;sasl_context,
167         infd_xmpp_server_sasl_cb,
168         xmpp,
169         NULL
170       );
171       g_object_notify(G_OBJECT(xmpp), "sasl-context");
172     }
173   }
174 }
175 static void
176 infd_xmpp_server_set_tcp(InfdXmppServer* xmpp,
177                          InfdTcpServer* tcp)
178 {
179   InfdXmppServerPrivate* priv;
180   InfdTcpServerStatus tcp_status;
181   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
182   g_object_freeze_notify(G_OBJECT(xmpp));
183   if(priv-&gt;tcp != NULL)
184   {
185     g_object_get(G_OBJECT(priv-&gt;tcp), "status", &amp;tcp_status, NULL);
186     if(tcp_status != INFD_TCP_SERVER_CLOSED)
187       infd_tcp_server_close(priv-&gt;tcp);
188     if(priv-&gt;sasl_own_context != NULL)
189     {
190       inf_sasl_context_unref(priv-&gt;sasl_own_context);
191       priv-&gt;sasl_own_context = NULL;
192     }
193     inf_signal_handlers_disconnect_by_func(
194       G_OBJECT(priv-&gt;tcp),
195       G_CALLBACK(infd_xmpp_server_new_connection_cb),
196       xmpp
197     );
198     inf_signal_handlers_disconnect_by_func(
199       G_OBJECT(priv-&gt;tcp),
200       G_CALLBACK(infd_xmpp_server_error_cb),
201       xmpp
202     );
203     inf_signal_handlers_disconnect_by_func(
204       G_OBJECT(priv-&gt;tcp),
205       G_CALLBACK(infd_xmpp_server_notify_status_cb),
206       xmpp
207     );
208     g_object_unref(G_OBJECT(priv-&gt;tcp));
209   }
210   priv-&gt;tcp = tcp;
211   if(tcp != NULL)
212   {
213     g_object_ref(G_OBJECT(tcp));
214     g_signal_connect(
215       G_OBJECT(tcp),
216       "new-connection",
217       G_CALLBACK(infd_xmpp_server_new_connection_cb),
218       xmpp
219     );
220     g_signal_connect(
221       G_OBJECT(tcp),
222       "error",
223       G_CALLBACK(infd_xmpp_server_error_cb),
224       xmpp
225     );
226     g_signal_connect(
227       G_OBJECT(tcp),
228       "notify::status",
229       G_CALLBACK(infd_xmpp_server_notify_status_cb),
230       xmpp
231     );
232     g_object_get(G_OBJECT(tcp), "status", &amp;tcp_status, NULL);
233     switch(tcp_status)
234     {
235     case INFD_TCP_SERVER_CLOSED:
236     case INFD_TCP_SERVER_BOUND:
237       g_assert(priv-&gt;status == INFD_XMPP_SERVER_CLOSED);
238       break;
239     case INFD_TCP_SERVER_OPEN:
240       priv-&gt;status = INFD_XMPP_SERVER_OPEN;
241       g_object_notify(G_OBJECT(xmpp), "status");
242       break;
243     default:
244       g_assert_not_reached();
245       break;
246     }
247   }
248   infd_xmpp_server_setup_own_sasl_context(xmpp);
249   g_object_thaw_notify(G_OBJECT(xmpp));
250 }
251 static void
252 infd_xmpp_server_init(InfdXmppServer* xmpp)
253 {
254   InfdXmppServerPrivate* priv;
255   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
256   priv-&gt;tcp = NULL;
257   priv-&gt;status = INFD_XMPP_SERVER_CLOSED;
258   priv-&gt;local_hostname = g_strdup(g_get_host_name());
259   priv-&gt;security_policy = INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED;
260   priv-&gt;tls_creds = NULL;
261   priv-&gt;sasl_context = NULL;
262   priv-&gt;sasl_own_context = NULL;
263   priv-&gt;sasl_mechanisms = NULL;
264 }
265 static void
266 infd_xmpp_server_dispose(GObject* object)
267 {
268   InfdXmppServer* xmpp;
269   InfdXmppServerPrivate* priv;
270   xmpp = INFD_XMPP_SERVER(object);
271   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
272   if(priv-&gt;status != INFD_XMPP_SERVER_CLOSED)
273     infd_xml_server_close(INFD_XML_SERVER(xmpp));
274   infd_xmpp_server_set_tcp(xmpp, NULL);
275   if(priv-&gt;sasl_own_context != NULL)
276   {
277     inf_sasl_context_unref(priv-&gt;sasl_own_context);
278     priv-&gt;sasl_own_context = NULL;
279   }
280   if(priv-&gt;sasl_context != NULL)
281   {
282     inf_sasl_context_unref(priv-&gt;sasl_context);
283     priv-&gt;sasl_context = NULL;
284   }
285   if(priv-&gt;tls_creds != NULL)
286   {
287     inf_certificate_credentials_unref(priv-&gt;tls_creds);
288     priv-&gt;tls_creds = NULL;
289 <a name="1"></a>  }
290   G_OBJECT_CLASS(infd_xmpp_server_parent_class)-&gt;dispose(object);
291 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
292 static void
293 infd_xmpp_server_finalize(GObject* object)
294 {
295   InfdXmppServer* xmpp;
296   InfdXmppServerPrivate* priv;
297   xmpp = INFD_XMPP_SERVER(object);
298   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
299   g_free(priv-&gt;local_hostname);
300   g_free(priv-&gt;sasl_mechanisms);
301   G_OBJECT_CLASS(infd_xmpp_server_parent_class)-&gt;finalize(object);
302 }
303 static void
304 infd_xmpp_server_set_property(GObject* object,
305                               guint prop_id,
306                               const GValue* value,
307                               GParamSpec* pspec)
308 {
309   InfdXmppServer* xmpp;
310   InfdXmppServerPrivate* priv;
311   xmpp = INFD_XMPP_SERVER(object);
312   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
313   switch(prop_id)
314   {
315   case PROP_TCP:</b></font>
316     infd_xmpp_server_set_tcp(
317       xmpp,
318       INFD_TCP_SERVER(g_value_get_object(value))
319     );
320     break;
321   case PROP_LOCAL_HOSTNAME:
322     g_free(priv-&gt;local_hostname);
323     priv-&gt;local_hostname = g_value_dup_string(value);
324     if(priv-&gt;local_hostname == NULL)
325       priv-&gt;local_hostname = g_strdup(g_get_host_name());
326     break;
327   case PROP_CREDENTIALS:
328     if(priv-&gt;tls_creds != NULL)
329       inf_certificate_credentials_unref(priv-&gt;tls_creds);
330     priv-&gt;tls_creds = g_value_dup_boxed(value);
331     break;
332   case PROP_SASL_CONTEXT:
333     if(priv-&gt;sasl_own_context != NULL)
334     {
335       inf_sasl_context_unref(priv-&gt;sasl_own_context);
336       priv-&gt;sasl_own_context = NULL;
337     }
338     if(priv-&gt;sasl_context != NULL)
339       inf_sasl_context_unref(priv-&gt;sasl_context);
340     priv-&gt;sasl_context = g_value_dup_boxed(value);
341     infd_xmpp_server_setup_own_sasl_context(xmpp);
342     break;
343 <a name="2"></a>  case PROP_SASL_MECHANISMS:
344     g_free(priv-&gt;sasl_mechanisms);
345     priv-&gt;sasl_mechanisms = g_value_dup_string(value);
346 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
347   case PROP_SECURITY_POLICY:
348     infd_xmpp_server_set_security_policy(xmpp, g_value_get_enum(value));
349     break;
350   default:
351     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
352     break;
353   }
354 }
355 static void
356 infd_xmpp_server_get_property(GObject* object,
357                               guint prop_id,
358                               GValue* value,
359                               GParamSpec* pspec)
360 {
361   InfdXmppServer* xmpp;
362   InfdXmppServerPrivate* priv;
363   xmpp = INFD_XMPP_SERVER(object);
364   priv = INFD_XMPP_SERVER_PRIVATE(xmpp);</b></font>
365   switch(prop_id)
366   {
367   case PROP_STATUS:
368     switch(priv-&gt;status)
369     {
370     case INFD_XMPP_SERVER_CLOSED:
371       g_value_set_enum(value, INFD_XML_SERVER_CLOSED);
372       break;
373     case INFD_XMPP_SERVER_OPEN:
374       g_value_set_enum(value, INFD_XML_SERVER_OPEN);
375       break;
376     default:
377       g_assert_not_reached();
378       break;
379     }
380     break;
381   case PROP_TCP:
382     g_value_set_object(value, priv-&gt;tcp);
383 <a name="0"></a>    break;
384   case PROP_LOCAL_HOSTNAME:
385     g_value_set_string(value, priv-&gt;local_hostname);
386 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
387   case PROP_CREDENTIALS:
388     g_value_set_boxed(value, priv-&gt;tls_creds);
389     break;
390   case PROP_SASL_CONTEXT:
391     g_value_set_boxed(value, priv-&gt;sasl_context);
392     break;
393   case PROP_SASL_MECHANISMS:
394     g_value_set_string(value, priv-&gt;sasl_mechanisms);
395     break;
396   case PROP_SECURITY_POLICY:
397     g_value_set_enum(value, priv-&gt;security_policy);
398     break;
399   default:
400     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
401     break;
402   }
403 }
404 static void
405 infd_xmpp_server_xml_server_close(InfdXmlServer* xml)
406 {
407   InfdXmppServerPrivate* priv;
408   priv = INFD_XMPP_SERVER_PRIVATE(xml);</b></font>
409   g_return_if_fail(priv-&gt;status != INFD_XMPP_SERVER_CLOSED);
410   switch(priv-&gt;status)
411   {
412   case INFD_XMPP_SERVER_OPEN:
413     infd_tcp_server_close(priv-&gt;tcp);
414     break;
415   case INFD_XMPP_SERVER_CLOSED:
416   default:
417     g_assert_not_reached();
418     break;
419   }
420 }
421 static void
422 infd_xmpp_server_class_init(InfdXmppServerClass* xmpp_class)
423 {
424   GObjectClass* object_class;
425   object_class = G_OBJECT_CLASS(xmpp_class);
426   object_class-&gt;dispose = infd_xmpp_server_dispose;
427   object_class-&gt;finalize = infd_xmpp_server_finalize;
428   object_class-&gt;set_property = infd_xmpp_server_set_property;
429   object_class-&gt;get_property = infd_xmpp_server_get_property;
430   xmpp_class-&gt;error = NULL;
431   g_object_class_install_property(
432     object_class,
433     PROP_TCP,
434     g_param_spec_object(
435       "tcp-server",
436       "TCP server",
437       "Underlaying TCP server",
438       INFD_TYPE_TCP_SERVER,
439       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
440     )
441   );
442   g_object_class_install_property(
443     object_class,
444     PROP_LOCAL_HOSTNAME,
445     g_param_spec_string(
446       "local-hostname",
447       "Local hostname",
448       "Hostname of the server",
449       NULL,
450       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
451     )
452   );
453   g_object_class_install_property(
454     object_class,
455     PROP_CREDENTIALS,
456     g_param_spec_boxed(
457       "credentials",
458       "Credentials",
459       "The certificate credentials for GnuTLS",
460       INF_TYPE_CERTIFICATE_CREDENTIALS,
461       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
462     )
463   );
464   g_object_class_install_property(
465     object_class,
466     PROP_SASL_CONTEXT,
467     g_param_spec_boxed(
468       "sasl-context",
469       "SASL context",
470       "The SASL context used for authentaction",
471       INF_TYPE_SASL_CONTEXT,
472       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
473     )
474   );
475   g_object_class_install_property(
476     object_class,
477     PROP_SASL_MECHANISMS,
478     g_param_spec_string(
479       "sasl-mechanisms",
480       "SASL mechanisms",
481       "The SASL mechanisms offered to the client for authentication",
482       NULL,
483       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
484     )
485   );
486   g_object_class_install_property(
487     object_class,
488     PROP_SECURITY_POLICY,
489     g_param_spec_enum(
490       "security-policy",
491       "Security policy",
492       "Whether to offer or require TLS",
493       INF_TYPE_XMPP_CONNECTION_SECURITY_POLICY,
494       INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED,
495       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
496     )
497   );
498   g_object_class_override_property(object_class, PROP_STATUS, "status");
499   xmpp_server_signals[ERROR] = g_signal_new(
500     "error",
501     G_OBJECT_CLASS_TYPE(object_class),
502     G_SIGNAL_RUN_LAST,
503     G_STRUCT_OFFSET(InfdXmppServerClass, error),
504     NULL, NULL,
505     g_cclosure_marshal_VOID__BOXED,
506     G_TYPE_NONE,
507     1,
508     G_TYPE_ERROR
509   );
510 }
511 static void
512 infd_xmpp_server_xml_server_iface_init(InfdXmlServerInterface* iface)
513 {
514   iface-&gt;close = infd_xmpp_server_xml_server_close;
515 }
516 InfdXmppServer*
517 infd_xmpp_server_new(InfdTcpServer* tcp,
518                      InfXmppConnectionSecurityPolicy policy,
519                      InfCertificateCredentials* creds,
520                      InfSaslContext* sasl_context,
521                      const gchar* sasl_mechanisms)
522 {
523   GObject* object;
524   g_return_val_if_fail(INFD_IS_TCP_SERVER(tcp), NULL);
525   g_return_val_if_fail(
526     policy == INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED || creds != NULL,
527     NULL
528   );
529   object = g_object_new(
530     INFD_TYPE_XMPP_SERVER,
531     "tcp-server", tcp,
532     "credentials", creds,
533     "security-policy", policy,
534     "sasl-context", sasl_context,
535     "sasl-mechanisms", sasl_mechanisms,
536     NULL
537   );
538   return INFD_XMPP_SERVER(object);
539 }
540 void
541 infd_xmpp_server_set_security_policy(InfdXmppServer* server,
542                                      InfXmppConnectionSecurityPolicy policy)
543 {
544   InfdXmppServerPrivate* priv;
545   g_return_if_fail(INFD_IS_XMPP_SERVER(server));
546   priv = INFD_XMPP_SERVER_PRIVATE(server);
547   if(policy != priv-&gt;security_policy)
548   {
549     g_return_if_fail(
550       policy == INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED ||
551       priv-&gt;tls_creds != NULL
552     );
553     priv-&gt;security_policy = policy;
554     g_object_notify(G_OBJECT(server), "security-policy");
555   }
556 }
557 InfXmppConnectionSecurityPolicy
558 infd_xmpp_server_get_security_policy(InfdXmppServer* server)
559 {
560   g_return_val_if_fail(
561     INFD_IS_XMPP_SERVER(server),
562     INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS
563   );
564   return INFD_XMPP_SERVER_PRIVATE(server)-&gt;security_policy;
565 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-gtk-buffer.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinftextgtk/inf-text-gtk-buffer.h&gt;
2 #include &lt;libinftext/inf-text-buffer.h&gt;
3 #include &lt;libinfinity/inf-signals.h&gt;
4 #include &lt;string.h&gt; 
5 struct _InfTextBufferIter {
6   GtkTextIter begin;
7   GtkTextIter end;
8   InfTextUser* user;
9 };
10 typedef struct _InfTextGtkBufferRecord InfTextGtkBufferRecord;
11 struct _InfTextGtkBufferRecord {
12   gboolean insert;
13   guint char_count;
14   guint position;
15   InfTextChunk* chunk;
16   gboolean applied;
17   InfTextGtkBufferRecord* next;
18 };
19 typedef struct _InfTextGtkBufferUserTags InfTextGtkBufferUserTags;
20 struct _InfTextGtkBufferUserTags {
21   InfTextGtkBuffer* buffer;
22   InfTextUser* user;
23   GtkTextTag* colored_tag;
24   GtkTextTag* colorless_tag;
25 };
26 typedef struct _InfTextGtkBufferTagRemove InfTextGtkBufferTagRemove;
27 struct _InfTextGtkBufferTagRemove {
28   GtkTextBuffer* buffer;
29   GtkTextIter begin_iter;
30   GtkTextIter end_iter;
31   InfTextGtkBufferUserTags* ignore_tags;
32 };
33 typedef struct _InfTextGtkBufferPrivate InfTextGtkBufferPrivate;
34 struct _InfTextGtkBufferPrivate {
35   GtkTextBuffer* buffer;
36   InfUserTable* user_table;
37   GHashTable* user_tags;
38   InfTextGtkBufferRecord* record;
39   gboolean show_user_colors;
40   InfTextUser* active_user;
41   gboolean wake_on_cursor_movement;
42   gdouble saturation;
43   gdouble value;
44   gdouble alpha;
45 };
46 enum {
47   PROP_0,
48   PROP_BUFFER,
49   PROP_USER_TABLE,
50   PROP_ACTIVE_USER,
51   PROP_WAKE_ON_CURSOR_MOVEMENT,
52   PROP_SHOW_USER_COLORS,
53   PROP_SATURATION,
54   PROP_VALUE,
55   PROP_ALPHA,
56   PROP_MODIFIED
57 };
58 #define INF_TEXT_GTK_BUFFER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_GTK_TYPE_BUFFER, InfTextGtkBufferPrivate))
59 static GQuark inf_text_gtk_buffer_tag_user_quark;
60 static void inf_text_gtk_buffer_buffer_iface_init(InfBufferInterface* iface);
61 static void inf_text_gtk_buffer_text_buffer_iface_init(InfTextBufferInterface* iface);
62 G_DEFINE_TYPE_WITH_CODE(InfTextGtkBuffer, inf_text_gtk_buffer, G_TYPE_OBJECT,
63   G_ADD_PRIVATE(InfTextGtkBuffer)
64   G_IMPLEMENT_INTERFACE(INF_TYPE_BUFFER, inf_text_gtk_buffer_buffer_iface_init)
65   G_IMPLEMENT_INTERFACE(INF_TEXT_TYPE_BUFFER, inf_text_gtk_buffer_text_buffer_iface_init))
66 static void
67 inf_text_gtk_update_tag_color(InfTextGtkBuffer* buffer,
68                               GtkTextTag* tag,
69                               InfTextUser* user)
70 {
71   InfTextGtkBufferPrivate* priv;
72   gdouble hue;
73   gdouble saturation;
74   gdouble value;
75   GdkRGBA rgba;
76   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
77   hue = inf_text_user_get_hue(user);
78   saturation = priv-&gt;saturation;
79   value = priv-&gt;value;
80   gtk_hsv_to_rgb(hue, saturation, value, &amp;rgba.red, &amp;rgba.green, &amp;rgba.blue);
81   rgba.alpha = priv-&gt;alpha;
82   g_object_set(G_OBJECT(tag), "background-rgba", &amp;rgba, NULL);
83 }
84 static void
85 inf_text_gtk_user_notify_hue_cb(GObject* object,
86                                 GParamSpec* pspec,
87                                 gpointer user_data)
88 {
89   InfTextGtkBuffer* buffer;
90   InfTextGtkBufferPrivate* priv;
91   guint user_id;
92   InfTextGtkBufferUserTags* tags;
93   buffer = INF_TEXT_GTK_BUFFER(user_data);
94   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
95   user_id = inf_user_get_id(INF_USER(object));
96   tags = g_hash_table_lookup(priv-&gt;user_tags, GUINT_TO_POINTER(user_id));
97   g_assert(tags != NULL &amp;&amp; tags-&gt;colored_tag != NULL);
98   inf_text_gtk_update_tag_color(
99     buffer,
100     tags-&gt;colored_tag,
101     INF_TEXT_USER(object)
102   );
103 }
104 static void
105 inf_text_gtk_buffer_user_tags_free(gpointer user_tags)
106 {
107   InfTextGtkBufferUserTags* tags;
108   tags = (InfTextGtkBufferUserTags*)user_tags;
109   if(tags-&gt;colored_tag)
110   {
111     inf_signal_handlers_disconnect_by_func(
112       tags-&gt;user,
113       G_CALLBACK(inf_text_gtk_user_notify_hue_cb),
114       tags-&gt;buffer
115     );
116     g_object_unref(tags-&gt;colored_tag);
117   }
118   if(tags-&gt;colorless_tag)
119     g_object_unref(tags-&gt;colorless_tag);
120   g_slice_free(InfTextGtkBufferUserTags, tags);
121 }
122 static InfTextGtkBufferUserTags*
123 inf_text_gtk_buffer_get_user_tags(InfTextGtkBuffer* buffer,
124                                   guint user_id)
125 {
126   InfTextGtkBufferPrivate* priv;
127   InfTextGtkBufferUserTags* tags;
128   InfUser* user;
129   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
130   if(user_id == 0)
131     return NULL;
132   tags = g_hash_table_lookup(priv-&gt;user_tags, GUINT_TO_POINTER(user_id));
133   if(tags != NULL)
134   {
135     return tags;
136   }
137   else
138   {
139     user = inf_user_table_lookup_user_by_id(priv-&gt;user_table, user_id);
140     g_assert(INF_TEXT_IS_USER(user));
141     tags = g_slice_new(InfTextGtkBufferUserTags);
142     tags-&gt;buffer = buffer;
143     tags-&gt;user = INF_TEXT_USER(user);
144     tags-&gt;colored_tag = NULL;
145     tags-&gt;colorless_tag = NULL;
146     g_hash_table_insert(priv-&gt;user_tags, GUINT_TO_POINTER(user_id), tags);
147     return tags;
148   }
149 }
150 static GtkTextTag*
151 inf_text_gtk_buffer_get_user_tag(InfTextGtkBuffer* buffer,
152                                  InfTextGtkBufferUserTags* user_tags,
153                                  gboolean colored)
154 {
155   InfTextGtkBufferPrivate* priv;
156   GtkTextTagTable* table;
157   GtkTextTag** tag;
158   gchar* tag_name;
159   guint user_id;
160   const gchar* colorstr;
161   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
162   tag = colored ? &amp;user_tags-&gt;colored_tag : &amp;user_tags-&gt;colorless_tag;
163   if(*tag != NULL) return *tag;
164   user_id = 0;
165   if(user_tags-&gt;user != NULL)
166     user_id = inf_user_get_id(INF_USER(user_tags-&gt;user));
167   colorstr = colored ? "colored" : "colorless";
168   tag_name = g_strdup_printf("inftextgtk-user-%s-%u", colorstr, user_id);
169   *tag = gtk_text_tag_new(tag_name);
170   g_free(tag_name);
171   table = gtk_text_buffer_get_tag_table(priv-&gt;buffer);
172   gtk_text_tag_table_add(table, *tag);
173   gtk_text_tag_set_priority(*tag, 0);
174   g_object_set_qdata(
175     G_OBJECT(*tag),
176     inf_text_gtk_buffer_tag_user_quark,
177     user_tags-&gt;user
178   );
179   if(colored)
180   {
181     g_signal_connect(
182       G_OBJECT(user_tags-&gt;user),
183       "notify::hue",
184       G_CALLBACK(inf_text_gtk_user_notify_hue_cb),
185       buffer
186     );
187     inf_text_gtk_update_tag_color(buffer, *tag, user_tags-&gt;user);
188   }
189   return *tag;
190 }
191 static InfTextUser*
192 inf_text_gtk_buffer_author_from_tag(GtkTextTag* tag)
193 {
194   gpointer author_ptr;
195   author_ptr = g_object_get_qdata(
196     G_OBJECT(tag),
197     inf_text_gtk_buffer_tag_user_quark
198   );
199   return INF_TEXT_USER(author_ptr);
200 }
201 static InfTextUser*
202 inf_text_gtk_buffer_iter_list_contains_author_tag(GSList* tag_list)
203 {
204   GSList* item;
205   InfTextUser* author;
206   for(item = tag_list; item != NULL; item = g_slist_next(item))
207   {
208     author = inf_text_gtk_buffer_author_from_tag(GTK_TEXT_TAG(item-&gt;data));
209     if(author != NULL) return author;
210   }
211   return NULL;
212 }
213 static InfTextUser*
214 inf_text_gtk_buffer_iter_get_author(GtkTextIter* location)
215 {
216   GSList* tag_list;
217   InfTextUser* author;
218   tag_list = gtk_text_iter_get_tags(location);
219   author = inf_text_gtk_buffer_iter_list_contains_author_tag(tag_list);
220   g_slist_free(tag_list);
221   return author;
222 }
223 static gboolean
224 inf_text_gtk_buffer_iter_is_author_toggle(const GtkTextIter* iter,
225                                           InfTextUser** toggled_on,
226                                           InfTextUser** toggled_off)
227 {
228   GSList* tag_list;
229   InfTextUser* author_on;
230   InfTextUser* author_off;
231   tag_list = gtk_text_iter_get_toggled_tags(iter, TRUE);
232   author_on = inf_text_gtk_buffer_iter_list_contains_author_tag(tag_list);
233   g_slist_free(tag_list);
234   if(author_on == NULL || toggled_off != NULL)
235   {
236     tag_list = gtk_text_iter_get_toggled_tags(iter, FALSE);
237     author_off = inf_text_gtk_buffer_iter_list_contains_author_tag(tag_list);
238     g_slist_free(tag_list);
239   }
240   if(author_on == NULL &amp;&amp; author_off == NULL)
241     if(!gtk_text_iter_is_start(iter) &amp;&amp; !gtk_text_iter_is_end(iter))
242       return FALSE;
243   if(toggled_on) *toggled_on = author_on;
244   if(toggled_off) *toggled_off = author_off;
245   return TRUE;
246 }
247 static void
248 inf_text_gtk_buffer_iter_next_author_toggle(GtkTextIter* iter,
249                                             InfTextUser** user_on,
250                                             InfTextUser** user_off)
251 {
252   gboolean is_author_toggle;
253   do
254   {
255     gtk_text_iter_forward_to_tag_toggle(iter, NULL);
256     is_author_toggle = inf_text_gtk_buffer_iter_is_author_toggle(
257       iter,
258       user_on,
259       user_off
260     );
261   } while(!is_author_toggle);
262 }
263 static void
264 inf_text_gtk_buffer_iter_prev_author_toggle(GtkTextIter* iter,
265                                             InfTextUser** user_on,
266                                             InfTextUser** user_off)
267 {
268   gboolean is_author_toggle;
269   do
270   {
271     gtk_text_iter_backward_to_tag_toggle(iter, NULL);
272     is_author_toggle = inf_text_gtk_buffer_iter_is_author_toggle(
273       iter,
274       user_on,
275       user_off
276     );
277   } while(!is_author_toggle);
278 }
279 static void
280 inf_text_gtk_buffer_ensure_author_tags_priority_foreach_func(GtkTextTag* tag,
281                                                              gpointer data)
282 {
283   InfTextUser* author;
284   author = inf_text_gtk_buffer_author_from_tag(tag);
285   if(author != NULL)
286     gtk_text_tag_set_priority(tag, 0);
287 }
288 static void
289 inf_text_gtk_buffer_update_user_color_tag_table_foreach_func(GtkTextTag* tag,
290                                                              gpointer data)
291 {
292   InfTextGtkBuffer* buffer;
293   InfTextGtkBufferPrivate* priv;
294   InfTextUser* author;
295   buffer = INF_TEXT_GTK_BUFFER(data);
296   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
297   author = inf_text_gtk_buffer_author_from_tag(tag);
298   if(author != NULL)
299     inf_text_gtk_update_tag_color(buffer, tag, author);
300 }
301 static void
302 inf_text_gtk_buffer_active_user_selection_changed_cb(InfTextUser* user,
303                                                      guint position,
304                                                      gint length,
305                                                      gboolean by_request,
306                                                      gpointer user_data);
307 static void
308 inf_text_gtk_buffer_active_user_notify_status_cb(GObject* object,
309                                                  GParamSpec* pspec,
310                                                  gpointer user_data);
311 static void
312 inf_text_gtk_buffer_apply_tag_cb(GtkTextBuffer* gtk_buffer,
313                                  GtkTextTag* tag,
314                                  GtkTextIter* start,
315                                  GtkTextIter* end,
316                                  gpointer user_data)
317 {
318   if(inf_text_gtk_buffer_author_from_tag(tag) != NULL)
319     g_signal_stop_emission_by_name(G_OBJECT(gtk_buffer), "apply-tag");
320 }
321 static void
322 inf_text_gtk_buffer_buffer_insert_text_tag_table_foreach_func(GtkTextTag* tag,
323                                                               gpointer data)
324 {
325   InfTextGtkBufferTagRemove* tag_remove;
326   tag_remove = (InfTextGtkBufferTagRemove*)data;
327   if(tag_remove-&gt;ignore_tags == NULL ||
328      (tag != tag_remove-&gt;ignore_tags-&gt;colored_tag &amp;&amp;
329       tag != tag_remove-&gt;ignore_tags-&gt;colorless_tag))
330   {
331     gtk_text_buffer_remove_tag(
332       tag_remove-&gt;buffer,
333       tag,
334       &amp;tag_remove-&gt;begin_iter,
335       &amp;tag_remove-&gt;end_iter
336     );
337   }
338 }
339 #ifndef G_DISABLE_ASSERT
340 static gboolean
341 inf_text_gtk_buffer_record_check(InfTextGtkBuffer* buffer,
342                                  InfTextGtkBufferRecord* record)
343 {
344   InfTextGtkBufferPrivate* priv;
345   InfTextChunk* chunk;
346   guint text_len;
347   guint buf_len;
348   gpointer buf_text;
349   gpointer chunk_text;
350   gsize buf_bytes;
351   gsize chunk_bytes;
352   int result;
353   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
354   text_len = inf_text_chunk_get_length(record-&gt;chunk);
355   buf_len = gtk_text_buffer_get_char_count(priv-&gt;buffer);
356   if(record-&gt;insert)
357   {
358     if(record-&gt;char_count + text_len != buf_len)
359       return FALSE;
360     if(record-&gt;position + text_len &gt; buf_len)
361       return FALSE;
362     chunk = inf_text_buffer_get_slice(
363       INF_TEXT_BUFFER(buffer),
364       record-&gt;position,
365       text_len
366     );
367     buf_text = inf_text_chunk_get_text(record-&gt;chunk, &amp;buf_bytes);
368     chunk_text = inf_text_chunk_get_text(chunk, &amp;chunk_bytes);
369     inf_text_chunk_free(chunk);
370     if(buf_bytes == chunk_bytes)
371       result = memcmp(buf_text, chunk_text, buf_bytes);
372     else
373       result = -1;
374     g_free(buf_text);
375     g_free(chunk_text);
376     if(result != 0) return FALSE;
377   }
378   else
379   {
380     if(text_len &gt; record-&gt;char_count)
381       return FALSE;
382     if(record-&gt;char_count - text_len != buf_len)
383       return FALSE;
384   }
385   return TRUE;
386 }
387 #endif
388 static void
389 inf_text_gtk_buffer_record_transform(InfTextGtkBufferRecord* record,
390                                      InfTextGtkBufferRecord* against)
391 {
392   guint record_len;
393   guint against_len;
394   g_assert(record-&gt;applied == FALSE);
395   g_assert(against-&gt;applied == TRUE);
396   record_len = inf_text_chunk_get_length(record-&gt;chunk);
397   against_len = inf_text_chunk_get_length(against-&gt;chunk);
398   if(record-&gt;insert &amp;&amp; against-&gt;insert)
399   {
400     if(record-&gt;position &gt;= against-&gt;position)
401       record-&gt;position += against_len;
402   }
403   else if(record-&gt;insert &amp;&amp; !against-&gt;insert)
404   {
405     if(record-&gt;position &gt;= against-&gt;position + against_len)
406       record-&gt;position -= against_len;
407     else if(record-&gt;position &gt;= against-&gt;position)
408       record-&gt;position = against-&gt;position;
409   }
410   else if(!record-&gt;insert &amp;&amp; against-&gt;insert)
411   {
412     if(record-&gt;position &gt;= against-&gt;position)
413     {
414       record-&gt;position += against-&gt;position;
415     }
416     else if(record-&gt;position &lt; against-&gt;position &amp;&amp;
417             record-&gt;position + record_len &gt; against-&gt;position)
418     {
419       inf_text_chunk_insert_chunk(
420         record-&gt;chunk,
421         against-&gt;position - record-&gt;position,
422         against-&gt;chunk
423       );
424     }
425   }
426   else if(!record-&gt;insert &amp;&amp; !against-&gt;insert)
427   {
428     if(against-&gt;position + against_len &lt;= record-&gt;position + record_len)
429     {
430       record-&gt;position -= against_len;
431     }
432     else if(against-&gt;position + against_len &gt; record-&gt;position &amp;&amp;
433             against-&gt;position + against_len &lt;= record-&gt;position + record_len)
434     {
435       record-&gt;position = against-&gt;position;
436       inf_text_chunk_erase(
437         record-&gt;chunk,
438         0,
439         against-&gt;position + against_len - record-&gt;position
440       );
441     }
442     else if(against-&gt;position &lt;= record-&gt;position &amp;&amp;
443             against-&gt;position + against_len &gt;= record-&gt;position + record_len)
444     {
445       record-&gt;position = against-&gt;position;
446       inf_text_chunk_erase(
447         record-&gt;chunk,
448         0,
449         inf_text_chunk_get_length(record-&gt;chunk)
450       );
451     }
452     else if(against-&gt;position &gt;= record-&gt;position &amp;&amp;
453             against-&gt;position + against_len &lt;= record-&gt;position + record_len)
454     {
455       inf_text_chunk_erase(
456         record-&gt;chunk,
457         against-&gt;position - record-&gt;position,
458         inf_text_chunk_get_length(against-&gt;chunk)
459       );
460     }
461     else if(against-&gt;position &gt;= record-&gt;position &amp;&amp;
462             against-&gt;position + against_len &gt;= record-&gt;position + record_len)
463     {
464       inf_text_chunk_erase(
465         record-&gt;chunk,
466         against-&gt;position - record-&gt;position,
467         record-&gt;position + record_len - against-&gt;position
468       );
469     }
470   }
471   if(against-&gt;insert)
472   {
473     record-&gt;char_count += against_len;
474   }
475   else
476   {
477     g_assert(record-&gt;char_count &gt;= against_len);
478     record-&gt;char_count -= against_len;
479   }
480 }
481 static void
482 inf_text_gtk_buffer_record_signal(InfTextGtkBuffer* buffer,
483                                   InfTextGtkBufferRecord* record)
484 {
485   InfTextGtkBufferPrivate* priv;
486   InfTextGtkBufferRecord* rec;
487   InfTextGtkBufferTagRemove tag_remove;
488   GtkTextTag* tag;
489   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
490   g_assert(priv-&gt;active_user != NULL);
491   g_assert(record-&gt;applied == FALSE);
492   g_assert(inf_text_gtk_buffer_record_check(buffer, record));
493   record-&gt;applied = TRUE;
494   for(rec = record-&gt;next; rec != NULL; rec = rec-&gt;next)
495     if(!rec-&gt;applied)
496       inf_text_gtk_buffer_record_transform(rec-&gt;next, record);
497   if(record-&gt;insert)
498   {
499     inf_signal_handlers_block_by_func(
500       G_OBJECT(priv-&gt;buffer),
501       G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
502       buffer
503     );
504     tag_remove.buffer = priv-&gt;buffer;
505     tag_remove.ignore_tags = inf_text_gtk_buffer_get_user_tags(
506       buffer,
507       inf_user_get_id(INF_USER(priv-&gt;active_user))
508     );
509     g_assert(tag_remove.ignore_tags != NULL);
510     tag = inf_text_gtk_buffer_get_user_tag(
511       buffer,
512       tag_remove.ignore_tags,
513       priv-&gt;show_user_colors
514     );
515     gtk_text_buffer_get_iter_at_offset(
516       priv-&gt;buffer,
517       &amp;tag_remove.begin_iter,
518       record-&gt;position
519     );
520     gtk_text_buffer_get_iter_at_offset(
521       priv-&gt;buffer,
522       &amp;tag_remove.end_iter,
523       record-&gt;position + inf_text_chunk_get_length(record-&gt;chunk)
524     );
525     gtk_text_tag_table_foreach(
526       gtk_text_buffer_get_tag_table(tag_remove.buffer),
527       inf_text_gtk_buffer_buffer_insert_text_tag_table_foreach_func,
528       &amp;tag_remove
529     );
530     gtk_text_buffer_apply_tag(
531       priv-&gt;buffer,
532       tag,
533       &amp;tag_remove.begin_iter,
534       &amp;tag_remove.end_iter
535     );
536     inf_signal_handlers_unblock_by_func(
537       G_OBJECT(priv-&gt;buffer),
538       G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
539       buffer
540     );
541   }
542   inf_signal_handlers_block_by_func(
543     G_OBJECT(priv-&gt;active_user),
544     G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
545     buffer
546   );
547   inf_signal_handlers_block_by_func(
548     G_OBJECT(priv-&gt;active_user),
549     G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
550     buffer
551   );
552   if(record-&gt;insert)
553   {
554     inf_text_buffer_text_inserted(
555       INF_TEXT_BUFFER(buffer),
556       record-&gt;position,
557       record-&gt;chunk,
558       INF_USER(priv-&gt;active_user)
559     );
560   }
561   else
562   {
563     inf_text_buffer_text_erased(
564       INF_TEXT_BUFFER(buffer),
565       record-&gt;position,
566       record-&gt;chunk,
567       INF_USER(priv-&gt;active_user)
568     );
569   }
570   inf_signal_handlers_unblock_by_func(
571     G_OBJECT(priv-&gt;active_user),
572     G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
573     buffer
574   );
575   inf_signal_handlers_unblock_by_func(
576     G_OBJECT(priv-&gt;active_user),
577     G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
578     buffer
579   );
580 }
581 static void
582 inf_text_gtk_buffer_push_record(InfTextGtkBuffer* buffer,
583                                 gboolean insert,
584                                 guint position,
585                                 InfTextChunk* chunk)
586 {
587   InfTextGtkBufferPrivate* priv;
588   InfTextGtkBufferRecord* rec;
589   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
590   rec = priv-&gt;record;
591   priv-&gt;record = g_slice_new(InfTextGtkBufferRecord);
592   priv-&gt;record-&gt;insert = insert;
593   priv-&gt;record-&gt;char_count = gtk_text_buffer_get_char_count(priv-&gt;buffer);
594   priv-&gt;record-&gt;position = position;
595   priv-&gt;record-&gt;chunk = chunk;
596   priv-&gt;record-&gt;applied = FALSE;
597   priv-&gt;record-&gt;next = rec;
598   if(rec != NULL &amp;&amp; rec-&gt;applied == FALSE)
599   {
600     if(rec-&gt;char_count != (guint)gtk_text_buffer_get_char_count(priv-&gt;buffer))
601     {
602       inf_text_gtk_buffer_record_signal(buffer, rec);
603 #ifndef G_ASSERT_DISABLED
604       for(; rec != NULL; rec = rec-&gt;next)
605       {
606         g_assert(
607           rec-&gt;applied == TRUE ||
608           rec-&gt;char_count ==
609             (guint)gtk_text_buffer_get_char_count(priv-&gt;buffer)
610         );
611       }
612 #endif
613     }
614   }
615 }
616 static void
617 inf_text_gtk_buffer_pop_record(InfTextGtkBuffer* buffer)
618 {
619   InfTextGtkBufferPrivate* priv;
620   InfTextGtkBufferRecord* rec;
621   guint char_count;
622   guint length;
623   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
624   g_assert(priv-&gt;record != NULL);
625   if(!priv-&gt;record-&gt;applied)
626   {
627     length = inf_text_chunk_get_length(priv-&gt;record-&gt;chunk);
628     char_count = gtk_text_buffer_get_char_count(priv-&gt;buffer);
629     if(priv-&gt;record-&gt;insert)
630     {
631       g_assert(priv-&gt;record-&gt;char_count + length == char_count);
632     }
633     else
634     {
635       g_assert(priv-&gt;record-&gt;char_count &gt;= length);
636       g_assert(priv-&gt;record-&gt;char_count - length == char_count);
637     }
638     inf_text_gtk_buffer_record_signal(buffer, priv-&gt;record);
639   }
640   rec = priv-&gt;record;
641   priv-&gt;record = rec-&gt;next;
642   inf_text_chunk_free(rec-&gt;chunk);
643   g_slice_free(InfTextGtkBufferRecord, rec);
644 }
645 static void
646 inf_text_gtk_buffer_insert_text_cb_before(GtkTextBuffer* gtk_buffer,
647                                           GtkTextIter* location,
648                                           gchar* text,
649                                           gint len,
650                                           gpointer user_data)
651 {
652   InfTextGtkBuffer* buffer;
653   InfTextGtkBufferPrivate* priv;
654   InfTextChunk* chunk;
655   buffer = INF_TEXT_GTK_BUFFER(user_data);
656   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
657   g_assert(priv-&gt;active_user != NULL);
658   chunk = inf_text_chunk_new("UTF-8");
659   inf_text_chunk_insert_text(
660     chunk,
661     0,
662     text,
663     len,
664     g_utf8_strlen(text, len),
665     inf_user_get_id(INF_USER(priv-&gt;active_user))
666   );
667   inf_text_gtk_buffer_push_record(
668     buffer,
669     TRUE,
670     gtk_text_iter_get_offset(location),
671     chunk
672   );
673 }
674 static void
675 inf_text_gtk_buffer_insert_text_cb_after(GtkTextBuffer* gtk_buffer,
676                                          GtkTextIter* location,
677                                          gchar* text,
678                                          gint len,
679                                          gpointer user_data)
680 {
681   InfTextGtkBuffer* buffer;
682   InfTextGtkBufferPrivate* priv;
683   gpointer rec_text;
684   gsize bytes;
685   buffer = INF_TEXT_GTK_BUFFER(user_data);
686   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
687   g_assert(priv-&gt;record != NULL);
688   g_assert(priv-&gt;record-&gt;insert == TRUE);
689 #ifndef G_ASSERT_DISABLED
690   if(priv-&gt;record-&gt;applied == FALSE)
691   {
692     g_assert(
693       priv-&gt;record-&gt;position +
694         inf_text_chunk_get_length(priv-&gt;record-&gt;chunk) ==
695       (guint)gtk_text_iter_get_offset(location)
696     );
697     rec_text = inf_text_chunk_get_text(priv-&gt;record-&gt;chunk, &amp;bytes);
698     g_assert(bytes == (gsize)len);
699     g_assert(memcmp(text, rec_text, bytes) == 0);
700     g_free(rec_text);
701   }
702 #endif
703   inf_text_gtk_buffer_pop_record(buffer);
704 }
705 static void
706 inf_text_gtk_buffer_delete_range_cb_before(GtkTextBuffer* gtk_buffer,
707                                            GtkTextIter* begin,
708                                            GtkTextIter* end,
709                                            gpointer user_data)
710 {
711   InfTextGtkBuffer* buffer;
712   InfTextGtkBufferPrivate* priv;
713   guint begin_offset;
714   guint end_offset;
715   InfTextChunk* chunk;
716   buffer = INF_TEXT_GTK_BUFFER(user_data);
717   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
718   begin_offset = gtk_text_iter_get_offset(begin);
719   end_offset = gtk_text_iter_get_offset(end);
720   chunk = inf_text_buffer_get_slice(
721     INF_TEXT_BUFFER(buffer),
722     begin_offset,
723     end_offset - begin_offset
724   );
725   inf_text_gtk_buffer_push_record(buffer, FALSE, begin_offset, chunk);
726 }
727 static void
728 inf_text_gtk_buffer_delete_range_cb_after(GtkTextBuffer* gtk_buffer,
729                                           GtkTextIter* begin,
730                                           GtkTextIter* end,
731                                           gpointer user_data)
732 {
733   InfTextGtkBuffer* buffer;
734   InfTextGtkBufferPrivate* priv;
735   buffer = INF_TEXT_GTK_BUFFER(user_data);
736   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
737   g_assert(priv-&gt;record != NULL);
738   g_assert(priv-&gt;record-&gt;insert == FALSE);
739   g_assert(priv-&gt;record-&gt;applied == TRUE ||
740            priv-&gt;record-&gt;position == (guint)gtk_text_iter_get_offset(begin));
741   inf_text_gtk_buffer_pop_record(buffer);
742 }
743 static void
744 inf_text_gtk_buffer_mark_set_cb(GtkTextBuffer* gtk_buffer,
745                                 GtkTextIter* location,
746                                 GtkTextMark* mark,
747                                 gpointer user_data)
748 {
749   InfTextGtkBuffer* buffer;
750   InfTextGtkBufferPrivate* priv;
751   GtkTextMark* insert_mark;
752   GtkTextMark* sel_mark;
753   GtkTextIter insert_iter;
754   GtkTextIter sel_iter;
755   guint offset;
756   int sel;
757   buffer = INF_TEXT_GTK_BUFFER(user_data);
758   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
759   insert_mark = gtk_text_buffer_get_insert(gtk_buffer);
760   sel_mark = gtk_text_buffer_get_selection_bound(gtk_buffer);
761   if( (mark == insert_mark || mark == sel_mark) &amp;&amp; priv-&gt;active_user != NULL)
762   {
763     if(inf_user_get_status(INF_USER(priv-&gt;active_user)) == INF_USER_ACTIVE ||
764        priv-&gt;wake_on_cursor_movement == TRUE)
765     {
766       gtk_text_buffer_get_iter_at_mark(gtk_buffer, &amp;insert_iter, insert_mark);
767       gtk_text_buffer_get_iter_at_mark(gtk_buffer, &amp;sel_iter, sel_mark);
768       offset = gtk_text_iter_get_offset(&amp;insert_iter);
769       sel = gtk_text_iter_get_offset(&amp;sel_iter) - offset;
770       if(inf_text_user_get_caret_position(priv-&gt;active_user) != offset ||
771          inf_text_user_get_selection_length(priv-&gt;active_user) != sel)
772       {
773         inf_signal_handlers_block_by_func(
774           G_OBJECT(priv-&gt;active_user),
775           G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
776           buffer
777         );
778         inf_signal_handlers_block_by_func(
779           G_OBJECT(priv-&gt;active_user),
780           G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
781           buffer
782         );
783         inf_text_user_set_selection(priv-&gt;active_user, offset, sel, TRUE);
784         inf_signal_handlers_unblock_by_func(
785           G_OBJECT(priv-&gt;active_user),
786           G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
787           buffer
788         );
789         inf_signal_handlers_unblock_by_func(
790           G_OBJECT(priv-&gt;active_user),
791           G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
792           buffer
793         );
794       }
795     }
796   }
797 }
798 static void
799 inf_text_gtk_buffer_active_user_notify_status_cb(GObject* object,
800                                                  GParamSpec* pspec,
801                                                  gpointer user_data)
802 {
803   InfTextGtkBuffer* buffer;
804   InfTextGtkBufferPrivate* priv;
805   GtkTextMark* insert_mark;
806   GtkTextMark* sel_mark;
807   GtkTextIter insert_iter;
808   GtkTextIter sel_iter;
809   guint offset;
810   int sel;
811   buffer = INF_TEXT_GTK_BUFFER(user_data);
812   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
813   g_assert(INF_TEXT_USER(object) == priv-&gt;active_user);
814   switch(inf_user_get_status(INF_USER(object)))
815   {
816   case INF_USER_ACTIVE:
817     insert_mark = gtk_text_buffer_get_insert(priv-&gt;buffer);
818     sel_mark = gtk_text_buffer_get_selection_bound(priv-&gt;buffer);
819     gtk_text_buffer_get_iter_at_mark(priv-&gt;buffer, &amp;insert_iter, insert_mark);
820     gtk_text_buffer_get_iter_at_mark(priv-&gt;buffer, &amp;sel_iter, sel_mark);
821     offset = gtk_text_iter_get_offset(&amp;insert_iter);
822     sel = gtk_text_iter_get_offset(&amp;sel_iter) - offset;
823     if(inf_text_user_get_caret_position(priv-&gt;active_user) != offset ||
824        inf_text_user_get_selection_length(priv-&gt;active_user) != sel)
825     {
826       inf_signal_handlers_block_by_func(
827         G_OBJECT(priv-&gt;active_user),
828         G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
829         buffer
830       );
831       inf_text_user_set_selection(priv-&gt;active_user, offset, sel, TRUE);
832       inf_signal_handlers_unblock_by_func(
833         G_OBJECT(priv-&gt;active_user),
834         G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
835         buffer
836 <a name="2"></a>      );
837     }
838 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
839   case INF_USER_UNAVAILABLE:
840     break;
841   default:
842     break;
843   }
844 }
845 static void
846 inf_text_gtk_buffer_active_user_selection_changed_cb(InfTextUser* user,
847                                                      guint position,
848                                                      gint selection_length,
849                                                      gboolean by_request,
850                                                      gpointer user_data)
851 {
852   InfTextGtkBuffer* buffer;
853   InfTextGtkBufferPrivate* priv;
854   GtkTextIter insert;
855   GtkTextIter selection_bound;
856   buffer = INF_TEXT_GTK_BUFFER(user_data);
857   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);</b></font>
858   inf_signal_handlers_block_by_func(
859     G_OBJECT(priv-&gt;buffer),
860     G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
861     buffer
862   );
863   gtk_text_buffer_get_iter_at_offset(priv-&gt;buffer, &amp;insert, position);
864   gtk_text_buffer_get_iter_at_offset(
865     priv-&gt;buffer,
866     &amp;selection_bound,
867     position + selection_length
868   );
869   gtk_text_buffer_select_range(priv-&gt;buffer, &amp;insert, &amp;selection_bound);
870   inf_signal_handlers_unblock_by_func(
871     G_OBJECT(priv-&gt;buffer),
872     G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
873     buffer
874   );
875 }
876 static void
877 inf_text_gtk_buffer_modified_changed_cb(GtkTextBuffer* buffer,
878                                         gpointer user_data)
879 {
880   g_object_notify(G_OBJECT(user_data), "modified");
881 }
882 static void
883 inf_text_gtk_buffer_set_modified(InfTextGtkBuffer* buffer,
884                                  gboolean modified)
885 {
886   InfTextGtkBufferPrivate* priv;
887   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
888   if(priv-&gt;buffer != NULL)
889   {
890     inf_signal_handlers_block_by_func(
891       G_OBJECT(priv-&gt;buffer),
892       G_CALLBACK(inf_text_gtk_buffer_modified_changed_cb),
893       buffer
894     );
895     gtk_text_buffer_set_modified(priv-&gt;buffer, modified);
896     inf_signal_handlers_unblock_by_func(
897       G_OBJECT(priv-&gt;buffer),
898       G_CALLBACK(inf_text_gtk_buffer_modified_changed_cb),
899       buffer
900     );
901     g_object_notify(G_OBJECT(buffer), "modified");
902   }
903 }
904 static void
905 inf_text_gtk_buffer_set_buffer(InfTextGtkBuffer* buffer,
906                                GtkTextBuffer* gtk_buffer)
907 {
908   InfTextGtkBufferPrivate* priv;
909   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
910   if(priv-&gt;buffer != NULL)
911   {
912     inf_signal_handlers_disconnect_by_func(
913       G_OBJECT(priv-&gt;buffer),
914       G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
915       buffer
916     );
917     inf_signal_handlers_disconnect_by_func(
918       G_OBJECT(priv-&gt;buffer),
919       G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_before),
920       buffer
921     );
922     inf_signal_handlers_disconnect_by_func(
923       G_OBJECT(priv-&gt;buffer),
924       G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_after),
925       buffer
926     );
927     inf_signal_handlers_disconnect_by_func(
928       G_OBJECT(priv-&gt;buffer),
929       G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_before),
930       buffer
931     );
932     inf_signal_handlers_disconnect_by_func(
933       G_OBJECT(priv-&gt;buffer),
934       G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_after),
935       buffer
936     );
937     inf_signal_handlers_disconnect_by_func(
938       G_OBJECT(priv-&gt;buffer),
939       G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
940       buffer
941     );
942     inf_signal_handlers_disconnect_by_func(
943       G_OBJECT(priv-&gt;buffer),
944       G_CALLBACK(inf_text_gtk_buffer_modified_changed_cb),
945       buffer
946     );
947     g_object_unref(G_OBJECT(priv-&gt;buffer));
948   }
949   priv-&gt;buffer = gtk_buffer;
950   if(gtk_buffer != NULL)
951   {
952     g_object_ref(G_OBJECT(gtk_buffer));
953     g_signal_connect(
954       G_OBJECT(gtk_buffer),
955       "apply-tag",
956       G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
957       buffer
958     );
959     g_signal_connect(
960       G_OBJECT(gtk_buffer),
961       "insert-text",
962       G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_before),
963       buffer
964     );
965     g_signal_connect_after(
966       G_OBJECT(gtk_buffer),
967       "insert-text",
968       G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_after),
969       buffer
970     );
971     g_signal_connect(
972       G_OBJECT(gtk_buffer),
973       "delete-range",
974       G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_before),
975       buffer
976     );
977     g_signal_connect_after(
978       G_OBJECT(gtk_buffer),
979       "delete-range",
980       G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_after),
981       buffer
982     );
983     g_signal_connect_after(
984       G_OBJECT(gtk_buffer),
985       "mark-set",
986       G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
987       buffer
988     );
989     g_signal_connect_after(
990       G_OBJECT(gtk_buffer),
991       "modified-changed",
992       G_CALLBACK(inf_text_gtk_buffer_modified_changed_cb),
993       buffer
994     );
995   }
996   g_object_notify(G_OBJECT(buffer), "buffer");
997 }
998 static void
999 inf_text_gtk_buffer_init(InfTextGtkBuffer* buffer)
1000 {
1001   InfTextGtkBufferPrivate* priv;
1002   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1003   priv-&gt;buffer = NULL;
1004   priv-&gt;user_table = NULL;
1005   priv-&gt;user_tags = g_hash_table_new_full(
1006     NULL,
1007     NULL,
1008     NULL,
1009     inf_text_gtk_buffer_user_tags_free
1010   );
1011   priv-&gt;show_user_colors = TRUE;
1012   priv-&gt;active_user = NULL;
1013   priv-&gt;wake_on_cursor_movement = FALSE;
1014   priv-&gt;saturation = 0.35;
1015   priv-&gt;value = 1.0;
1016   priv-&gt;alpha = 1.0;
1017 }
1018 static void
1019 inf_text_gtk_buffer_dispose(GObject* object)
1020 {
1021   InfTextGtkBuffer* buffer;
1022   InfTextGtkBufferPrivate* priv;
1023   buffer = INF_TEXT_GTK_BUFFER(object);
1024   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1025   g_hash_table_remove_all(priv-&gt;user_tags);
1026   inf_text_gtk_buffer_set_buffer(buffer, NULL);
1027   inf_text_gtk_buffer_set_active_user(buffer, NULL);
1028 <a name="1"></a>  g_object_unref(priv-&gt;user_table);
1029   G_OBJECT_CLASS(inf_text_gtk_buffer_parent_class)-&gt;dispose(object);
1030 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
1031 static void
1032 inf_text_gtk_buffer_finalize(GObject* object)
1033 {
1034   InfTextGtkBuffer* buffer;
1035   InfTextGtkBufferPrivate* priv;
1036   buffer = INF_TEXT_GTK_BUFFER(object);
1037   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1038   g_hash_table_unref(priv-&gt;user_tags);
1039   G_OBJECT_CLASS(inf_text_gtk_buffer_parent_class)-&gt;finalize(object);
1040 }
1041 static void
1042 inf_text_gtk_buffer_set_property(GObject* object,
1043                                  guint prop_id,
1044                                  const GValue* value,
1045                                  GParamSpec* pspec)
1046 {
1047   InfTextGtkBuffer* buffer;
1048   InfTextGtkBufferPrivate* priv;
1049   buffer = INF_TEXT_GTK_BUFFER(object);
1050   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1051   switch(prop_id)
1052   {
1053   case PROP_BUFFER:</b></font>
1054     g_assert(priv-&gt;buffer == NULL);     inf_text_gtk_buffer_set_buffer(
1055       buffer,
1056       GTK_TEXT_BUFFER(g_value_get_object(value))
1057     );
1058     break;
1059   case PROP_USER_TABLE:
1060     g_assert(priv-&gt;user_table == NULL);     priv-&gt;user_table = INF_USER_TABLE(g_value_dup_object(value));
1061     break;
1062   case PROP_ACTIVE_USER:
1063     inf_text_gtk_buffer_set_active_user(
1064       buffer,
1065       INF_TEXT_USER(g_value_get_object(value))
1066     );
1067     break;
1068   case PROP_WAKE_ON_CURSOR_MOVEMENT:
1069     priv-&gt;wake_on_cursor_movement = g_value_get_boolean(value);
1070 <a name="0"></a>    break;
1071   case PROP_SHOW_USER_COLORS:
1072     priv-&gt;show_user_colors = g_value_get_boolean(value);
1073 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
1074   case PROP_MODIFIED:
1075     inf_text_gtk_buffer_set_modified(buffer, g_value_get_boolean(value));
1076     break;
1077   case PROP_SATURATION:
1078     inf_text_gtk_buffer_set_saturation_value(
1079       buffer,
1080       g_value_get_double(value),
1081       priv-&gt;value
1082     );
1083     break;
1084   case PROP_VALUE:
1085     inf_text_gtk_buffer_set_saturation_value(
1086       buffer,
1087       priv-&gt;saturation,
1088       g_value_get_double(value)
1089     );
1090     break;
1091   case PROP_ALPHA:
1092     inf_text_gtk_buffer_set_fade(buffer, g_value_get_double(value));
1093     break;
1094   default:
1095     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
1096     break;
1097   }
1098 }
1099 static void
1100 inf_text_gtk_buffer_get_property(GObject* object,
1101                                  guint prop_id,
1102                                  GValue* value,
1103                                  GParamSpec* pspec)
1104 {
1105   InfTextGtkBuffer* buffer;
1106   InfTextGtkBufferPrivate* priv;
1107   buffer = INF_TEXT_GTK_BUFFER(object);</b></font>
1108   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1109   switch(prop_id)
1110   {
1111   case PROP_BUFFER:
1112     g_value_set_object(value, G_OBJECT(priv-&gt;buffer));
1113     break;
1114   case PROP_USER_TABLE:
1115     g_value_set_object(value, G_OBJECT(priv-&gt;user_table));
1116     break;
1117   case PROP_ACTIVE_USER:
1118     g_value_set_object(value, G_OBJECT(priv-&gt;active_user));
1119     break;
1120   case PROP_WAKE_ON_CURSOR_MOVEMENT:
1121     g_value_set_boolean(value, priv-&gt;wake_on_cursor_movement);
1122     break;
1123   case PROP_SHOW_USER_COLORS:
1124     g_value_set_boolean(value, priv-&gt;show_user_colors);
1125     break;
1126   case PROP_MODIFIED:
1127     if(priv-&gt;buffer != NULL)
1128       g_value_set_boolean(value, gtk_text_buffer_get_modified(priv-&gt;buffer));
1129     else
1130       g_value_set_boolean(value, FALSE);
1131     break;
1132   case PROP_SATURATION:
1133     g_value_set_double(value, priv-&gt;saturation);
1134     break;
1135   case PROP_VALUE:
1136     g_value_set_double(value, priv-&gt;value);
1137     break;
1138   case PROP_ALPHA:
1139     g_value_set_double(value, priv-&gt;alpha);
1140     break;
1141   default:
1142     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
1143     break;
1144   }
1145 }
1146 static gboolean
1147 inf_text_gtk_buffer_buffer_get_modified(InfBuffer* buffer)
1148 {
1149   InfTextGtkBuffer* gtk_buffer;
1150   InfTextGtkBufferPrivate* priv;
1151   gtk_buffer = INF_TEXT_GTK_BUFFER(buffer);
1152   priv = INF_TEXT_GTK_BUFFER_PRIVATE(gtk_buffer);
1153   if(priv-&gt;buffer != NULL)
1154     return gtk_text_buffer_get_modified(priv-&gt;buffer);
1155   else
1156     return FALSE;
1157 }
1158 static void
1159 inf_text_gtk_buffer_buffer_set_modified(InfBuffer* buffer,
1160                                         gboolean modified)
1161 {
1162   inf_text_gtk_buffer_set_modified(INF_TEXT_GTK_BUFFER(buffer), modified);
1163 }
1164 static const gchar*
1165 inf_text_gtk_buffer_buffer_get_encoding(InfTextBuffer* buffer)
1166 {
1167   return "UTF-8";
1168 }
1169 static guint
1170 inf_text_gtk_buffer_get_length(InfTextBuffer* buffer)
1171 {
1172   InfTextGtkBufferPrivate* priv;
1173   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1174   return gtk_text_buffer_get_char_count(priv-&gt;buffer);
1175 }
1176 static InfTextChunk*
1177 inf_text_gtk_buffer_buffer_get_slice(InfTextBuffer* buffer,
1178                                      guint pos,
1179                                      guint len)
1180 {
1181   InfTextGtkBufferPrivate* priv;
1182   GtkTextIter begin;
1183   GtkTextIter iter;
1184   InfTextChunk* result;
1185   guint remaining;
1186   guint size;
1187   InfTextUser* author;
1188   gchar* text;
1189   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1190   gtk_text_buffer_get_iter_at_offset(priv-&gt;buffer, &amp;iter, pos);
1191   result = inf_text_chunk_new("UTF-8");
1192   remaining = len;
1193   while(remaining &gt; 0)
1194   {
1195     g_assert(gtk_text_iter_is_end(&amp;iter) == FALSE);
1196     begin = iter;
1197     inf_text_gtk_buffer_iter_next_author_toggle(&amp;iter, NULL, &amp;author);
1198     size = gtk_text_iter_get_offset(&amp;iter) - gtk_text_iter_get_offset(&amp;begin);
1199     if(size &gt; remaining)
1200     {
1201       size = remaining;
1202       iter = begin;
1203       gtk_text_iter_forward_chars(&amp;iter, size);
1204     }
1205     text = gtk_text_buffer_get_slice(priv-&gt;buffer, &amp;begin, &amp;iter, TRUE);
1206     inf_text_chunk_insert_text(
1207       result,
1208       len - remaining,
1209       text,
1210       strlen(text),       size,
1211       (author == NULL) ? 0 : inf_user_get_id(INF_USER(author))
1212     );
1213     remaining -= size;
1214     g_free(text);
1215   }
1216   return result;
1217 }
1218 static void
1219 inf_text_gtk_buffer_buffer_insert_text(InfTextBuffer* buffer,
1220                                        guint pos,
1221                                        InfTextChunk* chunk,
1222                                        InfUser* user)
1223 {
1224   InfTextGtkBufferPrivate* priv;
1225   InfTextChunkIter chunk_iter;
1226   InfTextGtkBufferTagRemove tag_remove;
1227   GtkTextTag* tag;
1228   GtkTextMark* mark;
1229   GtkTextIter insert_iter;
1230   gboolean insert_at_cursor;
1231   gboolean insert_at_selection_bound;
1232   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1233   tag_remove.buffer = priv-&gt;buffer;
1234   g_assert(priv-&gt;record == NULL);
1235   inf_signal_handlers_block_by_func(
1236     G_OBJECT(priv-&gt;buffer),
1237     G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
1238     buffer
1239   );
1240   inf_signal_handlers_block_by_func(
1241     G_OBJECT(priv-&gt;buffer),
1242     G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_before),
1243     buffer
1244   );
1245   inf_signal_handlers_block_by_func(
1246     G_OBJECT(priv-&gt;buffer),
1247     G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_after),
1248     buffer
1249   );
1250   if(inf_text_chunk_iter_init_begin(chunk, &amp;chunk_iter))
1251   {
1252     gtk_text_buffer_get_iter_at_offset(
1253       priv-&gt;buffer,
1254       &amp;tag_remove.end_iter,
1255       pos
1256     );
1257     do
1258     {
1259       tag_remove.ignore_tags = inf_text_gtk_buffer_get_user_tags(
1260         INF_TEXT_GTK_BUFFER(buffer),
1261         inf_text_chunk_iter_get_author(&amp;chunk_iter)
1262       );
1263       if(tag_remove.ignore_tags)
1264       {
1265         tag = inf_text_gtk_buffer_get_user_tag(
1266           INF_TEXT_GTK_BUFFER(buffer),
1267           tag_remove.ignore_tags,
1268           priv-&gt;show_user_colors
1269         );
1270       }
1271       else
1272       {
1273         tag = NULL;
1274       }
1275       gtk_text_buffer_insert_with_tags(
1276         tag_remove.buffer,
1277         &amp;tag_remove.end_iter,
1278         inf_text_chunk_iter_get_text(&amp;chunk_iter),
1279         inf_text_chunk_iter_get_bytes(&amp;chunk_iter),
1280         tag,
1281         NULL
1282       );
1283       tag_remove.begin_iter = tag_remove.end_iter;
1284       gtk_text_iter_backward_chars(
1285         &amp;tag_remove.begin_iter,
1286         inf_text_chunk_iter_get_length(&amp;chunk_iter)
1287       );
1288       gtk_text_tag_table_foreach(
1289         gtk_text_buffer_get_tag_table(tag_remove.buffer),
1290         inf_text_gtk_buffer_buffer_insert_text_tag_table_foreach_func,
1291         &amp;tag_remove
1292       );
1293     } while(inf_text_chunk_iter_next(&amp;chunk_iter));
1294     if(user != INF_USER(priv-&gt;active_user) || user == NULL)
1295     {
1296       mark = gtk_text_buffer_get_insert(priv-&gt;buffer);
1297       gtk_text_buffer_get_iter_at_mark(priv-&gt;buffer, &amp;insert_iter, mark);
1298       if(gtk_text_iter_equal(&amp;insert_iter, &amp;tag_remove.end_iter))
1299         insert_at_cursor = TRUE;
1300       else
1301         insert_at_cursor = FALSE;
1302       mark = gtk_text_buffer_get_selection_bound(priv-&gt;buffer);
1303       gtk_text_buffer_get_iter_at_mark(priv-&gt;buffer, &amp;insert_iter, mark);
1304       if(gtk_text_iter_equal(&amp;insert_iter, &amp;tag_remove.end_iter))
1305         insert_at_selection_bound = TRUE;
1306       else
1307         insert_at_selection_bound = FALSE;
1308       if(insert_at_cursor || insert_at_selection_bound)
1309       {
1310         inf_signal_handlers_block_by_func(
1311           G_OBJECT(priv-&gt;buffer),
1312           G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
1313           buffer
1314         );
1315         gtk_text_iter_backward_chars(
1316           &amp;tag_remove.end_iter,
1317           inf_text_chunk_get_length(chunk)
1318         );
1319         if(insert_at_cursor)
1320         {
1321           gtk_text_buffer_move_mark(
1322             priv-&gt;buffer,
1323             gtk_text_buffer_get_insert(priv-&gt;buffer),
1324             &amp;tag_remove.end_iter
1325           );
1326         }
1327         if(insert_at_selection_bound)
1328         {
1329           gtk_text_buffer_move_mark(
1330             priv-&gt;buffer,
1331             gtk_text_buffer_get_selection_bound(priv-&gt;buffer),
1332             &amp;tag_remove.end_iter
1333           );
1334         }
1335         inf_signal_handlers_unblock_by_func(
1336           G_OBJECT(priv-&gt;buffer),
1337           G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
1338           buffer
1339         );
1340       }
1341     }
1342   }
1343   inf_signal_handlers_unblock_by_func(
1344     G_OBJECT(priv-&gt;buffer),
1345     G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
1346     buffer
1347   );
1348   inf_signal_handlers_unblock_by_func(
1349     G_OBJECT(priv-&gt;buffer),
1350     G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_before),
1351     buffer
1352   );
1353   inf_signal_handlers_unblock_by_func(
1354     G_OBJECT(priv-&gt;buffer),
1355     G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_after),
1356     buffer
1357   );
1358   inf_text_buffer_text_inserted(buffer, pos, chunk, user);
1359 }
1360 static void
1361 inf_text_gtk_buffer_buffer_erase_text(InfTextBuffer* buffer,
1362                                       guint pos,
1363                                       guint len,
1364                                       InfUser* user)
1365 {
1366   InfTextGtkBufferPrivate* priv;
1367   InfTextChunk* chunk;
1368   GtkTextIter begin;
1369   GtkTextIter end;
1370   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1371   g_assert(priv-&gt;record == NULL);
1372   chunk = inf_text_buffer_get_slice(buffer, pos, len);
1373   gtk_text_buffer_get_iter_at_offset(priv-&gt;buffer, &amp;begin, pos);
1374   gtk_text_buffer_get_iter_at_offset(priv-&gt;buffer, &amp;end, pos + len);
1375   inf_signal_handlers_block_by_func(
1376     G_OBJECT(priv-&gt;buffer),
1377     G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_before),
1378     buffer
1379   );
1380   inf_signal_handlers_block_by_func(
1381     G_OBJECT(priv-&gt;buffer),
1382     G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_after),
1383     buffer
1384   );
1385   gtk_text_buffer_delete(priv-&gt;buffer, &amp;begin, &amp;end);
1386   inf_signal_handlers_unblock_by_func(
1387     G_OBJECT(priv-&gt;buffer),
1388     G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_before),
1389     buffer
1390   );
1391   inf_signal_handlers_unblock_by_func(
1392     G_OBJECT(priv-&gt;buffer),
1393     G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_after),
1394     buffer
1395   );
1396   inf_text_buffer_text_erased(buffer, pos, chunk, user);
1397   inf_text_chunk_free(chunk);
1398 }
1399 static InfTextBufferIter*
1400 inf_text_gtk_buffer_buffer_create_begin_iter(InfTextBuffer* buffer)
1401 {
1402   InfTextGtkBufferPrivate* priv;
1403   InfTextBufferIter* iter;
1404   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1405   if(gtk_text_buffer_get_char_count(priv-&gt;buffer) == 0)
1406   {
1407     return NULL;
1408   }
1409   else
1410   {
1411     iter = g_slice_new(InfTextBufferIter);
1412     gtk_text_buffer_get_start_iter(priv-&gt;buffer, &amp;iter-&gt;begin);
1413     iter-&gt;end = iter-&gt;begin;
1414     inf_text_gtk_buffer_iter_next_author_toggle(
1415       &amp;iter-&gt;end,
1416       NULL,
1417       &amp;iter-&gt;user
1418     );
1419     return iter;
1420   }
1421 }
1422 static InfTextBufferIter*
1423 inf_text_gtk_buffer_buffer_create_end_iter(InfTextBuffer* buffer)
1424 {
1425   InfTextGtkBufferPrivate* priv;
1426   InfTextBufferIter* iter;
1427   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1428   if(gtk_text_buffer_get_char_count(priv-&gt;buffer) == 0)
1429   {
1430     return NULL;
1431   }
1432   else
1433   {
1434     iter = g_slice_new(InfTextBufferIter);
1435     gtk_text_buffer_get_end_iter(priv-&gt;buffer, &amp;iter-&gt;end);
1436     iter-&gt;begin = iter-&gt;end;
1437     inf_text_gtk_buffer_iter_prev_author_toggle(
1438       &amp;iter-&gt;begin,
1439       &amp;iter-&gt;user,
1440       NULL
1441     );
1442     return iter;
1443   }
1444 }
1445 static void
1446 inf_text_gtk_buffer_buffer_destroy_iter(InfTextBuffer* buffer,
1447                                         InfTextBufferIter* iter)
1448 {
1449   g_slice_free(InfTextBufferIter, iter);
1450 }
1451 static gboolean
1452 inf_text_gtk_buffer_buffer_iter_next(InfTextBuffer* buffer,
1453                                      InfTextBufferIter* iter)
1454 {
1455   if(gtk_text_iter_is_end(&amp;iter-&gt;end))
1456     return FALSE;
1457   iter-&gt;begin = iter-&gt;end;
1458   inf_text_gtk_buffer_iter_next_author_toggle(&amp;iter-&gt;end, NULL, &amp;iter-&gt;user);
1459   return TRUE;
1460 }
1461 static gboolean
1462 inf_text_gtk_buffer_buffer_iter_prev(InfTextBuffer* buffer,
1463                                      InfTextBufferIter* iter)
1464 {
1465   if(gtk_text_iter_is_start(&amp;iter-&gt;begin))
1466     return FALSE;
1467   iter-&gt;end = iter-&gt;begin;
1468   inf_text_gtk_buffer_iter_prev_author_toggle(
1469     &amp;iter-&gt;begin,
1470     &amp;iter-&gt;user,
1471     NULL
1472   );
1473   return TRUE;
1474 }
1475 static gpointer
1476 inf_text_gtk_buffer_buffer_iter_get_text(InfTextBuffer* buffer,
1477                                          InfTextBufferIter* iter)
1478 {
1479   InfTextGtkBufferPrivate* priv;
1480   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1481   return gtk_text_buffer_get_slice(
1482     priv-&gt;buffer,
1483     &amp;iter-&gt;begin,
1484     &amp;iter-&gt;end,
1485     TRUE
1486   );
1487 }
1488 static guint
1489 inf_text_gtk_buffer_buffer_iter_get_offset(InfTextBuffer* buffer,
1490                                            InfTextBufferIter* iter)
1491 {
1492   return gtk_text_iter_get_offset(&amp;iter-&gt;begin);
1493 }
1494 static guint
1495 inf_text_gtk_buffer_buffer_iter_get_length(InfTextBuffer* buffer,
1496                                            InfTextBufferIter* iter)
1497 {
1498   return gtk_text_iter_get_offset(&amp;iter-&gt;end) -
1499     gtk_text_iter_get_offset(&amp;iter-&gt;begin);
1500 }
1501 static gsize
1502 inf_text_gtk_buffer_buffer_iter_get_bytes(InfTextBuffer* buffer,
1503                                           InfTextBufferIter* iter)
1504 {
1505   GtkTextIter walk;
1506   gsize bytes;
1507   guint remaining;
1508   guint end;
1509   guint line_chars;
1510   guint line_bytes;
1511   gboolean result;
1512   walk = iter-&gt;begin;
1513   bytes = 0;
1514   remaining = gtk_text_iter_get_offset(&amp;iter-&gt;end) -
1515     gtk_text_iter_get_offset(&amp;walk);
1516   end = gtk_text_iter_get_offset(&amp;iter-&gt;end);
1517   while(remaining &gt; 0)
1518   {
1519     line_chars = gtk_text_iter_get_chars_in_line(&amp;walk) -
1520       gtk_text_iter_get_line_offset(&amp;walk);
1521     if(line_chars + gtk_text_iter_get_offset(&amp;walk) &lt;= end)
1522     {
1523       line_bytes = gtk_text_iter_get_bytes_in_line(&amp;walk) -
1524         gtk_text_iter_get_line_index(&amp;walk);
1525       remaining -= line_chars;
1526       bytes += line_bytes;
1527       result = gtk_text_iter_forward_line(&amp;walk);
1528       g_assert(remaining == 0 || result == TRUE);
1529     }
1530     else
1531     {
1532       line_bytes = gtk_text_iter_get_line_index(&amp;iter-&gt;end) -
1533         gtk_text_iter_get_line_index(&amp;walk);
1534       remaining = 0;
1535       bytes += line_bytes;
1536     }
1537   }
1538   return bytes;
1539 }
1540 static guint
1541 inf_text_gtk_buffer_buffer_iter_get_author(InfTextBuffer* buffer,
1542                                            InfTextBufferIter* iter)
1543 {
1544   return (iter-&gt;user == NULL) ? 0 : inf_user_get_id(INF_USER(iter-&gt;user));
1545 }
1546 static void
1547 inf_text_gtk_buffer_class_init(InfTextGtkBufferClass* text_gtk_buffer_class)
1548 {
1549   GObjectClass* object_class;
1550   object_class = G_OBJECT_CLASS(text_gtk_buffer_class);
1551   object_class-&gt;dispose = inf_text_gtk_buffer_dispose;
1552   object_class-&gt;finalize = inf_text_gtk_buffer_finalize;
1553   object_class-&gt;set_property = inf_text_gtk_buffer_set_property;
1554   object_class-&gt;get_property = inf_text_gtk_buffer_get_property;
1555   inf_text_gtk_buffer_tag_user_quark = g_quark_from_static_string(
1556     "inf-text-gtk-buffer-tag-user"
1557   );
1558   g_object_class_install_property(
1559     object_class,
1560     PROP_BUFFER,
1561     g_param_spec_object(
1562       "buffer",
1563       "Buffer",
1564       "The underlaying GtkTextBuffer",
1565       GTK_TYPE_TEXT_BUFFER,
1566       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1567     )
1568   );
1569   g_object_class_install_property(
1570     object_class,
1571     PROP_USER_TABLE,
1572     g_param_spec_object(
1573       "user-table",
1574       "User table",
1575       "A user table of the participating users",
1576       INF_TYPE_USER_TABLE,
1577       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1578     )
1579   );
1580   g_object_class_install_property(
1581     object_class,
1582     PROP_ACTIVE_USER,
1583     g_param_spec_object(
1584       "active-user",
1585       "Active user",
1586       "The user currently inserting text locally",
1587       INF_TEXT_TYPE_USER,
1588       G_PARAM_READWRITE
1589     )
1590   );
1591   g_object_class_install_property(
1592     object_class,
1593     PROP_WAKE_ON_CURSOR_MOVEMENT,
1594     g_param_spec_boolean(
1595       "wake-on-cursor-movement",
1596       "Wake on cursor movement",
1597       "Whether to make inactive users active when the insertion mark in the "
1598       "TextBuffer moves",
1599       FALSE,
1600       G_PARAM_READWRITE
1601     )
1602   );
1603   g_object_class_install_property(
1604     object_class,
1605     PROP_SHOW_USER_COLORS,
1606     g_param_spec_boolean(
1607       "show-user-colors",
1608       "Show user colors",
1609       "Whether to show user colors initially for newly written text",
1610       TRUE,
1611       G_PARAM_READWRITE
1612     )
1613   );
1614   g_object_class_install_property(
1615     object_class,
1616     PROP_SATURATION,
1617     g_param_spec_double(
1618       "saturation",
1619       "Saturation",
1620       "Saturation of user colors in a HSV color model",
1621       0.0,
1622       1.0,
1623       0.35,
1624       G_PARAM_READWRITE
1625     )
1626   );
1627   g_object_class_install_property(
1628     object_class,
1629     PROP_VALUE,
1630     g_param_spec_double(
1631       "value",
1632       "Value",
1633       "Value of user colors in a HSV color model",
1634       0.0,
1635       1.0,
1636       1.0,
1637       G_PARAM_READWRITE
1638     )
1639   );
1640   g_object_class_install_property(
1641     object_class,
1642     PROP_VALUE,
1643     g_param_spec_double(
1644       "alpha",
1645       "Alpha",
1646       "The translucency of the user color",
1647       0.0,
1648       1.0,
1649       1.0,
1650       G_PARAM_READWRITE
1651     )
1652   );
1653   g_object_class_override_property(object_class, PROP_MODIFIED, "modified");
1654 }
1655 static void
1656 inf_text_gtk_buffer_buffer_iface_init(InfBufferInterface* iface)
1657 {
1658   iface-&gt;get_modified = inf_text_gtk_buffer_buffer_get_modified;
1659   iface-&gt;set_modified = inf_text_gtk_buffer_buffer_set_modified;
1660 }
1661 static void
1662 inf_text_gtk_buffer_text_buffer_iface_init(InfTextBufferInterface* iface)
1663 {
1664   iface-&gt;get_encoding = inf_text_gtk_buffer_buffer_get_encoding;
1665   iface-&gt;get_length = inf_text_gtk_buffer_get_length;
1666   iface-&gt;get_slice = inf_text_gtk_buffer_buffer_get_slice;
1667   iface-&gt;insert_text = inf_text_gtk_buffer_buffer_insert_text;
1668   iface-&gt;erase_text = inf_text_gtk_buffer_buffer_erase_text;
1669   iface-&gt;create_begin_iter = inf_text_gtk_buffer_buffer_create_begin_iter;
1670   iface-&gt;create_end_iter = inf_text_gtk_buffer_buffer_create_end_iter;
1671   iface-&gt;destroy_iter = inf_text_gtk_buffer_buffer_destroy_iter;
1672   iface-&gt;iter_next = inf_text_gtk_buffer_buffer_iter_next;
1673   iface-&gt;iter_prev = inf_text_gtk_buffer_buffer_iter_prev;
1674   iface-&gt;iter_get_text = inf_text_gtk_buffer_buffer_iter_get_text;
1675   iface-&gt;iter_get_offset = inf_text_gtk_buffer_buffer_iter_get_offset;
1676   iface-&gt;iter_get_length = inf_text_gtk_buffer_buffer_iter_get_length;
1677   iface-&gt;iter_get_bytes = inf_text_gtk_buffer_buffer_iter_get_bytes;
1678   iface-&gt;iter_get_author = inf_text_gtk_buffer_buffer_iter_get_author;
1679   iface-&gt;text_inserted = NULL;
1680   iface-&gt;text_erased = NULL;
1681 }
1682 InfTextGtkBuffer*
1683 inf_text_gtk_buffer_new(GtkTextBuffer* buffer,
1684                         InfUserTable* user_table)
1685 {
1686   GObject* object;
1687   g_return_val_if_fail(GTK_IS_TEXT_BUFFER(buffer), NULL);
1688   g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);
1689   object = g_object_new(
1690     INF_TEXT_GTK_TYPE_BUFFER,
1691     "buffer", buffer,
1692     "user-table", user_table,
1693     NULL
1694   );
1695   return INF_TEXT_GTK_BUFFER(object);
1696 }
1697 GtkTextBuffer*
1698 inf_text_gtk_buffer_get_text_buffer(InfTextGtkBuffer* buffer)
1699 {
1700   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), NULL);
1701   return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;buffer;
1702 }
1703 void
1704 inf_text_gtk_buffer_set_active_user(InfTextGtkBuffer* buffer,
1705                                     InfTextUser* user)
1706 {
1707   InfTextGtkBufferPrivate* priv;
1708   g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
1709   g_return_if_fail(user == NULL || INF_TEXT_IS_USER(user));
1710   g_return_if_fail(
1711     user == NULL ||
1712     (inf_user_get_flags(INF_USER(user)) &amp; INF_USER_LOCAL) != 0
1713   );
1714   g_return_if_fail(
1715     user == NULL ||
1716     inf_user_get_status(INF_USER(user)) != INF_USER_UNAVAILABLE
1717   );
1718   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1719   if(priv-&gt;active_user != NULL)
1720   {
1721     inf_signal_handlers_disconnect_by_func(
1722       G_OBJECT(priv-&gt;active_user),
1723       G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
1724       buffer
1725     );
1726     inf_signal_handlers_disconnect_by_func(
1727       G_OBJECT(priv-&gt;active_user),
1728       G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
1729       buffer
1730     );
1731     g_object_unref(G_OBJECT(priv-&gt;active_user));
1732   }
1733   priv-&gt;active_user = user;
1734   if(user != NULL)
1735   {
1736     g_object_ref(G_OBJECT(user));
1737     g_signal_connect(
1738       G_OBJECT(user),
1739       "notify::status",
1740       G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
1741       buffer
1742     );
1743     g_signal_connect(
1744       G_OBJECT(user),
1745       "selection-changed",
1746       G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
1747       buffer
1748     );
1749   }
1750   g_object_notify(G_OBJECT(buffer), "active-user");
1751 }
1752 InfTextUser*
1753 inf_text_gtk_buffer_get_active_user(InfTextGtkBuffer* buffer)
1754 {
1755   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), NULL);
1756   return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;active_user;
1757 }
1758 InfTextUser*
1759 inf_text_gtk_buffer_get_author(InfTextGtkBuffer* buffer,
1760                                GtkTextIter* location)
1761 {
1762   InfTextGtkBufferPrivate* priv;
1763   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), NULL);
1764   g_return_val_if_fail(
1765     location != NULL &amp;&amp; !gtk_text_iter_is_end(location),
1766     NULL
1767   );
1768   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1769   return inf_text_gtk_buffer_iter_get_author(location);
1770 }
1771 InfTextUser*
1772 inf_text_gtk_buffer_get_user_for_tag(InfTextGtkBuffer* buffer,
1773                                      GtkTextTag* tag)
1774 {
1775   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), NULL);
1776   g_return_val_if_fail(GTK_IS_TEXT_TAG(tag), NULL);
1777   return inf_text_gtk_buffer_author_from_tag(tag);
1778 }
1779 gboolean
1780 inf_text_gtk_buffer_is_author_toggle(InfTextGtkBuffer* buffer,
1781                                      const GtkTextIter* iter,
1782                                      InfTextUser** user_on,
1783                                      InfTextUser** user_off)
1784 {
1785   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
1786   g_return_val_if_fail(iter != NULL, FALSE);
1787   return inf_text_gtk_buffer_iter_is_author_toggle(
1788     iter,
1789     user_on,
1790     user_off
1791   );
1792 }
1793 gboolean
1794 inf_text_gtk_buffer_forward_to_author_toggle(InfTextGtkBuffer* buffer,
1795                                              GtkTextIter* iter,
1796                                              InfTextUser** user_on,
1797                                              InfTextUser** user_off)
1798 {
1799   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
1800   g_return_val_if_fail(iter != NULL, FALSE);
1801   if(gtk_text_iter_is_end(iter))
1802     return FALSE;
1803   inf_text_gtk_buffer_iter_next_author_toggle(iter, user_on, user_off);
1804   return TRUE;
1805 }
1806 gboolean
1807 inf_text_gtk_buffer_backward_to_author_toggle(InfTextGtkBuffer* buffer,
1808                                               GtkTextIter* iter,
1809                                               InfTextUser** user_on,
1810                                               InfTextUser** user_off)
1811 {
1812   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
1813   g_return_val_if_fail(iter != NULL, FALSE);
1814   if(gtk_text_iter_is_start(iter))
1815     return FALSE;
1816   inf_text_gtk_buffer_iter_prev_author_toggle(iter, user_on, user_off);
1817   return TRUE;
1818 }
1819 void
1820 inf_text_gtk_buffer_set_wake_on_cursor_movement(InfTextGtkBuffer* buffer,
1821                                                 gboolean wake)
1822 {
1823   g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
1824   INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;wake_on_cursor_movement = wake;
1825   g_object_notify(G_OBJECT(buffer), "wake-on-cursor-movement");
1826 }
1827 gboolean
1828 inf_text_gtk_buffer_get_wake_on_cursor_movement(InfTextGtkBuffer* buffer)
1829 {
1830   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
1831   return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;wake_on_cursor_movement;
1832 }
1833 void
1834 inf_text_gtk_buffer_ensure_author_tags_priority(InfTextGtkBuffer* buffer)
1835 {
1836   InfTextGtkBufferPrivate* priv;
1837   GtkTextTagTable* tag_table;
1838   g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
1839   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1840   tag_table = gtk_text_buffer_get_tag_table(priv-&gt;buffer);
1841   gtk_text_tag_table_foreach(
1842     tag_table,
1843     inf_text_gtk_buffer_ensure_author_tags_priority_foreach_func,
1844     buffer
1845   );
1846 }
1847 void
1848 inf_text_gtk_buffer_set_saturation_value(InfTextGtkBuffer* buffer,
1849                                          gdouble saturation,
1850                                          gdouble value)
1851 {
1852   InfTextGtkBufferPrivate* priv;
1853   GtkTextTagTable* tag_table;
1854   g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
1855   g_return_if_fail(saturation &gt;= 0.0 &amp;&amp; saturation &lt;= 1.0);
1856   g_return_if_fail(value &gt;= 0.0 &amp;&amp; value &lt;= 1.0);
1857   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1858   if(saturation == priv-&gt;saturation &amp;&amp; value == priv-&gt;value)
1859     return;
1860   g_object_freeze_notify(G_OBJECT(buffer));
1861   if(saturation != priv-&gt;saturation)
1862   {
1863     priv-&gt;saturation = saturation;
1864     g_object_notify(G_OBJECT(buffer), "saturation");
1865   }
1866   if(value != priv-&gt;value)
1867   {
1868     priv-&gt;value = value;
1869     g_object_notify(G_OBJECT(buffer), "value");
1870   }
1871   tag_table = gtk_text_buffer_get_tag_table(priv-&gt;buffer);
1872   gtk_text_tag_table_foreach(
1873     tag_table,
1874     inf_text_gtk_buffer_update_user_color_tag_table_foreach_func,
1875     buffer
1876   );
1877   g_object_thaw_notify(G_OBJECT(buffer));
1878 }
1879 void
1880 inf_text_gtk_buffer_set_fade(InfTextGtkBuffer* buffer,
1881                              gdouble alpha)
1882 {
1883   InfTextGtkBufferPrivate* priv;
1884   GtkTextTagTable* tag_table;
1885   g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
1886   g_return_if_fail(alpha &gt;= 0.0 &amp;&amp; alpha &lt;= 1.0);
1887   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1888   g_object_freeze_notify(G_OBJECT(buffer));
1889   if(alpha != priv-&gt;alpha)
1890   {
1891     priv-&gt;alpha = alpha;
1892     g_object_notify(G_OBJECT(buffer), "alpha");
1893   }
1894   tag_table = gtk_text_buffer_get_tag_table(priv-&gt;buffer);
1895   gtk_text_tag_table_foreach(
1896     tag_table,
1897     inf_text_gtk_buffer_update_user_color_tag_table_foreach_func,
1898     buffer
1899   );
1900   g_object_thaw_notify(G_OBJECT(buffer));
1901 }
1902 gdouble
1903 inf_text_gtk_buffer_get_saturation(InfTextGtkBuffer* buffer)
1904 {
1905   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), 0.0);
1906   return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;saturation;
1907 }
1908 gdouble
1909 inf_text_gtk_buffer_get_value(InfTextGtkBuffer* buffer)
1910 {
1911   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), 0.0);
1912   return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;value;
1913 }
1914 void
1915 inf_text_gtk_buffer_set_show_user_colors(InfTextGtkBuffer* buffer,
1916                                          gboolean show)
1917 {
1918   g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
1919   INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;show_user_colors = show;
1920   g_object_notify(G_OBJECT(buffer), "show-user-colors");
1921 }
1922 gboolean
1923 inf_text_gtk_buffer_get_show_user_colors(InfTextGtkBuffer* buffer)
1924 {
1925   g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
1926   return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;show_user_colors;
1927 }
1928 void
1929 inf_text_gtk_buffer_show_user_colors(InfTextGtkBuffer* buffer,
1930                                      gboolean show,
1931                                      GtkTextIter* start,
1932                                      GtkTextIter* end)
1933 {
1934   InfTextGtkBufferPrivate* priv;
1935   GtkTextIter iter;
1936   GtkTextIter prev;
1937   InfTextUser* user;
1938   InfTextGtkBufferUserTags* tags;
1939   GtkTextTag* hide_tag;
1940   GtkTextTag* show_tag;
1941   g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
1942   g_return_if_fail(start != NULL);
1943   g_return_if_fail(end != NULL);
1944   priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
1945   iter = *start;
1946   prev = iter;
1947   while(!gtk_text_iter_equal(&amp;iter, end))
1948   {
1949     inf_text_gtk_buffer_iter_next_author_toggle(&amp;iter, NULL, &amp;user);
1950     if(gtk_text_iter_compare(&amp;iter, end) &gt; 0)
1951       iter = *end;
1952     if(user != NULL)
1953     {
1954       tags = g_hash_table_lookup(
1955         priv-&gt;user_tags,
1956         GUINT_TO_POINTER(inf_user_get_id(INF_USER(user)))
1957       );
1958       g_assert(tags != NULL);
1959       if(show)
1960       {
1961         hide_tag = inf_text_gtk_buffer_get_user_tag(buffer, tags, FALSE);
1962         show_tag = inf_text_gtk_buffer_get_user_tag(buffer, tags, TRUE);
1963       }
1964       else
1965       {
1966         hide_tag = inf_text_gtk_buffer_get_user_tag(buffer, tags, TRUE);
1967         show_tag = inf_text_gtk_buffer_get_user_tag(buffer, tags, FALSE);
1968       }
1969       inf_signal_handlers_block_by_func(
1970         priv-&gt;buffer,
1971         G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
1972         buffer
1973       );
1974       gtk_text_buffer_remove_tag(priv-&gt;buffer, hide_tag, &amp;prev, &amp;iter);
1975       gtk_text_buffer_apply_tag(priv-&gt;buffer, show_tag, &amp;prev, &amp;iter);
1976       inf_signal_handlers_unblock_by_func(
1977         priv-&gt;buffer,
1978         G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
1979         buffer
1980       );
1981     }
1982     prev = iter;
1983   }
1984 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
