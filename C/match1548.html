<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for infd-xmpp-server.c &amp; inf-text-gtk-buffer.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for infd-xmpp-server.c &amp; inf-text-gtk-buffer.c
      </h3>
<h1 align="center">
        7.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>infd-xmpp-server.c (14.705882%)<th>inf-text-gtk-buffer.c (4.6487603%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(505-528)<td><a href="#" name="0">(1416-1452)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(396-427)<td><a href="#" name="1">(1362-1392)</a><td align="center"><font color="#f00000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(461-481)<td><a href="#" name="2">(1123-1146)</a><td align="center"><font color="#b40000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>infd-xmpp-server.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinfinity/server/infd-xmpp-server.h&gt;
#include &lt;libinfinity/server/infd-tcp-server.h&gt;
#include &lt;libinfinity/server/infd-xml-server.h&gt;
#include &lt;libinfinity/common/inf-xmpp-connection.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
#ifdef G_OS_WIN32
# ifdef ERROR
#  undef ERROR
# endif
#endif
typedef enum InfdXmppServerStatus_ {
  INFD_XMPP_SERVER_CLOSED,
  INFD_XMPP_SERVER_OPEN
} InfdXmppServerStatus;
typedef struct _InfdXmppServerPrivate InfdXmppServerPrivate;
struct _InfdXmppServerPrivate {
  InfdTcpServer* tcp;
  InfdXmppServerStatus status;
  gchar* local_hostname;
  InfXmppConnectionSecurityPolicy security_policy;
  InfCertificateCredentials* tls_creds;
  InfSaslContext* sasl_context;
  InfSaslContext* sasl_own_context;
  gchar* sasl_mechanisms;
};
enum {
  PROP_0,
  PROP_TCP,
  PROP_LOCAL_HOSTNAME,
  PROP_CREDENTIALS,
  PROP_SASL_CONTEXT,
  PROP_SASL_MECHANISMS,
  PROP_SECURITY_POLICY,
  PROP_STATUS
};
enum {
  ERROR,
  LAST_SIGNAL
};
#define INFD_XMPP_SERVER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFD_TYPE_XMPP_SERVER, InfdXmppServerPrivate))
static guint xmpp_server_signals[LAST_SIGNAL];
static void infd_xmpp_server_xml_server_iface_init(InfdXmlServerInterface* iface);
G_DEFINE_TYPE_WITH_CODE(InfdXmppServer, infd_xmpp_server, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfdXmppServer)
  G_IMPLEMENT_INTERFACE(INFD_TYPE_XML_SERVER, infd_xmpp_server_xml_server_iface_init))
static void
infd_xmpp_server_new_connection_cb(InfdTcpServer* tcp_server,
                                   InfTcpConnection* tcp_connection,
                                   gpointer user_data)
{
  InfdXmppServer* xmpp_server;
  InfdXmppServerPrivate* priv;
  InfXmppConnection* xmpp_connection;
  InfIpAddress* addr;
  gchar* addr_str;
  xmpp_server = INFD_XMPP_SERVER(user_data);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp_server);
  g_object_get(G_OBJECT(tcp_connection), "remote-address", &amp;addr, NULL);
  addr_str = inf_ip_address_to_string(addr);
  inf_ip_address_free(addr);
  xmpp_connection = inf_xmpp_connection_new(
    tcp_connection,
    INF_XMPP_CONNECTION_SERVER,
    priv-&gt;local_hostname,
    addr_str,
    priv-&gt;security_policy,
    priv-&gt;tls_creds,
    priv-&gt;sasl_context,
    priv-&gt;sasl_own_context != NULL ? "ANONYMOUS" : priv-&gt;sasl_mechanisms
  );
  g_free(addr_str);
  infd_xml_server_new_connection(
    INFD_XML_SERVER(xmpp_server),
    INF_XML_CONNECTION(xmpp_connection)
  );
  g_object_unref(G_OBJECT(xmpp_connection));
}
static void
infd_xmpp_server_error_cb(InfdTcpServer* tcp_server,
                          GError* error,
                          gpointer user_data)
{
  g_signal_emit(
    G_OBJECT(user_data),
    xmpp_server_signals[ERROR],
    0,
    error
  );
}
static void
infd_xmpp_server_notify_status_cb(InfdTcpServer* tcp_server,
                                  GParamSpec* pspec,
                                  gpointer user_data)
{
  InfdXmppServer* xmpp;
  InfdXmppServerPrivate* priv;
  InfdTcpServerStatus status;
  xmpp = INFD_XMPP_SERVER(user_data);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  g_object_get(G_OBJECT(tcp_server), "status", &amp;status, NULL);
  switch(status)
  {
  case INFD_TCP_SERVER_CLOSED:
  case INFD_TCP_SERVER_BOUND:
    if(priv-&gt;status != INFD_XMPP_SERVER_CLOSED)
    {
      priv-&gt;status = INFD_XMPP_SERVER_CLOSED;
      g_object_notify(G_OBJECT(xmpp), "status");
    }
    break;
  case INFD_TCP_SERVER_OPEN:
    if(priv-&gt;status != INFD_XMPP_SERVER_OPEN)
    {
      priv-&gt;status = INFD_XMPP_SERVER_OPEN;
      g_object_notify(G_OBJECT(xmpp), "status");
    }
    break;
  default:
    g_assert_not_reached();
    break;
  }
}
static void
infd_xmpp_server_sasl_cb(InfSaslContextSession* session,
                         Gsasl_property property,
                         gpointer session_data,
                         gpointer user_data)
{
  InfdXmppServer* xmpp;
  InfdXmppServerPrivate* priv;
  xmpp = INFD_XMPP_SERVER(user_data);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  switch(property)
  {
  case GSASL_ANONYMOUS_TOKEN:
    inf_sasl_context_session_set_property(
      session,
      GSASL_ANONYMOUS_TOKEN,
      priv-&gt;local_hostname
    );
    inf_sasl_context_session_continue(session, GSASL_OK);
    break;
  case GSASL_VALIDATE_ANONYMOUS:
    inf_sasl_context_session_continue(session, GSASL_OK);
    break;
  default:
    g_assert_not_reached();
    inf_sasl_context_session_continue(session, GSASL_NO_CALLBACK);
    break;
  }
}
static void
infd_xmpp_server_setup_own_sasl_context(InfdXmppServer* xmpp)
{
  InfdXmppServerPrivate* priv;
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  g_assert(priv-&gt;sasl_own_context == NULL);
  if(priv-&gt;sasl_context == NULL &amp;&amp; priv-&gt;tcp != NULL)
  {
    priv-&gt;sasl_own_context = inf_sasl_context_new(NULL);
    if(priv-&gt;sasl_own_context != NULL)
    {
      priv-&gt;sasl_context = priv-&gt;sasl_own_context;
      inf_sasl_context_ref(priv-&gt;sasl_context);
      inf_sasl_context_set_callback(
        priv-&gt;sasl_context,
        infd_xmpp_server_sasl_cb,
        xmpp,
        NULL
      );
      g_object_notify(G_OBJECT(xmpp), "sasl-context");
    }
  }
}
static void
infd_xmpp_server_set_tcp(InfdXmppServer* xmpp,
                         InfdTcpServer* tcp)
{
  InfdXmppServerPrivate* priv;
  InfdTcpServerStatus tcp_status;
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  g_object_freeze_notify(G_OBJECT(xmpp));
  if(priv-&gt;tcp != NULL)
  {
    g_object_get(G_OBJECT(priv-&gt;tcp), "status", &amp;tcp_status, NULL);
    if(tcp_status != INFD_TCP_SERVER_CLOSED)
      infd_tcp_server_close(priv-&gt;tcp);
    if(priv-&gt;sasl_own_context != NULL)
    {
      inf_sasl_context_unref(priv-&gt;sasl_own_context);
      priv-&gt;sasl_own_context = NULL;
    }
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;tcp),
      G_CALLBACK(infd_xmpp_server_new_connection_cb),
      xmpp
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;tcp),
      G_CALLBACK(infd_xmpp_server_error_cb),
      xmpp
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;tcp),
      G_CALLBACK(infd_xmpp_server_notify_status_cb),
      xmpp
    );
    g_object_unref(G_OBJECT(priv-&gt;tcp));
  }
  priv-&gt;tcp = tcp;
  if(tcp != NULL)
  {
    g_object_ref(G_OBJECT(tcp));
    g_signal_connect(
      G_OBJECT(tcp),
      "new-connection",
      G_CALLBACK(infd_xmpp_server_new_connection_cb),
      xmpp
    );
    g_signal_connect(
      G_OBJECT(tcp),
      "error",
      G_CALLBACK(infd_xmpp_server_error_cb),
      xmpp
    );
    g_signal_connect(
      G_OBJECT(tcp),
      "notify::status",
      G_CALLBACK(infd_xmpp_server_notify_status_cb),
      xmpp
    );
    g_object_get(G_OBJECT(tcp), "status", &amp;tcp_status, NULL);
    switch(tcp_status)
    {
    case INFD_TCP_SERVER_CLOSED:
    case INFD_TCP_SERVER_BOUND:
      g_assert(priv-&gt;status == INFD_XMPP_SERVER_CLOSED);
      break;
    case INFD_TCP_SERVER_OPEN:
      priv-&gt;status = INFD_XMPP_SERVER_OPEN;
      g_object_notify(G_OBJECT(xmpp), "status");
      break;
    default:
      g_assert_not_reached();
      break;
    }
  }
  infd_xmpp_server_setup_own_sasl_context(xmpp);
  g_object_thaw_notify(G_OBJECT(xmpp));
}
static void
infd_xmpp_server_init(InfdXmppServer* xmpp)
{
  InfdXmppServerPrivate* priv;
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  priv-&gt;tcp = NULL;
  priv-&gt;status = INFD_XMPP_SERVER_CLOSED;
  priv-&gt;local_hostname = g_strdup(g_get_host_name());
  priv-&gt;security_policy = INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED;
  priv-&gt;tls_creds = NULL;
  priv-&gt;sasl_context = NULL;
  priv-&gt;sasl_own_context = NULL;
  priv-&gt;sasl_mechanisms = NULL;
}
static void
infd_xmpp_server_dispose(GObject* object)
{
  InfdXmppServer* xmpp;
  InfdXmppServerPrivate* priv;
  xmpp = INFD_XMPP_SERVER(object);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  if(priv-&gt;status != INFD_XMPP_SERVER_CLOSED)
    infd_xml_server_close(INFD_XML_SERVER(xmpp));
  infd_xmpp_server_set_tcp(xmpp, NULL);
  if(priv-&gt;sasl_own_context != NULL)
  {
    inf_sasl_context_unref(priv-&gt;sasl_own_context);
    priv-&gt;sasl_own_context = NULL;
  }
  if(priv-&gt;sasl_context != NULL)
  {
    inf_sasl_context_unref(priv-&gt;sasl_context);
    priv-&gt;sasl_context = NULL;
  }
  if(priv-&gt;tls_creds != NULL)
  {
    inf_certificate_credentials_unref(priv-&gt;tls_creds);
    priv-&gt;tls_creds = NULL;
<a name="1"></a>  }
  G_OBJECT_CLASS(infd_xmpp_server_parent_class)-&gt;dispose(object);
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
static void
infd_xmpp_server_finalize(GObject* object)
{
  InfdXmppServer* xmpp;
  InfdXmppServerPrivate* priv;
  xmpp = INFD_XMPP_SERVER(object);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  g_free(priv-&gt;local_hostname);
  g_free(priv-&gt;sasl_mechanisms);
  G_OBJECT_CLASS(infd_xmpp_server_parent_class)-&gt;finalize(object);
}
static void
infd_xmpp_server_set_property(GObject* object,
                              guint prop_id,
                              const GValue* value,
                              GParamSpec* pspec)
{
  InfdXmppServer* xmpp;
  InfdXmppServerPrivate* priv;
  xmpp = INFD_XMPP_SERVER(object);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);
  switch(prop_id)
  {
  case PROP_TCP:</b></font>
    infd_xmpp_server_set_tcp(
      xmpp,
      INFD_TCP_SERVER(g_value_get_object(value))
    );
    break;
  case PROP_LOCAL_HOSTNAME:
    g_free(priv-&gt;local_hostname);
    priv-&gt;local_hostname = g_value_dup_string(value);
    if(priv-&gt;local_hostname == NULL)
      priv-&gt;local_hostname = g_strdup(g_get_host_name());
    break;
  case PROP_CREDENTIALS:
    if(priv-&gt;tls_creds != NULL)
      inf_certificate_credentials_unref(priv-&gt;tls_creds);
    priv-&gt;tls_creds = g_value_dup_boxed(value);
    break;
  case PROP_SASL_CONTEXT:
    if(priv-&gt;sasl_own_context != NULL)
    {
      inf_sasl_context_unref(priv-&gt;sasl_own_context);
      priv-&gt;sasl_own_context = NULL;
    }
    if(priv-&gt;sasl_context != NULL)
      inf_sasl_context_unref(priv-&gt;sasl_context);
    priv-&gt;sasl_context = g_value_dup_boxed(value);
    infd_xmpp_server_setup_own_sasl_context(xmpp);
    break;
<a name="2"></a>  case PROP_SASL_MECHANISMS:
    g_free(priv-&gt;sasl_mechanisms);
    priv-&gt;sasl_mechanisms = g_value_dup_string(value);
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
  case PROP_SECURITY_POLICY:
    infd_xmpp_server_set_security_policy(xmpp, g_value_get_enum(value));
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
infd_xmpp_server_get_property(GObject* object,
                              guint prop_id,
                              GValue* value,
                              GParamSpec* pspec)
{
  InfdXmppServer* xmpp;
  InfdXmppServerPrivate* priv;
  xmpp = INFD_XMPP_SERVER(object);
  priv = INFD_XMPP_SERVER_PRIVATE(xmpp);</b></font>
  switch(prop_id)
  {
  case PROP_STATUS:
    switch(priv-&gt;status)
    {
    case INFD_XMPP_SERVER_CLOSED:
      g_value_set_enum(value, INFD_XML_SERVER_CLOSED);
      break;
    case INFD_XMPP_SERVER_OPEN:
      g_value_set_enum(value, INFD_XML_SERVER_OPEN);
      break;
    default:
      g_assert_not_reached();
      break;
    }
    break;
  case PROP_TCP:
    g_value_set_object(value, priv-&gt;tcp);
<a name="0"></a>    break;
  case PROP_LOCAL_HOSTNAME:
    g_value_set_string(value, priv-&gt;local_hostname);
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
  case PROP_CREDENTIALS:
    g_value_set_boxed(value, priv-&gt;tls_creds);
    break;
  case PROP_SASL_CONTEXT:
    g_value_set_boxed(value, priv-&gt;sasl_context);
    break;
  case PROP_SASL_MECHANISMS:
    g_value_set_string(value, priv-&gt;sasl_mechanisms);
    break;
  case PROP_SECURITY_POLICY:
    g_value_set_enum(value, priv-&gt;security_policy);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
infd_xmpp_server_xml_server_close(InfdXmlServer* xml)
{
  InfdXmppServerPrivate* priv;
  priv = INFD_XMPP_SERVER_PRIVATE(xml);</b></font>
  g_return_if_fail(priv-&gt;status != INFD_XMPP_SERVER_CLOSED);
  switch(priv-&gt;status)
  {
  case INFD_XMPP_SERVER_OPEN:
    infd_tcp_server_close(priv-&gt;tcp);
    break;
  case INFD_XMPP_SERVER_CLOSED:
  default:
    g_assert_not_reached();
    break;
  }
}
static void
infd_xmpp_server_class_init(InfdXmppServerClass* xmpp_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(xmpp_class);
  object_class-&gt;dispose = infd_xmpp_server_dispose;
  object_class-&gt;finalize = infd_xmpp_server_finalize;
  object_class-&gt;set_property = infd_xmpp_server_set_property;
  object_class-&gt;get_property = infd_xmpp_server_get_property;
  xmpp_class-&gt;error = NULL;
  g_object_class_install_property(
    object_class,
    PROP_TCP,
    g_param_spec_object(
      "tcp-server",
      "TCP server",
      "Underlaying TCP server",
      INFD_TYPE_TCP_SERVER,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_LOCAL_HOSTNAME,
    g_param_spec_string(
      "local-hostname",
      "Local hostname",
      "Hostname of the server",
      NULL,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_CREDENTIALS,
    g_param_spec_boxed(
      "credentials",
      "Credentials",
      "The certificate credentials for GnuTLS",
      INF_TYPE_CERTIFICATE_CREDENTIALS,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SASL_CONTEXT,
    g_param_spec_boxed(
      "sasl-context",
      "SASL context",
      "The SASL context used for authentaction",
      INF_TYPE_SASL_CONTEXT,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SASL_MECHANISMS,
    g_param_spec_string(
      "sasl-mechanisms",
      "SASL mechanisms",
      "The SASL mechanisms offered to the client for authentication",
      NULL,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SECURITY_POLICY,
    g_param_spec_enum(
      "security-policy",
      "Security policy",
      "Whether to offer or require TLS",
      INF_TYPE_XMPP_CONNECTION_SECURITY_POLICY,
      INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );
  g_object_class_override_property(object_class, PROP_STATUS, "status");
  xmpp_server_signals[ERROR] = g_signal_new(
    "error",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET(InfdXmppServerClass, error),
    NULL, NULL,
    g_cclosure_marshal_VOID__BOXED,
    G_TYPE_NONE,
    1,
    G_TYPE_ERROR
  );
}
static void
infd_xmpp_server_xml_server_iface_init(InfdXmlServerInterface* iface)
{
  iface-&gt;close = infd_xmpp_server_xml_server_close;
}
InfdXmppServer*
infd_xmpp_server_new(InfdTcpServer* tcp,
                     InfXmppConnectionSecurityPolicy policy,
                     InfCertificateCredentials* creds,
                     InfSaslContext* sasl_context,
                     const gchar* sasl_mechanisms)
{
  GObject* object;
  g_return_val_if_fail(INFD_IS_TCP_SERVER(tcp), NULL);
  g_return_val_if_fail(
    policy == INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED || creds != NULL,
    NULL
  );
  object = g_object_new(
    INFD_TYPE_XMPP_SERVER,
    "tcp-server", tcp,
    "credentials", creds,
    "security-policy", policy,
    "sasl-context", sasl_context,
    "sasl-mechanisms", sasl_mechanisms,
    NULL
  );
  return INFD_XMPP_SERVER(object);
}
void
infd_xmpp_server_set_security_policy(InfdXmppServer* server,
                                     InfXmppConnectionSecurityPolicy policy)
{
  InfdXmppServerPrivate* priv;
  g_return_if_fail(INFD_IS_XMPP_SERVER(server));
  priv = INFD_XMPP_SERVER_PRIVATE(server);
  if(policy != priv-&gt;security_policy)
  {
    g_return_if_fail(
      policy == INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED ||
      priv-&gt;tls_creds != NULL
    );
    priv-&gt;security_policy = policy;
    g_object_notify(G_OBJECT(server), "security-policy");
  }
}
InfXmppConnectionSecurityPolicy
infd_xmpp_server_get_security_policy(InfdXmppServer* server)
{
  g_return_val_if_fail(
    INFD_IS_XMPP_SERVER(server),
    INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS
  );
  return INFD_XMPP_SERVER_PRIVATE(server)-&gt;security_policy;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-gtk-buffer.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinftextgtk/inf-text-gtk-buffer.h&gt;
#include &lt;libinftext/inf-text-buffer.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
#include &lt;string.h&gt; 
struct _InfTextBufferIter {
  GtkTextIter begin;
  GtkTextIter end;
  InfTextUser* user;
};
typedef struct _InfTextGtkBufferRecord InfTextGtkBufferRecord;
struct _InfTextGtkBufferRecord {
  gboolean insert;
  guint char_count;
  guint position;
  InfTextChunk* chunk;
  gboolean applied;
  InfTextGtkBufferRecord* next;
};
typedef struct _InfTextGtkBufferUserTags InfTextGtkBufferUserTags;
struct _InfTextGtkBufferUserTags {
  InfTextGtkBuffer* buffer;
  InfTextUser* user;
  GtkTextTag* colored_tag;
  GtkTextTag* colorless_tag;
};
typedef struct _InfTextGtkBufferTagRemove InfTextGtkBufferTagRemove;
struct _InfTextGtkBufferTagRemove {
  GtkTextBuffer* buffer;
  GtkTextIter begin_iter;
  GtkTextIter end_iter;
  InfTextGtkBufferUserTags* ignore_tags;
};
typedef struct _InfTextGtkBufferPrivate InfTextGtkBufferPrivate;
struct _InfTextGtkBufferPrivate {
  GtkTextBuffer* buffer;
  InfUserTable* user_table;
  GHashTable* user_tags;
  InfTextGtkBufferRecord* record;
  gboolean show_user_colors;
  InfTextUser* active_user;
  gboolean wake_on_cursor_movement;
  gdouble saturation;
  gdouble value;
  gdouble alpha;
};
enum {
  PROP_0,
  PROP_BUFFER,
  PROP_USER_TABLE,
  PROP_ACTIVE_USER,
  PROP_WAKE_ON_CURSOR_MOVEMENT,
  PROP_SHOW_USER_COLORS,
  PROP_SATURATION,
  PROP_VALUE,
  PROP_ALPHA,
  PROP_MODIFIED
};
#define INF_TEXT_GTK_BUFFER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_GTK_TYPE_BUFFER, InfTextGtkBufferPrivate))
static GQuark inf_text_gtk_buffer_tag_user_quark;
static void inf_text_gtk_buffer_buffer_iface_init(InfBufferInterface* iface);
static void inf_text_gtk_buffer_text_buffer_iface_init(InfTextBufferInterface* iface);
G_DEFINE_TYPE_WITH_CODE(InfTextGtkBuffer, inf_text_gtk_buffer, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfTextGtkBuffer)
  G_IMPLEMENT_INTERFACE(INF_TYPE_BUFFER, inf_text_gtk_buffer_buffer_iface_init)
  G_IMPLEMENT_INTERFACE(INF_TEXT_TYPE_BUFFER, inf_text_gtk_buffer_text_buffer_iface_init))
static void
inf_text_gtk_update_tag_color(InfTextGtkBuffer* buffer,
                              GtkTextTag* tag,
                              InfTextUser* user)
{
  InfTextGtkBufferPrivate* priv;
  gdouble hue;
  gdouble saturation;
  gdouble value;
  GdkRGBA rgba;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  hue = inf_text_user_get_hue(user);
  saturation = priv-&gt;saturation;
  value = priv-&gt;value;
  gtk_hsv_to_rgb(hue, saturation, value, &amp;rgba.red, &amp;rgba.green, &amp;rgba.blue);
  rgba.alpha = priv-&gt;alpha;
  g_object_set(G_OBJECT(tag), "background-rgba", &amp;rgba, NULL);
}
static void
inf_text_gtk_user_notify_hue_cb(GObject* object,
                                GParamSpec* pspec,
                                gpointer user_data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  guint user_id;
  InfTextGtkBufferUserTags* tags;
  buffer = INF_TEXT_GTK_BUFFER(user_data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  user_id = inf_user_get_id(INF_USER(object));
  tags = g_hash_table_lookup(priv-&gt;user_tags, GUINT_TO_POINTER(user_id));
  g_assert(tags != NULL &amp;&amp; tags-&gt;colored_tag != NULL);
  inf_text_gtk_update_tag_color(
    buffer,
    tags-&gt;colored_tag,
    INF_TEXT_USER(object)
  );
}
static void
inf_text_gtk_buffer_user_tags_free(gpointer user_tags)
{
  InfTextGtkBufferUserTags* tags;
  tags = (InfTextGtkBufferUserTags*)user_tags;
  if(tags-&gt;colored_tag)
  {
    inf_signal_handlers_disconnect_by_func(
      tags-&gt;user,
      G_CALLBACK(inf_text_gtk_user_notify_hue_cb),
      tags-&gt;buffer
    );
    g_object_unref(tags-&gt;colored_tag);
  }
  if(tags-&gt;colorless_tag)
    g_object_unref(tags-&gt;colorless_tag);
  g_slice_free(InfTextGtkBufferUserTags, tags);
}
static InfTextGtkBufferUserTags*
inf_text_gtk_buffer_get_user_tags(InfTextGtkBuffer* buffer,
                                  guint user_id)
{
  InfTextGtkBufferPrivate* priv;
  InfTextGtkBufferUserTags* tags;
  InfUser* user;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  if(user_id == 0)
    return NULL;
  tags = g_hash_table_lookup(priv-&gt;user_tags, GUINT_TO_POINTER(user_id));
  if(tags != NULL)
  {
    return tags;
  }
  else
  {
    user = inf_user_table_lookup_user_by_id(priv-&gt;user_table, user_id);
    g_assert(INF_TEXT_IS_USER(user));
    tags = g_slice_new(InfTextGtkBufferUserTags);
    tags-&gt;buffer = buffer;
    tags-&gt;user = INF_TEXT_USER(user);
    tags-&gt;colored_tag = NULL;
    tags-&gt;colorless_tag = NULL;
    g_hash_table_insert(priv-&gt;user_tags, GUINT_TO_POINTER(user_id), tags);
    return tags;
  }
}
static GtkTextTag*
inf_text_gtk_buffer_get_user_tag(InfTextGtkBuffer* buffer,
                                 InfTextGtkBufferUserTags* user_tags,
                                 gboolean colored)
{
  InfTextGtkBufferPrivate* priv;
  GtkTextTagTable* table;
  GtkTextTag** tag;
  gchar* tag_name;
  guint user_id;
  const gchar* colorstr;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  tag = colored ? &amp;user_tags-&gt;colored_tag : &amp;user_tags-&gt;colorless_tag;
  if(*tag != NULL) return *tag;
  user_id = 0;
  if(user_tags-&gt;user != NULL)
    user_id = inf_user_get_id(INF_USER(user_tags-&gt;user));
  colorstr = colored ? "colored" : "colorless";
  tag_name = g_strdup_printf("inftextgtk-user-%s-%u", colorstr, user_id);
  *tag = gtk_text_tag_new(tag_name);
  g_free(tag_name);
  table = gtk_text_buffer_get_tag_table(priv-&gt;buffer);
  gtk_text_tag_table_add(table, *tag);
  gtk_text_tag_set_priority(*tag, 0);
  g_object_set_qdata(
    G_OBJECT(*tag),
    inf_text_gtk_buffer_tag_user_quark,
    user_tags-&gt;user
  );
  if(colored)
  {
    g_signal_connect(
      G_OBJECT(user_tags-&gt;user),
      "notify::hue",
      G_CALLBACK(inf_text_gtk_user_notify_hue_cb),
      buffer
    );
    inf_text_gtk_update_tag_color(buffer, *tag, user_tags-&gt;user);
  }
  return *tag;
}
static InfTextUser*
inf_text_gtk_buffer_author_from_tag(GtkTextTag* tag)
{
  gpointer author_ptr;
  author_ptr = g_object_get_qdata(
    G_OBJECT(tag),
    inf_text_gtk_buffer_tag_user_quark
  );
  return INF_TEXT_USER(author_ptr);
}
static InfTextUser*
inf_text_gtk_buffer_iter_list_contains_author_tag(GSList* tag_list)
{
  GSList* item;
  InfTextUser* author;
  for(item = tag_list; item != NULL; item = g_slist_next(item))
  {
    author = inf_text_gtk_buffer_author_from_tag(GTK_TEXT_TAG(item-&gt;data));
    if(author != NULL) return author;
  }
  return NULL;
}
static InfTextUser*
inf_text_gtk_buffer_iter_get_author(GtkTextIter* location)
{
  GSList* tag_list;
  InfTextUser* author;
  tag_list = gtk_text_iter_get_tags(location);
  author = inf_text_gtk_buffer_iter_list_contains_author_tag(tag_list);
  g_slist_free(tag_list);
  return author;
}
static gboolean
inf_text_gtk_buffer_iter_is_author_toggle(const GtkTextIter* iter,
                                          InfTextUser** toggled_on,
                                          InfTextUser** toggled_off)
{
  GSList* tag_list;
  InfTextUser* author_on;
  InfTextUser* author_off;
  tag_list = gtk_text_iter_get_toggled_tags(iter, TRUE);
  author_on = inf_text_gtk_buffer_iter_list_contains_author_tag(tag_list);
  g_slist_free(tag_list);
  if(author_on == NULL || toggled_off != NULL)
  {
    tag_list = gtk_text_iter_get_toggled_tags(iter, FALSE);
    author_off = inf_text_gtk_buffer_iter_list_contains_author_tag(tag_list);
    g_slist_free(tag_list);
  }
  if(author_on == NULL &amp;&amp; author_off == NULL)
    if(!gtk_text_iter_is_start(iter) &amp;&amp; !gtk_text_iter_is_end(iter))
      return FALSE;
  if(toggled_on) *toggled_on = author_on;
  if(toggled_off) *toggled_off = author_off;
  return TRUE;
}
static void
inf_text_gtk_buffer_iter_next_author_toggle(GtkTextIter* iter,
                                            InfTextUser** user_on,
                                            InfTextUser** user_off)
{
  gboolean is_author_toggle;
  do
  {
    gtk_text_iter_forward_to_tag_toggle(iter, NULL);
    is_author_toggle = inf_text_gtk_buffer_iter_is_author_toggle(
      iter,
      user_on,
      user_off
    );
  } while(!is_author_toggle);
}
static void
inf_text_gtk_buffer_iter_prev_author_toggle(GtkTextIter* iter,
                                            InfTextUser** user_on,
                                            InfTextUser** user_off)
{
  gboolean is_author_toggle;
  do
  {
    gtk_text_iter_backward_to_tag_toggle(iter, NULL);
    is_author_toggle = inf_text_gtk_buffer_iter_is_author_toggle(
      iter,
      user_on,
      user_off
    );
  } while(!is_author_toggle);
}
static void
inf_text_gtk_buffer_ensure_author_tags_priority_foreach_func(GtkTextTag* tag,
                                                             gpointer data)
{
  InfTextUser* author;
  author = inf_text_gtk_buffer_author_from_tag(tag);
  if(author != NULL)
    gtk_text_tag_set_priority(tag, 0);
}
static void
inf_text_gtk_buffer_update_user_color_tag_table_foreach_func(GtkTextTag* tag,
                                                             gpointer data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  InfTextUser* author;
  buffer = INF_TEXT_GTK_BUFFER(data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  author = inf_text_gtk_buffer_author_from_tag(tag);
  if(author != NULL)
    inf_text_gtk_update_tag_color(buffer, tag, author);
}
static void
inf_text_gtk_buffer_active_user_selection_changed_cb(InfTextUser* user,
                                                     guint position,
                                                     gint length,
                                                     gboolean by_request,
                                                     gpointer user_data);
static void
inf_text_gtk_buffer_active_user_notify_status_cb(GObject* object,
                                                 GParamSpec* pspec,
                                                 gpointer user_data);
static void
inf_text_gtk_buffer_apply_tag_cb(GtkTextBuffer* gtk_buffer,
                                 GtkTextTag* tag,
                                 GtkTextIter* start,
                                 GtkTextIter* end,
                                 gpointer user_data)
{
  if(inf_text_gtk_buffer_author_from_tag(tag) != NULL)
    g_signal_stop_emission_by_name(G_OBJECT(gtk_buffer), "apply-tag");
}
static void
inf_text_gtk_buffer_buffer_insert_text_tag_table_foreach_func(GtkTextTag* tag,
                                                              gpointer data)
{
  InfTextGtkBufferTagRemove* tag_remove;
  tag_remove = (InfTextGtkBufferTagRemove*)data;
  if(tag_remove-&gt;ignore_tags == NULL ||
     (tag != tag_remove-&gt;ignore_tags-&gt;colored_tag &amp;&amp;
      tag != tag_remove-&gt;ignore_tags-&gt;colorless_tag))
  {
    gtk_text_buffer_remove_tag(
      tag_remove-&gt;buffer,
      tag,
      &amp;tag_remove-&gt;begin_iter,
      &amp;tag_remove-&gt;end_iter
    );
  }
}
#ifndef G_DISABLE_ASSERT
static gboolean
inf_text_gtk_buffer_record_check(InfTextGtkBuffer* buffer,
                                 InfTextGtkBufferRecord* record)
{
  InfTextGtkBufferPrivate* priv;
  InfTextChunk* chunk;
  guint text_len;
  guint buf_len;
  gpointer buf_text;
  gpointer chunk_text;
  gsize buf_bytes;
  gsize chunk_bytes;
  int result;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  text_len = inf_text_chunk_get_length(record-&gt;chunk);
  buf_len = gtk_text_buffer_get_char_count(priv-&gt;buffer);
  if(record-&gt;insert)
  {
    if(record-&gt;char_count + text_len != buf_len)
      return FALSE;
    if(record-&gt;position + text_len &gt; buf_len)
      return FALSE;
    chunk = inf_text_buffer_get_slice(
      INF_TEXT_BUFFER(buffer),
      record-&gt;position,
      text_len
    );
    buf_text = inf_text_chunk_get_text(record-&gt;chunk, &amp;buf_bytes);
    chunk_text = inf_text_chunk_get_text(chunk, &amp;chunk_bytes);
    inf_text_chunk_free(chunk);
    if(buf_bytes == chunk_bytes)
      result = memcmp(buf_text, chunk_text, buf_bytes);
    else
      result = -1;
    g_free(buf_text);
    g_free(chunk_text);
    if(result != 0) return FALSE;
  }
  else
  {
    if(text_len &gt; record-&gt;char_count)
      return FALSE;
    if(record-&gt;char_count - text_len != buf_len)
      return FALSE;
  }
  return TRUE;
}
#endif
static void
inf_text_gtk_buffer_record_transform(InfTextGtkBufferRecord* record,
                                     InfTextGtkBufferRecord* against)
{
  guint record_len;
  guint against_len;
  g_assert(record-&gt;applied == FALSE);
  g_assert(against-&gt;applied == TRUE);
  record_len = inf_text_chunk_get_length(record-&gt;chunk);
  against_len = inf_text_chunk_get_length(against-&gt;chunk);
  if(record-&gt;insert &amp;&amp; against-&gt;insert)
  {
    if(record-&gt;position &gt;= against-&gt;position)
      record-&gt;position += against_len;
  }
  else if(record-&gt;insert &amp;&amp; !against-&gt;insert)
  {
    if(record-&gt;position &gt;= against-&gt;position + against_len)
      record-&gt;position -= against_len;
    else if(record-&gt;position &gt;= against-&gt;position)
      record-&gt;position = against-&gt;position;
  }
  else if(!record-&gt;insert &amp;&amp; against-&gt;insert)
  {
    if(record-&gt;position &gt;= against-&gt;position)
    {
      record-&gt;position += against-&gt;position;
    }
    else if(record-&gt;position &lt; against-&gt;position &amp;&amp;
            record-&gt;position + record_len &gt; against-&gt;position)
    {
      inf_text_chunk_insert_chunk(
        record-&gt;chunk,
        against-&gt;position - record-&gt;position,
        against-&gt;chunk
      );
    }
  }
  else if(!record-&gt;insert &amp;&amp; !against-&gt;insert)
  {
    if(against-&gt;position + against_len &lt;= record-&gt;position + record_len)
    {
      record-&gt;position -= against_len;
    }
    else if(against-&gt;position + against_len &gt; record-&gt;position &amp;&amp;
            against-&gt;position + against_len &lt;= record-&gt;position + record_len)
    {
      record-&gt;position = against-&gt;position;
      inf_text_chunk_erase(
        record-&gt;chunk,
        0,
        against-&gt;position + against_len - record-&gt;position
      );
    }
    else if(against-&gt;position &lt;= record-&gt;position &amp;&amp;
            against-&gt;position + against_len &gt;= record-&gt;position + record_len)
    {
      record-&gt;position = against-&gt;position;
      inf_text_chunk_erase(
        record-&gt;chunk,
        0,
        inf_text_chunk_get_length(record-&gt;chunk)
      );
    }
    else if(against-&gt;position &gt;= record-&gt;position &amp;&amp;
            against-&gt;position + against_len &lt;= record-&gt;position + record_len)
    {
      inf_text_chunk_erase(
        record-&gt;chunk,
        against-&gt;position - record-&gt;position,
        inf_text_chunk_get_length(against-&gt;chunk)
      );
    }
    else if(against-&gt;position &gt;= record-&gt;position &amp;&amp;
            against-&gt;position + against_len &gt;= record-&gt;position + record_len)
    {
      inf_text_chunk_erase(
        record-&gt;chunk,
        against-&gt;position - record-&gt;position,
        record-&gt;position + record_len - against-&gt;position
      );
    }
  }
  if(against-&gt;insert)
  {
    record-&gt;char_count += against_len;
  }
  else
  {
    g_assert(record-&gt;char_count &gt;= against_len);
    record-&gt;char_count -= against_len;
  }
}
static void
inf_text_gtk_buffer_record_signal(InfTextGtkBuffer* buffer,
                                  InfTextGtkBufferRecord* record)
{
  InfTextGtkBufferPrivate* priv;
  InfTextGtkBufferRecord* rec;
  InfTextGtkBufferTagRemove tag_remove;
  GtkTextTag* tag;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  g_assert(priv-&gt;active_user != NULL);
  g_assert(record-&gt;applied == FALSE);
  g_assert(inf_text_gtk_buffer_record_check(buffer, record));
  record-&gt;applied = TRUE;
  for(rec = record-&gt;next; rec != NULL; rec = rec-&gt;next)
    if(!rec-&gt;applied)
      inf_text_gtk_buffer_record_transform(rec-&gt;next, record);
  if(record-&gt;insert)
  {
    inf_signal_handlers_block_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
      buffer
    );
    tag_remove.buffer = priv-&gt;buffer;
    tag_remove.ignore_tags = inf_text_gtk_buffer_get_user_tags(
      buffer,
      inf_user_get_id(INF_USER(priv-&gt;active_user))
    );
    g_assert(tag_remove.ignore_tags != NULL);
    tag = inf_text_gtk_buffer_get_user_tag(
      buffer,
      tag_remove.ignore_tags,
      priv-&gt;show_user_colors
    );
    gtk_text_buffer_get_iter_at_offset(
      priv-&gt;buffer,
      &amp;tag_remove.begin_iter,
      record-&gt;position
    );
    gtk_text_buffer_get_iter_at_offset(
      priv-&gt;buffer,
      &amp;tag_remove.end_iter,
      record-&gt;position + inf_text_chunk_get_length(record-&gt;chunk)
    );
    gtk_text_tag_table_foreach(
      gtk_text_buffer_get_tag_table(tag_remove.buffer),
      inf_text_gtk_buffer_buffer_insert_text_tag_table_foreach_func,
      &amp;tag_remove
    );
    gtk_text_buffer_apply_tag(
      priv-&gt;buffer,
      tag,
      &amp;tag_remove.begin_iter,
      &amp;tag_remove.end_iter
    );
    inf_signal_handlers_unblock_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
      buffer
    );
  }
  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;active_user),
    G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
    buffer
  );
  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;active_user),
    G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
    buffer
  );
  if(record-&gt;insert)
  {
    inf_text_buffer_text_inserted(
      INF_TEXT_BUFFER(buffer),
      record-&gt;position,
      record-&gt;chunk,
      INF_USER(priv-&gt;active_user)
    );
  }
  else
  {
    inf_text_buffer_text_erased(
      INF_TEXT_BUFFER(buffer),
      record-&gt;position,
      record-&gt;chunk,
      INF_USER(priv-&gt;active_user)
    );
  }
  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;active_user),
    G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
    buffer
  );
  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;active_user),
    G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
    buffer
  );
}
static void
inf_text_gtk_buffer_push_record(InfTextGtkBuffer* buffer,
                                gboolean insert,
                                guint position,
                                InfTextChunk* chunk)
{
  InfTextGtkBufferPrivate* priv;
  InfTextGtkBufferRecord* rec;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  rec = priv-&gt;record;
  priv-&gt;record = g_slice_new(InfTextGtkBufferRecord);
  priv-&gt;record-&gt;insert = insert;
  priv-&gt;record-&gt;char_count = gtk_text_buffer_get_char_count(priv-&gt;buffer);
  priv-&gt;record-&gt;position = position;
  priv-&gt;record-&gt;chunk = chunk;
  priv-&gt;record-&gt;applied = FALSE;
  priv-&gt;record-&gt;next = rec;
  if(rec != NULL &amp;&amp; rec-&gt;applied == FALSE)
  {
    if(rec-&gt;char_count != (guint)gtk_text_buffer_get_char_count(priv-&gt;buffer))
    {
      inf_text_gtk_buffer_record_signal(buffer, rec);
#ifndef G_ASSERT_DISABLED
      for(; rec != NULL; rec = rec-&gt;next)
      {
        g_assert(
          rec-&gt;applied == TRUE ||
          rec-&gt;char_count ==
            (guint)gtk_text_buffer_get_char_count(priv-&gt;buffer)
        );
      }
#endif
    }
  }
}
static void
inf_text_gtk_buffer_pop_record(InfTextGtkBuffer* buffer)
{
  InfTextGtkBufferPrivate* priv;
  InfTextGtkBufferRecord* rec;
  guint char_count;
  guint length;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  g_assert(priv-&gt;record != NULL);
  if(!priv-&gt;record-&gt;applied)
  {
    length = inf_text_chunk_get_length(priv-&gt;record-&gt;chunk);
    char_count = gtk_text_buffer_get_char_count(priv-&gt;buffer);
    if(priv-&gt;record-&gt;insert)
    {
      g_assert(priv-&gt;record-&gt;char_count + length == char_count);
    }
    else
    {
      g_assert(priv-&gt;record-&gt;char_count &gt;= length);
      g_assert(priv-&gt;record-&gt;char_count - length == char_count);
    }
    inf_text_gtk_buffer_record_signal(buffer, priv-&gt;record);
  }
  rec = priv-&gt;record;
  priv-&gt;record = rec-&gt;next;
  inf_text_chunk_free(rec-&gt;chunk);
  g_slice_free(InfTextGtkBufferRecord, rec);
}
static void
inf_text_gtk_buffer_insert_text_cb_before(GtkTextBuffer* gtk_buffer,
                                          GtkTextIter* location,
                                          gchar* text,
                                          gint len,
                                          gpointer user_data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  InfTextChunk* chunk;
  buffer = INF_TEXT_GTK_BUFFER(user_data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  g_assert(priv-&gt;active_user != NULL);
  chunk = inf_text_chunk_new("UTF-8");
  inf_text_chunk_insert_text(
    chunk,
    0,
    text,
    len,
    g_utf8_strlen(text, len),
    inf_user_get_id(INF_USER(priv-&gt;active_user))
  );
  inf_text_gtk_buffer_push_record(
    buffer,
    TRUE,
    gtk_text_iter_get_offset(location),
    chunk
  );
}
static void
inf_text_gtk_buffer_insert_text_cb_after(GtkTextBuffer* gtk_buffer,
                                         GtkTextIter* location,
                                         gchar* text,
                                         gint len,
                                         gpointer user_data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  gpointer rec_text;
  gsize bytes;
  buffer = INF_TEXT_GTK_BUFFER(user_data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  g_assert(priv-&gt;record != NULL);
  g_assert(priv-&gt;record-&gt;insert == TRUE);
#ifndef G_ASSERT_DISABLED
  if(priv-&gt;record-&gt;applied == FALSE)
  {
    g_assert(
      priv-&gt;record-&gt;position +
        inf_text_chunk_get_length(priv-&gt;record-&gt;chunk) ==
      (guint)gtk_text_iter_get_offset(location)
    );
    rec_text = inf_text_chunk_get_text(priv-&gt;record-&gt;chunk, &amp;bytes);
    g_assert(bytes == (gsize)len);
    g_assert(memcmp(text, rec_text, bytes) == 0);
    g_free(rec_text);
  }
#endif
  inf_text_gtk_buffer_pop_record(buffer);
}
static void
inf_text_gtk_buffer_delete_range_cb_before(GtkTextBuffer* gtk_buffer,
                                           GtkTextIter* begin,
                                           GtkTextIter* end,
                                           gpointer user_data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  guint begin_offset;
  guint end_offset;
  InfTextChunk* chunk;
  buffer = INF_TEXT_GTK_BUFFER(user_data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  begin_offset = gtk_text_iter_get_offset(begin);
  end_offset = gtk_text_iter_get_offset(end);
  chunk = inf_text_buffer_get_slice(
    INF_TEXT_BUFFER(buffer),
    begin_offset,
    end_offset - begin_offset
  );
  inf_text_gtk_buffer_push_record(buffer, FALSE, begin_offset, chunk);
}
static void
inf_text_gtk_buffer_delete_range_cb_after(GtkTextBuffer* gtk_buffer,
                                          GtkTextIter* begin,
                                          GtkTextIter* end,
                                          gpointer user_data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  buffer = INF_TEXT_GTK_BUFFER(user_data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  g_assert(priv-&gt;record != NULL);
  g_assert(priv-&gt;record-&gt;insert == FALSE);
  g_assert(priv-&gt;record-&gt;applied == TRUE ||
           priv-&gt;record-&gt;position == (guint)gtk_text_iter_get_offset(begin));
  inf_text_gtk_buffer_pop_record(buffer);
}
static void
inf_text_gtk_buffer_mark_set_cb(GtkTextBuffer* gtk_buffer,
                                GtkTextIter* location,
                                GtkTextMark* mark,
                                gpointer user_data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  GtkTextMark* insert_mark;
  GtkTextMark* sel_mark;
  GtkTextIter insert_iter;
  GtkTextIter sel_iter;
  guint offset;
  int sel;
  buffer = INF_TEXT_GTK_BUFFER(user_data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  insert_mark = gtk_text_buffer_get_insert(gtk_buffer);
  sel_mark = gtk_text_buffer_get_selection_bound(gtk_buffer);
  if( (mark == insert_mark || mark == sel_mark) &amp;&amp; priv-&gt;active_user != NULL)
  {
    if(inf_user_get_status(INF_USER(priv-&gt;active_user)) == INF_USER_ACTIVE ||
       priv-&gt;wake_on_cursor_movement == TRUE)
    {
      gtk_text_buffer_get_iter_at_mark(gtk_buffer, &amp;insert_iter, insert_mark);
      gtk_text_buffer_get_iter_at_mark(gtk_buffer, &amp;sel_iter, sel_mark);
      offset = gtk_text_iter_get_offset(&amp;insert_iter);
      sel = gtk_text_iter_get_offset(&amp;sel_iter) - offset;
      if(inf_text_user_get_caret_position(priv-&gt;active_user) != offset ||
         inf_text_user_get_selection_length(priv-&gt;active_user) != sel)
      {
        inf_signal_handlers_block_by_func(
          G_OBJECT(priv-&gt;active_user),
          G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
          buffer
        );
        inf_signal_handlers_block_by_func(
          G_OBJECT(priv-&gt;active_user),
          G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
          buffer
        );
        inf_text_user_set_selection(priv-&gt;active_user, offset, sel, TRUE);
        inf_signal_handlers_unblock_by_func(
          G_OBJECT(priv-&gt;active_user),
          G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
          buffer
        );
        inf_signal_handlers_unblock_by_func(
          G_OBJECT(priv-&gt;active_user),
          G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
          buffer
        );
      }
    }
  }
}
static void
inf_text_gtk_buffer_active_user_notify_status_cb(GObject* object,
                                                 GParamSpec* pspec,
                                                 gpointer user_data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  GtkTextMark* insert_mark;
  GtkTextMark* sel_mark;
  GtkTextIter insert_iter;
  GtkTextIter sel_iter;
  guint offset;
  int sel;
  buffer = INF_TEXT_GTK_BUFFER(user_data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  g_assert(INF_TEXT_USER(object) == priv-&gt;active_user);
  switch(inf_user_get_status(INF_USER(object)))
  {
  case INF_USER_ACTIVE:
    insert_mark = gtk_text_buffer_get_insert(priv-&gt;buffer);
    sel_mark = gtk_text_buffer_get_selection_bound(priv-&gt;buffer);
    gtk_text_buffer_get_iter_at_mark(priv-&gt;buffer, &amp;insert_iter, insert_mark);
    gtk_text_buffer_get_iter_at_mark(priv-&gt;buffer, &amp;sel_iter, sel_mark);
    offset = gtk_text_iter_get_offset(&amp;insert_iter);
    sel = gtk_text_iter_get_offset(&amp;sel_iter) - offset;
    if(inf_text_user_get_caret_position(priv-&gt;active_user) != offset ||
       inf_text_user_get_selection_length(priv-&gt;active_user) != sel)
    {
      inf_signal_handlers_block_by_func(
        G_OBJECT(priv-&gt;active_user),
        G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
        buffer
      );
      inf_text_user_set_selection(priv-&gt;active_user, offset, sel, TRUE);
      inf_signal_handlers_unblock_by_func(
        G_OBJECT(priv-&gt;active_user),
        G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
        buffer
<a name="2"></a>      );
    }
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
  case INF_USER_UNAVAILABLE:
    break;
  default:
    break;
  }
}
static void
inf_text_gtk_buffer_active_user_selection_changed_cb(InfTextUser* user,
                                                     guint position,
                                                     gint selection_length,
                                                     gboolean by_request,
                                                     gpointer user_data)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  GtkTextIter insert;
  GtkTextIter selection_bound;
  buffer = INF_TEXT_GTK_BUFFER(user_data);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);</b></font>
  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
    buffer
  );
  gtk_text_buffer_get_iter_at_offset(priv-&gt;buffer, &amp;insert, position);
  gtk_text_buffer_get_iter_at_offset(
    priv-&gt;buffer,
    &amp;selection_bound,
    position + selection_length
  );
  gtk_text_buffer_select_range(priv-&gt;buffer, &amp;insert, &amp;selection_bound);
  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
    buffer
  );
}
static void
inf_text_gtk_buffer_modified_changed_cb(GtkTextBuffer* buffer,
                                        gpointer user_data)
{
  g_object_notify(G_OBJECT(user_data), "modified");
}
static void
inf_text_gtk_buffer_set_modified(InfTextGtkBuffer* buffer,
                                 gboolean modified)
{
  InfTextGtkBufferPrivate* priv;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  if(priv-&gt;buffer != NULL)
  {
    inf_signal_handlers_block_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_modified_changed_cb),
      buffer
    );
    gtk_text_buffer_set_modified(priv-&gt;buffer, modified);
    inf_signal_handlers_unblock_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_modified_changed_cb),
      buffer
    );
    g_object_notify(G_OBJECT(buffer), "modified");
  }
}
static void
inf_text_gtk_buffer_set_buffer(InfTextGtkBuffer* buffer,
                               GtkTextBuffer* gtk_buffer)
{
  InfTextGtkBufferPrivate* priv;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  if(priv-&gt;buffer != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
      buffer
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_before),
      buffer
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_after),
      buffer
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_before),
      buffer
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_after),
      buffer
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
      buffer
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;buffer),
      G_CALLBACK(inf_text_gtk_buffer_modified_changed_cb),
      buffer
    );
    g_object_unref(G_OBJECT(priv-&gt;buffer));
  }
  priv-&gt;buffer = gtk_buffer;
  if(gtk_buffer != NULL)
  {
    g_object_ref(G_OBJECT(gtk_buffer));
    g_signal_connect(
      G_OBJECT(gtk_buffer),
      "apply-tag",
      G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
      buffer
    );
    g_signal_connect(
      G_OBJECT(gtk_buffer),
      "insert-text",
      G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_before),
      buffer
    );
    g_signal_connect_after(
      G_OBJECT(gtk_buffer),
      "insert-text",
      G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_after),
      buffer
    );
    g_signal_connect(
      G_OBJECT(gtk_buffer),
      "delete-range",
      G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_before),
      buffer
    );
    g_signal_connect_after(
      G_OBJECT(gtk_buffer),
      "delete-range",
      G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_after),
      buffer
    );
    g_signal_connect_after(
      G_OBJECT(gtk_buffer),
      "mark-set",
      G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
      buffer
    );
    g_signal_connect_after(
      G_OBJECT(gtk_buffer),
      "modified-changed",
      G_CALLBACK(inf_text_gtk_buffer_modified_changed_cb),
      buffer
    );
  }
  g_object_notify(G_OBJECT(buffer), "buffer");
}
static void
inf_text_gtk_buffer_init(InfTextGtkBuffer* buffer)
{
  InfTextGtkBufferPrivate* priv;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  priv-&gt;buffer = NULL;
  priv-&gt;user_table = NULL;
  priv-&gt;user_tags = g_hash_table_new_full(
    NULL,
    NULL,
    NULL,
    inf_text_gtk_buffer_user_tags_free
  );
  priv-&gt;show_user_colors = TRUE;
  priv-&gt;active_user = NULL;
  priv-&gt;wake_on_cursor_movement = FALSE;
  priv-&gt;saturation = 0.35;
  priv-&gt;value = 1.0;
  priv-&gt;alpha = 1.0;
}
static void
inf_text_gtk_buffer_dispose(GObject* object)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  buffer = INF_TEXT_GTK_BUFFER(object);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  g_hash_table_remove_all(priv-&gt;user_tags);
  inf_text_gtk_buffer_set_buffer(buffer, NULL);
  inf_text_gtk_buffer_set_active_user(buffer, NULL);
<a name="1"></a>  g_object_unref(priv-&gt;user_table);
  G_OBJECT_CLASS(inf_text_gtk_buffer_parent_class)-&gt;dispose(object);
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
static void
inf_text_gtk_buffer_finalize(GObject* object)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  buffer = INF_TEXT_GTK_BUFFER(object);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  g_hash_table_unref(priv-&gt;user_tags);
  G_OBJECT_CLASS(inf_text_gtk_buffer_parent_class)-&gt;finalize(object);
}
static void
inf_text_gtk_buffer_set_property(GObject* object,
                                 guint prop_id,
                                 const GValue* value,
                                 GParamSpec* pspec)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  buffer = INF_TEXT_GTK_BUFFER(object);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  switch(prop_id)
  {
  case PROP_BUFFER:</b></font>
    g_assert(priv-&gt;buffer == NULL);     inf_text_gtk_buffer_set_buffer(
      buffer,
      GTK_TEXT_BUFFER(g_value_get_object(value))
    );
    break;
  case PROP_USER_TABLE:
    g_assert(priv-&gt;user_table == NULL);     priv-&gt;user_table = INF_USER_TABLE(g_value_dup_object(value));
    break;
  case PROP_ACTIVE_USER:
    inf_text_gtk_buffer_set_active_user(
      buffer,
      INF_TEXT_USER(g_value_get_object(value))
    );
    break;
  case PROP_WAKE_ON_CURSOR_MOVEMENT:
    priv-&gt;wake_on_cursor_movement = g_value_get_boolean(value);
<a name="0"></a>    break;
  case PROP_SHOW_USER_COLORS:
    priv-&gt;show_user_colors = g_value_get_boolean(value);
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
  case PROP_MODIFIED:
    inf_text_gtk_buffer_set_modified(buffer, g_value_get_boolean(value));
    break;
  case PROP_SATURATION:
    inf_text_gtk_buffer_set_saturation_value(
      buffer,
      g_value_get_double(value),
      priv-&gt;value
    );
    break;
  case PROP_VALUE:
    inf_text_gtk_buffer_set_saturation_value(
      buffer,
      priv-&gt;saturation,
      g_value_get_double(value)
    );
    break;
  case PROP_ALPHA:
    inf_text_gtk_buffer_set_fade(buffer, g_value_get_double(value));
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_text_gtk_buffer_get_property(GObject* object,
                                 guint prop_id,
                                 GValue* value,
                                 GParamSpec* pspec)
{
  InfTextGtkBuffer* buffer;
  InfTextGtkBufferPrivate* priv;
  buffer = INF_TEXT_GTK_BUFFER(object);</b></font>
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  switch(prop_id)
  {
  case PROP_BUFFER:
    g_value_set_object(value, G_OBJECT(priv-&gt;buffer));
    break;
  case PROP_USER_TABLE:
    g_value_set_object(value, G_OBJECT(priv-&gt;user_table));
    break;
  case PROP_ACTIVE_USER:
    g_value_set_object(value, G_OBJECT(priv-&gt;active_user));
    break;
  case PROP_WAKE_ON_CURSOR_MOVEMENT:
    g_value_set_boolean(value, priv-&gt;wake_on_cursor_movement);
    break;
  case PROP_SHOW_USER_COLORS:
    g_value_set_boolean(value, priv-&gt;show_user_colors);
    break;
  case PROP_MODIFIED:
    if(priv-&gt;buffer != NULL)
      g_value_set_boolean(value, gtk_text_buffer_get_modified(priv-&gt;buffer));
    else
      g_value_set_boolean(value, FALSE);
    break;
  case PROP_SATURATION:
    g_value_set_double(value, priv-&gt;saturation);
    break;
  case PROP_VALUE:
    g_value_set_double(value, priv-&gt;value);
    break;
  case PROP_ALPHA:
    g_value_set_double(value, priv-&gt;alpha);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static gboolean
inf_text_gtk_buffer_buffer_get_modified(InfBuffer* buffer)
{
  InfTextGtkBuffer* gtk_buffer;
  InfTextGtkBufferPrivate* priv;
  gtk_buffer = INF_TEXT_GTK_BUFFER(buffer);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(gtk_buffer);
  if(priv-&gt;buffer != NULL)
    return gtk_text_buffer_get_modified(priv-&gt;buffer);
  else
    return FALSE;
}
static void
inf_text_gtk_buffer_buffer_set_modified(InfBuffer* buffer,
                                        gboolean modified)
{
  inf_text_gtk_buffer_set_modified(INF_TEXT_GTK_BUFFER(buffer), modified);
}
static const gchar*
inf_text_gtk_buffer_buffer_get_encoding(InfTextBuffer* buffer)
{
  return "UTF-8";
}
static guint
inf_text_gtk_buffer_get_length(InfTextBuffer* buffer)
{
  InfTextGtkBufferPrivate* priv;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  return gtk_text_buffer_get_char_count(priv-&gt;buffer);
}
static InfTextChunk*
inf_text_gtk_buffer_buffer_get_slice(InfTextBuffer* buffer,
                                     guint pos,
                                     guint len)
{
  InfTextGtkBufferPrivate* priv;
  GtkTextIter begin;
  GtkTextIter iter;
  InfTextChunk* result;
  guint remaining;
  guint size;
  InfTextUser* author;
  gchar* text;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  gtk_text_buffer_get_iter_at_offset(priv-&gt;buffer, &amp;iter, pos);
  result = inf_text_chunk_new("UTF-8");
  remaining = len;
  while(remaining &gt; 0)
  {
    g_assert(gtk_text_iter_is_end(&amp;iter) == FALSE);
    begin = iter;
    inf_text_gtk_buffer_iter_next_author_toggle(&amp;iter, NULL, &amp;author);
    size = gtk_text_iter_get_offset(&amp;iter) - gtk_text_iter_get_offset(&amp;begin);
    if(size &gt; remaining)
    {
      size = remaining;
      iter = begin;
      gtk_text_iter_forward_chars(&amp;iter, size);
    }
    text = gtk_text_buffer_get_slice(priv-&gt;buffer, &amp;begin, &amp;iter, TRUE);
    inf_text_chunk_insert_text(
      result,
      len - remaining,
      text,
      strlen(text),       size,
      (author == NULL) ? 0 : inf_user_get_id(INF_USER(author))
    );
    remaining -= size;
    g_free(text);
  }
  return result;
}
static void
inf_text_gtk_buffer_buffer_insert_text(InfTextBuffer* buffer,
                                       guint pos,
                                       InfTextChunk* chunk,
                                       InfUser* user)
{
  InfTextGtkBufferPrivate* priv;
  InfTextChunkIter chunk_iter;
  InfTextGtkBufferTagRemove tag_remove;
  GtkTextTag* tag;
  GtkTextMark* mark;
  GtkTextIter insert_iter;
  gboolean insert_at_cursor;
  gboolean insert_at_selection_bound;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  tag_remove.buffer = priv-&gt;buffer;
  g_assert(priv-&gt;record == NULL);
  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
    buffer
  );
  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_before),
    buffer
  );
  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_after),
    buffer
  );
  if(inf_text_chunk_iter_init_begin(chunk, &amp;chunk_iter))
  {
    gtk_text_buffer_get_iter_at_offset(
      priv-&gt;buffer,
      &amp;tag_remove.end_iter,
      pos
    );
    do
    {
      tag_remove.ignore_tags = inf_text_gtk_buffer_get_user_tags(
        INF_TEXT_GTK_BUFFER(buffer),
        inf_text_chunk_iter_get_author(&amp;chunk_iter)
      );
      if(tag_remove.ignore_tags)
      {
        tag = inf_text_gtk_buffer_get_user_tag(
          INF_TEXT_GTK_BUFFER(buffer),
          tag_remove.ignore_tags,
          priv-&gt;show_user_colors
        );
      }
      else
      {
        tag = NULL;
      }
      gtk_text_buffer_insert_with_tags(
        tag_remove.buffer,
        &amp;tag_remove.end_iter,
        inf_text_chunk_iter_get_text(&amp;chunk_iter),
        inf_text_chunk_iter_get_bytes(&amp;chunk_iter),
        tag,
        NULL
      );
      tag_remove.begin_iter = tag_remove.end_iter;
      gtk_text_iter_backward_chars(
        &amp;tag_remove.begin_iter,
        inf_text_chunk_iter_get_length(&amp;chunk_iter)
      );
      gtk_text_tag_table_foreach(
        gtk_text_buffer_get_tag_table(tag_remove.buffer),
        inf_text_gtk_buffer_buffer_insert_text_tag_table_foreach_func,
        &amp;tag_remove
      );
    } while(inf_text_chunk_iter_next(&amp;chunk_iter));
    if(user != INF_USER(priv-&gt;active_user) || user == NULL)
    {
      mark = gtk_text_buffer_get_insert(priv-&gt;buffer);
      gtk_text_buffer_get_iter_at_mark(priv-&gt;buffer, &amp;insert_iter, mark);
      if(gtk_text_iter_equal(&amp;insert_iter, &amp;tag_remove.end_iter))
        insert_at_cursor = TRUE;
      else
        insert_at_cursor = FALSE;
      mark = gtk_text_buffer_get_selection_bound(priv-&gt;buffer);
      gtk_text_buffer_get_iter_at_mark(priv-&gt;buffer, &amp;insert_iter, mark);
      if(gtk_text_iter_equal(&amp;insert_iter, &amp;tag_remove.end_iter))
        insert_at_selection_bound = TRUE;
      else
        insert_at_selection_bound = FALSE;
      if(insert_at_cursor || insert_at_selection_bound)
      {
        inf_signal_handlers_block_by_func(
          G_OBJECT(priv-&gt;buffer),
          G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
          buffer
        );
        gtk_text_iter_backward_chars(
          &amp;tag_remove.end_iter,
          inf_text_chunk_get_length(chunk)
        );
        if(insert_at_cursor)
        {
          gtk_text_buffer_move_mark(
            priv-&gt;buffer,
            gtk_text_buffer_get_insert(priv-&gt;buffer),
            &amp;tag_remove.end_iter
          );
        }
        if(insert_at_selection_bound)
        {
          gtk_text_buffer_move_mark(
            priv-&gt;buffer,
            gtk_text_buffer_get_selection_bound(priv-&gt;buffer),
            &amp;tag_remove.end_iter
          );
        }
        inf_signal_handlers_unblock_by_func(
          G_OBJECT(priv-&gt;buffer),
          G_CALLBACK(inf_text_gtk_buffer_mark_set_cb),
          buffer
        );
      }
    }
  }
  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
    buffer
  );
  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_before),
    buffer
  );
  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_insert_text_cb_after),
    buffer
  );
  inf_text_buffer_text_inserted(buffer, pos, chunk, user);
}
static void
inf_text_gtk_buffer_buffer_erase_text(InfTextBuffer* buffer,
                                      guint pos,
                                      guint len,
                                      InfUser* user)
{
  InfTextGtkBufferPrivate* priv;
  InfTextChunk* chunk;
  GtkTextIter begin;
  GtkTextIter end;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  g_assert(priv-&gt;record == NULL);
  chunk = inf_text_buffer_get_slice(buffer, pos, len);
  gtk_text_buffer_get_iter_at_offset(priv-&gt;buffer, &amp;begin, pos);
  gtk_text_buffer_get_iter_at_offset(priv-&gt;buffer, &amp;end, pos + len);
  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_before),
    buffer
  );
  inf_signal_handlers_block_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_after),
    buffer
  );
  gtk_text_buffer_delete(priv-&gt;buffer, &amp;begin, &amp;end);
  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_before),
    buffer
  );
  inf_signal_handlers_unblock_by_func(
    G_OBJECT(priv-&gt;buffer),
    G_CALLBACK(inf_text_gtk_buffer_delete_range_cb_after),
    buffer
  );
  inf_text_buffer_text_erased(buffer, pos, chunk, user);
  inf_text_chunk_free(chunk);
}
static InfTextBufferIter*
inf_text_gtk_buffer_buffer_create_begin_iter(InfTextBuffer* buffer)
{
  InfTextGtkBufferPrivate* priv;
  InfTextBufferIter* iter;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  if(gtk_text_buffer_get_char_count(priv-&gt;buffer) == 0)
  {
    return NULL;
  }
  else
  {
    iter = g_slice_new(InfTextBufferIter);
    gtk_text_buffer_get_start_iter(priv-&gt;buffer, &amp;iter-&gt;begin);
    iter-&gt;end = iter-&gt;begin;
    inf_text_gtk_buffer_iter_next_author_toggle(
      &amp;iter-&gt;end,
      NULL,
      &amp;iter-&gt;user
    );
    return iter;
  }
}
static InfTextBufferIter*
inf_text_gtk_buffer_buffer_create_end_iter(InfTextBuffer* buffer)
{
  InfTextGtkBufferPrivate* priv;
  InfTextBufferIter* iter;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  if(gtk_text_buffer_get_char_count(priv-&gt;buffer) == 0)
  {
    return NULL;
  }
  else
  {
    iter = g_slice_new(InfTextBufferIter);
    gtk_text_buffer_get_end_iter(priv-&gt;buffer, &amp;iter-&gt;end);
    iter-&gt;begin = iter-&gt;end;
    inf_text_gtk_buffer_iter_prev_author_toggle(
      &amp;iter-&gt;begin,
      &amp;iter-&gt;user,
      NULL
    );
    return iter;
  }
}
static void
inf_text_gtk_buffer_buffer_destroy_iter(InfTextBuffer* buffer,
                                        InfTextBufferIter* iter)
{
  g_slice_free(InfTextBufferIter, iter);
}
static gboolean
inf_text_gtk_buffer_buffer_iter_next(InfTextBuffer* buffer,
                                     InfTextBufferIter* iter)
{
  if(gtk_text_iter_is_end(&amp;iter-&gt;end))
    return FALSE;
  iter-&gt;begin = iter-&gt;end;
  inf_text_gtk_buffer_iter_next_author_toggle(&amp;iter-&gt;end, NULL, &amp;iter-&gt;user);
  return TRUE;
}
static gboolean
inf_text_gtk_buffer_buffer_iter_prev(InfTextBuffer* buffer,
                                     InfTextBufferIter* iter)
{
  if(gtk_text_iter_is_start(&amp;iter-&gt;begin))
    return FALSE;
  iter-&gt;end = iter-&gt;begin;
  inf_text_gtk_buffer_iter_prev_author_toggle(
    &amp;iter-&gt;begin,
    &amp;iter-&gt;user,
    NULL
  );
  return TRUE;
}
static gpointer
inf_text_gtk_buffer_buffer_iter_get_text(InfTextBuffer* buffer,
                                         InfTextBufferIter* iter)
{
  InfTextGtkBufferPrivate* priv;
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  return gtk_text_buffer_get_slice(
    priv-&gt;buffer,
    &amp;iter-&gt;begin,
    &amp;iter-&gt;end,
    TRUE
  );
}
static guint
inf_text_gtk_buffer_buffer_iter_get_offset(InfTextBuffer* buffer,
                                           InfTextBufferIter* iter)
{
  return gtk_text_iter_get_offset(&amp;iter-&gt;begin);
}
static guint
inf_text_gtk_buffer_buffer_iter_get_length(InfTextBuffer* buffer,
                                           InfTextBufferIter* iter)
{
  return gtk_text_iter_get_offset(&amp;iter-&gt;end) -
    gtk_text_iter_get_offset(&amp;iter-&gt;begin);
}
static gsize
inf_text_gtk_buffer_buffer_iter_get_bytes(InfTextBuffer* buffer,
                                          InfTextBufferIter* iter)
{
  GtkTextIter walk;
  gsize bytes;
  guint remaining;
  guint end;
  guint line_chars;
  guint line_bytes;
  gboolean result;
  walk = iter-&gt;begin;
  bytes = 0;
  remaining = gtk_text_iter_get_offset(&amp;iter-&gt;end) -
    gtk_text_iter_get_offset(&amp;walk);
  end = gtk_text_iter_get_offset(&amp;iter-&gt;end);
  while(remaining &gt; 0)
  {
    line_chars = gtk_text_iter_get_chars_in_line(&amp;walk) -
      gtk_text_iter_get_line_offset(&amp;walk);
    if(line_chars + gtk_text_iter_get_offset(&amp;walk) &lt;= end)
    {
      line_bytes = gtk_text_iter_get_bytes_in_line(&amp;walk) -
        gtk_text_iter_get_line_index(&amp;walk);
      remaining -= line_chars;
      bytes += line_bytes;
      result = gtk_text_iter_forward_line(&amp;walk);
      g_assert(remaining == 0 || result == TRUE);
    }
    else
    {
      line_bytes = gtk_text_iter_get_line_index(&amp;iter-&gt;end) -
        gtk_text_iter_get_line_index(&amp;walk);
      remaining = 0;
      bytes += line_bytes;
    }
  }
  return bytes;
}
static guint
inf_text_gtk_buffer_buffer_iter_get_author(InfTextBuffer* buffer,
                                           InfTextBufferIter* iter)
{
  return (iter-&gt;user == NULL) ? 0 : inf_user_get_id(INF_USER(iter-&gt;user));
}
static void
inf_text_gtk_buffer_class_init(InfTextGtkBufferClass* text_gtk_buffer_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(text_gtk_buffer_class);
  object_class-&gt;dispose = inf_text_gtk_buffer_dispose;
  object_class-&gt;finalize = inf_text_gtk_buffer_finalize;
  object_class-&gt;set_property = inf_text_gtk_buffer_set_property;
  object_class-&gt;get_property = inf_text_gtk_buffer_get_property;
  inf_text_gtk_buffer_tag_user_quark = g_quark_from_static_string(
    "inf-text-gtk-buffer-tag-user"
  );
  g_object_class_install_property(
    object_class,
    PROP_BUFFER,
    g_param_spec_object(
      "buffer",
      "Buffer",
      "The underlaying GtkTextBuffer",
      GTK_TYPE_TEXT_BUFFER,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_USER_TABLE,
    g_param_spec_object(
      "user-table",
      "User table",
      "A user table of the participating users",
      INF_TYPE_USER_TABLE,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_ACTIVE_USER,
    g_param_spec_object(
      "active-user",
      "Active user",
      "The user currently inserting text locally",
      INF_TEXT_TYPE_USER,
      G_PARAM_READWRITE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_WAKE_ON_CURSOR_MOVEMENT,
    g_param_spec_boolean(
      "wake-on-cursor-movement",
      "Wake on cursor movement",
      "Whether to make inactive users active when the insertion mark in the "
      "TextBuffer moves",
      FALSE,
      G_PARAM_READWRITE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SHOW_USER_COLORS,
    g_param_spec_boolean(
      "show-user-colors",
      "Show user colors",
      "Whether to show user colors initially for newly written text",
      TRUE,
      G_PARAM_READWRITE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SATURATION,
    g_param_spec_double(
      "saturation",
      "Saturation",
      "Saturation of user colors in a HSV color model",
      0.0,
      1.0,
      0.35,
      G_PARAM_READWRITE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_VALUE,
    g_param_spec_double(
      "value",
      "Value",
      "Value of user colors in a HSV color model",
      0.0,
      1.0,
      1.0,
      G_PARAM_READWRITE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_VALUE,
    g_param_spec_double(
      "alpha",
      "Alpha",
      "The translucency of the user color",
      0.0,
      1.0,
      1.0,
      G_PARAM_READWRITE
    )
  );
  g_object_class_override_property(object_class, PROP_MODIFIED, "modified");
}
static void
inf_text_gtk_buffer_buffer_iface_init(InfBufferInterface* iface)
{
  iface-&gt;get_modified = inf_text_gtk_buffer_buffer_get_modified;
  iface-&gt;set_modified = inf_text_gtk_buffer_buffer_set_modified;
}
static void
inf_text_gtk_buffer_text_buffer_iface_init(InfTextBufferInterface* iface)
{
  iface-&gt;get_encoding = inf_text_gtk_buffer_buffer_get_encoding;
  iface-&gt;get_length = inf_text_gtk_buffer_get_length;
  iface-&gt;get_slice = inf_text_gtk_buffer_buffer_get_slice;
  iface-&gt;insert_text = inf_text_gtk_buffer_buffer_insert_text;
  iface-&gt;erase_text = inf_text_gtk_buffer_buffer_erase_text;
  iface-&gt;create_begin_iter = inf_text_gtk_buffer_buffer_create_begin_iter;
  iface-&gt;create_end_iter = inf_text_gtk_buffer_buffer_create_end_iter;
  iface-&gt;destroy_iter = inf_text_gtk_buffer_buffer_destroy_iter;
  iface-&gt;iter_next = inf_text_gtk_buffer_buffer_iter_next;
  iface-&gt;iter_prev = inf_text_gtk_buffer_buffer_iter_prev;
  iface-&gt;iter_get_text = inf_text_gtk_buffer_buffer_iter_get_text;
  iface-&gt;iter_get_offset = inf_text_gtk_buffer_buffer_iter_get_offset;
  iface-&gt;iter_get_length = inf_text_gtk_buffer_buffer_iter_get_length;
  iface-&gt;iter_get_bytes = inf_text_gtk_buffer_buffer_iter_get_bytes;
  iface-&gt;iter_get_author = inf_text_gtk_buffer_buffer_iter_get_author;
  iface-&gt;text_inserted = NULL;
  iface-&gt;text_erased = NULL;
}
InfTextGtkBuffer*
inf_text_gtk_buffer_new(GtkTextBuffer* buffer,
                        InfUserTable* user_table)
{
  GObject* object;
  g_return_val_if_fail(GTK_IS_TEXT_BUFFER(buffer), NULL);
  g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);
  object = g_object_new(
    INF_TEXT_GTK_TYPE_BUFFER,
    "buffer", buffer,
    "user-table", user_table,
    NULL
  );
  return INF_TEXT_GTK_BUFFER(object);
}
GtkTextBuffer*
inf_text_gtk_buffer_get_text_buffer(InfTextGtkBuffer* buffer)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), NULL);
  return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;buffer;
}
void
inf_text_gtk_buffer_set_active_user(InfTextGtkBuffer* buffer,
                                    InfTextUser* user)
{
  InfTextGtkBufferPrivate* priv;
  g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
  g_return_if_fail(user == NULL || INF_TEXT_IS_USER(user));
  g_return_if_fail(
    user == NULL ||
    (inf_user_get_flags(INF_USER(user)) &amp; INF_USER_LOCAL) != 0
  );
  g_return_if_fail(
    user == NULL ||
    inf_user_get_status(INF_USER(user)) != INF_USER_UNAVAILABLE
  );
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  if(priv-&gt;active_user != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;active_user),
      G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
      buffer
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;active_user),
      G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
      buffer
    );
    g_object_unref(G_OBJECT(priv-&gt;active_user));
  }
  priv-&gt;active_user = user;
  if(user != NULL)
  {
    g_object_ref(G_OBJECT(user));
    g_signal_connect(
      G_OBJECT(user),
      "notify::status",
      G_CALLBACK(inf_text_gtk_buffer_active_user_notify_status_cb),
      buffer
    );
    g_signal_connect(
      G_OBJECT(user),
      "selection-changed",
      G_CALLBACK(inf_text_gtk_buffer_active_user_selection_changed_cb),
      buffer
    );
  }
  g_object_notify(G_OBJECT(buffer), "active-user");
}
InfTextUser*
inf_text_gtk_buffer_get_active_user(InfTextGtkBuffer* buffer)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), NULL);
  return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;active_user;
}
InfTextUser*
inf_text_gtk_buffer_get_author(InfTextGtkBuffer* buffer,
                               GtkTextIter* location)
{
  InfTextGtkBufferPrivate* priv;
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), NULL);
  g_return_val_if_fail(
    location != NULL &amp;&amp; !gtk_text_iter_is_end(location),
    NULL
  );
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  return inf_text_gtk_buffer_iter_get_author(location);
}
InfTextUser*
inf_text_gtk_buffer_get_user_for_tag(InfTextGtkBuffer* buffer,
                                     GtkTextTag* tag)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), NULL);
  g_return_val_if_fail(GTK_IS_TEXT_TAG(tag), NULL);
  return inf_text_gtk_buffer_author_from_tag(tag);
}
gboolean
inf_text_gtk_buffer_is_author_toggle(InfTextGtkBuffer* buffer,
                                     const GtkTextIter* iter,
                                     InfTextUser** user_on,
                                     InfTextUser** user_off)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
  g_return_val_if_fail(iter != NULL, FALSE);
  return inf_text_gtk_buffer_iter_is_author_toggle(
    iter,
    user_on,
    user_off
  );
}
gboolean
inf_text_gtk_buffer_forward_to_author_toggle(InfTextGtkBuffer* buffer,
                                             GtkTextIter* iter,
                                             InfTextUser** user_on,
                                             InfTextUser** user_off)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
  g_return_val_if_fail(iter != NULL, FALSE);
  if(gtk_text_iter_is_end(iter))
    return FALSE;
  inf_text_gtk_buffer_iter_next_author_toggle(iter, user_on, user_off);
  return TRUE;
}
gboolean
inf_text_gtk_buffer_backward_to_author_toggle(InfTextGtkBuffer* buffer,
                                              GtkTextIter* iter,
                                              InfTextUser** user_on,
                                              InfTextUser** user_off)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
  g_return_val_if_fail(iter != NULL, FALSE);
  if(gtk_text_iter_is_start(iter))
    return FALSE;
  inf_text_gtk_buffer_iter_prev_author_toggle(iter, user_on, user_off);
  return TRUE;
}
void
inf_text_gtk_buffer_set_wake_on_cursor_movement(InfTextGtkBuffer* buffer,
                                                gboolean wake)
{
  g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
  INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;wake_on_cursor_movement = wake;
  g_object_notify(G_OBJECT(buffer), "wake-on-cursor-movement");
}
gboolean
inf_text_gtk_buffer_get_wake_on_cursor_movement(InfTextGtkBuffer* buffer)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
  return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;wake_on_cursor_movement;
}
void
inf_text_gtk_buffer_ensure_author_tags_priority(InfTextGtkBuffer* buffer)
{
  InfTextGtkBufferPrivate* priv;
  GtkTextTagTable* tag_table;
  g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  tag_table = gtk_text_buffer_get_tag_table(priv-&gt;buffer);
  gtk_text_tag_table_foreach(
    tag_table,
    inf_text_gtk_buffer_ensure_author_tags_priority_foreach_func,
    buffer
  );
}
void
inf_text_gtk_buffer_set_saturation_value(InfTextGtkBuffer* buffer,
                                         gdouble saturation,
                                         gdouble value)
{
  InfTextGtkBufferPrivate* priv;
  GtkTextTagTable* tag_table;
  g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
  g_return_if_fail(saturation &gt;= 0.0 &amp;&amp; saturation &lt;= 1.0);
  g_return_if_fail(value &gt;= 0.0 &amp;&amp; value &lt;= 1.0);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  if(saturation == priv-&gt;saturation &amp;&amp; value == priv-&gt;value)
    return;
  g_object_freeze_notify(G_OBJECT(buffer));
  if(saturation != priv-&gt;saturation)
  {
    priv-&gt;saturation = saturation;
    g_object_notify(G_OBJECT(buffer), "saturation");
  }
  if(value != priv-&gt;value)
  {
    priv-&gt;value = value;
    g_object_notify(G_OBJECT(buffer), "value");
  }
  tag_table = gtk_text_buffer_get_tag_table(priv-&gt;buffer);
  gtk_text_tag_table_foreach(
    tag_table,
    inf_text_gtk_buffer_update_user_color_tag_table_foreach_func,
    buffer
  );
  g_object_thaw_notify(G_OBJECT(buffer));
}
void
inf_text_gtk_buffer_set_fade(InfTextGtkBuffer* buffer,
                             gdouble alpha)
{
  InfTextGtkBufferPrivate* priv;
  GtkTextTagTable* tag_table;
  g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
  g_return_if_fail(alpha &gt;= 0.0 &amp;&amp; alpha &lt;= 1.0);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  g_object_freeze_notify(G_OBJECT(buffer));
  if(alpha != priv-&gt;alpha)
  {
    priv-&gt;alpha = alpha;
    g_object_notify(G_OBJECT(buffer), "alpha");
  }
  tag_table = gtk_text_buffer_get_tag_table(priv-&gt;buffer);
  gtk_text_tag_table_foreach(
    tag_table,
    inf_text_gtk_buffer_update_user_color_tag_table_foreach_func,
    buffer
  );
  g_object_thaw_notify(G_OBJECT(buffer));
}
gdouble
inf_text_gtk_buffer_get_saturation(InfTextGtkBuffer* buffer)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), 0.0);
  return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;saturation;
}
gdouble
inf_text_gtk_buffer_get_value(InfTextGtkBuffer* buffer)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), 0.0);
  return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;value;
}
void
inf_text_gtk_buffer_set_show_user_colors(InfTextGtkBuffer* buffer,
                                         gboolean show)
{
  g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
  INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;show_user_colors = show;
  g_object_notify(G_OBJECT(buffer), "show-user-colors");
}
gboolean
inf_text_gtk_buffer_get_show_user_colors(InfTextGtkBuffer* buffer)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer), FALSE);
  return INF_TEXT_GTK_BUFFER_PRIVATE(buffer)-&gt;show_user_colors;
}
void
inf_text_gtk_buffer_show_user_colors(InfTextGtkBuffer* buffer,
                                     gboolean show,
                                     GtkTextIter* start,
                                     GtkTextIter* end)
{
  InfTextGtkBufferPrivate* priv;
  GtkTextIter iter;
  GtkTextIter prev;
  InfTextUser* user;
  InfTextGtkBufferUserTags* tags;
  GtkTextTag* hide_tag;
  GtkTextTag* show_tag;
  g_return_if_fail(INF_TEXT_GTK_IS_BUFFER(buffer));
  g_return_if_fail(start != NULL);
  g_return_if_fail(end != NULL);
  priv = INF_TEXT_GTK_BUFFER_PRIVATE(buffer);
  iter = *start;
  prev = iter;
  while(!gtk_text_iter_equal(&amp;iter, end))
  {
    inf_text_gtk_buffer_iter_next_author_toggle(&amp;iter, NULL, &amp;user);
    if(gtk_text_iter_compare(&amp;iter, end) &gt; 0)
      iter = *end;
    if(user != NULL)
    {
      tags = g_hash_table_lookup(
        priv-&gt;user_tags,
        GUINT_TO_POINTER(inf_user_get_id(INF_USER(user)))
      );
      g_assert(tags != NULL);
      if(show)
      {
        hide_tag = inf_text_gtk_buffer_get_user_tag(buffer, tags, FALSE);
        show_tag = inf_text_gtk_buffer_get_user_tag(buffer, tags, TRUE);
      }
      else
      {
        hide_tag = inf_text_gtk_buffer_get_user_tag(buffer, tags, TRUE);
        show_tag = inf_text_gtk_buffer_get_user_tag(buffer, tags, FALSE);
      }
      inf_signal_handlers_block_by_func(
        priv-&gt;buffer,
        G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
        buffer
      );
      gtk_text_buffer_remove_tag(priv-&gt;buffer, hide_tag, &amp;prev, &amp;iter);
      gtk_text_buffer_apply_tag(priv-&gt;buffer, show_tag, &amp;prev, &amp;iter);
      inf_signal_handlers_unblock_by_func(
        priv-&gt;buffer,
        G_CALLBACK(inf_text_gtk_buffer_apply_tag_cb),
        buffer
      );
    }
    prev = iter;
  }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
