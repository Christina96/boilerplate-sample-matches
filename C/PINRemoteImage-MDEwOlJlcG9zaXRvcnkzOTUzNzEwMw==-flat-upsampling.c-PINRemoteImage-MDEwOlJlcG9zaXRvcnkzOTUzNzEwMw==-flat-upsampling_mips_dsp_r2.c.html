
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 334, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-upsampling.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #include "src/dsp/yuv.h"
3  #include <assert.h>
4  #ifdef FANCY_UPSAMPLING
5  WebPUpsampleLinePairFunc WebPUpsamplers[MODE_LAST];
6  #define LOAD_UV(u, v) ((u) | ((v) << 16))
7  #define UPSAMPLE_FUNC(FUNC_NAME, FUNC, XSTEP)                                  \
8  static void FUNC_NAME(const uint8_t* top_y, const uint8_t* bottom_y,           \
9                        const uint8_t* top_u, const uint8_t* top_v,              \
10                        const uint8_t* cur_u, const uint8_t* cur_v,              \
11                        uint8_t* top_dst, uint8_t* bottom_dst, int len) {        \
12    int x;                                                                       \
<span onclick='openModal()' class='match'>13    const int last_pixel_pair = (len - 1) >> 1;                                  \
14    uint32_t tl_uv = LOAD_UV(top_u[0], top_v[0]);   &bsol;* top-left sample */        \
15    uint32_t l_uv  = LOAD_UV(cur_u[0], cur_v[0]);   &bsol;* left-sample */            \
16    assert(top_y != NULL);                                                       \
17    {                                                                            \
18      const uint32_t uv0 = (3 * tl_uv + l_uv + 0x00020002u) >> 2;                \
19      FUNC(top_y[0], uv0 & 0xff, (uv0 >> 16), top_dst);                          \
20    }                                                                            \
21    if (bottom_y != NULL) {                                                      \
22      const uint32_t uv0 = (3 * l_uv + tl_uv + 0x00020002u) >> 2;                \
23      FUNC(bottom_y[0], uv0 & 0xff, (uv0 >> 16), bottom_dst);                    \
24    }                                                                            \
25    for (x = 1; x <= last_pixel_pair; ++x) {                                     \
26      const uint32_t t_uv = LOAD_UV(top_u[x], top_v[x]);  &bsol;* top sample */       \
27      const uint32_t uv   = LOAD_UV(cur_u[x], cur_v[x]);  &bsol;* sample */           \
28      \
29      const uint32_t avg = tl_uv + t_uv + l_uv + uv + 0x00080008u;               \
30      const uint32_t diag_12 = (avg + 2 * (t_uv + l_uv)) >> 3;                   \
31      const uint32_t diag_03 = (avg + 2 * (tl_uv + uv)) >> 3;                    \
32      {                                                                          \
33        const uint32_t uv0 = (diag_12 + tl_uv) >> 1;                             \
34        const uint32_t uv1 = (diag_03 + t_uv) >> 1;                              \
35        FUNC(top_y[2 * x - 1], uv0 & 0xff, (uv0 >> 16),                          \
36             top_dst + (2 * x - 1) * (XSTEP));                                   \
</span>37        FUNC(top_y[2 * x - 0], uv1 & 0xff, (uv1 >> 16),                          \
38             top_dst + (2 * x - 0) * (XSTEP));                                   \
39      }                                                                          \
40      if (bottom_y != NULL) {                                                    \
41        const uint32_t uv0 = (diag_03 + l_uv) >> 1;                              \
42        const uint32_t uv1 = (diag_12 + uv) >> 1;                                \
43        FUNC(bottom_y[2 * x - 1], uv0 & 0xff, (uv0 >> 16),                       \
44             bottom_dst + (2 * x - 1) * (XSTEP));                                \
45        FUNC(bottom_y[2 * x + 0], uv1 & 0xff, (uv1 >> 16),                       \
46             bottom_dst + (2 * x + 0) * (XSTEP));                                \
47      }                                                                          \
48      tl_uv = t_uv;                                                              \
49      l_uv = uv;                                                                 \
50    }                                                                            \
51    if (!(len & 1)) {                                                            \
52      {                                                                          \
53        const uint32_t uv0 = (3 * tl_uv + l_uv + 0x00020002u) >> 2;              \
54        FUNC(top_y[len - 1], uv0 & 0xff, (uv0 >> 16),                            \
55             top_dst + (len - 1) * (XSTEP));                                     \
56      }                                                                          \
57      if (bottom_y != NULL) {                                                    \
58        const uint32_t uv0 = (3 * l_uv + tl_uv + 0x00020002u) >> 2;              \
59        FUNC(bottom_y[len - 1], uv0 & 0xff, (uv0 >> 16),                         \
60             bottom_dst + (len - 1) * (XSTEP));                                  \
61      }                                                                          \
62    }                                                                            \
63  }
64  #if !WEBP_NEON_OMIT_C_CODE
65  UPSAMPLE_FUNC(UpsampleRgbaLinePair_C, VP8YuvToRgba, 4)
66  UPSAMPLE_FUNC(UpsampleBgraLinePair_C, VP8YuvToBgra, 4)
67  #if !defined(WEBP_REDUCE_CSP)
68  UPSAMPLE_FUNC(UpsampleArgbLinePair_C, VP8YuvToArgb, 4)
69  UPSAMPLE_FUNC(UpsampleRgbLinePair_C,  VP8YuvToRgb,  3)
70  UPSAMPLE_FUNC(UpsampleBgrLinePair_C,  VP8YuvToBgr,  3)
71  UPSAMPLE_FUNC(UpsampleRgba4444LinePair_C, VP8YuvToRgba4444, 2)
72  UPSAMPLE_FUNC(UpsampleRgb565LinePair_C,  VP8YuvToRgb565,  2)
73  #else
74  static void EmptyUpsampleFunc(const uint8_t* top_y, const uint8_t* bottom_y,
75                                const uint8_t* top_u, const uint8_t* top_v,
76                                const uint8_t* cur_u, const uint8_t* cur_v,
77                                uint8_t* top_dst, uint8_t* bottom_dst, int len) {
78    (void)top_y;
79    (void)bottom_y;
80    (void)top_u;
81    (void)top_v;
82    (void)cur_u;
83    (void)cur_v;
84    (void)top_dst;
85    (void)bottom_dst;
86    (void)len;
87    assert(0);   
88  }
89  #define UpsampleArgbLinePair_C EmptyUpsampleFunc
90  #define UpsampleRgbLinePair_C EmptyUpsampleFunc
91  #define UpsampleBgrLinePair_C EmptyUpsampleFunc
92  #define UpsampleRgba4444LinePair_C EmptyUpsampleFunc
93  #define UpsampleRgb565LinePair_C EmptyUpsampleFunc
94  #endif   
95  #endif
96  #undef LOAD_UV
97  #undef UPSAMPLE_FUNC
98  #endif  
99  #if !defined(FANCY_UPSAMPLING)
100  #define DUAL_SAMPLE_FUNC(FUNC_NAME, FUNC)                                      \
101  static void FUNC_NAME(const uint8_t* top_y, const uint8_t* bot_y,              \
102                        const uint8_t* top_u, const uint8_t* top_v,              \
103                        const uint8_t* bot_u, const uint8_t* bot_v,              \
104                        uint8_t* top_dst, uint8_t* bot_dst, int len) {           \
105    const int half_len = len >> 1;                                               \
106    int x;                                                                       \
107    assert(top_dst != NULL);                                                     \
108    {                                                                            \
109      for (x = 0; x < half_len; ++x) {                                           \
110        FUNC(top_y[2 * x + 0], top_u[x], top_v[x], top_dst + 8 * x + 0);         \
111        FUNC(top_y[2 * x + 1], top_u[x], top_v[x], top_dst + 8 * x + 4);         \
112      }                                                                          \
113      if (len & 1) FUNC(top_y[2 * x + 0], top_u[x], top_v[x], top_dst + 8 * x);  \
114    }                                                                            \
115    if (bot_dst != NULL) {                                                       \
116      for (x = 0; x < half_len; ++x) {                                           \
117        FUNC(bot_y[2 * x + 0], bot_u[x], bot_v[x], bot_dst + 8 * x + 0);         \
118        FUNC(bot_y[2 * x + 1], bot_u[x], bot_v[x], bot_dst + 8 * x + 4);         \
119      }                                                                          \
120      if (len & 1) FUNC(bot_y[2 * x + 0], bot_u[x], bot_v[x], bot_dst + 8 * x);  \
121    }                                                                            \
122  }
123  DUAL_SAMPLE_FUNC(DualLineSamplerBGRA, VP8YuvToBgra)
124  DUAL_SAMPLE_FUNC(DualLineSamplerARGB, VP8YuvToArgb)
125  #undef DUAL_SAMPLE_FUNC
126  #endif  
127  WebPUpsampleLinePairFunc WebPGetLinePairConverter(int alpha_is_last) {
128    WebPInitUpsamplers();
129  #ifdef FANCY_UPSAMPLING
130    return WebPUpsamplers[alpha_is_last ? MODE_BGRA : MODE_ARGB];
131  #else
132    return (alpha_is_last ? DualLineSamplerBGRA : DualLineSamplerARGB);
133  #endif
134  }
135  #define YUV444_FUNC(FUNC_NAME, FUNC, XSTEP)                                    \
136  extern void FUNC_NAME(const uint8_t* y, const uint8_t* u, const uint8_t* v,    \
137                        uint8_t* dst, int len);                                  \
138  void FUNC_NAME(const uint8_t* y, const uint8_t* u, const uint8_t* v,           \
139                 uint8_t* dst, int len) {                                        \
140    int i;                                                                       \
141    for (i = 0; i < len; ++i) FUNC(y[i], u[i], v[i], &dst[i * (XSTEP)]);         \
142  }
143  YUV444_FUNC(WebPYuv444ToRgba_C,     VP8YuvToRgba, 4)
144  YUV444_FUNC(WebPYuv444ToBgra_C,     VP8YuvToBgra, 4)
145  #if !defined(WEBP_REDUCE_CSP)
146  YUV444_FUNC(WebPYuv444ToRgb_C,      VP8YuvToRgb,  3)
147  YUV444_FUNC(WebPYuv444ToBgr_C,      VP8YuvToBgr,  3)
148  YUV444_FUNC(WebPYuv444ToArgb_C,     VP8YuvToArgb, 4)
149  YUV444_FUNC(WebPYuv444ToRgba4444_C, VP8YuvToRgba4444, 2)
150  YUV444_FUNC(WebPYuv444ToRgb565_C,   VP8YuvToRgb565, 2)
151  #else
152  static void EmptyYuv444Func(const uint8_t* y,
153                              const uint8_t* u, const uint8_t* v,
154                              uint8_t* dst, int len) {
155    (void)y;
156    (void)u;
157    (void)v;
158    (void)dst;
159    (void)len;
160  }
161  #define WebPYuv444ToRgb_C EmptyYuv444Func
162  #define WebPYuv444ToBgr_C EmptyYuv444Func
163  #define WebPYuv444ToArgb_C EmptyYuv444Func
164  #define WebPYuv444ToRgba4444_C EmptyYuv444Func
165  #define WebPYuv444ToRgb565_C EmptyYuv444Func
166  #endif   
167  #undef YUV444_FUNC
168  WebPYUV444Converter WebPYUV444Converters[MODE_LAST];
169  extern void WebPInitYUV444ConvertersMIPSdspR2(void);
170  extern void WebPInitYUV444ConvertersSSE2(void);
171  extern void WebPInitYUV444ConvertersSSE41(void);
172  WEBP_DSP_INIT_FUNC(WebPInitYUV444Converters) {
173    WebPYUV444Converters[MODE_RGBA]      = WebPYuv444ToRgba_C;
174    WebPYUV444Converters[MODE_BGRA]      = WebPYuv444ToBgra_C;
175    WebPYUV444Converters[MODE_RGB]       = WebPYuv444ToRgb_C;
176    WebPYUV444Converters[MODE_BGR]       = WebPYuv444ToBgr_C;
177    WebPYUV444Converters[MODE_ARGB]      = WebPYuv444ToArgb_C;
178    WebPYUV444Converters[MODE_RGBA_4444] = WebPYuv444ToRgba4444_C;
179    WebPYUV444Converters[MODE_RGB_565]   = WebPYuv444ToRgb565_C;
180    WebPYUV444Converters[MODE_rgbA]      = WebPYuv444ToRgba_C;
181    WebPYUV444Converters[MODE_bgrA]      = WebPYuv444ToBgra_C;
182    WebPYUV444Converters[MODE_Argb]      = WebPYuv444ToArgb_C;
183    WebPYUV444Converters[MODE_rgbA_4444] = WebPYuv444ToRgba4444_C;
184    if (VP8GetCPUInfo != NULL) {
185  #if defined(WEBP_USE_SSE2)
186      if (VP8GetCPUInfo(kSSE2)) {
187        WebPInitYUV444ConvertersSSE2();
188      }
189  #endif
190  #if defined(WEBP_USE_SSE41)
191      if (VP8GetCPUInfo(kSSE4_1)) {
192        WebPInitYUV444ConvertersSSE41();
193      }
194  #endif
195  #if defined(WEBP_USE_MIPS_DSP_R2)
196      if (VP8GetCPUInfo(kMIPSdspR2)) {
197        WebPInitYUV444ConvertersMIPSdspR2();
198      }
199  #endif
200    }
201  }
202  extern void WebPInitUpsamplersSSE2(void);
203  extern void WebPInitUpsamplersSSE41(void);
204  extern void WebPInitUpsamplersNEON(void);
205  extern void WebPInitUpsamplersMIPSdspR2(void);
206  extern void WebPInitUpsamplersMSA(void);
207  WEBP_DSP_INIT_FUNC(WebPInitUpsamplers) {
208  #ifdef FANCY_UPSAMPLING
209  #if !WEBP_NEON_OMIT_C_CODE
210    WebPUpsamplers[MODE_RGBA]      = UpsampleRgbaLinePair_C;
211    WebPUpsamplers[MODE_BGRA]      = UpsampleBgraLinePair_C;
212    WebPUpsamplers[MODE_rgbA]      = UpsampleRgbaLinePair_C;
213    WebPUpsamplers[MODE_bgrA]      = UpsampleBgraLinePair_C;
214    WebPUpsamplers[MODE_RGB]       = UpsampleRgbLinePair_C;
215    WebPUpsamplers[MODE_BGR]       = UpsampleBgrLinePair_C;
216    WebPUpsamplers[MODE_ARGB]      = UpsampleArgbLinePair_C;
217    WebPUpsamplers[MODE_RGBA_4444] = UpsampleRgba4444LinePair_C;
218    WebPUpsamplers[MODE_RGB_565]   = UpsampleRgb565LinePair_C;
219    WebPUpsamplers[MODE_Argb]      = UpsampleArgbLinePair_C;
220    WebPUpsamplers[MODE_rgbA_4444] = UpsampleRgba4444LinePair_C;
221  #endif
222    if (VP8GetCPUInfo != NULL) {
223  #if defined(WEBP_USE_SSE2)
224      if (VP8GetCPUInfo(kSSE2)) {
225        WebPInitUpsamplersSSE2();
226      }
227  #endif
228  #if defined(WEBP_USE_SSE41)
229      if (VP8GetCPUInfo(kSSE4_1)) {
230        WebPInitUpsamplersSSE41();
231      }
232  #endif
233  #if defined(WEBP_USE_MIPS_DSP_R2)
234      if (VP8GetCPUInfo(kMIPSdspR2)) {
235        WebPInitUpsamplersMIPSdspR2();
236      }
237  #endif
238  #if defined(WEBP_USE_MSA)
239      if (VP8GetCPUInfo(kMSA)) {
240        WebPInitUpsamplersMSA();
241      }
242  #endif
243    }
244  #if defined(WEBP_USE_NEON)
245    if (WEBP_NEON_OMIT_C_CODE ||
246        (VP8GetCPUInfo != NULL && VP8GetCPUInfo(kNEON))) {
247      WebPInitUpsamplersNEON();
248    }
249  #endif
250    assert(WebPUpsamplers[MODE_RGBA] != NULL);
251    assert(WebPUpsamplers[MODE_BGRA] != NULL);
252    assert(WebPUpsamplers[MODE_rgbA] != NULL);
253    assert(WebPUpsamplers[MODE_bgrA] != NULL);
254  #if !defined(WEBP_REDUCE_CSP) || !WEBP_NEON_OMIT_C_CODE
255    assert(WebPUpsamplers[MODE_RGB] != NULL);
256    assert(WebPUpsamplers[MODE_BGR] != NULL);
257    assert(WebPUpsamplers[MODE_ARGB] != NULL);
258    assert(WebPUpsamplers[MODE_RGBA_4444] != NULL);
259    assert(WebPUpsamplers[MODE_RGB_565] != NULL);
260    assert(WebPUpsamplers[MODE_Argb] != NULL);
261    assert(WebPUpsamplers[MODE_rgbA_4444] != NULL);
262  #endif
263  #endif  
264  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-upsampling_mips_dsp_r2.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_MIPS_DSP_R2)
3  #include <assert.h>
4  #include "src/dsp/yuv.h"
5  #define YUV_TO_RGB(Y, U, V, R, G, B) do {                                      \
6      const int t1 = MultHi(Y, 19077);                                           \
7      const int t2 = MultHi(V, 13320);                                           \
8      R = MultHi(V, 26149);                                                      \
9      G = MultHi(U, 6419);                                                       \
10      B = MultHi(U, 33050);                                                      \
11      R = t1 + R;                                                                \
12      G = t1 - G;                                                                \
13      B = t1 + B;                                                                \
14      R = R - 14234;                                                             \
15      G = G - t2 + 8708;                                                         \
16      B = B - 17685;                                                             \
17      __asm__ volatile (                                                         \
18        "shll_s.w         %[" #R "],      %[" #R "],        17         \n\t"     \
19        "shll_s.w         %[" #G "],      %[" #G "],        17         \n\t"     \
20        "shll_s.w         %[" #B "],      %[" #B "],        17         \n\t"     \
21        "precrqu_s.qb.ph  %[" #R "],      %[" #R "],        $zero      \n\t"     \
22        "precrqu_s.qb.ph  %[" #G "],      %[" #G "],        $zero      \n\t"     \
23        "precrqu_s.qb.ph  %[" #B "],      %[" #B "],        $zero      \n\t"     \
24        "srl              %[" #R "],      %[" #R "],        24         \n\t"     \
25        "srl              %[" #G "],      %[" #G "],        24         \n\t"     \
26        "srl              %[" #B "],      %[" #B "],        24         \n\t"     \
27        : [R]"+r"(R), [G]"+r"(G), [B]"+r"(B)                                     \
28        :                                                                        \
29      );                                                                         \
30    } while (0)
31  #if !defined(WEBP_REDUCE_CSP)
32  static WEBP_INLINE void YuvToRgb(int y, int u, int v, uint8_t* const rgb) {
33    int r, g, b;
34    YUV_TO_RGB(y, u, v, r, g, b);
35    rgb[0] = r;
36    rgb[1] = g;
37    rgb[2] = b;
38  }
39  static WEBP_INLINE void YuvToBgr(int y, int u, int v, uint8_t* const bgr) {
40    int r, g, b;
41    YUV_TO_RGB(y, u, v, r, g, b);
42    bgr[0] = b;
43    bgr[1] = g;
44    bgr[2] = r;
45  }
46  static WEBP_INLINE void YuvToRgb565(int y, int u, int v, uint8_t* const rgb) {
47    int r, g, b;
48    YUV_TO_RGB(y, u, v, r, g, b);
49    {
50      const int rg = (r & 0xf8) | (g >> 5);
51      const int gb = ((g << 3) & 0xe0) | (b >> 3);
52  #if (WEBP_SWAP_16BIT_CSP == 1)
53      rgb[0] = gb;
54      rgb[1] = rg;
55  #else
56      rgb[0] = rg;
57      rgb[1] = gb;
58  #endif
59    }
60  }
61  static WEBP_INLINE void YuvToRgba4444(int y, int u, int v,
62                                        uint8_t* const argb) {
63    int r, g, b;
64    YUV_TO_RGB(y, u, v, r, g, b);
65    {
66      const int rg = (r & 0xf0) | (g >> 4);
67      const int ba = (b & 0xf0) | 0x0f;     
68  #if (WEBP_SWAP_16BIT_CSP == 1)
69      argb[0] = ba;
70      argb[1] = rg;
71  #else
72      argb[0] = rg;
73      argb[1] = ba;
74  #endif
75     }
76  }
77  #endif   
78  #if !defined(WEBP_REDUCE_CSP)
79  static WEBP_INLINE void YuvToArgb(uint8_t y, uint8_t u, uint8_t v,
80                                    uint8_t* const argb) {
81    int r, g, b;
82    YUV_TO_RGB(y, u, v, r, g, b);
83    argb[0] = 0xff;
84    argb[1] = r;
85    argb[2] = g;
86    argb[3] = b;
87  }
88  #endif   
89  static WEBP_INLINE void YuvToBgra(uint8_t y, uint8_t u, uint8_t v,
90                                    uint8_t* const bgra) {
91    int r, g, b;
92    YUV_TO_RGB(y, u, v, r, g, b);
93    bgra[0] = b;
94    bgra[1] = g;
95    bgra[2] = r;
96    bgra[3] = 0xff;
97  }
98  static WEBP_INLINE void YuvToRgba(uint8_t y, uint8_t u, uint8_t v,
99                                    uint8_t* const rgba) {
100    int r, g, b;
101    YUV_TO_RGB(y, u, v, r, g, b);
102    rgba[0] = r;
103    rgba[1] = g;
104    rgba[2] = b;
105    rgba[3] = 0xff;
106  }
107  #ifdef FANCY_UPSAMPLING
108  #define LOAD_UV(u, v) ((u) | ((v) << 16))
109  #define UPSAMPLE_FUNC(FUNC_NAME, FUNC, XSTEP)                                  \
110  static void FUNC_NAME(const uint8_t* top_y, const uint8_t* bottom_y,           \
111                        const uint8_t* top_u, const uint8_t* top_v,              \
112                        const uint8_t* cur_u, const uint8_t* cur_v,              \
113                        uint8_t* top_dst, uint8_t* bottom_dst, int len) {        \
114    int x;                                                                       \
<span onclick='openModal()' class='match'>115    const int last_pixel_pair = (len - 1) >> 1;                                  \
116    uint32_t tl_uv = LOAD_UV(top_u[0], top_v[0]);   &bsol;* top-left sample */        \
117    uint32_t l_uv  = LOAD_UV(cur_u[0], cur_v[0]);   &bsol;* left-sample */            \
118    assert(top_y != NULL);                                                       \
119    {                                                                            \
120      const uint32_t uv0 = (3 * tl_uv + l_uv + 0x00020002u) >> 2;                \
121      FUNC(top_y[0], uv0 & 0xff, (uv0 >> 16), top_dst);                          \
122    }                                                                            \
123    if (bottom_y != NULL) {                                                      \
124      const uint32_t uv0 = (3 * l_uv + tl_uv + 0x00020002u) >> 2;                \
125      FUNC(bottom_y[0], uv0 & 0xff, (uv0 >> 16), bottom_dst);                    \
126    }                                                                            \
127    for (x = 1; x <= last_pixel_pair; ++x) {                                     \
128      const uint32_t t_uv = LOAD_UV(top_u[x], top_v[x]);  &bsol;* top sample */       \
129      const uint32_t uv   = LOAD_UV(cur_u[x], cur_v[x]);  &bsol;* sample */           \
130      \
131      const uint32_t avg = tl_uv + t_uv + l_uv + uv + 0x00080008u;               \
132      const uint32_t diag_12 = (avg + 2 * (t_uv + l_uv)) >> 3;                   \
133      const uint32_t diag_03 = (avg + 2 * (tl_uv + uv)) >> 3;                    \
134      {                                                                          \
135        const uint32_t uv0 = (diag_12 + tl_uv) >> 1;                             \
136        const uint32_t uv1 = (diag_03 + t_uv) >> 1;                              \
137        FUNC(top_y[2 * x - 1], uv0 & 0xff, (uv0 >> 16),                          \
138             top_dst + (2 * x - 1) * XSTEP);                                     \
</span>139        FUNC(top_y[2 * x - 0], uv1 & 0xff, (uv1 >> 16),                          \
140             top_dst + (2 * x - 0) * XSTEP);                                     \
141      }                                                                          \
142      if (bottom_y != NULL) {                                                    \
143        const uint32_t uv0 = (diag_03 + l_uv) >> 1;                              \
144        const uint32_t uv1 = (diag_12 + uv) >> 1;                                \
145        FUNC(bottom_y[2 * x - 1], uv0 & 0xff, (uv0 >> 16),                       \
146             bottom_dst + (2 * x - 1) * XSTEP);                                  \
147        FUNC(bottom_y[2 * x + 0], uv1 & 0xff, (uv1 >> 16),                       \
148             bottom_dst + (2 * x + 0) * XSTEP);                                  \
149      }                                                                          \
150      tl_uv = t_uv;                                                              \
151      l_uv = uv;                                                                 \
152    }                                                                            \
153    if (!(len & 1)) {                                                            \
154      {                                                                          \
155        const uint32_t uv0 = (3 * tl_uv + l_uv + 0x00020002u) >> 2;              \
156        FUNC(top_y[len - 1], uv0 & 0xff, (uv0 >> 16),                            \
157             top_dst + (len - 1) * XSTEP);                                       \
158      }                                                                          \
159      if (bottom_y != NULL) {                                                    \
160        const uint32_t uv0 = (3 * l_uv + tl_uv + 0x00020002u) >> 2;              \
161        FUNC(bottom_y[len - 1], uv0 & 0xff, (uv0 >> 16),                         \
162             bottom_dst + (len - 1) * XSTEP);                                    \
163      }                                                                          \
164    }                                                                            \
165  }
166  UPSAMPLE_FUNC(UpsampleRgbaLinePair,     YuvToRgba,     4)
167  UPSAMPLE_FUNC(UpsampleBgraLinePair,     YuvToBgra,     4)
168  #if !defined(WEBP_REDUCE_CSP)
169  UPSAMPLE_FUNC(UpsampleRgbLinePair,      YuvToRgb,      3)
170  UPSAMPLE_FUNC(UpsampleBgrLinePair,      YuvToBgr,      3)
171  UPSAMPLE_FUNC(UpsampleArgbLinePair,     YuvToArgb,     4)
172  UPSAMPLE_FUNC(UpsampleRgba4444LinePair, YuvToRgba4444, 2)
173  UPSAMPLE_FUNC(UpsampleRgb565LinePair,   YuvToRgb565,   2)
174  #endif   
175  #undef LOAD_UV
176  #undef UPSAMPLE_FUNC
177  extern void WebPInitUpsamplersMIPSdspR2(void);
178  WEBP_TSAN_IGNORE_FUNCTION void WebPInitUpsamplersMIPSdspR2(void) {
179    WebPUpsamplers[MODE_RGBA]      = UpsampleRgbaLinePair;
180    WebPUpsamplers[MODE_BGRA]      = UpsampleBgraLinePair;
181    WebPUpsamplers[MODE_rgbA]      = UpsampleRgbaLinePair;
182    WebPUpsamplers[MODE_bgrA]      = UpsampleBgraLinePair;
183  #if !defined(WEBP_REDUCE_CSP)
184    WebPUpsamplers[MODE_RGB]       = UpsampleRgbLinePair;
185    WebPUpsamplers[MODE_BGR]       = UpsampleBgrLinePair;
186    WebPUpsamplers[MODE_ARGB]      = UpsampleArgbLinePair;
187    WebPUpsamplers[MODE_RGBA_4444] = UpsampleRgba4444LinePair;
188    WebPUpsamplers[MODE_RGB_565]   = UpsampleRgb565LinePair;
189    WebPUpsamplers[MODE_Argb]      = UpsampleArgbLinePair;
190    WebPUpsamplers[MODE_rgbA_4444] = UpsampleRgba4444LinePair;
191  #endif   
192  }
193  #endif  
194  #define YUV444_FUNC(FUNC_NAME, FUNC, XSTEP)                                    \
195  static void FUNC_NAME(const uint8_t* y, const uint8_t* u, const uint8_t* v,    \
196                        uint8_t* dst, int len) {                                 \
197    int i;                                                                       \
198    for (i = 0; i < len; ++i) FUNC(y[i], u[i], v[i], &dst[i * XSTEP]);           \
199  }
200  YUV444_FUNC(Yuv444ToRgba,     YuvToRgba,     4)
201  YUV444_FUNC(Yuv444ToBgra,     YuvToBgra,     4)
202  #if !defined(WEBP_REDUCE_CSP)
203  YUV444_FUNC(Yuv444ToRgb,      YuvToRgb,      3)
204  YUV444_FUNC(Yuv444ToBgr,      YuvToBgr,      3)
205  YUV444_FUNC(Yuv444ToArgb,     YuvToArgb,     4)
206  YUV444_FUNC(Yuv444ToRgba4444, YuvToRgba4444, 2)
207  YUV444_FUNC(Yuv444ToRgb565,   YuvToRgb565,   2)
208  #endif   
209  #undef YUV444_FUNC
210  extern void WebPInitYUV444ConvertersMIPSdspR2(void);
211  WEBP_TSAN_IGNORE_FUNCTION void WebPInitYUV444ConvertersMIPSdspR2(void) {
212    WebPYUV444Converters[MODE_RGBA]      = Yuv444ToRgba;
213    WebPYUV444Converters[MODE_BGRA]      = Yuv444ToBgra;
214    WebPYUV444Converters[MODE_rgbA]      = Yuv444ToRgba;
215    WebPYUV444Converters[MODE_bgrA]      = Yuv444ToBgra;
216  #if !defined(WEBP_REDUCE_CSP)
217    WebPYUV444Converters[MODE_RGB]       = Yuv444ToRgb;
218    WebPYUV444Converters[MODE_BGR]       = Yuv444ToBgr;
219    WebPYUV444Converters[MODE_ARGB]      = Yuv444ToArgb;
220    WebPYUV444Converters[MODE_RGBA_4444] = Yuv444ToRgba4444;
221    WebPYUV444Converters[MODE_RGB_565]   = Yuv444ToRgb565;
222    WebPYUV444Converters[MODE_Argb]      = Yuv444ToArgb;
223    WebPYUV444Converters[MODE_rgbA_4444] = Yuv444ToRgba4444;
224  #endif   
225  }
226  #else  
227  WEBP_DSP_INIT_STUB(WebPInitYUV444ConvertersMIPSdspR2)
228  #endif  
229  #if !(defined(FANCY_UPSAMPLING) && defined(WEBP_USE_MIPS_DSP_R2))
230  WEBP_DSP_INIT_STUB(WebPInitUpsamplersMIPSdspR2)
231  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-upsampling.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-upsampling_mips_dsp_r2.c</div>
                </div>
                <div class="column column_space"><pre><code>13    const int last_pixel_pair = (len - 1) >> 1;                                  \
14    uint32_t tl_uv = LOAD_UV(top_u[0], top_v[0]);   &bsol;* top-left sample */        \
15    uint32_t l_uv  = LOAD_UV(cur_u[0], cur_v[0]);   &bsol;* left-sample */            \
16    assert(top_y != NULL);                                                       \
17    {                                                                            \
18      const uint32_t uv0 = (3 * tl_uv + l_uv + 0x00020002u) >> 2;                \
19      FUNC(top_y[0], uv0 & 0xff, (uv0 >> 16), top_dst);                          \
20    }                                                                            \
21    if (bottom_y != NULL) {                                                      \
22      const uint32_t uv0 = (3 * l_uv + tl_uv + 0x00020002u) >> 2;                \
23      FUNC(bottom_y[0], uv0 & 0xff, (uv0 >> 16), bottom_dst);                    \
24    }                                                                            \
25    for (x = 1; x <= last_pixel_pair; ++x) {                                     \
26      const uint32_t t_uv = LOAD_UV(top_u[x], top_v[x]);  &bsol;* top sample */       \
27      const uint32_t uv   = LOAD_UV(cur_u[x], cur_v[x]);  &bsol;* sample */           \
28      \
29      const uint32_t avg = tl_uv + t_uv + l_uv + uv + 0x00080008u;               \
30      const uint32_t diag_12 = (avg + 2 * (t_uv + l_uv)) >> 3;                   \
31      const uint32_t diag_03 = (avg + 2 * (tl_uv + uv)) >> 3;                    \
32      {                                                                          \
33        const uint32_t uv0 = (diag_12 + tl_uv) >> 1;                             \
34        const uint32_t uv1 = (diag_03 + t_uv) >> 1;                              \
35        FUNC(top_y[2 * x - 1], uv0 & 0xff, (uv0 >> 16),                          \
36             top_dst + (2 * x - 1) * (XSTEP));                                   \
</pre></code></div>
                <div class="column column_space"><pre><code>115    const int last_pixel_pair = (len - 1) >> 1;                                  \
116    uint32_t tl_uv = LOAD_UV(top_u[0], top_v[0]);   &bsol;* top-left sample */        \
117    uint32_t l_uv  = LOAD_UV(cur_u[0], cur_v[0]);   &bsol;* left-sample */            \
118    assert(top_y != NULL);                                                       \
119    {                                                                            \
120      const uint32_t uv0 = (3 * tl_uv + l_uv + 0x00020002u) >> 2;                \
121      FUNC(top_y[0], uv0 & 0xff, (uv0 >> 16), top_dst);                          \
122    }                                                                            \
123    if (bottom_y != NULL) {                                                      \
124      const uint32_t uv0 = (3 * l_uv + tl_uv + 0x00020002u) >> 2;                \
125      FUNC(bottom_y[0], uv0 & 0xff, (uv0 >> 16), bottom_dst);                    \
126    }                                                                            \
127    for (x = 1; x <= last_pixel_pair; ++x) {                                     \
128      const uint32_t t_uv = LOAD_UV(top_u[x], top_v[x]);  &bsol;* top sample */       \
129      const uint32_t uv   = LOAD_UV(cur_u[x], cur_v[x]);  &bsol;* sample */           \
130      \
131      const uint32_t avg = tl_uv + t_uv + l_uv + uv + 0x00080008u;               \
132      const uint32_t diag_12 = (avg + 2 * (t_uv + l_uv)) >> 3;                   \
133      const uint32_t diag_03 = (avg + 2 * (tl_uv + uv)) >> 3;                    \
134      {                                                                          \
135        const uint32_t uv0 = (diag_12 + tl_uv) >> 1;                             \
136        const uint32_t uv1 = (diag_03 + t_uv) >> 1;                              \
137        FUNC(top_y[2 * x - 1], uv0 & 0xff, (uv0 >> 16),                          \
138             top_dst + (2 * x - 1) * XSTEP);                                     \
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    