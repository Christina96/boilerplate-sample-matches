<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for lrmerge.c & image.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for lrmerge.c & image.c
      </h3>
      <h1 align="center">
        2.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>lrmerge.c (3.762663%)<TH>image.c (1.6219589%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match27985-0.html#0',2,'match27985-1.html#0',3)" NAME="0">(739-758)<TD><A HREF="javascript:ZweiFrames('match27985-0.html#0',2,'match27985-1.html#0',3)" NAME="0">(1073-1089)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match27985-0.html#1',2,'match27985-1.html#1',3)" NAME="1">(1015-1026)<TD><A HREF="javascript:ZweiFrames('match27985-0.html#1',2,'match27985-1.html#1',3)" NAME="1">(3432-3452)</A><TD ALIGN=center><FONT COLOR="#da0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>lrmerge.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* Merge two images left-right. 
 *
 * Copyright: 1990, 1991 N. Dessipris 
 * Author: N. Dessipris
 * Written on: 20/09/1990
 * Updated on: 17/04/1991
 * 1/6/92: JC
 * 	- check for difference bug fixed
 *	- geometry calculations improved and simplified
 *	- small speedups
 Kirk Martinez for Sys5 29/4/93
 * 7/8/93 JC
 *	- ANSIfied
 *	- memory leaks fixed, ready for partial v2
 *	- now does IM_CODING_LABQ too
 * 8/11/93 JC
 *	- now propogates both input histories
 *	- adds magic lines for global mosaic optimisation
 *
 *
 *
 May/1994 Ahmed Abbood
 *
 *	- Modified to use partials on all IO
 *
 June/1995 Ahmed Abbood
 *
 *	- Modified to work with different types of images.
 *
 * 16/6/95 JC
 *	- tidied up a little
 *	- added to VIPS!
 * 7/9/95 JC
 *	- split into two parts: im_lrmerge() and im__lrmerge()
 *	- latter called by im_lrmosaic()
 *	- just the same as public im_lrmerge(), but adds no history
 *	- necessary for im_global_balance()
 *	- small bugs fixed
 * 10/10/95 JC
 *	- better checks that parameters are sensible
 * 11/10/95 JC
 *	- Kirk spotted what a load of rubbish Ahmed's code is
 *	- rewritten - many, many bugs fixed
 * 24/1/97 JC
 *	- now outputs bounding area of input images, rather than clipping
 *	- ignores 0 pixels in blend
 *	- small tidies
 * 7/2/97 JC
 *	- new blend, caching
 * 25/2/97 JC
 *	- old blend back, much simpler
 *	- speed this up at some point if you think of an easy way to do it
 * 29/7/97 JC
 *	- IM_CODING_LABQ blend now works, was bug in im_wrapone()
 *	- small tidies
 * 10/1/98 JC
 *	- merge LUTs now shared between all running mergers
 *	- frees memory explicitly in im__stop_merge, for much better memory
 *	  use in large mosaics, huge improvement!
 * 18/2/98 JC
 *	- im_demand_hint() call added
 * 19/2/98 JC
 *	- now works for any dx/dy by calling im_insert() for bizarre cases
 * 26/9/99 JC
 *	- ooops, blend lut was wrong! wonder how long that's been broken,
 *	  since feb97 I guess
 * 2/2/01 JC
 *	- added tunable max blend width
 * 8/3/01 JC
 *	- switched to integer arithmetic for integer blends
 * 7/11/01 JC
 *	- more sophisticated transparency handling
 *	- tiny blend speed up
 * 19/3/02 JC
 * 	- move fl cache to main state for better sharing
 * 15/8/02 JC
 *	- records Xoffset/Yoffset
 * 20/6/05
 *	- now requires all bands == 0 for transparency (used to just check
 *	  band 0)
 * 24/1/11
 * 	- gtk-doc
 * 	- match formats and bands automatically
 * 22/5/14
 * 	- wrap as a class
 * 18/6/20 kleisauke
 * 	- convert to vips8
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;

/* Define for debug output.
#define DEBUG
 */

#include &lt;vips/vips.h&gt;
#include &lt;vips/thread.h&gt;
#include &lt;vips/transform.h&gt;
#include &lt;vips/internal.h&gt;

#include &quot;pmosaicing.h&quot;

/* Blend luts. Shared between all lr and tb blends.
 */
double *vips__coef1 = NULL;
double *vips__coef2 = NULL;
int *vips__icoef1 = NULL;
int *vips__icoef2 = NULL;

/* Create a lut for the merging area. Always BLEND_SIZE entries, we 
 * scale later when we index it.
 */
int
vips__make_blend_luts( void )
{
	int x;

	/* Already done?
	 */
	if( vips__coef1 &amp;&amp; vips__coef2 )
		return( 0 );

	/* Allocate and fill.
	 */
	vips__coef1 = VIPS_ARRAY( NULL, BLEND_SIZE, double );
	vips__coef2 = VIPS_ARRAY( NULL, BLEND_SIZE, double );
	vips__icoef1 = VIPS_ARRAY( NULL, BLEND_SIZE, int );
	vips__icoef2 = VIPS_ARRAY( NULL, BLEND_SIZE, int );
	if( !vips__coef1 || !vips__coef2 || !vips__icoef1 || !vips__icoef2 ) 
		return( -1 ); 

	for( x = 0; x &lt; BLEND_SIZE; x++ ) {
		double a = VIPS_PI * x / (BLEND_SIZE - 1.0);

		vips__coef1[x] = (cos( a ) + 1.0) / 2.0;
		vips__coef2[x] = 1.0 - vips__coef1[x];
		vips__icoef1[x] = vips__coef1[x] * BLEND_SCALE;
		vips__icoef2[x] = vips__coef2[x] * BLEND_SCALE;
	}

	return( 0 );
}

/* Return the position of the first non-zero pel from the left.
 */
static int
find_first( VipsRegion *ir, int *pos, int x, int y, int w )
{
	VipsPel *pr = VIPS_REGION_ADDR( ir, x, y );
	VipsImage *im = ir-&gt;im;
	int ne = w * im-&gt;Bands;
	int i;

	/* Double the number of bands in a complex.
	 */
	if( vips_band_format_iscomplex( im-&gt;BandFmt ) )
		ne *= 2;

/* Search for the first non-zero band element from the left edge of the image.
 */
#define lsearch( TYPE ) { \
	TYPE *p = (TYPE *) pr; \
	\
	for( i = 0; i &lt; ne; i++ ) \
		if( p[i] )\
			break;\
}

	switch( im-&gt;BandFmt ) {
	case VIPS_FORMAT_UCHAR:		lsearch( unsigned char ); break; 
	case VIPS_FORMAT_CHAR:		lsearch( signed char ); break; 
	case VIPS_FORMAT_USHORT:	lsearch( unsigned short ); break; 
	case VIPS_FORMAT_SHORT:		lsearch( signed short ); break; 
	case VIPS_FORMAT_UINT:		lsearch( unsigned int ); break; 
	case VIPS_FORMAT_INT:		lsearch( signed int );  break; 
	case VIPS_FORMAT_FLOAT:		lsearch( float ); break; 
	case VIPS_FORMAT_DOUBLE:	lsearch( double ); break; 
	case VIPS_FORMAT_COMPLEX:	lsearch( float ); break; 
	case VIPS_FORMAT_DPCOMPLEX:	lsearch( double ); break;

	default:
		g_assert_not_reached(); 
		return( -1 );
	}

	/* i is first non-zero band element, we want first non-zero pixel.
	 */
	*pos = x + i / im-&gt;Bands;

	return( 0 );
}

/* Return the position of the first non-zero pel from the right.
 */
static int
find_last( VipsRegion *ir, int *pos, int x, int y, int w )
{
	VipsPel *pr = VIPS_REGION_ADDR( ir, x, y );
	VipsImage *im = ir-&gt;im;
	int ne = w * im-&gt;Bands;
	int i;

	/* Double the number of bands in a complex.
	 */
	if( vips_band_format_iscomplex( im-&gt;BandFmt ) )
		ne *= 2;

/* Search for the first non-zero band element from the right.
 */
#define rsearch( TYPE ) { \
	TYPE *p = (TYPE *) pr; \
	\
	for( i = ne - 1; i &gt;= 0; i-- )\
		if( p[i] )\
			break;\
}

	switch( im-&gt;BandFmt ) {
	case VIPS_FORMAT_UCHAR:		rsearch( unsigned char ); break; 
	case VIPS_FORMAT_CHAR:		rsearch( signed char ); break; 
	case VIPS_FORMAT_USHORT:	rsearch( unsigned short ); break; 
	case VIPS_FORMAT_SHORT:		rsearch( signed short ); break; 
	case VIPS_FORMAT_UINT:		rsearch( unsigned int ); break; 
	case VIPS_FORMAT_INT:		rsearch( signed int );  break; 
	case VIPS_FORMAT_FLOAT:		rsearch( float ); break; 
	case VIPS_FORMAT_DOUBLE:	rsearch( double ); break; 
	case VIPS_FORMAT_COMPLEX:	rsearch( float ); break; 
	case VIPS_FORMAT_DPCOMPLEX:	rsearch( double ); break;

	default:
		vips_error( &quot;lrmerge&quot;, &quot;%s&quot;, _( &quot;internal error&quot; ) );
		return( -1 );
	}

	/* i is first non-zero band element, we want first non-zero pixel.
	 */
	*pos = x + i / im-&gt;Bands;

	return( 0 );
}

/* Make sure we have first/last for this area.
 */
static int
make_firstlast( MergeInfo *inf, Overlapping *ovlap, VipsRect *oreg )
{
	VipsRegion *rir = inf-&gt;rir;
	VipsRegion *sir = inf-&gt;sir;
	VipsRect rr, sr;
	int y, yr, ys;
	int missing;

	/* We're going to build first/last ... lock it from other generate
	 * threads. In fact it's harmless if we do get two writers, but we may
	 * avoid duplicating work.
	 */
	g_mutex_lock( ovlap-&gt;fl_lock );

	/* Do we already have first/last for this area? Bail out if we do.
	 */
	missing = 0;
	for( y = oreg-&gt;top; y &lt; VIPS_RECT_BOTTOM( oreg ); y++ ) {
		const int j = y - ovlap-&gt;overlap.top;
		const int first = ovlap-&gt;first[j];

		if( first &lt; 0 ) {
			missing = 1;
			break;
		}
	}
	if( !missing ) {
		/* No work to do!
		 */
		g_mutex_unlock( ovlap-&gt;fl_lock );
		return( 0 );
	}

	/* Entire width of overlap in ref for scan-lines we want.
	 */
	rr.left = ovlap-&gt;overlap.left;
	rr.top = oreg-&gt;top;
	rr.width = ovlap-&gt;overlap.width;
	rr.height = oreg-&gt;height;
	rr.left -= ovlap-&gt;rarea.left;
	rr.top -= ovlap-&gt;rarea.top;

	/* Entire width of overlap in sec for scan-lines we want.
	 */
	sr.left = ovlap-&gt;overlap.left;
	sr.top = oreg-&gt;top;
	sr.width = ovlap-&gt;overlap.width;
	sr.height = oreg-&gt;height;
	sr.left -= ovlap-&gt;sarea.left;
	sr.top -= ovlap-&gt;sarea.top;

#ifdef DEBUG
	printf( &quot;lrmerge: making first/last for areas:\n&quot; );
	printf( &quot;ref: left = %d, top = %d, width = %d, height = %d\n&quot;,
		rr.left, rr.top, rr.width, rr.height );
	printf( &quot;sec: left = %d, top = %d, width = %d, height = %d\n&quot;,
		sr.left, sr.top, sr.width, sr.height );
#endif

	/* Make pixels.
	 */
	if( vips_region_prepare( rir, &amp;rr ) ||
		vips_region_prepare( sir, &amp;sr ) ) {
		g_mutex_unlock( ovlap-&gt;fl_lock );
		return( -1 );
	}

	/* Make first/last cache.
	 */
	for( y = oreg-&gt;top, yr = rr.top, ys = sr.top; 
		y &lt; VIPS_RECT_BOTTOM( oreg ); y++, yr++, ys++ ) {
		const int j = y - ovlap-&gt;overlap.top;
		int *first = &amp;ovlap-&gt;first[j];
		int *last = &amp;ovlap-&gt;last[j];

		/* Done this line already?
		 */
		if( *first &lt; 0 ) {
			/* Search for start/end of overlap on this scan-line.
			 */
			if( find_first( sir, first, 
				sr.left, ys, sr.width ) ||
				find_last( rir, last, 
					rr.left, yr, rr.width ) ) {
				g_mutex_unlock( ovlap-&gt;fl_lock );
				return( -1 );
			}

			/* Translate to output space.
			 */
			*first += ovlap-&gt;sarea.left;
			*last += ovlap-&gt;rarea.left;

			/* Clip to maximum blend width, if necessary.
			 */
			if( ovlap-&gt;mwidth &gt;= 0 &amp;&amp; 
				*last - *first &gt; ovlap-&gt;mwidth ) {
				int shrinkby = (*last - *first) - ovlap-&gt;mwidth;

				*first += shrinkby / 2;
				*last -= shrinkby / 2;
			}
		}
	}

	g_mutex_unlock( ovlap-&gt;fl_lock );

	return( 0 );
}

/* Test pixel == 0.
 */
#define TEST_ZERO( TYPE, T, RESULT ) { \
	TYPE *tt = (T); \
	int ii; \
	\
	for( ii = 0; ii &lt; cb; ii++ ) \
		if( tt[i + ii] ) \
			break; \
	if( ii == cb )  \
		(RESULT) = 1; \
}

/* Blend two integer images.
 */
#define iblend( TYPE, B, IN1, IN2, OUT ) { \
	TYPE *tr = (TYPE *) (IN1); \
	TYPE *ts = (TYPE *) (IN2); \
	TYPE *tq = (TYPE *) (OUT); \
	const int cb = (B); \
	const int left = VIPS_CLIP( 0, first - oreg-&gt;left, oreg-&gt;width ); \
	const int right = VIPS_CLIP( left, last - oreg-&gt;left, oreg-&gt;width ); \
	int ref_zero; \
	int sec_zero; \
	int x, b; \
	int i; \
	\
	/* Left of the blend area. \
	 */ \
	for( i = 0, x = 0; x &lt; left; x++ ) { \
		ref_zero = 0; \
		TEST_ZERO( TYPE, tr, ref_zero ); \
		if( !ref_zero ) \
			for( b = 0; b &lt; cb; b++, i++ ) \
				tq[i] = tr[i]; \
		else \
			for( b = 0; b &lt; cb; b++, i++ ) \
				tq[i] = ts[i]; \
	} \
	\
	/* In blend area. \
	 */ \
	for( x = left; x &lt; right; x++ ) { \
		ref_zero = 0; \
		sec_zero = 0; \
		TEST_ZERO( TYPE, tr, ref_zero ); \
		TEST_ZERO( TYPE, ts, sec_zero ); \
		\
		if( !ref_zero &amp;&amp; !sec_zero ) { \
			int inx = ((x + oreg-&gt;left - first) &lt;&lt;  \
				BLEND_SHIFT) / bwidth; \
			int c1 = vips__icoef1[inx]; \
			int c2 = vips__icoef2[inx]; \
			\
			for( b = 0; b &lt; cb; b++, i++ ) \
				tq[i] = c1 * tr[i] / BLEND_SCALE + \
					c2 * ts[i] / BLEND_SCALE; \
		} \
		else if( !ref_zero ) \
			for( b = 0; b &lt; cb; b++, i++ ) \
				tq[i] = tr[i]; \
		else \
			for( b = 0; b &lt; cb; b++, i++ ) \
				tq[i] = ts[i]; \
	} \
	\
	/* Right of blend.
	 */ \
	for( x = right; x &lt; oreg-&gt;width; x++ ) { \
		sec_zero = 0; \
		TEST_ZERO( TYPE, ts, sec_zero ); \
		if( !sec_zero ) \
			for( b = 0; b &lt; cb; b++, i++ )  \
				tq[i] = ts[i]; \
		else \
			for( b = 0; b &lt; cb; b++, i++ )  \
				tq[i] = tr[i]; \
	} \
}

/* Blend two float images.
 */
#define fblend( TYPE, B, IN1, IN2, OUT ) { \
	TYPE *tr = (TYPE *) (IN1); \
	TYPE *ts = (TYPE *) (IN2); \
	TYPE *tq = (TYPE *) (OUT); \
	const int cb = (B); \
	const int left = VIPS_CLIP( 0, first - oreg-&gt;left, oreg-&gt;width ); \
	const int right = VIPS_CLIP( left, last - oreg-&gt;left, oreg-&gt;width ); \
	int ref_zero; \
	int sec_zero; \
	int x, b; \
	int i; \
	\
	/* Left of the blend area. \
	 */ \
	for( i = 0, x = 0; x &lt; left; x++ ) { \
		ref_zero = 0; \
		TEST_ZERO( TYPE, tr, ref_zero ); \
		if( !ref_zero ) \
			for( b = 0; b &lt; cb; b++, i++ ) \
				tq[i] = tr[i]; \
		else \
			for( b = 0; b &lt; cb; b++, i++ ) \
				tq[i] = ts[i]; \
	} \
	\
	/* In blend area. \
	 */ \
	for( x = left; x &lt; right; x++ ) { \
		ref_zero = 0; \
		sec_zero = 0; \
		TEST_ZERO( TYPE, tr, ref_zero ); \
		TEST_ZERO( TYPE, ts, sec_zero ); \
		\
		if( !ref_zero &amp;&amp; !sec_zero ) { \
			int inx = ((x + oreg-&gt;left - first) &lt;&lt;  \
				BLEND_SHIFT) / bwidth; \
			double c1 = vips__coef1[inx];  \
			double c2 = vips__coef2[inx];  \
			\
			for( b = 0; b &lt; cb; b++, i++ ) \
				tq[i] = c1 * tr[i] + c2 * ts[i]; \
		} \
		else if( !ref_zero ) \
			for( b = 0; b &lt; cb; b++, i++ ) \
				tq[i] = tr[i]; \
		else \
			for( b = 0; b &lt; cb; b++, i++ ) \
				tq[i] = ts[i]; \
	} \
	\
	/* Right of blend.
	 */ \
	for( x = right; x &lt; oreg-&gt;width; x++ ) { \
		sec_zero = 0; \
		TEST_ZERO( TYPE, ts, sec_zero ); \
		if( !sec_zero ) \
			for( b = 0; b &lt; cb; b++, i++ )  \
				tq[i] = ts[i]; \
		else \
			for( b = 0; b &lt; cb; b++, i++ )  \
				tq[i] = tr[i]; \
	} \
}

/* Left-right blend function for non-labpack images.
 */
static int
lr_blend( VipsRegion *or, MergeInfo *inf, Overlapping *ovlap, VipsRect *oreg )
{
	VipsRegion *rir = inf-&gt;rir;
	VipsRegion *sir = inf-&gt;sir;
	VipsImage *im = or-&gt;im;

	VipsRect prr, psr;
	int y, yr, ys;

	/* Make sure we have a complete first/last set for this area.
	 */
	if( make_firstlast( inf, ovlap, oreg ) )
		return( -1 );

	/* Part of rr which we will output.
	 */
	prr = *oreg;
	prr.left -= ovlap-&gt;rarea.left;
	prr.top -= ovlap-&gt;rarea.top;

	/* Part of sr which we will output.
	 */
	psr = *oreg;
	psr.left -= ovlap-&gt;sarea.left;
	psr.top -= ovlap-&gt;sarea.top;

	/* Make pixels.
	 */
	if( vips_region_prepare( rir, &amp;prr ) || 
		vips_region_prepare( sir, &amp;psr ) )
		return( -1 );

	/* Loop down overlap area.
	 */
	for( y = oreg-&gt;top, yr = prr.top, ys = psr.top; 
		y &lt; VIPS_RECT_BOTTOM( oreg ); y++, yr++, ys++ ) { 
		VipsPel *pr = VIPS_REGION_ADDR( rir, prr.left, yr );
		VipsPel *ps = VIPS_REGION_ADDR( sir, psr.left, ys );
		VipsPel *q = VIPS_REGION_ADDR( or, oreg-&gt;left, y );

		const int j = y - ovlap-&gt;overlap.top;
		const int first = ovlap-&gt;first[j];
		const int last = ovlap-&gt;last[j];
		const int bwidth = last - first;

		switch( im-&gt;BandFmt ) {
		case VIPS_FORMAT_UCHAR: 	
			iblend( unsigned char, im-&gt;Bands, pr, ps, q ); break; 
		case VIPS_FORMAT_CHAR: 	
			iblend( signed char, im-&gt;Bands, pr, ps, q ); break; 
		case VIPS_FORMAT_USHORT: 
			iblend( unsigned short, im-&gt;Bands, pr, ps, q ); break; 
		case VIPS_FORMAT_SHORT: 	
			iblend( signed short, im-&gt;Bands, pr, ps, q ); break; 
		case VIPS_FORMAT_UINT: 	
			iblend( unsigned int, im-&gt;Bands, pr, ps, q ); break; 
		case VIPS_FORMAT_INT: 	
			iblend( signed int, im-&gt;Bands, pr, ps, q );  break; 
		case VIPS_FORMAT_FLOAT: 	
			fblend( float, im-&gt;Bands, pr, ps, q ); break; 
		case VIPS_FORMAT_DOUBLE:	
			fblend( double, im-&gt;Bands, pr, ps, q ); break; 
		case VIPS_FORMAT_COMPLEX:
			fblend( float, im-&gt;Bands * 2, pr, ps, q ); break; 
		case VIPS_FORMAT_DPCOMPLEX:
			fblend( double, im-&gt;Bands * 2, pr, ps, q ); break;

		default:
			g_assert_not_reached();
			return( -1 );
		}
	}

	return( 0 );
}

/* Left-right blend function for VIPS_CODING_LABQ images.
 */
static int
lr_blend_labpack( VipsRegion *or, MergeInfo *inf, Overlapping *ovlap, 
	VipsRect *oreg )
{
	VipsRegion *rir = inf-&gt;rir;
	VipsRegion *sir = inf-&gt;sir;
	VipsRect prr, psr;
	int y, yr, ys;

	/* Make sure we have a complete first/last set for this area. This
	 * will just look at the top 8 bits of L, not all 10, but should be OK.
	 */
	if( make_firstlast( inf, ovlap, oreg ) )
		return( -1 );

	/* Part of rr which we will output.
	 */
	prr = *oreg;
	prr.left -= ovlap-&gt;rarea.left;
	prr.top -= ovlap-&gt;rarea.top;

	/* Part of sr which we will output.
	 */
	psr = *oreg;
	psr.left -= ovlap-&gt;sarea.left;
	psr.top -= ovlap-&gt;sarea.top;

	/* Make pixels.
	 */
	if( vips_region_prepare( rir, &amp;prr ) || 
		vips_region_prepare( sir, &amp;psr ) )
		return( -1 );

	/* Loop down overlap area.
	 */
	for( y = oreg-&gt;top, yr = prr.top, ys = psr.top; 
		y &lt; VIPS_RECT_BOTTOM( oreg ); y++, yr++, ys++ ) { 
		VipsPel *pr = VIPS_REGION_ADDR( rir, prr.left, yr );
		VipsPel *ps = VIPS_REGION_ADDR( sir, psr.left, ys );
		VipsPel *q = VIPS_REGION_ADDR( or, oreg-&gt;left, y );

		const int j = y - ovlap-&gt;overlap.top;
		const int first = ovlap-&gt;first[j];
		const int last = ovlap-&gt;last[j];
		const int bwidth = last - first;

		float *fq = inf-&gt;merge;
		float *r = inf-&gt;from1;
		float *s = inf-&gt;from2;

		/* Unpack two bits we want.
		 */
		vips__LabQ2Lab_vec( r, pr, oreg-&gt;width );
		vips__LabQ2Lab_vec( s, ps, oreg-&gt;width );

		/* Blend as floats.
		 */
		fblend( float, 3, r, s, fq ); 

		/* Re-pack to output buffer.
		 */
		vips__Lab2LabQ_vec( q, inf-&gt;merge, oreg-&gt;width );
	}

	return( 0 );
}

static void
lock_free( VipsImage *image, GMutex *lock )
{
	VIPS_FREEF( vips_g_mutex_free, lock );
}

/* Build basic per-call state and do some geometry calculations. Shared with
 * tbmerge, so not static.
 */
Overlapping *
vips__build_mergestate( const char *domain,
	VipsImage *ref, VipsImage *sec, VipsImage *out, 
	int dx, int dy, int mwidth )
{
	VipsImage **t = (VipsImage **)
		vips_object_local_array( VIPS_OBJECT( out ), 4 );

	VipsImage **arry;
   	Overlapping *ovlap;
	int x;

	/* TODO(kleisauke): Copied from vips_insert, perhaps we
	 * need a separate function for this?
	 * (just like im__insert_base)
	 */
	if( vips_image_pio_input( ref ) ||
		vips_image_pio_input( sec ) ||
		vips_check_bands_1orn( domain, ref, sec ) ||
		vips_check_coding_known( domain, ref ) ||
		vips_check_coding_same( domain, ref, sec ) )
		return( NULL );

	/* Cast our input images up to a common format and bands.
	 */
	if( vips__formatalike( ref, sec, &amp;t[0], &amp;t[1] ) ||
		vips__bandalike( domain, t[0], t[1], &amp;t[2], &amp;t[3] ) )
		return( NULL );
	
	if( !(arry = vips_allocate_input_array( out,
		t[2], t[3], NULL )) )
		return( NULL );

	if( vips_image_pipeline_array( out,
		VIPS_DEMAND_STYLE_SMALLTILE, arry ) )
		return( NULL );

	if( mwidth &lt; -1 ) {
		vips_error( domain, &quot;%s&quot;, _( &quot;mwidth must be -1 or &gt;= 0&quot; ) );
		return( NULL );
	}

<A NAME="0"></A>	if( !(ovlap = VIPS_NEW( out, Overlapping )) )
		return( NULL );

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match27985-1.html#0',3,'match27985-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	ovlap-&gt;ref = arry[0];
	ovlap-&gt;sec = arry[1];
	ovlap-&gt;out = out;
	ovlap-&gt;dx = dx;
	ovlap-&gt;dy = dy;
	ovlap-&gt;mwidth = mwidth;

	/* Area occupied by ref image. Place at (0,0) to start with.
	 */
   	ovlap-&gt;rarea.left = 0;
   	ovlap-&gt;rarea.top = 0;
   	ovlap-&gt;rarea.width = ovlap-&gt;ref-&gt;Xsize;
   	ovlap-&gt;rarea.height = ovlap-&gt;ref-&gt;Ysize;

	/* Area occupied by sec image. 
	 */
   	ovlap-&gt;sarea.left = -dx;
   	ovlap-&gt;sarea.top = -dy;
   	ovlap-&gt;sarea.width = ovlap-&gt;sec-&gt;Xsize;
   	ovlap-&gt;sarea.height = ovlap-&gt;sec-&gt;Ysize;</B></FONT>

	/* Compute overlap. 
	 */
	vips_rect_intersectrect( &amp;ovlap-&gt;rarea, &amp;ovlap-&gt;sarea, &amp;ovlap-&gt;overlap );
	if( vips_rect_isempty( &amp;ovlap-&gt;overlap ) ) {
		vips_error( domain, &quot;%s&quot;, _( &quot;no overlap&quot; ) );
		return( NULL );
	}

	/* Find position and size of output image.
	 */
	vips_rect_unionrect( &amp;ovlap-&gt;rarea, &amp;ovlap-&gt;sarea, &amp;ovlap-&gt;oarea );

	/* Now: translate everything, so that the output image, not the left
	 * image, is at (0,0).
	 */
	ovlap-&gt;rarea.left -= ovlap-&gt;oarea.left;
	ovlap-&gt;rarea.top -= ovlap-&gt;oarea.top;
	ovlap-&gt;sarea.left -= ovlap-&gt;oarea.left;
	ovlap-&gt;sarea.top -= ovlap-&gt;oarea.top;
	ovlap-&gt;overlap.left -= ovlap-&gt;oarea.left;
	ovlap-&gt;overlap.top -= ovlap-&gt;oarea.top;
	ovlap-&gt;oarea.left = 0;
	ovlap-&gt;oarea.top = 0;

	/* Make sure blend luts are built.
	 */
	vips__make_blend_luts();
	
	/* Size of first/last cache. Could be either of these ... just pick
	 * the larger.
	 */
	ovlap-&gt;flsize = VIPS_MAX( ovlap-&gt;overlap.width, ovlap-&gt;overlap.height );

	/* Build first/last cache.
	 */
	ovlap-&gt;first = VIPS_ARRAY( out, ovlap-&gt;flsize, int );
	ovlap-&gt;last = VIPS_ARRAY( out, ovlap-&gt;flsize, int );
	if( !ovlap-&gt;first || !ovlap-&gt;last ) 
		return( NULL ); 
	for( x = 0; x &lt; ovlap-&gt;flsize; x++ )
		ovlap-&gt;first[x] = -1;

	ovlap-&gt;fl_lock = vips_g_mutex_new();

	g_signal_connect( out, &quot;close&quot;,
		G_CALLBACK( lock_free ), ovlap-&gt;fl_lock );

	return( ovlap );
}

/* Build per-call state.
 */
static Overlapping *
build_lrstate( VipsImage *ref, VipsImage *sec, VipsImage *out, 
	int dx, int dy, int mwidth )
{
   	Overlapping *ovlap;

	if( !(ovlap = vips__build_mergestate( &quot;lrmerge&quot;, 
		ref, sec, out, dx, dy, mwidth )) )
		return( NULL );

	/* Select blender.
	 */
	switch( ovlap-&gt;ref-&gt;Coding ) {
	case VIPS_CODING_LABQ:
		ovlap-&gt;blend = lr_blend_labpack;
		break;

	case VIPS_CODING_NONE:
		ovlap-&gt;blend = lr_blend;
		break;

	default:
		vips_error( &quot;lrmerge&quot;, &quot;%s&quot;, _( &quot;unknown coding type&quot; ) );
		return( NULL );
	}

	/* Find the parts of output which come just from ref and just from sec.
	 */
	ovlap-&gt;rpart = ovlap-&gt;rarea;
	ovlap-&gt;spart = ovlap-&gt;sarea;
	ovlap-&gt;rpart.width -= ovlap-&gt;overlap.width;
	ovlap-&gt;spart.left += ovlap-&gt;overlap.width;
	ovlap-&gt;spart.width -= ovlap-&gt;overlap.width;

	/* Is there too much overlap? ie. right edge of ref image is greater
	 * than right edge of sec image, or left &gt; left.
	 */
	if( VIPS_RECT_RIGHT( &amp;ovlap-&gt;rarea ) &gt; 
		VIPS_RECT_RIGHT( &amp;ovlap-&gt;sarea ) ||
		ovlap-&gt;rarea.left &gt; ovlap-&gt;sarea.left ) {
		vips_error( &quot;lrmerge&quot;, &quot;%s&quot;, _( &quot;too much overlap&quot; ) );
		return( NULL );
	}

	/* Max number of pixels we may have to blend over.
	 */
	ovlap-&gt;blsize = ovlap-&gt;overlap.width;

	return( ovlap );
}

/* The area being demanded can be filled using only pels from either the ref 
 * or the sec images. Attach output to the appropriate part of the input image. 
 * area is the position that ir-&gt;im occupies in the output image.
 *
 * Shared with tbmerge, so not static.
 */
int
vips__attach_input( VipsRegion *or, VipsRegion *ir, VipsRect *area )
{
	VipsRect r = or-&gt;valid;

	/* Translate to source coordinate space.
	 */
	r.left -= area-&gt;left;
	r.top -= area-&gt;top;

	/* Demand input.
	 */
	if( vips_region_prepare( ir, &amp;r ) )
		return( -1 );

	/* Attach or to ir.
	 */
	if( vips_region_region( or, ir, &amp;or-&gt;valid, r.left, r.top ) )
		 return( -1 );

	return( 0 );
}

/* The area being demanded requires pixels from the ref and sec images. As 
 * above, but just do a sub-area of the output, and make sure we copy rather 
 * than just pointer-fiddling. reg is the sub-area of or-&gt;valid we should do.
 *
 * Shared with tbmerge, so not static.
 */
int
vips__copy_input( VipsRegion *or, VipsRegion *ir, 
	VipsRect *area, VipsRect *reg )
{
	VipsRect r = *reg;

	/* Translate to source coordinate space.
	 */
	r.left -= area-&gt;left;
	r.top -= area-&gt;top;

	/* Paint this area of ir into or.
	 */
	if( vips_region_prepare_to( ir, or, &amp;r, reg-&gt;left, reg-&gt;top ) )
		return( -1 );

	return( 0 );
}

/* Generate function for merge. This is shared between lrmerge and
 * tbmerge.
 */
int
vips__merge_gen( VipsRegion *or, void *seq, void *a, void *b, 
	gboolean *stop )
{
	MergeInfo *inf = (MergeInfo *) seq;
	Overlapping *ovlap = (Overlapping *) a;
	VipsRect *r = &amp;or-&gt;valid;
	VipsRect rreg, sreg, oreg;

	/* Find intersection with overlap, ref and sec parts. 
	 */
	vips_rect_intersectrect( r, &amp;ovlap-&gt;rpart, &amp;rreg );
	vips_rect_intersectrect( r, &amp;ovlap-&gt;spart, &amp;sreg );

	/* Do easy cases first: can we satisfy this demand with pixels just 
	 * from ref, or just from sec.
	 */
	if( vips_rect_equalsrect( r, &amp;rreg ) ) {
		if( vips__attach_input( or, inf-&gt;rir, &amp;ovlap-&gt;rarea ) )
			return( -1 );
	}
	else if( vips_rect_equalsrect( r, &amp;sreg ) ) {
		if( vips__attach_input( or, inf-&gt;sir, &amp;ovlap-&gt;sarea ) )
			return( -1 );
	}
	else {
		/* Difficult case - do in three stages: black out whole area, 
		 * copy in parts of ref and sec we touch, write blend area. 
		 * This could be sped up somewhat ... we will usually black 
		 * out far too much, and write to the blend area three times. 
		 * Upgrade in the future!
		 */

		/* Need intersections with whole of left &amp; right, and overlap
		 * too.
		 */
		vips_rect_intersectrect( r, &amp;ovlap-&gt;rarea, &amp;rreg );
		vips_rect_intersectrect( r, &amp;ovlap-&gt;sarea, &amp;sreg );
		vips_rect_intersectrect( r, &amp;ovlap-&gt;overlap, &amp;oreg );

		vips_region_black( or );
		if( !vips_rect_isempty( &amp;rreg ) ) 
			if( vips__copy_input( or, 
				inf-&gt;rir, &amp;ovlap-&gt;rarea, &amp;rreg ) )
				return( -1 );
		if( !vips_rect_isempty( &amp;sreg ) )
			if( vips__copy_input( or, 
				inf-&gt;sir, &amp;ovlap-&gt;sarea, &amp;sreg ) )
				return( -1 );

		/* Nasty: inf-&gt;rir and inf-&gt;sir now point to the same bit of
		 * memory (part of or), and we've written twice. We need to
		 * make sure we get fresh pixels for the blend, so we must
		 * invalidate them both. Should maybe add a call to the API
		 * for this.
		 */
		inf-&gt;rir-&gt;valid.width = inf-&gt;sir-&gt;valid.width = 0;

		/* Now blat in the blended area.
		 */
		if( !vips_rect_isempty( &amp;oreg ) )
			if( ovlap-&gt;blend( or, inf, ovlap, &amp;oreg ) )
				return( -1 );
	}

	return( 0 );
}

/* Stop function. Shared with tbmerge. Free explicitly to reduce mem
 * requirements quickly for large mosaics.
 */
int
vips__stop_merge( void *seq, void *a, void *b )
{
	MergeInfo *inf = (MergeInfo *) seq;

	VIPS_UNREF( inf-&gt;rir );
	VIPS_UNREF( inf-&gt;sir );
	VIPS_FREE( inf-&gt;from1 );
	VIPS_FREE( inf-&gt;from2 );
	VIPS_FREE( inf-&gt;merge );
	g_free( inf );

	return( 0 );
}

/* Start function. Shared with tbmerge.
 */
void *
vips__start_merge( VipsImage *out, void *a, void *b )
{
	Overlapping *ovlap = (Overlapping *) a;
<A NAME="1"></A>	MergeInfo *inf;

	if( !(inf = VIPS_NEW( NULL, MergeInfo )) )
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match27985-1.html#1',3,'match27985-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		return( NULL );

	inf-&gt;rir = NULL;
	inf-&gt;sir = NULL;
	inf-&gt;from1 = NULL;
	inf-&gt;from2 = NULL;
	inf-&gt;merge = NULL;

	/* If this is going to be a VIPS_CODING_LABQ, we need VIPS_CODING_LABQ 
	 * blend buffers.
	 */
	if( out-&gt;Coding == VIPS_CODING_LABQ ) {</B></FONT>
		inf-&gt;from1 = VIPS_ARRAY( NULL, ovlap-&gt;blsize * 3, float );
		inf-&gt;from2 = VIPS_ARRAY( NULL, ovlap-&gt;blsize * 3, float );
		inf-&gt;merge = VIPS_ARRAY( NULL, ovlap-&gt;blsize * 3, float );
		if( !inf-&gt;from1 || !inf-&gt;from2 || !inf-&gt;merge ) {
			vips__stop_merge( inf, NULL, NULL );
			return( NULL ); 
		}
	}

	inf-&gt;rir = vips_region_new( ovlap-&gt;ref );
	inf-&gt;sir = vips_region_new( ovlap-&gt;sec );

	if( !inf-&gt;rir || !inf-&gt;sir ) {
		vips__stop_merge( inf, NULL, NULL );
		return( NULL );
	}

	return( inf );
}

int
vips__lrmerge( VipsImage *ref, VipsImage *sec, VipsImage *out, 
	int dx, int dy, int mwidth )
{
	Overlapping *ovlap;

#ifdef DEBUG
	printf( &quot;lrmerge %s %s %s %d %d %d\n&quot;, 
		ref-&gt;filename, sec-&gt;filename, out-&gt;filename, 
		dx, dy, mwidth );
	printf( &quot;ref is %d x %d pixels\n&quot;, ref-&gt;Xsize, ref-&gt;Ysize );
	printf( &quot;sec is %d x %d pixels\n&quot;, sec-&gt;Xsize, sec-&gt;Ysize );
#endif

	if( dx &gt; 0 || dx &lt; 1 - ref-&gt;Xsize ) {
		VipsImage *x;

#ifdef DEBUG
		printf( &quot;lrmerge: no overlap, using insert\n&quot; ); 
#endif

		/* No overlap, use insert instead.
		 */
  		if( vips_insert( ref, sec, &amp;x, -dx, -dy,
  			&quot;expand&quot;, TRUE,
			NULL ) )
			return( -1 );
		if( vips_image_write( x, out ) ) {
			g_object_unref( x );
			return( -1 );
		}
		g_object_unref( x );

		out-&gt;Xoffset = -dx;
		out-&gt;Yoffset = -dy;

		return( 0 );
	}

	if( !(ovlap = build_lrstate( ref, sec, out, dx, dy, mwidth )) )
		return( -1 );

	if( vips_image_pipelinev( out,
		VIPS_DEMAND_STYLE_THINSTRIP, ovlap-&gt;ref, ovlap-&gt;sec, NULL ) )
		return( -1 );

	out-&gt;Xsize = ovlap-&gt;oarea.width;
	out-&gt;Ysize = ovlap-&gt;oarea.height;
	out-&gt;Xoffset = -dx;
	out-&gt;Yoffset = -dy;

	if( vips_image_generate( out,
		vips__start_merge, vips__merge_gen, vips__stop_merge, 
		ovlap, NULL ) )
		return( -1 );

	return ( 0 );
}

const char *
vips__get_mosaic_name( VipsImage *image )
{
	const char *name;

	if( vips_image_get_typeof( image, &quot;mosaic-name&quot; ) ) {
		if( vips_image_get_string( image, &quot;mosaic-name&quot;, &amp;name ) )
			return( NULL );
	}
	else 
		name = image-&gt;filename;

	return( name ); 
}

void
vips__add_mosaic_name( VipsImage *image )
{
	static int global_serial = 0;

	/* TODO(kleisauke): Could we call vips_image_temp_name instead?
	 */
	int serial = g_atomic_int_add( &amp;global_serial, 1 );

	char name[256];

	/* We must override any inherited name, so don't test for doesn't
	 * exist before setting.
	 */
	vips_snprintf( name, 256, &quot;mosaic-temp-%d&quot;, serial );
	vips_image_set_string( image, &quot;mosaic-name&quot;, name );
}

</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>image.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* vips image class
 * 
 * 4/2/11
 * 	- hacked up from various places
 * 6/6/13
 * 	- vips_image_write() didn't ref non-partial sources
 * 18/4/15
 * 	- add vips_image_copy_memory()
 * 25/11/15
 * 	- add vips_image_new_from_memory_copy()
 * 10/6/16
 * 	- vips_image_write() does not ref input for non-partial images
 * 29/10/16
 * 	- add vips_image_hasalpha()
 * 11/10/17
 * 	- more severing for vips_image_write()
 * 3/4/18
 * 	- better rules for hasalpha
 * 9/10/18
 * 	- fix up vips_image_dump(), it was still using ints not enums
 * 10/12/19
 * 	- add vips_image_new_from_source() / vips_image_write_to_target()
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/*
#define VIPS_DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#ifdef HAVE_UNISTD_H
#include &lt;unistd.h&gt;
#endif /*HAVE_UNISTD_H*/
#include &lt;ctype.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/internal.h&gt;
#include &lt;vips/debug.h&gt;

/**
 * SECTION: image
 * @short_description: the VIPS image class
 * @stability: Stable
 * @see_also: &lt;link linkend=&quot;libvips-header&quot;&gt;header&lt;/link&gt; 
 * &lt;link linkend=&quot;VipsRegion&quot;&gt;VipsRegion&lt;/link&gt; 
 * &lt;link linkend=&quot;libvips-generate&quot;&gt;generate&lt;/link&gt;
 * &lt;link linkend=&quot;VipsOperation&quot;&gt;VipsOperation&lt;/link&gt; 
 * @include: vips/vips.h
 *
 * The image class and associated types and macros.
 *
 * Images can be created from formatted files on disc, from C-style arrays on
 * disc, from formatted areas of memory, or from C-style arrays in memory. See
 * vips_image_new_from_file() and friends. 
 * Creating an image is fast. VIPS reads just enough of
 * the image to be able to get the various properties, such as width in
 * pixels. It delays reading any pixels until they are really needed.
 *
 * Once you have an image, you can get properties from it in the usual way. 
 * You can use projection functions, like vips_image_get_width() or 
 * g_object_get(), to get %GObject properties. 
 * 
 * VIPS images are three-dimensional arrays, the dimensions being width, 
 * height and bands. Each dimension can be up to 2 ** 31 pixels (or band 
 * elements). An image has a format, meaning the machine number type used 
 * to represent each value. VIPS supports 10 formats, from 8-bit unsigned 
 * integer up to 128-bit double complex, see vips_image_get_format(). 
 *
 * In VIPS, images are uninterpreted arrays, meaning that from the point of 
 * view of most operations, they are just large collections of numbers. 
 * There's no difference between an RGBA (RGB with alpha) image and a CMYK 
 * image, for example, they are both just four-band images. It's up to the 
 * user of the library to pass the right sort of image to each operation. 
 *
 * To take an example, VIPS has vips_Lab2XYZ(), an operation to transform 
 * an image from CIE LAB colour space to CIE XYZ space. It assumes the 
 * first three bands represent pixels in LAB colour space and returns an 
 * image where the first three bands are transformed to XYZ and any 
 * remaining bands are just copied. Pass it a RGB image by mistake and 
 * you'll just get nonsense.
 *
 * VIPS has a feature to help (a little) with this: it sets a 
 * #VipsInterpretation hint for each image (see 
 * vips_image_get_interpretation()); a hint which says how pixels should
 * be interpreted. For example, vips_Lab2XYZ() will set the
 * interpretation of the output image to #VIPS_INTERPRETATION_XYZ. A
 * few utility operations will also use interpretation as a guide. For
 * example, you can give vips_colourspace() an input image and a desired
 * colourspace and it will use the input's interpretation hint to apply
 * the best sequence of colourspace transforms to get to the desired space.
 *
 * Use things like vips_invert() to manipulate your images. When you are done,
 * you can write images to disc files (with vips_image_write_to_file()),
 * to formatted memory buffers (with vips_image_write_to_buffer()) and to
 * C-style memory arrays (with vips_image_write_to_memory().
 *
 * You can also write images to other images. Create, for example, a temporary
 * disc image with vips_image_new_temp_file(), then write your image to that
 * with vips_image_write(). You can create several other types of image and
 * write to them, see vips_image_new_memory(), for example. 
 *
 * See &lt;link linkend=&quot;VipsOperation&quot;&gt;operation&lt;/link&gt; for an introduction to
 * running operations on images, see &lt;link
 * linkend=&quot;libvips-header&quot;&gt;header&lt;/link&gt; for getting and setting image
 * metadata. See &lt;link linkend=&quot;VipsObject&quot;&gt;object&lt;/link&gt; for a discussion of
 * the lower levels. 
 */

/**
 * VIPS_MAGIC_INTEL:
 *
 * The first four bytes of a VIPS file in Intel byte ordering.
 */

/**
 * VIPS_MAGIC_SPARC:
 *
 * The first four bytes of a VIPS file in SPARC byte ordering.
 */

/** 
 * VipsAccess:
 * @VIPS_ACCESS_RANDOM: can read anywhere
 * @VIPS_ACCESS_SEQUENTIAL: top-to-bottom reading only, but with a small buffer
 *
 * The type of access an operation has to supply. See vips_tilecache()
 * and #VipsForeign. 
 *
 * @VIPS_ACCESS_RANDOM means requests can come in any order. 
 *
 * @VIPS_ACCESS_SEQUENTIAL means requests will be top-to-bottom, but with some
 * amount of buffering behind the read point for small non-local accesses. 
 */

/** 
 * VipsDemandStyle:
 * @VIPS_DEMAND_STYLE_SMALLTILE: demand in small (typically 64x64 pixel) tiles
 * @VIPS_DEMAND_STYLE_FATSTRIP: demand in fat (typically 10 pixel high) strips
 * @VIPS_DEMAND_STYLE_THINSTRIP: demand in thin (typically 1 pixel high) strips
 * @VIPS_DEMAND_STYLE_ANY: demand geometry does not matter
 *
 * See vips_image_pipelinev(). Operations can hint to the VIPS image IO 
 * system about the kind of demand geometry they prefer. 
 *
 * These demand styles are given below in order of increasing
 * restrictiveness.  When demanding output from a pipeline, 
 * vips_image_generate()
 * will use the most restrictive of the styles requested by the operations 
 * in the pipeline.
 *
 * #VIPS_DEMAND_STYLE_THINSTRIP --- This operation would like to output strips 
 * the width of the image and a few pels high. This is option suitable for 
 * point-to-point operations, such as those in the arithmetic package.
 *
 * This option is only efficient for cases where each output pel depends 
 * upon the pel in the corresponding position in the input image.
 *
 * #VIPS_DEMAND_STYLE_FATSTRIP --- This operation would like to output strips 
 * the width of the image and as high as possible. This option is suitable 
 * for area operations which do not violently transform coordinates, such 
 * as vips_conv(). 
 *
 * #VIPS_DEMAND_STYLE_SMALLTILE --- This is the most general demand format.
 * Output is demanded in small (around 100x100 pel) sections. This style works 
 * reasonably efficiently, even for bizzare operations like 45 degree rotate.
 *
 * #VIPS_DEMAND_STYLE_ANY --- This image is not being demand-read from a disc 
 * file (even indirectly) so any demand style is OK. It's used for things like
 * vips_black() where the pixels are calculated.
 *
 * See also: vips_image_pipelinev().
 */

/**
 * VipsInterpretation: 
 * @VIPS_INTERPRETATION_MULTIBAND: generic many-band image
 * @VIPS_INTERPRETATION_B_W: some kind of single-band image
 * @VIPS_INTERPRETATION_HISTOGRAM: a 1D image, eg. histogram or lookup table
 * @VIPS_INTERPRETATION_FOURIER: image is in fourier space
 * @VIPS_INTERPRETATION_XYZ: the first three bands are CIE XYZ 
 * @VIPS_INTERPRETATION_LAB: pixels are in CIE Lab space
 * @VIPS_INTERPRETATION_CMYK: the first four bands are in CMYK space
 * @VIPS_INTERPRETATION_LABQ: implies #VIPS_CODING_LABQ
 * @VIPS_INTERPRETATION_RGB: generic RGB space
 * @VIPS_INTERPRETATION_CMC: a uniform colourspace based on CMC(1:1)
 * @VIPS_INTERPRETATION_LCH: pixels are in CIE LCh space
 * @VIPS_INTERPRETATION_LABS: CIE LAB coded as three signed 16-bit values
 * @VIPS_INTERPRETATION_sRGB: pixels are sRGB
 * @VIPS_INTERPRETATION_HSV: pixels are HSV
 * @VIPS_INTERPRETATION_scRGB: pixels are scRGB
 * @VIPS_INTERPRETATION_YXY: pixels are CIE Yxy
 * @VIPS_INTERPRETATION_RGB16: generic 16-bit RGB
 * @VIPS_INTERPRETATION_GREY16: generic 16-bit mono
 * @VIPS_INTERPRETATION_MATRIX: a matrix
 *
 * How the values in an image should be interpreted. For example, a
 * three-band float image of type #VIPS_INTERPRETATION_LAB should have its 
 * pixels interpreted as coordinates in CIE Lab space.
 *
 * RGB and sRGB are treated in the same way. Use the colourspace functions if
 * you want some other behaviour.
 *
 * The gaps in numbering are historical and must be maintained. Allocate 
 * new numbers from the end.
 */

/**
 * VipsBandFormat: 
 * @VIPS_FORMAT_NOTSET: invalid setting
 * @VIPS_FORMAT_UCHAR: unsigned char format
 * @VIPS_FORMAT_CHAR: char format
 * @VIPS_FORMAT_USHORT: unsigned short format
 * @VIPS_FORMAT_SHORT: short format
 * @VIPS_FORMAT_UINT: unsigned int format
 * @VIPS_FORMAT_INT: int format
 * @VIPS_FORMAT_FLOAT: float format
 * @VIPS_FORMAT_COMPLEX: complex (two floats) format
 * @VIPS_FORMAT_DOUBLE: double float format
 * @VIPS_FORMAT_DPCOMPLEX: double complex (two double) format
 *
 * The format used for each band element. 
 *
 * Each corresponds to a native C type for the current machine. For example,
 * #VIPS_FORMAT_USHORT is &lt;type&gt;unsigned short&lt;/type&gt;.
 */

/**
 * VipsCoding: 
 * @VIPS_CODING_NONE: pixels are not coded
 * @VIPS_CODING_LABQ: pixels encode 3 float CIELAB values as 4 uchar
 * @VIPS_CODING_RAD: pixels encode 3 float RGB as 4 uchar (Radiance coding)
 *
 * How pixels are coded. 
 *
 * Normally, pixels are uncoded and can be manipulated as you would expect.
 * However some file formats code pixels for compression, and sometimes it's
 * useful to be able to manipulate images in the coded format.
 *
 * The gaps in the numbering are historical and must be maintained. Allocate 
 * new numbers from the end.
 */

/** 
 * VipsProgress:
 * @run: Time we have been running 
 * @eta: Estimated seconds of computation left 
 * @tpels: Number of pels we expect to calculate
 * @npels: Number of pels calculated so far
 * @percent: Percent complete
 * @start: Start time 
 *
 * A structure available to eval callbacks giving information on evaluation
 * progress. See #VipsImage::eval.
 */

/**
 * VipsImage:
 *
 * An image. These can represent an image on disc, a memory buffer, an image
 * in the process of being written to disc or a partially evaluated image
 * in memory.
 */

/**
 * VIPS_IMAGE_SIZEOF_ELEMENT:
 * @I: a #VipsImage
 *
 * Returns: sizeof() a band element.
 */

/**
 * VIPS_IMAGE_SIZEOF_PEL:
 * @I: a #VipsImage
 *
 * Returns: sizeof() a pixel.
 */

/**
 * VIPS_IMAGE_SIZEOF_LINE:
 * @I: a #VipsImage
 *
 * Returns: sizeof() a scanline of pixels.
 */

/**
 * VIPS_IMAGE_N_ELEMENTS:
 * @I: a #VipsImage
 *
 * Returns: The number of band elements in a scanline.
 */

/**
 * VIPS_IMAGE_N_PELS:
 * @I: a #VipsImage
 *
 * Returns: The number of pels in an image. A 64-bit unsigned int.
 */

/**
 * VIPS_IMAGE_ADDR:
 * @I: a #VipsImage
 * @X: x coordinate
 * @Y: y coordinate
 *
 * This macro returns a pointer to a pixel in an image, cast to a #VipsPel *. 
 * It only works for
 * images which are fully available in memory, so memory buffers and small
 * mapped images only.
 * 
 * If VIPS_DEBUG is defined, you get a version that checks bounds for you.
 *
 * See also: vips_image_wio_input(), vips_image_inplace(), VIPS_REGION_ADDR().
 *
 * Returns: The address of pixel (@X,@Y) in @I. 
 */

/**
 * VIPS_MATRIX:
 * @I: a #VipsImage
 * @X: x coordinate
 * @Y: y coordinate
 *
 * This macro returns a pointer to a pixel in an image, cast to a double*. The
 * image must have a single band, be #VIPS_FORMAT_DOUBLE and be 
 * fully available in memory, so memory buffers and small
 * mapped images only.
 * 
 * If VIPS_DEBUG is defined, you get a version that checks bounds and image
 * type for you.
 *
 * See also: vips_image_wio_input(), vips_image_inplace(), vips_check_matrix(). 
 *
 * Returns: The address of pixel (@X,@Y) in @I.
 */

/* Our signals. 
 */
enum {
	SIG_PREEVAL,		
	SIG_EVAL,		
	SIG_POSTEVAL,		
	SIG_WRITTEN,		
	SIG_INVALIDATE,		
	SIG_MINIMISE,		
	SIG_LAST
};

/* Progress feedback. Only really useful for testing, tbh.
 */
int vips__progress = 0;

/* A string giving the image size (in bytes of uncompressed image) above which 
 * we decompress to disc on open.  Can be eg. &quot;12m&quot; for 12 megabytes.
 */
char *vips__disc_threshold = NULL;

/* Minimise needs a lock.
 */
static GMutex *vips__minimise_lock = NULL;

static guint vips_image_signals[SIG_LAST] = { 0 };

G_DEFINE_TYPE( VipsImage, vips_image, VIPS_TYPE_OBJECT );

/**
 * vips_progress_set:
 * @progress: %TRUE to enable progress messages
 *
 * If set, vips will print messages about the progress of computation to
 * stdout. This can also be enabled with the --vips-progress option, or by
 * setting the environment variable VIPS_PROGRESS.
 */
void
vips_progress_set( gboolean progress )
{
	vips__progress = progress;
}

static void
vips_image_delete( VipsImage *image )
{
	if( image-&gt;delete_on_close ) {
		g_assert( image-&gt;delete_on_close_filename );

		VIPS_DEBUG_MSG( &quot;vips_image_delete: removing temp %s\n&quot;, 
				image-&gt;delete_on_close_filename );
		g_unlink( image-&gt;delete_on_close_filename );
		VIPS_FREE( image-&gt;delete_on_close_filename );
		image-&gt;delete_on_close = FALSE;
	}
}

static void
vips_image_finalize( GObject *gobject )
{
	VipsImage *image = VIPS_IMAGE( gobject );

	VIPS_DEBUG_MSG( &quot;vips_image_finalize: %p\n&quot;, gobject );

	/* Should be no regions defined on the image, since they all hold a
	 * ref to their host image.
	 */
	g_assert( !image-&gt;regions );

	/* Therefore there should be no windows.
	 */
	g_assert( !image-&gt;windows );

	/* Junk generate functions. 
	 */
	image-&gt;start_fn = NULL;
	image-&gt;generate_fn = NULL;
	image-&gt;stop_fn = NULL;
	image-&gt;client1 = NULL;
	image-&gt;client2 = NULL;

	/* No more upstream/downstream links.
	 */
	vips__link_break_all( image );

	if( image-&gt;time ) {
		VIPS_FREEF( g_timer_destroy, image-&gt;time-&gt;start );
		VIPS_FREE( image-&gt;time );
	}

	/* Free attached memory.
	 */
	if( image-&gt;data ) {
		if( image-&gt;dtype == VIPS_IMAGE_SETBUF ) {
			VIPS_DEBUG_MSG( &quot;vips_image_finalize: &quot;
				&quot;freeing buffer\n&quot; );
			vips_tracked_free( image-&gt;data );
			image-&gt;dtype = VIPS_IMAGE_NONE;
		}

		image-&gt;data = NULL;
	}

	/* Delete associated files.
	 */
	vips_image_delete( image );

	VIPS_FREEF( vips_g_mutex_free, image-&gt;sslock );

	VIPS_FREE( image-&gt;Hist );
	VIPS_FREEF( vips__gslist_gvalue_free, image-&gt;history_list );
	vips__meta_destroy( image );

	G_OBJECT_CLASS( vips_image_parent_class )-&gt;finalize( gobject );
}

static void
vips_image_dispose( GObject *gobject )
{
	VipsImage *image = VIPS_IMAGE( gobject );

	VIPS_DEBUG_MSG( &quot;vips_image_dispose: %p\n&quot;, gobject );

#ifdef DEBUG_LEAK
{
	VipsImagePixels *pixels = g_object_get_qdata( G_OBJECT( image ), 
		vips__image_pixels_quark ); 

	if( pixels &amp;&amp;
		pixels-&gt;tpels ) {
		int compute_percent = 100.0 * pixels-&gt;npels / pixels-&gt;tpels;

		if( compute_percent &gt; 100 ) 
			printf( &quot;vips_image_dispose: %s %s computed %d%%\n&quot;, 
				image-&gt;filename, 
				pixels-&gt;nickname, 
				compute_percent );
	}
}
#endif /*DEBUG_LEAK*/

	vips_object_preclose( VIPS_OBJECT( gobject ) );

	/* We have to junk the fd in dispose, since we run this for rewind and
	 * we must close and reopen the file when we switch from write to
	 * read.
	 */

	/* Any file mapping?
	 */
	if( image-&gt;baseaddr ) {
		/* MMAP file.
		 */
		VIPS_DEBUG_MSG( &quot;vips_image_dispose: unmapping file\n&quot; );

		vips__munmap( image-&gt;baseaddr, image-&gt;length );
		image-&gt;baseaddr = NULL;
		image-&gt;length = 0;

		/* This must have been a pointer to the mmap region, rather
		 * than a setbuf.
		 */
		image-&gt;data = NULL;
	}

	/* Is there a file descriptor?
	 */
	if( image-&gt;fd != -1 ) {
		VIPS_DEBUG_MSG( &quot;vips_image_dispose: closing output file\n&quot; );

		if( vips_tracked_close( image-&gt;fd ) == -1 ) 
			vips_error( &quot;VipsImage&quot;, 
				&quot;%s&quot;, _( &quot;unable to close fd&quot; ) );
		image-&gt;fd = -1;
	}

	G_OBJECT_CLASS( vips_image_parent_class )-&gt;dispose( gobject );
}

static VipsObject *
vips_image_new_from_file_object( const char *string )
{
	VipsImage *image;

	vips_check_init();

	/* We mustn't _build() the object here, so we can't just call
	 * vips_image_new_from_file().
	 */
	image = VIPS_IMAGE( g_object_new( VIPS_TYPE_IMAGE, NULL ) );
	g_object_set( image,
		&quot;filename&quot;, string,
		&quot;mode&quot;, &quot;r&quot;,
		NULL );

	return( VIPS_OBJECT( image ) );
}

static void
vips_image_to_string( VipsObject *object, VipsBuf *buf )
{
	VipsImage *image = VIPS_IMAGE( object );

	vips_buf_appends( buf, image-&gt;filename );
}

static int 
vips_image_write_object( VipsObject *object, const char *string )
{
	return( vips_image_write_to_file( VIPS_IMAGE( object ), string, 
		NULL ) );
}

static void *
print_field_fn( VipsImage *image, const char *field, GValue *value, void *a )
{
	VipsBuf *buf = (VipsBuf *) a;

	vips_buf_appendf( buf, &quot;%s: &quot;, field );
	vips_buf_appendgv( buf, value );
	vips_buf_appendf( buf, &quot;\n&quot; );

	return( NULL );
}

static void
vips_image_dump( VipsObject *object, VipsBuf *buf )
{
	VipsImage *image = VIPS_IMAGE( object );

	vips_buf_appendf( buf, 
		ngettext( 
			&quot;%dx%d %s, %d band, %s&quot;, 
			&quot;%dx%d %s, %d bands, %s&quot;, 
			vips_image_get_bands( image ) ),
		vips_image_get_width( image ),
		vips_image_get_height( image ),
		vips_enum_nick( VIPS_TYPE_BAND_FORMAT, 
			vips_image_get_format( image ) ),
		vips_image_get_bands( image ),
		vips_enum_nick( VIPS_TYPE_INTERPRETATION, 
			vips_image_get_interpretation( image ) ) );

	vips_buf_appendf( buf, &quot;, %s&quot;, 
		vips_enum_nick( VIPS_TYPE_IMAGE_TYPE, image-&gt;dtype ) );

	VIPS_OBJECT_CLASS( vips_image_parent_class )-&gt;dump( object, buf );

	vips_buf_appendf( buf, &quot;\n&quot; );

	(void) vips_image_map( image, print_field_fn, (void *) buf );

	vips_buf_appendf( buf, &quot;Hist: %s&quot;, vips_image_get_history( image ) );
}

static void
vips_image_summary( VipsObject *object, VipsBuf *buf )
{
	VipsImage *image = VIPS_IMAGE( object );
	const char *p;

	vips_buf_appendf( buf, &quot;%dx%d&quot;,
		vips_image_get_width( image ), vips_image_get_height( image ) );
	if( vips_image_get_coding( image ) == VIPS_CODING_NONE ) {
		vips_buf_appendf( buf, 
			ngettext( 
				&quot; %s, %d band, %s&quot;, 
				&quot; %s, %d bands, %s&quot;, 
				vips_image_get_bands( image ) ),
			vips_enum_nick( VIPS_TYPE_BAND_FORMAT, 
				vips_image_get_format( image ) ),
			vips_image_get_bands( image ),
			vips_enum_nick( VIPS_TYPE_INTERPRETATION, 
				vips_image_get_interpretation( image ) ) );
	}
	else {
		vips_buf_appendf( buf, &quot;, %s&quot;,
			vips_enum_nick( VIPS_TYPE_CODING, 
				vips_image_get_coding( image ) ) );
	}

	if( vips_image_get_typeof( image, VIPS_META_LOADER ) &amp;&amp;
		!vips_image_get_string( image, VIPS_META_LOADER, &amp;p ) ) 
		vips_buf_appendf( buf, &quot;, %s&quot;, p );

	VIPS_OBJECT_CLASS( vips_image_parent_class )-&gt;summary( object, buf );
}

static void *
vips_image_sanity_upstream( VipsImage *up, VipsImage *down, void *b )
{
	if( !g_slist_find( up-&gt;downstream, down ) ||
		!g_slist_find( down-&gt;upstream, up ) )
		return( up );

	return( NULL );
}

static void *
vips_image_sanity_downstream( VipsImage *down, VipsImage *up, void *b )
{
	return( vips_image_sanity_upstream( up, down, b ) );
}

static void
vips_image_sanity( VipsObject *object, VipsBuf *buf )
{
	VipsImage *image = VIPS_IMAGE( object );

	/* All 0 means im has been inited but never used.
	 */
	if( image-&gt;Xsize != 0 ||
		image-&gt;Ysize != 0 ||
		image-&gt;Bands != 0 ) {
		if( image-&gt;Xsize &lt;= 0 || 
			image-&gt;Ysize &lt;= 0 || 
			image-&gt;Bands &lt;= 0 ) 
			vips_buf_appends( buf, &quot;bad dimensions\n&quot; );
		if( image-&gt;BandFmt &lt; -1 || 
			image-&gt;BandFmt &gt; VIPS_FORMAT_DPCOMPLEX ||
			(image-&gt;Coding != -1 &amp;&amp;
				image-&gt;Coding != VIPS_CODING_NONE &amp;&amp; 
				image-&gt;Coding != VIPS_CODING_LABQ &amp;&amp;
				image-&gt;Coding != VIPS_CODING_RAD) ||
			image-&gt;Type &gt;= VIPS_INTERPRETATION_LAST ||
			image-&gt;dtype &gt; VIPS_IMAGE_PARTIAL || 
			image-&gt;dhint &gt; VIPS_DEMAND_STYLE_ANY ) 
			vips_buf_appends( buf, &quot;bad enum\n&quot; );
		if( image-&gt;Xres &lt; 0 || 
			image-&gt;Yres &lt; 0 ) 
			vips_buf_appends( buf, &quot;bad resolution\n&quot; );
	}

	/* Must lock around inter-image links.
	 */
	g_mutex_lock( vips__global_lock );

	if( vips_slist_map2( image-&gt;upstream, 
		(VipsSListMap2Fn) vips_image_sanity_upstream, image, NULL ) )
		vips_buf_appends( buf, &quot;upstream broken\n&quot; );
	if( vips_slist_map2( image-&gt;downstream, 
		(VipsSListMap2Fn) vips_image_sanity_downstream, image, NULL ) )
		vips_buf_appends( buf, &quot;downstream broken\n&quot; );

	g_mutex_unlock( vips__global_lock );

	VIPS_OBJECT_CLASS( vips_image_parent_class )-&gt;sanity( object, buf );
}

static void
vips_image_rewind( VipsObject *object )
{
	VipsImage *image = VIPS_IMAGE( object );
	char *filename;
	char *mode;

	/* This triggers a dispose. Copy filename/mode across the dispose.
	 */
	filename = g_strdup( vips_image_get_filename( image ) );
	mode = g_strdup( vips_image_get_mode( image ) );

	VIPS_OBJECT_CLASS( vips_image_parent_class )-&gt;rewind( object );

	g_assert( image-&gt;filename == NULL );
	g_assert( image-&gt;mode == NULL );

	image-&gt;filename = filename;
	image-&gt;mode = mode;
}

/* Delayed save.
 */

/* From &quot;written&quot; callback: save to image-&gt;filename using VipsForeign.
 */
static void
vips_image_save_cb( VipsImage *image, int *result, void *data )
{
	if( vips_foreign_save( image, image-&gt;filename, NULL ) )
		*result = -1;
}

/* Progress feedback. 
 */

static void
vips_image_preeval_cb( VipsImage *image, VipsProgress *progress, int *last )
{
	int tile_width; 
	int tile_height; 
	int n_lines;

	*last = -1;

	vips_get_tile_size( image, 
		&amp;tile_width, &amp;tile_height, &amp;n_lines );
	printf( _( &quot;%s %s: %d x %d pixels, %d threads, %d x %d tiles, &quot;
		&quot;%d lines in buffer&quot; ),
		vips_get_prgname(), image-&gt;filename,
		image-&gt;Xsize, image-&gt;Ysize,
		vips_concurrency_get(),
		tile_width, tile_height, n_lines );
	printf( &quot;\n&quot; );
}

static void
vips_image_eval_cb( VipsImage *image, VipsProgress *progress, int *last )
{
	if( progress-&gt;percent != *last ) {
		printf( _( &quot;%s %s: %d%% complete&quot; ), 
			vips_get_prgname(), image-&gt;filename, 
			progress-&gt;percent );
		printf( &quot;\r&quot; ); 
		fflush( stdout );

		*last = progress-&gt;percent;

		/* Needs DEBUG in region.c
		vips_region_dump_all();
		 */
	}
}

static void
vips_image_posteval_cb( VipsImage *image, VipsProgress *progress, void *data )
{
	/* Spaces at end help to erase the %complete message we overwrite.
	 */
	printf( _( &quot;%s %s: done in %.3gs          \n&quot; ), 
		vips_get_prgname(), image-&gt;filename, 
		g_timer_elapsed( progress-&gt;start, NULL ) );
}

/* Attach progress feedback, if required.
 */
static void
vips_image_add_progress( VipsImage *image )
{
	if( vips__progress || 
		g_getenv( &quot;VIPS_PROGRESS&quot; )
#if ENABLE_DEPRECATED
		|| g_getenv( &quot;IM_PROGRESS&quot; )
#endif
		) {

		/* Keep the %complete we displayed last time here.
		 */
		int *last = VIPS_NEW( image, int );

		g_signal_connect( image, &quot;preeval&quot;, 
			G_CALLBACK( vips_image_preeval_cb ), last );
		g_signal_connect( image, &quot;eval&quot;, 
			G_CALLBACK( vips_image_eval_cb ), last );
		g_signal_connect( image, &quot;posteval&quot;, 
			G_CALLBACK( vips_image_posteval_cb ), NULL );

		vips_image_set_progress( image, TRUE );
	}
}

/* We have to do a lot of work in _build() so we can work with the stuff in
 * /deprecated to support the vips7 API. We could get rid of most of this
 * stuff if we were vips8-only.
 */

static int
vips_image_build( VipsObject *object )
{
	VipsImage *image = VIPS_IMAGE( object );
	const char *filename = image-&gt;filename;
	const char *mode = image-&gt;mode;

	guint32 magic;
	guint64 sizeof_image;

	VIPS_DEBUG_MSG( &quot;vips_image_build: %p\n&quot;, image );

	if( VIPS_OBJECT_CLASS( vips_image_parent_class )-&gt;build( object ) )
		return( -1 );

	/* Parse the mode string.
	 */
	switch( mode[0] ) {
        case 'v':
		/* Used by 'r' for native open of vips, see below. Also by
		 * vips_image_rewind_output().
		 */
		if( vips_image_open_input( image ) )
			return( -1 );

		break;

        case 'r':
		if( (magic = vips__file_magic( filename )) ) {
			/* We may need to byteswap.
			 */
			if( GUINT_FROM_BE( magic ) == image-&gt;magic ) {
				/* Native open.
				 */
				if( vips_image_open_input( image ) )
					return( -1 );
			}
			else {
				VipsImage *t; 
				VipsImage *t2;

				/* Open the image in t, then byteswap to this
				 * image.
				 */
				if( !(t = vips_image_new_mode( filename, 
					&quot;v&quot; )) )
					return( -1 );

				if( vips_byteswap( t, &amp;t2, NULL ) ) {
					g_object_unref( t );
					return( -1 );
				}
				g_object_unref( t );

				image-&gt;dtype = VIPS_IMAGE_PARTIAL;
				if( vips_image_write( t2, image ) ) {
					g_object_unref( t2 );
					return( -1 );
				}
				g_object_unref( t2 );
			}
		}
		else {
			VipsImage *t;

			if( mode[1] == 's' ) {
				if( vips_foreign_load( filename, &amp;t, 
					&quot;access&quot;, VIPS_ACCESS_SEQUENTIAL,
					NULL ) )
					return( -1 );
			}
			else {
				if( vips_foreign_load( filename, &amp;t, NULL ) )
					return( -1 );
			}

			image-&gt;dtype = VIPS_IMAGE_PARTIAL;
			if( vips_image_write( t, image ) ) {
				g_object_unref( t );
				return( -1 );
			}
			g_object_unref( t );
		}

        	break;

	case 'w':
{
		const char *file_op;

		/* Make sure the vips saver is there ... strange things will
		 * happen if this type is renamed or removed.
		 */
		g_assert( g_type_from_name( &quot;VipsForeignSaveVips&quot; ) );

		if( !(file_op = vips_foreign_find_save( filename )) )
			return( -1 );

		/* If this is the vips saver, just save directly ourselves.
		 * Otherwise save with VipsForeign when the image has been 
		 * written to.
		 */
		if( vips_isprefix( &quot;VipsForeignSaveVips&quot;, file_op ) )
			image-&gt;dtype = VIPS_IMAGE_OPENOUT;
		else {
			image-&gt;dtype = VIPS_IMAGE_PARTIAL;
			g_signal_connect( image, &quot;written&quot;, 
				G_CALLBACK( vips_image_save_cb ), 
				NULL );
		}
}
        	break;

        case 't':
		image-&gt;dtype = VIPS_IMAGE_SETBUF;
		image-&gt;dhint = VIPS_DEMAND_STYLE_ANY;
                break;

        case 'p':
		image-&gt;dtype = VIPS_IMAGE_PARTIAL;
                break;

	case 'a':
		if( (image-&gt;fd = vips__open_image_read( filename )) == -1 ) 
			return( -1 );
		image-&gt;dtype = VIPS_IMAGE_OPENIN;
		image-&gt;dhint = VIPS_DEMAND_STYLE_THINSTRIP;

		if( image-&gt;Bands == 1 )
			image-&gt;Type = VIPS_INTERPRETATION_B_W;
		else if( image-&gt;Bands == 3 )
			image-&gt;Type = VIPS_INTERPRETATION_sRGB;
		else 
			image-&gt;Type = VIPS_INTERPRETATION_MULTIBAND;

		/* Read the real file length and check against what we think 
		 * the size should be.
		 */
		if( (image-&gt;file_length = vips_file_length( image-&gt;fd )) == -1 )
			return( -1 );

		/* Very common, so a special message.
		 */
		sizeof_image = VIPS_IMAGE_SIZEOF_IMAGE( image ) + 
			image-&gt;sizeof_header;
		if( image-&gt;file_length &lt; sizeof_image ) {
			vips_error( &quot;VipsImage&quot;, 
				_( &quot;unable to open \&quot;%s\&quot;, file too short&quot; ), 
				image-&gt;filename );
			return( -1 );
		}

		/* Just weird. Only print a warning for this, since we should
		 * still be able to process it without coredumps.
		 */
		if( image-&gt;file_length &gt; sizeof_image ) 
			g_warning( _( &quot;%s is longer than expected&quot; ),
				image-&gt;filename );
		break;

	case 'm':
		if( image-&gt;Bands == 1 )
			image-&gt;Type = VIPS_INTERPRETATION_B_W;
		else if( image-&gt;Bands == 3 )
			image-&gt;Type = VIPS_INTERPRETATION_sRGB;
		else 
			image-&gt;Type = VIPS_INTERPRETATION_MULTIBAND;

		image-&gt;dtype = VIPS_IMAGE_SETBUF_FOREIGN;
		image-&gt;dhint = VIPS_DEMAND_STYLE_ANY;

		break;

	default:
		vips_error( &quot;VipsImage&quot;, _( &quot;bad mode \&quot;%s\&quot;&quot; ), mode );

		return( -1 );
        }

	vips_image_add_progress( image );

	return( 0 );
}

static void *
vips_image_real_invalidate_cb( VipsRegion *reg, void *a, void *b )
{
	vips_region_invalidate( reg );

	return( NULL );
}

static void 
vips_image_real_invalidate( VipsImage *image, void *data )
{
	VIPS_DEBUG_MSG( &quot;vips_image_real_invalidate: %p\n&quot;, image );

	VIPS_GATE_START( &quot;vips_image_real_invalidate: wait&quot; );

	g_mutex_lock( image-&gt;sslock );

	VIPS_GATE_STOP( &quot;vips_image_real_invalidate: wait&quot; );

	(void) vips_slist_map2( image-&gt;regions,
		(VipsSListMap2Fn) vips_image_real_invalidate_cb, NULL, NULL );

	g_mutex_unlock( image-&gt;sslock );
}

static void 
vips_image_real_minimise( VipsImage *image, void *data )
{
	VIPS_DEBUG_MSG( &quot;vips_image_real_minimise: %p\n&quot;, image );
}

static void 
vips_image_real_written( VipsImage *image, int *result, void *data )
{
	VIPS_DEBUG_MSG( &quot;vips_image_real_written: %p\n&quot;, image );

	/* For vips image write, append the xml after the data.
	 */
	if( image-&gt;dtype == VIPS_IMAGE_OPENOUT &amp;&amp;
		vips__writehist( image ) ) 
		*result = -1;
}

static void
vips_image_class_init( VipsImageClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );

	VIPS_DEBUG_MSG( &quot;vips_image_class_init:\n&quot; );

	/* We must have threads set up before we can process.
<A NAME="0"></A>	 */
	vips_check_init(); 

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match27985-0.html#0',2,'match27985-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	gobject_class-&gt;finalize = vips_image_finalize;
	gobject_class-&gt;dispose = vips_image_dispose;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	vobject_class-&gt;new_from_string = vips_image_new_from_file_object;
	vobject_class-&gt;to_string = vips_image_to_string;
	vobject_class-&gt;output_needs_arg = TRUE;
	vobject_class-&gt;output_to_arg = vips_image_write_object;

	vobject_class-&gt;nickname = &quot;image&quot;;
	vobject_class-&gt;description = _( &quot;image class&quot; );

	vobject_class-&gt;dump = vips_image_dump;
	vobject_class-&gt;summary = vips_image_summary;
	vobject_class-&gt;sanity = vips_image_sanity;
	vobject_class-&gt;rewind = vips_image_rewind;</B></FONT>
	vobject_class-&gt;build = vips_image_build;

	class-&gt;invalidate = vips_image_real_invalidate;
	class-&gt;written = vips_image_real_written;
	class-&gt;minimise = vips_image_real_minimise;

	/* Create properties.
	 */

	/* It'd be good to have these as set once at construct time, but we
	 * can't :-( 
	 *
	 * For example, a &quot;p&quot; image might be made with vips_image_new() and
	 * constructed, then passed to vips_copy() of whatever to be written to.
	 * That operation will then need to set width/height etc.
	 *
	 * We can't set_once either, since vips_copy() etc. need to update
	 * xoffset and friends on the way through.
	 */

	VIPS_ARG_INT( class, &quot;width&quot;, 2, 
		_( &quot;Width&quot; ), 
		_( &quot;Image width in pixels&quot; ),
		VIPS_ARGUMENT_SET_ALWAYS,
		G_STRUCT_OFFSET( VipsImage, Xsize ),
		1, VIPS_MAX_COORD, 1 );

	VIPS_ARG_INT( class, &quot;height&quot;, 3, 
		_( &quot;Height&quot; ), 
		_( &quot;Image height in pixels&quot; ),
		VIPS_ARGUMENT_SET_ALWAYS,
		G_STRUCT_OFFSET( VipsImage, Ysize ),
		1, VIPS_MAX_COORD, 1 );

	VIPS_ARG_INT( class, &quot;bands&quot;, 4, 
		_( &quot;Bands&quot; ), 
		_( &quot;Number of bands in image&quot; ),
		VIPS_ARGUMENT_SET_ALWAYS,
		G_STRUCT_OFFSET( VipsImage, Bands ),
		1, VIPS_MAX_COORD, 1 );

	VIPS_ARG_ENUM( class, &quot;format&quot;, 5, 
		_( &quot;Format&quot; ), 
		_( &quot;Pixel format in image&quot; ),
		VIPS_ARGUMENT_SET_ALWAYS,
		G_STRUCT_OFFSET( VipsImage, BandFmt ),
		VIPS_TYPE_BAND_FORMAT, VIPS_FORMAT_UCHAR ); 

	VIPS_ARG_ENUM( class, &quot;coding&quot;, 6, 
		_( &quot;Coding&quot; ), 
		_( &quot;Pixel coding&quot; ),
		VIPS_ARGUMENT_SET_ALWAYS,
		G_STRUCT_OFFSET( VipsImage, Coding ),
		VIPS_TYPE_CODING, VIPS_CODING_NONE ); 

	VIPS_ARG_ENUM( class, &quot;interpretation&quot;, 7, 
		_( &quot;Interpretation&quot; ), 
		_( &quot;Pixel interpretation&quot; ),
		VIPS_ARGUMENT_SET_ALWAYS,
		G_STRUCT_OFFSET( VipsImage, Type ),
		VIPS_TYPE_INTERPRETATION, VIPS_INTERPRETATION_MULTIBAND ); 

	VIPS_ARG_DOUBLE( class, &quot;xres&quot;, 8, 
		_( &quot;Xres&quot; ), 
		_( &quot;Horizontal resolution in pixels/mm&quot; ),
		VIPS_ARGUMENT_SET_ALWAYS,
		G_STRUCT_OFFSET( VipsImage, Xres ),
		-0.0, 1000000, 0 );

	VIPS_ARG_DOUBLE( class, &quot;yres&quot;, 9, 
		_( &quot;Yres&quot; ), 
		_( &quot;Vertical resolution in pixels/mm&quot; ),
		VIPS_ARGUMENT_SET_ALWAYS,
		G_STRUCT_OFFSET( VipsImage, Yres ),
		-0.0, 1000000, 0 );

	VIPS_ARG_INT( class, &quot;xoffset&quot;, 10, 
		_( &quot;Xoffset&quot; ), 
		_( &quot;Horizontal offset of origin&quot; ),
		VIPS_ARGUMENT_SET_ALWAYS,
		G_STRUCT_OFFSET( VipsImage, Xoffset ),
		-VIPS_MAX_COORD, VIPS_MAX_COORD, 0 );

	VIPS_ARG_INT( class, &quot;yoffset&quot;, 11, 
		_( &quot;Yoffset&quot; ), 
		_( &quot;Vertical offset of origin&quot; ),
		VIPS_ARGUMENT_SET_ALWAYS,
		G_STRUCT_OFFSET( VipsImage, Yoffset ),
		-VIPS_MAX_COORD, VIPS_MAX_COORD, 0 );

	VIPS_ARG_STRING( class, &quot;filename&quot;, 12, 
		_( &quot;Filename&quot; ),
		_( &quot;Image filename&quot; ),
		VIPS_ARGUMENT_SET_ONCE | VIPS_ARGUMENT_CONSTRUCT, 
		G_STRUCT_OFFSET( VipsImage, filename ),
		NULL );

	VIPS_ARG_STRING( class, &quot;mode&quot;, 13, 
		_( &quot;Mode&quot; ),
		_( &quot;Open mode&quot; ),
		VIPS_ARGUMENT_SET_ONCE | VIPS_ARGUMENT_CONSTRUCT, 
		G_STRUCT_OFFSET( VipsImage, mode ),
		&quot;p&quot; );

	VIPS_ARG_BOOL( class, &quot;kill&quot;, 14, 
		_( &quot;Kill&quot; ),
		_( &quot;Block evaluation on this image&quot; ),
		VIPS_ARGUMENT_SET_ALWAYS, 
		G_STRUCT_OFFSET( VipsImage, kill ),
		FALSE );

	VIPS_ARG_ENUM( class, &quot;demand&quot;, 15, 
		_( &quot;Demand style&quot; ), 
		_( &quot;Preferred demand style for this image&quot; ),
		VIPS_ARGUMENT_CONSTRUCT,
		G_STRUCT_OFFSET( VipsImage, dhint ),
		VIPS_TYPE_DEMAND_STYLE, VIPS_DEMAND_STYLE_SMALLTILE );

	VIPS_ARG_UINT64( class, &quot;sizeof_header&quot;, 16, 
		_( &quot;Size of header&quot; ), 
		_( &quot;Offset in bytes from start of file&quot; ),
		VIPS_ARGUMENT_SET_ONCE | VIPS_ARGUMENT_CONSTRUCT, 
		G_STRUCT_OFFSET( VipsImage, sizeof_header ),
		0, 1000000000, VIPS_SIZEOF_HEADER );

	VIPS_ARG_POINTER( class, &quot;foreign_buffer&quot;, 17, 
		_( &quot;Foreign buffer&quot; ),
		_( &quot;Pointer to foreign pixels&quot; ),
		VIPS_ARGUMENT_SET_ONCE | VIPS_ARGUMENT_CONSTRUCT, 
		G_STRUCT_OFFSET( VipsImage, data ) );

	/* Create signals.
	 */

	/**
	 * VipsImage::preeval:
	 * @image: the image to be calculated
	 * @progress: #VipsProgress for this image
	 *
	 * The ::preeval signal is emitted once before computation of @image
	 * starts. It's a good place to set up evaluation feedback.
	 *
	 * Use vips_image_set_progress() to turn on progress reporting for an
	 * image. 
	 */
	vips_image_signals[SIG_PREEVAL] = g_signal_new( &quot;preeval&quot;,
		G_TYPE_FROM_CLASS( class ),
		G_SIGNAL_RUN_LAST,
		G_STRUCT_OFFSET( VipsImageClass, preeval ), 
		NULL, NULL,
		g_cclosure_marshal_VOID__POINTER,
		G_TYPE_NONE, 1,
		G_TYPE_POINTER );

	/**
	 * VipsImage::eval:
	 * @image: the image being calculated
	 * @progress: #VipsProgress for this image
	 *
	 * The ::eval signal is emitted once per work unit (typically a 128 x
	 * 128 area of pixels) during image computation. 
	 *
	 * You can use this signal to update user-interfaces with progress
	 * feedback. Beware of updating too frequently: you will usually
	 * need some throttling mechanism.
	 *
	 * Use vips_image_set_progress() to turn on progress reporting for an
	 * image. 
	 */
	vips_image_signals[SIG_EVAL] = g_signal_new( &quot;eval&quot;,
		G_TYPE_FROM_CLASS( class ),
		G_SIGNAL_RUN_LAST,
		G_STRUCT_OFFSET( VipsImageClass, eval ), 
		NULL, NULL,
		g_cclosure_marshal_VOID__POINTER,
		G_TYPE_NONE, 1,
		G_TYPE_POINTER );

	/**
	 * VipsImage::posteval:
	 * @image: the image that was calculated
	 * @progress: #VipsProgress for this image
	 *
	 * The ::posteval signal is emitted once at the end of the computation 
	 * of @image. It's a good place to shut down evaluation feedback.
	 *
	 * Use vips_image_set_progress() to turn on progress reporting for an
	 * image. 
	 */
	vips_image_signals[SIG_POSTEVAL] = g_signal_new( &quot;posteval&quot;,
		G_TYPE_FROM_CLASS( class ),
		G_SIGNAL_RUN_LAST,
		G_STRUCT_OFFSET( VipsImageClass, posteval ), 
		NULL, NULL,
		g_cclosure_marshal_VOID__POINTER,
		G_TYPE_NONE, 1,
		G_TYPE_POINTER );

	/**
	 * VipsImage::written:
	 * @image: the image that was calculated
	 * @result: set to non-zero to indicate error
	 *
	 * The ::written signal is emitted just after an image has been 
	 * written to. It is
	 * used by vips to implement things like write to foreign file
	 * formats. 
	 */
	vips_image_signals[SIG_WRITTEN] = g_signal_new( &quot;written&quot;,
		G_TYPE_FROM_CLASS( class ),
		G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
		G_STRUCT_OFFSET( VipsImageClass, written ), 
		NULL, NULL,
		g_cclosure_marshal_VOID__POINTER,
		G_TYPE_NONE, 1,
		G_TYPE_POINTER );

	/**
	 * VipsImage::invalidate:
	 * @image: the image that has changed
	 *
	 * The ::invalidate signal is emitted when an image or one of it's
	 * upstream data sources has been destructively modified. See
	 * vips_image_invalidate_all().
	 */
	vips_image_signals[SIG_INVALIDATE] = g_signal_new( &quot;invalidate&quot;,
		G_TYPE_FROM_CLASS( class ),
		G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
		G_STRUCT_OFFSET( VipsImageClass, invalidate ), 
		NULL, NULL,
		g_cclosure_marshal_VOID__VOID,
		G_TYPE_NONE, 0 );

	/**
	 * VipsImage::minimise:
	 * @image: the image that is being minimised
	 *
	 * The ::minimise signal is emitted when an image has been asked to
	 * minimise memory usage. All non-essential caches are dropped. 
	 * See vips_image_minimise_all().
	 */
	vips_image_signals[SIG_MINIMISE] = g_signal_new( &quot;minimise&quot;,
		G_TYPE_FROM_CLASS( class ),
		G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
		G_STRUCT_OFFSET( VipsImageClass, minimise ), 
		NULL, NULL,
		g_cclosure_marshal_VOID__VOID,
		G_TYPE_NONE, 0 );

	vips__minimise_lock = vips_g_mutex_new();
}

static void
vips_image_init( VipsImage *image )
{
	VIPS_DEBUG_MSG( &quot;vips_image_init: %p\n&quot;, image );

	/* Default to native order.
	 */
	image-&gt;magic = vips_amiMSBfirst() ? VIPS_MAGIC_SPARC : VIPS_MAGIC_INTEL;

	image-&gt;Xsize = 1;
	image-&gt;Ysize = 1;
	image-&gt;Bands = 1;

	image-&gt;Xres = 1.0;
	image-&gt;Yres = 1.0;

	image-&gt;fd = -1;			/* since 0 is stdout */
	image-&gt;sslock = vips_g_mutex_new();

	image-&gt;sizeof_header = VIPS_SIZEOF_HEADER;

	image-&gt;mode = g_strdup( &quot;p&quot; );

#ifdef DEBUG_LEAK
	g_object_set_qdata_full( G_OBJECT( image ), vips__image_pixels_quark, 
		g_new0( VipsImagePixels, 1 ), (GDestroyNotify) g_free ); 
#endif /*DEBUG_LEAK*/
}

int
vips_image_written( VipsImage *image )
{
	int result;

	VIPS_DEBUG_MSG( &quot;vips_image_written: %p\n&quot;, image );

	result = 0;
	g_signal_emit( image, vips_image_signals[SIG_WRITTEN], 0, &amp;result );

	return( result );
}

void
vips_image_invalidate( VipsImage *image )
{
	VIPS_DEBUG_MSG( &quot;vips_image_invalidate: %p\n&quot;, image );

	g_signal_emit( image, vips_image_signals[SIG_INVALIDATE], 0 );
}

static void *
vips_image_invalidate_all_cb( VipsImage *image, void *a, void *b )
{
	vips_image_invalidate( image );

	return( NULL );
}

/**
 * vips_image_invalidate_all: (method)
 * @image: #VipsImage to invalidate
 *
 * Invalidate all pixel caches on @image and any downstream images, that
 * is, images which depend on this image. Additionally, all operations which
 * depend upon this image are dropped from the VIPS operation cache. 
 *
 * You should call this function after
 * destructively modifying an image with something like vips_draw_circle().
 *
 * The #VipsImage::invalidate signal is emitted for all invalidated images.
 *
 * See also: vips_region_invalidate().
 */
void
vips_image_invalidate_all( VipsImage *image )
{
	VIPS_DEBUG_MSG( &quot;vips_image_invalidate_all: %p\n&quot;, image );

	(void) vips__link_map( image, FALSE,
		(VipsSListMap2Fn) vips_image_invalidate_all_cb, NULL, NULL );
}

void
vips_image_minimise( VipsImage *image )
{
	VIPS_DEBUG_MSG( &quot;vips_image_minimise: %p\n&quot;, image );

	g_signal_emit( image, vips_image_signals[SIG_MINIMISE], 0 );
}

static void *
vips_image_minimise_all_cb( VipsImage *image, void *a, void *b )
{
	vips_image_minimise( image );

	return( NULL );
}

/**
 * vips_image_minimise_all: (method)
 * @image: #VipsImage to minimise
 *
 * Minimise memory use on this image and any upstream images, that is, images
 * which this image depends upon. This function is called automatically at the
 * end of a computation, but it might be useful to call at other times. 
 *
 * The #VipsImage::minimise signal is emitted for all minimised images.
 */
void 
vips_image_minimise_all( VipsImage *image )
{
	/* Minimisation will modify things like sources, so we can't run it
	 * from many threads.
	 */
	g_mutex_lock( vips__minimise_lock );

	(void) vips__link_map( image, TRUE,
		(VipsSListMap2Fn) vips_image_minimise_all_cb, NULL, NULL );

	g_mutex_unlock( vips__minimise_lock );
}

/**
 * vips_image_is_sequential: (method)
 * @image: #VipsImage to minimise
 *
 * TRUE if any of the images upstream from @image were opened in sequential
 * mode. Some operations change behaviour slightly in sequential mode to
 * optimize memory behaviour.
 *
 * Returns: %TRUE if @image is in sequential mode.
 */
gboolean
vips_image_is_sequential( VipsImage *image )
{
	return( vips_image_get_typeof( image, VIPS_META_SEQUENTIAL ) );
}

/* Attach a new time struct, if necessary, and reset it.
 */
static int
vips_progress_add( VipsImage *image )
{
	VipsProgress *progress;

	VIPS_DEBUG_MSG( &quot;vips_progress_add: %p\n&quot;, image );

	if( !(progress = image-&gt;time) ) {
		if( !(image-&gt;time = VIPS_NEW( NULL, VipsProgress )) )
			return( -1 );
		progress = image-&gt;time;

		progress-&gt;im = image;
		progress-&gt;start = NULL;
	}

	if( !progress-&gt;start )
		progress-&gt;start = g_timer_new();

	g_timer_start( progress-&gt;start );
	progress-&gt;run = 0;
	progress-&gt;eta = 0;
	progress-&gt;tpels = VIPS_IMAGE_N_PELS( image );
	progress-&gt;npels = 0;
	progress-&gt;percent = 0;

	return( 0 );
}

static void
vips_progress_update( VipsProgress *progress, guint64 processed )
{
	float prop;

	VIPS_DEBUG_MSG( &quot;vips_progress_update: %p\n&quot;, progress );

	g_assert( progress );

	progress-&gt;run = g_timer_elapsed( progress-&gt;start, NULL );
	progress-&gt;npels = processed;
	prop = (float) progress-&gt;npels / (float) progress-&gt;tpels;
	progress-&gt;percent = 100 * prop;

	/* Don't estimate eta until we are 10% in.
	 */
	if( prop &gt; 0.1 ) 
		progress-&gt;eta = (1.0 / prop) * progress-&gt;run - progress-&gt;run;
}

void
vips_image_preeval( VipsImage *image )
{
	if( image-&gt;progress_signal ) {
		VIPS_DEBUG_MSG( &quot;vips_image_preeval: %p\n&quot;, image );

		g_assert( vips_object_sanity( 
			VIPS_OBJECT( image-&gt;progress_signal ) ) );

		(void) vips_progress_add( image );

		/* For vips7 compat, we also have to make sure -&gt;time on the
		 * image that was originally marked with 
		 * vips_image_set_progress() is valid.
		 */
		(void) vips_progress_add( image-&gt;progress_signal );

		if( !vips_image_get_typeof( image, &quot;hide-progress&quot; ) )
			g_signal_emit( image-&gt;progress_signal, 
				vips_image_signals[SIG_PREEVAL], 0, 
				image-&gt;time );
	}
}

/* Updated the number of pixels that have been processed.
 */
void
vips_image_eval( VipsImage *image, guint64 processed )
{
	if( image-&gt;progress_signal &amp;&amp;
		image-&gt;time ) {
		VIPS_DEBUG_MSG( &quot;vips_image_eval: %p\n&quot;, image );

		g_assert( vips_object_sanity( 
			VIPS_OBJECT( image-&gt;progress_signal ) ) );

		vips_progress_update( image-&gt;time, processed );

		/* For vips7 compat, update the -&gt;time on the signalling image
		 * too, even though it may have a different width/height to
		 * the image we are actually generating.
		 */
		if( image-&gt;progress_signal-&gt;time != image-&gt;time )
			vips_progress_update( image-&gt;progress_signal-&gt;time, 
				processed );

		if( !vips_image_get_typeof( image, &quot;hide-progress&quot; ) )
			g_signal_emit( image-&gt;progress_signal, 
				vips_image_signals[SIG_EVAL], 0, 
				image-&gt;time );
	}
}

void
vips_image_posteval( VipsImage *image )
{
	if( image-&gt;progress_signal &amp;&amp;
		image-&gt;progress_signal-&gt;time ) { 
		VIPS_DEBUG_MSG( &quot;vips_image_posteval: %p\n&quot;, image );

		g_assert( vips_object_sanity( 
			VIPS_OBJECT( image-&gt;progress_signal ) ) );

		if( !vips_image_get_typeof( image, &quot;hide-progress&quot; ) )
			g_signal_emit( image-&gt;progress_signal, 
				vips_image_signals[SIG_POSTEVAL], 0, 
				image-&gt;time );
	}
}

/**
 * vips_image_set_progress: (method)
 * @image: image to signal progress on
 * @progress: turn progress reporting on or off
 *
 * vips signals evaluation progress via the #VipsImage::preeval, 
 * #VipsImage::eval and #VipsImage::posteval
 * signals. Progress is signalled on the most-downstream image for which
 * vips_image_set_progress() was called.
 */
void
vips_image_set_progress( VipsImage *image, gboolean progress )
{
	if( progress &amp;&amp; 
		!image-&gt;progress_signal ) {
		VIPS_DEBUG_MSG( &quot;vips_image_set_progress: %p %s\n&quot;, 
			image, image-&gt;filename );
		image-&gt;progress_signal = image;
	}
	else if( !progress )
		image-&gt;progress_signal = NULL;
}

/**
 * vips_image_iskilled: (method)
 * @image: image to test
 *
 * If @image has been killed (see vips_image_set_kill()), set an error message,
 * clear the #VipsImage.kill flag and return %TRUE. Otherwise return %FALSE.
 *
 * Handy for loops which need to run sets of threads which can fail. 
 *
 * See also: vips_image_set_kill().
 *
 * Returns: %TRUE if @image has been killed. 
 */
gboolean
vips_image_iskilled( VipsImage *image )
{
	gboolean kill;

	kill = image-&gt;kill;

	/* Has kill been set for this image? If yes, abort evaluation.
	 */
	if( image-&gt;kill ) {
		VIPS_DEBUG_MSG( &quot;vips_image_iskilled: %s (%p) killed\n&quot;, 
			image-&gt;filename, image );
		vips_error( &quot;VipsImage&quot;, 
			_( &quot;killed for image \&quot;%s\&quot;&quot; ), image-&gt;filename );

		/* We've picked up the kill message, it's now our caller's
		 * responsibility to pass the message up the chain.
		 */
		vips_image_set_kill( image, FALSE );
	}

	return( kill );
}

/**
 * vips_image_set_kill: (method)
 * @image: image to test
 * @kill: the kill state
 *
 * Set the #VipsImage.kill flag on an image. Handy for stopping sets of
 * threads. 
 *
 * See also: vips_image_iskilled().
 */
void
vips_image_set_kill( VipsImage *image, gboolean kill )
{
	if( image-&gt;kill != kill ) 
		VIPS_DEBUG_MSG( &quot;vips_image_set_kill: %s (%p) %d\n&quot;, 
			image-&gt;filename, image, kill );

	image-&gt;kill = kill;
}

/* Fills the given buffer with a temporary filename.
 * Assuming that &quot;int&quot; might be 64 Bit wide a buffer size of 26 suffices.
 */
void
vips_image_temp_name( char *name, int size )
{
	static int global_serial = 0;

	int serial = g_atomic_int_add( &amp;global_serial, 1 );

	vips_snprintf( name, size, &quot;temp-%d&quot;, serial );
}

/**
 * vips_image_new: (constructor)
 *
 * vips_image_new() creates a new, empty #VipsImage. 
 * If you write to one of these images, vips will just attach some callbacks,
 * no pixels will be generated. 
 *
 * Write pixels to an image with vips_image_generate() or 
 * vips_image_write_line(). Write a whole image to another image with
 * vips_image_write(). 
 *
 * Returns: (transfer full): the new #VipsImage, or %NULL on error.
 */
VipsImage *
vips_image_new( void )
{
	VipsImage *image;
	char filename[26];

	vips_check_init();

	vips_image_temp_name( filename, sizeof( filename ) );

	image = VIPS_IMAGE( g_object_new( VIPS_TYPE_IMAGE, NULL ) );
	g_object_set( image,
		&quot;filename&quot;, filename,
		&quot;mode&quot;, &quot;p&quot;,
		NULL );
	if( vips_object_build( VIPS_OBJECT( image ) ) ) {
		VIPS_UNREF( image );
		return( NULL );
	}

	return( image ); 
}

VipsImage *
vips_image_new_mode( const char *filename, const char *mode )
{
	VipsImage *image;

	g_assert( filename );
	g_assert( mode );

	vips_check_init();

	image = VIPS_IMAGE( g_object_new( VIPS_TYPE_IMAGE, NULL ) );
	g_object_set( image,
		&quot;filename&quot;, filename,
		&quot;mode&quot;, mode,
		NULL );
	if( vips_object_build( VIPS_OBJECT( image ) ) ) {
		VIPS_UNREF( image );
		return( NULL );
	}

	return( image ); 
}

/**
 * vips_image_new_memory: (constructor)
 *
 * vips_image_new_memory() creates a new #VipsImage which, when written to, will
 * create a memory image. 
 *
 * See also: vips_image_new().
 *
 * Returns: (transfer full): the new #VipsImage, or %NULL on error.
 */
VipsImage *
vips_image_new_memory( void )
{
	char filename[26];

	vips_image_temp_name( filename, sizeof( filename ) );
	return( vips_image_new_mode( filename, &quot;t&quot; ) );
}

/**
 * vips_image_memory: (constructor)
 *
 * A renamed vips_image_new_memory() ... Some gobject binding systems do not 
 * like more than one _new() method.
 *
 * See also: vips_image_new_memory().
 *
 * Returns: (transfer full): the new #VipsImage, or %NULL on error.
 */
VipsImage *
vips_image_memory( void )
{
	return( vips_image_new_memory() ); 
}

/**
 * vips_filename_get_filename:
 * @vips_filename: a filename including a set of options
 *
 * Given a vips filename like &quot;fred.jpg[Q=90]&quot;, return a new string of
 * just the filename part, &quot;fred.jpg&quot; in this case. 
 *
 * Useful for language bindings. 
 *
 * See also: vips_filename_get_options().
 *
 * Returns: transfer full: just the filename component.
 */
char *
vips_filename_get_filename( const char *vips_filename )
{
	char filename[VIPS_PATH_MAX];
	char options[VIPS_PATH_MAX];

	vips__filename_split8( vips_filename, filename, options ); 

	return( g_strdup( filename ) );
}

/**
 * vips_filename_get_options:
 * @vips_filename: a filename including a set of options
 *
 * Given a vips filename like &quot;fred.jpg[Q=90]&quot;, return a new string of
 * just the options part, &quot;[Q=90]&quot; in this case. 
 *
 * Useful for language bindings. 
 *
 * See also: vips_filename_get_filename().
 *
 * Returns: transfer full: just the options component.
 */
char *
vips_filename_get_options( const char *vips_filename )
{
	char filename[VIPS_PATH_MAX];
	char options[VIPS_PATH_MAX];

	vips__filename_split8( vips_filename, filename, options ); 

	return( g_strdup( options ) );
}

/**
 * vips_image_new_from_file: (constructor)
 * @name: file to open
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @access: hint #VipsAccess mode to loader
 * * @memory: force load via memory 
 *
 * vips_image_new_from_file() opens @name for reading. It can load files
 * in many image formats, including VIPS, TIFF, PNG, JPEG, FITS, Matlab,
 * OpenEXR, CSV, WebP, Radiance, RAW, PPM and others. 
 *
 * Load options may be appended to @filename as &quot;[name=value,...]&quot; or given as
 * a NULL-terminated list of name-value pairs at the end of the arguments.
 * Options given in the function call override options given in the filename. 
 * Many loaders add extra options, see vips_jpegload(), for example. 
 *
 * vips_image_new_from_file() always returns immediately with the header
 * fields filled in. No pixels are actually read until you first access them. 
 *
 * @access lets you set a #VipsAccess hint giving the expected access pattern 
 * for this file.
 * #VIPS_ACCESS_RANDOM means you can fetch pixels randomly from the image.
 * This is the default mode. #VIPS_ACCESS_SEQUENTIAL means you will read the
 * whole image exactly once, top-to-bottom. In this mode, vips can avoid
 * converting the whole image in one go, for a large memory saving. You are
 * allowed to make small non-local references, so area operations like 
 * convolution will work. 
 *
 * In #VIPS_ACCESS_RANDOM mode, small images are decompressed to memory and
 * then processed from there. Large images are decompressed to temporary
 * random-access files on disc and then processed from there. 
 *
 * Set @memory to %TRUE to force loading via memory. The default is to load 
 * large random access images via temporary disc files. See 
 * vips_image_new_temp_file() for an 
 * explanation of how VIPS selects a location for the temporary file.
 *
 * The disc threshold can be set with the &quot;--vips-disc-threshold&quot;
 * command-line argument, or the `VIPS_DISC_THRESHOLD` environment variable.
 * The value is a simple integer, but can take a unit postfix of &quot;k&quot;, 
 * &quot;m&quot; or &quot;g&quot; to indicate kilobytes, megabytes or gigabytes.
 * The default threshold is 100 MB.
 *
 * For example:
 *
 * |[
 * VipsImage *image = vips_image_new_from_file (&quot;fred.tif&quot;,
 * 	&quot;page&quot;, 12,
 * 	NULL);
 * ]|
 *
 * Will open &quot;fred.tif&quot;, reading page 12. 
 *
 * |[
 * VipsImage *image = vips_image_new_from_file (&quot;fred.jpg[shrink=2]&quot;,
 * 	NULL);
 * ]|
 *
 * Will open &quot;fred.jpg&quot;, downsampling by a factor of two. 
 *
 * Use vips_foreign_find_load() or vips_foreign_is_a() to see what format a 
 * file is in and therefore what options are available. If you need more 
 * control over the loading process, you can call loaders directly, see 
 * vips_jpegload(), for example. 
 *
 * See also: vips_foreign_find_load(), vips_foreign_is_a(), 
 * vips_image_write_to_file().
 *
 * Returns: (transfer full): the new #VipsImage, or %NULL on error.
 */
VipsImage *
vips_image_new_from_file( const char *name, ... )
{
	char filename[VIPS_PATH_MAX];
	char option_string[VIPS_PATH_MAX];
	const char *operation_name;
	va_list ap;
	int result;
	VipsImage *out;

	vips_check_init();

	vips__filename_split8( name, filename, option_string );

	if( !(operation_name = vips_foreign_find_load( filename )) )
		return( NULL );

	va_start( ap, name );
	result = vips_call_split_option_string( operation_name, 
		option_string, ap, filename, &amp;out );
	va_end( ap );

	if( result )
		return( NULL ); 

	return( out );
}

/**
 * vips_image_new_from_file_RW: (constructor)
 * @filename: filename to open
 *
 * Opens the named file for simultaneous reading and writing. This will only 
 * work for VIPS files in a format native to your machine. It is only for 
 * paintbox-type applications.
 *
 * See also: vips_draw_circle().
 *
 * Returns: (transfer full): the new #VipsImage, or %NULL on error.
 */
VipsImage *
vips_image_new_from_file_RW( const char *filename )
{
	return( vips_image_new_mode( filename, &quot;rw&quot; ) ); 
}

/**
 * vips_image_new_from_file_raw: (constructor)
 * @filename: filename to open
 * @xsize: image width
 * @ysize: image height
 * @bands: image bands (or bytes per pixel)
 * @offset: bytes to skip at start of file
 *
 * This function maps the named file and returns a #VipsImage you can use to
 * read it.
 *
 * It returns an 8-bit image with @bands bands. If the image is not 8-bit, use 
 * vips_copy() to transform the descriptor after loading it.
 *
 * See also: vips_copy(), vips_rawload(), vips_image_new_from_file().
 *
 * Returns: (transfer full): the new #VipsImage, or %NULL on error.
 */
VipsImage *
vips_image_new_from_file_raw( const char *filename, 
	int xsize, int ysize, int bands, guint64 offset )
{
	VipsImage *image;

	vips_check_init();

	image = VIPS_IMAGE( g_object_new( VIPS_TYPE_IMAGE, NULL ) );
	g_object_set( image,
		&quot;filename&quot;, filename,
		&quot;mode&quot;, &quot;a&quot;,
		&quot;width&quot;, xsize,
		&quot;height&quot;, ysize,
		&quot;bands&quot;, bands,
		&quot;sizeof_header&quot;, offset,
		NULL );
	if( vips_object_build( VIPS_OBJECT( image ) ) ) {
		VIPS_UNREF( image );
		return( NULL );
	}

	return( image );
}

/**
 * vips_image_new_from_memory: (constructor)
 * @data: (array length=size) (element-type guint8) (transfer none): start of memory area
 * @size: (type gsize): length of memory area
 * @width: image width
 * @height: image height
 * @bands: image bands (or bytes per pixel)
 * @format: image format
 *
 * This function wraps a #VipsImage around a memory area. The memory area
 * must be a simple array, for example RGBRGBRGB, left-to-right,
 * top-to-bottom. Use vips_image_new_from_buffer() to load an area of memory
 * containing an image in a format.
 *
 * VIPS does not take
 * responsibility for the area of memory, it's up to you to make sure it's
 * freed when the image is closed. See for example #VipsObject::close.
 *
 * Because VIPS is &quot;borrowing&quot; @data from the caller, this function is
 * extremely dangerous. Unless you are very careful, you will get crashes or
 * memory corruption. Use vips_image_new_from_memory_copy() instead if you are
 * at all unsure. 
 *
 * Use vips_copy() to set other image properties. 
 *
 * See also: vips_image_new(), vips_image_write_to_memory(),
 * vips_image_new_from_memory_copy().
 *
 * Returns: (transfer full): the new #VipsImage, or %NULL on error.
 */
VipsImage *
vips_image_new_from_memory( const void *data, size_t size,
	int width, int height, int bands, VipsBandFormat format )
{
	VipsImage *image;
	char filename[26];

	vips_check_init();
	vips_image_temp_name( filename, sizeof( filename ) );

	image = VIPS_IMAGE( g_object_new( VIPS_TYPE_IMAGE, NULL ) );
	g_object_set( image,
		&quot;filename&quot;, filename,
		&quot;mode&quot;, &quot;m&quot;,
		&quot;foreign_buffer&quot;, data,
		&quot;width&quot;, width,
		&quot;height&quot;, height,
		&quot;bands&quot;, bands,
		&quot;format&quot;, format,
		NULL );
	if( vips_object_build( VIPS_OBJECT( image ) ) ) {
		VIPS_UNREF( image );
		return( NULL );
	}

	if( size &lt; VIPS_IMAGE_SIZEOF_IMAGE( image ) ) {
		vips_error( &quot;VipsImage&quot;,
			_( &quot;memory area too small --- &quot;
				&quot;should be %&quot; G_GINT64_FORMAT &quot; bytes, &quot;
				&quot;you passed %zd&quot; ),
			VIPS_IMAGE_SIZEOF_IMAGE( image ), size ); 
		VIPS_UNREF( image );
		return( NULL );
	}

	return( image );
}

static void
vips_image_new_from_memory_copy_cb( VipsImage *image, void *data_copy )
{
	vips_tracked_free( data_copy );
}

/**
 * vips_image_new_from_memory_copy: (constructor)
 * @data: (array length=size) (element-type guint8) (transfer none): start of memory area
 * @size: (type gsize): length of memory area
 * @width: image width
 * @height: image height
 * @bands: image bands (or bytes per pixel)
 * @format: image format
 *
 * Like vips_image_new_from_memory(), but VIPS will make a copy of the memory 
 * area. This means more memory use and an extra copy operation, but is much 
 * simpler and safer. 
 *
 * See also: vips_image_new_from_memory().
 *
 * Returns: (transfer full): the new #VipsImage, or %NULL on error.
 */
VipsImage *
vips_image_new_from_memory_copy( const void *data, size_t size,
	int width, int height, int bands, VipsBandFormat format )
{
	void *data_copy;
	VipsImage *image;

	vips_check_init();

	if( !(data_copy = vips_tracked_malloc( size )) )
		return( NULL );
	memcpy( data_copy, data, size );
	if( !(image = vips_image_new_from_memory( data_copy, size, 
		width, height, bands, format )) ) {
		vips_tracked_free( data_copy );
		return( NULL );
	}

	g_signal_connect( image, &quot;close&quot;, 
		G_CALLBACK( vips_image_new_from_memory_copy_cb ), data_copy );

	return( image );
}

/**
 * vips_image_new_from_buffer: (constructor)
 * @buf: (array length=len) (element-type guint8) (transfer none): image data
 * @len: (type gsize): length of memory buffer
 * @option_string: set of extra options as a string
 * @...: %NULL-terminated list of optional named arguments
 *
 * Loads an image from the formatted area of memory @buf, @len using the 
 * loader recommended by vips_foreign_find_load_buffer(). 
 * To load an unformatted area of memory, use
 * vips_image_new_from_memory(). 
 *
 * VIPS does not take
 * responsibility for the area of memory, it's up to you to make sure it's
 * freed when the image is closed. See for example #VipsObject::close.
 *
 * Load options may be given in @option_string as &quot;[name=value,...]&quot; or given as
 * a NULL-terminated list of name-value pairs at the end of the arguments.
 * Options given in the function call override options given in the filename. 
 *
 * See also: vips_image_write_to_buffer().
 *
 * Returns: (transfer full): the new #VipsImage, or %NULL on error.
 */
VipsImage *
vips_image_new_from_buffer( const void *buf, size_t len, 
	const char *option_string, ... )
{
	const char *operation_name;
	va_list ap;
	int result;
	VipsImage *out;
	VipsBlob *blob;

	vips_check_init();

	if( !(operation_name = 
		vips_foreign_find_load_buffer( buf, len )) )
		return( NULL );

	/* We don't take a copy of the data or free it.
	 */
	blob = vips_blob_new( NULL, buf, len );

	va_start( ap, option_string );
	result = vips_call_split_option_string( operation_name,
		option_string, ap, blob, &amp;out );
	va_end( ap );

	vips_area_unref( VIPS_AREA( blob ) );

	if( result )
		return( NULL );

	return( out ); 
}

/**
 * vips_image_new_from_source: (constructor)
 * @source: (transfer none): source to fetch image from
 * @option_string: set of extra options as a string
 * @...: %NULL-terminated list of optional named arguments
 *
 * Loads an image from the formatted source @input, 
 * loader recommended by vips_foreign_find_load_source(). 
 *
 * Load options may be given in @option_string as &quot;[name=value,...]&quot; or given as
 * a NULL-terminated list of name-value pairs at the end of the arguments.
 * Options given in the function call override options given in the string. 
 *
 * See also: vips_image_write_to_target().
 *
 * Returns: (transfer full): the new #VipsImage, or %NULL on error.
 */
VipsImage *
vips_image_new_from_source( VipsSource *source, 
	const char *option_string, ... )
{
	const char *filename = 
		vips_connection_filename( VIPS_CONNECTION( source ) );

	const char *operation_name;
	va_list ap;
	int result;
	VipsImage *out;

	vips_check_init();

	vips_error_freeze();
	operation_name = vips_foreign_find_load_source( source );
	vips_error_thaw();

        if( operation_name ) { 
		va_start( ap, option_string );
		result = vips_call_split_option_string( operation_name,
			option_string, ap, source, &amp;out );
		va_end( ap );
	}
	else if( filename ) {
		/* Try with the old file-based loaders.
		 */
		if( !(operation_name = vips_foreign_find_load( filename )) )
			return( NULL );

		va_start( ap, option_string );
		result = vips_call_split_option_string( operation_name, 
			option_string, ap, filename, &amp;out );
		va_end( ap );
	}
	else if( vips_source_is_mappable( source ) ) {
		/* Try with the old buffer-based loaders.
		 */
		VipsBlob *blob;
		const void *buf;
		size_t len;

		if( !(blob = vips_source_map_blob( source )) )
			return( NULL );

		buf = vips_blob_get( blob, &amp;len );
		if( !(operation_name = 
			vips_foreign_find_load_buffer( buf, len )) ) {
			vips_area_unref( VIPS_AREA( blob ) );
			return( NULL );
		}

                va_start( ap, option_string );
                result = vips_call_split_option_string( operation_name,
                        option_string, ap, blob, &amp;out );
                va_end( ap );

		vips_area_unref( VIPS_AREA( blob ) );
	}
	else {
		vips_error( &quot;VipsImage&quot;,
			&quot;%s&quot;, _( &quot;unable to load source&quot; ) );
		result = -1;
	}

        if( result )
                return( NULL );

        return( out );
}

/**
 * vips_image_new_matrix: (constructor)
 * @width: image width
 * @height: image height
 *
 * This convenience function makes an image which is a matrix: a one-band
 * #VIPS_FORMAT_DOUBLE image held in memory.
 *
 * Use VIPS_IMAGE_ADDR(), or VIPS_MATRIX() to address pixels in the image.
 *
 * Use vips_image_set_double() to set &quot;scale&quot; and &quot;offset&quot;, if required. 
 *
 * See also: vips_image_new_matrixv()
 * 
 * Returns: (transfer full): the new #VipsImage, or %NULL on error.
 */
VipsImage *
vips_image_new_matrix( int width, int height )
{
	VipsImage *image;

	vips_check_init();

	image = VIPS_IMAGE( g_object_new( VIPS_TYPE_IMAGE, NULL ) );
	g_object_set( image,
		&quot;filename&quot;, &quot;vips_image_new_matrix&quot;,
		&quot;mode&quot;, &quot;t&quot;,
		&quot;width&quot;, width,
		&quot;height&quot;, height,
		&quot;bands&quot;, 1,
		&quot;format&quot;, VIPS_FORMAT_DOUBLE,
		&quot;interpretation&quot;, VIPS_INTERPRETATION_MATRIX,
		NULL );
	if( vips_object_build( VIPS_OBJECT( image ) ) ) {
		VIPS_UNREF( image );
		return( NULL );
	}

	if( vips_image_write_prepare( image ) ) {
		g_object_unref( image );
		return( NULL );
	}

	return( image );
}

/**
 * vips_image_new_matrixv: (constructor)
 * @width: image width
 * @height: image height
 * @...: matrix coefficients
 *
 * As vips_image_new_matrix(), but initialise the matrix from the argument
 * list. After @height should be @width * @height double constants which are
 * used to set the matrix elements. 
 *
 * See also: vips_image_new_matrix()
 * 
 * Returns: (transfer full): the new #VipsImage, or %NULL on error.
 */
VipsImage *
vips_image_new_matrixv( int width, int height, ... )
{
	va_list ap;
	VipsImage *matrix;
	int x, y;

	vips_check_init();

	matrix = vips_image_new_matrix( width, height ); 

	va_start( ap, height );
	for( y = 0; y &lt; height; y++ )
		for( x = 0; x &lt; width; x++ )
			*VIPS_MATRIX( matrix, x, y ) = va_arg( ap, double );
	va_end( ap );

	return( matrix ); 
}

/**
 * vips_image_new_matrix_from_array: (constructor)
 * @width: image width
 * @height: image height
 * @array: (array length=size) (transfer none): array of elements
 * @size: (type gsize): number of elements
 *
 * A binding-friendly version of vips_image_new_matrixv().
 *
 * Returns: (transfer full): the new #VipsImage, or %NULL on error.
 */
VipsImage *
vips_image_new_matrix_from_array( int width, int height, 
	const double *array, int size )
{
	VipsImage *matrix;
	int x, y;
	int i;

	if( size != width * height ) {
		vips_error( &quot;VipsImage&quot;,
			_( &quot;bad array length --- should be %d, you passed %d&quot; ),
			width * height, size );
		return( NULL );
	}

	vips_check_init();

	matrix = vips_image_new_matrix( width, height ); 

	i = 0;
	for( y = 0; y &lt; height; y++ )
		for( x = 0; x &lt; width; x++ )
			*VIPS_MATRIX( matrix, x, y ) = array[i++];

	return( matrix ); 
}

/**
 * vips_image_matrix_from_array: (constructor)
 * @width: image width
 * @height: image height
 * @array: (array length=size) (transfer none): array of elements
 * @size: (type gsize): number of elements
 *
 * A renamed vips_image_new_matrix_from_array(). Some gobject bindings do not
 * like more than one _new method.
 *
 * Returns: (transfer full): the new #VipsImage, or %NULL on error.
 */
VipsImage *
vips_image_matrix_from_array( int width, int height, 
	const double *array, int size )
{
	return( vips_image_new_matrix_from_array( width, height, 
		array, size ) ); 
}

/**
 * vips_image_new_from_image: (constructor)
 * @image: image to copy
 * @c: (array length=n) (transfer none): array of constants
 * @n: number of constants
 *
 * Creates a new image with width, height, format, interpretation, resolution
 * and offset taken from @image, but with number of bands taken from @n and the
 * value of each band element set from @c.
 *
 * See also: vips_image_new_from_image1()
 *
 * Returns: (transfer full): the new #VipsImage, or %NULL on error.
 */
VipsImage *
vips_image_new_from_image( VipsImage *image, const double *c, int n )
{
	VipsObject *scope = (VipsObject *) vips_image_new();
	VipsImage **t = (VipsImage **) vips_object_local_array( scope, 5 );

	double *ones;
	int i;
	VipsImage *result;

	if( !(ones = VIPS_ARRAY( scope, n, double )) ) {
		g_object_unref( scope );
		return( NULL );
	}
	for( i = 0; i &lt; n; i++ )
		ones[i] = 1.0;

	if( vips_black( &amp;t[0], 1, 1, NULL ) ||
		vips_linear( t[0], &amp;t[1], ones, (double *) c, n, NULL ) ||
		vips_cast( t[1], &amp;t[2], image-&gt;BandFmt, NULL ) ||
		vips_embed( t[2], &amp;t[3], 0, 0, image-&gt;Xsize, image-&gt;Ysize,
			&quot;extend&quot;, VIPS_EXTEND_COPY, NULL ) ||
		vips_copy( t[3], &amp;t[4], 
			&quot;interpretation&quot;, image-&gt;Type,
			&quot;xres&quot;, image-&gt;Xres,
			&quot;yres&quot;, image-&gt;Yres,
			&quot;xoffset&quot;, image-&gt;Xoffset,
			&quot;yoffset&quot;, image-&gt;Yoffset,
			NULL ) ) {
		g_object_unref( scope );
		return( NULL );
	}

	result = t[4];
	g_object_ref( result );

	g_object_unref( scope );

	return( result ); 
}

/**
 * vips_image_new_from_image1: (constructor)
 * @image: image to copy
 * @c: constants
 *
 * Creates a new image with width, height, format, interpretation, resolution
 * and offset taken from @image, but with one band and each pixel having the
 * value @c.
 *
 * See also: vips_image_new_from_image()
 *
 * Returns: (transfer full): the new #VipsImage, or %NULL on error.
 */
VipsImage *
vips_image_new_from_image1( VipsImage *image, double c )
{
	return( vips_image_new_from_image( image, (const double *) &amp;c, 1 ) );
}

/**
 * vips_image_set_delete_on_close: (method)
 * @image: image to set
 * @delete_on_close: format of file
 *
 * Sets the delete_on_close flag for the image. If this flag is set, when
 * @image is finalized, the filename held in @image-&gt;filename at the time of
 * this call is deleted.
 *
 * This function is clearly extremely dangerous, use with great caution.
 *
 * See also: vips_image_new_temp_file().
 */
void
vips_image_set_delete_on_close( VipsImage *image, gboolean delete_on_close )
{
	VIPS_DEBUG_MSG( &quot;vips_image_set_delete_on_close: %d %s\n&quot;, 
			delete_on_close, image-&gt;filename );

	image-&gt;delete_on_close = delete_on_close;
	VIPS_FREE( image-&gt;delete_on_close_filename );
	if( delete_on_close ) 
		VIPS_SETSTR( image-&gt;delete_on_close_filename, image-&gt;filename );
}

/**
 * vips_get_disc_threshold:
 *
 * Return the number of bytes at which we flip between open via memory and
 * open via disc. This defaults to 100mb, but can be changed with the
 * VIPS_DISC_THRESHOLD environment variable or the --vips-disc-threshold
 * command-line flag. See vips_image_new_from_file(). 
 *
 * Returns: disc threshold in bytes.
 */
guint64
vips_get_disc_threshold( void )
{
	static gboolean done = FALSE;
	static guint64 threshold;

	if( !done ) {
		const char *env;

		done = TRUE;

		/* 100mb default.
		 */
		threshold = 100 * 1024 * 1024;

		if( (env = g_getenv( &quot;VIPS_DISC_THRESHOLD&quot; ))
#if ENABLE_DEPRECATED
			|| (env = g_getenv( &quot;IM_DISC_THRESHOLD&quot; ))
#endif
		  )
			threshold = vips__parse_size( env );

		if( vips__disc_threshold ) 
			threshold = vips__parse_size( vips__disc_threshold );

#ifdef DEBUG
		printf( &quot;vips_get_disc_threshold: %zd bytes\n&quot;, threshold );
#endif /*DEBUG*/
	}

	return( threshold );
}

/**
 * vips_image_new_temp_file: (constructor)
 * @format: format of file
 *
 * Make a #VipsImage which, when written to, will create a temporary file on
 * disc. The file will be automatically deleted when the image is destroyed. 
 * @format is something like &quot;&amp;percnt;s.v&quot; for a vips file.
 *
 * The file is created in the temporary directory. This is set with the
 * environment variable TMPDIR. If this is not set, then on Unix systems, vips
 * will default to /tmp. On Windows, vips uses GetTempPath() to find the
 * temporary directory. 
 *
 * See also: vips_image_new().
 *
 * Returns: the new #VipsImage, or %NULL on error.
 */
VipsImage *
vips_image_new_temp_file( const char *format )
{
	char *name;
	VipsImage *image;

	vips_check_init();

	if( !(name = vips__temp_name( format )) )
		return( NULL );

	if( !(image = vips_image_new_mode( name, &quot;w&quot; )) ) {
		g_free( name );
		return( NULL );
	}

	g_free( name );

	vips_image_set_delete_on_close( image, TRUE );

	return( image );
}

static int
vips_image_write_gen( VipsRegion *or, 
	void *seq, void *a, void *b, gboolean *stop )
{
	VipsRegion *ir = (VipsRegion *) seq;
	VipsRect *r = &amp;or-&gt;valid;

	/*
	printf( &quot;vips_image_write_gen: %p &quot;
		&quot;left = %d, top = %d, width = %d, height = %d\n&quot;,
		or-&gt;im,
		r-&gt;left, r-&gt;top, r-&gt;width, r-&gt;height ); 
	 */

	/* Copy with pointers.
	 */
	if( vips_region_prepare( ir, r ) ||
		vips_region_region( or, ir, r, r-&gt;left, r-&gt;top ) )
		return( -1 );

	return( 0 );
}

/**
 * vips_image_write: (method)
 * @image: image to write
 * @out: (out): write to this image
 *
 * Write @image to @out. Use vips_image_new() and friends to create the
 * #VipsImage you want to write to.
 *
 * See also: vips_image_new(), vips_copy(), vips_image_write_to_file().
 *
 * Returns: 0 on success, or -1 on error.
 */
int
vips_image_write( VipsImage *image, VipsImage *out )
{
	/* image needs to stay alive for this call. It can be unreffed during
	 * the generate.
	 */
	g_object_ref( image );

	if( vips_image_pio_input( image ) || 
		vips_image_pipelinev( out, 
			VIPS_DEMAND_STYLE_THINSTRIP, image, NULL ) ) {
		g_object_unref( image );
		return( -1 );
	}

	if( vips_image_generate( out,
		vips_start_one, vips_image_write_gen, vips_stop_one, 
		image, NULL ) ) {
		g_object_unref( image );
		return( -1 );
	}

	/* If @out is a partial image, we need to unref @image when out is
	 * unreffed.
	 *
	 * If it's not partial, perhaps a file we write to or a memory image,
	 * we need to break any links between @image and @out created by
	 * vips_image_pipelinev().
	 */
	if( vips_image_ispartial( out ) ) { 
		vips_object_local( out, image );
	}
	else {
		vips__reorder_clear( out );
		vips__link_break_all( out );
		g_object_unref( image );
	}

	return( 0 );
}

/**
 * vips_image_write_to_file: (method)
 * @image: image to write
 * @name: write to this file
 * @...: %NULL-terminated list of optional named arguments
 *
 * Writes @in to @name using the saver recommended by
 * vips_foreign_find_save(). 
 *
 * Save options may be appended to @filename as &quot;[name=value,...]&quot; or given as
 * a NULL-terminated list of name-value pairs at the end of the arguments.
 * Options given in the function call override options given in the filename. 
 *
 * See also: vips_image_new_from_file().
 *
 * Returns: 0 on success, or -1 on error.
 */
int
vips_image_write_to_file( VipsImage *image, const char *name, ... )
{
	char filename[VIPS_PATH_MAX];
	char option_string[VIPS_PATH_MAX];
	const char *operation_name;
	va_list ap;
	int result;

	/* Save with the new target API if we can. Fall back to the older
	 * mechanism in case the loader we need has not been converted yet.
	 *
	 * We need to hide any errors from this first phase.
	 */
	vips__filename_split8( name, filename, option_string );

	vips_error_freeze();
	operation_name = vips_foreign_find_save_target( filename );
	vips_error_thaw();

	if( operation_name ) {
		VipsTarget *target;

		if( !(target = vips_target_new_to_file( filename )) )
			return( -1 );

		va_start( ap, name );
		result = vips_call_split_option_string( operation_name, 
			option_string, ap, image, target );
		va_end( ap );

		VIPS_UNREF( target );
	}
	else if( (operation_name = vips_foreign_find_save( filename )) ) {
		va_start( ap, name );
		result = vips_call_split_option_string( operation_name, 
			option_string, ap, image, filename );
		va_end( ap );
	}
	else
		return( -1 );

	return( result );
}

/**
 * vips_image_write_to_buffer: (method)
 * @in: image to write
 * @suffix: format to write 
 * @buf: (array length=size) (element-type guint8) (transfer full): return buffer start here
 * @size: (type gsize): return buffer length here
 * @...: %NULL-terminated list of optional named arguments
 *
 * Writes @in to a memory buffer in a format specified by @suffix. 
 *
 * Save options may be appended to @suffix as &quot;[name=value,...]&quot; or given as
 * a NULL-terminated list of name-value pairs at the end of the arguments.
 * Options given in the function call override options given in the filename. 
 *
 * Currently only TIFF, JPEG and PNG formats are supported.
 *
 * You can call the various save operations directly if you wish, see
 * vips_jpegsave_buffer(), for example. 
 *
 * See also: vips_image_write_to_memory(), vips_image_new_from_buffer().
 *
 * Returns: 0 on success, -1 on error
 */
int
vips_image_write_to_buffer( VipsImage *in, 
	const char *suffix, void **buf, size_t *size, 
	... )
{
	char filename[VIPS_PATH_MAX];
	char option_string[VIPS_PATH_MAX];
	const char *operation_name;
	VipsBlob *blob;
	va_list ap;
	int result;

	vips__filename_split8( suffix, filename, option_string );

	if( (operation_name = vips_foreign_find_save_target( filename )) ) {
		VipsTarget *target;

		if( !(target = vips_target_new_to_memory()) )
			return( -1 );

		va_start( ap, size );
		result = vips_call_split_option_string( operation_name, 
			option_string, ap, in, target );
		va_end( ap );

		if( result ) {
			VIPS_UNREF( target );
			return( -1 );
		}

		g_object_get( target, &quot;blob&quot;, &amp;blob, NULL );
		VIPS_UNREF( target );
	}
	else if( (operation_name = 
		vips_foreign_find_save_buffer( filename )) ) {

		va_start( ap, size );
		result = vips_call_split_option_string( operation_name, 
			option_string, ap, in, &amp;blob );
		va_end( ap );

		if( result )
			return( -1 );
	}
	else
		return( -1 );

	*buf = NULL;
	if( size ) 
		*size = 0;

	if( blob ) { 
		if( buf ) {
			*buf = VIPS_AREA( blob )-&gt;data;
			VIPS_AREA( blob )-&gt;free_fn = NULL;
		}
		if( size ) 
			*size = VIPS_AREA( blob )-&gt;length;

		vips_area_unref( VIPS_AREA( blob ) );
	}

	return( 0 );
}

/**
 * vips_image_write_to_target: (method)
 * @in: image to write
 * @suffix: format to write 
 * @target: target to write to
 * @...: %NULL-terminated list of optional named arguments
 *
 * Writes @in to @output in format @suffix.
 *
 * Save options may be appended to @suffix as &quot;[name=value,...]&quot; or given as
 * a NULL-terminated list of name-value pairs at the end of the arguments.
 * Options given in the function call override options given in the filename. 
 *
 * You can call the various save operations directly if you wish, see
 * vips_jpegsave_target(), for example. 
 *
 * See also: vips_image_write_to_file().
 *
 * Returns: 0 on success, -1 on error
 */
int
vips_image_write_to_target( VipsImage *in, 
	const char *suffix, VipsTarget *target, ... )
{
	char filename[VIPS_PATH_MAX];
	char option_string[VIPS_PATH_MAX];
	const char *operation_name;
	va_list ap;
	int result;

	vips__filename_split8( suffix, filename, option_string );
	if( !(operation_name = vips_foreign_find_save_target( filename )) )
		return( -1 );

	va_start( ap, target );
	result = vips_call_split_option_string( operation_name, option_string, 
		ap, in, target );
	va_end( ap );

	if( result )
		return( -1 );

	return( 0 );
}

/**
 * vips_image_write_to_memory: (method)
 * @in: image to write
 * @size: return buffer length here
 *
 * Writes @in to memory as a simple, unformatted C-style array. 
 *
 * The caller is responsible for freeing this memory with g_free(). 
 *
 * See also: vips_image_write_to_buffer().
 *
 * Returns: (array length=size) (element-type guint8) (transfer full): return buffer start here
 */
void *
vips_image_write_to_memory( VipsImage *in, size_t *size_out )
{
	void *buf;
	size_t size;
	VipsImage *x;

	size = VIPS_IMAGE_SIZEOF_IMAGE( in );
	if( !(buf = g_try_malloc( size )) ) {
		vips_error( &quot;vips_image_write_to_memory&quot;, 
			_( &quot;out of memory --- size == %dMB&quot; ), 
			(int) (size / (1024.0 * 1024.0))  );
		g_warning( _( &quot;out of memory --- size == %dMB&quot; ), 
			(int) (size / (1024.0 * 1024.0))  );
		return( NULL );
	}

	x = vips_image_new_from_memory( buf, size,
		in-&gt;Xsize, in-&gt;Ysize, in-&gt;Bands, in-&gt;BandFmt );
	if( vips_image_write( in, x ) ) {
		g_object_unref( x );
		g_free( buf ); 
		return( NULL ); 
	}
	g_object_unref( x );

	if( size_out )
		*size_out = size;

	return( buf ); 
}

/**
 * vips_image_decode: (method)
 * @in: image to decode
 * @out: (out): write to this image
 *
 * A convenience function to unpack to a format that we can compute with. 
 * @out.coding is always #VIPS_CODING_NONE. 
 *
 * This unpacks LABQ to plain LAB. Use vips_LabQ2LabS() for a bit more speed
 * if you need it. 
 *
 * See also: vips_image_encode(), vips_LabQ2Lab(), vips_rad2float(). 
 *
 * Returns: 0 on success, or -1 on error.
 */
int
vips_image_decode( VipsImage *in, VipsImage **out )
{
	/* Keep in sync with vips__vector_to_ink().
	 */
	if( in-&gt;Coding == VIPS_CODING_LABQ ) {
		if( vips_LabQ2Lab( in, out, NULL ) )
			return( -1 );
	} 
	else if( in-&gt;Coding == VIPS_CODING_RAD ) {
		if( vips_rad2float( in, out, NULL ) )
			return( -1 );
	}
	else {
		if( vips_copy( in, out, NULL ) )
			return( -1 );
	}

	return( 0 );
}

/**
 * vips_image_decode_predict: (method)
 * @in: image to decode
 * @bands: (out): predict bands here
 * @format: (out): predict format here
 *
 * We often need to know what an image will decode to without actually
 * decoding it, for example, in arg checking.
 *
 * See also: vips_image_decode().
 */
int
vips_image_decode_predict( VipsImage *in, 
	int *out_bands, VipsBandFormat *out_format )
{
	VipsBandFormat format;
	int bands; 

	if( in-&gt;Coding == VIPS_CODING_LABQ ) {
		bands = 3;
		format = VIPS_FORMAT_FLOAT;
	}
	else if( in-&gt;Coding == VIPS_CODING_RAD ) {
		bands = 3;
		format = VIPS_FORMAT_FLOAT;
	}
	else {
		bands = in-&gt;Bands;
		format = in-&gt;BandFmt;
	}

	if( out_bands )
		*out_bands = bands;
	if( out_format )
		*out_format = format;

	return( 0 );
}

/**
 * vips_image_encode: (method)
 * @in: image to encode
 * @out: (out): write to this image
 * @coding: coding to apply
 *
 * A convenience function to pack to a coding. The inverse of
 * vips_image_decode().
 *
 * See also: vips_image_decode().
 *
 * Returns: 0 on success, or -1 on error.
 */
int
vips_image_encode( VipsImage *in, VipsImage **out, VipsCoding coding )
{
	if( coding == VIPS_CODING_LABQ ) {
		if( vips_Lab2LabQ( in, out, NULL ) )
			return( -1 );
	} 
	else if( coding == VIPS_CODING_RAD ) {
		if( vips_float2rad( in, out, NULL ) )
			return( -1 );
	}
	else {
		if( vips_copy( in, out, NULL ) )
			return( -1 );
	}

	return( 0 );
}

/**
 * vips_image_isMSBfirst: (method)
 * @image: image to test
 *
 * Return %TRUE if @image is in most-significant-
 * byte first form. This is the byte order used on the SPARC
 * architecture and others. 
 */
gboolean
vips_image_isMSBfirst( VipsImage *image )
{	
	if( image-&gt;magic == VIPS_MAGIC_SPARC )
		return( 1 );
	else
		return( 0 );
}

/**
 * vips_image_isfile: (method)
 * @image: image to test
 *
 * Return %TRUE if @image represents a file on disc in some way. 
 */
gboolean 
vips_image_isfile( VipsImage *image )
{
	switch( image-&gt;dtype ) {
	case VIPS_IMAGE_MMAPIN:
	case VIPS_IMAGE_MMAPINRW:
	case VIPS_IMAGE_OPENOUT:
	case VIPS_IMAGE_OPENIN:
		return( 1 );

	case VIPS_IMAGE_PARTIAL:
	case VIPS_IMAGE_SETBUF:
	case VIPS_IMAGE_SETBUF_FOREIGN:
	case VIPS_IMAGE_NONE:
		return( 0 );

	default:
		g_assert( FALSE ); 
		return( 0 );
	}
}

/**
 * vips_image_ispartial: (method)
 * @image: image to test
 *
 * Return %TRUE if @im represents a partial image (a delayed calculation).
 */
gboolean 
vips_image_ispartial( VipsImage *image )
{
	if( image-&gt;dtype == VIPS_IMAGE_PARTIAL )
		return( 1 );
	else
		return( 0 );
}

/**
 * vips_image_hasalpha: (method)
 * @image: image to check
 *
 * Look at an image's interpretation and see if it has extra alpha bands. For
 * example, a 4-band #VIPS_INTERPRETATION_sRGB would, but a six-band 
 * #VIPS_INTERPRETATION_MULTIBAND would not. 
 *
 * Return %TRUE if @image has an alpha channel.
 */
gboolean
vips_image_hasalpha( VipsImage *image )
{
	/* The result of hasalpha is used to turn on things like
	 * premultiplication, so we are rather conservative about when we
	 * signal this. We don't want to premultiply things that should not be
	 * premultiplied.
	 */
	switch( image-&gt;Type ) { 
	case VIPS_INTERPRETATION_B_W:
	case VIPS_INTERPRETATION_GREY16:
		return( image-&gt;Bands &gt; 1 ); 

	case VIPS_INTERPRETATION_RGB:
	case VIPS_INTERPRETATION_CMC:
	case VIPS_INTERPRETATION_LCH:
	case VIPS_INTERPRETATION_LABS:
	case VIPS_INTERPRETATION_sRGB:
	case VIPS_INTERPRETATION_YXY:
	case VIPS_INTERPRETATION_XYZ:
	case VIPS_INTERPRETATION_LAB:
	case VIPS_INTERPRETATION_RGB16:
	case VIPS_INTERPRETATION_scRGB:
	case VIPS_INTERPRETATION_HSV:
		return( image-&gt;Bands &gt; 3 ); 

	case VIPS_INTERPRETATION_CMYK:
		return( image-&gt;Bands &gt; 4 ); 

	default:
		/* We can't really infer anything about bands from things like
		 * HISTOGRAM or FOURIER.
		 */
		return( FALSE ); 
	}
}

/**
 * vips_image_write_prepare: (method)
 * @image: image to prepare
 *
 * Call this after setting header fields (width, height, and so on) to
 * allocate resources ready for writing. 
 *
 * Normally this function is called for you by vips_image_generate() or
 * vips_image_write_line(). You will need to call it yourself if you plan to
 * write directly to the -&gt;data member of a memory image.
 *
 * Returns: 0 on success, or -1 on error.
 */
int
vips_image_write_prepare( VipsImage *image )
{
	g_assert( vips_object_sanity( VIPS_OBJECT( image ) ) );

	if( image-&gt;Xsize &lt;= 0 || 
		image-&gt;Ysize &lt;= 0 || 
		image-&gt;Bands &lt;= 0 ) {
		vips_error( &quot;VipsImage&quot;, &quot;%s&quot;, _( &quot;bad dimensions&quot; ) );
		return( -1 );
	}

	/* We don't use this, but make sure it's set in case any old programs
	 * are expecting it.
	 */
	image-&gt;Bbits = vips_format_sizeof( image-&gt;BandFmt ) &lt;&lt; 3;
 
	if( image-&gt;dtype == VIPS_IMAGE_PARTIAL ) {
		VIPS_DEBUG_MSG( &quot;vips_image_write_prepare: &quot;
			&quot;old-style output for %s\n&quot;, image-&gt;filename );

		image-&gt;dtype = VIPS_IMAGE_SETBUF;
	}

	switch( image-&gt;dtype ) {
	case VIPS_IMAGE_MMAPINRW:
	case VIPS_IMAGE_SETBUF_FOREIGN:
		break;

	case VIPS_IMAGE_SETBUF:
		if( !image-&gt;data &amp;&amp; 
			!(image-&gt;data = vips_tracked_malloc( 
				VIPS_IMAGE_SIZEOF_IMAGE( image ))) ) 
			return( -1 );

		break;

	case VIPS_IMAGE_OPENOUT:
		if( vips_image_open_output( image ) )
			return( -1 );

		break;

	default:
		vips_error( &quot;VipsImage&quot;, &quot;%s&quot;, _( &quot;bad image descriptor&quot; ) );
		return( -1 );
	}

	return( 0 );
}

/**
 * vips_image_write_line: (method)
 * @image: image to write to
 * @ypos: vertical position of scan-line to write
 * @linebuffer: scanline of pixels
 *
 * Write a line of pixels to an image. This function must be called repeatedly
 * with @ypos increasing from 0 to #VipsImage::height .
 * @linebuffer must be VIPS_IMAGE_SIZEOF_LINE() bytes long.
 *
 * See also: vips_image_generate().
 *
 * Returns: 0 on success, or -1 on error.
 */
int
vips_image_write_line( VipsImage *image, int ypos, VipsPel *linebuffer )
{	
	int linesize = VIPS_IMAGE_SIZEOF_LINE( image );

	/* Is this the start of eval?
	 */
	if( ypos == 0 ) {
		if( vips__image_wio_output( image ) )
			return( -1 );

		/* Always clear kill before we start looping. See the 
		 * call to vips_image_iskilled() below.
		 */
		vips_image_set_kill( image, FALSE );
		vips_image_write_prepare( image );
		vips_image_preeval( image );
	}

	/* Possible cases for output: FILE or SETBUF.
	 */
	switch( image-&gt;dtype ) {
	case VIPS_IMAGE_SETBUF:
	case VIPS_IMAGE_SETBUF_FOREIGN:
		memcpy( VIPS_IMAGE_ADDR( image, 0, ypos ), 
			linebuffer, linesize );
		break;

	case VIPS_IMAGE_OPENOUT:
		/* Don't use ypos for this.
		 */
		if( vips__write( image-&gt;fd, linebuffer, linesize ) )
			return( -1 );
		break;

	default:
		vips_error( &quot;VipsImage&quot;, 
			_( &quot;unable to output to a %s image&quot; ),
			vips_enum_string( VIPS_TYPE_IMAGE_TYPE, 
				image-&gt;dtype ) );
		return( -1 );
	}

	/* Trigger evaluation callbacks for this image.
	 */
	vips_image_eval( image, ypos * image-&gt;Xsize );
	if( vips_image_iskilled( image ) )
		return( -1 );

	/* Is this the end of eval?
	 */
	if( ypos == image-&gt;Ysize - 1 ) {
		vips_image_posteval( image );
		if( vips_image_written( image ) )
			return( -1 );
	}

	return( 0 );
}

/* Rewind an output file. VIPS images only.
 */
static int
vips_image_rewind_output( VipsImage *image ) 
{
	int fd;

	g_assert( image-&gt;dtype == VIPS_IMAGE_OPENOUT );

#ifdef DEBUG_IO
	printf( &quot;vips_image_rewind_output: %s\n&quot;, image-&gt;filename );
#endif/*DEBUG_IO*/

	/* We want to keep the fd across rewind. 
	 *
	 * On Windows, we open temp files with _O_TEMPORARY. We mustn't close
	 * the file since this will delete it. 
	 *
	 * We could open the file again to keep a reference to it alive, but
	 * this is also problematic on Windows. 
	 */
	fd = image-&gt;fd;
	image-&gt;fd = -1;

	/* Free any resources the image holds and reset to a base
	 * state.
	 */
	vips_object_rewind( VIPS_OBJECT( image ) );

	/* And reopen ... recurse to get a mmaped image. 
	 *
	 * We use &quot;v&quot; mode to get it opened as a vips image, bypassing the
	 * file type checks. They will fail on Windows because you can't open
	 * fds more than once.
	 */
	image-&gt;fd = fd;
	g_object_set( image,
		&quot;mode&quot;, &quot;v&quot;,
		NULL );
	if( vips_object_build( VIPS_OBJECT( image ) ) ) {
		vips_error( &quot;VipsImage&quot;, 
			_( &quot;auto-rewind for %s failed&quot; ),
			image-&gt;filename );
		return( -1 );
	}

	/* Now we've finished writing and reopened as read, we can
	 * delete-on-close. 
	 *
	 * On *nix-like systems, this will unlink the file from the 
	 * filesystem and when we exit, for whatever reason, the file
	 * we be reclaimed. 
	 *
	 * On Windows this will fail because the file is open and you can't
	 * delete open files. However, on Windows we set _O_TEMPORARY, so the 
	 * file will be deleted when the fd is finally closed.
	 */
	vips_image_delete( image );

	return( 0 );
}

/** 
 * vips_image_copy_memory: (method)
 * @image: image to copy to a memory buffer
 *
 * Make an image which is an area of memory. 
 *
 * If @image is already a memory buffer, just ref and return. If it's a file on
 * disc or a partial, allocate memory and copy the image to it. 
 *
 * This operation is thread-safe, unlike vips_image_wio_input(). 
 *
 * If you are sure that @image is not shared with another thread (perhaps you
 * have made it yourself), use vips_image_wio_input() instead.
 *
 * See also: vips_image_wio_input().
 *
 * Returns: (transfer full): the new #VipsImage, or %NULL on error.
 */
VipsImage *
vips_image_copy_memory( VipsImage *image )
{
	VipsImage *new;

	switch( image-&gt;dtype ) {
	case VIPS_IMAGE_SETBUF:
	case VIPS_IMAGE_SETBUF_FOREIGN:
	case VIPS_IMAGE_MMAPIN:
	case VIPS_IMAGE_MMAPINRW:
		/* Can read from all these, in principle anyway.
		 */
		new = image;
		g_object_ref( new );
		break;

	case VIPS_IMAGE_OPENOUT:
	case VIPS_IMAGE_OPENIN:
	case VIPS_IMAGE_PARTIAL:
		new = vips_image_new_memory();
		if( vips_image_write( image, new ) ) {
			g_object_unref( new );
			return( NULL ); 
		}
		break;

	default:
		vips_error( &quot;vips_image_copy_memory&quot;, 
			&quot;%s&quot;, _( &quot;image not readable&quot; ) );
		return( NULL );
	}

	return( new );
}

/**
 * vips_image_wio_input: (method)
 * @image: image to transform
 *
 * Check that an image is readable via the VIPS_IMAGE_ADDR() macro, that is,
 * that the entire image is in memory and all pixels can be read with 
 * VIPS_IMAGE_ADDR().  If it 
 * isn't, try to transform it so that VIPS_IMAGE_ADDR() can work. 
 *
 * Since this function modifies @image, it is not thread-safe. Only call it on
 * images which you are sure have not been shared with another thread. If the
 * image might have been shared, use the less efficient
 * vips_image_copy_memory() instead.
 *
 * See also: vips_image_copy_memory(), vips_image_pio_input(), 
 * vips_image_inplace(), VIPS_IMAGE_ADDR().
 *
 * Returns: 0 on succeess, or -1 on error.
 */
int
vips_image_wio_input( VipsImage *image )
{	
	VipsImage *t1;

	g_assert( vips_object_sanity( VIPS_OBJECT( image ) ) );

#ifdef DEBUG_IO
	printf( &quot;vips_image_wio_input: wio input for %s\n&quot;, 
		image-&gt;filename );
#endif/*DEBUG_IO*/

	switch( image-&gt;dtype ) {
	case VIPS_IMAGE_SETBUF:
	case VIPS_IMAGE_SETBUF_FOREIGN:
		/* Should have been written to.
		 */
		if( !image-&gt;data ) {
			vips_error( &quot;vips_image_wio_input&quot;, 
				&quot;%s&quot;, _( &quot;no image data&quot; ) );
			return( -1 );
		}

		break;

	case VIPS_IMAGE_MMAPIN:
	case VIPS_IMAGE_MMAPINRW:
		/* Can read from all these, in principle anyway.
		 */
		break;

	case VIPS_IMAGE_PARTIAL:
#ifdef DEBUG_IO
		printf( &quot;vips_image_wio_input: &quot;
			&quot;converting partial image to WIO\n&quot; );
#endif/*DEBUG_IO*/

		/* Change to VIPS_IMAGE_SETBUF. First, make a memory 
		 * buffer and copy into that.
		 */
		t1 = vips_image_new_memory();
		if( vips_image_write( image, t1 ) ) {
			g_object_unref( t1 );
			return( -1 );
		}

		/* Copy new stuff in. We can't unref and free stuff, as this
		 * would kill of lots of regions and cause dangling pointers
		 * elsewhere.
<A NAME="1"></A>		 */
		image-&gt;dtype = VIPS_IMAGE_SETBUF;
		image-&gt;data = t1-&gt;data; 
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match27985-0.html#1',2,'match27985-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		t1-&gt;data = NULL;

		/* Close temp image.
		 */
		g_object_unref( t1 );

		/* We need to zap any start/gen/stop callbacks. If we don't,
		 * calling vips_region_prepare_to() later to read from this 
		 * image will fail, since it will think it needs to create the
		 * image, not read from it.
		 */
		image-&gt;start_fn = NULL;
		image-&gt;generate_fn = NULL;
		image-&gt;stop_fn = NULL;
		image-&gt;client1 = NULL;
		image-&gt;client2 = NULL;

		/* ... and that may confuse any regions which are trying to
		 * generate from this image.
		 */
		if( image-&gt;regions ) </B></FONT>
			g_warning( &quot;rewinding image with active regions&quot; ); 

		break;

	case VIPS_IMAGE_OPENIN:
#ifdef DEBUG_IO
		printf( &quot;vips_image_wio_input: &quot;
			&quot;converting openin image for wio input\n&quot; );
#endif/*DEBUG_IO*/

		/* just mmap() the whole thing.
		 */
		if( vips_mapfile( image ) ) 
			return( -1 );
		image-&gt;data = (VipsPel *) image-&gt;baseaddr + 
			image-&gt;sizeof_header;
		image-&gt;dtype = VIPS_IMAGE_MMAPIN;

		break;

	case VIPS_IMAGE_OPENOUT:
		/* Close file down and reopen as input. I guess this will only
		 * work for vips files?
		 */
		if( vips_image_rewind_output( image ) ||
			vips_image_wio_input( image ) ) 
			return( -1 );

		break;

	default:
		vips_error( &quot;vips_image_wio_input&quot;, 
			&quot;%s&quot;, _( &quot;image not readable&quot; ) );
		return( -1 );
	}

	return( 0 );
}

int 
vips__image_wio_output( VipsImage *image )
{
#ifdef DEBUG_IO
	printf( &quot;vips__image_wio_output: WIO output for %s\n&quot;, 
		image-&gt;filename );
#endif/*DEBUG_IO*/

	switch( image-&gt;dtype ) {
	case VIPS_IMAGE_PARTIAL:
		/* Make sure nothing is attached.
		 */
		if( image-&gt;generate_fn ) {
			vips_error( &quot;vips__image_wio_output&quot;, 
				&quot;%s&quot;, _( &quot;image already written&quot; ) );
			return( -1 );
		}

		/* Cannot do old-style write to PARTIAL. Turn to SETBUF.
		 */
		image-&gt;dtype = VIPS_IMAGE_SETBUF;

		break;

	case VIPS_IMAGE_SETBUF:
	case VIPS_IMAGE_OPENOUT:
	case VIPS_IMAGE_SETBUF_FOREIGN:
		/* Can write to this ok. 
		 *
		 * We used to check that -&gt;data was null and warn about
		 * writing twice, but we no longer insist that this is called
		 * before vips_image_write_prepare(), so we can't do that any
		 * more.
		 */
		break;

	default:
		vips_error( &quot;vips__image_wio_output&quot;, 
			&quot;%s&quot;, _( &quot;image not writeable&quot; ) );
		return( -1 );
	}

	return( 0 );
}
 
/**
 * vips_image_inplace: (method)
 * @image: image to make read-write
 *
 * Gets @image ready for an in-place operation, such as vips_draw_circle().
 * After calling this function you can both read and write the image with 
 * VIPS_IMAGE_ADDR().
 *
 * This method is called for you by the base class of the draw operations, 
 * there's no need to call it yourself.
 *
 * Since this function modifies @image, it is not thread-safe. Only call it on
 * images which you are sure have not been shared with another thread. 
 * All in-place operations are inherently not thread-safe, so you need to take
 * great care in any case.
 *
 * See also: vips_draw_circle(), vips_image_wio_input().
 *
 * Returns: 0 on succeess, or -1 on error.
 */
int
vips_image_inplace( VipsImage *image )
{
	/* Do an vips_image_wio_input(). This will rewind, generate, etc.
	 */
	if( vips_image_wio_input( image ) ) 
		return( -1 );

	/* Look at the type.
	 */
	switch( image-&gt;dtype ) {
	case VIPS_IMAGE_SETBUF:
	case VIPS_IMAGE_SETBUF_FOREIGN:
	case VIPS_IMAGE_MMAPINRW:
		/* No action necessary.
		 */
		break;

	case VIPS_IMAGE_MMAPIN:
		/* Try to remap read-write.
		 */
		if( vips_remapfilerw( image ) )
			return( -1 );

		break;

	default:
		vips_error( &quot;vips_image_inplace&quot;, 
			&quot;%s&quot;, _( &quot;bad file type&quot; ) );
		return( -1 );
	}

	/* This image is about to be changed (probably). Make sure it's not 
	 * in cache.
	 */
	vips_image_invalidate_all( image ); 

	return( 0 );
}

/**
 * vips_image_pio_input: (method)
 * @image: image to check
 *
 * Check that an image is readable with vips_region_prepare() and friends. 
 * If it isn't, try to transform the image so that vips_region_prepare() can 
 * work.
 *
 * See also: vips_image_pio_output(), vips_region_prepare().
 *
 * Returns: 0 on succeess, or -1 on error.
 */
int
vips_image_pio_input( VipsImage *image )
{
	g_assert( vips_object_sanity( VIPS_OBJECT( image ) ) );

#ifdef DEBUG_IO
	printf( &quot;vips_image_pio_input: enabling partial input for %s\n&quot;, 
		image-&gt;filename );
#endif /*DEBUG_IO*/

	switch( image-&gt;dtype ) {
	case VIPS_IMAGE_SETBUF:
	case VIPS_IMAGE_SETBUF_FOREIGN:
		/* Should have been written to.
		 */
		if( !image-&gt;data ) {
			vips_error( &quot;vips_image_pio_input&quot;, 
				&quot;%s&quot;, _( &quot;no image data&quot; ) );
			return( -1 );
		}

		/* Should be no generate functions now.
		 */
		image-&gt;start_fn = NULL;
		image-&gt;generate_fn = NULL;
		image-&gt;stop_fn = NULL;

		break;

	case VIPS_IMAGE_PARTIAL:
		/* Should have had generate functions attached.
		 */
		if( !image-&gt;generate_fn ) {
			vips_error( &quot;vips_image_pio_input&quot;, 
				&quot;%s&quot;, _( &quot;no image data&quot; ) );
			return( -1 );
		}

		break;

	case VIPS_IMAGE_MMAPIN:
	case VIPS_IMAGE_MMAPINRW:
	case VIPS_IMAGE_OPENIN:
		break;

	case VIPS_IMAGE_OPENOUT:

		/* Free any resources the image holds and reset to a base
		 * state.
		 */
		if( vips_image_rewind_output( image ) )
			return( -1 );

		break;

	default:
		vips_error( &quot;vips_image_pio_input&quot;, 
			&quot;%s&quot;, _( &quot;image not readable&quot; ) );
		return( -1 );
	}

	return( 0 );
}

/**
 * vips_image_pio_output: (method)
 * @image: image to check
 *
 * Check that an image is writeable with vips_image_generate(). If it isn't,
 * try to transform the image so that vips_image_generate() can work.
 *
 * See also: vips_image_pio_input().
 *
 * Returns: 0 on succeess, or -1 on error.
 */
int 
vips_image_pio_output( VipsImage *image )
{
#ifdef DEBUG_IO
	printf( &quot;vips_image_pio_output: enabling partial output for %s\n&quot;, 
		image-&gt;filename );
#endif /*DEBUG_IO*/

	switch( image-&gt;dtype ) {
	case VIPS_IMAGE_SETBUF:
		if( image-&gt;data ) {
			vips_error( &quot;vips_image_pio_output&quot;, 
				&quot;%s&quot;, _( &quot;image already written&quot; ) );
			return( -1 );
		}

		break;

	case VIPS_IMAGE_PARTIAL:
		if( image-&gt;generate_fn ) {
			vips_error( &quot;vips_image_pio_output&quot;, 
				&quot;%s&quot;, _( &quot;image already written&quot; ) );
			return( -1 );
		}

		break;

	case VIPS_IMAGE_OPENOUT:
	case VIPS_IMAGE_SETBUF_FOREIGN:
		break;

	default:
		vips_error( &quot;vips_image_pio_output&quot;, 
			&quot;%s&quot;, _( &quot;image not writeable&quot; ) );
		return( -1 );
	}

	return( 0 );
}

/**
 * vips_band_format_isint:
 * @format: format to test
 *
 * Return %TRUE if @format is one of the integer types.
 */
gboolean
vips_band_format_isint( VipsBandFormat format )
{
	switch( format ) {
	case VIPS_FORMAT_UCHAR:
	case VIPS_FORMAT_CHAR:
	case VIPS_FORMAT_USHORT:
	case VIPS_FORMAT_SHORT:
	case VIPS_FORMAT_UINT:
	case VIPS_FORMAT_INT:
		return( TRUE );

	case VIPS_FORMAT_FLOAT:
	case VIPS_FORMAT_DOUBLE:	
	case VIPS_FORMAT_COMPLEX:
	case VIPS_FORMAT_DPCOMPLEX:	
		return( FALSE );

	default:
		g_assert_not_reached();
		return( FALSE );
	}
}

/**
 * vips_band_format_isuint:
 * @format: format to test
 *
 * Return %TRUE if @format is one of the unsigned integer types.
 */
gboolean
vips_band_format_isuint( VipsBandFormat format )
{
	switch( format ) {
	case VIPS_FORMAT_UCHAR:
	case VIPS_FORMAT_USHORT:
	case VIPS_FORMAT_UINT:
		return( TRUE );

	case VIPS_FORMAT_INT:
	case VIPS_FORMAT_SHORT:
	case VIPS_FORMAT_CHAR:
	case VIPS_FORMAT_FLOAT:
	case VIPS_FORMAT_DOUBLE:	
	case VIPS_FORMAT_COMPLEX:
	case VIPS_FORMAT_DPCOMPLEX:	
		return( FALSE );
	
	default:
		g_assert_not_reached();
		return( FALSE );
	}
}

/**
 * vips_band_format_is8bit:
 * @format: format to test
 *
 * Return %TRUE if @format is uchar or schar.
 */
gboolean
vips_band_format_is8bit( VipsBandFormat format )
{
	switch( format ) {
	case VIPS_FORMAT_UCHAR:
	case VIPS_FORMAT_CHAR:
		return( TRUE );

	case VIPS_FORMAT_USHORT:
	case VIPS_FORMAT_SHORT:
	case VIPS_FORMAT_UINT:
	case VIPS_FORMAT_INT:
	case VIPS_FORMAT_FLOAT:
	case VIPS_FORMAT_DOUBLE:
	case VIPS_FORMAT_COMPLEX:
	case VIPS_FORMAT_DPCOMPLEX:
		return( FALSE );

	default:
		g_assert_not_reached();
		return( FALSE );
	}
}

/**
 * vips_band_format_isfloat:
 * @format: format to test
 *
 * Return %TRUE if @format is one of the float types.
 */
gboolean
vips_band_format_isfloat( VipsBandFormat format )
{
	switch( format ) {
	case VIPS_FORMAT_FLOAT:
	case VIPS_FORMAT_DOUBLE:	
		return( TRUE );

	case VIPS_FORMAT_UCHAR:
	case VIPS_FORMAT_CHAR:
	case VIPS_FORMAT_USHORT:
	case VIPS_FORMAT_SHORT:
	case VIPS_FORMAT_UINT:
	case VIPS_FORMAT_INT:
	case VIPS_FORMAT_COMPLEX:
	case VIPS_FORMAT_DPCOMPLEX:	
		return( FALSE );
	
	default:
		g_assert_not_reached();
		return( FALSE );
	}
}

/**
 * vips_band_format_iscomplex:
 * @format: format to test
 *
 * Return %TRUE if @fmt is one of the complex types.
 */
gboolean
vips_band_format_iscomplex( VipsBandFormat format )
{
	switch( format ) {
	case VIPS_FORMAT_COMPLEX:
	case VIPS_FORMAT_DPCOMPLEX:	
		return( TRUE );

	case VIPS_FORMAT_UCHAR:
	case VIPS_FORMAT_CHAR:
	case VIPS_FORMAT_USHORT:
	case VIPS_FORMAT_SHORT:
	case VIPS_FORMAT_UINT:
	case VIPS_FORMAT_INT:
	case VIPS_FORMAT_FLOAT:
	case VIPS_FORMAT_DOUBLE:	
		return( FALSE );
	
	default:
		g_assert_not_reached();
		return( FALSE );
	}
}

/**
 * vips_image_free_buffer:
 * @image: the image that contains the buffer
 * @buffer: the orignal buffer that was stolen
 *
 * Free the externally allocated buffer found in the input image. This function
 * is intended to be used with g_signal_connect.
 */
void
vips_image_free_buffer( VipsImage *image, void *buffer )
{
	free( buffer );
}

/* Handy for debugging: view an image in nip2.
 */
int
vips__view_image( VipsImage *image )
{
	VipsArrayImage *array; 
	int result;

	array = vips_array_image_new( &amp;image, 1 );
	result = vips_system( &quot;nip2 %s&quot;, 
		&quot;in&quot;, array, 
		&quot;in-format&quot;, &quot;%s.v&quot;, 
		NULL ); 
	vips_area_unref( VIPS_AREA( array ) );

	return( result ); 
}
</PRE>
</div>
  </div>
</body>
</html>
