<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for lrmerge.c &amp; image.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for lrmerge.c &amp; image.c
      </h3>
<h1 align="center">
        2.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>lrmerge.c (3.762663%)<th>image.c (1.6219589%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(739-758)<td><a href="#" name="0">(1073-1089)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1015-1026)<td><a href="#" name="1">(3432-3452)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>lrmerge.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#include &lt;vips/intl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;
#include &lt;vips/vips.h&gt;
#include &lt;vips/thread.h&gt;
#include &lt;vips/transform.h&gt;
#include &lt;vips/internal.h&gt;
#include "pmosaicing.h"
double *vips__coef1 = NULL;
double *vips__coef2 = NULL;
int *vips__icoef1 = NULL;
int *vips__icoef2 = NULL;
int
vips__make_blend_luts( void )
{
	int x;
	if( vips__coef1 &amp;&amp; vips__coef2 )
		return( 0 );
	vips__coef1 = VIPS_ARRAY( NULL, BLEND_SIZE, double );
	vips__coef2 = VIPS_ARRAY( NULL, BLEND_SIZE, double );
	vips__icoef1 = VIPS_ARRAY( NULL, BLEND_SIZE, int );
	vips__icoef2 = VIPS_ARRAY( NULL, BLEND_SIZE, int );
	if( !vips__coef1 || !vips__coef2 || !vips__icoef1 || !vips__icoef2 ) 
		return( -1 ); 
	for( x = 0; x &lt; BLEND_SIZE; x++ ) {
		double a = VIPS_PI * x / (BLEND_SIZE - 1.0);
		vips__coef1[x] = (cos( a ) + 1.0) / 2.0;
		vips__coef2[x] = 1.0 - vips__coef1[x];
		vips__icoef1[x] = vips__coef1[x] * BLEND_SCALE;
		vips__icoef2[x] = vips__coef2[x] * BLEND_SCALE;
	}
	return( 0 );
}
static int
find_first( VipsRegion *ir, int *pos, int x, int y, int w )
{
	VipsPel *pr = VIPS_REGION_ADDR( ir, x, y );
	VipsImage *im = ir-&gt;im;
	int ne = w * im-&gt;Bands;
	int i;
	if( vips_band_format_iscomplex( im-&gt;BandFmt ) )
		ne *= 2;
#define lsearch( TYPE ) { \
	TYPE *p = (TYPE *) pr; \
	\
	for( i = 0; i &lt; ne; i++ ) \
		if( p[i] )\
			break;\
}
	switch( im-&gt;BandFmt ) {
	case VIPS_FORMAT_UCHAR:		lsearch( unsigned char ); break; 
	case VIPS_FORMAT_CHAR:		lsearch( signed char ); break; 
	case VIPS_FORMAT_USHORT:	lsearch( unsigned short ); break; 
	case VIPS_FORMAT_SHORT:		lsearch( signed short ); break; 
	case VIPS_FORMAT_UINT:		lsearch( unsigned int ); break; 
	case VIPS_FORMAT_INT:		lsearch( signed int );  break; 
	case VIPS_FORMAT_FLOAT:		lsearch( float ); break; 
	case VIPS_FORMAT_DOUBLE:	lsearch( double ); break; 
	case VIPS_FORMAT_COMPLEX:	lsearch( float ); break; 
	case VIPS_FORMAT_DPCOMPLEX:	lsearch( double ); break;
	default:
		g_assert_not_reached(); 
		return( -1 );
	}
	*pos = x + i / im-&gt;Bands;
	return( 0 );
}
static int
find_last( VipsRegion *ir, int *pos, int x, int y, int w )
{
	VipsPel *pr = VIPS_REGION_ADDR( ir, x, y );
	VipsImage *im = ir-&gt;im;
	int ne = w * im-&gt;Bands;
	int i;
	if( vips_band_format_iscomplex( im-&gt;BandFmt ) )
		ne *= 2;
#define rsearch( TYPE ) { \
	TYPE *p = (TYPE *) pr; \
	\
	for( i = ne - 1; i &gt;= 0; i-- )\
		if( p[i] )\
			break;\
}
	switch( im-&gt;BandFmt ) {
	case VIPS_FORMAT_UCHAR:		rsearch( unsigned char ); break; 
	case VIPS_FORMAT_CHAR:		rsearch( signed char ); break; 
	case VIPS_FORMAT_USHORT:	rsearch( unsigned short ); break; 
	case VIPS_FORMAT_SHORT:		rsearch( signed short ); break; 
	case VIPS_FORMAT_UINT:		rsearch( unsigned int ); break; 
	case VIPS_FORMAT_INT:		rsearch( signed int );  break; 
	case VIPS_FORMAT_FLOAT:		rsearch( float ); break; 
	case VIPS_FORMAT_DOUBLE:	rsearch( double ); break; 
	case VIPS_FORMAT_COMPLEX:	rsearch( float ); break; 
	case VIPS_FORMAT_DPCOMPLEX:	rsearch( double ); break;
	default:
		vips_error( "lrmerge", "%s", _( "internal error" ) );
		return( -1 );
	}
	*pos = x + i / im-&gt;Bands;
	return( 0 );
}
static int
make_firstlast( MergeInfo *inf, Overlapping *ovlap, VipsRect *oreg )
{
	VipsRegion *rir = inf-&gt;rir;
	VipsRegion *sir = inf-&gt;sir;
	VipsRect rr, sr;
	int y, yr, ys;
	int missing;
	g_mutex_lock( ovlap-&gt;fl_lock );
	missing = 0;
	for( y = oreg-&gt;top; y &lt; VIPS_RECT_BOTTOM( oreg ); y++ ) {
		const int j = y - ovlap-&gt;overlap.top;
		const int first = ovlap-&gt;first[j];
		if( first &lt; 0 ) {
			missing = 1;
			break;
		}
	}
	if( !missing ) {
		g_mutex_unlock( ovlap-&gt;fl_lock );
		return( 0 );
	}
	rr.left = ovlap-&gt;overlap.left;
	rr.top = oreg-&gt;top;
	rr.width = ovlap-&gt;overlap.width;
	rr.height = oreg-&gt;height;
	rr.left -= ovlap-&gt;rarea.left;
	rr.top -= ovlap-&gt;rarea.top;
	sr.left = ovlap-&gt;overlap.left;
	sr.top = oreg-&gt;top;
	sr.width = ovlap-&gt;overlap.width;
	sr.height = oreg-&gt;height;
	sr.left -= ovlap-&gt;sarea.left;
	sr.top -= ovlap-&gt;sarea.top;
#ifdef DEBUG
	printf( "lrmerge: making first/last for areas:\n" );
	printf( "ref: left = %d, top = %d, width = %d, height = %d\n",
		rr.left, rr.top, rr.width, rr.height );
	printf( "sec: left = %d, top = %d, width = %d, height = %d\n",
		sr.left, sr.top, sr.width, sr.height );
#endif
	if( vips_region_prepare( rir, &amp;rr ) ||
		vips_region_prepare( sir, &amp;sr ) ) {
		g_mutex_unlock( ovlap-&gt;fl_lock );
		return( -1 );
	}
	for( y = oreg-&gt;top, yr = rr.top, ys = sr.top; 
		y &lt; VIPS_RECT_BOTTOM( oreg ); y++, yr++, ys++ ) {
		const int j = y - ovlap-&gt;overlap.top;
		int *first = &amp;ovlap-&gt;first[j];
		int *last = &amp;ovlap-&gt;last[j];
		if( *first &lt; 0 ) {
			if( find_first( sir, first, 
				sr.left, ys, sr.width ) ||
				find_last( rir, last, 
					rr.left, yr, rr.width ) ) {
				g_mutex_unlock( ovlap-&gt;fl_lock );
				return( -1 );
			}
			*first += ovlap-&gt;sarea.left;
			*last += ovlap-&gt;rarea.left;
			if( ovlap-&gt;mwidth &gt;= 0 &amp;&amp; 
				*last - *first &gt; ovlap-&gt;mwidth ) {
				int shrinkby = (*last - *first) - ovlap-&gt;mwidth;
				*first += shrinkby / 2;
				*last -= shrinkby / 2;
			}
		}
	}
	g_mutex_unlock( ovlap-&gt;fl_lock );
	return( 0 );
}
#define TEST_ZERO( TYPE, T, RESULT ) { \
	TYPE *tt = (T); \
	int ii; \
	\
	for( ii = 0; ii &lt; cb; ii++ ) \
		if( tt[i + ii] ) \
			break; \
	if( ii == cb )  \
		(RESULT) = 1; \
}
#define iblend( TYPE, B, IN1, IN2, OUT ) { \
	TYPE *tr = (TYPE *) (IN1); \
	TYPE *ts = (TYPE *) (IN2); \
	TYPE *tq = (TYPE *) (OUT); \
	const int cb = (B); \
	const int left = VIPS_CLIP( 0, first - oreg-&gt;left, oreg-&gt;width ); \
	const int right = VIPS_CLIP( left, last - oreg-&gt;left, oreg-&gt;width ); \
	int ref_zero; \
	int sec_zero; \
	int x, b; \
	int i; \
	\
	for( i = 0, x = 0; x &lt; left; x++ ) { \
		ref_zero = 0; \
		TEST_ZERO( TYPE, tr, ref_zero ); \
		if( !ref_zero ) \
			for( b = 0; b &lt; cb; b++, i++ ) \
				tq[i] = tr[i]; \
		else \
			for( b = 0; b &lt; cb; b++, i++ ) \
				tq[i] = ts[i]; \
	} \
	\
	for( x = left; x &lt; right; x++ ) { \
		ref_zero = 0; \
		sec_zero = 0; \
		TEST_ZERO( TYPE, tr, ref_zero ); \
		TEST_ZERO( TYPE, ts, sec_zero ); \
		\
		if( !ref_zero &amp;&amp; !sec_zero ) { \
			int inx = ((x + oreg-&gt;left - first) &lt;&lt;  \
				BLEND_SHIFT) / bwidth; \
			int c1 = vips__icoef1[inx]; \
			int c2 = vips__icoef2[inx]; \
			\
			for( b = 0; b &lt; cb; b++, i++ ) \
				tq[i] = c1 * tr[i] / BLEND_SCALE + \
					c2 * ts[i] / BLEND_SCALE; \
		} \
		else if( !ref_zero ) \
			for( b = 0; b &lt; cb; b++, i++ ) \
				tq[i] = tr[i]; \
		else \
			for( b = 0; b &lt; cb; b++, i++ ) \
				tq[i] = ts[i]; \
	} \
	\
	for( x = right; x &lt; oreg-&gt;width; x++ ) { \
		sec_zero = 0; \
		TEST_ZERO( TYPE, ts, sec_zero ); \
		if( !sec_zero ) \
			for( b = 0; b &lt; cb; b++, i++ )  \
				tq[i] = ts[i]; \
		else \
			for( b = 0; b &lt; cb; b++, i++ )  \
				tq[i] = tr[i]; \
	} \
}
#define fblend( TYPE, B, IN1, IN2, OUT ) { \
	TYPE *tr = (TYPE *) (IN1); \
	TYPE *ts = (TYPE *) (IN2); \
	TYPE *tq = (TYPE *) (OUT); \
	const int cb = (B); \
	const int left = VIPS_CLIP( 0, first - oreg-&gt;left, oreg-&gt;width ); \
	const int right = VIPS_CLIP( left, last - oreg-&gt;left, oreg-&gt;width ); \
	int ref_zero; \
	int sec_zero; \
	int x, b; \
	int i; \
	\
	for( i = 0, x = 0; x &lt; left; x++ ) { \
		ref_zero = 0; \
		TEST_ZERO( TYPE, tr, ref_zero ); \
		if( !ref_zero ) \
			for( b = 0; b &lt; cb; b++, i++ ) \
				tq[i] = tr[i]; \
		else \
			for( b = 0; b &lt; cb; b++, i++ ) \
				tq[i] = ts[i]; \
	} \
	\
	for( x = left; x &lt; right; x++ ) { \
		ref_zero = 0; \
		sec_zero = 0; \
		TEST_ZERO( TYPE, tr, ref_zero ); \
		TEST_ZERO( TYPE, ts, sec_zero ); \
		\
		if( !ref_zero &amp;&amp; !sec_zero ) { \
			int inx = ((x + oreg-&gt;left - first) &lt;&lt;  \
				BLEND_SHIFT) / bwidth; \
			double c1 = vips__coef1[inx];  \
			double c2 = vips__coef2[inx];  \
			\
			for( b = 0; b &lt; cb; b++, i++ ) \
				tq[i] = c1 * tr[i] + c2 * ts[i]; \
		} \
		else if( !ref_zero ) \
			for( b = 0; b &lt; cb; b++, i++ ) \
				tq[i] = tr[i]; \
		else \
			for( b = 0; b &lt; cb; b++, i++ ) \
				tq[i] = ts[i]; \
	} \
	\
	for( x = right; x &lt; oreg-&gt;width; x++ ) { \
		sec_zero = 0; \
		TEST_ZERO( TYPE, ts, sec_zero ); \
		if( !sec_zero ) \
			for( b = 0; b &lt; cb; b++, i++ )  \
				tq[i] = ts[i]; \
		else \
			for( b = 0; b &lt; cb; b++, i++ )  \
				tq[i] = tr[i]; \
	} \
}
static int
lr_blend( VipsRegion *or, MergeInfo *inf, Overlapping *ovlap, VipsRect *oreg )
{
	VipsRegion *rir = inf-&gt;rir;
	VipsRegion *sir = inf-&gt;sir;
	VipsImage *im = or-&gt;im;
	VipsRect prr, psr;
	int y, yr, ys;
	if( make_firstlast( inf, ovlap, oreg ) )
		return( -1 );
	prr = *oreg;
	prr.left -= ovlap-&gt;rarea.left;
	prr.top -= ovlap-&gt;rarea.top;
	psr = *oreg;
	psr.left -= ovlap-&gt;sarea.left;
	psr.top -= ovlap-&gt;sarea.top;
	if( vips_region_prepare( rir, &amp;prr ) || 
		vips_region_prepare( sir, &amp;psr ) )
		return( -1 );
	for( y = oreg-&gt;top, yr = prr.top, ys = psr.top; 
		y &lt; VIPS_RECT_BOTTOM( oreg ); y++, yr++, ys++ ) { 
		VipsPel *pr = VIPS_REGION_ADDR( rir, prr.left, yr );
		VipsPel *ps = VIPS_REGION_ADDR( sir, psr.left, ys );
		VipsPel *q = VIPS_REGION_ADDR( or, oreg-&gt;left, y );
		const int j = y - ovlap-&gt;overlap.top;
		const int first = ovlap-&gt;first[j];
		const int last = ovlap-&gt;last[j];
		const int bwidth = last - first;
		switch( im-&gt;BandFmt ) {
		case VIPS_FORMAT_UCHAR: 	
			iblend( unsigned char, im-&gt;Bands, pr, ps, q ); break; 
		case VIPS_FORMAT_CHAR: 	
			iblend( signed char, im-&gt;Bands, pr, ps, q ); break; 
		case VIPS_FORMAT_USHORT: 
			iblend( unsigned short, im-&gt;Bands, pr, ps, q ); break; 
		case VIPS_FORMAT_SHORT: 	
			iblend( signed short, im-&gt;Bands, pr, ps, q ); break; 
		case VIPS_FORMAT_UINT: 	
			iblend( unsigned int, im-&gt;Bands, pr, ps, q ); break; 
		case VIPS_FORMAT_INT: 	
			iblend( signed int, im-&gt;Bands, pr, ps, q );  break; 
		case VIPS_FORMAT_FLOAT: 	
			fblend( float, im-&gt;Bands, pr, ps, q ); break; 
		case VIPS_FORMAT_DOUBLE:	
			fblend( double, im-&gt;Bands, pr, ps, q ); break; 
		case VIPS_FORMAT_COMPLEX:
			fblend( float, im-&gt;Bands * 2, pr, ps, q ); break; 
		case VIPS_FORMAT_DPCOMPLEX:
			fblend( double, im-&gt;Bands * 2, pr, ps, q ); break;
		default:
			g_assert_not_reached();
			return( -1 );
		}
	}
	return( 0 );
}
static int
lr_blend_labpack( VipsRegion *or, MergeInfo *inf, Overlapping *ovlap, 
	VipsRect *oreg )
{
	VipsRegion *rir = inf-&gt;rir;
	VipsRegion *sir = inf-&gt;sir;
	VipsRect prr, psr;
	int y, yr, ys;
	if( make_firstlast( inf, ovlap, oreg ) )
		return( -1 );
	prr = *oreg;
	prr.left -= ovlap-&gt;rarea.left;
	prr.top -= ovlap-&gt;rarea.top;
	psr = *oreg;
	psr.left -= ovlap-&gt;sarea.left;
	psr.top -= ovlap-&gt;sarea.top;
	if( vips_region_prepare( rir, &amp;prr ) || 
		vips_region_prepare( sir, &amp;psr ) )
		return( -1 );
	for( y = oreg-&gt;top, yr = prr.top, ys = psr.top; 
		y &lt; VIPS_RECT_BOTTOM( oreg ); y++, yr++, ys++ ) { 
		VipsPel *pr = VIPS_REGION_ADDR( rir, prr.left, yr );
		VipsPel *ps = VIPS_REGION_ADDR( sir, psr.left, ys );
		VipsPel *q = VIPS_REGION_ADDR( or, oreg-&gt;left, y );
		const int j = y - ovlap-&gt;overlap.top;
		const int first = ovlap-&gt;first[j];
		const int last = ovlap-&gt;last[j];
		const int bwidth = last - first;
		float *fq = inf-&gt;merge;
		float *r = inf-&gt;from1;
		float *s = inf-&gt;from2;
		vips__LabQ2Lab_vec( r, pr, oreg-&gt;width );
		vips__LabQ2Lab_vec( s, ps, oreg-&gt;width );
		fblend( float, 3, r, s, fq ); 
		vips__Lab2LabQ_vec( q, inf-&gt;merge, oreg-&gt;width );
	}
	return( 0 );
}
static void
lock_free( VipsImage *image, GMutex *lock )
{
	VIPS_FREEF( vips_g_mutex_free, lock );
}
Overlapping *
vips__build_mergestate( const char *domain,
	VipsImage *ref, VipsImage *sec, VipsImage *out, 
	int dx, int dy, int mwidth )
{
	VipsImage **t = (VipsImage **)
		vips_object_local_array( VIPS_OBJECT( out ), 4 );
	VipsImage **arry;
   	Overlapping *ovlap;
	int x;
	if( vips_image_pio_input( ref ) ||
		vips_image_pio_input( sec ) ||
		vips_check_bands_1orn( domain, ref, sec ) ||
		vips_check_coding_known( domain, ref ) ||
		vips_check_coding_same( domain, ref, sec ) )
		return( NULL );
	if( vips__formatalike( ref, sec, &amp;t[0], &amp;t[1] ) ||
		vips__bandalike( domain, t[0], t[1], &amp;t[2], &amp;t[3] ) )
		return( NULL );
	if( !(arry = vips_allocate_input_array( out,
		t[2], t[3], NULL )) )
		return( NULL );
	if( vips_image_pipeline_array( out,
		VIPS_DEMAND_STYLE_SMALLTILE, arry ) )
		return( NULL );
	if( mwidth &lt; -1 ) {
		vips_error( domain, "%s", _( "mwidth must be -1 or &gt;= 0" ) );
		return( NULL );
	}
<a name="0"></a>	if( !(ovlap = VIPS_NEW( out, Overlapping )) )
		return( NULL );
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	ovlap-&gt;ref = arry[0];
	ovlap-&gt;sec = arry[1];
	ovlap-&gt;out = out;
	ovlap-&gt;dx = dx;
	ovlap-&gt;dy = dy;
	ovlap-&gt;mwidth = mwidth;
   	ovlap-&gt;rarea.left = 0;
   	ovlap-&gt;rarea.top = 0;
   	ovlap-&gt;rarea.width = ovlap-&gt;ref-&gt;Xsize;
   	ovlap-&gt;rarea.height = ovlap-&gt;ref-&gt;Ysize;
   	ovlap-&gt;sarea.left = -dx;
   	ovlap-&gt;sarea.top = -dy;
   	ovlap-&gt;sarea.width = ovlap-&gt;sec-&gt;Xsize;
   	ovlap-&gt;sarea.height = ovlap-&gt;sec-&gt;Ysize;</b></font>
	vips_rect_intersectrect( &amp;ovlap-&gt;rarea, &amp;ovlap-&gt;sarea, &amp;ovlap-&gt;overlap );
	if( vips_rect_isempty( &amp;ovlap-&gt;overlap ) ) {
		vips_error( domain, "%s", _( "no overlap" ) );
		return( NULL );
	}
	vips_rect_unionrect( &amp;ovlap-&gt;rarea, &amp;ovlap-&gt;sarea, &amp;ovlap-&gt;oarea );
	ovlap-&gt;rarea.left -= ovlap-&gt;oarea.left;
	ovlap-&gt;rarea.top -= ovlap-&gt;oarea.top;
	ovlap-&gt;sarea.left -= ovlap-&gt;oarea.left;
	ovlap-&gt;sarea.top -= ovlap-&gt;oarea.top;
	ovlap-&gt;overlap.left -= ovlap-&gt;oarea.left;
	ovlap-&gt;overlap.top -= ovlap-&gt;oarea.top;
	ovlap-&gt;oarea.left = 0;
	ovlap-&gt;oarea.top = 0;
	vips__make_blend_luts();
	ovlap-&gt;flsize = VIPS_MAX( ovlap-&gt;overlap.width, ovlap-&gt;overlap.height );
	ovlap-&gt;first = VIPS_ARRAY( out, ovlap-&gt;flsize, int );
	ovlap-&gt;last = VIPS_ARRAY( out, ovlap-&gt;flsize, int );
	if( !ovlap-&gt;first || !ovlap-&gt;last ) 
		return( NULL ); 
	for( x = 0; x &lt; ovlap-&gt;flsize; x++ )
		ovlap-&gt;first[x] = -1;
	ovlap-&gt;fl_lock = vips_g_mutex_new();
	g_signal_connect( out, "close",
		G_CALLBACK( lock_free ), ovlap-&gt;fl_lock );
	return( ovlap );
}
static Overlapping *
build_lrstate( VipsImage *ref, VipsImage *sec, VipsImage *out, 
	int dx, int dy, int mwidth )
{
   	Overlapping *ovlap;
	if( !(ovlap = vips__build_mergestate( "lrmerge", 
		ref, sec, out, dx, dy, mwidth )) )
		return( NULL );
	switch( ovlap-&gt;ref-&gt;Coding ) {
	case VIPS_CODING_LABQ:
		ovlap-&gt;blend = lr_blend_labpack;
		break;
	case VIPS_CODING_NONE:
		ovlap-&gt;blend = lr_blend;
		break;
	default:
		vips_error( "lrmerge", "%s", _( "unknown coding type" ) );
		return( NULL );
	}
	ovlap-&gt;rpart = ovlap-&gt;rarea;
	ovlap-&gt;spart = ovlap-&gt;sarea;
	ovlap-&gt;rpart.width -= ovlap-&gt;overlap.width;
	ovlap-&gt;spart.left += ovlap-&gt;overlap.width;
	ovlap-&gt;spart.width -= ovlap-&gt;overlap.width;
	if( VIPS_RECT_RIGHT( &amp;ovlap-&gt;rarea ) &gt; 
		VIPS_RECT_RIGHT( &amp;ovlap-&gt;sarea ) ||
		ovlap-&gt;rarea.left &gt; ovlap-&gt;sarea.left ) {
		vips_error( "lrmerge", "%s", _( "too much overlap" ) );
		return( NULL );
	}
	ovlap-&gt;blsize = ovlap-&gt;overlap.width;
	return( ovlap );
}
int
vips__attach_input( VipsRegion *or, VipsRegion *ir, VipsRect *area )
{
	VipsRect r = or-&gt;valid;
	r.left -= area-&gt;left;
	r.top -= area-&gt;top;
	if( vips_region_prepare( ir, &amp;r ) )
		return( -1 );
	if( vips_region_region( or, ir, &amp;or-&gt;valid, r.left, r.top ) )
		 return( -1 );
	return( 0 );
}
int
vips__copy_input( VipsRegion *or, VipsRegion *ir, 
	VipsRect *area, VipsRect *reg )
{
	VipsRect r = *reg;
	r.left -= area-&gt;left;
	r.top -= area-&gt;top;
	if( vips_region_prepare_to( ir, or, &amp;r, reg-&gt;left, reg-&gt;top ) )
		return( -1 );
	return( 0 );
}
int
vips__merge_gen( VipsRegion *or, void *seq, void *a, void *b, 
	gboolean *stop )
{
	MergeInfo *inf = (MergeInfo *) seq;
	Overlapping *ovlap = (Overlapping *) a;
	VipsRect *r = &amp;or-&gt;valid;
	VipsRect rreg, sreg, oreg;
	vips_rect_intersectrect( r, &amp;ovlap-&gt;rpart, &amp;rreg );
	vips_rect_intersectrect( r, &amp;ovlap-&gt;spart, &amp;sreg );
	if( vips_rect_equalsrect( r, &amp;rreg ) ) {
		if( vips__attach_input( or, inf-&gt;rir, &amp;ovlap-&gt;rarea ) )
			return( -1 );
	}
	else if( vips_rect_equalsrect( r, &amp;sreg ) ) {
		if( vips__attach_input( or, inf-&gt;sir, &amp;ovlap-&gt;sarea ) )
			return( -1 );
	}
	else {
		vips_rect_intersectrect( r, &amp;ovlap-&gt;rarea, &amp;rreg );
		vips_rect_intersectrect( r, &amp;ovlap-&gt;sarea, &amp;sreg );
		vips_rect_intersectrect( r, &amp;ovlap-&gt;overlap, &amp;oreg );
		vips_region_black( or );
		if( !vips_rect_isempty( &amp;rreg ) ) 
			if( vips__copy_input( or, 
				inf-&gt;rir, &amp;ovlap-&gt;rarea, &amp;rreg ) )
				return( -1 );
		if( !vips_rect_isempty( &amp;sreg ) )
			if( vips__copy_input( or, 
				inf-&gt;sir, &amp;ovlap-&gt;sarea, &amp;sreg ) )
				return( -1 );
		inf-&gt;rir-&gt;valid.width = inf-&gt;sir-&gt;valid.width = 0;
		if( !vips_rect_isempty( &amp;oreg ) )
			if( ovlap-&gt;blend( or, inf, ovlap, &amp;oreg ) )
				return( -1 );
	}
	return( 0 );
}
int
vips__stop_merge( void *seq, void *a, void *b )
{
	MergeInfo *inf = (MergeInfo *) seq;
	VIPS_UNREF( inf-&gt;rir );
	VIPS_UNREF( inf-&gt;sir );
	VIPS_FREE( inf-&gt;from1 );
	VIPS_FREE( inf-&gt;from2 );
	VIPS_FREE( inf-&gt;merge );
	g_free( inf );
	return( 0 );
}
void *
vips__start_merge( VipsImage *out, void *a, void *b )
{
	Overlapping *ovlap = (Overlapping *) a;
<a name="1"></a>	MergeInfo *inf;
	if( !(inf = VIPS_NEW( NULL, MergeInfo )) )
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		return( NULL );
	inf-&gt;rir = NULL;
	inf-&gt;sir = NULL;
	inf-&gt;from1 = NULL;
	inf-&gt;from2 = NULL;
	inf-&gt;merge = NULL;
	if( out-&gt;Coding == VIPS_CODING_LABQ ) {</b></font>
		inf-&gt;from1 = VIPS_ARRAY( NULL, ovlap-&gt;blsize * 3, float );
		inf-&gt;from2 = VIPS_ARRAY( NULL, ovlap-&gt;blsize * 3, float );
		inf-&gt;merge = VIPS_ARRAY( NULL, ovlap-&gt;blsize * 3, float );
		if( !inf-&gt;from1 || !inf-&gt;from2 || !inf-&gt;merge ) {
			vips__stop_merge( inf, NULL, NULL );
			return( NULL ); 
		}
	}
	inf-&gt;rir = vips_region_new( ovlap-&gt;ref );
	inf-&gt;sir = vips_region_new( ovlap-&gt;sec );
	if( !inf-&gt;rir || !inf-&gt;sir ) {
		vips__stop_merge( inf, NULL, NULL );
		return( NULL );
	}
	return( inf );
}
int
vips__lrmerge( VipsImage *ref, VipsImage *sec, VipsImage *out, 
	int dx, int dy, int mwidth )
{
	Overlapping *ovlap;
#ifdef DEBUG
	printf( "lrmerge %s %s %s %d %d %d\n", 
		ref-&gt;filename, sec-&gt;filename, out-&gt;filename, 
		dx, dy, mwidth );
	printf( "ref is %d x %d pixels\n", ref-&gt;Xsize, ref-&gt;Ysize );
	printf( "sec is %d x %d pixels\n", sec-&gt;Xsize, sec-&gt;Ysize );
#endif
	if( dx &gt; 0 || dx &lt; 1 - ref-&gt;Xsize ) {
		VipsImage *x;
#ifdef DEBUG
		printf( "lrmerge: no overlap, using insert\n" ); 
#endif
  		if( vips_insert( ref, sec, &amp;x, -dx, -dy,
  			"expand", TRUE,
			NULL ) )
			return( -1 );
		if( vips_image_write( x, out ) ) {
			g_object_unref( x );
			return( -1 );
		}
		g_object_unref( x );
		out-&gt;Xoffset = -dx;
		out-&gt;Yoffset = -dy;
		return( 0 );
	}
	if( !(ovlap = build_lrstate( ref, sec, out, dx, dy, mwidth )) )
		return( -1 );
	if( vips_image_pipelinev( out,
		VIPS_DEMAND_STYLE_THINSTRIP, ovlap-&gt;ref, ovlap-&gt;sec, NULL ) )
		return( -1 );
	out-&gt;Xsize = ovlap-&gt;oarea.width;
	out-&gt;Ysize = ovlap-&gt;oarea.height;
	out-&gt;Xoffset = -dx;
	out-&gt;Yoffset = -dy;
	if( vips_image_generate( out,
		vips__start_merge, vips__merge_gen, vips__stop_merge, 
		ovlap, NULL ) )
		return( -1 );
	return ( 0 );
}
const char *
vips__get_mosaic_name( VipsImage *image )
{
	const char *name;
	if( vips_image_get_typeof( image, "mosaic-name" ) ) {
		if( vips_image_get_string( image, "mosaic-name", &amp;name ) )
			return( NULL );
	}
	else 
		name = image-&gt;filename;
	return( name ); 
}
void
vips__add_mosaic_name( VipsImage *image )
{
	static int global_serial = 0;
	int serial = g_atomic_int_add( &amp;global_serial, 1 );
	char name[256];
	vips_snprintf( name, 256, "mosaic-temp-%d", serial );
	vips_image_set_string( image, "mosaic-name", name );
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>image.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#include &lt;vips/intl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#ifdef HAVE_UNISTD_H
#include &lt;unistd.h&gt;
#include &lt;ctype.h&gt;
#include &lt;vips/vips.h&gt;
#include &lt;vips/internal.h&gt;
#include &lt;vips/debug.h&gt;
enum {
	SIG_PREEVAL,		
	SIG_EVAL,		
	SIG_POSTEVAL,		
	SIG_WRITTEN,		
	SIG_INVALIDATE,		
	SIG_MINIMISE,		
	SIG_LAST
};
int vips__progress = 0;
char *vips__disc_threshold = NULL;
static GMutex *vips__minimise_lock = NULL;
static guint vips_image_signals[SIG_LAST] = { 0 };
G_DEFINE_TYPE( VipsImage, vips_image, VIPS_TYPE_OBJECT );
void
vips_progress_set( gboolean progress )
{
	vips__progress = progress;
}
static void
vips_image_delete( VipsImage *image )
{
	if( image-&gt;delete_on_close ) {
		g_assert( image-&gt;delete_on_close_filename );
		VIPS_DEBUG_MSG( "vips_image_delete: removing temp %s\n", 
				image-&gt;delete_on_close_filename );
		g_unlink( image-&gt;delete_on_close_filename );
		VIPS_FREE( image-&gt;delete_on_close_filename );
		image-&gt;delete_on_close = FALSE;
	}
}
static void
vips_image_finalize( GObject *gobject )
{
	VipsImage *image = VIPS_IMAGE( gobject );
	VIPS_DEBUG_MSG( "vips_image_finalize: %p\n", gobject );
	g_assert( !image-&gt;regions );
	g_assert( !image-&gt;windows );
	image-&gt;start_fn = NULL;
	image-&gt;generate_fn = NULL;
	image-&gt;stop_fn = NULL;
	image-&gt;client1 = NULL;
	image-&gt;client2 = NULL;
	vips__link_break_all( image );
	if( image-&gt;time ) {
		VIPS_FREEF( g_timer_destroy, image-&gt;time-&gt;start );
		VIPS_FREE( image-&gt;time );
	}
	if( image-&gt;data ) {
		if( image-&gt;dtype == VIPS_IMAGE_SETBUF ) {
			VIPS_DEBUG_MSG( "vips_image_finalize: "
				"freeing buffer\n" );
			vips_tracked_free( image-&gt;data );
			image-&gt;dtype = VIPS_IMAGE_NONE;
		}
		image-&gt;data = NULL;
	}
	vips_image_delete( image );
	VIPS_FREEF( vips_g_mutex_free, image-&gt;sslock );
	VIPS_FREE( image-&gt;Hist );
	VIPS_FREEF( vips__gslist_gvalue_free, image-&gt;history_list );
	vips__meta_destroy( image );
	G_OBJECT_CLASS( vips_image_parent_class )-&gt;finalize( gobject );
}
static void
vips_image_dispose( GObject *gobject )
{
	VipsImage *image = VIPS_IMAGE( gobject );
	VIPS_DEBUG_MSG( "vips_image_dispose: %p\n", gobject );
#ifdef DEBUG_LEAK
{
	VipsImagePixels *pixels = g_object_get_qdata( G_OBJECT( image ), 
		vips__image_pixels_quark ); 
	if( pixels &amp;&amp;
		pixels-&gt;tpels ) {
		int compute_percent = 100.0 * pixels-&gt;npels / pixels-&gt;tpels;
		if( compute_percent &gt; 100 ) 
			printf( "vips_image_dispose: %s %s computed %d%%\n", 
				image-&gt;filename, 
				pixels-&gt;nickname, 
				compute_percent );
	}
}
	vips_object_preclose( VIPS_OBJECT( gobject ) );
	if( image-&gt;baseaddr ) {
		VIPS_DEBUG_MSG( "vips_image_dispose: unmapping file\n" );
		vips__munmap( image-&gt;baseaddr, image-&gt;length );
		image-&gt;baseaddr = NULL;
		image-&gt;length = 0;
		image-&gt;data = NULL;
	}
	if( image-&gt;fd != -1 ) {
		VIPS_DEBUG_MSG( "vips_image_dispose: closing output file\n" );
		if( vips_tracked_close( image-&gt;fd ) == -1 ) 
			vips_error( "VipsImage", 
				"%s", _( "unable to close fd" ) );
		image-&gt;fd = -1;
	}
	G_OBJECT_CLASS( vips_image_parent_class )-&gt;dispose( gobject );
}
static VipsObject *
vips_image_new_from_file_object( const char *string )
{
	VipsImage *image;
	vips_check_init();
	image = VIPS_IMAGE( g_object_new( VIPS_TYPE_IMAGE, NULL ) );
	g_object_set( image,
		"filename", string,
		"mode", "r",
		NULL );
	return( VIPS_OBJECT( image ) );
}
static void
vips_image_to_string( VipsObject *object, VipsBuf *buf )
{
	VipsImage *image = VIPS_IMAGE( object );
	vips_buf_appends( buf, image-&gt;filename );
}
static int 
vips_image_write_object( VipsObject *object, const char *string )
{
	return( vips_image_write_to_file( VIPS_IMAGE( object ), string, 
		NULL ) );
}
static void *
print_field_fn( VipsImage *image, const char *field, GValue *value, void *a )
{
	VipsBuf *buf = (VipsBuf *) a;
	vips_buf_appendf( buf, "%s: ", field );
	vips_buf_appendgv( buf, value );
	vips_buf_appendf( buf, "\n" );
	return( NULL );
}
static void
vips_image_dump( VipsObject *object, VipsBuf *buf )
{
	VipsImage *image = VIPS_IMAGE( object );
	vips_buf_appendf( buf, 
		ngettext( 
			"%dx%d %s, %d band, %s", 
			"%dx%d %s, %d bands, %s", 
			vips_image_get_bands( image ) ),
		vips_image_get_width( image ),
		vips_image_get_height( image ),
		vips_enum_nick( VIPS_TYPE_BAND_FORMAT, 
			vips_image_get_format( image ) ),
		vips_image_get_bands( image ),
		vips_enum_nick( VIPS_TYPE_INTERPRETATION, 
			vips_image_get_interpretation( image ) ) );
	vips_buf_appendf( buf, ", %s", 
		vips_enum_nick( VIPS_TYPE_IMAGE_TYPE, image-&gt;dtype ) );
	VIPS_OBJECT_CLASS( vips_image_parent_class )-&gt;dump( object, buf );
	vips_buf_appendf( buf, "\n" );
	(void) vips_image_map( image, print_field_fn, (void *) buf );
	vips_buf_appendf( buf, "Hist: %s", vips_image_get_history( image ) );
}
static void
vips_image_summary( VipsObject *object, VipsBuf *buf )
{
	VipsImage *image = VIPS_IMAGE( object );
	const char *p;
	vips_buf_appendf( buf, "%dx%d",
		vips_image_get_width( image ), vips_image_get_height( image ) );
	if( vips_image_get_coding( image ) == VIPS_CODING_NONE ) {
		vips_buf_appendf( buf, 
			ngettext( 
				" %s, %d band, %s", 
				" %s, %d bands, %s", 
				vips_image_get_bands( image ) ),
			vips_enum_nick( VIPS_TYPE_BAND_FORMAT, 
				vips_image_get_format( image ) ),
			vips_image_get_bands( image ),
			vips_enum_nick( VIPS_TYPE_INTERPRETATION, 
				vips_image_get_interpretation( image ) ) );
	}
	else {
		vips_buf_appendf( buf, ", %s",
			vips_enum_nick( VIPS_TYPE_CODING, 
				vips_image_get_coding( image ) ) );
	}
	if( vips_image_get_typeof( image, VIPS_META_LOADER ) &amp;&amp;
		!vips_image_get_string( image, VIPS_META_LOADER, &amp;p ) ) 
		vips_buf_appendf( buf, ", %s", p );
	VIPS_OBJECT_CLASS( vips_image_parent_class )-&gt;summary( object, buf );
}
static void *
vips_image_sanity_upstream( VipsImage *up, VipsImage *down, void *b )
{
	if( !g_slist_find( up-&gt;downstream, down ) ||
		!g_slist_find( down-&gt;upstream, up ) )
		return( up );
	return( NULL );
}
static void *
vips_image_sanity_downstream( VipsImage *down, VipsImage *up, void *b )
{
	return( vips_image_sanity_upstream( up, down, b ) );
}
static void
vips_image_sanity( VipsObject *object, VipsBuf *buf )
{
	VipsImage *image = VIPS_IMAGE( object );
	if( image-&gt;Xsize != 0 ||
		image-&gt;Ysize != 0 ||
		image-&gt;Bands != 0 ) {
		if( image-&gt;Xsize &lt;= 0 || 
			image-&gt;Ysize &lt;= 0 || 
			image-&gt;Bands &lt;= 0 ) 
			vips_buf_appends( buf, "bad dimensions\n" );
		if( image-&gt;BandFmt &lt; -1 || 
			image-&gt;BandFmt &gt; VIPS_FORMAT_DPCOMPLEX ||
			(image-&gt;Coding != -1 &amp;&amp;
				image-&gt;Coding != VIPS_CODING_NONE &amp;&amp; 
				image-&gt;Coding != VIPS_CODING_LABQ &amp;&amp;
				image-&gt;Coding != VIPS_CODING_RAD) ||
			image-&gt;Type &gt;= VIPS_INTERPRETATION_LAST ||
			image-&gt;dtype &gt; VIPS_IMAGE_PARTIAL || 
			image-&gt;dhint &gt; VIPS_DEMAND_STYLE_ANY ) 
			vips_buf_appends( buf, "bad enum\n" );
		if( image-&gt;Xres &lt; 0 || 
			image-&gt;Yres &lt; 0 ) 
			vips_buf_appends( buf, "bad resolution\n" );
	}
	g_mutex_lock( vips__global_lock );
	if( vips_slist_map2( image-&gt;upstream, 
		(VipsSListMap2Fn) vips_image_sanity_upstream, image, NULL ) )
		vips_buf_appends( buf, "upstream broken\n" );
	if( vips_slist_map2( image-&gt;downstream, 
		(VipsSListMap2Fn) vips_image_sanity_downstream, image, NULL ) )
		vips_buf_appends( buf, "downstream broken\n" );
	g_mutex_unlock( vips__global_lock );
	VIPS_OBJECT_CLASS( vips_image_parent_class )-&gt;sanity( object, buf );
}
static void
vips_image_rewind( VipsObject *object )
{
	VipsImage *image = VIPS_IMAGE( object );
	char *filename;
	char *mode;
	filename = g_strdup( vips_image_get_filename( image ) );
	mode = g_strdup( vips_image_get_mode( image ) );
	VIPS_OBJECT_CLASS( vips_image_parent_class )-&gt;rewind( object );
	g_assert( image-&gt;filename == NULL );
	g_assert( image-&gt;mode == NULL );
	image-&gt;filename = filename;
	image-&gt;mode = mode;
}
static void
vips_image_save_cb( VipsImage *image, int *result, void *data )
{
	if( vips_foreign_save( image, image-&gt;filename, NULL ) )
		*result = -1;
}
static void
vips_image_preeval_cb( VipsImage *image, VipsProgress *progress, int *last )
{
	int tile_width; 
	int tile_height; 
	int n_lines;
	*last = -1;
	vips_get_tile_size( image, 
		&amp;tile_width, &amp;tile_height, &amp;n_lines );
	printf( _( "%s %s: %d x %d pixels, %d threads, %d x %d tiles, "
		"%d lines in buffer" ),
		vips_get_prgname(), image-&gt;filename,
		image-&gt;Xsize, image-&gt;Ysize,
		vips_concurrency_get(),
		tile_width, tile_height, n_lines );
	printf( "\n" );
}
static void
vips_image_eval_cb( VipsImage *image, VipsProgress *progress, int *last )
{
	if( progress-&gt;percent != *last ) {
		printf( _( "%s %s: %d%% complete" ), 
			vips_get_prgname(), image-&gt;filename, 
			progress-&gt;percent );
		printf( "\r" ); 
		fflush( stdout );
		*last = progress-&gt;percent;
	}
}
static void
vips_image_posteval_cb( VipsImage *image, VipsProgress *progress, void *data )
{
	printf( _( "%s %s: done in %.3gs          \n" ), 
		vips_get_prgname(), image-&gt;filename, 
		g_timer_elapsed( progress-&gt;start, NULL ) );
}
static void
vips_image_add_progress( VipsImage *image )
{
	if( vips__progress || 
		g_getenv( "VIPS_PROGRESS" )
#if ENABLE_DEPRECATED
		|| g_getenv( "IM_PROGRESS" )
#endif
		) {
		int *last = VIPS_NEW( image, int );
		g_signal_connect( image, "preeval", 
			G_CALLBACK( vips_image_preeval_cb ), last );
		g_signal_connect( image, "eval", 
			G_CALLBACK( vips_image_eval_cb ), last );
		g_signal_connect( image, "posteval", 
			G_CALLBACK( vips_image_posteval_cb ), NULL );
		vips_image_set_progress( image, TRUE );
	}
}
static int
vips_image_build( VipsObject *object )
{
	VipsImage *image = VIPS_IMAGE( object );
	const char *filename = image-&gt;filename;
	const char *mode = image-&gt;mode;
	guint32 magic;
	guint64 sizeof_image;
	VIPS_DEBUG_MSG( "vips_image_build: %p\n", image );
	if( VIPS_OBJECT_CLASS( vips_image_parent_class )-&gt;build( object ) )
		return( -1 );
	switch( mode[0] ) {
        case 'v':
		if( vips_image_open_input( image ) )
			return( -1 );
		break;
        case 'r':
		if( (magic = vips__file_magic( filename )) ) {
			if( GUINT_FROM_BE( magic ) == image-&gt;magic ) {
				if( vips_image_open_input( image ) )
					return( -1 );
			}
			else {
				VipsImage *t; 
				VipsImage *t2;
				if( !(t = vips_image_new_mode( filename, 
					"v" )) )
					return( -1 );
				if( vips_byteswap( t, &amp;t2, NULL ) ) {
					g_object_unref( t );
					return( -1 );
				}
				g_object_unref( t );
				image-&gt;dtype = VIPS_IMAGE_PARTIAL;
				if( vips_image_write( t2, image ) ) {
					g_object_unref( t2 );
					return( -1 );
				}
				g_object_unref( t2 );
			}
		}
		else {
			VipsImage *t;
			if( mode[1] == 's' ) {
				if( vips_foreign_load( filename, &amp;t, 
					"access", VIPS_ACCESS_SEQUENTIAL,
					NULL ) )
					return( -1 );
			}
			else {
				if( vips_foreign_load( filename, &amp;t, NULL ) )
					return( -1 );
			}
			image-&gt;dtype = VIPS_IMAGE_PARTIAL;
			if( vips_image_write( t, image ) ) {
				g_object_unref( t );
				return( -1 );
			}
			g_object_unref( t );
		}
        	break;
	case 'w':
{
		const char *file_op;
		g_assert( g_type_from_name( "VipsForeignSaveVips" ) );
		if( !(file_op = vips_foreign_find_save( filename )) )
			return( -1 );
		if( vips_isprefix( "VipsForeignSaveVips", file_op ) )
			image-&gt;dtype = VIPS_IMAGE_OPENOUT;
		else {
			image-&gt;dtype = VIPS_IMAGE_PARTIAL;
			g_signal_connect( image, "written", 
				G_CALLBACK( vips_image_save_cb ), 
				NULL );
		}
}
        	break;
        case 't':
		image-&gt;dtype = VIPS_IMAGE_SETBUF;
		image-&gt;dhint = VIPS_DEMAND_STYLE_ANY;
                break;
        case 'p':
		image-&gt;dtype = VIPS_IMAGE_PARTIAL;
                break;
	case 'a':
		if( (image-&gt;fd = vips__open_image_read( filename )) == -1 ) 
			return( -1 );
		image-&gt;dtype = VIPS_IMAGE_OPENIN;
		image-&gt;dhint = VIPS_DEMAND_STYLE_THINSTRIP;
		if( image-&gt;Bands == 1 )
			image-&gt;Type = VIPS_INTERPRETATION_B_W;
		else if( image-&gt;Bands == 3 )
			image-&gt;Type = VIPS_INTERPRETATION_sRGB;
		else 
			image-&gt;Type = VIPS_INTERPRETATION_MULTIBAND;
		if( (image-&gt;file_length = vips_file_length( image-&gt;fd )) == -1 )
			return( -1 );
		sizeof_image = VIPS_IMAGE_SIZEOF_IMAGE( image ) + 
			image-&gt;sizeof_header;
		if( image-&gt;file_length &lt; sizeof_image ) {
			vips_error( "VipsImage", 
				_( "unable to open \"%s\", file too short" ), 
				image-&gt;filename );
			return( -1 );
		}
		if( image-&gt;file_length &gt; sizeof_image ) 
			g_warning( _( "%s is longer than expected" ),
				image-&gt;filename );
		break;
	case 'm':
		if( image-&gt;Bands == 1 )
			image-&gt;Type = VIPS_INTERPRETATION_B_W;
		else if( image-&gt;Bands == 3 )
			image-&gt;Type = VIPS_INTERPRETATION_sRGB;
		else 
			image-&gt;Type = VIPS_INTERPRETATION_MULTIBAND;
		image-&gt;dtype = VIPS_IMAGE_SETBUF_FOREIGN;
		image-&gt;dhint = VIPS_DEMAND_STYLE_ANY;
		break;
	default:
		vips_error( "VipsImage", _( "bad mode \"%s\"" ), mode );
		return( -1 );
        }
	vips_image_add_progress( image );
	return( 0 );
}
static void *
vips_image_real_invalidate_cb( VipsRegion *reg, void *a, void *b )
{
	vips_region_invalidate( reg );
	return( NULL );
}
static void 
vips_image_real_invalidate( VipsImage *image, void *data )
{
	VIPS_DEBUG_MSG( "vips_image_real_invalidate: %p\n", image );
	VIPS_GATE_START( "vips_image_real_invalidate: wait" );
	g_mutex_lock( image-&gt;sslock );
	VIPS_GATE_STOP( "vips_image_real_invalidate: wait" );
	(void) vips_slist_map2( image-&gt;regions,
		(VipsSListMap2Fn) vips_image_real_invalidate_cb, NULL, NULL );
	g_mutex_unlock( image-&gt;sslock );
}
static void 
vips_image_real_minimise( VipsImage *image, void *data )
{
	VIPS_DEBUG_MSG( "vips_image_real_minimise: %p\n", image );
}
static void 
vips_image_real_written( VipsImage *image, int *result, void *data )
{
	VIPS_DEBUG_MSG( "vips_image_real_written: %p\n", image );
	if( image-&gt;dtype == VIPS_IMAGE_OPENOUT &amp;&amp;
		vips__writehist( image ) ) 
		*result = -1;
}
static void
vips_image_class_init( VipsImageClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
	VIPS_DEBUG_MSG( "vips_image_class_init:\n" );
	vips_check_init(); 
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	gobject_class-&gt;finalize = vips_image_finalize;
	gobject_class-&gt;dispose = vips_image_dispose;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	vobject_class-&gt;new_from_string = vips_image_new_from_file_object;
	vobject_class-&gt;to_string = vips_image_to_string;
	vobject_class-&gt;output_needs_arg = TRUE;
	vobject_class-&gt;output_to_arg = vips_image_write_object;
	vobject_class-&gt;nickname = "image";
	vobject_class-&gt;description = _( "image class" );
	vobject_class-&gt;dump = vips_image_dump;
	vobject_class-&gt;summary = vips_image_summary;
	vobject_class-&gt;sanity = vips_image_sanity;
	vobject_class-&gt;rewind = vips_image_rewind;</b></font>
	vobject_class-&gt;build = vips_image_build;
	class-&gt;invalidate = vips_image_real_invalidate;
	class-&gt;written = vips_image_real_written;
	class-&gt;minimise = vips_image_real_minimise;
	VIPS_ARG_INT( class, "width", 2, 
		_( "Width" ), 
		_( "Image width in pixels" ),
		VIPS_ARGUMENT_SET_ALWAYS,
		G_STRUCT_OFFSET( VipsImage, Xsize ),
		1, VIPS_MAX_COORD, 1 );
	VIPS_ARG_INT( class, "height", 3, 
		_( "Height" ), 
		_( "Image height in pixels" ),
		VIPS_ARGUMENT_SET_ALWAYS,
		G_STRUCT_OFFSET( VipsImage, Ysize ),
		1, VIPS_MAX_COORD, 1 );
	VIPS_ARG_INT( class, "bands", 4, 
		_( "Bands" ), 
		_( "Number of bands in image" ),
		VIPS_ARGUMENT_SET_ALWAYS,
		G_STRUCT_OFFSET( VipsImage, Bands ),
		1, VIPS_MAX_COORD, 1 );
	VIPS_ARG_ENUM( class, "format", 5, 
		_( "Format" ), 
		_( "Pixel format in image" ),
		VIPS_ARGUMENT_SET_ALWAYS,
		G_STRUCT_OFFSET( VipsImage, BandFmt ),
		VIPS_TYPE_BAND_FORMAT, VIPS_FORMAT_UCHAR ); 
	VIPS_ARG_ENUM( class, "coding", 6, 
		_( "Coding" ), 
		_( "Pixel coding" ),
		VIPS_ARGUMENT_SET_ALWAYS,
		G_STRUCT_OFFSET( VipsImage, Coding ),
		VIPS_TYPE_CODING, VIPS_CODING_NONE ); 
	VIPS_ARG_ENUM( class, "interpretation", 7, 
		_( "Interpretation" ), 
		_( "Pixel interpretation" ),
		VIPS_ARGUMENT_SET_ALWAYS,
		G_STRUCT_OFFSET( VipsImage, Type ),
		VIPS_TYPE_INTERPRETATION, VIPS_INTERPRETATION_MULTIBAND ); 
	VIPS_ARG_DOUBLE( class, "xres", 8, 
		_( "Xres" ), 
		_( "Horizontal resolution in pixels/mm" ),
		VIPS_ARGUMENT_SET_ALWAYS,
		G_STRUCT_OFFSET( VipsImage, Xres ),
		-0.0, 1000000, 0 );
	VIPS_ARG_DOUBLE( class, "yres", 9, 
		_( "Yres" ), 
		_( "Vertical resolution in pixels/mm" ),
		VIPS_ARGUMENT_SET_ALWAYS,
		G_STRUCT_OFFSET( VipsImage, Yres ),
		-0.0, 1000000, 0 );
	VIPS_ARG_INT( class, "xoffset", 10, 
		_( "Xoffset" ), 
		_( "Horizontal offset of origin" ),
		VIPS_ARGUMENT_SET_ALWAYS,
		G_STRUCT_OFFSET( VipsImage, Xoffset ),
		-VIPS_MAX_COORD, VIPS_MAX_COORD, 0 );
	VIPS_ARG_INT( class, "yoffset", 11, 
		_( "Yoffset" ), 
		_( "Vertical offset of origin" ),
		VIPS_ARGUMENT_SET_ALWAYS,
		G_STRUCT_OFFSET( VipsImage, Yoffset ),
		-VIPS_MAX_COORD, VIPS_MAX_COORD, 0 );
	VIPS_ARG_STRING( class, "filename", 12, 
		_( "Filename" ),
		_( "Image filename" ),
		VIPS_ARGUMENT_SET_ONCE | VIPS_ARGUMENT_CONSTRUCT, 
		G_STRUCT_OFFSET( VipsImage, filename ),
		NULL );
	VIPS_ARG_STRING( class, "mode", 13, 
		_( "Mode" ),
		_( "Open mode" ),
		VIPS_ARGUMENT_SET_ONCE | VIPS_ARGUMENT_CONSTRUCT, 
		G_STRUCT_OFFSET( VipsImage, mode ),
		"p" );
	VIPS_ARG_BOOL( class, "kill", 14, 
		_( "Kill" ),
		_( "Block evaluation on this image" ),
		VIPS_ARGUMENT_SET_ALWAYS, 
		G_STRUCT_OFFSET( VipsImage, kill ),
		FALSE );
	VIPS_ARG_ENUM( class, "demand", 15, 
		_( "Demand style" ), 
		_( "Preferred demand style for this image" ),
		VIPS_ARGUMENT_CONSTRUCT,
		G_STRUCT_OFFSET( VipsImage, dhint ),
		VIPS_TYPE_DEMAND_STYLE, VIPS_DEMAND_STYLE_SMALLTILE );
	VIPS_ARG_UINT64( class, "sizeof_header", 16, 
		_( "Size of header" ), 
		_( "Offset in bytes from start of file" ),
		VIPS_ARGUMENT_SET_ONCE | VIPS_ARGUMENT_CONSTRUCT, 
		G_STRUCT_OFFSET( VipsImage, sizeof_header ),
		0, 1000000000, VIPS_SIZEOF_HEADER );
	VIPS_ARG_POINTER( class, "foreign_buffer", 17, 
		_( "Foreign buffer" ),
		_( "Pointer to foreign pixels" ),
		VIPS_ARGUMENT_SET_ONCE | VIPS_ARGUMENT_CONSTRUCT, 
		G_STRUCT_OFFSET( VipsImage, data ) );
	vips_image_signals[SIG_PREEVAL] = g_signal_new( "preeval",
		G_TYPE_FROM_CLASS( class ),
		G_SIGNAL_RUN_LAST,
		G_STRUCT_OFFSET( VipsImageClass, preeval ), 
		NULL, NULL,
		g_cclosure_marshal_VOID__POINTER,
		G_TYPE_NONE, 1,
		G_TYPE_POINTER );
	vips_image_signals[SIG_EVAL] = g_signal_new( "eval",
		G_TYPE_FROM_CLASS( class ),
		G_SIGNAL_RUN_LAST,
		G_STRUCT_OFFSET( VipsImageClass, eval ), 
		NULL, NULL,
		g_cclosure_marshal_VOID__POINTER,
		G_TYPE_NONE, 1,
		G_TYPE_POINTER );
	vips_image_signals[SIG_POSTEVAL] = g_signal_new( "posteval",
		G_TYPE_FROM_CLASS( class ),
		G_SIGNAL_RUN_LAST,
		G_STRUCT_OFFSET( VipsImageClass, posteval ), 
		NULL, NULL,
		g_cclosure_marshal_VOID__POINTER,
		G_TYPE_NONE, 1,
		G_TYPE_POINTER );
	vips_image_signals[SIG_WRITTEN] = g_signal_new( "written",
		G_TYPE_FROM_CLASS( class ),
		G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
		G_STRUCT_OFFSET( VipsImageClass, written ), 
		NULL, NULL,
		g_cclosure_marshal_VOID__POINTER,
		G_TYPE_NONE, 1,
		G_TYPE_POINTER );
	vips_image_signals[SIG_INVALIDATE] = g_signal_new( "invalidate",
		G_TYPE_FROM_CLASS( class ),
		G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
		G_STRUCT_OFFSET( VipsImageClass, invalidate ), 
		NULL, NULL,
		g_cclosure_marshal_VOID__VOID,
		G_TYPE_NONE, 0 );
	vips_image_signals[SIG_MINIMISE] = g_signal_new( "minimise",
		G_TYPE_FROM_CLASS( class ),
		G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
		G_STRUCT_OFFSET( VipsImageClass, minimise ), 
		NULL, NULL,
		g_cclosure_marshal_VOID__VOID,
		G_TYPE_NONE, 0 );
	vips__minimise_lock = vips_g_mutex_new();
}
static void
vips_image_init( VipsImage *image )
{
	VIPS_DEBUG_MSG( "vips_image_init: %p\n", image );
	image-&gt;magic = vips_amiMSBfirst() ? VIPS_MAGIC_SPARC : VIPS_MAGIC_INTEL;
	image-&gt;Xsize = 1;
	image-&gt;Ysize = 1;
	image-&gt;Bands = 1;
	image-&gt;Xres = 1.0;
	image-&gt;Yres = 1.0;
	image-&gt;fd = -1;				image-&gt;sslock = vips_g_mutex_new();
	image-&gt;sizeof_header = VIPS_SIZEOF_HEADER;
	image-&gt;mode = g_strdup( "p" );
#ifdef DEBUG_LEAK
	g_object_set_qdata_full( G_OBJECT( image ), vips__image_pixels_quark, 
		g_new0( VipsImagePixels, 1 ), (GDestroyNotify) g_free ); 
}
int
vips_image_written( VipsImage *image )
{
	int result;
	VIPS_DEBUG_MSG( "vips_image_written: %p\n", image );
	result = 0;
	g_signal_emit( image, vips_image_signals[SIG_WRITTEN], 0, &amp;result );
	return( result );
}
void
vips_image_invalidate( VipsImage *image )
{
	VIPS_DEBUG_MSG( "vips_image_invalidate: %p\n", image );
	g_signal_emit( image, vips_image_signals[SIG_INVALIDATE], 0 );
}
static void *
vips_image_invalidate_all_cb( VipsImage *image, void *a, void *b )
{
	vips_image_invalidate( image );
	return( NULL );
}
void
vips_image_invalidate_all( VipsImage *image )
{
	VIPS_DEBUG_MSG( "vips_image_invalidate_all: %p\n", image );
	(void) vips__link_map( image, FALSE,
		(VipsSListMap2Fn) vips_image_invalidate_all_cb, NULL, NULL );
}
void
vips_image_minimise( VipsImage *image )
{
	VIPS_DEBUG_MSG( "vips_image_minimise: %p\n", image );
	g_signal_emit( image, vips_image_signals[SIG_MINIMISE], 0 );
}
static void *
vips_image_minimise_all_cb( VipsImage *image, void *a, void *b )
{
	vips_image_minimise( image );
	return( NULL );
}
void 
vips_image_minimise_all( VipsImage *image )
{
	g_mutex_lock( vips__minimise_lock );
	(void) vips__link_map( image, TRUE,
		(VipsSListMap2Fn) vips_image_minimise_all_cb, NULL, NULL );
	g_mutex_unlock( vips__minimise_lock );
}
gboolean
vips_image_is_sequential( VipsImage *image )
{
	return( vips_image_get_typeof( image, VIPS_META_SEQUENTIAL ) );
}
static int
vips_progress_add( VipsImage *image )
{
	VipsProgress *progress;
	VIPS_DEBUG_MSG( "vips_progress_add: %p\n", image );
	if( !(progress = image-&gt;time) ) {
		if( !(image-&gt;time = VIPS_NEW( NULL, VipsProgress )) )
			return( -1 );
		progress = image-&gt;time;
		progress-&gt;im = image;
		progress-&gt;start = NULL;
	}
	if( !progress-&gt;start )
		progress-&gt;start = g_timer_new();
	g_timer_start( progress-&gt;start );
	progress-&gt;run = 0;
	progress-&gt;eta = 0;
	progress-&gt;tpels = VIPS_IMAGE_N_PELS( image );
	progress-&gt;npels = 0;
	progress-&gt;percent = 0;
	return( 0 );
}
static void
vips_progress_update( VipsProgress *progress, guint64 processed )
{
	float prop;
	VIPS_DEBUG_MSG( "vips_progress_update: %p\n", progress );
	g_assert( progress );
	progress-&gt;run = g_timer_elapsed( progress-&gt;start, NULL );
	progress-&gt;npels = processed;
	prop = (float) progress-&gt;npels / (float) progress-&gt;tpels;
	progress-&gt;percent = 100 * prop;
	if( prop &gt; 0.1 ) 
		progress-&gt;eta = (1.0 / prop) * progress-&gt;run - progress-&gt;run;
}
void
vips_image_preeval( VipsImage *image )
{
	if( image-&gt;progress_signal ) {
		VIPS_DEBUG_MSG( "vips_image_preeval: %p\n", image );
		g_assert( vips_object_sanity( 
			VIPS_OBJECT( image-&gt;progress_signal ) ) );
		(void) vips_progress_add( image );
		(void) vips_progress_add( image-&gt;progress_signal );
		if( !vips_image_get_typeof( image, "hide-progress" ) )
			g_signal_emit( image-&gt;progress_signal, 
				vips_image_signals[SIG_PREEVAL], 0, 
				image-&gt;time );
	}
}
void
vips_image_eval( VipsImage *image, guint64 processed )
{
	if( image-&gt;progress_signal &amp;&amp;
		image-&gt;time ) {
		VIPS_DEBUG_MSG( "vips_image_eval: %p\n", image );
		g_assert( vips_object_sanity( 
			VIPS_OBJECT( image-&gt;progress_signal ) ) );
		vips_progress_update( image-&gt;time, processed );
		if( image-&gt;progress_signal-&gt;time != image-&gt;time )
			vips_progress_update( image-&gt;progress_signal-&gt;time, 
				processed );
		if( !vips_image_get_typeof( image, "hide-progress" ) )
			g_signal_emit( image-&gt;progress_signal, 
				vips_image_signals[SIG_EVAL], 0, 
				image-&gt;time );
	}
}
void
vips_image_posteval( VipsImage *image )
{
	if( image-&gt;progress_signal &amp;&amp;
		image-&gt;progress_signal-&gt;time ) { 
		VIPS_DEBUG_MSG( "vips_image_posteval: %p\n", image );
		g_assert( vips_object_sanity( 
			VIPS_OBJECT( image-&gt;progress_signal ) ) );
		if( !vips_image_get_typeof( image, "hide-progress" ) )
			g_signal_emit( image-&gt;progress_signal, 
				vips_image_signals[SIG_POSTEVAL], 0, 
				image-&gt;time );
	}
}
void
vips_image_set_progress( VipsImage *image, gboolean progress )
{
	if( progress &amp;&amp; 
		!image-&gt;progress_signal ) {
		VIPS_DEBUG_MSG( "vips_image_set_progress: %p %s\n", 
			image, image-&gt;filename );
		image-&gt;progress_signal = image;
	}
	else if( !progress )
		image-&gt;progress_signal = NULL;
}
gboolean
vips_image_iskilled( VipsImage *image )
{
	gboolean kill;
	kill = image-&gt;kill;
	if( image-&gt;kill ) {
		VIPS_DEBUG_MSG( "vips_image_iskilled: %s (%p) killed\n", 
			image-&gt;filename, image );
		vips_error( "VipsImage", 
			_( "killed for image \"%s\"" ), image-&gt;filename );
		vips_image_set_kill( image, FALSE );
	}
	return( kill );
}
void
vips_image_set_kill( VipsImage *image, gboolean kill )
{
	if( image-&gt;kill != kill ) 
		VIPS_DEBUG_MSG( "vips_image_set_kill: %s (%p) %d\n", 
			image-&gt;filename, image, kill );
	image-&gt;kill = kill;
}
void
vips_image_temp_name( char *name, int size )
{
	static int global_serial = 0;
	int serial = g_atomic_int_add( &amp;global_serial, 1 );
	vips_snprintf( name, size, "temp-%d", serial );
}
VipsImage *
vips_image_new( void )
{
	VipsImage *image;
	char filename[26];
	vips_check_init();
	vips_image_temp_name( filename, sizeof( filename ) );
	image = VIPS_IMAGE( g_object_new( VIPS_TYPE_IMAGE, NULL ) );
	g_object_set( image,
		"filename", filename,
		"mode", "p",
		NULL );
	if( vips_object_build( VIPS_OBJECT( image ) ) ) {
		VIPS_UNREF( image );
		return( NULL );
	}
	return( image ); 
}
VipsImage *
vips_image_new_mode( const char *filename, const char *mode )
{
	VipsImage *image;
	g_assert( filename );
	g_assert( mode );
	vips_check_init();
	image = VIPS_IMAGE( g_object_new( VIPS_TYPE_IMAGE, NULL ) );
	g_object_set( image,
		"filename", filename,
		"mode", mode,
		NULL );
	if( vips_object_build( VIPS_OBJECT( image ) ) ) {
		VIPS_UNREF( image );
		return( NULL );
	}
	return( image ); 
}
VipsImage *
vips_image_new_memory( void )
{
	char filename[26];
	vips_image_temp_name( filename, sizeof( filename ) );
	return( vips_image_new_mode( filename, "t" ) );
}
VipsImage *
vips_image_memory( void )
{
	return( vips_image_new_memory() ); 
}
char *
vips_filename_get_filename( const char *vips_filename )
{
	char filename[VIPS_PATH_MAX];
	char options[VIPS_PATH_MAX];
	vips__filename_split8( vips_filename, filename, options ); 
	return( g_strdup( filename ) );
}
char *
vips_filename_get_options( const char *vips_filename )
{
	char filename[VIPS_PATH_MAX];
	char options[VIPS_PATH_MAX];
	vips__filename_split8( vips_filename, filename, options ); 
	return( g_strdup( options ) );
}
VipsImage *
vips_image_new_from_file( const char *name, ... )
{
	char filename[VIPS_PATH_MAX];
	char option_string[VIPS_PATH_MAX];
	const char *operation_name;
	va_list ap;
	int result;
	VipsImage *out;
	vips_check_init();
	vips__filename_split8( name, filename, option_string );
	if( !(operation_name = vips_foreign_find_load( filename )) )
		return( NULL );
	va_start( ap, name );
	result = vips_call_split_option_string( operation_name, 
		option_string, ap, filename, &amp;out );
	va_end( ap );
	if( result )
		return( NULL ); 
	return( out );
}
VipsImage *
vips_image_new_from_file_RW( const char *filename )
{
	return( vips_image_new_mode( filename, "rw" ) ); 
}
VipsImage *
vips_image_new_from_file_raw( const char *filename, 
	int xsize, int ysize, int bands, guint64 offset )
{
	VipsImage *image;
	vips_check_init();
	image = VIPS_IMAGE( g_object_new( VIPS_TYPE_IMAGE, NULL ) );
	g_object_set( image,
		"filename", filename,
		"mode", "a",
		"width", xsize,
		"height", ysize,
		"bands", bands,
		"sizeof_header", offset,
		NULL );
	if( vips_object_build( VIPS_OBJECT( image ) ) ) {
		VIPS_UNREF( image );
		return( NULL );
	}
	return( image );
}
VipsImage *
vips_image_new_from_memory( const void *data, size_t size,
	int width, int height, int bands, VipsBandFormat format )
{
	VipsImage *image;
	char filename[26];
	vips_check_init();
	vips_image_temp_name( filename, sizeof( filename ) );
	image = VIPS_IMAGE( g_object_new( VIPS_TYPE_IMAGE, NULL ) );
	g_object_set( image,
		"filename", filename,
		"mode", "m",
		"foreign_buffer", data,
		"width", width,
		"height", height,
		"bands", bands,
		"format", format,
		NULL );
	if( vips_object_build( VIPS_OBJECT( image ) ) ) {
		VIPS_UNREF( image );
		return( NULL );
	}
	if( size &lt; VIPS_IMAGE_SIZEOF_IMAGE( image ) ) {
		vips_error( "VipsImage",
			_( "memory area too small --- "
				"should be %" G_GINT64_FORMAT " bytes, "
				"you passed %zd" ),
			VIPS_IMAGE_SIZEOF_IMAGE( image ), size ); 
		VIPS_UNREF( image );
		return( NULL );
	}
	return( image );
}
static void
vips_image_new_from_memory_copy_cb( VipsImage *image, void *data_copy )
{
	vips_tracked_free( data_copy );
}
VipsImage *
vips_image_new_from_memory_copy( const void *data, size_t size,
	int width, int height, int bands, VipsBandFormat format )
{
	void *data_copy;
	VipsImage *image;
	vips_check_init();
	if( !(data_copy = vips_tracked_malloc( size )) )
		return( NULL );
	memcpy( data_copy, data, size );
	if( !(image = vips_image_new_from_memory( data_copy, size, 
		width, height, bands, format )) ) {
		vips_tracked_free( data_copy );
		return( NULL );
	}
	g_signal_connect( image, "close", 
		G_CALLBACK( vips_image_new_from_memory_copy_cb ), data_copy );
	return( image );
}
VipsImage *
vips_image_new_from_buffer( const void *buf, size_t len, 
	const char *option_string, ... )
{
	const char *operation_name;
	va_list ap;
	int result;
	VipsImage *out;
	VipsBlob *blob;
	vips_check_init();
	if( !(operation_name = 
		vips_foreign_find_load_buffer( buf, len )) )
		return( NULL );
	blob = vips_blob_new( NULL, buf, len );
	va_start( ap, option_string );
	result = vips_call_split_option_string( operation_name,
		option_string, ap, blob, &amp;out );
	va_end( ap );
	vips_area_unref( VIPS_AREA( blob ) );
	if( result )
		return( NULL );
	return( out ); 
}
VipsImage *
vips_image_new_from_source( VipsSource *source, 
	const char *option_string, ... )
{
	const char *filename = 
		vips_connection_filename( VIPS_CONNECTION( source ) );
	const char *operation_name;
	va_list ap;
	int result;
	VipsImage *out;
	vips_check_init();
	vips_error_freeze();
	operation_name = vips_foreign_find_load_source( source );
	vips_error_thaw();
        if( operation_name ) { 
		va_start( ap, option_string );
		result = vips_call_split_option_string( operation_name,
			option_string, ap, source, &amp;out );
		va_end( ap );
	}
	else if( filename ) {
		if( !(operation_name = vips_foreign_find_load( filename )) )
			return( NULL );
		va_start( ap, option_string );
		result = vips_call_split_option_string( operation_name, 
			option_string, ap, filename, &amp;out );
		va_end( ap );
	}
	else if( vips_source_is_mappable( source ) ) {
		VipsBlob *blob;
		const void *buf;
		size_t len;
		if( !(blob = vips_source_map_blob( source )) )
			return( NULL );
		buf = vips_blob_get( blob, &amp;len );
		if( !(operation_name = 
			vips_foreign_find_load_buffer( buf, len )) ) {
			vips_area_unref( VIPS_AREA( blob ) );
			return( NULL );
		}
                va_start( ap, option_string );
                result = vips_call_split_option_string( operation_name,
                        option_string, ap, blob, &amp;out );
                va_end( ap );
		vips_area_unref( VIPS_AREA( blob ) );
	}
	else {
		vips_error( "VipsImage",
			"%s", _( "unable to load source" ) );
		result = -1;
	}
        if( result )
                return( NULL );
        return( out );
}
VipsImage *
vips_image_new_matrix( int width, int height )
{
	VipsImage *image;
	vips_check_init();
	image = VIPS_IMAGE( g_object_new( VIPS_TYPE_IMAGE, NULL ) );
	g_object_set( image,
		"filename", "vips_image_new_matrix",
		"mode", "t",
		"width", width,
		"height", height,
		"bands", 1,
		"format", VIPS_FORMAT_DOUBLE,
		"interpretation", VIPS_INTERPRETATION_MATRIX,
		NULL );
	if( vips_object_build( VIPS_OBJECT( image ) ) ) {
		VIPS_UNREF( image );
		return( NULL );
	}
	if( vips_image_write_prepare( image ) ) {
		g_object_unref( image );
		return( NULL );
	}
	return( image );
}
VipsImage *
vips_image_new_matrixv( int width, int height, ... )
{
	va_list ap;
	VipsImage *matrix;
	int x, y;
	vips_check_init();
	matrix = vips_image_new_matrix( width, height ); 
	va_start( ap, height );
	for( y = 0; y &lt; height; y++ )
		for( x = 0; x &lt; width; x++ )
			*VIPS_MATRIX( matrix, x, y ) = va_arg( ap, double );
	va_end( ap );
	return( matrix ); 
}
VipsImage *
vips_image_new_matrix_from_array( int width, int height, 
	const double *array, int size )
{
	VipsImage *matrix;
	int x, y;
	int i;
	if( size != width * height ) {
		vips_error( "VipsImage",
			_( "bad array length --- should be %d, you passed %d" ),
			width * height, size );
		return( NULL );
	}
	vips_check_init();
	matrix = vips_image_new_matrix( width, height ); 
	i = 0;
	for( y = 0; y &lt; height; y++ )
		for( x = 0; x &lt; width; x++ )
			*VIPS_MATRIX( matrix, x, y ) = array[i++];
	return( matrix ); 
}
VipsImage *
vips_image_matrix_from_array( int width, int height, 
	const double *array, int size )
{
	return( vips_image_new_matrix_from_array( width, height, 
		array, size ) ); 
}
VipsImage *
vips_image_new_from_image( VipsImage *image, const double *c, int n )
{
	VipsObject *scope = (VipsObject *) vips_image_new();
	VipsImage **t = (VipsImage **) vips_object_local_array( scope, 5 );
	double *ones;
	int i;
	VipsImage *result;
	if( !(ones = VIPS_ARRAY( scope, n, double )) ) {
		g_object_unref( scope );
		return( NULL );
	}
	for( i = 0; i &lt; n; i++ )
		ones[i] = 1.0;
	if( vips_black( &amp;t[0], 1, 1, NULL ) ||
		vips_linear( t[0], &amp;t[1], ones, (double *) c, n, NULL ) ||
		vips_cast( t[1], &amp;t[2], image-&gt;BandFmt, NULL ) ||
		vips_embed( t[2], &amp;t[3], 0, 0, image-&gt;Xsize, image-&gt;Ysize,
			"extend", VIPS_EXTEND_COPY, NULL ) ||
		vips_copy( t[3], &amp;t[4], 
			"interpretation", image-&gt;Type,
			"xres", image-&gt;Xres,
			"yres", image-&gt;Yres,
			"xoffset", image-&gt;Xoffset,
			"yoffset", image-&gt;Yoffset,
			NULL ) ) {
		g_object_unref( scope );
		return( NULL );
	}
	result = t[4];
	g_object_ref( result );
	g_object_unref( scope );
	return( result ); 
}
VipsImage *
vips_image_new_from_image1( VipsImage *image, double c )
{
	return( vips_image_new_from_image( image, (const double *) &amp;c, 1 ) );
}
void
vips_image_set_delete_on_close( VipsImage *image, gboolean delete_on_close )
{
	VIPS_DEBUG_MSG( "vips_image_set_delete_on_close: %d %s\n", 
			delete_on_close, image-&gt;filename );
	image-&gt;delete_on_close = delete_on_close;
	VIPS_FREE( image-&gt;delete_on_close_filename );
	if( delete_on_close ) 
		VIPS_SETSTR( image-&gt;delete_on_close_filename, image-&gt;filename );
}
guint64
vips_get_disc_threshold( void )
{
	static gboolean done = FALSE;
	static guint64 threshold;
	if( !done ) {
		const char *env;
		done = TRUE;
		threshold = 100 * 1024 * 1024;
		if( (env = g_getenv( "VIPS_DISC_THRESHOLD" ))
#if ENABLE_DEPRECATED
			|| (env = g_getenv( "IM_DISC_THRESHOLD" ))
#endif
		  )
			threshold = vips__parse_size( env );
		if( vips__disc_threshold ) 
			threshold = vips__parse_size( vips__disc_threshold );
#ifdef DEBUG
		printf( "vips_get_disc_threshold: %zd bytes\n", threshold );
	}
	return( threshold );
}
VipsImage *
vips_image_new_temp_file( const char *format )
{
	char *name;
	VipsImage *image;
	vips_check_init();
	if( !(name = vips__temp_name( format )) )
		return( NULL );
	if( !(image = vips_image_new_mode( name, "w" )) ) {
		g_free( name );
		return( NULL );
	}
	g_free( name );
	vips_image_set_delete_on_close( image, TRUE );
	return( image );
}
static int
vips_image_write_gen( VipsRegion *or, 
	void *seq, void *a, void *b, gboolean *stop )
{
	VipsRegion *ir = (VipsRegion *) seq;
	VipsRect *r = &amp;or-&gt;valid;
	if( vips_region_prepare( ir, r ) ||
		vips_region_region( or, ir, r, r-&gt;left, r-&gt;top ) )
		return( -1 );
	return( 0 );
}
int
vips_image_write( VipsImage *image, VipsImage *out )
{
	g_object_ref( image );
	if( vips_image_pio_input( image ) || 
		vips_image_pipelinev( out, 
			VIPS_DEMAND_STYLE_THINSTRIP, image, NULL ) ) {
		g_object_unref( image );
		return( -1 );
	}
	if( vips_image_generate( out,
		vips_start_one, vips_image_write_gen, vips_stop_one, 
		image, NULL ) ) {
		g_object_unref( image );
		return( -1 );
	}
	if( vips_image_ispartial( out ) ) { 
		vips_object_local( out, image );
	}
	else {
		vips__reorder_clear( out );
		vips__link_break_all( out );
		g_object_unref( image );
	}
	return( 0 );
}
int
vips_image_write_to_file( VipsImage *image, const char *name, ... )
{
	char filename[VIPS_PATH_MAX];
	char option_string[VIPS_PATH_MAX];
	const char *operation_name;
	va_list ap;
	int result;
	vips__filename_split8( name, filename, option_string );
	vips_error_freeze();
	operation_name = vips_foreign_find_save_target( filename );
	vips_error_thaw();
	if( operation_name ) {
		VipsTarget *target;
		if( !(target = vips_target_new_to_file( filename )) )
			return( -1 );
		va_start( ap, name );
		result = vips_call_split_option_string( operation_name, 
			option_string, ap, image, target );
		va_end( ap );
		VIPS_UNREF( target );
	}
	else if( (operation_name = vips_foreign_find_save( filename )) ) {
		va_start( ap, name );
		result = vips_call_split_option_string( operation_name, 
			option_string, ap, image, filename );
		va_end( ap );
	}
	else
		return( -1 );
	return( result );
}
int
vips_image_write_to_buffer( VipsImage *in, 
	const char *suffix, void **buf, size_t *size, 
	... )
{
	char filename[VIPS_PATH_MAX];
	char option_string[VIPS_PATH_MAX];
	const char *operation_name;
	VipsBlob *blob;
	va_list ap;
	int result;
	vips__filename_split8( suffix, filename, option_string );
	if( (operation_name = vips_foreign_find_save_target( filename )) ) {
		VipsTarget *target;
		if( !(target = vips_target_new_to_memory()) )
			return( -1 );
		va_start( ap, size );
		result = vips_call_split_option_string( operation_name, 
			option_string, ap, in, target );
		va_end( ap );
		if( result ) {
			VIPS_UNREF( target );
			return( -1 );
		}
		g_object_get( target, "blob", &amp;blob, NULL );
		VIPS_UNREF( target );
	}
	else if( (operation_name = 
		vips_foreign_find_save_buffer( filename )) ) {
		va_start( ap, size );
		result = vips_call_split_option_string( operation_name, 
			option_string, ap, in, &amp;blob );
		va_end( ap );
		if( result )
			return( -1 );
	}
	else
		return( -1 );
	*buf = NULL;
	if( size ) 
		*size = 0;
	if( blob ) { 
		if( buf ) {
			*buf = VIPS_AREA( blob )-&gt;data;
			VIPS_AREA( blob )-&gt;free_fn = NULL;
		}
		if( size ) 
			*size = VIPS_AREA( blob )-&gt;length;
		vips_area_unref( VIPS_AREA( blob ) );
	}
	return( 0 );
}
int
vips_image_write_to_target( VipsImage *in, 
	const char *suffix, VipsTarget *target, ... )
{
	char filename[VIPS_PATH_MAX];
	char option_string[VIPS_PATH_MAX];
	const char *operation_name;
	va_list ap;
	int result;
	vips__filename_split8( suffix, filename, option_string );
	if( !(operation_name = vips_foreign_find_save_target( filename )) )
		return( -1 );
	va_start( ap, target );
	result = vips_call_split_option_string( operation_name, option_string, 
		ap, in, target );
	va_end( ap );
	if( result )
		return( -1 );
	return( 0 );
}
void *
vips_image_write_to_memory( VipsImage *in, size_t *size_out )
{
	void *buf;
	size_t size;
	VipsImage *x;
	size = VIPS_IMAGE_SIZEOF_IMAGE( in );
	if( !(buf = g_try_malloc( size )) ) {
		vips_error( "vips_image_write_to_memory", 
			_( "out of memory --- size == %dMB" ), 
			(int) (size / (1024.0 * 1024.0))  );
		g_warning( _( "out of memory --- size == %dMB" ), 
			(int) (size / (1024.0 * 1024.0))  );
		return( NULL );
	}
	x = vips_image_new_from_memory( buf, size,
		in-&gt;Xsize, in-&gt;Ysize, in-&gt;Bands, in-&gt;BandFmt );
	if( vips_image_write( in, x ) ) {
		g_object_unref( x );
		g_free( buf ); 
		return( NULL ); 
	}
	g_object_unref( x );
	if( size_out )
		*size_out = size;
	return( buf ); 
}
int
vips_image_decode( VipsImage *in, VipsImage **out )
{
	if( in-&gt;Coding == VIPS_CODING_LABQ ) {
		if( vips_LabQ2Lab( in, out, NULL ) )
			return( -1 );
	} 
	else if( in-&gt;Coding == VIPS_CODING_RAD ) {
		if( vips_rad2float( in, out, NULL ) )
			return( -1 );
	}
	else {
		if( vips_copy( in, out, NULL ) )
			return( -1 );
	}
	return( 0 );
}
int
vips_image_decode_predict( VipsImage *in, 
	int *out_bands, VipsBandFormat *out_format )
{
	VipsBandFormat format;
	int bands; 
	if( in-&gt;Coding == VIPS_CODING_LABQ ) {
		bands = 3;
		format = VIPS_FORMAT_FLOAT;
	}
	else if( in-&gt;Coding == VIPS_CODING_RAD ) {
		bands = 3;
		format = VIPS_FORMAT_FLOAT;
	}
	else {
		bands = in-&gt;Bands;
		format = in-&gt;BandFmt;
	}
	if( out_bands )
		*out_bands = bands;
	if( out_format )
		*out_format = format;
	return( 0 );
}
int
vips_image_encode( VipsImage *in, VipsImage **out, VipsCoding coding )
{
	if( coding == VIPS_CODING_LABQ ) {
		if( vips_Lab2LabQ( in, out, NULL ) )
			return( -1 );
	} 
	else if( coding == VIPS_CODING_RAD ) {
		if( vips_float2rad( in, out, NULL ) )
			return( -1 );
	}
	else {
		if( vips_copy( in, out, NULL ) )
			return( -1 );
	}
	return( 0 );
}
gboolean
vips_image_isMSBfirst( VipsImage *image )
{	
	if( image-&gt;magic == VIPS_MAGIC_SPARC )
		return( 1 );
	else
		return( 0 );
}
gboolean 
vips_image_isfile( VipsImage *image )
{
	switch( image-&gt;dtype ) {
	case VIPS_IMAGE_MMAPIN:
	case VIPS_IMAGE_MMAPINRW:
	case VIPS_IMAGE_OPENOUT:
	case VIPS_IMAGE_OPENIN:
		return( 1 );
	case VIPS_IMAGE_PARTIAL:
	case VIPS_IMAGE_SETBUF:
	case VIPS_IMAGE_SETBUF_FOREIGN:
	case VIPS_IMAGE_NONE:
		return( 0 );
	default:
		g_assert( FALSE ); 
		return( 0 );
	}
}
gboolean 
vips_image_ispartial( VipsImage *image )
{
	if( image-&gt;dtype == VIPS_IMAGE_PARTIAL )
		return( 1 );
	else
		return( 0 );
}
gboolean
vips_image_hasalpha( VipsImage *image )
{
	switch( image-&gt;Type ) { 
	case VIPS_INTERPRETATION_B_W:
	case VIPS_INTERPRETATION_GREY16:
		return( image-&gt;Bands &gt; 1 ); 
	case VIPS_INTERPRETATION_RGB:
	case VIPS_INTERPRETATION_CMC:
	case VIPS_INTERPRETATION_LCH:
	case VIPS_INTERPRETATION_LABS:
	case VIPS_INTERPRETATION_sRGB:
	case VIPS_INTERPRETATION_YXY:
	case VIPS_INTERPRETATION_XYZ:
	case VIPS_INTERPRETATION_LAB:
	case VIPS_INTERPRETATION_RGB16:
	case VIPS_INTERPRETATION_scRGB:
	case VIPS_INTERPRETATION_HSV:
		return( image-&gt;Bands &gt; 3 ); 
	case VIPS_INTERPRETATION_CMYK:
		return( image-&gt;Bands &gt; 4 ); 
	default:
		return( FALSE ); 
	}
}
int
vips_image_write_prepare( VipsImage *image )
{
	g_assert( vips_object_sanity( VIPS_OBJECT( image ) ) );
	if( image-&gt;Xsize &lt;= 0 || 
		image-&gt;Ysize &lt;= 0 || 
		image-&gt;Bands &lt;= 0 ) {
		vips_error( "VipsImage", "%s", _( "bad dimensions" ) );
		return( -1 );
	}
	image-&gt;Bbits = vips_format_sizeof( image-&gt;BandFmt ) &lt;&lt; 3;
	if( image-&gt;dtype == VIPS_IMAGE_PARTIAL ) {
		VIPS_DEBUG_MSG( "vips_image_write_prepare: "
			"old-style output for %s\n", image-&gt;filename );
		image-&gt;dtype = VIPS_IMAGE_SETBUF;
	}
	switch( image-&gt;dtype ) {
	case VIPS_IMAGE_MMAPINRW:
	case VIPS_IMAGE_SETBUF_FOREIGN:
		break;
	case VIPS_IMAGE_SETBUF:
		if( !image-&gt;data &amp;&amp; 
			!(image-&gt;data = vips_tracked_malloc( 
				VIPS_IMAGE_SIZEOF_IMAGE( image ))) ) 
			return( -1 );
		break;
	case VIPS_IMAGE_OPENOUT:
		if( vips_image_open_output( image ) )
			return( -1 );
		break;
	default:
		vips_error( "VipsImage", "%s", _( "bad image descriptor" ) );
		return( -1 );
	}
	return( 0 );
}
int
vips_image_write_line( VipsImage *image, int ypos, VipsPel *linebuffer )
{	
	int linesize = VIPS_IMAGE_SIZEOF_LINE( image );
	if( ypos == 0 ) {
		if( vips__image_wio_output( image ) )
			return( -1 );
		vips_image_set_kill( image, FALSE );
		vips_image_write_prepare( image );
		vips_image_preeval( image );
	}
	switch( image-&gt;dtype ) {
	case VIPS_IMAGE_SETBUF:
	case VIPS_IMAGE_SETBUF_FOREIGN:
		memcpy( VIPS_IMAGE_ADDR( image, 0, ypos ), 
			linebuffer, linesize );
		break;
	case VIPS_IMAGE_OPENOUT:
		if( vips__write( image-&gt;fd, linebuffer, linesize ) )
			return( -1 );
		break;
	default:
		vips_error( "VipsImage", 
			_( "unable to output to a %s image" ),
			vips_enum_string( VIPS_TYPE_IMAGE_TYPE, 
				image-&gt;dtype ) );
		return( -1 );
	}
	vips_image_eval( image, ypos * image-&gt;Xsize );
	if( vips_image_iskilled( image ) )
		return( -1 );
	if( ypos == image-&gt;Ysize - 1 ) {
		vips_image_posteval( image );
		if( vips_image_written( image ) )
			return( -1 );
	}
	return( 0 );
}
static int
vips_image_rewind_output( VipsImage *image ) 
{
	int fd;
	g_assert( image-&gt;dtype == VIPS_IMAGE_OPENOUT );
#ifdef DEBUG_IO
	printf( "vips_image_rewind_output: %s\n", image-&gt;filename );
	fd = image-&gt;fd;
	image-&gt;fd = -1;
	vips_object_rewind( VIPS_OBJECT( image ) );
	image-&gt;fd = fd;
	g_object_set( image,
		"mode", "v",
		NULL );
	if( vips_object_build( VIPS_OBJECT( image ) ) ) {
		vips_error( "VipsImage", 
			_( "auto-rewind for %s failed" ),
			image-&gt;filename );
		return( -1 );
	}
	vips_image_delete( image );
	return( 0 );
}
VipsImage *
vips_image_copy_memory( VipsImage *image )
{
	VipsImage *new;
	switch( image-&gt;dtype ) {
	case VIPS_IMAGE_SETBUF:
	case VIPS_IMAGE_SETBUF_FOREIGN:
	case VIPS_IMAGE_MMAPIN:
	case VIPS_IMAGE_MMAPINRW:
		new = image;
		g_object_ref( new );
		break;
	case VIPS_IMAGE_OPENOUT:
	case VIPS_IMAGE_OPENIN:
	case VIPS_IMAGE_PARTIAL:
		new = vips_image_new_memory();
		if( vips_image_write( image, new ) ) {
			g_object_unref( new );
			return( NULL ); 
		}
		break;
	default:
		vips_error( "vips_image_copy_memory", 
			"%s", _( "image not readable" ) );
		return( NULL );
	}
	return( new );
}
int
vips_image_wio_input( VipsImage *image )
{	
	VipsImage *t1;
	g_assert( vips_object_sanity( VIPS_OBJECT( image ) ) );
#ifdef DEBUG_IO
	printf( "vips_image_wio_input: wio input for %s\n", 
		image-&gt;filename );
	switch( image-&gt;dtype ) {
	case VIPS_IMAGE_SETBUF:
	case VIPS_IMAGE_SETBUF_FOREIGN:
		if( !image-&gt;data ) {
			vips_error( "vips_image_wio_input", 
				"%s", _( "no image data" ) );
			return( -1 );
		}
		break;
	case VIPS_IMAGE_MMAPIN:
	case VIPS_IMAGE_MMAPINRW:
		break;
	case VIPS_IMAGE_PARTIAL:
#ifdef DEBUG_IO
		printf( "vips_image_wio_input: "
			"converting partial image to WIO\n" );
		t1 = vips_image_new_memory();
		if( vips_image_write( image, t1 ) ) {
			g_object_unref( t1 );
			return( -1 );
		}
		image-&gt;dtype = VIPS_IMAGE_SETBUF;
		image-&gt;data = t1-&gt;data; 
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		t1-&gt;data = NULL;
		g_object_unref( t1 );
		image-&gt;start_fn = NULL;
		image-&gt;generate_fn = NULL;
		image-&gt;stop_fn = NULL;
		image-&gt;client1 = NULL;
		image-&gt;client2 = NULL;
		if( image-&gt;regions ) </b></font>
			g_warning( "rewinding image with active regions" ); 
		break;
	case VIPS_IMAGE_OPENIN:
#ifdef DEBUG_IO
		printf( "vips_image_wio_input: "
			"converting openin image for wio input\n" );
		if( vips_mapfile( image ) ) 
			return( -1 );
		image-&gt;data = (VipsPel *) image-&gt;baseaddr + 
			image-&gt;sizeof_header;
		image-&gt;dtype = VIPS_IMAGE_MMAPIN;
		break;
	case VIPS_IMAGE_OPENOUT:
		if( vips_image_rewind_output( image ) ||
			vips_image_wio_input( image ) ) 
			return( -1 );
		break;
	default:
		vips_error( "vips_image_wio_input", 
			"%s", _( "image not readable" ) );
		return( -1 );
	}
	return( 0 );
}
int 
vips__image_wio_output( VipsImage *image )
{
#ifdef DEBUG_IO
	printf( "vips__image_wio_output: WIO output for %s\n", 
		image-&gt;filename );
	switch( image-&gt;dtype ) {
	case VIPS_IMAGE_PARTIAL:
		if( image-&gt;generate_fn ) {
			vips_error( "vips__image_wio_output", 
				"%s", _( "image already written" ) );
			return( -1 );
		}
		image-&gt;dtype = VIPS_IMAGE_SETBUF;
		break;
	case VIPS_IMAGE_SETBUF:
	case VIPS_IMAGE_OPENOUT:
	case VIPS_IMAGE_SETBUF_FOREIGN:
		break;
	default:
		vips_error( "vips__image_wio_output", 
			"%s", _( "image not writeable" ) );
		return( -1 );
	}
	return( 0 );
}
int
vips_image_inplace( VipsImage *image )
{
	if( vips_image_wio_input( image ) ) 
		return( -1 );
	switch( image-&gt;dtype ) {
	case VIPS_IMAGE_SETBUF:
	case VIPS_IMAGE_SETBUF_FOREIGN:
	case VIPS_IMAGE_MMAPINRW:
		break;
	case VIPS_IMAGE_MMAPIN:
		if( vips_remapfilerw( image ) )
			return( -1 );
		break;
	default:
		vips_error( "vips_image_inplace", 
			"%s", _( "bad file type" ) );
		return( -1 );
	}
	vips_image_invalidate_all( image ); 
	return( 0 );
}
int
vips_image_pio_input( VipsImage *image )
{
	g_assert( vips_object_sanity( VIPS_OBJECT( image ) ) );
#ifdef DEBUG_IO
	printf( "vips_image_pio_input: enabling partial input for %s\n", 
		image-&gt;filename );
	switch( image-&gt;dtype ) {
	case VIPS_IMAGE_SETBUF:
	case VIPS_IMAGE_SETBUF_FOREIGN:
		if( !image-&gt;data ) {
			vips_error( "vips_image_pio_input", 
				"%s", _( "no image data" ) );
			return( -1 );
		}
		image-&gt;start_fn = NULL;
		image-&gt;generate_fn = NULL;
		image-&gt;stop_fn = NULL;
		break;
	case VIPS_IMAGE_PARTIAL:
		if( !image-&gt;generate_fn ) {
			vips_error( "vips_image_pio_input", 
				"%s", _( "no image data" ) );
			return( -1 );
		}
		break;
	case VIPS_IMAGE_MMAPIN:
	case VIPS_IMAGE_MMAPINRW:
	case VIPS_IMAGE_OPENIN:
		break;
	case VIPS_IMAGE_OPENOUT:
		if( vips_image_rewind_output( image ) )
			return( -1 );
		break;
	default:
		vips_error( "vips_image_pio_input", 
			"%s", _( "image not readable" ) );
		return( -1 );
	}
	return( 0 );
}
int 
vips_image_pio_output( VipsImage *image )
{
#ifdef DEBUG_IO
	printf( "vips_image_pio_output: enabling partial output for %s\n", 
		image-&gt;filename );
	switch( image-&gt;dtype ) {
	case VIPS_IMAGE_SETBUF:
		if( image-&gt;data ) {
			vips_error( "vips_image_pio_output", 
				"%s", _( "image already written" ) );
			return( -1 );
		}
		break;
	case VIPS_IMAGE_PARTIAL:
		if( image-&gt;generate_fn ) {
			vips_error( "vips_image_pio_output", 
				"%s", _( "image already written" ) );
			return( -1 );
		}
		break;
	case VIPS_IMAGE_OPENOUT:
	case VIPS_IMAGE_SETBUF_FOREIGN:
		break;
	default:
		vips_error( "vips_image_pio_output", 
			"%s", _( "image not writeable" ) );
		return( -1 );
	}
	return( 0 );
}
gboolean
vips_band_format_isint( VipsBandFormat format )
{
	switch( format ) {
	case VIPS_FORMAT_UCHAR:
	case VIPS_FORMAT_CHAR:
	case VIPS_FORMAT_USHORT:
	case VIPS_FORMAT_SHORT:
	case VIPS_FORMAT_UINT:
	case VIPS_FORMAT_INT:
		return( TRUE );
	case VIPS_FORMAT_FLOAT:
	case VIPS_FORMAT_DOUBLE:	
	case VIPS_FORMAT_COMPLEX:
	case VIPS_FORMAT_DPCOMPLEX:	
		return( FALSE );
	default:
		g_assert_not_reached();
		return( FALSE );
	}
}
gboolean
vips_band_format_isuint( VipsBandFormat format )
{
	switch( format ) {
	case VIPS_FORMAT_UCHAR:
	case VIPS_FORMAT_USHORT:
	case VIPS_FORMAT_UINT:
		return( TRUE );
	case VIPS_FORMAT_INT:
	case VIPS_FORMAT_SHORT:
	case VIPS_FORMAT_CHAR:
	case VIPS_FORMAT_FLOAT:
	case VIPS_FORMAT_DOUBLE:	
	case VIPS_FORMAT_COMPLEX:
	case VIPS_FORMAT_DPCOMPLEX:	
		return( FALSE );
	default:
		g_assert_not_reached();
		return( FALSE );
	}
}
gboolean
vips_band_format_is8bit( VipsBandFormat format )
{
	switch( format ) {
	case VIPS_FORMAT_UCHAR:
	case VIPS_FORMAT_CHAR:
		return( TRUE );
	case VIPS_FORMAT_USHORT:
	case VIPS_FORMAT_SHORT:
	case VIPS_FORMAT_UINT:
	case VIPS_FORMAT_INT:
	case VIPS_FORMAT_FLOAT:
	case VIPS_FORMAT_DOUBLE:
	case VIPS_FORMAT_COMPLEX:
	case VIPS_FORMAT_DPCOMPLEX:
		return( FALSE );
	default:
		g_assert_not_reached();
		return( FALSE );
	}
}
gboolean
vips_band_format_isfloat( VipsBandFormat format )
{
	switch( format ) {
	case VIPS_FORMAT_FLOAT:
	case VIPS_FORMAT_DOUBLE:	
		return( TRUE );
	case VIPS_FORMAT_UCHAR:
	case VIPS_FORMAT_CHAR:
	case VIPS_FORMAT_USHORT:
	case VIPS_FORMAT_SHORT:
	case VIPS_FORMAT_UINT:
	case VIPS_FORMAT_INT:
	case VIPS_FORMAT_COMPLEX:
	case VIPS_FORMAT_DPCOMPLEX:	
		return( FALSE );
	default:
		g_assert_not_reached();
		return( FALSE );
	}
}
gboolean
vips_band_format_iscomplex( VipsBandFormat format )
{
	switch( format ) {
	case VIPS_FORMAT_COMPLEX:
	case VIPS_FORMAT_DPCOMPLEX:	
		return( TRUE );
	case VIPS_FORMAT_UCHAR:
	case VIPS_FORMAT_CHAR:
	case VIPS_FORMAT_USHORT:
	case VIPS_FORMAT_SHORT:
	case VIPS_FORMAT_UINT:
	case VIPS_FORMAT_INT:
	case VIPS_FORMAT_FLOAT:
	case VIPS_FORMAT_DOUBLE:	
		return( FALSE );
	default:
		g_assert_not_reached();
		return( FALSE );
	}
}
void
vips_image_free_buffer( VipsImage *image, void *buffer )
{
	free( buffer );
}
int
vips__view_image( VipsImage *image )
{
	VipsArrayImage *array; 
	int result;
	array = vips_array_image_new( &amp;image, 1 );
	result = vips_system( "nip2 %s", 
		"in", array, 
		"in-format", "%s.v", 
		NULL ); 
	vips_area_unref( VIPS_AREA( array ) );
	return( result ); 
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
