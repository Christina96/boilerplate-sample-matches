
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 46, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-timing.c</h3>
            <pre><code>1  #include &quot;tomcrypt_private.h&quot;
2  #if defined(_WIN32)
3     #define PRI64  &quot;I64d&quot;
4  #else
5     #define PRI64  &quot;ll&quot;
6  #endif
7  static prng_state yarrow_prng;
8  #define KTIMES  25
9  #define TIMES   100000
10  static struct list {
11      int id;
12      ulong64 spd1, spd2, avg;
13  } results[100];
14  static int no_results;
15  static int sorter(const void *a, const void *b)
16  {
17     const struct list *A, *B;
18     A = a;
19     B = b;
20     if (A-&gt;avg &lt; B-&gt;avg) return -1;
21     if (A-&gt;avg &gt; B-&gt;avg) return 1;
22     return 0;
23  }
24  static void tally_results(int type)
25  {
26     int x;
27     qsort(results, no_results, sizeof(struct list), &amp;sorter);
28     fprintf(stderr, &quot;\n&quot;);
29     if (type == 0) {
30        for (x = 0; x &lt; no_results; x++) {
31           fprintf(stderr, &quot;%-20s: Schedule at %6lu\n&quot;, cipher_descriptor[results[x].id].name, (unsigned long)results[x].spd1);
32        }
33     } else if (type == 1) {
34        for (x = 0; x &lt; no_results; x++) {
35          printf
36            (&quot;%-20s[%3d]: Encrypt at %5&quot;PRI64&quot;u, Decrypt at %5&quot;PRI64&quot;u\n&quot;, cipher_descriptor[results[x].id].name, cipher_descriptor[results[x].id].ID, results[x].spd1, results[x].spd2);
37        }
38     } else {
39        for (x = 0; x &lt; no_results; x++) {
40          printf
41            (&quot;%-20s: Process at %5&quot;PRI64&quot;u\n&quot;, hash_descriptor[results[x].id].name, results[x].spd1 / 1000);
42        }
43     }
44  }
45  static ulong64 rdtsc (void)
46     {
47     #if defined __GNUC__ &amp;&amp; !defined(LTC_NO_ASM)
48        #if defined(__i386__) || defined(__x86_64__)
49           unsigned hi, lo;
50           __asm__ __volatile__ (&quot;rdtsc&quot; : &quot;=a&quot;(lo), &quot;=d&quot;(hi));
51           return ((ulong64)lo)|( ((ulong64)hi)&lt;&lt;32);
52        #elif defined(LTC_PPC32) || defined(TFM_PPC32)
53           unsigned long a, b;
54           __asm__ __volatile__ (&quot;mftbu %1 \nmftb %0\n&quot;:&quot;=r&quot;(a), &quot;=r&quot;(b));
55           return (((ulong64)b) &lt;&lt; 32ULL) | ((ulong64)a);
56        #elif defined(__ia64__)  &amp;bsol;* gcc-IA64 version */
57           unsigned long result;
58           __asm__ __volatile__(&quot;mov %0=ar.itc&quot; : &quot;=r&quot;(result) :: &quot;memory&quot;);
59           while (__builtin_expect ((int) result == -1, 0))
60           __asm__ __volatile__(&quot;mov %0=ar.itc&quot; : &quot;=r&quot;(result) :: &quot;memory&quot;);
61           return result;
62        #elif defined(__sparc__)
63           #if defined(__arch64__)
64             ulong64 a;
65             asm volatile(&quot;rd %%tick,%0&quot; : &quot;=r&quot; (a));
66             return a;
67           #else
68             register unsigned long x, y;
69             __asm__ __volatile__ (&quot;rd %%tick, %0; clruw %0, %1; srlx %0, 32, %0&quot; : &quot;=r&quot; (x), &quot;=r&quot; (y) : &quot;0&quot; (x), &quot;1&quot; (y));
70             return ((unsigned long long) x &lt;&lt; 32) | y;
71           #endif
72        #elif defined(__aarch64__)
73           ulong64 CNTVCT_EL0;
74           __asm__ __volatile__ (&quot;mrs %0, cntvct_el0&quot; : &quot;=r&quot;(CNTVCT_EL0));
75           return CNTVCT_EL0;
76        #else
77           return XCLOCK();
78        #endif
79     #elif defined _M_IX86 &amp;&amp; !defined(LTC_NO_ASM)
80       __asm rdtsc
81     #elif defined _M_AMD64 &amp;&amp; !defined(LTC_NO_ASM)
82       return __rdtsc ();
83     #elif defined _M_IA64 &amp;&amp; !defined(LTC_NO_ASM)
84       #if defined __INTEL_COMPILER
85         #include &lt;ia64intrin.h&gt;
86       #endif
87        return __getReg (3116);
88     #else
89       return XCLOCK();
90     #endif
91     }
92  static ulong64 timer, skew = 0;
93  static void t_start(void)
94  {
95     timer = rdtsc();
96  }
97  static ulong64 t_read(void)
98  {
99     return rdtsc() - timer;
100  }
101  static void init_timer(void)
102  {
103     ulong64 c1, c2, t1, t2;
104     unsigned long y1;
105     c1 = c2 = (ulong64)-1;
106     for (y1 = 0; y1 &lt; TIMES*100; y1++) {
107        t_start();
108        t1 = t_read();
109        t2 = (t_read() - t1)&gt;&gt;1;
110        c1 = (t1 &gt; c1) ? t1 : c1;
111        c2 = (t2 &gt; c2) ? t2 : c2;
112     }
113     skew = c2 - c1;
114     fprintf(stderr, &quot;Clock Skew: %lu\n&quot;, (unsigned long)skew);
115  }
116  static void time_keysched(void)
117  {
118    unsigned long x, y1;
119    ulong64 t1, c1;
120    symmetric_key skey;
121    int kl;
122    int    (*func) (const unsigned char *, int , int , symmetric_key *);
123    unsigned char key[MAXBLOCKSIZE];
124    fprintf(stderr, &quot;\n\nKey Schedule Time Trials for the Symmetric Ciphers:\n(Times are cycles per key)\n&quot;);
125    no_results = 0;
126   for (x = 0; cipher_descriptor[x].name != NULL; x++) {
127  #define DO1(k)   func(k, kl, 0, &amp;skey);
128      func = cipher_descriptor[x].setup;
129      kl   = cipher_descriptor[x].min_key_length;
130      c1 = (ulong64)-1;
131      for (y1 = 0; y1 &lt; KTIMES; y1++) {
132         yarrow_read(key, kl, &amp;yarrow_prng);
133         t_start();
134         DO1(key);
135         t1 = t_read();
136         c1 = (t1 &gt; c1) ? c1 : t1;
137      }
138      t1 = c1 - skew;
139      results[no_results].spd1 = results[no_results].avg = t1;
140      results[no_results++].id = x;
141      fprintf(stderr, &quot;.&quot;); fflush(stdout);
142  #undef DO1
143     }
144     tally_results(0);
145  }
146  #ifdef LTC_ECB_MODE
147  static void time_cipher_ecb(void)
148  {
149    unsigned long x, y1;
150    ulong64  t1, t2, c1, c2, a1, a2;
151    symmetric_ECB ecb;
152    unsigned char key[MAXBLOCKSIZE] = { 0 }, pt[4096] = { 0 };
153    int err;
154    fprintf(stderr, &quot;\n\nECB Time Trials for the Symmetric Ciphers:\n&quot;);
155    no_results = 0;
156    for (x = 0; cipher_descriptor[x].name != NULL; x++) {
157      ecb_start(x, key, cipher_descriptor[x].min_key_length, 0, &amp;ecb);
158      if ((err = cipher_descriptor[x].test()) != CRYPT_OK) {
159         fprintf(stderr, &quot;\n\nERROR: Cipher %s failed self-test %s\n&quot;, cipher_descriptor[x].name, error_to_string(err));
160         exit(EXIT_FAILURE);
161      }
162  #define DO1   ecb_encrypt(pt, pt, sizeof(pt), &amp;ecb);
163  #define DO2   DO1 DO1
164      c1 = c2 = (ulong64)-1;
165      for (y1 = 0; y1 &lt; 100; y1++) {
166          t_start();
167          DO1;
168          t1 = t_read();
169          DO2;
170          t2 = t_read();
171          t2 -= t1;
172          c1 = (t1 &gt; c1 ? c1 : t1);
173          c2 = (t2 &gt; c2 ? c2 : t2);
174      }
175      a1 = c2 - c1 - skew;
176  #undef DO1
177  #undef DO2
178  #define DO1   ecb_decrypt(pt, pt, sizeof(pt), &amp;ecb);
179  #define DO2   DO1 DO1
180      c1 = c2 = (ulong64)-1;
181      for (y1 = 0; y1 &lt; 100; y1++) {
182          t_start();
183          DO1;
184          t1 = t_read();
185          DO2;
186          t2 = t_read();
187          t2 -= t1;
188          c1 = (t1 &gt; c1 ? c1 : t1);
189          c2 = (t2 &gt; c2 ? c2 : t2);
190      }
191      a2 = c2 - c1 - skew;
192      ecb_done(&amp;ecb);
193      results[no_results].id = x;
194      results[no_results].spd1 = a1/(sizeof(pt)/cipher_descriptor[x].block_length);
195      results[no_results].spd2 = a2/(sizeof(pt)/cipher_descriptor[x].block_length);
196      results[no_results].avg = (results[no_results].spd1 + results[no_results].spd2+1)/2;
197      ++no_results;
198      fprintf(stderr, &quot;.&quot;); fflush(stdout);
199  #undef DO2
200  #undef DO1
201     }
202     tally_results(1);
203  }
204  #else
205  static void time_cipher_ecb(void) { fprintf(stderr, &quot;NO ECB\n&quot;); return 0; }
206  #endif
207  #ifdef LTC_CBC_MODE
208  static void time_cipher_cbc(void)
209  {
210    unsigned long x, y1;
211    ulong64  t1, t2, c1, c2, a1, a2;
212    symmetric_CBC cbc;
213    unsigned char key[MAXBLOCKSIZE] = { 0 }, pt[4096] = { 0 };
214    int err;
215    fprintf(stderr, &quot;\n\nCBC Time Trials for the Symmetric Ciphers:\n&quot;);
216    no_results = 0;
217    for (x = 0; cipher_descriptor[x].name != NULL; x++) {
218      cbc_start(x, pt, key, cipher_descriptor[x].min_key_length, 0, &amp;cbc);
219      if ((err = cipher_descriptor[x].test()) != CRYPT_OK) {
220         fprintf(stderr, &quot;\n\nERROR: Cipher %s failed self-test %s\n&quot;, cipher_descriptor[x].name, error_to_string(err));
221         exit(EXIT_FAILURE);
222      }
223  #define DO1   cbc_encrypt(pt, pt, sizeof(pt), &amp;cbc);
224  #define DO2   DO1 DO1
225      c1 = c2 = (ulong64)-1;
226      for (y1 = 0; y1 &lt; 100; y1++) {
227          t_start();
228          DO1;
229          t1 = t_read();
230          DO2;
231          t2 = t_read();
232          t2 -= t1;
233          c1 = (t1 &gt; c1 ? c1 : t1);
234          c2 = (t2 &gt; c2 ? c2 : t2);
235      }
236      a1 = c2 - c1 - skew;
237  #undef DO1
238  #undef DO2
239  #define DO1   cbc_decrypt(pt, pt, sizeof(pt), &amp;cbc);
240  #define DO2   DO1 DO1
241      c1 = c2 = (ulong64)-1;
242      for (y1 = 0; y1 &lt; 100; y1++) {
243          t_start();
244          DO1;
245          t1 = t_read();
246          DO2;
247          t2 = t_read();
248          t2 -= t1;
249          c1 = (t1 &gt; c1 ? c1 : t1);
250          c2 = (t2 &gt; c2 ? c2 : t2);
251      }
252      a2 = c2 - c1 - skew;
253      cbc_done(&amp;cbc);
254      results[no_results].id = x;
255      results[no_results].spd1 = a1/(sizeof(pt)/cipher_descriptor[x].block_length);
256      results[no_results].spd2 = a2/(sizeof(pt)/cipher_descriptor[x].block_length);
257      results[no_results].avg = (results[no_results].spd1 + results[no_results].spd2+1)/2;
258      ++no_results;
259      fprintf(stderr, &quot;.&quot;); fflush(stdout);
260  #undef DO2
261  #undef DO1
262     }
263     tally_results(1);
264  }
265  #else
266  static void time_cipher_cbc(void) { fprintf(stderr, &quot;NO CBC\n&quot;); return 0; }
267  #endif
268  #ifdef LTC_CTR_MODE
269  static void time_cipher_ctr(void)
270  {
271    unsigned long x, y1;
272    ulong64  t1, t2, c1, c2, a1, a2;
273    symmetric_CTR ctr;
274    unsigned char key[MAXBLOCKSIZE] = { 0 }, pt[4096] = { 0 };
275    int err;
276    fprintf(stderr, &quot;\n\nCTR Time Trials for the Symmetric Ciphers:\n&quot;);
277    no_results = 0;
278    for (x = 0; cipher_descriptor[x].name != NULL; x++) {
279      ctr_start(x, pt, key, cipher_descriptor[x].min_key_length, 0, CTR_COUNTER_LITTLE_ENDIAN, &amp;ctr);
280      if ((err = cipher_descriptor[x].test()) != CRYPT_OK) {
281         fprintf(stderr, &quot;\n\nERROR: Cipher %s failed self-test %s\n&quot;, cipher_descriptor[x].name, error_to_string(err));
282         exit(EXIT_FAILURE);
283      }
284  #define DO1   ctr_encrypt(pt, pt, sizeof(pt), &amp;ctr);
285  #define DO2   DO1 DO1
286      c1 = c2 = (ulong64)-1;
287      for (y1 = 0; y1 &lt; 100; y1++) {
288          t_start();
289          DO1;
290          t1 = t_read();
291          DO2;
292          t2 = t_read();
293          t2 -= t1;
294          c1 = (t1 &gt; c1 ? c1 : t1);
295          c2 = (t2 &gt; c2 ? c2 : t2);
296      }
297      a1 = c2 - c1 - skew;
298  #undef DO1
299  #undef DO2
300  #define DO1   ctr_decrypt(pt, pt, sizeof(pt), &amp;ctr);
301  #define DO2   DO1 DO1
302      c1 = c2 = (ulong64)-1;
303      for (y1 = 0; y1 &lt; 100; y1++) {
304          t_start();
305          DO1;
306          t1 = t_read();
307          DO2;
308          t2 = t_read();
309          t2 -= t1;
310          c1 = (t1 &gt; c1 ? c1 : t1);
311          c2 = (t2 &gt; c2 ? c2 : t2);
312      }
313      a2 = c2 - c1 - skew;
314      ctr_done(&amp;ctr);
315      results[no_results].id = x;
316      results[no_results].spd1 = a1/(sizeof(pt)/cipher_descriptor[x].block_length);
317      results[no_results].spd2 = a2/(sizeof(pt)/cipher_descriptor[x].block_length);
318      results[no_results].avg = (results[no_results].spd1 + results[no_results].spd2+1)/2;
319      ++no_results;
320      fprintf(stderr, &quot;.&quot;); fflush(stdout);
321  #undef DO2
322  #undef DO1
323     }
324     tally_results(1);
325  }
326  #else
327  static void time_cipher_ctr(void) { fprintf(stderr, &quot;NO CTR\n&quot;); return 0; }
328  #endif
329  #ifdef LTC_LRW_MODE
330  static void time_cipher_lrw(void)
331  {
332    unsigned long x, y1;
333    ulong64  t1, t2, c1, c2, a1, a2;
334    symmetric_LRW lrw;
335    unsigned char key[MAXBLOCKSIZE] = { 0 }, pt[4096] = { 0 };
336    int err;
337    fprintf(stderr, &quot;\n\nLRW Time Trials for the Symmetric Ciphers:\n&quot;);
338    no_results = 0;
339    for (x = 0; cipher_descriptor[x].name != NULL; x++) {
340      if (cipher_descriptor[x].block_length != 16) continue;
341      lrw_start(x, pt, key, cipher_descriptor[x].min_key_length, key, 0, &amp;lrw);
342      if ((err = cipher_descriptor[x].test()) != CRYPT_OK) {
343         fprintf(stderr, &quot;\n\nERROR: Cipher %s failed self-test %s\n&quot;, cipher_descriptor[x].name, error_to_string(err));
344         exit(EXIT_FAILURE);
345      }
346  #define DO1   lrw_encrypt(pt, pt, sizeof(pt), &amp;lrw);
347  #define DO2   DO1 DO1
348      c1 = c2 = (ulong64)-1;
349      for (y1 = 0; y1 &lt; 100; y1++) {
350          t_start();
351          DO1;
352          t1 = t_read();
353          DO2;
354          t2 = t_read();
355          t2 -= t1;
356          c1 = (t1 &gt; c1 ? c1 : t1);
357          c2 = (t2 &gt; c2 ? c2 : t2);
358      }
359      a1 = c2 - c1 - skew;
360  #undef DO1
361  #undef DO2
362  #define DO1   lrw_decrypt(pt, pt, sizeof(pt), &amp;lrw);
363  #define DO2   DO1 DO1
364      c1 = c2 = (ulong64)-1;
365      for (y1 = 0; y1 &lt; 100; y1++) {
366          t_start();
367          DO1;
368          t1 = t_read();
369          DO2;
370          t2 = t_read();
371          t2 -= t1;
372          c1 = (t1 &gt; c1 ? c1 : t1);
373          c2 = (t2 &gt; c2 ? c2 : t2);
374      }
375      a2 = c2 - c1 - skew;
376      lrw_done(&amp;lrw);
377      results[no_results].id = x;
378      results[no_results].spd1 = a1/(sizeof(pt)/cipher_descriptor[x].block_length);
379      results[no_results].spd2 = a2/(sizeof(pt)/cipher_descriptor[x].block_length);
380      results[no_results].avg = (results[no_results].spd1 + results[no_results].spd2+1)/2;
381      ++no_results;
382      fprintf(stderr, &quot;.&quot;); fflush(stdout);
383  #undef DO2
384  #undef DO1
385     }
386     tally_results(1);
387  }
388  #else
389  static void time_cipher_lrw(void) { fprintf(stderr, &quot;NO LRW\n&quot;); }
390  #endif
391  static void time_hash(void)
392  {
393    unsigned long x, y1, len;
394    ulong64 t1, t2, c1, c2;
395    hash_state md;
396    int    (*func)(hash_state *, const unsigned char *, unsigned long), err;
397    unsigned char pt[MAXBLOCKSIZE] = { 0 };
398    fprintf(stderr, &quot;\n\nHASH Time Trials for:\n&quot;);
399    no_results = 0;
400    for (x = 0; hash_descriptor[x].name != NULL; x++) {
401      if ((err = hash_descriptor[x].test()) != CRYPT_OK) {
402         fprintf(stderr, &quot;\n\nERROR: Hash %s failed self-test %s\n&quot;, hash_descriptor[x].name, error_to_string(err));
403         exit(EXIT_FAILURE);
404      }
405      hash_descriptor[x].init(&amp;md);
406  #define DO1   func(&amp;md,pt,len);
407  #define DO2   DO1 DO1
408      func = hash_descriptor[x].process;
409      len  = hash_descriptor[x].blocksize;
410      c1 = c2 = (ulong64)-1;
411      for (y1 = 0; y1 &lt; TIMES; y1++) {
412         t_start();
413         DO1;
414         t1 = t_read();
415         DO2;
416         t2 = t_read() - t1;
417         c1 = (t1 &gt; c1) ? c1 : t1;
418         c2 = (t2 &gt; c2) ? c2 : t2;
419      }
420      t1 = c2 - c1 - skew;
421      t1 = ((t1 * CONST64(1000))) / ((ulong64)hash_descriptor[x].blocksize);
422      results[no_results].id = x;
423      results[no_results].spd1 = results[no_results].avg = t1;
424      ++no_results;
425      fprintf(stderr, &quot;.&quot;); fflush(stdout);
426  #undef DO2
427  #undef DO1
428     }
429     tally_results(2);
430  }
431  static void time_mult(void)
432  {
433     ulong64 t1, t2;
434     unsigned long x, y;
435     void  *a, *b, *c;
436     if (ltc_mp.name == NULL) return;
437     fprintf(stderr, &quot;Timing Multiplying:\n&quot;);
438     mp_init_multi(&amp;a,&amp;b,&amp;c,NULL);
439     for (x = 128/MP_DIGIT_BIT; x &lt;= (unsigned long)1536/MP_DIGIT_BIT; x += 128/MP_DIGIT_BIT) {
440         mp_rand(a, x);
441         mp_rand(b, x);
442  #define DO1 mp_mul(a, b, c);
443  #define DO2 DO1; DO1;
444         t2 = -1;
445         for (y = 0; y &lt; TIMES; y++) {
446             t_start();
447             t1 = t_read();
448             DO2;
449             t1 = (t_read() - t1)&gt;&gt;1;
450             if (t1 &lt; t2) t2 = t1;
451         }
452         fprintf(stderr, &quot;%4lu bits: %9&quot;PRI64&quot;u cycles\n&quot;, x*MP_DIGIT_BIT, t2);
453     }
454     mp_clear_multi(a,b,c,NULL);
455  #undef DO1
456  #undef DO2
457  }
458  static void time_sqr(void)
459  {
460     ulong64 t1, t2;
461     unsigned long x, y;
462     void *a, *b;
463     if (ltc_mp.name == NULL) return;
464     fprintf(stderr, &quot;Timing Squaring:\n&quot;);
465     mp_init_multi(&amp;a,&amp;b,NULL);
466     for (x = 128/MP_DIGIT_BIT; x &lt;= (unsigned long)1536/MP_DIGIT_BIT; x += 128/MP_DIGIT_BIT) {
467         mp_rand(a, x);
468  #define DO1 mp_sqr(a, b);
469  #define DO2 DO1; DO1;
470         t2 = -1;
471         for (y = 0; y &lt; TIMES; y++) {
472             t_start();
473             t1 = t_read();
474             DO2;
475             t1 = (t_read() - t1)&gt;&gt;1;
476             if (t1 &lt; t2) t2 = t1;
477         }
478         fprintf(stderr, &quot;%4lu bits: %9&quot;PRI64&quot;u cycles\n&quot;, x*MP_DIGIT_BIT, t2);
479     }
480     mp_clear_multi(a,b,NULL);
481  #undef DO1
482  #undef DO2
483  }
484  static void time_prng(void)
485  {
486     ulong64 t1, t2;
487     unsigned char buf[4096];
488     prng_state tprng;
489     unsigned long x, y;
490     int           err;
491     fprintf(stderr, &quot;Timing PRNGs (cycles/byte output, cycles add_entropy (32 bytes) :\n&quot;);
492     for (x = 0; prng_descriptor[x].name != NULL; x++) {
493        if ((err = prng_descriptor[x].test()) != CRYPT_OK) {
494           fprintf(stderr, &quot;\n\nERROR: PRNG %s failed self-test %s\n&quot;, prng_descriptor[x].name, error_to_string(err));
495           exit(EXIT_FAILURE);
496        }
497        prng_descriptor[x].start(&amp;tprng);
498        zeromem(buf, 256);
499        prng_descriptor[x].add_entropy(buf, 256, &amp;tprng);
500        prng_descriptor[x].ready(&amp;tprng);
501        t2 = -1;
502  #define DO1 if (prng_descriptor[x].read(buf, 4096, &amp;tprng) != 4096) { fprintf(stderr, &quot;\n\nERROR READ != 4096\n\n&quot;); exit(EXIT_FAILURE); }
503  #define DO2 DO1 DO1
504        for (y = 0; y &lt; 10000; y++) {
505           t_start();
506           t1 = t_read();
507           DO2;
508           t1 = (t_read() - t1)&gt;&gt;1;
509           if (t1 &lt; t2) t2 = t1;
510        }
511        fprintf(stderr, &quot;%20s: %5&quot;PRI64&quot;u &quot;, prng_descriptor[x].name, t2&gt;&gt;12);
512  #undef DO2
513  #undef DO1
514  #define DO1 prng_descriptor[x].start(&amp;tprng); prng_descriptor[x].add_entropy(buf, 32, &amp;tprng); prng_descriptor[x].ready(&amp;tprng); prng_descriptor[x].done(&amp;tprng);
515  #define DO2 DO1 DO1
516        for (y = 0; y &lt; 10000; y++) {
517           t_start();
518           t1 = t_read();
519           DO2;
520           t1 = (t_read() - t1)&gt;&gt;1;
521           if (t1 &lt; t2) t2 = t1;
522        }
523        fprintf(stderr, &quot;%5&quot;PRI64&quot;u\n&quot;, t2);
524  #undef DO2
525  #undef DO1
526     }
527  }
528  #if defined(LTC_MDSA)
529  static void time_dsa(void)
530  {
531     dsa_key       key;
532     ulong64       t1, t2;
533     unsigned long x, y;
534     int           err;
535  static const struct {
536     int group, modulus;
537  } groups[] = {
538  { 20, 96  },
539  { 20, 128 },
540  { 24, 192 },
541  { 28, 256 },
542  #ifndef TFM_DESC
543  { 32, 512 },
544  #endif
545  };
546     if (ltc_mp.name == NULL) return;
547     for (x = 0; x &lt; (sizeof(groups)/sizeof(groups[0])); x++) {
548         t2 = 0;
549         for (y = 0; y &lt; 4; y++) {
550             t_start();
551             t1 = t_read();
552             if ((err = dsa_generate_pqg(&amp;yarrow_prng, find_prng(&quot;yarrow&quot;), groups[x].group, groups[x].modulus, &amp;key)) != CRYPT_OK) {
553                fprintf(stderr, &quot;\n\ndsa_generate_pqg says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
554                exit(EXIT_FAILURE);
555             }
556             if ((err = dsa_generate_key(&amp;yarrow_prng, find_prng(&quot;yarrow&quot;), &amp;key)) != CRYPT_OK) {
557                fprintf(stderr, &quot;\n\ndsa_make_key says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
558                exit(EXIT_FAILURE);
559             }
560             t1 = t_read() - t1;
561             t2 += t1;
562  #ifdef LTC_PROFILE
563         t2 &lt;&lt;= 2;
564         break;
565  #endif
566             if (y &lt; 3) {
567                dsa_free(&amp;key);
568             }
569         }
570         t2 &gt;&gt;= 2;
571         fprintf(stderr, &quot;DSA-(%lu, %lu) make_key    took %15&quot;PRI64&quot;u cycles\n&quot;, (unsigned long)groups[x].group*8, (unsigned long)groups[x].modulus*8, t2);
572         dsa_free(&amp;key);
573     }
574     fprintf(stderr, &quot;\n\n&quot;);
575  }
576  #else
577  static void time_dsa(void) { fprintf(stderr, &quot;NO DSA\n&quot;); }
578  #endif
579  #if defined(LTC_MRSA)
580  static void time_rsa(void)
581  {
582     rsa_key       key;
583     ulong64       t1, t2;
584     unsigned char buf[2][2048] = { 0 };
585     unsigned long x, y, z, zzz;
586     int           err, zz, stat;
587     if (ltc_mp.name == NULL) return;
588     for (x = 2048; x &lt;= 8192; x &lt;&lt;= 1) {
589         t2 = 0;
590         for (y = 0; y &lt; 4; y++) {
591             t_start();
592             t1 = t_read();
593             if ((err = rsa_make_key(&amp;yarrow_prng, find_prng(&quot;yarrow&quot;), x/8, 65537, &amp;key)) != CRYPT_OK) {
594                fprintf(stderr, &quot;\n\nrsa_make_key says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
595                exit(EXIT_FAILURE);
596             }
597             t1 = t_read() - t1;
598             t2 += t1;
599  #ifdef LTC_PROFILE
600         t2 &lt;&lt;= 2;
601         break;
602  #endif
603             if (y &lt; 3) {
604                rsa_free(&amp;key);
605             }
606         }
607         t2 &gt;&gt;= 2;
608         fprintf(stderr, &quot;RSA-%lu make_key    took %15&quot;PRI64&quot;u cycles\n&quot;, x, t2);
609         t2 = 0;
610         for (y = 0; y &lt; 16; y++) {
611             t_start();
612             t1 = t_read();
613             z = sizeof(buf[1]);
614             if ((err = rsa_encrypt_key(buf[0], 32, buf[1], &amp;z, (const unsigned char *)&quot;testprog&quot;, 8, &amp;yarrow_prng,
615                                        find_prng(&quot;yarrow&quot;), find_hash(&quot;sha1&quot;),
616                                        &amp;key)) != CRYPT_OK) {
617                fprintf(stderr, &quot;\n\nrsa_encrypt_key says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
618                exit(EXIT_FAILURE);
619             }
620             t1 = t_read() - t1;
621             t2 += t1;
622  #ifdef LTC_PROFILE
623         t2 &lt;&lt;= 4;
624         break;
625  #endif
626         }
627         t2 &gt;&gt;= 4;
628         fprintf(stderr, &quot;RSA-%lu encrypt_key took %15&quot;PRI64&quot;u cycles\n&quot;, x, t2);
629         t2 = 0;
630         for (y = 0; y &lt; 2048; y++) {
631             t_start();
632             t1 = t_read();
633             zzz = sizeof(buf[0]);
634             if ((err = rsa_decrypt_key(buf[1], z, buf[0], &amp;zzz, (const unsigned char *)&quot;testprog&quot;, 8,  find_hash(&quot;sha1&quot;),
635                                        &amp;zz, &amp;key)) != CRYPT_OK) {
636                fprintf(stderr, &quot;\n\nrsa_decrypt_key says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
637                exit(EXIT_FAILURE);
638             }
639             t1 = t_read() - t1;
640             t2 += t1;
641  #ifdef LTC_PROFILE
642         t2 &lt;&lt;= 11;
643         break;
644  #endif
645         }
646         t2 &gt;&gt;= 11;
647         fprintf(stderr, &quot;RSA-%lu decrypt_key took %15&quot;PRI64&quot;u cycles\n&quot;, x, t2);
648         t2 = 0;
649         for (y = 0; y &lt; 256; y++) {
650            t_start();
651            t1 = t_read();
652            z = sizeof(buf[1]);
653            if ((err = rsa_sign_hash(buf[0], 20, buf[1], &amp;z, &amp;yarrow_prng,
654                                     find_prng(&quot;yarrow&quot;), find_hash(&quot;sha1&quot;), 8, &amp;key)) != CRYPT_OK) {
655                fprintf(stderr, &quot;\n\nrsa_sign_hash says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
656                exit(EXIT_FAILURE);
657             }
658             t1 = t_read() - t1;
659             t2 += t1;
660  #ifdef LTC_PROFILE
661         t2 &lt;&lt;= 8;
662         break;
663  #endif
664          }
665          t2 &gt;&gt;= 8;
666          fprintf(stderr, &quot;RSA-%lu sign_hash took   %15&quot;PRI64&quot;u cycles\n&quot;, x, t2);
667         t2 = 0;
668         for (y = 0; y &lt; 2048; y++) {
669            t_start();
670            t1 = t_read();
671            if ((err = rsa_verify_hash(buf[1], z, buf[0], 20, find_hash(&quot;sha1&quot;), 8, &amp;stat, &amp;key)) != CRYPT_OK) {
672                fprintf(stderr, &quot;\n\nrsa_verify_hash says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
673                exit(EXIT_FAILURE);
674            }
675            if (stat == 0) {
676               fprintf(stderr, &quot;\n\nrsa_verify_hash for RSA-%lu failed to verify signature(%lu)\n&quot;, x, y);
677               exit(EXIT_FAILURE);
678            }
679            t1 = t_read() - t1;
680            t2 += t1;
681  #ifdef LTC_PROFILE
682         t2 &lt;&lt;= 11;
683         break;
684  #endif
685          }
686          t2 &gt;&gt;= 11;
687          fprintf(stderr, &quot;RSA-%lu verify_hash took %15&quot;PRI64&quot;u cycles\n&quot;, x, t2);
688         fprintf(stderr, &quot;\n\n&quot;);
689         rsa_free(&amp;key);
690    }
691  }
692  #else
693  static void time_rsa(void) { fprintf(stderr, &quot;NO RSA\n&quot;); }
694  #endif
695  #if defined(LTC_MDH)
696  static void time_dh(void)
697  {
698     dh_key key;
699     ulong64 t1, t2;
700     unsigned long i, x, y;
701     int           err;
702     static unsigned long sizes[] = {768/8, 1024/8, 1536/8, 2048/8,
703  #ifndef TFM_DESC
704                                     3072/8, 4096/8, 6144/8, 8192/8,
705  #endif
706                                     100000
707     };
708     if (ltc_mp.name == NULL) return;
709     for (x = sizes[i=0]; x &lt; 100000; x = sizes[++i]) {
710         t2 = 0;
711         for (y = 0; y &lt; 16; y++) {
712             if((err = dh_set_pg_groupsize(x, &amp;key)) != CRYPT_OK) {
713                fprintf(stderr, &quot;\n\ndh_set_pg_groupsize says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
714                exit(EXIT_FAILURE);
715             }
716             t_start();
717             t1 = t_read();
718             if ((err = dh_generate_key(&amp;yarrow_prng, find_prng(&quot;yarrow&quot;), &amp;key)) != CRYPT_OK) {
719                fprintf(stderr, &quot;\n\ndh_make_key says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
720                exit(EXIT_FAILURE);
721             }
722             t1 = t_read() - t1;
723             t2 += t1;
724             dh_free(&amp;key);
725         }
726         t2 &gt;&gt;= 4;
727         fprintf(stderr, &quot;DH-%4lu make_key    took %15&quot;PRI64&quot;u cycles\n&quot;, x*8, t2);
728    }
729  }
730  #else
731  static void time_dh(void) { fprintf(stderr, &quot;NO DH\n&quot;); }
732  #endif
733  #if defined(LTC_MECC)
734  static void time_ecc(void)
735  {
736     ecc_key key;
737     ulong64 t1, t2;
738     unsigned char buf[2][256] = { 0 };
739     unsigned long i, w, x, y, z;
740     int           err, stat;
741     static unsigned long sizes[] = {
742  #ifdef LTC_ECC_SECP112R1
743  112/8,
744  #endif
745  #ifdef LTC_ECC_SECP128R1
746  128/8,
747  #endif
748  #ifdef LTC_ECC_SECP160R1
749  160/8,
750  #endif
751  #ifdef LTC_ECC_SECP192R1
752  192/8,
753  #endif
754  #ifdef LTC_ECC_SECP224R1
755  224/8,
756  #endif
757  #ifdef LTC_ECC_SECP256R1
758  256/8,
759  #endif
760  #ifdef LTC_ECC_SECP384R1
761  384/8,
762  #endif
763  #ifdef LTC_ECC_SECP512R1
764  521/8,
765  #endif
766  100000};
767     if (ltc_mp.name == NULL) return;
768     for (x = sizes[i=0]; x &lt; 100000; x = sizes[++i]) {
769         t2 = 0;
770         for (y = 0; y &lt; 256; y++) {
771             t_start();
772             t1 = t_read();
773             if ((err = ecc_make_key(&amp;yarrow_prng, find_prng(&quot;yarrow&quot;), x, &amp;key)) != CRYPT_OK) {
774                fprintf(stderr, &quot;\n\necc_make_key says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
775                exit(EXIT_FAILURE);
776             }
777             t1 = t_read() - t1;
778             t2 += t1;
779  #ifdef LTC_PROFILE
780         t2 &lt;&lt;= 8;
781         break;
782  #endif
783             if (y &lt; 255) {
784                ecc_free(&amp;key);
785             }
786         }
787         t2 &gt;&gt;= 8;
788         fprintf(stderr, &quot;ECC-%lu make_key    took %15&quot;PRI64&quot;u cycles\n&quot;, x*8, t2);
789         t2 = 0;
790         for (y = 0; y &lt; 256; y++) {
791             t_start();
792             t1 = t_read();
793             z = sizeof(buf[1]);
794             if ((err = ecc_encrypt_key(buf[0], 20, buf[1], &amp;z, &amp;yarrow_prng, find_prng(&quot;yarrow&quot;), find_hash(&quot;sha1&quot;),
795                                        &amp;key)) != CRYPT_OK) {
796                fprintf(stderr, &quot;\n\necc_encrypt_key says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
797                exit(EXIT_FAILURE);
798             }
799             t1 = t_read() - t1;
800             t2 += t1;
801  #ifdef LTC_PROFILE
802         t2 &lt;&lt;= 8;
803         break;
804  #endif
805         }
806         t2 &gt;&gt;= 8;
807         fprintf(stderr, &quot;ECC-%lu encrypt_key took %15&quot;PRI64&quot;u cycles\n&quot;, x*8, t2);
808         t2 = 0;
809         for (y = 0; y &lt; 256; y++) {
810             t_start();
811             t1 = t_read();
812             w = 20;
813             if ((err = ecc_decrypt_key(buf[1], z, buf[0], &amp;w, &amp;key)) != CRYPT_OK) {
814                fprintf(stderr, &quot;\n\necc_decrypt_key says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
815                exit(EXIT_FAILURE);
816             }
817             t1 = t_read() - t1;
818             t2 += t1;
819  #ifdef LTC_PROFILE
820         t2 &lt;&lt;= 8;
821         break;
822  #endif
823         }
824         t2 &gt;&gt;= 8;
825         fprintf(stderr, &quot;ECC-%lu decrypt_key took %15&quot;PRI64&quot;u cycles\n&quot;, x*8, t2);
826         t2 = 0;
827         for (y = 0; y &lt; 256; y++) {
828            t_start();
829            t1 = t_read();
830            z = sizeof(buf[1]);
831            if ((err = ecc_sign_hash(buf[0], 20, buf[1], &amp;z, &amp;yarrow_prng,
832                                     find_prng(&quot;yarrow&quot;), &amp;key)) != CRYPT_OK) {
833                fprintf(stderr, &quot;\n\necc_sign_hash says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
834                exit(EXIT_FAILURE);
835             }
836             t1 = t_read() - t1;
837             t2 += t1;
838  #ifdef LTC_PROFILE
839         t2 &lt;&lt;= 8;
840         break;
841  #endif
842          }
843          t2 &gt;&gt;= 8;
844          fprintf(stderr, &quot;ECC-%lu sign_hash took   %15&quot;PRI64&quot;u cycles\n&quot;, x*8, t2);
845         t2 = 0;
846         for (y = 0; y &lt; 256; y++) {
847            t_start();
848            t1 = t_read();
849            if ((err = ecc_verify_hash(buf[1], z, buf[0], 20, &amp;stat, &amp;key)) != CRYPT_OK) {
850                fprintf(stderr, &quot;\n\necc_verify_hash says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
851                exit(EXIT_FAILURE);
852            }
853            if (stat == 0) {
854               fprintf(stderr, &quot;\n\necc_verify_hash for ECC-%lu failed to verify signature(%lu)\n&quot;, x*8, y);
855               exit(EXIT_FAILURE);
856            }
857            t1 = t_read() - t1;
858            t2 += t1;
859  #ifdef LTC_PROFILE
860         t2 &lt;&lt;= 8;
861         break;
862  #endif
863          }
864          t2 &gt;&gt;= 8;
865          fprintf(stderr, &quot;ECC-%lu verify_hash took %15&quot;PRI64&quot;u cycles\n&quot;, x*8, t2);
866         fprintf(stderr, &quot;\n\n&quot;);
867         ecc_free(&amp;key);
868    }
869  }
870  #else
871  static void time_ecc(void) { fprintf(stderr, &quot;NO ECC\n&quot;); }
872  #endif
873  static void time_macs_(unsigned long MAC_SIZE)
874  {
875  #if defined(LTC_OMAC) || defined(LTC_XCBC) || defined(LTC_F9_MODE) || defined(LTC_PMAC) || defined(LTC_PELICAN) || defined(LTC_HMAC)
876     unsigned char *buf, key[16], tag[16];
877     ulong64 t1, t2;
878     unsigned long x, z;
879     int err, cipher_idx, hash_idx;
880     fprintf(stderr, &quot;\nMAC Timings (cycles/byte on %luKB blocks):\n&quot;, MAC_SIZE);
881     buf = XMALLOC(MAC_SIZE*1024);
882     if (buf == NULL) {
883        fprintf(stderr, &quot;\n\nout of heap yo\n\n&quot;);
884        exit(EXIT_FAILURE);
885     }
886     cipher_idx = find_cipher(&quot;aes&quot;);
887     hash_idx   = find_hash(&quot;sha1&quot;);
888     if (cipher_idx == -1 || hash_idx == -1) {
889        fprintf(stderr, &quot;Warning the MAC tests requires AES and SHA1 to operate... so sorry\n&quot;);
890        exit(EXIT_FAILURE);
891     }
892     yarrow_read(buf, MAC_SIZE*1024, &amp;yarrow_prng);
<span onclick='openModal()' class='match'>893     yarrow_read(key, 16, &amp;yarrow_prng);
894  #ifdef LTC_OMAC
895     t2 = -1;
896     for (x = 0; x &lt; 10000; x++) {
897          t_start();
898          t1 = t_read();
899          z = 16;
900          if ((err = omac_memory(cipher_idx, key, 16, buf, MAC_SIZE*1024, tag, &amp;z)) != CRYPT_OK) {
</span>901             fprintf(stderr, &quot;\n\nomac-%s error... %s\n&quot;, cipher_descriptor[cipher_idx].name, error_to_string(err));
902             exit(EXIT_FAILURE);
903          }
904          t1 = t_read() - t1;
905          if (t1 &lt; t2) t2 = t1;
906     }
907     fprintf(stderr, &quot;OMAC-%s\t\t%9&quot;PRI64&quot;u\n&quot;, cipher_descriptor[cipher_idx].name, t2/(ulong64)(MAC_SIZE*1024));
908  #endif
909  #ifdef LTC_XCBC
910     t2 = -1;
911     for (x = 0; x &lt; 10000; x++) {
912          t_start();
913          t1 = t_read();
914          z = 16;
915          if ((err = xcbc_memory(cipher_idx, key, 16, buf, MAC_SIZE*1024, tag, &amp;z)) != CRYPT_OK) {
916             fprintf(stderr, &quot;\n\nxcbc-%s error... %s\n&quot;, cipher_descriptor[cipher_idx].name, error_to_string(err));
917             exit(EXIT_FAILURE);
918          }
919          t1 = t_read() - t1;
920          if (t1 &lt; t2) t2 = t1;
921     }
922     fprintf(stderr, &quot;XCBC-%s\t\t%9&quot;PRI64&quot;u\n&quot;, cipher_descriptor[cipher_idx].name, t2/(ulong64)(MAC_SIZE*1024));
923  #endif
924  #ifdef LTC_F9_MODE
925     t2 = -1;
926     for (x = 0; x &lt; 10000; x++) {
927          t_start();
928          t1 = t_read();
929          z = 16;
930          if ((err = f9_memory(cipher_idx, key, 16, buf, MAC_SIZE*1024, tag, &amp;z)) != CRYPT_OK) {
931             fprintf(stderr, &quot;\n\nF9-%s error... %s\n&quot;, cipher_descriptor[cipher_idx].name, error_to_string(err));
932             exit(EXIT_FAILURE);
933          }
934          t1 = t_read() - t1;
935          if (t1 &lt; t2) t2 = t1;
936     }
937     fprintf(stderr, &quot;F9-%s\t\t\t%9&quot;PRI64&quot;u\n&quot;, cipher_descriptor[cipher_idx].name, t2/(ulong64)(MAC_SIZE*1024));
938  #endif
939  #ifdef LTC_PMAC
940     t2 = -1;
941     for (x = 0; x &lt; 10000; x++) {
942          t_start();
943          t1 = t_read();
944          z = 16;
945          if ((err = pmac_memory(cipher_idx, key, 16, buf, MAC_SIZE*1024, tag, &amp;z)) != CRYPT_OK) {
946             fprintf(stderr, &quot;\n\npmac-%s error... %s\n&quot;, cipher_descriptor[cipher_idx].name, error_to_string(err));
947             exit(EXIT_FAILURE);
948          }
949          t1 = t_read() - t1;
950          if (t1 &lt; t2) t2 = t1;
951     }
952     fprintf(stderr, &quot;PMAC-%s\t\t%9&quot;PRI64&quot;u\n&quot;, cipher_descriptor[cipher_idx].name, t2/(ulong64)(MAC_SIZE*1024));
953  #endif
954  #ifdef LTC_PELICAN
955     t2 = -1;
956     for (x = 0; x &lt; 10000; x++) {
957          t_start();
958          t1 = t_read();
959          z = 16;
960          if ((err = pelican_memory(key, 16, buf, MAC_SIZE*1024, tag)) != CRYPT_OK) {
961             fprintf(stderr, &quot;\n\npelican error... %s\n&quot;, error_to_string(err));
962             exit(EXIT_FAILURE);
963          }
964          t1 = t_read() - t1;
965          if (t1 &lt; t2) t2 = t1;
966     }
967     fprintf(stderr, &quot;PELICAN \t\t%9&quot;PRI64&quot;u\n&quot;, t2/(ulong64)(MAC_SIZE*1024));
968  #endif
969  #ifdef LTC_HMAC
970     t2 = -1;
971     for (x = 0; x &lt; 10000; x++) {
972          t_start();
973          t1 = t_read();
974          z = 16;
975          if ((err = hmac_memory(hash_idx, key, 16, buf, MAC_SIZE*1024, tag, &amp;z)) != CRYPT_OK) {
976             fprintf(stderr, &quot;\n\nhmac-%s error... %s\n&quot;, hash_descriptor[hash_idx].name, error_to_string(err));
977             exit(EXIT_FAILURE);
978          }
979          t1 = t_read() - t1;
980          if (t1 &lt; t2) t2 = t1;
981     }
982     fprintf(stderr, &quot;HMAC-%s\t\t%9&quot;PRI64&quot;u\n&quot;, hash_descriptor[hash_idx].name, t2/(ulong64)(MAC_SIZE*1024));
983  #endif
984     XFREE(buf);
985  #else
986     LTC_UNUSED_PARAM(MAC_SIZE);
987     fprintf(stderr, &quot;NO MACs\n&quot;);
988  #endif
989  }
990  static void time_macs(void)
991  {
992     time_macs_(1);
993     time_macs_(4);
994     time_macs_(32);
995  }
996  static void time_encmacs_(unsigned long MAC_SIZE)
997  {
998  #if defined(LTC_EAX_MODE) || defined(LTC_OCB_MODE) || defined(LTC_OCB3_MODE) || defined(LTC_CCM_MODE) || defined(LTC_GCM_MODE)
999     unsigned char *buf, IV[16], key[16], tag[16];
1000     ulong64 t1, t2;
1001     unsigned long x, z;
1002     int err, cipher_idx;
1003     symmetric_key skey;
1004     fprintf(stderr, &quot;\nENC+MAC Timings (zero byte AAD, 16 byte IV, cycles/byte on %luKB blocks):\n&quot;, MAC_SIZE);
1005     buf = XMALLOC(MAC_SIZE*1024);
1006     if (buf == NULL) {
1007        fprintf(stderr, &quot;\n\nout of heap yo\n\n&quot;);
1008        exit(EXIT_FAILURE);
1009     }
1010     cipher_idx = find_cipher(&quot;aes&quot;);
1011     yarrow_read(buf, MAC_SIZE*1024, &amp;yarrow_prng);
1012     yarrow_read(key, 16, &amp;yarrow_prng);
1013     yarrow_read(IV, 16, &amp;yarrow_prng);
1014  #ifdef LTC_EAX_MODE
1015     t2 = -1;
1016     for (x = 0; x &lt; 10000; x++) {
1017          t_start();
1018          t1 = t_read();
1019          z = 16;
1020          if ((err = eax_encrypt_authenticate_memory(cipher_idx, key, 16, IV, 16, NULL, 0, buf, MAC_SIZE*1024, buf, tag, &amp;z)) != CRYPT_OK) {
1021             fprintf(stderr, &quot;\nEAX error... %s\n&quot;, error_to_string(err));
1022             exit(EXIT_FAILURE);
1023          }
1024          t1 = t_read() - t1;
1025          if (t1 &lt; t2) t2 = t1;
1026     }
1027     fprintf(stderr, &quot;EAX \t\t\t%9&quot;PRI64&quot;u\n&quot;, t2/(ulong64)(MAC_SIZE*1024));
1028  #endif
1029  #ifdef LTC_OCB_MODE
1030     t2 = -1;
1031     for (x = 0; x &lt; 10000; x++) {
1032          t_start();
1033          t1 = t_read();
1034          z = 16;
1035          if ((err = ocb_encrypt_authenticate_memory(cipher_idx, key, 16, IV, buf, MAC_SIZE*1024, buf, tag, &amp;z)) != CRYPT_OK) {
1036             fprintf(stderr, &quot;\nOCB error... %s\n&quot;, error_to_string(err));
1037             exit(EXIT_FAILURE);
1038          }
1039          t1 = t_read() - t1;
1040          if (t1 &lt; t2) t2 = t1;
1041     }
1042     fprintf(stderr, &quot;OCB \t\t\t%9&quot;PRI64&quot;u\n&quot;, t2/(ulong64)(MAC_SIZE*1024));
1043  #endif
1044  #ifdef LTC_OCB3_MODE
1045     t2 = -1;
1046     for (x = 0; x &lt; 10000; x++) {
1047          t_start();
1048          t1 = t_read();
1049          z = 16;
1050          if ((err = ocb3_encrypt_authenticate_memory(cipher_idx, key, 16, IV, 15, (unsigned char*)&quot;&quot;, 0, buf, MAC_SIZE*1024, buf, tag, &amp;z)) != CRYPT_OK) {
1051             fprintf(stderr, &quot;\nOCB3 error... %s\n&quot;, error_to_string(err));
1052             exit(EXIT_FAILURE);
1053          }
1054          t1 = t_read() - t1;
1055          if (t1 &lt; t2) t2 = t1;
1056     }
1057     fprintf(stderr, &quot;OCB3 \t\t\t%9&quot;PRI64&quot;u\n&quot;, t2/(ulong64)(MAC_SIZE*1024));
1058  #endif
1059  #ifdef LTC_CCM_MODE
1060     t2 = -1;
1061     for (x = 0; x &lt; 10000; x++) {
1062          t_start();
1063          t1 = t_read();
1064          z = 16;
1065          if ((err = ccm_memory(cipher_idx, key, 16, NULL, IV, 16, NULL, 0, buf, MAC_SIZE*1024, buf, tag, &amp;z, CCM_ENCRYPT)) != CRYPT_OK) {
1066             fprintf(stderr, &quot;\nCCM error... %s\n&quot;, error_to_string(err));
1067             exit(EXIT_FAILURE);
1068          }
1069          t1 = t_read() - t1;
1070          if (t1 &lt; t2) t2 = t1;
1071     }
1072     fprintf(stderr, &quot;CCM (no-precomp) \t%9&quot;PRI64&quot;u\n&quot;, t2/(ulong64)(MAC_SIZE*1024));
1073     cipher_descriptor[cipher_idx].setup(key, 16, 0, &amp;skey);
1074     t2 = -1;
1075     for (x = 0; x &lt; 10000; x++) {
1076          t_start();
1077          t1 = t_read();
1078          z = 16;
1079          if ((err = ccm_memory(cipher_idx, key, 16, &amp;skey, IV, 16, NULL, 0, buf, MAC_SIZE*1024, buf, tag, &amp;z, CCM_ENCRYPT)) != CRYPT_OK) {
1080             fprintf(stderr, &quot;\nCCM error... %s\n&quot;, error_to_string(err));
1081             exit(EXIT_FAILURE);
1082          }
1083          t1 = t_read() - t1;
1084          if (t1 &lt; t2) t2 = t1;
1085     }
1086     fprintf(stderr, &quot;CCM (precomp) \t\t%9&quot;PRI64&quot;u\n&quot;, t2/(ulong64)(MAC_SIZE*1024));
1087     cipher_descriptor[cipher_idx].done(&amp;skey);
1088  #endif
1089  #ifdef LTC_GCM_MODE
1090     t2 = -1;
1091     for (x = 0; x &lt; 100; x++) {
1092          t_start();
1093          t1 = t_read();
1094          z = 16;
1095          if ((err = gcm_memory(cipher_idx, key, 16, IV, 16, NULL, 0, buf, MAC_SIZE*1024, buf, tag, &amp;z, GCM_ENCRYPT)) != CRYPT_OK) {
1096             fprintf(stderr, &quot;\nGCM error... %s\n&quot;, error_to_string(err));
1097             exit(EXIT_FAILURE);
1098          }
1099          t1 = t_read() - t1;
1100          if (t1 &lt; t2) t2 = t1;
1101     }
1102     fprintf(stderr, &quot;GCM (no-precomp)\t%9&quot;PRI64&quot;u\n&quot;, t2/(ulong64)(MAC_SIZE*1024));
1103     {
1104     gcm_state gcm
1105  #ifdef LTC_GCM_TABLES_SSE2
1106  __attribute__ ((aligned (16)))
1107  #endif
1108  ;
1109     if ((err = gcm_init(&amp;gcm, cipher_idx, key, 16)) != CRYPT_OK) { fprintf(stderr, &quot;gcm_init: %s\n&quot;, error_to_string(err)); exit(EXIT_FAILURE); }
1110     t2 = -1;
1111     for (x = 0; x &lt; 10000; x++) {
1112          t_start();
1113          t1 = t_read();
1114          z = 16;
1115          if ((err = gcm_reset(&amp;gcm)) != CRYPT_OK) {
1116              fprintf(stderr, &quot;\nGCM error[%d]... %s\n&quot;, __LINE__, error_to_string(err));
1117             exit(EXIT_FAILURE);
1118          }
1119          if ((err = gcm_add_iv(&amp;gcm, IV, 16)) != CRYPT_OK) {
1120              fprintf(stderr, &quot;\nGCM error[%d]... %s\n&quot;, __LINE__, error_to_string(err));
1121             exit(EXIT_FAILURE);
1122          }
1123          if ((err = gcm_add_aad(&amp;gcm, NULL, 0)) != CRYPT_OK) {
1124              fprintf(stderr, &quot;\nGCM error[%d]... %s\n&quot;, __LINE__, error_to_string(err));
1125             exit(EXIT_FAILURE);
1126          }
1127          if ((err = gcm_process(&amp;gcm, buf, MAC_SIZE*1024, buf, GCM_ENCRYPT)) != CRYPT_OK) {
1128              fprintf(stderr, &quot;\nGCM error[%d]... %s\n&quot;, __LINE__, error_to_string(err));
1129             exit(EXIT_FAILURE);
1130          }
1131          if ((err = gcm_done(&amp;gcm, tag, &amp;z)) != CRYPT_OK) {
1132              fprintf(stderr, &quot;\nGCM error[%d]... %s\n&quot;, __LINE__, error_to_string(err));
1133             exit(EXIT_FAILURE);
1134          }
1135          t1 = t_read() - t1;
1136          if (t1 &lt; t2) t2 = t1;
1137     }
1138     fprintf(stderr, &quot;GCM (precomp)\t\t%9&quot;PRI64&quot;u\n&quot;, t2/(ulong64)(MAC_SIZE*1024));
1139     }
1140  #endif
1141     XFREE(buf);
1142  #else
1143     LTC_UNUSED_PARAM(MAC_SIZE);
1144     fprintf(stderr, &quot;NO ENCMACs\n&quot;);
1145  #endif
1146  }
1147  static void time_encmacs(void)
1148  {
1149     time_encmacs_(1);
1150     time_encmacs_(4);
1151     time_encmacs_(32);
1152  }
1153  #define LTC_TEST_FN(f)  { f, #f }
1154  int main(int argc, char **argv)
1155  {
1156  int err;
1157  const struct
1158  {
1159     void (*fn)(void);
1160     const char* name;
1161  } test_functions[] = {
1162     LTC_TEST_FN(time_keysched),
1163     LTC_TEST_FN(time_cipher_ecb),
1164     LTC_TEST_FN(time_cipher_cbc),
1165     LTC_TEST_FN(time_cipher_ctr),
1166     LTC_TEST_FN(time_cipher_lrw),
1167     LTC_TEST_FN(time_hash),
1168     LTC_TEST_FN(time_macs),
1169     LTC_TEST_FN(time_encmacs),
1170     LTC_TEST_FN(time_prng),
1171     LTC_TEST_FN(time_mult),
1172     LTC_TEST_FN(time_sqr),
1173     LTC_TEST_FN(time_rsa),
1174     LTC_TEST_FN(time_dsa),
1175     LTC_TEST_FN(time_ecc),
1176     LTC_TEST_FN(time_dh),
1177  };
1178  char *single_test = NULL;
1179  unsigned int i;
1180  const char* mpi_provider = NULL;
1181  init_timer();
1182  register_all_ciphers();
1183  register_all_hashes();
1184  register_all_prngs();
1185  #ifdef USE_LTM
1186     mpi_provider = &quot;ltm&quot;;
1187  #elif defined(USE_TFM)
1188     mpi_provider = &quot;tfm&quot;;
1189  #elif defined(USE_GMP)
1190     mpi_provider = &quot;gmp&quot;;
1191  #elif defined(EXT_MATH_LIB)
1192     mpi_provider = &quot;ext&quot;;
1193  #endif
1194     if (argc &gt; 2) {
1195        mpi_provider = argv[2];
1196     }
1197     crypt_mp_init(mpi_provider);
1198  if ((err = rng_make_prng(128, find_prng(&quot;yarrow&quot;), &amp;yarrow_prng, NULL)) != CRYPT_OK) {
1199     fprintf(stderr, &quot;rng_make_prng failed: %s\n&quot;, error_to_string(err));
1200     exit(EXIT_FAILURE);
1201  }
1202  if (argc &gt; 1) single_test = argv[1];
1203  for (i = 0; i &lt; sizeof(test_functions)/sizeof(test_functions[0]); ++i) {
1204     if (single_test &amp;&amp; strstr(test_functions[i].name, single_test) == NULL) {
1205       continue;
1206     }
1207     test_functions[i].fn();
1208  }
1209  return EXIT_SUCCESS;
1210  }
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-timing.c</h3>
            <pre><code>1  #include &quot;tomcrypt_private.h&quot;
2  #if defined(_WIN32)
3     #define PRI64  &quot;I64d&quot;
4  #else
5     #define PRI64  &quot;ll&quot;
6  #endif
7  static prng_state yarrow_prng;
8  #define KTIMES  25
9  #define TIMES   100000
10  static struct list {
11      int id;
12      ulong64 spd1, spd2, avg;
13  } results[100];
14  static int no_results;
15  static int sorter(const void *a, const void *b)
16  {
17     const struct list *A, *B;
18     A = a;
19     B = b;
20     if (A-&gt;avg &lt; B-&gt;avg) return -1;
21     if (A-&gt;avg &gt; B-&gt;avg) return 1;
22     return 0;
23  }
24  static void tally_results(int type)
25  {
26     int x;
27     qsort(results, no_results, sizeof(struct list), &amp;sorter);
28     fprintf(stderr, &quot;\n&quot;);
29     if (type == 0) {
30        for (x = 0; x &lt; no_results; x++) {
31           fprintf(stderr, &quot;%-20s: Schedule at %6lu\n&quot;, cipher_descriptor[results[x].id].name, (unsigned long)results[x].spd1);
32        }
33     } else if (type == 1) {
34        for (x = 0; x &lt; no_results; x++) {
35          printf
36            (&quot;%-20s[%3d]: Encrypt at %5&quot;PRI64&quot;u, Decrypt at %5&quot;PRI64&quot;u\n&quot;, cipher_descriptor[results[x].id].name, cipher_descriptor[results[x].id].ID, results[x].spd1, results[x].spd2);
37        }
38     } else {
39        for (x = 0; x &lt; no_results; x++) {
40          printf
41            (&quot;%-20s: Process at %5&quot;PRI64&quot;u\n&quot;, hash_descriptor[results[x].id].name, results[x].spd1 / 1000);
42        }
43     }
44  }
45  static ulong64 rdtsc (void)
46     {
47     #if defined __GNUC__ &amp;&amp; !defined(LTC_NO_ASM)
48        #if defined(__i386__) || defined(__x86_64__)
49           unsigned hi, lo;
50           __asm__ __volatile__ (&quot;rdtsc&quot; : &quot;=a&quot;(lo), &quot;=d&quot;(hi));
51           return ((ulong64)lo)|( ((ulong64)hi)&lt;&lt;32);
52        #elif defined(LTC_PPC32) || defined(TFM_PPC32)
53           unsigned long a, b;
54           __asm__ __volatile__ (&quot;mftbu %1 \nmftb %0\n&quot;:&quot;=r&quot;(a), &quot;=r&quot;(b));
55           return (((ulong64)b) &lt;&lt; 32ULL) | ((ulong64)a);
56        #elif defined(__ia64__)  &amp;bsol;* gcc-IA64 version */
57           unsigned long result;
58           __asm__ __volatile__(&quot;mov %0=ar.itc&quot; : &quot;=r&quot;(result) :: &quot;memory&quot;);
59           while (__builtin_expect ((int) result == -1, 0))
60           __asm__ __volatile__(&quot;mov %0=ar.itc&quot; : &quot;=r&quot;(result) :: &quot;memory&quot;);
61           return result;
62        #elif defined(__sparc__)
63           #if defined(__arch64__)
64             ulong64 a;
65             asm volatile(&quot;rd %%tick,%0&quot; : &quot;=r&quot; (a));
66             return a;
67           #else
68             register unsigned long x, y;
69             __asm__ __volatile__ (&quot;rd %%tick, %0; clruw %0, %1; srlx %0, 32, %0&quot; : &quot;=r&quot; (x), &quot;=r&quot; (y) : &quot;0&quot; (x), &quot;1&quot; (y));
70             return ((unsigned long long) x &lt;&lt; 32) | y;
71           #endif
72        #elif defined(__aarch64__)
73           ulong64 CNTVCT_EL0;
74           __asm__ __volatile__ (&quot;mrs %0, cntvct_el0&quot; : &quot;=r&quot;(CNTVCT_EL0));
75           return CNTVCT_EL0;
76        #else
77           return XCLOCK();
78        #endif
79     #elif defined _M_IX86 &amp;&amp; !defined(LTC_NO_ASM)
80       __asm rdtsc
81     #elif defined _M_AMD64 &amp;&amp; !defined(LTC_NO_ASM)
82       return __rdtsc ();
83     #elif defined _M_IA64 &amp;&amp; !defined(LTC_NO_ASM)
84       #if defined __INTEL_COMPILER
85         #include &lt;ia64intrin.h&gt;
86       #endif
87        return __getReg (3116);
88     #else
89       return XCLOCK();
90     #endif
91     }
92  static ulong64 timer, skew = 0;
93  static void t_start(void)
94  {
95     timer = rdtsc();
96  }
97  static ulong64 t_read(void)
98  {
99     return rdtsc() - timer;
100  }
101  static void init_timer(void)
102  {
103     ulong64 c1, c2, t1, t2;
104     unsigned long y1;
105     c1 = c2 = (ulong64)-1;
106     for (y1 = 0; y1 &lt; TIMES*100; y1++) {
107        t_start();
108        t1 = t_read();
109        t2 = (t_read() - t1)&gt;&gt;1;
110        c1 = (t1 &gt; c1) ? t1 : c1;
111        c2 = (t2 &gt; c2) ? t2 : c2;
112     }
113     skew = c2 - c1;
114     fprintf(stderr, &quot;Clock Skew: %lu\n&quot;, (unsigned long)skew);
115  }
116  static void time_keysched(void)
117  {
118    unsigned long x, y1;
119    ulong64 t1, c1;
120    symmetric_key skey;
121    int kl;
122    int    (*func) (const unsigned char *, int , int , symmetric_key *);
123    unsigned char key[MAXBLOCKSIZE];
124    fprintf(stderr, &quot;\n\nKey Schedule Time Trials for the Symmetric Ciphers:\n(Times are cycles per key)\n&quot;);
125    no_results = 0;
126   for (x = 0; cipher_descriptor[x].name != NULL; x++) {
127  #define DO1(k)   func(k, kl, 0, &amp;skey);
128      func = cipher_descriptor[x].setup;
129      kl   = cipher_descriptor[x].min_key_length;
130      c1 = (ulong64)-1;
131      for (y1 = 0; y1 &lt; KTIMES; y1++) {
132         yarrow_read(key, kl, &amp;yarrow_prng);
133         t_start();
134         DO1(key);
135         t1 = t_read();
136         c1 = (t1 &gt; c1) ? c1 : t1;
137      }
138      t1 = c1 - skew;
139      results[no_results].spd1 = results[no_results].avg = t1;
140      results[no_results++].id = x;
141      fprintf(stderr, &quot;.&quot;); fflush(stdout);
142  #undef DO1
143     }
144     tally_results(0);
145  }
146  #ifdef LTC_ECB_MODE
147  static void time_cipher_ecb(void)
148  {
149    unsigned long x, y1;
150    ulong64  t1, t2, c1, c2, a1, a2;
151    symmetric_ECB ecb;
152    unsigned char key[MAXBLOCKSIZE] = { 0 }, pt[4096] = { 0 };
153    int err;
154    fprintf(stderr, &quot;\n\nECB Time Trials for the Symmetric Ciphers:\n&quot;);
155    no_results = 0;
156    for (x = 0; cipher_descriptor[x].name != NULL; x++) {
157      ecb_start(x, key, cipher_descriptor[x].min_key_length, 0, &amp;ecb);
158      if ((err = cipher_descriptor[x].test()) != CRYPT_OK) {
159         fprintf(stderr, &quot;\n\nERROR: Cipher %s failed self-test %s\n&quot;, cipher_descriptor[x].name, error_to_string(err));
160         exit(EXIT_FAILURE);
161      }
162  #define DO1   ecb_encrypt(pt, pt, sizeof(pt), &amp;ecb);
163  #define DO2   DO1 DO1
164      c1 = c2 = (ulong64)-1;
165      for (y1 = 0; y1 &lt; 100; y1++) {
166          t_start();
167          DO1;
168          t1 = t_read();
169          DO2;
170          t2 = t_read();
171          t2 -= t1;
172          c1 = (t1 &gt; c1 ? c1 : t1);
173          c2 = (t2 &gt; c2 ? c2 : t2);
174      }
175      a1 = c2 - c1 - skew;
176  #undef DO1
177  #undef DO2
178  #define DO1   ecb_decrypt(pt, pt, sizeof(pt), &amp;ecb);
179  #define DO2   DO1 DO1
180      c1 = c2 = (ulong64)-1;
181      for (y1 = 0; y1 &lt; 100; y1++) {
182          t_start();
183          DO1;
184          t1 = t_read();
185          DO2;
186          t2 = t_read();
187          t2 -= t1;
188          c1 = (t1 &gt; c1 ? c1 : t1);
189          c2 = (t2 &gt; c2 ? c2 : t2);
190      }
191      a2 = c2 - c1 - skew;
192      ecb_done(&amp;ecb);
193      results[no_results].id = x;
194      results[no_results].spd1 = a1/(sizeof(pt)/cipher_descriptor[x].block_length);
195      results[no_results].spd2 = a2/(sizeof(pt)/cipher_descriptor[x].block_length);
196      results[no_results].avg = (results[no_results].spd1 + results[no_results].spd2+1)/2;
197      ++no_results;
198      fprintf(stderr, &quot;.&quot;); fflush(stdout);
199  #undef DO2
200  #undef DO1
201     }
202     tally_results(1);
203  }
204  #else
205  static void time_cipher_ecb(void) { fprintf(stderr, &quot;NO ECB\n&quot;); return 0; }
206  #endif
207  #ifdef LTC_CBC_MODE
208  static void time_cipher_cbc(void)
209  {
210    unsigned long x, y1;
211    ulong64  t1, t2, c1, c2, a1, a2;
212    symmetric_CBC cbc;
213    unsigned char key[MAXBLOCKSIZE] = { 0 }, pt[4096] = { 0 };
214    int err;
215    fprintf(stderr, &quot;\n\nCBC Time Trials for the Symmetric Ciphers:\n&quot;);
216    no_results = 0;
217    for (x = 0; cipher_descriptor[x].name != NULL; x++) {
218      cbc_start(x, pt, key, cipher_descriptor[x].min_key_length, 0, &amp;cbc);
219      if ((err = cipher_descriptor[x].test()) != CRYPT_OK) {
220         fprintf(stderr, &quot;\n\nERROR: Cipher %s failed self-test %s\n&quot;, cipher_descriptor[x].name, error_to_string(err));
221         exit(EXIT_FAILURE);
222      }
223  #define DO1   cbc_encrypt(pt, pt, sizeof(pt), &amp;cbc);
224  #define DO2   DO1 DO1
225      c1 = c2 = (ulong64)-1;
226      for (y1 = 0; y1 &lt; 100; y1++) {
227          t_start();
228          DO1;
229          t1 = t_read();
230          DO2;
231          t2 = t_read();
232          t2 -= t1;
233          c1 = (t1 &gt; c1 ? c1 : t1);
234          c2 = (t2 &gt; c2 ? c2 : t2);
235      }
236      a1 = c2 - c1 - skew;
237  #undef DO1
238  #undef DO2
239  #define DO1   cbc_decrypt(pt, pt, sizeof(pt), &amp;cbc);
240  #define DO2   DO1 DO1
241      c1 = c2 = (ulong64)-1;
242      for (y1 = 0; y1 &lt; 100; y1++) {
243          t_start();
244          DO1;
245          t1 = t_read();
246          DO2;
247          t2 = t_read();
248          t2 -= t1;
249          c1 = (t1 &gt; c1 ? c1 : t1);
250          c2 = (t2 &gt; c2 ? c2 : t2);
251      }
252      a2 = c2 - c1 - skew;
253      cbc_done(&amp;cbc);
254      results[no_results].id = x;
255      results[no_results].spd1 = a1/(sizeof(pt)/cipher_descriptor[x].block_length);
256      results[no_results].spd2 = a2/(sizeof(pt)/cipher_descriptor[x].block_length);
257      results[no_results].avg = (results[no_results].spd1 + results[no_results].spd2+1)/2;
258      ++no_results;
259      fprintf(stderr, &quot;.&quot;); fflush(stdout);
260  #undef DO2
261  #undef DO1
262     }
263     tally_results(1);
264  }
265  #else
266  static void time_cipher_cbc(void) { fprintf(stderr, &quot;NO CBC\n&quot;); return 0; }
267  #endif
268  #ifdef LTC_CTR_MODE
269  static void time_cipher_ctr(void)
270  {
271    unsigned long x, y1;
272    ulong64  t1, t2, c1, c2, a1, a2;
273    symmetric_CTR ctr;
274    unsigned char key[MAXBLOCKSIZE] = { 0 }, pt[4096] = { 0 };
275    int err;
276    fprintf(stderr, &quot;\n\nCTR Time Trials for the Symmetric Ciphers:\n&quot;);
277    no_results = 0;
278    for (x = 0; cipher_descriptor[x].name != NULL; x++) {
279      ctr_start(x, pt, key, cipher_descriptor[x].min_key_length, 0, CTR_COUNTER_LITTLE_ENDIAN, &amp;ctr);
280      if ((err = cipher_descriptor[x].test()) != CRYPT_OK) {
281         fprintf(stderr, &quot;\n\nERROR: Cipher %s failed self-test %s\n&quot;, cipher_descriptor[x].name, error_to_string(err));
282         exit(EXIT_FAILURE);
283      }
284  #define DO1   ctr_encrypt(pt, pt, sizeof(pt), &amp;ctr);
285  #define DO2   DO1 DO1
286      c1 = c2 = (ulong64)-1;
287      for (y1 = 0; y1 &lt; 100; y1++) {
288          t_start();
289          DO1;
290          t1 = t_read();
291          DO2;
292          t2 = t_read();
293          t2 -= t1;
294          c1 = (t1 &gt; c1 ? c1 : t1);
295          c2 = (t2 &gt; c2 ? c2 : t2);
296      }
297      a1 = c2 - c1 - skew;
298  #undef DO1
299  #undef DO2
300  #define DO1   ctr_decrypt(pt, pt, sizeof(pt), &amp;ctr);
301  #define DO2   DO1 DO1
302      c1 = c2 = (ulong64)-1;
303      for (y1 = 0; y1 &lt; 100; y1++) {
304          t_start();
305          DO1;
306          t1 = t_read();
307          DO2;
308          t2 = t_read();
309          t2 -= t1;
310          c1 = (t1 &gt; c1 ? c1 : t1);
311          c2 = (t2 &gt; c2 ? c2 : t2);
312      }
313      a2 = c2 - c1 - skew;
314      ctr_done(&amp;ctr);
315      results[no_results].id = x;
316      results[no_results].spd1 = a1/(sizeof(pt)/cipher_descriptor[x].block_length);
317      results[no_results].spd2 = a2/(sizeof(pt)/cipher_descriptor[x].block_length);
318      results[no_results].avg = (results[no_results].spd1 + results[no_results].spd2+1)/2;
319      ++no_results;
320      fprintf(stderr, &quot;.&quot;); fflush(stdout);
321  #undef DO2
322  #undef DO1
323     }
324     tally_results(1);
325  }
326  #else
327  static void time_cipher_ctr(void) { fprintf(stderr, &quot;NO CTR\n&quot;); return 0; }
328  #endif
329  #ifdef LTC_LRW_MODE
330  static void time_cipher_lrw(void)
331  {
332    unsigned long x, y1;
333    ulong64  t1, t2, c1, c2, a1, a2;
334    symmetric_LRW lrw;
335    unsigned char key[MAXBLOCKSIZE] = { 0 }, pt[4096] = { 0 };
336    int err;
337    fprintf(stderr, &quot;\n\nLRW Time Trials for the Symmetric Ciphers:\n&quot;);
338    no_results = 0;
339    for (x = 0; cipher_descriptor[x].name != NULL; x++) {
340      if (cipher_descriptor[x].block_length != 16) continue;
341      lrw_start(x, pt, key, cipher_descriptor[x].min_key_length, key, 0, &amp;lrw);
342      if ((err = cipher_descriptor[x].test()) != CRYPT_OK) {
343         fprintf(stderr, &quot;\n\nERROR: Cipher %s failed self-test %s\n&quot;, cipher_descriptor[x].name, error_to_string(err));
344         exit(EXIT_FAILURE);
345      }
346  #define DO1   lrw_encrypt(pt, pt, sizeof(pt), &amp;lrw);
347  #define DO2   DO1 DO1
348      c1 = c2 = (ulong64)-1;
349      for (y1 = 0; y1 &lt; 100; y1++) {
350          t_start();
351          DO1;
352          t1 = t_read();
353          DO2;
354          t2 = t_read();
355          t2 -= t1;
356          c1 = (t1 &gt; c1 ? c1 : t1);
357          c2 = (t2 &gt; c2 ? c2 : t2);
358      }
359      a1 = c2 - c1 - skew;
360  #undef DO1
361  #undef DO2
362  #define DO1   lrw_decrypt(pt, pt, sizeof(pt), &amp;lrw);
363  #define DO2   DO1 DO1
364      c1 = c2 = (ulong64)-1;
365      for (y1 = 0; y1 &lt; 100; y1++) {
366          t_start();
367          DO1;
368          t1 = t_read();
369          DO2;
370          t2 = t_read();
371          t2 -= t1;
372          c1 = (t1 &gt; c1 ? c1 : t1);
373          c2 = (t2 &gt; c2 ? c2 : t2);
374      }
375      a2 = c2 - c1 - skew;
376      lrw_done(&amp;lrw);
377      results[no_results].id = x;
378      results[no_results].spd1 = a1/(sizeof(pt)/cipher_descriptor[x].block_length);
379      results[no_results].spd2 = a2/(sizeof(pt)/cipher_descriptor[x].block_length);
380      results[no_results].avg = (results[no_results].spd1 + results[no_results].spd2+1)/2;
381      ++no_results;
382      fprintf(stderr, &quot;.&quot;); fflush(stdout);
383  #undef DO2
384  #undef DO1
385     }
386     tally_results(1);
387  }
388  #else
389  static void time_cipher_lrw(void) { fprintf(stderr, &quot;NO LRW\n&quot;); }
390  #endif
391  static void time_hash(void)
392  {
393    unsigned long x, y1, len;
394    ulong64 t1, t2, c1, c2;
395    hash_state md;
396    int    (*func)(hash_state *, const unsigned char *, unsigned long), err;
397    unsigned char pt[MAXBLOCKSIZE] = { 0 };
398    fprintf(stderr, &quot;\n\nHASH Time Trials for:\n&quot;);
399    no_results = 0;
400    for (x = 0; hash_descriptor[x].name != NULL; x++) {
401      if ((err = hash_descriptor[x].test()) != CRYPT_OK) {
402         fprintf(stderr, &quot;\n\nERROR: Hash %s failed self-test %s\n&quot;, hash_descriptor[x].name, error_to_string(err));
403         exit(EXIT_FAILURE);
404      }
405      hash_descriptor[x].init(&amp;md);
406  #define DO1   func(&amp;md,pt,len);
407  #define DO2   DO1 DO1
408      func = hash_descriptor[x].process;
409      len  = hash_descriptor[x].blocksize;
410      c1 = c2 = (ulong64)-1;
411      for (y1 = 0; y1 &lt; TIMES; y1++) {
412         t_start();
413         DO1;
414         t1 = t_read();
415         DO2;
416         t2 = t_read() - t1;
417         c1 = (t1 &gt; c1) ? c1 : t1;
418         c2 = (t2 &gt; c2) ? c2 : t2;
419      }
420      t1 = c2 - c1 - skew;
421      t1 = ((t1 * CONST64(1000))) / ((ulong64)hash_descriptor[x].blocksize);
422      results[no_results].id = x;
423      results[no_results].spd1 = results[no_results].avg = t1;
424      ++no_results;
425      fprintf(stderr, &quot;.&quot;); fflush(stdout);
426  #undef DO2
427  #undef DO1
428     }
429     tally_results(2);
430  }
431  static void time_mult(void)
432  {
433     ulong64 t1, t2;
434     unsigned long x, y;
435     void  *a, *b, *c;
436     if (ltc_mp.name == NULL) return;
437     fprintf(stderr, &quot;Timing Multiplying:\n&quot;);
438     mp_init_multi(&amp;a,&amp;b,&amp;c,NULL);
439     for (x = 128/MP_DIGIT_BIT; x &lt;= (unsigned long)1536/MP_DIGIT_BIT; x += 128/MP_DIGIT_BIT) {
440         mp_rand(a, x);
441         mp_rand(b, x);
442  #define DO1 mp_mul(a, b, c);
443  #define DO2 DO1; DO1;
444         t2 = -1;
445         for (y = 0; y &lt; TIMES; y++) {
446             t_start();
447             t1 = t_read();
448             DO2;
449             t1 = (t_read() - t1)&gt;&gt;1;
450             if (t1 &lt; t2) t2 = t1;
451         }
452         fprintf(stderr, &quot;%4lu bits: %9&quot;PRI64&quot;u cycles\n&quot;, x*MP_DIGIT_BIT, t2);
453     }
454     mp_clear_multi(a,b,c,NULL);
455  #undef DO1
456  #undef DO2
457  }
458  static void time_sqr(void)
459  {
460     ulong64 t1, t2;
461     unsigned long x, y;
462     void *a, *b;
463     if (ltc_mp.name == NULL) return;
464     fprintf(stderr, &quot;Timing Squaring:\n&quot;);
465     mp_init_multi(&amp;a,&amp;b,NULL);
466     for (x = 128/MP_DIGIT_BIT; x &lt;= (unsigned long)1536/MP_DIGIT_BIT; x += 128/MP_DIGIT_BIT) {
467         mp_rand(a, x);
468  #define DO1 mp_sqr(a, b);
469  #define DO2 DO1; DO1;
470         t2 = -1;
471         for (y = 0; y &lt; TIMES; y++) {
472             t_start();
473             t1 = t_read();
474             DO2;
475             t1 = (t_read() - t1)&gt;&gt;1;
476             if (t1 &lt; t2) t2 = t1;
477         }
478         fprintf(stderr, &quot;%4lu bits: %9&quot;PRI64&quot;u cycles\n&quot;, x*MP_DIGIT_BIT, t2);
479     }
480     mp_clear_multi(a,b,NULL);
481  #undef DO1
482  #undef DO2
483  }
484  static void time_prng(void)
485  {
486     ulong64 t1, t2;
487     unsigned char buf[4096];
488     prng_state tprng;
489     unsigned long x, y;
490     int           err;
491     fprintf(stderr, &quot;Timing PRNGs (cycles/byte output, cycles add_entropy (32 bytes) :\n&quot;);
492     for (x = 0; prng_descriptor[x].name != NULL; x++) {
493        if ((err = prng_descriptor[x].test()) != CRYPT_OK) {
494           fprintf(stderr, &quot;\n\nERROR: PRNG %s failed self-test %s\n&quot;, prng_descriptor[x].name, error_to_string(err));
495           exit(EXIT_FAILURE);
496        }
497        prng_descriptor[x].start(&amp;tprng);
498        zeromem(buf, 256);
499        prng_descriptor[x].add_entropy(buf, 256, &amp;tprng);
500        prng_descriptor[x].ready(&amp;tprng);
501        t2 = -1;
502  #define DO1 if (prng_descriptor[x].read(buf, 4096, &amp;tprng) != 4096) { fprintf(stderr, &quot;\n\nERROR READ != 4096\n\n&quot;); exit(EXIT_FAILURE); }
503  #define DO2 DO1 DO1
504        for (y = 0; y &lt; 10000; y++) {
505           t_start();
506           t1 = t_read();
507           DO2;
508           t1 = (t_read() - t1)&gt;&gt;1;
509           if (t1 &lt; t2) t2 = t1;
510        }
511        fprintf(stderr, &quot;%20s: %5&quot;PRI64&quot;u &quot;, prng_descriptor[x].name, t2&gt;&gt;12);
512  #undef DO2
513  #undef DO1
514  #define DO1 prng_descriptor[x].start(&amp;tprng); prng_descriptor[x].add_entropy(buf, 32, &amp;tprng); prng_descriptor[x].ready(&amp;tprng); prng_descriptor[x].done(&amp;tprng);
515  #define DO2 DO1 DO1
516        for (y = 0; y &lt; 10000; y++) {
517           t_start();
518           t1 = t_read();
519           DO2;
520           t1 = (t_read() - t1)&gt;&gt;1;
521           if (t1 &lt; t2) t2 = t1;
522        }
523        fprintf(stderr, &quot;%5&quot;PRI64&quot;u\n&quot;, t2);
524  #undef DO2
525  #undef DO1
526     }
527  }
528  #if defined(LTC_MDSA)
529  static void time_dsa(void)
530  {
531     dsa_key       key;
532     ulong64       t1, t2;
533     unsigned long x, y;
534     int           err;
535  static const struct {
536     int group, modulus;
537  } groups[] = {
538  { 20, 96  },
539  { 20, 128 },
540  { 24, 192 },
541  { 28, 256 },
542  #ifndef TFM_DESC
543  { 32, 512 },
544  #endif
545  };
546     if (ltc_mp.name == NULL) return;
547     for (x = 0; x &lt; (sizeof(groups)/sizeof(groups[0])); x++) {
548         t2 = 0;
549         for (y = 0; y &lt; 4; y++) {
550             t_start();
551             t1 = t_read();
552             if ((err = dsa_generate_pqg(&amp;yarrow_prng, find_prng(&quot;yarrow&quot;), groups[x].group, groups[x].modulus, &amp;key)) != CRYPT_OK) {
553                fprintf(stderr, &quot;\n\ndsa_generate_pqg says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
554                exit(EXIT_FAILURE);
555             }
556             if ((err = dsa_generate_key(&amp;yarrow_prng, find_prng(&quot;yarrow&quot;), &amp;key)) != CRYPT_OK) {
557                fprintf(stderr, &quot;\n\ndsa_make_key says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
558                exit(EXIT_FAILURE);
559             }
560             t1 = t_read() - t1;
561             t2 += t1;
562  #ifdef LTC_PROFILE
563         t2 &lt;&lt;= 2;
564         break;
565  #endif
566             if (y &lt; 3) {
567                dsa_free(&amp;key);
568             }
569         }
570         t2 &gt;&gt;= 2;
571         fprintf(stderr, &quot;DSA-(%lu, %lu) make_key    took %15&quot;PRI64&quot;u cycles\n&quot;, (unsigned long)groups[x].group*8, (unsigned long)groups[x].modulus*8, t2);
572         dsa_free(&amp;key);
573     }
574     fprintf(stderr, &quot;\n\n&quot;);
575  }
576  #else
577  static void time_dsa(void) { fprintf(stderr, &quot;NO DSA\n&quot;); }
578  #endif
579  #if defined(LTC_MRSA)
580  static void time_rsa(void)
581  {
582     rsa_key       key;
583     ulong64       t1, t2;
584     unsigned char buf[2][2048] = { 0 };
585     unsigned long x, y, z, zzz;
586     int           err, zz, stat;
587     if (ltc_mp.name == NULL) return;
588     for (x = 2048; x &lt;= 8192; x &lt;&lt;= 1) {
589         t2 = 0;
590         for (y = 0; y &lt; 4; y++) {
591             t_start();
592             t1 = t_read();
593             if ((err = rsa_make_key(&amp;yarrow_prng, find_prng(&quot;yarrow&quot;), x/8, 65537, &amp;key)) != CRYPT_OK) {
594                fprintf(stderr, &quot;\n\nrsa_make_key says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
595                exit(EXIT_FAILURE);
596             }
597             t1 = t_read() - t1;
598             t2 += t1;
599  #ifdef LTC_PROFILE
600         t2 &lt;&lt;= 2;
601         break;
602  #endif
603             if (y &lt; 3) {
604                rsa_free(&amp;key);
605             }
606         }
607         t2 &gt;&gt;= 2;
608         fprintf(stderr, &quot;RSA-%lu make_key    took %15&quot;PRI64&quot;u cycles\n&quot;, x, t2);
609         t2 = 0;
610         for (y = 0; y &lt; 16; y++) {
611             t_start();
612             t1 = t_read();
613             z = sizeof(buf[1]);
614             if ((err = rsa_encrypt_key(buf[0], 32, buf[1], &amp;z, (const unsigned char *)&quot;testprog&quot;, 8, &amp;yarrow_prng,
615                                        find_prng(&quot;yarrow&quot;), find_hash(&quot;sha1&quot;),
616                                        &amp;key)) != CRYPT_OK) {
617                fprintf(stderr, &quot;\n\nrsa_encrypt_key says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
618                exit(EXIT_FAILURE);
619             }
620             t1 = t_read() - t1;
621             t2 += t1;
622  #ifdef LTC_PROFILE
623         t2 &lt;&lt;= 4;
624         break;
625  #endif
626         }
627         t2 &gt;&gt;= 4;
628         fprintf(stderr, &quot;RSA-%lu encrypt_key took %15&quot;PRI64&quot;u cycles\n&quot;, x, t2);
629         t2 = 0;
630         for (y = 0; y &lt; 2048; y++) {
631             t_start();
632             t1 = t_read();
633             zzz = sizeof(buf[0]);
634             if ((err = rsa_decrypt_key(buf[1], z, buf[0], &amp;zzz, (const unsigned char *)&quot;testprog&quot;, 8,  find_hash(&quot;sha1&quot;),
635                                        &amp;zz, &amp;key)) != CRYPT_OK) {
636                fprintf(stderr, &quot;\n\nrsa_decrypt_key says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
637                exit(EXIT_FAILURE);
638             }
639             t1 = t_read() - t1;
640             t2 += t1;
641  #ifdef LTC_PROFILE
642         t2 &lt;&lt;= 11;
643         break;
644  #endif
645         }
646         t2 &gt;&gt;= 11;
647         fprintf(stderr, &quot;RSA-%lu decrypt_key took %15&quot;PRI64&quot;u cycles\n&quot;, x, t2);
648         t2 = 0;
649         for (y = 0; y &lt; 256; y++) {
650            t_start();
651            t1 = t_read();
652            z = sizeof(buf[1]);
653            if ((err = rsa_sign_hash(buf[0], 20, buf[1], &amp;z, &amp;yarrow_prng,
654                                     find_prng(&quot;yarrow&quot;), find_hash(&quot;sha1&quot;), 8, &amp;key)) != CRYPT_OK) {
655                fprintf(stderr, &quot;\n\nrsa_sign_hash says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
656                exit(EXIT_FAILURE);
657             }
658             t1 = t_read() - t1;
659             t2 += t1;
660  #ifdef LTC_PROFILE
661         t2 &lt;&lt;= 8;
662         break;
663  #endif
664          }
665          t2 &gt;&gt;= 8;
666          fprintf(stderr, &quot;RSA-%lu sign_hash took   %15&quot;PRI64&quot;u cycles\n&quot;, x, t2);
667         t2 = 0;
668         for (y = 0; y &lt; 2048; y++) {
669            t_start();
670            t1 = t_read();
671            if ((err = rsa_verify_hash(buf[1], z, buf[0], 20, find_hash(&quot;sha1&quot;), 8, &amp;stat, &amp;key)) != CRYPT_OK) {
672                fprintf(stderr, &quot;\n\nrsa_verify_hash says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
673                exit(EXIT_FAILURE);
674            }
675            if (stat == 0) {
676               fprintf(stderr, &quot;\n\nrsa_verify_hash for RSA-%lu failed to verify signature(%lu)\n&quot;, x, y);
677               exit(EXIT_FAILURE);
678            }
679            t1 = t_read() - t1;
680            t2 += t1;
681  #ifdef LTC_PROFILE
682         t2 &lt;&lt;= 11;
683         break;
684  #endif
685          }
686          t2 &gt;&gt;= 11;
687          fprintf(stderr, &quot;RSA-%lu verify_hash took %15&quot;PRI64&quot;u cycles\n&quot;, x, t2);
688         fprintf(stderr, &quot;\n\n&quot;);
689         rsa_free(&amp;key);
690    }
691  }
692  #else
693  static void time_rsa(void) { fprintf(stderr, &quot;NO RSA\n&quot;); }
694  #endif
695  #if defined(LTC_MDH)
696  static void time_dh(void)
697  {
698     dh_key key;
699     ulong64 t1, t2;
700     unsigned long i, x, y;
701     int           err;
702     static unsigned long sizes[] = {768/8, 1024/8, 1536/8, 2048/8,
703  #ifndef TFM_DESC
704                                     3072/8, 4096/8, 6144/8, 8192/8,
705  #endif
706                                     100000
707     };
708     if (ltc_mp.name == NULL) return;
709     for (x = sizes[i=0]; x &lt; 100000; x = sizes[++i]) {
710         t2 = 0;
711         for (y = 0; y &lt; 16; y++) {
712             if((err = dh_set_pg_groupsize(x, &amp;key)) != CRYPT_OK) {
713                fprintf(stderr, &quot;\n\ndh_set_pg_groupsize says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
714                exit(EXIT_FAILURE);
715             }
716             t_start();
717             t1 = t_read();
718             if ((err = dh_generate_key(&amp;yarrow_prng, find_prng(&quot;yarrow&quot;), &amp;key)) != CRYPT_OK) {
719                fprintf(stderr, &quot;\n\ndh_make_key says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
720                exit(EXIT_FAILURE);
721             }
722             t1 = t_read() - t1;
723             t2 += t1;
724             dh_free(&amp;key);
725         }
726         t2 &gt;&gt;= 4;
727         fprintf(stderr, &quot;DH-%4lu make_key    took %15&quot;PRI64&quot;u cycles\n&quot;, x*8, t2);
728    }
729  }
730  #else
731  static void time_dh(void) { fprintf(stderr, &quot;NO DH\n&quot;); }
732  #endif
733  #if defined(LTC_MECC)
734  static void time_ecc(void)
735  {
736     ecc_key key;
737     ulong64 t1, t2;
738     unsigned char buf[2][256] = { 0 };
739     unsigned long i, w, x, y, z;
740     int           err, stat;
741     static unsigned long sizes[] = {
742  #ifdef LTC_ECC_SECP112R1
743  112/8,
744  #endif
745  #ifdef LTC_ECC_SECP128R1
746  128/8,
747  #endif
748  #ifdef LTC_ECC_SECP160R1
749  160/8,
750  #endif
751  #ifdef LTC_ECC_SECP192R1
752  192/8,
753  #endif
754  #ifdef LTC_ECC_SECP224R1
755  224/8,
756  #endif
757  #ifdef LTC_ECC_SECP256R1
758  256/8,
759  #endif
760  #ifdef LTC_ECC_SECP384R1
761  384/8,
762  #endif
763  #ifdef LTC_ECC_SECP512R1
764  521/8,
765  #endif
766  100000};
767     if (ltc_mp.name == NULL) return;
768     for (x = sizes[i=0]; x &lt; 100000; x = sizes[++i]) {
769         t2 = 0;
770         for (y = 0; y &lt; 256; y++) {
771             t_start();
772             t1 = t_read();
773             if ((err = ecc_make_key(&amp;yarrow_prng, find_prng(&quot;yarrow&quot;), x, &amp;key)) != CRYPT_OK) {
774                fprintf(stderr, &quot;\n\necc_make_key says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
775                exit(EXIT_FAILURE);
776             }
777             t1 = t_read() - t1;
778             t2 += t1;
779  #ifdef LTC_PROFILE
780         t2 &lt;&lt;= 8;
781         break;
782  #endif
783             if (y &lt; 255) {
784                ecc_free(&amp;key);
785             }
786         }
787         t2 &gt;&gt;= 8;
788         fprintf(stderr, &quot;ECC-%lu make_key    took %15&quot;PRI64&quot;u cycles\n&quot;, x*8, t2);
789         t2 = 0;
790         for (y = 0; y &lt; 256; y++) {
791             t_start();
792             t1 = t_read();
793             z = sizeof(buf[1]);
794             if ((err = ecc_encrypt_key(buf[0], 20, buf[1], &amp;z, &amp;yarrow_prng, find_prng(&quot;yarrow&quot;), find_hash(&quot;sha1&quot;),
795                                        &amp;key)) != CRYPT_OK) {
796                fprintf(stderr, &quot;\n\necc_encrypt_key says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
797                exit(EXIT_FAILURE);
798             }
799             t1 = t_read() - t1;
800             t2 += t1;
801  #ifdef LTC_PROFILE
802         t2 &lt;&lt;= 8;
803         break;
804  #endif
805         }
806         t2 &gt;&gt;= 8;
807         fprintf(stderr, &quot;ECC-%lu encrypt_key took %15&quot;PRI64&quot;u cycles\n&quot;, x*8, t2);
808         t2 = 0;
809         for (y = 0; y &lt; 256; y++) {
810             t_start();
811             t1 = t_read();
812             w = 20;
813             if ((err = ecc_decrypt_key(buf[1], z, buf[0], &amp;w, &amp;key)) != CRYPT_OK) {
814                fprintf(stderr, &quot;\n\necc_decrypt_key says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
815                exit(EXIT_FAILURE);
816             }
817             t1 = t_read() - t1;
818             t2 += t1;
819  #ifdef LTC_PROFILE
820         t2 &lt;&lt;= 8;
821         break;
822  #endif
823         }
824         t2 &gt;&gt;= 8;
825         fprintf(stderr, &quot;ECC-%lu decrypt_key took %15&quot;PRI64&quot;u cycles\n&quot;, x*8, t2);
826         t2 = 0;
827         for (y = 0; y &lt; 256; y++) {
828            t_start();
829            t1 = t_read();
830            z = sizeof(buf[1]);
831            if ((err = ecc_sign_hash(buf[0], 20, buf[1], &amp;z, &amp;yarrow_prng,
832                                     find_prng(&quot;yarrow&quot;), &amp;key)) != CRYPT_OK) {
833                fprintf(stderr, &quot;\n\necc_sign_hash says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
834                exit(EXIT_FAILURE);
835             }
836             t1 = t_read() - t1;
837             t2 += t1;
838  #ifdef LTC_PROFILE
839         t2 &lt;&lt;= 8;
840         break;
841  #endif
842          }
843          t2 &gt;&gt;= 8;
844          fprintf(stderr, &quot;ECC-%lu sign_hash took   %15&quot;PRI64&quot;u cycles\n&quot;, x*8, t2);
845         t2 = 0;
846         for (y = 0; y &lt; 256; y++) {
847            t_start();
848            t1 = t_read();
849            if ((err = ecc_verify_hash(buf[1], z, buf[0], 20, &amp;stat, &amp;key)) != CRYPT_OK) {
850                fprintf(stderr, &quot;\n\necc_verify_hash says %s, wait...no it should say %s...damn you!\n&quot;, error_to_string(err), error_to_string(CRYPT_OK));
851                exit(EXIT_FAILURE);
852            }
853            if (stat == 0) {
854               fprintf(stderr, &quot;\n\necc_verify_hash for ECC-%lu failed to verify signature(%lu)\n&quot;, x*8, y);
855               exit(EXIT_FAILURE);
856            }
857            t1 = t_read() - t1;
858            t2 += t1;
859  #ifdef LTC_PROFILE
860         t2 &lt;&lt;= 8;
861         break;
862  #endif
863          }
864          t2 &gt;&gt;= 8;
865          fprintf(stderr, &quot;ECC-%lu verify_hash took %15&quot;PRI64&quot;u cycles\n&quot;, x*8, t2);
866         fprintf(stderr, &quot;\n\n&quot;);
867         ecc_free(&amp;key);
868    }
869  }
870  #else
871  static void time_ecc(void) { fprintf(stderr, &quot;NO ECC\n&quot;); }
872  #endif
873  static void time_macs_(unsigned long MAC_SIZE)
874  {
875  #if defined(LTC_OMAC) || defined(LTC_XCBC) || defined(LTC_F9_MODE) || defined(LTC_PMAC) || defined(LTC_PELICAN) || defined(LTC_HMAC)
876     unsigned char *buf, key[16], tag[16];
877     ulong64 t1, t2;
878     unsigned long x, z;
879     int err, cipher_idx, hash_idx;
880     fprintf(stderr, &quot;\nMAC Timings (cycles/byte on %luKB blocks):\n&quot;, MAC_SIZE);
881     buf = XMALLOC(MAC_SIZE*1024);
882     if (buf == NULL) {
883        fprintf(stderr, &quot;\n\nout of heap yo\n\n&quot;);
884        exit(EXIT_FAILURE);
885     }
886     cipher_idx = find_cipher(&quot;aes&quot;);
887     hash_idx   = find_hash(&quot;sha1&quot;);
888     if (cipher_idx == -1 || hash_idx == -1) {
889        fprintf(stderr, &quot;Warning the MAC tests requires AES and SHA1 to operate... so sorry\n&quot;);
890        exit(EXIT_FAILURE);
891     }
892     yarrow_read(buf, MAC_SIZE*1024, &amp;yarrow_prng);
893     yarrow_read(key, 16, &amp;yarrow_prng);
894  #ifdef LTC_OMAC
895     t2 = -1;
896     for (x = 0; x &lt; 10000; x++) {
897          t_start();
898          t1 = t_read();
899          z = 16;
900          if ((err = omac_memory(cipher_idx, key, 16, buf, MAC_SIZE*1024, tag, &amp;z)) != CRYPT_OK) {
901             fprintf(stderr, &quot;\n\nomac-%s error... %s\n&quot;, cipher_descriptor[cipher_idx].name, error_to_string(err));
902             exit(EXIT_FAILURE);
903          }
904          t1 = t_read() - t1;
905          if (t1 &lt; t2) t2 = t1;
906     }
907     fprintf(stderr, &quot;OMAC-%s\t\t%9&quot;PRI64&quot;u\n&quot;, cipher_descriptor[cipher_idx].name, t2/(ulong64)(MAC_SIZE*1024));
908  #endif
909  #ifdef LTC_XCBC
910     t2 = -1;
911     for (x = 0; x &lt; 10000; x++) {
912          t_start();
913          t1 = t_read();
914          z = 16;
915          if ((err = xcbc_memory(cipher_idx, key, 16, buf, MAC_SIZE*1024, tag, &amp;z)) != CRYPT_OK) {
916             fprintf(stderr, &quot;\n\nxcbc-%s error... %s\n&quot;, cipher_descriptor[cipher_idx].name, error_to_string(err));
917             exit(EXIT_FAILURE);
918          }
919          t1 = t_read() - t1;
920          if (t1 &lt; t2) t2 = t1;
921     }
922     fprintf(stderr, &quot;XCBC-%s\t\t%9&quot;PRI64&quot;u\n&quot;, cipher_descriptor[cipher_idx].name, t2/(ulong64)(MAC_SIZE*1024));
923  #endif
924  #ifdef LTC_F9_MODE
925     t2 = -1;
926     for (x = 0; x &lt; 10000; x++) {
927          t_start();
928          t1 = t_read();
929          z = 16;
930          if ((err = f9_memory(cipher_idx, key, 16, buf, MAC_SIZE*1024, tag, &amp;z)) != CRYPT_OK) {
931             fprintf(stderr, &quot;\n\nF9-%s error... %s\n&quot;, cipher_descriptor[cipher_idx].name, error_to_string(err));
932             exit(EXIT_FAILURE);
933          }
934          t1 = t_read() - t1;
935          if (t1 &lt; t2) t2 = t1;
936     }
937     fprintf(stderr, &quot;F9-%s\t\t\t%9&quot;PRI64&quot;u\n&quot;, cipher_descriptor[cipher_idx].name, t2/(ulong64)(MAC_SIZE*1024));
938  #endif
939  #ifdef LTC_PMAC
940     t2 = -1;
941     for (x = 0; x &lt; 10000; x++) {
942          t_start();
943          t1 = t_read();
944          z = 16;
945          if ((err = pmac_memory(cipher_idx, key, 16, buf, MAC_SIZE*1024, tag, &amp;z)) != CRYPT_OK) {
946             fprintf(stderr, &quot;\n\npmac-%s error... %s\n&quot;, cipher_descriptor[cipher_idx].name, error_to_string(err));
947             exit(EXIT_FAILURE);
948          }
949          t1 = t_read() - t1;
950          if (t1 &lt; t2) t2 = t1;
951     }
952     fprintf(stderr, &quot;PMAC-%s\t\t%9&quot;PRI64&quot;u\n&quot;, cipher_descriptor[cipher_idx].name, t2/(ulong64)(MAC_SIZE*1024));
953  #endif
954  #ifdef LTC_PELICAN
955     t2 = -1;
956     for (x = 0; x &lt; 10000; x++) {
957          t_start();
958          t1 = t_read();
959          z = 16;
960          if ((err = pelican_memory(key, 16, buf, MAC_SIZE*1024, tag)) != CRYPT_OK) {
961             fprintf(stderr, &quot;\n\npelican error... %s\n&quot;, error_to_string(err));
962             exit(EXIT_FAILURE);
963          }
964          t1 = t_read() - t1;
965          if (t1 &lt; t2) t2 = t1;
966     }
967     fprintf(stderr, &quot;PELICAN \t\t%9&quot;PRI64&quot;u\n&quot;, t2/(ulong64)(MAC_SIZE*1024));
968  #endif
969  #ifdef LTC_HMAC
970     t2 = -1;
971     for (x = 0; x &lt; 10000; x++) {
972          t_start();
973          t1 = t_read();
974          z = 16;
975          if ((err = hmac_memory(hash_idx, key, 16, buf, MAC_SIZE*1024, tag, &amp;z)) != CRYPT_OK) {
976             fprintf(stderr, &quot;\n\nhmac-%s error... %s\n&quot;, hash_descriptor[hash_idx].name, error_to_string(err));
977             exit(EXIT_FAILURE);
978          }
979          t1 = t_read() - t1;
980          if (t1 &lt; t2) t2 = t1;
981     }
982     fprintf(stderr, &quot;HMAC-%s\t\t%9&quot;PRI64&quot;u\n&quot;, hash_descriptor[hash_idx].name, t2/(ulong64)(MAC_SIZE*1024));
983  #endif
984     XFREE(buf);
985  #else
986     LTC_UNUSED_PARAM(MAC_SIZE);
987     fprintf(stderr, &quot;NO MACs\n&quot;);
988  #endif
989  }
990  static void time_macs(void)
991  {
992     time_macs_(1);
993     time_macs_(4);
994     time_macs_(32);
995  }
996  static void time_encmacs_(unsigned long MAC_SIZE)
997  {
998  #if defined(LTC_EAX_MODE) || defined(LTC_OCB_MODE) || defined(LTC_OCB3_MODE) || defined(LTC_CCM_MODE) || defined(LTC_GCM_MODE)
999     unsigned char *buf, IV[16], key[16], tag[16];
1000     ulong64 t1, t2;
1001     unsigned long x, z;
1002     int err, cipher_idx;
1003     symmetric_key skey;
1004     fprintf(stderr, &quot;\nENC+MAC Timings (zero byte AAD, 16 byte IV, cycles/byte on %luKB blocks):\n&quot;, MAC_SIZE);
1005     buf = XMALLOC(MAC_SIZE*1024);
1006     if (buf == NULL) {
1007        fprintf(stderr, &quot;\n\nout of heap yo\n\n&quot;);
1008        exit(EXIT_FAILURE);
1009     }
1010     cipher_idx = find_cipher(&quot;aes&quot;);
1011     yarrow_read(buf, MAC_SIZE*1024, &amp;yarrow_prng);
1012     yarrow_read(key, 16, &amp;yarrow_prng);
<span onclick='openModal()' class='match'>1013     yarrow_read(IV, 16, &amp;yarrow_prng);
1014  #ifdef LTC_EAX_MODE
1015     t2 = -1;
1016     for (x = 0; x &lt; 10000; x++) {
1017          t_start();
1018          t1 = t_read();
1019          z = 16;
1020          if ((err = eax_encrypt_authenticate_memory(cipher_idx, key, 16, IV, 16, NULL, 0, buf, MAC_SIZE*1024, buf, tag, &amp;z)) != CRYPT_OK) {
</span>1021             fprintf(stderr, &quot;\nEAX error... %s\n&quot;, error_to_string(err));
1022             exit(EXIT_FAILURE);
1023          }
1024          t1 = t_read() - t1;
1025          if (t1 &lt; t2) t2 = t1;
1026     }
1027     fprintf(stderr, &quot;EAX \t\t\t%9&quot;PRI64&quot;u\n&quot;, t2/(ulong64)(MAC_SIZE*1024));
1028  #endif
1029  #ifdef LTC_OCB_MODE
1030     t2 = -1;
1031     for (x = 0; x &lt; 10000; x++) {
1032          t_start();
1033          t1 = t_read();
1034          z = 16;
1035          if ((err = ocb_encrypt_authenticate_memory(cipher_idx, key, 16, IV, buf, MAC_SIZE*1024, buf, tag, &amp;z)) != CRYPT_OK) {
1036             fprintf(stderr, &quot;\nOCB error... %s\n&quot;, error_to_string(err));
1037             exit(EXIT_FAILURE);
1038          }
1039          t1 = t_read() - t1;
1040          if (t1 &lt; t2) t2 = t1;
1041     }
1042     fprintf(stderr, &quot;OCB \t\t\t%9&quot;PRI64&quot;u\n&quot;, t2/(ulong64)(MAC_SIZE*1024));
1043  #endif
1044  #ifdef LTC_OCB3_MODE
1045     t2 = -1;
1046     for (x = 0; x &lt; 10000; x++) {
1047          t_start();
1048          t1 = t_read();
1049          z = 16;
1050          if ((err = ocb3_encrypt_authenticate_memory(cipher_idx, key, 16, IV, 15, (unsigned char*)&quot;&quot;, 0, buf, MAC_SIZE*1024, buf, tag, &amp;z)) != CRYPT_OK) {
1051             fprintf(stderr, &quot;\nOCB3 error... %s\n&quot;, error_to_string(err));
1052             exit(EXIT_FAILURE);
1053          }
1054          t1 = t_read() - t1;
1055          if (t1 &lt; t2) t2 = t1;
1056     }
1057     fprintf(stderr, &quot;OCB3 \t\t\t%9&quot;PRI64&quot;u\n&quot;, t2/(ulong64)(MAC_SIZE*1024));
1058  #endif
1059  #ifdef LTC_CCM_MODE
1060     t2 = -1;
1061     for (x = 0; x &lt; 10000; x++) {
1062          t_start();
1063          t1 = t_read();
1064          z = 16;
1065          if ((err = ccm_memory(cipher_idx, key, 16, NULL, IV, 16, NULL, 0, buf, MAC_SIZE*1024, buf, tag, &amp;z, CCM_ENCRYPT)) != CRYPT_OK) {
1066             fprintf(stderr, &quot;\nCCM error... %s\n&quot;, error_to_string(err));
1067             exit(EXIT_FAILURE);
1068          }
1069          t1 = t_read() - t1;
1070          if (t1 &lt; t2) t2 = t1;
1071     }
1072     fprintf(stderr, &quot;CCM (no-precomp) \t%9&quot;PRI64&quot;u\n&quot;, t2/(ulong64)(MAC_SIZE*1024));
1073     cipher_descriptor[cipher_idx].setup(key, 16, 0, &amp;skey);
1074     t2 = -1;
1075     for (x = 0; x &lt; 10000; x++) {
1076          t_start();
1077          t1 = t_read();
1078          z = 16;
1079          if ((err = ccm_memory(cipher_idx, key, 16, &amp;skey, IV, 16, NULL, 0, buf, MAC_SIZE*1024, buf, tag, &amp;z, CCM_ENCRYPT)) != CRYPT_OK) {
1080             fprintf(stderr, &quot;\nCCM error... %s\n&quot;, error_to_string(err));
1081             exit(EXIT_FAILURE);
1082          }
1083          t1 = t_read() - t1;
1084          if (t1 &lt; t2) t2 = t1;
1085     }
1086     fprintf(stderr, &quot;CCM (precomp) \t\t%9&quot;PRI64&quot;u\n&quot;, t2/(ulong64)(MAC_SIZE*1024));
1087     cipher_descriptor[cipher_idx].done(&amp;skey);
1088  #endif
1089  #ifdef LTC_GCM_MODE
1090     t2 = -1;
1091     for (x = 0; x &lt; 100; x++) {
1092          t_start();
1093          t1 = t_read();
1094          z = 16;
1095          if ((err = gcm_memory(cipher_idx, key, 16, IV, 16, NULL, 0, buf, MAC_SIZE*1024, buf, tag, &amp;z, GCM_ENCRYPT)) != CRYPT_OK) {
1096             fprintf(stderr, &quot;\nGCM error... %s\n&quot;, error_to_string(err));
1097             exit(EXIT_FAILURE);
1098          }
1099          t1 = t_read() - t1;
1100          if (t1 &lt; t2) t2 = t1;
1101     }
1102     fprintf(stderr, &quot;GCM (no-precomp)\t%9&quot;PRI64&quot;u\n&quot;, t2/(ulong64)(MAC_SIZE*1024));
1103     {
1104     gcm_state gcm
1105  #ifdef LTC_GCM_TABLES_SSE2
1106  __attribute__ ((aligned (16)))
1107  #endif
1108  ;
1109     if ((err = gcm_init(&amp;gcm, cipher_idx, key, 16)) != CRYPT_OK) { fprintf(stderr, &quot;gcm_init: %s\n&quot;, error_to_string(err)); exit(EXIT_FAILURE); }
1110     t2 = -1;
1111     for (x = 0; x &lt; 10000; x++) {
1112          t_start();
1113          t1 = t_read();
1114          z = 16;
1115          if ((err = gcm_reset(&amp;gcm)) != CRYPT_OK) {
1116              fprintf(stderr, &quot;\nGCM error[%d]... %s\n&quot;, __LINE__, error_to_string(err));
1117             exit(EXIT_FAILURE);
1118          }
1119          if ((err = gcm_add_iv(&amp;gcm, IV, 16)) != CRYPT_OK) {
1120              fprintf(stderr, &quot;\nGCM error[%d]... %s\n&quot;, __LINE__, error_to_string(err));
1121             exit(EXIT_FAILURE);
1122          }
1123          if ((err = gcm_add_aad(&amp;gcm, NULL, 0)) != CRYPT_OK) {
1124              fprintf(stderr, &quot;\nGCM error[%d]... %s\n&quot;, __LINE__, error_to_string(err));
1125             exit(EXIT_FAILURE);
1126          }
1127          if ((err = gcm_process(&amp;gcm, buf, MAC_SIZE*1024, buf, GCM_ENCRYPT)) != CRYPT_OK) {
1128              fprintf(stderr, &quot;\nGCM error[%d]... %s\n&quot;, __LINE__, error_to_string(err));
1129             exit(EXIT_FAILURE);
1130          }
1131          if ((err = gcm_done(&amp;gcm, tag, &amp;z)) != CRYPT_OK) {
1132              fprintf(stderr, &quot;\nGCM error[%d]... %s\n&quot;, __LINE__, error_to_string(err));
1133             exit(EXIT_FAILURE);
1134          }
1135          t1 = t_read() - t1;
1136          if (t1 &lt; t2) t2 = t1;
1137     }
1138     fprintf(stderr, &quot;GCM (precomp)\t\t%9&quot;PRI64&quot;u\n&quot;, t2/(ulong64)(MAC_SIZE*1024));
1139     }
1140  #endif
1141     XFREE(buf);
1142  #else
1143     LTC_UNUSED_PARAM(MAC_SIZE);
1144     fprintf(stderr, &quot;NO ENCMACs\n&quot;);
1145  #endif
1146  }
1147  static void time_encmacs(void)
1148  {
1149     time_encmacs_(1);
1150     time_encmacs_(4);
1151     time_encmacs_(32);
1152  }
1153  #define LTC_TEST_FN(f)  { f, #f }
1154  int main(int argc, char **argv)
1155  {
1156  int err;
1157  const struct
1158  {
1159     void (*fn)(void);
1160     const char* name;
1161  } test_functions[] = {
1162     LTC_TEST_FN(time_keysched),
1163     LTC_TEST_FN(time_cipher_ecb),
1164     LTC_TEST_FN(time_cipher_cbc),
1165     LTC_TEST_FN(time_cipher_ctr),
1166     LTC_TEST_FN(time_cipher_lrw),
1167     LTC_TEST_FN(time_hash),
1168     LTC_TEST_FN(time_macs),
1169     LTC_TEST_FN(time_encmacs),
1170     LTC_TEST_FN(time_prng),
1171     LTC_TEST_FN(time_mult),
1172     LTC_TEST_FN(time_sqr),
1173     LTC_TEST_FN(time_rsa),
1174     LTC_TEST_FN(time_dsa),
1175     LTC_TEST_FN(time_ecc),
1176     LTC_TEST_FN(time_dh),
1177  };
1178  char *single_test = NULL;
1179  unsigned int i;
1180  const char* mpi_provider = NULL;
1181  init_timer();
1182  register_all_ciphers();
1183  register_all_hashes();
1184  register_all_prngs();
1185  #ifdef USE_LTM
1186     mpi_provider = &quot;ltm&quot;;
1187  #elif defined(USE_TFM)
1188     mpi_provider = &quot;tfm&quot;;
1189  #elif defined(USE_GMP)
1190     mpi_provider = &quot;gmp&quot;;
1191  #elif defined(EXT_MATH_LIB)
1192     mpi_provider = &quot;ext&quot;;
1193  #endif
1194     if (argc &gt; 2) {
1195        mpi_provider = argv[2];
1196     }
1197     crypt_mp_init(mpi_provider);
1198  if ((err = rng_make_prng(128, find_prng(&quot;yarrow&quot;), &amp;yarrow_prng, NULL)) != CRYPT_OK) {
1199     fprintf(stderr, &quot;rng_make_prng failed: %s\n&quot;, error_to_string(err));
1200     exit(EXIT_FAILURE);
1201  }
1202  if (argc &gt; 1) single_test = argv[1];
1203  for (i = 0; i &lt; sizeof(test_functions)/sizeof(test_functions[0]); ++i) {
1204     if (single_test &amp;&amp; strstr(test_functions[i].name, single_test) == NULL) {
1205       continue;
1206     }
1207     test_functions[i].fn();
1208  }
1209  return EXIT_SUCCESS;
1210  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-timing.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-timing.c</div>
                </div>
                <div class="column column_space"><pre><code>893     yarrow_read(key, 16, &amp;yarrow_prng);
894  #ifdef LTC_OMAC
895     t2 = -1;
896     for (x = 0; x &lt; 10000; x++) {
897          t_start();
898          t1 = t_read();
899          z = 16;
900          if ((err = omac_memory(cipher_idx, key, 16, buf, MAC_SIZE*1024, tag, &amp;z)) != CRYPT_OK) {
</pre></code></div>
                <div class="column column_space"><pre><code>1013     yarrow_read(IV, 16, &amp;yarrow_prng);
1014  #ifdef LTC_EAX_MODE
1015     t2 = -1;
1016     for (x = 0; x &lt; 10000; x++) {
1017          t_start();
1018          t1 = t_read();
1019          z = 16;
1020          if ((err = eax_encrypt_authenticate_memory(cipher_idx, key, 16, IV, 16, NULL, 0, buf, MAC_SIZE*1024, buf, tag, &amp;z)) != CRYPT_OK) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    