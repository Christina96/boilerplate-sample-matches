
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 13.60544217687075%, Tokens: 10</h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-core.h</h3>
            <pre><code>1  #ifndef ARGON2_CORE_H
2  #define ARGON2_CORE_H
3  #include "3rdparty/argon2.h"
4  #if defined(_MSC_VER)
5  #define ALIGN(n) __declspec(align(16))
6  #elif defined(__GNUC__) || defined(__clang)
7  #define ALIGN(x) __attribute__((__aligned__(x)))
8  #else
9  #define ALIGN(x)
10  #endif
11  #define CONST_CAST(x) (x)(uintptr_t)
12  enum argon2_core_constants {
13      ARGON2_BLOCK_SIZE = 1024,
14      ARGON2_QWORDS_IN_BLOCK = ARGON2_BLOCK_SIZE / 8,
15      ARGON2_OWORDS_IN_BLOCK = ARGON2_BLOCK_SIZE / 16,
16      ARGON2_ADDRESSES_IN_BLOCK = 128,
17      ARGON2_PREHASH_DIGEST_LENGTH = 64,
18      ARGON2_PREHASH_SEED_LENGTH = 72
19  };
20  typedef struct block_ { uint64_t v[ARGON2_QWORDS_IN_BLOCK]; } block;
21  void init_block_value(block *b, uint8_t in);
22  void copy_block(block *dst, const block *src);
23  void xor_block(block *dst, const block *src);
<span onclick='openModal()' class='match'>24  typedef struct Argon2_instance_t {
25      block *memory;          &bsol;* Memory pointer */
26      uint32_t version;
27      uint32_t passes;        &bsol;* Number of passes */
28      uint32_t memory_blocks; &bsol;* Number of blocks in memory */
29      uint32_t segment_length;
30      uint32_t lane_length;
31      uint32_t lanes;
32      uint32_t threads;
33      argon2_type type;
34      int print_internals; &bsol;* whether to print the memory blocks */
35      int keep_memory;
36      argon2_context *context_ptr; &bsol;* points back to original context */
37  } argon2_instance_t;
38  typedef struct Argon2_position_t {
39      uint32_t pass;
40      uint32_t lane;
41      uint8_t slice;
42      uint32_t index;
43  } argon2_position_t;
</span>44  typedef struct Argon2_thread_data {
45      argon2_instance_t *instance_ptr;
46      argon2_position_t pos;
47  } argon2_thread_data;
48  int xmrig_ar2_allocate_memory(const argon2_context *context, argon2_instance_t *instance);
49  void xmrig_ar2_free_memory(const argon2_context *context, const argon2_instance_t *instance);
50  void xmrig_ar2_secure_wipe_memory(void *v, size_t n);
51  ARGON2_PUBLIC void xmrig_ar2_clear_internal_memory(void *v, size_t n);
52  uint32_t xmrig_ar2_index_alpha(const argon2_instance_t *instance, const argon2_position_t *position, uint32_t pseudo_rand, int same_lane);
53  int xmrig_ar2_validate_inputs(const argon2_context *context);
54  void xmrig_ar2_initial_hash(uint8_t *blockhash, argon2_context *context, argon2_type type);
55  void xmrig_ar2_fill_first_blocks(uint8_t *blockhash, const argon2_instance_t *instance);
56  int xmrig_ar2_initialize(argon2_instance_t *instance, argon2_context *context);
57  void xmrig_ar2_finalize(const argon2_context *context, argon2_instance_t *instance);
58  void xmrig_ar2_fill_segment(const argon2_instance_t *instance, argon2_position_t position);
59  int xmrig_ar2_fill_memory_blocks(argon2_instance_t *instance);
60  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-swscale.h</h3>
            <pre><code>1  #ifndef SWSCALE_SWSCALE_H
2  #define SWSCALE_SWSCALE_H
3  #include <stdint.h>
4  #include "libavutil/avutil.h"
5  #include "libavutil/log.h"
6  #include "libavutil/pixfmt.h"
7  #include "version.h"
8  unsigned swscale_version(void);
9  const char *swscale_configuration(void);
10  const char *swscale_license(void);
11  #define SWS_FAST_BILINEAR     1
12  #define SWS_BILINEAR          2
13  #define SWS_BICUBIC           4
14  #define SWS_X                 8
15  #define SWS_POINT          0x10
16  #define SWS_AREA           0x20
17  #define SWS_BICUBLIN       0x40
18  #define SWS_GAUSS          0x80
19  #define SWS_SINC          0x100
20  #define SWS_LANCZOS       0x200
21  #define SWS_SPLINE        0x400
22  #define SWS_SRC_V_CHR_DROP_MASK     0x30000
23  #define SWS_SRC_V_CHR_DROP_SHIFT    16
24  #define SWS_PARAM_DEFAULT           123456
25  #define SWS_PRINT_INFO              0x1000
26  #define SWS_FULL_CHR_H_INT    0x2000
27  #define SWS_FULL_CHR_H_INP    0x4000
28  #define SWS_DIRECT_BGR        0x8000
29  #define SWS_ACCURATE_RND      0x40000
30  #define SWS_BITEXACT          0x80000
31  #define SWS_ERROR_DIFFUSION  0x800000
32  #define SWS_MAX_REDUCE_CUTOFF 0.002
33  #define SWS_CS_ITU709         1
34  #define SWS_CS_FCC            4
35  #define SWS_CS_ITU601         5
36  #define SWS_CS_ITU624         5
37  #define SWS_CS_SMPTE170M      5
38  #define SWS_CS_SMPTE240M      7
39  #define SWS_CS_DEFAULT        5
40  #define SWS_CS_BT2020         9
41  const int *sws_getCoefficients(int colorspace);
<span onclick='openModal()' class='match'>42  typedef struct SwsVector {
43      double *coeff;              
44      int length;                 
45  } SwsVector;
46  typedef struct SwsFilter {
47      SwsVector *lumH;
48      SwsVector *lumV;
49      SwsVector *chrH;
50      SwsVector *chrV;
51  } SwsFilter;
</span>52  struct SwsContext;
53  int sws_isSupportedInput(enum AVPixelFormat pix_fmt);
54  int sws_isSupportedOutput(enum AVPixelFormat pix_fmt);
55  int sws_isSupportedEndiannessConversion(enum AVPixelFormat pix_fmt);
56  struct SwsContext *sws_alloc_context(void);
57  av_warn_unused_result
58  int sws_init_context(struct SwsContext *sws_context, SwsFilter *srcFilter, SwsFilter *dstFilter);
59  void sws_freeContext(struct SwsContext *swsContext);
60  struct SwsContext *sws_getContext(int srcW, int srcH, enum AVPixelFormat srcFormat,
61                                    int dstW, int dstH, enum AVPixelFormat dstFormat,
62                                    int flags, SwsFilter *srcFilter,
63                                    SwsFilter *dstFilter, const double *param);
64  int sws_scale(struct SwsContext *c, const uint8_t *const srcSlice[],
65                const int srcStride[], int srcSliceY, int srcSliceH,
66                uint8_t *const dst[], const int dstStride[]);
67  int sws_setColorspaceDetails(struct SwsContext *c, const int inv_table[4],
68                               int srcRange, const int table[4], int dstRange,
69                               int brightness, int contrast, int saturation);
70  int sws_getColorspaceDetails(struct SwsContext *c, int **inv_table,
71                               int *srcRange, int **table, int *dstRange,
72                               int *brightness, int *contrast, int *saturation);
73  SwsVector *sws_allocVec(int length);
74  SwsVector *sws_getGaussianVec(double variance, double quality);
75  void sws_scaleVec(SwsVector *a, double scalar);
76  void sws_normalizeVec(SwsVector *a, double height);
77  #if FF_API_SWS_VECTOR
78  attribute_deprecated SwsVector *sws_getConstVec(double c, int length);
79  attribute_deprecated SwsVector *sws_getIdentityVec(void);
80  attribute_deprecated void sws_convVec(SwsVector *a, SwsVector *b);
81  attribute_deprecated void sws_addVec(SwsVector *a, SwsVector *b);
82  attribute_deprecated void sws_subVec(SwsVector *a, SwsVector *b);
83  attribute_deprecated void sws_shiftVec(SwsVector *a, int shift);
84  attribute_deprecated SwsVector *sws_cloneVec(SwsVector *a);
85  attribute_deprecated void sws_printVec2(SwsVector *a, AVClass *log_ctx, int log_level);
86  #endif
87  void sws_freeVec(SwsVector *a);
88  SwsFilter *sws_getDefaultFilter(float lumaGBlur, float chromaGBlur,
89                                  float lumaSharpen, float chromaSharpen,
90                                  float chromaHShift, float chromaVShift,
91                                  int verbose);
92  void sws_freeFilter(SwsFilter *filter);
93  struct SwsContext *sws_getCachedContext(struct SwsContext *context,
94                                          int srcW, int srcH, enum AVPixelFormat srcFormat,
95                                          int dstW, int dstH, enum AVPixelFormat dstFormat,
96                                          int flags, SwsFilter *srcFilter,
97                                          SwsFilter *dstFilter, const double *param);
98  void sws_convertPalette8ToPacked32(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette);
99  void sws_convertPalette8ToPacked24(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette);
100  const AVClass *sws_get_class(void);
101  #endif &bsol;* SWSCALE_SWSCALE_H */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-core.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-swscale.h</div>
                </div>
                <div class="column column_space"><pre><code>24  typedef struct Argon2_instance_t {
25      block *memory;          &bsol;* Memory pointer */
26      uint32_t version;
27      uint32_t passes;        &bsol;* Number of passes */
28      uint32_t memory_blocks; &bsol;* Number of blocks in memory */
29      uint32_t segment_length;
30      uint32_t lane_length;
31      uint32_t lanes;
32      uint32_t threads;
33      argon2_type type;
34      int print_internals; &bsol;* whether to print the memory blocks */
35      int keep_memory;
36      argon2_context *context_ptr; &bsol;* points back to original context */
37  } argon2_instance_t;
38  typedef struct Argon2_position_t {
39      uint32_t pass;
40      uint32_t lane;
41      uint8_t slice;
42      uint32_t index;
43  } argon2_position_t;
</pre></code></div>
                <div class="column column_space"><pre><code>42  typedef struct SwsVector {
43      double *coeff;              
44      int length;                 
45  } SwsVector;
46  typedef struct SwsFilter {
47      SwsVector *lumH;
48      SwsVector *lumV;
49      SwsVector *chrH;
50      SwsVector *chrV;
51  } SwsFilter;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    