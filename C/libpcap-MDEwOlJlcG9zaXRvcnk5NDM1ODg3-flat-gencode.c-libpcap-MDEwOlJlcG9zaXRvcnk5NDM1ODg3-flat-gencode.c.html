
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-gencode.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #ifdef _WIN32
5    #include <ws2tcpip.h>
6  #else
7    #include <sys/socket.h>
8    #ifdef __NetBSD__
9      #include <sys/param.h>
10    #endif
11    #include <netinet/in.h>
12    #include <arpa/inet.h>
13  #endif &bsol;* _WIN32 */
14  #include <stdlib.h>
15  #include <string.h>
16  #include <memory.h>
17  #include <setjmp.h>
18  #include <stdarg.h>
19  #include <stdio.h>
20  #ifdef MSDOS
21  #include "pcap-dos.h"
22  #endif
23  #include "pcap-int.h"
24  #include "extract.h"
25  #include "ethertype.h"
26  #include "nlpid.h"
27  #include "llc.h"
28  #include "gencode.h"
29  #include "ieee80211.h"
30  #include "atmuni31.h"
31  #include "sunatmpos.h"
32  #include "pflog.h"
33  #include "ppp.h"
34  #include "pcap/sll.h"
35  #include "pcap/ipnet.h"
36  #include "arcnet.h"
37  #include "diag-control.h"
38  #include "scanner.h"
39  #if defined(linux)
40  #include <linux/types.h>
41  #include <linux/if_packet.h>
42  #include <linux/filter.h>
43  #endif
44  #ifndef offsetof
45  #define offsetof(s, e) ((size_t)&((s *)0)->e)
46  #endif
47  #ifdef _WIN32
48    #ifdef INET6
49      #if defined(__MINGW32__) && defined(DEFINE_ADDITIONAL_IPV6_STUFF)
50  struct in6_addr
51    {
52      union
53        {
54  	uint8_t		u6_addr8[16];
55  	uint16_t	u6_addr16[8];
56  	uint32_t	u6_addr32[4];
57        } in6_u;
58  #define s6_addr			in6_u.u6_addr8
59  #define s6_addr16		in6_u.u6_addr16
60  #define s6_addr32		in6_u.u6_addr32
61  #define s6_addr64		in6_u.u6_addr64
62    };
63  typedef unsigned short	sa_family_t;
64  #define	__SOCKADDR_COMMON(sa_prefix) \
65    sa_family_t sa_prefix##family
66  struct sockaddr_in6
67    {
68      __SOCKADDR_COMMON (sin6_);
69      uint16_t sin6_port;		&bsol;* Transport layer port # */
70      uint32_t sin6_flowinfo;	&bsol;* IPv6 flow information */
71      struct in6_addr sin6_addr;	&bsol;* IPv6 address */
72    };
73        #ifndef EAI_ADDRFAMILY
74  struct addrinfo {
75  	int	ai_flags;	&bsol;* AI_PASSIVE, AI_CANONNAME */
76  	int	ai_family;	&bsol;* PF_xxx */
77  	int	ai_socktype;	&bsol;* SOCK_xxx */
78  	int	ai_protocol;	&bsol;* 0 or IPPROTO_xxx for IPv4 and IPv6 */
79  	size_t	ai_addrlen;	&bsol;* length of ai_addr */
80  	char	*ai_canonname;	&bsol;* canonical name for hostname */
81  	struct sockaddr *ai_addr;	&bsol;* binary address */
82  	struct addrinfo *ai_next;	&bsol;* next structure in linked list */
83  };
84        #endif &bsol;* EAI_ADDRFAMILY */
85      #endif &bsol;* defined(__MINGW32__) && defined(DEFINE_ADDITIONAL_IPV6_STUFF) */
86    #endif &bsol;* INET6 */
87  #else &bsol;* _WIN32 */
88    #include <netdb.h>	&bsol;* for "struct addrinfo" */
89  #endif &bsol;* _WIN32 */
90  #include <pcap/namedb.h>
91  #include "nametoaddr.h"
92  #define ETHERMTU	1500
93  #ifndef IPPROTO_HOPOPTS
94  #define IPPROTO_HOPOPTS 0
95  #endif
96  #ifndef IPPROTO_ROUTING
97  #define IPPROTO_ROUTING 43
98  #endif
99  #ifndef IPPROTO_FRAGMENT
100  #define IPPROTO_FRAGMENT 44
101  #endif
102  #ifndef IPPROTO_DSTOPTS
103  #define IPPROTO_DSTOPTS 60
104  #endif
105  #ifndef IPPROTO_SCTP
106  #define IPPROTO_SCTP 132
107  #endif
108  #define GENEVE_PORT 6081
109  #ifdef HAVE_OS_PROTO_H
110  #include "os-proto.h"
111  #endif
112  #define JMP(c) ((c)|BPF_JMP|BPF_K)
113  #define PUSH_LINKHDR(cs, new_linktype, new_is_variable, new_constant_part, new_reg) \
114  { \
115  	(cs)->prevlinktype = (cs)->linktype; \
116  	(cs)->off_prevlinkhdr = (cs)->off_linkhdr; \
117  	(cs)->linktype = (new_linktype); \
118  	(cs)->off_linkhdr.is_variable = (new_is_variable); \
119  	(cs)->off_linkhdr.constant_part = (new_constant_part); \
120  	(cs)->off_linkhdr.reg = (new_reg); \
121  	(cs)->is_geneve = 0; \
122  }
123  #define OFFSET_NOT_SET	0xffffffffU
124  typedef struct {
125  	int	is_variable;
126  	u_int	constant_part;
127  	int	reg;
128  } bpf_abs_offset;
129  enum e_offrel {
130  	OR_PACKET,		&bsol;* full packet data */
131  	OR_LINKHDR,		&bsol;* link-layer header */
132  	OR_PREVLINKHDR,		&bsol;* previous link-layer header */
133  	OR_LLC,			&bsol;* 802.2 LLC header */
134  	OR_PREVMPLSHDR,		&bsol;* previous MPLS header */
135  	OR_LINKTYPE,		&bsol;* link-layer type */
136  	OR_LINKPL,		&bsol;* link-layer payload */
137  	OR_LINKPL_NOSNAP,	&bsol;* link-layer payload, with no SNAP header at the link layer */
138  	OR_TRAN_IPV4,		&bsol;* transport-layer header, with IPv4 network layer */
139  	OR_TRAN_IPV6		&bsol;* transport-layer header, with IPv6 network layer */
140  };
141  #define NCHUNKS 16
142  #define CHUNK0SIZE 1024
143  struct chunk {
144  	size_t n_left;
145  	void *m;
146  };
147  struct chunk_align {
148  	char dummy;
149  	union {
150  		char c;
151  		struct block b;
152  		struct slist s;
153  		struct arth a;
154  	} u;
155  };
156  #define CHUNK_ALIGN (offsetof(struct chunk_align, u))
157  struct _compiler_state {
158  	jmp_buf top_ctx;
159  	pcap_t *bpf_pcap;
160  	int error_set;
161  	struct icode ic;
162  	int snaplen;
163  	int linktype;
164  	int prevlinktype;
165  	int outermostlinktype;
166  	bpf_u_int32 netmask;
167  	int no_optimize;
168  	u_int label_stack_depth;
169  	u_int vlan_stack_depth;
170  	u_int pcap_fddipad;
171  	struct addrinfo *ai;
172  	u_char *e;
173  	bpf_abs_offset off_linkhdr;
174  	bpf_abs_offset off_prevlinkhdr;
175  	bpf_abs_offset off_outermostlinkhdr;
176  	bpf_abs_offset off_linkpl;
177  	bpf_abs_offset off_linktype;
178  	int is_atm;
179  	int is_geneve;
180  	int is_vlan_vloffset;
181  	u_int off_vpi;
182  	u_int off_vci;
183  	u_int off_proto;
184  	u_int off_li;
185  	u_int off_li_hsl;
186  	u_int off_sio;
187  	u_int off_opc;
188  	u_int off_dpc;
189  	u_int off_sls;
190  	u_int off_payload;
191  	u_int off_nl;
192  	u_int off_nl_nosnap;
193  	int regused[BPF_MEMWORDS];
194  	int curreg;
195  	struct chunk chunks[NCHUNKS];
196  	int cur_chunk;
197  };
198  void
199  bpf_set_error(compiler_state_t *cstate, const char *fmt, ...)
200  {
201  	va_list ap;
202  	if (!cstate->error_set) {
203  		va_start(ap, fmt);
204  		(void)vsnprintf(cstate->bpf_pcap->errbuf, PCAP_ERRBUF_SIZE,
205  		    fmt, ap);
206  		va_end(ap);
207  		cstate->error_set = 1;
208  	}
209  }
210  static void PCAP_NORETURN bpf_error(compiler_state_t *, const char *, ...)
211      PCAP_PRINTFLIKE(2, 3);
212  static void PCAP_NORETURN
213  bpf_error(compiler_state_t *cstate, const char *fmt, ...)
214  {
215  	va_list ap;
216  	va_start(ap, fmt);
217  	(void)vsnprintf(cstate->bpf_pcap->errbuf, PCAP_ERRBUF_SIZE,
218  	    fmt, ap);
219  	va_end(ap);
220  	longjmp(cstate->top_ctx, 1);
221  #ifdef _AIX
222  	PCAP_UNREACHABLE
223  #endif &bsol;* _AIX */
224  }
225  static int init_linktype(compiler_state_t *, pcap_t *);
226  static void init_regs(compiler_state_t *);
227  static int alloc_reg(compiler_state_t *);
228  static void free_reg(compiler_state_t *, int);
229  static void initchunks(compiler_state_t *cstate);
230  static void *newchunk_nolongjmp(compiler_state_t *cstate, size_t);
231  static void *newchunk(compiler_state_t *cstate, size_t);
232  static void freechunks(compiler_state_t *cstate);
233  static inline struct block *new_block(compiler_state_t *cstate, int);
234  static inline struct slist *new_stmt(compiler_state_t *cstate, int);
235  static struct block *gen_retblk(compiler_state_t *cstate, int);
236  static inline void syntax(compiler_state_t *cstate);
237  static void backpatch(struct block *, struct block *);
238  static void merge(struct block *, struct block *);
239  static struct block *gen_cmp(compiler_state_t *, enum e_offrel, u_int,
240      u_int, bpf_u_int32);
241  static struct block *gen_cmp_gt(compiler_state_t *, enum e_offrel, u_int,
242      u_int, bpf_u_int32);
243  static struct block *gen_cmp_ge(compiler_state_t *, enum e_offrel, u_int,
244      u_int, bpf_u_int32);
245  static struct block *gen_cmp_lt(compiler_state_t *, enum e_offrel, u_int,
246      u_int, bpf_u_int32);
247  static struct block *gen_cmp_le(compiler_state_t *, enum e_offrel, u_int,
248      u_int, bpf_u_int32);
249  static struct block *gen_mcmp(compiler_state_t *, enum e_offrel, u_int,
250      u_int, bpf_u_int32, bpf_u_int32);
251  static struct block *gen_bcmp(compiler_state_t *, enum e_offrel, u_int,
252      u_int, const u_char *);
253  static struct block *gen_ncmp(compiler_state_t *, enum e_offrel, u_int,
254      u_int, bpf_u_int32, int, int, bpf_u_int32);
255  static struct slist *gen_load_absoffsetrel(compiler_state_t *, bpf_abs_offset *,
256      u_int, u_int);
257  static struct slist *gen_load_a(compiler_state_t *, enum e_offrel, u_int,
258      u_int);
259  static struct slist *gen_loadx_iphdrlen(compiler_state_t *);
260  static struct block *gen_uncond(compiler_state_t *, int);
261  static inline struct block *gen_true(compiler_state_t *);
262  static inline struct block *gen_false(compiler_state_t *);
263  static struct block *gen_ether_linktype(compiler_state_t *, bpf_u_int32);
264  static struct block *gen_ipnet_linktype(compiler_state_t *, bpf_u_int32);
265  static struct block *gen_linux_sll_linktype(compiler_state_t *, bpf_u_int32);
266  static struct slist *gen_load_pflog_llprefixlen(compiler_state_t *);
267  static struct slist *gen_load_prism_llprefixlen(compiler_state_t *);
268  static struct slist *gen_load_avs_llprefixlen(compiler_state_t *);
269  static struct slist *gen_load_radiotap_llprefixlen(compiler_state_t *);
270  static struct slist *gen_load_ppi_llprefixlen(compiler_state_t *);
271  static void insert_compute_vloffsets(compiler_state_t *, struct block *);
272  static struct slist *gen_abs_offset_varpart(compiler_state_t *,
273      bpf_abs_offset *);
274  static bpf_u_int32 ethertype_to_ppptype(bpf_u_int32);
275  static struct block *gen_linktype(compiler_state_t *, bpf_u_int32);
276  static struct block *gen_snap(compiler_state_t *, bpf_u_int32, bpf_u_int32);
277  static struct block *gen_llc_linktype(compiler_state_t *, bpf_u_int32);
278  static struct block *gen_hostop(compiler_state_t *, bpf_u_int32, bpf_u_int32,
279      int, bpf_u_int32, u_int, u_int);
280  #ifdef INET6
281  static struct block *gen_hostop6(compiler_state_t *, struct in6_addr *,
282      struct in6_addr *, int, bpf_u_int32, u_int, u_int);
283  #endif
284  static struct block *gen_ahostop(compiler_state_t *, const u_char *, int);
285  static struct block *gen_ehostop(compiler_state_t *, const u_char *, int);
286  static struct block *gen_fhostop(compiler_state_t *, const u_char *, int);
287  static struct block *gen_thostop(compiler_state_t *, const u_char *, int);
288  static struct block *gen_wlanhostop(compiler_state_t *, const u_char *, int);
289  static struct block *gen_ipfchostop(compiler_state_t *, const u_char *, int);
290  static struct block *gen_dnhostop(compiler_state_t *, bpf_u_int32, int);
291  static struct block *gen_mpls_linktype(compiler_state_t *, bpf_u_int32);
292  static struct block *gen_host(compiler_state_t *, bpf_u_int32, bpf_u_int32,
293      int, int, int);
294  #ifdef INET6
295  static struct block *gen_host6(compiler_state_t *, struct in6_addr *,
296      struct in6_addr *, int, int, int);
297  #endif
298  #ifndef INET6
299  static struct block *gen_gateway(compiler_state_t *, const u_char *,
300      struct addrinfo *, int, int);
301  #endif
302  static struct block *gen_ipfrag(compiler_state_t *);
303  static struct block *gen_portatom(compiler_state_t *, int, bpf_u_int32);
304  static struct block *gen_portrangeatom(compiler_state_t *, u_int, bpf_u_int32,
305      bpf_u_int32);
306  static struct block *gen_portatom6(compiler_state_t *, int, bpf_u_int32);
307  static struct block *gen_portrangeatom6(compiler_state_t *, u_int, bpf_u_int32,
308      bpf_u_int32);
309  static struct block *gen_portop(compiler_state_t *, u_int, u_int, int);
310  static struct block *gen_port(compiler_state_t *, u_int, int, int);
311  static struct block *gen_portrangeop(compiler_state_t *, u_int, u_int,
312      bpf_u_int32, int);
313  static struct block *gen_portrange(compiler_state_t *, u_int, u_int, int, int);
314  struct block *gen_portop6(compiler_state_t *, u_int, u_int, int);
315  static struct block *gen_port6(compiler_state_t *, u_int, int, int);
316  static struct block *gen_portrangeop6(compiler_state_t *, u_int, u_int,
317      bpf_u_int32, int);
318  static struct block *gen_portrange6(compiler_state_t *, u_int, u_int, int, int);
319  static int lookup_proto(compiler_state_t *, const char *, int);
320  #if !defined(NO_PROTOCHAIN)
321  static struct block *gen_protochain(compiler_state_t *, bpf_u_int32, int);
322  #endif &bsol;* !defined(NO_PROTOCHAIN) */
323  static struct block *gen_proto(compiler_state_t *, bpf_u_int32, int, int);
324  static struct slist *xfer_to_x(compiler_state_t *, struct arth *);
325  static struct slist *xfer_to_a(compiler_state_t *, struct arth *);
326  static struct block *gen_mac_multicast(compiler_state_t *, int);
327  static struct block *gen_len(compiler_state_t *, int, int);
328  static struct block *gen_check_802_11_data_frame(compiler_state_t *);
329  static struct block *gen_geneve_ll_check(compiler_state_t *cstate);
330  static struct block *gen_ppi_dlt_check(compiler_state_t *);
331  static struct block *gen_atmfield_code_internal(compiler_state_t *, int,
332      bpf_u_int32, int, int);
333  static struct block *gen_atmtype_llc(compiler_state_t *);
334  static struct block *gen_msg_abbrev(compiler_state_t *, int type);
335  static void
336  initchunks(compiler_state_t *cstate)
337  {
338  	int i;
339  	for (i = 0; i < NCHUNKS; i++) {
340  		cstate->chunks[i].n_left = 0;
341  		cstate->chunks[i].m = NULL;
342  	}
343  	cstate->cur_chunk = 0;
344  }
345  static void *
346  newchunk_nolongjmp(compiler_state_t *cstate, size_t n)
347  {
348  	struct chunk *cp;
349  	int k;
350  	size_t size;
351  	n = (n + CHUNK_ALIGN - 1) & ~(CHUNK_ALIGN - 1);
352  	cp = &cstate->chunks[cstate->cur_chunk];
353  	if (n > cp->n_left) {
354  		++cp;
355  		k = ++cstate->cur_chunk;
356  		if (k >= NCHUNKS) {
357  			bpf_set_error(cstate, "out of memory");
358  			return (NULL);
359  		}
360  		size = CHUNK0SIZE << k;
361  		cp->m = (void *)malloc(size);
362  		if (cp->m == NULL) {
363  			bpf_set_error(cstate, "out of memory");
364  			return (NULL);
365  		}
366  		memset((char *)cp->m, 0, size);
367  		cp->n_left = size;
368  		if (n > size) {
369  			bpf_set_error(cstate, "out of memory");
370  			return (NULL);
371  		}
372  	}
373  	cp->n_left -= n;
374  	return (void *)((char *)cp->m + cp->n_left);
375  }
376  static void *
377  newchunk(compiler_state_t *cstate, size_t n)
378  {
379  	void *p;
380  	p = newchunk_nolongjmp(cstate, n);
381  	if (p == NULL) {
382  		longjmp(cstate->top_ctx, 1);
383  	}
384  	return (p);
385  }
386  static void
387  freechunks(compiler_state_t *cstate)
388  {
389  	int i;
390  	for (i = 0; i < NCHUNKS; ++i)
391  		if (cstate->chunks[i].m != NULL)
392  			free(cstate->chunks[i].m);
393  }
394  char *
395  sdup(compiler_state_t *cstate, const char *s)
396  {
397  	size_t n = strlen(s) + 1;
398  	char *cp = newchunk_nolongjmp(cstate, n);
399  	if (cp == NULL)
400  		return (NULL);
401  	pcap_strlcpy(cp, s, n);
402  	return (cp);
403  }
404  static inline struct block *
405  new_block(compiler_state_t *cstate, int code)
406  {
407  	struct block *p;
408  	p = (struct block *)newchunk(cstate, sizeof(*p));
409  	p->s.code = code;
410  	p->head = p;
411  	return p;
412  }
413  static inline struct slist *
414  new_stmt(compiler_state_t *cstate, int code)
415  {
416  	struct slist *p;
417  	p = (struct slist *)newchunk(cstate, sizeof(*p));
418  	p->s.code = code;
419  	return p;
420  }
421  static struct block *
422  gen_retblk(compiler_state_t *cstate, int v)
423  {
424  	struct block *b = new_block(cstate, BPF_RET|BPF_K);
425  	b->s.k = v;
426  	return b;
427  }
428  static inline PCAP_NORETURN_DEF void
429  syntax(compiler_state_t *cstate)
430  {
431  	bpf_error(cstate, "syntax error in filter expression");
432  }
433  int
434  pcap_compile(pcap_t *p, struct bpf_program *program,
435  	     const char *buf, int optimize, bpf_u_int32 mask)
436  {
437  #ifdef _WIN32
438  	static int done = 0;
439  #endif
440  	compiler_state_t cstate;
441  	const char * volatile xbuf = buf;
442  	yyscan_t scanner = NULL;
443  	volatile YY_BUFFER_STATE in_buffer = NULL;
444  	u_int len;
445  	int rc;
446  	if (!p->activated) {
447  		(void)snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
448  		    "not-yet-activated pcap_t passed to pcap_compile");
449  		return (PCAP_ERROR);
450  	}
451  #ifdef _WIN32
452  	if (!done) {
453  		pcap_wsockinit();
454  		done = 1;
455  	}
456  #endif
457  #ifdef ENABLE_REMOTE
458  	if (p->save_current_filter_op != NULL)
459  		(p->save_current_filter_op)(p, buf);
460  #endif
461  	initchunks(&cstate);
462  	cstate.no_optimize = 0;
463  #ifdef INET6
464  	cstate.ai = NULL;
465  #endif
466  	cstate.e = NULL;
467  	cstate.ic.root = NULL;
468  	cstate.ic.cur_mark = 0;
469  	cstate.bpf_pcap = p;
470  	cstate.error_set = 0;
471  	init_regs(&cstate);
472  	cstate.netmask = mask;
473  	cstate.snaplen = pcap_snapshot(p);
474  	if (cstate.snaplen == 0) {
475  		(void)snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
476  			 "snaplen of 0 rejects all packets");
477  		rc = PCAP_ERROR;
478  		goto quit;
479  	}
480  	if (pcap_lex_init(&scanner) != 0) {
481  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
482  		    errno, "can't initialize scanner");
483  		rc = PCAP_ERROR;
484  		goto quit;
485  	}
486  	in_buffer = pcap__scan_string(xbuf ? xbuf : "", scanner);
487  	pcap_set_extra(&cstate, scanner);
488  	if (init_linktype(&cstate, p) == -1) {
489  		rc = PCAP_ERROR;
490  		goto quit;
491  	}
492  	if (pcap_parse(scanner, &cstate) != 0) {
493  #ifdef INET6
494  		if (cstate.ai != NULL)
495  			freeaddrinfo(cstate.ai);
496  #endif
497  		if (cstate.e != NULL)
498  			free(cstate.e);
499  		rc = PCAP_ERROR;
500  		goto quit;
501  	}
502  	if (cstate.ic.root == NULL) {
503  		if (setjmp(cstate.top_ctx)) {
504  			rc = PCAP_ERROR;
505  			goto quit;
506  		}
507  		cstate.ic.root = gen_retblk(&cstate, cstate.snaplen);
508  	}
509  	if (optimize && !cstate.no_optimize) {
510  		if (bpf_optimize(&cstate.ic, p->errbuf) == -1) {
511  			rc = PCAP_ERROR;
512  			goto quit;
513  		}
514  		if (cstate.ic.root == NULL ||
515  		    (cstate.ic.root->s.code == (BPF_RET|BPF_K) && cstate.ic.root->s.k == 0)) {
516  			(void)snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
517  			    "expression rejects all packets");
518  			rc = PCAP_ERROR;
519  			goto quit;
520  		}
521  	}
522  	program->bf_insns = icode_to_fcode(&cstate.ic,
523  	    cstate.ic.root, &len, p->errbuf);
524  	if (program->bf_insns == NULL) {
525  		rc = PCAP_ERROR;
526  		goto quit;
527  	}
528  	program->bf_len = len;
529  	rc = 0;  &bsol;* We're all okay */
530  quit:
531  	if (in_buffer != NULL)
532  		pcap__delete_buffer(in_buffer, scanner);
533  	if (scanner != NULL)
534  		pcap_lex_destroy(scanner);
535  	freechunks(&cstate);
536  	return (rc);
537  }
538  int
539  pcap_compile_nopcap(int snaplen_arg, int linktype_arg,
540  		    struct bpf_program *program,
541  	     const char *buf, int optimize, bpf_u_int32 mask)
542  {
543  	pcap_t *p;
544  	int ret;
545  	p = pcap_open_dead(linktype_arg, snaplen_arg);
546  	if (p == NULL)
547  		return (PCAP_ERROR);
548  	ret = pcap_compile(p, program, buf, optimize, mask);
549  	pcap_close(p);
550  	return (ret);
551  }
552  void
553  pcap_freecode(struct bpf_program *program)
554  {
555  	program->bf_len = 0;
556  	if (program->bf_insns != NULL) {
557  		free((char *)program->bf_insns);
558  		program->bf_insns = NULL;
559  	}
560  }
561  static void
562  backpatch(struct block *list, struct block *target)
563  {
564  	struct block *next;
565  	while (list) {
566  		if (!list->sense) {
567  			next = JT(list);
568  			JT(list) = target;
569  		} else {
570  			next = JF(list);
571  			JF(list) = target;
572  		}
573  		list = next;
574  	}
575  }
576  static void
577  merge(struct block *b0, struct block *b1)
578  {
579  	register struct block **p = &b0;
580  	while (*p)
581  		p = !((*p)->sense) ? &JT(*p) : &JF(*p);
582  	*p = b1;
583  }
584  int
585  finish_parse(compiler_state_t *cstate, struct block *p)
586  {
587  	struct block *ppi_dlt_check;
588  	if (setjmp(cstate->top_ctx))
589  		return (-1);
590  	insert_compute_vloffsets(cstate, p->head);
591  	ppi_dlt_check = gen_ppi_dlt_check(cstate);
592  	if (ppi_dlt_check != NULL)
593  		gen_and(ppi_dlt_check, p);
594  	backpatch(p, gen_retblk(cstate, cstate->snaplen));
595  	p->sense = !p->sense;
596  	backpatch(p, gen_retblk(cstate, 0));
597  	cstate->ic.root = p->head;
598  	return (0);
599  }
600  void
601  gen_and(struct block *b0, struct block *b1)
602  {
603  	backpatch(b0, b1->head);
604  	b0->sense = !b0->sense;
605  	b1->sense = !b1->sense;
606  	merge(b1, b0);
607  	b1->sense = !b1->sense;
608  	b1->head = b0->head;
609  }
610  void
611  gen_or(struct block *b0, struct block *b1)
612  {
613  	b0->sense = !b0->sense;
614  	backpatch(b0, b1->head);
615  	b0->sense = !b0->sense;
616  	merge(b1, b0);
617  	b1->head = b0->head;
618  }
619  void
620  gen_not(struct block *b)
621  {
622  	b->sense = !b->sense;
623  }
624  static struct block *
625  gen_cmp(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,
626      u_int size, bpf_u_int32 v)
627  {
628  	return gen_ncmp(cstate, offrel, offset, size, 0xffffffff, BPF_JEQ, 0, v);
629  }
630  static struct block *
631  gen_cmp_gt(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,
632      u_int size, bpf_u_int32 v)
633  {
634  	return gen_ncmp(cstate, offrel, offset, size, 0xffffffff, BPF_JGT, 0, v);
635  }
636  static struct block *
637  gen_cmp_ge(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,
638      u_int size, bpf_u_int32 v)
639  {
640  	return gen_ncmp(cstate, offrel, offset, size, 0xffffffff, BPF_JGE, 0, v);
641  }
642  static struct block *
643  gen_cmp_lt(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,
644      u_int size, bpf_u_int32 v)
645  {
646  	return gen_ncmp(cstate, offrel, offset, size, 0xffffffff, BPF_JGE, 1, v);
647  }
648  static struct block *
649  gen_cmp_le(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,
650      u_int size, bpf_u_int32 v)
651  {
652  	return gen_ncmp(cstate, offrel, offset, size, 0xffffffff, BPF_JGT, 1, v);
653  }
654  static struct block *
655  gen_mcmp(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,
656      u_int size, bpf_u_int32 v, bpf_u_int32 mask)
657  {
658  	return gen_ncmp(cstate, offrel, offset, size, mask, BPF_JEQ, 0, v);
659  }
660  static struct block *
661  gen_bcmp(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,
662      u_int size, const u_char *v)
663  {
664  	register struct block *b, *tmp;
665  	b = NULL;
666  	while (size >= 4) {
667  		register const u_char *p = &v[size - 4];
668  		tmp = gen_cmp(cstate, offrel, offset + size - 4, BPF_W,
669  		    EXTRACT_BE_U_4(p));
670  		if (b != NULL)
671  			gen_and(b, tmp);
672  		b = tmp;
673  		size -= 4;
674  	}
675  	while (size >= 2) {
676  		register const u_char *p = &v[size - 2];
677  		tmp = gen_cmp(cstate, offrel, offset + size - 2, BPF_H,
678  		    EXTRACT_BE_U_2(p));
679  		if (b != NULL)
680  			gen_and(b, tmp);
681  		b = tmp;
682  		size -= 2;
683  	}
684  	if (size > 0) {
685  		tmp = gen_cmp(cstate, offrel, offset, BPF_B, v[0]);
686  		if (b != NULL)
687  			gen_and(b, tmp);
688  		b = tmp;
689  	}
690  	return b;
691  }
692  static struct block *
693  gen_ncmp(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,
694      u_int size, bpf_u_int32 mask, int jtype, int reverse,
695      bpf_u_int32 v)
696  {
697  	struct slist *s, *s2;
698  	struct block *b;
699  	s = gen_load_a(cstate, offrel, offset, size);
700  	if (mask != 0xffffffff) {
701  		s2 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);
702  		s2->s.k = mask;
703  		sappend(s, s2);
704  	}
705  	b = new_block(cstate, JMP(jtype));
706  	b->stmts = s;
707  	b->s.k = v;
708  	if (reverse && (jtype == BPF_JGT || jtype == BPF_JGE))
709  		gen_not(b);
710  	return b;
711  }
712  static int
713  init_linktype(compiler_state_t *cstate, pcap_t *p)
714  {
715  	cstate->pcap_fddipad = p->fddipad;
716  	cstate->outermostlinktype = pcap_datalink(p);
717  	cstate->off_outermostlinkhdr.constant_part = 0;
718  	cstate->off_outermostlinkhdr.is_variable = 0;
719  	cstate->off_outermostlinkhdr.reg = -1;
720  	cstate->prevlinktype = cstate->outermostlinktype;
721  	cstate->off_prevlinkhdr.constant_part = 0;
722  	cstate->off_prevlinkhdr.is_variable = 0;
723  	cstate->off_prevlinkhdr.reg = -1;
724  	cstate->linktype = cstate->outermostlinktype;
725  	cstate->off_linkhdr.constant_part = 0;
726  	cstate->off_linkhdr.is_variable = 0;
727  	cstate->off_linkhdr.reg = -1;
728  	cstate->off_linkpl.constant_part = 0;
729  	cstate->off_linkpl.is_variable = 0;
730  	cstate->off_linkpl.reg = -1;
731  	cstate->off_linktype.constant_part = 0;
732  	cstate->off_linktype.is_variable = 0;
733  	cstate->off_linktype.reg = -1;
734  	cstate->is_atm = 0;
735  	cstate->off_vpi = OFFSET_NOT_SET;
736  	cstate->off_vci = OFFSET_NOT_SET;
737  	cstate->off_proto = OFFSET_NOT_SET;
738  	cstate->off_payload = OFFSET_NOT_SET;
739  	cstate->is_geneve = 0;
740  	cstate->is_vlan_vloffset = 0;
741  	cstate->off_li = OFFSET_NOT_SET;
742  	cstate->off_li_hsl = OFFSET_NOT_SET;
743  	cstate->off_sio = OFFSET_NOT_SET;
744  	cstate->off_opc = OFFSET_NOT_SET;
745  	cstate->off_dpc = OFFSET_NOT_SET;
746  	cstate->off_sls = OFFSET_NOT_SET;
747  	cstate->label_stack_depth = 0;
748  	cstate->vlan_stack_depth = 0;
749  	switch (cstate->linktype) {
750  	case DLT_ARCNET:
751  		cstate->off_linktype.constant_part = 2;
752  		cstate->off_linkpl.constant_part = 6;
753  		cstate->off_nl = 0;		&bsol;* XXX in reality, variable! */
754  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
755  		break;
756  	case DLT_ARCNET_LINUX:
757  		cstate->off_linktype.constant_part = 4;
758  		cstate->off_linkpl.constant_part = 8;
759  		cstate->off_nl = 0;		&bsol;* XXX in reality, variable! */
760  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
761  		break;
762  	case DLT_EN10MB:
763  		cstate->off_linktype.constant_part = 12;
764  		cstate->off_linkpl.constant_part = 14;	&bsol;* Ethernet header length */
765  		cstate->off_nl = 0;		&bsol;* Ethernet II */
766  		cstate->off_nl_nosnap = 3;	&bsol;* 802.3+802.2 */
767  		break;
768  	case DLT_SLIP:
769  		cstate->off_linktype.constant_part = OFFSET_NOT_SET;
770  		cstate->off_linkpl.constant_part = 16;
771  		cstate->off_nl = 0;
772  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
773  		break;
774  	case DLT_SLIP_BSDOS:
775  		cstate->off_linktype.constant_part = OFFSET_NOT_SET;
776  		cstate->off_linkpl.constant_part = 24;
777  		cstate->off_nl = 0;
778  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
779  		break;
780  	case DLT_NULL:
781  	case DLT_LOOP:
782  		cstate->off_linktype.constant_part = 0;
783  		cstate->off_linkpl.constant_part = 4;
784  		cstate->off_nl = 0;
785  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
786  		break;
787  	case DLT_ENC:
788  		cstate->off_linktype.constant_part = 0;
789  		cstate->off_linkpl.constant_part = 12;
790  		cstate->off_nl = 0;
791  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
792  		break;
793  	case DLT_PPP:
794  	case DLT_PPP_PPPD:
795  	case DLT_C_HDLC:		&bsol;* BSD/OS Cisco HDLC */
796  	case DLT_HDLC:			&bsol;* NetBSD (Cisco) HDLC */
797  	case DLT_PPP_SERIAL:		&bsol;* NetBSD sync/async serial PPP */
798  		cstate->off_linktype.constant_part = 2;	&bsol;* skip HDLC-like framing */
799  		cstate->off_linkpl.constant_part = 4;	&bsol;* skip HDLC-like framing and protocol field */
800  		cstate->off_nl = 0;
801  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
802  		break;
803  	case DLT_PPP_ETHER:
804  		cstate->off_linktype.constant_part = 6;
805  		cstate->off_linkpl.constant_part = 8;
806  		cstate->off_nl = 0;
807  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
808  		break;
809  	case DLT_PPP_BSDOS:
810  		cstate->off_linktype.constant_part = 5;
811  		cstate->off_linkpl.constant_part = 24;
812  		cstate->off_nl = 0;
813  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
814  		break;
815  	case DLT_FDDI:
816  		cstate->off_linktype.constant_part = 13;
817  		cstate->off_linktype.constant_part += cstate->pcap_fddipad;
818  		cstate->off_linkpl.constant_part = 13;	&bsol;* FDDI MAC header length */
819  		cstate->off_linkpl.constant_part += cstate->pcap_fddipad;
820  		cstate->off_nl = 8;		&bsol;* 802.2+SNAP */
821  		cstate->off_nl_nosnap = 3;	&bsol;* 802.2 */
822  		break;
823  	case DLT_IEEE802:
824  		cstate->off_linktype.constant_part = 14;
825  		cstate->off_linkpl.constant_part = 14;	&bsol;* Token Ring MAC header length */
826  		cstate->off_nl = 8;		&bsol;* 802.2+SNAP */
827  		cstate->off_nl_nosnap = 3;	&bsol;* 802.2 */
828  		break;
829  	case DLT_PRISM_HEADER:
830  	case DLT_IEEE802_11_RADIO_AVS:
831  	case DLT_IEEE802_11_RADIO:
832  		cstate->off_linkhdr.is_variable = 1;
833  	case DLT_IEEE802_11:
834  		cstate->off_linktype.constant_part = 24;
835  		cstate->off_linkpl.constant_part = 0;	&bsol;* link-layer header is variable-length */
836  		cstate->off_linkpl.is_variable = 1;
837  		cstate->off_nl = 8;		&bsol;* 802.2+SNAP */
838  		cstate->off_nl_nosnap = 3;	&bsol;* 802.2 */
839  		break;
840  	case DLT_PPI:
841  		cstate->off_linktype.constant_part = 24;
842  		cstate->off_linkpl.constant_part = 0;	&bsol;* link-layer header is variable-length */
843  		cstate->off_linkpl.is_variable = 1;
844  		cstate->off_linkhdr.is_variable = 1;
845  		cstate->off_nl = 8;		&bsol;* 802.2+SNAP */
846  		cstate->off_nl_nosnap = 3;	&bsol;* 802.2 */
847  		break;
848  	case DLT_ATM_RFC1483:
849  	case DLT_ATM_CLIP:	&bsol;* Linux ATM defines this */
850  		cstate->off_linktype.constant_part = 0;
851  		cstate->off_linkpl.constant_part = 0;	&bsol;* packet begins with LLC header */
852  		cstate->off_nl = 8;		&bsol;* 802.2+SNAP */
853  		cstate->off_nl_nosnap = 3;	&bsol;* 802.2 */
854  		break;
855  	case DLT_SUNATM:
856  		cstate->is_atm = 1;
857  		cstate->off_vpi = SUNATM_VPI_POS;
858  		cstate->off_vci = SUNATM_VCI_POS;
859  		cstate->off_proto = PROTO_POS;
860  		cstate->off_payload = SUNATM_PKT_BEGIN_POS;
861  		cstate->off_linktype.constant_part = cstate->off_payload;
862  		cstate->off_linkpl.constant_part = cstate->off_payload;	&bsol;* if LLC-encapsulated */
863  		cstate->off_nl = 8;		&bsol;* 802.2+SNAP */
864  		cstate->off_nl_nosnap = 3;	&bsol;* 802.2 */
865  		break;
866  	case DLT_RAW:
867  	case DLT_IPV4:
868  	case DLT_IPV6:
869  		cstate->off_linktype.constant_part = OFFSET_NOT_SET;
870  		cstate->off_linkpl.constant_part = 0;
871  		cstate->off_nl = 0;
872  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
873  		break;
874  	case DLT_LINUX_SLL:	&bsol;* fake header for Linux cooked socket v1 */
875  		cstate->off_linktype.constant_part = 14;
876  		cstate->off_linkpl.constant_part = 16;
877  		cstate->off_nl = 0;
878  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
879  		break;
880  	case DLT_LINUX_SLL2:	&bsol;* fake header for Linux cooked socket v2 */
881  		cstate->off_linktype.constant_part = 0;
882  		cstate->off_linkpl.constant_part = 20;
883  		cstate->off_nl = 0;
884  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
885  		break;
886  	case DLT_LTALK:
887  		cstate->off_linktype.constant_part = OFFSET_NOT_SET;
888  		cstate->off_linkpl.constant_part = 0;
889  		cstate->off_nl = 0;
890  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
891  		break;
892  	case DLT_IP_OVER_FC:
893  		cstate->off_linktype.constant_part = 16;
894  		cstate->off_linkpl.constant_part = 16;
895  		cstate->off_nl = 8;		&bsol;* 802.2+SNAP */
896  		cstate->off_nl_nosnap = 3;	&bsol;* 802.2 */
897  		break;
898  	case DLT_FRELAY:
899  		cstate->off_linktype.constant_part = OFFSET_NOT_SET;
900  		cstate->off_linkpl.constant_part = 0;
901  		cstate->off_nl = 0;
902  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
903  		break;
904  	case DLT_MFR:
905  		cstate->off_linktype.constant_part = OFFSET_NOT_SET;
906  		cstate->off_linkpl.constant_part = 0;
907  		cstate->off_nl = 4;
908  		cstate->off_nl_nosnap = 0;	&bsol;* XXX - for now -> no 802.2 LLC */
909  		break;
910  	case DLT_APPLE_IP_OVER_IEEE1394:
911  		cstate->off_linktype.constant_part = 16;
912  		cstate->off_linkpl.constant_part = 18;
913  		cstate->off_nl = 0;
914  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
915  		break;
916  	case DLT_SYMANTEC_FIREWALL:
917  		cstate->off_linktype.constant_part = 6;
918  		cstate->off_linkpl.constant_part = 44;
919  		cstate->off_nl = 0;		&bsol;* Ethernet II */
920  		cstate->off_nl_nosnap = 0;	&bsol;* XXX - what does it do with 802.3 packets? */
921  		break;
922  	case DLT_PFLOG:
923  		cstate->off_linktype.constant_part = 0;
924  		cstate->off_linkpl.constant_part = 0;	&bsol;* link-layer header is variable-length */
925  		cstate->off_linkpl.is_variable = 1;
926  		cstate->off_nl = 0;
927  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
928  		break;
929          case DLT_JUNIPER_MFR:
930          case DLT_JUNIPER_MLFR:
931          case DLT_JUNIPER_MLPPP:
932          case DLT_JUNIPER_PPP:
933          case DLT_JUNIPER_CHDLC:
934          case DLT_JUNIPER_FRELAY:
935  		cstate->off_linktype.constant_part = 4;
936  		cstate->off_linkpl.constant_part = 4;
937  		cstate->off_nl = 0;
938  		cstate->off_nl_nosnap = OFFSET_NOT_SET;	&bsol;* no 802.2 LLC */
939                  break;
940  	case DLT_JUNIPER_ATM1:
941  		cstate->off_linktype.constant_part = 4;		&bsol;* in reality variable between 4-8 */
942  		cstate->off_linkpl.constant_part = 4;	&bsol;* in reality variable between 4-8 */
943  		cstate->off_nl = 0;
944  		cstate->off_nl_nosnap = 10;
945  		break;
946  	case DLT_JUNIPER_ATM2:
947  		cstate->off_linktype.constant_part = 8;		&bsol;* in reality variable between 8-12 */
948  		cstate->off_linkpl.constant_part = 8;	&bsol;* in reality variable between 8-12 */
949  		cstate->off_nl = 0;
950  		cstate->off_nl_nosnap = 10;
951  		break;
952  	case DLT_JUNIPER_PPPOE:
953          case DLT_JUNIPER_ETHER:
954  		cstate->off_linkpl.constant_part = 14;
955  		cstate->off_linktype.constant_part = 16;
956  		cstate->off_nl = 18;		&bsol;* Ethernet II */
957  		cstate->off_nl_nosnap = 21;	&bsol;* 802.3+802.2 */
958  		break;
959  	case DLT_JUNIPER_PPPOE_ATM:
960  		cstate->off_linktype.constant_part = 4;
961  		cstate->off_linkpl.constant_part = 6;
962  		cstate->off_nl = 0;
963  		cstate->off_nl_nosnap = OFFSET_NOT_SET;	&bsol;* no 802.2 LLC */
964  		break;
965  	case DLT_JUNIPER_GGSN:
966  		cstate->off_linktype.constant_part = 6;
967  		cstate->off_linkpl.constant_part = 12;
968  		cstate->off_nl = 0;
969  		cstate->off_nl_nosnap = OFFSET_NOT_SET;	&bsol;* no 802.2 LLC */
970  		break;
971  	case DLT_JUNIPER_ES:
972  		cstate->off_linktype.constant_part = 6;
973  		cstate->off_linkpl.constant_part = OFFSET_NOT_SET;	&bsol;* not really a network layer but raw IP addresses */
974  		cstate->off_nl = OFFSET_NOT_SET;	&bsol;* not really a network layer but raw IP addresses */
975  		cstate->off_nl_nosnap = OFFSET_NOT_SET;	&bsol;* no 802.2 LLC */
976  		break;
977  	case DLT_JUNIPER_MONITOR:
978  		cstate->off_linktype.constant_part = 12;
979  		cstate->off_linkpl.constant_part = 12;
980  		cstate->off_nl = 0;			&bsol;* raw IP/IP6 header */
981  		cstate->off_nl_nosnap = OFFSET_NOT_SET;	&bsol;* no 802.2 LLC */
982  		break;
983  	case DLT_BACNET_MS_TP:
984  		cstate->off_linktype.constant_part = OFFSET_NOT_SET;
985  		cstate->off_linkpl.constant_part = OFFSET_NOT_SET;
986  		cstate->off_nl = OFFSET_NOT_SET;
987  		cstate->off_nl_nosnap = OFFSET_NOT_SET;
988  		break;
989  	case DLT_JUNIPER_SERVICES:
990  		cstate->off_linktype.constant_part = 12;
991  		cstate->off_linkpl.constant_part = OFFSET_NOT_SET;	&bsol;* L3 proto location dep. on cookie type */
992  		cstate->off_nl = OFFSET_NOT_SET;	&bsol;* L3 proto location dep. on cookie type */
993  		cstate->off_nl_nosnap = OFFSET_NOT_SET;	&bsol;* no 802.2 LLC */
994  		break;
995  	case DLT_JUNIPER_VP:
996  		cstate->off_linktype.constant_part = 18;
997  		cstate->off_linkpl.constant_part = OFFSET_NOT_SET;
998  		cstate->off_nl = OFFSET_NOT_SET;
999  		cstate->off_nl_nosnap = OFFSET_NOT_SET;
1000  		break;
1001  	case DLT_JUNIPER_ST:
1002  		cstate->off_linktype.constant_part = 18;
1003  		cstate->off_linkpl.constant_part = OFFSET_NOT_SET;
1004  		cstate->off_nl = OFFSET_NOT_SET;
1005  		cstate->off_nl_nosnap = OFFSET_NOT_SET;
1006  		break;
1007  	case DLT_JUNIPER_ISM:
1008  		cstate->off_linktype.constant_part = 8;
1009  		cstate->off_linkpl.constant_part = OFFSET_NOT_SET;
1010  		cstate->off_nl = OFFSET_NOT_SET;
1011  		cstate->off_nl_nosnap = OFFSET_NOT_SET;
1012  		break;
1013  	case DLT_JUNIPER_VS:
1014  	case DLT_JUNIPER_SRX_E2E:
1015  	case DLT_JUNIPER_FIBRECHANNEL:
1016  	case DLT_JUNIPER_ATM_CEMIC:
1017  		cstate->off_linktype.constant_part = 8;
1018  		cstate->off_linkpl.constant_part = OFFSET_NOT_SET;
1019  		cstate->off_nl = OFFSET_NOT_SET;
1020  		cstate->off_nl_nosnap = OFFSET_NOT_SET;
1021  		break;
1022  	case DLT_MTP2:
1023  		cstate->off_li = 2;
1024  		cstate->off_li_hsl = 4;
1025  		cstate->off_sio = 3;
1026  		cstate->off_opc = 4;
1027  		cstate->off_dpc = 4;
1028  		cstate->off_sls = 7;
1029  		cstate->off_linktype.constant_part = OFFSET_NOT_SET;
1030  		cstate->off_linkpl.constant_part = OFFSET_NOT_SET;
1031  		cstate->off_nl = OFFSET_NOT_SET;
1032  		cstate->off_nl_nosnap = OFFSET_NOT_SET;
1033  		break;
1034  	case DLT_MTP2_WITH_PHDR:
1035  		cstate->off_li = 6;
1036  		cstate->off_li_hsl = 8;
1037  		cstate->off_sio = 7;
1038  		cstate->off_opc = 8;
1039  		cstate->off_dpc = 8;
1040  		cstate->off_sls = 11;
1041  		cstate->off_linktype.constant_part = OFFSET_NOT_SET;
1042  		cstate->off_linkpl.constant_part = OFFSET_NOT_SET;
1043  		cstate->off_nl = OFFSET_NOT_SET;
1044  		cstate->off_nl_nosnap = OFFSET_NOT_SET;
1045  		break;
1046  	case DLT_ERF:
1047  		cstate->off_li = 22;
1048  		cstate->off_li_hsl = 24;
1049  		cstate->off_sio = 23;
1050  		cstate->off_opc = 24;
1051  		cstate->off_dpc = 24;
1052  		cstate->off_sls = 27;
1053  		cstate->off_linktype.constant_part = OFFSET_NOT_SET;
1054  		cstate->off_linkpl.constant_part = OFFSET_NOT_SET;
1055  		cstate->off_nl = OFFSET_NOT_SET;
1056  		cstate->off_nl_nosnap = OFFSET_NOT_SET;
1057  		break;
1058  	case DLT_PFSYNC:
1059  		cstate->off_linktype.constant_part = OFFSET_NOT_SET;
1060  		cstate->off_linkpl.constant_part = 4;
1061  		cstate->off_nl = 0;
1062  		cstate->off_nl_nosnap = 0;
1063  		break;
1064  	case DLT_AX25_KISS:
1065  		cstate->off_linktype.constant_part = OFFSET_NOT_SET;	&bsol;* variable, min 15, max 71 steps of 7 */
1066  		cstate->off_linkpl.constant_part = OFFSET_NOT_SET;
1067  		cstate->off_nl = OFFSET_NOT_SET;	&bsol;* variable, min 16, max 71 steps of 7 */
1068  		cstate->off_nl_nosnap = OFFSET_NOT_SET;	&bsol;* no 802.2 LLC */
1069  		break;
1070  	case DLT_IPNET:
1071  		cstate->off_linktype.constant_part = 1;
1072  		cstate->off_linkpl.constant_part = 24;	&bsol;* ipnet header length */
1073  		cstate->off_nl = 0;
1074  		cstate->off_nl_nosnap = OFFSET_NOT_SET;
1075  		break;
1076  	case DLT_NETANALYZER:
1077  		cstate->off_linkhdr.constant_part = 4;	&bsol;* Ethernet header is past 4-byte pseudo-header */
1078  		cstate->off_linktype.constant_part = cstate->off_linkhdr.constant_part + 12;
1079  		cstate->off_linkpl.constant_part = cstate->off_linkhdr.constant_part + 14;	&bsol;* pseudo-header+Ethernet header length */
1080  		cstate->off_nl = 0;		&bsol;* Ethernet II */
1081  		cstate->off_nl_nosnap = 3;	&bsol;* 802.3+802.2 */
1082  		break;
1083  	case DLT_NETANALYZER_TRANSPARENT:
1084  		cstate->off_linkhdr.constant_part = 12;	&bsol;* MAC header is past 4-byte pseudo-header, preamble, and SFD */
1085  		cstate->off_linktype.constant_part = cstate->off_linkhdr.constant_part + 12;
1086  		cstate->off_linkpl.constant_part = cstate->off_linkhdr.constant_part + 14;	&bsol;* pseudo-header+preamble+SFD+Ethernet header length */
1087  		cstate->off_nl = 0;		&bsol;* Ethernet II */
1088  		cstate->off_nl_nosnap = 3;	&bsol;* 802.3+802.2 */
1089  		break;
1090  	default:
1091  		if (cstate->linktype >= DLT_MATCHING_MIN &&
1092  		    cstate->linktype <= DLT_MATCHING_MAX) {
1093  			cstate->off_linktype.constant_part = OFFSET_NOT_SET;
1094  			cstate->off_linkpl.constant_part = OFFSET_NOT_SET;
1095  			cstate->off_nl = OFFSET_NOT_SET;
1096  			cstate->off_nl_nosnap = OFFSET_NOT_SET;
1097  		} else {
1098  			bpf_set_error(cstate, "unknown data link type %d (min %d, max %d)",
1099  			    cstate->linktype, DLT_MATCHING_MIN, DLT_MATCHING_MAX);
1100  			return (-1);
1101  		}
1102  		break;
1103  	}
1104  	cstate->off_outermostlinkhdr = cstate->off_prevlinkhdr = cstate->off_linkhdr;
1105  	return (0);
1106  }
1107  static struct slist *
1108  gen_load_absoffsetrel(compiler_state_t *cstate, bpf_abs_offset *abs_offset,
1109      u_int offset, u_int size)
1110  {
1111  	struct slist *s, *s2;
1112  	s = gen_abs_offset_varpart(cstate, abs_offset);
1113  	if (s != NULL) {
1114  		s2 = new_stmt(cstate, BPF_LD|BPF_IND|size);
1115  		s2->s.k = abs_offset->constant_part + offset;
1116  		sappend(s, s2);
1117  	} else {
1118  		s = new_stmt(cstate, BPF_LD|BPF_ABS|size);
1119  		s->s.k = abs_offset->constant_part + offset;
1120  	}
1121  	return s;
1122  }
1123  static struct slist *
1124  gen_load_a(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,
1125      u_int size)
1126  {
1127  	struct slist *s, *s2;
1128  	s = NULL;
1129  	switch (offrel) {
1130  	case OR_PACKET:
1131                  s = new_stmt(cstate, BPF_LD|BPF_ABS|size);
1132                  s->s.k = offset;
1133  		break;
1134  	case OR_LINKHDR:
1135  		s = gen_load_absoffsetrel(cstate, &cstate->off_linkhdr, offset, size);
1136  		break;
1137  	case OR_PREVLINKHDR:
1138  		s = gen_load_absoffsetrel(cstate, &cstate->off_prevlinkhdr, offset, size);
1139  		break;
1140  	case OR_LLC:
1141  		s = gen_load_absoffsetrel(cstate, &cstate->off_linkpl, offset, size);
1142  		break;
1143  	case OR_PREVMPLSHDR:
1144  		s = gen_load_absoffsetrel(cstate, &cstate->off_linkpl, cstate->off_nl - 4 + offset, size);
1145  		break;
1146  	case OR_LINKPL:
1147  		s = gen_load_absoffsetrel(cstate, &cstate->off_linkpl, cstate->off_nl + offset, size);
1148  		break;
1149  	case OR_LINKPL_NOSNAP:
1150  		s = gen_load_absoffsetrel(cstate, &cstate->off_linkpl, cstate->off_nl_nosnap + offset, size);
1151  		break;
1152  	case OR_LINKTYPE:
1153  		s = gen_load_absoffsetrel(cstate, &cstate->off_linktype, offset, size);
1154  		break;
1155  	case OR_TRAN_IPV4:
1156  		s = gen_loadx_iphdrlen(cstate);
1157  		s2 = new_stmt(cstate, BPF_LD|BPF_IND|size);
1158  		s2->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + offset;
1159  		sappend(s, s2);
1160  		break;
1161  	case OR_TRAN_IPV6:
1162  		s = gen_load_absoffsetrel(cstate, &cstate->off_linkpl, cstate->off_nl + 40 + offset, size);
1163  		break;
1164  	}
1165  	return s;
1166  }
1167  static struct slist *
1168  gen_loadx_iphdrlen(compiler_state_t *cstate)
1169  {
1170  	struct slist *s, *s2;
1171  	s = gen_abs_offset_varpart(cstate, &cstate->off_linkpl);
1172  	if (s != NULL) {
1173  		s2 = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);
1174  		s2->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;
1175  		sappend(s, s2);
1176  		s2 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);
1177  		s2->s.k = 0xf;
1178  		sappend(s, s2);
1179  		s2 = new_stmt(cstate, BPF_ALU|BPF_LSH|BPF_K);
1180  		s2->s.k = 2;
1181  		sappend(s, s2);
1182  		sappend(s, new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X));
1183  		sappend(s, new_stmt(cstate, BPF_MISC|BPF_TAX));
1184  	} else {
1185  		s = new_stmt(cstate, BPF_LDX|BPF_MSH|BPF_B);
1186  		s->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;
1187  	}
1188  	return s;
1189  }
1190  static struct block *
1191  gen_uncond(compiler_state_t *cstate, int rsense)
1192  {
1193  	struct block *b;
1194  	struct slist *s;
1195  	s = new_stmt(cstate, BPF_LD|BPF_IMM);
1196  	s->s.k = !rsense;
1197  	b = new_block(cstate, JMP(BPF_JEQ));
1198  	b->stmts = s;
1199  	return b;
1200  }
1201  static inline struct block *
1202  gen_true(compiler_state_t *cstate)
1203  {
1204  	return gen_uncond(cstate, 1);
1205  }
1206  static inline struct block *
1207  gen_false(compiler_state_t *cstate)
1208  {
1209  	return gen_uncond(cstate, 0);
1210  }
1211  #define	SWAPLONG(y) \
1212  ((((y)&0xff)<<24) | (((y)&0xff00)<<8) | (((y)&0xff0000)>>8) | (((y)>>24)&0xff))
1213  static struct block *
1214  gen_ether_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)
1215  {
1216  	struct block *b0, *b1;
1217  	switch (ll_proto) {
1218  	case LLCSAP_ISONS:
1219  	case LLCSAP_IP:
1220  	case LLCSAP_NETBEUI:
1221  		b0 = gen_cmp_gt(cstate, OR_LINKTYPE, 0, BPF_H, ETHERMTU);
1222  		gen_not(b0);
1223  		b1 = gen_cmp(cstate, OR_LLC, 0, BPF_H, (ll_proto << 8) | ll_proto);
1224  		gen_and(b0, b1);
1225  		return b1;
1226  	case LLCSAP_IPX:
1227  		b0 = gen_cmp(cstate, OR_LLC, 0, BPF_B, LLCSAP_IPX);
1228  		b1 = gen_cmp(cstate, OR_LLC, 0, BPF_H, 0xFFFF);
1229  		gen_or(b0, b1);
1230  		b0 = gen_snap(cstate, 0x000000, ETHERTYPE_IPX);
1231  		gen_or(b0, b1);
1232  		b0 = gen_cmp_gt(cstate, OR_LINKTYPE, 0, BPF_H, ETHERMTU);
1233  		gen_not(b0);
1234  		gen_and(b0, b1);
1235  		b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ETHERTYPE_IPX);
1236  		gen_or(b0, b1);
1237  		return b1;
1238  	case ETHERTYPE_ATALK:
1239  	case ETHERTYPE_AARP:
1240  		b0 = gen_cmp_gt(cstate, OR_LINKTYPE, 0, BPF_H, ETHERMTU);
1241  		gen_not(b0);
1242  		if (ll_proto == ETHERTYPE_ATALK)
1243  			b1 = gen_snap(cstate, 0x080007, ETHERTYPE_ATALK);
1244  		else	&bsol;* ll_proto == ETHERTYPE_AARP */
1245  			b1 = gen_snap(cstate, 0x000000, ETHERTYPE_AARP);
1246  		gen_and(b0, b1);
1247  		b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ll_proto);
1248  		gen_or(b0, b1);
1249  		return b1;
1250  	default:
1251  		if (ll_proto <= ETHERMTU) {
1252  			b0 = gen_cmp_gt(cstate, OR_LINKTYPE, 0, BPF_H, ETHERMTU);
1253  			gen_not(b0);
1254  			b1 = gen_cmp(cstate, OR_LINKTYPE, 2, BPF_B, ll_proto);
1255  			gen_and(b0, b1);
1256  			return b1;
1257  		} else {
1258  			return gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ll_proto);
1259  		}
1260  	}
1261  }
1262  static struct block *
1263  gen_loopback_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)
1264  {
1265  	if (cstate->linktype == DLT_NULL || cstate->linktype == DLT_ENC) {
1266  		if (cstate->bpf_pcap->rfile != NULL && cstate->bpf_pcap->swapped)
1267  			ll_proto = SWAPLONG(ll_proto);
1268  		ll_proto = htonl(ll_proto);
1269  	}
1270  	return (gen_cmp(cstate, OR_LINKHDR, 0, BPF_W, ll_proto));
1271  }
1272  static struct block *
1273  gen_ipnet_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)
1274  {
1275  	switch (ll_proto) {
1276  	case ETHERTYPE_IP:
1277  		return gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B, IPH_AF_INET);
1278  	case ETHERTYPE_IPV6:
1279  		return gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B, IPH_AF_INET6);
1280  	default:
1281  		break;
1282  	}
1283  	return gen_false(cstate);
1284  }
1285  static struct block *
1286  gen_linux_sll_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)
1287  {
1288  	struct block *b0, *b1;
1289  	switch (ll_proto) {
1290  	case LLCSAP_ISONS:
1291  	case LLCSAP_IP:
1292  	case LLCSAP_NETBEUI:
1293  		b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, LINUX_SLL_P_802_2);
1294  		b1 = gen_cmp(cstate, OR_LLC, 0, BPF_H, (ll_proto << 8) | ll_proto);
1295  		gen_and(b0, b1);
1296  		return b1;
1297  	case LLCSAP_IPX:
1298  		b0 = gen_cmp(cstate, OR_LLC, 0, BPF_B, LLCSAP_IPX);
1299  		b1 = gen_snap(cstate, 0x000000, ETHERTYPE_IPX);
1300  		gen_or(b0, b1);
1301  		b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, LINUX_SLL_P_802_2);
1302  		gen_and(b0, b1);
1303  		b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, LINUX_SLL_P_802_3);
1304  		gen_or(b0, b1);
1305  		b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ETHERTYPE_IPX);
1306  		gen_or(b0, b1);
1307  		return b1;
1308  	case ETHERTYPE_ATALK:
1309  	case ETHERTYPE_AARP:
1310  		b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, LINUX_SLL_P_802_2);
1311  		if (ll_proto == ETHERTYPE_ATALK)
1312  			b1 = gen_snap(cstate, 0x080007, ETHERTYPE_ATALK);
1313  		else	&bsol;* ll_proto == ETHERTYPE_AARP */
1314  			b1 = gen_snap(cstate, 0x000000, ETHERTYPE_AARP);
1315  		gen_and(b0, b1);
1316  		b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ll_proto);
1317  		gen_or(b0, b1);
1318  		return b1;
1319  	default:
1320  		if (ll_proto <= ETHERMTU) {
1321  			b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, LINUX_SLL_P_802_2);
1322  			b1 = gen_cmp(cstate, OR_LINKHDR, cstate->off_linkpl.constant_part, BPF_B,
1323  			     ll_proto);
1324  			gen_and(b0, b1);
1325  			return b1;
1326  		} else {
1327  			return gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ll_proto);
1328  		}
1329  	}
1330  }
1331  static struct slist *
1332  gen_load_pflog_llprefixlen(compiler_state_t *cstate)
1333  {
1334  	struct slist *s1, *s2;
1335  	if (cstate->off_linkpl.reg != -1) {
1336  		s1 = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);
1337  		s1->s.k = 0;
1338  		s2 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);
1339  		s2->s.k = 3;
1340  		sappend(s1, s2);
1341  		s2 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);
1342  		s2->s.k = 0xfffffffc;
1343  		sappend(s1, s2);
1344  		s2 = new_stmt(cstate, BPF_ST);
1345  		s2->s.k = cstate->off_linkpl.reg;
1346  		sappend(s1, s2);
1347  		s2 = new_stmt(cstate, BPF_MISC|BPF_TAX);
1348  		sappend(s1, s2);
1349  		return (s1);
1350  	} else
1351  		return (NULL);
1352  }
1353  static struct slist *
1354  gen_load_prism_llprefixlen(compiler_state_t *cstate)
1355  {
1356  	struct slist *s1, *s2;
1357  	struct slist *sjeq_avs_cookie;
1358  	struct slist *sjcommon;
1359  	cstate->no_optimize = 1;
1360  	if (cstate->off_linkhdr.reg != -1) {
1361  		s1 = new_stmt(cstate, BPF_LD|BPF_W|BPF_ABS);
1362  		s1->s.k = 0;
1363  		s2 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);
1364  		s2->s.k = 0xFFFFF000;
1365  		sappend(s1, s2);
1366  		sjeq_avs_cookie = new_stmt(cstate, JMP(BPF_JEQ));
1367  		sjeq_avs_cookie->s.k = 0x80211000;
1368  		sappend(s1, sjeq_avs_cookie);
1369  		s2 = new_stmt(cstate, BPF_LD|BPF_W|BPF_ABS);
1370  		s2->s.k = 4;
1371  		sappend(s1, s2);
1372  		sjeq_avs_cookie->s.jt = s2;
1373  		sjcommon = new_stmt(cstate, JMP(BPF_JA));
1374  		sjcommon->s.k = 1;
1375  		sappend(s1, sjcommon);
1376  		s2 = new_stmt(cstate, BPF_LD|BPF_W|BPF_IMM);
1377  		s2->s.k = 144;
1378  		sappend(s1, s2);
1379  		sjeq_avs_cookie->s.jf = s2;
1380  		s2 = new_stmt(cstate, BPF_ST);
1381  		s2->s.k = cstate->off_linkhdr.reg;
1382  		sappend(s1, s2);
1383  		sjcommon->s.jf = s2;
1384  		s2 = new_stmt(cstate, BPF_MISC|BPF_TAX);
1385  		sappend(s1, s2);
1386  		return (s1);
1387  	} else
1388  		return (NULL);
1389  }
1390  static struct slist *
1391  gen_load_avs_llprefixlen(compiler_state_t *cstate)
1392  {
1393  	struct slist *s1, *s2;
1394  	if (cstate->off_linkhdr.reg != -1) {
1395  		s1 = new_stmt(cstate, BPF_LD|BPF_W|BPF_ABS);
1396  		s1->s.k = 4;
1397  		s2 = new_stmt(cstate, BPF_ST);
1398  		s2->s.k = cstate->off_linkhdr.reg;
1399  		sappend(s1, s2);
1400  		s2 = new_stmt(cstate, BPF_MISC|BPF_TAX);
1401  		sappend(s1, s2);
1402  		return (s1);
1403  	} else
1404  		return (NULL);
1405  }
1406  static struct slist *
1407  gen_load_radiotap_llprefixlen(compiler_state_t *cstate)
1408  {
1409  	struct slist *s1, *s2;
1410  	if (cstate->off_linkhdr.reg != -1) {
1411  		s1 = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);
1412  		s1->s.k = 3;
1413  		s2 = new_stmt(cstate, BPF_ALU|BPF_LSH|BPF_K);
1414  		sappend(s1, s2);
1415  		s2->s.k = 8;
1416  		s2 = new_stmt(cstate, BPF_MISC|BPF_TAX);
1417  		sappend(s1, s2);
1418  		s2 = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);
1419  		sappend(s1, s2);
1420  		s2->s.k = 2;
1421  		s2 = new_stmt(cstate, BPF_ALU|BPF_OR|BPF_X);
1422  		sappend(s1, s2);
1423  		s2 = new_stmt(cstate, BPF_ST);
1424  		s2->s.k = cstate->off_linkhdr.reg;
1425  		sappend(s1, s2);
1426  		s2 = new_stmt(cstate, BPF_MISC|BPF_TAX);
1427  		sappend(s1, s2);
1428  		return (s1);
1429  	} else
1430  		return (NULL);
1431  }
1432  static struct slist *
1433  gen_load_ppi_llprefixlen(compiler_state_t *cstate)
1434  {
1435  	struct slist *s1, *s2;
1436  	if (cstate->off_linkhdr.reg != -1) {
1437  		s1 = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);
1438  		s1->s.k = 3;
1439  		s2 = new_stmt(cstate, BPF_ALU|BPF_LSH|BPF_K);
1440  		sappend(s1, s2);
1441  		s2->s.k = 8;
1442  		s2 = new_stmt(cstate, BPF_MISC|BPF_TAX);
1443  		sappend(s1, s2);
1444  		s2 = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);
1445  		sappend(s1, s2);
1446  		s2->s.k = 2;
1447  		s2 = new_stmt(cstate, BPF_ALU|BPF_OR|BPF_X);
1448  		sappend(s1, s2);
1449  		s2 = new_stmt(cstate, BPF_ST);
1450  		s2->s.k = cstate->off_linkhdr.reg;
1451  		sappend(s1, s2);
1452  		s2 = new_stmt(cstate, BPF_MISC|BPF_TAX);
1453  		sappend(s1, s2);
1454  		return (s1);
1455  	} else
1456  		return (NULL);
1457  }
1458  static struct slist *
1459  gen_load_802_11_header_len(compiler_state_t *cstate, struct slist *s, struct slist *snext)
1460  {
1461  	struct slist *s2;
1462  	struct slist *sjset_data_frame_1;
1463  	struct slist *sjset_data_frame_2;
1464  	struct slist *sjset_qos;
1465  	struct slist *sjset_radiotap_flags_present;
1466  	struct slist *sjset_radiotap_ext_present;
1467  	struct slist *sjset_radiotap_tsft_present;
1468  	struct slist *sjset_tsft_datapad, *sjset_notsft_datapad;
1469  	struct slist *s_roundup;
1470  	if (cstate->off_linkpl.reg == -1) {
1471  		return (s);
1472  	}
1473  	cstate->no_optimize = 1;
1474  	if (s == NULL) {
1475  		s = new_stmt(cstate, BPF_LDX|BPF_IMM);
1476  		s->s.k = cstate->off_outermostlinkhdr.constant_part;
1477  	}
1478  	s2 = new_stmt(cstate, BPF_MISC|BPF_TXA);
1479  	sappend(s, s2);
1480  	s2 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);
1481  	s2->s.k = 24;
1482  	sappend(s, s2);
1483  	s2 = new_stmt(cstate, BPF_ST);
1484  	s2->s.k = cstate->off_linkpl.reg;
1485  	sappend(s, s2);
1486  	s2 = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);
1487  	s2->s.k = 0;
1488  	sappend(s, s2);
1489  	sjset_data_frame_1 = new_stmt(cstate, JMP(BPF_JSET));
1490  	sjset_data_frame_1->s.k = 0x08;
1491  	sappend(s, sjset_data_frame_1);
1492  	sjset_data_frame_1->s.jt = sjset_data_frame_2 = new_stmt(cstate, JMP(BPF_JSET));
1493  	sjset_data_frame_2->s.k = 0x04;
1494  	sappend(s, sjset_data_frame_2);
1495  	sjset_data_frame_1->s.jf = snext;
1496  	sjset_data_frame_2->s.jt = snext;
1497  	sjset_data_frame_2->s.jf = sjset_qos = new_stmt(cstate, JMP(BPF_JSET));
1498  	sjset_qos->s.k = 0x80;	&bsol;* QoS bit */
1499  	sappend(s, sjset_qos);
1500  	sjset_qos->s.jt = s2 = new_stmt(cstate, BPF_LD|BPF_MEM);
1501  	s2->s.k = cstate->off_linkpl.reg;
1502  	sappend(s, s2);
1503  	s2 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_IMM);
1504  	s2->s.k = 2;
1505  	sappend(s, s2);
1506  	s2 = new_stmt(cstate, BPF_ST);
1507  	s2->s.k = cstate->off_linkpl.reg;
1508  	sappend(s, s2);
1509  	if (cstate->linktype == DLT_IEEE802_11_RADIO) {
1510  		sjset_qos->s.jf = s2 = new_stmt(cstate, BPF_LD|BPF_ABS|BPF_W);
1511  		s2->s.k = 4;
1512  		sappend(s, s2);
1513  		sjset_radiotap_flags_present = new_stmt(cstate, JMP(BPF_JSET));
1514  		sjset_radiotap_flags_present->s.k = SWAPLONG(0x00000002);
1515  		sappend(s, sjset_radiotap_flags_present);
1516  		sjset_radiotap_flags_present->s.jf = snext;
1517  		sjset_radiotap_ext_present = new_stmt(cstate, JMP(BPF_JSET));
1518  		sjset_radiotap_ext_present->s.k = SWAPLONG(0x80000000);
1519  		sappend(s, sjset_radiotap_ext_present);
1520  		sjset_radiotap_flags_present->s.jt = sjset_radiotap_ext_present;
1521  		sjset_radiotap_ext_present->s.jt = snext;
1522  		sjset_radiotap_tsft_present = new_stmt(cstate, JMP(BPF_JSET));
1523  		sjset_radiotap_tsft_present->s.k = SWAPLONG(0x00000001);
1524  		sappend(s, sjset_radiotap_tsft_present);
1525  		sjset_radiotap_ext_present->s.jf = sjset_radiotap_tsft_present;
1526  		s2 = new_stmt(cstate, BPF_LD|BPF_ABS|BPF_B);
1527  		s2->s.k = 16;
1528  		sappend(s, s2);
1529  		sjset_radiotap_tsft_present->s.jt = s2;
1530  		sjset_tsft_datapad = new_stmt(cstate, JMP(BPF_JSET));
1531  		sjset_tsft_datapad->s.k = 0x20;
1532  		sappend(s, sjset_tsft_datapad);
1533  		s2 = new_stmt(cstate, BPF_LD|BPF_ABS|BPF_B);
1534  		s2->s.k = 8;
1535  		sappend(s, s2);
1536  		sjset_radiotap_tsft_present->s.jf = s2;
1537  		sjset_notsft_datapad = new_stmt(cstate, JMP(BPF_JSET));
1538  		sjset_notsft_datapad->s.k = 0x20;
1539  		sappend(s, sjset_notsft_datapad);
1540  		s_roundup = new_stmt(cstate, BPF_LD|BPF_MEM);
1541  		s_roundup->s.k = cstate->off_linkpl.reg;
1542  		sappend(s, s_roundup);
1543  		s2 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_IMM);
1544  		s2->s.k = 3;
1545  		sappend(s, s2);
1546  		s2 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_IMM);
1547  		s2->s.k = (bpf_u_int32)~3;
1548  		sappend(s, s2);
1549  		s2 = new_stmt(cstate, BPF_ST);
1550  		s2->s.k = cstate->off_linkpl.reg;
1551  		sappend(s, s2);
1552  		sjset_tsft_datapad->s.jt = s_roundup;
1553  		sjset_tsft_datapad->s.jf = snext;
1554  		sjset_notsft_datapad->s.jt = s_roundup;
1555  		sjset_notsft_datapad->s.jf = snext;
1556  	} else
1557  		sjset_qos->s.jf = snext;
1558  	return s;
1559  }
1560  static void
1561  insert_compute_vloffsets(compiler_state_t *cstate, struct block *b)
1562  {
1563  	struct slist *s;
1564  	if (cstate->off_linkpl.reg != -1 && cstate->off_linkhdr.is_variable &&
1565  	    cstate->off_linkhdr.reg == -1)
1566  		cstate->off_linkhdr.reg = alloc_reg(cstate);
1567  	switch (cstate->outermostlinktype) {
1568  	case DLT_PRISM_HEADER:
1569  		s = gen_load_prism_llprefixlen(cstate);
1570  		break;
1571  	case DLT_IEEE802_11_RADIO_AVS:
1572  		s = gen_load_avs_llprefixlen(cstate);
1573  		break;
1574  	case DLT_IEEE802_11_RADIO:
1575  		s = gen_load_radiotap_llprefixlen(cstate);
1576  		break;
1577  	case DLT_PPI:
1578  		s = gen_load_ppi_llprefixlen(cstate);
1579  		break;
1580  	default:
1581  		s = NULL;
1582  		break;
1583  	}
1584  	switch (cstate->outermostlinktype) {
1585  	case DLT_IEEE802_11:
1586  	case DLT_PRISM_HEADER:
1587  	case DLT_IEEE802_11_RADIO_AVS:
1588  	case DLT_IEEE802_11_RADIO:
1589  	case DLT_PPI:
1590  		s = gen_load_802_11_header_len(cstate, s, b->stmts);
1591  		break;
1592  	case DLT_PFLOG:
1593  		s = gen_load_pflog_llprefixlen(cstate);
1594  		break;
1595  	}
1596  	if (s == NULL && cstate->is_vlan_vloffset) {
1597  		struct slist *s2;
1598  		if (cstate->off_linkpl.reg == -1)
1599  			cstate->off_linkpl.reg = alloc_reg(cstate);
1600  		if (cstate->off_linktype.reg == -1)
1601  			cstate->off_linktype.reg = alloc_reg(cstate);
1602  		s = new_stmt(cstate, BPF_LD|BPF_W|BPF_IMM);
1603  		s->s.k = 0;
1604  		s2 = new_stmt(cstate, BPF_ST);
1605  		s2->s.k = cstate->off_linkpl.reg;
1606  		sappend(s, s2);
1607  		s2 = new_stmt(cstate, BPF_ST);
1608  		s2->s.k = cstate->off_linktype.reg;
1609  		sappend(s, s2);
1610  	}
1611  	if (s != NULL) {
1612  		sappend(s, b->stmts);
1613  		b->stmts = s;
1614  	}
1615  }
1616  static struct block *
1617  gen_ppi_dlt_check(compiler_state_t *cstate)
1618  {
1619  	struct slist *s_load_dlt;
1620  	struct block *b;
1621  	if (cstate->linktype == DLT_PPI)
1622  	{
1623  		s_load_dlt = new_stmt(cstate, BPF_LD|BPF_W|BPF_ABS);
1624  		s_load_dlt->s.k = 4;
1625  		b = new_block(cstate, JMP(BPF_JEQ));
1626  		b->stmts = s_load_dlt;
1627  		b->s.k = SWAPLONG(DLT_IEEE802_11);
1628  	}
1629  	else
1630  	{
1631  		b = NULL;
1632  	}
1633  	return b;
1634  }
1635  static struct slist *
1636  gen_abs_offset_varpart(compiler_state_t *cstate, bpf_abs_offset *off)
1637  {
1638  	struct slist *s;
1639  	if (off->is_variable) {
1640  		if (off->reg == -1) {
1641  			off->reg = alloc_reg(cstate);
1642  		}
1643  		s = new_stmt(cstate, BPF_LDX|BPF_MEM);
1644  		s->s.k = off->reg;
1645  		return s;
1646  	} else {
1647  		return NULL;
1648  	}
1649  }
1650  static bpf_u_int32
1651  ethertype_to_ppptype(bpf_u_int32 ll_proto)
1652  {
1653  	switch (ll_proto) {
1654  	case ETHERTYPE_IP:
1655  		ll_proto = PPP_IP;
1656  		break;
1657  	case ETHERTYPE_IPV6:
1658  		ll_proto = PPP_IPV6;
1659  		break;
1660  	case ETHERTYPE_DN:
1661  		ll_proto = PPP_DECNET;
1662  		break;
1663  	case ETHERTYPE_ATALK:
1664  		ll_proto = PPP_APPLE;
1665  		break;
1666  	case ETHERTYPE_NS:
1667  		ll_proto = PPP_NS;
1668  		break;
1669  	case LLCSAP_ISONS:
1670  		ll_proto = PPP_OSI;
1671  		break;
1672  	case LLCSAP_8021D:
1673  		ll_proto = PPP_BRPDU;
1674  		break;
1675  	case LLCSAP_IPX:
1676  		ll_proto = PPP_IPX;
1677  		break;
1678  	}
1679  	return (ll_proto);
1680  }
1681  static struct block *
1682  gen_prevlinkhdr_check(compiler_state_t *cstate)
1683  {
1684  	struct block *b0;
1685  	if (cstate->is_geneve)
1686  		return gen_geneve_ll_check(cstate);
1687  	switch (cstate->prevlinktype) {
1688  	case DLT_SUNATM:
1689  		b0 = gen_cmp(cstate, OR_PREVLINKHDR, SUNATM_PKT_BEGIN_POS, BPF_H, 0xFF00);
1690  		gen_not(b0);
1691  		return b0;
1692  	default:
1693  		return NULL;
1694  	}
1695  }
1696  #define BSD_AFNUM_INET6_BSD	24	&bsol;* NetBSD, OpenBSD, BSD/OS, Npcap */
1697  #define BSD_AFNUM_INET6_FREEBSD	28	&bsol;* FreeBSD */
1698  #define BSD_AFNUM_INET6_DARWIN	30	&bsol;* macOS, iOS, other Darwin-based OSes */
1699  static struct block *
1700  gen_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)
1701  {
1702  	struct block *b0, *b1, *b2;
1703  	const char *description;
1704  	if (cstate->label_stack_depth > 0)
1705  		return gen_mpls_linktype(cstate, ll_proto);
1706  	switch (cstate->linktype) {
1707  	case DLT_EN10MB:
1708  	case DLT_NETANALYZER:
1709  	case DLT_NETANALYZER_TRANSPARENT:
1710  		if (!cstate->is_geneve)
1711  			b0 = gen_prevlinkhdr_check(cstate);
1712  		else
1713  			b0 = NULL;
1714  		b1 = gen_ether_linktype(cstate, ll_proto);
1715  		if (b0 != NULL)
1716  			gen_and(b0, b1);
1717  		return b1;
1718  	case DLT_C_HDLC:
1719  	case DLT_HDLC:
1720  		switch (ll_proto) {
1721  		case LLCSAP_ISONS:
1722  			ll_proto = (ll_proto << 8 | LLCSAP_ISONS);
1723  		default:
1724  			return gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ll_proto);
1725  		}
1726  	case DLT_IEEE802_11:
1727  	case DLT_PRISM_HEADER:
1728  	case DLT_IEEE802_11_RADIO_AVS:
1729  	case DLT_IEEE802_11_RADIO:
1730  	case DLT_PPI:
1731  		b0 = gen_check_802_11_data_frame(cstate);
1732  		b1 = gen_llc_linktype(cstate, ll_proto);
1733  		gen_and(b0, b1);
1734  		return b1;
1735  	case DLT_FDDI:
1736  		return gen_llc_linktype(cstate, ll_proto);
1737  	case DLT_IEEE802:
1738  		return gen_llc_linktype(cstate, ll_proto);
1739  	case DLT_ATM_RFC1483:
1740  	case DLT_ATM_CLIP:
1741  	case DLT_IP_OVER_FC:
1742  		return gen_llc_linktype(cstate, ll_proto);
1743  	case DLT_SUNATM:
1744  		b0 = gen_atmfield_code_internal(cstate, A_PROTOTYPE, PT_LLC, BPF_JEQ, 0);
1745  		b1 = gen_llc_linktype(cstate, ll_proto);
1746  		gen_and(b0, b1);
1747  		return b1;
1748  	case DLT_LINUX_SLL:
1749  		return gen_linux_sll_linktype(cstate, ll_proto);
1750  	case DLT_SLIP:
1751  	case DLT_SLIP_BSDOS:
1752  	case DLT_RAW:
1753  		switch (ll_proto) {
1754  		case ETHERTYPE_IP:
1755  			return gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, 0x40, 0xF0);
1756  		case ETHERTYPE_IPV6:
1757  			return gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, 0x60, 0xF0);
1758  		default:
1759  			return gen_false(cstate);	&bsol;* always false */
1760  		}
1761  	case DLT_IPV4:
1762  		if (ll_proto == ETHERTYPE_IP)
1763  			return gen_true(cstate);	&bsol;* always true */
1764  		return gen_false(cstate);
1765  	case DLT_IPV6:
1766  		if (ll_proto == ETHERTYPE_IPV6)
1767  			return gen_true(cstate);	&bsol;* always true */
1768  		return gen_false(cstate);
1769  	case DLT_PPP:
1770  	case DLT_PPP_PPPD:
1771  	case DLT_PPP_SERIAL:
1772  	case DLT_PPP_ETHER:
1773  		return gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H,
1774  		    ethertype_to_ppptype(ll_proto));
1775  	case DLT_PPP_BSDOS:
1776  		switch (ll_proto) {
1777  		case ETHERTYPE_IP:
1778  			b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, PPP_IP);
1779  			b1 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, PPP_VJC);
1780  			gen_or(b0, b1);
1781  			b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, PPP_VJNC);
1782  			gen_or(b1, b0);
1783  			return b0;
1784  		default:
1785  			return gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H,
1786  			    ethertype_to_ppptype(ll_proto));
1787  		}
1788  	case DLT_NULL:
1789  	case DLT_LOOP:
1790  	case DLT_ENC:
1791  		switch (ll_proto) {
1792  		case ETHERTYPE_IP:
1793  			return (gen_loopback_linktype(cstate, AF_INET));
1794  		case ETHERTYPE_IPV6:
1795  			if (cstate->bpf_pcap->rfile != NULL) {
1796  				b0 = gen_loopback_linktype(cstate, BSD_AFNUM_INET6_BSD);
1797  				b1 = gen_loopback_linktype(cstate, BSD_AFNUM_INET6_FREEBSD);
1798  				gen_or(b0, b1);
1799  				b0 = gen_loopback_linktype(cstate, BSD_AFNUM_INET6_DARWIN);
1800  				gen_or(b0, b1);
1801  				return (b1);
1802  			} else {
1803  #ifdef _WIN32
1804  				return (gen_loopback_linktype(cstate, 24));
1805  #else &bsol;* _WIN32 */
1806  #ifdef AF_INET6
1807  				return (gen_loopback_linktype(cstate, AF_INET6));
1808  #else &bsol;* AF_INET6 */
1809  				return gen_false(cstate);
1810  #endif &bsol;* AF_INET6 */
1811  #endif &bsol;* _WIN32 */
1812  			}
1813  		default:
1814  			return gen_false(cstate);
1815  		}
1816  	case DLT_PFLOG:
1817  		if (ll_proto == ETHERTYPE_IP)
1818  			return (gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, af),
1819  			    BPF_B, AF_INET));
1820  		else if (ll_proto == ETHERTYPE_IPV6)
1821  			return (gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, af),
1822  			    BPF_B, AF_INET6));
1823  		else
1824  			return gen_false(cstate);
1825  	case DLT_ARCNET:
1826  	case DLT_ARCNET_LINUX:
1827  		switch (ll_proto) {
1828  		default:
1829  			return gen_false(cstate);
1830  		case ETHERTYPE_IPV6:
1831  			return (gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,
1832  				ARCTYPE_INET6));
1833  		case ETHERTYPE_IP:
1834  			b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,
1835  			    ARCTYPE_IP);
1836  			b1 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,
1837  			    ARCTYPE_IP_OLD);
1838  			gen_or(b0, b1);
1839  			return (b1);
1840  		case ETHERTYPE_ARP:
1841  			b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,
1842  			    ARCTYPE_ARP);
1843  			b1 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,
1844  			    ARCTYPE_ARP_OLD);
1845  			gen_or(b0, b1);
1846  			return (b1);
1847  		case ETHERTYPE_REVARP:
1848  			return (gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,
1849  			    ARCTYPE_REVARP));
1850  		case ETHERTYPE_ATALK:
1851  			return (gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,
1852  			    ARCTYPE_ATALK));
1853  		}
1854  	case DLT_LTALK:
1855  		switch (ll_proto) {
1856  		case ETHERTYPE_ATALK:
1857  			return gen_true(cstate);
1858  		default:
1859  			return gen_false(cstate);
1860  		}
1861  	case DLT_FRELAY:
1862  		switch (ll_proto) {
1863  		case ETHERTYPE_IP:
1864  			return gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | 0xcc);
1865  		case ETHERTYPE_IPV6:
1866  			return gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | 0x8e);
1867  		case LLCSAP_ISONS:
1868  			b0 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | ISO8473_CLNP);
1869  			b1 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | ISO9542_ESIS);
1870  			b2 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | ISO10589_ISIS);
1871  			gen_or(b1, b2);
1872  			gen_or(b0, b2);
1873  			return b2;
1874  		default:
1875  			return gen_false(cstate);
1876  		}
1877  	case DLT_MFR:
1878  		bpf_error(cstate, "Multi-link Frame Relay link-layer type filtering not implemented");
1879          case DLT_JUNIPER_MFR:
1880          case DLT_JUNIPER_MLFR:
1881          case DLT_JUNIPER_MLPPP:
1882  	case DLT_JUNIPER_ATM1:
1883  	case DLT_JUNIPER_ATM2:
1884  	case DLT_JUNIPER_PPPOE:
1885  	case DLT_JUNIPER_PPPOE_ATM:
1886          case DLT_JUNIPER_GGSN:
1887          case DLT_JUNIPER_ES:
1888          case DLT_JUNIPER_MONITOR:
1889          case DLT_JUNIPER_SERVICES:
1890          case DLT_JUNIPER_ETHER:
1891          case DLT_JUNIPER_PPP:
1892          case DLT_JUNIPER_FRELAY:
1893          case DLT_JUNIPER_CHDLC:
1894          case DLT_JUNIPER_VP:
1895          case DLT_JUNIPER_ST:
1896          case DLT_JUNIPER_ISM:
1897          case DLT_JUNIPER_VS:
1898          case DLT_JUNIPER_SRX_E2E:
1899          case DLT_JUNIPER_FIBRECHANNEL:
1900  	case DLT_JUNIPER_ATM_CEMIC:
1901  		return gen_mcmp(cstate, OR_LINKHDR, 0, BPF_W, 0x4d474300, 0xffffff00); &bsol;* compare the magic number */
1902  	case DLT_BACNET_MS_TP:
1903  		return gen_mcmp(cstate, OR_LINKHDR, 0, BPF_W, 0x55FF0000, 0xffff0000);
1904  	case DLT_IPNET:
1905  		return gen_ipnet_linktype(cstate, ll_proto);
1906  	case DLT_LINUX_IRDA:
1907  		bpf_error(cstate, "IrDA link-layer type filtering not implemented");
1908  	case DLT_DOCSIS:
1909  		bpf_error(cstate, "DOCSIS link-layer type filtering not implemented");
1910  	case DLT_MTP2:
1911  	case DLT_MTP2_WITH_PHDR:
1912  		bpf_error(cstate, "MTP2 link-layer type filtering not implemented");
1913  	case DLT_ERF:
1914  		bpf_error(cstate, "ERF link-layer type filtering not implemented");
1915  	case DLT_PFSYNC:
1916  		bpf_error(cstate, "PFSYNC link-layer type filtering not implemented");
1917  	case DLT_LINUX_LAPD:
1918  		bpf_error(cstate, "LAPD link-layer type filtering not implemented");
1919  	case DLT_USB_FREEBSD:
1920  	case DLT_USB_LINUX:
1921  	case DLT_USB_LINUX_MMAPPED:
1922  	case DLT_USBPCAP:
1923  		bpf_error(cstate, "USB link-layer type filtering not implemented");
1924  	case DLT_BLUETOOTH_HCI_H4:
1925  	case DLT_BLUETOOTH_HCI_H4_WITH_PHDR:
1926  		bpf_error(cstate, "Bluetooth link-layer type filtering not implemented");
1927  	case DLT_CAN20B:
1928  	case DLT_CAN_SOCKETCAN:
1929  		bpf_error(cstate, "CAN link-layer type filtering not implemented");
1930  	case DLT_IEEE802_15_4:
1931  	case DLT_IEEE802_15_4_LINUX:
1932  	case DLT_IEEE802_15_4_NONASK_PHY:
1933  	case DLT_IEEE802_15_4_NOFCS:
1934  	case DLT_IEEE802_15_4_TAP:
1935  		bpf_error(cstate, "IEEE 802.15.4 link-layer type filtering not implemented");
1936  	case DLT_IEEE802_16_MAC_CPS_RADIO:
1937  		bpf_error(cstate, "IEEE 802.16 link-layer type filtering not implemented");
1938  	case DLT_SITA:
1939  		bpf_error(cstate, "SITA link-layer type filtering not implemented");
1940  	case DLT_RAIF1:
1941  		bpf_error(cstate, "RAIF1 link-layer type filtering not implemented");
1942  	case DLT_IPMB_KONTRON:
1943  	case DLT_IPMB_LINUX:
1944  		bpf_error(cstate, "IPMB link-layer type filtering not implemented");
1945  	case DLT_AX25_KISS:
1946  		bpf_error(cstate, "AX.25 link-layer type filtering not implemented");
1947  	case DLT_NFLOG:
1948  		bpf_error(cstate, "NFLOG link-layer type filtering not implemented");
1949  	default:
1950  		if (cstate->off_linktype.constant_part != OFFSET_NOT_SET) {
1951  			return gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ll_proto);
1952  		} else {
1953  			description = pcap_datalink_val_to_description_or_dlt(cstate->linktype);
1954  			bpf_error(cstate, "%s link-layer type filtering not implemented",
1955  			    description);
1956  		}
1957  	}
1958  }
1959  static struct block *
1960  gen_snap(compiler_state_t *cstate, bpf_u_int32 orgcode, bpf_u_int32 ptype)
1961  {
1962  	u_char snapblock[8];
1963  	snapblock[0] = LLCSAP_SNAP;		&bsol;* DSAP = SNAP */
1964  	snapblock[1] = LLCSAP_SNAP;		&bsol;* SSAP = SNAP */
1965  	snapblock[2] = 0x03;			&bsol;* control = UI */
1966  	snapblock[3] = (u_char)(orgcode >> 16);	&bsol;* upper 8 bits of organization code */
1967  	snapblock[4] = (u_char)(orgcode >> 8);	&bsol;* middle 8 bits of organization code */
1968  	snapblock[5] = (u_char)(orgcode >> 0);	&bsol;* lower 8 bits of organization code */
1969  	snapblock[6] = (u_char)(ptype >> 8);	&bsol;* upper 8 bits of protocol type */
1970  	snapblock[7] = (u_char)(ptype >> 0);	&bsol;* lower 8 bits of protocol type */
1971  	return gen_bcmp(cstate, OR_LLC, 0, 8, snapblock);
1972  }
1973  static struct block *
1974  gen_llc_internal(compiler_state_t *cstate)
1975  {
1976  	struct block *b0, *b1;
1977  	switch (cstate->linktype) {
1978  	case DLT_EN10MB:
1979  		b0 = gen_cmp_gt(cstate, OR_LINKTYPE, 0, BPF_H, ETHERMTU);
1980  		gen_not(b0);
1981  		b1 = gen_cmp(cstate, OR_LLC, 0, BPF_H, 0xFFFF);
1982  		gen_not(b1);
1983  		gen_and(b0, b1);
1984  		return b1;
1985  	case DLT_SUNATM:
1986  		b0 = gen_atmtype_llc(cstate);
1987  		return b0;
1988  	case DLT_IEEE802:	&bsol;* Token Ring */
1989  		return gen_true(cstate);
1990  	case DLT_FDDI:
1991  		return gen_true(cstate);
1992  	case DLT_ATM_RFC1483:
1993  		return gen_true(cstate);
1994  	case DLT_IEEE802_11:
1995  	case DLT_PRISM_HEADER:
1996  	case DLT_IEEE802_11_RADIO:
1997  	case DLT_IEEE802_11_RADIO_AVS:
1998  	case DLT_PPI:
1999  		b0 = gen_check_802_11_data_frame(cstate);
2000  		return b0;
2001  	default:
2002  		bpf_error(cstate, "'llc' not supported for %s",
2003  			  pcap_datalink_val_to_description_or_dlt(cstate->linktype));
2004  	}
2005  }
2006  struct block *
2007  gen_llc(compiler_state_t *cstate)
2008  {
2009  	if (setjmp(cstate->top_ctx))
2010  		return (NULL);
2011  	return gen_llc_internal(cstate);
2012  }
2013  struct block *
2014  gen_llc_i(compiler_state_t *cstate)
2015  {
2016  	struct block *b0, *b1;
2017  	struct slist *s;
2018  	if (setjmp(cstate->top_ctx))
2019  		return (NULL);
2020  	b0 = gen_llc_internal(cstate);
2021  	s = gen_load_a(cstate, OR_LLC, 2, BPF_B);
2022  	b1 = new_block(cstate, JMP(BPF_JSET));
2023  	b1->s.k = 0x01;
2024  	b1->stmts = s;
2025  	gen_not(b1);
2026  	gen_and(b0, b1);
2027  	return b1;
2028  }
2029  struct block *
2030  gen_llc_s(compiler_state_t *cstate)
2031  {
2032  	struct block *b0, *b1;
2033  	if (setjmp(cstate->top_ctx))
2034  		return (NULL);
2035  	b0 = gen_llc_internal(cstate);
2036  	b1 = gen_mcmp(cstate, OR_LLC, 2, BPF_B, LLC_S_FMT, 0x03);
2037  	gen_and(b0, b1);
2038  	return b1;
2039  }
2040  struct block *
2041  gen_llc_u(compiler_state_t *cstate)
2042  {
2043  	struct block *b0, *b1;
2044  	if (setjmp(cstate->top_ctx))
2045  		return (NULL);
2046  	b0 = gen_llc_internal(cstate);
2047  	b1 = gen_mcmp(cstate, OR_LLC, 2, BPF_B, LLC_U_FMT, 0x03);
2048  	gen_and(b0, b1);
2049  	return b1;
2050  }
2051  struct block *
2052  gen_llc_s_subtype(compiler_state_t *cstate, bpf_u_int32 subtype)
2053  {
2054  	struct block *b0, *b1;
2055  	if (setjmp(cstate->top_ctx))
2056  		return (NULL);
2057  	b0 = gen_llc_internal(cstate);
2058  	b1 = gen_mcmp(cstate, OR_LLC, 2, BPF_B, subtype, LLC_S_CMD_MASK);
2059  	gen_and(b0, b1);
2060  	return b1;
2061  }
2062  struct block *
2063  gen_llc_u_subtype(compiler_state_t *cstate, bpf_u_int32 subtype)
2064  {
2065  	struct block *b0, *b1;
2066  	if (setjmp(cstate->top_ctx))
2067  		return (NULL);
2068  	b0 = gen_llc_internal(cstate);
2069  	b1 = gen_mcmp(cstate, OR_LLC, 2, BPF_B, subtype, LLC_U_CMD_MASK);
2070  	gen_and(b0, b1);
2071  	return b1;
2072  }
2073  static struct block *
2074  gen_llc_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)
2075  {
2076  	switch (ll_proto) {
2077  	case LLCSAP_IP:
2078  	case LLCSAP_ISONS:
2079  	case LLCSAP_NETBEUI:
2080  		return gen_cmp(cstate, OR_LLC, 0, BPF_H, (bpf_u_int32)
2081  			     ((ll_proto << 8) | ll_proto));
2082  	case LLCSAP_IPX:
2083  		return gen_cmp(cstate, OR_LLC, 0, BPF_B, LLCSAP_IPX);
2084  	case ETHERTYPE_ATALK:
2085  		return gen_snap(cstate, 0x080007, ETHERTYPE_ATALK);
2086  	default:
2087  		if (ll_proto <= ETHERMTU) {
2088  			return gen_cmp(cstate, OR_LLC, 0, BPF_B, ll_proto);
2089  		} else {
2090  			return gen_cmp(cstate, OR_LLC, 6, BPF_H, ll_proto);
2091  		}
2092  	}
2093  }
2094  static struct block *
2095  gen_hostop(compiler_state_t *cstate, bpf_u_int32 addr, bpf_u_int32 mask,
2096      int dir, bpf_u_int32 ll_proto, u_int src_off, u_int dst_off)
2097  {
2098  	struct block *b0, *b1;
2099  	u_int offset;
2100  	switch (dir) {
2101  	case Q_SRC:
2102  		offset = src_off;
2103  		break;
2104  	case Q_DST:
2105  		offset = dst_off;
2106  		break;
2107  	case Q_AND:
2108  		b0 = gen_hostop(cstate, addr, mask, Q_SRC, ll_proto, src_off, dst_off);
2109  		b1 = gen_hostop(cstate, addr, mask, Q_DST, ll_proto, src_off, dst_off);
2110  		gen_and(b0, b1);
2111  		return b1;
2112  	case Q_DEFAULT:
2113  	case Q_OR:
2114  		b0 = gen_hostop(cstate, addr, mask, Q_SRC, ll_proto, src_off, dst_off);
2115  		b1 = gen_hostop(cstate, addr, mask, Q_DST, ll_proto, src_off, dst_off);
2116  		gen_or(b0, b1);
2117  		return b1;
2118  	case Q_ADDR1:
2119  		bpf_error(cstate, "'addr1' and 'address1' are not valid qualifiers for addresses other than 802.11 MAC addresses");
2120  	case Q_ADDR2:
2121  		bpf_error(cstate, "'addr2' and 'address2' are not valid qualifiers for addresses other than 802.11 MAC addresses");
2122  	case Q_ADDR3:
2123  		bpf_error(cstate, "'addr3' and 'address3' are not valid qualifiers for addresses other than 802.11 MAC addresses");
2124  	case Q_ADDR4:
2125  		bpf_error(cstate, "'addr4' and 'address4' are not valid qualifiers for addresses other than 802.11 MAC addresses");
2126  	case Q_RA:
2127  		bpf_error(cstate, "'ra' is not a valid qualifier for addresses other than 802.11 MAC addresses");
2128  	case Q_TA:
2129  		bpf_error(cstate, "'ta' is not a valid qualifier for addresses other than 802.11 MAC addresses");
2130  	default:
2131  		abort();
2132  	}
2133  	b0 = gen_linktype(cstate, ll_proto);
2134  	b1 = gen_mcmp(cstate, OR_LINKPL, offset, BPF_W, addr, mask);
2135  	gen_and(b0, b1);
2136  	return b1;
2137  }
2138  #ifdef INET6
2139  static struct block *
2140  gen_hostop6(compiler_state_t *cstate, struct in6_addr *addr,
2141      struct in6_addr *mask, int dir, bpf_u_int32 ll_proto, u_int src_off,
2142      u_int dst_off)
2143  {
2144  	struct block *b0, *b1;
2145  	u_int offset;
2146  	bpf_u_int32 a[4], m[4];
2147  	switch (dir) {
2148  	case Q_SRC:
2149  		offset = src_off;
2150  		break;
2151  	case Q_DST:
2152  		offset = dst_off;
2153  		break;
2154  	case Q_AND:
2155  		b0 = gen_hostop6(cstate, addr, mask, Q_SRC, ll_proto, src_off, dst_off);
2156  		b1 = gen_hostop6(cstate, addr, mask, Q_DST, ll_proto, src_off, dst_off);
2157  		gen_and(b0, b1);
2158  		return b1;
2159  	case Q_DEFAULT:
2160  	case Q_OR:
2161  		b0 = gen_hostop6(cstate, addr, mask, Q_SRC, ll_proto, src_off, dst_off);
2162  		b1 = gen_hostop6(cstate, addr, mask, Q_DST, ll_proto, src_off, dst_off);
2163  		gen_or(b0, b1);
2164  		return b1;
2165  	case Q_ADDR1:
2166  		bpf_error(cstate, "'addr1' and 'address1' are not valid qualifiers for addresses other than 802.11 MAC addresses");
2167  	case Q_ADDR2:
2168  		bpf_error(cstate, "'addr2' and 'address2' are not valid qualifiers for addresses other than 802.11 MAC addresses");
2169  	case Q_ADDR3:
2170  		bpf_error(cstate, "'addr3' and 'address3' are not valid qualifiers for addresses other than 802.11 MAC addresses");
2171  	case Q_ADDR4:
2172  		bpf_error(cstate, "'addr4' and 'address4' are not valid qualifiers for addresses other than 802.11 MAC addresses");
2173  	case Q_RA:
2174  		bpf_error(cstate, "'ra' is not a valid qualifier for addresses other than 802.11 MAC addresses");
2175  	case Q_TA:
2176  		bpf_error(cstate, "'ta' is not a valid qualifier for addresses other than 802.11 MAC addresses");
2177  	default:
2178  		abort();
2179  	}
2180  	memcpy(a, addr, sizeof(a));
2181  	memcpy(m, mask, sizeof(m));
2182  	b1 = gen_mcmp(cstate, OR_LINKPL, offset + 12, BPF_W, ntohl(a[3]), ntohl(m[3]));
2183  	b0 = gen_mcmp(cstate, OR_LINKPL, offset + 8, BPF_W, ntohl(a[2]), ntohl(m[2]));
2184  	gen_and(b0, b1);
2185  	b0 = gen_mcmp(cstate, OR_LINKPL, offset + 4, BPF_W, ntohl(a[1]), ntohl(m[1]));
2186  	gen_and(b0, b1);
2187  	b0 = gen_mcmp(cstate, OR_LINKPL, offset + 0, BPF_W, ntohl(a[0]), ntohl(m[0]));
2188  	gen_and(b0, b1);
2189  	b0 = gen_linktype(cstate, ll_proto);
2190  	gen_and(b0, b1);
2191  	return b1;
2192  }
2193  #endif
2194  static struct block *
2195  gen_ehostop(compiler_state_t *cstate, const u_char *eaddr, int dir)
2196  {
2197  	register struct block *b0, *b1;
2198  	switch (dir) {
2199  	case Q_SRC:
2200  		return gen_bcmp(cstate, OR_LINKHDR, 6, 6, eaddr);
2201  	case Q_DST:
2202  		return gen_bcmp(cstate, OR_LINKHDR, 0, 6, eaddr);
2203  	case Q_AND:
2204  		b0 = gen_ehostop(cstate, eaddr, Q_SRC);
2205  		b1 = gen_ehostop(cstate, eaddr, Q_DST);
2206  		gen_and(b0, b1);
2207  		return b1;
2208  	case Q_DEFAULT:
2209  	case Q_OR:
2210  		b0 = gen_ehostop(cstate, eaddr, Q_SRC);
2211  		b1 = gen_ehostop(cstate, eaddr, Q_DST);
2212  		gen_or(b0, b1);
2213  		return b1;
2214  	case Q_ADDR1:
2215  		bpf_error(cstate, "'addr1' and 'address1' are only supported on 802.11 with 802.11 headers");
2216  	case Q_ADDR2:
2217  		bpf_error(cstate, "'addr2' and 'address2' are only supported on 802.11 with 802.11 headers");
2218  	case Q_ADDR3:
2219  		bpf_error(cstate, "'addr3' and 'address3' are only supported on 802.11 with 802.11 headers");
2220  	case Q_ADDR4:
2221  		bpf_error(cstate, "'addr4' and 'address4' are only supported on 802.11 with 802.11 headers");
2222  	case Q_RA:
2223  		bpf_error(cstate, "'ra' is only supported on 802.11 with 802.11 headers");
2224  	case Q_TA:
2225  		bpf_error(cstate, "'ta' is only supported on 802.11 with 802.11 headers");
2226  	}
2227  	abort();
2228  }
2229  static struct block *
2230  gen_fhostop(compiler_state_t *cstate, const u_char *eaddr, int dir)
2231  {
2232  	struct block *b0, *b1;
2233  	switch (dir) {
2234  	case Q_SRC:
2235  		return gen_bcmp(cstate, OR_LINKHDR, 6 + 1 + cstate->pcap_fddipad, 6, eaddr);
2236  	case Q_DST:
2237  		return gen_bcmp(cstate, OR_LINKHDR, 0 + 1 + cstate->pcap_fddipad, 6, eaddr);
2238  	case Q_AND:
2239  		b0 = gen_fhostop(cstate, eaddr, Q_SRC);
2240  		b1 = gen_fhostop(cstate, eaddr, Q_DST);
2241  		gen_and(b0, b1);
2242  		return b1;
2243  	case Q_DEFAULT:
2244  	case Q_OR:
2245  		b0 = gen_fhostop(cstate, eaddr, Q_SRC);
2246  		b1 = gen_fhostop(cstate, eaddr, Q_DST);
2247  		gen_or(b0, b1);
2248  		return b1;
2249  	case Q_ADDR1:
2250  		bpf_error(cstate, "'addr1' and 'address1' are only supported on 802.11");
2251  	case Q_ADDR2:
2252  		bpf_error(cstate, "'addr2' and 'address2' are only supported on 802.11");
2253  	case Q_ADDR3:
2254  		bpf_error(cstate, "'addr3' and 'address3' are only supported on 802.11");
2255  	case Q_ADDR4:
2256  		bpf_error(cstate, "'addr4' and 'address4' are only supported on 802.11");
2257  	case Q_RA:
2258  		bpf_error(cstate, "'ra' is only supported on 802.11");
2259  	case Q_TA:
2260  		bpf_error(cstate, "'ta' is only supported on 802.11");
2261  	}
2262  	abort();
2263  }
2264  static struct block *
2265  gen_thostop(compiler_state_t *cstate, const u_char *eaddr, int dir)
2266  {
2267  	register struct block *b0, *b1;
2268  	switch (dir) {
2269  	case Q_SRC:
2270  		return gen_bcmp(cstate, OR_LINKHDR, 8, 6, eaddr);
2271  	case Q_DST:
2272  		return gen_bcmp(cstate, OR_LINKHDR, 2, 6, eaddr);
2273  	case Q_AND:
2274  		b0 = gen_thostop(cstate, eaddr, Q_SRC);
2275  		b1 = gen_thostop(cstate, eaddr, Q_DST);
2276  		gen_and(b0, b1);
2277  		return b1;
2278  	case Q_DEFAULT:
2279  	case Q_OR:
2280  		b0 = gen_thostop(cstate, eaddr, Q_SRC);
2281  		b1 = gen_thostop(cstate, eaddr, Q_DST);
2282  		gen_or(b0, b1);
2283  		return b1;
2284  	case Q_ADDR1:
2285  		bpf_error(cstate, "'addr1' and 'address1' are only supported on 802.11");
2286  	case Q_ADDR2:
2287  		bpf_error(cstate, "'addr2' and 'address2' are only supported on 802.11");
2288  	case Q_ADDR3:
2289  		bpf_error(cstate, "'addr3' and 'address3' are only supported on 802.11");
2290  	case Q_ADDR4:
2291  		bpf_error(cstate, "'addr4' and 'address4' are only supported on 802.11");
2292  	case Q_RA:
2293  		bpf_error(cstate, "'ra' is only supported on 802.11");
2294  	case Q_TA:
2295  		bpf_error(cstate, "'ta' is only supported on 802.11");
2296  	}
2297  	abort();
2298  }
2299  static struct block *
2300  gen_wlanhostop(compiler_state_t *cstate, const u_char *eaddr, int dir)
2301  {
2302  	register struct block *b0, *b1, *b2;
2303  	register struct slist *s;
2304  #ifdef ENABLE_WLAN_FILTERING_PATCH
2305  	cstate->no_optimize = 1;
2306  #endif &bsol;* ENABLE_WLAN_FILTERING_PATCH */
2307  	switch (dir) {
2308  	case Q_SRC:
2309  		s = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);
2310  		b1 = new_block(cstate, JMP(BPF_JSET));
2311  		b1->s.k = 0x01;	&bsol;* To DS */
2312  		b1->stmts = s;
2313  		b0 = gen_bcmp(cstate, OR_LINKHDR, 24, 6, eaddr);
2314  		gen_and(b1, b0);
2315  		s = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);
2316  		b2 = new_block(cstate, JMP(BPF_JSET));
2317  		b2->s.k = 0x01;	&bsol;* To DS */
2318  		b2->stmts = s;
2319  		gen_not(b2);
2320  		b1 = gen_bcmp(cstate, OR_LINKHDR, 16, 6, eaddr);
2321  		gen_and(b2, b1);
2322  		gen_or(b1, b0);
2323  		s = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);
2324  		b1 = new_block(cstate, JMP(BPF_JSET));
2325  		b1->s.k = 0x02;	&bsol;* From DS */
2326  		b1->stmts = s;
2327  		gen_and(b1, b0);
2328  		s = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);
2329  		b2 = new_block(cstate, JMP(BPF_JSET));
2330  		b2->s.k = 0x02;	&bsol;* From DS */
2331  		b2->stmts = s;
2332  		gen_not(b2);
2333  		b1 = gen_bcmp(cstate, OR_LINKHDR, 10, 6, eaddr);
2334  		gen_and(b2, b1);
2335  		gen_or(b1, b0);
2336  		s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
2337  		b1 = new_block(cstate, JMP(BPF_JSET));
2338  		b1->s.k = 0x08;
2339  		b1->stmts = s;
2340  		gen_and(b1, b0);
2341  		s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
2342  		b2 = new_block(cstate, JMP(BPF_JSET));
2343  		b2->s.k = 0x08;
2344  		b2->stmts = s;
2345  		gen_not(b2);
2346  		b1 = gen_bcmp(cstate, OR_LINKHDR, 10, 6, eaddr);
2347  		gen_and(b2, b1);
2348  		gen_or(b1, b0);
2349  		s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
2350  		b1 = new_block(cstate, JMP(BPF_JSET));
2351  		b1->s.k = 0x04;
2352  		b1->stmts = s;
2353  		gen_not(b1);
2354  		gen_and(b1, b0);
2355  		return b0;
2356  	case Q_DST:
2357  		s = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);
2358  		b1 = new_block(cstate, JMP(BPF_JSET));
2359  		b1->s.k = 0x01;	&bsol;* To DS */
2360  		b1->stmts = s;
2361  		b0 = gen_bcmp(cstate, OR_LINKHDR, 16, 6, eaddr);
2362  		gen_and(b1, b0);
2363  		s = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);
2364  		b2 = new_block(cstate, JMP(BPF_JSET));
2365  		b2->s.k = 0x01;	&bsol;* To DS */
2366  		b2->stmts = s;
2367  		gen_not(b2);
2368  		b1 = gen_bcmp(cstate, OR_LINKHDR, 4, 6, eaddr);
2369  		gen_and(b2, b1);
2370  		gen_or(b1, b0);
2371  		s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
2372  		b1 = new_block(cstate, JMP(BPF_JSET));
2373  		b1->s.k = 0x08;
2374  		b1->stmts = s;
2375  		gen_and(b1, b0);
2376  		s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
2377  		b2 = new_block(cstate, JMP(BPF_JSET));
2378  		b2->s.k = 0x08;
2379  		b2->stmts = s;
2380  		gen_not(b2);
2381  		b1 = gen_bcmp(cstate, OR_LINKHDR, 4, 6, eaddr);
2382  		gen_and(b2, b1);
2383  		gen_or(b1, b0);
2384  		s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
2385  		b1 = new_block(cstate, JMP(BPF_JSET));
2386  		b1->s.k = 0x04;
2387  		b1->stmts = s;
2388  		gen_not(b1);
2389  		gen_and(b1, b0);
2390  		return b0;
2391  	case Q_AND:
2392  		b0 = gen_wlanhostop(cstate, eaddr, Q_SRC);
2393  		b1 = gen_wlanhostop(cstate, eaddr, Q_DST);
2394  		gen_and(b0, b1);
2395  		return b1;
2396  	case Q_DEFAULT:
2397  	case Q_OR:
2398  		b0 = gen_wlanhostop(cstate, eaddr, Q_SRC);
2399  		b1 = gen_wlanhostop(cstate, eaddr, Q_DST);
2400  		gen_or(b0, b1);
2401  		return b1;
2402  	case Q_ADDR1:
2403  		return (gen_bcmp(cstate, OR_LINKHDR, 4, 6, eaddr));
2404  	case Q_ADDR2:
2405  		b0 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_TYPE_CTL,
2406  			IEEE80211_FC0_TYPE_MASK);
2407  		gen_not(b0);
2408  		b1 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_SUBTYPE_CTS,
2409  			IEEE80211_FC0_SUBTYPE_MASK);
2410  		gen_not(b1);
2411  		b2 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_SUBTYPE_ACK,
2412  			IEEE80211_FC0_SUBTYPE_MASK);
2413  		gen_not(b2);
2414  		gen_and(b1, b2);
2415  		gen_or(b0, b2);
2416  		b1 = gen_bcmp(cstate, OR_LINKHDR, 10, 6, eaddr);
2417  		gen_and(b2, b1);
2418  		return b1;
2419  	case Q_ADDR3:
2420  		b0 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_TYPE_CTL,
2421  			IEEE80211_FC0_TYPE_MASK);
2422  		gen_not(b0);
2423  		b1 = gen_bcmp(cstate, OR_LINKHDR, 16, 6, eaddr);
2424  		gen_and(b0, b1);
2425  		return b1;
2426  	case Q_ADDR4:
2427  		b0 = gen_mcmp(cstate, OR_LINKHDR, 1, BPF_B,
2428  			IEEE80211_FC1_DIR_DSTODS, IEEE80211_FC1_DIR_MASK);
2429  		b1 = gen_bcmp(cstate, OR_LINKHDR, 24, 6, eaddr);
2430  		gen_and(b0, b1);
2431  		return b1;
2432  	case Q_RA:
2433  		s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
2434  		b1 = new_block(cstate, JMP(BPF_JSET));
2435  		b1->s.k = 0x08;
2436  		b1->stmts = s;
2437  		b0 = gen_bcmp(cstate, OR_LINKHDR, 4, 6, eaddr);
2438  		gen_and(b1, b0);
2439  		return (b0);
2440  	case Q_TA:
2441  		b0 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_TYPE_CTL,
2442  			IEEE80211_FC0_TYPE_MASK);
2443  		gen_not(b0);
2444  		b1 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_SUBTYPE_CTS,
2445  			IEEE80211_FC0_SUBTYPE_MASK);
2446  		gen_not(b1);
2447  		b2 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_SUBTYPE_ACK,
2448  			IEEE80211_FC0_SUBTYPE_MASK);
2449  		gen_not(b2);
2450  		gen_and(b1, b2);
2451  		gen_or(b0, b2);
2452  		s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
2453  		b1 = new_block(cstate, JMP(BPF_JSET));
2454  		b1->s.k = 0x08;
2455  		b1->stmts = s;
2456  		gen_and(b1, b2);
2457  		b1 = gen_bcmp(cstate, OR_LINKHDR, 10, 6, eaddr);
2458  		gen_and(b2, b1);
2459  		return b1;
2460  	}
2461  	abort();
2462  }
2463  static struct block *
2464  gen_ipfchostop(compiler_state_t *cstate, const u_char *eaddr, int dir)
2465  {
2466  	register struct block *b0, *b1;
2467  	switch (dir) {
2468  	case Q_SRC:
2469  		return gen_bcmp(cstate, OR_LINKHDR, 10, 6, eaddr);
2470  	case Q_DST:
2471  		return gen_bcmp(cstate, OR_LINKHDR, 2, 6, eaddr);
2472  	case Q_AND:
2473  		b0 = gen_ipfchostop(cstate, eaddr, Q_SRC);
2474  		b1 = gen_ipfchostop(cstate, eaddr, Q_DST);
2475  		gen_and(b0, b1);
2476  		return b1;
2477  	case Q_DEFAULT:
2478  	case Q_OR:
2479  		b0 = gen_ipfchostop(cstate, eaddr, Q_SRC);
2480  		b1 = gen_ipfchostop(cstate, eaddr, Q_DST);
2481  		gen_or(b0, b1);
2482  		return b1;
2483  	case Q_ADDR1:
2484  		bpf_error(cstate, "'addr1' and 'address1' are only supported on 802.11");
2485  	case Q_ADDR2:
2486  		bpf_error(cstate, "'addr2' and 'address2' are only supported on 802.11");
2487  	case Q_ADDR3:
2488  		bpf_error(cstate, "'addr3' and 'address3' are only supported on 802.11");
2489  	case Q_ADDR4:
2490  		bpf_error(cstate, "'addr4' and 'address4' are only supported on 802.11");
2491  	case Q_RA:
2492  		bpf_error(cstate, "'ra' is only supported on 802.11");
2493  	case Q_TA:
2494  		bpf_error(cstate, "'ta' is only supported on 802.11");
2495  	}
2496  	abort();
2497  }
2498  static struct block *
2499  gen_dnhostop(compiler_state_t *cstate, bpf_u_int32 addr, int dir)
2500  {
2501  	struct block *b0, *b1, *b2, *tmp;
2502  	u_int offset_lh;	&bsol;* offset if long header is received */
2503  	u_int offset_sh;	&bsol;* offset if short header is received */
2504  	switch (dir) {
2505  	case Q_DST:
2506  		offset_sh = 1;	&bsol;* follows flags */
2507  		offset_lh = 7;	&bsol;* flgs,darea,dsubarea,HIORD */
2508  		break;
2509  	case Q_SRC:
2510  		offset_sh = 3;	&bsol;* follows flags, dstnode */
2511  		offset_lh = 15;	&bsol;* flgs,darea,dsubarea,did,sarea,ssub,HIORD */
2512  		break;
2513  	case Q_AND:
2514  		b0 = gen_dnhostop(cstate, addr, Q_SRC);
2515  		b1 = gen_dnhostop(cstate, addr, Q_DST);
2516  		gen_and(b0, b1);
2517  		return b1;
2518  	case Q_DEFAULT:
2519  	case Q_OR:
2520  		b0 = gen_dnhostop(cstate, addr, Q_SRC);
2521  		b1 = gen_dnhostop(cstate, addr, Q_DST);
2522  		gen_or(b0, b1);
2523  		return b1;
2524  	case Q_ADDR1:
2525  		bpf_error(cstate, "'addr1' and 'address1' are not valid qualifiers for addresses other than 802.11 MAC addresses");
2526  	case Q_ADDR2:
2527  		bpf_error(cstate, "'addr2' and 'address2' are not valid qualifiers for addresses other than 802.11 MAC addresses");
2528  	case Q_ADDR3:
2529  		bpf_error(cstate, "'addr3' and 'address3' are not valid qualifiers for addresses other than 802.11 MAC addresses");
2530  	case Q_ADDR4:
2531  		bpf_error(cstate, "'addr4' and 'address4' are not valid qualifiers for addresses other than 802.11 MAC addresses");
2532  	case Q_RA:
2533  		bpf_error(cstate, "'ra' is not a valid qualifier for addresses other than 802.11 MAC addresses");
2534  	case Q_TA:
2535  		bpf_error(cstate, "'ta' is not a valid qualifier for addresses other than 802.11 MAC addresses");
2536  	default:
2537  		abort();
2538  	}
2539  	b0 = gen_linktype(cstate, ETHERTYPE_DN);
2540  	tmp = gen_mcmp(cstate, OR_LINKPL, 2, BPF_H,
2541  	    (bpf_u_int32)ntohs(0x0681), (bpf_u_int32)ntohs(0x07FF));
2542  	b1 = gen_cmp(cstate, OR_LINKPL, 2 + 1 + offset_lh,
2543  	    BPF_H, (bpf_u_int32)ntohs((u_short)addr));
2544  	gen_and(tmp, b1);
2545  	tmp = gen_mcmp(cstate, OR_LINKPL, 2, BPF_B, (bpf_u_int32)0x06,
2546  	    (bpf_u_int32)0x7);
2547  	b2 = gen_cmp(cstate, OR_LINKPL, 2 + offset_lh, BPF_H,
2548  	    (bpf_u_int32)ntohs((u_short)addr));
2549  	gen_and(tmp, b2);
2550  	gen_or(b2, b1);
2551  	tmp = gen_mcmp(cstate, OR_LINKPL, 2, BPF_H,
2552  	    (bpf_u_int32)ntohs(0x0281), (bpf_u_int32)ntohs(0x07FF));
2553  	b2 = gen_cmp(cstate, OR_LINKPL, 2 + 1 + offset_sh, BPF_H,
2554  	    (bpf_u_int32)ntohs((u_short)addr));
2555  	gen_and(tmp, b2);
2556  	gen_or(b2, b1);
2557  	tmp = gen_mcmp(cstate, OR_LINKPL, 2, BPF_B, (bpf_u_int32)0x02,
2558  	    (bpf_u_int32)0x7);
2559  	b2 = gen_cmp(cstate, OR_LINKPL, 2 + offset_sh, BPF_H,
2560  	    (bpf_u_int32)ntohs((u_short)addr));
2561  	gen_and(tmp, b2);
2562  	gen_or(b2, b1);
2563  	gen_and(b0, b1);
2564  	return b1;
2565  }
2566  static struct block *
2567  gen_mpls_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)
2568  {
2569  	struct block *b0, *b1;
2570          switch (ll_proto) {
2571          case ETHERTYPE_IP:
2572                  b0 = gen_mcmp(cstate, OR_LINKPL, (u_int)-2, BPF_B, 0x01, 0x01);
2573                  b1 = gen_mcmp(cstate, OR_LINKPL, 0, BPF_B, 0x40, 0xf0);
2574                  gen_and(b0, b1);
2575                  return b1;
2576          case ETHERTYPE_IPV6:
2577                  b0 = gen_mcmp(cstate, OR_LINKPL, (u_int)-2, BPF_B, 0x01, 0x01);
2578                  b1 = gen_mcmp(cstate, OR_LINKPL, 0, BPF_B, 0x60, 0xf0);
2579                  gen_and(b0, b1);
2580                  return b1;
2581          default:
2582                 bpf_error(cstate, "unsupported protocol over mpls");
2583          }
2584  }
2585  static struct block *
2586  gen_host(compiler_state_t *cstate, bpf_u_int32 addr, bpf_u_int32 mask,
2587      int proto, int dir, int type)
2588  {
2589  	struct block *b0, *b1;
2590  	const char *typestr;
2591  	if (type == Q_NET)
2592  		typestr = "net";
2593  	else
2594  		typestr = "host";
2595  	switch (proto) {
2596  	case Q_DEFAULT:
2597  		b0 = gen_host(cstate, addr, mask, Q_IP, dir, type);
2598  		if (cstate->label_stack_depth == 0) {
2599  			b1 = gen_host(cstate, addr, mask, Q_ARP, dir, type);
2600  			gen_or(b0, b1);
2601  			b0 = gen_host(cstate, addr, mask, Q_RARP, dir, type);
2602  			gen_or(b1, b0);
2603  		}
2604  		return b0;
2605  	case Q_LINK:
2606  		bpf_error(cstate, "link-layer modifier applied to %s", typestr);
2607  	case Q_IP:
2608  		return gen_hostop(cstate, addr, mask, dir, ETHERTYPE_IP, 12, 16);
2609  	case Q_RARP:
2610  		return gen_hostop(cstate, addr, mask, dir, ETHERTYPE_REVARP, 14, 24);
2611  	case Q_ARP:
2612  		return gen_hostop(cstate, addr, mask, dir, ETHERTYPE_ARP, 14, 24);
2613  	case Q_SCTP:
2614  		bpf_error(cstate, "'sctp' modifier applied to %s", typestr);
2615  	case Q_TCP:
2616  		bpf_error(cstate, "'tcp' modifier applied to %s", typestr);
2617  	case Q_UDP:
2618  		bpf_error(cstate, "'udp' modifier applied to %s", typestr);
2619  	case Q_ICMP:
2620  		bpf_error(cstate, "'icmp' modifier applied to %s", typestr);
2621  	case Q_IGMP:
2622  		bpf_error(cstate, "'igmp' modifier applied to %s", typestr);
2623  	case Q_IGRP:
2624  		bpf_error(cstate, "'igrp' modifier applied to %s", typestr);
2625  	case Q_ATALK:
2626  		bpf_error(cstate, "AppleTalk host filtering not implemented");
2627  	case Q_DECNET:
2628  		return gen_dnhostop(cstate, addr, dir);
2629  	case Q_LAT:
2630  		bpf_error(cstate, "LAT host filtering not implemented");
2631  	case Q_SCA:
2632  		bpf_error(cstate, "SCA host filtering not implemented");
2633  	case Q_MOPRC:
2634  		bpf_error(cstate, "MOPRC host filtering not implemented");
2635  	case Q_MOPDL:
2636  		bpf_error(cstate, "MOPDL host filtering not implemented");
2637  	case Q_IPV6:
2638  		bpf_error(cstate, "'ip6' modifier applied to ip host");
2639  	case Q_ICMPV6:
2640  		bpf_error(cstate, "'icmp6' modifier applied to %s", typestr);
2641  	case Q_AH:
2642  		bpf_error(cstate, "'ah' modifier applied to %s", typestr);
2643  	case Q_ESP:
2644  		bpf_error(cstate, "'esp' modifier applied to %s", typestr);
2645  	case Q_PIM:
2646  		bpf_error(cstate, "'pim' modifier applied to %s", typestr);
2647  	case Q_VRRP:
2648  		bpf_error(cstate, "'vrrp' modifier applied to %s", typestr);
2649  	case Q_AARP:
2650  		bpf_error(cstate, "AARP host filtering not implemented");
2651  	case Q_ISO:
2652  		bpf_error(cstate, "ISO host filtering not implemented");
2653  	case Q_ESIS:
2654  		bpf_error(cstate, "'esis' modifier applied to %s", typestr);
2655  	case Q_ISIS:
2656  		bpf_error(cstate, "'isis' modifier applied to %s", typestr);
2657  	case Q_CLNP:
2658  		bpf_error(cstate, "'clnp' modifier applied to %s", typestr);
2659  	case Q_STP:
2660  		bpf_error(cstate, "'stp' modifier applied to %s", typestr);
2661  	case Q_IPX:
2662  		bpf_error(cstate, "IPX host filtering not implemented");
2663  	case Q_NETBEUI:
2664  		bpf_error(cstate, "'netbeui' modifier applied to %s", typestr);
2665  	case Q_ISIS_L1:
2666  		bpf_error(cstate, "'l1' modifier applied to %s", typestr);
2667  	case Q_ISIS_L2:
2668  		bpf_error(cstate, "'l2' modifier applied to %s", typestr);
2669  	case Q_ISIS_IIH:
2670  		bpf_error(cstate, "'iih' modifier applied to %s", typestr);
2671  	case Q_ISIS_SNP:
2672  		bpf_error(cstate, "'snp' modifier applied to %s", typestr);
2673  	case Q_ISIS_CSNP:
2674  		bpf_error(cstate, "'csnp' modifier applied to %s", typestr);
2675  	case Q_ISIS_PSNP:
2676  		bpf_error(cstate, "'psnp' modifier applied to %s", typestr);
2677  	case Q_ISIS_LSP:
2678  		bpf_error(cstate, "'lsp' modifier applied to %s", typestr);
2679  	case Q_RADIO:
2680  		bpf_error(cstate, "'radio' modifier applied to %s", typestr);
2681  	case Q_CARP:
2682  		bpf_error(cstate, "'carp' modifier applied to %s", typestr);
2683  	default:
2684  		abort();
2685  	}
2686  }
2687  #ifdef INET6
2688  static struct block *
2689  gen_host6(compiler_state_t *cstate, struct in6_addr *addr,
2690      struct in6_addr *mask, int proto, int dir, int type)
2691  {
2692  	const char *typestr;
2693  	if (type == Q_NET)
2694  		typestr = "net";
2695  	else
2696  		typestr = "host";
2697  	switch (proto) {
2698  	case Q_DEFAULT:
2699  		return gen_host6(cstate, addr, mask, Q_IPV6, dir, type);
2700  	case Q_LINK:
2701  		bpf_error(cstate, "link-layer modifier applied to ip6 %s", typestr);
2702  	case Q_IP:
2703  		bpf_error(cstate, "'ip' modifier applied to ip6 %s", typestr);
2704  	case Q_RARP:
2705  		bpf_error(cstate, "'rarp' modifier applied to ip6 %s", typestr);
2706  	case Q_ARP:
2707  		bpf_error(cstate, "'arp' modifier applied to ip6 %s", typestr);
2708  	case Q_SCTP:
2709  		bpf_error(cstate, "'sctp' modifier applied to ip6 %s", typestr);
2710  	case Q_TCP:
2711  		bpf_error(cstate, "'tcp' modifier applied to ip6 %s", typestr);
2712  	case Q_UDP:
2713  		bpf_error(cstate, "'udp' modifier applied to ip6 %s", typestr);
2714  	case Q_ICMP:
2715  		bpf_error(cstate, "'icmp' modifier applied to ip6 %s", typestr);
2716  	case Q_IGMP:
2717  		bpf_error(cstate, "'igmp' modifier applied to ip6 %s", typestr);
2718  	case Q_IGRP:
2719  		bpf_error(cstate, "'igrp' modifier applied to ip6 %s", typestr);
2720  	case Q_ATALK:
2721  		bpf_error(cstate, "AppleTalk modifier applied to ip6 %s", typestr);
2722  	case Q_DECNET:
2723  		bpf_error(cstate, "'decnet' modifier applied to ip6 %s", typestr);
2724  	case Q_LAT:
2725  		bpf_error(cstate, "'lat' modifier applied to ip6 %s", typestr);
2726  	case Q_SCA:
2727  		bpf_error(cstate, "'sca' modifier applied to ip6 %s", typestr);
2728  	case Q_MOPRC:
2729  		bpf_error(cstate, "'moprc' modifier applied to ip6 %s", typestr);
2730  	case Q_MOPDL:
2731  		bpf_error(cstate, "'mopdl' modifier applied to ip6 %s", typestr);
2732  	case Q_IPV6:
2733  		return gen_hostop6(cstate, addr, mask, dir, ETHERTYPE_IPV6, 8, 24);
2734  	case Q_ICMPV6:
2735  		bpf_error(cstate, "'icmp6' modifier applied to ip6 %s", typestr);
2736  	case Q_AH:
2737  		bpf_error(cstate, "'ah' modifier applied to ip6 %s", typestr);
2738  	case Q_ESP:
2739  		bpf_error(cstate, "'esp' modifier applied to ip6 %s", typestr);
2740  	case Q_PIM:
2741  		bpf_error(cstate, "'pim' modifier applied to ip6 %s", typestr);
2742  	case Q_VRRP:
2743  		bpf_error(cstate, "'vrrp' modifier applied to ip6 %s", typestr);
2744  	case Q_AARP:
2745  		bpf_error(cstate, "'aarp' modifier applied to ip6 %s", typestr);
2746  	case Q_ISO:
2747  		bpf_error(cstate, "'iso' modifier applied to ip6 %s", typestr);
2748  	case Q_ESIS:
2749  		bpf_error(cstate, "'esis' modifier applied to ip6 %s", typestr);
2750  	case Q_ISIS:
2751  		bpf_error(cstate, "'isis' modifier applied to ip6 %s", typestr);
2752  	case Q_CLNP:
2753  		bpf_error(cstate, "'clnp' modifier applied to ip6 %s", typestr);
2754  	case Q_STP:
2755  		bpf_error(cstate, "'stp' modifier applied to ip6 %s", typestr);
2756  	case Q_IPX:
2757  		bpf_error(cstate, "'ipx' modifier applied to ip6 %s", typestr);
2758  	case Q_NETBEUI:
2759  		bpf_error(cstate, "'netbeui' modifier applied to ip6 %s", typestr);
2760  	case Q_ISIS_L1:
2761  		bpf_error(cstate, "'l1' modifier applied to ip6 %s", typestr);
2762  	case Q_ISIS_L2:
2763  		bpf_error(cstate, "'l2' modifier applied to ip6 %s", typestr);
2764  	case Q_ISIS_IIH:
2765  		bpf_error(cstate, "'iih' modifier applied to ip6 %s", typestr);
2766  	case Q_ISIS_SNP:
2767  		bpf_error(cstate, "'snp' modifier applied to ip6 %s", typestr);
2768  	case Q_ISIS_CSNP:
2769  		bpf_error(cstate, "'csnp' modifier applied to ip6 %s", typestr);
2770  	case Q_ISIS_PSNP:
2771  		bpf_error(cstate, "'psnp' modifier applied to ip6 %s", typestr);
2772  	case Q_ISIS_LSP:
2773  		bpf_error(cstate, "'lsp' modifier applied to ip6 %s", typestr);
2774  	case Q_RADIO:
2775  		bpf_error(cstate, "'radio' modifier applied to ip6 %s", typestr);
2776  	case Q_CARP:
2777  		bpf_error(cstate, "'carp' modifier applied to ip6 %s", typestr);
2778  	default:
2779  		abort();
2780  	}
2781  }
2782  #endif
2783  #ifndef INET6
2784  static struct block *
2785  gen_gateway(compiler_state_t *cstate, const u_char *eaddr,
2786      struct addrinfo *alist, int proto, int dir)
2787  {
2788  	struct block *b0, *b1, *tmp;
2789  	struct addrinfo *ai;
2790  	struct sockaddr_in *sin;
2791  	if (dir != 0)
2792  		bpf_error(cstate, "direction applied to 'gateway'");
2793  	switch (proto) {
2794  	case Q_DEFAULT:
2795  	case Q_IP:
2796  	case Q_ARP:
2797  	case Q_RARP:
2798  		switch (cstate->linktype) {
2799  		case DLT_EN10MB:
2800  		case DLT_NETANALYZER:
2801  		case DLT_NETANALYZER_TRANSPARENT:
2802  			b1 = gen_prevlinkhdr_check(cstate);
2803  			b0 = gen_ehostop(cstate, eaddr, Q_OR);
2804  			if (b1 != NULL)
2805  				gen_and(b1, b0);
2806  			break;
2807  		case DLT_FDDI:
2808  			b0 = gen_fhostop(cstate, eaddr, Q_OR);
2809  			break;
2810  		case DLT_IEEE802:
2811  			b0 = gen_thostop(cstate, eaddr, Q_OR);
2812  			break;
2813  		case DLT_IEEE802_11:
2814  		case DLT_PRISM_HEADER:
2815  		case DLT_IEEE802_11_RADIO_AVS:
2816  		case DLT_IEEE802_11_RADIO:
2817  		case DLT_PPI:
2818  			b0 = gen_wlanhostop(cstate, eaddr, Q_OR);
2819  			break;
2820  		case DLT_SUNATM:
2821  			bpf_error(cstate,
2822  			    "'gateway' supported only on ethernet/FDDI/token ring/802.11/ATM LANE/Fibre Channel");
2823  			break;
2824  		case DLT_IP_OVER_FC:
2825  			b0 = gen_ipfchostop(cstate, eaddr, Q_OR);
2826  			break;
2827  		default:
2828  			bpf_error(cstate,
2829  			    "'gateway' supported only on ethernet/FDDI/token ring/802.11/ATM LANE/Fibre Channel");
2830  		}
2831  		b1 = NULL;
2832  		for (ai = alist; ai != NULL; ai = ai->ai_next) {
2833  			if (ai->ai_addr != NULL) {
2834  				if (ai->ai_addr->sa_family == AF_INET) {
2835  					sin = (struct sockaddr_in *)ai->ai_addr;
2836  					tmp = gen_host(cstate,
2837  					    ntohl(sin->sin_addr.s_addr),
2838  					    0xffffffff, proto, Q_OR, Q_HOST);
2839  					if (b1 == NULL) {
2840  						b1 = tmp;
2841  					} else {
2842  						gen_or(b1, tmp);
2843  						b1 = tmp;
2844  					}
2845  				}
2846  			}
2847  		}
2848  		if (b1 == NULL) {
2849  			return (NULL);
2850  		}
2851  		gen_not(b1);
2852  		gen_and(b0, b1);
2853  		return b1;
2854  	}
2855  	bpf_error(cstate, "illegal modifier of 'gateway'");
2856  }
2857  #endif
2858  static struct block *
2859  gen_proto_abbrev_internal(compiler_state_t *cstate, int proto)
2860  {
2861  	struct block *b0;
2862  	struct block *b1;
2863  	switch (proto) {
2864  	case Q_SCTP:
2865  		b1 = gen_proto(cstate, IPPROTO_SCTP, Q_DEFAULT, Q_DEFAULT);
2866  		break;
2867  	case Q_TCP:
2868  		b1 = gen_proto(cstate, IPPROTO_TCP, Q_DEFAULT, Q_DEFAULT);
2869  		break;
2870  	case Q_UDP:
2871  		b1 = gen_proto(cstate, IPPROTO_UDP, Q_DEFAULT, Q_DEFAULT);
2872  		break;
2873  	case Q_ICMP:
2874  		b1 = gen_proto(cstate, IPPROTO_ICMP, Q_IP, Q_DEFAULT);
2875  		break;
2876  #ifndef	IPPROTO_IGMP
2877  #define	IPPROTO_IGMP	2
2878  #endif
2879  	case Q_IGMP:
2880  		b1 = gen_proto(cstate, IPPROTO_IGMP, Q_IP, Q_DEFAULT);
2881  		break;
2882  #ifndef	IPPROTO_IGRP
2883  #define	IPPROTO_IGRP	9
2884  #endif
2885  	case Q_IGRP:
2886  		b1 = gen_proto(cstate, IPPROTO_IGRP, Q_IP, Q_DEFAULT);
2887  		break;
2888  #ifndef IPPROTO_PIM
2889  #define IPPROTO_PIM	103
2890  #endif
2891  	case Q_PIM:
2892  		b1 = gen_proto(cstate, IPPROTO_PIM, Q_DEFAULT, Q_DEFAULT);
2893  		break;
2894  #ifndef IPPROTO_VRRP
2895  #define IPPROTO_VRRP	112
2896  #endif
2897  	case Q_VRRP:
2898  		b1 = gen_proto(cstate, IPPROTO_VRRP, Q_IP, Q_DEFAULT);
2899  		break;
2900  #ifndef IPPROTO_CARP
2901  #define IPPROTO_CARP	112
2902  #endif
2903  	case Q_CARP:
2904  		b1 = gen_proto(cstate, IPPROTO_CARP, Q_IP, Q_DEFAULT);
2905  		break;
2906  	case Q_IP:
2907  		b1 = gen_linktype(cstate, ETHERTYPE_IP);
2908  		break;
2909  	case Q_ARP:
2910  		b1 = gen_linktype(cstate, ETHERTYPE_ARP);
2911  		break;
2912  	case Q_RARP:
2913  		b1 = gen_linktype(cstate, ETHERTYPE_REVARP);
2914  		break;
2915  	case Q_LINK:
2916  		bpf_error(cstate, "link layer applied in wrong context");
2917  	case Q_ATALK:
2918  		b1 = gen_linktype(cstate, ETHERTYPE_ATALK);
2919  		break;
2920  	case Q_AARP:
2921  		b1 = gen_linktype(cstate, ETHERTYPE_AARP);
2922  		break;
2923  	case Q_DECNET:
2924  		b1 = gen_linktype(cstate, ETHERTYPE_DN);
2925  		break;
2926  	case Q_SCA:
2927  		b1 = gen_linktype(cstate, ETHERTYPE_SCA);
2928  		break;
2929  	case Q_LAT:
2930  		b1 = gen_linktype(cstate, ETHERTYPE_LAT);
2931  		break;
2932  	case Q_MOPDL:
2933  		b1 = gen_linktype(cstate, ETHERTYPE_MOPDL);
2934  		break;
2935  	case Q_MOPRC:
2936  		b1 = gen_linktype(cstate, ETHERTYPE_MOPRC);
2937  		break;
2938  	case Q_IPV6:
2939  		b1 = gen_linktype(cstate, ETHERTYPE_IPV6);
2940  		break;
2941  #ifndef IPPROTO_ICMPV6
2942  #define IPPROTO_ICMPV6	58
2943  #endif
2944  	case Q_ICMPV6:
2945  		b1 = gen_proto(cstate, IPPROTO_ICMPV6, Q_IPV6, Q_DEFAULT);
2946  		break;
2947  #ifndef IPPROTO_AH
2948  #define IPPROTO_AH	51
2949  #endif
2950  	case Q_AH:
2951  		b1 = gen_proto(cstate, IPPROTO_AH, Q_DEFAULT, Q_DEFAULT);
2952  		break;
2953  #ifndef IPPROTO_ESP
2954  #define IPPROTO_ESP	50
2955  #endif
2956  	case Q_ESP:
2957  		b1 = gen_proto(cstate, IPPROTO_ESP, Q_DEFAULT, Q_DEFAULT);
2958  		break;
2959  	case Q_ISO:
2960  		b1 = gen_linktype(cstate, LLCSAP_ISONS);
2961  		break;
2962  	case Q_ESIS:
2963  		b1 = gen_proto(cstate, ISO9542_ESIS, Q_ISO, Q_DEFAULT);
2964  		break;
2965  	case Q_ISIS:
2966  		b1 = gen_proto(cstate, ISO10589_ISIS, Q_ISO, Q_DEFAULT);
2967  		break;
2968  	case Q_ISIS_L1: &bsol;* all IS-IS Level1 PDU-Types */
2969  		b0 = gen_proto(cstate, ISIS_L1_LAN_IIH, Q_ISIS, Q_DEFAULT);
2970  		b1 = gen_proto(cstate, ISIS_PTP_IIH, Q_ISIS, Q_DEFAULT); &bsol;* FIXME extract the circuit-type bits */
2971  		gen_or(b0, b1);
2972  		b0 = gen_proto(cstate, ISIS_L1_LSP, Q_ISIS, Q_DEFAULT);
2973  		gen_or(b0, b1);
2974  		b0 = gen_proto(cstate, ISIS_L1_CSNP, Q_ISIS, Q_DEFAULT);
2975  		gen_or(b0, b1);
2976  		b0 = gen_proto(cstate, ISIS_L1_PSNP, Q_ISIS, Q_DEFAULT);
2977  		gen_or(b0, b1);
2978  		break;
2979  	case Q_ISIS_L2: &bsol;* all IS-IS Level2 PDU-Types */
2980  		b0 = gen_proto(cstate, ISIS_L2_LAN_IIH, Q_ISIS, Q_DEFAULT);
2981  		b1 = gen_proto(cstate, ISIS_PTP_IIH, Q_ISIS, Q_DEFAULT); &bsol;* FIXME extract the circuit-type bits */
2982  		gen_or(b0, b1);
2983  		b0 = gen_proto(cstate, ISIS_L2_LSP, Q_ISIS, Q_DEFAULT);
2984  		gen_or(b0, b1);
2985  		b0 = gen_proto(cstate, ISIS_L2_CSNP, Q_ISIS, Q_DEFAULT);
2986  		gen_or(b0, b1);
2987  		b0 = gen_proto(cstate, ISIS_L2_PSNP, Q_ISIS, Q_DEFAULT);
2988  		gen_or(b0, b1);
2989  		break;
2990  	case Q_ISIS_IIH: &bsol;* all IS-IS Hello PDU-Types */
2991  		b0 = gen_proto(cstate, ISIS_L1_LAN_IIH, Q_ISIS, Q_DEFAULT);
2992  		b1 = gen_proto(cstate, ISIS_L2_LAN_IIH, Q_ISIS, Q_DEFAULT);
2993  		gen_or(b0, b1);
2994  		b0 = gen_proto(cstate, ISIS_PTP_IIH, Q_ISIS, Q_DEFAULT);
2995  		gen_or(b0, b1);
2996  		break;
2997  	case Q_ISIS_LSP:
2998  		b0 = gen_proto(cstate, ISIS_L1_LSP, Q_ISIS, Q_DEFAULT);
2999  		b1 = gen_proto(cstate, ISIS_L2_LSP, Q_ISIS, Q_DEFAULT);
3000  		gen_or(b0, b1);
3001  		break;
3002  	case Q_ISIS_SNP:
3003  		b0 = gen_proto(cstate, ISIS_L1_CSNP, Q_ISIS, Q_DEFAULT);
3004  		b1 = gen_proto(cstate, ISIS_L2_CSNP, Q_ISIS, Q_DEFAULT);
3005  		gen_or(b0, b1);
3006  		b0 = gen_proto(cstate, ISIS_L1_PSNP, Q_ISIS, Q_DEFAULT);
3007  		gen_or(b0, b1);
3008  		b0 = gen_proto(cstate, ISIS_L2_PSNP, Q_ISIS, Q_DEFAULT);
3009  		gen_or(b0, b1);
3010  		break;
3011  	case Q_ISIS_CSNP:
3012  		b0 = gen_proto(cstate, ISIS_L1_CSNP, Q_ISIS, Q_DEFAULT);
3013  		b1 = gen_proto(cstate, ISIS_L2_CSNP, Q_ISIS, Q_DEFAULT);
3014  		gen_or(b0, b1);
3015  		break;
3016  	case Q_ISIS_PSNP:
3017  		b0 = gen_proto(cstate, ISIS_L1_PSNP, Q_ISIS, Q_DEFAULT);
3018  		b1 = gen_proto(cstate, ISIS_L2_PSNP, Q_ISIS, Q_DEFAULT);
3019  		gen_or(b0, b1);
3020  		break;
3021  	case Q_CLNP:
3022  		b1 = gen_proto(cstate, ISO8473_CLNP, Q_ISO, Q_DEFAULT);
3023  		break;
3024  	case Q_STP:
3025  		b1 = gen_linktype(cstate, LLCSAP_8021D);
3026  		break;
3027  	case Q_IPX:
3028  		b1 = gen_linktype(cstate, LLCSAP_IPX);
3029  		break;
3030  	case Q_NETBEUI:
3031  		b1 = gen_linktype(cstate, LLCSAP_NETBEUI);
3032  		break;
3033  	case Q_RADIO:
3034  		bpf_error(cstate, "'radio' is not a valid protocol type");
3035  	default:
3036  		abort();
3037  	}
3038  	return b1;
3039  }
3040  struct block *
3041  gen_proto_abbrev(compiler_state_t *cstate, int proto)
3042  {
3043  	if (setjmp(cstate->top_ctx))
3044  		return (NULL);
3045  	return gen_proto_abbrev_internal(cstate, proto);
3046  }
3047  static struct block *
3048  gen_ipfrag(compiler_state_t *cstate)
3049  {
3050  	struct slist *s;
3051  	struct block *b;
3052  	s = gen_load_a(cstate, OR_LINKPL, 6, BPF_H);
3053  	b = new_block(cstate, JMP(BPF_JSET));
3054  	b->s.k = 0x1fff;
3055  	b->stmts = s;
3056  	gen_not(b);
3057  	return b;
3058  }
3059  static struct block *
3060  gen_portatom(compiler_state_t *cstate, int off, bpf_u_int32 v)
3061  {
3062  	return gen_cmp(cstate, OR_TRAN_IPV4, off, BPF_H, v);
3063  }
3064  static struct block *
3065  gen_portatom6(compiler_state_t *cstate, int off, bpf_u_int32 v)
3066  {
3067  	return gen_cmp(cstate, OR_TRAN_IPV6, off, BPF_H, v);
3068  }
3069  static struct block *
3070  gen_portop(compiler_state_t *cstate, u_int port, u_int proto, int dir)
3071  {
3072  	struct block *b0, *b1, *tmp;
3073  	tmp = gen_cmp(cstate, OR_LINKPL, 9, BPF_B, proto);
3074  	b0 = gen_ipfrag(cstate);
3075  	gen_and(tmp, b0);
3076  	switch (dir) {
3077  	case Q_SRC:
3078  		b1 = gen_portatom(cstate, 0, port);
3079  		break;
3080  	case Q_DST:
3081  		b1 = gen_portatom(cstate, 2, port);
3082  		break;
3083  	case Q_AND:
3084  		tmp = gen_portatom(cstate, 0, port);
3085  		b1 = gen_portatom(cstate, 2, port);
3086  		gen_and(tmp, b1);
3087  		break;
3088  	case Q_DEFAULT:
3089  	case Q_OR:
3090  		tmp = gen_portatom(cstate, 0, port);
3091  		b1 = gen_portatom(cstate, 2, port);
3092  		gen_or(tmp, b1);
3093  		break;
3094  	case Q_ADDR1:
3095  		bpf_error(cstate, "'addr1' and 'address1' are not valid qualifiers for ports");
3096  	case Q_ADDR2:
3097  		bpf_error(cstate, "'addr2' and 'address2' are not valid qualifiers for ports");
3098  	case Q_ADDR3:
3099  		bpf_error(cstate, "'addr3' and 'address3' are not valid qualifiers for ports");
3100  	case Q_ADDR4:
3101  		bpf_error(cstate, "'addr4' and 'address4' are not valid qualifiers for ports");
3102  	case Q_RA:
3103  		bpf_error(cstate, "'ra' is not a valid qualifier for ports");
3104  	case Q_TA:
3105  		bpf_error(cstate, "'ta' is not a valid qualifier for ports");
3106  	default:
3107  		abort();
3108  	}
3109  	gen_and(b0, b1);
3110  	return b1;
3111  }
3112  static struct block *
3113  gen_port(compiler_state_t *cstate, u_int port, int ip_proto, int dir)
3114  {
3115  	struct block *b0, *b1, *tmp;
3116  	b0 = gen_linktype(cstate, ETHERTYPE_IP);
3117  	switch (ip_proto) {
3118  	case IPPROTO_UDP:
3119  	case IPPROTO_TCP:
3120  	case IPPROTO_SCTP:
3121  		b1 = gen_portop(cstate, port, (u_int)ip_proto, dir);
3122  		break;
3123  	case PROTO_UNDEF:
3124  		tmp = gen_portop(cstate, port, IPPROTO_TCP, dir);
3125  		b1 = gen_portop(cstate, port, IPPROTO_UDP, dir);
3126  		gen_or(tmp, b1);
3127  		tmp = gen_portop(cstate, port, IPPROTO_SCTP, dir);
3128  		gen_or(tmp, b1);
3129  		break;
3130  	default:
3131  		abort();
3132  	}
3133  	gen_and(b0, b1);
3134  	return b1;
3135  }
3136  struct block *
3137  gen_portop6(compiler_state_t *cstate, u_int port, u_int proto, int dir)
3138  {
3139  	struct block *b0, *b1, *tmp;
3140  	b0 = gen_cmp(cstate, OR_LINKPL, 6, BPF_B, proto);
3141  	switch (dir) {
3142  	case Q_SRC:
3143  		b1 = gen_portatom6(cstate, 0, port);
3144  		break;
3145  	case Q_DST:
3146  		b1 = gen_portatom6(cstate, 2, port);
3147  		break;
3148  	case Q_AND:
3149  		tmp = gen_portatom6(cstate, 0, port);
3150  		b1 = gen_portatom6(cstate, 2, port);
3151  		gen_and(tmp, b1);
3152  		break;
3153  	case Q_DEFAULT:
3154  	case Q_OR:
3155  		tmp = gen_portatom6(cstate, 0, port);
3156  		b1 = gen_portatom6(cstate, 2, port);
3157  		gen_or(tmp, b1);
3158  		break;
3159  	default:
3160  		abort();
3161  	}
3162  	gen_and(b0, b1);
3163  	return b1;
3164  }
3165  static struct block *
3166  gen_port6(compiler_state_t *cstate, u_int port, int ip_proto, int dir)
3167  {
3168  	struct block *b0, *b1, *tmp;
3169  	b0 = gen_linktype(cstate, ETHERTYPE_IPV6);
3170  	switch (ip_proto) {
3171  	case IPPROTO_UDP:
3172  	case IPPROTO_TCP:
3173  	case IPPROTO_SCTP:
3174  		b1 = gen_portop6(cstate, port, (u_int)ip_proto, dir);
3175  		break;
3176  	case PROTO_UNDEF:
3177  		tmp = gen_portop6(cstate, port, IPPROTO_TCP, dir);
3178  		b1 = gen_portop6(cstate, port, IPPROTO_UDP, dir);
3179  		gen_or(tmp, b1);
3180  		tmp = gen_portop6(cstate, port, IPPROTO_SCTP, dir);
3181  		gen_or(tmp, b1);
3182  		break;
3183  	default:
3184  		abort();
3185  	}
3186  	gen_and(b0, b1);
3187  	return b1;
3188  }
3189  static struct block *
3190  gen_portrangeatom(compiler_state_t *cstate, u_int off, bpf_u_int32 v1,
3191      bpf_u_int32 v2)
3192  {
3193  	struct block *b1, *b2;
3194  	if (v1 > v2) {
3195  		bpf_u_int32 vtemp;
3196  		vtemp = v1;
3197  		v1 = v2;
3198  		v2 = vtemp;
3199  	}
3200  	b1 = gen_cmp_ge(cstate, OR_TRAN_IPV4, off, BPF_H, v1);
3201  	b2 = gen_cmp_le(cstate, OR_TRAN_IPV4, off, BPF_H, v2);
3202  	gen_and(b1, b2);
3203  	return b2;
3204  }
3205  static struct block *
3206  gen_portrangeop(compiler_state_t *cstate, u_int port1, u_int port2,
3207      bpf_u_int32 proto, int dir)
3208  {
3209  	struct block *b0, *b1, *tmp;
3210  	tmp = gen_cmp(cstate, OR_LINKPL, 9, BPF_B, proto);
3211  	b0 = gen_ipfrag(cstate);
3212  	gen_and(tmp, b0);
3213  	switch (dir) {
3214  	case Q_SRC:
3215  		b1 = gen_portrangeatom(cstate, 0, port1, port2);
3216  		break;
3217  	case Q_DST:
3218  		b1 = gen_portrangeatom(cstate, 2, port1, port2);
3219  		break;
3220  	case Q_AND:
3221  		tmp = gen_portrangeatom(cstate, 0, port1, port2);
3222  		b1 = gen_portrangeatom(cstate, 2, port1, port2);
3223  		gen_and(tmp, b1);
3224  		break;
3225  	case Q_DEFAULT:
3226  	case Q_OR:
3227  		tmp = gen_portrangeatom(cstate, 0, port1, port2);
3228  		b1 = gen_portrangeatom(cstate, 2, port1, port2);
3229  		gen_or(tmp, b1);
3230  		break;
3231  	case Q_ADDR1:
3232  		bpf_error(cstate, "'addr1' and 'address1' are not valid qualifiers for port ranges");
3233  	case Q_ADDR2:
3234  		bpf_error(cstate, "'addr2' and 'address2' are not valid qualifiers for port ranges");
3235  	case Q_ADDR3:
3236  		bpf_error(cstate, "'addr3' and 'address3' are not valid qualifiers for port ranges");
3237  	case Q_ADDR4:
3238  		bpf_error(cstate, "'addr4' and 'address4' are not valid qualifiers for port ranges");
3239  	case Q_RA:
3240  		bpf_error(cstate, "'ra' is not a valid qualifier for port ranges");
3241  	case Q_TA:
3242  		bpf_error(cstate, "'ta' is not a valid qualifier for port ranges");
3243  	default:
3244  		abort();
3245  	}
3246  	gen_and(b0, b1);
3247  	return b1;
3248  }
3249  static struct block *
3250  gen_portrange(compiler_state_t *cstate, u_int port1, u_int port2, int ip_proto,
3251      int dir)
3252  {
3253  	struct block *b0, *b1, *tmp;
3254  	b0 = gen_linktype(cstate, ETHERTYPE_IP);
3255  	switch (ip_proto) {
3256  	case IPPROTO_UDP:
3257  	case IPPROTO_TCP:
3258  	case IPPROTO_SCTP:
3259  		b1 = gen_portrangeop(cstate, port1, port2, (bpf_u_int32)ip_proto,
3260  		    dir);
3261  		break;
3262  	case PROTO_UNDEF:
3263  		tmp = gen_portrangeop(cstate, port1, port2, IPPROTO_TCP, dir);
3264  		b1 = gen_portrangeop(cstate, port1, port2, IPPROTO_UDP, dir);
3265  		gen_or(tmp, b1);
3266  		tmp = gen_portrangeop(cstate, port1, port2, IPPROTO_SCTP, dir);
3267  		gen_or(tmp, b1);
3268  		break;
3269  	default:
3270  		abort();
3271  	}
3272  	gen_and(b0, b1);
3273  	return b1;
3274  }
3275  static struct block *
3276  gen_portrangeatom6(compiler_state_t *cstate, u_int off, bpf_u_int32 v1,
3277      bpf_u_int32 v2)
3278  {
3279  	struct block *b1, *b2;
3280  	if (v1 > v2) {
3281  		bpf_u_int32 vtemp;
3282  		vtemp = v1;
3283  		v1 = v2;
3284  		v2 = vtemp;
3285  	}
3286  	b1 = gen_cmp_ge(cstate, OR_TRAN_IPV6, off, BPF_H, v1);
3287  	b2 = gen_cmp_le(cstate, OR_TRAN_IPV6, off, BPF_H, v2);
3288  	gen_and(b1, b2);
3289  	return b2;
3290  }
3291  static struct block *
3292  gen_portrangeop6(compiler_state_t *cstate, u_int port1, u_int port2,
3293      bpf_u_int32 proto, int dir)
3294  {
3295  	struct block *b0, *b1, *tmp;
3296  	b0 = gen_cmp(cstate, OR_LINKPL, 6, BPF_B, proto);
3297  	switch (dir) {
3298  	case Q_SRC:
3299  		b1 = gen_portrangeatom6(cstate, 0, port1, port2);
3300  		break;
3301  	case Q_DST:
3302  		b1 = gen_portrangeatom6(cstate, 2, port1, port2);
3303  		break;
3304  	case Q_AND:
3305  		tmp = gen_portrangeatom6(cstate, 0, port1, port2);
3306  		b1 = gen_portrangeatom6(cstate, 2, port1, port2);
3307  		gen_and(tmp, b1);
3308  		break;
3309  	case Q_DEFAULT:
3310  	case Q_OR:
3311  		tmp = gen_portrangeatom6(cstate, 0, port1, port2);
3312  		b1 = gen_portrangeatom6(cstate, 2, port1, port2);
3313  		gen_or(tmp, b1);
3314  		break;
3315  	default:
3316  		abort();
3317  	}
3318  	gen_and(b0, b1);
3319  	return b1;
3320  }
3321  static struct block *
3322  gen_portrange6(compiler_state_t *cstate, u_int port1, u_int port2, int ip_proto,
3323      int dir)
3324  {
3325  	struct block *b0, *b1, *tmp;
3326  	b0 = gen_linktype(cstate, ETHERTYPE_IPV6);
3327  	switch (ip_proto) {
3328  	case IPPROTO_UDP:
3329  	case IPPROTO_TCP:
3330  	case IPPROTO_SCTP:
3331  		b1 = gen_portrangeop6(cstate, port1, port2, (bpf_u_int32)ip_proto,
3332  		    dir);
3333  		break;
3334  	case PROTO_UNDEF:
3335  		tmp = gen_portrangeop6(cstate, port1, port2, IPPROTO_TCP, dir);
3336  		b1 = gen_portrangeop6(cstate, port1, port2, IPPROTO_UDP, dir);
3337  		gen_or(tmp, b1);
3338  		tmp = gen_portrangeop6(cstate, port1, port2, IPPROTO_SCTP, dir);
3339  		gen_or(tmp, b1);
3340  		break;
3341  	default:
3342  		abort();
3343  	}
3344  	gen_and(b0, b1);
3345  	return b1;
3346  }
3347  static int
3348  lookup_proto(compiler_state_t *cstate, const char *name, int proto)
3349  {
3350  	register int v;
3351  	switch (proto) {
3352  	case Q_DEFAULT:
3353  	case Q_IP:
3354  	case Q_IPV6:
3355  		v = pcap_nametoproto(name);
3356  		if (v == PROTO_UNDEF)
3357  			bpf_error(cstate, "unknown ip proto '%s'", name);
3358  		break;
3359  	case Q_LINK:
3360  		v = pcap_nametoeproto(name);
3361  		if (v == PROTO_UNDEF) {
3362  			v = pcap_nametollc(name);
3363  			if (v == PROTO_UNDEF)
3364  				bpf_error(cstate, "unknown ether proto '%s'", name);
3365  		}
3366  		break;
3367  	case Q_ISO:
3368  		if (strcmp(name, "esis") == 0)
3369  			v = ISO9542_ESIS;
3370  		else if (strcmp(name, "isis") == 0)
3371  			v = ISO10589_ISIS;
3372  		else if (strcmp(name, "clnp") == 0)
3373  			v = ISO8473_CLNP;
3374  		else
3375  			bpf_error(cstate, "unknown osi proto '%s'", name);
3376  		break;
3377  	default:
3378  		v = PROTO_UNDEF;
3379  		break;
3380  	}
3381  	return v;
3382  }
3383  #if !defined(NO_PROTOCHAIN)
3384  static struct block *
3385  gen_protochain(compiler_state_t *cstate, bpf_u_int32 v, int proto)
3386  {
3387  	struct block *b0, *b;
3388  	struct slist *s[100];
3389  	int fix2, fix3, fix4, fix5;
3390  	int ahcheck, again, end;
3391  	int i, max;
3392  	int reg2 = alloc_reg(cstate);
3393  	memset(s, 0, sizeof(s));
3394  	fix3 = fix4 = fix5 = 0;
3395  	switch (proto) {
3396  	case Q_IP:
3397  	case Q_IPV6:
3398  		break;
3399  	case Q_DEFAULT:
3400  		b0 = gen_protochain(cstate, v, Q_IP);
3401  		b = gen_protochain(cstate, v, Q_IPV6);
3402  		gen_or(b0, b);
3403  		return b;
3404  	default:
3405  		bpf_error(cstate, "bad protocol applied for 'protochain'");
3406  	}
3407  	if (cstate->off_linkpl.is_variable)
3408  		bpf_error(cstate, "'protochain' not supported with variable length headers");
3409  	cstate->no_optimize = 1;
3410  	i = 0;
3411  	s[i] = new_stmt(cstate, 0);	&bsol;*dummy*/
3412  	i++;
3413  	switch (proto) {
3414  	case Q_IP:
3415  		b0 = gen_linktype(cstate, ETHERTYPE_IP);
3416  		s[i] = new_stmt(cstate, BPF_LD|BPF_ABS|BPF_B);
3417  		s[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + 9;
3418  		i++;
3419  		s[i] = new_stmt(cstate, BPF_LDX|BPF_MSH|BPF_B);
3420  		s[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;
3421  		i++;
3422  		break;
3423  	case Q_IPV6:
3424  		b0 = gen_linktype(cstate, ETHERTYPE_IPV6);
3425  		s[i] = new_stmt(cstate, BPF_LD|BPF_ABS|BPF_B);
3426  		s[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + 6;
3427  		i++;
3428  		s[i] = new_stmt(cstate, BPF_LDX|BPF_IMM);
3429  		s[i]->s.k = 40;
3430  		i++;
3431  		break;
3432  	default:
3433  		bpf_error(cstate, "unsupported proto to gen_protochain");
3434  	}
3435  	again = i;
3436  	s[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);
3437  	s[i]->s.k = v;
3438  	s[i]->s.jt = NULL;		&bsol;*later*/
3439  	s[i]->s.jf = NULL;		&bsol;*update in next stmt*/
3440  	fix5 = i;
3441  	i++;
3442  #ifndef IPPROTO_NONE
3443  #define IPPROTO_NONE	59
3444  #endif
3445  	s[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);
3446  	s[i]->s.jt = NULL;	&bsol;*later*/
3447  	s[i]->s.jf = NULL;	&bsol;*update in next stmt*/
3448  	s[i]->s.k = IPPROTO_NONE;
3449  	s[fix5]->s.jf = s[i];
3450  	fix2 = i;
3451  	i++;
3452  	if (proto == Q_IPV6) {
3453  		int v6start, v6end, v6advance, j;
3454  		v6start = i;
3455  		s[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);
3456  		s[i]->s.jt = NULL;	&bsol;*later*/
3457  		s[i]->s.jf = NULL;	&bsol;*update in next stmt*/
3458  		s[i]->s.k = IPPROTO_HOPOPTS;
3459  		s[fix2]->s.jf = s[i];
3460  		i++;
3461  		s[i - 1]->s.jf = s[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);
3462  		s[i]->s.jt = NULL;	&bsol;*later*/
3463  		s[i]->s.jf = NULL;	&bsol;*update in next stmt*/
3464  		s[i]->s.k = IPPROTO_DSTOPTS;
3465  		i++;
3466  		s[i - 1]->s.jf = s[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);
3467  		s[i]->s.jt = NULL;	&bsol;*later*/
3468  		s[i]->s.jf = NULL;	&bsol;*update in next stmt*/
3469  		s[i]->s.k = IPPROTO_ROUTING;
3470  		i++;
3471  		s[i - 1]->s.jf = s[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);
3472  		s[i]->s.jt = NULL;	&bsol;*later*/
3473  		s[i]->s.jf = NULL;	&bsol;*later*/
3474  		s[i]->s.k = IPPROTO_FRAGMENT;
3475  		fix3 = i;
3476  		v6end = i;
3477  		i++;
3478  		v6advance = i;
3479  		s[i] = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);
3480  		s[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;
3481  		i++;
3482  		s[i] = new_stmt(cstate, BPF_ST);
3483  		s[i]->s.k = reg2;
3484  		i++;
3485  		s[i] = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);
3486  		s[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + 1;
3487  		i++;
3488  		s[i] = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);
3489  		s[i]->s.k = 1;
3490  		i++;
3491  		s[i] = new_stmt(cstate, BPF_ALU|BPF_MUL|BPF_K);
3492  		s[i]->s.k = 8;
3493  		i++;
3494  		s[i] = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X);
3495  		s[i]->s.k = 0;
3496  		i++;
3497  		s[i] = new_stmt(cstate, BPF_MISC|BPF_TAX);
3498  		i++;
3499  		s[i] = new_stmt(cstate, BPF_LD|BPF_MEM);
3500  		s[i]->s.k = reg2;
3501  		i++;
3502  		s[i] = new_stmt(cstate, BPF_JMP|BPF_JA);
3503  		s[i]->s.k = again - i - 1;
3504  		s[i - 1]->s.jf = s[i];
3505  		i++;
3506  		for (j = v6start; j <= v6end; j++)
3507  			s[j]->s.jt = s[v6advance];
3508  	} else {
3509  		s[i] = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);
3510  		s[i]->s.k = 0;
3511  		s[fix2]->s.jf = s[i];
3512  		i++;
3513  	}
3514  	ahcheck = i;
3515  	s[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);
3516  	s[i]->s.jt = NULL;	&bsol;*later*/
3517  	s[i]->s.jf = NULL;	&bsol;*later*/
3518  	s[i]->s.k = IPPROTO_AH;
3519  	if (fix3)
3520  		s[fix3]->s.jf = s[ahcheck];
3521  	fix4 = i;
3522  	i++;
3523  	s[i - 1]->s.jt = s[i] = new_stmt(cstate, BPF_MISC|BPF_TXA);
3524  	i++;
3525  	s[i] = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);
3526  	s[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;
3527  	i++;
3528  	s[i] = new_stmt(cstate, BPF_ST);
3529  	s[i]->s.k = reg2;
3530  	i++;
3531  	s[i - 1]->s.jt = s[i] = new_stmt(cstate, BPF_MISC|BPF_TXA);
3532  	i++;
3533  	s[i] = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);
3534  	s[i]->s.k = 1;
3535  	i++;
3536  	s[i] = new_stmt(cstate, BPF_MISC|BPF_TAX);
3537  	i++;
3538  	s[i] = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);
3539  	s[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;
3540  	i++;
3541  	s[i] = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);
3542  	s[i]->s.k = 2;
3543  	i++;
3544  	s[i] = new_stmt(cstate, BPF_ALU|BPF_MUL|BPF_K);
3545  	s[i]->s.k = 4;
3546  	i++;
3547  	s[i] = new_stmt(cstate, BPF_MISC|BPF_TAX);
3548  	i++;
3549  	s[i] = new_stmt(cstate, BPF_LD|BPF_MEM);
3550  	s[i]->s.k = reg2;
3551  	i++;
3552  	s[i] = new_stmt(cstate, BPF_JMP|BPF_JA);
3553  	s[i]->s.k = again - i - 1;
3554  	i++;
3555  	end = i;
3556  	s[i] = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);
3557  	s[i]->s.k = 0;
3558  	s[fix2]->s.jt = s[end];
3559  	s[fix4]->s.jf = s[end];
3560  	s[fix5]->s.jt = s[end];
3561  	i++;
3562  	max = i;
3563  	for (i = 0; i < max - 1; i++)
3564  		s[i]->next = s[i + 1];
3565  	s[max - 1]->next = NULL;
3566  	b = new_block(cstate, JMP(BPF_JEQ));
3567  	b->stmts = s[1];	&bsol;*remember, s[0] is dummy*/
3568  	b->s.k = v;
3569  	free_reg(cstate, reg2);
3570  	gen_and(b0, b);
3571  	return b;
3572  }
3573  #endif &bsol;* !defined(NO_PROTOCHAIN) */
3574  static struct block *
3575  gen_check_802_11_data_frame(compiler_state_t *cstate)
3576  {
3577  	struct slist *s;
3578  	struct block *b0, *b1;
3579  	s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
3580  	b0 = new_block(cstate, JMP(BPF_JSET));
3581  	b0->s.k = 0x08;
3582  	b0->stmts = s;
3583  	s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
3584  	b1 = new_block(cstate, JMP(BPF_JSET));
3585  	b1->s.k = 0x04;
3586  	b1->stmts = s;
3587  	gen_not(b1);
3588  	gen_and(b1, b0);
3589  	return b0;
3590  }
3591  static struct block *
3592  gen_proto(compiler_state_t *cstate, bpf_u_int32 v, int proto, int dir)
3593  {
3594  	struct block *b0, *b1;
3595  	struct block *b2;
3596  	if (dir != Q_DEFAULT)
3597  		bpf_error(cstate, "direction applied to 'proto'");
3598  	switch (proto) {
3599  	case Q_DEFAULT:
3600  		b0 = gen_proto(cstate, v, Q_IP, dir);
3601  		b1 = gen_proto(cstate, v, Q_IPV6, dir);
3602  		gen_or(b0, b1);
3603  		return b1;
3604  	case Q_LINK:
3605  		return gen_linktype(cstate, v);
3606  	case Q_IP:
3607  		b0 = gen_linktype(cstate, ETHERTYPE_IP);
3608  		b1 = gen_cmp(cstate, OR_LINKPL, 9, BPF_B, v);
3609  		gen_and(b0, b1);
3610  		return b1;
3611  	case Q_ARP:
3612  		bpf_error(cstate, "arp does not encapsulate another protocol");
3613  	case Q_RARP:
3614  		bpf_error(cstate, "rarp does not encapsulate another protocol");
3615  	case Q_SCTP:
3616  		bpf_error(cstate, "'sctp proto' is bogus");
3617  	case Q_TCP:
3618  		bpf_error(cstate, "'tcp proto' is bogus");
3619  	case Q_UDP:
3620  		bpf_error(cstate, "'udp proto' is bogus");
3621  	case Q_ICMP:
3622  		bpf_error(cstate, "'icmp proto' is bogus");
3623  	case Q_IGMP:
3624  		bpf_error(cstate, "'igmp proto' is bogus");
3625  	case Q_IGRP:
3626  		bpf_error(cstate, "'igrp proto' is bogus");
3627  	case Q_ATALK:
3628  		bpf_error(cstate, "AppleTalk encapsulation is not specifiable");
3629  	case Q_DECNET:
3630  		bpf_error(cstate, "DECNET encapsulation is not specifiable");
3631  	case Q_LAT:
3632  		bpf_error(cstate, "LAT does not encapsulate another protocol");
3633  	case Q_SCA:
3634  		bpf_error(cstate, "SCA does not encapsulate another protocol");
3635  	case Q_MOPRC:
3636  		bpf_error(cstate, "MOPRC does not encapsulate another protocol");
3637  	case Q_MOPDL:
3638  		bpf_error(cstate, "MOPDL does not encapsulate another protocol");
3639  	case Q_IPV6:
3640  		b0 = gen_linktype(cstate, ETHERTYPE_IPV6);
3641  		b2 = gen_cmp(cstate, OR_LINKPL, 6, BPF_B, IPPROTO_FRAGMENT);
3642  		b1 = gen_cmp(cstate, OR_LINKPL, 40, BPF_B, v);
3643  		gen_and(b2, b1);
3644  		b2 = gen_cmp(cstate, OR_LINKPL, 6, BPF_B, v);
3645  		gen_or(b2, b1);
3646  		gen_and(b0, b1);
3647  		return b1;
3648  	case Q_ICMPV6:
3649  		bpf_error(cstate, "'icmp6 proto' is bogus");
3650  	case Q_AH:
3651  		bpf_error(cstate, "'ah proto' is bogus");
3652  	case Q_ESP:
3653  		bpf_error(cstate, "'esp proto' is bogus");
3654  	case Q_PIM:
3655  		bpf_error(cstate, "'pim proto' is bogus");
3656  	case Q_VRRP:
3657  		bpf_error(cstate, "'vrrp proto' is bogus");
3658  	case Q_AARP:
3659  		bpf_error(cstate, "'aarp proto' is bogus");
3660  	case Q_ISO:
3661  		switch (cstate->linktype) {
3662  		case DLT_FRELAY:
3663  			return gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | v);
3664  		case DLT_C_HDLC:
3665  		case DLT_HDLC:
3666  			b0 = gen_linktype(cstate, LLCSAP_ISONS<<8 | LLCSAP_ISONS);
3667  			b1 = gen_cmp(cstate, OR_LINKPL_NOSNAP, 1, BPF_B, v);
3668  			gen_and(b0, b1);
3669  			return b1;
3670  		default:
3671  			b0 = gen_linktype(cstate, LLCSAP_ISONS);
3672  			b1 = gen_cmp(cstate, OR_LINKPL_NOSNAP, 0, BPF_B, v);
3673  			gen_and(b0, b1);
3674  			return b1;
3675  		}
3676  	case Q_ESIS:
3677  		bpf_error(cstate, "'esis proto' is bogus");
3678  	case Q_ISIS:
3679  		b0 = gen_proto(cstate, ISO10589_ISIS, Q_ISO, Q_DEFAULT);
3680  		b1 = gen_cmp(cstate, OR_LINKPL_NOSNAP, 4, BPF_B, v);
3681  		gen_and(b0, b1);
3682  		return b1;
3683  	case Q_CLNP:
3684  		bpf_error(cstate, "'clnp proto' is not supported");
3685  	case Q_STP:
3686  		bpf_error(cstate, "'stp proto' is bogus");
3687  	case Q_IPX:
3688  		bpf_error(cstate, "'ipx proto' is bogus");
3689  	case Q_NETBEUI:
3690  		bpf_error(cstate, "'netbeui proto' is bogus");
3691  	case Q_ISIS_L1:
3692  		bpf_error(cstate, "'l1 proto' is bogus");
3693  	case Q_ISIS_L2:
3694  		bpf_error(cstate, "'l2 proto' is bogus");
3695  	case Q_ISIS_IIH:
3696  		bpf_error(cstate, "'iih proto' is bogus");
3697  	case Q_ISIS_SNP:
3698  		bpf_error(cstate, "'snp proto' is bogus");
3699  	case Q_ISIS_CSNP:
3700  		bpf_error(cstate, "'csnp proto' is bogus");
3701  	case Q_ISIS_PSNP:
3702  		bpf_error(cstate, "'psnp proto' is bogus");
3703  	case Q_ISIS_LSP:
3704  		bpf_error(cstate, "'lsp proto' is bogus");
3705  	case Q_RADIO:
3706  		bpf_error(cstate, "'radio proto' is bogus");
3707  	case Q_CARP:
3708  		bpf_error(cstate, "'carp proto' is bogus");
3709  	default:
3710  		abort();
3711  	}
3712  }
3713  static int
3714  nametoport(compiler_state_t *cstate, const char *name, int ipproto)
3715  {
3716  	struct addrinfo hints, *res, *ai;
3717  	int error;
3718  	struct sockaddr_in *in4;
3719  #ifdef INET6
3720  	struct sockaddr_in6 *in6;
3721  #endif
3722  	int port = -1;
3723  	memset(&hints, 0, sizeof(hints));
3724  	hints.ai_family = PF_UNSPEC;
3725  	hints.ai_socktype = (ipproto == IPPROTO_TCP) ? SOCK_STREAM : SOCK_DGRAM;
3726  	hints.ai_protocol = ipproto;
3727  	error = getaddrinfo(NULL, name, &hints, &res);
3728  	if (error != 0) {
3729  		switch (error) {
3730  		case EAI_NONAME:
3731  		case EAI_SERVICE:
3732  			break;
3733  #ifdef EAI_SYSTEM
3734  		case EAI_SYSTEM:
3735  			bpf_set_error(cstate, "getaddrinfo(\"%s\" fails with system error: %d",
3736  			    name, errno);
3737  			port = -2;	&bsol;* a real error */
3738  			break;
3739  #endif
3740  		default:
3741  			bpf_set_error(cstate, "getaddrinfo(\"%s\") fails with error: %d",
3742  			    name, error);
3743  			port = -2;	&bsol;* a real error */
3744  			break;
3745  		}
3746  	} else {
3747  		for (ai = res; ai != NULL; ai = ai->ai_next) {
3748  			if (ai->ai_addr != NULL) {
3749  				if (ai->ai_addr->sa_family == AF_INET) {
3750  					in4 = (struct sockaddr_in *)ai->ai_addr;
3751  					port = ntohs(in4->sin_port);
3752  					break;
3753  				}
3754  #ifdef INET6
3755  				if (ai->ai_addr->sa_family == AF_INET6) {
3756  					in6 = (struct sockaddr_in6 *)ai->ai_addr;
3757  					port = ntohs(in6->sin6_port);
3758  					break;
3759  				}
3760  #endif
3761  			}
3762  		}
3763  		freeaddrinfo(res);
3764  	}
3765  	return port;
3766  }
3767  static bpf_u_int32
3768  stringtoport(compiler_state_t *cstate, const char *string, size_t string_size,
3769      int *proto)
3770  {
3771  	stoulen_ret ret;
3772  	char *cpy;
3773  	bpf_u_int32 val;
3774  	int tcp_port = -1;
3775  	int udp_port = -1;
3776  	ret = stoulen(string, string_size, &val, cstate);
3777  	switch (ret) {
3778  	case STOULEN_OK:
3779  		*proto = PROTO_UNDEF;
3780  		break;
3781  	case STOULEN_NOT_OCTAL_NUMBER:
3782  	case STOULEN_NOT_HEX_NUMBER:
3783  	case STOULEN_NOT_DECIMAL_NUMBER:
3784  		cpy = malloc(string_size + 1);	&bsol;* +1 for terminating '\0' */
3785  		memcpy(cpy, string, string_size);
3786  		cpy[string_size] = '\0';
3787  		tcp_port = nametoport(cstate, cpy, IPPROTO_TCP);
3788  		if (tcp_port == -2) {
3789  			free(cpy);
3790  			longjmp(cstate->top_ctx, 1);
3791  		}
3792  		udp_port = nametoport(cstate, cpy, IPPROTO_UDP);
3793  		if (udp_port == -2) {
3794  			free(cpy);
3795  			longjmp(cstate->top_ctx, 1);
3796  		}
3797  		if (tcp_port >= 0) {
3798  			val = (bpf_u_int32)tcp_port;
3799  			*proto = IPPROTO_TCP;
3800  			if (udp_port >= 0) {
3801  				if (udp_port == tcp_port)
3802  					*proto = PROTO_UNDEF;
3803  #ifdef notdef
3804  				else
3805  					warning("ambiguous port %s in /etc/services",
3806  						cpy);
3807  #endif
3808  			}
3809  			free(cpy);
3810  			break;
3811  		}
3812  		if (udp_port >= 0) {
3813  			val = (bpf_u_int32)udp_port;
3814  			*proto = IPPROTO_UDP;
3815  			free(cpy);
3816  			break;
3817  		}
3818  #if defined(ultrix) || defined(__osf__)
3819  		if (strcmp(cpy, "nfs") == 0) {
3820  			val = 2049;
3821  			*proto = PROTO_UNDEF;
3822  			free(cpy);
3823  			break;
3824  		}
3825  #endif
3826  		bpf_set_error(cstate, "'%s' is not a valid port", cpy);
3827  		free(cpy);
3828  		longjmp(cstate->top_ctx, 1);
3829  	case STOULEN_ERROR:
3830  		longjmp(cstate->top_ctx, 1);
3831  	default:
3832  		bpf_set_error(cstate, "stoulen returned %d - this should not happen", ret);
3833  		longjmp(cstate->top_ctx, 1);
3834  	}
3835  	return (val);
3836  }
3837  static void
3838  stringtoportrange(compiler_state_t *cstate, const char *string,
3839      bpf_u_int32 *port1, bpf_u_int32 *port2, int *proto)
3840  {
3841  	char *hyphen_off;
3842  	const char *first, *second;
3843  	size_t first_size, second_size;
3844  	int save_proto;
3845  	if ((hyphen_off = strchr(string, '-')) == NULL)
3846  		bpf_error(cstate, "port range '%s' contains no hyphen", string);
3847  	if (strchr(hyphen_off + 1, '-') != NULL)
3848  		bpf_error(cstate, "port range '%s' contains more than one hyphen",
3849  		    string);
3850  	first = string;
3851  	first_size = hyphen_off - string;
3852  	if (first_size == 0) {
3853  		bpf_error(cstate, "port range '%s' has no starting port", string);
3854  	}
3855  	*port1 = stringtoport(cstate, first, first_size, proto);
3856  	save_proto = *proto;
3857  	second = hyphen_off + 1;
3858  	second_size = strlen(second);
3859  	if (second_size == 0) {
3860  		bpf_error(cstate, "port range '%s' has no ending port", string);
3861  	}
3862  	*port2 = stringtoport(cstate, second, second_size, proto);
3863  	if (*proto != save_proto)
3864  		*proto = PROTO_UNDEF;
3865  }
3866  struct block *
3867  gen_scode(compiler_state_t *cstate, const char *name, struct qual q)
3868  {
3869  	int proto = q.proto;
3870  	int dir = q.dir;
3871  	int tproto;
3872  	u_char *eaddr;
3873  	bpf_u_int32 mask, addr;
3874  	struct addrinfo *res, *res0;
3875  	struct sockaddr_in *sin4;
3876  #ifdef INET6
3877  	int tproto6;
3878  	struct sockaddr_in6 *sin6;
3879  	struct in6_addr mask128;
3880  #endif &bsol;*INET6*/
3881  	struct block *b, *tmp;
3882  	int port, real_proto;
3883  	bpf_u_int32 port1, port2;
3884  	if (setjmp(cstate->top_ctx))
3885  		return (NULL);
3886  	switch (q.addr) {
3887  	case Q_NET:
3888  		addr = pcap_nametonetaddr(name);
3889  		if (addr == 0)
3890  			bpf_error(cstate, "unknown network '%s'", name);
3891  		mask = 0xffffffff;
3892  		while (addr && (addr & 0xff000000) == 0) {
3893  			addr <<= 8;
3894  			mask <<= 8;
3895  		}
3896  		return gen_host(cstate, addr, mask, proto, dir, q.addr);
3897  	case Q_DEFAULT:
3898  	case Q_HOST:
3899  		if (proto == Q_LINK) {
3900  			switch (cstate->linktype) {
3901  			case DLT_EN10MB:
3902  			case DLT_NETANALYZER:
3903  			case DLT_NETANALYZER_TRANSPARENT:
3904  				eaddr = pcap_ether_hostton(name);
3905  				if (eaddr == NULL)
3906  					bpf_error(cstate,
3907  					    "unknown ether host '%s'", name);
3908  				tmp = gen_prevlinkhdr_check(cstate);
3909  				b = gen_ehostop(cstate, eaddr, dir);
3910  				if (tmp != NULL)
3911  					gen_and(tmp, b);
3912  				free(eaddr);
3913  				return b;
3914  			case DLT_FDDI:
3915  				eaddr = pcap_ether_hostton(name);
3916  				if (eaddr == NULL)
3917  					bpf_error(cstate,
3918  					    "unknown FDDI host '%s'", name);
3919  				b = gen_fhostop(cstate, eaddr, dir);
3920  				free(eaddr);
3921  				return b;
3922  			case DLT_IEEE802:
3923  				eaddr = pcap_ether_hostton(name);
3924  				if (eaddr == NULL)
3925  					bpf_error(cstate,
3926  					    "unknown token ring host '%s'", name);
3927  				b = gen_thostop(cstate, eaddr, dir);
3928  				free(eaddr);
3929  				return b;
3930  			case DLT_IEEE802_11:
3931  			case DLT_PRISM_HEADER:
3932  			case DLT_IEEE802_11_RADIO_AVS:
3933  			case DLT_IEEE802_11_RADIO:
3934  			case DLT_PPI:
3935  				eaddr = pcap_ether_hostton(name);
3936  				if (eaddr == NULL)
3937  					bpf_error(cstate,
3938  					    "unknown 802.11 host '%s'", name);
3939  				b = gen_wlanhostop(cstate, eaddr, dir);
3940  				free(eaddr);
3941  				return b;
3942  			case DLT_IP_OVER_FC:
3943  				eaddr = pcap_ether_hostton(name);
3944  				if (eaddr == NULL)
3945  					bpf_error(cstate,
3946  					    "unknown Fibre Channel host '%s'", name);
3947  				b = gen_ipfchostop(cstate, eaddr, dir);
3948  				free(eaddr);
3949  				return b;
3950  			}
3951  			bpf_error(cstate, "only ethernet/FDDI/token ring/802.11/ATM LANE/Fibre Channel supports link-level host name");
3952  		} else if (proto == Q_DECNET) {
3953  			bpf_error(cstate, "invalid DECnet address '%s'", name);
3954  		} else {
3955  #ifdef INET6
3956  			memset(&mask128, 0xff, sizeof(mask128));
3957  #endif
3958  			res0 = res = pcap_nametoaddrinfo(name);
3959  			if (res == NULL)
3960  				bpf_error(cstate, "unknown host '%s'", name);
3961  			cstate->ai = res;
3962  			b = tmp = NULL;
3963  			tproto = proto;
3964  #ifdef INET6
3965  			tproto6 = proto;
3966  #endif
3967  			if (cstate->off_linktype.constant_part == OFFSET_NOT_SET &&
3968  			    tproto == Q_DEFAULT) {
3969  				tproto = Q_IP;
3970  #ifdef INET6
3971  				tproto6 = Q_IPV6;
3972  #endif
3973  			}
3974  			for (res = res0; res; res = res->ai_next) {
3975  				switch (res->ai_family) {
3976  				case AF_INET:
3977  #ifdef INET6
3978  					if (tproto == Q_IPV6)
3979  						continue;
3980  #endif
3981  					sin4 = (struct sockaddr_in *)
3982  						res->ai_addr;
3983  					tmp = gen_host(cstate, ntohl(sin4->sin_addr.s_addr),
3984  						0xffffffff, tproto, dir, q.addr);
3985  					break;
3986  #ifdef INET6
3987  				case AF_INET6:
3988  					if (tproto6 == Q_IP)
3989  						continue;
3990  					sin6 = (struct sockaddr_in6 *)
3991  						res->ai_addr;
3992  					tmp = gen_host6(cstate, &sin6->sin6_addr,
3993  						&mask128, tproto6, dir, q.addr);
3994  					break;
3995  #endif
3996  				default:
3997  					continue;
3998  				}
3999  				if (b)
4000  					gen_or(b, tmp);
4001  				b = tmp;
4002  			}
4003  			cstate->ai = NULL;
4004  			freeaddrinfo(res0);
4005  			if (b == NULL) {
4006  				bpf_error(cstate, "unknown host '%s'%s", name,
4007  				    (proto == Q_DEFAULT)
4008  					? ""
4009  					: " for specified address family");
4010  			}
4011  			return b;
4012  		}
4013  	case Q_PORT:
4014  		if (proto != Q_DEFAULT &&
4015  		    proto != Q_UDP && proto != Q_TCP && proto != Q_SCTP)
4016  			bpf_error(cstate, "illegal qualifier of 'port'");
4017  		if (pcap_nametoport(name, &port, &real_proto) == 0)
4018  			bpf_error(cstate, "unknown port '%s'", name);
4019  		if (proto == Q_UDP) {
4020  			if (real_proto == IPPROTO_TCP)
4021  				bpf_error(cstate, "port '%s' is tcp", name);
4022  			else if (real_proto == IPPROTO_SCTP)
4023  				bpf_error(cstate, "port '%s' is sctp", name);
4024  			else
4025  				real_proto = IPPROTO_UDP;
4026  		}
4027  		if (proto == Q_TCP) {
4028  			if (real_proto == IPPROTO_UDP)
4029  				bpf_error(cstate, "port '%s' is udp", name);
4030  			else if (real_proto == IPPROTO_SCTP)
4031  				bpf_error(cstate, "port '%s' is sctp", name);
4032  			else
4033  				real_proto = IPPROTO_TCP;
4034  		}
4035  		if (proto == Q_SCTP) {
4036  			if (real_proto == IPPROTO_UDP)
4037  				bpf_error(cstate, "port '%s' is udp", name);
4038  			else if (real_proto == IPPROTO_TCP)
4039  				bpf_error(cstate, "port '%s' is tcp", name);
4040  			else
4041  				real_proto = IPPROTO_SCTP;
4042  		}
4043  		if (port < 0)
4044  			bpf_error(cstate, "illegal port number %d < 0", port);
4045  		if (port > 65535)
4046  			bpf_error(cstate, "illegal port number %d > 65535", port);
4047  		b = gen_port(cstate, port, real_proto, dir);
4048  		gen_or(gen_port6(cstate, port, real_proto, dir), b);
4049  		return b;
4050  	case Q_PORTRANGE:
4051  		if (proto != Q_DEFAULT &&
4052  		    proto != Q_UDP && proto != Q_TCP && proto != Q_SCTP)
4053  			bpf_error(cstate, "illegal qualifier of 'portrange'");
4054  		stringtoportrange(cstate, name, &port1, &port2, &real_proto);
4055  		if (proto == Q_UDP) {
4056  			if (real_proto == IPPROTO_TCP)
4057  				bpf_error(cstate, "port in range '%s' is tcp", name);
4058  			else if (real_proto == IPPROTO_SCTP)
4059  				bpf_error(cstate, "port in range '%s' is sctp", name);
4060  			else
4061  				real_proto = IPPROTO_UDP;
4062  		}
4063  		if (proto == Q_TCP) {
4064  			if (real_proto == IPPROTO_UDP)
4065  				bpf_error(cstate, "port in range '%s' is udp", name);
4066  			else if (real_proto == IPPROTO_SCTP)
4067  				bpf_error(cstate, "port in range '%s' is sctp", name);
4068  			else
4069  				real_proto = IPPROTO_TCP;
4070  		}
4071  		if (proto == Q_SCTP) {
4072  			if (real_proto == IPPROTO_UDP)
4073  				bpf_error(cstate, "port in range '%s' is udp", name);
4074  			else if (real_proto == IPPROTO_TCP)
4075  				bpf_error(cstate, "port in range '%s' is tcp", name);
4076  			else
4077  				real_proto = IPPROTO_SCTP;
4078  		}
4079  		if (port1 > 65535)
4080  			bpf_error(cstate, "illegal port number %d > 65535", port1);
4081  		if (port2 > 65535)
4082  			bpf_error(cstate, "illegal port number %d > 65535", port2);
4083  		b = gen_portrange(cstate, port1, port2, real_proto, dir);
4084  		gen_or(gen_portrange6(cstate, port1, port2, real_proto, dir), b);
4085  		return b;
4086  	case Q_GATEWAY:
4087  #ifndef INET6
4088  		eaddr = pcap_ether_hostton(name);
4089  		if (eaddr == NULL)
4090  			bpf_error(cstate, "unknown ether host: %s", name);
4091  		res = pcap_nametoaddrinfo(name);
4092  		cstate->ai = res;
4093  		if (res == NULL)
4094  			bpf_error(cstate, "unknown host '%s'", name);
4095  		b = gen_gateway(cstate, eaddr, res, proto, dir);
4096  		cstate->ai = NULL;
4097  		freeaddrinfo(res);
4098  		if (b == NULL)
4099  			bpf_error(cstate, "unknown host '%s'", name);
4100  		return b;
4101  #else
4102  		bpf_error(cstate, "'gateway' not supported in this configuration");
4103  #endif &bsol;*INET6*/
4104  	case Q_PROTO:
4105  		real_proto = lookup_proto(cstate, name, proto);
4106  		if (real_proto >= 0)
4107  			return gen_proto(cstate, real_proto, proto, dir);
4108  		else
4109  			bpf_error(cstate, "unknown protocol: %s", name);
4110  #if !defined(NO_PROTOCHAIN)
4111  	case Q_PROTOCHAIN:
4112  		real_proto = lookup_proto(cstate, name, proto);
4113  		if (real_proto >= 0)
4114  			return gen_protochain(cstate, real_proto, proto);
4115  		else
4116  			bpf_error(cstate, "unknown protocol: %s", name);
4117  #endif &bsol;* !defined(NO_PROTOCHAIN) */
4118  	case Q_UNDEF:
4119  		syntax(cstate);
4120  	}
4121  	abort();
4122  }
4123  struct block *
4124  gen_mcode(compiler_state_t *cstate, const char *s1, const char *s2,
4125      bpf_u_int32 masklen, struct qual q)
4126  {
4127  	register int nlen, mlen;
4128  	bpf_u_int32 n, m;
4129  	if (setjmp(cstate->top_ctx))
4130  		return (NULL);
4131  	nlen = __pcap_atoin(s1, &n);
4132  	if (nlen < 0)
4133  		bpf_error(cstate, "invalid IPv4 address '%s'", s1);
4134  	n <<= 32 - nlen;
4135  	if (s2 != NULL) {
4136  		mlen = __pcap_atoin(s2, &m);
4137  		if (mlen < 0)
4138  			bpf_error(cstate, "invalid IPv4 address '%s'", s2);
4139  		m <<= 32 - mlen;
4140  		if ((n & ~m) != 0)
4141  			bpf_error(cstate, "non-network bits set in \"%s mask %s\"",
4142  			    s1, s2);
4143  	} else {
4144  		if (masklen > 32)
4145  			bpf_error(cstate, "mask length must be <= 32");
4146  		if (masklen == 0) {
4147  			m = 0;
4148  		} else
4149  			m = 0xffffffff << (32 - masklen);
4150  		if ((n & ~m) != 0)
4151  			bpf_error(cstate, "non-network bits set in \"%s/%d\"",
4152  			    s1, masklen);
4153  	}
4154  	switch (q.addr) {
4155  	case Q_NET:
4156  		return gen_host(cstate, n, m, q.proto, q.dir, q.addr);
4157  	default:
4158  		bpf_error(cstate, "Mask syntax for networks only");
4159  	}
4160  }
4161  struct block *
4162  gen_ncode(compiler_state_t *cstate, const char *s, bpf_u_int32 v, struct qual q)
4163  {
4164  	bpf_u_int32 mask;
4165  	int proto;
4166  	int dir;
4167  	register int vlen;
4168  	if (setjmp(cstate->top_ctx))
4169  		return (NULL);
4170  	proto = q.proto;
4171  	dir = q.dir;
4172  	if (s == NULL) {
4173  		if (proto == Q_DECNET)
4174  			bpf_error(cstate, "invalid DECnet address '%u'", v);
4175  		vlen = 32;
4176  	} else if (proto == Q_DECNET) {
4177  		vlen = __pcap_atodn(s, &v);
4178  		if (vlen == 0)
4179  			bpf_error(cstate, "invalid DECnet address '%s'", s);
4180  	} else {
4181  		vlen = __pcap_atoin(s, &v);
4182  		if (vlen < 0)
4183  			bpf_error(cstate, "invalid IPv4 address '%s'", s);
4184  	}
4185  	switch (q.addr) {
4186  	case Q_DEFAULT:
4187  	case Q_HOST:
4188  	case Q_NET:
4189  		if (proto == Q_DECNET)
4190  			return gen_host(cstate, v, 0, proto, dir, q.addr);
4191  		else if (proto == Q_LINK) {
4192  			bpf_error(cstate, "illegal link layer address");
4193  		} else {
4194  			mask = 0xffffffff;
4195  			if (s == NULL && q.addr == Q_NET) {
4196  				while (v && (v & 0xff000000) == 0) {
4197  					v <<= 8;
4198  					mask <<= 8;
4199  				}
4200  			} else {
4201  				v <<= 32 - vlen;
4202  				mask <<= 32 - vlen ;
4203  			}
4204  			return gen_host(cstate, v, mask, proto, dir, q.addr);
4205  		}
4206  	case Q_PORT:
4207  		if (proto == Q_UDP)
4208  			proto = IPPROTO_UDP;
4209  		else if (proto == Q_TCP)
4210  			proto = IPPROTO_TCP;
4211  		else if (proto == Q_SCTP)
4212  			proto = IPPROTO_SCTP;
4213  		else if (proto == Q_DEFAULT)
4214  			proto = PROTO_UNDEF;
4215  		else
4216  			bpf_error(cstate, "illegal qualifier of 'port'");
4217  		if (v > 65535)
4218  			bpf_error(cstate, "illegal port number %u > 65535", v);
4219  	    {
4220  		struct block *b;
4221  		b = gen_port(cstate, v, proto, dir);
4222  		gen_or(gen_port6(cstate, v, proto, dir), b);
4223  		return b;
4224  	    }
4225  	case Q_PORTRANGE:
4226  		if (proto == Q_UDP)
4227  			proto = IPPROTO_UDP;
4228  		else if (proto == Q_TCP)
4229  			proto = IPPROTO_TCP;
4230  		else if (proto == Q_SCTP)
4231  			proto = IPPROTO_SCTP;
4232  		else if (proto == Q_DEFAULT)
4233  			proto = PROTO_UNDEF;
4234  		else
4235  			bpf_error(cstate, "illegal qualifier of 'portrange'");
4236  		if (v > 65535)
4237  			bpf_error(cstate, "illegal port number %u > 65535", v);
4238  	    {
4239  		struct block *b;
4240  		b = gen_portrange(cstate, v, v, proto, dir);
4241  		gen_or(gen_portrange6(cstate, v, v, proto, dir), b);
4242  		return b;
4243  	    }
4244  	case Q_GATEWAY:
4245  		bpf_error(cstate, "'gateway' requires a name");
4246  	case Q_PROTO:
4247  		return gen_proto(cstate, v, proto, dir);
4248  #if !defined(NO_PROTOCHAIN)
4249  	case Q_PROTOCHAIN:
4250  		return gen_protochain(cstate, v, proto);
4251  #endif
4252  	case Q_UNDEF:
4253  		syntax(cstate);
4254  	default:
4255  		abort();
4256  	}
4257  }
4258  #ifdef INET6
4259  struct block *
4260  gen_mcode6(compiler_state_t *cstate, const char *s, bpf_u_int32 masklen,
4261      struct qual q)
4262  {
4263  	struct addrinfo *res;
4264  	struct in6_addr *addr;
4265  	struct in6_addr mask;
4266  	struct block *b;
4267  	bpf_u_int32 a[4], m[4]; &bsol;* Same as in gen_hostop6(). */
4268  	if (setjmp(cstate->top_ctx))
4269  		return (NULL);
4270  	res = pcap_nametoaddrinfo(s);
4271  	if (!res)
4272  		bpf_error(cstate, "invalid ip6 address %s", s);
4273  	cstate->ai = res;
4274  	if (res->ai_next)
4275  		bpf_error(cstate, "%s resolved to multiple address", s);
4276  	addr = &((struct sockaddr_in6 *)res->ai_addr)->sin6_addr;
4277  	if (masklen > sizeof(mask.s6_addr) * 8)
4278  		bpf_error(cstate, "mask length must be <= %zu", sizeof(mask.s6_addr) * 8);
4279  	memset(&mask, 0, sizeof(mask));
4280  	memset(&mask.s6_addr, 0xff, masklen / 8);
4281  	if (masklen % 8) {
4282  		mask.s6_addr[masklen / 8] =
4283  			(0xff << (8 - masklen % 8)) & 0xff;
4284  	}
4285  	memcpy(a, addr, sizeof(a));
4286  	memcpy(m, &mask, sizeof(m));
4287  	if ((a[0] & ~m[0]) || (a[1] & ~m[1])
4288  	 || (a[2] & ~m[2]) || (a[3] & ~m[3])) {
4289  		bpf_error(cstate, "non-network bits set in \"%s/%d\"", s, masklen);
4290  	}
4291  	switch (q.addr) {
4292  	case Q_DEFAULT:
4293  	case Q_HOST:
4294  		if (masklen != 128)
4295  			bpf_error(cstate, "Mask syntax for networks only");
4296  	case Q_NET:
4297  		b = gen_host6(cstate, addr, &mask, q.proto, q.dir, q.addr);
4298  		cstate->ai = NULL;
4299  		freeaddrinfo(res);
4300  		return b;
4301  	default:
4302  		bpf_error(cstate, "invalid qualifier against IPv6 address");
4303  	}
4304  }
4305  #endif &bsol;*INET6*/
4306  struct block *
4307  gen_ecode(compiler_state_t *cstate, const char *s, struct qual q)
4308  {
4309  	struct block *b, *tmp;
4310  	if (setjmp(cstate->top_ctx))
4311  		return (NULL);
4312  	if ((q.addr == Q_HOST || q.addr == Q_DEFAULT) && q.proto == Q_LINK) {
4313  		cstate->e = pcap_ether_aton(s);
4314  		if (cstate->e == NULL)
4315  			bpf_error(cstate, "malloc");
4316  		switch (cstate->linktype) {
4317  		case DLT_EN10MB:
4318  		case DLT_NETANALYZER:
4319  		case DLT_NETANALYZER_TRANSPARENT:
4320  			tmp = gen_prevlinkhdr_check(cstate);
4321  			b = gen_ehostop(cstate, cstate->e, (int)q.dir);
4322  			if (tmp != NULL)
4323  				gen_and(tmp, b);
4324  			break;
4325  		case DLT_FDDI:
4326  			b = gen_fhostop(cstate, cstate->e, (int)q.dir);
4327  			break;
4328  		case DLT_IEEE802:
4329  			b = gen_thostop(cstate, cstate->e, (int)q.dir);
4330  			break;
4331  		case DLT_IEEE802_11:
4332  		case DLT_PRISM_HEADER:
4333  		case DLT_IEEE802_11_RADIO_AVS:
4334  		case DLT_IEEE802_11_RADIO:
4335  		case DLT_PPI:
4336  			b = gen_wlanhostop(cstate, cstate->e, (int)q.dir);
4337  			break;
4338  		case DLT_IP_OVER_FC:
4339  			b = gen_ipfchostop(cstate, cstate->e, (int)q.dir);
4340  			break;
4341  		default:
4342  			free(cstate->e);
4343  			cstate->e = NULL;
4344  			bpf_error(cstate, "ethernet addresses supported only on ethernet/FDDI/token ring/802.11/ATM LANE/Fibre Channel");
4345  		}
4346  		free(cstate->e);
4347  		cstate->e = NULL;
4348  		return (b);
4349  	}
4350  	bpf_error(cstate, "ethernet address used in non-ether expression");
4351  }
4352  void
4353  sappend(struct slist *s0, struct slist *s1)
4354  {
4355  	while (s0->next)
4356  		s0 = s0->next;
4357  	s0->next = s1;
4358  }
4359  static struct slist *
4360  xfer_to_x(compiler_state_t *cstate, struct arth *a)
4361  {
4362  	struct slist *s;
4363  	s = new_stmt(cstate, BPF_LDX|BPF_MEM);
4364  	s->s.k = a->regno;
4365  	return s;
4366  }
4367  static struct slist *
4368  xfer_to_a(compiler_state_t *cstate, struct arth *a)
4369  {
4370  	struct slist *s;
4371  	s = new_stmt(cstate, BPF_LD|BPF_MEM);
4372  	s->s.k = a->regno;
4373  	return s;
4374  }
4375  static struct arth *
4376  gen_load_internal(compiler_state_t *cstate, int proto, struct arth *inst,
4377      bpf_u_int32 size)
4378  {
4379  	int size_code;
4380  	struct slist *s, *tmp;
4381  	struct block *b;
4382  	int regno = alloc_reg(cstate);
4383  	free_reg(cstate, inst->regno);
4384  	switch (size) {
4385  	default:
4386  		bpf_error(cstate, "data size must be 1, 2, or 4");
4387  	case 1:
4388  		size_code = BPF_B;
4389  		break;
4390  	case 2:
4391  		size_code = BPF_H;
4392  		break;
4393  	case 4:
4394  		size_code = BPF_W;
4395  		break;
4396  	}
4397  	switch (proto) {
4398  	default:
4399  		bpf_error(cstate, "unsupported index operation");
4400  	case Q_RADIO:
4401  		if (cstate->linktype != DLT_IEEE802_11_RADIO_AVS &&
4402  		    cstate->linktype != DLT_IEEE802_11_RADIO &&
4403  		    cstate->linktype != DLT_PRISM_HEADER)
4404  			bpf_error(cstate, "radio information not present in capture");
4405  		s = xfer_to_x(cstate, inst);
4406  		tmp = new_stmt(cstate, BPF_LD|BPF_IND|size_code);
4407  		sappend(s, tmp);
4408  		sappend(inst->s, s);
4409  		break;
4410  	case Q_LINK:
4411  		s = gen_abs_offset_varpart(cstate, &cstate->off_linkhdr);
4412  		if (s != NULL) {
4413  			sappend(s, xfer_to_a(cstate, inst));
4414  			sappend(s, new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X));
4415  			sappend(s, new_stmt(cstate, BPF_MISC|BPF_TAX));
4416  		} else
4417  			s = xfer_to_x(cstate, inst);
4418  		tmp = new_stmt(cstate, BPF_LD|BPF_IND|size_code);
4419  		tmp->s.k = cstate->off_linkhdr.constant_part;
4420  		sappend(s, tmp);
4421  		sappend(inst->s, s);
4422  		break;
4423  	case Q_IP:
4424  	case Q_ARP:
4425  	case Q_RARP:
4426  	case Q_ATALK:
4427  	case Q_DECNET:
4428  	case Q_SCA:
4429  	case Q_LAT:
4430  	case Q_MOPRC:
4431  	case Q_MOPDL:
4432  	case Q_IPV6:
4433  		s = gen_abs_offset_varpart(cstate, &cstate->off_linkpl);
4434  		if (s != NULL) {
4435  			sappend(s, xfer_to_a(cstate, inst));
4436  			sappend(s, new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X));
4437  			sappend(s, new_stmt(cstate, BPF_MISC|BPF_TAX));
4438  		} else
4439  			s = xfer_to_x(cstate, inst);
4440  		tmp = new_stmt(cstate, BPF_LD|BPF_IND|size_code);
4441  		tmp->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;
4442  		sappend(s, tmp);
4443  		sappend(inst->s, s);
4444  		b = gen_proto_abbrev_internal(cstate, proto);
4445  		if (inst->b)
4446  			gen_and(inst->b, b);
4447  		inst->b = b;
4448  		break;
4449  	case Q_SCTP:
4450  	case Q_TCP:
4451  	case Q_UDP:
4452  	case Q_ICMP:
4453  	case Q_IGMP:
4454  	case Q_IGRP:
4455  	case Q_PIM:
4456  	case Q_VRRP:
4457  	case Q_CARP:
4458  		s = gen_loadx_iphdrlen(cstate);
4459  		sappend(s, xfer_to_a(cstate, inst));
4460  		sappend(s, new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X));
4461  		sappend(s, new_stmt(cstate, BPF_MISC|BPF_TAX));
4462  		sappend(s, tmp = new_stmt(cstate, BPF_LD|BPF_IND|size_code));
4463  		tmp->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;
4464  		sappend(inst->s, s);
4465  		gen_and(gen_proto_abbrev_internal(cstate, proto), b = gen_ipfrag(cstate));
4466  		if (inst->b)
4467  			gen_and(inst->b, b);
4468  		gen_and(gen_proto_abbrev_internal(cstate, Q_IP), b);
4469  		inst->b = b;
4470  		break;
4471  	case Q_ICMPV6:
4472          b = gen_proto_abbrev_internal(cstate, Q_IPV6);
4473          if (inst->b) {
4474              gen_and(inst->b, b);
4475          }
4476          inst->b = b;
4477          b = gen_cmp(cstate, OR_LINKPL, 6, BPF_B, 58);
4478          if (inst->b) {
4479              gen_and(inst->b, b);
4480          }
4481          inst->b = b;
4482          s = gen_abs_offset_varpart(cstate, &cstate->off_linkpl);
4483          if (s != NULL) {
4484              sappend(s, xfer_to_a(cstate, inst));
4485              sappend(s, new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X));
4486              sappend(s, new_stmt(cstate, BPF_MISC|BPF_TAX));
4487          } else {
4488              s = xfer_to_x(cstate, inst);
4489          }
4490          tmp = new_stmt(cstate, BPF_LD|BPF_IND|size_code);
4491          tmp->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + 40;
4492          sappend(s, tmp);
4493          sappend(inst->s, s);
4494          break;
4495  	}
4496  	inst->regno = regno;
4497  	s = new_stmt(cstate, BPF_ST);
4498  	s->s.k = regno;
4499  	sappend(inst->s, s);
4500  	return inst;
4501  }
4502  struct arth *
4503  gen_load(compiler_state_t *cstate, int proto, struct arth *inst,
4504      bpf_u_int32 size)
4505  {
4506  	if (setjmp(cstate->top_ctx))
4507  		return (NULL);
4508  	return gen_load_internal(cstate, proto, inst, size);
4509  }
4510  static struct block *
4511  gen_relation_internal(compiler_state_t *cstate, int code, struct arth *a0,
4512      struct arth *a1, int reversed)
4513  {
4514  	struct slist *s0, *s1, *s2;
4515  	struct block *b, *tmp;
4516  	s0 = xfer_to_x(cstate, a1);
4517  	s1 = xfer_to_a(cstate, a0);
4518  	if (code == BPF_JEQ) {
4519  		s2 = new_stmt(cstate, BPF_ALU|BPF_SUB|BPF_X);
4520  		b = new_block(cstate, JMP(code));
4521  		sappend(s1, s2);
4522  	}
4523  	else
4524  		b = new_block(cstate, BPF_JMP|code|BPF_X);
4525  	if (reversed)
4526  		gen_not(b);
4527  	sappend(s0, s1);
4528  	sappend(a1->s, s0);
4529  	sappend(a0->s, a1->s);
4530  	b->stmts = a0->s;
4531  	free_reg(cstate, a0->regno);
4532  	free_reg(cstate, a1->regno);
4533  	if (a0->b) {
4534  		if (a1->b) {
4535  			gen_and(a0->b, tmp = a1->b);
4536  		}
4537  		else
4538  			tmp = a0->b;
4539  	} else
4540  		tmp = a1->b;
4541  	if (tmp)
4542  		gen_and(tmp, b);
4543  	return b;
4544  }
4545  struct block *
4546  gen_relation(compiler_state_t *cstate, int code, struct arth *a0,
4547      struct arth *a1, int reversed)
4548  {
4549  	if (setjmp(cstate->top_ctx))
4550  		return (NULL);
4551  	return gen_relation_internal(cstate, code, a0, a1, reversed);
4552  }
4553  struct arth *
4554  gen_loadlen(compiler_state_t *cstate)
4555  {
4556  	int regno;
4557  	struct arth *a;
4558  	struct slist *s;
4559  	if (setjmp(cstate->top_ctx))
4560  		return (NULL);
4561  	regno = alloc_reg(cstate);
4562  	a = (struct arth *)newchunk(cstate, sizeof(*a));
4563  	s = new_stmt(cstate, BPF_LD|BPF_LEN);
4564  	s->next = new_stmt(cstate, BPF_ST);
4565  	s->next->s.k = regno;
4566  	a->s = s;
4567  	a->regno = regno;
4568  	return a;
4569  }
4570  static struct arth *
4571  gen_loadi_internal(compiler_state_t *cstate, bpf_u_int32 val)
4572  {
4573  	struct arth *a;
4574  	struct slist *s;
4575  	int reg;
4576  	a = (struct arth *)newchunk(cstate, sizeof(*a));
4577  	reg = alloc_reg(cstate);
4578  	s = new_stmt(cstate, BPF_LD|BPF_IMM);
4579  	s->s.k = val;
4580  	s->next = new_stmt(cstate, BPF_ST);
4581  	s->next->s.k = reg;
4582  	a->s = s;
4583  	a->regno = reg;
4584  	return a;
4585  }
4586  struct arth *
4587  gen_loadi(compiler_state_t *cstate, bpf_u_int32 val)
4588  {
4589  	if (setjmp(cstate->top_ctx))
4590  		return (NULL);
4591  	return gen_loadi_internal(cstate, val);
4592  }
4593  struct arth *
4594  gen_neg(compiler_state_t *cstate, struct arth *a_arg)
4595  {
4596  	struct arth *a = a_arg;
4597  	struct slist *s;
4598  	if (setjmp(cstate->top_ctx))
4599  		return (NULL);
4600  	s = xfer_to_a(cstate, a);
4601  	sappend(a->s, s);
4602  	s = new_stmt(cstate, BPF_ALU|BPF_NEG);
4603  	s->s.k = 0;
4604  	sappend(a->s, s);
4605  	s = new_stmt(cstate, BPF_ST);
4606  	s->s.k = a->regno;
4607  	sappend(a->s, s);
4608  	return a;
4609  }
4610  struct arth *
4611  gen_arth(compiler_state_t *cstate, int code, struct arth *a0_arg,
4612      struct arth *a1)
4613  {
4614  	struct arth *a0 = a0_arg;
4615  	struct slist *s0, *s1, *s2;
4616  	if (setjmp(cstate->top_ctx))
4617  		return (NULL);
4618  	if (code == BPF_DIV) {
4619  		if (a1->s->s.code == (BPF_LD|BPF_IMM) && a1->s->s.k == 0)
4620  			bpf_error(cstate, "division by zero");
4621  	} else if (code == BPF_MOD) {
4622  		if (a1->s->s.code == (BPF_LD|BPF_IMM) && a1->s->s.k == 0)
4623  			bpf_error(cstate, "modulus by zero");
4624  	} else if (code == BPF_LSH || code == BPF_RSH) {
4625  		if (a1->s->s.code == (BPF_LD|BPF_IMM) && a1->s->s.k > 31)
4626  			bpf_error(cstate, "shift by more than 31 bits");
4627  	}
4628  	s0 = xfer_to_x(cstate, a1);
4629  	s1 = xfer_to_a(cstate, a0);
4630  	s2 = new_stmt(cstate, BPF_ALU|BPF_X|code);
4631  	sappend(s1, s2);
4632  	sappend(s0, s1);
4633  	sappend(a1->s, s0);
4634  	sappend(a0->s, a1->s);
4635  	free_reg(cstate, a0->regno);
4636  	free_reg(cstate, a1->regno);
4637  	s0 = new_stmt(cstate, BPF_ST);
4638  	a0->regno = s0->s.k = alloc_reg(cstate);
4639  	sappend(a0->s, s0);
4640  	return a0;
4641  }
4642  static void
4643  init_regs(compiler_state_t *cstate)
4644  {
4645  	cstate->curreg = 0;
4646  	memset(cstate->regused, 0, sizeof cstate->regused);
4647  }
4648  static int
4649  alloc_reg(compiler_state_t *cstate)
4650  {
4651  	int n = BPF_MEMWORDS;
4652  	while (--n >= 0) {
4653  		if (cstate->regused[cstate->curreg])
4654  			cstate->curreg = (cstate->curreg + 1) % BPF_MEMWORDS;
4655  		else {
4656  			cstate->regused[cstate->curreg] = 1;
4657  			return cstate->curreg;
4658  		}
4659  	}
4660  	bpf_error(cstate, "too many registers needed to evaluate expression");
4661  }
4662  static void
4663  free_reg(compiler_state_t *cstate, int n)
4664  {
4665  	cstate->regused[n] = 0;
4666  }
4667  static struct block *
4668  gen_len(compiler_state_t *cstate, int jmp, int n)
4669  {
4670  	struct slist *s;
4671  	struct block *b;
4672  	s = new_stmt(cstate, BPF_LD|BPF_LEN);
4673  	b = new_block(cstate, JMP(jmp));
4674  	b->stmts = s;
4675  	b->s.k = n;
4676  	return b;
4677  }
4678  struct block *
4679  gen_greater(compiler_state_t *cstate, int n)
4680  {
4681  	if (setjmp(cstate->top_ctx))
4682  		return (NULL);
4683  	return gen_len(cstate, BPF_JGE, n);
4684  }
4685  struct block *
4686  gen_less(compiler_state_t *cstate, int n)
4687  {
4688  	struct block *b;
4689  	if (setjmp(cstate->top_ctx))
4690  		return (NULL);
4691  	b = gen_len(cstate, BPF_JGT, n);
4692  	gen_not(b);
4693  	return b;
4694  }
4695  struct block *
4696  gen_byteop(compiler_state_t *cstate, int op, int idx, bpf_u_int32 val)
4697  {
4698  	struct block *b;
4699  	struct slist *s;
4700  	if (setjmp(cstate->top_ctx))
4701  		return (NULL);
4702  	switch (op) {
4703  	default:
4704  		abort();
4705  	case '=':
4706  		return gen_cmp(cstate, OR_LINKHDR, (u_int)idx, BPF_B, val);
4707  	case '<':
4708  		b = gen_cmp_lt(cstate, OR_LINKHDR, (u_int)idx, BPF_B, val);
4709  		return b;
4710  	case '>':
4711  		b = gen_cmp_gt(cstate, OR_LINKHDR, (u_int)idx, BPF_B, val);
4712  		return b;
4713  	case '|':
4714  		s = new_stmt(cstate, BPF_ALU|BPF_OR|BPF_K);
4715  		break;
4716  	case '&':
4717  		s = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);
4718  		break;
4719  	}
4720  	s->s.k = val;
4721  	b = new_block(cstate, JMP(BPF_JEQ));
4722  	b->stmts = s;
4723  	gen_not(b);
4724  	return b;
4725  }
4726  static const u_char abroadcast[] = { 0x0 };
4727  struct block *
4728  gen_broadcast(compiler_state_t *cstate, int proto)
4729  {
4730  	bpf_u_int32 hostmask;
4731  	struct block *b0, *b1, *b2;
4732  	static const u_char ebroadcast[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
4733  	if (setjmp(cstate->top_ctx))
4734  		return (NULL);
4735  	switch (proto) {
4736  	case Q_DEFAULT:
4737  	case Q_LINK:
4738  		switch (cstate->linktype) {
4739  		case DLT_ARCNET:
4740  		case DLT_ARCNET_LINUX:
4741  			return gen_ahostop(cstate, abroadcast, Q_DST);
4742  		case DLT_EN10MB:
4743  		case DLT_NETANALYZER:
4744  		case DLT_NETANALYZER_TRANSPARENT:
4745  			b1 = gen_prevlinkhdr_check(cstate);
4746  			b0 = gen_ehostop(cstate, ebroadcast, Q_DST);
4747  			if (b1 != NULL)
4748  				gen_and(b1, b0);
4749  			return b0;
4750  		case DLT_FDDI:
4751  			return gen_fhostop(cstate, ebroadcast, Q_DST);
4752  		case DLT_IEEE802:
4753  			return gen_thostop(cstate, ebroadcast, Q_DST);
4754  		case DLT_IEEE802_11:
4755  		case DLT_PRISM_HEADER:
4756  		case DLT_IEEE802_11_RADIO_AVS:
4757  		case DLT_IEEE802_11_RADIO:
4758  		case DLT_PPI:
4759  			return gen_wlanhostop(cstate, ebroadcast, Q_DST);
4760  		case DLT_IP_OVER_FC:
4761  			return gen_ipfchostop(cstate, ebroadcast, Q_DST);
4762  		default:
4763  			bpf_error(cstate, "not a broadcast link");
4764  		}
4765  	case Q_IP:
4766  		if (cstate->netmask == PCAP_NETMASK_UNKNOWN)
4767  			bpf_error(cstate, "netmask not known, so 'ip broadcast' not supported");
4768  		b0 = gen_linktype(cstate, ETHERTYPE_IP);
4769  		hostmask = ~cstate->netmask;
4770  		b1 = gen_mcmp(cstate, OR_LINKPL, 16, BPF_W, 0, hostmask);
4771  		b2 = gen_mcmp(cstate, OR_LINKPL, 16, BPF_W,
4772  			      ~0 & hostmask, hostmask);
4773  		gen_or(b1, b2);
4774  		gen_and(b0, b2);
4775  		return b2;
4776  	}
4777  	bpf_error(cstate, "only link-layer/IP broadcast filters supported");
4778  }
4779  static struct block *
4780  gen_mac_multicast(compiler_state_t *cstate, int offset)
4781  {
4782  	register struct block *b0;
4783  	register struct slist *s;
4784  	s = gen_load_a(cstate, OR_LINKHDR, offset, BPF_B);
4785  	b0 = new_block(cstate, JMP(BPF_JSET));
4786  	b0->s.k = 1;
4787  	b0->stmts = s;
4788  	return b0;
4789  }
4790  struct block *
4791  gen_multicast(compiler_state_t *cstate, int proto)
4792  {
4793  	register struct block *b0, *b1, *b2;
4794  	register struct slist *s;
4795  	if (setjmp(cstate->top_ctx))
4796  		return (NULL);
4797  	switch (proto) {
4798  	case Q_DEFAULT:
4799  	case Q_LINK:
4800  		switch (cstate->linktype) {
4801  		case DLT_ARCNET:
4802  		case DLT_ARCNET_LINUX:
4803  			return gen_ahostop(cstate, abroadcast, Q_DST);
4804  		case DLT_EN10MB:
4805  		case DLT_NETANALYZER:
4806  		case DLT_NETANALYZER_TRANSPARENT:
4807  			b1 = gen_prevlinkhdr_check(cstate);
4808  			b0 = gen_mac_multicast(cstate, 0);
4809  			if (b1 != NULL)
4810  				gen_and(b1, b0);
4811  			return b0;
4812  		case DLT_FDDI:
4813  			return gen_mac_multicast(cstate, 1);
4814  		case DLT_IEEE802:
4815  			return gen_mac_multicast(cstate, 2);
4816  		case DLT_IEEE802_11:
4817  		case DLT_PRISM_HEADER:
4818  		case DLT_IEEE802_11_RADIO_AVS:
4819  		case DLT_IEEE802_11_RADIO:
4820  		case DLT_PPI:
4821  			s = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);
4822  			b1 = new_block(cstate, JMP(BPF_JSET));
4823  			b1->s.k = 0x01;	&bsol;* To DS */
4824  			b1->stmts = s;
4825  			b0 = gen_mac_multicast(cstate, 16);
4826  			gen_and(b1, b0);
4827  			s = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);
4828  			b2 = new_block(cstate, JMP(BPF_JSET));
4829  			b2->s.k = 0x01;	&bsol;* To DS */
4830  			b2->stmts = s;
4831  			gen_not(b2);
4832  			b1 = gen_mac_multicast(cstate, 4);
4833  			gen_and(b2, b1);
4834  			gen_or(b1, b0);
4835  			s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
4836  			b1 = new_block(cstate, JMP(BPF_JSET));
4837  			b1->s.k = 0x08;
4838  			b1->stmts = s;
4839  			gen_and(b1, b0);
4840  			s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
4841  			b2 = new_block(cstate, JMP(BPF_JSET));
4842  			b2->s.k = 0x08;
4843  			b2->stmts = s;
4844  			gen_not(b2);
4845  			b1 = gen_mac_multicast(cstate, 4);
4846  			gen_and(b2, b1);
4847  			gen_or(b1, b0);
4848  			s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
4849  			b1 = new_block(cstate, JMP(BPF_JSET));
4850  			b1->s.k = 0x04;
4851  			b1->stmts = s;
4852  			gen_not(b1);
4853  			gen_and(b1, b0);
4854  			return b0;
4855  		case DLT_IP_OVER_FC:
4856  			b0 = gen_mac_multicast(cstate, 2);
4857  			return b0;
4858  		default:
4859  			break;
4860  		}
4861  		break;
4862  	case Q_IP:
4863  		b0 = gen_linktype(cstate, ETHERTYPE_IP);
4864  		b1 = gen_cmp_ge(cstate, OR_LINKPL, 16, BPF_B, 224);
4865  		gen_and(b0, b1);
4866  		return b1;
4867  	case Q_IPV6:
4868  		b0 = gen_linktype(cstate, ETHERTYPE_IPV6);
4869  		b1 = gen_cmp(cstate, OR_LINKPL, 24, BPF_B, 255);
4870  		gen_and(b0, b1);
4871  		return b1;
4872  	}
4873  	bpf_error(cstate, "link-layer multicast filters supported only on ethernet/FDDI/token ring/ARCNET/802.11/ATM LANE/Fibre Channel");
4874  }
4875  struct block *
4876  gen_ifindex(compiler_state_t *cstate, int ifindex)
4877  {
4878  	register struct block *b0;
4879  	if (setjmp(cstate->top_ctx))
4880  		return (NULL);
4881  	switch (cstate->linktype) {
4882  	case DLT_LINUX_SLL2:
4883  		b0 = gen_cmp(cstate, OR_LINKHDR, 4, BPF_W, ifindex);
4884  		break;
4885          default:
4886  #if defined(linux)
4887  		if (cstate->bpf_pcap->rfile != NULL) {
4888  			bpf_error(cstate, "ifindex not supported on %s when reading savefiles",
4889  			    pcap_datalink_val_to_description_or_dlt(cstate->linktype));
4890  		}
4891  		b0 = gen_cmp(cstate, OR_LINKHDR, SKF_AD_OFF + SKF_AD_IFINDEX, BPF_W,
4892  		             ifindex);
4893  #else &bsol;* defined(linux) */
4894  		bpf_error(cstate, "ifindex not supported on %s",
4895  		    pcap_datalink_val_to_description_or_dlt(cstate->linktype));
4896  #endif &bsol;* defined(linux) */
4897  	}
4898  	return (b0);
4899  }
4900  struct block *
4901  gen_inbound(compiler_state_t *cstate, int dir)
4902  {
4903  	register struct block *b0;
4904  	if (setjmp(cstate->top_ctx))
4905  		return (NULL);
4906  	switch (cstate->linktype) {
4907  	case DLT_SLIP:
4908  		b0 = gen_relation_internal(cstate, BPF_JEQ,
4909  			  gen_load_internal(cstate, Q_LINK, gen_loadi_internal(cstate, 0), 1),
4910  			  gen_loadi_internal(cstate, 0),
4911  			  dir);
4912  		break;
4913  	case DLT_IPNET:
4914  		if (dir) {
4915  			b0 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, IPNET_OUTBOUND);
4916  		} else {
4917  			b0 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, IPNET_INBOUND);
4918  		}
4919  		break;
4920  	case DLT_LINUX_SLL:
4921  		b0 = gen_cmp(cstate, OR_LINKHDR, 0, BPF_H, LINUX_SLL_OUTGOING);
4922  		if (!dir) {
4923  			gen_not(b0);
4924  		}
4925  		break;
4926  	case DLT_LINUX_SLL2:
4927  		b0 = gen_cmp(cstate, OR_LINKHDR, 10, BPF_B, LINUX_SLL_OUTGOING);
4928  		if (!dir) {
4929  			gen_not(b0);
4930  		}
4931  		break;
4932  	case DLT_PFLOG:
4933  		b0 = gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, dir), BPF_B,
4934  		    ((dir == 0) ? PF_IN : PF_OUT));
4935  		break;
4936  	case DLT_PPP_PPPD:
4937  		if (dir) {
4938  			b0 = gen_cmp(cstate, OR_LINKHDR, 0, BPF_B, PPP_PPPD_OUT);
4939  		} else {
4940  			b0 = gen_cmp(cstate, OR_LINKHDR, 0, BPF_B, PPP_PPPD_IN);
4941  		}
4942  		break;
4943          case DLT_JUNIPER_MFR:
4944          case DLT_JUNIPER_MLFR:
4945          case DLT_JUNIPER_MLPPP:
4946  	case DLT_JUNIPER_ATM1:
4947  	case DLT_JUNIPER_ATM2:
4948  	case DLT_JUNIPER_PPPOE:
4949  	case DLT_JUNIPER_PPPOE_ATM:
4950          case DLT_JUNIPER_GGSN:
4951          case DLT_JUNIPER_ES:
4952          case DLT_JUNIPER_MONITOR:
4953          case DLT_JUNIPER_SERVICES:
4954          case DLT_JUNIPER_ETHER:
4955          case DLT_JUNIPER_PPP:
4956          case DLT_JUNIPER_FRELAY:
4957          case DLT_JUNIPER_CHDLC:
4958          case DLT_JUNIPER_VP:
4959          case DLT_JUNIPER_ST:
4960          case DLT_JUNIPER_ISM:
4961          case DLT_JUNIPER_VS:
4962          case DLT_JUNIPER_SRX_E2E:
4963          case DLT_JUNIPER_FIBRECHANNEL:
4964  	case DLT_JUNIPER_ATM_CEMIC:
4965  		if (dir) {
4966  			b0 = gen_mcmp(cstate, OR_LINKHDR, 3, BPF_B, 0, 0x01);
4967  		} else {
4968  			b0 = gen_mcmp(cstate, OR_LINKHDR, 3, BPF_B, 1, 0x01);
4969  		}
4970  		break;
4971  	default:
4972  #if defined(linux)
4973  		if (cstate->bpf_pcap->rfile != NULL) {
4974  			bpf_error(cstate, "inbound/outbound not supported on %s when reading savefiles",
4975  			    pcap_datalink_val_to_description_or_dlt(cstate->linktype));
4976  		}
4977  		b0 = gen_cmp(cstate, OR_LINKHDR, SKF_AD_OFF + SKF_AD_PKTTYPE, BPF_H,
4978  		             PACKET_OUTGOING);
4979  		if (!dir) {
4980  			gen_not(b0);
4981  		}
4982  #else &bsol;* defined(linux) */
4983  		bpf_error(cstate, "inbound/outbound not supported on %s",
4984  		    pcap_datalink_val_to_description_or_dlt(cstate->linktype));
4985  #endif &bsol;* defined(linux) */
4986  	}
4987  	return (b0);
4988  }
4989  struct block *
4990  gen_pf_ifname(compiler_state_t *cstate, const char *ifname)
4991  {
4992  	struct block *b0;
4993  	u_int len, off;
4994  	if (setjmp(cstate->top_ctx))
4995  		return (NULL);
4996  	if (cstate->linktype != DLT_PFLOG) {
4997  		bpf_error(cstate, "ifname supported only on PF linktype");
4998  	}
4999  	len = sizeof(((struct pfloghdr *)0)->ifname);
5000  	off = offsetof(struct pfloghdr, ifname);
5001  	if (strlen(ifname) >= len) {
5002  		bpf_error(cstate, "ifname interface names can only be %d characters",
5003  		    len-1);
5004  	}
5005  	b0 = gen_bcmp(cstate, OR_LINKHDR, off, (u_int)strlen(ifname),
5006  	    (const u_char *)ifname);
5007  	return (b0);
5008  }
5009  struct block *
5010  gen_pf_ruleset(compiler_state_t *cstate, char *ruleset)
5011  {
5012  	struct block *b0;
5013  	if (setjmp(cstate->top_ctx))
5014  		return (NULL);
5015  	if (cstate->linktype != DLT_PFLOG) {
5016  		bpf_error(cstate, "ruleset supported only on PF linktype");
5017  	}
5018  	if (strlen(ruleset) >= sizeof(((struct pfloghdr *)0)->ruleset)) {
5019  		bpf_error(cstate, "ruleset names can only be %ld characters",
5020  		    (long)(sizeof(((struct pfloghdr *)0)->ruleset) - 1));
5021  	}
5022  	b0 = gen_bcmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, ruleset),
5023  	    (u_int)strlen(ruleset), (const u_char *)ruleset);
5024  	return (b0);
5025  }
5026  struct block *
5027  gen_pf_rnr(compiler_state_t *cstate, int rnr)
5028  {
5029  	struct block *b0;
5030  	if (setjmp(cstate->top_ctx))
5031  		return (NULL);
5032  	if (cstate->linktype != DLT_PFLOG) {
5033  		bpf_error(cstate, "rnr supported only on PF linktype");
5034  	}
5035  	b0 = gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, rulenr), BPF_W,
5036  		 (bpf_u_int32)rnr);
5037  	return (b0);
5038  }
5039  struct block *
5040  gen_pf_srnr(compiler_state_t *cstate, int srnr)
5041  {
5042  	struct block *b0;
5043  	if (setjmp(cstate->top_ctx))
5044  		return (NULL);
5045  	if (cstate->linktype != DLT_PFLOG) {
5046  		bpf_error(cstate, "srnr supported only on PF linktype");
5047  	}
5048  	b0 = gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, subrulenr), BPF_W,
5049  	    (bpf_u_int32)srnr);
5050  	return (b0);
5051  }
5052  struct block *
5053  gen_pf_reason(compiler_state_t *cstate, int reason)
5054  {
5055  	struct block *b0;
5056  	if (setjmp(cstate->top_ctx))
5057  		return (NULL);
5058  	if (cstate->linktype != DLT_PFLOG) {
5059  		bpf_error(cstate, "reason supported only on PF linktype");
5060  	}
5061  	b0 = gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, reason), BPF_B,
5062  	    (bpf_u_int32)reason);
5063  	return (b0);
5064  }
5065  struct block *
5066  gen_pf_action(compiler_state_t *cstate, int action)
5067  {
5068  	struct block *b0;
5069  	if (setjmp(cstate->top_ctx))
5070  		return (NULL);
5071  	if (cstate->linktype != DLT_PFLOG) {
5072  		bpf_error(cstate, "action supported only on PF linktype");
5073  	}
5074  	b0 = gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, action), BPF_B,
5075  	    (bpf_u_int32)action);
5076  	return (b0);
5077  }
5078  struct block *
5079  gen_p80211_type(compiler_state_t *cstate, bpf_u_int32 type, bpf_u_int32 mask)
5080  {
5081  	struct block *b0;
5082  	if (setjmp(cstate->top_ctx))
5083  		return (NULL);
5084  	switch (cstate->linktype) {
5085  	case DLT_IEEE802_11:
5086  	case DLT_PRISM_HEADER:
5087  	case DLT_IEEE802_11_RADIO_AVS:
5088  	case DLT_IEEE802_11_RADIO:
5089  		b0 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, type, mask);
5090  		break;
5091  	default:
5092  		bpf_error(cstate, "802.11 link-layer types supported only on 802.11");
5093  	}
5094  	return (b0);
5095  }
5096  struct block *
5097  gen_p80211_fcdir(compiler_state_t *cstate, bpf_u_int32 fcdir)
5098  {
5099  	struct block *b0;
5100  	if (setjmp(cstate->top_ctx))
5101  		return (NULL);
5102  	switch (cstate->linktype) {
5103  	case DLT_IEEE802_11:
5104  	case DLT_PRISM_HEADER:
5105  	case DLT_IEEE802_11_RADIO_AVS:
5106  	case DLT_IEEE802_11_RADIO:
5107  		break;
5108  	default:
5109  		bpf_error(cstate, "frame direction supported only with 802.11 headers");
5110  	}
5111  	b0 = gen_mcmp(cstate, OR_LINKHDR, 1, BPF_B, fcdir,
5112  	    IEEE80211_FC1_DIR_MASK);
5113  	return (b0);
5114  }
5115  struct block *
5116  gen_acode(compiler_state_t *cstate, const char *s, struct qual q)
5117  {
5118  	struct block *b;
5119  	if (setjmp(cstate->top_ctx))
5120  		return (NULL);
5121  	switch (cstate->linktype) {
5122  	case DLT_ARCNET:
5123  	case DLT_ARCNET_LINUX:
5124  		if ((q.addr == Q_HOST || q.addr == Q_DEFAULT) &&
5125  		    q.proto == Q_LINK) {
5126  			cstate->e = pcap_ether_aton(s);
5127  			if (cstate->e == NULL)
5128  				bpf_error(cstate, "malloc");
5129  			b = gen_ahostop(cstate, cstate->e, (int)q.dir);
5130  			free(cstate->e);
5131  			cstate->e = NULL;
5132  			return (b);
5133  		} else
5134  			bpf_error(cstate, "ARCnet address used in non-arc expression");
5135  	default:
5136  		bpf_error(cstate, "aid supported only on ARCnet");
5137  	}
5138  }
5139  static struct block *
5140  gen_ahostop(compiler_state_t *cstate, const u_char *eaddr, int dir)
5141  {
5142  	register struct block *b0, *b1;
5143  	switch (dir) {
5144  	case Q_SRC:
5145  		return gen_bcmp(cstate, OR_LINKHDR, 0, 1, eaddr);
5146  	case Q_DST:
5147  		return gen_bcmp(cstate, OR_LINKHDR, 1, 1, eaddr);
5148  	case Q_AND:
5149  		b0 = gen_ahostop(cstate, eaddr, Q_SRC);
5150  		b1 = gen_ahostop(cstate, eaddr, Q_DST);
5151  		gen_and(b0, b1);
5152  		return b1;
5153  	case Q_DEFAULT:
5154  	case Q_OR:
5155  		b0 = gen_ahostop(cstate, eaddr, Q_SRC);
5156  		b1 = gen_ahostop(cstate, eaddr, Q_DST);
5157  		gen_or(b0, b1);
5158  		return b1;
5159  	case Q_ADDR1:
5160  		bpf_error(cstate, "'addr1' and 'address1' are only supported on 802.11");
5161  	case Q_ADDR2:
5162  		bpf_error(cstate, "'addr2' and 'address2' are only supported on 802.11");
5163  	case Q_ADDR3:
5164  		bpf_error(cstate, "'addr3' and 'address3' are only supported on 802.11");
5165  	case Q_ADDR4:
5166  		bpf_error(cstate, "'addr4' and 'address4' are only supported on 802.11");
5167  	case Q_RA:
5168  		bpf_error(cstate, "'ra' is only supported on 802.11");
5169  	case Q_TA:
5170  		bpf_error(cstate, "'ta' is only supported on 802.11");
5171  	}
5172  	abort();
5173  }
5174  static struct block *
5175  gen_vlan_tpid_test(compiler_state_t *cstate)
5176  {
5177  	struct block *b0, *b1;
5178  	b0 = gen_linktype(cstate, ETHERTYPE_8021Q);
5179  	b1 = gen_linktype(cstate, ETHERTYPE_8021AD);
5180  	gen_or(b0,b1);
5181  	b0 = b1;
5182  	b1 = gen_linktype(cstate, ETHERTYPE_8021QINQ);
5183  	gen_or(b0,b1);
5184  	return b1;
5185  }
5186  static struct block *
5187  gen_vlan_vid_test(compiler_state_t *cstate, bpf_u_int32 vlan_num)
5188  {
5189  	if (vlan_num > 0x0fff) {
5190  		bpf_error(cstate, "VLAN tag %u greater than maximum %u",
5191  		    vlan_num, 0x0fff);
5192  	}
5193  	return gen_mcmp(cstate, OR_LINKPL, 0, BPF_H, vlan_num, 0x0fff);
5194  }
5195  static struct block *
5196  gen_vlan_no_bpf_extensions(compiler_state_t *cstate, bpf_u_int32 vlan_num,
5197      int has_vlan_tag)
5198  {
5199  	struct block *b0, *b1;
5200  	b0 = gen_vlan_tpid_test(cstate);
5201  	if (has_vlan_tag) {
5202  		b1 = gen_vlan_vid_test(cstate, vlan_num);
5203  		gen_and(b0, b1);
5204  		b0 = b1;
5205  	}
5206  	cstate->off_linkpl.constant_part += 4;
5207  	cstate->off_linktype.constant_part += 4;
5208  	return b0;
5209  }
5210  #if defined(SKF_AD_VLAN_TAG_PRESENT)
5211  static void
5212  gen_vlan_vloffset_add(compiler_state_t *cstate, bpf_abs_offset *off,
5213      bpf_u_int32 v, struct slist *s)
5214  {
5215  	struct slist *s2;
5216  	if (!off->is_variable)
5217  		off->is_variable = 1;
5218  	if (off->reg == -1)
5219  		off->reg = alloc_reg(cstate);
5220  	s2 = new_stmt(cstate, BPF_LD|BPF_MEM);
5221  	s2->s.k = off->reg;
5222  	sappend(s, s2);
5223  	s2 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_IMM);
5224  	s2->s.k = v;
5225  	sappend(s, s2);
5226  	s2 = new_stmt(cstate, BPF_ST);
5227  	s2->s.k = off->reg;
5228  	sappend(s, s2);
5229  }
5230  static void
5231  gen_vlan_patch_tpid_test(compiler_state_t *cstate, struct block *b_tpid)
5232  {
5233  	struct slist s;
5234  	s.next = NULL;
5235  	cstate->is_vlan_vloffset = 1;
5236  	gen_vlan_vloffset_add(cstate, &cstate->off_linkpl, 4, &s);
5237  	gen_vlan_vloffset_add(cstate, &cstate->off_linktype, 4, &s);
5238  	sappend(s.next, b_tpid->head->stmts);
5239  	b_tpid->head->stmts = s.next;
5240  }
5241  static void
5242  gen_vlan_patch_vid_test(compiler_state_t *cstate, struct block *b_vid)
5243  {
5244  	struct slist *s, *s2, *sjeq;
5245  	unsigned cnt;
5246  	s = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);
5247  	s->s.k = SKF_AD_OFF + SKF_AD_VLAN_TAG_PRESENT;
5248  	sjeq = new_stmt(cstate, JMP(BPF_JEQ));
5249  	sjeq->s.k = 1;
5250  	sjeq->s.jf = b_vid->stmts;
5251  	sappend(s, sjeq);
5252  	s2 = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);
5253  	s2->s.k = SKF_AD_OFF + SKF_AD_VLAN_TAG;
5254  	sappend(s, s2);
5255  	sjeq->s.jt = s2;
5256  	cnt = 0;
5257  	for (s2 = b_vid->stmts; s2; s2 = s2->next)
5258  		cnt++;
5259  	s2 = new_stmt(cstate, JMP(BPF_JA));
5260  	s2->s.k = cnt - 1;
5261  	sappend(s, s2);
5262  	sappend(s, b_vid->stmts);
5263  	b_vid->stmts = s;
5264  }
5265  static struct block *
5266  gen_vlan_bpf_extensions(compiler_state_t *cstate, bpf_u_int32 vlan_num,
5267      int has_vlan_tag)
5268  {
5269          struct block *b0, *b_tpid, *b_vid = NULL;
5270          struct slist *s;
5271          s = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);
5272          s->s.k = SKF_AD_OFF + SKF_AD_VLAN_TAG_PRESENT;
5273          b0 = new_block(cstate, JMP(BPF_JEQ));
5274          b0->stmts = s;
5275          b0->s.k = 1;
5276  	b_tpid = gen_vlan_tpid_test(cstate);
5277  	if (has_vlan_tag)
5278  		b_vid = gen_vlan_vid_test(cstate, vlan_num);
5279  	gen_vlan_patch_tpid_test(cstate, b_tpid);
5280  	gen_or(b0, b_tpid);
5281  	b0 = b_tpid;
5282  	if (has_vlan_tag) {
5283  		gen_vlan_patch_vid_test(cstate, b_vid);
5284  		gen_and(b0, b_vid);
5285  		b0 = b_vid;
5286  	}
5287          return b0;
5288  }
5289  #endif
5290  struct block *
5291  gen_vlan(compiler_state_t *cstate, bpf_u_int32 vlan_num, int has_vlan_tag)
5292  {
5293  	struct	block	*b0;
5294  	if (setjmp(cstate->top_ctx))
5295  		return (NULL);
5296  	if (cstate->label_stack_depth > 0)
5297  		bpf_error(cstate, "no VLAN match after MPLS");
5298  	switch (cstate->linktype) {
5299  	case DLT_EN10MB:
5300  	case DLT_NETANALYZER:
5301  	case DLT_NETANALYZER_TRANSPARENT:
5302  #if defined(SKF_AD_VLAN_TAG_PRESENT)
5303  		if (cstate->vlan_stack_depth == 0 && !cstate->off_linkhdr.is_variable &&
5304  		    cstate->off_linkhdr.constant_part ==
5305  		    cstate->off_outermostlinkhdr.constant_part) {
5306  			if (cstate->bpf_pcap->bpf_codegen_flags & BPF_SPECIAL_VLAN_HANDLING)
5307  				b0 = gen_vlan_bpf_extensions(cstate, vlan_num,
5308  				    has_vlan_tag);
5309  			else
5310  				b0 = gen_vlan_no_bpf_extensions(cstate,
5311  				    vlan_num, has_vlan_tag);
5312  		} else
5313  #endif
5314  			b0 = gen_vlan_no_bpf_extensions(cstate, vlan_num,
5315  			    has_vlan_tag);
5316                  break;
5317  	case DLT_IEEE802_11:
5318  	case DLT_PRISM_HEADER:
5319  	case DLT_IEEE802_11_RADIO_AVS:
5320  	case DLT_IEEE802_11_RADIO:
5321  		b0 = gen_vlan_no_bpf_extensions(cstate, vlan_num, has_vlan_tag);
5322  		break;
5323  	default:
5324  		bpf_error(cstate, "no VLAN support for %s",
5325  		      pcap_datalink_val_to_description_or_dlt(cstate->linktype));
5326  	}
5327          cstate->vlan_stack_depth++;
5328  	return (b0);
5329  }
5330  struct block *
5331  gen_mpls(compiler_state_t *cstate, bpf_u_int32 label_num_arg,
5332      int has_label_num)
5333  {
5334  	volatile bpf_u_int32 label_num = label_num_arg;
5335  	struct	block	*b0, *b1;
5336  	if (setjmp(cstate->top_ctx))
5337  		return (NULL);
5338          if (cstate->label_stack_depth > 0) {
5339              b0 = gen_mcmp(cstate, OR_PREVMPLSHDR, 2, BPF_B, 0, 0x01);
5340          } else {
5341              switch (cstate->linktype) {
5342              case DLT_C_HDLC: &bsol;* fall through */
5343              case DLT_HDLC:
5344              case DLT_EN10MB:
5345              case DLT_NETANALYZER:
5346              case DLT_NETANALYZER_TRANSPARENT:
5347                      b0 = gen_linktype(cstate, ETHERTYPE_MPLS);
5348                      break;
5349              case DLT_PPP:
5350                      b0 = gen_linktype(cstate, PPP_MPLS_UCAST);
5351                      break;
5352              default:
5353                      bpf_error(cstate, "no MPLS support for %s",
5354                            pcap_datalink_val_to_description_or_dlt(cstate->linktype));
5355              }
5356          }
5357  	if (has_label_num) {
5358  		if (label_num > 0xFFFFF) {
5359  			bpf_error(cstate, "MPLS label %u greater than maximum %u",
5360  			    label_num, 0xFFFFF);
5361  		}
5362  		label_num = label_num << 12; &bsol;* label is shifted 12 bits on the wire */
5363  		b1 = gen_mcmp(cstate, OR_LINKPL, 0, BPF_W, label_num,
5364  		    0xfffff000); &bsol;* only compare the first 20 bits */
5365  		gen_and(b0, b1);
5366  		b0 = b1;
5367  	}
5368          cstate->off_nl_nosnap += 4;
5369          cstate->off_nl += 4;
5370          cstate->label_stack_depth++;
5371  	return (b0);
5372  }
5373  struct block *
5374  gen_pppoed(compiler_state_t *cstate)
5375  {
5376  	if (setjmp(cstate->top_ctx))
5377  		return (NULL);
5378  	return gen_linktype(cstate, ETHERTYPE_PPPOED);
5379  }
5380  struct block *
5381  gen_pppoes(compiler_state_t *cstate, bpf_u_int32 sess_num, int has_sess_num)
5382  {
5383  	struct block *b0, *b1;
5384  	if (setjmp(cstate->top_ctx))
5385  		return (NULL);
5386  	b0 = gen_linktype(cstate, ETHERTYPE_PPPOES);
5387  	if (has_sess_num) {
5388  		if (sess_num > 0x0000ffff) {
5389  			bpf_error(cstate, "PPPoE session number %u greater than maximum %u",
5390  			    sess_num, 0x0000ffff);
5391  		}
5392  		b1 = gen_mcmp(cstate, OR_LINKPL, 0, BPF_W, sess_num, 0x0000ffff);
5393  		gen_and(b0, b1);
5394  		b0 = b1;
5395  	}
5396  	PUSH_LINKHDR(cstate, DLT_PPP, cstate->off_linkpl.is_variable,
5397  	    cstate->off_linkpl.constant_part + cstate->off_nl + 6, &bsol;* 6 bytes past the PPPoE header */
5398  	    cstate->off_linkpl.reg);
5399  	cstate->off_linktype = cstate->off_linkhdr;
5400  	cstate->off_linkpl.constant_part = cstate->off_linkhdr.constant_part + 2;
5401  	cstate->off_nl = 0;
5402  	cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
5403  	return b0;
5404  }
5405  static struct block *
5406  gen_geneve_check(compiler_state_t *cstate,
5407      struct block *(*gen_portfn)(compiler_state_t *, u_int, int, int),
5408      enum e_offrel offrel, bpf_u_int32 vni, int has_vni)
5409  {
5410  	struct block *b0, *b1;
5411  	b0 = gen_portfn(cstate, GENEVE_PORT, IPPROTO_UDP, Q_DST);
5412  	b1 = gen_mcmp(cstate, offrel, 8, BPF_B, 0, 0xc0);
5413  	gen_and(b0, b1);
5414  	b0 = b1;
5415  	if (has_vni) {
5416  		if (vni > 0xffffff) {
5417  			bpf_error(cstate, "Geneve VNI %u greater than maximum %u",
5418  			    vni, 0xffffff);
5419  		}
5420  		vni <<= 8; &bsol;* VNI is in the upper 3 bytes */
5421  		b1 = gen_mcmp(cstate, offrel, 12, BPF_W, vni, 0xffffff00);
5422  		gen_and(b0, b1);
5423  		b0 = b1;
5424  	}
5425  	return b0;
5426  }
5427  static struct block *
5428  gen_geneve4(compiler_state_t *cstate, bpf_u_int32 vni, int has_vni)
5429  {
5430  	struct block *b0, *b1;
5431  	struct slist *s, *s1;
5432  	b0 = gen_geneve_check(cstate, gen_port, OR_TRAN_IPV4, vni, has_vni);
5433  	s = gen_loadx_iphdrlen(cstate);
5434  	s1 = new_stmt(cstate, BPF_MISC|BPF_TXA);
5435  	sappend(s, s1);
5436  	b1 = new_block(cstate, BPF_JMP|BPF_JEQ|BPF_X);
5437  	b1->stmts = s;
5438  	b1->s.k = 0;
5439  	gen_and(b0, b1);
5440  	return b1;
5441  }
5442  static struct block *
5443  gen_geneve6(compiler_state_t *cstate, bpf_u_int32 vni, int has_vni)
5444  {
5445  	struct block *b0, *b1;
5446  	struct slist *s, *s1;
5447  	b0 = gen_geneve_check(cstate, gen_port6, OR_TRAN_IPV6, vni, has_vni);
5448  	s = gen_abs_offset_varpart(cstate, &cstate->off_linkpl);
5449  	if (s) {
5450  		s1 = new_stmt(cstate, BPF_LD|BPF_IMM);
5451  		s1->s.k = 40;
5452  		sappend(s, s1);
5453  		s1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X);
5454  		s1->s.k = 0;
5455  		sappend(s, s1);
5456  	} else {
5457  		s = new_stmt(cstate, BPF_LD|BPF_IMM);
5458  		s->s.k = 40;
5459  	}
5460  	s1 = new_stmt(cstate, BPF_MISC|BPF_TAX);
5461  	sappend(s, s1);
5462  	b1 = new_block(cstate, BPF_JMP|BPF_JEQ|BPF_X);
5463  	b1->stmts = s;
5464  	b1->s.k = 0;
5465  	gen_and(b0, b1);
5466  	return b1;
5467  }
5468  static struct slist *
5469  gen_geneve_offsets(compiler_state_t *cstate)
5470  {
5471  	struct slist *s, *s1, *s_proto;
5472  	s = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);
5473  	s->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + 8;
5474  	s1 = new_stmt(cstate, BPF_MISC|BPF_TAX);
5475  	sappend(s, s1);
5476  	s1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);
5477  	s1->s.k = 2;
5478  	sappend(s, s1);
5479  	cstate->off_linktype.reg = alloc_reg(cstate);
5480  	cstate->off_linktype.is_variable = 1;
5481  	cstate->off_linktype.constant_part = 0;
5482  	s1 = new_stmt(cstate, BPF_ST);
5483  	s1->s.k = cstate->off_linktype.reg;
5484  	sappend(s, s1);
5485  	s1 = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);
5486  	s1->s.k = 0;
5487  	sappend(s, s1);
5488  	s1 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);
5489  	s1->s.k = 0x3f;
5490  	sappend(s, s1);
5491  	s1 = new_stmt(cstate, BPF_ALU|BPF_MUL|BPF_K);
5492  	s1->s.k = 4;
5493  	sappend(s, s1);
5494  	s1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);
5495  	s1->s.k = 8;
5496  	sappend(s, s1);
5497  	s1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X);
5498  	s1->s.k = 0;
5499  	sappend(s, s1);
5500  	PUSH_LINKHDR(cstate, DLT_EN10MB, 1, 0, alloc_reg(cstate));
5501  	s1 = new_stmt(cstate, BPF_ST);
5502  	s1->s.k = cstate->off_linkhdr.reg;
5503  	sappend(s, s1);
5504  	cstate->no_optimize = 1;
5505  	s1 = new_stmt(cstate, BPF_LD|BPF_IND|BPF_H);
5506  	s1->s.k = 2;
5507  	sappend(s, s1);
5508  	s1 = new_stmt(cstate, BPF_LDX|BPF_MEM);
5509  	s1->s.k = cstate->off_linkhdr.reg;
5510  	sappend(s, s1);
5511  	s_proto = new_stmt(cstate, JMP(BPF_JEQ));
5512  	s_proto->s.k = ETHERTYPE_TEB;
5513  	sappend(s, s_proto);
5514  	s1 = new_stmt(cstate, BPF_MISC|BPF_TXA);
5515  	sappend(s, s1);
5516  	s_proto->s.jt = s1;
5517  	s1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);
5518  	s1->s.k = 12;
5519  	sappend(s, s1);
5520  	s1 = new_stmt(cstate, BPF_ST);
5521  	s1->s.k = cstate->off_linktype.reg;
5522  	sappend(s, s1);
5523  	s1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);
5524  	s1->s.k = 2;
5525  	sappend(s, s1);
5526  	s1 = new_stmt(cstate, BPF_MISC|BPF_TAX);
5527  	sappend(s, s1);
5528  	cstate->off_linkpl.reg = alloc_reg(cstate);
5529  	cstate->off_linkpl.is_variable = 1;
5530  	cstate->off_linkpl.constant_part = 0;
5531  	s1 = new_stmt(cstate, BPF_STX);
5532  	s1->s.k = cstate->off_linkpl.reg;
5533  	sappend(s, s1);
5534  	s_proto->s.jf = s1;
5535  	cstate->off_nl = 0;
5536  	return s;
5537  }
5538  struct block *
5539  gen_geneve(compiler_state_t *cstate, bpf_u_int32 vni, int has_vni)
5540  {
5541  	struct block *b0, *b1;
5542  	struct slist *s;
5543  	if (setjmp(cstate->top_ctx))
5544  		return (NULL);
5545  	b0 = gen_geneve4(cstate, vni, has_vni);
5546  	b1 = gen_geneve6(cstate, vni, has_vni);
5547  	gen_or(b0, b1);
5548  	b0 = b1;
5549  	s = gen_geneve_offsets(cstate);
5550  	b1 = gen_true(cstate);
5551  	sappend(s, b1->stmts);
5552  	b1->stmts = s;
5553  	gen_and(b0, b1);
5554  	cstate->is_geneve = 1;
5555  	return b1;
5556  }
5557  static struct block *
5558  gen_geneve_ll_check(compiler_state_t *cstate)
5559  {
5560  	struct block *b0;
5561  	struct slist *s, *s1;
5562  	s = new_stmt(cstate, BPF_LD|BPF_MEM);
5563  	s->s.k = cstate->off_linkhdr.reg;
5564  	s1 = new_stmt(cstate, BPF_LDX|BPF_MEM);
5565  	s1->s.k = cstate->off_linkpl.reg;
5566  	sappend(s, s1);
5567  	b0 = new_block(cstate, BPF_JMP|BPF_JEQ|BPF_X);
5568  	b0->stmts = s;
5569  	b0->s.k = 0;
5570  	gen_not(b0);
5571  	return b0;
5572  }
5573  static struct block *
5574  gen_atmfield_code_internal(compiler_state_t *cstate, int atmfield,
5575      bpf_u_int32 jvalue, int jtype, int reverse)
5576  {
5577  	struct block *b0;
5578  	switch (atmfield) {
5579  	case A_VPI:
5580  		if (!cstate->is_atm)
5581  			bpf_error(cstate, "'vpi' supported only on raw ATM");
5582  		if (cstate->off_vpi == OFFSET_NOT_SET)
5583  			abort();
5584  		b0 = gen_ncmp(cstate, OR_LINKHDR, cstate->off_vpi, BPF_B,
5585  		    0xffffffffU, jtype, reverse, jvalue);
5586  		break;
5587  	case A_VCI:
5588  		if (!cstate->is_atm)
5589  			bpf_error(cstate, "'vci' supported only on raw ATM");
5590  		if (cstate->off_vci == OFFSET_NOT_SET)
5591  			abort();
5592  		b0 = gen_ncmp(cstate, OR_LINKHDR, cstate->off_vci, BPF_H,
5593  		    0xffffffffU, jtype, reverse, jvalue);
5594  		break;
5595  	case A_PROTOTYPE:
5596  		if (cstate->off_proto == OFFSET_NOT_SET)
5597  			abort();	&bsol;* XXX - this isn't on FreeBSD */
5598  		b0 = gen_ncmp(cstate, OR_LINKHDR, cstate->off_proto, BPF_B,
5599  		    0x0fU, jtype, reverse, jvalue);
5600  		break;
5601  	case A_MSGTYPE:
5602  		if (cstate->off_payload == OFFSET_NOT_SET)
5603  			abort();
5604  		b0 = gen_ncmp(cstate, OR_LINKHDR, cstate->off_payload + MSG_TYPE_POS, BPF_B,
5605  		    0xffffffffU, jtype, reverse, jvalue);
5606  		break;
5607  	case A_CALLREFTYPE:
5608  		if (!cstate->is_atm)
5609  			bpf_error(cstate, "'callref' supported only on raw ATM");
5610  		if (cstate->off_proto == OFFSET_NOT_SET)
5611  			abort();
5612  		b0 = gen_ncmp(cstate, OR_LINKHDR, cstate->off_proto, BPF_B,
5613  		    0xffffffffU, jtype, reverse, jvalue);
5614  		break;
5615  	default:
5616  		abort();
5617  	}
5618  	return b0;
5619  }
5620  static struct block *
5621  gen_atmtype_metac(compiler_state_t *cstate)
5622  {
5623  	struct block *b0, *b1;
5624  	b0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);
5625  	b1 = gen_atmfield_code_internal(cstate, A_VCI, 1, BPF_JEQ, 0);
5626  	gen_and(b0, b1);
5627  	return b1;
5628  }
5629  static struct block *
5630  gen_atmtype_sc(compiler_state_t *cstate)
5631  {
5632  	struct block *b0, *b1;
5633  	b0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);
5634  	b1 = gen_atmfield_code_internal(cstate, A_VCI, 5, BPF_JEQ, 0);
5635  	gen_and(b0, b1);
5636  	return b1;
5637  }
5638  static struct block *
5639  gen_atmtype_llc(compiler_state_t *cstate)
5640  {
5641  	struct block *b0;
5642  	b0 = gen_atmfield_code_internal(cstate, A_PROTOTYPE, PT_LLC, BPF_JEQ, 0);
5643  	cstate->linktype = cstate->prevlinktype;
5644  	return b0;
5645  }
5646  struct block *
5647  gen_atmfield_code(compiler_state_t *cstate, int atmfield,
5648      bpf_u_int32 jvalue, int jtype, int reverse)
5649  {
5650  	if (setjmp(cstate->top_ctx))
5651  		return (NULL);
5652  	return gen_atmfield_code_internal(cstate, atmfield, jvalue, jtype,
5653  	    reverse);
5654  }
5655  struct block *
5656  gen_atmtype_abbrev(compiler_state_t *cstate, int type)
5657  {
5658  	struct block *b0, *b1;
5659  	if (setjmp(cstate->top_ctx))
5660  		return (NULL);
5661  	switch (type) {
5662  	case A_METAC:
5663  		if (!cstate->is_atm)
5664  			bpf_error(cstate, "'metac' supported only on raw ATM");
5665  		b1 = gen_atmtype_metac(cstate);
5666  		break;
5667  	case A_BCC:
5668  		if (!cstate->is_atm)
5669  			bpf_error(cstate, "'bcc' supported only on raw ATM");
5670  		b0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);
5671  		b1 = gen_atmfield_code_internal(cstate, A_VCI, 2, BPF_JEQ, 0);
5672  		gen_and(b0, b1);
5673  		break;
5674  	case A_OAMF4SC:
5675  		if (!cstate->is_atm)
5676  			bpf_error(cstate, "'oam4sc' supported only on raw ATM");
5677  		b0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);
5678  		b1 = gen_atmfield_code_internal(cstate, A_VCI, 3, BPF_JEQ, 0);
5679  		gen_and(b0, b1);
5680  		break;
5681  	case A_OAMF4EC:
5682  		if (!cstate->is_atm)
5683  			bpf_error(cstate, "'oam4ec' supported only on raw ATM");
5684  		b0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);
5685  		b1 = gen_atmfield_code_internal(cstate, A_VCI, 4, BPF_JEQ, 0);
5686  		gen_and(b0, b1);
5687  		break;
5688  	case A_SC:
5689  		if (!cstate->is_atm)
5690  			bpf_error(cstate, "'sc' supported only on raw ATM");
5691  		b1 = gen_atmtype_sc(cstate);
5692  		break;
5693  	case A_ILMIC:
5694  		if (!cstate->is_atm)
5695  			bpf_error(cstate, "'ilmic' supported only on raw ATM");
5696  		b0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);
5697  		b1 = gen_atmfield_code_internal(cstate, A_VCI, 16, BPF_JEQ, 0);
5698  		gen_and(b0, b1);
5699  		break;
5700  	case A_LANE:
5701  		if (!cstate->is_atm)
5702  			bpf_error(cstate, "'lane' supported only on raw ATM");
5703  		b1 = gen_atmfield_code_internal(cstate, A_PROTOTYPE, PT_LANE, BPF_JEQ, 0);
5704  		PUSH_LINKHDR(cstate, DLT_EN10MB, 0,
5705  		    cstate->off_payload + 2,	&bsol;* Ethernet header */
5706  		    -1);
5707  		cstate->off_linktype.constant_part = cstate->off_linkhdr.constant_part + 12;
5708  		cstate->off_linkpl.constant_part = cstate->off_linkhdr.constant_part + 14;	&bsol;* Ethernet */
5709  		cstate->off_nl = 0;			&bsol;* Ethernet II */
5710  		cstate->off_nl_nosnap = 3;		&bsol;* 802.3+802.2 */
5711  		break;
5712  	case A_LLC:
5713  		if (!cstate->is_atm)
5714  			bpf_error(cstate, "'llc' supported only on raw ATM");
5715  		b1 = gen_atmtype_llc(cstate);
5716  		break;
5717  	default:
5718  		abort();
5719  	}
5720  	return b1;
5721  }
5722  struct block *
5723  gen_mtp2type_abbrev(compiler_state_t *cstate, int type)
5724  {
5725  	struct block *b0, *b1;
5726  	if (setjmp(cstate->top_ctx))
5727  		return (NULL);
5728  	switch (type) {
5729  	case M_FISU:
5730  		if ( (cstate->linktype != DLT_MTP2) &&
5731  		     (cstate->linktype != DLT_ERF) &&
5732  		     (cstate->linktype != DLT_MTP2_WITH_PHDR) )
5733  			bpf_error(cstate, "'fisu' supported only on MTP2");
5734  		b0 = gen_ncmp(cstate, OR_PACKET, cstate->off_li, BPF_B,
5735  		    0x3fU, BPF_JEQ, 0, 0U);
5736  		break;
5737  	case M_LSSU:
5738  		if ( (cstate->linktype != DLT_MTP2) &&
5739  		     (cstate->linktype != DLT_ERF) &&
5740  		     (cstate->linktype != DLT_MTP2_WITH_PHDR) )
5741  			bpf_error(cstate, "'lssu' supported only on MTP2");
5742  		b0 = gen_ncmp(cstate, OR_PACKET, cstate->off_li, BPF_B,
5743  		    0x3fU, BPF_JGT, 1, 2U);
5744  		b1 = gen_ncmp(cstate, OR_PACKET, cstate->off_li, BPF_B,
5745  		    0x3fU, BPF_JGT, 0, 0U);
5746  		gen_and(b1, b0);
5747  		break;
5748  	case M_MSU:
5749  		if ( (cstate->linktype != DLT_MTP2) &&
5750  		     (cstate->linktype != DLT_ERF) &&
5751  		     (cstate->linktype != DLT_MTP2_WITH_PHDR) )
5752  			bpf_error(cstate, "'msu' supported only on MTP2");
5753  		b0 = gen_ncmp(cstate, OR_PACKET, cstate->off_li, BPF_B,
5754  		    0x3fU, BPF_JGT, 0, 2U);
5755  		break;
5756  	case MH_FISU:
5757  		if ( (cstate->linktype != DLT_MTP2) &&
5758  		     (cstate->linktype != DLT_ERF) &&
5759  		     (cstate->linktype != DLT_MTP2_WITH_PHDR) )
5760  			bpf_error(cstate, "'hfisu' supported only on MTP2_HSL");
5761  		b0 = gen_ncmp(cstate, OR_PACKET, cstate->off_li_hsl, BPF_H,
5762  		    0xff80U, BPF_JEQ, 0, 0U);
5763  		break;
5764  	case MH_LSSU:
5765  		if ( (cstate->linktype != DLT_MTP2) &&
5766  		     (cstate->linktype != DLT_ERF) &&
5767  		     (cstate->linktype != DLT_MTP2_WITH_PHDR) )
5768  			bpf_error(cstate, "'hlssu' supported only on MTP2_HSL");
5769  		b0 = gen_ncmp(cstate, OR_PACKET, cstate->off_li_hsl, BPF_H,
5770  		    0xff80U, BPF_JGT, 1, 0x0100U);
5771  		b1 = gen_ncmp(cstate, OR_PACKET, cstate->off_li_hsl, BPF_H,
5772  		    0xff80U, BPF_JGT, 0, 0U);
5773  		gen_and(b1, b0);
5774  		break;
5775  	case MH_MSU:
5776  		if ( (cstate->linktype != DLT_MTP2) &&
5777  		     (cstate->linktype != DLT_ERF) &&
5778  		     (cstate->linktype != DLT_MTP2_WITH_PHDR) )
5779  			bpf_error(cstate, "'hmsu' supported only on MTP2_HSL");
5780  		b0 = gen_ncmp(cstate, OR_PACKET, cstate->off_li_hsl, BPF_H,
5781  		    0xff80U, BPF_JGT, 0, 0x0100U);
5782  		break;
5783  	default:
5784  		abort();
5785  	}
5786  	return b0;
5787  }
5788  struct block *
5789  gen_mtp3field_code(compiler_state_t *cstate, int mtp3field,
5790      bpf_u_int32 jvalue_arg, int jtype, int reverse)
5791  {
5792  	volatile bpf_u_int32 jvalue = jvalue_arg;
5793  	struct block *b0;
5794  	bpf_u_int32 val1 , val2 , val3;
5795  	u_int newoff_sio;
5796  	u_int newoff_opc;
5797  	u_int newoff_dpc;
5798  	u_int newoff_sls;
5799  	if (setjmp(cstate->top_ctx))
5800  		return (NULL);
5801  	newoff_sio = cstate->off_sio;
5802  	newoff_opc = cstate->off_opc;
5803  	newoff_dpc = cstate->off_dpc;
5804  	newoff_sls = cstate->off_sls;
5805  	switch (mtp3field) {
5806  	case MH_SIO:
5807  		newoff_sio += 3; &bsol;* offset for MTP2_HSL */
5808  	case M_SIO:
5809  		if (cstate->off_sio == OFFSET_NOT_SET)
5810  			bpf_error(cstate, "'sio' supported only on SS7");
5811  		if(jvalue > 255)
5812  		        bpf_error(cstate, "sio value %u too big; max value = 255",
5813  		            jvalue);
5814  		b0 = gen_ncmp(cstate, OR_PACKET, newoff_sio, BPF_B, 0xffffffffU,
5815  		    jtype, reverse, jvalue);
5816  		break;
5817  	case MH_OPC:
5818  		newoff_opc += 3;
5819          case M_OPC:
5820  	        if (cstate->off_opc == OFFSET_NOT_SET)
<span onclick='openModal()' class='match'>5821  			bpf_error(cstate, "'opc' supported only on SS7");
5822  		if (jvalue > 16383)
5823  		        bpf_error(cstate, "opc value %u too big; max value = 16383",
5824  		            jvalue);
5825  		val1 = jvalue & 0x00003c00;
</span>5826  		val1 = val1 >>10;
5827  		val2 = jvalue & 0x000003fc;
5828  		val2 = val2 <<6;
5829  		val3 = jvalue & 0x00000003;
5830  		val3 = val3 <<22;
5831  		jvalue = val1 + val2 + val3;
5832  		b0 = gen_ncmp(cstate, OR_PACKET, newoff_opc, BPF_W, 0x00c0ff0fU,
5833  		    jtype, reverse, jvalue);
5834  		break;
5835  	case MH_DPC:
5836  		newoff_dpc += 3;
5837  	case M_DPC:
5838  	        if (cstate->off_dpc == OFFSET_NOT_SET)
5839  			bpf_error(cstate, "'dpc' supported only on SS7");
5840  		if (jvalue > 16383)
5841  		        bpf_error(cstate, "dpc value %u too big; max value = 16383",
5842  		            jvalue);
5843  		val1 = jvalue & 0x000000ff;
5844  		val1 = val1 << 24;
5845  		val2 = jvalue & 0x00003f00;
5846  		val2 = val2 << 8;
5847  		jvalue = val1 + val2;
5848  		b0 = gen_ncmp(cstate, OR_PACKET, newoff_dpc, BPF_W, 0xff3f0000U,
5849  		    jtype, reverse, jvalue);
5850  		break;
5851  	case MH_SLS:
5852  		newoff_sls += 3;
5853  	case M_SLS:
5854  	        if (cstate->off_sls == OFFSET_NOT_SET)
5855  			bpf_error(cstate, "'sls' supported only on SS7");
5856  		if (jvalue > 15)
5857  		         bpf_error(cstate, "sls value %u too big; max value = 15",
5858  		             jvalue);
5859  		jvalue = jvalue << 4;
5860  		b0 = gen_ncmp(cstate, OR_PACKET, newoff_sls, BPF_B, 0xf0U,
5861  		    jtype, reverse, jvalue);
5862  		break;
5863  	default:
5864  		abort();
5865  	}
5866  	return b0;
5867  }
5868  static struct block *
5869  gen_msg_abbrev(compiler_state_t *cstate, int type)
5870  {
5871  	struct block *b1;
5872  	switch (type) {
5873  	case A_SETUP:
5874  		b1 = gen_atmfield_code_internal(cstate, A_MSGTYPE, SETUP, BPF_JEQ, 0);
5875  		break;
5876  	case A_CALLPROCEED:
5877  		b1 = gen_atmfield_code_internal(cstate, A_MSGTYPE, CALL_PROCEED, BPF_JEQ, 0);
5878  		break;
5879  	case A_CONNECT:
5880  		b1 = gen_atmfield_code_internal(cstate, A_MSGTYPE, CONNECT, BPF_JEQ, 0);
5881  		break;
5882  	case A_CONNECTACK:
5883  		b1 = gen_atmfield_code_internal(cstate, A_MSGTYPE, CONNECT_ACK, BPF_JEQ, 0);
5884  		break;
5885  	case A_RELEASE:
5886  		b1 = gen_atmfield_code_internal(cstate, A_MSGTYPE, RELEASE, BPF_JEQ, 0);
5887  		break;
5888  	case A_RELEASE_DONE:
5889  		b1 = gen_atmfield_code_internal(cstate, A_MSGTYPE, RELEASE_DONE, BPF_JEQ, 0);
5890  		break;
5891  	default:
5892  		abort();
5893  	}
5894  	return b1;
5895  }
5896  struct block *
5897  gen_atmmulti_abbrev(compiler_state_t *cstate, int type)
5898  {
5899  	struct block *b0, *b1;
5900  	if (setjmp(cstate->top_ctx))
5901  		return (NULL);
5902  	switch (type) {
5903  	case A_OAM:
5904  		if (!cstate->is_atm)
5905  			bpf_error(cstate, "'oam' supported only on raw ATM");
5906  		b0 = gen_atmfield_code_internal(cstate, A_VCI, 3, BPF_JEQ, 0);
5907  		b1 = gen_atmfield_code_internal(cstate, A_VCI, 4, BPF_JEQ, 0);
5908  		gen_or(b0, b1);
5909  		b0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);
5910  		gen_and(b0, b1);
5911  		break;
5912  	case A_OAMF4:
5913  		if (!cstate->is_atm)
5914  			bpf_error(cstate, "'oamf4' supported only on raw ATM");
5915  		b0 = gen_atmfield_code_internal(cstate, A_VCI, 3, BPF_JEQ, 0);
5916  		b1 = gen_atmfield_code_internal(cstate, A_VCI, 4, BPF_JEQ, 0);
5917  		gen_or(b0, b1);
5918  		b0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);
5919  		gen_and(b0, b1);
5920  		break;
5921  	case A_CONNECTMSG:
5922  		if (!cstate->is_atm)
5923  			bpf_error(cstate, "'connectmsg' supported only on raw ATM");
5924  		b0 = gen_msg_abbrev(cstate, A_SETUP);
5925  		b1 = gen_msg_abbrev(cstate, A_CALLPROCEED);
5926  		gen_or(b0, b1);
5927  		b0 = gen_msg_abbrev(cstate, A_CONNECT);
5928  		gen_or(b0, b1);
5929  		b0 = gen_msg_abbrev(cstate, A_CONNECTACK);
5930  		gen_or(b0, b1);
5931  		b0 = gen_msg_abbrev(cstate, A_RELEASE);
5932  		gen_or(b0, b1);
5933  		b0 = gen_msg_abbrev(cstate, A_RELEASE_DONE);
5934  		gen_or(b0, b1);
5935  		b0 = gen_atmtype_sc(cstate);
5936  		gen_and(b0, b1);
5937  		break;
5938  	case A_METACONNECT:
5939  		if (!cstate->is_atm)
5940  			bpf_error(cstate, "'metaconnect' supported only on raw ATM");
5941  		b0 = gen_msg_abbrev(cstate, A_SETUP);
5942  		b1 = gen_msg_abbrev(cstate, A_CALLPROCEED);
5943  		gen_or(b0, b1);
5944  		b0 = gen_msg_abbrev(cstate, A_CONNECT);
5945  		gen_or(b0, b1);
5946  		b0 = gen_msg_abbrev(cstate, A_RELEASE);
5947  		gen_or(b0, b1);
5948  		b0 = gen_msg_abbrev(cstate, A_RELEASE_DONE);
5949  		gen_or(b0, b1);
5950  		b0 = gen_atmtype_metac(cstate);
5951  		gen_and(b0, b1);
5952  		break;
5953  	default:
5954  		abort();
5955  	}
5956  	return b1;
5957  }
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-gencode.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #ifdef _WIN32
5    #include <ws2tcpip.h>
6  #else
7    #include <sys/socket.h>
8    #ifdef __NetBSD__
9      #include <sys/param.h>
10    #endif
11    #include <netinet/in.h>
12    #include <arpa/inet.h>
13  #endif &bsol;* _WIN32 */
14  #include <stdlib.h>
15  #include <string.h>
16  #include <memory.h>
17  #include <setjmp.h>
18  #include <stdarg.h>
19  #include <stdio.h>
20  #ifdef MSDOS
21  #include "pcap-dos.h"
22  #endif
23  #include "pcap-int.h"
24  #include "extract.h"
25  #include "ethertype.h"
26  #include "nlpid.h"
27  #include "llc.h"
28  #include "gencode.h"
29  #include "ieee80211.h"
30  #include "atmuni31.h"
31  #include "sunatmpos.h"
32  #include "pflog.h"
33  #include "ppp.h"
34  #include "pcap/sll.h"
35  #include "pcap/ipnet.h"
36  #include "arcnet.h"
37  #include "diag-control.h"
38  #include "scanner.h"
39  #if defined(linux)
40  #include <linux/types.h>
41  #include <linux/if_packet.h>
42  #include <linux/filter.h>
43  #endif
44  #ifndef offsetof
45  #define offsetof(s, e) ((size_t)&((s *)0)->e)
46  #endif
47  #ifdef _WIN32
48    #ifdef INET6
49      #if defined(__MINGW32__) && defined(DEFINE_ADDITIONAL_IPV6_STUFF)
50  struct in6_addr
51    {
52      union
53        {
54  	uint8_t		u6_addr8[16];
55  	uint16_t	u6_addr16[8];
56  	uint32_t	u6_addr32[4];
57        } in6_u;
58  #define s6_addr			in6_u.u6_addr8
59  #define s6_addr16		in6_u.u6_addr16
60  #define s6_addr32		in6_u.u6_addr32
61  #define s6_addr64		in6_u.u6_addr64
62    };
63  typedef unsigned short	sa_family_t;
64  #define	__SOCKADDR_COMMON(sa_prefix) \
65    sa_family_t sa_prefix##family
66  struct sockaddr_in6
67    {
68      __SOCKADDR_COMMON (sin6_);
69      uint16_t sin6_port;		&bsol;* Transport layer port # */
70      uint32_t sin6_flowinfo;	&bsol;* IPv6 flow information */
71      struct in6_addr sin6_addr;	&bsol;* IPv6 address */
72    };
73        #ifndef EAI_ADDRFAMILY
74  struct addrinfo {
75  	int	ai_flags;	&bsol;* AI_PASSIVE, AI_CANONNAME */
76  	int	ai_family;	&bsol;* PF_xxx */
77  	int	ai_socktype;	&bsol;* SOCK_xxx */
78  	int	ai_protocol;	&bsol;* 0 or IPPROTO_xxx for IPv4 and IPv6 */
79  	size_t	ai_addrlen;	&bsol;* length of ai_addr */
80  	char	*ai_canonname;	&bsol;* canonical name for hostname */
81  	struct sockaddr *ai_addr;	&bsol;* binary address */
82  	struct addrinfo *ai_next;	&bsol;* next structure in linked list */
83  };
84        #endif &bsol;* EAI_ADDRFAMILY */
85      #endif &bsol;* defined(__MINGW32__) && defined(DEFINE_ADDITIONAL_IPV6_STUFF) */
86    #endif &bsol;* INET6 */
87  #else &bsol;* _WIN32 */
88    #include <netdb.h>	&bsol;* for "struct addrinfo" */
89  #endif &bsol;* _WIN32 */
90  #include <pcap/namedb.h>
91  #include "nametoaddr.h"
92  #define ETHERMTU	1500
93  #ifndef IPPROTO_HOPOPTS
94  #define IPPROTO_HOPOPTS 0
95  #endif
96  #ifndef IPPROTO_ROUTING
97  #define IPPROTO_ROUTING 43
98  #endif
99  #ifndef IPPROTO_FRAGMENT
100  #define IPPROTO_FRAGMENT 44
101  #endif
102  #ifndef IPPROTO_DSTOPTS
103  #define IPPROTO_DSTOPTS 60
104  #endif
105  #ifndef IPPROTO_SCTP
106  #define IPPROTO_SCTP 132
107  #endif
108  #define GENEVE_PORT 6081
109  #ifdef HAVE_OS_PROTO_H
110  #include "os-proto.h"
111  #endif
112  #define JMP(c) ((c)|BPF_JMP|BPF_K)
113  #define PUSH_LINKHDR(cs, new_linktype, new_is_variable, new_constant_part, new_reg) \
114  { \
115  	(cs)->prevlinktype = (cs)->linktype; \
116  	(cs)->off_prevlinkhdr = (cs)->off_linkhdr; \
117  	(cs)->linktype = (new_linktype); \
118  	(cs)->off_linkhdr.is_variable = (new_is_variable); \
119  	(cs)->off_linkhdr.constant_part = (new_constant_part); \
120  	(cs)->off_linkhdr.reg = (new_reg); \
121  	(cs)->is_geneve = 0; \
122  }
123  #define OFFSET_NOT_SET	0xffffffffU
124  typedef struct {
125  	int	is_variable;
126  	u_int	constant_part;
127  	int	reg;
128  } bpf_abs_offset;
129  enum e_offrel {
130  	OR_PACKET,		&bsol;* full packet data */
131  	OR_LINKHDR,		&bsol;* link-layer header */
132  	OR_PREVLINKHDR,		&bsol;* previous link-layer header */
133  	OR_LLC,			&bsol;* 802.2 LLC header */
134  	OR_PREVMPLSHDR,		&bsol;* previous MPLS header */
135  	OR_LINKTYPE,		&bsol;* link-layer type */
136  	OR_LINKPL,		&bsol;* link-layer payload */
137  	OR_LINKPL_NOSNAP,	&bsol;* link-layer payload, with no SNAP header at the link layer */
138  	OR_TRAN_IPV4,		&bsol;* transport-layer header, with IPv4 network layer */
139  	OR_TRAN_IPV6		&bsol;* transport-layer header, with IPv6 network layer */
140  };
141  #define NCHUNKS 16
142  #define CHUNK0SIZE 1024
143  struct chunk {
144  	size_t n_left;
145  	void *m;
146  };
147  struct chunk_align {
148  	char dummy;
149  	union {
150  		char c;
151  		struct block b;
152  		struct slist s;
153  		struct arth a;
154  	} u;
155  };
156  #define CHUNK_ALIGN (offsetof(struct chunk_align, u))
157  struct _compiler_state {
158  	jmp_buf top_ctx;
159  	pcap_t *bpf_pcap;
160  	int error_set;
161  	struct icode ic;
162  	int snaplen;
163  	int linktype;
164  	int prevlinktype;
165  	int outermostlinktype;
166  	bpf_u_int32 netmask;
167  	int no_optimize;
168  	u_int label_stack_depth;
169  	u_int vlan_stack_depth;
170  	u_int pcap_fddipad;
171  	struct addrinfo *ai;
172  	u_char *e;
173  	bpf_abs_offset off_linkhdr;
174  	bpf_abs_offset off_prevlinkhdr;
175  	bpf_abs_offset off_outermostlinkhdr;
176  	bpf_abs_offset off_linkpl;
177  	bpf_abs_offset off_linktype;
178  	int is_atm;
179  	int is_geneve;
180  	int is_vlan_vloffset;
181  	u_int off_vpi;
182  	u_int off_vci;
183  	u_int off_proto;
184  	u_int off_li;
185  	u_int off_li_hsl;
186  	u_int off_sio;
187  	u_int off_opc;
188  	u_int off_dpc;
189  	u_int off_sls;
190  	u_int off_payload;
191  	u_int off_nl;
192  	u_int off_nl_nosnap;
193  	int regused[BPF_MEMWORDS];
194  	int curreg;
195  	struct chunk chunks[NCHUNKS];
196  	int cur_chunk;
197  };
198  void
199  bpf_set_error(compiler_state_t *cstate, const char *fmt, ...)
200  {
201  	va_list ap;
202  	if (!cstate->error_set) {
203  		va_start(ap, fmt);
204  		(void)vsnprintf(cstate->bpf_pcap->errbuf, PCAP_ERRBUF_SIZE,
205  		    fmt, ap);
206  		va_end(ap);
207  		cstate->error_set = 1;
208  	}
209  }
210  static void PCAP_NORETURN bpf_error(compiler_state_t *, const char *, ...)
211      PCAP_PRINTFLIKE(2, 3);
212  static void PCAP_NORETURN
213  bpf_error(compiler_state_t *cstate, const char *fmt, ...)
214  {
215  	va_list ap;
216  	va_start(ap, fmt);
217  	(void)vsnprintf(cstate->bpf_pcap->errbuf, PCAP_ERRBUF_SIZE,
218  	    fmt, ap);
219  	va_end(ap);
220  	longjmp(cstate->top_ctx, 1);
221  #ifdef _AIX
222  	PCAP_UNREACHABLE
223  #endif &bsol;* _AIX */
224  }
225  static int init_linktype(compiler_state_t *, pcap_t *);
226  static void init_regs(compiler_state_t *);
227  static int alloc_reg(compiler_state_t *);
228  static void free_reg(compiler_state_t *, int);
229  static void initchunks(compiler_state_t *cstate);
230  static void *newchunk_nolongjmp(compiler_state_t *cstate, size_t);
231  static void *newchunk(compiler_state_t *cstate, size_t);
232  static void freechunks(compiler_state_t *cstate);
233  static inline struct block *new_block(compiler_state_t *cstate, int);
234  static inline struct slist *new_stmt(compiler_state_t *cstate, int);
235  static struct block *gen_retblk(compiler_state_t *cstate, int);
236  static inline void syntax(compiler_state_t *cstate);
237  static void backpatch(struct block *, struct block *);
238  static void merge(struct block *, struct block *);
239  static struct block *gen_cmp(compiler_state_t *, enum e_offrel, u_int,
240      u_int, bpf_u_int32);
241  static struct block *gen_cmp_gt(compiler_state_t *, enum e_offrel, u_int,
242      u_int, bpf_u_int32);
243  static struct block *gen_cmp_ge(compiler_state_t *, enum e_offrel, u_int,
244      u_int, bpf_u_int32);
245  static struct block *gen_cmp_lt(compiler_state_t *, enum e_offrel, u_int,
246      u_int, bpf_u_int32);
247  static struct block *gen_cmp_le(compiler_state_t *, enum e_offrel, u_int,
248      u_int, bpf_u_int32);
249  static struct block *gen_mcmp(compiler_state_t *, enum e_offrel, u_int,
250      u_int, bpf_u_int32, bpf_u_int32);
251  static struct block *gen_bcmp(compiler_state_t *, enum e_offrel, u_int,
252      u_int, const u_char *);
253  static struct block *gen_ncmp(compiler_state_t *, enum e_offrel, u_int,
254      u_int, bpf_u_int32, int, int, bpf_u_int32);
255  static struct slist *gen_load_absoffsetrel(compiler_state_t *, bpf_abs_offset *,
256      u_int, u_int);
257  static struct slist *gen_load_a(compiler_state_t *, enum e_offrel, u_int,
258      u_int);
259  static struct slist *gen_loadx_iphdrlen(compiler_state_t *);
260  static struct block *gen_uncond(compiler_state_t *, int);
261  static inline struct block *gen_true(compiler_state_t *);
262  static inline struct block *gen_false(compiler_state_t *);
263  static struct block *gen_ether_linktype(compiler_state_t *, bpf_u_int32);
264  static struct block *gen_ipnet_linktype(compiler_state_t *, bpf_u_int32);
265  static struct block *gen_linux_sll_linktype(compiler_state_t *, bpf_u_int32);
266  static struct slist *gen_load_pflog_llprefixlen(compiler_state_t *);
267  static struct slist *gen_load_prism_llprefixlen(compiler_state_t *);
268  static struct slist *gen_load_avs_llprefixlen(compiler_state_t *);
269  static struct slist *gen_load_radiotap_llprefixlen(compiler_state_t *);
270  static struct slist *gen_load_ppi_llprefixlen(compiler_state_t *);
271  static void insert_compute_vloffsets(compiler_state_t *, struct block *);
272  static struct slist *gen_abs_offset_varpart(compiler_state_t *,
273      bpf_abs_offset *);
274  static bpf_u_int32 ethertype_to_ppptype(bpf_u_int32);
275  static struct block *gen_linktype(compiler_state_t *, bpf_u_int32);
276  static struct block *gen_snap(compiler_state_t *, bpf_u_int32, bpf_u_int32);
277  static struct block *gen_llc_linktype(compiler_state_t *, bpf_u_int32);
278  static struct block *gen_hostop(compiler_state_t *, bpf_u_int32, bpf_u_int32,
279      int, bpf_u_int32, u_int, u_int);
280  #ifdef INET6
281  static struct block *gen_hostop6(compiler_state_t *, struct in6_addr *,
282      struct in6_addr *, int, bpf_u_int32, u_int, u_int);
283  #endif
284  static struct block *gen_ahostop(compiler_state_t *, const u_char *, int);
285  static struct block *gen_ehostop(compiler_state_t *, const u_char *, int);
286  static struct block *gen_fhostop(compiler_state_t *, const u_char *, int);
287  static struct block *gen_thostop(compiler_state_t *, const u_char *, int);
288  static struct block *gen_wlanhostop(compiler_state_t *, const u_char *, int);
289  static struct block *gen_ipfchostop(compiler_state_t *, const u_char *, int);
290  static struct block *gen_dnhostop(compiler_state_t *, bpf_u_int32, int);
291  static struct block *gen_mpls_linktype(compiler_state_t *, bpf_u_int32);
292  static struct block *gen_host(compiler_state_t *, bpf_u_int32, bpf_u_int32,
293      int, int, int);
294  #ifdef INET6
295  static struct block *gen_host6(compiler_state_t *, struct in6_addr *,
296      struct in6_addr *, int, int, int);
297  #endif
298  #ifndef INET6
299  static struct block *gen_gateway(compiler_state_t *, const u_char *,
300      struct addrinfo *, int, int);
301  #endif
302  static struct block *gen_ipfrag(compiler_state_t *);
303  static struct block *gen_portatom(compiler_state_t *, int, bpf_u_int32);
304  static struct block *gen_portrangeatom(compiler_state_t *, u_int, bpf_u_int32,
305      bpf_u_int32);
306  static struct block *gen_portatom6(compiler_state_t *, int, bpf_u_int32);
307  static struct block *gen_portrangeatom6(compiler_state_t *, u_int, bpf_u_int32,
308      bpf_u_int32);
309  static struct block *gen_portop(compiler_state_t *, u_int, u_int, int);
310  static struct block *gen_port(compiler_state_t *, u_int, int, int);
311  static struct block *gen_portrangeop(compiler_state_t *, u_int, u_int,
312      bpf_u_int32, int);
313  static struct block *gen_portrange(compiler_state_t *, u_int, u_int, int, int);
314  struct block *gen_portop6(compiler_state_t *, u_int, u_int, int);
315  static struct block *gen_port6(compiler_state_t *, u_int, int, int);
316  static struct block *gen_portrangeop6(compiler_state_t *, u_int, u_int,
317      bpf_u_int32, int);
318  static struct block *gen_portrange6(compiler_state_t *, u_int, u_int, int, int);
319  static int lookup_proto(compiler_state_t *, const char *, int);
320  #if !defined(NO_PROTOCHAIN)
321  static struct block *gen_protochain(compiler_state_t *, bpf_u_int32, int);
322  #endif &bsol;* !defined(NO_PROTOCHAIN) */
323  static struct block *gen_proto(compiler_state_t *, bpf_u_int32, int, int);
324  static struct slist *xfer_to_x(compiler_state_t *, struct arth *);
325  static struct slist *xfer_to_a(compiler_state_t *, struct arth *);
326  static struct block *gen_mac_multicast(compiler_state_t *, int);
327  static struct block *gen_len(compiler_state_t *, int, int);
328  static struct block *gen_check_802_11_data_frame(compiler_state_t *);
329  static struct block *gen_geneve_ll_check(compiler_state_t *cstate);
330  static struct block *gen_ppi_dlt_check(compiler_state_t *);
331  static struct block *gen_atmfield_code_internal(compiler_state_t *, int,
332      bpf_u_int32, int, int);
333  static struct block *gen_atmtype_llc(compiler_state_t *);
334  static struct block *gen_msg_abbrev(compiler_state_t *, int type);
335  static void
336  initchunks(compiler_state_t *cstate)
337  {
338  	int i;
339  	for (i = 0; i < NCHUNKS; i++) {
340  		cstate->chunks[i].n_left = 0;
341  		cstate->chunks[i].m = NULL;
342  	}
343  	cstate->cur_chunk = 0;
344  }
345  static void *
346  newchunk_nolongjmp(compiler_state_t *cstate, size_t n)
347  {
348  	struct chunk *cp;
349  	int k;
350  	size_t size;
351  	n = (n + CHUNK_ALIGN - 1) & ~(CHUNK_ALIGN - 1);
352  	cp = &cstate->chunks[cstate->cur_chunk];
353  	if (n > cp->n_left) {
354  		++cp;
355  		k = ++cstate->cur_chunk;
356  		if (k >= NCHUNKS) {
357  			bpf_set_error(cstate, "out of memory");
358  			return (NULL);
359  		}
360  		size = CHUNK0SIZE << k;
361  		cp->m = (void *)malloc(size);
362  		if (cp->m == NULL) {
363  			bpf_set_error(cstate, "out of memory");
364  			return (NULL);
365  		}
366  		memset((char *)cp->m, 0, size);
367  		cp->n_left = size;
368  		if (n > size) {
369  			bpf_set_error(cstate, "out of memory");
370  			return (NULL);
371  		}
372  	}
373  	cp->n_left -= n;
374  	return (void *)((char *)cp->m + cp->n_left);
375  }
376  static void *
377  newchunk(compiler_state_t *cstate, size_t n)
378  {
379  	void *p;
380  	p = newchunk_nolongjmp(cstate, n);
381  	if (p == NULL) {
382  		longjmp(cstate->top_ctx, 1);
383  	}
384  	return (p);
385  }
386  static void
387  freechunks(compiler_state_t *cstate)
388  {
389  	int i;
390  	for (i = 0; i < NCHUNKS; ++i)
391  		if (cstate->chunks[i].m != NULL)
392  			free(cstate->chunks[i].m);
393  }
394  char *
395  sdup(compiler_state_t *cstate, const char *s)
396  {
397  	size_t n = strlen(s) + 1;
398  	char *cp = newchunk_nolongjmp(cstate, n);
399  	if (cp == NULL)
400  		return (NULL);
401  	pcap_strlcpy(cp, s, n);
402  	return (cp);
403  }
404  static inline struct block *
405  new_block(compiler_state_t *cstate, int code)
406  {
407  	struct block *p;
408  	p = (struct block *)newchunk(cstate, sizeof(*p));
409  	p->s.code = code;
410  	p->head = p;
411  	return p;
412  }
413  static inline struct slist *
414  new_stmt(compiler_state_t *cstate, int code)
415  {
416  	struct slist *p;
417  	p = (struct slist *)newchunk(cstate, sizeof(*p));
418  	p->s.code = code;
419  	return p;
420  }
421  static struct block *
422  gen_retblk(compiler_state_t *cstate, int v)
423  {
424  	struct block *b = new_block(cstate, BPF_RET|BPF_K);
425  	b->s.k = v;
426  	return b;
427  }
428  static inline PCAP_NORETURN_DEF void
429  syntax(compiler_state_t *cstate)
430  {
431  	bpf_error(cstate, "syntax error in filter expression");
432  }
433  int
434  pcap_compile(pcap_t *p, struct bpf_program *program,
435  	     const char *buf, int optimize, bpf_u_int32 mask)
436  {
437  #ifdef _WIN32
438  	static int done = 0;
439  #endif
440  	compiler_state_t cstate;
441  	const char * volatile xbuf = buf;
442  	yyscan_t scanner = NULL;
443  	volatile YY_BUFFER_STATE in_buffer = NULL;
444  	u_int len;
445  	int rc;
446  	if (!p->activated) {
447  		(void)snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
448  		    "not-yet-activated pcap_t passed to pcap_compile");
449  		return (PCAP_ERROR);
450  	}
451  #ifdef _WIN32
452  	if (!done) {
453  		pcap_wsockinit();
454  		done = 1;
455  	}
456  #endif
457  #ifdef ENABLE_REMOTE
458  	if (p->save_current_filter_op != NULL)
459  		(p->save_current_filter_op)(p, buf);
460  #endif
461  	initchunks(&cstate);
462  	cstate.no_optimize = 0;
463  #ifdef INET6
464  	cstate.ai = NULL;
465  #endif
466  	cstate.e = NULL;
467  	cstate.ic.root = NULL;
468  	cstate.ic.cur_mark = 0;
469  	cstate.bpf_pcap = p;
470  	cstate.error_set = 0;
471  	init_regs(&cstate);
472  	cstate.netmask = mask;
473  	cstate.snaplen = pcap_snapshot(p);
474  	if (cstate.snaplen == 0) {
475  		(void)snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
476  			 "snaplen of 0 rejects all packets");
477  		rc = PCAP_ERROR;
478  		goto quit;
479  	}
480  	if (pcap_lex_init(&scanner) != 0) {
481  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
482  		    errno, "can't initialize scanner");
483  		rc = PCAP_ERROR;
484  		goto quit;
485  	}
486  	in_buffer = pcap__scan_string(xbuf ? xbuf : "", scanner);
487  	pcap_set_extra(&cstate, scanner);
488  	if (init_linktype(&cstate, p) == -1) {
489  		rc = PCAP_ERROR;
490  		goto quit;
491  	}
492  	if (pcap_parse(scanner, &cstate) != 0) {
493  #ifdef INET6
494  		if (cstate.ai != NULL)
495  			freeaddrinfo(cstate.ai);
496  #endif
497  		if (cstate.e != NULL)
498  			free(cstate.e);
499  		rc = PCAP_ERROR;
500  		goto quit;
501  	}
502  	if (cstate.ic.root == NULL) {
503  		if (setjmp(cstate.top_ctx)) {
504  			rc = PCAP_ERROR;
505  			goto quit;
506  		}
507  		cstate.ic.root = gen_retblk(&cstate, cstate.snaplen);
508  	}
509  	if (optimize && !cstate.no_optimize) {
510  		if (bpf_optimize(&cstate.ic, p->errbuf) == -1) {
511  			rc = PCAP_ERROR;
512  			goto quit;
513  		}
514  		if (cstate.ic.root == NULL ||
515  		    (cstate.ic.root->s.code == (BPF_RET|BPF_K) && cstate.ic.root->s.k == 0)) {
516  			(void)snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
517  			    "expression rejects all packets");
518  			rc = PCAP_ERROR;
519  			goto quit;
520  		}
521  	}
522  	program->bf_insns = icode_to_fcode(&cstate.ic,
523  	    cstate.ic.root, &len, p->errbuf);
524  	if (program->bf_insns == NULL) {
525  		rc = PCAP_ERROR;
526  		goto quit;
527  	}
528  	program->bf_len = len;
529  	rc = 0;  &bsol;* We're all okay */
530  quit:
531  	if (in_buffer != NULL)
532  		pcap__delete_buffer(in_buffer, scanner);
533  	if (scanner != NULL)
534  		pcap_lex_destroy(scanner);
535  	freechunks(&cstate);
536  	return (rc);
537  }
538  int
539  pcap_compile_nopcap(int snaplen_arg, int linktype_arg,
540  		    struct bpf_program *program,
541  	     const char *buf, int optimize, bpf_u_int32 mask)
542  {
543  	pcap_t *p;
544  	int ret;
545  	p = pcap_open_dead(linktype_arg, snaplen_arg);
546  	if (p == NULL)
547  		return (PCAP_ERROR);
548  	ret = pcap_compile(p, program, buf, optimize, mask);
549  	pcap_close(p);
550  	return (ret);
551  }
552  void
553  pcap_freecode(struct bpf_program *program)
554  {
555  	program->bf_len = 0;
556  	if (program->bf_insns != NULL) {
557  		free((char *)program->bf_insns);
558  		program->bf_insns = NULL;
559  	}
560  }
561  static void
562  backpatch(struct block *list, struct block *target)
563  {
564  	struct block *next;
565  	while (list) {
566  		if (!list->sense) {
567  			next = JT(list);
568  			JT(list) = target;
569  		} else {
570  			next = JF(list);
571  			JF(list) = target;
572  		}
573  		list = next;
574  	}
575  }
576  static void
577  merge(struct block *b0, struct block *b1)
578  {
579  	register struct block **p = &b0;
580  	while (*p)
581  		p = !((*p)->sense) ? &JT(*p) : &JF(*p);
582  	*p = b1;
583  }
584  int
585  finish_parse(compiler_state_t *cstate, struct block *p)
586  {
587  	struct block *ppi_dlt_check;
588  	if (setjmp(cstate->top_ctx))
589  		return (-1);
590  	insert_compute_vloffsets(cstate, p->head);
591  	ppi_dlt_check = gen_ppi_dlt_check(cstate);
592  	if (ppi_dlt_check != NULL)
593  		gen_and(ppi_dlt_check, p);
594  	backpatch(p, gen_retblk(cstate, cstate->snaplen));
595  	p->sense = !p->sense;
596  	backpatch(p, gen_retblk(cstate, 0));
597  	cstate->ic.root = p->head;
598  	return (0);
599  }
600  void
601  gen_and(struct block *b0, struct block *b1)
602  {
603  	backpatch(b0, b1->head);
604  	b0->sense = !b0->sense;
605  	b1->sense = !b1->sense;
606  	merge(b1, b0);
607  	b1->sense = !b1->sense;
608  	b1->head = b0->head;
609  }
610  void
611  gen_or(struct block *b0, struct block *b1)
612  {
613  	b0->sense = !b0->sense;
614  	backpatch(b0, b1->head);
615  	b0->sense = !b0->sense;
616  	merge(b1, b0);
617  	b1->head = b0->head;
618  }
619  void
620  gen_not(struct block *b)
621  {
622  	b->sense = !b->sense;
623  }
624  static struct block *
625  gen_cmp(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,
626      u_int size, bpf_u_int32 v)
627  {
628  	return gen_ncmp(cstate, offrel, offset, size, 0xffffffff, BPF_JEQ, 0, v);
629  }
630  static struct block *
631  gen_cmp_gt(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,
632      u_int size, bpf_u_int32 v)
633  {
634  	return gen_ncmp(cstate, offrel, offset, size, 0xffffffff, BPF_JGT, 0, v);
635  }
636  static struct block *
637  gen_cmp_ge(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,
638      u_int size, bpf_u_int32 v)
639  {
640  	return gen_ncmp(cstate, offrel, offset, size, 0xffffffff, BPF_JGE, 0, v);
641  }
642  static struct block *
643  gen_cmp_lt(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,
644      u_int size, bpf_u_int32 v)
645  {
646  	return gen_ncmp(cstate, offrel, offset, size, 0xffffffff, BPF_JGE, 1, v);
647  }
648  static struct block *
649  gen_cmp_le(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,
650      u_int size, bpf_u_int32 v)
651  {
652  	return gen_ncmp(cstate, offrel, offset, size, 0xffffffff, BPF_JGT, 1, v);
653  }
654  static struct block *
655  gen_mcmp(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,
656      u_int size, bpf_u_int32 v, bpf_u_int32 mask)
657  {
658  	return gen_ncmp(cstate, offrel, offset, size, mask, BPF_JEQ, 0, v);
659  }
660  static struct block *
661  gen_bcmp(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,
662      u_int size, const u_char *v)
663  {
664  	register struct block *b, *tmp;
665  	b = NULL;
666  	while (size >= 4) {
667  		register const u_char *p = &v[size - 4];
668  		tmp = gen_cmp(cstate, offrel, offset + size - 4, BPF_W,
669  		    EXTRACT_BE_U_4(p));
670  		if (b != NULL)
671  			gen_and(b, tmp);
672  		b = tmp;
673  		size -= 4;
674  	}
675  	while (size >= 2) {
676  		register const u_char *p = &v[size - 2];
677  		tmp = gen_cmp(cstate, offrel, offset + size - 2, BPF_H,
678  		    EXTRACT_BE_U_2(p));
679  		if (b != NULL)
680  			gen_and(b, tmp);
681  		b = tmp;
682  		size -= 2;
683  	}
684  	if (size > 0) {
685  		tmp = gen_cmp(cstate, offrel, offset, BPF_B, v[0]);
686  		if (b != NULL)
687  			gen_and(b, tmp);
688  		b = tmp;
689  	}
690  	return b;
691  }
692  static struct block *
693  gen_ncmp(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,
694      u_int size, bpf_u_int32 mask, int jtype, int reverse,
695      bpf_u_int32 v)
696  {
697  	struct slist *s, *s2;
698  	struct block *b;
699  	s = gen_load_a(cstate, offrel, offset, size);
700  	if (mask != 0xffffffff) {
701  		s2 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);
702  		s2->s.k = mask;
703  		sappend(s, s2);
704  	}
705  	b = new_block(cstate, JMP(jtype));
706  	b->stmts = s;
707  	b->s.k = v;
708  	if (reverse && (jtype == BPF_JGT || jtype == BPF_JGE))
709  		gen_not(b);
710  	return b;
711  }
712  static int
713  init_linktype(compiler_state_t *cstate, pcap_t *p)
714  {
715  	cstate->pcap_fddipad = p->fddipad;
716  	cstate->outermostlinktype = pcap_datalink(p);
717  	cstate->off_outermostlinkhdr.constant_part = 0;
718  	cstate->off_outermostlinkhdr.is_variable = 0;
719  	cstate->off_outermostlinkhdr.reg = -1;
720  	cstate->prevlinktype = cstate->outermostlinktype;
721  	cstate->off_prevlinkhdr.constant_part = 0;
722  	cstate->off_prevlinkhdr.is_variable = 0;
723  	cstate->off_prevlinkhdr.reg = -1;
724  	cstate->linktype = cstate->outermostlinktype;
725  	cstate->off_linkhdr.constant_part = 0;
726  	cstate->off_linkhdr.is_variable = 0;
727  	cstate->off_linkhdr.reg = -1;
728  	cstate->off_linkpl.constant_part = 0;
729  	cstate->off_linkpl.is_variable = 0;
730  	cstate->off_linkpl.reg = -1;
731  	cstate->off_linktype.constant_part = 0;
732  	cstate->off_linktype.is_variable = 0;
733  	cstate->off_linktype.reg = -1;
734  	cstate->is_atm = 0;
735  	cstate->off_vpi = OFFSET_NOT_SET;
736  	cstate->off_vci = OFFSET_NOT_SET;
737  	cstate->off_proto = OFFSET_NOT_SET;
738  	cstate->off_payload = OFFSET_NOT_SET;
739  	cstate->is_geneve = 0;
740  	cstate->is_vlan_vloffset = 0;
741  	cstate->off_li = OFFSET_NOT_SET;
742  	cstate->off_li_hsl = OFFSET_NOT_SET;
743  	cstate->off_sio = OFFSET_NOT_SET;
744  	cstate->off_opc = OFFSET_NOT_SET;
745  	cstate->off_dpc = OFFSET_NOT_SET;
746  	cstate->off_sls = OFFSET_NOT_SET;
747  	cstate->label_stack_depth = 0;
748  	cstate->vlan_stack_depth = 0;
749  	switch (cstate->linktype) {
750  	case DLT_ARCNET:
751  		cstate->off_linktype.constant_part = 2;
752  		cstate->off_linkpl.constant_part = 6;
753  		cstate->off_nl = 0;		&bsol;* XXX in reality, variable! */
754  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
755  		break;
756  	case DLT_ARCNET_LINUX:
757  		cstate->off_linktype.constant_part = 4;
758  		cstate->off_linkpl.constant_part = 8;
759  		cstate->off_nl = 0;		&bsol;* XXX in reality, variable! */
760  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
761  		break;
762  	case DLT_EN10MB:
763  		cstate->off_linktype.constant_part = 12;
764  		cstate->off_linkpl.constant_part = 14;	&bsol;* Ethernet header length */
765  		cstate->off_nl = 0;		&bsol;* Ethernet II */
766  		cstate->off_nl_nosnap = 3;	&bsol;* 802.3+802.2 */
767  		break;
768  	case DLT_SLIP:
769  		cstate->off_linktype.constant_part = OFFSET_NOT_SET;
770  		cstate->off_linkpl.constant_part = 16;
771  		cstate->off_nl = 0;
772  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
773  		break;
774  	case DLT_SLIP_BSDOS:
775  		cstate->off_linktype.constant_part = OFFSET_NOT_SET;
776  		cstate->off_linkpl.constant_part = 24;
777  		cstate->off_nl = 0;
778  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
779  		break;
780  	case DLT_NULL:
781  	case DLT_LOOP:
782  		cstate->off_linktype.constant_part = 0;
783  		cstate->off_linkpl.constant_part = 4;
784  		cstate->off_nl = 0;
785  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
786  		break;
787  	case DLT_ENC:
788  		cstate->off_linktype.constant_part = 0;
789  		cstate->off_linkpl.constant_part = 12;
790  		cstate->off_nl = 0;
791  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
792  		break;
793  	case DLT_PPP:
794  	case DLT_PPP_PPPD:
795  	case DLT_C_HDLC:		&bsol;* BSD/OS Cisco HDLC */
796  	case DLT_HDLC:			&bsol;* NetBSD (Cisco) HDLC */
797  	case DLT_PPP_SERIAL:		&bsol;* NetBSD sync/async serial PPP */
798  		cstate->off_linktype.constant_part = 2;	&bsol;* skip HDLC-like framing */
799  		cstate->off_linkpl.constant_part = 4;	&bsol;* skip HDLC-like framing and protocol field */
800  		cstate->off_nl = 0;
801  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
802  		break;
803  	case DLT_PPP_ETHER:
804  		cstate->off_linktype.constant_part = 6;
805  		cstate->off_linkpl.constant_part = 8;
806  		cstate->off_nl = 0;
807  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
808  		break;
809  	case DLT_PPP_BSDOS:
810  		cstate->off_linktype.constant_part = 5;
811  		cstate->off_linkpl.constant_part = 24;
812  		cstate->off_nl = 0;
813  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
814  		break;
815  	case DLT_FDDI:
816  		cstate->off_linktype.constant_part = 13;
817  		cstate->off_linktype.constant_part += cstate->pcap_fddipad;
818  		cstate->off_linkpl.constant_part = 13;	&bsol;* FDDI MAC header length */
819  		cstate->off_linkpl.constant_part += cstate->pcap_fddipad;
820  		cstate->off_nl = 8;		&bsol;* 802.2+SNAP */
821  		cstate->off_nl_nosnap = 3;	&bsol;* 802.2 */
822  		break;
823  	case DLT_IEEE802:
824  		cstate->off_linktype.constant_part = 14;
825  		cstate->off_linkpl.constant_part = 14;	&bsol;* Token Ring MAC header length */
826  		cstate->off_nl = 8;		&bsol;* 802.2+SNAP */
827  		cstate->off_nl_nosnap = 3;	&bsol;* 802.2 */
828  		break;
829  	case DLT_PRISM_HEADER:
830  	case DLT_IEEE802_11_RADIO_AVS:
831  	case DLT_IEEE802_11_RADIO:
832  		cstate->off_linkhdr.is_variable = 1;
833  	case DLT_IEEE802_11:
834  		cstate->off_linktype.constant_part = 24;
835  		cstate->off_linkpl.constant_part = 0;	&bsol;* link-layer header is variable-length */
836  		cstate->off_linkpl.is_variable = 1;
837  		cstate->off_nl = 8;		&bsol;* 802.2+SNAP */
838  		cstate->off_nl_nosnap = 3;	&bsol;* 802.2 */
839  		break;
840  	case DLT_PPI:
841  		cstate->off_linktype.constant_part = 24;
842  		cstate->off_linkpl.constant_part = 0;	&bsol;* link-layer header is variable-length */
843  		cstate->off_linkpl.is_variable = 1;
844  		cstate->off_linkhdr.is_variable = 1;
845  		cstate->off_nl = 8;		&bsol;* 802.2+SNAP */
846  		cstate->off_nl_nosnap = 3;	&bsol;* 802.2 */
847  		break;
848  	case DLT_ATM_RFC1483:
849  	case DLT_ATM_CLIP:	&bsol;* Linux ATM defines this */
850  		cstate->off_linktype.constant_part = 0;
851  		cstate->off_linkpl.constant_part = 0;	&bsol;* packet begins with LLC header */
852  		cstate->off_nl = 8;		&bsol;* 802.2+SNAP */
853  		cstate->off_nl_nosnap = 3;	&bsol;* 802.2 */
854  		break;
855  	case DLT_SUNATM:
856  		cstate->is_atm = 1;
857  		cstate->off_vpi = SUNATM_VPI_POS;
858  		cstate->off_vci = SUNATM_VCI_POS;
859  		cstate->off_proto = PROTO_POS;
860  		cstate->off_payload = SUNATM_PKT_BEGIN_POS;
861  		cstate->off_linktype.constant_part = cstate->off_payload;
862  		cstate->off_linkpl.constant_part = cstate->off_payload;	&bsol;* if LLC-encapsulated */
863  		cstate->off_nl = 8;		&bsol;* 802.2+SNAP */
864  		cstate->off_nl_nosnap = 3;	&bsol;* 802.2 */
865  		break;
866  	case DLT_RAW:
867  	case DLT_IPV4:
868  	case DLT_IPV6:
869  		cstate->off_linktype.constant_part = OFFSET_NOT_SET;
870  		cstate->off_linkpl.constant_part = 0;
871  		cstate->off_nl = 0;
872  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
873  		break;
874  	case DLT_LINUX_SLL:	&bsol;* fake header for Linux cooked socket v1 */
875  		cstate->off_linktype.constant_part = 14;
876  		cstate->off_linkpl.constant_part = 16;
877  		cstate->off_nl = 0;
878  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
879  		break;
880  	case DLT_LINUX_SLL2:	&bsol;* fake header for Linux cooked socket v2 */
881  		cstate->off_linktype.constant_part = 0;
882  		cstate->off_linkpl.constant_part = 20;
883  		cstate->off_nl = 0;
884  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
885  		break;
886  	case DLT_LTALK:
887  		cstate->off_linktype.constant_part = OFFSET_NOT_SET;
888  		cstate->off_linkpl.constant_part = 0;
889  		cstate->off_nl = 0;
890  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
891  		break;
892  	case DLT_IP_OVER_FC:
893  		cstate->off_linktype.constant_part = 16;
894  		cstate->off_linkpl.constant_part = 16;
895  		cstate->off_nl = 8;		&bsol;* 802.2+SNAP */
896  		cstate->off_nl_nosnap = 3;	&bsol;* 802.2 */
897  		break;
898  	case DLT_FRELAY:
899  		cstate->off_linktype.constant_part = OFFSET_NOT_SET;
900  		cstate->off_linkpl.constant_part = 0;
901  		cstate->off_nl = 0;
902  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
903  		break;
904  	case DLT_MFR:
905  		cstate->off_linktype.constant_part = OFFSET_NOT_SET;
906  		cstate->off_linkpl.constant_part = 0;
907  		cstate->off_nl = 4;
908  		cstate->off_nl_nosnap = 0;	&bsol;* XXX - for now -> no 802.2 LLC */
909  		break;
910  	case DLT_APPLE_IP_OVER_IEEE1394:
911  		cstate->off_linktype.constant_part = 16;
912  		cstate->off_linkpl.constant_part = 18;
913  		cstate->off_nl = 0;
914  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
915  		break;
916  	case DLT_SYMANTEC_FIREWALL:
917  		cstate->off_linktype.constant_part = 6;
918  		cstate->off_linkpl.constant_part = 44;
919  		cstate->off_nl = 0;		&bsol;* Ethernet II */
920  		cstate->off_nl_nosnap = 0;	&bsol;* XXX - what does it do with 802.3 packets? */
921  		break;
922  	case DLT_PFLOG:
923  		cstate->off_linktype.constant_part = 0;
924  		cstate->off_linkpl.constant_part = 0;	&bsol;* link-layer header is variable-length */
925  		cstate->off_linkpl.is_variable = 1;
926  		cstate->off_nl = 0;
927  		cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
928  		break;
929          case DLT_JUNIPER_MFR:
930          case DLT_JUNIPER_MLFR:
931          case DLT_JUNIPER_MLPPP:
932          case DLT_JUNIPER_PPP:
933          case DLT_JUNIPER_CHDLC:
934          case DLT_JUNIPER_FRELAY:
935  		cstate->off_linktype.constant_part = 4;
936  		cstate->off_linkpl.constant_part = 4;
937  		cstate->off_nl = 0;
938  		cstate->off_nl_nosnap = OFFSET_NOT_SET;	&bsol;* no 802.2 LLC */
939                  break;
940  	case DLT_JUNIPER_ATM1:
941  		cstate->off_linktype.constant_part = 4;		&bsol;* in reality variable between 4-8 */
942  		cstate->off_linkpl.constant_part = 4;	&bsol;* in reality variable between 4-8 */
943  		cstate->off_nl = 0;
944  		cstate->off_nl_nosnap = 10;
945  		break;
946  	case DLT_JUNIPER_ATM2:
947  		cstate->off_linktype.constant_part = 8;		&bsol;* in reality variable between 8-12 */
948  		cstate->off_linkpl.constant_part = 8;	&bsol;* in reality variable between 8-12 */
949  		cstate->off_nl = 0;
950  		cstate->off_nl_nosnap = 10;
951  		break;
952  	case DLT_JUNIPER_PPPOE:
953          case DLT_JUNIPER_ETHER:
954  		cstate->off_linkpl.constant_part = 14;
955  		cstate->off_linktype.constant_part = 16;
956  		cstate->off_nl = 18;		&bsol;* Ethernet II */
957  		cstate->off_nl_nosnap = 21;	&bsol;* 802.3+802.2 */
958  		break;
959  	case DLT_JUNIPER_PPPOE_ATM:
960  		cstate->off_linktype.constant_part = 4;
961  		cstate->off_linkpl.constant_part = 6;
962  		cstate->off_nl = 0;
963  		cstate->off_nl_nosnap = OFFSET_NOT_SET;	&bsol;* no 802.2 LLC */
964  		break;
965  	case DLT_JUNIPER_GGSN:
966  		cstate->off_linktype.constant_part = 6;
967  		cstate->off_linkpl.constant_part = 12;
968  		cstate->off_nl = 0;
969  		cstate->off_nl_nosnap = OFFSET_NOT_SET;	&bsol;* no 802.2 LLC */
970  		break;
971  	case DLT_JUNIPER_ES:
972  		cstate->off_linktype.constant_part = 6;
973  		cstate->off_linkpl.constant_part = OFFSET_NOT_SET;	&bsol;* not really a network layer but raw IP addresses */
974  		cstate->off_nl = OFFSET_NOT_SET;	&bsol;* not really a network layer but raw IP addresses */
975  		cstate->off_nl_nosnap = OFFSET_NOT_SET;	&bsol;* no 802.2 LLC */
976  		break;
977  	case DLT_JUNIPER_MONITOR:
978  		cstate->off_linktype.constant_part = 12;
979  		cstate->off_linkpl.constant_part = 12;
980  		cstate->off_nl = 0;			&bsol;* raw IP/IP6 header */
981  		cstate->off_nl_nosnap = OFFSET_NOT_SET;	&bsol;* no 802.2 LLC */
982  		break;
983  	case DLT_BACNET_MS_TP:
984  		cstate->off_linktype.constant_part = OFFSET_NOT_SET;
985  		cstate->off_linkpl.constant_part = OFFSET_NOT_SET;
986  		cstate->off_nl = OFFSET_NOT_SET;
987  		cstate->off_nl_nosnap = OFFSET_NOT_SET;
988  		break;
989  	case DLT_JUNIPER_SERVICES:
990  		cstate->off_linktype.constant_part = 12;
991  		cstate->off_linkpl.constant_part = OFFSET_NOT_SET;	&bsol;* L3 proto location dep. on cookie type */
992  		cstate->off_nl = OFFSET_NOT_SET;	&bsol;* L3 proto location dep. on cookie type */
993  		cstate->off_nl_nosnap = OFFSET_NOT_SET;	&bsol;* no 802.2 LLC */
994  		break;
995  	case DLT_JUNIPER_VP:
996  		cstate->off_linktype.constant_part = 18;
997  		cstate->off_linkpl.constant_part = OFFSET_NOT_SET;
998  		cstate->off_nl = OFFSET_NOT_SET;
999  		cstate->off_nl_nosnap = OFFSET_NOT_SET;
1000  		break;
1001  	case DLT_JUNIPER_ST:
1002  		cstate->off_linktype.constant_part = 18;
1003  		cstate->off_linkpl.constant_part = OFFSET_NOT_SET;
1004  		cstate->off_nl = OFFSET_NOT_SET;
1005  		cstate->off_nl_nosnap = OFFSET_NOT_SET;
1006  		break;
1007  	case DLT_JUNIPER_ISM:
1008  		cstate->off_linktype.constant_part = 8;
1009  		cstate->off_linkpl.constant_part = OFFSET_NOT_SET;
1010  		cstate->off_nl = OFFSET_NOT_SET;
1011  		cstate->off_nl_nosnap = OFFSET_NOT_SET;
1012  		break;
1013  	case DLT_JUNIPER_VS:
1014  	case DLT_JUNIPER_SRX_E2E:
1015  	case DLT_JUNIPER_FIBRECHANNEL:
1016  	case DLT_JUNIPER_ATM_CEMIC:
1017  		cstate->off_linktype.constant_part = 8;
1018  		cstate->off_linkpl.constant_part = OFFSET_NOT_SET;
1019  		cstate->off_nl = OFFSET_NOT_SET;
1020  		cstate->off_nl_nosnap = OFFSET_NOT_SET;
1021  		break;
1022  	case DLT_MTP2:
1023  		cstate->off_li = 2;
1024  		cstate->off_li_hsl = 4;
1025  		cstate->off_sio = 3;
1026  		cstate->off_opc = 4;
1027  		cstate->off_dpc = 4;
1028  		cstate->off_sls = 7;
1029  		cstate->off_linktype.constant_part = OFFSET_NOT_SET;
1030  		cstate->off_linkpl.constant_part = OFFSET_NOT_SET;
1031  		cstate->off_nl = OFFSET_NOT_SET;
1032  		cstate->off_nl_nosnap = OFFSET_NOT_SET;
1033  		break;
1034  	case DLT_MTP2_WITH_PHDR:
1035  		cstate->off_li = 6;
1036  		cstate->off_li_hsl = 8;
1037  		cstate->off_sio = 7;
1038  		cstate->off_opc = 8;
1039  		cstate->off_dpc = 8;
1040  		cstate->off_sls = 11;
1041  		cstate->off_linktype.constant_part = OFFSET_NOT_SET;
1042  		cstate->off_linkpl.constant_part = OFFSET_NOT_SET;
1043  		cstate->off_nl = OFFSET_NOT_SET;
1044  		cstate->off_nl_nosnap = OFFSET_NOT_SET;
1045  		break;
1046  	case DLT_ERF:
1047  		cstate->off_li = 22;
1048  		cstate->off_li_hsl = 24;
1049  		cstate->off_sio = 23;
1050  		cstate->off_opc = 24;
1051  		cstate->off_dpc = 24;
1052  		cstate->off_sls = 27;
1053  		cstate->off_linktype.constant_part = OFFSET_NOT_SET;
1054  		cstate->off_linkpl.constant_part = OFFSET_NOT_SET;
1055  		cstate->off_nl = OFFSET_NOT_SET;
1056  		cstate->off_nl_nosnap = OFFSET_NOT_SET;
1057  		break;
1058  	case DLT_PFSYNC:
1059  		cstate->off_linktype.constant_part = OFFSET_NOT_SET;
1060  		cstate->off_linkpl.constant_part = 4;
1061  		cstate->off_nl = 0;
1062  		cstate->off_nl_nosnap = 0;
1063  		break;
1064  	case DLT_AX25_KISS:
1065  		cstate->off_linktype.constant_part = OFFSET_NOT_SET;	&bsol;* variable, min 15, max 71 steps of 7 */
1066  		cstate->off_linkpl.constant_part = OFFSET_NOT_SET;
1067  		cstate->off_nl = OFFSET_NOT_SET;	&bsol;* variable, min 16, max 71 steps of 7 */
1068  		cstate->off_nl_nosnap = OFFSET_NOT_SET;	&bsol;* no 802.2 LLC */
1069  		break;
1070  	case DLT_IPNET:
1071  		cstate->off_linktype.constant_part = 1;
1072  		cstate->off_linkpl.constant_part = 24;	&bsol;* ipnet header length */
1073  		cstate->off_nl = 0;
1074  		cstate->off_nl_nosnap = OFFSET_NOT_SET;
1075  		break;
1076  	case DLT_NETANALYZER:
1077  		cstate->off_linkhdr.constant_part = 4;	&bsol;* Ethernet header is past 4-byte pseudo-header */
1078  		cstate->off_linktype.constant_part = cstate->off_linkhdr.constant_part + 12;
1079  		cstate->off_linkpl.constant_part = cstate->off_linkhdr.constant_part + 14;	&bsol;* pseudo-header+Ethernet header length */
1080  		cstate->off_nl = 0;		&bsol;* Ethernet II */
1081  		cstate->off_nl_nosnap = 3;	&bsol;* 802.3+802.2 */
1082  		break;
1083  	case DLT_NETANALYZER_TRANSPARENT:
1084  		cstate->off_linkhdr.constant_part = 12;	&bsol;* MAC header is past 4-byte pseudo-header, preamble, and SFD */
1085  		cstate->off_linktype.constant_part = cstate->off_linkhdr.constant_part + 12;
1086  		cstate->off_linkpl.constant_part = cstate->off_linkhdr.constant_part + 14;	&bsol;* pseudo-header+preamble+SFD+Ethernet header length */
1087  		cstate->off_nl = 0;		&bsol;* Ethernet II */
1088  		cstate->off_nl_nosnap = 3;	&bsol;* 802.3+802.2 */
1089  		break;
1090  	default:
1091  		if (cstate->linktype >= DLT_MATCHING_MIN &&
1092  		    cstate->linktype <= DLT_MATCHING_MAX) {
1093  			cstate->off_linktype.constant_part = OFFSET_NOT_SET;
1094  			cstate->off_linkpl.constant_part = OFFSET_NOT_SET;
1095  			cstate->off_nl = OFFSET_NOT_SET;
1096  			cstate->off_nl_nosnap = OFFSET_NOT_SET;
1097  		} else {
1098  			bpf_set_error(cstate, "unknown data link type %d (min %d, max %d)",
1099  			    cstate->linktype, DLT_MATCHING_MIN, DLT_MATCHING_MAX);
1100  			return (-1);
1101  		}
1102  		break;
1103  	}
1104  	cstate->off_outermostlinkhdr = cstate->off_prevlinkhdr = cstate->off_linkhdr;
1105  	return (0);
1106  }
1107  static struct slist *
1108  gen_load_absoffsetrel(compiler_state_t *cstate, bpf_abs_offset *abs_offset,
1109      u_int offset, u_int size)
1110  {
1111  	struct slist *s, *s2;
1112  	s = gen_abs_offset_varpart(cstate, abs_offset);
1113  	if (s != NULL) {
1114  		s2 = new_stmt(cstate, BPF_LD|BPF_IND|size);
1115  		s2->s.k = abs_offset->constant_part + offset;
1116  		sappend(s, s2);
1117  	} else {
1118  		s = new_stmt(cstate, BPF_LD|BPF_ABS|size);
1119  		s->s.k = abs_offset->constant_part + offset;
1120  	}
1121  	return s;
1122  }
1123  static struct slist *
1124  gen_load_a(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,
1125      u_int size)
1126  {
1127  	struct slist *s, *s2;
1128  	s = NULL;
1129  	switch (offrel) {
1130  	case OR_PACKET:
1131                  s = new_stmt(cstate, BPF_LD|BPF_ABS|size);
1132                  s->s.k = offset;
1133  		break;
1134  	case OR_LINKHDR:
1135  		s = gen_load_absoffsetrel(cstate, &cstate->off_linkhdr, offset, size);
1136  		break;
1137  	case OR_PREVLINKHDR:
1138  		s = gen_load_absoffsetrel(cstate, &cstate->off_prevlinkhdr, offset, size);
1139  		break;
1140  	case OR_LLC:
1141  		s = gen_load_absoffsetrel(cstate, &cstate->off_linkpl, offset, size);
1142  		break;
1143  	case OR_PREVMPLSHDR:
1144  		s = gen_load_absoffsetrel(cstate, &cstate->off_linkpl, cstate->off_nl - 4 + offset, size);
1145  		break;
1146  	case OR_LINKPL:
1147  		s = gen_load_absoffsetrel(cstate, &cstate->off_linkpl, cstate->off_nl + offset, size);
1148  		break;
1149  	case OR_LINKPL_NOSNAP:
1150  		s = gen_load_absoffsetrel(cstate, &cstate->off_linkpl, cstate->off_nl_nosnap + offset, size);
1151  		break;
1152  	case OR_LINKTYPE:
1153  		s = gen_load_absoffsetrel(cstate, &cstate->off_linktype, offset, size);
1154  		break;
1155  	case OR_TRAN_IPV4:
1156  		s = gen_loadx_iphdrlen(cstate);
1157  		s2 = new_stmt(cstate, BPF_LD|BPF_IND|size);
1158  		s2->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + offset;
1159  		sappend(s, s2);
1160  		break;
1161  	case OR_TRAN_IPV6:
1162  		s = gen_load_absoffsetrel(cstate, &cstate->off_linkpl, cstate->off_nl + 40 + offset, size);
1163  		break;
1164  	}
1165  	return s;
1166  }
1167  static struct slist *
1168  gen_loadx_iphdrlen(compiler_state_t *cstate)
1169  {
1170  	struct slist *s, *s2;
1171  	s = gen_abs_offset_varpart(cstate, &cstate->off_linkpl);
1172  	if (s != NULL) {
1173  		s2 = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);
1174  		s2->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;
1175  		sappend(s, s2);
1176  		s2 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);
1177  		s2->s.k = 0xf;
1178  		sappend(s, s2);
1179  		s2 = new_stmt(cstate, BPF_ALU|BPF_LSH|BPF_K);
1180  		s2->s.k = 2;
1181  		sappend(s, s2);
1182  		sappend(s, new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X));
1183  		sappend(s, new_stmt(cstate, BPF_MISC|BPF_TAX));
1184  	} else {
1185  		s = new_stmt(cstate, BPF_LDX|BPF_MSH|BPF_B);
1186  		s->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;
1187  	}
1188  	return s;
1189  }
1190  static struct block *
1191  gen_uncond(compiler_state_t *cstate, int rsense)
1192  {
1193  	struct block *b;
1194  	struct slist *s;
1195  	s = new_stmt(cstate, BPF_LD|BPF_IMM);
1196  	s->s.k = !rsense;
1197  	b = new_block(cstate, JMP(BPF_JEQ));
1198  	b->stmts = s;
1199  	return b;
1200  }
1201  static inline struct block *
1202  gen_true(compiler_state_t *cstate)
1203  {
1204  	return gen_uncond(cstate, 1);
1205  }
1206  static inline struct block *
1207  gen_false(compiler_state_t *cstate)
1208  {
1209  	return gen_uncond(cstate, 0);
1210  }
1211  #define	SWAPLONG(y) \
1212  ((((y)&0xff)<<24) | (((y)&0xff00)<<8) | (((y)&0xff0000)>>8) | (((y)>>24)&0xff))
1213  static struct block *
1214  gen_ether_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)
1215  {
1216  	struct block *b0, *b1;
1217  	switch (ll_proto) {
1218  	case LLCSAP_ISONS:
1219  	case LLCSAP_IP:
1220  	case LLCSAP_NETBEUI:
1221  		b0 = gen_cmp_gt(cstate, OR_LINKTYPE, 0, BPF_H, ETHERMTU);
1222  		gen_not(b0);
1223  		b1 = gen_cmp(cstate, OR_LLC, 0, BPF_H, (ll_proto << 8) | ll_proto);
1224  		gen_and(b0, b1);
1225  		return b1;
1226  	case LLCSAP_IPX:
1227  		b0 = gen_cmp(cstate, OR_LLC, 0, BPF_B, LLCSAP_IPX);
1228  		b1 = gen_cmp(cstate, OR_LLC, 0, BPF_H, 0xFFFF);
1229  		gen_or(b0, b1);
1230  		b0 = gen_snap(cstate, 0x000000, ETHERTYPE_IPX);
1231  		gen_or(b0, b1);
1232  		b0 = gen_cmp_gt(cstate, OR_LINKTYPE, 0, BPF_H, ETHERMTU);
1233  		gen_not(b0);
1234  		gen_and(b0, b1);
1235  		b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ETHERTYPE_IPX);
1236  		gen_or(b0, b1);
1237  		return b1;
1238  	case ETHERTYPE_ATALK:
1239  	case ETHERTYPE_AARP:
1240  		b0 = gen_cmp_gt(cstate, OR_LINKTYPE, 0, BPF_H, ETHERMTU);
1241  		gen_not(b0);
1242  		if (ll_proto == ETHERTYPE_ATALK)
1243  			b1 = gen_snap(cstate, 0x080007, ETHERTYPE_ATALK);
1244  		else	&bsol;* ll_proto == ETHERTYPE_AARP */
1245  			b1 = gen_snap(cstate, 0x000000, ETHERTYPE_AARP);
1246  		gen_and(b0, b1);
1247  		b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ll_proto);
1248  		gen_or(b0, b1);
1249  		return b1;
1250  	default:
1251  		if (ll_proto <= ETHERMTU) {
1252  			b0 = gen_cmp_gt(cstate, OR_LINKTYPE, 0, BPF_H, ETHERMTU);
1253  			gen_not(b0);
1254  			b1 = gen_cmp(cstate, OR_LINKTYPE, 2, BPF_B, ll_proto);
1255  			gen_and(b0, b1);
1256  			return b1;
1257  		} else {
1258  			return gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ll_proto);
1259  		}
1260  	}
1261  }
1262  static struct block *
1263  gen_loopback_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)
1264  {
1265  	if (cstate->linktype == DLT_NULL || cstate->linktype == DLT_ENC) {
1266  		if (cstate->bpf_pcap->rfile != NULL && cstate->bpf_pcap->swapped)
1267  			ll_proto = SWAPLONG(ll_proto);
1268  		ll_proto = htonl(ll_proto);
1269  	}
1270  	return (gen_cmp(cstate, OR_LINKHDR, 0, BPF_W, ll_proto));
1271  }
1272  static struct block *
1273  gen_ipnet_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)
1274  {
1275  	switch (ll_proto) {
1276  	case ETHERTYPE_IP:
1277  		return gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B, IPH_AF_INET);
1278  	case ETHERTYPE_IPV6:
1279  		return gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B, IPH_AF_INET6);
1280  	default:
1281  		break;
1282  	}
1283  	return gen_false(cstate);
1284  }
1285  static struct block *
1286  gen_linux_sll_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)
1287  {
1288  	struct block *b0, *b1;
1289  	switch (ll_proto) {
1290  	case LLCSAP_ISONS:
1291  	case LLCSAP_IP:
1292  	case LLCSAP_NETBEUI:
1293  		b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, LINUX_SLL_P_802_2);
1294  		b1 = gen_cmp(cstate, OR_LLC, 0, BPF_H, (ll_proto << 8) | ll_proto);
1295  		gen_and(b0, b1);
1296  		return b1;
1297  	case LLCSAP_IPX:
1298  		b0 = gen_cmp(cstate, OR_LLC, 0, BPF_B, LLCSAP_IPX);
1299  		b1 = gen_snap(cstate, 0x000000, ETHERTYPE_IPX);
1300  		gen_or(b0, b1);
1301  		b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, LINUX_SLL_P_802_2);
1302  		gen_and(b0, b1);
1303  		b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, LINUX_SLL_P_802_3);
1304  		gen_or(b0, b1);
1305  		b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ETHERTYPE_IPX);
1306  		gen_or(b0, b1);
1307  		return b1;
1308  	case ETHERTYPE_ATALK:
1309  	case ETHERTYPE_AARP:
1310  		b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, LINUX_SLL_P_802_2);
1311  		if (ll_proto == ETHERTYPE_ATALK)
1312  			b1 = gen_snap(cstate, 0x080007, ETHERTYPE_ATALK);
1313  		else	&bsol;* ll_proto == ETHERTYPE_AARP */
1314  			b1 = gen_snap(cstate, 0x000000, ETHERTYPE_AARP);
1315  		gen_and(b0, b1);
1316  		b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ll_proto);
1317  		gen_or(b0, b1);
1318  		return b1;
1319  	default:
1320  		if (ll_proto <= ETHERMTU) {
1321  			b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, LINUX_SLL_P_802_2);
1322  			b1 = gen_cmp(cstate, OR_LINKHDR, cstate->off_linkpl.constant_part, BPF_B,
1323  			     ll_proto);
1324  			gen_and(b0, b1);
1325  			return b1;
1326  		} else {
1327  			return gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ll_proto);
1328  		}
1329  	}
1330  }
1331  static struct slist *
1332  gen_load_pflog_llprefixlen(compiler_state_t *cstate)
1333  {
1334  	struct slist *s1, *s2;
1335  	if (cstate->off_linkpl.reg != -1) {
1336  		s1 = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);
1337  		s1->s.k = 0;
1338  		s2 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);
1339  		s2->s.k = 3;
1340  		sappend(s1, s2);
1341  		s2 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);
1342  		s2->s.k = 0xfffffffc;
1343  		sappend(s1, s2);
1344  		s2 = new_stmt(cstate, BPF_ST);
1345  		s2->s.k = cstate->off_linkpl.reg;
1346  		sappend(s1, s2);
1347  		s2 = new_stmt(cstate, BPF_MISC|BPF_TAX);
1348  		sappend(s1, s2);
1349  		return (s1);
1350  	} else
1351  		return (NULL);
1352  }
1353  static struct slist *
1354  gen_load_prism_llprefixlen(compiler_state_t *cstate)
1355  {
1356  	struct slist *s1, *s2;
1357  	struct slist *sjeq_avs_cookie;
1358  	struct slist *sjcommon;
1359  	cstate->no_optimize = 1;
1360  	if (cstate->off_linkhdr.reg != -1) {
1361  		s1 = new_stmt(cstate, BPF_LD|BPF_W|BPF_ABS);
1362  		s1->s.k = 0;
1363  		s2 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);
1364  		s2->s.k = 0xFFFFF000;
1365  		sappend(s1, s2);
1366  		sjeq_avs_cookie = new_stmt(cstate, JMP(BPF_JEQ));
1367  		sjeq_avs_cookie->s.k = 0x80211000;
1368  		sappend(s1, sjeq_avs_cookie);
1369  		s2 = new_stmt(cstate, BPF_LD|BPF_W|BPF_ABS);
1370  		s2->s.k = 4;
1371  		sappend(s1, s2);
1372  		sjeq_avs_cookie->s.jt = s2;
1373  		sjcommon = new_stmt(cstate, JMP(BPF_JA));
1374  		sjcommon->s.k = 1;
1375  		sappend(s1, sjcommon);
1376  		s2 = new_stmt(cstate, BPF_LD|BPF_W|BPF_IMM);
1377  		s2->s.k = 144;
1378  		sappend(s1, s2);
1379  		sjeq_avs_cookie->s.jf = s2;
1380  		s2 = new_stmt(cstate, BPF_ST);
1381  		s2->s.k = cstate->off_linkhdr.reg;
1382  		sappend(s1, s2);
1383  		sjcommon->s.jf = s2;
1384  		s2 = new_stmt(cstate, BPF_MISC|BPF_TAX);
1385  		sappend(s1, s2);
1386  		return (s1);
1387  	} else
1388  		return (NULL);
1389  }
1390  static struct slist *
1391  gen_load_avs_llprefixlen(compiler_state_t *cstate)
1392  {
1393  	struct slist *s1, *s2;
1394  	if (cstate->off_linkhdr.reg != -1) {
1395  		s1 = new_stmt(cstate, BPF_LD|BPF_W|BPF_ABS);
1396  		s1->s.k = 4;
1397  		s2 = new_stmt(cstate, BPF_ST);
1398  		s2->s.k = cstate->off_linkhdr.reg;
1399  		sappend(s1, s2);
1400  		s2 = new_stmt(cstate, BPF_MISC|BPF_TAX);
1401  		sappend(s1, s2);
1402  		return (s1);
1403  	} else
1404  		return (NULL);
1405  }
1406  static struct slist *
1407  gen_load_radiotap_llprefixlen(compiler_state_t *cstate)
1408  {
1409  	struct slist *s1, *s2;
1410  	if (cstate->off_linkhdr.reg != -1) {
1411  		s1 = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);
1412  		s1->s.k = 3;
1413  		s2 = new_stmt(cstate, BPF_ALU|BPF_LSH|BPF_K);
1414  		sappend(s1, s2);
1415  		s2->s.k = 8;
1416  		s2 = new_stmt(cstate, BPF_MISC|BPF_TAX);
1417  		sappend(s1, s2);
1418  		s2 = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);
1419  		sappend(s1, s2);
1420  		s2->s.k = 2;
1421  		s2 = new_stmt(cstate, BPF_ALU|BPF_OR|BPF_X);
1422  		sappend(s1, s2);
1423  		s2 = new_stmt(cstate, BPF_ST);
1424  		s2->s.k = cstate->off_linkhdr.reg;
1425  		sappend(s1, s2);
1426  		s2 = new_stmt(cstate, BPF_MISC|BPF_TAX);
1427  		sappend(s1, s2);
1428  		return (s1);
1429  	} else
1430  		return (NULL);
1431  }
1432  static struct slist *
1433  gen_load_ppi_llprefixlen(compiler_state_t *cstate)
1434  {
1435  	struct slist *s1, *s2;
1436  	if (cstate->off_linkhdr.reg != -1) {
1437  		s1 = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);
1438  		s1->s.k = 3;
1439  		s2 = new_stmt(cstate, BPF_ALU|BPF_LSH|BPF_K);
1440  		sappend(s1, s2);
1441  		s2->s.k = 8;
1442  		s2 = new_stmt(cstate, BPF_MISC|BPF_TAX);
1443  		sappend(s1, s2);
1444  		s2 = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);
1445  		sappend(s1, s2);
1446  		s2->s.k = 2;
1447  		s2 = new_stmt(cstate, BPF_ALU|BPF_OR|BPF_X);
1448  		sappend(s1, s2);
1449  		s2 = new_stmt(cstate, BPF_ST);
1450  		s2->s.k = cstate->off_linkhdr.reg;
1451  		sappend(s1, s2);
1452  		s2 = new_stmt(cstate, BPF_MISC|BPF_TAX);
1453  		sappend(s1, s2);
1454  		return (s1);
1455  	} else
1456  		return (NULL);
1457  }
1458  static struct slist *
1459  gen_load_802_11_header_len(compiler_state_t *cstate, struct slist *s, struct slist *snext)
1460  {
1461  	struct slist *s2;
1462  	struct slist *sjset_data_frame_1;
1463  	struct slist *sjset_data_frame_2;
1464  	struct slist *sjset_qos;
1465  	struct slist *sjset_radiotap_flags_present;
1466  	struct slist *sjset_radiotap_ext_present;
1467  	struct slist *sjset_radiotap_tsft_present;
1468  	struct slist *sjset_tsft_datapad, *sjset_notsft_datapad;
1469  	struct slist *s_roundup;
1470  	if (cstate->off_linkpl.reg == -1) {
1471  		return (s);
1472  	}
1473  	cstate->no_optimize = 1;
1474  	if (s == NULL) {
1475  		s = new_stmt(cstate, BPF_LDX|BPF_IMM);
1476  		s->s.k = cstate->off_outermostlinkhdr.constant_part;
1477  	}
1478  	s2 = new_stmt(cstate, BPF_MISC|BPF_TXA);
1479  	sappend(s, s2);
1480  	s2 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);
1481  	s2->s.k = 24;
1482  	sappend(s, s2);
1483  	s2 = new_stmt(cstate, BPF_ST);
1484  	s2->s.k = cstate->off_linkpl.reg;
1485  	sappend(s, s2);
1486  	s2 = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);
1487  	s2->s.k = 0;
1488  	sappend(s, s2);
1489  	sjset_data_frame_1 = new_stmt(cstate, JMP(BPF_JSET));
1490  	sjset_data_frame_1->s.k = 0x08;
1491  	sappend(s, sjset_data_frame_1);
1492  	sjset_data_frame_1->s.jt = sjset_data_frame_2 = new_stmt(cstate, JMP(BPF_JSET));
1493  	sjset_data_frame_2->s.k = 0x04;
1494  	sappend(s, sjset_data_frame_2);
1495  	sjset_data_frame_1->s.jf = snext;
1496  	sjset_data_frame_2->s.jt = snext;
1497  	sjset_data_frame_2->s.jf = sjset_qos = new_stmt(cstate, JMP(BPF_JSET));
1498  	sjset_qos->s.k = 0x80;	&bsol;* QoS bit */
1499  	sappend(s, sjset_qos);
1500  	sjset_qos->s.jt = s2 = new_stmt(cstate, BPF_LD|BPF_MEM);
1501  	s2->s.k = cstate->off_linkpl.reg;
1502  	sappend(s, s2);
1503  	s2 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_IMM);
1504  	s2->s.k = 2;
1505  	sappend(s, s2);
1506  	s2 = new_stmt(cstate, BPF_ST);
1507  	s2->s.k = cstate->off_linkpl.reg;
1508  	sappend(s, s2);
1509  	if (cstate->linktype == DLT_IEEE802_11_RADIO) {
1510  		sjset_qos->s.jf = s2 = new_stmt(cstate, BPF_LD|BPF_ABS|BPF_W);
1511  		s2->s.k = 4;
1512  		sappend(s, s2);
1513  		sjset_radiotap_flags_present = new_stmt(cstate, JMP(BPF_JSET));
1514  		sjset_radiotap_flags_present->s.k = SWAPLONG(0x00000002);
1515  		sappend(s, sjset_radiotap_flags_present);
1516  		sjset_radiotap_flags_present->s.jf = snext;
1517  		sjset_radiotap_ext_present = new_stmt(cstate, JMP(BPF_JSET));
1518  		sjset_radiotap_ext_present->s.k = SWAPLONG(0x80000000);
1519  		sappend(s, sjset_radiotap_ext_present);
1520  		sjset_radiotap_flags_present->s.jt = sjset_radiotap_ext_present;
1521  		sjset_radiotap_ext_present->s.jt = snext;
1522  		sjset_radiotap_tsft_present = new_stmt(cstate, JMP(BPF_JSET));
1523  		sjset_radiotap_tsft_present->s.k = SWAPLONG(0x00000001);
1524  		sappend(s, sjset_radiotap_tsft_present);
1525  		sjset_radiotap_ext_present->s.jf = sjset_radiotap_tsft_present;
1526  		s2 = new_stmt(cstate, BPF_LD|BPF_ABS|BPF_B);
1527  		s2->s.k = 16;
1528  		sappend(s, s2);
1529  		sjset_radiotap_tsft_present->s.jt = s2;
1530  		sjset_tsft_datapad = new_stmt(cstate, JMP(BPF_JSET));
1531  		sjset_tsft_datapad->s.k = 0x20;
1532  		sappend(s, sjset_tsft_datapad);
1533  		s2 = new_stmt(cstate, BPF_LD|BPF_ABS|BPF_B);
1534  		s2->s.k = 8;
1535  		sappend(s, s2);
1536  		sjset_radiotap_tsft_present->s.jf = s2;
1537  		sjset_notsft_datapad = new_stmt(cstate, JMP(BPF_JSET));
1538  		sjset_notsft_datapad->s.k = 0x20;
1539  		sappend(s, sjset_notsft_datapad);
1540  		s_roundup = new_stmt(cstate, BPF_LD|BPF_MEM);
1541  		s_roundup->s.k = cstate->off_linkpl.reg;
1542  		sappend(s, s_roundup);
1543  		s2 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_IMM);
1544  		s2->s.k = 3;
1545  		sappend(s, s2);
1546  		s2 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_IMM);
1547  		s2->s.k = (bpf_u_int32)~3;
1548  		sappend(s, s2);
1549  		s2 = new_stmt(cstate, BPF_ST);
1550  		s2->s.k = cstate->off_linkpl.reg;
1551  		sappend(s, s2);
1552  		sjset_tsft_datapad->s.jt = s_roundup;
1553  		sjset_tsft_datapad->s.jf = snext;
1554  		sjset_notsft_datapad->s.jt = s_roundup;
1555  		sjset_notsft_datapad->s.jf = snext;
1556  	} else
1557  		sjset_qos->s.jf = snext;
1558  	return s;
1559  }
1560  static void
1561  insert_compute_vloffsets(compiler_state_t *cstate, struct block *b)
1562  {
1563  	struct slist *s;
1564  	if (cstate->off_linkpl.reg != -1 && cstate->off_linkhdr.is_variable &&
1565  	    cstate->off_linkhdr.reg == -1)
1566  		cstate->off_linkhdr.reg = alloc_reg(cstate);
1567  	switch (cstate->outermostlinktype) {
1568  	case DLT_PRISM_HEADER:
1569  		s = gen_load_prism_llprefixlen(cstate);
1570  		break;
1571  	case DLT_IEEE802_11_RADIO_AVS:
1572  		s = gen_load_avs_llprefixlen(cstate);
1573  		break;
1574  	case DLT_IEEE802_11_RADIO:
1575  		s = gen_load_radiotap_llprefixlen(cstate);
1576  		break;
1577  	case DLT_PPI:
1578  		s = gen_load_ppi_llprefixlen(cstate);
1579  		break;
1580  	default:
1581  		s = NULL;
1582  		break;
1583  	}
1584  	switch (cstate->outermostlinktype) {
1585  	case DLT_IEEE802_11:
1586  	case DLT_PRISM_HEADER:
1587  	case DLT_IEEE802_11_RADIO_AVS:
1588  	case DLT_IEEE802_11_RADIO:
1589  	case DLT_PPI:
1590  		s = gen_load_802_11_header_len(cstate, s, b->stmts);
1591  		break;
1592  	case DLT_PFLOG:
1593  		s = gen_load_pflog_llprefixlen(cstate);
1594  		break;
1595  	}
1596  	if (s == NULL && cstate->is_vlan_vloffset) {
1597  		struct slist *s2;
1598  		if (cstate->off_linkpl.reg == -1)
1599  			cstate->off_linkpl.reg = alloc_reg(cstate);
1600  		if (cstate->off_linktype.reg == -1)
1601  			cstate->off_linktype.reg = alloc_reg(cstate);
1602  		s = new_stmt(cstate, BPF_LD|BPF_W|BPF_IMM);
1603  		s->s.k = 0;
1604  		s2 = new_stmt(cstate, BPF_ST);
1605  		s2->s.k = cstate->off_linkpl.reg;
1606  		sappend(s, s2);
1607  		s2 = new_stmt(cstate, BPF_ST);
1608  		s2->s.k = cstate->off_linktype.reg;
1609  		sappend(s, s2);
1610  	}
1611  	if (s != NULL) {
1612  		sappend(s, b->stmts);
1613  		b->stmts = s;
1614  	}
1615  }
1616  static struct block *
1617  gen_ppi_dlt_check(compiler_state_t *cstate)
1618  {
1619  	struct slist *s_load_dlt;
1620  	struct block *b;
1621  	if (cstate->linktype == DLT_PPI)
1622  	{
1623  		s_load_dlt = new_stmt(cstate, BPF_LD|BPF_W|BPF_ABS);
1624  		s_load_dlt->s.k = 4;
1625  		b = new_block(cstate, JMP(BPF_JEQ));
1626  		b->stmts = s_load_dlt;
1627  		b->s.k = SWAPLONG(DLT_IEEE802_11);
1628  	}
1629  	else
1630  	{
1631  		b = NULL;
1632  	}
1633  	return b;
1634  }
1635  static struct slist *
1636  gen_abs_offset_varpart(compiler_state_t *cstate, bpf_abs_offset *off)
1637  {
1638  	struct slist *s;
1639  	if (off->is_variable) {
1640  		if (off->reg == -1) {
1641  			off->reg = alloc_reg(cstate);
1642  		}
1643  		s = new_stmt(cstate, BPF_LDX|BPF_MEM);
1644  		s->s.k = off->reg;
1645  		return s;
1646  	} else {
1647  		return NULL;
1648  	}
1649  }
1650  static bpf_u_int32
1651  ethertype_to_ppptype(bpf_u_int32 ll_proto)
1652  {
1653  	switch (ll_proto) {
1654  	case ETHERTYPE_IP:
1655  		ll_proto = PPP_IP;
1656  		break;
1657  	case ETHERTYPE_IPV6:
1658  		ll_proto = PPP_IPV6;
1659  		break;
1660  	case ETHERTYPE_DN:
1661  		ll_proto = PPP_DECNET;
1662  		break;
1663  	case ETHERTYPE_ATALK:
1664  		ll_proto = PPP_APPLE;
1665  		break;
1666  	case ETHERTYPE_NS:
1667  		ll_proto = PPP_NS;
1668  		break;
1669  	case LLCSAP_ISONS:
1670  		ll_proto = PPP_OSI;
1671  		break;
1672  	case LLCSAP_8021D:
1673  		ll_proto = PPP_BRPDU;
1674  		break;
1675  	case LLCSAP_IPX:
1676  		ll_proto = PPP_IPX;
1677  		break;
1678  	}
1679  	return (ll_proto);
1680  }
1681  static struct block *
1682  gen_prevlinkhdr_check(compiler_state_t *cstate)
1683  {
1684  	struct block *b0;
1685  	if (cstate->is_geneve)
1686  		return gen_geneve_ll_check(cstate);
1687  	switch (cstate->prevlinktype) {
1688  	case DLT_SUNATM:
1689  		b0 = gen_cmp(cstate, OR_PREVLINKHDR, SUNATM_PKT_BEGIN_POS, BPF_H, 0xFF00);
1690  		gen_not(b0);
1691  		return b0;
1692  	default:
1693  		return NULL;
1694  	}
1695  }
1696  #define BSD_AFNUM_INET6_BSD	24	&bsol;* NetBSD, OpenBSD, BSD/OS, Npcap */
1697  #define BSD_AFNUM_INET6_FREEBSD	28	&bsol;* FreeBSD */
1698  #define BSD_AFNUM_INET6_DARWIN	30	&bsol;* macOS, iOS, other Darwin-based OSes */
1699  static struct block *
1700  gen_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)
1701  {
1702  	struct block *b0, *b1, *b2;
1703  	const char *description;
1704  	if (cstate->label_stack_depth > 0)
1705  		return gen_mpls_linktype(cstate, ll_proto);
1706  	switch (cstate->linktype) {
1707  	case DLT_EN10MB:
1708  	case DLT_NETANALYZER:
1709  	case DLT_NETANALYZER_TRANSPARENT:
1710  		if (!cstate->is_geneve)
1711  			b0 = gen_prevlinkhdr_check(cstate);
1712  		else
1713  			b0 = NULL;
1714  		b1 = gen_ether_linktype(cstate, ll_proto);
1715  		if (b0 != NULL)
1716  			gen_and(b0, b1);
1717  		return b1;
1718  	case DLT_C_HDLC:
1719  	case DLT_HDLC:
1720  		switch (ll_proto) {
1721  		case LLCSAP_ISONS:
1722  			ll_proto = (ll_proto << 8 | LLCSAP_ISONS);
1723  		default:
1724  			return gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ll_proto);
1725  		}
1726  	case DLT_IEEE802_11:
1727  	case DLT_PRISM_HEADER:
1728  	case DLT_IEEE802_11_RADIO_AVS:
1729  	case DLT_IEEE802_11_RADIO:
1730  	case DLT_PPI:
1731  		b0 = gen_check_802_11_data_frame(cstate);
1732  		b1 = gen_llc_linktype(cstate, ll_proto);
1733  		gen_and(b0, b1);
1734  		return b1;
1735  	case DLT_FDDI:
1736  		return gen_llc_linktype(cstate, ll_proto);
1737  	case DLT_IEEE802:
1738  		return gen_llc_linktype(cstate, ll_proto);
1739  	case DLT_ATM_RFC1483:
1740  	case DLT_ATM_CLIP:
1741  	case DLT_IP_OVER_FC:
1742  		return gen_llc_linktype(cstate, ll_proto);
1743  	case DLT_SUNATM:
1744  		b0 = gen_atmfield_code_internal(cstate, A_PROTOTYPE, PT_LLC, BPF_JEQ, 0);
1745  		b1 = gen_llc_linktype(cstate, ll_proto);
1746  		gen_and(b0, b1);
1747  		return b1;
1748  	case DLT_LINUX_SLL:
1749  		return gen_linux_sll_linktype(cstate, ll_proto);
1750  	case DLT_SLIP:
1751  	case DLT_SLIP_BSDOS:
1752  	case DLT_RAW:
1753  		switch (ll_proto) {
1754  		case ETHERTYPE_IP:
1755  			return gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, 0x40, 0xF0);
1756  		case ETHERTYPE_IPV6:
1757  			return gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, 0x60, 0xF0);
1758  		default:
1759  			return gen_false(cstate);	&bsol;* always false */
1760  		}
1761  	case DLT_IPV4:
1762  		if (ll_proto == ETHERTYPE_IP)
1763  			return gen_true(cstate);	&bsol;* always true */
1764  		return gen_false(cstate);
1765  	case DLT_IPV6:
1766  		if (ll_proto == ETHERTYPE_IPV6)
1767  			return gen_true(cstate);	&bsol;* always true */
1768  		return gen_false(cstate);
1769  	case DLT_PPP:
1770  	case DLT_PPP_PPPD:
1771  	case DLT_PPP_SERIAL:
1772  	case DLT_PPP_ETHER:
1773  		return gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H,
1774  		    ethertype_to_ppptype(ll_proto));
1775  	case DLT_PPP_BSDOS:
1776  		switch (ll_proto) {
1777  		case ETHERTYPE_IP:
1778  			b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, PPP_IP);
1779  			b1 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, PPP_VJC);
1780  			gen_or(b0, b1);
1781  			b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, PPP_VJNC);
1782  			gen_or(b1, b0);
1783  			return b0;
1784  		default:
1785  			return gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H,
1786  			    ethertype_to_ppptype(ll_proto));
1787  		}
1788  	case DLT_NULL:
1789  	case DLT_LOOP:
1790  	case DLT_ENC:
1791  		switch (ll_proto) {
1792  		case ETHERTYPE_IP:
1793  			return (gen_loopback_linktype(cstate, AF_INET));
1794  		case ETHERTYPE_IPV6:
1795  			if (cstate->bpf_pcap->rfile != NULL) {
1796  				b0 = gen_loopback_linktype(cstate, BSD_AFNUM_INET6_BSD);
1797  				b1 = gen_loopback_linktype(cstate, BSD_AFNUM_INET6_FREEBSD);
1798  				gen_or(b0, b1);
1799  				b0 = gen_loopback_linktype(cstate, BSD_AFNUM_INET6_DARWIN);
1800  				gen_or(b0, b1);
1801  				return (b1);
1802  			} else {
1803  #ifdef _WIN32
1804  				return (gen_loopback_linktype(cstate, 24));
1805  #else &bsol;* _WIN32 */
1806  #ifdef AF_INET6
1807  				return (gen_loopback_linktype(cstate, AF_INET6));
1808  #else &bsol;* AF_INET6 */
1809  				return gen_false(cstate);
1810  #endif &bsol;* AF_INET6 */
1811  #endif &bsol;* _WIN32 */
1812  			}
1813  		default:
1814  			return gen_false(cstate);
1815  		}
1816  	case DLT_PFLOG:
1817  		if (ll_proto == ETHERTYPE_IP)
1818  			return (gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, af),
1819  			    BPF_B, AF_INET));
1820  		else if (ll_proto == ETHERTYPE_IPV6)
1821  			return (gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, af),
1822  			    BPF_B, AF_INET6));
1823  		else
1824  			return gen_false(cstate);
1825  	case DLT_ARCNET:
1826  	case DLT_ARCNET_LINUX:
1827  		switch (ll_proto) {
1828  		default:
1829  			return gen_false(cstate);
1830  		case ETHERTYPE_IPV6:
1831  			return (gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,
1832  				ARCTYPE_INET6));
1833  		case ETHERTYPE_IP:
1834  			b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,
1835  			    ARCTYPE_IP);
1836  			b1 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,
1837  			    ARCTYPE_IP_OLD);
1838  			gen_or(b0, b1);
1839  			return (b1);
1840  		case ETHERTYPE_ARP:
1841  			b0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,
1842  			    ARCTYPE_ARP);
1843  			b1 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,
1844  			    ARCTYPE_ARP_OLD);
1845  			gen_or(b0, b1);
1846  			return (b1);
1847  		case ETHERTYPE_REVARP:
1848  			return (gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,
1849  			    ARCTYPE_REVARP));
1850  		case ETHERTYPE_ATALK:
1851  			return (gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,
1852  			    ARCTYPE_ATALK));
1853  		}
1854  	case DLT_LTALK:
1855  		switch (ll_proto) {
1856  		case ETHERTYPE_ATALK:
1857  			return gen_true(cstate);
1858  		default:
1859  			return gen_false(cstate);
1860  		}
1861  	case DLT_FRELAY:
1862  		switch (ll_proto) {
1863  		case ETHERTYPE_IP:
1864  			return gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | 0xcc);
1865  		case ETHERTYPE_IPV6:
1866  			return gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | 0x8e);
1867  		case LLCSAP_ISONS:
1868  			b0 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | ISO8473_CLNP);
1869  			b1 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | ISO9542_ESIS);
1870  			b2 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | ISO10589_ISIS);
1871  			gen_or(b1, b2);
1872  			gen_or(b0, b2);
1873  			return b2;
1874  		default:
1875  			return gen_false(cstate);
1876  		}
1877  	case DLT_MFR:
1878  		bpf_error(cstate, "Multi-link Frame Relay link-layer type filtering not implemented");
1879          case DLT_JUNIPER_MFR:
1880          case DLT_JUNIPER_MLFR:
1881          case DLT_JUNIPER_MLPPP:
1882  	case DLT_JUNIPER_ATM1:
1883  	case DLT_JUNIPER_ATM2:
1884  	case DLT_JUNIPER_PPPOE:
1885  	case DLT_JUNIPER_PPPOE_ATM:
1886          case DLT_JUNIPER_GGSN:
1887          case DLT_JUNIPER_ES:
1888          case DLT_JUNIPER_MONITOR:
1889          case DLT_JUNIPER_SERVICES:
1890          case DLT_JUNIPER_ETHER:
1891          case DLT_JUNIPER_PPP:
1892          case DLT_JUNIPER_FRELAY:
1893          case DLT_JUNIPER_CHDLC:
1894          case DLT_JUNIPER_VP:
1895          case DLT_JUNIPER_ST:
1896          case DLT_JUNIPER_ISM:
1897          case DLT_JUNIPER_VS:
1898          case DLT_JUNIPER_SRX_E2E:
1899          case DLT_JUNIPER_FIBRECHANNEL:
1900  	case DLT_JUNIPER_ATM_CEMIC:
1901  		return gen_mcmp(cstate, OR_LINKHDR, 0, BPF_W, 0x4d474300, 0xffffff00); &bsol;* compare the magic number */
1902  	case DLT_BACNET_MS_TP:
1903  		return gen_mcmp(cstate, OR_LINKHDR, 0, BPF_W, 0x55FF0000, 0xffff0000);
1904  	case DLT_IPNET:
1905  		return gen_ipnet_linktype(cstate, ll_proto);
1906  	case DLT_LINUX_IRDA:
1907  		bpf_error(cstate, "IrDA link-layer type filtering not implemented");
1908  	case DLT_DOCSIS:
1909  		bpf_error(cstate, "DOCSIS link-layer type filtering not implemented");
1910  	case DLT_MTP2:
1911  	case DLT_MTP2_WITH_PHDR:
1912  		bpf_error(cstate, "MTP2 link-layer type filtering not implemented");
1913  	case DLT_ERF:
1914  		bpf_error(cstate, "ERF link-layer type filtering not implemented");
1915  	case DLT_PFSYNC:
1916  		bpf_error(cstate, "PFSYNC link-layer type filtering not implemented");
1917  	case DLT_LINUX_LAPD:
1918  		bpf_error(cstate, "LAPD link-layer type filtering not implemented");
1919  	case DLT_USB_FREEBSD:
1920  	case DLT_USB_LINUX:
1921  	case DLT_USB_LINUX_MMAPPED:
1922  	case DLT_USBPCAP:
1923  		bpf_error(cstate, "USB link-layer type filtering not implemented");
1924  	case DLT_BLUETOOTH_HCI_H4:
1925  	case DLT_BLUETOOTH_HCI_H4_WITH_PHDR:
1926  		bpf_error(cstate, "Bluetooth link-layer type filtering not implemented");
1927  	case DLT_CAN20B:
1928  	case DLT_CAN_SOCKETCAN:
1929  		bpf_error(cstate, "CAN link-layer type filtering not implemented");
1930  	case DLT_IEEE802_15_4:
1931  	case DLT_IEEE802_15_4_LINUX:
1932  	case DLT_IEEE802_15_4_NONASK_PHY:
1933  	case DLT_IEEE802_15_4_NOFCS:
1934  	case DLT_IEEE802_15_4_TAP:
1935  		bpf_error(cstate, "IEEE 802.15.4 link-layer type filtering not implemented");
1936  	case DLT_IEEE802_16_MAC_CPS_RADIO:
1937  		bpf_error(cstate, "IEEE 802.16 link-layer type filtering not implemented");
1938  	case DLT_SITA:
1939  		bpf_error(cstate, "SITA link-layer type filtering not implemented");
1940  	case DLT_RAIF1:
1941  		bpf_error(cstate, "RAIF1 link-layer type filtering not implemented");
1942  	case DLT_IPMB_KONTRON:
1943  	case DLT_IPMB_LINUX:
1944  		bpf_error(cstate, "IPMB link-layer type filtering not implemented");
1945  	case DLT_AX25_KISS:
1946  		bpf_error(cstate, "AX.25 link-layer type filtering not implemented");
1947  	case DLT_NFLOG:
1948  		bpf_error(cstate, "NFLOG link-layer type filtering not implemented");
1949  	default:
1950  		if (cstate->off_linktype.constant_part != OFFSET_NOT_SET) {
1951  			return gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ll_proto);
1952  		} else {
1953  			description = pcap_datalink_val_to_description_or_dlt(cstate->linktype);
1954  			bpf_error(cstate, "%s link-layer type filtering not implemented",
1955  			    description);
1956  		}
1957  	}
1958  }
1959  static struct block *
1960  gen_snap(compiler_state_t *cstate, bpf_u_int32 orgcode, bpf_u_int32 ptype)
1961  {
1962  	u_char snapblock[8];
1963  	snapblock[0] = LLCSAP_SNAP;		&bsol;* DSAP = SNAP */
1964  	snapblock[1] = LLCSAP_SNAP;		&bsol;* SSAP = SNAP */
1965  	snapblock[2] = 0x03;			&bsol;* control = UI */
1966  	snapblock[3] = (u_char)(orgcode >> 16);	&bsol;* upper 8 bits of organization code */
1967  	snapblock[4] = (u_char)(orgcode >> 8);	&bsol;* middle 8 bits of organization code */
1968  	snapblock[5] = (u_char)(orgcode >> 0);	&bsol;* lower 8 bits of organization code */
1969  	snapblock[6] = (u_char)(ptype >> 8);	&bsol;* upper 8 bits of protocol type */
1970  	snapblock[7] = (u_char)(ptype >> 0);	&bsol;* lower 8 bits of protocol type */
1971  	return gen_bcmp(cstate, OR_LLC, 0, 8, snapblock);
1972  }
1973  static struct block *
1974  gen_llc_internal(compiler_state_t *cstate)
1975  {
1976  	struct block *b0, *b1;
1977  	switch (cstate->linktype) {
1978  	case DLT_EN10MB:
1979  		b0 = gen_cmp_gt(cstate, OR_LINKTYPE, 0, BPF_H, ETHERMTU);
1980  		gen_not(b0);
1981  		b1 = gen_cmp(cstate, OR_LLC, 0, BPF_H, 0xFFFF);
1982  		gen_not(b1);
1983  		gen_and(b0, b1);
1984  		return b1;
1985  	case DLT_SUNATM:
1986  		b0 = gen_atmtype_llc(cstate);
1987  		return b0;
1988  	case DLT_IEEE802:	&bsol;* Token Ring */
1989  		return gen_true(cstate);
1990  	case DLT_FDDI:
1991  		return gen_true(cstate);
1992  	case DLT_ATM_RFC1483:
1993  		return gen_true(cstate);
1994  	case DLT_IEEE802_11:
1995  	case DLT_PRISM_HEADER:
1996  	case DLT_IEEE802_11_RADIO:
1997  	case DLT_IEEE802_11_RADIO_AVS:
1998  	case DLT_PPI:
1999  		b0 = gen_check_802_11_data_frame(cstate);
2000  		return b0;
2001  	default:
2002  		bpf_error(cstate, "'llc' not supported for %s",
2003  			  pcap_datalink_val_to_description_or_dlt(cstate->linktype));
2004  	}
2005  }
2006  struct block *
2007  gen_llc(compiler_state_t *cstate)
2008  {
2009  	if (setjmp(cstate->top_ctx))
2010  		return (NULL);
2011  	return gen_llc_internal(cstate);
2012  }
2013  struct block *
2014  gen_llc_i(compiler_state_t *cstate)
2015  {
2016  	struct block *b0, *b1;
2017  	struct slist *s;
2018  	if (setjmp(cstate->top_ctx))
2019  		return (NULL);
2020  	b0 = gen_llc_internal(cstate);
2021  	s = gen_load_a(cstate, OR_LLC, 2, BPF_B);
2022  	b1 = new_block(cstate, JMP(BPF_JSET));
2023  	b1->s.k = 0x01;
2024  	b1->stmts = s;
2025  	gen_not(b1);
2026  	gen_and(b0, b1);
2027  	return b1;
2028  }
2029  struct block *
2030  gen_llc_s(compiler_state_t *cstate)
2031  {
2032  	struct block *b0, *b1;
2033  	if (setjmp(cstate->top_ctx))
2034  		return (NULL);
2035  	b0 = gen_llc_internal(cstate);
2036  	b1 = gen_mcmp(cstate, OR_LLC, 2, BPF_B, LLC_S_FMT, 0x03);
2037  	gen_and(b0, b1);
2038  	return b1;
2039  }
2040  struct block *
2041  gen_llc_u(compiler_state_t *cstate)
2042  {
2043  	struct block *b0, *b1;
2044  	if (setjmp(cstate->top_ctx))
2045  		return (NULL);
2046  	b0 = gen_llc_internal(cstate);
2047  	b1 = gen_mcmp(cstate, OR_LLC, 2, BPF_B, LLC_U_FMT, 0x03);
2048  	gen_and(b0, b1);
2049  	return b1;
2050  }
2051  struct block *
2052  gen_llc_s_subtype(compiler_state_t *cstate, bpf_u_int32 subtype)
2053  {
2054  	struct block *b0, *b1;
2055  	if (setjmp(cstate->top_ctx))
2056  		return (NULL);
2057  	b0 = gen_llc_internal(cstate);
2058  	b1 = gen_mcmp(cstate, OR_LLC, 2, BPF_B, subtype, LLC_S_CMD_MASK);
2059  	gen_and(b0, b1);
2060  	return b1;
2061  }
2062  struct block *
2063  gen_llc_u_subtype(compiler_state_t *cstate, bpf_u_int32 subtype)
2064  {
2065  	struct block *b0, *b1;
2066  	if (setjmp(cstate->top_ctx))
2067  		return (NULL);
2068  	b0 = gen_llc_internal(cstate);
2069  	b1 = gen_mcmp(cstate, OR_LLC, 2, BPF_B, subtype, LLC_U_CMD_MASK);
2070  	gen_and(b0, b1);
2071  	return b1;
2072  }
2073  static struct block *
2074  gen_llc_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)
2075  {
2076  	switch (ll_proto) {
2077  	case LLCSAP_IP:
2078  	case LLCSAP_ISONS:
2079  	case LLCSAP_NETBEUI:
2080  		return gen_cmp(cstate, OR_LLC, 0, BPF_H, (bpf_u_int32)
2081  			     ((ll_proto << 8) | ll_proto));
2082  	case LLCSAP_IPX:
2083  		return gen_cmp(cstate, OR_LLC, 0, BPF_B, LLCSAP_IPX);
2084  	case ETHERTYPE_ATALK:
2085  		return gen_snap(cstate, 0x080007, ETHERTYPE_ATALK);
2086  	default:
2087  		if (ll_proto <= ETHERMTU) {
2088  			return gen_cmp(cstate, OR_LLC, 0, BPF_B, ll_proto);
2089  		} else {
2090  			return gen_cmp(cstate, OR_LLC, 6, BPF_H, ll_proto);
2091  		}
2092  	}
2093  }
2094  static struct block *
2095  gen_hostop(compiler_state_t *cstate, bpf_u_int32 addr, bpf_u_int32 mask,
2096      int dir, bpf_u_int32 ll_proto, u_int src_off, u_int dst_off)
2097  {
2098  	struct block *b0, *b1;
2099  	u_int offset;
2100  	switch (dir) {
2101  	case Q_SRC:
2102  		offset = src_off;
2103  		break;
2104  	case Q_DST:
2105  		offset = dst_off;
2106  		break;
2107  	case Q_AND:
2108  		b0 = gen_hostop(cstate, addr, mask, Q_SRC, ll_proto, src_off, dst_off);
2109  		b1 = gen_hostop(cstate, addr, mask, Q_DST, ll_proto, src_off, dst_off);
2110  		gen_and(b0, b1);
2111  		return b1;
2112  	case Q_DEFAULT:
2113  	case Q_OR:
2114  		b0 = gen_hostop(cstate, addr, mask, Q_SRC, ll_proto, src_off, dst_off);
2115  		b1 = gen_hostop(cstate, addr, mask, Q_DST, ll_proto, src_off, dst_off);
2116  		gen_or(b0, b1);
2117  		return b1;
2118  	case Q_ADDR1:
2119  		bpf_error(cstate, "'addr1' and 'address1' are not valid qualifiers for addresses other than 802.11 MAC addresses");
2120  	case Q_ADDR2:
2121  		bpf_error(cstate, "'addr2' and 'address2' are not valid qualifiers for addresses other than 802.11 MAC addresses");
2122  	case Q_ADDR3:
2123  		bpf_error(cstate, "'addr3' and 'address3' are not valid qualifiers for addresses other than 802.11 MAC addresses");
2124  	case Q_ADDR4:
2125  		bpf_error(cstate, "'addr4' and 'address4' are not valid qualifiers for addresses other than 802.11 MAC addresses");
2126  	case Q_RA:
2127  		bpf_error(cstate, "'ra' is not a valid qualifier for addresses other than 802.11 MAC addresses");
2128  	case Q_TA:
2129  		bpf_error(cstate, "'ta' is not a valid qualifier for addresses other than 802.11 MAC addresses");
2130  	default:
2131  		abort();
2132  	}
2133  	b0 = gen_linktype(cstate, ll_proto);
2134  	b1 = gen_mcmp(cstate, OR_LINKPL, offset, BPF_W, addr, mask);
2135  	gen_and(b0, b1);
2136  	return b1;
2137  }
2138  #ifdef INET6
2139  static struct block *
2140  gen_hostop6(compiler_state_t *cstate, struct in6_addr *addr,
2141      struct in6_addr *mask, int dir, bpf_u_int32 ll_proto, u_int src_off,
2142      u_int dst_off)
2143  {
2144  	struct block *b0, *b1;
2145  	u_int offset;
2146  	bpf_u_int32 a[4], m[4];
2147  	switch (dir) {
2148  	case Q_SRC:
2149  		offset = src_off;
2150  		break;
2151  	case Q_DST:
2152  		offset = dst_off;
2153  		break;
2154  	case Q_AND:
2155  		b0 = gen_hostop6(cstate, addr, mask, Q_SRC, ll_proto, src_off, dst_off);
2156  		b1 = gen_hostop6(cstate, addr, mask, Q_DST, ll_proto, src_off, dst_off);
2157  		gen_and(b0, b1);
2158  		return b1;
2159  	case Q_DEFAULT:
2160  	case Q_OR:
2161  		b0 = gen_hostop6(cstate, addr, mask, Q_SRC, ll_proto, src_off, dst_off);
2162  		b1 = gen_hostop6(cstate, addr, mask, Q_DST, ll_proto, src_off, dst_off);
2163  		gen_or(b0, b1);
2164  		return b1;
2165  	case Q_ADDR1:
2166  		bpf_error(cstate, "'addr1' and 'address1' are not valid qualifiers for addresses other than 802.11 MAC addresses");
2167  	case Q_ADDR2:
2168  		bpf_error(cstate, "'addr2' and 'address2' are not valid qualifiers for addresses other than 802.11 MAC addresses");
2169  	case Q_ADDR3:
2170  		bpf_error(cstate, "'addr3' and 'address3' are not valid qualifiers for addresses other than 802.11 MAC addresses");
2171  	case Q_ADDR4:
2172  		bpf_error(cstate, "'addr4' and 'address4' are not valid qualifiers for addresses other than 802.11 MAC addresses");
2173  	case Q_RA:
2174  		bpf_error(cstate, "'ra' is not a valid qualifier for addresses other than 802.11 MAC addresses");
2175  	case Q_TA:
2176  		bpf_error(cstate, "'ta' is not a valid qualifier for addresses other than 802.11 MAC addresses");
2177  	default:
2178  		abort();
2179  	}
2180  	memcpy(a, addr, sizeof(a));
2181  	memcpy(m, mask, sizeof(m));
2182  	b1 = gen_mcmp(cstate, OR_LINKPL, offset + 12, BPF_W, ntohl(a[3]), ntohl(m[3]));
2183  	b0 = gen_mcmp(cstate, OR_LINKPL, offset + 8, BPF_W, ntohl(a[2]), ntohl(m[2]));
2184  	gen_and(b0, b1);
2185  	b0 = gen_mcmp(cstate, OR_LINKPL, offset + 4, BPF_W, ntohl(a[1]), ntohl(m[1]));
2186  	gen_and(b0, b1);
2187  	b0 = gen_mcmp(cstate, OR_LINKPL, offset + 0, BPF_W, ntohl(a[0]), ntohl(m[0]));
2188  	gen_and(b0, b1);
2189  	b0 = gen_linktype(cstate, ll_proto);
2190  	gen_and(b0, b1);
2191  	return b1;
2192  }
2193  #endif
2194  static struct block *
2195  gen_ehostop(compiler_state_t *cstate, const u_char *eaddr, int dir)
2196  {
2197  	register struct block *b0, *b1;
2198  	switch (dir) {
2199  	case Q_SRC:
2200  		return gen_bcmp(cstate, OR_LINKHDR, 6, 6, eaddr);
2201  	case Q_DST:
2202  		return gen_bcmp(cstate, OR_LINKHDR, 0, 6, eaddr);
2203  	case Q_AND:
2204  		b0 = gen_ehostop(cstate, eaddr, Q_SRC);
2205  		b1 = gen_ehostop(cstate, eaddr, Q_DST);
2206  		gen_and(b0, b1);
2207  		return b1;
2208  	case Q_DEFAULT:
2209  	case Q_OR:
2210  		b0 = gen_ehostop(cstate, eaddr, Q_SRC);
2211  		b1 = gen_ehostop(cstate, eaddr, Q_DST);
2212  		gen_or(b0, b1);
2213  		return b1;
2214  	case Q_ADDR1:
2215  		bpf_error(cstate, "'addr1' and 'address1' are only supported on 802.11 with 802.11 headers");
2216  	case Q_ADDR2:
2217  		bpf_error(cstate, "'addr2' and 'address2' are only supported on 802.11 with 802.11 headers");
2218  	case Q_ADDR3:
2219  		bpf_error(cstate, "'addr3' and 'address3' are only supported on 802.11 with 802.11 headers");
2220  	case Q_ADDR4:
2221  		bpf_error(cstate, "'addr4' and 'address4' are only supported on 802.11 with 802.11 headers");
2222  	case Q_RA:
2223  		bpf_error(cstate, "'ra' is only supported on 802.11 with 802.11 headers");
2224  	case Q_TA:
2225  		bpf_error(cstate, "'ta' is only supported on 802.11 with 802.11 headers");
2226  	}
2227  	abort();
2228  }
2229  static struct block *
2230  gen_fhostop(compiler_state_t *cstate, const u_char *eaddr, int dir)
2231  {
2232  	struct block *b0, *b1;
2233  	switch (dir) {
2234  	case Q_SRC:
2235  		return gen_bcmp(cstate, OR_LINKHDR, 6 + 1 + cstate->pcap_fddipad, 6, eaddr);
2236  	case Q_DST:
2237  		return gen_bcmp(cstate, OR_LINKHDR, 0 + 1 + cstate->pcap_fddipad, 6, eaddr);
2238  	case Q_AND:
2239  		b0 = gen_fhostop(cstate, eaddr, Q_SRC);
2240  		b1 = gen_fhostop(cstate, eaddr, Q_DST);
2241  		gen_and(b0, b1);
2242  		return b1;
2243  	case Q_DEFAULT:
2244  	case Q_OR:
2245  		b0 = gen_fhostop(cstate, eaddr, Q_SRC);
2246  		b1 = gen_fhostop(cstate, eaddr, Q_DST);
2247  		gen_or(b0, b1);
2248  		return b1;
2249  	case Q_ADDR1:
2250  		bpf_error(cstate, "'addr1' and 'address1' are only supported on 802.11");
2251  	case Q_ADDR2:
2252  		bpf_error(cstate, "'addr2' and 'address2' are only supported on 802.11");
2253  	case Q_ADDR3:
2254  		bpf_error(cstate, "'addr3' and 'address3' are only supported on 802.11");
2255  	case Q_ADDR4:
2256  		bpf_error(cstate, "'addr4' and 'address4' are only supported on 802.11");
2257  	case Q_RA:
2258  		bpf_error(cstate, "'ra' is only supported on 802.11");
2259  	case Q_TA:
2260  		bpf_error(cstate, "'ta' is only supported on 802.11");
2261  	}
2262  	abort();
2263  }
2264  static struct block *
2265  gen_thostop(compiler_state_t *cstate, const u_char *eaddr, int dir)
2266  {
2267  	register struct block *b0, *b1;
2268  	switch (dir) {
2269  	case Q_SRC:
2270  		return gen_bcmp(cstate, OR_LINKHDR, 8, 6, eaddr);
2271  	case Q_DST:
2272  		return gen_bcmp(cstate, OR_LINKHDR, 2, 6, eaddr);
2273  	case Q_AND:
2274  		b0 = gen_thostop(cstate, eaddr, Q_SRC);
2275  		b1 = gen_thostop(cstate, eaddr, Q_DST);
2276  		gen_and(b0, b1);
2277  		return b1;
2278  	case Q_DEFAULT:
2279  	case Q_OR:
2280  		b0 = gen_thostop(cstate, eaddr, Q_SRC);
2281  		b1 = gen_thostop(cstate, eaddr, Q_DST);
2282  		gen_or(b0, b1);
2283  		return b1;
2284  	case Q_ADDR1:
2285  		bpf_error(cstate, "'addr1' and 'address1' are only supported on 802.11");
2286  	case Q_ADDR2:
2287  		bpf_error(cstate, "'addr2' and 'address2' are only supported on 802.11");
2288  	case Q_ADDR3:
2289  		bpf_error(cstate, "'addr3' and 'address3' are only supported on 802.11");
2290  	case Q_ADDR4:
2291  		bpf_error(cstate, "'addr4' and 'address4' are only supported on 802.11");
2292  	case Q_RA:
2293  		bpf_error(cstate, "'ra' is only supported on 802.11");
2294  	case Q_TA:
2295  		bpf_error(cstate, "'ta' is only supported on 802.11");
2296  	}
2297  	abort();
2298  }
2299  static struct block *
2300  gen_wlanhostop(compiler_state_t *cstate, const u_char *eaddr, int dir)
2301  {
2302  	register struct block *b0, *b1, *b2;
2303  	register struct slist *s;
2304  #ifdef ENABLE_WLAN_FILTERING_PATCH
2305  	cstate->no_optimize = 1;
2306  #endif &bsol;* ENABLE_WLAN_FILTERING_PATCH */
2307  	switch (dir) {
2308  	case Q_SRC:
2309  		s = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);
2310  		b1 = new_block(cstate, JMP(BPF_JSET));
2311  		b1->s.k = 0x01;	&bsol;* To DS */
2312  		b1->stmts = s;
2313  		b0 = gen_bcmp(cstate, OR_LINKHDR, 24, 6, eaddr);
2314  		gen_and(b1, b0);
2315  		s = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);
2316  		b2 = new_block(cstate, JMP(BPF_JSET));
2317  		b2->s.k = 0x01;	&bsol;* To DS */
2318  		b2->stmts = s;
2319  		gen_not(b2);
2320  		b1 = gen_bcmp(cstate, OR_LINKHDR, 16, 6, eaddr);
2321  		gen_and(b2, b1);
2322  		gen_or(b1, b0);
2323  		s = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);
2324  		b1 = new_block(cstate, JMP(BPF_JSET));
2325  		b1->s.k = 0x02;	&bsol;* From DS */
2326  		b1->stmts = s;
2327  		gen_and(b1, b0);
2328  		s = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);
2329  		b2 = new_block(cstate, JMP(BPF_JSET));
2330  		b2->s.k = 0x02;	&bsol;* From DS */
2331  		b2->stmts = s;
2332  		gen_not(b2);
2333  		b1 = gen_bcmp(cstate, OR_LINKHDR, 10, 6, eaddr);
2334  		gen_and(b2, b1);
2335  		gen_or(b1, b0);
2336  		s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
2337  		b1 = new_block(cstate, JMP(BPF_JSET));
2338  		b1->s.k = 0x08;
2339  		b1->stmts = s;
2340  		gen_and(b1, b0);
2341  		s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
2342  		b2 = new_block(cstate, JMP(BPF_JSET));
2343  		b2->s.k = 0x08;
2344  		b2->stmts = s;
2345  		gen_not(b2);
2346  		b1 = gen_bcmp(cstate, OR_LINKHDR, 10, 6, eaddr);
2347  		gen_and(b2, b1);
2348  		gen_or(b1, b0);
2349  		s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
2350  		b1 = new_block(cstate, JMP(BPF_JSET));
2351  		b1->s.k = 0x04;
2352  		b1->stmts = s;
2353  		gen_not(b1);
2354  		gen_and(b1, b0);
2355  		return b0;
2356  	case Q_DST:
2357  		s = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);
2358  		b1 = new_block(cstate, JMP(BPF_JSET));
2359  		b1->s.k = 0x01;	&bsol;* To DS */
2360  		b1->stmts = s;
2361  		b0 = gen_bcmp(cstate, OR_LINKHDR, 16, 6, eaddr);
2362  		gen_and(b1, b0);
2363  		s = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);
2364  		b2 = new_block(cstate, JMP(BPF_JSET));
2365  		b2->s.k = 0x01;	&bsol;* To DS */
2366  		b2->stmts = s;
2367  		gen_not(b2);
2368  		b1 = gen_bcmp(cstate, OR_LINKHDR, 4, 6, eaddr);
2369  		gen_and(b2, b1);
2370  		gen_or(b1, b0);
2371  		s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
2372  		b1 = new_block(cstate, JMP(BPF_JSET));
2373  		b1->s.k = 0x08;
2374  		b1->stmts = s;
2375  		gen_and(b1, b0);
2376  		s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
2377  		b2 = new_block(cstate, JMP(BPF_JSET));
2378  		b2->s.k = 0x08;
2379  		b2->stmts = s;
2380  		gen_not(b2);
2381  		b1 = gen_bcmp(cstate, OR_LINKHDR, 4, 6, eaddr);
2382  		gen_and(b2, b1);
2383  		gen_or(b1, b0);
2384  		s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
2385  		b1 = new_block(cstate, JMP(BPF_JSET));
2386  		b1->s.k = 0x04;
2387  		b1->stmts = s;
2388  		gen_not(b1);
2389  		gen_and(b1, b0);
2390  		return b0;
2391  	case Q_AND:
2392  		b0 = gen_wlanhostop(cstate, eaddr, Q_SRC);
2393  		b1 = gen_wlanhostop(cstate, eaddr, Q_DST);
2394  		gen_and(b0, b1);
2395  		return b1;
2396  	case Q_DEFAULT:
2397  	case Q_OR:
2398  		b0 = gen_wlanhostop(cstate, eaddr, Q_SRC);
2399  		b1 = gen_wlanhostop(cstate, eaddr, Q_DST);
2400  		gen_or(b0, b1);
2401  		return b1;
2402  	case Q_ADDR1:
2403  		return (gen_bcmp(cstate, OR_LINKHDR, 4, 6, eaddr));
2404  	case Q_ADDR2:
2405  		b0 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_TYPE_CTL,
2406  			IEEE80211_FC0_TYPE_MASK);
2407  		gen_not(b0);
2408  		b1 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_SUBTYPE_CTS,
2409  			IEEE80211_FC0_SUBTYPE_MASK);
2410  		gen_not(b1);
2411  		b2 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_SUBTYPE_ACK,
2412  			IEEE80211_FC0_SUBTYPE_MASK);
2413  		gen_not(b2);
2414  		gen_and(b1, b2);
2415  		gen_or(b0, b2);
2416  		b1 = gen_bcmp(cstate, OR_LINKHDR, 10, 6, eaddr);
2417  		gen_and(b2, b1);
2418  		return b1;
2419  	case Q_ADDR3:
2420  		b0 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_TYPE_CTL,
2421  			IEEE80211_FC0_TYPE_MASK);
2422  		gen_not(b0);
2423  		b1 = gen_bcmp(cstate, OR_LINKHDR, 16, 6, eaddr);
2424  		gen_and(b0, b1);
2425  		return b1;
2426  	case Q_ADDR4:
2427  		b0 = gen_mcmp(cstate, OR_LINKHDR, 1, BPF_B,
2428  			IEEE80211_FC1_DIR_DSTODS, IEEE80211_FC1_DIR_MASK);
2429  		b1 = gen_bcmp(cstate, OR_LINKHDR, 24, 6, eaddr);
2430  		gen_and(b0, b1);
2431  		return b1;
2432  	case Q_RA:
2433  		s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
2434  		b1 = new_block(cstate, JMP(BPF_JSET));
2435  		b1->s.k = 0x08;
2436  		b1->stmts = s;
2437  		b0 = gen_bcmp(cstate, OR_LINKHDR, 4, 6, eaddr);
2438  		gen_and(b1, b0);
2439  		return (b0);
2440  	case Q_TA:
2441  		b0 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_TYPE_CTL,
2442  			IEEE80211_FC0_TYPE_MASK);
2443  		gen_not(b0);
2444  		b1 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_SUBTYPE_CTS,
2445  			IEEE80211_FC0_SUBTYPE_MASK);
2446  		gen_not(b1);
2447  		b2 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_SUBTYPE_ACK,
2448  			IEEE80211_FC0_SUBTYPE_MASK);
2449  		gen_not(b2);
2450  		gen_and(b1, b2);
2451  		gen_or(b0, b2);
2452  		s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
2453  		b1 = new_block(cstate, JMP(BPF_JSET));
2454  		b1->s.k = 0x08;
2455  		b1->stmts = s;
2456  		gen_and(b1, b2);
2457  		b1 = gen_bcmp(cstate, OR_LINKHDR, 10, 6, eaddr);
2458  		gen_and(b2, b1);
2459  		return b1;
2460  	}
2461  	abort();
2462  }
2463  static struct block *
2464  gen_ipfchostop(compiler_state_t *cstate, const u_char *eaddr, int dir)
2465  {
2466  	register struct block *b0, *b1;
2467  	switch (dir) {
2468  	case Q_SRC:
2469  		return gen_bcmp(cstate, OR_LINKHDR, 10, 6, eaddr);
2470  	case Q_DST:
2471  		return gen_bcmp(cstate, OR_LINKHDR, 2, 6, eaddr);
2472  	case Q_AND:
2473  		b0 = gen_ipfchostop(cstate, eaddr, Q_SRC);
2474  		b1 = gen_ipfchostop(cstate, eaddr, Q_DST);
2475  		gen_and(b0, b1);
2476  		return b1;
2477  	case Q_DEFAULT:
2478  	case Q_OR:
2479  		b0 = gen_ipfchostop(cstate, eaddr, Q_SRC);
2480  		b1 = gen_ipfchostop(cstate, eaddr, Q_DST);
2481  		gen_or(b0, b1);
2482  		return b1;
2483  	case Q_ADDR1:
2484  		bpf_error(cstate, "'addr1' and 'address1' are only supported on 802.11");
2485  	case Q_ADDR2:
2486  		bpf_error(cstate, "'addr2' and 'address2' are only supported on 802.11");
2487  	case Q_ADDR3:
2488  		bpf_error(cstate, "'addr3' and 'address3' are only supported on 802.11");
2489  	case Q_ADDR4:
2490  		bpf_error(cstate, "'addr4' and 'address4' are only supported on 802.11");
2491  	case Q_RA:
2492  		bpf_error(cstate, "'ra' is only supported on 802.11");
2493  	case Q_TA:
2494  		bpf_error(cstate, "'ta' is only supported on 802.11");
2495  	}
2496  	abort();
2497  }
2498  static struct block *
2499  gen_dnhostop(compiler_state_t *cstate, bpf_u_int32 addr, int dir)
2500  {
2501  	struct block *b0, *b1, *b2, *tmp;
2502  	u_int offset_lh;	&bsol;* offset if long header is received */
2503  	u_int offset_sh;	&bsol;* offset if short header is received */
2504  	switch (dir) {
2505  	case Q_DST:
2506  		offset_sh = 1;	&bsol;* follows flags */
2507  		offset_lh = 7;	&bsol;* flgs,darea,dsubarea,HIORD */
2508  		break;
2509  	case Q_SRC:
2510  		offset_sh = 3;	&bsol;* follows flags, dstnode */
2511  		offset_lh = 15;	&bsol;* flgs,darea,dsubarea,did,sarea,ssub,HIORD */
2512  		break;
2513  	case Q_AND:
2514  		b0 = gen_dnhostop(cstate, addr, Q_SRC);
2515  		b1 = gen_dnhostop(cstate, addr, Q_DST);
2516  		gen_and(b0, b1);
2517  		return b1;
2518  	case Q_DEFAULT:
2519  	case Q_OR:
2520  		b0 = gen_dnhostop(cstate, addr, Q_SRC);
2521  		b1 = gen_dnhostop(cstate, addr, Q_DST);
2522  		gen_or(b0, b1);
2523  		return b1;
2524  	case Q_ADDR1:
2525  		bpf_error(cstate, "'addr1' and 'address1' are not valid qualifiers for addresses other than 802.11 MAC addresses");
2526  	case Q_ADDR2:
2527  		bpf_error(cstate, "'addr2' and 'address2' are not valid qualifiers for addresses other than 802.11 MAC addresses");
2528  	case Q_ADDR3:
2529  		bpf_error(cstate, "'addr3' and 'address3' are not valid qualifiers for addresses other than 802.11 MAC addresses");
2530  	case Q_ADDR4:
2531  		bpf_error(cstate, "'addr4' and 'address4' are not valid qualifiers for addresses other than 802.11 MAC addresses");
2532  	case Q_RA:
2533  		bpf_error(cstate, "'ra' is not a valid qualifier for addresses other than 802.11 MAC addresses");
2534  	case Q_TA:
2535  		bpf_error(cstate, "'ta' is not a valid qualifier for addresses other than 802.11 MAC addresses");
2536  	default:
2537  		abort();
2538  	}
2539  	b0 = gen_linktype(cstate, ETHERTYPE_DN);
2540  	tmp = gen_mcmp(cstate, OR_LINKPL, 2, BPF_H,
2541  	    (bpf_u_int32)ntohs(0x0681), (bpf_u_int32)ntohs(0x07FF));
2542  	b1 = gen_cmp(cstate, OR_LINKPL, 2 + 1 + offset_lh,
2543  	    BPF_H, (bpf_u_int32)ntohs((u_short)addr));
2544  	gen_and(tmp, b1);
2545  	tmp = gen_mcmp(cstate, OR_LINKPL, 2, BPF_B, (bpf_u_int32)0x06,
2546  	    (bpf_u_int32)0x7);
2547  	b2 = gen_cmp(cstate, OR_LINKPL, 2 + offset_lh, BPF_H,
2548  	    (bpf_u_int32)ntohs((u_short)addr));
2549  	gen_and(tmp, b2);
2550  	gen_or(b2, b1);
2551  	tmp = gen_mcmp(cstate, OR_LINKPL, 2, BPF_H,
2552  	    (bpf_u_int32)ntohs(0x0281), (bpf_u_int32)ntohs(0x07FF));
2553  	b2 = gen_cmp(cstate, OR_LINKPL, 2 + 1 + offset_sh, BPF_H,
2554  	    (bpf_u_int32)ntohs((u_short)addr));
2555  	gen_and(tmp, b2);
2556  	gen_or(b2, b1);
2557  	tmp = gen_mcmp(cstate, OR_LINKPL, 2, BPF_B, (bpf_u_int32)0x02,
2558  	    (bpf_u_int32)0x7);
2559  	b2 = gen_cmp(cstate, OR_LINKPL, 2 + offset_sh, BPF_H,
2560  	    (bpf_u_int32)ntohs((u_short)addr));
2561  	gen_and(tmp, b2);
2562  	gen_or(b2, b1);
2563  	gen_and(b0, b1);
2564  	return b1;
2565  }
2566  static struct block *
2567  gen_mpls_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)
2568  {
2569  	struct block *b0, *b1;
2570          switch (ll_proto) {
2571          case ETHERTYPE_IP:
2572                  b0 = gen_mcmp(cstate, OR_LINKPL, (u_int)-2, BPF_B, 0x01, 0x01);
2573                  b1 = gen_mcmp(cstate, OR_LINKPL, 0, BPF_B, 0x40, 0xf0);
2574                  gen_and(b0, b1);
2575                  return b1;
2576          case ETHERTYPE_IPV6:
2577                  b0 = gen_mcmp(cstate, OR_LINKPL, (u_int)-2, BPF_B, 0x01, 0x01);
2578                  b1 = gen_mcmp(cstate, OR_LINKPL, 0, BPF_B, 0x60, 0xf0);
2579                  gen_and(b0, b1);
2580                  return b1;
2581          default:
2582                 bpf_error(cstate, "unsupported protocol over mpls");
2583          }
2584  }
2585  static struct block *
2586  gen_host(compiler_state_t *cstate, bpf_u_int32 addr, bpf_u_int32 mask,
2587      int proto, int dir, int type)
2588  {
2589  	struct block *b0, *b1;
2590  	const char *typestr;
2591  	if (type == Q_NET)
2592  		typestr = "net";
2593  	else
2594  		typestr = "host";
2595  	switch (proto) {
2596  	case Q_DEFAULT:
2597  		b0 = gen_host(cstate, addr, mask, Q_IP, dir, type);
2598  		if (cstate->label_stack_depth == 0) {
2599  			b1 = gen_host(cstate, addr, mask, Q_ARP, dir, type);
2600  			gen_or(b0, b1);
2601  			b0 = gen_host(cstate, addr, mask, Q_RARP, dir, type);
2602  			gen_or(b1, b0);
2603  		}
2604  		return b0;
2605  	case Q_LINK:
2606  		bpf_error(cstate, "link-layer modifier applied to %s", typestr);
2607  	case Q_IP:
2608  		return gen_hostop(cstate, addr, mask, dir, ETHERTYPE_IP, 12, 16);
2609  	case Q_RARP:
2610  		return gen_hostop(cstate, addr, mask, dir, ETHERTYPE_REVARP, 14, 24);
2611  	case Q_ARP:
2612  		return gen_hostop(cstate, addr, mask, dir, ETHERTYPE_ARP, 14, 24);
2613  	case Q_SCTP:
2614  		bpf_error(cstate, "'sctp' modifier applied to %s", typestr);
2615  	case Q_TCP:
2616  		bpf_error(cstate, "'tcp' modifier applied to %s", typestr);
2617  	case Q_UDP:
2618  		bpf_error(cstate, "'udp' modifier applied to %s", typestr);
2619  	case Q_ICMP:
2620  		bpf_error(cstate, "'icmp' modifier applied to %s", typestr);
2621  	case Q_IGMP:
2622  		bpf_error(cstate, "'igmp' modifier applied to %s", typestr);
2623  	case Q_IGRP:
2624  		bpf_error(cstate, "'igrp' modifier applied to %s", typestr);
2625  	case Q_ATALK:
2626  		bpf_error(cstate, "AppleTalk host filtering not implemented");
2627  	case Q_DECNET:
2628  		return gen_dnhostop(cstate, addr, dir);
2629  	case Q_LAT:
2630  		bpf_error(cstate, "LAT host filtering not implemented");
2631  	case Q_SCA:
2632  		bpf_error(cstate, "SCA host filtering not implemented");
2633  	case Q_MOPRC:
2634  		bpf_error(cstate, "MOPRC host filtering not implemented");
2635  	case Q_MOPDL:
2636  		bpf_error(cstate, "MOPDL host filtering not implemented");
2637  	case Q_IPV6:
2638  		bpf_error(cstate, "'ip6' modifier applied to ip host");
2639  	case Q_ICMPV6:
2640  		bpf_error(cstate, "'icmp6' modifier applied to %s", typestr);
2641  	case Q_AH:
2642  		bpf_error(cstate, "'ah' modifier applied to %s", typestr);
2643  	case Q_ESP:
2644  		bpf_error(cstate, "'esp' modifier applied to %s", typestr);
2645  	case Q_PIM:
2646  		bpf_error(cstate, "'pim' modifier applied to %s", typestr);
2647  	case Q_VRRP:
2648  		bpf_error(cstate, "'vrrp' modifier applied to %s", typestr);
2649  	case Q_AARP:
2650  		bpf_error(cstate, "AARP host filtering not implemented");
2651  	case Q_ISO:
2652  		bpf_error(cstate, "ISO host filtering not implemented");
2653  	case Q_ESIS:
2654  		bpf_error(cstate, "'esis' modifier applied to %s", typestr);
2655  	case Q_ISIS:
2656  		bpf_error(cstate, "'isis' modifier applied to %s", typestr);
2657  	case Q_CLNP:
2658  		bpf_error(cstate, "'clnp' modifier applied to %s", typestr);
2659  	case Q_STP:
2660  		bpf_error(cstate, "'stp' modifier applied to %s", typestr);
2661  	case Q_IPX:
2662  		bpf_error(cstate, "IPX host filtering not implemented");
2663  	case Q_NETBEUI:
2664  		bpf_error(cstate, "'netbeui' modifier applied to %s", typestr);
2665  	case Q_ISIS_L1:
2666  		bpf_error(cstate, "'l1' modifier applied to %s", typestr);
2667  	case Q_ISIS_L2:
2668  		bpf_error(cstate, "'l2' modifier applied to %s", typestr);
2669  	case Q_ISIS_IIH:
2670  		bpf_error(cstate, "'iih' modifier applied to %s", typestr);
2671  	case Q_ISIS_SNP:
2672  		bpf_error(cstate, "'snp' modifier applied to %s", typestr);
2673  	case Q_ISIS_CSNP:
2674  		bpf_error(cstate, "'csnp' modifier applied to %s", typestr);
2675  	case Q_ISIS_PSNP:
2676  		bpf_error(cstate, "'psnp' modifier applied to %s", typestr);
2677  	case Q_ISIS_LSP:
2678  		bpf_error(cstate, "'lsp' modifier applied to %s", typestr);
2679  	case Q_RADIO:
2680  		bpf_error(cstate, "'radio' modifier applied to %s", typestr);
2681  	case Q_CARP:
2682  		bpf_error(cstate, "'carp' modifier applied to %s", typestr);
2683  	default:
2684  		abort();
2685  	}
2686  }
2687  #ifdef INET6
2688  static struct block *
2689  gen_host6(compiler_state_t *cstate, struct in6_addr *addr,
2690      struct in6_addr *mask, int proto, int dir, int type)
2691  {
2692  	const char *typestr;
2693  	if (type == Q_NET)
2694  		typestr = "net";
2695  	else
2696  		typestr = "host";
2697  	switch (proto) {
2698  	case Q_DEFAULT:
2699  		return gen_host6(cstate, addr, mask, Q_IPV6, dir, type);
2700  	case Q_LINK:
2701  		bpf_error(cstate, "link-layer modifier applied to ip6 %s", typestr);
2702  	case Q_IP:
2703  		bpf_error(cstate, "'ip' modifier applied to ip6 %s", typestr);
2704  	case Q_RARP:
2705  		bpf_error(cstate, "'rarp' modifier applied to ip6 %s", typestr);
2706  	case Q_ARP:
2707  		bpf_error(cstate, "'arp' modifier applied to ip6 %s", typestr);
2708  	case Q_SCTP:
2709  		bpf_error(cstate, "'sctp' modifier applied to ip6 %s", typestr);
2710  	case Q_TCP:
2711  		bpf_error(cstate, "'tcp' modifier applied to ip6 %s", typestr);
2712  	case Q_UDP:
2713  		bpf_error(cstate, "'udp' modifier applied to ip6 %s", typestr);
2714  	case Q_ICMP:
2715  		bpf_error(cstate, "'icmp' modifier applied to ip6 %s", typestr);
2716  	case Q_IGMP:
2717  		bpf_error(cstate, "'igmp' modifier applied to ip6 %s", typestr);
2718  	case Q_IGRP:
2719  		bpf_error(cstate, "'igrp' modifier applied to ip6 %s", typestr);
2720  	case Q_ATALK:
2721  		bpf_error(cstate, "AppleTalk modifier applied to ip6 %s", typestr);
2722  	case Q_DECNET:
2723  		bpf_error(cstate, "'decnet' modifier applied to ip6 %s", typestr);
2724  	case Q_LAT:
2725  		bpf_error(cstate, "'lat' modifier applied to ip6 %s", typestr);
2726  	case Q_SCA:
2727  		bpf_error(cstate, "'sca' modifier applied to ip6 %s", typestr);
2728  	case Q_MOPRC:
2729  		bpf_error(cstate, "'moprc' modifier applied to ip6 %s", typestr);
2730  	case Q_MOPDL:
2731  		bpf_error(cstate, "'mopdl' modifier applied to ip6 %s", typestr);
2732  	case Q_IPV6:
2733  		return gen_hostop6(cstate, addr, mask, dir, ETHERTYPE_IPV6, 8, 24);
2734  	case Q_ICMPV6:
2735  		bpf_error(cstate, "'icmp6' modifier applied to ip6 %s", typestr);
2736  	case Q_AH:
2737  		bpf_error(cstate, "'ah' modifier applied to ip6 %s", typestr);
2738  	case Q_ESP:
2739  		bpf_error(cstate, "'esp' modifier applied to ip6 %s", typestr);
2740  	case Q_PIM:
2741  		bpf_error(cstate, "'pim' modifier applied to ip6 %s", typestr);
2742  	case Q_VRRP:
2743  		bpf_error(cstate, "'vrrp' modifier applied to ip6 %s", typestr);
2744  	case Q_AARP:
2745  		bpf_error(cstate, "'aarp' modifier applied to ip6 %s", typestr);
2746  	case Q_ISO:
2747  		bpf_error(cstate, "'iso' modifier applied to ip6 %s", typestr);
2748  	case Q_ESIS:
2749  		bpf_error(cstate, "'esis' modifier applied to ip6 %s", typestr);
2750  	case Q_ISIS:
2751  		bpf_error(cstate, "'isis' modifier applied to ip6 %s", typestr);
2752  	case Q_CLNP:
2753  		bpf_error(cstate, "'clnp' modifier applied to ip6 %s", typestr);
2754  	case Q_STP:
2755  		bpf_error(cstate, "'stp' modifier applied to ip6 %s", typestr);
2756  	case Q_IPX:
2757  		bpf_error(cstate, "'ipx' modifier applied to ip6 %s", typestr);
2758  	case Q_NETBEUI:
2759  		bpf_error(cstate, "'netbeui' modifier applied to ip6 %s", typestr);
2760  	case Q_ISIS_L1:
2761  		bpf_error(cstate, "'l1' modifier applied to ip6 %s", typestr);
2762  	case Q_ISIS_L2:
2763  		bpf_error(cstate, "'l2' modifier applied to ip6 %s", typestr);
2764  	case Q_ISIS_IIH:
2765  		bpf_error(cstate, "'iih' modifier applied to ip6 %s", typestr);
2766  	case Q_ISIS_SNP:
2767  		bpf_error(cstate, "'snp' modifier applied to ip6 %s", typestr);
2768  	case Q_ISIS_CSNP:
2769  		bpf_error(cstate, "'csnp' modifier applied to ip6 %s", typestr);
2770  	case Q_ISIS_PSNP:
2771  		bpf_error(cstate, "'psnp' modifier applied to ip6 %s", typestr);
2772  	case Q_ISIS_LSP:
2773  		bpf_error(cstate, "'lsp' modifier applied to ip6 %s", typestr);
2774  	case Q_RADIO:
2775  		bpf_error(cstate, "'radio' modifier applied to ip6 %s", typestr);
2776  	case Q_CARP:
2777  		bpf_error(cstate, "'carp' modifier applied to ip6 %s", typestr);
2778  	default:
2779  		abort();
2780  	}
2781  }
2782  #endif
2783  #ifndef INET6
2784  static struct block *
2785  gen_gateway(compiler_state_t *cstate, const u_char *eaddr,
2786      struct addrinfo *alist, int proto, int dir)
2787  {
2788  	struct block *b0, *b1, *tmp;
2789  	struct addrinfo *ai;
2790  	struct sockaddr_in *sin;
2791  	if (dir != 0)
2792  		bpf_error(cstate, "direction applied to 'gateway'");
2793  	switch (proto) {
2794  	case Q_DEFAULT:
2795  	case Q_IP:
2796  	case Q_ARP:
2797  	case Q_RARP:
2798  		switch (cstate->linktype) {
2799  		case DLT_EN10MB:
2800  		case DLT_NETANALYZER:
2801  		case DLT_NETANALYZER_TRANSPARENT:
2802  			b1 = gen_prevlinkhdr_check(cstate);
2803  			b0 = gen_ehostop(cstate, eaddr, Q_OR);
2804  			if (b1 != NULL)
2805  				gen_and(b1, b0);
2806  			break;
2807  		case DLT_FDDI:
2808  			b0 = gen_fhostop(cstate, eaddr, Q_OR);
2809  			break;
2810  		case DLT_IEEE802:
2811  			b0 = gen_thostop(cstate, eaddr, Q_OR);
2812  			break;
2813  		case DLT_IEEE802_11:
2814  		case DLT_PRISM_HEADER:
2815  		case DLT_IEEE802_11_RADIO_AVS:
2816  		case DLT_IEEE802_11_RADIO:
2817  		case DLT_PPI:
2818  			b0 = gen_wlanhostop(cstate, eaddr, Q_OR);
2819  			break;
2820  		case DLT_SUNATM:
2821  			bpf_error(cstate,
2822  			    "'gateway' supported only on ethernet/FDDI/token ring/802.11/ATM LANE/Fibre Channel");
2823  			break;
2824  		case DLT_IP_OVER_FC:
2825  			b0 = gen_ipfchostop(cstate, eaddr, Q_OR);
2826  			break;
2827  		default:
2828  			bpf_error(cstate,
2829  			    "'gateway' supported only on ethernet/FDDI/token ring/802.11/ATM LANE/Fibre Channel");
2830  		}
2831  		b1 = NULL;
2832  		for (ai = alist; ai != NULL; ai = ai->ai_next) {
2833  			if (ai->ai_addr != NULL) {
2834  				if (ai->ai_addr->sa_family == AF_INET) {
2835  					sin = (struct sockaddr_in *)ai->ai_addr;
2836  					tmp = gen_host(cstate,
2837  					    ntohl(sin->sin_addr.s_addr),
2838  					    0xffffffff, proto, Q_OR, Q_HOST);
2839  					if (b1 == NULL) {
2840  						b1 = tmp;
2841  					} else {
2842  						gen_or(b1, tmp);
2843  						b1 = tmp;
2844  					}
2845  				}
2846  			}
2847  		}
2848  		if (b1 == NULL) {
2849  			return (NULL);
2850  		}
2851  		gen_not(b1);
2852  		gen_and(b0, b1);
2853  		return b1;
2854  	}
2855  	bpf_error(cstate, "illegal modifier of 'gateway'");
2856  }
2857  #endif
2858  static struct block *
2859  gen_proto_abbrev_internal(compiler_state_t *cstate, int proto)
2860  {
2861  	struct block *b0;
2862  	struct block *b1;
2863  	switch (proto) {
2864  	case Q_SCTP:
2865  		b1 = gen_proto(cstate, IPPROTO_SCTP, Q_DEFAULT, Q_DEFAULT);
2866  		break;
2867  	case Q_TCP:
2868  		b1 = gen_proto(cstate, IPPROTO_TCP, Q_DEFAULT, Q_DEFAULT);
2869  		break;
2870  	case Q_UDP:
2871  		b1 = gen_proto(cstate, IPPROTO_UDP, Q_DEFAULT, Q_DEFAULT);
2872  		break;
2873  	case Q_ICMP:
2874  		b1 = gen_proto(cstate, IPPROTO_ICMP, Q_IP, Q_DEFAULT);
2875  		break;
2876  #ifndef	IPPROTO_IGMP
2877  #define	IPPROTO_IGMP	2
2878  #endif
2879  	case Q_IGMP:
2880  		b1 = gen_proto(cstate, IPPROTO_IGMP, Q_IP, Q_DEFAULT);
2881  		break;
2882  #ifndef	IPPROTO_IGRP
2883  #define	IPPROTO_IGRP	9
2884  #endif
2885  	case Q_IGRP:
2886  		b1 = gen_proto(cstate, IPPROTO_IGRP, Q_IP, Q_DEFAULT);
2887  		break;
2888  #ifndef IPPROTO_PIM
2889  #define IPPROTO_PIM	103
2890  #endif
2891  	case Q_PIM:
2892  		b1 = gen_proto(cstate, IPPROTO_PIM, Q_DEFAULT, Q_DEFAULT);
2893  		break;
2894  #ifndef IPPROTO_VRRP
2895  #define IPPROTO_VRRP	112
2896  #endif
2897  	case Q_VRRP:
2898  		b1 = gen_proto(cstate, IPPROTO_VRRP, Q_IP, Q_DEFAULT);
2899  		break;
2900  #ifndef IPPROTO_CARP
2901  #define IPPROTO_CARP	112
2902  #endif
2903  	case Q_CARP:
2904  		b1 = gen_proto(cstate, IPPROTO_CARP, Q_IP, Q_DEFAULT);
2905  		break;
2906  	case Q_IP:
2907  		b1 = gen_linktype(cstate, ETHERTYPE_IP);
2908  		break;
2909  	case Q_ARP:
2910  		b1 = gen_linktype(cstate, ETHERTYPE_ARP);
2911  		break;
2912  	case Q_RARP:
2913  		b1 = gen_linktype(cstate, ETHERTYPE_REVARP);
2914  		break;
2915  	case Q_LINK:
2916  		bpf_error(cstate, "link layer applied in wrong context");
2917  	case Q_ATALK:
2918  		b1 = gen_linktype(cstate, ETHERTYPE_ATALK);
2919  		break;
2920  	case Q_AARP:
2921  		b1 = gen_linktype(cstate, ETHERTYPE_AARP);
2922  		break;
2923  	case Q_DECNET:
2924  		b1 = gen_linktype(cstate, ETHERTYPE_DN);
2925  		break;
2926  	case Q_SCA:
2927  		b1 = gen_linktype(cstate, ETHERTYPE_SCA);
2928  		break;
2929  	case Q_LAT:
2930  		b1 = gen_linktype(cstate, ETHERTYPE_LAT);
2931  		break;
2932  	case Q_MOPDL:
2933  		b1 = gen_linktype(cstate, ETHERTYPE_MOPDL);
2934  		break;
2935  	case Q_MOPRC:
2936  		b1 = gen_linktype(cstate, ETHERTYPE_MOPRC);
2937  		break;
2938  	case Q_IPV6:
2939  		b1 = gen_linktype(cstate, ETHERTYPE_IPV6);
2940  		break;
2941  #ifndef IPPROTO_ICMPV6
2942  #define IPPROTO_ICMPV6	58
2943  #endif
2944  	case Q_ICMPV6:
2945  		b1 = gen_proto(cstate, IPPROTO_ICMPV6, Q_IPV6, Q_DEFAULT);
2946  		break;
2947  #ifndef IPPROTO_AH
2948  #define IPPROTO_AH	51
2949  #endif
2950  	case Q_AH:
2951  		b1 = gen_proto(cstate, IPPROTO_AH, Q_DEFAULT, Q_DEFAULT);
2952  		break;
2953  #ifndef IPPROTO_ESP
2954  #define IPPROTO_ESP	50
2955  #endif
2956  	case Q_ESP:
2957  		b1 = gen_proto(cstate, IPPROTO_ESP, Q_DEFAULT, Q_DEFAULT);
2958  		break;
2959  	case Q_ISO:
2960  		b1 = gen_linktype(cstate, LLCSAP_ISONS);
2961  		break;
2962  	case Q_ESIS:
2963  		b1 = gen_proto(cstate, ISO9542_ESIS, Q_ISO, Q_DEFAULT);
2964  		break;
2965  	case Q_ISIS:
2966  		b1 = gen_proto(cstate, ISO10589_ISIS, Q_ISO, Q_DEFAULT);
2967  		break;
2968  	case Q_ISIS_L1: &bsol;* all IS-IS Level1 PDU-Types */
2969  		b0 = gen_proto(cstate, ISIS_L1_LAN_IIH, Q_ISIS, Q_DEFAULT);
2970  		b1 = gen_proto(cstate, ISIS_PTP_IIH, Q_ISIS, Q_DEFAULT); &bsol;* FIXME extract the circuit-type bits */
2971  		gen_or(b0, b1);
2972  		b0 = gen_proto(cstate, ISIS_L1_LSP, Q_ISIS, Q_DEFAULT);
2973  		gen_or(b0, b1);
2974  		b0 = gen_proto(cstate, ISIS_L1_CSNP, Q_ISIS, Q_DEFAULT);
2975  		gen_or(b0, b1);
2976  		b0 = gen_proto(cstate, ISIS_L1_PSNP, Q_ISIS, Q_DEFAULT);
2977  		gen_or(b0, b1);
2978  		break;
2979  	case Q_ISIS_L2: &bsol;* all IS-IS Level2 PDU-Types */
2980  		b0 = gen_proto(cstate, ISIS_L2_LAN_IIH, Q_ISIS, Q_DEFAULT);
2981  		b1 = gen_proto(cstate, ISIS_PTP_IIH, Q_ISIS, Q_DEFAULT); &bsol;* FIXME extract the circuit-type bits */
2982  		gen_or(b0, b1);
2983  		b0 = gen_proto(cstate, ISIS_L2_LSP, Q_ISIS, Q_DEFAULT);
2984  		gen_or(b0, b1);
2985  		b0 = gen_proto(cstate, ISIS_L2_CSNP, Q_ISIS, Q_DEFAULT);
2986  		gen_or(b0, b1);
2987  		b0 = gen_proto(cstate, ISIS_L2_PSNP, Q_ISIS, Q_DEFAULT);
2988  		gen_or(b0, b1);
2989  		break;
2990  	case Q_ISIS_IIH: &bsol;* all IS-IS Hello PDU-Types */
2991  		b0 = gen_proto(cstate, ISIS_L1_LAN_IIH, Q_ISIS, Q_DEFAULT);
2992  		b1 = gen_proto(cstate, ISIS_L2_LAN_IIH, Q_ISIS, Q_DEFAULT);
2993  		gen_or(b0, b1);
2994  		b0 = gen_proto(cstate, ISIS_PTP_IIH, Q_ISIS, Q_DEFAULT);
2995  		gen_or(b0, b1);
2996  		break;
2997  	case Q_ISIS_LSP:
2998  		b0 = gen_proto(cstate, ISIS_L1_LSP, Q_ISIS, Q_DEFAULT);
2999  		b1 = gen_proto(cstate, ISIS_L2_LSP, Q_ISIS, Q_DEFAULT);
3000  		gen_or(b0, b1);
3001  		break;
3002  	case Q_ISIS_SNP:
3003  		b0 = gen_proto(cstate, ISIS_L1_CSNP, Q_ISIS, Q_DEFAULT);
3004  		b1 = gen_proto(cstate, ISIS_L2_CSNP, Q_ISIS, Q_DEFAULT);
3005  		gen_or(b0, b1);
3006  		b0 = gen_proto(cstate, ISIS_L1_PSNP, Q_ISIS, Q_DEFAULT);
3007  		gen_or(b0, b1);
3008  		b0 = gen_proto(cstate, ISIS_L2_PSNP, Q_ISIS, Q_DEFAULT);
3009  		gen_or(b0, b1);
3010  		break;
3011  	case Q_ISIS_CSNP:
3012  		b0 = gen_proto(cstate, ISIS_L1_CSNP, Q_ISIS, Q_DEFAULT);
3013  		b1 = gen_proto(cstate, ISIS_L2_CSNP, Q_ISIS, Q_DEFAULT);
3014  		gen_or(b0, b1);
3015  		break;
3016  	case Q_ISIS_PSNP:
3017  		b0 = gen_proto(cstate, ISIS_L1_PSNP, Q_ISIS, Q_DEFAULT);
3018  		b1 = gen_proto(cstate, ISIS_L2_PSNP, Q_ISIS, Q_DEFAULT);
3019  		gen_or(b0, b1);
3020  		break;
3021  	case Q_CLNP:
3022  		b1 = gen_proto(cstate, ISO8473_CLNP, Q_ISO, Q_DEFAULT);
3023  		break;
3024  	case Q_STP:
3025  		b1 = gen_linktype(cstate, LLCSAP_8021D);
3026  		break;
3027  	case Q_IPX:
3028  		b1 = gen_linktype(cstate, LLCSAP_IPX);
3029  		break;
3030  	case Q_NETBEUI:
3031  		b1 = gen_linktype(cstate, LLCSAP_NETBEUI);
3032  		break;
3033  	case Q_RADIO:
3034  		bpf_error(cstate, "'radio' is not a valid protocol type");
3035  	default:
3036  		abort();
3037  	}
3038  	return b1;
3039  }
3040  struct block *
3041  gen_proto_abbrev(compiler_state_t *cstate, int proto)
3042  {
3043  	if (setjmp(cstate->top_ctx))
3044  		return (NULL);
3045  	return gen_proto_abbrev_internal(cstate, proto);
3046  }
3047  static struct block *
3048  gen_ipfrag(compiler_state_t *cstate)
3049  {
3050  	struct slist *s;
3051  	struct block *b;
3052  	s = gen_load_a(cstate, OR_LINKPL, 6, BPF_H);
3053  	b = new_block(cstate, JMP(BPF_JSET));
3054  	b->s.k = 0x1fff;
3055  	b->stmts = s;
3056  	gen_not(b);
3057  	return b;
3058  }
3059  static struct block *
3060  gen_portatom(compiler_state_t *cstate, int off, bpf_u_int32 v)
3061  {
3062  	return gen_cmp(cstate, OR_TRAN_IPV4, off, BPF_H, v);
3063  }
3064  static struct block *
3065  gen_portatom6(compiler_state_t *cstate, int off, bpf_u_int32 v)
3066  {
3067  	return gen_cmp(cstate, OR_TRAN_IPV6, off, BPF_H, v);
3068  }
3069  static struct block *
3070  gen_portop(compiler_state_t *cstate, u_int port, u_int proto, int dir)
3071  {
3072  	struct block *b0, *b1, *tmp;
3073  	tmp = gen_cmp(cstate, OR_LINKPL, 9, BPF_B, proto);
3074  	b0 = gen_ipfrag(cstate);
3075  	gen_and(tmp, b0);
3076  	switch (dir) {
3077  	case Q_SRC:
3078  		b1 = gen_portatom(cstate, 0, port);
3079  		break;
3080  	case Q_DST:
3081  		b1 = gen_portatom(cstate, 2, port);
3082  		break;
3083  	case Q_AND:
3084  		tmp = gen_portatom(cstate, 0, port);
3085  		b1 = gen_portatom(cstate, 2, port);
3086  		gen_and(tmp, b1);
3087  		break;
3088  	case Q_DEFAULT:
3089  	case Q_OR:
3090  		tmp = gen_portatom(cstate, 0, port);
3091  		b1 = gen_portatom(cstate, 2, port);
3092  		gen_or(tmp, b1);
3093  		break;
3094  	case Q_ADDR1:
3095  		bpf_error(cstate, "'addr1' and 'address1' are not valid qualifiers for ports");
3096  	case Q_ADDR2:
3097  		bpf_error(cstate, "'addr2' and 'address2' are not valid qualifiers for ports");
3098  	case Q_ADDR3:
3099  		bpf_error(cstate, "'addr3' and 'address3' are not valid qualifiers for ports");
3100  	case Q_ADDR4:
3101  		bpf_error(cstate, "'addr4' and 'address4' are not valid qualifiers for ports");
3102  	case Q_RA:
3103  		bpf_error(cstate, "'ra' is not a valid qualifier for ports");
3104  	case Q_TA:
3105  		bpf_error(cstate, "'ta' is not a valid qualifier for ports");
3106  	default:
3107  		abort();
3108  	}
3109  	gen_and(b0, b1);
3110  	return b1;
3111  }
3112  static struct block *
3113  gen_port(compiler_state_t *cstate, u_int port, int ip_proto, int dir)
3114  {
3115  	struct block *b0, *b1, *tmp;
3116  	b0 = gen_linktype(cstate, ETHERTYPE_IP);
3117  	switch (ip_proto) {
3118  	case IPPROTO_UDP:
3119  	case IPPROTO_TCP:
3120  	case IPPROTO_SCTP:
3121  		b1 = gen_portop(cstate, port, (u_int)ip_proto, dir);
3122  		break;
3123  	case PROTO_UNDEF:
3124  		tmp = gen_portop(cstate, port, IPPROTO_TCP, dir);
3125  		b1 = gen_portop(cstate, port, IPPROTO_UDP, dir);
3126  		gen_or(tmp, b1);
3127  		tmp = gen_portop(cstate, port, IPPROTO_SCTP, dir);
3128  		gen_or(tmp, b1);
3129  		break;
3130  	default:
3131  		abort();
3132  	}
3133  	gen_and(b0, b1);
3134  	return b1;
3135  }
3136  struct block *
3137  gen_portop6(compiler_state_t *cstate, u_int port, u_int proto, int dir)
3138  {
3139  	struct block *b0, *b1, *tmp;
3140  	b0 = gen_cmp(cstate, OR_LINKPL, 6, BPF_B, proto);
3141  	switch (dir) {
3142  	case Q_SRC:
3143  		b1 = gen_portatom6(cstate, 0, port);
3144  		break;
3145  	case Q_DST:
3146  		b1 = gen_portatom6(cstate, 2, port);
3147  		break;
3148  	case Q_AND:
3149  		tmp = gen_portatom6(cstate, 0, port);
3150  		b1 = gen_portatom6(cstate, 2, port);
3151  		gen_and(tmp, b1);
3152  		break;
3153  	case Q_DEFAULT:
3154  	case Q_OR:
3155  		tmp = gen_portatom6(cstate, 0, port);
3156  		b1 = gen_portatom6(cstate, 2, port);
3157  		gen_or(tmp, b1);
3158  		break;
3159  	default:
3160  		abort();
3161  	}
3162  	gen_and(b0, b1);
3163  	return b1;
3164  }
3165  static struct block *
3166  gen_port6(compiler_state_t *cstate, u_int port, int ip_proto, int dir)
3167  {
3168  	struct block *b0, *b1, *tmp;
3169  	b0 = gen_linktype(cstate, ETHERTYPE_IPV6);
3170  	switch (ip_proto) {
3171  	case IPPROTO_UDP:
3172  	case IPPROTO_TCP:
3173  	case IPPROTO_SCTP:
3174  		b1 = gen_portop6(cstate, port, (u_int)ip_proto, dir);
3175  		break;
3176  	case PROTO_UNDEF:
3177  		tmp = gen_portop6(cstate, port, IPPROTO_TCP, dir);
3178  		b1 = gen_portop6(cstate, port, IPPROTO_UDP, dir);
3179  		gen_or(tmp, b1);
3180  		tmp = gen_portop6(cstate, port, IPPROTO_SCTP, dir);
3181  		gen_or(tmp, b1);
3182  		break;
3183  	default:
3184  		abort();
3185  	}
3186  	gen_and(b0, b1);
3187  	return b1;
3188  }
3189  static struct block *
3190  gen_portrangeatom(compiler_state_t *cstate, u_int off, bpf_u_int32 v1,
3191      bpf_u_int32 v2)
3192  {
3193  	struct block *b1, *b2;
3194  	if (v1 > v2) {
3195  		bpf_u_int32 vtemp;
3196  		vtemp = v1;
3197  		v1 = v2;
3198  		v2 = vtemp;
3199  	}
3200  	b1 = gen_cmp_ge(cstate, OR_TRAN_IPV4, off, BPF_H, v1);
3201  	b2 = gen_cmp_le(cstate, OR_TRAN_IPV4, off, BPF_H, v2);
3202  	gen_and(b1, b2);
3203  	return b2;
3204  }
3205  static struct block *
3206  gen_portrangeop(compiler_state_t *cstate, u_int port1, u_int port2,
3207      bpf_u_int32 proto, int dir)
3208  {
3209  	struct block *b0, *b1, *tmp;
3210  	tmp = gen_cmp(cstate, OR_LINKPL, 9, BPF_B, proto);
3211  	b0 = gen_ipfrag(cstate);
3212  	gen_and(tmp, b0);
3213  	switch (dir) {
3214  	case Q_SRC:
3215  		b1 = gen_portrangeatom(cstate, 0, port1, port2);
3216  		break;
3217  	case Q_DST:
3218  		b1 = gen_portrangeatom(cstate, 2, port1, port2);
3219  		break;
3220  	case Q_AND:
3221  		tmp = gen_portrangeatom(cstate, 0, port1, port2);
3222  		b1 = gen_portrangeatom(cstate, 2, port1, port2);
3223  		gen_and(tmp, b1);
3224  		break;
3225  	case Q_DEFAULT:
3226  	case Q_OR:
3227  		tmp = gen_portrangeatom(cstate, 0, port1, port2);
3228  		b1 = gen_portrangeatom(cstate, 2, port1, port2);
3229  		gen_or(tmp, b1);
3230  		break;
3231  	case Q_ADDR1:
3232  		bpf_error(cstate, "'addr1' and 'address1' are not valid qualifiers for port ranges");
3233  	case Q_ADDR2:
3234  		bpf_error(cstate, "'addr2' and 'address2' are not valid qualifiers for port ranges");
3235  	case Q_ADDR3:
3236  		bpf_error(cstate, "'addr3' and 'address3' are not valid qualifiers for port ranges");
3237  	case Q_ADDR4:
3238  		bpf_error(cstate, "'addr4' and 'address4' are not valid qualifiers for port ranges");
3239  	case Q_RA:
3240  		bpf_error(cstate, "'ra' is not a valid qualifier for port ranges");
3241  	case Q_TA:
3242  		bpf_error(cstate, "'ta' is not a valid qualifier for port ranges");
3243  	default:
3244  		abort();
3245  	}
3246  	gen_and(b0, b1);
3247  	return b1;
3248  }
3249  static struct block *
3250  gen_portrange(compiler_state_t *cstate, u_int port1, u_int port2, int ip_proto,
3251      int dir)
3252  {
3253  	struct block *b0, *b1, *tmp;
3254  	b0 = gen_linktype(cstate, ETHERTYPE_IP);
3255  	switch (ip_proto) {
3256  	case IPPROTO_UDP:
3257  	case IPPROTO_TCP:
3258  	case IPPROTO_SCTP:
3259  		b1 = gen_portrangeop(cstate, port1, port2, (bpf_u_int32)ip_proto,
3260  		    dir);
3261  		break;
3262  	case PROTO_UNDEF:
3263  		tmp = gen_portrangeop(cstate, port1, port2, IPPROTO_TCP, dir);
3264  		b1 = gen_portrangeop(cstate, port1, port2, IPPROTO_UDP, dir);
3265  		gen_or(tmp, b1);
3266  		tmp = gen_portrangeop(cstate, port1, port2, IPPROTO_SCTP, dir);
3267  		gen_or(tmp, b1);
3268  		break;
3269  	default:
3270  		abort();
3271  	}
3272  	gen_and(b0, b1);
3273  	return b1;
3274  }
3275  static struct block *
3276  gen_portrangeatom6(compiler_state_t *cstate, u_int off, bpf_u_int32 v1,
3277      bpf_u_int32 v2)
3278  {
3279  	struct block *b1, *b2;
3280  	if (v1 > v2) {
3281  		bpf_u_int32 vtemp;
3282  		vtemp = v1;
3283  		v1 = v2;
3284  		v2 = vtemp;
3285  	}
3286  	b1 = gen_cmp_ge(cstate, OR_TRAN_IPV6, off, BPF_H, v1);
3287  	b2 = gen_cmp_le(cstate, OR_TRAN_IPV6, off, BPF_H, v2);
3288  	gen_and(b1, b2);
3289  	return b2;
3290  }
3291  static struct block *
3292  gen_portrangeop6(compiler_state_t *cstate, u_int port1, u_int port2,
3293      bpf_u_int32 proto, int dir)
3294  {
3295  	struct block *b0, *b1, *tmp;
3296  	b0 = gen_cmp(cstate, OR_LINKPL, 6, BPF_B, proto);
3297  	switch (dir) {
3298  	case Q_SRC:
3299  		b1 = gen_portrangeatom6(cstate, 0, port1, port2);
3300  		break;
3301  	case Q_DST:
3302  		b1 = gen_portrangeatom6(cstate, 2, port1, port2);
3303  		break;
3304  	case Q_AND:
3305  		tmp = gen_portrangeatom6(cstate, 0, port1, port2);
3306  		b1 = gen_portrangeatom6(cstate, 2, port1, port2);
3307  		gen_and(tmp, b1);
3308  		break;
3309  	case Q_DEFAULT:
3310  	case Q_OR:
3311  		tmp = gen_portrangeatom6(cstate, 0, port1, port2);
3312  		b1 = gen_portrangeatom6(cstate, 2, port1, port2);
3313  		gen_or(tmp, b1);
3314  		break;
3315  	default:
3316  		abort();
3317  	}
3318  	gen_and(b0, b1);
3319  	return b1;
3320  }
3321  static struct block *
3322  gen_portrange6(compiler_state_t *cstate, u_int port1, u_int port2, int ip_proto,
3323      int dir)
3324  {
3325  	struct block *b0, *b1, *tmp;
3326  	b0 = gen_linktype(cstate, ETHERTYPE_IPV6);
3327  	switch (ip_proto) {
3328  	case IPPROTO_UDP:
3329  	case IPPROTO_TCP:
3330  	case IPPROTO_SCTP:
3331  		b1 = gen_portrangeop6(cstate, port1, port2, (bpf_u_int32)ip_proto,
3332  		    dir);
3333  		break;
3334  	case PROTO_UNDEF:
3335  		tmp = gen_portrangeop6(cstate, port1, port2, IPPROTO_TCP, dir);
3336  		b1 = gen_portrangeop6(cstate, port1, port2, IPPROTO_UDP, dir);
3337  		gen_or(tmp, b1);
3338  		tmp = gen_portrangeop6(cstate, port1, port2, IPPROTO_SCTP, dir);
3339  		gen_or(tmp, b1);
3340  		break;
3341  	default:
3342  		abort();
3343  	}
3344  	gen_and(b0, b1);
3345  	return b1;
3346  }
3347  static int
3348  lookup_proto(compiler_state_t *cstate, const char *name, int proto)
3349  {
3350  	register int v;
3351  	switch (proto) {
3352  	case Q_DEFAULT:
3353  	case Q_IP:
3354  	case Q_IPV6:
3355  		v = pcap_nametoproto(name);
3356  		if (v == PROTO_UNDEF)
3357  			bpf_error(cstate, "unknown ip proto '%s'", name);
3358  		break;
3359  	case Q_LINK:
3360  		v = pcap_nametoeproto(name);
3361  		if (v == PROTO_UNDEF) {
3362  			v = pcap_nametollc(name);
3363  			if (v == PROTO_UNDEF)
3364  				bpf_error(cstate, "unknown ether proto '%s'", name);
3365  		}
3366  		break;
3367  	case Q_ISO:
3368  		if (strcmp(name, "esis") == 0)
3369  			v = ISO9542_ESIS;
3370  		else if (strcmp(name, "isis") == 0)
3371  			v = ISO10589_ISIS;
3372  		else if (strcmp(name, "clnp") == 0)
3373  			v = ISO8473_CLNP;
3374  		else
3375  			bpf_error(cstate, "unknown osi proto '%s'", name);
3376  		break;
3377  	default:
3378  		v = PROTO_UNDEF;
3379  		break;
3380  	}
3381  	return v;
3382  }
3383  #if !defined(NO_PROTOCHAIN)
3384  static struct block *
3385  gen_protochain(compiler_state_t *cstate, bpf_u_int32 v, int proto)
3386  {
3387  	struct block *b0, *b;
3388  	struct slist *s[100];
3389  	int fix2, fix3, fix4, fix5;
3390  	int ahcheck, again, end;
3391  	int i, max;
3392  	int reg2 = alloc_reg(cstate);
3393  	memset(s, 0, sizeof(s));
3394  	fix3 = fix4 = fix5 = 0;
3395  	switch (proto) {
3396  	case Q_IP:
3397  	case Q_IPV6:
3398  		break;
3399  	case Q_DEFAULT:
3400  		b0 = gen_protochain(cstate, v, Q_IP);
3401  		b = gen_protochain(cstate, v, Q_IPV6);
3402  		gen_or(b0, b);
3403  		return b;
3404  	default:
3405  		bpf_error(cstate, "bad protocol applied for 'protochain'");
3406  	}
3407  	if (cstate->off_linkpl.is_variable)
3408  		bpf_error(cstate, "'protochain' not supported with variable length headers");
3409  	cstate->no_optimize = 1;
3410  	i = 0;
3411  	s[i] = new_stmt(cstate, 0);	&bsol;*dummy*/
3412  	i++;
3413  	switch (proto) {
3414  	case Q_IP:
3415  		b0 = gen_linktype(cstate, ETHERTYPE_IP);
3416  		s[i] = new_stmt(cstate, BPF_LD|BPF_ABS|BPF_B);
3417  		s[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + 9;
3418  		i++;
3419  		s[i] = new_stmt(cstate, BPF_LDX|BPF_MSH|BPF_B);
3420  		s[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;
3421  		i++;
3422  		break;
3423  	case Q_IPV6:
3424  		b0 = gen_linktype(cstate, ETHERTYPE_IPV6);
3425  		s[i] = new_stmt(cstate, BPF_LD|BPF_ABS|BPF_B);
3426  		s[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + 6;
3427  		i++;
3428  		s[i] = new_stmt(cstate, BPF_LDX|BPF_IMM);
3429  		s[i]->s.k = 40;
3430  		i++;
3431  		break;
3432  	default:
3433  		bpf_error(cstate, "unsupported proto to gen_protochain");
3434  	}
3435  	again = i;
3436  	s[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);
3437  	s[i]->s.k = v;
3438  	s[i]->s.jt = NULL;		&bsol;*later*/
3439  	s[i]->s.jf = NULL;		&bsol;*update in next stmt*/
3440  	fix5 = i;
3441  	i++;
3442  #ifndef IPPROTO_NONE
3443  #define IPPROTO_NONE	59
3444  #endif
3445  	s[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);
3446  	s[i]->s.jt = NULL;	&bsol;*later*/
3447  	s[i]->s.jf = NULL;	&bsol;*update in next stmt*/
3448  	s[i]->s.k = IPPROTO_NONE;
3449  	s[fix5]->s.jf = s[i];
3450  	fix2 = i;
3451  	i++;
3452  	if (proto == Q_IPV6) {
3453  		int v6start, v6end, v6advance, j;
3454  		v6start = i;
3455  		s[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);
3456  		s[i]->s.jt = NULL;	&bsol;*later*/
3457  		s[i]->s.jf = NULL;	&bsol;*update in next stmt*/
3458  		s[i]->s.k = IPPROTO_HOPOPTS;
3459  		s[fix2]->s.jf = s[i];
3460  		i++;
3461  		s[i - 1]->s.jf = s[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);
3462  		s[i]->s.jt = NULL;	&bsol;*later*/
3463  		s[i]->s.jf = NULL;	&bsol;*update in next stmt*/
3464  		s[i]->s.k = IPPROTO_DSTOPTS;
3465  		i++;
3466  		s[i - 1]->s.jf = s[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);
3467  		s[i]->s.jt = NULL;	&bsol;*later*/
3468  		s[i]->s.jf = NULL;	&bsol;*update in next stmt*/
3469  		s[i]->s.k = IPPROTO_ROUTING;
3470  		i++;
3471  		s[i - 1]->s.jf = s[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);
3472  		s[i]->s.jt = NULL;	&bsol;*later*/
3473  		s[i]->s.jf = NULL;	&bsol;*later*/
3474  		s[i]->s.k = IPPROTO_FRAGMENT;
3475  		fix3 = i;
3476  		v6end = i;
3477  		i++;
3478  		v6advance = i;
3479  		s[i] = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);
3480  		s[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;
3481  		i++;
3482  		s[i] = new_stmt(cstate, BPF_ST);
3483  		s[i]->s.k = reg2;
3484  		i++;
3485  		s[i] = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);
3486  		s[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + 1;
3487  		i++;
3488  		s[i] = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);
3489  		s[i]->s.k = 1;
3490  		i++;
3491  		s[i] = new_stmt(cstate, BPF_ALU|BPF_MUL|BPF_K);
3492  		s[i]->s.k = 8;
3493  		i++;
3494  		s[i] = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X);
3495  		s[i]->s.k = 0;
3496  		i++;
3497  		s[i] = new_stmt(cstate, BPF_MISC|BPF_TAX);
3498  		i++;
3499  		s[i] = new_stmt(cstate, BPF_LD|BPF_MEM);
3500  		s[i]->s.k = reg2;
3501  		i++;
3502  		s[i] = new_stmt(cstate, BPF_JMP|BPF_JA);
3503  		s[i]->s.k = again - i - 1;
3504  		s[i - 1]->s.jf = s[i];
3505  		i++;
3506  		for (j = v6start; j <= v6end; j++)
3507  			s[j]->s.jt = s[v6advance];
3508  	} else {
3509  		s[i] = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);
3510  		s[i]->s.k = 0;
3511  		s[fix2]->s.jf = s[i];
3512  		i++;
3513  	}
3514  	ahcheck = i;
3515  	s[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);
3516  	s[i]->s.jt = NULL;	&bsol;*later*/
3517  	s[i]->s.jf = NULL;	&bsol;*later*/
3518  	s[i]->s.k = IPPROTO_AH;
3519  	if (fix3)
3520  		s[fix3]->s.jf = s[ahcheck];
3521  	fix4 = i;
3522  	i++;
3523  	s[i - 1]->s.jt = s[i] = new_stmt(cstate, BPF_MISC|BPF_TXA);
3524  	i++;
3525  	s[i] = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);
3526  	s[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;
3527  	i++;
3528  	s[i] = new_stmt(cstate, BPF_ST);
3529  	s[i]->s.k = reg2;
3530  	i++;
3531  	s[i - 1]->s.jt = s[i] = new_stmt(cstate, BPF_MISC|BPF_TXA);
3532  	i++;
3533  	s[i] = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);
3534  	s[i]->s.k = 1;
3535  	i++;
3536  	s[i] = new_stmt(cstate, BPF_MISC|BPF_TAX);
3537  	i++;
3538  	s[i] = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);
3539  	s[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;
3540  	i++;
3541  	s[i] = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);
3542  	s[i]->s.k = 2;
3543  	i++;
3544  	s[i] = new_stmt(cstate, BPF_ALU|BPF_MUL|BPF_K);
3545  	s[i]->s.k = 4;
3546  	i++;
3547  	s[i] = new_stmt(cstate, BPF_MISC|BPF_TAX);
3548  	i++;
3549  	s[i] = new_stmt(cstate, BPF_LD|BPF_MEM);
3550  	s[i]->s.k = reg2;
3551  	i++;
3552  	s[i] = new_stmt(cstate, BPF_JMP|BPF_JA);
3553  	s[i]->s.k = again - i - 1;
3554  	i++;
3555  	end = i;
3556  	s[i] = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);
3557  	s[i]->s.k = 0;
3558  	s[fix2]->s.jt = s[end];
3559  	s[fix4]->s.jf = s[end];
3560  	s[fix5]->s.jt = s[end];
3561  	i++;
3562  	max = i;
3563  	for (i = 0; i < max - 1; i++)
3564  		s[i]->next = s[i + 1];
3565  	s[max - 1]->next = NULL;
3566  	b = new_block(cstate, JMP(BPF_JEQ));
3567  	b->stmts = s[1];	&bsol;*remember, s[0] is dummy*/
3568  	b->s.k = v;
3569  	free_reg(cstate, reg2);
3570  	gen_and(b0, b);
3571  	return b;
3572  }
3573  #endif &bsol;* !defined(NO_PROTOCHAIN) */
3574  static struct block *
3575  gen_check_802_11_data_frame(compiler_state_t *cstate)
3576  {
3577  	struct slist *s;
3578  	struct block *b0, *b1;
3579  	s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
3580  	b0 = new_block(cstate, JMP(BPF_JSET));
3581  	b0->s.k = 0x08;
3582  	b0->stmts = s;
3583  	s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
3584  	b1 = new_block(cstate, JMP(BPF_JSET));
3585  	b1->s.k = 0x04;
3586  	b1->stmts = s;
3587  	gen_not(b1);
3588  	gen_and(b1, b0);
3589  	return b0;
3590  }
3591  static struct block *
3592  gen_proto(compiler_state_t *cstate, bpf_u_int32 v, int proto, int dir)
3593  {
3594  	struct block *b0, *b1;
3595  	struct block *b2;
3596  	if (dir != Q_DEFAULT)
3597  		bpf_error(cstate, "direction applied to 'proto'");
3598  	switch (proto) {
3599  	case Q_DEFAULT:
3600  		b0 = gen_proto(cstate, v, Q_IP, dir);
3601  		b1 = gen_proto(cstate, v, Q_IPV6, dir);
3602  		gen_or(b0, b1);
3603  		return b1;
3604  	case Q_LINK:
3605  		return gen_linktype(cstate, v);
3606  	case Q_IP:
3607  		b0 = gen_linktype(cstate, ETHERTYPE_IP);
3608  		b1 = gen_cmp(cstate, OR_LINKPL, 9, BPF_B, v);
3609  		gen_and(b0, b1);
3610  		return b1;
3611  	case Q_ARP:
3612  		bpf_error(cstate, "arp does not encapsulate another protocol");
3613  	case Q_RARP:
3614  		bpf_error(cstate, "rarp does not encapsulate another protocol");
3615  	case Q_SCTP:
3616  		bpf_error(cstate, "'sctp proto' is bogus");
3617  	case Q_TCP:
3618  		bpf_error(cstate, "'tcp proto' is bogus");
3619  	case Q_UDP:
3620  		bpf_error(cstate, "'udp proto' is bogus");
3621  	case Q_ICMP:
3622  		bpf_error(cstate, "'icmp proto' is bogus");
3623  	case Q_IGMP:
3624  		bpf_error(cstate, "'igmp proto' is bogus");
3625  	case Q_IGRP:
3626  		bpf_error(cstate, "'igrp proto' is bogus");
3627  	case Q_ATALK:
3628  		bpf_error(cstate, "AppleTalk encapsulation is not specifiable");
3629  	case Q_DECNET:
3630  		bpf_error(cstate, "DECNET encapsulation is not specifiable");
3631  	case Q_LAT:
3632  		bpf_error(cstate, "LAT does not encapsulate another protocol");
3633  	case Q_SCA:
3634  		bpf_error(cstate, "SCA does not encapsulate another protocol");
3635  	case Q_MOPRC:
3636  		bpf_error(cstate, "MOPRC does not encapsulate another protocol");
3637  	case Q_MOPDL:
3638  		bpf_error(cstate, "MOPDL does not encapsulate another protocol");
3639  	case Q_IPV6:
3640  		b0 = gen_linktype(cstate, ETHERTYPE_IPV6);
3641  		b2 = gen_cmp(cstate, OR_LINKPL, 6, BPF_B, IPPROTO_FRAGMENT);
3642  		b1 = gen_cmp(cstate, OR_LINKPL, 40, BPF_B, v);
3643  		gen_and(b2, b1);
3644  		b2 = gen_cmp(cstate, OR_LINKPL, 6, BPF_B, v);
3645  		gen_or(b2, b1);
3646  		gen_and(b0, b1);
3647  		return b1;
3648  	case Q_ICMPV6:
3649  		bpf_error(cstate, "'icmp6 proto' is bogus");
3650  	case Q_AH:
3651  		bpf_error(cstate, "'ah proto' is bogus");
3652  	case Q_ESP:
3653  		bpf_error(cstate, "'esp proto' is bogus");
3654  	case Q_PIM:
3655  		bpf_error(cstate, "'pim proto' is bogus");
3656  	case Q_VRRP:
3657  		bpf_error(cstate, "'vrrp proto' is bogus");
3658  	case Q_AARP:
3659  		bpf_error(cstate, "'aarp proto' is bogus");
3660  	case Q_ISO:
3661  		switch (cstate->linktype) {
3662  		case DLT_FRELAY:
3663  			return gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | v);
3664  		case DLT_C_HDLC:
3665  		case DLT_HDLC:
3666  			b0 = gen_linktype(cstate, LLCSAP_ISONS<<8 | LLCSAP_ISONS);
3667  			b1 = gen_cmp(cstate, OR_LINKPL_NOSNAP, 1, BPF_B, v);
3668  			gen_and(b0, b1);
3669  			return b1;
3670  		default:
3671  			b0 = gen_linktype(cstate, LLCSAP_ISONS);
3672  			b1 = gen_cmp(cstate, OR_LINKPL_NOSNAP, 0, BPF_B, v);
3673  			gen_and(b0, b1);
3674  			return b1;
3675  		}
3676  	case Q_ESIS:
3677  		bpf_error(cstate, "'esis proto' is bogus");
3678  	case Q_ISIS:
3679  		b0 = gen_proto(cstate, ISO10589_ISIS, Q_ISO, Q_DEFAULT);
3680  		b1 = gen_cmp(cstate, OR_LINKPL_NOSNAP, 4, BPF_B, v);
3681  		gen_and(b0, b1);
3682  		return b1;
3683  	case Q_CLNP:
3684  		bpf_error(cstate, "'clnp proto' is not supported");
3685  	case Q_STP:
3686  		bpf_error(cstate, "'stp proto' is bogus");
3687  	case Q_IPX:
3688  		bpf_error(cstate, "'ipx proto' is bogus");
3689  	case Q_NETBEUI:
3690  		bpf_error(cstate, "'netbeui proto' is bogus");
3691  	case Q_ISIS_L1:
3692  		bpf_error(cstate, "'l1 proto' is bogus");
3693  	case Q_ISIS_L2:
3694  		bpf_error(cstate, "'l2 proto' is bogus");
3695  	case Q_ISIS_IIH:
3696  		bpf_error(cstate, "'iih proto' is bogus");
3697  	case Q_ISIS_SNP:
3698  		bpf_error(cstate, "'snp proto' is bogus");
3699  	case Q_ISIS_CSNP:
3700  		bpf_error(cstate, "'csnp proto' is bogus");
3701  	case Q_ISIS_PSNP:
3702  		bpf_error(cstate, "'psnp proto' is bogus");
3703  	case Q_ISIS_LSP:
3704  		bpf_error(cstate, "'lsp proto' is bogus");
3705  	case Q_RADIO:
3706  		bpf_error(cstate, "'radio proto' is bogus");
3707  	case Q_CARP:
3708  		bpf_error(cstate, "'carp proto' is bogus");
3709  	default:
3710  		abort();
3711  	}
3712  }
3713  static int
3714  nametoport(compiler_state_t *cstate, const char *name, int ipproto)
3715  {
3716  	struct addrinfo hints, *res, *ai;
3717  	int error;
3718  	struct sockaddr_in *in4;
3719  #ifdef INET6
3720  	struct sockaddr_in6 *in6;
3721  #endif
3722  	int port = -1;
3723  	memset(&hints, 0, sizeof(hints));
3724  	hints.ai_family = PF_UNSPEC;
3725  	hints.ai_socktype = (ipproto == IPPROTO_TCP) ? SOCK_STREAM : SOCK_DGRAM;
3726  	hints.ai_protocol = ipproto;
3727  	error = getaddrinfo(NULL, name, &hints, &res);
3728  	if (error != 0) {
3729  		switch (error) {
3730  		case EAI_NONAME:
3731  		case EAI_SERVICE:
3732  			break;
3733  #ifdef EAI_SYSTEM
3734  		case EAI_SYSTEM:
3735  			bpf_set_error(cstate, "getaddrinfo(\"%s\" fails with system error: %d",
3736  			    name, errno);
3737  			port = -2;	&bsol;* a real error */
3738  			break;
3739  #endif
3740  		default:
3741  			bpf_set_error(cstate, "getaddrinfo(\"%s\") fails with error: %d",
3742  			    name, error);
3743  			port = -2;	&bsol;* a real error */
3744  			break;
3745  		}
3746  	} else {
3747  		for (ai = res; ai != NULL; ai = ai->ai_next) {
3748  			if (ai->ai_addr != NULL) {
3749  				if (ai->ai_addr->sa_family == AF_INET) {
3750  					in4 = (struct sockaddr_in *)ai->ai_addr;
3751  					port = ntohs(in4->sin_port);
3752  					break;
3753  				}
3754  #ifdef INET6
3755  				if (ai->ai_addr->sa_family == AF_INET6) {
3756  					in6 = (struct sockaddr_in6 *)ai->ai_addr;
3757  					port = ntohs(in6->sin6_port);
3758  					break;
3759  				}
3760  #endif
3761  			}
3762  		}
3763  		freeaddrinfo(res);
3764  	}
3765  	return port;
3766  }
3767  static bpf_u_int32
3768  stringtoport(compiler_state_t *cstate, const char *string, size_t string_size,
3769      int *proto)
3770  {
3771  	stoulen_ret ret;
3772  	char *cpy;
3773  	bpf_u_int32 val;
3774  	int tcp_port = -1;
3775  	int udp_port = -1;
3776  	ret = stoulen(string, string_size, &val, cstate);
3777  	switch (ret) {
3778  	case STOULEN_OK:
3779  		*proto = PROTO_UNDEF;
3780  		break;
3781  	case STOULEN_NOT_OCTAL_NUMBER:
3782  	case STOULEN_NOT_HEX_NUMBER:
3783  	case STOULEN_NOT_DECIMAL_NUMBER:
3784  		cpy = malloc(string_size + 1);	&bsol;* +1 for terminating '\0' */
3785  		memcpy(cpy, string, string_size);
3786  		cpy[string_size] = '\0';
3787  		tcp_port = nametoport(cstate, cpy, IPPROTO_TCP);
3788  		if (tcp_port == -2) {
3789  			free(cpy);
3790  			longjmp(cstate->top_ctx, 1);
3791  		}
3792  		udp_port = nametoport(cstate, cpy, IPPROTO_UDP);
3793  		if (udp_port == -2) {
3794  			free(cpy);
3795  			longjmp(cstate->top_ctx, 1);
3796  		}
3797  		if (tcp_port >= 0) {
3798  			val = (bpf_u_int32)tcp_port;
3799  			*proto = IPPROTO_TCP;
3800  			if (udp_port >= 0) {
3801  				if (udp_port == tcp_port)
3802  					*proto = PROTO_UNDEF;
3803  #ifdef notdef
3804  				else
3805  					warning("ambiguous port %s in /etc/services",
3806  						cpy);
3807  #endif
3808  			}
3809  			free(cpy);
3810  			break;
3811  		}
3812  		if (udp_port >= 0) {
3813  			val = (bpf_u_int32)udp_port;
3814  			*proto = IPPROTO_UDP;
3815  			free(cpy);
3816  			break;
3817  		}
3818  #if defined(ultrix) || defined(__osf__)
3819  		if (strcmp(cpy, "nfs") == 0) {
3820  			val = 2049;
3821  			*proto = PROTO_UNDEF;
3822  			free(cpy);
3823  			break;
3824  		}
3825  #endif
3826  		bpf_set_error(cstate, "'%s' is not a valid port", cpy);
3827  		free(cpy);
3828  		longjmp(cstate->top_ctx, 1);
3829  	case STOULEN_ERROR:
3830  		longjmp(cstate->top_ctx, 1);
3831  	default:
3832  		bpf_set_error(cstate, "stoulen returned %d - this should not happen", ret);
3833  		longjmp(cstate->top_ctx, 1);
3834  	}
3835  	return (val);
3836  }
3837  static void
3838  stringtoportrange(compiler_state_t *cstate, const char *string,
3839      bpf_u_int32 *port1, bpf_u_int32 *port2, int *proto)
3840  {
3841  	char *hyphen_off;
3842  	const char *first, *second;
3843  	size_t first_size, second_size;
3844  	int save_proto;
3845  	if ((hyphen_off = strchr(string, '-')) == NULL)
3846  		bpf_error(cstate, "port range '%s' contains no hyphen", string);
3847  	if (strchr(hyphen_off + 1, '-') != NULL)
3848  		bpf_error(cstate, "port range '%s' contains more than one hyphen",
3849  		    string);
3850  	first = string;
3851  	first_size = hyphen_off - string;
3852  	if (first_size == 0) {
3853  		bpf_error(cstate, "port range '%s' has no starting port", string);
3854  	}
3855  	*port1 = stringtoport(cstate, first, first_size, proto);
3856  	save_proto = *proto;
3857  	second = hyphen_off + 1;
3858  	second_size = strlen(second);
3859  	if (second_size == 0) {
3860  		bpf_error(cstate, "port range '%s' has no ending port", string);
3861  	}
3862  	*port2 = stringtoport(cstate, second, second_size, proto);
3863  	if (*proto != save_proto)
3864  		*proto = PROTO_UNDEF;
3865  }
3866  struct block *
3867  gen_scode(compiler_state_t *cstate, const char *name, struct qual q)
3868  {
3869  	int proto = q.proto;
3870  	int dir = q.dir;
3871  	int tproto;
3872  	u_char *eaddr;
3873  	bpf_u_int32 mask, addr;
3874  	struct addrinfo *res, *res0;
3875  	struct sockaddr_in *sin4;
3876  #ifdef INET6
3877  	int tproto6;
3878  	struct sockaddr_in6 *sin6;
3879  	struct in6_addr mask128;
3880  #endif &bsol;*INET6*/
3881  	struct block *b, *tmp;
3882  	int port, real_proto;
3883  	bpf_u_int32 port1, port2;
3884  	if (setjmp(cstate->top_ctx))
3885  		return (NULL);
3886  	switch (q.addr) {
3887  	case Q_NET:
3888  		addr = pcap_nametonetaddr(name);
3889  		if (addr == 0)
3890  			bpf_error(cstate, "unknown network '%s'", name);
3891  		mask = 0xffffffff;
3892  		while (addr && (addr & 0xff000000) == 0) {
3893  			addr <<= 8;
3894  			mask <<= 8;
3895  		}
3896  		return gen_host(cstate, addr, mask, proto, dir, q.addr);
3897  	case Q_DEFAULT:
3898  	case Q_HOST:
3899  		if (proto == Q_LINK) {
3900  			switch (cstate->linktype) {
3901  			case DLT_EN10MB:
3902  			case DLT_NETANALYZER:
3903  			case DLT_NETANALYZER_TRANSPARENT:
3904  				eaddr = pcap_ether_hostton(name);
3905  				if (eaddr == NULL)
3906  					bpf_error(cstate,
3907  					    "unknown ether host '%s'", name);
3908  				tmp = gen_prevlinkhdr_check(cstate);
3909  				b = gen_ehostop(cstate, eaddr, dir);
3910  				if (tmp != NULL)
3911  					gen_and(tmp, b);
3912  				free(eaddr);
3913  				return b;
3914  			case DLT_FDDI:
3915  				eaddr = pcap_ether_hostton(name);
3916  				if (eaddr == NULL)
3917  					bpf_error(cstate,
3918  					    "unknown FDDI host '%s'", name);
3919  				b = gen_fhostop(cstate, eaddr, dir);
3920  				free(eaddr);
3921  				return b;
3922  			case DLT_IEEE802:
3923  				eaddr = pcap_ether_hostton(name);
3924  				if (eaddr == NULL)
3925  					bpf_error(cstate,
3926  					    "unknown token ring host '%s'", name);
3927  				b = gen_thostop(cstate, eaddr, dir);
3928  				free(eaddr);
3929  				return b;
3930  			case DLT_IEEE802_11:
3931  			case DLT_PRISM_HEADER:
3932  			case DLT_IEEE802_11_RADIO_AVS:
3933  			case DLT_IEEE802_11_RADIO:
3934  			case DLT_PPI:
3935  				eaddr = pcap_ether_hostton(name);
3936  				if (eaddr == NULL)
3937  					bpf_error(cstate,
3938  					    "unknown 802.11 host '%s'", name);
3939  				b = gen_wlanhostop(cstate, eaddr, dir);
3940  				free(eaddr);
3941  				return b;
3942  			case DLT_IP_OVER_FC:
3943  				eaddr = pcap_ether_hostton(name);
3944  				if (eaddr == NULL)
3945  					bpf_error(cstate,
3946  					    "unknown Fibre Channel host '%s'", name);
3947  				b = gen_ipfchostop(cstate, eaddr, dir);
3948  				free(eaddr);
3949  				return b;
3950  			}
3951  			bpf_error(cstate, "only ethernet/FDDI/token ring/802.11/ATM LANE/Fibre Channel supports link-level host name");
3952  		} else if (proto == Q_DECNET) {
3953  			bpf_error(cstate, "invalid DECnet address '%s'", name);
3954  		} else {
3955  #ifdef INET6
3956  			memset(&mask128, 0xff, sizeof(mask128));
3957  #endif
3958  			res0 = res = pcap_nametoaddrinfo(name);
3959  			if (res == NULL)
3960  				bpf_error(cstate, "unknown host '%s'", name);
3961  			cstate->ai = res;
3962  			b = tmp = NULL;
3963  			tproto = proto;
3964  #ifdef INET6
3965  			tproto6 = proto;
3966  #endif
3967  			if (cstate->off_linktype.constant_part == OFFSET_NOT_SET &&
3968  			    tproto == Q_DEFAULT) {
3969  				tproto = Q_IP;
3970  #ifdef INET6
3971  				tproto6 = Q_IPV6;
3972  #endif
3973  			}
3974  			for (res = res0; res; res = res->ai_next) {
3975  				switch (res->ai_family) {
3976  				case AF_INET:
3977  #ifdef INET6
3978  					if (tproto == Q_IPV6)
3979  						continue;
3980  #endif
3981  					sin4 = (struct sockaddr_in *)
3982  						res->ai_addr;
3983  					tmp = gen_host(cstate, ntohl(sin4->sin_addr.s_addr),
3984  						0xffffffff, tproto, dir, q.addr);
3985  					break;
3986  #ifdef INET6
3987  				case AF_INET6:
3988  					if (tproto6 == Q_IP)
3989  						continue;
3990  					sin6 = (struct sockaddr_in6 *)
3991  						res->ai_addr;
3992  					tmp = gen_host6(cstate, &sin6->sin6_addr,
3993  						&mask128, tproto6, dir, q.addr);
3994  					break;
3995  #endif
3996  				default:
3997  					continue;
3998  				}
3999  				if (b)
4000  					gen_or(b, tmp);
4001  				b = tmp;
4002  			}
4003  			cstate->ai = NULL;
4004  			freeaddrinfo(res0);
4005  			if (b == NULL) {
4006  				bpf_error(cstate, "unknown host '%s'%s", name,
4007  				    (proto == Q_DEFAULT)
4008  					? ""
4009  					: " for specified address family");
4010  			}
4011  			return b;
4012  		}
4013  	case Q_PORT:
4014  		if (proto != Q_DEFAULT &&
4015  		    proto != Q_UDP && proto != Q_TCP && proto != Q_SCTP)
4016  			bpf_error(cstate, "illegal qualifier of 'port'");
4017  		if (pcap_nametoport(name, &port, &real_proto) == 0)
4018  			bpf_error(cstate, "unknown port '%s'", name);
4019  		if (proto == Q_UDP) {
4020  			if (real_proto == IPPROTO_TCP)
4021  				bpf_error(cstate, "port '%s' is tcp", name);
4022  			else if (real_proto == IPPROTO_SCTP)
4023  				bpf_error(cstate, "port '%s' is sctp", name);
4024  			else
4025  				real_proto = IPPROTO_UDP;
4026  		}
4027  		if (proto == Q_TCP) {
4028  			if (real_proto == IPPROTO_UDP)
4029  				bpf_error(cstate, "port '%s' is udp", name);
4030  			else if (real_proto == IPPROTO_SCTP)
4031  				bpf_error(cstate, "port '%s' is sctp", name);
4032  			else
4033  				real_proto = IPPROTO_TCP;
4034  		}
4035  		if (proto == Q_SCTP) {
4036  			if (real_proto == IPPROTO_UDP)
4037  				bpf_error(cstate, "port '%s' is udp", name);
4038  			else if (real_proto == IPPROTO_TCP)
4039  				bpf_error(cstate, "port '%s' is tcp", name);
4040  			else
4041  				real_proto = IPPROTO_SCTP;
4042  		}
4043  		if (port < 0)
4044  			bpf_error(cstate, "illegal port number %d < 0", port);
4045  		if (port > 65535)
4046  			bpf_error(cstate, "illegal port number %d > 65535", port);
4047  		b = gen_port(cstate, port, real_proto, dir);
4048  		gen_or(gen_port6(cstate, port, real_proto, dir), b);
4049  		return b;
4050  	case Q_PORTRANGE:
4051  		if (proto != Q_DEFAULT &&
4052  		    proto != Q_UDP && proto != Q_TCP && proto != Q_SCTP)
4053  			bpf_error(cstate, "illegal qualifier of 'portrange'");
4054  		stringtoportrange(cstate, name, &port1, &port2, &real_proto);
4055  		if (proto == Q_UDP) {
4056  			if (real_proto == IPPROTO_TCP)
4057  				bpf_error(cstate, "port in range '%s' is tcp", name);
4058  			else if (real_proto == IPPROTO_SCTP)
4059  				bpf_error(cstate, "port in range '%s' is sctp", name);
4060  			else
4061  				real_proto = IPPROTO_UDP;
4062  		}
4063  		if (proto == Q_TCP) {
4064  			if (real_proto == IPPROTO_UDP)
4065  				bpf_error(cstate, "port in range '%s' is udp", name);
4066  			else if (real_proto == IPPROTO_SCTP)
4067  				bpf_error(cstate, "port in range '%s' is sctp", name);
4068  			else
4069  				real_proto = IPPROTO_TCP;
4070  		}
4071  		if (proto == Q_SCTP) {
4072  			if (real_proto == IPPROTO_UDP)
4073  				bpf_error(cstate, "port in range '%s' is udp", name);
4074  			else if (real_proto == IPPROTO_TCP)
4075  				bpf_error(cstate, "port in range '%s' is tcp", name);
4076  			else
4077  				real_proto = IPPROTO_SCTP;
4078  		}
4079  		if (port1 > 65535)
4080  			bpf_error(cstate, "illegal port number %d > 65535", port1);
4081  		if (port2 > 65535)
4082  			bpf_error(cstate, "illegal port number %d > 65535", port2);
4083  		b = gen_portrange(cstate, port1, port2, real_proto, dir);
4084  		gen_or(gen_portrange6(cstate, port1, port2, real_proto, dir), b);
4085  		return b;
4086  	case Q_GATEWAY:
4087  #ifndef INET6
4088  		eaddr = pcap_ether_hostton(name);
4089  		if (eaddr == NULL)
4090  			bpf_error(cstate, "unknown ether host: %s", name);
4091  		res = pcap_nametoaddrinfo(name);
4092  		cstate->ai = res;
4093  		if (res == NULL)
4094  			bpf_error(cstate, "unknown host '%s'", name);
4095  		b = gen_gateway(cstate, eaddr, res, proto, dir);
4096  		cstate->ai = NULL;
4097  		freeaddrinfo(res);
4098  		if (b == NULL)
4099  			bpf_error(cstate, "unknown host '%s'", name);
4100  		return b;
4101  #else
4102  		bpf_error(cstate, "'gateway' not supported in this configuration");
4103  #endif &bsol;*INET6*/
4104  	case Q_PROTO:
4105  		real_proto = lookup_proto(cstate, name, proto);
4106  		if (real_proto >= 0)
4107  			return gen_proto(cstate, real_proto, proto, dir);
4108  		else
4109  			bpf_error(cstate, "unknown protocol: %s", name);
4110  #if !defined(NO_PROTOCHAIN)
4111  	case Q_PROTOCHAIN:
4112  		real_proto = lookup_proto(cstate, name, proto);
4113  		if (real_proto >= 0)
4114  			return gen_protochain(cstate, real_proto, proto);
4115  		else
4116  			bpf_error(cstate, "unknown protocol: %s", name);
4117  #endif &bsol;* !defined(NO_PROTOCHAIN) */
4118  	case Q_UNDEF:
4119  		syntax(cstate);
4120  	}
4121  	abort();
4122  }
4123  struct block *
4124  gen_mcode(compiler_state_t *cstate, const char *s1, const char *s2,
4125      bpf_u_int32 masklen, struct qual q)
4126  {
4127  	register int nlen, mlen;
4128  	bpf_u_int32 n, m;
4129  	if (setjmp(cstate->top_ctx))
4130  		return (NULL);
4131  	nlen = __pcap_atoin(s1, &n);
4132  	if (nlen < 0)
4133  		bpf_error(cstate, "invalid IPv4 address '%s'", s1);
4134  	n <<= 32 - nlen;
4135  	if (s2 != NULL) {
4136  		mlen = __pcap_atoin(s2, &m);
4137  		if (mlen < 0)
4138  			bpf_error(cstate, "invalid IPv4 address '%s'", s2);
4139  		m <<= 32 - mlen;
4140  		if ((n & ~m) != 0)
4141  			bpf_error(cstate, "non-network bits set in \"%s mask %s\"",
4142  			    s1, s2);
4143  	} else {
4144  		if (masklen > 32)
4145  			bpf_error(cstate, "mask length must be <= 32");
4146  		if (masklen == 0) {
4147  			m = 0;
4148  		} else
4149  			m = 0xffffffff << (32 - masklen);
4150  		if ((n & ~m) != 0)
4151  			bpf_error(cstate, "non-network bits set in \"%s/%d\"",
4152  			    s1, masklen);
4153  	}
4154  	switch (q.addr) {
4155  	case Q_NET:
4156  		return gen_host(cstate, n, m, q.proto, q.dir, q.addr);
4157  	default:
4158  		bpf_error(cstate, "Mask syntax for networks only");
4159  	}
4160  }
4161  struct block *
4162  gen_ncode(compiler_state_t *cstate, const char *s, bpf_u_int32 v, struct qual q)
4163  {
4164  	bpf_u_int32 mask;
4165  	int proto;
4166  	int dir;
4167  	register int vlen;
4168  	if (setjmp(cstate->top_ctx))
4169  		return (NULL);
4170  	proto = q.proto;
4171  	dir = q.dir;
4172  	if (s == NULL) {
4173  		if (proto == Q_DECNET)
4174  			bpf_error(cstate, "invalid DECnet address '%u'", v);
4175  		vlen = 32;
4176  	} else if (proto == Q_DECNET) {
4177  		vlen = __pcap_atodn(s, &v);
4178  		if (vlen == 0)
4179  			bpf_error(cstate, "invalid DECnet address '%s'", s);
4180  	} else {
4181  		vlen = __pcap_atoin(s, &v);
4182  		if (vlen < 0)
4183  			bpf_error(cstate, "invalid IPv4 address '%s'", s);
4184  	}
4185  	switch (q.addr) {
4186  	case Q_DEFAULT:
4187  	case Q_HOST:
4188  	case Q_NET:
4189  		if (proto == Q_DECNET)
4190  			return gen_host(cstate, v, 0, proto, dir, q.addr);
4191  		else if (proto == Q_LINK) {
4192  			bpf_error(cstate, "illegal link layer address");
4193  		} else {
4194  			mask = 0xffffffff;
4195  			if (s == NULL && q.addr == Q_NET) {
4196  				while (v && (v & 0xff000000) == 0) {
4197  					v <<= 8;
4198  					mask <<= 8;
4199  				}
4200  			} else {
4201  				v <<= 32 - vlen;
4202  				mask <<= 32 - vlen ;
4203  			}
4204  			return gen_host(cstate, v, mask, proto, dir, q.addr);
4205  		}
4206  	case Q_PORT:
4207  		if (proto == Q_UDP)
4208  			proto = IPPROTO_UDP;
4209  		else if (proto == Q_TCP)
4210  			proto = IPPROTO_TCP;
4211  		else if (proto == Q_SCTP)
4212  			proto = IPPROTO_SCTP;
4213  		else if (proto == Q_DEFAULT)
4214  			proto = PROTO_UNDEF;
4215  		else
4216  			bpf_error(cstate, "illegal qualifier of 'port'");
4217  		if (v > 65535)
4218  			bpf_error(cstate, "illegal port number %u > 65535", v);
4219  	    {
4220  		struct block *b;
4221  		b = gen_port(cstate, v, proto, dir);
4222  		gen_or(gen_port6(cstate, v, proto, dir), b);
4223  		return b;
4224  	    }
4225  	case Q_PORTRANGE:
4226  		if (proto == Q_UDP)
4227  			proto = IPPROTO_UDP;
4228  		else if (proto == Q_TCP)
4229  			proto = IPPROTO_TCP;
4230  		else if (proto == Q_SCTP)
4231  			proto = IPPROTO_SCTP;
4232  		else if (proto == Q_DEFAULT)
4233  			proto = PROTO_UNDEF;
4234  		else
4235  			bpf_error(cstate, "illegal qualifier of 'portrange'");
4236  		if (v > 65535)
4237  			bpf_error(cstate, "illegal port number %u > 65535", v);
4238  	    {
4239  		struct block *b;
4240  		b = gen_portrange(cstate, v, v, proto, dir);
4241  		gen_or(gen_portrange6(cstate, v, v, proto, dir), b);
4242  		return b;
4243  	    }
4244  	case Q_GATEWAY:
4245  		bpf_error(cstate, "'gateway' requires a name");
4246  	case Q_PROTO:
4247  		return gen_proto(cstate, v, proto, dir);
4248  #if !defined(NO_PROTOCHAIN)
4249  	case Q_PROTOCHAIN:
4250  		return gen_protochain(cstate, v, proto);
4251  #endif
4252  	case Q_UNDEF:
4253  		syntax(cstate);
4254  	default:
4255  		abort();
4256  	}
4257  }
4258  #ifdef INET6
4259  struct block *
4260  gen_mcode6(compiler_state_t *cstate, const char *s, bpf_u_int32 masklen,
4261      struct qual q)
4262  {
4263  	struct addrinfo *res;
4264  	struct in6_addr *addr;
4265  	struct in6_addr mask;
4266  	struct block *b;
4267  	bpf_u_int32 a[4], m[4]; &bsol;* Same as in gen_hostop6(). */
4268  	if (setjmp(cstate->top_ctx))
4269  		return (NULL);
4270  	res = pcap_nametoaddrinfo(s);
4271  	if (!res)
4272  		bpf_error(cstate, "invalid ip6 address %s", s);
4273  	cstate->ai = res;
4274  	if (res->ai_next)
4275  		bpf_error(cstate, "%s resolved to multiple address", s);
4276  	addr = &((struct sockaddr_in6 *)res->ai_addr)->sin6_addr;
4277  	if (masklen > sizeof(mask.s6_addr) * 8)
4278  		bpf_error(cstate, "mask length must be <= %zu", sizeof(mask.s6_addr) * 8);
4279  	memset(&mask, 0, sizeof(mask));
4280  	memset(&mask.s6_addr, 0xff, masklen / 8);
4281  	if (masklen % 8) {
4282  		mask.s6_addr[masklen / 8] =
4283  			(0xff << (8 - masklen % 8)) & 0xff;
4284  	}
4285  	memcpy(a, addr, sizeof(a));
4286  	memcpy(m, &mask, sizeof(m));
4287  	if ((a[0] & ~m[0]) || (a[1] & ~m[1])
4288  	 || (a[2] & ~m[2]) || (a[3] & ~m[3])) {
4289  		bpf_error(cstate, "non-network bits set in \"%s/%d\"", s, masklen);
4290  	}
4291  	switch (q.addr) {
4292  	case Q_DEFAULT:
4293  	case Q_HOST:
4294  		if (masklen != 128)
4295  			bpf_error(cstate, "Mask syntax for networks only");
4296  	case Q_NET:
4297  		b = gen_host6(cstate, addr, &mask, q.proto, q.dir, q.addr);
4298  		cstate->ai = NULL;
4299  		freeaddrinfo(res);
4300  		return b;
4301  	default:
4302  		bpf_error(cstate, "invalid qualifier against IPv6 address");
4303  	}
4304  }
4305  #endif &bsol;*INET6*/
4306  struct block *
4307  gen_ecode(compiler_state_t *cstate, const char *s, struct qual q)
4308  {
4309  	struct block *b, *tmp;
4310  	if (setjmp(cstate->top_ctx))
4311  		return (NULL);
4312  	if ((q.addr == Q_HOST || q.addr == Q_DEFAULT) && q.proto == Q_LINK) {
4313  		cstate->e = pcap_ether_aton(s);
4314  		if (cstate->e == NULL)
4315  			bpf_error(cstate, "malloc");
4316  		switch (cstate->linktype) {
4317  		case DLT_EN10MB:
4318  		case DLT_NETANALYZER:
4319  		case DLT_NETANALYZER_TRANSPARENT:
4320  			tmp = gen_prevlinkhdr_check(cstate);
4321  			b = gen_ehostop(cstate, cstate->e, (int)q.dir);
4322  			if (tmp != NULL)
4323  				gen_and(tmp, b);
4324  			break;
4325  		case DLT_FDDI:
4326  			b = gen_fhostop(cstate, cstate->e, (int)q.dir);
4327  			break;
4328  		case DLT_IEEE802:
4329  			b = gen_thostop(cstate, cstate->e, (int)q.dir);
4330  			break;
4331  		case DLT_IEEE802_11:
4332  		case DLT_PRISM_HEADER:
4333  		case DLT_IEEE802_11_RADIO_AVS:
4334  		case DLT_IEEE802_11_RADIO:
4335  		case DLT_PPI:
4336  			b = gen_wlanhostop(cstate, cstate->e, (int)q.dir);
4337  			break;
4338  		case DLT_IP_OVER_FC:
4339  			b = gen_ipfchostop(cstate, cstate->e, (int)q.dir);
4340  			break;
4341  		default:
4342  			free(cstate->e);
4343  			cstate->e = NULL;
4344  			bpf_error(cstate, "ethernet addresses supported only on ethernet/FDDI/token ring/802.11/ATM LANE/Fibre Channel");
4345  		}
4346  		free(cstate->e);
4347  		cstate->e = NULL;
4348  		return (b);
4349  	}
4350  	bpf_error(cstate, "ethernet address used in non-ether expression");
4351  }
4352  void
4353  sappend(struct slist *s0, struct slist *s1)
4354  {
4355  	while (s0->next)
4356  		s0 = s0->next;
4357  	s0->next = s1;
4358  }
4359  static struct slist *
4360  xfer_to_x(compiler_state_t *cstate, struct arth *a)
4361  {
4362  	struct slist *s;
4363  	s = new_stmt(cstate, BPF_LDX|BPF_MEM);
4364  	s->s.k = a->regno;
4365  	return s;
4366  }
4367  static struct slist *
4368  xfer_to_a(compiler_state_t *cstate, struct arth *a)
4369  {
4370  	struct slist *s;
4371  	s = new_stmt(cstate, BPF_LD|BPF_MEM);
4372  	s->s.k = a->regno;
4373  	return s;
4374  }
4375  static struct arth *
4376  gen_load_internal(compiler_state_t *cstate, int proto, struct arth *inst,
4377      bpf_u_int32 size)
4378  {
4379  	int size_code;
4380  	struct slist *s, *tmp;
4381  	struct block *b;
4382  	int regno = alloc_reg(cstate);
4383  	free_reg(cstate, inst->regno);
4384  	switch (size) {
4385  	default:
4386  		bpf_error(cstate, "data size must be 1, 2, or 4");
4387  	case 1:
4388  		size_code = BPF_B;
4389  		break;
4390  	case 2:
4391  		size_code = BPF_H;
4392  		break;
4393  	case 4:
4394  		size_code = BPF_W;
4395  		break;
4396  	}
4397  	switch (proto) {
4398  	default:
4399  		bpf_error(cstate, "unsupported index operation");
4400  	case Q_RADIO:
4401  		if (cstate->linktype != DLT_IEEE802_11_RADIO_AVS &&
4402  		    cstate->linktype != DLT_IEEE802_11_RADIO &&
4403  		    cstate->linktype != DLT_PRISM_HEADER)
4404  			bpf_error(cstate, "radio information not present in capture");
4405  		s = xfer_to_x(cstate, inst);
4406  		tmp = new_stmt(cstate, BPF_LD|BPF_IND|size_code);
4407  		sappend(s, tmp);
4408  		sappend(inst->s, s);
4409  		break;
4410  	case Q_LINK:
4411  		s = gen_abs_offset_varpart(cstate, &cstate->off_linkhdr);
4412  		if (s != NULL) {
4413  			sappend(s, xfer_to_a(cstate, inst));
4414  			sappend(s, new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X));
4415  			sappend(s, new_stmt(cstate, BPF_MISC|BPF_TAX));
4416  		} else
4417  			s = xfer_to_x(cstate, inst);
4418  		tmp = new_stmt(cstate, BPF_LD|BPF_IND|size_code);
4419  		tmp->s.k = cstate->off_linkhdr.constant_part;
4420  		sappend(s, tmp);
4421  		sappend(inst->s, s);
4422  		break;
4423  	case Q_IP:
4424  	case Q_ARP:
4425  	case Q_RARP:
4426  	case Q_ATALK:
4427  	case Q_DECNET:
4428  	case Q_SCA:
4429  	case Q_LAT:
4430  	case Q_MOPRC:
4431  	case Q_MOPDL:
4432  	case Q_IPV6:
4433  		s = gen_abs_offset_varpart(cstate, &cstate->off_linkpl);
4434  		if (s != NULL) {
4435  			sappend(s, xfer_to_a(cstate, inst));
4436  			sappend(s, new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X));
4437  			sappend(s, new_stmt(cstate, BPF_MISC|BPF_TAX));
4438  		} else
4439  			s = xfer_to_x(cstate, inst);
4440  		tmp = new_stmt(cstate, BPF_LD|BPF_IND|size_code);
4441  		tmp->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;
4442  		sappend(s, tmp);
4443  		sappend(inst->s, s);
4444  		b = gen_proto_abbrev_internal(cstate, proto);
4445  		if (inst->b)
4446  			gen_and(inst->b, b);
4447  		inst->b = b;
4448  		break;
4449  	case Q_SCTP:
4450  	case Q_TCP:
4451  	case Q_UDP:
4452  	case Q_ICMP:
4453  	case Q_IGMP:
4454  	case Q_IGRP:
4455  	case Q_PIM:
4456  	case Q_VRRP:
4457  	case Q_CARP:
4458  		s = gen_loadx_iphdrlen(cstate);
4459  		sappend(s, xfer_to_a(cstate, inst));
4460  		sappend(s, new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X));
4461  		sappend(s, new_stmt(cstate, BPF_MISC|BPF_TAX));
4462  		sappend(s, tmp = new_stmt(cstate, BPF_LD|BPF_IND|size_code));
4463  		tmp->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;
4464  		sappend(inst->s, s);
4465  		gen_and(gen_proto_abbrev_internal(cstate, proto), b = gen_ipfrag(cstate));
4466  		if (inst->b)
4467  			gen_and(inst->b, b);
4468  		gen_and(gen_proto_abbrev_internal(cstate, Q_IP), b);
4469  		inst->b = b;
4470  		break;
4471  	case Q_ICMPV6:
4472          b = gen_proto_abbrev_internal(cstate, Q_IPV6);
4473          if (inst->b) {
4474              gen_and(inst->b, b);
4475          }
4476          inst->b = b;
4477          b = gen_cmp(cstate, OR_LINKPL, 6, BPF_B, 58);
4478          if (inst->b) {
4479              gen_and(inst->b, b);
4480          }
4481          inst->b = b;
4482          s = gen_abs_offset_varpart(cstate, &cstate->off_linkpl);
4483          if (s != NULL) {
4484              sappend(s, xfer_to_a(cstate, inst));
4485              sappend(s, new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X));
4486              sappend(s, new_stmt(cstate, BPF_MISC|BPF_TAX));
4487          } else {
4488              s = xfer_to_x(cstate, inst);
4489          }
4490          tmp = new_stmt(cstate, BPF_LD|BPF_IND|size_code);
4491          tmp->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + 40;
4492          sappend(s, tmp);
4493          sappend(inst->s, s);
4494          break;
4495  	}
4496  	inst->regno = regno;
4497  	s = new_stmt(cstate, BPF_ST);
4498  	s->s.k = regno;
4499  	sappend(inst->s, s);
4500  	return inst;
4501  }
4502  struct arth *
4503  gen_load(compiler_state_t *cstate, int proto, struct arth *inst,
4504      bpf_u_int32 size)
4505  {
4506  	if (setjmp(cstate->top_ctx))
4507  		return (NULL);
4508  	return gen_load_internal(cstate, proto, inst, size);
4509  }
4510  static struct block *
4511  gen_relation_internal(compiler_state_t *cstate, int code, struct arth *a0,
4512      struct arth *a1, int reversed)
4513  {
4514  	struct slist *s0, *s1, *s2;
4515  	struct block *b, *tmp;
4516  	s0 = xfer_to_x(cstate, a1);
4517  	s1 = xfer_to_a(cstate, a0);
4518  	if (code == BPF_JEQ) {
4519  		s2 = new_stmt(cstate, BPF_ALU|BPF_SUB|BPF_X);
4520  		b = new_block(cstate, JMP(code));
4521  		sappend(s1, s2);
4522  	}
4523  	else
4524  		b = new_block(cstate, BPF_JMP|code|BPF_X);
4525  	if (reversed)
4526  		gen_not(b);
4527  	sappend(s0, s1);
4528  	sappend(a1->s, s0);
4529  	sappend(a0->s, a1->s);
4530  	b->stmts = a0->s;
4531  	free_reg(cstate, a0->regno);
4532  	free_reg(cstate, a1->regno);
4533  	if (a0->b) {
4534  		if (a1->b) {
4535  			gen_and(a0->b, tmp = a1->b);
4536  		}
4537  		else
4538  			tmp = a0->b;
4539  	} else
4540  		tmp = a1->b;
4541  	if (tmp)
4542  		gen_and(tmp, b);
4543  	return b;
4544  }
4545  struct block *
4546  gen_relation(compiler_state_t *cstate, int code, struct arth *a0,
4547      struct arth *a1, int reversed)
4548  {
4549  	if (setjmp(cstate->top_ctx))
4550  		return (NULL);
4551  	return gen_relation_internal(cstate, code, a0, a1, reversed);
4552  }
4553  struct arth *
4554  gen_loadlen(compiler_state_t *cstate)
4555  {
4556  	int regno;
4557  	struct arth *a;
4558  	struct slist *s;
4559  	if (setjmp(cstate->top_ctx))
4560  		return (NULL);
4561  	regno = alloc_reg(cstate);
4562  	a = (struct arth *)newchunk(cstate, sizeof(*a));
4563  	s = new_stmt(cstate, BPF_LD|BPF_LEN);
4564  	s->next = new_stmt(cstate, BPF_ST);
4565  	s->next->s.k = regno;
4566  	a->s = s;
4567  	a->regno = regno;
4568  	return a;
4569  }
4570  static struct arth *
4571  gen_loadi_internal(compiler_state_t *cstate, bpf_u_int32 val)
4572  {
4573  	struct arth *a;
4574  	struct slist *s;
4575  	int reg;
4576  	a = (struct arth *)newchunk(cstate, sizeof(*a));
4577  	reg = alloc_reg(cstate);
4578  	s = new_stmt(cstate, BPF_LD|BPF_IMM);
4579  	s->s.k = val;
4580  	s->next = new_stmt(cstate, BPF_ST);
4581  	s->next->s.k = reg;
4582  	a->s = s;
4583  	a->regno = reg;
4584  	return a;
4585  }
4586  struct arth *
4587  gen_loadi(compiler_state_t *cstate, bpf_u_int32 val)
4588  {
4589  	if (setjmp(cstate->top_ctx))
4590  		return (NULL);
4591  	return gen_loadi_internal(cstate, val);
4592  }
4593  struct arth *
4594  gen_neg(compiler_state_t *cstate, struct arth *a_arg)
4595  {
4596  	struct arth *a = a_arg;
4597  	struct slist *s;
4598  	if (setjmp(cstate->top_ctx))
4599  		return (NULL);
4600  	s = xfer_to_a(cstate, a);
4601  	sappend(a->s, s);
4602  	s = new_stmt(cstate, BPF_ALU|BPF_NEG);
4603  	s->s.k = 0;
4604  	sappend(a->s, s);
4605  	s = new_stmt(cstate, BPF_ST);
4606  	s->s.k = a->regno;
4607  	sappend(a->s, s);
4608  	return a;
4609  }
4610  struct arth *
4611  gen_arth(compiler_state_t *cstate, int code, struct arth *a0_arg,
4612      struct arth *a1)
4613  {
4614  	struct arth *a0 = a0_arg;
4615  	struct slist *s0, *s1, *s2;
4616  	if (setjmp(cstate->top_ctx))
4617  		return (NULL);
4618  	if (code == BPF_DIV) {
4619  		if (a1->s->s.code == (BPF_LD|BPF_IMM) && a1->s->s.k == 0)
4620  			bpf_error(cstate, "division by zero");
4621  	} else if (code == BPF_MOD) {
4622  		if (a1->s->s.code == (BPF_LD|BPF_IMM) && a1->s->s.k == 0)
4623  			bpf_error(cstate, "modulus by zero");
4624  	} else if (code == BPF_LSH || code == BPF_RSH) {
4625  		if (a1->s->s.code == (BPF_LD|BPF_IMM) && a1->s->s.k > 31)
4626  			bpf_error(cstate, "shift by more than 31 bits");
4627  	}
4628  	s0 = xfer_to_x(cstate, a1);
4629  	s1 = xfer_to_a(cstate, a0);
4630  	s2 = new_stmt(cstate, BPF_ALU|BPF_X|code);
4631  	sappend(s1, s2);
4632  	sappend(s0, s1);
4633  	sappend(a1->s, s0);
4634  	sappend(a0->s, a1->s);
4635  	free_reg(cstate, a0->regno);
4636  	free_reg(cstate, a1->regno);
4637  	s0 = new_stmt(cstate, BPF_ST);
4638  	a0->regno = s0->s.k = alloc_reg(cstate);
4639  	sappend(a0->s, s0);
4640  	return a0;
4641  }
4642  static void
4643  init_regs(compiler_state_t *cstate)
4644  {
4645  	cstate->curreg = 0;
4646  	memset(cstate->regused, 0, sizeof cstate->regused);
4647  }
4648  static int
4649  alloc_reg(compiler_state_t *cstate)
4650  {
4651  	int n = BPF_MEMWORDS;
4652  	while (--n >= 0) {
4653  		if (cstate->regused[cstate->curreg])
4654  			cstate->curreg = (cstate->curreg + 1) % BPF_MEMWORDS;
4655  		else {
4656  			cstate->regused[cstate->curreg] = 1;
4657  			return cstate->curreg;
4658  		}
4659  	}
4660  	bpf_error(cstate, "too many registers needed to evaluate expression");
4661  }
4662  static void
4663  free_reg(compiler_state_t *cstate, int n)
4664  {
4665  	cstate->regused[n] = 0;
4666  }
4667  static struct block *
4668  gen_len(compiler_state_t *cstate, int jmp, int n)
4669  {
4670  	struct slist *s;
4671  	struct block *b;
4672  	s = new_stmt(cstate, BPF_LD|BPF_LEN);
4673  	b = new_block(cstate, JMP(jmp));
4674  	b->stmts = s;
4675  	b->s.k = n;
4676  	return b;
4677  }
4678  struct block *
4679  gen_greater(compiler_state_t *cstate, int n)
4680  {
4681  	if (setjmp(cstate->top_ctx))
4682  		return (NULL);
4683  	return gen_len(cstate, BPF_JGE, n);
4684  }
4685  struct block *
4686  gen_less(compiler_state_t *cstate, int n)
4687  {
4688  	struct block *b;
4689  	if (setjmp(cstate->top_ctx))
4690  		return (NULL);
4691  	b = gen_len(cstate, BPF_JGT, n);
4692  	gen_not(b);
4693  	return b;
4694  }
4695  struct block *
4696  gen_byteop(compiler_state_t *cstate, int op, int idx, bpf_u_int32 val)
4697  {
4698  	struct block *b;
4699  	struct slist *s;
4700  	if (setjmp(cstate->top_ctx))
4701  		return (NULL);
4702  	switch (op) {
4703  	default:
4704  		abort();
4705  	case '=':
4706  		return gen_cmp(cstate, OR_LINKHDR, (u_int)idx, BPF_B, val);
4707  	case '<':
4708  		b = gen_cmp_lt(cstate, OR_LINKHDR, (u_int)idx, BPF_B, val);
4709  		return b;
4710  	case '>':
4711  		b = gen_cmp_gt(cstate, OR_LINKHDR, (u_int)idx, BPF_B, val);
4712  		return b;
4713  	case '|':
4714  		s = new_stmt(cstate, BPF_ALU|BPF_OR|BPF_K);
4715  		break;
4716  	case '&':
4717  		s = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);
4718  		break;
4719  	}
4720  	s->s.k = val;
4721  	b = new_block(cstate, JMP(BPF_JEQ));
4722  	b->stmts = s;
4723  	gen_not(b);
4724  	return b;
4725  }
4726  static const u_char abroadcast[] = { 0x0 };
4727  struct block *
4728  gen_broadcast(compiler_state_t *cstate, int proto)
4729  {
4730  	bpf_u_int32 hostmask;
4731  	struct block *b0, *b1, *b2;
4732  	static const u_char ebroadcast[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
4733  	if (setjmp(cstate->top_ctx))
4734  		return (NULL);
4735  	switch (proto) {
4736  	case Q_DEFAULT:
4737  	case Q_LINK:
4738  		switch (cstate->linktype) {
4739  		case DLT_ARCNET:
4740  		case DLT_ARCNET_LINUX:
4741  			return gen_ahostop(cstate, abroadcast, Q_DST);
4742  		case DLT_EN10MB:
4743  		case DLT_NETANALYZER:
4744  		case DLT_NETANALYZER_TRANSPARENT:
4745  			b1 = gen_prevlinkhdr_check(cstate);
4746  			b0 = gen_ehostop(cstate, ebroadcast, Q_DST);
4747  			if (b1 != NULL)
4748  				gen_and(b1, b0);
4749  			return b0;
4750  		case DLT_FDDI:
4751  			return gen_fhostop(cstate, ebroadcast, Q_DST);
4752  		case DLT_IEEE802:
4753  			return gen_thostop(cstate, ebroadcast, Q_DST);
4754  		case DLT_IEEE802_11:
4755  		case DLT_PRISM_HEADER:
4756  		case DLT_IEEE802_11_RADIO_AVS:
4757  		case DLT_IEEE802_11_RADIO:
4758  		case DLT_PPI:
4759  			return gen_wlanhostop(cstate, ebroadcast, Q_DST);
4760  		case DLT_IP_OVER_FC:
4761  			return gen_ipfchostop(cstate, ebroadcast, Q_DST);
4762  		default:
4763  			bpf_error(cstate, "not a broadcast link");
4764  		}
4765  	case Q_IP:
4766  		if (cstate->netmask == PCAP_NETMASK_UNKNOWN)
4767  			bpf_error(cstate, "netmask not known, so 'ip broadcast' not supported");
4768  		b0 = gen_linktype(cstate, ETHERTYPE_IP);
4769  		hostmask = ~cstate->netmask;
4770  		b1 = gen_mcmp(cstate, OR_LINKPL, 16, BPF_W, 0, hostmask);
4771  		b2 = gen_mcmp(cstate, OR_LINKPL, 16, BPF_W,
4772  			      ~0 & hostmask, hostmask);
4773  		gen_or(b1, b2);
4774  		gen_and(b0, b2);
4775  		return b2;
4776  	}
4777  	bpf_error(cstate, "only link-layer/IP broadcast filters supported");
4778  }
4779  static struct block *
4780  gen_mac_multicast(compiler_state_t *cstate, int offset)
4781  {
4782  	register struct block *b0;
4783  	register struct slist *s;
4784  	s = gen_load_a(cstate, OR_LINKHDR, offset, BPF_B);
4785  	b0 = new_block(cstate, JMP(BPF_JSET));
4786  	b0->s.k = 1;
4787  	b0->stmts = s;
4788  	return b0;
4789  }
4790  struct block *
4791  gen_multicast(compiler_state_t *cstate, int proto)
4792  {
4793  	register struct block *b0, *b1, *b2;
4794  	register struct slist *s;
4795  	if (setjmp(cstate->top_ctx))
4796  		return (NULL);
4797  	switch (proto) {
4798  	case Q_DEFAULT:
4799  	case Q_LINK:
4800  		switch (cstate->linktype) {
4801  		case DLT_ARCNET:
4802  		case DLT_ARCNET_LINUX:
4803  			return gen_ahostop(cstate, abroadcast, Q_DST);
4804  		case DLT_EN10MB:
4805  		case DLT_NETANALYZER:
4806  		case DLT_NETANALYZER_TRANSPARENT:
4807  			b1 = gen_prevlinkhdr_check(cstate);
4808  			b0 = gen_mac_multicast(cstate, 0);
4809  			if (b1 != NULL)
4810  				gen_and(b1, b0);
4811  			return b0;
4812  		case DLT_FDDI:
4813  			return gen_mac_multicast(cstate, 1);
4814  		case DLT_IEEE802:
4815  			return gen_mac_multicast(cstate, 2);
4816  		case DLT_IEEE802_11:
4817  		case DLT_PRISM_HEADER:
4818  		case DLT_IEEE802_11_RADIO_AVS:
4819  		case DLT_IEEE802_11_RADIO:
4820  		case DLT_PPI:
4821  			s = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);
4822  			b1 = new_block(cstate, JMP(BPF_JSET));
4823  			b1->s.k = 0x01;	&bsol;* To DS */
4824  			b1->stmts = s;
4825  			b0 = gen_mac_multicast(cstate, 16);
4826  			gen_and(b1, b0);
4827  			s = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);
4828  			b2 = new_block(cstate, JMP(BPF_JSET));
4829  			b2->s.k = 0x01;	&bsol;* To DS */
4830  			b2->stmts = s;
4831  			gen_not(b2);
4832  			b1 = gen_mac_multicast(cstate, 4);
4833  			gen_and(b2, b1);
4834  			gen_or(b1, b0);
4835  			s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
4836  			b1 = new_block(cstate, JMP(BPF_JSET));
4837  			b1->s.k = 0x08;
4838  			b1->stmts = s;
4839  			gen_and(b1, b0);
4840  			s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
4841  			b2 = new_block(cstate, JMP(BPF_JSET));
4842  			b2->s.k = 0x08;
4843  			b2->stmts = s;
4844  			gen_not(b2);
4845  			b1 = gen_mac_multicast(cstate, 4);
4846  			gen_and(b2, b1);
4847  			gen_or(b1, b0);
4848  			s = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);
4849  			b1 = new_block(cstate, JMP(BPF_JSET));
4850  			b1->s.k = 0x04;
4851  			b1->stmts = s;
4852  			gen_not(b1);
4853  			gen_and(b1, b0);
4854  			return b0;
4855  		case DLT_IP_OVER_FC:
4856  			b0 = gen_mac_multicast(cstate, 2);
4857  			return b0;
4858  		default:
4859  			break;
4860  		}
4861  		break;
4862  	case Q_IP:
4863  		b0 = gen_linktype(cstate, ETHERTYPE_IP);
4864  		b1 = gen_cmp_ge(cstate, OR_LINKPL, 16, BPF_B, 224);
4865  		gen_and(b0, b1);
4866  		return b1;
4867  	case Q_IPV6:
4868  		b0 = gen_linktype(cstate, ETHERTYPE_IPV6);
4869  		b1 = gen_cmp(cstate, OR_LINKPL, 24, BPF_B, 255);
4870  		gen_and(b0, b1);
4871  		return b1;
4872  	}
4873  	bpf_error(cstate, "link-layer multicast filters supported only on ethernet/FDDI/token ring/ARCNET/802.11/ATM LANE/Fibre Channel");
4874  }
4875  struct block *
4876  gen_ifindex(compiler_state_t *cstate, int ifindex)
4877  {
4878  	register struct block *b0;
4879  	if (setjmp(cstate->top_ctx))
4880  		return (NULL);
4881  	switch (cstate->linktype) {
4882  	case DLT_LINUX_SLL2:
4883  		b0 = gen_cmp(cstate, OR_LINKHDR, 4, BPF_W, ifindex);
4884  		break;
4885          default:
4886  #if defined(linux)
4887  		if (cstate->bpf_pcap->rfile != NULL) {
4888  			bpf_error(cstate, "ifindex not supported on %s when reading savefiles",
4889  			    pcap_datalink_val_to_description_or_dlt(cstate->linktype));
4890  		}
4891  		b0 = gen_cmp(cstate, OR_LINKHDR, SKF_AD_OFF + SKF_AD_IFINDEX, BPF_W,
4892  		             ifindex);
4893  #else &bsol;* defined(linux) */
4894  		bpf_error(cstate, "ifindex not supported on %s",
4895  		    pcap_datalink_val_to_description_or_dlt(cstate->linktype));
4896  #endif &bsol;* defined(linux) */
4897  	}
4898  	return (b0);
4899  }
4900  struct block *
4901  gen_inbound(compiler_state_t *cstate, int dir)
4902  {
4903  	register struct block *b0;
4904  	if (setjmp(cstate->top_ctx))
4905  		return (NULL);
4906  	switch (cstate->linktype) {
4907  	case DLT_SLIP:
4908  		b0 = gen_relation_internal(cstate, BPF_JEQ,
4909  			  gen_load_internal(cstate, Q_LINK, gen_loadi_internal(cstate, 0), 1),
4910  			  gen_loadi_internal(cstate, 0),
4911  			  dir);
4912  		break;
4913  	case DLT_IPNET:
4914  		if (dir) {
4915  			b0 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, IPNET_OUTBOUND);
4916  		} else {
4917  			b0 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, IPNET_INBOUND);
4918  		}
4919  		break;
4920  	case DLT_LINUX_SLL:
4921  		b0 = gen_cmp(cstate, OR_LINKHDR, 0, BPF_H, LINUX_SLL_OUTGOING);
4922  		if (!dir) {
4923  			gen_not(b0);
4924  		}
4925  		break;
4926  	case DLT_LINUX_SLL2:
4927  		b0 = gen_cmp(cstate, OR_LINKHDR, 10, BPF_B, LINUX_SLL_OUTGOING);
4928  		if (!dir) {
4929  			gen_not(b0);
4930  		}
4931  		break;
4932  	case DLT_PFLOG:
4933  		b0 = gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, dir), BPF_B,
4934  		    ((dir == 0) ? PF_IN : PF_OUT));
4935  		break;
4936  	case DLT_PPP_PPPD:
4937  		if (dir) {
4938  			b0 = gen_cmp(cstate, OR_LINKHDR, 0, BPF_B, PPP_PPPD_OUT);
4939  		} else {
4940  			b0 = gen_cmp(cstate, OR_LINKHDR, 0, BPF_B, PPP_PPPD_IN);
4941  		}
4942  		break;
4943          case DLT_JUNIPER_MFR:
4944          case DLT_JUNIPER_MLFR:
4945          case DLT_JUNIPER_MLPPP:
4946  	case DLT_JUNIPER_ATM1:
4947  	case DLT_JUNIPER_ATM2:
4948  	case DLT_JUNIPER_PPPOE:
4949  	case DLT_JUNIPER_PPPOE_ATM:
4950          case DLT_JUNIPER_GGSN:
4951          case DLT_JUNIPER_ES:
4952          case DLT_JUNIPER_MONITOR:
4953          case DLT_JUNIPER_SERVICES:
4954          case DLT_JUNIPER_ETHER:
4955          case DLT_JUNIPER_PPP:
4956          case DLT_JUNIPER_FRELAY:
4957          case DLT_JUNIPER_CHDLC:
4958          case DLT_JUNIPER_VP:
4959          case DLT_JUNIPER_ST:
4960          case DLT_JUNIPER_ISM:
4961          case DLT_JUNIPER_VS:
4962          case DLT_JUNIPER_SRX_E2E:
4963          case DLT_JUNIPER_FIBRECHANNEL:
4964  	case DLT_JUNIPER_ATM_CEMIC:
4965  		if (dir) {
4966  			b0 = gen_mcmp(cstate, OR_LINKHDR, 3, BPF_B, 0, 0x01);
4967  		} else {
4968  			b0 = gen_mcmp(cstate, OR_LINKHDR, 3, BPF_B, 1, 0x01);
4969  		}
4970  		break;
4971  	default:
4972  #if defined(linux)
4973  		if (cstate->bpf_pcap->rfile != NULL) {
4974  			bpf_error(cstate, "inbound/outbound not supported on %s when reading savefiles",
4975  			    pcap_datalink_val_to_description_or_dlt(cstate->linktype));
4976  		}
4977  		b0 = gen_cmp(cstate, OR_LINKHDR, SKF_AD_OFF + SKF_AD_PKTTYPE, BPF_H,
4978  		             PACKET_OUTGOING);
4979  		if (!dir) {
4980  			gen_not(b0);
4981  		}
4982  #else &bsol;* defined(linux) */
4983  		bpf_error(cstate, "inbound/outbound not supported on %s",
4984  		    pcap_datalink_val_to_description_or_dlt(cstate->linktype));
4985  #endif &bsol;* defined(linux) */
4986  	}
4987  	return (b0);
4988  }
4989  struct block *
4990  gen_pf_ifname(compiler_state_t *cstate, const char *ifname)
4991  {
4992  	struct block *b0;
4993  	u_int len, off;
4994  	if (setjmp(cstate->top_ctx))
4995  		return (NULL);
4996  	if (cstate->linktype != DLT_PFLOG) {
4997  		bpf_error(cstate, "ifname supported only on PF linktype");
4998  	}
4999  	len = sizeof(((struct pfloghdr *)0)->ifname);
5000  	off = offsetof(struct pfloghdr, ifname);
5001  	if (strlen(ifname) >= len) {
5002  		bpf_error(cstate, "ifname interface names can only be %d characters",
5003  		    len-1);
5004  	}
5005  	b0 = gen_bcmp(cstate, OR_LINKHDR, off, (u_int)strlen(ifname),
5006  	    (const u_char *)ifname);
5007  	return (b0);
5008  }
5009  struct block *
5010  gen_pf_ruleset(compiler_state_t *cstate, char *ruleset)
5011  {
5012  	struct block *b0;
5013  	if (setjmp(cstate->top_ctx))
5014  		return (NULL);
5015  	if (cstate->linktype != DLT_PFLOG) {
5016  		bpf_error(cstate, "ruleset supported only on PF linktype");
5017  	}
5018  	if (strlen(ruleset) >= sizeof(((struct pfloghdr *)0)->ruleset)) {
5019  		bpf_error(cstate, "ruleset names can only be %ld characters",
5020  		    (long)(sizeof(((struct pfloghdr *)0)->ruleset) - 1));
5021  	}
5022  	b0 = gen_bcmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, ruleset),
5023  	    (u_int)strlen(ruleset), (const u_char *)ruleset);
5024  	return (b0);
5025  }
5026  struct block *
5027  gen_pf_rnr(compiler_state_t *cstate, int rnr)
5028  {
5029  	struct block *b0;
5030  	if (setjmp(cstate->top_ctx))
5031  		return (NULL);
5032  	if (cstate->linktype != DLT_PFLOG) {
5033  		bpf_error(cstate, "rnr supported only on PF linktype");
5034  	}
5035  	b0 = gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, rulenr), BPF_W,
5036  		 (bpf_u_int32)rnr);
5037  	return (b0);
5038  }
5039  struct block *
5040  gen_pf_srnr(compiler_state_t *cstate, int srnr)
5041  {
5042  	struct block *b0;
5043  	if (setjmp(cstate->top_ctx))
5044  		return (NULL);
5045  	if (cstate->linktype != DLT_PFLOG) {
5046  		bpf_error(cstate, "srnr supported only on PF linktype");
5047  	}
5048  	b0 = gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, subrulenr), BPF_W,
5049  	    (bpf_u_int32)srnr);
5050  	return (b0);
5051  }
5052  struct block *
5053  gen_pf_reason(compiler_state_t *cstate, int reason)
5054  {
5055  	struct block *b0;
5056  	if (setjmp(cstate->top_ctx))
5057  		return (NULL);
5058  	if (cstate->linktype != DLT_PFLOG) {
5059  		bpf_error(cstate, "reason supported only on PF linktype");
5060  	}
5061  	b0 = gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, reason), BPF_B,
5062  	    (bpf_u_int32)reason);
5063  	return (b0);
5064  }
5065  struct block *
5066  gen_pf_action(compiler_state_t *cstate, int action)
5067  {
5068  	struct block *b0;
5069  	if (setjmp(cstate->top_ctx))
5070  		return (NULL);
5071  	if (cstate->linktype != DLT_PFLOG) {
5072  		bpf_error(cstate, "action supported only on PF linktype");
5073  	}
5074  	b0 = gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, action), BPF_B,
5075  	    (bpf_u_int32)action);
5076  	return (b0);
5077  }
5078  struct block *
5079  gen_p80211_type(compiler_state_t *cstate, bpf_u_int32 type, bpf_u_int32 mask)
5080  {
5081  	struct block *b0;
5082  	if (setjmp(cstate->top_ctx))
5083  		return (NULL);
5084  	switch (cstate->linktype) {
5085  	case DLT_IEEE802_11:
5086  	case DLT_PRISM_HEADER:
5087  	case DLT_IEEE802_11_RADIO_AVS:
5088  	case DLT_IEEE802_11_RADIO:
5089  		b0 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, type, mask);
5090  		break;
5091  	default:
5092  		bpf_error(cstate, "802.11 link-layer types supported only on 802.11");
5093  	}
5094  	return (b0);
5095  }
5096  struct block *
5097  gen_p80211_fcdir(compiler_state_t *cstate, bpf_u_int32 fcdir)
5098  {
5099  	struct block *b0;
5100  	if (setjmp(cstate->top_ctx))
5101  		return (NULL);
5102  	switch (cstate->linktype) {
5103  	case DLT_IEEE802_11:
5104  	case DLT_PRISM_HEADER:
5105  	case DLT_IEEE802_11_RADIO_AVS:
5106  	case DLT_IEEE802_11_RADIO:
5107  		break;
5108  	default:
5109  		bpf_error(cstate, "frame direction supported only with 802.11 headers");
5110  	}
5111  	b0 = gen_mcmp(cstate, OR_LINKHDR, 1, BPF_B, fcdir,
5112  	    IEEE80211_FC1_DIR_MASK);
5113  	return (b0);
5114  }
5115  struct block *
5116  gen_acode(compiler_state_t *cstate, const char *s, struct qual q)
5117  {
5118  	struct block *b;
5119  	if (setjmp(cstate->top_ctx))
5120  		return (NULL);
5121  	switch (cstate->linktype) {
5122  	case DLT_ARCNET:
5123  	case DLT_ARCNET_LINUX:
5124  		if ((q.addr == Q_HOST || q.addr == Q_DEFAULT) &&
5125  		    q.proto == Q_LINK) {
5126  			cstate->e = pcap_ether_aton(s);
5127  			if (cstate->e == NULL)
5128  				bpf_error(cstate, "malloc");
5129  			b = gen_ahostop(cstate, cstate->e, (int)q.dir);
5130  			free(cstate->e);
5131  			cstate->e = NULL;
5132  			return (b);
5133  		} else
5134  			bpf_error(cstate, "ARCnet address used in non-arc expression");
5135  	default:
5136  		bpf_error(cstate, "aid supported only on ARCnet");
5137  	}
5138  }
5139  static struct block *
5140  gen_ahostop(compiler_state_t *cstate, const u_char *eaddr, int dir)
5141  {
5142  	register struct block *b0, *b1;
5143  	switch (dir) {
5144  	case Q_SRC:
5145  		return gen_bcmp(cstate, OR_LINKHDR, 0, 1, eaddr);
5146  	case Q_DST:
5147  		return gen_bcmp(cstate, OR_LINKHDR, 1, 1, eaddr);
5148  	case Q_AND:
5149  		b0 = gen_ahostop(cstate, eaddr, Q_SRC);
5150  		b1 = gen_ahostop(cstate, eaddr, Q_DST);
5151  		gen_and(b0, b1);
5152  		return b1;
5153  	case Q_DEFAULT:
5154  	case Q_OR:
5155  		b0 = gen_ahostop(cstate, eaddr, Q_SRC);
5156  		b1 = gen_ahostop(cstate, eaddr, Q_DST);
5157  		gen_or(b0, b1);
5158  		return b1;
5159  	case Q_ADDR1:
5160  		bpf_error(cstate, "'addr1' and 'address1' are only supported on 802.11");
5161  	case Q_ADDR2:
5162  		bpf_error(cstate, "'addr2' and 'address2' are only supported on 802.11");
5163  	case Q_ADDR3:
5164  		bpf_error(cstate, "'addr3' and 'address3' are only supported on 802.11");
5165  	case Q_ADDR4:
5166  		bpf_error(cstate, "'addr4' and 'address4' are only supported on 802.11");
5167  	case Q_RA:
5168  		bpf_error(cstate, "'ra' is only supported on 802.11");
5169  	case Q_TA:
5170  		bpf_error(cstate, "'ta' is only supported on 802.11");
5171  	}
5172  	abort();
5173  }
5174  static struct block *
5175  gen_vlan_tpid_test(compiler_state_t *cstate)
5176  {
5177  	struct block *b0, *b1;
5178  	b0 = gen_linktype(cstate, ETHERTYPE_8021Q);
5179  	b1 = gen_linktype(cstate, ETHERTYPE_8021AD);
5180  	gen_or(b0,b1);
5181  	b0 = b1;
5182  	b1 = gen_linktype(cstate, ETHERTYPE_8021QINQ);
5183  	gen_or(b0,b1);
5184  	return b1;
5185  }
5186  static struct block *
5187  gen_vlan_vid_test(compiler_state_t *cstate, bpf_u_int32 vlan_num)
5188  {
5189  	if (vlan_num > 0x0fff) {
5190  		bpf_error(cstate, "VLAN tag %u greater than maximum %u",
5191  		    vlan_num, 0x0fff);
5192  	}
5193  	return gen_mcmp(cstate, OR_LINKPL, 0, BPF_H, vlan_num, 0x0fff);
5194  }
5195  static struct block *
5196  gen_vlan_no_bpf_extensions(compiler_state_t *cstate, bpf_u_int32 vlan_num,
5197      int has_vlan_tag)
5198  {
5199  	struct block *b0, *b1;
5200  	b0 = gen_vlan_tpid_test(cstate);
5201  	if (has_vlan_tag) {
5202  		b1 = gen_vlan_vid_test(cstate, vlan_num);
5203  		gen_and(b0, b1);
5204  		b0 = b1;
5205  	}
5206  	cstate->off_linkpl.constant_part += 4;
5207  	cstate->off_linktype.constant_part += 4;
5208  	return b0;
5209  }
5210  #if defined(SKF_AD_VLAN_TAG_PRESENT)
5211  static void
5212  gen_vlan_vloffset_add(compiler_state_t *cstate, bpf_abs_offset *off,
5213      bpf_u_int32 v, struct slist *s)
5214  {
5215  	struct slist *s2;
5216  	if (!off->is_variable)
5217  		off->is_variable = 1;
5218  	if (off->reg == -1)
5219  		off->reg = alloc_reg(cstate);
5220  	s2 = new_stmt(cstate, BPF_LD|BPF_MEM);
5221  	s2->s.k = off->reg;
5222  	sappend(s, s2);
5223  	s2 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_IMM);
5224  	s2->s.k = v;
5225  	sappend(s, s2);
5226  	s2 = new_stmt(cstate, BPF_ST);
5227  	s2->s.k = off->reg;
5228  	sappend(s, s2);
5229  }
5230  static void
5231  gen_vlan_patch_tpid_test(compiler_state_t *cstate, struct block *b_tpid)
5232  {
5233  	struct slist s;
5234  	s.next = NULL;
5235  	cstate->is_vlan_vloffset = 1;
5236  	gen_vlan_vloffset_add(cstate, &cstate->off_linkpl, 4, &s);
5237  	gen_vlan_vloffset_add(cstate, &cstate->off_linktype, 4, &s);
5238  	sappend(s.next, b_tpid->head->stmts);
5239  	b_tpid->head->stmts = s.next;
5240  }
5241  static void
5242  gen_vlan_patch_vid_test(compiler_state_t *cstate, struct block *b_vid)
5243  {
5244  	struct slist *s, *s2, *sjeq;
5245  	unsigned cnt;
5246  	s = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);
5247  	s->s.k = SKF_AD_OFF + SKF_AD_VLAN_TAG_PRESENT;
5248  	sjeq = new_stmt(cstate, JMP(BPF_JEQ));
5249  	sjeq->s.k = 1;
5250  	sjeq->s.jf = b_vid->stmts;
5251  	sappend(s, sjeq);
5252  	s2 = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);
5253  	s2->s.k = SKF_AD_OFF + SKF_AD_VLAN_TAG;
5254  	sappend(s, s2);
5255  	sjeq->s.jt = s2;
5256  	cnt = 0;
5257  	for (s2 = b_vid->stmts; s2; s2 = s2->next)
5258  		cnt++;
5259  	s2 = new_stmt(cstate, JMP(BPF_JA));
5260  	s2->s.k = cnt - 1;
5261  	sappend(s, s2);
5262  	sappend(s, b_vid->stmts);
5263  	b_vid->stmts = s;
5264  }
5265  static struct block *
5266  gen_vlan_bpf_extensions(compiler_state_t *cstate, bpf_u_int32 vlan_num,
5267      int has_vlan_tag)
5268  {
5269          struct block *b0, *b_tpid, *b_vid = NULL;
5270          struct slist *s;
5271          s = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);
5272          s->s.k = SKF_AD_OFF + SKF_AD_VLAN_TAG_PRESENT;
5273          b0 = new_block(cstate, JMP(BPF_JEQ));
5274          b0->stmts = s;
5275          b0->s.k = 1;
5276  	b_tpid = gen_vlan_tpid_test(cstate);
5277  	if (has_vlan_tag)
5278  		b_vid = gen_vlan_vid_test(cstate, vlan_num);
5279  	gen_vlan_patch_tpid_test(cstate, b_tpid);
5280  	gen_or(b0, b_tpid);
5281  	b0 = b_tpid;
5282  	if (has_vlan_tag) {
5283  		gen_vlan_patch_vid_test(cstate, b_vid);
5284  		gen_and(b0, b_vid);
5285  		b0 = b_vid;
5286  	}
5287          return b0;
5288  }
5289  #endif
5290  struct block *
5291  gen_vlan(compiler_state_t *cstate, bpf_u_int32 vlan_num, int has_vlan_tag)
5292  {
5293  	struct	block	*b0;
5294  	if (setjmp(cstate->top_ctx))
5295  		return (NULL);
5296  	if (cstate->label_stack_depth > 0)
5297  		bpf_error(cstate, "no VLAN match after MPLS");
5298  	switch (cstate->linktype) {
5299  	case DLT_EN10MB:
5300  	case DLT_NETANALYZER:
5301  	case DLT_NETANALYZER_TRANSPARENT:
5302  #if defined(SKF_AD_VLAN_TAG_PRESENT)
5303  		if (cstate->vlan_stack_depth == 0 && !cstate->off_linkhdr.is_variable &&
5304  		    cstate->off_linkhdr.constant_part ==
5305  		    cstate->off_outermostlinkhdr.constant_part) {
5306  			if (cstate->bpf_pcap->bpf_codegen_flags & BPF_SPECIAL_VLAN_HANDLING)
5307  				b0 = gen_vlan_bpf_extensions(cstate, vlan_num,
5308  				    has_vlan_tag);
5309  			else
5310  				b0 = gen_vlan_no_bpf_extensions(cstate,
5311  				    vlan_num, has_vlan_tag);
5312  		} else
5313  #endif
5314  			b0 = gen_vlan_no_bpf_extensions(cstate, vlan_num,
5315  			    has_vlan_tag);
5316                  break;
5317  	case DLT_IEEE802_11:
5318  	case DLT_PRISM_HEADER:
5319  	case DLT_IEEE802_11_RADIO_AVS:
5320  	case DLT_IEEE802_11_RADIO:
5321  		b0 = gen_vlan_no_bpf_extensions(cstate, vlan_num, has_vlan_tag);
5322  		break;
5323  	default:
5324  		bpf_error(cstate, "no VLAN support for %s",
5325  		      pcap_datalink_val_to_description_or_dlt(cstate->linktype));
5326  	}
5327          cstate->vlan_stack_depth++;
5328  	return (b0);
5329  }
5330  struct block *
5331  gen_mpls(compiler_state_t *cstate, bpf_u_int32 label_num_arg,
5332      int has_label_num)
5333  {
5334  	volatile bpf_u_int32 label_num = label_num_arg;
5335  	struct	block	*b0, *b1;
5336  	if (setjmp(cstate->top_ctx))
5337  		return (NULL);
5338          if (cstate->label_stack_depth > 0) {
5339              b0 = gen_mcmp(cstate, OR_PREVMPLSHDR, 2, BPF_B, 0, 0x01);
5340          } else {
5341              switch (cstate->linktype) {
5342              case DLT_C_HDLC: &bsol;* fall through */
5343              case DLT_HDLC:
5344              case DLT_EN10MB:
5345              case DLT_NETANALYZER:
5346              case DLT_NETANALYZER_TRANSPARENT:
5347                      b0 = gen_linktype(cstate, ETHERTYPE_MPLS);
5348                      break;
5349              case DLT_PPP:
5350                      b0 = gen_linktype(cstate, PPP_MPLS_UCAST);
5351                      break;
5352              default:
5353                      bpf_error(cstate, "no MPLS support for %s",
5354                            pcap_datalink_val_to_description_or_dlt(cstate->linktype));
5355              }
5356          }
5357  	if (has_label_num) {
5358  		if (label_num > 0xFFFFF) {
5359  			bpf_error(cstate, "MPLS label %u greater than maximum %u",
5360  			    label_num, 0xFFFFF);
5361  		}
5362  		label_num = label_num << 12; &bsol;* label is shifted 12 bits on the wire */
5363  		b1 = gen_mcmp(cstate, OR_LINKPL, 0, BPF_W, label_num,
5364  		    0xfffff000); &bsol;* only compare the first 20 bits */
5365  		gen_and(b0, b1);
5366  		b0 = b1;
5367  	}
5368          cstate->off_nl_nosnap += 4;
5369          cstate->off_nl += 4;
5370          cstate->label_stack_depth++;
5371  	return (b0);
5372  }
5373  struct block *
5374  gen_pppoed(compiler_state_t *cstate)
5375  {
5376  	if (setjmp(cstate->top_ctx))
5377  		return (NULL);
5378  	return gen_linktype(cstate, ETHERTYPE_PPPOED);
5379  }
5380  struct block *
5381  gen_pppoes(compiler_state_t *cstate, bpf_u_int32 sess_num, int has_sess_num)
5382  {
5383  	struct block *b0, *b1;
5384  	if (setjmp(cstate->top_ctx))
5385  		return (NULL);
5386  	b0 = gen_linktype(cstate, ETHERTYPE_PPPOES);
5387  	if (has_sess_num) {
5388  		if (sess_num > 0x0000ffff) {
5389  			bpf_error(cstate, "PPPoE session number %u greater than maximum %u",
5390  			    sess_num, 0x0000ffff);
5391  		}
5392  		b1 = gen_mcmp(cstate, OR_LINKPL, 0, BPF_W, sess_num, 0x0000ffff);
5393  		gen_and(b0, b1);
5394  		b0 = b1;
5395  	}
5396  	PUSH_LINKHDR(cstate, DLT_PPP, cstate->off_linkpl.is_variable,
5397  	    cstate->off_linkpl.constant_part + cstate->off_nl + 6, &bsol;* 6 bytes past the PPPoE header */
5398  	    cstate->off_linkpl.reg);
5399  	cstate->off_linktype = cstate->off_linkhdr;
5400  	cstate->off_linkpl.constant_part = cstate->off_linkhdr.constant_part + 2;
5401  	cstate->off_nl = 0;
5402  	cstate->off_nl_nosnap = 0;	&bsol;* no 802.2 LLC */
5403  	return b0;
5404  }
5405  static struct block *
5406  gen_geneve_check(compiler_state_t *cstate,
5407      struct block *(*gen_portfn)(compiler_state_t *, u_int, int, int),
5408      enum e_offrel offrel, bpf_u_int32 vni, int has_vni)
5409  {
5410  	struct block *b0, *b1;
5411  	b0 = gen_portfn(cstate, GENEVE_PORT, IPPROTO_UDP, Q_DST);
5412  	b1 = gen_mcmp(cstate, offrel, 8, BPF_B, 0, 0xc0);
5413  	gen_and(b0, b1);
5414  	b0 = b1;
5415  	if (has_vni) {
5416  		if (vni > 0xffffff) {
5417  			bpf_error(cstate, "Geneve VNI %u greater than maximum %u",
5418  			    vni, 0xffffff);
5419  		}
5420  		vni <<= 8; &bsol;* VNI is in the upper 3 bytes */
5421  		b1 = gen_mcmp(cstate, offrel, 12, BPF_W, vni, 0xffffff00);
5422  		gen_and(b0, b1);
5423  		b0 = b1;
5424  	}
5425  	return b0;
5426  }
5427  static struct block *
5428  gen_geneve4(compiler_state_t *cstate, bpf_u_int32 vni, int has_vni)
5429  {
5430  	struct block *b0, *b1;
5431  	struct slist *s, *s1;
5432  	b0 = gen_geneve_check(cstate, gen_port, OR_TRAN_IPV4, vni, has_vni);
5433  	s = gen_loadx_iphdrlen(cstate);
5434  	s1 = new_stmt(cstate, BPF_MISC|BPF_TXA);
5435  	sappend(s, s1);
5436  	b1 = new_block(cstate, BPF_JMP|BPF_JEQ|BPF_X);
5437  	b1->stmts = s;
5438  	b1->s.k = 0;
5439  	gen_and(b0, b1);
5440  	return b1;
5441  }
5442  static struct block *
5443  gen_geneve6(compiler_state_t *cstate, bpf_u_int32 vni, int has_vni)
5444  {
5445  	struct block *b0, *b1;
5446  	struct slist *s, *s1;
5447  	b0 = gen_geneve_check(cstate, gen_port6, OR_TRAN_IPV6, vni, has_vni);
5448  	s = gen_abs_offset_varpart(cstate, &cstate->off_linkpl);
5449  	if (s) {
5450  		s1 = new_stmt(cstate, BPF_LD|BPF_IMM);
5451  		s1->s.k = 40;
5452  		sappend(s, s1);
5453  		s1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X);
5454  		s1->s.k = 0;
5455  		sappend(s, s1);
5456  	} else {
5457  		s = new_stmt(cstate, BPF_LD|BPF_IMM);
5458  		s->s.k = 40;
5459  	}
5460  	s1 = new_stmt(cstate, BPF_MISC|BPF_TAX);
5461  	sappend(s, s1);
5462  	b1 = new_block(cstate, BPF_JMP|BPF_JEQ|BPF_X);
5463  	b1->stmts = s;
5464  	b1->s.k = 0;
5465  	gen_and(b0, b1);
5466  	return b1;
5467  }
5468  static struct slist *
5469  gen_geneve_offsets(compiler_state_t *cstate)
5470  {
5471  	struct slist *s, *s1, *s_proto;
5472  	s = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);
5473  	s->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + 8;
5474  	s1 = new_stmt(cstate, BPF_MISC|BPF_TAX);
5475  	sappend(s, s1);
5476  	s1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);
5477  	s1->s.k = 2;
5478  	sappend(s, s1);
5479  	cstate->off_linktype.reg = alloc_reg(cstate);
5480  	cstate->off_linktype.is_variable = 1;
5481  	cstate->off_linktype.constant_part = 0;
5482  	s1 = new_stmt(cstate, BPF_ST);
5483  	s1->s.k = cstate->off_linktype.reg;
5484  	sappend(s, s1);
5485  	s1 = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);
5486  	s1->s.k = 0;
5487  	sappend(s, s1);
5488  	s1 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);
5489  	s1->s.k = 0x3f;
5490  	sappend(s, s1);
5491  	s1 = new_stmt(cstate, BPF_ALU|BPF_MUL|BPF_K);
5492  	s1->s.k = 4;
5493  	sappend(s, s1);
5494  	s1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);
5495  	s1->s.k = 8;
5496  	sappend(s, s1);
5497  	s1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X);
5498  	s1->s.k = 0;
5499  	sappend(s, s1);
5500  	PUSH_LINKHDR(cstate, DLT_EN10MB, 1, 0, alloc_reg(cstate));
5501  	s1 = new_stmt(cstate, BPF_ST);
5502  	s1->s.k = cstate->off_linkhdr.reg;
5503  	sappend(s, s1);
5504  	cstate->no_optimize = 1;
5505  	s1 = new_stmt(cstate, BPF_LD|BPF_IND|BPF_H);
5506  	s1->s.k = 2;
5507  	sappend(s, s1);
5508  	s1 = new_stmt(cstate, BPF_LDX|BPF_MEM);
5509  	s1->s.k = cstate->off_linkhdr.reg;
5510  	sappend(s, s1);
5511  	s_proto = new_stmt(cstate, JMP(BPF_JEQ));
5512  	s_proto->s.k = ETHERTYPE_TEB;
5513  	sappend(s, s_proto);
5514  	s1 = new_stmt(cstate, BPF_MISC|BPF_TXA);
5515  	sappend(s, s1);
5516  	s_proto->s.jt = s1;
5517  	s1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);
5518  	s1->s.k = 12;
5519  	sappend(s, s1);
5520  	s1 = new_stmt(cstate, BPF_ST);
5521  	s1->s.k = cstate->off_linktype.reg;
5522  	sappend(s, s1);
5523  	s1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);
5524  	s1->s.k = 2;
5525  	sappend(s, s1);
5526  	s1 = new_stmt(cstate, BPF_MISC|BPF_TAX);
5527  	sappend(s, s1);
5528  	cstate->off_linkpl.reg = alloc_reg(cstate);
5529  	cstate->off_linkpl.is_variable = 1;
5530  	cstate->off_linkpl.constant_part = 0;
5531  	s1 = new_stmt(cstate, BPF_STX);
5532  	s1->s.k = cstate->off_linkpl.reg;
5533  	sappend(s, s1);
5534  	s_proto->s.jf = s1;
5535  	cstate->off_nl = 0;
5536  	return s;
5537  }
5538  struct block *
5539  gen_geneve(compiler_state_t *cstate, bpf_u_int32 vni, int has_vni)
5540  {
5541  	struct block *b0, *b1;
5542  	struct slist *s;
5543  	if (setjmp(cstate->top_ctx))
5544  		return (NULL);
5545  	b0 = gen_geneve4(cstate, vni, has_vni);
5546  	b1 = gen_geneve6(cstate, vni, has_vni);
5547  	gen_or(b0, b1);
5548  	b0 = b1;
5549  	s = gen_geneve_offsets(cstate);
5550  	b1 = gen_true(cstate);
5551  	sappend(s, b1->stmts);
5552  	b1->stmts = s;
5553  	gen_and(b0, b1);
5554  	cstate->is_geneve = 1;
5555  	return b1;
5556  }
5557  static struct block *
5558  gen_geneve_ll_check(compiler_state_t *cstate)
5559  {
5560  	struct block *b0;
5561  	struct slist *s, *s1;
5562  	s = new_stmt(cstate, BPF_LD|BPF_MEM);
5563  	s->s.k = cstate->off_linkhdr.reg;
5564  	s1 = new_stmt(cstate, BPF_LDX|BPF_MEM);
5565  	s1->s.k = cstate->off_linkpl.reg;
5566  	sappend(s, s1);
5567  	b0 = new_block(cstate, BPF_JMP|BPF_JEQ|BPF_X);
5568  	b0->stmts = s;
5569  	b0->s.k = 0;
5570  	gen_not(b0);
5571  	return b0;
5572  }
5573  static struct block *
5574  gen_atmfield_code_internal(compiler_state_t *cstate, int atmfield,
5575      bpf_u_int32 jvalue, int jtype, int reverse)
5576  {
5577  	struct block *b0;
5578  	switch (atmfield) {
5579  	case A_VPI:
5580  		if (!cstate->is_atm)
5581  			bpf_error(cstate, "'vpi' supported only on raw ATM");
5582  		if (cstate->off_vpi == OFFSET_NOT_SET)
5583  			abort();
5584  		b0 = gen_ncmp(cstate, OR_LINKHDR, cstate->off_vpi, BPF_B,
5585  		    0xffffffffU, jtype, reverse, jvalue);
5586  		break;
5587  	case A_VCI:
5588  		if (!cstate->is_atm)
5589  			bpf_error(cstate, "'vci' supported only on raw ATM");
5590  		if (cstate->off_vci == OFFSET_NOT_SET)
5591  			abort();
5592  		b0 = gen_ncmp(cstate, OR_LINKHDR, cstate->off_vci, BPF_H,
5593  		    0xffffffffU, jtype, reverse, jvalue);
5594  		break;
5595  	case A_PROTOTYPE:
5596  		if (cstate->off_proto == OFFSET_NOT_SET)
5597  			abort();	&bsol;* XXX - this isn't on FreeBSD */
5598  		b0 = gen_ncmp(cstate, OR_LINKHDR, cstate->off_proto, BPF_B,
5599  		    0x0fU, jtype, reverse, jvalue);
5600  		break;
5601  	case A_MSGTYPE:
5602  		if (cstate->off_payload == OFFSET_NOT_SET)
5603  			abort();
5604  		b0 = gen_ncmp(cstate, OR_LINKHDR, cstate->off_payload + MSG_TYPE_POS, BPF_B,
5605  		    0xffffffffU, jtype, reverse, jvalue);
5606  		break;
5607  	case A_CALLREFTYPE:
5608  		if (!cstate->is_atm)
5609  			bpf_error(cstate, "'callref' supported only on raw ATM");
5610  		if (cstate->off_proto == OFFSET_NOT_SET)
5611  			abort();
5612  		b0 = gen_ncmp(cstate, OR_LINKHDR, cstate->off_proto, BPF_B,
5613  		    0xffffffffU, jtype, reverse, jvalue);
5614  		break;
5615  	default:
5616  		abort();
5617  	}
5618  	return b0;
5619  }
5620  static struct block *
5621  gen_atmtype_metac(compiler_state_t *cstate)
5622  {
5623  	struct block *b0, *b1;
5624  	b0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);
5625  	b1 = gen_atmfield_code_internal(cstate, A_VCI, 1, BPF_JEQ, 0);
5626  	gen_and(b0, b1);
5627  	return b1;
5628  }
5629  static struct block *
5630  gen_atmtype_sc(compiler_state_t *cstate)
5631  {
5632  	struct block *b0, *b1;
5633  	b0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);
5634  	b1 = gen_atmfield_code_internal(cstate, A_VCI, 5, BPF_JEQ, 0);
5635  	gen_and(b0, b1);
5636  	return b1;
5637  }
5638  static struct block *
5639  gen_atmtype_llc(compiler_state_t *cstate)
5640  {
5641  	struct block *b0;
5642  	b0 = gen_atmfield_code_internal(cstate, A_PROTOTYPE, PT_LLC, BPF_JEQ, 0);
5643  	cstate->linktype = cstate->prevlinktype;
5644  	return b0;
5645  }
5646  struct block *
5647  gen_atmfield_code(compiler_state_t *cstate, int atmfield,
5648      bpf_u_int32 jvalue, int jtype, int reverse)
5649  {
5650  	if (setjmp(cstate->top_ctx))
5651  		return (NULL);
5652  	return gen_atmfield_code_internal(cstate, atmfield, jvalue, jtype,
5653  	    reverse);
5654  }
5655  struct block *
5656  gen_atmtype_abbrev(compiler_state_t *cstate, int type)
5657  {
5658  	struct block *b0, *b1;
5659  	if (setjmp(cstate->top_ctx))
5660  		return (NULL);
5661  	switch (type) {
5662  	case A_METAC:
5663  		if (!cstate->is_atm)
5664  			bpf_error(cstate, "'metac' supported only on raw ATM");
5665  		b1 = gen_atmtype_metac(cstate);
5666  		break;
5667  	case A_BCC:
5668  		if (!cstate->is_atm)
5669  			bpf_error(cstate, "'bcc' supported only on raw ATM");
5670  		b0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);
5671  		b1 = gen_atmfield_code_internal(cstate, A_VCI, 2, BPF_JEQ, 0);
5672  		gen_and(b0, b1);
5673  		break;
5674  	case A_OAMF4SC:
5675  		if (!cstate->is_atm)
5676  			bpf_error(cstate, "'oam4sc' supported only on raw ATM");
5677  		b0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);
5678  		b1 = gen_atmfield_code_internal(cstate, A_VCI, 3, BPF_JEQ, 0);
5679  		gen_and(b0, b1);
5680  		break;
5681  	case A_OAMF4EC:
5682  		if (!cstate->is_atm)
5683  			bpf_error(cstate, "'oam4ec' supported only on raw ATM");
5684  		b0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);
5685  		b1 = gen_atmfield_code_internal(cstate, A_VCI, 4, BPF_JEQ, 0);
5686  		gen_and(b0, b1);
5687  		break;
5688  	case A_SC:
5689  		if (!cstate->is_atm)
5690  			bpf_error(cstate, "'sc' supported only on raw ATM");
5691  		b1 = gen_atmtype_sc(cstate);
5692  		break;
5693  	case A_ILMIC:
5694  		if (!cstate->is_atm)
5695  			bpf_error(cstate, "'ilmic' supported only on raw ATM");
5696  		b0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);
5697  		b1 = gen_atmfield_code_internal(cstate, A_VCI, 16, BPF_JEQ, 0);
5698  		gen_and(b0, b1);
5699  		break;
5700  	case A_LANE:
5701  		if (!cstate->is_atm)
5702  			bpf_error(cstate, "'lane' supported only on raw ATM");
5703  		b1 = gen_atmfield_code_internal(cstate, A_PROTOTYPE, PT_LANE, BPF_JEQ, 0);
5704  		PUSH_LINKHDR(cstate, DLT_EN10MB, 0,
5705  		    cstate->off_payload + 2,	&bsol;* Ethernet header */
5706  		    -1);
5707  		cstate->off_linktype.constant_part = cstate->off_linkhdr.constant_part + 12;
5708  		cstate->off_linkpl.constant_part = cstate->off_linkhdr.constant_part + 14;	&bsol;* Ethernet */
5709  		cstate->off_nl = 0;			&bsol;* Ethernet II */
5710  		cstate->off_nl_nosnap = 3;		&bsol;* 802.3+802.2 */
5711  		break;
5712  	case A_LLC:
5713  		if (!cstate->is_atm)
5714  			bpf_error(cstate, "'llc' supported only on raw ATM");
5715  		b1 = gen_atmtype_llc(cstate);
5716  		break;
5717  	default:
5718  		abort();
5719  	}
5720  	return b1;
5721  }
5722  struct block *
5723  gen_mtp2type_abbrev(compiler_state_t *cstate, int type)
5724  {
5725  	struct block *b0, *b1;
5726  	if (setjmp(cstate->top_ctx))
5727  		return (NULL);
5728  	switch (type) {
5729  	case M_FISU:
5730  		if ( (cstate->linktype != DLT_MTP2) &&
5731  		     (cstate->linktype != DLT_ERF) &&
5732  		     (cstate->linktype != DLT_MTP2_WITH_PHDR) )
5733  			bpf_error(cstate, "'fisu' supported only on MTP2");
5734  		b0 = gen_ncmp(cstate, OR_PACKET, cstate->off_li, BPF_B,
5735  		    0x3fU, BPF_JEQ, 0, 0U);
5736  		break;
5737  	case M_LSSU:
5738  		if ( (cstate->linktype != DLT_MTP2) &&
5739  		     (cstate->linktype != DLT_ERF) &&
5740  		     (cstate->linktype != DLT_MTP2_WITH_PHDR) )
5741  			bpf_error(cstate, "'lssu' supported only on MTP2");
5742  		b0 = gen_ncmp(cstate, OR_PACKET, cstate->off_li, BPF_B,
5743  		    0x3fU, BPF_JGT, 1, 2U);
5744  		b1 = gen_ncmp(cstate, OR_PACKET, cstate->off_li, BPF_B,
5745  		    0x3fU, BPF_JGT, 0, 0U);
5746  		gen_and(b1, b0);
5747  		break;
5748  	case M_MSU:
5749  		if ( (cstate->linktype != DLT_MTP2) &&
5750  		     (cstate->linktype != DLT_ERF) &&
5751  		     (cstate->linktype != DLT_MTP2_WITH_PHDR) )
5752  			bpf_error(cstate, "'msu' supported only on MTP2");
5753  		b0 = gen_ncmp(cstate, OR_PACKET, cstate->off_li, BPF_B,
5754  		    0x3fU, BPF_JGT, 0, 2U);
5755  		break;
5756  	case MH_FISU:
5757  		if ( (cstate->linktype != DLT_MTP2) &&
5758  		     (cstate->linktype != DLT_ERF) &&
5759  		     (cstate->linktype != DLT_MTP2_WITH_PHDR) )
5760  			bpf_error(cstate, "'hfisu' supported only on MTP2_HSL");
5761  		b0 = gen_ncmp(cstate, OR_PACKET, cstate->off_li_hsl, BPF_H,
5762  		    0xff80U, BPF_JEQ, 0, 0U);
5763  		break;
5764  	case MH_LSSU:
5765  		if ( (cstate->linktype != DLT_MTP2) &&
5766  		     (cstate->linktype != DLT_ERF) &&
5767  		     (cstate->linktype != DLT_MTP2_WITH_PHDR) )
5768  			bpf_error(cstate, "'hlssu' supported only on MTP2_HSL");
5769  		b0 = gen_ncmp(cstate, OR_PACKET, cstate->off_li_hsl, BPF_H,
5770  		    0xff80U, BPF_JGT, 1, 0x0100U);
5771  		b1 = gen_ncmp(cstate, OR_PACKET, cstate->off_li_hsl, BPF_H,
5772  		    0xff80U, BPF_JGT, 0, 0U);
5773  		gen_and(b1, b0);
5774  		break;
5775  	case MH_MSU:
5776  		if ( (cstate->linktype != DLT_MTP2) &&
5777  		     (cstate->linktype != DLT_ERF) &&
5778  		     (cstate->linktype != DLT_MTP2_WITH_PHDR) )
5779  			bpf_error(cstate, "'hmsu' supported only on MTP2_HSL");
5780  		b0 = gen_ncmp(cstate, OR_PACKET, cstate->off_li_hsl, BPF_H,
5781  		    0xff80U, BPF_JGT, 0, 0x0100U);
5782  		break;
5783  	default:
5784  		abort();
5785  	}
5786  	return b0;
5787  }
5788  struct block *
5789  gen_mtp3field_code(compiler_state_t *cstate, int mtp3field,
5790      bpf_u_int32 jvalue_arg, int jtype, int reverse)
5791  {
5792  	volatile bpf_u_int32 jvalue = jvalue_arg;
5793  	struct block *b0;
5794  	bpf_u_int32 val1 , val2 , val3;
5795  	u_int newoff_sio;
5796  	u_int newoff_opc;
5797  	u_int newoff_dpc;
5798  	u_int newoff_sls;
5799  	if (setjmp(cstate->top_ctx))
5800  		return (NULL);
5801  	newoff_sio = cstate->off_sio;
5802  	newoff_opc = cstate->off_opc;
5803  	newoff_dpc = cstate->off_dpc;
5804  	newoff_sls = cstate->off_sls;
5805  	switch (mtp3field) {
5806  	case MH_SIO:
5807  		newoff_sio += 3; &bsol;* offset for MTP2_HSL */
5808  	case M_SIO:
5809  		if (cstate->off_sio == OFFSET_NOT_SET)
5810  			bpf_error(cstate, "'sio' supported only on SS7");
5811  		if(jvalue > 255)
5812  		        bpf_error(cstate, "sio value %u too big; max value = 255",
5813  		            jvalue);
5814  		b0 = gen_ncmp(cstate, OR_PACKET, newoff_sio, BPF_B, 0xffffffffU,
5815  		    jtype, reverse, jvalue);
5816  		break;
5817  	case MH_OPC:
5818  		newoff_opc += 3;
5819          case M_OPC:
5820  	        if (cstate->off_opc == OFFSET_NOT_SET)
5821  			bpf_error(cstate, "'opc' supported only on SS7");
5822  		if (jvalue > 16383)
5823  		        bpf_error(cstate, "opc value %u too big; max value = 16383",
5824  		            jvalue);
5825  		val1 = jvalue & 0x00003c00;
5826  		val1 = val1 >>10;
5827  		val2 = jvalue & 0x000003fc;
5828  		val2 = val2 <<6;
5829  		val3 = jvalue & 0x00000003;
5830  		val3 = val3 <<22;
5831  		jvalue = val1 + val2 + val3;
5832  		b0 = gen_ncmp(cstate, OR_PACKET, newoff_opc, BPF_W, 0x00c0ff0fU,
5833  		    jtype, reverse, jvalue);
5834  		break;
5835  	case MH_DPC:
5836  		newoff_dpc += 3;
5837  	case M_DPC:
5838  	        if (cstate->off_dpc == OFFSET_NOT_SET)
5839  			bpf_error(cstate, "'dpc' supported only on SS7");
5840  		if (jvalue > 16383)
5841  		        bpf_error(cstate, "dpc value %u too big; max value = 16383",
5842  		            jvalue);
5843  		val1 = jvalue & 0x000000ff;
5844  		val1 = val1 << 24;
5845  		val2 = jvalue & 0x00003f00;
5846  		val2 = val2 << 8;
5847  		jvalue = val1 + val2;
5848  		b0 = gen_ncmp(cstate, OR_PACKET, newoff_dpc, BPF_W, 0xff3f0000U,
5849  		    jtype, reverse, jvalue);
5850  		break;
5851  	case MH_SLS:
5852  		newoff_sls += 3;
5853  	case M_SLS:
5854  	        if (cstate->off_sls == OFFSET_NOT_SET)
<span onclick='openModal()' class='match'>5855  			bpf_error(cstate, "'sls' supported only on SS7");
5856  		if (jvalue > 15)
5857  		         bpf_error(cstate, "sls value %u too big; max value = 15",
5858  		             jvalue);
5859  		jvalue = jvalue << 4;
</span>5860  		b0 = gen_ncmp(cstate, OR_PACKET, newoff_sls, BPF_B, 0xf0U,
5861  		    jtype, reverse, jvalue);
5862  		break;
5863  	default:
5864  		abort();
5865  	}
5866  	return b0;
5867  }
5868  static struct block *
5869  gen_msg_abbrev(compiler_state_t *cstate, int type)
5870  {
5871  	struct block *b1;
5872  	switch (type) {
5873  	case A_SETUP:
5874  		b1 = gen_atmfield_code_internal(cstate, A_MSGTYPE, SETUP, BPF_JEQ, 0);
5875  		break;
5876  	case A_CALLPROCEED:
5877  		b1 = gen_atmfield_code_internal(cstate, A_MSGTYPE, CALL_PROCEED, BPF_JEQ, 0);
5878  		break;
5879  	case A_CONNECT:
5880  		b1 = gen_atmfield_code_internal(cstate, A_MSGTYPE, CONNECT, BPF_JEQ, 0);
5881  		break;
5882  	case A_CONNECTACK:
5883  		b1 = gen_atmfield_code_internal(cstate, A_MSGTYPE, CONNECT_ACK, BPF_JEQ, 0);
5884  		break;
5885  	case A_RELEASE:
5886  		b1 = gen_atmfield_code_internal(cstate, A_MSGTYPE, RELEASE, BPF_JEQ, 0);
5887  		break;
5888  	case A_RELEASE_DONE:
5889  		b1 = gen_atmfield_code_internal(cstate, A_MSGTYPE, RELEASE_DONE, BPF_JEQ, 0);
5890  		break;
5891  	default:
5892  		abort();
5893  	}
5894  	return b1;
5895  }
5896  struct block *
5897  gen_atmmulti_abbrev(compiler_state_t *cstate, int type)
5898  {
5899  	struct block *b0, *b1;
5900  	if (setjmp(cstate->top_ctx))
5901  		return (NULL);
5902  	switch (type) {
5903  	case A_OAM:
5904  		if (!cstate->is_atm)
5905  			bpf_error(cstate, "'oam' supported only on raw ATM");
5906  		b0 = gen_atmfield_code_internal(cstate, A_VCI, 3, BPF_JEQ, 0);
5907  		b1 = gen_atmfield_code_internal(cstate, A_VCI, 4, BPF_JEQ, 0);
5908  		gen_or(b0, b1);
5909  		b0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);
5910  		gen_and(b0, b1);
5911  		break;
5912  	case A_OAMF4:
5913  		if (!cstate->is_atm)
5914  			bpf_error(cstate, "'oamf4' supported only on raw ATM");
5915  		b0 = gen_atmfield_code_internal(cstate, A_VCI, 3, BPF_JEQ, 0);
5916  		b1 = gen_atmfield_code_internal(cstate, A_VCI, 4, BPF_JEQ, 0);
5917  		gen_or(b0, b1);
5918  		b0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);
5919  		gen_and(b0, b1);
5920  		break;
5921  	case A_CONNECTMSG:
5922  		if (!cstate->is_atm)
5923  			bpf_error(cstate, "'connectmsg' supported only on raw ATM");
5924  		b0 = gen_msg_abbrev(cstate, A_SETUP);
5925  		b1 = gen_msg_abbrev(cstate, A_CALLPROCEED);
5926  		gen_or(b0, b1);
5927  		b0 = gen_msg_abbrev(cstate, A_CONNECT);
5928  		gen_or(b0, b1);
5929  		b0 = gen_msg_abbrev(cstate, A_CONNECTACK);
5930  		gen_or(b0, b1);
5931  		b0 = gen_msg_abbrev(cstate, A_RELEASE);
5932  		gen_or(b0, b1);
5933  		b0 = gen_msg_abbrev(cstate, A_RELEASE_DONE);
5934  		gen_or(b0, b1);
5935  		b0 = gen_atmtype_sc(cstate);
5936  		gen_and(b0, b1);
5937  		break;
5938  	case A_METACONNECT:
5939  		if (!cstate->is_atm)
5940  			bpf_error(cstate, "'metaconnect' supported only on raw ATM");
5941  		b0 = gen_msg_abbrev(cstate, A_SETUP);
5942  		b1 = gen_msg_abbrev(cstate, A_CALLPROCEED);
5943  		gen_or(b0, b1);
5944  		b0 = gen_msg_abbrev(cstate, A_CONNECT);
5945  		gen_or(b0, b1);
5946  		b0 = gen_msg_abbrev(cstate, A_RELEASE);
5947  		gen_or(b0, b1);
5948  		b0 = gen_msg_abbrev(cstate, A_RELEASE_DONE);
5949  		gen_or(b0, b1);
5950  		b0 = gen_atmtype_metac(cstate);
5951  		gen_and(b0, b1);
5952  		break;
5953  	default:
5954  		abort();
5955  	}
5956  	return b1;
5957  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-gencode.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-gencode.c</div>
                </div>
                <div class="column column_space"><pre><code>5821  			bpf_error(cstate, "'opc' supported only on SS7");
5822  		if (jvalue > 16383)
5823  		        bpf_error(cstate, "opc value %u too big; max value = 16383",
5824  		            jvalue);
5825  		val1 = jvalue & 0x00003c00;
</pre></code></div>
                <div class="column column_space"><pre><code>5855  			bpf_error(cstate, "'sls' supported only on SS7");
5856  		if (jvalue > 15)
5857  		         bpf_error(cstate, "sls value %u too big; max value = 15",
5858  		             jvalue);
5859  		jvalue = jvalue << 4;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    