<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for react_outc.c &amp; grid_util.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for react_outc.c &amp; grid_util.c
      </h3>
<h1 align="center">
        1.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>react_outc.c (1.9607843%)<th>grid_util.c (1.3196481%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1690-1705)<td><a href="#" name="0">(1921-1927)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1634-1637)<td><a href="#" name="1">(1375-1378)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(516-524)<td><a href="#" name="2">(2019-2030)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>react_outc.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;string.h&gt;
3 #include &lt;math.h&gt;
4 #include &lt;stdlib.h&gt;
5 #include &lt;assert.h&gt;
6 #include &lt;vector&gt;
7 #include "logging.h"
8 #include "rng.h"
9 #include "util.h"
10 #include "grid_util.h"
11 #include "count_util.h"
12 #include "react.h"
13 #include "vol_util.h"
14 #include "wall_util.h"
15 #include "nfsim_func.h"
16 #include "mcell_reactions.h"
17 #include "diffuse.h"
18 #include "debug_config.h"
19 #include "debug.h"
20 #include "dump_state.h"
21 static int outcome_products_random(struct volume *world, struct wall *w,
22                                    struct vector3 *hitpt, double t,
23                                    struct rxn *rx, int path,
24                                    struct abstract_molecule *reacA,
25                                    struct abstract_molecule *reacB,
26                                    short orientA, short orientB);
27 static int cleanup_and_block_rx(struct tile_neighbor *tn1, struct tile_neighbor *tn2);
28 int is_compatible_surface(void *req_species, struct wall *w) {
29   struct surf_class_list *scl, *scl2;
30   struct surf_class_list *rs_head = (struct surf_class_list *)req_species;
31   if (rs_head == NULL)
32     return 1;
33   for (scl = w-&gt;surf_class_head; scl != NULL; scl = scl-&gt;next) {
34     for (scl2 = rs_head; scl2 != NULL; scl2 = scl2-&gt;next) {
35       if (scl-&gt;surf_class == scl2-&gt;surf_class)
36         return 1;
37     }
38   }
39   return 0;
40 }
41 void add_reactants_to_product_list(struct rxn *rx, struct abstract_molecule *reacA,
42   struct abstract_molecule *reacB, struct abstract_molecule *reacC,
43   struct abstract_molecule **player, char *player_type) {
44   player[0] = reacA;
45   player_type[0] = IS_SURF_MOL(reacA) ? PLAYER_SURF_MOL : PLAYER_VOL_MOL;
46   if (rx-&gt;n_reactants &gt; 1) {
47     if (reacB == NULL) {
48       assert(rx-&gt;n_reactants == 2);
49       player[1] = NULL;
50       player_type[1] = PLAYER_WALL;
51     } else {        player[1] = reacB;
52       player_type[1] = IS_SURF_MOL(reacB) ? PLAYER_SURF_MOL : PLAYER_VOL_MOL;
53     }
54     if (rx-&gt;n_reactants &gt; 2) {
55       if (reacC == NULL) {
56         player[2] = NULL;
57         player_type[2] = PLAYER_WALL;
58       } else {
59         player[2] = reacC;
60         player_type[2] = IS_SURF_MOL(reacC) ? PLAYER_SURF_MOL : PLAYER_VOL_MOL;
61       }
62     }
63   }
64 }
65 static bool is_rxn_unimol(struct rxn *rx) {
66   if (rx-&gt;n_reactants == 1)
67     return true;
68   if (rx-&gt;n_reactants != 2)
69     return false;
70   if (!(rx-&gt;players[0]-&gt;flags &amp; ON_GRID))
71     return false;
72   return (rx-&gt;players[1]-&gt;flags &amp; IS_SURFACE) != 0;
73 }
74 void tiny_diffuse_3D(
75     struct volume *world,
76     struct subvolume *subvol,
77     struct vector3 *displacement,
78     struct vector3 *pos,
79     struct wall *w) {
80   struct vector3 temp_displacement = {
81     displacement-&gt;x,
82     displacement-&gt;y,
83     displacement-&gt;z
84   };
85   struct collision *shead = ray_trace(
86       world, pos, NULL, subvol, &amp;temp_displacement, w);
87   if (shead-&gt;next != NULL) {
88     shead = (struct collision *)ae_list_sort((struct abstract_element *)shead);
89   }
90   struct collision *smash = NULL;
91   for (smash = shead; smash != NULL; smash = smash-&gt;next) {
92     if ((smash-&gt;what &amp; COLLIDE_WALL) != 0) {
93       vectorize(pos, &amp;(smash-&gt;loc), displacement);
94       scalar_prod(displacement, 0.5, displacement);
95       break;
96     }
97   }
98   pos-&gt;x += displacement-&gt;x;
99   pos-&gt;y += displacement-&gt;y;
100   pos-&gt;z += displacement-&gt;z;
101   subvol = find_subvolume(world, pos, subvol);
102 }
103 struct volume_molecule *
104 place_volume_product(struct volume *world, struct species *product_species, struct graph_data* graph,
105                      struct surface_molecule *sm_reactant, struct wall *w,
106                      struct subvolume *subvol, struct vector3 *hitpt,
107                      short orient, double t, struct periodic_image *periodic_box) {
108   struct vector3 pos = *hitpt;
109   if (w) {
110     double bump = (orient &gt; 0) ? EPS_C : -EPS_C;
111     struct vector3 displacement = {2 * bump * w-&gt;normal.x,
112                                    2 * bump * w-&gt;normal.y,
113                                    2 * bump * w-&gt;normal.z,
114                                   };
115     tiny_diffuse_3D(world, subvol, &amp;displacement, &amp;pos, w);
116   }
117   struct volume_molecule *new_volume_mol;
118   new_volume_mol =
119       (struct volume_molecule *)CHECKED_MEM_GET(subvol-&gt;local_storage-&gt;mol, "volume molecule");
120   new_volume_mol-&gt;birthplace = subvol-&gt;local_storage-&gt;mol;
121   new_volume_mol-&gt;birthday = convert_iterations_to_seconds(
122       world-&gt;start_iterations, world-&gt;time_unit,
123       world-&gt;simulation_start_seconds, t);
124   new_volume_mol-&gt;id = world-&gt;current_mol_id++;
125   new_volume_mol-&gt;t = t;
126   new_volume_mol-&gt;t2 = 0.0;
127   new_volume_mol-&gt;periodic_box = CHECKED_MALLOC_STRUCT(struct periodic_image,
128     "periodic image descriptor");
129   new_volume_mol-&gt;periodic_box-&gt;x = periodic_box-&gt;x;
130   new_volume_mol-&gt;periodic_box-&gt;y = periodic_box-&gt;y;
131   new_volume_mol-&gt;periodic_box-&gt;z = periodic_box-&gt;z;
132   new_volume_mol-&gt;properties = product_species;
133   new_volume_mol-&gt;graph_data = graph;
134   initialize_diffusion_function((struct abstract_molecule*) new_volume_mol);
135   new_volume_mol-&gt;prev_v = NULL;
136   new_volume_mol-&gt;next_v = NULL;
137   new_volume_mol-&gt;pos = pos;
138   new_volume_mol-&gt;subvol = subvol;
139   new_volume_mol-&gt;index = 0;
140   new_volume_mol-&gt;flags = TYPE_VOL | ACT_NEWBIE | IN_VOLUME | IN_SCHEDULE;
141   if (new_volume_mol-&gt;get_space_step(new_volume_mol) &gt; 0.0)
142     new_volume_mol-&gt;flags |= ACT_DIFFUSE;
143   if ((product_species-&gt;flags &amp; COUNT_SOME_MASK) != 0)
144     new_volume_mol-&gt;flags |= COUNT_ME;
145   if (trigger_unimolecular(world-&gt;reaction_hash, world-&gt;rx_hashsize,
146                            product_species-&gt;hashval,
147                            (struct abstract_molecule *)new_volume_mol) != NULL)
148     new_volume_mol-&gt;flags |= ACT_REACT;
149   if (sm_reactant &amp;&amp; distinguishable(new_volume_mol-&gt;get_diffusion(new_volume_mol), 0, EPS_C)) {
150     new_volume_mol-&gt;previous_wall = sm_reactant-&gt;grid-&gt;surface;
151     new_volume_mol-&gt;index = sm_reactant-&gt;grid_index;
152   }
153   else {
154     new_volume_mol-&gt;previous_wall = NULL;
155     new_volume_mol-&gt;index = -1;
156   }
157   if (w) {
158     if (world-&gt;surface_reversibility) {
159       new_volume_mol-&gt;previous_wall = w;
160       new_volume_mol-&gt;index = (orient &gt; 0) ? 1 : -1;
161       new_volume_mol-&gt;flags |= ACT_CLAMPED;
162     }
163   } else if (world-&gt;volume_reversibility) {
164     new_volume_mol-&gt;index = world-&gt;dissociation_index;
165     new_volume_mol-&gt;flags |= ACT_CLAMPED;
166   }
167   ht_add_molecule_to_list(&amp;new_volume_mol-&gt;subvol-&gt;mol_by_species,
168                           new_volume_mol);
169   ++new_volume_mol-&gt;subvol-&gt;mol_count;
170   if (schedule_add_mol(subvol-&gt;local_storage-&gt;timer, new_volume_mol))
171     mcell_allocfailed("Failed to add newly created %s molecule to scheduler.",
172                       product_species-&gt;sym-&gt;name);
173   return new_volume_mol;
174 }
175 struct surface_molecule *
176 place_sm_product(struct volume *world, struct species *product_species, struct graph_data* graph,
177                  struct surface_grid *grid, int grid_index,
178                  struct vector2 *mol_uv_pos, short orient, double t,
179                  struct periodic_image *periodic_box) {
180   struct vector3 mol_xyz_pos;
181   uv2xyz(mol_uv_pos, grid-&gt;surface, &amp;mol_xyz_pos);
182   struct subvolume *sv = find_subvolume(world, &amp;mol_xyz_pos, grid-&gt;subvol);
183   struct surface_molecule *new_surf_mol;
184   new_surf_mol = (struct surface_molecule *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;smol, "surface molecule");
185   new_surf_mol-&gt;birthplace = sv-&gt;local_storage-&gt;smol;
186   new_surf_mol-&gt;birthday = convert_iterations_to_seconds(
187       world-&gt;start_iterations, world-&gt;time_unit,
188       world-&gt;simulation_start_seconds, t);
189   new_surf_mol-&gt;id = world-&gt;current_mol_id++;
190   new_surf_mol-&gt;t = t;
191   new_surf_mol-&gt;t2 = 0.0;
192   new_surf_mol-&gt;properties = product_species;
193   new_surf_mol-&gt;graph_data = graph;
194   initialize_diffusion_function((struct abstract_molecule*) new_surf_mol);
195   new_surf_mol-&gt;periodic_box = CHECKED_MALLOC_STRUCT(struct periodic_image,
196     "periodic image descriptor");
197   new_surf_mol-&gt;periodic_box-&gt;x = periodic_box-&gt;x;
198   new_surf_mol-&gt;periodic_box-&gt;y = periodic_box-&gt;y;
199   new_surf_mol-&gt;periodic_box-&gt;z = periodic_box-&gt;z;
200   new_surf_mol-&gt;flags = TYPE_SURF | ACT_NEWBIE | IN_SCHEDULE;
201   if (new_surf_mol-&gt;get_space_step(new_surf_mol) &gt; 0)
202     new_surf_mol-&gt;flags |= ACT_DIFFUSE;
203   if (product_species-&gt;flags &amp; COUNT_ENCLOSED)
204     new_surf_mol-&gt;flags |= COUNT_ME;
205   new_surf_mol-&gt;grid = grid;
206   new_surf_mol-&gt;grid_index = grid_index;
207   new_surf_mol-&gt;s_pos = *mol_uv_pos;
208   new_surf_mol-&gt;orient = orient;
209   if (trigger_unimolecular(world-&gt;reaction_hash, world-&gt;rx_hashsize,
210                            product_species-&gt;hashval,
211                            (struct abstract_molecule *)new_surf_mol) != NULL ||
212       (product_species-&gt;flags &amp; CAN_SURFWALL) != 0)
213     new_surf_mol-&gt;flags |= ACT_REACT;
214   ++grid-&gt;n_occupied;
215   if (grid-&gt;sm_list[grid_index]) {
216     remove_surfmol_from_list(
217         &amp;grid-&gt;sm_list[grid_index], grid-&gt;sm_list[grid_index]-&gt;sm);
218   }
219   grid-&gt;sm_list[grid_index] = add_surfmol_with_unique_pb_to_list(
220     grid-&gt;sm_list[grid_index], new_surf_mol);
221   if (schedule_add_mol(sv-&gt;local_storage-&gt;timer, new_surf_mol))
222     mcell_allocfailed("Failed to add newly created %s molecule to scheduler.",
223                       product_species-&gt;sym-&gt;name);
224   return new_surf_mol;
225 }
226 static int outcome_products_random(struct volume *world, struct wall *w,
227                                    struct vector3 *hitpt, double t,
228                                    struct rxn *rx, int path,
229                                    struct abstract_molecule *reacA,
230                                    struct abstract_molecule *reacB,
231                                    short orientA, short orientB) {
232 #ifdef DEBUG_RXNS
233   DUMP_CONDITION3(
234     dump_processing_reaction(world-&gt;current_iterations, hitpt, t, rx, reacA, reacB, w);
235     dump_molecule_species(reacA);
236     if (reacB != nullptr) {
237       mcell_log(" + ");
238       dump_molecule_species(reacB);
239     }
240     mcell_log("\nreaction_index: %d\n", path);
241     dump_rxn(rx, "", true);
242   );
243 #endif
244   bool cross_wall = false; 
245   int const i0 = rx-&gt;product_idx[path]; 
246   int const iN = rx-&gt;product_idx[path + 1]; 
247   assert(iN &gt; i0);
248   struct species **rx_players = rx-&gt;players + i0; 
249   int const n_players = iN - i0;                  std::vector&lt;struct abstract_molecule *&gt; product(n_players);   std::vector&lt;char&gt; product_type(n_players);
250   std::vector&lt;short&gt; product_orient(n_players);   std::vector&lt;struct surface_grid *&gt; product_grid(n_players);
251   std::vector&lt;int&gt; product_grid_idx(n_players);   std::vector&lt;byte&gt; product_flag(n_players);    
252   bool const is_unimol = is_rxn_unimol(rx);
253   struct surface_grid *tile_grid;   int num_vacant_tiles = 0;       
254   unsigned int reac_idx = UINT_MAX;
255   struct surface_grid *reac_grid = NULL, *mol_grid = NULL;
256   for (int i = 0; i &lt; n_players; ++i) {
257     product[i] = NULL;
258     product_type[i] = PLAYER_NONE;
259     product_orient[i] = 0;
260     product_grid[i] = NULL;
261     product_grid_idx[i] = -1;
262     product_flag[i] = PRODUCT_FLAG_NOT_SET;
263   }
264   struct surface_molecule *const sm_1 =
265       IS_SURF_MOL(reacA) ? (struct surface_molecule *)reacA : NULL;
266   struct surface_molecule *const sm_2 =
267       IS_SURF_MOL(reacB) ? (struct surface_molecule *)reacB : NULL;
268   struct surface_molecule *const sm_reactant = sm_1 ? sm_1 : sm_2;
269   bool const is_orientable = (w != NULL) || (sm_reactant != NULL);
270   struct region_list *rlp_head_wall_1 = NULL, *rlp_head_wall_2 = NULL;
271   struct region_list *rlp_head_obj_1 = NULL, *rlp_head_obj_2 = NULL;
272   int sm_bitmask = determine_molecule_region_topology(
273       world, sm_1, sm_2, &amp;rlp_head_wall_1, &amp;rlp_head_wall_2, &amp;rlp_head_obj_1,
274       &amp;rlp_head_obj_2, is_unimol);
275   struct abstract_molecule *const initiator = reacA;
276   short const initiatorOrient = orientA;
277   assert(reacA != NULL);
278   if (reacA-&gt;properties != rx-&gt;players[0]) {
279     struct abstract_molecule *tmp_mol = reacA;
280     reacA = reacB;
281     reacB = tmp_mol;
282     short tmp_orient = orientA;
283     orientA = orientB;
284     orientB = tmp_orient;
285   }
286   assert(reacA != NULL);
287   add_reactants_to_product_list(rx, reacA, reacB, NULL, &amp;product[0], &amp;product_type[0]);
288   int replace_p1 = (product_type[0] == PLAYER_SURF_MOL &amp;&amp; rx_players[0] == NULL);
289   int replace_p2 = rx-&gt;n_reactants &gt; 1 &amp;&amp; (product_type[1] == PLAYER_SURF_MOL &amp;&amp;
290                                            rx_players[1] == NULL);
291   struct vector2 rxn_uv_pos;   int rxn_uv_idx = -1;         int num_surface_static_reactants = 0;   if (is_orientable) {
292     if (sm_reactant) {
293       rxn_uv_pos = sm_reactant-&gt;s_pos;
294     } else {
295       xyz2uv(hitpt, w, &amp;rxn_uv_pos);
296     }
297     assert(w != NULL);
298     if (w-&gt;grid == NULL) {
299       assert(!IS_SURF_MOL(reacA));
300       if (create_grid(world, w, ((struct volume_molecule *)reacA)-&gt;subvol))
301         mcell_allocfailed("Failed to create a grid for a wall.");
302     }
303     rxn_uv_idx = uv2grid(&amp;rxn_uv_pos, w-&gt;grid);
304     if ((sm_1 != NULL) &amp;&amp; (!distinguishable(sm_1-&gt;get_diffusion(sm_1), 0, EPS_C))){
305       num_surface_static_reactants++;
306     }
307     if ((sm_2 != NULL) &amp;&amp; (!distinguishable(sm_2-&gt;get_diffusion(sm_2), 0, EPS_C))){
308       num_surface_static_reactants++;
309     }
310   }
311   int num_surface_products = 0;
312   int num_surface_static_products = 0;   for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
313     if (rx_players[n_product] == NULL) {
314       continue;
315     }
316     if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
317       num_surface_products++;
318       if (!distinguishable(rx_players[n_product]-&gt;D, 0, EPS_C))
319         num_surface_static_products++;
320     }
321   }
322   int mol_idx = INT_MAX;
323   struct tile_neighbor *tile_nbr_head = NULL;   int tile_nbr_list_length = 0;
324   struct tile_neighbor *tile_vacant_nbr_head = NULL;   if (is_orientable) {
325     if (num_surface_products &gt; 0) {
326       if (sm_reactant != NULL) {
327         find_neighbor_tiles(world, sm_reactant, sm_reactant-&gt;grid,
328                             sm_reactant-&gt;grid_index, 1, 0, &amp;tile_nbr_head,
329                             &amp;tile_nbr_list_length);
330       } else {
331         find_neighbor_tiles(world, sm_reactant, w-&gt;grid, rxn_uv_idx, 1, 0,
332                             &amp;tile_nbr_head, &amp;tile_nbr_list_length);
333       }
334       for (struct tile_neighbor *tile_nbr = tile_nbr_head; tile_nbr != NULL;
335            tile_nbr = tile_nbr-&gt;next) {
336         struct surface_molecule_list *sm_list = tile_nbr-&gt;grid-&gt;sm_list[tile_nbr-&gt;idx]; 
337         if (sm_list == NULL || sm_list-&gt;sm == NULL) {
338           num_vacant_tiles++;
339 <a name="2"></a>          push_tile_neighbor_to_list(&amp;tile_vacant_nbr_head, tile_nbr-&gt;grid, tile_nbr-&gt;idx);
340         }
341       }
342 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    }
343     int num_recycled_tiles = 0;
344     if (replace_p1 &amp;&amp; replace_p2) {
345       num_recycled_tiles = 2;
346     } else if (replace_p1 || replace_p2) {
347       num_recycled_tiles = 1;
348     }</b></font>
349     if (num_surface_products &gt; num_vacant_tiles + num_recycled_tiles) {
350       return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
351     }
352     for (int n_product = 0; n_product &lt; n_players; ++n_product) {
353       if (rx_players[n_product] == NULL) {
354         continue;
355       }
356       int this_geometry = rx-&gt;geometries[i0 + n_product];
357       int relative_orient = (this_geometry &lt; 0) ? -1 : 1;
358       this_geometry = abs(this_geometry);
359       if (this_geometry == 0) {
360         product_orient[n_product] = (rng_uint(world-&gt;rng) &amp; 1) ? 1 : -1;
361       } else {
362         if (this_geometry &gt; (int)rx-&gt;n_reactants) {
363           product_orient[n_product] = relative_orient *
364               product_orient[this_geometry - rx-&gt;n_reactants - 1];
365         } else if (this_geometry == 1) {
366           product_orient[n_product] = relative_orient * orientA;
367         } else if (this_geometry == 2 &amp;&amp; reacB != NULL) {
368           product_orient[n_product] = relative_orient * orientB;
369         } else {
370           product_orient[n_product] = relative_orient * 1;
371         }
372       }
373       if (n_product &lt; (int)rx-&gt;n_reactants) {
374         if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
375           assert(IS_SURF_MOL(product[n_product]));
376           struct surface_molecule *sm =
377               (struct surface_molecule *)product[n_product];
378           if (sm-&gt;orient != product_orient[n_product]) {
379             if (product[n_product]-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS|COUNT_ENCLOSED)) {
380               count_region_from_scratch(world,
381                                         product[n_product],                                         NULL,                                                       -1,                                                         NULL,                                         w,                                            t,                                            NULL);
382             }
383             if (((sm-&gt;flags &amp; ACT_REACT) != 0) &amp;&amp;
384                 ((sm-&gt;properties-&gt;flags &amp; CAN_SURFWALL) != 0)) {
385               sm-&gt;t2 = 0;
386             }
387             sm-&gt;orient = product_orient[n_product];
388             if (product[n_product]-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS|COUNT_ENCLOSED)) {
389               count_region_from_scratch(world,
390                                         product[n_product],                                         NULL,                                                       1,                                                          NULL,                                         w,                                            t,                                            NULL);
391             }
392           }
393         } else if (!is_unimol) {           if (product[n_product] == initiator) {
394             if (product_orient[n_product] != initiatorOrient)
395               cross_wall = true;
396           }
397         }
398       }
399     }
400     if (num_surface_products == 1) {
401       if (is_unimol &amp;&amp; replace_p1) {
402         for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
403           if (rx_players[n_product] == NULL ||
404              (rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0) {
405             continue;
406           }
407           if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
408             product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
409             product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
410             product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
411             replace_p1 = 0;
412             break;
413           }
414         }
415       } else if ((num_surface_static_reactants == 1) &amp;&amp; (num_surface_static_products == 1)
416           &amp;&amp; (replace_p1 || replace_p2)) {
417         for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
418           if (rx_players[n_product] == NULL ||
419               (rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0 ||
420               distinguishable(rx_players[n_product]-&gt;D, 0, EPS_C)) {
421             continue;
422           }
423           if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
424             if (replace_p1 &amp;&amp; (!distinguishable(reacA-&gt;properties-&gt;D, 0, EPS_C))) {
425               product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
426               product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
427               product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
428               replace_p1 = 0;
429               break;
430             } else if (replace_p2 &amp;&amp; (!distinguishable(reacB-&gt;properties-&gt;D, 0, EPS_C))) {
431               product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
432               product_grid[n_product] = ((struct surface_molecule *)reacB)-&gt;grid;
433               product_grid_idx[n_product] = ((struct surface_molecule *)reacB)-&gt;grid_index;
434               break;
435             }
436           }
437         }
438       } else if (replace_p1 &amp;&amp; replace_p2) {
439         for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
440           if ((rx_players[n_product] == NULL) ||
441               ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
442             continue;
443           }
444           if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
445             if (reacA == initiator) {
446               product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
447               product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
448               product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
449               replace_p1 = 0;
450             } else {
451               product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
452               product_grid[n_product] = ((struct surface_molecule *)reacB)-&gt;grid;
453               product_grid_idx[n_product] = ((struct surface_molecule *)reacB)-&gt;grid_index;
454             }
455             break;
456           }
457         }
458       } else if (replace_p1) {
459         for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
460           if ((rx_players[n_product] == NULL) ||
461               ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
462             continue;
463           }
464           if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
465             product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
466             product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
467             product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
468             replace_p1 = 0;
469             break;
470           }
471         }
472       } else if (replace_p2) {
473         for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
474           if ((rx_players[n_product] == NULL) |
475               ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
476             continue;
477           }
478           if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
479             product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
480             product_grid[n_product] = ((struct surface_molecule *)reacB)-&gt;grid;
481             product_grid_idx[n_product] = ((struct surface_molecule *)reacB)-&gt;grid_index;
482             break;
483           }
484         }
485       }
486     } else if (num_surface_products &gt; 1) {
487       if (num_surface_static_reactants &gt; 0) {
488         bool replace_reacA = (!distinguishable(reacA-&gt;get_diffusion(reacA), 0, EPS_C)) &amp;&amp; replace_p1;
489         bool replace_reacB =
490             (reacB == NULL) ? false : (!distinguishable(reacB-&gt;get_diffusion(reacB), 0, EPS_C)) &amp;&amp; replace_p2;
491         if (replace_reacA || replace_reacB) {
492           int max_static_count = (num_surface_static_products &lt; num_surface_static_reactants)
493             ? num_surface_static_products : num_surface_static_reactants;
494           int count = 0;
495           while (count &lt; max_static_count) {
496             unsigned int rnd_num = rng_uint(world-&gt;rng) % n_players;
497             if ((rnd_num &lt; rx-&gt;n_reactants) || (rx_players[rnd_num] == NULL) ||
498                 ((rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0) ||
499                 distinguishable(rx_players[rnd_num]-&gt;D, 0, EPS_C)) {
500               continue;
501             }
502             if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
503               if (replace_reacA) {
504                 product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
505                 product_grid[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid;
506                 product_grid_idx[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid_index;
507                 count++;
508                 replace_p1 = 0;
509                 replace_reacA = 0;
510               } else if (replace_reacB) {
511                 product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
512                 product_grid[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid;
513                 product_grid_idx[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid_index;
514                 count++;
515                 replace_p2 = 0;
516                 replace_reacB = 0;
517               }
518             }
519           }         }
520       }
521       if (replace_p1 || replace_p2) {
522         int surf_prod_left = 0, surf_reactant_left = 0;
523         for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
524           if ((rx_players[n_product] == NULL) ||
525               ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
526             continue;
527           }
528           if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
529             surf_prod_left++;
530           }
531         }
532         if (replace_p1) {
533           surf_reactant_left++;
534         }
535         if (replace_p2) {
536           surf_reactant_left++;
537         }
538         if (surf_prod_left &gt; 0) {
539           int num_to_place = surf_prod_left;
540           if (surf_prod_left &gt;= surf_reactant_left) {
541             num_to_place = surf_reactant_left;
542           }
543           int count = 0;
544           while (count &lt; num_to_place) {
545             unsigned int rnd_num = rng_uint(world-&gt;rng) % n_players;
546             if ((rnd_num &lt; rx-&gt;n_reactants) || (rx_players[rnd_num] == NULL) ||
547                 (rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0) {
548              continue;
549             }
550             if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
551               if (replace_p1) {
552                 product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
553                 product_grid[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid;
554                 product_grid_idx[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid_index;
555                 count++;
556                 replace_p1 = 0;
557               } else if (replace_p2) {
558                 product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
559                 product_grid[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid;
560                 product_grid_idx[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid_index;
561                 replace_p2 = 0;
562                 count++;
563               }
564             }
565           }         }
566       }
567     }
568     if ((sm_reactant == NULL) &amp;&amp; (w != NULL) &amp;&amp; (num_surface_products &gt;= 1)) {
569       assert(!IS_SURF_MOL(reacA));
570       assert(rxn_uv_idx != -1);
571       while (true) {
572         unsigned int rnd_num = rng_uint(world-&gt;rng) % (n_players);
573         if (rnd_num &lt;= 1 || (rx_players[rnd_num] == NULL) ||
574             (rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0) {
575           continue;
576         }
577         if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
578           product_flag[rnd_num] = PRODUCT_FLAG_USE_UV_LOC;
579           product_grid[rnd_num] = w-&gt;grid;
580           product_grid_idx[rnd_num] = rxn_uv_idx;
581           break;
582         }
583       }
584     }
585     if (is_unimol &amp;&amp; (sm_reactant != NULL) &amp;&amp; (num_surface_products == 2)) {
586       reac_idx = sm_reactant-&gt;grid_index;
587       reac_grid = sm_reactant-&gt;grid;
588     }
589     int do_it_once = 0;     int num_attempts = 0;
590     for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
591       if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
592         if (product_flag[n_product] != PRODUCT_FLAG_NOT_SET) {
593           continue;
594         }
595         if (num_vacant_tiles == 0) {
596           return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
597         }
598         num_attempts = 0;
599         while (true) {
600           if (num_attempts &gt; SURFACE_DIFFUSION_RETRIES) {
601             return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
602           }
603           unsigned int rnd_num = rng_uint(world-&gt;rng) % num_vacant_tiles;
604           int tile_idx = -1;           tile_grid = NULL;
605           if (get_tile_neighbor_from_list_of_vacant_neighbors(
606                   tile_vacant_nbr_head, rnd_num, &amp;tile_grid, &amp;tile_idx) == 0) {
607             return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
608           }
609           if (tile_idx &lt; 0) {
610             continue;           }
611           assert(tile_grid != NULL);
612           if (!product_tile_can_be_reached(tile_grid-&gt;surface, rlp_head_wall_1,
613             rlp_head_wall_2, rlp_head_obj_1, rlp_head_obj_2, sm_bitmask, is_unimol)) {
614             uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
615             num_attempts++;
616             continue;
617           }
618           product_grid[n_product] = tile_grid;
619           product_grid_idx[n_product] = tile_idx;
620           product_flag[n_product] = PRODUCT_FLAG_USE_RANDOM;
621           if (!do_it_once &amp;&amp; is_unimol &amp;&amp; (sm_reactant != NULL) &amp;&amp; (num_surface_products == 2)) {
622             mol_idx = tile_idx;
623             mol_grid = tile_grid;
624             do_it_once = 1;
625           }
626           break;
627         }       }
628     }
629   } 
630   struct vector3 count_pos_xyz;
631   struct periodic_image *periodic_box = ((struct volume_molecule *)reacA)-&gt;periodic_box;
632   if (hitpt != NULL) {
633     count_pos_xyz = *hitpt;
634   } else if (sm_reactant) {
635     uv2xyz(&amp;sm_reactant-&gt;s_pos, sm_reactant-&gt;grid-&gt;surface, &amp;count_pos_xyz);
636   } else {
637     count_pos_xyz = ((struct volume_molecule *)reacA)-&gt;pos;
638   }
639   struct vector3 mol_pos_tmp;
640   struct subvolume *product_subvol = NULL;
641   bool update_dissociation_index = false; 
642   for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
643     struct graph_data* g_data = NULL;
644     if (rx-&gt;product_graph_data != NULL)
645       g_data = rx-&gt;product_graph_data[path][n_product - rx-&gt;n_reactants];
646     struct abstract_molecule *this_product = NULL;
647     struct species *const product_species = rx_players[n_product];
648     if (product_species-&gt;flags &amp; ON_GRID) {
649       struct vector2 prod_uv_pos;
650       if (world-&gt;randomize_smol_pos) {
651         switch (product_flag[n_product]) {
652         case PRODUCT_FLAG_USE_REACA_UV:
653           if (is_unimol &amp;&amp; (num_surface_products == 2) &amp;&amp; (sm_reactant != NULL)) {
654             if (mol_grid == NULL) {
655               mcell_internal_error("Error in surface product placement for the "
656                                    "unimolecular reaction.");
657             }
658             find_closest_position(product_grid[n_product], product_grid_idx[n_product],
659               mol_grid, mol_idx, &amp;prod_uv_pos);
660           } else {
661             prod_uv_pos = ((struct surface_molecule *)reacA)-&gt;s_pos;
662           }
663           break;
664         case PRODUCT_FLAG_USE_REACB_UV:
665           assert(reacB != NULL);
666           prod_uv_pos = ((struct surface_molecule *)reacB)-&gt;s_pos;
667           break;
668         case PRODUCT_FLAG_USE_UV_LOC:
669           prod_uv_pos = rxn_uv_pos;
670           break;
671         case PRODUCT_FLAG_USE_RANDOM:
672           if (is_unimol &amp;&amp; replace_p1 &amp;&amp; (num_surface_products == 2)) {
673             find_closest_position(product_grid[n_product],
674                                   product_grid_idx[n_product], reac_grid,
675                                   reac_idx, &amp;prod_uv_pos);
676           } else {
677             grid2uv_random(product_grid[n_product], product_grid_idx[n_product],
678                            &amp;prod_uv_pos, world-&gt;rng);
679           }
680           break;
681         default:
682           UNHANDLED_CASE(product_flag[n_product]);
683         }
684       } else {
685         grid2uv(product_grid[n_product], product_grid_idx[n_product], &amp;prod_uv_pos);
686       }
687       this_product = (struct abstract_molecule *)place_sm_product(
688           world, product_species, g_data, product_grid[n_product],
689           product_grid_idx[n_product], &amp;prod_uv_pos, product_orient[n_product],
690           t, reacA-&gt;periodic_box);
691 #ifdef DEBUG_RXNS
692       DUMP_CONDITION3(
693           dump_surface_molecule((struct surface_molecule*)this_product, "", true, "  created sm:", world-&gt;current_iterations, this_product-&gt;t, true);
694       );
695 #endif
696       if (!hitpt) {
697         if (reacA-&gt;properties-&gt;flags &amp; ON_GRID) {
698           w = ((struct surface_molecule *)reacA)-&gt;grid-&gt;surface;
699           uv2xyz(&amp;((struct surface_molecule *)reacA)-&gt;s_pos,
700                  w, &amp;mol_pos_tmp);
701           product_subvol = find_subvolume(world, &amp;mol_pos_tmp, NULL);
702         } else {
703           mol_pos_tmp = ((struct volume_molecule *)reacA)-&gt;pos;
704           product_subvol = ((struct volume_molecule *)reacA)-&gt;subvol;
705         }
706         hitpt = &amp;mol_pos_tmp;
707       } else if (product_subvol == NULL) {
708         product_subvol = find_subvolume(world, hitpt, NULL);
709       }
710       this_product = (struct abstract_molecule *)place_volume_product(
711           world, product_species, g_data, sm_reactant, w, product_subvol, hitpt,
712           product_orient[n_product], t, reacA-&gt;periodic_box);
713 #ifdef DEBUG_RXNS
714       DUMP_CONDITION3(
715       		dump_volume_molecule((struct volume_molecule*)this_product, "", true, "  created vm:", world-&gt;current_iterations, this_product-&gt;t, true);
716       );
717 #endif
718       if (((struct volume_molecule *)this_product)-&gt;index &lt; DISSOCIATION_MAX)
719         update_dissociation_index = true;
720     }
721     if(rx-&gt;product_graph_data != NULL){
722       this_product-&gt;graph_data = g_data;
723     }
724     ++product_species-&gt;population;
725     if (product_species-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED))
726       count_region_from_scratch(world, this_product, NULL, 1, NULL, NULL, t, this_product-&gt;periodic_box);
727 #ifndef MCELL3_DO_NOT_REUSE_MOL_ID_UNIMOL_RXN
728     if (is_unimol &amp;&amp; (n_players == 1)) {
729       this_product-&gt;id = reacA-&gt;id;
730       world-&gt;current_mol_id--;       continue;
731     }
732     if ((n_players == 3) &amp;&amp; product_type[1] == PLAYER_WALL) {
733       this_product-&gt;id = reacA-&gt;id;
734       world-&gt;current_mol_id--;       continue;
735     }
736 #endif
737   }
738   if (update_dissociation_index) {
739     ASSERT_FOR_MCELL4(false);
740     if (--world-&gt;dissociation_index &lt; DISSOCIATION_MIN)
741       world-&gt;dissociation_index = DISSOCIATION_MAX;
742   }
743   if (rx-&gt;info[path].pathname != NULL) {
744     if (world-&gt;place_waypoints_flag)
745       count_region_from_scratch(world, NULL, rx-&gt;info[path].pathname, 1,
746                                 &amp;count_pos_xyz, w, t, periodic_box);
747     if (rx-&gt;info[path].pathname-&gt;magic != NULL) {
748       if (reaction_wizardry(world, rx-&gt;info[path].pathname-&gt;magic, w,
749                             &amp;count_pos_xyz, t))
750         mcell_allocfailed("Failed to complete reaction triggered release after "
751                           "a '%s' reaction.",
752                           rx-&gt;info[path].pathname-&gt;sym-&gt;name);
753     }
754   }
755   delete_tile_neighbor_list(tile_nbr_head);
756   delete_tile_neighbor_list(tile_vacant_nbr_head);
757   delete_region_list(rlp_head_wall_1);
758   delete_region_list(rlp_head_wall_2);
759   delete_region_list(rlp_head_obj_1);
760   delete_region_list(rlp_head_obj_2);
761   return cross_wall ? RX_FLIP : RX_A_OK;
762 }
763 int outcome_unimolecular(struct volume *world, struct rxn *rx, int path,
764                          struct abstract_molecule *reac, double t) {
765   struct species *who_was_i = reac-&gt;properties;
766   int result = RX_A_OK;
767   struct volume_molecule *vm = NULL;
768   struct surface_molecule *sm = NULL;
769   if ((reac-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
770     vm = (struct volume_molecule *)reac;
771     if(reac-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
772 #if 0       for (int path = 0; path &lt; rx-&gt;n_pathways; path++) {
773         outcome_nfsim(world, rx, path, reac, NULL, t);
774       }
775 #else
776       outcome_nfsim(world, rx, path, reac, NULL, t);
777 #endif
778     }
779     result = outcome_products_random(world, NULL, NULL, t, rx, path, reac,
780                                        NULL, 0, 0);
781   } else {
782     sm = (struct surface_molecule *)reac;
783       if ((strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_SURFACE_MOLECULES") == 0) ||
784           (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_MOLECULES") == 0)) {
785       } else {
786         if(reac-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
787           outcome_nfsim(world, rx, path, reac, NULL, t);
788         }
789         result = outcome_products_random(world, sm-&gt;grid-&gt;surface, NULL, t, rx,
790                                          path, reac, NULL, sm-&gt;orient, 0);
791       }
792   }
793   if (result == RX_BLOCKED)
794     return RX_BLOCKED;
795   if (result != RX_BLOCKED) {
796     rx-&gt;info[path].count++;
797     rx-&gt;n_occurred++;
798     if(rx-&gt;product_graph_data != NULL){
799       logNFSimReactions_c(rx-&gt;external_reaction_data[path].reaction_name);
800     }
801   }
802   struct species *who_am_i = rx-&gt;players[rx-&gt;product_idx[path]];
803   if (who_am_i == NULL) {
804     if (vm != NULL) {
805       vm-&gt;subvol-&gt;mol_count--;
806       if (vm-&gt;flags &amp; IN_SCHEDULE)
807         vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
808       if (vm-&gt;properties-&gt;flags &amp; COUNT_SOME_MASK) {
809         count_region_from_scratch(world, (struct abstract_molecule *)vm, NULL,
810                                   -1, &amp;(vm-&gt;pos), NULL, vm-&gt;t, vm-&gt;periodic_box);
811       }
812     } else {
813 #ifdef DEBUG_RXNS
814       DUMP_CONDITION3(
815         dump_surface_molecule(sm, "", true, "Unimolecular sm defunct:", world-&gt;current_iterations, sm-&gt;t, false);
816       );
817 #endif
818       remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
819       sm-&gt;grid-&gt;n_occupied--;
820       if (sm-&gt;flags &amp; IN_SCHEDULE) {
821         sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
822       }
823       if (sm-&gt;properties-&gt;flags &amp; COUNT_SOME_MASK) {
824         count_region_from_scratch(world, (struct abstract_molecule *)sm, NULL,
825                                   -1, NULL, NULL, sm-&gt;t, sm-&gt;periodic_box);
826       }
827     }
828     free(reac-&gt;periodic_box);
829     who_was_i-&gt;n_deceased++;
830     double t_time = convert_iterations_to_seconds(
831         world-&gt;start_iterations, world-&gt;time_unit,
832         world-&gt;simulation_start_seconds, t);
833     who_was_i-&gt;cum_lifetime_seconds += t_time - reac-&gt;birthday;
834     who_was_i-&gt;population--;
835     if (vm != NULL) {
836 #ifdef DEBUG_RXNS
837       DUMP_CONDITION3(
838         dump_volume_molecule(vm, "", true, "Unimolecular vm defunct:", world-&gt;current_iterations, vm-&gt;t, false);
839       );
840 #endif
841       collect_molecule(vm);
842     }
843     else {
844       reac-&gt;properties = NULL;
845       mem_put(reac-&gt;birthplace, reac);
846     }
847     return RX_DESTROY;
848   } else if (who_am_i != who_was_i) {
849     if (vm != NULL) {
850 #ifdef DEBUG_RXNS
851       DUMP_CONDITION3(
852         dump_volume_molecule(vm, "", true, "Unimolecular vm defunct:", world-&gt;current_iterations, vm-&gt;t, false);
853       );
854 #endif
855       collect_molecule(vm);
856     }
857     else
858       reac-&gt;properties = NULL;
859     return RX_DESTROY;
860   } else
861     return result;
862 }
863 int outcome_bimolecular(struct volume *world, struct rxn *rx, int path,
864                         struct abstract_molecule *reacA,
865                         struct abstract_molecule *reacB, short orientA,
866                         short orientB, double t, struct vector3 *hitpt,
867                         struct vector3 *loc_okay) {
868 #ifdef DEBUG_TIMING
869   DUMP_CONDITION3(
870       MCell::dump_outcome_bimolecular_timing(t);
871   );
872 #endif
873   assert(periodic_boxes_are_identical(reacA-&gt;periodic_box, reacB-&gt;periodic_box));
874   struct surface_molecule *sm = NULL;
875   struct volume_molecule *vm = NULL;
876   struct wall *w = NULL;
877   int result;
878   int reacB_was_free = 0;
879   int killA, killB;
880   if ((reacA-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
881     if ((reacB-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
882       sm = (struct surface_molecule *)reacB;
883       w = sm-&gt;grid-&gt;surface;
884     }
885   } else {     sm = (struct surface_molecule *)reacA;
886     w = sm-&gt;grid-&gt;surface;
887   }
888   if(reacA-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
889     result = outcome_nfsim(world, rx, path, reacA, reacB, t);
890     result = outcome_products_random(world, w, hitpt, t, rx, path, reacA, reacB,
891                                      orientA, orientB);
892   }
893   else {
894     result = outcome_products_random(world, w, hitpt, t, rx, path, reacA, reacB,
895                                      orientA, orientB);
896   }
897   if (result == RX_BLOCKED)
898     return RX_BLOCKED;
899   rx-&gt;n_occurred++;
900   rx-&gt;info[path].count++;
901   if(rx-&gt;product_graph_data != NULL){
902     logNFSimReactions_c(rx-&gt;external_reaction_data[path].reaction_name);
903   }
904   if (rx-&gt;players[0] == reacA-&gt;properties) {
905     killB = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
906     killA = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
907   } else {
908     killB = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
909     killA = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
910   }
911   if (killB) {
912 #ifdef DEBUG_RXNS
913     DUMP_CONDITION3(
914       dump_volume_molecule((struct volume_molecule*)reacB, "", true, "  defunct m:", world-&gt;current_iterations, 0.0, false);
915     );
916 #endif
917     vm = NULL;
918     if ((reacB-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
919       sm = (struct surface_molecule *)reacB;
920       remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
921       sm-&gt;grid-&gt;n_occupied--;
922       if (sm-&gt;flags &amp; IN_SURFACE)
923         sm-&gt;flags -= IN_SURFACE;
924       if (sm-&gt;flags &amp; IN_SCHEDULE) {
925         sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
926       }
927     } else if ((reacB-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
928       vm = (struct volume_molecule *)reacB;
929       vm-&gt;subvol-&gt;mol_count--;
930       if (vm-&gt;flags &amp; IN_SCHEDULE) {
931         vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
932       }
933       reacB_was_free = 1;
934     }
935     if ((reacB-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) != 0) {
936       count_region_from_scratch(world, reacB, NULL, -1, NULL, NULL, t, reacB-&gt;periodic_box);
937     }
938     free(reacB-&gt;periodic_box);
939     reacB-&gt;periodic_box = NULL;
940     reacB-&gt;properties-&gt;n_deceased++;
941     double t_time = convert_iterations_to_seconds(
942         world-&gt;start_iterations, world-&gt;time_unit,
943         world-&gt;simulation_start_seconds, t);
944     reacB-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacB-&gt;birthday;
945     reacB-&gt;properties-&gt;population--;
946     if (vm != NULL)
947       collect_molecule(vm);
948     else
949       reacB-&gt;properties = NULL;
950   }
951   if (killA) {
952 #ifdef DEBUG_RXNS
953     DUMP_CONDITION3(
954       dump_volume_molecule((struct volume_molecule*)reacA, "", true, "  defunct m:", world-&gt;current_iterations, 0.0, false);
955     );
956 #endif
957     vm = NULL;
958     if ((reacA-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
959       sm = (struct surface_molecule *)reacA;
960       remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
961       sm-&gt;grid-&gt;n_occupied--;
962       if (sm-&gt;flags &amp; IN_SCHEDULE) {
963         sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
964       }
965     } else if ((reacA-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
966       vm = (struct volume_molecule *)reacA;
967       vm-&gt;subvol-&gt;mol_count--;
968       if (vm-&gt;flags &amp; IN_SCHEDULE) {
969         vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
970       }
971     }
972     if ((reacA-&gt;properties-&gt;flags &amp; ON_GRID) !=
973         0)     {
974       if (reacA-&gt;properties-&gt;flags &amp;
975           COUNT_SOME_MASK)       {
976         count_region_from_scratch(world, reacA, NULL, -1, NULL, NULL, t, reacA-&gt;periodic_box);
977       }
978     } else if (reacA-&gt;flags &amp; COUNT_ME) {
979       if (hitpt == NULL || reacB_was_free ||
980           (reacB-&gt;properties != NULL &amp;&amp;
981            (reacB-&gt;properties-&gt;flags &amp; NOT_FREE) == 0)) {
982         count_region_from_scratch(world, reacA, NULL, -1, hitpt, NULL, t, reacA-&gt;periodic_box);
983       {
984         struct vector3 fake_hitpt;
985         vm = (struct volume_molecule *)reacA;
986         if (loc_okay == NULL)
987           loc_okay = &amp;(vm-&gt;pos);
988         fake_hitpt.x = 0.5 * hitpt-&gt;x + 0.5 * loc_okay-&gt;x;
989         fake_hitpt.y = 0.5 * hitpt-&gt;y + 0.5 * loc_okay-&gt;y;
990         fake_hitpt.z = 0.5 * hitpt-&gt;z + 0.5 * loc_okay-&gt;z;
991         count_region_from_scratch(world, reacA, NULL, -1, &amp;fake_hitpt, NULL, t, reacA-&gt;periodic_box);
992       }
993     }
994     free(reacA-&gt;periodic_box);
995     reacA-&gt;periodic_box = NULL;
996     reacA-&gt;properties-&gt;n_deceased++;
997     double t_time = convert_iterations_to_seconds(
998         world-&gt;start_iterations, world-&gt;time_unit,
999         world-&gt;simulation_start_seconds, t);
1000     reacA-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacA-&gt;birthday;
1001     reacA-&gt;properties-&gt;population--;
1002     if (vm != NULL)
1003       collect_molecule(vm);
1004     else
1005       reacA-&gt;properties = NULL;
1006     return RX_DESTROY;
1007   }
1008   return result;
1009 }
1010 int outcome_intersect(struct volume *world, struct rxn *rx, int path,
1011                       struct wall *surface, struct abstract_molecule *reac,
1012                       short orient, double t, struct vector3 *hitpt,
1013                       struct vector3 *loc_okay) {
1014   if (rx-&gt;n_pathways &lt;= RX_SPECIAL) {
1015     rx-&gt;n_occurred++;
1016     if (rx-&gt;n_pathways == RX_REFLEC)
1017       return RX_A_OK;
1018     else
1019       return RX_FLIP;   }
1020   int idx = rx-&gt;product_idx[path];
1021   if ((reac-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
1022     struct volume_molecule *vm = (struct volume_molecule *)reac;
1023     int result;
1024     if ((strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_MOLECULES") == 0) ||
1025         (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_VOLUME_MOLECULES") == 0)) {
1026       result = RX_DESTROY;
1027     } else {
1028       result = outcome_products_random(world, surface, hitpt, t, rx, path,
1029                                        reac, NULL, orient, 0);
1030     }
1031     if (result == RX_BLOCKED)
1032       return RX_A_OK; 
1033     rx-&gt;info[path].count++;
1034     rx-&gt;n_occurred++;
1035     if (rx-&gt;players[idx] == NULL) {
1036       vm-&gt;subvol-&gt;mol_count--;
1037       if (world-&gt;place_waypoints_flag &amp;&amp; (reac-&gt;flags &amp; COUNT_ME)) {
1038         if (hitpt == NULL) {
1039           count_region_from_scratch(
1040             world, reac, NULL, -1, NULL, NULL, t, reac-&gt;periodic_box);
1041         } else {
1042           struct vector3 fake_hitpt;
1043           if (loc_okay == NULL)
1044             loc_okay = &amp;(vm-&gt;pos);
1045           fake_hitpt.x = 0.5 * hitpt-&gt;x + 0.5 * loc_okay-&gt;x;
1046           fake_hitpt.y = 0.5 * hitpt-&gt;y + 0.5 * loc_okay-&gt;y;
1047           fake_hitpt.z = 0.5 * hitpt-&gt;z + 0.5 * loc_okay-&gt;z;
1048           count_region_from_scratch(world, reac, NULL, -1, &amp;fake_hitpt, NULL,
1049                                     t, reac-&gt;periodic_box);
1050         }
1051       }
1052       free(reac-&gt;periodic_box);
1053       reac-&gt;properties-&gt;n_deceased++;
1054       double t_time = convert_iterations_to_seconds(
1055           world-&gt;start_iterations, world-&gt;time_unit,
1056           world-&gt;simulation_start_seconds, t);
1057       reac-&gt;properties-&gt;cum_lifetime_seconds += t_time - reac-&gt;birthday;
1058       reac-&gt;properties-&gt;population--;
1059       if (vm-&gt;flags &amp; IN_SCHEDULE) {
1060         vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
1061       }
1062 #ifdef DEBUG_RXNS
1063       DUMP_CONDITION3(
1064          dump_volume_molecule((struct volume_molecule*)vm, "", true, "  defunct m:", world-&gt;current_iterations, 0.0, false);
1065       );
1066 #endif
1067       collect_molecule(vm);
1068       return RX_DESTROY;
1069     } else
1070       return result;   } else {
1071     return RX_A_OK;
1072   }
1073 }
1074 int reaction_wizardry(struct volume *world, struct magic_list *incantation,
1075                       struct wall *surface, struct vector3 *hitpt, double t) {
1076   struct release_event_queue req; 
1077   req.next = NULL;
1078   req.event_time = t;
1079   req.train_counter = 0;
1080   req.train_high_time = t;
1081   if (hitpt == NULL) {
1082     init_matrix(req.t_matrix);
1083   } else if (surface == NULL ||
1084              !distinguishable(surface-&gt;normal.z, 1.0,
1085                               EPS_C))   {
1086     init_matrix(req.t_matrix);
1087     req.t_matrix[3][0] = hitpt-&gt;x;
1088     req.t_matrix[3][1] = hitpt-&gt;y;
1089     req.t_matrix[3][2] = hitpt-&gt;z;
1090   {
1091     struct vector3 scale = { 1.0, 1.0, 1.0 };     struct vector3 axis = { 1.0, 0.0, 0.0 };      double cos_theta;
1092     double degrees;
1093     cos_theta = surface-&gt;normal.z;     if (!distinguishable(cos_theta, -1.0, EPS_C)) {
1094       degrees = 180.0;     } else {
1095       axis.x = -surface-&gt;normal.y;
1096       axis.y = surface-&gt;normal.x;
1097       axis.z = 0.0;
1098       degrees = acos(cos_theta) * 180.0 / MY_PI;
1099     }
1100     tform_matrix(&amp;scale, hitpt, &amp;axis, degrees, req.t_matrix);
1101   }
1102   for (; incantation != NULL; incantation = incantation-&gt;next) {
1103     if (incantation-&gt;type != magic_release)
1104       continue; 
1105     req.release_site = (struct release_site_obj *)incantation-&gt;data;
1106     if (release_molecules(world, &amp;req))
1107       return 1;
1108   }
1109   return 0;
1110 }
1111 int determine_molecule_region_topology(
1112     struct volume *world, struct surface_molecule *sm_1,
1113     struct surface_molecule *sm_2, struct region_list **rlp_wall_1_ptr,
1114     struct region_list **rlp_wall_2_ptr, struct region_list **rlp_obj_1_ptr,
1115 <a name="1"></a>    struct region_list **rlp_obj_2_ptr, bool is_unimol) {
1116   int sm_bitmask = 0;
1117   struct wall *w_1, *w_2;
1118 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  struct region_list *rlp_head_wall_1 = NULL;
1119   struct region_list *rlp_head_wall_2 = NULL;
1120   struct region_list *rlp_head_obj_1 = NULL;
1121   struct region_list *rlp_head_obj_2 = NULL;</b></font>
1122   if ((sm_1 != NULL) &amp;&amp; (sm_2 != NULL)) {
1123     if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
1124         (sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
1125         are_restricted_regions_for_species_on_object(
1126             world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
1127         are_restricted_regions_for_species_on_object(
1128             world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2)) {
1129       w_1 = sm_1-&gt;grid-&gt;surface;
1130       w_2 = sm_2-&gt;grid-&gt;surface;
1131       rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
1132       rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
1133       if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 != NULL)) {
1134         sm_bitmask |= ALL_INSIDE;
1135       }
1136       else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 == NULL)) {
1137         rlp_head_obj_1 =
1138             find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
1139         rlp_head_obj_2 =
1140             find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
1141         sm_bitmask |= ALL_OUTSIDE;
1142       }
1143       else if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 == NULL)) {
1144         rlp_head_obj_2 =
1145             find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
1146         sm_bitmask |= SURF1_IN_SURF2_OUT;
1147       }
1148       else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 != NULL)) {
1149         rlp_head_obj_1 =
1150             find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
1151         sm_bitmask |= SURF1_OUT_SURF2_IN;
1152       }
1153     }
1154     else if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
1155              are_restricted_regions_for_species_on_object(
1156                  world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
1157              (!(sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
1158               !are_restricted_regions_for_species_on_object(
1159 <a name="0"></a>                   world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2))) {
1160       w_1 = sm_1-&gt;grid-&gt;surface;
1161       rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
1162 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>      if (rlp_head_wall_1 != NULL) {
1163         sm_bitmask |= SURF1_IN;
1164       } else {
1165         rlp_head_obj_1 =
1166             find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
1167         sm_bitmask |= SURF1_OUT;
1168       }
1169     }
1170     else if ((sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
1171              are_restricted_regions_for_species_on_object(
1172                  world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2) &amp;&amp;
1173              (!(sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
1174               !are_restricted_regions_for_species_on_object(
1175                    world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1))) {</b></font>
1176       w_2 = sm_2-&gt;grid-&gt;surface;
1177       rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
1178       if (rlp_head_wall_2 != NULL) {
1179         sm_bitmask |= SURF2_IN;
1180       } else {
1181         rlp_head_obj_2 =
1182             find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
1183         sm_bitmask |= SURF2_OUT;
1184       }
1185     }
1186   }
1187   else if ((sm_1 != NULL) &amp;&amp; is_unimol) {
1188     if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
1189         are_restricted_regions_for_species_on_object(
1190             world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1)) {
1191       w_1 = sm_1-&gt;grid-&gt;surface;
1192       rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
1193       if (rlp_head_wall_1 != NULL) {
1194         sm_bitmask |= ALL_INSIDE;
1195       } else {
1196         rlp_head_obj_1 =
1197             find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
1198         sm_bitmask |= ALL_OUTSIDE;
1199       }
1200     }
1201   }
1202   *rlp_wall_1_ptr = rlp_head_wall_1;
1203   *rlp_wall_2_ptr = rlp_head_wall_2;
1204   *rlp_obj_1_ptr = rlp_head_obj_1;
1205   *rlp_obj_2_ptr = rlp_head_obj_2;
1206   return sm_bitmask;
1207 }
1208 bool product_tile_can_be_reached(struct wall *target,
1209                                  struct region_list *rlp_head_wall_1,
1210                                  struct region_list *rlp_head_wall_2,
1211                                  struct region_list *rlp_head_obj_1,
1212                                  struct region_list *rlp_head_obj_2,
1213                                  int sm_bitmask, bool is_unimol) {
1214   bool status = true;
1215   if (sm_bitmask &amp; ALL_INSIDE) {
1216     if (is_unimol) {
1217       if (!wall_belongs_to_all_regions_in_region_list(target,
1218                                                       rlp_head_wall_1)) {
1219         status = false;
1220       }
1221     } else {
1222       if (!wall_belongs_to_all_regions_in_region_list(target,
1223                                                       rlp_head_wall_1) ||
1224           !wall_belongs_to_all_regions_in_region_list(target,
1225                                                       rlp_head_wall_2)) {
1226         status = false;
1227       }
1228     }
1229   } else if (sm_bitmask &amp; ALL_OUTSIDE) {
1230     if (is_unimol) {
1231       if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1)) {
1232         status = false;
1233       }
1234     } else {
1235       if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1) ||
1236           wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_2)) {
1237         status = false;
1238       }
1239     }
1240   } else if (sm_bitmask &amp; SURF1_IN_SURF2_OUT) {
1241     if (!wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_1) ||
1242         wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_2)) {
1243       status = false;
1244     }
1245   } else if (sm_bitmask &amp; SURF1_OUT_SURF2_IN) {
1246     if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1) ||
1247         !wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_2)) {
1248       status = false;
1249     }
1250   } else if (sm_bitmask &amp; SURF1_IN) {
1251     if (!wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_1)) {
1252       status = false;
1253     }
1254   } else if (sm_bitmask &amp; SURF1_OUT) {
1255     if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1)) {
1256       status = false;
1257     }
1258   } else if (sm_bitmask &amp; SURF2_IN) {
1259     if (!wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_2)) {
1260       status = false;
1261     }
1262   } else if (sm_bitmask &amp; SURF2_OUT) {
1263     if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_2)) {
1264       status = false;
1265     }
1266   }
1267   return status;
1268 }
1269 int cleanup_and_block_rx(struct tile_neighbor *tn1, struct tile_neighbor *tn2) {
1270   if (tn1 != NULL) {
1271     delete_tile_neighbor_list(tn1);
1272   }
1273   if (tn2 != NULL) {
1274     delete_tile_neighbor_list(tn2);
1275   }
1276   return RX_BLOCKED;
1277 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>grid_util.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;math.h&gt;
3 #include &lt;string.h&gt;
4 #include &lt;stdlib.h&gt;
5 #include &lt;vector&gt;
6 #include "logging.h"
7 #include "rng.h"
8 #include "grid_util.h"
9 #include "vol_util.h"
10 #include "wall_util.h"
11 #include "react.h"
12 #include "init.h"
13 #include "debug_config.h"
14 #include "dump_state.h"
15 void xyz2uv(struct vector3 *a, struct wall *w, struct vector2 *b) {
16   if (w-&gt;grid) {
17     b-&gt;u = a-&gt;x * w-&gt;unit_u.x + a-&gt;y * w-&gt;unit_u.y + a-&gt;z * w-&gt;unit_u.z -
18            w-&gt;grid-&gt;vert0.u;
19     b-&gt;v = a-&gt;x * w-&gt;unit_v.x + a-&gt;y * w-&gt;unit_v.y + a-&gt;z * w-&gt;unit_v.z -
20            w-&gt;grid-&gt;vert0.v;
21   } else {
22     struct vector3 p;
23     p.x = a-&gt;x - w-&gt;vert[0]-&gt;x;
24     p.y = a-&gt;y - w-&gt;vert[0]-&gt;y;
25     p.z = a-&gt;z - w-&gt;vert[0]-&gt;z;
26     b-&gt;u = p.x * w-&gt;unit_u.x + p.y * w-&gt;unit_u.y + p.z * w-&gt;unit_u.z;
27     b-&gt;v = p.x * w-&gt;unit_v.x + p.y * w-&gt;unit_v.y + p.z * w-&gt;unit_v.z;
28   }
29 }
30 void uv2xyz(struct vector2 *a, struct wall *w, struct vector3 *b) {
31   b-&gt;x = a-&gt;u * w-&gt;unit_u.x + a-&gt;v * w-&gt;unit_v.x + w-&gt;vert[0]-&gt;x;
32   b-&gt;y = a-&gt;u * w-&gt;unit_u.y + a-&gt;v * w-&gt;unit_v.y + w-&gt;vert[0]-&gt;y;
33   b-&gt;z = a-&gt;u * w-&gt;unit_u.z + a-&gt;v * w-&gt;unit_v.z + w-&gt;vert[0]-&gt;z;
34 }
35 int xyz2grid(struct vector3 *v, struct surface_grid *g) {
36   struct vector3 *unit_u = &amp;(g-&gt;surface-&gt;unit_u);
37   struct vector3 *unit_v = &amp;(g-&gt;surface-&gt;unit_v);
38   double i, j;
39   double u0, u1_u0;
40   double striploc, striprem, stripeloc, striperem;
41   int strip, stripe, flip, idx;
42   int tile_idx_0, tile_idx_mid, tile_idx_last;
43   if (g-&gt;n_tiles == 1)
44     return 0;
45   tile_idx_0 = 0;
46   tile_idx_mid = g-&gt;n_tiles - 2 * (g-&gt;n) + 1;
47   tile_idx_last = g-&gt;n_tiles - 1;
48   if (!(distinguishable_vec3(v, g-&gt;surface-&gt;vert[0], EPS_C)))
49     return tile_idx_mid;
50   if (!(distinguishable_vec3(v, g-&gt;surface-&gt;vert[1], EPS_C)))
51     return tile_idx_last;
52   if (!(distinguishable_vec3(v, g-&gt;surface-&gt;vert[2], EPS_C)))
53     return tile_idx_0;
54   if (!(point_in_triangle(v, g-&gt;surface-&gt;vert[0], g-&gt;surface-&gt;vert[1],
55                           g-&gt;surface-&gt;vert[2]))) {
56     mcell_internal_error(
57         "Error in function 'xyz2grid()': point is outside wall.");
58   }
59   i = v-&gt;x * unit_u-&gt;x + v-&gt;y * unit_u-&gt;y + v-&gt;z * unit_u-&gt;z - g-&gt;vert0.u;
60   j = v-&gt;x * unit_v-&gt;x + v-&gt;y * unit_v-&gt;y + v-&gt;z * unit_v-&gt;z - g-&gt;vert0.v;
61   striploc = j * g-&gt;inv_strip_wid;
62   strip = (int)striploc;
63   striprem = striploc - strip;
64   strip = g-&gt;n - strip - 1;
65   u0 = j * g-&gt;vert2_slope;
66   u1_u0 = g-&gt;surface-&gt;uv_vert1_u - j * g-&gt;fullslope;
67   stripeloc = ((i - u0) / u1_u0) * (((double)strip) + (1.0 - striprem));
68   stripe = (int)(stripeloc);
69   striperem = stripeloc - stripe;
70   flip = (striperem &lt; 1.0 - striprem) ? 0 : 1;
71   idx = strip * strip + 2 * stripe + flip;
72   if ((u_int)idx &gt;= g-&gt;n_tiles) {
73     mcell_internal_error("Error in function 'xyz2grid()': returning tile index "
74                          "%d while wall has %u tiles",
75                          idx, g-&gt;n_tiles);
76   }
77   return idx;
78 }
79 int uv2grid(struct vector2 *v, struct surface_grid *g) {
80   double i, j;
81   double u0, u1_u0;
82   double striploc, striprem, stripeloc, striperem;
83   int strip, stripe, flip, idx;
84   struct vector2 vert_0, vert_1;
85   int tile_idx_0, tile_idx_mid, tile_idx_last;
86   if (g-&gt;n_tiles == 1)
87     return 0;
88   tile_idx_0 = 0;
89   tile_idx_mid = g-&gt;n_tiles - 2 * (g-&gt;n) + 1;
90   tile_idx_last = g-&gt;n_tiles - 1;
91   vert_0.u = vert_0.v = 0;
92   vert_1.u = g-&gt;surface-&gt;uv_vert1_u;
93   vert_1.v = 0;
94   if (!distinguishable_vec2(v, &amp;vert_0, EPS_C))
95     return tile_idx_mid;
96   if (!distinguishable_vec2(v, &amp;vert_1, EPS_C))
97     return tile_idx_0;
98   if (!distinguishable_vec2(v, &amp;g-&gt;surface-&gt;uv_vert2, EPS_C))
99     return tile_idx_last;
100   if (!(point_in_triangle_2D(v, &amp;vert_0, &amp;vert_1, &amp;g-&gt;surface-&gt;uv_vert2))) {
101     mcell_internal_error(
102         "Error in function 'uv2grid()': point is outside wall.");
103   }
104   i = v-&gt;u;
105   j = v-&gt;v;
106   striploc = j * g-&gt;inv_strip_wid;
107   strip = (int)striploc;
108   striprem = striploc - strip;
109   strip = g-&gt;n - strip - 1;
110   u0 = j * g-&gt;vert2_slope;
111   u1_u0 = g-&gt;surface-&gt;uv_vert1_u - j * g-&gt;fullslope;
112   stripeloc = ((i - u0) / u1_u0) * (((double)strip) + (1.0 - striprem));
113   stripe = (int)(stripeloc);
114   striperem = stripeloc - stripe;
115   flip = (striperem &lt; 1.0 - striprem) ? 0 : 1;
116   idx = strip * strip + 2 * stripe + flip;
117   if ((u_int)idx &gt;= g-&gt;n_tiles) {
118     mcell_internal_error("Error in function 'xyz2grid()': returning tile index "
119                          "%d while wall has %u tiles",
120                          idx, g-&gt;n_tiles);
121   }
122   return idx;
123 }
124 void grid2xyz(struct surface_grid *g, int idx, struct vector3 *v) {
125   struct vector3 *unit_u = &amp;(g-&gt;surface-&gt;unit_u);
126   struct vector3 *unit_v = &amp;(g-&gt;surface-&gt;unit_v);
127   int root;
128   int rootrem;
129   int k, j, i;
130   double ucoef, vcoef, over3n;
131   root = (int)(sqrt((double)idx));
132   rootrem = idx - root * root;
133   k = g-&gt;n - root - 1;
134   j = rootrem / 2;
135   i = rootrem - 2 * j;
136   over3n = 1.0 / (double)(3 * g-&gt;n);
137   ucoef = ((double)(3 * j + i + 1)) * over3n * g-&gt;surface-&gt;uv_vert1_u +
138           ((double)(3 * k + i + 1)) * over3n * g-&gt;surface-&gt;uv_vert2.u;
139   vcoef = ((double)(3 * k + i + 1)) * over3n * g-&gt;surface-&gt;uv_vert2.v;
140   v-&gt;x = ucoef * unit_u-&gt;x + vcoef * unit_v-&gt;x + g-&gt;surface-&gt;vert[0]-&gt;x;
141   v-&gt;y = ucoef * unit_u-&gt;y + vcoef * unit_v-&gt;y + g-&gt;surface-&gt;vert[0]-&gt;y;
142   v-&gt;z = ucoef * unit_u-&gt;z + vcoef * unit_v-&gt;z + g-&gt;surface-&gt;vert[0]-&gt;z;
143 }
144 void grid2uv(struct surface_grid *g, int idx, struct vector2 *v) {
145   int root;
146   int rootrem;
147   int k, j, i;
148   double over3n;
149   root = (int)(sqrt((double)idx));
150   rootrem = idx - root * root;
151   k = g-&gt;n - root - 1;
152   j = rootrem / 2;
153   i = rootrem - 2 * j;
154   over3n = 1.0 / (double)(3 * g-&gt;n);
155   v-&gt;u = ((double)(3 * j + i + 1)) * over3n * g-&gt;surface-&gt;uv_vert1_u +
156          ((double)(3 * k + i + 1)) * over3n * g-&gt;surface-&gt;uv_vert2.u;
157   v-&gt;v = ((double)(3 * k + i + 1)) * over3n * g-&gt;surface-&gt;uv_vert2.v;
158 }
159 void grid2uv_random(struct surface_grid *g, int idx, struct vector2 *v,
160                     struct rng_state *rng) {
161   int root;
162   int rootrem;
163   int k, j, i;
164   double over_n;
165   double u_ran, v_ran;
166   root = (int)(sqrt((double)idx));
167   rootrem = idx - root * root;
168   k = g-&gt;n - root - 1;
169   j = rootrem / 2;
170   i = rootrem - 2 * j;
171   over_n = 1.0 / (double)(g-&gt;n);
172   u_ran = rng_dbl(rng);
173   v_ran = 1.0 - sqrt(rng_dbl(rng));
174   v-&gt;u =
175       ((double)(j + i) + (1 - 2 * i) * (1.0 - v_ran) * u_ran) * over_n *
176           g-&gt;surface-&gt;uv_vert1_u +
177       ((double)(k + i) + (1 - 2 * i) * v_ran) * over_n * g-&gt;surface-&gt;uv_vert2.u;
178   v-&gt;v =
179       ((double)(k + i) + (1 - 2 * i) * v_ran) * over_n * g-&gt;surface-&gt;uv_vert2.v;
180 }
181 void init_grid_geometry(struct surface_grid *g) {
182   g-&gt;inv_strip_wid = 1.0 / (g-&gt;surface-&gt;uv_vert2.v / ((double)g-&gt;n));
183   g-&gt;vert2_slope = g-&gt;surface-&gt;uv_vert2.u / g-&gt;surface-&gt;uv_vert2.v;
184   g-&gt;fullslope = g-&gt;surface-&gt;uv_vert1_u / g-&gt;surface-&gt;uv_vert2.v;
185   g-&gt;vert0.u = g-&gt;surface-&gt;vert[0]-&gt;x * g-&gt;surface-&gt;unit_u.x +
186                g-&gt;surface-&gt;vert[0]-&gt;y * g-&gt;surface-&gt;unit_u.y +
187                g-&gt;surface-&gt;vert[0]-&gt;z * g-&gt;surface-&gt;unit_u.z;
188   g-&gt;vert0.v = g-&gt;surface-&gt;vert[0]-&gt;x * g-&gt;surface-&gt;unit_v.x +
189                g-&gt;surface-&gt;vert[0]-&gt;y * g-&gt;surface-&gt;unit_v.y +
190                g-&gt;surface-&gt;vert[0]-&gt;z * g-&gt;surface-&gt;unit_v.z;
191   g-&gt;n_tiles = g-&gt;n * g-&gt;n;
192 }
193 int create_grid(struct volume *world, struct wall *w, struct subvolume *guess) {
194   struct surface_grid *sg = NULL;
195   struct vector3 center;
196   if (w-&gt;grid != NULL)
197     return 0;
198   sg = (struct surface_grid *)CHECKED_MEM_GET(w-&gt;birthplace-&gt;grids,
199                                               "surface grid");
200   if (sg == NULL)
201     return 1;
202   center.x = 0.33333333333 * (w-&gt;vert[0]-&gt;x + w-&gt;vert[1]-&gt;x + w-&gt;vert[2]-&gt;x);
203   center.y = 0.33333333333 * (w-&gt;vert[0]-&gt;y + w-&gt;vert[1]-&gt;y + w-&gt;vert[2]-&gt;y);
204   center.z = 0.33333333333 * (w-&gt;vert[0]-&gt;z + w-&gt;vert[1]-&gt;z + w-&gt;vert[2]-&gt;z);
205   sg-&gt;surface = w;
206   sg-&gt;subvol = find_subvolume(world, &amp;center, guess);
207   sg-&gt;n = (int)ceil(sqrt(w-&gt;area));
208   if (sg-&gt;n &lt; 1)
209     sg-&gt;n = 1;
210   sg-&gt;n_tiles = sg-&gt;n * sg-&gt;n;
211   sg-&gt;n_occupied = 0;
212   sg-&gt;binding_factor = ((double)sg-&gt;n_tiles) / w-&gt;area;
213   init_grid_geometry(sg);
214   sg-&gt;sm_list = CHECKED_MALLOC_ARRAY(struct surface_molecule_list *, sg-&gt;n_tiles,
215                                      "surface grid");
216   for (unsigned int i = 0; i &lt; sg-&gt;n_tiles; i++) {
217     sg-&gt;sm_list[i] = NULL;
218   }
219   w-&gt;grid = sg;
220   return 0;
221 }
222 void grid_neighbors(struct volume *world, struct surface_grid *grid, int idx,
223                     int create_grid_flag, struct surface_grid **nb_grid,
224                     int *nb_idx) {
225   int i, j, k, root, rootrem;
226   struct vector3 loc_3d;
227   struct vector2 near_2d;
228   double d;
229   root = (int)(sqrt((double)idx));
230   rootrem = idx - root * root;
231   k = root;
232   j = rootrem / 2;
233   i = rootrem - 2 * j;
234   if (j &gt; 0 || i &gt; 0)   {
235     nb_grid[2] = grid;
236     nb_idx[2] = idx - 1;
237   } else   {
238     if (grid-&gt;surface-&gt;nb_walls[2] == NULL)
239       nb_grid[2] = NULL;
240     else if ((grid-&gt;surface-&gt;nb_walls[2]-&gt;grid == NULL) &amp;&amp; (!create_grid_flag))
241       nb_grid[2] = NULL;
242     else {
243       if ((grid-&gt;surface-&gt;nb_walls[2]-&gt;grid == NULL) &amp;&amp; create_grid_flag) {
244         if (create_grid(world, grid-&gt;surface-&gt;nb_walls[2], NULL))
245           mcell_allocfailed("Failed to create grid for wall.");
246       }
247       if (grid-&gt;sm_list[idx]-&gt;sm != NULL)
248         uv2xyz(&amp;grid-&gt;sm_list[idx]-&gt;sm-&gt;s_pos, grid-&gt;surface, &amp;loc_3d);
249       else
250         grid2xyz(grid, idx, &amp;loc_3d);
251       d = closest_interior_point(&amp;loc_3d, grid-&gt;surface-&gt;nb_walls[2], &amp;near_2d,
252                                  GIGANTIC);
253       if (!distinguishable(d, GIGANTIC, EPS_C))
254         nb_grid[2] = NULL;
255       else {
256         nb_grid[2] = grid-&gt;surface-&gt;nb_walls[2]-&gt;grid;
257         nb_idx[2] = uv2grid(&amp;near_2d, nb_grid[2]);
258       }
259     }
260   }
261   if (j &lt; k)   {
262     nb_grid[1] = grid;
263     nb_idx[1] = idx + 1;
264   } else   {
265     if (grid-&gt;surface-&gt;nb_walls[1] == NULL)
266       nb_grid[1] = NULL;
267     else if ((grid-&gt;surface-&gt;nb_walls[1]-&gt;grid == NULL) &amp;&amp; (!create_grid_flag))
268       nb_grid[1] = NULL;
269     else {
270       if ((grid-&gt;surface-&gt;nb_walls[1]-&gt;grid == NULL) &amp;&amp; create_grid_flag) {
271         if (create_grid(world, grid-&gt;surface-&gt;nb_walls[1], NULL))
272           mcell_allocfailed("Failed to create grid for wall.");
273       }
274       if (grid-&gt;sm_list[idx]-&gt;sm != NULL)
275         uv2xyz(&amp;grid-&gt;sm_list[idx]-&gt;sm-&gt;s_pos, grid-&gt;surface, &amp;loc_3d);
276       else
277         grid2xyz(grid, idx, &amp;loc_3d);
278       d = closest_interior_point(&amp;loc_3d, grid-&gt;surface-&gt;nb_walls[1], &amp;near_2d,
279                                  GIGANTIC);
280       if (!distinguishable(d, GIGANTIC, EPS_C))
281         nb_grid[1] = NULL;
282       else {
283         nb_grid[1] = grid-&gt;surface-&gt;nb_walls[1]-&gt;grid;
284         nb_idx[1] = uv2grid(&amp;near_2d, nb_grid[1]);
285       }
286     }
287   }
288   if (i || k + 1 &lt; grid-&gt;n)   {
289     nb_grid[0] = grid;
290     if (i)
291       nb_idx[0] =
292           2 * j + (k - 1) * (k - 1);     else
293       nb_idx[0] = 1 + 2 * j + (k + 1) * (k + 1);   } else   {
294     if (grid-&gt;surface-&gt;nb_walls[0] == NULL)
295       nb_grid[0] = NULL;
296     else if ((grid-&gt;surface-&gt;nb_walls[0]-&gt;grid == NULL) &amp;&amp; (!create_grid_flag))
297       nb_grid[0] = NULL;
298     else {
299       if ((grid-&gt;surface-&gt;nb_walls[0]-&gt;grid == NULL) &amp;&amp; create_grid_flag) {
300         if (create_grid(world, grid-&gt;surface-&gt;nb_walls[0], NULL))
301           mcell_allocfailed("Failed to create grid for wall.");
302       }
303       if (grid-&gt;sm_list[idx]-&gt;sm != NULL)
304         uv2xyz(&amp;grid-&gt;sm_list[idx]-&gt;sm-&gt;s_pos, grid-&gt;surface, &amp;loc_3d);
305       else
306         grid2xyz(grid, idx, &amp;loc_3d);
307       d = closest_interior_point(&amp;loc_3d, grid-&gt;surface-&gt;nb_walls[0], &amp;near_2d,
308                                  GIGANTIC);
309       if (!distinguishable(d, GIGANTIC, EPS_C))
310         nb_grid[0] = NULL;
311       else {
312         nb_grid[0] = grid-&gt;surface-&gt;nb_walls[0]-&gt;grid;
313         nb_idx[0] = uv2grid(&amp;near_2d, nb_grid[0]);
314       }
315     }
316   }
317 }
318 int nearest_free(struct surface_grid *g, struct vector2 *v, double max_d2,
319                  double *found_dist2) {
320   int h, i, j, k;
321   int span;
322   int can_flip;
323   int idx;
324   double d2;
325   double f, ff, fff;
326   double over3n = 0.333333333333333 / (double)(g-&gt;n);
327   if (g-&gt;n_occupied &gt;= g-&gt;n_tiles) {
328     *found_dist2 = 0;
329     return -1;
330   }
331   idx = -1;
332   d2 = 2 * max_d2 + 1.0;
333   for (k = 0; k &lt; g-&gt;n; k++) {
334     f = v-&gt;v - ((double)(3 * k + 1)) * over3n * g-&gt;surface-&gt;uv_vert2.v;
335     ff = f - over3n * g-&gt;surface-&gt;uv_vert2.v;
336     ff *= ff;
337     f *= f;
338     if (f &gt; max_d2 &amp;&amp; ff &gt; max_d2)
339       continue; 
340     span = (g-&gt;n - k);
341     for (j = 0; j &lt; span; j++) {
342       can_flip = (j != span - 1);
343       for (i = 0; i &lt;= can_flip; i++) {
344         fff =
345             v-&gt;u - over3n * ((double)(3 * j + i + 1) * g-&gt;surface-&gt;uv_vert1_u +
346                              (double)(3 * k + i + 1) * g-&gt;surface-&gt;uv_vert2.u);
347         fff *= fff;
348         if (i)
349           fff += ff;
350         else
351           fff += f;
352         if (fff &lt; max_d2 &amp;&amp; (idx == -1 || fff &lt; d2)) {
353           h = (g-&gt;n - k) - 1;
354           h = h * h + 2 * j + i;
355           if (!g-&gt;sm_list[h] || !g-&gt;sm_list[h]-&gt;sm) {
356             idx = h;
357             d2 = fff;
358           } else if (idx == -1) {
359             if (fff &lt; d2)
360               d2 = fff;
361           }
362         }
363       }
364     }
365   }
366   if (found_dist2 != NULL)
367     *found_dist2 = d2;
368   return idx;
369 }
370 int verify_wall_regions_match(
371     const char *mesh_name, struct string_buffer *prev_reg_names, struct wall *w,
372     struct string_buffer *regions_to_ignore,
373     struct mesh_transparency *mesh_transp, const char *species_name) {
374   if ((mesh_name != NULL) &amp;&amp; (prev_reg_names != NULL)) {
375     if (strcmp(w-&gt;parent_object-&gt;sym-&gt;name, mesh_name) != 0) {
376       return 1;
377     }
378     struct name_list *wall_reg_names = NULL;
379     wall_reg_names = find_regions_names_by_wall(w, regions_to_ignore);
380     struct name_list *wrn = NULL;
381     int i = 0;
382     int still_inside = 0;
383     for (char *prn = prev_reg_names-&gt;strings[i]; i &lt; prev_reg_names-&gt;n_strings; i++) {
384       for (wrn = wall_reg_names; wrn != NULL; wrn = wrn-&gt;next) {
385         if (strcmp(prn, wrn-&gt;name) == 0) {
386           still_inside = 1;
387           break;
388         }
389       }
390       if (!still_inside) {
391         struct mesh_transparency *mt = mesh_transp;
392         for (; mt != NULL; mt = mt-&gt;next) {
393           if ((strcmp(mt-&gt;name, prn) == 0) &amp;&amp;
394               (!mt-&gt;transp_top_front || !mt-&gt;transp_top_back)) {
395             if (wall_reg_names != NULL) {
396               remove_molecules_name_list(&amp;wall_reg_names);
397             }
398             return 1;
399           }
400         }
401       }
402       still_inside = 0;
403     }
404     for (wrn = wall_reg_names; wrn != NULL; wrn = wrn-&gt;next) {
405       if (is_string_present_in_string_array(
406          wrn-&gt;name, regions_to_ignore-&gt;strings, regions_to_ignore-&gt;n_strings)) {
407         continue;
408       }
409       if (!is_string_present_in_string_array(
410           wrn-&gt;name, prev_reg_names-&gt;strings, prev_reg_names-&gt;n_strings)) {
411         int cont = 0;
412         struct mesh_transparency *mt = mesh_transp;
413         for (; mt != NULL; mt = mt-&gt;next) {
414           if (strcmp(mt-&gt;name, wrn-&gt;name) == 0) {
415             if (mt-&gt;transp_top_front || mt-&gt;transp_top_back) {
416               cont = 1;
417               break;
418             }
419           }
420         }
421         if (cont) {
422           continue;
423         }
424         remove_molecules_name_list(&amp;wall_reg_names);
425         return 1;
426       }
427     }
428     if (wall_reg_names != NULL) {
429       remove_molecules_name_list(&amp;wall_reg_names);
430     }
431   }
432   return 0;
433 }
434 struct wall *search_nbhd_for_free(struct volume *world, struct wall *origin,
435                                   struct vector2 *point, double max_d2,
436                                   int *found_idx,
437                                   int (*ok)(void *, struct wall *),
438                                   void *context, const char *mesh_name,
439                                   struct string_buffer *reg_names) {
440   struct wall *there = NULL;
441   int i, j;
442   double d2 = 0;
443   struct vector2 pt, ed;
444   struct vector2 vurt0, vurt1;
445   int best_i;
446   double best_d2;
447   struct wall *best_w = NULL;
448   best_i = -1;
449   best_d2 = 2.0 * max_d2 + 1.0;
450   if (origin-&gt;grid == NULL &amp;&amp; create_grid(world, origin, NULL))
451     mcell_allocfailed("Failed to create grid for wall.");
452   i = -1; 
453   if (origin-&gt;grid-&gt;n_occupied &lt; origin-&gt;grid-&gt;n_tiles) {
454     i = nearest_free(origin-&gt;grid, point, max_d2, &amp;d2);
455   }
456   if (i != -1) {
457     best_i = i;
458     best_d2 = d2;
459     best_w = origin;
460   }
461   if (best_w == NULL) {
462     for (j = 0; j &lt; 3; j++) {
463       if (origin-&gt;edges[j] == NULL || origin-&gt;edges[j]-&gt;backward == NULL)
464         continue;
465       if (origin-&gt;edges[j]-&gt;forward == origin)
466         there = origin-&gt;edges[j]-&gt;backward;
467       else
468         there = origin-&gt;edges[j]-&gt;forward;
469       if (ok != NULL &amp;&amp; !(*ok)(context, there))
470         continue; 
471       if (verify_wall_regions_match(mesh_name, reg_names, there, NULL, NULL, NULL)) {
472         continue; 
473       }
474       if (there-&gt;grid != NULL) {
475         if (there-&gt;grid-&gt;n_occupied &gt;= there-&gt;grid-&gt;n_tiles) {
476           continue;
477         }
478       }
479       switch (j) {
480       case 0:
481         vurt0.u = vurt0.v = 0.0;
482         vurt1.u = origin-&gt;uv_vert1_u;
483         vurt1.v = 0;
484         break;
485       case 1:
486         vurt0.u = origin-&gt;uv_vert1_u;
487         vurt0.v = 0;
488         memcpy(&amp;vurt1, &amp;(origin-&gt;uv_vert2), sizeof(struct vector2));
489         break;
490       case 2:
491         memcpy(&amp;vurt0, &amp;(origin-&gt;uv_vert2), sizeof(struct vector2));
492         vurt1.u = vurt1.v = 0.0;
493         break;
494       default:
495         UNHANDLED_CASE(j);
496       }
497       ed.u = vurt1.u - vurt0.u;
498       ed.v = vurt1.v - vurt0.v;
499       pt.u = point-&gt;u - vurt0.u;
500       pt.v = point-&gt;v - vurt0.v;
501       d2 = pt.u * ed.u + pt.v * ed.v;
502       d2 = (pt.u * pt.u + pt.v * pt.v) -
503            d2 * d2 / (ed.u * ed.u + ed.v * ed.v); 
504       if (d2 &lt; best_d2) {
505         if (there-&gt;grid == NULL &amp;&amp; create_grid(world, there, NULL))
506           mcell_allocfailed("Failed to create grid for wall.");
507         traverse_surface(origin, point, j, &amp;pt);
508         i = nearest_free(there-&gt;grid, &amp;pt, max_d2, &amp;d2);
509         if (i != -1 &amp;&amp; d2 &lt; best_d2) {
510           best_i = i;
511           best_d2 = d2;
512           best_w = there;
513         }
514       }
515     }
516   }
517   *found_idx = best_i;
518   return best_w;
519 }
520 void delete_tile_neighbor_list(struct tile_neighbor *head) {
521   struct tile_neighbor *nnext;
522   while (head != NULL) {
523     nnext = head-&gt;next;
524     free(head);
525     head = nnext;
526   }
527 }
528 void delete_region_list(struct region_list *head) {
529   struct region_list *next;
530   while (head != NULL) {
531     next = head-&gt;next;
532     free(head);
533     head = next;
534   }
535 }
536 void push_tile_neighbor_to_list(struct tile_neighbor **head,
537                                 struct surface_grid *grid, int idx) {
538   struct tile_neighbor *old_head = *head;
539   struct tile_neighbor *tile_nbr = CHECKED_MALLOC_STRUCT(struct tile_neighbor,
540                                                          "tile_neighbor");
541   tile_nbr-&gt;grid = grid;
542   tile_nbr-&gt;flag = 0;
543   tile_nbr-&gt;idx = idx;
544   if (old_head == NULL) {
545     tile_nbr-&gt;next = NULL;
546     old_head = tile_nbr;
547   } else {
548     tile_nbr-&gt;next = old_head;
549     old_head = tile_nbr;
550   }
551   *head = old_head;
552 }
553 int push_tile_neighbor_to_list_with_checking(struct tile_neighbor **head,
554                                              struct surface_grid *grid,
555                                              int idx) {
556   struct tile_neighbor *tile_nbr, *old_head;
557   old_head = *head;
558   for (tile_nbr = old_head; tile_nbr != NULL; tile_nbr = tile_nbr-&gt;next) {
559     if ((tile_nbr-&gt;grid == grid) &amp;&amp; (tile_nbr-&gt;idx == (u_int)idx))
560       return 0;
561   }
562   tile_nbr = CHECKED_MALLOC_STRUCT(struct tile_neighbor, "tile_neighbor");
563   tile_nbr-&gt;grid = grid;
564   tile_nbr-&gt;flag = 0;
565   tile_nbr-&gt;idx = idx;
566   if (old_head == NULL) {
567     tile_nbr-&gt;next = NULL;
568     old_head = tile_nbr;
569   } else {
570     tile_nbr-&gt;next = old_head;
571     old_head = tile_nbr;
572   }
573   *head = old_head;
574   return 1;
575 }
576 int get_tile_neighbor_from_list_of_vacant_neighbors(struct tile_neighbor *head,
577   int list_index, struct surface_grid **grid, int *tile_idx) {
578   struct tile_neighbor *curr = head;
579   int iter = 0;    int count = 0; 
580   while (curr != NULL) {
581     if ((curr-&gt;flag &amp; TILE_CHECKED) == 0) {
582       count++;
583     }
584     if ((iter == list_index) &amp;&amp; ((curr-&gt;flag &amp; TILE_CHECKED) == 0)) {
585       curr-&gt;flag |= TILE_CHECKED;
586       *grid = curr-&gt;grid;
587       *tile_idx = curr-&gt;idx;
588     }
589     iter++;
590     curr = curr-&gt;next;
591   }
592   return count;
593 }
594 void uncheck_vacant_tile(struct tile_neighbor *head, int list_index) {
595   struct tile_neighbor *curr = head;
596   int iter = 0; 
597   while (curr != NULL) {
598     if ((iter == list_index) &amp;&amp; (curr-&gt;flag &amp; TILE_CHECKED)) {
599       curr-&gt;flag &amp;= ~TILE_CHECKED;
600     }
601     iter++;
602     curr = curr-&gt;next;
603   }
604 }
605 void get_tile_vertices(struct surface_grid *sg, int idx, int *flp,
606                        struct vector2 *R, struct vector2 *S,
607                        struct vector2 *T) {
608   int strip, stripe, flip;
609   int root, rootrem;
610   struct vector2 P, Q, X, Y;
611   double pq, xy;
612   double cot_angle;
613   root = (int)(sqrt((double)idx));
614   rootrem = idx - root * root;
615   strip = sg-&gt;n - root - 1;
616   stripe = rootrem / 2;
617   flip = rootrem - 2 * stripe;
618   P.v = Q.v = strip / sg-&gt;inv_strip_wid;
619   X.v = Y.v = (strip + 1) / sg-&gt;inv_strip_wid;
620   P.u = (P.v) * (sg-&gt;vert2_slope);
621   X.u = (X.v) * (sg-&gt;vert2_slope);
622   cot_angle = (sg-&gt;surface-&gt;uv_vert1_u - sg-&gt;surface-&gt;uv_vert2.u) /
623               (sg-&gt;surface-&gt;uv_vert2.v);
624   Q.u = sg-&gt;surface-&gt;uv_vert1_u - (Q.v) * cot_angle;
625   Y.u = sg-&gt;surface-&gt;uv_vert1_u - (Y.v) * cot_angle;
626   pq = Q.u - P.u;
627   if (idx == 0) {
628     xy = 0;
629   } else {
630     xy = Y.u - X.u;
631   }
632   if (flip == 1) {
633     R-&gt;v = P.v;
634     R-&gt;u = P.u + pq * (stripe + 1) / (sg-&gt;n - strip);
635     S-&gt;v = T-&gt;v = X.v;
636     T-&gt;u = X.u + xy * stripe / (sg-&gt;n - strip - 1);
637     S-&gt;u = X.u + xy * (stripe + 1) / (sg-&gt;n - strip - 1);
638   } else {
639     R-&gt;v = S-&gt;v = P.v;
640     T-&gt;v = X.v;
641     R-&gt;u = P.u + pq * stripe / (sg-&gt;n - strip);
642     S-&gt;u = P.u + pq * (stripe + 1) / (sg-&gt;n - strip);
643     if (idx == 0) {
644       T-&gt;u = X.u;
645     } else {
646       T-&gt;u = X.u + xy * stripe / (sg-&gt;n - strip - 1);
647     }
648   }
649   *flp = flip;
650 }
651 int tile_orientation(struct vector2 *v, struct surface_grid *g) {
652   double i, j;
653   double u0, u1_u0;
654   double striploc, striprem, stripeloc, striperem;
655   int strip, stripe, flip;
656   i = v-&gt;u;
657   j = v-&gt;v;
658   striploc = j * g-&gt;inv_strip_wid;
659   strip = (int)striploc;
660   striprem = striploc - strip;
661   strip = g-&gt;n - strip - 1;
662   u0 = j * g-&gt;vert2_slope;
663   u1_u0 = g-&gt;surface-&gt;uv_vert1_u - j * g-&gt;fullslope;
664   stripeloc = ((i - u0) / u1_u0) * (((double)strip) + (1.0 - striprem));
665   stripe = (int)(stripeloc);
666   striperem = stripeloc - stripe;
667   flip = (striperem &lt; 1.0 - striprem) ? 0 : 1;
668   return flip;
669 }
670 void grid_all_neighbors_for_inner_tile(
671     struct volume *world, struct surface_grid *grid, int idx,
672     struct vector2 *pos, struct tile_neighbor **tile_neighbor_head,
673     int *list_length) {
674   struct tile_neighbor *tile_nbr_head = NULL;
675   int count = 0;
676   int vert_nbr_ind = -1;
677   int kk;
678   struct surface_grid *sg[3];   int si[3]; 
679   if ((u_int)idx &gt;= grid-&gt;n_tiles) {
680     mcell_internal_error(
681         "Surface molecule tile index is greater than or equal of "
682         "the number of tiles on the grid\n");
683   }
684   for (kk = 0; kk &lt; 3; kk++) {
685     sg[kk] = NULL;
686     si[kk] = -1;
687   }
688   grid_neighbors(world, grid, idx, 0, sg, si);
689   if ((grid != sg[0]) || (grid != sg[1]) || (grid != sg[2])) {
690     mcell_internal_error("The function 'grid_all_neighbors_for_inner_tile()' "
691                          "is called for the tile %d that is not an inner tile.",
692                          idx);
693   }
694   for (kk = 0; kk &lt; 3; kk++) {
695     if ((si[kk] != idx - 1) &amp;&amp; (si[kk] != idx + 1)) {
696       vert_nbr_ind = si[kk];
697       break;
698     }
699   }
700   push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 1);
701   count++;
702   push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 2);
703   count++;
704   push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 1);
705   count++;
706   push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 2);
707   count++;
708   int tile_orient = tile_orientation(pos, grid);
709   int temp_ind;
710   if (tile_orient == 0) {
711     push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind);
712     count++;
713     push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind - 1);
714     count++;
715     push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind - 2);
716     count++;
717     push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind + 1);
718     count++;
719     push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind + 2);
720     count++;
721     temp_ind = move_strip_down(grid, idx);
722     if (temp_ind == -1) {
723       mcell_internal_error("The function 'grid_all_neighbors_for_inner_tile() "
724                            "is called for the tile %d that is not an inner "
725                            "tile.",
726                            idx);
727     }
728     push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_ind);
729     count++;
730     push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_ind - 1);
731     count++;
732     push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_ind + 1);
733     count++;
734   } else {
735     temp_ind = move_strip_up(grid, idx);
736     if (temp_ind == -1) {
737       mcell_internal_error("The function 'grid_all_neighbors_for_inner_tile() "
738                            "is called for the tile %d that is not an inner "
739                            "tile.",
740                            idx);
741     }
742     push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_ind);
743     count++;
744     push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_ind - 1);
745     count++;
746     push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_ind + 1);
747     count++;
748     push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind);
749     count++;
750     push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind - 1);
751     count++;
752     push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind - 2);
753     count++;
754     push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind + 1);
755     count++;
756     push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind + 2);
757     count++;
758   }
759   if (count != 12) {
760     mcell_internal_error("The function 'grid_all_neighbors_for_inner_tile() is "
761                          "called for the tile %d that is not an inner tile.",
762                          idx);
763   } else {
764     *list_length = count;
765   }
766   *tile_neighbor_head = tile_nbr_head;
767 }
768 void grid_all_neighbors_across_walls_through_vertices(
769     struct volume *world, struct surface_molecule *sm,
770     struct wall_list *wall_nbr_head, struct surface_grid *grid,
771     int create_grid_flag, int search_for_reactant,
772     struct tile_neighbor **tile_neighbor_head, int *list_length) {
773   struct tile_neighbor *tile_nbr_head = NULL;
774   struct wall_list *wl;
775   struct wall *w;
776   long long origin_vert_indices[3], nbr_vert_indices[3];
777   int i, k;
778   int tiles_count = 0;   struct region_list *rlp_head_own_wall = NULL;
779   struct region_list *rlp_head_nbr_wall;
780   if ((sm != NULL) &amp;&amp; (sm-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER)) {
781     rlp_head_own_wall =
782         find_restricted_regions_by_wall(world, sm-&gt;grid-&gt;surface, sm);
783   }
784   for (wl = wall_nbr_head; wl != NULL; wl = wl-&gt;next) {
785     w = wl-&gt;this_wall;
786     rlp_head_nbr_wall = NULL;
787     if (w-&gt;grid == NULL) {
788       if (create_grid_flag) {
789         if (create_grid(world, w, NULL))
790           mcell_allocfailed("Failed to allocate grid for wall.");
791       } else {
792         continue;
793       }
794     }
795     if (search_for_reactant &amp;&amp; (rlp_head_own_wall != NULL)) {
796       if (!wall_belongs_to_all_regions_in_region_list(w, rlp_head_own_wall))
797         continue;
798     }
799     if (sm != NULL) {
800       if (search_for_reactant &amp;&amp; (sm-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER)) {
801         rlp_head_nbr_wall = find_restricted_regions_by_wall(world, w, sm);
802         if (rlp_head_nbr_wall != NULL) {
803           if (!wall_belongs_to_all_regions_in_region_list(sm-&gt;grid-&gt;surface,
804                                                           rlp_head_nbr_wall)) {
805             delete_void_list((struct void_list *)rlp_head_nbr_wall);
806             continue;
807           } else {
808             delete_void_list((struct void_list *)rlp_head_nbr_wall);
809           }
810         }
811       }
812     }
813     if (w-&gt;grid-&gt;n_tiles == 1) {
814       nbr_tile_idx = 0;
815     } else {
816       nbr_wall_vertex_id = -1;
817       nbr_tile_idx = -1;
818       for (i = 0; i &lt; 3; i++) {
819         origin_vert_indices[i] = (long long)(grid-&gt;surface-&gt;vert[i] - world-&gt;all_vertices);
820       }
821       for (i = 0; i &lt; 3; i++) {
822         nbr_vert_indices[i] = (long long)(w-&gt;grid-&gt;surface-&gt;vert[i] - world-&gt;all_vertices);
823       }
824       for (i = 0; i &lt; 3; i++) {
825         for (k = 0; k &lt; 3; k++) {
826           if (origin_vert_indices[i] == nbr_vert_indices[k]) {
827             nbr_wall_vertex_id = nbr_vert_indices[k];
828             break;
829           }
830         }
831       }
832       if (nbr_wall_vertex_id == -1)
833         mcell_internal_error("Error identifying tile on the neighbor wall.");
834       if (&amp;world-&gt;all_vertices[nbr_wall_vertex_id] ==
835           w-&gt;grid-&gt;surface-&gt;vert[0]) {
836         nbr_tile_idx = w-&gt;grid-&gt;n_tiles - 2 * (w-&gt;grid-&gt;n) + 1;
837       } else if (&amp;world-&gt;all_vertices[nbr_wall_vertex_id] ==
838                  w-&gt;grid-&gt;surface-&gt;vert[1]) {
839         nbr_tile_idx = w-&gt;grid-&gt;n_tiles - 1;
840       } else if (&amp;world-&gt;all_vertices[nbr_wall_vertex_id] ==
841                  w-&gt;grid-&gt;surface-&gt;vert[2]) {
842         nbr_tile_idx = 0;
843       }
844       if (nbr_tile_idx == -1)
845         mcell_internal_error("Error identifying tile on the neighbor wall.");
846     }
847     push_tile_neighbor_to_list(&amp;tile_nbr_head, w-&gt;grid, nbr_tile_idx);
848     tiles_count++;
849   }
850   *list_length = tiles_count;
851   *tile_neighbor_head = tile_nbr_head;
852   if (rlp_head_own_wall != NULL)
853     delete_void_list((struct void_list *)rlp_head_own_wall);
854 }
855 void grid_all_neighbors_across_walls_through_edges(
856     struct volume *world, struct surface_molecule *sm,
857     struct surface_grid *grid, int idx, int create_grid_flag,
858     int search_for_reactant, struct tile_neighbor **tile_neighbor_head,
859     int *list_length) {
860   struct tile_neighbor *tile_nbr_head = NULL;
861   int tiles_count = 0;
862   int kk;
863   int root, rootrem, strip, stripe, flip;
864 <a name="1"></a>  int temp_idx;
865 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  struct region_list *rlp_head_own_wall = NULL;
866   struct region_list *rlp_head_nbr_wall_0 = NULL;
867   struct region_list *rlp_head_nbr_wall_1 = NULL;
868   struct region_list *rlp_head_nbr_wall_2 = NULL;</b></font>
869   int move_thru_border_0 = 1;
870   int move_thru_border_1 = 1;
871   int move_thru_border_2 = 1;
872   if ((sm != NULL) &amp;&amp; search_for_reactant &amp;&amp;
873       (sm-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER)) {
874     rlp_head_own_wall =
875         find_restricted_regions_by_wall(world, sm-&gt;grid-&gt;surface, sm);
876     if (sm-&gt;grid-&gt;surface-&gt;nb_walls[0] != NULL) {
877       rlp_head_nbr_wall_0 = find_restricted_regions_by_wall(
878           world, sm-&gt;grid-&gt;surface-&gt;nb_walls[0], sm);
879       if (rlp_head_own_wall != NULL) {
880         if (!wall_belongs_to_all_regions_in_region_list(
881                  sm-&gt;grid-&gt;surface-&gt;nb_walls[0], rlp_head_own_wall))
882           move_thru_border_0 = 0;
883       }
884       if (rlp_head_nbr_wall_0 != NULL) {
885         if (!wall_belongs_to_all_regions_in_region_list(sm-&gt;grid-&gt;surface,
886                                                         rlp_head_nbr_wall_0))
887           move_thru_border_0 = 0;
888       }
889       if (rlp_head_nbr_wall_0 != NULL)
890         delete_void_list((struct void_list *)rlp_head_nbr_wall_0);
891     } else {
892       move_thru_border_0 = 0;
893     }
894     if (sm-&gt;grid-&gt;surface-&gt;nb_walls[1] != NULL) {
895       rlp_head_nbr_wall_1 = find_restricted_regions_by_wall(
896           world, sm-&gt;grid-&gt;surface-&gt;nb_walls[1], sm);
897       if (rlp_head_own_wall != NULL) {
898         if (!wall_belongs_to_all_regions_in_region_list(
899                  sm-&gt;grid-&gt;surface-&gt;nb_walls[1], rlp_head_own_wall))
900           move_thru_border_1 = 0;
901       }
902       if (rlp_head_nbr_wall_1 != NULL) {
903         if (!wall_belongs_to_all_regions_in_region_list(sm-&gt;grid-&gt;surface,
904                                                         rlp_head_nbr_wall_1))
905           move_thru_border_1 = 0;
906       }
907       if (rlp_head_nbr_wall_1 != NULL)
908         delete_void_list((struct void_list *)rlp_head_nbr_wall_1);
909     } else {
910       move_thru_border_1 = 0;
911     }
912     if (sm-&gt;grid-&gt;surface-&gt;nb_walls[2] != NULL) {
913       rlp_head_nbr_wall_2 = find_restricted_regions_by_wall(
914           world, sm-&gt;grid-&gt;surface-&gt;nb_walls[2], sm);
915       if (rlp_head_own_wall != NULL) {
916         if (!wall_belongs_to_all_regions_in_region_list(
917                  sm-&gt;grid-&gt;surface-&gt;nb_walls[2], rlp_head_own_wall))
918           move_thru_border_2 = 0;
919       }
920       if (rlp_head_nbr_wall_2 != NULL) {
921         if (!wall_belongs_to_all_regions_in_region_list(sm-&gt;grid-&gt;surface,
922                                                         rlp_head_nbr_wall_2))
923           move_thru_border_2 = 0;
924       }
925       if (rlp_head_nbr_wall_2 != NULL)
926         delete_void_list((struct void_list *)rlp_head_nbr_wall_2);
927     } else {
928       move_thru_border_2 = 0;
929     }
930     if (rlp_head_own_wall != NULL)
931       delete_void_list((struct void_list *)rlp_head_own_wall);
932   }
933   if ((u_int)idx &gt;= grid-&gt;n_tiles) {
934     mcell_internal_error("Surface molecule tile index %u is greater than or "
935                          "equal of the number of tiles on the grid %u\n",
936                          (u_int)idx, grid-&gt;n_tiles);
937   }
938   root = (int)(sqrt((double)idx));
939   rootrem = idx - root * root;
940   strip = grid-&gt;n - root - 1;
941   stripe = rootrem / 2;
942   flip = rootrem - 2 * stripe;
943   if (create_grid_flag) {
944     for (kk = 0; kk &lt; 3; kk++) {
945       if ((grid-&gt;surface-&gt;nb_walls[kk] != NULL) &amp;&amp;
946           (grid-&gt;surface-&gt;nb_walls[kk]-&gt;grid == NULL)) {
947         if (create_grid(world, grid-&gt;surface-&gt;nb_walls[kk], NULL))
948           mcell_allocfailed("Failed to create grid for wall.");
949       }
950     }
951   }
952   if (stripe == 0) {
953     if (flip &gt; 0)     {
954       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 1);
955       tiles_count++;
956       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 1);
957       tiles_count++;
958       if (strip &lt; grid-&gt;n - 2) {
959         push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 2);
960         tiles_count++;
961       }
962       temp_idx = move_strip_down(grid, idx);
963       if (temp_idx == -1) {
964         mcell_internal_error("Error in navigating on the grid");
965       }
966       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
967       tiles_count++;
968       if (strip &lt; grid-&gt;n - 2) {
969         push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 1);
970         tiles_count++;
971         push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 2);
972         tiles_count++;
973       }
974       if (strip &gt; 0) {
975         temp_idx = move_strip_up(grid, idx);
976         if (temp_idx == -1) {
977           mcell_internal_error("Error in navigating on the grid");
978         }
979         push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
980         tiles_count++;
981         push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 1);
982         tiles_count++;
983         push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 1);
984         tiles_count++;
985       }
986       if ((grid-&gt;surface-&gt;nb_walls[2] != NULL) &amp;&amp;
987           (grid-&gt;surface-&gt;nb_walls[2]-&gt;grid != NULL)) {
988         if (move_thru_border_2) {
989           tiles_added = add_more_tile_neighbors_to_list_fast(
990               &amp;tile_nbr_head, grid, strip, stripe, flip, grid-&gt;surface-&gt;vert[0],
991               grid-&gt;surface-&gt;vert[2], 2, grid-&gt;surface-&gt;nb_walls[2]-&gt;grid);
992           tiles_count += tiles_added;
993         }
994       }
995       if (strip == 0) {
996         if ((grid-&gt;surface-&gt;nb_walls[0] != NULL) &amp;&amp;
997             (grid-&gt;surface-&gt;nb_walls[0]-&gt;grid != NULL)) {
998           if (move_thru_border_0) {
999             tiles_added = add_more_tile_neighbors_to_list_fast(
1000                 &amp;tile_nbr_head, grid, strip, stripe, flip,
1001                 grid-&gt;surface-&gt;vert[0], grid-&gt;surface-&gt;vert[1], 0,
1002                 grid-&gt;surface-&gt;nb_walls[0]-&gt;grid);
1003             tiles_count += tiles_added;
1004           }
1005         }
1006       }
1007       if (strip == (grid-&gt;n - 2)) {
1008         if ((grid-&gt;surface-&gt;nb_walls[1] != NULL) &amp;&amp;
1009             (grid-&gt;surface-&gt;nb_walls[1]-&gt;grid != NULL)) {
1010           if (move_thru_border_1) {
1011             tiles_added = add_more_tile_neighbors_to_list_fast(
1012                 &amp;tile_nbr_head, grid, strip, stripe, flip,
1013                 grid-&gt;surface-&gt;vert[1], grid-&gt;surface-&gt;vert[2], 1,
1014                 grid-&gt;surface-&gt;nb_walls[1]-&gt;grid);
1015             tiles_count += tiles_added;
1016           }
1017         }
1018       }
1019     } else {              if (idx == 0)       {
1020         if (grid-&gt;n_tiles &gt; 1) {
1021           temp_idx = move_strip_up(grid, idx);
1022           if (temp_idx == -1) {
1023             mcell_internal_error("Error in navigating on the grid");
1024           }
1025           push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
1026           tiles_count++;
1027           push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 1);
1028           tiles_count++;
1029           push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 1);
1030           tiles_count++;
1031         } else {
1032           if ((grid-&gt;surface-&gt;nb_walls[0] != NULL) &amp;&amp;
1033               (grid-&gt;surface-&gt;nb_walls[0]-&gt;grid != NULL)) {
1034             if (move_thru_border_0) {
1035               tiles_added = add_more_tile_neighbors_to_list_fast(
1036                   &amp;tile_nbr_head, grid, strip, stripe, flip,
1037                   grid-&gt;surface-&gt;vert[0], grid-&gt;surface-&gt;vert[1], 0,
1038                   grid-&gt;surface-&gt;nb_walls[0]-&gt;grid);
1039               tiles_count += tiles_added;
1040             }
1041           }
1042         }
1043         if ((grid-&gt;surface-&gt;nb_walls[1] != NULL) &amp;&amp;
1044             (grid-&gt;surface-&gt;nb_walls[1]-&gt;grid != NULL)) {
1045           if (move_thru_border_1) {
1046             tiles_added = add_more_tile_neighbors_to_list_fast(
1047                 &amp;tile_nbr_head, grid, strip, stripe, flip,
1048                 grid-&gt;surface-&gt;vert[1], grid-&gt;surface-&gt;vert[2], 1,
1049                 grid-&gt;surface-&gt;nb_walls[1]-&gt;grid);
1050             tiles_count += tiles_added;
1051           }
1052         }
1053         if ((grid-&gt;surface-&gt;nb_walls[2] != NULL) &amp;&amp;
1054             (grid-&gt;surface-&gt;nb_walls[2]-&gt;grid != NULL)) {
1055           if (move_thru_border_2) {
1056             tiles_added = add_more_tile_neighbors_to_list_fast(
1057                 &amp;tile_nbr_head, grid, strip, stripe, flip,
1058                 grid-&gt;surface-&gt;vert[0], grid-&gt;surface-&gt;vert[2], 2,
1059                 grid-&gt;surface-&gt;nb_walls[2]-&gt;grid);
1060             tiles_count += tiles_added;
1061           }
1062         }
1063       } else { 
1064         push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 1);
1065         tiles_count++;
1066         push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 2);
1067         tiles_count++;
1068         temp_idx = move_strip_down(grid, idx + 1);
1069         if (temp_idx == -1) {
1070           mcell_internal_error("Error in navigating on the grid");
1071         }
1072         push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
1073         tiles_count++;
1074         if (strip &gt; 0) {
1075           temp_idx = move_strip_up(grid, idx);
1076           if (temp_idx == -1) {
1077             mcell_internal_error("Error in navigating on the grid");
1078           }
1079           push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
1080           tiles_count++;
1081           push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 1);
1082           tiles_count++;
1083           push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 1);
1084           tiles_count++;
1085           push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 2);
1086           tiles_count++;
1087           if ((grid-&gt;surface-&gt;nb_walls[0] != NULL) &amp;&amp;
1088               (grid-&gt;surface-&gt;nb_walls[0]-&gt;grid != NULL)) {
1089             if (move_thru_border_0) {
1090               tiles_added = add_more_tile_neighbors_to_list_fast(
1091                   &amp;tile_nbr_head, grid, strip, stripe, flip,
1092                   grid-&gt;surface-&gt;vert[0], grid-&gt;surface-&gt;vert[1], 0,
1093                   grid-&gt;surface-&gt;nb_walls[0]-&gt;grid);
1094               tiles_count += tiles_added;
1095             }
1096           }
1097           if ((grid-&gt;surface-&gt;nb_walls[2] != NULL) &amp;&amp;
1098               (grid-&gt;surface-&gt;nb_walls[2]-&gt;grid != NULL)) {
1099             if (move_thru_border_2) {
1100               tiles_added = add_more_tile_neighbors_to_list_fast(
1101                   &amp;tile_nbr_head, grid, strip, stripe, flip,
1102                   grid-&gt;surface-&gt;vert[0], grid-&gt;surface-&gt;vert[2], 2,
1103                   grid-&gt;surface-&gt;nb_walls[2]-&gt;grid);
1104               tiles_count += tiles_added;
1105             }
1106           }
1107         }
1108       } 
1109     } 
1110   } 
1111   if ((strip == 0) &amp;&amp; (stripe &gt; 0)) {
1112     push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 1);
1113     tiles_count++;
1114     push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 2);
1115     tiles_count++;
1116     if ((stripe &lt; grid-&gt;n - 2) || ((stripe == grid-&gt;n - 2) &amp;&amp; (flip == 0))) {
1117       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 1);
1118       tiles_count++;
1119       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 2);
1120       tiles_count++;
1121     } else if ((stripe == grid-&gt;n - 2) &amp;&amp; (flip == 1)) {
1122       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 1);
1123       tiles_count++;
1124     }
1125     if (flip &gt; 0) {
1126       temp_idx = move_strip_down(grid, idx);
1127       if (temp_idx == -1) {
1128         mcell_internal_error("Error in navigating on the grid");
1129       }
1130       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
1131       tiles_count++;
1132       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 1);
1133       tiles_count++;
1134       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 2);
1135       tiles_count++;
1136       if (stripe &lt; grid-&gt;n - 2) {
1137         push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 1);
1138         tiles_count++;
1139         push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 2);
1140         tiles_count++;
1141       }
1142     } else {       if ((unsigned int)idx &lt; grid-&gt;n_tiles - 1) {
1143         temp_idx = move_strip_down(grid, idx);
1144         if (temp_idx == -1) {
1145           mcell_internal_error("Error in navigating on the grid");
1146         }
1147         push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
1148         tiles_count++;
1149         push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 1);
1150         tiles_count++;
1151         push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 1);
1152         tiles_count++;
1153       } else {
1154         temp_idx = move_strip_down(grid, idx - 1);
1155         if (temp_idx == -1) {
1156           mcell_internal_error("Error in navigating on the grid");
1157         }
1158         push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
1159         tiles_count++;
1160       }
1161     }
1162     if ((grid-&gt;surface-&gt;nb_walls[0] != NULL) &amp;&amp;
1163         (grid-&gt;surface-&gt;nb_walls[0]-&gt;grid != NULL)) {
1164       if (move_thru_border_0) {
1165         tiles_added = add_more_tile_neighbors_to_list_fast(
1166             &amp;tile_nbr_head, grid, strip, stripe, flip, grid-&gt;surface-&gt;vert[0],
1167             grid-&gt;surface-&gt;vert[1], 0, grid-&gt;surface-&gt;nb_walls[0]-&gt;grid);
1168         tiles_count += tiles_added;
1169       }
1170     }
1171     if (((u_int)idx == (grid-&gt;n_tiles - 1)) ||
1172         ((u_int)idx == (grid-&gt;n_tiles - 2))) {
1173       if ((grid-&gt;surface-&gt;nb_walls[1] != NULL) &amp;&amp;
1174           (grid-&gt;surface-&gt;nb_walls[1]-&gt;grid != NULL)) {
1175         if (move_thru_border_1) {
1176           tiles_added = add_more_tile_neighbors_to_list_fast(
1177               &amp;tile_nbr_head, grid, strip, stripe, flip, grid-&gt;surface-&gt;vert[1],
1178               grid-&gt;surface-&gt;vert[2], 1, grid-&gt;surface-&gt;nb_walls[1]-&gt;grid);
1179           tiles_count += tiles_added;
1180         }
1181       }
1182     }
1183   } 
1184   if ((strip &gt; 0) &amp;&amp; (stripe &gt; 0)) {
1185     if (flip &gt; 0) {
1186       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 1);
1187       tiles_count++;
1188       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 2);
1189       tiles_count++;
1190       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 1);
1191       tiles_count++;
1192       temp_idx = move_strip_up(grid, idx);
1193       if (temp_idx == -1) {
1194         mcell_internal_error("Error in navigating on the grid");
1195       }
1196       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
1197       tiles_count++;
1198       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 1);
1199       tiles_count++;
1200       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 1);
1201       tiles_count++;
1202       temp_idx = move_strip_down(grid, idx);
1203       if (temp_idx == -1) {
1204         mcell_internal_error("Error in navigating on the grid");
1205       }
1206       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
1207       tiles_count++;
1208       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 1);
1209       tiles_count++;
1210       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 2);
1211       tiles_count++;
1212     } else { 
1213       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 1);
1214       tiles_count++;
1215       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 2);
1216       tiles_count++;
1217       temp_idx = move_strip_up(grid, idx);
1218       if (temp_idx == -1) {
1219         mcell_internal_error("Error in navigating on the grid");
1220       }
1221       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
1222       tiles_count++;
1223       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 1);
1224       tiles_count++;
1225       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 2);
1226       tiles_count++;
1227       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 1);
1228       tiles_count++;
1229       temp_idx = move_strip_down(grid, idx - 1);
1230       if (temp_idx == -1) {
1231         mcell_internal_error("Error in navigating on the grid");
1232       }
1233       push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
1234       tiles_count++;
1235     }
1236     if ((grid-&gt;surface-&gt;nb_walls[1] != NULL) &amp;&amp;
1237         (grid-&gt;surface-&gt;nb_walls[1]-&gt;grid != NULL)) {
1238       if (move_thru_border_1) {
1239         tiles_added = add_more_tile_neighbors_to_list_fast(
1240             &amp;tile_nbr_head, grid, strip, stripe, flip, grid-&gt;surface-&gt;vert[1],
1241             grid-&gt;surface-&gt;vert[2], 1, grid-&gt;surface-&gt;nb_walls[1]-&gt;grid);
1242         tiles_count += tiles_added;
1243       }
1244     }
1245   } 
1246   *list_length = tiles_count;
1247   *tile_neighbor_head = tile_nbr_head;
1248 }
1249 int add_more_tile_neighbors_to_list_fast(struct tile_neighbor **tile_nbr_head,
1250                                          struct surface_grid *orig_grid,
1251                                          int orig_strip, int orig_stripe,
1252                                          int orig_flip, struct vector3 *start,
1253                                          struct vector3 *end, int edge_index,
1254                                          struct surface_grid *new_grid) {
1255   double orig_pos_1 = -1, orig_pos_2 = -1;
1256   const int new_pos_size = new_grid-&gt;n + 1;
1257   std::vector&lt;double&gt; new_pos(new_pos_size);
1258   std::vector&lt;std::vector&lt;int&gt;&gt; new_tile_idx(new_pos_size);
1259   for (auto&amp; elem: new_tile_idx) {
1260     elem.resize(3);
1261   }
1262   int i, k;
1263   int shared_vert_1 = -1, shared_vert_2 = -1;
1264   int new_start_index, new_end_index;
1265   int tiles_added = 0; 
1266   if (orig_grid == new_grid) {
1267     mcell_internal_error("Function 'add_more_tile_neighbors_to_list()' should "
1268                          "be called for different grids only");
1269   }
1270   edge_length = distance_vec3(start, end);
1271   if (orig_stripe == 0) {
1272     if (orig_strip &gt; 0) {
1273       if (orig_flip == 0) {
1274         orig_pos_1 = orig_strip * edge_length / (orig_grid-&gt;n);
1275         orig_pos_2 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
1276       } else {         orig_pos_1 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
1277       }
1278     } else {
1279       if (edge_index == 0) {
1280         if (orig_flip == 0) {
1281           orig_pos_1 = orig_stripe * edge_length / (orig_grid-&gt;n);
1282           orig_pos_2 = (orig_stripe + 1) * edge_length / (orig_grid-&gt;n);
1283         } else { <a name="0"></a>          orig_pos_1 = (orig_stripe + 1) * edge_length / (orig_grid-&gt;n);
1284         }
1285       } else if (edge_index == 1) {
1286 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        if (orig_flip == 0) {
1287           orig_pos_1 = (orig_strip) * edge_length / (orig_grid-&gt;n);
1288         } else {           orig_pos_1 = orig_strip * edge_length / (orig_grid-&gt;n);
1289           orig_pos_2 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
1290         }
1291       } else if (edge_index == 2) {</b></font>
1292         if (orig_flip == 0) {
1293           orig_pos_1 = orig_strip * edge_length / (orig_grid-&gt;n);
1294           orig_pos_2 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
1295         } else {           orig_pos_1 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
1296         }
1297       } else {
1298         mcell_internal_error(
1299             "Error in the function 'add_more_tile_neighbors_to_list_fast()'.");
1300       }
1301     }
1302   }
1303   check_side_flag = 0;
1304   if ((orig_strip == 0) &amp;&amp; (orig_stripe &gt; 0)) {
1305     if (orig_stripe == orig_grid-&gt;n - 1)
1306       check_side_flag = 1;
1307     if ((orig_stripe == orig_grid-&gt;n - 2) &amp;&amp; (orig_flip == 1))
1308       check_side_flag = 1;
1309     if (!check_side_flag) {
1310       if (orig_flip == 0) {
1311         orig_pos_1 = orig_stripe * edge_length / (orig_grid-&gt;n);
1312         orig_pos_2 = (orig_stripe + 1) * edge_length / (orig_grid-&gt;n);
1313       } else {         orig_pos_1 = (orig_stripe + 1) * edge_length / (orig_grid-&gt;n);
1314       }
1315     } else {
1316       if (edge_index == 0) {
1317         if (orig_flip == 0) {
1318           orig_pos_1 = orig_stripe * edge_length / (orig_grid-&gt;n);
1319           orig_pos_2 = (orig_stripe + 1) * edge_length / (orig_grid-&gt;n);
1320         } else {           orig_pos_1 = (orig_stripe + 1) * edge_length / (orig_grid-&gt;n);
1321         }
1322       } else if (edge_index == 1) {
1323         if (orig_flip == 0) {
1324           orig_pos_1 = orig_strip * edge_length / (orig_grid-&gt;n);
1325           orig_pos_2 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
1326         } else {           orig_pos_1 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
1327         }
1328       } else {
1329         mcell_internal_error(
1330             "Error in the function 'add_more_tile_neighbors_to_list_fast()'.");
1331       }
1332     }
1333   }
1334   if ((orig_strip &gt; 0) &amp;&amp; (orig_stripe &gt; 0)) {
1335     if (orig_flip == 0) {
1336       orig_pos_1 = orig_strip * edge_length / (orig_grid-&gt;n);
1337       orig_pos_2 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
1338     } else {       orig_pos_1 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
1339     }
1340   }
1341   find_shared_vertices_for_neighbor_walls(orig_grid-&gt;surface, new_grid-&gt;surface,
1342                                           &amp;shared_vert_1, &amp;shared_vert_2);
1343   if (!distinguishable_vec3(start, new_grid-&gt;surface-&gt;vert[shared_vert_1],
1344                             EPS_C)) {
1345     new_start_index = shared_vert_1;
1346     new_end_index = shared_vert_2;
1347   } else {
1348     new_start_index = shared_vert_2;
1349     new_end_index = shared_vert_1;
1350   }
1351   if (new_start_index &gt; new_end_index)
1352     invert_orig_pos = 1;
1353   if (invert_orig_pos) {
1354     orig_pos_1 = edge_length - orig_pos_1;
1355     if (orig_pos_2 &gt; 0) {
1356       orig_pos_2 = edge_length - orig_pos_2;
1357     }
1358   }
1359   for (i = 0; i &lt; new_pos_size; i++) {
1360     new_pos[i] = i * edge_length / (new_grid-&gt;n);
1361 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  }
1362   int new_edge_index = 0;
1363   if ((shared_vert_1 + shared_vert_2) == 1) {
1364     new_edge_index = 0;
1365   } else if ((shared_vert_1 + shared_vert_2) == 2) {
1366     new_edge_index = 2;
1367   } else if ((shared_vert_1 + shared_vert_2) == 3) {</b></font>
1368     new_edge_index = 1;
1369   } else {
1370     mcell_internal_error(
1371         "Error in the function 'add_more_tile_neighbors_to_list_fast()'.");
1372   }
1373   int last_value;
1374   if (new_edge_index == 0) {
1375     new_tile_idx[0][0] = -1;
1376     new_tile_idx[0][1] = -1;
1377     new_tile_idx[0][2] = new_grid-&gt;n_tiles - 2 * (new_grid-&gt;n) + 1;
1378     last_value = new_tile_idx[0][2];
1379     for (i = 1; i &lt; new_pos_size - 1; i++) {
1380       for (k = 0; k &lt; 3; k++) {
1381         new_tile_idx[i][k] = last_value + k;
1382       }
1383       last_value = new_tile_idx[i][2];
1384     }
1385     new_tile_idx[new_pos_size - 1][0] = last_value;
1386     new_tile_idx[new_pos_size - 1][1] = -1;
1387     new_tile_idx[new_pos_size - 1][2] = -1;
1388   } else if (new_edge_index == 1) {
1389     new_tile_idx[0][0] = -1;
1390     new_tile_idx[0][1] = -1;
1391     new_tile_idx[0][2] = new_grid-&gt;n_tiles - 1;
1392     last_value = new_tile_idx[0][2];
1393     for (i = 1; i &lt; new_pos_size - 1; i++) {
1394       for (k = 0; k &lt; 2; k++) {
1395         new_tile_idx[i][k] = last_value - k;
1396       }
1397       last_value = new_tile_idx[i][1];
1398       new_tile_idx[i][2] = move_strip_down(new_grid, last_value);
1399       last_value = new_tile_idx[i][2];
1400     }
1401     new_tile_idx[new_pos_size - 1][0] = last_value;
1402     new_tile_idx[new_pos_size - 1][1] = -1;
1403     new_tile_idx[new_pos_size - 1][2] = -1;
1404   } else {     new_tile_idx[0][0] = -1;
1405     new_tile_idx[0][1] = -1;
1406     new_tile_idx[0][2] = new_grid-&gt;n_tiles - 2 * (new_grid-&gt;n) + 1;
1407     last_value = new_tile_idx[0][2];
1408     for (i = 1; i &lt; new_pos_size - 1; i++) {
1409       for (k = 0; k &lt; 2; k++) {
1410         new_tile_idx[i][k] = last_value + k;
1411       }
1412       last_value = new_tile_idx[i][1];
1413       new_tile_idx[i][2] = move_strip_down(new_grid, last_value);
1414       last_value = new_tile_idx[i][2];
1415     }
1416     new_tile_idx[new_pos_size - 1][0] = last_value;
1417     new_tile_idx[new_pos_size - 1][1] = -1;
1418     new_tile_idx[new_pos_size - 1][2] = -1;
1419   }
1420   int ind_high, ind_low = -1;
1421   if (orig_pos_1 &gt; orig_pos_2) {
1422     ind_high = bisect_high(&amp;new_pos[0], new_pos_size, orig_pos_1);
1423     if (orig_pos_2 &gt; 0) {
1424       ind_low = bisect(&amp;new_pos[0], new_pos_size, orig_pos_2);
1425     }
1426   } else {
1427     ind_high = bisect_high(&amp;new_pos[0], new_pos_size, orig_pos_2);
1428     if (orig_pos_1 &gt; 0) {
1429       ind_low = bisect(&amp;new_pos[0], new_pos_size, orig_pos_1);
1430     }
1431   }
1432   if (ind_low &gt;= 0) {
1433     for (i = ind_low + 1; i &lt; ind_high; i++) {
1434       for (k = 0; k &lt; 3; k++) {
1435         if (push_tile_neighbor_to_list_with_checking(tile_nbr_head, new_grid,
1436                                                      new_tile_idx[i][k]))
1437           tiles_added++;
1438       }
1439     }
1440   } else {
1441     if (push_tile_neighbor_to_list_with_checking(tile_nbr_head, new_grid,
1442                                                  new_tile_idx[ind_high][0]))
1443       tiles_added++;
1444   }
1445   return tiles_added;
1446 }
1447 void find_closest_position(struct surface_grid *grid1, int idx1,
1448                            struct surface_grid *grid2, int idx2,
1449                            struct vector2 *p) {
1450   struct vector2 R, S, T;
1451   struct vector3 R_3d, S_3d, T_3d;
1452   struct vector2 A, B, C;
1453   struct vector3 A_3d, B_3d, C_3d;
1454   struct vector2 A_new, B_new, C_new;
1455   double k1 = 1e-10;   double k2 = 1;
1456   int flip1;   int flip2; 
1457   int num_exact_shared_vertices = 0;
1458   int R_shared = 0, S_shared = 0, T_shared = 0;
1459   int A_shared = 0, B_shared = 0, C_shared = 0;
1460   get_tile_vertices(grid1, idx1, &amp;flip1, &amp;R, &amp;S, &amp;T);
1461   if (is_corner_tile(grid1, idx1)) {
1462     int shared_wall_vertex_id_1 = find_wall_vertex_for_corner_tile(grid1, idx1);
1463     if (idx1 == 0) {
1464       memcpy(&amp;T_3d, grid1-&gt;surface-&gt;vert[shared_wall_vertex_id_1],
1465              sizeof(struct vector3));
1466       uv2xyz(&amp;R, grid1-&gt;surface, &amp;R_3d);
1467       uv2xyz(&amp;S, grid1-&gt;surface, &amp;S_3d);
1468     } else if ((u_int)idx1 == (grid1-&gt;n_tiles - 2 * (grid1-&gt;n) + 1)) {
1469       memcpy(&amp;R_3d, grid1-&gt;surface-&gt;vert[shared_wall_vertex_id_1],
1470              sizeof(struct vector3));
1471       uv2xyz(&amp;S, grid1-&gt;surface, &amp;S_3d);
1472       uv2xyz(&amp;T, grid1-&gt;surface, &amp;T_3d);
1473     } else {
1474       memcpy(&amp;S_3d, grid1-&gt;surface-&gt;vert[shared_wall_vertex_id_1],
1475              sizeof(struct vector3));
1476       uv2xyz(&amp;R, grid1-&gt;surface, &amp;R_3d);
1477       uv2xyz(&amp;T, grid1-&gt;surface, &amp;T_3d);
1478     }
1479   } else {
1480     uv2xyz(&amp;R, grid1-&gt;surface, &amp;R_3d);
1481     uv2xyz(&amp;S, grid1-&gt;surface, &amp;S_3d);
1482     uv2xyz(&amp;T, grid1-&gt;surface, &amp;T_3d);
1483   }
1484   get_tile_vertices(grid2, idx2, &amp;flip2, &amp;A, &amp;B, &amp;C);
1485   if (is_corner_tile(grid2, idx2)) {
1486     int shared_wall_vertex_id_2 = find_wall_vertex_for_corner_tile(grid2, idx2);
1487     if (idx2 == 0) {
1488       memcpy(&amp;C_3d, grid2-&gt;surface-&gt;vert[shared_wall_vertex_id_2],
1489              sizeof(struct vector3));
1490       uv2xyz(&amp;A, grid2-&gt;surface, &amp;A_3d);
1491       uv2xyz(&amp;B, grid2-&gt;surface, &amp;B_3d);
1492     } else if ((u_int)idx2 == (grid2-&gt;n_tiles - 2 * (grid2-&gt;n) + 1)) {
1493       memcpy(&amp;A_3d, grid2-&gt;surface-&gt;vert[shared_wall_vertex_id_2],
1494              sizeof(struct vector3));
1495       uv2xyz(&amp;B, grid2-&gt;surface, &amp;B_3d);
1496       uv2xyz(&amp;C, grid2-&gt;surface, &amp;C_3d);
1497     } else {
1498       memcpy(&amp;B_3d, grid2-&gt;surface-&gt;vert[shared_wall_vertex_id_2],
1499              sizeof(struct vector3));
1500       uv2xyz(&amp;A, grid2-&gt;surface, &amp;A_3d);
1501       uv2xyz(&amp;C, grid2-&gt;surface, &amp;C_3d);
1502     }
1503   } else {
1504     uv2xyz(&amp;A, grid2-&gt;surface, &amp;A_3d);
1505     uv2xyz(&amp;B, grid2-&gt;surface, &amp;B_3d);
1506     uv2xyz(&amp;C, grid2-&gt;surface, &amp;C_3d);
1507   }
1508   if (grid1 == grid2) {
1509     if (!distinguishable_vec2(&amp;R, &amp;A, EPS_C) ||
1510         (!distinguishable_vec2(&amp;R, &amp;B, EPS_C)) ||
1511         (!distinguishable_vec2(&amp;R, &amp;C, EPS_C))) {
1512       num_exact_shared_vertices++;
1513       R_shared = 1;
1514     }
1515     if (!distinguishable_vec2(&amp;S, &amp;A, EPS_C) ||
1516         (!distinguishable_vec2(&amp;S, &amp;B, EPS_C)) ||
1517         (!distinguishable_vec2(&amp;S, &amp;C, EPS_C))) {
1518       num_exact_shared_vertices++;
1519       S_shared = 1;
1520     }
1521     if (!distinguishable_vec2(&amp;T, &amp;A, EPS_C) ||
1522         (!distinguishable_vec2(&amp;T, &amp;B, EPS_C)) ||
1523         (!distinguishable_vec2(&amp;T, &amp;C, EPS_C))) {
1524       num_exact_shared_vertices++;
1525       T_shared = 1;
1526     }
1527   } else {
1528     if (!distinguishable_vec3(&amp;R_3d, &amp;A_3d, EPS_C) ||
1529         (!distinguishable_vec3(&amp;R_3d, &amp;B_3d, EPS_C)) ||
1530         (!distinguishable_vec3(&amp;R_3d, &amp;C_3d, EPS_C))) {
1531       num_exact_shared_vertices++;
1532       R_shared = 1;
1533     }
1534     if (!distinguishable_vec3(&amp;S_3d, &amp;A_3d, EPS_C) ||
1535         (!distinguishable_vec3(&amp;S_3d, &amp;B_3d, EPS_C)) ||
1536         (!distinguishable_vec3(&amp;S_3d, &amp;C_3d, EPS_C))) {
1537       num_exact_shared_vertices++;
1538       S_shared = 1;
1539     }
1540     if (!distinguishable_vec3(&amp;T_3d, &amp;A_3d, EPS_C) ||
1541         (!distinguishable_vec3(&amp;T_3d, &amp;B_3d, EPS_C)) ||
1542         (!distinguishable_vec3(&amp;T_3d, &amp;C_3d, EPS_C))) {
1543       num_exact_shared_vertices++;
1544       T_shared = 1;
1545     }
1546   }
1547   if (num_exact_shared_vertices == 1) {
1548     if (R_shared) {
1549       place_product_shared_vertex(&amp;R, &amp;S, &amp;T, p, k1, k2);
1550       return;
1551     } else if (S_shared) {
1552       place_product_shared_vertex(&amp;S, &amp;R, &amp;T, p, k1, k2);
1553       return;
1554       place_product_shared_vertex(&amp;T, &amp;R, &amp;S, p, k1, k2);
1555       return;
1556     }
1557   }
1558   if (num_exact_shared_vertices == 2) {
1559     if (R_shared &amp;&amp; S_shared) {
1560       place_product_shared_segment(&amp;R, &amp;S, &amp;T, p, k1, k2);
1561       return;
1562     } else if (R_shared &amp;&amp; T_shared) {
1563       place_product_shared_segment(&amp;R, &amp;T, &amp;S, p, k1, k2);
1564       return;
1565       place_product_shared_segment(&amp;S, &amp;T, &amp;R, p, k1, k2);
1566       return;
1567     }
1568   }
1569   if (num_exact_shared_vertices == 0) {
1570     if ((intersect_point_segment(&amp;S_3d, &amp;A_3d, &amp;B_3d)) ||
1571         (intersect_point_segment(&amp;S_3d, &amp;B_3d, &amp;C_3d)) ||
1572         (intersect_point_segment(&amp;S_3d, &amp;A_3d, &amp;C_3d))) {
1573       S_shared = 1;
1574     }
1575     if ((intersect_point_segment(&amp;R_3d, &amp;A_3d, &amp;B_3d)) ||
1576         (intersect_point_segment(&amp;R_3d, &amp;B_3d, &amp;C_3d)) ||
1577         (intersect_point_segment(&amp;R_3d, &amp;A_3d, &amp;C_3d))) {
1578       R_shared = 1;
1579     }
1580     if ((intersect_point_segment(&amp;T_3d, &amp;A_3d, &amp;B_3d)) ||
1581         (intersect_point_segment(&amp;T_3d, &amp;B_3d, &amp;C_3d)) ||
1582         (intersect_point_segment(&amp;T_3d, &amp;A_3d, &amp;C_3d))) {
1583       T_shared = 1;
1584     }
1585     if ((intersect_point_segment(&amp;A_3d, &amp;R_3d, &amp;S_3d)) ||
1586         (intersect_point_segment(&amp;A_3d, &amp;S_3d, &amp;T_3d)) ||
1587         (intersect_point_segment(&amp;A_3d, &amp;R_3d, &amp;T_3d))) {
1588       A_shared = 1;
1589     }
1590     if ((intersect_point_segment(&amp;B_3d, &amp;R_3d, &amp;S_3d)) ||
1591         (intersect_point_segment(&amp;B_3d, &amp;S_3d, &amp;T_3d)) ||
1592         (intersect_point_segment(&amp;B_3d, &amp;R_3d, &amp;T_3d))) {
1593       B_shared = 1;
1594     }
1595     if ((intersect_point_segment(&amp;C_3d, &amp;R_3d, &amp;S_3d)) ||
1596         (intersect_point_segment(&amp;C_3d, &amp;S_3d, &amp;T_3d)) ||
1597         (intersect_point_segment(&amp;C_3d, &amp;R_3d, &amp;T_3d))) {
1598       C_shared = 1;
1599     }
1600     if (R_shared &amp;&amp; S_shared) {
1601       place_product_shared_segment(&amp;R, &amp;S, &amp;T, p, k1, k2);
1602       return;
1603     } else if (R_shared &amp;&amp; T_shared) {
1604       place_product_shared_segment(&amp;R, &amp;T, &amp;S, p, k1, k2);
1605       return;
1606     } else if (S_shared &amp;&amp; T_shared) {
1607       place_product_shared_segment(&amp;S, &amp;T, &amp;R, p, k1, k2);
1608       return;
1609     }
1610     if (A_shared &amp;&amp; B_shared) {
1611       if (parallel_segments(&amp;A_3d, &amp;B_3d, &amp;R_3d, &amp;S_3d)) {
1612         xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
1613         xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
1614         place_product_shared_segment(&amp;A_new, &amp;B_new, &amp;T, p, k1, k2);
1615         return;
1616       } else if (parallel_segments(&amp;A_3d, &amp;B_3d, &amp;R_3d, &amp;T_3d)) {
1617         xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
1618         xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
1619         place_product_shared_segment(&amp;A_new, &amp;B_new, &amp;S, p, k1, k2);
1620         return;
1621       } else if (parallel_segments(&amp;A_3d, &amp;B_3d, &amp;S_3d, &amp;T_3d)) {
1622         xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
1623         xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
1624         place_product_shared_segment(&amp;A_new, &amp;B_new, &amp;R, p, k1, k2);
1625         return;
1626       }
1627     } else if (A_shared &amp;&amp; C_shared) {
1628       if (parallel_segments(&amp;A_3d, &amp;C_3d, &amp;R_3d, &amp;S_3d)) {
1629         xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
1630         xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
1631         place_product_shared_segment(&amp;A_new, &amp;C_new, &amp;T, p, k1, k2);
1632         return;
1633       } else if (parallel_segments(&amp;A_3d, &amp;C_3d, &amp;R_3d, &amp;T_3d)) {
1634         xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
1635         xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
1636         place_product_shared_segment(&amp;A_new, &amp;C_new, &amp;S, p, k1, k2);
1637         return;
1638       } else if (parallel_segments(&amp;A_3d, &amp;C_3d, &amp;S_3d, &amp;T_3d)) {
1639         xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
1640         xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
1641         place_product_shared_segment(&amp;A_new, &amp;C_new, &amp;R, p, k1, k2);
1642         return;
1643       }
1644     } else if (B_shared &amp;&amp; C_shared) {
1645       if (parallel_segments(&amp;B_3d, &amp;C_3d, &amp;R_3d, &amp;S_3d)) {
1646         xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
1647         xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
1648         place_product_shared_segment(&amp;B_new, &amp;C_new, &amp;T, p, k1, k2);
1649         return;
1650       } else if (parallel_segments(&amp;B_3d, &amp;C_3d, &amp;R_3d, &amp;T_3d)) {
1651         xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
1652         xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
1653         place_product_shared_segment(&amp;B_new, &amp;C_new, &amp;S, p, k1, k2);
1654         return;
1655       } else if (parallel_segments(&amp;B_3d, &amp;C_3d, &amp;S_3d, &amp;T_3d)) {
1656         xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
1657         xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
1658         place_product_shared_segment(&amp;B_new, &amp;C_new, &amp;R, p, k1, k2);
1659         return;
1660       }
1661     }
1662     if (R_shared) {
1663       if (A_shared) {
1664         if (parallel_segments(&amp;R_3d, &amp;A_3d, &amp;R_3d, &amp;S_3d)) {
1665           xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
1666           place_product_shared_segment(&amp;A_new, &amp;R, &amp;T, p, k1, k2);
1667           return;
1668         } else if (parallel_segments(&amp;R_3d, &amp;A_3d, &amp;R_3d, &amp;T_3d)) {
1669           xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
1670           place_product_shared_segment(&amp;A_new, &amp;R, &amp;S, p, k1, k2);
1671           return;
1672         }
1673       } else if (B_shared) {
1674         if (parallel_segments(&amp;R_3d, &amp;B_3d, &amp;R_3d, &amp;S_3d)) {
1675           xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
1676           place_product_shared_segment(&amp;B_new, &amp;R, &amp;T, p, k1, k2);
1677           return;
1678         } else if (parallel_segments(&amp;R_3d, &amp;B_3d, &amp;R_3d, &amp;T_3d)) {
1679           xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
1680           place_product_shared_segment(&amp;B_new, &amp;R, &amp;S, p, k1, k2);
1681           return;
1682         }
1683       } else if (C_shared) {
1684         if (parallel_segments(&amp;R_3d, &amp;C_3d, &amp;R_3d, &amp;S_3d)) {
1685           xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
1686           place_product_shared_segment(&amp;C_new, &amp;R, &amp;T, p, k1, k2);
1687           return;
1688         } else if (parallel_segments(&amp;R_3d, &amp;C_3d, &amp;R_3d, &amp;T_3d)) {
1689           xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
1690           place_product_shared_segment(&amp;C_new, &amp;R, &amp;S, p, k1, k2);
1691           return;
1692         }
1693       } else {
1694         place_product_shared_vertex(&amp;R, &amp;S, &amp;T, p, k1, k2);
1695         return;
1696       }
1697     } else if (S_shared) {
1698       if (A_shared) {
1699         if (parallel_segments(&amp;S_3d, &amp;A_3d, &amp;S_3d, &amp;T_3d)) {
1700           xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
1701           place_product_shared_segment(&amp;A_new, &amp;S, &amp;R, p, k1, k2);
1702           return;
1703         } else if (parallel_segments(&amp;S_3d, &amp;A_3d, &amp;S_3d, &amp;R_3d)) {
1704           xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
1705           place_product_shared_segment(&amp;A_new, &amp;S, &amp;T, p, k1, k2);
1706           return;
1707         }
1708       } else if (B_shared) {
1709         if (parallel_segments(&amp;S_3d, &amp;B_3d, &amp;S_3d, &amp;T_3d)) {
1710           xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
1711           place_product_shared_segment(&amp;B_new, &amp;S, &amp;R, p, k1, k2);
1712           return;
1713         } else if (parallel_segments(&amp;S_3d, &amp;B_3d, &amp;S_3d, &amp;R_3d)) {
1714           xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
1715           place_product_shared_segment(&amp;B_new, &amp;S, &amp;T, p, k1, k2);
1716           return;
1717         }
1718       } else if (C_shared) {
1719         if (parallel_segments(&amp;S_3d, &amp;C_3d, &amp;S_3d, &amp;T_3d)) {
1720           xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
1721           place_product_shared_segment(&amp;C_new, &amp;S, &amp;R, p, k1, k2);
1722           return;
1723         } else if (parallel_segments(&amp;S_3d, &amp;C_3d, &amp;S_3d, &amp;R_3d)) {
1724           xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
1725           place_product_shared_segment(&amp;C_new, &amp;S, &amp;T, p, k1, k2);
1726           return;
1727         }
1728       } else {
1729         place_product_shared_vertex(&amp;S, &amp;R, &amp;T, p, k1, k2);
1730         return;
1731       }
1732     } else if (T_shared) {
1733       if (A_shared) {
1734         if (parallel_segments(&amp;T_3d, &amp;A_3d, &amp;T_3d, &amp;S_3d)) {
1735           xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
1736           place_product_shared_segment(&amp;A_new, &amp;T, &amp;R, p, k1, k2);
1737           return;
1738         } else if (parallel_segments(&amp;T_3d, &amp;A_3d, &amp;T_3d, &amp;R_3d)) {
1739           xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
1740           place_product_shared_segment(&amp;A_new, &amp;T, &amp;S, p, k1, k2);
1741           return;
1742         }
1743       } else if (B_shared) {
1744         if (parallel_segments(&amp;T_3d, &amp;B_3d, &amp;T_3d, &amp;S_3d)) {
1745           xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
1746           place_product_shared_segment(&amp;B_new, &amp;T, &amp;R, p, k1, k2);
1747           return;
1748         } else if (parallel_segments(&amp;T_3d, &amp;B_3d, &amp;T_3d, &amp;R_3d)) {
1749           xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
1750           place_product_shared_segment(&amp;B_new, &amp;T, &amp;S, p, k1, k2);
1751           return;
1752         }
1753       } else if (C_shared) {
1754         if (parallel_segments(&amp;T_3d, &amp;C_3d, &amp;T_3d, &amp;S_3d)) {
1755           xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
1756           place_product_shared_segment(&amp;C_new, &amp;T, &amp;R, p, k1, k2);
1757           return;
1758         } else if (parallel_segments(&amp;T_3d, &amp;C_3d, &amp;T_3d, &amp;R_3d)) {
1759           xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
1760           place_product_shared_segment(&amp;C_new, &amp;T, &amp;S, p, k1, k2);
1761           return;
1762         }
1763       } else {
1764         place_product_shared_vertex(&amp;T, &amp;R, &amp;S, p, k1, k2);
1765         return;
1766       }
1767     }
1768     if (A_shared) {
1769       xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
1770       if (intersect_point_segment(&amp;A_3d, &amp;R_3d, &amp;S_3d)) {
1771         place_product_close_to_segment_endpoint(&amp;T, &amp;A_new, p, k1, k2);
1772         return;
1773       } else if (intersect_point_segment(&amp;A_3d, &amp;R_3d, &amp;T_3d)) {
1774         place_product_close_to_segment_endpoint(&amp;S, &amp;A_new, p, k1, k2);
1775         return;
1776       } else if (intersect_point_segment(&amp;A_3d, &amp;S_3d, &amp;T_3d)) {
1777         place_product_close_to_segment_endpoint(&amp;R, &amp;A_new, p, k1, k2);
1778         return;
1779       }
1780     } else if (B_shared) {
1781       xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
1782       if (intersect_point_segment(&amp;B_3d, &amp;R_3d, &amp;S_3d)) {
1783         place_product_close_to_segment_endpoint(&amp;T, &amp;B_new, p, k1, k2);
1784         return;
1785       } else if (intersect_point_segment(&amp;B_3d, &amp;R_3d, &amp;T_3d)) {
1786         place_product_close_to_segment_endpoint(&amp;S, &amp;B_new, p, k1, k2);
1787         return;
1788       } else if (intersect_point_segment(&amp;B_3d, &amp;S_3d, &amp;T_3d)) {
1789         place_product_close_to_segment_endpoint(&amp;R, &amp;B_new, p, k1, k2);
1790         return;
1791       }
1792     } else if (C_shared) {
1793       xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
1794       if (intersect_point_segment(&amp;C_3d, &amp;R_3d, &amp;S_3d)) {
1795         place_product_close_to_segment_endpoint(&amp;T, &amp;C_new, p, k1, k2);
1796         return;
1797       } else if (intersect_point_segment(&amp;C_3d, &amp;R_3d, &amp;T_3d)) {
1798         place_product_close_to_segment_endpoint(&amp;S, &amp;C_new, p, k1, k2);
1799         return;
1800       } else if (intersect_point_segment(&amp;C_3d, &amp;S_3d, &amp;T_3d)) {
1801         place_product_close_to_segment_endpoint(&amp;R, &amp;C_new, p, k1, k2);
1802         return;
1803       }
1804     }
1805   } 
1806   struct vector3 A_close_3d, B_close_3d, C_close_3d;
1807   double dist_A_A_close_3d, dist_B_B_close_3d, dist_C_C_close_3d, min_dist;
1808   struct vector3 prod_pos_3d;
1809   struct vector2 prod_pos;
1810   closest_pt_point_triangle(&amp;A_3d, &amp;R_3d, &amp;S_3d, &amp;T_3d, &amp;A_close_3d);
1811   closest_pt_point_triangle(&amp;B_3d, &amp;R_3d, &amp;S_3d, &amp;T_3d, &amp;B_close_3d);
1812   closest_pt_point_triangle(&amp;C_3d, &amp;R_3d, &amp;S_3d, &amp;T_3d, &amp;C_close_3d);
1813   dist_A_A_close_3d = distance_vec3(&amp;A_3d, &amp;A_close_3d);
1814   dist_B_B_close_3d = distance_vec3(&amp;B_3d, &amp;B_close_3d);
1815   dist_C_C_close_3d = distance_vec3(&amp;C_3d, &amp;C_close_3d);
1816   min_dist = min3d(dist_A_A_close_3d, dist_B_B_close_3d, dist_C_C_close_3d);
1817   if (!distinguishable(min_dist, dist_A_A_close_3d, EPS_C)) {
1818     prod_pos_3d.x = A_close_3d.x;
1819     prod_pos_3d.y = A_close_3d.y;
1820     prod_pos_3d.z = A_close_3d.z;
1821   } else if (!distinguishable(min_dist, dist_B_B_close_3d, EPS_C)) {
1822     prod_pos_3d.x = B_close_3d.x;
1823     prod_pos_3d.y = B_close_3d.y;
1824     prod_pos_3d.z = B_close_3d.z;
1825   } else {
1826     prod_pos_3d.x = C_close_3d.x;
1827     prod_pos_3d.y = C_close_3d.y;
1828     prod_pos_3d.z = C_close_3d.z;
1829   }
1830   xyz2uv(&amp;prod_pos_3d, grid1-&gt;surface, &amp;prod_pos);
1831   if (intersect_point_segment(&amp;prod_pos_3d, &amp;R_3d, &amp;S_3d)) {
1832     place_product_close_to_segment_endpoint(&amp;T, &amp;prod_pos, p, k1, k2);
1833     return;
1834   } else if (intersect_point_segment(&amp;prod_pos_3d, &amp;R_3d, &amp;T_3d)) {
1835     place_product_close_to_segment_endpoint(&amp;S, &amp;prod_pos, p, k1, k2);
1836     return;
1837   } else if (intersect_point_segment(&amp;prod_pos_3d, &amp;S_3d, &amp;T_3d)) {
1838     place_product_close_to_segment_endpoint(&amp;R, &amp;prod_pos, p, k1, k2);
1839     return;
1840   } else {
1841     p-&gt;u = prod_pos.u;
1842     p-&gt;v = prod_pos.v;
1843     return;
1844   }
1845   mcell_internal_error("Error in the function 'find_closest_position()'.");
1846 }
1847 int is_inner_tile(struct surface_grid *g, int idx) {
1848   int root, rootrem, strip, stripe, flip;
1849   root = (int)(sqrt((double)idx));
1850   rootrem = idx - root * root;
1851   strip = g-&gt;n - root - 1;
1852   stripe = rootrem / 2;
1853   flip = rootrem - 2 * stripe;
1854   if ((strip == 0) || (stripe == 0))
1855     return 0;
1856   if ((strip + stripe) == g-&gt;n - 1) {
1857     return 0;
1858   }
1859   if (((strip + stripe) == g-&gt;n - 2) &amp;&amp; (flip == 1)) {
1860     return 0;
1861   }
1862   return 1;
1863 }
1864 int is_corner_tile(struct surface_grid *g, int idx) {
1865   int tile_idx_mid = g-&gt;n_tiles - 2 * (g-&gt;n) + 1;
1866   if ((idx == 0) || ((u_int)idx == (g-&gt;n_tiles - 1)))
1867     return 1;
1868   if (idx == tile_idx_mid)
1869     return 1;
1870   return 0;
1871 }
1872 void find_shared_vertices_corner_tile_parent_wall(struct volume *world,
1873                                                   struct surface_grid *sg,
1874                                                   int idx,
1875                                                   long long int *shared_vert) {
1876   long long global_vert_index;
1877   struct vector3 *v;
1878   if (!world-&gt;create_shared_walls_info_flag)
1879     mcell_internal_error("Function "
1880                          "'find_shared_vertices_corner_tile_parent_wall()' is "
1881                          "called but shared walls information is not created.");
1882   if ((u_int)idx == (sg-&gt;n_tiles - 2 * (sg-&gt;n) + 1)) {
1883     v = sg-&gt;surface-&gt;vert[0];
1884     global_vert_index = (long long)(v - world-&gt;all_vertices);
1885     if (world-&gt;walls_using_vertex[global_vert_index] != NULL) {
1886       shared_vert[0] = global_vert_index;
1887     }
1888   }
1889   if ((u_int)idx == (sg-&gt;n_tiles - 1)) {
1890     v = sg-&gt;surface-&gt;vert[1];
1891     global_vert_index = (long long)(v - world-&gt;all_vertices);
1892     if (world-&gt;walls_using_vertex[global_vert_index] != NULL) {
1893       shared_vert[1] = global_vert_index;
1894     }
1895   }
1896   if ((u_int)idx == 0) {
1897     v = sg-&gt;surface-&gt;vert[2];
1898     global_vert_index = (long long)(v - world-&gt;all_vertices);
1899     if (world-&gt;walls_using_vertex[global_vert_index] != NULL) {
1900       shared_vert[2] = global_vert_index;
1901     }
1902   }
1903 }
1904 int move_strip_up(struct surface_grid *grid, int idx) {
1905   int root;
1906   int tile_up_idx; 
1907   root = (int)(sqrt((double)idx)) + 1;
1908   if (grid-&gt;n == root) {
1909     tile_up_idx = -1;
1910   } else {
1911     tile_up_idx = idx + 2 * root;
1912   }
1913   return tile_up_idx;
1914 }
1915 int move_strip_down(struct surface_grid *grid, int idx) {
1916   int root, rootrem, strip, stripe, flip;
1917   int num_tiles_per_strip;
1918   int tile_down_idx; 
1919   root = (int)(sqrt((double)idx));
1920   rootrem = idx - root * root;
1921   strip = grid-&gt;n - root - 1;
1922   stripe = rootrem / 2;
1923   flip = rootrem - 2 * stripe;
1924   num_tiles_per_strip = 2 * (grid-&gt;n) - 2 * strip - 1;
1925   if (is_inner_tile(grid, idx)) {
1926     tile_down_idx = idx - num_tiles_per_strip + 1;
1927   } else {
1928     if ((strip == 0) &amp;&amp; (stripe &gt; 0)) {
1929       if ((unsigned int)idx == grid-&gt;n_tiles - 1) {
1930         tile_down_idx = -1;
1931       } else {
1932         tile_down_idx = idx - num_tiles_per_strip + 1;
1933       }
1934     } else {
1935       if (flip == 0) {
1936         tile_down_idx = -1;
1937       } else {
1938         tile_down_idx = idx - num_tiles_per_strip + 1;
1939       }
1940     }
1941   }
1942   return tile_down_idx;
1943 }
1944 void place_product_shared_segment(struct vector2 *R_shared,
1945                                   struct vector2 *S_shared, struct vector2 *T,
1946                                   struct vector2 *prod, double k1, double k2) {
1947   struct vector2 M; 
1948   M.u = 0.5 * (R_shared-&gt;u + S_shared-&gt;u);
1949   M.v = 0.5 * (R_shared-&gt;v + S_shared-&gt;v);
1950   prod-&gt;u = (k1 * T-&gt;u + k2 * M.u) / (k1 + k2);
1951   prod-&gt;v = (k1 * T-&gt;v + k2 * M.v) / (k1 + k2);
1952 }
1953 void place_product_shared_vertex(struct vector2 *R_shared, struct vector2 *S,
1954                                  struct vector2 *T, struct vector2 *prod,
1955                                  double k1, double k2) {
1956   struct vector2 M; 
1957   M.u = 0.5 * (S-&gt;u + T-&gt;u);
1958   M.v = 0.5 * (S-&gt;v + T-&gt;v);
1959   prod-&gt;u = (k1 * M.u + k2 * R_shared-&gt;u) / (k1 + k2);
1960   prod-&gt;v = (k1 * M.v + k2 * R_shared-&gt;v) / (k1 + k2);
1961 }
1962 void place_product_close_to_segment_endpoint(struct vector2 *S,
1963                                              struct vector2 *E,
1964                                              struct vector2 *prod, double k1,
1965                                              double k2) {
1966   prod-&gt;u = (k1 * S-&gt;u + k2 * E-&gt;u) / (k1 + k2);
1967   prod-&gt;v = (k1 * S-&gt;v + k2 * E-&gt;v) / (k1 + k2);
1968 }
1969 void append_tile_neighbor_list(struct tile_neighbor **head1,
1970                                struct tile_neighbor **head2) {
1971   struct tile_neighbor *curr;
1972   if (*head1 == NULL)   {
1973     *head1 = *head2;
1974   } else {
1975     curr = *head1;
1976     while (curr-&gt;next != NULL)     {
1977       curr = curr-&gt;next;
1978     }
1979     curr-&gt;next = *head2;
1980   }
1981   *head2 = NULL;
1982 }
1983 int find_wall_vertex_for_corner_tile(struct surface_grid *grid, int idx) {
1984   int vertex_id = 0;
1985   if (!is_corner_tile(grid, idx))
1986     mcell_internal_error("Function 'find_wall_vertex_for_corner_tile()' is "
1987                          "called for the tile that is not the corner tile.");
1988   if ((u_int)idx == (grid-&gt;n_tiles - 2 * (grid-&gt;n) + 1)) {
1989     vertex_id = 0;
1990   } else if ((u_int)idx == (grid-&gt;n_tiles - 1)) {
1991     vertex_id = 1;
1992   } else if (idx == 0) {
1993     vertex_id = 2;
1994   } else {
1995     mcell_internal_error("Function 'find_wall_vertex_for_corner_tile()' is "
1996                          "called for the tile that is not the corner tile.");
1997   }
1998   return vertex_id;
1999 }
2000 void find_shared_vertices_for_neighbor_walls(struct wall *orig_wall,
2001                                              struct wall *nb_wall,
2002                                              int *shared_vert_1,
2003                                              int *shared_vert_2) {
2004   if ((!distinguishable_vec3(nb_wall-&gt;vert[0], orig_wall-&gt;vert[0], EPS_C)) ||
2005       (!distinguishable_vec3(nb_wall-&gt;vert[0], orig_wall-&gt;vert[1], EPS_C)) ||
2006       (!distinguishable_vec3(nb_wall-&gt;vert[0], orig_wall-&gt;vert[2], EPS_C))) {
2007     *shared_vert_1 = 0;
2008   }
2009   if ((!distinguishable_vec3(nb_wall-&gt;vert[1], orig_wall-&gt;vert[0], EPS_C)) ||
2010       (!distinguishable_vec3(nb_wall-&gt;vert[1], orig_wall-&gt;vert[1], EPS_C)) ||
2011       (!distinguishable_vec3(nb_wall-&gt;vert[1], orig_wall-&gt;vert[2], EPS_C))) {
2012     if (*shared_vert_1 &lt; 0) {
2013       *shared_vert_1 = 1;
2014     } else {
2015       *shared_vert_2 = 1;
2016     }
2017   }
2018   if ((!distinguishable_vec3(nb_wall-&gt;vert[2], orig_wall-&gt;vert[0], EPS_C)) ||
2019       (!distinguishable_vec3(nb_wall-&gt;vert[2], orig_wall-&gt;vert[1], EPS_C)) ||
2020       (!distinguishable_vec3(nb_wall-&gt;vert[2], orig_wall-&gt;vert[2], EPS_C))) {
2021     if (*shared_vert_1 &lt; 0) {
2022       *shared_vert_1 = 2;
2023     } else {
2024       *shared_vert_2 = 2;
2025     }
2026   }
2027 }
2028 void find_neighbor_tiles(struct volume *world, struct surface_molecule *sm,
2029                          struct surface_grid *grid, int idx,
2030                          int create_grid_flag, int search_for_reactant,
2031                          struct tile_neighbor **tile_nbr_head,
2032                          int *list_length) {
2033   int kk;
2034   struct tile_neighbor *tile_nbr_head_vert = NULL, *tmp_head = NULL;
2035   int list_length_vert = 0;   int tmp_list_length = 0;    struct vector2 pos;       
2036   struct wall_list *wall_nbr_head = NULL; 
2037   for (kk = 0; kk &lt; 3; kk++) {
2038     shared_vert[kk] = -1;
2039   }
2040   if (is_inner_tile(grid, idx)) {
2041     grid2uv(grid, idx, &amp;pos);
2042     grid_all_neighbors_for_inner_tile(world, grid, idx, &amp;pos, &amp;tmp_head,
2043                                       &amp;tmp_list_length);
2044   } else {
2045     if (is_corner_tile(grid, idx)) {
2046       find_shared_vertices_corner_tile_parent_wall(world, grid, idx,
2047                                                    shared_vert);
2048       wall_nbr_head =
2049           find_nbr_walls_shared_one_vertex(world, grid-&gt;surface, shared_vert);
2050       if (wall_nbr_head != NULL) {
2051         grid_all_neighbors_across_walls_through_vertices(
2052             world, sm, wall_nbr_head, grid, create_grid_flag,
2053             search_for_reactant, &amp;tile_nbr_head_vert, &amp;list_length_vert);
2054       }
2055       if (wall_nbr_head != NULL) {
2056         delete_wall_list(wall_nbr_head);
2057         wall_nbr_head = NULL;
2058       }
2059       grid_all_neighbors_across_walls_through_edges(
2060           world, sm, grid, idx, create_grid_flag, search_for_reactant,
2061           &amp;tmp_head, &amp;tmp_list_length);
2062     } else {
2063       grid_all_neighbors_across_walls_through_edges(
2064           world, sm, grid, idx, create_grid_flag, search_for_reactant,
2065           &amp;tmp_head, &amp;tmp_list_length);
2066     }
2067   }
2068   if (tile_nbr_head_vert != NULL) {
2069     append_tile_neighbor_list(&amp;tmp_head, &amp;tile_nbr_head_vert);
2070     tmp_list_length += list_length_vert;
2071   }
2072   *tile_nbr_head = tmp_head;
2073   *list_length = tmp_list_length;
2074 #ifdef DEBUG_GRIDS
2075   dump_tile_neighbors_list(*tile_nbr_head, __FUNCTION__, "  ");
2076 #endif
2077 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
