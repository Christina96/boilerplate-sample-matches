<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for react_outc.c &amp; grid_util.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for react_outc.c &amp; grid_util.c
      </h3>
<h1 align="center">
        1.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>react_outc.c (1.9607843%)<th>grid_util.c (1.3196481%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1690-1705)<td><a href="#" name="0">(1921-1927)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1634-1637)<td><a href="#" name="1">(1375-1378)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(516-524)<td><a href="#" name="2">(2019-2030)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>react_outc.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;vector&gt;
#include "logging.h"
#include "rng.h"
#include "util.h"
#include "grid_util.h"
#include "count_util.h"
#include "react.h"
#include "vol_util.h"
#include "wall_util.h"
#include "nfsim_func.h"
#include "mcell_reactions.h"
#include "diffuse.h"
#include "debug_config.h"
#include "debug.h"
#include "dump_state.h"
static int outcome_products_random(struct volume *world, struct wall *w,
                                   struct vector3 *hitpt, double t,
                                   struct rxn *rx, int path,
                                   struct abstract_molecule *reacA,
                                   struct abstract_molecule *reacB,
                                   short orientA, short orientB);
static int cleanup_and_block_rx(struct tile_neighbor *tn1, struct tile_neighbor *tn2);
int is_compatible_surface(void *req_species, struct wall *w) {
  struct surf_class_list *scl, *scl2;
  struct surf_class_list *rs_head = (struct surf_class_list *)req_species;
  if (rs_head == NULL)
    return 1;
  for (scl = w-&gt;surf_class_head; scl != NULL; scl = scl-&gt;next) {
    for (scl2 = rs_head; scl2 != NULL; scl2 = scl2-&gt;next) {
      if (scl-&gt;surf_class == scl2-&gt;surf_class)
        return 1;
    }
  }
  return 0;
}
void add_reactants_to_product_list(struct rxn *rx, struct abstract_molecule *reacA,
  struct abstract_molecule *reacB, struct abstract_molecule *reacC,
  struct abstract_molecule **player, char *player_type) {
  player[0] = reacA;
  player_type[0] = IS_SURF_MOL(reacA) ? PLAYER_SURF_MOL : PLAYER_VOL_MOL;
  if (rx-&gt;n_reactants &gt; 1) {
    if (reacB == NULL) {
      assert(rx-&gt;n_reactants == 2);
      player[1] = NULL;
      player_type[1] = PLAYER_WALL;
    } else {        player[1] = reacB;
      player_type[1] = IS_SURF_MOL(reacB) ? PLAYER_SURF_MOL : PLAYER_VOL_MOL;
    }
    if (rx-&gt;n_reactants &gt; 2) {
      if (reacC == NULL) {
        player[2] = NULL;
        player_type[2] = PLAYER_WALL;
      } else {
        player[2] = reacC;
        player_type[2] = IS_SURF_MOL(reacC) ? PLAYER_SURF_MOL : PLAYER_VOL_MOL;
      }
    }
  }
}
static bool is_rxn_unimol(struct rxn *rx) {
  if (rx-&gt;n_reactants == 1)
    return true;
  if (rx-&gt;n_reactants != 2)
    return false;
  if (!(rx-&gt;players[0]-&gt;flags &amp; ON_GRID))
    return false;
  return (rx-&gt;players[1]-&gt;flags &amp; IS_SURFACE) != 0;
}
void tiny_diffuse_3D(
    struct volume *world,
    struct subvolume *subvol,
    struct vector3 *displacement,
    struct vector3 *pos,
    struct wall *w) {
  struct vector3 temp_displacement = {
    displacement-&gt;x,
    displacement-&gt;y,
    displacement-&gt;z
  };
  struct collision *shead = ray_trace(
      world, pos, NULL, subvol, &amp;temp_displacement, w);
  if (shead-&gt;next != NULL) {
    shead = (struct collision *)ae_list_sort((struct abstract_element *)shead);
  }
  struct collision *smash = NULL;
  for (smash = shead; smash != NULL; smash = smash-&gt;next) {
    if ((smash-&gt;what &amp; COLLIDE_WALL) != 0) {
      vectorize(pos, &amp;(smash-&gt;loc), displacement);
      scalar_prod(displacement, 0.5, displacement);
      break;
    }
  }
  pos-&gt;x += displacement-&gt;x;
  pos-&gt;y += displacement-&gt;y;
  pos-&gt;z += displacement-&gt;z;
  subvol = find_subvolume(world, pos, subvol);
}
struct volume_molecule *
place_volume_product(struct volume *world, struct species *product_species, struct graph_data* graph,
                     struct surface_molecule *sm_reactant, struct wall *w,
                     struct subvolume *subvol, struct vector3 *hitpt,
                     short orient, double t, struct periodic_image *periodic_box) {
  struct vector3 pos = *hitpt;
  if (w) {
    double bump = (orient &gt; 0) ? EPS_C : -EPS_C;
    struct vector3 displacement = {2 * bump * w-&gt;normal.x,
                                   2 * bump * w-&gt;normal.y,
                                   2 * bump * w-&gt;normal.z,
                                  };
    tiny_diffuse_3D(world, subvol, &amp;displacement, &amp;pos, w);
  }
  struct volume_molecule *new_volume_mol;
  new_volume_mol =
      (struct volume_molecule *)CHECKED_MEM_GET(subvol-&gt;local_storage-&gt;mol, "volume molecule");
  new_volume_mol-&gt;birthplace = subvol-&gt;local_storage-&gt;mol;
  new_volume_mol-&gt;birthday = convert_iterations_to_seconds(
      world-&gt;start_iterations, world-&gt;time_unit,
      world-&gt;simulation_start_seconds, t);
  new_volume_mol-&gt;id = world-&gt;current_mol_id++;
  new_volume_mol-&gt;t = t;
  new_volume_mol-&gt;t2 = 0.0;
  new_volume_mol-&gt;periodic_box = CHECKED_MALLOC_STRUCT(struct periodic_image,
    "periodic image descriptor");
  new_volume_mol-&gt;periodic_box-&gt;x = periodic_box-&gt;x;
  new_volume_mol-&gt;periodic_box-&gt;y = periodic_box-&gt;y;
  new_volume_mol-&gt;periodic_box-&gt;z = periodic_box-&gt;z;
  new_volume_mol-&gt;properties = product_species;
  new_volume_mol-&gt;graph_data = graph;
  initialize_diffusion_function((struct abstract_molecule*) new_volume_mol);
  new_volume_mol-&gt;prev_v = NULL;
  new_volume_mol-&gt;next_v = NULL;
  new_volume_mol-&gt;pos = pos;
  new_volume_mol-&gt;subvol = subvol;
  new_volume_mol-&gt;index = 0;
  new_volume_mol-&gt;flags = TYPE_VOL | ACT_NEWBIE | IN_VOLUME | IN_SCHEDULE;
  if (new_volume_mol-&gt;get_space_step(new_volume_mol) &gt; 0.0)
    new_volume_mol-&gt;flags |= ACT_DIFFUSE;
  if ((product_species-&gt;flags &amp; COUNT_SOME_MASK) != 0)
    new_volume_mol-&gt;flags |= COUNT_ME;
  if (trigger_unimolecular(world-&gt;reaction_hash, world-&gt;rx_hashsize,
                           product_species-&gt;hashval,
                           (struct abstract_molecule *)new_volume_mol) != NULL)
    new_volume_mol-&gt;flags |= ACT_REACT;
  if (sm_reactant &amp;&amp; distinguishable(new_volume_mol-&gt;get_diffusion(new_volume_mol), 0, EPS_C)) {
    new_volume_mol-&gt;previous_wall = sm_reactant-&gt;grid-&gt;surface;
    new_volume_mol-&gt;index = sm_reactant-&gt;grid_index;
  }
  else {
    new_volume_mol-&gt;previous_wall = NULL;
    new_volume_mol-&gt;index = -1;
  }
  if (w) {
    if (world-&gt;surface_reversibility) {
      new_volume_mol-&gt;previous_wall = w;
      new_volume_mol-&gt;index = (orient &gt; 0) ? 1 : -1;
      new_volume_mol-&gt;flags |= ACT_CLAMPED;
    }
  } else if (world-&gt;volume_reversibility) {
    new_volume_mol-&gt;index = world-&gt;dissociation_index;
    new_volume_mol-&gt;flags |= ACT_CLAMPED;
  }
  ht_add_molecule_to_list(&amp;new_volume_mol-&gt;subvol-&gt;mol_by_species,
                          new_volume_mol);
  ++new_volume_mol-&gt;subvol-&gt;mol_count;
  if (schedule_add_mol(subvol-&gt;local_storage-&gt;timer, new_volume_mol))
    mcell_allocfailed("Failed to add newly created %s molecule to scheduler.",
                      product_species-&gt;sym-&gt;name);
  return new_volume_mol;
}
struct surface_molecule *
place_sm_product(struct volume *world, struct species *product_species, struct graph_data* graph,
                 struct surface_grid *grid, int grid_index,
                 struct vector2 *mol_uv_pos, short orient, double t,
                 struct periodic_image *periodic_box) {
  struct vector3 mol_xyz_pos;
  uv2xyz(mol_uv_pos, grid-&gt;surface, &amp;mol_xyz_pos);
  struct subvolume *sv = find_subvolume(world, &amp;mol_xyz_pos, grid-&gt;subvol);
  struct surface_molecule *new_surf_mol;
  new_surf_mol = (struct surface_molecule *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;smol, "surface molecule");
  new_surf_mol-&gt;birthplace = sv-&gt;local_storage-&gt;smol;
  new_surf_mol-&gt;birthday = convert_iterations_to_seconds(
      world-&gt;start_iterations, world-&gt;time_unit,
      world-&gt;simulation_start_seconds, t);
  new_surf_mol-&gt;id = world-&gt;current_mol_id++;
  new_surf_mol-&gt;t = t;
  new_surf_mol-&gt;t2 = 0.0;
  new_surf_mol-&gt;properties = product_species;
  new_surf_mol-&gt;graph_data = graph;
  initialize_diffusion_function((struct abstract_molecule*) new_surf_mol);
  new_surf_mol-&gt;periodic_box = CHECKED_MALLOC_STRUCT(struct periodic_image,
    "periodic image descriptor");
  new_surf_mol-&gt;periodic_box-&gt;x = periodic_box-&gt;x;
  new_surf_mol-&gt;periodic_box-&gt;y = periodic_box-&gt;y;
  new_surf_mol-&gt;periodic_box-&gt;z = periodic_box-&gt;z;
  new_surf_mol-&gt;flags = TYPE_SURF | ACT_NEWBIE | IN_SCHEDULE;
  if (new_surf_mol-&gt;get_space_step(new_surf_mol) &gt; 0)
    new_surf_mol-&gt;flags |= ACT_DIFFUSE;
  if (product_species-&gt;flags &amp; COUNT_ENCLOSED)
    new_surf_mol-&gt;flags |= COUNT_ME;
  new_surf_mol-&gt;grid = grid;
  new_surf_mol-&gt;grid_index = grid_index;
  new_surf_mol-&gt;s_pos = *mol_uv_pos;
  new_surf_mol-&gt;orient = orient;
  if (trigger_unimolecular(world-&gt;reaction_hash, world-&gt;rx_hashsize,
                           product_species-&gt;hashval,
                           (struct abstract_molecule *)new_surf_mol) != NULL ||
      (product_species-&gt;flags &amp; CAN_SURFWALL) != 0)
    new_surf_mol-&gt;flags |= ACT_REACT;
  ++grid-&gt;n_occupied;
  if (grid-&gt;sm_list[grid_index]) {
    remove_surfmol_from_list(
        &amp;grid-&gt;sm_list[grid_index], grid-&gt;sm_list[grid_index]-&gt;sm);
  }
  grid-&gt;sm_list[grid_index] = add_surfmol_with_unique_pb_to_list(
    grid-&gt;sm_list[grid_index], new_surf_mol);
  if (schedule_add_mol(sv-&gt;local_storage-&gt;timer, new_surf_mol))
    mcell_allocfailed("Failed to add newly created %s molecule to scheduler.",
                      product_species-&gt;sym-&gt;name);
  return new_surf_mol;
}
static int outcome_products_random(struct volume *world, struct wall *w,
                                   struct vector3 *hitpt, double t,
                                   struct rxn *rx, int path,
                                   struct abstract_molecule *reacA,
                                   struct abstract_molecule *reacB,
                                   short orientA, short orientB) {
#ifdef DEBUG_RXNS
  DUMP_CONDITION3(
    dump_processing_reaction(world-&gt;current_iterations, hitpt, t, rx, reacA, reacB, w);
    dump_molecule_species(reacA);
    if (reacB != nullptr) {
      mcell_log(" + ");
      dump_molecule_species(reacB);
    }
    mcell_log("\nreaction_index: %d\n", path);
    dump_rxn(rx, "", true);
  );
#endif
  bool cross_wall = false; 
  int const i0 = rx-&gt;product_idx[path]; 
  int const iN = rx-&gt;product_idx[path + 1]; 
  assert(iN &gt; i0);
  struct species **rx_players = rx-&gt;players + i0; 
  int const n_players = iN - i0;                  std::vector&lt;struct abstract_molecule *&gt; product(n_players);   std::vector&lt;char&gt; product_type(n_players);
  std::vector&lt;short&gt; product_orient(n_players);   std::vector&lt;struct surface_grid *&gt; product_grid(n_players);
  std::vector&lt;int&gt; product_grid_idx(n_players);   std::vector&lt;byte&gt; product_flag(n_players);    
  bool const is_unimol = is_rxn_unimol(rx);
  struct surface_grid *tile_grid;   int num_vacant_tiles = 0;       
  unsigned int reac_idx = UINT_MAX;
  struct surface_grid *reac_grid = NULL, *mol_grid = NULL;
  for (int i = 0; i &lt; n_players; ++i) {
    product[i] = NULL;
    product_type[i] = PLAYER_NONE;
    product_orient[i] = 0;
    product_grid[i] = NULL;
    product_grid_idx[i] = -1;
    product_flag[i] = PRODUCT_FLAG_NOT_SET;
  }
  struct surface_molecule *const sm_1 =
      IS_SURF_MOL(reacA) ? (struct surface_molecule *)reacA : NULL;
  struct surface_molecule *const sm_2 =
      IS_SURF_MOL(reacB) ? (struct surface_molecule *)reacB : NULL;
  struct surface_molecule *const sm_reactant = sm_1 ? sm_1 : sm_2;
  bool const is_orientable = (w != NULL) || (sm_reactant != NULL);
  struct region_list *rlp_head_wall_1 = NULL, *rlp_head_wall_2 = NULL;
  struct region_list *rlp_head_obj_1 = NULL, *rlp_head_obj_2 = NULL;
  int sm_bitmask = determine_molecule_region_topology(
      world, sm_1, sm_2, &amp;rlp_head_wall_1, &amp;rlp_head_wall_2, &amp;rlp_head_obj_1,
      &amp;rlp_head_obj_2, is_unimol);
  struct abstract_molecule *const initiator = reacA;
  short const initiatorOrient = orientA;
  assert(reacA != NULL);
  if (reacA-&gt;properties != rx-&gt;players[0]) {
    struct abstract_molecule *tmp_mol = reacA;
    reacA = reacB;
    reacB = tmp_mol;
    short tmp_orient = orientA;
    orientA = orientB;
    orientB = tmp_orient;
  }
  assert(reacA != NULL);
  add_reactants_to_product_list(rx, reacA, reacB, NULL, &amp;product[0], &amp;product_type[0]);
  int replace_p1 = (product_type[0] == PLAYER_SURF_MOL &amp;&amp; rx_players[0] == NULL);
  int replace_p2 = rx-&gt;n_reactants &gt; 1 &amp;&amp; (product_type[1] == PLAYER_SURF_MOL &amp;&amp;
                                           rx_players[1] == NULL);
  struct vector2 rxn_uv_pos;   int rxn_uv_idx = -1;         int num_surface_static_reactants = 0;   if (is_orientable) {
    if (sm_reactant) {
      rxn_uv_pos = sm_reactant-&gt;s_pos;
    } else {
      xyz2uv(hitpt, w, &amp;rxn_uv_pos);
    }
    assert(w != NULL);
    if (w-&gt;grid == NULL) {
      assert(!IS_SURF_MOL(reacA));
      if (create_grid(world, w, ((struct volume_molecule *)reacA)-&gt;subvol))
        mcell_allocfailed("Failed to create a grid for a wall.");
    }
    rxn_uv_idx = uv2grid(&amp;rxn_uv_pos, w-&gt;grid);
    if ((sm_1 != NULL) &amp;&amp; (!distinguishable(sm_1-&gt;get_diffusion(sm_1), 0, EPS_C))){
      num_surface_static_reactants++;
    }
    if ((sm_2 != NULL) &amp;&amp; (!distinguishable(sm_2-&gt;get_diffusion(sm_2), 0, EPS_C))){
      num_surface_static_reactants++;
    }
  }
  int num_surface_products = 0;
  int num_surface_static_products = 0;   for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
    if (rx_players[n_product] == NULL) {
      continue;
    }
    if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
      num_surface_products++;
      if (!distinguishable(rx_players[n_product]-&gt;D, 0, EPS_C))
        num_surface_static_products++;
    }
  }
  int mol_idx = INT_MAX;
  struct tile_neighbor *tile_nbr_head = NULL;   int tile_nbr_list_length = 0;
  struct tile_neighbor *tile_vacant_nbr_head = NULL;   if (is_orientable) {
    if (num_surface_products &gt; 0) {
      if (sm_reactant != NULL) {
        find_neighbor_tiles(world, sm_reactant, sm_reactant-&gt;grid,
                            sm_reactant-&gt;grid_index, 1, 0, &amp;tile_nbr_head,
                            &amp;tile_nbr_list_length);
      } else {
        find_neighbor_tiles(world, sm_reactant, w-&gt;grid, rxn_uv_idx, 1, 0,
                            &amp;tile_nbr_head, &amp;tile_nbr_list_length);
      }
      for (struct tile_neighbor *tile_nbr = tile_nbr_head; tile_nbr != NULL;
           tile_nbr = tile_nbr-&gt;next) {
        struct surface_molecule_list *sm_list = tile_nbr-&gt;grid-&gt;sm_list[tile_nbr-&gt;idx]; 
        if (sm_list == NULL || sm_list-&gt;sm == NULL) {
          num_vacant_tiles++;
<a name="2"></a>          push_tile_neighbor_to_list(&amp;tile_vacant_nbr_head, tile_nbr-&gt;grid, tile_nbr-&gt;idx);
        }
      }
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    }
    int num_recycled_tiles = 0;
    if (replace_p1 &amp;&amp; replace_p2) {
      num_recycled_tiles = 2;
    } else if (replace_p1 || replace_p2) {
      num_recycled_tiles = 1;
    }</b></font>
    if (num_surface_products &gt; num_vacant_tiles + num_recycled_tiles) {
      return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
    }
    for (int n_product = 0; n_product &lt; n_players; ++n_product) {
      if (rx_players[n_product] == NULL) {
        continue;
      }
      int this_geometry = rx-&gt;geometries[i0 + n_product];
      int relative_orient = (this_geometry &lt; 0) ? -1 : 1;
      this_geometry = abs(this_geometry);
      if (this_geometry == 0) {
        product_orient[n_product] = (rng_uint(world-&gt;rng) &amp; 1) ? 1 : -1;
      } else {
        if (this_geometry &gt; (int)rx-&gt;n_reactants) {
          product_orient[n_product] = relative_orient *
              product_orient[this_geometry - rx-&gt;n_reactants - 1];
        } else if (this_geometry == 1) {
          product_orient[n_product] = relative_orient * orientA;
        } else if (this_geometry == 2 &amp;&amp; reacB != NULL) {
          product_orient[n_product] = relative_orient * orientB;
        } else {
          product_orient[n_product] = relative_orient * 1;
        }
      }
      if (n_product &lt; (int)rx-&gt;n_reactants) {
        if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
          assert(IS_SURF_MOL(product[n_product]));
          struct surface_molecule *sm =
              (struct surface_molecule *)product[n_product];
          if (sm-&gt;orient != product_orient[n_product]) {
            if (product[n_product]-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS|COUNT_ENCLOSED)) {
              count_region_from_scratch(world,
                                        product[n_product],                                         NULL,                                                       -1,                                                         NULL,                                         w,                                            t,                                            NULL);
            }
            if (((sm-&gt;flags &amp; ACT_REACT) != 0) &amp;&amp;
                ((sm-&gt;properties-&gt;flags &amp; CAN_SURFWALL) != 0)) {
              sm-&gt;t2 = 0;
            }
            sm-&gt;orient = product_orient[n_product];
            if (product[n_product]-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS|COUNT_ENCLOSED)) {
              count_region_from_scratch(world,
                                        product[n_product],                                         NULL,                                                       1,                                                          NULL,                                         w,                                            t,                                            NULL);
            }
          }
        } else if (!is_unimol) {           if (product[n_product] == initiator) {
            if (product_orient[n_product] != initiatorOrient)
              cross_wall = true;
          }
        }
      }
    }
    if (num_surface_products == 1) {
      if (is_unimol &amp;&amp; replace_p1) {
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if (rx_players[n_product] == NULL ||
             (rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0) {
            continue;
          }
          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
            product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
            product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
            replace_p1 = 0;
            break;
          }
        }
      } else if ((num_surface_static_reactants == 1) &amp;&amp; (num_surface_static_products == 1)
          &amp;&amp; (replace_p1 || replace_p2)) {
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if (rx_players[n_product] == NULL ||
              (rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0 ||
              distinguishable(rx_players[n_product]-&gt;D, 0, EPS_C)) {
            continue;
          }
          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            if (replace_p1 &amp;&amp; (!distinguishable(reacA-&gt;properties-&gt;D, 0, EPS_C))) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
              product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
              product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
              replace_p1 = 0;
              break;
            } else if (replace_p2 &amp;&amp; (!distinguishable(reacB-&gt;properties-&gt;D, 0, EPS_C))) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
              product_grid[n_product] = ((struct surface_molecule *)reacB)-&gt;grid;
              product_grid_idx[n_product] = ((struct surface_molecule *)reacB)-&gt;grid_index;
              break;
            }
          }
        }
      } else if (replace_p1 &amp;&amp; replace_p2) {
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if ((rx_players[n_product] == NULL) ||
              ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
            continue;
          }
          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            if (reacA == initiator) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
              product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
              product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
              replace_p1 = 0;
            } else {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
              product_grid[n_product] = ((struct surface_molecule *)reacB)-&gt;grid;
              product_grid_idx[n_product] = ((struct surface_molecule *)reacB)-&gt;grid_index;
            }
            break;
          }
        }
      } else if (replace_p1) {
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if ((rx_players[n_product] == NULL) ||
              ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
            continue;
          }
          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
            product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
            product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
            replace_p1 = 0;
            break;
          }
        }
      } else if (replace_p2) {
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if ((rx_players[n_product] == NULL) |
              ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
            continue;
          }
          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
            product_grid[n_product] = ((struct surface_molecule *)reacB)-&gt;grid;
            product_grid_idx[n_product] = ((struct surface_molecule *)reacB)-&gt;grid_index;
            break;
          }
        }
      }
    } else if (num_surface_products &gt; 1) {
      if (num_surface_static_reactants &gt; 0) {
        bool replace_reacA = (!distinguishable(reacA-&gt;get_diffusion(reacA), 0, EPS_C)) &amp;&amp; replace_p1;
        bool replace_reacB =
            (reacB == NULL) ? false : (!distinguishable(reacB-&gt;get_diffusion(reacB), 0, EPS_C)) &amp;&amp; replace_p2;
        if (replace_reacA || replace_reacB) {
          int max_static_count = (num_surface_static_products &lt; num_surface_static_reactants)
            ? num_surface_static_products : num_surface_static_reactants;
          int count = 0;
          while (count &lt; max_static_count) {
            unsigned int rnd_num = rng_uint(world-&gt;rng) % n_players;
            if ((rnd_num &lt; rx-&gt;n_reactants) || (rx_players[rnd_num] == NULL) ||
                ((rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0) ||
                distinguishable(rx_players[rnd_num]-&gt;D, 0, EPS_C)) {
              continue;
            }
            if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
              if (replace_reacA) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
                product_grid[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid;
                product_grid_idx[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid_index;
                count++;
                replace_p1 = 0;
                replace_reacA = 0;
              } else if (replace_reacB) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
                product_grid[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid;
                product_grid_idx[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid_index;
                count++;
                replace_p2 = 0;
                replace_reacB = 0;
              }
            }
          }         }
      }
      if (replace_p1 || replace_p2) {
        int surf_prod_left = 0, surf_reactant_left = 0;
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if ((rx_players[n_product] == NULL) ||
              ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
            continue;
          }
          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            surf_prod_left++;
          }
        }
        if (replace_p1) {
          surf_reactant_left++;
        }
        if (replace_p2) {
          surf_reactant_left++;
        }
        if (surf_prod_left &gt; 0) {
          int num_to_place = surf_prod_left;
          if (surf_prod_left &gt;= surf_reactant_left) {
            num_to_place = surf_reactant_left;
          }
          int count = 0;
          while (count &lt; num_to_place) {
            unsigned int rnd_num = rng_uint(world-&gt;rng) % n_players;
            if ((rnd_num &lt; rx-&gt;n_reactants) || (rx_players[rnd_num] == NULL) ||
                (rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0) {
             continue;
            }
            if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
              if (replace_p1) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
                product_grid[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid;
                product_grid_idx[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid_index;
                count++;
                replace_p1 = 0;
              } else if (replace_p2) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
                product_grid[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid;
                product_grid_idx[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid_index;
                replace_p2 = 0;
                count++;
              }
            }
          }         }
      }
    }
    if ((sm_reactant == NULL) &amp;&amp; (w != NULL) &amp;&amp; (num_surface_products &gt;= 1)) {
      assert(!IS_SURF_MOL(reacA));
      assert(rxn_uv_idx != -1);
      while (true) {
        unsigned int rnd_num = rng_uint(world-&gt;rng) % (n_players);
        if (rnd_num &lt;= 1 || (rx_players[rnd_num] == NULL) ||
            (rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0) {
          continue;
        }
        if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
          product_flag[rnd_num] = PRODUCT_FLAG_USE_UV_LOC;
          product_grid[rnd_num] = w-&gt;grid;
          product_grid_idx[rnd_num] = rxn_uv_idx;
          break;
        }
      }
    }
    if (is_unimol &amp;&amp; (sm_reactant != NULL) &amp;&amp; (num_surface_products == 2)) {
      reac_idx = sm_reactant-&gt;grid_index;
      reac_grid = sm_reactant-&gt;grid;
    }
    int do_it_once = 0;     int num_attempts = 0;
    for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
      if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
        if (product_flag[n_product] != PRODUCT_FLAG_NOT_SET) {
          continue;
        }
        if (num_vacant_tiles == 0) {
          return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
        }
        num_attempts = 0;
        while (true) {
          if (num_attempts &gt; SURFACE_DIFFUSION_RETRIES) {
            return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
          }
          unsigned int rnd_num = rng_uint(world-&gt;rng) % num_vacant_tiles;
          int tile_idx = -1;           tile_grid = NULL;
          if (get_tile_neighbor_from_list_of_vacant_neighbors(
                  tile_vacant_nbr_head, rnd_num, &amp;tile_grid, &amp;tile_idx) == 0) {
            return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
          }
          if (tile_idx &lt; 0) {
            continue;           }
          assert(tile_grid != NULL);
          if (!product_tile_can_be_reached(tile_grid-&gt;surface, rlp_head_wall_1,
            rlp_head_wall_2, rlp_head_obj_1, rlp_head_obj_2, sm_bitmask, is_unimol)) {
            uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
            num_attempts++;
            continue;
          }
          product_grid[n_product] = tile_grid;
          product_grid_idx[n_product] = tile_idx;
          product_flag[n_product] = PRODUCT_FLAG_USE_RANDOM;
          if (!do_it_once &amp;&amp; is_unimol &amp;&amp; (sm_reactant != NULL) &amp;&amp; (num_surface_products == 2)) {
            mol_idx = tile_idx;
            mol_grid = tile_grid;
            do_it_once = 1;
          }
          break;
        }       }
    }
  } 
  struct vector3 count_pos_xyz;
  struct periodic_image *periodic_box = ((struct volume_molecule *)reacA)-&gt;periodic_box;
  if (hitpt != NULL) {
    count_pos_xyz = *hitpt;
  } else if (sm_reactant) {
    uv2xyz(&amp;sm_reactant-&gt;s_pos, sm_reactant-&gt;grid-&gt;surface, &amp;count_pos_xyz);
  } else {
    count_pos_xyz = ((struct volume_molecule *)reacA)-&gt;pos;
  }
  struct vector3 mol_pos_tmp;
  struct subvolume *product_subvol = NULL;
  bool update_dissociation_index = false; 
  for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
    struct graph_data* g_data = NULL;
    if (rx-&gt;product_graph_data != NULL)
      g_data = rx-&gt;product_graph_data[path][n_product - rx-&gt;n_reactants];
    struct abstract_molecule *this_product = NULL;
    struct species *const product_species = rx_players[n_product];
    if (product_species-&gt;flags &amp; ON_GRID) {
      struct vector2 prod_uv_pos;
      if (world-&gt;randomize_smol_pos) {
        switch (product_flag[n_product]) {
        case PRODUCT_FLAG_USE_REACA_UV:
          if (is_unimol &amp;&amp; (num_surface_products == 2) &amp;&amp; (sm_reactant != NULL)) {
            if (mol_grid == NULL) {
              mcell_internal_error("Error in surface product placement for the "
                                   "unimolecular reaction.");
            }
            find_closest_position(product_grid[n_product], product_grid_idx[n_product],
              mol_grid, mol_idx, &amp;prod_uv_pos);
          } else {
            prod_uv_pos = ((struct surface_molecule *)reacA)-&gt;s_pos;
          }
          break;
        case PRODUCT_FLAG_USE_REACB_UV:
          assert(reacB != NULL);
          prod_uv_pos = ((struct surface_molecule *)reacB)-&gt;s_pos;
          break;
        case PRODUCT_FLAG_USE_UV_LOC:
          prod_uv_pos = rxn_uv_pos;
          break;
        case PRODUCT_FLAG_USE_RANDOM:
          if (is_unimol &amp;&amp; replace_p1 &amp;&amp; (num_surface_products == 2)) {
            find_closest_position(product_grid[n_product],
                                  product_grid_idx[n_product], reac_grid,
                                  reac_idx, &amp;prod_uv_pos);
          } else {
            grid2uv_random(product_grid[n_product], product_grid_idx[n_product],
                           &amp;prod_uv_pos, world-&gt;rng);
          }
          break;
        default:
          UNHANDLED_CASE(product_flag[n_product]);
        }
      } else {
        grid2uv(product_grid[n_product], product_grid_idx[n_product], &amp;prod_uv_pos);
      }
      this_product = (struct abstract_molecule *)place_sm_product(
          world, product_species, g_data, product_grid[n_product],
          product_grid_idx[n_product], &amp;prod_uv_pos, product_orient[n_product],
          t, reacA-&gt;periodic_box);
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
          dump_surface_molecule((struct surface_molecule*)this_product, "", true, "  created sm:", world-&gt;current_iterations, this_product-&gt;t, true);
      );
#endif
      if (!hitpt) {
        if (reacA-&gt;properties-&gt;flags &amp; ON_GRID) {
          w = ((struct surface_molecule *)reacA)-&gt;grid-&gt;surface;
          uv2xyz(&amp;((struct surface_molecule *)reacA)-&gt;s_pos,
                 w, &amp;mol_pos_tmp);
          product_subvol = find_subvolume(world, &amp;mol_pos_tmp, NULL);
        } else {
          mol_pos_tmp = ((struct volume_molecule *)reacA)-&gt;pos;
          product_subvol = ((struct volume_molecule *)reacA)-&gt;subvol;
        }
        hitpt = &amp;mol_pos_tmp;
      } else if (product_subvol == NULL) {
        product_subvol = find_subvolume(world, hitpt, NULL);
      }
      this_product = (struct abstract_molecule *)place_volume_product(
          world, product_species, g_data, sm_reactant, w, product_subvol, hitpt,
          product_orient[n_product], t, reacA-&gt;periodic_box);
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
      		dump_volume_molecule((struct volume_molecule*)this_product, "", true, "  created vm:", world-&gt;current_iterations, this_product-&gt;t, true);
      );
#endif
      if (((struct volume_molecule *)this_product)-&gt;index &lt; DISSOCIATION_MAX)
        update_dissociation_index = true;
    }
    if(rx-&gt;product_graph_data != NULL){
      this_product-&gt;graph_data = g_data;
    }
    ++product_species-&gt;population;
    if (product_species-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED))
      count_region_from_scratch(world, this_product, NULL, 1, NULL, NULL, t, this_product-&gt;periodic_box);
#ifndef MCELL3_DO_NOT_REUSE_MOL_ID_UNIMOL_RXN
    if (is_unimol &amp;&amp; (n_players == 1)) {
      this_product-&gt;id = reacA-&gt;id;
      world-&gt;current_mol_id--;       continue;
    }
    if ((n_players == 3) &amp;&amp; product_type[1] == PLAYER_WALL) {
      this_product-&gt;id = reacA-&gt;id;
      world-&gt;current_mol_id--;       continue;
    }
#endif
  }
  if (update_dissociation_index) {
    ASSERT_FOR_MCELL4(false);
    if (--world-&gt;dissociation_index &lt; DISSOCIATION_MIN)
      world-&gt;dissociation_index = DISSOCIATION_MAX;
  }
  if (rx-&gt;info[path].pathname != NULL) {
    if (world-&gt;place_waypoints_flag)
      count_region_from_scratch(world, NULL, rx-&gt;info[path].pathname, 1,
                                &amp;count_pos_xyz, w, t, periodic_box);
    if (rx-&gt;info[path].pathname-&gt;magic != NULL) {
      if (reaction_wizardry(world, rx-&gt;info[path].pathname-&gt;magic, w,
                            &amp;count_pos_xyz, t))
        mcell_allocfailed("Failed to complete reaction triggered release after "
                          "a '%s' reaction.",
                          rx-&gt;info[path].pathname-&gt;sym-&gt;name);
    }
  }
  delete_tile_neighbor_list(tile_nbr_head);
  delete_tile_neighbor_list(tile_vacant_nbr_head);
  delete_region_list(rlp_head_wall_1);
  delete_region_list(rlp_head_wall_2);
  delete_region_list(rlp_head_obj_1);
  delete_region_list(rlp_head_obj_2);
  return cross_wall ? RX_FLIP : RX_A_OK;
}
int outcome_unimolecular(struct volume *world, struct rxn *rx, int path,
                         struct abstract_molecule *reac, double t) {
  struct species *who_was_i = reac-&gt;properties;
  int result = RX_A_OK;
  struct volume_molecule *vm = NULL;
  struct surface_molecule *sm = NULL;
  if ((reac-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
    vm = (struct volume_molecule *)reac;
    if(reac-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
#if 0       for (int path = 0; path &lt; rx-&gt;n_pathways; path++) {
        outcome_nfsim(world, rx, path, reac, NULL, t);
      }
#else
      outcome_nfsim(world, rx, path, reac, NULL, t);
#endif
    }
    result = outcome_products_random(world, NULL, NULL, t, rx, path, reac,
                                       NULL, 0, 0);
  } else {
    sm = (struct surface_molecule *)reac;
      if ((strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_SURFACE_MOLECULES") == 0) ||
          (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_MOLECULES") == 0)) {
      } else {
        if(reac-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
          outcome_nfsim(world, rx, path, reac, NULL, t);
        }
        result = outcome_products_random(world, sm-&gt;grid-&gt;surface, NULL, t, rx,
                                         path, reac, NULL, sm-&gt;orient, 0);
      }
  }
  if (result == RX_BLOCKED)
    return RX_BLOCKED;
  if (result != RX_BLOCKED) {
    rx-&gt;info[path].count++;
    rx-&gt;n_occurred++;
    if(rx-&gt;product_graph_data != NULL){
      logNFSimReactions_c(rx-&gt;external_reaction_data[path].reaction_name);
    }
  }
  struct species *who_am_i = rx-&gt;players[rx-&gt;product_idx[path]];
  if (who_am_i == NULL) {
    if (vm != NULL) {
      vm-&gt;subvol-&gt;mol_count--;
      if (vm-&gt;flags &amp; IN_SCHEDULE)
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      if (vm-&gt;properties-&gt;flags &amp; COUNT_SOME_MASK) {
        count_region_from_scratch(world, (struct abstract_molecule *)vm, NULL,
                                  -1, &amp;(vm-&gt;pos), NULL, vm-&gt;t, vm-&gt;periodic_box);
      }
    } else {
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
        dump_surface_molecule(sm, "", true, "Unimolecular sm defunct:", world-&gt;current_iterations, sm-&gt;t, false);
      );
#endif
      remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
      sm-&gt;grid-&gt;n_occupied--;
      if (sm-&gt;flags &amp; IN_SCHEDULE) {
        sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
      if (sm-&gt;properties-&gt;flags &amp; COUNT_SOME_MASK) {
        count_region_from_scratch(world, (struct abstract_molecule *)sm, NULL,
                                  -1, NULL, NULL, sm-&gt;t, sm-&gt;periodic_box);
      }
    }
    free(reac-&gt;periodic_box);
    who_was_i-&gt;n_deceased++;
    double t_time = convert_iterations_to_seconds(
        world-&gt;start_iterations, world-&gt;time_unit,
        world-&gt;simulation_start_seconds, t);
    who_was_i-&gt;cum_lifetime_seconds += t_time - reac-&gt;birthday;
    who_was_i-&gt;population--;
    if (vm != NULL) {
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
        dump_volume_molecule(vm, "", true, "Unimolecular vm defunct:", world-&gt;current_iterations, vm-&gt;t, false);
      );
#endif
      collect_molecule(vm);
    }
    else {
      reac-&gt;properties = NULL;
      mem_put(reac-&gt;birthplace, reac);
    }
    return RX_DESTROY;
  } else if (who_am_i != who_was_i) {
    if (vm != NULL) {
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
        dump_volume_molecule(vm, "", true, "Unimolecular vm defunct:", world-&gt;current_iterations, vm-&gt;t, false);
      );
#endif
      collect_molecule(vm);
    }
    else
      reac-&gt;properties = NULL;
    return RX_DESTROY;
  } else
    return result;
}
int outcome_bimolecular(struct volume *world, struct rxn *rx, int path,
                        struct abstract_molecule *reacA,
                        struct abstract_molecule *reacB, short orientA,
                        short orientB, double t, struct vector3 *hitpt,
                        struct vector3 *loc_okay) {
#ifdef DEBUG_TIMING
  DUMP_CONDITION3(
      MCell::dump_outcome_bimolecular_timing(t);
  );
#endif
  assert(periodic_boxes_are_identical(reacA-&gt;periodic_box, reacB-&gt;periodic_box));
  struct surface_molecule *sm = NULL;
  struct volume_molecule *vm = NULL;
  struct wall *w = NULL;
  int result;
  int reacB_was_free = 0;
  int killA, killB;
  if ((reacA-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
    if ((reacB-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
      sm = (struct surface_molecule *)reacB;
      w = sm-&gt;grid-&gt;surface;
    }
  } else {     sm = (struct surface_molecule *)reacA;
    w = sm-&gt;grid-&gt;surface;
  }
  if(reacA-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
    result = outcome_nfsim(world, rx, path, reacA, reacB, t);
    result = outcome_products_random(world, w, hitpt, t, rx, path, reacA, reacB,
                                     orientA, orientB);
  }
  else {
    result = outcome_products_random(world, w, hitpt, t, rx, path, reacA, reacB,
                                     orientA, orientB);
  }
  if (result == RX_BLOCKED)
    return RX_BLOCKED;
  rx-&gt;n_occurred++;
  rx-&gt;info[path].count++;
  if(rx-&gt;product_graph_data != NULL){
    logNFSimReactions_c(rx-&gt;external_reaction_data[path].reaction_name);
  }
  if (rx-&gt;players[0] == reacA-&gt;properties) {
    killB = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
    killA = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
  } else {
    killB = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
    killA = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
  }
  if (killB) {
#ifdef DEBUG_RXNS
    DUMP_CONDITION3(
      dump_volume_molecule((struct volume_molecule*)reacB, "", true, "  defunct m:", world-&gt;current_iterations, 0.0, false);
    );
#endif
    vm = NULL;
    if ((reacB-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
      sm = (struct surface_molecule *)reacB;
      remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
      sm-&gt;grid-&gt;n_occupied--;
      if (sm-&gt;flags &amp; IN_SURFACE)
        sm-&gt;flags -= IN_SURFACE;
      if (sm-&gt;flags &amp; IN_SCHEDULE) {
        sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
    } else if ((reacB-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
      vm = (struct volume_molecule *)reacB;
      vm-&gt;subvol-&gt;mol_count--;
      if (vm-&gt;flags &amp; IN_SCHEDULE) {
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
      reacB_was_free = 1;
    }
    if ((reacB-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) != 0) {
      count_region_from_scratch(world, reacB, NULL, -1, NULL, NULL, t, reacB-&gt;periodic_box);
    }
    free(reacB-&gt;periodic_box);
    reacB-&gt;periodic_box = NULL;
    reacB-&gt;properties-&gt;n_deceased++;
    double t_time = convert_iterations_to_seconds(
        world-&gt;start_iterations, world-&gt;time_unit,
        world-&gt;simulation_start_seconds, t);
    reacB-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacB-&gt;birthday;
    reacB-&gt;properties-&gt;population--;
    if (vm != NULL)
      collect_molecule(vm);
    else
      reacB-&gt;properties = NULL;
  }
  if (killA) {
#ifdef DEBUG_RXNS
    DUMP_CONDITION3(
      dump_volume_molecule((struct volume_molecule*)reacA, "", true, "  defunct m:", world-&gt;current_iterations, 0.0, false);
    );
#endif
    vm = NULL;
    if ((reacA-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
      sm = (struct surface_molecule *)reacA;
      remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
      sm-&gt;grid-&gt;n_occupied--;
      if (sm-&gt;flags &amp; IN_SCHEDULE) {
        sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
    } else if ((reacA-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
      vm = (struct volume_molecule *)reacA;
      vm-&gt;subvol-&gt;mol_count--;
      if (vm-&gt;flags &amp; IN_SCHEDULE) {
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
    }
    if ((reacA-&gt;properties-&gt;flags &amp; ON_GRID) !=
        0)     {
      if (reacA-&gt;properties-&gt;flags &amp;
          COUNT_SOME_MASK)       {
        count_region_from_scratch(world, reacA, NULL, -1, NULL, NULL, t, reacA-&gt;periodic_box);
      }
    } else if (reacA-&gt;flags &amp; COUNT_ME) {
      if (hitpt == NULL || reacB_was_free ||
          (reacB-&gt;properties != NULL &amp;&amp;
           (reacB-&gt;properties-&gt;flags &amp; NOT_FREE) == 0)) {
        count_region_from_scratch(world, reacA, NULL, -1, hitpt, NULL, t, reacA-&gt;periodic_box);
      {
        struct vector3 fake_hitpt;
        vm = (struct volume_molecule *)reacA;
        if (loc_okay == NULL)
          loc_okay = &amp;(vm-&gt;pos);
        fake_hitpt.x = 0.5 * hitpt-&gt;x + 0.5 * loc_okay-&gt;x;
        fake_hitpt.y = 0.5 * hitpt-&gt;y + 0.5 * loc_okay-&gt;y;
        fake_hitpt.z = 0.5 * hitpt-&gt;z + 0.5 * loc_okay-&gt;z;
        count_region_from_scratch(world, reacA, NULL, -1, &amp;fake_hitpt, NULL, t, reacA-&gt;periodic_box);
      }
    }
    free(reacA-&gt;periodic_box);
    reacA-&gt;periodic_box = NULL;
    reacA-&gt;properties-&gt;n_deceased++;
    double t_time = convert_iterations_to_seconds(
        world-&gt;start_iterations, world-&gt;time_unit,
        world-&gt;simulation_start_seconds, t);
    reacA-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacA-&gt;birthday;
    reacA-&gt;properties-&gt;population--;
    if (vm != NULL)
      collect_molecule(vm);
    else
      reacA-&gt;properties = NULL;
    return RX_DESTROY;
  }
  return result;
}
int outcome_intersect(struct volume *world, struct rxn *rx, int path,
                      struct wall *surface, struct abstract_molecule *reac,
                      short orient, double t, struct vector3 *hitpt,
                      struct vector3 *loc_okay) {
  if (rx-&gt;n_pathways &lt;= RX_SPECIAL) {
    rx-&gt;n_occurred++;
    if (rx-&gt;n_pathways == RX_REFLEC)
      return RX_A_OK;
    else
      return RX_FLIP;   }
  int idx = rx-&gt;product_idx[path];
  if ((reac-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
    struct volume_molecule *vm = (struct volume_molecule *)reac;
    int result;
    if ((strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_MOLECULES") == 0) ||
        (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_VOLUME_MOLECULES") == 0)) {
      result = RX_DESTROY;
    } else {
      result = outcome_products_random(world, surface, hitpt, t, rx, path,
                                       reac, NULL, orient, 0);
    }
    if (result == RX_BLOCKED)
      return RX_A_OK; 
    rx-&gt;info[path].count++;
    rx-&gt;n_occurred++;
    if (rx-&gt;players[idx] == NULL) {
      vm-&gt;subvol-&gt;mol_count--;
      if (world-&gt;place_waypoints_flag &amp;&amp; (reac-&gt;flags &amp; COUNT_ME)) {
        if (hitpt == NULL) {
          count_region_from_scratch(
            world, reac, NULL, -1, NULL, NULL, t, reac-&gt;periodic_box);
        } else {
          struct vector3 fake_hitpt;
          if (loc_okay == NULL)
            loc_okay = &amp;(vm-&gt;pos);
          fake_hitpt.x = 0.5 * hitpt-&gt;x + 0.5 * loc_okay-&gt;x;
          fake_hitpt.y = 0.5 * hitpt-&gt;y + 0.5 * loc_okay-&gt;y;
          fake_hitpt.z = 0.5 * hitpt-&gt;z + 0.5 * loc_okay-&gt;z;
          count_region_from_scratch(world, reac, NULL, -1, &amp;fake_hitpt, NULL,
                                    t, reac-&gt;periodic_box);
        }
      }
      free(reac-&gt;periodic_box);
      reac-&gt;properties-&gt;n_deceased++;
      double t_time = convert_iterations_to_seconds(
          world-&gt;start_iterations, world-&gt;time_unit,
          world-&gt;simulation_start_seconds, t);
      reac-&gt;properties-&gt;cum_lifetime_seconds += t_time - reac-&gt;birthday;
      reac-&gt;properties-&gt;population--;
      if (vm-&gt;flags &amp; IN_SCHEDULE) {
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
         dump_volume_molecule((struct volume_molecule*)vm, "", true, "  defunct m:", world-&gt;current_iterations, 0.0, false);
      );
#endif
      collect_molecule(vm);
      return RX_DESTROY;
    } else
      return result;   } else {
    return RX_A_OK;
  }
}
int reaction_wizardry(struct volume *world, struct magic_list *incantation,
                      struct wall *surface, struct vector3 *hitpt, double t) {
  struct release_event_queue req; 
  req.next = NULL;
  req.event_time = t;
  req.train_counter = 0;
  req.train_high_time = t;
  if (hitpt == NULL) {
    init_matrix(req.t_matrix);
  } else if (surface == NULL ||
             !distinguishable(surface-&gt;normal.z, 1.0,
                              EPS_C))   {
    init_matrix(req.t_matrix);
    req.t_matrix[3][0] = hitpt-&gt;x;
    req.t_matrix[3][1] = hitpt-&gt;y;
    req.t_matrix[3][2] = hitpt-&gt;z;
  {
    struct vector3 scale = { 1.0, 1.0, 1.0 };     struct vector3 axis = { 1.0, 0.0, 0.0 };      double cos_theta;
    double degrees;
    cos_theta = surface-&gt;normal.z;     if (!distinguishable(cos_theta, -1.0, EPS_C)) {
      degrees = 180.0;     } else {
      axis.x = -surface-&gt;normal.y;
      axis.y = surface-&gt;normal.x;
      axis.z = 0.0;
      degrees = acos(cos_theta) * 180.0 / MY_PI;
    }
    tform_matrix(&amp;scale, hitpt, &amp;axis, degrees, req.t_matrix);
  }
  for (; incantation != NULL; incantation = incantation-&gt;next) {
    if (incantation-&gt;type != magic_release)
      continue; 
    req.release_site = (struct release_site_obj *)incantation-&gt;data;
    if (release_molecules(world, &amp;req))
      return 1;
  }
  return 0;
}
int determine_molecule_region_topology(
    struct volume *world, struct surface_molecule *sm_1,
    struct surface_molecule *sm_2, struct region_list **rlp_wall_1_ptr,
    struct region_list **rlp_wall_2_ptr, struct region_list **rlp_obj_1_ptr,
<a name="1"></a>    struct region_list **rlp_obj_2_ptr, bool is_unimol) {
  int sm_bitmask = 0;
  struct wall *w_1, *w_2;
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  struct region_list *rlp_head_wall_1 = NULL;
  struct region_list *rlp_head_wall_2 = NULL;
  struct region_list *rlp_head_obj_1 = NULL;
  struct region_list *rlp_head_obj_2 = NULL;</b></font>
  if ((sm_1 != NULL) &amp;&amp; (sm_2 != NULL)) {
    if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
        (sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
        are_restricted_regions_for_species_on_object(
            world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
        are_restricted_regions_for_species_on_object(
            world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2)) {
      w_1 = sm_1-&gt;grid-&gt;surface;
      w_2 = sm_2-&gt;grid-&gt;surface;
      rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
      rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
      if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 != NULL)) {
        sm_bitmask |= ALL_INSIDE;
      }
      else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 == NULL)) {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        sm_bitmask |= ALL_OUTSIDE;
      }
      else if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 == NULL)) {
        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        sm_bitmask |= SURF1_IN_SURF2_OUT;
      }
      else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 != NULL)) {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        sm_bitmask |= SURF1_OUT_SURF2_IN;
      }
    }
    else if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
             are_restricted_regions_for_species_on_object(
                 world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
             (!(sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
              !are_restricted_regions_for_species_on_object(
<a name="0"></a>                   world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2))) {
      w_1 = sm_1-&gt;grid-&gt;surface;
      rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>      if (rlp_head_wall_1 != NULL) {
        sm_bitmask |= SURF1_IN;
      } else {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        sm_bitmask |= SURF1_OUT;
      }
    }
    else if ((sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
             are_restricted_regions_for_species_on_object(
                 world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2) &amp;&amp;
             (!(sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
              !are_restricted_regions_for_species_on_object(
                   world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1))) {</b></font>
      w_2 = sm_2-&gt;grid-&gt;surface;
      rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
      if (rlp_head_wall_2 != NULL) {
        sm_bitmask |= SURF2_IN;
      } else {
        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        sm_bitmask |= SURF2_OUT;
      }
    }
  }
  else if ((sm_1 != NULL) &amp;&amp; is_unimol) {
    if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
        are_restricted_regions_for_species_on_object(
            world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1)) {
      w_1 = sm_1-&gt;grid-&gt;surface;
      rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
      if (rlp_head_wall_1 != NULL) {
        sm_bitmask |= ALL_INSIDE;
      } else {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        sm_bitmask |= ALL_OUTSIDE;
      }
    }
  }
  *rlp_wall_1_ptr = rlp_head_wall_1;
  *rlp_wall_2_ptr = rlp_head_wall_2;
  *rlp_obj_1_ptr = rlp_head_obj_1;
  *rlp_obj_2_ptr = rlp_head_obj_2;
  return sm_bitmask;
}
bool product_tile_can_be_reached(struct wall *target,
                                 struct region_list *rlp_head_wall_1,
                                 struct region_list *rlp_head_wall_2,
                                 struct region_list *rlp_head_obj_1,
                                 struct region_list *rlp_head_obj_2,
                                 int sm_bitmask, bool is_unimol) {
  bool status = true;
  if (sm_bitmask &amp; ALL_INSIDE) {
    if (is_unimol) {
      if (!wall_belongs_to_all_regions_in_region_list(target,
                                                      rlp_head_wall_1)) {
        status = false;
      }
    } else {
      if (!wall_belongs_to_all_regions_in_region_list(target,
                                                      rlp_head_wall_1) ||
          !wall_belongs_to_all_regions_in_region_list(target,
                                                      rlp_head_wall_2)) {
        status = false;
      }
    }
  } else if (sm_bitmask &amp; ALL_OUTSIDE) {
    if (is_unimol) {
      if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1)) {
        status = false;
      }
    } else {
      if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1) ||
          wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_2)) {
        status = false;
      }
    }
  } else if (sm_bitmask &amp; SURF1_IN_SURF2_OUT) {
    if (!wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_1) ||
        wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_2)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF1_OUT_SURF2_IN) {
    if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1) ||
        !wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_2)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF1_IN) {
    if (!wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_1)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF1_OUT) {
    if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF2_IN) {
    if (!wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_2)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF2_OUT) {
    if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_2)) {
      status = false;
    }
  }
  return status;
}
int cleanup_and_block_rx(struct tile_neighbor *tn1, struct tile_neighbor *tn2) {
  if (tn1 != NULL) {
    delete_tile_neighbor_list(tn1);
  }
  if (tn2 != NULL) {
    delete_tile_neighbor_list(tn2);
  }
  return RX_BLOCKED;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>grid_util.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;math.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;vector&gt;
#include "logging.h"
#include "rng.h"
#include "grid_util.h"
#include "vol_util.h"
#include "wall_util.h"
#include "react.h"
#include "init.h"
#include "debug_config.h"
#include "dump_state.h"
void xyz2uv(struct vector3 *a, struct wall *w, struct vector2 *b) {
  if (w-&gt;grid) {
    b-&gt;u = a-&gt;x * w-&gt;unit_u.x + a-&gt;y * w-&gt;unit_u.y + a-&gt;z * w-&gt;unit_u.z -
           w-&gt;grid-&gt;vert0.u;
    b-&gt;v = a-&gt;x * w-&gt;unit_v.x + a-&gt;y * w-&gt;unit_v.y + a-&gt;z * w-&gt;unit_v.z -
           w-&gt;grid-&gt;vert0.v;
  } else {
    struct vector3 p;
    p.x = a-&gt;x - w-&gt;vert[0]-&gt;x;
    p.y = a-&gt;y - w-&gt;vert[0]-&gt;y;
    p.z = a-&gt;z - w-&gt;vert[0]-&gt;z;
    b-&gt;u = p.x * w-&gt;unit_u.x + p.y * w-&gt;unit_u.y + p.z * w-&gt;unit_u.z;
    b-&gt;v = p.x * w-&gt;unit_v.x + p.y * w-&gt;unit_v.y + p.z * w-&gt;unit_v.z;
  }
}
void uv2xyz(struct vector2 *a, struct wall *w, struct vector3 *b) {
  b-&gt;x = a-&gt;u * w-&gt;unit_u.x + a-&gt;v * w-&gt;unit_v.x + w-&gt;vert[0]-&gt;x;
  b-&gt;y = a-&gt;u * w-&gt;unit_u.y + a-&gt;v * w-&gt;unit_v.y + w-&gt;vert[0]-&gt;y;
  b-&gt;z = a-&gt;u * w-&gt;unit_u.z + a-&gt;v * w-&gt;unit_v.z + w-&gt;vert[0]-&gt;z;
}
int xyz2grid(struct vector3 *v, struct surface_grid *g) {
  struct vector3 *unit_u = &amp;(g-&gt;surface-&gt;unit_u);
  struct vector3 *unit_v = &amp;(g-&gt;surface-&gt;unit_v);
  double i, j;
  double u0, u1_u0;
  double striploc, striprem, stripeloc, striperem;
  int strip, stripe, flip, idx;
  int tile_idx_0, tile_idx_mid, tile_idx_last;
  if (g-&gt;n_tiles == 1)
    return 0;
  tile_idx_0 = 0;
  tile_idx_mid = g-&gt;n_tiles - 2 * (g-&gt;n) + 1;
  tile_idx_last = g-&gt;n_tiles - 1;
  if (!(distinguishable_vec3(v, g-&gt;surface-&gt;vert[0], EPS_C)))
    return tile_idx_mid;
  if (!(distinguishable_vec3(v, g-&gt;surface-&gt;vert[1], EPS_C)))
    return tile_idx_last;
  if (!(distinguishable_vec3(v, g-&gt;surface-&gt;vert[2], EPS_C)))
    return tile_idx_0;
  if (!(point_in_triangle(v, g-&gt;surface-&gt;vert[0], g-&gt;surface-&gt;vert[1],
                          g-&gt;surface-&gt;vert[2]))) {
    mcell_internal_error(
        "Error in function 'xyz2grid()': point is outside wall.");
  }
  i = v-&gt;x * unit_u-&gt;x + v-&gt;y * unit_u-&gt;y + v-&gt;z * unit_u-&gt;z - g-&gt;vert0.u;
  j = v-&gt;x * unit_v-&gt;x + v-&gt;y * unit_v-&gt;y + v-&gt;z * unit_v-&gt;z - g-&gt;vert0.v;
  striploc = j * g-&gt;inv_strip_wid;
  strip = (int)striploc;
  striprem = striploc - strip;
  strip = g-&gt;n - strip - 1;
  u0 = j * g-&gt;vert2_slope;
  u1_u0 = g-&gt;surface-&gt;uv_vert1_u - j * g-&gt;fullslope;
  stripeloc = ((i - u0) / u1_u0) * (((double)strip) + (1.0 - striprem));
  stripe = (int)(stripeloc);
  striperem = stripeloc - stripe;
  flip = (striperem &lt; 1.0 - striprem) ? 0 : 1;
  idx = strip * strip + 2 * stripe + flip;
  if ((u_int)idx &gt;= g-&gt;n_tiles) {
    mcell_internal_error("Error in function 'xyz2grid()': returning tile index "
                         "%d while wall has %u tiles",
                         idx, g-&gt;n_tiles);
  }
  return idx;
}
int uv2grid(struct vector2 *v, struct surface_grid *g) {
  double i, j;
  double u0, u1_u0;
  double striploc, striprem, stripeloc, striperem;
  int strip, stripe, flip, idx;
  struct vector2 vert_0, vert_1;
  int tile_idx_0, tile_idx_mid, tile_idx_last;
  if (g-&gt;n_tiles == 1)
    return 0;
  tile_idx_0 = 0;
  tile_idx_mid = g-&gt;n_tiles - 2 * (g-&gt;n) + 1;
  tile_idx_last = g-&gt;n_tiles - 1;
  vert_0.u = vert_0.v = 0;
  vert_1.u = g-&gt;surface-&gt;uv_vert1_u;
  vert_1.v = 0;
  if (!distinguishable_vec2(v, &amp;vert_0, EPS_C))
    return tile_idx_mid;
  if (!distinguishable_vec2(v, &amp;vert_1, EPS_C))
    return tile_idx_0;
  if (!distinguishable_vec2(v, &amp;g-&gt;surface-&gt;uv_vert2, EPS_C))
    return tile_idx_last;
  if (!(point_in_triangle_2D(v, &amp;vert_0, &amp;vert_1, &amp;g-&gt;surface-&gt;uv_vert2))) {
    mcell_internal_error(
        "Error in function 'uv2grid()': point is outside wall.");
  }
  i = v-&gt;u;
  j = v-&gt;v;
  striploc = j * g-&gt;inv_strip_wid;
  strip = (int)striploc;
  striprem = striploc - strip;
  strip = g-&gt;n - strip - 1;
  u0 = j * g-&gt;vert2_slope;
  u1_u0 = g-&gt;surface-&gt;uv_vert1_u - j * g-&gt;fullslope;
  stripeloc = ((i - u0) / u1_u0) * (((double)strip) + (1.0 - striprem));
  stripe = (int)(stripeloc);
  striperem = stripeloc - stripe;
  flip = (striperem &lt; 1.0 - striprem) ? 0 : 1;
  idx = strip * strip + 2 * stripe + flip;
  if ((u_int)idx &gt;= g-&gt;n_tiles) {
    mcell_internal_error("Error in function 'xyz2grid()': returning tile index "
                         "%d while wall has %u tiles",
                         idx, g-&gt;n_tiles);
  }
  return idx;
}
void grid2xyz(struct surface_grid *g, int idx, struct vector3 *v) {
  struct vector3 *unit_u = &amp;(g-&gt;surface-&gt;unit_u);
  struct vector3 *unit_v = &amp;(g-&gt;surface-&gt;unit_v);
  int root;
  int rootrem;
  int k, j, i;
  double ucoef, vcoef, over3n;
  root = (int)(sqrt((double)idx));
  rootrem = idx - root * root;
  k = g-&gt;n - root - 1;
  j = rootrem / 2;
  i = rootrem - 2 * j;
  over3n = 1.0 / (double)(3 * g-&gt;n);
  ucoef = ((double)(3 * j + i + 1)) * over3n * g-&gt;surface-&gt;uv_vert1_u +
          ((double)(3 * k + i + 1)) * over3n * g-&gt;surface-&gt;uv_vert2.u;
  vcoef = ((double)(3 * k + i + 1)) * over3n * g-&gt;surface-&gt;uv_vert2.v;
  v-&gt;x = ucoef * unit_u-&gt;x + vcoef * unit_v-&gt;x + g-&gt;surface-&gt;vert[0]-&gt;x;
  v-&gt;y = ucoef * unit_u-&gt;y + vcoef * unit_v-&gt;y + g-&gt;surface-&gt;vert[0]-&gt;y;
  v-&gt;z = ucoef * unit_u-&gt;z + vcoef * unit_v-&gt;z + g-&gt;surface-&gt;vert[0]-&gt;z;
}
void grid2uv(struct surface_grid *g, int idx, struct vector2 *v) {
  int root;
  int rootrem;
  int k, j, i;
  double over3n;
  root = (int)(sqrt((double)idx));
  rootrem = idx - root * root;
  k = g-&gt;n - root - 1;
  j = rootrem / 2;
  i = rootrem - 2 * j;
  over3n = 1.0 / (double)(3 * g-&gt;n);
  v-&gt;u = ((double)(3 * j + i + 1)) * over3n * g-&gt;surface-&gt;uv_vert1_u +
         ((double)(3 * k + i + 1)) * over3n * g-&gt;surface-&gt;uv_vert2.u;
  v-&gt;v = ((double)(3 * k + i + 1)) * over3n * g-&gt;surface-&gt;uv_vert2.v;
}
void grid2uv_random(struct surface_grid *g, int idx, struct vector2 *v,
                    struct rng_state *rng) {
  int root;
  int rootrem;
  int k, j, i;
  double over_n;
  double u_ran, v_ran;
  root = (int)(sqrt((double)idx));
  rootrem = idx - root * root;
  k = g-&gt;n - root - 1;
  j = rootrem / 2;
  i = rootrem - 2 * j;
  over_n = 1.0 / (double)(g-&gt;n);
  u_ran = rng_dbl(rng);
  v_ran = 1.0 - sqrt(rng_dbl(rng));
  v-&gt;u =
      ((double)(j + i) + (1 - 2 * i) * (1.0 - v_ran) * u_ran) * over_n *
          g-&gt;surface-&gt;uv_vert1_u +
      ((double)(k + i) + (1 - 2 * i) * v_ran) * over_n * g-&gt;surface-&gt;uv_vert2.u;
  v-&gt;v =
      ((double)(k + i) + (1 - 2 * i) * v_ran) * over_n * g-&gt;surface-&gt;uv_vert2.v;
}
void init_grid_geometry(struct surface_grid *g) {
  g-&gt;inv_strip_wid = 1.0 / (g-&gt;surface-&gt;uv_vert2.v / ((double)g-&gt;n));
  g-&gt;vert2_slope = g-&gt;surface-&gt;uv_vert2.u / g-&gt;surface-&gt;uv_vert2.v;
  g-&gt;fullslope = g-&gt;surface-&gt;uv_vert1_u / g-&gt;surface-&gt;uv_vert2.v;
  g-&gt;vert0.u = g-&gt;surface-&gt;vert[0]-&gt;x * g-&gt;surface-&gt;unit_u.x +
               g-&gt;surface-&gt;vert[0]-&gt;y * g-&gt;surface-&gt;unit_u.y +
               g-&gt;surface-&gt;vert[0]-&gt;z * g-&gt;surface-&gt;unit_u.z;
  g-&gt;vert0.v = g-&gt;surface-&gt;vert[0]-&gt;x * g-&gt;surface-&gt;unit_v.x +
               g-&gt;surface-&gt;vert[0]-&gt;y * g-&gt;surface-&gt;unit_v.y +
               g-&gt;surface-&gt;vert[0]-&gt;z * g-&gt;surface-&gt;unit_v.z;
  g-&gt;n_tiles = g-&gt;n * g-&gt;n;
}
int create_grid(struct volume *world, struct wall *w, struct subvolume *guess) {
  struct surface_grid *sg = NULL;
  struct vector3 center;
  if (w-&gt;grid != NULL)
    return 0;
  sg = (struct surface_grid *)CHECKED_MEM_GET(w-&gt;birthplace-&gt;grids,
                                              "surface grid");
  if (sg == NULL)
    return 1;
  center.x = 0.33333333333 * (w-&gt;vert[0]-&gt;x + w-&gt;vert[1]-&gt;x + w-&gt;vert[2]-&gt;x);
  center.y = 0.33333333333 * (w-&gt;vert[0]-&gt;y + w-&gt;vert[1]-&gt;y + w-&gt;vert[2]-&gt;y);
  center.z = 0.33333333333 * (w-&gt;vert[0]-&gt;z + w-&gt;vert[1]-&gt;z + w-&gt;vert[2]-&gt;z);
  sg-&gt;surface = w;
  sg-&gt;subvol = find_subvolume(world, &amp;center, guess);
  sg-&gt;n = (int)ceil(sqrt(w-&gt;area));
  if (sg-&gt;n &lt; 1)
    sg-&gt;n = 1;
  sg-&gt;n_tiles = sg-&gt;n * sg-&gt;n;
  sg-&gt;n_occupied = 0;
  sg-&gt;binding_factor = ((double)sg-&gt;n_tiles) / w-&gt;area;
  init_grid_geometry(sg);
  sg-&gt;sm_list = CHECKED_MALLOC_ARRAY(struct surface_molecule_list *, sg-&gt;n_tiles,
                                     "surface grid");
  for (unsigned int i = 0; i &lt; sg-&gt;n_tiles; i++) {
    sg-&gt;sm_list[i] = NULL;
  }
  w-&gt;grid = sg;
  return 0;
}
void grid_neighbors(struct volume *world, struct surface_grid *grid, int idx,
                    int create_grid_flag, struct surface_grid **nb_grid,
                    int *nb_idx) {
  int i, j, k, root, rootrem;
  struct vector3 loc_3d;
  struct vector2 near_2d;
  double d;
  root = (int)(sqrt((double)idx));
  rootrem = idx - root * root;
  k = root;
  j = rootrem / 2;
  i = rootrem - 2 * j;
  if (j &gt; 0 || i &gt; 0)   {
    nb_grid[2] = grid;
    nb_idx[2] = idx - 1;
  } else   {
    if (grid-&gt;surface-&gt;nb_walls[2] == NULL)
      nb_grid[2] = NULL;
    else if ((grid-&gt;surface-&gt;nb_walls[2]-&gt;grid == NULL) &amp;&amp; (!create_grid_flag))
      nb_grid[2] = NULL;
    else {
      if ((grid-&gt;surface-&gt;nb_walls[2]-&gt;grid == NULL) &amp;&amp; create_grid_flag) {
        if (create_grid(world, grid-&gt;surface-&gt;nb_walls[2], NULL))
          mcell_allocfailed("Failed to create grid for wall.");
      }
      if (grid-&gt;sm_list[idx]-&gt;sm != NULL)
        uv2xyz(&amp;grid-&gt;sm_list[idx]-&gt;sm-&gt;s_pos, grid-&gt;surface, &amp;loc_3d);
      else
        grid2xyz(grid, idx, &amp;loc_3d);
      d = closest_interior_point(&amp;loc_3d, grid-&gt;surface-&gt;nb_walls[2], &amp;near_2d,
                                 GIGANTIC);
      if (!distinguishable(d, GIGANTIC, EPS_C))
        nb_grid[2] = NULL;
      else {
        nb_grid[2] = grid-&gt;surface-&gt;nb_walls[2]-&gt;grid;
        nb_idx[2] = uv2grid(&amp;near_2d, nb_grid[2]);
      }
    }
  }
  if (j &lt; k)   {
    nb_grid[1] = grid;
    nb_idx[1] = idx + 1;
  } else   {
    if (grid-&gt;surface-&gt;nb_walls[1] == NULL)
      nb_grid[1] = NULL;
    else if ((grid-&gt;surface-&gt;nb_walls[1]-&gt;grid == NULL) &amp;&amp; (!create_grid_flag))
      nb_grid[1] = NULL;
    else {
      if ((grid-&gt;surface-&gt;nb_walls[1]-&gt;grid == NULL) &amp;&amp; create_grid_flag) {
        if (create_grid(world, grid-&gt;surface-&gt;nb_walls[1], NULL))
          mcell_allocfailed("Failed to create grid for wall.");
      }
      if (grid-&gt;sm_list[idx]-&gt;sm != NULL)
        uv2xyz(&amp;grid-&gt;sm_list[idx]-&gt;sm-&gt;s_pos, grid-&gt;surface, &amp;loc_3d);
      else
        grid2xyz(grid, idx, &amp;loc_3d);
      d = closest_interior_point(&amp;loc_3d, grid-&gt;surface-&gt;nb_walls[1], &amp;near_2d,
                                 GIGANTIC);
      if (!distinguishable(d, GIGANTIC, EPS_C))
        nb_grid[1] = NULL;
      else {
        nb_grid[1] = grid-&gt;surface-&gt;nb_walls[1]-&gt;grid;
        nb_idx[1] = uv2grid(&amp;near_2d, nb_grid[1]);
      }
    }
  }
  if (i || k + 1 &lt; grid-&gt;n)   {
    nb_grid[0] = grid;
    if (i)
      nb_idx[0] =
          2 * j + (k - 1) * (k - 1);     else
      nb_idx[0] = 1 + 2 * j + (k + 1) * (k + 1);   } else   {
    if (grid-&gt;surface-&gt;nb_walls[0] == NULL)
      nb_grid[0] = NULL;
    else if ((grid-&gt;surface-&gt;nb_walls[0]-&gt;grid == NULL) &amp;&amp; (!create_grid_flag))
      nb_grid[0] = NULL;
    else {
      if ((grid-&gt;surface-&gt;nb_walls[0]-&gt;grid == NULL) &amp;&amp; create_grid_flag) {
        if (create_grid(world, grid-&gt;surface-&gt;nb_walls[0], NULL))
          mcell_allocfailed("Failed to create grid for wall.");
      }
      if (grid-&gt;sm_list[idx]-&gt;sm != NULL)
        uv2xyz(&amp;grid-&gt;sm_list[idx]-&gt;sm-&gt;s_pos, grid-&gt;surface, &amp;loc_3d);
      else
        grid2xyz(grid, idx, &amp;loc_3d);
      d = closest_interior_point(&amp;loc_3d, grid-&gt;surface-&gt;nb_walls[0], &amp;near_2d,
                                 GIGANTIC);
      if (!distinguishable(d, GIGANTIC, EPS_C))
        nb_grid[0] = NULL;
      else {
        nb_grid[0] = grid-&gt;surface-&gt;nb_walls[0]-&gt;grid;
        nb_idx[0] = uv2grid(&amp;near_2d, nb_grid[0]);
      }
    }
  }
}
int nearest_free(struct surface_grid *g, struct vector2 *v, double max_d2,
                 double *found_dist2) {
  int h, i, j, k;
  int span;
  int can_flip;
  int idx;
  double d2;
  double f, ff, fff;
  double over3n = 0.333333333333333 / (double)(g-&gt;n);
  if (g-&gt;n_occupied &gt;= g-&gt;n_tiles) {
    *found_dist2 = 0;
    return -1;
  }
  idx = -1;
  d2 = 2 * max_d2 + 1.0;
  for (k = 0; k &lt; g-&gt;n; k++) {
    f = v-&gt;v - ((double)(3 * k + 1)) * over3n * g-&gt;surface-&gt;uv_vert2.v;
    ff = f - over3n * g-&gt;surface-&gt;uv_vert2.v;
    ff *= ff;
    f *= f;
    if (f &gt; max_d2 &amp;&amp; ff &gt; max_d2)
      continue; 
    span = (g-&gt;n - k);
    for (j = 0; j &lt; span; j++) {
      can_flip = (j != span - 1);
      for (i = 0; i &lt;= can_flip; i++) {
        fff =
            v-&gt;u - over3n * ((double)(3 * j + i + 1) * g-&gt;surface-&gt;uv_vert1_u +
                             (double)(3 * k + i + 1) * g-&gt;surface-&gt;uv_vert2.u);
        fff *= fff;
        if (i)
          fff += ff;
        else
          fff += f;
        if (fff &lt; max_d2 &amp;&amp; (idx == -1 || fff &lt; d2)) {
          h = (g-&gt;n - k) - 1;
          h = h * h + 2 * j + i;
          if (!g-&gt;sm_list[h] || !g-&gt;sm_list[h]-&gt;sm) {
            idx = h;
            d2 = fff;
          } else if (idx == -1) {
            if (fff &lt; d2)
              d2 = fff;
          }
        }
      }
    }
  }
  if (found_dist2 != NULL)
    *found_dist2 = d2;
  return idx;
}
int verify_wall_regions_match(
    const char *mesh_name, struct string_buffer *prev_reg_names, struct wall *w,
    struct string_buffer *regions_to_ignore,
    struct mesh_transparency *mesh_transp, const char *species_name) {
  if ((mesh_name != NULL) &amp;&amp; (prev_reg_names != NULL)) {
    if (strcmp(w-&gt;parent_object-&gt;sym-&gt;name, mesh_name) != 0) {
      return 1;
    }
    struct name_list *wall_reg_names = NULL;
    wall_reg_names = find_regions_names_by_wall(w, regions_to_ignore);
    struct name_list *wrn = NULL;
    int i = 0;
    int still_inside = 0;
    for (char *prn = prev_reg_names-&gt;strings[i]; i &lt; prev_reg_names-&gt;n_strings; i++) {
      for (wrn = wall_reg_names; wrn != NULL; wrn = wrn-&gt;next) {
        if (strcmp(prn, wrn-&gt;name) == 0) {
          still_inside = 1;
          break;
        }
      }
      if (!still_inside) {
        struct mesh_transparency *mt = mesh_transp;
        for (; mt != NULL; mt = mt-&gt;next) {
          if ((strcmp(mt-&gt;name, prn) == 0) &amp;&amp;
              (!mt-&gt;transp_top_front || !mt-&gt;transp_top_back)) {
            if (wall_reg_names != NULL) {
              remove_molecules_name_list(&amp;wall_reg_names);
            }
            return 1;
          }
        }
      }
      still_inside = 0;
    }
    for (wrn = wall_reg_names; wrn != NULL; wrn = wrn-&gt;next) {
      if (is_string_present_in_string_array(
         wrn-&gt;name, regions_to_ignore-&gt;strings, regions_to_ignore-&gt;n_strings)) {
        continue;
      }
      if (!is_string_present_in_string_array(
          wrn-&gt;name, prev_reg_names-&gt;strings, prev_reg_names-&gt;n_strings)) {
        int cont = 0;
        struct mesh_transparency *mt = mesh_transp;
        for (; mt != NULL; mt = mt-&gt;next) {
          if (strcmp(mt-&gt;name, wrn-&gt;name) == 0) {
            if (mt-&gt;transp_top_front || mt-&gt;transp_top_back) {
              cont = 1;
              break;
            }
          }
        }
        if (cont) {
          continue;
        }
        remove_molecules_name_list(&amp;wall_reg_names);
        return 1;
      }
    }
    if (wall_reg_names != NULL) {
      remove_molecules_name_list(&amp;wall_reg_names);
    }
  }
  return 0;
}
struct wall *search_nbhd_for_free(struct volume *world, struct wall *origin,
                                  struct vector2 *point, double max_d2,
                                  int *found_idx,
                                  int (*ok)(void *, struct wall *),
                                  void *context, const char *mesh_name,
                                  struct string_buffer *reg_names) {
  struct wall *there = NULL;
  int i, j;
  double d2 = 0;
  struct vector2 pt, ed;
  struct vector2 vurt0, vurt1;
  int best_i;
  double best_d2;
  struct wall *best_w = NULL;
  best_i = -1;
  best_d2 = 2.0 * max_d2 + 1.0;
  if (origin-&gt;grid == NULL &amp;&amp; create_grid(world, origin, NULL))
    mcell_allocfailed("Failed to create grid for wall.");
  i = -1; 
  if (origin-&gt;grid-&gt;n_occupied &lt; origin-&gt;grid-&gt;n_tiles) {
    i = nearest_free(origin-&gt;grid, point, max_d2, &amp;d2);
  }
  if (i != -1) {
    best_i = i;
    best_d2 = d2;
    best_w = origin;
  }
  if (best_w == NULL) {
    for (j = 0; j &lt; 3; j++) {
      if (origin-&gt;edges[j] == NULL || origin-&gt;edges[j]-&gt;backward == NULL)
        continue;
      if (origin-&gt;edges[j]-&gt;forward == origin)
        there = origin-&gt;edges[j]-&gt;backward;
      else
        there = origin-&gt;edges[j]-&gt;forward;
      if (ok != NULL &amp;&amp; !(*ok)(context, there))
        continue; 
      if (verify_wall_regions_match(mesh_name, reg_names, there, NULL, NULL, NULL)) {
        continue; 
      }
      if (there-&gt;grid != NULL) {
        if (there-&gt;grid-&gt;n_occupied &gt;= there-&gt;grid-&gt;n_tiles) {
          continue;
        }
      }
      switch (j) {
      case 0:
        vurt0.u = vurt0.v = 0.0;
        vurt1.u = origin-&gt;uv_vert1_u;
        vurt1.v = 0;
        break;
      case 1:
        vurt0.u = origin-&gt;uv_vert1_u;
        vurt0.v = 0;
        memcpy(&amp;vurt1, &amp;(origin-&gt;uv_vert2), sizeof(struct vector2));
        break;
      case 2:
        memcpy(&amp;vurt0, &amp;(origin-&gt;uv_vert2), sizeof(struct vector2));
        vurt1.u = vurt1.v = 0.0;
        break;
      default:
        UNHANDLED_CASE(j);
      }
      ed.u = vurt1.u - vurt0.u;
      ed.v = vurt1.v - vurt0.v;
      pt.u = point-&gt;u - vurt0.u;
      pt.v = point-&gt;v - vurt0.v;
      d2 = pt.u * ed.u + pt.v * ed.v;
      d2 = (pt.u * pt.u + pt.v * pt.v) -
           d2 * d2 / (ed.u * ed.u + ed.v * ed.v); 
      if (d2 &lt; best_d2) {
        if (there-&gt;grid == NULL &amp;&amp; create_grid(world, there, NULL))
          mcell_allocfailed("Failed to create grid for wall.");
        traverse_surface(origin, point, j, &amp;pt);
        i = nearest_free(there-&gt;grid, &amp;pt, max_d2, &amp;d2);
        if (i != -1 &amp;&amp; d2 &lt; best_d2) {
          best_i = i;
          best_d2 = d2;
          best_w = there;
        }
      }
    }
  }
  *found_idx = best_i;
  return best_w;
}
void delete_tile_neighbor_list(struct tile_neighbor *head) {
  struct tile_neighbor *nnext;
  while (head != NULL) {
    nnext = head-&gt;next;
    free(head);
    head = nnext;
  }
}
void delete_region_list(struct region_list *head) {
  struct region_list *next;
  while (head != NULL) {
    next = head-&gt;next;
    free(head);
    head = next;
  }
}
void push_tile_neighbor_to_list(struct tile_neighbor **head,
                                struct surface_grid *grid, int idx) {
  struct tile_neighbor *old_head = *head;
  struct tile_neighbor *tile_nbr = CHECKED_MALLOC_STRUCT(struct tile_neighbor,
                                                         "tile_neighbor");
  tile_nbr-&gt;grid = grid;
  tile_nbr-&gt;flag = 0;
  tile_nbr-&gt;idx = idx;
  if (old_head == NULL) {
    tile_nbr-&gt;next = NULL;
    old_head = tile_nbr;
  } else {
    tile_nbr-&gt;next = old_head;
    old_head = tile_nbr;
  }
  *head = old_head;
}
int push_tile_neighbor_to_list_with_checking(struct tile_neighbor **head,
                                             struct surface_grid *grid,
                                             int idx) {
  struct tile_neighbor *tile_nbr, *old_head;
  old_head = *head;
  for (tile_nbr = old_head; tile_nbr != NULL; tile_nbr = tile_nbr-&gt;next) {
    if ((tile_nbr-&gt;grid == grid) &amp;&amp; (tile_nbr-&gt;idx == (u_int)idx))
      return 0;
  }
  tile_nbr = CHECKED_MALLOC_STRUCT(struct tile_neighbor, "tile_neighbor");
  tile_nbr-&gt;grid = grid;
  tile_nbr-&gt;flag = 0;
  tile_nbr-&gt;idx = idx;
  if (old_head == NULL) {
    tile_nbr-&gt;next = NULL;
    old_head = tile_nbr;
  } else {
    tile_nbr-&gt;next = old_head;
    old_head = tile_nbr;
  }
  *head = old_head;
  return 1;
}
int get_tile_neighbor_from_list_of_vacant_neighbors(struct tile_neighbor *head,
  int list_index, struct surface_grid **grid, int *tile_idx) {
  struct tile_neighbor *curr = head;
  int iter = 0;    int count = 0; 
  while (curr != NULL) {
    if ((curr-&gt;flag &amp; TILE_CHECKED) == 0) {
      count++;
    }
    if ((iter == list_index) &amp;&amp; ((curr-&gt;flag &amp; TILE_CHECKED) == 0)) {
      curr-&gt;flag |= TILE_CHECKED;
      *grid = curr-&gt;grid;
      *tile_idx = curr-&gt;idx;
    }
    iter++;
    curr = curr-&gt;next;
  }
  return count;
}
void uncheck_vacant_tile(struct tile_neighbor *head, int list_index) {
  struct tile_neighbor *curr = head;
  int iter = 0; 
  while (curr != NULL) {
    if ((iter == list_index) &amp;&amp; (curr-&gt;flag &amp; TILE_CHECKED)) {
      curr-&gt;flag &amp;= ~TILE_CHECKED;
    }
    iter++;
    curr = curr-&gt;next;
  }
}
void get_tile_vertices(struct surface_grid *sg, int idx, int *flp,
                       struct vector2 *R, struct vector2 *S,
                       struct vector2 *T) {
  int strip, stripe, flip;
  int root, rootrem;
  struct vector2 P, Q, X, Y;
  double pq, xy;
  double cot_angle;
  root = (int)(sqrt((double)idx));
  rootrem = idx - root * root;
  strip = sg-&gt;n - root - 1;
  stripe = rootrem / 2;
  flip = rootrem - 2 * stripe;
  P.v = Q.v = strip / sg-&gt;inv_strip_wid;
  X.v = Y.v = (strip + 1) / sg-&gt;inv_strip_wid;
  P.u = (P.v) * (sg-&gt;vert2_slope);
  X.u = (X.v) * (sg-&gt;vert2_slope);
  cot_angle = (sg-&gt;surface-&gt;uv_vert1_u - sg-&gt;surface-&gt;uv_vert2.u) /
              (sg-&gt;surface-&gt;uv_vert2.v);
  Q.u = sg-&gt;surface-&gt;uv_vert1_u - (Q.v) * cot_angle;
  Y.u = sg-&gt;surface-&gt;uv_vert1_u - (Y.v) * cot_angle;
  pq = Q.u - P.u;
  if (idx == 0) {
    xy = 0;
  } else {
    xy = Y.u - X.u;
  }
  if (flip == 1) {
    R-&gt;v = P.v;
    R-&gt;u = P.u + pq * (stripe + 1) / (sg-&gt;n - strip);
    S-&gt;v = T-&gt;v = X.v;
    T-&gt;u = X.u + xy * stripe / (sg-&gt;n - strip - 1);
    S-&gt;u = X.u + xy * (stripe + 1) / (sg-&gt;n - strip - 1);
  } else {
    R-&gt;v = S-&gt;v = P.v;
    T-&gt;v = X.v;
    R-&gt;u = P.u + pq * stripe / (sg-&gt;n - strip);
    S-&gt;u = P.u + pq * (stripe + 1) / (sg-&gt;n - strip);
    if (idx == 0) {
      T-&gt;u = X.u;
    } else {
      T-&gt;u = X.u + xy * stripe / (sg-&gt;n - strip - 1);
    }
  }
  *flp = flip;
}
int tile_orientation(struct vector2 *v, struct surface_grid *g) {
  double i, j;
  double u0, u1_u0;
  double striploc, striprem, stripeloc, striperem;
  int strip, stripe, flip;
  i = v-&gt;u;
  j = v-&gt;v;
  striploc = j * g-&gt;inv_strip_wid;
  strip = (int)striploc;
  striprem = striploc - strip;
  strip = g-&gt;n - strip - 1;
  u0 = j * g-&gt;vert2_slope;
  u1_u0 = g-&gt;surface-&gt;uv_vert1_u - j * g-&gt;fullslope;
  stripeloc = ((i - u0) / u1_u0) * (((double)strip) + (1.0 - striprem));
  stripe = (int)(stripeloc);
  striperem = stripeloc - stripe;
  flip = (striperem &lt; 1.0 - striprem) ? 0 : 1;
  return flip;
}
void grid_all_neighbors_for_inner_tile(
    struct volume *world, struct surface_grid *grid, int idx,
    struct vector2 *pos, struct tile_neighbor **tile_neighbor_head,
    int *list_length) {
  struct tile_neighbor *tile_nbr_head = NULL;
  int count = 0;
  int vert_nbr_ind = -1;
  int kk;
  struct surface_grid *sg[3];   int si[3]; 
  if ((u_int)idx &gt;= grid-&gt;n_tiles) {
    mcell_internal_error(
        "Surface molecule tile index is greater than or equal of "
        "the number of tiles on the grid\n");
  }
  for (kk = 0; kk &lt; 3; kk++) {
    sg[kk] = NULL;
    si[kk] = -1;
  }
  grid_neighbors(world, grid, idx, 0, sg, si);
  if ((grid != sg[0]) || (grid != sg[1]) || (grid != sg[2])) {
    mcell_internal_error("The function 'grid_all_neighbors_for_inner_tile()' "
                         "is called for the tile %d that is not an inner tile.",
                         idx);
  }
  for (kk = 0; kk &lt; 3; kk++) {
    if ((si[kk] != idx - 1) &amp;&amp; (si[kk] != idx + 1)) {
      vert_nbr_ind = si[kk];
      break;
    }
  }
  push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 1);
  count++;
  push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 2);
  count++;
  push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 1);
  count++;
  push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 2);
  count++;
  int tile_orient = tile_orientation(pos, grid);
  int temp_ind;
  if (tile_orient == 0) {
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind - 1);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind - 2);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind + 1);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind + 2);
    count++;
    temp_ind = move_strip_down(grid, idx);
    if (temp_ind == -1) {
      mcell_internal_error("The function 'grid_all_neighbors_for_inner_tile() "
                           "is called for the tile %d that is not an inner "
                           "tile.",
                           idx);
    }
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_ind);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_ind - 1);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_ind + 1);
    count++;
  } else {
    temp_ind = move_strip_up(grid, idx);
    if (temp_ind == -1) {
      mcell_internal_error("The function 'grid_all_neighbors_for_inner_tile() "
                           "is called for the tile %d that is not an inner "
                           "tile.",
                           idx);
    }
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_ind);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_ind - 1);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_ind + 1);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind - 1);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind - 2);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind + 1);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind + 2);
    count++;
  }
  if (count != 12) {
    mcell_internal_error("The function 'grid_all_neighbors_for_inner_tile() is "
                         "called for the tile %d that is not an inner tile.",
                         idx);
  } else {
    *list_length = count;
  }
  *tile_neighbor_head = tile_nbr_head;
}
void grid_all_neighbors_across_walls_through_vertices(
    struct volume *world, struct surface_molecule *sm,
    struct wall_list *wall_nbr_head, struct surface_grid *grid,
    int create_grid_flag, int search_for_reactant,
    struct tile_neighbor **tile_neighbor_head, int *list_length) {
  struct tile_neighbor *tile_nbr_head = NULL;
  struct wall_list *wl;
  struct wall *w;
  long long origin_vert_indices[3], nbr_vert_indices[3];
  int i, k;
  int tiles_count = 0;   struct region_list *rlp_head_own_wall = NULL;
  struct region_list *rlp_head_nbr_wall;
  if ((sm != NULL) &amp;&amp; (sm-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER)) {
    rlp_head_own_wall =
        find_restricted_regions_by_wall(world, sm-&gt;grid-&gt;surface, sm);
  }
  for (wl = wall_nbr_head; wl != NULL; wl = wl-&gt;next) {
    w = wl-&gt;this_wall;
    rlp_head_nbr_wall = NULL;
    if (w-&gt;grid == NULL) {
      if (create_grid_flag) {
        if (create_grid(world, w, NULL))
          mcell_allocfailed("Failed to allocate grid for wall.");
      } else {
        continue;
      }
    }
    if (search_for_reactant &amp;&amp; (rlp_head_own_wall != NULL)) {
      if (!wall_belongs_to_all_regions_in_region_list(w, rlp_head_own_wall))
        continue;
    }
    if (sm != NULL) {
      if (search_for_reactant &amp;&amp; (sm-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER)) {
        rlp_head_nbr_wall = find_restricted_regions_by_wall(world, w, sm);
        if (rlp_head_nbr_wall != NULL) {
          if (!wall_belongs_to_all_regions_in_region_list(sm-&gt;grid-&gt;surface,
                                                          rlp_head_nbr_wall)) {
            delete_void_list((struct void_list *)rlp_head_nbr_wall);
            continue;
          } else {
            delete_void_list((struct void_list *)rlp_head_nbr_wall);
          }
        }
      }
    }
    if (w-&gt;grid-&gt;n_tiles == 1) {
      nbr_tile_idx = 0;
    } else {
      nbr_wall_vertex_id = -1;
      nbr_tile_idx = -1;
      for (i = 0; i &lt; 3; i++) {
        origin_vert_indices[i] = (long long)(grid-&gt;surface-&gt;vert[i] - world-&gt;all_vertices);
      }
      for (i = 0; i &lt; 3; i++) {
        nbr_vert_indices[i] = (long long)(w-&gt;grid-&gt;surface-&gt;vert[i] - world-&gt;all_vertices);
      }
      for (i = 0; i &lt; 3; i++) {
        for (k = 0; k &lt; 3; k++) {
          if (origin_vert_indices[i] == nbr_vert_indices[k]) {
            nbr_wall_vertex_id = nbr_vert_indices[k];
            break;
          }
        }
      }
      if (nbr_wall_vertex_id == -1)
        mcell_internal_error("Error identifying tile on the neighbor wall.");
      if (&amp;world-&gt;all_vertices[nbr_wall_vertex_id] ==
          w-&gt;grid-&gt;surface-&gt;vert[0]) {
        nbr_tile_idx = w-&gt;grid-&gt;n_tiles - 2 * (w-&gt;grid-&gt;n) + 1;
      } else if (&amp;world-&gt;all_vertices[nbr_wall_vertex_id] ==
                 w-&gt;grid-&gt;surface-&gt;vert[1]) {
        nbr_tile_idx = w-&gt;grid-&gt;n_tiles - 1;
      } else if (&amp;world-&gt;all_vertices[nbr_wall_vertex_id] ==
                 w-&gt;grid-&gt;surface-&gt;vert[2]) {
        nbr_tile_idx = 0;
      }
      if (nbr_tile_idx == -1)
        mcell_internal_error("Error identifying tile on the neighbor wall.");
    }
    push_tile_neighbor_to_list(&amp;tile_nbr_head, w-&gt;grid, nbr_tile_idx);
    tiles_count++;
  }
  *list_length = tiles_count;
  *tile_neighbor_head = tile_nbr_head;
  if (rlp_head_own_wall != NULL)
    delete_void_list((struct void_list *)rlp_head_own_wall);
}
void grid_all_neighbors_across_walls_through_edges(
    struct volume *world, struct surface_molecule *sm,
    struct surface_grid *grid, int idx, int create_grid_flag,
    int search_for_reactant, struct tile_neighbor **tile_neighbor_head,
    int *list_length) {
  struct tile_neighbor *tile_nbr_head = NULL;
  int tiles_count = 0;
  int kk;
  int root, rootrem, strip, stripe, flip;
<a name="1"></a>  int temp_idx;
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  struct region_list *rlp_head_own_wall = NULL;
  struct region_list *rlp_head_nbr_wall_0 = NULL;
  struct region_list *rlp_head_nbr_wall_1 = NULL;
  struct region_list *rlp_head_nbr_wall_2 = NULL;</b></font>
  int move_thru_border_0 = 1;
  int move_thru_border_1 = 1;
  int move_thru_border_2 = 1;
  if ((sm != NULL) &amp;&amp; search_for_reactant &amp;&amp;
      (sm-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER)) {
    rlp_head_own_wall =
        find_restricted_regions_by_wall(world, sm-&gt;grid-&gt;surface, sm);
    if (sm-&gt;grid-&gt;surface-&gt;nb_walls[0] != NULL) {
      rlp_head_nbr_wall_0 = find_restricted_regions_by_wall(
          world, sm-&gt;grid-&gt;surface-&gt;nb_walls[0], sm);
      if (rlp_head_own_wall != NULL) {
        if (!wall_belongs_to_all_regions_in_region_list(
                 sm-&gt;grid-&gt;surface-&gt;nb_walls[0], rlp_head_own_wall))
          move_thru_border_0 = 0;
      }
      if (rlp_head_nbr_wall_0 != NULL) {
        if (!wall_belongs_to_all_regions_in_region_list(sm-&gt;grid-&gt;surface,
                                                        rlp_head_nbr_wall_0))
          move_thru_border_0 = 0;
      }
      if (rlp_head_nbr_wall_0 != NULL)
        delete_void_list((struct void_list *)rlp_head_nbr_wall_0);
    } else {
      move_thru_border_0 = 0;
    }
    if (sm-&gt;grid-&gt;surface-&gt;nb_walls[1] != NULL) {
      rlp_head_nbr_wall_1 = find_restricted_regions_by_wall(
          world, sm-&gt;grid-&gt;surface-&gt;nb_walls[1], sm);
      if (rlp_head_own_wall != NULL) {
        if (!wall_belongs_to_all_regions_in_region_list(
                 sm-&gt;grid-&gt;surface-&gt;nb_walls[1], rlp_head_own_wall))
          move_thru_border_1 = 0;
      }
      if (rlp_head_nbr_wall_1 != NULL) {
        if (!wall_belongs_to_all_regions_in_region_list(sm-&gt;grid-&gt;surface,
                                                        rlp_head_nbr_wall_1))
          move_thru_border_1 = 0;
      }
      if (rlp_head_nbr_wall_1 != NULL)
        delete_void_list((struct void_list *)rlp_head_nbr_wall_1);
    } else {
      move_thru_border_1 = 0;
    }
    if (sm-&gt;grid-&gt;surface-&gt;nb_walls[2] != NULL) {
      rlp_head_nbr_wall_2 = find_restricted_regions_by_wall(
          world, sm-&gt;grid-&gt;surface-&gt;nb_walls[2], sm);
      if (rlp_head_own_wall != NULL) {
        if (!wall_belongs_to_all_regions_in_region_list(
                 sm-&gt;grid-&gt;surface-&gt;nb_walls[2], rlp_head_own_wall))
          move_thru_border_2 = 0;
      }
      if (rlp_head_nbr_wall_2 != NULL) {
        if (!wall_belongs_to_all_regions_in_region_list(sm-&gt;grid-&gt;surface,
                                                        rlp_head_nbr_wall_2))
          move_thru_border_2 = 0;
      }
      if (rlp_head_nbr_wall_2 != NULL)
        delete_void_list((struct void_list *)rlp_head_nbr_wall_2);
    } else {
      move_thru_border_2 = 0;
    }
    if (rlp_head_own_wall != NULL)
      delete_void_list((struct void_list *)rlp_head_own_wall);
  }
  if ((u_int)idx &gt;= grid-&gt;n_tiles) {
    mcell_internal_error("Surface molecule tile index %u is greater than or "
                         "equal of the number of tiles on the grid %u\n",
                         (u_int)idx, grid-&gt;n_tiles);
  }
  root = (int)(sqrt((double)idx));
  rootrem = idx - root * root;
  strip = grid-&gt;n - root - 1;
  stripe = rootrem / 2;
  flip = rootrem - 2 * stripe;
  if (create_grid_flag) {
    for (kk = 0; kk &lt; 3; kk++) {
      if ((grid-&gt;surface-&gt;nb_walls[kk] != NULL) &amp;&amp;
          (grid-&gt;surface-&gt;nb_walls[kk]-&gt;grid == NULL)) {
        if (create_grid(world, grid-&gt;surface-&gt;nb_walls[kk], NULL))
          mcell_allocfailed("Failed to create grid for wall.");
      }
    }
  }
  if (stripe == 0) {
    if (flip &gt; 0)     {
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 1);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 1);
      tiles_count++;
      if (strip &lt; grid-&gt;n - 2) {
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 2);
        tiles_count++;
      }
      temp_idx = move_strip_down(grid, idx);
      if (temp_idx == -1) {
        mcell_internal_error("Error in navigating on the grid");
      }
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
      tiles_count++;
      if (strip &lt; grid-&gt;n - 2) {
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 1);
        tiles_count++;
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 2);
        tiles_count++;
      }
      if (strip &gt; 0) {
        temp_idx = move_strip_up(grid, idx);
        if (temp_idx == -1) {
          mcell_internal_error("Error in navigating on the grid");
        }
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
        tiles_count++;
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 1);
        tiles_count++;
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 1);
        tiles_count++;
      }
      if ((grid-&gt;surface-&gt;nb_walls[2] != NULL) &amp;&amp;
          (grid-&gt;surface-&gt;nb_walls[2]-&gt;grid != NULL)) {
        if (move_thru_border_2) {
          tiles_added = add_more_tile_neighbors_to_list_fast(
              &amp;tile_nbr_head, grid, strip, stripe, flip, grid-&gt;surface-&gt;vert[0],
              grid-&gt;surface-&gt;vert[2], 2, grid-&gt;surface-&gt;nb_walls[2]-&gt;grid);
          tiles_count += tiles_added;
        }
      }
      if (strip == 0) {
        if ((grid-&gt;surface-&gt;nb_walls[0] != NULL) &amp;&amp;
            (grid-&gt;surface-&gt;nb_walls[0]-&gt;grid != NULL)) {
          if (move_thru_border_0) {
            tiles_added = add_more_tile_neighbors_to_list_fast(
                &amp;tile_nbr_head, grid, strip, stripe, flip,
                grid-&gt;surface-&gt;vert[0], grid-&gt;surface-&gt;vert[1], 0,
                grid-&gt;surface-&gt;nb_walls[0]-&gt;grid);
            tiles_count += tiles_added;
          }
        }
      }
      if (strip == (grid-&gt;n - 2)) {
        if ((grid-&gt;surface-&gt;nb_walls[1] != NULL) &amp;&amp;
            (grid-&gt;surface-&gt;nb_walls[1]-&gt;grid != NULL)) {
          if (move_thru_border_1) {
            tiles_added = add_more_tile_neighbors_to_list_fast(
                &amp;tile_nbr_head, grid, strip, stripe, flip,
                grid-&gt;surface-&gt;vert[1], grid-&gt;surface-&gt;vert[2], 1,
                grid-&gt;surface-&gt;nb_walls[1]-&gt;grid);
            tiles_count += tiles_added;
          }
        }
      }
    } else {              if (idx == 0)       {
        if (grid-&gt;n_tiles &gt; 1) {
          temp_idx = move_strip_up(grid, idx);
          if (temp_idx == -1) {
            mcell_internal_error("Error in navigating on the grid");
          }
          push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
          tiles_count++;
          push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 1);
          tiles_count++;
          push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 1);
          tiles_count++;
        } else {
          if ((grid-&gt;surface-&gt;nb_walls[0] != NULL) &amp;&amp;
              (grid-&gt;surface-&gt;nb_walls[0]-&gt;grid != NULL)) {
            if (move_thru_border_0) {
              tiles_added = add_more_tile_neighbors_to_list_fast(
                  &amp;tile_nbr_head, grid, strip, stripe, flip,
                  grid-&gt;surface-&gt;vert[0], grid-&gt;surface-&gt;vert[1], 0,
                  grid-&gt;surface-&gt;nb_walls[0]-&gt;grid);
              tiles_count += tiles_added;
            }
          }
        }
        if ((grid-&gt;surface-&gt;nb_walls[1] != NULL) &amp;&amp;
            (grid-&gt;surface-&gt;nb_walls[1]-&gt;grid != NULL)) {
          if (move_thru_border_1) {
            tiles_added = add_more_tile_neighbors_to_list_fast(
                &amp;tile_nbr_head, grid, strip, stripe, flip,
                grid-&gt;surface-&gt;vert[1], grid-&gt;surface-&gt;vert[2], 1,
                grid-&gt;surface-&gt;nb_walls[1]-&gt;grid);
            tiles_count += tiles_added;
          }
        }
        if ((grid-&gt;surface-&gt;nb_walls[2] != NULL) &amp;&amp;
            (grid-&gt;surface-&gt;nb_walls[2]-&gt;grid != NULL)) {
          if (move_thru_border_2) {
            tiles_added = add_more_tile_neighbors_to_list_fast(
                &amp;tile_nbr_head, grid, strip, stripe, flip,
                grid-&gt;surface-&gt;vert[0], grid-&gt;surface-&gt;vert[2], 2,
                grid-&gt;surface-&gt;nb_walls[2]-&gt;grid);
            tiles_count += tiles_added;
          }
        }
      } else { 
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 1);
        tiles_count++;
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 2);
        tiles_count++;
        temp_idx = move_strip_down(grid, idx + 1);
        if (temp_idx == -1) {
          mcell_internal_error("Error in navigating on the grid");
        }
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
        tiles_count++;
        if (strip &gt; 0) {
          temp_idx = move_strip_up(grid, idx);
          if (temp_idx == -1) {
            mcell_internal_error("Error in navigating on the grid");
          }
          push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
          tiles_count++;
          push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 1);
          tiles_count++;
          push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 1);
          tiles_count++;
          push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 2);
          tiles_count++;
          if ((grid-&gt;surface-&gt;nb_walls[0] != NULL) &amp;&amp;
              (grid-&gt;surface-&gt;nb_walls[0]-&gt;grid != NULL)) {
            if (move_thru_border_0) {
              tiles_added = add_more_tile_neighbors_to_list_fast(
                  &amp;tile_nbr_head, grid, strip, stripe, flip,
                  grid-&gt;surface-&gt;vert[0], grid-&gt;surface-&gt;vert[1], 0,
                  grid-&gt;surface-&gt;nb_walls[0]-&gt;grid);
              tiles_count += tiles_added;
            }
          }
          if ((grid-&gt;surface-&gt;nb_walls[2] != NULL) &amp;&amp;
              (grid-&gt;surface-&gt;nb_walls[2]-&gt;grid != NULL)) {
            if (move_thru_border_2) {
              tiles_added = add_more_tile_neighbors_to_list_fast(
                  &amp;tile_nbr_head, grid, strip, stripe, flip,
                  grid-&gt;surface-&gt;vert[0], grid-&gt;surface-&gt;vert[2], 2,
                  grid-&gt;surface-&gt;nb_walls[2]-&gt;grid);
              tiles_count += tiles_added;
            }
          }
        }
      } 
    } 
  } 
  if ((strip == 0) &amp;&amp; (stripe &gt; 0)) {
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 1);
    tiles_count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 2);
    tiles_count++;
    if ((stripe &lt; grid-&gt;n - 2) || ((stripe == grid-&gt;n - 2) &amp;&amp; (flip == 0))) {
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 1);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 2);
      tiles_count++;
    } else if ((stripe == grid-&gt;n - 2) &amp;&amp; (flip == 1)) {
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 1);
      tiles_count++;
    }
    if (flip &gt; 0) {
      temp_idx = move_strip_down(grid, idx);
      if (temp_idx == -1) {
        mcell_internal_error("Error in navigating on the grid");
      }
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 1);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 2);
      tiles_count++;
      if (stripe &lt; grid-&gt;n - 2) {
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 1);
        tiles_count++;
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 2);
        tiles_count++;
      }
    } else {       if ((unsigned int)idx &lt; grid-&gt;n_tiles - 1) {
        temp_idx = move_strip_down(grid, idx);
        if (temp_idx == -1) {
          mcell_internal_error("Error in navigating on the grid");
        }
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
        tiles_count++;
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 1);
        tiles_count++;
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 1);
        tiles_count++;
      } else {
        temp_idx = move_strip_down(grid, idx - 1);
        if (temp_idx == -1) {
          mcell_internal_error("Error in navigating on the grid");
        }
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
        tiles_count++;
      }
    }
    if ((grid-&gt;surface-&gt;nb_walls[0] != NULL) &amp;&amp;
        (grid-&gt;surface-&gt;nb_walls[0]-&gt;grid != NULL)) {
      if (move_thru_border_0) {
        tiles_added = add_more_tile_neighbors_to_list_fast(
            &amp;tile_nbr_head, grid, strip, stripe, flip, grid-&gt;surface-&gt;vert[0],
            grid-&gt;surface-&gt;vert[1], 0, grid-&gt;surface-&gt;nb_walls[0]-&gt;grid);
        tiles_count += tiles_added;
      }
    }
    if (((u_int)idx == (grid-&gt;n_tiles - 1)) ||
        ((u_int)idx == (grid-&gt;n_tiles - 2))) {
      if ((grid-&gt;surface-&gt;nb_walls[1] != NULL) &amp;&amp;
          (grid-&gt;surface-&gt;nb_walls[1]-&gt;grid != NULL)) {
        if (move_thru_border_1) {
          tiles_added = add_more_tile_neighbors_to_list_fast(
              &amp;tile_nbr_head, grid, strip, stripe, flip, grid-&gt;surface-&gt;vert[1],
              grid-&gt;surface-&gt;vert[2], 1, grid-&gt;surface-&gt;nb_walls[1]-&gt;grid);
          tiles_count += tiles_added;
        }
      }
    }
  } 
  if ((strip &gt; 0) &amp;&amp; (stripe &gt; 0)) {
    if (flip &gt; 0) {
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 1);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 2);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 1);
      tiles_count++;
      temp_idx = move_strip_up(grid, idx);
      if (temp_idx == -1) {
        mcell_internal_error("Error in navigating on the grid");
      }
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 1);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 1);
      tiles_count++;
      temp_idx = move_strip_down(grid, idx);
      if (temp_idx == -1) {
        mcell_internal_error("Error in navigating on the grid");
      }
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 1);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 2);
      tiles_count++;
    } else { 
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 1);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 2);
      tiles_count++;
      temp_idx = move_strip_up(grid, idx);
      if (temp_idx == -1) {
        mcell_internal_error("Error in navigating on the grid");
      }
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 1);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 2);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 1);
      tiles_count++;
      temp_idx = move_strip_down(grid, idx - 1);
      if (temp_idx == -1) {
        mcell_internal_error("Error in navigating on the grid");
      }
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
      tiles_count++;
    }
    if ((grid-&gt;surface-&gt;nb_walls[1] != NULL) &amp;&amp;
        (grid-&gt;surface-&gt;nb_walls[1]-&gt;grid != NULL)) {
      if (move_thru_border_1) {
        tiles_added = add_more_tile_neighbors_to_list_fast(
            &amp;tile_nbr_head, grid, strip, stripe, flip, grid-&gt;surface-&gt;vert[1],
            grid-&gt;surface-&gt;vert[2], 1, grid-&gt;surface-&gt;nb_walls[1]-&gt;grid);
        tiles_count += tiles_added;
      }
    }
  } 
  *list_length = tiles_count;
  *tile_neighbor_head = tile_nbr_head;
}
int add_more_tile_neighbors_to_list_fast(struct tile_neighbor **tile_nbr_head,
                                         struct surface_grid *orig_grid,
                                         int orig_strip, int orig_stripe,
                                         int orig_flip, struct vector3 *start,
                                         struct vector3 *end, int edge_index,
                                         struct surface_grid *new_grid) {
  double orig_pos_1 = -1, orig_pos_2 = -1;
  const int new_pos_size = new_grid-&gt;n + 1;
  std::vector&lt;double&gt; new_pos(new_pos_size);
  std::vector&lt;std::vector&lt;int&gt;&gt; new_tile_idx(new_pos_size);
  for (auto&amp; elem: new_tile_idx) {
    elem.resize(3);
  }
  int i, k;
  int shared_vert_1 = -1, shared_vert_2 = -1;
  int new_start_index, new_end_index;
  int tiles_added = 0; 
  if (orig_grid == new_grid) {
    mcell_internal_error("Function 'add_more_tile_neighbors_to_list()' should "
                         "be called for different grids only");
  }
  edge_length = distance_vec3(start, end);
  if (orig_stripe == 0) {
    if (orig_strip &gt; 0) {
      if (orig_flip == 0) {
        orig_pos_1 = orig_strip * edge_length / (orig_grid-&gt;n);
        orig_pos_2 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
      } else {         orig_pos_1 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
      }
    } else {
      if (edge_index == 0) {
        if (orig_flip == 0) {
          orig_pos_1 = orig_stripe * edge_length / (orig_grid-&gt;n);
          orig_pos_2 = (orig_stripe + 1) * edge_length / (orig_grid-&gt;n);
        } else { <a name="0"></a>          orig_pos_1 = (orig_stripe + 1) * edge_length / (orig_grid-&gt;n);
        }
      } else if (edge_index == 1) {
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        if (orig_flip == 0) {
          orig_pos_1 = (orig_strip) * edge_length / (orig_grid-&gt;n);
        } else {           orig_pos_1 = orig_strip * edge_length / (orig_grid-&gt;n);
          orig_pos_2 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
        }
      } else if (edge_index == 2) {</b></font>
        if (orig_flip == 0) {
          orig_pos_1 = orig_strip * edge_length / (orig_grid-&gt;n);
          orig_pos_2 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
        } else {           orig_pos_1 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
        }
      } else {
        mcell_internal_error(
            "Error in the function 'add_more_tile_neighbors_to_list_fast()'.");
      }
    }
  }
  check_side_flag = 0;
  if ((orig_strip == 0) &amp;&amp; (orig_stripe &gt; 0)) {
    if (orig_stripe == orig_grid-&gt;n - 1)
      check_side_flag = 1;
    if ((orig_stripe == orig_grid-&gt;n - 2) &amp;&amp; (orig_flip == 1))
      check_side_flag = 1;
    if (!check_side_flag) {
      if (orig_flip == 0) {
        orig_pos_1 = orig_stripe * edge_length / (orig_grid-&gt;n);
        orig_pos_2 = (orig_stripe + 1) * edge_length / (orig_grid-&gt;n);
      } else {         orig_pos_1 = (orig_stripe + 1) * edge_length / (orig_grid-&gt;n);
      }
    } else {
      if (edge_index == 0) {
        if (orig_flip == 0) {
          orig_pos_1 = orig_stripe * edge_length / (orig_grid-&gt;n);
          orig_pos_2 = (orig_stripe + 1) * edge_length / (orig_grid-&gt;n);
        } else {           orig_pos_1 = (orig_stripe + 1) * edge_length / (orig_grid-&gt;n);
        }
      } else if (edge_index == 1) {
        if (orig_flip == 0) {
          orig_pos_1 = orig_strip * edge_length / (orig_grid-&gt;n);
          orig_pos_2 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
        } else {           orig_pos_1 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
        }
      } else {
        mcell_internal_error(
            "Error in the function 'add_more_tile_neighbors_to_list_fast()'.");
      }
    }
  }
  if ((orig_strip &gt; 0) &amp;&amp; (orig_stripe &gt; 0)) {
    if (orig_flip == 0) {
      orig_pos_1 = orig_strip * edge_length / (orig_grid-&gt;n);
      orig_pos_2 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
    } else {       orig_pos_1 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
    }
  }
  find_shared_vertices_for_neighbor_walls(orig_grid-&gt;surface, new_grid-&gt;surface,
                                          &amp;shared_vert_1, &amp;shared_vert_2);
  if (!distinguishable_vec3(start, new_grid-&gt;surface-&gt;vert[shared_vert_1],
                            EPS_C)) {
    new_start_index = shared_vert_1;
    new_end_index = shared_vert_2;
  } else {
    new_start_index = shared_vert_2;
    new_end_index = shared_vert_1;
  }
  if (new_start_index &gt; new_end_index)
    invert_orig_pos = 1;
  if (invert_orig_pos) {
    orig_pos_1 = edge_length - orig_pos_1;
    if (orig_pos_2 &gt; 0) {
      orig_pos_2 = edge_length - orig_pos_2;
    }
  }
  for (i = 0; i &lt; new_pos_size; i++) {
    new_pos[i] = i * edge_length / (new_grid-&gt;n);
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  }
  int new_edge_index = 0;
  if ((shared_vert_1 + shared_vert_2) == 1) {
    new_edge_index = 0;
  } else if ((shared_vert_1 + shared_vert_2) == 2) {
    new_edge_index = 2;
  } else if ((shared_vert_1 + shared_vert_2) == 3) {</b></font>
    new_edge_index = 1;
  } else {
    mcell_internal_error(
        "Error in the function 'add_more_tile_neighbors_to_list_fast()'.");
  }
  int last_value;
  if (new_edge_index == 0) {
    new_tile_idx[0][0] = -1;
    new_tile_idx[0][1] = -1;
    new_tile_idx[0][2] = new_grid-&gt;n_tiles - 2 * (new_grid-&gt;n) + 1;
    last_value = new_tile_idx[0][2];
    for (i = 1; i &lt; new_pos_size - 1; i++) {
      for (k = 0; k &lt; 3; k++) {
        new_tile_idx[i][k] = last_value + k;
      }
      last_value = new_tile_idx[i][2];
    }
    new_tile_idx[new_pos_size - 1][0] = last_value;
    new_tile_idx[new_pos_size - 1][1] = -1;
    new_tile_idx[new_pos_size - 1][2] = -1;
  } else if (new_edge_index == 1) {
    new_tile_idx[0][0] = -1;
    new_tile_idx[0][1] = -1;
    new_tile_idx[0][2] = new_grid-&gt;n_tiles - 1;
    last_value = new_tile_idx[0][2];
    for (i = 1; i &lt; new_pos_size - 1; i++) {
      for (k = 0; k &lt; 2; k++) {
        new_tile_idx[i][k] = last_value - k;
      }
      last_value = new_tile_idx[i][1];
      new_tile_idx[i][2] = move_strip_down(new_grid, last_value);
      last_value = new_tile_idx[i][2];
    }
    new_tile_idx[new_pos_size - 1][0] = last_value;
    new_tile_idx[new_pos_size - 1][1] = -1;
    new_tile_idx[new_pos_size - 1][2] = -1;
  } else {     new_tile_idx[0][0] = -1;
    new_tile_idx[0][1] = -1;
    new_tile_idx[0][2] = new_grid-&gt;n_tiles - 2 * (new_grid-&gt;n) + 1;
    last_value = new_tile_idx[0][2];
    for (i = 1; i &lt; new_pos_size - 1; i++) {
      for (k = 0; k &lt; 2; k++) {
        new_tile_idx[i][k] = last_value + k;
      }
      last_value = new_tile_idx[i][1];
      new_tile_idx[i][2] = move_strip_down(new_grid, last_value);
      last_value = new_tile_idx[i][2];
    }
    new_tile_idx[new_pos_size - 1][0] = last_value;
    new_tile_idx[new_pos_size - 1][1] = -1;
    new_tile_idx[new_pos_size - 1][2] = -1;
  }
  int ind_high, ind_low = -1;
  if (orig_pos_1 &gt; orig_pos_2) {
    ind_high = bisect_high(&amp;new_pos[0], new_pos_size, orig_pos_1);
    if (orig_pos_2 &gt; 0) {
      ind_low = bisect(&amp;new_pos[0], new_pos_size, orig_pos_2);
    }
  } else {
    ind_high = bisect_high(&amp;new_pos[0], new_pos_size, orig_pos_2);
    if (orig_pos_1 &gt; 0) {
      ind_low = bisect(&amp;new_pos[0], new_pos_size, orig_pos_1);
    }
  }
  if (ind_low &gt;= 0) {
    for (i = ind_low + 1; i &lt; ind_high; i++) {
      for (k = 0; k &lt; 3; k++) {
        if (push_tile_neighbor_to_list_with_checking(tile_nbr_head, new_grid,
                                                     new_tile_idx[i][k]))
          tiles_added++;
      }
    }
  } else {
    if (push_tile_neighbor_to_list_with_checking(tile_nbr_head, new_grid,
                                                 new_tile_idx[ind_high][0]))
      tiles_added++;
  }
  return tiles_added;
}
void find_closest_position(struct surface_grid *grid1, int idx1,
                           struct surface_grid *grid2, int idx2,
                           struct vector2 *p) {
  struct vector2 R, S, T;
  struct vector3 R_3d, S_3d, T_3d;
  struct vector2 A, B, C;
  struct vector3 A_3d, B_3d, C_3d;
  struct vector2 A_new, B_new, C_new;
  double k1 = 1e-10;   double k2 = 1;
  int flip1;   int flip2; 
  int num_exact_shared_vertices = 0;
  int R_shared = 0, S_shared = 0, T_shared = 0;
  int A_shared = 0, B_shared = 0, C_shared = 0;
  get_tile_vertices(grid1, idx1, &amp;flip1, &amp;R, &amp;S, &amp;T);
  if (is_corner_tile(grid1, idx1)) {
    int shared_wall_vertex_id_1 = find_wall_vertex_for_corner_tile(grid1, idx1);
    if (idx1 == 0) {
      memcpy(&amp;T_3d, grid1-&gt;surface-&gt;vert[shared_wall_vertex_id_1],
             sizeof(struct vector3));
      uv2xyz(&amp;R, grid1-&gt;surface, &amp;R_3d);
      uv2xyz(&amp;S, grid1-&gt;surface, &amp;S_3d);
    } else if ((u_int)idx1 == (grid1-&gt;n_tiles - 2 * (grid1-&gt;n) + 1)) {
      memcpy(&amp;R_3d, grid1-&gt;surface-&gt;vert[shared_wall_vertex_id_1],
             sizeof(struct vector3));
      uv2xyz(&amp;S, grid1-&gt;surface, &amp;S_3d);
      uv2xyz(&amp;T, grid1-&gt;surface, &amp;T_3d);
    } else {
      memcpy(&amp;S_3d, grid1-&gt;surface-&gt;vert[shared_wall_vertex_id_1],
             sizeof(struct vector3));
      uv2xyz(&amp;R, grid1-&gt;surface, &amp;R_3d);
      uv2xyz(&amp;T, grid1-&gt;surface, &amp;T_3d);
    }
  } else {
    uv2xyz(&amp;R, grid1-&gt;surface, &amp;R_3d);
    uv2xyz(&amp;S, grid1-&gt;surface, &amp;S_3d);
    uv2xyz(&amp;T, grid1-&gt;surface, &amp;T_3d);
  }
  get_tile_vertices(grid2, idx2, &amp;flip2, &amp;A, &amp;B, &amp;C);
  if (is_corner_tile(grid2, idx2)) {
    int shared_wall_vertex_id_2 = find_wall_vertex_for_corner_tile(grid2, idx2);
    if (idx2 == 0) {
      memcpy(&amp;C_3d, grid2-&gt;surface-&gt;vert[shared_wall_vertex_id_2],
             sizeof(struct vector3));
      uv2xyz(&amp;A, grid2-&gt;surface, &amp;A_3d);
      uv2xyz(&amp;B, grid2-&gt;surface, &amp;B_3d);
    } else if ((u_int)idx2 == (grid2-&gt;n_tiles - 2 * (grid2-&gt;n) + 1)) {
      memcpy(&amp;A_3d, grid2-&gt;surface-&gt;vert[shared_wall_vertex_id_2],
             sizeof(struct vector3));
      uv2xyz(&amp;B, grid2-&gt;surface, &amp;B_3d);
      uv2xyz(&amp;C, grid2-&gt;surface, &amp;C_3d);
    } else {
      memcpy(&amp;B_3d, grid2-&gt;surface-&gt;vert[shared_wall_vertex_id_2],
             sizeof(struct vector3));
      uv2xyz(&amp;A, grid2-&gt;surface, &amp;A_3d);
      uv2xyz(&amp;C, grid2-&gt;surface, &amp;C_3d);
    }
  } else {
    uv2xyz(&amp;A, grid2-&gt;surface, &amp;A_3d);
    uv2xyz(&amp;B, grid2-&gt;surface, &amp;B_3d);
    uv2xyz(&amp;C, grid2-&gt;surface, &amp;C_3d);
  }
  if (grid1 == grid2) {
    if (!distinguishable_vec2(&amp;R, &amp;A, EPS_C) ||
        (!distinguishable_vec2(&amp;R, &amp;B, EPS_C)) ||
        (!distinguishable_vec2(&amp;R, &amp;C, EPS_C))) {
      num_exact_shared_vertices++;
      R_shared = 1;
    }
    if (!distinguishable_vec2(&amp;S, &amp;A, EPS_C) ||
        (!distinguishable_vec2(&amp;S, &amp;B, EPS_C)) ||
        (!distinguishable_vec2(&amp;S, &amp;C, EPS_C))) {
      num_exact_shared_vertices++;
      S_shared = 1;
    }
    if (!distinguishable_vec2(&amp;T, &amp;A, EPS_C) ||
        (!distinguishable_vec2(&amp;T, &amp;B, EPS_C)) ||
        (!distinguishable_vec2(&amp;T, &amp;C, EPS_C))) {
      num_exact_shared_vertices++;
      T_shared = 1;
    }
  } else {
    if (!distinguishable_vec3(&amp;R_3d, &amp;A_3d, EPS_C) ||
        (!distinguishable_vec3(&amp;R_3d, &amp;B_3d, EPS_C)) ||
        (!distinguishable_vec3(&amp;R_3d, &amp;C_3d, EPS_C))) {
      num_exact_shared_vertices++;
      R_shared = 1;
    }
    if (!distinguishable_vec3(&amp;S_3d, &amp;A_3d, EPS_C) ||
        (!distinguishable_vec3(&amp;S_3d, &amp;B_3d, EPS_C)) ||
        (!distinguishable_vec3(&amp;S_3d, &amp;C_3d, EPS_C))) {
      num_exact_shared_vertices++;
      S_shared = 1;
    }
    if (!distinguishable_vec3(&amp;T_3d, &amp;A_3d, EPS_C) ||
        (!distinguishable_vec3(&amp;T_3d, &amp;B_3d, EPS_C)) ||
        (!distinguishable_vec3(&amp;T_3d, &amp;C_3d, EPS_C))) {
      num_exact_shared_vertices++;
      T_shared = 1;
    }
  }
  if (num_exact_shared_vertices == 1) {
    if (R_shared) {
      place_product_shared_vertex(&amp;R, &amp;S, &amp;T, p, k1, k2);
      return;
    } else if (S_shared) {
      place_product_shared_vertex(&amp;S, &amp;R, &amp;T, p, k1, k2);
      return;
      place_product_shared_vertex(&amp;T, &amp;R, &amp;S, p, k1, k2);
      return;
    }
  }
  if (num_exact_shared_vertices == 2) {
    if (R_shared &amp;&amp; S_shared) {
      place_product_shared_segment(&amp;R, &amp;S, &amp;T, p, k1, k2);
      return;
    } else if (R_shared &amp;&amp; T_shared) {
      place_product_shared_segment(&amp;R, &amp;T, &amp;S, p, k1, k2);
      return;
      place_product_shared_segment(&amp;S, &amp;T, &amp;R, p, k1, k2);
      return;
    }
  }
  if (num_exact_shared_vertices == 0) {
    if ((intersect_point_segment(&amp;S_3d, &amp;A_3d, &amp;B_3d)) ||
        (intersect_point_segment(&amp;S_3d, &amp;B_3d, &amp;C_3d)) ||
        (intersect_point_segment(&amp;S_3d, &amp;A_3d, &amp;C_3d))) {
      S_shared = 1;
    }
    if ((intersect_point_segment(&amp;R_3d, &amp;A_3d, &amp;B_3d)) ||
        (intersect_point_segment(&amp;R_3d, &amp;B_3d, &amp;C_3d)) ||
        (intersect_point_segment(&amp;R_3d, &amp;A_3d, &amp;C_3d))) {
      R_shared = 1;
    }
    if ((intersect_point_segment(&amp;T_3d, &amp;A_3d, &amp;B_3d)) ||
        (intersect_point_segment(&amp;T_3d, &amp;B_3d, &amp;C_3d)) ||
        (intersect_point_segment(&amp;T_3d, &amp;A_3d, &amp;C_3d))) {
      T_shared = 1;
    }
    if ((intersect_point_segment(&amp;A_3d, &amp;R_3d, &amp;S_3d)) ||
        (intersect_point_segment(&amp;A_3d, &amp;S_3d, &amp;T_3d)) ||
        (intersect_point_segment(&amp;A_3d, &amp;R_3d, &amp;T_3d))) {
      A_shared = 1;
    }
    if ((intersect_point_segment(&amp;B_3d, &amp;R_3d, &amp;S_3d)) ||
        (intersect_point_segment(&amp;B_3d, &amp;S_3d, &amp;T_3d)) ||
        (intersect_point_segment(&amp;B_3d, &amp;R_3d, &amp;T_3d))) {
      B_shared = 1;
    }
    if ((intersect_point_segment(&amp;C_3d, &amp;R_3d, &amp;S_3d)) ||
        (intersect_point_segment(&amp;C_3d, &amp;S_3d, &amp;T_3d)) ||
        (intersect_point_segment(&amp;C_3d, &amp;R_3d, &amp;T_3d))) {
      C_shared = 1;
    }
    if (R_shared &amp;&amp; S_shared) {
      place_product_shared_segment(&amp;R, &amp;S, &amp;T, p, k1, k2);
      return;
    } else if (R_shared &amp;&amp; T_shared) {
      place_product_shared_segment(&amp;R, &amp;T, &amp;S, p, k1, k2);
      return;
    } else if (S_shared &amp;&amp; T_shared) {
      place_product_shared_segment(&amp;S, &amp;T, &amp;R, p, k1, k2);
      return;
    }
    if (A_shared &amp;&amp; B_shared) {
      if (parallel_segments(&amp;A_3d, &amp;B_3d, &amp;R_3d, &amp;S_3d)) {
        xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
        xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
        place_product_shared_segment(&amp;A_new, &amp;B_new, &amp;T, p, k1, k2);
        return;
      } else if (parallel_segments(&amp;A_3d, &amp;B_3d, &amp;R_3d, &amp;T_3d)) {
        xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
        xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
        place_product_shared_segment(&amp;A_new, &amp;B_new, &amp;S, p, k1, k2);
        return;
      } else if (parallel_segments(&amp;A_3d, &amp;B_3d, &amp;S_3d, &amp;T_3d)) {
        xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
        xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
        place_product_shared_segment(&amp;A_new, &amp;B_new, &amp;R, p, k1, k2);
        return;
      }
    } else if (A_shared &amp;&amp; C_shared) {
      if (parallel_segments(&amp;A_3d, &amp;C_3d, &amp;R_3d, &amp;S_3d)) {
        xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
        xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
        place_product_shared_segment(&amp;A_new, &amp;C_new, &amp;T, p, k1, k2);
        return;
      } else if (parallel_segments(&amp;A_3d, &amp;C_3d, &amp;R_3d, &amp;T_3d)) {
        xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
        xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
        place_product_shared_segment(&amp;A_new, &amp;C_new, &amp;S, p, k1, k2);
        return;
      } else if (parallel_segments(&amp;A_3d, &amp;C_3d, &amp;S_3d, &amp;T_3d)) {
        xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
        xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
        place_product_shared_segment(&amp;A_new, &amp;C_new, &amp;R, p, k1, k2);
        return;
      }
    } else if (B_shared &amp;&amp; C_shared) {
      if (parallel_segments(&amp;B_3d, &amp;C_3d, &amp;R_3d, &amp;S_3d)) {
        xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
        xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
        place_product_shared_segment(&amp;B_new, &amp;C_new, &amp;T, p, k1, k2);
        return;
      } else if (parallel_segments(&amp;B_3d, &amp;C_3d, &amp;R_3d, &amp;T_3d)) {
        xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
        xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
        place_product_shared_segment(&amp;B_new, &amp;C_new, &amp;S, p, k1, k2);
        return;
      } else if (parallel_segments(&amp;B_3d, &amp;C_3d, &amp;S_3d, &amp;T_3d)) {
        xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
        xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
        place_product_shared_segment(&amp;B_new, &amp;C_new, &amp;R, p, k1, k2);
        return;
      }
    }
    if (R_shared) {
      if (A_shared) {
        if (parallel_segments(&amp;R_3d, &amp;A_3d, &amp;R_3d, &amp;S_3d)) {
          xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
          place_product_shared_segment(&amp;A_new, &amp;R, &amp;T, p, k1, k2);
          return;
        } else if (parallel_segments(&amp;R_3d, &amp;A_3d, &amp;R_3d, &amp;T_3d)) {
          xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
          place_product_shared_segment(&amp;A_new, &amp;R, &amp;S, p, k1, k2);
          return;
        }
      } else if (B_shared) {
        if (parallel_segments(&amp;R_3d, &amp;B_3d, &amp;R_3d, &amp;S_3d)) {
          xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
          place_product_shared_segment(&amp;B_new, &amp;R, &amp;T, p, k1, k2);
          return;
        } else if (parallel_segments(&amp;R_3d, &amp;B_3d, &amp;R_3d, &amp;T_3d)) {
          xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
          place_product_shared_segment(&amp;B_new, &amp;R, &amp;S, p, k1, k2);
          return;
        }
      } else if (C_shared) {
        if (parallel_segments(&amp;R_3d, &amp;C_3d, &amp;R_3d, &amp;S_3d)) {
          xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
          place_product_shared_segment(&amp;C_new, &amp;R, &amp;T, p, k1, k2);
          return;
        } else if (parallel_segments(&amp;R_3d, &amp;C_3d, &amp;R_3d, &amp;T_3d)) {
          xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
          place_product_shared_segment(&amp;C_new, &amp;R, &amp;S, p, k1, k2);
          return;
        }
      } else {
        place_product_shared_vertex(&amp;R, &amp;S, &amp;T, p, k1, k2);
        return;
      }
    } else if (S_shared) {
      if (A_shared) {
        if (parallel_segments(&amp;S_3d, &amp;A_3d, &amp;S_3d, &amp;T_3d)) {
          xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
          place_product_shared_segment(&amp;A_new, &amp;S, &amp;R, p, k1, k2);
          return;
        } else if (parallel_segments(&amp;S_3d, &amp;A_3d, &amp;S_3d, &amp;R_3d)) {
          xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
          place_product_shared_segment(&amp;A_new, &amp;S, &amp;T, p, k1, k2);
          return;
        }
      } else if (B_shared) {
        if (parallel_segments(&amp;S_3d, &amp;B_3d, &amp;S_3d, &amp;T_3d)) {
          xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
          place_product_shared_segment(&amp;B_new, &amp;S, &amp;R, p, k1, k2);
          return;
        } else if (parallel_segments(&amp;S_3d, &amp;B_3d, &amp;S_3d, &amp;R_3d)) {
          xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
          place_product_shared_segment(&amp;B_new, &amp;S, &amp;T, p, k1, k2);
          return;
        }
      } else if (C_shared) {
        if (parallel_segments(&amp;S_3d, &amp;C_3d, &amp;S_3d, &amp;T_3d)) {
          xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
          place_product_shared_segment(&amp;C_new, &amp;S, &amp;R, p, k1, k2);
          return;
        } else if (parallel_segments(&amp;S_3d, &amp;C_3d, &amp;S_3d, &amp;R_3d)) {
          xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
          place_product_shared_segment(&amp;C_new, &amp;S, &amp;T, p, k1, k2);
          return;
        }
      } else {
        place_product_shared_vertex(&amp;S, &amp;R, &amp;T, p, k1, k2);
        return;
      }
    } else if (T_shared) {
      if (A_shared) {
        if (parallel_segments(&amp;T_3d, &amp;A_3d, &amp;T_3d, &amp;S_3d)) {
          xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
          place_product_shared_segment(&amp;A_new, &amp;T, &amp;R, p, k1, k2);
          return;
        } else if (parallel_segments(&amp;T_3d, &amp;A_3d, &amp;T_3d, &amp;R_3d)) {
          xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
          place_product_shared_segment(&amp;A_new, &amp;T, &amp;S, p, k1, k2);
          return;
        }
      } else if (B_shared) {
        if (parallel_segments(&amp;T_3d, &amp;B_3d, &amp;T_3d, &amp;S_3d)) {
          xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
          place_product_shared_segment(&amp;B_new, &amp;T, &amp;R, p, k1, k2);
          return;
        } else if (parallel_segments(&amp;T_3d, &amp;B_3d, &amp;T_3d, &amp;R_3d)) {
          xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
          place_product_shared_segment(&amp;B_new, &amp;T, &amp;S, p, k1, k2);
          return;
        }
      } else if (C_shared) {
        if (parallel_segments(&amp;T_3d, &amp;C_3d, &amp;T_3d, &amp;S_3d)) {
          xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
          place_product_shared_segment(&amp;C_new, &amp;T, &amp;R, p, k1, k2);
          return;
        } else if (parallel_segments(&amp;T_3d, &amp;C_3d, &amp;T_3d, &amp;R_3d)) {
          xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
          place_product_shared_segment(&amp;C_new, &amp;T, &amp;S, p, k1, k2);
          return;
        }
      } else {
        place_product_shared_vertex(&amp;T, &amp;R, &amp;S, p, k1, k2);
        return;
      }
    }
    if (A_shared) {
      xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
      if (intersect_point_segment(&amp;A_3d, &amp;R_3d, &amp;S_3d)) {
        place_product_close_to_segment_endpoint(&amp;T, &amp;A_new, p, k1, k2);
        return;
      } else if (intersect_point_segment(&amp;A_3d, &amp;R_3d, &amp;T_3d)) {
        place_product_close_to_segment_endpoint(&amp;S, &amp;A_new, p, k1, k2);
        return;
      } else if (intersect_point_segment(&amp;A_3d, &amp;S_3d, &amp;T_3d)) {
        place_product_close_to_segment_endpoint(&amp;R, &amp;A_new, p, k1, k2);
        return;
      }
    } else if (B_shared) {
      xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
      if (intersect_point_segment(&amp;B_3d, &amp;R_3d, &amp;S_3d)) {
        place_product_close_to_segment_endpoint(&amp;T, &amp;B_new, p, k1, k2);
        return;
      } else if (intersect_point_segment(&amp;B_3d, &amp;R_3d, &amp;T_3d)) {
        place_product_close_to_segment_endpoint(&amp;S, &amp;B_new, p, k1, k2);
        return;
      } else if (intersect_point_segment(&amp;B_3d, &amp;S_3d, &amp;T_3d)) {
        place_product_close_to_segment_endpoint(&amp;R, &amp;B_new, p, k1, k2);
        return;
      }
    } else if (C_shared) {
      xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
      if (intersect_point_segment(&amp;C_3d, &amp;R_3d, &amp;S_3d)) {
        place_product_close_to_segment_endpoint(&amp;T, &amp;C_new, p, k1, k2);
        return;
      } else if (intersect_point_segment(&amp;C_3d, &amp;R_3d, &amp;T_3d)) {
        place_product_close_to_segment_endpoint(&amp;S, &amp;C_new, p, k1, k2);
        return;
      } else if (intersect_point_segment(&amp;C_3d, &amp;S_3d, &amp;T_3d)) {
        place_product_close_to_segment_endpoint(&amp;R, &amp;C_new, p, k1, k2);
        return;
      }
    }
  } 
  struct vector3 A_close_3d, B_close_3d, C_close_3d;
  double dist_A_A_close_3d, dist_B_B_close_3d, dist_C_C_close_3d, min_dist;
  struct vector3 prod_pos_3d;
  struct vector2 prod_pos;
  closest_pt_point_triangle(&amp;A_3d, &amp;R_3d, &amp;S_3d, &amp;T_3d, &amp;A_close_3d);
  closest_pt_point_triangle(&amp;B_3d, &amp;R_3d, &amp;S_3d, &amp;T_3d, &amp;B_close_3d);
  closest_pt_point_triangle(&amp;C_3d, &amp;R_3d, &amp;S_3d, &amp;T_3d, &amp;C_close_3d);
  dist_A_A_close_3d = distance_vec3(&amp;A_3d, &amp;A_close_3d);
  dist_B_B_close_3d = distance_vec3(&amp;B_3d, &amp;B_close_3d);
  dist_C_C_close_3d = distance_vec3(&amp;C_3d, &amp;C_close_3d);
  min_dist = min3d(dist_A_A_close_3d, dist_B_B_close_3d, dist_C_C_close_3d);
  if (!distinguishable(min_dist, dist_A_A_close_3d, EPS_C)) {
    prod_pos_3d.x = A_close_3d.x;
    prod_pos_3d.y = A_close_3d.y;
    prod_pos_3d.z = A_close_3d.z;
  } else if (!distinguishable(min_dist, dist_B_B_close_3d, EPS_C)) {
    prod_pos_3d.x = B_close_3d.x;
    prod_pos_3d.y = B_close_3d.y;
    prod_pos_3d.z = B_close_3d.z;
  } else {
    prod_pos_3d.x = C_close_3d.x;
    prod_pos_3d.y = C_close_3d.y;
    prod_pos_3d.z = C_close_3d.z;
  }
  xyz2uv(&amp;prod_pos_3d, grid1-&gt;surface, &amp;prod_pos);
  if (intersect_point_segment(&amp;prod_pos_3d, &amp;R_3d, &amp;S_3d)) {
    place_product_close_to_segment_endpoint(&amp;T, &amp;prod_pos, p, k1, k2);
    return;
  } else if (intersect_point_segment(&amp;prod_pos_3d, &amp;R_3d, &amp;T_3d)) {
    place_product_close_to_segment_endpoint(&amp;S, &amp;prod_pos, p, k1, k2);
    return;
  } else if (intersect_point_segment(&amp;prod_pos_3d, &amp;S_3d, &amp;T_3d)) {
    place_product_close_to_segment_endpoint(&amp;R, &amp;prod_pos, p, k1, k2);
    return;
  } else {
    p-&gt;u = prod_pos.u;
    p-&gt;v = prod_pos.v;
    return;
  }
  mcell_internal_error("Error in the function 'find_closest_position()'.");
}
int is_inner_tile(struct surface_grid *g, int idx) {
  int root, rootrem, strip, stripe, flip;
  root = (int)(sqrt((double)idx));
  rootrem = idx - root * root;
  strip = g-&gt;n - root - 1;
  stripe = rootrem / 2;
  flip = rootrem - 2 * stripe;
  if ((strip == 0) || (stripe == 0))
    return 0;
  if ((strip + stripe) == g-&gt;n - 1) {
    return 0;
  }
  if (((strip + stripe) == g-&gt;n - 2) &amp;&amp; (flip == 1)) {
    return 0;
  }
  return 1;
}
int is_corner_tile(struct surface_grid *g, int idx) {
  int tile_idx_mid = g-&gt;n_tiles - 2 * (g-&gt;n) + 1;
  if ((idx == 0) || ((u_int)idx == (g-&gt;n_tiles - 1)))
    return 1;
  if (idx == tile_idx_mid)
    return 1;
  return 0;
}
void find_shared_vertices_corner_tile_parent_wall(struct volume *world,
                                                  struct surface_grid *sg,
                                                  int idx,
                                                  long long int *shared_vert) {
  long long global_vert_index;
  struct vector3 *v;
  if (!world-&gt;create_shared_walls_info_flag)
    mcell_internal_error("Function "
                         "'find_shared_vertices_corner_tile_parent_wall()' is "
                         "called but shared walls information is not created.");
  if ((u_int)idx == (sg-&gt;n_tiles - 2 * (sg-&gt;n) + 1)) {
    v = sg-&gt;surface-&gt;vert[0];
    global_vert_index = (long long)(v - world-&gt;all_vertices);
    if (world-&gt;walls_using_vertex[global_vert_index] != NULL) {
      shared_vert[0] = global_vert_index;
    }
  }
  if ((u_int)idx == (sg-&gt;n_tiles - 1)) {
    v = sg-&gt;surface-&gt;vert[1];
    global_vert_index = (long long)(v - world-&gt;all_vertices);
    if (world-&gt;walls_using_vertex[global_vert_index] != NULL) {
      shared_vert[1] = global_vert_index;
    }
  }
  if ((u_int)idx == 0) {
    v = sg-&gt;surface-&gt;vert[2];
    global_vert_index = (long long)(v - world-&gt;all_vertices);
    if (world-&gt;walls_using_vertex[global_vert_index] != NULL) {
      shared_vert[2] = global_vert_index;
    }
  }
}
int move_strip_up(struct surface_grid *grid, int idx) {
  int root;
  int tile_up_idx; 
  root = (int)(sqrt((double)idx)) + 1;
  if (grid-&gt;n == root) {
    tile_up_idx = -1;
  } else {
    tile_up_idx = idx + 2 * root;
  }
  return tile_up_idx;
}
int move_strip_down(struct surface_grid *grid, int idx) {
  int root, rootrem, strip, stripe, flip;
  int num_tiles_per_strip;
  int tile_down_idx; 
  root = (int)(sqrt((double)idx));
  rootrem = idx - root * root;
  strip = grid-&gt;n - root - 1;
  stripe = rootrem / 2;
  flip = rootrem - 2 * stripe;
  num_tiles_per_strip = 2 * (grid-&gt;n) - 2 * strip - 1;
  if (is_inner_tile(grid, idx)) {
    tile_down_idx = idx - num_tiles_per_strip + 1;
  } else {
    if ((strip == 0) &amp;&amp; (stripe &gt; 0)) {
      if ((unsigned int)idx == grid-&gt;n_tiles - 1) {
        tile_down_idx = -1;
      } else {
        tile_down_idx = idx - num_tiles_per_strip + 1;
      }
    } else {
      if (flip == 0) {
        tile_down_idx = -1;
      } else {
        tile_down_idx = idx - num_tiles_per_strip + 1;
      }
    }
  }
  return tile_down_idx;
}
void place_product_shared_segment(struct vector2 *R_shared,
                                  struct vector2 *S_shared, struct vector2 *T,
                                  struct vector2 *prod, double k1, double k2) {
  struct vector2 M; 
  M.u = 0.5 * (R_shared-&gt;u + S_shared-&gt;u);
  M.v = 0.5 * (R_shared-&gt;v + S_shared-&gt;v);
  prod-&gt;u = (k1 * T-&gt;u + k2 * M.u) / (k1 + k2);
  prod-&gt;v = (k1 * T-&gt;v + k2 * M.v) / (k1 + k2);
}
void place_product_shared_vertex(struct vector2 *R_shared, struct vector2 *S,
                                 struct vector2 *T, struct vector2 *prod,
                                 double k1, double k2) {
  struct vector2 M; 
  M.u = 0.5 * (S-&gt;u + T-&gt;u);
  M.v = 0.5 * (S-&gt;v + T-&gt;v);
  prod-&gt;u = (k1 * M.u + k2 * R_shared-&gt;u) / (k1 + k2);
  prod-&gt;v = (k1 * M.v + k2 * R_shared-&gt;v) / (k1 + k2);
}
void place_product_close_to_segment_endpoint(struct vector2 *S,
                                             struct vector2 *E,
                                             struct vector2 *prod, double k1,
                                             double k2) {
  prod-&gt;u = (k1 * S-&gt;u + k2 * E-&gt;u) / (k1 + k2);
  prod-&gt;v = (k1 * S-&gt;v + k2 * E-&gt;v) / (k1 + k2);
}
void append_tile_neighbor_list(struct tile_neighbor **head1,
                               struct tile_neighbor **head2) {
  struct tile_neighbor *curr;
  if (*head1 == NULL)   {
    *head1 = *head2;
  } else {
    curr = *head1;
    while (curr-&gt;next != NULL)     {
      curr = curr-&gt;next;
    }
    curr-&gt;next = *head2;
  }
  *head2 = NULL;
}
int find_wall_vertex_for_corner_tile(struct surface_grid *grid, int idx) {
  int vertex_id = 0;
  if (!is_corner_tile(grid, idx))
    mcell_internal_error("Function 'find_wall_vertex_for_corner_tile()' is "
                         "called for the tile that is not the corner tile.");
  if ((u_int)idx == (grid-&gt;n_tiles - 2 * (grid-&gt;n) + 1)) {
    vertex_id = 0;
  } else if ((u_int)idx == (grid-&gt;n_tiles - 1)) {
    vertex_id = 1;
  } else if (idx == 0) {
    vertex_id = 2;
  } else {
    mcell_internal_error("Function 'find_wall_vertex_for_corner_tile()' is "
                         "called for the tile that is not the corner tile.");
  }
  return vertex_id;
}
void find_shared_vertices_for_neighbor_walls(struct wall *orig_wall,
                                             struct wall *nb_wall,
                                             int *shared_vert_1,
                                             int *shared_vert_2) {
  if ((!distinguishable_vec3(nb_wall-&gt;vert[0], orig_wall-&gt;vert[0], EPS_C)) ||
      (!distinguishable_vec3(nb_wall-&gt;vert[0], orig_wall-&gt;vert[1], EPS_C)) ||
      (!distinguishable_vec3(nb_wall-&gt;vert[0], orig_wall-&gt;vert[2], EPS_C))) {
    *shared_vert_1 = 0;
  }
  if ((!distinguishable_vec3(nb_wall-&gt;vert[1], orig_wall-&gt;vert[0], EPS_C)) ||
      (!distinguishable_vec3(nb_wall-&gt;vert[1], orig_wall-&gt;vert[1], EPS_C)) ||
      (!distinguishable_vec3(nb_wall-&gt;vert[1], orig_wall-&gt;vert[2], EPS_C))) {
    if (*shared_vert_1 &lt; 0) {
      *shared_vert_1 = 1;
    } else {
      *shared_vert_2 = 1;
    }
  }
  if ((!distinguishable_vec3(nb_wall-&gt;vert[2], orig_wall-&gt;vert[0], EPS_C)) ||
      (!distinguishable_vec3(nb_wall-&gt;vert[2], orig_wall-&gt;vert[1], EPS_C)) ||
      (!distinguishable_vec3(nb_wall-&gt;vert[2], orig_wall-&gt;vert[2], EPS_C))) {
    if (*shared_vert_1 &lt; 0) {
      *shared_vert_1 = 2;
    } else {
      *shared_vert_2 = 2;
    }
  }
}
void find_neighbor_tiles(struct volume *world, struct surface_molecule *sm,
                         struct surface_grid *grid, int idx,
                         int create_grid_flag, int search_for_reactant,
                         struct tile_neighbor **tile_nbr_head,
                         int *list_length) {
  int kk;
  struct tile_neighbor *tile_nbr_head_vert = NULL, *tmp_head = NULL;
  int list_length_vert = 0;   int tmp_list_length = 0;    struct vector2 pos;       
  struct wall_list *wall_nbr_head = NULL; 
  for (kk = 0; kk &lt; 3; kk++) {
    shared_vert[kk] = -1;
  }
  if (is_inner_tile(grid, idx)) {
    grid2uv(grid, idx, &amp;pos);
    grid_all_neighbors_for_inner_tile(world, grid, idx, &amp;pos, &amp;tmp_head,
                                      &amp;tmp_list_length);
  } else {
    if (is_corner_tile(grid, idx)) {
      find_shared_vertices_corner_tile_parent_wall(world, grid, idx,
                                                   shared_vert);
      wall_nbr_head =
          find_nbr_walls_shared_one_vertex(world, grid-&gt;surface, shared_vert);
      if (wall_nbr_head != NULL) {
        grid_all_neighbors_across_walls_through_vertices(
            world, sm, wall_nbr_head, grid, create_grid_flag,
            search_for_reactant, &amp;tile_nbr_head_vert, &amp;list_length_vert);
      }
      if (wall_nbr_head != NULL) {
        delete_wall_list(wall_nbr_head);
        wall_nbr_head = NULL;
      }
      grid_all_neighbors_across_walls_through_edges(
          world, sm, grid, idx, create_grid_flag, search_for_reactant,
          &amp;tmp_head, &amp;tmp_list_length);
    } else {
      grid_all_neighbors_across_walls_through_edges(
          world, sm, grid, idx, create_grid_flag, search_for_reactant,
          &amp;tmp_head, &amp;tmp_list_length);
    }
  }
  if (tile_nbr_head_vert != NULL) {
    append_tile_neighbor_list(&amp;tmp_head, &amp;tile_nbr_head_vert);
    tmp_list_length += list_length_vert;
  }
  *tile_nbr_head = tmp_head;
  *list_length = tmp_list_length;
#ifdef DEBUG_GRIDS
  dump_tile_neighbors_list(*tile_nbr_head, __FUNCTION__, "  ");
#endif
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
