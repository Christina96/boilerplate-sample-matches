<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for react_outc.c & grid_util.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for react_outc.c & grid_util.c
      </h3>
      <h1 align="center">
        1.5%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>react_outc.c (1.9607843%)<TH>grid_util.c (1.3196481%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1323-0.html#0',2,'match1323-1.html#0',3)" NAME="0">(1690-1705)<TD><A HREF="javascript:ZweiFrames('match1323-0.html#0',2,'match1323-1.html#0',3)" NAME="0">(1921-1927)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1323-0.html#1',2,'match1323-1.html#1',3)" NAME="1">(1634-1637)<TD><A HREF="javascript:ZweiFrames('match1323-0.html#1',2,'match1323-1.html#1',3)" NAME="1">(1375-1378)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match1323-0.html#2',2,'match1323-1.html#2',3)" NAME="2">(516-524)<TD><A HREF="javascript:ZweiFrames('match1323-0.html#2',2,'match1323-1.html#2',3)" NAME="2">(2019-2030)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>react_outc.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/******************************************************************************
 *
 * Copyright (C) 2006-2017 by
 * The Salk Institute for Biological Studies and
 * Pittsburgh Supercomputing Center, Carnegie Mellon University
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 *
******************************************************************************/

#include &quot;config.h&quot;

#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;vector&gt;

#include &quot;logging.h&quot;
#include &quot;rng.h&quot;
#include &quot;util.h&quot;
#include &quot;grid_util.h&quot;
#include &quot;count_util.h&quot;
#include &quot;react.h&quot;
#include &quot;vol_util.h&quot;
#include &quot;wall_util.h&quot;
#include &quot;nfsim_func.h&quot;
#include &quot;mcell_reactions.h&quot;

#include &quot;diffuse.h&quot;

#include &quot;debug_config.h&quot;
#include &quot;debug.h&quot;
#include &quot;dump_state.h&quot;

static int outcome_products_random(struct volume *world, struct wall *w,
                                   struct vector3 *hitpt, double t,
                                   struct rxn *rx, int path,
                                   struct abstract_molecule *reacA,
                                   struct abstract_molecule *reacB,
                                   short orientA, short orientB);


static int cleanup_and_block_rx(struct tile_neighbor *tn1, struct tile_neighbor *tn2);

int is_compatible_surface(void *req_species, struct wall *w) {
  struct surf_class_list *scl, *scl2;

  struct surf_class_list *rs_head = (struct surf_class_list *)req_species;

  if (rs_head == NULL)
    return 1;

  for (scl = w-&gt;surf_class_head; scl != NULL; scl = scl-&gt;next) {
    for (scl2 = rs_head; scl2 != NULL; scl2 = scl2-&gt;next) {
      if (scl-&gt;surf_class == scl2-&gt;surf_class)
        return 1;
    }
  }

  return 0;
}

void add_reactants_to_product_list(struct rxn *rx, struct abstract_molecule *reacA,
  struct abstract_molecule *reacB, struct abstract_molecule *reacC,
  struct abstract_molecule **player, char *player_type) {

  /* Add reacA to the list of players, saving the reactant's type. */
  player[0] = reacA;
  player_type[0] = IS_SURF_MOL(reacA) ? PLAYER_SURF_MOL : PLAYER_VOL_MOL;

  /* If we have a second reactant, add it to the list of players. */
  if (rx-&gt;n_reactants &gt; 1) {

    /* If the second reactant is a wall... */
    if (reacB == NULL) {
      assert(rx-&gt;n_reactants == 2);
      player[1] = NULL;
      player_type[1] = PLAYER_WALL;
    } else {  // else 2nd reactant is a wall
      player[1] = reacB;
      player_type[1] = IS_SURF_MOL(reacB) ? PLAYER_SURF_MOL : PLAYER_VOL_MOL;
    }

    if (rx-&gt;n_reactants &gt; 2) {
      if (reacC == NULL) {
        /* it's a wall. */
        player[2] = NULL;
        player_type[2] = PLAYER_WALL;
      } else {
        player[2] = reacC;
        player_type[2] = IS_SURF_MOL(reacC) ? PLAYER_SURF_MOL : PLAYER_VOL_MOL;
      }
    }
  }
}

static bool is_rxn_unimol(struct rxn *rx) {
  if (rx-&gt;n_reactants == 1)
    return true;

  if (rx-&gt;n_reactants != 2)
    return false;

  if (!(rx-&gt;players[0]-&gt;flags &amp; ON_GRID))
    return false;

  return (rx-&gt;players[1]-&gt;flags &amp; IS_SURFACE) != 0;
}

void tiny_diffuse_3D(
    struct volume *world,
    struct subvolume *subvol,
    struct vector3 *displacement,
    struct vector3 *pos,
    struct wall *w) {

  struct vector3 temp_displacement = {
    displacement-&gt;x,
    displacement-&gt;y,
    displacement-&gt;z
  };
  struct collision *shead = ray_trace(
      world, pos, NULL, subvol, &amp;temp_displacement, w);
  if (shead-&gt;next != NULL) {
    shead = (struct collision *)ae_list_sort((struct abstract_element *)shead);
  }

  struct collision *smash = NULL;
  for (smash = shead; smash != NULL; smash = smash-&gt;next) {
    if ((smash-&gt;what &amp; COLLIDE_WALL) != 0) {
      vectorize(pos, &amp;(smash-&gt;loc), displacement);
      scalar_prod(displacement, 0.5, displacement);
      break;
    }
  }
  pos-&gt;x += displacement-&gt;x;
  pos-&gt;y += displacement-&gt;y;
  pos-&gt;z += displacement-&gt;z;
  subvol = find_subvolume(world, pos, subvol);
}

struct volume_molecule *
place_volume_product(struct volume *world, struct species *product_species, struct graph_data* graph,
                     struct surface_molecule *sm_reactant, struct wall *w,
                     struct subvolume *subvol, struct vector3 *hitpt,
                     short orient, double t, struct periodic_image *periodic_box) {
  struct vector3 pos = *hitpt;

  /* For an orientable reaction, we need to move products away from the surface
   * to ensure they end up on the correct side of the plane. */
  if (w) {
    double bump = (orient &gt; 0) ? EPS_C : -EPS_C;
    struct vector3 displacement = {2 * bump * w-&gt;normal.x,
                                   2 * bump * w-&gt;normal.y,
                                   2 * bump * w-&gt;normal.z,
                                  };
    tiny_diffuse_3D(world, subvol, &amp;displacement, &amp;pos, w);
  }

  /* Allocate and initialize the molecule. */
  struct volume_molecule *new_volume_mol;
  new_volume_mol =
      (struct volume_molecule *)CHECKED_MEM_GET(subvol-&gt;local_storage-&gt;mol, &quot;volume molecule&quot;);
  new_volume_mol-&gt;birthplace = subvol-&gt;local_storage-&gt;mol;
  new_volume_mol-&gt;birthday = convert_iterations_to_seconds(
      world-&gt;start_iterations, world-&gt;time_unit,
      world-&gt;simulation_start_seconds, t);
  new_volume_mol-&gt;id = world-&gt;current_mol_id++;
  new_volume_mol-&gt;t = t;
  new_volume_mol-&gt;t2 = 0.0;

  new_volume_mol-&gt;periodic_box = CHECKED_MALLOC_STRUCT(struct periodic_image,
    &quot;periodic image descriptor&quot;);
  new_volume_mol-&gt;periodic_box-&gt;x = periodic_box-&gt;x;
  new_volume_mol-&gt;periodic_box-&gt;y = periodic_box-&gt;y;
  new_volume_mol-&gt;periodic_box-&gt;z = periodic_box-&gt;z;

  new_volume_mol-&gt;properties = product_species;
  new_volume_mol-&gt;graph_data = graph;
  initialize_diffusion_function((struct abstract_molecule*) new_volume_mol);

  new_volume_mol-&gt;prev_v = NULL;
  new_volume_mol-&gt;next_v = NULL;
  new_volume_mol-&gt;pos = pos;
  new_volume_mol-&gt;subvol = subvol;
  new_volume_mol-&gt;index = 0;
  new_volume_mol-&gt;flags = TYPE_VOL | ACT_NEWBIE | IN_VOLUME | IN_SCHEDULE;
  //if the molecule is extern then inherit the reactant's diffusion.
  //XXX: is this the best way?


  if (new_volume_mol-&gt;get_space_step(new_volume_mol) &gt; 0.0)
    new_volume_mol-&gt;flags |= ACT_DIFFUSE;
  if ((product_species-&gt;flags &amp; COUNT_SOME_MASK) != 0)
    new_volume_mol-&gt;flags |= COUNT_ME;

  /* Check whether the product can undergo unimolecular rxns; if so, mark it. */
  if (trigger_unimolecular(world-&gt;reaction_hash, world-&gt;rx_hashsize,
                           product_species-&gt;hashval,
                           (struct abstract_molecule *)new_volume_mol) != NULL)
    new_volume_mol-&gt;flags |= ACT_REACT;

  /* If this product resulted from a surface rxn, store the previous wall
   * position. */
  if (sm_reactant &amp;&amp; distinguishable(new_volume_mol-&gt;get_diffusion(new_volume_mol), 0, EPS_C)) {
    new_volume_mol-&gt;previous_wall = sm_reactant-&gt;grid-&gt;surface;

    /* This will be overwritten with orientation in the CLAMPED/surf.
     * reversibility case
     */
    new_volume_mol-&gt;index = sm_reactant-&gt;grid_index;
  }

  /* Else clear the previous wall position. */
  else {
    new_volume_mol-&gt;previous_wall = NULL;
    new_volume_mol-&gt;index = -1;
  }

  /* Set reversibility state for the new molecule. */
  if (w) {
    if (world-&gt;surface_reversibility) {
      /* Which direction did we move? */
      new_volume_mol-&gt;previous_wall = w;
      new_volume_mol-&gt;index = (orient &gt; 0) ? 1 : -1;
      new_volume_mol-&gt;flags |= ACT_CLAMPED;
    }
  } else if (world-&gt;volume_reversibility) {
    new_volume_mol-&gt;index = world-&gt;dissociation_index;
    new_volume_mol-&gt;flags |= ACT_CLAMPED;
  }

  /* Add the molecule to the subvolume */
  ht_add_molecule_to_list(&amp;new_volume_mol-&gt;subvol-&gt;mol_by_species,
                          new_volume_mol);
  ++new_volume_mol-&gt;subvol-&gt;mol_count;

  /* Add to the schedule. */
  if (schedule_add_mol(subvol-&gt;local_storage-&gt;timer, new_volume_mol))
    mcell_allocfailed(&quot;Failed to add newly created %s molecule to scheduler.&quot;,
                      product_species-&gt;sym-&gt;name);
  return new_volume_mol;
}

struct surface_molecule *
place_sm_product(struct volume *world, struct species *product_species, struct graph_data* graph,
                 struct surface_grid *grid, int grid_index,
                 struct vector2 *mol_uv_pos, short orient, double t,
                 struct periodic_image *periodic_box) {
  struct vector3 mol_xyz_pos;
  uv2xyz(mol_uv_pos, grid-&gt;surface, &amp;mol_xyz_pos);
  struct subvolume *sv = find_subvolume(world, &amp;mol_xyz_pos, grid-&gt;subvol);

  /* Allocate and initialize the molecule. */
  struct surface_molecule *new_surf_mol;
  new_surf_mol = (struct surface_molecule *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;smol, &quot;surface molecule&quot;);
  new_surf_mol-&gt;birthplace = sv-&gt;local_storage-&gt;smol;
  new_surf_mol-&gt;birthday = convert_iterations_to_seconds(
      world-&gt;start_iterations, world-&gt;time_unit,
      world-&gt;simulation_start_seconds, t);
  new_surf_mol-&gt;id = world-&gt;current_mol_id++;
  new_surf_mol-&gt;t = t;
  new_surf_mol-&gt;t2 = 0.0;
  new_surf_mol-&gt;properties = product_species;
  //nfsim graph init
  new_surf_mol-&gt;graph_data = graph;
  initialize_diffusion_function((struct abstract_molecule*) new_surf_mol);
  new_surf_mol-&gt;periodic_box = CHECKED_MALLOC_STRUCT(struct periodic_image,
    &quot;periodic image descriptor&quot;);
  new_surf_mol-&gt;periodic_box-&gt;x = periodic_box-&gt;x;
  new_surf_mol-&gt;periodic_box-&gt;y = periodic_box-&gt;y;
  new_surf_mol-&gt;periodic_box-&gt;z = periodic_box-&gt;z;

  new_surf_mol-&gt;flags = TYPE_SURF | ACT_NEWBIE | IN_SCHEDULE;
  if (new_surf_mol-&gt;get_space_step(new_surf_mol) &gt; 0)
    new_surf_mol-&gt;flags |= ACT_DIFFUSE;
  if (product_species-&gt;flags &amp; COUNT_ENCLOSED)
    new_surf_mol-&gt;flags |= COUNT_ME;
  new_surf_mol-&gt;grid = grid;
  new_surf_mol-&gt;grid_index = grid_index;
  new_surf_mol-&gt;s_pos = *mol_uv_pos;
  new_surf_mol-&gt;orient = orient;

  /* Check whether the product can undergo unimolecular rxns; if so, mark it. */
  if (trigger_unimolecular(world-&gt;reaction_hash, world-&gt;rx_hashsize,
                           product_species-&gt;hashval,
                           (struct abstract_molecule *)new_surf_mol) != NULL ||
      (product_species-&gt;flags &amp; CAN_SURFWALL) != 0)
    new_surf_mol-&gt;flags |= ACT_REACT;

  /* Add to the grid. */
  ++grid-&gt;n_occupied;
  if (grid-&gt;sm_list[grid_index]) {
    remove_surfmol_from_list(
        &amp;grid-&gt;sm_list[grid_index], grid-&gt;sm_list[grid_index]-&gt;sm);
  }
  grid-&gt;sm_list[grid_index] = add_surfmol_with_unique_pb_to_list(
    grid-&gt;sm_list[grid_index], new_surf_mol);

  /* Add to the schedule. */
  if (schedule_add_mol(sv-&gt;local_storage-&gt;timer, new_surf_mol))
    mcell_allocfailed(&quot;Failed to add newly created %s molecule to scheduler.&quot;,
                      product_species-&gt;sym-&gt;name);

  return new_surf_mol;
}

/***************************************************************************
outcome_products_random:
   In: world: simulation state
       w: first wall in the reaction
       hitpt: hit point (if any)
       t: time of the reaction
       rx: reaction
       path: path of the reaction
       reacA: first reactant (moving molecule)
       reacB: second reactant
       orientA: orientation of the first reactant
       orientB: orientation of the second reactant
   Out: Returns RX_A_OK, RX_FLIP or RX_BLOCKED.
Note: This function replaces surface reactants (if needed) by the surface
      products picked in the random order from the list of products. Also
      surface products are placed in the random order in the surrounding empty
      tiles. After this function execution some walls that do not have surface
      molecules and therefore do not have a grid may get a grid as side effect
      of calling functions &quot;grid_all_neigbors_across_walls_through_vertices()&quot;
      and &quot;grid_all_neighbors_across_walls_through_edges()&quot;.
Note: If both reactants are surface molecules, and they are both located within
      the same restricted region border (REFL/ABSORB), then reaction products -
      surface molecules for which this region border is restrictive will be
      placed inside this region. If any of the conditions above are not true,
      the reaction products - surface molecules can be placed on any tile from
      the list of vacant tiles.
Note: Policy on surface products placement is described in the document
      &quot;policy_surf_products_placement.doc&quot; (see &quot;src/docs&quot;).

****************************************************************************/
static int outcome_products_random(struct volume *world, struct wall *w,
                                   struct vector3 *hitpt, double t,
                                   struct rxn *rx, int path,
                                   struct abstract_molecule *reacA,
                                   struct abstract_molecule *reacB,
                                   short orientA, short orientB) {

#ifdef DEBUG_RXNS
  // NOTE: maybe make a single dump call out of this
  DUMP_CONDITION3(
    dump_processing_reaction(world-&gt;current_iterations, hitpt, t, rx, reacA, reacB, w);
    dump_molecule_species(reacA);
    if (reacB != nullptr) {
      mcell_log(&quot; + &quot;);
      dump_molecule_species(reacB);
    }
    mcell_log(&quot;\nreaction_index: %d\n&quot;, path);
    dump_rxn(rx, &quot;&quot;, true);
  );
#endif

  /* Did the moving molecule cross the plane? */
  bool cross_wall = false; 

  /* index of the first player for the pathway */
  int const i0 = rx-&gt;product_idx[path]; 
  /* index of the first player for the next pathway */
  int const iN = rx-&gt;product_idx[path + 1]; 
  assert(iN &gt; i0);
  /* Players array from the reaction. */
  struct species **rx_players = rx-&gt;players + i0; 

  int const n_players = iN - i0;                /* number of reaction players */
  std::vector&lt;struct abstract_molecule *&gt; product(n_players); /* array of products */
  /* array that decodes the type of each product */
  std::vector&lt;char&gt; product_type(n_players);
  std::vector&lt;short&gt; product_orient(n_players); /* array of orientations for each product */
  /* array of surface_grids for products */
  std::vector&lt;struct surface_grid *&gt; product_grid(n_players);
  std::vector&lt;int&gt; product_grid_idx(n_players); /* array of grid indices for products */
  std::vector&lt;byte&gt; product_flag(n_players);    /* array of placement flags for products */

  /* Unimol rxn (not mol-mol, not mol-wall) */
  bool const is_unimol = is_rxn_unimol(rx);

  struct surface_grid *tile_grid; /* surface grid the tile belongs to */
  int num_vacant_tiles = 0;       /* number of vacant tiles */

  /* used for product placement for the reaction of type A-&gt;B+C[rate] */
  unsigned int reac_idx = UINT_MAX;
  struct surface_grid *reac_grid = NULL, *mol_grid = NULL;

  /* Clear the initial product info. */
  for (int i = 0; i &lt; n_players; ++i) {
    product[i] = NULL;
    product_type[i] = PLAYER_NONE;
    product_orient[i] = 0;
    product_grid[i] = NULL;
    product_grid_idx[i] = -1;
    product_flag[i] = PRODUCT_FLAG_NOT_SET;
  }

  /* Flag indicating that a surface is somehow involved with this reaction. */
  struct surface_molecule *const sm_1 =
      IS_SURF_MOL(reacA) ? (struct surface_molecule *)reacA : NULL;
  struct surface_molecule *const sm_2 =
      IS_SURF_MOL(reacB) ? (struct surface_molecule *)reacB : NULL;
  struct surface_molecule *const sm_reactant = sm_1 ? sm_1 : sm_2;
  bool const is_orientable = (w != NULL) || (sm_reactant != NULL);

  /* list of the restricted regions for the reactants by wall */
  struct region_list *rlp_head_wall_1 = NULL, *rlp_head_wall_2 = NULL;

  /* list of the restricted regions for the reactants by object */
  struct region_list *rlp_head_obj_1 = NULL, *rlp_head_obj_2 = NULL;

  int sm_bitmask = determine_molecule_region_topology(
      world, sm_1, sm_2, &amp;rlp_head_wall_1, &amp;rlp_head_wall_2, &amp;rlp_head_obj_1,
      &amp;rlp_head_obj_2, is_unimol);

  /* reacA is the molecule which initiated the reaction. */
  struct abstract_molecule *const initiator = reacA;
  short const initiatorOrient = orientA;

  /* Ensure that reacA and reacB are sorted in the same order as the rxn players. */
  assert(reacA != NULL);

  if (reacA-&gt;properties != rx-&gt;players[0]) {
    struct abstract_molecule *tmp_mol = reacA;
    reacA = reacB;
    reacB = tmp_mol;
    short tmp_orient = orientA;
    orientA = orientB;
    orientB = tmp_orient;
  }
  assert(reacA != NULL);

  add_reactants_to_product_list(rx, reacA, reacB, NULL, &amp;product[0], &amp;product_type[0]);

  /* Determine whether any of the reactants can be replaced by a product.
     This is only useful for surface molecules to make sure reactions of the
     type A + B -&gt; A don't push A to neighboring tiles */
  int replace_p1 = (product_type[0] == PLAYER_SURF_MOL &amp;&amp; rx_players[0] == NULL);
  int replace_p2 = rx-&gt;n_reactants &gt; 1 &amp;&amp; (product_type[1] == PLAYER_SURF_MOL &amp;&amp;
                                           rx_players[1] == NULL);

  /* Determine the point of reaction on the surface. */
  struct vector2 rxn_uv_pos; // position of reaction on wall
  int rxn_uv_idx = -1;       // tile index of where reaction occurred
  int num_surface_static_reactants = 0; // number of reactants with (D_2D == 0)
  if (is_orientable) {
    if (sm_reactant) {
      rxn_uv_pos = sm_reactant-&gt;s_pos;
    } else {
      xyz2uv(hitpt, w, &amp;rxn_uv_pos);
    }

    assert(w != NULL);
    if (w-&gt;grid == NULL) {
      /* reacA must be a volume molecule, or this wall would have a grid already. */
      assert(!IS_SURF_MOL(reacA));
      if (create_grid(world, w, ((struct volume_molecule *)reacA)-&gt;subvol))
        mcell_allocfailed(&quot;Failed to create a grid for a wall.&quot;);
    }
    rxn_uv_idx = uv2grid(&amp;rxn_uv_pos, w-&gt;grid);

    /* find out number of static surface reactants */
    if ((sm_1 != NULL) &amp;&amp; (!distinguishable(sm_1-&gt;get_diffusion(sm_1), 0, EPS_C))){
      num_surface_static_reactants++;
    }
    if ((sm_2 != NULL) &amp;&amp; (!distinguishable(sm_2-&gt;get_diffusion(sm_2), 0, EPS_C))){
      num_surface_static_reactants++;
    }
  }

  /* find out number of surface products */
  int num_surface_products = 0;
  int num_surface_static_products = 0; // number of products with (D_2D == 0)
  for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
    if (rx_players[n_product] == NULL) {
      continue;
    }
    if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
      num_surface_products++;
      if (!distinguishable(rx_players[n_product]-&gt;D, 0, EPS_C))
        num_surface_static_products++;
    }
  }

  int mol_idx = INT_MAX;
  /* If the reaction involves a surface, make sure there is room for each
   * product. */
  struct tile_neighbor *tile_nbr_head = NULL; // list of neighbor tiles
  int tile_nbr_list_length = 0;
  struct tile_neighbor *tile_vacant_nbr_head = NULL; // list of vacant neighbor tiles
  if (is_orientable) {
    if (num_surface_products &gt; 0) {
      if (sm_reactant != NULL) {
        find_neighbor_tiles(world, sm_reactant, sm_reactant-&gt;grid,
                            sm_reactant-&gt;grid_index, 1, 0, &amp;tile_nbr_head,
                            &amp;tile_nbr_list_length);
      } else {
        find_neighbor_tiles(world, sm_reactant, w-&gt;grid, rxn_uv_idx, 1, 0,
                            &amp;tile_nbr_head, &amp;tile_nbr_list_length);
      }

      /* Create list of vacant tiles */
      for (struct tile_neighbor *tile_nbr = tile_nbr_head; tile_nbr != NULL;
           tile_nbr = tile_nbr-&gt;next) {
        struct surface_molecule_list *sm_list = tile_nbr-&gt;grid-&gt;sm_list[tile_nbr-&gt;idx]; 
        if (sm_list == NULL || sm_list-&gt;sm == NULL) {
          num_vacant_tiles++;
<A NAME="2"></A>          push_tile_neighbor_to_list(&amp;tile_vacant_nbr_head, tile_nbr-&gt;grid, tile_nbr-&gt;idx);
        }
      }
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match1323-1.html#2',3,'match1323-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    }

    /* Can this reaction happen at all? */
    int num_recycled_tiles = 0;
    if (replace_p1 &amp;&amp; replace_p2) {
      num_recycled_tiles = 2;
    } else if (replace_p1 || replace_p2) {
      num_recycled_tiles = 1;
    }</B></FONT>
    if (num_surface_products &gt; num_vacant_tiles + num_recycled_tiles) {
      return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
    }

    /* set the orientations of the products. */
    for (int n_product = 0; n_product &lt; n_players; ++n_product) {
      /* Skip NULL products */
      if (rx_players[n_product] == NULL) {
        continue;
      }

      int this_geometry = rx-&gt;geometries[i0 + n_product];
      int relative_orient = (this_geometry &lt; 0) ? -1 : 1;
      this_geometry = abs(this_geometry);

      /* Geometry of 0 means &quot;random orientation&quot; */
      if (this_geometry == 0) {
        product_orient[n_product] = (rng_uint(world-&gt;rng) &amp; 1) ? 1 : -1;
      } else {
        if (this_geometry &gt; (int)rx-&gt;n_reactants) {
          product_orient[n_product] = relative_orient *
              product_orient[this_geometry - rx-&gt;n_reactants - 1];
        } else if (this_geometry == 1) {
          product_orient[n_product] = relative_orient * orientA;
        } else if (this_geometry == 2 &amp;&amp; reacB != NULL) {
          product_orient[n_product] = relative_orient * orientB;
        } else {
          product_orient[n_product] = relative_orient * 1;
        }
      }

      /* If this is a reactant... */
      if (n_product &lt; (int)rx-&gt;n_reactants) {
        /* If this is a surface molecule, we need to set its orientation. */
        if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
          assert(IS_SURF_MOL(product[n_product]));
          struct surface_molecule *sm =
              (struct surface_molecule *)product[n_product];

          /* If the new orientation doesn't match the old, we've got some work
           * to do. */
          if (sm-&gt;orient != product_orient[n_product]) {

            /* We're about to update the molecule's orientation, so we will
             * first remove it from the counts in case we have any
             * orientation-sensitive counts. Then, we will update the
             * orientation. Finally, we will add the molecule back into the
             * counts in its new orientation. */

            /* Remove molecule from counts in old orientation, if mol is
             * counted. */
            if (product[n_product]-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS|COUNT_ENCLOSED)) {
              count_region_from_scratch(world,
                                        product[n_product], /* molecule */
                                        NULL,               /* rxn pathway */
                                        -1,                 /* remove count */
                                        NULL, /* Location at which to count */
                                        w,    /* Wall on which this happened */
                                        t,    /* Time of occurrence */
                                        NULL);
            }

            /* Force check for the unimolecular reactions
               after changing orientation.
               There are two possible cases to be covered here:
               1) when (sm-&gt;t2) was previously set to FOREVER
               2) there may be two or more unimolecular reactions involving surface
                class that have different kinetics.
             */
            if (((sm-&gt;flags &amp; ACT_REACT) != 0) &amp;&amp;
                ((sm-&gt;properties-&gt;flags &amp; CAN_SURFWALL) != 0)) {
              sm-&gt;t2 = 0;
            }

            /* Set the molecule's orientation. */
            sm-&gt;orient = product_orient[n_product];

            /* Add molecule back to counts in new orientation, if mol is
             * counted. */
            if (product[n_product]-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS|COUNT_ENCLOSED)) {
              count_region_from_scratch(world,
                                        product[n_product], /* molecule */
                                        NULL,               /* rxn pathway */
                                        1,                  /* add count */
                                        NULL, /* Location at which to count */
                                        w,    /* Wall on which this happened */
                                        t,    /* Time of occurrence */
                                        NULL);
            }
          }
        } else if (!is_unimol) { /* Otherwise, check if we've crossed the plane. */
          if (product[n_product] == initiator) {
            if (product_orient[n_product] != initiatorOrient)
              cross_wall = true;
          }
        }
      }
    }

    /* find out where to place surface products */
    /* Some special cases are listed below. */
    if (num_surface_products == 1) {
      if (is_unimol &amp;&amp; replace_p1) {
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if (rx_players[n_product] == NULL ||
             (rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0) {
            continue;
          }

          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
            product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
            product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
            replace_p1 = 0;
            break;
          }
        }
      } else if ((num_surface_static_reactants == 1) &amp;&amp; (num_surface_static_products == 1)
          &amp;&amp; (replace_p1 || replace_p2)) {
        /* the lonely static product always replaces lonely static reactant */
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if (rx_players[n_product] == NULL ||
              (rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0 ||
              distinguishable(rx_players[n_product]-&gt;D, 0, EPS_C)) {
            continue;
          }

          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            if (replace_p1 &amp;&amp; (!distinguishable(reacA-&gt;properties-&gt;D, 0, EPS_C))) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
              product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
              product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
              replace_p1 = 0;
              break;
            } else if (replace_p2 &amp;&amp; (!distinguishable(reacB-&gt;properties-&gt;D, 0, EPS_C))) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
              product_grid[n_product] = ((struct surface_molecule *)reacB)-&gt;grid;
              product_grid_idx[n_product] = ((struct surface_molecule *)reacB)-&gt;grid_index;
              break;
            }
          }
        }
      } else if (replace_p1 &amp;&amp; replace_p2) {
        /* if both reactants should be replaced and there is only one surface product
          here we make sure that the initiator molecule is replaced */
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if ((rx_players[n_product] == NULL) ||
              ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
            continue;
          }

          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            if (reacA == initiator) {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
              product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
              product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
              replace_p1 = 0;
            } else {
              product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
              product_grid[n_product] = ((struct surface_molecule *)reacB)-&gt;grid;
              product_grid_idx[n_product] = ((struct surface_molecule *)reacB)-&gt;grid_index;
            }
            break;
          }
        }
      } else if (replace_p1) {
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if ((rx_players[n_product] == NULL) ||
              ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
            continue;
          }

          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            product_flag[n_product] = PRODUCT_FLAG_USE_REACA_UV;
            product_grid[n_product] = ((struct surface_molecule *)reacA)-&gt;grid;
            product_grid_idx[n_product] = ((struct surface_molecule *)reacA)-&gt;grid_index;
            replace_p1 = 0;
            break;
          }
        }
      } else if (replace_p2) {
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if ((rx_players[n_product] == NULL) |
              ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
            continue;
          }

          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            product_flag[n_product] = PRODUCT_FLAG_USE_REACB_UV;
            product_grid[n_product] = ((struct surface_molecule *)reacB)-&gt;grid;
            product_grid_idx[n_product] = ((struct surface_molecule *)reacB)-&gt;grid_index;
            break;
          }
        }
      }
    } else if (num_surface_products &gt; 1) {
      /* more than one surface products */
      if (num_surface_static_reactants &gt; 0) {
        bool replace_reacA = (!distinguishable(reacA-&gt;get_diffusion(reacA), 0, EPS_C)) &amp;&amp; replace_p1;
        bool replace_reacB =
            (reacB == NULL) ? false : (!distinguishable(reacB-&gt;get_diffusion(reacB), 0, EPS_C)) &amp;&amp; replace_p2;

        if (replace_reacA || replace_reacB) {
          int max_static_count = (num_surface_static_products &lt; num_surface_static_reactants)
            ? num_surface_static_products : num_surface_static_reactants;

          int count = 0;
          while (count &lt; max_static_count) {
            unsigned int rnd_num = rng_uint(world-&gt;rng) % n_players;
            /* pass reactants */
            if ((rnd_num &lt; rx-&gt;n_reactants) || (rx_players[rnd_num] == NULL) ||
                ((rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0) ||
                distinguishable(rx_players[rnd_num]-&gt;D, 0, EPS_C)) {
              continue;
            }
            if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
              if (replace_reacA) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
                product_grid[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid;
                product_grid_idx[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid_index;
                count++;
                replace_p1 = 0;
                replace_reacA = 0;
              } else if (replace_reacB) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
                product_grid[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid;
                product_grid_idx[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid_index;
                count++;
                replace_p2 = 0;
                replace_reacB = 0;
              }
            }
          } /* end while */
        }
      }

      /* check whether there are any surface reactants left to replace with
       * surface products since we are done with static reactants/products */
      if (replace_p1 || replace_p2) {
        int surf_prod_left = 0, surf_reactant_left = 0;
        for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; n_product++) {
          if ((rx_players[n_product] == NULL) ||
              ((rx_players[n_product]-&gt;flags &amp; NOT_FREE) == 0)) {
            continue;
          }
          if (product_flag[n_product] == PRODUCT_FLAG_NOT_SET) {
            surf_prod_left++;
          }
        }
        if (replace_p1) {
          surf_reactant_left++;
        }
        if (replace_p2) {
          surf_reactant_left++;
        }

        if (surf_prod_left &gt; 0) {
          int num_to_place = surf_prod_left;
          if (surf_prod_left &gt;= surf_reactant_left) {
            num_to_place = surf_reactant_left;
          }
          int count = 0;
          while (count &lt; num_to_place) {
            unsigned int rnd_num = rng_uint(world-&gt;rng) % n_players;
            if ((rnd_num &lt; rx-&gt;n_reactants) || (rx_players[rnd_num] == NULL) ||
                (rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0) {
             continue;
            }
            if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
              if (replace_p1) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACA_UV;
                product_grid[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid;
                product_grid_idx[rnd_num] = ((struct surface_molecule *)reacA)-&gt;grid_index;
                count++;
                replace_p1 = 0;
              } else if (replace_p2) {
                product_flag[rnd_num] = PRODUCT_FLAG_USE_REACB_UV;
                product_grid[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid;
                product_grid_idx[rnd_num] = ((struct surface_molecule *)reacB)-&gt;grid_index;
                replace_p2 = 0;
                count++;
              }
            }
          } /* end while */
        }
      }
    }

    /* here we will find placement for the case of the reaction of type
     * &quot;vol_mol + w -&gt; surf_mol + ...[rate] &quot; */
    if ((sm_reactant == NULL) &amp;&amp; (w != NULL) &amp;&amp; (num_surface_products &gt;= 1)) {
      assert(!IS_SURF_MOL(reacA));
      assert(rxn_uv_idx != -1);

      while (true) {
        unsigned int rnd_num = rng_uint(world-&gt;rng) % (n_players);
        if (rnd_num &lt;= 1 || (rx_players[rnd_num] == NULL) ||
            (rx_players[rnd_num]-&gt;flags &amp; NOT_FREE) == 0) {
          continue;
        }

        if (product_flag[rnd_num] == PRODUCT_FLAG_NOT_SET) {
          product_flag[rnd_num] = PRODUCT_FLAG_USE_UV_LOC;
          product_grid[rnd_num] = w-&gt;grid;
          product_grid_idx[rnd_num] = rxn_uv_idx;
          break;
        }
      }
    }

    /* we will implement special placement policy for reaction of type of *
     * A-&gt;B+C[rate] */
    if (is_unimol &amp;&amp; (sm_reactant != NULL) &amp;&amp; (num_surface_products == 2)) {
      reac_idx = sm_reactant-&gt;grid_index;
      reac_grid = sm_reactant-&gt;grid;
    }

    // all other products are placed on one of the randomly chosen vacant tiles 
    int do_it_once = 0; /* flag */
    int num_attempts = 0;
    for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
      /* If the product is a volume product, no placement is required. */
      if (rx_players[n_product]-&gt;flags &amp; ON_GRID) {
        if (product_flag[n_product] != PRODUCT_FLAG_NOT_SET) {
          continue;
        }

        /* can't place products - reaction blocked */
        if (num_vacant_tiles == 0) {
          return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
        }

        num_attempts = 0;
        while (true) {
          if (num_attempts &gt; SURFACE_DIFFUSION_RETRIES) {
            return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
          }

          /* randomly pick a tile from the list */
          unsigned int rnd_num = rng_uint(world-&gt;rng) % num_vacant_tiles;
          int tile_idx = -1; /* index of the tile on the grid */
          tile_grid = NULL;
          if (get_tile_neighbor_from_list_of_vacant_neighbors(
                  tile_vacant_nbr_head, rnd_num, &amp;tile_grid, &amp;tile_idx) == 0) {
            return cleanup_and_block_rx(tile_nbr_head, tile_vacant_nbr_head);
          }
          if (tile_idx &lt; 0) {
            continue; /* this tile was probed already */
          }
          assert(tile_grid != NULL);

          /* make sure we can get to the tile given the surface regions defined
           * in the model */
          //ASSERT_FOR_MCELL4(sm_bitmask == 0); - should not be needed anymore but keeping it as a marker for future debugging
          if (!product_tile_can_be_reached(tile_grid-&gt;surface, rlp_head_wall_1,
            rlp_head_wall_2, rlp_head_obj_1, rlp_head_obj_2, sm_bitmask, is_unimol)) {
            uncheck_vacant_tile(tile_vacant_nbr_head, rnd_num);
            num_attempts++;
            continue;
          }

          product_grid[n_product] = tile_grid;
          product_grid_idx[n_product] = tile_idx;
          product_flag[n_product] = PRODUCT_FLAG_USE_RANDOM;
          if (!do_it_once &amp;&amp; is_unimol &amp;&amp; (sm_reactant != NULL) &amp;&amp; (num_surface_products == 2)) {
            /*remember this tile (used for the reaction A-&gt;B+C[rate]) */
            mol_idx = tile_idx;
            mol_grid = tile_grid;
            do_it_once = 1;
          }
          break;
        } /* end while */
      }
    }
  } /* end if (is_orientable) */

  /* Determine the location of the reaction for count purposes. */
  struct vector3 count_pos_xyz;
  struct periodic_image *periodic_box = ((struct volume_molecule *)reacA)-&gt;periodic_box;
  if (hitpt != NULL) {
    count_pos_xyz = *hitpt;
  } else if (sm_reactant) {
    uv2xyz(&amp;sm_reactant-&gt;s_pos, sm_reactant-&gt;grid-&gt;surface, &amp;count_pos_xyz);
  } else {
    count_pos_xyz = ((struct volume_molecule *)reacA)-&gt;pos;
  }

  /* Create and place each product. */
  struct vector3 mol_pos_tmp;
  struct subvolume *product_subvol = NULL;
  /* Do we need to advance the dissociation index? */
  bool update_dissociation_index = false; 
  for (int n_product = rx-&gt;n_reactants; n_product &lt; n_players; ++n_product) {
    struct graph_data* g_data = NULL;
    if (rx-&gt;product_graph_data != NULL)
      g_data = rx-&gt;product_graph_data[path][n_product - rx-&gt;n_reactants];
    struct abstract_molecule *this_product = NULL;
    struct species *const product_species = rx_players[n_product];

    /* If the product is a surface molecule, place it on the grid. */
    if (product_species-&gt;flags &amp; ON_GRID) {
      struct vector2 prod_uv_pos;

      /* Pick an appropriate position for the new molecule. */
      if (world-&gt;randomize_smol_pos) {
        switch (product_flag[n_product]) {
        case PRODUCT_FLAG_USE_REACA_UV:
          if (is_unimol &amp;&amp; (num_surface_products == 2) &amp;&amp; (sm_reactant != NULL)) {
            if (mol_grid == NULL) {
              mcell_internal_error(&quot;Error in surface product placement for the &quot;
                                   &quot;unimolecular reaction.&quot;);
            }
            find_closest_position(product_grid[n_product], product_grid_idx[n_product],
              mol_grid, mol_idx, &amp;prod_uv_pos);
          } else {
            prod_uv_pos = ((struct surface_molecule *)reacA)-&gt;s_pos;
          }
          break;

        case PRODUCT_FLAG_USE_REACB_UV:
          assert(reacB != NULL);
          prod_uv_pos = ((struct surface_molecule *)reacB)-&gt;s_pos;
          break;

        case PRODUCT_FLAG_USE_UV_LOC:
          prod_uv_pos = rxn_uv_pos;
          break;

        case PRODUCT_FLAG_USE_RANDOM:
          if (is_unimol &amp;&amp; replace_p1 &amp;&amp; (num_surface_products == 2)) {
            find_closest_position(product_grid[n_product],
                                  product_grid_idx[n_product], reac_grid,
                                  reac_idx, &amp;prod_uv_pos);
          } else {
            grid2uv_random(product_grid[n_product], product_grid_idx[n_product],
                           &amp;prod_uv_pos, world-&gt;rng);
          }
          break;

        default:
          UNHANDLED_CASE(product_flag[n_product]);
          /*break;*/
        }
      } else {
        grid2uv(product_grid[n_product], product_grid_idx[n_product], &amp;prod_uv_pos);
      }

      this_product = (struct abstract_molecule *)place_sm_product(
          world, product_species, g_data, product_grid[n_product],
          product_grid_idx[n_product], &amp;prod_uv_pos, product_orient[n_product],
          t, reacA-&gt;periodic_box);

#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
          dump_surface_molecule((struct surface_molecule*)this_product, &quot;&quot;, true, &quot;  created sm:&quot;, world-&gt;current_iterations, this_product-&gt;t, true);
      );
#endif

    } else { /* else place the molecule in space. */
      /* For either a unimolecular reaction, or a reaction between two surface
         molecules we don't have a hitpoint. */
      if (!hitpt) {
        if (reacA-&gt;properties-&gt;flags &amp; ON_GRID) {
          /* Since we use reactA's position to compute the location of the reaction
             we also need to use its wall for picking the displacement later in
             place_volume_products */
          w = ((struct surface_molecule *)reacA)-&gt;grid-&gt;surface;
          uv2xyz(&amp;((struct surface_molecule *)reacA)-&gt;s_pos,
                 w, &amp;mol_pos_tmp);
          product_subvol = find_subvolume(world, &amp;mol_pos_tmp, NULL);
        } else {
          mol_pos_tmp = ((struct volume_molecule *)reacA)-&gt;pos;
          product_subvol = ((struct volume_molecule *)reacA)-&gt;subvol;
        }
        hitpt = &amp;mol_pos_tmp;
      } else if (product_subvol == NULL) {
        product_subvol = find_subvolume(world, hitpt, NULL);
      }

      this_product = (struct abstract_molecule *)place_volume_product(
          world, product_species, g_data, sm_reactant, w, product_subvol, hitpt,
          product_orient[n_product], t, reacA-&gt;periodic_box);

#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
      		dump_volume_molecule((struct volume_molecule*)this_product, &quot;&quot;, true, &quot;  created vm:&quot;, world-&gt;current_iterations, this_product-&gt;t, true);
      );
#endif

      if (((struct volume_molecule *)this_product)-&gt;index &lt; DISSOCIATION_MAX)
        update_dissociation_index = true;
    }

    /* Provide new molecule with graph information if it exists */
    if(rx-&gt;product_graph_data != NULL){
      this_product-&gt;graph_data = g_data;
    }


    /* Update molecule counts */
    ++product_species-&gt;population;
    if (product_species-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED))
      count_region_from_scratch(world, this_product, NULL, 1, NULL, NULL, t, this_product-&gt;periodic_box);

#ifndef MCELL3_DO_NOT_REUSE_MOL_ID_UNIMOL_RXN
    /* preserve molecule id if rxn is unimolecular with one product */
    if (is_unimol &amp;&amp; (n_players == 1)) {
      this_product-&gt;id = reacA-&gt;id;
      world-&gt;current_mol_id--; /* give back id we used */
      continue;
    }
    /* preserve molecule id if rxn is surface rxn with one product */
    if ((n_players == 3) &amp;&amp; product_type[1] == PLAYER_WALL) {
      this_product-&gt;id = reacA-&gt;id;
      world-&gt;current_mol_id--; /* give back id we used */
      continue;
    }
#endif
  }

  /* If necessary, update the dissociation index. */
  if (update_dissociation_index) {
    ASSERT_FOR_MCELL4(false);
    if (--world-&gt;dissociation_index &lt; DISSOCIATION_MIN)
      world-&gt;dissociation_index = DISSOCIATION_MAX;
  }

  /* Handle events triggered off of named reactions */
  if (rx-&gt;info[path].pathname != NULL) {
    /* No flags for reactions so we have to check regions if we have waypoints!
     * Fix to be more efficient for WORLD-only counts? */
    if (world-&gt;place_waypoints_flag)
      count_region_from_scratch(world, NULL, rx-&gt;info[path].pathname, 1,
                                &amp;count_pos_xyz, w, t, periodic_box);

    /* Other magical stuff.  For now, can only trigger releases. */
    if (rx-&gt;info[path].pathname-&gt;magic != NULL) {
      if (reaction_wizardry(world, rx-&gt;info[path].pathname-&gt;magic, w,
                            &amp;count_pos_xyz, t))
        mcell_allocfailed(&quot;Failed to complete reaction triggered release after &quot;
                          &quot;a '%s' reaction.&quot;,
                          rx-&gt;info[path].pathname-&gt;sym-&gt;name);
    }
  }

  /* recover memory */
  delete_tile_neighbor_list(tile_nbr_head);
  delete_tile_neighbor_list(tile_vacant_nbr_head);
  delete_region_list(rlp_head_wall_1);
  delete_region_list(rlp_head_wall_2);
  delete_region_list(rlp_head_obj_1);
  delete_region_list(rlp_head_obj_2);

  return cross_wall ? RX_FLIP : RX_A_OK;
}



/*************************************************************************
outcome_unimolecular:
  In: world: simulation state
      rx: the reaction that is occuring
      path: the path that the reaction is taking
      reac: the molecule that is taking that path
      t: time that the reaction is occurring
  Out: Value based on outcome:
       RX_BLOCKED if there was no room to put products on grid
       RX_DESTROY if molecule no longer exists.
       RX_A_OK if it does.
       Products are created as needed.
*************************************************************************/
int outcome_unimolecular(struct volume *world, struct rxn *rx, int path,
                         struct abstract_molecule *reac, double t) {
  struct species *who_was_i = reac-&gt;properties;
  int result = RX_A_OK;
  struct volume_molecule *vm = NULL;
  struct surface_molecule *sm = NULL;
  //JJT: if this is a molecule marked as external leave it up to nfsim
  /*if(reac-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
    vm = (struct volume_molecule *)reac;
    //outcome_unimolecular_nfsim(world, rx, path, reac, t);
    outcome_nfsim(world, rx, path, reac, NULL, t);

    result = outcome_products_random(world, NULL, NULL, t, rx, path, reac, NULL, 0, 0);
  }*/
  if ((reac-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
    vm = (struct volume_molecule *)reac;

    //NFSim calculation
    if(reac-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
#if 0 // just to dump the whole rxn, fails later for some reason..
      // populate all pathways
      for (int path = 0; path &lt; rx-&gt;n_pathways; path++) {
        outcome_nfsim(world, rx, path, reac, NULL, t);
      }
#else
      outcome_nfsim(world, rx, path, reac, NULL, t);
#endif
    }
    result = outcome_products_random(world, NULL, NULL, t, rx, path, reac,
                                       NULL, 0, 0);
  } else {
    sm = (struct surface_molecule *)reac;
      /* we will not create products if the reaction is with an ABSORPTIVE
         region border */

      if ((strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, &quot;ALL_SURFACE_MOLECULES&quot;) == 0) ||
          (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, &quot;ALL_MOLECULES&quot;) == 0)) {
        /* do nothing */
      } else {
        //NFSim calculations
        if(reac-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
          outcome_nfsim(world, rx, path, reac, NULL, t);
        }
        result = outcome_products_random(world, sm-&gt;grid-&gt;surface, NULL, t, rx,
                                         path, reac, NULL, sm-&gt;orient, 0);
      }
  }

  if (result == RX_BLOCKED)
    return RX_BLOCKED;

  if (result != RX_BLOCKED) {
    rx-&gt;info[path].count++;
    rx-&gt;n_occurred++;
    if(rx-&gt;product_graph_data != NULL){
      logNFSimReactions_c(rx-&gt;external_reaction_data[path].reaction_name);

    }
  }

  struct species *who_am_i = rx-&gt;players[rx-&gt;product_idx[path]];

  if (who_am_i == NULL) {
    if (vm != NULL) {
      vm-&gt;subvol-&gt;mol_count--;
      if (vm-&gt;flags &amp; IN_SCHEDULE)
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      if (vm-&gt;properties-&gt;flags &amp; COUNT_SOME_MASK) {
        count_region_from_scratch(world, (struct abstract_molecule *)vm, NULL,
                                  -1, &amp;(vm-&gt;pos), NULL, vm-&gt;t, vm-&gt;periodic_box);
      }
    } else {
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
        dump_surface_molecule(sm, &quot;&quot;, true, &quot;Unimolecular sm defunct:&quot;, world-&gt;current_iterations, sm-&gt;t, false);
      );
#endif
      remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
      sm-&gt;grid-&gt;n_occupied--;
      if (sm-&gt;flags &amp; IN_SCHEDULE) {
        sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
      if (sm-&gt;properties-&gt;flags &amp; COUNT_SOME_MASK) {
        count_region_from_scratch(world, (struct abstract_molecule *)sm, NULL,
                                  -1, NULL, NULL, sm-&gt;t, sm-&gt;periodic_box);
      }
    }

    free(reac-&gt;periodic_box);
    who_was_i-&gt;n_deceased++;
    double t_time = convert_iterations_to_seconds(
        world-&gt;start_iterations, world-&gt;time_unit,
        world-&gt;simulation_start_seconds, t);
    who_was_i-&gt;cum_lifetime_seconds += t_time - reac-&gt;birthday;

    who_was_i-&gt;population--;
    if (vm != NULL) {
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
        dump_volume_molecule(vm, &quot;&quot;, true, &quot;Unimolecular vm defunct:&quot;, world-&gt;current_iterations, vm-&gt;t, false);
      );
#endif
      collect_molecule(vm);
    }
    else {
      reac-&gt;properties = NULL;
      mem_put(reac-&gt;birthplace, reac);
    }
    return RX_DESTROY;
  } else if (who_am_i != who_was_i) {
    if (vm != NULL) {
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
        dump_volume_molecule(vm, &quot;&quot;, true, &quot;Unimolecular vm defunct:&quot;, world-&gt;current_iterations, vm-&gt;t, false);
      );
#endif
      collect_molecule(vm);
    }
    else
      reac-&gt;properties = NULL;
    return RX_DESTROY;
  } else
    return result;
}

/*************************************************************************
outcome_bimolecular:
  In: reaction that's occurring
      path the reaction's taking
      two molecules that are reacting (first is moving one)
      orientations of the two molecules
      time that the reaction is occurring
      location of collision between molecules
  Out: Value based on outcome:
       RX_BLOCKED if there was no room to put products on grid
       RX_FLIP if the molecule goes across the membrane
       RX_DESTROY if the molecule no longer exists
       RX_A_OK if everything proceeded smoothly
       Products are created as needed.
  Note: reacA is the triggering molecule (e.g. moving)
*************************************************************************/
int outcome_bimolecular(struct volume *world, struct rxn *rx, int path,
                        struct abstract_molecule *reacA,
                        struct abstract_molecule *reacB, short orientA,
                        short orientB, double t, struct vector3 *hitpt,
                        struct vector3 *loc_okay) {
#ifdef DEBUG_TIMING
  DUMP_CONDITION3(
      MCell::dump_outcome_bimolecular_timing(t);
  );
#endif

  assert(periodic_boxes_are_identical(reacA-&gt;periodic_box, reacB-&gt;periodic_box));

  struct surface_molecule *sm = NULL;
  struct volume_molecule *vm = NULL;
  struct wall *w = NULL;
  /* struct storage *x; */
  int result;
  int reacB_was_free = 0;
  int killA, killB;

  if ((reacA-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
    if ((reacB-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
      sm = (struct surface_molecule *)reacB;
      w = sm-&gt;grid-&gt;surface;
    }
  } else { /* Surface molecule */
    sm = (struct surface_molecule *)reacA;
    w = sm-&gt;grid-&gt;surface;
  }

  //JJT: if this is a molecule marked as external leave it up to nfsim
  if(reacA-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
    result = outcome_nfsim(world, rx, path, reacA, reacB, t);
    result = outcome_products_random(world, w, hitpt, t, rx, path, reacA, reacB,
                                     orientA, orientB);
  }

  else {
    result = outcome_products_random(world, w, hitpt, t, rx, path, reacA, reacB,
                                     orientA, orientB);
  }

  if (result == RX_BLOCKED)
    return RX_BLOCKED;

  rx-&gt;n_occurred++;
  rx-&gt;info[path].count++;
  if(rx-&gt;product_graph_data != NULL){
    logNFSimReactions_c(rx-&gt;external_reaction_data[path].reaction_name);
  }

  /* Figure out if either of the reactants was destroyed */
  if (rx-&gt;players[0] == reacA-&gt;properties) {
    killB = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
    killA = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
  } else {
    killB = (rx-&gt;players[rx-&gt;product_idx[path]] == NULL);
    killA = (rx-&gt;players[rx-&gt;product_idx[path] + 1] == NULL);
  }

  if (killB) {
#ifdef DEBUG_RXNS
    DUMP_CONDITION3(
      dump_volume_molecule((struct volume_molecule*)reacB, &quot;&quot;, true, &quot;  defunct m:&quot;, world-&gt;current_iterations, 0.0, false);
    );
#endif

    vm = NULL;
    if ((reacB-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
      sm = (struct surface_molecule *)reacB;

      remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
      sm-&gt;grid-&gt;n_occupied--;
      if (sm-&gt;flags &amp; IN_SURFACE)
        sm-&gt;flags -= IN_SURFACE;
      if (sm-&gt;flags &amp; IN_SCHEDULE) {
        sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
    } else if ((reacB-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
      vm = (struct volume_molecule *)reacB;
      vm-&gt;subvol-&gt;mol_count--;
      if (vm-&gt;flags &amp; IN_SCHEDULE) {
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
      reacB_was_free = 1;
    }

    if ((reacB-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) != 0) {
      count_region_from_scratch(world, reacB, NULL, -1, NULL, NULL, t, reacB-&gt;periodic_box);
    }

    free(reacB-&gt;periodic_box);
    reacB-&gt;periodic_box = NULL;
    reacB-&gt;properties-&gt;n_deceased++;
    double t_time = convert_iterations_to_seconds(
        world-&gt;start_iterations, world-&gt;time_unit,
        world-&gt;simulation_start_seconds, t);
    reacB-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacB-&gt;birthday;
    reacB-&gt;properties-&gt;population--;

    if (vm != NULL)
      collect_molecule(vm);
    else
      reacB-&gt;properties = NULL;
  }

  if (killA) {
#ifdef DEBUG_RXNS
    DUMP_CONDITION3(
      dump_volume_molecule((struct volume_molecule*)reacA, &quot;&quot;, true, &quot;  defunct m:&quot;, world-&gt;current_iterations, 0.0, false);
    );
#endif

    vm = NULL;
    if ((reacA-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
      sm = (struct surface_molecule *)reacA;

      remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
      sm-&gt;grid-&gt;n_occupied--;
      if (sm-&gt;flags &amp; IN_SCHEDULE) {
        sm-&gt;grid-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
    } else if ((reacA-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
      vm = (struct volume_molecule *)reacA;
      vm-&gt;subvol-&gt;mol_count--;
      if (vm-&gt;flags &amp; IN_SCHEDULE) {
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
    }

    if ((reacA-&gt;properties-&gt;flags &amp; ON_GRID) !=
        0) /* Surface molecule is OK where it is, doesn't obey COUNT_ME */
    {
      if (reacA-&gt;properties-&gt;flags &amp;
          COUNT_SOME_MASK) /* If we're ever counted, try to count us now */
      {
        count_region_from_scratch(world, reacA, NULL, -1, NULL, NULL, t, reacA-&gt;periodic_box);
      }
    } else if (reacA-&gt;flags &amp; COUNT_ME) {
      /* Subtlety: we made it up to hitpt, but our position is wherever we were
       * before that! */
      if (hitpt == NULL || reacB_was_free ||
          (reacB-&gt;properties != NULL &amp;&amp;
           (reacB-&gt;properties-&gt;flags &amp; NOT_FREE) == 0)) {
        /* Vol-vol rx should be counted at hitpt */
        count_region_from_scratch(world, reacA, NULL, -1, hitpt, NULL, t, reacA-&gt;periodic_box);
      } else /* Vol-surf but don't want to count exactly on a wall or we might
                count on the wrong side */
      {
        struct vector3 fake_hitpt;

        vm = (struct volume_molecule *)reacA;

        /* Halfway in between where we were and where we react should be a safe
         * away-from-wall place to remove us */
        if (loc_okay == NULL)
          loc_okay = &amp;(vm-&gt;pos);
        fake_hitpt.x = 0.5 * hitpt-&gt;x + 0.5 * loc_okay-&gt;x;
        fake_hitpt.y = 0.5 * hitpt-&gt;y + 0.5 * loc_okay-&gt;y;
        fake_hitpt.z = 0.5 * hitpt-&gt;z + 0.5 * loc_okay-&gt;z;

        count_region_from_scratch(world, reacA, NULL, -1, &amp;fake_hitpt, NULL, t, reacA-&gt;periodic_box);
      }
    }

    free(reacA-&gt;periodic_box);
    reacA-&gt;periodic_box = NULL;
    reacA-&gt;properties-&gt;n_deceased++;
    double t_time = convert_iterations_to_seconds(
        world-&gt;start_iterations, world-&gt;time_unit,
        world-&gt;simulation_start_seconds, t);
    reacA-&gt;properties-&gt;cum_lifetime_seconds += t_time - reacA-&gt;birthday;
    reacA-&gt;properties-&gt;population--;

    if (vm != NULL)
      collect_molecule(vm);
    else
      reacA-&gt;properties = NULL;

    return RX_DESTROY;
  }

  return result;
}

/*************************************************************************
outcome_intersect:
  In: world: simulation state
      rx: reaction that's taking place
      path: path the reaction's taking
      surface: wall that is being struck
      reac: molecule that is hitting the wall
      orient: orientation of the molecule
      t: time that the reaction is occurring
      hitpt: location of collision with wall
      loc_okay:
  Out: Value depending on outcome:
       RX_A_OK if the molecule reflects
       RX_FLIP if the molecule passes through
       RX_DESTROY if the molecule stops, is destroyed, etc.
       Additionally, products are created as needed.
  Note: Can assume molecule is always first in the reaction.
*************************************************************************/
int outcome_intersect(struct volume *world, struct rxn *rx, int path,
                      struct wall *surface, struct abstract_molecule *reac,
                      short orient, double t, struct vector3 *hitpt,
                      struct vector3 *loc_okay) {

  if (rx-&gt;n_pathways &lt;= RX_SPECIAL) {
    rx-&gt;n_occurred++;
    if (rx-&gt;n_pathways == RX_REFLEC)
      return RX_A_OK;
    else
      return RX_FLIP; /* Flip = transparent is default special case */
  }
  int idx = rx-&gt;product_idx[path];

  if ((reac-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
    struct volume_molecule *vm = (struct volume_molecule *)reac;

    /* If reaction object has ALL_MOLECULES or ALL_VOLUME_MOLECULES as the
     * first reactant it means that reaction is of the type ABSORPTIVE =
     * ALL_MOLECULES or ABSORPTIVE = ALL_VOLUME_MOLECULES since other cases
     * (REFLECTIVE/TRANSPARENT) are taken care above. But there are no products
     * for this reaction, so we do no need to go into &quot;outcome_products()&quot;
     * function. */

    int result;
    if ((strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, &quot;ALL_MOLECULES&quot;) == 0) ||
        (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, &quot;ALL_VOLUME_MOLECULES&quot;) == 0)) {
      result = RX_DESTROY;
    } else {
      result = outcome_products_random(world, surface, hitpt, t, rx, path,
                                       reac, NULL, orient, 0);
    }
    if (result == RX_BLOCKED)
      return RX_A_OK; /* reflect the molecule */

    rx-&gt;info[path].count++;
    rx-&gt;n_occurred++;

    if (rx-&gt;players[idx] == NULL) {
      /* The code below is also valid for the special reaction of the type
       * ABSORPTIVE = ALL_MOLECULES (or ALL_VOLUME_MOLECULES) */
      vm-&gt;subvol-&gt;mol_count--;
      if (world-&gt;place_waypoints_flag &amp;&amp; (reac-&gt;flags &amp; COUNT_ME)) {
        if (hitpt == NULL) {
          count_region_from_scratch(
            world, reac, NULL, -1, NULL, NULL, t, reac-&gt;periodic_box);
        } else {
          struct vector3 fake_hitpt;

          /* Halfway in between where we were and where we react should be a
           * safe away-from-wall place to remove us */
          if (loc_okay == NULL)
            loc_okay = &amp;(vm-&gt;pos);
          fake_hitpt.x = 0.5 * hitpt-&gt;x + 0.5 * loc_okay-&gt;x;
          fake_hitpt.y = 0.5 * hitpt-&gt;y + 0.5 * loc_okay-&gt;y;
          fake_hitpt.z = 0.5 * hitpt-&gt;z + 0.5 * loc_okay-&gt;z;

          count_region_from_scratch(world, reac, NULL, -1, &amp;fake_hitpt, NULL,
                                    t, reac-&gt;periodic_box);
        }
      }
      free(reac-&gt;periodic_box);
      reac-&gt;properties-&gt;n_deceased++;
      double t_time = convert_iterations_to_seconds(
          world-&gt;start_iterations, world-&gt;time_unit,
          world-&gt;simulation_start_seconds, t);
      reac-&gt;properties-&gt;cum_lifetime_seconds += t_time - reac-&gt;birthday;
      reac-&gt;properties-&gt;population--;
      if (vm-&gt;flags &amp; IN_SCHEDULE) {
        vm-&gt;subvol-&gt;local_storage-&gt;timer-&gt;defunct_count++;
      }
#ifdef DEBUG_RXNS
      DUMP_CONDITION3(
         dump_volume_molecule((struct volume_molecule*)vm, &quot;&quot;, true, &quot;  defunct m:&quot;, world-&gt;current_iterations, 0.0, false);
      );
#endif
      collect_molecule(vm);
      return RX_DESTROY;
    } else
      return result; /* RX_A_OK or RX_FLIP */
  } else {
    /* Should really be an error because we should never call
     * outcome_intersect() on a surface molecule */
    return RX_A_OK;
  }
}

/*************************************************************************
reaction_wizardry:
  In: a list of releases to magically cause
      the wall associated with the release, if any
      the location of the release
      the time of the release
  Out: 0 if successful, 1 on failure (usually out of memory).
       Each release event in the list is triggered at a location that
       is relative to the location of the release and the surface normal
       of the wall.  The surface normal of the wall is considered to be
       the +Z direction.  Other coordinates are rotated in the &quot;natural&quot;
       way (i.e. the XYZ coordinate system has the Z-axis rotated directly
       to the direction of the normal and the other coordinates follow
       along naturally; if the normal is in the -Z direction, the rotation
       is about the X-axis.)
  Note: this function isn't all that cheap computationally because of
        all the math required to compute the right coordinate transform.
        If this gets really really heavily used, we should store the
        coordinate transform off of the wall data structure.
  Note: it would be more efficient to skip calculating the transform if
        the release type didn't use it (e.g. release by region).
  Note: if we wanted to be extra-super clever, we could actually schedule
        this event instead of running it and somehow have it start a
        time-shifted release pattern (so we could have delays and stuff).
*************************************************************************/
int reaction_wizardry(struct volume *world, struct magic_list *incantation,
                      struct wall *surface, struct vector3 *hitpt, double t) {
  struct release_event_queue req; /* Create a release event on the fly */

  /* Release event happens &quot;now&quot; */
  req.next = NULL;
  req.event_time = t;
  req.train_counter = 0;
  req.train_high_time = t;

  /* Set up transform to place products at site of reaction */
  if (hitpt == NULL) {
    init_matrix(req.t_matrix);
  } else if (surface == NULL ||
             !distinguishable(surface-&gt;normal.z, 1.0,
                              EPS_C)) /* Just need a translation */
  {
    init_matrix(req.t_matrix);
    req.t_matrix[3][0] = hitpt-&gt;x;
    req.t_matrix[3][1] = hitpt-&gt;y;
    req.t_matrix[3][2] = hitpt-&gt;z;
  } else /* Set up transform that will translate and then rotate Z axis to align
            with surface normal */
  {
    struct vector3 scale = { 1.0, 1.0, 1.0 }; /* No scaling */
    struct vector3 axis = { 1.0, 0.0, 0.0 };  /* X-axis is default */
    double cos_theta;
    double degrees;

    cos_theta = surface-&gt;normal.z; /* (0,0,1) . surface-&gt;normal */
    if (!distinguishable(cos_theta, -1.0, EPS_C)) {
      degrees = 180.0; /* Upside-down */
    } else {
      /* (0,0,1) x surface-&gt;normal */
      axis.x = -surface-&gt;normal.y;
      axis.y = surface-&gt;normal.x;
      axis.z = 0.0;

      degrees = acos(cos_theta) * 180.0 / MY_PI;
    }
    tform_matrix(&amp;scale, hitpt, &amp;axis, degrees, req.t_matrix);
  }

  /* Now we're ready to cast our spell! */
  for (; incantation != NULL; incantation = incantation-&gt;next) {
    if (incantation-&gt;type != magic_release)
      continue; /* Only know how to magically release stuff */

    req.release_site = (struct release_site_obj *)incantation-&gt;data;

    if (release_molecules(world, &amp;req))
      return 1;
  }

  return 0;
}

/************************************************************************
 *
 * this function determines where reactants grid1 and grid2 are located
 * (inside/outside) with respect to their restrictive region borders if
 * they have any.
 *
 * in: surface molecule 1 (located on wall 1)
 *     surface molecule 2 (located on wall 2)
 *     pointer to array with restrictive regions which contain wall 1
 *     pointer to array with restrictive regions which contain wall 2
 *     pointer to array with restrictive regions which don't contain wall 1
 *     pointer to array with restrictive regions which don't contain wall 2
 *
 * out: the 4 arrays with pointers to restrictive regions will be filled
 *      and returned
 *
 ***********************************************************************/
int determine_molecule_region_topology(
    struct volume *world, struct surface_molecule *sm_1,
    struct surface_molecule *sm_2, struct region_list **rlp_wall_1_ptr,
    struct region_list **rlp_wall_2_ptr, struct region_list **rlp_obj_1_ptr,
<A NAME="1"></A>    struct region_list **rlp_obj_2_ptr, bool is_unimol) {
  int sm_bitmask = 0;
  struct wall *w_1, *w_2;
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1323-1.html#1',3,'match1323-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  struct region_list *rlp_head_wall_1 = NULL;
  struct region_list *rlp_head_wall_2 = NULL;
  struct region_list *rlp_head_obj_1 = NULL;
  struct region_list *rlp_head_obj_2 = NULL;</B></FONT>

  /* bimolecular reactions */
  if ((sm_1 != NULL) &amp;&amp; (sm_2 != NULL)) {
    /* both reactants have restrictive region borders */
    if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
        (sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
        are_restricted_regions_for_species_on_object(
            world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
        are_restricted_regions_for_species_on_object(
            world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2)) {
      w_1 = sm_1-&gt;grid-&gt;surface;
      w_2 = sm_2-&gt;grid-&gt;surface;
      rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
      rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);

      /* both reactants are inside their respective restricted regions */
      if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 != NULL)) {
        sm_bitmask |= ALL_INSIDE;
      }
      /* both reactants are outside their respective restricted regions */
      else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 == NULL)) {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        sm_bitmask |= ALL_OUTSIDE;
      }
      /* grid1 is inside and grid2 is outside of its respective
       * restrictive region */
      else if ((rlp_head_wall_1 != NULL) &amp;&amp; (rlp_head_wall_2 == NULL)) {
        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        sm_bitmask |= SURF1_IN_SURF2_OUT;
      }
      /* grid2 is inside and grid1 is outside of its respective
       * restrictive region */
      else if ((rlp_head_wall_1 == NULL) &amp;&amp; (rlp_head_wall_2 != NULL)) {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        sm_bitmask |= SURF1_OUT_SURF2_IN;
      }
    }

    /* only reactant sm_1 has restrictive region border property */
    else if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
             are_restricted_regions_for_species_on_object(
                 world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1) &amp;&amp;
             (!(sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
              !are_restricted_regions_for_species_on_object(
<A NAME="0"></A>                   world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2))) {
      w_1 = sm_1-&gt;grid-&gt;surface;
      rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1323-1.html#0',3,'match1323-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>      if (rlp_head_wall_1 != NULL) {
        sm_bitmask |= SURF1_IN;
      } else {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        sm_bitmask |= SURF1_OUT;
      }
    }

    /* only reactant &quot;sm_2&quot; has restrictive region border property */
    else if ((sm_2-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
             are_restricted_regions_for_species_on_object(
                 world, sm_2-&gt;grid-&gt;surface-&gt;parent_object, sm_2) &amp;&amp;
             (!(sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
              !are_restricted_regions_for_species_on_object(
                   world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1))) {</B></FONT>
      w_2 = sm_2-&gt;grid-&gt;surface;
      rlp_head_wall_2 = find_restricted_regions_by_wall(world, w_2, sm_2);
      if (rlp_head_wall_2 != NULL) {
        sm_bitmask |= SURF2_IN;
      } else {
        rlp_head_obj_2 =
            find_restricted_regions_by_object(world, w_2-&gt;parent_object, sm_2);
        sm_bitmask |= SURF2_OUT;
      }
    }
  }

  /* unimolecular reactions */
  else if ((sm_1 != NULL) &amp;&amp; is_unimol) {
    if ((sm_1-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) &amp;&amp;
        are_restricted_regions_for_species_on_object(
            world, sm_1-&gt;grid-&gt;surface-&gt;parent_object, sm_1)) {
      w_1 = sm_1-&gt;grid-&gt;surface;
      rlp_head_wall_1 = find_restricted_regions_by_wall(world, w_1, sm_1);
      if (rlp_head_wall_1 != NULL) {
        sm_bitmask |= ALL_INSIDE;
      } else {
        rlp_head_obj_1 =
            find_restricted_regions_by_object(world, w_1-&gt;parent_object, sm_1);
        sm_bitmask |= ALL_OUTSIDE;
      }
    }
  }

  *rlp_wall_1_ptr = rlp_head_wall_1;
  *rlp_wall_2_ptr = rlp_head_wall_2;
  *rlp_obj_1_ptr = rlp_head_obj_1;
  *rlp_obj_2_ptr = rlp_head_obj_2;

  return sm_bitmask;
}

/***********************************************************************
 *
 * this function tests if wall target can be reached for product placement
 * based on the previously stored reactant topology based on
 * sm_bitmask. Below, wall 1 is the wall containing reactant 1 and
 * wall 2 is the wall containing reactant 2.
 *
 * in: wall to test for product placement
 *     pointer to array with regions that contain wall 1
 *     pointer to array with regions that contain wall 2
 *     pointer to array with regions that do not contain wall 1
 *     pointer to array with regions that do not contain wall 2
 *
 * out: returns true or false depending if wall target can be
 *      used for product placement.
 *
 ***********************************************************************/
bool product_tile_can_be_reached(struct wall *target,
                                 struct region_list *rlp_head_wall_1,
                                 struct region_list *rlp_head_wall_2,
                                 struct region_list *rlp_head_obj_1,
                                 struct region_list *rlp_head_obj_2,
                                 int sm_bitmask, bool is_unimol) {
  bool status = true;

  if (sm_bitmask &amp; ALL_INSIDE) {
    if (is_unimol) {
      if (!wall_belongs_to_all_regions_in_region_list(target,
                                                      rlp_head_wall_1)) {
        status = false;
      }
    } else {
      /* bimol reaction */
      if (!wall_belongs_to_all_regions_in_region_list(target,
                                                      rlp_head_wall_1) ||
          !wall_belongs_to_all_regions_in_region_list(target,
                                                      rlp_head_wall_2)) {
        status = false;
      }
    }
  } else if (sm_bitmask &amp; ALL_OUTSIDE) {
    if (is_unimol) {
      if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1)) {
        status = false;
      }
    } else {
      if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1) ||
          wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_2)) {
        status = false;
      }
    }
  } else if (sm_bitmask &amp; SURF1_IN_SURF2_OUT) {
    if (!wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_1) ||
        wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_2)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF1_OUT_SURF2_IN) {
    if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1) ||
        !wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_2)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF1_IN) {
    if (!wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_1)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF1_OUT) {
    if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_1)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF2_IN) {
    if (!wall_belongs_to_all_regions_in_region_list(target, rlp_head_wall_2)) {
      status = false;
    }
  } else if (sm_bitmask &amp; SURF2_OUT) {
    if (wall_belongs_to_any_region_in_region_list(target, rlp_head_obj_2)) {
      status = false;
    }
  }

  return status;
}

/*
 * cleanup_and_block_rx is a simple helper function which deletes the provided
 * linked lists of tile_neighbors and the return RX_BLOCKED
 */
int cleanup_and_block_rx(struct tile_neighbor *tn1, struct tile_neighbor *tn2) {
  if (tn1 != NULL) {
    delete_tile_neighbor_list(tn1);
  }
  if (tn2 != NULL) {
    delete_tile_neighbor_list(tn2);
  }
  return RX_BLOCKED;
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>grid_util.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/******************************************************************************
 *
 * Copyright (C) 2006-2017 by
 * The Salk Institute for Biological Studies and
 * Pittsburgh Supercomputing Center, Carnegie Mellon University
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 *
******************************************************************************/

/**************************************************************************\
** File: grid_util.c                                                      **
**                                                                        **
** Purpose: Translates between 3D world coordinates and surface grid index**
**                                                                        **
** Testing status: partially tested (validate_grid_util.c).               **
\**************************************************************************/

#include &quot;config.h&quot;

#include &lt;math.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;vector&gt;

#include &quot;logging.h&quot;
#include &quot;rng.h&quot;
#include &quot;grid_util.h&quot;
#include &quot;vol_util.h&quot;
#include &quot;wall_util.h&quot;
#include &quot;react.h&quot;
#include &quot;init.h&quot;

#include &quot;debug_config.h&quot;
#include &quot;dump_state.h&quot;

/*************************************************************************
xyz2uv and uv2xyz:
  In: 2D and 3D vectors and a wall
  Out: first vector is converted to 2nd vector
       WARNING: no error checking--point assumed to be valid!
*************************************************************************/
void xyz2uv(struct vector3 *a, struct wall *w, struct vector2 *b) {
  if (w-&gt;grid) {
    b-&gt;u = a-&gt;x * w-&gt;unit_u.x + a-&gt;y * w-&gt;unit_u.y + a-&gt;z * w-&gt;unit_u.z -
           w-&gt;grid-&gt;vert0.u;
    b-&gt;v = a-&gt;x * w-&gt;unit_v.x + a-&gt;y * w-&gt;unit_v.y + a-&gt;z * w-&gt;unit_v.z -
           w-&gt;grid-&gt;vert0.v;
  } else {
    struct vector3 p;
    p.x = a-&gt;x - w-&gt;vert[0]-&gt;x;
    p.y = a-&gt;y - w-&gt;vert[0]-&gt;y;
    p.z = a-&gt;z - w-&gt;vert[0]-&gt;z;
    b-&gt;u = p.x * w-&gt;unit_u.x + p.y * w-&gt;unit_u.y + p.z * w-&gt;unit_u.z;
    b-&gt;v = p.x * w-&gt;unit_v.x + p.y * w-&gt;unit_v.y + p.z * w-&gt;unit_v.z;
  }
}

void uv2xyz(struct vector2 *a, struct wall *w, struct vector3 *b) {
  b-&gt;x = a-&gt;u * w-&gt;unit_u.x + a-&gt;v * w-&gt;unit_v.x + w-&gt;vert[0]-&gt;x;
  b-&gt;y = a-&gt;u * w-&gt;unit_u.y + a-&gt;v * w-&gt;unit_v.y + w-&gt;vert[0]-&gt;y;
  b-&gt;z = a-&gt;u * w-&gt;unit_u.z + a-&gt;v * w-&gt;unit_v.z + w-&gt;vert[0]-&gt;z;
}

/*************************************************************************
xyz2grid and uv2grid:
  In: a vector and a surface grid
  Out: int containing the index on the grid of that vector
  Note: xyz2grid just does a dot-product to uv coordinates first.
        Error checking for a valid point is done.
*************************************************************************/
int xyz2grid(struct vector3 *v, struct surface_grid *g) {
  struct vector3 *unit_u = &amp;(g-&gt;surface-&gt;unit_u);
  struct vector3 *unit_v = &amp;(g-&gt;surface-&gt;unit_v);
  double i, j;
  double u0, u1_u0;
  double striploc, striprem, stripeloc, striperem;
  int strip, stripe, flip, idx;
  int tile_idx_0, tile_idx_mid, tile_idx_last;

  if (g-&gt;n_tiles == 1)
    return 0;

  /* find tile indices of the corner tiles */
  tile_idx_0 = 0;
  /* see function &quot;move_strip_up()&quot; */
  tile_idx_mid = g-&gt;n_tiles - 2 * (g-&gt;n) + 1;
  tile_idx_last = g-&gt;n_tiles - 1;

  if (!(distinguishable_vec3(v, g-&gt;surface-&gt;vert[0], EPS_C)))
    return tile_idx_mid;
  if (!(distinguishable_vec3(v, g-&gt;surface-&gt;vert[1], EPS_C)))
    return tile_idx_last;
  if (!(distinguishable_vec3(v, g-&gt;surface-&gt;vert[2], EPS_C)))
    return tile_idx_0;

  if (!(point_in_triangle(v, g-&gt;surface-&gt;vert[0], g-&gt;surface-&gt;vert[1],
                          g-&gt;surface-&gt;vert[2]))) {
    mcell_internal_error(
        &quot;Error in function 'xyz2grid()': point is outside wall.&quot;);
  }

  i = v-&gt;x * unit_u-&gt;x + v-&gt;y * unit_u-&gt;y + v-&gt;z * unit_u-&gt;z - g-&gt;vert0.u;
  j = v-&gt;x * unit_v-&gt;x + v-&gt;y * unit_v-&gt;y + v-&gt;z * unit_v-&gt;z - g-&gt;vert0.v;

  striploc = j * g-&gt;inv_strip_wid;
  strip = (int)striploc;
  striprem = striploc - strip;

  strip = g-&gt;n - strip - 1;

  u0 = j * g-&gt;vert2_slope;
  u1_u0 = g-&gt;surface-&gt;uv_vert1_u - j * g-&gt;fullslope;

  stripeloc = ((i - u0) / u1_u0) * (((double)strip) + (1.0 - striprem));
  stripe = (int)(stripeloc);
  striperem = stripeloc - stripe;

  flip = (striperem &lt; 1.0 - striprem) ? 0 : 1;

  idx = strip * strip + 2 * stripe + flip;

  if ((u_int)idx &gt;= g-&gt;n_tiles) {
    mcell_internal_error(&quot;Error in function 'xyz2grid()': returning tile index &quot;
                         &quot;%d while wall has %u tiles&quot;,
                         idx, g-&gt;n_tiles);
  }

  return idx;
}

int uv2grid(struct vector2 *v, struct surface_grid *g) {
  double i, j;
  double u0, u1_u0;
  double striploc, striprem, stripeloc, striperem;
  int strip, stripe, flip, idx;
  struct vector2 vert_0, vert_1;
  int tile_idx_0, tile_idx_mid, tile_idx_last;

  if (g-&gt;n_tiles == 1)
    return 0;

  /* find tile indices of the corner tiles */
  tile_idx_0 = 0;
  /* see function &quot;move_strip_up()&quot; */
  tile_idx_mid = g-&gt;n_tiles - 2 * (g-&gt;n) + 1;
  tile_idx_last = g-&gt;n_tiles - 1;

  vert_0.u = vert_0.v = 0;
  vert_1.u = g-&gt;surface-&gt;uv_vert1_u;
  vert_1.v = 0;

  if (!distinguishable_vec2(v, &amp;vert_0, EPS_C))
    return tile_idx_mid;
  if (!distinguishable_vec2(v, &amp;vert_1, EPS_C))
    return tile_idx_0;
  if (!distinguishable_vec2(v, &amp;g-&gt;surface-&gt;uv_vert2, EPS_C))
    return tile_idx_last;

  if (!(point_in_triangle_2D(v, &amp;vert_0, &amp;vert_1, &amp;g-&gt;surface-&gt;uv_vert2))) {
    mcell_internal_error(
        &quot;Error in function 'uv2grid()': point is outside wall.&quot;);
  }

  i = v-&gt;u;
  j = v-&gt;v;

  striploc = j * g-&gt;inv_strip_wid;
  strip = (int)striploc;
  striprem = striploc - strip;

  strip = g-&gt;n - strip - 1;

  u0 = j * g-&gt;vert2_slope;
  u1_u0 = g-&gt;surface-&gt;uv_vert1_u - j * g-&gt;fullslope;

  stripeloc = ((i - u0) / u1_u0) * (((double)strip) + (1.0 - striprem));
  stripe = (int)(stripeloc);
  striperem = stripeloc - stripe;

  flip = (striperem &lt; 1.0 - striprem) ? 0 : 1;
  idx = strip * strip + 2 * stripe + flip;

  if ((u_int)idx &gt;= g-&gt;n_tiles) {
    mcell_internal_error(&quot;Error in function 'xyz2grid()': returning tile index &quot;
                         &quot;%d while wall has %u tiles&quot;,
                         idx, g-&gt;n_tiles);
  }

  return idx;
}

/*************************************************************************
grid2xyz and grid2uv and grid2uv_random
  In: a surface grid
      index of a tile on that grid
      vector to store the results
  Out: vector contains the coordinates of the center of that tile, or
       a random coordinate within that tile.
       WARNING: no error checking--index assumed to be valid!
  Note: grid2xyz just multiplies by uv unit vectors at the end.
*************************************************************************/

void grid2xyz(struct surface_grid *g, int idx, struct vector3 *v) {
  struct vector3 *unit_u = &amp;(g-&gt;surface-&gt;unit_u);
  struct vector3 *unit_v = &amp;(g-&gt;surface-&gt;unit_v);
  int root;
  int rootrem;
  int k, j, i;
  double ucoef, vcoef, over3n;

  root = (int)(sqrt((double)idx));
  rootrem = idx - root * root;
  k = g-&gt;n - root - 1;
  j = rootrem / 2;
  i = rootrem - 2 * j;

  over3n = 1.0 / (double)(3 * g-&gt;n);

  ucoef = ((double)(3 * j + i + 1)) * over3n * g-&gt;surface-&gt;uv_vert1_u +
          ((double)(3 * k + i + 1)) * over3n * g-&gt;surface-&gt;uv_vert2.u;
  vcoef = ((double)(3 * k + i + 1)) * over3n * g-&gt;surface-&gt;uv_vert2.v;

  v-&gt;x = ucoef * unit_u-&gt;x + vcoef * unit_v-&gt;x + g-&gt;surface-&gt;vert[0]-&gt;x;
  v-&gt;y = ucoef * unit_u-&gt;y + vcoef * unit_v-&gt;y + g-&gt;surface-&gt;vert[0]-&gt;y;
  v-&gt;z = ucoef * unit_u-&gt;z + vcoef * unit_v-&gt;z + g-&gt;surface-&gt;vert[0]-&gt;z;
}

void grid2uv(struct surface_grid *g, int idx, struct vector2 *v) {
  int root;
  int rootrem;
  int k, j, i;
  double over3n;

  root = (int)(sqrt((double)idx));
  rootrem = idx - root * root;
  k = g-&gt;n - root - 1;
  j = rootrem / 2;
  i = rootrem - 2 * j;

  over3n = 1.0 / (double)(3 * g-&gt;n);

  v-&gt;u = ((double)(3 * j + i + 1)) * over3n * g-&gt;surface-&gt;uv_vert1_u +
         ((double)(3 * k + i + 1)) * over3n * g-&gt;surface-&gt;uv_vert2.u;
  v-&gt;v = ((double)(3 * k + i + 1)) * over3n * g-&gt;surface-&gt;uv_vert2.v;
}

void grid2uv_random(struct surface_grid *g, int idx, struct vector2 *v,
                    struct rng_state *rng) {
  int root;
  int rootrem;
  int k, j, i;
  double over_n;
  double u_ran, v_ran;

  root = (int)(sqrt((double)idx));
  rootrem = idx - root * root;
  k = g-&gt;n - root - 1;
  j = rootrem / 2;
  i = rootrem - 2 * j;

  over_n = 1.0 / (double)(g-&gt;n);

  u_ran = rng_dbl(rng);
  v_ran = 1.0 - sqrt(rng_dbl(rng));

  v-&gt;u =
      ((double)(j + i) + (1 - 2 * i) * (1.0 - v_ran) * u_ran) * over_n *
          g-&gt;surface-&gt;uv_vert1_u +
      ((double)(k + i) + (1 - 2 * i) * v_ran) * over_n * g-&gt;surface-&gt;uv_vert2.u;
  v-&gt;v =
      ((double)(k + i) + (1 - 2 * i) * v_ran) * over_n * g-&gt;surface-&gt;uv_vert2.v;
}

/*************************************************************************
init_grid_geometry:
  In: a surface grid with correct # of divisions/edge and wall pointer
  Out: all the precomputed geometry speedup values are properly set
*************************************************************************/

void init_grid_geometry(struct surface_grid *g) {
  g-&gt;inv_strip_wid = 1.0 / (g-&gt;surface-&gt;uv_vert2.v / ((double)g-&gt;n));
  g-&gt;vert2_slope = g-&gt;surface-&gt;uv_vert2.u / g-&gt;surface-&gt;uv_vert2.v;
  g-&gt;fullslope = g-&gt;surface-&gt;uv_vert1_u / g-&gt;surface-&gt;uv_vert2.v;

  g-&gt;vert0.u = g-&gt;surface-&gt;vert[0]-&gt;x * g-&gt;surface-&gt;unit_u.x +
               g-&gt;surface-&gt;vert[0]-&gt;y * g-&gt;surface-&gt;unit_u.y +
               g-&gt;surface-&gt;vert[0]-&gt;z * g-&gt;surface-&gt;unit_u.z;
  g-&gt;vert0.v = g-&gt;surface-&gt;vert[0]-&gt;x * g-&gt;surface-&gt;unit_v.x +
               g-&gt;surface-&gt;vert[0]-&gt;y * g-&gt;surface-&gt;unit_v.y +
               g-&gt;surface-&gt;vert[0]-&gt;z * g-&gt;surface-&gt;unit_v.z;

  g-&gt;n_tiles = g-&gt;n * g-&gt;n;
}

/*************************************************************************
create_grid:
  In: a wall pointer that needs to have its grid created
      a guess for the subvolume the center of the grid is in
  Out: integer, 0 if grid exists or was created, 1 on memory error.
       The grid is created and the wall is set to point at it.
*************************************************************************/
int create_grid(struct volume *world, struct wall *w, struct subvolume *guess) {
  struct surface_grid *sg = NULL;
  struct vector3 center;

  if (w-&gt;grid != NULL)
    return 0;

  sg = (struct surface_grid *)CHECKED_MEM_GET(w-&gt;birthplace-&gt;grids,
                                              &quot;surface grid&quot;);
  if (sg == NULL)
    return 1;

  center.x = 0.33333333333 * (w-&gt;vert[0]-&gt;x + w-&gt;vert[1]-&gt;x + w-&gt;vert[2]-&gt;x);
  center.y = 0.33333333333 * (w-&gt;vert[0]-&gt;y + w-&gt;vert[1]-&gt;y + w-&gt;vert[2]-&gt;y);
  center.z = 0.33333333333 * (w-&gt;vert[0]-&gt;z + w-&gt;vert[1]-&gt;z + w-&gt;vert[2]-&gt;z);

  sg-&gt;surface = w;
  sg-&gt;subvol = find_subvolume(world, &amp;center, guess);

  sg-&gt;n = (int)ceil(sqrt(w-&gt;area));
  if (sg-&gt;n &lt; 1)
    sg-&gt;n = 1;

  sg-&gt;n_tiles = sg-&gt;n * sg-&gt;n;
  sg-&gt;n_occupied = 0;

  sg-&gt;binding_factor = ((double)sg-&gt;n_tiles) / w-&gt;area;
  init_grid_geometry(sg);

  sg-&gt;sm_list = CHECKED_MALLOC_ARRAY(struct surface_molecule_list *, sg-&gt;n_tiles,
                                     &quot;surface grid&quot;);

  for (unsigned int i = 0; i &lt; sg-&gt;n_tiles; i++) {
    sg-&gt;sm_list[i] = NULL;
  }

  w-&gt;grid = sg;

  return 0;
}

/*************************************************************************
grid_neighbors:
  In: a surface grid
      an index on that grid
      flag that tells whether we have to create a grid on the
          neighbor wall if there is no grid there
      an array[3] of pointers to be filled in with neighboring grid(s)
      an array[3] of pointers to be filled in with neighboring indices
  Out: no return value.  The three nearest neighbors are returned,
       which may be on a neighboring grid if the supplied index is
       at an edge.  If there is no neighbor in one of the three
       directions, the neighboring grid pointer is set to NULL.
  Note: the three neighbors are returned in the same order as the
        edges, i.e. the 0th will be the nearest neighbor in the
        direction of the 0th edge, and so on.
  Note: If this code is used to find neighboring molecules,
        the &quot;create_grid_flag&quot; should be set to zero.
        In such case if a nearby wall exists but has no grid placed
        on it, this function returns NULL for that grid, even though
        there is space there (just no molecules).
        If this code is used to find free spots, the &quot;create_grid_flag&quot;
        should be set to 1 (or any positive value) and the function
        returns newly created grid for this wall.
*************************************************************************/
void grid_neighbors(struct volume *world, struct surface_grid *grid, int idx,
                    int create_grid_flag, struct surface_grid **nb_grid,
                    int *nb_idx) {
  int i, j, k, root, rootrem;
  struct vector3 loc_3d;
  struct vector2 near_2d;
  double d;

  /* Calculate strip (k), stripe (j), and flip (i) indices from idx */
  root = (int)(sqrt((double)idx));
  rootrem = idx - root * root;
  k = root;
  j = rootrem / 2;
  i = rootrem - 2 * j;

  /* First look &quot;left&quot; (towards edge 2) */
  if (j &gt; 0 || i &gt; 0) /* all tiles except upright tiles in stripe 0 */
  {
    nb_grid[2] = grid;
    nb_idx[2] = idx - 1;
  } else /* upright tiles in stripe 0 */
  {
    if (grid-&gt;surface-&gt;nb_walls[2] == NULL)
      nb_grid[2] = NULL;
    else if ((grid-&gt;surface-&gt;nb_walls[2]-&gt;grid == NULL) &amp;&amp; (!create_grid_flag))
      nb_grid[2] = NULL;
    else {
      if ((grid-&gt;surface-&gt;nb_walls[2]-&gt;grid == NULL) &amp;&amp; create_grid_flag) {
        if (create_grid(world, grid-&gt;surface-&gt;nb_walls[2], NULL))
          mcell_allocfailed(&quot;Failed to create grid for wall.&quot;);
      }

      if (grid-&gt;sm_list[idx]-&gt;sm != NULL)
        uv2xyz(&amp;grid-&gt;sm_list[idx]-&gt;sm-&gt;s_pos, grid-&gt;surface, &amp;loc_3d);
      else
        grid2xyz(grid, idx, &amp;loc_3d);
      d = closest_interior_point(&amp;loc_3d, grid-&gt;surface-&gt;nb_walls[2], &amp;near_2d,
                                 GIGANTIC);
      if (!distinguishable(d, GIGANTIC, EPS_C))
        nb_grid[2] = NULL;
      else {
        nb_grid[2] = grid-&gt;surface-&gt;nb_walls[2]-&gt;grid;
        nb_idx[2] = uv2grid(&amp;near_2d, nb_grid[2]);
      }
    }
  }

  /* Then &quot;right&quot; (towards edge 1) */
  if (j &lt; k) /* all tiles except upright tiles in last stripe */
  {
    nb_grid[1] = grid;
    nb_idx[1] = idx + 1;
  } else /* upright tiles in last stripe */
  {
    if (grid-&gt;surface-&gt;nb_walls[1] == NULL)
      nb_grid[1] = NULL;
    else if ((grid-&gt;surface-&gt;nb_walls[1]-&gt;grid == NULL) &amp;&amp; (!create_grid_flag))
      nb_grid[1] = NULL;
    else {
      if ((grid-&gt;surface-&gt;nb_walls[1]-&gt;grid == NULL) &amp;&amp; create_grid_flag) {
        if (create_grid(world, grid-&gt;surface-&gt;nb_walls[1], NULL))
          mcell_allocfailed(&quot;Failed to create grid for wall.&quot;);
      }
      if (grid-&gt;sm_list[idx]-&gt;sm != NULL)
        uv2xyz(&amp;grid-&gt;sm_list[idx]-&gt;sm-&gt;s_pos, grid-&gt;surface, &amp;loc_3d);
      else
        grid2xyz(grid, idx, &amp;loc_3d);
      d = closest_interior_point(&amp;loc_3d, grid-&gt;surface-&gt;nb_walls[1], &amp;near_2d,
                                 GIGANTIC);
      if (!distinguishable(d, GIGANTIC, EPS_C))
        nb_grid[1] = NULL;
      else {
        nb_grid[1] = grid-&gt;surface-&gt;nb_walls[1]-&gt;grid;
        nb_idx[1] = uv2grid(&amp;near_2d, nb_grid[1]);
      }
    }
  }

  /* Finally &quot;up/down&quot; (towards edge 0 if not flipped) */
  if (i || k + 1 &lt; grid-&gt;n) /* all tiles except upright tiles in last strip */
  {
    nb_grid[0] = grid;
    if (i)
      nb_idx[0] =
          2 * j + (k - 1) * (k - 1); /* unflip and goto previous strip */
    else
      nb_idx[0] = 1 + 2 * j + (k + 1) * (k + 1); /* flip and goto next strip */
  } else /* upright tiles in last strip */
  {
    if (grid-&gt;surface-&gt;nb_walls[0] == NULL)
      nb_grid[0] = NULL;
    else if ((grid-&gt;surface-&gt;nb_walls[0]-&gt;grid == NULL) &amp;&amp; (!create_grid_flag))
      nb_grid[0] = NULL;
    else {
      if ((grid-&gt;surface-&gt;nb_walls[0]-&gt;grid == NULL) &amp;&amp; create_grid_flag) {
        if (create_grid(world, grid-&gt;surface-&gt;nb_walls[0], NULL))
          mcell_allocfailed(&quot;Failed to create grid for wall.&quot;);
      }

      if (grid-&gt;sm_list[idx]-&gt;sm != NULL)
        uv2xyz(&amp;grid-&gt;sm_list[idx]-&gt;sm-&gt;s_pos, grid-&gt;surface, &amp;loc_3d);
      else
        grid2xyz(grid, idx, &amp;loc_3d);
      d = closest_interior_point(&amp;loc_3d, grid-&gt;surface-&gt;nb_walls[0], &amp;near_2d,
                                 GIGANTIC);
      if (!distinguishable(d, GIGANTIC, EPS_C))
        nb_grid[0] = NULL;
      else {
        nb_grid[0] = grid-&gt;surface-&gt;nb_walls[0]-&gt;grid;
        nb_idx[0] = uv2grid(&amp;near_2d, nb_grid[0]);
      }
    }
  }
}

/*************************************************************************
nearest_free:
  In: a surface grid
      a vector in u,v coordinates on that surface
      the maximum distance we can search for free spots
  Out: integer containing the index of the closest unoccupied grid point
       to the vector, or -1 if no unoccupied points are found in range
  Note: we assume you've already checked the grid element that contains
        the point, so we don't bother looking there first.
  Note: if no unoccupied tile is found, found_dist2 contains distance to
        closest occupied tile.
*************************************************************************/

int nearest_free(struct surface_grid *g, struct vector2 *v, double max_d2,
                 double *found_dist2) {
  int h, i, j, k;
  int span;
  int can_flip;
  int idx;
  double d2;
  double f, ff, fff;
  double over3n = 0.333333333333333 / (double)(g-&gt;n);

  /* check whether the grid is fully occupied */
  if (g-&gt;n_occupied &gt;= g-&gt;n_tiles) {
    *found_dist2 = 0;
    return -1;
  }

  idx = -1;
  d2 = 2 * max_d2 + 1.0;

  for (k = 0; k &lt; g-&gt;n; k++) {
    f = v-&gt;v - ((double)(3 * k + 1)) * over3n * g-&gt;surface-&gt;uv_vert2.v;
    ff = f - over3n * g-&gt;surface-&gt;uv_vert2.v;
    ff *= ff;
    f *= f;
    if (f &gt; max_d2 &amp;&amp; ff &gt; max_d2)
      continue; /* Entire strip is too far away */

    span = (g-&gt;n - k);
    for (j = 0; j &lt; span; j++) {
      can_flip = (j != span - 1);
      for (i = 0; i &lt;= can_flip; i++) {
        fff =
            v-&gt;u - over3n * ((double)(3 * j + i + 1) * g-&gt;surface-&gt;uv_vert1_u +
                             (double)(3 * k + i + 1) * g-&gt;surface-&gt;uv_vert2.u);
        fff *= fff;
        if (i)
          fff += ff;
        else
          fff += f;

        if (fff &lt; max_d2 &amp;&amp; (idx == -1 || fff &lt; d2)) {
          h = (g-&gt;n - k) - 1;
          h = h * h + 2 * j + i;

          if (!g-&gt;sm_list[h] || !g-&gt;sm_list[h]-&gt;sm) {
            idx = h;
            d2 = fff;
          } else if (idx == -1) {
            if (fff &lt; d2)
              d2 = fff;
          }
        }
      }
    }
  }

  if (found_dist2 != NULL)
    *found_dist2 = d2;

  return idx;
}

/*************************************************************************
verify_wall_regions_match:
  In: char *mesh_name - the name of the polygon object to be checked
      string_buffer *reg_names - contains the regions names to be checked
      wall *w - we will compare the regions on this wall to those in reg_names
  Out: 0 if region names in reg_names match those of the wall or if we aren't really
       checking (mesh_name and/or reg_names are NULL), 1 otherwise.
*************************************************************************/
int verify_wall_regions_match(
    const char *mesh_name, struct string_buffer *prev_reg_names, struct wall *w,
    struct string_buffer *regions_to_ignore,
    struct mesh_transparency *mesh_transp, const char *species_name) {


  if ((mesh_name != NULL) &amp;&amp; (prev_reg_names != NULL)) {
    if (strcmp(w-&gt;parent_object-&gt;sym-&gt;name, mesh_name) != 0) {
      return 1;
    }
    struct name_list *wall_reg_names = NULL;
    wall_reg_names = find_regions_names_by_wall(w, regions_to_ignore);
    struct name_list *wrn = NULL;

    int i = 0;
    int still_inside = 0;
    // See if we moved *OUTSIDE* of a region we were previously *INSIDE*
    // TODO: Really need to optimize this
    for (char *prn = prev_reg_names-&gt;strings[i]; i &lt; prev_reg_names-&gt;n_strings; i++) {
      for (wrn = wall_reg_names; wrn != NULL; wrn = wrn-&gt;next) {
        if (strcmp(prn, wrn-&gt;name) == 0) {
          still_inside = 1;
          break;
        }
      }
      if (!still_inside) {
        // We are now outside a region now that we were inside before
        // See if we can legally be there (i.e. are we transparent to it)
        struct mesh_transparency *mt = mesh_transp;
        for (; mt != NULL; mt = mt-&gt;next) {
          // Need to add test to discriminate between top front and top back
          if ((strcmp(mt-&gt;name, prn) == 0) &amp;&amp;
              (!mt-&gt;transp_top_front || !mt-&gt;transp_top_back)) {
            if (wall_reg_names != NULL) {
              remove_molecules_name_list(&amp;wall_reg_names);
            }
            return 1;
          }
        }
      }
      still_inside = 0;
    }

    // See if we moved *INSIDE* a region we were *OUTSIDE* of before
    for (wrn = wall_reg_names; wrn != NULL; wrn = wrn-&gt;next) {
      // Disregard regions which were just removed
      if (is_string_present_in_string_array(
         wrn-&gt;name, regions_to_ignore-&gt;strings, regions_to_ignore-&gt;n_strings)) {
        continue;
      }

      if (!is_string_present_in_string_array(
          wrn-&gt;name, prev_reg_names-&gt;strings, prev_reg_names-&gt;n_strings)) {

        // We are in a region now that we weren't in before
        // See if we can legally be there (i.e. are we transparent to it)
        int cont = 0;
        struct mesh_transparency *mt = mesh_transp;
        for (; mt != NULL; mt = mt-&gt;next) {
          if (strcmp(mt-&gt;name, wrn-&gt;name) == 0) {
            if (mt-&gt;transp_top_front || mt-&gt;transp_top_back) {
              cont = 1;
              break;
            }
          }
        }
        if (cont) {
          continue;
        }

        remove_molecules_name_list(&amp;wall_reg_names);
        return 1;
      }
    }
    if (wall_reg_names != NULL) {
      remove_molecules_name_list(&amp;wall_reg_names);
    }
  }
  return 0;
}

/*************************************************************************
search_nbhd_for_free:
  In: the wall that we ought to be in
      a vector in u,v coordinates on that surface where we should go
      the maximum distance we can search for free spots
      a place to store the index of our free slot
      a function that we'll call to make sure a wall is okay
      context for that function passed in by whatever called us
  Out: pointer to the wall that has the free slot, or NULL if no wall
       exist in range.
  Note: usually the calling function will create a grid if needed and
        check the grid element at u,v; if that is not done this function
        will return the correct result but not efficiently.
  Note: This is not recursive.  It should be made recursive.
*************************************************************************/
struct wall *search_nbhd_for_free(struct volume *world, struct wall *origin,
                                  struct vector2 *point, double max_d2,
                                  int *found_idx,
                                  int (*ok)(void *, struct wall *),
                                  void *context, const char *mesh_name,
                                  struct string_buffer *reg_names) {
  struct wall *there = NULL;
  int i, j;
  double d2 = 0;
  struct vector2 pt, ed;
  struct vector2 vurt0, vurt1;
  int best_i;
  double best_d2;
  struct wall *best_w = NULL;

  best_i = -1;
  best_d2 = 2.0 * max_d2 + 1.0;

  if (origin-&gt;grid == NULL &amp;&amp; create_grid(world, origin, NULL))
    mcell_allocfailed(&quot;Failed to create grid for wall.&quot;);

  i = -1; /* default return value */

  /* Find index and distance of nearest free grid element on origin wall */
  if (origin-&gt;grid-&gt;n_occupied &lt; origin-&gt;grid-&gt;n_tiles) {
    i = nearest_free(origin-&gt;grid, point, max_d2, &amp;d2);
  }

  if (i != -1) {
    best_i = i;
    best_d2 = d2;
    best_w = origin;
  }

  /* if there are no free slots on the origin wall - look around */

  if (best_w == NULL) {
    /* Check for closer free grid elements on neighboring walls */
    for (j = 0; j &lt; 3; j++) {
      if (origin-&gt;edges[j] == NULL || origin-&gt;edges[j]-&gt;backward == NULL)
        continue;

      if (origin-&gt;edges[j]-&gt;forward == origin)
        there = origin-&gt;edges[j]-&gt;backward;
      else
        there = origin-&gt;edges[j]-&gt;forward;

      if (ok != NULL &amp;&amp; !(*ok)(context, there))
        continue; /* Calling function doesn't like this wall */

      if (verify_wall_regions_match(mesh_name, reg_names, there, NULL, NULL, NULL)) {
        continue; 
      }

      /* check whether there are any available spots on the neighbor wall */
      if (there-&gt;grid != NULL) {
        if (there-&gt;grid-&gt;n_occupied &gt;= there-&gt;grid-&gt;n_tiles) {
          continue;
        }
      }

      /* Calculate distance between point and edge j of origin wall */
      switch (j) {
      case 0:
        vurt0.u = vurt0.v = 0.0;
        vurt1.u = origin-&gt;uv_vert1_u;
        vurt1.v = 0;
        break;
      case 1:
        vurt0.u = origin-&gt;uv_vert1_u;
        vurt0.v = 0;
        memcpy(&amp;vurt1, &amp;(origin-&gt;uv_vert2), sizeof(struct vector2));
        break;
      case 2:
        memcpy(&amp;vurt0, &amp;(origin-&gt;uv_vert2), sizeof(struct vector2));
        vurt1.u = vurt1.v = 0.0;
        break;
      default:
        /* default case should not occur since 0&lt;=j&lt;=2 */
        UNHANDLED_CASE(j);
      }
      ed.u = vurt1.u - vurt0.u;
      ed.v = vurt1.v - vurt0.v;
      pt.u = point-&gt;u - vurt0.u;
      pt.v = point-&gt;v - vurt0.v;

      d2 = pt.u * ed.u + pt.v * ed.v;
      d2 = (pt.u * pt.u + pt.v * pt.v) -
           d2 * d2 / (ed.u * ed.u + ed.v * ed.v); /* Distance squared to line */

      /* Check for free grid element on neighbor if point to edge distance is
       * closer than best_d2  */
      if (d2 &lt; best_d2) {

        if (there-&gt;grid == NULL &amp;&amp; create_grid(world, there, NULL))
          mcell_allocfailed(&quot;Failed to create grid for wall.&quot;);

        traverse_surface(origin, point, j, &amp;pt);
        i = nearest_free(there-&gt;grid, &amp;pt, max_d2, &amp;d2);

        if (i != -1 &amp;&amp; d2 &lt; best_d2) {
          best_i = i;
          best_d2 = d2;
          best_w = there;
        }
      }
    }
  }

  *found_idx = best_i;
  return best_w;
}

/***************************************************************************
delete_tile_neighbor_list:
   In: linked list of tile_neighbors
   Out: none.  The memory is freed
****************************************************************************/
void delete_tile_neighbor_list(struct tile_neighbor *head) {
  struct tile_neighbor *nnext;
  while (head != NULL) {
    nnext = head-&gt;next;
    free(head);
    head = nnext;
  }
}

/***************************************************************************
delete_region_list:
   In: linked list of regions
   Out: none.  The memory is freed
****************************************************************************/
void delete_region_list(struct region_list *head) {
  struct region_list *next;
  while (head != NULL) {
    next = head-&gt;next;
    free(head);
    head = next;
  }
}

/***************************************************************************
push_tile_neighbor_to_list:
   In: head of the linked list
       surface_grid of the wall the tile is on
       index of the tile
   Out: none. The linked list is expanded by one node (grid/idx).
****************************************************************************/
void push_tile_neighbor_to_list(struct tile_neighbor **head,
                                struct surface_grid *grid, int idx) {
  struct tile_neighbor *old_head = *head;
  struct tile_neighbor *tile_nbr = CHECKED_MALLOC_STRUCT(struct tile_neighbor,
                                                         &quot;tile_neighbor&quot;);
  tile_nbr-&gt;grid = grid;
  tile_nbr-&gt;flag = 0;
  tile_nbr-&gt;idx = idx;

  if (old_head == NULL) {
    tile_nbr-&gt;next = NULL;
    old_head = tile_nbr;
  } else {
    tile_nbr-&gt;next = old_head;
    old_head = tile_nbr;
  }

  *head = old_head;
}

/***************************************************************************
push_tile_neighbor_to_list_with_checking:
   In: head of the linked list
       surface_grid of the wall the tile is on
       index of the tile
   Out: number of added nodes (grid/idx).  Should be zero or 1.
   Note: we perform checking so that no duplicates are added
****************************************************************************/
int push_tile_neighbor_to_list_with_checking(struct tile_neighbor **head,
                                             struct surface_grid *grid,
                                             int idx) {
  struct tile_neighbor *tile_nbr, *old_head;

  old_head = *head;

  for (tile_nbr = old_head; tile_nbr != NULL; tile_nbr = tile_nbr-&gt;next) {
    if ((tile_nbr-&gt;grid == grid) &amp;&amp; (tile_nbr-&gt;idx == (u_int)idx))
      return 0;
  }

  tile_nbr = CHECKED_MALLOC_STRUCT(struct tile_neighbor, &quot;tile_neighbor&quot;);
  tile_nbr-&gt;grid = grid;
  tile_nbr-&gt;flag = 0;
  tile_nbr-&gt;idx = idx;

  if (old_head == NULL) {
    tile_nbr-&gt;next = NULL;
    old_head = tile_nbr;
  } else {
    tile_nbr-&gt;next = old_head;
    old_head = tile_nbr;
  }

  *head = old_head;
  return 1;
}

/*********************************************************************
get_tile_neighbor_from_list_of_vacant_neighbors:
   In:  head of the linked list of tile_neighbors
        index of the node in the list (indexing starts from zero)
        surface_grid (return value)
        tile index (return value)
   Out: Only if the node was not previously selected, the surface_grid
        and tile index on the surface grid are set.
        Returns number of really vacant tiles at the start of the function
        (some tiles may be already selected by the previous calls
           to the function).
*********************************************************************/
int get_tile_neighbor_from_list_of_vacant_neighbors(struct tile_neighbor *head,
  int list_index, struct surface_grid **grid, int *tile_idx) {

  struct tile_neighbor *curr = head;

  int iter = 0;  /* iterator through the linked list like through the array */
  int count = 0; /* number of really vacant tiles */

  while (curr != NULL) {
    if ((curr-&gt;flag &amp; TILE_CHECKED) == 0) {
      count++;
    }

    if ((iter == list_index) &amp;&amp; ((curr-&gt;flag &amp; TILE_CHECKED) == 0)) {
      curr-&gt;flag |= TILE_CHECKED;
      *grid = curr-&gt;grid;
      *tile_idx = curr-&gt;idx;
    }
    iter++;
    curr = curr-&gt;next;
  }
  return count;
}

/******************************************************************
uncheck_vacant_tile:
   In:  head of the linked list of tile_neighbors
        index of the node in the list (indexing starts from zero)
   Out: None. The flag on the tile_neighbor is cleared at
        bit TILE_CHECKED.

******************************************************************/
void uncheck_vacant_tile(struct tile_neighbor *head, int list_index) {
  struct tile_neighbor *curr = head;
  int iter = 0; /* iterator through the linked list like through the array */

  while (curr != NULL) {
    if ((iter == list_index) &amp;&amp; (curr-&gt;flag &amp; TILE_CHECKED)) {
      /* clear the bit */
      curr-&gt;flag &amp;= ~TILE_CHECKED;
    }
    iter++;
    curr = curr-&gt;next;
  }
}

/*************************************************************************
get_tile_vertices:
   In: surface grid
       tile index
       tile flip information (return value)
       first tile vertex R   (return value)
       second tile vertex S  (return value)
       third tile vertex T   (return value)
   Out: the tile vertices (R,S,T) coordinates are defined
   Note: the vertices (R,S,T) are listed clockwise.  For the upright tile
         (orientation similar to the wall) two vertices R and S are
         on the same line PQ parallel and closest to the u-axis.
         For the inverted tile (orientation inverted compared to the wall)
         two vertices S and T are on the same line XY parallel and furthest
         to the u-axis.

*************************************************************************/
void get_tile_vertices(struct surface_grid *sg, int idx, int *flp,
                       struct vector2 *R, struct vector2 *S,
                       struct vector2 *T) {
  /* indices of the barycentric subdivision */
  int strip, stripe, flip;
  int root, rootrem;
  struct vector2 P, Q, X, Y;
  /* length of the segments PQ and XY (see below) */
  double pq, xy;
  /* cotangent of the angle formed between the u-axis
     and the wall edge opposite to the origin of the
     uv-coordinate system */
  double cot_angle;

  /* Calculate strip, stripe, and flip indices from idx */
  root = (int)(sqrt((double)idx));
  rootrem = idx - root * root;
  strip = sg-&gt;n - root - 1;
  stripe = rootrem / 2;
  flip = rootrem - 2 * stripe;

  /* Let PQ to be the segment on the grid containing the vertex R
     and the one closest to the u-axis.  Let XY to be the segment
     containing the vertex T and the one furthest to the u-axis.
     Let point P to be on the left side of point Q.
     Let point X to be on the left side of point Y.
  */

  /* find v-coordinates of P, Q, X, Y */
  P.v = Q.v = strip / sg-&gt;inv_strip_wid;
  X.v = Y.v = (strip + 1) / sg-&gt;inv_strip_wid;

  /* find u-coordinates of P, Q, X, Y */
  P.u = (P.v) * (sg-&gt;vert2_slope);
  X.u = (X.v) * (sg-&gt;vert2_slope);

  cot_angle = (sg-&gt;surface-&gt;uv_vert1_u - sg-&gt;surface-&gt;uv_vert2.u) /
              (sg-&gt;surface-&gt;uv_vert2.v);
  Q.u = sg-&gt;surface-&gt;uv_vert1_u - (Q.v) * cot_angle;
  Y.u = sg-&gt;surface-&gt;uv_vert1_u - (Y.v) * cot_angle;

  pq = Q.u - P.u;
  if (idx == 0) {
    xy = 0;
  } else {
    xy = Y.u - X.u;
  }

  /* find coordinates of the tile vertices */
  /* For the upright tile the vertices R and S lie on
     the line PQ and vertex T - on the line XY.
     For the inverted tile only the vertex R lies on the line PQ
     while the vertices S and T lie on the line XY */

  if (flip == 1) {
    /* inverted tile */
    R-&gt;v = P.v;
    /* note: pq/(sg-&gt;n - strip) tells us
             the number of slots on the line PQ */
    R-&gt;u = P.u + pq * (stripe + 1) / (sg-&gt;n - strip);

    S-&gt;v = T-&gt;v = X.v;
    T-&gt;u = X.u + xy * stripe / (sg-&gt;n - strip - 1);
    S-&gt;u = X.u + xy * (stripe + 1) / (sg-&gt;n - strip - 1);

  } else {
    /* upright tile */
    R-&gt;v = S-&gt;v = P.v;
    T-&gt;v = X.v;

    /* note: pq/(sg-&gt;n - strip) tells us
             the number of slots on the line PQ */
    R-&gt;u = P.u + pq * stripe / (sg-&gt;n - strip);
    S-&gt;u = P.u + pq * (stripe + 1) / (sg-&gt;n - strip);
    if (idx == 0) {
      T-&gt;u = X.u;
    } else {
      T-&gt;u = X.u + xy * stripe / (sg-&gt;n - strip - 1);
    }
  }

  /* set the tile flip value */
  *flp = flip;
}

/*************************************************************************
tile_orientation:
  In: a vector to the point on the grid and a surface grid
  Out: 0 if the triangle containg the point  is upright,
       and 1 if it is inverted.
       WARNING: no error checking--point assumed to be valid.
*************************************************************************/
int tile_orientation(struct vector2 *v, struct surface_grid *g) {
  double i, j;
  double u0, u1_u0;
  double striploc, striprem, stripeloc, striperem;
  int strip, stripe, flip;

  i = v-&gt;u;
  j = v-&gt;v;

  striploc = j * g-&gt;inv_strip_wid;
  strip = (int)striploc;
  striprem = striploc - strip;

  strip = g-&gt;n - strip - 1;

  u0 = j * g-&gt;vert2_slope;
  u1_u0 = g-&gt;surface-&gt;uv_vert1_u - j * g-&gt;fullslope;

  stripeloc = ((i - u0) / u1_u0) * (((double)strip) + (1.0 - striprem));
  stripe = (int)(stripeloc);
  striperem = stripeloc - stripe;

  flip = (striperem &lt; 1.0 - striprem) ? 0 : 1;

  return flip;
}

/*****************************************************************************
grid_all_neighbors_for_inner_tile:
  In: a surface grid
      an index on that grid
      a point on that tile
      a linked list of  neighbor tiles (return value)
      a length of the linked list above (return value)
  Out: The list and list length of nearest neighbors
       are returned.  Neighbors should share either common edge or
       common vertice.
  Note: The code below is valid only for the inner tile - the one that has 12
        neighbor tiles all belonging to the same grid as the start tile.
*****************************************************************************/
void grid_all_neighbors_for_inner_tile(
    struct volume *world, struct surface_grid *grid, int idx,
    struct vector2 *pos, struct tile_neighbor **tile_neighbor_head,
    int *list_length) {
  struct tile_neighbor *tile_nbr_head = NULL;
  int count = 0;

  int vert_nbr_ind = -1;

  /* The tile that has shape similar to the wall is called upright tile.
     The tile that has shape inverted relative to the wall is
     called inverted tile. */

  int kk;
  struct surface_grid *sg[3]; /* Neighboring surface grids (edge-to-edge) */
  int si[3]; /* Indices on those grids (edge-to-edge) of neighbor molecules */

  if ((u_int)idx &gt;= grid-&gt;n_tiles) {
    mcell_internal_error(
        &quot;Surface molecule tile index is greater than or equal of &quot;
        &quot;the number of tiles on the grid\n&quot;);
  }

  for (kk = 0; kk &lt; 3; kk++) {
    sg[kk] = NULL;
    si[kk] = -1;
  }

  /* find neighbors to react with */
  grid_neighbors(world, grid, idx, 0, sg, si);

  if ((grid != sg[0]) || (grid != sg[1]) || (grid != sg[2])) {
    mcell_internal_error(&quot;The function 'grid_all_neighbors_for_inner_tile()' &quot;
                         &quot;is called for the tile %d that is not an inner tile.&quot;,
                         idx);
  }

  for (kk = 0; kk &lt; 3; kk++) {
    if ((si[kk] != idx - 1) &amp;&amp; (si[kk] != idx + 1)) {
      vert_nbr_ind = si[kk];
      break;
    }
  }

  /* The tile has 2 neighbors to the left and 2 neighbors to the right */
  push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 1);
  count++;
  push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 2);
  count++;
  push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 1);
  count++;
  push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 2);
  count++;

  /* find the orientation of the tile */
  int tile_orient = tile_orientation(pos, grid);

  int temp_ind;
  if (tile_orient == 0) {
    /* upright tile has 5 neighbors in the row above it */
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind - 1);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind - 2);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind + 1);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind + 2);
    count++;

    /* upright tile has 3 neighbors in the row below it */
    temp_ind = move_strip_down(grid, idx);
    if (temp_ind == -1) {
      mcell_internal_error(&quot;The function 'grid_all_neighbors_for_inner_tile() &quot;
                           &quot;is called for the tile %d that is not an inner &quot;
                           &quot;tile.&quot;,
                           idx);
    }
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_ind);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_ind - 1);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_ind + 1);
    count++;
  } else {
    /* inverted tile has 3 neighbors in the row above it  */
    temp_ind = move_strip_up(grid, idx);
    if (temp_ind == -1) {
      mcell_internal_error(&quot;The function 'grid_all_neighbors_for_inner_tile() &quot;
                           &quot;is called for the tile %d that is not an inner &quot;
                           &quot;tile.&quot;,
                           idx);
    }
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_ind);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_ind - 1);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_ind + 1);
    count++;

    /*   inverted tile has 5 neighbors in the row below it  */
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind - 1);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind - 2);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind + 1);
    count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, vert_nbr_ind + 2);
    count++;
  }

  if (count != 12) {
    mcell_internal_error(&quot;The function 'grid_all_neighbors_for_inner_tile() is &quot;
                         &quot;called for the tile %d that is not an inner tile.&quot;,
                         idx);
  } else {
    *list_length = count;
  }

  *tile_neighbor_head = tile_nbr_head;
}

/**************************************************************************
grid_all_neighbors_across_walls_through_vertices:
  In: a surface molecule
      linked list of the neighbor walls that share one vertex only
      surface grid of thew all the molecule sits on or where the hit happens
      flag that tells whether we need to create a grid on a neighbor wall
      flag that tells whether we are searching for reactant
          (value = 1) or doing product placement (value = 0)
      a linked list of  neighbor tiles (return value)
      a length of the linked list above (return value)
  Out: The list of nearest neighbors are returned,
       Neighbors should share common vertex.
  Note: This version allows looking for the neighbors at the neighbor walls
       that are connected to the start wall through vertices only. Also
       the function takes care of REFLECTIVE/ABSORPTIVE region borders.
****************************************************************************/
void grid_all_neighbors_across_walls_through_vertices(
    struct volume *world, struct surface_molecule *sm,
    struct wall_list *wall_nbr_head, struct surface_grid *grid,
    int create_grid_flag, int search_for_reactant,
    struct tile_neighbor **tile_neighbor_head, int *list_length) {
  struct tile_neighbor *tile_nbr_head = NULL;
  struct wall_list *wl;
  struct wall *w;
  long long nbr_wall_vertex_id; /* index of the neighbor wall vertex in
                             &quot;world-&gt;all_vertices&quot; array  that coincides
                             with tile vertex */
  int nbr_tile_idx; /* index of the neighbor tile */
  /* arrays of vertex indices for the origin and neighbor walls
     in the global array &quot;world-&gt;all_vertices&quot; */
  long long origin_vert_indices[3], nbr_vert_indices[3];
  int i, k;
  int tiles_count = 0; /* number of tiles added */
  /* list of restricted regions */
  struct region_list *rlp_head_own_wall = NULL;
  struct region_list *rlp_head_nbr_wall;

  /* check for possible reflection (absorption) from the wall edges
     that may be region borders.  This is INSIDE_OUT check against
     molecule's own wall */
  if ((sm != NULL) &amp;&amp; (sm-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER)) {
    rlp_head_own_wall =
        find_restricted_regions_by_wall(world, sm-&gt;grid-&gt;surface, sm);
  }

  /* only one corner tile from each neighbor wall
     can be a neighbor to our start tile */

  /* since the neighbor walls are connected to the origin wall by just
     one vertex, and this code is valid only for the corner tile
     on the origin wall, from each neighbor wall we will pick up
     only one corner tile that shares a vertex with the origin wall */
  for (wl = wall_nbr_head; wl != NULL; wl = wl-&gt;next) {
    w = wl-&gt;this_wall;
    rlp_head_nbr_wall = NULL;

    if (w-&gt;grid == NULL) {
      if (create_grid_flag) {
        if (create_grid(world, w, NULL))
          mcell_allocfailed(&quot;Failed to allocate grid for wall.&quot;);
      } else {
        continue;
      }
    }

    /* if there is a restricted region list  for own wall
       and neighbor wall does NOT belong to all regions in this list -
       we assume that neighbor wall lies outside the
       restricted region boundary and we DO NOT add
       tile on such wall to the list of neighbor tiles  */
    if (search_for_reactant &amp;&amp; (rlp_head_own_wall != NULL)) {
      if (!wall_belongs_to_all_regions_in_region_list(w, rlp_head_own_wall))
        continue;
    }

    /* Similar test done OUTSIDE-IN */

    if (sm != NULL) {
      if (search_for_reactant &amp;&amp; (sm-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER)) {
        rlp_head_nbr_wall = find_restricted_regions_by_wall(world, w, sm);

        if (rlp_head_nbr_wall != NULL) {
          if (!wall_belongs_to_all_regions_in_region_list(sm-&gt;grid-&gt;surface,
                                                          rlp_head_nbr_wall)) {
            delete_void_list((struct void_list *)rlp_head_nbr_wall);
            continue;
          } else {
            /* we will add the tile on this wall to the list */
            delete_void_list((struct void_list *)rlp_head_nbr_wall);
          }
        }
      }
    }

    /* find the index of the neighbor tile */
    if (w-&gt;grid-&gt;n_tiles == 1) {
      nbr_tile_idx = 0;
    } else {
      nbr_wall_vertex_id = -1;
      nbr_tile_idx = -1;

      for (i = 0; i &lt; 3; i++) {
        origin_vert_indices[i] = (long long)(grid-&gt;surface-&gt;vert[i] - world-&gt;all_vertices);
      }
      for (i = 0; i &lt; 3; i++) {
        nbr_vert_indices[i] = (long long)(w-&gt;grid-&gt;surface-&gt;vert[i] - world-&gt;all_vertices);
      }
      for (i = 0; i &lt; 3; i++) {
        for (k = 0; k &lt; 3; k++) {
          if (origin_vert_indices[i] == nbr_vert_indices[k]) {
            nbr_wall_vertex_id = nbr_vert_indices[k];
            break;
          }
        }
      }

      if (nbr_wall_vertex_id == -1)
        mcell_internal_error(&quot;Error identifying tile on the neighbor wall.&quot;);

      /* find the index of the neighbor tile */
      if (&amp;world-&gt;all_vertices[nbr_wall_vertex_id] ==
          w-&gt;grid-&gt;surface-&gt;vert[0]) {
        nbr_tile_idx = w-&gt;grid-&gt;n_tiles - 2 * (w-&gt;grid-&gt;n) + 1;
      } else if (&amp;world-&gt;all_vertices[nbr_wall_vertex_id] ==
                 w-&gt;grid-&gt;surface-&gt;vert[1]) {
        nbr_tile_idx = w-&gt;grid-&gt;n_tiles - 1;
      } else if (&amp;world-&gt;all_vertices[nbr_wall_vertex_id] ==
                 w-&gt;grid-&gt;surface-&gt;vert[2]) {
        nbr_tile_idx = 0;
      }
      if (nbr_tile_idx == -1)
        mcell_internal_error(&quot;Error identifying tile on the neighbor wall.&quot;);
    }

    push_tile_neighbor_to_list(&amp;tile_nbr_head, w-&gt;grid, nbr_tile_idx);
    tiles_count++;
  }

  *list_length = tiles_count;
  *tile_neighbor_head = tile_nbr_head;

  if (rlp_head_own_wall != NULL)
    delete_void_list((struct void_list *)rlp_head_own_wall);
}

/**************************************************************************
grid_all_neighbors_across_walls_through_edges:
  In: a surface molecule
      surface grid of the wall where molecule sits on or where hit happens
      index of the tile for the condition above
      flag that tells whether we need to create a grid on a neighbor wall
      flag that tells whether we are searching for reactant
          (value = 1) or doing product placement (value = 0)
      a linked list of  neighbor tiles (return value)
      a length of the linked list above (return value)
  Out: The list of nearest neighbors are returned,
       Neighbors should share common edge.
  Note: This version allows looking for the neighbors at the neighbor walls
        that are connected to the start wall through edges only.
****************************************************************************/
void grid_all_neighbors_across_walls_through_edges(
    struct volume *world, struct surface_molecule *sm,
    struct surface_grid *grid, int idx, int create_grid_flag,
    int search_for_reactant, struct tile_neighbor **tile_neighbor_head,
    int *list_length) {
  struct tile_neighbor *tile_nbr_head = NULL;
  int tiles_count = 0;
  int tiles_added = 0; /* return value from the function
                        &quot;add_more_tile_neighbors_to_list()&quot; */
  int kk;
  int root, rootrem, strip, stripe, flip;
<A NAME="1"></A>  int temp_idx;

  /* list of restricted regions */
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1323-0.html#1',2,'match1323-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  struct region_list *rlp_head_own_wall = NULL;
  struct region_list *rlp_head_nbr_wall_0 = NULL;
  struct region_list *rlp_head_nbr_wall_1 = NULL;
  struct region_list *rlp_head_nbr_wall_2 = NULL;</B></FONT>
  /* flags */
  int move_thru_border_0 = 1;
  int move_thru_border_1 = 1;
  int move_thru_border_2 = 1;

  /* check for possible reflection (absorption) from the wall edges
     that may be region borders.  These are INSIDE_OUT and OUTSIDE-IN
     checks against molecule's own wall and neighbor wall */
  if ((sm != NULL) &amp;&amp; search_for_reactant &amp;&amp;
      (sm-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER)) {
    rlp_head_own_wall =
        find_restricted_regions_by_wall(world, sm-&gt;grid-&gt;surface, sm);

    if (sm-&gt;grid-&gt;surface-&gt;nb_walls[0] != NULL) {
      rlp_head_nbr_wall_0 = find_restricted_regions_by_wall(
          world, sm-&gt;grid-&gt;surface-&gt;nb_walls[0], sm);
      if (rlp_head_own_wall != NULL) {
        if (!wall_belongs_to_all_regions_in_region_list(
                 sm-&gt;grid-&gt;surface-&gt;nb_walls[0], rlp_head_own_wall))
          move_thru_border_0 = 0;
      }
      if (rlp_head_nbr_wall_0 != NULL) {
        if (!wall_belongs_to_all_regions_in_region_list(sm-&gt;grid-&gt;surface,
                                                        rlp_head_nbr_wall_0))
          move_thru_border_0 = 0;
      }
      if (rlp_head_nbr_wall_0 != NULL)
        delete_void_list((struct void_list *)rlp_head_nbr_wall_0);

    } else {
      move_thru_border_0 = 0;
    }

    if (sm-&gt;grid-&gt;surface-&gt;nb_walls[1] != NULL) {
      rlp_head_nbr_wall_1 = find_restricted_regions_by_wall(
          world, sm-&gt;grid-&gt;surface-&gt;nb_walls[1], sm);
      if (rlp_head_own_wall != NULL) {
        if (!wall_belongs_to_all_regions_in_region_list(
                 sm-&gt;grid-&gt;surface-&gt;nb_walls[1], rlp_head_own_wall))
          move_thru_border_1 = 0;
      }
      if (rlp_head_nbr_wall_1 != NULL) {
        if (!wall_belongs_to_all_regions_in_region_list(sm-&gt;grid-&gt;surface,
                                                        rlp_head_nbr_wall_1))
          move_thru_border_1 = 0;
      }

      if (rlp_head_nbr_wall_1 != NULL)
        delete_void_list((struct void_list *)rlp_head_nbr_wall_1);
    } else {
      move_thru_border_1 = 0;
    }

    if (sm-&gt;grid-&gt;surface-&gt;nb_walls[2] != NULL) {
      rlp_head_nbr_wall_2 = find_restricted_regions_by_wall(
          world, sm-&gt;grid-&gt;surface-&gt;nb_walls[2], sm);
      if (rlp_head_own_wall != NULL) {
        if (!wall_belongs_to_all_regions_in_region_list(
                 sm-&gt;grid-&gt;surface-&gt;nb_walls[2], rlp_head_own_wall))
          move_thru_border_2 = 0;
      }
      if (rlp_head_nbr_wall_2 != NULL) {
        if (!wall_belongs_to_all_regions_in_region_list(sm-&gt;grid-&gt;surface,
                                                        rlp_head_nbr_wall_2))
          move_thru_border_2 = 0;
      }

      if (rlp_head_nbr_wall_2 != NULL)
        delete_void_list((struct void_list *)rlp_head_nbr_wall_2);
    } else {
      move_thru_border_2 = 0;
    }

    if (rlp_head_own_wall != NULL)
      delete_void_list((struct void_list *)rlp_head_own_wall);
  }

  if ((u_int)idx &gt;= grid-&gt;n_tiles) {
    mcell_internal_error(&quot;Surface molecule tile index %u is greater than or &quot;
                         &quot;equal of the number of tiles on the grid %u\n&quot;,
                         (u_int)idx, grid-&gt;n_tiles);
  }

  /* find (strip, stripe, flip) coordinates of the tile */
  root = (int)(sqrt((double)idx));
  rootrem = idx - root * root;
  strip = grid-&gt;n - root - 1;
  stripe = rootrem / 2;
  flip = rootrem - 2 * stripe;

  if (create_grid_flag) {
    for (kk = 0; kk &lt; 3; kk++) {
      if ((grid-&gt;surface-&gt;nb_walls[kk] != NULL) &amp;&amp;
          (grid-&gt;surface-&gt;nb_walls[kk]-&gt;grid == NULL)) {
        if (create_grid(world, grid-&gt;surface-&gt;nb_walls[kk], NULL))
          mcell_allocfailed(&quot;Failed to create grid for wall.&quot;);
      }
    }
  }

  if (stripe == 0) {
    if (flip &gt; 0) /* inverted tile */
    {
      /* put in the list tiles that are on the same strip */
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 1);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 1);
      tiles_count++;
      if (strip &lt; grid-&gt;n - 2) {
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 2);
        tiles_count++;
      }

      /* put in the list tiles that are on the row below the start tile
         but on the same grid */
      temp_idx = move_strip_down(grid, idx);
      if (temp_idx == -1) {
        mcell_internal_error(&quot;Error in navigating on the grid&quot;);
      }
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
      tiles_count++;
      if (strip &lt; grid-&gt;n - 2) {
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 1);
        tiles_count++;
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 2);
        tiles_count++;
      }

      if (strip &gt; 0) {
        /* put in the list tiles that are on the row above the start tile
           but on the same grid */
        temp_idx = move_strip_up(grid, idx);
        if (temp_idx == -1) {
          mcell_internal_error(&quot;Error in navigating on the grid&quot;);
        }
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
        tiles_count++;
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 1);
        tiles_count++;
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 1);
        tiles_count++;
      }

      /* get the neighbors from the neighbor walls */
      if ((grid-&gt;surface-&gt;nb_walls[2] != NULL) &amp;&amp;
          (grid-&gt;surface-&gt;nb_walls[2]-&gt;grid != NULL)) {
        if (move_thru_border_2) {
          tiles_added = add_more_tile_neighbors_to_list_fast(
              &amp;tile_nbr_head, grid, strip, stripe, flip, grid-&gt;surface-&gt;vert[0],
              grid-&gt;surface-&gt;vert[2], 2, grid-&gt;surface-&gt;nb_walls[2]-&gt;grid);
          tiles_count += tiles_added;
        }
      }
      if (strip == 0) {
        if ((grid-&gt;surface-&gt;nb_walls[0] != NULL) &amp;&amp;
            (grid-&gt;surface-&gt;nb_walls[0]-&gt;grid != NULL)) {
          if (move_thru_border_0) {
            tiles_added = add_more_tile_neighbors_to_list_fast(
                &amp;tile_nbr_head, grid, strip, stripe, flip,
                grid-&gt;surface-&gt;vert[0], grid-&gt;surface-&gt;vert[1], 0,
                grid-&gt;surface-&gt;nb_walls[0]-&gt;grid);
            tiles_count += tiles_added;
          }
        }
      }
      if (strip == (grid-&gt;n - 2)) {
        if ((grid-&gt;surface-&gt;nb_walls[1] != NULL) &amp;&amp;
            (grid-&gt;surface-&gt;nb_walls[1]-&gt;grid != NULL)) {
          if (move_thru_border_1) {
            tiles_added = add_more_tile_neighbors_to_list_fast(
                &amp;tile_nbr_head, grid, strip, stripe, flip,
                grid-&gt;surface-&gt;vert[1], grid-&gt;surface-&gt;vert[2], 1,
                grid-&gt;surface-&gt;nb_walls[1]-&gt;grid);
            tiles_count += tiles_added;
          }
        }
      }
    } else {        /* upright tile (flip == 0)  */
      if (idx == 0) /* it is a special case */
      {
        if (grid-&gt;n_tiles &gt; 1) {
          /* put in the list tiles that are on the row above the start tile */
          temp_idx = move_strip_up(grid, idx);
          if (temp_idx == -1) {
            mcell_internal_error(&quot;Error in navigating on the grid&quot;);
          }
          push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
          tiles_count++;
          push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 1);
          tiles_count++;
          push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 1);
          tiles_count++;
        } else {
          if ((grid-&gt;surface-&gt;nb_walls[0] != NULL) &amp;&amp;
              (grid-&gt;surface-&gt;nb_walls[0]-&gt;grid != NULL)) {
            if (move_thru_border_0) {
              /* get the neighbors from the neighbor walls */
              tiles_added = add_more_tile_neighbors_to_list_fast(
                  &amp;tile_nbr_head, grid, strip, stripe, flip,
                  grid-&gt;surface-&gt;vert[0], grid-&gt;surface-&gt;vert[1], 0,
                  grid-&gt;surface-&gt;nb_walls[0]-&gt;grid);
              tiles_count += tiles_added;
            }
          }
        }
        if ((grid-&gt;surface-&gt;nb_walls[1] != NULL) &amp;&amp;
            (grid-&gt;surface-&gt;nb_walls[1]-&gt;grid != NULL)) {
          if (move_thru_border_1) {
            /* get the neighbors from the neighbor walls */
            tiles_added = add_more_tile_neighbors_to_list_fast(
                &amp;tile_nbr_head, grid, strip, stripe, flip,
                grid-&gt;surface-&gt;vert[1], grid-&gt;surface-&gt;vert[2], 1,
                grid-&gt;surface-&gt;nb_walls[1]-&gt;grid);
            tiles_count += tiles_added;
          }
        }
        if ((grid-&gt;surface-&gt;nb_walls[2] != NULL) &amp;&amp;
            (grid-&gt;surface-&gt;nb_walls[2]-&gt;grid != NULL)) {
          if (move_thru_border_2) {
            /* get the neighbors from the neighbor walls */
            tiles_added = add_more_tile_neighbors_to_list_fast(
                &amp;tile_nbr_head, grid, strip, stripe, flip,
                grid-&gt;surface-&gt;vert[0], grid-&gt;surface-&gt;vert[2], 2,
                grid-&gt;surface-&gt;nb_walls[2]-&gt;grid);
            tiles_count += tiles_added;
          }
        }
      } else { /* if (idx != 0) */

        /* put in the list tiles that are on the same strip */
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 1);
        tiles_count++;
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 2);
        tiles_count++;

        /* put in the list tiles that are on the row below the start tile */
        temp_idx = move_strip_down(grid, idx + 1);
        if (temp_idx == -1) {
          mcell_internal_error(&quot;Error in navigating on the grid&quot;);
        }
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
        tiles_count++;

        if (strip &gt; 0) {
          /* put in the list tiles that are on the row above the start tile
             but on the same grid */
          temp_idx = move_strip_up(grid, idx);
          if (temp_idx == -1) {
            mcell_internal_error(&quot;Error in navigating on the grid&quot;);
          }
          push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
          tiles_count++;
          push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 1);
          tiles_count++;
          push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 1);
          tiles_count++;
          push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 2);
          tiles_count++;
        } else { /* strip == 0 */
          /* put in the list tiles that are on the row above the start tile
          but on the different grid */
          /* it is the top left corner - special case */
          if ((grid-&gt;surface-&gt;nb_walls[0] != NULL) &amp;&amp;
              (grid-&gt;surface-&gt;nb_walls[0]-&gt;grid != NULL)) {
            if (move_thru_border_0) {
              /* get the neighbors from the neighbor walls */
              tiles_added = add_more_tile_neighbors_to_list_fast(
                  &amp;tile_nbr_head, grid, strip, stripe, flip,
                  grid-&gt;surface-&gt;vert[0], grid-&gt;surface-&gt;vert[1], 0,
                  grid-&gt;surface-&gt;nb_walls[0]-&gt;grid);
              tiles_count += tiles_added;
            }
          }
          if ((grid-&gt;surface-&gt;nb_walls[2] != NULL) &amp;&amp;
              (grid-&gt;surface-&gt;nb_walls[2]-&gt;grid != NULL)) {
            if (move_thru_border_2) {
              /* get the neighbors from the neighbor walls */
              tiles_added = add_more_tile_neighbors_to_list_fast(
                  &amp;tile_nbr_head, grid, strip, stripe, flip,
                  grid-&gt;surface-&gt;vert[0], grid-&gt;surface-&gt;vert[2], 2,
                  grid-&gt;surface-&gt;nb_walls[2]-&gt;grid);
              tiles_count += tiles_added;
            }
          }
        }

      } /* end if-else (idx == 0) */

    } /* end upright or inverted tile */

  } /* end if (stripe == 0) */

  if ((strip == 0) &amp;&amp; (stripe &gt; 0)) {
    /* put in the list tiles that are on the same row */
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 1);
    tiles_count++;
    push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 2);
    tiles_count++;

    if ((stripe &lt; grid-&gt;n - 2) || ((stripe == grid-&gt;n - 2) &amp;&amp; (flip == 0))) {
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 1);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 2);
      tiles_count++;
    } else if ((stripe == grid-&gt;n - 2) &amp;&amp; (flip == 1)) {
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 1);
      tiles_count++;
    }

    /* put in the list tiles that are on the row below */
    if (flip &gt; 0) {
      temp_idx = move_strip_down(grid, idx);
      if (temp_idx == -1) {
        mcell_internal_error(&quot;Error in navigating on the grid&quot;);
      }
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 1);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 2);
      tiles_count++;
      if (stripe &lt; grid-&gt;n - 2) {
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 1);
        tiles_count++;
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 2);
        tiles_count++;
      }
    } else { /* (flip == 0) */
      if ((unsigned int)idx &lt; grid-&gt;n_tiles - 1) {
        temp_idx = move_strip_down(grid, idx);
        if (temp_idx == -1) {
          mcell_internal_error(&quot;Error in navigating on the grid&quot;);
        }
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
        tiles_count++;
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 1);
        tiles_count++;
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 1);
        tiles_count++;
      } else {
        /* this is a corner tile */
        temp_idx = move_strip_down(grid, idx - 1);
        if (temp_idx == -1) {
          mcell_internal_error(&quot;Error in navigating on the grid&quot;);
        }
        push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
        tiles_count++;
      }
    }

    /* put in the list tiles that are on the row above */
    if ((grid-&gt;surface-&gt;nb_walls[0] != NULL) &amp;&amp;
        (grid-&gt;surface-&gt;nb_walls[0]-&gt;grid != NULL)) {
      if (move_thru_border_0) {
        /* get the neighbors from the neighbor walls */
        tiles_added = add_more_tile_neighbors_to_list_fast(
            &amp;tile_nbr_head, grid, strip, stripe, flip, grid-&gt;surface-&gt;vert[0],
            grid-&gt;surface-&gt;vert[1], 0, grid-&gt;surface-&gt;nb_walls[0]-&gt;grid);
        tiles_count += tiles_added;
      }
    }
    /* put in the list tiles that are on the side */
    if (((u_int)idx == (grid-&gt;n_tiles - 1)) ||
        ((u_int)idx == (grid-&gt;n_tiles - 2))) {
      if ((grid-&gt;surface-&gt;nb_walls[1] != NULL) &amp;&amp;
          (grid-&gt;surface-&gt;nb_walls[1]-&gt;grid != NULL)) {
        if (move_thru_border_1) {
          /* get the neighbors from the neighbor walls */
          tiles_added = add_more_tile_neighbors_to_list_fast(
              &amp;tile_nbr_head, grid, strip, stripe, flip, grid-&gt;surface-&gt;vert[1],
              grid-&gt;surface-&gt;vert[2], 1, grid-&gt;surface-&gt;nb_walls[1]-&gt;grid);
          tiles_count += tiles_added;
        }
      }
    }

  } /* end if ((strip == 0) &amp;&amp; (stripe &gt; 0)) */

  if ((strip &gt; 0) &amp;&amp; (stripe &gt; 0)) {
    /* We are guaranteed to be in the right layer of the wall.
       Note that no extra checking is done here for that
       assumption besides calling the function &quot;is_inner_tile()&quot;
       before calling this function. */
    if (flip &gt; 0) {
      /* put in the list tiles that are on the same row */
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 1);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 2);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx + 1);
      tiles_count++;

      /* put in the list tiles that are above the current row */
      temp_idx = move_strip_up(grid, idx);
      if (temp_idx == -1) {
        mcell_internal_error(&quot;Error in navigating on the grid&quot;);
      }
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 1);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 1);
      tiles_count++;
      /* put in the list tiles that are below the current row */
      temp_idx = move_strip_down(grid, idx);
      if (temp_idx == -1) {
        mcell_internal_error(&quot;Error in navigating on the grid&quot;);
      }
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 1);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 2);
      tiles_count++;

    } else { /* (flip == 0) */

      /* put in the list tiles that are on the same row */
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 1);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, idx - 2);
      tiles_count++;

      /* put in the list tiles that are above the current row */
      temp_idx = move_strip_up(grid, idx);
      if (temp_idx == -1) {
        mcell_internal_error(&quot;Error in navigating on the grid&quot;);
      }
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 1);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx - 2);
      tiles_count++;
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx + 1);
      tiles_count++;
      /* put in the list tiles that are below the current row */
      temp_idx = move_strip_down(grid, idx - 1);
      if (temp_idx == -1) {
        mcell_internal_error(&quot;Error in navigating on the grid&quot;);
      }
      push_tile_neighbor_to_list(&amp;tile_nbr_head, grid, temp_idx);
      tiles_count++;
    }
    /* put in the list tiles that are on the side */
    if ((grid-&gt;surface-&gt;nb_walls[1] != NULL) &amp;&amp;
        (grid-&gt;surface-&gt;nb_walls[1]-&gt;grid != NULL)) {
      if (move_thru_border_1) {
        /* get the neighbors from the neighbor walls */
        tiles_added = add_more_tile_neighbors_to_list_fast(
            &amp;tile_nbr_head, grid, strip, stripe, flip, grid-&gt;surface-&gt;vert[1],
            grid-&gt;surface-&gt;vert[2], 1, grid-&gt;surface-&gt;nb_walls[1]-&gt;grid);
        tiles_count += tiles_added;
      }
    }

  } /* end if ((strip &gt; 0) &amp;&amp; (stripe &gt; 0)) */

  *list_length = tiles_count;
  *tile_neighbor_head = tile_nbr_head;
}

/**************************************************************************
add_more_tile_neighbors_to_list_fast:
  In: a linked list of  neighbor tiles
      a surface grid of the start tile
      (strip, stripe, flip) coordinates of the start tile
      3D coordinates of the shared edge
          (edge has a direction from &quot;start&quot; to &quot;end&quot;)
      index of the shared edge looking from the original orid
          (0 - for edge between vert[0] and vert[1],
          1 - for edge between vert[1] and vert[2],
          2 - for edge between vert[0] and vert[2])
      a surface grid of the neighbor wall
  Out: Returns number of new neighbor tiles added to the original
       linked list of neighbor tiles.
       Neighbors should share either common edge or common vertex.
  Note:  The function looks only for the tiles that are the neighbors of
        &quot;orig_grid/orig_idx&quot; and reside on the neighbor &quot;new_grid&quot;.
***************************************************************************/
int add_more_tile_neighbors_to_list_fast(struct tile_neighbor **tile_nbr_head,
                                         struct surface_grid *orig_grid,
                                         int orig_strip, int orig_stripe,
                                         int orig_flip, struct vector3 *start,
                                         struct vector3 *end, int edge_index,
                                         struct surface_grid *new_grid) {

  int invert_orig_pos = 0; /* flag */
  int check_side_flag;     /* flag */
  double edge_length;      /* length of the shared edge */
  /* positions of the shared vertices along the shared edge,
     measured relative to the shared edge length for the original tile */
  double orig_pos_1 = -1, orig_pos_2 = -1;
  /* number of tile vertices on the common edge */
  const int new_pos_size = new_grid-&gt;n + 1;
  /* array of the positions of tile vertices on the common edge */
  std::vector&lt;double&gt; new_pos(new_pos_size);

  /* each tile vertex on the common shared edge is connected to
     3 tiles (the end points of the shared edge are connected
     to 1 tile). */
  /* 2-dimensional array of the tile indices */
  std::vector&lt;std::vector&lt;int&gt;&gt; new_tile_idx(new_pos_size);
  for (auto&amp; elem: new_tile_idx) {
    elem.resize(3);
  }

  int i, k;
  /* what vertices of new wall are shared with original wall */
  int shared_vert_1 = -1, shared_vert_2 = -1;
  /* what indices of the shared vertices refer to the vertex &quot;start&quot;
     and &quot;end&quot; for &quot;original&quot; wall */
  int new_start_index, new_end_index;

  int tiles_added = 0; /* counter of added tiles */

  if (orig_grid == new_grid) {
    mcell_internal_error(&quot;Function 'add_more_tile_neighbors_to_list()' should &quot;
                         &quot;be called for different grids only&quot;);
  }

  /* find out relative positions of vertices of original tile
     on the common edge */
  edge_length = distance_vec3(start, end);
  if (orig_stripe == 0) {
    if (orig_strip &gt; 0) {
      if (orig_flip == 0) {
        orig_pos_1 = orig_strip * edge_length / (orig_grid-&gt;n);
        orig_pos_2 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
      } else { /* (orig_flip == 1) */
        orig_pos_1 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
      }
    } else {
      /* find out common edge refers to what side of the original wall */
      if (edge_index == 0) {
        if (orig_flip == 0) {
          orig_pos_1 = orig_stripe * edge_length / (orig_grid-&gt;n);
          orig_pos_2 = (orig_stripe + 1) * edge_length / (orig_grid-&gt;n);
        } else { /* (orig_flip == 1) */
<A NAME="0"></A>          orig_pos_1 = (orig_stripe + 1) * edge_length / (orig_grid-&gt;n);
        }
      } else if (edge_index == 1) {
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1323-0.html#0',2,'match1323-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>        if (orig_flip == 0) {
          orig_pos_1 = (orig_strip) * edge_length / (orig_grid-&gt;n);
        } else { /* (orig_flip == 1) */
          orig_pos_1 = orig_strip * edge_length / (orig_grid-&gt;n);
          orig_pos_2 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
        }
      } else if (edge_index == 2) {</B></FONT>
        if (orig_flip == 0) {
          orig_pos_1 = orig_strip * edge_length / (orig_grid-&gt;n);
          orig_pos_2 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
        } else { /* (orig_flip == 1) */
          orig_pos_1 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
        }

      } else {
        mcell_internal_error(
            &quot;Error in the function 'add_more_tile_neighbors_to_list_fast()'.&quot;);
      }
    }
  }

  check_side_flag = 0;
  if ((orig_strip == 0) &amp;&amp; (orig_stripe &gt; 0)) {
    if (orig_stripe == orig_grid-&gt;n - 1)
      check_side_flag = 1;
    if ((orig_stripe == orig_grid-&gt;n - 2) &amp;&amp; (orig_flip == 1))
      check_side_flag = 1;
    if (!check_side_flag) {
      if (orig_flip == 0) {
        orig_pos_1 = orig_stripe * edge_length / (orig_grid-&gt;n);
        orig_pos_2 = (orig_stripe + 1) * edge_length / (orig_grid-&gt;n);
      } else { /* (orig_flip == 1) */
        orig_pos_1 = (orig_stripe + 1) * edge_length / (orig_grid-&gt;n);
      }
    } else {
      /* find out common edge refers to what side of the original wall */
      if (edge_index == 0) {
        if (orig_flip == 0) {
          orig_pos_1 = orig_stripe * edge_length / (orig_grid-&gt;n);
          orig_pos_2 = (orig_stripe + 1) * edge_length / (orig_grid-&gt;n);
        } else { /* (orig_flip == 1) */
          orig_pos_1 = (orig_stripe + 1) * edge_length / (orig_grid-&gt;n);
        }
      } else if (edge_index == 1) {
        if (orig_flip == 0) {
          orig_pos_1 = orig_strip * edge_length / (orig_grid-&gt;n);
          orig_pos_2 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
        } else { /* (orig_flip == 1) */
          orig_pos_1 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
        }
      } else {
        mcell_internal_error(
            &quot;Error in the function 'add_more_tile_neighbors_to_list_fast()'.&quot;);
      }
    }
  }

  if ((orig_strip &gt; 0) &amp;&amp; (orig_stripe &gt; 0)) {
    if (orig_flip == 0) {
      orig_pos_1 = orig_strip * edge_length / (orig_grid-&gt;n);
      orig_pos_2 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
    } else { /* (orig_flip == 1) */
      orig_pos_1 = (orig_strip + 1) * edge_length / (orig_grid-&gt;n);
    }
  }

  find_shared_vertices_for_neighbor_walls(orig_grid-&gt;surface, new_grid-&gt;surface,
                                          &amp;shared_vert_1, &amp;shared_vert_2);

  /* set the value of 'invert_orig_pos' flag */
  if (!distinguishable_vec3(start, new_grid-&gt;surface-&gt;vert[shared_vert_1],
                            EPS_C)) {
    new_start_index = shared_vert_1;
    new_end_index = shared_vert_2;
  } else {
    new_start_index = shared_vert_2;
    new_end_index = shared_vert_1;
  }

  if (new_start_index &gt; new_end_index)
    invert_orig_pos = 1;

  /* our coordinate system here is effectively one-dimensional
     shared edge. For the neighbor grid it's orientation is opposite
     to the one we used for the original grid. Let's recalculate
     the positions of the common points on the shared edge depending
     on the neigbor grid shared edge direction */
  if (invert_orig_pos) {
    orig_pos_1 = edge_length - orig_pos_1;
    if (orig_pos_2 &gt; 0) {
      orig_pos_2 = edge_length - orig_pos_2;
    }
  }

  /* find out relative positions of vertices of tile structure
<A NAME="2"></A>     on the common edge for &quot;new_grid&quot; */
  for (i = 0; i &lt; new_pos_size; i++) {
    new_pos[i] = i * edge_length / (new_grid-&gt;n);
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1323-0.html#2',2,'match1323-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  }

  /* index of the shared edge in terms of the &quot;new_grid&quot;.
   Here the edge between vert[0] and vert[1] has index 0,
   the edge between vert[1] and vert[2] has index 1,
   and the edge between vert[0] and vert[2] has index 2. */
  int new_edge_index = 0;
  if ((shared_vert_1 + shared_vert_2) == 1) {
    new_edge_index = 0;
  } else if ((shared_vert_1 + shared_vert_2) == 2) {
    new_edge_index = 2;
  } else if ((shared_vert_1 + shared_vert_2) == 3) {</B></FONT>
    new_edge_index = 1;
  } else {
    mcell_internal_error(
        &quot;Error in the function 'add_more_tile_neighbors_to_list_fast()'.&quot;);
  }

  /* fill out the array with tile indices for the border layer
     adjacent to the shared edge */
  int last_value;
  if (new_edge_index == 0) {
    new_tile_idx[0][0] = -1;
    new_tile_idx[0][1] = -1;
    new_tile_idx[0][2] = new_grid-&gt;n_tiles - 2 * (new_grid-&gt;n) + 1;
    last_value = new_tile_idx[0][2];

    for (i = 1; i &lt; new_pos_size - 1; i++) {
      for (k = 0; k &lt; 3; k++) {
        new_tile_idx[i][k] = last_value + k;
      }
      last_value = new_tile_idx[i][2];
    }

    new_tile_idx[new_pos_size - 1][0] = last_value;
    new_tile_idx[new_pos_size - 1][1] = -1;
    new_tile_idx[new_pos_size - 1][2] = -1;

  } else if (new_edge_index == 1) {
    new_tile_idx[0][0] = -1;
    new_tile_idx[0][1] = -1;
    new_tile_idx[0][2] = new_grid-&gt;n_tiles - 1;
    last_value = new_tile_idx[0][2];

    for (i = 1; i &lt; new_pos_size - 1; i++) {
      for (k = 0; k &lt; 2; k++) {
        new_tile_idx[i][k] = last_value - k;
      }
      last_value = new_tile_idx[i][1];
      new_tile_idx[i][2] = move_strip_down(new_grid, last_value);
      last_value = new_tile_idx[i][2];
    }
    new_tile_idx[new_pos_size - 1][0] = last_value;
    new_tile_idx[new_pos_size - 1][1] = -1;
    new_tile_idx[new_pos_size - 1][2] = -1;

  } else { /* (new_edge_index == 2) */
    new_tile_idx[0][0] = -1;
    new_tile_idx[0][1] = -1;
    new_tile_idx[0][2] = new_grid-&gt;n_tiles - 2 * (new_grid-&gt;n) + 1;
    last_value = new_tile_idx[0][2];

    for (i = 1; i &lt; new_pos_size - 1; i++) {
      for (k = 0; k &lt; 2; k++) {
        new_tile_idx[i][k] = last_value + k;
      }
      last_value = new_tile_idx[i][1];
      new_tile_idx[i][2] = move_strip_down(new_grid, last_value);
      last_value = new_tile_idx[i][2];
    }
    new_tile_idx[new_pos_size - 1][0] = last_value;
    new_tile_idx[new_pos_size - 1][1] = -1;
    new_tile_idx[new_pos_size - 1][2] = -1;
  }

  int ind_high, ind_low = -1;
  if (orig_pos_1 &gt; orig_pos_2) {
    ind_high = bisect_high(&amp;new_pos[0], new_pos_size, orig_pos_1);
    if (orig_pos_2 &gt; 0) {
      ind_low = bisect(&amp;new_pos[0], new_pos_size, orig_pos_2);
    }

  } else {
    ind_high = bisect_high(&amp;new_pos[0], new_pos_size, orig_pos_2);

    if (orig_pos_1 &gt; 0) {
      ind_low = bisect(&amp;new_pos[0], new_pos_size, orig_pos_1);
    }
  }

  if (ind_low &gt;= 0) {
    for (i = ind_low + 1; i &lt; ind_high; i++) {
      for (k = 0; k &lt; 3; k++) {
        if (push_tile_neighbor_to_list_with_checking(tile_nbr_head, new_grid,
                                                     new_tile_idx[i][k]))
          tiles_added++;
      }
    }

  } else {
    if (push_tile_neighbor_to_list_with_checking(tile_nbr_head, new_grid,
                                                 new_tile_idx[ind_high][0]))
      tiles_added++;
  }

  return tiles_added;
}

/************************************************************************
find_closest_position:
  In: surface grid of the first tile
      first tile index
      surface grid of the second tile
      second (neighbor) tile index
  Out: position of the product on the first tile that is closest
       to the second tile. If the neighbor tiles have common edge
       this position happens to be very close to the center of the
       common edge but inward the first tile.  If the neighbor tiles
       have common vertex, this position happens to be very close to
       to the vertex but inward the first tile.
*************************************************************************/
void find_closest_position(struct surface_grid *grid1, int idx1,
                           struct surface_grid *grid2, int idx2,
                           struct vector2 *p) {

  /* vertices of the first tile */
  struct vector2 R, S, T;
  struct vector3 R_3d, S_3d, T_3d;

  /* vertices of the second tile */
  struct vector2 A, B, C;
  struct vector3 A_3d, B_3d, C_3d;
  /* vertices A,B,C in the coordinate system RST */
  struct vector2 A_new, B_new, C_new;

  /* the ratios in which we divide the segment */
  double k1 = 1e-10; /* this is our good faith assumption */
  double k2 = 1;

  int flip1; /* flip information about first tile */
  int flip2; /* flip information about second tile */

  int num_exact_shared_vertices = 0;
  /* flags */
  int R_shared = 0, S_shared = 0, T_shared = 0;
  int A_shared = 0, B_shared = 0, C_shared = 0;

  /* find out the vertices of the first tile where we will put the product */
  get_tile_vertices(grid1, idx1, &amp;flip1, &amp;R, &amp;S, &amp;T);

  /* the code below tries to increase accuracy for the corner tiles */
  if (is_corner_tile(grid1, idx1)) {
    /* find out the shared vertex */
    int shared_wall_vertex_id_1 = find_wall_vertex_for_corner_tile(grid1, idx1);
    /* note that vertices R, S, T followed clockwise rule */
    if (idx1 == 0) {
      memcpy(&amp;T_3d, grid1-&gt;surface-&gt;vert[shared_wall_vertex_id_1],
             sizeof(struct vector3));
      uv2xyz(&amp;R, grid1-&gt;surface, &amp;R_3d);
      uv2xyz(&amp;S, grid1-&gt;surface, &amp;S_3d);
    } else if ((u_int)idx1 == (grid1-&gt;n_tiles - 2 * (grid1-&gt;n) + 1)) {
      memcpy(&amp;R_3d, grid1-&gt;surface-&gt;vert[shared_wall_vertex_id_1],
             sizeof(struct vector3));
      uv2xyz(&amp;S, grid1-&gt;surface, &amp;S_3d);
      uv2xyz(&amp;T, grid1-&gt;surface, &amp;T_3d);
    } else {
      memcpy(&amp;S_3d, grid1-&gt;surface-&gt;vert[shared_wall_vertex_id_1],
             sizeof(struct vector3));
      uv2xyz(&amp;R, grid1-&gt;surface, &amp;R_3d);
      uv2xyz(&amp;T, grid1-&gt;surface, &amp;T_3d);
    }

  } else {
    uv2xyz(&amp;R, grid1-&gt;surface, &amp;R_3d);
    uv2xyz(&amp;S, grid1-&gt;surface, &amp;S_3d);
    uv2xyz(&amp;T, grid1-&gt;surface, &amp;T_3d);
  }

  /* find out the vertices of the second tile  */
  get_tile_vertices(grid2, idx2, &amp;flip2, &amp;A, &amp;B, &amp;C);

  if (is_corner_tile(grid2, idx2)) {
    /* find out the shared vertex */
    int shared_wall_vertex_id_2 = find_wall_vertex_for_corner_tile(grid2, idx2);
    /* note that vertices A, B, C followed clockwise rule */
    if (idx2 == 0) {
      memcpy(&amp;C_3d, grid2-&gt;surface-&gt;vert[shared_wall_vertex_id_2],
             sizeof(struct vector3));
      uv2xyz(&amp;A, grid2-&gt;surface, &amp;A_3d);
      uv2xyz(&amp;B, grid2-&gt;surface, &amp;B_3d);
    } else if ((u_int)idx2 == (grid2-&gt;n_tiles - 2 * (grid2-&gt;n) + 1)) {
      memcpy(&amp;A_3d, grid2-&gt;surface-&gt;vert[shared_wall_vertex_id_2],
             sizeof(struct vector3));
      uv2xyz(&amp;B, grid2-&gt;surface, &amp;B_3d);
      uv2xyz(&amp;C, grid2-&gt;surface, &amp;C_3d);
    } else {
      memcpy(&amp;B_3d, grid2-&gt;surface-&gt;vert[shared_wall_vertex_id_2],
             sizeof(struct vector3));
      uv2xyz(&amp;A, grid2-&gt;surface, &amp;A_3d);
      uv2xyz(&amp;C, grid2-&gt;surface, &amp;C_3d);
    }

  } else {
    uv2xyz(&amp;A, grid2-&gt;surface, &amp;A_3d);
    uv2xyz(&amp;B, grid2-&gt;surface, &amp;B_3d);
    uv2xyz(&amp;C, grid2-&gt;surface, &amp;C_3d);
  }

  /* find shared vertices */
  if (grid1 == grid2) {
    if (!distinguishable_vec2(&amp;R, &amp;A, EPS_C) ||
        (!distinguishable_vec2(&amp;R, &amp;B, EPS_C)) ||
        (!distinguishable_vec2(&amp;R, &amp;C, EPS_C))) {
      num_exact_shared_vertices++;
      R_shared = 1;
    }
    if (!distinguishable_vec2(&amp;S, &amp;A, EPS_C) ||
        (!distinguishable_vec2(&amp;S, &amp;B, EPS_C)) ||
        (!distinguishable_vec2(&amp;S, &amp;C, EPS_C))) {
      num_exact_shared_vertices++;
      S_shared = 1;
    }
    if (!distinguishable_vec2(&amp;T, &amp;A, EPS_C) ||
        (!distinguishable_vec2(&amp;T, &amp;B, EPS_C)) ||
        (!distinguishable_vec2(&amp;T, &amp;C, EPS_C))) {
      num_exact_shared_vertices++;
      T_shared = 1;
    }

  } else {
    /* below there are cases when the grid structures on the neighbor
       walls are not shifted relative to one another */
    if (!distinguishable_vec3(&amp;R_3d, &amp;A_3d, EPS_C) ||
        (!distinguishable_vec3(&amp;R_3d, &amp;B_3d, EPS_C)) ||
        (!distinguishable_vec3(&amp;R_3d, &amp;C_3d, EPS_C))) {
      num_exact_shared_vertices++;
      R_shared = 1;
    }

    if (!distinguishable_vec3(&amp;S_3d, &amp;A_3d, EPS_C) ||
        (!distinguishable_vec3(&amp;S_3d, &amp;B_3d, EPS_C)) ||
        (!distinguishable_vec3(&amp;S_3d, &amp;C_3d, EPS_C))) {
      num_exact_shared_vertices++;
      S_shared = 1;
    }

    if (!distinguishable_vec3(&amp;T_3d, &amp;A_3d, EPS_C) ||
        (!distinguishable_vec3(&amp;T_3d, &amp;B_3d, EPS_C)) ||
        (!distinguishable_vec3(&amp;T_3d, &amp;C_3d, EPS_C))) {
      num_exact_shared_vertices++;
      T_shared = 1;
    }
  }

  if (num_exact_shared_vertices == 1) {
    if (R_shared) {
      place_product_shared_vertex(&amp;R, &amp;S, &amp;T, p, k1, k2);
      return;
    } else if (S_shared) {
      place_product_shared_vertex(&amp;S, &amp;R, &amp;T, p, k1, k2);
      return;
    } else { /*T is shared */
      place_product_shared_vertex(&amp;T, &amp;R, &amp;S, p, k1, k2);
      return;
    }
  }

  if (num_exact_shared_vertices == 2) {
    if (R_shared &amp;&amp; S_shared) {
      place_product_shared_segment(&amp;R, &amp;S, &amp;T, p, k1, k2);
      return;
    } else if (R_shared &amp;&amp; T_shared) {
      place_product_shared_segment(&amp;R, &amp;T, &amp;S, p, k1, k2);
      return;
    } else { /*S_shared and T_shared */
      place_product_shared_segment(&amp;S, &amp;T, &amp;R, p, k1, k2);
      return;
    }
  }

  if (num_exact_shared_vertices == 0) {
    /* below are the cases when the grids on the neighbor walls
       are shifted relative to one another */
    /* find out whether the vertices of one tile cross the sides of
       another tile */

    if ((intersect_point_segment(&amp;S_3d, &amp;A_3d, &amp;B_3d)) ||
        (intersect_point_segment(&amp;S_3d, &amp;B_3d, &amp;C_3d)) ||
        (intersect_point_segment(&amp;S_3d, &amp;A_3d, &amp;C_3d))) {
      S_shared = 1;
    }

    if ((intersect_point_segment(&amp;R_3d, &amp;A_3d, &amp;B_3d)) ||
        (intersect_point_segment(&amp;R_3d, &amp;B_3d, &amp;C_3d)) ||
        (intersect_point_segment(&amp;R_3d, &amp;A_3d, &amp;C_3d))) {
      R_shared = 1;
    }

    if ((intersect_point_segment(&amp;T_3d, &amp;A_3d, &amp;B_3d)) ||
        (intersect_point_segment(&amp;T_3d, &amp;B_3d, &amp;C_3d)) ||
        (intersect_point_segment(&amp;T_3d, &amp;A_3d, &amp;C_3d))) {
      T_shared = 1;
    }

    if ((intersect_point_segment(&amp;A_3d, &amp;R_3d, &amp;S_3d)) ||
        (intersect_point_segment(&amp;A_3d, &amp;S_3d, &amp;T_3d)) ||
        (intersect_point_segment(&amp;A_3d, &amp;R_3d, &amp;T_3d))) {
      A_shared = 1;
    }

    if ((intersect_point_segment(&amp;B_3d, &amp;R_3d, &amp;S_3d)) ||
        (intersect_point_segment(&amp;B_3d, &amp;S_3d, &amp;T_3d)) ||
        (intersect_point_segment(&amp;B_3d, &amp;R_3d, &amp;T_3d))) {
      B_shared = 1;
    }

    if ((intersect_point_segment(&amp;C_3d, &amp;R_3d, &amp;S_3d)) ||
        (intersect_point_segment(&amp;C_3d, &amp;S_3d, &amp;T_3d)) ||
        (intersect_point_segment(&amp;C_3d, &amp;R_3d, &amp;T_3d))) {
      C_shared = 1;
    }

    /* two vertices shared from the same tile */
    if (R_shared &amp;&amp; S_shared) {
      place_product_shared_segment(&amp;R, &amp;S, &amp;T, p, k1, k2);
      return;
    } else if (R_shared &amp;&amp; T_shared) {
      place_product_shared_segment(&amp;R, &amp;T, &amp;S, p, k1, k2);
      return;
    } else if (S_shared &amp;&amp; T_shared) {
      place_product_shared_segment(&amp;S, &amp;T, &amp;R, p, k1, k2);
      return;
    }

    /* two vertices shared from the same tile */
    if (A_shared &amp;&amp; B_shared) {
      if (parallel_segments(&amp;A_3d, &amp;B_3d, &amp;R_3d, &amp;S_3d)) {
        xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
        xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
        place_product_shared_segment(&amp;A_new, &amp;B_new, &amp;T, p, k1, k2);
        return;
      } else if (parallel_segments(&amp;A_3d, &amp;B_3d, &amp;R_3d, &amp;T_3d)) {
        xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
        xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
        place_product_shared_segment(&amp;A_new, &amp;B_new, &amp;S, p, k1, k2);
        return;
      } else if (parallel_segments(&amp;A_3d, &amp;B_3d, &amp;S_3d, &amp;T_3d)) {
        xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
        xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
        place_product_shared_segment(&amp;A_new, &amp;B_new, &amp;R, p, k1, k2);
        return;
      }

    } else if (A_shared &amp;&amp; C_shared) {
      if (parallel_segments(&amp;A_3d, &amp;C_3d, &amp;R_3d, &amp;S_3d)) {
        xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
        xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
        place_product_shared_segment(&amp;A_new, &amp;C_new, &amp;T, p, k1, k2);
        return;
      } else if (parallel_segments(&amp;A_3d, &amp;C_3d, &amp;R_3d, &amp;T_3d)) {
        xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
        xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
        place_product_shared_segment(&amp;A_new, &amp;C_new, &amp;S, p, k1, k2);
        return;
      } else if (parallel_segments(&amp;A_3d, &amp;C_3d, &amp;S_3d, &amp;T_3d)) {
        xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
        xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
        place_product_shared_segment(&amp;A_new, &amp;C_new, &amp;R, p, k1, k2);
        return;
      }

    } else if (B_shared &amp;&amp; C_shared) {
      if (parallel_segments(&amp;B_3d, &amp;C_3d, &amp;R_3d, &amp;S_3d)) {
        xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
        xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
        place_product_shared_segment(&amp;B_new, &amp;C_new, &amp;T, p, k1, k2);
        return;
      } else if (parallel_segments(&amp;B_3d, &amp;C_3d, &amp;R_3d, &amp;T_3d)) {
        xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
        xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
        place_product_shared_segment(&amp;B_new, &amp;C_new, &amp;S, p, k1, k2);
        return;
      } else if (parallel_segments(&amp;B_3d, &amp;C_3d, &amp;S_3d, &amp;T_3d)) {
        xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
        xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
        place_product_shared_segment(&amp;B_new, &amp;C_new, &amp;R, p, k1, k2);
        return;
      }
    }

    /* one vertex shared from each tile */
    if (R_shared) {
      if (A_shared) {
        if (parallel_segments(&amp;R_3d, &amp;A_3d, &amp;R_3d, &amp;S_3d)) {
          xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
          place_product_shared_segment(&amp;A_new, &amp;R, &amp;T, p, k1, k2);
          return;
        } else if (parallel_segments(&amp;R_3d, &amp;A_3d, &amp;R_3d, &amp;T_3d)) {
          xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
          place_product_shared_segment(&amp;A_new, &amp;R, &amp;S, p, k1, k2);
          return;
        }

      } else if (B_shared) {
        if (parallel_segments(&amp;R_3d, &amp;B_3d, &amp;R_3d, &amp;S_3d)) {
          xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
          place_product_shared_segment(&amp;B_new, &amp;R, &amp;T, p, k1, k2);
          return;
        } else if (parallel_segments(&amp;R_3d, &amp;B_3d, &amp;R_3d, &amp;T_3d)) {
          xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
          place_product_shared_segment(&amp;B_new, &amp;R, &amp;S, p, k1, k2);
          return;
        }

      } else if (C_shared) {
        if (parallel_segments(&amp;R_3d, &amp;C_3d, &amp;R_3d, &amp;S_3d)) {
          xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
          place_product_shared_segment(&amp;C_new, &amp;R, &amp;T, p, k1, k2);
          return;
        } else if (parallel_segments(&amp;R_3d, &amp;C_3d, &amp;R_3d, &amp;T_3d)) {
          xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
          place_product_shared_segment(&amp;C_new, &amp;R, &amp;S, p, k1, k2);
          return;
        }

      } else {
        place_product_shared_vertex(&amp;R, &amp;S, &amp;T, p, k1, k2);
        return;
      }

    } else if (S_shared) {
      if (A_shared) {
        if (parallel_segments(&amp;S_3d, &amp;A_3d, &amp;S_3d, &amp;T_3d)) {
          xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
          place_product_shared_segment(&amp;A_new, &amp;S, &amp;R, p, k1, k2);
          return;
        } else if (parallel_segments(&amp;S_3d, &amp;A_3d, &amp;S_3d, &amp;R_3d)) {
          xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
          place_product_shared_segment(&amp;A_new, &amp;S, &amp;T, p, k1, k2);
          return;
        }

      } else if (B_shared) {
        if (parallel_segments(&amp;S_3d, &amp;B_3d, &amp;S_3d, &amp;T_3d)) {
          xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
          place_product_shared_segment(&amp;B_new, &amp;S, &amp;R, p, k1, k2);
          return;
        } else if (parallel_segments(&amp;S_3d, &amp;B_3d, &amp;S_3d, &amp;R_3d)) {
          xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
          place_product_shared_segment(&amp;B_new, &amp;S, &amp;T, p, k1, k2);
          return;
        }

      } else if (C_shared) {
        if (parallel_segments(&amp;S_3d, &amp;C_3d, &amp;S_3d, &amp;T_3d)) {
          xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
          place_product_shared_segment(&amp;C_new, &amp;S, &amp;R, p, k1, k2);
          return;
        } else if (parallel_segments(&amp;S_3d, &amp;C_3d, &amp;S_3d, &amp;R_3d)) {
          xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
          place_product_shared_segment(&amp;C_new, &amp;S, &amp;T, p, k1, k2);
          return;
        }

      } else {
        place_product_shared_vertex(&amp;S, &amp;R, &amp;T, p, k1, k2);
        return;
      }

    } else if (T_shared) {
      if (A_shared) {
        if (parallel_segments(&amp;T_3d, &amp;A_3d, &amp;T_3d, &amp;S_3d)) {
          xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
          place_product_shared_segment(&amp;A_new, &amp;T, &amp;R, p, k1, k2);
          return;
        } else if (parallel_segments(&amp;T_3d, &amp;A_3d, &amp;T_3d, &amp;R_3d)) {
          xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
          place_product_shared_segment(&amp;A_new, &amp;T, &amp;S, p, k1, k2);
          return;
        }
      } else if (B_shared) {
        if (parallel_segments(&amp;T_3d, &amp;B_3d, &amp;T_3d, &amp;S_3d)) {
          xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
          place_product_shared_segment(&amp;B_new, &amp;T, &amp;R, p, k1, k2);
          return;
        } else if (parallel_segments(&amp;T_3d, &amp;B_3d, &amp;T_3d, &amp;R_3d)) {
          xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
          place_product_shared_segment(&amp;B_new, &amp;T, &amp;S, p, k1, k2);
          return;
        }

      } else if (C_shared) {
        if (parallel_segments(&amp;T_3d, &amp;C_3d, &amp;T_3d, &amp;S_3d)) {
          xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
          place_product_shared_segment(&amp;C_new, &amp;T, &amp;R, p, k1, k2);
          return;
        } else if (parallel_segments(&amp;T_3d, &amp;C_3d, &amp;T_3d, &amp;R_3d)) {
          xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
          place_product_shared_segment(&amp;C_new, &amp;T, &amp;S, p, k1, k2);
          return;
        }

      } else {
        place_product_shared_vertex(&amp;T, &amp;R, &amp;S, p, k1, k2);
        return;
      }
    }

    /* only one vertex is shared */
    if (A_shared) {
      xyz2uv(&amp;A_3d, grid1-&gt;surface, &amp;A_new);
      if (intersect_point_segment(&amp;A_3d, &amp;R_3d, &amp;S_3d)) {
        place_product_close_to_segment_endpoint(&amp;T, &amp;A_new, p, k1, k2);
        return;
      } else if (intersect_point_segment(&amp;A_3d, &amp;R_3d, &amp;T_3d)) {
        place_product_close_to_segment_endpoint(&amp;S, &amp;A_new, p, k1, k2);
        return;
      } else if (intersect_point_segment(&amp;A_3d, &amp;S_3d, &amp;T_3d)) {
        place_product_close_to_segment_endpoint(&amp;R, &amp;A_new, p, k1, k2);
        return;
      }

    } else if (B_shared) {
      xyz2uv(&amp;B_3d, grid1-&gt;surface, &amp;B_new);
      if (intersect_point_segment(&amp;B_3d, &amp;R_3d, &amp;S_3d)) {
        place_product_close_to_segment_endpoint(&amp;T, &amp;B_new, p, k1, k2);
        return;
      } else if (intersect_point_segment(&amp;B_3d, &amp;R_3d, &amp;T_3d)) {
        place_product_close_to_segment_endpoint(&amp;S, &amp;B_new, p, k1, k2);
        return;
      } else if (intersect_point_segment(&amp;B_3d, &amp;S_3d, &amp;T_3d)) {
        place_product_close_to_segment_endpoint(&amp;R, &amp;B_new, p, k1, k2);
        return;
      }
    } else if (C_shared) {
      xyz2uv(&amp;C_3d, grid1-&gt;surface, &amp;C_new);
      if (intersect_point_segment(&amp;C_3d, &amp;R_3d, &amp;S_3d)) {
        place_product_close_to_segment_endpoint(&amp;T, &amp;C_new, p, k1, k2);
        return;
      } else if (intersect_point_segment(&amp;C_3d, &amp;R_3d, &amp;T_3d)) {
        place_product_close_to_segment_endpoint(&amp;S, &amp;C_new, p, k1, k2);
        return;
      } else if (intersect_point_segment(&amp;C_3d, &amp;S_3d, &amp;T_3d)) {
        place_product_close_to_segment_endpoint(&amp;R, &amp;C_new, p, k1, k2);
        return;
      }
    }

  } /* end if (num_exact_shared_vertices == 0) */

  /* Apparently there are some round-up errors that force
     the code to come to this place. Below we will try
     again to place the product. */

  /* find points on the triangle RST that are closest to A, B, C */
  struct vector3 A_close_3d, B_close_3d, C_close_3d;
  double dist_A_A_close_3d, dist_B_B_close_3d, dist_C_C_close_3d, min_dist;
  struct vector3 prod_pos_3d;
  struct vector2 prod_pos;

  closest_pt_point_triangle(&amp;A_3d, &amp;R_3d, &amp;S_3d, &amp;T_3d, &amp;A_close_3d);
  closest_pt_point_triangle(&amp;B_3d, &amp;R_3d, &amp;S_3d, &amp;T_3d, &amp;B_close_3d);
  closest_pt_point_triangle(&amp;C_3d, &amp;R_3d, &amp;S_3d, &amp;T_3d, &amp;C_close_3d);

  dist_A_A_close_3d = distance_vec3(&amp;A_3d, &amp;A_close_3d);
  dist_B_B_close_3d = distance_vec3(&amp;B_3d, &amp;B_close_3d);
  dist_C_C_close_3d = distance_vec3(&amp;C_3d, &amp;C_close_3d);

  min_dist = min3d(dist_A_A_close_3d, dist_B_B_close_3d, dist_C_C_close_3d);

  if (!distinguishable(min_dist, dist_A_A_close_3d, EPS_C)) {
    prod_pos_3d.x = A_close_3d.x;
    prod_pos_3d.y = A_close_3d.y;
    prod_pos_3d.z = A_close_3d.z;
  } else if (!distinguishable(min_dist, dist_B_B_close_3d, EPS_C)) {
    prod_pos_3d.x = B_close_3d.x;
    prod_pos_3d.y = B_close_3d.y;
    prod_pos_3d.z = B_close_3d.z;
  } else {
    prod_pos_3d.x = C_close_3d.x;
    prod_pos_3d.y = C_close_3d.y;
    prod_pos_3d.z = C_close_3d.z;
  }

  xyz2uv(&amp;prod_pos_3d, grid1-&gt;surface, &amp;prod_pos);

  if (intersect_point_segment(&amp;prod_pos_3d, &amp;R_3d, &amp;S_3d)) {
    place_product_close_to_segment_endpoint(&amp;T, &amp;prod_pos, p, k1, k2);
    return;
  } else if (intersect_point_segment(&amp;prod_pos_3d, &amp;R_3d, &amp;T_3d)) {
    place_product_close_to_segment_endpoint(&amp;S, &amp;prod_pos, p, k1, k2);
    return;
  } else if (intersect_point_segment(&amp;prod_pos_3d, &amp;S_3d, &amp;T_3d)) {
    place_product_close_to_segment_endpoint(&amp;R, &amp;prod_pos, p, k1, k2);
    return;
  } else {
    p-&gt;u = prod_pos.u;
    p-&gt;v = prod_pos.v;
    return;
  }

  /* I should not come here... */
  mcell_internal_error(&quot;Error in the function 'find_closest_position()'.&quot;);
}

/*****************************************************************************
is_inner_tile:
   In: Surface grid
       Index of the tile on that grid
   Out: Returns 1 if the tile is an inner tile
        (not on the border with the neighbor walls).
        Returns 0 if the tile is on the border with the neighbor wall.
*****************************************************************************/
int is_inner_tile(struct surface_grid *g, int idx) {
  int root, rootrem, strip, stripe, flip;

  root = (int)(sqrt((double)idx));
  rootrem = idx - root * root;
  strip = g-&gt;n - root - 1;
  stripe = rootrem / 2;
  flip = rootrem - 2 * stripe;

  if ((strip == 0) || (stripe == 0))
    return 0;

  if ((strip + stripe) == g-&gt;n - 1) {
    return 0;
  }

  if (((strip + stripe) == g-&gt;n - 2) &amp;&amp; (flip == 1)) {
    return 0;
  }

  return 1;
}

/*****************************************************************************
is_corner_tile:
   In: Surface grid
       Index of the tile on that grid
   Out: Returns 1 if the tile is a corner tile
        (there are only three corners on each wall).
        Returns 0 if the tile is not a corner tile.
*****************************************************************************/
int is_corner_tile(struct surface_grid *g, int idx) {
  /* tile index at the wall corner with vertex 0 */
  int tile_idx_mid = g-&gt;n_tiles - 2 * (g-&gt;n) + 1;

  if ((idx == 0) || ((u_int)idx == (g-&gt;n_tiles - 1)))
    return 1;

  if (idx == tile_idx_mid)
    return 1;

  return 0;
}

/*****************************************************************************
find_shared_vertices_corner_tile_parent_wall:
   In: Surface grid
       Index of the tile on that grid
       3-member array of indices (in the global array &quot;walls_using_vertex&quot;
            of parent wall vertices that are shared with other walls
            (return value)
   Out: Returns 3-member array of the indices of parent wall vertices
        in the global &quot;world-&gt;walls_using_vertex&quot; array
        that are shared with other neighbor walls.
        If the wall vertex is not shared the corresponding value
        in the return array is not set.
   Note: Used only for corner tiles.  Here some of the tile vertices
         coincide with the wall vertices which in turn may be shared
         with the neighbor walls.
*****************************************************************************/
void find_shared_vertices_corner_tile_parent_wall(struct volume *world,
                                                  struct surface_grid *sg,
                                                  int idx,
                                                  long long int *shared_vert) {
  long long global_vert_index;
  struct vector3 *v;

  if (!world-&gt;create_shared_walls_info_flag)
    mcell_internal_error(&quot;Function &quot;
                         &quot;'find_shared_vertices_corner_tile_parent_wall()' is &quot;
                         &quot;called but shared walls information is not created.&quot;);

  /* check if we are at vertex 0 */
  if ((u_int)idx == (sg-&gt;n_tiles - 2 * (sg-&gt;n) + 1)) {
    v = sg-&gt;surface-&gt;vert[0];
    global_vert_index = (long long)(v - world-&gt;all_vertices);
    if (world-&gt;walls_using_vertex[global_vert_index] != NULL) {
      shared_vert[0] = global_vert_index;
    }
  }

  /* check if we are at vertex 1 */
  if ((u_int)idx == (sg-&gt;n_tiles - 1)) {
    v = sg-&gt;surface-&gt;vert[1];
    global_vert_index = (long long)(v - world-&gt;all_vertices);
    if (world-&gt;walls_using_vertex[global_vert_index] != NULL) {
      shared_vert[1] = global_vert_index;
    }
  }

  /* check if we are at vertex 2 */
  if ((u_int)idx == 0) {
    v = sg-&gt;surface-&gt;vert[2];
    global_vert_index = (long long)(v - world-&gt;all_vertices);
    if (world-&gt;walls_using_vertex[global_vert_index] != NULL) {
      shared_vert[2] = global_vert_index;
    }
  }
}

/*****************************************************************************
move_strip_up:
   In: Wall surface grid and tile index on that grid
   Out: Returns index of the tile that is exactly above the tile
        with index &quot;idx&quot;.  Both &quot;idx&quot; and return index should be
        on the same surface grid.
        Returns (-1) if there is no such tile that satisfies the above
        condition (e.g. when the &quot;idx&quot; tile is in the (strip == 0).)
   Note: The direction &quot;up&quot; means moving to the strip where tile indices
         are greater than index &quot;idx&quot;.
*****************************************************************************/
int move_strip_up(struct surface_grid *grid, int idx) {
  int root;
  int tile_up_idx; /* return value */

  root = (int)(sqrt((double)idx)) + 1;

  if (grid-&gt;n == root) {
    /* tile above is on another wall */
    tile_up_idx = -1;
  } else {
    tile_up_idx = idx + 2 * root;
  }

  return tile_up_idx;
}

/*****************************************************************************
move_strip_down:
   In: Wall surface grid and tile index on that grid
   Out: Returns index of the tile that is exactly below the tile
        with index &quot;idx&quot;.  Both &quot;idx&quot; and return index should be
        on the same surface grid. Both &quot;idx&quot; and &quot;tile down&quot;
        should share the side.
        Returns (-1) if there is no such tile that satisfies the above
        conditions.
   Note: The direction &quot;down&quot; means moving to the strip where tile indices
         are less than index &quot;idx&quot;.
*****************************************************************************/
int move_strip_down(struct surface_grid *grid, int idx) {
  int root, rootrem, strip, stripe, flip;
  int num_tiles_per_strip;
  int tile_down_idx; /* return value */

  /* find internal coordinates (strip, stripe, flip) */
  root = (int)(sqrt((double)idx));
  rootrem = idx - root * root;
  strip = grid-&gt;n - root - 1;
  stripe = rootrem / 2;
  flip = rootrem - 2 * stripe;

  num_tiles_per_strip = 2 * (grid-&gt;n) - 2 * strip - 1;

  if (is_inner_tile(grid, idx)) {
    tile_down_idx = idx - num_tiles_per_strip + 1;
  } else {
    if ((strip == 0) &amp;&amp; (stripe &gt; 0)) {
      if ((unsigned int)idx == grid-&gt;n_tiles - 1) {
        tile_down_idx = -1;
      } else {
        tile_down_idx = idx - num_tiles_per_strip + 1;
      }
    } else {
      /* here we are at the left or right border layers */
      if (flip == 0) {
        tile_down_idx = -1;
      } else {
        tile_down_idx = idx - num_tiles_per_strip + 1;
      }
    }
  }

  return tile_down_idx;
}

/*****************************************************************************
place_product_shared_segment:
   In: segment defined by points R_shared and S_shared
       point T
       position of the product (return value)
       ratios k1 and k2
   Out: coordinates of the point &quot;prod&quot; dividing the distance between T
       and midpont on (R_shared, S_shared) in the ratio k1:k2, so that
       midpoint_prod/midpoint_T = k1/k2
   Note: all points are on the plane
******************************************************************************/

void place_product_shared_segment(struct vector2 *R_shared,
                                  struct vector2 *S_shared, struct vector2 *T,
                                  struct vector2 *prod, double k1, double k2) {
  struct vector2 M; /* midpoint */

  /* find midpoint on the segment (R_shared - S_shared) */
  M.u = 0.5 * (R_shared-&gt;u + S_shared-&gt;u);
  M.v = 0.5 * (R_shared-&gt;v + S_shared-&gt;v);

  /* find coordinates of the  point such that internally
      divides the segment TM in the ratio (k1:k2)
      We want to place the product close to the common edge.
  */
  prod-&gt;u = (k1 * T-&gt;u + k2 * M.u) / (k1 + k2);
  prod-&gt;v = (k1 * T-&gt;v + k2 * M.v) / (k1 + k2);
}

/*****************************************************************************
place_product_shared_vertex:
   In: point R_shared
       segment defined by points S and T
       position of the product (return value)
       ratios k1 and k2
   Out: coordinates of the point &quot;prod&quot; dividing the distance between R_shared
       and midpont on (S, T) in the ratio k1:k2, so that
       R_shared_prod/prod_midpoint = k1/k2
   Note: all points are on the plane
******************************************************************************/
void place_product_shared_vertex(struct vector2 *R_shared, struct vector2 *S,
                                 struct vector2 *T, struct vector2 *prod,
                                 double k1, double k2) {
  struct vector2 M; /* midpoint */

  /* find midpoint on the segment ST */
  M.u = 0.5 * (S-&gt;u + T-&gt;u);
  M.v = 0.5 * (S-&gt;v + T-&gt;v);

  /* find coordinates of the  point such that internally
     divides the segment RM in the ratio (k1:k2)
  */
  prod-&gt;u = (k1 * M.u + k2 * R_shared-&gt;u) / (k1 + k2);
  prod-&gt;v = (k1 * M.v + k2 * R_shared-&gt;v) / (k1 + k2);
}

/*****************************************************************************
place_product_close_to_segment_endpoint:
   In: segment defined by points S (start) and E (end)
       position of the product (return value)
       ratios k1 and k2
   Out: coordinates of the point &quot;prod&quot; dividing the distance between S and E
        in the ratio k1:k2, so that E_prod/S_prod = k1/k2
   Note: all points are on the plane
******************************************************************************/
void place_product_close_to_segment_endpoint(struct vector2 *S,
                                             struct vector2 *E,
                                             struct vector2 *prod, double k1,
                                             double k2) {
  prod-&gt;u = (k1 * S-&gt;u + k2 * E-&gt;u) / (k1 + k2);
  prod-&gt;v = (k1 * S-&gt;v + k2 * E-&gt;v) / (k1 + k2);
}

/***************************************************************************
append_tile_neighbor_list:
   In: linked list of neighbor tiles head1
       linked list of neighbor tiles head2
   Out: list &quot;head2&quot; is appended to the list &quot;head1&quot;
        The original &quot;head2&quot; head is set to NULL
***************************************************************************/
void append_tile_neighbor_list(struct tile_neighbor **head1,
                               struct tile_neighbor **head2) {
  struct tile_neighbor *curr;

  if (*head1 == NULL) /* special case if &quot;head1&quot; is empty */
  {
    *head1 = *head2;
  } else {
    curr = *head1;
    while (curr-&gt;next != NULL) /* find the last node */
    {
      curr = curr-&gt;next;
    }
    curr-&gt;next = *head2;
  }
  *head2 = NULL;
}

/****************************************************************************
find_wall_vertex_for_corner_tile:
   In: surface grid
       tile index on the grid
   Out: corner tile should share one of it's vertices with the wall.
        Returns the shared wall vertex id (index in the array wall_vert[])
****************************************************************************/
int find_wall_vertex_for_corner_tile(struct surface_grid *grid, int idx) {
  /* index of the wall vertex that is shared with the tile vertex */
  int vertex_id = 0;

  if (!is_corner_tile(grid, idx))
    mcell_internal_error(&quot;Function 'find_wall_vertex_for_corner_tile()' is &quot;
                         &quot;called for the tile that is not the corner tile.&quot;);

  if ((u_int)idx == (grid-&gt;n_tiles - 2 * (grid-&gt;n) + 1)) {
    vertex_id = 0;
  } else if ((u_int)idx == (grid-&gt;n_tiles - 1)) {
    vertex_id = 1;
  } else if (idx == 0) {
    vertex_id = 2;
  } else {
    mcell_internal_error(&quot;Function 'find_wall_vertex_for_corner_tile()' is &quot;
                         &quot;called for the tile that is not the corner tile.&quot;);
  }

  return vertex_id;
}

/***********************************************************************
find_shared_vertices_for_neighbor_walls:
   In: original wall
       neighbor wall
       index of the neighbor wall vertex that is
           shared with original wall (return value)
       index of the neighbor wall vertex that is
           shared with original wall (return value)
   Out: neighbor wall shared vertices indices are set up.
***********************************************************************/
void find_shared_vertices_for_neighbor_walls(struct wall *orig_wall,
                                             struct wall *nb_wall,
                                             int *shared_vert_1,
                                             int *shared_vert_2) {

  if ((!distinguishable_vec3(nb_wall-&gt;vert[0], orig_wall-&gt;vert[0], EPS_C)) ||
      (!distinguishable_vec3(nb_wall-&gt;vert[0], orig_wall-&gt;vert[1], EPS_C)) ||
      (!distinguishable_vec3(nb_wall-&gt;vert[0], orig_wall-&gt;vert[2], EPS_C))) {
    *shared_vert_1 = 0;
  }

  if ((!distinguishable_vec3(nb_wall-&gt;vert[1], orig_wall-&gt;vert[0], EPS_C)) ||
      (!distinguishable_vec3(nb_wall-&gt;vert[1], orig_wall-&gt;vert[1], EPS_C)) ||
      (!distinguishable_vec3(nb_wall-&gt;vert[1], orig_wall-&gt;vert[2], EPS_C))) {
    if (*shared_vert_1 &lt; 0) {
      *shared_vert_1 = 1;
    } else {
      *shared_vert_2 = 1;
    }
  }

  if ((!distinguishable_vec3(nb_wall-&gt;vert[2], orig_wall-&gt;vert[0], EPS_C)) ||
      (!distinguishable_vec3(nb_wall-&gt;vert[2], orig_wall-&gt;vert[1], EPS_C)) ||
      (!distinguishable_vec3(nb_wall-&gt;vert[2], orig_wall-&gt;vert[2], EPS_C))) {
    if (*shared_vert_1 &lt; 0) {
      *shared_vert_1 = 2;
    } else {
      *shared_vert_2 = 2;
    }
  }
}

/**************************************************************************
find_neighbor_tiles:
  In: a surface molecule
      surface grid of the wall where hit happens, or
          surface molecule is located
      index of the tile where hit happens, or surface molecule is located
      flag that tells whether we need to create a grid on a neighbor wall
      flag that tells whether we are searching for reactant
          (value = 1) or doing product placement (value = 0)
      a linked list of  neighbor tiles (return value)
      a length of the linked list above (return value)
  Out: The list of nearest neighbors are returned,
       Neighbors should share either common edge or common vertex.
  Note: This version allows looking for the neighbors at the neighbor walls
       that are connected to the start wall through vertices only.
****************************************************************************/
void find_neighbor_tiles(struct volume *world, struct surface_molecule *sm,
                         struct surface_grid *grid, int idx,
                         int create_grid_flag, int search_for_reactant,
                         struct tile_neighbor **tile_nbr_head,
                         int *list_length) {
  int kk;
  struct tile_neighbor *tile_nbr_head_vert = NULL, *tmp_head = NULL;
  int list_length_vert = 0; /* length of the linked list */
  int tmp_list_length = 0;  /* length of the linked list */
  struct vector2 pos;       /* center of the tile */

  /* corner tile may have one or more vertices that coincide with
     the wall vertices which can be shared with the neighbor walls */

  long long shared_vert[3]; /* indices of the vertices of the parent wall
                         in the global array &quot;world-&gt;walls_using_vertex&quot;
                         that are shared with the neighbor walls
                         (used only for the corner tile)  */

  struct wall_list *wall_nbr_head = NULL; /* linked list of neighbor walls */

  for (kk = 0; kk &lt; 3; kk++) {
    shared_vert[kk] = -1;
  }

  if (is_inner_tile(grid, idx)) {
    grid2uv(grid, idx, &amp;pos);
    grid_all_neighbors_for_inner_tile(world, grid, idx, &amp;pos, &amp;tmp_head,
                                      &amp;tmp_list_length);
  } else {
    if (is_corner_tile(grid, idx)) {
      /* find tile vertices that are shared with the parent wall */
      find_shared_vertices_corner_tile_parent_wall(world, grid, idx,
                                                   shared_vert);

      /* create list of neighbor walls that share one vertex
         with the start tile  (not edge-to-edge neighbor walls) */
      wall_nbr_head =
          find_nbr_walls_shared_one_vertex(world, grid-&gt;surface, shared_vert);

      if (wall_nbr_head != NULL) {
        grid_all_neighbors_across_walls_through_vertices(
            world, sm, wall_nbr_head, grid, create_grid_flag,
            search_for_reactant, &amp;tile_nbr_head_vert, &amp;list_length_vert);
      }

      if (wall_nbr_head != NULL) {
        delete_wall_list(wall_nbr_head);
        wall_nbr_head = NULL;
      }

      grid_all_neighbors_across_walls_through_edges(
          world, sm, grid, idx, create_grid_flag, search_for_reactant,
          &amp;tmp_head, &amp;tmp_list_length);

    } else {
      grid_all_neighbors_across_walls_through_edges(
          world, sm, grid, idx, create_grid_flag, search_for_reactant,
          &amp;tmp_head, &amp;tmp_list_length);
    }
  }

  if (tile_nbr_head_vert != NULL) {
    append_tile_neighbor_list(&amp;tmp_head, &amp;tile_nbr_head_vert);
    tmp_list_length += list_length_vert;
  }

  *tile_nbr_head = tmp_head;
  *list_length = tmp_list_length;

#ifdef DEBUG_GRIDS
  dump_tile_neighbors_list(*tile_nbr_head, __FUNCTION__, &quot;  &quot;);
#endif
}


</PRE>
</div>
  </div>
</body>
</html>
