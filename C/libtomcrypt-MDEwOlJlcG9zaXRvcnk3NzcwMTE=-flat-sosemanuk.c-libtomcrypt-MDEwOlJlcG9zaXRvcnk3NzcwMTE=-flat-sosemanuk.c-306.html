
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 53, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-sosemanuk.c</h3>
            <pre><code>1  #include &quot;tomcrypt_private.h&quot;
2  #ifdef LTC_SOSEMANUK
3  #define T32(x)   ((x) &amp; (ulong32)0xFFFFFFFF)
4  #define S0(r0, r1, r2, r3, r4)   do { \
5          r3 ^= r0;  r4  = r1; \
6          r1 &amp;= r3;  r4 ^= r2; \
7          r1 ^= r0;  r0 |= r3; \
8          r0 ^= r4;  r4 ^= r3; \
9          r3 ^= r2;  r2 |= r1; \
10          r2 ^= r4;  r4 = ~r4; \
11          r4 |= r1;  r1 ^= r3; \
12          r1 ^= r4;  r3 |= r0; \
13          r1 ^= r3;  r4 ^= r3; \
14      } while (0)
15  #define S1(r0, r1, r2, r3, r4)   do { \
16          r0 = ~r0;  r2 = ~r2; \
17          r4  = r0;  r0 &amp;= r1; \
18          r2 ^= r0;  r0 |= r3; \
19          r3 ^= r2;  r1 ^= r0; \
20          r0 ^= r4;  r4 |= r1; \
21          r1 ^= r3;  r2 |= r0; \
22          r2 &amp;= r4;  r0 ^= r1; \
23          r1 &amp;= r2; \
24          r1 ^= r0;  r0 &amp;= r2; \
25          r0 ^= r4; \
26      } while (0)
27  #define S2(r0, r1, r2, r3, r4)   do { \
28          r4  = r0;  r0 &amp;= r2; \
29          r0 ^= r3;  r2 ^= r1; \
30          r2 ^= r0;  r3 |= r4; \
31          r3 ^= r1;  r4 ^= r2; \
32          r1  = r3;  r3 |= r4; \
33          r3 ^= r0;  r0 &amp;= r1; \
34          r4 ^= r0;  r1 ^= r3; \
35          r1 ^= r4;  r4 = ~r4; \
36      } while (0)
37  #define S3(r0, r1, r2, r3, r4)   do { \
38          r4  = r0;  r0 |= r3; \
39          r3 ^= r1;  r1 &amp;= r4; \
40          r4 ^= r2;  r2 ^= r3; \
41          r3 &amp;= r0;  r4 |= r1; \
42          r3 ^= r4;  r0 ^= r1; \
43          r4 &amp;= r0;  r1 ^= r3; \
44          r4 ^= r2;  r1 |= r0; \
45          r1 ^= r2;  r0 ^= r3; \
46          r2  = r1;  r1 |= r3; \
47          r1 ^= r0; \
48      } while (0)
49  #define S4(r0, r1, r2, r3, r4)   do { \
50          r1 ^= r3;  r3 = ~r3; \
51          r2 ^= r3;  r3 ^= r0; \
52          r4  = r1;  r1 &amp;= r3; \
53          r1 ^= r2;  r4 ^= r3; \
54          r0 ^= r4;  r2 &amp;= r4; \
55          r2 ^= r0;  r0 &amp;= r1; \
56          r3 ^= r0;  r4 |= r1; \
57          r4 ^= r0;  r0 |= r3; \
58          r0 ^= r2;  r2 &amp;= r3; \
59          r0 = ~r0;  r4 ^= r2; \
60      } while (0)
61  #define S5(r0, r1, r2, r3, r4)   do { \
62          r0 ^= r1;  r1 ^= r3; \
63          r3 = ~r3;  r4  = r1; \
64          r1 &amp;= r0;  r2 ^= r3; \
65          r1 ^= r2;  r2 |= r4; \
66          r4 ^= r3;  r3 &amp;= r1; \
67          r3 ^= r0;  r4 ^= r1; \
68          r4 ^= r2;  r2 ^= r0; \
69          r0 &amp;= r3;  r2 = ~r2; \
70          r0 ^= r4;  r4 |= r3; \
71          r2 ^= r4; \
72      } while (0)
73  #define S6(r0, r1, r2, r3, r4)   do { \
74          r2 = ~r2;  r4  = r3; \
75          r3 &amp;= r0;  r0 ^= r4; \
76          r3 ^= r2;  r2 |= r4; \
77          r1 ^= r3;  r2 ^= r0; \
78          r0 |= r1;  r2 ^= r1; \
79          r4 ^= r0;  r0 |= r3; \
80          r0 ^= r2;  r4 ^= r3; \
81          r4 ^= r0;  r3 = ~r3; \
82          r2 &amp;= r4; \
83          r2 ^= r3; \
84      } while (0)
85  #define S7(r0, r1, r2, r3, r4)   do { \
86          r4  = r1;  r1 |= r2; \
87          r1 ^= r3;  r4 ^= r2; \
88          r2 ^= r1;  r3 |= r4; \
89          r3 &amp;= r0;  r4 ^= r2; \
90          r3 ^= r1;  r1 |= r4; \
91          r1 ^= r0;  r0 |= r4; \
92          r0 ^= r2;  r1 ^= r4; \
93          r2 ^= r1;  r1 &amp;= r0; \
94          r1 ^= r4;  r2 = ~r2; \
95          r2 |= r0; \
96          r4 ^= r2; \
97      } while (0)
98  #define SERPENT_LT(x0, x1, x2, x3)  do { \
99          x0 = ROLc(x0, 13); \
<span onclick='openModal()' class='match'>100          x2 = ROLc(x2, 3); \
101          x1 = x1 ^ x0 ^ x2; \
102          x3 = x3 ^ x2 ^ T32(x0 &lt;&lt; 3); \
103          x1 = ROLc(x1, 1); \
104          x3 = ROLc(x3, 7); \
105          x0 = x0 ^ x1 ^ x3; \
</span>106          x2 = x2 ^ x3 ^ T32(x1 &lt;&lt; 7); \
107          x0 = ROLc(x0, 5); \
108          x2 = ROLc(x2, 22); \
109      } while (0)
110  int sosemanuk_setup(sosemanuk_state *st, const unsigned char *key, unsigned long keylen)
111  {
112  #define SKS(S, o0, o1, o2, o3, d0, d1, d2, d3)   do { \
113          ulong32 r0, r1, r2, r3, r4; \
114          r0 = w ## o0; \
115          r1 = w ## o1; \
116          r2 = w ## o2; \
117          r3 = w ## o3; \
118          S(r0, r1, r2, r3, r4); \
119          st-&gt;kc[i ++] = r ## d0; \
120          st-&gt;kc[i ++] = r ## d1; \
121          st-&gt;kc[i ++] = r ## d2; \
122          st-&gt;kc[i ++] = r ## d3; \
123      } while (0)
124  #define SKS0    SKS(S0, 4, 5, 6, 7, 1, 4, 2, 0)
125  #define SKS1    SKS(S1, 0, 1, 2, 3, 2, 0, 3, 1)
126  #define SKS2    SKS(S2, 4, 5, 6, 7, 2, 3, 1, 4)
127  #define SKS3    SKS(S3, 0, 1, 2, 3, 1, 2, 3, 4)
128  #define SKS4    SKS(S4, 4, 5, 6, 7, 1, 4, 0, 3)
129  #define SKS5    SKS(S5, 0, 1, 2, 3, 1, 3, 0, 2)
130  #define SKS6    SKS(S6, 4, 5, 6, 7, 0, 1, 4, 2)
131  #define SKS7    SKS(S7, 0, 1, 2, 3, 4, 3, 1, 0)
132  #define WUP(wi, wi5, wi3, wi1, cc)   do { \
133          ulong32 tt = (wi) ^ (wi5) ^ (wi3) \
134              ^ (wi1) ^ (0x9E3779B9 ^ (ulong32)(cc)); \
135          (wi) = ROLc(tt, 11); \
136      } while (0)
137  #define WUP0(cc)   do { \
138          WUP(w0, w3, w5, w7, cc); \
139          WUP(w1, w4, w6, w0, cc + 1); \
140          WUP(w2, w5, w7, w1, cc + 2); \
141          WUP(w3, w6, w0, w2, cc + 3); \
142      } while (0)
143  #define WUP1(cc)   do { \
144          WUP(w4, w7, w1, w3, cc); \
145          WUP(w5, w0, w2, w4, cc + 1); \
146          WUP(w6, w1, w3, w5, cc + 2); \
147          WUP(w7, w2, w4, w6, cc + 3); \
148      } while (0)
149      unsigned char wbuf[32];
150      ulong32 w0, w1, w2, w3, w4, w5, w6, w7;
151      int i = 0;
152     LTC_ARGCHK(st  != NULL);
153     LTC_ARGCHK(key != NULL);
154     LTC_ARGCHK(keylen &gt; 0 &amp;&amp; keylen &lt;= 32);
155      XMEMCPY(wbuf, key, keylen);
156      if (keylen &lt; 32) {
157          wbuf[keylen] = 0x01;
158          if (keylen &lt; 31) {
159              XMEMSET(wbuf + keylen + 1, 0, 31 - keylen);
160          }
161      }
162      LOAD32L(w0, wbuf);
163      LOAD32L(w1, wbuf + 4);
164      LOAD32L(w2, wbuf + 8);
165      LOAD32L(w3, wbuf + 12);
166      LOAD32L(w4, wbuf + 16);
167      LOAD32L(w5, wbuf + 20);
168      LOAD32L(w6, wbuf + 24);
169      LOAD32L(w7, wbuf + 28);
170      WUP0(0);   SKS3;
171      WUP1(4);   SKS2;
172      WUP0(8);   SKS1;
173      WUP1(12);  SKS0;
174      WUP0(16);  SKS7;
175      WUP1(20);  SKS6;
176      WUP0(24);  SKS5;
177      WUP1(28);  SKS4;
178      WUP0(32);  SKS3;
179      WUP1(36);  SKS2;
180      WUP0(40);  SKS1;
181      WUP1(44);  SKS0;
182      WUP0(48);  SKS7;
183      WUP1(52);  SKS6;
184      WUP0(56);  SKS5;
185      WUP1(60);  SKS4;
186      WUP0(64);  SKS3;
187      WUP1(68);  SKS2;
188      WUP0(72);  SKS1;
189      WUP1(76);  SKS0;
190      WUP0(80);  SKS7;
191      WUP1(84);  SKS6;
192      WUP0(88);  SKS5;
193      WUP1(92);  SKS4;
194      WUP0(96);  SKS3;
195  #undef SKS
196  #undef SKS0
197  #undef SKS1
198  #undef SKS2
199  #undef SKS3
200  #undef SKS4
201  #undef SKS5
202  #undef SKS6
203  #undef SKS7
204  #undef WUP
205  #undef WUP0
206  #undef WUP1
207      return CRYPT_OK;
208  }
209  int sosemanuk_setiv(sosemanuk_state *st, const unsigned char *iv, unsigned long ivlen)
210  {
211  #define KA(zc, x0, x1, x2, x3)  do { \
212          x0 ^= st-&gt;kc[(zc)]; \
213          x1 ^= st-&gt;kc[(zc) + 1]; \
214          x2 ^= st-&gt;kc[(zc) + 2]; \
215          x3 ^= st-&gt;kc[(zc) + 3]; \
216      } while (0)
217  #define FSS(zc, S, i0, i1, i2, i3, i4, o0, o1, o2, o3)  do { \
218          KA(zc, r ## i0, r ## i1, r ## i2, r ## i3); \
219          S(r ## i0, r ## i1, r ## i2, r ## i3, r ## i4); \
220          SERPENT_LT(r ## o0, r ## o1, r ## o2, r ## o3); \
221      } while (0)
222  #define FSF(zc, S, i0, i1, i2, i3, i4, o0, o1, o2, o3)  do { \
223          KA(zc, r ## i0, r ## i1, r ## i2, r ## i3); \
224          S(r ## i0, r ## i1, r ## i2, r ## i3, r ## i4); \
225          SERPENT_LT(r ## o0, r ## o1, r ## o2, r ## o3); \
226          KA(zc + 4, r ## o0, r ## o1, r ## o2, r ## o3); \
227      } while (0)
228      ulong32 r0, r1, r2, r3, r4;
229      unsigned char ivtmp[16] = {0};
230      LTC_ARGCHK(st != NULL);
231      LTC_ARGCHK(ivlen &lt;= 16);
232      LTC_ARGCHK(iv != NULL || ivlen == 0);
233      if (ivlen &gt; 0) XMEMCPY(ivtmp, iv, ivlen);
234      LOAD32L(r0, ivtmp);
235      LOAD32L(r1, ivtmp + 4);
236      LOAD32L(r2, ivtmp + 8);
237      LOAD32L(r3, ivtmp + 12);
238      FSS(0, S0, 0, 1, 2, 3, 4, 1, 4, 2, 0);
239      FSS(4, S1, 1, 4, 2, 0, 3, 2, 1, 0, 4);
240      FSS(8, S2, 2, 1, 0, 4, 3, 0, 4, 1, 3);
241      FSS(12, S3, 0, 4, 1, 3, 2, 4, 1, 3, 2);
242      FSS(16, S4, 4, 1, 3, 2, 0, 1, 0, 4, 2);
243      FSS(20, S5, 1, 0, 4, 2, 3, 0, 2, 1, 4);
244      FSS(24, S6, 0, 2, 1, 4, 3, 0, 2, 3, 1);
245      FSS(28, S7, 0, 2, 3, 1, 4, 4, 1, 2, 0);
246      FSS(32, S0, 4, 1, 2, 0, 3, 1, 3, 2, 4);
247      FSS(36, S1, 1, 3, 2, 4, 0, 2, 1, 4, 3);
248      FSS(40, S2, 2, 1, 4, 3, 0, 4, 3, 1, 0);
249      FSS(44, S3, 4, 3, 1, 0, 2, 3, 1, 0, 2);
250      st-&gt;s09 = r3;
251      st-&gt;s08 = r1;
252      st-&gt;s07 = r0;
253      st-&gt;s06 = r2;
254      FSS(48, S4, 3, 1, 0, 2, 4, 1, 4, 3, 2);
255      FSS(52, S5, 1, 4, 3, 2, 0, 4, 2, 1, 3);
256      FSS(56, S6, 4, 2, 1, 3, 0, 4, 2, 0, 1);
257      FSS(60, S7, 4, 2, 0, 1, 3, 3, 1, 2, 4);
258      FSS(64, S0, 3, 1, 2, 4, 0, 1, 0, 2, 3);
259      FSS(68, S1, 1, 0, 2, 3, 4, 2, 1, 3, 0);
260      st-&gt;r1  = r2;
261      st-&gt;s04 = r1;
262      st-&gt;r2  = r3;
263      st-&gt;s05 = r0;
264      FSS(72, S2, 2, 1, 3, 0, 4, 3, 0, 1, 4);
265      FSS(76, S3, 3, 0, 1, 4, 2, 0, 1, 4, 2);
266      FSS(80, S4, 0, 1, 4, 2, 3, 1, 3, 0, 2);
267      FSS(84, S5, 1, 3, 0, 2, 4, 3, 2, 1, 0);
268      FSS(88, S6, 3, 2, 1, 0, 4, 3, 2, 4, 1);
269      FSF(92, S7, 3, 2, 4, 1, 0, 0, 1, 2, 3);
270      st-&gt;s03 = r0;
271      st-&gt;s02 = r1;
272      st-&gt;s01 = r2;
273      st-&gt;s00 = r3;
274      st-&gt;ptr = sizeof(st-&gt;buf);
275  #undef KA
276  #undef FSS
277  #undef FSF
278      return CRYPT_OK;
279  }
280  static const ulong32 mul_a[] = {
281      0x00000000, 0xE19FCF13, 0x6B973726, 0x8A08F835,
282      0xD6876E4C, 0x3718A15F, 0xBD10596A, 0x5C8F9679,
283      0x05A7DC98, 0xE438138B, 0x6E30EBBE, 0x8FAF24AD,
284      0xD320B2D4, 0x32BF7DC7, 0xB8B785F2, 0x59284AE1,
285      0x0AE71199, 0xEB78DE8A, 0x617026BF, 0x80EFE9AC,
286      0xDC607FD5, 0x3DFFB0C6, 0xB7F748F3, 0x566887E0,
287      0x0F40CD01, 0xEEDF0212, 0x64D7FA27, 0x85483534,
288      0xD9C7A34D, 0x38586C5E, 0xB250946B, 0x53CF5B78,
289      0x1467229B, 0xF5F8ED88, 0x7FF015BD, 0x9E6FDAAE,
290      0xC2E04CD7, 0x237F83C4, 0xA9777BF1, 0x48E8B4E2,
291      0x11C0FE03, 0xF05F3110, 0x7A57C925, 0x9BC80636,
292      0xC747904F, 0x26D85F5C, 0xACD0A769, 0x4D4F687A,
293      0x1E803302, 0xFF1FFC11, 0x75170424, 0x9488CB37,
294      0xC8075D4E, 0x2998925D, 0xA3906A68, 0x420FA57B,
295      0x1B27EF9A, 0xFAB82089, 0x70B0D8BC, 0x912F17AF,
296      0xCDA081D6, 0x2C3F4EC5, 0xA637B6F0, 0x47A879E3,
297      0x28CE449F, 0xC9518B8C, 0x435973B9, 0xA2C6BCAA,
298      0xFE492AD3, 0x1FD6E5C0, 0x95DE1DF5, 0x7441D2E6,
299      0x2D699807, 0xCCF65714, 0x46FEAF21, 0xA7616032,
300      0xFBEEF64B, 0x1A713958, 0x9079C16D, 0x71E60E7E,
301      0x22295506, 0xC3B69A15, 0x49BE6220, 0xA821AD33,
302      0xF4AE3B4A, 0x1531F459, 0x9F390C6C, 0x7EA6C37F,
303      0x278E899E, 0xC611468D, 0x4C19BEB8, 0xAD8671AB,
304      0xF109E7D2, 0x109628C1, 0x9A9ED0F4, 0x7B011FE7,
305      0x3CA96604, 0xDD36A917, 0x573E5122, 0xB6A19E31,
306      0xEA2E0848, 0x0BB1C75B, 0x81B93F6E, 0x6026F07D,
307      0x390EBA9C, 0xD891758F, 0x52998DBA, 0xB30642A9,
308      0xEF89D4D0, 0x0E161BC3, 0x841EE3F6, 0x65812CE5,
309      0x364E779D, 0xD7D1B88E, 0x5DD940BB, 0xBC468FA8,
310      0xE0C919D1, 0x0156D6C2, 0x8B5E2EF7, 0x6AC1E1E4,
311      0x33E9AB05, 0xD2766416, 0x587E9C23, 0xB9E15330,
312      0xE56EC549, 0x04F10A5A, 0x8EF9F26F, 0x6F663D7C,
313      0x50358897, 0xB1AA4784, 0x3BA2BFB1, 0xDA3D70A2,
314      0x86B2E6DB, 0x672D29C8, 0xED25D1FD, 0x0CBA1EEE,
315      0x5592540F, 0xB40D9B1C, 0x3E056329, 0xDF9AAC3A,
316      0x83153A43, 0x628AF550, 0xE8820D65, 0x091DC276,
317      0x5AD2990E, 0xBB4D561D, 0x3145AE28, 0xD0DA613B,
318      0x8C55F742, 0x6DCA3851, 0xE7C2C064, 0x065D0F77,
319      0x5F754596, 0xBEEA8A85, 0x34E272B0, 0xD57DBDA3,
320      0x89F22BDA, 0x686DE4C9, 0xE2651CFC, 0x03FAD3EF,
321      0x4452AA0C, 0xA5CD651F, 0x2FC59D2A, 0xCE5A5239,
322      0x92D5C440, 0x734A0B53, 0xF942F366, 0x18DD3C75,
323      0x41F57694, 0xA06AB987, 0x2A6241B2, 0xCBFD8EA1,
324      0x977218D8, 0x76EDD7CB, 0xFCE52FFE, 0x1D7AE0ED,
325      0x4EB5BB95, 0xAF2A7486, 0x25228CB3, 0xC4BD43A0,
326      0x9832D5D9, 0x79AD1ACA, 0xF3A5E2FF, 0x123A2DEC,
327      0x4B12670D, 0xAA8DA81E, 0x2085502B, 0xC11A9F38,
328      0x9D950941, 0x7C0AC652, 0xF6023E67, 0x179DF174,
329      0x78FBCC08, 0x9964031B, 0x136CFB2E, 0xF2F3343D,
330      0xAE7CA244, 0x4FE36D57, 0xC5EB9562, 0x24745A71,
331      0x7D5C1090, 0x9CC3DF83, 0x16CB27B6, 0xF754E8A5,
332      0xABDB7EDC, 0x4A44B1CF, 0xC04C49FA, 0x21D386E9,
333      0x721CDD91, 0x93831282, 0x198BEAB7, 0xF81425A4,
334      0xA49BB3DD, 0x45047CCE, 0xCF0C84FB, 0x2E934BE8,
335      0x77BB0109, 0x9624CE1A, 0x1C2C362F, 0xFDB3F93C,
336      0xA13C6F45, 0x40A3A056, 0xCAAB5863, 0x2B349770,
337      0x6C9CEE93, 0x8D032180, 0x070BD9B5, 0xE69416A6,
338      0xBA1B80DF, 0x5B844FCC, 0xD18CB7F9, 0x301378EA,
339      0x693B320B, 0x88A4FD18, 0x02AC052D, 0xE333CA3E,
340      0xBFBC5C47, 0x5E239354, 0xD42B6B61, 0x35B4A472,
341      0x667BFF0A, 0x87E43019, 0x0DECC82C, 0xEC73073F,
342      0xB0FC9146, 0x51635E55, 0xDB6BA660, 0x3AF46973,
343      0x63DC2392, 0x8243EC81, 0x084B14B4, 0xE9D4DBA7,
344      0xB55B4DDE, 0x54C482CD, 0xDECC7AF8, 0x3F53B5EB
345  };
346  static const ulong32 mul_ia[] = {
347      0x00000000, 0x180F40CD, 0x301E8033, 0x2811C0FE,
348      0x603CA966, 0x7833E9AB, 0x50222955, 0x482D6998,
349      0xC078FBCC, 0xD877BB01, 0xF0667BFF, 0xE8693B32,
350      0xA04452AA, 0xB84B1267, 0x905AD299, 0x88559254,
351      0x29F05F31, 0x31FF1FFC, 0x19EEDF02, 0x01E19FCF,
352      0x49CCF657, 0x51C3B69A, 0x79D27664, 0x61DD36A9,
353      0xE988A4FD, 0xF187E430, 0xD99624CE, 0xC1996403,
354      0x89B40D9B, 0x91BB4D56, 0xB9AA8DA8, 0xA1A5CD65,
355      0x5249BE62, 0x4A46FEAF, 0x62573E51, 0x7A587E9C,
356      0x32751704, 0x2A7A57C9, 0x026B9737, 0x1A64D7FA,
357      0x923145AE, 0x8A3E0563, 0xA22FC59D, 0xBA208550,
358      0xF20DECC8, 0xEA02AC05, 0xC2136CFB, 0xDA1C2C36,
359      0x7BB9E153, 0x63B6A19E, 0x4BA76160, 0x53A821AD,
360      0x1B854835, 0x038A08F8, 0x2B9BC806, 0x339488CB,
361      0xBBC11A9F, 0xA3CE5A52, 0x8BDF9AAC, 0x93D0DA61,
362      0xDBFDB3F9, 0xC3F2F334, 0xEBE333CA, 0xF3EC7307,
363      0xA492D5C4, 0xBC9D9509, 0x948C55F7, 0x8C83153A,
364      0xC4AE7CA2, 0xDCA13C6F, 0xF4B0FC91, 0xECBFBC5C,
365      0x64EA2E08, 0x7CE56EC5, 0x54F4AE3B, 0x4CFBEEF6,
366      0x04D6876E, 0x1CD9C7A3, 0x34C8075D, 0x2CC74790,
367      0x8D628AF5, 0x956DCA38, 0xBD7C0AC6, 0xA5734A0B,
368      0xED5E2393, 0xF551635E, 0xDD40A3A0, 0xC54FE36D,
369      0x4D1A7139, 0x551531F4, 0x7D04F10A, 0x650BB1C7,
370      0x2D26D85F, 0x35299892, 0x1D38586C, 0x053718A1,
371      0xF6DB6BA6, 0xEED42B6B, 0xC6C5EB95, 0xDECAAB58,
372      0x96E7C2C0, 0x8EE8820D, 0xA6F942F3, 0xBEF6023E,
373      0x36A3906A, 0x2EACD0A7, 0x06BD1059, 0x1EB25094,
374      0x569F390C, 0x4E9079C1, 0x6681B93F, 0x7E8EF9F2,
375      0xDF2B3497, 0xC724745A, 0xEF35B4A4, 0xF73AF469,
376      0xBF179DF1, 0xA718DD3C, 0x8F091DC2, 0x97065D0F,
377      0x1F53CF5B, 0x075C8F96, 0x2F4D4F68, 0x37420FA5,
378      0x7F6F663D, 0x676026F0, 0x4F71E60E, 0x577EA6C3,
379      0xE18D0321, 0xF98243EC, 0xD1938312, 0xC99CC3DF,
380      0x81B1AA47, 0x99BEEA8A, 0xB1AF2A74, 0xA9A06AB9,
381      0x21F5F8ED, 0x39FAB820, 0x11EB78DE, 0x09E43813,
382      0x41C9518B, 0x59C61146, 0x71D7D1B8, 0x69D89175,
383      0xC87D5C10, 0xD0721CDD, 0xF863DC23, 0xE06C9CEE,
384      0xA841F576, 0xB04EB5BB, 0x985F7545, 0x80503588,
385      0x0805A7DC, 0x100AE711, 0x381B27EF, 0x20146722,
386      0x68390EBA, 0x70364E77, 0x58278E89, 0x4028CE44,
387      0xB3C4BD43, 0xABCBFD8E, 0x83DA3D70, 0x9BD57DBD,
388      0xD3F81425, 0xCBF754E8, 0xE3E69416, 0xFBE9D4DB,
389      0x73BC468F, 0x6BB30642, 0x43A2C6BC, 0x5BAD8671,
390      0x1380EFE9, 0x0B8FAF24, 0x239E6FDA, 0x3B912F17,
391      0x9A34E272, 0x823BA2BF, 0xAA2A6241, 0xB225228C,
392      0xFA084B14, 0xE2070BD9, 0xCA16CB27, 0xD2198BEA,
393      0x5A4C19BE, 0x42435973, 0x6A52998D, 0x725DD940,
394      0x3A70B0D8, 0x227FF015, 0x0A6E30EB, 0x12617026,
395      0x451FD6E5, 0x5D109628, 0x750156D6, 0x6D0E161B,
396      0x25237F83, 0x3D2C3F4E, 0x153DFFB0, 0x0D32BF7D,
397      0x85672D29, 0x9D686DE4, 0xB579AD1A, 0xAD76EDD7,
398      0xE55B844F, 0xFD54C482, 0xD545047C, 0xCD4A44B1,
399      0x6CEF89D4, 0x74E0C919, 0x5CF109E7, 0x44FE492A,
400      0x0CD320B2, 0x14DC607F, 0x3CCDA081, 0x24C2E04C,
401      0xAC977218, 0xB49832D5, 0x9C89F22B, 0x8486B2E6,
402      0xCCABDB7E, 0xD4A49BB3, 0xFCB55B4D, 0xE4BA1B80,
403      0x17566887, 0x0F59284A, 0x2748E8B4, 0x3F47A879,
404      0x776AC1E1, 0x6F65812C, 0x477441D2, 0x5F7B011F,
405      0xD72E934B, 0xCF21D386, 0xE7301378, 0xFF3F53B5,
406      0xB7123A2D, 0xAF1D7AE0, 0x870CBA1E, 0x9F03FAD3,
407      0x3EA637B6, 0x26A9777B, 0x0EB8B785, 0x16B7F748,
408      0x5E9A9ED0, 0x4695DE1D, 0x6E841EE3, 0x768B5E2E,
409      0xFEDECC7A, 0xE6D18CB7, 0xCEC04C49, 0xD6CF0C84,
410      0x9EE2651C, 0x86ED25D1, 0xAEFCE52F, 0xB6F3A5E2
411  };
412  static LTC_INLINE void s_sosemanuk_internal(sosemanuk_state *st)
413  {
414  #define MUL_A(x)    (T32((x) &lt;&lt; 8) ^ mul_a[(x) &gt;&gt; 24])
415  #define MUL_G(x)    (((x) &gt;&gt; 8) ^ mul_ia[(x) &amp; 0xFF])
416  #ifdef __alpha
417  #define XMUX(c, x, y)   ((((signed int)((c) &lt;&lt; 31) &gt;&gt; 31) &amp; (y)) ^ (x))
418  #else
419  #define XMUX(c, x, y)   (((c) &amp; 0x1) ? ((x) ^ (y)) : (x))
420  #endif
421  #define FSM(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)   do { \
422          ulong32 tt, or1; \
423          tt = XMUX(r1, s ## x1, s ## x8); \
424          or1 = r1; \
425          r1 = T32(r2 + tt); \
426          tt = T32(or1 * 0x54655307); \
427          r2 = ROLc(tt, 7); \
428      } while (0)
429  #define LRU(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, dd)   do { \
430          dd = s ## x0; \
431          s ## x0 = MUL_A(s ## x0) ^ MUL_G(s ## x3) ^ s ## x9; \
432      } while (0)
433  #define CC1(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, ee)   do { \
434          ee = T32(s ## x9 + r1) ^ r2; \
435      } while (0)
436  #define STEP(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, dd, ee)   do { \
437          FSM(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9); \
438          LRU(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, dd); \
439          CC1(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, ee); \
440      } while (0)
441  #define SRD(S, x0, x1, x2, x3, ooff)   do { \
442          S(u0, u1, u2, u3, u4); \
443          STORE32L(u ## x0 ^ v0, st-&gt;buf + ooff); \
444          STORE32L(u ## x1 ^ v1, st-&gt;buf + ooff +  4); \
445          STORE32L(u ## x2 ^ v2, st-&gt;buf + ooff +  8); \
446          STORE32L(u ## x3 ^ v3, st-&gt;buf + ooff + 12); \
447      } while (0)
448      ulong32 s00 = st-&gt;s00;
449      ulong32 s01 = st-&gt;s01;
450      ulong32 s02 = st-&gt;s02;
451      ulong32 s03 = st-&gt;s03;
452      ulong32 s04 = st-&gt;s04;
453      ulong32 s05 = st-&gt;s05;
454      ulong32 s06 = st-&gt;s06;
455      ulong32 s07 = st-&gt;s07;
456      ulong32 s08 = st-&gt;s08;
457      ulong32 s09 = st-&gt;s09;
458      ulong32 r1 = st-&gt;r1;
459      ulong32 r2 = st-&gt;r2;
460      ulong32 u0, u1, u2, u3, u4;
461      ulong32 v0, v1, v2, v3;
462      STEP(00, 01, 02, 03, 04, 05, 06, 07, 08, 09, v0, u0);
463      STEP(01, 02, 03, 04, 05, 06, 07, 08, 09, 00, v1, u1);
464      STEP(02, 03, 04, 05, 06, 07, 08, 09, 00, 01, v2, u2);
465      STEP(03, 04, 05, 06, 07, 08, 09, 00, 01, 02, v3, u3);
466      SRD(S2, 2, 3, 1, 4, 0);
467      STEP(04, 05, 06, 07, 08, 09, 00, 01, 02, 03, v0, u0);
468      STEP(05, 06, 07, 08, 09, 00, 01, 02, 03, 04, v1, u1);
469      STEP(06, 07, 08, 09, 00, 01, 02, 03, 04, 05, v2, u2);
470      STEP(07, 08, 09, 00, 01, 02, 03, 04, 05, 06, v3, u3);
471      SRD(S2, 2, 3, 1, 4, 16);
472      STEP(08, 09, 00, 01, 02, 03, 04, 05, 06, 07, v0, u0);
473      STEP(09, 00, 01, 02, 03, 04, 05, 06, 07, 08, v1, u1);
474      STEP(00, 01, 02, 03, 04, 05, 06, 07, 08, 09, v2, u2);
475      STEP(01, 02, 03, 04, 05, 06, 07, 08, 09, 00, v3, u3);
476      SRD(S2, 2, 3, 1, 4, 32);
477      STEP(02, 03, 04, 05, 06, 07, 08, 09, 00, 01, v0, u0);
478      STEP(03, 04, 05, 06, 07, 08, 09, 00, 01, 02, v1, u1);
479      STEP(04, 05, 06, 07, 08, 09, 00, 01, 02, 03, v2, u2);
480      STEP(05, 06, 07, 08, 09, 00, 01, 02, 03, 04, v3, u3);
481      SRD(S2, 2, 3, 1, 4, 48);
482      STEP(06, 07, 08, 09, 00, 01, 02, 03, 04, 05, v0, u0);
483      STEP(07, 08, 09, 00, 01, 02, 03, 04, 05, 06, v1, u1);
484      STEP(08, 09, 00, 01, 02, 03, 04, 05, 06, 07, v2, u2);
485      STEP(09, 00, 01, 02, 03, 04, 05, 06, 07, 08, v3, u3);
486      SRD(S2, 2, 3, 1, 4, 64);
487      st-&gt;s00 = s00;
488      st-&gt;s01 = s01;
489      st-&gt;s02 = s02;
490      st-&gt;s03 = s03;
491      st-&gt;s04 = s04;
492      st-&gt;s05 = s05;
493      st-&gt;s06 = s06;
494      st-&gt;s07 = s07;
495      st-&gt;s08 = s08;
496      st-&gt;s09 = s09;
497      st-&gt;r1 = r1;
498      st-&gt;r2 = r2;
499  }
500  static LTC_INLINE void s_xorbuf(const unsigned char *in1, const unsigned char *in2,
501      unsigned char *out, unsigned long datalen)
502  {
503      while (datalen -- &gt; 0) {
504          *out ++ = *in1 ++ ^ *in2 ++;
505      }
506  }
507  int sosemanuk_crypt(sosemanuk_state *st,
508                          const unsigned char *in, unsigned long inlen, unsigned char *out)
509  {
510      LTC_ARGCHK(st  != NULL);
511      LTC_ARGCHK(in  != NULL);
512      LTC_ARGCHK(out != NULL);
513      if (st-&gt;ptr &lt; (sizeof(st-&gt;buf))) {
514          unsigned long rlen = (sizeof(st-&gt;buf)) - st-&gt;ptr;
515          if (rlen &gt; inlen) {
516              rlen = inlen;
517          }
518          s_xorbuf(st-&gt;buf + st-&gt;ptr, in, out, rlen);
519          in += rlen;
520          out += rlen;
521          inlen -= rlen;
522          st-&gt;ptr += rlen;
523      }
524      while (inlen &gt; 0) {
525          s_sosemanuk_internal(st);
526          if (inlen &gt;= sizeof(st-&gt;buf)) {
527              s_xorbuf(st-&gt;buf, in, out, sizeof(st-&gt;buf));
528              in += sizeof(st-&gt;buf);
529              out += sizeof(st-&gt;buf);
530              inlen -= sizeof(st-&gt;buf);
531          } else {
532              s_xorbuf(st-&gt;buf, in, out, inlen);
533              st-&gt;ptr = inlen;
534              inlen = 0;
535          }
536      }
537      return CRYPT_OK;
538  }
539  int sosemanuk_keystream(sosemanuk_state *st, unsigned char *out, unsigned long outlen)
540  {
541     if (outlen == 0) return CRYPT_OK; &amp;bsol;* nothing to do */
542     LTC_ARGCHK(out != NULL);
543     XMEMSET(out, 0, outlen);
544     return sosemanuk_crypt(st, out, outlen, out);
545  }
546  int sosemanuk_done(sosemanuk_state *st)
547  {
548     LTC_ARGCHK(st != NULL);
549     zeromem(st, sizeof(sosemanuk_state));
550     return CRYPT_OK;
551  }
552  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-sosemanuk.c</h3>
            <pre><code>1  #include &quot;tomcrypt_private.h&quot;
2  #ifdef LTC_SOSEMANUK
3  #define T32(x)   ((x) &amp; (ulong32)0xFFFFFFFF)
4  #define S0(r0, r1, r2, r3, r4)   do { \
5          r3 ^= r0;  r4  = r1; \
6          r1 &amp;= r3;  r4 ^= r2; \
7          r1 ^= r0;  r0 |= r3; \
8          r0 ^= r4;  r4 ^= r3; \
9          r3 ^= r2;  r2 |= r1; \
10          r2 ^= r4;  r4 = ~r4; \
11          r4 |= r1;  r1 ^= r3; \
12          r1 ^= r4;  r3 |= r0; \
13          r1 ^= r3;  r4 ^= r3; \
14      } while (0)
15  #define S1(r0, r1, r2, r3, r4)   do { \
16          r0 = ~r0;  r2 = ~r2; \
17          r4  = r0;  r0 &amp;= r1; \
18          r2 ^= r0;  r0 |= r3; \
19          r3 ^= r2;  r1 ^= r0; \
20          r0 ^= r4;  r4 |= r1; \
21          r1 ^= r3;  r2 |= r0; \
22          r2 &amp;= r4;  r0 ^= r1; \
23          r1 &amp;= r2; \
24          r1 ^= r0;  r0 &amp;= r2; \
25          r0 ^= r4; \
26      } while (0)
27  #define S2(r0, r1, r2, r3, r4)   do { \
28          r4  = r0;  r0 &amp;= r2; \
29          r0 ^= r3;  r2 ^= r1; \
30          r2 ^= r0;  r3 |= r4; \
31          r3 ^= r1;  r4 ^= r2; \
32          r1  = r3;  r3 |= r4; \
33          r3 ^= r0;  r0 &amp;= r1; \
34          r4 ^= r0;  r1 ^= r3; \
35          r1 ^= r4;  r4 = ~r4; \
36      } while (0)
37  #define S3(r0, r1, r2, r3, r4)   do { \
38          r4  = r0;  r0 |= r3; \
39          r3 ^= r1;  r1 &amp;= r4; \
40          r4 ^= r2;  r2 ^= r3; \
41          r3 &amp;= r0;  r4 |= r1; \
42          r3 ^= r4;  r0 ^= r1; \
43          r4 &amp;= r0;  r1 ^= r3; \
44          r4 ^= r2;  r1 |= r0; \
45          r1 ^= r2;  r0 ^= r3; \
46          r2  = r1;  r1 |= r3; \
47          r1 ^= r0; \
48      } while (0)
49  #define S4(r0, r1, r2, r3, r4)   do { \
50          r1 ^= r3;  r3 = ~r3; \
51          r2 ^= r3;  r3 ^= r0; \
52          r4  = r1;  r1 &amp;= r3; \
53          r1 ^= r2;  r4 ^= r3; \
54          r0 ^= r4;  r2 &amp;= r4; \
55          r2 ^= r0;  r0 &amp;= r1; \
56          r3 ^= r0;  r4 |= r1; \
57          r4 ^= r0;  r0 |= r3; \
58          r0 ^= r2;  r2 &amp;= r3; \
59          r0 = ~r0;  r4 ^= r2; \
60      } while (0)
61  #define S5(r0, r1, r2, r3, r4)   do { \
62          r0 ^= r1;  r1 ^= r3; \
63          r3 = ~r3;  r4  = r1; \
64          r1 &amp;= r0;  r2 ^= r3; \
65          r1 ^= r2;  r2 |= r4; \
66          r4 ^= r3;  r3 &amp;= r1; \
67          r3 ^= r0;  r4 ^= r1; \
68          r4 ^= r2;  r2 ^= r0; \
69          r0 &amp;= r3;  r2 = ~r2; \
70          r0 ^= r4;  r4 |= r3; \
71          r2 ^= r4; \
72      } while (0)
73  #define S6(r0, r1, r2, r3, r4)   do { \
74          r2 = ~r2;  r4  = r3; \
75          r3 &amp;= r0;  r0 ^= r4; \
76          r3 ^= r2;  r2 |= r4; \
77          r1 ^= r3;  r2 ^= r0; \
78          r0 |= r1;  r2 ^= r1; \
79          r4 ^= r0;  r0 |= r3; \
80          r0 ^= r2;  r4 ^= r3; \
81          r4 ^= r0;  r3 = ~r3; \
82          r2 &amp;= r4; \
83          r2 ^= r3; \
84      } while (0)
85  #define S7(r0, r1, r2, r3, r4)   do { \
86          r4  = r1;  r1 |= r2; \
87          r1 ^= r3;  r4 ^= r2; \
88          r2 ^= r1;  r3 |= r4; \
89          r3 &amp;= r0;  r4 ^= r2; \
90          r3 ^= r1;  r1 |= r4; \
91          r1 ^= r0;  r0 |= r4; \
92          r0 ^= r2;  r1 ^= r4; \
93          r2 ^= r1;  r1 &amp;= r0; \
94          r1 ^= r4;  r2 = ~r2; \
95          r2 |= r0; \
96          r4 ^= r2; \
97      } while (0)
98  #define SERPENT_LT(x0, x1, x2, x3)  do { \
99          x0 = ROLc(x0, 13); \
100          x2 = ROLc(x2, 3); \
101          x1 = x1 ^ x0 ^ x2; \
102          x3 = x3 ^ x2 ^ T32(x0 &lt;&lt; 3); \
103          x1 = ROLc(x1, 1); \
<span onclick='openModal()' class='match'>104          x3 = ROLc(x3, 7); \
105          x0 = x0 ^ x1 ^ x3; \
106          x2 = x2 ^ x3 ^ T32(x1 &lt;&lt; 7); \
107          x0 = ROLc(x0, 5); \
108          x2 = ROLc(x2, 22); \
109      } while (0)
</span>110  int sosemanuk_setup(sosemanuk_state *st, const unsigned char *key, unsigned long keylen)
111  {
112  #define SKS(S, o0, o1, o2, o3, d0, d1, d2, d3)   do { \
113          ulong32 r0, r1, r2, r3, r4; \
114          r0 = w ## o0; \
115          r1 = w ## o1; \
116          r2 = w ## o2; \
117          r3 = w ## o3; \
118          S(r0, r1, r2, r3, r4); \
119          st-&gt;kc[i ++] = r ## d0; \
120          st-&gt;kc[i ++] = r ## d1; \
121          st-&gt;kc[i ++] = r ## d2; \
122          st-&gt;kc[i ++] = r ## d3; \
123      } while (0)
124  #define SKS0    SKS(S0, 4, 5, 6, 7, 1, 4, 2, 0)
125  #define SKS1    SKS(S1, 0, 1, 2, 3, 2, 0, 3, 1)
126  #define SKS2    SKS(S2, 4, 5, 6, 7, 2, 3, 1, 4)
127  #define SKS3    SKS(S3, 0, 1, 2, 3, 1, 2, 3, 4)
128  #define SKS4    SKS(S4, 4, 5, 6, 7, 1, 4, 0, 3)
129  #define SKS5    SKS(S5, 0, 1, 2, 3, 1, 3, 0, 2)
130  #define SKS6    SKS(S6, 4, 5, 6, 7, 0, 1, 4, 2)
131  #define SKS7    SKS(S7, 0, 1, 2, 3, 4, 3, 1, 0)
132  #define WUP(wi, wi5, wi3, wi1, cc)   do { \
133          ulong32 tt = (wi) ^ (wi5) ^ (wi3) \
134              ^ (wi1) ^ (0x9E3779B9 ^ (ulong32)(cc)); \
135          (wi) = ROLc(tt, 11); \
136      } while (0)
137  #define WUP0(cc)   do { \
138          WUP(w0, w3, w5, w7, cc); \
139          WUP(w1, w4, w6, w0, cc + 1); \
140          WUP(w2, w5, w7, w1, cc + 2); \
141          WUP(w3, w6, w0, w2, cc + 3); \
142      } while (0)
143  #define WUP1(cc)   do { \
144          WUP(w4, w7, w1, w3, cc); \
145          WUP(w5, w0, w2, w4, cc + 1); \
146          WUP(w6, w1, w3, w5, cc + 2); \
147          WUP(w7, w2, w4, w6, cc + 3); \
148      } while (0)
149      unsigned char wbuf[32];
150      ulong32 w0, w1, w2, w3, w4, w5, w6, w7;
151      int i = 0;
152     LTC_ARGCHK(st  != NULL);
153     LTC_ARGCHK(key != NULL);
154     LTC_ARGCHK(keylen &gt; 0 &amp;&amp; keylen &lt;= 32);
155      XMEMCPY(wbuf, key, keylen);
156      if (keylen &lt; 32) {
157          wbuf[keylen] = 0x01;
158          if (keylen &lt; 31) {
159              XMEMSET(wbuf + keylen + 1, 0, 31 - keylen);
160          }
161      }
162      LOAD32L(w0, wbuf);
163      LOAD32L(w1, wbuf + 4);
164      LOAD32L(w2, wbuf + 8);
165      LOAD32L(w3, wbuf + 12);
166      LOAD32L(w4, wbuf + 16);
167      LOAD32L(w5, wbuf + 20);
168      LOAD32L(w6, wbuf + 24);
169      LOAD32L(w7, wbuf + 28);
170      WUP0(0);   SKS3;
171      WUP1(4);   SKS2;
172      WUP0(8);   SKS1;
173      WUP1(12);  SKS0;
174      WUP0(16);  SKS7;
175      WUP1(20);  SKS6;
176      WUP0(24);  SKS5;
177      WUP1(28);  SKS4;
178      WUP0(32);  SKS3;
179      WUP1(36);  SKS2;
180      WUP0(40);  SKS1;
181      WUP1(44);  SKS0;
182      WUP0(48);  SKS7;
183      WUP1(52);  SKS6;
184      WUP0(56);  SKS5;
185      WUP1(60);  SKS4;
186      WUP0(64);  SKS3;
187      WUP1(68);  SKS2;
188      WUP0(72);  SKS1;
189      WUP1(76);  SKS0;
190      WUP0(80);  SKS7;
191      WUP1(84);  SKS6;
192      WUP0(88);  SKS5;
193      WUP1(92);  SKS4;
194      WUP0(96);  SKS3;
195  #undef SKS
196  #undef SKS0
197  #undef SKS1
198  #undef SKS2
199  #undef SKS3
200  #undef SKS4
201  #undef SKS5
202  #undef SKS6
203  #undef SKS7
204  #undef WUP
205  #undef WUP0
206  #undef WUP1
207      return CRYPT_OK;
208  }
209  int sosemanuk_setiv(sosemanuk_state *st, const unsigned char *iv, unsigned long ivlen)
210  {
211  #define KA(zc, x0, x1, x2, x3)  do { \
212          x0 ^= st-&gt;kc[(zc)]; \
213          x1 ^= st-&gt;kc[(zc) + 1]; \
214          x2 ^= st-&gt;kc[(zc) + 2]; \
215          x3 ^= st-&gt;kc[(zc) + 3]; \
216      } while (0)
217  #define FSS(zc, S, i0, i1, i2, i3, i4, o0, o1, o2, o3)  do { \
218          KA(zc, r ## i0, r ## i1, r ## i2, r ## i3); \
219          S(r ## i0, r ## i1, r ## i2, r ## i3, r ## i4); \
220          SERPENT_LT(r ## o0, r ## o1, r ## o2, r ## o3); \
221      } while (0)
222  #define FSF(zc, S, i0, i1, i2, i3, i4, o0, o1, o2, o3)  do { \
223          KA(zc, r ## i0, r ## i1, r ## i2, r ## i3); \
224          S(r ## i0, r ## i1, r ## i2, r ## i3, r ## i4); \
225          SERPENT_LT(r ## o0, r ## o1, r ## o2, r ## o3); \
226          KA(zc + 4, r ## o0, r ## o1, r ## o2, r ## o3); \
227      } while (0)
228      ulong32 r0, r1, r2, r3, r4;
229      unsigned char ivtmp[16] = {0};
230      LTC_ARGCHK(st != NULL);
231      LTC_ARGCHK(ivlen &lt;= 16);
232      LTC_ARGCHK(iv != NULL || ivlen == 0);
233      if (ivlen &gt; 0) XMEMCPY(ivtmp, iv, ivlen);
234      LOAD32L(r0, ivtmp);
235      LOAD32L(r1, ivtmp + 4);
236      LOAD32L(r2, ivtmp + 8);
237      LOAD32L(r3, ivtmp + 12);
238      FSS(0, S0, 0, 1, 2, 3, 4, 1, 4, 2, 0);
239      FSS(4, S1, 1, 4, 2, 0, 3, 2, 1, 0, 4);
240      FSS(8, S2, 2, 1, 0, 4, 3, 0, 4, 1, 3);
241      FSS(12, S3, 0, 4, 1, 3, 2, 4, 1, 3, 2);
242      FSS(16, S4, 4, 1, 3, 2, 0, 1, 0, 4, 2);
243      FSS(20, S5, 1, 0, 4, 2, 3, 0, 2, 1, 4);
244      FSS(24, S6, 0, 2, 1, 4, 3, 0, 2, 3, 1);
245      FSS(28, S7, 0, 2, 3, 1, 4, 4, 1, 2, 0);
246      FSS(32, S0, 4, 1, 2, 0, 3, 1, 3, 2, 4);
247      FSS(36, S1, 1, 3, 2, 4, 0, 2, 1, 4, 3);
248      FSS(40, S2, 2, 1, 4, 3, 0, 4, 3, 1, 0);
249      FSS(44, S3, 4, 3, 1, 0, 2, 3, 1, 0, 2);
250      st-&gt;s09 = r3;
251      st-&gt;s08 = r1;
252      st-&gt;s07 = r0;
253      st-&gt;s06 = r2;
254      FSS(48, S4, 3, 1, 0, 2, 4, 1, 4, 3, 2);
255      FSS(52, S5, 1, 4, 3, 2, 0, 4, 2, 1, 3);
256      FSS(56, S6, 4, 2, 1, 3, 0, 4, 2, 0, 1);
257      FSS(60, S7, 4, 2, 0, 1, 3, 3, 1, 2, 4);
258      FSS(64, S0, 3, 1, 2, 4, 0, 1, 0, 2, 3);
259      FSS(68, S1, 1, 0, 2, 3, 4, 2, 1, 3, 0);
260      st-&gt;r1  = r2;
261      st-&gt;s04 = r1;
262      st-&gt;r2  = r3;
263      st-&gt;s05 = r0;
264      FSS(72, S2, 2, 1, 3, 0, 4, 3, 0, 1, 4);
265      FSS(76, S3, 3, 0, 1, 4, 2, 0, 1, 4, 2);
266      FSS(80, S4, 0, 1, 4, 2, 3, 1, 3, 0, 2);
267      FSS(84, S5, 1, 3, 0, 2, 4, 3, 2, 1, 0);
268      FSS(88, S6, 3, 2, 1, 0, 4, 3, 2, 4, 1);
269      FSF(92, S7, 3, 2, 4, 1, 0, 0, 1, 2, 3);
270      st-&gt;s03 = r0;
271      st-&gt;s02 = r1;
272      st-&gt;s01 = r2;
273      st-&gt;s00 = r3;
274      st-&gt;ptr = sizeof(st-&gt;buf);
275  #undef KA
276  #undef FSS
277  #undef FSF
278      return CRYPT_OK;
279  }
280  static const ulong32 mul_a[] = {
281      0x00000000, 0xE19FCF13, 0x6B973726, 0x8A08F835,
282      0xD6876E4C, 0x3718A15F, 0xBD10596A, 0x5C8F9679,
283      0x05A7DC98, 0xE438138B, 0x6E30EBBE, 0x8FAF24AD,
284      0xD320B2D4, 0x32BF7DC7, 0xB8B785F2, 0x59284AE1,
285      0x0AE71199, 0xEB78DE8A, 0x617026BF, 0x80EFE9AC,
286      0xDC607FD5, 0x3DFFB0C6, 0xB7F748F3, 0x566887E0,
287      0x0F40CD01, 0xEEDF0212, 0x64D7FA27, 0x85483534,
288      0xD9C7A34D, 0x38586C5E, 0xB250946B, 0x53CF5B78,
289      0x1467229B, 0xF5F8ED88, 0x7FF015BD, 0x9E6FDAAE,
290      0xC2E04CD7, 0x237F83C4, 0xA9777BF1, 0x48E8B4E2,
291      0x11C0FE03, 0xF05F3110, 0x7A57C925, 0x9BC80636,
292      0xC747904F, 0x26D85F5C, 0xACD0A769, 0x4D4F687A,
293      0x1E803302, 0xFF1FFC11, 0x75170424, 0x9488CB37,
294      0xC8075D4E, 0x2998925D, 0xA3906A68, 0x420FA57B,
295      0x1B27EF9A, 0xFAB82089, 0x70B0D8BC, 0x912F17AF,
296      0xCDA081D6, 0x2C3F4EC5, 0xA637B6F0, 0x47A879E3,
297      0x28CE449F, 0xC9518B8C, 0x435973B9, 0xA2C6BCAA,
298      0xFE492AD3, 0x1FD6E5C0, 0x95DE1DF5, 0x7441D2E6,
299      0x2D699807, 0xCCF65714, 0x46FEAF21, 0xA7616032,
300      0xFBEEF64B, 0x1A713958, 0x9079C16D, 0x71E60E7E,
301      0x22295506, 0xC3B69A15, 0x49BE6220, 0xA821AD33,
302      0xF4AE3B4A, 0x1531F459, 0x9F390C6C, 0x7EA6C37F,
303      0x278E899E, 0xC611468D, 0x4C19BEB8, 0xAD8671AB,
304      0xF109E7D2, 0x109628C1, 0x9A9ED0F4, 0x7B011FE7,
305      0x3CA96604, 0xDD36A917, 0x573E5122, 0xB6A19E31,
306      0xEA2E0848, 0x0BB1C75B, 0x81B93F6E, 0x6026F07D,
307      0x390EBA9C, 0xD891758F, 0x52998DBA, 0xB30642A9,
308      0xEF89D4D0, 0x0E161BC3, 0x841EE3F6, 0x65812CE5,
309      0x364E779D, 0xD7D1B88E, 0x5DD940BB, 0xBC468FA8,
310      0xE0C919D1, 0x0156D6C2, 0x8B5E2EF7, 0x6AC1E1E4,
311      0x33E9AB05, 0xD2766416, 0x587E9C23, 0xB9E15330,
312      0xE56EC549, 0x04F10A5A, 0x8EF9F26F, 0x6F663D7C,
313      0x50358897, 0xB1AA4784, 0x3BA2BFB1, 0xDA3D70A2,
314      0x86B2E6DB, 0x672D29C8, 0xED25D1FD, 0x0CBA1EEE,
315      0x5592540F, 0xB40D9B1C, 0x3E056329, 0xDF9AAC3A,
316      0x83153A43, 0x628AF550, 0xE8820D65, 0x091DC276,
317      0x5AD2990E, 0xBB4D561D, 0x3145AE28, 0xD0DA613B,
318      0x8C55F742, 0x6DCA3851, 0xE7C2C064, 0x065D0F77,
319      0x5F754596, 0xBEEA8A85, 0x34E272B0, 0xD57DBDA3,
320      0x89F22BDA, 0x686DE4C9, 0xE2651CFC, 0x03FAD3EF,
321      0x4452AA0C, 0xA5CD651F, 0x2FC59D2A, 0xCE5A5239,
322      0x92D5C440, 0x734A0B53, 0xF942F366, 0x18DD3C75,
323      0x41F57694, 0xA06AB987, 0x2A6241B2, 0xCBFD8EA1,
324      0x977218D8, 0x76EDD7CB, 0xFCE52FFE, 0x1D7AE0ED,
325      0x4EB5BB95, 0xAF2A7486, 0x25228CB3, 0xC4BD43A0,
326      0x9832D5D9, 0x79AD1ACA, 0xF3A5E2FF, 0x123A2DEC,
327      0x4B12670D, 0xAA8DA81E, 0x2085502B, 0xC11A9F38,
328      0x9D950941, 0x7C0AC652, 0xF6023E67, 0x179DF174,
329      0x78FBCC08, 0x9964031B, 0x136CFB2E, 0xF2F3343D,
330      0xAE7CA244, 0x4FE36D57, 0xC5EB9562, 0x24745A71,
331      0x7D5C1090, 0x9CC3DF83, 0x16CB27B6, 0xF754E8A5,
332      0xABDB7EDC, 0x4A44B1CF, 0xC04C49FA, 0x21D386E9,
333      0x721CDD91, 0x93831282, 0x198BEAB7, 0xF81425A4,
334      0xA49BB3DD, 0x45047CCE, 0xCF0C84FB, 0x2E934BE8,
335      0x77BB0109, 0x9624CE1A, 0x1C2C362F, 0xFDB3F93C,
336      0xA13C6F45, 0x40A3A056, 0xCAAB5863, 0x2B349770,
337      0x6C9CEE93, 0x8D032180, 0x070BD9B5, 0xE69416A6,
338      0xBA1B80DF, 0x5B844FCC, 0xD18CB7F9, 0x301378EA,
339      0x693B320B, 0x88A4FD18, 0x02AC052D, 0xE333CA3E,
340      0xBFBC5C47, 0x5E239354, 0xD42B6B61, 0x35B4A472,
341      0x667BFF0A, 0x87E43019, 0x0DECC82C, 0xEC73073F,
342      0xB0FC9146, 0x51635E55, 0xDB6BA660, 0x3AF46973,
343      0x63DC2392, 0x8243EC81, 0x084B14B4, 0xE9D4DBA7,
344      0xB55B4DDE, 0x54C482CD, 0xDECC7AF8, 0x3F53B5EB
345  };
346  static const ulong32 mul_ia[] = {
347      0x00000000, 0x180F40CD, 0x301E8033, 0x2811C0FE,
348      0x603CA966, 0x7833E9AB, 0x50222955, 0x482D6998,
349      0xC078FBCC, 0xD877BB01, 0xF0667BFF, 0xE8693B32,
350      0xA04452AA, 0xB84B1267, 0x905AD299, 0x88559254,
351      0x29F05F31, 0x31FF1FFC, 0x19EEDF02, 0x01E19FCF,
352      0x49CCF657, 0x51C3B69A, 0x79D27664, 0x61DD36A9,
353      0xE988A4FD, 0xF187E430, 0xD99624CE, 0xC1996403,
354      0x89B40D9B, 0x91BB4D56, 0xB9AA8DA8, 0xA1A5CD65,
355      0x5249BE62, 0x4A46FEAF, 0x62573E51, 0x7A587E9C,
356      0x32751704, 0x2A7A57C9, 0x026B9737, 0x1A64D7FA,
357      0x923145AE, 0x8A3E0563, 0xA22FC59D, 0xBA208550,
358      0xF20DECC8, 0xEA02AC05, 0xC2136CFB, 0xDA1C2C36,
359      0x7BB9E153, 0x63B6A19E, 0x4BA76160, 0x53A821AD,
360      0x1B854835, 0x038A08F8, 0x2B9BC806, 0x339488CB,
361      0xBBC11A9F, 0xA3CE5A52, 0x8BDF9AAC, 0x93D0DA61,
362      0xDBFDB3F9, 0xC3F2F334, 0xEBE333CA, 0xF3EC7307,
363      0xA492D5C4, 0xBC9D9509, 0x948C55F7, 0x8C83153A,
364      0xC4AE7CA2, 0xDCA13C6F, 0xF4B0FC91, 0xECBFBC5C,
365      0x64EA2E08, 0x7CE56EC5, 0x54F4AE3B, 0x4CFBEEF6,
366      0x04D6876E, 0x1CD9C7A3, 0x34C8075D, 0x2CC74790,
367      0x8D628AF5, 0x956DCA38, 0xBD7C0AC6, 0xA5734A0B,
368      0xED5E2393, 0xF551635E, 0xDD40A3A0, 0xC54FE36D,
369      0x4D1A7139, 0x551531F4, 0x7D04F10A, 0x650BB1C7,
370      0x2D26D85F, 0x35299892, 0x1D38586C, 0x053718A1,
371      0xF6DB6BA6, 0xEED42B6B, 0xC6C5EB95, 0xDECAAB58,
372      0x96E7C2C0, 0x8EE8820D, 0xA6F942F3, 0xBEF6023E,
373      0x36A3906A, 0x2EACD0A7, 0x06BD1059, 0x1EB25094,
374      0x569F390C, 0x4E9079C1, 0x6681B93F, 0x7E8EF9F2,
375      0xDF2B3497, 0xC724745A, 0xEF35B4A4, 0xF73AF469,
376      0xBF179DF1, 0xA718DD3C, 0x8F091DC2, 0x97065D0F,
377      0x1F53CF5B, 0x075C8F96, 0x2F4D4F68, 0x37420FA5,
378      0x7F6F663D, 0x676026F0, 0x4F71E60E, 0x577EA6C3,
379      0xE18D0321, 0xF98243EC, 0xD1938312, 0xC99CC3DF,
380      0x81B1AA47, 0x99BEEA8A, 0xB1AF2A74, 0xA9A06AB9,
381      0x21F5F8ED, 0x39FAB820, 0x11EB78DE, 0x09E43813,
382      0x41C9518B, 0x59C61146, 0x71D7D1B8, 0x69D89175,
383      0xC87D5C10, 0xD0721CDD, 0xF863DC23, 0xE06C9CEE,
384      0xA841F576, 0xB04EB5BB, 0x985F7545, 0x80503588,
385      0x0805A7DC, 0x100AE711, 0x381B27EF, 0x20146722,
386      0x68390EBA, 0x70364E77, 0x58278E89, 0x4028CE44,
387      0xB3C4BD43, 0xABCBFD8E, 0x83DA3D70, 0x9BD57DBD,
388      0xD3F81425, 0xCBF754E8, 0xE3E69416, 0xFBE9D4DB,
389      0x73BC468F, 0x6BB30642, 0x43A2C6BC, 0x5BAD8671,
390      0x1380EFE9, 0x0B8FAF24, 0x239E6FDA, 0x3B912F17,
391      0x9A34E272, 0x823BA2BF, 0xAA2A6241, 0xB225228C,
392      0xFA084B14, 0xE2070BD9, 0xCA16CB27, 0xD2198BEA,
393      0x5A4C19BE, 0x42435973, 0x6A52998D, 0x725DD940,
394      0x3A70B0D8, 0x227FF015, 0x0A6E30EB, 0x12617026,
395      0x451FD6E5, 0x5D109628, 0x750156D6, 0x6D0E161B,
396      0x25237F83, 0x3D2C3F4E, 0x153DFFB0, 0x0D32BF7D,
397      0x85672D29, 0x9D686DE4, 0xB579AD1A, 0xAD76EDD7,
398      0xE55B844F, 0xFD54C482, 0xD545047C, 0xCD4A44B1,
399      0x6CEF89D4, 0x74E0C919, 0x5CF109E7, 0x44FE492A,
400      0x0CD320B2, 0x14DC607F, 0x3CCDA081, 0x24C2E04C,
401      0xAC977218, 0xB49832D5, 0x9C89F22B, 0x8486B2E6,
402      0xCCABDB7E, 0xD4A49BB3, 0xFCB55B4D, 0xE4BA1B80,
403      0x17566887, 0x0F59284A, 0x2748E8B4, 0x3F47A879,
404      0x776AC1E1, 0x6F65812C, 0x477441D2, 0x5F7B011F,
405      0xD72E934B, 0xCF21D386, 0xE7301378, 0xFF3F53B5,
406      0xB7123A2D, 0xAF1D7AE0, 0x870CBA1E, 0x9F03FAD3,
407      0x3EA637B6, 0x26A9777B, 0x0EB8B785, 0x16B7F748,
408      0x5E9A9ED0, 0x4695DE1D, 0x6E841EE3, 0x768B5E2E,
409      0xFEDECC7A, 0xE6D18CB7, 0xCEC04C49, 0xD6CF0C84,
410      0x9EE2651C, 0x86ED25D1, 0xAEFCE52F, 0xB6F3A5E2
411  };
412  static LTC_INLINE void s_sosemanuk_internal(sosemanuk_state *st)
413  {
414  #define MUL_A(x)    (T32((x) &lt;&lt; 8) ^ mul_a[(x) &gt;&gt; 24])
415  #define MUL_G(x)    (((x) &gt;&gt; 8) ^ mul_ia[(x) &amp; 0xFF])
416  #ifdef __alpha
417  #define XMUX(c, x, y)   ((((signed int)((c) &lt;&lt; 31) &gt;&gt; 31) &amp; (y)) ^ (x))
418  #else
419  #define XMUX(c, x, y)   (((c) &amp; 0x1) ? ((x) ^ (y)) : (x))
420  #endif
421  #define FSM(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)   do { \
422          ulong32 tt, or1; \
423          tt = XMUX(r1, s ## x1, s ## x8); \
424          or1 = r1; \
425          r1 = T32(r2 + tt); \
426          tt = T32(or1 * 0x54655307); \
427          r2 = ROLc(tt, 7); \
428      } while (0)
429  #define LRU(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, dd)   do { \
430          dd = s ## x0; \
431          s ## x0 = MUL_A(s ## x0) ^ MUL_G(s ## x3) ^ s ## x9; \
432      } while (0)
433  #define CC1(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, ee)   do { \
434          ee = T32(s ## x9 + r1) ^ r2; \
435      } while (0)
436  #define STEP(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, dd, ee)   do { \
437          FSM(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9); \
438          LRU(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, dd); \
439          CC1(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, ee); \
440      } while (0)
441  #define SRD(S, x0, x1, x2, x3, ooff)   do { \
442          S(u0, u1, u2, u3, u4); \
443          STORE32L(u ## x0 ^ v0, st-&gt;buf + ooff); \
444          STORE32L(u ## x1 ^ v1, st-&gt;buf + ooff +  4); \
445          STORE32L(u ## x2 ^ v2, st-&gt;buf + ooff +  8); \
446          STORE32L(u ## x3 ^ v3, st-&gt;buf + ooff + 12); \
447      } while (0)
448      ulong32 s00 = st-&gt;s00;
449      ulong32 s01 = st-&gt;s01;
450      ulong32 s02 = st-&gt;s02;
451      ulong32 s03 = st-&gt;s03;
452      ulong32 s04 = st-&gt;s04;
453      ulong32 s05 = st-&gt;s05;
454      ulong32 s06 = st-&gt;s06;
455      ulong32 s07 = st-&gt;s07;
456      ulong32 s08 = st-&gt;s08;
457      ulong32 s09 = st-&gt;s09;
458      ulong32 r1 = st-&gt;r1;
459      ulong32 r2 = st-&gt;r2;
460      ulong32 u0, u1, u2, u3, u4;
461      ulong32 v0, v1, v2, v3;
462      STEP(00, 01, 02, 03, 04, 05, 06, 07, 08, 09, v0, u0);
463      STEP(01, 02, 03, 04, 05, 06, 07, 08, 09, 00, v1, u1);
464      STEP(02, 03, 04, 05, 06, 07, 08, 09, 00, 01, v2, u2);
465      STEP(03, 04, 05, 06, 07, 08, 09, 00, 01, 02, v3, u3);
466      SRD(S2, 2, 3, 1, 4, 0);
467      STEP(04, 05, 06, 07, 08, 09, 00, 01, 02, 03, v0, u0);
468      STEP(05, 06, 07, 08, 09, 00, 01, 02, 03, 04, v1, u1);
469      STEP(06, 07, 08, 09, 00, 01, 02, 03, 04, 05, v2, u2);
470      STEP(07, 08, 09, 00, 01, 02, 03, 04, 05, 06, v3, u3);
471      SRD(S2, 2, 3, 1, 4, 16);
472      STEP(08, 09, 00, 01, 02, 03, 04, 05, 06, 07, v0, u0);
473      STEP(09, 00, 01, 02, 03, 04, 05, 06, 07, 08, v1, u1);
474      STEP(00, 01, 02, 03, 04, 05, 06, 07, 08, 09, v2, u2);
475      STEP(01, 02, 03, 04, 05, 06, 07, 08, 09, 00, v3, u3);
476      SRD(S2, 2, 3, 1, 4, 32);
477      STEP(02, 03, 04, 05, 06, 07, 08, 09, 00, 01, v0, u0);
478      STEP(03, 04, 05, 06, 07, 08, 09, 00, 01, 02, v1, u1);
479      STEP(04, 05, 06, 07, 08, 09, 00, 01, 02, 03, v2, u2);
480      STEP(05, 06, 07, 08, 09, 00, 01, 02, 03, 04, v3, u3);
481      SRD(S2, 2, 3, 1, 4, 48);
482      STEP(06, 07, 08, 09, 00, 01, 02, 03, 04, 05, v0, u0);
483      STEP(07, 08, 09, 00, 01, 02, 03, 04, 05, 06, v1, u1);
484      STEP(08, 09, 00, 01, 02, 03, 04, 05, 06, 07, v2, u2);
485      STEP(09, 00, 01, 02, 03, 04, 05, 06, 07, 08, v3, u3);
486      SRD(S2, 2, 3, 1, 4, 64);
487      st-&gt;s00 = s00;
488      st-&gt;s01 = s01;
489      st-&gt;s02 = s02;
490      st-&gt;s03 = s03;
491      st-&gt;s04 = s04;
492      st-&gt;s05 = s05;
493      st-&gt;s06 = s06;
494      st-&gt;s07 = s07;
495      st-&gt;s08 = s08;
496      st-&gt;s09 = s09;
497      st-&gt;r1 = r1;
498      st-&gt;r2 = r2;
499  }
500  static LTC_INLINE void s_xorbuf(const unsigned char *in1, const unsigned char *in2,
501      unsigned char *out, unsigned long datalen)
502  {
503      while (datalen -- &gt; 0) {
504          *out ++ = *in1 ++ ^ *in2 ++;
505      }
506  }
507  int sosemanuk_crypt(sosemanuk_state *st,
508                          const unsigned char *in, unsigned long inlen, unsigned char *out)
509  {
510      LTC_ARGCHK(st  != NULL);
511      LTC_ARGCHK(in  != NULL);
512      LTC_ARGCHK(out != NULL);
513      if (st-&gt;ptr &lt; (sizeof(st-&gt;buf))) {
514          unsigned long rlen = (sizeof(st-&gt;buf)) - st-&gt;ptr;
515          if (rlen &gt; inlen) {
516              rlen = inlen;
517          }
518          s_xorbuf(st-&gt;buf + st-&gt;ptr, in, out, rlen);
519          in += rlen;
520          out += rlen;
521          inlen -= rlen;
522          st-&gt;ptr += rlen;
523      }
524      while (inlen &gt; 0) {
525          s_sosemanuk_internal(st);
526          if (inlen &gt;= sizeof(st-&gt;buf)) {
527              s_xorbuf(st-&gt;buf, in, out, sizeof(st-&gt;buf));
528              in += sizeof(st-&gt;buf);
529              out += sizeof(st-&gt;buf);
530              inlen -= sizeof(st-&gt;buf);
531          } else {
532              s_xorbuf(st-&gt;buf, in, out, inlen);
533              st-&gt;ptr = inlen;
534              inlen = 0;
535          }
536      }
537      return CRYPT_OK;
538  }
539  int sosemanuk_keystream(sosemanuk_state *st, unsigned char *out, unsigned long outlen)
540  {
541     if (outlen == 0) return CRYPT_OK; &amp;bsol;* nothing to do */
542     LTC_ARGCHK(out != NULL);
543     XMEMSET(out, 0, outlen);
544     return sosemanuk_crypt(st, out, outlen, out);
545  }
546  int sosemanuk_done(sosemanuk_state *st)
547  {
548     LTC_ARGCHK(st != NULL);
549     zeromem(st, sizeof(sosemanuk_state));
550     return CRYPT_OK;
551  }
552  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-sosemanuk.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-sosemanuk.c</div>
                </div>
                <div class="column column_space"><pre><code>100          x2 = ROLc(x2, 3); \
101          x1 = x1 ^ x0 ^ x2; \
102          x3 = x3 ^ x2 ^ T32(x0 &lt;&lt; 3); \
103          x1 = ROLc(x1, 1); \
104          x3 = ROLc(x3, 7); \
105          x0 = x0 ^ x1 ^ x3; \
</pre></code></div>
                <div class="column column_space"><pre><code>104          x3 = ROLc(x3, 7); \
105          x0 = x0 ^ x1 ^ x3; \
106          x2 = x2 ^ x3 ^ T32(x1 &lt;&lt; 7); \
107          x0 = ROLc(x0, 5); \
108          x2 = ROLc(x2, 22); \
109      } while (0)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    