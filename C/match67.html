<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for lluv_timer.c &amp; lluv_udp.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for lluv_timer.c &amp; lluv_udp.c
      </h3>
<h1 align="center">
        23.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>lluv_timer.c (61.22449%)<th>lluv_udp.c (14.53958%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(133-160)<td><a href="#" name="0">(639-666)</a><td align="center"><font color="#ff0000">27</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(120-133)<td><a href="#" name="1">(599-614)</a><td align="center"><font color="#bc0000">20</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(73-85)<td><a href="#" name="2">(451-467)</a><td align="center"><font color="#8d0000">15</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(25-36)<td><a href="#" name="3">(60-72)</a><td align="center"><font color="#8d0000">15</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(100-113)<td><a href="#" name="4">(571-585)</a><td align="center"><font color="#7a0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>lluv_timer.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "lluv.h"
2 #include "lluv_handle.h"
3 #include "lluv_timer.h"
4 #include "lluv_loop.h"
5 #include "lluv_error.h"
6 #include &lt;assert.h&gt;
7 #define LLUV_TIMER_NAME LLUV_PREFIX" Timer"
8 static const char *LLUV_TIMER = LLUV_TIMER_NAME;
9 LLUV_INTERNAL int lluv_timer_index(lua_State *L){
10 <a name="3"></a>  return lluv__index(L, LLUV_TIMER, lluv_handle_index);
11 }
12 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>LLUV_IMPL_SAFE(lluv_timer_create){
13   lluv_loop_t   *loop   = lluv_opt_loop_ex(L, 1, LLUV_FLAG_OPEN);
14   lluv_handle_t *handle = lluv_handle_create(L, UV_TIMER, safe_flag | INHERITE_FLAGS(loop));
15   int err = uv_timer_init(loop-&gt;handle, LLUV_H(handle, uv_timer_t));
16   if(err &lt; 0){
17     lluv_handle_cleanup(L, handle, -1);
18     return lluv_fail(L, safe_flag | loop-&gt;flags, LLUV_ERR_UV, (uv_errno_t)err, NULL);
19   }
20   return 1;
21 }
22 static lluv_handle_t* lluv_check_timer(lua_State *L, int idx, lluv_flags_t flags){</b></font>
23   lluv_handle_t *handle = lluv_check_handle(L, idx, flags);
24   luaL_argcheck (L, LLUV_H(handle, uv_handle_t)-&gt;type == UV_TIMER, idx, LLUV_TIMER_NAME" expected");
25   return handle;
26 }
27 static void lluv_on_timer_start(uv_timer_t *arg){
28   uv_handle_t *h = (uv_handle_t*)arg;
29   if(!uv_is_active(h)){
30     lluv_handle_t *handle = lluv_handle_byptr(h);
31     lua_State *L = LLUV_HCALLBACK_L(handle);
32     lluv_handle_unlock(L, handle, LLUV_LOCK_START);
33   }
34   lluv_on_handle_start(h);
35 }
36 static int lluv_timer_start(lua_State *L){
37   lluv_handle_t *handle = lluv_check_timer(L, 1, LLUV_FLAG_OPEN);
38   uint64_t timeout, repeat;
39   int err;
40   lluv_check_args_with_cb(L, 4);
41   LLUV_START_CB(handle) = luaL_ref(L, LLUV_LUA_REGISTRY);
42   if(lua_gettop(L) &gt; 1){
43     timeout = lutil_checkint64(L, 2);
44     if(lua_gettop(L) &gt; 2)
45       repeat = lutil_checkint64(L, 3);
46     else
47       repeat = 0;
48   }
49   else{
50     timeout = 0;
51 <a name="2"></a>    repeat  = 0;
52   }
53 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  err = uv_timer_start(LLUV_H(handle, uv_timer_t), lluv_on_timer_start, timeout, repeat);
54   if(err &gt;= 0) lluv_handle_lock(L, handle, LLUV_LOCK_START);
55   return lluv_return(L, handle, LLUV_START_CB(handle), err);
56 }
57 static int lluv_timer_stop(lua_State *L){
58   lluv_handle_t *handle = lluv_check_timer(L, 1, LLUV_FLAG_OPEN);
59   int err = uv_timer_stop(LLUV_H(handle, uv_timer_t));
60   if(err &lt; 0){
61     return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
62   }</b></font>
63   lluv_handle_lock(L, handle, LLUV_LOCK_START);
64   lua_settop(L, 1);
65   return 1;
66 }
67 static int lluv_timer_again(lua_State *L){
68   lluv_handle_t *handle = lluv_check_timer(L, 1, LLUV_FLAG_OPEN);
69   int err;
70   if(lua_isnumber(L, 2)){
71 <a name="4"></a>    uint64_t repeat = lutil_optint64(L, 2, 0);
72     uv_timer_set_repeat(LLUV_H(handle, uv_timer_t), repeat);
73   }
74 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  err = uv_timer_again(LLUV_H(handle, uv_timer_t));
75   if(err &lt; 0){
76     return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
77   }
78   lluv_handle_lock(L, handle, LLUV_LOCK_START);
79   lua_settop(L, 1);
80   return 1;
81 }
82 static int lluv_timer_set_repeat(lua_State *L){
83   lluv_handle_t *handle = lluv_check_timer(L, 1, LLUV_FLAG_OPEN);
84   uint64_t repeat = lutil_optint64(L, 2, 0);</b></font>
85   uv_timer_set_repeat(LLUV_H(handle, uv_timer_t), repeat);
86   lua_settop(L, 1);
87   return 1;
88 <a name="1"></a>}
89 static int lluv_timer_get_repeat(lua_State *L){
90 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  lluv_handle_t *handle = lluv_check_timer(L, 1, LLUV_FLAG_OPEN);
91   uint64_t repeat = uv_timer_get_repeat(LLUV_H(handle, uv_timer_t));
92   lutil_pushint64(L, repeat);
93   return 1;
94 }
95 static const struct luaL_Reg lluv_timer_methods[] = {
96   { "start",      lluv_timer_start      },
97   { "stop",       lluv_timer_stop       },
98   { "again",      lluv_timer_again      },
99 <a name="0"></a>  { "set_repeat", lluv_timer_set_repeat },
100   { "get_repeat", lluv_timer_get_repeat },
101 </b></font><font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  {NULL,NULL}
102 };
103 #define LLUV_FUNCTIONS(F)           \
104   {"timer", lluv_timer_create_##F}, \
105 static const struct luaL_Reg lluv_functions[][2] = {
106   {
107     LLUV_FUNCTIONS(unsafe)
108     {NULL,NULL}
109   },
110   {
111     LLUV_FUNCTIONS(safe)
112     {NULL,NULL}
113   },
114 };
115 LLUV_INTERNAL void lluv_timer_initlib(lua_State *L, int nup, int safe){
116   lutil_pushnvalues(L, nup);
117   if(!lutil_createmetap(L, LLUV_TIMER, lluv_timer_methods, nup))
118     lua_pop(L, nup);
119   lua_pop(L, 1);
120   luaL_setfuncs(L, lluv_functions[safe], nup);
121 }</b></font>
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lluv_udp.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "lluv.h"
2 #include "lluv_handle.h"
3 #include "lluv_udp.h"
4 #include "lluv_loop.h"
5 #include "lluv_error.h"
6 #include "lluv_req.h"
7 #include "lluv_stream.h"
8 #include &lt;assert.h&gt;
9 #define LLUV_UDP_NAME LLUV_PREFIX" udp"
10 static const char *LLUV_UDP = LLUV_UDP_NAME;
11 LLUV_INTERNAL int lluv_udp_index(lua_State *L){
12   return lluv__index(L, LLUV_UDP, lluv_handle_index);
13 }
14 LLUV_IMPL_SAFE(lluv_udp_create){
15   lluv_loop_t   *loop   = lluv_opt_loop(L, 1, LLUV_FLAG_OPEN);
16   lluv_handle_t *handle;
17   int err;
18 #if LLUV_UV_VER_GE(1,7,0)
19   unsigned int flags = lluv_opt_af_flags(L, loop ? 2 : 1, AF_UNSPEC);
20 #endif
21   if(!loop) loop = lluv_default_loop(L);
22   handle = lluv_handle_create(L, UV_UDP, safe_flag | INHERITE_FLAGS(loop));
23 #if LLUV_UV_VER_GE(1,7,0)
24   err = uv_udp_init_ex(loop-&gt;handle, LLUV_H(handle, uv_udp_t), flags);
25 #else
26   err = uv_udp_init(loop-&gt;handle, LLUV_H(handle, uv_udp_t));
27 #endif
28   if(err &lt; 0){
29     lluv_handle_cleanup(L, handle, -1);
30     return lluv_fail(L, safe_flag | loop-&gt;flags, LLUV_ERR_UV, (uv_errno_t)err, NULL);
31   }
32   return 1;
33 }
34 static lluv_handle_t* lluv_check_udp(lua_State *L, int idx, lluv_flags_t flags){
35   lluv_handle_t *handle = lluv_check_handle(L, idx, flags);
36   luaL_argcheck (L, LLUV_H(handle, uv_handle_t)-&gt;type == UV_UDP, idx, LLUV_UDP_NAME" expected");
37 <a name="3"></a>  return handle;
38 }
39 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static int lluv_udp_open(lua_State *L){
40   lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
41   uv_os_sock_t sock = lluv_check_os_sock(L, 2);
42   int err = uv_udp_open(LLUV_H(handle, uv_udp_t), sock);
43   if(err &lt; 0){
44     return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
45   }
46   lua_settop(L, 1);
47   return 1;
48 }
49 static int lluv_udp_bind(lua_State *L){</b></font>
50   static const lluv_uv_const_t FLAGS[] = {
51     { UV_UDP_IPV6ONLY ,   "ipv6only"   },
52     { UV_UDP_REUSEADDR,   "reuseaddr"  },
53     { 0, NULL }
54   };
55   lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
56   struct sockaddr_storage sa; int err = lluv_check_addr(L, 2, &amp;sa);
57   unsigned int flags = 0;
58   int top = lua_gettop(L);
59   if(top &gt; 5)lua_settop(L, top = 5);
60   if((top &gt; 4) || (!lua_isfunction(L, 4))){
61     flags = lluv_opt_flags_ui(L, 4, flags, FLAGS);
62   }
63   if(err &lt; 0){
64     lua_checkstack(L, 3);
65     lua_pushvalue(L, 2); lua_pushliteral(L, ":"); lua_pushvalue(L, 3); lua_concat(L, 3);
66     if(!lua_isfunction(L, top)){
67       return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, lua_tostring(L, -1));
68     }
69     lluv_error_create(L, LLUV_ERR_UV, err, lua_tostring(L, -1));
70     lua_remove(L, -2);
71     lua_pushvalue(L, 1);
72     lua_insert(L, -2);
73     lluv_loop_defer_call(L, lluv_loop_by_handle(&amp;handle-&gt;handle), 2);
74     lua_settop(L, 1);
75     return 1;
76   }
77   err = uv_udp_bind(LLUV_H(handle, uv_udp_t), (struct sockaddr *)&amp;sa, flags);
78   if(err &lt; 0){
79     lua_checkstack(L, 3);
80     lua_pushvalue(L, 2); lua_pushliteral(L, ":"); lua_pushvalue(L, 3); lua_concat(L, 3);
81     if(!lua_isfunction(L, top)){
82       return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, lua_tostring(L, -1));
83     }
84     lluv_error_create(L, LLUV_ERR_UV, err, lua_tostring(L, -1));
85     lua_remove(L, -2);
86     lua_pushvalue(L, 1);
87     lua_insert(L, -2);
88     lluv_loop_defer_call(L, lluv_loop_by_handle(&amp;handle-&gt;handle), 2);
89     lua_settop(L, 1);
90     return 1;
91   }
92   if(lua_isfunction(L, top)){
93     lua_pushvalue(L, 1);
94     lua_pushnil(L);
95     lluv_loop_defer_call(L,
96       lluv_loop_by_handle(&amp;handle-&gt;handle),
97       lluv_push_addr(L, &amp;sa) + 2
98     );
99   }
100   lua_settop(L, 1);
101   return 1;
102 }
103 #if LLUV_UV_VER_GE(1,27,0)
104 static int lluv_udp_connect(lua_State *L){
105   lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
106   int is_disconnect = (lua_isnoneornil(L, 2) || lua_isfunction(L, 2)) ? 1 : 0;
107   struct sockaddr_storage sa; int err = is_disconnect ? 0 : lluv_check_addr(L, 2, &amp;sa);
108   struct sockaddr_storage *psa = is_disconnect ? 0 : &amp;sa;
109   int top = lua_gettop(L);
110   if(top &gt; 4) lua_settop(L, top = 4);
111   if (err &lt; 0) {
112     assert(psa);
113     lua_checkstack(L, 3);
114     lua_pushvalue(L, 2); lua_pushliteral(L, ":"); lua_pushvalue(L, 3); lua_concat(L, 3);
115     if (!lua_isfunction(L, top)) {
116       return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, lua_tostring(L, -1));
117     }
118     lluv_error_create(L, LLUV_ERR_UV, err, lua_tostring(L, -1));
119     lua_remove(L, -2);
120     lua_pushvalue(L, 1);
121     lua_insert(L, -2);
122     lluv_loop_defer_call(L, lluv_loop_by_handle(&amp;handle-&gt;handle), 2);
123     lua_settop(L, 1);
124     return 1;
125   }
126   err = uv_udp_connect(LLUV_H(handle, uv_udp_t), (struct sockaddr *)psa);
127   if (err &lt; 0) {
128     const char *ip = 0;
129     if (psa) {
130       lua_checkstack(L, 3);
131       lua_pushvalue(L, 2); lua_pushliteral(L, ":"); lua_pushvalue(L, 3); lua_concat(L, 3);
132       ip = lua_tostring(L, -1);
133     }
134     if (!lua_isfunction(L, top)) {
135       return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, ip);
136     }
137     lluv_error_create(L, LLUV_ERR_UV, err, ip);
138     if (ip) {
139       lua_remove(L, -2);
140     }
141     lua_pushvalue(L, 1);
142     lua_insert(L, -2);
143     lluv_loop_defer_call(L, lluv_loop_by_handle(&amp;handle-&gt;handle), 2);
144     lua_settop(L, 1);
145     return 1;
146   }
147   if(lua_isfunction(L, top)){
148     int n = 2;
149     lua_pushvalue(L, 1);
150     lua_pushnil(L);
151     if (psa) {
152       n += lluv_push_addr(L, psa);
153     }
154     lluv_loop_defer_call(L, lluv_loop_by_handle(&amp;handle-&gt;handle), n);
155   }
156   lua_settop(L, 1);
157   return 1;
158 }
159 static int lluv_udp_getpeername(lua_State *L) {
160   lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
161   struct sockaddr_storage sa;
162   int size = sizeof(sa);
163   int err = uv_udp_getpeername(LLUV_H(handle, uv_udp_t), (struct sockaddr *)&amp;sa, &amp;size);
164   if (err &lt; 0) {
165     return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, 0);
166   }
167   return lluv_push_addr(L, &amp;sa);
168 }
169 #endif
170 static int lluv_udp_try_send(lua_State *L){
171   lluv_handle_t *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
172   int top = lua_gettop(L);
173   int is_connected =
174 #if LLUV_UV_VER_GE(1,27,0)
175     (top == 2) ? 1 :
176 #endif
177     0;
178   struct sockaddr_storage sa; int err = is_connected ? 0 : lluv_check_addr(L, 2, &amp;sa);
179   struct sockaddr_storage *psa = is_connected ? 0 : &amp;sa;
180   int data_index = is_connected ? 2 : 4;
181   if (err &lt; 0) {
182     lua_settop(L, 3);
183     lua_pushliteral(L, ":"); lua_insert(L, -2); lua_concat(L, 3);
184     return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, lua_tostring(L, -1));
185   }
186   if (lua_istable(L, data_index)) {
187     size_t i, n = lua_rawlen(L, data_index);
188     uv_buf_t *buf;
189     luaL_argcheck(L, n &gt; 0, data_index, "Empty array not supported");
190     buf = (uv_buf_t*)lluv_alloca(sizeof(uv_buf_t) * n);
191     if (!buf) {
192       return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, ENOMEM, NULL);
193     }
194     for (i = 0; i &lt; n; ++i) {
195       size_t len; const char *str;
196       lua_rawgeti(L, data_index, i + 1);
197       str = luaL_checklstring(L, -1, &amp;len);
198       buf[i] = lluv_buf_init((char*)str, len);
199       lua_pop(L, 1);
200     }
201     err = uv_udp_try_send(LLUV_H(handle, uv_udp_t), buf, n, (struct sockaddr*)psa);
202   }
203   else {
204     size_t len; const char *str;
205     uv_buf_t buf;
206     luaL_argcheck(L, lua_isstring(L, data_index), data_index, "String or array expected");
207     str = lua_tolstring(L, data_index, &amp;len);
208     buf = lluv_buf_init((char*)str, len);
209     err = uv_udp_try_send(LLUV_H(handle, uv_udp_t), &amp;buf, 1, (struct sockaddr*)psa);
210   }
211   if(err &lt; 0){
212     return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
213   }
214   lua_pushinteger(L, err);
215   return 1;
216 }
217 static void lluv_on_udp_send_cb(uv_udp_send_t* arg, int status){
218   lluv_on_stream_req_cb((uv_req_t*)arg, status);
219 }
220 static int lluv_udp_send_(lua_State *L, lluv_handle_t *handle, struct sockaddr *sa, uv_buf_t *buf, size_t n, int data_index){
221   int err; lluv_req_t *req;
222   if(lua_gettop(L) == (data_index + 2)){
223     int ctx;
224     lluv_check_callable(L, -2);
225     ctx = luaL_ref(L, LLUV_LUA_REGISTRY);
226     req = lluv_req_new(L, UV_UDP_SEND, handle);
227     lluv_req_ref(L, req);     req-&gt;ctx = ctx;
228   }
229   else{
230     if(lua_gettop(L) == data_index)
231       lua_settop(L, data_index + 1);
232     else
233       lluv_check_args_with_cb(L, data_index + 1);
234     req = lluv_req_new(L, UV_UDP_SEND, handle);
235     lluv_req_ref(L, req);   }
236   err = uv_udp_send(LLUV_R(req, udp_send), LLUV_H(handle, uv_udp_t), buf, n, sa, lluv_on_udp_send_cb);
237   return lluv_return_req(L, handle, req, err);
238 }
239 static int lluv_udp_send_t(lua_State *L, lluv_handle_t  *handle, struct sockaddr *sa, int data_index){
240   int i;
241   size_t n = lua_rawlen(L, data_index);
242   uv_buf_t *buf;
243   assert(lua_type(L, data_index) == LUA_TTABLE);
244   luaL_argcheck(L, n &gt; 0, data_index, "Empty array not supported");
245   buf = (uv_buf_t*)lluv_alloca(sizeof(uv_buf_t) * n);
246   if(!buf){
247     return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, ENOMEM, NULL); 
248   }
249   for(i = 0; i &lt; n; ++i){
250     size_t len; const char *str;
251     lua_rawgeti(L, data_index, i + 1);
252     str = luaL_checklstring(L, -1, &amp;len);
253     buf[i] = lluv_buf_init((char*)str, len);
254     lua_pop(L, 1);
255   }
256   return lluv_udp_send_(L, handle, sa, buf, n, data_index);
257 }
258 static int lluv_udp_send(lua_State *L){
259   lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
260   int top = lua_gettop(L);
261   int is_connected =
262 #if LLUV_UV_VER_GE(1,27,0)
263     ((top == 2) || lua_isfunction(L, 3)) ? 1 :
264 #endif
265     0;
266   struct sockaddr_storage sa; int err = is_connected ? 0 : lluv_check_addr(L, 2, &amp;sa);
267   struct sockaddr_storage *psa = is_connected ? 0 : &amp;sa;
268   int data_index = is_connected ? 2 : 4;
269   if(err &lt; 0){
270     int top = lua_gettop(L);
271     if(top &gt; 4) lua_settop(L, top = 5);
272     if(lua_isfunction(L, top)){
273       lua_pushvalue(L, 2); lua_pushliteral(L, ":"); lua_pushvalue(L, 3); lua_concat(L, 3);
274       lluv_error_create(L, LLUV_ERR_UV, err, lua_tostring(L, -1));
275       lua_remove(L, -2);
276       lluv_loop_defer_call(L, lluv_loop_by_handle(&amp;handle-&gt;handle), 2);
277       lua_settop(L, 1);
278       return 1;
279     }
280     lua_settop(L, 3);
281     lua_pushliteral(L, ":");lua_insert(L, -2);lua_concat(L, 3);
282     return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, lua_tostring(L, -1));
283   }
284   if(lua_type(L, data_index) == LUA_TTABLE){
285     return lluv_udp_send_t(L, handle, (struct sockaddr*)psa, data_index);
286   }
287   else{
288     size_t len; const char *str = luaL_checklstring(L, data_index, &amp;len);
289     uv_buf_t buf = lluv_buf_init((char*)str, len);
290     return lluv_udp_send_(L, handle, (struct sockaddr*)psa, &amp;buf, 1, data_index);
291   }
292 }
293 static void lluv_on_udp_recv_cb(uv_udp_t *arg, ssize_t nread, const uv_buf_t* buf, const struct sockaddr* addr, unsigned flags){
294   lluv_handle_t *handle = lluv_handle_byptr((uv_handle_t*)arg);
295   lua_State *L = LLUV_HCALLBACK_L(handle);
296   LLUV_CHECK_LOOP_CB_INVARIANT(L);
297   if((nread == 0) &amp;&amp; (addr == NULL)){
298     lluv_free_buffer((uv_handle_t*)arg, buf);
299     return;
300   }
301   lua_rawgeti(L, LLUV_LUA_REGISTRY, LLUV_READ_CB(handle));
302   assert(!lua_isnil(L, -1));
303   lluv_handle_pushself(L, handle);
304   if(nread &gt;= 0){
305     assert(addr);
306     lua_pushnil(L);
307     lua_pushlstring(L, buf-&gt;base, nread);
308     lluv_free_buffer((uv_handle_t*)arg, buf);
309   }
310   else{
311     lluv_free_buffer((uv_handle_t*)arg, buf);
312     uv_udp_recv_stop(arg);
313     luaL_unref(L, LLUV_LUA_REGISTRY, LLUV_READ_CB(handle));
314     LLUV_READ_CB(handle) = LUA_NOREF;
315     lluv_error_create(L, LLUV_ERR_UV, (uv_errno_t)nread, NULL);
316     lua_pushnil(L);
317     lluv_handle_unlock(L, handle, LLUV_LOCK_READ);
318   }
319   lua_pushinteger(L, flags);
320   LLUV_HANDLE_CALL_CB(L, handle, 4 + lluv_push_addr(L, (const struct sockaddr_storage*)addr));
321   LLUV_CHECK_LOOP_CB_INVARIANT(L);
322 }
323 static int lluv_udp_start_recv(lua_State *L){
324   lluv_handle_t *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
325   int err;
326 <a name="2"></a>  lluv_check_args_with_cb(L, 2);
327   LLUV_READ_CB(handle) = luaL_ref(L, LLUV_LUA_REGISTRY);
328 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  err = uv_udp_recv_start(LLUV_H(handle, uv_udp_t), lluv_alloc_buffer_cb, lluv_on_udp_recv_cb);
329   if(err &gt;= 0) lluv_handle_lock(L, handle, LLUV_LOCK_READ);
330   return lluv_return(L, handle, LLUV_READ_CB(handle), err);
331 }
332 static int lluv_udp_stop_recv(lua_State *L){
333   lluv_handle_t *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
334   int err;
335   lluv_check_none(L, 2);
336   err = uv_udp_recv_stop(LLUV_H(handle, uv_udp_t));
337   if(err &lt; 0){
338     return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
339   }</b></font>
340   if(LLUV_READ_CB(handle) != LUA_NOREF){
341     luaL_unref(L, LLUV_LUA_REGISTRY, LLUV_READ_CB(handle));
342     LLUV_READ_CB(handle) = LUA_NOREF;
343     lluv_handle_unlock(L, handle, LLUV_LOCK_READ);
344   }
345   lua_settop(L, 1);
346   return 1;
347 }
348 static int lluv_udp_getsockname(lua_State *L){
349   lluv_handle_t *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
350   struct sockaddr_storage sa; int sa_len = sizeof(sa);
351   int err = uv_udp_getsockname(LLUV_H(handle, uv_udp_t), (struct sockaddr*)&amp;sa, &amp;sa_len);
352   lua_settop(L, 1);
353   if(err &lt; 0){
354     return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
355   }
356   return lluv_push_addr(L, &amp;sa);
357 }
358 static int lluv_udp_set_membership(lua_State *L){
359   static const lluv_uv_const_t FLAGS[] = {
360     { UV_LEAVE_GROUP,   "leave" },
361     { UV_JOIN_GROUP,    "join"  },
362     { 0, NULL }
363   };
364   lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
365   const char *multicast_addr = luaL_checkstring(L, 2);
366   const char *interface_addr = lua_isnoneornil(L,3)?NULL:luaL_checkstring(L, 3);
367   uv_membership membership   = (uv_membership)lluv_opt_named_const(L, 4, UV_JOIN_GROUP, FLAGS);
368   int err = uv_udp_set_membership(LLUV_H(handle, uv_udp_t), multicast_addr, interface_addr, membership);
369   if(err &lt; 0){
370     return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
371   }
372   lua_settop(L, 1);
373   return 1;
374 }
375 static int lluv_udp_set_multicast_loop(lua_State *L){
376   lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
377   int enable = lua_toboolean(L, 2);
378   int err = uv_udp_set_multicast_loop(LLUV_H(handle, uv_udp_t), enable);
379   if(err &lt; 0){
380     return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
381   }
382   lua_settop(L, 1);
383   return 1;
384 }
385 static int lluv_udp_set_multicast_ttl(lua_State *L){
386   lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
387   int ttl = luaL_checkint(L, 2);
388   int err = uv_udp_set_multicast_ttl(LLUV_H(handle, uv_udp_t), ttl);
389   if(err &lt; 0){
390     return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
391   }
392   lua_settop(L, 1);
393   return 1;
394 }
395 static int lluv_udp_set_multicast_interface(lua_State *L){
396   lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
397   const char *interface_addr = luaL_checkstring(L, 2);
398   int err = uv_udp_set_multicast_interface(LLUV_H(handle, uv_udp_t), interface_addr);
399   if(err &lt; 0){
400     return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
401   }
402   lua_settop(L, 1);
403   return 1;
404 }
405 static int lluv_udp_set_broadcast(lua_State *L){
406   lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
407   int enable = lua_toboolean(L, 2);
408   int err = uv_udp_set_broadcast(LLUV_H(handle, uv_udp_t), enable);
409   if(err &lt; 0){
410     return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
411   }
412   lua_settop(L, 1);
413   return 1;
414 }
415 static int lluv_udp_set_ttl(lua_State *L){
416 <a name="4"></a>  lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
417   int ttl = luaL_checkint(L, 2);
418 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  int err = uv_udp_set_ttl(LLUV_H(handle, uv_udp_t), ttl);
419   if(err &lt; 0){
420     return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
421   }
422   lua_settop(L, 1);
423   return 1;
424 }
425 static int lluv_udp_get_send_queue_size(lua_State *L){
426   lluv_handle_t *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
427   size_t queue_size;
428 #if LLUV_UV_VER_GE(1,19,0)
429   queue_size = uv_udp_get_send_queue_size(LLUV_H(handle, uv_udp_t));</b></font>
430 #else
431   queue_size = LLUV_H(handle, uv_udp_t)-&gt;send_queue_size;
432 #endif
433   lutil_pushint64(L, queue_size);
434   return 1;
435 }
436 static int lluv_udp_get_send_queue_count(lua_State *L){
437   lluv_handle_t *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
438 <a name="1"></a>  size_t queue_count;
439 #if LLUV_UV_VER_GE(1,19,0)
440 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  queue_count = uv_udp_get_send_queue_count(LLUV_H(handle, uv_udp_t));
441 #else
442   queue_count = LLUV_H(handle, uv_udp_t)-&gt;send_queue_count;
443 #endif
444   lutil_pushint64(L, queue_count);
445   return 1;
446 }
447 static const struct luaL_Reg lluv_udp_methods[] = {
448   { "open",                     lluv_udp_open                    },
449   { "bind",                     lluv_udp_bind                    },
450   { "try_send",                 lluv_udp_try_send                },
451   { "send",                     lluv_udp_send                    },
452   { "getsockname",              lluv_udp_getsockname             },
453   { "start_recv",               lluv_udp_start_recv              },</b></font>
454   { "stop_recv",                lluv_udp_stop_recv               },
455   { "set_membership",           lluv_udp_set_membership          },
456   { "set_multicast_loop",       lluv_udp_set_multicast_loop      },
457   { "set_multicast_ttl",        lluv_udp_set_multicast_ttl       },
458   { "set_multicast_interface",  lluv_udp_set_multicast_interface },
459   { "set_broadcast",            lluv_udp_set_broadcast           },
460   { "set_ttl",                  lluv_udp_set_ttl                 },
461   { "get_send_queue_size",      lluv_udp_get_send_queue_size     },
462   { "get_send_queue_count",     lluv_udp_get_send_queue_count    },
463 #if LLUV_UV_VER_GE(1,27,0)
464   { "connect",                  lluv_udp_connect                 },
465   { "getpeername",              lluv_udp_getpeername             },
466 #endif
467   {NULL,NULL}
468 };
469 static const lluv_uv_const_t lluv_udp_constants[] = {
470   { UV_UDP_IPV6ONLY,   "UDP_IPV6ONLY"   },
471   { UV_UDP_PARTIAL,    "UDP_PARTIAL"    },
472   { UV_UDP_REUSEADDR,  "UDP_REUSEADDR"  },
473 <a name="0"></a>  { UV_LEAVE_GROUP ,   "LEAVE_GROUP"    },
474   { UV_JOIN_GROUP,     "JOIN_GROUP"     },
475 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  { 0, NULL }
476 };
477 #define LLUV_FUNCTIONS(F)       \
478   {"udp", lluv_udp_create_##F}, \
479 static const struct luaL_Reg lluv_functions[][2] = {
480   {
481     LLUV_FUNCTIONS(unsafe)
482     {NULL,NULL}
483   },
484   {
485     LLUV_FUNCTIONS(safe)
486     {NULL,NULL}
487   },
488 };
489 LLUV_INTERNAL void lluv_udp_initlib(lua_State *L, int nup, int safe){
490   lutil_pushnvalues(L, nup);
491   if(!lutil_createmetap(L, LLUV_UDP, lluv_udp_methods, nup))
492     lua_pop(L, nup);
493   lua_pop(L, 1);
494   luaL_setfuncs(L, lluv_functions[safe], nup);
495   lluv_register_constants(L, lluv_udp_constants);
496 }</b></font>
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
