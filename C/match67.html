<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for lluv_timer.c &amp; lluv_udp.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for lluv_timer.c &amp; lluv_udp.c
      </h3>
<h1 align="center">
        23.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>lluv_timer.c (61.22449%)<th>lluv_udp.c (14.53958%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(133-160)<td><a href="#" name="0">(639-666)</a><td align="center"><font color="#ff0000">27</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(120-133)<td><a href="#" name="1">(599-614)</a><td align="center"><font color="#bc0000">20</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(73-85)<td><a href="#" name="2">(451-467)</a><td align="center"><font color="#8d0000">15</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(25-36)<td><a href="#" name="3">(60-72)</a><td align="center"><font color="#8d0000">15</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(100-113)<td><a href="#" name="4">(571-585)</a><td align="center"><font color="#7a0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>lluv_timer.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/******************************************************************************
* Author: Alexey Melnichuk &lt;alexeymelnichuck@gmail.com&gt;
*
* Copyright (C) 2014-2016 Alexey Melnichuk &lt;alexeymelnichuck@gmail.com&gt;
*
* Licensed according to the included 'LICENSE' document
*
* This file is part of lua-lluv library.
******************************************************************************/

#include "lluv.h"
#include "lluv_handle.h"
#include "lluv_timer.h"
#include "lluv_loop.h"
#include "lluv_error.h"
#include &lt;assert.h&gt;

#define LLUV_TIMER_NAME LLUV_PREFIX" Timer"
static const char *LLUV_TIMER = LLUV_TIMER_NAME;

LLUV_INTERNAL int lluv_timer_index(lua_State *L){
<a name="3"></a>  return lluv__index(L, LLUV_TIMER, lluv_handle_index);
}

<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>LLUV_IMPL_SAFE(lluv_timer_create){
  lluv_loop_t   *loop   = lluv_opt_loop_ex(L, 1, LLUV_FLAG_OPEN);
  lluv_handle_t *handle = lluv_handle_create(L, UV_TIMER, safe_flag | INHERITE_FLAGS(loop));
  int err = uv_timer_init(loop-&gt;handle, LLUV_H(handle, uv_timer_t));
  if(err &lt; 0){
    lluv_handle_cleanup(L, handle, -1);
    return lluv_fail(L, safe_flag | loop-&gt;flags, LLUV_ERR_UV, (uv_errno_t)err, NULL);
  }
  return 1;
}

static lluv_handle_t* lluv_check_timer(lua_State *L, int idx, lluv_flags_t flags){</b></font>
  lluv_handle_t *handle = lluv_check_handle(L, idx, flags);
  luaL_argcheck (L, LLUV_H(handle, uv_handle_t)-&gt;type == UV_TIMER, idx, LLUV_TIMER_NAME" expected");

  return handle;
}

static void lluv_on_timer_start(uv_timer_t *arg){
  uv_handle_t *h = (uv_handle_t*)arg;
  if(!uv_is_active(h)){
    lluv_handle_t *handle = lluv_handle_byptr(h);
    lua_State *L = LLUV_HCALLBACK_L(handle);
    lluv_handle_unlock(L, handle, LLUV_LOCK_START);
  }
  lluv_on_handle_start(h);
}

static int lluv_timer_start(lua_State *L){
  lluv_handle_t *handle = lluv_check_timer(L, 1, LLUV_FLAG_OPEN);
  uint64_t timeout, repeat;
  int err;

  lluv_check_args_with_cb(L, 4);
  LLUV_START_CB(handle) = luaL_ref(L, LLUV_LUA_REGISTRY);

  if(lua_gettop(L) &gt; 1){
    timeout = lutil_checkint64(L, 2);
    if(lua_gettop(L) &gt; 2)
      repeat = lutil_checkint64(L, 3);
    else
      repeat = 0;
  }
  else{
    timeout = 0;
<a name="2"></a>    repeat  = 0;
  }

<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  err = uv_timer_start(LLUV_H(handle, uv_timer_t), lluv_on_timer_start, timeout, repeat);

  if(err &gt;= 0) lluv_handle_lock(L, handle, LLUV_LOCK_START);

  return lluv_return(L, handle, LLUV_START_CB(handle), err);
}

static int lluv_timer_stop(lua_State *L){
  lluv_handle_t *handle = lluv_check_timer(L, 1, LLUV_FLAG_OPEN);
  int err = uv_timer_stop(LLUV_H(handle, uv_timer_t));
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }</b></font>

  lluv_handle_lock(L, handle, LLUV_LOCK_START);

  lua_settop(L, 1);
  return 1;
}

static int lluv_timer_again(lua_State *L){
  lluv_handle_t *handle = lluv_check_timer(L, 1, LLUV_FLAG_OPEN);
  int err;
  if(lua_isnumber(L, 2)){
<a name="4"></a>    uint64_t repeat = lutil_optint64(L, 2, 0);
    uv_timer_set_repeat(LLUV_H(handle, uv_timer_t), repeat);
  }
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  err = uv_timer_again(LLUV_H(handle, uv_timer_t));
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }

  lluv_handle_lock(L, handle, LLUV_LOCK_START);

  lua_settop(L, 1);
  return 1;
}

static int lluv_timer_set_repeat(lua_State *L){
  lluv_handle_t *handle = lluv_check_timer(L, 1, LLUV_FLAG_OPEN);
  uint64_t repeat = lutil_optint64(L, 2, 0);</b></font>
  uv_timer_set_repeat(LLUV_H(handle, uv_timer_t), repeat);
  lua_settop(L, 1);
  return 1;
<a name="1"></a>}

static int lluv_timer_get_repeat(lua_State *L){
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  lluv_handle_t *handle = lluv_check_timer(L, 1, LLUV_FLAG_OPEN);
  uint64_t repeat = uv_timer_get_repeat(LLUV_H(handle, uv_timer_t));
  lutil_pushint64(L, repeat);
  return 1;
}

static const struct luaL_Reg lluv_timer_methods[] = {
  { "start",      lluv_timer_start      },
  { "stop",       lluv_timer_stop       },
  { "again",      lluv_timer_again      },
<a name="0"></a>  { "set_repeat", lluv_timer_set_repeat },
  { "get_repeat", lluv_timer_get_repeat },

</b></font><font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  {NULL,NULL}
};

#define LLUV_FUNCTIONS(F)           \
  {"timer", lluv_timer_create_##F}, \

static const struct luaL_Reg lluv_functions[][2] = {
  {
    LLUV_FUNCTIONS(unsafe)

    {NULL,NULL}
  },
  {
    LLUV_FUNCTIONS(safe)

    {NULL,NULL}
  },
};


LLUV_INTERNAL void lluv_timer_initlib(lua_State *L, int nup, int safe){
  lutil_pushnvalues(L, nup);
  if(!lutil_createmetap(L, LLUV_TIMER, lluv_timer_methods, nup))
    lua_pop(L, nup);
  lua_pop(L, 1);

  luaL_setfuncs(L, lluv_functions[safe], nup);
}</b></font>
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lluv_udp.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/******************************************************************************
* Author: Alexey Melnichuk &lt;alexeymelnichuck@gmail.com&gt;
*
* Copyright (C) 2014-2019 Alexey Melnichuk &lt;alexeymelnichuck@gmail.com&gt;
*
* Licensed according to the included 'LICENSE' document
*
* This file is part of lua-lluv library.
******************************************************************************/

#include "lluv.h"
#include "lluv_handle.h"
#include "lluv_udp.h"
#include "lluv_loop.h"
#include "lluv_error.h"
#include "lluv_req.h"
#include "lluv_stream.h"
#include &lt;assert.h&gt;

#define LLUV_UDP_NAME LLUV_PREFIX" udp"
static const char *LLUV_UDP = LLUV_UDP_NAME;

LLUV_INTERNAL int lluv_udp_index(lua_State *L){
  return lluv__index(L, LLUV_UDP, lluv_handle_index);
}

LLUV_IMPL_SAFE(lluv_udp_create){
  lluv_loop_t   *loop   = lluv_opt_loop(L, 1, LLUV_FLAG_OPEN);
  lluv_handle_t *handle;
  int err;

#if LLUV_UV_VER_GE(1,7,0)
  unsigned int flags = lluv_opt_af_flags(L, loop ? 2 : 1, AF_UNSPEC);
#endif

  if(!loop) loop = lluv_default_loop(L);

  handle = lluv_handle_create(L, UV_UDP, safe_flag | INHERITE_FLAGS(loop));

#if LLUV_UV_VER_GE(1,7,0)
  err = uv_udp_init_ex(loop-&gt;handle, LLUV_H(handle, uv_udp_t), flags);
#else
  err = uv_udp_init(loop-&gt;handle, LLUV_H(handle, uv_udp_t));
#endif

  if(err &lt; 0){
    lluv_handle_cleanup(L, handle, -1);
    return lluv_fail(L, safe_flag | loop-&gt;flags, LLUV_ERR_UV, (uv_errno_t)err, NULL);
  }
  return 1;
}

static lluv_handle_t* lluv_check_udp(lua_State *L, int idx, lluv_flags_t flags){
  lluv_handle_t *handle = lluv_check_handle(L, idx, flags);
  luaL_argcheck (L, LLUV_H(handle, uv_handle_t)-&gt;type == UV_UDP, idx, LLUV_UDP_NAME" expected");

<a name="3"></a>  return handle;
}

<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static int lluv_udp_open(lua_State *L){
  lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  uv_os_sock_t sock = lluv_check_os_sock(L, 2);
  int err = uv_udp_open(LLUV_H(handle, uv_udp_t), sock);
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }

  lua_settop(L, 1);
  return 1;
}

static int lluv_udp_bind(lua_State *L){</b></font>
  static const lluv_uv_const_t FLAGS[] = {
    { UV_UDP_IPV6ONLY ,   "ipv6only"   },
    { UV_UDP_REUSEADDR,   "reuseaddr"  },

    { 0, NULL }
  };

  lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  struct sockaddr_storage sa; int err = lluv_check_addr(L, 2, &amp;sa);
  unsigned int flags = 0;
  int top = lua_gettop(L);
  if(top &gt; 5)lua_settop(L, top = 5);

  if((top &gt; 4) || (!lua_isfunction(L, 4))){
    flags = lluv_opt_flags_ui(L, 4, flags, FLAGS);
  }

  if(err &lt; 0){
    lua_checkstack(L, 3);

    lua_pushvalue(L, 2); lua_pushliteral(L, ":"); lua_pushvalue(L, 3); lua_concat(L, 3);

    if(!lua_isfunction(L, top)){
      return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, lua_tostring(L, -1));
    }

    lluv_error_create(L, LLUV_ERR_UV, err, lua_tostring(L, -1));
    lua_remove(L, -2);
    lua_pushvalue(L, 1);
    lua_insert(L, -2);
    lluv_loop_defer_call(L, lluv_loop_by_handle(&amp;handle-&gt;handle), 2);
    lua_settop(L, 1);
    return 1;
  }

  err = uv_udp_bind(LLUV_H(handle, uv_udp_t), (struct sockaddr *)&amp;sa, flags);
  if(err &lt; 0){
    lua_checkstack(L, 3);

    lua_pushvalue(L, 2); lua_pushliteral(L, ":"); lua_pushvalue(L, 3); lua_concat(L, 3);

    if(!lua_isfunction(L, top)){
      return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, lua_tostring(L, -1));
    }

    lluv_error_create(L, LLUV_ERR_UV, err, lua_tostring(L, -1));
    lua_remove(L, -2);
    lua_pushvalue(L, 1);
    lua_insert(L, -2);
    lluv_loop_defer_call(L, lluv_loop_by_handle(&amp;handle-&gt;handle), 2);
    lua_settop(L, 1);
    return 1;
  }

  if(lua_isfunction(L, top)){
    lua_pushvalue(L, 1);
    lua_pushnil(L);
    lluv_loop_defer_call(L,
      lluv_loop_by_handle(&amp;handle-&gt;handle),
      lluv_push_addr(L, &amp;sa) + 2
    );
  }

  lua_settop(L, 1);
  return 1;
}

#if LLUV_UV_VER_GE(1,27,0)

static int lluv_udp_connect(lua_State *L){
  lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  int is_disconnect = (lua_isnoneornil(L, 2) || lua_isfunction(L, 2)) ? 1 : 0;
  struct sockaddr_storage sa; int err = is_disconnect ? 0 : lluv_check_addr(L, 2, &amp;sa);
  struct sockaddr_storage *psa = is_disconnect ? 0 : &amp;sa;
  int top = lua_gettop(L);

  if(top &gt; 4) lua_settop(L, top = 4);

  if (err &lt; 0) {
    assert(psa);

    lua_checkstack(L, 3);

    lua_pushvalue(L, 2); lua_pushliteral(L, ":"); lua_pushvalue(L, 3); lua_concat(L, 3);

    if (!lua_isfunction(L, top)) {
      return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, lua_tostring(L, -1));
    }

    lluv_error_create(L, LLUV_ERR_UV, err, lua_tostring(L, -1));
    lua_remove(L, -2);
    lua_pushvalue(L, 1);
    lua_insert(L, -2);
    lluv_loop_defer_call(L, lluv_loop_by_handle(&amp;handle-&gt;handle), 2);
    lua_settop(L, 1);
    return 1;
  }

  err = uv_udp_connect(LLUV_H(handle, uv_udp_t), (struct sockaddr *)psa);

  if (err &lt; 0) {
    const char *ip = 0;
    if (psa) {
      lua_checkstack(L, 3);
      lua_pushvalue(L, 2); lua_pushliteral(L, ":"); lua_pushvalue(L, 3); lua_concat(L, 3);
      ip = lua_tostring(L, -1);
    }

    if (!lua_isfunction(L, top)) {
      return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, ip);
    }

    lluv_error_create(L, LLUV_ERR_UV, err, ip);
    if (ip) {
      lua_remove(L, -2);
    }
    lua_pushvalue(L, 1);
    lua_insert(L, -2);
    lluv_loop_defer_call(L, lluv_loop_by_handle(&amp;handle-&gt;handle), 2);
    lua_settop(L, 1);
    return 1;
  }

  if(lua_isfunction(L, top)){
    int n = 2;
    lua_pushvalue(L, 1);
    lua_pushnil(L);
    if (psa) {
      n += lluv_push_addr(L, psa);
    }
    lluv_loop_defer_call(L, lluv_loop_by_handle(&amp;handle-&gt;handle), n);
  }

  lua_settop(L, 1);
  return 1;
}

static int lluv_udp_getpeername(lua_State *L) {
  lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  struct sockaddr_storage sa;
  int size = sizeof(sa);

  int err = uv_udp_getpeername(LLUV_H(handle, uv_udp_t), (struct sockaddr *)&amp;sa, &amp;size);

  if (err &lt; 0) {
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, 0);
  }

  return lluv_push_addr(L, &amp;sa);
}

#endif

//{ Send

static int lluv_udp_try_send(lua_State *L){
  lluv_handle_t *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  int top = lua_gettop(L);
  int is_connected =
#if LLUV_UV_VER_GE(1,27,0)
    (top == 2) ? 1 :
#endif
    0;
  struct sockaddr_storage sa; int err = is_connected ? 0 : lluv_check_addr(L, 2, &amp;sa);
  struct sockaddr_storage *psa = is_connected ? 0 : &amp;sa;
  int data_index = is_connected ? 2 : 4;

  if (err &lt; 0) {
    lua_settop(L, 3);
    lua_pushliteral(L, ":"); lua_insert(L, -2); lua_concat(L, 3);
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, lua_tostring(L, -1));
  }

  if (lua_istable(L, data_index)) {
    size_t i, n = lua_rawlen(L, data_index);
    uv_buf_t *buf;

    luaL_argcheck(L, n &gt; 0, data_index, "Empty array not supported");

    buf = (uv_buf_t*)lluv_alloca(sizeof(uv_buf_t) * n);
    if (!buf) {
      return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, ENOMEM, NULL);
    }

    for (i = 0; i &lt; n; ++i) {
      size_t len; const char *str;
      lua_rawgeti(L, data_index, i + 1);
      str = luaL_checklstring(L, -1, &amp;len);
      buf[i] = lluv_buf_init((char*)str, len);
      lua_pop(L, 1);
    }
    err = uv_udp_try_send(LLUV_H(handle, uv_udp_t), buf, n, (struct sockaddr*)psa);
  }
  else {
    size_t len; const char *str;
    uv_buf_t buf;

    luaL_argcheck(L, lua_isstring(L, data_index), data_index, "String or array expected");
    str = lua_tolstring(L, data_index, &amp;len);
    buf = lluv_buf_init((char*)str, len);
    err = uv_udp_try_send(LLUV_H(handle, uv_udp_t), &amp;buf, 1, (struct sockaddr*)psa);
  }

  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }

  lua_pushinteger(L, err);
  return 1;
}

static void lluv_on_udp_send_cb(uv_udp_send_t* arg, int status){
  lluv_on_stream_req_cb((uv_req_t*)arg, status);
}

static int lluv_udp_send_(lua_State *L, lluv_handle_t *handle, struct sockaddr *sa, uv_buf_t *buf, size_t n, int data_index){
  int err; lluv_req_t *req;

  if(lua_gettop(L) == (data_index + 2)){
    int ctx;
    lluv_check_callable(L, -2);
    ctx = luaL_ref(L, LLUV_LUA_REGISTRY);
    req = lluv_req_new(L, UV_UDP_SEND, handle);
    lluv_req_ref(L, req); /* string/table */
    req-&gt;ctx = ctx;
  }
  else{
    if(lua_gettop(L) == data_index)
      lua_settop(L, data_index + 1);
    else
      lluv_check_args_with_cb(L, data_index + 1);

    req = lluv_req_new(L, UV_UDP_SEND, handle);
    lluv_req_ref(L, req); /* string/table */
  }

  err = uv_udp_send(LLUV_R(req, udp_send), LLUV_H(handle, uv_udp_t), buf, n, sa, lluv_on_udp_send_cb);

  return lluv_return_req(L, handle, req, err);
}

static int lluv_udp_send_t(lua_State *L, lluv_handle_t  *handle, struct sockaddr *sa, int data_index){
  int i;
  size_t n = lua_rawlen(L, data_index);
  uv_buf_t *buf;

  assert(lua_type(L, data_index) == LUA_TTABLE);

  luaL_argcheck(L, n &gt; 0, data_index, "Empty array not supported");

  buf = (uv_buf_t*)lluv_alloca(sizeof(uv_buf_t) * n);
  if(!buf){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, ENOMEM, NULL); 
  }

  for(i = 0; i &lt; n; ++i){
    size_t len; const char *str;
    lua_rawgeti(L, data_index, i + 1);
    str = luaL_checklstring(L, -1, &amp;len);
    buf[i] = lluv_buf_init((char*)str, len);
    lua_pop(L, 1);
  }

  return lluv_udp_send_(L, handle, sa, buf, n, data_index);
}

// connected
//   send(data)
//   send(data, cb)
//   send(data, cb, ctx)
// disconnected
//   send(addr, port, data)
//   send(addr, port, data, cb)
//   send(addr, port, data, cb, ctx)
static int lluv_udp_send(lua_State *L){
  lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  int top = lua_gettop(L);
  int is_connected =
#if LLUV_UV_VER_GE(1,27,0)
    ((top == 2) || lua_isfunction(L, 3)) ? 1 :
#endif
    0;
  struct sockaddr_storage sa; int err = is_connected ? 0 : lluv_check_addr(L, 2, &amp;sa);
  struct sockaddr_storage *psa = is_connected ? 0 : &amp;sa;
  int data_index = is_connected ? 2 : 4;

  if(err &lt; 0){
    int top = lua_gettop(L);
    if(top &gt; 4) lua_settop(L, top = 5);

    if(lua_isfunction(L, top)){
      lua_pushvalue(L, 1); /*self*/
      /*host:port*/
      lua_pushvalue(L, 2); lua_pushliteral(L, ":"); lua_pushvalue(L, 3); lua_concat(L, 3);
      lluv_error_create(L, LLUV_ERR_UV, err, lua_tostring(L, -1));
      lua_remove(L, -2);
      lluv_loop_defer_call(L, lluv_loop_by_handle(&amp;handle-&gt;handle), 2);
      lua_settop(L, 1);
      return 1;
    }
  
    lua_settop(L, 3);
    lua_pushliteral(L, ":");lua_insert(L, -2);lua_concat(L, 3);
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, lua_tostring(L, -1));
  }

  if(lua_type(L, data_index) == LUA_TTABLE){
    return lluv_udp_send_t(L, handle, (struct sockaddr*)psa, data_index);
  }
  else{
    size_t len; const char *str = luaL_checklstring(L, data_index, &amp;len);
    uv_buf_t buf = lluv_buf_init((char*)str, len);
    return lluv_udp_send_(L, handle, (struct sockaddr*)psa, &amp;buf, 1, data_index);
  }
}

//}

//{ Recv

static void lluv_on_udp_recv_cb(uv_udp_t *arg, ssize_t nread, const uv_buf_t* buf, const struct sockaddr* addr, unsigned flags){
  lluv_handle_t *handle = lluv_handle_byptr((uv_handle_t*)arg);
  lua_State *L = LLUV_HCALLBACK_L(handle);

  LLUV_CHECK_LOOP_CB_INVARIANT(L);

  if((nread == 0) &amp;&amp; (addr == NULL)){
    /*
    ** The receive callback will be called with 
    ** nread == 0 and addr == NULL when there is 
    ** nothing to read
    */
    lluv_free_buffer((uv_handle_t*)arg, buf);
    return;
  }

  lua_rawgeti(L, LLUV_LUA_REGISTRY, LLUV_READ_CB(handle));
  assert(!lua_isnil(L, -1));

  lluv_handle_pushself(L, handle);

  if(nread &gt;= 0){
    assert(addr);
    lua_pushnil(L);
    lua_pushlstring(L, buf-&gt;base, nread);
    lluv_free_buffer((uv_handle_t*)arg, buf);
  }
  else{
    lluv_free_buffer((uv_handle_t*)arg, buf);

    /* The callee is responsible for stopping closing the stream 
     *  when an error happens by calling uv_read_stop() or uv_close().
     *  Trying to read from the stream again is undefined.
     */
    uv_udp_recv_stop(arg);

    luaL_unref(L, LLUV_LUA_REGISTRY, LLUV_READ_CB(handle));
    LLUV_READ_CB(handle) = LUA_NOREF;

    lluv_error_create(L, LLUV_ERR_UV, (uv_errno_t)nread, NULL);
    lua_pushnil(L);

    lluv_handle_unlock(L, handle, LLUV_LOCK_READ);
  }
  lua_pushinteger(L, flags);

  LLUV_HANDLE_CALL_CB(L, handle, 4 + lluv_push_addr(L, (const struct sockaddr_storage*)addr));

  LLUV_CHECK_LOOP_CB_INVARIANT(L);
}

static int lluv_udp_start_recv(lua_State *L){
  lluv_handle_t *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  int err;

<a name="2"></a>  lluv_check_args_with_cb(L, 2);
  LLUV_READ_CB(handle) = luaL_ref(L, LLUV_LUA_REGISTRY);

<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  err = uv_udp_recv_start(LLUV_H(handle, uv_udp_t), lluv_alloc_buffer_cb, lluv_on_udp_recv_cb);

  if(err &gt;= 0) lluv_handle_lock(L, handle, LLUV_LOCK_READ);

  return lluv_return(L, handle, LLUV_READ_CB(handle), err);
}

static int lluv_udp_stop_recv(lua_State *L){
  lluv_handle_t *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  int err;

  lluv_check_none(L, 2);

  err = uv_udp_recv_stop(LLUV_H(handle, uv_udp_t));
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }</b></font>

  if(LLUV_READ_CB(handle) != LUA_NOREF){
    luaL_unref(L, LLUV_LUA_REGISTRY, LLUV_READ_CB(handle));
    LLUV_READ_CB(handle) = LUA_NOREF;
    lluv_handle_unlock(L, handle, LLUV_LOCK_READ);
  }

  lua_settop(L, 1);
  return 1;
}

//}

static int lluv_udp_getsockname(lua_State *L){
  lluv_handle_t *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  struct sockaddr_storage sa; int sa_len = sizeof(sa);
  int err = uv_udp_getsockname(LLUV_H(handle, uv_udp_t), (struct sockaddr*)&amp;sa, &amp;sa_len);

  lua_settop(L, 1);
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }
  return lluv_push_addr(L, &amp;sa);
}

static int lluv_udp_set_membership(lua_State *L){
  static const lluv_uv_const_t FLAGS[] = {
    { UV_LEAVE_GROUP,   "leave" },
    { UV_JOIN_GROUP,    "join"  },

    { 0, NULL }
  };

  lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  const char *multicast_addr = luaL_checkstring(L, 2);
  const char *interface_addr = lua_isnoneornil(L,3)?NULL:luaL_checkstring(L, 3);
  uv_membership membership   = (uv_membership)lluv_opt_named_const(L, 4, UV_JOIN_GROUP, FLAGS);

  int err = uv_udp_set_membership(LLUV_H(handle, uv_udp_t), multicast_addr, interface_addr, membership);
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }

  lua_settop(L, 1);
  return 1;
}

static int lluv_udp_set_multicast_loop(lua_State *L){
  lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  int enable = lua_toboolean(L, 2);

  int err = uv_udp_set_multicast_loop(LLUV_H(handle, uv_udp_t), enable);
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }

  lua_settop(L, 1);
  return 1;
}

static int lluv_udp_set_multicast_ttl(lua_State *L){
  lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  int ttl = luaL_checkint(L, 2);

  int err = uv_udp_set_multicast_ttl(LLUV_H(handle, uv_udp_t), ttl);
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }

  lua_settop(L, 1);
  return 1;
}

static int lluv_udp_set_multicast_interface(lua_State *L){
  lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  const char *interface_addr = luaL_checkstring(L, 2);

  int err = uv_udp_set_multicast_interface(LLUV_H(handle, uv_udp_t), interface_addr);
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }

  lua_settop(L, 1);
  return 1;
}

static int lluv_udp_set_broadcast(lua_State *L){
  lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  int enable = lua_toboolean(L, 2);

  int err = uv_udp_set_broadcast(LLUV_H(handle, uv_udp_t), enable);
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }

  lua_settop(L, 1);
  return 1;
}

static int lluv_udp_set_ttl(lua_State *L){
<a name="4"></a>  lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  int ttl = luaL_checkint(L, 2);

<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  int err = uv_udp_set_ttl(LLUV_H(handle, uv_udp_t), ttl);
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }

  lua_settop(L, 1);
  return 1;
}

static int lluv_udp_get_send_queue_size(lua_State *L){
  lluv_handle_t *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  size_t queue_size;

#if LLUV_UV_VER_GE(1,19,0)
  queue_size = uv_udp_get_send_queue_size(LLUV_H(handle, uv_udp_t));</b></font>
#else
  queue_size = LLUV_H(handle, uv_udp_t)-&gt;send_queue_size;
#endif

  lutil_pushint64(L, queue_size);
  return 1;
}

static int lluv_udp_get_send_queue_count(lua_State *L){
  lluv_handle_t *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
<a name="1"></a>  size_t queue_count;

#if LLUV_UV_VER_GE(1,19,0)
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  queue_count = uv_udp_get_send_queue_count(LLUV_H(handle, uv_udp_t));
#else
  queue_count = LLUV_H(handle, uv_udp_t)-&gt;send_queue_count;
#endif

  lutil_pushint64(L, queue_count);
  return 1;
}

static const struct luaL_Reg lluv_udp_methods[] = {
  { "open",                     lluv_udp_open                    },
  { "bind",                     lluv_udp_bind                    },
  { "try_send",                 lluv_udp_try_send                },
  { "send",                     lluv_udp_send                    },
  { "getsockname",              lluv_udp_getsockname             },
  { "start_recv",               lluv_udp_start_recv              },</b></font>
  { "stop_recv",                lluv_udp_stop_recv               },
  { "set_membership",           lluv_udp_set_membership          },
  { "set_multicast_loop",       lluv_udp_set_multicast_loop      },
  { "set_multicast_ttl",        lluv_udp_set_multicast_ttl       },
  { "set_multicast_interface",  lluv_udp_set_multicast_interface },
  { "set_broadcast",            lluv_udp_set_broadcast           },
  { "set_ttl",                  lluv_udp_set_ttl                 },
  { "get_send_queue_size",      lluv_udp_get_send_queue_size     },
  { "get_send_queue_count",     lluv_udp_get_send_queue_count    },
#if LLUV_UV_VER_GE(1,27,0)
  { "connect",                  lluv_udp_connect                 },
  { "getpeername",              lluv_udp_getpeername             },
#endif

  {NULL,NULL}
};

static const lluv_uv_const_t lluv_udp_constants[] = {
  { UV_UDP_IPV6ONLY,   "UDP_IPV6ONLY"   },
  { UV_UDP_PARTIAL,    "UDP_PARTIAL"    },
  { UV_UDP_REUSEADDR,  "UDP_REUSEADDR"  },
<a name="0"></a>  { UV_LEAVE_GROUP ,   "LEAVE_GROUP"    },
  { UV_JOIN_GROUP,     "JOIN_GROUP"     },

<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  { 0, NULL }
};

#define LLUV_FUNCTIONS(F)       \
  {"udp", lluv_udp_create_##F}, \

static const struct luaL_Reg lluv_functions[][2] = {
  {
    LLUV_FUNCTIONS(unsafe)

    {NULL,NULL}
  },
  {
    LLUV_FUNCTIONS(safe)

    {NULL,NULL}
  },
};

LLUV_INTERNAL void lluv_udp_initlib(lua_State *L, int nup, int safe){
  lutil_pushnvalues(L, nup);
  if(!lutil_createmetap(L, LLUV_UDP, lluv_udp_methods, nup))
    lua_pop(L, nup);
  lua_pop(L, 1);

  luaL_setfuncs(L, lluv_functions[safe], nup);
  lluv_register_constants(L, lluv_udp_constants);
}</b></font>
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
