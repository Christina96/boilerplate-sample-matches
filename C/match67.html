<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for lluv_timer.c & lluv_udp.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for lluv_timer.c & lluv_udp.c
      </h3>
      <h1 align="center">
        23.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>lluv_timer.c (61.22449%)<TH>lluv_udp.c (14.53958%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match67-0.html#0',2,'match67-1.html#0',3)" NAME="0">(133-160)<TD><A HREF="javascript:ZweiFrames('match67-0.html#0',2,'match67-1.html#0',3)" NAME="0">(639-666)</A><TD ALIGN=center><FONT COLOR="#ff0000">27</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match67-0.html#1',2,'match67-1.html#1',3)" NAME="1">(120-133)<TD><A HREF="javascript:ZweiFrames('match67-0.html#1',2,'match67-1.html#1',3)" NAME="1">(599-614)</A><TD ALIGN=center><FONT COLOR="#bc0000">20</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match67-0.html#2',2,'match67-1.html#2',3)" NAME="2">(73-85)<TD><A HREF="javascript:ZweiFrames('match67-0.html#2',2,'match67-1.html#2',3)" NAME="2">(451-467)</A><TD ALIGN=center><FONT COLOR="#8d0000">15</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match67-0.html#3',2,'match67-1.html#3',3)" NAME="3">(25-36)<TD><A HREF="javascript:ZweiFrames('match67-0.html#3',2,'match67-1.html#3',3)" NAME="3">(60-72)</A><TD ALIGN=center><FONT COLOR="#8d0000">15</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match67-0.html#4',2,'match67-1.html#4',3)" NAME="4">(100-113)<TD><A HREF="javascript:ZweiFrames('match67-0.html#4',2,'match67-1.html#4',3)" NAME="4">(571-585)</A><TD ALIGN=center><FONT COLOR="#7a0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>lluv_timer.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/******************************************************************************
* Author: Alexey Melnichuk &lt;alexeymelnichuck@gmail.com&gt;
*
* Copyright (C) 2014-2016 Alexey Melnichuk &lt;alexeymelnichuck@gmail.com&gt;
*
* Licensed according to the included 'LICENSE' document
*
* This file is part of lua-lluv library.
******************************************************************************/

#include &quot;lluv.h&quot;
#include &quot;lluv_handle.h&quot;
#include &quot;lluv_timer.h&quot;
#include &quot;lluv_loop.h&quot;
#include &quot;lluv_error.h&quot;
#include &lt;assert.h&gt;

#define LLUV_TIMER_NAME LLUV_PREFIX&quot; Timer&quot;
static const char *LLUV_TIMER = LLUV_TIMER_NAME;

LLUV_INTERNAL int lluv_timer_index(lua_State *L){
<A NAME="3"></A>  return lluv__index(L, LLUV_TIMER, lluv_handle_index);
}

<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match67-1.html#3',3,'match67-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>LLUV_IMPL_SAFE(lluv_timer_create){
  lluv_loop_t   *loop   = lluv_opt_loop_ex(L, 1, LLUV_FLAG_OPEN);
  lluv_handle_t *handle = lluv_handle_create(L, UV_TIMER, safe_flag | INHERITE_FLAGS(loop));
  int err = uv_timer_init(loop-&gt;handle, LLUV_H(handle, uv_timer_t));
  if(err &lt; 0){
    lluv_handle_cleanup(L, handle, -1);
    return lluv_fail(L, safe_flag | loop-&gt;flags, LLUV_ERR_UV, (uv_errno_t)err, NULL);
  }
  return 1;
}

static lluv_handle_t* lluv_check_timer(lua_State *L, int idx, lluv_flags_t flags){</B></FONT>
  lluv_handle_t *handle = lluv_check_handle(L, idx, flags);
  luaL_argcheck (L, LLUV_H(handle, uv_handle_t)-&gt;type == UV_TIMER, idx, LLUV_TIMER_NAME&quot; expected&quot;);

  return handle;
}

static void lluv_on_timer_start(uv_timer_t *arg){
  uv_handle_t *h = (uv_handle_t*)arg;
  if(!uv_is_active(h)){
    lluv_handle_t *handle = lluv_handle_byptr(h);
    lua_State *L = LLUV_HCALLBACK_L(handle);
    lluv_handle_unlock(L, handle, LLUV_LOCK_START);
  }
  lluv_on_handle_start(h);
}

static int lluv_timer_start(lua_State *L){
  lluv_handle_t *handle = lluv_check_timer(L, 1, LLUV_FLAG_OPEN);
  uint64_t timeout, repeat;
  int err;

  lluv_check_args_with_cb(L, 4);
  LLUV_START_CB(handle) = luaL_ref(L, LLUV_LUA_REGISTRY);

  if(lua_gettop(L) &gt; 1){
    timeout = lutil_checkint64(L, 2);
    if(lua_gettop(L) &gt; 2)
      repeat = lutil_checkint64(L, 3);
    else
      repeat = 0;
  }
  else{
    timeout = 0;
<A NAME="2"></A>    repeat  = 0;
  }

<FONT color="#980517"><A HREF="javascript:ZweiFrames('match67-1.html#2',3,'match67-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  err = uv_timer_start(LLUV_H(handle, uv_timer_t), lluv_on_timer_start, timeout, repeat);

  if(err &gt;= 0) lluv_handle_lock(L, handle, LLUV_LOCK_START);

  return lluv_return(L, handle, LLUV_START_CB(handle), err);
}

static int lluv_timer_stop(lua_State *L){
  lluv_handle_t *handle = lluv_check_timer(L, 1, LLUV_FLAG_OPEN);
  int err = uv_timer_stop(LLUV_H(handle, uv_timer_t));
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }</B></FONT>

  lluv_handle_lock(L, handle, LLUV_LOCK_START);

  lua_settop(L, 1);
  return 1;
}

static int lluv_timer_again(lua_State *L){
  lluv_handle_t *handle = lluv_check_timer(L, 1, LLUV_FLAG_OPEN);
  int err;
  if(lua_isnumber(L, 2)){
<A NAME="4"></A>    uint64_t repeat = lutil_optint64(L, 2, 0);
    uv_timer_set_repeat(LLUV_H(handle, uv_timer_t), repeat);
  }
<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match67-1.html#4',3,'match67-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  err = uv_timer_again(LLUV_H(handle, uv_timer_t));
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }

  lluv_handle_lock(L, handle, LLUV_LOCK_START);

  lua_settop(L, 1);
  return 1;
}

static int lluv_timer_set_repeat(lua_State *L){
  lluv_handle_t *handle = lluv_check_timer(L, 1, LLUV_FLAG_OPEN);
  uint64_t repeat = lutil_optint64(L, 2, 0);</B></FONT>
  uv_timer_set_repeat(LLUV_H(handle, uv_timer_t), repeat);
  lua_settop(L, 1);
  return 1;
<A NAME="1"></A>}

static int lluv_timer_get_repeat(lua_State *L){
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match67-1.html#1',3,'match67-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  lluv_handle_t *handle = lluv_check_timer(L, 1, LLUV_FLAG_OPEN);
  uint64_t repeat = uv_timer_get_repeat(LLUV_H(handle, uv_timer_t));
  lutil_pushint64(L, repeat);
  return 1;
}

static const struct luaL_Reg lluv_timer_methods[] = {
  { &quot;start&quot;,      lluv_timer_start      },
  { &quot;stop&quot;,       lluv_timer_stop       },
  { &quot;again&quot;,      lluv_timer_again      },
<A NAME="0"></A>  { &quot;set_repeat&quot;, lluv_timer_set_repeat },
  { &quot;get_repeat&quot;, lluv_timer_get_repeat },

</B></FONT><FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match67-1.html#0',3,'match67-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  {NULL,NULL}
};

#define LLUV_FUNCTIONS(F)           \
  {&quot;timer&quot;, lluv_timer_create_##F}, \

static const struct luaL_Reg lluv_functions[][2] = {
  {
    LLUV_FUNCTIONS(unsafe)

    {NULL,NULL}
  },
  {
    LLUV_FUNCTIONS(safe)

    {NULL,NULL}
  },
};


LLUV_INTERNAL void lluv_timer_initlib(lua_State *L, int nup, int safe){
  lutil_pushnvalues(L, nup);
  if(!lutil_createmetap(L, LLUV_TIMER, lluv_timer_methods, nup))
    lua_pop(L, nup);
  lua_pop(L, 1);

  luaL_setfuncs(L, lluv_functions[safe], nup);
}</B></FONT>
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lluv_udp.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/******************************************************************************
* Author: Alexey Melnichuk &lt;alexeymelnichuck@gmail.com&gt;
*
* Copyright (C) 2014-2019 Alexey Melnichuk &lt;alexeymelnichuck@gmail.com&gt;
*
* Licensed according to the included 'LICENSE' document
*
* This file is part of lua-lluv library.
******************************************************************************/

#include &quot;lluv.h&quot;
#include &quot;lluv_handle.h&quot;
#include &quot;lluv_udp.h&quot;
#include &quot;lluv_loop.h&quot;
#include &quot;lluv_error.h&quot;
#include &quot;lluv_req.h&quot;
#include &quot;lluv_stream.h&quot;
#include &lt;assert.h&gt;

#define LLUV_UDP_NAME LLUV_PREFIX&quot; udp&quot;
static const char *LLUV_UDP = LLUV_UDP_NAME;

LLUV_INTERNAL int lluv_udp_index(lua_State *L){
  return lluv__index(L, LLUV_UDP, lluv_handle_index);
}

LLUV_IMPL_SAFE(lluv_udp_create){
  lluv_loop_t   *loop   = lluv_opt_loop(L, 1, LLUV_FLAG_OPEN);
  lluv_handle_t *handle;
  int err;

#if LLUV_UV_VER_GE(1,7,0)
  unsigned int flags = lluv_opt_af_flags(L, loop ? 2 : 1, AF_UNSPEC);
#endif

  if(!loop) loop = lluv_default_loop(L);

  handle = lluv_handle_create(L, UV_UDP, safe_flag | INHERITE_FLAGS(loop));

#if LLUV_UV_VER_GE(1,7,0)
  err = uv_udp_init_ex(loop-&gt;handle, LLUV_H(handle, uv_udp_t), flags);
#else
  err = uv_udp_init(loop-&gt;handle, LLUV_H(handle, uv_udp_t));
#endif

  if(err &lt; 0){
    lluv_handle_cleanup(L, handle, -1);
    return lluv_fail(L, safe_flag | loop-&gt;flags, LLUV_ERR_UV, (uv_errno_t)err, NULL);
  }
  return 1;
}

static lluv_handle_t* lluv_check_udp(lua_State *L, int idx, lluv_flags_t flags){
  lluv_handle_t *handle = lluv_check_handle(L, idx, flags);
  luaL_argcheck (L, LLUV_H(handle, uv_handle_t)-&gt;type == UV_UDP, idx, LLUV_UDP_NAME&quot; expected&quot;);

<A NAME="3"></A>  return handle;
}

<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match67-0.html#3',2,'match67-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>static int lluv_udp_open(lua_State *L){
  lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  uv_os_sock_t sock = lluv_check_os_sock(L, 2);
  int err = uv_udp_open(LLUV_H(handle, uv_udp_t), sock);
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }

  lua_settop(L, 1);
  return 1;
}

static int lluv_udp_bind(lua_State *L){</B></FONT>
  static const lluv_uv_const_t FLAGS[] = {
    { UV_UDP_IPV6ONLY ,   &quot;ipv6only&quot;   },
    { UV_UDP_REUSEADDR,   &quot;reuseaddr&quot;  },

    { 0, NULL }
  };

  lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  struct sockaddr_storage sa; int err = lluv_check_addr(L, 2, &amp;sa);
  unsigned int flags = 0;
  int top = lua_gettop(L);
  if(top &gt; 5)lua_settop(L, top = 5);

  if((top &gt; 4) || (!lua_isfunction(L, 4))){
    flags = lluv_opt_flags_ui(L, 4, flags, FLAGS);
  }

  if(err &lt; 0){
    lua_checkstack(L, 3);

    lua_pushvalue(L, 2); lua_pushliteral(L, &quot;:&quot;); lua_pushvalue(L, 3); lua_concat(L, 3);

    if(!lua_isfunction(L, top)){
      return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, lua_tostring(L, -1));
    }

    lluv_error_create(L, LLUV_ERR_UV, err, lua_tostring(L, -1));
    lua_remove(L, -2);
    lua_pushvalue(L, 1);
    lua_insert(L, -2);
    lluv_loop_defer_call(L, lluv_loop_by_handle(&amp;handle-&gt;handle), 2);
    lua_settop(L, 1);
    return 1;
  }

  err = uv_udp_bind(LLUV_H(handle, uv_udp_t), (struct sockaddr *)&amp;sa, flags);
  if(err &lt; 0){
    lua_checkstack(L, 3);

    lua_pushvalue(L, 2); lua_pushliteral(L, &quot;:&quot;); lua_pushvalue(L, 3); lua_concat(L, 3);

    if(!lua_isfunction(L, top)){
      return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, lua_tostring(L, -1));
    }

    lluv_error_create(L, LLUV_ERR_UV, err, lua_tostring(L, -1));
    lua_remove(L, -2);
    lua_pushvalue(L, 1);
    lua_insert(L, -2);
    lluv_loop_defer_call(L, lluv_loop_by_handle(&amp;handle-&gt;handle), 2);
    lua_settop(L, 1);
    return 1;
  }

  if(lua_isfunction(L, top)){
    lua_pushvalue(L, 1);
    lua_pushnil(L);
    lluv_loop_defer_call(L,
      lluv_loop_by_handle(&amp;handle-&gt;handle),
      lluv_push_addr(L, &amp;sa) + 2
    );
  }

  lua_settop(L, 1);
  return 1;
}

#if LLUV_UV_VER_GE(1,27,0)

static int lluv_udp_connect(lua_State *L){
  lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  int is_disconnect = (lua_isnoneornil(L, 2) || lua_isfunction(L, 2)) ? 1 : 0;
  struct sockaddr_storage sa; int err = is_disconnect ? 0 : lluv_check_addr(L, 2, &amp;sa);
  struct sockaddr_storage *psa = is_disconnect ? 0 : &amp;sa;
  int top = lua_gettop(L);

  if(top &gt; 4) lua_settop(L, top = 4);

  if (err &lt; 0) {
    assert(psa);

    lua_checkstack(L, 3);

    lua_pushvalue(L, 2); lua_pushliteral(L, &quot;:&quot;); lua_pushvalue(L, 3); lua_concat(L, 3);

    if (!lua_isfunction(L, top)) {
      return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, lua_tostring(L, -1));
    }

    lluv_error_create(L, LLUV_ERR_UV, err, lua_tostring(L, -1));
    lua_remove(L, -2);
    lua_pushvalue(L, 1);
    lua_insert(L, -2);
    lluv_loop_defer_call(L, lluv_loop_by_handle(&amp;handle-&gt;handle), 2);
    lua_settop(L, 1);
    return 1;
  }

  err = uv_udp_connect(LLUV_H(handle, uv_udp_t), (struct sockaddr *)psa);

  if (err &lt; 0) {
    const char *ip = 0;
    if (psa) {
      lua_checkstack(L, 3);
      lua_pushvalue(L, 2); lua_pushliteral(L, &quot;:&quot;); lua_pushvalue(L, 3); lua_concat(L, 3);
      ip = lua_tostring(L, -1);
    }

    if (!lua_isfunction(L, top)) {
      return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, ip);
    }

    lluv_error_create(L, LLUV_ERR_UV, err, ip);
    if (ip) {
      lua_remove(L, -2);
    }
    lua_pushvalue(L, 1);
    lua_insert(L, -2);
    lluv_loop_defer_call(L, lluv_loop_by_handle(&amp;handle-&gt;handle), 2);
    lua_settop(L, 1);
    return 1;
  }

  if(lua_isfunction(L, top)){
    int n = 2;
    lua_pushvalue(L, 1);
    lua_pushnil(L);
    if (psa) {
      n += lluv_push_addr(L, psa);
    }
    lluv_loop_defer_call(L, lluv_loop_by_handle(&amp;handle-&gt;handle), n);
  }

  lua_settop(L, 1);
  return 1;
}

static int lluv_udp_getpeername(lua_State *L) {
  lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  struct sockaddr_storage sa;
  int size = sizeof(sa);

  int err = uv_udp_getpeername(LLUV_H(handle, uv_udp_t), (struct sockaddr *)&amp;sa, &amp;size);

  if (err &lt; 0) {
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, 0);
  }

  return lluv_push_addr(L, &amp;sa);
}

#endif

//{ Send

static int lluv_udp_try_send(lua_State *L){
  lluv_handle_t *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  int top = lua_gettop(L);
  int is_connected =
#if LLUV_UV_VER_GE(1,27,0)
    (top == 2) ? 1 :
#endif
    0;
  struct sockaddr_storage sa; int err = is_connected ? 0 : lluv_check_addr(L, 2, &amp;sa);
  struct sockaddr_storage *psa = is_connected ? 0 : &amp;sa;
  int data_index = is_connected ? 2 : 4;

  if (err &lt; 0) {
    lua_settop(L, 3);
    lua_pushliteral(L, &quot;:&quot;); lua_insert(L, -2); lua_concat(L, 3);
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, lua_tostring(L, -1));
  }

  if (lua_istable(L, data_index)) {
    size_t i, n = lua_rawlen(L, data_index);
    uv_buf_t *buf;

    luaL_argcheck(L, n &gt; 0, data_index, &quot;Empty array not supported&quot;);

    buf = (uv_buf_t*)lluv_alloca(sizeof(uv_buf_t) * n);
    if (!buf) {
      return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, ENOMEM, NULL);
    }

    for (i = 0; i &lt; n; ++i) {
      size_t len; const char *str;
      lua_rawgeti(L, data_index, i + 1);
      str = luaL_checklstring(L, -1, &amp;len);
      buf[i] = lluv_buf_init((char*)str, len);
      lua_pop(L, 1);
    }
    err = uv_udp_try_send(LLUV_H(handle, uv_udp_t), buf, n, (struct sockaddr*)psa);
  }
  else {
    size_t len; const char *str;
    uv_buf_t buf;

    luaL_argcheck(L, lua_isstring(L, data_index), data_index, &quot;String or array expected&quot;);
    str = lua_tolstring(L, data_index, &amp;len);
    buf = lluv_buf_init((char*)str, len);
    err = uv_udp_try_send(LLUV_H(handle, uv_udp_t), &amp;buf, 1, (struct sockaddr*)psa);
  }

  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }

  lua_pushinteger(L, err);
  return 1;
}

static void lluv_on_udp_send_cb(uv_udp_send_t* arg, int status){
  lluv_on_stream_req_cb((uv_req_t*)arg, status);
}

static int lluv_udp_send_(lua_State *L, lluv_handle_t *handle, struct sockaddr *sa, uv_buf_t *buf, size_t n, int data_index){
  int err; lluv_req_t *req;

  if(lua_gettop(L) == (data_index + 2)){
    int ctx;
    lluv_check_callable(L, -2);
    ctx = luaL_ref(L, LLUV_LUA_REGISTRY);
    req = lluv_req_new(L, UV_UDP_SEND, handle);
    lluv_req_ref(L, req); /* string/table */
    req-&gt;ctx = ctx;
  }
  else{
    if(lua_gettop(L) == data_index)
      lua_settop(L, data_index + 1);
    else
      lluv_check_args_with_cb(L, data_index + 1);

    req = lluv_req_new(L, UV_UDP_SEND, handle);
    lluv_req_ref(L, req); /* string/table */
  }

  err = uv_udp_send(LLUV_R(req, udp_send), LLUV_H(handle, uv_udp_t), buf, n, sa, lluv_on_udp_send_cb);

  return lluv_return_req(L, handle, req, err);
}

static int lluv_udp_send_t(lua_State *L, lluv_handle_t  *handle, struct sockaddr *sa, int data_index){
  int i;
  size_t n = lua_rawlen(L, data_index);
  uv_buf_t *buf;

  assert(lua_type(L, data_index) == LUA_TTABLE);

  luaL_argcheck(L, n &gt; 0, data_index, &quot;Empty array not supported&quot;);

  buf = (uv_buf_t*)lluv_alloca(sizeof(uv_buf_t) * n);
  if(!buf){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, ENOMEM, NULL); 
  }

  for(i = 0; i &lt; n; ++i){
    size_t len; const char *str;
    lua_rawgeti(L, data_index, i + 1);
    str = luaL_checklstring(L, -1, &amp;len);
    buf[i] = lluv_buf_init((char*)str, len);
    lua_pop(L, 1);
  }

  return lluv_udp_send_(L, handle, sa, buf, n, data_index);
}

// connected
//   send(data)
//   send(data, cb)
//   send(data, cb, ctx)
// disconnected
//   send(addr, port, data)
//   send(addr, port, data, cb)
//   send(addr, port, data, cb, ctx)
static int lluv_udp_send(lua_State *L){
  lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  int top = lua_gettop(L);
  int is_connected =
#if LLUV_UV_VER_GE(1,27,0)
    ((top == 2) || lua_isfunction(L, 3)) ? 1 :
#endif
    0;
  struct sockaddr_storage sa; int err = is_connected ? 0 : lluv_check_addr(L, 2, &amp;sa);
  struct sockaddr_storage *psa = is_connected ? 0 : &amp;sa;
  int data_index = is_connected ? 2 : 4;

  if(err &lt; 0){
    int top = lua_gettop(L);
    if(top &gt; 4) lua_settop(L, top = 5);

    if(lua_isfunction(L, top)){
      lua_pushvalue(L, 1); /*self*/
      /*host:port*/
      lua_pushvalue(L, 2); lua_pushliteral(L, &quot;:&quot;); lua_pushvalue(L, 3); lua_concat(L, 3);
      lluv_error_create(L, LLUV_ERR_UV, err, lua_tostring(L, -1));
      lua_remove(L, -2);
      lluv_loop_defer_call(L, lluv_loop_by_handle(&amp;handle-&gt;handle), 2);
      lua_settop(L, 1);
      return 1;
    }
  
    lua_settop(L, 3);
    lua_pushliteral(L, &quot;:&quot;);lua_insert(L, -2);lua_concat(L, 3);
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, lua_tostring(L, -1));
  }

  if(lua_type(L, data_index) == LUA_TTABLE){
    return lluv_udp_send_t(L, handle, (struct sockaddr*)psa, data_index);
  }
  else{
    size_t len; const char *str = luaL_checklstring(L, data_index, &amp;len);
    uv_buf_t buf = lluv_buf_init((char*)str, len);
    return lluv_udp_send_(L, handle, (struct sockaddr*)psa, &amp;buf, 1, data_index);
  }
}

//}

//{ Recv

static void lluv_on_udp_recv_cb(uv_udp_t *arg, ssize_t nread, const uv_buf_t* buf, const struct sockaddr* addr, unsigned flags){
  lluv_handle_t *handle = lluv_handle_byptr((uv_handle_t*)arg);
  lua_State *L = LLUV_HCALLBACK_L(handle);

  LLUV_CHECK_LOOP_CB_INVARIANT(L);

  if((nread == 0) &amp;&amp; (addr == NULL)){
    /*
    ** The receive callback will be called with 
    ** nread == 0 and addr == NULL when there is 
    ** nothing to read
    */
    lluv_free_buffer((uv_handle_t*)arg, buf);
    return;
  }

  lua_rawgeti(L, LLUV_LUA_REGISTRY, LLUV_READ_CB(handle));
  assert(!lua_isnil(L, -1));

  lluv_handle_pushself(L, handle);

  if(nread &gt;= 0){
    assert(addr);
    lua_pushnil(L);
    lua_pushlstring(L, buf-&gt;base, nread);
    lluv_free_buffer((uv_handle_t*)arg, buf);
  }
  else{
    lluv_free_buffer((uv_handle_t*)arg, buf);

    /* The callee is responsible for stopping closing the stream 
     *  when an error happens by calling uv_read_stop() or uv_close().
     *  Trying to read from the stream again is undefined.
     */
    uv_udp_recv_stop(arg);

    luaL_unref(L, LLUV_LUA_REGISTRY, LLUV_READ_CB(handle));
    LLUV_READ_CB(handle) = LUA_NOREF;

    lluv_error_create(L, LLUV_ERR_UV, (uv_errno_t)nread, NULL);
    lua_pushnil(L);

    lluv_handle_unlock(L, handle, LLUV_LOCK_READ);
  }
  lua_pushinteger(L, flags);

  LLUV_HANDLE_CALL_CB(L, handle, 4 + lluv_push_addr(L, (const struct sockaddr_storage*)addr));

  LLUV_CHECK_LOOP_CB_INVARIANT(L);
}

static int lluv_udp_start_recv(lua_State *L){
  lluv_handle_t *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  int err;

<A NAME="2"></A>  lluv_check_args_with_cb(L, 2);
  LLUV_READ_CB(handle) = luaL_ref(L, LLUV_LUA_REGISTRY);

<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match67-0.html#2',2,'match67-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  err = uv_udp_recv_start(LLUV_H(handle, uv_udp_t), lluv_alloc_buffer_cb, lluv_on_udp_recv_cb);

  if(err &gt;= 0) lluv_handle_lock(L, handle, LLUV_LOCK_READ);

  return lluv_return(L, handle, LLUV_READ_CB(handle), err);
}

static int lluv_udp_stop_recv(lua_State *L){
  lluv_handle_t *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  int err;

  lluv_check_none(L, 2);

  err = uv_udp_recv_stop(LLUV_H(handle, uv_udp_t));
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }</B></FONT>

  if(LLUV_READ_CB(handle) != LUA_NOREF){
    luaL_unref(L, LLUV_LUA_REGISTRY, LLUV_READ_CB(handle));
    LLUV_READ_CB(handle) = LUA_NOREF;
    lluv_handle_unlock(L, handle, LLUV_LOCK_READ);
  }

  lua_settop(L, 1);
  return 1;
}

//}

static int lluv_udp_getsockname(lua_State *L){
  lluv_handle_t *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  struct sockaddr_storage sa; int sa_len = sizeof(sa);
  int err = uv_udp_getsockname(LLUV_H(handle, uv_udp_t), (struct sockaddr*)&amp;sa, &amp;sa_len);

  lua_settop(L, 1);
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }
  return lluv_push_addr(L, &amp;sa);
}

static int lluv_udp_set_membership(lua_State *L){
  static const lluv_uv_const_t FLAGS[] = {
    { UV_LEAVE_GROUP,   &quot;leave&quot; },
    { UV_JOIN_GROUP,    &quot;join&quot;  },

    { 0, NULL }
  };

  lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  const char *multicast_addr = luaL_checkstring(L, 2);
  const char *interface_addr = lua_isnoneornil(L,3)?NULL:luaL_checkstring(L, 3);
  uv_membership membership   = (uv_membership)lluv_opt_named_const(L, 4, UV_JOIN_GROUP, FLAGS);

  int err = uv_udp_set_membership(LLUV_H(handle, uv_udp_t), multicast_addr, interface_addr, membership);
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }

  lua_settop(L, 1);
  return 1;
}

static int lluv_udp_set_multicast_loop(lua_State *L){
  lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  int enable = lua_toboolean(L, 2);

  int err = uv_udp_set_multicast_loop(LLUV_H(handle, uv_udp_t), enable);
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }

  lua_settop(L, 1);
  return 1;
}

static int lluv_udp_set_multicast_ttl(lua_State *L){
  lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  int ttl = luaL_checkint(L, 2);

  int err = uv_udp_set_multicast_ttl(LLUV_H(handle, uv_udp_t), ttl);
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }

  lua_settop(L, 1);
  return 1;
}

static int lluv_udp_set_multicast_interface(lua_State *L){
  lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  const char *interface_addr = luaL_checkstring(L, 2);

  int err = uv_udp_set_multicast_interface(LLUV_H(handle, uv_udp_t), interface_addr);
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }

  lua_settop(L, 1);
  return 1;
}

static int lluv_udp_set_broadcast(lua_State *L){
  lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  int enable = lua_toboolean(L, 2);

  int err = uv_udp_set_broadcast(LLUV_H(handle, uv_udp_t), enable);
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }

  lua_settop(L, 1);
  return 1;
}

static int lluv_udp_set_ttl(lua_State *L){
<A NAME="4"></A>  lluv_handle_t  *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  int ttl = luaL_checkint(L, 2);

<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match67-0.html#4',2,'match67-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  int err = uv_udp_set_ttl(LLUV_H(handle, uv_udp_t), ttl);
  if(err &lt; 0){
    return lluv_fail(L, handle-&gt;flags, LLUV_ERR_UV, err, NULL);
  }

  lua_settop(L, 1);
  return 1;
}

static int lluv_udp_get_send_queue_size(lua_State *L){
  lluv_handle_t *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
  size_t queue_size;

#if LLUV_UV_VER_GE(1,19,0)
  queue_size = uv_udp_get_send_queue_size(LLUV_H(handle, uv_udp_t));</B></FONT>
#else
  queue_size = LLUV_H(handle, uv_udp_t)-&gt;send_queue_size;
#endif

  lutil_pushint64(L, queue_size);
  return 1;
}

static int lluv_udp_get_send_queue_count(lua_State *L){
  lluv_handle_t *handle = lluv_check_udp(L, 1, LLUV_FLAG_OPEN);
<A NAME="1"></A>  size_t queue_count;

#if LLUV_UV_VER_GE(1,19,0)
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match67-0.html#1',2,'match67-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  queue_count = uv_udp_get_send_queue_count(LLUV_H(handle, uv_udp_t));
#else
  queue_count = LLUV_H(handle, uv_udp_t)-&gt;send_queue_count;
#endif

  lutil_pushint64(L, queue_count);
  return 1;
}

static const struct luaL_Reg lluv_udp_methods[] = {
  { &quot;open&quot;,                     lluv_udp_open                    },
  { &quot;bind&quot;,                     lluv_udp_bind                    },
  { &quot;try_send&quot;,                 lluv_udp_try_send                },
  { &quot;send&quot;,                     lluv_udp_send                    },
  { &quot;getsockname&quot;,              lluv_udp_getsockname             },
  { &quot;start_recv&quot;,               lluv_udp_start_recv              },</B></FONT>
  { &quot;stop_recv&quot;,                lluv_udp_stop_recv               },
  { &quot;set_membership&quot;,           lluv_udp_set_membership          },
  { &quot;set_multicast_loop&quot;,       lluv_udp_set_multicast_loop      },
  { &quot;set_multicast_ttl&quot;,        lluv_udp_set_multicast_ttl       },
  { &quot;set_multicast_interface&quot;,  lluv_udp_set_multicast_interface },
  { &quot;set_broadcast&quot;,            lluv_udp_set_broadcast           },
  { &quot;set_ttl&quot;,                  lluv_udp_set_ttl                 },
  { &quot;get_send_queue_size&quot;,      lluv_udp_get_send_queue_size     },
  { &quot;get_send_queue_count&quot;,     lluv_udp_get_send_queue_count    },
#if LLUV_UV_VER_GE(1,27,0)
  { &quot;connect&quot;,                  lluv_udp_connect                 },
  { &quot;getpeername&quot;,              lluv_udp_getpeername             },
#endif

  {NULL,NULL}
};

static const lluv_uv_const_t lluv_udp_constants[] = {
  { UV_UDP_IPV6ONLY,   &quot;UDP_IPV6ONLY&quot;   },
  { UV_UDP_PARTIAL,    &quot;UDP_PARTIAL&quot;    },
  { UV_UDP_REUSEADDR,  &quot;UDP_REUSEADDR&quot;  },
<A NAME="0"></A>  { UV_LEAVE_GROUP ,   &quot;LEAVE_GROUP&quot;    },
  { UV_JOIN_GROUP,     &quot;JOIN_GROUP&quot;     },

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match67-0.html#0',2,'match67-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  { 0, NULL }
};

#define LLUV_FUNCTIONS(F)       \
  {&quot;udp&quot;, lluv_udp_create_##F}, \

static const struct luaL_Reg lluv_functions[][2] = {
  {
    LLUV_FUNCTIONS(unsafe)

    {NULL,NULL}
  },
  {
    LLUV_FUNCTIONS(safe)

    {NULL,NULL}
  },
};

LLUV_INTERNAL void lluv_udp_initlib(lua_State *L, int nup, int safe){
  lutil_pushnvalues(L, nup);
  if(!lutil_createmetap(L, LLUV_UDP, lluv_udp_methods, nup))
    lua_pop(L, nup);
  lua_pop(L, 1);

  luaL_setfuncs(L, lluv_functions[safe], nup);
  lluv_register_constants(L, lluv_udp_constants);
}</B></FONT>
</PRE>
</div>
  </div>
</body>
</html>
