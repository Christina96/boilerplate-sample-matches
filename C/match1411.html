<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mcell_reactions.c &amp; config-win.h</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mcell_reactions.c &amp; config-win.h
      </h3>
<h1 align="center">
        1.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mcell_reactions.c (0.708061%)<th>config-win.h (3.6879432%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1714-1728)<td><a href="#" name="0">(233-246)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1913-1924)<td><a href="#" name="1">(305-320)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mcell_reactions.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;assert.h&gt;
3 #include &lt;string.h&gt;
4 #include &lt;math.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include "nfsim_func.h"
7 #include "diffuse_util.h"
8 #include "sym_table.h"
9 #include "logging.h"
10 #include "react_util.h"
11 #include "strfunc.h"
12 #include "react.h"
13 #include "mcell_reactions.h"
14 #include "diffuse.h"
15 #include "vol_util.h"
16 #include "mcell_structs.h"
17 static char *concat_rx_name(char *name1, char *name2);
18 MCELL_STATUS extract_reactants(struct pathway *path,
19                                       struct mcell_species *reactants,
20                                       int *num_reactants, int *num_vol_mols,
21                                       int *num_surface_mols,
22                                       int *all_3d,
23                                       int *oriented_count);
24 static MCELL_STATUS extract_catalytic_arrow(struct pathway *path,
25                                             struct reaction_arrow *react_arrow,
26                                             int *num_reactants,
27                                             int *num_vol_mols,
28                                             int *num_surface_mols, int *all_3d,
29                                             int *oriented_count);
30 static MCELL_STATUS extract_surface(struct pathway *path,
31                                     struct mcell_species *surf_class,
32                                     int *num_reactants,
33                                     unsigned int *num_surfaces,
34                                     int *oriented_count);
35 MCELL_STATUS extract_products(struct notifications *notify,
36                                      struct pathway *path,
37                                      struct mcell_species *products,
38                                      int *num_surf_products,
39                                      int bidirectional,
40                                      int all_3d);
41 static MCELL_STATUS check_surface_specs(struct notifications *notify,
42                                         int num_reactants, int num_surfaces,
43                                         int num_vol_mols, int all_3d,
44                                         int oriented_count);
45 static MCELL_STATUS add_catalytic_species_to_products(struct pathway *path,
46                                                       int catalytic,
47                                                       int bidirectional,
48                                                       int all_3d);
49 static MCELL_STATUS invert_current_reaction_pathway(
50     struct sym_table_head *rxn_sym_table,
51     double vacancy_search_dist2,
52     struct pathway *pathp,
53     struct reaction_rate *reverse_rate,
54     const char *rate_filename);
55 static char *create_prod_signature(struct product **product_head);
56 static void set_reaction_player_flags(struct rxn *rx);
57 static int build_reaction_hash_table(
58   struct rxn ***reaction_hash, int *n_reactions,
59   struct sym_table_head *rxn_sym_table, int *rx_hashsize, int num_rx);
60 static void check_reaction_for_duplicate_pathways(struct pathway **head);
61 static int load_rate_file(struct volume* state, struct rxn *rx, char *fname, int path);
62 static void add_surface_reaction_flags(struct sym_table_head *mol_sym_table,
63                                        struct species *all_mols,
64                                        struct species *all_surface_mols,
65                                        struct species *all_volume_mols);
66 static void alphabetize_pathway(struct pathway *path, struct rxn *reaction);
67 static struct rxn *split_reaction(struct rxn *rx);
68 static void check_duplicate_special_reactions(struct pathway *path);
69 static int sort_product_list_compare(struct product *list_item,
70                                      struct product *new_item);
71 static struct product *sort_product_list(struct product *product_head);
72 MCELL_STATUS
73 mcell_modify_multiple_rate_constants(struct volume *world, char **names, double *rate_constants, int n_rxns) {
74   struct rxn **reactions_ud = (struct rxn **)malloc(0 * sizeof(*reactions_ud));   struct rxn **reactions_undv = (struct rxn **)malloc(0 * sizeof(*reactions_undv));
75   struct rxn **reactions_unds = (struct rxn **)malloc(0 * sizeof(*reactions_unds));
76   int n_reactions_ud=0;
77   int n_reactions_undv=0;
78   int n_reactions_unds=0;
79   int i_rxn=0;
80   while(i_rxn &lt; n_rxns)
81   {
82     struct sym_table_head *rxpn_sym_table = world-&gt;rxpn_sym_table;
83     struct sym_entry *sym = retrieve_sym(names[i_rxn], rxpn_sym_table);
84     if (sym == NULL) 
85     {
86       return MCELL_FAIL;
87     }
88     struct rxn_pathname *rxpn = (struct rxn_pathname *)sym-&gt;value;
89     struct rxn *reaction = rxpn-&gt;rx;  
90     int j = rxpn-&gt;path_num;
91     int can_diffuse = distinguishable(reaction-&gt;players[0]-&gt;D, 0, EPS_C);
92     if (reaction-&gt;n_reactants == 1 &amp;&amp; can_diffuse)
93     {
94       reactions_ud = (struct rxn **) realloc(reactions_ud, (n_reactions_ud + 1)*sizeof(*reactions_ud));
95       reactions_ud[n_reactions_ud] = reaction;
96       n_reactions_ud++;
97     }
98     else if (((!can_diffuse) &amp;&amp; (reaction-&gt;n_reactants == 1)) || 
99     ((!can_diffuse) &amp;&amp; (reaction-&gt;n_reactants == 2) &amp;&amp; (reaction-&gt;players[1]-&gt;flags == IS_SURFACE))) 
100     {
101       if ((reaction-&gt;players[0]-&gt;flags &amp; NOT_FREE) != 0) 
102       {
103         reactions_unds = (struct rxn **) realloc(reactions_unds, (n_reactions_unds + 1)*sizeof(*reactions_unds));
104         reactions_unds[n_reactions_unds] = reaction;
105         n_reactions_unds++;
106       }
107       else
108       {
109         reactions_undv = (struct rxn **) realloc(reactions_undv, (n_reactions_undv + 1)*sizeof(*reactions_undv));
110         reactions_undv[n_reactions_undv] = reaction;
111         n_reactions_undv++;
112       }
113     }
114     double p = rate_constants[i_rxn] * reaction-&gt;pb_factor;
115     double delta_prob;
116     if (j == 0)
117       delta_prob = p - reaction-&gt;cum_probs[0];
118     else
119       delta_prob = p - (reaction-&gt;cum_probs[j] - reaction-&gt;cum_probs[j - 1]);
120     for (int k = j; k &lt; reaction-&gt;n_pathways; k++) 
121     {
122       reaction-&gt;cum_probs[k] += delta_prob;
123     }
124     reaction-&gt;max_fixed_p += delta_prob;
125     reaction-&gt;min_noreaction_p += delta_prob;
126     i_rxn++;
127   }
128   if (n_reactions_ud &gt; 0)   {
129     for (struct storage_list *local = world-&gt;storage_head; local != NULL; local = local-&gt;next) 
130     {
131       struct abstract_element *head_molecule = local-&gt;store-&gt;timer-&gt;current;
132       while (local-&gt;store-&gt;timer-&gt;current != NULL) 
133       {
134         struct abstract_molecule *am = (struct abstract_molecule *)schedule_peak(local-&gt;store-&gt;timer);
135         for (int i_reactions_ud=0; i_reactions_ud&lt;n_reactions_ud; i_reactions_ud++)
136         {
137           if ((am-&gt;properties != NULL) &amp;&amp; (am-&gt;properties-&gt;species_id == reactions_ud[i_reactions_ud]-&gt;players[0]-&gt;species_id)) 
138           {
139             am-&gt;t2 = 0.0;
140             am-&gt;flags |= ACT_CHANGE;
141           }
142         }
143       }
144       local-&gt;store-&gt;timer-&gt;current = head_molecule;
145     }
146   }
147   if (n_reactions_undv &gt; 0)   {
148     int n_subvols = world-&gt;n_subvols;
149     for (int i = 0; i &lt; n_subvols; i++) 
150     {
151       struct subvolume *sv = &amp;(world-&gt;subvol[i]);
152       for (struct per_species_list *psl = sv-&gt;species_head; psl != NULL; psl = psl-&gt;next) 
153       {
154         if (psl-&gt;properties == NULL) 
155         {
156           continue;
157         }
158         for (struct volume_molecule *vm = psl-&gt;head; vm != NULL; vm = vm-&gt;next_v) 
159         {
160           if ((vm-&gt;properties != NULL) &amp;&amp; (vm-&gt;t &gt; world-&gt;current_iterations)) 
161           {
162             for (int i_reactions_undv=0; i_reactions_undv&lt;n_reactions_undv; i_reactions_undv++)
163             {
164               if (vm-&gt;properties-&gt;species_id == reactions_undv[i_reactions_undv]-&gt;players[0]-&gt;species_id)
165               { 
166                 for (struct storage_list *local = world-&gt;storage_head; local != NULL; local = local-&gt;next) 
167                 {
168                   vm-&gt;flags |= ACT_CHANGE;
169                   vm-&gt;t2 = 0.0;
170                   schedule_reschedule(local-&gt;store-&gt;timer, vm, world-&gt;current_iterations);
171                 }
172               }
173             }
174           }
175         }
176       }
177     }
178   }
179   if (n_reactions_unds &gt; 0)   {
180     int n_subvols = world-&gt;n_subvols;
181     for (int i = 0; i &lt; n_subvols; i++) 
182     {
183       struct subvolume *sv = &amp;(world-&gt;subvol[i]);
184       for (struct wall_list *wl = sv-&gt;wall_head; wl != NULL; wl = wl-&gt;next) 
185       {
186         struct surface_grid *grid = wl-&gt;this_wall-&gt;grid;
187         if (grid != NULL) 
188         {
189           for (u_int tile_idx = 0; tile_idx &lt; grid-&gt;n_tiles; tile_idx++) 
190           {
191             if (grid-&gt;sm_list[tile_idx]) 
192             {
193               struct surface_molecule *sm = grid-&gt;sm_list[tile_idx]-&gt;sm;
194               if ((sm-&gt;properties != NULL) &amp;&amp; (sm-&gt;t &gt; world-&gt;current_iterations)) 
195               {
196                 for (int i_reactions_unds=0; i_reactions_unds&lt;n_reactions_unds; i_reactions_unds++)
197                 {
198                   if (sm-&gt;properties-&gt;species_id == reactions_unds[i_reactions_unds]-&gt;players[0]-&gt;species_id)
199                   {
200                     for (struct storage_list *local = world-&gt;storage_head; local != NULL; local = local-&gt;next) 
201                     {
202                       sm-&gt;flags |= ACT_CHANGE;
203                       sm-&gt;t2 = 0.0;
204                       schedule_reschedule(local-&gt;store-&gt;timer, sm, world-&gt;current_iterations);
205                     }
206                   }
207                 } 
208               }
209             }
210           }
211         }
212       }
213     }
214   }
215   free(reactions_ud);
216   free(reactions_undv);
217   free(reactions_unds);
218   return MCELL_SUCCESS;
219 }
220 MCELL_STATUS
221 mcell_modify_rate_constant(struct volume *world, char *name, double rate_constant) {
222   struct sym_table_head *rxpn_sym_table = world-&gt;rxpn_sym_table;
223   struct sym_entry *sym = retrieve_sym(name, rxpn_sym_table);
224   if (sym == NULL) 
225   {
226     return MCELL_FAIL;
227   }
228   else 
229   {
230     struct rxn_pathname *rxpn = (struct rxn_pathname *)sym-&gt;value;
231     struct rxn *reaction = rxpn-&gt;rx;  
232     int j = rxpn-&gt;path_num;
233     double p = rate_constant * reaction-&gt;pb_factor;
234     double delta_prob;
235     if (j == 0)
236       delta_prob = p - reaction-&gt;cum_probs[0];
237     else
238       delta_prob = p - (reaction-&gt;cum_probs[j] - reaction-&gt;cum_probs[j - 1]);
239     for (int k = j; k &lt; reaction-&gt;n_pathways; k++) 
240     {
241       reaction-&gt;cum_probs[k] += delta_prob;
242     }
243     reaction-&gt;max_fixed_p += delta_prob;
244     reaction-&gt;min_noreaction_p += delta_prob;
245     int can_diffuse = distinguishable(reaction-&gt;players[0]-&gt;D, 0, EPS_C);
246     if (reaction-&gt;n_reactants == 1 &amp;&amp; can_diffuse) 
247     {
248       for (struct storage_list *local = world-&gt;storage_head; local != NULL; local = local-&gt;next) 
249       {
250         struct abstract_element *head_molecule = local-&gt;store-&gt;timer-&gt;current;
251         while (local-&gt;store-&gt;timer-&gt;current != NULL) 
252         {
253           struct abstract_molecule *am = (struct abstract_molecule *)schedule_peak(local-&gt;store-&gt;timer);
254           if ((am-&gt;properties != NULL) &amp;&amp; (am-&gt;properties-&gt;species_id == reaction-&gt;players[0]-&gt;species_id)) 
255           {
256             am-&gt;t2 = 0.0;
257           am-&gt;flags |= ACT_CHANGE;
258           }
259         }
260         local-&gt;store-&gt;timer-&gt;current = head_molecule;
261       }
262     }
263     if (((!can_diffuse) &amp;&amp; (reaction-&gt;n_reactants == 1)) || 
264       ((!can_diffuse) &amp;&amp; (reaction-&gt;n_reactants == 2) &amp;&amp; (reaction-&gt;players[1]-&gt;flags == IS_SURFACE))) 
265     {
266       for (struct storage_list *local = world-&gt;storage_head; local != NULL; local = local-&gt;next) 
267       {
268         int n_subvols = world-&gt;n_subvols;
269         for (int i = 0; i &lt; n_subvols; i++) 
270         {
271           struct subvolume *sv = &amp;(world-&gt;subvol[i]);
272           if ((reaction-&gt;players[0]-&gt;flags &amp; NOT_FREE) != 0) 
273           {
274             for (struct wall_list *wl = sv-&gt;wall_head; wl != NULL; wl = wl-&gt;next) 
275             {
276               struct surface_grid *grid = wl-&gt;this_wall-&gt;grid;
277               if (grid != NULL) 
278               {
279                 for (u_int tile_idx = 0; tile_idx &lt; grid-&gt;n_tiles; tile_idx++) 
280                 {
281                   if (grid-&gt;sm_list[tile_idx]) 
282                   {
283                     struct surface_molecule *sm = grid-&gt;sm_list[tile_idx]-&gt;sm;
284                     if ((sm-&gt;properties != NULL) &amp;&amp; 
285                       (sm-&gt;properties-&gt;species_id == reaction-&gt;players[0]-&gt;species_id) &amp;&amp;
286                       (sm-&gt;t &gt; world-&gt;current_iterations)) 
287                     {
288                       sm-&gt;flags |= ACT_CHANGE;
289                       sm-&gt;t2 = 0.0;
290                       schedule_reschedule(local-&gt;store-&gt;timer, sm, world-&gt;current_iterations);
291                     }
292                   }
293                 } 
294               }
295             }   
296           }
297           else 
298           {
299             for (struct per_species_list *psl = sv-&gt;species_head; psl != NULL; psl = psl-&gt;next) 
300             {
301               if (psl-&gt;properties == NULL) 
302               {
303                 continue;
304               }
305               for (struct volume_molecule *vm = psl-&gt;head; vm != NULL; vm = vm-&gt;next_v) 
306               {
307                 if ((vm-&gt;properties != NULL) &amp;&amp; 
308                   (vm-&gt;properties-&gt;species_id == reaction-&gt;players[0]-&gt;species_id)  &amp;&amp;
309                   (vm-&gt;t &gt; world-&gt;current_iterations)) 
310                 { 
311                   vm-&gt;flags |= ACT_CHANGE;
312                   vm-&gt;t2 = 0.0;
313                   schedule_reschedule(local-&gt;store-&gt;timer, vm, world-&gt;current_iterations);
314                 }
315               }
316             }
317           }
318         }
319       }
320     }
321   }
322   return MCELL_SUCCESS;
323 }
324 MCELL_STATUS
325 mcell_add_reaction_simplified(
326     struct volume *state, 
327     struct mcell_species *reactants,
328     struct reaction_arrow *arrow,
329     struct mcell_species *surfs,
330     struct mcell_species *products,
331     struct reaction_rates *rates,
332     struct sym_entry *pathname) {
333   mcell_add_reaction(state-&gt;notify, &amp;state-&gt;r_step_release,
334                      state-&gt;rxn_sym_table, state-&gt;radial_subdivisions,
335                      state-&gt;vacancy_search_dist2, reactants, arrow, surfs,
336                      products, pathname, rates, NULL, NULL);
337   return MCELL_SUCCESS;
338 }
339 MCELL_STATUS
340 mcell_add_reaction(struct notifications *notify,
341                    double **r_step_release,
342                    struct sym_table_head *rxn_sym_table,
343                    u_int radial_subdivisions,
344                    double vacancy_search_dist2,
345                    struct mcell_species *reactants,
346                    struct reaction_arrow *react_arrow,
347                    struct mcell_species *surf_class,
348                    struct mcell_species *products, struct sym_entry *pathname,
349                    struct reaction_rates *rates,
350                    const char *forward_rate_filename,
351                    const char *backward_rate_filename) {
352   char *rx_name;
353   struct sym_entry *symp;
354   int bidirectional = 0;
355   int num_surf_products = 0;
356   struct rxn *rxnp;
357   struct pathway *pathp = (struct pathway *)CHECKED_MALLOC_STRUCT(
358       struct pathway, "reaction pathway");
359   if (pathp == NULL) {
360     return MCELL_FAIL;
361   }
362   memset(pathp, 0, sizeof(struct pathway));
363   int num_vol_mols = 0;
364   int num_surface_mols = 0;
365   int all_3d = 1;
366   int reactant_idx = 0;
367   int oriented_count = 0;
368   int surface = -1;
369   int catalytic = -1;
370   unsigned int num_surfaces = 0;
371   if (react_arrow-&gt;flags &amp; ARROW_BIDIRECTIONAL) {
372     bidirectional = 1;
373   }
374   if (extract_reactants(pathp, reactants, &amp;reactant_idx, &amp;num_vol_mols,
375                         &amp;num_surface_mols, &amp;all_3d,
376                         &amp;oriented_count) == MCELL_FAIL) {
377     free(pathp);
378     return MCELL_FAIL;
379   }
380   if (react_arrow-&gt;flags &amp; ARROW_CATALYTIC) {
381     if (extract_catalytic_arrow(pathp, react_arrow, &amp;reactant_idx,
382                                 &amp;num_vol_mols, &amp;num_surface_mols, &amp;all_3d,
383                                 &amp;oriented_count) == MCELL_FAIL) {
384       free(pathp);
385       return MCELL_FAIL;
386     }
387     catalytic = reactant_idx - 1;
388   }
389   if (surf_class-&gt;mol_type != NULL) {
390     if (extract_surface(pathp, surf_class, &amp;reactant_idx, &amp;num_surfaces,
391                         &amp;oriented_count) == MCELL_FAIL) {
392       free(pathp);
393       return MCELL_FAIL;
394     }
395     surface = reactant_idx - 1;
396     all_3d = 0;
397   }
398   rx_name = create_rx_name(pathp);
399   if (rx_name == NULL) {
400     free(pathp);
401     mcell_error("Out of memory while creating reaction.");
402     return MCELL_FAIL;
403   }
404   if ((symp = retrieve_sym(rx_name, rxn_sym_table)) != NULL) {
405   } else if ((symp = store_sym(rx_name, RX, rxn_sym_table, NULL)) ==
406              NULL) {
407     free(pathp);
408     free(rx_name);
409     mcell_error("Out of memory while creating reaction.");
410   }
411   free(rx_name);
412   rxnp = (struct rxn *)symp-&gt;value;
413   rxnp-&gt;n_reactants = reactant_idx;
414   ++rxnp-&gt;n_pathways;
415   if (check_surface_specs(notify, rxnp-&gt;n_reactants, num_surfaces,
416                           num_vol_mols, all_3d, oriented_count) == MCELL_FAIL) {
417     free(pathp);
418     return MCELL_FAIL;
419   }
420   if (catalytic &gt;= 0) {
421     if (add_catalytic_species_to_products(pathp, catalytic, bidirectional,
422                                           all_3d) == MCELL_FAIL) {
423       free(pathp);
424       return MCELL_FAIL;
425     }
426   }
427   if (extract_products(notify, pathp, products, &amp;num_surf_products,
428                        bidirectional, all_3d) == MCELL_FAIL) {
429     free(pathp);
430     return MCELL_FAIL;
431   }
432   if (pathname != NULL) {
433     struct rxn_pathname *rxpnp = (struct rxn_pathname *)pathname-&gt;value;
434     rxpnp-&gt;rx = rxnp;
435     pathp-&gt;pathname = rxpnp;
436   }
437   if (pathp-&gt;product_head != NULL) {
438     pathp-&gt;prod_signature = create_prod_signature(&amp;pathp-&gt;product_head);
439     if (pathp-&gt;prod_signature == NULL) {
440       free(pathp);
441       mcell_error(
442           "Error creating 'prod_signature' field for the reaction pathway.");
443       return MCELL_FAIL;
444     }
445   } else
446     pathp-&gt;prod_signature = NULL;
447   switch (rates-&gt;forward_rate.rate_type) {
448   case RATE_UNSET:
449     mcell_error_raw("File %s, Line %d: Internal error: Rate is not set",
450                     __FILE__, __LINE__);
451     free(pathp);
452     return MCELL_FAIL;
453   case RATE_CONSTANT:
454     pathp-&gt;km = rates-&gt;forward_rate.v.rate_constant;
455     pathp-&gt;km_filename = NULL;
456     break;
457   case RATE_FILE:
458     pathp-&gt;km = 0.0;
459     pathp-&gt;km_filename = (char *)forward_rate_filename;
460     free(rates-&gt;forward_rate.v.rate_file);
461     rates-&gt;forward_rate.v.rate_file = NULL;
462     break;
463   default:
464     UNHANDLED_CASE(rates-&gt;forward_rate.rate_type);
465   }
466   if (rates-&gt;forward_rate.rate_type == RATE_FILE) {
467     struct pathway *tpp;
468     if (rxnp-&gt;pathway_head == NULL) {
469       rxnp-&gt;pathway_head = pathp;
470       pathp-&gt;next = NULL;
471     } else     {
472       for (tpp = rxnp-&gt;pathway_head;
473            tpp-&gt;next != NULL &amp;&amp; tpp-&gt;next-&gt;km_filename == NULL;
474            tpp = tpp-&gt;next) {
475       }
476       pathp-&gt;next = tpp-&gt;next;
477       tpp-&gt;next = pathp;
478     }
479   } else {
480     pathp-&gt;next = rxnp-&gt;pathway_head;
481     rxnp-&gt;pathway_head = pathp;
482   }
483   if (*r_step_release == NULL &amp;&amp; all_3d &amp;&amp; pathp-&gt;product_head != NULL) {
484     *r_step_release = init_r_step_3d_release(radial_subdivisions);
485     if (*r_step_release == NULL) {
486       free(pathp);
487       mcell_error("Out of memory building r_step array.");
488       return MCELL_FAIL;
489     }
490   }
491   if ((!distinguishable(vacancy_search_dist2, 0, EPS_C)) &amp;&amp;
492       (num_surf_products &gt; num_surface_mols)) {
493     if (num_surface_mols == 0 &amp;&amp; num_vol_mols == 1 &amp;&amp; num_surf_products == 1) {
494     } else {
495       free(pathp);
496       mcell_error("number of surface products exceeds number of surface "
497                   "reactants, but VACANCY_SEARCH_DISTANCE is not specified or "
498                   "set to zero.");
499       return MCELL_FAIL;
500     }
501   }
502   if (rates-&gt;backward_rate.rate_type != RATE_UNSET &amp;&amp; !bidirectional) {
503     free(pathp);
504     mcell_error("reverse rate specified but the reaction isn't reversible.");
505     return MCELL_FAIL;
506   }
507   if (bidirectional) {
508     if (rates-&gt;backward_rate.rate_type == RATE_UNSET) {
509       free(pathp);
510       mcell_error("reversible reaction indicated but no reverse rate "
511                   "supplied.");
512       return MCELL_FAIL;
513     }
514     if (surface != -1 &amp;&amp; surface != catalytic) {
515       struct product *prodp;
516       prodp = (struct product *)CHECKED_MALLOC_STRUCT(struct product,
517                                                       "reaction product");
518       if (prodp == NULL) {
519         free(pathp);
520         return MCELL_FAIL;
521       }
522       switch (surface) {
523       case 1:
524         prodp-&gt;prod = pathp-&gt;reactant2;
525         prodp-&gt;orientation = pathp-&gt;orientation2;
526         break;
527       case 2:
528         prodp-&gt;prod = pathp-&gt;reactant3;
529         prodp-&gt;orientation = pathp-&gt;orientation3;
530         break;
531       case 0:
532       default:
533         mcell_internal_error(
534             "Surface appears in invalid reactant slot in reaction (%d).",
535             surface);
536       }
537       prodp-&gt;next = pathp-&gt;product_head;
538       pathp-&gt;product_head = prodp;
539     }
540     if (invert_current_reaction_pathway(
541         rxn_sym_table, vacancy_search_dist2, pathp,
542         &amp;rates-&gt;backward_rate, backward_rate_filename)) {
543       free(pathp);
544       return MCELL_FAIL;
545     }
546   }
547   rxnp-&gt;get_reactant_diffusion = rxn_get_standard_diffusion;
548   return MCELL_SUCCESS;
549 }
550 MCELL_STATUS
551 mcell_add_surface_reaction(struct sym_table_head *rxn_sym_table,
552                            int reaction_type, struct species *surface_class,
553                            struct sym_entry *reactant_sym, short orient) {
554   struct species *reactant = (struct species *)reactant_sym-&gt;value;
555   if (reactant-&gt;flags == IS_SURFACE) {
556     return MCELL_FAIL;
557   }
558   char *rx_name =
559       concat_rx_name(surface_class-&gt;sym-&gt;name, reactant_sym-&gt;name);
560   if (rx_name == NULL) {
561     return MCELL_FAIL;
562   }
563   struct sym_entry *reaction_sym;
564   if ((reaction_sym = retrieve_sym(rx_name, rxn_sym_table)) != NULL) {
565   } else if ((reaction_sym =
566                   store_sym(rx_name, RX, rxn_sym_table, NULL)) == NULL) {
567     free(rx_name);
568     return MCELL_FAIL;
569   }
570   free(rx_name);
571   struct pathway *pathp = (struct pathway *)CHECKED_MALLOC_STRUCT(
572       struct pathway, "reaction pathway");
573   if (pathp == NULL)
574     return MCELL_FAIL;
575   memset(pathp, 0, sizeof(struct pathway));
576   struct rxn *rxnp = (struct rxn *)reaction_sym-&gt;value;
577   rxnp-&gt;n_reactants = 2;
578   ++rxnp-&gt;n_pathways;
579   pathp-&gt;pathname = NULL;
580   pathp-&gt;reactant1 = surface_class;
581   pathp-&gt;reactant2 = (struct species *)reactant_sym-&gt;value;
582   pathp-&gt;reactant3 = NULL;
583   pathp-&gt;km = GIGANTIC;
584   pathp-&gt;km_filename = NULL;
585   pathp-&gt;prod_signature = NULL;
586   pathp-&gt;flags = 0;
587   pathp-&gt;orientation1 = 1;
588   pathp-&gt;orientation3 = 0;
589   if (orient == 0) {
590     pathp-&gt;orientation2 = 0;
591   } else {
592     pathp-&gt;orientation2 = (orient &lt; 0) ? -1 : 1;
593   }
594   struct name_orient *no;
595   no = CHECKED_MALLOC_STRUCT(struct name_orient, "struct name_orient");
596   no-&gt;name = CHECKED_STRDUP(reactant-&gt;sym-&gt;name, "reactant name");
597   if (orient == 0) {
598     no-&gt;orient = 0;
599   } else {
600     no-&gt;orient = (orient &lt; 0) ? -1 : 1;
601   }
602   struct product *prodp;
603   switch (reaction_type) {
604   case RFLCT:
605     prodp = (struct product *)CHECKED_MALLOC_STRUCT(struct product,
606                                                     "reaction product");
607     if (prodp == NULL) {
608       free(no);
609       free(pathp);
610       return MCELL_FAIL;
611     }
612     pathp-&gt;flags |= PATHW_REFLEC;
613     prodp-&gt;prod = pathp-&gt;reactant2;
614     prodp-&gt;orientation = 1;
615     prodp-&gt;next = NULL;
616     pathp-&gt;product_head = prodp;
617     if (pathp-&gt;product_head != NULL) {
618       pathp-&gt;prod_signature = create_prod_signature(&amp;pathp-&gt;product_head);
619       if (pathp-&gt;prod_signature == NULL) {
620         free(no);
621         free(pathp);
622         return MCELL_FAIL;
623       }
624     }
625     if (surface_class-&gt;refl_mols == NULL) {
626       no-&gt;next = NULL;
627       surface_class-&gt;refl_mols = no;
628     } else {
629       no-&gt;next = surface_class-&gt;refl_mols;
630       surface_class-&gt;refl_mols = no;
631     }
632     break;
633   case TRANSP:
634     prodp = (struct product *)CHECKED_MALLOC_STRUCT(struct product,
635                                                     "reaction product");
636     if (prodp == NULL) {
637       free(no);
638       free(pathp);
639       return MCELL_FAIL;
640     }
641     pathp-&gt;flags |= PATHW_TRANSP;
642     prodp-&gt;prod = pathp-&gt;reactant2;
643     prodp-&gt;orientation = -1;
644     prodp-&gt;next = NULL;
645     pathp-&gt;product_head = prodp;
646     if (pathp-&gt;product_head != NULL) {
647       pathp-&gt;prod_signature = create_prod_signature(&amp;pathp-&gt;product_head);
648       if (pathp-&gt;prod_signature == NULL) {
649         free(no);
650         free(pathp);
651         return MCELL_FAIL;
652       }
653     }
654     if (surface_class-&gt;transp_mols == NULL) {
655       no-&gt;next = NULL;
656       surface_class-&gt;transp_mols = no;
657     } else {
658       no-&gt;next = surface_class-&gt;transp_mols;
659       surface_class-&gt;transp_mols = no;
660     }
661     break;
662   case SINK:
663     pathp-&gt;flags |= PATHW_ABSORP;
664     pathp-&gt;product_head = NULL;
665     if (surface_class-&gt;absorb_mols == NULL) {
666       no-&gt;next = NULL;
667       surface_class-&gt;absorb_mols = no;
668     } else {
669       no-&gt;next = surface_class-&gt;absorb_mols;
670       surface_class-&gt;absorb_mols = no;
671     }
672     break;
673   default:
674     free(no);
675     free(pathp);
676     return MCELL_FAIL;
677   }
678   pathp-&gt;next = rxnp-&gt;pathway_head;
679   rxnp-&gt;pathway_head = pathp;
680   rxnp-&gt;get_reactant_diffusion = rxn_get_standard_diffusion;
681   return MCELL_SUCCESS;
682 }
683 MCELL_STATUS
684 mcell_add_clamp(struct sym_table_head *rxn_sym_table,
685                               struct species *surface_class,
686                               struct sym_entry *mol_sym, short orient,
687                               int clamp_type,
688                               double clamp_value) {
689   struct rxn *rxnp;
690   struct pathway *pathp;
691   struct sym_entry *stp3;
692   struct species *specp = (struct species *)mol_sym-&gt;value;
693   struct name_orient *no;
694   if (specp-&gt;flags == IS_SURFACE) {
695     return MCELL_FAIL;
696   }
697   if (specp-&gt;flags &amp; ON_GRID) {
698     return MCELL_FAIL;
699   }
700   if (specp-&gt;flags &amp; NOT_FREE || specp-&gt;D &lt;= 0.0) {
701     return MCELL_FAIL;
702   }
703   if (clamp_value &lt; 0) {
704     return MCELL_FAIL;
705   }
706   char *rx_name = concat_rx_name(surface_class-&gt;sym-&gt;name, mol_sym-&gt;name);
707   if (rx_name == NULL) {
708     return MCELL_FAIL;
709   }
710   if ((stp3 = retrieve_sym(rx_name, rxn_sym_table)) != NULL) {
711   } else if ((stp3 = store_sym(rx_name, RX, rxn_sym_table, NULL)) ==
712              NULL) {
713     free(rx_name);
714     return MCELL_FAIL;
715   }
716   free(rx_name);
717   pathp = (struct pathway *)CHECKED_MALLOC_STRUCT(struct pathway,
718                                                   "reaction pathway");
719   if (pathp == NULL)
720     return MCELL_FAIL;
721   memset(pathp, 0, sizeof(struct pathway));
722   rxnp = (struct rxn *)stp3-&gt;value;
723   rxnp-&gt;n_reactants = 2;
724   ++rxnp-&gt;n_pathways;
725   pathp-&gt;pathname = NULL;
726   pathp-&gt;reactant1 = surface_class;
727   pathp-&gt;reactant2 = (struct species *)mol_sym-&gt;value;
728   pathp-&gt;reactant3 = NULL;
729   pathp-&gt;flags = 0;
730   pathp-&gt;km = clamp_value;
731   pathp-&gt;km_filename = NULL;
732   pathp-&gt;orientation1 = 1;
733   pathp-&gt;orientation3 = 0;
734   if (orient == 0) {
735     pathp-&gt;orientation2 = 0;
736   } else {
737     pathp-&gt;orientation2 = (orient &lt; 0) ? -1 : 1;
738   }
739   if (clamp_type == CLAMP_TYPE_CONC) {
740     pathp-&gt;flags |= PATHW_CLAMP_CONC;
741     pathp-&gt;product_head = NULL;
742     pathp-&gt;prod_signature = NULL;
743   }
744   else {
745     pathp-&gt;flags |= PATHW_CLAMP_FLUX | PATHW_REFLEC;
746     pathp-&gt;product_head = NULL;
747     pathp-&gt;prod_signature = NULL;
748 #if 0
749     struct product *prodp;
750     prodp = (struct product *)CHECKED_MALLOC_STRUCT(struct product,
751                                                     "reaction product");
752     if (prodp == NULL) {
753       free(pathp);
754       return MCELL_FAIL;
755     }
756     prodp-&gt;prod = pathp-&gt;reactant2;
757     prodp-&gt;orientation = pathp-&gt;orientation2;
758     prodp-&gt;next = NULL;
759     pathp-&gt;product_head = prodp;
760     if (pathp-&gt;product_head != NULL) {
761       pathp-&gt;prod_signature = create_prod_signature(&amp;pathp-&gt;product_head);
762       if (pathp-&gt;prod_signature == NULL) {
763         free(pathp);
764         return MCELL_FAIL;
765       }
766     }
767 #endif
768   }
769   no = CHECKED_MALLOC_STRUCT(struct name_orient, "struct name_orient");
770   no-&gt;name = CHECKED_STRDUP(mol_sym-&gt;name, "molecule name");
771   no-&gt;orient = pathp-&gt;orientation2;
772   if (surface_class-&gt;clamp_mols == NULL) {
773     no-&gt;next = NULL;
774     surface_class-&gt;clamp_mols = no;
775   } else {
776     no-&gt;next = surface_class-&gt;clamp_mols;
777     surface_class-&gt;clamp_mols = no;
778   }
779   rxnp-&gt;get_reactant_diffusion = rxn_get_standard_diffusion;
780   pathp-&gt;next = rxnp-&gt;pathway_head;
781   rxnp-&gt;pathway_head = pathp;
782   return MCELL_SUCCESS;
783 }
784 MCELL_STATUS
785 mcell_change_reaction_rate(MCELL_STATE *state, const char *reaction_name,
786                            double new_rate) {
787   if (new_rate &lt; 0.0) {
788     return MCELL_FAIL;
789   }
790   struct rxn *rx = NULL;
791   int path_id = 0;
792   if (get_rxn_by_name(state-&gt;reaction_hash, state-&gt;rx_hashsize, reaction_name,
793                       &amp;rx, &amp;path_id)) {
794     return MCELL_FAIL;
795   }
796   if (change_reaction_probability(
797       &amp;state-&gt;reaction_prob_limit_flag, state-&gt;notify, rx, path_id,
798       new_rate)) {
799     return MCELL_FAIL;
800   }
801   return MCELL_SUCCESS;
802 }
803 int init_reaction_info(struct rxn* rx){
804   struct pathway *path;
805   if (rx-&gt;n_pathways &gt; 0) {
806     rx-&gt;info = CHECKED_MALLOC_ARRAY(struct pathway_info, rx-&gt;n_pathways,
807                                     "reaction pathway info");
808     if (rx-&gt;info == NULL)
809       return 1;
810     path = rx-&gt;pathway_head;
811     for (int n_pathway = 0; path != NULL;
812          n_pathway++, path = path-&gt;next) {
813       rx-&gt;info[n_pathway].count = 0;
814       rx-&gt;info[n_pathway].pathname =
815           path-&gt;pathname;       if (path-&gt;pathname != NULL) {
816         rx-&gt;info[n_pathway].pathname-&gt;path_num = n_pathway;
817         rx-&gt;info[n_pathway].pathname-&gt;rx = rx;
818       }
819     }
820   } else   {
821     rx-&gt;info = CHECKED_MALLOC_STRUCT(struct pathway_info,
822                                      "reaction pathway info");
823     if (rx-&gt;info == NULL)
824       return 1;
825     rx-&gt;info[0].count = 0;
826     rx-&gt;info[0].pathname = rx-&gt;pathway_head-&gt;pathname;
827     if (rx-&gt;pathway_head-&gt;pathname != NULL) {
828       rx-&gt;info[0].pathname-&gt;path_num = 0;
829       rx-&gt;info[0].pathname-&gt;rx = rx;
830     }
831   }
832   return 0;
833 }
834 int init_reactions(MCELL_STATE *state) {
835   struct pathway *path;
836   struct product *prod = NULL;
837   short geom;
838   int num_rx = 0;
839   state-&gt;vacancy_search_dist2 *= state-&gt;r_length_unit;   state-&gt;vacancy_search_dist2 *= state-&gt;vacancy_search_dist2; 
840   if (state-&gt;rx_radius_3d &lt;= 0.0) {
841     state-&gt;rx_radius_3d = 1.0 / sqrt(MY_PI * state-&gt;grid_density);
842   }
843   state-&gt;tv_rxn_mem = create_mem(sizeof(struct t_func), 100);
844   if (state-&gt;tv_rxn_mem == NULL)
845     return 1;
846   for (int n_rxn_bin = 0; n_rxn_bin &lt; state-&gt;rxn_sym_table-&gt;n_bins;
847        n_rxn_bin++) {
848     for (struct sym_entry *sym = state-&gt;rxn_sym_table-&gt;entries[n_rxn_bin];
849          sym != NULL; sym = sym-&gt;next) {
850       struct rxn *reaction = (struct rxn *)sym-&gt;value;
851       reaction-&gt;next = NULL;
852       for (path = reaction-&gt;pathway_head; path != NULL; path = path-&gt;next) {
853         check_duplicate_special_reactions(path);
854         if (reaction-&gt;n_reactants &gt; 1) {
855           struct species *temp_sp;
856           if ((path-&gt;reactant1-&gt;flags &amp; IS_SURFACE) != 0) {
857             temp_sp = path-&gt;reactant1;
858             path-&gt;reactant1 = path-&gt;reactant2;
859             path-&gt;reactant2 = temp_sp;
860             geom = path-&gt;orientation1;
861             path-&gt;orientation1 = path-&gt;orientation2;
862             path-&gt;orientation2 = geom;
863           }
864           if (reaction-&gt;n_reactants &gt; 2) {
865             if ((path-&gt;reactant2-&gt;flags &amp; IS_SURFACE) != 0) {
866               temp_sp = path-&gt;reactant3;
867               path-&gt;reactant3 = path-&gt;reactant2;
868               path-&gt;reactant2 = temp_sp;
869               geom = path-&gt;orientation3;
870               path-&gt;orientation3 = path-&gt;orientation2;
871               path-&gt;orientation2 = geom;
872             }
873           }
874           alphabetize_pathway(path, reaction);
875         } 
876       } 
877       struct rxn *rx = split_reaction(reaction);
878       sym-&gt;value = (void *)rx;
879       while (rx != NULL) {
880         double pb_factor = 0.0;
881         check_reaction_for_duplicate_pathways(&amp;rx-&gt;pathway_head);
882         num_rx++;
883         rx-&gt;product_idx = CHECKED_MALLOC_ARRAY(u_int, rx-&gt;n_pathways + 1,
884                                                "reaction product index array");
885         rx-&gt;cum_probs = CHECKED_MALLOC_ARRAY(
886             double, rx-&gt;n_pathways, "reaction cumulative probabilities array");
887         if (rx-&gt;product_idx == NULL || rx-&gt;cum_probs == NULL)
888           return 1;
889         int n_prob_t_rxns = 0;         path = rx-&gt;pathway_head;
890         for (int n_pathway = 0; path != NULL; n_pathway++, path = path-&gt;next) {
891           rx-&gt;product_idx[n_pathway] = 0;
892           if ( path-&gt;reactant2 != NULL
893                &amp;&amp; (path-&gt;reactant2-&gt;flags &amp; IS_SURFACE) != 0
894                &amp;&amp; path-&gt;km &gt;= 0.0
895                &amp;&amp; ( ( path-&gt;product_head == NULL &amp;&amp; (path-&gt;flags &amp; PATHW_CLAMP_CONC) != 0 )
896                   ||
897                   ( path-&gt;product_head == NULL &amp;&amp; (path-&gt;flags &amp; PATHW_CLAMP_FLUX) != 0 ) )
898              ) {
899             struct clamp_data *cdp;
900             if (n_pathway != 0 || path-&gt;next != NULL)
901               mcell_warn("Mixing surface modes with other surface reactions.  "
902                          "Please don't.");
903             if (path-&gt;km &gt; 0) {
904               cdp = CHECKED_MALLOC_STRUCT(struct clamp_data,
905                                           "clamp data");
906               if (cdp == NULL)
907                 return 1;
908               cdp-&gt;surf_class = path-&gt;reactant2;
909               cdp-&gt;mol = path-&gt;reactant1;
910               cdp-&gt;clamp_value = path-&gt;km;
911               if ((path-&gt;flags &amp; PATHW_CLAMP_CONC) != 0) {
912                 cdp-&gt;clamp_type = CLAMP_TYPE_CONC;
913               }
914               else {
915                 cdp-&gt;clamp_type = CLAMP_TYPE_FLUX;
916               }
917               if (path-&gt;orientation1 * path-&gt;orientation2 == 0) {
918                 cdp-&gt;orient = 0;
919               } else {
920                 cdp-&gt;orient =
921                     (path-&gt;orientation1 == path-&gt;orientation2) ? 1 : -1;
922               }
923               cdp-&gt;sides = NULL;
924               cdp-&gt;next_mol = NULL;
925               cdp-&gt;next_obj = NULL;
926               cdp-&gt;objp = NULL;
927               cdp-&gt;n_sides = 0;
928               cdp-&gt;side_idx = NULL;
929               cdp-&gt;cum_area = NULL;
930               cdp-&gt;scaling_factor = 0.0;
931               cdp-&gt;next = state-&gt;clamp_list;
932               state-&gt;clamp_list = cdp;
933             }
934             path-&gt;clamp_concentration = path-&gt;km;             path-&gt;km = GIGANTIC;
935             if ((path-&gt;flags &amp; PATHW_CLAMP_FLUX) != 0) {
936               rx-&gt;n_pathways = RX_REFLEC;
937               if (path-&gt;reactant2 != NULL &amp;&amp;
938                   (path-&gt;reactant2-&gt;flags &amp; IS_SURFACE) &amp;&amp;
939                   (path-&gt;reactant1-&gt;flags &amp; ON_GRID)) {
940                 path-&gt;reactant1-&gt;flags |= CAN_REGION_BORDER;
941               }
942             }
943           } else if ((path-&gt;flags &amp; PATHW_TRANSP) != 0) {
944             rx-&gt;n_pathways = RX_TRANSP;
945             if (path-&gt;reactant2 != NULL &amp;&amp;
946                 (path-&gt;reactant2-&gt;flags &amp; IS_SURFACE) &amp;&amp;
947                 (path-&gt;reactant1-&gt;flags &amp; ON_GRID)) {
948               path-&gt;reactant1-&gt;flags |= CAN_REGION_BORDER;
949             }
950           } else if ((path-&gt;flags &amp; PATHW_REFLEC) != 0) {
951             rx-&gt;n_pathways = RX_REFLEC;
952             if (path-&gt;reactant2 != NULL &amp;&amp;
953                 (path-&gt;reactant2-&gt;flags &amp; IS_SURFACE) &amp;&amp;
954                 (path-&gt;reactant1-&gt;flags &amp; ON_GRID)) {
955               path-&gt;reactant1-&gt;flags |= CAN_REGION_BORDER;
956             }
957           } else if (path-&gt;reactant2 != NULL &amp;&amp;
958                      (path-&gt;reactant2-&gt;flags &amp; IS_SURFACE) &amp;&amp;
959                      (path-&gt;reactant1-&gt;flags &amp; ON_GRID) &amp;&amp;
960                      (path-&gt;product_head == NULL) &amp;&amp;
961                      (path-&gt;flags &amp; PATHW_ABSORP)) {
962             rx-&gt;n_pathways = RX_ABSORB_REGION_BORDER;
963             path-&gt;reactant1-&gt;flags |= CAN_REGION_BORDER;
964           } else if ((strcmp(path-&gt;reactant1-&gt;sym-&gt;name,
965                              "ALL_SURFACE_MOLECULES") == 0)) {
966             if (path-&gt;reactant2 != NULL &amp;&amp;
967                 (path-&gt;reactant2-&gt;flags &amp; IS_SURFACE) &amp;&amp;
968                 (path-&gt;product_head == NULL) &amp;&amp; (path-&gt;flags &amp; PATHW_ABSORP)) {
969               rx-&gt;n_pathways = RX_ABSORB_REGION_BORDER;
970               path-&gt;reactant1-&gt;flags |= CAN_REGION_BORDER;
971             }
972           }
973           if (path-&gt;km_filename == NULL)
974             rx-&gt;cum_probs[n_pathway] = path-&gt;km;
975           else {
976             rx-&gt;cum_probs[n_pathway] = 0;
977             n_prob_t_rxns++;
978           }
979           int recycled1 = 0;
980           int recycled2 = 0;
981           int recycled3 = 0;
982           for (prod = path-&gt;product_head; prod != NULL; prod = prod-&gt;next) {
983             if (recycled1 == 0 &amp;&amp; prod-&gt;prod == path-&gt;reactant1)
984               recycled1 = 1;
985             else if (recycled2 == 0 &amp;&amp; prod-&gt;prod == path-&gt;reactant2)
986               recycled2 = 1;
987             else if (recycled3 == 0 &amp;&amp; prod-&gt;prod == path-&gt;reactant3)
988               recycled3 = 1;
989             else
990               rx-&gt;product_idx[n_pathway]++;
991           }
992         } 
993         int num_players = rx-&gt;n_reactants;
994         int kk = rx-&gt;n_pathways;
995         if (kk &lt;= RX_SPECIAL)
996           kk = 1;
997         for (int n_pathway = 0; n_pathway &lt; kk; n_pathway++) {
998           int k = rx-&gt;product_idx[n_pathway] + rx-&gt;n_reactants;
999           rx-&gt;product_idx[n_pathway] = num_players;
1000           num_players += k;
1001         }
1002         rx-&gt;product_idx[kk] = num_players;
1003         rx-&gt;players = CHECKED_MALLOC_ARRAY(struct species *, num_players,
1004                                            "reaction players array");
1005         rx-&gt;geometries = CHECKED_MALLOC_ARRAY(short, num_players,
1006                                               "reaction geometries array");
1007         if (rx-&gt;players == NULL || rx-&gt;geometries == NULL)
1008           return 1;
1009         if (n_prob_t_rxns &gt; 0) {
1010           path = rx-&gt;pathway_head;
1011           for (int n_pathway = 0; path != NULL;
1012                n_pathway++, path = path-&gt;next) {
1013             if (path-&gt;km_filename != NULL) {
1014               if (load_rate_file(state, rx, path-&gt;km_filename, n_pathway))
1015                 mcell_error("Failed to load rates from file '%s'.",
1016                             path-&gt;km_filename);
1017             }
1018             free(path-&gt;km_filename);
1019             path-&gt;km_filename = NULL;
1020           }
1021           rx-&gt;prob_t = (struct t_func *)ae_list_sort(
1022               (struct abstract_element *)rx-&gt;prob_t);
1023           while (rx-&gt;prob_t != NULL &amp;&amp; rx-&gt;prob_t-&gt;time &lt;= 0.0) {
1024             rx-&gt;cum_probs[rx-&gt;prob_t-&gt;path] = rx-&gt;prob_t-&gt;value;
1025             rx-&gt;prob_t = rx-&gt;prob_t-&gt;next;
1026           }
1027         } 
1028         path = rx-&gt;pathway_head;
1029         rx-&gt;players[0] = path-&gt;reactant1;
1030         rx-&gt;geometries[0] = path-&gt;orientation1;
1031         if (rx-&gt;n_reactants &gt; 1) {
1032           rx-&gt;players[1] = path-&gt;reactant2;
1033           rx-&gt;geometries[1] = path-&gt;orientation2;
1034           if (rx-&gt;n_reactants &gt; 2) {
1035             rx-&gt;players[2] = path-&gt;reactant3;
1036             rx-&gt;geometries[2] = path-&gt;orientation3;
1037           }
1038         }
1039         initialize_rxn_diffusion_functions(rx);
1040         rx-&gt;external_reaction_data = NULL;
1041         rx-&gt;product_graph_data = NULL;
1042         rx-&gt;reactant_graph_data = NULL;
1043         path = rx-&gt;pathway_head;
1044         int max_num_surf_products = set_product_geometries(path, rx, prod);
1045         pb_factor = compute_pb_factor(
1046             state-&gt;time_unit, state-&gt;length_unit, state-&gt;grid_density,
1047             state-&gt;rx_radius_3d,
1048             &amp;state-&gt;rxn_flags,
1049             &amp;state-&gt;create_shared_walls_info_flag,
1050             rx, max_num_surf_products);
1051         rx-&gt;pb_factor = pb_factor;
1052         path = rx-&gt;pathway_head;
1053         if (scale_rxn_probabilities(&amp;state-&gt;reaction_prob_limit_flag, state-&gt;notify,
1054                                 path, rx, pb_factor))
1055           return 1;
1056         if (n_prob_t_rxns &gt; 0) {
1057           for (struct t_func *tp = rx-&gt;prob_t; tp != NULL; tp = tp-&gt;next)
1058             tp-&gt;value *= pb_factor;
1059         }
1060         if(init_reaction_info(rx) != 0)
1061           return MCELL_FAIL;
1062         for (int n_pathway = 1; n_pathway &lt; rx-&gt;n_pathways; ++n_pathway)
1063           rx-&gt;cum_probs[n_pathway] += rx-&gt;cum_probs[n_pathway - 1];
1064         if (rx-&gt;n_pathways &gt; 0)
1065           rx-&gt;min_noreaction_p = rx-&gt;max_fixed_p =
1066               rx-&gt;cum_probs[rx-&gt;n_pathways - 1];
1067         else
1068           rx-&gt;min_noreaction_p = rx-&gt;max_fixed_p = 1.0;
1069         rx = rx-&gt;next;
1070       }
1071     }
1072   }
1073   if (state-&gt;rxn_flags.surf_surf_reaction_flag ||
1074       state-&gt;rxn_flags.surf_surf_surf_reaction_flag) {
1075     if (state-&gt;notify-&gt;reaction_probabilities == NOTIFY_FULL)
1076       mcell_log("For reaction between two (or three) surface molecules the "
1077                 "upper probability limit is given. The effective reaction "
1078                 "probability will be recalculated dynamically during "
1079                 "simulation.");
1080   }
1081   if (build_reaction_hash_table(&amp;state-&gt;reaction_hash, &amp;state-&gt;n_reactions,
1082                                 state-&gt;rxn_sym_table, &amp;state-&gt;rx_hashsize,
1083                                 num_rx))
1084     return 1;
1085   state-&gt;rx_radius_3d *= state-&gt;r_length_unit; 
1086   for (int n_rxn_bin = 0; n_rxn_bin &lt; state-&gt;rx_hashsize; n_rxn_bin++) {
1087     for (struct rxn *this_rx = state-&gt;reaction_hash[n_rxn_bin]; this_rx != NULL;
1088          this_rx = this_rx-&gt;next) {
1089       set_reaction_player_flags(this_rx);
1090     }
1091   }
1092 #if 0
1093   for (int n_rxn_bin = 0; n_rxn_bin &lt; state-&gt;rx_hashsize; n_rxn_bin++) {
1094     for (struct rxn *this_rx = state-&gt;reaction_hash[n_rxn_bin]; this_rx != NULL;
1095          this_rx = this_rx-&gt;next) {
1096       path = this_rx-&gt;pathway_head;
1097       struct pathway *next_path = path;
1098       while (next_path != NULL) {
1099         next_path = path-&gt;next;
1100         if (path-&gt;prod_signature != NULL) {
1101           free(path-&gt;prod_signature);
1102         }
1103         struct product *dead_prod = path-&gt;product_head;
1104         struct product *nxt = dead_prod;
1105         while (nxt != NULL) {
1106           nxt = dead_prod-&gt;next;
1107           free(dead_prod);
1108           dead_prod = nxt;
1109         }
1110         free(path);
1111         path = next_path;
1112       }
1113       this_rx-&gt;pathway_head = NULL;
1114     }
1115   }
1116 #endif
1117   add_surface_reaction_flags(state-&gt;mol_sym_table, state-&gt;all_mols, state-&gt;all_surface_mols,
1118                              state-&gt;all_volume_mols);
1119   if (state-&gt;notify-&gt;reaction_probabilities == NOTIFY_FULL)
1120     mcell_log_raw("\n");
1121   return 0;
1122 }
1123 MCELL_STATUS
1124 extract_reactants(struct pathway *pathp, struct mcell_species *reactants,
1125                   int *num_reactants, int *num_vol_mols, int *num_surface_mols,
1126                   int *all_3d, int *oriented_count) {
1127   int reactant_idx = 0;
1128   struct mcell_species *current_reactant;
1129   for (current_reactant = reactants;
1130        reactant_idx &lt; 3 &amp;&amp; current_reactant != NULL;
1131        ++reactant_idx, current_reactant = current_reactant-&gt;next) {
1132     short orient = current_reactant-&gt;orient_set ? current_reactant-&gt;orient : 0;
1133     struct species *reactant_species =
1134         (struct species *)current_reactant-&gt;mol_type-&gt;value;
1135     if (current_reactant-&gt;orient_set) {
1136       ++(*oriented_count);
1137     }
1138     if (reactant_species-&gt;flags &amp; NOT_FREE) {
1139       *all_3d = 0;
1140       if (reactant_species-&gt;flags &amp; ON_GRID) {
1141         ++(*num_surface_mols);
1142       }
1143     } else {
1144       ++(*num_vol_mols);
1145 <a name="0"></a>    }
1146 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    switch (reactant_idx) {
1147     case 0:
1148       pathp-&gt;reactant1 = reactant_species;
1149       pathp-&gt;orientation1 = orient;
1150       break;
1151     case 1:
1152       pathp-&gt;reactant2 = reactant_species;
1153       pathp-&gt;orientation2 = orient;
1154       break;
1155     case 2:
1156       pathp-&gt;reactant3 = reactant_species;
1157       pathp-&gt;orientation3 = orient;
1158       break;</b></font>
1159     default:
1160       UNHANDLED_CASE(reactant_idx);
1161     }
1162   }
1163   *num_reactants = reactant_idx;
1164   if (current_reactant != NULL) {
1165     return MCELL_FAIL;
1166   } else {
1167     return MCELL_SUCCESS;
1168   }
1169 }
1170 MCELL_STATUS
1171 extract_catalytic_arrow(struct pathway *pathp,
1172                         struct reaction_arrow *react_arrow, int *reactant_idx,
1173                         int *num_vol_mols, int *num_surface_mols, int *all_3d,
1174                         int *oriented_count) {
1175   struct species *catalyst_species =
1176       (struct species *)react_arrow-&gt;catalyst.mol_type-&gt;value;
1177   short orient =
1178       react_arrow-&gt;catalyst.orient_set ? react_arrow-&gt;catalyst.orient : 0;
1179   if (catalyst_species-&gt;flags &amp; IS_SURFACE) {
1180      mcell_error("a surface class may not appear inside a catalytic arrow");
1181     return MCELL_FAIL;
1182   }
1183   if (react_arrow-&gt;catalyst.orient_set) {
1184     ++(*oriented_count);
1185   }
1186   if (catalyst_species-&gt;flags &amp; NOT_FREE) {
1187     *all_3d = 0;
1188     if (catalyst_species-&gt;flags &amp; ON_GRID) {
1189       ++(*num_surface_mols);
1190     }
1191   } else {
1192     ++(*num_vol_mols);
1193   }
1194   switch (*reactant_idx) {
1195   case 1:
1196     pathp-&gt;reactant2 = (struct species *)react_arrow-&gt;catalyst.mol_type-&gt;value;
1197     pathp-&gt;orientation2 = orient;
1198     break;
1199   case 2:
1200     pathp-&gt;reactant3 = (struct species *)react_arrow-&gt;catalyst.mol_type-&gt;value;
1201     pathp-&gt;orientation3 = orient;
1202     break;
1203   case 0:
1204   default:
1205     return MCELL_FAIL;
1206   }
1207   ++(*reactant_idx);
1208   return MCELL_SUCCESS;
1209 }
1210 MCELL_STATUS
1211 extract_surface(struct pathway *path, struct mcell_species *surf_class,
1212                 int *num_reactants, unsigned int *num_surfaces,
1213                 int *oriented_count) {
1214   short orient = surf_class-&gt;orient_set ? surf_class-&gt;orient : 0;
1215   if (surf_class-&gt;orient_set) {
1216     (*oriented_count)++;
1217   }
1218   switch (*num_reactants) {
1219   case 0:
1220     return MCELL_FAIL;
1221   case 1:
1222     path-&gt;reactant2 = (struct species *)surf_class-&gt;mol_type-&gt;value;
1223     path-&gt;orientation2 = orient;
1224     break;
1225   case 2:
1226     path-&gt;reactant3 = (struct species *)surf_class-&gt;mol_type-&gt;value;
1227     path-&gt;orientation3 = orient;
1228     break;
1229   default:
1230     return MCELL_FAIL;
1231   }
1232   (*num_reactants)++;
1233   (*num_surfaces)++;
1234   return MCELL_SUCCESS;
1235 }
1236 MCELL_STATUS
1237 check_surface_specs(struct notifications *notify, int num_reactants,
1238                     int num_surfaces, int num_vol_mols, int all_3d,
1239                     int oriented_count) {
1240   if (num_surfaces &gt; 1) {
1241     mcell_internal_error(
1242         "Too many surfaces--reactions can take place on at most one surface.");
1243     return MCELL_FAIL;
1244   }
1245   if (num_surfaces == num_reactants) {
1246     mcell_error("Reactants cannot consist entirely of surfaces.  Use a surface "
1247                 "release site instead!");
1248     return MCELL_FAIL;
1249   }
1250   if ((num_vol_mols == 2) &amp;&amp; (num_surfaces == 1)) {
1251     mcell_error(
1252         "Reaction between two volume molecules and a surface is not defined.");
1253     return MCELL_FAIL;
1254   }
1255   if (all_3d) {
1256     if (oriented_count != 0) {
1257       if (notify-&gt;useless_vol_orient == WARN_ERROR) {
1258         mcell_error("Orientation specified for molecule in reaction in volume");
1259         return MCELL_FAIL;
1260       } else if (notify-&gt;useless_vol_orient == WARN_WARN) {
1261         mcell_warn("Orientation specified for molecule in reaction in volume");
1262       }
1263     }
1264   } else {
1265     if (num_reactants != oriented_count) {
1266       if (notify-&gt;missed_surf_orient == WARN_ERROR) {
1267         mcell_error("Orientation not specified for molecule in reaction "
1268                     "at surface\n  (use ; or ', or ,' for random orientation)");
1269         return MCELL_FAIL;
1270       } else if (notify-&gt;missed_surf_orient == WARN_WARN) {
1271         mcell_warn("Orientation not specified for molecule in reaction at "
1272                    "surface\n  (use ; or ', or ,' for random orientation)");
1273       }
1274     }
1275   }
1276   return MCELL_SUCCESS;
1277 }
1278 MCELL_STATUS
1279 add_catalytic_species_to_products(struct pathway *path, int catalytic,
1280                                   int bidirectional, int all_3d) {
1281 <a name="1"></a>  struct species *catalyst;
1282   short catalyst_orient;
1283   switch (catalytic) {
1284 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  case 0:
1285     catalyst = path-&gt;reactant1;
1286     catalyst_orient = path-&gt;orientation1;
1287     break;
1288   case 1:
1289     catalyst = path-&gt;reactant2;
1290     catalyst_orient = path-&gt;orientation2;
1291     break;
1292   case 2:
1293     catalyst = path-&gt;reactant3;
1294     catalyst_orient = path-&gt;orientation3;
1295     break;</b></font>
1296   default:
1297     mcell_internal_error("Catalytic reagent index is invalid.");
1298     return MCELL_FAIL;
1299   }
1300   if (bidirectional || !(catalyst-&gt;flags &amp; IS_SURFACE)) {
1301     struct product *prodp = (struct product *)CHECKED_MALLOC_STRUCT(
1302         struct product, "reaction product");
1303     if (prodp == NULL) {
1304       return MCELL_FAIL;
1305     }
1306     prodp-&gt;prod = catalyst;
1307     if (all_3d) {
1308       prodp-&gt;orientation = 0;
1309     } else {
1310       prodp-&gt;orientation = catalyst_orient;
1311     }
1312     prodp-&gt;next = path-&gt;product_head;
1313     path-&gt;product_head = prodp;
1314   }
1315   return MCELL_SUCCESS;
1316 }
1317 MCELL_STATUS
1318 extract_products(struct notifications *notify, struct pathway *pathp,
1319                  struct mcell_species *products, int *num_surf_products,
1320                  int bidirectional,
1321                  int all_3d) {
1322   struct mcell_species *current_product;
1323   for (current_product = products; current_product != NULL;
1324        current_product = current_product-&gt;next) {
1325     if (current_product-&gt;mol_type == NULL)
1326       continue;
1327     struct product *prodp = (struct product *)CHECKED_MALLOC_STRUCT(
1328         struct product, "reaction product");
1329     if (prodp == NULL) {
1330       return MCELL_FAIL;
1331     }
1332     prodp-&gt;prod = (struct species *)current_product-&gt;mol_type-&gt;value;
1333     if (all_3d) {
1334       prodp-&gt;orientation = 0;
1335     } else {
1336       prodp-&gt;orientation = current_product-&gt;orient;
1337     }
1338     if (!bidirectional) {
1339       if (prodp-&gt;prod-&gt;flags &amp; IS_SURFACE) {
1340         mcell_error_raw("Surface_class '%s' is not allowed to be on the "
1341                         "product side of the reaction.",
1342                         prodp-&gt;prod-&gt;sym-&gt;name);
1343         free(prodp);
1344         return MCELL_FAIL;
1345       }
1346     }
1347     prodp-&gt;next = pathp-&gt;product_head;
1348     pathp-&gt;product_head = prodp;
1349     if (prodp-&gt;prod-&gt;flags &amp; ON_GRID) {
1350       ++(*num_surf_products);
1351     }
1352     if (!(prodp-&gt;prod-&gt;flags &amp; IS_SURFACE)) {
1353       if (all_3d == 0) {
1354         if (!current_product-&gt;orient_set) {
1355           if (notify-&gt;missed_surf_orient == WARN_ERROR) {
1356             mcell_error("Product orientation not specified for molecule in "
1357                         "reaction at surface\n  (use ; or ', or ,' for random "
1358                         "orientation)");
1359             return MCELL_FAIL;
1360           } else if (notify-&gt;missed_surf_orient == WARN_WARN) {
1361             mcell_warn("Product orientation not specified for molecule in "
1362                        "reaction at surface\n  (use ; or ', or ,' for random "
1363                        "orientation)");
1364           }
1365         }
1366       } else {
1367         if ((prodp-&gt;prod-&gt;flags &amp; NOT_FREE) != 0) {
1368           mcell_error("Reaction has only volume reactants but is trying to "
1369                       "create a surface product");
1370           return MCELL_FAIL;
1371         }
1372         if (current_product-&gt;orient_set) {
1373           if (notify-&gt;useless_vol_orient == WARN_ERROR) {
1374             mcell_error("Orientation specified for molecule in reaction in "
1375                         "volume");
1376             return MCELL_FAIL;
1377           } else if (notify-&gt;useless_vol_orient == WARN_WARN) {
1378             mcell_warn("Orientation specified for molecule in reaction in "
1379                        "volume");
1380           }
1381         }
1382       }
1383     }
1384   }
1385   return MCELL_SUCCESS;
1386 }
1387 char *create_rx_name(struct pathway *p) {
1388   struct species *reagents[3];
1389   int n_reagents = 0;
1390   reagents[0] = p-&gt;reactant1;
1391   reagents[1] = p-&gt;reactant2;
1392   reagents[2] = p-&gt;reactant3;
1393   for (n_reagents = 0; n_reagents &lt; 3; ++n_reagents)
1394     if (reagents[n_reagents] == NULL)
1395       break;
1396   for (int i = 0; i &lt; n_reagents; ++i) {
1397     for (int j = i + 1; j &lt; n_reagents; ++j) {
1398       if (strcmp(reagents[j]-&gt;sym-&gt;name, reagents[i]-&gt;sym-&gt;name) &lt; 0) {
1399         struct species *tmp = reagents[j];
1400         reagents[j] = reagents[i];
1401         reagents[i] = tmp;
1402       }
1403     }
1404   }
1405   switch (n_reagents) {
1406   case 1:
1407     return alloc_sprintf("%s", reagents[0]-&gt;sym-&gt;name);
1408   case 2:
1409     return alloc_sprintf("%s+%s", reagents[0]-&gt;sym-&gt;name,
1410                          reagents[1]-&gt;sym-&gt;name);
1411   case 3:
1412     return alloc_sprintf("%s+%s+%s", reagents[0]-&gt;sym-&gt;name,
1413                          reagents[1]-&gt;sym-&gt;name, reagents[2]-&gt;sym-&gt;name);
1414   default:
1415     return NULL;
1416   }
1417 }
1418 static char *concat_rx_name(char *name1, char *name2) {
1419   char *rx_name;
1420   if (strcmp(name2, name1) &lt;= 0) {
1421     char *nametmp = name1;
1422     name1 = name2;
1423     name2 = nametmp;
1424   }
1425   rx_name = CHECKED_SPRINTF("%s+%s", name1, name2);
1426   if (rx_name == NULL)
1427     return NULL;
1428   return rx_name;
1429 }
1430 MCELL_STATUS invert_current_reaction_pathway(
1431     struct sym_table_head *rxn_sym_table,
1432     double vacancy_search_dist2,
1433     struct pathway *pathp,
1434     struct reaction_rate *reverse_rate,
1435     const char *rate_filename) {
1436   struct product *prodp;
1437   int num_surf_products = 0;
1438   int num_surface_mols = 0;
1439   int num_vol_mols = 0;
1440   int is_surf_class = 0;
1441   int all_3d = 1;   int nprods;   for (nprods = 0, prodp = pathp-&gt;product_head; prodp != NULL;
1442        prodp = prodp-&gt;next) {
1443     nprods++;
1444     if ((prodp-&gt;prod-&gt;flags &amp; NOT_FREE) != 0)
1445       all_3d = 0;
1446     if ((prodp-&gt;prod-&gt;flags &amp; IS_SURFACE) != 0) {
1447       is_surf_class = 1;
1448     }
1449   }
1450   if (nprods == 0) {
1451     return MCELL_FAIL;
1452   }
1453   if (nprods == 1 &amp;&amp; (pathp-&gt;product_head-&gt;prod-&gt;flags &amp; IS_SURFACE)) {
1454     return MCELL_FAIL;
1455   }
1456   if (nprods &gt; 3) {
1457     return MCELL_FAIL;
1458   }
1459   if (pathp-&gt;pathname != NULL) {
1460     return MCELL_FAIL;
1461   }
1462   if (all_3d) {
1463     if ((pathp-&gt;reactant1-&gt;flags &amp; NOT_FREE) != 0)
1464       all_3d = 0;
1465     if (pathp-&gt;reactant2 != NULL &amp;&amp; (pathp-&gt;reactant2-&gt;flags &amp; NOT_FREE) != 0)
1466       all_3d = 0;
1467     if (pathp-&gt;reactant3 != NULL &amp;&amp; (pathp-&gt;reactant3-&gt;flags &amp; NOT_FREE) != 0)
1468       all_3d = 0;
1469     if (!all_3d) {
1470       return MCELL_FAIL;
1471     }
1472   }
1473   prodp = pathp-&gt;product_head;
1474   char *inverse_name;
1475   if (nprods == 1) {
1476     inverse_name = strdup(prodp-&gt;prod-&gt;sym-&gt;name);
1477     if (inverse_name == NULL)
1478       return MCELL_FAIL;
1479   } else if (nprods == 2) {
1480     inverse_name =
1481         concat_rx_name(prodp-&gt;prod-&gt;sym-&gt;name, prodp-&gt;next-&gt;prod-&gt;sym-&gt;name);
1482   } else {
1483     char *tmp_inverse_name = concat_rx_name(
1484       prodp-&gt;prod-&gt;sym-&gt;name, prodp-&gt;next-&gt;prod-&gt;sym-&gt;name);
1485     if (tmp_inverse_name == NULL) {
1486       return MCELL_FAIL;
1487     }
1488     inverse_name =
1489         concat_rx_name(tmp_inverse_name, prodp-&gt;next-&gt;next-&gt;prod-&gt;sym-&gt;name);
1490     free(tmp_inverse_name);
1491   }
1492   if (inverse_name == NULL) {
1493     return MCELL_FAIL;
1494   }
1495   struct sym_entry *sym = retrieve_sym(inverse_name, rxn_sym_table);
1496   if (sym == NULL) {
1497     sym = store_sym(inverse_name, RX, rxn_sym_table, NULL);
1498     if (sym == NULL) {
1499       free(inverse_name);
1500       return MCELL_FAIL;
1501     }
1502   }
1503   free(inverse_name);
1504   struct rxn *rx = (struct rxn *)sym-&gt;value;
1505   rx-&gt;n_reactants = nprods;
1506   rx-&gt;n_pathways++;
1507   struct pathway *path = (struct pathway *)CHECKED_MALLOC_STRUCT(
1508     struct pathway, "reaction pathway");
1509   if (path == NULL) {
1510     return MCELL_FAIL;
1511   }
1512   path-&gt;pathname = NULL;
1513   path-&gt;flags = 0;
1514   path-&gt;reactant1 = prodp-&gt;prod;
1515   if ((path-&gt;reactant1-&gt;flags &amp; NOT_FREE) == 0) {
1516     ++num_vol_mols;
1517   } else {
1518     if (path-&gt;reactant1-&gt;flags &amp; ON_GRID) {
1519       ++num_surface_mols;
1520     }
1521   }
1522   path-&gt;orientation1 = prodp-&gt;orientation;
1523   path-&gt;reactant2 = NULL;
1524   path-&gt;reactant3 = NULL;
1525   path-&gt;prod_signature = NULL;
1526   if (nprods &gt; 1) {
1527     path-&gt;reactant2 = prodp-&gt;next-&gt;prod;
1528     if ((path-&gt;reactant2-&gt;flags &amp; NOT_FREE) == 0) {
1529       ++num_vol_mols;
1530     } else {
1531       if (path-&gt;reactant2-&gt;flags &amp; ON_GRID) {
1532         ++num_surface_mols;
1533       }
1534     }
1535     path-&gt;orientation2 = prodp-&gt;next-&gt;orientation;
1536   }
1537   if (nprods &gt; 2) {
1538     path-&gt;reactant3 = prodp-&gt;next-&gt;next-&gt;prod;
1539     if ((path-&gt;reactant3-&gt;flags &amp; NOT_FREE) == 0) {
1540       ++num_vol_mols;
1541     } else {
1542       if (path-&gt;reactant3-&gt;flags &amp; ON_GRID) {
1543         ++num_surface_mols;
1544       }
1545     }
1546     path-&gt;orientation3 = prodp-&gt;next-&gt;next-&gt;orientation;
1547   }
1548   switch (reverse_rate-&gt;rate_type) {
1549   case RATE_UNSET:
1550     free(path);
1551     return MCELL_FAIL;
1552   case RATE_CONSTANT:
1553     path-&gt;km = reverse_rate-&gt;v.rate_constant;
1554     path-&gt;km_filename = NULL;
1555     break;
1556   case RATE_FILE:
1557     path-&gt;km = 0.0;
1558     path-&gt;km_filename = (char *)rate_filename;
1559     free(reverse_rate-&gt;v.rate_file);
1560     reverse_rate-&gt;v.rate_file = NULL;
1561     break;
1562   default:
1563     UNHANDLED_CASE(reverse_rate-&gt;rate_type);
1564   }
1565   path-&gt;product_head = (struct product *)CHECKED_MALLOC_STRUCT(
1566       struct product, "reaction product");
1567   if (path-&gt;product_head == NULL) {
1568     free(path);
1569     return 1;
1570   }
1571   path-&gt;product_head-&gt;orientation = pathp-&gt;orientation1;
1572   path-&gt;product_head-&gt;prod = pathp-&gt;reactant1;
1573   path-&gt;product_head-&gt;next = NULL;
1574   if (path-&gt;product_head-&gt;prod-&gt;flags &amp; ON_GRID)
1575     ++num_surf_products;
1576   if ((pathp-&gt;reactant2 != NULL) &amp;&amp;
1577       ((pathp-&gt;reactant2-&gt;flags &amp; IS_SURFACE) == 0)) {
1578     path-&gt;product_head-&gt;next = (struct product *)CHECKED_MALLOC_STRUCT(
1579         struct product, "reaction product");
1580     if (path-&gt;product_head-&gt;next == NULL) {
1581       free(path);
1582       return 1;
1583     }
1584     path-&gt;product_head-&gt;next-&gt;orientation = pathp-&gt;orientation2;
1585     path-&gt;product_head-&gt;next-&gt;prod = pathp-&gt;reactant2;
1586     path-&gt;product_head-&gt;next-&gt;next = NULL;
1587     if (path-&gt;product_head-&gt;next-&gt;prod-&gt;flags &amp; ON_GRID)
1588       ++num_surf_products;
1589     if ((pathp-&gt;reactant3 != NULL) &amp;&amp;
1590         ((pathp-&gt;reactant3-&gt;flags &amp; IS_SURFACE) == 0)) {
1591       path-&gt;product_head-&gt;next-&gt;next = (struct product *)CHECKED_MALLOC_STRUCT(
1592           struct product, "reaction product");
1593       if (path-&gt;product_head-&gt;next-&gt;next == NULL) {
1594         free(path);
1595         return 1;
1596       }
1597       path-&gt;product_head-&gt;next-&gt;next-&gt;orientation = pathp-&gt;orientation3;
1598       path-&gt;product_head-&gt;next-&gt;next-&gt;prod = pathp-&gt;reactant3;
1599       path-&gt;product_head-&gt;next-&gt;next-&gt;next = NULL;
1600       if (path-&gt;product_head-&gt;next-&gt;next-&gt;prod-&gt;flags &amp; ON_GRID)
1601         ++num_surf_products;
1602     }
1603   }
1604   path-&gt;prod_signature = create_prod_signature(&amp;path-&gt;product_head);
1605   if (path-&gt;prod_signature == NULL) {
1606     free(path);
1607     return MCELL_FAIL;
1608   }
1609   if ((!distinguishable(vacancy_search_dist2, 0, EPS_C)) &amp;&amp;
1610       (num_surf_products &gt; num_surface_mols)) {
1611     if (!((num_surface_mols == 0) &amp;&amp; (num_vol_mols == 1))) {
1612       free(path);
1613       return MCELL_FAIL;
1614     }
1615   }
1616   if (is_surf_class) {
1617     prodp = pathp-&gt;product_head;
1618     if (prodp-&gt;prod-&gt;flags &amp; IS_SURFACE) {
1619       pathp-&gt;product_head = prodp-&gt;next;
1620       prodp-&gt;next = NULL;
1621     } else if (prodp-&gt;next-&gt;prod-&gt;flags &amp; IS_SURFACE) {
1622       prodp-&gt;next = prodp-&gt;next-&gt;next;
1623     } else {
1624       prodp-&gt;next-&gt;next = prodp-&gt;next-&gt;next-&gt;next;
1625     }
1626   }
1627   path-&gt;next = rx-&gt;pathway_head;
1628   rx-&gt;pathway_head = path;
1629   return 0;
1630 }
1631 static int sort_product_list_compare(struct product *list_item,
1632                                      struct product *new_item) {
1633   int cmp = strcmp(list_item-&gt;prod-&gt;sym-&gt;name, new_item-&gt;prod-&gt;sym-&gt;name);
1634   if (cmp == 0) {
1635     if (list_item-&gt;orientation &gt; new_item-&gt;orientation)
1636       cmp = -1;
1637     else if (list_item-&gt;orientation &lt; new_item-&gt;orientation)
1638       cmp = 1;
1639     else
1640       cmp = 0;
1641   }
1642   return cmp;
1643 }
1644 static struct product *sort_product_list(struct product *product_head) {
1645   struct product *iter;            struct product *result = NULL;   int cmp;
1646   for (struct product *current = product_head; current != NULL;
1647        current = next) {
1648     next = current-&gt;next;
1649     if (result == NULL) {
1650       current-&gt;next = result;
1651       result = current;
1652       continue;
1653     }
1654     cmp = sort_product_list_compare(result, current);
1655     if (cmp &gt;= 0) {
1656       current-&gt;next = result;
1657       result = current;
1658       continue;
1659     }
1660     else {
1661       iter = result;
1662       while (iter-&gt;next != NULL &amp;&amp; sort_product_list_compare(iter, current) &lt; 0)
1663         iter = iter-&gt;next;
1664       current-&gt;next = iter-&gt;next;
1665       iter-&gt;next = current;
1666     }
1667   }
1668   return result;
1669 }
1670 char *create_prod_signature(struct product **product_head) {
1671   char *prod_signature = NULL;
1672   *product_head = sort_product_list(*product_head);
1673   struct product *current = *product_head;
1674   if (current == NULL) {
1675     return NULL;
1676   }
1677   prod_signature = CHECKED_STRDUP(current-&gt;prod-&gt;sym-&gt;name, "product name");
1678   char *temp_str = NULL;
1679   while (current-&gt;next != NULL) {
1680     temp_str = prod_signature;
1681     prod_signature = CHECKED_SPRINTF("%s+%s", prod_signature,
1682                                      current-&gt;next-&gt;prod-&gt;sym-&gt;name);
1683     if (prod_signature == NULL) {
1684       if (temp_str != NULL)
1685         free(temp_str);
1686       return NULL;
1687     }
1688     if (temp_str != NULL)
1689       free(temp_str);
1690     current = current-&gt;next;
1691   }
1692   return prod_signature;
1693 }
1694 void check_duplicate_special_reactions(struct pathway *path) {
1695   if (path-&gt;next != NULL) {
1696     if ((path-&gt;flags &amp; PATHW_TRANSP) &amp;&amp; (path-&gt;next-&gt;flags &amp; PATHW_TRANSP)) {
1697       if ((path-&gt;orientation2 == path-&gt;next-&gt;orientation2) ||
1698           (path-&gt;orientation2 == 0) || (path-&gt;next-&gt;orientation2 == 0)) {
1699         mcell_error("Exact duplicates of special reaction TRANSPARENT = %s are "
1700                     "not allowed.  Please verify the contents of "
1701                     "DEFINE_SURFACE_CLASS statement.",
1702                     path-&gt;reactant2-&gt;sym-&gt;name);
1703       }
1704     }
1705     if ((path-&gt;flags &amp; PATHW_REFLEC) &amp;&amp; (path-&gt;next-&gt;flags &amp; PATHW_REFLEC)) {
1706       if ((path-&gt;orientation2 == path-&gt;next-&gt;orientation2) ||
1707           (path-&gt;orientation2 == 0) || (path-&gt;next-&gt;orientation2 == 0)) {
1708         mcell_error("Exact duplicates of special reaction REFLECTIVE = %s are "
1709                     "not allowed.  Please verify the contents of "
1710                     "DEFINE_SURFACE_CLASS statement.",
1711                     path-&gt;reactant2-&gt;sym-&gt;name);
1712       }
1713     }
1714     if ((path-&gt;flags &amp; PATHW_ABSORP) &amp;&amp; (path-&gt;next-&gt;flags &amp; PATHW_ABSORP)) {
1715       if ((path-&gt;orientation2 == path-&gt;next-&gt;orientation2) ||
1716           (path-&gt;orientation2 == 0) || (path-&gt;next-&gt;orientation2 == 0)) {
1717         mcell_error("Exact duplicates of special reaction ABSORPTIVE = %s are "
1718                     "not allowed.  Please verify the contents of "
1719                     "DEFINE_SURFACE_CLASS statement.",
1720                     path-&gt;reactant2-&gt;sym-&gt;name);
1721       }
1722     }
1723   }
1724 }
1725 int set_product_geometries(struct pathway *path, struct rxn *rx,
1726                            struct product *prod) {
1727   int recycled1, recycled2, recycled3;
1728   int k, kk, k2;
1729   short geom;
1730   struct product *prod2;
1731   int max_num_surf_products;   int num_surf_products_per_pathway;
1732   max_num_surf_products = 0;
1733   for (int n_pathway = 0; path != NULL; n_pathway++, path = path-&gt;next) {
1734     recycled1 = 0;
1735     recycled2 = 0;
1736     recycled3 = 0;
1737     k = rx-&gt;product_idx[n_pathway] + rx-&gt;n_reactants;
1738     num_surf_products_per_pathway = 0;
1739     for (prod = path-&gt;product_head; prod != NULL; prod = prod-&gt;next) {
1740       if (recycled1 == 0 &amp;&amp; prod-&gt;prod == path-&gt;reactant1) {
1741         recycled1 = 1;
1742         kk = rx-&gt;product_idx[n_pathway] + 0;
1743       } else if (recycled2 == 0 &amp;&amp; prod-&gt;prod == path-&gt;reactant2) {
1744         recycled2 = 1;
1745         kk = rx-&gt;product_idx[n_pathway] + 1;
1746       } else if (recycled3 == 0 &amp;&amp; prod-&gt;prod == path-&gt;reactant3) {
1747         recycled3 = 1;
1748         kk = rx-&gt;product_idx[n_pathway] + 2;
1749       } else {
1750         kk = k;
1751         k++;
1752       }
1753       if (prod-&gt;prod-&gt;flags &amp; ON_GRID)
1754         num_surf_products_per_pathway++;
1755       rx-&gt;players[kk] = prod-&gt;prod;
1756       if ((prod-&gt;orientation + path-&gt;orientation1) *
1757                   (prod-&gt;orientation - path-&gt;orientation1) ==
1758               0 &amp;&amp;
1759           prod-&gt;orientation * path-&gt;orientation1 != 0) {
1760         if (prod-&gt;orientation == path-&gt;orientation1)
1761           rx-&gt;geometries[kk] = 1;
1762         else
1763           rx-&gt;geometries[kk] = -1;
1764       } else if (rx-&gt;n_reactants &gt; 1 &amp;&amp;
1765                  (prod-&gt;orientation + path-&gt;orientation2) *
1766                          (prod-&gt;orientation - path-&gt;orientation2) ==
1767                      0 &amp;&amp;
1768                  prod-&gt;orientation * path-&gt;orientation2 != 0) {
1769         if (prod-&gt;orientation == path-&gt;orientation2)
1770           rx-&gt;geometries[kk] = 2;
1771         else
1772           rx-&gt;geometries[kk] = -2;
1773       } else if (rx-&gt;n_reactants &gt; 2 &amp;&amp;
1774                  (prod-&gt;orientation + path-&gt;orientation3) *
1775                          (prod-&gt;orientation - path-&gt;orientation3) ==
1776                      0 &amp;&amp;
1777                  prod-&gt;orientation * path-&gt;orientation3 != 0) {
1778         if (prod-&gt;orientation == path-&gt;orientation3)
1779           rx-&gt;geometries[kk] = 3;
1780         else
1781           rx-&gt;geometries[kk] = -3;
1782       } else {
1783         geom = 0;
1784         for (prod2 = path-&gt;product_head;
1785              prod2 != prod &amp;&amp; prod2 != NULL &amp;&amp; geom == 0; prod2 = prod2-&gt;next) {
1786           if ((prod2-&gt;orientation + prod-&gt;orientation) *
1787                       (prod2-&gt;orientation - prod-&gt;orientation) ==
1788                   0 &amp;&amp;
1789               prod-&gt;orientation * prod2-&gt;orientation != 0) {
1790             if (prod2-&gt;orientation == prod-&gt;orientation)
1791               geom = 1;
1792             else
1793               geom = -1;
1794           } else
1795             geom = 0;
1796           if (recycled1 == 1) {
1797             if (prod2-&gt;prod == path-&gt;reactant1) {
1798               recycled1 = 2;
1799               geom *= rx-&gt;n_reactants + 1;
1800             }
1801           } else if (recycled2 == 1) {
1802             if (prod2-&gt;prod == path-&gt;reactant2) {
1803               recycled2 = 2;
1804               geom *= rx-&gt;n_reactants + 2;
1805             }
1806           } else if (recycled3 == 1) {
1807             if (prod2-&gt;prod == path-&gt;reactant3) {
1808               recycled3 = 2;
1809               geom *= rx-&gt;n_reactants + 3;
1810             }
1811           } else {
1812             geom *= k2;
1813             k2++;
1814           }
1815         }
1816         rx-&gt;geometries[kk] = geom;
1817       }
1818       if (num_surf_products_per_pathway &gt; max_num_surf_products)
1819         max_num_surf_products = num_surf_products_per_pathway;
1820     }
1821     k = rx-&gt;product_idx[n_pathway];
1822     if (recycled1 == 0)
1823       rx-&gt;players[k] = NULL;
1824     if (recycled2 == 0 &amp;&amp; rx-&gt;n_reactants &gt; 1)
1825       rx-&gt;players[k + 1] = NULL;
1826     if (recycled3 == 0 &amp;&amp; rx-&gt;n_reactants &gt; 2)
1827       rx-&gt;players[k + 2] = NULL;
1828   }   return max_num_surf_products;
1829 }
1830 void alphabetize_pathway(struct pathway *path, struct rxn *reaction) {
1831   short geom, geom2;
1832   struct species *temp_sp, *temp_sp2;
1833   if ((path-&gt;reactant2-&gt;flags &amp; IS_SURFACE) == 0) {
1834     if (strcmp(path-&gt;reactant1-&gt;sym-&gt;name, path-&gt;reactant2-&gt;sym-&gt;name) &gt; 0) {
1835       temp_sp = path-&gt;reactant1;
1836       path-&gt;reactant1 = path-&gt;reactant2;
1837       path-&gt;reactant2 = temp_sp;
1838       geom = path-&gt;orientation1;
1839       path-&gt;orientation1 = path-&gt;orientation2;
1840       path-&gt;orientation2 = geom;
1841     } else if (strcmp(path-&gt;reactant1-&gt;sym-&gt;name, path-&gt;reactant2-&gt;sym-&gt;name) ==
1842                0) {
1843       if (path-&gt;orientation1 &lt; path-&gt;orientation2) {
1844         geom = path-&gt;orientation1;
1845         path-&gt;orientation1 = path-&gt;orientation2;
1846         path-&gt;orientation2 = geom;
1847       }
1848     }
1849   }
1850   if (reaction-&gt;n_reactants == 3) {
1851     if ((path-&gt;reactant3-&gt;flags &amp; IS_SURFACE) == 0) {
1852       if (strcmp(path-&gt;reactant1-&gt;sym-&gt;name, path-&gt;reactant3-&gt;sym-&gt;name) &gt; 0) {
1853         temp_sp = path-&gt;reactant1;
1854         geom = path-&gt;orientation1;
1855         path-&gt;reactant1 = path-&gt;reactant3;
1856         path-&gt;orientation1 = path-&gt;orientation3;
1857         temp_sp2 = path-&gt;reactant2;
1858         geom2 = path-&gt;orientation2;
1859         path-&gt;reactant2 = temp_sp;
1860         path-&gt;orientation2 = geom;
1861         path-&gt;reactant3 = temp_sp2;
1862         path-&gt;orientation3 = geom2;
1863       } else if (strcmp(path-&gt;reactant2-&gt;sym-&gt;name,
1864                         path-&gt;reactant3-&gt;sym-&gt;name) &gt; 0) {
1865         temp_sp = path-&gt;reactant2;
1866         path-&gt;reactant2 = path-&gt;reactant3;
1867         path-&gt;reactant3 = temp_sp;
1868         geom = path-&gt;orientation2;
1869         path-&gt;orientation2 = path-&gt;orientation3;
1870         path-&gt;orientation3 = geom;
1871       }
1872   }
1873 }
1874 static int warn_about_high_rates(struct notifications *notify, FILE *warn_file,
1875                                  int rate_warn, int print_once) {
1876   if (rate_warn) {
1877     if (notify-&gt;high_reaction_prob == WARN_ERROR) {
1878       warn_file = mcell_get_error_file();
1879       if (!print_once) {
1880         fprintf(warn_file, "\n");
1881         fprintf(
1882             warn_file,
1883             "Reaction probabilities generated for the following reactions:\n");
1884         print_once = 1;
1885       }
1886       fprintf(warn_file, "\tError: High ");
1887     } else {
1888       if (!print_once) {
1889         fprintf(warn_file, "\n");
1890         fprintf(
1891             warn_file,
1892             "Reaction probabilities generated for the following reactions:\n");
1893         print_once = 1;
1894       }
1895       if (notify-&gt;high_reaction_prob == WARN_WARN)
1896         fprintf(warn_file, "\tWarning: High ");
1897       else
1898         fprintf(warn_file, "\t");
1899     }
1900   } else {
1901     if (!print_once) {
1902       fprintf(warn_file, "\n");
1903       fprintf(
1904           warn_file,
1905           "Reaction probabilities generated for the following reactions:\n");
1906       print_once = 1;
1907     }
1908     fprintf(warn_file, "\t");
1909   }
1910   return print_once;
1911 }
1912 void add_surface_reaction_flags(struct sym_table_head *mol_sym_table,
1913                                 struct species *all_mols,
1914                                 struct species *all_surface_mols,
1915                                 struct species *all_volume_mols) {
1916   struct species *temp_sp;
1917   if (all_mols-&gt;flags &amp; (CAN_VOLWALL | CAN_SURFWALL)) {
1918     for (int n_mol_bin = 0; n_mol_bin &lt; mol_sym_table-&gt;n_bins;
1919          n_mol_bin++) {
1920       for (struct sym_entry *symp = mol_sym_table-&gt;entries[n_mol_bin];
1921            symp != NULL; symp = symp-&gt;next) {
1922         temp_sp = (struct species *)symp-&gt;value;
1923         if (temp_sp == all_mols)
1924           continue;
1925         if (temp_sp == all_volume_mols)
1926           continue;
1927         if (temp_sp == all_surface_mols)
1928           continue;
1929         if (((temp_sp-&gt;flags &amp; NOT_FREE) == 0) &amp;&amp;
1930             ((temp_sp-&gt;flags &amp; CAN_VOLWALL) == 0)) {
1931           temp_sp-&gt;flags |= CAN_VOLWALL;
1932         } else if ((temp_sp-&gt;flags &amp; ON_GRID) &amp;&amp;
1933                    ((temp_sp-&gt;flags &amp; CAN_REGION_BORDER) == 0)) {
1934           temp_sp-&gt;flags |= CAN_REGION_BORDER;
1935         }
1936       }
1937     }
1938   }
1939   if (all_volume_mols-&gt;flags &amp; CAN_VOLWALL) {
1940     for (int n_mol_bin = 0; n_mol_bin &lt; mol_sym_table-&gt;n_bins;
1941          n_mol_bin++) {
1942       for (struct sym_entry *symp = mol_sym_table-&gt;entries[n_mol_bin];
1943            symp != NULL; symp = symp-&gt;next) {
1944         temp_sp = (struct species *)symp-&gt;value;
1945         if (temp_sp == all_mols)
1946           continue;
1947         if (temp_sp == all_volume_mols)
1948           continue;
1949         if (temp_sp == all_surface_mols)
1950           continue;
1951         if (((temp_sp-&gt;flags &amp; NOT_FREE) == 0) &amp;&amp;
1952             ((temp_sp-&gt;flags &amp; CAN_VOLWALL) == 0)) {
1953           temp_sp-&gt;flags |= CAN_VOLWALL;
1954         }
1955       }
1956     }
1957   }
1958   if (all_surface_mols-&gt;flags &amp; CAN_SURFWALL) {
1959     for (int n_mol_bin = 0; n_mol_bin &lt; mol_sym_table-&gt;n_bins;
1960          n_mol_bin++) {
1961       for (struct sym_entry *symp = mol_sym_table-&gt;entries[n_mol_bin];
1962            symp != NULL; symp = symp-&gt;next) {
1963         temp_sp = (struct species *)symp-&gt;value;
1964         if (temp_sp == all_mols)
1965           continue;
1966         if (temp_sp == all_volume_mols)
1967           continue;
1968         if (temp_sp == all_surface_mols)
1969           continue;
1970         if (((temp_sp-&gt;flags &amp; ON_GRID) &amp;&amp;
1971              ((temp_sp-&gt;flags &amp; CAN_REGION_BORDER) == 0))) {
1972           temp_sp-&gt;flags |= CAN_REGION_BORDER;
1973         }
1974       }
1975     }
1976   }
1977 }
1978 int scale_rxn_probabilities(unsigned char *reaction_prob_limit_flag,
1979                         struct notifications *notify,
1980                         struct pathway *path, struct rxn *rx,
1981                         double pb_factor) {
1982   int print_once = 0;   FILE *warn_file;
1983   int is_gigantic;
1984   double rate;
1985   for (int n_pathway = 0; path != NULL; n_pathway++, path = path-&gt;next) {
1986     int rate_notify = 0, rate_warn = 0;
1987     if (!distinguishable(rx-&gt;cum_probs[n_pathway], GIGANTIC, EPS_C))
1988       is_gigantic = 1;
1989     else
1990       is_gigantic = 0;
1991     if (is_gigantic)
1992       continue;
1993     rate = pb_factor * rx-&gt;cum_probs[n_pathway];
1994     rx-&gt;cum_probs[n_pathway] = rate;
1995     if ((notify-&gt;reaction_probabilities == NOTIFY_FULL &amp;&amp;
1996          ((rate &gt;= notify-&gt;reaction_prob_notify) ||
1997           (notify-&gt;reaction_prob_notify == 0.0))))
1998       rate_notify = 1;
1999     if ((notify-&gt;high_reaction_prob != WARN_COPE &amp;&amp;
2000          ((rate &gt;= notify-&gt;reaction_prob_warn) ||
2001           ((notify-&gt;reaction_prob_warn == 0.0)))))
2002       rate_warn = 1;
2003     if ((rate &gt; 1.0) &amp;&amp; (!*reaction_prob_limit_flag)) {
2004       *reaction_prob_limit_flag = 1;
2005     }
2006     if (rate_warn || rate_notify) {
2007       warn_file = mcell_get_log_file();
2008       print_once =
2009           warn_about_high_rates(notify, warn_file, rate_warn,
2010                                 print_once);
2011       fprintf(warn_file, "Probability %.4e set for ", rate);
2012       if (rx-&gt;n_reactants == 1)
2013         fprintf(warn_file, "%s{%d} -&gt; ", rx-&gt;players[0]-&gt;sym-&gt;name,
2014                 rx-&gt;geometries[0]);
2015       else if (rx-&gt;n_reactants == 2) {
2016         if (rx-&gt;players[1]-&gt;flags &amp; IS_SURFACE) {
2017           fprintf(warn_file, "%s{%d} @ %s{%d} -&gt; ", rx-&gt;players[0]-&gt;sym-&gt;name,
2018                   rx-&gt;geometries[0], rx-&gt;players[1]-&gt;sym-&gt;name,
2019                   rx-&gt;geometries[1]);
2020         } else {
2021           fprintf(warn_file, "%s{%d} + %s{%d} -&gt; ", rx-&gt;players[0]-&gt;sym-&gt;name,
2022                   rx-&gt;geometries[0], rx-&gt;players[1]-&gt;sym-&gt;name,
2023                   rx-&gt;geometries[1]);
2024         }
2025       } else {
2026         if (rx-&gt;players[2]-&gt;flags &amp; IS_SURFACE) {
2027           fprintf(warn_file, "%s{%d} + %s{%d}  @ %s{%d} -&gt; ",
2028                   rx-&gt;players[0]-&gt;sym-&gt;name, rx-&gt;geometries[0],
2029                   rx-&gt;players[1]-&gt;sym-&gt;name, rx-&gt;geometries[1],
2030                   rx-&gt;players[2]-&gt;sym-&gt;name, rx-&gt;geometries[2]);
2031         } else {
2032           fprintf(warn_file, "%s{%d} + %s{%d}  + %s{%d} -&gt; ",
2033                   rx-&gt;players[0]-&gt;sym-&gt;name, rx-&gt;geometries[0],
2034                   rx-&gt;players[1]-&gt;sym-&gt;name, rx-&gt;geometries[1],
2035                   rx-&gt;players[2]-&gt;sym-&gt;name, rx-&gt;geometries[2]);
2036         }
2037       }
2038       if (path-&gt;product_head == NULL) {
2039         fprintf(warn_file, "NULL ");
2040       } else {
2041         for (struct product *prod = path-&gt;product_head; prod != NULL;
2042              prod = prod-&gt;next) {
2043           fprintf(warn_file, "%s{%d} ", prod-&gt;prod-&gt;sym-&gt;name,
2044                   prod-&gt;orientation);
2045         }
2046       }
2047       fprintf(warn_file, "\n");
2048       if (rate_warn &amp;&amp; notify-&gt;high_reaction_prob == WARN_ERROR)
2049         return 1;
2050     }
2051   }
2052   return 0;
2053 }
2054 static int equivalent_geometry_for_two_reactants(int o1a, int o1b, int o2a,
2055                                                  int o2b) {
2056   if ((o1a == o1b) &amp;&amp; (o2a == o2b)) {
2057     return 1;
2058   } else if ((o1a == -o1b) &amp;&amp; (o2a == -o2b)) {
2059     return 1;
2060   }
2061   if (abs(o1a) != abs(o1b)) {
2062     if ((abs(o2a) != abs(o2b)) || ((o2a == 0) &amp;&amp; (o2b == 0))) {
2063       return 1;
2064     }
2065   }
2066   if (abs(o2a) != abs(o2b)) {
2067     if ((abs(o1a) != abs(o1b)) || ((o1a == 0) &amp;&amp; (o1b == 0))) {
2068       return 1;
2069     }
2070   }
2071   return 0;
2072 }
2073 static int equivalent_geometry(struct pathway *p1, struct pathway *p2, int n) {
2074   int mols_parallel_1 = SHRT_MIN + 1;       int mols_parallel_2 = SHRT_MIN + 2;       int mol_surf_parallel_1 = SHRT_MIN + 3;   int mol_surf_parallel_2 = SHRT_MIN + 4; 
2075   if (n &lt; 2) {
2076     return 1;
2077   } else if (n &lt; 3) {
2078     o11 = p1-&gt;orientation1;
2079     o12 = p1-&gt;orientation2;
2080     o21 = p2-&gt;orientation1;
2081     o22 = p2-&gt;orientation2;
2082     return equivalent_geometry_for_two_reactants(o11, o12, o21, o22);
2083   } else if (n &lt; 4) {
2084     o11 = p1-&gt;orientation1;
2085     o12 = p1-&gt;orientation2;
2086     o13 = p1-&gt;orientation3;
2087     o21 = p2-&gt;orientation1;
2088     o22 = p2-&gt;orientation2;
2089     o23 = p2-&gt;orientation3;
2090     if ((p1-&gt;reactant1 == p1-&gt;reactant2) &amp;&amp; (p2-&gt;reactant1 == p2-&gt;reactant2)) {
2091       if ((abs(o11) == abs(o12)) &amp;&amp; (abs(o11) == abs(o13))) {
2092         if (o11 == o12)
2093           mols_parallel_1 = 1;
2094         else
2095           mols_parallel_1 = 0;
2096         if (mols_parallel_1) {
2097           if ((o11 == -o13) || (o12 == -o13)) {
2098             mol_surf_parallel_1 = 0;
2099           } else {
2100             mol_surf_parallel_1 = 1;
2101           }
2102         } else {
2103           mol_surf_parallel_1 = 0;
2104         }
2105         if ((abs(o21) == abs(o22)) &amp;&amp; (abs(o21) == abs(o23))) {
2106           if (o21 == o22)
2107             mols_parallel_2 = 1;
2108           else
2109             mols_parallel_2 = 0;
2110           if (mols_parallel_2) {
2111             if ((o21 == -o23) || (o22 == -o23)) {
2112               mol_surf_parallel_2 = 0;
2113             } else {
2114               mol_surf_parallel_2 = 1;
2115             }
2116           } else {
2117             mol_surf_parallel_2 = 0;
2118           }
2119         }
2120         if ((mols_parallel_1 == mols_parallel_2) &amp;&amp;
2121             (mol_surf_parallel_1 == mol_surf_parallel_2)) {
2122           return 1;
2123         }
2124       } 
2125       else if ((abs(o11) == abs(o13)) || (abs(o12) == abs(o13))) {
2126         if ((o11 == o13) || (o12 == o13))
2127           mol_surf_parallel_1 = 1;
2128         else
2129           mol_surf_parallel_1 = 0;
2130         if ((abs(o21) != abs(o23)) || (abs(o22) != abs(o23))) {
2131           if ((abs(o21) == abs(o23)) || (abs(o22) == abs(o23))) {
2132             if ((o21 == o23) || (o22 == o23))
2133               mol_surf_parallel_2 = 1;
2134             else
2135               mol_surf_parallel_2 = 0;
2136           }
2137         }
2138         if (mol_surf_parallel_1 == mol_surf_parallel_2) {
2139           return 1;
2140         }
2141       } 
2142       else if ((abs(o11) == abs(o12)) &amp;&amp; (abs(o11) != abs(o13))) {
2143         if (o11 == o12)
2144           mols_parallel_1 = 1;
2145         else
2146           mols_parallel_1 = 0;
2147         if ((abs(o21) == abs(o22)) &amp;&amp; (abs(o21) != abs(o23))) {
2148           if (o21 == o22)
2149             mols_parallel_2 = 1;
2150           else
2151             mols_parallel_2 = 0;
2152         }
2153         if (mols_parallel_1 == mols_parallel_2) {
2154           return 1;
2155         }
2156       }
2157       else if ((abs(o11) != abs(o13)) &amp;&amp; (abs(o12) != abs(o13)) &amp;&amp;
2158                (abs(o11) != abs(o12))) {
2159         if ((abs(o21) != abs(o23)) &amp;&amp; (abs(o22) != abs(o23)) &amp;&amp;
2160             (abs(o21) != abs(o22))) {
2161           return 1;
2162         }
2163       } 
2164     } else { 
2165       if ((equivalent_geometry_for_two_reactants(o11, o12, o21, o22)) &amp;&amp;
2166           (equivalent_geometry_for_two_reactants(o12, o13, o22, o23)) &amp;&amp;
2167           (equivalent_geometry_for_two_reactants(o11, o13, o21, o23))) {
2168         return 1;
2169       }
2170     }
2171   } 
2172   return 0;
2173 }
2174 static struct rxn *create_sibling_reaction(struct rxn *rx) {
2175   struct rxn *reaction = CHECKED_MALLOC_STRUCT(struct rxn, "reaction");
2176   if (reaction == NULL)
2177     return NULL;
2178   reaction-&gt;next = NULL;
2179   reaction-&gt;sym = rx-&gt;sym;
2180   reaction-&gt;n_reactants = rx-&gt;n_reactants;
2181   reaction-&gt;get_reactant_diffusion = rx-&gt;get_reactant_diffusion;
2182   reaction-&gt;n_pathways = 0;
2183   reaction-&gt;cum_probs = NULL;
2184   reaction-&gt;product_idx = NULL;
2185   reaction-&gt;max_fixed_p = 0.0;
2186   reaction-&gt;min_noreaction_p = 0.0;
2187   reaction-&gt;pb_factor = 0.0;
2188   reaction-&gt;players = NULL;
2189   reaction-&gt;geometries = NULL;
2190   reaction-&gt;n_occurred = 0;
2191   reaction-&gt;n_skipped = 0.0;
2192   reaction-&gt;prob_t = NULL;
2193   reaction-&gt;pathway_head = NULL;
2194   reaction-&gt;info = NULL;
2195   reaction-&gt;product_graph_data = NULL;
2196   reaction-&gt;external_reaction_data = NULL;
2197   return reaction;
2198 }
2199 struct rxn *split_reaction(struct rxn *rx) {
2200   struct rxn *curr_rxn_ptr = NULL, *head = NULL, *end = NULL;
2201   struct rxn *reaction;
2202   struct pathway *to_place, *temp;
2203   head = end = rx;
2204   to_place = head-&gt;pathway_head-&gt;next;
2205   head-&gt;pathway_head-&gt;next = NULL;
2206   head-&gt;n_pathways = 1;
2207   while (to_place != NULL) {
2208     if (to_place-&gt;flags &amp;
2209         (PATHW_TRANSP | PATHW_REFLEC | PATHW_ABSORP | PATHW_CLAMP_CONC | PATHW_CLAMP_FLUX)) {
2210       reaction = create_sibling_reaction(rx);
2211       if (reaction == NULL)
2212         return NULL;
2213       reaction-&gt;pathway_head = to_place;
2214       to_place = to_place-&gt;next;
2215       reaction-&gt;pathway_head-&gt;next = NULL;
2216       ++reaction-&gt;n_pathways;
2217       end-&gt;next = reaction;
2218       end = reaction;
2219     } else {
2220       for (curr_rxn_ptr = head; curr_rxn_ptr != NULL;
2221            curr_rxn_ptr = curr_rxn_ptr-&gt;next) {
2222         if (curr_rxn_ptr-&gt;pathway_head-&gt;flags &amp;
2223             (PATHW_TRANSP | PATHW_REFLEC | PATHW_ABSORP))
2224           continue;
2225         if (equivalent_geometry(to_place, curr_rxn_ptr-&gt;pathway_head,
2226                                 curr_rxn_ptr-&gt;n_reactants))
2227           break;
2228       }
2229       if (!curr_rxn_ptr) {
2230         reaction = create_sibling_reaction(rx);
2231         if (reaction == NULL)
2232           return NULL;
2233         end-&gt;next = reaction;
2234         end = reaction;
2235         curr_rxn_ptr = end;
2236       }
2237       temp = to_place;
2238       to_place = to_place-&gt;next;
2239       temp-&gt;next = curr_rxn_ptr-&gt;pathway_head;
2240       curr_rxn_ptr-&gt;pathway_head = temp;
2241       ++curr_rxn_ptr-&gt;n_pathways;
2242     }
2243   }
2244   return head;
2245 }
2246 void check_reaction_for_duplicate_pathways(struct pathway **head) {
2247   struct pathway *current, *next, **pprev;
2248   struct product *iter1, *iter2;
2249   int pathways_equivalent;   int i, j;
2250   int num_reactants;   int num_products;    int num_players;     int *orient_players_1,
2251       *orient_players_2;   int o1a, o1b, o2a, o2b;
2252   current = *head;
2253   pprev = head;
2254   while (current != NULL) {
2255     if (current-&gt;prod_signature == NULL) {
2256       *pprev = current-&gt;next;
2257       current-&gt;next = null_result;
2258       null_result = current;
2259       current = *pprev;
2260     } else {
2261       pprev = &amp;current-&gt;next;
2262       current = current-&gt;next;
2263     }
2264   }
2265   current = null_result;
2266   if ((current != NULL) &amp;&amp; (current-&gt;next != NULL)) {
2267     if (current-&gt;reactant2 == NULL)
2268       mcell_error("Exact duplicates of reaction %s  ----&gt; NULL are not "
2269                   "allowed.  Please verify that orientations of reactants are "
2270                   "not equivalent.",
2271                   current-&gt;reactant1-&gt;sym-&gt;name);
2272     else if (current-&gt;reactant3 == NULL)
2273       mcell_error("Exact duplicates of reaction %s + %s  ----&gt; NULL are not "
2274                   "allowed.  Please verify that orientations of reactants are "
2275                   "not equivalent.",
2276                   current-&gt;reactant1-&gt;sym-&gt;name, current-&gt;reactant2-&gt;sym-&gt;name);
2277     else
2278       mcell_error("Exact duplicates of reaction %s + %s + %s  ----&gt; NULL are "
2279                   "not allowed.  Please verify that orientations of reactants "
2280                   "are not equivalent.",
2281                   current-&gt;reactant1-&gt;sym-&gt;name, current-&gt;reactant2-&gt;sym-&gt;name,
2282                   current-&gt;reactant3-&gt;sym-&gt;name);
2283   }
2284   current = *head;
2285   while (current != NULL) {
2286     next = current-&gt;next;
2287     if (result == NULL ||
2288         (strcmp(result-&gt;prod_signature, current-&gt;prod_signature) &gt;= 0)) {
2289       current-&gt;next = result;
2290       result = current;
2291     } else {
2292       struct pathway *iter = result;
2293       while (iter-&gt;next != NULL &amp;&amp; (strcmp(iter-&gt;next-&gt;prod_signature,
2294                                            current-&gt;prod_signature) &lt; 0)) {
2295         iter = iter-&gt;next;
2296       }
2297       current-&gt;next = iter-&gt;next;
2298       iter-&gt;next = current;
2299     }
2300     current = next;
2301   }
2302   current = result;
2303   if (current != NULL) {
2304     while (current-&gt;next != NULL) {
2305       if (strcmp(current-&gt;prod_signature, current-&gt;next-&gt;prod_signature) == 0) {
2306         pathways_equivalent = 1;
2307         num_reactants = 0;
2308         num_products = 0;
2309         if (current-&gt;reactant1 != NULL)
2310           num_reactants++;
2311         if (current-&gt;reactant2 != NULL)
2312           num_reactants++;
2313         if (current-&gt;reactant3 != NULL)
2314           num_reactants++;
2315         iter1 = current-&gt;product_head;
2316         while (iter1 != NULL) {
2317           num_products++;
2318           iter1 = iter1-&gt;next;
2319         }
2320         num_players = num_reactants + num_products;
2321         orient_players_1 = CHECKED_MALLOC_ARRAY(int, num_players,
2322                                                 "reaction player orientations");
2323         if (orient_players_1 == NULL)
2324           mcell_die();
2325         orient_players_2 = CHECKED_MALLOC_ARRAY(int, num_players,
2326                                                 "reaction player orientations");
2327         if (orient_players_2 == NULL)
2328           mcell_die();
2329         if (current-&gt;reactant1 != NULL)
2330           orient_players_1[0] = current-&gt;orientation1;
2331         if (current-&gt;reactant2 != NULL)
2332           orient_players_1[1] = current-&gt;orientation2;
2333         if (current-&gt;reactant3 != NULL)
2334           orient_players_1[2] = current-&gt;orientation3;
2335         if (current-&gt;next-&gt;reactant1 != NULL)
2336           orient_players_2[0] = current-&gt;next-&gt;orientation1;
2337         if (current-&gt;next-&gt;reactant2 != NULL)
2338           orient_players_2[1] = current-&gt;next-&gt;orientation2;
2339         if (current-&gt;next-&gt;reactant3 != NULL)
2340           orient_players_2[2] = current-&gt;next-&gt;orientation3;
2341         iter1 = current-&gt;product_head;
2342         iter2 = current-&gt;next-&gt;product_head;
2343         for (i = num_reactants; i &lt; num_players; i++) {
2344           orient_players_1[i] = iter1-&gt;orientation;
2345           orient_players_2[i] = iter2-&gt;orientation;
2346           iter1 = iter1-&gt;next;
2347           iter2 = iter2-&gt;next;
2348         }
2349         i = 0;
2350         while ((i &lt; num_players) &amp;&amp; (pathways_equivalent)) {
2351           if (i &lt; num_reactants) {
2352             j = num_reactants;
2353           } else {
2354             j = i + 1;
2355           }
2356           for (; j &lt; num_players; j++) {
2357             o1a = orient_players_1[i];
2358             o1b = orient_players_1[j];
2359             o2a = orient_players_2[i];
2360             o2b = orient_players_2[j];
2361             if (!equivalent_geometry_for_two_reactants(o1a, o1b, o2a, o2b)) {
2362               pathways_equivalent = 0;
2363               break;
2364             }
2365           }
2366           i++;
2367         }
2368         if (pathways_equivalent) {
2369           if (current-&gt;reactant1 != NULL) {
2370             if (current-&gt;reactant2 == NULL)
2371               mcell_error("Exact duplicates of reaction %s  ----&gt; %s are not "
2372                           "allowed.  Please verify that orientations of "
2373                           "reactants are not equivalent.",
2374                           current-&gt;reactant1-&gt;sym-&gt;name, current-&gt;prod_signature);
2375             else if (current-&gt;reactant3 == NULL)
2376               mcell_error("Exact duplicates of reaction %s + %s  ----&gt; %s are "
2377                           "not allowed.  Please verify that orientations of "
2378                           "reactants are not equivalent.",
2379                           current-&gt;reactant1-&gt;sym-&gt;name,
2380                           current-&gt;reactant2-&gt;sym-&gt;name, current-&gt;prod_signature);
2381             else
2382               mcell_error("Exact duplicates of reaction %s + %s + %s  ----&gt; %s "
2383                           "are not allowed.  Please verify that orientations of "
2384                           "reactants are not equivalent.",
2385                           current-&gt;reactant1-&gt;sym-&gt;name,
2386                           current-&gt;reactant2-&gt;sym-&gt;name,
2387                           current-&gt;reactant3-&gt;sym-&gt;name, current-&gt;prod_signature);
2388           }
2389         }
2390         free(orient_players_1);
2391         free(orient_players_2);
2392       }
2393       current = current-&gt;next;
2394     }
2395   }
2396   if (null_result == NULL) {
2397     *head = result;
2398   } else if (result == NULL) {
2399     *head = null_result;
2400   } else {
2401     current = result;
2402     while (current-&gt;next != NULL) {
2403       current = current-&gt;next;
2404     }
2405     current-&gt;next = null_result;
2406     null_result-&gt;next = NULL;
2407     *head = result;
2408   }
2409 }
2410 void set_reaction_player_flags(struct rxn *rx) {
2411   switch (rx-&gt;n_reactants) {
2412   case 1:
2413     return;
2414   case 2:
2415     if (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_MOLECULES") == 0) {
2416       rx-&gt;players[0]-&gt;flags |= (CAN_VOLWALL | CAN_SURFWALL);
2417     } else if (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_VOLUME_MOLECULES") == 0) {
2418       rx-&gt;players[0]-&gt;flags |= CAN_VOLWALL;
2419     } else if (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_SURFACE_MOLECULES") ==
2420                0) {
2421       rx-&gt;players[0]-&gt;flags |= CAN_SURFWALL;
2422     } else if ((rx-&gt;players[0]-&gt;flags &amp; NOT_FREE) == 0) {
2423       if ((rx-&gt;players[1]-&gt;flags &amp; NOT_FREE) == 0) {
2424         rx-&gt;players[0]-&gt;flags |= CAN_VOLVOL;
2425         rx-&gt;players[1]-&gt;flags |= CAN_VOLVOL;
2426       }
2427       else if ((rx-&gt;players[1]-&gt;flags &amp; IS_SURFACE) != 0) {
2428         rx-&gt;players[0]-&gt;flags |= CAN_VOLWALL;
2429       }
2430       else if ((rx-&gt;players[1]-&gt;flags &amp; ON_GRID) != 0) {
2431         rx-&gt;players[0]-&gt;flags |= CAN_VOLSURF;
2432       }
2433     } else if ((rx-&gt;players[0]-&gt;flags &amp; IS_SURFACE) != 0) {
2434       if ((rx-&gt;players[1]-&gt;flags &amp; NOT_FREE) == 0) {
2435         rx-&gt;players[1]-&gt;flags |= CAN_VOLWALL;
2436       }
2437       else if ((rx-&gt;players[1]-&gt;flags &amp; ON_GRID) != 0) {
2438         rx-&gt;players[1]-&gt;flags |= CAN_SURFWALL;
2439       }
2440     } else if ((rx-&gt;players[0]-&gt;flags &amp; ON_GRID) != 0) {
2441       if ((rx-&gt;players[1]-&gt;flags &amp; NOT_FREE) == 0) {
2442         rx-&gt;players[1]-&gt;flags |= CAN_VOLSURF;
2443       }
2444       else if ((rx-&gt;players[1]-&gt;flags &amp; ON_GRID) != 0) {
2445         rx-&gt;players[0]-&gt;flags |= CAN_SURFSURF;
2446         rx-&gt;players[1]-&gt;flags |= CAN_SURFSURF;
2447       }
2448       else if ((rx-&gt;players[1]-&gt;flags &amp; IS_SURFACE) != 0) {
2449         rx-&gt;players[0]-&gt;flags |= CAN_SURFWALL;
2450       }
2451     }
2452     break;
2453   case 3:
2454     if ((rx-&gt;players[2]-&gt;flags &amp; IS_SURFACE) != 0) {
2455       if ((rx-&gt;players[0]-&gt;flags &amp; NOT_FREE) == 0) {
2456         if ((rx-&gt;players[1]-&gt;flags &amp; ON_GRID) != 0) {
2457           rx-&gt;players[0]-&gt;flags |= CAN_VOLSURF;
2458         }
2459       } else if ((rx-&gt;players[0]-&gt;flags &amp; ON_GRID) != 0) {
2460         if ((rx-&gt;players[1]-&gt;flags &amp; NOT_FREE) == 0) {
2461           rx-&gt;players[1]-&gt;flags |= CAN_VOLSURF;
2462         }
2463         else if ((rx-&gt;players[1]-&gt;flags &amp; ON_GRID) != 0) {
2464           rx-&gt;players[0]-&gt;flags |= CAN_SURFSURF;
2465           rx-&gt;players[1]-&gt;flags |= CAN_SURFSURF;
2466         }
2467       }
2468     } else {
2469       if ((rx-&gt;players[0]-&gt;flags &amp; NOT_FREE) == 0) {
2470         if ((rx-&gt;players[1]-&gt;flags &amp; NOT_FREE) == 0) {
2471           if ((rx-&gt;players[2]-&gt;flags &amp; NOT_FREE) == 0) {
2472             rx-&gt;players[0]-&gt;flags |= CAN_VOLVOLVOL;
2473             rx-&gt;players[1]-&gt;flags |= CAN_VOLVOLVOL;
2474             rx-&gt;players[2]-&gt;flags |= CAN_VOLVOLVOL;
2475           }
2476           else if ((rx-&gt;players[2]-&gt;flags &amp; ON_GRID) != 0) {
2477             rx-&gt;players[0]-&gt;flags |= CAN_VOLVOLSURF;
2478             rx-&gt;players[1]-&gt;flags |= CAN_VOLVOLSURF;
2479           }
2480         } else if ((rx-&gt;players[1]-&gt;flags &amp; ON_GRID) != 0) {
2481           if ((rx-&gt;players[2]-&gt;flags &amp; NOT_FREE) == 0) {
2482             rx-&gt;players[0]-&gt;flags |= CAN_VOLVOLSURF;
2483             rx-&gt;players[2]-&gt;flags |= CAN_VOLVOLSURF;
2484           }
2485           else if ((rx-&gt;players[2]-&gt;flags &amp; ON_GRID) != 0) {
2486             rx-&gt;players[0]-&gt;flags |= CAN_VOLSURFSURF;
2487           }
2488         }
2489       } else if ((rx-&gt;players[0]-&gt;flags &amp; ON_GRID) != 0) {
2490         if ((rx-&gt;players[1]-&gt;flags &amp; NOT_FREE) == 0) {
2491           if ((rx-&gt;players[2]-&gt;flags &amp; NOT_FREE) == 0) {
2492             rx-&gt;players[1]-&gt;flags |= CAN_VOLVOLSURF;
2493             rx-&gt;players[2]-&gt;flags |= CAN_VOLVOLSURF;
2494           }
2495           else if ((rx-&gt;players[2]-&gt;flags &amp; ON_GRID) != 0) {
2496             rx-&gt;players[1]-&gt;flags |= CAN_VOLSURFSURF;
2497           }
2498         } else if ((rx-&gt;players[1]-&gt;flags &amp; ON_GRID) != 0) {
2499           if ((rx-&gt;players[2]-&gt;flags &amp; NOT_FREE) == 0) {
2500             rx-&gt;players[2]-&gt;flags |= CAN_VOLSURFSURF;
2501           }
2502           else if ((rx-&gt;players[2]-&gt;flags &amp; ON_GRID) != 0) {
2503             rx-&gt;players[0]-&gt;flags |= CAN_SURFSURFSURF;
2504             rx-&gt;players[1]-&gt;flags |= CAN_SURFSURFSURF;
2505             rx-&gt;players[2]-&gt;flags |= CAN_SURFSURFSURF;
2506           }
2507         }
2508       }
2509     }
2510     break;
2511   default:
2512     break;
2513   }
2514 }
2515 int build_reaction_hash_table(
2516     struct rxn ***reaction_hash, int *n_reactions,
2517     struct sym_table_head *rxn_sym_table, int *rx_hashsize, int num_rx) {
2518   struct rxn **rx_tbl = NULL;
2519   int rx_hash;
2520   for (rx_hash = 2; rx_hash &lt;= num_rx &amp;&amp; rx_hash != 0; rx_hash &lt;&lt;= 1)
2521     ;
2522   rx_hash &lt;&lt;= 1;
2523   if (rx_hash == 0)
2524     rx_hash = MAX_RX_HASH;
2525   if (rx_hash &gt; MAX_RX_HASH)
2526     rx_hash = MAX_RX_HASH;
2527 #ifdef REPORT_RXN_HASH_STATS
2528   mcell_log("Num rxns: %d", num_rx);
2529   mcell_log("Size of hash: %d", rx_hash);
2530 #endif
2531   *rx_hashsize = rx_hash;
2532   rx_hash -= 1;
2533   rx_tbl = CHECKED_MALLOC_ARRAY(struct rxn *, *rx_hashsize,
2534                                 "reaction hash table");
2535   if (rx_tbl == NULL)
2536     return 1;
2537   *reaction_hash = rx_tbl;
2538   for (int i = 0; i &lt;= rx_hash; i++)
2539     rx_tbl[i] = NULL;
2540 #ifdef REPORT_RXN_HASH_STATS
2541   int numcoll = 0;
2542 #endif
2543   for (int i = 0; i &lt; rxn_sym_table-&gt;n_bins; i++) {
2544     for (struct sym_entry *sym = rxn_sym_table-&gt;entries[i]; sym != NULL;
2545          sym = sym-&gt;next) {
2546       struct rxn *rx = (struct rxn *)sym-&gt;value;
2547       int table_slot;
2548       if (rx-&gt;n_reactants == 1) {
2549         table_slot = rx-&gt;players[0]-&gt;hashval &amp; rx_hash;
2550       } else {
2551         table_slot =
2552             (rx-&gt;players[0]-&gt;hashval + rx-&gt;players[1]-&gt;hashval) &amp; rx_hash;
2553       }
2554 #ifdef REPORT_RXN_HASH_STATS
2555       if (rx_tbl[table_slot] != NULL) {
2556         mcell_log("Collision: %s and %s", rx_tbl[table_slot]-&gt;sym-&gt;name,
2557                   sym-&gt;name);
2558         ++numcoll;
2559       }
2560 #endif
2561       *n_reactions = *n_reactions + 1;
2562       while (rx-&gt;next != NULL)
2563         rx = rx-&gt;next;
2564       rx-&gt;next = rx_tbl[table_slot];
2565       rx_tbl[table_slot] = (struct rxn *)sym-&gt;value;
2566     }
2567   }
2568 #ifdef REPORT_RXN_HASH_STATS
2569   mcell_log("Num collisions: %d", numcoll);
2570 #endif
2571   return 0;
2572 }
2573 struct reaction_rates mcell_create_reaction_rates(int forwardRateType,
2574                                                   double forwardRateConstant,
2575                                                   int backwardRateType,
2576                                                   double backwardRateConstant) {
2577   struct reaction_rate forwardRate;
2578   forwardRate.rate_type = forwardRateType;
2579   forwardRate.v.rate_constant = forwardRateConstant;
2580   struct reaction_rate backwardRate;
2581   backwardRate.rate_type = backwardRateType;
2582   backwardRate.v.rate_constant = backwardRateConstant;
2583   struct reaction_rates rates = { forwardRate, backwardRate };
2584   return rates;
2585 }
2586 int load_rate_file(struct volume* state, struct rxn *rx, char *fname, int path) {
2587   struct mem_helper *tv_rxn_mem = state-&gt;tv_rxn_mem;
2588   const char *RATE_SEPARATORS = "\f\n\r\t\v ,;";
2589   const char *FIRST_DIGIT = "+-0123456789";
2590   int i;
2591   FILE *f = fopen(fname, "r");
2592   if (!f)
2593     return 1;
2594   else {
2595     struct t_func *tp, *tp2;
2596     double t, rate_constant;
2597     char buf[2048];
2598     char *cp;
2599     int linecount = 0;
2600 #ifdef DEBUG
2601     int valid_linecount = 0;
2602 #endif
2603     tp2 = NULL;
2604     while (fgets(buf, 2048, f)) {
2605       linecount++;
2606       for (i = 0; i &lt; 2048; i++) {
2607         if (!strchr(RATE_SEPARATORS, buf[i]))
2608           break;
2609       }
2610       if (i &lt; 2048 &amp;&amp; strchr(FIRST_DIGIT, buf[i])) {
2611         t = strtod((buf + i), &amp;cp);
2612         if (cp == (buf + i))
2613           continue; 
2614         for (i = cp - buf; i &lt; 2048; i++) {
2615           if (!strchr(RATE_SEPARATORS, buf[i]))
2616             break;
2617         }
2618         if (i == 2048) {
2619           mcell_error(
2620             "a time in the rate constant file consists of too many characters "
2621             "(it uses 2048 or more characters).");
2622           return(1);
2623         }
2624         rate_constant = strtod((buf + i), &amp;cp);
2625         if (cp == (buf + i))
2626           continue; 
2627         if (rate_constant &lt; 0.0)
2628         {
2629           if (state-&gt;notify-&gt;neg_reaction == WARN_ERROR)
2630           {
2631             mcell_error("reaction rate constants should be zero or positive.");
2632             return 1;
2633           }
2634           else if (state-&gt;notify-&gt;neg_reaction == WARN_WARN) {
2635             mcell_warn("negative reaction rate constant %f; setting to zero "
2636                        "and continuing.", rate_constant);
2637             rate_constant = 0.0;
2638           }
2639         }
2640         tp = (struct t_func *)CHECKED_MEM_GET(tv_rxn_mem,
2641                              "time-varying reaction rate constants");
2642         if (tp == NULL) {
2643           fclose(f);
2644           return 1;
2645         }
2646         tp-&gt;next = NULL;
2647         tp-&gt;path = path;
2648         tp-&gt;time = convert_seconds_to_iterations(
2649             state-&gt;start_iterations, state-&gt;time_unit,
2650             state-&gt;chkpt_start_time_seconds, t);
2651         tp-&gt;value = rate_constant;
2652         tp-&gt;value_from_file = rate_constant; #ifdef DEBUG
2653         valid_linecount++;
2654 #endif
2655         if (rx-&gt;prob_t == NULL) {
2656           rx-&gt;prob_t = tp;
2657           tp2 = tp;
2658         } else {
2659           if (tp2 == NULL) {
2660             tp2 = tp;
2661             tp-&gt;next = rx-&gt;prob_t;
2662             rx-&gt;prob_t = tp;
2663           } else {
2664             if (tp-&gt;time &lt; tp2-&gt;time)
2665               mcell_warn(
2666                   "In rate constants file '%s', line %d is out of sequence. "
2667                   "Resorting.", fname, linecount);
2668             tp-&gt;next = tp2-&gt;next;
2669             tp2-&gt;next = tp;
2670             tp2 = tp;
2671           }
2672         }
2673       }
2674     }
2675 #ifdef DEBUG
2676     mcell_log("Read %d rate constants from file %s.", valid_linecount, fname);
2677 #endif
2678     fclose(f);
2679   }
2680   return 0;
2681 }
2682 struct sym_entry *mcell_new_rxn_pathname(struct volume *state, char *name) {
2683   if ((retrieve_sym(name, state-&gt;rxpn_sym_table)) != NULL) {
2684     mcell_log("Named reaction pathway already defined: %s", name);
2685     return NULL;
2686   } else if ((retrieve_sym(name, state-&gt;mol_sym_table)) != NULL) {
2687     mcell_log("Named reaction pathway already defined as a molecule: %s", name);
2688     return NULL;
2689   }
2690   struct sym_entry *symp = store_sym(name, RXPN, state-&gt;rxpn_sym_table, NULL);
2691   if (symp == NULL) {
2692     mcell_log("Out of memory while creating reaction name: %s", name);
2693     return NULL;
2694   }
2695   return symp;
2696 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>config-win.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef MCELL_CONFIG_WIN_H
2 #define MCELL_CONFIG_WIN_H
3 #ifdef _MSC_VER
4 typedef unsigned int mode_t;
5 #pragma warning( disable : 4996 )
6 #endif
7 #ifndef MINGW_HAS_SECURE_API
8 #define MINGW_HAS_SECURE_API #endif
9 #undef __USE_MINGW_ANSI_STDIO
10 #define __USE_MINGW_ANSI_STDIO                                                 \
11   1 #define PRINTF_FORMAT(arg)                                                     \
12   __attribute__((__format__(                                                   \
13 #define PRINTF_FORMAT_V(arg) __attribute__((__format__(gnu_printf, arg, 0)))
14 #define WIN32_LEAN_AND_MEAN #undef _WIN32_WINNT
15 #define _WIN32_WINNT 0x0502
16 #define _CRT_SECURE_NO_WARNINGS
17 #include &lt;windows.h&gt;
18 #include &lt;stdlib.h&gt;
19 #include &lt;direct.h&gt; #include &lt;errno.h&gt;
20 #include &lt;stdio.h&gt; #include &lt;stdint.h&gt;
21 #include &lt;time.h&gt;
22 typedef unsigned short u_short;
23 typedef unsigned int u_int;
24 typedef unsigned long u_long;
25 #undef TRUE
26 #undef FALSE
27 #undef ERROR
28 #undef TRANSPARENT
29 #undef FILE_OVERWRITE
30 #undef FILE_CREATE
31 #ifdef _MSC_VER
32 #define getcwd _getcwd
33 #define strdup _strdup
34 #define va_copy(d, s) ((d) = (s))
35 #endif
36 #define UNUSED(p) ((void)(p))
37 #ifndef __GNUC__
38 #ifndef __attribute__
39 #define __attribute__(x) #define __restrict__
40 #endif
41 #endif
42 _CRTIMP errno_t __cdecl strerror_s(char *_Buf, size_t _SizeInBytes, int errnum);
43 inline static int strerror_r(int errnum, char *buf, size_t buflen) {
44   errno_t err = strerror_s(buf, buflen, errnum);
45   if (err != 0) {
46     errno = err;
47     return -1;
48   }
49   return 0;
50 }
51 inline static char *_ctime_r_helper(const time_t *timep, char *buf,
52                                     size_t buflen) {
53 #if defined(_WIN64) || defined(_MSC_VER)
54   errno_t err = _ctime64_s(buf, buflen, timep);
55 #else
56   errno_t err = _ctime32_s(buf, buflen, timep);
57 #endif
58   if (err != 0) {
59     errno = err;
60     return NULL;
61   }
62   return buf;
63 }
64 #define ctime_r(timep, buf)                                                    \
65   _ctime_r_helper(timep, buf, sizeof(buf)) 
66 inline static int _is_leap_year(int y) {
67   return (y &amp; 3) == 0 &amp;&amp; ((y % 25) != 0 || (y &amp; 15) == 0);
68 }
69 inline static int _iso8061_weeknum(const struct tm *timeptr) {
70   int Y = timeptr-&gt;tm_year, M = timeptr-&gt;tm_mon;
71   int T = timeptr-&gt;tm_mday + 4 -
72           (timeptr-&gt;tm_wday == 0 ? 7 : timeptr-&gt;tm_wday);   if (M == 12 &amp;&amp; T &gt; 31) {
73     return 1;
74   }
75   if (M == 1 &amp;&amp; T &lt; 1) {
76     --Y;
77     M = 12;
78     T += 31;
79   }
80   int D = 275 * M / 9 + T - 31 +
81           (M &gt; 2 ? (_is_leap_year(Y) - 2) : 0);   return 1 + D / 7;
82 }
83 inline static int _iso8061_wn_year(const struct tm *timeptr) {
84   int T = timeptr-&gt;tm_mday + 4 -
85           (timeptr-&gt;tm_wday == 0 ? 7 : timeptr-&gt;tm_wday);   return timeptr-&gt;tm_year + 1900 +
86          ((timeptr-&gt;tm_mon == 11 &amp;&amp; T &gt; 31)
87               ? +1
88               : ((timeptr-&gt;tm_mon == 0 &amp;&amp; T &lt; 1) ? -1 : 0));
89 }
90 inline static void _strnlwr(char *str, size_t count) {
91   for (char *end = str + count; str &lt; end; ++str) {
92     *str = tolower(*str);
93   }
94 }
95 inline static void _strnupr(char *str, size_t count) {
96   for (char *end = str + count; str &lt; end; ++str) {
97     *str = toupper(*str);
98   }
99 }
100 inline static void _strnchcase(char *str, size_t count) {
101   for (char *end = str + count; str &lt; end; ++str) {
102     *str = isupper(*str) ? tolower(*str) : toupper(*str);
103   }
104 }
105 __attribute__((__format__(
106     gnu_strftime, 3,
107     0))) inline static size_t _win_strftime(char *strDest, size_t maxsize,
108                                             const char *format,
109                                             const struct tm *timeptr) {
110   struct tm t = *timeptr;
111   const char *f2, *f1 = format;
112   char *out = strDest, *out_end = strDest + maxsize;
113   char fbuf[3] = "%%", buf[64];
114   while ((f2 = strchr(f1, '%')) != NULL) {
115     if (f2 - f1 &gt; out_end - out) {
116       return 0;
117     }
118     strncpy(out, f1, f2 - f1);
119     out += f2 - f1;
120     ++f2;
121     char flag;
122     if (*f2 == '_' || *f2 == '-' || *f2 == '0' || *f2 == '^' || *f2 == '#') {
123       flag = *(f2++);
124     } else {
125       flag = 0;
126     }
127     size_t width = 0;
128     while (isdigit(*f2)) {
129       width = 10 * (width - '0') + *(f2++);
130     }
131     if ((ptrdiff_t)width &gt; out_end - out) {
132       return 0;
133     }
134     if (*f2 == 'E') {
135       f2++;
136     } else if (*f2 == 'O') {
137       f2++;
138     }
139 <a name="0"></a>        size_t count;
140     int is_numeric = 0, is_num_space_padded = 0;
141 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    switch (*f2) {
142     case 0:
143       buf[0] = '%';
144       count = 1;
145       break;
146     case 'n':
147       buf[0] = '\n';
148       count = 1;
149       break;
150     case 't':
151       buf[0] = '\t';
152       count = 1;
153       break;</b></font>
154     case 'h':
155       count = strftime(buf, ARRAYSIZE(buf), "%b", timeptr);
156       break;
157     case 'D':
158       count = strftime(buf, ARRAYSIZE(buf), "%m/%d/%y", timeptr);
159       break;
160     case 'F':
161       count = strftime(buf, ARRAYSIZE(buf), "%Y-%m-%d", timeptr);
162       break;
163     case 'r':
164       count = strftime(buf, ARRAYSIZE(buf), "%I:%M:%S %p", timeptr);
165       break;     case 'R':
166       count = strftime(buf, ARRAYSIZE(buf), "%H:%M", timeptr);
167       break;
168     case 'T':
169       count = strftime(buf, ARRAYSIZE(buf), "%H:%M:%S", timeptr);
170       break;
171     case '+':
172       count = strftime(buf, ARRAYSIZE(buf), "%a %b %d %H:%M:%S %Z %Y", timeptr);
173       break;
174     case 'P':
175       _strnlwr(buf, count = strftime(buf, ARRAYSIZE(buf), "%p", timeptr));
176       break;
177     case 'e':
178       count = strftime(buf, ARRAYSIZE(buf), "%d", timeptr);
179       is_num_space_padded = 1;
180       is_numeric = 1;
181       break;
182     case 'k':
183       count = strftime(buf, ARRAYSIZE(buf), "%H", timeptr);
184       is_num_space_padded = 1;
185       is_numeric = 1;
186       break;
187     case 'l':
188       count = strftime(buf, ARRAYSIZE(buf), "%I", timeptr);
189       is_num_space_padded = 1;
190       is_numeric = 1;
191       break;
192     case 'C':
193       count = _snprintf(buf, ARRAYSIZE(buf), "%02u",
194                         (timeptr-&gt;tm_year + 1900) / 100);
195       is_numeric = 1;
196       break;
197     case 'u':
198       count = _snprintf(buf, ARRAYSIZE(buf), "%1u",
199                         timeptr-&gt;tm_wday == 0 ? 7 : timeptr-&gt;tm_wday);
200 <a name="1"></a>      is_numeric = 1;
201       break;
202 #if defined(_WIN64) || defined(_MSC_VER)
203 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    case 's':
204       count = _snprintf(buf, ARRAYSIZE(buf), "%08Iu", mktime(&amp;t));
205       is_numeric = 1;
206       break;
207 #else
208     case 's':
209       count = _snprintf(buf, ARRAYSIZE(buf), "%04Iu", mktime(&amp;t));
210       is_numeric = 1;
211       break;
212 #endif
213     case 'V':
214       count = _snprintf(buf, ARRAYSIZE(buf), "%02u", _iso8061_weeknum(timeptr));
215       is_numeric = 1;
216       break;</b></font>
217     case 'G':
218       count = _snprintf(buf, ARRAYSIZE(buf), "%04u", _iso8061_wn_year(timeptr));
219       is_numeric = 1;
220       break;
221     case 'g':
222       count = _snprintf(buf, ARRAYSIZE(buf), "%02u",
223                         _iso8061_wn_year(timeptr) % 100);
224       is_numeric = 1;
225       break;
226     case 'd':
227     case 'H':
228     case 'I':
229     case 'j':
230     case 'm':
231     case 'M':
232     case 'S':
233     case 'U':
234     case 'w':
235     case 'W':
236     case 'y':
237     case 'Y':
238       is_numeric = 1;
239       fbuf[1] = *f2;
240       count = strftime(buf, ARRAYSIZE(buf), fbuf, timeptr);
241       break;
242     default:
243       fbuf[1] = *f2;
244       count = strftime(buf, ARRAYSIZE(buf), fbuf, timeptr);
245       break;
246     }
247     size_t trim = 0;
248     char padding =
249         (flag == '_')
250             ? ' '
251             : ((flag == '0')
252                    ? '0'
253                    : (is_numeric ? (is_num_space_padded ? ' ' : '0') : ' '));
254     if (is_numeric) {
255       if (flag == '-') {
256         while (trim &lt; count - 1 &amp;&amp; buf[trim] == '0') {
257           ++trim;
258         }
259         count -= trim;
260       } else if (padding == ' ') {
261         for (size_t i = 0; i &lt; count - 1 &amp;&amp; buf[i] == '0'; ++i) {
262           buf[i] = ' ';
263         }
264       }
265     } else if (flag == '^') {
266       _strnupr(buf, count);
267     }     else if (flag == '#') {
268       _strnchcase(buf, count);
269     }     if ((ptrdiff_t)count &gt; out_end - out) {
270       return 0;
271     }
272     if (count &lt; width) {
273       memset(out, padding, width - count);
274       out += width - count;
275     }
276     strncpy(out, buf + trim, count);
277     out += count;
278     f1 = f2 + 1;
279   }
280   size_t len = strlen(f1);
281   strncpy(out, f1, len);
282   out[len] = 0;
283   return out - strDest + len;
284 }
285 #define strftime _win_strftime
286 #if 0
287 #define WSADESCRIPTION_LEN 256
288 #define WSASYS_STATUS_LEN 128
289 #define SOCKET_ERROR -1
290 typedef struct WSAData {
291   WORD wVersion;
292   WORD wHighVersion;
293 #ifdef _WIN64
294   unsigned short iMaxSockets;
295   unsigned short iMaxUdpDg;
296   char *lpVendorInfo;
297   char szDescription[WSADESCRIPTION_LEN + 1];
298   char szSystemStatus[WSASYS_STATUS_LEN + 1];
299 #else
300   char szDescription[WSADESCRIPTION_LEN + 1];
301   char szSystemStatus[WSASYS_STATUS_LEN + 1];
302   unsigned short iMaxSockets;
303   unsigned short iMaxUdpDg;
304   char *lpVendorInfo;
305 #endif
306 } WSADATA, *LPWSADATA;
307 #endif
308 #if 0
309 typedef long long int(WINAPI *FUNC_WSAStartup)(WORD wVersionRequested,
310                                      LPWSADATA lpWSAData);
311 typedef long long int(WINAPI *FUNC_WSAGetLastError)(void);
312 typedef long long int(WINAPI *FUNC_gethostname)(char *name, int namelen);
313 static FUNC_WSAStartup WSAStartup = NULL;
314 static FUNC_WSAGetLastError WSAGetLastError = NULL;
315 static FUNC_gethostname win32gethostname = NULL;
316 inline static int gethostname(char *name, size_t len) {
317   if (len &gt; INT_MAX) {
318     errno = EINVAL;
319     return -1;
320   }
321   if (win32gethostname == NULL) {
322     HMODULE ws2 = LoadLibraryA("ws2_32");
323     WSADATA wsaData;
324     WSAStartup = (FUNC_WSAStartup)GetProcAddress(ws2, "WSAStartup");
325     WSAGetLastError =
326         (FUNC_WSAGetLastError)GetProcAddress(ws2, "WSAGetLastError");
327     win32gethostname = (FUNC_gethostname)GetProcAddress(ws2, "gethostname");
328     if (ws2 == NULL || WSAStartup == NULL || WSAGetLastError == NULL ||
329         win32gethostname == NULL || WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0) {
330       if (ws2) {
331         FreeLibrary(ws2);
332       }
333       win32gethostname = NULL;
334       errno = EPERM;
335       return -1;
336     }
337   }
338   if (win32gethostname(name, (int)len) == SOCKET_ERROR) {
339     switch (WSAGetLastError()) {
340     case WSAEFAULT:
341       errno = name ? ENAMETOOLONG : EFAULT;
342       break;
343     case WSANOTINITIALISED:
344     case WSAENETDOWN:
345     case WSAEINPROGRESS:
346       errno = EAGAIN;
347       break;
348     }
349     return -1;
350   }
351   return 0;
352 }
353 #endif
354 #if !defined(_TIMEVAL_DEFINED) #define _TIMEVAL_DEFINED
355 struct timeval {
356   long tv_sec;
357   long tv_usec;
358 };
359 #endif
360 struct rusage {
361   struct timeval ru_utime;   struct timeval ru_stime; };
362 #define RUSAGE_SELF 0
363 inline static int getrusage(int who, struct rusage *usage) {
364   if (who != RUSAGE_SELF) {
365     errno = EINVAL;
366     return -1;
367   }
368   if (usage == NULL) {
369     errno = EFAULT;
370     return -1;
371   }
372   FILETIME ftCreation, ftExit, ftKernel, ftUser;
373   if (GetProcessTimes(GetCurrentProcess(), &amp;ftCreation, &amp;ftExit, &amp;ftKernel,
374                       &amp;ftUser) == 0) {
375     return -1;
376   }
377   ULONGLONG user =
378       (((ULONGLONG)ftUser.dwHighDateTime) &lt;&lt; 32) + ftUser.dwLowDateTime;
379   ULONGLONG kernel =
380       (((ULONGLONG)ftKernel.dwHighDateTime) &lt;&lt; 32) + ftKernel.dwLowDateTime;
381   usage-&gt;ru_utime.tv_usec = (long)((user % 10000000) / 10);
382   usage-&gt;ru_utime.tv_sec = (long)(user / 10000000);
383   usage-&gt;ru_stime.tv_usec = (long)((kernel % 10000000) / 10);
384   usage-&gt;ru_stime.tv_sec = (long)(kernel / 10000000);
385   return 0;
386 }
387 static int gettimeofday(struct timeval * tp, void*)
388 {
389     const uint64_t EPOCH = ((uint64_t) 116444736000000000ULL);
390     SYSTEMTIME  system_time;
391     FILETIME    file_time;
392     uint64_t    time;
393     GetSystemTime( &amp;system_time );
394     SystemTimeToFileTime( &amp;system_time, &amp;file_time );
395     time =  ((uint64_t)file_time.dwLowDateTime )      ;
396     time += ((uint64_t)file_time.dwHighDateTime) &lt;&lt; 32;
397     tp-&gt;tv_sec  = (long) ((time - EPOCH) / 10000000L);
398     tp-&gt;tv_usec = (long) (system_time.wMilliseconds * 1000);
399     return 0;
400 }
401 #if 0
402 #define SYMBOLIC_LINK_FLAG_FILE 0x0
403 #define SYMBOLIC_LINK_FLAG_DIRECTORY 0x1
404 typedef long long int (WINAPI *FUNC_CreateSymbolicLink)(LPCSTR lpSymlinkFileName,
405                                                  LPCSTR lpTargetFileName,
406                                                  DWORD dwFlags);
407 static FUNC_CreateSymbolicLink CreateSymbolicLink = NULL;
408 inline static int _win_is_dir(const char *path) {
409   DWORD attr = GetFileAttributesA(path);
410   return attr != INVALID_FILE_ATTRIBUTES &amp;&amp;
411          (attr &amp; FILE_ATTRIBUTE_DIRECTORY) != 0;
412 }
413 inline static int symlink(const char *oldpath, const char *newpath) {
414   if (CreateSymbolicLink == NULL) {
415     CreateSymbolicLink = (FUNC_CreateSymbolicLink)GetProcAddress(
416         GetModuleHandleA("kernel32"), "CreateSymbolicLinkA");
417     if (CreateSymbolicLink == NULL) {
418       errno = EPERM;
419       return -1;
420     }
421   }
422   if (!CreateSymbolicLink(newpath, oldpath, _win_is_dir(oldpath))) {
423     char buf[MAX_PATH + 1];
424     switch (GetLastError()) {
425     case ERROR_INVALID_FUNCTION:
426       errno = EPERM;
427       break;
428     case ERROR_INVALID_REPARSE_DATA:     case ERROR_PATH_NOT_FOUND:
429       errno = strlen(getcwd(buf, sizeof(buf))) + strlen(newpath) &gt;= MAX_PATH
430                   ? ENAMETOOLONG
431                   : ENOENT;
432       break;     case ERROR_ACCESS_DENIED:
433       errno = _win_is_dir(newpath) ? EEXIST : EACCES;
434     case ERROR_NOT_ENOUGH_MEMORY:
435       errno = ENOMEM;
436       break;
437     case ERROR_WRITE_PROTECT:
438       errno = EROFS;
439       break;
440     case ERROR_INVALID_PARAMETER:
441       errno = EFAULT;
442       break;
443     case ERROR_DISK_FULL:
444       errno = ENOSPC;
445       break;
446     case ERROR_ALREADY_EXISTS:
447       errno = EEXIST;
448       break;
449     default:
450       errno = EIO;
451       break;
452     }
453     return -1;
454   }
455   return 0;
456 }
457 #endif
458 #include &lt;sys/stat.h&gt;
459 #ifndef FSCTL_GET_REPARSE_POINT
460 #define FSCTL_GET_REPARSE_POINT                                                \
461   (0x00000009 &lt;&lt; 16) | (42 &lt;&lt; 2) | 0 |                                         \
462       (0 &lt;&lt; 14) #endif
463 #define S_IFLNK 0120000
464 #define S_ISLNK(m) (((m) &amp; S_IFMT) == S_IFLNK)
465 inline static int _is_symlink(const char *path) {
466   HANDLE hFile = CreateFileA(
467       path, GENERIC_READ,
468       FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL,
469       OPEN_EXISTING, FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,
470       NULL);
471   if (hFile == INVALID_HANDLE_VALUE) {
472     return 0;
473   }
474   DWORD *data = (DWORD *)malloc(MAXIMUM_REPARSE_DATA_BUFFER_SIZE), size;
475   if (data == NULL) {
476     CloseHandle(hFile);
477     return 0;
478   }
479   BOOL success = DeviceIoControl(hFile, FSCTL_GET_REPARSE_POINT, NULL, 0, data,
480                                  MAXIMUM_REPARSE_DATA_BUFFER_SIZE, &amp;size, NULL);
481   DWORD tag = *data;
482   free(data);
483   CloseHandle(hFile);
484   return success &amp;&amp; tag == IO_REPARSE_TAG_SYMLINK;
485 }
486 #ifdef stat
487 #undef stat
488 #undef fstat
489 #define stat _win_stat
490 #define fstat _win_fstat
491 struct stat {   _dev_t st_dev;
492   _ino_t st_ino;
493   unsigned short st_mode;
494   short st_nlink;
495   short st_uid;
496   short st_gid;
497   _dev_t st_rdev;
498   __MINGW_EXTENSION __int64 st_size;
499   __time64_t st_atime;
500   __time64_t st_mtime;
501   __time64_t st_ctime;
502 };
503 inline static int stat(const char *path, struct stat *buf) {
504   int retval = _stat64(path, (struct _stat64 *)buf);
505   if (retval == 0 &amp;&amp; _is_symlink(path)) {
506     buf-&gt;st_mode |= S_IFLNK;
507   }
508   return retval;
509 }
510 inline static int fstat(int fd, struct stat *buf) {
511   return _fstat64(fd, (struct _stat64 *)buf);
512 }
513 #else
514 inline static int _win_stat(const char *path, struct stat *buf) {
515   int retval = stat(path, buf);
516   if (retval == 0 &amp;&amp; _is_symlink(path)) {
517     buf-&gt;st_mode |= S_IFLNK;
518   }
519   return retval;
520 }
521 #define stat(path, buf) _win_stat(path, buf)
522 #endif
523 #define SIGALRM 14
524 typedef void(__cdecl *ALARM_CB)(int);
525 static ALARM_CB _alarm_cb = NULL;
526 static HANDLE _timer = NULL;
527 inline static void _win_alarm_cb(PVOID lpParameter, BOOLEAN TimerOrWaitFired) {
528   _timer = NULL;
529   _alarm_cb(SIGALRM);
530 }
531 inline static void set_alarm_handler(ALARM_CB handler) { _alarm_cb = handler; }
532 inline static unsigned alarm(unsigned seconds) {
533   unsigned retval = 0;
534   if (_timer) {
535     retval = 1;     DeleteTimerQueueTimer(NULL, _timer, NULL);
536     _timer = NULL;
537   }
538   if (!CreateTimerQueueTimer(&amp;_timer, NULL, (WAITORTIMERCALLBACK)_win_alarm_cb,
539                              NULL, seconds * 1000, 0, WT_EXECUTEONLYONCE)) {
540     retval = (unsigned)-1;
541   }
542   return retval;
543 }
544 int _win_rename(const char *old, const char *new_name);
545 inline static int _win_mkdir(const char *pathname, mode_t mode) {
546   UNUSED(mode);
547   return mkdir(pathname);
548 }
549 #define mkdir _win_mkdir
550 #undef IGNORE
551 #undef DIFFERENCE
552 #endif
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
