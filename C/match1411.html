<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mcell_reactions.c &amp; config-win.h</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mcell_reactions.c &amp; config-win.h
      </h3>
<h1 align="center">
        1.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mcell_reactions.c (0.708061%)<th>config-win.h (3.6879432%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1714-1728)<td><a href="#" name="0">(233-246)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1913-1924)<td><a href="#" name="1">(305-320)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mcell_reactions.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include "nfsim_func.h"
#include "diffuse_util.h"
#include "sym_table.h"
#include "logging.h"
#include "react_util.h"
#include "strfunc.h"
#include "react.h"
#include "mcell_reactions.h"
#include "diffuse.h"
#include "vol_util.h"
#include "mcell_structs.h"
static char *concat_rx_name(char *name1, char *name2);
MCELL_STATUS extract_reactants(struct pathway *path,
                                      struct mcell_species *reactants,
                                      int *num_reactants, int *num_vol_mols,
                                      int *num_surface_mols,
                                      int *all_3d,
                                      int *oriented_count);
static MCELL_STATUS extract_catalytic_arrow(struct pathway *path,
                                            struct reaction_arrow *react_arrow,
                                            int *num_reactants,
                                            int *num_vol_mols,
                                            int *num_surface_mols, int *all_3d,
                                            int *oriented_count);
static MCELL_STATUS extract_surface(struct pathway *path,
                                    struct mcell_species *surf_class,
                                    int *num_reactants,
                                    unsigned int *num_surfaces,
                                    int *oriented_count);
MCELL_STATUS extract_products(struct notifications *notify,
                                     struct pathway *path,
                                     struct mcell_species *products,
                                     int *num_surf_products,
                                     int bidirectional,
                                     int all_3d);
static MCELL_STATUS check_surface_specs(struct notifications *notify,
                                        int num_reactants, int num_surfaces,
                                        int num_vol_mols, int all_3d,
                                        int oriented_count);
static MCELL_STATUS add_catalytic_species_to_products(struct pathway *path,
                                                      int catalytic,
                                                      int bidirectional,
                                                      int all_3d);
static MCELL_STATUS invert_current_reaction_pathway(
    struct sym_table_head *rxn_sym_table,
    double vacancy_search_dist2,
    struct pathway *pathp,
    struct reaction_rate *reverse_rate,
    const char *rate_filename);
static char *create_prod_signature(struct product **product_head);
static void set_reaction_player_flags(struct rxn *rx);
static int build_reaction_hash_table(
  struct rxn ***reaction_hash, int *n_reactions,
  struct sym_table_head *rxn_sym_table, int *rx_hashsize, int num_rx);
static void check_reaction_for_duplicate_pathways(struct pathway **head);
static int load_rate_file(struct volume* state, struct rxn *rx, char *fname, int path);
static void add_surface_reaction_flags(struct sym_table_head *mol_sym_table,
                                       struct species *all_mols,
                                       struct species *all_surface_mols,
                                       struct species *all_volume_mols);
static void alphabetize_pathway(struct pathway *path, struct rxn *reaction);
static struct rxn *split_reaction(struct rxn *rx);
static void check_duplicate_special_reactions(struct pathway *path);
static int sort_product_list_compare(struct product *list_item,
                                     struct product *new_item);
static struct product *sort_product_list(struct product *product_head);
MCELL_STATUS
mcell_modify_multiple_rate_constants(struct volume *world, char **names, double *rate_constants, int n_rxns) {
  struct rxn **reactions_ud = (struct rxn **)malloc(0 * sizeof(*reactions_ud));   struct rxn **reactions_undv = (struct rxn **)malloc(0 * sizeof(*reactions_undv));
  struct rxn **reactions_unds = (struct rxn **)malloc(0 * sizeof(*reactions_unds));
  int n_reactions_ud=0;
  int n_reactions_undv=0;
  int n_reactions_unds=0;
  int i_rxn=0;
  while(i_rxn &lt; n_rxns)
  {
    struct sym_table_head *rxpn_sym_table = world-&gt;rxpn_sym_table;
    struct sym_entry *sym = retrieve_sym(names[i_rxn], rxpn_sym_table);
    if (sym == NULL) 
    {
      return MCELL_FAIL;
    }
    struct rxn_pathname *rxpn = (struct rxn_pathname *)sym-&gt;value;
    struct rxn *reaction = rxpn-&gt;rx;  
    int j = rxpn-&gt;path_num;
    int can_diffuse = distinguishable(reaction-&gt;players[0]-&gt;D, 0, EPS_C);
    if (reaction-&gt;n_reactants == 1 &amp;&amp; can_diffuse)
    {
      reactions_ud = (struct rxn **) realloc(reactions_ud, (n_reactions_ud + 1)*sizeof(*reactions_ud));
      reactions_ud[n_reactions_ud] = reaction;
      n_reactions_ud++;
    }
    else if (((!can_diffuse) &amp;&amp; (reaction-&gt;n_reactants == 1)) || 
    ((!can_diffuse) &amp;&amp; (reaction-&gt;n_reactants == 2) &amp;&amp; (reaction-&gt;players[1]-&gt;flags == IS_SURFACE))) 
    {
      if ((reaction-&gt;players[0]-&gt;flags &amp; NOT_FREE) != 0) 
      {
        reactions_unds = (struct rxn **) realloc(reactions_unds, (n_reactions_unds + 1)*sizeof(*reactions_unds));
        reactions_unds[n_reactions_unds] = reaction;
        n_reactions_unds++;
      }
      else
      {
        reactions_undv = (struct rxn **) realloc(reactions_undv, (n_reactions_undv + 1)*sizeof(*reactions_undv));
        reactions_undv[n_reactions_undv] = reaction;
        n_reactions_undv++;
      }
    }
    double p = rate_constants[i_rxn] * reaction-&gt;pb_factor;
    double delta_prob;
    if (j == 0)
      delta_prob = p - reaction-&gt;cum_probs[0];
    else
      delta_prob = p - (reaction-&gt;cum_probs[j] - reaction-&gt;cum_probs[j - 1]);
    for (int k = j; k &lt; reaction-&gt;n_pathways; k++) 
    {
      reaction-&gt;cum_probs[k] += delta_prob;
    }
    reaction-&gt;max_fixed_p += delta_prob;
    reaction-&gt;min_noreaction_p += delta_prob;
    i_rxn++;
  }
  if (n_reactions_ud &gt; 0)   {
    for (struct storage_list *local = world-&gt;storage_head; local != NULL; local = local-&gt;next) 
    {
      struct abstract_element *head_molecule = local-&gt;store-&gt;timer-&gt;current;
      while (local-&gt;store-&gt;timer-&gt;current != NULL) 
      {
        struct abstract_molecule *am = (struct abstract_molecule *)schedule_peak(local-&gt;store-&gt;timer);
        for (int i_reactions_ud=0; i_reactions_ud&lt;n_reactions_ud; i_reactions_ud++)
        {
          if ((am-&gt;properties != NULL) &amp;&amp; (am-&gt;properties-&gt;species_id == reactions_ud[i_reactions_ud]-&gt;players[0]-&gt;species_id)) 
          {
            am-&gt;t2 = 0.0;
            am-&gt;flags |= ACT_CHANGE;
          }
        }
      }
      local-&gt;store-&gt;timer-&gt;current = head_molecule;
    }
  }
  if (n_reactions_undv &gt; 0)   {
    int n_subvols = world-&gt;n_subvols;
    for (int i = 0; i &lt; n_subvols; i++) 
    {
      struct subvolume *sv = &amp;(world-&gt;subvol[i]);
      for (struct per_species_list *psl = sv-&gt;species_head; psl != NULL; psl = psl-&gt;next) 
      {
        if (psl-&gt;properties == NULL) 
        {
          continue;
        }
        for (struct volume_molecule *vm = psl-&gt;head; vm != NULL; vm = vm-&gt;next_v) 
        {
          if ((vm-&gt;properties != NULL) &amp;&amp; (vm-&gt;t &gt; world-&gt;current_iterations)) 
          {
            for (int i_reactions_undv=0; i_reactions_undv&lt;n_reactions_undv; i_reactions_undv++)
            {
              if (vm-&gt;properties-&gt;species_id == reactions_undv[i_reactions_undv]-&gt;players[0]-&gt;species_id)
              { 
                for (struct storage_list *local = world-&gt;storage_head; local != NULL; local = local-&gt;next) 
                {
                  vm-&gt;flags |= ACT_CHANGE;
                  vm-&gt;t2 = 0.0;
                  schedule_reschedule(local-&gt;store-&gt;timer, vm, world-&gt;current_iterations);
                }
              }
            }
          }
        }
      }
    }
  }
  if (n_reactions_unds &gt; 0)   {
    int n_subvols = world-&gt;n_subvols;
    for (int i = 0; i &lt; n_subvols; i++) 
    {
      struct subvolume *sv = &amp;(world-&gt;subvol[i]);
      for (struct wall_list *wl = sv-&gt;wall_head; wl != NULL; wl = wl-&gt;next) 
      {
        struct surface_grid *grid = wl-&gt;this_wall-&gt;grid;
        if (grid != NULL) 
        {
          for (u_int tile_idx = 0; tile_idx &lt; grid-&gt;n_tiles; tile_idx++) 
          {
            if (grid-&gt;sm_list[tile_idx]) 
            {
              struct surface_molecule *sm = grid-&gt;sm_list[tile_idx]-&gt;sm;
              if ((sm-&gt;properties != NULL) &amp;&amp; (sm-&gt;t &gt; world-&gt;current_iterations)) 
              {
                for (int i_reactions_unds=0; i_reactions_unds&lt;n_reactions_unds; i_reactions_unds++)
                {
                  if (sm-&gt;properties-&gt;species_id == reactions_unds[i_reactions_unds]-&gt;players[0]-&gt;species_id)
                  {
                    for (struct storage_list *local = world-&gt;storage_head; local != NULL; local = local-&gt;next) 
                    {
                      sm-&gt;flags |= ACT_CHANGE;
                      sm-&gt;t2 = 0.0;
                      schedule_reschedule(local-&gt;store-&gt;timer, sm, world-&gt;current_iterations);
                    }
                  }
                } 
              }
            }
          }
        }
      }
    }
  }
  free(reactions_ud);
  free(reactions_undv);
  free(reactions_unds);
  return MCELL_SUCCESS;
}
MCELL_STATUS
mcell_modify_rate_constant(struct volume *world, char *name, double rate_constant) {
  struct sym_table_head *rxpn_sym_table = world-&gt;rxpn_sym_table;
  struct sym_entry *sym = retrieve_sym(name, rxpn_sym_table);
  if (sym == NULL) 
  {
    return MCELL_FAIL;
  }
  else 
  {
    struct rxn_pathname *rxpn = (struct rxn_pathname *)sym-&gt;value;
    struct rxn *reaction = rxpn-&gt;rx;  
    int j = rxpn-&gt;path_num;
    double p = rate_constant * reaction-&gt;pb_factor;
    double delta_prob;
    if (j == 0)
      delta_prob = p - reaction-&gt;cum_probs[0];
    else
      delta_prob = p - (reaction-&gt;cum_probs[j] - reaction-&gt;cum_probs[j - 1]);
    for (int k = j; k &lt; reaction-&gt;n_pathways; k++) 
    {
      reaction-&gt;cum_probs[k] += delta_prob;
    }
    reaction-&gt;max_fixed_p += delta_prob;
    reaction-&gt;min_noreaction_p += delta_prob;
    int can_diffuse = distinguishable(reaction-&gt;players[0]-&gt;D, 0, EPS_C);
    if (reaction-&gt;n_reactants == 1 &amp;&amp; can_diffuse) 
    {
      for (struct storage_list *local = world-&gt;storage_head; local != NULL; local = local-&gt;next) 
      {
        struct abstract_element *head_molecule = local-&gt;store-&gt;timer-&gt;current;
        while (local-&gt;store-&gt;timer-&gt;current != NULL) 
        {
          struct abstract_molecule *am = (struct abstract_molecule *)schedule_peak(local-&gt;store-&gt;timer);
          if ((am-&gt;properties != NULL) &amp;&amp; (am-&gt;properties-&gt;species_id == reaction-&gt;players[0]-&gt;species_id)) 
          {
            am-&gt;t2 = 0.0;
          am-&gt;flags |= ACT_CHANGE;
          }
        }
        local-&gt;store-&gt;timer-&gt;current = head_molecule;
      }
    }
    if (((!can_diffuse) &amp;&amp; (reaction-&gt;n_reactants == 1)) || 
      ((!can_diffuse) &amp;&amp; (reaction-&gt;n_reactants == 2) &amp;&amp; (reaction-&gt;players[1]-&gt;flags == IS_SURFACE))) 
    {
      for (struct storage_list *local = world-&gt;storage_head; local != NULL; local = local-&gt;next) 
      {
        int n_subvols = world-&gt;n_subvols;
        for (int i = 0; i &lt; n_subvols; i++) 
        {
          struct subvolume *sv = &amp;(world-&gt;subvol[i]);
          if ((reaction-&gt;players[0]-&gt;flags &amp; NOT_FREE) != 0) 
          {
            for (struct wall_list *wl = sv-&gt;wall_head; wl != NULL; wl = wl-&gt;next) 
            {
              struct surface_grid *grid = wl-&gt;this_wall-&gt;grid;
              if (grid != NULL) 
              {
                for (u_int tile_idx = 0; tile_idx &lt; grid-&gt;n_tiles; tile_idx++) 
                {
                  if (grid-&gt;sm_list[tile_idx]) 
                  {
                    struct surface_molecule *sm = grid-&gt;sm_list[tile_idx]-&gt;sm;
                    if ((sm-&gt;properties != NULL) &amp;&amp; 
                      (sm-&gt;properties-&gt;species_id == reaction-&gt;players[0]-&gt;species_id) &amp;&amp;
                      (sm-&gt;t &gt; world-&gt;current_iterations)) 
                    {
                      sm-&gt;flags |= ACT_CHANGE;
                      sm-&gt;t2 = 0.0;
                      schedule_reschedule(local-&gt;store-&gt;timer, sm, world-&gt;current_iterations);
                    }
                  }
                } 
              }
            }   
          }
          else 
          {
            for (struct per_species_list *psl = sv-&gt;species_head; psl != NULL; psl = psl-&gt;next) 
            {
              if (psl-&gt;properties == NULL) 
              {
                continue;
              }
              for (struct volume_molecule *vm = psl-&gt;head; vm != NULL; vm = vm-&gt;next_v) 
              {
                if ((vm-&gt;properties != NULL) &amp;&amp; 
                  (vm-&gt;properties-&gt;species_id == reaction-&gt;players[0]-&gt;species_id)  &amp;&amp;
                  (vm-&gt;t &gt; world-&gt;current_iterations)) 
                { 
                  vm-&gt;flags |= ACT_CHANGE;
                  vm-&gt;t2 = 0.0;
                  schedule_reschedule(local-&gt;store-&gt;timer, vm, world-&gt;current_iterations);
                }
              }
            }
          }
        }
      }
    }
  }
  return MCELL_SUCCESS;
}
MCELL_STATUS
mcell_add_reaction_simplified(
    struct volume *state, 
    struct mcell_species *reactants,
    struct reaction_arrow *arrow,
    struct mcell_species *surfs,
    struct mcell_species *products,
    struct reaction_rates *rates,
    struct sym_entry *pathname) {
  mcell_add_reaction(state-&gt;notify, &amp;state-&gt;r_step_release,
                     state-&gt;rxn_sym_table, state-&gt;radial_subdivisions,
                     state-&gt;vacancy_search_dist2, reactants, arrow, surfs,
                     products, pathname, rates, NULL, NULL);
  return MCELL_SUCCESS;
}
MCELL_STATUS
mcell_add_reaction(struct notifications *notify,
                   double **r_step_release,
                   struct sym_table_head *rxn_sym_table,
                   u_int radial_subdivisions,
                   double vacancy_search_dist2,
                   struct mcell_species *reactants,
                   struct reaction_arrow *react_arrow,
                   struct mcell_species *surf_class,
                   struct mcell_species *products, struct sym_entry *pathname,
                   struct reaction_rates *rates,
                   const char *forward_rate_filename,
                   const char *backward_rate_filename) {
  char *rx_name;
  struct sym_entry *symp;
  int bidirectional = 0;
  int num_surf_products = 0;
  struct rxn *rxnp;
  struct pathway *pathp = (struct pathway *)CHECKED_MALLOC_STRUCT(
      struct pathway, "reaction pathway");
  if (pathp == NULL) {
    return MCELL_FAIL;
  }
  memset(pathp, 0, sizeof(struct pathway));
  int num_vol_mols = 0;
  int num_surface_mols = 0;
  int all_3d = 1;
  int reactant_idx = 0;
  int oriented_count = 0;
  int surface = -1;
  int catalytic = -1;
  unsigned int num_surfaces = 0;
  if (react_arrow-&gt;flags &amp; ARROW_BIDIRECTIONAL) {
    bidirectional = 1;
  }
  if (extract_reactants(pathp, reactants, &amp;reactant_idx, &amp;num_vol_mols,
                        &amp;num_surface_mols, &amp;all_3d,
                        &amp;oriented_count) == MCELL_FAIL) {
    free(pathp);
    return MCELL_FAIL;
  }
  if (react_arrow-&gt;flags &amp; ARROW_CATALYTIC) {
    if (extract_catalytic_arrow(pathp, react_arrow, &amp;reactant_idx,
                                &amp;num_vol_mols, &amp;num_surface_mols, &amp;all_3d,
                                &amp;oriented_count) == MCELL_FAIL) {
      free(pathp);
      return MCELL_FAIL;
    }
    catalytic = reactant_idx - 1;
  }
  if (surf_class-&gt;mol_type != NULL) {
    if (extract_surface(pathp, surf_class, &amp;reactant_idx, &amp;num_surfaces,
                        &amp;oriented_count) == MCELL_FAIL) {
      free(pathp);
      return MCELL_FAIL;
    }
    surface = reactant_idx - 1;
    all_3d = 0;
  }
  rx_name = create_rx_name(pathp);
  if (rx_name == NULL) {
    free(pathp);
    mcell_error("Out of memory while creating reaction.");
    return MCELL_FAIL;
  }
  if ((symp = retrieve_sym(rx_name, rxn_sym_table)) != NULL) {
  } else if ((symp = store_sym(rx_name, RX, rxn_sym_table, NULL)) ==
             NULL) {
    free(pathp);
    free(rx_name);
    mcell_error("Out of memory while creating reaction.");
  }
  free(rx_name);
  rxnp = (struct rxn *)symp-&gt;value;
  rxnp-&gt;n_reactants = reactant_idx;
  ++rxnp-&gt;n_pathways;
  if (check_surface_specs(notify, rxnp-&gt;n_reactants, num_surfaces,
                          num_vol_mols, all_3d, oriented_count) == MCELL_FAIL) {
    free(pathp);
    return MCELL_FAIL;
  }
  if (catalytic &gt;= 0) {
    if (add_catalytic_species_to_products(pathp, catalytic, bidirectional,
                                          all_3d) == MCELL_FAIL) {
      free(pathp);
      return MCELL_FAIL;
    }
  }
  if (extract_products(notify, pathp, products, &amp;num_surf_products,
                       bidirectional, all_3d) == MCELL_FAIL) {
    free(pathp);
    return MCELL_FAIL;
  }
  if (pathname != NULL) {
    struct rxn_pathname *rxpnp = (struct rxn_pathname *)pathname-&gt;value;
    rxpnp-&gt;rx = rxnp;
    pathp-&gt;pathname = rxpnp;
  }
  if (pathp-&gt;product_head != NULL) {
    pathp-&gt;prod_signature = create_prod_signature(&amp;pathp-&gt;product_head);
    if (pathp-&gt;prod_signature == NULL) {
      free(pathp);
      mcell_error(
          "Error creating 'prod_signature' field for the reaction pathway.");
      return MCELL_FAIL;
    }
  } else
    pathp-&gt;prod_signature = NULL;
  switch (rates-&gt;forward_rate.rate_type) {
  case RATE_UNSET:
    mcell_error_raw("File %s, Line %d: Internal error: Rate is not set",
                    __FILE__, __LINE__);
    free(pathp);
    return MCELL_FAIL;
  case RATE_CONSTANT:
    pathp-&gt;km = rates-&gt;forward_rate.v.rate_constant;
    pathp-&gt;km_filename = NULL;
    break;
  case RATE_FILE:
    pathp-&gt;km = 0.0;
    pathp-&gt;km_filename = (char *)forward_rate_filename;
    free(rates-&gt;forward_rate.v.rate_file);
    rates-&gt;forward_rate.v.rate_file = NULL;
    break;
  default:
    UNHANDLED_CASE(rates-&gt;forward_rate.rate_type);
  }
  if (rates-&gt;forward_rate.rate_type == RATE_FILE) {
    struct pathway *tpp;
    if (rxnp-&gt;pathway_head == NULL) {
      rxnp-&gt;pathway_head = pathp;
      pathp-&gt;next = NULL;
    } else     {
      for (tpp = rxnp-&gt;pathway_head;
           tpp-&gt;next != NULL &amp;&amp; tpp-&gt;next-&gt;km_filename == NULL;
           tpp = tpp-&gt;next) {
      }
      pathp-&gt;next = tpp-&gt;next;
      tpp-&gt;next = pathp;
    }
  } else {
    pathp-&gt;next = rxnp-&gt;pathway_head;
    rxnp-&gt;pathway_head = pathp;
  }
  if (*r_step_release == NULL &amp;&amp; all_3d &amp;&amp; pathp-&gt;product_head != NULL) {
    *r_step_release = init_r_step_3d_release(radial_subdivisions);
    if (*r_step_release == NULL) {
      free(pathp);
      mcell_error("Out of memory building r_step array.");
      return MCELL_FAIL;
    }
  }
  if ((!distinguishable(vacancy_search_dist2, 0, EPS_C)) &amp;&amp;
      (num_surf_products &gt; num_surface_mols)) {
    if (num_surface_mols == 0 &amp;&amp; num_vol_mols == 1 &amp;&amp; num_surf_products == 1) {
    } else {
      free(pathp);
      mcell_error("number of surface products exceeds number of surface "
                  "reactants, but VACANCY_SEARCH_DISTANCE is not specified or "
                  "set to zero.");
      return MCELL_FAIL;
    }
  }
  if (rates-&gt;backward_rate.rate_type != RATE_UNSET &amp;&amp; !bidirectional) {
    free(pathp);
    mcell_error("reverse rate specified but the reaction isn't reversible.");
    return MCELL_FAIL;
  }
  if (bidirectional) {
    if (rates-&gt;backward_rate.rate_type == RATE_UNSET) {
      free(pathp);
      mcell_error("reversible reaction indicated but no reverse rate "
                  "supplied.");
      return MCELL_FAIL;
    }
    if (surface != -1 &amp;&amp; surface != catalytic) {
      struct product *prodp;
      prodp = (struct product *)CHECKED_MALLOC_STRUCT(struct product,
                                                      "reaction product");
      if (prodp == NULL) {
        free(pathp);
        return MCELL_FAIL;
      }
      switch (surface) {
      case 1:
        prodp-&gt;prod = pathp-&gt;reactant2;
        prodp-&gt;orientation = pathp-&gt;orientation2;
        break;
      case 2:
        prodp-&gt;prod = pathp-&gt;reactant3;
        prodp-&gt;orientation = pathp-&gt;orientation3;
        break;
      case 0:
      default:
        mcell_internal_error(
            "Surface appears in invalid reactant slot in reaction (%d).",
            surface);
      }
      prodp-&gt;next = pathp-&gt;product_head;
      pathp-&gt;product_head = prodp;
    }
    if (invert_current_reaction_pathway(
        rxn_sym_table, vacancy_search_dist2, pathp,
        &amp;rates-&gt;backward_rate, backward_rate_filename)) {
      free(pathp);
      return MCELL_FAIL;
    }
  }
  rxnp-&gt;get_reactant_diffusion = rxn_get_standard_diffusion;
  return MCELL_SUCCESS;
}
MCELL_STATUS
mcell_add_surface_reaction(struct sym_table_head *rxn_sym_table,
                           int reaction_type, struct species *surface_class,
                           struct sym_entry *reactant_sym, short orient) {
  struct species *reactant = (struct species *)reactant_sym-&gt;value;
  if (reactant-&gt;flags == IS_SURFACE) {
    return MCELL_FAIL;
  }
  char *rx_name =
      concat_rx_name(surface_class-&gt;sym-&gt;name, reactant_sym-&gt;name);
  if (rx_name == NULL) {
    return MCELL_FAIL;
  }
  struct sym_entry *reaction_sym;
  if ((reaction_sym = retrieve_sym(rx_name, rxn_sym_table)) != NULL) {
  } else if ((reaction_sym =
                  store_sym(rx_name, RX, rxn_sym_table, NULL)) == NULL) {
    free(rx_name);
    return MCELL_FAIL;
  }
  free(rx_name);
  struct pathway *pathp = (struct pathway *)CHECKED_MALLOC_STRUCT(
      struct pathway, "reaction pathway");
  if (pathp == NULL)
    return MCELL_FAIL;
  memset(pathp, 0, sizeof(struct pathway));
  struct rxn *rxnp = (struct rxn *)reaction_sym-&gt;value;
  rxnp-&gt;n_reactants = 2;
  ++rxnp-&gt;n_pathways;
  pathp-&gt;pathname = NULL;
  pathp-&gt;reactant1 = surface_class;
  pathp-&gt;reactant2 = (struct species *)reactant_sym-&gt;value;
  pathp-&gt;reactant3 = NULL;
  pathp-&gt;km = GIGANTIC;
  pathp-&gt;km_filename = NULL;
  pathp-&gt;prod_signature = NULL;
  pathp-&gt;flags = 0;
  pathp-&gt;orientation1 = 1;
  pathp-&gt;orientation3 = 0;
  if (orient == 0) {
    pathp-&gt;orientation2 = 0;
  } else {
    pathp-&gt;orientation2 = (orient &lt; 0) ? -1 : 1;
  }
  struct name_orient *no;
  no = CHECKED_MALLOC_STRUCT(struct name_orient, "struct name_orient");
  no-&gt;name = CHECKED_STRDUP(reactant-&gt;sym-&gt;name, "reactant name");
  if (orient == 0) {
    no-&gt;orient = 0;
  } else {
    no-&gt;orient = (orient &lt; 0) ? -1 : 1;
  }
  struct product *prodp;
  switch (reaction_type) {
  case RFLCT:
    prodp = (struct product *)CHECKED_MALLOC_STRUCT(struct product,
                                                    "reaction product");
    if (prodp == NULL) {
      free(no);
      free(pathp);
      return MCELL_FAIL;
    }
    pathp-&gt;flags |= PATHW_REFLEC;
    prodp-&gt;prod = pathp-&gt;reactant2;
    prodp-&gt;orientation = 1;
    prodp-&gt;next = NULL;
    pathp-&gt;product_head = prodp;
    if (pathp-&gt;product_head != NULL) {
      pathp-&gt;prod_signature = create_prod_signature(&amp;pathp-&gt;product_head);
      if (pathp-&gt;prod_signature == NULL) {
        free(no);
        free(pathp);
        return MCELL_FAIL;
      }
    }
    if (surface_class-&gt;refl_mols == NULL) {
      no-&gt;next = NULL;
      surface_class-&gt;refl_mols = no;
    } else {
      no-&gt;next = surface_class-&gt;refl_mols;
      surface_class-&gt;refl_mols = no;
    }
    break;
  case TRANSP:
    prodp = (struct product *)CHECKED_MALLOC_STRUCT(struct product,
                                                    "reaction product");
    if (prodp == NULL) {
      free(no);
      free(pathp);
      return MCELL_FAIL;
    }
    pathp-&gt;flags |= PATHW_TRANSP;
    prodp-&gt;prod = pathp-&gt;reactant2;
    prodp-&gt;orientation = -1;
    prodp-&gt;next = NULL;
    pathp-&gt;product_head = prodp;
    if (pathp-&gt;product_head != NULL) {
      pathp-&gt;prod_signature = create_prod_signature(&amp;pathp-&gt;product_head);
      if (pathp-&gt;prod_signature == NULL) {
        free(no);
        free(pathp);
        return MCELL_FAIL;
      }
    }
    if (surface_class-&gt;transp_mols == NULL) {
      no-&gt;next = NULL;
      surface_class-&gt;transp_mols = no;
    } else {
      no-&gt;next = surface_class-&gt;transp_mols;
      surface_class-&gt;transp_mols = no;
    }
    break;
  case SINK:
    pathp-&gt;flags |= PATHW_ABSORP;
    pathp-&gt;product_head = NULL;
    if (surface_class-&gt;absorb_mols == NULL) {
      no-&gt;next = NULL;
      surface_class-&gt;absorb_mols = no;
    } else {
      no-&gt;next = surface_class-&gt;absorb_mols;
      surface_class-&gt;absorb_mols = no;
    }
    break;
  default:
    free(no);
    free(pathp);
    return MCELL_FAIL;
  }
  pathp-&gt;next = rxnp-&gt;pathway_head;
  rxnp-&gt;pathway_head = pathp;
  rxnp-&gt;get_reactant_diffusion = rxn_get_standard_diffusion;
  return MCELL_SUCCESS;
}
MCELL_STATUS
mcell_add_clamp(struct sym_table_head *rxn_sym_table,
                              struct species *surface_class,
                              struct sym_entry *mol_sym, short orient,
                              int clamp_type,
                              double clamp_value) {
  struct rxn *rxnp;
  struct pathway *pathp;
  struct sym_entry *stp3;
  struct species *specp = (struct species *)mol_sym-&gt;value;
  struct name_orient *no;
  if (specp-&gt;flags == IS_SURFACE) {
    return MCELL_FAIL;
  }
  if (specp-&gt;flags &amp; ON_GRID) {
    return MCELL_FAIL;
  }
  if (specp-&gt;flags &amp; NOT_FREE || specp-&gt;D &lt;= 0.0) {
    return MCELL_FAIL;
  }
  if (clamp_value &lt; 0) {
    return MCELL_FAIL;
  }
  char *rx_name = concat_rx_name(surface_class-&gt;sym-&gt;name, mol_sym-&gt;name);
  if (rx_name == NULL) {
    return MCELL_FAIL;
  }
  if ((stp3 = retrieve_sym(rx_name, rxn_sym_table)) != NULL) {
  } else if ((stp3 = store_sym(rx_name, RX, rxn_sym_table, NULL)) ==
             NULL) {
    free(rx_name);
    return MCELL_FAIL;
  }
  free(rx_name);
  pathp = (struct pathway *)CHECKED_MALLOC_STRUCT(struct pathway,
                                                  "reaction pathway");
  if (pathp == NULL)
    return MCELL_FAIL;
  memset(pathp, 0, sizeof(struct pathway));
  rxnp = (struct rxn *)stp3-&gt;value;
  rxnp-&gt;n_reactants = 2;
  ++rxnp-&gt;n_pathways;
  pathp-&gt;pathname = NULL;
  pathp-&gt;reactant1 = surface_class;
  pathp-&gt;reactant2 = (struct species *)mol_sym-&gt;value;
  pathp-&gt;reactant3 = NULL;
  pathp-&gt;flags = 0;
  pathp-&gt;km = clamp_value;
  pathp-&gt;km_filename = NULL;
  pathp-&gt;orientation1 = 1;
  pathp-&gt;orientation3 = 0;
  if (orient == 0) {
    pathp-&gt;orientation2 = 0;
  } else {
    pathp-&gt;orientation2 = (orient &lt; 0) ? -1 : 1;
  }
  if (clamp_type == CLAMP_TYPE_CONC) {
    pathp-&gt;flags |= PATHW_CLAMP_CONC;
    pathp-&gt;product_head = NULL;
    pathp-&gt;prod_signature = NULL;
  }
  else {
    pathp-&gt;flags |= PATHW_CLAMP_FLUX | PATHW_REFLEC;
    pathp-&gt;product_head = NULL;
    pathp-&gt;prod_signature = NULL;
#if 0
    struct product *prodp;
    prodp = (struct product *)CHECKED_MALLOC_STRUCT(struct product,
                                                    "reaction product");
    if (prodp == NULL) {
      free(pathp);
      return MCELL_FAIL;
    }
    prodp-&gt;prod = pathp-&gt;reactant2;
    prodp-&gt;orientation = pathp-&gt;orientation2;
    prodp-&gt;next = NULL;
    pathp-&gt;product_head = prodp;
    if (pathp-&gt;product_head != NULL) {
      pathp-&gt;prod_signature = create_prod_signature(&amp;pathp-&gt;product_head);
      if (pathp-&gt;prod_signature == NULL) {
        free(pathp);
        return MCELL_FAIL;
      }
    }
#endif
  }
  no = CHECKED_MALLOC_STRUCT(struct name_orient, "struct name_orient");
  no-&gt;name = CHECKED_STRDUP(mol_sym-&gt;name, "molecule name");
  no-&gt;orient = pathp-&gt;orientation2;
  if (surface_class-&gt;clamp_mols == NULL) {
    no-&gt;next = NULL;
    surface_class-&gt;clamp_mols = no;
  } else {
    no-&gt;next = surface_class-&gt;clamp_mols;
    surface_class-&gt;clamp_mols = no;
  }
  rxnp-&gt;get_reactant_diffusion = rxn_get_standard_diffusion;
  pathp-&gt;next = rxnp-&gt;pathway_head;
  rxnp-&gt;pathway_head = pathp;
  return MCELL_SUCCESS;
}
MCELL_STATUS
mcell_change_reaction_rate(MCELL_STATE *state, const char *reaction_name,
                           double new_rate) {
  if (new_rate &lt; 0.0) {
    return MCELL_FAIL;
  }
  struct rxn *rx = NULL;
  int path_id = 0;
  if (get_rxn_by_name(state-&gt;reaction_hash, state-&gt;rx_hashsize, reaction_name,
                      &amp;rx, &amp;path_id)) {
    return MCELL_FAIL;
  }
  if (change_reaction_probability(
      &amp;state-&gt;reaction_prob_limit_flag, state-&gt;notify, rx, path_id,
      new_rate)) {
    return MCELL_FAIL;
  }
  return MCELL_SUCCESS;
}
int init_reaction_info(struct rxn* rx){
  struct pathway *path;
  if (rx-&gt;n_pathways &gt; 0) {
    rx-&gt;info = CHECKED_MALLOC_ARRAY(struct pathway_info, rx-&gt;n_pathways,
                                    "reaction pathway info");
    if (rx-&gt;info == NULL)
      return 1;
    path = rx-&gt;pathway_head;
    for (int n_pathway = 0; path != NULL;
         n_pathway++, path = path-&gt;next) {
      rx-&gt;info[n_pathway].count = 0;
      rx-&gt;info[n_pathway].pathname =
          path-&gt;pathname;       if (path-&gt;pathname != NULL) {
        rx-&gt;info[n_pathway].pathname-&gt;path_num = n_pathway;
        rx-&gt;info[n_pathway].pathname-&gt;rx = rx;
      }
    }
  } else   {
    rx-&gt;info = CHECKED_MALLOC_STRUCT(struct pathway_info,
                                     "reaction pathway info");
    if (rx-&gt;info == NULL)
      return 1;
    rx-&gt;info[0].count = 0;
    rx-&gt;info[0].pathname = rx-&gt;pathway_head-&gt;pathname;
    if (rx-&gt;pathway_head-&gt;pathname != NULL) {
      rx-&gt;info[0].pathname-&gt;path_num = 0;
      rx-&gt;info[0].pathname-&gt;rx = rx;
    }
  }
  return 0;
}
int init_reactions(MCELL_STATE *state) {
  struct pathway *path;
  struct product *prod = NULL;
  short geom;
  int num_rx = 0;
  state-&gt;vacancy_search_dist2 *= state-&gt;r_length_unit;   state-&gt;vacancy_search_dist2 *= state-&gt;vacancy_search_dist2; 
  if (state-&gt;rx_radius_3d &lt;= 0.0) {
    state-&gt;rx_radius_3d = 1.0 / sqrt(MY_PI * state-&gt;grid_density);
  }
  state-&gt;tv_rxn_mem = create_mem(sizeof(struct t_func), 100);
  if (state-&gt;tv_rxn_mem == NULL)
    return 1;
  for (int n_rxn_bin = 0; n_rxn_bin &lt; state-&gt;rxn_sym_table-&gt;n_bins;
       n_rxn_bin++) {
    for (struct sym_entry *sym = state-&gt;rxn_sym_table-&gt;entries[n_rxn_bin];
         sym != NULL; sym = sym-&gt;next) {
      struct rxn *reaction = (struct rxn *)sym-&gt;value;
      reaction-&gt;next = NULL;
      for (path = reaction-&gt;pathway_head; path != NULL; path = path-&gt;next) {
        check_duplicate_special_reactions(path);
        if (reaction-&gt;n_reactants &gt; 1) {
          struct species *temp_sp;
          if ((path-&gt;reactant1-&gt;flags &amp; IS_SURFACE) != 0) {
            temp_sp = path-&gt;reactant1;
            path-&gt;reactant1 = path-&gt;reactant2;
            path-&gt;reactant2 = temp_sp;
            geom = path-&gt;orientation1;
            path-&gt;orientation1 = path-&gt;orientation2;
            path-&gt;orientation2 = geom;
          }
          if (reaction-&gt;n_reactants &gt; 2) {
            if ((path-&gt;reactant2-&gt;flags &amp; IS_SURFACE) != 0) {
              temp_sp = path-&gt;reactant3;
              path-&gt;reactant3 = path-&gt;reactant2;
              path-&gt;reactant2 = temp_sp;
              geom = path-&gt;orientation3;
              path-&gt;orientation3 = path-&gt;orientation2;
              path-&gt;orientation2 = geom;
            }
          }
          alphabetize_pathway(path, reaction);
        } 
      } 
      struct rxn *rx = split_reaction(reaction);
      sym-&gt;value = (void *)rx;
      while (rx != NULL) {
        double pb_factor = 0.0;
        check_reaction_for_duplicate_pathways(&amp;rx-&gt;pathway_head);
        num_rx++;
        rx-&gt;product_idx = CHECKED_MALLOC_ARRAY(u_int, rx-&gt;n_pathways + 1,
                                               "reaction product index array");
        rx-&gt;cum_probs = CHECKED_MALLOC_ARRAY(
            double, rx-&gt;n_pathways, "reaction cumulative probabilities array");
        if (rx-&gt;product_idx == NULL || rx-&gt;cum_probs == NULL)
          return 1;
        int n_prob_t_rxns = 0;         path = rx-&gt;pathway_head;
        for (int n_pathway = 0; path != NULL; n_pathway++, path = path-&gt;next) {
          rx-&gt;product_idx[n_pathway] = 0;
          if ( path-&gt;reactant2 != NULL
               &amp;&amp; (path-&gt;reactant2-&gt;flags &amp; IS_SURFACE) != 0
               &amp;&amp; path-&gt;km &gt;= 0.0
               &amp;&amp; ( ( path-&gt;product_head == NULL &amp;&amp; (path-&gt;flags &amp; PATHW_CLAMP_CONC) != 0 )
                  ||
                  ( path-&gt;product_head == NULL &amp;&amp; (path-&gt;flags &amp; PATHW_CLAMP_FLUX) != 0 ) )
             ) {
            struct clamp_data *cdp;
            if (n_pathway != 0 || path-&gt;next != NULL)
              mcell_warn("Mixing surface modes with other surface reactions.  "
                         "Please don't.");
            if (path-&gt;km &gt; 0) {
              cdp = CHECKED_MALLOC_STRUCT(struct clamp_data,
                                          "clamp data");
              if (cdp == NULL)
                return 1;
              cdp-&gt;surf_class = path-&gt;reactant2;
              cdp-&gt;mol = path-&gt;reactant1;
              cdp-&gt;clamp_value = path-&gt;km;
              if ((path-&gt;flags &amp; PATHW_CLAMP_CONC) != 0) {
                cdp-&gt;clamp_type = CLAMP_TYPE_CONC;
              }
              else {
                cdp-&gt;clamp_type = CLAMP_TYPE_FLUX;
              }
              if (path-&gt;orientation1 * path-&gt;orientation2 == 0) {
                cdp-&gt;orient = 0;
              } else {
                cdp-&gt;orient =
                    (path-&gt;orientation1 == path-&gt;orientation2) ? 1 : -1;
              }
              cdp-&gt;sides = NULL;
              cdp-&gt;next_mol = NULL;
              cdp-&gt;next_obj = NULL;
              cdp-&gt;objp = NULL;
              cdp-&gt;n_sides = 0;
              cdp-&gt;side_idx = NULL;
              cdp-&gt;cum_area = NULL;
              cdp-&gt;scaling_factor = 0.0;
              cdp-&gt;next = state-&gt;clamp_list;
              state-&gt;clamp_list = cdp;
            }
            path-&gt;clamp_concentration = path-&gt;km;             path-&gt;km = GIGANTIC;
            if ((path-&gt;flags &amp; PATHW_CLAMP_FLUX) != 0) {
              rx-&gt;n_pathways = RX_REFLEC;
              if (path-&gt;reactant2 != NULL &amp;&amp;
                  (path-&gt;reactant2-&gt;flags &amp; IS_SURFACE) &amp;&amp;
                  (path-&gt;reactant1-&gt;flags &amp; ON_GRID)) {
                path-&gt;reactant1-&gt;flags |= CAN_REGION_BORDER;
              }
            }
          } else if ((path-&gt;flags &amp; PATHW_TRANSP) != 0) {
            rx-&gt;n_pathways = RX_TRANSP;
            if (path-&gt;reactant2 != NULL &amp;&amp;
                (path-&gt;reactant2-&gt;flags &amp; IS_SURFACE) &amp;&amp;
                (path-&gt;reactant1-&gt;flags &amp; ON_GRID)) {
              path-&gt;reactant1-&gt;flags |= CAN_REGION_BORDER;
            }
          } else if ((path-&gt;flags &amp; PATHW_REFLEC) != 0) {
            rx-&gt;n_pathways = RX_REFLEC;
            if (path-&gt;reactant2 != NULL &amp;&amp;
                (path-&gt;reactant2-&gt;flags &amp; IS_SURFACE) &amp;&amp;
                (path-&gt;reactant1-&gt;flags &amp; ON_GRID)) {
              path-&gt;reactant1-&gt;flags |= CAN_REGION_BORDER;
            }
          } else if (path-&gt;reactant2 != NULL &amp;&amp;
                     (path-&gt;reactant2-&gt;flags &amp; IS_SURFACE) &amp;&amp;
                     (path-&gt;reactant1-&gt;flags &amp; ON_GRID) &amp;&amp;
                     (path-&gt;product_head == NULL) &amp;&amp;
                     (path-&gt;flags &amp; PATHW_ABSORP)) {
            rx-&gt;n_pathways = RX_ABSORB_REGION_BORDER;
            path-&gt;reactant1-&gt;flags |= CAN_REGION_BORDER;
          } else if ((strcmp(path-&gt;reactant1-&gt;sym-&gt;name,
                             "ALL_SURFACE_MOLECULES") == 0)) {
            if (path-&gt;reactant2 != NULL &amp;&amp;
                (path-&gt;reactant2-&gt;flags &amp; IS_SURFACE) &amp;&amp;
                (path-&gt;product_head == NULL) &amp;&amp; (path-&gt;flags &amp; PATHW_ABSORP)) {
              rx-&gt;n_pathways = RX_ABSORB_REGION_BORDER;
              path-&gt;reactant1-&gt;flags |= CAN_REGION_BORDER;
            }
          }
          if (path-&gt;km_filename == NULL)
            rx-&gt;cum_probs[n_pathway] = path-&gt;km;
          else {
            rx-&gt;cum_probs[n_pathway] = 0;
            n_prob_t_rxns++;
          }
          int recycled1 = 0;
          int recycled2 = 0;
          int recycled3 = 0;
          for (prod = path-&gt;product_head; prod != NULL; prod = prod-&gt;next) {
            if (recycled1 == 0 &amp;&amp; prod-&gt;prod == path-&gt;reactant1)
              recycled1 = 1;
            else if (recycled2 == 0 &amp;&amp; prod-&gt;prod == path-&gt;reactant2)
              recycled2 = 1;
            else if (recycled3 == 0 &amp;&amp; prod-&gt;prod == path-&gt;reactant3)
              recycled3 = 1;
            else
              rx-&gt;product_idx[n_pathway]++;
          }
        } 
        int num_players = rx-&gt;n_reactants;
        int kk = rx-&gt;n_pathways;
        if (kk &lt;= RX_SPECIAL)
          kk = 1;
        for (int n_pathway = 0; n_pathway &lt; kk; n_pathway++) {
          int k = rx-&gt;product_idx[n_pathway] + rx-&gt;n_reactants;
          rx-&gt;product_idx[n_pathway] = num_players;
          num_players += k;
        }
        rx-&gt;product_idx[kk] = num_players;
        rx-&gt;players = CHECKED_MALLOC_ARRAY(struct species *, num_players,
                                           "reaction players array");
        rx-&gt;geometries = CHECKED_MALLOC_ARRAY(short, num_players,
                                              "reaction geometries array");
        if (rx-&gt;players == NULL || rx-&gt;geometries == NULL)
          return 1;
        if (n_prob_t_rxns &gt; 0) {
          path = rx-&gt;pathway_head;
          for (int n_pathway = 0; path != NULL;
               n_pathway++, path = path-&gt;next) {
            if (path-&gt;km_filename != NULL) {
              if (load_rate_file(state, rx, path-&gt;km_filename, n_pathway))
                mcell_error("Failed to load rates from file '%s'.",
                            path-&gt;km_filename);
            }
            free(path-&gt;km_filename);
            path-&gt;km_filename = NULL;
          }
          rx-&gt;prob_t = (struct t_func *)ae_list_sort(
              (struct abstract_element *)rx-&gt;prob_t);
          while (rx-&gt;prob_t != NULL &amp;&amp; rx-&gt;prob_t-&gt;time &lt;= 0.0) {
            rx-&gt;cum_probs[rx-&gt;prob_t-&gt;path] = rx-&gt;prob_t-&gt;value;
            rx-&gt;prob_t = rx-&gt;prob_t-&gt;next;
          }
        } 
        path = rx-&gt;pathway_head;
        rx-&gt;players[0] = path-&gt;reactant1;
        rx-&gt;geometries[0] = path-&gt;orientation1;
        if (rx-&gt;n_reactants &gt; 1) {
          rx-&gt;players[1] = path-&gt;reactant2;
          rx-&gt;geometries[1] = path-&gt;orientation2;
          if (rx-&gt;n_reactants &gt; 2) {
            rx-&gt;players[2] = path-&gt;reactant3;
            rx-&gt;geometries[2] = path-&gt;orientation3;
          }
        }
        initialize_rxn_diffusion_functions(rx);
        rx-&gt;external_reaction_data = NULL;
        rx-&gt;product_graph_data = NULL;
        rx-&gt;reactant_graph_data = NULL;
        path = rx-&gt;pathway_head;
        int max_num_surf_products = set_product_geometries(path, rx, prod);
        pb_factor = compute_pb_factor(
            state-&gt;time_unit, state-&gt;length_unit, state-&gt;grid_density,
            state-&gt;rx_radius_3d,
            &amp;state-&gt;rxn_flags,
            &amp;state-&gt;create_shared_walls_info_flag,
            rx, max_num_surf_products);
        rx-&gt;pb_factor = pb_factor;
        path = rx-&gt;pathway_head;
        if (scale_rxn_probabilities(&amp;state-&gt;reaction_prob_limit_flag, state-&gt;notify,
                                path, rx, pb_factor))
          return 1;
        if (n_prob_t_rxns &gt; 0) {
          for (struct t_func *tp = rx-&gt;prob_t; tp != NULL; tp = tp-&gt;next)
            tp-&gt;value *= pb_factor;
        }
        if(init_reaction_info(rx) != 0)
          return MCELL_FAIL;
        for (int n_pathway = 1; n_pathway &lt; rx-&gt;n_pathways; ++n_pathway)
          rx-&gt;cum_probs[n_pathway] += rx-&gt;cum_probs[n_pathway - 1];
        if (rx-&gt;n_pathways &gt; 0)
          rx-&gt;min_noreaction_p = rx-&gt;max_fixed_p =
              rx-&gt;cum_probs[rx-&gt;n_pathways - 1];
        else
          rx-&gt;min_noreaction_p = rx-&gt;max_fixed_p = 1.0;
        rx = rx-&gt;next;
      }
    }
  }
  if (state-&gt;rxn_flags.surf_surf_reaction_flag ||
      state-&gt;rxn_flags.surf_surf_surf_reaction_flag) {
    if (state-&gt;notify-&gt;reaction_probabilities == NOTIFY_FULL)
      mcell_log("For reaction between two (or three) surface molecules the "
                "upper probability limit is given. The effective reaction "
                "probability will be recalculated dynamically during "
                "simulation.");
  }
  if (build_reaction_hash_table(&amp;state-&gt;reaction_hash, &amp;state-&gt;n_reactions,
                                state-&gt;rxn_sym_table, &amp;state-&gt;rx_hashsize,
                                num_rx))
    return 1;
  state-&gt;rx_radius_3d *= state-&gt;r_length_unit; 
  for (int n_rxn_bin = 0; n_rxn_bin &lt; state-&gt;rx_hashsize; n_rxn_bin++) {
    for (struct rxn *this_rx = state-&gt;reaction_hash[n_rxn_bin]; this_rx != NULL;
         this_rx = this_rx-&gt;next) {
      set_reaction_player_flags(this_rx);
    }
  }
#if 0
  for (int n_rxn_bin = 0; n_rxn_bin &lt; state-&gt;rx_hashsize; n_rxn_bin++) {
    for (struct rxn *this_rx = state-&gt;reaction_hash[n_rxn_bin]; this_rx != NULL;
         this_rx = this_rx-&gt;next) {
      path = this_rx-&gt;pathway_head;
      struct pathway *next_path = path;
      while (next_path != NULL) {
        next_path = path-&gt;next;
        if (path-&gt;prod_signature != NULL) {
          free(path-&gt;prod_signature);
        }
        struct product *dead_prod = path-&gt;product_head;
        struct product *nxt = dead_prod;
        while (nxt != NULL) {
          nxt = dead_prod-&gt;next;
          free(dead_prod);
          dead_prod = nxt;
        }
        free(path);
        path = next_path;
      }
      this_rx-&gt;pathway_head = NULL;
    }
  }
#endif
  add_surface_reaction_flags(state-&gt;mol_sym_table, state-&gt;all_mols, state-&gt;all_surface_mols,
                             state-&gt;all_volume_mols);
  if (state-&gt;notify-&gt;reaction_probabilities == NOTIFY_FULL)
    mcell_log_raw("\n");
  return 0;
}
MCELL_STATUS
extract_reactants(struct pathway *pathp, struct mcell_species *reactants,
                  int *num_reactants, int *num_vol_mols, int *num_surface_mols,
                  int *all_3d, int *oriented_count) {
  int reactant_idx = 0;
  struct mcell_species *current_reactant;
  for (current_reactant = reactants;
       reactant_idx &lt; 3 &amp;&amp; current_reactant != NULL;
       ++reactant_idx, current_reactant = current_reactant-&gt;next) {
    short orient = current_reactant-&gt;orient_set ? current_reactant-&gt;orient : 0;
    struct species *reactant_species =
        (struct species *)current_reactant-&gt;mol_type-&gt;value;
    if (current_reactant-&gt;orient_set) {
      ++(*oriented_count);
    }
    if (reactant_species-&gt;flags &amp; NOT_FREE) {
      *all_3d = 0;
      if (reactant_species-&gt;flags &amp; ON_GRID) {
        ++(*num_surface_mols);
      }
    } else {
      ++(*num_vol_mols);
<a name="0"></a>    }
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    switch (reactant_idx) {
    case 0:
      pathp-&gt;reactant1 = reactant_species;
      pathp-&gt;orientation1 = orient;
      break;
    case 1:
      pathp-&gt;reactant2 = reactant_species;
      pathp-&gt;orientation2 = orient;
      break;
    case 2:
      pathp-&gt;reactant3 = reactant_species;
      pathp-&gt;orientation3 = orient;
      break;</b></font>
    default:
      UNHANDLED_CASE(reactant_idx);
    }
  }
  *num_reactants = reactant_idx;
  if (current_reactant != NULL) {
    return MCELL_FAIL;
  } else {
    return MCELL_SUCCESS;
  }
}
MCELL_STATUS
extract_catalytic_arrow(struct pathway *pathp,
                        struct reaction_arrow *react_arrow, int *reactant_idx,
                        int *num_vol_mols, int *num_surface_mols, int *all_3d,
                        int *oriented_count) {
  struct species *catalyst_species =
      (struct species *)react_arrow-&gt;catalyst.mol_type-&gt;value;
  short orient =
      react_arrow-&gt;catalyst.orient_set ? react_arrow-&gt;catalyst.orient : 0;
  if (catalyst_species-&gt;flags &amp; IS_SURFACE) {
     mcell_error("a surface class may not appear inside a catalytic arrow");
    return MCELL_FAIL;
  }
  if (react_arrow-&gt;catalyst.orient_set) {
    ++(*oriented_count);
  }
  if (catalyst_species-&gt;flags &amp; NOT_FREE) {
    *all_3d = 0;
    if (catalyst_species-&gt;flags &amp; ON_GRID) {
      ++(*num_surface_mols);
    }
  } else {
    ++(*num_vol_mols);
  }
  switch (*reactant_idx) {
  case 1:
    pathp-&gt;reactant2 = (struct species *)react_arrow-&gt;catalyst.mol_type-&gt;value;
    pathp-&gt;orientation2 = orient;
    break;
  case 2:
    pathp-&gt;reactant3 = (struct species *)react_arrow-&gt;catalyst.mol_type-&gt;value;
    pathp-&gt;orientation3 = orient;
    break;
  case 0:
  default:
    return MCELL_FAIL;
  }
  ++(*reactant_idx);
  return MCELL_SUCCESS;
}
MCELL_STATUS
extract_surface(struct pathway *path, struct mcell_species *surf_class,
                int *num_reactants, unsigned int *num_surfaces,
                int *oriented_count) {
  short orient = surf_class-&gt;orient_set ? surf_class-&gt;orient : 0;
  if (surf_class-&gt;orient_set) {
    (*oriented_count)++;
  }
  switch (*num_reactants) {
  case 0:
    return MCELL_FAIL;
  case 1:
    path-&gt;reactant2 = (struct species *)surf_class-&gt;mol_type-&gt;value;
    path-&gt;orientation2 = orient;
    break;
  case 2:
    path-&gt;reactant3 = (struct species *)surf_class-&gt;mol_type-&gt;value;
    path-&gt;orientation3 = orient;
    break;
  default:
    return MCELL_FAIL;
  }
  (*num_reactants)++;
  (*num_surfaces)++;
  return MCELL_SUCCESS;
}
MCELL_STATUS
check_surface_specs(struct notifications *notify, int num_reactants,
                    int num_surfaces, int num_vol_mols, int all_3d,
                    int oriented_count) {
  if (num_surfaces &gt; 1) {
    mcell_internal_error(
        "Too many surfaces--reactions can take place on at most one surface.");
    return MCELL_FAIL;
  }
  if (num_surfaces == num_reactants) {
    mcell_error("Reactants cannot consist entirely of surfaces.  Use a surface "
                "release site instead!");
    return MCELL_FAIL;
  }
  if ((num_vol_mols == 2) &amp;&amp; (num_surfaces == 1)) {
    mcell_error(
        "Reaction between two volume molecules and a surface is not defined.");
    return MCELL_FAIL;
  }
  if (all_3d) {
    if (oriented_count != 0) {
      if (notify-&gt;useless_vol_orient == WARN_ERROR) {
        mcell_error("Orientation specified for molecule in reaction in volume");
        return MCELL_FAIL;
      } else if (notify-&gt;useless_vol_orient == WARN_WARN) {
        mcell_warn("Orientation specified for molecule in reaction in volume");
      }
    }
  } else {
    if (num_reactants != oriented_count) {
      if (notify-&gt;missed_surf_orient == WARN_ERROR) {
        mcell_error("Orientation not specified for molecule in reaction "
                    "at surface\n  (use ; or ', or ,' for random orientation)");
        return MCELL_FAIL;
      } else if (notify-&gt;missed_surf_orient == WARN_WARN) {
        mcell_warn("Orientation not specified for molecule in reaction at "
                   "surface\n  (use ; or ', or ,' for random orientation)");
      }
    }
  }
  return MCELL_SUCCESS;
}
MCELL_STATUS
add_catalytic_species_to_products(struct pathway *path, int catalytic,
                                  int bidirectional, int all_3d) {
<a name="1"></a>  struct species *catalyst;
  short catalyst_orient;
  switch (catalytic) {
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  case 0:
    catalyst = path-&gt;reactant1;
    catalyst_orient = path-&gt;orientation1;
    break;
  case 1:
    catalyst = path-&gt;reactant2;
    catalyst_orient = path-&gt;orientation2;
    break;
  case 2:
    catalyst = path-&gt;reactant3;
    catalyst_orient = path-&gt;orientation3;
    break;</b></font>
  default:
    mcell_internal_error("Catalytic reagent index is invalid.");
    return MCELL_FAIL;
  }
  if (bidirectional || !(catalyst-&gt;flags &amp; IS_SURFACE)) {
    struct product *prodp = (struct product *)CHECKED_MALLOC_STRUCT(
        struct product, "reaction product");
    if (prodp == NULL) {
      return MCELL_FAIL;
    }
    prodp-&gt;prod = catalyst;
    if (all_3d) {
      prodp-&gt;orientation = 0;
    } else {
      prodp-&gt;orientation = catalyst_orient;
    }
    prodp-&gt;next = path-&gt;product_head;
    path-&gt;product_head = prodp;
  }
  return MCELL_SUCCESS;
}
MCELL_STATUS
extract_products(struct notifications *notify, struct pathway *pathp,
                 struct mcell_species *products, int *num_surf_products,
                 int bidirectional,
                 int all_3d) {
  struct mcell_species *current_product;
  for (current_product = products; current_product != NULL;
       current_product = current_product-&gt;next) {
    if (current_product-&gt;mol_type == NULL)
      continue;
    struct product *prodp = (struct product *)CHECKED_MALLOC_STRUCT(
        struct product, "reaction product");
    if (prodp == NULL) {
      return MCELL_FAIL;
    }
    prodp-&gt;prod = (struct species *)current_product-&gt;mol_type-&gt;value;
    if (all_3d) {
      prodp-&gt;orientation = 0;
    } else {
      prodp-&gt;orientation = current_product-&gt;orient;
    }
    if (!bidirectional) {
      if (prodp-&gt;prod-&gt;flags &amp; IS_SURFACE) {
        mcell_error_raw("Surface_class '%s' is not allowed to be on the "
                        "product side of the reaction.",
                        prodp-&gt;prod-&gt;sym-&gt;name);
        free(prodp);
        return MCELL_FAIL;
      }
    }
    prodp-&gt;next = pathp-&gt;product_head;
    pathp-&gt;product_head = prodp;
    if (prodp-&gt;prod-&gt;flags &amp; ON_GRID) {
      ++(*num_surf_products);
    }
    if (!(prodp-&gt;prod-&gt;flags &amp; IS_SURFACE)) {
      if (all_3d == 0) {
        if (!current_product-&gt;orient_set) {
          if (notify-&gt;missed_surf_orient == WARN_ERROR) {
            mcell_error("Product orientation not specified for molecule in "
                        "reaction at surface\n  (use ; or ', or ,' for random "
                        "orientation)");
            return MCELL_FAIL;
          } else if (notify-&gt;missed_surf_orient == WARN_WARN) {
            mcell_warn("Product orientation not specified for molecule in "
                       "reaction at surface\n  (use ; or ', or ,' for random "
                       "orientation)");
          }
        }
      } else {
        if ((prodp-&gt;prod-&gt;flags &amp; NOT_FREE) != 0) {
          mcell_error("Reaction has only volume reactants but is trying to "
                      "create a surface product");
          return MCELL_FAIL;
        }
        if (current_product-&gt;orient_set) {
          if (notify-&gt;useless_vol_orient == WARN_ERROR) {
            mcell_error("Orientation specified for molecule in reaction in "
                        "volume");
            return MCELL_FAIL;
          } else if (notify-&gt;useless_vol_orient == WARN_WARN) {
            mcell_warn("Orientation specified for molecule in reaction in "
                       "volume");
          }
        }
      }
    }
  }
  return MCELL_SUCCESS;
}
char *create_rx_name(struct pathway *p) {
  struct species *reagents[3];
  int n_reagents = 0;
  reagents[0] = p-&gt;reactant1;
  reagents[1] = p-&gt;reactant2;
  reagents[2] = p-&gt;reactant3;
  for (n_reagents = 0; n_reagents &lt; 3; ++n_reagents)
    if (reagents[n_reagents] == NULL)
      break;
  for (int i = 0; i &lt; n_reagents; ++i) {
    for (int j = i + 1; j &lt; n_reagents; ++j) {
      if (strcmp(reagents[j]-&gt;sym-&gt;name, reagents[i]-&gt;sym-&gt;name) &lt; 0) {
        struct species *tmp = reagents[j];
        reagents[j] = reagents[i];
        reagents[i] = tmp;
      }
    }
  }
  switch (n_reagents) {
  case 1:
    return alloc_sprintf("%s", reagents[0]-&gt;sym-&gt;name);
  case 2:
    return alloc_sprintf("%s+%s", reagents[0]-&gt;sym-&gt;name,
                         reagents[1]-&gt;sym-&gt;name);
  case 3:
    return alloc_sprintf("%s+%s+%s", reagents[0]-&gt;sym-&gt;name,
                         reagents[1]-&gt;sym-&gt;name, reagents[2]-&gt;sym-&gt;name);
  default:
    return NULL;
  }
}
static char *concat_rx_name(char *name1, char *name2) {
  char *rx_name;
  if (strcmp(name2, name1) &lt;= 0) {
    char *nametmp = name1;
    name1 = name2;
    name2 = nametmp;
  }
  rx_name = CHECKED_SPRINTF("%s+%s", name1, name2);
  if (rx_name == NULL)
    return NULL;
  return rx_name;
}
MCELL_STATUS invert_current_reaction_pathway(
    struct sym_table_head *rxn_sym_table,
    double vacancy_search_dist2,
    struct pathway *pathp,
    struct reaction_rate *reverse_rate,
    const char *rate_filename) {
  struct product *prodp;
  int num_surf_products = 0;
  int num_surface_mols = 0;
  int num_vol_mols = 0;
  int is_surf_class = 0;
  int all_3d = 1;   int nprods;   for (nprods = 0, prodp = pathp-&gt;product_head; prodp != NULL;
       prodp = prodp-&gt;next) {
    nprods++;
    if ((prodp-&gt;prod-&gt;flags &amp; NOT_FREE) != 0)
      all_3d = 0;
    if ((prodp-&gt;prod-&gt;flags &amp; IS_SURFACE) != 0) {
      is_surf_class = 1;
    }
  }
  if (nprods == 0) {
    return MCELL_FAIL;
  }
  if (nprods == 1 &amp;&amp; (pathp-&gt;product_head-&gt;prod-&gt;flags &amp; IS_SURFACE)) {
    return MCELL_FAIL;
  }
  if (nprods &gt; 3) {
    return MCELL_FAIL;
  }
  if (pathp-&gt;pathname != NULL) {
    return MCELL_FAIL;
  }
  if (all_3d) {
    if ((pathp-&gt;reactant1-&gt;flags &amp; NOT_FREE) != 0)
      all_3d = 0;
    if (pathp-&gt;reactant2 != NULL &amp;&amp; (pathp-&gt;reactant2-&gt;flags &amp; NOT_FREE) != 0)
      all_3d = 0;
    if (pathp-&gt;reactant3 != NULL &amp;&amp; (pathp-&gt;reactant3-&gt;flags &amp; NOT_FREE) != 0)
      all_3d = 0;
    if (!all_3d) {
      return MCELL_FAIL;
    }
  }
  prodp = pathp-&gt;product_head;
  char *inverse_name;
  if (nprods == 1) {
    inverse_name = strdup(prodp-&gt;prod-&gt;sym-&gt;name);
    if (inverse_name == NULL)
      return MCELL_FAIL;
  } else if (nprods == 2) {
    inverse_name =
        concat_rx_name(prodp-&gt;prod-&gt;sym-&gt;name, prodp-&gt;next-&gt;prod-&gt;sym-&gt;name);
  } else {
    char *tmp_inverse_name = concat_rx_name(
      prodp-&gt;prod-&gt;sym-&gt;name, prodp-&gt;next-&gt;prod-&gt;sym-&gt;name);
    if (tmp_inverse_name == NULL) {
      return MCELL_FAIL;
    }
    inverse_name =
        concat_rx_name(tmp_inverse_name, prodp-&gt;next-&gt;next-&gt;prod-&gt;sym-&gt;name);
    free(tmp_inverse_name);
  }
  if (inverse_name == NULL) {
    return MCELL_FAIL;
  }
  struct sym_entry *sym = retrieve_sym(inverse_name, rxn_sym_table);
  if (sym == NULL) {
    sym = store_sym(inverse_name, RX, rxn_sym_table, NULL);
    if (sym == NULL) {
      free(inverse_name);
      return MCELL_FAIL;
    }
  }
  free(inverse_name);
  struct rxn *rx = (struct rxn *)sym-&gt;value;
  rx-&gt;n_reactants = nprods;
  rx-&gt;n_pathways++;
  struct pathway *path = (struct pathway *)CHECKED_MALLOC_STRUCT(
    struct pathway, "reaction pathway");
  if (path == NULL) {
    return MCELL_FAIL;
  }
  path-&gt;pathname = NULL;
  path-&gt;flags = 0;
  path-&gt;reactant1 = prodp-&gt;prod;
  if ((path-&gt;reactant1-&gt;flags &amp; NOT_FREE) == 0) {
    ++num_vol_mols;
  } else {
    if (path-&gt;reactant1-&gt;flags &amp; ON_GRID) {
      ++num_surface_mols;
    }
  }
  path-&gt;orientation1 = prodp-&gt;orientation;
  path-&gt;reactant2 = NULL;
  path-&gt;reactant3 = NULL;
  path-&gt;prod_signature = NULL;
  if (nprods &gt; 1) {
    path-&gt;reactant2 = prodp-&gt;next-&gt;prod;
    if ((path-&gt;reactant2-&gt;flags &amp; NOT_FREE) == 0) {
      ++num_vol_mols;
    } else {
      if (path-&gt;reactant2-&gt;flags &amp; ON_GRID) {
        ++num_surface_mols;
      }
    }
    path-&gt;orientation2 = prodp-&gt;next-&gt;orientation;
  }
  if (nprods &gt; 2) {
    path-&gt;reactant3 = prodp-&gt;next-&gt;next-&gt;prod;
    if ((path-&gt;reactant3-&gt;flags &amp; NOT_FREE) == 0) {
      ++num_vol_mols;
    } else {
      if (path-&gt;reactant3-&gt;flags &amp; ON_GRID) {
        ++num_surface_mols;
      }
    }
    path-&gt;orientation3 = prodp-&gt;next-&gt;next-&gt;orientation;
  }
  switch (reverse_rate-&gt;rate_type) {
  case RATE_UNSET:
    free(path);
    return MCELL_FAIL;
  case RATE_CONSTANT:
    path-&gt;km = reverse_rate-&gt;v.rate_constant;
    path-&gt;km_filename = NULL;
    break;
  case RATE_FILE:
    path-&gt;km = 0.0;
    path-&gt;km_filename = (char *)rate_filename;
    free(reverse_rate-&gt;v.rate_file);
    reverse_rate-&gt;v.rate_file = NULL;
    break;
  default:
    UNHANDLED_CASE(reverse_rate-&gt;rate_type);
  }
  path-&gt;product_head = (struct product *)CHECKED_MALLOC_STRUCT(
      struct product, "reaction product");
  if (path-&gt;product_head == NULL) {
    free(path);
    return 1;
  }
  path-&gt;product_head-&gt;orientation = pathp-&gt;orientation1;
  path-&gt;product_head-&gt;prod = pathp-&gt;reactant1;
  path-&gt;product_head-&gt;next = NULL;
  if (path-&gt;product_head-&gt;prod-&gt;flags &amp; ON_GRID)
    ++num_surf_products;
  if ((pathp-&gt;reactant2 != NULL) &amp;&amp;
      ((pathp-&gt;reactant2-&gt;flags &amp; IS_SURFACE) == 0)) {
    path-&gt;product_head-&gt;next = (struct product *)CHECKED_MALLOC_STRUCT(
        struct product, "reaction product");
    if (path-&gt;product_head-&gt;next == NULL) {
      free(path);
      return 1;
    }
    path-&gt;product_head-&gt;next-&gt;orientation = pathp-&gt;orientation2;
    path-&gt;product_head-&gt;next-&gt;prod = pathp-&gt;reactant2;
    path-&gt;product_head-&gt;next-&gt;next = NULL;
    if (path-&gt;product_head-&gt;next-&gt;prod-&gt;flags &amp; ON_GRID)
      ++num_surf_products;
    if ((pathp-&gt;reactant3 != NULL) &amp;&amp;
        ((pathp-&gt;reactant3-&gt;flags &amp; IS_SURFACE) == 0)) {
      path-&gt;product_head-&gt;next-&gt;next = (struct product *)CHECKED_MALLOC_STRUCT(
          struct product, "reaction product");
      if (path-&gt;product_head-&gt;next-&gt;next == NULL) {
        free(path);
        return 1;
      }
      path-&gt;product_head-&gt;next-&gt;next-&gt;orientation = pathp-&gt;orientation3;
      path-&gt;product_head-&gt;next-&gt;next-&gt;prod = pathp-&gt;reactant3;
      path-&gt;product_head-&gt;next-&gt;next-&gt;next = NULL;
      if (path-&gt;product_head-&gt;next-&gt;next-&gt;prod-&gt;flags &amp; ON_GRID)
        ++num_surf_products;
    }
  }
  path-&gt;prod_signature = create_prod_signature(&amp;path-&gt;product_head);
  if (path-&gt;prod_signature == NULL) {
    free(path);
    return MCELL_FAIL;
  }
  if ((!distinguishable(vacancy_search_dist2, 0, EPS_C)) &amp;&amp;
      (num_surf_products &gt; num_surface_mols)) {
    if (!((num_surface_mols == 0) &amp;&amp; (num_vol_mols == 1))) {
      free(path);
      return MCELL_FAIL;
    }
  }
  if (is_surf_class) {
    prodp = pathp-&gt;product_head;
    if (prodp-&gt;prod-&gt;flags &amp; IS_SURFACE) {
      pathp-&gt;product_head = prodp-&gt;next;
      prodp-&gt;next = NULL;
    } else if (prodp-&gt;next-&gt;prod-&gt;flags &amp; IS_SURFACE) {
      prodp-&gt;next = prodp-&gt;next-&gt;next;
    } else {
      prodp-&gt;next-&gt;next = prodp-&gt;next-&gt;next-&gt;next;
    }
  }
  path-&gt;next = rx-&gt;pathway_head;
  rx-&gt;pathway_head = path;
  return 0;
}
static int sort_product_list_compare(struct product *list_item,
                                     struct product *new_item) {
  int cmp = strcmp(list_item-&gt;prod-&gt;sym-&gt;name, new_item-&gt;prod-&gt;sym-&gt;name);
  if (cmp == 0) {
    if (list_item-&gt;orientation &gt; new_item-&gt;orientation)
      cmp = -1;
    else if (list_item-&gt;orientation &lt; new_item-&gt;orientation)
      cmp = 1;
    else
      cmp = 0;
  }
  return cmp;
}
static struct product *sort_product_list(struct product *product_head) {
  struct product *iter;            struct product *result = NULL;   int cmp;
  for (struct product *current = product_head; current != NULL;
       current = next) {
    next = current-&gt;next;
    if (result == NULL) {
      current-&gt;next = result;
      result = current;
      continue;
    }
    cmp = sort_product_list_compare(result, current);
    if (cmp &gt;= 0) {
      current-&gt;next = result;
      result = current;
      continue;
    }
    else {
      iter = result;
      while (iter-&gt;next != NULL &amp;&amp; sort_product_list_compare(iter, current) &lt; 0)
        iter = iter-&gt;next;
      current-&gt;next = iter-&gt;next;
      iter-&gt;next = current;
    }
  }
  return result;
}
char *create_prod_signature(struct product **product_head) {
  char *prod_signature = NULL;
  *product_head = sort_product_list(*product_head);
  struct product *current = *product_head;
  if (current == NULL) {
    return NULL;
  }
  prod_signature = CHECKED_STRDUP(current-&gt;prod-&gt;sym-&gt;name, "product name");
  char *temp_str = NULL;
  while (current-&gt;next != NULL) {
    temp_str = prod_signature;
    prod_signature = CHECKED_SPRINTF("%s+%s", prod_signature,
                                     current-&gt;next-&gt;prod-&gt;sym-&gt;name);
    if (prod_signature == NULL) {
      if (temp_str != NULL)
        free(temp_str);
      return NULL;
    }
    if (temp_str != NULL)
      free(temp_str);
    current = current-&gt;next;
  }
  return prod_signature;
}
void check_duplicate_special_reactions(struct pathway *path) {
  if (path-&gt;next != NULL) {
    if ((path-&gt;flags &amp; PATHW_TRANSP) &amp;&amp; (path-&gt;next-&gt;flags &amp; PATHW_TRANSP)) {
      if ((path-&gt;orientation2 == path-&gt;next-&gt;orientation2) ||
          (path-&gt;orientation2 == 0) || (path-&gt;next-&gt;orientation2 == 0)) {
        mcell_error("Exact duplicates of special reaction TRANSPARENT = %s are "
                    "not allowed.  Please verify the contents of "
                    "DEFINE_SURFACE_CLASS statement.",
                    path-&gt;reactant2-&gt;sym-&gt;name);
      }
    }
    if ((path-&gt;flags &amp; PATHW_REFLEC) &amp;&amp; (path-&gt;next-&gt;flags &amp; PATHW_REFLEC)) {
      if ((path-&gt;orientation2 == path-&gt;next-&gt;orientation2) ||
          (path-&gt;orientation2 == 0) || (path-&gt;next-&gt;orientation2 == 0)) {
        mcell_error("Exact duplicates of special reaction REFLECTIVE = %s are "
                    "not allowed.  Please verify the contents of "
                    "DEFINE_SURFACE_CLASS statement.",
                    path-&gt;reactant2-&gt;sym-&gt;name);
      }
    }
    if ((path-&gt;flags &amp; PATHW_ABSORP) &amp;&amp; (path-&gt;next-&gt;flags &amp; PATHW_ABSORP)) {
      if ((path-&gt;orientation2 == path-&gt;next-&gt;orientation2) ||
          (path-&gt;orientation2 == 0) || (path-&gt;next-&gt;orientation2 == 0)) {
        mcell_error("Exact duplicates of special reaction ABSORPTIVE = %s are "
                    "not allowed.  Please verify the contents of "
                    "DEFINE_SURFACE_CLASS statement.",
                    path-&gt;reactant2-&gt;sym-&gt;name);
      }
    }
  }
}
int set_product_geometries(struct pathway *path, struct rxn *rx,
                           struct product *prod) {
  int recycled1, recycled2, recycled3;
  int k, kk, k2;
  short geom;
  struct product *prod2;
  int max_num_surf_products;   int num_surf_products_per_pathway;
  max_num_surf_products = 0;
  for (int n_pathway = 0; path != NULL; n_pathway++, path = path-&gt;next) {
    recycled1 = 0;
    recycled2 = 0;
    recycled3 = 0;
    k = rx-&gt;product_idx[n_pathway] + rx-&gt;n_reactants;
    num_surf_products_per_pathway = 0;
    for (prod = path-&gt;product_head; prod != NULL; prod = prod-&gt;next) {
      if (recycled1 == 0 &amp;&amp; prod-&gt;prod == path-&gt;reactant1) {
        recycled1 = 1;
        kk = rx-&gt;product_idx[n_pathway] + 0;
      } else if (recycled2 == 0 &amp;&amp; prod-&gt;prod == path-&gt;reactant2) {
        recycled2 = 1;
        kk = rx-&gt;product_idx[n_pathway] + 1;
      } else if (recycled3 == 0 &amp;&amp; prod-&gt;prod == path-&gt;reactant3) {
        recycled3 = 1;
        kk = rx-&gt;product_idx[n_pathway] + 2;
      } else {
        kk = k;
        k++;
      }
      if (prod-&gt;prod-&gt;flags &amp; ON_GRID)
        num_surf_products_per_pathway++;
      rx-&gt;players[kk] = prod-&gt;prod;
      if ((prod-&gt;orientation + path-&gt;orientation1) *
                  (prod-&gt;orientation - path-&gt;orientation1) ==
              0 &amp;&amp;
          prod-&gt;orientation * path-&gt;orientation1 != 0) {
        if (prod-&gt;orientation == path-&gt;orientation1)
          rx-&gt;geometries[kk] = 1;
        else
          rx-&gt;geometries[kk] = -1;
      } else if (rx-&gt;n_reactants &gt; 1 &amp;&amp;
                 (prod-&gt;orientation + path-&gt;orientation2) *
                         (prod-&gt;orientation - path-&gt;orientation2) ==
                     0 &amp;&amp;
                 prod-&gt;orientation * path-&gt;orientation2 != 0) {
        if (prod-&gt;orientation == path-&gt;orientation2)
          rx-&gt;geometries[kk] = 2;
        else
          rx-&gt;geometries[kk] = -2;
      } else if (rx-&gt;n_reactants &gt; 2 &amp;&amp;
                 (prod-&gt;orientation + path-&gt;orientation3) *
                         (prod-&gt;orientation - path-&gt;orientation3) ==
                     0 &amp;&amp;
                 prod-&gt;orientation * path-&gt;orientation3 != 0) {
        if (prod-&gt;orientation == path-&gt;orientation3)
          rx-&gt;geometries[kk] = 3;
        else
          rx-&gt;geometries[kk] = -3;
      } else {
        geom = 0;
        for (prod2 = path-&gt;product_head;
             prod2 != prod &amp;&amp; prod2 != NULL &amp;&amp; geom == 0; prod2 = prod2-&gt;next) {
          if ((prod2-&gt;orientation + prod-&gt;orientation) *
                      (prod2-&gt;orientation - prod-&gt;orientation) ==
                  0 &amp;&amp;
              prod-&gt;orientation * prod2-&gt;orientation != 0) {
            if (prod2-&gt;orientation == prod-&gt;orientation)
              geom = 1;
            else
              geom = -1;
          } else
            geom = 0;
          if (recycled1 == 1) {
            if (prod2-&gt;prod == path-&gt;reactant1) {
              recycled1 = 2;
              geom *= rx-&gt;n_reactants + 1;
            }
          } else if (recycled2 == 1) {
            if (prod2-&gt;prod == path-&gt;reactant2) {
              recycled2 = 2;
              geom *= rx-&gt;n_reactants + 2;
            }
          } else if (recycled3 == 1) {
            if (prod2-&gt;prod == path-&gt;reactant3) {
              recycled3 = 2;
              geom *= rx-&gt;n_reactants + 3;
            }
          } else {
            geom *= k2;
            k2++;
          }
        }
        rx-&gt;geometries[kk] = geom;
      }
      if (num_surf_products_per_pathway &gt; max_num_surf_products)
        max_num_surf_products = num_surf_products_per_pathway;
    }
    k = rx-&gt;product_idx[n_pathway];
    if (recycled1 == 0)
      rx-&gt;players[k] = NULL;
    if (recycled2 == 0 &amp;&amp; rx-&gt;n_reactants &gt; 1)
      rx-&gt;players[k + 1] = NULL;
    if (recycled3 == 0 &amp;&amp; rx-&gt;n_reactants &gt; 2)
      rx-&gt;players[k + 2] = NULL;
  }   return max_num_surf_products;
}
void alphabetize_pathway(struct pathway *path, struct rxn *reaction) {
  short geom, geom2;
  struct species *temp_sp, *temp_sp2;
  if ((path-&gt;reactant2-&gt;flags &amp; IS_SURFACE) == 0) {
    if (strcmp(path-&gt;reactant1-&gt;sym-&gt;name, path-&gt;reactant2-&gt;sym-&gt;name) &gt; 0) {
      temp_sp = path-&gt;reactant1;
      path-&gt;reactant1 = path-&gt;reactant2;
      path-&gt;reactant2 = temp_sp;
      geom = path-&gt;orientation1;
      path-&gt;orientation1 = path-&gt;orientation2;
      path-&gt;orientation2 = geom;
    } else if (strcmp(path-&gt;reactant1-&gt;sym-&gt;name, path-&gt;reactant2-&gt;sym-&gt;name) ==
               0) {
      if (path-&gt;orientation1 &lt; path-&gt;orientation2) {
        geom = path-&gt;orientation1;
        path-&gt;orientation1 = path-&gt;orientation2;
        path-&gt;orientation2 = geom;
      }
    }
  }
  if (reaction-&gt;n_reactants == 3) {
    if ((path-&gt;reactant3-&gt;flags &amp; IS_SURFACE) == 0) {
      if (strcmp(path-&gt;reactant1-&gt;sym-&gt;name, path-&gt;reactant3-&gt;sym-&gt;name) &gt; 0) {
        temp_sp = path-&gt;reactant1;
        geom = path-&gt;orientation1;
        path-&gt;reactant1 = path-&gt;reactant3;
        path-&gt;orientation1 = path-&gt;orientation3;
        temp_sp2 = path-&gt;reactant2;
        geom2 = path-&gt;orientation2;
        path-&gt;reactant2 = temp_sp;
        path-&gt;orientation2 = geom;
        path-&gt;reactant3 = temp_sp2;
        path-&gt;orientation3 = geom2;
      } else if (strcmp(path-&gt;reactant2-&gt;sym-&gt;name,
                        path-&gt;reactant3-&gt;sym-&gt;name) &gt; 0) {
        temp_sp = path-&gt;reactant2;
        path-&gt;reactant2 = path-&gt;reactant3;
        path-&gt;reactant3 = temp_sp;
        geom = path-&gt;orientation2;
        path-&gt;orientation2 = path-&gt;orientation3;
        path-&gt;orientation3 = geom;
      }
  }
}
static int warn_about_high_rates(struct notifications *notify, FILE *warn_file,
                                 int rate_warn, int print_once) {
  if (rate_warn) {
    if (notify-&gt;high_reaction_prob == WARN_ERROR) {
      warn_file = mcell_get_error_file();
      if (!print_once) {
        fprintf(warn_file, "\n");
        fprintf(
            warn_file,
            "Reaction probabilities generated for the following reactions:\n");
        print_once = 1;
      }
      fprintf(warn_file, "\tError: High ");
    } else {
      if (!print_once) {
        fprintf(warn_file, "\n");
        fprintf(
            warn_file,
            "Reaction probabilities generated for the following reactions:\n");
        print_once = 1;
      }
      if (notify-&gt;high_reaction_prob == WARN_WARN)
        fprintf(warn_file, "\tWarning: High ");
      else
        fprintf(warn_file, "\t");
    }
  } else {
    if (!print_once) {
      fprintf(warn_file, "\n");
      fprintf(
          warn_file,
          "Reaction probabilities generated for the following reactions:\n");
      print_once = 1;
    }
    fprintf(warn_file, "\t");
  }
  return print_once;
}
void add_surface_reaction_flags(struct sym_table_head *mol_sym_table,
                                struct species *all_mols,
                                struct species *all_surface_mols,
                                struct species *all_volume_mols) {
  struct species *temp_sp;
  if (all_mols-&gt;flags &amp; (CAN_VOLWALL | CAN_SURFWALL)) {
    for (int n_mol_bin = 0; n_mol_bin &lt; mol_sym_table-&gt;n_bins;
         n_mol_bin++) {
      for (struct sym_entry *symp = mol_sym_table-&gt;entries[n_mol_bin];
           symp != NULL; symp = symp-&gt;next) {
        temp_sp = (struct species *)symp-&gt;value;
        if (temp_sp == all_mols)
          continue;
        if (temp_sp == all_volume_mols)
          continue;
        if (temp_sp == all_surface_mols)
          continue;
        if (((temp_sp-&gt;flags &amp; NOT_FREE) == 0) &amp;&amp;
            ((temp_sp-&gt;flags &amp; CAN_VOLWALL) == 0)) {
          temp_sp-&gt;flags |= CAN_VOLWALL;
        } else if ((temp_sp-&gt;flags &amp; ON_GRID) &amp;&amp;
                   ((temp_sp-&gt;flags &amp; CAN_REGION_BORDER) == 0)) {
          temp_sp-&gt;flags |= CAN_REGION_BORDER;
        }
      }
    }
  }
  if (all_volume_mols-&gt;flags &amp; CAN_VOLWALL) {
    for (int n_mol_bin = 0; n_mol_bin &lt; mol_sym_table-&gt;n_bins;
         n_mol_bin++) {
      for (struct sym_entry *symp = mol_sym_table-&gt;entries[n_mol_bin];
           symp != NULL; symp = symp-&gt;next) {
        temp_sp = (struct species *)symp-&gt;value;
        if (temp_sp == all_mols)
          continue;
        if (temp_sp == all_volume_mols)
          continue;
        if (temp_sp == all_surface_mols)
          continue;
        if (((temp_sp-&gt;flags &amp; NOT_FREE) == 0) &amp;&amp;
            ((temp_sp-&gt;flags &amp; CAN_VOLWALL) == 0)) {
          temp_sp-&gt;flags |= CAN_VOLWALL;
        }
      }
    }
  }
  if (all_surface_mols-&gt;flags &amp; CAN_SURFWALL) {
    for (int n_mol_bin = 0; n_mol_bin &lt; mol_sym_table-&gt;n_bins;
         n_mol_bin++) {
      for (struct sym_entry *symp = mol_sym_table-&gt;entries[n_mol_bin];
           symp != NULL; symp = symp-&gt;next) {
        temp_sp = (struct species *)symp-&gt;value;
        if (temp_sp == all_mols)
          continue;
        if (temp_sp == all_volume_mols)
          continue;
        if (temp_sp == all_surface_mols)
          continue;
        if (((temp_sp-&gt;flags &amp; ON_GRID) &amp;&amp;
             ((temp_sp-&gt;flags &amp; CAN_REGION_BORDER) == 0))) {
          temp_sp-&gt;flags |= CAN_REGION_BORDER;
        }
      }
    }
  }
}
int scale_rxn_probabilities(unsigned char *reaction_prob_limit_flag,
                        struct notifications *notify,
                        struct pathway *path, struct rxn *rx,
                        double pb_factor) {
  int print_once = 0;   FILE *warn_file;
  int is_gigantic;
  double rate;
  for (int n_pathway = 0; path != NULL; n_pathway++, path = path-&gt;next) {
    int rate_notify = 0, rate_warn = 0;
    if (!distinguishable(rx-&gt;cum_probs[n_pathway], GIGANTIC, EPS_C))
      is_gigantic = 1;
    else
      is_gigantic = 0;
    if (is_gigantic)
      continue;
    rate = pb_factor * rx-&gt;cum_probs[n_pathway];
    rx-&gt;cum_probs[n_pathway] = rate;
    if ((notify-&gt;reaction_probabilities == NOTIFY_FULL &amp;&amp;
         ((rate &gt;= notify-&gt;reaction_prob_notify) ||
          (notify-&gt;reaction_prob_notify == 0.0))))
      rate_notify = 1;
    if ((notify-&gt;high_reaction_prob != WARN_COPE &amp;&amp;
         ((rate &gt;= notify-&gt;reaction_prob_warn) ||
          ((notify-&gt;reaction_prob_warn == 0.0)))))
      rate_warn = 1;
    if ((rate &gt; 1.0) &amp;&amp; (!*reaction_prob_limit_flag)) {
      *reaction_prob_limit_flag = 1;
    }
    if (rate_warn || rate_notify) {
      warn_file = mcell_get_log_file();
      print_once =
          warn_about_high_rates(notify, warn_file, rate_warn,
                                print_once);
      fprintf(warn_file, "Probability %.4e set for ", rate);
      if (rx-&gt;n_reactants == 1)
        fprintf(warn_file, "%s{%d} -&gt; ", rx-&gt;players[0]-&gt;sym-&gt;name,
                rx-&gt;geometries[0]);
      else if (rx-&gt;n_reactants == 2) {
        if (rx-&gt;players[1]-&gt;flags &amp; IS_SURFACE) {
          fprintf(warn_file, "%s{%d} @ %s{%d} -&gt; ", rx-&gt;players[0]-&gt;sym-&gt;name,
                  rx-&gt;geometries[0], rx-&gt;players[1]-&gt;sym-&gt;name,
                  rx-&gt;geometries[1]);
        } else {
          fprintf(warn_file, "%s{%d} + %s{%d} -&gt; ", rx-&gt;players[0]-&gt;sym-&gt;name,
                  rx-&gt;geometries[0], rx-&gt;players[1]-&gt;sym-&gt;name,
                  rx-&gt;geometries[1]);
        }
      } else {
        if (rx-&gt;players[2]-&gt;flags &amp; IS_SURFACE) {
          fprintf(warn_file, "%s{%d} + %s{%d}  @ %s{%d} -&gt; ",
                  rx-&gt;players[0]-&gt;sym-&gt;name, rx-&gt;geometries[0],
                  rx-&gt;players[1]-&gt;sym-&gt;name, rx-&gt;geometries[1],
                  rx-&gt;players[2]-&gt;sym-&gt;name, rx-&gt;geometries[2]);
        } else {
          fprintf(warn_file, "%s{%d} + %s{%d}  + %s{%d} -&gt; ",
                  rx-&gt;players[0]-&gt;sym-&gt;name, rx-&gt;geometries[0],
                  rx-&gt;players[1]-&gt;sym-&gt;name, rx-&gt;geometries[1],
                  rx-&gt;players[2]-&gt;sym-&gt;name, rx-&gt;geometries[2]);
        }
      }
      if (path-&gt;product_head == NULL) {
        fprintf(warn_file, "NULL ");
      } else {
        for (struct product *prod = path-&gt;product_head; prod != NULL;
             prod = prod-&gt;next) {
          fprintf(warn_file, "%s{%d} ", prod-&gt;prod-&gt;sym-&gt;name,
                  prod-&gt;orientation);
        }
      }
      fprintf(warn_file, "\n");
      if (rate_warn &amp;&amp; notify-&gt;high_reaction_prob == WARN_ERROR)
        return 1;
    }
  }
  return 0;
}
static int equivalent_geometry_for_two_reactants(int o1a, int o1b, int o2a,
                                                 int o2b) {
  if ((o1a == o1b) &amp;&amp; (o2a == o2b)) {
    return 1;
  } else if ((o1a == -o1b) &amp;&amp; (o2a == -o2b)) {
    return 1;
  }
  if (abs(o1a) != abs(o1b)) {
    if ((abs(o2a) != abs(o2b)) || ((o2a == 0) &amp;&amp; (o2b == 0))) {
      return 1;
    }
  }
  if (abs(o2a) != abs(o2b)) {
    if ((abs(o1a) != abs(o1b)) || ((o1a == 0) &amp;&amp; (o1b == 0))) {
      return 1;
    }
  }
  return 0;
}
static int equivalent_geometry(struct pathway *p1, struct pathway *p2, int n) {
  int mols_parallel_1 = SHRT_MIN + 1;       int mols_parallel_2 = SHRT_MIN + 2;       int mol_surf_parallel_1 = SHRT_MIN + 3;   int mol_surf_parallel_2 = SHRT_MIN + 4; 
  if (n &lt; 2) {
    return 1;
  } else if (n &lt; 3) {
    o11 = p1-&gt;orientation1;
    o12 = p1-&gt;orientation2;
    o21 = p2-&gt;orientation1;
    o22 = p2-&gt;orientation2;
    return equivalent_geometry_for_two_reactants(o11, o12, o21, o22);
  } else if (n &lt; 4) {
    o11 = p1-&gt;orientation1;
    o12 = p1-&gt;orientation2;
    o13 = p1-&gt;orientation3;
    o21 = p2-&gt;orientation1;
    o22 = p2-&gt;orientation2;
    o23 = p2-&gt;orientation3;
    if ((p1-&gt;reactant1 == p1-&gt;reactant2) &amp;&amp; (p2-&gt;reactant1 == p2-&gt;reactant2)) {
      if ((abs(o11) == abs(o12)) &amp;&amp; (abs(o11) == abs(o13))) {
        if (o11 == o12)
          mols_parallel_1 = 1;
        else
          mols_parallel_1 = 0;
        if (mols_parallel_1) {
          if ((o11 == -o13) || (o12 == -o13)) {
            mol_surf_parallel_1 = 0;
          } else {
            mol_surf_parallel_1 = 1;
          }
        } else {
          mol_surf_parallel_1 = 0;
        }
        if ((abs(o21) == abs(o22)) &amp;&amp; (abs(o21) == abs(o23))) {
          if (o21 == o22)
            mols_parallel_2 = 1;
          else
            mols_parallel_2 = 0;
          if (mols_parallel_2) {
            if ((o21 == -o23) || (o22 == -o23)) {
              mol_surf_parallel_2 = 0;
            } else {
              mol_surf_parallel_2 = 1;
            }
          } else {
            mol_surf_parallel_2 = 0;
          }
        }
        if ((mols_parallel_1 == mols_parallel_2) &amp;&amp;
            (mol_surf_parallel_1 == mol_surf_parallel_2)) {
          return 1;
        }
      } 
      else if ((abs(o11) == abs(o13)) || (abs(o12) == abs(o13))) {
        if ((o11 == o13) || (o12 == o13))
          mol_surf_parallel_1 = 1;
        else
          mol_surf_parallel_1 = 0;
        if ((abs(o21) != abs(o23)) || (abs(o22) != abs(o23))) {
          if ((abs(o21) == abs(o23)) || (abs(o22) == abs(o23))) {
            if ((o21 == o23) || (o22 == o23))
              mol_surf_parallel_2 = 1;
            else
              mol_surf_parallel_2 = 0;
          }
        }
        if (mol_surf_parallel_1 == mol_surf_parallel_2) {
          return 1;
        }
      } 
      else if ((abs(o11) == abs(o12)) &amp;&amp; (abs(o11) != abs(o13))) {
        if (o11 == o12)
          mols_parallel_1 = 1;
        else
          mols_parallel_1 = 0;
        if ((abs(o21) == abs(o22)) &amp;&amp; (abs(o21) != abs(o23))) {
          if (o21 == o22)
            mols_parallel_2 = 1;
          else
            mols_parallel_2 = 0;
        }
        if (mols_parallel_1 == mols_parallel_2) {
          return 1;
        }
      }
      else if ((abs(o11) != abs(o13)) &amp;&amp; (abs(o12) != abs(o13)) &amp;&amp;
               (abs(o11) != abs(o12))) {
        if ((abs(o21) != abs(o23)) &amp;&amp; (abs(o22) != abs(o23)) &amp;&amp;
            (abs(o21) != abs(o22))) {
          return 1;
        }
      } 
    } else { 
      if ((equivalent_geometry_for_two_reactants(o11, o12, o21, o22)) &amp;&amp;
          (equivalent_geometry_for_two_reactants(o12, o13, o22, o23)) &amp;&amp;
          (equivalent_geometry_for_two_reactants(o11, o13, o21, o23))) {
        return 1;
      }
    }
  } 
  return 0;
}
static struct rxn *create_sibling_reaction(struct rxn *rx) {
  struct rxn *reaction = CHECKED_MALLOC_STRUCT(struct rxn, "reaction");
  if (reaction == NULL)
    return NULL;
  reaction-&gt;next = NULL;
  reaction-&gt;sym = rx-&gt;sym;
  reaction-&gt;n_reactants = rx-&gt;n_reactants;
  reaction-&gt;get_reactant_diffusion = rx-&gt;get_reactant_diffusion;
  reaction-&gt;n_pathways = 0;
  reaction-&gt;cum_probs = NULL;
  reaction-&gt;product_idx = NULL;
  reaction-&gt;max_fixed_p = 0.0;
  reaction-&gt;min_noreaction_p = 0.0;
  reaction-&gt;pb_factor = 0.0;
  reaction-&gt;players = NULL;
  reaction-&gt;geometries = NULL;
  reaction-&gt;n_occurred = 0;
  reaction-&gt;n_skipped = 0.0;
  reaction-&gt;prob_t = NULL;
  reaction-&gt;pathway_head = NULL;
  reaction-&gt;info = NULL;
  reaction-&gt;product_graph_data = NULL;
  reaction-&gt;external_reaction_data = NULL;
  return reaction;
}
struct rxn *split_reaction(struct rxn *rx) {
  struct rxn *curr_rxn_ptr = NULL, *head = NULL, *end = NULL;
  struct rxn *reaction;
  struct pathway *to_place, *temp;
  head = end = rx;
  to_place = head-&gt;pathway_head-&gt;next;
  head-&gt;pathway_head-&gt;next = NULL;
  head-&gt;n_pathways = 1;
  while (to_place != NULL) {
    if (to_place-&gt;flags &amp;
        (PATHW_TRANSP | PATHW_REFLEC | PATHW_ABSORP | PATHW_CLAMP_CONC | PATHW_CLAMP_FLUX)) {
      reaction = create_sibling_reaction(rx);
      if (reaction == NULL)
        return NULL;
      reaction-&gt;pathway_head = to_place;
      to_place = to_place-&gt;next;
      reaction-&gt;pathway_head-&gt;next = NULL;
      ++reaction-&gt;n_pathways;
      end-&gt;next = reaction;
      end = reaction;
    } else {
      for (curr_rxn_ptr = head; curr_rxn_ptr != NULL;
           curr_rxn_ptr = curr_rxn_ptr-&gt;next) {
        if (curr_rxn_ptr-&gt;pathway_head-&gt;flags &amp;
            (PATHW_TRANSP | PATHW_REFLEC | PATHW_ABSORP))
          continue;
        if (equivalent_geometry(to_place, curr_rxn_ptr-&gt;pathway_head,
                                curr_rxn_ptr-&gt;n_reactants))
          break;
      }
      if (!curr_rxn_ptr) {
        reaction = create_sibling_reaction(rx);
        if (reaction == NULL)
          return NULL;
        end-&gt;next = reaction;
        end = reaction;
        curr_rxn_ptr = end;
      }
      temp = to_place;
      to_place = to_place-&gt;next;
      temp-&gt;next = curr_rxn_ptr-&gt;pathway_head;
      curr_rxn_ptr-&gt;pathway_head = temp;
      ++curr_rxn_ptr-&gt;n_pathways;
    }
  }
  return head;
}
void check_reaction_for_duplicate_pathways(struct pathway **head) {
  struct pathway *current, *next, **pprev;
  struct product *iter1, *iter2;
  int pathways_equivalent;   int i, j;
  int num_reactants;   int num_products;    int num_players;     int *orient_players_1,
      *orient_players_2;   int o1a, o1b, o2a, o2b;
  current = *head;
  pprev = head;
  while (current != NULL) {
    if (current-&gt;prod_signature == NULL) {
      *pprev = current-&gt;next;
      current-&gt;next = null_result;
      null_result = current;
      current = *pprev;
    } else {
      pprev = &amp;current-&gt;next;
      current = current-&gt;next;
    }
  }
  current = null_result;
  if ((current != NULL) &amp;&amp; (current-&gt;next != NULL)) {
    if (current-&gt;reactant2 == NULL)
      mcell_error("Exact duplicates of reaction %s  ----&gt; NULL are not "
                  "allowed.  Please verify that orientations of reactants are "
                  "not equivalent.",
                  current-&gt;reactant1-&gt;sym-&gt;name);
    else if (current-&gt;reactant3 == NULL)
      mcell_error("Exact duplicates of reaction %s + %s  ----&gt; NULL are not "
                  "allowed.  Please verify that orientations of reactants are "
                  "not equivalent.",
                  current-&gt;reactant1-&gt;sym-&gt;name, current-&gt;reactant2-&gt;sym-&gt;name);
    else
      mcell_error("Exact duplicates of reaction %s + %s + %s  ----&gt; NULL are "
                  "not allowed.  Please verify that orientations of reactants "
                  "are not equivalent.",
                  current-&gt;reactant1-&gt;sym-&gt;name, current-&gt;reactant2-&gt;sym-&gt;name,
                  current-&gt;reactant3-&gt;sym-&gt;name);
  }
  current = *head;
  while (current != NULL) {
    next = current-&gt;next;
    if (result == NULL ||
        (strcmp(result-&gt;prod_signature, current-&gt;prod_signature) &gt;= 0)) {
      current-&gt;next = result;
      result = current;
    } else {
      struct pathway *iter = result;
      while (iter-&gt;next != NULL &amp;&amp; (strcmp(iter-&gt;next-&gt;prod_signature,
                                           current-&gt;prod_signature) &lt; 0)) {
        iter = iter-&gt;next;
      }
      current-&gt;next = iter-&gt;next;
      iter-&gt;next = current;
    }
    current = next;
  }
  current = result;
  if (current != NULL) {
    while (current-&gt;next != NULL) {
      if (strcmp(current-&gt;prod_signature, current-&gt;next-&gt;prod_signature) == 0) {
        pathways_equivalent = 1;
        num_reactants = 0;
        num_products = 0;
        if (current-&gt;reactant1 != NULL)
          num_reactants++;
        if (current-&gt;reactant2 != NULL)
          num_reactants++;
        if (current-&gt;reactant3 != NULL)
          num_reactants++;
        iter1 = current-&gt;product_head;
        while (iter1 != NULL) {
          num_products++;
          iter1 = iter1-&gt;next;
        }
        num_players = num_reactants + num_products;
        orient_players_1 = CHECKED_MALLOC_ARRAY(int, num_players,
                                                "reaction player orientations");
        if (orient_players_1 == NULL)
          mcell_die();
        orient_players_2 = CHECKED_MALLOC_ARRAY(int, num_players,
                                                "reaction player orientations");
        if (orient_players_2 == NULL)
          mcell_die();
        if (current-&gt;reactant1 != NULL)
          orient_players_1[0] = current-&gt;orientation1;
        if (current-&gt;reactant2 != NULL)
          orient_players_1[1] = current-&gt;orientation2;
        if (current-&gt;reactant3 != NULL)
          orient_players_1[2] = current-&gt;orientation3;
        if (current-&gt;next-&gt;reactant1 != NULL)
          orient_players_2[0] = current-&gt;next-&gt;orientation1;
        if (current-&gt;next-&gt;reactant2 != NULL)
          orient_players_2[1] = current-&gt;next-&gt;orientation2;
        if (current-&gt;next-&gt;reactant3 != NULL)
          orient_players_2[2] = current-&gt;next-&gt;orientation3;
        iter1 = current-&gt;product_head;
        iter2 = current-&gt;next-&gt;product_head;
        for (i = num_reactants; i &lt; num_players; i++) {
          orient_players_1[i] = iter1-&gt;orientation;
          orient_players_2[i] = iter2-&gt;orientation;
          iter1 = iter1-&gt;next;
          iter2 = iter2-&gt;next;
        }
        i = 0;
        while ((i &lt; num_players) &amp;&amp; (pathways_equivalent)) {
          if (i &lt; num_reactants) {
            j = num_reactants;
          } else {
            j = i + 1;
          }
          for (; j &lt; num_players; j++) {
            o1a = orient_players_1[i];
            o1b = orient_players_1[j];
            o2a = orient_players_2[i];
            o2b = orient_players_2[j];
            if (!equivalent_geometry_for_two_reactants(o1a, o1b, o2a, o2b)) {
              pathways_equivalent = 0;
              break;
            }
          }
          i++;
        }
        if (pathways_equivalent) {
          if (current-&gt;reactant1 != NULL) {
            if (current-&gt;reactant2 == NULL)
              mcell_error("Exact duplicates of reaction %s  ----&gt; %s are not "
                          "allowed.  Please verify that orientations of "
                          "reactants are not equivalent.",
                          current-&gt;reactant1-&gt;sym-&gt;name, current-&gt;prod_signature);
            else if (current-&gt;reactant3 == NULL)
              mcell_error("Exact duplicates of reaction %s + %s  ----&gt; %s are "
                          "not allowed.  Please verify that orientations of "
                          "reactants are not equivalent.",
                          current-&gt;reactant1-&gt;sym-&gt;name,
                          current-&gt;reactant2-&gt;sym-&gt;name, current-&gt;prod_signature);
            else
              mcell_error("Exact duplicates of reaction %s + %s + %s  ----&gt; %s "
                          "are not allowed.  Please verify that orientations of "
                          "reactants are not equivalent.",
                          current-&gt;reactant1-&gt;sym-&gt;name,
                          current-&gt;reactant2-&gt;sym-&gt;name,
                          current-&gt;reactant3-&gt;sym-&gt;name, current-&gt;prod_signature);
          }
        }
        free(orient_players_1);
        free(orient_players_2);
      }
      current = current-&gt;next;
    }
  }
  if (null_result == NULL) {
    *head = result;
  } else if (result == NULL) {
    *head = null_result;
  } else {
    current = result;
    while (current-&gt;next != NULL) {
      current = current-&gt;next;
    }
    current-&gt;next = null_result;
    null_result-&gt;next = NULL;
    *head = result;
  }
}
void set_reaction_player_flags(struct rxn *rx) {
  switch (rx-&gt;n_reactants) {
  case 1:
    return;
  case 2:
    if (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_MOLECULES") == 0) {
      rx-&gt;players[0]-&gt;flags |= (CAN_VOLWALL | CAN_SURFWALL);
    } else if (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_VOLUME_MOLECULES") == 0) {
      rx-&gt;players[0]-&gt;flags |= CAN_VOLWALL;
    } else if (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, "ALL_SURFACE_MOLECULES") ==
               0) {
      rx-&gt;players[0]-&gt;flags |= CAN_SURFWALL;
    } else if ((rx-&gt;players[0]-&gt;flags &amp; NOT_FREE) == 0) {
      if ((rx-&gt;players[1]-&gt;flags &amp; NOT_FREE) == 0) {
        rx-&gt;players[0]-&gt;flags |= CAN_VOLVOL;
        rx-&gt;players[1]-&gt;flags |= CAN_VOLVOL;
      }
      else if ((rx-&gt;players[1]-&gt;flags &amp; IS_SURFACE) != 0) {
        rx-&gt;players[0]-&gt;flags |= CAN_VOLWALL;
      }
      else if ((rx-&gt;players[1]-&gt;flags &amp; ON_GRID) != 0) {
        rx-&gt;players[0]-&gt;flags |= CAN_VOLSURF;
      }
    } else if ((rx-&gt;players[0]-&gt;flags &amp; IS_SURFACE) != 0) {
      if ((rx-&gt;players[1]-&gt;flags &amp; NOT_FREE) == 0) {
        rx-&gt;players[1]-&gt;flags |= CAN_VOLWALL;
      }
      else if ((rx-&gt;players[1]-&gt;flags &amp; ON_GRID) != 0) {
        rx-&gt;players[1]-&gt;flags |= CAN_SURFWALL;
      }
    } else if ((rx-&gt;players[0]-&gt;flags &amp; ON_GRID) != 0) {
      if ((rx-&gt;players[1]-&gt;flags &amp; NOT_FREE) == 0) {
        rx-&gt;players[1]-&gt;flags |= CAN_VOLSURF;
      }
      else if ((rx-&gt;players[1]-&gt;flags &amp; ON_GRID) != 0) {
        rx-&gt;players[0]-&gt;flags |= CAN_SURFSURF;
        rx-&gt;players[1]-&gt;flags |= CAN_SURFSURF;
      }
      else if ((rx-&gt;players[1]-&gt;flags &amp; IS_SURFACE) != 0) {
        rx-&gt;players[0]-&gt;flags |= CAN_SURFWALL;
      }
    }
    break;
  case 3:
    if ((rx-&gt;players[2]-&gt;flags &amp; IS_SURFACE) != 0) {
      if ((rx-&gt;players[0]-&gt;flags &amp; NOT_FREE) == 0) {
        if ((rx-&gt;players[1]-&gt;flags &amp; ON_GRID) != 0) {
          rx-&gt;players[0]-&gt;flags |= CAN_VOLSURF;
        }
      } else if ((rx-&gt;players[0]-&gt;flags &amp; ON_GRID) != 0) {
        if ((rx-&gt;players[1]-&gt;flags &amp; NOT_FREE) == 0) {
          rx-&gt;players[1]-&gt;flags |= CAN_VOLSURF;
        }
        else if ((rx-&gt;players[1]-&gt;flags &amp; ON_GRID) != 0) {
          rx-&gt;players[0]-&gt;flags |= CAN_SURFSURF;
          rx-&gt;players[1]-&gt;flags |= CAN_SURFSURF;
        }
      }
    } else {
      if ((rx-&gt;players[0]-&gt;flags &amp; NOT_FREE) == 0) {
        if ((rx-&gt;players[1]-&gt;flags &amp; NOT_FREE) == 0) {
          if ((rx-&gt;players[2]-&gt;flags &amp; NOT_FREE) == 0) {
            rx-&gt;players[0]-&gt;flags |= CAN_VOLVOLVOL;
            rx-&gt;players[1]-&gt;flags |= CAN_VOLVOLVOL;
            rx-&gt;players[2]-&gt;flags |= CAN_VOLVOLVOL;
          }
          else if ((rx-&gt;players[2]-&gt;flags &amp; ON_GRID) != 0) {
            rx-&gt;players[0]-&gt;flags |= CAN_VOLVOLSURF;
            rx-&gt;players[1]-&gt;flags |= CAN_VOLVOLSURF;
          }
        } else if ((rx-&gt;players[1]-&gt;flags &amp; ON_GRID) != 0) {
          if ((rx-&gt;players[2]-&gt;flags &amp; NOT_FREE) == 0) {
            rx-&gt;players[0]-&gt;flags |= CAN_VOLVOLSURF;
            rx-&gt;players[2]-&gt;flags |= CAN_VOLVOLSURF;
          }
          else if ((rx-&gt;players[2]-&gt;flags &amp; ON_GRID) != 0) {
            rx-&gt;players[0]-&gt;flags |= CAN_VOLSURFSURF;
          }
        }
      } else if ((rx-&gt;players[0]-&gt;flags &amp; ON_GRID) != 0) {
        if ((rx-&gt;players[1]-&gt;flags &amp; NOT_FREE) == 0) {
          if ((rx-&gt;players[2]-&gt;flags &amp; NOT_FREE) == 0) {
            rx-&gt;players[1]-&gt;flags |= CAN_VOLVOLSURF;
            rx-&gt;players[2]-&gt;flags |= CAN_VOLVOLSURF;
          }
          else if ((rx-&gt;players[2]-&gt;flags &amp; ON_GRID) != 0) {
            rx-&gt;players[1]-&gt;flags |= CAN_VOLSURFSURF;
          }
        } else if ((rx-&gt;players[1]-&gt;flags &amp; ON_GRID) != 0) {
          if ((rx-&gt;players[2]-&gt;flags &amp; NOT_FREE) == 0) {
            rx-&gt;players[2]-&gt;flags |= CAN_VOLSURFSURF;
          }
          else if ((rx-&gt;players[2]-&gt;flags &amp; ON_GRID) != 0) {
            rx-&gt;players[0]-&gt;flags |= CAN_SURFSURFSURF;
            rx-&gt;players[1]-&gt;flags |= CAN_SURFSURFSURF;
            rx-&gt;players[2]-&gt;flags |= CAN_SURFSURFSURF;
          }
        }
      }
    }
    break;
  default:
    break;
  }
}
int build_reaction_hash_table(
    struct rxn ***reaction_hash, int *n_reactions,
    struct sym_table_head *rxn_sym_table, int *rx_hashsize, int num_rx) {
  struct rxn **rx_tbl = NULL;
  int rx_hash;
  for (rx_hash = 2; rx_hash &lt;= num_rx &amp;&amp; rx_hash != 0; rx_hash &lt;&lt;= 1)
    ;
  rx_hash &lt;&lt;= 1;
  if (rx_hash == 0)
    rx_hash = MAX_RX_HASH;
  if (rx_hash &gt; MAX_RX_HASH)
    rx_hash = MAX_RX_HASH;
#ifdef REPORT_RXN_HASH_STATS
  mcell_log("Num rxns: %d", num_rx);
  mcell_log("Size of hash: %d", rx_hash);
#endif
  *rx_hashsize = rx_hash;
  rx_hash -= 1;
  rx_tbl = CHECKED_MALLOC_ARRAY(struct rxn *, *rx_hashsize,
                                "reaction hash table");
  if (rx_tbl == NULL)
    return 1;
  *reaction_hash = rx_tbl;
  for (int i = 0; i &lt;= rx_hash; i++)
    rx_tbl[i] = NULL;
#ifdef REPORT_RXN_HASH_STATS
  int numcoll = 0;
#endif
  for (int i = 0; i &lt; rxn_sym_table-&gt;n_bins; i++) {
    for (struct sym_entry *sym = rxn_sym_table-&gt;entries[i]; sym != NULL;
         sym = sym-&gt;next) {
      struct rxn *rx = (struct rxn *)sym-&gt;value;
      int table_slot;
      if (rx-&gt;n_reactants == 1) {
        table_slot = rx-&gt;players[0]-&gt;hashval &amp; rx_hash;
      } else {
        table_slot =
            (rx-&gt;players[0]-&gt;hashval + rx-&gt;players[1]-&gt;hashval) &amp; rx_hash;
      }
#ifdef REPORT_RXN_HASH_STATS
      if (rx_tbl[table_slot] != NULL) {
        mcell_log("Collision: %s and %s", rx_tbl[table_slot]-&gt;sym-&gt;name,
                  sym-&gt;name);
        ++numcoll;
      }
#endif
      *n_reactions = *n_reactions + 1;
      while (rx-&gt;next != NULL)
        rx = rx-&gt;next;
      rx-&gt;next = rx_tbl[table_slot];
      rx_tbl[table_slot] = (struct rxn *)sym-&gt;value;
    }
  }
#ifdef REPORT_RXN_HASH_STATS
  mcell_log("Num collisions: %d", numcoll);
#endif
  return 0;
}
struct reaction_rates mcell_create_reaction_rates(int forwardRateType,
                                                  double forwardRateConstant,
                                                  int backwardRateType,
                                                  double backwardRateConstant) {
  struct reaction_rate forwardRate;
  forwardRate.rate_type = forwardRateType;
  forwardRate.v.rate_constant = forwardRateConstant;
  struct reaction_rate backwardRate;
  backwardRate.rate_type = backwardRateType;
  backwardRate.v.rate_constant = backwardRateConstant;
  struct reaction_rates rates = { forwardRate, backwardRate };
  return rates;
}
int load_rate_file(struct volume* state, struct rxn *rx, char *fname, int path) {
  struct mem_helper *tv_rxn_mem = state-&gt;tv_rxn_mem;
  const char *RATE_SEPARATORS = "\f\n\r\t\v ,;";
  const char *FIRST_DIGIT = "+-0123456789";
  int i;
  FILE *f = fopen(fname, "r");
  if (!f)
    return 1;
  else {
    struct t_func *tp, *tp2;
    double t, rate_constant;
    char buf[2048];
    char *cp;
    int linecount = 0;
#ifdef DEBUG
    int valid_linecount = 0;
#endif
    tp2 = NULL;
    while (fgets(buf, 2048, f)) {
      linecount++;
      for (i = 0; i &lt; 2048; i++) {
        if (!strchr(RATE_SEPARATORS, buf[i]))
          break;
      }
      if (i &lt; 2048 &amp;&amp; strchr(FIRST_DIGIT, buf[i])) {
        t = strtod((buf + i), &amp;cp);
        if (cp == (buf + i))
          continue; 
        for (i = cp - buf; i &lt; 2048; i++) {
          if (!strchr(RATE_SEPARATORS, buf[i]))
            break;
        }
        if (i == 2048) {
          mcell_error(
            "a time in the rate constant file consists of too many characters "
            "(it uses 2048 or more characters).");
          return(1);
        }
        rate_constant = strtod((buf + i), &amp;cp);
        if (cp == (buf + i))
          continue; 
        if (rate_constant &lt; 0.0)
        {
          if (state-&gt;notify-&gt;neg_reaction == WARN_ERROR)
          {
            mcell_error("reaction rate constants should be zero or positive.");
            return 1;
          }
          else if (state-&gt;notify-&gt;neg_reaction == WARN_WARN) {
            mcell_warn("negative reaction rate constant %f; setting to zero "
                       "and continuing.", rate_constant);
            rate_constant = 0.0;
          }
        }
        tp = (struct t_func *)CHECKED_MEM_GET(tv_rxn_mem,
                             "time-varying reaction rate constants");
        if (tp == NULL) {
          fclose(f);
          return 1;
        }
        tp-&gt;next = NULL;
        tp-&gt;path = path;
        tp-&gt;time = convert_seconds_to_iterations(
            state-&gt;start_iterations, state-&gt;time_unit,
            state-&gt;chkpt_start_time_seconds, t);
        tp-&gt;value = rate_constant;
        tp-&gt;value_from_file = rate_constant; #ifdef DEBUG
        valid_linecount++;
#endif
        if (rx-&gt;prob_t == NULL) {
          rx-&gt;prob_t = tp;
          tp2 = tp;
        } else {
          if (tp2 == NULL) {
            tp2 = tp;
            tp-&gt;next = rx-&gt;prob_t;
            rx-&gt;prob_t = tp;
          } else {
            if (tp-&gt;time &lt; tp2-&gt;time)
              mcell_warn(
                  "In rate constants file '%s', line %d is out of sequence. "
                  "Resorting.", fname, linecount);
            tp-&gt;next = tp2-&gt;next;
            tp2-&gt;next = tp;
            tp2 = tp;
          }
        }
      }
    }
#ifdef DEBUG
    mcell_log("Read %d rate constants from file %s.", valid_linecount, fname);
#endif
    fclose(f);
  }
  return 0;
}
struct sym_entry *mcell_new_rxn_pathname(struct volume *state, char *name) {
  if ((retrieve_sym(name, state-&gt;rxpn_sym_table)) != NULL) {
    mcell_log("Named reaction pathway already defined: %s", name);
    return NULL;
  } else if ((retrieve_sym(name, state-&gt;mol_sym_table)) != NULL) {
    mcell_log("Named reaction pathway already defined as a molecule: %s", name);
    return NULL;
  }
  struct sym_entry *symp = store_sym(name, RXPN, state-&gt;rxpn_sym_table, NULL);
  if (symp == NULL) {
    mcell_log("Out of memory while creating reaction name: %s", name);
    return NULL;
  }
  return symp;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>config-win.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifndef MCELL_CONFIG_WIN_H
#define MCELL_CONFIG_WIN_H
#ifdef _MSC_VER
typedef unsigned int mode_t;
#pragma warning( disable : 4996 )
#endif
#ifndef MINGW_HAS_SECURE_API
#define MINGW_HAS_SECURE_API #endif
#undef __USE_MINGW_ANSI_STDIO
#define __USE_MINGW_ANSI_STDIO                                                 \
  1 #define PRINTF_FORMAT(arg)                                                     \
  __attribute__((__format__(                                                   \
#define PRINTF_FORMAT_V(arg) __attribute__((__format__(gnu_printf, arg, 0)))
#define WIN32_LEAN_AND_MEAN #undef _WIN32_WINNT
#define _WIN32_WINNT 0x0502
#define _CRT_SECURE_NO_WARNINGS
#include &lt;windows.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;direct.h&gt; #include &lt;errno.h&gt;
#include &lt;stdio.h&gt; #include &lt;stdint.h&gt;
#include &lt;time.h&gt;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;
#undef TRUE
#undef FALSE
#undef ERROR
#undef TRANSPARENT
#undef FILE_OVERWRITE
#undef FILE_CREATE
#ifdef _MSC_VER
#define getcwd _getcwd
#define strdup _strdup
#define va_copy(d, s) ((d) = (s))
#endif
#define UNUSED(p) ((void)(p))
#ifndef __GNUC__
#ifndef __attribute__
#define __attribute__(x) #define __restrict__
#endif
#endif
_CRTIMP errno_t __cdecl strerror_s(char *_Buf, size_t _SizeInBytes, int errnum);
inline static int strerror_r(int errnum, char *buf, size_t buflen) {
  errno_t err = strerror_s(buf, buflen, errnum);
  if (err != 0) {
    errno = err;
    return -1;
  }
  return 0;
}
inline static char *_ctime_r_helper(const time_t *timep, char *buf,
                                    size_t buflen) {
#if defined(_WIN64) || defined(_MSC_VER)
  errno_t err = _ctime64_s(buf, buflen, timep);
#else
  errno_t err = _ctime32_s(buf, buflen, timep);
#endif
  if (err != 0) {
    errno = err;
    return NULL;
  }
  return buf;
}
#define ctime_r(timep, buf)                                                    \
  _ctime_r_helper(timep, buf, sizeof(buf)) 
inline static int _is_leap_year(int y) {
  return (y &amp; 3) == 0 &amp;&amp; ((y % 25) != 0 || (y &amp; 15) == 0);
}
inline static int _iso8061_weeknum(const struct tm *timeptr) {
  int Y = timeptr-&gt;tm_year, M = timeptr-&gt;tm_mon;
  int T = timeptr-&gt;tm_mday + 4 -
          (timeptr-&gt;tm_wday == 0 ? 7 : timeptr-&gt;tm_wday);   if (M == 12 &amp;&amp; T &gt; 31) {
    return 1;
  }
  if (M == 1 &amp;&amp; T &lt; 1) {
    --Y;
    M = 12;
    T += 31;
  }
  int D = 275 * M / 9 + T - 31 +
          (M &gt; 2 ? (_is_leap_year(Y) - 2) : 0);   return 1 + D / 7;
}
inline static int _iso8061_wn_year(const struct tm *timeptr) {
  int T = timeptr-&gt;tm_mday + 4 -
          (timeptr-&gt;tm_wday == 0 ? 7 : timeptr-&gt;tm_wday);   return timeptr-&gt;tm_year + 1900 +
         ((timeptr-&gt;tm_mon == 11 &amp;&amp; T &gt; 31)
              ? +1
              : ((timeptr-&gt;tm_mon == 0 &amp;&amp; T &lt; 1) ? -1 : 0));
}
inline static void _strnlwr(char *str, size_t count) {
  for (char *end = str + count; str &lt; end; ++str) {
    *str = tolower(*str);
  }
}
inline static void _strnupr(char *str, size_t count) {
  for (char *end = str + count; str &lt; end; ++str) {
    *str = toupper(*str);
  }
}
inline static void _strnchcase(char *str, size_t count) {
  for (char *end = str + count; str &lt; end; ++str) {
    *str = isupper(*str) ? tolower(*str) : toupper(*str);
  }
}
__attribute__((__format__(
    gnu_strftime, 3,
    0))) inline static size_t _win_strftime(char *strDest, size_t maxsize,
                                            const char *format,
                                            const struct tm *timeptr) {
  struct tm t = *timeptr;
  const char *f2, *f1 = format;
  char *out = strDest, *out_end = strDest + maxsize;
  char fbuf[3] = "%%", buf[64];
  while ((f2 = strchr(f1, '%')) != NULL) {
    if (f2 - f1 &gt; out_end - out) {
      return 0;
    }
    strncpy(out, f1, f2 - f1);
    out += f2 - f1;
    ++f2;
    char flag;
    if (*f2 == '_' || *f2 == '-' || *f2 == '0' || *f2 == '^' || *f2 == '#') {
      flag = *(f2++);
    } else {
      flag = 0;
    }
    size_t width = 0;
    while (isdigit(*f2)) {
      width = 10 * (width - '0') + *(f2++);
    }
    if ((ptrdiff_t)width &gt; out_end - out) {
      return 0;
    }
    if (*f2 == 'E') {
      f2++;
    } else if (*f2 == 'O') {
      f2++;
    }
<a name="0"></a>        size_t count;
    int is_numeric = 0, is_num_space_padded = 0;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    switch (*f2) {
    case 0:
      buf[0] = '%';
      count = 1;
      break;
    case 'n':
      buf[0] = '\n';
      count = 1;
      break;
    case 't':
      buf[0] = '\t';
      count = 1;
      break;</b></font>
    case 'h':
      count = strftime(buf, ARRAYSIZE(buf), "%b", timeptr);
      break;
    case 'D':
      count = strftime(buf, ARRAYSIZE(buf), "%m/%d/%y", timeptr);
      break;
    case 'F':
      count = strftime(buf, ARRAYSIZE(buf), "%Y-%m-%d", timeptr);
      break;
    case 'r':
      count = strftime(buf, ARRAYSIZE(buf), "%I:%M:%S %p", timeptr);
      break;     case 'R':
      count = strftime(buf, ARRAYSIZE(buf), "%H:%M", timeptr);
      break;
    case 'T':
      count = strftime(buf, ARRAYSIZE(buf), "%H:%M:%S", timeptr);
      break;
    case '+':
      count = strftime(buf, ARRAYSIZE(buf), "%a %b %d %H:%M:%S %Z %Y", timeptr);
      break;
    case 'P':
      _strnlwr(buf, count = strftime(buf, ARRAYSIZE(buf), "%p", timeptr));
      break;
    case 'e':
      count = strftime(buf, ARRAYSIZE(buf), "%d", timeptr);
      is_num_space_padded = 1;
      is_numeric = 1;
      break;
    case 'k':
      count = strftime(buf, ARRAYSIZE(buf), "%H", timeptr);
      is_num_space_padded = 1;
      is_numeric = 1;
      break;
    case 'l':
      count = strftime(buf, ARRAYSIZE(buf), "%I", timeptr);
      is_num_space_padded = 1;
      is_numeric = 1;
      break;
    case 'C':
      count = _snprintf(buf, ARRAYSIZE(buf), "%02u",
                        (timeptr-&gt;tm_year + 1900) / 100);
      is_numeric = 1;
      break;
    case 'u':
      count = _snprintf(buf, ARRAYSIZE(buf), "%1u",
                        timeptr-&gt;tm_wday == 0 ? 7 : timeptr-&gt;tm_wday);
<a name="1"></a>      is_numeric = 1;
      break;
#if defined(_WIN64) || defined(_MSC_VER)
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    case 's':
      count = _snprintf(buf, ARRAYSIZE(buf), "%08Iu", mktime(&amp;t));
      is_numeric = 1;
      break;
#else
    case 's':
      count = _snprintf(buf, ARRAYSIZE(buf), "%04Iu", mktime(&amp;t));
      is_numeric = 1;
      break;
#endif
    case 'V':
      count = _snprintf(buf, ARRAYSIZE(buf), "%02u", _iso8061_weeknum(timeptr));
      is_numeric = 1;
      break;</b></font>
    case 'G':
      count = _snprintf(buf, ARRAYSIZE(buf), "%04u", _iso8061_wn_year(timeptr));
      is_numeric = 1;
      break;
    case 'g':
      count = _snprintf(buf, ARRAYSIZE(buf), "%02u",
                        _iso8061_wn_year(timeptr) % 100);
      is_numeric = 1;
      break;
    case 'd':
    case 'H':
    case 'I':
    case 'j':
    case 'm':
    case 'M':
    case 'S':
    case 'U':
    case 'w':
    case 'W':
    case 'y':
    case 'Y':
      is_numeric = 1;
      fbuf[1] = *f2;
      count = strftime(buf, ARRAYSIZE(buf), fbuf, timeptr);
      break;
    default:
      fbuf[1] = *f2;
      count = strftime(buf, ARRAYSIZE(buf), fbuf, timeptr);
      break;
    }
    size_t trim = 0;
    char padding =
        (flag == '_')
            ? ' '
            : ((flag == '0')
                   ? '0'
                   : (is_numeric ? (is_num_space_padded ? ' ' : '0') : ' '));
    if (is_numeric) {
      if (flag == '-') {
        while (trim &lt; count - 1 &amp;&amp; buf[trim] == '0') {
          ++trim;
        }
        count -= trim;
      } else if (padding == ' ') {
        for (size_t i = 0; i &lt; count - 1 &amp;&amp; buf[i] == '0'; ++i) {
          buf[i] = ' ';
        }
      }
    } else if (flag == '^') {
      _strnupr(buf, count);
    }     else if (flag == '#') {
      _strnchcase(buf, count);
    }     if ((ptrdiff_t)count &gt; out_end - out) {
      return 0;
    }
    if (count &lt; width) {
      memset(out, padding, width - count);
      out += width - count;
    }
    strncpy(out, buf + trim, count);
    out += count;
    f1 = f2 + 1;
  }
  size_t len = strlen(f1);
  strncpy(out, f1, len);
  out[len] = 0;
  return out - strDest + len;
}
#define strftime _win_strftime
#if 0
#define WSADESCRIPTION_LEN 256
#define WSASYS_STATUS_LEN 128
#define SOCKET_ERROR -1
typedef struct WSAData {
  WORD wVersion;
  WORD wHighVersion;
#ifdef _WIN64
  unsigned short iMaxSockets;
  unsigned short iMaxUdpDg;
  char *lpVendorInfo;
  char szDescription[WSADESCRIPTION_LEN + 1];
  char szSystemStatus[WSASYS_STATUS_LEN + 1];
#else
  char szDescription[WSADESCRIPTION_LEN + 1];
  char szSystemStatus[WSASYS_STATUS_LEN + 1];
  unsigned short iMaxSockets;
  unsigned short iMaxUdpDg;
  char *lpVendorInfo;
#endif
} WSADATA, *LPWSADATA;
#endif
#if 0
typedef long long int(WINAPI *FUNC_WSAStartup)(WORD wVersionRequested,
                                     LPWSADATA lpWSAData);
typedef long long int(WINAPI *FUNC_WSAGetLastError)(void);
typedef long long int(WINAPI *FUNC_gethostname)(char *name, int namelen);
static FUNC_WSAStartup WSAStartup = NULL;
static FUNC_WSAGetLastError WSAGetLastError = NULL;
static FUNC_gethostname win32gethostname = NULL;
inline static int gethostname(char *name, size_t len) {
  if (len &gt; INT_MAX) {
    errno = EINVAL;
    return -1;
  }
  if (win32gethostname == NULL) {
    HMODULE ws2 = LoadLibraryA("ws2_32");
    WSADATA wsaData;
    WSAStartup = (FUNC_WSAStartup)GetProcAddress(ws2, "WSAStartup");
    WSAGetLastError =
        (FUNC_WSAGetLastError)GetProcAddress(ws2, "WSAGetLastError");
    win32gethostname = (FUNC_gethostname)GetProcAddress(ws2, "gethostname");
    if (ws2 == NULL || WSAStartup == NULL || WSAGetLastError == NULL ||
        win32gethostname == NULL || WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0) {
      if (ws2) {
        FreeLibrary(ws2);
      }
      win32gethostname = NULL;
      errno = EPERM;
      return -1;
    }
  }
  if (win32gethostname(name, (int)len) == SOCKET_ERROR) {
    switch (WSAGetLastError()) {
    case WSAEFAULT:
      errno = name ? ENAMETOOLONG : EFAULT;
      break;
    case WSANOTINITIALISED:
    case WSAENETDOWN:
    case WSAEINPROGRESS:
      errno = EAGAIN;
      break;
    }
    return -1;
  }
  return 0;
}
#endif
#if !defined(_TIMEVAL_DEFINED) #define _TIMEVAL_DEFINED
struct timeval {
  long tv_sec;
  long tv_usec;
};
#endif
struct rusage {
  struct timeval ru_utime;   struct timeval ru_stime; };
#define RUSAGE_SELF 0
inline static int getrusage(int who, struct rusage *usage) {
  if (who != RUSAGE_SELF) {
    errno = EINVAL;
    return -1;
  }
  if (usage == NULL) {
    errno = EFAULT;
    return -1;
  }
  FILETIME ftCreation, ftExit, ftKernel, ftUser;
  if (GetProcessTimes(GetCurrentProcess(), &amp;ftCreation, &amp;ftExit, &amp;ftKernel,
                      &amp;ftUser) == 0) {
    return -1;
  }
  ULONGLONG user =
      (((ULONGLONG)ftUser.dwHighDateTime) &lt;&lt; 32) + ftUser.dwLowDateTime;
  ULONGLONG kernel =
      (((ULONGLONG)ftKernel.dwHighDateTime) &lt;&lt; 32) + ftKernel.dwLowDateTime;
  usage-&gt;ru_utime.tv_usec = (long)((user % 10000000) / 10);
  usage-&gt;ru_utime.tv_sec = (long)(user / 10000000);
  usage-&gt;ru_stime.tv_usec = (long)((kernel % 10000000) / 10);
  usage-&gt;ru_stime.tv_sec = (long)(kernel / 10000000);
  return 0;
}
static int gettimeofday(struct timeval * tp, void*)
{
    const uint64_t EPOCH = ((uint64_t) 116444736000000000ULL);
    SYSTEMTIME  system_time;
    FILETIME    file_time;
    uint64_t    time;
    GetSystemTime( &amp;system_time );
    SystemTimeToFileTime( &amp;system_time, &amp;file_time );
    time =  ((uint64_t)file_time.dwLowDateTime )      ;
    time += ((uint64_t)file_time.dwHighDateTime) &lt;&lt; 32;
    tp-&gt;tv_sec  = (long) ((time - EPOCH) / 10000000L);
    tp-&gt;tv_usec = (long) (system_time.wMilliseconds * 1000);
    return 0;
}
#if 0
#define SYMBOLIC_LINK_FLAG_FILE 0x0
#define SYMBOLIC_LINK_FLAG_DIRECTORY 0x1
typedef long long int (WINAPI *FUNC_CreateSymbolicLink)(LPCSTR lpSymlinkFileName,
                                                 LPCSTR lpTargetFileName,
                                                 DWORD dwFlags);
static FUNC_CreateSymbolicLink CreateSymbolicLink = NULL;
inline static int _win_is_dir(const char *path) {
  DWORD attr = GetFileAttributesA(path);
  return attr != INVALID_FILE_ATTRIBUTES &amp;&amp;
         (attr &amp; FILE_ATTRIBUTE_DIRECTORY) != 0;
}
inline static int symlink(const char *oldpath, const char *newpath) {
  if (CreateSymbolicLink == NULL) {
    CreateSymbolicLink = (FUNC_CreateSymbolicLink)GetProcAddress(
        GetModuleHandleA("kernel32"), "CreateSymbolicLinkA");
    if (CreateSymbolicLink == NULL) {
      errno = EPERM;
      return -1;
    }
  }
  if (!CreateSymbolicLink(newpath, oldpath, _win_is_dir(oldpath))) {
    char buf[MAX_PATH + 1];
    switch (GetLastError()) {
    case ERROR_INVALID_FUNCTION:
      errno = EPERM;
      break;
    case ERROR_INVALID_REPARSE_DATA:     case ERROR_PATH_NOT_FOUND:
      errno = strlen(getcwd(buf, sizeof(buf))) + strlen(newpath) &gt;= MAX_PATH
                  ? ENAMETOOLONG
                  : ENOENT;
      break;     case ERROR_ACCESS_DENIED:
      errno = _win_is_dir(newpath) ? EEXIST : EACCES;
    case ERROR_NOT_ENOUGH_MEMORY:
      errno = ENOMEM;
      break;
    case ERROR_WRITE_PROTECT:
      errno = EROFS;
      break;
    case ERROR_INVALID_PARAMETER:
      errno = EFAULT;
      break;
    case ERROR_DISK_FULL:
      errno = ENOSPC;
      break;
    case ERROR_ALREADY_EXISTS:
      errno = EEXIST;
      break;
    default:
      errno = EIO;
      break;
    }
    return -1;
  }
  return 0;
}
#endif
#include &lt;sys/stat.h&gt;
#ifndef FSCTL_GET_REPARSE_POINT
#define FSCTL_GET_REPARSE_POINT                                                \
  (0x00000009 &lt;&lt; 16) | (42 &lt;&lt; 2) | 0 |                                         \
      (0 &lt;&lt; 14) #endif
#define S_IFLNK 0120000
#define S_ISLNK(m) (((m) &amp; S_IFMT) == S_IFLNK)
inline static int _is_symlink(const char *path) {
  HANDLE hFile = CreateFileA(
      path, GENERIC_READ,
      FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL,
      OPEN_EXISTING, FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,
      NULL);
  if (hFile == INVALID_HANDLE_VALUE) {
    return 0;
  }
  DWORD *data = (DWORD *)malloc(MAXIMUM_REPARSE_DATA_BUFFER_SIZE), size;
  if (data == NULL) {
    CloseHandle(hFile);
    return 0;
  }
  BOOL success = DeviceIoControl(hFile, FSCTL_GET_REPARSE_POINT, NULL, 0, data,
                                 MAXIMUM_REPARSE_DATA_BUFFER_SIZE, &amp;size, NULL);
  DWORD tag = *data;
  free(data);
  CloseHandle(hFile);
  return success &amp;&amp; tag == IO_REPARSE_TAG_SYMLINK;
}
#ifdef stat
#undef stat
#undef fstat
#define stat _win_stat
#define fstat _win_fstat
struct stat {   _dev_t st_dev;
  _ino_t st_ino;
  unsigned short st_mode;
  short st_nlink;
  short st_uid;
  short st_gid;
  _dev_t st_rdev;
  __MINGW_EXTENSION __int64 st_size;
  __time64_t st_atime;
  __time64_t st_mtime;
  __time64_t st_ctime;
};
inline static int stat(const char *path, struct stat *buf) {
  int retval = _stat64(path, (struct _stat64 *)buf);
  if (retval == 0 &amp;&amp; _is_symlink(path)) {
    buf-&gt;st_mode |= S_IFLNK;
  }
  return retval;
}
inline static int fstat(int fd, struct stat *buf) {
  return _fstat64(fd, (struct _stat64 *)buf);
}
#else
inline static int _win_stat(const char *path, struct stat *buf) {
  int retval = stat(path, buf);
  if (retval == 0 &amp;&amp; _is_symlink(path)) {
    buf-&gt;st_mode |= S_IFLNK;
  }
  return retval;
}
#define stat(path, buf) _win_stat(path, buf)
#endif
#define SIGALRM 14
typedef void(__cdecl *ALARM_CB)(int);
static ALARM_CB _alarm_cb = NULL;
static HANDLE _timer = NULL;
inline static void _win_alarm_cb(PVOID lpParameter, BOOLEAN TimerOrWaitFired) {
  _timer = NULL;
  _alarm_cb(SIGALRM);
}
inline static void set_alarm_handler(ALARM_CB handler) { _alarm_cb = handler; }
inline static unsigned alarm(unsigned seconds) {
  unsigned retval = 0;
  if (_timer) {
    retval = 1;     DeleteTimerQueueTimer(NULL, _timer, NULL);
    _timer = NULL;
  }
  if (!CreateTimerQueueTimer(&amp;_timer, NULL, (WAITORTIMERCALLBACK)_win_alarm_cb,
                             NULL, seconds * 1000, 0, WT_EXECUTEONLYONCE)) {
    retval = (unsigned)-1;
  }
  return retval;
}
int _win_rename(const char *old, const char *new_name);
inline static int _win_mkdir(const char *pathname, mode_t mode) {
  UNUSED(mode);
  return mkdir(pathname);
}
#define mkdir _win_mkdir
#undef IGNORE
#undef DIFFERENCE
#endif
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
