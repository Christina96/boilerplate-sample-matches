<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for mcell_reactions.c & config-win.h</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for mcell_reactions.c & config-win.h
      </h3>
      <h1 align="center">
        1.1%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>mcell_reactions.c (0.708061%)<TH>config-win.h (3.6879432%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1411-0.html#0',2,'match1411-1.html#0',3)" NAME="0">(1714-1728)<TD><A HREF="javascript:ZweiFrames('match1411-0.html#0',2,'match1411-1.html#0',3)" NAME="0">(233-246)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1411-0.html#1',2,'match1411-1.html#1',3)" NAME="1">(1913-1924)<TD><A HREF="javascript:ZweiFrames('match1411-0.html#1',2,'match1411-1.html#1',3)" NAME="1">(305-320)</A><TD ALIGN=center><FONT COLOR="#da0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mcell_reactions.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/******************************************************************************
 *
 * Copyright (C) 2006-2017 by
 * The Salk Institute for Biological Studies and
 * Pittsburgh Supercomputing Center, Carnegie Mellon University
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 *
******************************************************************************/

#include &quot;config.h&quot;

#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;nfsim_func.h&quot;
#include &quot;diffuse_util.h&quot;
#include &quot;sym_table.h&quot;
#include &quot;logging.h&quot;
#include &quot;react_util.h&quot;
#include &quot;strfunc.h&quot;
#include &quot;react.h&quot;
#include &quot;mcell_reactions.h&quot;
#include &quot;diffuse.h&quot;
#include &quot;vol_util.h&quot;
#include &quot;mcell_structs.h&quot;

/* static helper functions */
static char *concat_rx_name(char *name1, char *name2);

MCELL_STATUS extract_reactants(struct pathway *path,
                                      struct mcell_species *reactants,
                                      int *num_reactants, int *num_vol_mols,
                                      int *num_surface_mols,
                                      int *all_3d,
                                      int *oriented_count);

static MCELL_STATUS extract_catalytic_arrow(struct pathway *path,
                                            struct reaction_arrow *react_arrow,
                                            int *num_reactants,
                                            int *num_vol_mols,
                                            int *num_surface_mols, int *all_3d,
                                            int *oriented_count);

static MCELL_STATUS extract_surface(struct pathway *path,
                                    struct mcell_species *surf_class,
                                    int *num_reactants,
                                    unsigned int *num_surfaces,
                                    int *oriented_count);

MCELL_STATUS extract_products(struct notifications *notify,
                                     struct pathway *path,
                                     struct mcell_species *products,
                                     int *num_surf_products,
                                     int bidirectional,
                                     int all_3d);

static MCELL_STATUS check_surface_specs(struct notifications *notify,
                                        int num_reactants, int num_surfaces,
                                        int num_vol_mols, int all_3d,
                                        int oriented_count);

static MCELL_STATUS add_catalytic_species_to_products(struct pathway *path,
                                                      int catalytic,
                                                      int bidirectional,
                                                      int all_3d);

static MCELL_STATUS invert_current_reaction_pathway(
    struct sym_table_head *rxn_sym_table,
    double vacancy_search_dist2,
    struct pathway *pathp,
    struct reaction_rate *reverse_rate,
    const char *rate_filename);



static char *create_prod_signature(struct product **product_head);

static void set_reaction_player_flags(struct rxn *rx);

static int build_reaction_hash_table(
  struct rxn ***reaction_hash, int *n_reactions,
  struct sym_table_head *rxn_sym_table, int *rx_hashsize, int num_rx);

static void check_reaction_for_duplicate_pathways(struct pathway **head);

static int load_rate_file(struct volume* state, struct rxn *rx, char *fname, int path);

static void add_surface_reaction_flags(struct sym_table_head *mol_sym_table,
                                       struct species *all_mols,
                                       struct species *all_surface_mols,
                                       struct species *all_volume_mols);

static void alphabetize_pathway(struct pathway *path, struct rxn *reaction);

static struct rxn *split_reaction(struct rxn *rx);

static void check_duplicate_special_reactions(struct pathway *path);

static int sort_product_list_compare(struct product *list_item,
                                     struct product *new_item);

static struct product *sort_product_list(struct product *product_head);

/*************************************************************************
 *
 * mcell_modify_multiple_rate_constants - modifies the rate constant of multiple reactions with
 * names.
 *
 *************************************************************************/
MCELL_STATUS
mcell_modify_multiple_rate_constants(struct volume *world, char **names, double *rate_constants, int n_rxns) {

  // Store what each type of reaction is
  // diffusing
  struct rxn **reactions_ud = (struct rxn **)malloc(0 * sizeof(*reactions_ud)); // Empty
  // unimolecular non-diffusing, volume
  struct rxn **reactions_undv = (struct rxn **)malloc(0 * sizeof(*reactions_undv));
  // unimolecular non-diffusing, surface
  struct rxn **reactions_unds = (struct rxn **)malloc(0 * sizeof(*reactions_unds));
  // Keep track of the size
  int n_reactions_ud=0;
  int n_reactions_undv=0;
  int n_reactions_unds=0;

  // Go through all the reactions
  int i_rxn=0;
  while(i_rxn &lt; n_rxns)
  {

    // Grab the reaction
    struct sym_table_head *rxpn_sym_table = world-&gt;rxpn_sym_table;
    struct sym_entry *sym = retrieve_sym(names[i_rxn], rxpn_sym_table);

    // If the reaction couldn't be found by name, return fail
    if (sym == NULL) 
    {
      return MCELL_FAIL;
    }

    // Found the reaction, now do the changing

    // What is the pathway that needs to be changed?
    struct rxn_pathname *rxpn = (struct rxn_pathname *)sym-&gt;value;
    // The reaction that owns this pathway
    struct rxn *reaction = rxpn-&gt;rx;  
    // The index of the pathway in this reaction
    int j = rxpn-&gt;path_num;

    // Check what type of reaction this is; store this to update the scheduler later
    int can_diffuse = distinguishable(reaction-&gt;players[0]-&gt;D, 0, EPS_C);
    if (reaction-&gt;n_reactants == 1 &amp;&amp; can_diffuse)
    {
      // unimolecular reactions w/ diffusable reactants
      reactions_ud = (struct rxn **) realloc(reactions_ud, (n_reactions_ud + 1)*sizeof(*reactions_ud));
      reactions_ud[n_reactions_ud] = reaction;
      n_reactions_ud++;
    }
    else if (((!can_diffuse) &amp;&amp; (reaction-&gt;n_reactants == 1)) || 
    ((!can_diffuse) &amp;&amp; (reaction-&gt;n_reactants == 2) &amp;&amp; (reaction-&gt;players[1]-&gt;flags == IS_SURFACE))) 
    {
      // unimolecular reactions w/ non-diffusable reactants

      // Surface or volume
      if ((reaction-&gt;players[0]-&gt;flags &amp; NOT_FREE) != 0) 
      {
        // Surface
        reactions_unds = (struct rxn **) realloc(reactions_unds, (n_reactions_unds + 1)*sizeof(*reactions_unds));
        reactions_unds[n_reactions_unds] = reaction;
        n_reactions_unds++;
      }
      else
      {
        // Volume
        reactions_undv = (struct rxn **) realloc(reactions_undv, (n_reactions_undv + 1)*sizeof(*reactions_undv));
        reactions_undv[n_reactions_undv] = reaction;
        n_reactions_undv++;
      }
    }
    
    // From the new rate constant, compute the NEW probability for this pathway
    double p = rate_constants[i_rxn] * reaction-&gt;pb_factor;

    // Find the delta_prob for this pathway
    double delta_prob;
    if (j == 0)
      delta_prob = p - reaction-&gt;cum_probs[0];
    else
      delta_prob = p - (reaction-&gt;cum_probs[j] - reaction-&gt;cum_probs[j - 1]);

    // Update the prob for this pathway, but ALSO all other pathways above it
    for (int k = j; k &lt; reaction-&gt;n_pathways; k++) 
    {
      reaction-&gt;cum_probs[k] += delta_prob;
    }
    reaction-&gt;max_fixed_p += delta_prob;
    reaction-&gt;min_noreaction_p += delta_prob;

    // Go to the next reaction that needs to be changed
    i_rxn++;
  }

  // Now, reschedule all necessary reactions at once

  // Check: are there any reactions with diffusable reactants
  if (n_reactions_ud &gt; 0) // There is at least one
  {
    for (struct storage_list *local = world-&gt;storage_head; local != NULL; local = local-&gt;next) 
    {
      struct abstract_element *head_molecule = local-&gt;store-&gt;timer-&gt;current;
      while (local-&gt;store-&gt;timer-&gt;current != NULL) 
      {
        struct abstract_molecule *am = (struct abstract_molecule *)schedule_peak(local-&gt;store-&gt;timer);

        // Go through all types of these reactions
        for (int i_reactions_ud=0; i_reactions_ud&lt;n_reactions_ud; i_reactions_ud++)
        {
          // We only want to update molecules involved in this reaction.
          // Also, skip dead molecs (props=NULL). They'll be cleaned up later.
          if ((am-&gt;properties != NULL) &amp;&amp; (am-&gt;properties-&gt;species_id == reactions_ud[i_reactions_ud]-&gt;players[0]-&gt;species_id)) 
          {
            // Setting t2=0 and ACT_CHANGE will cause the lifetime to be
            // recomputed during the next timestep
            am-&gt;t2 = 0.0;
            am-&gt;flags |= ACT_CHANGE;
          }
        }
      }
      // Reset current molecule in scheduler now that we're done &quot;peaking&quot;
      local-&gt;store-&gt;timer-&gt;current = head_molecule;
    }
  }

  // Check: are there any reactions with NON-diffusable reagents
  // Volume case
  if (n_reactions_undv &gt; 0) // There is at least one
  {
    int n_subvols = world-&gt;n_subvols;
    for (int i = 0; i &lt; n_subvols; i++) 
    {
      struct subvolume *sv = &amp;(world-&gt;subvol[i]);

      for (struct per_species_list *psl = sv-&gt;species_head; psl != NULL; psl = psl-&gt;next) 
      {
        if (psl-&gt;properties == NULL) 
        {
          continue;
        }
        for (struct volume_molecule *vm = psl-&gt;head; vm != NULL; vm = vm-&gt;next_v) 
        {
          if ((vm-&gt;properties != NULL) &amp;&amp; (vm-&gt;t &gt; world-&gt;current_iterations)) 
          {
            // Go through all types of these reactions
            for (int i_reactions_undv=0; i_reactions_undv&lt;n_reactions_undv; i_reactions_undv++)
            {
              // More efficient here would be a hash table from species_id to reaction
              if (vm-&gt;properties-&gt;species_id == reactions_undv[i_reactions_undv]-&gt;players[0]-&gt;species_id)
              { 
                for (struct storage_list *local = world-&gt;storage_head; local != NULL; local = local-&gt;next) 
                {
                  vm-&gt;flags |= ACT_CHANGE;
                  vm-&gt;t2 = 0.0;
                  schedule_reschedule(local-&gt;store-&gt;timer, vm, world-&gt;current_iterations);
                }
              }
            }
          }
        }
      }
    }
  }

  // Surface case
  if (n_reactions_unds &gt; 0) // There is at least one
  {
    int n_subvols = world-&gt;n_subvols;
    for (int i = 0; i &lt; n_subvols; i++) 
    {
      struct subvolume *sv = &amp;(world-&gt;subvol[i]);

      for (struct wall_list *wl = sv-&gt;wall_head; wl != NULL; wl = wl-&gt;next) 
      {
        struct surface_grid *grid = wl-&gt;this_wall-&gt;grid;
        if (grid != NULL) 
        {
          for (u_int tile_idx = 0; tile_idx &lt; grid-&gt;n_tiles; tile_idx++) 
          {
            if (grid-&gt;sm_list[tile_idx]) 
            {
              struct surface_molecule *sm = grid-&gt;sm_list[tile_idx]-&gt;sm;
              if ((sm-&gt;properties != NULL) &amp;&amp; (sm-&gt;t &gt; world-&gt;current_iterations)) 
              {
                // Go through all types of these reactions
                for (int i_reactions_unds=0; i_reactions_unds&lt;n_reactions_unds; i_reactions_unds++)
                {
                  // More efficient here would be a hash table from species_id to reaction
                  if (sm-&gt;properties-&gt;species_id == reactions_unds[i_reactions_unds]-&gt;players[0]-&gt;species_id)
                  {
                    for (struct storage_list *local = world-&gt;storage_head; local != NULL; local = local-&gt;next) 
                    {
                      sm-&gt;flags |= ACT_CHANGE;
                      sm-&gt;t2 = 0.0;
                      schedule_reschedule(local-&gt;store-&gt;timer, sm, world-&gt;current_iterations);
                    }
                  }
                } 
              }
            }
          }
        }
      }
    }
  }

  free(reactions_ud);
  free(reactions_undv);
  free(reactions_unds);

  return MCELL_SUCCESS;
}

/*************************************************************************
 *
 * mcell_modify_rate_constant - modifies the rate constant of a reaction with a
 * specified name. For example, if you have this: 
 *
 * vm + vm -&gt; NULL [1e7] : rxn
 *
 * then you can change the rate constant from 1e7 to 0 like this:
 *
 * mcell_modify_rate_constant(world, &quot;rxn&quot;, 0)
 *
 * NOTE: This is inefficient and needs more extensive testing
 *
 *************************************************************************/
MCELL_STATUS
mcell_modify_rate_constant(struct volume *world, char *name, double rate_constant) {

  struct sym_table_head *rxpn_sym_table = world-&gt;rxpn_sym_table;
  struct sym_entry *sym = retrieve_sym(name, rxpn_sym_table);
  if (sym == NULL) 
  {
    return MCELL_FAIL;
  }
  else 
  {
    
    // What is the pathway that needs to be changed?
    struct rxn_pathname *rxpn = (struct rxn_pathname *)sym-&gt;value;
    // The reaction that owns this pathway
    struct rxn *reaction = rxpn-&gt;rx;  
    // The index of the pathway in this reaction
    int j = rxpn-&gt;path_num;

    // From the new rate constant, compute the NEW probability for this pathway
    double p = rate_constant * reaction-&gt;pb_factor;

    // Find the delta_prob for this pathway
    double delta_prob;
    if (j == 0)
      delta_prob = p - reaction-&gt;cum_probs[0];
    else
      delta_prob = p - (reaction-&gt;cum_probs[j] - reaction-&gt;cum_probs[j - 1]);

    // Update the prob for this pathway, but ALSO all other pathways above it
    for (int k = j; k &lt; reaction-&gt;n_pathways; k++) 
    {
      reaction-&gt;cum_probs[k] += delta_prob;
    }
    reaction-&gt;max_fixed_p += delta_prob;
    reaction-&gt;min_noreaction_p += delta_prob;
 
    // Print if the flags are set
    /*
    if (world-&gt;notify-&gt;time_varying_reactions == NOTIFY_FULL &amp;&amp;
        reaction-&gt;cum_probs[j] &gt;= world-&gt;notify-&gt;reaction_prob_notify) {

      // Print the reaction probabilities
      double new_prob;
      if (j == 0)
      {
          new_prob = reaction-&gt;cum_probs[0];
      }
      else
      {
          new_prob = reaction-&gt;cum_probs[j] - reaction-&gt;cum_probs[j - 1];
      }
      // Print the new_prob
      if (reaction-&gt;n_reactants == 1) 
      {
        mcell_log_raw(&quot;Probability %.4e set for %s[%d] -&gt; &quot;, new_prob,
          reaction-&gt;players[0]-&gt;sym-&gt;name, reaction-&gt;geometries[0]);
      } 
      else if (reaction-&gt;n_reactants == 2) 
      {
        mcell_log_raw(&quot;Probability %.4e set for %s[%d] + %s[%d] -&gt; &quot;, new_prob,
          reaction-&gt;players[0]-&gt;sym-&gt;name, reaction-&gt;geometries[0],
          reaction-&gt;players[1]-&gt;sym-&gt;name, reaction-&gt;geometries[1]);
      } 
      else 
      {
        mcell_log_raw(&quot;Probability %.4e set for %s[%d] + %s[%d] + %s[%d] -&gt; &quot;,
          new_prob, reaction-&gt;players[0]-&gt;sym-&gt;name, reaction-&gt;geometries[0],
          reaction-&gt;players[1]-&gt;sym-&gt;name, reaction-&gt;geometries[1],
          reaction-&gt;players[2]-&gt;sym-&gt;name, reaction-&gt;geometries[2]);
      }
      for (unsigned int n_product = reaction-&gt;product_idx[j]; 
        n_product &lt; reaction-&gt;product_idx[j + 1]; n_product++) 
      {
          if (reaction-&gt;players[n_product] != NULL)
          {
            mcell_log_raw(&quot;%s[%d] &quot;, reaction-&gt;players[n_product]-&gt;sym-&gt;name,
                          reaction-&gt;geometries[n_product]);
          }
      }
      mcell_log_raw(&quot;\n&quot;);
    }
    */

    // This is the old code as of 01.27.2017. Fixed based on react_cond.c
    /*
    int num_path = reaction-&gt;n_pathways;
    double p = rate_constant * reaction-&gt;pb_factor;

    double delta_prob = 0;
    if (num_path &gt; 1) {
      delta_prob = \
      p - (reaction-&gt;cum_probs[num_path-1] - reaction-&gt;cum_probs[num_path-2]);
    }
    else {
      delta_prob = p - (reaction-&gt;cum_probs[num_path-1]);
    }
    reaction-&gt;cum_probs[num_path-1] += delta_prob;
    reaction-&gt;max_fixed_p += delta_prob;
    reaction-&gt;min_noreaction_p += delta_prob;
    */

    // Now reschedule all the necessary reactions

    int can_diffuse = distinguishable(reaction-&gt;players[0]-&gt;D, 0, EPS_C);
    // Need to recompute lifetimes for unimolecular reactions w/ diffusable
    // reactants.
    if (reaction-&gt;n_reactants == 1 &amp;&amp; can_diffuse) 
    {
      for (struct storage_list *local = world-&gt;storage_head; local != NULL; local = local-&gt;next) 
      {
        struct abstract_element *head_molecule = local-&gt;store-&gt;timer-&gt;current;
        while (local-&gt;store-&gt;timer-&gt;current != NULL) 
        {
          struct abstract_molecule *am = (struct abstract_molecule *)schedule_peak(local-&gt;store-&gt;timer);
          // We only want to update molecules involved in this reaction.
          // Also, skip dead molecs (props=NULL). They'll be cleaned up later.
          if ((am-&gt;properties != NULL) &amp;&amp; (am-&gt;properties-&gt;species_id == reaction-&gt;players[0]-&gt;species_id)) 
          {
            // Setting t2=0 and ACT_CHANGE will cause the lifetime to be
            // recomputed during the next timestep
            am-&gt;t2 = 0.0;
          am-&gt;flags |= ACT_CHANGE;
          }
        }
        // Reset current molecule in scheduler now that we're done &quot;peaking&quot;
        local-&gt;store-&gt;timer-&gt;current = head_molecule;
      }
    }

    // Need to recompute lifetimes for non-diffusing molecules that are
    // unimolecular or where you have a surface molecule at a surface class
    // (e.g. sm@sc-&gt;whatever). These molecules won't come up next in the
    // scheduler, so we have to hunt them all down... :(
    if (((!can_diffuse) &amp;&amp; (reaction-&gt;n_reactants == 1)) || 
      ((!can_diffuse) &amp;&amp; (reaction-&gt;n_reactants == 2) &amp;&amp; (reaction-&gt;players[1]-&gt;flags == IS_SURFACE))) 
    {
      for (struct storage_list *local = world-&gt;storage_head; local != NULL; local = local-&gt;next) 
      {
        int n_subvols = world-&gt;n_subvols;
        for (int i = 0; i &lt; n_subvols; i++) 
        {
          struct subvolume *sv = &amp;(world-&gt;subvol[i]);

          // Reschedule the surface molecules involved in the reaction
          if ((reaction-&gt;players[0]-&gt;flags &amp; NOT_FREE) != 0) 
          {
            for (struct wall_list *wl = sv-&gt;wall_head; wl != NULL; wl = wl-&gt;next) 
            {
              struct surface_grid *grid = wl-&gt;this_wall-&gt;grid;
              if (grid != NULL) 
              {
                for (u_int tile_idx = 0; tile_idx &lt; grid-&gt;n_tiles; tile_idx++) 
                {
                  if (grid-&gt;sm_list[tile_idx]) 
                  {
                    struct surface_molecule *sm = grid-&gt;sm_list[tile_idx]-&gt;sm;
                    if ((sm-&gt;properties != NULL) &amp;&amp; 
                      (sm-&gt;properties-&gt;species_id == reaction-&gt;players[0]-&gt;species_id) &amp;&amp;
                      (sm-&gt;t &gt; world-&gt;current_iterations)) 
                    {
                      sm-&gt;flags |= ACT_CHANGE;
                      sm-&gt;t2 = 0.0;
                      schedule_reschedule(local-&gt;store-&gt;timer, sm, world-&gt;current_iterations);
                    }
                  }
                } 
              }
            }   
          }
          // Reschedule the volume molecules involved in the reaction
          else 
          {
            for (struct per_species_list *psl = sv-&gt;species_head; psl != NULL; psl = psl-&gt;next) 
            {
              if (psl-&gt;properties == NULL) 
              {
                continue;
              }
              for (struct volume_molecule *vm = psl-&gt;head; vm != NULL; vm = vm-&gt;next_v) 
              {
                if ((vm-&gt;properties != NULL) &amp;&amp; 
                  (vm-&gt;properties-&gt;species_id == reaction-&gt;players[0]-&gt;species_id)  &amp;&amp;
                  (vm-&gt;t &gt; world-&gt;current_iterations)) 
                { 
                  vm-&gt;flags |= ACT_CHANGE;
                  vm-&gt;t2 = 0.0;
                  schedule_reschedule(local-&gt;store-&gt;timer, vm, world-&gt;current_iterations);
                }
              }
            }
          }
        }
      }
    }
  }

  return MCELL_SUCCESS;
}

MCELL_STATUS
mcell_add_reaction_simplified(
    struct volume *state, 
    struct mcell_species *reactants,
    struct reaction_arrow *arrow,
    struct mcell_species *surfs,
    struct mcell_species *products,
    struct reaction_rates *rates,
    struct sym_entry *pathname) {

  mcell_add_reaction(state-&gt;notify, &amp;state-&gt;r_step_release,
                     state-&gt;rxn_sym_table, state-&gt;radial_subdivisions,
                     state-&gt;vacancy_search_dist2, reactants, arrow, surfs,
                     products, pathname, rates, NULL, NULL);

  return MCELL_SUCCESS;
}

/*************************************************************************
 *
 * mcell_add_reaction add a single reaction described by reaction_def to
 * the simulations.
 *
 *************************************************************************/
MCELL_STATUS
mcell_add_reaction(struct notifications *notify,
                   double **r_step_release,
                   struct sym_table_head *rxn_sym_table,
                   u_int radial_subdivisions,
                   double vacancy_search_dist2,
                   struct mcell_species *reactants,
                   struct reaction_arrow *react_arrow,
                   struct mcell_species *surf_class,
                   struct mcell_species *products, struct sym_entry *pathname,
                   struct reaction_rates *rates,
                   const char *forward_rate_filename,
                   const char *backward_rate_filename) {
  char *rx_name;
  struct sym_entry *symp;
  int bidirectional = 0;
  int num_surf_products = 0;
  struct rxn *rxnp;

  /* Create pathway */
  struct pathway *pathp = (struct pathway *)CHECKED_MALLOC_STRUCT(
      struct pathway, &quot;reaction pathway&quot;);
  if (pathp == NULL) {
    return MCELL_FAIL;
  }
  memset(pathp, 0, sizeof(struct pathway));

  /* Scan reactants, copying into the new pathway */
  int num_vol_mols = 0;
  int num_surface_mols = 0;
  int all_3d = 1;
  int reactant_idx = 0;
  int oriented_count = 0;
  int surface = -1;
  int catalytic = -1;

  unsigned int num_surfaces = 0;

  if (react_arrow-&gt;flags &amp; ARROW_BIDIRECTIONAL) {
    bidirectional = 1;
  }

  if (extract_reactants(pathp, reactants, &amp;reactant_idx, &amp;num_vol_mols,
                        &amp;num_surface_mols, &amp;all_3d,
                        &amp;oriented_count) == MCELL_FAIL) {
    free(pathp);
    return MCELL_FAIL;
  }

  /* Grab info from the arrow */

  if (react_arrow-&gt;flags &amp; ARROW_CATALYTIC) {
    if (extract_catalytic_arrow(pathp, react_arrow, &amp;reactant_idx,
                                &amp;num_vol_mols, &amp;num_surface_mols, &amp;all_3d,
                                &amp;oriented_count) == MCELL_FAIL) {
      free(pathp);
      return MCELL_FAIL;
    }
    catalytic = reactant_idx - 1;
  }

  /* If a surface was specified, include it */
  if (surf_class-&gt;mol_type != NULL) {
    if (extract_surface(pathp, surf_class, &amp;reactant_idx, &amp;num_surfaces,
                        &amp;oriented_count) == MCELL_FAIL) {
      free(pathp);
      return MCELL_FAIL;
    }
    surface = reactant_idx - 1;
    all_3d = 0;
  }


  /* Create a reaction name for the pathway we're creating */
  rx_name = create_rx_name(pathp);
  if (rx_name == NULL) {
    free(pathp);
    mcell_error(&quot;Out of memory while creating reaction.&quot;);
    return MCELL_FAIL;
  }

  /* If this reaction doesn't exist, create it */
  if ((symp = retrieve_sym(rx_name, rxn_sym_table)) != NULL) {
    /* do nothing */
  } else if ((symp = store_sym(rx_name, RX, rxn_sym_table, NULL)) ==
             NULL) {
    free(pathp);
    free(rx_name);
    mcell_error(&quot;Out of memory while creating reaction.&quot;);
    /*return MCELL_FAIL;*/
  }
  free(rx_name);

  rxnp = (struct rxn *)symp-&gt;value;
  rxnp-&gt;n_reactants = reactant_idx;
  ++rxnp-&gt;n_pathways;

  /* Check for invalid reaction specifications */
  if (check_surface_specs(notify, rxnp-&gt;n_reactants, num_surfaces,
                          num_vol_mols, all_3d, oriented_count) == MCELL_FAIL) {
    free(pathp);
    return MCELL_FAIL;
  }

  /* Add catalytic reagents to the product list.
   *    - For unidirectional catalytic reactions - copy catalyst to products
   *      only if catalyst is not a surface_clas.
   *    - For bidirectional catalytic reactions always copy catalyst to
   *      products and take care that surface_class will not appear in the
   *      products later after inverting the reaction
   */
  if (catalytic &gt;= 0) {
    if (add_catalytic_species_to_products(pathp, catalytic, bidirectional,
                                          all_3d) == MCELL_FAIL) {
      free(pathp);
      return MCELL_FAIL;
    }
  }

  /* Add in all products */
  if (extract_products(notify, pathp, products, &amp;num_surf_products,
                       bidirectional, all_3d) == MCELL_FAIL) {
    free(pathp);
    return MCELL_FAIL;
  }
  // mem_put_list(parse_state-&gt;mol_data_list_mem, products);

  /* Attach reaction pathway name, if we have one */
  if (pathname != NULL) {
    struct rxn_pathname *rxpnp = (struct rxn_pathname *)pathname-&gt;value;
    rxpnp-&gt;rx = rxnp;
    pathp-&gt;pathname = rxpnp;
  }

  if (pathp-&gt;product_head != NULL) {
    pathp-&gt;prod_signature = create_prod_signature(&amp;pathp-&gt;product_head);
    if (pathp-&gt;prod_signature == NULL) {
      free(pathp);
      mcell_error(
          &quot;Error creating 'prod_signature' field for the reaction pathway.&quot;);
      return MCELL_FAIL;
    }
  } else
    pathp-&gt;prod_signature = NULL;

  /* Copy in forward rate */
  switch (rates-&gt;forward_rate.rate_type) {
  case RATE_UNSET:
    mcell_error_raw(&quot;File %s, Line %d: Internal error: Rate is not set&quot;,
                    __FILE__, __LINE__);
    free(pathp);
    return MCELL_FAIL;

  case RATE_CONSTANT:
    pathp-&gt;km = rates-&gt;forward_rate.v.rate_constant;
    pathp-&gt;km_filename = NULL;
    break;

  case RATE_FILE:
    pathp-&gt;km = 0.0;
    pathp-&gt;km_filename = (char *)forward_rate_filename;
    free(rates-&gt;forward_rate.v.rate_file);
    rates-&gt;forward_rate.v.rate_file = NULL;
    break;

  default:
    UNHANDLED_CASE(rates-&gt;forward_rate.rate_type);
  }

  /* Add the pathway to the list for this reaction */
  if (rates-&gt;forward_rate.rate_type == RATE_FILE) {
    struct pathway *tpp;
    if (rxnp-&gt;pathway_head == NULL) {
      rxnp-&gt;pathway_head = pathp;
      pathp-&gt;next = NULL;
    } else /* Move varying reactions to the end of the list */
    {
      for (tpp = rxnp-&gt;pathway_head;
           tpp-&gt;next != NULL &amp;&amp; tpp-&gt;next-&gt;km_filename == NULL;
           tpp = tpp-&gt;next) {
      }
      pathp-&gt;next = tpp-&gt;next;
      tpp-&gt;next = pathp;
    }
  } else {
    pathp-&gt;next = rxnp-&gt;pathway_head;
    rxnp-&gt;pathway_head = pathp;
  }

  /* If we're doing 3D releases, set up array so we can release reversibly */
  if (*r_step_release == NULL &amp;&amp; all_3d &amp;&amp; pathp-&gt;product_head != NULL) {
    *r_step_release = init_r_step_3d_release(radial_subdivisions);
    if (*r_step_release == NULL) {
      free(pathp);
      mcell_error(&quot;Out of memory building r_step array.&quot;);
      return MCELL_FAIL;
    }
  }

  /* If the vacancy search distance is zero and this reaction produces more
   * surface molecules than it comsumes, it can never succeed, except if it is
   * a volume molecule hitting the surface and producing a single surface
   * molecule.  Fail with an error message.
   */
  if ((!distinguishable(vacancy_search_dist2, 0, EPS_C)) &amp;&amp;
      (num_surf_products &gt; num_surface_mols)) {
    /* The case with one volume molecule reacting with the surface and
     * producing one surface molecule is okay.
     */
    if (num_surface_mols == 0 &amp;&amp; num_vol_mols == 1 &amp;&amp; num_surf_products == 1) {
      /* do nothing */
    } else {
      free(pathp);
      mcell_error(&quot;number of surface products exceeds number of surface &quot;
                  &quot;reactants, but VACANCY_SEARCH_DISTANCE is not specified or &quot;
                  &quot;set to zero.&quot;);
      return MCELL_FAIL;
    }
  }

  /* A non-reversible reaction may not specify a reverse reaction rate */
  if (rates-&gt;backward_rate.rate_type != RATE_UNSET &amp;&amp; !bidirectional) {
    free(pathp);
    mcell_error(&quot;reverse rate specified but the reaction isn't reversible.&quot;);
    return MCELL_FAIL;
  }

  /* Create reverse reaction if we need to */
  if (bidirectional) {
    /* A bidirectional reaction must specify a reverse rate */
    if (rates-&gt;backward_rate.rate_type == RATE_UNSET) {
      free(pathp);
      mcell_error(&quot;reversible reaction indicated but no reverse rate &quot;
                  &quot;supplied.&quot;);
      return MCELL_FAIL;
    }

    /* if &quot;surface_class&quot; is present on the reactant side of the reaction copy
     * it to the product side of the reaction.
     *
     * Reversible reaction of the type:
     *    A' @ surf' &lt;---&gt; C''[&gt;r1,&lt;r2]
     *
     * is equivalent now to the two reactions:
     *    A' @ surf' ---&gt; C'' [r1]
     *    C'' @ surf' ----&gt; A' [r2]
     *
     * Reversible reaction of the type:
     *    A' + B' @ surf' &lt;---&gt; C'' + D'' [&gt;r1,&lt;r2]
     *
     * is equivalent now to the two reactions:
     *    A' + B @ surf' ---&gt; C'' + D'' [r1]
     *    C'' + D'' @ surf' ----&gt; A' + B' [r2]
     */
    if (surface != -1 &amp;&amp; surface != catalytic) {
      struct product *prodp;
      prodp = (struct product *)CHECKED_MALLOC_STRUCT(struct product,
                                                      &quot;reaction product&quot;);
      if (prodp == NULL) {
        // mem_put(parse_state-&gt;prod_mem, prodp);
        free(pathp);
        return MCELL_FAIL;
      }

      switch (surface) {
      case 1:
        prodp-&gt;prod = pathp-&gt;reactant2;
        prodp-&gt;orientation = pathp-&gt;orientation2;
        break;

      case 2:
        prodp-&gt;prod = pathp-&gt;reactant3;
        prodp-&gt;orientation = pathp-&gt;orientation3;
        break;

      case 0:
      default:
        mcell_internal_error(
            &quot;Surface appears in invalid reactant slot in reaction (%d).&quot;,
            surface);
        /*break;*/
      }
      prodp-&gt;next = pathp-&gt;product_head;
      pathp-&gt;product_head = prodp;
    }

    /* Invert the current reaction pathway */
    if (invert_current_reaction_pathway(
        rxn_sym_table, vacancy_search_dist2, pathp,
        &amp;rates-&gt;backward_rate, backward_rate_filename)) {
      free(pathp);
      return MCELL_FAIL;
    }
  }
  //set diffusion function
  rxnp-&gt;get_reactant_diffusion = rxn_get_standard_diffusion;
  return MCELL_SUCCESS;
}

/*************************************************************************
 *
 * mcell_add_surface_reaction adds a single surface reaction described
 * by reaction_def to the simulations.
 *
 *************************************************************************/
MCELL_STATUS
mcell_add_surface_reaction(struct sym_table_head *rxn_sym_table,
                           int reaction_type, struct species *surface_class,
                           struct sym_entry *reactant_sym, short orient) {
  struct species *reactant = (struct species *)reactant_sym-&gt;value;

  /* Make sure the other reactant isn't a surface */
  if (reactant-&gt;flags == IS_SURFACE) {
    // mdlerror_fmt(parse_state,
    //             &quot;Illegal reaction between two surfaces in surface reaction:
    // %s -%s-&gt; ...&quot;,
    //             reactant_sym-&gt;name,
    //             surface_class-&gt;sym-&gt;name);
    return MCELL_FAIL;
  }

  /* Build reaction name */
  char *rx_name =
      concat_rx_name(surface_class-&gt;sym-&gt;name, reactant_sym-&gt;name);
  if (rx_name == NULL) {
    // mdlerror_fmt(parse_state,
    //             &quot;Out of memory while parsing surface reaction: %s -%s-&gt; ...&quot;,
    //             surface_class-&gt;sym-&gt;name,
    //             reactant_sym-&gt;name);
    return MCELL_FAIL;
  }

  /* Find or create reaction */
  struct sym_entry *reaction_sym;
  if ((reaction_sym = retrieve_sym(rx_name, rxn_sym_table)) != NULL) {
    /* do nothing */
  } else if ((reaction_sym =
                  store_sym(rx_name, RX, rxn_sym_table, NULL)) == NULL) {
    free(rx_name);
    // mdlerror_fmt(parse_state,
    //             &quot;Out of memory while creating surface reaction: %s -%s-&gt;
    // ...&quot;,
    //             reactant_sym-&gt;name,
    //             surface_class-&gt;sym-&gt;name);
    return MCELL_FAIL;
  }
  free(rx_name);

  /* Create pathway */
  struct pathway *pathp = (struct pathway *)CHECKED_MALLOC_STRUCT(
      struct pathway, &quot;reaction pathway&quot;);

  if (pathp == NULL)
    return MCELL_FAIL;
  memset(pathp, 0, sizeof(struct pathway));

  struct rxn *rxnp = (struct rxn *)reaction_sym-&gt;value;
  rxnp-&gt;n_reactants = 2;
  ++rxnp-&gt;n_pathways;
  pathp-&gt;pathname = NULL;
  pathp-&gt;reactant1 = surface_class;
  pathp-&gt;reactant2 = (struct species *)reactant_sym-&gt;value;
  pathp-&gt;reactant3 = NULL;
  pathp-&gt;km = GIGANTIC;
  pathp-&gt;km_filename = NULL;
  pathp-&gt;prod_signature = NULL;
  pathp-&gt;flags = 0;

  pathp-&gt;orientation1 = 1;
  pathp-&gt;orientation3 = 0;
  if (orient == 0) {
    pathp-&gt;orientation2 = 0;
  } else {
    pathp-&gt;orientation2 = (orient &lt; 0) ? -1 : 1;
  }

  struct name_orient *no;
  no = CHECKED_MALLOC_STRUCT(struct name_orient, &quot;struct name_orient&quot;);
  no-&gt;name = CHECKED_STRDUP(reactant-&gt;sym-&gt;name, &quot;reactant name&quot;);
  if (orient == 0) {
    no-&gt;orient = 0;
  } else {
    no-&gt;orient = (orient &lt; 0) ? -1 : 1;
  }

  struct product *prodp;
  switch (reaction_type) {
  case RFLCT:
    prodp = (struct product *)CHECKED_MALLOC_STRUCT(struct product,
                                                    &quot;reaction product&quot;);
    if (prodp == NULL) {
      free(no);
      free(pathp);
      return MCELL_FAIL;
    }

    pathp-&gt;flags |= PATHW_REFLEC;
    prodp-&gt;prod = pathp-&gt;reactant2;
    prodp-&gt;orientation = 1;
    prodp-&gt;next = NULL;
    pathp-&gt;product_head = prodp;
    if (pathp-&gt;product_head != NULL) {
      pathp-&gt;prod_signature = create_prod_signature(&amp;pathp-&gt;product_head);
      if (pathp-&gt;prod_signature == NULL) {
        // mdlerror(parse_state, &quot;Error creating 'prod_signature' field for the
        // reaction pathway.&quot;);
        free(no);
        free(pathp);
        return MCELL_FAIL;
      }
    }
    if (surface_class-&gt;refl_mols == NULL) {
      no-&gt;next = NULL;
      surface_class-&gt;refl_mols = no;
    } else {
      no-&gt;next = surface_class-&gt;refl_mols;
      surface_class-&gt;refl_mols = no;
    }

    break;
  case TRANSP:
    prodp = (struct product *)CHECKED_MALLOC_STRUCT(struct product,
                                                    &quot;reaction product&quot;);
    if (prodp == NULL) {
      free(no);
      free(pathp);
      return MCELL_FAIL;
    }

    pathp-&gt;flags |= PATHW_TRANSP;
    prodp-&gt;prod = pathp-&gt;reactant2;
    prodp-&gt;orientation = -1;
    prodp-&gt;next = NULL;
    pathp-&gt;product_head = prodp;
    if (pathp-&gt;product_head != NULL) {
      pathp-&gt;prod_signature = create_prod_signature(&amp;pathp-&gt;product_head);
      if (pathp-&gt;prod_signature == NULL) {
        free(no);
        free(pathp);
        return MCELL_FAIL;
      }
    }
    if (surface_class-&gt;transp_mols == NULL) {
      no-&gt;next = NULL;
      surface_class-&gt;transp_mols = no;
    } else {
      no-&gt;next = surface_class-&gt;transp_mols;
      surface_class-&gt;transp_mols = no;
    }
    break;
  case SINK:
    pathp-&gt;flags |= PATHW_ABSORP;
    pathp-&gt;product_head = NULL;
    if (surface_class-&gt;absorb_mols == NULL) {
      no-&gt;next = NULL;
      surface_class-&gt;absorb_mols = no;
    } else {
      no-&gt;next = surface_class-&gt;absorb_mols;
      surface_class-&gt;absorb_mols = no;
    }
    break;
  default:
    // mdlerror(parse_state, &quot;Unknown special surface type.&quot;);
    free(no);
    free(pathp);
    return MCELL_FAIL;
  }

  pathp-&gt;next = rxnp-&gt;pathway_head;
  rxnp-&gt;pathway_head = pathp;

  rxnp-&gt;get_reactant_diffusion = rxn_get_standard_diffusion;
  return MCELL_SUCCESS;
}

/*************************************************************************
 *
 * mcell_add_clamp adds a surface clamp to the simulation
 *
 *************************************************************************/
MCELL_STATUS
mcell_add_clamp(struct sym_table_head *rxn_sym_table,
                              struct species *surface_class,
                              struct sym_entry *mol_sym, short orient,
                              int clamp_type,
                              double clamp_value) {
  struct rxn *rxnp;
  struct pathway *pathp;
  struct sym_entry *stp3;
  struct species *specp = (struct species *)mol_sym-&gt;value;
  struct name_orient *no;

  if (specp-&gt;flags == IS_SURFACE) {
    //    mdlerror_fmt(parse_state,
    //                &quot;Illegal reaction between two surfaces in surface
    // reaction: %s -%s-&gt; ...&quot;,
    //               mol_sym-&gt;name, surface_class-&gt;sym-&gt;name);
    return MCELL_FAIL;
  }
  if (specp-&gt;flags &amp; ON_GRID) {
    // mdlerror(parse_state, &quot;Concentration clamp does not work on surface
    // molecules.&quot;);
    return MCELL_FAIL;
  }
  if (specp-&gt;flags &amp; NOT_FREE || specp-&gt;D &lt;= 0.0) {
    //    mdlerror(parse_state, &quot;Concentration clamp must be applied to molecule
    // diffusing in 3D&quot;);
    return MCELL_FAIL;
  }
  if (clamp_value &lt; 0) {
    // mdlerror(parse_state, &quot;Concentration can only be clamped to positive
    // values.&quot;);
    return MCELL_FAIL;
  }

  char *rx_name = concat_rx_name(surface_class-&gt;sym-&gt;name, mol_sym-&gt;name);
  if (rx_name == NULL) {
    //    mdlerror_fmt(parse_state,
    //                 &quot;Memory allocation error: %s -%s-&gt; ...&quot;,
    //                 surface_class-&gt;sym-&gt;name, mol_sym-&gt;name);
    return MCELL_FAIL;
  }
  if ((stp3 = retrieve_sym(rx_name, rxn_sym_table)) != NULL) {
    /* do nothing */
  } else if ((stp3 = store_sym(rx_name, RX, rxn_sym_table, NULL)) ==
             NULL) {
    free(rx_name);
    //    mdlerror_fmt(parse_state,
    //                 &quot;Cannot store surface reaction: %s -%s-&gt; ...&quot;,
    //                 mol_sym-&gt;name, surface_class-&gt;sym-&gt;name);
    return MCELL_FAIL;
  }
  free(rx_name);

  pathp = (struct pathway *)CHECKED_MALLOC_STRUCT(struct pathway,
                                                  &quot;reaction pathway&quot;);
  if (pathp == NULL)
    return MCELL_FAIL;
  memset(pathp, 0, sizeof(struct pathway));

  rxnp = (struct rxn *)stp3-&gt;value;
  rxnp-&gt;n_reactants = 2;
  ++rxnp-&gt;n_pathways;
  pathp-&gt;pathname = NULL;
  pathp-&gt;reactant1 = surface_class;
  pathp-&gt;reactant2 = (struct species *)mol_sym-&gt;value;
  pathp-&gt;reactant3 = NULL;
  pathp-&gt;flags = 0;

  pathp-&gt;km = clamp_value;
  pathp-&gt;km_filename = NULL;

  pathp-&gt;orientation1 = 1;
  pathp-&gt;orientation3 = 0;
  if (orient == 0) {
    pathp-&gt;orientation2 = 0;
  } else {
    pathp-&gt;orientation2 = (orient &lt; 0) ? -1 : 1;
  }

  if (clamp_type == CLAMP_TYPE_CONC) {
    pathp-&gt;flags |= PATHW_CLAMP_CONC;

    pathp-&gt;product_head = NULL;
    pathp-&gt;prod_signature = NULL;
  }
  else {
    pathp-&gt;flags |= PATHW_CLAMP_FLUX | PATHW_REFLEC;
    pathp-&gt;product_head = NULL;
    pathp-&gt;prod_signature = NULL;

    /*
    Original implementation from branch neumann_boundaries
    created rxn a+ sc -&gt; a, however in this case the molecules could pass through
    the clamped membrane which does not seem correct*/

#if 0
    struct product *prodp;
    prodp = (struct product *)CHECKED_MALLOC_STRUCT(struct product,
                                                    &quot;reaction product&quot;);
    if (prodp == NULL) {
      free(pathp);
      return MCELL_FAIL;
    }

    prodp-&gt;prod = pathp-&gt;reactant2;
    prodp-&gt;orientation = pathp-&gt;orientation2;
    prodp-&gt;next = NULL;
    pathp-&gt;product_head = prodp;
    if (pathp-&gt;product_head != NULL) {
      pathp-&gt;prod_signature = create_prod_signature(&amp;pathp-&gt;product_head);
      if (pathp-&gt;prod_signature == NULL) {
        // mdlerror(parse_state, &quot;Error creating 'prod_signature' field for the
        // reaction pathway.&quot;);
        free(pathp);
        return MCELL_FAIL;
      }
    }
#endif
  }

  no = CHECKED_MALLOC_STRUCT(struct name_orient, &quot;struct name_orient&quot;);
  no-&gt;name = CHECKED_STRDUP(mol_sym-&gt;name, &quot;molecule name&quot;);
  no-&gt;orient = pathp-&gt;orientation2;

  if (surface_class-&gt;clamp_mols == NULL) {
    no-&gt;next = NULL;
    surface_class-&gt;clamp_mols = no;
  } else {
    no-&gt;next = surface_class-&gt;clamp_mols;
    surface_class-&gt;clamp_mols = no;
  }
  rxnp-&gt;get_reactant_diffusion = rxn_get_standard_diffusion;
  pathp-&gt;next = rxnp-&gt;pathway_head;
  rxnp-&gt;pathway_head = pathp;

  return MCELL_SUCCESS;
}

/************************************************************************
 *
 * function for changing the reaction rate constant of a given named
 * reaction.
 *
 * The call expects:
 *
 * - MCELL_STATE
 * - reaction name: const char* containing the name of reaction
 * - new rate: a double with the new reaction rate constant
 *
 * NOTE: This function can be called anytime after the
 *       REACTION_DATA_OUTPUT has been either parsed or
 *       set up with API calls.
 *
 * Returns 1 on error and 0 on success
 *
 ************************************************************************/
MCELL_STATUS
mcell_change_reaction_rate(MCELL_STATE *state, const char *reaction_name,
                           double new_rate) {
  // sanity check
  if (new_rate &lt; 0.0) {
    return MCELL_FAIL;
  }

  // retrive reaction corresponding to name if it exists
  struct rxn *rx = NULL;
  int path_id = 0;
  if (get_rxn_by_name(state-&gt;reaction_hash, state-&gt;rx_hashsize, reaction_name,
                      &amp;rx, &amp;path_id)) {
    return MCELL_FAIL;
  }

  // now change the rate
  if (change_reaction_probability(
      &amp;state-&gt;reaction_prob_limit_flag, state-&gt;notify, rx, path_id,
      new_rate)) {
    return MCELL_FAIL;
  }

  return MCELL_SUCCESS;
}

/*******************************************************************************
 *
 * static helper functions: initializes the rx-&gt;info field
 *
 ******************************************************************************/
int init_reaction_info(struct rxn* rx){
  struct pathway *path;

  if (rx-&gt;n_pathways &gt; 0) {
    rx-&gt;info = CHECKED_MALLOC_ARRAY(struct pathway_info, rx-&gt;n_pathways,
                                    &quot;reaction pathway info&quot;);
    if (rx-&gt;info == NULL)
      return 1;

    path = rx-&gt;pathway_head;
    for (int n_pathway = 0; path != NULL;
         n_pathway++, path = path-&gt;next) {
      rx-&gt;info[n_pathway].count = 0;
      rx-&gt;info[n_pathway].pathname =
          path-&gt;pathname; /* Keep track of named rxns */
      if (path-&gt;pathname != NULL) {
        rx-&gt;info[n_pathway].pathname-&gt;path_num = n_pathway;
        rx-&gt;info[n_pathway].pathname-&gt;rx = rx;
      }
    }
  } else /* Special reaction, only one exit pathway */
  {
    rx-&gt;info = CHECKED_MALLOC_STRUCT(struct pathway_info,
                                     &quot;reaction pathway info&quot;);
    if (rx-&gt;info == NULL)
      return 1;
    rx-&gt;info[0].count = 0;
    rx-&gt;info[0].pathname = rx-&gt;pathway_head-&gt;pathname;
    if (rx-&gt;pathway_head-&gt;pathname != NULL) {
      rx-&gt;info[0].pathname-&gt;path_num = 0;
      rx-&gt;info[0].pathname-&gt;rx = rx;
    }
  }
  return 0;

}


/*************************************************************************
 init_reactions:
    Postprocess the parsed reactions, moving them to the reaction hash table,
    and transferring information from the pathway structures to a more compact,
    runtime-optimized form.

 In: state: simulation state
 Out: Returns 1 on error, 0 on success.
      Reaction hash table is built and geometries are set properly.  Unlike in
      the parser, reactions with different reactant geometries are _different
      reactions_, and are stored as separate struct rxns.

 Note: The user inputs _geometric equivalence classes_, but here we convert
       from that to _output construction geometry_.  A geometry of 0 means to
       choose a random orientation.  A geometry of k means to adopt the
       geometry of the k'th species in the list (reactants start at #1,
       products are in order after reactants).  A geometry of -k means to adopt
       the opposite of the geometry of the k'th species.  The first n_reactants
       products determine the fate of the reactants (NULL = destroyed), and the
       rest are real products.
 PostNote: The reactants are used for triggering, and those have equivalence
       class geometry even in here.
*************************************************************************/
int init_reactions(MCELL_STATE *state) {
  struct pathway *path;
  struct product *prod = NULL;
  short geom;
  int num_rx = 0;

  state-&gt;vacancy_search_dist2 *= state-&gt;r_length_unit; /* Convert units */
  state-&gt;vacancy_search_dist2 *= state-&gt;vacancy_search_dist2; /* Take square */

  if (state-&gt;rx_radius_3d &lt;= 0.0) {
    state-&gt;rx_radius_3d = 1.0 / sqrt(MY_PI * state-&gt;grid_density);
  }
  state-&gt;tv_rxn_mem = create_mem(sizeof(struct t_func), 100);
  if (state-&gt;tv_rxn_mem == NULL)
    return 1;

  for (int n_rxn_bin = 0; n_rxn_bin &lt; state-&gt;rxn_sym_table-&gt;n_bins;
       n_rxn_bin++) {
    for (struct sym_entry *sym = state-&gt;rxn_sym_table-&gt;entries[n_rxn_bin];
         sym != NULL; sym = sym-&gt;next) {
      struct rxn *reaction = (struct rxn *)sym-&gt;value;
      reaction-&gt;next = NULL;

      for (path = reaction-&gt;pathway_head; path != NULL; path = path-&gt;next) {
        check_duplicate_special_reactions(path);

        /* if one of the reactants is a surface, move it to the last reactant.
         * Also arrange reactant1 and reactant2 in alphabetical order */
        if (reaction-&gt;n_reactants &gt; 1) {
          struct species *temp_sp;
          /* Put surface last */
          if ((path-&gt;reactant1-&gt;flags &amp; IS_SURFACE) != 0) {
            temp_sp = path-&gt;reactant1;
            path-&gt;reactant1 = path-&gt;reactant2;
            path-&gt;reactant2 = temp_sp;
            geom = path-&gt;orientation1;
            path-&gt;orientation1 = path-&gt;orientation2;
            path-&gt;orientation2 = geom;
          }
          if (reaction-&gt;n_reactants &gt; 2) {
            if ((path-&gt;reactant2-&gt;flags &amp; IS_SURFACE) != 0) {
              temp_sp = path-&gt;reactant3;
              path-&gt;reactant3 = path-&gt;reactant2;
              path-&gt;reactant2 = temp_sp;
              geom = path-&gt;orientation3;
              path-&gt;orientation3 = path-&gt;orientation2;
              path-&gt;orientation2 = geom;
            }
          }
          alphabetize_pathway(path, reaction);
        } /* end if (n_reactants &gt; 1) */

      } /* end for (path = reaction-&gt;pathway_head; ...) */

      /* if reaction contains equivalent pathways, split this reaction into a
       * linked list of reactions each containing only equivalent pathways. */

      struct rxn *rx = split_reaction(reaction);

      /* set the symbol value to the head of the linked list of reactions */
      sym-&gt;value = (void *)rx;

      while (rx != NULL) {
        double pb_factor = 0.0;
        /* Check whether reaction contains pathways with equivalent product
         * lists.  Also sort pathways in alphabetical order according to the
         * &quot;prod_signature&quot; field. */
        check_reaction_for_duplicate_pathways(&amp;rx-&gt;pathway_head);

        num_rx++;

        /* At this point we have reactions of the same geometry and can
         * collapse them and count how many non-reactant products are in each
         * pathway. */

        /* Search for reactants that appear as products */
        /* Any reactants that don't appear are set to be destroyed. */
        rx-&gt;product_idx = CHECKED_MALLOC_ARRAY(u_int, rx-&gt;n_pathways + 1,
                                               &quot;reaction product index array&quot;);
        rx-&gt;cum_probs = CHECKED_MALLOC_ARRAY(
            double, rx-&gt;n_pathways, &quot;reaction cumulative probabilities array&quot;);

        /* Note, that the last member of the array &quot;rx-&gt;product_idx&quot; contains
         * size of the array &quot;rx-&gt;players&quot; */

        if (rx-&gt;product_idx == NULL || rx-&gt;cum_probs == NULL)
          return 1;

        int n_prob_t_rxns = 0; /* # of pathways with time-varying rates */
        path = rx-&gt;pathway_head;

        for (int n_pathway = 0; path != NULL; n_pathway++, path = path-&gt;next) {

          rx-&gt;product_idx[n_pathway] = 0;

          /* Look for clamp */
          if ( path-&gt;reactant2 != NULL
               &amp;&amp; (path-&gt;reactant2-&gt;flags &amp; IS_SURFACE) != 0
               &amp;&amp; path-&gt;km &gt;= 0.0
               &amp;&amp; ( ( path-&gt;product_head == NULL &amp;&amp; (path-&gt;flags &amp; PATHW_CLAMP_CONC) != 0 )
                  ||
                  ( path-&gt;product_head == NULL &amp;&amp; (path-&gt;flags &amp; PATHW_CLAMP_FLUX) != 0 ) )
             ) {

            struct clamp_data *cdp;

            if (n_pathway != 0 || path-&gt;next != NULL)
              mcell_warn(&quot;Mixing surface modes with other surface reactions.  &quot;
                         &quot;Please don't.&quot;);

            if (path-&gt;km &gt; 0) {
              cdp = CHECKED_MALLOC_STRUCT(struct clamp_data,
                                          &quot;clamp data&quot;);
              if (cdp == NULL)
                return 1;

              cdp-&gt;surf_class = path-&gt;reactant2;
              cdp-&gt;mol = path-&gt;reactant1;
              cdp-&gt;clamp_value = path-&gt;km;
              if ((path-&gt;flags &amp; PATHW_CLAMP_CONC) != 0) {
                cdp-&gt;clamp_type = CLAMP_TYPE_CONC;
              }
              else {
                cdp-&gt;clamp_type = CLAMP_TYPE_FLUX;
              }
              if (path-&gt;orientation1 * path-&gt;orientation2 == 0) {
                cdp-&gt;orient = 0;
              } else {
                cdp-&gt;orient =
                    (path-&gt;orientation1 == path-&gt;orientation2) ? 1 : -1;
              }
              cdp-&gt;sides = NULL;
              cdp-&gt;next_mol = NULL;
              cdp-&gt;next_obj = NULL;
              cdp-&gt;objp = NULL;
              cdp-&gt;n_sides = 0;
              cdp-&gt;side_idx = NULL;
              cdp-&gt;cum_area = NULL;
              cdp-&gt;scaling_factor = 0.0;
              cdp-&gt;next = state-&gt;clamp_list;
              state-&gt;clamp_list = cdp;
            }
            path-&gt;clamp_concentration = path-&gt;km; // remember for mcell3-&gt;4 converter
            path-&gt;km = GIGANTIC;

            if ((path-&gt;flags &amp; PATHW_CLAMP_FLUX) != 0) {
              rx-&gt;n_pathways = RX_REFLEC;
              if (path-&gt;reactant2 != NULL &amp;&amp;
                  (path-&gt;reactant2-&gt;flags &amp; IS_SURFACE) &amp;&amp;
                  (path-&gt;reactant1-&gt;flags &amp; ON_GRID)) {
                path-&gt;reactant1-&gt;flags |= CAN_REGION_BORDER;
              }
            }

          } else if ((path-&gt;flags &amp; PATHW_TRANSP) != 0) {
            rx-&gt;n_pathways = RX_TRANSP;
            if (path-&gt;reactant2 != NULL &amp;&amp;
                (path-&gt;reactant2-&gt;flags &amp; IS_SURFACE) &amp;&amp;
                (path-&gt;reactant1-&gt;flags &amp; ON_GRID)) {
              path-&gt;reactant1-&gt;flags |= CAN_REGION_BORDER;
            }
          } else if ((path-&gt;flags &amp; PATHW_REFLEC) != 0) {
            rx-&gt;n_pathways = RX_REFLEC;
            if (path-&gt;reactant2 != NULL &amp;&amp;
                (path-&gt;reactant2-&gt;flags &amp; IS_SURFACE) &amp;&amp;
                (path-&gt;reactant1-&gt;flags &amp; ON_GRID)) {
              path-&gt;reactant1-&gt;flags |= CAN_REGION_BORDER;
            }
          } else if (path-&gt;reactant2 != NULL &amp;&amp;
                     (path-&gt;reactant2-&gt;flags &amp; IS_SURFACE) &amp;&amp;
                     (path-&gt;reactant1-&gt;flags &amp; ON_GRID) &amp;&amp;
                     (path-&gt;product_head == NULL) &amp;&amp;
                     (path-&gt;flags &amp; PATHW_ABSORP)) {
            rx-&gt;n_pathways = RX_ABSORB_REGION_BORDER;
            path-&gt;reactant1-&gt;flags |= CAN_REGION_BORDER;
          } else if ((strcmp(path-&gt;reactant1-&gt;sym-&gt;name,
                             &quot;ALL_SURFACE_MOLECULES&quot;) == 0)) {
            if (path-&gt;reactant2 != NULL &amp;&amp;
                (path-&gt;reactant2-&gt;flags &amp; IS_SURFACE) &amp;&amp;
                (path-&gt;product_head == NULL) &amp;&amp; (path-&gt;flags &amp; PATHW_ABSORP)) {
              rx-&gt;n_pathways = RX_ABSORB_REGION_BORDER;
              path-&gt;reactant1-&gt;flags |= CAN_REGION_BORDER;
            }
          }
          if (path-&gt;km_filename == NULL)
            rx-&gt;cum_probs[n_pathway] = path-&gt;km;
          else {
            rx-&gt;cum_probs[n_pathway] = 0;
            n_prob_t_rxns++;
          }

          /* flags that tell whether reactant_1 is also on the product list,
             same for reactant_2 and reactant_3 */
          int recycled1 = 0;
          int recycled2 = 0;
          int recycled3 = 0;

          for (prod = path-&gt;product_head; prod != NULL; prod = prod-&gt;next) {
            if (recycled1 == 0 &amp;&amp; prod-&gt;prod == path-&gt;reactant1)
              recycled1 = 1;
            else if (recycled2 == 0 &amp;&amp; prod-&gt;prod == path-&gt;reactant2)
              recycled2 = 1;
            else if (recycled3 == 0 &amp;&amp; prod-&gt;prod == path-&gt;reactant3)
              recycled3 = 1;
            else
              rx-&gt;product_idx[n_pathway]++;
          }

        } /* end for (n_pathway=0,path=rx-&gt;pathway_head; ...) */

        /* Now that we know how many products there really are, set the index
         * array and malloc space for the products and geometries. */
        int num_players = rx-&gt;n_reactants;
        int kk = rx-&gt;n_pathways;
        if (kk &lt;= RX_SPECIAL)
          kk = 1;
        for (int n_pathway = 0; n_pathway &lt; kk; n_pathway++) {
          int k = rx-&gt;product_idx[n_pathway] + rx-&gt;n_reactants;
          rx-&gt;product_idx[n_pathway] = num_players;
          num_players += k;
        }
        rx-&gt;product_idx[kk] = num_players;

        rx-&gt;players = CHECKED_MALLOC_ARRAY(struct species *, num_players,
                                           &quot;reaction players array&quot;);
        rx-&gt;geometries = CHECKED_MALLOC_ARRAY(short, num_players,
                                              &quot;reaction geometries array&quot;);

        if (rx-&gt;players == NULL || rx-&gt;geometries == NULL)
          return 1;

        /* Load all the time-varying rates from disk (if any), merge them into
         * a single sorted list, and pull off any updates for time zero. */
        if (n_prob_t_rxns &gt; 0) {
          path = rx-&gt;pathway_head;
          for (int n_pathway = 0; path != NULL;
               n_pathway++, path = path-&gt;next) {
            if (path-&gt;km_filename != NULL) {
              if (load_rate_file(state, rx, path-&gt;km_filename, n_pathway))
                mcell_error(&quot;Failed to load rates from file '%s'.&quot;,
                            path-&gt;km_filename);
            }
            free(path-&gt;km_filename);
            path-&gt;km_filename = NULL;
          }
          rx-&gt;prob_t = (struct t_func *)ae_list_sort(
              (struct abstract_element *)rx-&gt;prob_t);

          while (rx-&gt;prob_t != NULL &amp;&amp; rx-&gt;prob_t-&gt;time &lt;= 0.0) {
            rx-&gt;cum_probs[rx-&gt;prob_t-&gt;path] = rx-&gt;prob_t-&gt;value;
            rx-&gt;prob_t = rx-&gt;prob_t-&gt;next;
          }
        } /* end if (n_prob_t_rxns &gt; 0) */

        /* Set the geometry of the reactants.  These are used for triggering. */
        /* Since we use flags to control orientation changes, just tell everyone
         * to stay put. */
        path = rx-&gt;pathway_head;
        rx-&gt;players[0] = path-&gt;reactant1;
        rx-&gt;geometries[0] = path-&gt;orientation1;
        if (rx-&gt;n_reactants &gt; 1) {
          rx-&gt;players[1] = path-&gt;reactant2;
          rx-&gt;geometries[1] = path-&gt;orientation2;
          if (rx-&gt;n_reactants &gt; 2) {
            rx-&gt;players[2] = path-&gt;reactant3;
            rx-&gt;geometries[2] = path-&gt;orientation3;
          }
        }

        //JJT: once reactants have been initialized we can assign diffusion/space/timestep functions
        initialize_rxn_diffusion_functions(rx);
        //JJT: initialize nfsim reaction fields to null since they will not be used for this normal reaction
        rx-&gt;external_reaction_data = NULL;
        rx-&gt;product_graph_data = NULL;
        rx-&gt;reactant_graph_data = NULL;
        

        /* maximum number of surface products */
        path = rx-&gt;pathway_head;
        int max_num_surf_products = set_product_geometries(path, rx, prod);

        pb_factor = compute_pb_factor(
            state-&gt;time_unit, state-&gt;length_unit, state-&gt;grid_density,
            state-&gt;rx_radius_3d,
            &amp;state-&gt;rxn_flags,
            &amp;state-&gt;create_shared_walls_info_flag,
            rx, max_num_surf_products);
        rx-&gt;pb_factor = pb_factor;
        path = rx-&gt;pathway_head;

        if (scale_rxn_probabilities(&amp;state-&gt;reaction_prob_limit_flag, state-&gt;notify,
                                path, rx, pb_factor))
          return 1;

        if (n_prob_t_rxns &gt; 0) {
          for (struct t_func *tp = rx-&gt;prob_t; tp != NULL; tp = tp-&gt;next)
            tp-&gt;value *= pb_factor;
        }

        /* Move counts from list into array */
        if(init_reaction_info(rx) != 0)
          return MCELL_FAIL;

        /* Compute cumulative properties */
        for (int n_pathway = 1; n_pathway &lt; rx-&gt;n_pathways; ++n_pathway)
          rx-&gt;cum_probs[n_pathway] += rx-&gt;cum_probs[n_pathway - 1];
        if (rx-&gt;n_pathways &gt; 0)
          rx-&gt;min_noreaction_p = rx-&gt;max_fixed_p =
              rx-&gt;cum_probs[rx-&gt;n_pathways - 1];
        else
          rx-&gt;min_noreaction_p = rx-&gt;max_fixed_p = 1.0;

        rx = rx-&gt;next;
      }
    }
  }

  if (state-&gt;rxn_flags.surf_surf_reaction_flag ||
      state-&gt;rxn_flags.surf_surf_surf_reaction_flag) {
    if (state-&gt;notify-&gt;reaction_probabilities == NOTIFY_FULL)
      mcell_log(&quot;For reaction between two (or three) surface molecules the &quot;
                &quot;upper probability limit is given. The effective reaction &quot;
                &quot;probability will be recalculated dynamically during &quot;
                &quot;simulation.&quot;);
  }

  if (build_reaction_hash_table(&amp;state-&gt;reaction_hash, &amp;state-&gt;n_reactions,
                                state-&gt;rxn_sym_table, &amp;state-&gt;rx_hashsize,
                                num_rx))
    return 1;

  state-&gt;rx_radius_3d *= state-&gt;r_length_unit; /* Convert into length units */

  for (int n_rxn_bin = 0; n_rxn_bin &lt; state-&gt;rx_hashsize; n_rxn_bin++) {
    for (struct rxn *this_rx = state-&gt;reaction_hash[n_rxn_bin]; this_rx != NULL;
         this_rx = this_rx-&gt;next) {
      set_reaction_player_flags(this_rx);
    }
  }

#if 0
  // TODO: move this to a separate function and call after mcell4 conversion
  // pathway_head is used there - this is sued in mcell4's init
  for (int n_rxn_bin = 0; n_rxn_bin &lt; state-&gt;rx_hashsize; n_rxn_bin++) {
    for (struct rxn *this_rx = state-&gt;reaction_hash[n_rxn_bin]; this_rx != NULL;
         this_rx = this_rx-&gt;next) {
      /* Here we deallocate all memory used for creating pathways. */
      path = this_rx-&gt;pathway_head;
      struct pathway *next_path = path;
      while (next_path != NULL) {
        next_path = path-&gt;next;
        if (path-&gt;prod_signature != NULL) {
          free(path-&gt;prod_signature);
        }

        struct product *dead_prod = path-&gt;product_head;
        struct product *nxt = dead_prod;
        while (nxt != NULL) {
          nxt = dead_prod-&gt;next;
          free(dead_prod);
          dead_prod = nxt;
        }

        free(path);
        path = next_path;
      }

      //set_reaction_player_flags(this_rx);
      this_rx-&gt;pathway_head = NULL;
    }
  }
#endif

  add_surface_reaction_flags(state-&gt;mol_sym_table, state-&gt;all_mols, state-&gt;all_surface_mols,
                             state-&gt;all_volume_mols);

  if (state-&gt;notify-&gt;reaction_probabilities == NOTIFY_FULL)
    mcell_log_raw(&quot;\n&quot;);

  return 0;
}

/*******************************************************************************
 *
 * static helper functions
 *
 ******************************************************************************/
/*************************************************************************
 *
 * extract_reactants extracts the reactant info into a pathway structure
 *
 *************************************************************************/
MCELL_STATUS
extract_reactants(struct pathway *pathp, struct mcell_species *reactants,
                  int *num_reactants, int *num_vol_mols, int *num_surface_mols,
                  int *all_3d, int *oriented_count) {
  int reactant_idx = 0;
  struct mcell_species *current_reactant;
  for (current_reactant = reactants;
       reactant_idx &lt; 3 &amp;&amp; current_reactant != NULL;
       ++reactant_idx, current_reactant = current_reactant-&gt;next) {
    /* Extract orientation and species */
    short orient = current_reactant-&gt;orient_set ? current_reactant-&gt;orient : 0;
    struct species *reactant_species =
        (struct species *)current_reactant-&gt;mol_type-&gt;value;

    /* Count the type of this reactant */
    if (current_reactant-&gt;orient_set) {
      ++(*oriented_count);
    }

    if (reactant_species-&gt;flags &amp; NOT_FREE) {
      *all_3d = 0;
      if (reactant_species-&gt;flags &amp; ON_GRID) {
        ++(*num_surface_mols);
      }
    } else {
      ++(*num_vol_mols);
<A NAME="0"></A>    }

    /* Copy in reactant info */
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1411-1.html#0',3,'match1411-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    switch (reactant_idx) {
    case 0:
      pathp-&gt;reactant1 = reactant_species;
      pathp-&gt;orientation1 = orient;
      break;

    case 1:
      pathp-&gt;reactant2 = reactant_species;
      pathp-&gt;orientation2 = orient;
      break;

    case 2:
      pathp-&gt;reactant3 = reactant_species;
      pathp-&gt;orientation3 = orient;
      break;</B></FONT>

    default:
      UNHANDLED_CASE(reactant_idx);
    }
  }
  *num_reactants = reactant_idx;

  /* we had more than 3 reactants */
  if (current_reactant != NULL) {
    return MCELL_FAIL;
  } else {
    return MCELL_SUCCESS;
  }
}

/*************************************************************************
 *
 * extract_catalytic_arrow extracts the info for a catalytic arrow
 * into a pathway structure
 *
 *************************************************************************/
MCELL_STATUS
extract_catalytic_arrow(struct pathway *pathp,
                        struct reaction_arrow *react_arrow, int *reactant_idx,
                        int *num_vol_mols, int *num_surface_mols, int *all_3d,
                        int *oriented_count) {
  struct species *catalyst_species =
      (struct species *)react_arrow-&gt;catalyst.mol_type-&gt;value;
  short orient =
      react_arrow-&gt;catalyst.orient_set ? react_arrow-&gt;catalyst.orient : 0;

  /* XXX: Should surface class be allowed inside a catalytic arrow? */
  if (catalyst_species-&gt;flags &amp; IS_SURFACE) {
     mcell_error(&quot;a surface class may not appear inside a catalytic arrow&quot;);
    return MCELL_FAIL;
  }

  /* Count the type of this reactant */
  if (react_arrow-&gt;catalyst.orient_set) {
    ++(*oriented_count);
  }

  if (catalyst_species-&gt;flags &amp; NOT_FREE) {
    *all_3d = 0;
    if (catalyst_species-&gt;flags &amp; ON_GRID) {
      ++(*num_surface_mols);
    }
  } else {
    ++(*num_vol_mols);
  }

  /* Copy in catalytic reactant */
  switch (*reactant_idx) {
  case 1:
    pathp-&gt;reactant2 = (struct species *)react_arrow-&gt;catalyst.mol_type-&gt;value;
    pathp-&gt;orientation2 = orient;
    break;

  case 2:
    pathp-&gt;reactant3 = (struct species *)react_arrow-&gt;catalyst.mol_type-&gt;value;
    pathp-&gt;orientation3 = orient;
    break;

  case 0:
  default:
    // mcell_internal_error(&quot;Catalytic reagent ended up in an invalid slot
    // (%d).&quot;, reactant_idx);
    return MCELL_FAIL;
  }
  ++(*reactant_idx);

  return MCELL_SUCCESS;
}

/*************************************************************************
 *
 * extract_surface extracts the info for a surface included in the
 * reaction specification
 *
 *************************************************************************/
MCELL_STATUS
extract_surface(struct pathway *path, struct mcell_species *surf_class,
                int *num_reactants, unsigned int *num_surfaces,
                int *oriented_count) {
  short orient = surf_class-&gt;orient_set ? surf_class-&gt;orient : 0;
  if (surf_class-&gt;orient_set) {
    (*oriented_count)++;
  }

  /* Copy reactant into next available slot */
  switch (*num_reactants) {
  case 0:
    // mdlerror(parse_state, &quot;Before defining reaction surface class at least
    // one reactant should be defined.&quot;);
    return MCELL_FAIL;

  case 1:
    path-&gt;reactant2 = (struct species *)surf_class-&gt;mol_type-&gt;value;
    path-&gt;orientation2 = orient;
    break;

  case 2:
    path-&gt;reactant3 = (struct species *)surf_class-&gt;mol_type-&gt;value;
    path-&gt;orientation3 = orient;
    break;

  default:
    // mdlerror(parse_state, &quot;Too many reactants--maximum number is two plus
    // reaction surface class.&quot;);
    return MCELL_FAIL;
  }

  (*num_reactants)++;
  (*num_surfaces)++;

  return MCELL_SUCCESS;
}

/*************************************************************************
 *
 * check_surface_specs performs a number of sanity checks to make sure
 * the surface specifications are sane
 *
 *************************************************************************/
MCELL_STATUS
check_surface_specs(struct notifications *notify, int num_reactants,
                    int num_surfaces, int num_vol_mols, int all_3d,
                    int oriented_count) {
  if (num_surfaces &gt; 1) {
    /* Shouldn't happen */
    mcell_internal_error(
        &quot;Too many surfaces--reactions can take place on at most one surface.&quot;);
    return MCELL_FAIL;
  }

  if (num_surfaces == num_reactants) {
    mcell_error(&quot;Reactants cannot consist entirely of surfaces.  Use a surface &quot;
                &quot;release site instead!&quot;);
    return MCELL_FAIL;
  }

  if ((num_vol_mols == 2) &amp;&amp; (num_surfaces == 1)) {
    mcell_error(
        &quot;Reaction between two volume molecules and a surface is not defined.&quot;);
    return MCELL_FAIL;
  }

  if (all_3d) {
    if (oriented_count != 0) {
      if (notify-&gt;useless_vol_orient == WARN_ERROR) {
        mcell_error(&quot;Orientation specified for molecule in reaction in volume&quot;);
        return MCELL_FAIL;
      } else if (notify-&gt;useless_vol_orient == WARN_WARN) {
        mcell_warn(&quot;Orientation specified for molecule in reaction in volume&quot;);
      }
    }
  } else {
    if (num_reactants != oriented_count) {
      if (notify-&gt;missed_surf_orient == WARN_ERROR) {
        mcell_error(&quot;Orientation not specified for molecule in reaction &quot;
                    &quot;at surface\n  (use ; or ', or ,' for random orientation)&quot;);
        return MCELL_FAIL;
      } else if (notify-&gt;missed_surf_orient == WARN_WARN) {
        mcell_warn(&quot;Orientation not specified for molecule in reaction at &quot;
                   &quot;surface\n  (use ; or ', or ,' for random orientation)&quot;);
      }
    }
  }

  return MCELL_SUCCESS;
}

/*************************************************************************
 *
 * add_catalytic_species_to_products adds all species that are part of a
 * catalytic reaction to the list of products.
 *
 *************************************************************************/
MCELL_STATUS
add_catalytic_species_to_products(struct pathway *path, int catalytic,
                                  int bidirectional, int all_3d) {
<A NAME="1"></A>  struct species *catalyst;
  short catalyst_orient;
  switch (catalytic) {
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1411-1.html#1',3,'match1411-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  case 0:
    catalyst = path-&gt;reactant1;
    catalyst_orient = path-&gt;orientation1;
    break;
  case 1:
    catalyst = path-&gt;reactant2;
    catalyst_orient = path-&gt;orientation2;
    break;
  case 2:
    catalyst = path-&gt;reactant3;
    catalyst_orient = path-&gt;orientation3;
    break;</B></FONT>
  default:
    mcell_internal_error(&quot;Catalytic reagent index is invalid.&quot;);
    return MCELL_FAIL;
  }

  if (bidirectional || !(catalyst-&gt;flags &amp; IS_SURFACE)) {
    struct product *prodp = (struct product *)CHECKED_MALLOC_STRUCT(
        struct product, &quot;reaction product&quot;);
    if (prodp == NULL) {
      return MCELL_FAIL;
    }

    prodp-&gt;prod = catalyst;
    if (all_3d) {
      prodp-&gt;orientation = 0;
    } else {
      prodp-&gt;orientation = catalyst_orient;
    }
    prodp-&gt;next = path-&gt;product_head;
    path-&gt;product_head = prodp;
  }

  return MCELL_SUCCESS;
}

/*************************************************************************
 *
 * extract_products extracts the product info into a pathway structure
 *
 *************************************************************************/
MCELL_STATUS
extract_products(struct notifications *notify, struct pathway *pathp,
                 struct mcell_species *products, int *num_surf_products,
                 int bidirectional,
                 int all_3d) {
  struct mcell_species *current_product;
  for (current_product = products; current_product != NULL;
       current_product = current_product-&gt;next) {
    /* Nothing to do for NO_SPECIES */
    if (current_product-&gt;mol_type == NULL)
      continue;

    /* Create new product */
    struct product *prodp = (struct product *)CHECKED_MALLOC_STRUCT(
        struct product, &quot;reaction product&quot;);

    if (prodp == NULL) {
      // mcell_error_raw(&quot;Out of memory while creating reaction: %s -&gt; ... &quot;,
      //                rxnp-&gt;sym-&gt;name);
      return MCELL_FAIL;
    }

    /* Set product species and orientation */
    prodp-&gt;prod = (struct species *)current_product-&gt;mol_type-&gt;value;
    if (all_3d) {
      prodp-&gt;orientation = 0;
    } else {
      prodp-&gt;orientation = current_product-&gt;orient;
    }

    /* Disallow surface as product unless reaction is bidirectional */
    if (!bidirectional) {
      if (prodp-&gt;prod-&gt;flags &amp; IS_SURFACE) {
        mcell_error_raw(&quot;Surface_class '%s' is not allowed to be on the &quot;
                        &quot;product side of the reaction.&quot;,
                        prodp-&gt;prod-&gt;sym-&gt;name);
        free(prodp);
        return MCELL_FAIL;
      }
    }

    /* Append product to list */
    prodp-&gt;next = pathp-&gt;product_head;
    pathp-&gt;product_head = prodp;

    if (prodp-&gt;prod-&gt;flags &amp; ON_GRID) {
      ++(*num_surf_products);
    }

    /* Add product if it isn't a surface */
    if (!(prodp-&gt;prod-&gt;flags &amp; IS_SURFACE)) {
      if (all_3d == 0) {
        if (!current_product-&gt;orient_set) {
          if (notify-&gt;missed_surf_orient == WARN_ERROR) {
            mcell_error(&quot;Product orientation not specified for molecule in &quot;
                        &quot;reaction at surface\n  (use ; or ', or ,' for random &quot;
                        &quot;orientation)&quot;);
            return MCELL_FAIL;
          } else if (notify-&gt;missed_surf_orient == WARN_WARN) {
            mcell_warn(&quot;Product orientation not specified for molecule in &quot;
                       &quot;reaction at surface\n  (use ; or ', or ,' for random &quot;
                       &quot;orientation)&quot;);
          }
        }
      } else {
        if ((prodp-&gt;prod-&gt;flags &amp; NOT_FREE) != 0) {
          mcell_error(&quot;Reaction has only volume reactants but is trying to &quot;
                      &quot;create a surface product&quot;);
          return MCELL_FAIL;
        }
        if (current_product-&gt;orient_set) {
          if (notify-&gt;useless_vol_orient == WARN_ERROR) {
            mcell_error(&quot;Orientation specified for molecule in reaction in &quot;
                        &quot;volume&quot;);
            return MCELL_FAIL;
          } else if (notify-&gt;useless_vol_orient == WARN_WARN) {
            mcell_warn(&quot;Orientation specified for molecule in reaction in &quot;
                       &quot;volume&quot;);
          }
        }
      }
    }
  }

  return MCELL_SUCCESS;
}

/*************************************************************************
 create_rx_name:
    Assemble reactants alphabetically into a reaction name string.

 In:  p: reaction pathway whose reaction name we are to create
 Out: a string to be used as a symbol name for the reaction
*************************************************************************/
char *create_rx_name(struct pathway *p) {

  struct species *reagents[3];
  int n_reagents = 0;

  /* Store reagents in an array. */
  reagents[0] = p-&gt;reactant1;
  reagents[1] = p-&gt;reactant2;
  reagents[2] = p-&gt;reactant3;

  /* Count non-null reagents. */
  for (n_reagents = 0; n_reagents &lt; 3; ++n_reagents)
    if (reagents[n_reagents] == NULL)
      break;

  /* Sort reagents. */
  for (int i = 0; i &lt; n_reagents; ++i) {
    for (int j = i + 1; j &lt; n_reagents; ++j) {
      /* If 'j' precedes 'i', 'j' wins. */
      if (strcmp(reagents[j]-&gt;sym-&gt;name, reagents[i]-&gt;sym-&gt;name) &lt; 0) {
        struct species *tmp = reagents[j];
        reagents[j] = reagents[i];
        reagents[i] = tmp;
      }
    }
  }

  /* Now, produce a name! */
  switch (n_reagents) {
  case 1:
    return alloc_sprintf(&quot;%s&quot;, reagents[0]-&gt;sym-&gt;name);
  case 2:
    return alloc_sprintf(&quot;%s+%s&quot;, reagents[0]-&gt;sym-&gt;name,
                         reagents[1]-&gt;sym-&gt;name);
  case 3:
    return alloc_sprintf(&quot;%s+%s+%s&quot;, reagents[0]-&gt;sym-&gt;name,
                         reagents[1]-&gt;sym-&gt;name, reagents[2]-&gt;sym-&gt;name);
  default:
    // mcell_internal_error(&quot;Invalid number of reagents in reaction pathway
    // (%d).&quot;, n_reagents);
    return NULL;
  }
}

/*************************************************************************
 concat_rx_name:
    Concatenates reactants onto a reaction name.

 In:  name1: name of first reactant (or first part of reaction name)
      name2: name of second reactant (or second part of reaction name)
 Out: reaction name as a string, or NULL if an error occurred
*************************************************************************/
static char *concat_rx_name(char *name1, char *name2) {
  char *rx_name;

  /* Sort them */
  if (strcmp(name2, name1) &lt;= 0) {
    char *nametmp = name1;
    name1 = name2;
    name2 = nametmp;
  }

  /* Build the name */
  rx_name = CHECKED_SPRINTF(&quot;%s+%s&quot;, name1, name2);

  /* Die if we failed to allocate memory */
  if (rx_name == NULL)
    return NULL;

  return rx_name;
}

/***********************************************************************
 invert_current_reaction_pathway:
    Creates a new reversed pathway, where the reactants of new pathway are the
    products of the current pathway, and the products of new pathway are the
    reactants of the current pathway.

 In:  rxn_sym_table:
      vacancy_search_dist2:
      pathp: pathway to invert
      reverse_rate: the reverse reaction rate
      rate_filename:
 Out: Returns 1 on error and 0 - on success.  The new pathway is added to the
      linked list of the pathways for the current reaction.
***********************************************************************/
MCELL_STATUS invert_current_reaction_pathway(
    struct sym_table_head *rxn_sym_table,
    double vacancy_search_dist2,
    struct pathway *pathp,
    struct reaction_rate *reverse_rate,
    const char *rate_filename) {

  struct product *prodp;
  int num_surf_products = 0;
  int num_surface_mols = 0;
  int num_vol_mols = 0;

  /* flag that tells whether there is a surface_class
     among products in the direct reaction */
  int is_surf_class = 0;

  int all_3d = 1; // flag that tells whether all products are volume_molecules
  int nprods; /* number of products */
  for (nprods = 0, prodp = pathp-&gt;product_head; prodp != NULL;
       prodp = prodp-&gt;next) {
    nprods++;
    if ((prodp-&gt;prod-&gt;flags &amp; NOT_FREE) != 0)
      all_3d = 0;
    if ((prodp-&gt;prod-&gt;flags &amp; IS_SURFACE) != 0) {
      is_surf_class = 1;
    }
  }

  if (nprods == 0) {
    // mdlerror(parse_state, &quot;Can't create a reverse reaction with no
    // products&quot;);
    return MCELL_FAIL;
  }
  if (nprods == 1 &amp;&amp; (pathp-&gt;product_head-&gt;prod-&gt;flags &amp; IS_SURFACE)) {
    // mdlerror(parse_state, &quot;Can't create a reverse reaction starting from only
    // a surface&quot;);
    return MCELL_FAIL;
  }
  if (nprods &gt; 3) {
    // mdlerror(parse_state, &quot;Can't create a reverse reaction involving more
    // than three products. Please note that surface_class from the reaction
    // reactant side also counts as a product.&quot;);
    return MCELL_FAIL;
  }

  if (pathp-&gt;pathname != NULL) {
    // mdlerror(parse_state, &quot;Can't name bidirectional reactions--write each
    // reaction and name them separately&quot;);
    return MCELL_FAIL;
  }
  if (all_3d) {
    if ((pathp-&gt;reactant1-&gt;flags &amp; NOT_FREE) != 0)
      all_3d = 0;
    if (pathp-&gt;reactant2 != NULL &amp;&amp; (pathp-&gt;reactant2-&gt;flags &amp; NOT_FREE) != 0)
      all_3d = 0;
    if (pathp-&gt;reactant3 != NULL &amp;&amp; (pathp-&gt;reactant3-&gt;flags &amp; NOT_FREE) != 0)
      all_3d = 0;

    if (!all_3d) {
      // mdlerror(parse_state, &quot;Cannot reverse orientable reaction with only
      // volume products&quot;);
      return MCELL_FAIL;
    }
  }

  prodp = pathp-&gt;product_head;
  char *inverse_name;
  if (nprods == 1) {
    inverse_name = strdup(prodp-&gt;prod-&gt;sym-&gt;name);

    if (inverse_name == NULL)
      return MCELL_FAIL;
  } else if (nprods == 2) {
    inverse_name =
        concat_rx_name(prodp-&gt;prod-&gt;sym-&gt;name, prodp-&gt;next-&gt;prod-&gt;sym-&gt;name);
  } else {
    char *tmp_inverse_name = concat_rx_name(
      prodp-&gt;prod-&gt;sym-&gt;name, prodp-&gt;next-&gt;prod-&gt;sym-&gt;name);
    if (tmp_inverse_name == NULL) {
      return MCELL_FAIL;
    }
    inverse_name =
        concat_rx_name(tmp_inverse_name, prodp-&gt;next-&gt;next-&gt;prod-&gt;sym-&gt;name);
    free(tmp_inverse_name);
  }
  if (inverse_name == NULL) {
    return MCELL_FAIL;
  }

  struct sym_entry *sym = retrieve_sym(inverse_name, rxn_sym_table);
  if (sym == NULL) {
    sym = store_sym(inverse_name, RX, rxn_sym_table, NULL);
    if (sym == NULL) {
      // mdlerror_fmt(parse_state, &quot;File '%s', Line %ld: Out of memory while
      // storing reaction pathway.&quot;, __FILE__, (long)__LINE__);
      free(inverse_name);
      return MCELL_FAIL;
    }
  }
  free(inverse_name);
  struct rxn *rx = (struct rxn *)sym-&gt;value;
  rx-&gt;n_reactants = nprods;
  rx-&gt;n_pathways++;

  struct pathway *path = (struct pathway *)CHECKED_MALLOC_STRUCT(
    struct pathway, &quot;reaction pathway&quot;);
  if (path == NULL) {
    return MCELL_FAIL;
  }
  path-&gt;pathname = NULL;
  path-&gt;flags = 0;
  path-&gt;reactant1 = prodp-&gt;prod;
  if ((path-&gt;reactant1-&gt;flags &amp; NOT_FREE) == 0) {
    ++num_vol_mols;
  } else {
    if (path-&gt;reactant1-&gt;flags &amp; ON_GRID) {
      ++num_surface_mols;
    }
  }
  path-&gt;orientation1 = prodp-&gt;orientation;
  path-&gt;reactant2 = NULL;
  path-&gt;reactant3 = NULL;
  path-&gt;prod_signature = NULL;
  if (nprods &gt; 1) {
    path-&gt;reactant2 = prodp-&gt;next-&gt;prod;
    if ((path-&gt;reactant2-&gt;flags &amp; NOT_FREE) == 0) {
      ++num_vol_mols;
    } else {
      if (path-&gt;reactant2-&gt;flags &amp; ON_GRID) {
        ++num_surface_mols;
      }
    }
    path-&gt;orientation2 = prodp-&gt;next-&gt;orientation;
  }
  if (nprods &gt; 2) {
    path-&gt;reactant3 = prodp-&gt;next-&gt;next-&gt;prod;
    if ((path-&gt;reactant3-&gt;flags &amp; NOT_FREE) == 0) {
      ++num_vol_mols;
    } else {
      if (path-&gt;reactant3-&gt;flags &amp; ON_GRID) {
        ++num_surface_mols;
      }
    }
    path-&gt;orientation3 = prodp-&gt;next-&gt;next-&gt;orientation;
  }

  switch (reverse_rate-&gt;rate_type) {
  case RATE_UNSET:
    // mdlerror_fmt(parse_state, &quot;File %s, Line %d: Internal error: Reverse rate
    // is not set&quot;, __FILE__, __LINE__);
    free(path);
    return MCELL_FAIL;

  case RATE_CONSTANT:
    path-&gt;km = reverse_rate-&gt;v.rate_constant;
    path-&gt;km_filename = NULL;
    break;

  case RATE_FILE:
    path-&gt;km = 0.0;
    path-&gt;km_filename = (char *)rate_filename;
    free(reverse_rate-&gt;v.rate_file);
    reverse_rate-&gt;v.rate_file = NULL;
    break;

  default:
    UNHANDLED_CASE(reverse_rate-&gt;rate_type);
  }

  path-&gt;product_head = (struct product *)CHECKED_MALLOC_STRUCT(
      struct product, &quot;reaction product&quot;);
  if (path-&gt;product_head == NULL) {
    free(path);
    return 1;
  }

  path-&gt;product_head-&gt;orientation = pathp-&gt;orientation1;
  path-&gt;product_head-&gt;prod = pathp-&gt;reactant1;
  path-&gt;product_head-&gt;next = NULL;
  if (path-&gt;product_head-&gt;prod-&gt;flags &amp; ON_GRID)
    ++num_surf_products;

  if ((pathp-&gt;reactant2 != NULL) &amp;&amp;
      ((pathp-&gt;reactant2-&gt;flags &amp; IS_SURFACE) == 0)) {
    path-&gt;product_head-&gt;next = (struct product *)CHECKED_MALLOC_STRUCT(
        struct product, &quot;reaction product&quot;);
    if (path-&gt;product_head-&gt;next == NULL) {
      free(path);
      return 1;
    }
    path-&gt;product_head-&gt;next-&gt;orientation = pathp-&gt;orientation2;
    path-&gt;product_head-&gt;next-&gt;prod = pathp-&gt;reactant2;
    path-&gt;product_head-&gt;next-&gt;next = NULL;
    if (path-&gt;product_head-&gt;next-&gt;prod-&gt;flags &amp; ON_GRID)
      ++num_surf_products;

    if ((pathp-&gt;reactant3 != NULL) &amp;&amp;
        ((pathp-&gt;reactant3-&gt;flags &amp; IS_SURFACE) == 0)) {
      path-&gt;product_head-&gt;next-&gt;next = (struct product *)CHECKED_MALLOC_STRUCT(
          struct product, &quot;reaction product&quot;);
      if (path-&gt;product_head-&gt;next-&gt;next == NULL) {
        free(path);
        return 1;
      }
      path-&gt;product_head-&gt;next-&gt;next-&gt;orientation = pathp-&gt;orientation3;
      path-&gt;product_head-&gt;next-&gt;next-&gt;prod = pathp-&gt;reactant3;
      path-&gt;product_head-&gt;next-&gt;next-&gt;next = NULL;
      if (path-&gt;product_head-&gt;next-&gt;next-&gt;prod-&gt;flags &amp; ON_GRID)
        ++num_surf_products;
    }
  }

  path-&gt;prod_signature = create_prod_signature(&amp;path-&gt;product_head);
  if (path-&gt;prod_signature == NULL) {
    // mdlerror(parse_state, &quot;Error creating 'prod_signature' field for reaction
    // pathway.&quot;);
    free(path);
    return MCELL_FAIL;
  }

  if ((!distinguishable(vacancy_search_dist2, 0, EPS_C)) &amp;&amp;
      (num_surf_products &gt; num_surface_mols)) {
    /* the case with one volume molecule reacting with the surface
       and producing one surface molecule is excluded */
    if (!((num_surface_mols == 0) &amp;&amp; (num_vol_mols == 1))) {
      // mdlerror(parse_state, &quot;Error: number of surface products exceeds number
      // of surface reactants, but VACANCY_SEARCH_DISTANCE is not specified or
      // set to zero.&quot;);
      free(path);
      return MCELL_FAIL;
    }
  }

  /* Now go back to the original reaction and if there is a &quot;surface_class&quot;
     among products - remove it.  We do not need it now on the product side
     of the reaction */
  if (is_surf_class) {
    prodp = pathp-&gt;product_head;
    if (prodp-&gt;prod-&gt;flags &amp; IS_SURFACE) {
      pathp-&gt;product_head = prodp-&gt;next;
      prodp-&gt;next = NULL;
      // mem_put(parse_state-&gt;prod_mem, (void *)prodp);
    } else if (prodp-&gt;next-&gt;prod-&gt;flags &amp; IS_SURFACE) {
      // struct product *temp = prodp-&gt;next;
      prodp-&gt;next = prodp-&gt;next-&gt;next;
      // mem_put(parse_state-&gt;prod_mem, temp);
    } else {
      // struct product *temp = prodp-&gt;next-&gt;next;
      prodp-&gt;next-&gt;next = prodp-&gt;next-&gt;next-&gt;next;
      // mem_put(parse_state-&gt;prod_mem, temp);
    }
  }

  path-&gt;next = rx-&gt;pathway_head;
  rx-&gt;pathway_head = path;
  return 0;
}

/************************************************************************
 * static helper functions
 ************************************************************************/

/*************************************************************************
 sort_product_list_compare:
    Comparison function for products to be sorted when generating the product
    signature.

 In:  list_item: first item to compare
      new_item:  second item to compare
 Out: -1 if list_item &lt; new_item, 1 if list_item &gt; new_item, 0 if they are
      equal

  XXX Currently this function also appears in mdlparse_util.c. It should
      eventually be removed from there and only appear in this file.
*************************************************************************/
static int sort_product_list_compare(struct product *list_item,
                                     struct product *new_item) {

  int cmp = strcmp(list_item-&gt;prod-&gt;sym-&gt;name, new_item-&gt;prod-&gt;sym-&gt;name);
  if (cmp == 0) {
    if (list_item-&gt;orientation &gt; new_item-&gt;orientation)
      cmp = -1;
    else if (list_item-&gt;orientation &lt; new_item-&gt;orientation)
      cmp = 1;
    else
      cmp = 0;
  }
  return cmp;
}

/*************************************************************************
 sort_product_list:
    Sorts product_head in alphabetical order, and descending orientation order.
    Current algorithm uses insertion sort.

 In:  product_head: list to sort
 Out: the new list head

  XXX Currently this function also appears in mdlparse_util.c. It should
      eventually be removed from there and only appear in this file.
*************************************************************************/
static struct product *sort_product_list(struct product *product_head) {
  struct product *next; /* Saved next item (next field in product is
                           overwritten) */
  struct product *iter;          /* List iterator */
  struct product *result = NULL; /* Sorted list */
  int cmp;

  /* Use insertion sort to sort the list of products */
  for (struct product *current = product_head; current != NULL;
       current = next) {
    next = current-&gt;next;

    /* First item added always goes at the head */
    if (result == NULL) {
      current-&gt;next = result;
      result = current;
      continue;
    }

    /* Check if the item belongs at the head */
    cmp = sort_product_list_compare(result, current);
    if (cmp &gt;= 0) {
      current-&gt;next = result;
      result = current;
      continue;
    }

    /* Otherwise, if it goes after the current entry, scan forward to find the
       insert point */
    else {
      /* locate the node before the point of insertion */
      iter = result;
      while (iter-&gt;next != NULL &amp;&amp; sort_product_list_compare(iter, current) &lt; 0)
        iter = iter-&gt;next;

      current-&gt;next = iter-&gt;next;
      iter-&gt;next = current;
    }
  }

  return result;
}

/*************************************************************************
 create_prod_signature:
    Returns a string containing all products in the product_head list,
    separated by '+', and sorted in alphabetical order by name and descending
    orientation order.

 In:  product_head: list of products
 Out: product signature as a string.  *product_head list is sorted in
      alphabetical order by name, and descending order by orientation.  Returns
      NULL on failure.

  XXX Currently this function also appears in mdlparse_util.c. It should
      eventually be removed from there and only appear in this file.
*************************************************************************/
char *create_prod_signature(struct product **product_head) {
  /* points to the head of the sorted alphabetically list of products */
  char *prod_signature = NULL;

  *product_head = sort_product_list(*product_head);

  /* create prod_signature string */
  struct product *current = *product_head;
  if (current == NULL) {
    return NULL;
  }
  prod_signature = CHECKED_STRDUP(current-&gt;prod-&gt;sym-&gt;name, &quot;product name&quot;);

  /* Concatenate to create product signature */
  char *temp_str = NULL;
  while (current-&gt;next != NULL) {
    temp_str = prod_signature;
    prod_signature = CHECKED_SPRINTF(&quot;%s+%s&quot;, prod_signature,
                                     current-&gt;next-&gt;prod-&gt;sym-&gt;name);

    if (prod_signature == NULL) {
      if (temp_str != NULL)
        free(temp_str);
      return NULL;
    }
    if (temp_str != NULL)
      free(temp_str);

    current = current-&gt;next;
  }

  return prod_signature;
}

/*************************************************************************
 * init_reactions and related machinery
 *************************************************************************/

/*************************************************************************
 check_duplicate_special_reactions:
   Check for duplicate special reaction pathways (e.g. TRANSPARENT = molecule).

 In: path: Parse-time structure for reaction pathways
 Out: Nothing.
 Note: I'm not sure if this code is ever actually called.
*************************************************************************/
void check_duplicate_special_reactions(struct pathway *path) {
  /* if it is a special reaction - check for the duplicates pathways */
  if (path-&gt;next != NULL) {
    if ((path-&gt;flags &amp; PATHW_TRANSP) &amp;&amp; (path-&gt;next-&gt;flags &amp; PATHW_TRANSP)) {
      if ((path-&gt;orientation2 == path-&gt;next-&gt;orientation2) ||
          (path-&gt;orientation2 == 0) || (path-&gt;next-&gt;orientation2 == 0)) {
        mcell_error(&quot;Exact duplicates of special reaction TRANSPARENT = %s are &quot;
                    &quot;not allowed.  Please verify the contents of &quot;
                    &quot;DEFINE_SURFACE_CLASS statement.&quot;,
                    path-&gt;reactant2-&gt;sym-&gt;name);
      }
    }

    if ((path-&gt;flags &amp; PATHW_REFLEC) &amp;&amp; (path-&gt;next-&gt;flags &amp; PATHW_REFLEC)) {
      if ((path-&gt;orientation2 == path-&gt;next-&gt;orientation2) ||
          (path-&gt;orientation2 == 0) || (path-&gt;next-&gt;orientation2 == 0)) {
        mcell_error(&quot;Exact duplicates of special reaction REFLECTIVE = %s are &quot;
                    &quot;not allowed.  Please verify the contents of &quot;
                    &quot;DEFINE_SURFACE_CLASS statement.&quot;,
                    path-&gt;reactant2-&gt;sym-&gt;name);
      }
    }
    if ((path-&gt;flags &amp; PATHW_ABSORP) &amp;&amp; (path-&gt;next-&gt;flags &amp; PATHW_ABSORP)) {
      if ((path-&gt;orientation2 == path-&gt;next-&gt;orientation2) ||
          (path-&gt;orientation2 == 0) || (path-&gt;next-&gt;orientation2 == 0)) {
        mcell_error(&quot;Exact duplicates of special reaction ABSORPTIVE = %s are &quot;
                    &quot;not allowed.  Please verify the contents of &quot;
                    &quot;DEFINE_SURFACE_CLASS statement.&quot;,
                    path-&gt;reactant2-&gt;sym-&gt;name);
      }
    }
  }
}

/*************************************************************************
 set_product_geometries:

  Walk through the list, setting the geometries of each of the products. We do
  this by looking for an earlier geometric match and pointing there or we just
  point to 0 if there is no match.

 In: path: Parse-time structure for reaction pathways
     rx: Pathways leading away from a given intermediate
     prod: Parse-time structure for products of reaction pathways
 Out: max_num_surf_products: Maximum number of surface products
*************************************************************************/
int set_product_geometries(struct pathway *path, struct rxn *rx,
                           struct product *prod) {
  int recycled1, recycled2, recycled3;
  int k, kk, k2;
  short geom;
  struct product *prod2;
  int max_num_surf_products; /* maximum number of surface products */
  int num_surf_products_per_pathway;
  max_num_surf_products = 0;
  for (int n_pathway = 0; path != NULL; n_pathway++, path = path-&gt;next) {
    recycled1 = 0;
    recycled2 = 0;
    recycled3 = 0;
    k = rx-&gt;product_idx[n_pathway] + rx-&gt;n_reactants;
    num_surf_products_per_pathway = 0;
    for (prod = path-&gt;product_head; prod != NULL; prod = prod-&gt;next) {
      if (recycled1 == 0 &amp;&amp; prod-&gt;prod == path-&gt;reactant1) {
        recycled1 = 1;
        kk = rx-&gt;product_idx[n_pathway] + 0;
      } else if (recycled2 == 0 &amp;&amp; prod-&gt;prod == path-&gt;reactant2) {
        recycled2 = 1;
        kk = rx-&gt;product_idx[n_pathway] + 1;
      } else if (recycled3 == 0 &amp;&amp; prod-&gt;prod == path-&gt;reactant3) {
        recycled3 = 1;
        kk = rx-&gt;product_idx[n_pathway] + 2;
      } else {
        kk = k;
        k++;
      }

      if (prod-&gt;prod-&gt;flags &amp; ON_GRID)
        num_surf_products_per_pathway++;

      rx-&gt;players[kk] = prod-&gt;prod;

      if ((prod-&gt;orientation + path-&gt;orientation1) *
                  (prod-&gt;orientation - path-&gt;orientation1) ==
              0 &amp;&amp;
          prod-&gt;orientation * path-&gt;orientation1 != 0) {
        if (prod-&gt;orientation == path-&gt;orientation1)
          rx-&gt;geometries[kk] = 1;
        else
          rx-&gt;geometries[kk] = -1;
      } else if (rx-&gt;n_reactants &gt; 1 &amp;&amp;
                 (prod-&gt;orientation + path-&gt;orientation2) *
                         (prod-&gt;orientation - path-&gt;orientation2) ==
                     0 &amp;&amp;
                 prod-&gt;orientation * path-&gt;orientation2 != 0) {
        if (prod-&gt;orientation == path-&gt;orientation2)
          rx-&gt;geometries[kk] = 2;
        else
          rx-&gt;geometries[kk] = -2;
      } else if (rx-&gt;n_reactants &gt; 2 &amp;&amp;
                 (prod-&gt;orientation + path-&gt;orientation3) *
                         (prod-&gt;orientation - path-&gt;orientation3) ==
                     0 &amp;&amp;
                 prod-&gt;orientation * path-&gt;orientation3 != 0) {
        if (prod-&gt;orientation == path-&gt;orientation3)
          rx-&gt;geometries[kk] = 3;
        else
          rx-&gt;geometries[kk] = -3;
      } else {
        k2 = 2 * rx-&gt;n_reactants + 1; /* Geometry index of first non-reactant
                                         product, counting from 1. */
        geom = 0;
        for (prod2 = path-&gt;product_head;
             prod2 != prod &amp;&amp; prod2 != NULL &amp;&amp; geom == 0; prod2 = prod2-&gt;next) {
          if ((prod2-&gt;orientation + prod-&gt;orientation) *
                      (prod2-&gt;orientation - prod-&gt;orientation) ==
                  0 &amp;&amp;
              prod-&gt;orientation * prod2-&gt;orientation != 0) {
            if (prod2-&gt;orientation == prod-&gt;orientation)
              geom = 1;
            else
              geom = -1;
          } else
            geom = 0;

          if (recycled1 == 1) {
            if (prod2-&gt;prod == path-&gt;reactant1) {
              recycled1 = 2;
              geom *= rx-&gt;n_reactants + 1;
            }
          } else if (recycled2 == 1) {
            if (prod2-&gt;prod == path-&gt;reactant2) {
              recycled2 = 2;
              geom *= rx-&gt;n_reactants + 2;
            }
          } else if (recycled3 == 1) {
            if (prod2-&gt;prod == path-&gt;reactant3) {
              recycled3 = 2;
              geom *= rx-&gt;n_reactants + 3;
            }
          } else {
            geom *= k2;
            k2++;
          }
        }
        rx-&gt;geometries[kk] = geom;
      }
      if (num_surf_products_per_pathway &gt; max_num_surf_products)
        max_num_surf_products = num_surf_products_per_pathway;
    }

    k = rx-&gt;product_idx[n_pathway];
    if (recycled1 == 0)
      rx-&gt;players[k] = NULL;
    if (recycled2 == 0 &amp;&amp; rx-&gt;n_reactants &gt; 1)
      rx-&gt;players[k + 1] = NULL;
    if (recycled3 == 0 &amp;&amp; rx-&gt;n_reactants &gt; 2)
      rx-&gt;players[k + 2] = NULL;
  } /* end for (n_pathway = 0, ...) */
  return max_num_surf_products;
}

/*************************************************************************
 alphabetize_pathway:
    The reaction pathway (path) is alphabetized.

 In: path: Parse-time structure for reaction pathways
     reaction: Reaction pathways leading away from a given intermediate
 Out: Nothing.
*************************************************************************/
void alphabetize_pathway(struct pathway *path, struct rxn *reaction) {
  short geom, geom2;
  struct species *temp_sp, *temp_sp2;

  /* Alphabetize if we have two molecules */
  if ((path-&gt;reactant2-&gt;flags &amp; IS_SURFACE) == 0) {
    if (strcmp(path-&gt;reactant1-&gt;sym-&gt;name, path-&gt;reactant2-&gt;sym-&gt;name) &gt; 0) {
      temp_sp = path-&gt;reactant1;
      path-&gt;reactant1 = path-&gt;reactant2;
      path-&gt;reactant2 = temp_sp;
      geom = path-&gt;orientation1;
      path-&gt;orientation1 = path-&gt;orientation2;
      path-&gt;orientation2 = geom;
    } else if (strcmp(path-&gt;reactant1-&gt;sym-&gt;name, path-&gt;reactant2-&gt;sym-&gt;name) ==
               0) {
      if (path-&gt;orientation1 &lt; path-&gt;orientation2) {
        geom = path-&gt;orientation1;
        path-&gt;orientation1 = path-&gt;orientation2;
        path-&gt;orientation2 = geom;
      }
    }
  }

  /* Alphabetize if we have three molecules */
  if (reaction-&gt;n_reactants == 3) {
    if ((path-&gt;reactant3-&gt;flags &amp; IS_SURFACE) == 0) {
      if (strcmp(path-&gt;reactant1-&gt;sym-&gt;name, path-&gt;reactant3-&gt;sym-&gt;name) &gt; 0) {
        /* Put reactant3 at the beginning */
        temp_sp = path-&gt;reactant1;
        geom = path-&gt;orientation1;
        path-&gt;reactant1 = path-&gt;reactant3;
        path-&gt;orientation1 = path-&gt;orientation3;

        /* Put former reactant1 in place of reactant2 */
        temp_sp2 = path-&gt;reactant2;
        geom2 = path-&gt;orientation2;
        path-&gt;reactant2 = temp_sp;
        path-&gt;orientation2 = geom;

        /* Put former reactant2 in place of reactant3 */
        path-&gt;reactant3 = temp_sp2;
        path-&gt;orientation3 = geom2;

      } else if (strcmp(path-&gt;reactant2-&gt;sym-&gt;name,
                        path-&gt;reactant3-&gt;sym-&gt;name) &gt; 0) {

        /* Put reactant3 after reactant1 */
        temp_sp = path-&gt;reactant2;
        path-&gt;reactant2 = path-&gt;reactant3;
        path-&gt;reactant3 = temp_sp;
        geom = path-&gt;orientation2;
        path-&gt;orientation2 = path-&gt;orientation3;
        path-&gt;orientation3 = geom;
      }
    } /*end */
  }
}

/*************************************************************************
 warn_about_high_rates:
    If HIGH_REACTION_PROBABILITY is set to WARNING or ERROR, and the reaction
    probability is high, give the user a warning or error respectively.

 In: notify:
     warn_file: The log/error file. Can be stdout/stderr
     rate_warn: If 1, warn the user about high reaction rates (or give error)
     print_once: If the warning has been printed once, don't repeat it
 Out: print_once. Also print out reaction probabilities (with warning/error)
*************************************************************************/
static int warn_about_high_rates(struct notifications *notify, FILE *warn_file,
                                 int rate_warn, int print_once) {
  if (rate_warn) {
    if (notify-&gt;high_reaction_prob == WARN_ERROR) {
      warn_file = mcell_get_error_file();
      if (!print_once) {
        fprintf(warn_file, &quot;\n&quot;);
        fprintf(
            warn_file,
            &quot;Reaction probabilities generated for the following reactions:\n&quot;);
        print_once = 1;
      }
      fprintf(warn_file, &quot;\tError: High &quot;);
    } else {
      if (!print_once) {
        fprintf(warn_file, &quot;\n&quot;);
        fprintf(
            warn_file,
            &quot;Reaction probabilities generated for the following reactions:\n&quot;);
        print_once = 1;
      }
      if (notify-&gt;high_reaction_prob == WARN_WARN)
        fprintf(warn_file, &quot;\tWarning: High &quot;);
      else
        fprintf(warn_file, &quot;\t&quot;);
    }
  } else {
    if (!print_once) {
      fprintf(warn_file, &quot;\n&quot;);
      fprintf(
          warn_file,
          &quot;Reaction probabilities generated for the following reactions:\n&quot;);
      print_once = 1;
    }
    fprintf(warn_file, &quot;\t&quot;);
  }
  return print_once;
}

/*************************************************************************
 add_surface_reaction_flags:

 In:  mol_sym_table:
      all_mols:
      all_surface_mols:
      all_volume_mols:
 Out: Nothing
*************************************************************************/
void add_surface_reaction_flags(struct sym_table_head *mol_sym_table,
                                struct species *all_mols,
                                struct species *all_surface_mols,
                                struct species *all_volume_mols) {
  struct species *temp_sp;

  /* Add flags for surface reactions with ALL_MOLECULES */
  if (all_mols-&gt;flags &amp; (CAN_VOLWALL | CAN_SURFWALL)) {
    for (int n_mol_bin = 0; n_mol_bin &lt; mol_sym_table-&gt;n_bins;
         n_mol_bin++) {
      for (struct sym_entry *symp = mol_sym_table-&gt;entries[n_mol_bin];
           symp != NULL; symp = symp-&gt;next) {
        temp_sp = (struct species *)symp-&gt;value;
        if (temp_sp == all_mols)
          continue;
        if (temp_sp == all_volume_mols)
          continue;
        if (temp_sp == all_surface_mols)
          continue;

        if (((temp_sp-&gt;flags &amp; NOT_FREE) == 0) &amp;&amp;
            ((temp_sp-&gt;flags &amp; CAN_VOLWALL) == 0)) {
          temp_sp-&gt;flags |= CAN_VOLWALL;
        } else if ((temp_sp-&gt;flags &amp; ON_GRID) &amp;&amp;
                   ((temp_sp-&gt;flags &amp; CAN_REGION_BORDER) == 0)) {
          temp_sp-&gt;flags |= CAN_REGION_BORDER;
        }
      }
    }
  }

  /* Add flags for surface reactions with ALL_VOLUME_MOLECULES */
  if (all_volume_mols-&gt;flags &amp; CAN_VOLWALL) {
    for (int n_mol_bin = 0; n_mol_bin &lt; mol_sym_table-&gt;n_bins;
         n_mol_bin++) {
      for (struct sym_entry *symp = mol_sym_table-&gt;entries[n_mol_bin];
           symp != NULL; symp = symp-&gt;next) {
        temp_sp = (struct species *)symp-&gt;value;
        if (temp_sp == all_mols)
          continue;
        if (temp_sp == all_volume_mols)
          continue;
        if (temp_sp == all_surface_mols)
          continue;
        if (((temp_sp-&gt;flags &amp; NOT_FREE) == 0) &amp;&amp;
            ((temp_sp-&gt;flags &amp; CAN_VOLWALL) == 0)) {
          temp_sp-&gt;flags |= CAN_VOLWALL;
        }
      }
    }
  }

  /* Add flags for surface reactions with ALL_SURFACE_MOLECULES */
  if (all_surface_mols-&gt;flags &amp; CAN_SURFWALL) {
    for (int n_mol_bin = 0; n_mol_bin &lt; mol_sym_table-&gt;n_bins;
         n_mol_bin++) {
      for (struct sym_entry *symp = mol_sym_table-&gt;entries[n_mol_bin];
           symp != NULL; symp = symp-&gt;next) {
        temp_sp = (struct species *)symp-&gt;value;
        if (temp_sp == all_mols)
          continue;
        if (temp_sp == all_volume_mols)
          continue;
        if (temp_sp == all_surface_mols)
          continue;
        if (((temp_sp-&gt;flags &amp; ON_GRID) &amp;&amp;
             ((temp_sp-&gt;flags &amp; CAN_REGION_BORDER) == 0))) {
          temp_sp-&gt;flags |= CAN_REGION_BORDER;
        }
      }
    }
  }
}

/*************************************************************************
 scale_rxn_probabilities:

  Scale probabilities, notifying and warning as appropriate.

 In: reaction_prob_limit_flag:
     path: Parse-time structure for reaction pathways
     rx: Pathways leading away from a given intermediate
     pb_factor:
 Out: Return 1 if rates are high and HIGH_REACTION_PROBABILITY is set to ERROR
 Note: This does not work properly right now. Even if rates are high and
       HIGH_REACTION_PROBABILITY is set to ERROR, the error is ignored
*************************************************************************/
int scale_rxn_probabilities(unsigned char *reaction_prob_limit_flag,
                        struct notifications *notify,
                        struct pathway *path, struct rxn *rx,
                        double pb_factor) {
  int print_once = 0; /* flag */
  FILE *warn_file;
  int is_gigantic;
  double rate;

  for (int n_pathway = 0; path != NULL; n_pathway++, path = path-&gt;next) {
    int rate_notify = 0, rate_warn = 0;
    if (!distinguishable(rx-&gt;cum_probs[n_pathway], GIGANTIC, EPS_C))
      is_gigantic = 1;
    else
      is_gigantic = 0;

    /* automatic surface reactions will be printed out from 'init_sim()'. */
    if (is_gigantic)
      continue;

    rate = pb_factor * rx-&gt;cum_probs[n_pathway];
    rx-&gt;cum_probs[n_pathway] = rate;

    if ((notify-&gt;reaction_probabilities == NOTIFY_FULL &amp;&amp;
         ((rate &gt;= notify-&gt;reaction_prob_notify) ||
          (notify-&gt;reaction_prob_notify == 0.0))))
      rate_notify = 1;
    if ((notify-&gt;high_reaction_prob != WARN_COPE &amp;&amp;
         ((rate &gt;= notify-&gt;reaction_prob_warn) ||
          ((notify-&gt;reaction_prob_warn == 0.0)))))
      rate_warn = 1;

    if ((rate &gt; 1.0) &amp;&amp; (!*reaction_prob_limit_flag)) {
      *reaction_prob_limit_flag = 1;
    }

    if (rate_warn || rate_notify) {

      warn_file = mcell_get_log_file();

      print_once =
          warn_about_high_rates(notify, warn_file, rate_warn,
                                print_once);

      fprintf(warn_file, &quot;Probability %.4e set for &quot;, rate);

      if (rx-&gt;n_reactants == 1)
        fprintf(warn_file, &quot;%s{%d} -&gt; &quot;, rx-&gt;players[0]-&gt;sym-&gt;name,
                rx-&gt;geometries[0]);
      else if (rx-&gt;n_reactants == 2) {
        if (rx-&gt;players[1]-&gt;flags &amp; IS_SURFACE) {
          fprintf(warn_file, &quot;%s{%d} @ %s{%d} -&gt; &quot;, rx-&gt;players[0]-&gt;sym-&gt;name,
                  rx-&gt;geometries[0], rx-&gt;players[1]-&gt;sym-&gt;name,
                  rx-&gt;geometries[1]);
        } else {
          fprintf(warn_file, &quot;%s{%d} + %s{%d} -&gt; &quot;, rx-&gt;players[0]-&gt;sym-&gt;name,
                  rx-&gt;geometries[0], rx-&gt;players[1]-&gt;sym-&gt;name,
                  rx-&gt;geometries[1]);
        }
      } else {
        if (rx-&gt;players[2]-&gt;flags &amp; IS_SURFACE) {
          fprintf(warn_file, &quot;%s{%d} + %s{%d}  @ %s{%d} -&gt; &quot;,
                  rx-&gt;players[0]-&gt;sym-&gt;name, rx-&gt;geometries[0],
                  rx-&gt;players[1]-&gt;sym-&gt;name, rx-&gt;geometries[1],
                  rx-&gt;players[2]-&gt;sym-&gt;name, rx-&gt;geometries[2]);
        } else {
          fprintf(warn_file, &quot;%s{%d} + %s{%d}  + %s{%d} -&gt; &quot;,
                  rx-&gt;players[0]-&gt;sym-&gt;name, rx-&gt;geometries[0],
                  rx-&gt;players[1]-&gt;sym-&gt;name, rx-&gt;geometries[1],
                  rx-&gt;players[2]-&gt;sym-&gt;name, rx-&gt;geometries[2]);
        }
      }
      if (path-&gt;product_head == NULL) {
        fprintf(warn_file, &quot;NULL &quot;);
      } else {
        for (struct product *prod = path-&gt;product_head; prod != NULL;
             prod = prod-&gt;next) {
          fprintf(warn_file, &quot;%s{%d} &quot;, prod-&gt;prod-&gt;sym-&gt;name,
                  prod-&gt;orientation);
        }
      }

      fprintf(warn_file, &quot;\n&quot;);

      if (rate_warn &amp;&amp; notify-&gt;high_reaction_prob == WARN_ERROR)
        return 1;
    }
  }
  return 0;
}

/*************************************************************************
 equivalent_geometry_for_two_reactants:

 In: o1a: orientation of the first reactant from first reaction
     o1b: orientation of the second reactant from first reaction
     o2a: orientation of the first reactant from second reaction
     o2b: orientation of the second reactant from second reaction
 Out: Returns 1 if the two pathways (defined by pairs o1a-o1b and o2a-o2b)
      have equivalent geometry, 0 otherwise.
*************************************************************************/
static int equivalent_geometry_for_two_reactants(int o1a, int o1b, int o2a,
                                                 int o2b) {

  /* both reactants for each pathway are in the same
     orientation class and parallel one another */
  if ((o1a == o1b) &amp;&amp; (o2a == o2b)) {
    return 1;
    /* both reactants for each pathway are in the same
       orientation class and opposite one another */
  } else if ((o1a == -o1b) &amp;&amp; (o2a == -o2b)) {
    return 1;
  }
  /* reactants are not in the same orientation class */
  if (abs(o1a) != abs(o1b)) {
    if ((abs(o2a) != abs(o2b)) || ((o2a == 0) &amp;&amp; (o2b == 0))) {
      return 1;
    }
  }
  if (abs(o2a) != abs(o2b)) {
    if ((abs(o1a) != abs(o1b)) || ((o1a == 0) &amp;&amp; (o1b == 0))) {
      return 1;
    }
  }

  return 0;
}

/*************************************************************************
 equivalent_geometry:

 In: p1, p2: pathways to compare
     n: The number of reactants for the pathways
 Out: Returns 1 if the two pathways are the same (i.e. have equivalent
      geometry), 0 otherwise.
*************************************************************************/
static int equivalent_geometry(struct pathway *p1, struct pathway *p2, int n) {

  short o11, o12, o13, o21, o22, o23; /* orientations of individual reactants */
  /* flags for 3-reactant reactions signaling whether molecules orientations
   * are parallel one another and molecule and surface orientaions are parallel
   * one another
   */
  int mols_parallel_1 = SHRT_MIN + 1;     /* for first pathway */
  int mols_parallel_2 = SHRT_MIN + 2;     /* for second pathway */
  int mol_surf_parallel_1 = SHRT_MIN + 3; /* for first pathway */
  int mol_surf_parallel_2 = SHRT_MIN + 4; /* for second pathway */

  if (n &lt; 2) {
    /* one reactant case */
    /* RULE: all one_reactant pathway geometries are equivalent */

    return 1;

  } else if (n &lt; 3) {
    /* two reactants case */

    /* RULE - Two pathways have equivalent geometry when:
       1) Both pathways have exactly the same number of reactants;
       2) There exists an identity mapping between reactants from Pathway 1 and
          Pathway 2 such that for each pair of reactants, r1a and r1b from
       Pathway
          1, and r2a, and r2b from Pathway 2:
         - r1a is the same species as r2a (likewise for r1b and r2b);
         - r1a and r1b have the same orientation in the same orientation class
           if and only if r2a and r2b do;
         - r1a and r1b have the opposite orientation in the same orientation
           class if and only if r2a and r2b do;
         - r1a and r1b are not in the same orientation class, either because
           they have different orientation classes or both are in the zero
           orientation class, if and only if r2a and r2b are not in the same
           orientation class or both are in the zero orientation class
     */

    o11 = p1-&gt;orientation1;
    o12 = p1-&gt;orientation2;
    o21 = p2-&gt;orientation1;
    o22 = p2-&gt;orientation2;

    return equivalent_geometry_for_two_reactants(o11, o12, o21, o22);

  } else if (n &lt; 4) {
    /* three reactants case */

    o11 = p1-&gt;orientation1;
    o12 = p1-&gt;orientation2;
    o13 = p1-&gt;orientation3;
    o21 = p2-&gt;orientation1;
    o22 = p2-&gt;orientation2;
    o23 = p2-&gt;orientation3;

    /* special case: two identical reactants */
    if ((p1-&gt;reactant1 == p1-&gt;reactant2) &amp;&amp; (p2-&gt;reactant1 == p2-&gt;reactant2)) {

      /* Case 1: two molecules and surface are in the same orientation class */
      if ((abs(o11) == abs(o12)) &amp;&amp; (abs(o11) == abs(o13))) {
        if (o11 == o12)
          mols_parallel_1 = 1;
        else
          mols_parallel_1 = 0;

        if (mols_parallel_1) {
          if ((o11 == -o13) || (o12 == -o13)) {
            mol_surf_parallel_1 = 0;
          } else {
            mol_surf_parallel_1 = 1;
          }
        } else {
          mol_surf_parallel_1 = 0;
        }

        if ((abs(o21) == abs(o22)) &amp;&amp; (abs(o21) == abs(o23))) {
          if (o21 == o22)
            mols_parallel_2 = 1;
          else
            mols_parallel_2 = 0;

          if (mols_parallel_2) {
            if ((o21 == -o23) || (o22 == -o23)) {
              mol_surf_parallel_2 = 0;
            } else {
              mol_surf_parallel_2 = 1;
            }
          } else {
            mol_surf_parallel_2 = 0;
          }
        }

        if ((mols_parallel_1 == mols_parallel_2) &amp;&amp;
            (mol_surf_parallel_1 == mol_surf_parallel_2)) {
          return 1;
        }

      } /* end case 1 */

      /* Case 2: one molecule and surface are in the same orientation class */
      else if ((abs(o11) == abs(o13)) || (abs(o12) == abs(o13))) {
        if ((o11 == o13) || (o12 == o13))
          mol_surf_parallel_1 = 1;
        else
          mol_surf_parallel_1 = 0;

        /* check that pathway2 is also in the case2 */

        if ((abs(o21) != abs(o23)) || (abs(o22) != abs(o23))) {
          if ((abs(o21) == abs(o23)) || (abs(o22) == abs(o23))) {
            if ((o21 == o23) || (o22 == o23))
              mol_surf_parallel_2 = 1;
            else
              mol_surf_parallel_2 = 0;
          }
        }
        if (mol_surf_parallel_1 == mol_surf_parallel_2) {
          return 1;
        }

      } /* end case 2 */

      /* Case 3: two molecules but not surface are in the same
                 orientation class */
      else if ((abs(o11) == abs(o12)) &amp;&amp; (abs(o11) != abs(o13))) {
        if (o11 == o12)
          mols_parallel_1 = 1;
        else
          mols_parallel_1 = 0;

        if ((abs(o21) == abs(o22)) &amp;&amp; (abs(o21) != abs(o23))) {
          if (o21 == o22)
            mols_parallel_2 = 1;
          else
            mols_parallel_2 = 0;
        }
        if (mols_parallel_1 == mols_parallel_2) {
          return 1;
        }

      }
      /* Case 4: all molecules and surface are in different orientation classes
         */
      else if ((abs(o11) != abs(o13)) &amp;&amp; (abs(o12) != abs(o13)) &amp;&amp;
               (abs(o11) != abs(o12))) {

        if ((abs(o21) != abs(o23)) &amp;&amp; (abs(o22) != abs(o23)) &amp;&amp;
            (abs(o21) != abs(o22))) {
          return 1;
        }
      } /* end all cases */

    } else { /* no identical reactants */

      if ((equivalent_geometry_for_two_reactants(o11, o12, o21, o22)) &amp;&amp;
          (equivalent_geometry_for_two_reactants(o12, o13, o22, o23)) &amp;&amp;
          (equivalent_geometry_for_two_reactants(o11, o13, o21, o23))) {
        return 1;
      }
    }

  } // end if (n &lt; 4)

  return 0;
}

/*************************************************************************
 create_sibling_reaction:
    Create a sibling reaction to the given reaction -- a reaction into which
    some of the pathways may be split by split_reaction.

 In:  rx:   reaction for whom to create sibling
 Out: sibling reaction, or NULL on error
*************************************************************************/
static struct rxn *create_sibling_reaction(struct rxn *rx) {

  struct rxn *reaction = CHECKED_MALLOC_STRUCT(struct rxn, &quot;reaction&quot;);
  if (reaction == NULL)
    return NULL;
  reaction-&gt;next = NULL;
  reaction-&gt;sym = rx-&gt;sym;
  reaction-&gt;n_reactants = rx-&gt;n_reactants;
  reaction-&gt;get_reactant_diffusion = rx-&gt;get_reactant_diffusion;
  reaction-&gt;n_pathways = 0;
  reaction-&gt;cum_probs = NULL;
  reaction-&gt;product_idx = NULL;
  reaction-&gt;max_fixed_p = 0.0;
  reaction-&gt;min_noreaction_p = 0.0;
  reaction-&gt;pb_factor = 0.0;
  reaction-&gt;players = NULL;
  reaction-&gt;geometries = NULL;
  reaction-&gt;n_occurred = 0;
  reaction-&gt;n_skipped = 0.0;
  reaction-&gt;prob_t = NULL;
  reaction-&gt;pathway_head = NULL;
  reaction-&gt;info = NULL;
  reaction-&gt;product_graph_data = NULL;
  reaction-&gt;external_reaction_data = NULL;
  return reaction;
}

/*************************************************************************
 split_reaction:
 In:  rx: reaction to split
 Out: Returns head of the linked list of reactions where each reaction
      contains only geometrically equivalent pathways
*************************************************************************/
struct rxn *split_reaction(struct rxn *rx) {
  struct rxn *curr_rxn_ptr = NULL, *head = NULL, *end = NULL;
  struct rxn *reaction;
  struct pathway *to_place, *temp;

  /* keep reference to the head of the future linked_list */
  head = end = rx;
  to_place = head-&gt;pathway_head-&gt;next;
  head-&gt;pathway_head-&gt;next = NULL;
  head-&gt;n_pathways = 1;
  while (to_place != NULL) {
    if (to_place-&gt;flags &amp;
        (PATHW_TRANSP | PATHW_REFLEC | PATHW_ABSORP | PATHW_CLAMP_CONC | PATHW_CLAMP_FLUX)) {
      reaction = create_sibling_reaction(rx);
      if (reaction == NULL)
        return NULL;

      reaction-&gt;pathway_head = to_place;
      to_place = to_place-&gt;next;
      reaction-&gt;pathway_head-&gt;next = NULL;
      ++reaction-&gt;n_pathways;

      end-&gt;next = reaction;
      end = reaction;
    } else {
      for (curr_rxn_ptr = head; curr_rxn_ptr != NULL;
           curr_rxn_ptr = curr_rxn_ptr-&gt;next) {
        if (curr_rxn_ptr-&gt;pathway_head-&gt;flags &amp;
            (PATHW_TRANSP | PATHW_REFLEC | PATHW_ABSORP))
          continue;
        if (equivalent_geometry(to_place, curr_rxn_ptr-&gt;pathway_head,
                                curr_rxn_ptr-&gt;n_reactants))
          break;
      }

      if (!curr_rxn_ptr) {
        reaction = create_sibling_reaction(rx);
        if (reaction == NULL)
          return NULL;

        end-&gt;next = reaction;
        end = reaction;

        curr_rxn_ptr = end;
      }

      temp = to_place;
      to_place = to_place-&gt;next;

      temp-&gt;next = curr_rxn_ptr-&gt;pathway_head;
      curr_rxn_ptr-&gt;pathway_head = temp;
      ++curr_rxn_ptr-&gt;n_pathways;
    }
  }

  return head;
}

/*************************************************************************
 check_reaction_for_duplicate_pathways:
 In:  head: head of linked list of pathways
 Out: Sorts linked list of pathways in alphabetical order according to the
      &quot;prod_signature&quot; field.  Checks for the duplicate pathways.  Prints error
      message and exits simulation if duplicates found.
 Note: This function is called after 'split_reaction()' function so all
       pathways have equivalent geometry from the reactant side.  Here we check
       whether relative orientation of all players (both reactants and
       products) is the same for the two seemingly identical pathways.
 RULE: Two reactions pathways are duplicates if and only if
        (a) they both have the same number and species of reactants;
        (b) they both have the same number and species of products;
        (c) there exists a bijective mapping between the reactants and products
            of the two pathways such that reactants map to reactants, products
            map to products, and the two pathways have equivalent geometry
            under mapping.
            Two pathways R1 and R2 have an equivalent geometry under a mapping
            M if and only if for every pair of players &quot;i&quot; and &quot;j&quot; in R1, the
            corresponding players M(i) and M(j) in R2 have the same orientation
            relation as do &quot;i&quot; and &quot;j&quot; in R1.
            Two players &quot;i&quot; and &quot;j&quot; in a reaction pathway have the following
            orientation:
              parallel - if both &quot;i&quot; and &quot;j&quot; are in the same nonzero orientation
              class with the same sign;
              antiparallel (opposite) - if they are both in the same nonzero
              orientation class but have opposite sign;
              independent - if they are in different orientation classes or both
              in the zero orientation class.

 PostNote: In this function we check only the validity of Rule (c) since
           conditions of Rule (a) and (b) are already satisfied when the
           function is called.
*************************************************************************/
void check_reaction_for_duplicate_pathways(struct pathway **head) {

  struct pathway *result = NULL;      /* build the sorted list here */
  struct pathway *null_result = NULL; /* put pathways with NULL
                                         prod_signature field here */
  struct pathway *current, *next, **pprev;
  struct product *iter1, *iter2;
  int pathways_equivalent; /* flag */
  int i, j;
  int num_reactants; /* number of reactants in the pathway */
  int num_products;  /* number of products in the pathway */
  int num_players;   /* total number of reactants and products in the pathway */
  int *orient_players_1,
      *orient_players_2; /* array of orientations of players */
  int o1a, o1b, o2a, o2b;

  /* extract  pathways with &quot;prod_signature&quot; field equal to NULL into
   * &quot;null_result&quot; list */
  current = *head;
  pprev = head;
  while (current != NULL) {
    if (current-&gt;prod_signature == NULL) {
      *pprev = current-&gt;next;
      current-&gt;next = null_result;
      null_result = current;
      current = *pprev;
    } else {
      pprev = &amp;current-&gt;next;
      current = current-&gt;next;
    }
  }

  /* check for duplicate pathways in null_result */
  current = null_result;
  if ((current != NULL) &amp;&amp; (current-&gt;next != NULL)) {
    /* From the previously called function &quot;split_reaction()&quot; we know that
     * reactant-reactant pairs in two pathways are equivalent. Because there
     * are no products the pathways are duplicates.
       RULE: There may be no more than one pathway with zero (---&gt;NULL)
             products in the reaction-&gt;pathway_head
             after calling the function &quot;split_reaction()&quot;
    */
    if (current-&gt;reactant2 == NULL)
      mcell_error(&quot;Exact duplicates of reaction %s  ----&gt; NULL are not &quot;
                  &quot;allowed.  Please verify that orientations of reactants are &quot;
                  &quot;not equivalent.&quot;,
                  current-&gt;reactant1-&gt;sym-&gt;name);
    else if (current-&gt;reactant3 == NULL)
      mcell_error(&quot;Exact duplicates of reaction %s + %s  ----&gt; NULL are not &quot;
                  &quot;allowed.  Please verify that orientations of reactants are &quot;
                  &quot;not equivalent.&quot;,
                  current-&gt;reactant1-&gt;sym-&gt;name, current-&gt;reactant2-&gt;sym-&gt;name);
    else
      mcell_error(&quot;Exact duplicates of reaction %s + %s + %s  ----&gt; NULL are &quot;
                  &quot;not allowed.  Please verify that orientations of reactants &quot;
                  &quot;are not equivalent.&quot;,
                  current-&gt;reactant1-&gt;sym-&gt;name, current-&gt;reactant2-&gt;sym-&gt;name,
                  current-&gt;reactant3-&gt;sym-&gt;name);
  }

  /* now sort the remaining pathway list by &quot;prod_signature&quot; field and check
   * for the duplicates */
  current = *head;

  while (current != NULL) {
    next = current-&gt;next;

    /* insert in sorted order into the &quot;result&quot; */
    if (result == NULL ||
        (strcmp(result-&gt;prod_signature, current-&gt;prod_signature) &gt;= 0)) {
      current-&gt;next = result;
      result = current;
    } else {
      struct pathway *iter = result;
      while (iter-&gt;next != NULL &amp;&amp; (strcmp(iter-&gt;next-&gt;prod_signature,
                                           current-&gt;prod_signature) &lt; 0)) {
        iter = iter-&gt;next;
      }
      current-&gt;next = iter-&gt;next;
      iter-&gt;next = current;
    }

    /* move along the original list */
    current = next;
  }

  /* Now check for the duplicate pathways */
  /* Since the list is sorted we can proceed down the list and compare the
   * adjacent nodes */

  current = result;

  if (current != NULL) {
    while (current-&gt;next != NULL) {
      if (strcmp(current-&gt;prod_signature, current-&gt;next-&gt;prod_signature) == 0) {

        pathways_equivalent = 1;
        /* find total number of players in the pathways */
        num_reactants = 0;
        num_products = 0;
        if (current-&gt;reactant1 != NULL)
          num_reactants++;
        if (current-&gt;reactant2 != NULL)
          num_reactants++;
        if (current-&gt;reactant3 != NULL)
          num_reactants++;

        iter1 = current-&gt;product_head;
        while (iter1 != NULL) {
          num_products++;
          iter1 = iter1-&gt;next;
        }

        num_players = num_reactants + num_products;

        /* create arrays of players orientations */
        orient_players_1 = CHECKED_MALLOC_ARRAY(int, num_players,
                                                &quot;reaction player orientations&quot;);
        if (orient_players_1 == NULL)
          mcell_die();
        orient_players_2 = CHECKED_MALLOC_ARRAY(int, num_players,
                                                &quot;reaction player orientations&quot;);
        if (orient_players_2 == NULL)
          mcell_die();

        if (current-&gt;reactant1 != NULL)
          orient_players_1[0] = current-&gt;orientation1;
        if (current-&gt;reactant2 != NULL)
          orient_players_1[1] = current-&gt;orientation2;
        if (current-&gt;reactant3 != NULL)
          orient_players_1[2] = current-&gt;orientation3;
        if (current-&gt;next-&gt;reactant1 != NULL)
          orient_players_2[0] = current-&gt;next-&gt;orientation1;
        if (current-&gt;next-&gt;reactant2 != NULL)
          orient_players_2[1] = current-&gt;next-&gt;orientation2;
        if (current-&gt;next-&gt;reactant3 != NULL)
          orient_players_2[2] = current-&gt;next-&gt;orientation3;

        iter1 = current-&gt;product_head;
        iter2 = current-&gt;next-&gt;product_head;

        for (i = num_reactants; i &lt; num_players; i++) {
          orient_players_1[i] = iter1-&gt;orientation;
          orient_players_2[i] = iter2-&gt;orientation;
          iter1 = iter1-&gt;next;
          iter2 = iter2-&gt;next;
        }

        /* below we will compare only reactant-product and product-product
         * combinations because reactant-reactant combinations were compared
         * previously in the function &quot;equivalent_geometry()&quot; */

        /* Initial assumption - pathways are equivalent. We check whether this
         * assumption is valid by comparing pairs as described above */

        i = 0;
        while ((i &lt; num_players) &amp;&amp; (pathways_equivalent)) {
          if (i &lt; num_reactants) {
            j = num_reactants;
          } else {
            j = i + 1;
          }
          for (; j &lt; num_players; j++) {
            o1a = orient_players_1[i];
            o1b = orient_players_1[j];
            o2a = orient_players_2[i];
            o2b = orient_players_2[j];
            if (!equivalent_geometry_for_two_reactants(o1a, o1b, o2a, o2b)) {
              pathways_equivalent = 0;
              break;
            }
          }
          i++;
        }

        if (pathways_equivalent) {
          if (current-&gt;reactant1 != NULL) {
            if (current-&gt;reactant2 == NULL)
              mcell_error(&quot;Exact duplicates of reaction %s  ----&gt; %s are not &quot;
                          &quot;allowed.  Please verify that orientations of &quot;
                          &quot;reactants are not equivalent.&quot;,
                          current-&gt;reactant1-&gt;sym-&gt;name, current-&gt;prod_signature);
            else if (current-&gt;reactant3 == NULL)
              mcell_error(&quot;Exact duplicates of reaction %s + %s  ----&gt; %s are &quot;
                          &quot;not allowed.  Please verify that orientations of &quot;
                          &quot;reactants are not equivalent.&quot;,
                          current-&gt;reactant1-&gt;sym-&gt;name,
                          current-&gt;reactant2-&gt;sym-&gt;name, current-&gt;prod_signature);
            else
              mcell_error(&quot;Exact duplicates of reaction %s + %s + %s  ----&gt; %s &quot;
                          &quot;are not allowed.  Please verify that orientations of &quot;
                          &quot;reactants are not equivalent.&quot;,
                          current-&gt;reactant1-&gt;sym-&gt;name,
                          current-&gt;reactant2-&gt;sym-&gt;name,
                          current-&gt;reactant3-&gt;sym-&gt;name, current-&gt;prod_signature);
          }
        }
        free(orient_players_1);
        free(orient_players_2);
      }

      current = current-&gt;next;
    }
  }

  if (null_result == NULL) {
    *head = result;
  } else if (result == NULL) {
    *head = null_result;
  } else {
    current = result;
    while (current-&gt;next != NULL) {
      current = current-&gt;next;
    }
    current-&gt;next = null_result;
    null_result-&gt;next = NULL;

    *head = result;
  }
}

/*************************************************************************
 set_reaction_player_flags:
    Set the reaction player flags for all participating species in this
    reaction.

 In:  rx: the reaction
 Out: Nothing.  Species flags may be updated.
*************************************************************************/
void set_reaction_player_flags(struct rxn *rx) {
  switch (rx-&gt;n_reactants) {
  case 1:
    /* do nothing */
    return;

  case 2:
    if (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, &quot;ALL_MOLECULES&quot;) == 0) {
      rx-&gt;players[0]-&gt;flags |= (CAN_VOLWALL | CAN_SURFWALL);
    } else if (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, &quot;ALL_VOLUME_MOLECULES&quot;) == 0) {
      rx-&gt;players[0]-&gt;flags |= CAN_VOLWALL;
    } else if (strcmp(rx-&gt;players[0]-&gt;sym-&gt;name, &quot;ALL_SURFACE_MOLECULES&quot;) ==
               0) {
      rx-&gt;players[0]-&gt;flags |= CAN_SURFWALL;
    } else if ((rx-&gt;players[0]-&gt;flags &amp; NOT_FREE) == 0) {
      /* two volume molecules */
      if ((rx-&gt;players[1]-&gt;flags &amp; NOT_FREE) == 0) {
        rx-&gt;players[0]-&gt;flags |= CAN_VOLVOL;
        rx-&gt;players[1]-&gt;flags |= CAN_VOLVOL;
      }
      /* one volume molecules and one wall */
      else if ((rx-&gt;players[1]-&gt;flags &amp; IS_SURFACE) != 0) {
        rx-&gt;players[0]-&gt;flags |= CAN_VOLWALL;
      }
      /* one volume molecule and one surface molecule */
      else if ((rx-&gt;players[1]-&gt;flags &amp; ON_GRID) != 0) {
        rx-&gt;players[0]-&gt;flags |= CAN_VOLSURF;
      }
    } else if ((rx-&gt;players[0]-&gt;flags &amp; IS_SURFACE) != 0) {
      /* one volume molecule and one wall */
      if ((rx-&gt;players[1]-&gt;flags &amp; NOT_FREE) == 0) {
        rx-&gt;players[1]-&gt;flags |= CAN_VOLWALL;
      }
      /* one surface molecule and one wall */
      else if ((rx-&gt;players[1]-&gt;flags &amp; ON_GRID) != 0) {
        rx-&gt;players[1]-&gt;flags |= CAN_SURFWALL;
      }
    } else if ((rx-&gt;players[0]-&gt;flags &amp; ON_GRID) != 0) {
      /* one volume molecule and one surface molecule */
      if ((rx-&gt;players[1]-&gt;flags &amp; NOT_FREE) == 0) {
        rx-&gt;players[1]-&gt;flags |= CAN_VOLSURF;
      }
      /* two surface molecules */
      else if ((rx-&gt;players[1]-&gt;flags &amp; ON_GRID) != 0) {
        rx-&gt;players[0]-&gt;flags |= CAN_SURFSURF;
        rx-&gt;players[1]-&gt;flags |= CAN_SURFSURF;
      }
      /* one surface molecule and one wall */
      else if ((rx-&gt;players[1]-&gt;flags &amp; IS_SURFACE) != 0) {
        rx-&gt;players[0]-&gt;flags |= CAN_SURFWALL;
      }
    }
    break;

  case 3:
    if ((rx-&gt;players[2]-&gt;flags &amp; IS_SURFACE) != 0) {
      /* two molecules and surface  */
      if ((rx-&gt;players[0]-&gt;flags &amp; NOT_FREE) == 0) {
        /* one volume molecule, one surface molecule, one surface */
        if ((rx-&gt;players[1]-&gt;flags &amp; ON_GRID) != 0) {
          rx-&gt;players[0]-&gt;flags |= CAN_VOLSURF;
        }
      } else if ((rx-&gt;players[0]-&gt;flags &amp; ON_GRID) != 0) {
        /* one volume molecule, one surface molecule, one surface */
        if ((rx-&gt;players[1]-&gt;flags &amp; NOT_FREE) == 0) {
          rx-&gt;players[1]-&gt;flags |= CAN_VOLSURF;
        }
        /* two surface molecules, one surface */
        else if ((rx-&gt;players[1]-&gt;flags &amp; ON_GRID) != 0) {
          rx-&gt;players[0]-&gt;flags |= CAN_SURFSURF;
          rx-&gt;players[1]-&gt;flags |= CAN_SURFSURF;
        }
      }
    } else {
      if ((rx-&gt;players[0]-&gt;flags &amp; NOT_FREE) == 0) {
        if ((rx-&gt;players[1]-&gt;flags &amp; NOT_FREE) == 0) {
          /* three volume molecules */
          if ((rx-&gt;players[2]-&gt;flags &amp; NOT_FREE) == 0) {
            rx-&gt;players[0]-&gt;flags |= CAN_VOLVOLVOL;
            rx-&gt;players[1]-&gt;flags |= CAN_VOLVOLVOL;
            rx-&gt;players[2]-&gt;flags |= CAN_VOLVOLVOL;
          }
          /* two volume molecules and one surface molecule */
          else if ((rx-&gt;players[2]-&gt;flags &amp; ON_GRID) != 0) {
            rx-&gt;players[0]-&gt;flags |= CAN_VOLVOLSURF;
            rx-&gt;players[1]-&gt;flags |= CAN_VOLVOLSURF;
          }
        } else if ((rx-&gt;players[1]-&gt;flags &amp; ON_GRID) != 0) {
          /* two volume molecules and one surface molecule */
          if ((rx-&gt;players[2]-&gt;flags &amp; NOT_FREE) == 0) {
            rx-&gt;players[0]-&gt;flags |= CAN_VOLVOLSURF;
            rx-&gt;players[2]-&gt;flags |= CAN_VOLVOLSURF;
          }
          /* one volume molecules and two surface molecules */
          else if ((rx-&gt;players[2]-&gt;flags &amp; ON_GRID) != 0) {
            rx-&gt;players[0]-&gt;flags |= CAN_VOLSURFSURF;
          }
        }
      } else if ((rx-&gt;players[0]-&gt;flags &amp; ON_GRID) != 0) {
        if ((rx-&gt;players[1]-&gt;flags &amp; NOT_FREE) == 0) {
          /* two volume molecules and one surface molecule */
          if ((rx-&gt;players[2]-&gt;flags &amp; NOT_FREE) == 0) {
            rx-&gt;players[1]-&gt;flags |= CAN_VOLVOLSURF;
            rx-&gt;players[2]-&gt;flags |= CAN_VOLVOLSURF;
          }
          /* one volume molecule and two surface molecules */
          else if ((rx-&gt;players[2]-&gt;flags &amp; ON_GRID) != 0) {
            rx-&gt;players[1]-&gt;flags |= CAN_VOLSURFSURF;
          }
        } else if ((rx-&gt;players[1]-&gt;flags &amp; ON_GRID) != 0) {
          /* one volume molecule and two surface molecules */
          if ((rx-&gt;players[2]-&gt;flags &amp; NOT_FREE) == 0) {
            rx-&gt;players[2]-&gt;flags |= CAN_VOLSURFSURF;
          }
          /* three surface molecules */
          else if ((rx-&gt;players[2]-&gt;flags &amp; ON_GRID) != 0) {
            rx-&gt;players[0]-&gt;flags |= CAN_SURFSURFSURF;
            rx-&gt;players[1]-&gt;flags |= CAN_SURFSURFSURF;
            rx-&gt;players[2]-&gt;flags |= CAN_SURFSURFSURF;
          }
        }
      }
    }
    break;

  default:
    // assert(0);
    break;
  }
}

/*************************************************************************
 build_reaction_hash_table:
    Scan the symbol table, copying all reactions found into the reaction hash.

 In:  reaction_hash:
      n_reactions:
      rxn_sym_table:
      rx_hashsize:
      num_rx: num reactions expected
 Out: 0 on success, 1 if we fail to allocate the table
*************************************************************************/
int build_reaction_hash_table(
    struct rxn ***reaction_hash, int *n_reactions,
    struct sym_table_head *rxn_sym_table, int *rx_hashsize, int num_rx) {
  struct rxn **rx_tbl = NULL;
  int rx_hash;
  for (rx_hash = 2; rx_hash &lt;= num_rx &amp;&amp; rx_hash != 0; rx_hash &lt;&lt;= 1)
    ;
  rx_hash &lt;&lt;= 1;

  if (rx_hash == 0)
    rx_hash = MAX_RX_HASH;
  if (rx_hash &gt; MAX_RX_HASH)
    rx_hash = MAX_RX_HASH;
#ifdef REPORT_RXN_HASH_STATS
  mcell_log(&quot;Num rxns: %d&quot;, num_rx);
  mcell_log(&quot;Size of hash: %d&quot;, rx_hash);
#endif

  /* Create the reaction hash table */
  *rx_hashsize = rx_hash;
  rx_hash -= 1;
  rx_tbl = CHECKED_MALLOC_ARRAY(struct rxn *, *rx_hashsize,
                                &quot;reaction hash table&quot;);
  if (rx_tbl == NULL)
    return 1;
  *reaction_hash = rx_tbl;
  for (int i = 0; i &lt;= rx_hash; i++)
    rx_tbl[i] = NULL;

#ifdef REPORT_RXN_HASH_STATS
  int numcoll = 0;
#endif
  for (int i = 0; i &lt; rxn_sym_table-&gt;n_bins; i++) {
    for (struct sym_entry *sym = rxn_sym_table-&gt;entries[i]; sym != NULL;
         sym = sym-&gt;next) {

      struct rxn *rx = (struct rxn *)sym-&gt;value;
      int table_slot;
      if (rx-&gt;n_reactants == 1) {
        table_slot = rx-&gt;players[0]-&gt;hashval &amp; rx_hash;
      } else {
        table_slot =
            (rx-&gt;players[0]-&gt;hashval + rx-&gt;players[1]-&gt;hashval) &amp; rx_hash;
      }

#ifdef REPORT_RXN_HASH_STATS
      if (rx_tbl[table_slot] != NULL) {
        mcell_log(&quot;Collision: %s and %s&quot;, rx_tbl[table_slot]-&gt;sym-&gt;name,
                  sym-&gt;name);
        ++numcoll;
      }
#endif
      *n_reactions = *n_reactions + 1;
      while (rx-&gt;next != NULL)
        rx = rx-&gt;next;
      rx-&gt;next = rx_tbl[table_slot];
      rx_tbl[table_slot] = (struct rxn *)sym-&gt;value;
    }
  }
#ifdef REPORT_RXN_HASH_STATS
  mcell_log(&quot;Num collisions: %d&quot;, numcoll);
#endif

  return 0;
}

/*****************************************************************************
 *
 * mcell_create_reaction_rates list creates a struct reaction_rates used
 * for creating reactions from a forward and backward reaction rate.
 * The backward rate is only needed for catalytic arrow and should be
 * RATE_UNUSED otherwise.
 *
 *****************************************************************************/
struct reaction_rates mcell_create_reaction_rates(int forwardRateType,
                                                  double forwardRateConstant,
                                                  int backwardRateType,
                                                  double backwardRateConstant) {
  struct reaction_rate forwardRate;
  forwardRate.rate_type = forwardRateType;
  forwardRate.v.rate_constant = forwardRateConstant;

  struct reaction_rate backwardRate;
  backwardRate.rate_type = backwardRateType;
  backwardRate.v.rate_constant = backwardRateConstant;

  struct reaction_rates rates = { forwardRate, backwardRate };

  return rates;
}

/*************************************************************************
 load_rate_file:
    Read in a time-varying reaction rate constant file.

 In:  time_unit:
      tv_rxn_mem:
      rx:    Reaction structure that we'll load the rates into.
      fname: Filename to read the rates from.
      path:  Index of the pathway that these rates apply to.
      neg_reaction: warning or error policy for negative reactions.
 Out: Returns 1 on error, 0 on success.
      Rate constants are added to the prob_t linked list. If there is a rate
      constant given for time &lt;= 0, then this rate constant is stuck into
      cum_probs and the (time &lt;= 0) entries are not added to the list.  If no
      initial rate constnat is given in the file, it is assumed to be zero.
 Note: The file format is assumed to be two columns of numbers; the first
       column is time (in seconds) and the other is rate constant (in
       appropriate units) that starts at that time.  Lines that are not numbers
       are ignored.
*************************************************************************/
int load_rate_file(struct volume* state, struct rxn *rx, char *fname, int path) {

  struct mem_helper *tv_rxn_mem = state-&gt;tv_rxn_mem;

  const char *RATE_SEPARATORS = &quot;\f\n\r\t\v ,;&quot;;
  const char *FIRST_DIGIT = &quot;+-0123456789&quot;;
  int i;
  FILE *f = fopen(fname, &quot;r&quot;);

  if (!f)
    return 1;
  else {
    struct t_func *tp, *tp2;
    double t, rate_constant;
    char buf[2048];
    char *cp;
    int linecount = 0;
#ifdef DEBUG
    int valid_linecount = 0;
#endif

    tp2 = NULL;
    while (fgets(buf, 2048, f)) {
      linecount++;
      for (i = 0; i &lt; 2048; i++) {
        if (!strchr(RATE_SEPARATORS, buf[i]))
          break;
      }

      if (i &lt; 2048 &amp;&amp; strchr(FIRST_DIGIT, buf[i])) {
        t = strtod((buf + i), &amp;cp);
        if (cp == (buf + i))
          continue; /* Conversion error. */

        for (i = cp - buf; i &lt; 2048; i++) {
          if (!strchr(RATE_SEPARATORS, buf[i]))
            break;
        }
        // This is kind of a silly corner case, but let's check for it to keep
        // coverity happy.
        if (i == 2048) {
          mcell_error(
            &quot;a time in the rate constant file consists of too many characters &quot;
            &quot;(it uses 2048 or more characters).&quot;);
          return(1);
        }
        rate_constant = strtod((buf + i), &amp;cp);
        if (cp == (buf + i))
          continue; /* Conversion error */

        /* at this point we need to handle negative reaction rate constants */
        if (rate_constant &lt; 0.0)
        {
          if (state-&gt;notify-&gt;neg_reaction == WARN_ERROR)
          {
            mcell_error(&quot;reaction rate constants should be zero or positive.&quot;);
            return 1;
          }
          else if (state-&gt;notify-&gt;neg_reaction == WARN_WARN) {
            mcell_warn(&quot;negative reaction rate constant %f; setting to zero &quot;
                       &quot;and continuing.&quot;, rate_constant);
            rate_constant = 0.0;
          }
        }

        tp = (struct t_func *)CHECKED_MEM_GET(tv_rxn_mem,
                             &quot;time-varying reaction rate constants&quot;);
        if (tp == NULL) {
          fclose(f);
          return 1;
        }
        tp-&gt;next = NULL;
        tp-&gt;path = path;

        // tp-&gt;time is in fact iteration, we need to convert the iteration correctly in case we
        // are continuing from a checkpoint with a different timestep
        tp-&gt;time = convert_seconds_to_iterations(
            state-&gt;start_iterations, state-&gt;time_unit,
            state-&gt;chkpt_start_time_seconds, t);

        tp-&gt;value = rate_constant;
        tp-&gt;value_from_file = rate_constant; // tp-&gt;value gets updated later, for MCell we need the value from file
#ifdef DEBUG
        valid_linecount++;
#endif

        if (rx-&gt;prob_t == NULL) {
          rx-&gt;prob_t = tp;
          tp2 = tp;
        } else {
          if (tp2 == NULL) {
            tp2 = tp;
            tp-&gt;next = rx-&gt;prob_t;
            rx-&gt;prob_t = tp;
          } else {
            if (tp-&gt;time &lt; tp2-&gt;time)
              mcell_warn(
                  &quot;In rate constants file '%s', line %d is out of sequence. &quot;
                  &quot;Resorting.&quot;, fname, linecount);
            tp-&gt;next = tp2-&gt;next;
            tp2-&gt;next = tp;
            tp2 = tp;
          }
        }
      }
    }

#ifdef DEBUG
    mcell_log(&quot;Read %d rate constants from file %s.&quot;, valid_linecount, fname);
#endif

    fclose(f);
  }
  return 0;
}

struct sym_entry *mcell_new_rxn_pathname(struct volume *state, char *name) {
  if ((retrieve_sym(name, state-&gt;rxpn_sym_table)) != NULL) {
    mcell_log(&quot;Named reaction pathway already defined: %s&quot;, name);
    return NULL;
  } else if ((retrieve_sym(name, state-&gt;mol_sym_table)) != NULL) {
    mcell_log(&quot;Named reaction pathway already defined as a molecule: %s&quot;, name);
    return NULL;
  }

  struct sym_entry *symp = store_sym(name, RXPN, state-&gt;rxpn_sym_table, NULL);
  if (symp == NULL) {
    mcell_log(&quot;Out of memory while creating reaction name: %s&quot;, name);
    return NULL;
  }
  return symp;
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>config-win.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/******************************************************************************
 *
 * Copyright (C) 2006-2017,2021 by
 * The Salk Institute for Biological Studies and
 * Pittsburgh Supercomputing Center, Carnegie Mellon University
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 *
******************************************************************************/

/* Windows-specific includes and defines  */
/*
This file has includes, declarations, and function definitions to make the code
compile on Windows.
The functions where problems may exist are noted below with their caveats.
Some caveats could be addressed with additional code if necessary.

Wrapped Functions:  (the function is available in Windows but certain features
are not available)
  strerror_r  - return value is POSIX-like (not GCC-like) [strerror_s is used]
  ctime_r     - must be given a fixed-sized on-stack char buffer [ctime_s is
used]
  strftime    - [adds support for many of the additional format string]
  gethostname - [adds special initialization during the first call]
  stat/fstat  - [adds support for symlink detection]
  rename      - [adds support for atomic rename]
  mkdir       - mode argument is ignored [adds the mode argument to the
declaration]

Emulated functions:
  getrusage   - only supports RUSAGE_SELF, output struct only has ru_utime and
ru_stime, errno not always set, cannot include &lt;sys/resource.h&gt;
  symlink     - always fails on XP
  alarm       - return value is not correct, must use set_alarm_handler instead
of sigaction
*/

#ifndef MCELL_CONFIG_WIN_H
#define MCELL_CONFIG_WIN_H

#ifdef _MSC_VER
typedef unsigned int mode_t;
#pragma warning( disable : 4996 )
#endif

#ifndef MINGW_HAS_SECURE_API
#define MINGW_HAS_SECURE_API /* required for MinGW to expose _s functions */
#endif

#undef __USE_MINGW_ANSI_STDIO
#define __USE_MINGW_ANSI_STDIO                                                 \
  1 /* allows use of GNU-style printf format strings */
#define PRINTF_FORMAT(arg)                                                     \
  __attribute__((__format__(                                                   \
      gnu_printf, arg, arg + 1))) /* for functions that use printf-like \ \ \                                                                             \
                                     arguments this corrects warnings */
#define PRINTF_FORMAT_V(arg) __attribute__((__format__(gnu_printf, arg, 0)))

#define WIN32_LEAN_AND_MEAN /* removes many unneeded Windows definitions */
#undef _WIN32_WINNT
#define _WIN32_WINNT 0x0502
#define _CRT_SECURE_NO_WARNINGS
#include &lt;windows.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;direct.h&gt; /* many POSIX-like functions */
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt; /* _snprintf */
#include &lt;stdint.h&gt;
#include &lt;time.h&gt;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;
// typedef int errno_t;

/* Remove some windows.h definitions that may cause problems */
#undef TRUE
#undef FALSE
#undef ERROR
#undef TRANSPARENT
#undef FILE_OVERWRITE
#undef FILE_CREATE

#ifdef _MSC_VER
#define getcwd _getcwd
#define strdup _strdup
#define va_copy(d, s) ((d) = (s))
#endif

/* Macro for eliminating &quot;unused variable&quot; or &quot;unused parameter&quot; warnings. */
#define UNUSED(p) ((void)(p))

#ifndef __GNUC__
#ifndef __attribute__
#define __attribute__(x) /* empty */
#define __restrict__
#endif
#endif

/* MinGW does not include this in any header but has it in the libraries */
#include &lt;string.h&gt; /* include this to make sure we have definitions for the \ \
                       \                                                       \
                       \ \                                                                             \
                       declaration below */
_CRTIMP errno_t __cdecl strerror_s(char *_Buf, size_t _SizeInBytes, int errnum);
inline static int strerror_r(int errnum, char *buf, size_t buflen) {
  errno_t err = strerror_s(buf, buflen, errnum);
  if (err != 0) {
    errno = err;
    return -1;
  }
  return 0;
}

/* ctime_r wrapped function */
inline static char *_ctime_r_helper(const time_t *timep, char *buf,
                                    size_t buflen) {
#if defined(_WIN64) || defined(_MSC_VER)
  errno_t err = _ctime64_s(buf, buflen, timep);
#else
  errno_t err = _ctime32_s(buf, buflen, timep);
#endif
  if (err != 0) {
    errno = err;
    return NULL;
  }
  return buf;
}
#define ctime_r(timep, buf)                                                    \
  _ctime_r_helper(timep, buf, sizeof(buf)) // char *ctime_r(const time_t *timep,
                                           // char *buf) { }

/* strftime function with many additional format codes supported on *nix
 * machines */
inline static int _is_leap_year(int y) {
  return (y &amp; 3) == 0 &amp;&amp; ((y % 25) != 0 || (y &amp; 15) == 0);
}
inline static int _iso8061_weeknum(const struct tm *timeptr) {
  int Y = timeptr-&gt;tm_year, M = timeptr-&gt;tm_mon;
  int T = timeptr-&gt;tm_mday + 4 -
          (timeptr-&gt;tm_wday == 0 ? 7 : timeptr-&gt;tm_wday); // nearest Thursday
  if (M == 12 &amp;&amp; T &gt; 31) {
    return 1;
  }
  if (M == 1 &amp;&amp; T &lt; 1) {
    --Y;
    M = 12;
    T += 31;
  }
  int D = 275 * M / 9 + T - 31 +
          (M &gt; 2 ? (_is_leap_year(Y) - 2) : 0); // day of year
  return 1 + D / 7;
}
inline static int _iso8061_wn_year(const struct tm *timeptr) {
  int T = timeptr-&gt;tm_mday + 4 -
          (timeptr-&gt;tm_wday == 0 ? 7 : timeptr-&gt;tm_wday); // nearest Thursday
  return timeptr-&gt;tm_year + 1900 +
         ((timeptr-&gt;tm_mon == 11 &amp;&amp; T &gt; 31)
              ? +1
              : ((timeptr-&gt;tm_mon == 0 &amp;&amp; T &lt; 1) ? -1 : 0));
}
inline static void _strnlwr(char *str, size_t count) {
  for (char *end = str + count; str &lt; end; ++str) {
    *str = tolower(*str);
  }
}
inline static void _strnupr(char *str, size_t count) {
  for (char *end = str + count; str &lt; end; ++str) {
    *str = toupper(*str);
  }
}
inline static void _strnchcase(char *str, size_t count) {
  for (char *end = str + count; str &lt; end; ++str) {
    *str = isupper(*str) ? tolower(*str) : toupper(*str);
  }
}
__attribute__((__format__(
    gnu_strftime, 3,
    0))) inline static size_t _win_strftime(char *strDest, size_t maxsize,
                                            const char *format,
                                            const struct tm *timeptr) {
  /* TODO: verify against *nix version, including edge cases */
  struct tm t = *timeptr;
  const char *f2, *f1 = format;
  char *out = strDest, *out_end = strDest + maxsize;
  char fbuf[3] = &quot;%%&quot;, buf[64];
  while ((f2 = strchr(f1, '%')) != NULL) {
    if (f2 - f1 &gt; out_end - out) {
      return 0;
    }
    strncpy(out, f1, f2 - f1);
    out += f2 - f1;
    ++f2;

    /* Flag */
    char flag;
    if (*f2 == '_' || *f2 == '-' || *f2 == '0' || *f2 == '^' || *f2 == '#') {
      flag = *(f2++);
    } else {
      flag = 0;
    }

    /* Width */
    size_t width = 0;
    while (isdigit(*f2)) {
      width = 10 * (width - '0') + *(f2++);
    }
    if ((ptrdiff_t)width &gt; out_end - out) {
      return 0;
    }

    /* Modifier */
    /* TODO: support modifiers, currently they are read but never used */
    // char modifier = 0;
    if (*f2 == 'E') {
      f2++;
      // if (*f2 == 'c' || *f2 == 'C' || *f2 == 'x' || *f2 == 'X' || *f2 == 'y'
      // || *f2 == 'Y')
      //    modifier = 'E'; /* E only before: c, C, x, X, y, Y */
    } else if (*f2 == 'O') {
      f2++;
      // if (*f2 == 'd' || *f2 == 'e' || *f2 == 'H' || *f2 == 'I' || *f2 == 'm'
      // || *f2 == 'M' || *f2 == 'S' || *f2 == 'u' || *f2 == 'U' || *f2 == 'V'
      // || *f2 == 'w' || *f2 == 'W' || *f2 == 'Y')
      //    modifier = 'O'; /* O only before: d, e, H, I, m, M, S, u, U, V, w,
      // W, y */
    }

<A NAME="0"></A>    /* Get content */
    size_t count;
    int is_numeric = 0, is_num_space_padded = 0;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1411-0.html#0',2,'match1411-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    switch (*f2) {
    /* single character formats */
    case 0:
      buf[0] = '%';
      count = 1;
      break;
    case 'n':
      buf[0] = '\n';
      count = 1;
      break;
    case 't':
      buf[0] = '\t';
      count = 1;
      break;</B></FONT>

    /* simple format equivalences */
    case 'h':
      count = strftime(buf, ARRAYSIZE(buf), &quot;%b&quot;, timeptr);
      break;
    case 'D':
      count = strftime(buf, ARRAYSIZE(buf), &quot;%m/%d/%y&quot;, timeptr);
      break;
    case 'F':
      count = strftime(buf, ARRAYSIZE(buf), &quot;%Y-%m-%d&quot;, timeptr);
      break;
    case 'r':
      count = strftime(buf, ARRAYSIZE(buf), &quot;%I:%M:%S %p&quot;, timeptr);
      break; /* TODO: this is actually supposed to be locale dependent? */
    case 'R':
      count = strftime(buf, ARRAYSIZE(buf), &quot;%H:%M&quot;, timeptr);
      break;
    case 'T':
      count = strftime(buf, ARRAYSIZE(buf), &quot;%H:%M:%S&quot;, timeptr);
      break;
    case '+':
      count = strftime(buf, ARRAYSIZE(buf), &quot;%a %b %d %H:%M:%S %Z %Y&quot;, timeptr);
      break;

    /* lower-case conversions */
    case 'P':
      _strnlwr(buf, count = strftime(buf, ARRAYSIZE(buf), &quot;%p&quot;, timeptr));
      break;

    /* pad with leading spaces instead of 0s */
    case 'e':
      count = strftime(buf, ARRAYSIZE(buf), &quot;%d&quot;, timeptr);
      is_num_space_padded = 1;
      is_numeric = 1;
      break;
    case 'k':
      count = strftime(buf, ARRAYSIZE(buf), &quot;%H&quot;, timeptr);
      is_num_space_padded = 1;
      is_numeric = 1;
      break;
    case 'l':
      count = strftime(buf, ARRAYSIZE(buf), &quot;%I&quot;, timeptr);
      is_num_space_padded = 1;
      is_numeric = 1;
      break;

    /* sprintf conversions */
    case 'C':
      count = _snprintf(buf, ARRAYSIZE(buf), &quot;%02u&quot;,
                        (timeptr-&gt;tm_year + 1900) / 100);
      is_numeric = 1;
      break;
    case 'u':
      count = _snprintf(buf, ARRAYSIZE(buf), &quot;%1u&quot;,
                        timeptr-&gt;tm_wday == 0 ? 7 : timeptr-&gt;tm_wday);
<A NAME="1"></A>      is_numeric = 1;
      break;
#if defined(_WIN64) || defined(_MSC_VER)
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1411-0.html#1',2,'match1411-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    case 's':
      count = _snprintf(buf, ARRAYSIZE(buf), &quot;%08Iu&quot;, mktime(&amp;t));
      is_numeric = 1;
      break;
#else
    case 's':
      count = _snprintf(buf, ARRAYSIZE(buf), &quot;%04Iu&quot;, mktime(&amp;t));
      is_numeric = 1;
      break;
#endif

    /* ISO 8601 week formats */
    case 'V':
      count = _snprintf(buf, ARRAYSIZE(buf), &quot;%02u&quot;, _iso8061_weeknum(timeptr));
      is_numeric = 1;
      break;</B></FONT>
    case 'G':
      count = _snprintf(buf, ARRAYSIZE(buf), &quot;%04u&quot;, _iso8061_wn_year(timeptr));
      is_numeric = 1;
      break;
    case 'g':
      count = _snprintf(buf, ARRAYSIZE(buf), &quot;%02u&quot;,
                        _iso8061_wn_year(timeptr) % 100);
      is_numeric = 1;
      break;

    /* supported by Windows natively (or a character that can't be converted,
     * which will be converted to empty string) */
    /* make sure is_numeric is set appropriately */
    case 'd':
    case 'H':
    case 'I':
    case 'j':
    case 'm':
    case 'M':
    case 'S':
    case 'U':
    case 'w':
    case 'W':
    case 'y':
    case 'Y':
      is_numeric = 1;
      fbuf[1] = *f2;
      count = strftime(buf, ARRAYSIZE(buf), fbuf, timeptr);
      break;
    default:
      fbuf[1] = *f2;
      count = strftime(buf, ARRAYSIZE(buf), fbuf, timeptr);
      break;
      /* TODO: not sure if Windows' %z is the same as POSIX */
    }

    /* Write output */
    size_t trim = 0;
    char padding =
        (flag == '_')
            ? ' '
            : ((flag == '0')
                   ? '0'
                   : (is_numeric ? (is_num_space_padded ? ' ' : '0') : ' '));
    if (is_numeric) {
      if (flag == '-') {
        while (trim &lt; count - 1 &amp;&amp; buf[trim] == '0') {
          ++trim;
        }
        count -= trim;
      } else if (padding == ' ') {
        for (size_t i = 0; i &lt; count - 1 &amp;&amp; buf[i] == '0'; ++i) {
          buf[i] = ' ';
        }
      }
    } else if (flag == '^') {
      _strnupr(buf, count);
    } /* convert alphabetic characters in result string to upper case */
    else if (flag == '#') {
      _strnchcase(buf, count);
    } /* swap the case of the result string */
    if ((ptrdiff_t)count &gt; out_end - out) {
      return 0;
    }
    if (count &lt; width) {
      memset(out, padding, width - count);
      out += width - count;
    }
    strncpy(out, buf + trim, count);
    out += count;
    f1 = f2 + 1;
  }
  /* copy remaining */
  size_t len = strlen(f1);
  strncpy(out, f1, len);
  out[len] = 0;
  return out - strDest + len;
}
#define strftime _win_strftime

#if 0

/* gethostname wrapped function */
#define WSADESCRIPTION_LEN 256
#define WSASYS_STATUS_LEN 128
#define SOCKET_ERROR -1
typedef struct WSAData {
  WORD wVersion;
  WORD wHighVersion;
#ifdef _WIN64
  unsigned short iMaxSockets;
  unsigned short iMaxUdpDg;
  char *lpVendorInfo;
  char szDescription[WSADESCRIPTION_LEN + 1];
  char szSystemStatus[WSASYS_STATUS_LEN + 1];
#else
  char szDescription[WSADESCRIPTION_LEN + 1];
  char szSystemStatus[WSASYS_STATUS_LEN + 1];
  unsigned short iMaxSockets;
  unsigned short iMaxUdpDg;
  char *lpVendorInfo;
#endif
} WSADATA, *LPWSADATA;
#endif

#if 0
typedef long long int(WINAPI *FUNC_WSAStartup)(WORD wVersionRequested,
                                     LPWSADATA lpWSAData);
typedef long long int(WINAPI *FUNC_WSAGetLastError)(void);
typedef long long int(WINAPI *FUNC_gethostname)(char *name, int namelen);
static FUNC_WSAStartup WSAStartup = NULL;
static FUNC_WSAGetLastError WSAGetLastError = NULL;
static FUNC_gethostname win32gethostname = NULL;
inline static int gethostname(char *name, size_t len) {
  if (len &gt; INT_MAX) {
    errno = EINVAL;
    return -1;
  }

  /* dynamically load the necessary function and initialize the Winsock DLL */
  if (win32gethostname == NULL) {
    HMODULE ws2 = LoadLibraryA(&quot;ws2_32&quot;);
    WSADATA wsaData;
    WSAStartup = (FUNC_WSAStartup)GetProcAddress(ws2, &quot;WSAStartup&quot;);
    WSAGetLastError =
        (FUNC_WSAGetLastError)GetProcAddress(ws2, &quot;WSAGetLastError&quot;);
    win32gethostname = (FUNC_gethostname)GetProcAddress(ws2, &quot;gethostname&quot;);
    if (ws2 == NULL || WSAStartup == NULL || WSAGetLastError == NULL ||
        win32gethostname == NULL || WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0) {
      if (ws2) {
        FreeLibrary(ws2);
      }
      win32gethostname = NULL;
      errno = EPERM;
      return -1;
    }
  }

  /* call the Win32 gethostname() */
  if (win32gethostname(name, (int)len) == SOCKET_ERROR) {
    /* error */
    switch (WSAGetLastError()) {
    case WSAEFAULT:
      errno = name ? ENAMETOOLONG : EFAULT;
      break;
    case WSANOTINITIALISED:
    case WSAENETDOWN:
    case WSAEINPROGRESS:
      errno = EAGAIN;
      break;
    }
    return -1;
  }
  return 0;
}
#endif

/* getrusage emulated function, normally in &lt;sys/resources.h&gt; */
#if !defined(_TIMEVAL_DEFINED) // &amp;&amp; !defined(_MSC_VER)
#define _TIMEVAL_DEFINED
struct timeval {
  long tv_sec;
  long tv_usec;
};
#endif
struct rusage {
  struct timeval ru_utime; /* user CPU time used */
  struct timeval ru_stime; /* system CPU time used */
};
#define RUSAGE_SELF 0
inline static int getrusage(int who, struct rusage *usage) {
  if (who != RUSAGE_SELF) {
    errno = EINVAL;
    return -1;
  }
  if (usage == NULL) {
    errno = EFAULT;
    return -1;
  }
  FILETIME ftCreation, ftExit, ftKernel, ftUser;
  if (GetProcessTimes(GetCurrentProcess(), &amp;ftCreation, &amp;ftExit, &amp;ftKernel,
                      &amp;ftUser) == 0) {
    /* error */
    /* FIXME: set errno based on GetLastError() */
    return -1;
  }
  ULONGLONG user =
      (((ULONGLONG)ftUser.dwHighDateTime) &lt;&lt; 32) + ftUser.dwLowDateTime;
  ULONGLONG kernel =
      (((ULONGLONG)ftKernel.dwHighDateTime) &lt;&lt; 32) + ftKernel.dwLowDateTime;

  /* Value is in 100 nanosecond intervals */
  /* t / 10000000 =&gt; timeval.sec */
  /* (t % 10000000) / 10 =&gt; timeval.usec */

  usage-&gt;ru_utime.tv_usec = (long)((user % 10000000) / 10);
  usage-&gt;ru_utime.tv_sec = (long)(user / 10000000);

  usage-&gt;ru_stime.tv_usec = (long)((kernel % 10000000) / 10);
  usage-&gt;ru_stime.tv_sec = (long)(kernel / 10000000);

  return 0;
}


static int gettimeofday(struct timeval * tp, void*)
{
    // Note: some broken versions only have 8 trailing zero's, the correct epoch has 9 trailing zero's
    // This magic number is the number of 100 nanosecond intervals since January 1, 1601 (UTC)
    // until 00:00:00 January 1, 1970
    const uint64_t EPOCH = ((uint64_t) 116444736000000000ULL);

    SYSTEMTIME  system_time;
    FILETIME    file_time;
    uint64_t    time;

    GetSystemTime( &amp;system_time );
    SystemTimeToFileTime( &amp;system_time, &amp;file_time );
    time =  ((uint64_t)file_time.dwLowDateTime )      ;
    time += ((uint64_t)file_time.dwHighDateTime) &lt;&lt; 32;

    tp-&gt;tv_sec  = (long) ((time - EPOCH) / 10000000L);
    tp-&gt;tv_usec = (long) (system_time.wMilliseconds * 1000);
    return 0;
}

#if 0
/* symlink emulated function, normally in &lt;unistd.h&gt; */
#define SYMBOLIC_LINK_FLAG_FILE 0x0
#define SYMBOLIC_LINK_FLAG_DIRECTORY 0x1
typedef long long int (WINAPI *FUNC_CreateSymbolicLink)(LPCSTR lpSymlinkFileName,
                                                 LPCSTR lpTargetFileName,
                                                 DWORD dwFlags);
static FUNC_CreateSymbolicLink CreateSymbolicLink = NULL;
inline static int _win_is_dir(const char *path) {
  DWORD attr = GetFileAttributesA(path);
  return attr != INVALID_FILE_ATTRIBUTES &amp;&amp;
         (attr &amp; FILE_ATTRIBUTE_DIRECTORY) != 0;
}
inline static int symlink(const char *oldpath, const char *newpath) {
  /* dynamically load the CreateSymbolicLink function */
  if (CreateSymbolicLink == NULL) {
    /* requires Windows Vista or newer */
    CreateSymbolicLink = (FUNC_CreateSymbolicLink)GetProcAddress(
        GetModuleHandleA(&quot;kernel32&quot;), &quot;CreateSymbolicLinkA&quot;);
    if (CreateSymbolicLink == NULL) {
      errno = EPERM;
      return -1;
    }
  }
  if (!CreateSymbolicLink(newpath, oldpath, _win_is_dir(oldpath))) {
    /* error */
    char buf[MAX_PATH + 1];
    switch (GetLastError()) {
    case ERROR_INVALID_FUNCTION:
      errno = EPERM;
      break;
    case ERROR_INVALID_REPARSE_DATA: /* when oldpath == &quot;&quot; */
    case ERROR_PATH_NOT_FOUND:
      errno = strlen(getcwd(buf, sizeof(buf))) + strlen(newpath) &gt;= MAX_PATH
                  ? ENAMETOOLONG
                  : ENOENT;
      break; /* or ENOTDIR or ELOOP(?) */
    case ERROR_ACCESS_DENIED:
      errno = _win_is_dir(newpath) ? EEXIST : EACCES;
      break; /* reports ERROR_ACCESS_DENIED when newpath already exists as a
                directory */
    case ERROR_NOT_ENOUGH_MEMORY:
      errno = ENOMEM;
      break;
    case ERROR_WRITE_PROTECT:
      errno = EROFS;
      break;
    case ERROR_INVALID_PARAMETER:
      errno = EFAULT;
      break;
    case ERROR_DISK_FULL:
      errno = ENOSPC;
      break;
    case ERROR_ALREADY_EXISTS:
      errno = EEXIST;
      break;
    default:
      errno = EIO;
      break;
    }
    return -1;
  }
  return 0;
}
#endif

/* stat and fstat wrapped function */
/* adds S_IFLNK support to stat(path, &amp;s) - necessary since Windows' stat does
 * not set S_IFLNK (or even define S_IFLNK) */
#include &lt;sys/stat.h&gt;
#ifndef FSCTL_GET_REPARSE_POINT
#define FSCTL_GET_REPARSE_POINT                                                \
  (0x00000009 &lt;&lt; 16) | (42 &lt;&lt; 2) | 0 |                                         \
      (0 &lt;&lt; 14) // CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 42, METHOD_BUFFERED,
                // FILE_ANY_ACCESS) // REPARSE_DATA_BUFFER
#endif
#define S_IFLNK 0120000
#define S_ISLNK(m) (((m) &amp; S_IFMT) == S_IFLNK)
inline static int _is_symlink(const char *path) {
  HANDLE hFile = CreateFileA(
      path, GENERIC_READ,
      FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL,
      OPEN_EXISTING, FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,
      NULL);
  if (hFile == INVALID_HANDLE_VALUE) {
    return 0;
  }
  DWORD *data = (DWORD *)malloc(MAXIMUM_REPARSE_DATA_BUFFER_SIZE), size;
  if (data == NULL) {
    CloseHandle(hFile);
    return 0;
  }
  BOOL success = DeviceIoControl(hFile, FSCTL_GET_REPARSE_POINT, NULL, 0, data,
                                 MAXIMUM_REPARSE_DATA_BUFFER_SIZE, &amp;size, NULL);
  DWORD tag = *data;
  free(data);
  CloseHandle(hFile);
  return success &amp;&amp; tag == IO_REPARSE_TAG_SYMLINK;
}
#ifdef stat
/*
we have a version of MinGW that uses a #define to map stat to _stat64
this introduces a ton of problems
to make this work we need to do something similar
since the stat structure is &quot;changing&quot; we also need an fstat...
*/
#undef stat
#undef fstat
#define stat _win_stat
#define fstat _win_fstat
struct stat { // equivalent to _stat64
  _dev_t st_dev;
  _ino_t st_ino;
  unsigned short st_mode;
  short st_nlink;
  short st_uid;
  short st_gid;
  _dev_t st_rdev;
  __MINGW_EXTENSION __int64 st_size;
  __time64_t st_atime;
  __time64_t st_mtime;
  __time64_t st_ctime;
};
inline static int stat(const char *path, struct stat *buf) {
  int retval = _stat64(path, (struct _stat64 *)buf);
  if (retval == 0 &amp;&amp; _is_symlink(path)) {
    buf-&gt;st_mode |= S_IFLNK;
  }
  return retval;
}
inline static int fstat(int fd, struct stat *buf) {
  return _fstat64(fd, (struct _stat64 *)buf);
}
#else
// we just use the normal forwarding setup
// no need to treat fstat special
inline static int _win_stat(const char *path, struct stat *buf) {
  int retval = stat(path, buf);
  if (retval == 0 &amp;&amp; _is_symlink(path)) {
    buf-&gt;st_mode |= S_IFLNK;
  }
  return retval;
}
#define stat(path, buf) _win_stat(path, buf)
#endif

/* alarm emulated function, normally in &lt;unistd.h&gt; */
/* sigaction(SIGALRM, ...) replaced by set_alarm_handler() */
#define SIGALRM 14
typedef void(__cdecl *ALARM_CB)(int);
static ALARM_CB _alarm_cb = NULL;
static HANDLE _timer = NULL;
inline static void _win_alarm_cb(PVOID lpParameter, BOOLEAN TimerOrWaitFired) {
  _timer = NULL;
  _alarm_cb(SIGALRM);
}
inline static void set_alarm_handler(ALARM_CB handler) { _alarm_cb = handler; }
inline static unsigned alarm(unsigned seconds) {
  unsigned retval = 0;
  if (_timer) {
    retval = 1; /* fixme: get actual time left in the timer and return that */
    DeleteTimerQueueTimer(NULL, _timer, NULL);
    _timer = NULL;
  }
  if (!CreateTimerQueueTimer(&amp;_timer, NULL, (WAITORTIMERCALLBACK)_win_alarm_cb,
                             NULL, seconds * 1000, 0, WT_EXECUTEONLYONCE)) {
    retval = (unsigned)-1;
  }
  return retval;
}

/* atomic rename wrapped function */
/* Windows rename is not atomic, but there is ReplaceFile (only when actually
 * replacing though) */
int _win_rename(const char *old, const char *new_name);

//#define rename _win_rename

/* mkdir wrapped function */
inline static int _win_mkdir(const char *pathname, mode_t mode) {
  /* TODO: do something with the mode argument */
  UNUSED(mode);
  return mkdir(pathname);
}
#define mkdir _win_mkdir


// some annoying macros from windows.h
#undef IGNORE
#undef DIFFERENCE

#endif
</PRE>
</div>
  </div>
</body>
</html>
