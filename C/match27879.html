<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for subsample.c &amp; thumbnail.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for subsample.c &amp; thumbnail.c
      </h3>
<h1 align="center">
        2.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>subsample.c (7.303371%)<th>thumbnail.c (1.4332966%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(243-257)<td><a href="#" name="0">(955-966)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>subsample.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;vips/vips.h&gt;
7 #include "pconversion.h"
8 typedef struct _VipsSubsample {
9 	VipsConversion parent_instance;
10 	VipsImage *in;
11 	int xfac;	
12 	int yfac;
13 	gboolean point;
14 } VipsSubsample;
15 typedef VipsConversionClass VipsSubsampleClass;
16 G_DEFINE_TYPE( VipsSubsample, vips_subsample, VIPS_TYPE_CONVERSION );
17 #define VIPS_MAX_WIDTH (100)
18 static int
19 vips_subsample_line_gen( VipsRegion *or, 
20 	void *seq, void *a, void *b, gboolean *stop )
21 {
22 	VipsRegion *ir = (VipsRegion *) seq;
23 	VipsSubsample *subsample = (VipsSubsample *) b;
24 	VipsImage *in = (VipsImage *) a;
25 	VipsRect *r = &amp;or-&gt;valid;
26 	int le = r-&gt;left;
27 	int ri = VIPS_RECT_RIGHT( r );
28 	int to = r-&gt;top;
29 	int bo = VIPS_RECT_BOTTOM( r );
30 	int ps = VIPS_IMAGE_SIZEOF_PEL( in );
31 	int owidth = VIPS_MAX_WIDTH / subsample-&gt;xfac;
32 	VipsRect s;
33 	int x, y;
34 	int z, k;
35 	for( y = to; y &lt; bo; y++ ) {
36 		VipsPel *q = VIPS_REGION_ADDR( or, le, y );
37 		VipsPel *p;
38 		for( x = le; x &lt; ri; x += owidth ) {
39 			int ow = VIPS_MIN( owidth, ri - x );
40 			int iw = ow * subsample-&gt;xfac - (subsample-&gt;xfac - 1);
41 			s.left = x * subsample-&gt;xfac;
42 			s.top = y * subsample-&gt;yfac;
43 			s.width = iw;
44 			s.height = 1;
45 			if( vips_region_prepare( ir, &amp;s ) )
46 				return( -1 );
47 			p = VIPS_REGION_ADDR( ir, s.left, s.top );
48 			for( z = 0; z &lt; ow; z++ ) {
49 				for( k = 0; k &lt; ps; k++ )
50 					q[k] = p[k];
51 				q += ps;
52 				p += ps * subsample-&gt;xfac;
53 			}
54 		}
55 	}
56 	return( 0 );
57 }
58 static int
59 vips_subsample_point_gen( VipsRegion *or, 
60 	void *seq, void *a, void *b, gboolean *stop )
61 {
62 	VipsRegion *ir = (VipsRegion *) seq;
63 	VipsSubsample *subsample = (VipsSubsample *) b;
64 	VipsImage *in = (VipsImage *) a;
65 	VipsRect *r = &amp;or-&gt;valid;
66 	int le = r-&gt;left;
67 	int ri = VIPS_RECT_RIGHT( r );
68 	int to = r-&gt;top;
69 	int bo = VIPS_RECT_BOTTOM(r);
70 	int ps = VIPS_IMAGE_SIZEOF_PEL( in );
71 	VipsRect s;
72 	int x, y;
73 	int k;
74 	for( y = to; y &lt; bo; y++ ) {
75 		VipsPel *q = VIPS_REGION_ADDR( or, le, y );
76 		VipsPel *p;
77 		for( x = le; x &lt; ri; x++ ) {
78 			s.left = x * subsample-&gt;xfac;
79 			s.top = y * subsample-&gt;yfac;
80 			s.width = 1;
81 			s.height = 1;
82 			if( vips_region_prepare( ir, &amp;s ) )
83 				return( -1 );
84 			p = VIPS_REGION_ADDR( ir, s.left, s.top );
85 			for( k = 0; k &lt; ps; k++ )
86 				q[k] = p[k];
87 			q += ps;
88 		}
89 	}
90 	return( 0 );
91 }
92 static int
93 vips_subsample_build( VipsObject *object )
94 {
95 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
96 	VipsConversion *conversion = VIPS_CONVERSION( object );
97 	VipsSubsample *subsample = (VipsSubsample *) object;
98 	VipsGenerateFn subsample_fn;
99 	if( VIPS_OBJECT_CLASS( vips_subsample_parent_class )-&gt;build( object ) )
100 		return( -1 );
101 	g_assert( subsample-&gt;xfac &gt; 0 ); 
102 	g_assert( subsample-&gt;yfac &gt; 0 ); 
103 	if( subsample-&gt;xfac == 1 &amp;&amp; 
104 		subsample-&gt;yfac == 1 ) 
105 		return( vips_image_write( subsample-&gt;in, conversion-&gt;out ) );
106 	if( vips_image_pio_input( subsample-&gt;in ) || 
107 		vips_check_coding_known( class-&gt;nickname, subsample-&gt;in ) )  
108 		return( -1 );
109 	if( vips_image_pipelinev( conversion-&gt;out, 
110 		VIPS_DEMAND_STYLE_THINSTRIP, subsample-&gt;in, NULL ) )
111 		return( -1 );
112 	conversion-&gt;out-&gt;Xsize = subsample-&gt;in-&gt;Xsize / subsample-&gt;xfac;
113 	conversion-&gt;out-&gt;Ysize = subsample-&gt;in-&gt;Ysize / subsample-&gt;yfac;
114 	conversion-&gt;out-&gt;Xres = subsample-&gt;in-&gt;Xres / subsample-&gt;xfac;
115 	conversion-&gt;out-&gt;Yres = subsample-&gt;in-&gt;Yres / subsample-&gt;yfac;
116 	if( conversion-&gt;out-&gt;Xsize &lt;= 0 || 
117 		conversion-&gt;out-&gt;Ysize &lt;= 0 ) {
118 		vips_error( class-&gt;nickname, 
119 			"%s", _( "image has shrunk to nothing" ) );
120 		return( -1 );
121 	}
122 	if( subsample-&gt;point ||
123 		subsample-&gt;xfac &gt; 10 ) 
124 		subsample_fn = vips_subsample_point_gen;
125 <a name="0"></a>	else 
126 		subsample_fn = vips_subsample_line_gen;
127 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if( vips_image_generate( conversion-&gt;out, 
128 		vips_start_one, subsample_fn, vips_stop_one,
129 		subsample-&gt;in, subsample ) )
130 		return( -1 );
131 	return( 0 );
132 }
133 static void
134 vips_subsample_class_init( VipsSubsampleClass *class )
135 {
136 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
137 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
138 	gobject_class-&gt;set_property = vips_object_set_property;</b></font>
139 	gobject_class-&gt;get_property = vips_object_get_property;
140 	vobject_class-&gt;nickname = "subsample";
141 	vobject_class-&gt;description = _( "subsample an image" );
142 	vobject_class-&gt;build = vips_subsample_build;
143 	VIPS_ARG_IMAGE( class, "input", 1, 
144 		_( "Input" ), 
145 		_( "Input image" ),
146 		VIPS_ARGUMENT_REQUIRED_INPUT,
147 		G_STRUCT_OFFSET( VipsSubsample, in ) );
148 	VIPS_ARG_INT( class, "xfac", 3, 
149 		_( "Xfac" ), 
150 		_( "Horizontal subsample factor" ),
151 		VIPS_ARGUMENT_REQUIRED_INPUT,
152 		G_STRUCT_OFFSET( VipsSubsample, xfac ),
153 		1, VIPS_MAX_COORD, 1 );
154 	VIPS_ARG_INT( class, "yfac", 4, 
155 		_( "Yfac" ), 
156 		_( "Vertical subsample factor" ),
157 		VIPS_ARGUMENT_REQUIRED_INPUT,
158 		G_STRUCT_OFFSET( VipsSubsample, yfac ),
159 		1, VIPS_MAX_COORD, 1 );
160 	VIPS_ARG_BOOL( class, "point", 5, 
161 		_( "Point" ), 
162 		_( "Point sample" ),
163 		VIPS_ARGUMENT_OPTIONAL_INPUT,
164 		G_STRUCT_OFFSET( VipsSubsample, point ),
165 		FALSE );
166 }
167 static void
168 vips_subsample_init( VipsSubsample *subsample )
169 {
170 }
171 int
172 vips_subsample( VipsImage *in, VipsImage **out, int xfac, int yfac, ... )
173 {
174 	va_list ap;
175 	int result;
176 	va_start( ap, yfac );
177 	result = vips_call_split( "subsample", ap, in, out, xfac, yfac );
178 	va_end( ap );
179 	return( result );
180 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>thumbnail.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;math.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/internal.h&gt;
9 #define VIPS_TYPE_THUMBNAIL (vips_thumbnail_get_type())
10 #define VIPS_THUMBNAIL( obj ) \
11 	(G_TYPE_CHECK_INSTANCE_CAST( (obj), VIPS_TYPE_THUMBNAIL, VipsThumbnail ))
12 #define VIPS_THUMBNAIL_CLASS( klass ) \
13 	(G_TYPE_CHECK_CLASS_CAST( (klass), \
14 		VIPS_TYPE_THUMBNAIL, VipsThumbnailClass))
15 #define VIPS_IS_THUMBNAIL( obj ) \
16 	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_THUMBNAIL ))
17 #define VIPS_IS_THUMBNAIL_CLASS( klass ) \
18 	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_THUMBNAIL ))
19 #define VIPS_THUMBNAIL_GET_CLASS( obj ) \
20 	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
21 		VIPS_TYPE_THUMBNAIL, VipsThumbnailClass ))
22 #define MAX_LEVELS (256)
23 typedef struct _VipsThumbnail {
24 	VipsOperation parent_instance;
25 	VipsImage *out;
26 	int width;
27 	int height;
28 	VipsSize size;
29 	gboolean auto_rotate;
30 	gboolean no_rotate;
31 	VipsInteresting crop;
32 	gboolean linear;
33 	char *export_profile;
34 	char *import_profile;
35 	VipsIntent intent;
36 	const char *loader;			int input_width;
37 	int input_height;
38 	int page_height;
39 	int orientation; 			gboolean swap; 				int n_pages;				int n_loaded_pages;			int n_subifds;			
40 	int level_count;
41 	int level_width[MAX_LEVELS];
42 	int level_height[MAX_LEVELS];
43 	int heif_thumbnail_width;
44 	int heif_thumbnail_height;
45 	gboolean subifd_pyramid;
46 	gboolean page_pyramid;
47 } VipsThumbnail;
48 typedef struct _VipsThumbnailClass {
49 	VipsOperationClass parent_class;
50 	int (*get_info)( VipsThumbnail *thumbnail );  
51 	VipsImage *(*open)( VipsThumbnail *thumbnail, double factor );
52 } VipsThumbnailClass;
53 G_DEFINE_ABSTRACT_TYPE( VipsThumbnail, vips_thumbnail, VIPS_TYPE_OPERATION );
54 static void
55 vips_thumbnail_dispose( GObject *gobject )
56 {
57 #ifdef DEBUG
58 	printf( "vips_thumbnail_dispose: " );
59 	vips_object_print_name( VIPS_OBJECT( gobject ) );
60 	printf( "\n" );
61 	G_OBJECT_CLASS( vips_thumbnail_parent_class )-&gt;dispose( gobject );
62 }
63 static void
64 vips_thumbnail_finalize( GObject *gobject )
65 {
66 #ifdef DEBUG
67 	printf( "vips_thumbnail_finalize: " );
68 	vips_object_print_name( VIPS_OBJECT( gobject ) );
69 	printf( "\n" );
70 	G_OBJECT_CLASS( vips_thumbnail_parent_class )-&gt;finalize( gobject );
71 }
72 static int
73 get_int( VipsImage *image, const char *field, int default_value )
74 {
75 	const char *str;
76 	if( vips_image_get_typeof( image, field ) &amp;&amp;
77 		!vips_image_get_string( image, field, &amp;str ) ) 
78 		return( atoi( str ) );
79 	return( default_value );
80 }
81 static void
82 vips_thumbnail_read_header( VipsThumbnail *thumbnail, VipsImage *image )
83 {
84 	thumbnail-&gt;input_width = image-&gt;Xsize;
85 	thumbnail-&gt;input_height = image-&gt;Ysize;
86 	thumbnail-&gt;orientation = vips_image_get_orientation( image );
87 	thumbnail-&gt;swap = vips_image_get_orientation_swap( image );
88 	thumbnail-&gt;page_height = vips_image_get_page_height( image );
89 	thumbnail-&gt;n_pages = vips_image_get_n_pages( image );
90 	thumbnail-&gt;n_subifds = vips_image_get_n_subifds( image );
91 	thumbnail-&gt;n_loaded_pages = 
92 		thumbnail-&gt;input_height / thumbnail-&gt;page_height;
93 	if( vips_isprefix( "VipsForeignLoadOpenslide", thumbnail-&gt;loader ) ) {
94 		int level_count;
95 		int level;
96 		level_count = get_int( image, "openslide.level-count", 1 );
97 		level_count = VIPS_CLIP( 1, level_count, MAX_LEVELS );
98 		thumbnail-&gt;level_count = level_count;
99 		for( level = 0; level &lt; level_count; level++ ) {
100 			char name[256];
101 			vips_snprintf( name, 256, 
102 				"openslide.level[%d].width", level );
103 			thumbnail-&gt;level_width[level] =
104 				 get_int( image, name, 0 );
105 			vips_snprintf( name, 256, 
106 				"openslide.level[%d].height", level );
107 			thumbnail-&gt;level_height[level] =
108 				get_int( image, name, 0 );
109 		}
110 	}
111 }
112 static void
113 vips_thumbnail_get_pyramid_page( VipsThumbnail *thumbnail ) 
114 {
115 	VipsThumbnailClass *class = VIPS_THUMBNAIL_GET_CLASS( thumbnail );
116 	int i;
117 #ifdef DEBUG
118 	printf( "vips_thumbnail_get_pyramid_page:\n" );
119 	if( thumbnail-&gt;n_pages &lt; 2 )
120 		return;
121 	for( i = 0; i &lt; thumbnail-&gt;n_pages; i++ ) {
122 		VipsImage *page;
123 		int level_width;
124 		int level_height;
125 		int expected_level_width;
126 		int expected_level_height;
127 		if( !(page = class-&gt;open( thumbnail, i )) )
128 			return;
129 		level_width = page-&gt;Xsize;
130 		level_height = page-&gt;Ysize;
131 		VIPS_UNREF( page );
132 		expected_level_width = thumbnail-&gt;input_width / (1 &lt;&lt; i);
133 		expected_level_height = thumbnail-&gt;input_height / (1 &lt;&lt; i);
134 		if( abs( level_width - expected_level_width ) &gt; 5 ||
135 			level_width &lt; 2 )
136 			return;
137 		if( abs( level_height - expected_level_height ) &gt; 5 ||
138 			level_height &lt; 2 )
139 			return;
140 		thumbnail-&gt;level_width[i] = level_width;
141 		thumbnail-&gt;level_height[i] = level_height;
142 	}
143 #ifdef DEBUG
144 	printf( "vips_thumbnail_get_pyramid_page: "
145 		"%d layer pyramid detected\n",
146 		thumbnail-&gt;n_pages );
147 	thumbnail-&gt;level_count = thumbnail-&gt;n_pages;
148 }
149 static void
150 vips_thumbnail_get_tiff_pyramid_subifd( VipsThumbnail *thumbnail ) 
151 {
152 	VipsThumbnailClass *class = VIPS_THUMBNAIL_GET_CLASS( thumbnail );
153 	int i;
154 #ifdef DEBUG
155 	printf( "vips_thumbnail_get_tiff_pyramid_subifd:\n" );
156 	for( i = 0; i &lt; thumbnail-&gt;n_subifds; i++ ) {
157 		VipsImage *page;
158 		int level_width;
159 		int level_height;
160 		int expected_level_width;
161 		int expected_level_height;
162 		if( !(page = class-&gt;open( thumbnail, i )) )
163 			return;
164 		level_width = page-&gt;Xsize;
165 		level_height = page-&gt;Ysize;
166 		VIPS_UNREF( page );
167 		expected_level_width = thumbnail-&gt;input_width / (2 &lt;&lt; i);
168 		expected_level_height = thumbnail-&gt;input_height / (2 &lt;&lt; i);
169 		if( abs( level_width - expected_level_width ) &gt; 5 ||
170 			level_width &lt; 2 )
171 			return;
172 		if( abs( level_height - expected_level_height ) &gt; 5 ||
173 			level_height &lt; 2 )
174 			return;
175 		thumbnail-&gt;level_width[i] = level_width;
176 		thumbnail-&gt;level_height[i] = level_height;
177 	}
178 #ifdef DEBUG
179 	printf( "vips_thumbnail_get_tiff_pyramid_subifd: "
180 		"%d layer pyramid detected\n",
181 		thumbnail-&gt;n_subifds );
182 	thumbnail-&gt;level_count = thumbnail-&gt;n_subifds;
183 }
184 static int
185 vips_thumbnail_get_heif_thumb_info( VipsThumbnail *thumbnail ) 
186 {
187 	VipsThumbnailClass *class = VIPS_THUMBNAIL_GET_CLASS( thumbnail );
188 	VipsImage *thumb;
189 	if( !(thumb = class-&gt;open( thumbnail, 1 )) )
190 		return( -1 );
191 	if( thumb-&gt;Xsize &lt; thumbnail-&gt;input_width ) {
192 		thumbnail-&gt;heif_thumbnail_width = thumb-&gt;Xsize;
193 		thumbnail-&gt;heif_thumbnail_height = thumb-&gt;Ysize;
194 	}
195 	VIPS_UNREF( thumb );
196 	return( 0 );
197 }
198 static void
199 vips_thumbnail_calculate_shrink( VipsThumbnail *thumbnail, 
200 	int input_width, int input_height, double *hshrink, double *vshrink )
201 {
202 	gboolean rotate = 
203 		thumbnail-&gt;swap &amp;&amp;
204 		thumbnail-&gt;auto_rotate;
205 	int target_width = rotate ? 
206 		thumbnail-&gt;height : thumbnail-&gt;width;
207 	int target_height = rotate ? 
208 		thumbnail-&gt;width : thumbnail-&gt;height;
209 	VipsDirection direction;
210 	*hshrink = (double) input_width / target_width;
211 	*vshrink = (double) input_height / target_height;
212 	if( thumbnail-&gt;crop != VIPS_INTERESTING_NONE ) {
213 		if( *hshrink &lt; *vshrink )
214 			direction = VIPS_DIRECTION_HORIZONTAL;
215 		else
216 			direction = VIPS_DIRECTION_VERTICAL;
217 	}
218 	else {
219 		if( *hshrink &lt; *vshrink )
220 			direction = VIPS_DIRECTION_VERTICAL;
221 		else
222 			direction = VIPS_DIRECTION_HORIZONTAL;
223 	}
224 	if( thumbnail-&gt;size != VIPS_SIZE_FORCE ) {
225 		if( direction == VIPS_DIRECTION_HORIZONTAL )
226 			*vshrink = *hshrink;
227 		else
228 			*hshrink = *vshrink;
229 	}
230 	if( thumbnail-&gt;size == VIPS_SIZE_UP ) {
231 		*hshrink = VIPS_MIN( 1, *hshrink );
232 		*vshrink = VIPS_MIN( 1, *vshrink );
233 	}
234 	else if( thumbnail-&gt;size == VIPS_SIZE_DOWN ) {
235 		*hshrink = VIPS_MAX( 1, *hshrink );
236 		*vshrink = VIPS_MAX( 1, *vshrink );
237 	}
238 	*hshrink = VIPS_MIN( *hshrink, input_width );
239 	*vshrink = VIPS_MIN( *vshrink, input_height );
240 }
241 static double
242 vips_thumbnail_calculate_common_shrink( VipsThumbnail *thumbnail, 
243 	int width, int height )
244 {
245 	double hshrink;
246 	double vshrink;
247 	double shrink;
248 	vips_thumbnail_calculate_shrink( thumbnail, width, height, 
249 		&amp;hshrink, &amp;vshrink ); 
250 	shrink = VIPS_MIN( hshrink, vshrink );
251 	return( shrink ); 
252 }
253 static int
254 vips_thumbnail_find_jpegshrink( VipsThumbnail *thumbnail, 
255 	int width, int height )
256 {
257 	double shrink = vips_thumbnail_calculate_common_shrink( thumbnail, 
258 		width, height ); 
259 	if( thumbnail-&gt;linear )
260 		return( 1 ); 
261 	if( shrink &gt;= 16 )
262 		return( 8 );
263 	else if( shrink &gt;= 8 )
264 		return( 4 );
265 	else if( shrink &gt;= 4 )
266 		return( 2 );
267 	else 
268 		return( 1 );
269 }
270 static int
271 vips_thumbnail_find_pyrlevel( VipsThumbnail *thumbnail, 
272 	int width, int height )
273 {
274 	int level;
275 	g_assert( thumbnail-&gt;level_count &gt; 0 );
276 	g_assert( thumbnail-&gt;level_count &lt;= MAX_LEVELS );
277 	for( level = thumbnail-&gt;level_count - 1; level &gt;= 0; level-- ) 
278 		if( vips_thumbnail_calculate_common_shrink( thumbnail, 
279 			thumbnail-&gt;level_width[level], 
280 			thumbnail-&gt;level_height[level] ) &gt;= 1.0 ) 
281 			return( level );
282 	return( 0 );
283 }
284 static VipsImage *
285 vips_thumbnail_open( VipsThumbnail *thumbnail )
286 {
287 	VipsThumbnailClass *class = VIPS_THUMBNAIL_GET_CLASS( thumbnail );
288 	VipsImage *im;
289 	double factor;
290 	if( class-&gt;get_info( thumbnail ) )
291 		return( NULL );
292 	g_info( "selected loader is %s", thumbnail-&gt;loader ); 
293 	g_info( "input size is %d x %d", 
294 		thumbnail-&gt;input_width, thumbnail-&gt;input_height ); 
295 	if( vips_isprefix( "VipsForeignLoadTiff", thumbnail-&gt;loader ) ) {
296 		thumbnail-&gt;subifd_pyramid = TRUE;
297 		vips_thumbnail_get_tiff_pyramid_subifd( thumbnail );
298 		if( thumbnail-&gt;level_count == 0 ) {
299 			thumbnail-&gt;subifd_pyramid = FALSE;
300 			thumbnail-&gt;page_pyramid = TRUE;
301 			vips_thumbnail_get_pyramid_page( thumbnail );
302 			if( thumbnail-&gt;level_count == 0 ) 
303 				thumbnail-&gt;page_pyramid = FALSE;
304 		}
305 	}
306 	if( vips_isprefix( "VipsForeignLoadJp2k", thumbnail-&gt;loader ) ) {
307 		if( thumbnail-&gt;level_count == 0 ) {
308 			thumbnail-&gt;subifd_pyramid = FALSE;
309 			thumbnail-&gt;page_pyramid = TRUE;
310 			vips_thumbnail_get_pyramid_page( thumbnail );
311 			if( thumbnail-&gt;level_count == 0 ) 
312 				thumbnail-&gt;page_pyramid = FALSE;
313 		}
314 	}
315 	if( vips_isprefix( "VipsForeignLoadHeif", thumbnail-&gt;loader ) ) 
316 		vips_thumbnail_get_heif_thumb_info( thumbnail );
317 	factor = 1.0;
318 	if( vips_isprefix( "VipsForeignLoadJpeg", thumbnail-&gt;loader ) ) 
319 		factor = vips_thumbnail_find_jpegshrink( thumbnail, 
320 			thumbnail-&gt;input_width, thumbnail-&gt;input_height );
321 	else if( vips_isprefix( "VipsForeignLoadTiff", thumbnail-&gt;loader ) ||
322 		vips_isprefix( "VipsForeignLoadJp2k", thumbnail-&gt;loader ) ||
323 		vips_isprefix( "VipsForeignLoadOpenslide", 
324 			thumbnail-&gt;loader ) ) {
325 		if( thumbnail-&gt;level_count &gt; 0 )
326 			factor = vips_thumbnail_find_pyrlevel( thumbnail, 
327 				thumbnail-&gt;input_width, 
328 				thumbnail-&gt;input_height );
329 	}
330 	else if( vips_isprefix( "VipsForeignLoadPdf", thumbnail-&gt;loader ) ||
331 		vips_isprefix( "VipsForeignLoadWebp", thumbnail-&gt;loader ) ||
332 		vips_isprefix( "VipsForeignLoadSvg", thumbnail-&gt;loader ) ) 
333 		factor = vips_thumbnail_calculate_common_shrink( thumbnail, 
334 			thumbnail-&gt;input_width, 
335 			thumbnail-&gt;page_height );
336 	else if( vips_isprefix( "VipsForeignLoadHeif", thumbnail-&gt;loader ) ) {
337 		double shrink_factor = vips_thumbnail_calculate_common_shrink( 
338 			thumbnail, 
339 			thumbnail-&gt;heif_thumbnail_width, 
340 			thumbnail-&gt;heif_thumbnail_height );
341 		factor = shrink_factor &gt; 1.0 ? 1 : 0;
342 	}
343 	g_info( "loading with factor %g pre-shrink", factor ); 
344 	if( !(im = class-&gt;open( thumbnail, factor )) )
345 		return( NULL );
346 	g_info( "pre-shrunk size is %d x %d", im-&gt;Xsize, im-&gt;Ysize ); 
347 	return( im ); 
348 }
349 static int
350 vips_thumbnail_build( VipsObject *object )
351 {
352 	VipsThumbnail *thumbnail = VIPS_THUMBNAIL( object );
353 	VipsImage **t = (VipsImage **) vips_object_local_array( object, 15 );
354 	VipsImage *in;
355 	int preshrunk_page_height;
356 	double hshrink;
357 	double vshrink;
358 	gboolean have_imported;
359 	VipsInterpretation input_interpretation;
360 	VipsBandFormat unpremultiplied_format;
361 #ifdef DEBUG
362 	printf( "vips_thumbnail_build: " );
363 	vips_object_print_name( object );
364 	printf( "\n" );
365 	if( VIPS_OBJECT_CLASS( vips_thumbnail_parent_class )-&gt;build( object ) )
366 		return( -1 );
367 	if( vips_object_argument_isset( object, "no_rotate" ) ) 
368 		thumbnail-&gt;auto_rotate = !thumbnail-&gt;no_rotate;
369 	if( !vips_object_argument_isset( object, "height" ) )
370 		thumbnail-&gt;height = thumbnail-&gt;width;
371 	if( !(t[0] = vips_thumbnail_open( thumbnail )) )
372 		return( -1 );
373 	in = t[0];
374 	preshrunk_page_height = vips_image_get_page_height( in );
375 	if( in-&gt;Coding == VIPS_CODING_RAD ) {
376 		g_info( "unpacking Rad to float" );
377 		if( vips_rad2float( in, &amp;t[12], NULL ) )
378 			return( -1 );
379 		in = t[12];
380 	}
381 	input_interpretation = in-&gt;Type;
382 	have_imported = FALSE;
383 	if( thumbnail-&gt;linear ) {
384 		if( in-&gt;Coding == VIPS_CODING_NONE &amp;&amp;
385 			(in-&gt;BandFmt == VIPS_FORMAT_UCHAR ||
386 			 in-&gt;BandFmt == VIPS_FORMAT_USHORT) &amp;&amp;
387 			(vips_image_get_typeof( in, VIPS_META_ICC_NAME ) || 
388 			 thumbnail-&gt;import_profile) ) {
389 			g_info( "importing to XYZ PCS" );
390 			if( thumbnail-&gt;import_profile ) 
391 				g_info( "fallback input profile %s", 
392 					thumbnail-&gt;import_profile );
393 			if( vips_icc_import( in, &amp;t[1], 
394 				"input_profile", thumbnail-&gt;import_profile,
395 				"embedded", TRUE,
396 				"intent", thumbnail-&gt;intent,
397 				"pcs", VIPS_PCS_XYZ,
398 				NULL ) )  
399 				return( -1 );
400 			in = t[1];
401 			have_imported = TRUE;
402 		}
403 		else {
404 			VipsInterpretation interpretation;
405 			if( in-&gt;Bands &lt; 3 )
406 				interpretation = VIPS_INTERPRETATION_GREY16; 
407 			else 
408 				interpretation = VIPS_INTERPRETATION_scRGB; 
409 			g_info( "converting to processing space %s",
410 				vips_enum_nick( VIPS_TYPE_INTERPRETATION, 
411 					interpretation ) ); 
412 			if( vips_colourspace( in, &amp;t[2], interpretation, 
413 				NULL ) ) 
414 				return( -1 ); 
415 			in = t[2];
416 		}
417 	}
418 	else {
419 		VipsInterpretation interpretation;
420 		if( in-&gt;Bands &lt; 3 )
421 			interpretation = VIPS_INTERPRETATION_B_W; 
422 		else 
423 			interpretation = VIPS_INTERPRETATION_sRGB; 
424 		g_info( "converting to processing space %s",
425 			vips_enum_nick( VIPS_TYPE_INTERPRETATION, 
426 				interpretation ) ); 
427 		if( vips_colourspace( in, &amp;t[2], interpretation, 
428 			NULL ) ) 
429 			return( -1 ); 
430 		in = t[2];
431 	}
432 	vips_thumbnail_calculate_shrink( thumbnail, 
433 		in-&gt;Xsize, preshrunk_page_height, &amp;hshrink, &amp;vshrink );
434 	if( in-&gt;Ysize &gt; preshrunk_page_height ) {
435 		int target_page_height = VIPS_RINT( 
436 			preshrunk_page_height / vshrink );
437 		int target_image_height = target_page_height * 
438 			thumbnail-&gt;n_loaded_pages;
439 		vshrink = (double) in-&gt;Ysize / target_image_height;
440 	}
441 	unpremultiplied_format = VIPS_FORMAT_NOTSET;
442 	if( vips_image_hasalpha( in ) &amp;&amp; 
443 	 	hshrink != 1.0 &amp;&amp;
444 		vshrink != 1.0  ) { 
445 		g_info( "premultiplying alpha" ); 
446 		unpremultiplied_format = in-&gt;BandFmt;
447 		if( vips_premultiply( in, &amp;t[3], NULL ) ) 
448 			return( -1 );
449 		in = t[3];
450 	}
451 	if( vips_resize( in, &amp;t[4], 1.0 / hshrink, 
452 		"vscale", 1.0 / vshrink, 
453 		NULL ) ) 
454 		return( -1 );
455 	in = t[4];
456 	if( unpremultiplied_format != VIPS_FORMAT_NOTSET ) {
457 		g_info( "unpremultiplying alpha" ); 
458 		if( vips_unpremultiply( in, &amp;t[5], NULL ) || 
459 			vips_cast( t[5], &amp;t[6], unpremultiplied_format, NULL ) )
460 			return( -1 );
461 		in = t[6];
462 	}
463 	if( thumbnail-&gt;n_loaded_pages &gt; 1 ) {
464 		int output_page_height = 
465 			VIPS_RINT( preshrunk_page_height / vshrink );
466 		if( vips_copy( in, &amp;t[13], NULL ) )
467 			return( -1 );
468 		in = t[13];
469 		vips_image_set_int( in, 
470 			VIPS_META_PAGE_HEIGHT, output_page_height );
471 	}
472 	if( have_imported ) { 
473 		if( thumbnail-&gt;export_profile ||
474 			vips_image_get_typeof( in, VIPS_META_ICC_NAME ) ) {
475 			g_info( "exporting to device space with a profile" );
476 			if( vips_icc_export( in, &amp;t[7], 
477 				"output_profile", thumbnail-&gt;export_profile,
478 				"intent", thumbnail-&gt;intent,
479 				NULL ) )  
480 				return( -1 );
481 			in = t[7];
482 		}
483 		else {
484 			g_info( "converting to sRGB" );
485 			if( vips_colourspace( in, &amp;t[7], 
486 				VIPS_INTERPRETATION_sRGB, NULL ) ) 
487 				return( -1 ); 
488 			in = t[7];
489 		}
490 	}
491 	else if( thumbnail-&gt;export_profile ) {
492 		g_info( "transforming to %s", thumbnail-&gt;export_profile );
493 		if( thumbnail-&gt;import_profile ||
494 			(vips_image_get_typeof( in, VIPS_META_ICC_NAME ) ||
495 			 thumbnail-&gt;import_profile) ) {
496 			g_info( "transforming with supplied profiles" ); 
497 			if( vips_icc_transform( in, &amp;t[7], 
498 				thumbnail-&gt;export_profile,
499 				"input_profile", thumbnail-&gt;import_profile,
500 				"intent", thumbnail-&gt;intent,
501 				"embedded", TRUE,
502 				NULL ) ) 
503 				return( -1 );
504 			in = t[7];
505 		}
506 		else {
507 			g_info( "exporting with %s", 
508 				thumbnail-&gt;export_profile ); 
509 			if( vips_colourspace( in, &amp;t[7], 
510 				VIPS_INTERPRETATION_XYZ, NULL ) || 
511 				vips_icc_export( t[7], &amp;t[10], 
512 					"output_profile", 
513 						thumbnail-&gt;export_profile,
514 					"intent", thumbnail-&gt;intent,
515 					NULL ) )  
516 				return( -1 ); 
517 			in = t[10];
518 		}
519 	}
520 	else if( thumbnail-&gt;linear ) {
521 		g_info( "reverting to input space %s",
522 			vips_enum_nick( VIPS_TYPE_INTERPRETATION, 
523 				input_interpretation ) ); 
524 		if( vips_colourspace( in, &amp;t[7], 
525 			input_interpretation, NULL ) ) 
526 			return( -1 ); 
527 		in = t[7];
528 	}
529 	if( thumbnail-&gt;auto_rotate &amp;&amp;
530 		thumbnail-&gt;orientation != 1 ) {
531 		g_info( "rotating by EXIF orientation %d", 
532 			thumbnail-&gt;orientation ); 
533 		if( !(t[9] = vips_image_copy_memory( in )) ||
534 			vips_autorot( t[9], &amp;t[14], NULL ) )
535 			return( -1 );
536 		in = t[14];
537 	}
538 	if( thumbnail-&gt;crop != VIPS_INTERESTING_NONE ) {
539 		int crop_width = VIPS_MIN( thumbnail-&gt;width, in-&gt;Xsize );
540 		int crop_height = VIPS_MIN( thumbnail-&gt;height, in-&gt;Ysize );
541 		g_info( "cropping to %dx%d", crop_width, crop_height ); 
542 		if( !(t[8] = vips_image_copy_memory( in )) ||
543 			vips_smartcrop( t[8], &amp;t[11], 
544 				crop_width, crop_height, 
545 				"interesting", thumbnail-&gt;crop,
546 				NULL ) )
547 			return( -1 ); 
548 		in = t[11];
549 	}
550 <a name="0"></a>
551 	g_object_set( thumbnail, "out", vips_image_new(), NULL ); 
552 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if( vips_image_write( in, thumbnail-&gt;out ) )
553 		return( -1 );
554 	return( 0 );
555 }
556 static void
557 vips_thumbnail_class_init( VipsThumbnailClass *class )
558 {
559 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
560 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
561 	VipsOperationClass *operation_class = VIPS_OPERATION_CLASS( class );</b></font>
562 	gobject_class-&gt;dispose = vips_thumbnail_dispose;
563 	gobject_class-&gt;finalize = vips_thumbnail_finalize;
564 	gobject_class-&gt;set_property = vips_object_set_property;
565 	gobject_class-&gt;get_property = vips_object_get_property;
566 	vobject_class-&gt;nickname = "thumbnail_base";
567 	vobject_class-&gt;description = _( "thumbnail generation" );
568 	vobject_class-&gt;build = vips_thumbnail_build;
569 	operation_class-&gt;flags = VIPS_OPERATION_NOCACHE;
570 	VIPS_ARG_IMAGE( class, "out", 2, 
571 		_( "Output" ), 
572 		_( "Output image" ),
573 		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
574 		G_STRUCT_OFFSET( VipsThumbnail, out ) );
575 	VIPS_ARG_INT( class, "width", 3, 
576 		_( "Target width" ), 
577 		_( "Size to this width" ),
578 		VIPS_ARGUMENT_REQUIRED_INPUT,
579 		G_STRUCT_OFFSET( VipsThumbnail, width ),
580 		1, VIPS_MAX_COORD, 1 );
581 	VIPS_ARG_INT( class, "height", 113, 
582 		_( "Target height" ), 
583 		_( "Size to this height" ),
584 		VIPS_ARGUMENT_OPTIONAL_INPUT,
585 		G_STRUCT_OFFSET( VipsThumbnail, height ),
586 		1, VIPS_MAX_COORD, 1 );
587 	VIPS_ARG_ENUM( class, "size", 114, 
588 		_( "size" ), 
589 		_( "Only upsize, only downsize, or both" ),
590 		VIPS_ARGUMENT_OPTIONAL_INPUT,
591 		G_STRUCT_OFFSET( VipsThumbnail, size ),
592 		VIPS_TYPE_SIZE, VIPS_SIZE_BOTH ); 
593 	VIPS_ARG_BOOL( class, "no_rotate", 115, 
594 		_( "No rotate" ), 
595 		_( "Don't use orientation tags to rotate image upright" ),
596 		VIPS_ARGUMENT_OPTIONAL_INPUT,
597 		G_STRUCT_OFFSET( VipsThumbnail, no_rotate ),
598 		FALSE ); 
599 	VIPS_ARG_ENUM( class, "crop", 116, 
600 		_( "Crop" ), 
601 		_( "Reduce to fill target rectangle, then crop" ),
602 		VIPS_ARGUMENT_OPTIONAL_INPUT,
603 		G_STRUCT_OFFSET( VipsThumbnail, crop ),
604 		VIPS_TYPE_INTERESTING, VIPS_INTERESTING_NONE ); 
605 	VIPS_ARG_BOOL( class, "linear", 117, 
606 		_( "Linear" ), 
607 		_( "Reduce in linear light" ),
608 		VIPS_ARGUMENT_OPTIONAL_INPUT,
609 		G_STRUCT_OFFSET( VipsThumbnail, linear ),
610 		FALSE ); 
611 	VIPS_ARG_STRING( class, "import_profile", 118, 
612 		_( "Import profile" ), 
613 		_( "Fallback import profile" ),
614 		VIPS_ARGUMENT_OPTIONAL_INPUT,
615 		G_STRUCT_OFFSET( VipsThumbnail, import_profile ),
616 		NULL ); 
617 	VIPS_ARG_STRING( class, "export_profile", 119, 
618 		_( "Export profile" ), 
619 		_( "Fallback export profile" ),
620 		VIPS_ARGUMENT_OPTIONAL_INPUT,
621 		G_STRUCT_OFFSET( VipsThumbnail, export_profile ),
622 		NULL ); 
623 	VIPS_ARG_ENUM( class, "intent", 120, 
624 		_( "Intent" ), 
625 		_( "Rendering intent" ),
626 		VIPS_ARGUMENT_OPTIONAL_INPUT,
627 		G_STRUCT_OFFSET( VipsThumbnail, intent ),
628 		VIPS_TYPE_INTENT, VIPS_INTENT_RELATIVE );
629 	VIPS_ARG_BOOL( class, "auto_rotate", 121, 
630 		_( "Auto rotate" ), 
631 		_( "Use orientation tags to rotate image upright" ),
632 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
633 		G_STRUCT_OFFSET( VipsThumbnail, auto_rotate ),
634 		TRUE ); 
635 }
636 static void
637 vips_thumbnail_init( VipsThumbnail *thumbnail )
638 {
639 	thumbnail-&gt;width = 1;
640 	thumbnail-&gt;height = 1;
641 	thumbnail-&gt;auto_rotate = TRUE;
642 	thumbnail-&gt;intent = VIPS_INTENT_RELATIVE;
643 }
644 typedef struct _VipsThumbnailFile {
645 	VipsThumbnail parent_object;
646 	char *filename; 
647 } VipsThumbnailFile;
648 typedef VipsThumbnailClass VipsThumbnailFileClass;
649 G_DEFINE_TYPE( VipsThumbnailFile, vips_thumbnail_file, 
650 	vips_thumbnail_get_type() );
651 static int
652 vips_thumbnail_file_get_info( VipsThumbnail *thumbnail )
653 {
654 	VipsThumbnailFile *file = (VipsThumbnailFile *) thumbnail;
655 	VipsImage *image;
656 	g_info( "thumbnailing %s", file-&gt;filename ); 
657 	if( !(thumbnail-&gt;loader = vips_foreign_find_load( file-&gt;filename )) ||
658 		!(image = vips_image_new_from_file( file-&gt;filename, NULL )) )
659 		return( -1 );
660 	vips_thumbnail_read_header( thumbnail, image );
661 	g_object_unref( image );
662 	return( 0 );
663 }
664 static VipsImage *
665 vips_thumbnail_file_open( VipsThumbnail *thumbnail, double factor )
666 {
667 	VipsThumbnailFile *file = (VipsThumbnailFile *) thumbnail;
668 	if( vips_isprefix( "VipsForeignLoadJpeg", thumbnail-&gt;loader ) ) {
669 		return( vips_image_new_from_file( file-&gt;filename, 
670 			"access", VIPS_ACCESS_SEQUENTIAL,
671 			"shrink", (int) factor,
672 			NULL ) );
673 	}
674 	else if( vips_isprefix( "VipsForeignLoadOpenslide", 
675 		thumbnail-&gt;loader ) ) {
676 		return( vips_image_new_from_file( file-&gt;filename, 
677 			"access", VIPS_ACCESS_SEQUENTIAL,
678 			"level", (int) factor,
679 			NULL ) );
680 	}
681 	else if( vips_isprefix( "VipsForeignLoadPdf", thumbnail-&gt;loader ) ||
682 		vips_isprefix( "VipsForeignLoadSvg", thumbnail-&gt;loader ) ||
683 		vips_isprefix( "VipsForeignLoadWebp", thumbnail-&gt;loader ) ) {
684 		return( vips_image_new_from_file( file-&gt;filename, 
685 			"access", VIPS_ACCESS_SEQUENTIAL,
686 			"scale", 1.0 / factor,
687 			NULL ) );
688 	}
689 	else if( vips_isprefix( "VipsForeignLoadJp2k", thumbnail-&gt;loader ) ) {
690 		if( thumbnail-&gt;page_pyramid )
691 			return( vips_image_new_from_file( file-&gt;filename, 
692 				"access", VIPS_ACCESS_SEQUENTIAL,
693 				"page", (int) factor,
694 				NULL ) );
695 		else
696 			return( vips_image_new_from_file( file-&gt;filename, 
697 				"access", VIPS_ACCESS_SEQUENTIAL,
698 				NULL ) );
699 	}
700 	else if( vips_isprefix( "VipsForeignLoadTiff", thumbnail-&gt;loader ) ) {
701 		if( thumbnail-&gt;subifd_pyramid )
702 			return( vips_image_new_from_file( file-&gt;filename, 
703 				"access", VIPS_ACCESS_SEQUENTIAL,
704 				"subifd", (int) factor,
705 				NULL ) );
706 		else if( thumbnail-&gt;page_pyramid )
707 			return( vips_image_new_from_file( file-&gt;filename, 
708 				"access", VIPS_ACCESS_SEQUENTIAL,
709 				"page", (int) factor,
710 				NULL ) );
711 		else
712 			return( vips_image_new_from_file( file-&gt;filename, 
713 				"access", VIPS_ACCESS_SEQUENTIAL,
714 				NULL ) );
715 	}
716 	else if( vips_isprefix( "VipsForeignLoadHeif", thumbnail-&gt;loader ) ) {
717 		return( vips_image_new_from_file( file-&gt;filename, 
718 			"access", VIPS_ACCESS_SEQUENTIAL,
719 			"thumbnail", (int) factor,
720 			NULL ) );
721 	}
722 	else {
723 		return( vips_image_new_from_file( file-&gt;filename, 
724 			"access", VIPS_ACCESS_SEQUENTIAL,
725 			NULL ) );
726 	}
727 }
728 static void
729 vips_thumbnail_file_class_init( VipsThumbnailClass *class )
730 {
731 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
732 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
733 	VipsThumbnailClass *thumbnail_class = VIPS_THUMBNAIL_CLASS( class );
734 	gobject_class-&gt;set_property = vips_object_set_property;
735 	gobject_class-&gt;get_property = vips_object_get_property;
736 	vobject_class-&gt;nickname = "thumbnail";
737 	vobject_class-&gt;description = _( "generate thumbnail from file" );
738 	thumbnail_class-&gt;get_info = vips_thumbnail_file_get_info;
739 	thumbnail_class-&gt;open = vips_thumbnail_file_open;
740 	VIPS_ARG_STRING( class, "filename", 1, 
741 		_( "Filename" ),
742 		_( "Filename to read from" ),
743 		VIPS_ARGUMENT_REQUIRED_INPUT, 
744 		G_STRUCT_OFFSET( VipsThumbnailFile, filename ),
745 		NULL );
746 }
747 static void
748 vips_thumbnail_file_init( VipsThumbnailFile *file )
749 {
750 }
751 int
752 vips_thumbnail( const char *filename, VipsImage **out, int width, ... )
753 {
754 	va_list ap;
755 	int result;
756 	va_start( ap, width );
757 	result = vips_call_split( "thumbnail", ap, filename, out, width );
758 	va_end( ap );
759 	return( result );
760 }
761 typedef struct _VipsThumbnailBuffer {
762 	VipsThumbnail parent_object;
763 	VipsArea *buf;
764 	char *option_string;
765 } VipsThumbnailBuffer;
766 typedef VipsThumbnailClass VipsThumbnailBufferClass;
767 G_DEFINE_TYPE( VipsThumbnailBuffer, vips_thumbnail_buffer, 
768 	vips_thumbnail_get_type() );
769 static int
770 vips_thumbnail_buffer_get_info( VipsThumbnail *thumbnail )
771 {
772 	VipsThumbnailBuffer *buffer = (VipsThumbnailBuffer *) thumbnail;
773 	VipsImage *image;
774 	g_info( "thumbnailing %zd bytes of data", buffer-&gt;buf-&gt;length ); 
775 	if( !(thumbnail-&gt;loader = vips_foreign_find_load_buffer( 
776 			buffer-&gt;buf-&gt;data, buffer-&gt;buf-&gt;length )) ||
777 		!(image = vips_image_new_from_buffer( 
778 			buffer-&gt;buf-&gt;data, buffer-&gt;buf-&gt;length, 
779 			buffer-&gt;option_string, NULL )) )
780 		return( -1 );
781 	vips_thumbnail_read_header( thumbnail, image );
782 	g_object_unref( image );
783 	return( 0 );
784 }
785 static VipsImage *
786 vips_thumbnail_buffer_open( VipsThumbnail *thumbnail, double factor )
787 {
788 	VipsThumbnailBuffer *buffer = (VipsThumbnailBuffer *) thumbnail;
789 	if( vips_isprefix( "VipsForeignLoadJpeg", thumbnail-&gt;loader ) ) {
790 		return( vips_image_new_from_buffer( 
791 			buffer-&gt;buf-&gt;data, buffer-&gt;buf-&gt;length, 
792 			buffer-&gt;option_string,
793 			"access", VIPS_ACCESS_SEQUENTIAL,
794 			"shrink", (int) factor,
795 			NULL ) );
796 	}
797 	else if( vips_isprefix( "VipsForeignLoadOpenslide", 
798 		thumbnail-&gt;loader ) ) {
799 		return( vips_image_new_from_buffer( 
800 			buffer-&gt;buf-&gt;data, buffer-&gt;buf-&gt;length, 
801 			buffer-&gt;option_string,
802 			"access", VIPS_ACCESS_SEQUENTIAL,
803 			"level", (int) factor,
804 			NULL ) );
805 	}
806 	else if( vips_isprefix( "VipsForeignLoadPdf", thumbnail-&gt;loader ) ||
807 		vips_isprefix( "VipsForeignLoadSvg", thumbnail-&gt;loader ) ||
808 		vips_isprefix( "VipsForeignLoadWebp", thumbnail-&gt;loader ) ) {
809 		return( vips_image_new_from_buffer( 
810 			buffer-&gt;buf-&gt;data, buffer-&gt;buf-&gt;length, 
811 			buffer-&gt;option_string,
812 			"access", VIPS_ACCESS_SEQUENTIAL,
813 			"scale", 1.0 / factor,
814 			NULL ) );
815 	}
816 	else if( vips_isprefix( "VipsForeignLoadJp2k", thumbnail-&gt;loader ) ) {
817 		if( thumbnail-&gt;page_pyramid )
818 			return( vips_image_new_from_buffer( 
819 				buffer-&gt;buf-&gt;data, buffer-&gt;buf-&gt;length, 
820 				buffer-&gt;option_string,
821 				"access", VIPS_ACCESS_SEQUENTIAL,
822 				"page", (int) factor,
823 				NULL ) );
824 		else
825 			return( vips_image_new_from_buffer( 
826 				buffer-&gt;buf-&gt;data, buffer-&gt;buf-&gt;length, 
827 				buffer-&gt;option_string,
828 				"access", VIPS_ACCESS_SEQUENTIAL,
829 				NULL ) );
830 	}
831 	else if( vips_isprefix( "VipsForeignLoadTiff", thumbnail-&gt;loader ) ) {
832 		if( thumbnail-&gt;subifd_pyramid )
833 			return( vips_image_new_from_buffer( 
834 				buffer-&gt;buf-&gt;data, buffer-&gt;buf-&gt;length, 
835 				buffer-&gt;option_string,
836 				"access", VIPS_ACCESS_SEQUENTIAL,
837 				"subifd", (int) factor,
838 				NULL ) );
839 		else if( thumbnail-&gt;page_pyramid )
840 			return( vips_image_new_from_buffer( 
841 				buffer-&gt;buf-&gt;data, buffer-&gt;buf-&gt;length, 
842 				buffer-&gt;option_string,
843 				"access", VIPS_ACCESS_SEQUENTIAL,
844 				"page", (int) factor,
845 				NULL ) );
846 		else
847 			return( vips_image_new_from_buffer( 
848 				buffer-&gt;buf-&gt;data, buffer-&gt;buf-&gt;length, 
849 				buffer-&gt;option_string,
850 				"access", VIPS_ACCESS_SEQUENTIAL,
851 				NULL ) );
852 	}
853 	else if( vips_isprefix( "VipsForeignLoadHeif", thumbnail-&gt;loader ) ) {
854 		return( vips_image_new_from_buffer( 
855 			buffer-&gt;buf-&gt;data, buffer-&gt;buf-&gt;length, 
856 			buffer-&gt;option_string,
857 			"access", VIPS_ACCESS_SEQUENTIAL,
858 			"thumbnail", (int) factor,
859 			NULL ) );
860 	}
861 	else {
862 		return( vips_image_new_from_buffer( 
863 			buffer-&gt;buf-&gt;data, buffer-&gt;buf-&gt;length, 
864 			buffer-&gt;option_string,
865 			"access", VIPS_ACCESS_SEQUENTIAL,
866 			NULL ) );
867 	}
868 }
869 static void
870 vips_thumbnail_buffer_class_init( VipsThumbnailClass *class )
871 {
872 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
873 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
874 	VipsThumbnailClass *thumbnail_class = VIPS_THUMBNAIL_CLASS( class );
875 	gobject_class-&gt;set_property = vips_object_set_property;
876 	gobject_class-&gt;get_property = vips_object_get_property;
877 	vobject_class-&gt;nickname = "thumbnail_buffer";
878 	vobject_class-&gt;description = _( "generate thumbnail from buffer" );
879 	thumbnail_class-&gt;get_info = vips_thumbnail_buffer_get_info;
880 	thumbnail_class-&gt;open = vips_thumbnail_buffer_open;
881 	VIPS_ARG_BOXED( class, "buffer", 1, 
882 		_( "Buffer" ),
883 		_( "Buffer to load from" ),
884 		VIPS_ARGUMENT_REQUIRED_INPUT, 
885 		G_STRUCT_OFFSET( VipsThumbnailBuffer, buf ),
886 		VIPS_TYPE_BLOB );
887 	VIPS_ARG_STRING( class, "option_string", 20,
888 		_( "Extra options" ),
889 		_( "Options that are passed on to the underlying loader" ),
890 		VIPS_ARGUMENT_OPTIONAL_INPUT,
891 		G_STRUCT_OFFSET( VipsThumbnailBuffer, option_string ),
892 		"" );
893 }
894 static void
895 vips_thumbnail_buffer_init( VipsThumbnailBuffer *buffer )
896 {
897 }
898 int
899 vips_thumbnail_buffer( void *buf, size_t len, VipsImage **out, int width, ... )
900 {
901 	va_list ap;
902 	VipsBlob *blob;
903 	int result;
904 	blob = vips_blob_new( NULL, buf, len );
905 	va_start( ap, width );
906 	result = vips_call_split( "thumbnail_buffer", ap, blob, out, width );
907 	va_end( ap );
908 	vips_area_unref( VIPS_AREA( blob ) );
909 	return( result );
910 }
911 typedef struct _VipsThumbnailSource {
912 	VipsThumbnail parent_object;
913 	VipsSource *source;
914 	char *option_string;
915 } VipsThumbnailSource;
916 typedef VipsThumbnailClass VipsThumbnailSourceClass;
917 G_DEFINE_TYPE( VipsThumbnailSource, vips_thumbnail_source, 
918 	vips_thumbnail_get_type() );
919 static int
920 vips_thumbnail_source_get_info( VipsThumbnail *thumbnail )
921 {
922 	VipsThumbnailSource *source = (VipsThumbnailSource *) thumbnail;
923 	VipsImage *image;
924 	g_info( "thumbnailing source" ); 
925 	if( !(thumbnail-&gt;loader = vips_foreign_find_load_source( 
926 			source-&gt;source )) ||
927 		!(image = vips_image_new_from_source( source-&gt;source, 
928 			source-&gt;option_string, NULL )) )
929 		return( -1 );
930 	vips_thumbnail_read_header( thumbnail, image );
931 	g_object_unref( image );
932 	return( 0 );
933 }
934 static VipsImage *
935 vips_thumbnail_source_open( VipsThumbnail *thumbnail, double factor )
936 {
937 	VipsThumbnailSource *source = (VipsThumbnailSource *) thumbnail;
938 	if( vips_isprefix( "VipsForeignLoadJpeg", thumbnail-&gt;loader ) ) {
939 		return( vips_image_new_from_source( 
940 			source-&gt;source, 
941 			source-&gt;option_string,
942 			"access", VIPS_ACCESS_SEQUENTIAL,
943 			"shrink", (int) factor,
944 			NULL ) );
945 	}
946 	else if( vips_isprefix( "VipsForeignLoadOpenslide", 
947 		thumbnail-&gt;loader ) ) {
948 		return( vips_image_new_from_source( 
949 			source-&gt;source, 
950 			source-&gt;option_string,
951 			"access", VIPS_ACCESS_SEQUENTIAL,
952 			"level", (int) factor,
953 			NULL ) );
954 	}
955 	else if( vips_isprefix( "VipsForeignLoadPdf", thumbnail-&gt;loader ) ||
956 		vips_isprefix( "VipsForeignLoadSvg", thumbnail-&gt;loader ) ||
957 		vips_isprefix( "VipsForeignLoadWebp", thumbnail-&gt;loader ) ) {
958 		return( vips_image_new_from_source( 
959 			source-&gt;source, 
960 			source-&gt;option_string,
961 			"access", VIPS_ACCESS_SEQUENTIAL,
962 			"scale", 1.0 / factor,
963 			NULL ) );
964 	}
965 	else if( vips_isprefix( "VipsForeignLoadJp2k", thumbnail-&gt;loader ) ) {
966 		if( thumbnail-&gt;page_pyramid )
967 			return( vips_image_new_from_source(
968 				source-&gt;source, 
969 				source-&gt;option_string,
970 				"access", VIPS_ACCESS_SEQUENTIAL,
971 				"page", (int) factor,
972 				NULL ) );
973 		else
974 			return( vips_image_new_from_source(
975 				source-&gt;source, 
976 				source-&gt;option_string,
977 				"access", VIPS_ACCESS_SEQUENTIAL,
978 				NULL ) );
979 	}
980 	else if( vips_isprefix( "VipsForeignLoadTiff", thumbnail-&gt;loader ) ) {
981 		if( thumbnail-&gt;subifd_pyramid )
982 			return( vips_image_new_from_source(
983 				source-&gt;source, 
984 				source-&gt;option_string,
985 				"access", VIPS_ACCESS_SEQUENTIAL,
986 				"subifd", (int) factor,
987 				NULL ) );
988 		else if( thumbnail-&gt;page_pyramid )
989 			return( vips_image_new_from_source(
990 				source-&gt;source, 
991 				source-&gt;option_string,
992 				"access", VIPS_ACCESS_SEQUENTIAL,
993 				"page", (int) factor,
994 				NULL ) );
995 		else
996 			return( vips_image_new_from_source(
997 				source-&gt;source, 
998 				source-&gt;option_string,
999 				"access", VIPS_ACCESS_SEQUENTIAL,
1000 				NULL ) );
1001 	}
1002 	else if( vips_isprefix( "VipsForeignLoadHeif", thumbnail-&gt;loader ) ) {
1003 		return( vips_image_new_from_source( 
1004 			source-&gt;source, 
1005 			source-&gt;option_string,
1006 			"access", VIPS_ACCESS_SEQUENTIAL,
1007 			"thumbnail", (int) factor,
1008 			NULL ) );
1009 	}
1010 	else {
1011 		return( vips_image_new_from_source( 
1012 			source-&gt;source, 
1013 			source-&gt;option_string,
1014 			"access", VIPS_ACCESS_SEQUENTIAL,
1015 			NULL ) );
1016 	}
1017 }
1018 static void
1019 vips_thumbnail_source_class_init( VipsThumbnailClass *class )
1020 {
1021 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
1022 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
1023 	VipsThumbnailClass *thumbnail_class = VIPS_THUMBNAIL_CLASS( class );
1024 	gobject_class-&gt;set_property = vips_object_set_property;
1025 	gobject_class-&gt;get_property = vips_object_get_property;
1026 	vobject_class-&gt;nickname = "thumbnail_source";
1027 	vobject_class-&gt;description = _( "generate thumbnail from source" );
1028 	thumbnail_class-&gt;get_info = vips_thumbnail_source_get_info;
1029 	thumbnail_class-&gt;open = vips_thumbnail_source_open;
1030 	VIPS_ARG_OBJECT( class, "source", 1,
1031 		_( "Source" ),
1032 		_( "Source to load from" ),
1033 		VIPS_ARGUMENT_REQUIRED_INPUT, 
1034 		G_STRUCT_OFFSET( VipsThumbnailSource, source ),
1035 		VIPS_TYPE_SOURCE );
1036 	VIPS_ARG_STRING( class, "option_string", 20,
1037 		_( "Extra options" ),
1038 		_( "Options that are passed on to the underlying loader" ),
1039 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1040 		G_STRUCT_OFFSET( VipsThumbnailSource, option_string ),
1041 		"" );
1042 }
1043 static void
1044 vips_thumbnail_source_init( VipsThumbnailSource *source )
1045 {
1046 }
1047 int
1048 vips_thumbnail_source( VipsSource *source, VipsImage **out, int width, ... )
1049 {
1050 	va_list ap;
1051 	int result;
1052 	va_start( ap, width );
1053 	result = vips_call_split( "thumbnail_source", ap, source, out, width );
1054 	va_end( ap );
1055 	return( result );
1056 }
1057 typedef struct _VipsThumbnailImage {
1058 	VipsThumbnail parent_object;
1059 	VipsImage *in;
1060 } VipsThumbnailImage;
1061 typedef VipsThumbnailClass VipsThumbnailImageClass;
1062 G_DEFINE_TYPE( VipsThumbnailImage, vips_thumbnail_image, 
1063 	vips_thumbnail_get_type() );
1064 static int
1065 vips_thumbnail_image_get_info( VipsThumbnail *thumbnail )
1066 {
1067 	VipsThumbnailImage *image = (VipsThumbnailImage *) thumbnail;
1068 	thumbnail-&gt;loader = "image source";
1069 	vips_thumbnail_read_header( thumbnail, image-&gt;in );
1070 	return( 0 );
1071 }
1072 static VipsImage *
1073 vips_thumbnail_image_open( VipsThumbnail *thumbnail, double factor )
1074 {
1075 	VipsThumbnailImage *image = (VipsThumbnailImage *) thumbnail;
1076 	g_object_ref( image-&gt;in ); 
1077 	return( image-&gt;in ); 
1078 }
1079 static void
1080 vips_thumbnail_image_class_init( VipsThumbnailClass *class )
1081 {
1082 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
1083 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
1084 	VipsThumbnailClass *thumbnail_class = VIPS_THUMBNAIL_CLASS( class );
1085 	gobject_class-&gt;set_property = vips_object_set_property;
1086 	gobject_class-&gt;get_property = vips_object_get_property;
1087 	vobject_class-&gt;nickname = "thumbnail_image";
1088 	vobject_class-&gt;description = _( "generate thumbnail from image" );
1089 	thumbnail_class-&gt;get_info = vips_thumbnail_image_get_info;
1090 	thumbnail_class-&gt;open = vips_thumbnail_image_open;
1091 	VIPS_ARG_IMAGE( class, "in", 1, 
1092 		_( "Input" ), 
1093 		_( "Input image argument" ),
1094 		VIPS_ARGUMENT_REQUIRED_INPUT,
1095 		G_STRUCT_OFFSET( VipsThumbnailImage, in ) );
1096 }
1097 static void
1098 vips_thumbnail_image_init( VipsThumbnailImage *image )
1099 {
1100 }
1101 int
1102 vips_thumbnail_image( VipsImage *in, VipsImage **out, int width, ... )
1103 {
1104 	va_list ap;
1105 	int result;
1106 	va_start( ap, width );
1107 	result = vips_call_split( "thumbnail_image", ap, in, out, width );
1108 	va_end( ap );
1109 	return( result );
1110 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
