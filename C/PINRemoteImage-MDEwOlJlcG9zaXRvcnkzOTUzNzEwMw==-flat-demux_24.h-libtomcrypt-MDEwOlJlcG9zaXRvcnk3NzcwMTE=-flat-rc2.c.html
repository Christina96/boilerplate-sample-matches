
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.0018761726078798%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-demux_24.h</h3>
            <pre><code>1  #ifndef WEBP_WEBP_DEMUX_H_
2  #define WEBP_WEBP_DEMUX_H_
3  #include "./decode.h"     
4  #include "./mux_types.h"
5  #ifdef __cplusplus
6  extern "C" {
7  #endif
8  #define WEBP_DEMUX_ABI_VERSION 0x0107    
9  typedef struct WebPDemuxer WebPDemuxer;
10  typedef struct WebPIterator WebPIterator;
11  typedef struct WebPChunkIterator WebPChunkIterator;
12  typedef struct WebPAnimInfo WebPAnimInfo;
13  typedef struct WebPAnimDecoderOptions WebPAnimDecoderOptions;
14  WEBP_EXTERN int WebPGetDemuxVersion(void);
15  typedef enum WebPDemuxState {
16    WEBP_DEMUX_PARSE_ERROR    = -1,  
17    WEBP_DEMUX_PARSING_HEADER =  0,  
18    WEBP_DEMUX_PARSED_HEADER  =  1,  
19    WEBP_DEMUX_DONE           =  2   
20  } WebPDemuxState;
21  WEBP_EXTERN WebPDemuxer* WebPDemuxInternal(
22      const WebPData*, int, WebPDemuxState*, int);
23  static WEBP_INLINE WebPDemuxer* WebPDemux(const WebPData* data) {
24    return WebPDemuxInternal(data, 0, NULL, WEBP_DEMUX_ABI_VERSION);
25  }
26  static WEBP_INLINE WebPDemuxer* WebPDemuxPartial(
27      const WebPData* data, WebPDemuxState* state) {
28    return WebPDemuxInternal(data, 1, state, WEBP_DEMUX_ABI_VERSION);
29  }
30  WEBP_EXTERN void WebPDemuxDelete(WebPDemuxer* dmux);
31  typedef enum WebPFormatFeature {
32    WEBP_FF_FORMAT_FLAGS,      
33    WEBP_FF_CANVAS_WIDTH,
34    WEBP_FF_CANVAS_HEIGHT,
35    WEBP_FF_LOOP_COUNT,        
36    WEBP_FF_BACKGROUND_COLOR,  
37    WEBP_FF_FRAME_COUNT        
38  } WebPFormatFeature;
39  WEBP_EXTERN uint32_t WebPDemuxGetI(
40      const WebPDemuxer* dmux, WebPFormatFeature feature);
<span onclick='openModal()' class='match'>41  struct WebPIterator {
42    int frame_num;
43    int num_frames;          
44    int x_offset, y_offset;  
45    int width, height;       
46    int duration;            
47    WebPMuxAnimDispose dispose_method;  
48    int complete;   
49    WebPData fragment;  
50    int has_alpha;      
</span>51    WebPMuxAnimBlend blend_method;  
52    uint32_t pad[2];         
53    void* private_;          
54  };
55  WEBP_EXTERN int WebPDemuxGetFrame(
56      const WebPDemuxer* dmux, int frame_number, WebPIterator* iter);
57  WEBP_EXTERN int WebPDemuxNextFrame(WebPIterator* iter);
58  WEBP_EXTERN int WebPDemuxPrevFrame(WebPIterator* iter);
59  WEBP_EXTERN void WebPDemuxReleaseIterator(WebPIterator* iter);
60  struct WebPChunkIterator {
61    int chunk_num;
62    int num_chunks;
63    WebPData chunk;    
64    uint32_t pad[6];   
65    void* private_;
66  };
67  WEBP_EXTERN int WebPDemuxGetChunk(const WebPDemuxer* dmux,
68                                    const char fourcc[4], int chunk_number,
69                                    WebPChunkIterator* iter);
70  WEBP_EXTERN int WebPDemuxNextChunk(WebPChunkIterator* iter);
71  WEBP_EXTERN int WebPDemuxPrevChunk(WebPChunkIterator* iter);
72  WEBP_EXTERN void WebPDemuxReleaseChunkIterator(WebPChunkIterator* iter);
73  typedef struct WebPAnimDecoder WebPAnimDecoder;  
74  struct WebPAnimDecoderOptions {
75    WEBP_CSP_MODE color_mode;
76    int use_threads;           
77    uint32_t padding[7];       
78  };
79  WEBP_EXTERN int WebPAnimDecoderOptionsInitInternal(
80      WebPAnimDecoderOptions*, int);
81  static WEBP_INLINE int WebPAnimDecoderOptionsInit(
82      WebPAnimDecoderOptions* dec_options) {
83    return WebPAnimDecoderOptionsInitInternal(dec_options,
84                                              WEBP_DEMUX_ABI_VERSION);
85  }
86  WEBP_EXTERN WebPAnimDecoder* WebPAnimDecoderNewInternal(
87      const WebPData*, const WebPAnimDecoderOptions*, int);
88  static WEBP_INLINE WebPAnimDecoder* WebPAnimDecoderNew(
89      const WebPData* webp_data, const WebPAnimDecoderOptions* dec_options) {
90    return WebPAnimDecoderNewInternal(webp_data, dec_options,
91                                      WEBP_DEMUX_ABI_VERSION);
92  }
93  struct WebPAnimInfo {
94    uint32_t canvas_width;
95    uint32_t canvas_height;
96    uint32_t loop_count;
97    uint32_t bgcolor;
98    uint32_t frame_count;
99    uint32_t pad[4];   
100  };
101  WEBP_EXTERN int WebPAnimDecoderGetInfo(const WebPAnimDecoder* dec,
102                                         WebPAnimInfo* info);
103  WEBP_EXTERN int WebPAnimDecoderGetNext(WebPAnimDecoder* dec,
104                                         uint8_t** buf, int* timestamp);
105  WEBP_EXTERN int WebPAnimDecoderHasMoreFrames(const WebPAnimDecoder* dec);
106  WEBP_EXTERN void WebPAnimDecoderReset(WebPAnimDecoder* dec);
107  WEBP_EXTERN const WebPDemuxer* WebPAnimDecoderGetDemuxer(
108      const WebPAnimDecoder* dec);
109  WEBP_EXTERN void WebPAnimDecoderDelete(WebPAnimDecoder* dec);
110  #ifdef __cplusplus
111  }    
112  #endif
113  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rc2.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_RC2
<span onclick='openModal()' class='match'>3  const struct ltc_cipher_descriptor rc2_desc = {
4     "rc2",
5     12, 8, 128, 8, 16,
6     &rc2_setup,
7     &rc2_ecb_encrypt,
8     &rc2_ecb_decrypt,
9     &rc2_test,
10     &rc2_done,
11     &rc2_keysize,
12     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
</span>13  };
14  static const unsigned char permute[256] = {
15          217,120,249,196, 25,221,181,237, 40,233,253,121, 74,160,216,157,
16          198,126, 55,131, 43,118, 83,142, 98, 76,100,136, 68,139,251,162,
17           23,154, 89,245,135,179, 79, 19, 97, 69,109,141,  9,129,125, 50,
18          189,143, 64,235,134,183,123, 11,240,149, 33, 34, 92,107, 78,130,
19           84,214,101,147,206, 96,178, 28,115, 86,192, 20,167,140,241,220,
20           18,117,202, 31, 59,190,228,209, 66, 61,212, 48,163, 60,182, 38,
21          111,191, 14,218, 70,105,  7, 87, 39,242, 29,155,188,148, 67,  3,
22          248, 17,199,246,144,239, 62,231,  6,195,213, 47,200,102, 30,215,
23            8,232,234,222,128, 82,238,247,132,170,114,172, 53, 77,106, 42,
24          150, 26,210,113, 90, 21, 73,116, 75,159,208, 94,  4, 24,164,236,
25          194,224, 65,110, 15, 81,203,204, 36,145,175, 80,161,244,112, 57,
26          153,124, 58,133, 35,184,180,122,252,  2, 54, 91, 37, 85,151, 49,
27           45, 93,250,152,227,138,146,174,  5,223, 41, 16,103,108,186,201,
28          211,  0,230,207,225,158,168, 44, 99, 22,  1, 63, 88,226,137,169,
29           13, 56, 52, 27,171, 51,255,176,187, 72, 12, 95,185,177,205, 46,
30          197,243,219, 71,229,165,156,119, 10,166, 32,104,254,127,193,173
31  };
32  int rc2_setup_ex(const unsigned char *key, int keylen, int bits, int num_rounds, symmetric_key *skey)
33  {
34     unsigned *xkey = skey->rc2.xkey;
35     unsigned char tmp[128];
36     unsigned T8, TM;
37     int i;
38     LTC_ARGCHK(key  != NULL);
39     LTC_ARGCHK(skey != NULL);
40     if (keylen == 0 || keylen > 128 || bits > 1024) {
41        return CRYPT_INVALID_KEYSIZE;
42     }
43     if (bits == 0) {
44        bits = 1024;
45     }
46     if (num_rounds != 0 && num_rounds != 16) {
47        return CRYPT_INVALID_ROUNDS;
48     }
49     for (i = 0; i < keylen; i++) {
50        tmp[i] = key[i] & 255;
51     }
52     if (keylen < 128) {
53        for (i = keylen; i < 128; i++) {
54           tmp[i] = permute[(tmp[i - 1] + tmp[i - keylen]) & 255];
55        }
56     }
57     T8   = (unsigned)(bits+7)>>3;
58     TM   = (255 >> (unsigned)(7 & -bits));
59     tmp[128 - T8] = permute[tmp[128 - T8] & TM];
60     for (i = 127 - T8; i >= 0; i--) {
61        tmp[i] = permute[tmp[i + 1] ^ tmp[i + T8]];
62     }
63     for (i = 0; i < 64; i++) {
64        xkey[i] =  (unsigned)tmp[2*i] + ((unsigned)tmp[2*i+1] << 8);
65     }
66  #ifdef LTC_CLEAN_STACK
67     zeromem(tmp, sizeof(tmp));
68  #endif
69     return CRYPT_OK;
70  }
71  int rc2_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
72  {
73     return rc2_setup_ex(key, keylen, keylen * 8, num_rounds, skey);
74  }
75  #ifdef LTC_CLEAN_STACK
76  static int s_rc2_ecb_encrypt( const unsigned char *pt,
77                              unsigned char *ct,
78                              const symmetric_key *skey)
79  #else
80  int rc2_ecb_encrypt( const unsigned char *pt,
81                              unsigned char *ct,
82                              const symmetric_key *skey)
83  #endif
84  {
85      const unsigned *xkey;
86      unsigned x76, x54, x32, x10, i;
87      LTC_ARGCHK(pt  != NULL);
88      LTC_ARGCHK(ct != NULL);
89      LTC_ARGCHK(skey   != NULL);
90      xkey = skey->rc2.xkey;
91      x76 = ((unsigned)pt[7] << 8) + (unsigned)pt[6];
92      x54 = ((unsigned)pt[5] << 8) + (unsigned)pt[4];
93      x32 = ((unsigned)pt[3] << 8) + (unsigned)pt[2];
94      x10 = ((unsigned)pt[1] << 8) + (unsigned)pt[0];
95      for (i = 0; i < 16; i++) {
96          x10 = (x10 + (x32 & ~x76) + (x54 & x76) + xkey[4*i+0]) & 0xFFFF;
97          x10 = ((x10 << 1) | (x10 >> 15));
98          x32 = (x32 + (x54 & ~x10) + (x76 & x10) + xkey[4*i+1]) & 0xFFFF;
99          x32 = ((x32 << 2) | (x32 >> 14));
100          x54 = (x54 + (x76 & ~x32) + (x10 & x32) + xkey[4*i+2]) & 0xFFFF;
101          x54 = ((x54 << 3) | (x54 >> 13));
102          x76 = (x76 + (x10 & ~x54) + (x32 & x54) + xkey[4*i+3]) & 0xFFFF;
103          x76 = ((x76 << 5) | (x76 >> 11));
104          if (i == 4 || i == 10) {
105              x10 = (x10 + xkey[x76 & 63]) & 0xFFFF;
106              x32 = (x32 + xkey[x10 & 63]) & 0xFFFF;
107              x54 = (x54 + xkey[x32 & 63]) & 0xFFFF;
108              x76 = (x76 + xkey[x54 & 63]) & 0xFFFF;
109          }
110      }
111      ct[0] = (unsigned char)x10;
112      ct[1] = (unsigned char)(x10 >> 8);
113      ct[2] = (unsigned char)x32;
114      ct[3] = (unsigned char)(x32 >> 8);
115      ct[4] = (unsigned char)x54;
116      ct[5] = (unsigned char)(x54 >> 8);
117      ct[6] = (unsigned char)x76;
118      ct[7] = (unsigned char)(x76 >> 8);
119      return CRYPT_OK;
120  }
121  #ifdef LTC_CLEAN_STACK
122  int rc2_ecb_encrypt( const unsigned char *pt,
123                              unsigned char *ct,
124                              const symmetric_key *skey)
125  {
126      int err = s_rc2_ecb_encrypt(pt, ct, skey);
127      burn_stack(sizeof(unsigned *) + sizeof(unsigned) * 5);
128      return err;
129  }
130  #endif
131  #ifdef LTC_CLEAN_STACK
132  static int s_rc2_ecb_decrypt( const unsigned char *ct,
133                              unsigned char *pt,
134                              const symmetric_key *skey)
135  #else
136  int rc2_ecb_decrypt( const unsigned char *ct,
137                              unsigned char *pt,
138                              const symmetric_key *skey)
139  #endif
140  {
141      unsigned x76, x54, x32, x10;
142      const unsigned *xkey;
143      int i;
144      LTC_ARGCHK(pt  != NULL);
145      LTC_ARGCHK(ct != NULL);
146      LTC_ARGCHK(skey   != NULL);
147      xkey = skey->rc2.xkey;
148      x76 = ((unsigned)ct[7] << 8) + (unsigned)ct[6];
149      x54 = ((unsigned)ct[5] << 8) + (unsigned)ct[4];
150      x32 = ((unsigned)ct[3] << 8) + (unsigned)ct[2];
151      x10 = ((unsigned)ct[1] << 8) + (unsigned)ct[0];
152      for (i = 15; i >= 0; i--) {
153          if (i == 4 || i == 10) {
154              x76 = (x76 - xkey[x54 & 63]) & 0xFFFF;
155              x54 = (x54 - xkey[x32 & 63]) & 0xFFFF;
156              x32 = (x32 - xkey[x10 & 63]) & 0xFFFF;
157              x10 = (x10 - xkey[x76 & 63]) & 0xFFFF;
158          }
159          x76 = ((x76 << 11) | (x76 >> 5));
160          x76 = (x76 - ((x10 & ~x54) + (x32 & x54) + xkey[4*i+3])) & 0xFFFF;
161          x54 = ((x54 << 13) | (x54 >> 3));
162          x54 = (x54 - ((x76 & ~x32) + (x10 & x32) + xkey[4*i+2])) & 0xFFFF;
163          x32 = ((x32 << 14) | (x32 >> 2));
164          x32 = (x32 - ((x54 & ~x10) + (x76 & x10) + xkey[4*i+1])) & 0xFFFF;
165          x10 = ((x10 << 15) | (x10 >> 1));
166          x10 = (x10 - ((x32 & ~x76) + (x54 & x76) + xkey[4*i+0])) & 0xFFFF;
167      }
168      pt[0] = (unsigned char)x10;
169      pt[1] = (unsigned char)(x10 >> 8);
170      pt[2] = (unsigned char)x32;
171      pt[3] = (unsigned char)(x32 >> 8);
172      pt[4] = (unsigned char)x54;
173      pt[5] = (unsigned char)(x54 >> 8);
174      pt[6] = (unsigned char)x76;
175      pt[7] = (unsigned char)(x76 >> 8);
176      return CRYPT_OK;
177  }
178  #ifdef LTC_CLEAN_STACK
179  int rc2_ecb_decrypt( const unsigned char *ct,
180                              unsigned char *pt,
181                              const symmetric_key *skey)
182  {
183      int err = s_rc2_ecb_decrypt(ct, pt, skey);
184      burn_stack(sizeof(unsigned *) + sizeof(unsigned) * 4 + sizeof(int));
185      return err;
186  }
187  #endif
188  int rc2_test(void)
189  {
190   #ifndef LTC_TEST
191      return CRYPT_NOP;
192   #else
193     static const struct {
194          int keylen, bits;
195          unsigned char key[16], pt[8], ct[8];
196     } tests[] = {
197     { 8, 63,
198       { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
199         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
200       { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
201       { 0xeb, 0xb7, 0x73, 0xf9, 0x93, 0x27, 0x8e, 0xff }
202     },
203     { 8, 64,
204       { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
205         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
206       { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff },
207       { 0x27, 0x8b, 0x27, 0xe4, 0x2e, 0x2f, 0x0d, 0x49 }
208     },
209     { 8, 64,
210       { 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
211         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
212       { 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
213       { 0x30, 0x64, 0x9e, 0xdf, 0x9b, 0xe7, 0xd2, 0xc2 }
214     },
215     { 1, 64,
216       { 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
217         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
218       { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
219       { 0x61, 0xa8, 0xa2, 0x44, 0xad, 0xac, 0xcc, 0xf0 }
220     },
221     { 7, 64,
222       { 0x88, 0xbc, 0xa9, 0x0e, 0x90, 0x87, 0x5a, 0x00,
223         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
224       { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
225       { 0x6c, 0xcf, 0x43, 0x08, 0x97, 0x4c, 0x26, 0x7f }
226     },
227     { 16, 64,
228       { 0x88, 0xbc, 0xa9, 0x0e, 0x90, 0x87, 0x5a, 0x7f,
229         0x0f, 0x79, 0xc3, 0x84, 0x62, 0x7b, 0xaf, 0xb2 },
230       { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
231       { 0x1a, 0x80, 0x7d, 0x27, 0x2b, 0xbe, 0x5d, 0xb1 }
232     },
233     { 16, 128,
234       { 0x88, 0xbc, 0xa9, 0x0e, 0x90, 0x87, 0x5a, 0x7f,
235         0x0f, 0x79, 0xc3, 0x84, 0x62, 0x7b, 0xaf, 0xb2 },
236       { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
237       { 0x22, 0x69, 0x55, 0x2a, 0xb0, 0xf8, 0x5c, 0xa6 }
238     }
239    };
240      int x, y, err;
241      symmetric_key skey;
242      unsigned char tmp[2][8];
243      for (x = 0; x < (int)(sizeof(tests) / sizeof(tests[0])); x++) {
244          zeromem(tmp, sizeof(tmp));
245          if (tests[x].bits == (tests[x].keylen * 8)) {
246             if ((err = rc2_setup(tests[x].key, tests[x].keylen, 0, &skey)) != CRYPT_OK) {
247                return err;
248             }
249          }
250          else {
251             if ((err = rc2_setup_ex(tests[x].key, tests[x].keylen, tests[x].bits, 0, &skey)) != CRYPT_OK) {
252                return err;
253             }
254          }
255          rc2_ecb_encrypt(tests[x].pt, tmp[0], &skey);
256          rc2_ecb_decrypt(tmp[0], tmp[1], &skey);
257          if (compare_testvector(tmp[0], 8, tests[x].ct, 8, "RC2 CT", x) ||
258                compare_testvector(tmp[1], 8, tests[x].pt, 8, "RC2 PT", x)) {
259             return CRYPT_FAIL_TESTVECTOR;
260          }
261        for (y = 0; y < 8; y++) tmp[0][y] = 0;
262        for (y = 0; y < 1000; y++) rc2_ecb_encrypt(tmp[0], tmp[0], &skey);
263        for (y = 0; y < 1000; y++) rc2_ecb_decrypt(tmp[0], tmp[0], &skey);
264        for (y = 0; y < 8; y++) if (tmp[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;
265      }
266      return CRYPT_OK;
267     #endif
268  }
269  void rc2_done(symmetric_key *skey)
270  {
271    LTC_UNUSED_PARAM(skey);
272  }
273  int rc2_keysize(int *keysize)
274  {
275     LTC_ARGCHK(keysize != NULL);
276     if (*keysize < 1) {
277         return CRYPT_INVALID_KEYSIZE;
278     }
279     if (*keysize > 128) {
280         *keysize = 128;
281     }
282     return CRYPT_OK;
283  }
284  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-demux_24.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rc2.c</div>
                </div>
                <div class="column column_space"><pre><code>41  struct WebPIterator {
42    int frame_num;
43    int num_frames;          
44    int x_offset, y_offset;  
45    int width, height;       
46    int duration;            
47    WebPMuxAnimDispose dispose_method;  
48    int complete;   
49    WebPData fragment;  
50    int has_alpha;      
</pre></code></div>
                <div class="column column_space"><pre><code>3  const struct ltc_cipher_descriptor rc2_desc = {
4     "rc2",
5     12, 8, 128, 8, 16,
6     &rc2_setup,
7     &rc2_ecb_encrypt,
8     &rc2_ecb_decrypt,
9     &rc2_test,
10     &rc2_done,
11     &rc2_keysize,
12     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    