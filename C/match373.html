<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for inf-test-chat.c &amp; inf-test-browser.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-test-chat.c &amp; inf-test-browser.c
      </h3>
<h1 align="center">
        25.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-test-chat.c (30.81761%)<th>inf-test-browser.c (21.39738%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(324-384)<td><a href="#" name="0">(340-400)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(55-72)<td><a href="#" name="1">(229-247)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(300-320)<td><a href="#" name="2">(318-338)</a><td align="center"><font color="#b80000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-test-chat.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include &lt;libinfinity/client/infc-browser.h&gt;
#include &lt;libinfinity/communication/inf-communication-manager.h&gt;
#include &lt;libinfinity/common/inf-session-proxy.h&gt;
#include &lt;libinfinity/common/inf-chat-buffer.h&gt;
#include &lt;libinfinity/common/inf-chat-session.h&gt;
#include &lt;libinfinity/common/inf-xmpp-connection.h&gt;
#include &lt;libinfinity/common/inf-tcp-connection.h&gt;
#include &lt;libinfinity/common/inf-request-result.h&gt;
#include &lt;libinfinity/common/inf-ip-address.h&gt;
#include &lt;libinfinity/common/inf-standalone-io.h&gt;
#include &lt;libinfinity/common/inf-io.h&gt;
#include &lt;libinfinity/common/inf-protocol.h&gt;
#include &lt;libinfinity/common/inf-init.h&gt;

#include &lt;string.h&gt;

typedef struct _InfTestChat InfTestChat;
struct _InfTestChat {
  InfStandaloneIo* io;
  InfXmppConnection* conn;
  InfBrowser* browser;
#ifndef G_OS_WIN32
  int input_fd;
#endif

  InfChatBuffer* buffer;
  InfUser* self;
};

static void
inf_test_chat_input_cb(InfNativeSocket* fd,
                       InfIoEvent io,
<a name="1"></a>                       gpointer user_data)
{
  InfTestChat* test;
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  char buffer[1024];

  test = (InfTestChat*)user_data;

  if(io &amp; INF_IO_ERROR)
  {
  }

  if(io &amp; INF_IO_INCOMING)
  {
    if(fgets(buffer, sizeof(buffer), stdin) == NULL)
    {
      inf_standalone_io_loop_quit(test-&gt;io);
    }
    else if(strlen(buffer) != sizeof(buffer) ||
            buffer[sizeof(buffer)-2] == '\n')
    {
      buffer[strlen(buffer)-1] = '\0';</b></font>

      if(test-&gt;buffer != NULL &amp;&amp; test-&gt;self != NULL)
      {
        inf_chat_buffer_add_message(
          test-&gt;buffer,
          test-&gt;self,
          buffer,
          strlen(buffer),
          time(NULL),
          0
        );
      }
    }
  }
}

static void
inf_chat_test_buffer_receive_message_cb(InfChatSession* session,
                                        InfChatBufferMessage* message,
                                        gpointer user_data)
{
  switch(message-&gt;type)
  {
  case INF_CHAT_BUFFER_MESSAGE_NORMAL:
    printf("&lt;%s&gt; %s\n", inf_user_get_name(message-&gt;user), message-&gt;text);
    break;
  case INF_CHAT_BUFFER_MESSAGE_EMOTE:
    printf(" * %s %s\n", inf_user_get_name(message-&gt;user), message-&gt;text);
    break;
  case INF_CHAT_BUFFER_MESSAGE_USERJOIN:
    printf(" --&gt; %s has joined\n", inf_user_get_name(message-&gt;user));
    break;
  case INF_CHAT_BUFFER_MESSAGE_USERPART:
    printf(" &lt;-- %s has left\n", inf_user_get_name(message-&gt;user));
    break;
  }
}

static void
inf_test_chat_userjoin_finished_cb(InfRequest* request,
                                   const InfRequestResult* result,
                                   const GError* error,
                                   gpointer user_data)
{
  InfTestChat* test;
  InfUser* user;

  test = (InfTestChat*)user_data;

  if(error == NULL)
  {
    printf("User join complete. Start chatting!\n");

#ifndef G_OS_WIN32
    inf_io_add_watch(
      INF_IO(test-&gt;io),
      &amp;test-&gt;input_fd,
      INF_IO_INCOMING | INF_IO_ERROR,
      inf_test_chat_input_cb,
      test,
      NULL
    );
#endif

    inf_request_result_get_join_user(result, NULL, &amp;user);
    test-&gt;self = user;
  }
  else
  {
    fprintf(stderr, "User join failed: %s\n", error-&gt;message);
    fprintf(stderr, "Chat will be read-only\n");
  }
}

static void
inf_chat_test_session_synchronization_complete_cb(InfSession* session,
                                                  InfXmlConnection* connection,
                                                  gpointer user_data)
{
  InfTestChat* test;
  InfcSessionProxy* proxy;
  InfRequest* request;
  GParameter params[1] = { { "name", { 0 } } };

  printf("Synchronization complete, joining user...\n");

  test = (InfTestChat*)user_data;
  proxy = infc_browser_get_chat_session(INFC_BROWSER(test-&gt;browser));

  g_value_init(&amp;params[0].value, G_TYPE_STRING);
  g_value_set_string(&amp;params[0].value, g_get_user_name());

  inf_session_proxy_join_user(
    INF_SESSION_PROXY(proxy),
    G_N_ELEMENTS(params),
    params,
    inf_test_chat_userjoin_finished_cb,
    test
  );

  g_value_unset(&amp;params[0].value);
}

static void
inf_chat_test_session_synchronization_failed_cb(InfSession* session,
                                                InfXmlConnection* connection,
                                                const GError* error,
                                                gpointer user_data)
{
  InfTestChat* test;
  test = (InfTestChat*)user_data;

  fprintf(stderr, "Synchronization failed: %s\n", error-&gt;message);
  inf_standalone_io_loop_quit(test-&gt;io);
}

static void
inf_chat_test_session_close_cb(InfSession* session,
                               gpointer user_data)
{
  InfTestChat* test;
  test = (InfTestChat*)user_data;

  printf("The server closed the chat session\n");
  if(inf_standalone_io_loop_running(test-&gt;io))
    inf_standalone_io_loop_quit(test-&gt;io);
}

static void
inf_chat_test_subscribe_finished_cb(InfRequest* request,
                                    const InfRequestResult* result,
                                    const GError* error,
                                    gpointer user_data)
{
  InfTestChat* test;
  InfcSessionProxy* proxy;
  InfSession* session;
  test = (InfTestChat*)user_data;

  if(error == NULL)
  {
    printf("Subscription successful, waiting for synchronization...\n");

    proxy = infc_browser_get_chat_session(INFC_BROWSER(test-&gt;browser));
    g_object_get(G_OBJECT(proxy), "session", &amp;session, NULL);

    test-&gt;buffer = INF_CHAT_BUFFER(inf_session_get_buffer(session));

    /* TODO: Show backlog after during/after synchronization */

    g_signal_connect_after(
      G_OBJECT(session),
      "receive-message",
      G_CALLBACK(inf_chat_test_buffer_receive_message_cb),
      test
    );

    g_signal_connect_after(
      G_OBJECT(session),
      "synchronization-complete",
      G_CALLBACK(inf_chat_test_session_synchronization_complete_cb),
      test
    );

    g_signal_connect_after(
      G_OBJECT(session),
      "synchronization-failed",
      G_CALLBACK(inf_chat_test_session_synchronization_failed_cb),
      test
    );

    /* This can happen when the server disables the chat without being
     * shutdown. */
    g_signal_connect_after(
      G_OBJECT(session),
      "close",
      G_CALLBACK(inf_chat_test_session_close_cb),
      test
    );

    g_object_unref(session);
  }
  else
  {
    fprintf(stderr, "Subscription failed: %s\n", error-&gt;message);
    inf_standalone_io_loop_quit(test-&gt;io);
  }
}

static void
inf_test_chat_notify_status_cb(GObject* object,
                               GParamSpec* pspec,
                               gpointer user_data)
{
  InfTestChat* test;
  InfBrowserStatus status;

  test = (InfTestChat*)user_data;
  g_object_get(G_OBJECT(object), "status", &amp;status, NULL);

  if(status == INF_BROWSER_OPEN)
  {
    printf("Connection established, subscribing to chat...\n");

    /* Subscribe to chat */
    infc_browser_subscribe_chat(
      INFC_BROWSER(test-&gt;browser),
      inf_chat_test_subscribe_finished_cb,
      test
    );
  }

  if(status == INF_BROWSER_CLOSED)
  {
    printf("Connection closed\n");
    if(inf_standalone_io_loop_running(test-&gt;io))
      inf_standalone_io_loop_quit(test-&gt;io);
  }
}

static void
inf_test_chat_error_cb(InfXmppConnection* xmpp,
                          GError* error,
                          gpointer user_data)
<a name="2"></a>{
  /* status notify will close conn: */
  fprintf(stderr, "Connection error: %s\n", error-&gt;message);
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

int
main(int argc, char* argv[])
{
  InfTestChat test;
  InfIpAddress* address;
  InfCommunicationManager* manager;
  InfTcpConnection* tcp_conn;
  GError* error;

  error = NULL;
  if(!inf_init(&amp;error))
  {
    fprintf(stderr, "%s\n", error-&gt;message);
    return 1;
  }

  test.io = inf_standalone_io_new();
#ifndef G_OS_WIN32
  test.input_fd = STDIN_FILENO;</b></font>
<a name="0"></a>#endif
  test.buffer = NULL;

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  address = inf_ip_address_new_loopback4();

  tcp_conn =
    inf_tcp_connection_new_and_open(INF_IO(test.io), address, inf_protocol_get_default_port(), &amp;error);

  inf_ip_address_free(address);

  if(tcp_conn == NULL)
  {
    fprintf(stderr, "Could not open TCP connection: %s\n", error-&gt;message);
    g_error_free(error);
  }
  else
  {
    test.conn = inf_xmpp_connection_new(
      tcp_conn,
      INF_XMPP_CONNECTION_CLIENT,
      NULL,
      "localhost",
      INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS,
      NULL,
      NULL,
      NULL
    );

    g_object_unref(G_OBJECT(tcp_conn));

    manager = inf_communication_manager_new();
    test.browser = INF_BROWSER(
      infc_browser_new(
        INF_IO(test.io),
        manager,
        INF_XML_CONNECTION(test.conn)
      )
    );

    g_signal_connect_after(
      G_OBJECT(test.browser),
      "notify::status",
      G_CALLBACK(inf_test_chat_notify_status_cb),
      &amp;test
    );

    g_signal_connect(
      G_OBJECT(test.browser),
      "error",
      G_CALLBACK(inf_test_chat_error_cb),
      &amp;test
    );

    inf_standalone_io_loop(test.io);
    g_object_unref(G_OBJECT(manager));
    g_object_unref(G_OBJECT(test.browser));

    /* TODO: Wait until the XMPP connection is in status closed */
    g_object_unref(G_OBJECT(test.conn));
  }

  g_object_unref(G_OBJECT(test.io));
  return 0;
}</b></font>

/* vim:set et sw=2 ts=2: */
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-test-browser.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include &lt;libinfinity/client/infc-browser.h&gt;
#include &lt;libinfinity/communication/inf-communication-manager.h&gt;
#include &lt;libinfinity/common/inf-xmpp-connection.h&gt;
#include &lt;libinfinity/common/inf-tcp-connection.h&gt;
#include &lt;libinfinity/common/inf-ip-address.h&gt;
#include &lt;libinfinity/common/inf-standalone-io.h&gt;
#include &lt;libinfinity/common/inf-io.h&gt;
#include &lt;libinfinity/common/inf-protocol.h&gt;
#include &lt;libinfinity/common/inf-init.h&gt;

#include &lt;string.h&gt;

typedef struct _InfTestBrowser InfTestBrowser;
struct _InfTestBrowser {
  InfStandaloneIo* io;
  InfXmppConnection* conn;
  InfBrowser* browser;
#ifndef G_OS_WIN32
  int input_fd;
#endif

  InfBrowserIter cwd;
};

typedef void(*InfTestBrowserCmdFunc)(InfTestBrowser*, const gchar*);

typedef struct _InfTestBrowserCmd InfTestBrowserCmd;
struct _InfTestBrowserCmd {
  const gchar* name;
  InfTestBrowserCmdFunc func;
};

static gboolean
inf_test_browser_find_node(InfTestBrowser* test,
                           const gchar* name,
                           InfBrowserIter* result_iter)
{
  InfBrowserIter iter;
  gboolean result;

  if(inf_browser_get_explored(test-&gt;browser, &amp;test-&gt;cwd) == FALSE)
  {
    fprintf(
      stderr,
      "Directory '%s' not yet explored\n",
      inf_browser_get_node_name(test-&gt;browser, &amp;test-&gt;cwd)
    );
  }
  else
  {
    iter = test-&gt;cwd;
    for(result = inf_browser_get_child(test-&gt;browser, &amp;iter);
        result == TRUE;
        result = inf_browser_get_next(test-&gt;browser, &amp;iter))
    {
      if(strcmp(inf_browser_get_node_name(test-&gt;browser, &amp;iter), name) == 0)
      {
        *result_iter = iter;
        return TRUE;
      }
    }
  }

  return FALSE;
}

static void
inf_test_browser_cmd_ls(InfTestBrowser* test,
                        const gchar* param)
{
  InfBrowserIter iter;
  gboolean result;

  if(inf_browser_get_explored(test-&gt;browser, &amp;test-&gt;cwd) == FALSE)
  {
    fprintf(
      stderr,
      "Directory '%s' not yet explored\n",
      inf_browser_get_node_name(test-&gt;browser, &amp;test-&gt;cwd)
    );
  }
  else
  {
    iter = test-&gt;cwd;
    for(result = inf_browser_get_child(test-&gt;browser, &amp;iter);
        result == TRUE;
        result = inf_browser_get_next(test-&gt;browser, &amp;iter))
    {
      printf("%s\n", inf_browser_get_node_name(test-&gt;browser, &amp;iter));
    }
  }
}

static void
inf_test_browser_cmd_cd(InfTestBrowser* test,
                        const gchar* param)
{
  InfBrowserIter iter;

  if(strcmp(param, "..") == 0)
  {
    iter = test-&gt;cwd;
    if(inf_browser_get_parent(test-&gt;browser, &amp;iter) == FALSE)
    {
      fprintf(stderr, "Already at the root directory\n");
    }
    else
    {
      test-&gt;cwd = iter;
    }
  }
  else if(inf_test_browser_find_node(test, param, &amp;iter) == FALSE)
  {
    fprintf(
      stderr,
      "Directory '%s' does not exist\n",
      param
    );
  }
  else if(inf_browser_get_explored(test-&gt;browser, &amp;iter) == FALSE)
  {
    fprintf(
      stderr,
      "Directory '%s' not yet explored\n",
      inf_browser_get_node_name(test-&gt;browser, &amp;iter)
    );
  }
  else
  {
    test-&gt;cwd = iter;
  }
}

static void
inf_test_browser_cmd_explore(InfTestBrowser* test,
                             const gchar* param)
{
  InfBrowserIter iter;

  if(inf_test_browser_find_node(test, param, &amp;iter) == FALSE)
  {
    fprintf(
      stderr,
      "Directory '%s' does not exist\n",
      param
    );
  }
  else if(inf_browser_get_explored(test-&gt;browser, &amp;iter) == TRUE)
  {
    fprintf(
      stderr,
      "Directory '%s' is already explored",
      inf_browser_get_node_name(test-&gt;browser, &amp;iter)
    );
  }
  else
  {
    inf_browser_explore(test-&gt;browser, &amp;iter, NULL, NULL);
  }
}

static void
inf_test_browser_cmd_create(InfTestBrowser* test,
                            const gchar* param)
{
  inf_browser_add_subdirectory(
    test-&gt;browser,
    &amp;test-&gt;cwd,
    param,
    NULL,
    NULL,
    NULL
  );
}

static void
inf_test_browser_cmd_remove(InfTestBrowser* test,
                            const gchar* param)
{
  InfBrowserIter iter;
  if(inf_test_browser_find_node(test, param, &amp;iter) == FALSE)
  {
    fprintf(
      stderr,
      "Directory '%s' does not exist\n",
      param
    );
  }
  else
  {
    inf_browser_remove_node(test-&gt;browser, &amp;iter, NULL, NULL);
  }
}

static const InfTestBrowserCmd inf_test_browser_commands[] = {
  { "ls", inf_test_browser_cmd_ls },
  { "cd", inf_test_browser_cmd_cd },
  { "explore", inf_test_browser_cmd_explore },
  { "create", inf_test_browser_cmd_create },
  { "remove", inf_test_browser_cmd_remove }
};

static void
inf_test_browser_input_cb(InfNativeSocket* fd,
                          InfIoEvent io,
                          gpointer user_data)
<a name="1"></a>{
  InfTestBrowser* test;
  char buffer[1024];
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  char* occ;
  guint i;

  test = (InfTestBrowser*)user_data;

  if(io &amp; INF_IO_ERROR)
  {
  }

  if(io &amp; INF_IO_INCOMING)
  {
    if(fgets(buffer, sizeof(buffer), stdin) == NULL)
    {
      inf_standalone_io_loop_quit(test-&gt;io);
    }
    else if(strlen(buffer) != sizeof(buffer) ||
            buffer[sizeof(buffer)-2] == '\n')
    {
      buffer[strlen(buffer)-1] = '\0';</b></font>

      /* Read entire line */
      occ = strchr(buffer, ' ');
      if(occ != NULL)
      {
        *occ = '\0';
        ++ occ;
      }

      for(i = 0; i &lt; G_N_ELEMENTS(inf_test_browser_commands); ++ i)
      {
        if(strcmp(inf_test_browser_commands[i].name, buffer) == 0)
        {
          inf_test_browser_commands[i].func(test, occ);
          break;
        }
      }

      if(i == G_N_ELEMENTS(inf_test_browser_commands))
      {
        fprintf(stderr, "'%s': Command not found\n", buffer);
      }
    }
  }
}

static void
inf_test_browser_error_cb(InfcBrowser* browser,
                          GError* error,
                          gpointer user_data)
{
  fprintf(stderr, "Connection error: %s\n", error-&gt;message);
}

static void
inf_test_browser_notify_status_cb(GObject* object,
                                  GParamSpec* pspec,
                                  gpointer user_data)
{
  InfTestBrowser* test;
  InfBrowserStatus status;

  test = (InfTestBrowser*)user_data;
  g_object_get(G_OBJECT(test-&gt;browser), "status", &amp;status, NULL);

  if(status == INF_BROWSER_OPEN)
  {
    printf("Connection established\n");

#ifndef G_OS_WIN32
    inf_io_add_watch(
      INF_IO(test-&gt;io),
      &amp;test-&gt;input_fd,
      INF_IO_INCOMING | INF_IO_ERROR,
      inf_test_browser_input_cb,
      test,
      NULL
    );
#endif

    /* Explore root node */
    inf_browser_get_root(test-&gt;browser, &amp;test-&gt;cwd);
    inf_browser_explore(test-&gt;browser, &amp;test-&gt;cwd, NULL, NULL);
  }

  if(status == INF_BROWSER_CLOSED)
  {
<a name="2"></a>    if(inf_standalone_io_loop_running(test-&gt;io))
      inf_standalone_io_loop_quit(test-&gt;io);
  }
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

int
main(int argc, char* argv[])
{
  InfTestBrowser test;
  InfIpAddress* address;
  InfCommunicationManager* manager;
  InfTcpConnection* tcp_conn;
  GError* error;

  error = NULL;
  if(!inf_init(&amp;error))
  {
    fprintf(stderr, "%s\n", error-&gt;message);
    return 1;
  }

  test.io = inf_standalone_io_new();
<a name="0"></a>#ifndef G_OS_WIN32
  test.input_fd = STDIN_FILENO;</b></font>
#endif
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  address = inf_ip_address_new_loopback4();

  tcp_conn =
    inf_tcp_connection_new_and_open(INF_IO(test.io), address, inf_protocol_get_default_port(), &amp;error);

  inf_ip_address_free(address);

  if(tcp_conn == NULL)
  {
    fprintf(stderr, "Could not open TCP connection: %s\n", error-&gt;message);
    g_error_free(error);
  }
  else
  {
    test.conn = inf_xmpp_connection_new(
      tcp_conn,
      INF_XMPP_CONNECTION_CLIENT,
      NULL,
      "localhost",
      INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS,
      NULL,
      NULL,
      NULL
    );

    g_object_unref(G_OBJECT(tcp_conn));

    manager = inf_communication_manager_new();
    test.browser = INF_BROWSER(
      infc_browser_new(
        INF_IO(test.io),
        manager,
        INF_XML_CONNECTION(test.conn)
      )
    );

    g_signal_connect_after(
      G_OBJECT(test.browser),
      "notify::status",
      G_CALLBACK(inf_test_browser_notify_status_cb),
      &amp;test
    );

    g_signal_connect(
      G_OBJECT(test.browser),
      "error",
      G_CALLBACK(inf_test_browser_error_cb),
      &amp;test
    );

    inf_standalone_io_loop(test.io);
    g_object_unref(G_OBJECT(manager));
    g_object_unref(G_OBJECT(test.browser));

    /* TODO: Wait until the XMPP connection is in status closed */
    g_object_unref(G_OBJECT(test.conn));
  }

  g_object_unref(G_OBJECT(test.io));
  return 0;
}</b></font>

/* vim:set et sw=2 ts=2: */
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
