<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-test-chat.c &amp; inf-test-browser.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-test-chat.c &amp; inf-test-browser.c
      </h3>
<h1 align="center">
        25.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-test-chat.c (30.81761%)<th>inf-test-browser.c (21.39738%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(324-384)<td><a href="#" name="0">(340-400)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(55-72)<td><a href="#" name="1">(229-247)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(300-320)<td><a href="#" name="2">(318-338)</a><td align="center"><font color="#b80000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-test-chat.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/client/infc-browser.h&gt;
2 #include &lt;libinfinity/communication/inf-communication-manager.h&gt;
3 #include &lt;libinfinity/common/inf-session-proxy.h&gt;
4 #include &lt;libinfinity/common/inf-chat-buffer.h&gt;
5 #include &lt;libinfinity/common/inf-chat-session.h&gt;
6 #include &lt;libinfinity/common/inf-xmpp-connection.h&gt;
7 #include &lt;libinfinity/common/inf-tcp-connection.h&gt;
8 #include &lt;libinfinity/common/inf-request-result.h&gt;
9 #include &lt;libinfinity/common/inf-ip-address.h&gt;
10 #include &lt;libinfinity/common/inf-standalone-io.h&gt;
11 #include &lt;libinfinity/common/inf-io.h&gt;
12 #include &lt;libinfinity/common/inf-protocol.h&gt;
13 #include &lt;libinfinity/common/inf-init.h&gt;
14 #include &lt;string.h&gt;
15 typedef struct _InfTestChat InfTestChat;
16 struct _InfTestChat {
17   InfStandaloneIo* io;
18   InfXmppConnection* conn;
19   InfBrowser* browser;
20 #ifndef G_OS_WIN32
21   int input_fd;
22 #endif
23   InfChatBuffer* buffer;
24   InfUser* self;
25 };
26 static void
27 inf_test_chat_input_cb(InfNativeSocket* fd,
28                        InfIoEvent io,
29 <a name="1"></a>                       gpointer user_data)
30 {
31   InfTestChat* test;
32 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  char buffer[1024];
33   test = (InfTestChat*)user_data;
34   if(io &amp; INF_IO_ERROR)
35   {
36   }
37   if(io &amp; INF_IO_INCOMING)
38   {
39     if(fgets(buffer, sizeof(buffer), stdin) == NULL)
40     {
41       inf_standalone_io_loop_quit(test-&gt;io);
42     }
43     else if(strlen(buffer) != sizeof(buffer) ||
44             buffer[sizeof(buffer)-2] == '\n')
45     {
46       buffer[strlen(buffer)-1] = '\0';</b></font>
47       if(test-&gt;buffer != NULL &amp;&amp; test-&gt;self != NULL)
48       {
49         inf_chat_buffer_add_message(
50           test-&gt;buffer,
51           test-&gt;self,
52           buffer,
53           strlen(buffer),
54           time(NULL),
55           0
56         );
57       }
58     }
59   }
60 }
61 static void
62 inf_chat_test_buffer_receive_message_cb(InfChatSession* session,
63                                         InfChatBufferMessage* message,
64                                         gpointer user_data)
65 {
66   switch(message-&gt;type)
67   {
68   case INF_CHAT_BUFFER_MESSAGE_NORMAL:
69     printf("&lt;%s&gt; %s\n", inf_user_get_name(message-&gt;user), message-&gt;text);
70     break;
71   case INF_CHAT_BUFFER_MESSAGE_EMOTE:
72     printf(" * %s %s\n", inf_user_get_name(message-&gt;user), message-&gt;text);
73     break;
74   case INF_CHAT_BUFFER_MESSAGE_USERJOIN:
75     printf(" --&gt; %s has joined\n", inf_user_get_name(message-&gt;user));
76     break;
77   case INF_CHAT_BUFFER_MESSAGE_USERPART:
78     printf(" &lt;-- %s has left\n", inf_user_get_name(message-&gt;user));
79     break;
80   }
81 }
82 static void
83 inf_test_chat_userjoin_finished_cb(InfRequest* request,
84                                    const InfRequestResult* result,
85                                    const GError* error,
86                                    gpointer user_data)
87 {
88   InfTestChat* test;
89   InfUser* user;
90   test = (InfTestChat*)user_data;
91   if(error == NULL)
92   {
93     printf("User join complete. Start chatting!\n");
94 #ifndef G_OS_WIN32
95     inf_io_add_watch(
96       INF_IO(test-&gt;io),
97       &amp;test-&gt;input_fd,
98       INF_IO_INCOMING | INF_IO_ERROR,
99       inf_test_chat_input_cb,
100       test,
101       NULL
102     );
103 #endif
104     inf_request_result_get_join_user(result, NULL, &amp;user);
105     test-&gt;self = user;
106   }
107   else
108   {
109     fprintf(stderr, "User join failed: %s\n", error-&gt;message);
110     fprintf(stderr, "Chat will be read-only\n");
111   }
112 }
113 static void
114 inf_chat_test_session_synchronization_complete_cb(InfSession* session,
115                                                   InfXmlConnection* connection,
116                                                   gpointer user_data)
117 {
118   InfTestChat* test;
119   InfcSessionProxy* proxy;
120   InfRequest* request;
121   GParameter params[1] = { { "name", { 0 } } };
122   printf("Synchronization complete, joining user...\n");
123   test = (InfTestChat*)user_data;
124   proxy = infc_browser_get_chat_session(INFC_BROWSER(test-&gt;browser));
125   g_value_init(&amp;params[0].value, G_TYPE_STRING);
126   g_value_set_string(&amp;params[0].value, g_get_user_name());
127   inf_session_proxy_join_user(
128     INF_SESSION_PROXY(proxy),
129     G_N_ELEMENTS(params),
130     params,
131     inf_test_chat_userjoin_finished_cb,
132     test
133   );
134   g_value_unset(&amp;params[0].value);
135 }
136 static void
137 inf_chat_test_session_synchronization_failed_cb(InfSession* session,
138                                                 InfXmlConnection* connection,
139                                                 const GError* error,
140                                                 gpointer user_data)
141 {
142   InfTestChat* test;
143   test = (InfTestChat*)user_data;
144   fprintf(stderr, "Synchronization failed: %s\n", error-&gt;message);
145   inf_standalone_io_loop_quit(test-&gt;io);
146 }
147 static void
148 inf_chat_test_session_close_cb(InfSession* session,
149                                gpointer user_data)
150 {
151   InfTestChat* test;
152   test = (InfTestChat*)user_data;
153   printf("The server closed the chat session\n");
154   if(inf_standalone_io_loop_running(test-&gt;io))
155     inf_standalone_io_loop_quit(test-&gt;io);
156 }
157 static void
158 inf_chat_test_subscribe_finished_cb(InfRequest* request,
159                                     const InfRequestResult* result,
160                                     const GError* error,
161                                     gpointer user_data)
162 {
163   InfTestChat* test;
164   InfcSessionProxy* proxy;
165   InfSession* session;
166   test = (InfTestChat*)user_data;
167   if(error == NULL)
168   {
169     printf("Subscription successful, waiting for synchronization...\n");
170     proxy = infc_browser_get_chat_session(INFC_BROWSER(test-&gt;browser));
171     g_object_get(G_OBJECT(proxy), "session", &amp;session, NULL);
172     test-&gt;buffer = INF_CHAT_BUFFER(inf_session_get_buffer(session));
173     g_signal_connect_after(
174       G_OBJECT(session),
175       "receive-message",
176       G_CALLBACK(inf_chat_test_buffer_receive_message_cb),
177       test
178     );
179     g_signal_connect_after(
180       G_OBJECT(session),
181       "synchronization-complete",
182       G_CALLBACK(inf_chat_test_session_synchronization_complete_cb),
183       test
184     );
185     g_signal_connect_after(
186       G_OBJECT(session),
187       "synchronization-failed",
188       G_CALLBACK(inf_chat_test_session_synchronization_failed_cb),
189       test
190     );
191     g_signal_connect_after(
192       G_OBJECT(session),
193       "close",
194       G_CALLBACK(inf_chat_test_session_close_cb),
195       test
196     );
197     g_object_unref(session);
198   }
199   else
200   {
201     fprintf(stderr, "Subscription failed: %s\n", error-&gt;message);
202     inf_standalone_io_loop_quit(test-&gt;io);
203   }
204 }
205 static void
206 inf_test_chat_notify_status_cb(GObject* object,
207                                GParamSpec* pspec,
208                                gpointer user_data)
209 {
210   InfTestChat* test;
211   InfBrowserStatus status;
212   test = (InfTestChat*)user_data;
213   g_object_get(G_OBJECT(object), "status", &amp;status, NULL);
214   if(status == INF_BROWSER_OPEN)
215   {
216     printf("Connection established, subscribing to chat...\n");
217     infc_browser_subscribe_chat(
218       INFC_BROWSER(test-&gt;browser),
219       inf_chat_test_subscribe_finished_cb,
220       test
221     );
222   }
223   if(status == INF_BROWSER_CLOSED)
224   {
225     printf("Connection closed\n");
226     if(inf_standalone_io_loop_running(test-&gt;io))
227       inf_standalone_io_loop_quit(test-&gt;io);
228   }
229 }
230 static void
231 inf_test_chat_error_cb(InfXmppConnection* xmpp,
232                           GError* error,
233                           gpointer user_data)
234 <a name="2"></a>{
235   fprintf(stderr, "Connection error: %s\n", error-&gt;message);
236 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
237 int
238 main(int argc, char* argv[])
239 {
240   InfTestChat test;
241   InfIpAddress* address;
242   InfCommunicationManager* manager;
243   InfTcpConnection* tcp_conn;
244   GError* error;
245   error = NULL;
246   if(!inf_init(&amp;error))
247   {
248     fprintf(stderr, "%s\n", error-&gt;message);
249     return 1;
250   }
251   test.io = inf_standalone_io_new();
252 #ifndef G_OS_WIN32
253   test.input_fd = STDIN_FILENO;</b></font>
254 <a name="0"></a>#endif
255   test.buffer = NULL;
256 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  address = inf_ip_address_new_loopback4();
257   tcp_conn =
258     inf_tcp_connection_new_and_open(INF_IO(test.io), address, inf_protocol_get_default_port(), &amp;error);
259   inf_ip_address_free(address);
260   if(tcp_conn == NULL)
261   {
262     fprintf(stderr, "Could not open TCP connection: %s\n", error-&gt;message);
263     g_error_free(error);
264   }
265   else
266   {
267     test.conn = inf_xmpp_connection_new(
268       tcp_conn,
269       INF_XMPP_CONNECTION_CLIENT,
270       NULL,
271       "localhost",
272       INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS,
273       NULL,
274       NULL,
275       NULL
276     );
277     g_object_unref(G_OBJECT(tcp_conn));
278     manager = inf_communication_manager_new();
279     test.browser = INF_BROWSER(
280       infc_browser_new(
281         INF_IO(test.io),
282         manager,
283         INF_XML_CONNECTION(test.conn)
284       )
285     );
286     g_signal_connect_after(
287       G_OBJECT(test.browser),
288       "notify::status",
289       G_CALLBACK(inf_test_chat_notify_status_cb),
290       &amp;test
291     );
292     g_signal_connect(
293       G_OBJECT(test.browser),
294       "error",
295       G_CALLBACK(inf_test_chat_error_cb),
296       &amp;test
297     );
298     inf_standalone_io_loop(test.io);
299     g_object_unref(G_OBJECT(manager));
300     g_object_unref(G_OBJECT(test.browser));
301     g_object_unref(G_OBJECT(test.conn));
302   }
303   g_object_unref(G_OBJECT(test.io));
304   return 0;
305 }</b></font>
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-test-browser.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/client/infc-browser.h&gt;
2 #include &lt;libinfinity/communication/inf-communication-manager.h&gt;
3 #include &lt;libinfinity/common/inf-xmpp-connection.h&gt;
4 #include &lt;libinfinity/common/inf-tcp-connection.h&gt;
5 #include &lt;libinfinity/common/inf-ip-address.h&gt;
6 #include &lt;libinfinity/common/inf-standalone-io.h&gt;
7 #include &lt;libinfinity/common/inf-io.h&gt;
8 #include &lt;libinfinity/common/inf-protocol.h&gt;
9 #include &lt;libinfinity/common/inf-init.h&gt;
10 #include &lt;string.h&gt;
11 typedef struct _InfTestBrowser InfTestBrowser;
12 struct _InfTestBrowser {
13   InfStandaloneIo* io;
14   InfXmppConnection* conn;
15   InfBrowser* browser;
16 #ifndef G_OS_WIN32
17   int input_fd;
18 #endif
19   InfBrowserIter cwd;
20 };
21 typedef void(*InfTestBrowserCmdFunc)(InfTestBrowser*, const gchar*);
22 typedef struct _InfTestBrowserCmd InfTestBrowserCmd;
23 struct _InfTestBrowserCmd {
24   const gchar* name;
25   InfTestBrowserCmdFunc func;
26 };
27 static gboolean
28 inf_test_browser_find_node(InfTestBrowser* test,
29                            const gchar* name,
30                            InfBrowserIter* result_iter)
31 {
32   InfBrowserIter iter;
33   gboolean result;
34   if(inf_browser_get_explored(test-&gt;browser, &amp;test-&gt;cwd) == FALSE)
35   {
36     fprintf(
37       stderr,
38       "Directory '%s' not yet explored\n",
39       inf_browser_get_node_name(test-&gt;browser, &amp;test-&gt;cwd)
40     );
41   }
42   else
43   {
44     iter = test-&gt;cwd;
45     for(result = inf_browser_get_child(test-&gt;browser, &amp;iter);
46         result == TRUE;
47         result = inf_browser_get_next(test-&gt;browser, &amp;iter))
48     {
49       if(strcmp(inf_browser_get_node_name(test-&gt;browser, &amp;iter), name) == 0)
50       {
51         *result_iter = iter;
52         return TRUE;
53       }
54     }
55   }
56   return FALSE;
57 }
58 static void
59 inf_test_browser_cmd_ls(InfTestBrowser* test,
60                         const gchar* param)
61 {
62   InfBrowserIter iter;
63   gboolean result;
64   if(inf_browser_get_explored(test-&gt;browser, &amp;test-&gt;cwd) == FALSE)
65   {
66     fprintf(
67       stderr,
68       "Directory '%s' not yet explored\n",
69       inf_browser_get_node_name(test-&gt;browser, &amp;test-&gt;cwd)
70     );
71   }
72   else
73   {
74     iter = test-&gt;cwd;
75     for(result = inf_browser_get_child(test-&gt;browser, &amp;iter);
76         result == TRUE;
77         result = inf_browser_get_next(test-&gt;browser, &amp;iter))
78     {
79       printf("%s\n", inf_browser_get_node_name(test-&gt;browser, &amp;iter));
80     }
81   }
82 }
83 static void
84 inf_test_browser_cmd_cd(InfTestBrowser* test,
85                         const gchar* param)
86 {
87   InfBrowserIter iter;
88   if(strcmp(param, "..") == 0)
89   {
90     iter = test-&gt;cwd;
91     if(inf_browser_get_parent(test-&gt;browser, &amp;iter) == FALSE)
92     {
93       fprintf(stderr, "Already at the root directory\n");
94     }
95     else
96     {
97       test-&gt;cwd = iter;
98     }
99   }
100   else if(inf_test_browser_find_node(test, param, &amp;iter) == FALSE)
101   {
102     fprintf(
103       stderr,
104       "Directory '%s' does not exist\n",
105       param
106     );
107   }
108   else if(inf_browser_get_explored(test-&gt;browser, &amp;iter) == FALSE)
109   {
110     fprintf(
111       stderr,
112       "Directory '%s' not yet explored\n",
113       inf_browser_get_node_name(test-&gt;browser, &amp;iter)
114     );
115   }
116   else
117   {
118     test-&gt;cwd = iter;
119   }
120 }
121 static void
122 inf_test_browser_cmd_explore(InfTestBrowser* test,
123                              const gchar* param)
124 {
125   InfBrowserIter iter;
126   if(inf_test_browser_find_node(test, param, &amp;iter) == FALSE)
127   {
128     fprintf(
129       stderr,
130       "Directory '%s' does not exist\n",
131       param
132     );
133   }
134   else if(inf_browser_get_explored(test-&gt;browser, &amp;iter) == TRUE)
135   {
136     fprintf(
137       stderr,
138       "Directory '%s' is already explored",
139       inf_browser_get_node_name(test-&gt;browser, &amp;iter)
140     );
141   }
142   else
143   {
144     inf_browser_explore(test-&gt;browser, &amp;iter, NULL, NULL);
145   }
146 }
147 static void
148 inf_test_browser_cmd_create(InfTestBrowser* test,
149                             const gchar* param)
150 {
151   inf_browser_add_subdirectory(
152     test-&gt;browser,
153     &amp;test-&gt;cwd,
154     param,
155     NULL,
156     NULL,
157     NULL
158   );
159 }
160 static void
161 inf_test_browser_cmd_remove(InfTestBrowser* test,
162                             const gchar* param)
163 {
164   InfBrowserIter iter;
165   if(inf_test_browser_find_node(test, param, &amp;iter) == FALSE)
166   {
167     fprintf(
168       stderr,
169       "Directory '%s' does not exist\n",
170       param
171     );
172   }
173   else
174   {
175     inf_browser_remove_node(test-&gt;browser, &amp;iter, NULL, NULL);
176   }
177 }
178 static const InfTestBrowserCmd inf_test_browser_commands[] = {
179   { "ls", inf_test_browser_cmd_ls },
180   { "cd", inf_test_browser_cmd_cd },
181   { "explore", inf_test_browser_cmd_explore },
182   { "create", inf_test_browser_cmd_create },
183   { "remove", inf_test_browser_cmd_remove }
184 };
185 static void
186 inf_test_browser_input_cb(InfNativeSocket* fd,
187                           InfIoEvent io,
188                           gpointer user_data)
189 <a name="1"></a>{
190   InfTestBrowser* test;
191   char buffer[1024];
192 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  char* occ;
193   guint i;
194   test = (InfTestBrowser*)user_data;
195   if(io &amp; INF_IO_ERROR)
196   {
197   }
198   if(io &amp; INF_IO_INCOMING)
199   {
200     if(fgets(buffer, sizeof(buffer), stdin) == NULL)
201     {
202       inf_standalone_io_loop_quit(test-&gt;io);
203     }
204     else if(strlen(buffer) != sizeof(buffer) ||
205             buffer[sizeof(buffer)-2] == '\n')
206     {
207       buffer[strlen(buffer)-1] = '\0';</b></font>
208       occ = strchr(buffer, ' ');
209       if(occ != NULL)
210       {
211         *occ = '\0';
212         ++ occ;
213       }
214       for(i = 0; i &lt; G_N_ELEMENTS(inf_test_browser_commands); ++ i)
215       {
216         if(strcmp(inf_test_browser_commands[i].name, buffer) == 0)
217         {
218           inf_test_browser_commands[i].func(test, occ);
219           break;
220         }
221       }
222       if(i == G_N_ELEMENTS(inf_test_browser_commands))
223       {
224         fprintf(stderr, "'%s': Command not found\n", buffer);
225       }
226     }
227   }
228 }
229 static void
230 inf_test_browser_error_cb(InfcBrowser* browser,
231                           GError* error,
232                           gpointer user_data)
233 {
234   fprintf(stderr, "Connection error: %s\n", error-&gt;message);
235 }
236 static void
237 inf_test_browser_notify_status_cb(GObject* object,
238                                   GParamSpec* pspec,
239                                   gpointer user_data)
240 {
241   InfTestBrowser* test;
242   InfBrowserStatus status;
243   test = (InfTestBrowser*)user_data;
244   g_object_get(G_OBJECT(test-&gt;browser), "status", &amp;status, NULL);
245   if(status == INF_BROWSER_OPEN)
246   {
247     printf("Connection established\n");
248 #ifndef G_OS_WIN32
249     inf_io_add_watch(
250       INF_IO(test-&gt;io),
251       &amp;test-&gt;input_fd,
252       INF_IO_INCOMING | INF_IO_ERROR,
253       inf_test_browser_input_cb,
254       test,
255       NULL
256     );
257 #endif
258     inf_browser_get_root(test-&gt;browser, &amp;test-&gt;cwd);
259     inf_browser_explore(test-&gt;browser, &amp;test-&gt;cwd, NULL, NULL);
260   }
261   if(status == INF_BROWSER_CLOSED)
262   {
263 <a name="2"></a>    if(inf_standalone_io_loop_running(test-&gt;io))
264       inf_standalone_io_loop_quit(test-&gt;io);
265   }
266 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
267 int
268 main(int argc, char* argv[])
269 {
270   InfTestBrowser test;
271   InfIpAddress* address;
272   InfCommunicationManager* manager;
273   InfTcpConnection* tcp_conn;
274   GError* error;
275   error = NULL;
276   if(!inf_init(&amp;error))
277   {
278     fprintf(stderr, "%s\n", error-&gt;message);
279     return 1;
280   }
281   test.io = inf_standalone_io_new();
282 <a name="0"></a>#ifndef G_OS_WIN32
283   test.input_fd = STDIN_FILENO;</b></font>
284 #endif
285 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  address = inf_ip_address_new_loopback4();
286   tcp_conn =
287     inf_tcp_connection_new_and_open(INF_IO(test.io), address, inf_protocol_get_default_port(), &amp;error);
288   inf_ip_address_free(address);
289   if(tcp_conn == NULL)
290   {
291     fprintf(stderr, "Could not open TCP connection: %s\n", error-&gt;message);
292     g_error_free(error);
293   }
294   else
295   {
296     test.conn = inf_xmpp_connection_new(
297       tcp_conn,
298       INF_XMPP_CONNECTION_CLIENT,
299       NULL,
300       "localhost",
301       INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS,
302       NULL,
303       NULL,
304       NULL
305     );
306     g_object_unref(G_OBJECT(tcp_conn));
307     manager = inf_communication_manager_new();
308     test.browser = INF_BROWSER(
309       infc_browser_new(
310         INF_IO(test.io),
311         manager,
312         INF_XML_CONNECTION(test.conn)
313       )
314     );
315     g_signal_connect_after(
316       G_OBJECT(test.browser),
317       "notify::status",
318       G_CALLBACK(inf_test_browser_notify_status_cb),
319       &amp;test
320     );
321     g_signal_connect(
322       G_OBJECT(test.browser),
323       "error",
324       G_CALLBACK(inf_test_browser_error_cb),
325       &amp;test
326     );
327     inf_standalone_io_loop(test.io);
328     g_object_unref(G_OBJECT(manager));
329     g_object_unref(G_OBJECT(test.browser));
330     g_object_unref(G_OBJECT(test.conn));
331   }
332   g_object_unref(G_OBJECT(test.io));
333   return 0;
334 }</b></font>
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
