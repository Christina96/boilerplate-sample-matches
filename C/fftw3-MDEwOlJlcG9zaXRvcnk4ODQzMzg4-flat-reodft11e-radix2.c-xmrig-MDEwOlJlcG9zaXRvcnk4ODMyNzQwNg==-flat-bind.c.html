
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.8257456828885403%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-reodft11e-radix2.c</h3>
            <pre><code>1  #include "reodft/reodft.h"
2  typedef struct {
3       solver super;
4  } S;
5  typedef struct {
6       plan_rdft super;
7       plan *cld;
8       twid *td, *td2;
9       INT is, os;
10       INT n;
11       INT vl;
12       INT ivs, ovs;
13       rdft_kind kind;
14  } P;
15  static void apply_re11(const plan *ego_, R *I, R *O)
16  {
17       const P *ego = (const P *) ego_;
18       INT is = ego->is, os = ego->os;
19       INT i, n = ego->n, n2 = n/2;
20       INT iv, vl = ego->vl;
21       INT ivs = ego->ivs, ovs = ego->ovs;
22       R *W = ego->td->W;
23       R *W2;
24       R *buf;
25       buf = (R *) MALLOC(sizeof(R) * n, BUFFERS);
26       for (iv = 0; iv < vl; ++iv, I += ivs, O += ovs) {
27  	  buf[0] = K(2.0) * I[0];
28  	  buf[n2] = K(2.0) * I[is * (n - 1)];
29  	  for (i = 1; i + i < n2; ++i) {
30  	       INT k = i + i;
31  	       E a, b, a2, b2;
32  	       {
33  		    E u, v;
34  		    u = I[is * (k - 1)];
35  		    v = I[is * k];
36  		    a = u + v;
37  		    b2 = u - v;
38  	       }
39  	       {
40  		    E u, v;
41  		    u = I[is * (n - k - 1)];
42  		    v = I[is * (n - k)];
43  		    b = u + v;
44  		    a2 = u - v;
45  	       }
46  	       {
47  		    E wa, wb;
48  		    wa = W[2*i];
49  		    wb = W[2*i + 1];
50  		    {
51  			 E apb, amb;
52  			 apb = a + b;
53  			 amb = a - b;
54  			 buf[i] = wa * amb + wb * apb; 
55  			 buf[n2 - i] = wa * apb - wb * amb; 
56  		    }
57  		    {
58  			 E apb, amb;
59  			 apb = a2 + b2;
60  			 amb = a2 - b2;
61  			 buf[n2 + i] = wa * amb + wb * apb; 
62  			 buf[n - i] = wa * apb - wb * amb; 
63  		    }
64  	       }
65  	  }
66  	  if (i + i == n2) {
67  	       E u, v;
68  	       u = I[is * (n2 - 1)];
69  	       v = I[is * n2];
70  	       buf[i] = (u + v) * (W[2*i] * K(2.0));
71  	       buf[n - i] = (u - v) * (W[2*i] * K(2.0));
72  	  }
73  	  {
74  	       plan_rdft *cld = (plan_rdft *) ego->cld;
75  	       cld->apply((plan *) cld, buf, buf);
76  	  }
77  	  W2 = ego->td2->W;
78  	  { &bsol;* i == 0 case */
79  	       E wa, wb;
80  	       E a, b;
81  	       wa = W2[0]; &bsol;* cos */
82  	       wb = W2[1]; &bsol;* sin */
83  	       a = buf[0];
84  	       b = buf[n2];
85  	       O[0] = wa * a + wb * b;
86  	       O[os * (n - 1)] = wb * a - wa * b;
87  	  }
88  	  W2 += 2;
89  	  for (i = 1; i + i < n2; ++i, W2 += 2) {
90  	       INT k;
91  	       E u, v, u2, v2;
92  	       u = buf[i];
93  	       v = buf[n2 - i];
94  	       u2 = buf[n2 + i];
95  	       v2 = buf[n - i];
96  	       k = (i + i) - 1;
97  	       {
98                      E wa, wb;
99                      E a, b;
100                      wa = W2[0]; &bsol;* cos */
101                      wb = W2[1]; &bsol;* sin */
102                      a = u - v;
103                      b = v2 - u2;
104                      O[os * k] = wa * a + wb * b;
105                      O[os * (n - 1 - k)] = wb * a - wa * b;
106                 }
107  	       ++k;
108  	       W2 += 2;
109  	       {
110  		    E wa, wb;
111  		    E a, b;
112  		    wa = W2[0]; &bsol;* cos */
113  		    wb = W2[1]; &bsol;* sin */
114  		    a = u + v;
115  		    b = u2 + v2;
116  		    O[os * k] = wa * a + wb * b;
117  		    O[os * (n - 1 - k)] = wb * a - wa * b;
118  	       }
119  	  }
120  	  if (i + i == n2) {
121  	       INT k = (i + i) - 1;
122  	       E wa, wb;
123  	       E a, b;
124  	       wa = W2[0]; &bsol;* cos */
125  	       wb = W2[1]; &bsol;* sin */
126  	       a = buf[i];
127  	       b = buf[n2 + i];
128  	       O[os * k] = wa * a - wb * b;
129  	       O[os * (n - 1 - k)] = wb * a + wa * b;
130  	  }
131       }
132       X(ifree)(buf);
133  }
134  #if 0
135  static void apply_re11(const plan *ego_, R *I, R *O)
136  {
137       const P *ego = (const P *) ego_;
138       INT is = ego->is, os = ego->os;
139       INT i, n = ego->n;
140       INT iv, vl = ego->vl;
141       INT ivs = ego->ivs, ovs = ego->ovs;
142       R *W;
143       R *buf;
144       buf = (R *) MALLOC(sizeof(R) * n, BUFFERS);
145       for (iv = 0; iv < vl; ++iv, I += ivs, O += ovs) {
146  	  buf[0] = K(2.0) * I[0];
147  	  buf[n/2] = K(2.0) * I[is * (n - 1)];
148  	  for (i = 1; i + i < n; ++i) {
149  	       INT k = i + i;
150  	       E a, b;
151  	       a = I[is * (k - 1)];
152  	       b = I[is * k];
153  	       buf[i] = a + b;
154  	       buf[n - i] = a - b;
155  	  }
156  	  {
157  	       plan_rdft *cld = (plan_rdft *) ego->cld;
158  	       cld->apply((plan *) cld, buf, buf);
159  	  }
160  	  W = ego->td2->W;
161  	  for (i = 0; i + 1 < n/2; ++i, W += 2) {
162  	       {
163  		    E wa, wb;
164  		    E a, b;
165  		    wa = W[0]; &bsol;* cos */
166  		    wb = W[1]; &bsol;* sin */
167  		    a = buf[i];
168  		    b = buf[n/2 + i];
169  		    O[os * i] = wa * a + wb * b;
170  		    O[os * (n - 1 - i)] = wb * a - wa * b;
171  	       }
172  	       ++i;
173  	       W += 2;
174  	       {
175                      E wa, wb;
176                      E a, b;
177                      wa = W[0]; &bsol;* cos */
178                      wb = W[1]; &bsol;* sin */
179                      a = buf[i];
180                      b = buf[n/2 + i];
181                      O[os * i] = wa * a - wb * b;
182                      O[os * (n - 1 - i)] = wb * a + wa * b;
183                 }
184  	  }
185  	  if (i < n/2) {
186  	       E wa, wb;
187  	       E a, b;
188  	       wa = W[0]; &bsol;* cos */
189  	       wb = W[1]; &bsol;* sin */
190  	       a = buf[i];
191  	       b = buf[n/2 + i];
192  	       O[os * i] = wa * a + wb * b;
193  	       O[os * (n - 1 - i)] = wb * a - wa * b;
194  	  }
195       }
196       X(ifree)(buf);
197  }
198  #endif &bsol;* 0 */
199  static void apply_ro11(const plan *ego_, R *I, R *O)
200  {
201       const P *ego = (const P *) ego_;
202       INT is = ego->is, os = ego->os;
203       INT i, n = ego->n, n2 = n/2;
204       INT iv, vl = ego->vl;
205       INT ivs = ego->ivs, ovs = ego->ovs;
206       R *W = ego->td->W;
207       R *W2;
208       R *buf;
209       buf = (R *) MALLOC(sizeof(R) * n, BUFFERS);
210       for (iv = 0; iv < vl; ++iv, I += ivs, O += ovs) {
211  	  buf[0] = K(2.0) * I[is * (n - 1)];
212  	  buf[n2] = K(2.0) * I[0];
213  	  for (i = 1; i + i < n2; ++i) {
214  	       INT k = i + i;
215  	       E a, b, a2, b2;
216  	       {
217  		    E u, v;
218  		    u = I[is * (n - k)];
219  		    v = I[is * (n - 1 - k)];
220  		    a = u + v;
221  		    b2 = u - v;
222  	       }
223  	       {
224  		    E u, v;
225  		    u = I[is * (k)];
226  		    v = I[is * (k - 1)];
227  		    b = u + v;
228  		    a2 = u - v;
229  	       }
230  	       {
231  		    E wa, wb;
232  		    wa = W[2*i];
233  		    wb = W[2*i + 1];
234  		    {
235  			 E apb, amb;
236  			 apb = a + b;
237  			 amb = a - b;
238  			 buf[i] = wa * amb + wb * apb; 
239  			 buf[n2 - i] = wa * apb - wb * amb; 
240  		    }
241  		    {
242  			 E apb, amb;
243  			 apb = a2 + b2;
244  			 amb = a2 - b2;
245  			 buf[n2 + i] = wa * amb + wb * apb; 
246  			 buf[n - i] = wa * apb - wb * amb; 
247  		    }
248  	       }
249  	  }
250  	  if (i + i == n2) {
251  	       E u, v;
252  	       u = I[is * n2];
253  	       v = I[is * (n2 - 1)];
254  	       buf[i] = (u + v) * (W[2*i] * K(2.0));
255  	       buf[n - i] = (u - v) * (W[2*i] * K(2.0));
256  	  }
257  	  {
258  	       plan_rdft *cld = (plan_rdft *) ego->cld;
259  	       cld->apply((plan *) cld, buf, buf);
260  	  }
261  	  W2 = ego->td2->W;
262  	  { &bsol;* i == 0 case */
263  	       E wa, wb;
264  	       E a, b;
265  	       wa = W2[0]; &bsol;* cos */
266  	       wb = W2[1]; &bsol;* sin */
267  	       a = buf[0];
268  	       b = buf[n2];
269  	       O[0] = wa * a + wb * b;
270  	       O[os * (n - 1)] = wa * b - wb * a;
271  	  }
272  	  W2 += 2;
273  	  for (i = 1; i + i < n2; ++i, W2 += 2) {
274  	       INT k;
275  	       E u, v, u2, v2;
276  	       u = buf[i];
277  	       v = buf[n2 - i];
278  	       u2 = buf[n2 + i];
279  	       v2 = buf[n - i];
280  	       k = (i + i) - 1;
281  	       {
282                      E wa, wb;
283                      E a, b;
284                      wa = W2[0]; &bsol;* cos */
285                      wb = W2[1]; &bsol;* sin */
286                      a = v - u;
287                      b = u2 - v2;
288                      O[os * k] = wa * a + wb * b;
289                      O[os * (n - 1 - k)] = wa * b - wb * a;
290                 }
291  	       ++k;
292  	       W2 += 2;
293  	       {
294  		    E wa, wb;
295  		    E a, b;
296  		    wa = W2[0]; &bsol;* cos */
297  		    wb = W2[1]; &bsol;* sin */
298  		    a = u + v;
299  		    b = u2 + v2;
300  		    O[os * k] = wa * a + wb * b;
301  		    O[os * (n - 1 - k)] = wa * b - wb * a;
302  	       }
303  	  }
304  	  if (i + i == n2) {
305  	       INT k = (i + i) - 1;
306  	       E wa, wb;
307  	       E a, b;
308  	       wa = W2[0]; &bsol;* cos */
309  	       wb = W2[1]; &bsol;* sin */
310  	       a = buf[i];
311  	       b = buf[n2 + i];
312  	       O[os * k] = wb * b - wa * a;
313  	       O[os * (n - 1 - k)] = wa * b + wb * a;
314  	  }
315       }
316       X(ifree)(buf);
317  }
318  static void awake(plan *ego_, enum wakefulness wakefulness)
319  {
320       P *ego = (P *) ego_;
321       static const tw_instr reodft010e_tw[] = {
322            { TW_COS, 0, 1 },
323            { TW_SIN, 0, 1 },
324            { TW_NEXT, 1, 0 }
325       };
326       static const tw_instr reodft11e_tw[] = {
327            { TW_COS, 1, 1 },
328            { TW_SIN, 1, 1 },
329            { TW_NEXT, 2, 0 }
330       };
331       X(plan_awake)(ego->cld, wakefulness);
332       X(twiddle_awake)(wakefulness, &ego->td, reodft010e_tw, 
333  		      2*ego->n, 1, ego->n/4+1);
334       X(twiddle_awake)(wakefulness, &ego->td2, reodft11e_tw, 
335  		      8*ego->n, 1, ego->n);
336  }
337  static void destroy(plan *ego_)
338  {
339       P *ego = (P *) ego_;
340       X(plan_destroy_internal)(ego->cld);
341  }
342  static void print(const plan *ego_, printer *p)
343  {
344       const P *ego = (const P *) ego_;
345       p->print(p, "(%se-radix2-r2hc-%D%v%(%p%))",
346  	      X(rdft_kind_str)(ego->kind), ego->n, ego->vl, ego->cld);
347  }
348  static int applicable0(const solver *ego_, const problem *p_)
349  {
350       const problem_rdft *p = (const problem_rdft *) p_;
351       UNUSED(ego_);
352       return (1
353  	     && p->sz->rnk == 1
354  	     && p->vecsz->rnk <= 1
355  	     && p->sz->dims[0].n % 2 == 0
356  	     && (p->kind[0] == REDFT11 || p->kind[0] == RODFT11)
357  	  );
358  }
359  static int applicable(const solver *ego, const problem *p, const planner *plnr)
360  {
361       return (!NO_SLOWP(plnr) && applicable0(ego, p));
362  }
363  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
364  {
365       P *pln;
366       const problem_rdft *p;
367       plan *cld;
368       R *buf;
369       INT n;
370       opcnt ops;
371       static const plan_adt padt = {
372  	  X(rdft_solve), awake, print, destroy
373       };
374       if (!applicable(ego_, p_, plnr))
375            return (plan *)0;
376       p = (const problem_rdft *) p_;
377       n = p->sz->dims[0].n;
378       buf = (R *) MALLOC(sizeof(R) * n, BUFFERS);
379       cld = X(mkplan_d)(plnr, X(mkproblem_rdft_1_d)(X(mktensor_1d)(n/2, 1, 1),
380                                                     X(mktensor_1d)(2, n/2, n/2),
381                                                     buf, buf, R2HC));
382       X(ifree)(buf);
383       if (!cld)
384            return (plan *)0;
385       pln = MKPLAN_RDFT(P, &padt, p->kind[0]==REDFT11 ? apply_re11:apply_ro11);
<span onclick='openModal()' class='match'>386       pln->n = n;
387       pln->is = p->sz->dims[0].is;
388       pln->os = p->sz->dims[0].os;
389       pln->cld = cld;
390       pln->td = pln->td2 = 0;
391       pln->kind = p->kind[0];
392       X(tensor_tornk1)(p->vecsz, &pln->vl, &pln->ivs, &pln->ovs);
393       X(ops_zero)(&ops);
394       ops.add = 2 + (n/2 - 1)/2 * 20;
395       ops.mul = 6 + (n/2 - 1)/2 * 16;
396       ops.other = 4*n + 2 + (n/2 - 1)/2 * 6;
</span>397       if ((n/2) % 2 == 0) {
398  	  ops.add += 4;
399  	  ops.mul += 8;
400  	  ops.other += 4;
401       }
402       X(ops_zero)(&pln->super.super.ops);
403       X(ops_madd2)(pln->vl, &ops, &pln->super.super.ops);
404       X(ops_madd2)(pln->vl, &cld->ops, &pln->super.super.ops);
405       return &(pln->super.super);
406  }
407  static solver *mksolver(void)
408  {
409       static const solver_adt sadt = { PROBLEM_RDFT, mkplan, 0 };
410       S *slv = MKSOLVER(S, &sadt);
411       return &(slv->super);
412  }
413  void X(reodft11e_radix2_r2hc_register)(planner *p)
414  {
415       REGISTER_SOLVER(p, mksolver());
416  }
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-bind.c</h3>
            <pre><code>1  #include "private/autogen/config.h"
2  #include "hwloc.h"
3  #include "private/private.h"
4  #include "hwloc/helper.h"
5  #ifdef HAVE_SYS_MMAN_H
6  #  include <sys/mman.h>
7  #endif
8  #if defined(hwloc_getpagesize) && !defined(HAVE_POSIX_MEMALIGN) && defined(HAVE_MEMALIGN) && defined(HAVE_MALLOC_H)
9  #include <malloc.h>
10  #endif
11  #ifdef HAVE_UNISTD_H
12  #include <unistd.h>
13  #endif
14  #include <stdlib.h>
15  #include <errno.h>
16  #define HWLOC_CPUBIND_ALLFLAGS (HWLOC_CPUBIND_PROCESS|HWLOC_CPUBIND_THREAD|HWLOC_CPUBIND_STRICT|HWLOC_CPUBIND_NOMEMBIND)
17  static hwloc_const_bitmap_t
18  hwloc_fix_cpubind(hwloc_topology_t topology, hwloc_const_bitmap_t set)
19  {
20    hwloc_const_bitmap_t topology_set = hwloc_topology_get_topology_cpuset(topology);
21    hwloc_const_bitmap_t complete_set = hwloc_topology_get_complete_cpuset(topology);
22    if (hwloc_bitmap_iszero(set)) {
23      errno = EINVAL;
24      return NULL;
25    }
26    if (!hwloc_bitmap_isincluded(set, complete_set)) {
27      errno = EINVAL;
28      return NULL;
29    }
30    if (hwloc_bitmap_isincluded(topology_set, set))
31      set = complete_set;
32    return set;
33  }
34  int
35  hwloc_set_cpubind(hwloc_topology_t topology, hwloc_const_bitmap_t set, int flags)
36  {
37    if (flags & ~HWLOC_CPUBIND_ALLFLAGS) {
38      errno = EINVAL;
39      return -1;
40    }
41    set = hwloc_fix_cpubind(topology, set);
42    if (!set)
43      return -1;
44    if (flags & HWLOC_CPUBIND_PROCESS) {
45      if (topology->binding_hooks.set_thisproc_cpubind)
46        return topology->binding_hooks.set_thisproc_cpubind(topology, set, flags);
47    } else if (flags & HWLOC_CPUBIND_THREAD) {
48      if (topology->binding_hooks.set_thisthread_cpubind)
49        return topology->binding_hooks.set_thisthread_cpubind(topology, set, flags);
50    } else {
51      if (topology->binding_hooks.set_thisproc_cpubind) {
52        int err = topology->binding_hooks.set_thisproc_cpubind(topology, set, flags);
53        if (err >= 0 || errno != ENOSYS)
54          return err;
55      }
56      if (topology->binding_hooks.set_thisthread_cpubind)
57        return topology->binding_hooks.set_thisthread_cpubind(topology, set, flags);
58    }
59    errno = ENOSYS;
60    return -1;
61  }
62  int
63  hwloc_get_cpubind(hwloc_topology_t topology, hwloc_bitmap_t set, int flags)
64  {
65    if (flags & ~HWLOC_CPUBIND_ALLFLAGS) {
66      errno = EINVAL;
67      return -1;
68    }
69    if (flags & HWLOC_CPUBIND_PROCESS) {
70      if (topology->binding_hooks.get_thisproc_cpubind)
71        return topology->binding_hooks.get_thisproc_cpubind(topology, set, flags);
72    } else if (flags & HWLOC_CPUBIND_THREAD) {
73      if (topology->binding_hooks.get_thisthread_cpubind)
74        return topology->binding_hooks.get_thisthread_cpubind(topology, set, flags);
75    } else {
76      if (topology->binding_hooks.get_thisproc_cpubind) {
77        int err = topology->binding_hooks.get_thisproc_cpubind(topology, set, flags);
78        if (err >= 0 || errno != ENOSYS)
79          return err;
80      }
81      if (topology->binding_hooks.get_thisthread_cpubind)
82        return topology->binding_hooks.get_thisthread_cpubind(topology, set, flags);
83    }
84    errno = ENOSYS;
85    return -1;
86  }
87  int
88  hwloc_set_proc_cpubind(hwloc_topology_t topology, hwloc_pid_t pid, hwloc_const_bitmap_t set, int flags)
89  {
90    if (flags & ~HWLOC_CPUBIND_ALLFLAGS) {
91      errno = EINVAL;
92      return -1;
93    }
94    set = hwloc_fix_cpubind(topology, set);
95    if (!set)
96      return -1;
97    if (topology->binding_hooks.set_proc_cpubind)
98      return topology->binding_hooks.set_proc_cpubind(topology, pid, set, flags);
99    errno = ENOSYS;
100    return -1;
101  }
102  int
103  hwloc_get_proc_cpubind(hwloc_topology_t topology, hwloc_pid_t pid, hwloc_bitmap_t set, int flags)
104  {
105    if (flags & ~HWLOC_CPUBIND_ALLFLAGS) {
106      errno = EINVAL;
107      return -1;
108    }
109    if (topology->binding_hooks.get_proc_cpubind)
110      return topology->binding_hooks.get_proc_cpubind(topology, pid, set, flags);
111    errno = ENOSYS;
112    return -1;
113  }
114  #ifdef hwloc_thread_t
115  int
116  hwloc_set_thread_cpubind(hwloc_topology_t topology, hwloc_thread_t tid, hwloc_const_bitmap_t set, int flags)
117  {
118    if (flags & ~HWLOC_CPUBIND_ALLFLAGS) {
119      errno = EINVAL;
120      return -1;
121    }
122    set = hwloc_fix_cpubind(topology, set);
123    if (!set)
124      return -1;
125    if (topology->binding_hooks.set_thread_cpubind)
126      return topology->binding_hooks.set_thread_cpubind(topology, tid, set, flags);
127    errno = ENOSYS;
128    return -1;
129  }
130  int
131  hwloc_get_thread_cpubind(hwloc_topology_t topology, hwloc_thread_t tid, hwloc_bitmap_t set, int flags)
132  {
133    if (flags & ~HWLOC_CPUBIND_ALLFLAGS) {
134      errno = EINVAL;
135      return -1;
136    }
137    if (topology->binding_hooks.get_thread_cpubind)
138      return topology->binding_hooks.get_thread_cpubind(topology, tid, set, flags);
139    errno = ENOSYS;
140    return -1;
141  }
142  #endif
143  int
144  hwloc_get_last_cpu_location(hwloc_topology_t topology, hwloc_bitmap_t set, int flags)
145  {
146    if (flags & ~HWLOC_CPUBIND_ALLFLAGS) {
147      errno = EINVAL;
148      return -1;
149    }
150    if (flags & HWLOC_CPUBIND_PROCESS) {
151      if (topology->binding_hooks.get_thisproc_last_cpu_location)
152        return topology->binding_hooks.get_thisproc_last_cpu_location(topology, set, flags);
153    } else if (flags & HWLOC_CPUBIND_THREAD) {
154      if (topology->binding_hooks.get_thisthread_last_cpu_location)
155        return topology->binding_hooks.get_thisthread_last_cpu_location(topology, set, flags);
156    } else {
157      if (topology->binding_hooks.get_thisproc_last_cpu_location) {
158        int err = topology->binding_hooks.get_thisproc_last_cpu_location(topology, set, flags);
159        if (err >= 0 || errno != ENOSYS)
160          return err;
161      }
162      if (topology->binding_hooks.get_thisthread_last_cpu_location)
163        return topology->binding_hooks.get_thisthread_last_cpu_location(topology, set, flags);
164    }
165    errno = ENOSYS;
166    return -1;
167  }
168  int
169  hwloc_get_proc_last_cpu_location(hwloc_topology_t topology, hwloc_pid_t pid, hwloc_bitmap_t set, int flags)
170  {
171    if (flags & ~HWLOC_CPUBIND_ALLFLAGS) {
172      errno = EINVAL;
173      return -1;
174    }
175    if (topology->binding_hooks.get_proc_last_cpu_location)
176      return topology->binding_hooks.get_proc_last_cpu_location(topology, pid, set, flags);
177    errno = ENOSYS;
178    return -1;
179  }
180  #define HWLOC_MEMBIND_ALLFLAGS (HWLOC_MEMBIND_PROCESS|HWLOC_MEMBIND_THREAD|HWLOC_MEMBIND_STRICT|HWLOC_MEMBIND_MIGRATE|HWLOC_MEMBIND_NOCPUBIND|HWLOC_MEMBIND_BYNODESET)
181  static hwloc_const_nodeset_t
182  hwloc_fix_membind(hwloc_topology_t topology, hwloc_const_nodeset_t nodeset)
183  {
184    hwloc_const_bitmap_t topology_nodeset = hwloc_topology_get_topology_nodeset(topology);
185    hwloc_const_bitmap_t complete_nodeset = hwloc_topology_get_complete_nodeset(topology);
186    if (hwloc_bitmap_iszero(nodeset)) {
187      errno = EINVAL;
188      return NULL;
189    }
190    if (!hwloc_bitmap_isincluded(nodeset, complete_nodeset)) {
191      errno = EINVAL;
192      return NULL;
193    }
194    if (hwloc_bitmap_isincluded(topology_nodeset, nodeset))
195      return complete_nodeset;
196    return nodeset;
197  }
198  static int
199  hwloc_fix_membind_cpuset(hwloc_topology_t topology, hwloc_nodeset_t nodeset, hwloc_const_cpuset_t cpuset)
200  {
201    hwloc_const_bitmap_t topology_set = hwloc_topology_get_topology_cpuset(topology);
202    hwloc_const_bitmap_t complete_set = hwloc_topology_get_complete_cpuset(topology);
203    hwloc_const_bitmap_t complete_nodeset = hwloc_topology_get_complete_nodeset(topology);
204    if (hwloc_bitmap_iszero(cpuset)) {
205      errno = EINVAL;
206      return -1;
207    }
208    if (!hwloc_bitmap_isincluded(cpuset, complete_set)) {
209      errno = EINVAL;
210      return -1;
211    }
212    if (hwloc_bitmap_isincluded(topology_set, cpuset)) {
213      hwloc_bitmap_copy(nodeset, complete_nodeset);
214      return 0;
215    }
216    hwloc_cpuset_to_nodeset(topology, cpuset, nodeset);
217    return 0;
218  }
219  static __hwloc_inline int hwloc__check_membind_policy(hwloc_membind_policy_t policy)
220  {
221    if (policy == HWLOC_MEMBIND_DEFAULT
222        || policy == HWLOC_MEMBIND_FIRSTTOUCH
223        || policy == HWLOC_MEMBIND_BIND
224        || policy == HWLOC_MEMBIND_INTERLEAVE
225        || policy == HWLOC_MEMBIND_NEXTTOUCH)
226      return 0;
227    return -1;
228  }
229  static int
230  hwloc_set_membind_by_nodeset(hwloc_topology_t topology, hwloc_const_nodeset_t nodeset, hwloc_membind_policy_t policy, int flags)
231  {
232    if ((flags & ~HWLOC_MEMBIND_ALLFLAGS) || hwloc__check_membind_policy(policy) < 0) {
233      errno = EINVAL;
234      return -1;
235    }
236    nodeset = hwloc_fix_membind(topology, nodeset);
237    if (!nodeset)
238      return -1;
239    if (flags & HWLOC_MEMBIND_PROCESS) {
240      if (topology->binding_hooks.set_thisproc_membind)
241        return topology->binding_hooks.set_thisproc_membind(topology, nodeset, policy, flags);
242    } else if (flags & HWLOC_MEMBIND_THREAD) {
243      if (topology->binding_hooks.set_thisthread_membind)
244        return topology->binding_hooks.set_thisthread_membind(topology, nodeset, policy, flags);
245    } else {
246      if (topology->binding_hooks.set_thisproc_membind) {
247        int err = topology->binding_hooks.set_thisproc_membind(topology, nodeset, policy, flags);
248        if (err >= 0 || errno != ENOSYS)
249          return err;
250      }
251      if (topology->binding_hooks.set_thisthread_membind)
252        return topology->binding_hooks.set_thisthread_membind(topology, nodeset, policy, flags);
253    }
254    errno = ENOSYS;
255    return -1;
256  }
257  int
258  hwloc_set_membind(hwloc_topology_t topology, hwloc_const_bitmap_t set, hwloc_membind_policy_t policy, int flags)
259  {
260    int ret;
261    if (flags & HWLOC_MEMBIND_BYNODESET) {
262      ret = hwloc_set_membind_by_nodeset(topology, set, policy, flags);
263    } else {
264      hwloc_nodeset_t nodeset = hwloc_bitmap_alloc();
265      if (hwloc_fix_membind_cpuset(topology, nodeset, set))
266        ret = -1;
267      else
268        ret = hwloc_set_membind_by_nodeset(topology, nodeset, policy, flags);
269      hwloc_bitmap_free(nodeset);
270    }
271    return ret;
272  }
273  static int
274  hwloc_get_membind_by_nodeset(hwloc_topology_t topology, hwloc_nodeset_t nodeset, hwloc_membind_policy_t * policy, int flags)
275  {
276    if (flags & ~HWLOC_MEMBIND_ALLFLAGS) {
277      errno = EINVAL;
278      return -1;
279    }
280    if (flags & HWLOC_MEMBIND_PROCESS) {
281      if (topology->binding_hooks.get_thisproc_membind)
282        return topology->binding_hooks.get_thisproc_membind(topology, nodeset, policy, flags);
283    } else if (flags & HWLOC_MEMBIND_THREAD) {
284      if (topology->binding_hooks.get_thisthread_membind)
285        return topology->binding_hooks.get_thisthread_membind(topology, nodeset, policy, flags);
286    } else {
287      if (topology->binding_hooks.get_thisproc_membind) {
288        int err = topology->binding_hooks.get_thisproc_membind(topology, nodeset, policy, flags);
289        if (err >= 0 || errno != ENOSYS)
290          return err;
291      }
292      if (topology->binding_hooks.get_thisthread_membind)
293        return topology->binding_hooks.get_thisthread_membind(topology, nodeset, policy, flags);
294    }
295    errno = ENOSYS;
296    return -1;
297  }
298  int
299  hwloc_get_membind(hwloc_topology_t topology, hwloc_bitmap_t set, hwloc_membind_policy_t * policy, int flags)
300  {
301    int ret;
302    if (flags & HWLOC_MEMBIND_BYNODESET) {
303      ret = hwloc_get_membind_by_nodeset(topology, set, policy, flags);
304    } else {
305      hwloc_nodeset_t nodeset = hwloc_bitmap_alloc();
306      ret = hwloc_get_membind_by_nodeset(topology, nodeset, policy, flags);
307      if (!ret)
308        hwloc_cpuset_from_nodeset(topology, set, nodeset);
309      hwloc_bitmap_free(nodeset);
310    }
311    return ret;
312  }
313  static int
314  hwloc_set_proc_membind_by_nodeset(hwloc_topology_t topology, hwloc_pid_t pid, hwloc_const_nodeset_t nodeset, hwloc_membind_policy_t policy, int flags)
315  {
316    if ((flags & ~HWLOC_MEMBIND_ALLFLAGS) || hwloc__check_membind_policy(policy) < 0) {
317      errno = EINVAL;
318      return -1;
319    }
320    nodeset = hwloc_fix_membind(topology, nodeset);
321    if (!nodeset)
322      return -1;
323    if (topology->binding_hooks.set_proc_membind)
324      return topology->binding_hooks.set_proc_membind(topology, pid, nodeset, policy, flags);
325    errno = ENOSYS;
326    return -1;
327  }
328  int
329  hwloc_set_proc_membind(hwloc_topology_t topology, hwloc_pid_t pid, hwloc_const_bitmap_t set, hwloc_membind_policy_t policy, int flags)
330  {
331    int ret;
332    if (flags & HWLOC_MEMBIND_BYNODESET) {
333      ret = hwloc_set_proc_membind_by_nodeset(topology, pid, set, policy, flags);
334    } else {
335      hwloc_nodeset_t nodeset = hwloc_bitmap_alloc();
336      if (hwloc_fix_membind_cpuset(topology, nodeset, set))
337        ret = -1;
338      else
339        ret = hwloc_set_proc_membind_by_nodeset(topology, pid, nodeset, policy, flags);
340      hwloc_bitmap_free(nodeset);
341    }
342    return ret;
343  }
344  static int
345  hwloc_get_proc_membind_by_nodeset(hwloc_topology_t topology, hwloc_pid_t pid, hwloc_nodeset_t nodeset, hwloc_membind_policy_t * policy, int flags)
346  {
347    if (flags & ~HWLOC_MEMBIND_ALLFLAGS) {
348      errno = EINVAL;
349      return -1;
350    }
351    if (topology->binding_hooks.get_proc_membind)
352      return topology->binding_hooks.get_proc_membind(topology, pid, nodeset, policy, flags);
353    errno = ENOSYS;
354    return -1;
355  }
356  int
357  hwloc_get_proc_membind(hwloc_topology_t topology, hwloc_pid_t pid, hwloc_bitmap_t set, hwloc_membind_policy_t * policy, int flags)
358  {
359    int ret;
360    if (flags & HWLOC_MEMBIND_BYNODESET) {
361      ret = hwloc_get_proc_membind_by_nodeset(topology, pid, set, policy, flags);
362    } else {
363      hwloc_nodeset_t nodeset = hwloc_bitmap_alloc();
364      ret = hwloc_get_proc_membind_by_nodeset(topology, pid, nodeset, policy, flags);
365      if (!ret)
366        hwloc_cpuset_from_nodeset(topology, set, nodeset);
367      hwloc_bitmap_free(nodeset);
368    }
369    return ret;
370  }
371  static int
372  hwloc_set_area_membind_by_nodeset(hwloc_topology_t topology, const void *addr, size_t len, hwloc_const_nodeset_t nodeset, hwloc_membind_policy_t policy, int flags)
373  {
374    if ((flags & ~HWLOC_MEMBIND_ALLFLAGS) || hwloc__check_membind_policy(policy) < 0) {
375      errno = EINVAL;
376      return -1;
377    }
378    if (!len)
379      return 0;
380    nodeset = hwloc_fix_membind(topology, nodeset);
381    if (!nodeset)
382      return -1;
383    if (topology->binding_hooks.set_area_membind)
384      return topology->binding_hooks.set_area_membind(topology, addr, len, nodeset, policy, flags);
385    errno = ENOSYS;
386    return -1;
387  }
388  int
389  hwloc_set_area_membind(hwloc_topology_t topology, const void *addr, size_t len, hwloc_const_bitmap_t set, hwloc_membind_policy_t policy, int flags)
390  {
391    int ret;
392    if (flags & HWLOC_MEMBIND_BYNODESET) {
393      ret = hwloc_set_area_membind_by_nodeset(topology, addr, len, set, policy, flags);
394    } else {
395      hwloc_nodeset_t nodeset = hwloc_bitmap_alloc();
396      if (hwloc_fix_membind_cpuset(topology, nodeset, set))
397        ret = -1;
398      else
399        ret = hwloc_set_area_membind_by_nodeset(topology, addr, len, nodeset, policy, flags);
400      hwloc_bitmap_free(nodeset);
401    }
402    return ret;
403  }
404  static int
405  hwloc_get_area_membind_by_nodeset(hwloc_topology_t topology, const void *addr, size_t len, hwloc_nodeset_t nodeset, hwloc_membind_policy_t * policy, int flags)
406  {
407    if (flags & ~HWLOC_MEMBIND_ALLFLAGS) {
408      errno = EINVAL;
409      return -1;
410    }
411    if (!len) {
412      errno = EINVAL;
413      return -1;
414    }
415    if (topology->binding_hooks.get_area_membind)
416      return topology->binding_hooks.get_area_membind(topology, addr, len, nodeset, policy, flags);
417    errno = ENOSYS;
418    return -1;
419  }
420  int
421  hwloc_get_area_membind(hwloc_topology_t topology, const void *addr, size_t len, hwloc_bitmap_t set, hwloc_membind_policy_t * policy, int flags)
422  {
423    int ret;
424    if (flags & HWLOC_MEMBIND_BYNODESET) {
425      ret = hwloc_get_area_membind_by_nodeset(topology, addr, len, set, policy, flags);
426    } else {
427      hwloc_nodeset_t nodeset = hwloc_bitmap_alloc();
428      ret = hwloc_get_area_membind_by_nodeset(topology, addr, len, nodeset, policy, flags);
429      if (!ret)
430        hwloc_cpuset_from_nodeset(topology, set, nodeset);
431      hwloc_bitmap_free(nodeset);
432    }
433    return ret;
434  }
435  static int
436  hwloc_get_area_memlocation_by_nodeset(hwloc_topology_t topology, const void *addr, size_t len, hwloc_nodeset_t nodeset, int flags)
437  {
438    if (flags & ~HWLOC_MEMBIND_ALLFLAGS) {
439      errno = EINVAL;
440      return -1;
441    }
442    if (!len)
443      return 0;
444    if (topology->binding_hooks.get_area_memlocation)
445      return topology->binding_hooks.get_area_memlocation(topology, addr, len, nodeset, flags);
446    errno = ENOSYS;
447    return -1;
448  }
449  int
450  hwloc_get_area_memlocation(hwloc_topology_t topology, const void *addr, size_t len, hwloc_cpuset_t set, int flags)
451  {
452    int ret;
453    if (flags & HWLOC_MEMBIND_BYNODESET) {
454      ret = hwloc_get_area_memlocation_by_nodeset(topology, addr, len, set, flags);
455    } else {
456      hwloc_nodeset_t nodeset = hwloc_bitmap_alloc();
457      ret = hwloc_get_area_memlocation_by_nodeset(topology, addr, len, nodeset, flags);
458      if (!ret)
459        hwloc_cpuset_from_nodeset(topology, set, nodeset);
460      hwloc_bitmap_free(nodeset);
461    }
462    return ret;
463  }
464  void *
465  hwloc_alloc_heap(hwloc_topology_t topology __hwloc_attribute_unused, size_t len)
466  {
467    void *p = NULL;
468  #if defined(hwloc_getpagesize) && defined(HAVE_POSIX_MEMALIGN)
469    errno = posix_memalign(&p, hwloc_getpagesize(), len);
470    if (errno)
471      p = NULL;
472  #elif defined(hwloc_getpagesize) && defined(HAVE_MEMALIGN)
473    p = memalign(hwloc_getpagesize(), len);
474  #else
475    p = malloc(len);
476  #endif
477    return p;
478  }
479  #ifdef MAP_ANONYMOUS
480  void *
481  hwloc_alloc_mmap(hwloc_topology_t topology __hwloc_attribute_unused, size_t len)
482  {
483    void * buffer = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
484    return buffer == MAP_FAILED ? NULL : buffer;
485  }
486  #endif
487  int
488  hwloc_free_heap(hwloc_topology_t topology __hwloc_attribute_unused, void *addr, size_t len __hwloc_attribute_unused)
489  {
490    free(addr);
491    return 0;
492  }
493  #ifdef MAP_ANONYMOUS
494  int
495  hwloc_free_mmap(hwloc_topology_t topology __hwloc_attribute_unused, void *addr, size_t len)
496  {
497    if (!addr)
498      return 0;
499    return munmap(addr, len);
500  }
501  #endif
502  void *
503  hwloc_alloc(hwloc_topology_t topology, size_t len)
504  {
505    if (topology->binding_hooks.alloc)
506      return topology->binding_hooks.alloc(topology, len);
507    return hwloc_alloc_heap(topology, len);
508  }
509  static void *
510  hwloc_alloc_membind_by_nodeset(hwloc_topology_t topology, size_t len, hwloc_const_nodeset_t nodeset, hwloc_membind_policy_t policy, int flags)
511  {
512    void *p;
513    if ((flags & ~HWLOC_MEMBIND_ALLFLAGS) || hwloc__check_membind_policy(policy) < 0) {
514      errno = EINVAL;
515      return NULL;
516    }
517    nodeset = hwloc_fix_membind(topology, nodeset);
518    if (!nodeset)
519      goto fallback;
520    if (flags & HWLOC_MEMBIND_MIGRATE) {
521      errno = EINVAL;
522      goto fallback;
523    }
524    if (topology->binding_hooks.alloc_membind)
525      return topology->binding_hooks.alloc_membind(topology, len, nodeset, policy, flags);
526    else if (topology->binding_hooks.set_area_membind) {
527      p = hwloc_alloc(topology, len);
528      if (!p)
529        return NULL;
530      if (topology->binding_hooks.set_area_membind(topology, p, len, nodeset, policy, flags) && flags & HWLOC_MEMBIND_STRICT) {
531        int error = errno;
532        free(p);
533        errno = error;
534        return NULL;
535      }
536      return p;
537    } else {
538      errno = ENOSYS;
539    }
540  fallback:
541    if (flags & HWLOC_MEMBIND_STRICT)
542      return NULL;
543    return hwloc_alloc(topology, len);
544  }
545  void *
546  hwloc_alloc_membind(hwloc_topology_t topology, size_t len, hwloc_const_bitmap_t set, hwloc_membind_policy_t policy, int flags)
547  {
548    void *ret;
549    if (flags & HWLOC_MEMBIND_BYNODESET) {
550      ret = hwloc_alloc_membind_by_nodeset(topology, len, set, policy, flags);
551    } else {
552      hwloc_nodeset_t nodeset = hwloc_bitmap_alloc();
553      if (hwloc_fix_membind_cpuset(topology, nodeset, set)) {
554        if (flags & HWLOC_MEMBIND_STRICT)
555  	ret = NULL;
556        else
557  	ret = hwloc_alloc(topology, len);
558      } else
559        ret = hwloc_alloc_membind_by_nodeset(topology, len, nodeset, policy, flags);
560      hwloc_bitmap_free(nodeset);
561    }
562    return ret;
563  }
564  int
565  hwloc_free(hwloc_topology_t topology, void *addr, size_t len)
566  {
567    if (topology->binding_hooks.free_membind)
568      return topology->binding_hooks.free_membind(topology, addr, len);
569    return hwloc_free_heap(topology, addr, len);
570  }
571  static int dontset_return_complete_cpuset(hwloc_topology_t topology, hwloc_cpuset_t set)
572  {
573    hwloc_bitmap_copy(set, hwloc_topology_get_complete_cpuset(topology));
574    return 0;
575  }
576  static int dontset_thisthread_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_const_bitmap_t set __hwloc_attribute_unused, int flags __hwloc_attribute_unused)
577  {
578    return 0;
579  }
580  static int dontget_thisthread_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_bitmap_t set, int flags __hwloc_attribute_unused)
581  {
582    return dontset_return_complete_cpuset(topology, set);
583  }
584  static int dontset_thisproc_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_const_bitmap_t set __hwloc_attribute_unused, int flags __hwloc_attribute_unused)
585  {
586    return 0;
587  }
588  static int dontget_thisproc_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_bitmap_t set, int flags __hwloc_attribute_unused)
589  {
590    return dontset_return_complete_cpuset(topology, set);
591  }
592  static int dontset_proc_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_pid_t pid __hwloc_attribute_unused, hwloc_const_bitmap_t set __hwloc_attribute_unused, int flags __hwloc_attribute_unused)
593  {
594    return 0;
595  }
596  static int dontget_proc_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_pid_t pid __hwloc_attribute_unused, hwloc_bitmap_t cpuset, int flags __hwloc_attribute_unused)
597  {
598    return dontset_return_complete_cpuset(topology, cpuset);
599  }
600  #ifdef hwloc_thread_t
601  static int dontset_thread_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_thread_t tid __hwloc_attribute_unused, hwloc_const_bitmap_t set __hwloc_attribute_unused, int flags __hwloc_attribute_unused)
602  {
603    return 0;
604  }
605  static int dontget_thread_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_thread_t tid __hwloc_attribute_unused, hwloc_bitmap_t cpuset, int flags __hwloc_attribute_unused)
606  {
607    return dontset_return_complete_cpuset(topology, cpuset);
608  }
609  #endif
610  static int dontset_return_complete_nodeset(hwloc_topology_t topology, hwloc_nodeset_t set, hwloc_membind_policy_t *policy)
611  {
612    hwloc_bitmap_copy(set, hwloc_topology_get_complete_nodeset(topology));
613    *policy = HWLOC_MEMBIND_MIXED;
614    return 0;
615  }
616  static int dontset_thisproc_membind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_const_bitmap_t set __hwloc_attribute_unused, hwloc_membind_policy_t policy __hwloc_attribute_unused, int flags __hwloc_attribute_unused)
617  {
618    return 0;
619  }
620  static int dontget_thisproc_membind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_bitmap_t set, hwloc_membind_policy_t * policy, int flags __hwloc_attribute_unused)
621  {
622    return dontset_return_complete_nodeset(topology, set, policy);
623  }
624  static int dontset_thisthread_membind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_const_bitmap_t set __hwloc_attribute_unused, hwloc_membind_policy_t policy __hwloc_attribute_unused, int flags __hwloc_attribute_unused)
625  {
626    return 0;
627  }
628  static int dontget_thisthread_membind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_bitmap_t set, hwloc_membind_policy_t * policy, int flags __hwloc_attribute_unused)
629  {
630    return dontset_return_complete_nodeset(topology, set, policy);
631  }
632  static int dontset_proc_membind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_pid_t pid __hwloc_attribute_unused, hwloc_const_bitmap_t set __hwloc_attribute_unused, hwloc_membind_policy_t policy __hwloc_attribute_unused, int flags __hwloc_attribute_unused)
633  {
634    return 0;
635  }
636  static int dontget_proc_membind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_pid_t pid __hwloc_attribute_unused, hwloc_bitmap_t set, hwloc_membind_policy_t * policy, int flags __hwloc_attribute_unused)
637  {
638    return dontset_return_complete_nodeset(topology, set, policy);
639  }
640  static int dontset_area_membind(hwloc_topology_t topology __hwloc_attribute_unused, const void *addr __hwloc_attribute_unused, size_t size __hwloc_attribute_unused, hwloc_const_bitmap_t set __hwloc_attribute_unused, hwloc_membind_policy_t policy __hwloc_attribute_unused, int flags __hwloc_attribute_unused)
641  {
642    return 0;
643  }
644  static int dontget_area_membind(hwloc_topology_t topology __hwloc_attribute_unused, const void *addr __hwloc_attribute_unused, size_t size __hwloc_attribute_unused, hwloc_bitmap_t set, hwloc_membind_policy_t * policy, int flags __hwloc_attribute_unused)
645  {
646    return dontset_return_complete_nodeset(topology, set, policy);
647  }
648  static int dontget_area_memlocation(hwloc_topology_t topology __hwloc_attribute_unused, const void *addr __hwloc_attribute_unused, size_t size __hwloc_attribute_unused, hwloc_bitmap_t set, int flags __hwloc_attribute_unused)
649  {
650    hwloc_membind_policy_t policy;
651    return dontset_return_complete_nodeset(topology, set, &policy);
652  }
653  static void * dontalloc_membind(hwloc_topology_t topology __hwloc_attribute_unused, size_t size __hwloc_attribute_unused, hwloc_const_bitmap_t set __hwloc_attribute_unused, hwloc_membind_policy_t policy __hwloc_attribute_unused, int flags __hwloc_attribute_unused)
654  {
655    return malloc(size);
656  }
657  static int dontfree_membind(hwloc_topology_t topology __hwloc_attribute_unused, void *addr __hwloc_attribute_unused, size_t size __hwloc_attribute_unused)
658  {
659    free(addr);
660    return 0;
661  }
662  static void hwloc_set_dummy_hooks(struct hwloc_binding_hooks *hooks,
663  				  struct hwloc_topology_support *support __hwloc_attribute_unused)
664  {
<span onclick='openModal()' class='match'>665    hooks->set_thisproc_cpubind = dontset_thisproc_cpubind;
666    hooks->get_thisproc_cpubind = dontget_thisproc_cpubind;
667    hooks->set_thisthread_cpubind = dontset_thisthread_cpubind;
668    hooks->get_thisthread_cpubind = dontget_thisthread_cpubind;
669    hooks->set_proc_cpubind = dontset_proc_cpubind;
670    hooks->get_proc_cpubind = dontget_proc_cpubind;
671  #ifdef hwloc_thread_t
672    hooks->set_thread_cpubind = dontset_thread_cpubind;
673    hooks->get_thread_cpubind = dontget_thread_cpubind;
674  #endif
675    hooks->get_thisproc_last_cpu_location = dontget_thisproc_cpubind; &bsol;* cpubind instead of last_cpu_location is ok */
676    hooks->get_thisthread_last_cpu_location = dontget_thisthread_cpubind; &bsol;* cpubind instead of last_cpu_location is ok */
</span>677    hooks->get_proc_last_cpu_location = dontget_proc_cpubind; &bsol;* cpubind instead of last_cpu_location is ok */
678    hooks->set_thisproc_membind = dontset_thisproc_membind;
679    hooks->get_thisproc_membind = dontget_thisproc_membind;
680    hooks->set_thisthread_membind = dontset_thisthread_membind;
681    hooks->get_thisthread_membind = dontget_thisthread_membind;
682    hooks->set_proc_membind = dontset_proc_membind;
683    hooks->get_proc_membind = dontget_proc_membind;
684    hooks->set_area_membind = dontset_area_membind;
685    hooks->get_area_membind = dontget_area_membind;
686    hooks->get_area_memlocation = dontget_area_memlocation;
687    hooks->alloc_membind = dontalloc_membind;
688    hooks->free_membind = dontfree_membind;
689  }
690  void
691  hwloc_set_native_binding_hooks(struct hwloc_binding_hooks *hooks, struct hwloc_topology_support *support)
692  {
693  #    ifdef HWLOC_LINUX_SYS
694      hwloc_set_linuxfs_hooks(hooks, support);
695  #    endif &bsol;* HWLOC_LINUX_SYS */
696  #    ifdef HWLOC_BGQ_SYS
697      hwloc_set_bgq_hooks(hooks, support);
698  #    endif &bsol;* HWLOC_BGQ_SYS */
699  #    ifdef HWLOC_AIX_SYS
700      hwloc_set_aix_hooks(hooks, support);
701  #    endif &bsol;* HWLOC_AIX_SYS */
702  #    ifdef HWLOC_SOLARIS_SYS
703      hwloc_set_solaris_hooks(hooks, support);
704  #    endif &bsol;* HWLOC_SOLARIS_SYS */
705  #    ifdef HWLOC_WIN_SYS
706      hwloc_set_windows_hooks(hooks, support);
707  #    endif &bsol;* HWLOC_WIN_SYS */
708  #    ifdef HWLOC_DARWIN_SYS
709      hwloc_set_darwin_hooks(hooks, support);
710  #    endif &bsol;* HWLOC_DARWIN_SYS */
711  #    ifdef HWLOC_FREEBSD_SYS
712      hwloc_set_freebsd_hooks(hooks, support);
713  #    endif &bsol;* HWLOC_FREEBSD_SYS */
714  #    ifdef HWLOC_NETBSD_SYS
715      hwloc_set_netbsd_hooks(hooks, support);
716  #    endif &bsol;* HWLOC_NETBSD_SYS */
717  #    ifdef HWLOC_HPUX_SYS
718      hwloc_set_hpux_hooks(hooks, support);
719  #    endif &bsol;* HWLOC_HPUX_SYS */
720  }
721  void
722  hwloc_set_binding_hooks(struct hwloc_topology *topology)
723  {
724    if (topology->is_thissystem) {
725      hwloc_set_native_binding_hooks(&topology->binding_hooks, &topology->support);
726    } else {
727      hwloc_set_dummy_hooks(&topology->binding_hooks, &topology->support);
728    }
729    if (topology->is_thissystem) {
730  #define DO(which,kind) \
731      if (topology->binding_hooks.kind) \
732        topology->support.which##bind->kind = 1;
733      DO(cpu,set_thisproc_cpubind);
734      DO(cpu,get_thisproc_cpubind);
735      DO(cpu,set_proc_cpubind);
736      DO(cpu,get_proc_cpubind);
737      DO(cpu,set_thisthread_cpubind);
738      DO(cpu,get_thisthread_cpubind);
739  #ifdef hwloc_thread_t
740      DO(cpu,set_thread_cpubind);
741      DO(cpu,get_thread_cpubind);
742  #endif
743      DO(cpu,get_thisproc_last_cpu_location);
744      DO(cpu,get_proc_last_cpu_location);
745      DO(cpu,get_thisthread_last_cpu_location);
746      DO(mem,set_thisproc_membind);
747      DO(mem,get_thisproc_membind);
748      DO(mem,set_thisthread_membind);
749      DO(mem,get_thisthread_membind);
750      DO(mem,set_proc_membind);
751      DO(mem,get_proc_membind);
752      DO(mem,set_area_membind);
753      DO(mem,get_area_membind);
754      DO(mem,get_area_memlocation);
755      DO(mem,alloc_membind);
756  #undef DO
757    }
758  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-reodft11e-radix2.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-bind.c</div>
                </div>
                <div class="column column_space"><pre><code>386       pln->n = n;
387       pln->is = p->sz->dims[0].is;
388       pln->os = p->sz->dims[0].os;
389       pln->cld = cld;
390       pln->td = pln->td2 = 0;
391       pln->kind = p->kind[0];
392       X(tensor_tornk1)(p->vecsz, &pln->vl, &pln->ivs, &pln->ovs);
393       X(ops_zero)(&ops);
394       ops.add = 2 + (n/2 - 1)/2 * 20;
395       ops.mul = 6 + (n/2 - 1)/2 * 16;
396       ops.other = 4*n + 2 + (n/2 - 1)/2 * 6;
</pre></code></div>
                <div class="column column_space"><pre><code>665    hooks->set_thisproc_cpubind = dontset_thisproc_cpubind;
666    hooks->get_thisproc_cpubind = dontget_thisproc_cpubind;
667    hooks->set_thisthread_cpubind = dontset_thisthread_cpubind;
668    hooks->get_thisthread_cpubind = dontget_thisthread_cpubind;
669    hooks->set_proc_cpubind = dontset_proc_cpubind;
670    hooks->get_proc_cpubind = dontget_proc_cpubind;
671  #ifdef hwloc_thread_t
672    hooks->set_thread_cpubind = dontset_thread_cpubind;
673    hooks->get_thread_cpubind = dontget_thread_cpubind;
674  #endif
675    hooks->get_thisproc_last_cpu_location = dontget_thisproc_cpubind; &bsol;* cpubind instead of last_cpu_location is ok */
676    hooks->get_thisthread_last_cpu_location = dontget_thisthread_cpubind; &bsol;* cpubind instead of last_cpu_location is ok */
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    