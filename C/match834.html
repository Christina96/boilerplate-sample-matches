<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for omczmq.c &amp; imudp.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for omczmq.c &amp; imudp.c
      </h3>
<h1 align="center">
        10.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>omczmq.c (16.767677%)<th>imudp.c (7.6709795%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(98-120)<td><a href="#" name="0">(181-208)</a><td align="center"><font color="#ff0000">35</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(415-426)<td><a href="#" name="1">(990-996)</a><td align="center"><font color="#8a0000">19</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(49-59)<td><a href="#" name="2">(167-176)</a><td align="center"><font color="#7b0000">17</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(481-489)<td><a href="#" name="3">(996-1000)</a><td align="center"><font color="#570000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>omczmq.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* omczmq.c
 * Copyright (C) 2016 Brian Knox
 * Copyright (C) 2014 Rainer Gerhards
 *
 * Author: Brian Knox &lt;bknox@digitalocean.com&gt;
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "config.h"
#include "rsyslog.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "cfsysline.h"
#include &lt;czmq.h&gt;

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("omczmq")

DEF_OMOD_STATIC_DATA

<a name="2"></a>static pthread_mutex_t mutDoAct = PTHREAD_MUTEX_INITIALIZER;

static struct cnfparamdescr modpdescr[] = {
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "authenticator", eCmdHdlrBinary, 0 },
	{ "authtype", eCmdHdlrGetWord, 0 },
	{ "clientcertpath", eCmdHdlrGetWord, 0 },
	{ "servercertpath", eCmdHdlrGetWord, 0 }
};

static struct cnfparamblk modpblk = {
	CNFPARAMBLK_VERSION,
	sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	modpdescr
};</b></font>

struct modConfData_s {
	rsconf_t *pConf;
	uchar *tplName;
	int authenticator;
	char *authType;
	char *serverCertPath;
	char *clientCertPath;
};

static modConfData_t *runModConf = NULL;
static zactor_t *authActor;

typedef struct _instanceData {
	zsock_t *sock;
	bool serverish;
	int sendTimeout;
	zlist_t *topics;
	bool sendError;
	char *sockEndpoints;
	int sockType;
	int sendHWM;
#if(CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
	int heartbeatIvl;
	int heartbeatTimeout;
	int heartbeatTTL;
	int connectTimeout;
#endif
	uchar *tplName;
	sbool topicFrame;
	sbool dynaTopic;
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
<a name="0"></a>} wrkrInstanceData_t;

static struct cnfparamdescr actpdescr[] = {
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "endpoints", eCmdHdlrGetWord, 1 },
	{ "socktype", eCmdHdlrGetWord, 1 },
	{ "sendhwm", eCmdHdlrGetWord, 0 },
#if(CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
	{ "heartbeatttl", eCmdHdlrGetWord, 0},
	{ "heartbeativl", eCmdHdlrGetWord, 0},
	{ "heartbeattimeout", eCmdHdlrGetWord, 0},
	{ "connecttimeout", eCmdHdlrGetWord, 0},
#endif
	{ "sendtimeout", eCmdHdlrGetWord, 0 },
	{ "template", eCmdHdlrGetWord, 0 },
	{ "topics", eCmdHdlrGetWord, 0 },
	{ "topicframe", eCmdHdlrGetWord, 0},
	{ "dynatopic", eCmdHdlrBinary, 0 }
};

static struct cnfparamblk actpblk = {
	CNFPARAMBLK_VERSION,
	sizeof(actpdescr) / sizeof(struct cnfparamdescr),
	actpdescr
};

static rsRetVal initCZMQ(instanceData* pData) {</b></font>
	DEFiRet;
	int rc;
	putenv((char*)"ZSYS_SIGHANDLER=false");
	pData-&gt;sock = zsock_new(pData-&gt;sockType);
	if(!pData-&gt;sock) {
		LogError(0, RS_RET_NO_ERRCODE,
				"omczmq: new socket failed for endpoints: %s",
				pData-&gt;sockEndpoints);
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}

	zsock_set_sndtimeo(pData-&gt;sock, pData-&gt;sendTimeout);

#if(CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
	if(pData-&gt;heartbeatIvl &gt; 0 &amp;&amp; pData-&gt;heartbeatTimeout &gt; 0 &amp;&amp; pData-&gt;heartbeatTTL &gt; 0) {
		zsock_set_heartbeat_ivl(pData-&gt;sock, pData-&gt;heartbeatIvl);
		zsock_set_heartbeat_timeout(pData-&gt;sock, pData-&gt;heartbeatTimeout);
		zsock_set_heartbeat_ttl(pData-&gt;sock, pData-&gt;heartbeatTTL);
	}
#endif

	if(runModConf-&gt;authType) {
		if (!strcmp(runModConf-&gt;authType, "CURVESERVER")) {
			zcert_t *serverCert = zcert_load(runModConf-&gt;serverCertPath);
			if(!serverCert) {
				LogError(0, NO_ERRCODE, "could not load cert %s",
					runModConf-&gt;serverCertPath);
				ABORT_FINALIZE(RS_RET_ERR);
			}
			zsock_set_zap_domain(pData-&gt;sock, "global");
			zsock_set_curve_server(pData-&gt;sock, 1);
			zcert_apply(serverCert, pData-&gt;sock);
			zcert_destroy(&amp;serverCert);
		}
		else if(!strcmp(runModConf-&gt;authType, "CURVECLIENT")) {
			zcert_t *serverCert = zcert_load(runModConf-&gt;serverCertPath);
			if(!serverCert) {
				LogError(0, NO_ERRCODE, "could not load cert %s",
					runModConf-&gt;serverCertPath);
				ABORT_FINALIZE(RS_RET_ERR);
			}
			const char *server_key = zcert_public_txt(serverCert);
			zcert_destroy(&amp;serverCert);
			zsock_set_curve_serverkey(pData-&gt;sock, server_key);

			zcert_t *clientCert = zcert_load(runModConf-&gt;clientCertPath);
			if(!clientCert) {
				LogError(0, NO_ERRCODE, "could not load cert %s",
					runModConf-&gt;clientCertPath);
				ABORT_FINALIZE(RS_RET_ERR);
			}

			zcert_apply(clientCert, pData-&gt;sock);
			zcert_destroy(&amp;clientCert);
		}
	}

	switch(pData-&gt;sockType) {
		case ZMQ_PUB:
#if defined(ZMQ_RADIO)
		case ZMQ_RADIO:
#endif
			pData-&gt;serverish = true;
			break;
		case ZMQ_PUSH:
#if defined(ZMQ_SCATTER)
		case ZMQ_SCATTER:
#endif
		case ZMQ_DEALER:
#if defined(ZMQ_CLIENT)
		case ZMQ_CLIENT:
#endif
			pData-&gt;serverish = false;
			break;
	}

	rc = zsock_attach(pData-&gt;sock, pData-&gt;sockEndpoints, pData-&gt;serverish);
	if(rc == -1) {
		LogError(0, NO_ERRCODE, "zsock_attach to %s failed",
				pData-&gt;sockEndpoints);
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}

finalize_it:
	RETiRet;
}

static rsRetVal outputCZMQ(uchar** ppString, instanceData* pData) {
	DEFiRet;

	if(NULL == pData-&gt;sock) {
		CHKiRet(initCZMQ(pData));
	}

	/* if we are using a PUB (or RADIO) socket and we have a topic list then we
	 * need some special care and attention */
#if defined(ZMQ_RADIO)
	DBGPRINTF("omczmq: ZMQ_RADIO is defined...\n");
	if((pData-&gt;sockType == ZMQ_PUB || pData-&gt;sockType == ZMQ_RADIO) &amp;&amp; pData-&gt;topics) {
#else
	DBGPRINTF("omczmq: ZMQ_RADIO is NOT defined...\n");
	if(pData-&gt;sockType == ZMQ_PUB &amp;&amp; pData-&gt;topics) {
#endif
		int templateIndex = 1;
		const char *topic = (const char *)zlist_first(pData-&gt;topics);
		while(topic) {
			int rc;
			/* if dynaTopic is true, the topic is constructed by rsyslog
			 * by applying the supplied template to the message properties */
			if(pData-&gt;dynaTopic)
				topic = (const char*)ppString[templateIndex];

			if (pData-&gt;sockType == ZMQ_PUB) {
				/* if topicFrame is true, send the topic as a separate zmq frame */
				if(pData-&gt;topicFrame) {
					rc = zstr_sendx(pData-&gt;sock, topic, (char*)ppString[0], NULL);
				}

				/* if topicFrame is false, concatenate the topic with the
				 * message in the same frame */
				else {
					rc = zstr_sendf(pData-&gt;sock, "%s%s", topic, (char*)ppString[0]);
				}

				/* if we have a send error notify rsyslog */
				if(rc != 0) {
					pData-&gt;sendError = true;
					ABORT_FINALIZE(RS_RET_SUSPENDED);
				}
			}
#if defined(ZMQ_RADIO)
			else if(pData-&gt;sockType == ZMQ_RADIO) {
				DBGPRINTF("omczmq: sending on RADIO socket...\n");
				zframe_t *frame = zframe_from((char*)ppString[0]);
				if (!frame) {
					DBGPRINTF("omczmq: failed to create frame...\n");
					pData-&gt;sendError = true;
					ABORT_FINALIZE(RS_RET_SUSPENDED);
				}
				rc = zframe_set_group(frame, topic);
				if (rc != 0) {
					DBGPRINTF("omczmq: failed to set group '%d'...\n", rc);
					pData-&gt;sendError = true;
					ABORT_FINALIZE(RS_RET_SUSPENDED);
				}
				DBGPRINTF("omczmq: set RADIO group to '%s'\n", topic);
				rc = zframe_send(&amp;frame, pData-&gt;sock, 0);
				if(rc != 0) {
					pData-&gt;sendError = true;
					ABORT_FINALIZE(RS_RET_SUSPENDED);
				}
			}
#endif

			/* get the next topic from the list, and increment
			 * our topic index */
			topic = zlist_next(pData-&gt;topics);
			templateIndex++;
		}
	}

	/* we aren't a PUB socket and we don't have a topic list - this means
	 * we can just send the message using the rsyslog template */
	else {
		int rc = zstr_send(pData-&gt;sock, (char*)ppString[0]);
		if(rc != 0) {
			pData-&gt;sendError = true;
			DBGPRINTF("omczmq: send error: %d", rc);
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
	}
finalize_it:
	RETiRet;
}

static inline void
setInstParamDefaults(instanceData* pData) {
	pData-&gt;sockEndpoints = NULL;
	pData-&gt;sock = NULL;
	pData-&gt;sendError = false;
	pData-&gt;serverish = false;
	pData-&gt;tplName = NULL;
	pData-&gt;sockType = -1;
	pData-&gt;sendTimeout = -1;
	pData-&gt;topics = NULL;
	pData-&gt;topicFrame = false;
#if(CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
	pData-&gt;heartbeatIvl = 0;
	pData-&gt;heartbeatTimeout = 0;
	pData-&gt;heartbeatTTL = 0;
#endif
}


BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
ENDcreateWrkrInstance

BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction) {
		iRet = RS_RET_OK;
	}
ENDisCompatibleWithFeature
BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
ENDdbgPrintInstInfo

BEGINfreeInstance
CODESTARTfreeInstance
	zlist_destroy(&amp;pData-&gt;topics);
	zsock_destroy(&amp;pData-&gt;sock);
	free(pData-&gt;sockEndpoints);
	free(pData-&gt;tplName);
ENDfreeInstance


BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
ENDfreeWrkrInstance

BEGINtryResume
	instanceData *pData;
CODESTARTtryResume
	pthread_mutex_lock(&amp;mutDoAct);
	pData = pWrkrData-&gt;pData;
	DBGPRINTF("omczmq: trying to resume...\n");
	zsock_destroy(&amp;pData-&gt;sock);
	iRet = initCZMQ(pData);
	pthread_mutex_unlock(&amp;mutDoAct);
ENDtryResume

BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	runModConf = pModConf;
	runModConf-&gt;pConf = pConf;
	runModConf-&gt;authenticator = 0;
	runModConf-&gt;authType = NULL;
	runModConf-&gt;serverCertPath = NULL;
	runModConf-&gt;clientCertPath = NULL;
ENDbeginCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
	if(runModConf-&gt;authenticator == 1) {
		if(!authActor) {
			DBGPRINTF("omczmq: starting authActor\n");
			authActor = zactor_new(zauth, NULL);
			if(!strcmp(runModConf-&gt;clientCertPath, "*")) {
				zstr_sendx(authActor, "CURVE", CURVE_ALLOW_ANY, NULL);
			}
			else {
				zstr_sendx(authActor, "CURVE", runModConf-&gt;clientCertPath, NULL);
			}
			zsock_wait(authActor);
		}
	}
ENDactivateCnf

BEGINfreeCnf
CODESTARTfreeCnf
	free(pModConf-&gt;tplName);
	free(pModConf-&gt;authType);
	free(pModConf-&gt;serverCertPath);
	free(pModConf-&gt;clientCertPath);
	DBGPRINTF("omczmq: stopping authActor\n");
	zactor_destroy(&amp;authActor);
ENDfreeCnf

BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if (pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, "error processing module");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	for (i=0; i&lt;modpblk.nParams; ++i) {
		if(!pvals[i].bUsed) {
			DBGPRINTF("omczmq: pvals[i].bUSed continuing\n");
<a name="1"></a>			continue;
		}
		if(!strcmp(modpblk.descr[i].name, "authenticator")) {
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>			runModConf-&gt;authenticator = (int)pvals[i].val.d.n;
		}
		else if(!strcmp(modpblk.descr[i].name, "authtype")) {
			runModConf-&gt;authType = es_str2cstr(pvals[i].val.d.estr, NULL);
			DBGPRINTF("omczmq: authtype set to %s\n", runModConf-&gt;authType);
		}
		else if(!strcmp(modpblk.descr[i].name, "servercertpath")) {
			runModConf-&gt;serverCertPath = es_str2cstr(pvals[i].val.d.estr, NULL);
			DBGPRINTF("omczmq: serverCertPath set to %s\n", runModConf-&gt;serverCertPath);
		}
		else if(!strcmp(modpblk.descr[i].name, "clientcertpath")) {
			runModConf-&gt;clientCertPath = es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
			DBGPRINTF("omczmq: clientCertPath set to %s\n", runModConf-&gt;clientCertPath);
		}
		else {
			LogError(0, RS_RET_INVALID_PARAMS,
						"omczmq: config error, unknown "
						"param %s in setModCnf\n",
						modpblk.descr[i].name);
		}
	}

	DBGPRINTF("omczmq: authenticator set to %d\n", runModConf-&gt;authenticator);
	DBGPRINTF("omczmq: authType set to %s\n", runModConf-&gt;authType);
	DBGPRINTF("omczmq: serverCertPath set to %s\n", runModConf-&gt;serverCertPath);
	DBGPRINTF("omczmq: clientCertPath set to %s\n", runModConf-&gt;clientCertPath);

finalize_it:
		if(pvals != NULL)
			cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf

BEGINendCnfLoad
CODESTARTendCnfLoad
	runModConf = NULL;
ENDendCnfLoad


BEGINdoAction
	instanceData *pData;
CODESTARTdoAction
	pthread_mutex_lock(&amp;mutDoAct);
	pData = pWrkrData-&gt;pData;
	iRet = outputCZMQ(ppString, pData);
	pthread_mutex_unlock(&amp;mutDoAct);
ENDdoAction


BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
	int iNumTpls;
CODESTARTnewActInst
	if ((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	for(i = 0; i &lt; actpblk.nParams; ++i) {
		if(!pvals[i].bUsed) {
			continue;
<a name="3"></a>		}

		if(!strcmp(actpblk.descr[i].name, "endpoints")) {
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>			pData-&gt;sockEndpoints = es_str2cstr(pvals[i].val.d.estr, NULL);
			DBGPRINTF("omczmq: sockEndPoints set to '%s'\n", pData-&gt;sockEndpoints);
		}
		else if(!strcmp(actpblk.descr[i].name, "template")) {
			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			DBGPRINTF("omczmq: template set to '%s'\n", pData-&gt;tplName);
		}
		else if(!strcmp(actpblk.descr[i].name, "dynatopic")) {
			pData-&gt;dynaTopic = pvals[i].val.d.n;</b></font>
			DBGPRINTF("omczmq: dynaTopic set to %s\n", pData-&gt;dynaTopic ? "true" : "false");
		}
		else if(!strcmp(actpblk.descr[i].name, "sendtimeout")) {
			pData-&gt;sendTimeout = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
			DBGPRINTF("omczmq: sendTimeout set to %d\n", pData-&gt;sendTimeout);
		}
		else if(!strcmp(actpblk.descr[i].name, "sendhwm")) {
			pData-&gt;sendTimeout = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
			DBGPRINTF("omczmq: sendHWM set to %d\n", pData-&gt;sendHWM);
		}
#if (CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
		else if(!strcmp(actpblk.descr[i].name, "heartbeativl")) {
			pData-&gt;heartbeatIvl = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
			DBGPRINTF("omczmq: heartbeatbeatIvl set to %d\n", pData-&gt;heartbeatIvl);
		}
		else if(!strcmp(actpblk.descr[i].name, "heartbeattimeout")) {
			pData-&gt;heartbeatTimeout = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
			DBGPRINTF("omczmq: heartbeatTimeout set to %d\n", pData-&gt;heartbeatTimeout);
		}
		else if(!strcmp(actpblk.descr[i].name, "heartbeatttl")) {
			pData-&gt;heartbeatTimeout = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
			DBGPRINTF("omczmq: heartbeatTTL set to %d\n", pData-&gt;heartbeatTTL);
		}
#endif
		else if(!strcmp(actpblk.descr[i].name, "socktype")){
			char *stringType = es_str2cstr(pvals[i].val.d.estr, NULL);
			if(stringType != NULL){
				if(!strcmp("PUB", stringType)) {
					pData-&gt;sockType = ZMQ_PUB;
					DBGPRINTF("omczmq: sockType set to ZMQ_PUB\n");
				}
#if defined(ZMQ_RADIO)
				else if(!strcmp("RADIO", stringType)) {
					pData-&gt;sockType = ZMQ_RADIO;
					DBGPRINTF("omczmq: sockType set to ZMQ_RADIO\n");
				}
#endif
				else if(!strcmp("PUSH", stringType)) {
					pData-&gt;sockType = ZMQ_PUSH;
					DBGPRINTF("omczmq: sockType set to ZMQ_PUSH\n");
				}
#if defined(ZMQ_SCATTER)
				else if(!strcmp("SCATTER", stringType)) {
					pData-&gt;sockType = ZMQ_SCATTER;
					DBGPRINTF("omczmq: sockType set to ZMQ_SCATTER\n");
				}
#endif
				else if(!strcmp("DEALER", stringType)) {
					pData-&gt;sockType = ZMQ_DEALER;
					DBGPRINTF("omczmq: sockType set to ZMQ_DEALER\n");
				}
#if defined(ZMQ_CLIENT)
				else if(!strcmp("CLIENT", stringType)) {
					pData-&gt;sockType = ZMQ_CLIENT;
					DBGPRINTF("omczmq: sockType set to ZMQ_CLIENT\n");
				}
#endif
				free(stringType);
			}
			else{
				LogError(0, RS_RET_OUT_OF_MEMORY,
						"omczmq: out of memory");
				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
			}
		}
		else if(!strcmp(actpblk.descr[i].name, "topicframe")) {
			pData-&gt;topicFrame = pvals[i].val.d.n;
			DBGPRINTF("omczmq: topicFrame set to %s\n", pData-&gt;topicFrame ? "true" : "false");
		}
		else if(!strcmp(actpblk.descr[i].name, "topics")) {
			pData-&gt;topics = zlist_new();
			char *topics = es_str2cstr(pvals[i].val.d.estr, NULL);
			DBGPRINTF("omczmq: topics set to %s\n", topics);
			char *topics_org = topics;
			char topic[256];
			if(topics == NULL){
				LogError(0, RS_RET_OUT_OF_MEMORY,
					"out of memory");
				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
			}

			while(*topics) {
				char *delimiter = strchr(topics, ',');
				if (!delimiter) {
					delimiter = topics + strlen(topics);
				}
				memcpy (topic, topics, delimiter - topics);
				topic[delimiter-topics] = 0;
				char *current_topic = strdup(topic);
				zlist_append (pData-&gt;topics, current_topic);
				if(*delimiter == 0) {
					break;
				}
				topics = delimiter + 1;
			}
			free(topics_org);

		}
		else {
			LogError(0, NO_ERRCODE,
					"omczmq: config error - '%s' is not a valid option",
					actpblk.descr[i].name);
			ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
		}
	}

	iNumTpls = 1;
	if (pData-&gt;dynaTopic) {
		iNumTpls = zlist_size (pData-&gt;topics) + iNumTpls;
	}
	CODE_STD_STRING_REQUESTnewActInst(iNumTpls)
	
	if (pData-&gt;tplName == NULL) {
		CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)strdup("RSYSLOG_ForwardFormat"),
					OMSR_NO_RQD_TPL_OPTS));
	}
	else {
		CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)pData-&gt;tplName, OMSR_NO_RQD_TPL_OPTS));
	}

	i = 1;
	if (pData-&gt;dynaTopic) {
		char *topic = zlist_first(pData-&gt;topics);
		while (topic) {
			CHKiRet(OMSRsetEntry(*ppOMSR, i, (uchar*)strdup(topic), OMSR_NO_RQD_TPL_OPTS));
			i++;
			topic = zlist_next(pData-&gt;topics);
		}
	}

	CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst

BEGINinitConfVars
CODESTARTinitConfVars
ENDinitConfVars

NO_LEGACY_CONF_parseSelectorAct

BEGINmodExit
CODESTARTmodExit
ENDmodExit

BEGINqueryEtryPt
CODESTARTqueryEtryPt
	CODEqueryEtryPt_STD_OMOD_QUERIES
	CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
	CODEqueryEtryPt_STD_CONF2_QUERIES
	CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
	CODEqueryEtryPt_STD_OMOD8_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
CODEmodInit_QueryRegCFSLineHdlr
	INITChkCoreFeature(bCoreSupportsBatching, CORE_FEATURE_BATCHING);
	DBGPRINTF("omczmq: module compiled with rsyslog version %s.\n", VERSION);

	INITLegCnfVars
ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>imudp.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* imudp.c
 * This is the implementation of the UDP input module.
 *
 * NOTE: read comments in module-template.h to understand how this file
 *       works!
 *
 * Copyright 2007-2018 Rainer Gerhards and Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Rsyslog is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Rsyslog is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Rsyslog.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 * A copy of the GPL can be found in the file "COPYING" in this distribution.
 */
#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;pthread.h&gt;
#include &lt;signal.h&gt;
#include &lt;poll.h&gt;
#ifdef HAVE_SYS_EPOLL_H
#	include &lt;sys/epoll.h&gt;
#endif
#ifdef HAVE_SCHED_H
#	include &lt;sched.h&gt;
#endif
#ifdef HAVE_SYS_PRCTL_H
#  include &lt;sys/prctl.h&gt;
#endif
#include "rsyslog.h"
#include "dirty.h"
#include "net.h"
#include "cfsysline.h"
#include "module-template.h"
#include "srUtils.h"
#include "errmsg.h"
#include "glbl.h"
#include "msg.h"
#include "parser.h"
#include "datetime.h"
#include "prop.h"
#include "ruleset.h"
#include "statsobj.h"
#include "ratelimit.h"
#include "unicode-helper.h"

MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("imudp")

/* defines */
#define MAX_WRKR_THREADS 32

/* Module static data */
DEF_IMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(net)
DEFobjCurrIf(datetime)
DEFobjCurrIf(prop)
DEFobjCurrIf(ruleset)
DEFobjCurrIf(statsobj)


static struct lstn_s {
	struct lstn_s *next;
	int sock;		/* socket */
	ruleset_t *pRuleset;	/* bound ruleset */
	prop_t *pInputName;
	statsobj_t *stats;	/* listener stats */
	ratelimit_t *ratelimiter;
	uchar *dfltTZ;
	STATSCOUNTER_DEF(ctrSubmit, mutCtrSubmit)
	STATSCOUNTER_DEF(ctrDisallowed, mutCtrDisallowed)
} *lcnfRoot = NULL, *lcnfLast = NULL;


static int bLegacyCnfModGlobalsPermitted;/* are legacy module-global config parameters permitted? */
static int bDoACLCheck;			/* are ACL checks neeed? Cached once immediately before listener startup */
static int iMaxLine;			/* maximum UDP message size supported */
#define BATCH_SIZE_DFLT 32		/* do not overdo, has heavy toll on memory, especially with large msgs */
#define TIME_REQUERY_DFLT 2
#define SCHED_PRIO_UNSET -12345678	/* a value that indicates that the scheduling priority has not been set */
/* config vars for legacy config system */
static struct configSettings_s {
	uchar *pszBindAddr;		/* IP to bind socket to */
	char  *pszBindDevice;		/* Device to bind socket to */
	uchar *pszSchedPolicy;		/* scheduling policy string */
	uchar *pszBindRuleset;		/* name of Ruleset to bind to */
	int iSchedPrio;			/* scheduling priority */
	int iTimeRequery;		/* how often is time to be queried inside tight recv loop? 0=always */
} cs;

struct instanceConf_s {
	uchar *pszBindAddr;		/* IP to bind socket to */
	char  *pszBindDevice;		/* Device to bind socket to */
	uchar *pszBindPort;		/* Port to bind socket to */
	uchar *pszBindRuleset;		/* name of ruleset to bind to */
	uchar *inputname;
	ruleset_t *pBindRuleset;	/* ruleset to bind listener to (use system default if unspecified) */
	uchar *dfltTZ;
	unsigned int ratelimitInterval;
	unsigned int ratelimitBurst;
	int rcvbuf;			/* 0 means: do not set, keep OS default */
	/*  0 means:  IP_FREEBIND is disabled
	1 means:  IP_FREEBIND enabled + warning disabled
	1+ means: IP+FREEBIND enabled + warning enabled */
	int ipfreebind;
	struct instanceConf_s *next;
	sbool bAppendPortToInpname;
};

/* The following structure controls the worker threads. Global data is
 * needed for their access.
 */
static struct wrkrInfo_s {
	pthread_t tid;	/* the worker's thread ID */
	int id;
	thrdInfo_t *pThrd;
	statsobj_t *stats;	/* worker thread stats */
	STATSCOUNTER_DEF(ctrCall_recvmmsg, mutCtrCall_recvmmsg)
	STATSCOUNTER_DEF(ctrCall_recvmsg, mutCtrCall_recvmsg)
	STATSCOUNTER_DEF(ctrMsgsRcvd, mutCtrMsgsRcvd)
	uchar *pRcvBuf;		/* receive buffer (for a single packet) */
#	ifdef HAVE_RECVMMSG
	struct sockaddr_storage *frominet;
	struct mmsghdr *recvmsg_mmh;
	struct iovec *recvmsg_iov;
#	endif
} wrkrInfo[MAX_WRKR_THREADS];

struct modConfData_s {
	rsconf_t *pConf;		/* our overall config object */
	instanceConf_t *root, *tail;
	uchar *pszSchedPolicy;		/* scheduling policy string */
	int iSchedPolicy;		/* scheduling policy as SCHED_xxx */
	int iSchedPrio;			/* scheduling priority */
	int iTimeRequery;		/* how often is time to be queried inside tight recv loop? 0=always */
	int batchSize;			/* max nbr of input batch --&gt; also recvmmsg() max count */
	int8_t wrkrMax;			/* max nbr of worker threads */
	sbool configSetViaV2Method;
	sbool bPreserveCase;	/* preserves the case of fromhost; "off" by default */
};
static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current load process */

/* module-global parameters */
<a name="2"></a>static struct cnfparamdescr modpdescr[] = {
	{ "schedulingpolicy", eCmdHdlrGetWord, 0 },
	{ "schedulingpriority", eCmdHdlrInt, 0 },
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "batchsize", eCmdHdlrInt, 0 },
	{ "threads", eCmdHdlrPositiveInt, 0 },
	{ "timerequery", eCmdHdlrInt, 0 },
	{ "preservecase", eCmdHdlrBinary, 0 }
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};</b></font>

<a name="0"></a>/* input instance parameters */
static struct cnfparamdescr inppdescr[] = {
	{ "port", eCmdHdlrArray, CNFPARAM_REQUIRED }, /* legacy: InputTCPServerRun */
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "defaulttz", eCmdHdlrString, 0 },
	{ "inputname", eCmdHdlrGetWord, 0 },
	{ "inputname.appendport", eCmdHdlrBinary, 0 },
	{ "name", eCmdHdlrGetWord, 0 },
	{ "name.appendport", eCmdHdlrBinary, 0 },
	{ "address", eCmdHdlrString, 0 },
	{ "device", eCmdHdlrString, 0 },
	{ "ratelimit.interval", eCmdHdlrInt, 0 },
	{ "ratelimit.burst", eCmdHdlrInt, 0 },
	{ "rcvbufsize", eCmdHdlrSize, 0 },
	{ "ipfreebind", eCmdHdlrInt, 0 },
	{ "ruleset", eCmdHdlrString, 0 }
};
static struct cnfparamblk inppblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
	  inppdescr
	};

#include "im-helper.h" /* must be included AFTER the type definitions! */


/* create input instance, set default parameters, and
 * add it to the list of instances.
 */
static rsRetVal
createInstance(instanceConf_t **pinst)
{</b></font>
	instanceConf_t *inst;
	DEFiRet;
	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
	inst-&gt;next = NULL;
	inst-&gt;pBindRuleset = NULL;

	inst-&gt;pszBindPort = NULL;
	inst-&gt;pszBindAddr = NULL;
	inst-&gt;pszBindDevice = NULL;
	inst-&gt;pszBindRuleset = NULL;
	inst-&gt;inputname = NULL;
	inst-&gt;bAppendPortToInpname = 0;
	inst-&gt;ratelimitBurst = 10000; /* arbitrary high limit */
	inst-&gt;ratelimitInterval = 0; /* off */
	inst-&gt;rcvbuf = 0;
	inst-&gt;ipfreebind = IPFREEBIND_ENABLED_WITH_LOG;
	inst-&gt;dfltTZ = NULL;

	/* node created, let's add to config */
	if(loadModConf-&gt;tail == NULL) {
		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
	} else {
		loadModConf-&gt;tail-&gt;next = inst;
		loadModConf-&gt;tail = inst;
	}

	*pinst = inst;
finalize_it:
	RETiRet;
}

/* This function is called when a new listener instace shall be added to
 * the current config object via the legacy config system. It just shuffles
 * all parameters to the listener in-memory instance.
 * rgerhards, 2011-05-04
 */
static rsRetVal addInstance(void __attribute__((unused)) *pVal, uchar *pNewVal)
{
	instanceConf_t *inst;
	DEFiRet;

	CHKiRet(createInstance(&amp;inst));
	CHKmalloc(inst-&gt;pszBindPort = ustrdup((pNewVal == NULL || *pNewVal == '\0')
				 	       ? (uchar*) "514" : pNewVal));
	if((cs.pszBindAddr == NULL) || (cs.pszBindAddr[0] == '\0')) {
		inst-&gt;pszBindAddr = NULL;
	} else {
		CHKmalloc(inst-&gt;pszBindAddr = ustrdup(cs.pszBindAddr));
	}
	if((cs.pszBindDevice == NULL) || (cs.pszBindDevice[0] == '\0')) {
		inst-&gt;pszBindDevice= NULL;
	} else {
		CHKmalloc(inst-&gt;pszBindDevice = strdup(cs.pszBindDevice));
	}
	if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
		inst-&gt;pszBindRuleset = NULL;
	} else {
		CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));
	}

finalize_it:
	free(pNewVal);
	RETiRet;
}


/* This function is called when a new listener shall be added. It takes
 * the instance config description, tries to bind the socket and, if that
 * succeeds, adds it to the list of existing listen sockets.
 */
static rsRetVal
addListner(instanceConf_t *inst)
{
	DEFiRet;
	uchar *bindAddr;
	int *newSocks;
	int iSrc;
	struct lstn_s *newlcnfinfo;
	uchar *bindName;
	uchar *port;
	uchar dispname[64], inpnameBuf[128];
	uchar *inputname;

	/* check which address to bind to. We could do this more compact, but have not
	 * done so in order to make the code more readable. -- rgerhards, 2007-12-27
	 */
	if(inst-&gt;pszBindAddr == NULL)
		bindAddr = NULL;
	else if(inst-&gt;pszBindAddr[0] == '*' &amp;&amp; inst-&gt;pszBindAddr[1] == '\0')
		bindAddr = NULL;
	else
		bindAddr = inst-&gt;pszBindAddr;
	bindName = (bindAddr == NULL) ? (uchar*)"*" : bindAddr;
	port = (inst-&gt;pszBindPort == NULL || *inst-&gt;pszBindPort == '\0') ? (uchar*) "514" : inst-&gt;pszBindPort;

	DBGPRINTF("Trying to open syslog UDP ports at %s:%s.\n", bindName, inst-&gt;pszBindPort);

	newSocks = net.create_udp_socket(bindAddr, port, 1, inst-&gt;rcvbuf, 0, inst-&gt;ipfreebind, inst-&gt;pszBindDevice);
	if(newSocks != NULL) {
		/* we now need to add the new sockets to the existing set */
		/* ready to copy */
		for(iSrc = 1 ; iSrc &lt;= newSocks[0] ; ++iSrc) {
			struct sockaddr_in sa;
			socklen_t salen = sizeof(sa);
			const char *suffix;
			CHKmalloc(newlcnfinfo = (struct lstn_s*) calloc(1, sizeof(struct lstn_s)));
			newlcnfinfo-&gt;next = NULL;
			newlcnfinfo-&gt;sock = newSocks[iSrc];
			newlcnfinfo-&gt;pRuleset = inst-&gt;pBindRuleset;
			newlcnfinfo-&gt;dfltTZ = inst-&gt;dfltTZ;
			newlcnfinfo-&gt;ratelimiter = NULL;
			/* query socket IPv4 vs IPv6 */
			sa.sin_family = 0; /* just to keep CLANG static analyzer happy! */
			if(getsockname(newlcnfinfo-&gt;sock, (struct sockaddr*) &amp;sa, &amp;salen) != 0) {
				suffix = "error_getting_AF...";
			} else {
				if(sa.sin_family == AF_INET) {
					suffix = "IPv4";
				} else if(sa.sin_family == AF_INET6) {
					suffix = "IPv6";
				} else {
					suffix = "AF_unknown";
				}
			}
			if(inst-&gt;inputname == NULL) {
				inputname = (uchar*)"imudp";
			} else {
				inputname = inst-&gt;inputname;
			}
			snprintf((char*)dispname, sizeof(dispname), "%s(%s/%s/%s)",
				inputname, bindName, port, suffix);
			dispname[sizeof(dispname)-1] = '\0'; /* just to be on the save side... */
			CHKiRet(ratelimitNew(&amp;newlcnfinfo-&gt;ratelimiter, (char*)dispname, NULL));
			ratelimitSetLinuxLike(newlcnfinfo-&gt;ratelimiter, inst-&gt;ratelimitInterval,
					      inst-&gt;ratelimitBurst);
			ratelimitSetThreadSafe(newlcnfinfo-&gt;ratelimiter);
			if(inst-&gt;bAppendPortToInpname) {
				snprintf((char*)inpnameBuf, sizeof(inpnameBuf), "%s%s",
					inputname, port);
				inpnameBuf[sizeof(inpnameBuf)-1] = '\0';
				inputname = inpnameBuf;
			}
			CHKiRet(prop.Construct(&amp;newlcnfinfo-&gt;pInputName));
			CHKiRet(prop.SetString(newlcnfinfo-&gt;pInputName,
				inputname, ustrlen(inputname)));
			CHKiRet(prop.ConstructFinalize(newlcnfinfo-&gt;pInputName));
			/* support statistics gathering */
			CHKiRet(statsobj.Construct(&amp;(newlcnfinfo-&gt;stats)));
			CHKiRet(statsobj.SetName(newlcnfinfo-&gt;stats, dispname));
			CHKiRet(statsobj.SetOrigin(newlcnfinfo-&gt;stats, (uchar*)"imudp"));
			STATSCOUNTER_INIT(newlcnfinfo-&gt;ctrSubmit, newlcnfinfo-&gt;mutCtrSubmit);
			CHKiRet(statsobj.AddCounter(newlcnfinfo-&gt;stats, UCHAR_CONSTANT("submitted"),
				ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(newlcnfinfo-&gt;ctrSubmit)));
			STATSCOUNTER_INIT(newlcnfinfo-&gt;ctrDisallowed, newlcnfinfo-&gt;mutCtrDisallowed);
			CHKiRet(statsobj.AddCounter(newlcnfinfo-&gt;stats, UCHAR_CONSTANT("disallowed"),
				ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(newlcnfinfo-&gt;ctrDisallowed)));
			CHKiRet(statsobj.ConstructFinalize(newlcnfinfo-&gt;stats));
			/* link to list. Order must be preserved to take care for
			 * conflicting matches.
			 */
			if(lcnfRoot == NULL)
				lcnfRoot = newlcnfinfo;
			if(lcnfLast == NULL)
				lcnfLast = newlcnfinfo;
			else {
				lcnfLast-&gt;next = newlcnfinfo;
				lcnfLast = newlcnfinfo;
			}
		}
	} else {
		LogError(0, NO_ERRCODE, "imudp: Could not create udp listener,"
				" ignoring port %s bind-address %s.",
				port, bindAddr);
	}

finalize_it:
	if(iRet != RS_RET_OK) {
		if(newlcnfinfo != NULL) {
			if(newlcnfinfo-&gt;ratelimiter != NULL)
				ratelimitDestruct(newlcnfinfo-&gt;ratelimiter);
			if(newlcnfinfo-&gt;pInputName != NULL)
				prop.Destruct(&amp;newlcnfinfo-&gt;pInputName);
			if(newlcnfinfo-&gt;stats != NULL)
				statsobj.Destruct(&amp;newlcnfinfo-&gt;stats);
			free(newlcnfinfo);
		}
		/* close the rest of the open sockets as there's
		   nowhere to put them */
		for(; iSrc &lt;= newSocks[0]; iSrc++) {
			close(newSocks[iSrc]);
		}
	}

	free(newSocks);
	RETiRet;
}


static inline void
std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
{
	LogError(0, NO_ERRCODE, "imudp: ruleset '%s' for %s:%s not found - "
			"using default ruleset instead", inst-&gt;pszBindRuleset,
			inst-&gt;pszBindAddr == NULL ? "*" : (char*) inst-&gt;pszBindAddr,
			inst-&gt;pszBindPort);
}


/* This function processes received data. It provides unified handling
 * in cases where recvmmsg() is available and not.
 */
static rsRetVal
processPacket(struct lstn_s *lstn, struct sockaddr_storage *frominetPrev, int *pbIsPermitted,
	uchar *rcvBuf, ssize_t lenRcvBuf, struct syslogTime *stTime, time_t ttGenTime,
	struct sockaddr_storage *frominet, socklen_t socklen, multi_submit_t *multiSub)
{
	DEFiRet;
	smsg_t *pMsg = NULL;

	if(lenRcvBuf == 0)
		FINALIZE; /* this looks a bit strange, but practice shows it happens... */

	/* if we reach this point, we had a good receive and can process the packet received */
	/* check if we have a different sender than before, if so, we need to query some new values */
	if(bDoACLCheck) {
		socklen = sizeof(struct sockaddr_storage);
		if(net.CmpHost(frominet, frominetPrev, socklen) != 0) {
			memcpy(frominetPrev, frominet, socklen); /* update cache indicator */
			/* Here we check if a host is permitted to send us syslog messages. If it isn't,
			 * we do not further process the message but log a warning (if we are
			 * configured to do this). However, if the check would require name resolution,
			 * it is postponed to the main queue. See also my blog post at
			 * http://blog.gerhards.net/2009/11/acls-imudp-and-accepting-messages.html
			 * rgerhards, 2009-11-16
			 */
			*pbIsPermitted = net.isAllowedSender2((uchar*)"UDP",
					    (struct sockaddr *)frominet, "", 0);

			if(*pbIsPermitted == 0) {
				DBGPRINTF("msg is not from an allowed sender\n");
				STATSCOUNTER_INC(lstn-&gt;ctrDisallowed, lstn-&gt;mutCtrDisallowed);
				if(glbl.GetOptionDisallowWarning(runModConf-&gt;pConf)) {
					LogError(0, NO_ERRCODE,
						"imudp: UDP message from disallowed sender discarded");
				}
			}
		}
	} else {
		*pbIsPermitted = 1; /* no check -&gt; everything permitted */
	}

	DBGPRINTF("recv(%d,%d),acl:%d,msg:%.*s\n", lstn-&gt;sock, (int) lenRcvBuf, *pbIsPermitted,
			(int)lenRcvBuf, rcvBuf);

	if(*pbIsPermitted != 0)  {
		/* we now create our own message object and submit it to the queue */
		CHKiRet(msgConstructWithTime(&amp;pMsg, stTime, ttGenTime));
		MsgSetRawMsg(pMsg, (char*)rcvBuf, lenRcvBuf);
		MsgSetInputName(pMsg, lstn-&gt;pInputName);
		MsgSetRuleset(pMsg, lstn-&gt;pRuleset);
		MsgSetFlowControlType(pMsg, eFLOWCTL_NO_DELAY);
		if(lstn-&gt;dfltTZ != NULL)
			MsgSetDfltTZ(pMsg, (char*) lstn-&gt;dfltTZ);
		pMsg-&gt;msgFlags  = NEEDS_PARSING | PARSE_HOSTNAME | NEEDS_DNSRESOL;
		if(*pbIsPermitted == 2) {
			pMsg-&gt;msgFlags |= NEEDS_ACLCHK_U; /* request ACL check after resolution */
		}
		if(runModConf-&gt;bPreserveCase) {
			pMsg-&gt;msgFlags |= PRESERVE_CASE; /* preserve case of fromhost */
		}
		CHKiRet(msgSetFromSockinfo(pMsg, frominet));
		CHKiRet(ratelimitAddMsg(lstn-&gt;ratelimiter, multiSub, pMsg));
		STATSCOUNTER_INC(lstn-&gt;ctrSubmit, lstn-&gt;mutCtrSubmit);
	}

finalize_it:
	if(iRet != RS_RET_OK) {
		if(pMsg != NULL &amp;&amp; iRet != RS_RET_DISCARDMSG) {
			msgDestruct(&amp;pMsg);
		}
	}

	RETiRet;
}




/* The following "two" functions are helpers to runInput. Actually, it is
 * just one function. Depending on whether or not we have recvmmsg(),
 * an appropriate version is compiled (as such we need to maintain both!).
 */
#ifdef HAVE_RECVMMSG
static rsRetVal
processSocket(struct wrkrInfo_s *pWrkr, struct lstn_s *lstn, struct sockaddr_storage *frominetPrev,
int *pbIsPermitted)
{
	DEFiRet;
	int iNbrTimeUsed;
	time_t ttGenTime = 0; /* to avoid clang static analyzer false positive */
		/* note: we do never use this time, because we always get a
		 * requery below on first loop iteration */
	struct syslogTime stTime;
	char errStr[1024];
	smsg_t *pMsgs[CONF_NUM_MULTISUB];
	multi_submit_t multiSub;
	int nelem;
	int i;

	multiSub.ppMsgs = pMsgs;
	multiSub.maxElem = CONF_NUM_MULTISUB;
	multiSub.nElem = 0;
	iNbrTimeUsed = 0;
	while(1) { /* loop is terminated if we have a "bad" receive, done below in the body */
		if(pWrkr-&gt;pThrd-&gt;bShallStop == RSTRUE)
			ABORT_FINALIZE(RS_RET_FORCE_TERM);
		memset(pWrkr-&gt;recvmsg_iov, 0, runModConf-&gt;batchSize * sizeof(struct iovec));
		memset(pWrkr-&gt;recvmsg_mmh, 0, runModConf-&gt;batchSize * sizeof(struct mmsghdr));
		for(i = 0 ; i &lt; runModConf-&gt;batchSize ; ++i) {
			pWrkr-&gt;recvmsg_iov[i].iov_base = pWrkr-&gt;pRcvBuf+(i*(iMaxLine+1));
			pWrkr-&gt;recvmsg_iov[i].iov_len = iMaxLine;
			pWrkr-&gt;recvmsg_mmh[i].msg_hdr.msg_namelen = sizeof(struct sockaddr_storage);
			pWrkr-&gt;recvmsg_mmh[i].msg_hdr.msg_name = &amp;(pWrkr-&gt;frominet[i]);
			pWrkr-&gt;recvmsg_mmh[i].msg_hdr.msg_iov = &amp;(pWrkr-&gt;recvmsg_iov[i]);
			pWrkr-&gt;recvmsg_mmh[i].msg_hdr.msg_iovlen = 1;
		}
		nelem = recvmmsg(lstn-&gt;sock, pWrkr-&gt;recvmsg_mmh, runModConf-&gt;batchSize, 0, NULL);
		STATSCOUNTER_INC(pWrkr-&gt;ctrCall_recvmmsg, pWrkr-&gt;mutCtrCall_recvmmsg);
		DBGPRINTF("imudp: recvmmsg returned %d\n", nelem);
		if(nelem &lt; 0 &amp;&amp; errno == ENOSYS) {
			/* be careful: some versions of valgrind do not support recvmmsg()! */
			DBGPRINTF("imudp: error ENOSYS on call to recvmmsg() - fall back to recvmsg\n");
			nelem = recvmsg(lstn-&gt;sock, &amp;(pWrkr-&gt;recvmsg_mmh[0].msg_hdr), 0);
			STATSCOUNTER_INC(pWrkr-&gt;ctrCall_recvmsg, pWrkr-&gt;mutCtrCall_recvmsg);
			if(nelem &gt;= 0) {
				pWrkr-&gt;recvmsg_mmh[0].msg_len = nelem;
				nelem = 1;
			}
		}
		if(nelem &lt; 0) {
			if(errno != EINTR &amp;&amp; errno != EAGAIN) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				DBGPRINTF("INET socket error: %d = %s.\n", errno, errStr);
				LogError(errno, NO_ERRCODE, "imudp: error receiving on socket: %s", errStr);
			}
			ABORT_FINALIZE(RS_RET_ERR);
			// this most often is NOT an error, state is not checked by caller!
		}

		if((runModConf-&gt;iTimeRequery == 0) || (iNbrTimeUsed++ % runModConf-&gt;iTimeRequery) == 0) {
			datetime.getCurrTime(&amp;stTime, &amp;ttGenTime, TIME_IN_LOCALTIME);
		}

		pWrkr-&gt;ctrMsgsRcvd += nelem;
		for(i = 0 ; i &lt; nelem ; ++i) {
			processPacket(lstn, frominetPrev, pbIsPermitted,
				pWrkr-&gt;recvmsg_mmh[i].msg_hdr.msg_iov-&gt;iov_base,
				pWrkr-&gt;recvmsg_mmh[i].msg_len, &amp;stTime, ttGenTime, &amp;(pWrkr-&gt;frominet[i]),
				pWrkr-&gt;recvmsg_mmh[i].msg_hdr.msg_namelen, &amp;multiSub);
		}
	}

finalize_it:
	multiSubmitFlush(&amp;multiSub);
	RETiRet;
}
#else /* we do not have recvmmsg() */
/* This function is a helper to runInput. I have extracted it
 * from the main loop just so that we do not have that large amount of code
 * in a single place. This function takes a socket and pulls messages from
 * it until the socket does not have any more waiting.
 * rgerhards, 2008-01-08
 * We try to read from the file descriptor until there
 * is no more data. This is done in the hope to get better performance
 * out of the system. However, this also means that a descriptor
 * monopolizes processing while it contains data. This can lead to
 * data loss in other descriptors. However, if the system is incapable of
 * handling the workload, we will loss data in any case. So it doesn't really
 * matter where the actual loss occurs - it is always random, because we depend
 * on scheduling order. -- rgerhards, 2008-10-02
 */
static rsRetVal
processSocket(struct wrkrInfo_s *pWrkr, struct lstn_s *lstn, struct sockaddr_storage *frominetPrev,
int *pbIsPermitted)
{
	int iNbrTimeUsed;
	time_t ttGenTime;
	struct syslogTime stTime;
	ssize_t lenRcvBuf;
	struct sockaddr_storage frominet;
	multi_submit_t multiSub;
	smsg_t *pMsgs[CONF_NUM_MULTISUB];
	char errStr[1024];
	struct msghdr mh;
	struct iovec iov[1];
	DEFiRet;

	multiSub.ppMsgs = pMsgs;
	multiSub.maxElem = CONF_NUM_MULTISUB;
	multiSub.nElem = 0;
	iNbrTimeUsed = 0;
	while(1) { /* loop is terminated if we have a bad receive, done below in the body */
		if(pWrkr-&gt;pThrd-&gt;bShallStop == RSTRUE)
			ABORT_FINALIZE(RS_RET_FORCE_TERM);
		memset(iov, 0, sizeof(iov));
		iov[0].iov_base = pWrkr-&gt;pRcvBuf;
		iov[0].iov_len = iMaxLine;
		memset(&amp;mh, 0, sizeof(mh));
		mh.msg_name = &amp;frominet;
		mh.msg_namelen = sizeof(struct sockaddr_storage);
		mh.msg_iov = iov;
		mh.msg_iovlen = 1;
		lenRcvBuf = recvmsg(lstn-&gt;sock, &amp;mh, 0);
		STATSCOUNTER_INC(pWrkr-&gt;ctrCall_recvmsg, pWrkr-&gt;mutCtrCall_recvmsg);
		if(lenRcvBuf &lt; 0) {
			if(errno != EINTR &amp;&amp; errno != EAGAIN) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				DBGPRINTF("INET socket error: %d = %s.\n", errno, errStr);
				LogError(errno, NO_ERRCODE, "imudp: error receiving on socket: %s", errStr);
			}
			ABORT_FINALIZE(RS_RET_ERR);
			// this most often is NOT an error, state is not checked by caller!
		}

		++pWrkr-&gt;ctrMsgsRcvd;
		if((runModConf-&gt;iTimeRequery == 0) || (iNbrTimeUsed++ % runModConf-&gt;iTimeRequery) == 0) {
			datetime.getCurrTime(&amp;stTime, &amp;ttGenTime, TIME_IN_LOCALTIME);
		}

		CHKiRet(processPacket(lstn, frominetPrev, pbIsPermitted, pWrkr-&gt;pRcvBuf, lenRcvBuf, &amp;stTime,
			ttGenTime, &amp;frominet, mh.msg_namelen, &amp;multiSub));
	}


finalize_it:
	multiSubmitFlush(&amp;multiSub);
	RETiRet;
}
#endif /* #ifdef HAVE_RECVMMSG */


/* check configured scheduling priority.
 * Precondition: iSchedPolicy must have been set
 */
static rsRetVal
checkSchedulingPriority(modConfData_t *modConf)
{
	DEFiRet;

#ifdef HAVE_SCHED_GET_PRIORITY_MAX
	if(   modConf-&gt;iSchedPrio &lt; sched_get_priority_min(modConf-&gt;iSchedPolicy)
	   || modConf-&gt;iSchedPrio &gt; sched_get_priority_max(modConf-&gt;iSchedPolicy)) {
		LogError(0, NO_ERRCODE,
			"imudp: scheduling priority %d out of range (%d - %d)"
			" for scheduling policy '%s' - ignoring settings",
			modConf-&gt;iSchedPrio,
			sched_get_priority_min(modConf-&gt;iSchedPolicy),
			sched_get_priority_max(modConf-&gt;iSchedPolicy),
			modConf-&gt;pszSchedPolicy);
		ABORT_FINALIZE(RS_RET_VALIDATION_RUN);
	}
finalize_it:
#endif
	RETiRet;
}


/* check scheduling policy string and, if valid, set its
 * numeric equivalent in current load config
 */
static rsRetVal
checkSchedulingPolicy(modConfData_t *modConf)
{
	DEFiRet;

	if (0) { /* trick to use conditional compilation */
#ifdef SCHED_FIFO
	} else if (!strcasecmp((char*)modConf-&gt;pszSchedPolicy, "fifo")) {
		modConf-&gt;iSchedPolicy = SCHED_FIFO;
#endif
#ifdef SCHED_RR
	} else if (!strcasecmp((char*)modConf-&gt;pszSchedPolicy, "rr")) {
		modConf-&gt;iSchedPolicy = SCHED_RR;
#endif
#ifdef SCHED_OTHER
	} else if (!strcasecmp((char*)modConf-&gt;pszSchedPolicy, "other")) {
		modConf-&gt;iSchedPolicy = SCHED_OTHER;
#endif
	} else {
		LogError(errno, NO_ERRCODE,
			    "imudp: invalid scheduling policy '%s' "
			    "- ignoring setting", modConf-&gt;pszSchedPolicy);
		ABORT_FINALIZE(RS_RET_ERR_SCHED_PARAMS);
	}
finalize_it:
	RETiRet;
}

/* checks scheduling parameters during config check phase */
static rsRetVal
checkSchedParam(modConfData_t *modConf)
{
	DEFiRet;

	if(modConf-&gt;pszSchedPolicy != NULL &amp;&amp; modConf-&gt;iSchedPrio == SCHED_PRIO_UNSET) {
		LogError(0, RS_RET_ERR_SCHED_PARAMS,
			"imudp: scheduling policy set, but without priority - ignoring settings");
		ABORT_FINALIZE(RS_RET_ERR_SCHED_PARAMS);
	} else if(modConf-&gt;pszSchedPolicy == NULL &amp;&amp; modConf-&gt;iSchedPrio != SCHED_PRIO_UNSET) {
		LogError(0, RS_RET_ERR_SCHED_PARAMS,
			"imudp: scheduling priority set, but without policy - ignoring settings");
		ABORT_FINALIZE(RS_RET_ERR_SCHED_PARAMS);
	} else if(modConf-&gt;pszSchedPolicy != NULL &amp;&amp; modConf-&gt;iSchedPrio != SCHED_PRIO_UNSET) {
		/* we have parameters set, so check them */
		CHKiRet(checkSchedulingPolicy(modConf));
		CHKiRet(checkSchedulingPriority(modConf));
	} else { /* nothing set */
		modConf-&gt;iSchedPrio = SCHED_PRIO_UNSET; /* prevents doing the activation call */
	}
#ifndef HAVE_PTHREAD_SETSCHEDPARAM
	LogError(0, NO_ERRCODE,
		"imudp: cannot set thread scheduling policy, "
		"pthread_setschedparam() not available");
	ABORT_FINALIZE(RS_RET_ERR_SCHED_PARAMS);
#endif

finalize_it:
	if(iRet != RS_RET_OK)
		modConf-&gt;iSchedPrio = SCHED_PRIO_UNSET; /* prevents doing the activation call */

	RETiRet;
}

/* set the configured scheduling policy (if possible) */
static rsRetVal
setSchedParams(modConfData_t *modConf)
{
	DEFiRet;

#	ifdef HAVE_PTHREAD_SETSCHEDPARAM
	int err;
	struct sched_param sparam;

	if(modConf-&gt;iSchedPrio == SCHED_PRIO_UNSET)
		FINALIZE;

	memset(&amp;sparam, 0, sizeof sparam);
	sparam.sched_priority = modConf-&gt;iSchedPrio;
	dbgprintf("imudp trying to set sched policy to '%s', prio %d\n",
		  modConf-&gt;pszSchedPolicy, modConf-&gt;iSchedPrio);
	err = pthread_setschedparam(pthread_self(), modConf-&gt;iSchedPolicy, &amp;sparam);
	if(err != 0) {
		LogError(err, NO_ERRCODE, "imudp: pthread_setschedparam() failed - ignoring");
	}
finalize_it:
#	endif

	RETiRet;
}


/* This function implements the main reception loop. Depending on the environment,
 * we either use the traditional (but slower) select() or the Linux-specific epoll()
 * interface. ./configure settings control which one is used.
 * rgerhards, 2009-09-09
 */
#if defined(HAVE_EPOLL_CREATE1) || defined(HAVE_EPOLL_CREATE)
#define NUM_EPOLL_EVENTS 10
static rsRetVal
rcvMainLoop(struct wrkrInfo_s *const __restrict__ pWrkr)
{
	DEFiRet;
	int nfds;
	int efd;
	int i;
	struct sockaddr_storage frominetPrev;
	int bIsPermitted;
	struct epoll_event *udpEPollEvt = NULL;
	struct epoll_event currEvt[NUM_EPOLL_EVENTS];
	char errStr[1024];
	struct lstn_s *lstn;
	int nLstn;

	/* start "name caching" algo by making sure the previous system indicator
	 * is invalidated.
	 */
	bIsPermitted = 0;
	memset(&amp;frominetPrev, 0, sizeof(frominetPrev));

	/* count num listeners -- do it here in order to avoid inconsistency */
	nLstn = 0;
	for(lstn = lcnfRoot ; lstn != NULL ; lstn = lstn-&gt;next)
		++nLstn;

	if(nLstn == 0) {
		LogError(errno, RS_RET_ERR,
			"imudp error: we have 0 listeners, terminating"
			"worker thread");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	CHKmalloc(udpEPollEvt = calloc(nLstn, sizeof(struct epoll_event)));

#if defined(EPOLL_CLOEXEC) &amp;&amp; defined(HAVE_EPOLL_CREATE1)
	DBGPRINTF("imudp uses epoll_create1()\n");
	efd = epoll_create1(EPOLL_CLOEXEC);
	if(efd &lt; 0 &amp;&amp; errno == ENOSYS)
#endif
	{
		DBGPRINTF("imudp uses epoll_create()\n");
		efd = epoll_create(NUM_EPOLL_EVENTS);
	}

	if(efd &lt; 0) {
		DBGPRINTF("epoll_create1() could not create fd\n");
		ABORT_FINALIZE(RS_RET_IO_ERROR);
	}

	/* fill the epoll set - we need to do this only once, as the set
	 * can not change dyamically.
	 */
	i = 0;
	for(lstn = lcnfRoot ; lstn != NULL ; lstn = lstn-&gt;next) {
		if(lstn-&gt;sock != -1) {
			udpEPollEvt[i].events = EPOLLIN | EPOLLET;
			udpEPollEvt[i].data.ptr = lstn;
			if(epoll_ctl(efd, EPOLL_CTL_ADD,  lstn-&gt;sock, &amp;(udpEPollEvt[i])) &lt; 0) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				LogError(errno, NO_ERRCODE, "epoll_ctrl failed on fd %d with %s\n",
					lstn-&gt;sock, errStr);
			}
		}
		i++;
	}

	while(1) {
		/* wait for io to become ready */
		nfds = epoll_wait(efd, currEvt, NUM_EPOLL_EVENTS, -1);
		DBGPRINTF("imudp: epoll_wait() returned with %d fds\n", nfds);

		if(pWrkr-&gt;pThrd-&gt;bShallStop == RSTRUE)
			break; /* terminate input! */

		for(i = 0 ; i &lt; nfds ; ++i) {
			processSocket(pWrkr, currEvt[i].data.ptr, &amp;frominetPrev, &amp;bIsPermitted);
		}
		if(pWrkr-&gt;pThrd-&gt;bShallStop == RSTRUE)
			break; /* terminate input! */
	}

finalize_it:
	if(udpEPollEvt != NULL)
		free(udpEPollEvt);

	RETiRet;
}
#else /* #if HAVE_EPOLL_CREATE1 */
/* this is the code for the select() interface */
static rsRetVal ATTR_NONNULL()
rcvMainLoop(struct wrkrInfo_s *const __restrict__ pWrkr)
{
	DEFiRet;
	int nfds;
	struct sockaddr_storage frominetPrev;
	int bIsPermitted;
	int i = 0;
	struct lstn_s *lstn;

	DBGPRINTF("imudp uses poll() [ex-select]\n");
	/* start "name caching" algo by making sure the previous system indicator
	 * is invalidated. */
	bIsPermitted = 0;
	memset(&amp;frominetPrev, 0, sizeof(frominetPrev));

	/* setup poll() subsystem */
	int nfd = 0;
	for(lstn = lcnfRoot ; lstn != NULL ; lstn = lstn-&gt;next) {
		if(lstn-&gt;sock != -1) {
			if(Debug) {
				net.debugListenInfo(lstn-&gt;sock, (char*)"UDP");
			}
			++nfd;
		}
	}
	struct pollfd *const pollfds = calloc(nfd, sizeof(struct pollfd));
	CHKmalloc(pollfds);

	for(lstn = lcnfRoot ; lstn != NULL ; lstn = lstn-&gt;next) {
		assert(i &lt; nfd);
		if (lstn-&gt;sock != -1) {
			pollfds[i].fd = lstn-&gt;sock;
			pollfds[i].events = POLLIN;
			++i;
		}
	}

	while(1) {
		DBGPRINTF("--------imudp calling poll() on %d fds\n", nfd);
		nfds = poll(pollfds, nfd, -1);
		if(glbl.GetGlobalInputTermState() == 1)
			break; /* terminate input! */

		if(nfds &lt; 0) {
			if(errno == EINTR) {
				DBGPRINTF("imudp: EINTR occurred\n");
			} else {
				LogMsg(errno, RS_RET_POLL_ERR, LOG_WARNING, "imudp: poll "
					"system call failed, may cause further troubles");
			}
			nfds = 0;
		}

		i = 0;
		for(lstn = lcnfRoot ; nfds &amp;&amp; lstn != NULL ; lstn = lstn-&gt;next) {
			assert(i &lt; nfd);
			if(lstn-&gt;sock != -1) {
				if(glbl.GetGlobalInputTermState() == 1)
					ABORT_FINALIZE(RS_RET_FORCE_TERM); /* terminate input! */
				if(pollfds[i].revents &amp; POLLIN) {
					processSocket(pWrkr, lstn, &amp;frominetPrev, &amp;bIsPermitted);
					--nfds;
				}
				++i;
			}
	       }
	       /* end of a run, back to loop for next recv() */
	}

finalize_it:
	RETiRet;
}
#endif /* #if HAVE_EPOLL_CREATE1 */


static rsRetVal
createListner(es_str_t *port, struct cnfparamvals *pvals)
{
	instanceConf_t *inst;
	int i;
	int bAppendPortUsed = 0;
	DEFiRet;

	CHKiRet(createInstance(&amp;inst));
	inst-&gt;pszBindPort = (uchar*)es_str2cstr(port, NULL);
	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(inppblk.descr[i].name, "port")) {
			continue;	/* array, handled by caller */
		} else if(!strcmp(inppblk.descr[i].name, "name")) {
			if(inst-&gt;inputname != NULL) {
				LogError(0, RS_RET_INVALID_PARAMS, "imudp: name and inputname "
						"parameter specified - only one can be used");
				ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
			}
			inst-&gt;inputname = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "name.appendport")) {
			if(bAppendPortUsed) {
				LogError(0, RS_RET_INVALID_PARAMS, "imudp: name.appendport and "
						"inputname.appendport parameter specified - only one can be used");
				ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
			}
			inst-&gt;bAppendPortToInpname = (int) pvals[i].val.d.n;
			bAppendPortUsed = 1;
		} else if(!strcmp(inppblk.descr[i].name, "inputname")) {
			LogError(0, RS_RET_DEPRECATED , "imudp: deprecated parameter inputname "
					"used. Suggest to use name instead");
			if(inst-&gt;inputname != NULL) {
				LogError(0, RS_RET_INVALID_PARAMS, "imudp: name and inputname "
						"parameter specified - only one can be used");
				ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
			}
			inst-&gt;inputname = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "inputname.appendport")) {
			LogError(0, RS_RET_DEPRECATED , "imudp: deprecated parameter inputname.appendport "
					"used. Suggest to use name.appendport instead");
			if(bAppendPortUsed) {
				LogError(0, RS_RET_INVALID_PARAMS, "imudp: name.appendport and "
						"inputname.appendport parameter specified - only one can be used");
<a name="1"></a>				ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
			}
			bAppendPortUsed = 1;
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>			inst-&gt;bAppendPortToInpname = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "defaulttz")) {
			inst-&gt;dfltTZ = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
<a name="3"></a>		} else if(!strcmp(inppblk.descr[i].name, "address")) {
			inst-&gt;pszBindAddr = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "device")) {
			inst-&gt;pszBindDevice = (char*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font><font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>
		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "ratelimit.burst")) {
			inst-&gt;ratelimitBurst = (unsigned int) pvals[i].val.d.n;</b></font>
		} else if(!strcmp(inppblk.descr[i].name, "ratelimit.interval")) {
			inst-&gt;ratelimitInterval = (unsigned int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "rcvbufsize")) {
			const uint64_t val = pvals[i].val.d.n;
			if(val &gt; 1024 * 1024 * 1024) {
				LogError(0, RS_RET_MISSING_CNFPARAMS,
					"imudp: rcvbufsize maximum is 1 GiB, using "
					"default instead");
			} else {
				inst-&gt;rcvbuf = (int) val;
			}
		} else if(!strcmp(inppblk.descr[i].name, "ipfreebind")) {
			inst-&gt;ipfreebind = (int) pvals[i].val.d.n;
		} else {
			dbgprintf("imudp: program error, non-handled "
			  "param '%s'\n", inppblk.descr[i].name);
		}
	}
finalize_it:
	RETiRet;
}


BEGINnewInpInst
	struct cnfparamvals *pvals;
	int i;
	int portIdx;
CODESTARTnewInpInst
	DBGPRINTF("newInpInst (imudp)\n");

	if((pvals = nvlstGetParams(lst, &amp;inppblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if(Debug) {
		dbgprintf("input param blk in imudp:\n");
		cnfparamsPrint(&amp;inppblk, pvals);
	}

	portIdx = cnfparamGetIdx(&amp;inppblk, "port");
	assert(portIdx != -1);
	for(i = 0 ; i &lt;  pvals[portIdx].val.d.ar-&gt;nmemb ; ++i) {
		createListner(pvals[portIdx].val.d.ar-&gt;arr[i], pvals);
	}

finalize_it:
CODE_STD_FINALIZERnewInpInst
	cnfparamvalsDestruct(pvals, &amp;inppblk);
ENDnewInpInst


BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	/* init our settings */
	loadModConf-&gt;configSetViaV2Method = 0;
	loadModConf-&gt;wrkrMax = 1; /* conservative, but least msg reordering */
	loadModConf-&gt;batchSize = BATCH_SIZE_DFLT;
	loadModConf-&gt;iTimeRequery = TIME_REQUERY_DFLT;
	loadModConf-&gt;iSchedPrio = SCHED_PRIO_UNSET;
	loadModConf-&gt;pszSchedPolicy = NULL;
	loadModConf-&gt;bPreserveCase = 0; /* off */
	bLegacyCnfModGlobalsPermitted = 1;
	/* init legacy config vars */
	cs.pszBindRuleset = NULL;
	cs.pszSchedPolicy = NULL;
	cs.pszBindAddr = NULL;
	cs.pszBindDevice = NULL;
	cs.iSchedPrio = SCHED_PRIO_UNSET;
	cs.iTimeRequery = TIME_REQUERY_DFLT;
ENDbeginCnfLoad


BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
	int wrkrMax;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, "imudp: error processing module "
				"config parameters [module(...)]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf("module (global) param blk for imudp:\n");
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(modpblk.descr[i].name, "timerequery")) {
			loadModConf-&gt;iTimeRequery = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "batchsize")) {
			loadModConf-&gt;batchSize = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "schedulingpriority")) {
			loadModConf-&gt;iSchedPrio = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "schedulingpolicy")) {
			loadModConf-&gt;pszSchedPolicy = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, "threads")) {
			wrkrMax = (int) pvals[i].val.d.n;
			if(wrkrMax &gt; MAX_WRKR_THREADS) {
				LogError(0, RS_RET_PARAM_ERROR, "imudp: configured for %d"
						"worker threads, but maximum permitted is %d",
						wrkrMax, MAX_WRKR_THREADS);
				loadModConf-&gt;wrkrMax = MAX_WRKR_THREADS;
			} else {
				loadModConf-&gt;wrkrMax = wrkrMax;
			}
		} else if(!strcmp(modpblk.descr[i].name, "preservecase")) {
			loadModConf-&gt;bPreserveCase = (int) pvals[i].val.d.n;
		} else {
			dbgprintf("imudp: program error, non-handled "
			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
		}
	}

	/* remove all of our legacy handlers, as they can not used in addition
	 * the the new-style config method.
	 */
	bLegacyCnfModGlobalsPermitted = 0;
	loadModConf-&gt;configSetViaV2Method = 1;

finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf

BEGINendCnfLoad
CODESTARTendCnfLoad
	if(!loadModConf-&gt;configSetViaV2Method) {
		/* persist module-specific settings from legacy config system */
		loadModConf-&gt;iSchedPrio = cs.iSchedPrio;
		loadModConf-&gt;iTimeRequery = cs.iTimeRequery;
		if((cs.pszSchedPolicy != NULL) &amp;&amp; (cs.pszSchedPolicy[0] != '\0')) {
			CHKmalloc(loadModConf-&gt;pszSchedPolicy = ustrdup(cs.pszSchedPolicy));
		}
	}

finalize_it:
	loadModConf = NULL; /* done loading */
	/* free legacy config vars */
	free(cs.pszBindRuleset);
	free(cs.pszSchedPolicy);
	free(cs.pszBindAddr);
	free(cs.pszBindDevice);
ENDendCnfLoad


BEGINcheckCnf
	instanceConf_t *inst;
CODESTARTcheckCnf
	checkSchedParam(pModConf); /* this can not cause fatal errors */
	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		std_checkRuleset(pModConf, inst);
	}
	if(pModConf-&gt;root == NULL) {
		LogError(0, RS_RET_NO_LISTNERS , "imudp: module loaded, but "
				"no listeners defined - no input will be gathered");
		iRet = RS_RET_NO_LISTNERS;
	}
ENDcheckCnf


BEGINactivateCnfPrePrivDrop
	instanceConf_t *inst;
CODESTARTactivateCnfPrePrivDrop
	runModConf = pModConf;
	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		addListner(inst);
	}
	/* if we could not set up any listeners, there is no point in running... */
	if(lcnfRoot == NULL) {
		LogError(0, NO_ERRCODE, "imudp: no listeners could be started, "
				"input not activated.\n");
		ABORT_FINALIZE(RS_RET_NO_RUN);
	}

finalize_it:
ENDactivateCnfPrePrivDrop


BEGINactivateCnf
	int i;
	int lenRcvBuf;
CODESTARTactivateCnf
	/* caching various settings */
	iMaxLine = glbl.GetMaxLine(runConf);
	lenRcvBuf = iMaxLine + 1;
#	ifdef HAVE_RECVMMSG
	lenRcvBuf *= runModConf-&gt;batchSize;
#	endif
	DBGPRINTF("imudp: config params iMaxLine %d, lenRcvBuf %d\n", iMaxLine, lenRcvBuf);
	for(i = 0 ; i &lt; runModConf-&gt;wrkrMax ; ++i) {
#		ifdef HAVE_RECVMMSG
		CHKmalloc(wrkrInfo[i].recvmsg_iov = malloc(runModConf-&gt;batchSize * sizeof(struct iovec)));
		CHKmalloc(wrkrInfo[i].recvmsg_mmh = malloc(runModConf-&gt;batchSize * sizeof(struct mmsghdr)));
		CHKmalloc(wrkrInfo[i].frominet = malloc(runModConf-&gt;batchSize * sizeof(struct sockaddr_storage)));
#		endif
		CHKmalloc(wrkrInfo[i].pRcvBuf = malloc(lenRcvBuf));
		wrkrInfo[i].id = i;
	}
finalize_it:
ENDactivateCnf


BEGINfreeCnf
	instanceConf_t *inst, *del;
CODESTARTfreeCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
		free(inst-&gt;pszBindPort);
		free(inst-&gt;pszBindAddr);
		free(inst-&gt;pszBindDevice);
		free(inst-&gt;pszBindRuleset);
		free(inst-&gt;inputname);
		free(inst-&gt;dfltTZ);
		del = inst;
		inst = inst-&gt;next;
		free(del);
	}
ENDfreeCnf


static void *
wrkr(void *myself)
{
	struct wrkrInfo_s *pWrkr = (struct wrkrInfo_s*) myself;
	uchar thrdName[32];

	snprintf((char*)thrdName, sizeof(thrdName), "imudp(w%d)", pWrkr-&gt;id);
#	if defined(HAVE_PRCTL) &amp;&amp; defined(PR_SET_NAME)
	/* set thread name - we ignore if the call fails, has no harsh consequences... */
	if(prctl(PR_SET_NAME, thrdName, 0, 0, 0) != 0) {
		DBGPRINTF("prctl failed, not setting thread name for '%s'\n", thrdName);
	}
#	endif
	dbgOutputTID((char*)thrdName);

	/* Note well: the setting of scheduling parameters will not work
	 * when we dropped privileges (if the user is not sufficiently
	 * privileged, of course). Howerver, we can't change the
	 * scheduling params in PrePrivDrop(), as at that point our thread
	 * is not yet created. So at least as an interim solution, we do
	 * NOT support both setting sched parameters and dropping
	 * privileges within the same instance.
	 */
	setSchedParams(runModConf);

	/* support statistics gathering */
	statsobj.Construct(&amp;(pWrkr-&gt;stats));
	statsobj.SetName(pWrkr-&gt;stats, thrdName);
	statsobj.SetOrigin(pWrkr-&gt;stats, (uchar*)"imudp");
	STATSCOUNTER_INIT(pWrkr-&gt;ctrCall_recvmmsg, pWrkr-&gt;mutCtrCall_recvmmsg);
	statsobj.AddCounter(pWrkr-&gt;stats, UCHAR_CONSTANT("called.recvmmsg"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkr-&gt;ctrCall_recvmmsg));
	STATSCOUNTER_INIT(pWrkr-&gt;ctrCall_recvmsg, pWrkr-&gt;mutCtrCall_recvmsg);
	statsobj.AddCounter(pWrkr-&gt;stats, UCHAR_CONSTANT("called.recvmsg"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkr-&gt;ctrCall_recvmsg));
	STATSCOUNTER_INIT(pWrkr-&gt;ctrMsgsRcvd, pWrkr-&gt;mutCtrMsgsRcvd);
	statsobj.AddCounter(pWrkr-&gt;stats, UCHAR_CONSTANT("msgs.received"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkr-&gt;ctrMsgsRcvd));
	statsobj.ConstructFinalize(pWrkr-&gt;stats);

	rcvMainLoop(pWrkr);

	/* cleanup */
	return NULL;
}

/* This function is called to gather input.
 * In essence, it just starts the pool of workers. To save resources,
 * we run one of the workers on our own thread -- otherwise that thread would
 * just idle around and wait for the workers to finish.
 */
BEGINrunInput
	int i;
	pthread_attr_t wrkrThrdAttr;
CODESTARTrunInput
	pthread_attr_init(&amp;wrkrThrdAttr);
	pthread_attr_setstacksize(&amp;wrkrThrdAttr, 4096*1024);
	for(i = 0 ; i &lt; runModConf-&gt;wrkrMax - 1 ; ++i) {
		wrkrInfo[i].pThrd = pThrd;
		pthread_create(&amp;wrkrInfo[i].tid, &amp;wrkrThrdAttr, wrkr, &amp;(wrkrInfo[i]));
	}
	pthread_attr_destroy(&amp;wrkrThrdAttr);

	wrkrInfo[i].pThrd = pThrd;
	wrkrInfo[i].id = i;
	wrkr(&amp;wrkrInfo[i]);

	for(i = 0 ; i &lt; runModConf-&gt;wrkrMax - 1 ; ++i) {
		pthread_kill(wrkrInfo[i].tid, SIGTTIN);
	}
	for(i = 0 ; i &lt; runModConf-&gt;wrkrMax - 1 ; ++i) {
		pthread_join(wrkrInfo[i].tid, NULL);
	}
ENDrunInput


/* initialize and return if will run or not */
BEGINwillRun
CODESTARTwillRun
	net.PrintAllowedSenders(1); /* UDP */
	net.HasRestrictions(UCHAR_CONSTANT("UDP"), &amp;bDoACLCheck); /* UDP */
ENDwillRun


BEGINafterRun
	struct lstn_s *lstn, *lstnDel;
	int i;
CODESTARTafterRun
	/* do cleanup here */
	net.clearAllowedSenders((uchar*)"UDP");
	for(lstn = lcnfRoot ; lstn != NULL ; ) {
		statsobj.Destruct(&amp;(lstn-&gt;stats));
		ratelimitDestruct(lstn-&gt;ratelimiter);
		close(lstn-&gt;sock);
		prop.Destruct(&amp;lstn-&gt;pInputName);
		lstnDel = lstn;
		lstn = lstn-&gt;next;
		free(lstnDel);
	}
	lcnfRoot = lcnfLast = NULL;
	for(i = 0 ; i &lt; runModConf-&gt;wrkrMax ; ++i) {
#		ifdef HAVE_RECVMMSG
		free(wrkrInfo[i].recvmsg_iov);
		free(wrkrInfo[i].recvmsg_mmh);
		free(wrkrInfo[i].frominet);
#		endif
		free(wrkrInfo[i].pRcvBuf);
	}
ENDafterRun


BEGINmodExit
CODESTARTmodExit
	/* release what we no longer need */
	objRelease(glbl, CORE_COMPONENT);
	objRelease(statsobj, CORE_COMPONENT);
	objRelease(datetime, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
	objRelease(net, LM_NET_FILENAME);
ENDmodExit


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt

static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	free(cs.pszBindAddr);
	cs.pszBindAddr = NULL;
	free(cs.pszBindDevice);
	cs.pszBindDevice = NULL;
	free(cs.pszSchedPolicy);
	cs.pszSchedPolicy = NULL;
	free(cs.pszBindRuleset);
	cs.pszBindRuleset = NULL;
	cs.iSchedPrio = SCHED_PRIO_UNSET;
	cs.iTimeRequery = TIME_REQUERY_DFLT;/* the default is to query only every second time */
	return RS_RET_OK;
}


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(objUse(net, LM_NET_FILENAME));

	DBGPRINTF("imudp: version %s initializing\n", VERSION);
#	ifdef HAVE_RECVMMSG
	DBGPRINTF("imdup: support for recvmmsg() present\n");
#	endif

	/* register config file handlers */
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"inputudpserverbindruleset", 0, eCmdHdlrGetWord,
		NULL, &amp;cs.pszBindRuleset, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"udpserverrun", 0, eCmdHdlrGetWord,
		addInstance, NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"udpserveraddress", 0, eCmdHdlrGetWord,
		NULL, &amp;cs.pszBindAddr, STD_LOADABLE_MODULE_ID));
	/* module-global config params - will be disabled in configs that are loaded
	 * via module(...).
	 */
	CHKiRet(regCfSysLineHdlr2((uchar *)"imudpschedulingpolicy", 0, eCmdHdlrGetWord,
		NULL, &amp;cs.pszSchedPolicy, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"imudpschedulingpriority", 0, eCmdHdlrInt,
		NULL, &amp;cs.iSchedPrio, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"udpservertimerequery", 0, eCmdHdlrInt,
		NULL, &amp;cs.iTimeRequery, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));

	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit
/* vim:set ai:
 */
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
