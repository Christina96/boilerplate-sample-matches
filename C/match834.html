<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for omczmq.c & imudp.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for omczmq.c & imudp.c
      </h3>
      <h1 align="center">
        10.5%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>omczmq.c (16.767677%)<TH>imudp.c (7.6709795%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match834-0.html#0',2,'match834-1.html#0',3)" NAME="0">(98-120)<TD><A HREF="javascript:ZweiFrames('match834-0.html#0',2,'match834-1.html#0',3)" NAME="0">(181-208)</A><TD ALIGN=center><FONT COLOR="#ff0000">35</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match834-0.html#1',2,'match834-1.html#1',3)" NAME="1">(415-426)<TD><A HREF="javascript:ZweiFrames('match834-0.html#1',2,'match834-1.html#1',3)" NAME="1">(990-996)</A><TD ALIGN=center><FONT COLOR="#8a0000">19</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match834-0.html#2',2,'match834-1.html#2',3)" NAME="2">(49-59)<TD><A HREF="javascript:ZweiFrames('match834-0.html#2',2,'match834-1.html#2',3)" NAME="2">(167-176)</A><TD ALIGN=center><FONT COLOR="#7b0000">17</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match834-0.html#3',2,'match834-1.html#3',3)" NAME="3">(481-489)<TD><A HREF="javascript:ZweiFrames('match834-0.html#3',2,'match834-1.html#3',3)" NAME="3">(996-1000)</A><TD ALIGN=center><FONT COLOR="#570000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>omczmq.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* omczmq.c
 * Copyright (C) 2016 Brian Knox
 * Copyright (C) 2014 Rainer Gerhards
 *
 * Author: Brian Knox &lt;bknox@digitalocean.com&gt;
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;template.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;cfsysline.h&quot;
#include &lt;czmq.h&gt;

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;omczmq&quot;)

DEF_OMOD_STATIC_DATA

<A NAME="2"></A>static pthread_mutex_t mutDoAct = PTHREAD_MUTEX_INITIALIZER;

static struct cnfparamdescr modpdescr[] = {
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match834-1.html#2',3,'match834-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	{ &quot;authenticator&quot;, eCmdHdlrBinary, 0 },
	{ &quot;authtype&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;clientcertpath&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;servercertpath&quot;, eCmdHdlrGetWord, 0 }
};

static struct cnfparamblk modpblk = {
	CNFPARAMBLK_VERSION,
	sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	modpdescr
};</B></FONT>

struct modConfData_s {
	rsconf_t *pConf;
	uchar *tplName;
	int authenticator;
	char *authType;
	char *serverCertPath;
	char *clientCertPath;
};

static modConfData_t *runModConf = NULL;
static zactor_t *authActor;

typedef struct _instanceData {
	zsock_t *sock;
	bool serverish;
	int sendTimeout;
	zlist_t *topics;
	bool sendError;
	char *sockEndpoints;
	int sockType;
	int sendHWM;
#if(CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
	int heartbeatIvl;
	int heartbeatTimeout;
	int heartbeatTTL;
	int connectTimeout;
#endif
	uchar *tplName;
	sbool topicFrame;
	sbool dynaTopic;
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
<A NAME="0"></A>} wrkrInstanceData_t;

static struct cnfparamdescr actpdescr[] = {
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match834-1.html#0',3,'match834-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	{ &quot;endpoints&quot;, eCmdHdlrGetWord, 1 },
	{ &quot;socktype&quot;, eCmdHdlrGetWord, 1 },
	{ &quot;sendhwm&quot;, eCmdHdlrGetWord, 0 },
#if(CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
	{ &quot;heartbeatttl&quot;, eCmdHdlrGetWord, 0},
	{ &quot;heartbeativl&quot;, eCmdHdlrGetWord, 0},
	{ &quot;heartbeattimeout&quot;, eCmdHdlrGetWord, 0},
	{ &quot;connecttimeout&quot;, eCmdHdlrGetWord, 0},
#endif
	{ &quot;sendtimeout&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;template&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;topics&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;topicframe&quot;, eCmdHdlrGetWord, 0},
	{ &quot;dynatopic&quot;, eCmdHdlrBinary, 0 }
};

static struct cnfparamblk actpblk = {
	CNFPARAMBLK_VERSION,
	sizeof(actpdescr) / sizeof(struct cnfparamdescr),
	actpdescr
};

static rsRetVal initCZMQ(instanceData* pData) {</B></FONT>
	DEFiRet;
	int rc;
	putenv((char*)&quot;ZSYS_SIGHANDLER=false&quot;);
	pData-&gt;sock = zsock_new(pData-&gt;sockType);
	if(!pData-&gt;sock) {
		LogError(0, RS_RET_NO_ERRCODE,
				&quot;omczmq: new socket failed for endpoints: %s&quot;,
				pData-&gt;sockEndpoints);
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}

	zsock_set_sndtimeo(pData-&gt;sock, pData-&gt;sendTimeout);

#if(CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
	if(pData-&gt;heartbeatIvl &gt; 0 &amp;&amp; pData-&gt;heartbeatTimeout &gt; 0 &amp;&amp; pData-&gt;heartbeatTTL &gt; 0) {
		zsock_set_heartbeat_ivl(pData-&gt;sock, pData-&gt;heartbeatIvl);
		zsock_set_heartbeat_timeout(pData-&gt;sock, pData-&gt;heartbeatTimeout);
		zsock_set_heartbeat_ttl(pData-&gt;sock, pData-&gt;heartbeatTTL);
	}
#endif

	if(runModConf-&gt;authType) {
		if (!strcmp(runModConf-&gt;authType, &quot;CURVESERVER&quot;)) {
			zcert_t *serverCert = zcert_load(runModConf-&gt;serverCertPath);
			if(!serverCert) {
				LogError(0, NO_ERRCODE, &quot;could not load cert %s&quot;,
					runModConf-&gt;serverCertPath);
				ABORT_FINALIZE(RS_RET_ERR);
			}
			zsock_set_zap_domain(pData-&gt;sock, &quot;global&quot;);
			zsock_set_curve_server(pData-&gt;sock, 1);
			zcert_apply(serverCert, pData-&gt;sock);
			zcert_destroy(&amp;serverCert);
		}
		else if(!strcmp(runModConf-&gt;authType, &quot;CURVECLIENT&quot;)) {
			zcert_t *serverCert = zcert_load(runModConf-&gt;serverCertPath);
			if(!serverCert) {
				LogError(0, NO_ERRCODE, &quot;could not load cert %s&quot;,
					runModConf-&gt;serverCertPath);
				ABORT_FINALIZE(RS_RET_ERR);
			}
			const char *server_key = zcert_public_txt(serverCert);
			zcert_destroy(&amp;serverCert);
			zsock_set_curve_serverkey(pData-&gt;sock, server_key);

			zcert_t *clientCert = zcert_load(runModConf-&gt;clientCertPath);
			if(!clientCert) {
				LogError(0, NO_ERRCODE, &quot;could not load cert %s&quot;,
					runModConf-&gt;clientCertPath);
				ABORT_FINALIZE(RS_RET_ERR);
			}

			zcert_apply(clientCert, pData-&gt;sock);
			zcert_destroy(&amp;clientCert);
		}
	}

	switch(pData-&gt;sockType) {
		case ZMQ_PUB:
#if defined(ZMQ_RADIO)
		case ZMQ_RADIO:
#endif
			pData-&gt;serverish = true;
			break;
		case ZMQ_PUSH:
#if defined(ZMQ_SCATTER)
		case ZMQ_SCATTER:
#endif
		case ZMQ_DEALER:
#if defined(ZMQ_CLIENT)
		case ZMQ_CLIENT:
#endif
			pData-&gt;serverish = false;
			break;
	}

	rc = zsock_attach(pData-&gt;sock, pData-&gt;sockEndpoints, pData-&gt;serverish);
	if(rc == -1) {
		LogError(0, NO_ERRCODE, &quot;zsock_attach to %s failed&quot;,
				pData-&gt;sockEndpoints);
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}

finalize_it:
	RETiRet;
}

static rsRetVal outputCZMQ(uchar** ppString, instanceData* pData) {
	DEFiRet;

	if(NULL == pData-&gt;sock) {
		CHKiRet(initCZMQ(pData));
	}

	/* if we are using a PUB (or RADIO) socket and we have a topic list then we
	 * need some special care and attention */
#if defined(ZMQ_RADIO)
	DBGPRINTF(&quot;omczmq: ZMQ_RADIO is defined...\n&quot;);
	if((pData-&gt;sockType == ZMQ_PUB || pData-&gt;sockType == ZMQ_RADIO) &amp;&amp; pData-&gt;topics) {
#else
	DBGPRINTF(&quot;omczmq: ZMQ_RADIO is NOT defined...\n&quot;);
	if(pData-&gt;sockType == ZMQ_PUB &amp;&amp; pData-&gt;topics) {
#endif
		int templateIndex = 1;
		const char *topic = (const char *)zlist_first(pData-&gt;topics);
		while(topic) {
			int rc;
			/* if dynaTopic is true, the topic is constructed by rsyslog
			 * by applying the supplied template to the message properties */
			if(pData-&gt;dynaTopic)
				topic = (const char*)ppString[templateIndex];

			if (pData-&gt;sockType == ZMQ_PUB) {
				/* if topicFrame is true, send the topic as a separate zmq frame */
				if(pData-&gt;topicFrame) {
					rc = zstr_sendx(pData-&gt;sock, topic, (char*)ppString[0], NULL);
				}

				/* if topicFrame is false, concatenate the topic with the
				 * message in the same frame */
				else {
					rc = zstr_sendf(pData-&gt;sock, &quot;%s%s&quot;, topic, (char*)ppString[0]);
				}

				/* if we have a send error notify rsyslog */
				if(rc != 0) {
					pData-&gt;sendError = true;
					ABORT_FINALIZE(RS_RET_SUSPENDED);
				}
			}
#if defined(ZMQ_RADIO)
			else if(pData-&gt;sockType == ZMQ_RADIO) {
				DBGPRINTF(&quot;omczmq: sending on RADIO socket...\n&quot;);
				zframe_t *frame = zframe_from((char*)ppString[0]);
				if (!frame) {
					DBGPRINTF(&quot;omczmq: failed to create frame...\n&quot;);
					pData-&gt;sendError = true;
					ABORT_FINALIZE(RS_RET_SUSPENDED);
				}
				rc = zframe_set_group(frame, topic);
				if (rc != 0) {
					DBGPRINTF(&quot;omczmq: failed to set group '%d'...\n&quot;, rc);
					pData-&gt;sendError = true;
					ABORT_FINALIZE(RS_RET_SUSPENDED);
				}
				DBGPRINTF(&quot;omczmq: set RADIO group to '%s'\n&quot;, topic);
				rc = zframe_send(&amp;frame, pData-&gt;sock, 0);
				if(rc != 0) {
					pData-&gt;sendError = true;
					ABORT_FINALIZE(RS_RET_SUSPENDED);
				}
			}
#endif

			/* get the next topic from the list, and increment
			 * our topic index */
			topic = zlist_next(pData-&gt;topics);
			templateIndex++;
		}
	}

	/* we aren't a PUB socket and we don't have a topic list - this means
	 * we can just send the message using the rsyslog template */
	else {
		int rc = zstr_send(pData-&gt;sock, (char*)ppString[0]);
		if(rc != 0) {
			pData-&gt;sendError = true;
			DBGPRINTF(&quot;omczmq: send error: %d&quot;, rc);
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
	}
finalize_it:
	RETiRet;
}

static inline void
setInstParamDefaults(instanceData* pData) {
	pData-&gt;sockEndpoints = NULL;
	pData-&gt;sock = NULL;
	pData-&gt;sendError = false;
	pData-&gt;serverish = false;
	pData-&gt;tplName = NULL;
	pData-&gt;sockType = -1;
	pData-&gt;sendTimeout = -1;
	pData-&gt;topics = NULL;
	pData-&gt;topicFrame = false;
#if(CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
	pData-&gt;heartbeatIvl = 0;
	pData-&gt;heartbeatTimeout = 0;
	pData-&gt;heartbeatTTL = 0;
#endif
}


BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
ENDcreateWrkrInstance

BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction) {
		iRet = RS_RET_OK;
	}
ENDisCompatibleWithFeature
BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
ENDdbgPrintInstInfo

BEGINfreeInstance
CODESTARTfreeInstance
	zlist_destroy(&amp;pData-&gt;topics);
	zsock_destroy(&amp;pData-&gt;sock);
	free(pData-&gt;sockEndpoints);
	free(pData-&gt;tplName);
ENDfreeInstance


BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
ENDfreeWrkrInstance

BEGINtryResume
	instanceData *pData;
CODESTARTtryResume
	pthread_mutex_lock(&amp;mutDoAct);
	pData = pWrkrData-&gt;pData;
	DBGPRINTF(&quot;omczmq: trying to resume...\n&quot;);
	zsock_destroy(&amp;pData-&gt;sock);
	iRet = initCZMQ(pData);
	pthread_mutex_unlock(&amp;mutDoAct);
ENDtryResume

BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	runModConf = pModConf;
	runModConf-&gt;pConf = pConf;
	runModConf-&gt;authenticator = 0;
	runModConf-&gt;authType = NULL;
	runModConf-&gt;serverCertPath = NULL;
	runModConf-&gt;clientCertPath = NULL;
ENDbeginCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
	if(runModConf-&gt;authenticator == 1) {
		if(!authActor) {
			DBGPRINTF(&quot;omczmq: starting authActor\n&quot;);
			authActor = zactor_new(zauth, NULL);
			if(!strcmp(runModConf-&gt;clientCertPath, &quot;*&quot;)) {
				zstr_sendx(authActor, &quot;CURVE&quot;, CURVE_ALLOW_ANY, NULL);
			}
			else {
				zstr_sendx(authActor, &quot;CURVE&quot;, runModConf-&gt;clientCertPath, NULL);
			}
			zsock_wait(authActor);
		}
	}
ENDactivateCnf

BEGINfreeCnf
CODESTARTfreeCnf
	free(pModConf-&gt;tplName);
	free(pModConf-&gt;authType);
	free(pModConf-&gt;serverCertPath);
	free(pModConf-&gt;clientCertPath);
	DBGPRINTF(&quot;omczmq: stopping authActor\n&quot;);
	zactor_destroy(&amp;authActor);
ENDfreeCnf

BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if (pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;error processing module&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	for (i=0; i&lt;modpblk.nParams; ++i) {
		if(!pvals[i].bUsed) {
			DBGPRINTF(&quot;omczmq: pvals[i].bUSed continuing\n&quot;);
<A NAME="1"></A>			continue;
		}
		if(!strcmp(modpblk.descr[i].name, &quot;authenticator&quot;)) {
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match834-1.html#1',3,'match834-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>			runModConf-&gt;authenticator = (int)pvals[i].val.d.n;
		}
		else if(!strcmp(modpblk.descr[i].name, &quot;authtype&quot;)) {
			runModConf-&gt;authType = es_str2cstr(pvals[i].val.d.estr, NULL);
			DBGPRINTF(&quot;omczmq: authtype set to %s\n&quot;, runModConf-&gt;authType);
		}
		else if(!strcmp(modpblk.descr[i].name, &quot;servercertpath&quot;)) {
			runModConf-&gt;serverCertPath = es_str2cstr(pvals[i].val.d.estr, NULL);
			DBGPRINTF(&quot;omczmq: serverCertPath set to %s\n&quot;, runModConf-&gt;serverCertPath);
		}
		else if(!strcmp(modpblk.descr[i].name, &quot;clientcertpath&quot;)) {
			runModConf-&gt;clientCertPath = es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
			DBGPRINTF(&quot;omczmq: clientCertPath set to %s\n&quot;, runModConf-&gt;clientCertPath);
		}
		else {
			LogError(0, RS_RET_INVALID_PARAMS,
						&quot;omczmq: config error, unknown &quot;
						&quot;param %s in setModCnf\n&quot;,
						modpblk.descr[i].name);
		}
	}

	DBGPRINTF(&quot;omczmq: authenticator set to %d\n&quot;, runModConf-&gt;authenticator);
	DBGPRINTF(&quot;omczmq: authType set to %s\n&quot;, runModConf-&gt;authType);
	DBGPRINTF(&quot;omczmq: serverCertPath set to %s\n&quot;, runModConf-&gt;serverCertPath);
	DBGPRINTF(&quot;omczmq: clientCertPath set to %s\n&quot;, runModConf-&gt;clientCertPath);

finalize_it:
		if(pvals != NULL)
			cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf

BEGINendCnfLoad
CODESTARTendCnfLoad
	runModConf = NULL;
ENDendCnfLoad


BEGINdoAction
	instanceData *pData;
CODESTARTdoAction
	pthread_mutex_lock(&amp;mutDoAct);
	pData = pWrkrData-&gt;pData;
	iRet = outputCZMQ(ppString, pData);
	pthread_mutex_unlock(&amp;mutDoAct);
ENDdoAction


BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
	int iNumTpls;
CODESTARTnewActInst
	if ((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	for(i = 0; i &lt; actpblk.nParams; ++i) {
		if(!pvals[i].bUsed) {
			continue;
<A NAME="3"></A>		}

		if(!strcmp(actpblk.descr[i].name, &quot;endpoints&quot;)) {
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match834-1.html#3',3,'match834-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>			pData-&gt;sockEndpoints = es_str2cstr(pvals[i].val.d.estr, NULL);
			DBGPRINTF(&quot;omczmq: sockEndPoints set to '%s'\n&quot;, pData-&gt;sockEndpoints);
		}
		else if(!strcmp(actpblk.descr[i].name, &quot;template&quot;)) {
			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			DBGPRINTF(&quot;omczmq: template set to '%s'\n&quot;, pData-&gt;tplName);
		}
		else if(!strcmp(actpblk.descr[i].name, &quot;dynatopic&quot;)) {
			pData-&gt;dynaTopic = pvals[i].val.d.n;</B></FONT>
			DBGPRINTF(&quot;omczmq: dynaTopic set to %s\n&quot;, pData-&gt;dynaTopic ? &quot;true&quot; : &quot;false&quot;);
		}
		else if(!strcmp(actpblk.descr[i].name, &quot;sendtimeout&quot;)) {
			pData-&gt;sendTimeout = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
			DBGPRINTF(&quot;omczmq: sendTimeout set to %d\n&quot;, pData-&gt;sendTimeout);
		}
		else if(!strcmp(actpblk.descr[i].name, &quot;sendhwm&quot;)) {
			pData-&gt;sendTimeout = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
			DBGPRINTF(&quot;omczmq: sendHWM set to %d\n&quot;, pData-&gt;sendHWM);
		}
#if (CZMQ_VERSION_MAJOR &gt;= 4 &amp;&amp; ZMQ_VERSION_MAJOR &gt;=4 &amp;&amp; ZMQ_VERSION_MINOR &gt;=2)
		else if(!strcmp(actpblk.descr[i].name, &quot;heartbeativl&quot;)) {
			pData-&gt;heartbeatIvl = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
			DBGPRINTF(&quot;omczmq: heartbeatbeatIvl set to %d\n&quot;, pData-&gt;heartbeatIvl);
		}
		else if(!strcmp(actpblk.descr[i].name, &quot;heartbeattimeout&quot;)) {
			pData-&gt;heartbeatTimeout = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
			DBGPRINTF(&quot;omczmq: heartbeatTimeout set to %d\n&quot;, pData-&gt;heartbeatTimeout);
		}
		else if(!strcmp(actpblk.descr[i].name, &quot;heartbeatttl&quot;)) {
			pData-&gt;heartbeatTimeout = atoi(es_str2cstr(pvals[i].val.d.estr, NULL));
			DBGPRINTF(&quot;omczmq: heartbeatTTL set to %d\n&quot;, pData-&gt;heartbeatTTL);
		}
#endif
		else if(!strcmp(actpblk.descr[i].name, &quot;socktype&quot;)){
			char *stringType = es_str2cstr(pvals[i].val.d.estr, NULL);
			if(stringType != NULL){
				if(!strcmp(&quot;PUB&quot;, stringType)) {
					pData-&gt;sockType = ZMQ_PUB;
					DBGPRINTF(&quot;omczmq: sockType set to ZMQ_PUB\n&quot;);
				}
#if defined(ZMQ_RADIO)
				else if(!strcmp(&quot;RADIO&quot;, stringType)) {
					pData-&gt;sockType = ZMQ_RADIO;
					DBGPRINTF(&quot;omczmq: sockType set to ZMQ_RADIO\n&quot;);
				}
#endif
				else if(!strcmp(&quot;PUSH&quot;, stringType)) {
					pData-&gt;sockType = ZMQ_PUSH;
					DBGPRINTF(&quot;omczmq: sockType set to ZMQ_PUSH\n&quot;);
				}
#if defined(ZMQ_SCATTER)
				else if(!strcmp(&quot;SCATTER&quot;, stringType)) {
					pData-&gt;sockType = ZMQ_SCATTER;
					DBGPRINTF(&quot;omczmq: sockType set to ZMQ_SCATTER\n&quot;);
				}
#endif
				else if(!strcmp(&quot;DEALER&quot;, stringType)) {
					pData-&gt;sockType = ZMQ_DEALER;
					DBGPRINTF(&quot;omczmq: sockType set to ZMQ_DEALER\n&quot;);
				}
#if defined(ZMQ_CLIENT)
				else if(!strcmp(&quot;CLIENT&quot;, stringType)) {
					pData-&gt;sockType = ZMQ_CLIENT;
					DBGPRINTF(&quot;omczmq: sockType set to ZMQ_CLIENT\n&quot;);
				}
#endif
				free(stringType);
			}
			else{
				LogError(0, RS_RET_OUT_OF_MEMORY,
						&quot;omczmq: out of memory&quot;);
				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
			}
		}
		else if(!strcmp(actpblk.descr[i].name, &quot;topicframe&quot;)) {
			pData-&gt;topicFrame = pvals[i].val.d.n;
			DBGPRINTF(&quot;omczmq: topicFrame set to %s\n&quot;, pData-&gt;topicFrame ? &quot;true&quot; : &quot;false&quot;);
		}
		else if(!strcmp(actpblk.descr[i].name, &quot;topics&quot;)) {
			pData-&gt;topics = zlist_new();
			char *topics = es_str2cstr(pvals[i].val.d.estr, NULL);
			DBGPRINTF(&quot;omczmq: topics set to %s\n&quot;, topics);
			char *topics_org = topics;
			char topic[256];
			if(topics == NULL){
				LogError(0, RS_RET_OUT_OF_MEMORY,
					&quot;out of memory&quot;);
				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
			}

			while(*topics) {
				char *delimiter = strchr(topics, ',');
				if (!delimiter) {
					delimiter = topics + strlen(topics);
				}
				memcpy (topic, topics, delimiter - topics);
				topic[delimiter-topics] = 0;
				char *current_topic = strdup(topic);
				zlist_append (pData-&gt;topics, current_topic);
				if(*delimiter == 0) {
					break;
				}
				topics = delimiter + 1;
			}
			free(topics_org);

		}
		else {
			LogError(0, NO_ERRCODE,
					&quot;omczmq: config error - '%s' is not a valid option&quot;,
					actpblk.descr[i].name);
			ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
		}
	}

	iNumTpls = 1;
	if (pData-&gt;dynaTopic) {
		iNumTpls = zlist_size (pData-&gt;topics) + iNumTpls;
	}
	CODE_STD_STRING_REQUESTnewActInst(iNumTpls)
	
	if (pData-&gt;tplName == NULL) {
		CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)strdup(&quot;RSYSLOG_ForwardFormat&quot;),
					OMSR_NO_RQD_TPL_OPTS));
	}
	else {
		CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)pData-&gt;tplName, OMSR_NO_RQD_TPL_OPTS));
	}

	i = 1;
	if (pData-&gt;dynaTopic) {
		char *topic = zlist_first(pData-&gt;topics);
		while (topic) {
			CHKiRet(OMSRsetEntry(*ppOMSR, i, (uchar*)strdup(topic), OMSR_NO_RQD_TPL_OPTS));
			i++;
			topic = zlist_next(pData-&gt;topics);
		}
	}

	CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst

BEGINinitConfVars
CODESTARTinitConfVars
ENDinitConfVars

NO_LEGACY_CONF_parseSelectorAct

BEGINmodExit
CODESTARTmodExit
ENDmodExit

BEGINqueryEtryPt
CODESTARTqueryEtryPt
	CODEqueryEtryPt_STD_OMOD_QUERIES
	CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
	CODEqueryEtryPt_STD_CONF2_QUERIES
	CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
	CODEqueryEtryPt_STD_OMOD8_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
CODEmodInit_QueryRegCFSLineHdlr
	INITChkCoreFeature(bCoreSupportsBatching, CORE_FEATURE_BATCHING);
	DBGPRINTF(&quot;omczmq: module compiled with rsyslog version %s.\n&quot;, VERSION);

	INITLegCnfVars
ENDmodInit
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>imudp.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* imudp.c
 * This is the implementation of the UDP input module.
 *
 * NOTE: read comments in module-template.h to understand how this file
 *       works!
 *
 * Copyright 2007-2018 Rainer Gerhards and Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Rsyslog is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Rsyslog is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Rsyslog.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 * A copy of the GPL can be found in the file &quot;COPYING&quot; in this distribution.
 */
#include &quot;config.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;pthread.h&gt;
#include &lt;signal.h&gt;
#include &lt;poll.h&gt;
#ifdef HAVE_SYS_EPOLL_H
#	include &lt;sys/epoll.h&gt;
#endif
#ifdef HAVE_SCHED_H
#	include &lt;sched.h&gt;
#endif
#ifdef HAVE_SYS_PRCTL_H
#  include &lt;sys/prctl.h&gt;
#endif
#include &quot;rsyslog.h&quot;
#include &quot;dirty.h&quot;
#include &quot;net.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;module-template.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;glbl.h&quot;
#include &quot;msg.h&quot;
#include &quot;parser.h&quot;
#include &quot;datetime.h&quot;
#include &quot;prop.h&quot;
#include &quot;ruleset.h&quot;
#include &quot;statsobj.h&quot;
#include &quot;ratelimit.h&quot;
#include &quot;unicode-helper.h&quot;

MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;imudp&quot;)

/* defines */
#define MAX_WRKR_THREADS 32

/* Module static data */
DEF_IMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(net)
DEFobjCurrIf(datetime)
DEFobjCurrIf(prop)
DEFobjCurrIf(ruleset)
DEFobjCurrIf(statsobj)


static struct lstn_s {
	struct lstn_s *next;
	int sock;		/* socket */
	ruleset_t *pRuleset;	/* bound ruleset */
	prop_t *pInputName;
	statsobj_t *stats;	/* listener stats */
	ratelimit_t *ratelimiter;
	uchar *dfltTZ;
	STATSCOUNTER_DEF(ctrSubmit, mutCtrSubmit)
	STATSCOUNTER_DEF(ctrDisallowed, mutCtrDisallowed)
} *lcnfRoot = NULL, *lcnfLast = NULL;


static int bLegacyCnfModGlobalsPermitted;/* are legacy module-global config parameters permitted? */
static int bDoACLCheck;			/* are ACL checks neeed? Cached once immediately before listener startup */
static int iMaxLine;			/* maximum UDP message size supported */
#define BATCH_SIZE_DFLT 32		/* do not overdo, has heavy toll on memory, especially with large msgs */
#define TIME_REQUERY_DFLT 2
#define SCHED_PRIO_UNSET -12345678	/* a value that indicates that the scheduling priority has not been set */
/* config vars for legacy config system */
static struct configSettings_s {
	uchar *pszBindAddr;		/* IP to bind socket to */
	char  *pszBindDevice;		/* Device to bind socket to */
	uchar *pszSchedPolicy;		/* scheduling policy string */
	uchar *pszBindRuleset;		/* name of Ruleset to bind to */
	int iSchedPrio;			/* scheduling priority */
	int iTimeRequery;		/* how often is time to be queried inside tight recv loop? 0=always */
} cs;

struct instanceConf_s {
	uchar *pszBindAddr;		/* IP to bind socket to */
	char  *pszBindDevice;		/* Device to bind socket to */
	uchar *pszBindPort;		/* Port to bind socket to */
	uchar *pszBindRuleset;		/* name of ruleset to bind to */
	uchar *inputname;
	ruleset_t *pBindRuleset;	/* ruleset to bind listener to (use system default if unspecified) */
	uchar *dfltTZ;
	unsigned int ratelimitInterval;
	unsigned int ratelimitBurst;
	int rcvbuf;			/* 0 means: do not set, keep OS default */
	/*  0 means:  IP_FREEBIND is disabled
	1 means:  IP_FREEBIND enabled + warning disabled
	1+ means: IP+FREEBIND enabled + warning enabled */
	int ipfreebind;
	struct instanceConf_s *next;
	sbool bAppendPortToInpname;
};

/* The following structure controls the worker threads. Global data is
 * needed for their access.
 */
static struct wrkrInfo_s {
	pthread_t tid;	/* the worker's thread ID */
	int id;
	thrdInfo_t *pThrd;
	statsobj_t *stats;	/* worker thread stats */
	STATSCOUNTER_DEF(ctrCall_recvmmsg, mutCtrCall_recvmmsg)
	STATSCOUNTER_DEF(ctrCall_recvmsg, mutCtrCall_recvmsg)
	STATSCOUNTER_DEF(ctrMsgsRcvd, mutCtrMsgsRcvd)
	uchar *pRcvBuf;		/* receive buffer (for a single packet) */
#	ifdef HAVE_RECVMMSG
	struct sockaddr_storage *frominet;
	struct mmsghdr *recvmsg_mmh;
	struct iovec *recvmsg_iov;
#	endif
} wrkrInfo[MAX_WRKR_THREADS];

struct modConfData_s {
	rsconf_t *pConf;		/* our overall config object */
	instanceConf_t *root, *tail;
	uchar *pszSchedPolicy;		/* scheduling policy string */
	int iSchedPolicy;		/* scheduling policy as SCHED_xxx */
	int iSchedPrio;			/* scheduling priority */
	int iTimeRequery;		/* how often is time to be queried inside tight recv loop? 0=always */
	int batchSize;			/* max nbr of input batch --&gt; also recvmmsg() max count */
	int8_t wrkrMax;			/* max nbr of worker threads */
	sbool configSetViaV2Method;
	sbool bPreserveCase;	/* preserves the case of fromhost; &quot;off&quot; by default */
};
static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current load process */

/* module-global parameters */
<A NAME="2"></A>static struct cnfparamdescr modpdescr[] = {
	{ &quot;schedulingpolicy&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;schedulingpriority&quot;, eCmdHdlrInt, 0 },
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match834-0.html#2',2,'match834-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	{ &quot;batchsize&quot;, eCmdHdlrInt, 0 },
	{ &quot;threads&quot;, eCmdHdlrPositiveInt, 0 },
	{ &quot;timerequery&quot;, eCmdHdlrInt, 0 },
	{ &quot;preservecase&quot;, eCmdHdlrBinary, 0 }
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};</B></FONT>

<A NAME="0"></A>/* input instance parameters */
static struct cnfparamdescr inppdescr[] = {
	{ &quot;port&quot;, eCmdHdlrArray, CNFPARAM_REQUIRED }, /* legacy: InputTCPServerRun */
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match834-0.html#0',2,'match834-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	{ &quot;defaulttz&quot;, eCmdHdlrString, 0 },
	{ &quot;inputname&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;inputname.appendport&quot;, eCmdHdlrBinary, 0 },
	{ &quot;name&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;name.appendport&quot;, eCmdHdlrBinary, 0 },
	{ &quot;address&quot;, eCmdHdlrString, 0 },
	{ &quot;device&quot;, eCmdHdlrString, 0 },
	{ &quot;ratelimit.interval&quot;, eCmdHdlrInt, 0 },
	{ &quot;ratelimit.burst&quot;, eCmdHdlrInt, 0 },
	{ &quot;rcvbufsize&quot;, eCmdHdlrSize, 0 },
	{ &quot;ipfreebind&quot;, eCmdHdlrInt, 0 },
	{ &quot;ruleset&quot;, eCmdHdlrString, 0 }
};
static struct cnfparamblk inppblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
	  inppdescr
	};

#include &quot;im-helper.h&quot; /* must be included AFTER the type definitions! */


/* create input instance, set default parameters, and
 * add it to the list of instances.
 */
static rsRetVal
createInstance(instanceConf_t **pinst)
{</B></FONT>
	instanceConf_t *inst;
	DEFiRet;
	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
	inst-&gt;next = NULL;
	inst-&gt;pBindRuleset = NULL;

	inst-&gt;pszBindPort = NULL;
	inst-&gt;pszBindAddr = NULL;
	inst-&gt;pszBindDevice = NULL;
	inst-&gt;pszBindRuleset = NULL;
	inst-&gt;inputname = NULL;
	inst-&gt;bAppendPortToInpname = 0;
	inst-&gt;ratelimitBurst = 10000; /* arbitrary high limit */
	inst-&gt;ratelimitInterval = 0; /* off */
	inst-&gt;rcvbuf = 0;
	inst-&gt;ipfreebind = IPFREEBIND_ENABLED_WITH_LOG;
	inst-&gt;dfltTZ = NULL;

	/* node created, let's add to config */
	if(loadModConf-&gt;tail == NULL) {
		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
	} else {
		loadModConf-&gt;tail-&gt;next = inst;
		loadModConf-&gt;tail = inst;
	}

	*pinst = inst;
finalize_it:
	RETiRet;
}

/* This function is called when a new listener instace shall be added to
 * the current config object via the legacy config system. It just shuffles
 * all parameters to the listener in-memory instance.
 * rgerhards, 2011-05-04
 */
static rsRetVal addInstance(void __attribute__((unused)) *pVal, uchar *pNewVal)
{
	instanceConf_t *inst;
	DEFiRet;

	CHKiRet(createInstance(&amp;inst));
	CHKmalloc(inst-&gt;pszBindPort = ustrdup((pNewVal == NULL || *pNewVal == '\0')
				 	       ? (uchar*) &quot;514&quot; : pNewVal));
	if((cs.pszBindAddr == NULL) || (cs.pszBindAddr[0] == '\0')) {
		inst-&gt;pszBindAddr = NULL;
	} else {
		CHKmalloc(inst-&gt;pszBindAddr = ustrdup(cs.pszBindAddr));
	}
	if((cs.pszBindDevice == NULL) || (cs.pszBindDevice[0] == '\0')) {
		inst-&gt;pszBindDevice= NULL;
	} else {
		CHKmalloc(inst-&gt;pszBindDevice = strdup(cs.pszBindDevice));
	}
	if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
		inst-&gt;pszBindRuleset = NULL;
	} else {
		CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));
	}

finalize_it:
	free(pNewVal);
	RETiRet;
}


/* This function is called when a new listener shall be added. It takes
 * the instance config description, tries to bind the socket and, if that
 * succeeds, adds it to the list of existing listen sockets.
 */
static rsRetVal
addListner(instanceConf_t *inst)
{
	DEFiRet;
	uchar *bindAddr;
	int *newSocks;
	int iSrc;
	struct lstn_s *newlcnfinfo;
	uchar *bindName;
	uchar *port;
	uchar dispname[64], inpnameBuf[128];
	uchar *inputname;

	/* check which address to bind to. We could do this more compact, but have not
	 * done so in order to make the code more readable. -- rgerhards, 2007-12-27
	 */
	if(inst-&gt;pszBindAddr == NULL)
		bindAddr = NULL;
	else if(inst-&gt;pszBindAddr[0] == '*' &amp;&amp; inst-&gt;pszBindAddr[1] == '\0')
		bindAddr = NULL;
	else
		bindAddr = inst-&gt;pszBindAddr;
	bindName = (bindAddr == NULL) ? (uchar*)&quot;*&quot; : bindAddr;
	port = (inst-&gt;pszBindPort == NULL || *inst-&gt;pszBindPort == '\0') ? (uchar*) &quot;514&quot; : inst-&gt;pszBindPort;

	DBGPRINTF(&quot;Trying to open syslog UDP ports at %s:%s.\n&quot;, bindName, inst-&gt;pszBindPort);

	newSocks = net.create_udp_socket(bindAddr, port, 1, inst-&gt;rcvbuf, 0, inst-&gt;ipfreebind, inst-&gt;pszBindDevice);
	if(newSocks != NULL) {
		/* we now need to add the new sockets to the existing set */
		/* ready to copy */
		for(iSrc = 1 ; iSrc &lt;= newSocks[0] ; ++iSrc) {
			struct sockaddr_in sa;
			socklen_t salen = sizeof(sa);
			const char *suffix;
			CHKmalloc(newlcnfinfo = (struct lstn_s*) calloc(1, sizeof(struct lstn_s)));
			newlcnfinfo-&gt;next = NULL;
			newlcnfinfo-&gt;sock = newSocks[iSrc];
			newlcnfinfo-&gt;pRuleset = inst-&gt;pBindRuleset;
			newlcnfinfo-&gt;dfltTZ = inst-&gt;dfltTZ;
			newlcnfinfo-&gt;ratelimiter = NULL;
			/* query socket IPv4 vs IPv6 */
			sa.sin_family = 0; /* just to keep CLANG static analyzer happy! */
			if(getsockname(newlcnfinfo-&gt;sock, (struct sockaddr*) &amp;sa, &amp;salen) != 0) {
				suffix = &quot;error_getting_AF...&quot;;
			} else {
				if(sa.sin_family == AF_INET) {
					suffix = &quot;IPv4&quot;;
				} else if(sa.sin_family == AF_INET6) {
					suffix = &quot;IPv6&quot;;
				} else {
					suffix = &quot;AF_unknown&quot;;
				}
			}
			if(inst-&gt;inputname == NULL) {
				inputname = (uchar*)&quot;imudp&quot;;
			} else {
				inputname = inst-&gt;inputname;
			}
			snprintf((char*)dispname, sizeof(dispname), &quot;%s(%s/%s/%s)&quot;,
				inputname, bindName, port, suffix);
			dispname[sizeof(dispname)-1] = '\0'; /* just to be on the save side... */
			CHKiRet(ratelimitNew(&amp;newlcnfinfo-&gt;ratelimiter, (char*)dispname, NULL));
			ratelimitSetLinuxLike(newlcnfinfo-&gt;ratelimiter, inst-&gt;ratelimitInterval,
					      inst-&gt;ratelimitBurst);
			ratelimitSetThreadSafe(newlcnfinfo-&gt;ratelimiter);
			if(inst-&gt;bAppendPortToInpname) {
				snprintf((char*)inpnameBuf, sizeof(inpnameBuf), &quot;%s%s&quot;,
					inputname, port);
				inpnameBuf[sizeof(inpnameBuf)-1] = '\0';
				inputname = inpnameBuf;
			}
			CHKiRet(prop.Construct(&amp;newlcnfinfo-&gt;pInputName));
			CHKiRet(prop.SetString(newlcnfinfo-&gt;pInputName,
				inputname, ustrlen(inputname)));
			CHKiRet(prop.ConstructFinalize(newlcnfinfo-&gt;pInputName));
			/* support statistics gathering */
			CHKiRet(statsobj.Construct(&amp;(newlcnfinfo-&gt;stats)));
			CHKiRet(statsobj.SetName(newlcnfinfo-&gt;stats, dispname));
			CHKiRet(statsobj.SetOrigin(newlcnfinfo-&gt;stats, (uchar*)&quot;imudp&quot;));
			STATSCOUNTER_INIT(newlcnfinfo-&gt;ctrSubmit, newlcnfinfo-&gt;mutCtrSubmit);
			CHKiRet(statsobj.AddCounter(newlcnfinfo-&gt;stats, UCHAR_CONSTANT(&quot;submitted&quot;),
				ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(newlcnfinfo-&gt;ctrSubmit)));
			STATSCOUNTER_INIT(newlcnfinfo-&gt;ctrDisallowed, newlcnfinfo-&gt;mutCtrDisallowed);
			CHKiRet(statsobj.AddCounter(newlcnfinfo-&gt;stats, UCHAR_CONSTANT(&quot;disallowed&quot;),
				ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(newlcnfinfo-&gt;ctrDisallowed)));
			CHKiRet(statsobj.ConstructFinalize(newlcnfinfo-&gt;stats));
			/* link to list. Order must be preserved to take care for
			 * conflicting matches.
			 */
			if(lcnfRoot == NULL)
				lcnfRoot = newlcnfinfo;
			if(lcnfLast == NULL)
				lcnfLast = newlcnfinfo;
			else {
				lcnfLast-&gt;next = newlcnfinfo;
				lcnfLast = newlcnfinfo;
			}
		}
	} else {
		LogError(0, NO_ERRCODE, &quot;imudp: Could not create udp listener,&quot;
				&quot; ignoring port %s bind-address %s.&quot;,
				port, bindAddr);
	}

finalize_it:
	if(iRet != RS_RET_OK) {
		if(newlcnfinfo != NULL) {
			if(newlcnfinfo-&gt;ratelimiter != NULL)
				ratelimitDestruct(newlcnfinfo-&gt;ratelimiter);
			if(newlcnfinfo-&gt;pInputName != NULL)
				prop.Destruct(&amp;newlcnfinfo-&gt;pInputName);
			if(newlcnfinfo-&gt;stats != NULL)
				statsobj.Destruct(&amp;newlcnfinfo-&gt;stats);
			free(newlcnfinfo);
		}
		/* close the rest of the open sockets as there's
		   nowhere to put them */
		for(; iSrc &lt;= newSocks[0]; iSrc++) {
			close(newSocks[iSrc]);
		}
	}

	free(newSocks);
	RETiRet;
}


static inline void
std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
{
	LogError(0, NO_ERRCODE, &quot;imudp: ruleset '%s' for %s:%s not found - &quot;
			&quot;using default ruleset instead&quot;, inst-&gt;pszBindRuleset,
			inst-&gt;pszBindAddr == NULL ? &quot;*&quot; : (char*) inst-&gt;pszBindAddr,
			inst-&gt;pszBindPort);
}


/* This function processes received data. It provides unified handling
 * in cases where recvmmsg() is available and not.
 */
static rsRetVal
processPacket(struct lstn_s *lstn, struct sockaddr_storage *frominetPrev, int *pbIsPermitted,
	uchar *rcvBuf, ssize_t lenRcvBuf, struct syslogTime *stTime, time_t ttGenTime,
	struct sockaddr_storage *frominet, socklen_t socklen, multi_submit_t *multiSub)
{
	DEFiRet;
	smsg_t *pMsg = NULL;

	if(lenRcvBuf == 0)
		FINALIZE; /* this looks a bit strange, but practice shows it happens... */

	/* if we reach this point, we had a good receive and can process the packet received */
	/* check if we have a different sender than before, if so, we need to query some new values */
	if(bDoACLCheck) {
		socklen = sizeof(struct sockaddr_storage);
		if(net.CmpHost(frominet, frominetPrev, socklen) != 0) {
			memcpy(frominetPrev, frominet, socklen); /* update cache indicator */
			/* Here we check if a host is permitted to send us syslog messages. If it isn't,
			 * we do not further process the message but log a warning (if we are
			 * configured to do this). However, if the check would require name resolution,
			 * it is postponed to the main queue. See also my blog post at
			 * http://blog.gerhards.net/2009/11/acls-imudp-and-accepting-messages.html
			 * rgerhards, 2009-11-16
			 */
			*pbIsPermitted = net.isAllowedSender2((uchar*)&quot;UDP&quot;,
					    (struct sockaddr *)frominet, &quot;&quot;, 0);

			if(*pbIsPermitted == 0) {
				DBGPRINTF(&quot;msg is not from an allowed sender\n&quot;);
				STATSCOUNTER_INC(lstn-&gt;ctrDisallowed, lstn-&gt;mutCtrDisallowed);
				if(glbl.GetOptionDisallowWarning(runModConf-&gt;pConf)) {
					LogError(0, NO_ERRCODE,
						&quot;imudp: UDP message from disallowed sender discarded&quot;);
				}
			}
		}
	} else {
		*pbIsPermitted = 1; /* no check -&gt; everything permitted */
	}

	DBGPRINTF(&quot;recv(%d,%d),acl:%d,msg:%.*s\n&quot;, lstn-&gt;sock, (int) lenRcvBuf, *pbIsPermitted,
			(int)lenRcvBuf, rcvBuf);

	if(*pbIsPermitted != 0)  {
		/* we now create our own message object and submit it to the queue */
		CHKiRet(msgConstructWithTime(&amp;pMsg, stTime, ttGenTime));
		MsgSetRawMsg(pMsg, (char*)rcvBuf, lenRcvBuf);
		MsgSetInputName(pMsg, lstn-&gt;pInputName);
		MsgSetRuleset(pMsg, lstn-&gt;pRuleset);
		MsgSetFlowControlType(pMsg, eFLOWCTL_NO_DELAY);
		if(lstn-&gt;dfltTZ != NULL)
			MsgSetDfltTZ(pMsg, (char*) lstn-&gt;dfltTZ);
		pMsg-&gt;msgFlags  = NEEDS_PARSING | PARSE_HOSTNAME | NEEDS_DNSRESOL;
		if(*pbIsPermitted == 2) {
			pMsg-&gt;msgFlags |= NEEDS_ACLCHK_U; /* request ACL check after resolution */
		}
		if(runModConf-&gt;bPreserveCase) {
			pMsg-&gt;msgFlags |= PRESERVE_CASE; /* preserve case of fromhost */
		}
		CHKiRet(msgSetFromSockinfo(pMsg, frominet));
		CHKiRet(ratelimitAddMsg(lstn-&gt;ratelimiter, multiSub, pMsg));
		STATSCOUNTER_INC(lstn-&gt;ctrSubmit, lstn-&gt;mutCtrSubmit);
	}

finalize_it:
	if(iRet != RS_RET_OK) {
		if(pMsg != NULL &amp;&amp; iRet != RS_RET_DISCARDMSG) {
			msgDestruct(&amp;pMsg);
		}
	}

	RETiRet;
}




/* The following &quot;two&quot; functions are helpers to runInput. Actually, it is
 * just one function. Depending on whether or not we have recvmmsg(),
 * an appropriate version is compiled (as such we need to maintain both!).
 */
#ifdef HAVE_RECVMMSG
static rsRetVal
processSocket(struct wrkrInfo_s *pWrkr, struct lstn_s *lstn, struct sockaddr_storage *frominetPrev,
int *pbIsPermitted)
{
	DEFiRet;
	int iNbrTimeUsed;
	time_t ttGenTime = 0; /* to avoid clang static analyzer false positive */
		/* note: we do never use this time, because we always get a
		 * requery below on first loop iteration */
	struct syslogTime stTime;
	char errStr[1024];
	smsg_t *pMsgs[CONF_NUM_MULTISUB];
	multi_submit_t multiSub;
	int nelem;
	int i;

	multiSub.ppMsgs = pMsgs;
	multiSub.maxElem = CONF_NUM_MULTISUB;
	multiSub.nElem = 0;
	iNbrTimeUsed = 0;
	while(1) { /* loop is terminated if we have a &quot;bad&quot; receive, done below in the body */
		if(pWrkr-&gt;pThrd-&gt;bShallStop == RSTRUE)
			ABORT_FINALIZE(RS_RET_FORCE_TERM);
		memset(pWrkr-&gt;recvmsg_iov, 0, runModConf-&gt;batchSize * sizeof(struct iovec));
		memset(pWrkr-&gt;recvmsg_mmh, 0, runModConf-&gt;batchSize * sizeof(struct mmsghdr));
		for(i = 0 ; i &lt; runModConf-&gt;batchSize ; ++i) {
			pWrkr-&gt;recvmsg_iov[i].iov_base = pWrkr-&gt;pRcvBuf+(i*(iMaxLine+1));
			pWrkr-&gt;recvmsg_iov[i].iov_len = iMaxLine;
			pWrkr-&gt;recvmsg_mmh[i].msg_hdr.msg_namelen = sizeof(struct sockaddr_storage);
			pWrkr-&gt;recvmsg_mmh[i].msg_hdr.msg_name = &amp;(pWrkr-&gt;frominet[i]);
			pWrkr-&gt;recvmsg_mmh[i].msg_hdr.msg_iov = &amp;(pWrkr-&gt;recvmsg_iov[i]);
			pWrkr-&gt;recvmsg_mmh[i].msg_hdr.msg_iovlen = 1;
		}
		nelem = recvmmsg(lstn-&gt;sock, pWrkr-&gt;recvmsg_mmh, runModConf-&gt;batchSize, 0, NULL);
		STATSCOUNTER_INC(pWrkr-&gt;ctrCall_recvmmsg, pWrkr-&gt;mutCtrCall_recvmmsg);
		DBGPRINTF(&quot;imudp: recvmmsg returned %d\n&quot;, nelem);
		if(nelem &lt; 0 &amp;&amp; errno == ENOSYS) {
			/* be careful: some versions of valgrind do not support recvmmsg()! */
			DBGPRINTF(&quot;imudp: error ENOSYS on call to recvmmsg() - fall back to recvmsg\n&quot;);
			nelem = recvmsg(lstn-&gt;sock, &amp;(pWrkr-&gt;recvmsg_mmh[0].msg_hdr), 0);
			STATSCOUNTER_INC(pWrkr-&gt;ctrCall_recvmsg, pWrkr-&gt;mutCtrCall_recvmsg);
			if(nelem &gt;= 0) {
				pWrkr-&gt;recvmsg_mmh[0].msg_len = nelem;
				nelem = 1;
			}
		}
		if(nelem &lt; 0) {
			if(errno != EINTR &amp;&amp; errno != EAGAIN) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				DBGPRINTF(&quot;INET socket error: %d = %s.\n&quot;, errno, errStr);
				LogError(errno, NO_ERRCODE, &quot;imudp: error receiving on socket: %s&quot;, errStr);
			}
			ABORT_FINALIZE(RS_RET_ERR);
			// this most often is NOT an error, state is not checked by caller!
		}

		if((runModConf-&gt;iTimeRequery == 0) || (iNbrTimeUsed++ % runModConf-&gt;iTimeRequery) == 0) {
			datetime.getCurrTime(&amp;stTime, &amp;ttGenTime, TIME_IN_LOCALTIME);
		}

		pWrkr-&gt;ctrMsgsRcvd += nelem;
		for(i = 0 ; i &lt; nelem ; ++i) {
			processPacket(lstn, frominetPrev, pbIsPermitted,
				pWrkr-&gt;recvmsg_mmh[i].msg_hdr.msg_iov-&gt;iov_base,
				pWrkr-&gt;recvmsg_mmh[i].msg_len, &amp;stTime, ttGenTime, &amp;(pWrkr-&gt;frominet[i]),
				pWrkr-&gt;recvmsg_mmh[i].msg_hdr.msg_namelen, &amp;multiSub);
		}
	}

finalize_it:
	multiSubmitFlush(&amp;multiSub);
	RETiRet;
}
#else /* we do not have recvmmsg() */
/* This function is a helper to runInput. I have extracted it
 * from the main loop just so that we do not have that large amount of code
 * in a single place. This function takes a socket and pulls messages from
 * it until the socket does not have any more waiting.
 * rgerhards, 2008-01-08
 * We try to read from the file descriptor until there
 * is no more data. This is done in the hope to get better performance
 * out of the system. However, this also means that a descriptor
 * monopolizes processing while it contains data. This can lead to
 * data loss in other descriptors. However, if the system is incapable of
 * handling the workload, we will loss data in any case. So it doesn't really
 * matter where the actual loss occurs - it is always random, because we depend
 * on scheduling order. -- rgerhards, 2008-10-02
 */
static rsRetVal
processSocket(struct wrkrInfo_s *pWrkr, struct lstn_s *lstn, struct sockaddr_storage *frominetPrev,
int *pbIsPermitted)
{
	int iNbrTimeUsed;
	time_t ttGenTime;
	struct syslogTime stTime;
	ssize_t lenRcvBuf;
	struct sockaddr_storage frominet;
	multi_submit_t multiSub;
	smsg_t *pMsgs[CONF_NUM_MULTISUB];
	char errStr[1024];
	struct msghdr mh;
	struct iovec iov[1];
	DEFiRet;

	multiSub.ppMsgs = pMsgs;
	multiSub.maxElem = CONF_NUM_MULTISUB;
	multiSub.nElem = 0;
	iNbrTimeUsed = 0;
	while(1) { /* loop is terminated if we have a bad receive, done below in the body */
		if(pWrkr-&gt;pThrd-&gt;bShallStop == RSTRUE)
			ABORT_FINALIZE(RS_RET_FORCE_TERM);
		memset(iov, 0, sizeof(iov));
		iov[0].iov_base = pWrkr-&gt;pRcvBuf;
		iov[0].iov_len = iMaxLine;
		memset(&amp;mh, 0, sizeof(mh));
		mh.msg_name = &amp;frominet;
		mh.msg_namelen = sizeof(struct sockaddr_storage);
		mh.msg_iov = iov;
		mh.msg_iovlen = 1;
		lenRcvBuf = recvmsg(lstn-&gt;sock, &amp;mh, 0);
		STATSCOUNTER_INC(pWrkr-&gt;ctrCall_recvmsg, pWrkr-&gt;mutCtrCall_recvmsg);
		if(lenRcvBuf &lt; 0) {
			if(errno != EINTR &amp;&amp; errno != EAGAIN) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				DBGPRINTF(&quot;INET socket error: %d = %s.\n&quot;, errno, errStr);
				LogError(errno, NO_ERRCODE, &quot;imudp: error receiving on socket: %s&quot;, errStr);
			}
			ABORT_FINALIZE(RS_RET_ERR);
			// this most often is NOT an error, state is not checked by caller!
		}

		++pWrkr-&gt;ctrMsgsRcvd;
		if((runModConf-&gt;iTimeRequery == 0) || (iNbrTimeUsed++ % runModConf-&gt;iTimeRequery) == 0) {
			datetime.getCurrTime(&amp;stTime, &amp;ttGenTime, TIME_IN_LOCALTIME);
		}

		CHKiRet(processPacket(lstn, frominetPrev, pbIsPermitted, pWrkr-&gt;pRcvBuf, lenRcvBuf, &amp;stTime,
			ttGenTime, &amp;frominet, mh.msg_namelen, &amp;multiSub));
	}


finalize_it:
	multiSubmitFlush(&amp;multiSub);
	RETiRet;
}
#endif /* #ifdef HAVE_RECVMMSG */


/* check configured scheduling priority.
 * Precondition: iSchedPolicy must have been set
 */
static rsRetVal
checkSchedulingPriority(modConfData_t *modConf)
{
	DEFiRet;

#ifdef HAVE_SCHED_GET_PRIORITY_MAX
	if(   modConf-&gt;iSchedPrio &lt; sched_get_priority_min(modConf-&gt;iSchedPolicy)
	   || modConf-&gt;iSchedPrio &gt; sched_get_priority_max(modConf-&gt;iSchedPolicy)) {
		LogError(0, NO_ERRCODE,
			&quot;imudp: scheduling priority %d out of range (%d - %d)&quot;
			&quot; for scheduling policy '%s' - ignoring settings&quot;,
			modConf-&gt;iSchedPrio,
			sched_get_priority_min(modConf-&gt;iSchedPolicy),
			sched_get_priority_max(modConf-&gt;iSchedPolicy),
			modConf-&gt;pszSchedPolicy);
		ABORT_FINALIZE(RS_RET_VALIDATION_RUN);
	}
finalize_it:
#endif
	RETiRet;
}


/* check scheduling policy string and, if valid, set its
 * numeric equivalent in current load config
 */
static rsRetVal
checkSchedulingPolicy(modConfData_t *modConf)
{
	DEFiRet;

	if (0) { /* trick to use conditional compilation */
#ifdef SCHED_FIFO
	} else if (!strcasecmp((char*)modConf-&gt;pszSchedPolicy, &quot;fifo&quot;)) {
		modConf-&gt;iSchedPolicy = SCHED_FIFO;
#endif
#ifdef SCHED_RR
	} else if (!strcasecmp((char*)modConf-&gt;pszSchedPolicy, &quot;rr&quot;)) {
		modConf-&gt;iSchedPolicy = SCHED_RR;
#endif
#ifdef SCHED_OTHER
	} else if (!strcasecmp((char*)modConf-&gt;pszSchedPolicy, &quot;other&quot;)) {
		modConf-&gt;iSchedPolicy = SCHED_OTHER;
#endif
	} else {
		LogError(errno, NO_ERRCODE,
			    &quot;imudp: invalid scheduling policy '%s' &quot;
			    &quot;- ignoring setting&quot;, modConf-&gt;pszSchedPolicy);
		ABORT_FINALIZE(RS_RET_ERR_SCHED_PARAMS);
	}
finalize_it:
	RETiRet;
}

/* checks scheduling parameters during config check phase */
static rsRetVal
checkSchedParam(modConfData_t *modConf)
{
	DEFiRet;

	if(modConf-&gt;pszSchedPolicy != NULL &amp;&amp; modConf-&gt;iSchedPrio == SCHED_PRIO_UNSET) {
		LogError(0, RS_RET_ERR_SCHED_PARAMS,
			&quot;imudp: scheduling policy set, but without priority - ignoring settings&quot;);
		ABORT_FINALIZE(RS_RET_ERR_SCHED_PARAMS);
	} else if(modConf-&gt;pszSchedPolicy == NULL &amp;&amp; modConf-&gt;iSchedPrio != SCHED_PRIO_UNSET) {
		LogError(0, RS_RET_ERR_SCHED_PARAMS,
			&quot;imudp: scheduling priority set, but without policy - ignoring settings&quot;);
		ABORT_FINALIZE(RS_RET_ERR_SCHED_PARAMS);
	} else if(modConf-&gt;pszSchedPolicy != NULL &amp;&amp; modConf-&gt;iSchedPrio != SCHED_PRIO_UNSET) {
		/* we have parameters set, so check them */
		CHKiRet(checkSchedulingPolicy(modConf));
		CHKiRet(checkSchedulingPriority(modConf));
	} else { /* nothing set */
		modConf-&gt;iSchedPrio = SCHED_PRIO_UNSET; /* prevents doing the activation call */
	}
#ifndef HAVE_PTHREAD_SETSCHEDPARAM
	LogError(0, NO_ERRCODE,
		&quot;imudp: cannot set thread scheduling policy, &quot;
		&quot;pthread_setschedparam() not available&quot;);
	ABORT_FINALIZE(RS_RET_ERR_SCHED_PARAMS);
#endif

finalize_it:
	if(iRet != RS_RET_OK)
		modConf-&gt;iSchedPrio = SCHED_PRIO_UNSET; /* prevents doing the activation call */

	RETiRet;
}

/* set the configured scheduling policy (if possible) */
static rsRetVal
setSchedParams(modConfData_t *modConf)
{
	DEFiRet;

#	ifdef HAVE_PTHREAD_SETSCHEDPARAM
	int err;
	struct sched_param sparam;

	if(modConf-&gt;iSchedPrio == SCHED_PRIO_UNSET)
		FINALIZE;

	memset(&amp;sparam, 0, sizeof sparam);
	sparam.sched_priority = modConf-&gt;iSchedPrio;
	dbgprintf(&quot;imudp trying to set sched policy to '%s', prio %d\n&quot;,
		  modConf-&gt;pszSchedPolicy, modConf-&gt;iSchedPrio);
	err = pthread_setschedparam(pthread_self(), modConf-&gt;iSchedPolicy, &amp;sparam);
	if(err != 0) {
		LogError(err, NO_ERRCODE, &quot;imudp: pthread_setschedparam() failed - ignoring&quot;);
	}
finalize_it:
#	endif

	RETiRet;
}


/* This function implements the main reception loop. Depending on the environment,
 * we either use the traditional (but slower) select() or the Linux-specific epoll()
 * interface. ./configure settings control which one is used.
 * rgerhards, 2009-09-09
 */
#if defined(HAVE_EPOLL_CREATE1) || defined(HAVE_EPOLL_CREATE)
#define NUM_EPOLL_EVENTS 10
static rsRetVal
rcvMainLoop(struct wrkrInfo_s *const __restrict__ pWrkr)
{
	DEFiRet;
	int nfds;
	int efd;
	int i;
	struct sockaddr_storage frominetPrev;
	int bIsPermitted;
	struct epoll_event *udpEPollEvt = NULL;
	struct epoll_event currEvt[NUM_EPOLL_EVENTS];
	char errStr[1024];
	struct lstn_s *lstn;
	int nLstn;

	/* start &quot;name caching&quot; algo by making sure the previous system indicator
	 * is invalidated.
	 */
	bIsPermitted = 0;
	memset(&amp;frominetPrev, 0, sizeof(frominetPrev));

	/* count num listeners -- do it here in order to avoid inconsistency */
	nLstn = 0;
	for(lstn = lcnfRoot ; lstn != NULL ; lstn = lstn-&gt;next)
		++nLstn;

	if(nLstn == 0) {
		LogError(errno, RS_RET_ERR,
			&quot;imudp error: we have 0 listeners, terminating&quot;
			&quot;worker thread&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	CHKmalloc(udpEPollEvt = calloc(nLstn, sizeof(struct epoll_event)));

#if defined(EPOLL_CLOEXEC) &amp;&amp; defined(HAVE_EPOLL_CREATE1)
	DBGPRINTF(&quot;imudp uses epoll_create1()\n&quot;);
	efd = epoll_create1(EPOLL_CLOEXEC);
	if(efd &lt; 0 &amp;&amp; errno == ENOSYS)
#endif
	{
		DBGPRINTF(&quot;imudp uses epoll_create()\n&quot;);
		efd = epoll_create(NUM_EPOLL_EVENTS);
	}

	if(efd &lt; 0) {
		DBGPRINTF(&quot;epoll_create1() could not create fd\n&quot;);
		ABORT_FINALIZE(RS_RET_IO_ERROR);
	}

	/* fill the epoll set - we need to do this only once, as the set
	 * can not change dyamically.
	 */
	i = 0;
	for(lstn = lcnfRoot ; lstn != NULL ; lstn = lstn-&gt;next) {
		if(lstn-&gt;sock != -1) {
			udpEPollEvt[i].events = EPOLLIN | EPOLLET;
			udpEPollEvt[i].data.ptr = lstn;
			if(epoll_ctl(efd, EPOLL_CTL_ADD,  lstn-&gt;sock, &amp;(udpEPollEvt[i])) &lt; 0) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				LogError(errno, NO_ERRCODE, &quot;epoll_ctrl failed on fd %d with %s\n&quot;,
					lstn-&gt;sock, errStr);
			}
		}
		i++;
	}

	while(1) {
		/* wait for io to become ready */
		nfds = epoll_wait(efd, currEvt, NUM_EPOLL_EVENTS, -1);
		DBGPRINTF(&quot;imudp: epoll_wait() returned with %d fds\n&quot;, nfds);

		if(pWrkr-&gt;pThrd-&gt;bShallStop == RSTRUE)
			break; /* terminate input! */

		for(i = 0 ; i &lt; nfds ; ++i) {
			processSocket(pWrkr, currEvt[i].data.ptr, &amp;frominetPrev, &amp;bIsPermitted);
		}
		if(pWrkr-&gt;pThrd-&gt;bShallStop == RSTRUE)
			break; /* terminate input! */
	}

finalize_it:
	if(udpEPollEvt != NULL)
		free(udpEPollEvt);

	RETiRet;
}
#else /* #if HAVE_EPOLL_CREATE1 */
/* this is the code for the select() interface */
static rsRetVal ATTR_NONNULL()
rcvMainLoop(struct wrkrInfo_s *const __restrict__ pWrkr)
{
	DEFiRet;
	int nfds;
	struct sockaddr_storage frominetPrev;
	int bIsPermitted;
	int i = 0;
	struct lstn_s *lstn;

	DBGPRINTF(&quot;imudp uses poll() [ex-select]\n&quot;);
	/* start &quot;name caching&quot; algo by making sure the previous system indicator
	 * is invalidated. */
	bIsPermitted = 0;
	memset(&amp;frominetPrev, 0, sizeof(frominetPrev));

	/* setup poll() subsystem */
	int nfd = 0;
	for(lstn = lcnfRoot ; lstn != NULL ; lstn = lstn-&gt;next) {
		if(lstn-&gt;sock != -1) {
			if(Debug) {
				net.debugListenInfo(lstn-&gt;sock, (char*)&quot;UDP&quot;);
			}
			++nfd;
		}
	}
	struct pollfd *const pollfds = calloc(nfd, sizeof(struct pollfd));
	CHKmalloc(pollfds);

	for(lstn = lcnfRoot ; lstn != NULL ; lstn = lstn-&gt;next) {
		assert(i &lt; nfd);
		if (lstn-&gt;sock != -1) {
			pollfds[i].fd = lstn-&gt;sock;
			pollfds[i].events = POLLIN;
			++i;
		}
	}

	while(1) {
		DBGPRINTF(&quot;--------imudp calling poll() on %d fds\n&quot;, nfd);
		nfds = poll(pollfds, nfd, -1);
		if(glbl.GetGlobalInputTermState() == 1)
			break; /* terminate input! */

		if(nfds &lt; 0) {
			if(errno == EINTR) {
				DBGPRINTF(&quot;imudp: EINTR occurred\n&quot;);
			} else {
				LogMsg(errno, RS_RET_POLL_ERR, LOG_WARNING, &quot;imudp: poll &quot;
					&quot;system call failed, may cause further troubles&quot;);
			}
			nfds = 0;
		}

		i = 0;
		for(lstn = lcnfRoot ; nfds &amp;&amp; lstn != NULL ; lstn = lstn-&gt;next) {
			assert(i &lt; nfd);
			if(lstn-&gt;sock != -1) {
				if(glbl.GetGlobalInputTermState() == 1)
					ABORT_FINALIZE(RS_RET_FORCE_TERM); /* terminate input! */
				if(pollfds[i].revents &amp; POLLIN) {
					processSocket(pWrkr, lstn, &amp;frominetPrev, &amp;bIsPermitted);
					--nfds;
				}
				++i;
			}
	       }
	       /* end of a run, back to loop for next recv() */
	}

finalize_it:
	RETiRet;
}
#endif /* #if HAVE_EPOLL_CREATE1 */


static rsRetVal
createListner(es_str_t *port, struct cnfparamvals *pvals)
{
	instanceConf_t *inst;
	int i;
	int bAppendPortUsed = 0;
	DEFiRet;

	CHKiRet(createInstance(&amp;inst));
	inst-&gt;pszBindPort = (uchar*)es_str2cstr(port, NULL);
	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(inppblk.descr[i].name, &quot;port&quot;)) {
			continue;	/* array, handled by caller */
		} else if(!strcmp(inppblk.descr[i].name, &quot;name&quot;)) {
			if(inst-&gt;inputname != NULL) {
				LogError(0, RS_RET_INVALID_PARAMS, &quot;imudp: name and inputname &quot;
						&quot;parameter specified - only one can be used&quot;);
				ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
			}
			inst-&gt;inputname = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, &quot;name.appendport&quot;)) {
			if(bAppendPortUsed) {
				LogError(0, RS_RET_INVALID_PARAMS, &quot;imudp: name.appendport and &quot;
						&quot;inputname.appendport parameter specified - only one can be used&quot;);
				ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
			}
			inst-&gt;bAppendPortToInpname = (int) pvals[i].val.d.n;
			bAppendPortUsed = 1;
		} else if(!strcmp(inppblk.descr[i].name, &quot;inputname&quot;)) {
			LogError(0, RS_RET_DEPRECATED , &quot;imudp: deprecated parameter inputname &quot;
					&quot;used. Suggest to use name instead&quot;);
			if(inst-&gt;inputname != NULL) {
				LogError(0, RS_RET_INVALID_PARAMS, &quot;imudp: name and inputname &quot;
						&quot;parameter specified - only one can be used&quot;);
				ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
			}
			inst-&gt;inputname = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, &quot;inputname.appendport&quot;)) {
			LogError(0, RS_RET_DEPRECATED , &quot;imudp: deprecated parameter inputname.appendport &quot;
					&quot;used. Suggest to use name.appendport instead&quot;);
			if(bAppendPortUsed) {
				LogError(0, RS_RET_INVALID_PARAMS, &quot;imudp: name.appendport and &quot;
						&quot;inputname.appendport parameter specified - only one can be used&quot;);
<A NAME="1"></A>				ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
			}
			bAppendPortUsed = 1;
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match834-0.html#1',2,'match834-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>			inst-&gt;bAppendPortToInpname = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;defaulttz&quot;)) {
			inst-&gt;dfltTZ = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
<A NAME="3"></A>		} else if(!strcmp(inppblk.descr[i].name, &quot;address&quot;)) {
			inst-&gt;pszBindAddr = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, &quot;device&quot;)) {
			inst-&gt;pszBindDevice = (char*)es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT><FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match834-0.html#3',2,'match834-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>
		} else if(!strcmp(inppblk.descr[i].name, &quot;ruleset&quot;)) {
			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, &quot;ratelimit.burst&quot;)) {
			inst-&gt;ratelimitBurst = (unsigned int) pvals[i].val.d.n;</B></FONT>
		} else if(!strcmp(inppblk.descr[i].name, &quot;ratelimit.interval&quot;)) {
			inst-&gt;ratelimitInterval = (unsigned int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;rcvbufsize&quot;)) {
			const uint64_t val = pvals[i].val.d.n;
			if(val &gt; 1024 * 1024 * 1024) {
				LogError(0, RS_RET_MISSING_CNFPARAMS,
					&quot;imudp: rcvbufsize maximum is 1 GiB, using &quot;
					&quot;default instead&quot;);
			} else {
				inst-&gt;rcvbuf = (int) val;
			}
		} else if(!strcmp(inppblk.descr[i].name, &quot;ipfreebind&quot;)) {
			inst-&gt;ipfreebind = (int) pvals[i].val.d.n;
		} else {
			dbgprintf(&quot;imudp: program error, non-handled &quot;
			  &quot;param '%s'\n&quot;, inppblk.descr[i].name);
		}
	}
finalize_it:
	RETiRet;
}


BEGINnewInpInst
	struct cnfparamvals *pvals;
	int i;
	int portIdx;
CODESTARTnewInpInst
	DBGPRINTF(&quot;newInpInst (imudp)\n&quot;);

	if((pvals = nvlstGetParams(lst, &amp;inppblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if(Debug) {
		dbgprintf(&quot;input param blk in imudp:\n&quot;);
		cnfparamsPrint(&amp;inppblk, pvals);
	}

	portIdx = cnfparamGetIdx(&amp;inppblk, &quot;port&quot;);
	assert(portIdx != -1);
	for(i = 0 ; i &lt;  pvals[portIdx].val.d.ar-&gt;nmemb ; ++i) {
		createListner(pvals[portIdx].val.d.ar-&gt;arr[i], pvals);
	}

finalize_it:
CODE_STD_FINALIZERnewInpInst
	cnfparamvalsDestruct(pvals, &amp;inppblk);
ENDnewInpInst


BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	/* init our settings */
	loadModConf-&gt;configSetViaV2Method = 0;
	loadModConf-&gt;wrkrMax = 1; /* conservative, but least msg reordering */
	loadModConf-&gt;batchSize = BATCH_SIZE_DFLT;
	loadModConf-&gt;iTimeRequery = TIME_REQUERY_DFLT;
	loadModConf-&gt;iSchedPrio = SCHED_PRIO_UNSET;
	loadModConf-&gt;pszSchedPolicy = NULL;
	loadModConf-&gt;bPreserveCase = 0; /* off */
	bLegacyCnfModGlobalsPermitted = 1;
	/* init legacy config vars */
	cs.pszBindRuleset = NULL;
	cs.pszSchedPolicy = NULL;
	cs.pszBindAddr = NULL;
	cs.pszBindDevice = NULL;
	cs.iSchedPrio = SCHED_PRIO_UNSET;
	cs.iTimeRequery = TIME_REQUERY_DFLT;
ENDbeginCnfLoad


BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
	int wrkrMax;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;imudp: error processing module &quot;
				&quot;config parameters [module(...)]&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf(&quot;module (global) param blk for imudp:\n&quot;);
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(modpblk.descr[i].name, &quot;timerequery&quot;)) {
			loadModConf-&gt;iTimeRequery = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;batchsize&quot;)) {
			loadModConf-&gt;batchSize = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;schedulingpriority&quot;)) {
			loadModConf-&gt;iSchedPrio = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, &quot;schedulingpolicy&quot;)) {
			loadModConf-&gt;pszSchedPolicy = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, &quot;threads&quot;)) {
			wrkrMax = (int) pvals[i].val.d.n;
			if(wrkrMax &gt; MAX_WRKR_THREADS) {
				LogError(0, RS_RET_PARAM_ERROR, &quot;imudp: configured for %d&quot;
						&quot;worker threads, but maximum permitted is %d&quot;,
						wrkrMax, MAX_WRKR_THREADS);
				loadModConf-&gt;wrkrMax = MAX_WRKR_THREADS;
			} else {
				loadModConf-&gt;wrkrMax = wrkrMax;
			}
		} else if(!strcmp(modpblk.descr[i].name, &quot;preservecase&quot;)) {
			loadModConf-&gt;bPreserveCase = (int) pvals[i].val.d.n;
		} else {
			dbgprintf(&quot;imudp: program error, non-handled &quot;
			  &quot;param '%s' in beginCnfLoad\n&quot;, modpblk.descr[i].name);
		}
	}

	/* remove all of our legacy handlers, as they can not used in addition
	 * the the new-style config method.
	 */
	bLegacyCnfModGlobalsPermitted = 0;
	loadModConf-&gt;configSetViaV2Method = 1;

finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf

BEGINendCnfLoad
CODESTARTendCnfLoad
	if(!loadModConf-&gt;configSetViaV2Method) {
		/* persist module-specific settings from legacy config system */
		loadModConf-&gt;iSchedPrio = cs.iSchedPrio;
		loadModConf-&gt;iTimeRequery = cs.iTimeRequery;
		if((cs.pszSchedPolicy != NULL) &amp;&amp; (cs.pszSchedPolicy[0] != '\0')) {
			CHKmalloc(loadModConf-&gt;pszSchedPolicy = ustrdup(cs.pszSchedPolicy));
		}
	}

finalize_it:
	loadModConf = NULL; /* done loading */
	/* free legacy config vars */
	free(cs.pszBindRuleset);
	free(cs.pszSchedPolicy);
	free(cs.pszBindAddr);
	free(cs.pszBindDevice);
ENDendCnfLoad


BEGINcheckCnf
	instanceConf_t *inst;
CODESTARTcheckCnf
	checkSchedParam(pModConf); /* this can not cause fatal errors */
	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		std_checkRuleset(pModConf, inst);
	}
	if(pModConf-&gt;root == NULL) {
		LogError(0, RS_RET_NO_LISTNERS , &quot;imudp: module loaded, but &quot;
				&quot;no listeners defined - no input will be gathered&quot;);
		iRet = RS_RET_NO_LISTNERS;
	}
ENDcheckCnf


BEGINactivateCnfPrePrivDrop
	instanceConf_t *inst;
CODESTARTactivateCnfPrePrivDrop
	runModConf = pModConf;
	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		addListner(inst);
	}
	/* if we could not set up any listeners, there is no point in running... */
	if(lcnfRoot == NULL) {
		LogError(0, NO_ERRCODE, &quot;imudp: no listeners could be started, &quot;
				&quot;input not activated.\n&quot;);
		ABORT_FINALIZE(RS_RET_NO_RUN);
	}

finalize_it:
ENDactivateCnfPrePrivDrop


BEGINactivateCnf
	int i;
	int lenRcvBuf;
CODESTARTactivateCnf
	/* caching various settings */
	iMaxLine = glbl.GetMaxLine(runConf);
	lenRcvBuf = iMaxLine + 1;
#	ifdef HAVE_RECVMMSG
	lenRcvBuf *= runModConf-&gt;batchSize;
#	endif
	DBGPRINTF(&quot;imudp: config params iMaxLine %d, lenRcvBuf %d\n&quot;, iMaxLine, lenRcvBuf);
	for(i = 0 ; i &lt; runModConf-&gt;wrkrMax ; ++i) {
#		ifdef HAVE_RECVMMSG
		CHKmalloc(wrkrInfo[i].recvmsg_iov = malloc(runModConf-&gt;batchSize * sizeof(struct iovec)));
		CHKmalloc(wrkrInfo[i].recvmsg_mmh = malloc(runModConf-&gt;batchSize * sizeof(struct mmsghdr)));
		CHKmalloc(wrkrInfo[i].frominet = malloc(runModConf-&gt;batchSize * sizeof(struct sockaddr_storage)));
#		endif
		CHKmalloc(wrkrInfo[i].pRcvBuf = malloc(lenRcvBuf));
		wrkrInfo[i].id = i;
	}
finalize_it:
ENDactivateCnf


BEGINfreeCnf
	instanceConf_t *inst, *del;
CODESTARTfreeCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
		free(inst-&gt;pszBindPort);
		free(inst-&gt;pszBindAddr);
		free(inst-&gt;pszBindDevice);
		free(inst-&gt;pszBindRuleset);
		free(inst-&gt;inputname);
		free(inst-&gt;dfltTZ);
		del = inst;
		inst = inst-&gt;next;
		free(del);
	}
ENDfreeCnf


static void *
wrkr(void *myself)
{
	struct wrkrInfo_s *pWrkr = (struct wrkrInfo_s*) myself;
	uchar thrdName[32];

	snprintf((char*)thrdName, sizeof(thrdName), &quot;imudp(w%d)&quot;, pWrkr-&gt;id);
#	if defined(HAVE_PRCTL) &amp;&amp; defined(PR_SET_NAME)
	/* set thread name - we ignore if the call fails, has no harsh consequences... */
	if(prctl(PR_SET_NAME, thrdName, 0, 0, 0) != 0) {
		DBGPRINTF(&quot;prctl failed, not setting thread name for '%s'\n&quot;, thrdName);
	}
#	endif
	dbgOutputTID((char*)thrdName);

	/* Note well: the setting of scheduling parameters will not work
	 * when we dropped privileges (if the user is not sufficiently
	 * privileged, of course). Howerver, we can't change the
	 * scheduling params in PrePrivDrop(), as at that point our thread
	 * is not yet created. So at least as an interim solution, we do
	 * NOT support both setting sched parameters and dropping
	 * privileges within the same instance.
	 */
	setSchedParams(runModConf);

	/* support statistics gathering */
	statsobj.Construct(&amp;(pWrkr-&gt;stats));
	statsobj.SetName(pWrkr-&gt;stats, thrdName);
	statsobj.SetOrigin(pWrkr-&gt;stats, (uchar*)&quot;imudp&quot;);
	STATSCOUNTER_INIT(pWrkr-&gt;ctrCall_recvmmsg, pWrkr-&gt;mutCtrCall_recvmmsg);
	statsobj.AddCounter(pWrkr-&gt;stats, UCHAR_CONSTANT(&quot;called.recvmmsg&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkr-&gt;ctrCall_recvmmsg));
	STATSCOUNTER_INIT(pWrkr-&gt;ctrCall_recvmsg, pWrkr-&gt;mutCtrCall_recvmsg);
	statsobj.AddCounter(pWrkr-&gt;stats, UCHAR_CONSTANT(&quot;called.recvmsg&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkr-&gt;ctrCall_recvmsg));
	STATSCOUNTER_INIT(pWrkr-&gt;ctrMsgsRcvd, pWrkr-&gt;mutCtrMsgsRcvd);
	statsobj.AddCounter(pWrkr-&gt;stats, UCHAR_CONSTANT(&quot;msgs.received&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkr-&gt;ctrMsgsRcvd));
	statsobj.ConstructFinalize(pWrkr-&gt;stats);

	rcvMainLoop(pWrkr);

	/* cleanup */
	return NULL;
}

/* This function is called to gather input.
 * In essence, it just starts the pool of workers. To save resources,
 * we run one of the workers on our own thread -- otherwise that thread would
 * just idle around and wait for the workers to finish.
 */
BEGINrunInput
	int i;
	pthread_attr_t wrkrThrdAttr;
CODESTARTrunInput
	pthread_attr_init(&amp;wrkrThrdAttr);
	pthread_attr_setstacksize(&amp;wrkrThrdAttr, 4096*1024);
	for(i = 0 ; i &lt; runModConf-&gt;wrkrMax - 1 ; ++i) {
		wrkrInfo[i].pThrd = pThrd;
		pthread_create(&amp;wrkrInfo[i].tid, &amp;wrkrThrdAttr, wrkr, &amp;(wrkrInfo[i]));
	}
	pthread_attr_destroy(&amp;wrkrThrdAttr);

	wrkrInfo[i].pThrd = pThrd;
	wrkrInfo[i].id = i;
	wrkr(&amp;wrkrInfo[i]);

	for(i = 0 ; i &lt; runModConf-&gt;wrkrMax - 1 ; ++i) {
		pthread_kill(wrkrInfo[i].tid, SIGTTIN);
	}
	for(i = 0 ; i &lt; runModConf-&gt;wrkrMax - 1 ; ++i) {
		pthread_join(wrkrInfo[i].tid, NULL);
	}
ENDrunInput


/* initialize and return if will run or not */
BEGINwillRun
CODESTARTwillRun
	net.PrintAllowedSenders(1); /* UDP */
	net.HasRestrictions(UCHAR_CONSTANT(&quot;UDP&quot;), &amp;bDoACLCheck); /* UDP */
ENDwillRun


BEGINafterRun
	struct lstn_s *lstn, *lstnDel;
	int i;
CODESTARTafterRun
	/* do cleanup here */
	net.clearAllowedSenders((uchar*)&quot;UDP&quot;);
	for(lstn = lcnfRoot ; lstn != NULL ; ) {
		statsobj.Destruct(&amp;(lstn-&gt;stats));
		ratelimitDestruct(lstn-&gt;ratelimiter);
		close(lstn-&gt;sock);
		prop.Destruct(&amp;lstn-&gt;pInputName);
		lstnDel = lstn;
		lstn = lstn-&gt;next;
		free(lstnDel);
	}
	lcnfRoot = lcnfLast = NULL;
	for(i = 0 ; i &lt; runModConf-&gt;wrkrMax ; ++i) {
#		ifdef HAVE_RECVMMSG
		free(wrkrInfo[i].recvmsg_iov);
		free(wrkrInfo[i].recvmsg_mmh);
		free(wrkrInfo[i].frominet);
#		endif
		free(wrkrInfo[i].pRcvBuf);
	}
ENDafterRun


BEGINmodExit
CODESTARTmodExit
	/* release what we no longer need */
	objRelease(glbl, CORE_COMPONENT);
	objRelease(statsobj, CORE_COMPONENT);
	objRelease(datetime, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
	objRelease(net, LM_NET_FILENAME);
ENDmodExit


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt

static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	free(cs.pszBindAddr);
	cs.pszBindAddr = NULL;
	free(cs.pszBindDevice);
	cs.pszBindDevice = NULL;
	free(cs.pszSchedPolicy);
	cs.pszSchedPolicy = NULL;
	free(cs.pszBindRuleset);
	cs.pszBindRuleset = NULL;
	cs.iSchedPrio = SCHED_PRIO_UNSET;
	cs.iTimeRequery = TIME_REQUERY_DFLT;/* the default is to query only every second time */
	return RS_RET_OK;
}


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(objUse(net, LM_NET_FILENAME));

	DBGPRINTF(&quot;imudp: version %s initializing\n&quot;, VERSION);
#	ifdef HAVE_RECVMMSG
	DBGPRINTF(&quot;imdup: support for recvmmsg() present\n&quot;);
#	endif

	/* register config file handlers */
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;inputudpserverbindruleset&quot;, 0, eCmdHdlrGetWord,
		NULL, &amp;cs.pszBindRuleset, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;udpserverrun&quot;, 0, eCmdHdlrGetWord,
		addInstance, NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;udpserveraddress&quot;, 0, eCmdHdlrGetWord,
		NULL, &amp;cs.pszBindAddr, STD_LOADABLE_MODULE_ID));
	/* module-global config params - will be disabled in configs that are loaded
	 * via module(...).
	 */
	CHKiRet(regCfSysLineHdlr2((uchar *)&quot;imudpschedulingpolicy&quot;, 0, eCmdHdlrGetWord,
		NULL, &amp;cs.pszSchedPolicy, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)&quot;imudpschedulingpriority&quot;, 0, eCmdHdlrInt,
		NULL, &amp;cs.iSchedPrio, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)&quot;udpservertimerequery&quot;, 0, eCmdHdlrInt,
		NULL, &amp;cs.iTimeRequery, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));

	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;resetconfigvariables&quot;, 1, eCmdHdlrCustomHandler,
		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit
/* vim:set ai:
 */
</PRE>
</div>
  </div>
</body>
</html>
